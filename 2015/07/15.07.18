00:00:19 <mauke> wait, you didn't know that * binds tighter than +?
00:00:26 <mauke> this is grade school stuff
00:00:27 <julianleviston> mauke: that’s correct.
00:00:34 <julianleviston> mauke: in maths I knew.
00:00:38 <julianleviston> mauke: not in haskell
00:00:58 <julianleviston> mauke: I’m sure I’ve read it if it’s the case.
00:00:59 <mniip> julianleviston, the same logic applies
00:01:11 <julianleviston> mniip: what’s the logic?
00:01:21 <mniip> if ~ has higher precedence than =>, then a ~ b => c means (a ~ b) => c
00:01:22 <mauke> what language doesn't make * bind tighter than +? except for smalltalk maybe
00:01:27 <julianleviston> mniip: I don’t see a logical reason why * is tighter than + ?
00:01:31 <mniip> mauke, haskell
00:01:41 <mauke> mniip: ?
00:01:54 <mniip> haskell has no hardcoded precedence :P
00:02:07 <mauke> haskell has a standard library
00:02:10 <mniip> julianleviston, there isn't one
00:02:22 <mniip> mauke, you could shadow * and + with your own
00:03:11 <julianleviston> mauke: Um… I’m not sure. SmallTalk was the third language I learned. I tend not to assume.
00:03:22 <mniip> julianleviston, well, mostly convenience reasons, but that's a different question from "what does a*b+c mean"
00:03:56 <julianleviston> mniip: it depends on the context ;-)
00:04:30 <mniip> you need to develop a sense of default context
00:04:34 <julianleviston> mniip: it’s a form of sequencing, hm? :) 
00:04:48 <julianleviston> mniip: you’re not the first to say this to me! :) Tho non-default contexting is very handy sometimes.
00:05:07 <mniip> so far I've only seen it raise a load of useless questions
00:05:28 <jfeltz> without programmer action, is it possible for "GHC" to lock a file and cause exceptions to be thrown when trying to access its handle, even when access is being controlled to it, i.e. with an MVar? I'm reading through tryRotate in ,https://hackage.haskell.org/package/wai-logger-2.2.4/docs/src/Network-Wai-Logger.html  and I don't understand what motivates the need to catch exceptions on a accessing  a file, if that access is being tightly
00:05:28 <jfeltz>  controlled
00:05:46 <julianleviston> mniip: for example, that video the other day… the context I thought it was was haskell, so I assume that as a default context, hear “arrow” and go off reading Haskell’s arrow stuff only to find later it was CT arrow… ie = function.
00:06:01 <julianleviston> mniip: ouch.
00:06:09 <julianleviston> mniip: these questions aren’t useless to me.
00:06:17 <mniip> julianleviston, it was probably used right after the word "morphism"
00:06:25 <julianleviston> mniip: it was.
00:06:28 <mniip> which instantly identifies what arrows are on the topic
00:06:48 <julianleviston> mniip: well it didn’t to me.
00:07:07 <mniip> also to be entirely correct
00:07:17 <mniip> the arrow typeclass is the class of arrows from CT
00:07:26 <mniip> so you're not too far
00:08:24 <mniip> except the arrow typeclass is about arrows in subcategories of hask
00:10:00 <julianleviston> mniip: is hask Haskell?
00:10:18 <mniip> are you sure you want to know
00:10:21 <mauke> hask is the category of haskell types
00:10:33 <julianleviston> ah ok. “no” is fine.
00:10:35 <julianleviston> thansk mauke 
00:10:57 <julianleviston> something I actually understand :) yay :)
00:11:50 <julianleviston> mauke: is hask something in Haskell? or CT?
00:12:07 <mauke> I'd say "no"
00:12:10 <julianleviston> lol
00:12:12 <julianleviston> ok.
00:12:14 <julianleviston> thanks.
00:12:51 <julianleviston> mauke: gotcha :) https://wiki.haskell.org/Hask thanks.
00:13:36 <fishburne> does any one know how to access a POST array variable in Spock web framework. For example, when there are multiple checkboxes with name like student_name[]. 
00:14:18 <julianleviston> fishburne:  let’s see if I can find out for you
00:15:00 <zipper> Category theory question here:
00:15:18 <funfunctor> Anyone worked with postgresql-simple know how to deal with its exceptions?
00:15:20 <zipper> So a monoid is a category with one object but this one object has many morphisms that keep going around it.
00:15:41 <zipper> So natural numbers including zero form a monoid when partially applied to (+)
00:16:00 <mniip> I'm reading http://stackoverflow.com/q/31484936/2337954 and I'm like what
00:16:04 <zipper> I get how these make a morphism but where is the object here?
00:16:18 <mniip> xor = (/=)
00:16:32 <fishburne> julianleviston: thank you!
00:16:34 <xauth> zipper: I'd say the objects are numbers and the arrows are partial applications of plus to some number.
00:16:44 <mniip> zipper, any fixed number
00:16:46 <julianleviston> fishburne: does the param function not work?
00:17:06 <zipper> Oh
00:17:10 <julianleviston> fishburne:  sorry, param’ ?
00:17:31 <mniip> hmm hold on I need to evaluate
00:17:36 <zipper> That was simple.
00:17:54 <zipper> mniip: Why are you even bothering with uni? You already know so much.
00:18:01 <xauth> zipper: That's why I could give an answer. :)
00:18:06 <mniip> zipper, piece of paper
00:18:17 <mniip> also there are topic taught in uni that I don't know
00:18:17 <zipper> xauth: :)
00:18:23 <zipper> Yeah me too
00:18:28 <zipper> mniip: Which topic?
00:18:34 <mniip> topics*
00:18:44 <zomg> fishburne: technically those post params (and query params) are not arrays. http supports sending multiple params with the same name, some tools (like php) have a builtin thingy that converts names with [] into arrays (with varying results)
00:18:50 <P4Titan> :t <*>
00:18:51 <lambdabot> parse error on input ‘<*>’
00:18:56 <zipper> For me school just gets in the way of learning.
00:19:04 <mniip> zipper, school != uni though
00:19:09 <P4Titan> :t (<*>)
00:19:10 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:19:18 <P4Titan> :t fmap
00:19:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:19:33 <fishburne> julianleviston: i am looking at stuff at http://hackage.haskell.org/package/Spock-0.7.10.0/docs/Web-Spock-Shared.html, but it looks like it is just function that will throw an error if the requred param is not found...
00:20:16 <fishburne> zomg: Yes. That is what I thought.
00:20:29 <julianleviston> fishburne:  does this help : https://github.com/agrafix/funblog/blob/master/src/Web/Forms/Login.hs
00:21:07 <zipper> Well I stopped learning from teachers when I joined uni.
00:21:15 <zipper> I learned a lot in high school.
00:21:16 <xauth> zipper: wait. if every number is an object, and monoids have a single object, then it's not a monoid, is it?
00:21:44 <adarqui> just watched this http://www.techcast.com/events/bigtechday8/maffei-1450/?q=maffei-1450 .. good stuff
00:21:56 <zipper> No that single number and the morphisms around it form the monoid.
00:22:01 <zipper> xauth: ^
00:22:16 <fishburne> julianleviston: but it does not appear to use the [] type input variables...
00:22:55 <fishburne> I think zomg is right in that the functioality i am looking for is implemented on the langauge side rather than specified in the http spec...
00:23:26 <julianleviston> fishburne: HTTP will send a string. I’m pretty sure Scotty will parse params out tho… 
00:23:51 <julianleviston> fishburne:  sorry, scotty.
00:23:56 <julianleviston> fishburne: GUH spock.
00:23:58 <fishburne> it does for normal params...I can get them using params function, no issues with that
00:24:16 <zomg> Doesn't Scotty use wai's requests?
00:24:28 <zomg> There's a parser for request bodies in wai-extra which can be used to pull all post params
00:24:38 <zipper> zomg: Who's asking about WAI?
00:24:46 <zipper> What's the question?
00:24:49 <julianleviston> zipper: fishburne 
00:24:50 <P4Titan> :t (&&&)
00:24:51 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
00:24:53 <zomg> fishburne was asking how to get POST params in Scotty
00:25:10 <julianleviston> zipper:  it’s how to pull out individual checkbox controls from an HTTP POST, assuming I got it right, fishburne 
00:25:14 <zomg> Err sorry not Scotty, Spock
00:25:26 <julianleviston> zipper:  pull out values of checkboxes.
00:25:27 <zomg> (why are all of these things named after Star Trek character, lol)
00:25:45 <zipper> Are we asking about WAI or about a web framework that is WAI compliant?
00:25:46 <julianleviston> zomg:  coz spock came from scotty originally
00:25:53 <zomg> julianleviston: figures =)
00:25:58 <zipper> I can't help, sorry.
00:26:08 <zomg> zipper: spock is wai-compliant yeah
00:26:23 <zomg> that's why I suggested wai-extra's body parser which would do the trick
00:26:47 <zomg> Spock also seems to have some parameter functionality of its own, but it seems a bit vague and random. It gets either route, post or query params... ugh
00:26:51 <fishburne> it is not much of an issue. I can prefix the html form names and write a function to extract values from prefixed keys..
00:27:18 <zomg> fishburne: you would probably need to get all params which have the same name, I've not seen any haskell web framework handle the [] automatically
00:27:39 <zomg> if possible, I would consider sending a JSON body in the post request, this way the parsing could be handled more sanely
00:27:42 <julianleviston> fishburne: can’t you just do what they’re doing in this example? line 113 ? https://github.com/agrafix/funblog/blob/master/src/Web/Blog.hs
00:28:36 <julianleviston> zomg: an HTML form won’t send JSON unless you use AJAX tho right?
00:28:52 <zomg> Yeah
00:29:24 <fishburne> julianleviston: yes. But It is easy to work around this
00:29:56 <julianleviston> fishburne: sweet. Very informative question.
00:31:07 <julianleviston> fishburne: I’d just assumed most web frameworks in haskell would handle all the stuff most web frameworks do out of the box, for some stupid reason.
00:32:22 <fishburne> fishburne: Yes. Me too..But again, considering that an html can send data in what every nested way, would it be possible for a function to return that data in arbitrary formats?
00:32:49 <fishburne> julianleviston: Yes. Me too..But again, considering that an html can send data in what every nested way, would it be possible for a function to return that data in arbitrary formats?
00:33:05 <zomg> I'd imagine so, I mean JSON is fairly arbitrary too, and Aeson gives you it in a variety of nice ways
00:33:10 <julianleviston> fishburne:  I’m not sure what you mean, sorry.
00:35:41 <mauke> plain html forms send a flat list of key/value strings. what's this about nesting?
00:35:51 <fishburne> julianleviston: I mean, you can have a form with input form names student['name'] student['age'
00:36:16 <zomg> fishburne: btw if you use wai-extra, you can do something like `parseRequestBody lbsBackend req` which will give you IO ([Param], [File y])
00:36:27 <zomg> you can get req from Spock
00:36:29 <julianleviston> mauke: nesting is an artificial layer on top. 
00:36:51 <zomg> from the result from parseRequestBody, you'd simply look at the [Param] list, and filter out each param with the same name -> you'd get your list of inputs
00:37:04 <julianleviston> mauke: it’s quite handy for doing things like the above… 
00:37:04 <zomg> (Param is (ByteString, ByteString))
00:37:07 <fishburne> julianleviston: I mean, you can have a form with input form names student['name'] , student['age'], student['birthday']['day'], student['birthday']['month'], and you can have an dictionray with corresponding structure...
00:37:18 <julianleviston> zomg:  yeah, you could build a type for it, and parse it out, right?
00:37:21 <Haskellfant> isn't that simply what params from Web.Spock.Shared does?
00:37:42 <julianleviston> fishburne: dictionary? I *think* haskell uses associative lists or maps 
00:37:48 <zomg> Haskellfant: assuming you don't care about the fact it picks the source for the param fairly arbitrarily. It could be from route, post or query... 
00:38:00 <Haskellfant> fair enough
00:38:21 <zomg> At least in my experience you usually would want to be reasonably explicit about which of those you're using as the data source, especially when it comes to the querystring
00:38:47 <fishburne> zomg: That looks promising. I will try that. Thank you.
00:41:57 <fishburne> zomg: Well, I only had to use the params function which already returns the params in a list of tuples. I just have to filter ones with the same name (first element in tuple)
00:42:32 <fishburne> julianleviston: I mean, In languages like php...
00:42:43 <julianleviston> fishburne:  ah ok.
00:43:20 <julianleviston> fishburne: well you could easily do an associative list parse on params, probably (I’m really not too sure, but haskell is way more capable than PHP, so...)
00:44:06 <julianleviston> fishburne:  did Haskellfant ’s suggestion not help?
00:44:08 <zomg> fishburne: yeah that works too I guess, as long as you're careful to not let it leak in values from the querystring
00:44:48 <fred-fri> http://pastebin.com/knssrKjz noob trying to learn to define custom haskell types
00:44:52 <julianleviston> zomg:  I guess you could specify some kind of type?
00:45:18 <zomg> julianleviston: Spock doesn't let you specify the source which kinda sucks in my opinion
00:46:27 <julianleviston> zomg:  oh. composability for the win (sad when it’s lacking, I guess)
00:47:20 <fishburne> julianleviston, zomg, Haskellfant yes. That will work. But as zomg pointed out, it picks up values from query string also. But since I am using 'Safe' routes from spock, I think there is little chance of injecting an extra parameter...
00:47:48 <zomg> Easy enough to test =)
00:48:31 <julianleviston> fishburne:  I thought all these things usually pick things up from the querystring anyway
00:49:14 <jTT_> :t concatMap
00:49:15 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
00:50:35 <julianleviston> fred-fri: That’s not really how I’d do it...
00:50:44 <zomg> julianleviston: picking up things from query string is a really quick way to enable CSRF or XSS exploits ;)
00:50:54 <julianleviston> fred-fri: I guess I’d need to know what you’re going to do with these types to give any advice, tho.
00:51:04 <fred-fri> julianleviston: uh actually i found this page http://learnyouahaskell.com/making-our-own-types-and-typeclasses where they show how they define person, so nvm 
00:51:09 <jTT_> :t concat . map 
00:51:10 <lambdabot> Foldable ((->) [a1]) => (a1 -> a) -> [a]
00:54:29 <julianleviston> fred-fri: sweet.
00:54:43 <julianleviston> fishburne:  I guess perhaps this is one reason to use yesod instead, maybe… http://www.yesodweb.com/book/forms
00:55:06 <fred-fri> sorry for asking dumb questions =)
00:58:16 <julianleviston> fred-fri: it’s fine. I ask my fair share
00:58:51 <martinvlk>  I don't think we should need to apologise for that... 
00:59:16 <julianleviston> martinvlk: yeah, “there are no dumb questions”, maybe.
00:59:32 <martinvlk> just questions
01:03:56 <Cale> fred-fri: You probably want  data Position = Position { capital :: Integer, risk :: Integer, direction :: Direction, price :: Integer, stopLoss :: Integer }
01:04:19 <julianleviston> Cale: er wasn’t Capital a BigDecimal tho?
01:04:23 <Cale> fred-fri: Writing  data Capital = Num  defines Capital to be a type with only one defined value, called "Num"
01:04:28 <Cale> oh, BigDecimal
01:04:37 <Cale> Well, perhaps some Fixed type then
01:04:51 <Cale> (or Rational, I suppose)
01:06:39 <Cale> fred-fri: You'll get complaints that Num is already defined when you reuse that constructor name in the other data declarations.
01:09:06 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Data-Fixed.html defines some types you can use for exact fixed point arithmetic. For example, Fixed E2 (also named Centi) tends to be useful for currency.
01:14:59 <julianleviston> Hey, can I ask, how do you pronounce $ ? can you pronounce it map ?
01:15:50 <julianleviston> is map just ($) over a List ?
01:15:57 <dramforever> it's function application isn't it?
01:16:07 <julianleviston> yeah it is but how do you say it?
01:16:14 <tsani> I have a function f :: Monad m => a -> m b; how can I get that into (Functor f, Monad m) => f a -> m (f b) ?
01:16:18 <dramforever> I read it as "of"
01:16:42 <WashIrving> :t sequence
01:16:43 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:16:53 <julianleviston> because you’re mapping a function over some input where the input isn’t a list, aren’t you?
01:16:56 <dramforever> tsani: you can't
01:17:04 <tsani> drats
01:17:12 <dramforever> julianleviston: lists? why are you mentioning lists
01:17:26 <julianleviston> dramforever: because “map” is only for lists...
01:17:34 <julianleviston> map is function application over a list’s content.
01:17:35 <dramforever> why are you mentioning map?
01:17:40 <chpatrick> :t \f -> return . fmap f
01:17:41 <lambdabot> (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
01:17:52 <julianleviston> dramforever: because of the type of map and the type of ($)
01:17:53 <chpatrick> tsani: what are you trying to do though?
01:18:00 <julianleviston> :t map
01:18:01 <lambdabot> (a -> b) -> [a] -> [b]
01:18:03 <julianleviston> :t ($)
01:18:04 <lambdabot> (a -> b) -> a -> b
01:18:08 <tsani> Specifically, I have some Maybe values in the IO monad
01:18:15 <dramforever> :t id -- what about this?
01:18:16 <lambdabot> a -> a
01:18:17 <dramforever> =P
01:18:21 <tsani> lol
01:18:46 <Cale> tsani: Can you perhaps explain more what your program is actually doing?
01:19:04 <dramforever> XY Problem spotted! http://xyproblem.info
01:19:08 <julianleviston> dramforever: so there’s no relation? ok.
01:19:09 <tsani> Even more specifically, I have a IO (Maybe CString) and I'd like to get that into a IO (Maybe String)
01:19:24 <tsani> I see peekCString :: CString -> IO String
01:19:58 <chpatrick> :t (>>=(traverse peekCString)
01:19:59 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:20:02 <tsani> The issue that I'm having is that there're "two levels" of binds that I need to do
01:20:05 <Cale> tsani: Well, you probably want to first execute the action, getting a Maybe CString
01:20:06 <julianleviston> dramforever: seems like there’s a relation, tho. mapping a function over head of a single element list is identical to apply that function to that single element as an arg.
01:20:09 <chpatrick> :t (>>= (traverse peekCString))
01:20:10 <lambdabot>     Not in scope: ‘peekCString’
01:20:10 <lambdabot>     Perhaps you meant ‘BSC.packCString’ (imported from Data.ByteString.Char8)
01:20:29 <dramforever> julianleviston: well that makes sense, but this one makes more sense:
01:20:39 <tsani> Cale: yeah, I'm just going to write it out in full, and then refactor it.
01:20:46 <Cale> If we have x :: IO (Maybe CString)
01:20:46 <dramforever> :t fmap :: (a -> b) -> Identity a -> Identity b
01:20:46 <julianleviston> dramforever: Ryan Trinkle keeps saying map for ($), at least I think he is… in this video I’m watching.
01:20:47 <lambdabot> (a -> b) -> Identity a -> Identity b
01:20:49 <tsani> Rather than try to come up with the one-liner at first.
01:21:02 <julianleviston> dramforever: yeah… cool :)
01:21:19 <Cale> then we can write  do m <- x; case m of Nothing -> return Nothing; Just cs -> peekCString cs
01:21:26 <dramforever> actually if it's obvious you can omit that when reading =)
01:21:27 <julianleviston> dramforever: does the identity Functor just have fmap = id ? isn’t that just map’s definiton?
01:21:44 <dramforever> I don't know...
01:21:59 <julianleviston> dramforever: pretty sure map’s definition is fmap = id
01:22:27 <julianleviston> dramforever: I don’t know what the Identity Functor is, tho.
01:22:34 <dramforever> @src Identity
01:22:35 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
01:22:52 <julianleviston> dramforever: oh sweet! @src. I’ll try to remember that. Can you do that in GHCi?
01:23:07 <dramforever> no...
01:23:15 <julianleviston> dramforever I have to go learn more stuff. :) thanks.
01:23:19 <Cale> Oh, sorry, missed an fmap Just there
01:23:23 <dramforever> btw src is not very useful
01:23:29 <Cale> do m <- x; case m of Nothing -> return Nothing; Just cs -> fmap Just (peekCString cs)
01:23:30 <dramforever> haddocks are better
01:23:42 <julianleviston> dramforever: yeah, but they’re not in the console ! :)
01:24:04 <julianleviston> dramforever: local stuff is pretty much handier
01:24:06 * dramforever wonders if there's a console-based haddock reader
01:24:19 <dramforever> julianleviston: you can download haddocks IIRC
01:24:38 <julianleviston> wish it was baked in GHCi  - one thing I miss from Clojure.
01:24:55 <dramforever> except that it's not always possible
01:26:02 <Cale> tsani: You might want to use mapM from Data.Traversable (or the new Prelude)
01:26:12 <Cale> :t (mapM peekCString =<<)
01:26:13 <lambdabot>     Not in scope: ‘peekCString’
01:26:13 <lambdabot>     Perhaps you meant ‘BSC.packCString’ (imported from Data.ByteString.Char8)
01:26:20 <Cale> :t (mapM Foreign.C.String.peekCString =<<)
01:26:21 <lambdabot> Traversable t => IO (t Foreign.C.String.CString) -> IO (t String)
01:27:22 <tsani> Interesting !
01:28:16 <tsani> ha yeah, it turns out that the function I'm looking for is mapM/traverse
01:29:17 <tsani> Ah, but not quite
01:29:59 <Cale> Well, you also want to run the action you have
01:30:36 <dirk103> when i see :: that is explicit type specification eh?
01:30:42 <Cale> It's slightly unusual to take an IO action as an argument unless you're going to be doing something control-structure like, and want the option to execute it (causing the effects to occur) zero or more times.
01:30:57 <julianleviston> dirk103:  constraint, I believe.
01:31:01 <Cale> dirk103: Yeah,  e :: t  means that the expression e has type t
01:31:11 <tsani> Cale: of course. This piece of code is happening in an IO do-block.
01:31:20 <julianleviston> dirk103:  oops… scratch that. => is constraint. Guh.
01:31:23 <lpaste_> dramforever pasted “Kanren with inequality” at http://lpaste.net/136852
01:31:25 <Cale> There are technically a bunch of distinct places this gets used in the Haskell syntax
01:32:31 <Cale> One is a declaration form, which requires the thing to the left of the :: to be a single variable (name)
01:33:19 <Cale> One is an expression form: you can specify the type of any subexpression, and the compiler will both restrict the type to the one you gave, and check that the type is actually appropriate.
01:33:53 <dramforever> huh? what happened to lpaste?
01:34:18 <Cale> dramforever: huh?
01:34:22 <Cale> dramforever: Seems normal
01:34:28 <dramforever> what's the underscore/
01:34:29 <dramforever> ?
01:34:46 <dramforever> oh it doesn't really matter =)
01:34:48 <Cale> underscore?
01:34:57 <dramforever> lpaste_
01:35:25 <Cale> oh, the bot's name
01:36:03 <Cale> Probably lpaste was taken when the bot logged in, because it takes a while for disconnected clients to actually get dropped
01:49:09 <solatis> can anyone help me a little bit with a design / code quality issue ?
01:49:11 <solatis> https://github.com/solatis/bitgloom/blob/master/bitgloom-worker/src/Bitgloom/Worker.hs#L14
01:49:25 <solatis> i want to make sure that the user doesn't mess up providing the wrong TaskGroup there
01:49:37 <solatis> in other words, I want to make it strongly typed
01:49:57 <solatis> would the best approach to this would be just to wrap the TaskGroup in two different newtypes PollTaskGroup and AnonymizeTaskGroup ?
01:50:37 <solatis> or are there better approaches to this ?
01:51:15 <solatis> the problem with newtype is that you get 'newtype PollTaskGroup = PollTaskGroup TaskGroup', which requires you to expand the argument to access the underlying TaskGroup
01:51:26 <solatis> I would much rather prefer a strongly typed alias, if that makes sense ?
01:52:27 <bakibour> Hidiho
01:58:59 <quchen> How would one show that there is no Monad for ZipList? 
01:59:46 <dramforever> I think it has something to do with ap and (<*>)
02:00:29 <quchen> Sure, ap = <*>. But we can't reconstruct >>= from pure and <*> alone, so we have to show that there is no possible >>= such that <*> = ap.
02:00:48 <dramforever> yeah
02:06:54 <Twey> solatis: Yes, newtypes are the usual solution to this
02:07:24 <Twey> solatis: You can provide a projection function: newtype PollTaskGroup = PollTaskGroup { getPollTaskGroup ∷ TaskGroup }
02:08:36 <muzzle> Why is ++ not equal to <> ?
02:08:50 <muzzle> That way it would work for Sequence to ?
02:09:00 <solatis> Twey: superb, that was the answer i was looking for!
02:09:27 <Twey> muzzle: Same reason map isn't the same as fmap
02:09:51 <fishburne> julianleviston: Yes. I considered Yesod first. But it appeared to have too much magic for a beginner...
02:09:55 <Twey> muzzle: Historical reasons combined with a fear of scaring newbies by talking about typeclasses that they might not be able to connect to what they're doing, IIUC
02:10:29 <muzzle> Is it ok to use non-standard preludes in packages that i'm going to publish ?
02:10:40 <muzzle> Or is that bad practice
02:10:43 <muzzle> ?
02:11:11 <indiagreen> muzzle: it's alright for applications
02:11:25 <dramforever> muzzle: is it transparent to the users of your library?
02:11:35 <dramforever> (if it's a library, of course)
02:11:39 <muzzle> not really 
02:11:58 <dramforever> so it's like users have to know that alternative prelude?
02:12:38 <muzzle> no
02:12:51 <dramforever> hmm that seems fine
02:12:59 <muzzle> they don't, but if other people want to modify it then they would have to deal with it
02:13:03 <quchen> I think it's a code smell when I have to install one new prelude for each dependency I pull in.
02:13:35 * hackagebot elm-init 1.0.0.0 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-1.0.0.0 (justus)
02:18:36 * hackagebot spanout 0.1 - A breakout clone written in netwire and gloss  http://hackage.haskell.org/package/spanout-0.1 (vtan)
02:38:38 <tcs> What's the easiest way I can get a URI (https://hackage.haskell.org/package/network-uri-2.6.0.3/docs/Network-URI.html#t:URI) as a ByteString?
02:43:37 <Twey> tcs: You can make an orphan instance for e.g. Serialize, or whatever serialization package is hot these days: https://hackage.haskell.org/package/cereal-0.4.1.1/docs/Data-Serialize.html
02:44:14 <Twey> tcs: URI derives Generic, so you can just say ‘instance Serialize URI’ and then use ‘encode’
02:44:38 <funfunctor> Hi
02:44:55 <dramforever> Twey: I'm not so sure, maybe tcs wants the uri in bytestring, not just serialized
02:45:07 <dramforever> i.e. "http://..." not some random other stuff
02:45:10 <dramforever> funfunctor: hi
02:45:20 <Twey> dramforever: Ah, maybe
02:45:23 <funfunctor> I am getting an exception thrown in the following monad :: Handler b App ()   how can I catch it? Control.Exception seems to just work on the base monad IO
02:45:40 <dramforever> funfunctor: which package?
02:45:44 <dramforever> snap?
02:45:55 <Twey> tcs: If you want that then you'll need to use uriToString and pack
02:46:06 <funfunctor> dramforever: snap yes with a postgresql Sql exception
02:46:37 <tcs> well, I have a function (Request -> Request) where I want to insert a header. The header I need to insert is a hmac (SHA512) encoding of the URL
02:47:05 <tcs> I get the url with` getUri req` but the `hmac` function expects a ByteString
02:47:09 <funfunctor> dramforever: I am trying to handle SqlError {sqlState = "23505", sqlExecStatus = FatalError, sqlErrorMsg = "duplicate key value violates unique constraint \"prim\"", sqlErrorDetail = "Key (area)=(BELCONNEN) already exists.", sqlErrorHint = ""}
02:47:13 <Twey> tcs: hmac $ uriToString id uri ""
02:47:15 <Twey> Oops
02:47:21 <Twey> tcs: hmac . pack $ uriToString id uri ""
02:47:51 <tcs> I tried `B.pack . show` but that didn't work because the pack in Data.ByteString expects [Word8]
02:47:56 <funfunctor> dramforever: https://hackage.haskell.org/package/postgresql-simple-0.0.3/docs/src/Database-PostgreSQL-Simple-Internal.html#SqlError
02:47:59 <dramforever> funfunctor: will this suffice? http://hackage.haskell.org/package/snap-0.14.0.5/docs/Snap-Snaplet.html#v:bracketHandler
02:48:10 <dramforever> oh it doesn't...
02:48:23 <tcs> I haven't tried uriToString, but won't that have the same problem?
02:48:44 <dramforever> tcs: try Data.ByteString.Char8
02:48:47 <Twey> tcs: If you use Data.ByteString.Char8 then pack ∷ String → ByteString
02:48:54 <Twey> tcs: But watch out for higher codepoints
02:49:11 <dramforever> funfunctor: can you isolate the sql requests to an IO?
02:49:31 <dramforever> wait no..
02:49:41 <funfunctor> dramforever: I wish but no.. the server connection state is kept inside the Snap monad state
02:49:43 <Twey> I suppose they're probably URI-encoded or Punycoded in your input, so shouldn't be a problem
02:49:54 <dramforever> funfunctor: wow look at the Handler data type
02:50:01 <tcs> Twey: higher codepoints?
02:50:06 <funfunctor> dramforever: with Snap you wind up with monad transformers :<
02:50:06 <dramforever> http://hackage.haskell.org/package/snap-0.14.0.5/docs/Snap-Snaplet.html#t:Handler
02:50:17 <dramforever> see, MonadCatchIO instance !
02:50:27 <dramforever> http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.1.3/docs/Control-Monad-CatchIO.html#t:MonadCatchIO
02:50:33 <dramforever> horray!
02:50:44 <bennofs> MonadCatchUI-transformers? that sounds deprecrated
02:50:51 <bennofs> s/UI/IO
02:51:03 <bennofs> I thought the new, shiny thing was 'exceptions' ?
02:51:12 <tcs> Data.ByteString.Char8 seems to have worked, will give it a try now
02:51:39 <Twey> tcs: Char8 will silently discard the higher bits of any codepoints over 255
02:51:40 <funfunctor> dramforever: thanks so much!
02:51:58 <dramforever> funfunctor: always read the instance list
02:52:00 <dramforever> =)
02:52:07 <dramforever> RTFIL!
02:52:34 <dramforever> note that MonadCatchIO-transformers seems deprecated, as bennofs mentioned
02:52:56 <dramforever> but since snap is using it...I guess you're going to make do with the deprecated thing
02:53:32 <tcs> hmmm, so if there are non-ASCI characters in the URL they won't work?
02:53:37 * hackagebot hedis 0.6.9 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.9 (FalkoPeters)
02:55:00 <Twey> tcs: Non–Latin-1
02:55:30 <bennofs> dramforever: ah, I know why it is using it... seems they are currently working on snap-1.0
02:55:38 <bennofs> (which won't use it)
02:55:39 <dramforever> oh hmm
02:55:49 * dramforever checks snap version
02:55:56 * dramforever frowns
02:55:59 <bennofs> so probably they are only doing maintenance on 0.*
02:56:15 * dramforever doesn't use snap
02:56:41 <bennofs> my neither :p
02:57:40 <dramforever> =P
03:02:47 <funfunctor> dramforever: any idea how to specify the sort of exception I expect to deal with? http://lpaste.net/136856
03:03:27 <funfunctor> Its not clear to me where to put a type-signature
03:03:34 <dramforever> write type annotations
03:04:18 <dramforever> funfunctor: so you have an expression of the form try ... right?
03:04:53 <dramforever> annotate that
03:05:32 <funfunctor> dramforever: yea  r <- try $ foo abc
03:06:38 <tcs> Twey: that seemed to work
03:06:39 <Cale> funfunctor: It should also suffice just to pattern match on the result
03:06:40 <tcs> thanks
03:07:04 <Cale> funfunctor: i.e. in the Left case, match on one or more of the constructors of the exception type
03:07:15 <tcs> I'm pretty sure there won't be any UTF-8 characters in the url (famous last words)
03:07:25 <funfunctor> Cale oh yea! fantastic point!
03:08:38 * hackagebot elm-init 1.0.0.1 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-1.0.0.1 (justus)
04:13:41 <Sumang> does sb know how to enable https for Scotty?
04:16:04 <indiagreen> people who have used both Python and Haskell: what Haskell features do you miss most in Python?
04:16:29 <zomg> Sumang: I seem to recall some recommendation about putting an HTTPS proxy in front of it
04:16:53 <indiagreen> I'm tired of Haskell's pretty bad ecosystem and I want to switch to Python, but I'm scared
04:18:46 <joco42_> luite: I am trying to revive ghcjs-examples. I've managed to compile part of the ghcjs-examples with the help of Ryan using try-reflex, but when I try to execute the mouse examples, the lib1.js is missing http://snag.gy/Z3uhn.jpg, what is in lib1.js ? Should that be also generated from haskell ? Or can I just get that from your blog examples ?
04:18:54 <maerwald> indiagreen: what do you mean with ecosystem?
04:19:04 <Sumang> zong: do you know any info regarding running HTTPS over warp? I see there is warp-tls .
04:19:16 <rbocquet> indiagreen: bad ecosystem ?
04:19:24 <Sumang> zomg: do you know any info regarding running HTTPS over warp? I see there is warp-tls .
04:19:45 <indiagreen> maerwald, rbocquet: most of Haskell's good libraries are written like DSLs – they're perfect for their respective tasks
04:19:51 <dramforever> indiagreen: I sometimes use python, and the feature I miss most is ADT + pattern matching
04:20:00 <ptcek> indiagreen: typesystem, for sure :)
04:20:03 <indiagreen> because DSLs are so easy to write in Haskell
04:20:08 <dramforever> oh type system
04:20:16 <dramforever> indiagreen: so how is python different?
04:20:34 <indiagreen> as a consequence, I have to learn a friggin' new language every time I want to use a library for a one-off task
04:20:53 <dramforever> indiagreen: how is python different?
04:21:16 <slack1256> yes, but what in haskell we call DSL usually have well defined patterns
04:21:17 <indiagreen> dramforever: I think (not sure, but blah blah I heard) that its libraries are more uniform
04:21:28 <slack1256> I've seen people claim Data.List is a DSL
04:21:31 <maerwald> indiagreen: I can see that
04:22:03 <dramforever> well how uniform?
04:22:15 <maerwald> but I think that's a general thing with haskell... you have to learn more, but write less
04:22:26 <slack1256> usually offer a kind (or more) of composition operator
04:22:30 <dramforever> s/learn/think/ maybe?
04:22:36 <maerwald> learn
04:22:38 <slack1256> most notable example being pipes
04:22:40 <ptcek> indiagreen: python developers are more conservative in a way they use python's syntax, compared to ruby for example... it can be more verbose, but more uniform, you're right
04:22:43 <dramforever> okay
04:22:56 <ptcek> indiagreen: just try python, learn the good stuf and come back with some new insight :)
04:23:05 <bennofs> indiagreen: I'd think learning Python can't hurt, so just try it out? :)
04:23:06 <maerwald> If I had to think more in haskell than in another language for the same problem, I wouldn't use it
04:23:12 <dramforever> ptcek: I came from ruby, can confirm =P
04:23:15 <indiagreen> slack1256: do they? we have libraries that use lenses for everything (because they fit the task better, right), libraries that provide nothing but pipes or conduits or whatever (because they fit the task better, right), libraries that require you to work in their own monads, libraries that define their own set of operators (because let you write a bit shorter code, right), etc etc etc
04:24:08 <bennofs> indiagreen: or maybe try OCaml? :p it feels quite a bit simpler from my limited experience
04:24:28 <dramforever> haskell stuff are much better than ruby =P
04:25:00 <dramforever> in ruby it's like huh? I didn't know you could actually do *this*!
04:25:04 <ptcek> dramforever: i think its not haskell vs ruby but OOP vs FP
04:25:21 <slack1256> indiagreen: yes, but they all follow this pattern. Lenses do have good compositional semantics (composing lenses with lenses, prims and iso)
04:25:21 <dramforever> ptcek: I'm talking about the "uniform" problem
04:25:40 <ptcek> dramforever: but ruby is actually a bit separate story, thats right.... method_missing ....
04:25:45 <dramforever> lol
04:25:47 <indiagreen> slack1256: I'm not saying patterns are bad, I'm saying there's too many of them
04:25:52 <slack1256> both pipes and conduit use mostly the same underneath representation and if you know one you already know the another
04:26:15 <bennofs> slack1256: _"mostly"_ know the another :)
04:26:20 <dramforever> indiagreen: why do you think there are less patterns in python?
04:26:24 <slack1256> indiagreen: is only one pattern mostly, what tekmo called the category pattern
04:26:47 <slack1256> bennofs: I wish snoyberg didn't heard that :-)
04:27:05 <ptcek> I find it easier in haskell to fit the pieces together than in python, because typesystem helps a great deal...
04:27:08 <ronh> http://www.mmamania.com/2015/7/17/8990867/top-ufc-contender-warns-fedor-emelianenko-hope-he-understands-mma-has-changed
04:27:13 <ronh> wops, wrong channgel
04:28:19 <dramforever> indiagreen: IIUC in haskell the patterns are explicit
04:28:41 * hackagebot eigen 2.1.1 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-2.1.1 (OlegSidorkin)
04:29:09 <maerwald> dramforever: uh?
04:29:21 <Twey> maerwald: IME you don't *have* to think more in Haskell, but I always end up doing so anyway :þ
04:29:29 <slack1256> indiagreen: Maybe I am doing a strawman here, but maybe your complaint isn't that there are too many patterns. Is it than they take too much time to learn and be productive with them for equivalent power on other languages?
04:29:44 <maerwald> haskell is the most "implicit" language I have ever learned, hiding a lot of things that are going on, which can be both confusing and nice
04:29:50 <luite> joco42_: lib1.js has been removed a long time ago because of circular dependencies
04:29:51 <dramforever> with traditional OOP patterns you say "here's an iterator" "here's a factory"
04:30:06 <dramforever> in the docs
04:30:13 <dramforever> with haskell you say so in the code
04:30:21 <dramforever> well is that correct?
04:30:42 <P4Titan> Hello all, I have a question about using Set or IntSet. The big O notation for the `member` function is log(n) for the former and min(n,W) for the later where n is the size of the set and W the number of bits in an Int. In the best case, W can be 32 where IntSet works linearly. However, the n required for log(n) to be greater than 32 is 10 ^ 32, which is an obscenely large amount of elements. What is the reasoning behind chosing
04:30:42 <P4Titan> Data.IntSet over Data.Set?
04:30:43 <luite> joco42_: the file you see is probably based on template.html, it's probably easiest to start from the new template: https://github.com/ghcjs/ghcjs/blob/improved-base/lib/etc/template.html
04:30:58 <joco42_> luite: ok, thanks, i try that
04:31:16 <indiagreen> slack1256: I agree about the category pattern thing, but it's like monads – yep, they compose, but you still need to know the specifics of the monad you're working in. You need to know the details of pipes/conduits/whatever. Besides, there are also libraries like Aeson and web frameworks which don't follow the category pattern and which are still hard to learn.
04:31:51 <bennofs> P4Titan: O(...) notation does not represent constant factors. O(2) is the same as O(1)
04:32:13 <P4Titan> ok...
04:32:23 <bennofs> P4Titan: so for comparing constant factors, you need a different measure. In practice, I think IntSet is normally faster than Int
04:32:26 <luite> joco42_: keep in mind we're switching everything over to the improved-base branch soon, if you can manage to get that installed (use the 7.10.2 release candidate) it'd be most helpful if you update the examples to work with that
04:32:26 <dramforever> indiagreen: I don't really think there are less patterns to learn in python libs
04:32:30 <indiagreen> slack1256: my complaint is that all the patterns are optimised for repeated use of libraries. Long-term gain. But when I want to use a library only once – which happens often – I lose time learning the pattern I won't use often.
04:32:52 <indiagreen> dramforever: just in case: you know Python, right?
04:32:54 <P4Titan> bennofs: You are saying that the IntSets best O(W) is better than O(log(n))?
04:32:58 <dramforever> P4Titan: btw although it doesn't matter, in computer science log usually stands for log_2
04:33:08 <dramforever> indiagreen: a bit
04:33:19 <mauke> O(W) = O(1)
04:33:20 <maerwald> indiagreen: do you think there is a solution? A different style of writing libraries?
04:33:34 <P4Titan> mauke: Why so, if you don't mind?
04:33:35 <slack1256> indiagreen: That, how you actually sayed it is how I felt a long time. It's well put
04:33:43 <dramforever> indiagreen: so the problem is the patterns are spilled everywhere in haskell
04:33:43 <joco42_> luite: i see, that is good to know, is there a vagrant virtual machine I could use to get improved base up and running more easily ?
04:33:50 <P4Titan> dramforever: Was it not lg == log base 2?
04:33:55 <bennofs> P4Titan: O(min(W,n)) means that IntSet's lookup time is essentially the same if you put 32 elements in it or 100000
04:33:55 <slack1256> yes haskell doesn't seem to have much emphasis on "getting  right at working" libraries unless they are tiny
04:33:57 <mauke> P4Titan: because W is constant
04:34:11 <slack1256> but I think this is more a cultural thing that anything else
04:34:11 <Twey> dramforever: There's no real agreement
04:34:18 <dramforever> yeah
04:34:22 <dramforever> and it really didn't matter
04:34:23 <Twey> lg is often base-10
04:34:24 <P4Titan> Yes, but W is 32 while log(n) is less than 32 in all resonable cases
04:34:35 <indiagreen> maerwald: I'm pretty sure there is a solution, and sometimes I dream about writing my own set of consistent libraries for everything, but that's just too much work
04:34:36 <joco42_> luite: or what is the easiest way to get improved base up and running ? i tried already with the leksah vagrant vm, but it did not succeed
04:34:37 <bennofs> P4Titan: but it still 
04:34:48 <luite> P4Titan: complexity for many (Set Int a) operations is O(W) of course too
04:34:48 <Twey> ln is always base-e, lb is always base-2 (but rarely used), and ‘log’ is whatever the hell you want it to be :þ
04:34:51 <bennofs> P4Titan: you cannot compare it like this. O notation only gives information about 
04:34:52 <slack1256> there are efforts on that direction also, the case of lens vs data-family-lens is one
04:35:00 <slack1256> but is a valid concern
04:35:01 <dramforever> log_b(a) = log_c(a) / log_c(b)
04:35:06 <bennofs> P4Titan: relative runtime change when you add more elements, not about absolutre runtime
04:35:13 <Twey> But yes, it's just a constant factor
04:35:50 <P4Titan> bennofs: Ok, as it also says in the docs that IntSet is more efficient than Set when using Ints, but then I looked at the O notation and got this question
04:35:59 <emlun> P4Titan: yes, but big-O notation drops constant factors. You might be comparing the numbers 100000 * log(n) and 1 * W.
04:36:00 <luite> joco42_: use 7.10.2, then it should be easy: http://lpaste.net/135131
04:36:29 <joco42_> thanks, i give it a try !
04:36:33 <luite> joco42_: if you have an sdist, installation on windows is even quite simple :)
04:36:34 <P4Titan> Ok, so I should use IntSet
04:36:36 <Twey> P4Titan, emlun: Also, big-O is an *upper* bound
04:36:37 <indiagreen> okay, thanks everyone, let's see how I manage to live without ADTs and pattern-matching
04:36:38 <dramforever> indiagreen: I think I'm understanding your problem. In python is like "learn django learn django learn django learn django", but in haskell it's like "learn snap, learn monads, learn lens, learn pipes"
04:37:02 <emlun> Twey: that too
04:37:06 <slack1256> (and take at least a week practicing each one)
04:37:14 <slack1256> well more like 23 for lens
04:37:32 * dramforever remembered doing exactly the same thing while trying to figure out something in category theory!
04:37:45 <dramforever> what a categorical language...
04:37:49 <joco42_> luite: I have mac and ubuntu, but i can also set up a windows vm if needed, what environment do you recommend ? 
04:37:54 <Twey> dramforever, indiagreen: Well, that's not necessarily true.  There are microframeworks in Python that require you to learn several new libraries, and some of them have quite sophisticated DSLs (e.g. SQLAlchemy)
04:38:01 <slack1256> the libraries seem to have a big upfront cost, the question is, are they worth it?
04:38:13 <Twey> dramforever, indiagreen: And likewise we have some megaframeworks in Haskell, like Yesod
04:38:15 <dramforever> Twey: oh thanks
04:38:19 <indiagreen> dramforever: also this library uses monoids, and that library uses a Put monad which is actually a monoid but this way we can have do notation, and we have a dozen ways to handle errors (and each library uses its own), etc, etc
04:38:30 <luite> joco42_: linux is probably fastest
04:38:37 <luite> joco42_: but i often dev on os x as well
04:38:41 * hackagebot eigen 2.1.2 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-2.1.2 (OlegSidorkin)
04:38:52 <dramforever> indiagreen: so it's like you need to learn a lot, but that's pretty much it (or is it?)
04:39:08 <joco42_> luite: ok, thanks, i try to install then improved base on ubuntu
04:39:17 <indiagreen> yes, I need to learn a lot and I don't want to be learning something I'll only use a couple of times
04:39:25 <indiagreen> or rather
04:39:52 <phaazon> hey
04:39:52 <dramforever> so like a week later you try another library and say to yourself "monoids? I remembered seeing them somewhere...oh it has an identity element and......"
04:40:09 <phaazon> if I have a Ptr a (which is an array), and want to get the value at index 4 for instance
04:40:13 <phaazon> I can simply write
04:40:16 <phaazon> peekElemOff p 4
04:40:17 <phaazon> right?
04:40:21 <Twey> indiagreen: If you learn a few patterns, you're mostly good for new libraries.  Though there are more and more general such patterns to learn in Haskell than many other places.
04:40:28 <phaazon> it handles the offset on itself
04:40:36 <phaazon> the manual version would be with peekByteOff
04:40:41 <bennofs> phaazon: looks good
04:40:42 <phaazon> IIRC
04:40:48 <phaazon> right, thanks :)
04:40:49 <dramforever> phaazon: the elem one looks good
04:41:05 <phaazon> cool :5
04:41:07 <phaazon> :) *
04:41:10 <slack1256> also if at the end of the day you learn the pattern, if you end up maintaining such application, refactoring and testing will be easier
04:41:20 <Twey> indiagreen: Like the ‘pretend monad’ ‘design pattern’.  It's true that error handling is annoyingly inconsistent, though.
04:41:27 <slack1256> but if is a one time task... well up to the buyer is it
04:41:42 <P4Titan> Does anyone know the O notation for removing an elem from a list?
04:42:03 <slack1256> O(n) i think
04:42:03 <Twey> P4Titan: With Data.List.delete, it'll be O(n)
04:42:06 <dramforever> IIUC O(n)
04:42:27 <slack1256> also, best case? worst case? amortized one?
04:42:29 <dramforever> Twey: relevant xkcd: http://www.xkcd.com/927/
04:42:39 <Twey> slack1256: It'll take as many steps as the index of the element in the list
04:42:51 <Twey> slack1256: So O(n) is the worst case where the element is at the very end of the list (or not in the list at all)
04:42:57 <slack1256> but best case is that the element is the head, thus O(1)
04:43:09 <dramforever> :t delete 
04:43:10 <lambdabot> Eq a => a -> [a] -> [a]
04:43:15 <Twey> slack1256: Yes, but that's not very informative
04:43:21 <Twey> dramforever: Hehe.
04:43:24 <dramforever> > delete 2 [1,2,1,2,1,2] -- lemme see
04:43:26 <Twey> dramforever: Especially re error-handling.
04:43:26 <lambdabot>  [1,1,2,1,2]
04:43:51 <dramforever> let's make a standard error handling library!
04:43:57 <slack1256> \(ºvº)/
04:44:00 <Twey> dramforever: Heh.
04:44:04 <dramforever> and it happens
04:44:10 <phaazon> > filter (/=2) [1,2,1,2,1,2]
04:44:12 <lambdabot>  [1,1,1]
04:44:28 <ptcek> I am beginner and still confused with error handling...
04:44:30 <P4Titan> What data type would be lest to start with a bunch of numbers and remove elements one by one?
04:44:36 <ptcek> and it seems it won't go away quickly
04:44:45 <P4Titan> IntSet has O(min(n, W)) which is better than a list
04:44:45 <Twey> P4Titan: IntMap?
04:44:45 <dramforever> ptcek: good thing you don't need to do it *that* often
04:44:48 <phaazon> ptcek: what is confusing you?
04:45:06 <Twey> P4Titan: If you have multiple occurrences you can't use IntSet
04:45:14 <P4Titan> unique
04:45:16 <ptcek> it seems there are so many libraries with error handling
04:45:20 <P4Titan> I failed to mention that
04:45:25 <Twey> P4Titan: Ah, IntSet's fine then
04:45:30 <P4Titan> Ok
04:45:33 <P4Titan> thanks!
04:45:33 <phaazon> ptcek: yeah
04:45:39 <phaazon> you need to pick the one for your own use
04:45:42 <ptcek> but I am doing nothing real now, so no need to use any of these
04:45:55 <phaazon> I use the standard Maybe when I don’t need error message
04:45:59 <phaazon> and Either if I do
04:46:01 <phaazon> nothing else :)
04:46:05 <dramforever> ptcek: not really
04:46:16 <phaazon> (MaybeT or EitherT for monadic stacks)
04:46:44 <phaazon> and I guess you could also use a continuation, but as a beginner, you don’t need that :)
04:47:17 <phaazon> the cool thing about EitherT is the fact it’s ridiculously simple :)
04:47:17 <ptcek> phaazon: but I saw it in seasoned schemer or somewhere like that :)
04:47:19 <dramforever> oh I just did something cool today: http://lpaste.net/136852
04:47:34 <Twey> P4Titan: No problem
04:47:35 <dramforever> it's a logical programming language with negation
04:47:41 <dramforever> it's inspired by minikanren
04:47:47 <phaazon> my advice would be to dig in EitherT and MonadError
04:47:56 <phaazon> they’re great :)
04:48:01 <phaazon> and simple to understand
04:48:19 <slack1256> what is the difference between EitherT and the new ExceptT?
04:48:20 <P4Titan> You mind if I ask you what my entire problem is instead of part by part?
04:48:28 <phaazon> slack1256: I don’t know ExceptT
04:48:36 <indiagreen> slack1256: EitherT is in some Ed's library
04:48:37 <ptcek> phaazon: I'm writing it down for future reference when I need it, in the meantime I have to figure out, what monadic stack is :)
04:48:42 <phaazon> but I guess ExcepT also catches runtime exceptions
04:48:43 <Twey> dramforever: Can you backtrack through the negation?
04:48:43 <slack1256> That is the difference :-)
04:48:45 <dramforever> P4Titan: it's actually better =)
04:48:54 <phaazon> ptcek: monad transformers
04:48:59 <dramforever> Twey: I'm not sure, but I use constraints for negation
04:49:02 <indiagreen> slack1256: which depends on lots of stuff and so I never use it
04:49:13 <indiagreen> ExceptT is in transformers and it's unfortunately named
04:49:27 <Twey> dramforever: Ah.  Neat!
04:49:29 <ptcek> phaazon: i know it's somewhere in transformers or mtl, but I'm not there yet
04:49:31 <dramforever> i.e. I keep track of things like "<1> cannot be nil" "<2> cannot be cons(<1>, <3>)"
04:49:38 <Twey> P4Titan: Go ahead
04:49:40 <phaazon> ptcek: a monad transformer is a base type, like Maybe, but for “plugging” it to other typse
04:49:42 <dramforever> Twey: there's a bug though
04:49:47 <Twey> P4Titan: Often best to do that from the start :þ
04:50:02 <phaazon> MaybeT adds to other types the ability to fail
04:50:17 <phaazon> MaybeT IO is a type in which you can do regular IO
04:50:21 <phaazon> but you can also fail
04:50:22 <P4Titan> I have a ST s (MVector s TreeNode) which I want to apply a function f to a random selection of n elements in the vector
04:50:25 <dramforever> P4Titan: it's better to ask the question in whole, because you might be breaking the question into parts in a wrong way
04:50:27 <slack1256> up to commutation on how far it fails though
04:50:45 <ptcek> phaazon: i have a feeling about the basic idea, but we do not need to polute this channel with it, though :)
04:51:49 <P4Titan> This randomness and state stuff in Haskell is tricky, at first at least
04:52:29 <dramforever> Twey: hmm...you know logical programming?
04:52:31 <dramforever> great
04:52:36 <Twey> dramforever: Not well
04:52:44 <dramforever> well I don't know it well either
04:53:06 <phaazon> ptcek: this is a channel to learn
04:53:10 <phaazon> we’re not poluting ;)
04:53:17 <phaazon> but I have to fly out
04:53:34 <dramforever> hmm...do we need #haskell-monad?
04:53:37 <Twey> dramforever: There are some other people in here who are more hard-core fans, though I don't remember names with enough certainty to risk pinging them :þ
04:53:44 <dramforever> I just heard about prolog, then this minikanren thing, then I read an example of minikanren
04:53:45 <kuribas> dramforever: there is a language called curry which mixes logic and functional programming with a haskell like syntax.
04:53:57 <dramforever> and I thought "hey I could actually implement this"
04:54:02 <dramforever> then I wrote that thing
04:54:27 <P4Titan> Any ideas?
04:55:27 <dramforever> P4Titan: there's a monad (transformer) for that!
04:55:31 <dramforever> @hackage MonadRandom
04:55:32 <lambdabot> http://hackage.haskell.org/package/MonadRandom
04:55:57 <dramforever> or just use System.Random and pass around the seed manually
04:56:08 <Twey> Yeah, I was about to code up an example with RandT (ST s)
04:56:15 <dramforever> =)
04:56:58 <ptcek> do you know of any datlog like query language implemented in haskell with whatever backend?? (datalog as in Datomic, Clojure)
05:01:03 <P4Titan> In randomR, does the returned generator have in it packaged the range (a, a) supplied?
05:01:19 <mauke> :t randomR
05:01:21 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
05:01:26 <mauke> P4Titan: no
05:01:42 <P4Titan> ok
05:02:01 <Twey> P4Titan: You can just do bools ← take n <$> getRandoms; forM_ [ i | (True, i) ← zip bools [0 .. length vector - 1] ] $ \i → do unsafeRead vector i >>= unsafeWrite vector i . f
05:02:33 <kuribas> dramforever, Twey: http://www-ps.informatik.uni-kiel.de/currywiki/start
05:02:34 <Twey> Oh, wait, no
05:02:53 <dramforever> kuribas: wow thank you I'll check
05:03:02 <P4Titan> Twey: no what?
05:03:17 <wzjke> 
05:03:24 <Twey> P4Titan: I forgot to include your requirement that precisely n elements should be modified
05:04:20 <dramforever> the good thing of logic programming: easy
05:04:26 <dramforever> the bad thing: hard
05:05:34 <P4Titan> How should I go about picking a random number from an IntSet?
05:07:25 <dramforever> too bad it does not support indexing =(
05:07:36 <P4Titan> Then I have to use a list?
05:07:47 <dramforever> dunno
05:07:48 <Twey> P4Titan: Then, I guess: take n . nub <$> getRandoms (0, length vector - 1) >>= (mapM_ $ \i → unsafeRead vector i >>= unsafeWrite vector i . f)
05:08:06 <Twey> P4Titan: I'm not sure what you're using the IntSet for here
05:08:10 <dramforever> ---
05:09:25 <P4Titan> I wanted to keep a list of non affected indexes and as I apply f, remove that index from the IntSet, recurse with size - 1 until size gets to 0
05:09:58 <dramforever> wait that sounds familiar
05:10:13 <dramforever> P4Titan: http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
05:10:48 <bennofs> P4Titan: the easy solution is: generate a list of all possible indices, randomly shuffle them, and take the first n elemtns
05:11:13 <dramforever> bennofs: =)
05:11:14 <P4Titan> ohhh .
05:11:17 <P4Titan> wow
05:12:00 <dramforever> P4Titan: so that's why you should ask your question in whole rather than part by part
05:12:35 <P4Titan> ok
05:12:35 <kuribas> How well does FRP combine with concurrent programming?
05:12:52 <bennofs> kuribas: combine? you can make events for tasks in FRP
05:12:59 <P4Titan> should I use shuffle or shuffle', the later seems simpler
05:13:39 <bennofs> kuribas: so you can make an event that fires whenever an asynchronous computition finishes 
05:13:44 <dramforever> P4Titan: shuffle' is the random one
05:13:51 <dramforever> shuffle isn't even random
05:13:53 <P4Titan> what is shuffle?
05:14:28 <kuribas> bennofs: if I have a thread that yields a stream of values, can I create an event for each of them?
05:14:30 <dramforever> does the docs make sense?
05:14:32 <dramforever> *do
05:14:40 <dramforever> to me they don't
05:14:41 <dramforever> ...
05:14:44 <P4Titan> Given a sequence (e1,...en) to shuffle, and a sequence (r1,...r[n-1]) of numbers such that r[i] is an independent sample from a uniform random distribution [0..n-i], compute the corresponding permutation of the input sequence. 
05:14:48 <bennofs> kuribas: should be possible in almost all FRP libs I know, yes
05:15:12 <kuribas> ah, ok
05:15:59 <bennofs> P4Titan: something weird if you already have a "kind-of" random sequence to avoid the need for a random number generator
05:16:09 <P4Titan> That is what I thought
05:16:34 <P4Titan> are the r[1] .. r[n-1] a distribution of random unique indexes?
05:16:47 <bennofs> P4Titan: but doesn't look very useful except in quite special cases. Using shuffle' is probably almost always easier
05:16:55 <P4Titan> yes
05:17:37 <bennofs> P4Titan: kind of. r[1] must satisfy 0 <= r[1] <= n-1; r[2] must satisfy 0 <= r[2] <= n-2; and so on till r[n-1]
05:18:28 <P4Titan> ok ...
05:18:31 <P4Titan> I kinda get it
05:18:45 <dramforever> P4Titan: just like your idea isn't it?
05:19:00 <P4Titan> ye
05:20:22 <P4Titan> Ok, more questions ... sorry
05:20:56 <bennofs> np
05:21:27 <P4Titan> The suffle' requires a generator, which is IO StdGen. How can I pass the StdGen part into the function and then get the list to perform the function application part and return a ST s (MVector s TreeNode)
05:21:39 <P4Titan> How do I switch between IO to ST at the end
05:22:30 <P4Titan> >>= wont work
05:22:50 <bennofs> P4Titan: hmm, can you do IO somewhere "near" the code that you want to do in ST?
05:23:08 <bennofs> (or is this somewhere deep in your program, where you do not have access to IO?)
05:23:17 <P4Titan> What do you mean? Substitute ST for IO?
05:23:43 <bennofs> P4Titan: random numbers need IO
05:23:51 <P4Titan> ok
05:24:13 <bennofs> P4Titan: at least to initialise them. Because ST guarrantes that no matter when you run the computation, an ST computation always returns the same result
05:24:24 <kuribas> bennofs, P4Titan: unless you give the seed, like using mkStdGen.
05:24:38 <bennofs> kuribas: yeah, but you probably want the seed to be random :)
05:24:42 <P4Titan> yes
05:25:02 <bennofs> P4Titan: so if you can, get the StdGen in IO and then pass it to your ST function
05:25:16 <P4Titan> What do you mean?
05:25:19 <P4Titan> sorry
05:25:32 <kuribas> it depends on the usecase, but you can let the function accept a seed value.
05:25:44 <bennofs> P4Titan: yeah, where do you want to use your ST function?
05:26:04 <P4Titan> I use it all throughout and then I call runST at the end
05:26:25 <P4Titan> I use it to be able to modift the vector with O(1) instead of O(n)
05:27:23 <bennofs> P4Titan: so well, you need a way to pass the "randomness" from IO to your ST monad
05:27:46 <kuribas> :t mkStdGen
05:27:47 <lambdabot> Int -> StdGen
05:27:50 <P4Titan> unsafeIOOperation
05:27:54 <dramforever> wait you can do O(1) modify?
05:28:00 <ronh> :t getStdGen
05:28:01 <lambdabot> IO StdGen
05:28:04 <bennofs> dramforever: with mutable vectors, yes
05:28:08 <bennofs> dramforever: in ST
05:28:13 <dramforever> why can't you just use an imperative shuffle algorithm?
05:28:13 <P4Titan> exactly
05:28:37 <bennofs> dramforever: yeah you can. still need randomness though. and random-shuffle is not worse i think
05:28:44 <dramforever> sure
05:29:34 <bennofs> P4Titan: so my idea is use newStdGen :: IO StdGen in IO like: newStdGen >>= \stdGen -> functionUsingTheST stdGen and then pass the stdGen to your ST function 
05:29:41 <Twey> P4Titan: A random shuffle will be a bit more efficient than take n . nub, which will take O(n) space and at least O(n log n) time
05:29:58 <bennofs> @hackage random-shuffle
05:29:58 <lambdabot> http://hackage.haskell.org/package/random-shuffle
05:30:00 <bennofs> @Twey
05:30:00 <lambdabot> Unknown command, try @list
05:30:17 <Twey> bennofs: Yes, my comment was in response to the suggestion
05:30:27 <augur> morning!
05:30:28 <bennofs> Twey: well, that package was the later suggestion :)
05:30:51 <Twey> bennofs: In response to the suggestion of random-shuffle :þ
05:30:54 <P4Titan> bennofs: But the return of that entire newStdGen >>= ... is IO ...
05:31:12 <Twey> bennofs: dramforever already suggested it a while ago (but my laptop overheated >.>)
05:31:34 <bennofs> P4Titan: yes. you need to be in IO to get the "initial randomness". 
05:31:34 <Twey> P4Titan: Use MonadRandom instead
05:31:41 <bennofs> Twey: I don't see how it will help
05:32:19 <Twey> You can create the generator with newStdGen, and then pass it into a RandT (ST s) so you can do your random-using stuff in there
05:32:36 <ronh> P4Titan so? use newStdGen once, in main
05:32:53 <Twey> It just saves you having to pass the generator around all over the place
05:32:54 <bennofs> Twey: for one time use, it's probably easier to just pass the StdGen via a function argument
05:33:13 <bennofs> Twey: with the monad, it now forces you to lift all over the time
05:33:17 <Twey> bennofs: Who said it's only going to happen once?
05:33:26 <bennofs> Twey: hmmmm... idk :)
05:33:27 <Twey> bennofs: It doesn't, because there's a class
05:33:40 <Twey> bennofs: http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random-Class.html
05:33:54 <bennofs> Twey: well, the problem here are not the random things, but the ST things
05:34:00 <Twey> Whoops, old version, sorry: http://hackage.haskell.org/package/MonadRandom-0.4/docs/Control-Monad-Random-Class.html
05:34:18 <Twey> bennofs: None of these things are problems :þ
05:34:35 <bennofs> Twey: how do I use ST s a in RandT (ST s) a without lift?
05:34:52 <bennofs> Twey: or do a vector write in RandT (ST s) without lift?
05:34:56 <P4Titan> My question is how do I use ST s in RandT?
05:35:05 <dramforever> put ST s under it
05:35:37 <bennofs> Twey: as I see it, RandT is not a MonadPrim
05:35:43 <Twey> bennofs: Oh, sorry, I misinterpreted you
05:35:56 <Twey> Yes, you'll need one lift after the first line
05:36:19 <bennofs> Twey: and a lift each time that you intersperse random operations
05:36:20 <prinsen> Any one here who's initiated in glibc?
05:36:27 <bennofs> prinsen: in #haskell?
05:36:29 <nicolas12> hi there! is there a function which applies a function over a fst o snd element of a tuple? like "applySnd :: (b -> c) -> (a,b) -> (a,c)
05:36:38 <dramforever> :t second
05:36:39 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
05:36:44 <Twey> bennofs: That's once :þ
05:36:44 <dramforever> it's in Control.Arrow
05:36:53 <nicolas12> thanks :) !!
05:36:55 <dramforever> and there's an instance for Arrow (->)
05:37:04 <dramforever> nicolas12: =) yw
05:37:32 <prinsen> bennofs: hehe yes
05:37:33 <P4Titan> ugh
05:37:47 <prinsen> bennofs: im cross compiling haskell for Android, so its not completely unrelated
05:37:53 <prinsen> bennofs: and #glibc is dead
05:38:06 <bennofs> prinsen: might as well mention that cross-compiling thing then :)
05:38:24 <kuribas> :t over _1
05:38:25 <lambdabot> Field1 s t a b => (a -> b) -> s -> t
05:38:55 <bennofs> prinsen: btw, probably better to just ask and see if somebody responds. I have a feeling that nobody here is going to say "Hey, I'm expert at glibc! :)", but they might nevertheless know the answer to your question
05:39:12 <kuribas> :t over _1 (+1) (1,1)
05:39:13 <lambdabot> (Num a, Num t) => (a, t)
05:39:15 <bennofs> P4Titan: can you tell us a little bit more about the structure of your program? where do you use runST? 
05:39:21 <kuribas>  over _1 (+1) (1,1)
05:39:24 <kuribas> > over _1 (+1) (1,1)
05:39:26 <lambdabot>  (2,1)
05:39:29 <bennofs> in 7.10, Data.Bifunctor is in base
05:39:37 <bennofs> @let import qualified Data.Bifunctor as Bi
05:39:38 <lambdabot>  Defined.
05:39:44 <bennofs> :t Bi.first
05:39:45 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
05:39:47 <indiagreen> nicolas12: if you're on 7.10, consider using second from Data.Bifunctor instead (there's no difference but I just think it'd be nice if people stopped abusing Control.Arrow for tha— oops, bennofs already suggested this
05:40:01 <kuribas> nicolas12: or use lenses?
05:40:07 <dramforever> indiagreen: oh til that thanks
05:40:23 <prinsen> Bionic is missing some glibc-functions (get/set/end host/proto/net ent), required by lowlevel haskell networking libs. Would it be possible to write these functions myself?
05:40:26 <dramforever> kuribas: well if you are already using lens I would certainly recommend that
05:40:49 <nicolas12> thanks :) !!
05:40:59 <nicolas12> kuribas: second worked fine! :)
05:41:26 <P4Titan> I generate a vector to which I apply a function f on to random elements in. That is basically it
05:41:34 <kuribas> dramforever: lenses are really neat, but a rather large dependency.  I always wonder if I should rely on them in my library.
05:41:45 <P4Titan> the vector is ST, randomness is IO, ...
05:41:46 <dramforever> you shouldn't
05:42:18 <kuribas> dramforever: me?
05:42:26 <dramforever> yes
05:42:29 <bennofs> P4Titan: ok, so you call this function to generate the vector/apply a function on random elements from main?
05:42:37 <dramforever> otherwise your library users will be very happy
05:42:42 <dramforever> </sarcasm>
05:42:49 <indiagreen> dramforever++
05:43:12 <kuribas> dramforever: There should be a lens-light ...
05:43:15 <bennofs> dramforever: how about lens-family
05:43:18 <bennofs> kuribas: lens-family?
05:43:28 <dramforever> it lacks quite a few stuff
05:43:48 <bennofs> yeah, but Isos/Prisms need profunctors, which is not "lens-light"
05:43:54 <bennofs> :/
05:44:00 <P4Titan> I generates the vector and then perform a bool operation on it, while that operation is False, I apply f to a random element again, and check, etc until it returns True. I record and return the number of times that f had to be applied.
05:44:28 <bennofs> P4Titan: i mean, do you call the whole function that does all this from IO?
05:44:54 <indiagreen> it'd be nice if Edward could split all useful classes like Profunctor/Choice/etc into a separate light package, but ne doesn't want to do that for understandable reasons
05:45:03 <P4Titan> i gues
05:45:34 <bennofs> P4Titan: well, then it might be easier to just use IO instead of ST too, if you need randomness anyway
05:45:38 <Twey> P4Titan: http://lpaste.net/3147459215417671680
05:45:42 <P4Titan> yes
05:46:05 <Twey> Actually, that's less generic than it can be
05:49:29 <kuribas> lens-family is not compatible with lens, right?
05:49:41 <Twey> P4Titan: The trick is that randomness isn't in IO, only the initial generation of the random seed.  So you can generate the seed in IO and then pass it into your ST action, either directly as a function argument or using MonadRandom
05:49:59 <bennofs> kuribas: it is
05:50:09 <bennofs> kuribas: that's the selling point. no prisms/isos though
05:50:11 <safinaskar> how to tell ghci to skip all this messages "Loading package parallel-3.2.0.4 ... linking ... done."?
05:50:46 <kuribas> bennofs: so lenses created with lens-family-th can be used with lens?
05:50:52 <bennofs> kuribas: yes
05:51:14 <geekosaur> safinaskar, ghci -v0
05:51:26 <bennofs> kuribas: lenses are just things of type Functor f => (a -> f a) -> s -> f s   no need to depend on anything than base to write a lens 
05:51:42 <kuribas> bennofs: Ah, that makes sense.
05:52:16 <kuribas> It's a lot of type class magic, rather than fixed datatypes?
05:52:17 <safinaskar> geekosaur: thanks
05:52:34 <bennofs> kuribas: I wouldn't call it typeclass magic
05:52:42 <bennofs> kuribas: it's basically a generalization of Traversable IMO
05:53:21 <bennofs> (traverse :: Applicative f => (a -> f a) -> t a -> f (t a), for some Traversable t. => is a valid lens Traversal. If you replace Applicative by Functor, you get lenses)
05:53:44 * hackagebot monoid-subclasses 0.4.1.2 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.1.2 (MarioBlazevic)
05:57:17 <bennofs> kuribas: but yes, there are almost no fixed datatypes for interfaces in lens. The datatypes in lens are mostly used to implement the functions on lenses (any they are then concrete instances of Functor, Applicative, Profunctor...)
06:06:57 <kuribas> I can understand why haskell looks daunting to beginners, with Monads transformers, Functors, FRP, Lens, pipes, tons of GHC extensions, etc...   But in the end, I feel that it actually does make the programming experience nicer.
06:07:14 <kuribas> unlike for example java, which is mostly boiler plate.
06:10:08 <bennofs> kuribas: yeah, but IDE have got pretty good dealing with the boiler plate (?) (don't use java much myself)
06:10:56 <kuribas> bennofs: right.  The only IDE I ever used is emacs.
06:12:13 <kuribas> And visual C++ on windows, a long time ago.
06:12:28 <bennofs> so well, yeah, all languages have pros/cons. like https://twitter.com/EmojiHaskell ?!?!
06:14:15 <kawaii-imouto> Is the order of the results from `Data.List.permutations xs` specified? Or can a standard-compliant implementation return the permutations in different order from what `base` does?
06:14:15 <geekosaur> java's boilerplate always seemed pretty daunting to me....
06:15:20 * bennofs hasn't writte any enterprise java code TBH
06:15:26 <wei2912> good for you
06:15:54 <geekosaur> (and I say this as someone who started out maintaining COBOL code)
06:16:13 <indiagreen> kawaii-imouto: I think implementations are required to conform to the implementation in Haskell Report (they can be faster or something, but they have to be equivalent)
06:16:25 <indiagreen> but it's better to read Haskell Report anyway to check
06:17:16 <kuribas> In frpNow, what is the difference between an event and an event stream?  Does an event trigger only onces?
06:17:22 <bennofs> >  permutations "abc" == ["abc","bac","cba","bca","cab","acb"] 
06:17:23 <lambdabot>  True
06:17:37 <bennofs> kuribas: from my limited understanding of frpNow (only glanced at the lib), yes
06:17:48 <bennofs> kuribas: this is also how events were defined originally in Fran
06:18:04 <kuribas> I see, thanks.
06:18:08 <bennofs> kuribas: (and similar to Futures from Push-Pull FRP)
06:19:03 <kuribas> So a button press for example with generate an event stream?
06:19:27 <bennofs> kuribas: I think so
06:20:17 <bennofs> kuribas: yeah, createButton :: Behavior String -> Now (Button, EvStream ())
06:20:37 <safinaskar> i have data Foo = Foo { _fooX :: Int, _fooY :: Int } and data Bar = Bar { _barX :: Int }. how to construct lens, which can view Bar of Foo?
06:21:04 <bennofs> safinaskar: per hand or with template haskell?
06:21:28 <safinaskar> bennofs: template haskell would be ideal
06:21:33 <safinaskar> bennofs: per hand will go, too
06:21:45 <bennofs> safinaskar: see http://hackage.haskell.org/package/lens-4.12.1/docs/Control-Lens-TH.html#v:makeFields
06:21:58 <bennofs> like, exactly your example :p
06:22:14 <kawaii-imouto> bennofs: `permutations "abc" == ...` --> Does that test case, together with parametricity, pin down a single function (modulo extensional equality)?
06:22:15 <safinaskar> bennofs: of course, yes, i copied it from this page :)
06:22:28 <safinaskar> bennofs: but the page doesn't say how to construct my lens
06:22:39 <safinaskar> bennofs: i want to _get_Bar_of_Foo_
06:22:55 <bennofs> safinaskar: oh, sorry, misunderstood then
06:23:04 <kawaii-imouto> No, wait, never mind, it doesn't. :-|
06:23:19 <kuribas> safinaskar: erm "makeFields ''Foo"?
06:23:36 <bennofs> kuribas: Lens' Foo Bar is what is wanted IIUC
06:23:44 <safinaskar> bennofs: yes
06:23:57 <bennofs> safinaskar: in your real code, does Bar also only have one field?
06:24:20 <safinaskar> bennofs: no
06:24:28 <safinaskar> bennofs: (generally speaking :))
06:25:52 <kuribas> bennofs: Foo cannot contain Bar?
06:26:20 <bennofs> safinaskar: ok, assuming data Foo = Foo Int String Bool and data Bar = Bar Int Bool, you can do this as: barOfFoo :: Lens' Foo Bar; barOfFoo f (Foo x y z) = f (Bar x z) <&> \(Bar x' z') -> Foo x' y z'
06:26:33 <bennofs> kuribas: but Foo contains enough information to make a Bar view of it
06:26:51 <bennofs> kuribas: it's like virtual fields.
06:27:29 <kuribas> I have no clue about what is asked...
06:27:43 <safinaskar> kuribas: fields of Bar are subset of fields of Foo
06:27:49 <kuribas> true
06:28:06 <bennofs> @let data Foo = Foo Int String Bool
06:28:08 <lambdabot>  Defined.
06:28:16 <kuribas> So you want to put the first field of Foo into a Bar?
06:28:18 <bennofs> @let data Bar = Bar Int Bool
06:28:19 <lambdabot>  Defined.
06:28:45 <bennofs> @let barOfFoo ::  Lens' Foo Bar; barOfFoo f (Foo x y z) = f (Bar x z) <&> \(Bar x' z') -> Foo x' y z'
06:28:46 <lambdabot>  Defined.
06:28:50 <safinaskar> also, Foo and Bar in my example don't have any parameters. i. e. Foo and Bar have kind "*"
06:29:21 <bennofs> > Foo 3 "hello" True & barOfFoo %~ \(Foo x z) -> Foo (x + 1) (not z)
06:29:22 <lambdabot>      Constructor ‘Foo’ should have 3 arguments, but has been given 2
06:29:22 <lambdabot>      In the pattern: Foo x z
06:29:22 <lambdabot>      In the second argument of ‘(%~)’, namely
06:29:28 <bennofs> > Foo 3 "hello" True & barOfFoo %~ \(Bar x z) -> Bar (x + 1) (not z)
06:29:30 <lambdabot>      No instance for (Show Foo)
06:29:30 <lambdabot>        arising from a use of ‘show_M849701335788419652522855’
06:29:30 <lambdabot>      In the expression:
06:29:37 <kuribas> bennofs: You can make Bar out of each of the elemens of Foo, then which one to choose?
06:30:09 <bennofs> kuribas: he probably wants to make the bar only out of the fooX field (since bar has a correspondending barX field)
06:30:22 <safinaskar> bennofs: "barOfFoo :: Lens' Foo Bar;  barOfFoo f (Foo x y z) =
06:30:31 <safinaskar> bennofs: ..." - thanks
06:31:06 <safinaskar> kuribas: "So you want to put the first field of Foo into a Bar?" - yes
06:31:30 <bennofs> @let deriving instance Show Foo
06:31:35 <lambdabot>  Defined.
06:31:38 <bennofs> > Foo 3 "hello" True & barOfFoo %~ \(Bar x z) -> Bar (x + 1) (not z)
06:31:45 <lambdabot>  Foo 4 "hello" False
06:31:47 <bennofs> success :)
06:31:55 <safinaskar> okey, okey, i understand. thanks, bennofs
06:32:56 <zmbmartin> I am not understanding how I can run a haskell function every 15 seconds.
06:32:57 <kuribas> What's wrong with "Bar . _fooX"?
06:33:17 <bennofs> kuribas: doesn't work in my example, where Bar has multiple fields
06:33:32 <geekosaur> zmbmartin, Control.Concurrent.thrteadDelay 15000000 ?
06:33:38 <bennofs> kuribas: also, you cannot apply a function Bar -> Bar to a Foo
06:35:41 <bennofs> kuribas: the lens I provided basically gives you a virtual "view" that shows a part of Foo (exactly the part which fits in Bar)
06:36:02 <zmbmartin> geekosaur: I guess I am having trouble understanding how to use that. Let me gist what I have.
06:36:56 <kuribas> bennofs: I didn't know that was even possible :-P
06:37:25 <zmbmartin> geekosaur: Here is the relevant part https://gist.github.com/codedmart/9904c93cc224dbcd3e53
06:38:57 <geekosaur> threadDelay does not take a callback parameter
06:39:08 <geekosaur> you apparently think it's a loop construct?
06:39:29 <geekosaur> also 5000 means 5 milliseconds
06:40:22 <zmbmartin> geekosaur: Yeah I know 5000 is 5 milliseconds. Just threw that in there.
06:43:48 <Phillemann> I'm reading Bartosz' article about lenses and comonds and I'm just wondering: Is a comonad also an algebra? "alg" and "extract" have the same type signatures.
06:44:23 <Phillemann> (Maybe I just need to read on)
06:44:27 <bennofs> Phillemann: isn't there some law relating to alg?
06:44:39 <geekosaur> zmbmartin, in any case threadDelay does not start a new thread for you and does not repeatedly execute something specified by a parameter
06:44:44 <geekosaur> it just delays the current thread
06:44:59 <geekosaur> threadDelay 15000000 >> whateverElseHere
06:45:07 <Phillemann> bennofs: Well, Bartosz doesn't state any. But yeah, that would explain a difference.
06:46:54 <bennofs> Phillemann: hmm, I don't see any laws. so probably the answer is yes
06:47:32 <lpaste_> geekosaur pasted “threadDelay - zmbmartin” at http://lpaste.net/136859
06:51:39 <kuribas> :t repeat
06:51:40 <zmbmartin> geekosaur: Thanks!
06:51:41 <lambdabot> a -> [a]
06:52:34 <geekosaur> yeh, I don't recommend keeping that name except possibly as a local where binding
07:01:19 <mpickering> what could be the reason that "cabal test" runs my main executable rather than the test executable
07:01:41 <bennofs> Phillemann: in fact, for a comonad, there exists infinitely many algebras. I think an algebra is defined for a concrete A, so Int -> f Int (where f is the comonad) is an algebra, but so is Bool -> f Bool and so on
07:06:51 <Phillemann> bennofs: So it's more like an F-A-algebra but an F-comonad. ;)
07:07:02 <ion> What is the exact definition of “an algebra” here?
07:07:12 <bennofs> Phillemann: I think so (A is called carrier according to what I've read)
07:08:09 <bennofs> ion: f-algebra I think?
07:09:06 <ion> Thanks
07:15:12 <nshepperd> i though f Int -> Int was an algebra? do I have it backwards?
07:16:27 <bennofs> nshepperd, Phillemann, ion: oh yes, you're right. I mixed it up, extract is :: f Int -> Int too :)  
07:18:12 <catgocat> Hey, is there any haskell minifier? (to use in code golf competitions) ?
07:18:52 <bernalex> catgocat: augustss.
07:18:58 <bennofs> haha
07:19:08 <catgocat> Sorry, what?
07:19:32 <bennofs> catgocat: augustss is a person 
07:19:47 <catgocat> Yeah, but I am asking for a tool
07:19:48 <bernalex> augustss is the by far most effective haskell minifier I have ever seen.
07:19:52 <catgocat> to compress haskell code
07:20:03 <bernalex> yes, try emailing your program to lennart.
07:20:16 <catgocat> but a tool for me to use regularly
07:20:33 <koomi> I don't think so
07:22:23 <ion> bernalex++
07:24:03 <indiagreen> can anyone explain why Lennart is singled out? (I mean, did ne perform some codegolfing feat I haven't heard of? or wrote a Haskell compiler which was 10× smaller than GHC at the time? or something)
07:26:17 <ralu> is it  hard to make compiler 10x smaller than ghc
07:26:38 <indiagreen> “at the time”
07:26:47 <indiagreen> maybe in the old days GHC was small, who knows
07:26:58 <geekosaur> hard if you want to support the same features. I don't think jhc is 10x smaller, but it is certainly much smaller --- on the other hand, it does far less
07:28:06 <ralu> ghc is great i just made cross-compilation for redpitaya
07:31:28 <asxz> you all dont think of using alternatives
07:31:43 <asxz> i like to mess with them to see how wrong they are
07:31:55 <asxz> GHC's error might be that its too big
07:32:04 <wei2912> why would that be an error?
07:32:23 <asxz> i have a old computer haha
07:34:43 <catgocat> how to use `where` in one line?
07:35:38 <ralu> main = print a where a=6
07:35:45 <bennofs> @let foooo x = y where y = x 
07:35:46 <lambdabot>  Defined.
07:35:50 <bennofs> like that?
07:36:27 <indiagreen> catgocat: it works in definitions but not in expressions
07:37:02 <indiagreen> so you can say “let x = ... where ...” but not “x where ...”
07:37:08 <indiagreen> I think
07:40:24 <mpickering> Is there a way to set the ghc-option -main-is from a cabal file?
07:41:03 <bernalex> mpickering: yes.
07:41:51 <bennofs> mpickering: ghc-options?
07:42:17 <bernalex> it's just 'main-is: foo'
07:43:44 <obadz> Is there a FlatBuffers equivalent for Haskell ?
07:43:54 <mpickering> bernalex: no, main-is is different in a cabal file, it just specifies the file where Main should be
07:44:07 <mpickering> bennofs: yes I guess that will have to do
07:45:34 <bernalex> mpickering: ah, *that* main-is. yeah you can just use ghc-options for that.
07:46:06 <bernalex> ghc-options: -main-is foo
07:46:24 <bernalex> bad practice from cabal there imo.
07:47:40 <Cale> obadz: Not entirely sure what FlatBuffers is, but it sounds like binary serialisation? In that case, the 'binary' or 'cereal' packages might be what you're looking for.
07:48:07 <Cale> http://hackage.haskell.org/package/binary http://hackage.haskell.org/package/cereal
07:51:42 <obadz> Cale: thx, one thing that's interesting with FlatBuffers is the datastructures are laid out in such a way that they do not require parsing and they can be used "as is" in memory without any further allocations. Can even be mmapped.
07:56:02 <Cale> obadz: Well, that's not likely to be the case for Haskell -- serialising unevaluated expressions for instance is quite tricky.
07:56:46 <obadz> Cale: the serialization isn't a memory dump, there is a process there
07:56:55 <obadz> Cale: it's the DEserialization that is "very light"
07:57:18 <obadz> Cale: I think with C FFI bindings it should work?
07:57:28 <obadz> Cale: hell there's probably a way to right a pure Haskell implementation
07:59:13 <Cale> I'm not sure how you're going to get away without doing deserialisation, but perhaps
07:59:33 <Cale> Haskell datastructures are full of code pointers
08:01:15 <emlun> does ghci not memoize function calls? I tried defining the fibonacci sequence recursively, and evaluation time explodes around approximately n = 30
08:01:24 <obadz> I suppose you would only get C data structure
08:01:43 <indiagreen> emlun: it only memoises values, not function calls
08:01:47 <obadz> how does Haskell convert a C struct to a Haskell struct?
08:01:52 <indiagreen> if you do “let x = ...”, it'll be memoised
08:01:55 <obadz> sorry C string to Haskell record?
08:02:31 <indiagreen> emlun: if you want memoisation, you can use one of the memoisation libraries
08:02:50 <indiagreen> @hackage MemoTrie
08:02:50 <lambdabot> http://hackage.haskell.org/package/MemoTrie
08:03:00 <Cale> emlun: If we did memoise all functions automatically, nothing would ever be garbage collected
08:03:00 <indiagreen> @hackage data-memocombinators
08:03:00 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
08:03:09 <emlun> Cale: ah, good point
08:03:10 <indiagreen> I don't remember which of these is better
08:04:00 <emlun> indiagreen Cale: it's no biggie, I was just curious of whether Haskell did it out of the box since it's one of those things you could do aggressively if referential transparency is guaranteed
08:04:28 <saep> > let fibs = 1:1:scanl1 (+) fibs in fibs !! 3000
08:04:29 <lambdabot>  4106158863079712603335683787192671052201251086373692524088854309269055842741...
08:04:41 <indiagreen> we actually have troubles sometimes even with the way GHC currently does things
08:05:11 <indiagreen> lists like [1..10000000] being kept in memory when they are used twice (while it's much cheaper to generate the list again each time)
08:05:23 <geekosaur> you can do it aggressively if you have infinite memory and assume hashing is O(1) with a tiny constant
08:05:46 <emlun> yeah
08:06:17 <indiagreen> it's also one of the reasons why GHC doesn't do agressive common subexpression elimination, I think
08:06:38 <indiagreen> * aggressive
08:07:13 <catgocat> @let f n=mapM_(putStrLn.s)[0..3*n]where;d x=(++)$take(3*n)$cycle x;s x|x`mod`3<1=d"+--""+"|x`mod`6<3=d"|  |##""|"|1<2=d"|##|  ""|"
08:07:14 <lambdabot>  Defined.
08:07:20 <catgocat> > f 3
08:07:22 <lambdabot>      Ambiguous occurrence ‘f’
08:07:22 <lambdabot>      It could refer to either ‘L.f’, defined at L.hs:157:1
08:07:22 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
08:07:48 <catgocat> @let coolTable n=mapM_(putStrLn.s)[0..3*n]where;d x=(++)$take(3*n)$cycle x;s x|x`mod`3<1=d"+--""+"|x`mod`6<3=d"|  |##""|"|1<2=d"|##|  ""|"
08:07:49 <lambdabot>  Defined.
08:07:55 <catgocat> > coolTable 3
08:07:57 <lambdabot>  <IO ()>
08:08:14 <catgocat> xD
08:08:50 * hackagebot gtk3-mac-integration 0.3.1.0 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.1.0 (HamishMackenzie)
08:10:03 <catgocat> @let coolTable n=concat$map((++"\n").s)[0..3*n]where;d x=(++)$take(3*n)$cycle x;s x|x`mod`3<1=d"+--""+"|x`mod`6<3=d"|  |##""|"|1<2=d"|##|  ""|"
08:10:04 <lambdabot>  .L.hs:163:15:
08:10:04 <lambdabot>      Couldn't match type ‘[]’ with ‘IO’
08:10:04 <lambdabot>      Expected type: IO ()
08:10:17 <catgocat> @let coolTable2 n=concat$map((++"\n").s)[0..3*n]where;d x=(++)$take(3*n)$cycle x;s x|x`mod`3<1=d"+--""+"|x`mod`6<3=d"|  |##""|"|1<2=d"|##|  ""|"
08:10:18 <lambdabot>  Defined.
08:10:24 <catgocat> > coolTable2 5
08:10:26 <lambdabot>  "+--+--+--+--+--+\n|  |##|  |##|  |\n|  |##|  |##|  |\n+--+--+--+--+--+\n|##...
08:13:50 * hackagebot irc-fun-color 0.1.0.0 - Add color and style decorations to IRC messages.  http://hackage.haskell.org/package/irc-fun-color-0.1.0.0 (akrasner)
08:16:16 <ralu> > hf 2 3 100 where hf 0  x =  (x+); hf n  x =  ( foldl1 (hf (n-1)) ) . (flip  genericReplicate  x )
08:16:18 <lambdabot>  <hint>:1:12: parse error on input ‘where’
08:17:09 <ralu> > p = hf 2 3 100 where hf 0  x =  (x+); hf n  x =  ( foldl1 (hf (n-1)) ) . (flip  genericReplicate  x )
08:17:11 <lambdabot>  <hint>:1:3: parse error on input ‘=’
08:17:23 <ralu> > let p = hf 2 3 100 where hf 0  x =  (x+); hf n  x =  ( foldl1 (hf (n-1)) ) . (flip  genericReplicate  x )
08:17:24 <lambdabot>  <no location info>:
08:17:24 <lambdabot>      not an expression: ‘let p = hf 2 3 100 where hf 0  x =  (x+); hf n  x = ...
08:17:25 <ParahSailin_> anyone use Data.Dynamic for anything?
08:20:02 <ralu> >let p = hf 2 3 100 where; hf 0  x =  (x+); hf n  x =  ( foldl1 (hf (n-1)) ) . (flip  genericReplicate  x )
08:20:56 <geekosaur> the space after the initial > is required
09:09:18 <SrPx> Why all the questions with a #haskell tag are answered in 5 minutes stop pls
09:09:58 <indiagreen> yeah everyone stop so that SrPx could have some sweet sweet rep
09:10:08 <SrPx> really? :D
09:10:16 <indiagreen> no
09:10:19 <SrPx> :(
09:11:05 * SrPx barely feels qualified to answer a frac of those questions anyway
09:11:17 <indiagreen> that should motivate you to learn more!
09:11:34 <indiagreen> and then you'd be able to answer questions which aren't being answered in 5m
09:13:40 <SrPx> I don't think more motivation is even possible at this point :) more time would be sweet though
09:14:40 <indiagreen> SrPx: you can always switch to writing posts
09:14:55 <indiagreen> we have enough answers on SO but we don't have enough good tutorials for libraries
09:17:59 <SrPx> indiagreen: I will start writing a series of posts on how to implement things on the lambda calculus soon, but I'm not sure that is useful for Haskell... or for anyone. #haskell-blah
09:24:49 <muzzle> hi
09:24:57 <muzzle> how can i make my code OS specific ?
09:25:10 <muzzle> i.e. do an import only if i'm on linux
09:25:34 <muzzle> or return different class instances depending on the OS
09:26:06 <indiagreen> muzzle: http://hackage.haskell.org/package/filepath-1.4.0.0/docs/src/System-FilePath.html
09:26:18 <indiagreen> as an example
09:27:19 <muzzle> thx indiagreen
09:32:20 <catgocat> Hey guys I have a question
09:32:35 <hodapp> ASK!
09:32:36 <catgocat> I am using regexp and `=~ pat :: (String, String, String, [String])` doesn't return what is expected
09:33:01 <catgocat> @let pat = "(foo[a-z]*bar|quux)"
09:33:02 <lambdabot>  Defined.
09:33:20 <catgocat> > "b fookbar fooqbar after" =~ pat :: (String, String, String, [String])
09:33:22 <lambdabot>      Not in scope: ‘=~’
09:33:22 <lambdabot>      Perhaps you meant one of these:
09:33:22 <lambdabot>        ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
09:33:39 <catgocat> > import Text.Regex.Posix; "b fookbar fooqbar after" =~ pat :: (String, String, String, [String])
09:33:41 <lambdabot>  <hint>:1:1: parse error on input ‘import’
09:33:46 <catgocat> for fuck sake
09:33:51 <catgocat> how do you import stuff?
09:34:08 <catgocat> @import Text.Regex.Posix
09:34:08 <lambdabot> Unknown command, try @list
09:34:11 <catgocat> @list
09:34:11 <lambdabot> What module?  Try @listmodules for some ideas.
09:34:13 <geekosaur> with @let but not everything can beimported
09:35:24 <lpaste_> catgocat pasted “not_working_regexp” at http://lpaste.net/136862
09:35:29 <catgocat> see please
09:38:46 <muzzle> I want to return different implementations of a typeclass depending on the OS that i'm on. How would I do this. I cannt really give the function the type (Class a) => x -> a, can i?
09:38:52 <geekosaur> afaik that is correct behavior, if it is in after then it is not matched
09:38:59 <Lokathor> Is there a haskell IDE that presents the modules of the project and their functions/data/instances in a tree along one side in a tree, and then when you click one the "main" textual area displays only that entry?
09:39:07 <geekosaur> and the default behavior of =~ is *not* the equivalent of /g
09:39:30 <catgocat> the real-word-haskell book is so bad in reg expressions
09:39:39 <Lokathor> it's just an IDE style that I thought of, and was wondering if anyone had tried it before
09:40:10 <geekosaur> Lokathor, folding editors are a thing but I don't know if anyone has implemented it to that extent
09:40:20 <catgocat> real-word-haskell is such fucking stupid book! I mean it says that you can blabalba, but then it shows the code showing that you can't. what the fuck?
09:40:21 <geekosaur> for haskell or any other language, really
09:41:01 <nkaretnikov> muzzle: using CPP, i guess
09:41:02 <hodapp> geekosaur: it's common for Java I thought, if I'm thinking of 'folding' riht
09:41:03 <geekosaur> catgocat, can you show the section of RWH that leads you to believe that should work?
09:41:05 <hodapp> s/riht/right/
09:41:09 <Lokathor> Well i think with other languages (eg: java/python) you wouldn't really want it so seperated up like that because you'd lose track of class variables a little
09:41:23 <catgocat> geekosaur: I don't believe anything, it's bad written. http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
09:41:31 <catgocat> Start reading it and you'll notice the trash
09:41:41 <Lokathor> hmm. I'd make a prototype, but my Haskell isn't good enough to make this sort of thing, so I'd probably have to make it in java instead XD
09:41:55 <catgocat> scroll to regexps
09:42:06 <nkaretnikov> catgocat: you should be more careful with words, it's a good book, but a bit dated.
09:42:13 <geekosaur> RWH is rather old at this point, the Haskell ecosystem moves quickly
09:42:21 <catgocat> Not a good book in terms of regexps
09:42:24 <geekosaur> but 90%+ of the time if it involves regex, it's you that are wrong
09:42:36 <catgocat> it says stuff and then says the complete opposite
09:42:59 <geekosaur> in particular, you claimed that fooqbar should be in both after and in the list of submatches, *that* is a contradiction
09:43:00 <catgocat> it shows code that contradicts what has just been said
09:43:10 <hodapp> catgocat: can you name a specific contradiction you have in mind?
09:43:11 <catgocat> see it for youself
09:43:35 <catgocat> hodapp: in that rwh page, search for "Another valid type of result is [String], which returns a list of all matching strings."
09:44:34 <catgocat> seriously, what the hell
09:44:46 <hodapp> catgocat: go on...
09:44:49 <catgocat> it shows code that contradicts what he just said
09:45:01 * geekosaur is looking at that part and it shows type errors instead of results...
09:45:21 <geekosaur> which makes me think things changed out from under it, but is it actually running those when the page is loaded?!
09:46:00 <geekosaur> that said, I think "Asking for a four-element tuple gives us a fourth element that's a list of all groups in the pattern that matched." does not mean what you think it does
09:46:04 <catgocat> I don't know.. I just think it's really bad .
09:46:05 <geekosaur> you have *one* group, it matched
09:46:26 <catgocat> it shows type-errors instead of the result for 20 paragraphs
09:46:31 <geekosaur> "all groups that matched" does not mean "all ways it could match"
09:46:35 <catgocat> and the code doesn't even compile on my end
09:47:14 <geekosaur> again, RWH is out of date
09:47:33 <geekosaur> sorry there isn;'t an army of monkeys to update every book to ghc 7.10.2RC2 before you look at it
09:47:38 <benzrf> :>
09:47:57 <geekosaur> but your expectation is still incorrect
09:48:21 <hodapp> geekosaur: I'm working on it, for God's sake. Do you have any idea how hard it is to train monkeys to use a package manager?
09:48:22 <catgocat> I just want a good haskell book to follow
09:48:23 <geekosaur> "all groups that matched" does not mean "all ways it could match"
09:48:26 <catgocat> why is that so hard to find?
09:48:40 <geekosaur> you're not going to find one that helps you with regex, because Haskellers don't like regex
09:48:49 <geekosaur> and this misunderstanding of yours is one of the reasons why
09:48:52 <catgocat> geekosaur: fine, forget that example. I am now talking about the rest of the book
09:49:49 <geekosaur> if you are not in a position to deal with a book that is intended for ghc 6.x then do not use that book
09:49:52 <ChristianS> for regex-related stuff, perl is still my language of choice
09:50:02 <sm> catgocat: there is no good guide to using regexps in haskell anywhere I think
09:50:20 <catgocat> I know regExp
09:50:23 <sm> you should write one when you figure it out :)
09:50:25 <geekosaur> apparently not
09:50:32 <catgocat> but I need to know the actual API to use it, with help of modules
09:50:40 <geekosaur> http://lpaste.net/136862 is still wrong
09:50:43 <catgocat> I use regexp in javascript for example
09:51:00 <catgocat> RegExp /= Haskell functions
09:51:06 <nkaretnikov> catgocat: just use rwh as a reference, try the existing libraries.  read other sources, e.g., the wiki book
09:51:21 <nkaretnikov> catgocat: for example, the section on profiling is still relevant
09:51:23 <nkaretnikov> and useful
09:51:40 <catgocat> I haven't reached that part yet.. let's see how it goes
09:52:04 <nkaretnikov> catgocat: join #haskell-beginners, folks there could recommend more resources
09:53:11 <lpaste_> geekosaur annotated “not_working_regexp” with “not_working_regexp (annotation)” at http://lpaste.net/136862#a136863
09:54:01 <nkaretnikov> catgocat: for rwh reading comments may be quite useful since people post suggestions there.  and, as I said, just use it as a reference.  pick the recent version of a library they're explaining and play around.
09:54:12 <geekosaur> and (c) javascript is probably using PCRE, which is NOT fully compatible with POSIX ERE; although that should not be relevant here
09:54:27 <nkaretnikov> the wiki book is quite good in a sense that you don't have to wait for the authors to update it, you're the author
09:55:59 <nkaretnikov> simon marlow's book on parallelism and concurrency is quite recent if you're ready for that sort of thing
09:57:15 <nkaretnikov> there are nice blog posts like ocharles' 24 days of ghc extensions
09:58:14 <nkaretnikov> basically, if you're comfortable with the language, just try to implement something, then ask for feedback
10:02:52 <beckyconning_> how do you update a cabal package to the latest version?
10:03:43 <muzzle> Say i want to return two different instances of a typeclass from a function depending on a random number. How can I do that?
10:04:08 <glguy> beckyconning_:  I unregister the old one and then install the new one. I have tool I use to recursively unregister packages and to detect outdated ones
10:04:19 <Zekka> muzzle: Typeclasses instances aren't values and can't be returned
10:04:33 <Zekka> Are you sure you don't mean instances of a type?
10:04:40 <glguy> https://github.com/glguy/GhcPkgUtils is what I use for that
10:05:06 <beckyconning_> ty glguy
10:05:16 <geekosaur> muzzle, you can't do that, the caller decides what type you return
10:05:50 <geekosaur> maybe you want a parameterized record instead of a typeclassd
10:06:19 <muzzle> geekosaur i want to expose a function in a module that should return a different type class instance depending on the os
10:06:30 <muzzle> geekosaur but i want to expose the module
10:06:32 <muzzle> in a library
10:07:40 <fr33domlover> Q: when should I use unordered-containers (and not containers)? Whould not needing element ordering be a good enough reason, practically?
10:07:42 <Zekka> muzzle: Like I said, typeclasses aren't values, so you can't return them
10:07:52 <Zekka> (apologies if that's not helpful but I'm not sure what you mean)
10:07:59 <Zekka> er, typeclass instances*
10:08:14 <Zekka> muzzle: Can what you're trying to do be accomplished via conditional compilation?
10:08:16 <muzzle> so what i would like to do is have a function like f :: (OSDependentClass a) => a that can return a Microsoft instance or a Linux instance depending on OS, how would i emulate functionality like this ?
10:08:45 <muzzle> Zekka: I don't want to force the caller to write OS specific code
10:09:00 <muzzle> Zekka I completely want to abstract the OS specifics away for the caller
10:09:16 <Zekka> muzzle: Oh, sure, I follow you. This really sounds like a case for conditional compilation though
10:09:40 <muzzle> My use-case is specifically this package of mine: https://github.com/kryoxide/delta
10:09:43 <geekosaur> you don't want to do it based on a random number, I think. for testing I'd probably use unsafePerformIO to pull an envar saying whether the library is in POSIX or Windows compatibility mode, and then have some certainty that everything is using the same type
10:09:59 <geekosaur> you still do not get to choose inside your function, though; the caller controls the return type
10:10:02 <muzzle> geekosaur: random number was a bad example
10:10:13 <muzzle> i wanted to do it with CPP pragmas in the function
10:10:34 <geekosaur> the best you can hope for there is that the caller infers the type or that you export one or the other type depending on CPP
10:10:41 <Zekka> You could also make your function return a specific type -- then if the caller wants to ignore it, it can be less specific
10:10:42 <geekosaur> the latter is probably better
10:11:08 <fizbin1> muzzle: Call your typeclass Tc and the two types with instances of Tc TcWin and TcMac (or more). Then, I'd create data TcGeneric = TcW TcWin | TcM TcMac and declare instance Tc TcGeneric defined in the obvious way.
10:12:00 <fizbin1> Then from your module export only the TcGeneric type, and not its constructors. (and not the os-specific types)
10:12:12 <muzzle> example of what i would like it to look like http://lpaste.net/136864
10:13:36 <simon> if I write 'ghci Foo.hs', I get to prod its non-exported values. if I 'cabal repl', I don't. how do I interact with a particular file inside a project?
10:15:39 <muzzle> I have the feeling I'm doing something wrong when coding haskell. I often run into the problem that i want to return different typeclass instances from functions. What is a better approach ? This is just one of my use-cases
10:17:27 <geekosaur> that sounds to me like you are used to OO types, where you can return any subclass of a declared class
10:17:42 <fizbin> muzzle: I tried to explain above, but let me finish rewriting your example to what will work.
10:17:44 <muzzle> geekosaur i probably am :S
10:17:49 <geekosaur> typeclasses are not OOP and don't work that way; as I said, it is the caller who specifies the return type
10:18:56 <geekosaur> if you declare foo :: Num a => ... -> a, this tells the caller that it can pick any type a that is an instance of Num and you will produce a value of that type
10:19:03 <geekosaur> s/you/foo/
10:19:18 <geekosaur> it does not mean that foo can pick a type a itself
10:19:23 <muzzle> Sure but what if i have a lot of datatypes that i can run a given set of functions on. How would i do that. The problem with data declarations in my head is just, that i can't add to them (when i'm using a library e.g.)
10:20:15 <muzzle> And by adding to them i mean adding new variants to the sum type
10:21:42 <geekosaur> this may be where the first thing I suggested some time ago comes in: you have a record type containing functions and return a value of that type with appropriate functions in it
10:24:34 <fizbin> Hrm. So, muzzle, one possibility is http://lpaste.net/136865
10:25:08 <fizbin> But it occurs to me that if your real worry is extensibility, maybe a different pattern would work. Just a moment...
10:30:43 <cow_2001> why would i have an (IO (IO a)) type and not (IO ())
10:33:03 <muzzle> geekosaur Zekka fizbin would this also be ok? I commented out my current version… http://lpaste.net/136866
10:36:27 <fizbin> muzzle: Another possibility is http://lpaste.net/136867 , but you might have to study that a bit to see how it works.
10:38:29 <subleq__> I have a function compile :: Ast -> String. Its code is super ugly and I want to add pretty-printing. Is there a nice pattern for this sort of thing?
10:39:45 <muzzle> Is there actually a use case where you can't use a datatype for something but can use a typeclass ?
10:41:32 <geekosaur> that question sounds like you don't have a firm understanding of what typeclasses are
10:41:42 <geekosaur> :t (+)
10:41:43 <lambdabot> Num a => a -> a -> a
10:41:53 <hhhelp> Hi all, I'sd like to output a list to a file, each item on a line. 
10:42:28 <hhhelp> I tried :  writeFile ("outt.txt")  $ unlines ["a","b"]     But the output in the file has all the elements on the same line
10:42:34 <muzzle> geekosaur, but couldn't i make Num with a datatype ?
10:42:48 <hhhelp> and a character ^j seprating them
10:43:35 <geekosaur> hhhelp, that would be expected... on a unixlike. I take it you are on Windows?
10:44:02 <hhhelp> geekosaur: on a mac
10:44:17 <geekosaur> macs use ^J as line separator
10:44:27 <geekosaur> unless you are using an editor badly ported from OS 9
10:45:26 <hhhelp> geekosaur: when I cat the file it prints out correctly, in vim I saw those characters.
10:45:51 <hhhelp> I'll investigate thanks. But is the way I am doing it the right way in haskell?
10:45:54 <geekosaur> somehow your vim is expecting windows or macos9
10:45:55 <muzzle> geekosaur so technically something like http://lpaste.net/136868
10:46:06 <geekosaur> hhhelp, that is the right way to do it, yes
10:46:20 <hhhelp> geekosaur: great
10:46:38 <koala_man> my program compiles very slowly but ghci (cabal repl) loads really fast. can I run the entire program interpretted for testing purposes to avoid compiling?
10:46:56 <geekosaur> you can, but it will run more slowly
10:47:00 <koala_man> that's fine
10:47:07 <geekosaur> (there is also runhaskell which is interpreted)
10:47:33 <geekosaur> muzzle, that's more or less what a typeclass is
10:48:10 <fizbin> geekosaur: Is there a cabal command that just does something like runhaskell?
10:48:18 <fizbin> "cabal run" compiles first.
10:48:49 <geekosaur> not so far as I know. but if your cabal-install isn't ancient then "cabal exec -- runhaskell ..." should work
10:48:56 * hackagebot Network-NineP 0.4.0 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.4.0 (SergeyAlirzaev)
10:49:11 <geekosaur> although that probably compiles first too, or at least configure-s
10:50:25 <fizbin> Right, but then koala_man could use "cabal exec -- runhaskell MyProg.hs" since he's apparently getting acceptable start times from "cabal run"
10:50:49 <fizbin> Sorry, meant: ... getting acceptable start times from "cabal repl"
10:53:07 <koala_man> I can't figure out how it works. I tried 'cabal exec -- runhaskell myprogram.hs'  but it complains about missing packages just like 'runhaskell myprogram.hs' and like ghci if I don't use cabal repl 
10:54:09 <Welkin> koala_man: 
10:54:18 <Welkin> koala_man: what is the structure of your project?
10:54:27 <Welkin> is your course in a subdirectory?
10:54:39 <koala_man> my what?
10:55:19 <Welkin> if so, use this: cabal exec -- ghc lions/bears.hs -ilions
10:56:01 <fizbin> koala_man: Can you try something like: runhaskell -package-db=.cabal-sandbox/i386-windows-ghc-7.8.3-packages.conf.d  myprogram.hs       (where obviously you use the actual name of the actual directory in .cabal-sandbox)
10:57:25 <glguy> I'd be interested to know what "cabal repl" doesthat makes things so slow. I get keyboard lag sometimes just typing into GHCi using it
10:57:51 <koala_man> fizbin: I have no idea how cabal works and I don't have a .cabal-sandbox in either my cabal dir or my home dir
10:58:18 <fizbin> Oh, I thought that's why you were using "cabal repl" instead of just ghci.
10:58:24 <fizbin> Are you using cabal-dev?
10:59:01 <fizbin> I just couldn't imagine a reason to use "cabal repl" instead of ghci unless you were using a sandbox.
10:59:15 <koala_man> my project has some magic that gets the version number from the cabal file, and I guess cabal generates some files to make that happen
11:00:16 <fizbin> With CPP macros?
11:01:01 <glguy> The version is added to your library's Paths module
11:01:51 <koala_man> yes, that's the one
11:02:05 <koala_man> how do I get the Paths module included
11:02:07 <Zemyla> So I wrote a program for serialization and deserialization using generics. Should I put a prism in for encoding and possibly decoding to ByteStrings?
11:03:56 <koala_man> fizbin, Welkin: I straced cabal repl and it turns out I can use  runhaskell -idist/build/autogen myprogram.hs. thanks!
11:04:48 <glguy> koala_man: Some projects add a .ghci file to set that up automatically
11:05:05 <glguy> https://github.com/ekmett/lens/blob/master/.ghci
11:05:20 <koala_man> oh nice
11:06:19 <fizbin> glguy: What's -optP for? does that pass options to CPP?
11:06:30 <hhhelp> drawTree :: Tree String -> String
11:07:25 <hhhelp> If I have a Tree Int instea dof the Tree String is there a way to convert it to Tree String so I can use the drawTree function above?
11:08:05 <fizbin> hhhelp: Does your Tree type have a Functor instance?
11:08:07 <mauke> hhhelp: what Tree type is this?
11:08:54 <hhhelp> I am using the Data.Graph library, the dfs function returns a Forest Vertex
11:09:27 <Zemyla> It should have a functor instance. You would be able to just drawTree . fmap show.
11:09:38 <hhhelp> What I would like to actually do is traverse my Data.Graph with bfs, but unfortunately my attempts have not worked well
11:10:56 <hhhelp>     Couldn't match type ‘Int’ with ‘[Char]’     Expected type: Tree String       Actual type: Tree Int     In the first argument of ‘drawTree’, namely ‘x’     In a stmt of a 'do' block: drawTree x fmap show
11:11:00 <geekosaur> fizbin, yes
11:11:33 <fizbin> hhhelp: You misread what Zemyla was suggesting.
11:11:34 <hhhelp> fizbin: I'm not sure, fairly new to haskell
11:11:50 <glguy> drawTree (fmap show x)
11:11:58 <fizbin> They were suggesting: drawTree (fmap show x)
11:12:15 <fizbin> Or, equivalently, (drawTree . fmap show) x
11:13:45 <hhhelp> fizbin: perfect, yeah that works, thanks
11:13:57 * hackagebot amqp 0.13.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.13.0 (HolgerReinhardt)
11:14:13 <hhhelp> glguy Zemyla and mauke thanks to you too
11:14:42 <hhhelp> Any reason why there is no bfs function in the Data.Graph library?
11:15:42 <hhhelp> I see one in another library, Data.Graph.Inductive.Query.BFS 
11:16:17 <hhhelp> But from my understanding the Graph types are different and I cannot use the BFS search on my graph from Data.Graph
11:17:04 <fizbin> You can't use that implementation of BFS, no.
11:18:53 <fizbin> But container's Data.Graph is pretty open in its representation so you should be able to roll your own BFS.
11:18:58 * hackagebot dash-haskell 1.1.0.2 - Convert package Haddock to Dash docsets (IDE docs)  http://hackage.haskell.org/package/dash-haskell-1.1.0.2 (johnfeltz)
11:19:10 <Welkin> BFS is very easy with Data.Graph
11:20:20 <hhhelp> I'll have to give it another shot with writing my own
11:21:27 <Welkin> I like to use Data.Sequence for my queues
11:21:35 <Welkin> it's simple
11:22:18 <hhhelp> ok, i'll look at Data.Sequence, I'll be sure to ask if I get stuck
11:26:40 <fizbin> Hrm. Something like: bfs gr start = go S.empty [start] where go _ [] = []; go s (x:xs) | S.member x s = go s xs ; go s (x:xs) = x : go (S.insert x s) (xs ++ (gr ! x))
11:27:05 <fizbin> (Where you've imported Data.Set qualified as S)
11:28:42 <fizbin> @type let bfs gr start = go S.empty [start] where {go _ [] = []; go s (x:xs) | S.member x s = go s xs ; go s (x:xs) = x : go (S.insert x s) (xs ++ (gr ! x))} in bfs
11:28:43 <lambdabot> Ix i => Array i [i] -> i -> [i]
11:30:21 <fizbin> @type let bfs :: Data.Graph.Graph -> Data.Graph.Vertex -> [Data.Graph.Vertex]; bfs = undefined in bfs
11:30:22 <lambdabot> Graph -> Vertex -> [Vertex]
11:31:01 <fizbin> @type let bfs gr start = go S.empty [start] where {go _ [] = []; go s (x:xs) | S.member x s = go s xs ; go s (x:xs) = x : go (S.insert x s) (xs ++ (gr ! x))} in bfs :: Data.Graph.Graph -> Data.Graph.Vertex -> [Data.Graph.Vertex]
11:31:02 <lambdabot> Graph -> Vertex -> [Vertex]
11:31:34 <fizbin> Okay, so the type unifies with the right thing, and it compiles. I think it also works.
11:32:50 <hhhelp> If I get this error? a1.hs:10:141: Not in scope: ‘!’
11:33:34 <fizbin> hhhelp: import Data.Array ((!))
11:40:32 <hhhelp> fizbin: Thank You! That seems to work great
11:51:16 <ralu> is there way to make c binding from h file?
11:51:32 <blup> This might not be the right channel, but.. I'm a js developer and I'm trying to learn some of the basic/intermediate concepts of functional programming. So far the clearest and most helpful doc i've found is https://github.com/DrBoolean/mostly-adequate-guide , but elas its not yet complete.
11:52:12 <fizbin> ralu: I don't quite understand what you're asking. Are you asking how to use the Haskell FFI?
11:52:14 <blup> I was wondering if I could get some recommendations. Not necesarily language specific, but i have to say I'm not proficient at all in Haskell.
11:52:26 <ralu> i know that
11:53:20 <fizbin> blup: The best reference I know for functional stuff from a javascript background is the book "Javascript: The Good parts". You may be able to find places where people are talking about what's in that book.
11:53:51 <blup> fizbin: thanks, i'll take a look at it
11:54:10 <nkaretnikov> blup: would you like to learn haskell?
11:54:30 <fizbin> ralu: Then... what _are_ you asking?
11:54:53 <blup> nkaretnikov: i have no use for it, but i find it very interesting.
11:55:07 <nkaretnikov> blup: what do you may by no use?
11:55:15 <ralu> i have h file and .so .Do I have to rewrite all prottypes in haskell?
11:55:21 <blup> nkaretnikov: i'm a front-end dev mostly
11:55:23 <mauke> ralu: I think c2hs can help with that
11:55:26 <nkaretnikov> blup: there's ghcjs
11:55:58 <nkaretnikov> blup: there's yesod which defines a few dsls for html,javascript,css
11:56:05 <lethjakman> I'm not sure what you're talking about, but I know purejs is supposed to be nice, however it isn't haskell
11:56:25 <lethjakman> it's purely functional, transpiles into javascript.
11:56:32 <nkaretnikov> blup: I'd recommend you to start with haskell, really.  it won't let you to "cheat" when you're learning new concepts
11:56:34 <lethjakman> elm is supposed to be cool, it has some cool versioning stuff to iit
11:56:56 <blup> nkaretnikov: i'm mostly interested for the intellectual aspect of it. i can't change languages right now :)
11:57:16 <blup> lethjakman: yes, elm is quite intesresting
11:57:26 <nkaretnikov> blup: I'm saying that with javascript or python or whatever you won't be able to fully appreciate functional programming
11:57:38 <nkaretnikov> blup: any you might get a wrong impression because of that
11:57:40 <lethjakman> blup: have you used it?
11:58:00 <lethjakman> agreed. javascript kinda sucks at being functional compared to haskell. 
11:58:06 <blup> nkaretnikov: its just, there are so many haskell concepts that leak into JS.. i guess you're right and i should learn from th source
11:58:13 <nkaretnikov> blup: for example
11:58:14 <lethjakman> actually. I just don't like javascript personally so don't ask me. 
11:58:29 <nkaretnikov> blup: you can't really write in functional style if you want fast javascript code
11:58:39 <nkaretnikov> same for python
11:58:45 <lethjakman> Array.new(300) and [300] should be the same thing, especially if Array.new(301,302) == [301, 302]
11:58:55 <lethjakman> clojures are a bit slow in JS
11:58:55 <blup> nkaretnikov: yea, thats one aspect that bugs me a bit. its more elegant, but less efficient
11:59:01 <albz> Why is it that if I read a file as a bytestring, then print it, appears as &#39, but if I use putStrLn, it appears as '?
11:59:06 <lethjakman> I disagree with the elegance. 
11:59:24 <nkaretnikov> blup: there's #haskell-beginners, btw
12:00:51 <blup> nkaretnikov: thanks again
12:00:56 <nkaretnikov> one more thing
12:00:56 <mniip> albz, because print uses show
12:01:03 <mniip> > show "'"
12:01:04 <lambdabot>  "\"'\""
12:01:30 <nkaretnikov> blup: learning functional programming in javascript is possible, but it's a minefield.  functional programming is all about referential transparency, and it javascript has lots of implict conversion rules
12:01:33 <albz> Hm. If I write this bytestring back to a file, how will it appear ?
12:01:45 <mniip> albz, depends on what you use to write it?
12:02:04 <albz> If I want it to appear as ', what should I use? :p
12:02:11 <blup> nkdaretnikov: not sure if i follow. do you mean the lack of types?
12:02:13 <mniip> anything that doesn't use show?
12:02:16 <nkaretnikov> blup: no
12:02:26 <mniip> print = putStrLn . show
12:02:39 <nkaretnikov> blup: I mean things like "2" + 2
12:02:51 <nkaretnikov> blup: scala has types for instance, but it still has the same problems
12:03:01 <blup> nkaretnikov: ah yes, the easter eggs as i call them
12:03:25 <mniip> blup, it's not lack of types
12:03:25 <nkaretnikov> blup: there's a lot of frontend-ish stuff you can do with haskell
12:03:28 <mniip> javascript has types
12:03:42 <mniip> I assume you're referring to dynamic typing and overloading
12:04:01 <blup> yes
12:08:23 <blup> nkaretnikov: sorry to bother again, but do you have any recommendations on docs/books on basic concepts in haskell/fp? monads, transformers etc...
12:08:23 <blup> again, not so interested in the language itself as much as the theory behind it
12:09:17 <mniip> blup, beware, most of those papers use haskell to describe things
12:10:14 <nkaretnikov> blup: I think there's a beginners guide on #haskell-beginners, let's move there
12:11:40 <nkaretnikov> blup: anyway, here's the guide: https://github.com/bitemyapp/learnhaskell
12:11:50 <Welkin> blup: use learnhaskell
12:11:53 <Welkin> @where learnhaskell
12:11:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:12:06 <nkaretnikov> blup: for transformers, etc. see "the topic listing" on that page
12:12:07 <Welkin> the UPenn course, followed by NICTA
12:12:18 <Welkin> and read the Typeclassopedia
12:13:44 <nkaretnikov> blup: when I want to learn a new topic, I just search around, find something that looks suitable, and read that.  if it doesn't work for me, I move on to the next thing
12:14:28 <nkaretnikov> blup: all people are different and have different backgrounds.  so don't give up if the recommended stuff doesn't work for you
12:15:39 <Welkin> yes
12:15:46 <Welkin> you should try lots of different resources
12:16:02 <Welkin> books, essays, courses, this channel
12:16:47 <blup__> Nkaretnikov: sorry lost my connection and dont know if you replied. Thanks.
12:16:58 <nkaretnikov> blup__: yeah, I replied
12:16:59 <nkaretnikov> one sec
12:17:10 <nkaretnikov> blup__: I'll just give you a link to the logs
12:17:23 <blup__> Thanks
12:17:39 <nkaretnikov> blup__: http://ircbrowse.net/browse/haskell?events_page=602045
12:19:25 <mniip> bitemyapp, :o typo
12:19:30 <blup__> Thanks again.. Now for a bit of light reading :)
12:19:35 <mniip> install.md, "Users of other Unix-like Systmes"
12:32:31 <P4Titan> Hello all, is there an easy way to see the implentation source code
12:32:34 <P4Titan>           for Functor [] for example?
12:32:37 <Welkin> yes
12:32:45 <P4Titan> How exactly?
12:32:50 <Welkin> look at the docs on hackage and click "source"
12:33:02 <Welkin> also, lambdabot has a command
12:33:06 <Welkin> @src [] Functor
12:33:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:33:12 <Welkin> @src Functor []
12:33:12 <lambdabot> Source not found. Wrong!  You cheating scum!
12:33:20 <geekosaur> but @src is dumb
12:33:21 <P4Titan> @src [] fmap
12:33:21 <lambdabot> fmap = map
12:33:23 <Welkin> ah
12:33:24 <geekosaur> and missing many things
12:33:41 <Welkin> I prefer to read the sourcecode
12:33:48 <Welkin> you get all the comments then too
12:33:56 <Welkin> base is extensively annotated
12:33:58 <P4Titan> So, I clicked source on fmap, but that does not lead me to the source of fmap on []
12:34:27 <Welkin> search the page for "instance Functor []"
12:34:52 <Welkin> https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#line-712
12:34:54 <albz> I'm converting a Text to ByteString using a toJSON instance, then writing this bytestring to a file. I see in the text of that file many things like \u003e instead of >. Why is this?
12:35:04 <P4Titan> I guess that is circumvent, I was just wondering for a more direct method
12:35:12 <bitemyapp> mniip: ?
12:35:15 <Welkin> albz: it is just a different representation of it
12:35:21 <bitemyapp> mniip: oh thank you
12:35:35 <albz> Welkin: I get that - but why doesnt this happen if I directly write a Text to a file?
12:35:37 <indiagreen> P4Titan: go to Functor (http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Functor.html#t:Functor), and you'll see a “Functor []” line in the “Instances” section, and “Source” next to it
12:36:05 <Welkin> albz: did you call show on it at any point?
12:36:09 <albz> Nope
12:36:21 <P4Titan> Why are they not here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Data-Functor.html#t%3AFunctor
12:36:24 <geekosaur> albz, possibly a safety thing to keep it from being interpreted as part of an HTML sequence?
12:36:25 <Welkin> it is the same data
12:36:31 <Welkin> it is just not displayed how you want
12:36:32 <albz> I just used Data.ByteString.Lazy writefile
12:36:49 <albz> Does aeson do this escaping from html?
12:37:35 <indiagreen> P4Titan: I guess those were generated with different Haddock options
12:37:59 <P4Titan> Ok, how did you get to yours?
12:38:03 <ChristianS> albz: aeson has nothing to do with html
12:38:06 <indiagreen> I gave you a link
12:38:14 <indiagreen> and I got it from hayoo
12:38:18 <P4Titan> Ok
12:38:20 <indiagreen> you can also get it from hoogle
12:38:31 <indiagreen> I recommend adding browser shortcuts for hayoo and hoogle
12:38:35 <indiagreen> hg/hy
12:38:44 <indiagreen> I use them all the time, very convenient
12:38:51 <Welkin> if you use duckduckgo, they are built in already
12:38:56 <Welkin> hoogle is !h, hayoo is !hayoo
12:39:03 <indiagreen> most people don't use duckduckgo but use a browser
12:39:10 <Welkin> I use a browser
12:39:17 <Welkin> but ddg is my default search engine
12:39:25 <P4Titan> startpage anyone?
12:39:35 <indiagreen> sorry, I'm just biased against replacing already existing functions with web-based alternatives
12:39:43 <indiagreen> so-o ignore me
12:39:58 <P4Titan> no one is a startpage fan?
12:40:07 <bennofs> what is start
12:40:10 <P4Titan> Anyway, hoogle takes me to the docs with the source on instages
12:40:21 <P4Titan> startpage is a search engine
12:40:38 <indiagreen> P4Titan: nah, I like my customised search recommendations
12:40:46 <indiagreen> and the ability to see what I googled a year ago
12:40:53 <P4Titan> Ok =)
12:40:55 <albz> ChristianS: I get that, but I really cant understand why Text -> ByteString via aeson results in u003cli
12:41:06 <albz> rather than <
12:41:21 <indiagreen> albz: Aeson does escaping, yes
12:41:28 <albz> indiagreen: Ah!
12:41:39 <albz> Ok, then that makes sense. Is there a way to avoid it ?
12:41:45 <indiagreen> it doesn't have to, but it does anyway to prevent some XSS attack or whatever
12:42:30 <indiagreen> no, you can't turn it off
12:42:35 <albz> ok, cool.
12:43:30 <P4Titan> :t sequence
12:43:31 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:44:02 <ttt_fff> data Foo a b = Foo a b // now, I want (Foo a b) -> b // now, is there a builtin in Control.Lens which will do this for me? i.e. selecting the 2nd arg, even when it's not a tuple?
12:44:15 <benzrf> has anyone proven that the implemetation of ST is identical to something implemented entirely purely?
12:44:26 <benzrf> ttt_fff: thats not possible in general
12:44:30 <Welkin> benzrf: bacon pancakes
12:44:38 <benzrf> Welkin: ?
12:44:50 <benzrf> ttt_fff: you need to at very least instantiate some kind of class that exposes info about the type
12:45:09 <P4Titan> :t tails
12:45:10 <lambdabot> [a] -> [[a]]
12:45:16 <mniip> benzrf, ST can be implemented with State [forall a. Typeable a => a]
12:45:21 <benzrf> ttt_fff: how could you write a function that operates on 'Foo's with no typeclass help without being able to see the type Foo?
12:45:30 <ttt_fff> oh right, because if we had "data Foo a b = Foo a b | Bar a | Cat b" ... then we're sorta fucked if we want (Foo a b -> b)
12:45:35 <benzrf> er
12:45:40 <ttt_fff> because (Bar a) can't produce a b
12:45:50 <ttt_fff> benzrf++
12:45:51 <mniip> but yes
12:45:53 <benzrf> were you thinking of `p a b -> b' or something
12:45:54 <mniip> you still have limitations
12:46:07 <ttt_fff> benzrf what is 'p' ?
12:46:11 <benzrf> ttt_fff: parametric
12:46:16 <benzrf> i dont see what other type you would want from Lens
12:46:20 <benzrf> *lens
12:46:22 <ttt_fff> I don't know. I don't know what parametric is.
12:46:30 <benzrf> like the 'a' in 'a -> a'
12:46:40 <benzrf> it's forall'd
12:47:11 <ttt_fff> benzrf: I have no clue what you are tlaking about
12:47:14 <ttt_fff> but I am convinced that I am wrong
12:47:15 <benzrf> anyway, lens has makeLenses, which uses template haskell magic to read your type def and generate lenses/traversals/etc
12:47:18 <ttt_fff> and I need to debug my thought process
12:47:25 <ttt_fff> I know abou tmakeLenses, it's not what I want
12:47:30 <benzrf> yeah?
12:47:39 <benzrf> what do you want
12:48:30 <ttt_fff> I'm not sure what I want anymore.
12:48:33 <ttt_fff> Ineed to debug jy thinking.
12:48:47 * ttt_fff just worke up and hasn't ahd coffee yet.
12:49:25 <indiagreen> ttt_fff: something has been bugging me for maybe a day by now
12:49:37 <indiagreen> wasn't your nick ttt_tff or ttf_fff or something at one point?
12:50:03 <ttt_fff> indiagreen: un-oh, I thought you were going to reveal that at one point I was in #ocaml
12:50:06 <ttt_fff> phew
12:50:12 <benzrf> indiagreen: i will grep my logs!
12:50:31 <ttt_fff> there may have been times, where due to typos, I used ttt_tff or ttf_fff or some variant of [tf]^3_[tf]^3, but I tend to mostly use ttt_fff
12:51:04 <ttt_fff> though, if this irritates you, it gives me a brilliantly evil idea
12:51:10 <indiagreen> it's just that I always felt that “ttt_tff” was done on purpose, like— don't
12:51:22 <ttt_fff> of cycling through nicks that are 1 char away from ttt_fff , yet matches regex [tf]^3_[tf]^3
12:51:53 <ttt_fff> you may be overanalyzing
12:52:00 <ttt_fff> I don't have an irc client; I'm using wechat.freenode.net
12:52:02 <benzrf> theres one result not from today
12:52:05 <ttt_fff> so I have to retype-in nick every time
12:52:20 <benzrf> oh, its just indiagreen's type
12:52:23 <benzrf> *typo
12:52:25 <benzrf> [23:02:14] <indiagreen> @tell ttf_fff you can use Â«left N '0'Â» (where N is the number of chars you want to have). For lazy Text, use justifyRight
12:52:25 <ttt_fff> and when I'm typing in the nick, I'm not focused on the nick, I'm focused on the dumbass retarded stupidass captcha I need to solve
12:52:38 <benzrf> ttt_fff: plz dont use 'retarded', its ableist
12:52:38 <indiagreen> ...interesting
12:52:58 <ttt_fff> benzrf: what do you mean? webchat is merely a slowly developing irc chat client
12:53:04 <benzrf> sigh
12:53:08 <ttt_fff> it's the politically correct use of 'retard' (as in slow in development)
12:53:15 <benzrf> no it isnt
12:53:21 <benzrf> indiagreen: all other instances of [tf]{3}_[tf]{3} that arent ttt_fff are either from today, or are that
12:53:54 <ttt_fff> also, I'd like to point out, on the record, taht ttt_fff is not registered
12:54:00 <ttt_fff> so not all uses of ttt_fff are necessairly me
12:54:11 <benzrf> who else would want such a shitty nick
12:54:14 <benzrf> B)
12:54:21 <ttt_fff> benzrf is an asshole
12:54:26 <ttt_fff> ^ definitely not me, was some other guy
12:54:43 <ttt_fff> so anyway, this is probably -blah
12:54:47 <ttt_fff> I think we were talking about lens
12:54:52 <benzrf> yep
12:55:53 <ttt_fff> here something I was thinking about this morning
12:56:00 <ttt_fff> why don't we have a spreadsheet with haskell as the scripting language
12:56:15 <ttt_fff> like the entire sheet has a list of shared datatypes
12:56:16 <benzrf> we do, it's called ghci
12:56:19 <benzrf> :>
12:56:20 <ttt_fff> each cell is typed (based on the expr)
12:56:32 <ttt_fff> ghci is more like a graphing calculator than a spreadsheet
12:56:51 <benzrf> i bet this would be super easy to make in threepenny-gui
12:57:06 <ttt_fff> can you use ghci as a library?
12:57:11 <benzrf> iunno
12:57:15 <ttt_fff> becuase you need to read an arbitrary string, and evaluate it as haskell
12:57:23 <benzrf> o tru
12:57:23 <ttt_fff> also, can you declare new datatypes in ghci?
12:57:32 <benzrf> there are indeed libs for that
12:57:35 <ttt_fff> I think typing makes this spreadsheet non-trivial
12:57:35 <benzrf> @google using ghc as a library
12:57:36 <lambdabot> https://wiki.haskell.org/GHC/As_a_library
12:57:58 <ttt_fff> that's ghc
12:58:03 <ttt_fff> I don't wnat to wait for a ghc compile cycle
12:58:04 <ttt_fff> every time I update a cell
12:58:09 <ttt_fff> that's ridicilously slow
12:58:20 <luite> ghci is not part of the ghc library unfortunately
12:58:26 <ttt_fff> but I think this idea is badass -- I want typed spread sheets, with haskell as the host language
12:58:42 <ttt_fff> luite: go back to working on ghcjs, we don't want you doing anything besides making ghcjs rock
12:58:45 <ttt_fff> :-)
12:59:15 <ttt_fff> luite: actually, is there some ghcjsI / node thing which makes this possible to do using ghcjs/node/javascript?
12:59:21 <nkaretnikov> ttt_fff: I haven't used it, but this looks relevant: https://hackage.haskell.org/package/ghcid
12:59:23 <ttt_fff> I would not mind the node/js slowdown if I get typed stpreadsheets
12:59:35 <geekosaur> you can't use ghci /per se/ as a library, but the bytecode backend is certainly available
12:59:36 <luite> ttt_fff: yes, see the ghcjsi branch of the ghcjs repo
12:59:37 <andrevm> can anyone explain the difference between the difference between the least- and greatest- fixpoints of a functor?
12:59:50 <geekosaur> you might want to look at the source code for hint
12:59:55 <geekosaur> or mueval
13:00:25 <ttt_fff> nkaretnikov: I think hdevtools gives me all that ghcid offers
13:00:28 <luite> ttt_fff: it evaluates the code on node.js, or if you connect a browser in the browser. the front end is exactly ghci, you can interact with the browser document if you want
13:02:12 <benzrf> ttt_fff: 03:56 <benzrf> i bet this would be super easy to make in threepenny-gui
13:02:24 <ttt_fff> benzrf: famous last words
13:02:33 <ttt_fff> unless you have a demo to show us now
13:02:49 <P4Titan> :t forM
13:02:50 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
13:03:57 <luite> i bet i can do it in a week based on ghcjsi :p
13:04:54 <ttt_fff> luite: please post a kickstarter
13:05:00 <ttt_fff> I will try to get people to donate
13:09:02 * hackagebot delta 0.2.0.0 - A library for detecting file changes  http://hackage.haskell.org/package/delta-0.2.0.0 (muzzle)
13:09:18 <luite> ttt_fff: for what?
13:09:29 <ttt_fff> luite: for you implementing spreadsheets in ghcjsi
13:11:27 <luite> oh nah too much work, unless there really is massive demand, i have enough on my plate doing ghcjs/ghcjsi itself
13:12:57 <ttt_fff> so If I get a bunch of ppl in #hskell to pm you, will that count as massive demand?
13:14:56 <luite> depends on how convincing their messages are
13:15:40 <bernalex> luite: I don't know what I'm talking about or how web works -- would it be possible (technically, not politically and so on) to write a haskell vm for firefox?
13:17:35 <clynamen> (intersperse "^") . words "a asefd sdf asdf "
13:17:40 <luite> bernalex: what's your definition of a vm?
13:17:58 <clynamen> gives error: could not match a -> [[Char]] with [String]
13:18:04 <P4Titan> If someone does not mind, how can I make this permutation code simpler/better: http://lpaste.net/6734975102036738048
13:18:08 <bernalex> luite: the ability to execute haskell natively in firefox, like the dart devs wrote for chromium (dartium).
13:18:19 <ttt_fff> > (intersperse "^") . words "a asefd sdf asdf "
13:18:20 <lambdabot>      Couldn't match expected type ‘a -> [[Char]]’
13:18:20 <lambdabot>                  with actual type ‘[String]’
13:18:20 <lambdabot>      Possible cause: ‘words’ is applied to too many arguments
13:18:26 <P4Titan> @src [] (>>=)
13:18:26 <lambdabot> xs >>= f = concatMap f xs
13:18:40 <clynamen> shouldn't [[Char] and [String] be the same?
13:18:48 <ttt_fff> clynamen: seems the problem is "a -> [[Char]]" not matching with '[String]" ... whihc is different from what you said
13:18:56 <ttt_fff> > (intersperse "^") . words "a asefd sdf asdf "
13:18:57 <lambdabot>      Couldn't match expected type ‘a -> [[Char]]’
13:18:57 <lambdabot>                  with actual type ‘[String]’
13:18:57 <lambdabot>      Possible cause: ‘words’ is applied to too many arguments
13:19:12 <ttt_fff> it's "[String]" vs "a -> [[Char]]"   NOT "[String]" vs "[[Char]]"
13:19:17 <luite> bernalex: haskell as source or as intermediate code?
13:19:18 <ttt_fff> clynamen: ^^
13:19:25 <clynamen> got it, thanks
13:19:31 <bernalex> luite: I was thinking former
13:20:59 <luite> bernalex: i mean sure it's technically possible to bundle ghc and related tools with a browser and run everything in some pnacl sandbox
13:21:59 <bernalex> luite: do you think it would be (technically) interesting? when compared to the need for transpiling to js
13:23:52 <luite> bernalex: uh the use case is rather different. what would you use it for?
13:27:03 <benzrf> does `hint' support introducing variables into a scope
13:27:19 <bernalex> luite: well I just want to run haskell natively. it was very neat to be able to run dart natively. it would require a rather interesting dsl or library or whatever to e.g. interop with the dom though.
13:29:56 <lifter> a
13:30:05 <luite> bernalex: but what's the actual use case? build web apps? development tool? ghci with gui?
13:30:07 <benzrf> hmm
13:30:25 <bernalex> luite: I was thinking for web apps really
13:30:27 <benzrf> actually...
13:30:39 <bernalex> but now that you mention it, ghci with gui would be cool.
13:30:41 <benzrf> this is quite interesting
13:31:16 <geekosaur> iHaskell is already there, for ghci gui?
13:31:25 <geekosaur> (although may not be updated for 7.10)
13:31:54 <luite> bernalex: then it has rather limited appeal. require a custom browser? might as well compile against an embedded blink or webkit engine and distribute as a native app, perhaps use ghcjs-dom for dom manipulation
13:32:41 <bernalex> luite: that is political. I'm just interested from a technological perspective.
13:33:36 <bernalex> luite: & I realise that native dart was abandoned because of politics (e.g. mozilla refused to bundle the vm). but I'm not very interested in that aspect of it.
13:35:18 <rcyr> I guess we just have to wait for webassembly to be released https://en.wikipedia.org/wiki/WebAssembly
13:35:40 <luite> bernalex: technologically everything is possible
13:36:10 <bernalex> luite: that's hyperbolic if anything. report back when we have teleportation available. ;)
13:36:46 <luite> bernalex: but you can't really get around the politics if it's a massive amount of work, who's going to dedicate their time to something that's of very limited use?
13:36:48 <bernalex> I think it would be interesting to use native haskell for a browser at least.
13:36:58 <bernalex> luite: academia does that all the time. ;)
13:39:56 <luite> bernalex: well there's the hurdle of convincing someone to fund the research there, admittedly that's not always directly correlated to the use, but it's a hurdle nonetheless
13:40:06 <bernalex> luite: I agree
13:40:31 <bernalex> luite: but if it's possible as a bachelor or master thesis, anyone can do it.
13:40:37 <Pamelloes> I wonder if you could make a pure web engine with some form of frp....
13:40:44 <Pamelloes> Does that exist already?
13:41:48 <bernalex> I would be very surprised if that existed
13:42:26 <jgcoded> What are the kinds of things that people put in the >>= function to make their monads more useful?
13:43:54 <Pamelloes> bernalex: Well a full fledged web engine probably doesn't exist. But it would be pretty cool if there was at least a minimal haskell web engine.
13:44:05 <murphxyz> Hey, friends, is this really the best place for newbies to ask questions, or is there a different channel where that would be more appropriate?
13:44:08 <Pamelloes> Though web engines are ridiculous.
13:44:48 <Pamelloes> murphxyz: Right here is a great place for questions :) There might be a haskell noob channel or something (someone else will have to link to it) but we'll be happy to help you here, too.
13:45:13 * Pamelloes hopes no-one minds his use of "we"
13:45:23 <luite> bernalex: doing it properly would take lots of time. you could bet on finding a poor (but good) student willing to spend a few years unpaid working on this as a bachelor's thesis project...
13:46:30 <andrevm> what does it mean to be the least or greatest fixed point of a Functor? what is the difference between them?
13:47:24 <murphxyz> okay, thanks! I'm slowly trying to dig into Haskell during nights and weekends, wanting to write a basic web-server, coming from Node. Each time I've tried in the past, I've been frustrated at the outset by trying to get Cabal to install deps. I was referred to https://www.stackage.org/, but I feel like most of what is written there is targeted toward people who already know what they're doing. Is stackage just an alternate package
13:47:24 <murphxyz>  repository? Will the stack executable read Cabal files? Is it a drop-in replacement for Cabal?
13:48:07 <murphxyz> it looks like stack can be installed with cabal, and then used instead of cabal. but I'm not sure that's right
13:49:32 <geekosaur> stack is not dependent on stackage
13:50:23 <murphxyz> okay
13:50:35 <murphxyz> why use Stack over Cabal? Maybe there's a blog post on this I can find
13:51:28 <benzrf> augh :(
13:51:29 <murphxyz> this looks pretty good: https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
13:51:35 <murphxyz> should have googled first
13:52:10 <benzrf> tfw no dependent types
13:52:39 <benzrf> andrevm: googling didnt work?
13:53:12 <andrevm> benzrf: i havent been able to find anything that makes sense for me
13:53:34 <andrevm> i got to a page that talked about lattices, but idk if that the wrong path
13:53:46 <andrevm> and link to a good resource on it would be fine as well
13:54:20 <benzrf> i dont know myself sorry
13:54:31 <benzrf> when i hear about least and greatest fix points i tend to think of domains
13:54:38 <benzrf> but at the type level... idk
13:56:30 <andrevm> idk anything about domains either
13:57:47 <ralu> how can i use c2hs whout writing  chs file
13:58:20 <c_wraith> ralu: that sounds a lot like asking how you can use haskell without writing a haskell file
13:58:38 <ralu> in package description it sais that is not requred, but i cant figure out how to use this tool 
13:58:52 <benzrf> andrevm: they are some sort of mathematical structure
13:59:04 * hackagebot tttool 1.4.0.3 - Working with files for the Tiptoi pen  http://hackage.haskell.org/package/tttool-1.4.0.3 (JoachimBreitner)
13:59:33 <benzrf> andrevm: the idea AIUI is that you make a set of terms in your language, then order them, in some sense, by which ones subsume the others in terms of how close to normal they are
13:59:49 <benzrf> so then bottom is the least element, for example
14:00:06 <benzrf> and then the fix function computes the least fix point of another function
14:00:11 <benzrf> that is, the least-defined
14:00:27 <benzrf> -- or something
14:28:42 <erisco> what is a predicate that cannot be computed with a fold (excluding prime numbers :))
14:28:55 <benzrf> erisco: ??
14:33:30 <Cale> erisco: You can compute arbitrary fixed points using folds over an infinite list, so I guess the only examples will be non-computable predicates?
14:33:43 <arkeet> erisco: what makes you think you can't do prime numbers :-)
14:34:05 * hackagebot z3 4.1.0 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-4.1.0 (IagoAbal)
14:34:47 <Pamelloes> Oh god. I have to compile 3 versions of GHC.
14:40:42 <ttt_fff> I need an array of Text, should I use https://hackage.haskell.org/package/vector or should I use something else?
14:43:57 <Welkin> vector is nice
14:53:11 <catgocat> What is the difference between deriving, and creating an instance of a typeclass?
14:53:18 <erisco> benzrf, Cale, arkeet I dunno man I was hoping it'd make sense to someone else
14:53:46 <erisco> catgocat, deriving asks GHC to do the work
14:53:47 <benzrf> hey ttt_fff
14:53:56 <ttt_fff> benzrf: hey benzrf
14:54:00 <benzrf> i spent a while thinking about the spreadsheet thing
14:54:11 <ttt_fff> and you implemented a prototyle
14:54:12 <benzrf> and ive come to the conclusion that without dependent types, it would be a nightmare
14:54:13 <ttt_fff> and want me to test it out
14:54:13 <catgocat> erisco: Oh ok but for, let's say, Show, I could do instance Show Maybe where ... for example
14:54:15 <benzrf> however
14:54:17 <ttt_fff> oh
14:54:25 <ttt_fff> I like negative results too, explain your proof
14:54:34 <benzrf> ttt_fff: i think it'd be feasible if monotyped though
14:54:42 <ttt_fff> I know what depenent types are.
14:54:45 <erisco> catgocat, no because Maybe has kind * -> * but you could do instance (Show a) => Maybe a 
14:54:45 <ttt_fff> I don't know what monotypes are.
14:54:54 <benzrf> ttt_fff: er, i just meant 'all cells are the same type'
14:54:56 <ttt_fff> I learned Coq before I learned Haskell.
14:55:00 <benzrf> ttt_fff: as opposed to allowing arbitrary expressions
14:55:02 <ttt_fff> no, we do not want that.
14:55:06 <erisco> er  instance (Show a) => Show (Maybe a)
14:55:08 <benzrf> :(
14:55:09 <erisco> whatever the notation is
14:55:12 <ttt_fff> I want to have one fell taht is a Sring, another cell that is [Int]
14:55:20 <mniip> erisco, tthat's right
14:55:25 <ttt_fff> benzrf: what is your 'proof' behind 'we need dependent types' ?
14:55:34 <catgocat> erisco: so instance Show Bool
14:55:34 <benzrf> i dont have a /proof/
14:55:45 <benzrf> i just spent a while thinking about it and ran up against a few type walls
14:55:49 <ttt_fff> benzrf: what is your 'intuition' behind 'we need depenent types' for haskell-in-a-spreadsheet
14:55:56 <geekosaur> catgocat, for the standard typeclasses such as Show, it's preferable to let ghc derive it because Show (and Read) are supposed to behave in specific ways and ghc will ensure that they do. also, it's often a bunch of boilerplate and why write it yourself when ghc can do it?
14:56:02 <benzrf> ttt_fff: oh, well. we definitely do not
14:56:08 <ttt_fff> benzrf: what are instances of spreadshets you would like to create that runs into the "damn it, I need dependent types" issue
14:56:26 <erisco> catgocat, sure though there already is one
14:56:26 <benzrf> ttt_fff: i just meant for a nice hint-based implementation using FRP
14:56:31 <ttt_fff> I feel like the Emacs Psychologist
14:56:39 <catgocat> @erisco yes, I was just asking for learning purposes
14:56:40 <lambdabot> Unknown command, try @list
14:56:46 <zipper> We need to update the typeclassopedia.
14:56:54 <zipper> Who can I talk to about this?
14:56:56 <erisco> do you have your learner's permit?
14:56:59 <catgocat> what are the types you can derive from ?
14:57:06 <catgocat> s/types/typeclasses
14:57:18 <catgocat> Eq, Ord, Show, Read..
14:57:20 <benzrf> ttt_fff: you could certainly make a haskell spreadsheet in a non-dependently-typed language, you just couldnt do it in a way that can work with the values in it at the same level as native values
14:57:50 <benzrf> ttt_fff: you'd have to do a lot more legwork
14:58:03 <ttt_fff> I have no doubt it'll be lots of work
14:58:09 <ttt_fff> which is why I'd love to have someone else do it
14:58:13 <benzrf> :^)
14:58:44 <mniip> catgocat, Bounded and Enum
14:58:55 <catgocat> that's it?
14:58:58 <mniip> with some extensions you can derive Generic, Typeable and Functor
14:59:13 <catgocat> how can I make a derivable typeclass?
14:59:19 <mniip> and with another extension you can derive anything on newtype, such that the wrapped type supports it
14:59:22 <catgocat> and how does it work
14:59:36 <geekosaur> you can't make one yourself, unless you enable generics
14:59:43 <catgocat> what are generics
14:59:59 <geekosaur> Eq, Ord, Enum, Bounded, Show, and Read are the only classes for which automatic deriving normally exists
15:00:07 <mniip> generics allow you to instantiate your typeclass on abstract data types
15:00:20 <mniip> and then GHC will represent complex data types in terms of combinations of abstract ones
15:00:25 <mniip> and compile an instance accordingly
15:00:28 <catgocat> and how can I make generics
15:01:25 <mniip> well that is beyond me
15:01:50 <benzrf> ttt_fff: well, i'll get back to you
15:01:56 <benzrf> maybe i will think of something :>
15:02:22 <ttt_fff> benzrf: return with an implementation of haskell-in-a-spreadsheet or return on your shield! :-) // spartan haskellers
15:02:30 <benzrf> eh
15:02:33 <benzrf> bye
15:02:47 <ttt_fff> benzrf: I'm actually thinking that the easiest way is to just wrap around ghci
15:02:56 <ttt_fff> benzrf: and have 'each cell = a named var in ghci'
15:03:09 <ttt_fff> and whenenver something needs to be updated, just send stuff to ghci and get stuff bak
15:03:17 <ttt_fff> and let ghci handle all the parsing / evaluating ahskell / etc ....
15:03:36 <ttt_fff> i.e. something like " threepenny-gui <-> haskell prog <-> SOME PIPE <-> ghci instance"
15:03:40 <ttt_fff> benzrf: ^
15:05:53 <ttt_fff> when I have a expr with free + bound vars, and I convert it to an expr with only bound vars -- what is this process called?
15:06:04 <ttt_fff> I am using the verb 'wrap', but I think there is a proper compiler term for exactly what this should be called
15:06:07 <ttt_fff> mniip: ^
15:07:14 <mniip> binding?
15:07:31 <cow_2001> ghc-mod won't work well with stack :(
15:10:29 <ttt_fff> hmm
15:10:35 <ttt_fff> well, it takes expr with free + bound, and outputs expr with only bound
15:10:41 <ttt_fff> so I was going to name it "killFreedom"
15:10:46 <ttt_fff> but that seeed like a bad function name
15:24:52 <ttt_fff> \(x, y, z) -> ... in debrujin, do we have "choice a: 0=x, 1=y, 2=z" or "choice b: 2=x, 1=y, 0=z" ?
15:43:49 <neuroserpens> I was going to ask a question but found the answer while writing the question.
15:43:51 <neuroserpens> LoL.
15:43:53 <neuroserpens> This made me laugh hard.
15:45:00 <neuroserpens> I think I should become one of those devs who ask questions first to their stuffed animals or action figures.
15:45:46 <danilo2> Hello! :) Are there any standard functions in haskell that allow me to convert Word64 -> [Word8]? I've been looking into Data.Bits etc but didn't found any function for this purpose. I know I can implement it by hand, but I don't want to duplicate libraries functionalities :)
15:48:55 <rowanblush> danilo2: Not that I know of. It would probably have type `Word64 -> (Word8, Word8, Word8, Word8, Word8, Word8, Word8, Word8)` though.
15:53:50 <ttt_fff> do .... \n lst <- b \n foo lst \n   ... is there a way to combine the last two lines ?
15:55:20 <Rembane> ttt_fff: fmap foo b
15:55:39 <ttt_fff> Rembane: thanks
15:55:56 <Rembane> ttt_fff: np
15:56:03 <ttt_fff> Rembane++
15:56:09 <ttt_fff> @karma Rembane
15:56:09 <lambdabot> Rembane has a karma of 1
15:56:12 <zipper> Why do we need monad transformers?
15:56:15 <ttt_fff> hmm, you should help more people :-)
15:56:28 <Welkin> zipper: to use more than one monad at once
15:56:38 <ttt_fff> yeah, like RWST
15:56:41 <ttt_fff> reader + writer + state
15:56:42 <ttt_fff> my favorite monad
15:58:00 <Rembane> ttt_fff: I'm generally too slow. :)
15:59:44 <zipper> Do I need to use several monads at once?
15:59:59 <byorgey> zipper: updating the typeclassopedia (e.g. for the AMP) is on my todo list.  Any help gratefully accepted.  I will see any edits you make so be bold and don't worry that you might make a mistake.
16:00:31 <byorgey> zipper: if you want to combine the effects of several monads, e.g. you want to have some state and also do IO
16:01:02 <zipper> byorgey: Oh you wrote the typeclassopedia. I hope it's on github. I haven't actually checked.
16:01:10 <Welkin> no
16:01:16 <Welkin> @where typeclassopedia
16:01:16 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:01:36 <zipper> Welkin: I mean to edit.
16:01:47 <zipper> Then realised it's a wiki so I need an account.
16:01:55 <zipper> Anyway I think I got it
16:04:18 <zipper> wiki.haskell.org has a log in page but no sign up page. What am I missing?
16:04:41 <zipper> Oh "If you would like an account please email "wiki-account-request" (at the domain haskell dot org) or, if you find that unresponsive, on the haskell-cafe mailing list."
16:04:45 <bernalex> zipper: you need to send an email to register. it's a PITA, but that's how they combat spam.
16:05:00 <zipper> bernalex: PITA?
16:05:10 <bernalex> zipper: pain in the arse.
16:05:21 <danilo2> rowan blush: Of course :) Hmm I've write it by myself then :)
16:05:34 * zipper procrastinates.
16:05:35 <danilo2> *I've got to 
16:05:37 <danilo2> :)
16:05:50 <zipper> I'll sign up later when time is found.
16:18:07 <jle`> the staff is pretty prompt though, registration is relatively painless. just not immediate :)
16:29:22 <catgocat> Can anyone explain me a thing about newtypes and undefined?
16:29:43 <Welkin> newtype is just a wrapper around another data type
16:29:57 <Welkin> it must have only one parameter and one constructor
16:29:57 <geekosaur> you're going to have to actually ask the question, I think
16:30:30 <catgocat> I am reading LYAH, and I don't understand the section about pattern matching undefined.
16:30:42 <catgocat> See here: Search for "helloMe undefined" http://learnyouahaskell.com/functors-applicative-functors-and-monoids
16:31:03 <catgocat> I read the paragraph over and over again and can't get it
16:31:17 <catgocat> It doesn't make any sense for me? How doesn't undefined get evaluated?
16:31:21 <Welkin> because undefined is an undefined value
16:31:37 <Welkin> it is a placeholder
16:31:44 <Welkin> if you try to evaluate it, you get an exception
16:31:49 <catgocat> Yes, that's right.
16:31:52 <quchen> It's used as a placeholder, but it's really just a program crash.
16:32:00 <catgocat> But an exception doesn't happen when using newtype, see the code in LYAH.
16:32:17 <mauke> catgocat: newtypes don't exist at runtime
16:32:32 <catgocat> Saying those one-line sentences don't add nothing to me.
16:32:42 <catgocat> It's like throwing random facts without forming a puzzle.
16:32:45 <mauke> that's why "unwrapping the constructor" is a no-op at runtime
16:32:57 <mauke> the function is effectively helloMe _ = "hello"
16:33:03 <catgocat> Why ?
16:33:12 <mauke> because newtypes don't exist at runtime
16:33:20 <catgocat> What does that even mean?
16:33:25 <geekosaur> ...
16:33:36 <geekosaur> a newtype is a thing that only exists in ghc's typechecker's mind
16:33:38 <Welkin> think of it as a search-and-replace
16:33:44 <mauke> it means 'newtype' creates a new type as far as the type checker is concerned
16:33:54 <geekosaur> there is no code generated for it, it does nothing except hide some detailsof the underlying type
16:33:56 <mauke> but it doesn't affect the underlying representation
16:34:01 <ronh> isn't that true for every type due to type erasure?
16:34:07 <mauke> ronh: no
16:34:14 <geekosaur> so matching a newtype's constructor doesn't actually do anything except "unhide" the underlying type to the typechecker
16:34:21 <geekosaur> it does not *access* the hidden type, just exposes it
16:34:23 <ronh> mauke what is the difference?
16:34:31 <mauke> see this discussion
16:34:41 <mauke> also the example in LYAH
16:35:13 <mauke> ronh: data Foo a = Foo a; now 'Foo undefined' is not undefined itself
16:35:31 <mauke> maybe I should use different names
16:35:45 <quchen> ronh: Type erasure deletes the type information itself, e.g. you don't have any mentions of "Maybe Int" in your final program. But you'll still have some remnants of using Maybe: Nothing might be represented as a "0" in some register.
16:35:48 <mauke> data Foo a = MkFoo a; now 'MkFoo undefined' is defined
16:36:10 <mauke> that's because MkFoo is actually stored at runtime
16:36:16 <catgocat> Ok, I get the idea that it hides the underlying type. But I don't understand what the hell is going on when I do (CoolBool _), CoolBool True and False will match for booleans, doesn't _ match every boolean? But undefined isn't a boolean
16:36:32 <mauke> catgocat: why is undefined not a boolean?
16:36:39 <mauke> undefined is in every type
16:37:01 <quchen> :t let x :: Bool; x = x in x
16:37:02 <lambdabot> Bool
16:37:04 <geekosaur> undefined is not a value in the usual sense
16:37:12 <geekosaur> undefined is the possibility of not producing a value
16:37:47 <catgocat> So a newtype, pattern matches for everything that is a type of the underlying type of that newtype?
16:37:53 <geekosaur> > and $ repeat False
16:37:54 <lambdabot>  False
16:38:01 <geekosaur> whoops, wromng one
16:38:05 <mauke> catgocat: eh?
16:38:05 <geekosaur> > and $ repeat True
16:38:09 <lambdabot>  mueval-core: Time limit exceeded
16:38:12 <geekosaur> ^ undefined
16:38:45 <catgocat> If I pattern match against CoolBool True, does True also pass the test?
16:38:55 <mauke> catgocat: depends on the value
16:39:13 <catgocat> And if so, do other newtypes that have True under the shadow also match?
16:39:26 <catgocat> mauke: which value ??
16:39:40 <mauke> the value that you're matching on
16:39:47 <catgocat> :(
16:39:55 <mauke> what
16:39:57 <catgocat> I am matching for CoolBool True
16:40:06 <mauke> what do you mean by "for"?
16:40:06 <catgocat> CoolBool is a new type
16:40:16 <catgocat> that hides a Bool
16:40:26 <mauke> show code, not english
16:40:28 <catgocat> myFunction (CoolBool True) = ...
16:40:31 <jmcarthur> pattern matching on a newtype has no operational meaning. it's just a syntax for accessing the thing you wrapped in the newtype
16:41:35 <catgocat> jmcarthur: so why can't I do head $ ZipList [1,2,3]
16:41:49 <jmcarthur> catgocat: where's the pattern matching there?
16:42:02 <quchen> catgocat: Consider "data Foo a = Foo a". When you try matching in "let Foo x = undefined", we have to evaluate the "undefined" to check whether the "Foo" constructor matches. You might say "of course it matches, Foo has only one constructor", and you're right - but we'd like pattern matching on "data" types to behave independently of how that type might have been created. For example, we don't want the semantics of pattern matching elsewher
16:42:02 <quchen> e to change when a user decides to add a "Bar" constructor to the "Foo" type. Action at a distance is spooky and bad. Sooo - we have to evaluate "undefined" to check whether it really matches a "Foo x", and evaluating "undefined" crashes.
16:42:08 <quchen> catgocat: Now consider "newtype Foo a = Foo a", trying to match "let Foo x = undefined" again. Newtype matching is special, since the compiler can remove all mentions of Foo after typechecking (but before evaluating) the code. So your pattern looks like "x = undefined", and to check whether that matches we do not have to look at the "undefined". (You will still get an error here if you try to evaluate the "x" of course.)
16:42:08 <catgocat> there probably is within `head`
16:42:20 <jmcarthur> catgocat: but head matches on a list, not on a ZipList
16:42:55 <jmcarthur> catgocat: pattern matching on ZipList is how you access the list, and head doesn't know how to do that because it expects a list, not a ZipList
16:44:07 <jmcarthur> catgocat: the feature that newtypes give you is the ability to make a value for one type appear to the compiler to have a totally different type. the type mismatch with head is a consequence of that.
16:44:15 <catgocat> quchen: I understood the last paragraph, can you explain the data thing again?
16:46:45 <quchen> catgocat: "newtype" is like a special kind of "data" when you have only one constructor on the right hand side, and that constructor has only one field. In this case, you can implement it in a way that makes the wrapper go away, but still give you type safety during compilation.
16:47:11 <catgocat> and why is this useful
16:47:41 <quchen> Since "newtype" guarantees you to have only one constructor with only one field, you can guarantee that the compiler can simply ignore that constructor. "newtype Foo = Foo Int" is *exactly* the same as "Int" in the compiled program.
16:47:45 <jmcarthur> catgocat: if you know C... the difference between a list and ZipList in haskell is kind of like the difference between int and struct { int x; }. most c compilers won't represent the struct any differently than just an int. also, if i have a value of that type, foo, then foo.x isn't any different than just x.
16:47:46 <catgocat> if when pattern matching against a newtype, the underlying type also matches, how can I make functions that take ONLY the newtype?
16:48:09 <jmcarthur> catgocat: the underlying type doesn't match. head doesn't work on ZipLists
16:49:14 <quchen> "head" for ZipList would be defined via "headZ (ZipList xs) = head xs". Note how you have to pattern match on the ZipList before you can have a go at the xs.
16:49:26 <quchen> headZ (ZipList (x:_)) = x -- another way
16:49:46 <geekosaur> why newtypes are useful:
16:49:51 <geekosaur> [18 22:09] <geekosaur> sometimes you want to have two different instances for a single type, which Haskell doesn't permit; so we put them on newtypes instead so they won't conflict
16:49:51 <geekosaur> [18 22:09] <geekosaur> (example: there are two fundamental monoids on integer types, so we put one on a newtype Sum and the other on a newtype Product)
16:49:51 <geekosaur> [18 22:10] <geekosaur> the other reason to do it is so the person using your monadic type doesn't need to care which order you stacked it in
16:50:00 <geekosaur> (someone asked about that in #xmonad about an hour ago...)
16:50:22 <quchen> catgocat: You have to clearly separate type-level representation of something and machine-level representation. On the type level, a newtype looks pretty much like a data type. On the compiled-program-level it looks like … well, it's entirely gone.
16:51:07 <quchen> catgocat: Maybe this part of the FBUT also helps a bit (very short read): https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
16:51:36 <jmcarthur> catgocat: newtypes are useful for a few things. one is to make a new type to write an instance of a type class for. another is to help prevent from accidentally using a value in a context that it makes no sense in or to help you organize your thoughts and write clearer code (basically using them as type-checked labels). another is to use with the module system to completely hide the representation of
16:51:39 <jmcarthur> something without any operational overhead.
16:52:42 <catgocat> ok it's becoming more clear
16:55:24 <mniip> so looking at Omega
16:55:43 <mniip> how does it manage to conform to the associativity monad law
16:55:48 <quchen> Omega?
16:56:01 <mniip> the Omega monad
16:56:06 <quchen> I only know Ω = λx. x x  which does not typecheck in STLC
16:56:30 <mniip> https://hackage.haskell.org/package/control-monad-omega-0.2/docs/Control-Monad-Omega.html
16:57:39 <bufferloss> haskell is fun!
16:57:41 <jmcarthur> mniip: "Warning: Omega is only a monad when the results of runOmega are interpreted as a set; that is, a valid transformation according to the monad laws may change the order of the results."
16:57:46 <jmcarthur> mniip: it's in the documentation
16:58:06 <jmcarthur> mniip: so, in short, it doesn't satisfy the monad laws
16:58:19 <mniip> mhm
16:58:42 <jmcarthur> at least not if satisfying them means up to structural equality
16:59:11 <quchen> It's observable via the API so it's violated.
16:59:15 <jmcarthur> yup
16:59:54 <jmcarthur> mniip: also worth point out, from the same paragraph: " If you are using this as a monad, I recommendIded that you use the newer weighted-search package instead (it's also faster)."
17:00:21 <jmcarthur> *pointing
17:03:16 <Pamelloes> accursedUnutterableIO is best IO.
17:03:31 <jmcarthur> my favorite IO
17:04:30 <Pamelloes> I think I should make a function to launch the proverbial missiles. And slip it into accursedUnuterrableIO. It would be amusing.
17:18:26 <Pamelloes> If GHC is self-compiling, how do you bring it to a new platform that doesn't already have a GHC to compile itself?
17:19:31 <geekosaur> currently? compile to llvm bytecode and translate that on the target
17:20:11 <Pamelloes> Huh. Cool.
17:20:17 <geekosaur> used to be that you could make ghc dump out portable but horribly slow ANSI C code that could be compiled on the target, and then that compiler used to write and compile a native one
17:20:48 <bufferloss> so, sorry if this is covered somewhere in the docs but, what do I do to actually write code to a file? what file extension do I use? how do I compile/run it?
17:20:51 <bufferloss> I've got ghc installed
17:21:03 <bufferloss> I just did the interactive tutorial on the homepage http://www.haskell.org
17:21:20 <bufferloss> now I just wanna make a file like e.g. hello_world.haskell and run it
17:21:28 <geekosaur> .hs extension generally. we recommend an editor that can be told not to write out tabs, since tabs tend to be inconsistent across editors
17:21:38 <bufferloss> k
17:21:54 <geekosaur> there are haskell support packages for emacs, vim, sublime text, and other editors
17:22:08 <bufferloss> ok, so how do I compile/run my .hs file?
17:22:09 <geekosaur> but people get by just fine with notepad++ on Windows or gedit on Linux
17:22:14 <geekosaur> ghc foo.hs
17:22:15 <bufferloss> ghc hello.hs; # ?
17:22:20 <bufferloss> ok, simple enough thanks
17:22:20 <jle`> runghc hello.hs works too
17:22:29 <jle`> it'll compile to a temporary file location and run that
17:22:33 <bufferloss> jle`, ah nice ok
17:22:35 <geekosaur> but doesn't actually compile it (this may be fine for testing but it's kinda slow)
17:22:52 <geekosaur> jle`, runghc is runhaskell is the bytecode interpreter
17:23:01 <jle`> i thought it used to be but they changed it?
17:23:03 <ompaul> barfly’s: if windows you need an extension to the file name, if some unix like system you don't but it is a good idea to do so, if only six months down the line you want to know what it is 
17:23:11 <jle`> maybe i heard wrong
17:23:42 <jle`> i heard at one point that runghc gave up interpreting things and just compiled them in low optimization.  but maybe i misinterpreted the statement
17:23:44 <jle`> hm
17:24:20 * geekosaur does not have ghc 7.10 yet (waiting on 7.10.2) so can't readily check
17:25:25 <Pamelloes> GHC takes forever to compile D:
17:25:33 <geekosaur> but compiling to a temporary location is annoying when it comes to cleaning up afterward (not an insoluble problem, just an annoying one to get right with all the edge cases)
17:25:35 <mlrutherford> Hey guys! I'm currently new to Haskell, and i have a quick question. In what ways would Haskell be able to replace production Lisp code? (also is there any way to achieve prefix notation to minimize conversion pains?)
17:25:38 <bufferloss> hmm, I get a message about naked expressions, how do I avoid that? is there an equivalent to echo/print/puts for haskell?
17:25:52 <geekosaur> also annoying is knowing there was a compiled copy of the thing that just crashed on you somewhere, but you can't access it any more
17:25:57 <bufferloss> how can I have the return output of an expression be used as the bash exit code for example?
17:26:11 <geekosaur> bufferloss, haskell is like C, not like python or ruby
17:26:31 <geekosaur> your program must have a function called main, which is the entry point for your program
17:26:34 <bufferloss> ok so is there an
17:26:39 <bufferloss> ahh yes, that's what I was going to ask, ok
17:26:42 <geekosaur> if you just want a place to play around, run ghci
17:26:51 <bufferloss> well I want to start doing more than playing
17:26:56 <bufferloss> I've done some playing in the interpreter
17:27:01 <geekosaur> that will evaluate bare expressions and such (but there's no way to save what you're doing)
17:27:03 <bufferloss> I wanna start composing real programs
17:28:08 <bufferloss> geekosaur, any idea where in the docs I can find reference for the signature/params of the main function?
17:28:22 <Pamelloes> bufferloss: main :: IO ()
17:28:27 <bufferloss> ideally something tutorial-like, I don't see where Learn You A Haskell covers moving from ghci to using source files
17:28:38 <geekosaur> @where learnhaskell
17:28:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:28:39 <bufferloss> Pamelloes, ok thanks
17:28:48 <Pamelloes> bufferloss: It's in one of the last chapters, btw.
17:29:12 <geekosaur> that link is a collection of learning/tutorial resources including an online introductory Haskell course
17:29:33 <Gurkenglas_> http://fho.f12n.de/posts/2014-05-07-dont-fear-the-cat.html <- At "Aside: We could use a Coalgebra to deconstruct trees:", shouldn't it say Algebra?
17:30:29 <bufferloss> Pamelloes, one of the later chapters of which book?
17:30:29 <geekosaur> I will say that Haskell does a bunch of things differently than you are used to... in particular, main does not take parameters, you use System.Environment.getArgs in IO to get at parameters (being external to the program, they must be in IO)
17:30:47 <geekosaur> I think that was an answer to [19 00:28] <bufferloss> ideally something tutorial-like, I don't see where Learn You A Haskell covers moving from ghci to using source files
17:30:57 <geekosaur> it does cover it, but rather late
17:31:42 <Pamelloes> Yep, that's what I meant
17:31:46 <bufferloss> geekosaur, ok, sorry to be verbose but, you're saying that https://github.com/bitemyapp/learnhaskell covers using files and main but rather late?
17:31:57 <Pamelloes> No. Learn You a Haskell.
17:32:01 <bufferloss> ahh ok
17:32:03 <Pamelloes> :)
17:32:09 <geekosaur> no, you said that LYAH didn't cover it and Pamelloes told you it does cover it but rather late
17:32:16 <geekosaur> the URL is for other learning resources
17:32:20 <bufferloss> I didn't say it didn't cover it
17:32:24 <bufferloss> I said I didn't see it
17:32:27 <geekosaur> cis194 should cover it in the first lecture :)
17:32:32 <bufferloss> ah ok grat
17:32:38 <bufferloss> I'll start with cis194 then, thanks
17:33:58 <Pamelloes> What does <<ghc: .... :ghc>> mean? It's being output while compiling GHC.
17:39:42 <AXENT> Maybe a fun break from all the programing? https://www.youtube.com/watch?v=fq2j7-rZ9Hc , Hot babe included!
17:41:42 <bufferloss> so http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html says to "evaluate each of the following expressions" in GHCi and one of them is: ex01 = 3 + 2 but I get the following error: <interactive>:3:6: parse error on input =
17:42:37 <geekosaur> you're not supposed to type the "ex01 =" part
17:42:49 <bufferloss> hmm, ok that's not entirely clear but ok, yeah then it works fine
17:42:59 <geekosaur> oh, no, I see
17:43:09 <geekosaur> they want you to stick that in a file and :load it
17:43:16 <geekosaur> and then you can type ex01 at the prompt
17:43:23 <bufferloss> ah, interesting, ok
17:43:36 <bufferloss> also, nowhere did they say this :)
17:43:38 <lispy> > let ex01 = 3 + 2 in ex01 -- this should work in ghci
17:43:39 <geekosaur> (the problem with looking just at that part of the page...)
17:43:40 <lambdabot>  5
17:44:11 <bufferloss> geekosaur, er, which other part of the page was I supposed to look at?
17:44:31 <geekosaur> not you, me
17:44:46 <bufferloss> ah nm ok
17:44:51 <geekosaur> my first response was just on looking at that part, I had to scroll up tosee they wanted you to put it in a file
17:45:03 <geekosaur> where they were talking about :load
17:45:35 <bufferloss> sure well they never actually say I'm supposed to put it in a file, they just assumed that I could read their mind :)
17:45:52 <bufferloss> I suppose if :load was supposed to be a hint, then ok but it should really say I'm supposed to put it in a file explicitly
17:45:55 * geekosaur hasn't actually done that course... since it didn't exist in 2006 :)
17:46:18 <bufferloss> anyway, oh well, so it goes with us technical folk, we all too often forget that we know or take things we know for granted
17:46:24 <geekosaur> or at least not in a form we could see outside of the university
17:46:26 <bufferloss> ok yeah now it works
17:46:36 <Gurkenglas> "Cont r a can be represented as ([a], [r] -> r)." Thoughts?
17:46:40 <bufferloss> I used :load and ex01 provides the expected result
17:47:30 <lispy> bufferloss: I like to take it a step futher and assume that if I understand something so does everyone else and therefore it must not be interesting anymore :)
17:48:43 <bufferloss> geekosaur, so what does your personal/typical work/development flow look like with haskell?
17:48:57 <bufferloss> do folks use build systems like make? is there an equivalent for haskell?
17:49:07 <bufferloss> do you just load your file through ghci and then :load and run a function?
17:49:21 <bufferloss> I mean, I think for now loading through ghci will hopefully get *close* to what I want
17:49:43 <geekosaur> ghc has rudimentary dependency handling built in, so generally just ghc main.hs will do the right thing if you have the libraries installed.
17:50:02 <geekosaur> but there's a lot of libraries out there and they aren't always compatible with each other so we use build tools like cabal-install or stack
17:50:30 <geekosaur> and work in sandboxes so the build tools can try to keep conflicting library versions out of the way
17:51:27 <lispy> bufferloss: you can also use the :e command in ghci to invoke your editor
17:52:11 <lispy> I don't know if anyone actually works that way though. I tend to have vim or emacs open in one terminal and run cabal commands in another terminal (I use tmux to manage all the terminals)
17:56:32 <geekosaur> I think I mentioned earlier that there are haskell support packages for various editors? one thing they allow you to do is to send part or all of the file you're editing to ghci so you can test it. another is a ghci interaction buffer
18:02:11 <Pamelloes> Wooo! GHC 7.10 compiled :D
18:04:17 <bufferloss> so, I think I understand this, but I am not entirely positive, parentheses are for more than just tuples right?
18:04:41 <bufferloss> am I correct if I say that parentheses are also use to run or invoke a function but that the parentheses can optionally sometimes be omitted?
18:05:02 <Pamelloes> Parentheses are not used to run or invoke a function.
18:05:13 <Pamelloes> They are used for tuples and for grouping like in math.
18:05:15 <ronh> space is used to apply a function to an argument. parenthesis are used for grouping 
18:06:51 <bufferloss> hm ok
18:06:59 <bufferloss> is there a channel ghci bot?
18:07:17 <Pamelloes> > print "here I am!"
18:07:19 <lambdabot>  <IO ()>
18:07:25 <Pamelloes> :/
18:07:34 <Pamelloes> Apparently I'm not that good with lambdabot.
18:07:35 <bufferloss> > "here I am!"
18:07:36 <lambdabot>  "here I am!"
18:07:39 <bufferloss> :)
18:08:12 <Pamelloes> If you want to interact with lambadabot, you should PM it for the most part.
18:08:13 <mniip> > text "hi"
18:08:15 <lambdabot>  hi
18:08:21 <bufferloss> k
18:08:52 * Pamelloes is super excited. nix finally finished compiling ghc and is now working through haskell dependencies
18:12:17 <bufferloss> > pow :: Integer -> Integer
18:12:19 <lambdabot>  Not in scope: ‘pow’
18:12:22 <bufferloss> why?
18:12:41 <Pamelloes> What is pow?
18:12:45 <bufferloss> I'm on http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html the second called "Defining basic functions"
18:13:09 <bufferloss> Pamelloes, I intended it to be an identifier for a function
18:13:15 <bufferloss> isn't that the way to "declare" a function?
18:13:19 <bufferloss> > i :: Int
18:13:20 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Expr’
18:13:20 <lambdabot>      In the expression: i :: Int
18:13:26 <Pamelloes> That's the type signature for the function.
18:13:47 <Pamelloes> If you want to define a function in ghci, you have to use let.
18:13:53 <bufferloss> hmm, ok
18:14:05 <bufferloss> > let pow :: Integer -> Integer
18:14:05 <Pamelloes> So: let pow :: Integer -> Integer; pow x = x * x
18:14:06 <lambdabot>  <no location info>:
18:14:06 <lambdabot>      not an expression: ‘let pow :: Integer -> Integer’
18:14:24 <bufferloss> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html has that :: syntax all over the place
18:14:32 <bufferloss> does that only work if it's in a source file?
18:14:41 <Pamelloes> See, "pow :: Integer -> Integer" isn't a statement. It's a type declaration. The actual function is the next line.
18:14:42 <bufferloss> > let pow x = x * 2 in 5
18:14:44 <lambdabot>  5
18:14:56 <bufferloss> > let x = x * 2 in 5
18:14:57 <lambdabot>  5
18:16:03 <ronh> let pow :: Integer -> Integer; pow x = x * x  works in ghci
18:16:25 <mniip> ghci pretends to be a do block
18:16:25 <bufferloss> > let pow :: Integer -> Integer; pow x = x * x
18:16:27 <lambdabot>  <no location info>:
18:16:27 <lambdabot>      not an expression: ‘let pow :: Integer -> Integer; pow x = x * x’
18:16:28 <mniip> hence you can use let
18:16:37 <mniip> lambdabot is not ghci
18:16:43 <bufferloss> > let pow :: Integer -> Integer; pow x = x * x; pow 5
18:16:45 <lambdabot>  <hint>:1:52:
18:16:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:16:58 <bufferloss> k
18:17:03 <Pamelloes> bufferloss: lambdabot is not exactly equal to ghci.
18:28:48 <bufferloss> how do I use https://www.haskell.org/hugs/pages/libraries/base/Text-Printf.html#t%3APrintfArg
18:29:20 <bufferloss> i get Not in scope: printf
18:29:39 <bufferloss> and import Text reports parse error on input Text.printf
18:29:41 <geekosaur> import Text.Printf; {- ... -} printf "foo %s bar" someStringHere
18:30:15 <geekosaur> (don't try to understand PrintfType)
18:30:30 <bufferloss> ok yeah that works thanks
18:37:47 <bufferloss> so, it appears I don't strictly need to provide the signature
18:37:57 <bufferloss> I assume there's probably a reason I should anyway?
18:38:21 <bufferloss> > let sumtorial :: Integer -> Integer; sumtorial 0 = 0; sumtorial n = n + sumtorial (n-1);
18:38:22 <lambdabot>  <no location info>:
18:38:22 <lambdabot>      not an expression: ‘let sumtorial :: Integer -> Integer; sumtorial 0 = 0...
18:38:28 <bufferloss> > let sumtorial :: Integer -> Integer; sumtorial 0 = 0; sumtorial n = n + sumtorial (n-1); sumtorial 5
18:38:29 <lambdabot>  <hint>:1:101:
18:38:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:38:44 <bufferloss> hmm, that works if you s/;/\r/ and put it in a file anyway
18:38:44 <jle`> bufferloss: > can only evaluate expressions
18:38:55 <bufferloss> it also works if I remove the :: statement, why is that?
18:39:01 <jle`> "let x = 4" is not an expression, but "let x = 5 in x" is an expression
18:39:04 <bufferloss> and should I always still include my :: statement for the definition?
18:39:10 <jle`> > let x = 5 in x
18:39:11 <lambdabot>  5
18:39:45 <jle`> "let ... in ..." has a block for declarations and a block for expressions using the declarations :)  you're missing the `in`
18:39:56 <jle`> "let x = 5" is not an expression alone and doesn't evaluate to anything
18:40:09 <edk> for function bindings omitting the type usually works
18:40:16 <bufferloss> jle`, I'm reading the section here http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html called "Defining basic functions"
18:40:21 <bufferloss> that code is basically from them, verbatim
18:40:26 <bufferloss> I'm less concerned about ghci
18:40:36 <bufferloss> the code works fine in a .hs file when I build and compile and run using cabal
18:40:41 <jle`> yeah, just explaining why "> ..." doesn't work :)
18:40:52 <bufferloss> k
18:40:54 <jle`> "> ..." only evaluates expressions
18:40:57 <bufferloss> right
18:41:02 <jle`> but it's also important to tell when expressions are different than declarations
18:41:14 <jle`> for example, if you had `6 * _____`, the blank is supposed to be an expression
18:41:15 <edk> in this case the type of sumtorial is more restricted than what would be inferred, i believe
18:41:21 <bufferloss> so in terms of non ghci, why is it that it's ok for me to omit the foo :: Int -> Int
18:41:24 <edk> which would be a good reason to include the signature, if that's what you want
18:41:31 <jle`> if you did `6 * (let x = 5)`, that's not well formed
18:41:45 <bufferloss> edk, ah ok, so like if I want to be able to use it on integers and floats for example
18:41:52 <bufferloss> edk, then I might want to omit the signature
18:42:00 <edk> or supply a more generic one
18:42:06 <init> bufferloss: we normally keep the type signatures for top-level functions as documentation
18:42:20 <bufferloss> edk, ok cool thanks
18:47:58 <mniip> because parametricity
18:48:53 <mniip> there aren't too many functions that can satisfy a signature, and provided the name is meaningful, you can uniquely identify what a function does and how to use it
18:50:14 <mniip> but it also almost mandatory in the haskell community to document everything
19:16:39 <lispy> It really depends on the types, String -> IO () has lots of (very different) inhabitants
19:18:59 <init> lispy: that's a good reason to avoid IO! :p
19:20:17 <benzrf> lispy: it has at least as many inhabitants as IO (), even
19:22:17 <Fuuzetsu> isn't it always the case that (a -> b) has always at least as many inhabitants as b?
19:24:16 * hackagebot snap 0.14.0.6 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0.6 (DougBeardsley)
19:25:30 <mniip> Fuuzetsu, no
19:26:08 <mniip> you're asking whether b^a >= b
19:26:35 <Fuuzetsu> ah
19:26:44 <Fuuzetsu> ok, how about when a >= 1 then
19:26:45 <Javran> you mean when a ~ Void ?
19:26:49 <Fuuzetsu> yes, he does
19:26:52 <mniip> Fuuzetsu, then yes
19:26:53 <Fuuzetsu> ok
19:27:07 <Fuuzetsu> at least in Haskell b^a >= b ;)
19:27:13 <Fuuzetsu> or should that be ;(
19:27:14 <init> considering there's no Void in Haskell...
19:27:15 <mniip> Void exists in haskell
19:27:27 <init> we have bottom 
19:28:01 <mniip> if we ignore lifting
19:28:15 <init> well, if we ignore it, then Haskell is so nice :P 
19:28:29 <init> I am not sure how type families get there, too
19:32:11 <bufferloss> in http://www.seas.upenn.edu/~cis194/spring13/lectures/02-ADTs.html he asks "what its the type of OK?"
19:32:22 <ttt_fff> uisng lens, how do I write \(a, b, c) -> a ?
19:32:41 <bufferloss> data FailableDouble = Failure\n    | OK Double\n  deriving Show
19:32:48 <bufferloss> so, what *is* the type of OK?
19:33:09 <bufferloss> is that an un-named ADT?
19:33:12 <init> ttt_fff: view _1 
19:33:18 <ttt_fff> is ther something shorter
19:33:19 <ttt_fff> using ^ ?
19:33:21 <ttt_fff> or something like that
19:33:36 <init> using the infix version of view.. maybe...
19:33:51 <init> > (1,2,3)^._1 
19:33:53 <lambdabot>  1
19:34:11 <Javran> bufferloss: isn't it Double -> FailableDouble ?
19:34:13 <ttt_fff> http://ekmett.github.io/lens/Control-Lens-Getter.html#v:-94-.
19:34:17 <ttt_fff> init++
19:34:19 <bufferloss> Javran, I don't know what it is
19:34:20 <ttt_fff> @karma init
19:34:20 <lambdabot> init has a karma of 1
19:34:23 <bufferloss> Javran, that's why I'm asking
19:35:04 <Javran> so the LHS of a data definition is a type, and RHSs are defining data constructors
19:35:38 <Javran> Failure is a data constructor that takes no argument, so itself is also a value of type FailableDouble
19:36:17 <Javran> OK is also a data constructor, but this time it needs a Double to construct a value of type FailableDouble
19:37:02 <Javran> so OK :: Double -> FailableDouble, but if you feed it with some value, say "OK 1.0", then this is a FailableDouble
19:37:02 <bufferloss> ok
19:37:11 <bufferloss> got it
19:37:16 <Javran> :)
19:37:46 <mniip> @karma mniip
19:37:46 <lambdabot> You have a karma of 1
19:37:47 <mniip> :(
19:38:09 <init> my guess is that it just tracks the nick, right?
19:38:39 <shachaf> Only you know what your guess is.
19:38:46 <shachaf> But that's what it does.
19:40:29 <ttt_fff> what is control.lens.rewrite used for?
19:41:21 <lispy> ttt_fff: it's part of the lens example uniplace reimplementation
19:41:26 <lispy> uniplate*
19:41:33 <ttt_fff> lispy: ELI5 what is uniplate ?
19:41:42 <ttt_fff> https://hackage.haskell.org/package/lens-2.9/docs/Control-Lens-Plated.html amkes no sense
19:41:43 <lispy> ttt_fff: https://hackage.haskell.org/package/lens-2.9/docs/Control-Lens-Plated.html
19:41:52 <ttt_fff> lol
19:42:04 <lispy> ttt_fff: Well, uniplate was a replacement for the scrap your boilerplate approach
19:42:16 <lispy> ttt_fff: roughly speaking, its for generic programming
19:42:20 <ttt_fff> yeah
19:42:23 <ttt_fff> but I use GHC.Generics
19:43:30 <lispy> uniplate is good for transforming a large typed AST
19:49:17 * hackagebot twitter-conduit 0.1.1 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.1.1 (TakahiroHimura)
19:50:22 * Welkin clicks
20:08:23 <tcs> I'm wondering if it's possible to override an instance from a package?
20:08:56 <mniip> no
20:09:26 <tcs> thought as much, damn
20:09:39 <mniip> there is also no way to "hide" instancess
20:10:09 <mniip> the type system would collapse if that was allowed
20:11:34 <tcs> fair enough, I guess I could re-implement the function that relies on the instance, hide it in my import and call a separate function that does the same thing
20:12:17 <ttt_fff> damn it, anyone run into situations where "cabal cmpile" runs fine, but hdevtools (plugged into vim via syntastic) bitches about errors ?
20:12:53 <Welkin> that sounds like a fragile setup
20:13:02 <Welkin> I don't use anything by haskell-mode
20:13:08 <Welkin> not even a linter or ghc-mod
20:13:13 <Welkin> but*
20:13:30 <ttt_fff> Welkin: it's worked for me for months
20:13:37 <ttt_fff> but now, apparelty ghc and hdevtools diverge on waht's allowed
20:14:01 <ttt_fff> so ":make" ==> cabal compile works fine; but ":w" ==> hdevtools, gets me errors taht ghc is ciool with
20:14:18 * hackagebot gtk3-mac-integration 0.3.1.1 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.1.1 (HamishMackenzie)
20:15:18 <bufferloss> ok, so http://www.seas.upenn.edu/~cis194/spring13/lectures/03-rec-poly.html has a section called Recursion patterns where they mention mapIntList
20:15:25 <bufferloss> but they don't provide the way to actually implement that function
20:15:34 <bufferloss> how do I pass (and use) multiple parameters in a function?
20:17:13 <Cale> bufferloss: Yeah, there's a code section missing there
20:17:24 <Cale> mapIntList f Empty = Empty
20:17:35 <bufferloss> k
20:17:36 <Cale> mapIntList f (Cons x xs) = Cons (f x) (mapIntList f xs)
20:17:46 <bufferloss> I was trying Empty f
20:17:51 <bufferloss> at least I was close :)
20:18:27 <Cale> Yeah, you could put the arguments in the other order, but the rest of the code assumes the function is first (and there are a bunch of things which make that choice the more convenient one)
20:19:19 * hackagebot gtk-mac-integration 0.3.1.1 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.3.1.1 (HamishMackenzie)
20:19:51 <Cale> Well, mostly it's just that in Haskell when you apply a function to less than all of its arguments, you get a function which will accept the rest. So you usually want to put the arguments which will change rapidly last, and the more configuration-y / constant things first
20:20:14 <bufferloss> Cale, so what would/should/does the signature look like?
20:20:26 <bufferloss> mapIntList (Int -> Int) IntList -> IntList gives me an error
20:20:40 <Welkin> :t flip . flip
20:20:41 <lambdabot> (b -> a -> c) -> b -> a -> c
20:20:44 <Cale> mapIntList :: (Int -> Int) -> IntList -> IntList
20:20:54 <bufferloss> Int -> Int is applied to too many type arguments
20:21:02 <mniip> you missed an arrow
20:21:04 <bufferloss> oh, right need the other ->
20:21:05 <bufferloss> thx
20:21:06 <mniip> probably
20:21:54 <Cale> bufferloss: Note that it's possible to write that as  (Int -> Int) -> (IntList -> IntList)
20:22:17 <Cale> bufferloss: which suggests that one way to think about this function is that it's turning a function on Int values into a function on IntList values
20:23:27 <bufferloss> cool
20:24:33 <mlrutherford> what would be the haskell equivalent of SLIME for Emacs?
20:29:30 <arkeet> :t (flip .)
20:29:31 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
20:29:35 <arkeet> :t ((flip .) .)
20:29:36 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> b -> a2 -> c
20:29:39 <arkeet> :t (((flip .) .) .)
20:29:40 <lambdabot> (a -> a1 -> a2 -> a3 -> b -> c) -> a -> a1 -> a2 -> b -> a3 -> c
20:29:52 <arkeet> :t flip . (flip .) . flip
20:29:53 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
20:34:13 <bufferloss> mlrutherford, that would be vim :P
20:36:21 <mniip> emacs is a great os
20:36:25 <mniip> it only lacks a decent editor
20:37:10 <mlrutherford> To each their own, but I love the emacs key bindings :P
20:37:36 <mlrutherford> Plus writing plug-ins in a Lisp is always nice :D
20:43:37 <blup> is there such thing as C-itis?
20:44:07 <Welkin> ?
20:44:21 <geekosaur> this sounds like a -blah discussion
20:50:18 <bufferloss> in www.seas.upenn.edu/~cis194/spring13/lectures/03-rec-poly.html under the section "Writing partial functions" what does the $ do?
20:50:32 <bufferloss> is Just $ NEL x xs the same as Just (NEL x xs) ?
20:50:51 <geekosaur> yes
20:51:07 <geekosaur> $ is normal function application except at very low precedence instead of highest precedence
20:51:15 <geekosaur> so it kinda acts like inverted parentheses
20:52:01 <bufferloss> k
20:52:14 <nitrix> Is there a convenient table with operator precedence in Haskell?
20:52:46 <nitrix> Just recently, I got caught up by <$> and $.
20:52:59 <Welkin> yes
20:53:01 <Welkin> on the wiki
20:54:02 <Welkin> oh
20:54:07 <Welkin> I was thinking of the keywords page
20:54:08 <Welkin> https://wiki.haskell.org/Keywords
20:54:29 <nitrix> It's not exactly detailed though.
20:54:55 <Welkin> well
20:55:00 <Welkin> it depends on the library it comes from
20:55:11 <Welkin> the operators are just normal functions
20:55:13 <Welkin> they are not special
20:55:24 <Welkin> just infix versions of named functions (usually)
20:55:56 <Welkin> :info (>>=)
20:56:01 <Welkin> @info (>>=)
20:56:01 <lambdabot> (>>=)
20:56:04 <Welkin> well
20:56:12 <Welkin> if you use :info (>>=)
20:56:14 <Welkin> in ghci
20:56:21 <Welkin> it tells you the precedence
20:56:34 <Welkin> if it doesn't say anything about precedence, it is infixl 9 by default
20:57:04 <nitrix> http://lpaste.net/136898
20:57:09 <nitrix> That's a good begining.
20:57:11 <Welkin> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061
20:57:19 <Welkin> that lists a few common operators
20:57:44 <nitrix> What's the difference between the l and r versions? Also the number?
20:58:03 <Welkin> 9 is highest precendece 0 is lowest
20:58:11 <nitrix> l and r are the associativity?
20:58:11 <Welkin> l means "associates to the left"
20:58:14 <Welkin> r, to the right
20:58:26 <nitrix> I see.
20:59:14 <Welkin> also, see here: http://www.scs.stanford.edu/14sp-cs240h/slides/basics-slides.html
20:59:27 <Welkin> search for "fixity of specific operators"
21:01:28 <nitrix> Welkin: Appreciated.
21:02:39 <tanko> =|
21:02:46 <bufferloss> > uncurry (+) (2,3)
21:02:47 <lambdabot>  5
21:03:51 <bufferloss> I don't quite understand the signature for uncurry
21:03:59 <bufferloss> or how to use the converse (curry)
21:04:08 <bufferloss> unschnfinkel :: (a -> b -> c) -> (a,b) -> c
21:04:14 <nitrix> :t uncurry
21:04:16 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:04:27 <bufferloss> how does (+) correspond to (a -> b -> c)
21:04:49 <geekosaur> given a function that takes two parameters Haskell-style and a tuple of parameters, unpack the tuple and pass the parameters
21:04:52 <geekosaur> :t (+)
21:04:53 <lambdabot> Num a => a -> a -> a
21:04:55 <nitrix> bufferloss: It transforms a function (a -> b -> c) to ((a, b) -> c)
21:05:12 <bufferloss> nitrix, which one is "it", curry or uncurry?
21:05:26 <nitrix> bufferloss: The two arguments becomes a tuple. Uncurry.
21:05:36 <geekosaur> haskell uses the uncurried form of parameters (foo a b instead of foo(a, b)) so that you can do partial application
21:05:51 <geekosaur> which is a powerful functional programming technique
21:05:52 <bufferloss> nitrix, uncurry looks like the opposite, a tuple becomes two arguments
21:06:42 <nitrix> "Two arguments" is very abstract, considering technically functions only have one argument. But, no.
21:07:04 <nitrix> Just focus on the type signature:
21:07:09 <bufferloss> nitrix, I was just using your own terms
21:07:29 <bufferloss> nitrix, so, uncurry *takes* a tuple
21:07:37 <bufferloss> so that fact makes it seem your definition is backwards
21:08:01 <nitrix> It's tuples all the way down. I'm just simplifying it for you.
21:08:31 <bufferloss> seems it's the opposite though, it's "single argument functions" all the way down, no?
21:09:48 <bufferloss> so, the example they give for uncurry is:
21:09:54 <bufferloss> > uncurry (+) (2,3)
21:09:55 <lambdabot>  5
21:10:03 <bufferloss> I basically understand that, what's a similar example for the usage of curry?
21:10:26 <nitrix> Currying is a big subject. If you explain what knowledge you have the subject, it might simplify the process of providing you with the missing pieces.
21:11:04 <bufferloss> nitrix, can you give a similar example usage of curry?
21:11:12 <bufferloss> like I said, I basically understand how uncurry is working
21:11:20 <nitrix> > curry fst 2 3
21:11:21 <lambdabot>  2
21:11:47 <bufferloss> >:t fst
21:11:53 <bufferloss> :t fst
21:11:54 <lambdabot> (a, b) -> a
21:12:05 <nitrix> First returns the first element of a tuple.
21:12:18 <bufferloss> ok cool yeah I get that now, thanks
21:12:25 <nitrix> :t curry fst
21:12:26 <lambdabot> c -> b -> c
21:13:00 <nitrix> So it becomes a function that returns it's "first" argument and drops its "second".
21:13:31 <ronh> > uncurry const (1,2)
21:13:33 <nitrix> But again, you might not like this simplification.
21:13:33 <lambdabot>  1
21:21:18 <bufferloss> > let foo = sum . map (\x -> 7*x + 2) . filter (>3); foo [1..10]
21:21:19 <lambdabot>  <hint>:1:63:
21:21:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:21:59 <bufferloss> > let foo = (sum (map (\x -> 7*x + 2) (filter (>3)))); foo [1..10]
21:22:01 <lambdabot>  <hint>:1:65:
21:22:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:22:01 <init> > let foo = sum . map (\x -> 7*x + 2) . filter (>3) in foo [1..10] 
21:22:02 <lambdabot>  357
21:22:13 <bufferloss> ah ok
21:22:16 <init> bufferloss: you need to give > expressions, as said previously
21:22:26 <init> let X = Y ; is not an expression
21:22:32 <init> let X = Y in Z is
21:22:36 <bufferloss> > let foo y = sum . map (\x -> 7*x + 2) . filter (>3) y in foo [1..10]
21:22:38 <lambdabot>      Couldn't match expected type ‘a1 -> [c1]’ with actual type ‘[a2]’
21:22:38 <lambdabot>      Relevant bindings include
21:22:38 <lambdabot>        y :: [a2] (bound at <interactive>:1:9)
21:23:29 <bufferloss> > let foo y = (sum (map (\x -> 7*x + 2) (filter (>3) y))) in foo [1..10]
21:23:30 <lambdabot>  357
21:23:39 <bufferloss> hmm, so what did I get wrong there?
21:23:57 <bufferloss> why is it that my usage of . works without the y but not with the y?
21:24:25 <geekosaur> because . composes functions
21:24:29 <Axman6> because (.) takes functions as arguments. when you have filter (>3) y, that's no longer a function
21:24:32 <geekosaur> filter (>3) y is not a function
21:24:48 <geekosaur> that is, its type does not look like _ -> _
21:24:51 <Axman6> the idion you'd usually use is f . g . h $ x where f, g and h are functions
21:25:16 <bufferloss> > let foo y = sum . map (\x -> 7*x + 2) . filter (>3) $ y in foo [1..10]
21:25:17 <lambdabot>  357
21:25:21 <Axman6> and x is the argument you pass to h, which returns a value which is passed to g, which returns a value which is passed to f
21:25:23 <bufferloss> ah, interesting, ok
21:25:23 <geekosaur> > let foo y = (sum . map (\x -> 7*x + 2) . filter (>3)) y in foo [1..10]
21:25:26 <lambdabot>  357
21:26:07 <Welkin> filter (>:3)
21:26:11 <Welkin> filter for lions!
21:26:42 <dramforever> :t filter (<3)
21:26:44 <lambdabot> (Num a, Ord a) => [a] -> [a]
21:28:32 <bufferloss> > [] : []
21:28:34 <lambdabot>  [[]]
21:28:43 <init> dramforever: that's a love filter 
21:29:06 <dramforever> :t (<*>) . (<*>)
21:29:07 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
21:32:42 <bufferloss> why are some named a and some named b?
21:32:50 <bufferloss> like why doesn't it say e.g. a2 instead of b there?
21:33:08 <dramforever> :t (<*>) -- I guess it came from here
21:33:09 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:33:24 <bufferloss> but there, why not a1 instead of b?
21:33:36 <dramforever> IIUC the a1 is renamed from a
21:34:05 <bufferloss> :t (+)
21:34:06 <lambdabot> Num a => a -> a -> a
21:34:26 <init> bufferloss: it's just what the compiler said
21:34:32 <bufferloss> why is it all a's there, is that because it's supposed to input and output the same types
21:35:47 <jle`> bufferloss: yeah, they're all the same type because the inputs and outputs are the same type
21:36:04 <bufferloss> :t Int -> String
21:36:05 <lambdabot> parse error on input ‘->’
21:36:08 <jle`> the reason why it's `a` and not Num b => b -> b -> b is because GHC tries to guess from the source code
21:36:10 <bufferloss> :t (Int -> String)
21:36:11 <lambdabot>     Pattern syntax in expression context: Int -> String
21:36:20 <jle`> and use the letters you give when you write the source
21:36:25 <jle`> but it's all the same
21:37:09 <jle`> bufferloss: what are you trying to ask? :)
21:39:13 <wei2912> bufferloss: Int -> String is a type itself, you can't find the type of a type
21:39:25 <dramforever> :k Int -> String
21:39:26 <lambdabot> *
21:39:35 <dramforever> you could find the kind, though
21:39:44 <wei2912> ^^
21:53:41 <bros> application _ respond = respond $ responseLBS status200 [("Content-Type", "text/plain")] "Hello World"
21:53:53 <bros> Can somebody explains what the _ represents/translates to in that line of code?
21:53:58 <bros> s/explains/explain
21:54:45 <bros> application matching anything takes parameter respond, $ is the operator that fakes a parentheses wrap
21:54:55 <hodapp> bros: it's just something that's ignored.
21:55:21 <bros> so it's application _ respond = respond (responseLBS status200 [("Content-Type", "text/plain")] "Hello World")
21:55:32 <hodapp> yeah, we know what $ stands for
21:55:38 <bros> i don't, lol
21:55:51 <hodapp> not sure but looks like a function argument that is just ignored.
21:56:25 <hodapp> > let foo _ n = n + 1 in foo 100 2
21:56:27 <lambdabot>  3
21:58:04 <bros> hodapp: responseLBS :: H.Status -> H.ResponseHeaders -> L.ByteString -> Response does that translate to responseLBS is a function that takes 3 parameters a d outputs 1 of type Response?
21:58:08 <bros> and*
22:01:08 <jle`> wei2912: bros you can view it in that way
22:01:16 <jle`> er sorry, bros , not wei2912 
22:01:47 <wei2912> lol
22:01:49 <bros> so $ only wraps the following 2 parameters
22:01:56 <bros> application _ respond = respond (responseLBS status200 [("Content-Type", "text/plain")]) "Hello World"
22:02:03 <jle`> $ goes from the end of the line to the beginning of the line
22:02:11 <jle`> it's like the spine of a  beautiful butterfly
22:02:16 <jle`> whose wings expand both sides
22:02:27 <hodapp> o_O
22:02:36 <jle`> f x y $ g a b c = (f x y) (g a b c)
22:02:54 <bros> application _ respond = respond $
22:02:54 <bros>   responseLBS status200 [("Content-Type", "text/plain")] "Hello World"
22:02:56 <dramforever> bros: how about this: do you understand operator associativity and precedence?
22:03:03 <bros> I do not! :/
22:03:20 <dramforever> =(
22:03:22 <bros> have no idea who do, ->, ', $, ` mean at the moment. trying to figure it out
22:03:26 <jle`> bros: so that is (respond) (responseLBS status200 [...] "hello world")
22:03:45 <dramforever> bros: is haskell your first programming language?
22:03:47 <bros> jle`: why is respond wrapped?
22:03:49 <bros> dramforever: not at all.
22:03:54 <jle`> ($) is not a special syntax, it's just a normal defined operator
22:04:07 <jle`> bros: i wrapped it redundantly to show that ($) goes over "both sides"
22:04:14 <jle`> let's look at the definition of ($)
22:04:18 <jle`> @src ($)
22:04:18 <lambdabot> f $ x = f x
22:04:33 <dramforever> jle`: actually it *is* special, because it has a different typing rule =)
22:04:34 <jle`> so you have respond $ responseLBS status200 [..] "hello world"
22:04:46 <jle`> and so if you match it up with the definition
22:04:50 <jle`> f is resond
22:04:59 <jle`> and x is "responseLBS status200 [..] "hello world""
22:05:10 <bros> ok, cool. makes sense.
22:05:19 <jle`> dramforever: heh, that's another story though >_>
22:05:22 <dramforever> =)
22:05:32 <bros> http://pastebin.com/FpuPnsAN jle`
22:05:36 <bros> what does "do" mean?
22:05:43 <jle`> it's a syntax construct
22:05:55 * dramforever remembered someone asking "what do the separators . and $ mean in haskell?"
22:06:09 <bros> and \count and -> and let count' and <> and <- ?
22:06:15 <jle`> bros: for the case of "main" it's sequencing IO actions
22:06:31 <dramforever> "\count ->" is special syntax
22:06:32 <jle`> "first do the IO action newMVar 0 and call the reuslt visitorCount.  then do run 3000 ... etc"
22:06:35 <dramforever> <> is an operator
22:06:39 <jle`> every lilne of a do block is a sequenced action
22:06:41 <dramforever> and <- is special syntax
22:07:04 <jle`> so if you want to sequence three IO actions, you'd do "do x; y; z"
22:07:15 <jle`> here they sequenced two IO actions
22:07:26 <bros> so <- is like assignment
22:07:28 <jle`> `<-` lets you name the result of an action for use later
22:07:29 <redcoat> I second hodapp's sentiment.
22:07:44 <jle`> it's kind of like assignment
22:07:51 <benzrf> >_<
22:07:58 <benzrf> bros: it's just syntactic sugar
22:08:00 <dramforever> bros: you can define custom operators in haskell. anything operator-ish thing you see that is not listed in http://haskell.org/haskellwiki/Keywords is an operator
22:08:15 <benzrf> bros: `do' is, anyway
22:08:17 <redcoat> dramforever: Except for <-, which is syntax.
22:08:20 <benzrf> as well as <-
22:08:26 <dramforever> redcoat: it's listed there
22:08:31 <redcoat> Bullshit.
22:08:32 <bros>  modifyMVar countRef $ \count -> do
22:08:39 <jle`> so you have actions x y z, you can sequence tehm as `do x; y; z`
22:08:40 <bros> \ means multiline according to that link?
22:08:40 <hodapp> redcoat: which sentiment was that?
22:08:51 <Welkin> also, operators are not special, they are just infix functions
22:08:58 <jle`> some actions have results, which you might want to name and use later in the do block
22:09:02 <redcoat> dramforever: Oh, in the keywords you mean. Yes, I would believe that. :P
22:09:05 <jle`> to name and catch the result, you use <-
22:09:08 <redcoat> hodapp: "o_O"
22:09:10 <dramforever> bros: there are two meanings, see?
22:09:16 <ferdinand> quick question: https://gist.github.com/25cf/1c26e98368379453bc37
22:09:25 <hodapp> redcoat: oh, okay.
22:09:26 <dramforever> first one is only in string literals, second is in expressions
22:09:29 <jle`> `do res <- x; y; z` is the same thing, except now the result of the action `x` can be used later as "res"
22:09:44 <jle`> (\x -> blah blah) is anonymous function syntax
22:09:51 <P4Titan> Hello all, could some just look at this short code and tell me possibly any improvements: http://lpaste.net/7173325799343259648
22:09:59 <bros> jle`: when you reference res, do you have to say res'?
22:10:06 <bros> why does that code refer to count as count'?
22:10:09 <dramforever> bros: how about this: what other programming languages do you know?
22:10:14 <jle`> `(\x -> x * 3)` is a function that takes a number and returns the number multiplied by three
22:10:15 <bros> dramforever: c, assembly, node
22:10:29 <jle`> dramforever: no, there is another variable called coun't
22:10:33 <jle`> er sorry, bros 
22:10:35 <redcoat> bros: You should read "Learn You a Haskell". :)
22:10:44 <benzrf> nooooo
22:10:45 <jle`> "count'" is defined as another binding
22:10:46 <redcoat> Or Real World Haskell. Both are good books.
22:10:50 <benzrf> no, redcoat
22:10:51 <dramforever> oh great, so \a -> blah is kinda like function(a) { return blah; }
22:10:54 <redcoat> benzrf: Whatever, that's how I learned Haskell.
22:10:55 <P4Titan> > pure ()
22:10:57 <lambdabot>      No instance for (Show (f0 ()))
22:10:57 <lambdabot>        arising from a use of ‘show_M57058077752010152464756’
22:10:57 <lambdabot>      The type variable ‘f0’ is ambiguous
22:10:57 <benzrf> there are pedagogical issues with both
22:10:58 <jle`> "count'" is defined on line 12
22:11:00 <benzrf> redcoat: yes, i used lyah too
22:11:07 <jle`> dramforever: ya
22:11:21 <bros> benzrf: i agree. they were both very math heavy.
22:11:21 <dramforever> =)
22:11:24 <redcoat> Not everything is perfect. Someday, people grow up and realize that they have to stumble on their own, sometimes.
22:11:30 <P4Titan> How does the guard function work?
22:11:37 <dramforever> bros: huh?
22:11:39 <jle`> the usage of ($) to cheat parentheses makes it a bit weird to read when you're getting used to it
22:11:41 <benzrf> redcoat: that doesnt excuse lyah being so-so
22:11:43 <dramforever> math heavy?
22:11:46 <bitemyapp> redcoat: not all pain or stumbling has utility.
22:11:49 <benzrf> bros: math heaviness is not an issue i am aware of
22:12:04 <P4Titan> It returns a pure () which allows the code to continue, and empty which stops the execution there
22:12:05 <bitemyapp> redcoat: having a challenge put before that is tractable and constructive can be useful. Bad material is not.
22:12:07 <dramforever> seriously why do you think they are math heavy?
22:12:08 <redcoat> bitemyapp: I kept thinking in my head "what if bitemyapp shows up and talks about his book again..."
22:12:16 <jle`> P4Titan: it signals failure if the condition doesn't hold
22:12:21 <dramforever> P4Titan: yes, so what's your question again?
22:12:34 <P4Titan> Which one, the code one or about guard?
22:12:34 <bitemyapp> redcoat: it's not really about that. I point people to the guide which says nothing of my book.
22:12:53 <bitemyapp> redcoat: and I was steering people away from less-than-ideal material long before I started on the book.
22:12:58 <P4Titan> I am using guard with the context of [] and pure () does not make much sense to me
22:12:59 <JoeyA> ferdinand: Great question!  The first thing that popped into my mind involved GADTs (an advanced Haskell feature), but I don't think that would be a good idea.
22:13:03 <bros> msg = fromByteString "You are visitor number: " <>
22:13:03 <bros>                   fromShow count'
22:13:09 <redcoat> Oh, I know. And I know this is a personal thing for you. Still, it's funny that your LYAH senses were tingling.
22:13:09 <dramforever> P4Titan: it does:
22:13:14 <dramforever> > pure () :: [()]
22:13:15 <bros> jle`: what does <> do there? i've understood everything so far
22:13:15 <lambdabot>  [()]
22:13:30 <dibblego> redcoat: your mode of argument is dishonest. "Not all things are perfect" and "but you are writing a book" do not contribute to the topic of the discussion.
22:13:44 <redcoat> dibblego: I'm not arguing. :P
22:13:46 <P4Titan> > empty :: []
22:13:47 <lambdabot>      Expecting one more argument to ‘[]’
22:13:47 <lambdabot>      Expected a type, but ‘[]’ has kind ‘* -> *’
22:13:47 <lambdabot>      In an expression type signature: []
22:13:49 <ferdinand> JoeyA: is there a good way to do this?
22:13:52 <Welkin> I think LYAH is good for the community because it makes haskell more approachable for beginners
22:13:57 <Welkin> even if it is not the best resource
22:13:58 <dibblego> redcoat: or that
22:14:03 <JoeyA> The GADT approach would make the Hard and Soft data constructors have different types, and would add a type parameter to Bed to distinguish.  But it'd probably be better to avoid GADTs and find a simpler solution.
22:14:11 <Welkin> it got me to start learning, then I moved on to better resources
22:14:11 <bitemyapp> Welkin: it doesn't make Haskell more approachable in a meaningful sense. It's just shrink-wrap.
22:14:17 <P4Titan> > empty :: [()]
22:14:19 <lambdabot>  []
22:14:30 <P4Titan> > pure () :: [1]
22:14:31 <lambdabot>      Expected kind ‘*’, but ‘1’ has kind ‘GHC.TypeLits.Nat’
22:14:31 <lambdabot>      In an expression type signature: [1]
22:14:31 <lambdabot>      In the expression: pure () :: [1]
22:14:32 * dramforever thinks that #haskell would be better if it were separated into topics
22:14:41 <benzrf> bitemyapp: i think Welkin means in terms of PR
22:14:43 <P4Titan> pure () :: [a]
22:14:43 <JoeyA> ferdinand: You could split out the mattress attributes into their own type.
22:14:46 <ferdinand> JoeyA: I'm new to haskell so I didn't know if it had type parameters like Java. I suppose it would be much more complicated though.
22:14:50 <bitemyapp> benzrf: that would be true then. That falls under shrinkwrap.
22:14:53 <P4Titan> > pure () :: [a]
22:14:54 <lambdabot>      Couldn't match expected type ‘a1’ with actual type ‘()’
22:14:54 <lambdabot>        ‘a1’ is a rigid type variable bound by
22:14:54 <lambdabot>             an expression type signature: [a1] at <interactive>:1:1
22:15:08 <ferdinand> JoeyA: do you mean something like HardBed and SoftBed?
22:15:19 <dibblego> ferdinand: it has type parameters in ways that are similar to java, and also dissimilar ways in other contexts where java's type system is limited.
22:15:23 <bros> jle`: did the chatter in the channel cause me to lose you?
22:15:23 <dramforever> so we now have "help bros read code" topic, "the guard function" topic and "help ferdinand" topic
22:15:30 <ferdinand> haha
22:15:36 <P4Titan> Ok, for guard: When it returns [()] how does that allow the code to continue, but when it returns [], the code stops there?
22:15:42 <bitemyapp> dramforever: 1418 present in channel. So it goes.
22:15:54 <dramforever> bitemyapp: most are inactive
22:16:02 <ferdinand> late saturday night haskelling
22:16:14 <JoeyA> I gotta go
22:17:04 <Welkin> most everyone is just leeching animu from lambdabot
22:17:15 <dramforever> bros: <> is yet another operator
22:17:16 <Welkin> they never talk
22:17:20 <dirk103> what is <- called?
22:17:23 <bitemyapp> Welkin: LOL
22:17:26 <bros> dramforever: what does <> do?
22:17:32 <bitemyapp> dirk103: bind is a reasonable name for <-
22:17:33 <Welkin> dirk103: you can pronounce that "from"
22:17:36 <P4Titan> :t (<>)
22:17:37 <lambdabot> Monoid m => m -> m -> m
22:17:40 <dramforever> it's an infix form of mappend
22:17:41 <ferdinand> not left arrow? :)
22:17:52 <dibblego> bros: when you have the question, what does anything do? then rephrase that question at GHCi with :info
22:18:10 <dibblego> Prelude Data.Monoid> :info (<>)
22:18:10 <dibblego> (<>) :: Monoid m => m -> m -> m         -- Defined in Data.Monoid
22:18:21 <Welkin> SPJ pronounces "x <- xs" as "x from xs"
22:18:21 <P4Titan> guard anyone?
22:18:28 <wei2912> P4Titan: hmm?
22:18:43 <P4Titan> Ok, for guard: When it returns [()] how does that allow the code to
22:18:44 <P4Titan>           continue, but when it returns [], the code stops there?
22:18:49 <dramforever> yes
22:18:49 <jle`> > map (\_ -> 2) [()]
22:18:51 <lambdabot>  [2]
22:18:52 <jle`> > map (\_ -> 2) []
22:18:53 <lambdabot>  []
22:18:56 <jle`> see the difference, P4Titan ?
22:19:18 <P4Titan> ok, that is map
22:19:25 <jle`> (>>=) is concatMap
22:19:27 <dramforever> P4Titan: IIUC the applicative laws imply pure () *> m
22:19:30 <jle`> it's a map and a concat
22:19:40 <dramforever> and empty *> m = empty
22:19:42 <jle`> > [()] >>= (\_ -> [2])
22:19:43 <lambdabot>  [2]
22:19:43 <P4Titan> @src [] (>>=)
22:19:43 <lambdabot> xs >>= f = concatMap f xs
22:19:49 <jle`> > [] >>= (\_ -> [2])
22:19:50 <bros> dramforever: ok. i understand. mappend is sort of like string concatenation. last question, it regards to the do/let
22:19:51 <lambdabot>  []
22:20:02 <bros> why does line 12 have let, but not 13? did they omit it for brevity?
22:20:14 <dirk103> what in the world is all that ugly symbols about
22:20:16 <P4Titan> ohhh, tricky
22:20:17 <dramforever> yes, it's a let block
22:20:27 <ferdinand> any ideas here? https://gist.github.com/25cf/1c26e98368379453bc37
22:20:30 <jle`> bros: you use <- to bind the results of actions
22:20:30 <dramforever> P4Titan: did my explaination make sense?
22:20:36 <Welkin> dirk103: infix functions
22:20:40 <jle`> bros: but "count + 1" is not an action
22:20:46 <P4Titan> all is good, thanks
22:20:50 <jle`> let count' = count + 1 is just a definition
22:20:58 <bros> jle`: so in that case, you use let. ok. i see.
22:20:59 <jle`> "every time you see count', remember that it's just count + 1"
22:21:02 <jle`> that's what "let" means
22:21:14 <bros> could lines 13 and 14 been written as one line?
22:21:15 <jle`> "let x = y" means, "in this block, wherever you see x, remember that it's just y."
22:21:21 <jle`> yes
22:21:39 <bros> then every line of a do block is a statement that gets executed, as if it were a "function"
22:21:46 <jle`> in this case it's being used to concatenate Bytestrings
22:21:50 <jle`> er, (<>) is being used for that
22:21:59 <jle`> it's what we call "functions" in other languages
22:22:08 <Welkin> > 4 <> 7 :: Num a => Sum a
22:22:08 <jle`> or more appropriately, subroutines, kinda
22:22:09 <lambdabot>  Sum {getSum = 11}
22:22:14 <Welkin> > 4 <> 7 :: Num a => Product a
22:22:14 <jle`> but it's not what we call a function in haskell
22:22:15 <lambdabot>  Product {getProduct = 28}
22:22:30 <jle`> yeah, (<>) is overloaded over many different types
22:22:37 <jle`> for Bytestring, it's concatenation
22:22:56 <jle`> for lists it's also concatentation
22:23:00 <jle`> > [1,2,3] <> [4,5,6]
22:23:01 <lambdabot>  [1,2,3,4,5,6]
22:23:05 <bros> jle`: line 11, what is the purpose of \count?
22:23:10 <jle`> every type gets to define its own implementation of (<>)
22:23:14 <bros> why can't it be just count?
22:23:15 <jle`> bros: it's a big (\x -> ...) block
22:23:22 <jle`> modfyMVar m takes a function
22:23:28 <Welkin> \ means lambda
22:23:34 <jle`> the line is really `modifyMVar m (\count -> ..... )`
22:23:45 <jle`> the entire lines 11-19 is that one thing
22:23:55 <jle`> lines 12 to 19 are what's in that "...."
22:23:59 <bros> i see. is it bad if i ask what lambda is?
22:24:06 <jle`> yeah, it's just an anonymous function
22:24:14 <jle`> (\x -> ...) is a function that akes x as an argument
22:24:30 <jle`> (\x -> x * 2) is a function that takes a value and returns the number doubled
22:24:39 <dramforever> jle`: bros knows node
22:24:52 <dramforever> so I guess I'll explain it as function(x) { blah blah }
22:24:53 <bros> dramforever: he's helping like crazy though
22:24:59 <bros> like curry
22:25:02 <bros> or a closure?
22:25:07 <dramforever> that's how #haskell works
22:25:11 <dramforever> bros: closure, yes
22:25:14 <jle`> yeah, (\x -> x * 2) is function(x) { return x*2; }
22:25:14 <bros> yeah, i'm really impressed
22:25:21 <bros> i would have been kicked out of any other channel
22:25:32 <jle`> so if you translate line 11 to node-speak, it'd be like
22:25:33 <dramforever> hmm...I think I know why
22:25:41 <ferdinand> lol
22:25:43 <jle`> modifyMVar(countRef, function(count) { .... } );
22:25:44 <bros> so it reads: lock variable countRef because of haskell's concurrency, and store in it the results of the entire lambda function
22:25:49 <bros> dramforever: lol why?
22:25:57 <dramforever> haskellers are not productive enough to have no time on irc =)
22:25:57 <jle`> that's basically a node translation of the syntax for lines 11-19
22:26:01 <jle`> lines 12-19 are the ....
22:26:06 <wei2912> dramforever: lol
22:26:21 <dramforever> by productive I mean something like lines per minute
22:26:34 <jle`> modifyMVar takes a function as its second argument, and we give it a function by doing (\count -> ....)
22:26:51 <bros> jle`: and modifyMVar just stores the return value of the function into the variable? in this case, countRef
22:27:17 <jle`> bros: yeah
22:27:23 <jle`> you can think of `countRef` as like a pointer
22:27:28 <bros> jle`: why does it return (count', responseReceived) and not just count'?
22:27:41 <lethjakman> template haskell seems risky...should I be cautious of it?
22:28:00 <jle`> check out the type of modifyMVar
22:28:07 <bitemyapp> lethjakman: how afraid are you of ASTs and macros?
22:28:07 <jle`> :t modifyMVar
22:28:08 <lambdabot> Not in scope: ‘modifyMVar’
22:28:09 <lethjakman> I'm looking at yesod, and I like a lot of the type safety it integrates into the system, but the template haskell seems a bit crazy. 
22:28:10 <jle`> oops
22:28:15 <jle`> anyays, it's in the docs for modiyMVar
22:28:18 <bitemyapp> lethjakman: oh as just an end-user?
22:28:18 <lethjakman> bitemyapp: not sure, I haven't used them much yet
22:28:22 <lethjakman> I'm still fairly new. 
22:28:26 <bitemyapp> lethjakman: I'd say it's not a big deal then if you don't even have to write the macros yourself.
22:28:27 <jle`> modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
22:28:40 <jle`> the docs say that it applies the function to "update" the mvar with the new a
22:28:47 <jle`> but the result of the action itself is the b you return
22:28:49 <lethjakman> yeah?
22:29:02 <lethjakman> how difficult are they to write safely?
22:29:26 <bros> jle`: ok. so it's sort of like passthrough, because application defines you need to return whatever responseReceived is typeof
22:29:27 <jle`> bros: the reesult of the entire "modifyMVar" command/action is the `b`, the second thing in the tuple
22:29:31 <bitemyapp> lethjakman: safely? it's still compile-time.
22:29:42 <jle`> and modifyMVar the command changes the mvar to have the value of the `a`, the first thing in the tuple
22:29:54 <bitemyapp> you're parsing an AST into whatever it is you're expecting structurally and failing the parser or generating something that doesn't type-check.
22:30:05 <bitemyapp> it's really not that spooky. People make too much out of it.
22:30:06 <bros> jle`: wow. we did it. we broke down warp's hello, world example. lol
22:30:08 <jle`> bros: yeah, and presumably responseReceived is something useful that `application` wants to know
22:30:27 <ferdinand> speaking of compile time, does anybody know how to do this https://gist.github.com/25cf/1c26e98368379453bc37
22:30:30 <bros> jle`: is run standard to haskell or probably an abstraction through the Warp/WAI package?
22:30:35 <lethjakman> bitemyapp: well...what I'm saying is it doesn't have types anymore right?
22:30:45 <jle`> that's a part of the warp/wai package
22:30:46 <lethjakman> it basically turns that part of haskell off for that file?
22:30:54 <jle`> it looks like it runs the application on port 3000
22:31:10 <bros> yeah, i was curious about what other magic it does
22:31:14 <bros> that allows for concurrency
22:31:38 <jle`> yeah, it's probablyhandled by run's implementation
22:31:55 <jle`> well, it looks like `run` takes what's basically a callback
22:32:02 <bitemyapp> lethjakman: that's a hard question to answer as it's not clear what "typed" means
22:32:04 <jle`> and runs it on every request
22:32:33 <bitemyapp> lethjakman: usually what people want when they say they want "typed" metaprogramming is something very powerful which makes macros that could generated code that isn't well-typed impossible (cf. the calculi developed for cpp)
22:32:36 <jle`> you can look into the type of `run` to see what kind of callback it is looking for
22:32:53 <bitemyapp> lethjakman: as it is, you're not entering a unityped twilight zone by using Template Haskell. You're folding an AST which is like 50% of what people in any Haskell code.
22:33:05 <jle`> the callback itself accesses a shared mutex-protected variable that's shared between all calls
22:33:07 <bros> jle`: https://gist.github.com/brandonros/e3dd3d6e0a7126345bbb better for beginners. is that correct though?
22:33:09 <bitemyapp> lethjakman: and if you're an end-user, you don't even write the fold. You just do as the docs tell you.
22:33:32 <jle`> bros: yea,h that's def a nice de-fancification
22:33:39 <jle`> you can combine the two let blocks though
22:33:44 <jle`> but yeah
22:33:49 <bros> jle`: do you have to use the let on line 12 or can line 13 be let msg = fromByteString "You are visitor number: " <> fromShow (count + 1)
22:34:03 <jle`> line 13 doesn't need the let as long as `msg` is indented to where `count'` is
22:34:08 <jle`> so it knows you're still in the same "let block"
22:34:15 <jle`> er, new_count
22:34:34 <jle`> honestly if i were writing it to be as readable as possible, i'd do something like
22:34:50 <jle`> application countRef = \_ respond -> do ....
22:34:52 <bros> jle`: https://gist.github.com/brandonros/57e199d78000074992fc ?
22:34:57 <jle`> so it's clear that "application countRef" is your callback
22:35:02 <jle`> and you call it with two parameters, _ and respond
22:35:38 <bros> jle`: how are you able to eat the second parameter matching?
22:35:42 <jle`> bros: replaced in the count+1's, right?  i'm nto sure if that's a more or less readable thing so it's up to your own personal things
22:35:49 <jle`> personal tastes
22:36:14 <jle`> "application countRef" takes two parameters, but _ is a wildcard so you don't bind it to any name
22:36:26 <jle`> applciation countRef = \x y -> do ...
22:36:36 <jle`> but if you don't care about x, it's idiomatic to leave it as _
22:36:45 <jle`> also you do'nt need the `do` there, actually...it's redundant and a little silly
22:36:49 <jle`> not sure why the original example had it
22:37:00 <bros> do you need either do?
22:37:12 <jle`> do is only used to sequence multiple actions, but that `application` only has one action, modifyMVar ...
22:37:17 <jle`> so you're not sequencing multiple things
22:37:22 <jle`> you don't need the first do, but you need the second do
22:37:40 <jle`> for the second thing you're sequencing "respond ..." and "return ..."
22:37:48 <lethjakman> bitemyapp: thanks for explaining that a bit better to me, I'm also curious because I'd like to try it at some point
22:38:12 <jle`> on line 16 you're sequencing "newMVar" and "run", so that's why the do block is there
22:38:35 <bros> can you sequence more than 2 calls per do?
22:38:37 <jle`> but on line 10 you're not squencing multiple actions, it's just one action, modifyMVar
22:38:40 <lethjakman> haskell metaprogramming could be interesting...
22:38:42 <jle`> yeah, you can sequence as much as you like
22:38:52 <lethjakman> but I kinda started doing haskell because I thought ruby's metaprogramming was getting too crazy
22:39:34 <jle`> main = do putStrLn "hello"; putStrLn "how are you"; putStrLn "okay goodbye"
22:39:40 <joco42_> can someone help my solve this cabal-install install mystery http://lpaste.net/136904 ? 
22:39:48 <joco42_> my=me
22:40:00 <bros> jle`: but haskell doesn't actually use semi-colons, right?
22:40:08 <jle`> you can use semicolons or newlines there
22:40:27 <Welkin> joco42_: add ~/.cabal to your path
22:40:29 <jle`> semicolons, or the layouting constructs based on newlines, indents, etc.
22:40:33 <Welkin> and reload your bash profile
22:40:39 <joco42_> Welkin: many thanks !
22:40:45 <Welkin> source ~/.bash_profile
22:41:02 <jle`> so line 16 can also be written as main = do visitorCount <- newMVar 0; run 3000 (application visitorCount)
22:41:21 <joco42_> Welkin: appreciated, thanks
22:41:23 <jle`> taking advantage of layouting instead of using semicolons is in general preferred
22:41:38 <bitemyapp> lethjakman: I find TH to be great fun, but YMMV. I don't have strong opinions on it as an end-user. If it makes it less hassle to make something well-typed - so be it.
22:41:45 <bitemyapp> lethjakman: cheers :)
22:42:23 <lethjakman> good to know!
22:42:50 <bros> jle`: everything is clear except \.
22:43:01 <bros> oh, i forgot. lambda.
22:43:14 <jle`> bros: yeah, (\x -> x * 2) is like function(x) { return x*2; }
22:43:17 <bros> MVars are like pointers with free locking, which is cool
22:43:23 <bros> \ is like callbacks
22:43:25 <jle`> yup, it's nice
22:43:55 <bros> i have this 30k line node.js project. i read people saying haskell ironically becomes easier/faster to write, but is that really true in your opinion?
22:43:58 <jle`> yeah, they're used for what callbacks are used for in typical javascript style
22:44:25 <jle`> in many cases haskell code writes itself faster for me and smoother
22:44:30 <jle`> because the types guide my implementation
22:44:42 <bros> it just takes a while to get to that point in skill?
22:44:59 <jle`> this actually comes relatively early i think
22:45:07 <bros> what's the hard part after this then? :/
22:45:12 <jle`> it's one of those more immediate gratification things from learning haskell
22:45:25 <jle`> there's no "hard part" realy, it's just always that there's always more you can learn haha
22:45:28 <jle`> you can never stop learning
22:45:31 <jle`> nobody's stopped learning
22:45:34 <bros> i'm not a huge fan of frameworks. it stinks that i have to use one with haskell. 
22:45:42 <bros> it'd be insane not to, right? for http server stuff
22:45:58 <jle`> yeah. but wai is less of a framework in the sense of rails, etc.
22:46:08 <jle`> i wouldn't call it a framework
22:46:17 <bros> yeah, yesod would be the framework there
22:46:18 <bros> i guess
22:46:19 <jle`> it's more like a library interfacing with http requests on the server side
22:46:35 <jle`> like, i blas to work with performant matrix operations in C/fortran
22:46:46 <jle`> it's a library, not a framework.  but the line is a bit blurry admittedly
22:47:51 <jle`> you probably use a library to work with dates and times and manipulating them/parsing them.  libraries, not frameworks
22:48:02 <jle`> you can implement date parsing and manipulation yourself, but why?
22:48:41 <bros> libraries, i'm all for. i just hate having to drink the koolaid of others. by the time i learn that specific koolaid
22:48:47 <bros> i could have learned something more reusable
22:48:51 <bros> are you a fan or angular or react?
22:48:55 <bros> might not be in your line of work
22:49:37 <jle`> i haven't been forced to use them so i can't comment either way, heh
22:49:56 <jle`> i like to do my own haskell mvc things though
22:50:33 <Welkin> angular, most certainly not
22:50:40 <bufferloss> angular sucks
22:50:42 <Welkin> that is a mess of mutable state
22:50:50 <bufferloss> react is pretty good
22:50:56 <Welkin> two-way data binding was a fad that passed long ago
22:51:16 <bufferloss> react is still growing and has some issues that need to be worked out, but it's got a solid conceptual paradigm behind it with flux
22:51:48 <Welkin> it seems many SoLoMo startups haven't gotten the message yet
22:52:03 <bufferloss> what's SoLoMo ?
22:52:11 <bros> bufferloss: would i sound crazy if i said i like dom spaghetti + jquery?
22:52:14 <Welkin> social, local, mobile
22:53:46 <bros> jle`: you have a database of preference?
22:55:15 <jle`> not really, i usually just stick with what i know, postgres heh
22:55:26 <Welkin> bros: the standard for relational data seems to be postgres
22:55:41 <bufferloss> postgres = win
22:55:42 <Welkin> for key-value stores there are tons of options
22:55:43 <bros> somebody told me to learn mongo so i did :/
22:55:50 <bros> Welkin: why wouldn't you use redis?
22:55:52 <Welkin> mongo is an abomination
22:56:03 <bros> I'll say a few good things about mongo
22:56:12 <bros> the aggregation framework allows me to do powerful stuff
22:56:27 <dirk103> what am i supposed to do with this literate .lhs file?
22:56:29 <bros> not having to add columns to tables is nice with the ORM i use and rapidly changing schema
22:56:47 <Welkin> it is even acid compliant
22:56:58 <Welkin> so anything else is moot
22:57:05 <wei2912> dirk103: just run it with ghci
22:57:13 <Welkin> dirk103: you can compile it like any other .hs file
22:57:21 <wei2912> dirk103: or ghc*
22:57:28 <bros> Welkin: you mean it isn't?
22:57:31 <dirk103> ok
22:57:36 <Welkin> bros: it is not
22:57:50 <bros> do people use that hackage acid-state package?
22:59:25 <dirk103> Could not find module `Data.Vector.Unboxed'
22:59:27 <dirk103> :O
22:59:35 <dirk103> a library i don't have installed?
23:00:13 <bufferloss> bros, I think the better questions are: is it mature, is it well maintained, does it fit your requirements?
23:00:38 <bufferloss> bros, usually the first two go hand in hand with how many people use it
23:00:41 <ttt_fff> is there a way to tell cabal :yo, run ghc compiles in parallel 
23:00:55 <Welkin> dirk103: check by typing into ghci: import Data.Vector.Unboxed
23:01:03 <bufferloss> if no one uses something then the maintainer is probably less likely to provide timely updates
23:01:11 <Welkin> ttt_fff: use -j
23:01:36 <ttt_fff> Welkin: -j is unreconigzed to 'cabal compile"
23:01:51 <Welkin> oh, I don't know about `cabal compile`
23:01:54 <Welkin> never used that
23:02:00 <ttt_fff> well
23:02:05 <ttt_fff> how else do you tell cabal to compie? :-)
23:02:09 <Welkin> you mean cabal build?
23:02:13 <ttt_fff> sure
23:02:24 <ttt_fff> cabal build
23:02:25 <ttt_fff> sorry
23:11:15 <haskelltroll> AMA
23:11:16 <funfunctor> Hi
23:11:19 <haskelltroll> Hi
23:19:18 <wei2912> haskelltroll: did you know that haskell trolls are non-existant?
23:19:44 <haskelltroll> wei2912: are you hallucinating?
23:20:32 <arahael> haskelltroll: it is more likely you're confused.  have you spoken to your therapist lately?
23:26:18 <haskelltroll> trolling is ahrd when no one is asking questions
23:28:43 <slack1256> specially when is 4AM
23:30:56 <zipper> Hey you guys. Would you say opt-parse is the easiest/best lib to use for parsing of command line args?
23:31:56 <zipper> :t (<>)
23:31:57 <rowanblush> zipper: optparse-applicative?
23:31:57 <lambdabot> Monoid m => m -> m -> m
23:32:02 <slack1256> if you are willing to user deriving (Data) then cmdargs is also pretty easy
23:32:18 <slack1256> *use
23:32:22 <zipper> slack1256: I want to keep complexity at a minimum.
23:32:32 <haskelltroll> use parsec
23:32:54 <slack1256> a noble goal indeed, optparse-applicative seems to get good rap. Also you could check hackage reverse dependencies to see what is popular now
23:34:48 <zipper> slack1256: Hackage reverse dependencies?
23:36:06 <zipper> :t execParser
23:36:07 <lambdabot> Not in scope: ‘execParser’
23:36:24 <slack1256> zipper: http://packdeps.haskellers.com/reverse I don't know how up to date it is. 
23:36:54 <slack1256> it gives you a way to see how "popular" a library is by metric of how many libraries use it
23:41:42 <dbushenko> hi all!
23:42:57 <wei2912> HI dbushenko, need any help?
23:43:14 <dbushenko> indeed
23:43:22 <dbushenko> trying to understand how the monad reader works
23:43:30 <dramforever> dbushenko: next time ask your question right away =)
23:43:42 <dramforever> dbushenko: the magzine-ish thing?
23:43:44 <dbushenko> I just wanted to be polite :-)
23:43:51 <dbushenko> no, the monad
23:43:56 <dramforever> okay
23:43:58 <haskelltroll> hi!
23:44:01 <haskelltroll> were very helpful here
23:44:07 <haskelltroll> ask away
23:44:07 <dbushenko> can't understand what does (runReader m r) do in the monad source
23:44:17 <dramforever> dbushenko: "hi all!" then your question is polite enough =)
23:44:24 <haskelltroll> runReader (Reader a) r will run a reader monad with intial state r
23:44:24 * dramforever goes to read monad source
23:45:01 <dbushenko> I mean, m -- is (Reader r), then (runReader m) should return some value a
23:45:20 <dramforever> (Reader r a), not (Reader r)
23:45:21 <dbushenko> but applying a value a to environment r -- is weird
23:45:50 <dramforever> runReader :: Reader r a -> r -> a
23:45:59 <dramforever> are you trying understand this function?
23:46:01 <dbushenko> f*ck...
23:46:09 <dbushenko> yes, thanks
23:46:13 <haskelltroll> so much for politeness
23:46:18 <dramforever> lol
23:46:27 <dbushenko> haha! :-)
23:46:40 <dramforever> well the * is pretty polite =)
23:46:48 <wei2912> *!*!*@@**@!*@!*@
23:46:52 <dbushenko> thanks anyway, I need to continue thinking... you were very helpful!
23:47:10 <haskelltroll> yeah, the * makes f*ck completely ambigious, it would be fack, feck, fick, fock, or fyck
23:47:14 <dramforever> #haskell is helpful
23:47:45 <wei2912> haskelltroll: * matches zero or more characters, so it could be flick too
23:47:50 <dbushenko> no, wait
23:47:55 <dbushenko> it is runReader :: r -> a in the source code
23:48:04 <dbushenko> not runReader :: Reader r a -> r -> a
23:48:24 <dramforever> dbushenko: oh it's record syntax
23:48:41 <dbushenko> can you explain?
23:48:42 <julianleviston> is there a function that takes a pair and emits a function? (ie (a,b) -> (a -> b))
23:48:50 <arkeet> newtype Reader r a = Reader { runReader :: r -> a }
23:48:50 <dramforever> @let data X = X { getX :: Int }
23:48:51 <lambdabot>  Defined.
23:48:54 <dramforever> :t getX
23:48:55 <lambdabot> X -> Int
23:49:10 <arkeet> defines a data type Reader, a constructor Reader :: (r -> a) -> Reader r a, and a field accessor runReader :: Reader r a -> (r -> a)
23:49:32 <dbushenko> ah, now its clear
23:49:38 <dbushenko> many thanks! :-)
23:49:56 <wei2912> julianleviston: what do you want the function to be?
23:50:12 <wei2912> i doubt any such function exists, seems to be very specific to a usecse
23:50:15 <wei2912> usecase*
23:50:16 <julianleviston> or… put another way, if I have this function: ((,) . Just) and I wanted to feed it a pair as an input (which is impossible) what would I need in between it and the pair? So that I can have it point-free?
23:50:20 <wei2912> and, got to go now. bye
23:50:26 <julianleviston> wei2912: hehe ok
23:50:34 <dramforever> julianleviston: your question doesn't make sense, but there such exists a function
23:50:38 <dramforever> but it's boring
23:50:46 <dramforever> @djinn (a, b) -> a -> b
23:50:46 <lambdabot> f (_, a) _ = a
23:50:59 <julianleviston> oh
23:50:59 <dramforever> :t ((,) . Just)
23:51:01 <lambdabot> a -> b -> (Maybe a, b)
23:51:21 <dramforever> julianleviston: hey there's a function in prelude called uncurry
23:51:23 <dramforever> :t uncurry
23:51:24 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:51:27 <julianleviston> I have a list of pairs (x,y) and I want a list of (Just x, y)
23:51:47 <julianleviston> dramforever: I already have this: ex (x,y) = (Just x, y)
23:52:01 <julianleviston> dramforever: but I was curious as to whether I could express it point-free style.
23:52:23 <dramforever> :t map (\(x, y) -> (Just x, y))
23:52:24 <lambdabot> [(a, t)] -> [(Maybe a, t)]
23:52:29 <julianleviston> dramforever: yep.
23:52:38 <julianleviston> dramforever: that’s what my function does already.
23:52:56 <julianleviston> dramforever: but I was wondering if I could express it in point-free style?
23:52:57 <dramforever> so map ex is what you want, right?
23:53:02 <julianleviston> dramforever: yep.
23:53:22 <Iceland_jack> > over (mapped._1) Just [('a', "apple"), ('b', "banana"), ('c', "candy")]
23:53:23 <julianleviston> dramforever: and I got as far as ((,) . Just) but then realised that won’t take pairs
23:53:23 <lambdabot>  [(Just 'a',"apple"),(Just 'b',"banana"),(Just 'c',"candy")]
23:53:39 <dramforever> julianleviston: uncurry
23:53:41 <dramforever> :t uncurry
23:53:42 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:53:46 <julianleviston> Iceland_jack:  oh wow thank you!
23:54:12 <julianleviston> dramforever: thanks I’ll lokk
23:55:50 <Iceland_jack> julianleviston: If you later want to operate on the values you can write
23:55:50 <Iceland_jack> > over (mapped._1._Just) (\x -> [x]) [(Just 'a',"apple"),(Just 'b',"banana"),(Just 'c',"candy")]
23:55:51 <lambdabot>  [(Just "a","apple"),(Just "b","banana"),(Just "c","candy")]
23:56:00 <Iceland_jack> julianleviston: If you later want to operate on the values you can write
23:56:00 <Iceland_jack> > over (mapped._1._Just) (\x -> [x,x,x]) [(Just 'a',"apple"),(Just 'b',"banana"),(Just 'c',"candy")]
23:56:01 <lambdabot>  [(Just "aaa","apple"),(Just "bbb","banana"),(Just "ccc","candy")]
23:56:13 <Iceland_jack> didn't meant to post twice
23:56:47 <julianleviston> Iceland_jack: I’ll go look into over and mapped._1. which I’m really not familiar with.
23:56:51 <Iceland_jack> or more generally
23:56:52 <Iceland_jack>     mapped._1.traverse
23:57:07 <dramforever> julianleviston: that's lens
23:57:08 <Iceland_jack> julianleviston: If you're a beginner the other solution is better
23:57:16 <julianleviston> ah.
23:57:21 <dramforever> and it's actually two functions, mapped composed with _1
23:58:01 <Iceland_jack> julianleviston: But it's good to know that something like that ('lens') exists, for the future
23:58:28 <julianleviston> Iceland_jack: yeah, well I need to learn some lens libarary stuff soon because I’ll be using it when I get into Snap.
