00:00:03 <yayfoxes> i'm doing this to learn and it's not an assignment
00:00:19 <adarqui> i remember that from yorhey's online class
00:00:23 <nkaretnikov> yayfoxes: well, you need to show what you've already tried
00:00:24 <adarqui> yorgey
00:00:48 <yayfoxes> i haven't tried
00:00:55 <nkaretnikov> why?
00:01:02 <yayfoxes> so I need to know what to read so that i may have a good try
00:01:18 <adarqui> the class says what you need to read..
00:01:19 <nkaretnikov> yayfoxes: do you know how to solve it in a different language?
00:01:20 <yayfoxes> like i don't understand the math aspect of it
00:01:31 <yayfoxes> nkaretnikov: no sir
00:01:34 <adarqui> it has lecture notes and i think it says to read chapter 1/2 of real world haskell and learn you a haskell..
00:01:41 <yayfoxes> ok
00:02:17 <yayfoxes> but yes, how do I learn the math aspect of it?
00:02:28 <yayfoxes> I can go to khan academy
00:02:39 <yayfoxes> I need to study math, I believe
00:02:42 <nkaretnikov> yayfoxes: I guess you need to ask a more direct question
00:02:48 <adarqui> what specifically? there's not much math too it imho
00:02:50 <nkaretnikov> what do you find challenging?
00:03:13 <frerich> yayfoxes: You do not need to know any math other than addition of integers.
00:03:13 <yayfoxes> ok, what if i wanted to implement toDigits which turns 1234 into [1,2,3,4]?
00:03:26 <yayfoxes> frerich: ok thanks
00:03:35 <yayfoxes> I shall read those books then
00:04:00 <nkaretnikov> yayfoxes: do you know how to turn 1 into [1]?
00:04:01 <frerich> yayfoxes: Ok, for splitting an integer into its digits, it might be useful to be able to divide integers, too (but you don't need it ;-)
00:04:25 <yayfoxes> nkaretnikov: yes, do 1 : []
00:04:35 <nkaretnikov> okay, what about 12?
00:04:47 <dramforever> IMHO you proabably don't need math stuff you don't know
00:04:47 <pacak> > (const [1]) 12
00:04:49 <lambdabot>  [1]
00:04:50 <yayfoxes> 1 : 2 : [] or [1,2]
00:04:54 <pacak> I know :)
00:05:05 <pacak> It can turn ANYTHING into [1]!
00:05:10 <dramforever> because you either 1. don't have enough time/energy/... etc to learn
00:05:12 <yayfoxes> let's test my function application skills
00:05:24 <dramforever> 2. don't have to use it because someone else wrote a library
00:05:33 <nkaretnikov> yayfoxes: no, I said 12, not 1 and 2.
00:05:40 <dramforever> lens is an interesting example of 2.
00:05:51 <pacak> :t ana
00:05:52 <yayfoxes> so, you want to recursively call your function to turn just one more digit into it's own list item
00:05:53 <lambdabot>     Not in scope: ‘ana’
00:05:53 <lambdabot>     Perhaps you meant one of these:
00:05:53 <lambdabot>       ‘and’ (imported from Data.List), ‘any’ (imported from Data.List),
00:05:56 <pacak> :(
00:06:28 <nkaretnikov> yayfoxes: there's also a way to cheat
00:07:25 <yayfoxes> nkaretnikov: cheat by using modulus 10 and  taking tht
00:07:33 <nkaretnikov> no
00:07:38 * hackagebot pipes-cellular 0.0.0.1 - Pipes-based combinators for cellular data processing  http://hackage.haskell.org/package/pipes-cellular-0.0.0.1 (patrykz)
00:07:38 * hackagebot pipes-cellular-csv 1.0.0.0 - Efficient pipes-based cellular CSV codec  http://hackage.haskell.org/package/pipes-cellular-csv-1.0.0.0 (patrykz)
00:07:44 <nkaretnikov> that's not what I meant
00:08:04 <nkaretnikov> yayfoxes: convert the argument to something else and work with that
00:08:17 <frerich> yayfoxes: Using modulus 10 to extract a digit would actually be a very plausible and legit approach.
00:08:25 <adarqui> mathy way is more fun than converty way
00:08:43 <pacak> > reverse $ unfoldr  (\x -> if x == 0 then Nothing else Just $ swap $ x `divMod` 10) 1234
00:08:44 <lambdabot>  [1,2,3,4]
00:08:48 <dramforever> > map (read . pure) . show :: Int -> [Int] -- the sstream way
00:08:50 <lambdabot>  <Int -> [Int]>
00:09:03 <dramforever> > (map (read . pure) . show :: Int -> [Int]) 1234 -- the sstream way
00:09:05 <lambdabot>  [1,2,3,4]
00:09:32 <yayfoxes> frerich: but then what am I missing in my quest to solve this assignment?
00:09:50 <yayfoxes> i must try now and get back with you later
00:09:55 <yayfoxes> because we don
00:10:05 <yayfoxes> don't know what I am missing yet
00:11:04 <adarqui> ya you havn't even tried yet, lul
00:11:22 <nkaretnikov> yayfoxes: can you do it on paper?
00:11:29 <nkaretnikov> yayfoxes: like step by step
00:11:46 <yayfoxes> I can try
00:12:40 <frerich> yayfoxes: You're missing a definition for the function 'toDigits :: Integer -> [Integer]' and thinking about how to do that is exactly the point of the exercise. If you have a more specific question about how to tackle some sub-problem, feel free to ask about that.
00:12:54 * dramforever thinks you need some math skills like equational reasoning for haskell, but it's the same for any programming language
00:12:55 <frerich> yayfoxes: I think doing something which involves modulo 10 sounds good.
00:12:57 <ttt_fff> does studying forth make one a better haskell programmer? if so, how?
00:13:22 <dramforever> ttt_fff: yes, you can learn to make an interpreter :P
00:13:27 <dramforever> kidding
00:13:33 <pacak> yayfoxes: It's a simple anamorphism.
00:13:48 <ttt_fff> besides "how to write a forth interpreter", does studying forth make one a better haskeller?
00:13:51 <frerich> yayfoxes: Note that the exercise says that for non-positive numbers the function should yield an empty list. So you could start with that - distinguishing positive from non-positive numbers.
00:13:56 <ttt_fff> I'm tryign to understnad the value of this point-free concatative style
00:14:17 <ttt_fff> on one hand, it forces intense modularity, since you can't keep track of too compilicated things on the stack
00:14:22 <ttt_fff> on the other hand ... only verbs? wtf
00:14:23 <dramforever> ttt_fff: it looks like a pretty good intermediate language
00:14:31 <nkaretnikov> yayfoxes: I'll give you another hint.  are there any operations there that you could use?  https://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html
00:14:46 <yayfoxes> nkaretnikov: wow  thanks!
00:15:23 <dramforever> nkaretnikov: wow that's a long list
00:16:03 <nkaretnikov> well, otherwise, I'd just revealed a solution
00:16:16 * dramforever misses the synopsis thing in old haddocks
00:16:53 <dramforever> basically just all the names and types listed together
00:18:09 <nkaretnikov> yayfoxes: how good are you with haskell?  it may be difficult because you're just getting confused by a lot of new things (function names, syntax, etc.)
00:18:36 <nkaretnikov> yayfoxes: can you solve, say, the first five problems from the the 99 haskell problems set?
00:18:54 <nkaretnikov> yayfoxes: can you implement the reverse function?
00:18:55 <dramforever> nkaretnikov: I used to ask this often. it's very hard to get a good answer
00:19:09 <adarqui> the worst thing to do with haskell is to rush it without learning the basics
00:19:12 <adarqui> i speak from experience
00:19:34 <nkaretnikov> I couldn't write pretty much anything while I was reading lyah
00:19:41 <dramforever> adarqui: exactly, I saw someone on reddit /r/haskellquestions ask about his/her code
00:20:07 <dramforever> filled with something like if ... then do return f(x, y) + g(z)
00:20:35 <dramforever> (s)he must think "oh haskell must be like any other language"
00:21:54 <adarqui> yup
00:23:44 <catsup> ttt_fff: on the vale of the concatative style...  http://www.vex.net/~trebla/weblog/pointfree.html
00:24:01 <adarqui> i found an effective technique for me at least.. trying to avoid blogs/examples/tutorials etc.. instead, i just grab all of the code locally and sift through it. so for example i have ghc/base, every repo from bos/and tons of others etc.
00:24:34 <dramforever> adarqui: I thinks blogs/examples/... are pretty useful
00:24:44 <dramforever> I believe that some day they will all fall into place
00:24:52 <yarou> this discussion about haskell pedagogy is truly fascinating
00:24:58 <dramforever> lol
00:25:08 <yarou> enlighten me on the one true(tm) way to learn Haskell
00:25:53 <dramforever> "there's no royal road to haskell"
00:26:29 <yayfoxes> is there a null in Haskell? i've heard of Maybe and Just but don't know how to use them or what they are for
00:26:31 <adarqui> where do you get "one true way" from the discussion?
00:26:52 <catsup> yayfoxes: Nothing (from Maybe) is like null
00:27:11 <catsup> yayfoxes: but it is very different from null in other languages
00:27:31 <dramforever> yayfoxes: they are for replacing null to be explicit :)
00:27:43 <dramforever> with failures
00:27:47 <dramforever> for example:
00:28:16 <yayfoxes> how would you write last if this doesn't make any sense?
00:28:22 <yayfoxes> myLast (x:[]) = x
00:28:24 <yayfoxes> myLast (x:ys) = myLast ys
00:28:52 <dramforever> why? it makes sense to me
00:29:00 <pacak> yayfoxes: Looks OK, you can write first pattern as [x]
00:29:06 <catsup> well it thros an exception on an empty list
00:29:14 <pacak> > last []
00:29:15 <lambdabot>  *Exception: Prelude.last: empty list
00:29:19 <jle`> you can have it return Maybe
00:29:26 <jle`> if that's what you're getting at
00:29:31 <jle`> last :: [a] -> Maybe a
00:29:34 <jle`> last [] = Nothing
00:29:38 <pacak> @hackage acme-safe
00:29:38 <lambdabot> http://hackage.haskell.org/package/acme-safe
00:29:39 <jle`> last [x] = Just x
00:29:44 <dramforever> okay prepend myLast [] = error "fine"
00:29:48 <yayfoxes> catsup: how do I make mine throw an exception if it finds an empty list?
00:29:51 <jle`> last (_:xs) = last xs
00:29:59 <dramforever> yayfoxes: look
00:30:08 <catsup> yayfoxes: yo already did, by not specifying a reslut for empty list
00:30:09 <dramforever> > error "My Own Exception"
00:30:10 <lambdabot>  *Exception: My Own Exception
00:30:29 <jle`> keep in mind that error in haskell is a bit different than error in other languages
00:30:35 <pacak> :t Acme.Safe.safeFromJust
00:30:35 <catsup> you don't want the exception though
00:30:36 <lambdabot> Not in scope: ‘Acme.Safe.safeFromJust’
00:30:40 <dramforever> @let data MyException = MyException deriving (Show, Typeable, Exception)
00:30:42 <lambdabot>  .L.hs:144:44:
00:30:42 <lambdabot>      Can't make a derived instance of ‘Exception MyException’:
00:30:42 <lambdabot>        ‘Exception’ is not a derivable class
00:30:52 <gfixler> jle`: http://lpaste.net/136083
00:30:52 <dramforever> @let data MyException = MyException deriving (Show, Typeable)
00:30:54 <lambdabot>  Defined.
00:30:59 <jle`> but yeah, if we return it in a Maybe, then what we have is now that the compilar can check that our implementation is "correct"
00:31:01 <dramforever> @let instance Exception MyException
00:31:01 <jle`> and doesn't error
00:31:02 <lambdabot>  Defined.
00:31:08 <dramforever> > throw MyException
00:31:10 <lambdabot>  *Exception: MyException
00:31:15 <gfixler> jle`: that compiled, and then I passed out
00:31:20 <jle`> gfixler: congrats :D
00:31:27 <gfixler> jle`: but is it right?
00:31:32 <jle`> yeah
00:31:33 <gfixler> (ugly is a separate matter)
00:31:35 <gfixler> cool
00:31:39 <gfixler> jle`: I used holes to find it
00:31:44 <jle`> haha nice
00:31:50 <gfixler> and a lot of head-scratching
00:31:57 <gfixler> I'm really liking holes
00:31:58 <jle`> a lot of people like to use record accessors instead of pattern matching, but that's a style choice
00:32:15 <jle`> but yeah, you see what it sort of is doing, right?
00:32:24 <gfixler> jle`: so is this like a manual monad transformer?
00:32:25 <jle`> it executes the first action, and "goes on" if the first action returns a Just, and stops otherwise
00:32:42 <jle`> you can think of it as a monad transformer, or you can think of it as a newtype of IO (Maybe a) that just happens to have a Monad instance
00:33:00 <jle`> it might also be fun to write the Applicative instance...and interesting/fun to write the Alternative instance
00:33:00 <gfixler> can all monad transformers be thought of in such ways?
00:33:12 <jle`> that is my belief
00:33:25 <jle`> you get more than just a new monad instance, you also get a neat new Alternative instance, if you want to think about it
00:33:26 <gfixler> hmmm, I still don't really know what to do with this thing, though
00:33:33 <jle`> (<|>) :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a)
00:33:41 <gfixler> oh, that Alternative
00:33:42 <jle`> the Alternative instance is supa useful in lots of cases
00:33:50 <gfixler> I used it for bowling
00:33:51 <jle`> because you can use asum on a [IO (Maybe a)]
00:34:01 <jle`> and basically "sequence until you get the first Just"
00:34:02 <yayfoxes> lul guys i don't even have  ghc installed
00:34:06 <jle`> because asum will give the first Just value
00:34:12 <jle`> asum for Maybe, that is
00:34:14 <gfixler> https://gist.github.com/gfixler/9bb742b1fa92afa04a42
00:34:22 <adarqui> yayfoxes: :(
00:34:23 <jle`> but asum for IO (Maybe a) will give you the result of the first Just action
00:34:35 <jle`> gfixler: yup that one :)
00:34:48 <yayfoxes> adarqui: although it's downloading haskell platform at 1,827KB/s
00:35:04 <gfixler> jle`: I keep redoing the bowling thing, trying to find new ideas
00:35:11 <jle`> findM f [x,y,z], which people say, "execute f on x, y, z...until you find the first thing that returns Just"
00:35:21 <gfixler> jle`: oh, nice
00:35:26 <nkaretnikov> yayfoxes: you can pm lambdabot and try there
00:35:30 <jle`> findM :: (a -> IO (Maybe b)) -> [a] -> IO (Maybe b)
00:35:38 <jle`> but you can just implement this using Alternative/asum
00:35:38 <gfixler> jle`: I want something like a big cookbook of these use-cases
00:35:40 <dramforever> nkaretnikov: you can start ghci :P
00:35:46 <adarqui> cool yayfoxes. make sure you have read Prelude if you havn't already
00:35:47 <gfixler> lots of learning through useful examples
00:35:47 <jle`> findM f [x,y,z] = f x <|> f y <|> f z
00:35:59 <jle`> which makes sense, right?  Alternative just "finds the first okay choice", so to speak
00:36:00 <nkaretnikov> dramforever: yayfoxes doesn't have ghci yet
00:36:10 <dramforever> nkaretnikov: oh okay
00:36:13 <gfixler> jle`: yeah, it feels like if-then-else to me
00:36:25 <funfunctor> Hi
00:36:28 <jle`> yeah, so with your newtype wrapper over IO (Maybe a), you get a very useful Alternative instance, too
00:36:43 <jle`> Monads are just one part of the picture
00:36:46 <gfixler> jle`: the question is - how do I use the IO bit, and the Maybe bit?
00:36:49 <yayfoxes> nkaretnikov: I just installed it lol
00:36:56 <gfixler> jle`: and is that even a sensible question?
00:37:01 <jle`> well, if you have an IO a, you can write a function IO a -> MaybeIO a
00:37:09 <jle`> and if you have a Maybe a, you can write a function Maybe a -> MaybeIO a
00:37:12 <nkaretnikov> yayfoxes: in general, exceptions should be avoided in haskell.  especially in this particular function since there's no downside of making it pure
00:37:15 <jle`> and then you're "good to go"
00:37:22 <jle`> this is Tekmo's "functor design pattern"
00:37:31 <gfixler> jle`: yeah, I was thinking of such functions as 'lifts'
00:37:34 * hackagebot bytestring-conversion 0.3.1 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.3.1 (ToralfWittner)
00:37:40 <gfixler> Tekmo, the game company?
00:37:43 <jle`> yeah.  the first one is typically called a lift, and the second one is typically called a hoist
00:37:48 <jle`> Tekmo as in gabriel gonzalez
00:37:53 <nkaretnikov> jle`: are there haskell design patterns now? :(
00:37:59 <gfixler> ah, I didn't know his pen name
00:38:09 <jle`> it's his freenode nick, heh
00:38:12 <catsup> https://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/
00:38:16 <funfunctor> So I am making a REPL for something that has a whole bunch of commands that essentially do system POSIX level stuff. I am trying to think up a core design for/and around the IO monad for hooking up new subcommands. In C I would create struct's with a name and handler function pointer fields. Wondering where to start for a Haskell sort of design
00:38:17 <gfixler> what's the diff between a lift and hoist?
00:38:27 <yayfoxes> nkaretnikov: but just I do "myLast [] = []" and ghci complains
00:38:33 <gfixler> funfunctor: sweet - have you looked at Turtle?
00:38:38 <gfixler> (which I believe is by Tekmo)
00:38:39 <adarqui> turtle is dope
00:38:53 <funfunctor> gfixler: I think so a long while ago
00:38:55 <adarqui> filemanip is dope too
00:38:59 <funfunctor> let me check again
00:39:08 <adarqui> are there any tekmo chans for his libs?
00:39:14 <gfixler> I just found kmett's zippers thing today, too
00:39:14 <yayfoxes> funfunctor: is it going to be FOSS?
00:39:16 <Itkovian> Does anybody have experience with using Criterion for analysis performance data obtained from another source?
00:39:16 <jle`> gfixler: in the context of monad transformers, a lift turns a value in a "wrapped" monad into a value in the transformed monad, and a hoist swaps out the wrapped monad with another one
00:39:22 <gfixler> I was playing with Data.List.Zipper before
00:39:30 <Itkovian> Say, analyse ds where ds are performance numbers?
00:39:30 <jle`> but it's not really a formal/important thing
00:39:51 <gfixler> jle`: that's going to take a minute to get into my brain
00:39:57 <jle`> also lift literally has a thousand different meanings in haskell
00:39:58 <nkaretnikov> yayfoxes: how does it complain?
00:40:05 <nkaretnikov> yayfoxes: ah, ghci
00:40:06 <jle`> so it's not really an important bit of terminology, heh
00:40:09 <nkaretnikov> you need to put let in front of it
00:40:10 <gfixler> jle`: does haskell even lift?
00:40:13 <jle`> bro
00:40:15 <jle`> :t lift
00:40:16 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
00:40:19 <nkaretnikov> yayfoxes: type it into a file and load that instead
00:40:29 <tdammers> do you even fmap?
00:40:29 <nkaretnikov> yayfoxes: ghci can be confusing if you're not used to it
00:40:34 <jle`> :t lift even
00:40:35 <lambdabot> (Integral a, MonadTrans t) => t ((->) a) Bool
00:40:42 <yayfoxes> [1 of 1] Compiling Main             ( mylast.hs, interpreted )
00:40:47 <yayfoxes>     Couldn't match expected type ‘a’ with actual type ‘[t0]’
00:41:10 <glaukon> specialWord :: Parser String
00:41:16 <adarqui> olympicLiftM
00:41:20 <glaukon> specialWord = do
00:41:27 <funfunctor> yayfoxes: first it needs to exist ;)
00:41:31 <glaukon> 	 word <- many1 letter
00:41:43 <jle`> gfixler: but yeah, the 'functor design pattern' is basically, pick a mega-type that sort of offers everything that you want, and then write computation in their smaller type that you can 'lift'/'map' into your mega type, so now you can use all the smaller types as if they were your big type
00:41:47 <glaukon> 	 if thereIsSomethingSpecialAbout word then return word else failSomehow
00:42:16 <gfixler> jle`: that's what I guessed, but I think it'll be awhile, and a lot of playing before it really makes any sense
00:42:17 <funfunctor> gfixler: ok that is useful but my solution is for a different use case, I have my own custom parser in the REPL with my own dialect
00:42:17 <jle`> so if your computation is in MaybeIO, then write IO a -> MaybeIO a's, and write Maybe a -> MaybeIO a's, and now you can use Maybe's, IO's, etc. in your MaybeIO a
00:42:22 <glaukon> How do I failShowhow in the Parsec parser?
00:42:55 <gfixler> funfunctor: cool - I've been wanting a design tool with a memory and pronouns
00:43:11 <quchen2> glaukon: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html#v:parserFail
00:43:13 <yayfoxes> funfunctor: see that's an empty list with no type "a" as a single item but an empty list
00:43:22 <gfixler> jle`: that could be a good next thing for me to try
00:43:23 <lamefun> Cabal = dead, stack = future?
00:43:34 <gfixler> i.e. to use this monster I've assembled for something
00:43:49 <jle`> heh, yeah
00:44:06 <jle`> anyways try writing the Alternative instance, it might help you sort of "see" what the semantics of the type sort of are
00:44:19 <jle`> and you get more than just a neat Monad instance out of this newtype
00:44:21 <funfunctor> lamefun: cabal = fedora , stack = centos  afaik
00:44:38 <gfixler> jle`: I'm still trying to remember the order of Maybe and IO in the name - it won't stick!
00:44:44 <gfixler> MaybeIO? IOMaybe?
00:44:48 <funfunctor> yayfoxes: sorry?
00:44:54 <AshyIsMe> i like the idea of stack sharing dependencies when it can
00:45:10 <funfunctor> gfixler: design tool?
00:45:11 <AshyIsMe> sandboxes can be annoying on my little macbook when it decides "lol let's recompile everythnig again"
00:45:25 <yayfoxes> funfunctor: it would return a single item from the end of the list. in the case of an empty list it's not a single item so it fails to compile
00:45:26 <gfixler> funfunctor: e.g. for 2d vector or 3d mesh work
00:45:31 <funfunctor> gfixler: the idea is to have something not unlike this https://github.com/yellowman/nsh
00:46:01 <gfixler> funfunctor: ah, networking stuff - the black hole in my knowledge
00:46:41 <funfunctor> yayfoxes: are you saying, put everything in the REPL into a list of type :: [IO a], I don't understand what your getting at?
00:46:41 <lamefun> funfunctor: why is stack a complete build tool instead of being simply a profile for cabal then?
00:46:47 <gfixler> AshyIsMe: let's just switch to NixOS. I've been wanting to for a while now.
00:47:08 <funfunctor> lamefun: deployment made easier perhaps?
00:47:23 <yayfoxes> funfunctor: oh i guess I need to pastebin the code and the error message
00:47:57 <funfunctor> gfixler: don't worry about the network aspect.. My interest is purely about how to hook IO action primitives (subcommands) into some kind of easy to work with structure in the main REPL context
00:48:26 <funfunctor> yayfoxes: which code? :)
00:48:27 <yayfoxes> http://vpaste.net/ySxur
00:49:03 <AshyIsMe> gfixler: yeah i tried to a few months back but the binary caches for osx weren't set up yet so it didn't help me with the recompiling the world problem at the time
00:49:18 <yayfoxes> funfunctor: I want to go to bed though
00:49:27 <gfixler> AshyIsMe: yeah, I'm worried about the switch - might try it out soon on my laptop, which I don't use often
00:49:29 <yayfoxes> I'm tired
00:49:44 <funfunctor> yayfoxes: ok... myLast (_:ys) = myLast ys  is the line, ys has a different type than you are expecting here
00:50:01 <AshyIsMe> gfixler: oh you meant full nixos, i just tried nix on osx
00:50:09 <gfixler> yayfoxes: I think it doesn't like [] = [], when the type [a] -> a
00:50:21 <frerich> gfixler: Seems that 'Roll' isn't used in https://gist.github.com/gfixler/9bb742b1fa92afa04a42 yet. I'm not really familiar with bowling, but shouldn't that serve as some sort of fallback?
00:50:26 <yayfoxes> gfixler: exactly.
00:50:43 <funfunctor> yayfoxes: your code does not make a huge amount of sense..
00:50:48 <yayfoxes> i'm heading to bed
00:51:00 <gfixler> yayfoxes: ah, that's the problem everyone was talking about earlier - I caught up
00:51:04 <gfixler> night
00:52:49 <gfixler> @let myLast = foldr1 (flip const)
00:52:51 <lambdabot>  Defined.
00:52:53 <gfixler> myLast [1,2,3,4]
00:52:56 <gfixler> > myLast [1,2,3,4]
00:52:58 <lambdabot>  4
00:53:26 <merijn> w00t
00:53:35 <merijn> Explicit dependencies for Setup.hs :D
00:54:46 <frerich> Sometimes #haskell is as if you need help with slicing bread and then you accidentally walk into a sushi bar and all the chefs start showing off 101 ways to slice a bread, most of which are so dangerous that mere mortals most certainly want to stay from actually *using* that method.
00:55:26 <gfixler> frerich: that's what happens in wizard school
00:55:40 <gfixler> we all wave our wands - someone's going to lose an eye, or light on fire
00:56:33 <merijn> frerich: It's a good way to learn from people better than you, though :)
00:58:40 <sccrstud92_> > [1,2,3,4] ^.. backwards traverse
00:58:41 <lambdabot>  [4,3,2,1]
00:58:46 <sccrstud92_> > [1,2,3,4] ^? backwards traverse
00:58:48 <lambdabot>  Just 4
00:58:57 <sccrstud92_> > [1,2,3,4] ^?! backwards traverse
00:58:58 <lambdabot>  4
00:59:05 * dramforever is trying to implement a logical language, and is reading about minikanren
00:59:08 <dramforever> wtf
00:59:09 <gfixler> is this lens?
00:59:16 <sccrstud92_> yes
00:59:33 <gfixler> is ^?! the Q*Bert operator?
00:59:49 <adarqui> @type ^?!
00:59:50 <lambdabot> parse error on input ‘^?!’
00:59:54 <adarqui> @type (^?!)
00:59:55 <lambdabot> s -> Getting (Endo a) s a -> a
00:59:56 <sccrstud92_> :t (<<@%~)
00:59:57 <lambdabot>     Not in scope: ‘<<@%~’
00:59:57 <lambdabot>     Perhaps you meant one of these:
00:59:57 <lambdabot>       ‘<<%@~’ (imported from Control.Lens),
01:00:02 <sccrstud92_> :t (<<@@~)
01:00:03 <lambdabot>     Not in scope: ‘<<@@~’
01:00:03 <lambdabot>     Perhaps you meant ‘<<%@~’ (imported from Control.Lens)
01:00:06 <sccrstud92_> :t (<<%@~)
01:00:07 <lambdabot> Optical (Indexed i) q ((,) a) s t a b -> (i -> a -> b) -> q s (a, t)
01:00:12 <sccrstud92_> there you go
01:00:17 <sccrstud92_> thats the Q*Bert Operator
01:00:26 <sccrstud92_> =P
01:00:34 <poincare101> Is there a way to *not* export certain functions from a module?
01:00:50 <sccrstud92_> poincare101: dont put them in the export list?
01:01:32 <poincare101> sccrstud92_: but then I'd have to put everything else in the export list
01:02:39 <sccrstud92_> poincare101: I think thats what most people end up doing
01:02:56 <dramforever> poincare101: you should do it
01:02:57 <sccrstud92_> i havent written any libraries, so someone else can probably answer better
01:03:14 <poincare101> dramforever: so every single function in my file goes in the export list?
01:03:26 <adarqui> poincare101: put everything in the export list and you can also create prettier documentation by creating sections in there etc, in the comments
01:03:29 <dramforever> poincare101: at least that's what I do
01:03:43 <dramforever> poincare101: is your module too large?
01:04:11 <poincare101> adarqui: ah, ok. so I guess putting everything in the export list is common practice?
01:04:55 <merijn> Alternatively you can create a new module "module MyModule (module MyOriginalModule) where import MyOriginalModule hiding (foo,bar,baz)" which will export everything in MyOriginalModule, minus foo, bar and baz
01:05:04 <dramforever> well we often use SomeType(..) to avoid listing too many constructors
01:05:17 <adarqui> ya poincare101 , check it
01:05:18 <adarqui> https://github.com/bos/filemanip/blob/master/System/FilePath/Find.hs
01:05:26 <adarqui> see how he has sections in there too, with -- * Blah ?
01:05:50 <poincare101> adarqui: Ah, so those make the sections in the haddock documentation?
01:06:05 <adarqui> but ya it's common practice, check bos/ekmett's libs if you want to pick up more best practices
01:06:08 <adarqui> ya
01:10:24 <adarqui> gn folks!
01:10:39 <Pip> gn
01:10:45 <dramforever> gn
01:10:47 <pacak> o/
01:10:59 <pacak> I mean - gn!
01:12:23 <ChristianS> good morning
01:12:48 <dramforever> good afternoon
01:12:59 <glaukon> quchen2: Thanks, that was what I was looking for.
01:13:08 <dramforever> yeah #haskell is truly a global channel
01:13:23 <Pip> Indeed
01:18:59 <gfixler> > const const const const const const const 5 const
01:19:00 <lambdabot>  5
01:19:23 <gfixler> > const const const const const const const "const" const
01:19:24 <lambdabot>  "const"
01:20:03 <pacak> Evening!
01:20:20 <gfixler> o/
01:27:48 <ttt_fff> how do I tell hoogle: yo, I want to search for 'over', but only in the context of COntrol.Lens
01:28:16 <dramforever> @hoogle Control.Lens.over
01:28:17 <lambdabot> package doctest-discover
01:28:17 <lambdabot> package doctest-discover-configurator
01:28:17 <lambdabot> package hpc-coveralls
01:28:21 <dramforever> huh?
01:28:53 <merijn> @hoogle over +lens
01:28:53 <lambdabot> Could not find some databases: lens
01:28:54 <lambdabot> Searching in:
01:28:54 <lambdabot>   .
01:29:01 <merijn> oh, that works in the webinterface
01:29:12 <merijn> You can't specify a specific module, but you can specify a package
01:29:18 <dramforever> ttt_fff: why don't you just head to Control.Lens?
01:29:28 <merijn> Also, packages just have an alphabetical index you can browse
01:29:36 <ttt_fff> because it's more convenient to use hoogle
01:29:52 <ttt_fff> so I'd prefer to just pass an additinoal option to hoogle rather than google "control.lens ahckage"
01:29:56 <ttt_fff> then edit the URL to get the latest version
01:30:03 <ttt_fff> then try to guess which module actually exports over
01:30:17 <ttt_fff> instead, I'd rather just hoolge "over // but please use Control.Lens"
01:30:19 <dramforever> hoogle Control.Lens, click, ctrl-f over
01:30:27 <dramforever> that's what I do
01:30:53 <ttt_fff> dramforever: hmm, can you make a youtube screencast with step by step instructions? :-)
01:31:04 <ttt_fff> the c-f over part is NOT working for me
01:31:20 <merijn> ttt_fff: Because over is not in Control.Lens
01:31:26 <ttt_fff> okay
01:31:28 <ttt_fff> where is over in ?
01:31:30 <dramforever> oh yes...
01:31:32 <merijn> ttt_fff: What's wrong with using the alphabetical index or "over +lens"?
01:32:04 <ttt_fff> over +lens worked
01:32:05 <ttt_fff> thanks
01:32:10 * dramforever is thinking about Grand Haddocks
01:32:13 <ttt_fff> why did I do "+lens" rather than "+Control.Lens" ?
01:32:19 <dramforever> ttt_fff: package
01:32:31 <ttt_fff> okay
01:32:33 <merijn> ttt_fff: Control.Lens is not a package name
01:32:38 <ttt_fff> merijn , dramforever: this all worked, thanks for your time
01:32:45 <dramforever> yw :)
01:33:08 <merijn> ttt_fff: Note that at the bottom of the package page there's an "index" link which has all functions/types sorta alphabetically
01:33:46 <ttt_fff> merijn: oh shit, was not aware of that
01:33:52 <ttt_fff> merijn: that's what you were shouting about, thanks :-)
01:35:49 <merijn> So does anyone understand what the unpacked Int's in bound's Deriving.hs example are for? I'm confused...
01:45:24 <fronko> If you can set a channel to enabled or disabled, what would you call the function that does that? 
01:45:34 <fronko> setChannelState?
01:45:46 <fronko> is there a more accurate word than state?
01:45:59 <dramforever> fronko: options? flags? settings?
01:46:14 <keko_> enableChannel or disableChannel?
01:46:53 <keko_> (two clearly-named functions might be better than a single one that takes a boolean, depending on your situation)
01:55:59 <merijn> Is anyone aware of an example combining free and bound to construct an AST? I think I've figured out how bound is supposed to work, and I think I've figured out how free is supposed to work
01:56:10 <merijn> But I'm not sure I understand how to fit them together
01:56:30 <merijn> The generality of Free certainly doesn't help >.>
02:13:03 <forgottenone> does runhaskell compile or interpret the code?
02:13:31 <dramforever> interpret by compiling to bytecode
02:14:09 <forgottenone> dramforever: does it differ from ghc code.hs
02:14:18 <dramforever> you mean runghc?
02:14:22 <dramforever> I dunno then
02:14:38 <forgottenone> i mean ghc code.hs && ./code
02:15:04 <dramforever> I don't know the details
02:15:31 <merijn> runhaskell compiles to bytecode and runs that
02:15:38 <merijn> So yes, it differs from compiling via GHC
02:15:41 <merijn> By a lot
02:16:32 <forgottenone> merijn: ok thank, i asked if performance differs and i think i got the answer
02:21:05 <latk> How can I determine the path of a specific .hs file?
02:21:09 <latk> I guess I cant?
02:21:23 <merijn> latk: You can't, what would you do with that info anyway?
02:21:45 <latk> Want to reference a relative folder
02:21:47 <dramforever> latk: what do you want? http://xyproblem.info/
02:21:53 <dramforever> lol exactly
02:22:06 <dramforever> it's an x y problem
02:22:19 <dramforever> latk: does "./" suffice?
02:23:01 <latk> I assume this will require the binary to always be executed from that folder.. although I guess there is no way around this.
02:23:33 <merijn> latk: Why not use a relative path in your executable?
02:23:42 <dramforever> latk: okay, so what are you doing? It seems that we are still suffering from an x y problem
02:23:53 * dramforever learnt about that today
02:24:03 <latk> dramforever: You seem to be fond of it :p
02:24:09 <dramforever> lol
02:24:18 <dramforever> happens all the time
02:24:35 <latk> I want to reference some sample files for some tests for some parsers.
02:24:58 <dramforever> what about taking filenames as arguments?
02:25:28 <dramforever> well, directory name also looks great
02:25:58 <latk> Yeah, it would be nicer if you could just "stack test"
02:26:07 <latk> but I guess maybe there is no way around this.
02:26:17 <dramforever> latk: don't lose hope
02:26:29 * dramforever isn't really good at that, so that answer is probably bad
02:26:51 <latk> I guess I could also set an env variable
02:26:54 <latk> but that seems a bit lame
02:26:59 <nkaretnikov> is there showFFloat that doesn't round?
02:29:55 <phaazon> merijn: does ghci also compile to bytecode?
02:30:01 <merijn> phaazon: Yes
02:30:11 <phaazon> :)
02:31:27 <merijn> hmmm
02:31:33 <merijn> I think I've got my code working
02:31:41 <merijn> But I'm reminded of a quote...
02:32:07 <merijn> @quote autrijus didn't.you
02:32:07 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I just don't know what it means.
02:34:05 <lpaste> merijn pasted “Bound and free!” at http://lpaste.net/136091
02:34:25 <merijn> Can anyone with edwardk levels of wizardry tell me whether that makes any sense?
02:34:40 <dramforever> edwardk: ^
02:34:56 <phaazon> ahah
02:34:59 <phaazon> the bound library
02:35:08 <dramforever> merijn: wait you are not using f in data ExpF f a
02:35:10 <merijn> dramforever: He's always asleep when I have questions for him, so rude of him to not be my personal helpdesk :)
02:35:18 <dramforever> okay
02:35:23 <phaazon> merijn: do you know bound?
02:35:30 <phaazon> or is it the first time you use it?
02:35:31 <merijn> phaazon: Define "know"
02:35:35 <phaazon> it's not that hard, actually
02:35:36 <merijn> phaazon: First time
02:35:44 <merijn> I think I understand bound
02:35:49 <merijn> I think I understand free
02:35:51 <phaazon> what don't you understand in your excerpt?
02:36:03 <merijn> I'm not sure I understand both in conjunction :p
02:37:04 <merijn> dramforever: oh, 'f' should be used where I use "Exp" in scope, but I bollocksed it up the first time around
02:37:27 <phaazon> merijn: IIRC, bound uses De Bruijn's encoding
02:37:31 <merijn> phaazon: I don't think I understand anything xD
02:37:43 <phaazon> do you understand abstract1?
02:38:23 <merijn> As far as I can tell I'm basically (ab)using Pure (from free) as a variable and the recursion in ExpF to form the 'a'
02:40:16 <dramforever> oh hmm....you can build trees with free
02:40:24 <phaazon> well, your Exp type is just a convenient way to get a monad out of ExpF
02:41:09 <phaazon> abstract1 v b is not very hard to understand
02:41:28 <merijn> I understand the abstract1/instantiate1 bits just fine
02:41:29 <phaazon> it abstracts a single variable
02:41:31 <phaazon> ok
02:41:59 <merijn> I wonder if there's a more convenient way to get rid of the "Exp . liftF" in lam, probably not, I guess?
02:42:52 <phaazon> I don't think so, yeah
02:43:14 <merijn> phaazon: The thing I'm not sure about is "a :@ a"
02:43:22 <phaazon> the app operator?
02:43:34 <phaazon> looks like it's wrong, yeah
02:43:37 <merijn> I'm not sure whether that should be "f a :@ f a" or "Exp a :@ Exp a" instead
02:43:54 <phaazon> I'd go for Exp a :@ Exp a, yeah
02:44:03 <phaazon> because you can apply a bound variable
02:44:47 <merijn> I think Free should be responsible for the recursion there, so I think "Exp a" is wrong
02:45:38 <nkaretnikov> how can I show 0.06 without scientific notation and rounding?  neither show nor showFFloat help here
02:45:40 <phaazon> when I wanted to build an AST with bound, I finally gave up 
02:45:50 <phaazon> nkaretnikov: try having a look at Numeric.* stuff
02:46:28 <nkaretnikov> phaazon: please re-read the second sentence
02:46:42 <phaazon> nkaretnikov: ah
02:46:43 <nkaretnikov> there's nothing suitable in Numeric
02:46:58 <merijn> "f a :@ f a" looks right
02:47:13 <phaazon> have you tried with sprintf?
02:47:22 <nkaretnikov> nope
02:47:42 <merijn> If I add "I Int" to ExpF and "int = Exp . liftF . I" I can write "lam 'c' (pure 'c') :@ int 1" and it has the right type
02:48:46 <nkaretnikov> phaason: wait, where's it defined?
02:49:09 <nkaretnikov> I meant phaazon, sorry
02:50:50 <nkaretnikov> Text.printf "0.06" :: String => "0.06"
02:50:56 <nkaretnikov> phaazon: thanks!
02:51:20 <nkaretnikov> should have been Text.Printf.printf but whatever
02:53:54 <nkaretnikov> lol, I'm totally sleepy.  I just converted from a string to a string...
02:59:51 <nkaretnikov> this works: formatRealFloat 0.06 (FieldFormat Nothing (Just 2) Nothing Nothing False "" 'f') ""
03:03:34 <Sindriava> It might be worth noting somewhere that cabal package names are case-sensitive, I haven't seen it written anywhere
03:07:47 <phaazon> oh yeah, printf
03:07:51 <phaazon> not sprintf, sorry :)
03:08:39 <nkaretnikov> well, printf doesn't help here anyway since it takes a string
03:09:31 <eds> Any ideas on how I can solve this error? http://lpaste.net/132328
03:12:10 <bergmark> eds: you need to establish that the `b' in fapply si the same `b' as in `Fox'. atm fapplay has type `forall b. Fox -> b'
03:14:14 <eds> and how would I do that? bergmark.
03:21:15 <lpaste> chpatrick pasted “Demoting DataKinds from Template Haskell - Generic edition” at http://lpaste.net/136095
03:21:15 <bergmark> eds: i'm not sure if it's possible since Fox is opaque, you may need to make the return type into a type parameter
03:32:42 * hackagebot ViennaRNAParser 1.2.3 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.2.3 (FlorianEggenhofer)
03:32:44 * hackagebot ClustalParser 1.1.3 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.1.3 (FlorianEggenhofer)
03:39:56 <Sindriava> Ist here a general uncurry function?
03:40:03 <Sindriava> *Is there
03:40:44 <hamid> :t uncurry
03:40:45 <lambdabot> (a -> b -> c) -> (a, b) -> c
03:41:07 <Sindriava> I'm well aware of that, but it's not *general*, is it
03:41:26 <hamid> I've no idea what you mean by general.
03:41:39 <Sindriava> For arbitrary function types
03:41:46 <Sindriava> I meant something that takes a function with arbitrary number of args
03:41:48 <merijn> Sindriava: How would that work?
03:42:04 <Sindriava> merijn: Well, I imagine this:
03:42:31 <Sindriava> merijn: a → b → c is of type a → b', it's just b' is (b → c)
03:42:40 <Sindriava> Right?
03:43:16 <merijn> Sure
03:43:24 <Sindriava> uncurry could work recursively and just flatten the resulting tuple
03:43:31 <nkaretnikov> Sindriava: there's a trick for defining multiargument functions in haskell
03:43:35 <merijn> How would you know when to stop?
03:43:38 <nkaretnikov> not sure whether it applies here
03:43:58 <Sindriava> merijn: When the type isn't an arrow? ¯\_(ツ)_/¯
03:44:04 <Sindriava> merijn: That's where I'm unsure
03:44:06 <merijn> Sindriava: You can't match on types
03:44:14 <Sindriava> merijn: Fair enough
03:44:19 <merijn> Sindriava: So there's no way to detect "the type isn't an arrow"
03:44:29 <merijn> Sindriava: Also, take foldr
03:44:31 <merijn> :t foldr
03:44:32 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:44:53 <merijn> How do you know 'b' is an arrow or not until you've applied all arguments?
03:45:03 <Sindriava> Fair enough
03:45:26 <Sindriava> But there's (,), it's weird that there's no counterpart to it
03:45:40 <hamid> @src uncurry
03:45:41 <lambdabot> uncurry f p = f (fst p) (snd p)
03:46:29 <Sindriava> :t (,)
03:46:30 <lambdabot> a -> b -> (a, b)
03:46:33 <Sindriava> :t (,,)
03:46:34 <lambdabot> a -> b -> c -> (a, b, c)
03:46:39 <Sindriava> :t (,,,,,,,)
03:46:41 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
03:46:48 <hamid> it has a limit
03:46:52 <Sindriava> Does it?
03:46:54 <Sindriava> I see
03:46:54 <hamid> yes
03:47:26 <Sindriava> In any case, I feel like "uncurry2" would find plenty of uses
03:47:40 <rom1504> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
03:47:41 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30)
03:47:50 <rom1504> right :d
03:48:05 <Sindriava> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
03:48:06 <lambdabot>     A 85-tuple is too large for GHC
03:48:06 <lambdabot>       (max size is 62)
03:48:06 <lambdabot>       Workaround: use nested tuples or define a data type
03:48:18 <hamid> and that's the limit :)
03:48:30 <Sindriava> I wouldn't call that a limit of (,) though
03:48:36 <frerich> Quiz: why is the maximum size 62 and not, say, 64.
03:48:44 <Sindriava> Sounds more like a limit of GHC
03:49:23 <Sindriava> hamid: And it's still not a reason for having (,,,) and no counterpart IMO
03:49:47 <magneticDuck> wow that's such a terrible arbitrary limitation!
03:50:01 <magneticDuck> surely huge tuples are an elegant way of storing large datasets!
03:50:21 <edk> well on that basis why isn't it something like 20?
03:50:25 <magneticDuck> no more MySQL, more (,,,,,,,,,,,,,)
03:50:31 * frerich thinks that if you have to make up some arbitrary maximum, you should pick a power of two so that everybody things you actually impose that particular limit for a good reason.
03:51:07 <rom1504> https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs#L162
03:52:32 <rom1504> ( https://www.reddit.com/r/haskelltil/comments/2u3ees/tuples_are_limited_to_size_62_in_ghc/ )
03:54:52 <hamid> well... it's a type constructor
04:00:54 <Sindriava> magneticDuck++
04:01:11 <Sindriava> frerich+++ :D
04:02:18 <Sindriava> "Manuel says" is my new favourite excuse for anything and everything
04:04:05 <merijn> Is there a lens/prim for peering through Free?
04:30:58 <predator217> merijn: you mean _Pure and _Free? it's at the bottom of http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html
04:31:06 <merijn> Ah
04:31:21 <merijn> Looking in the wrong place, apparently
04:42:04 <FPtje> Hey I'm using UUAGC and I just cloned my repo on a new laptop, but the setup file throws a tantrum about cabal: http://i.imgur.com/HY3Isti.png
04:42:29 <FPtje> What can I do with this kind of error? I mean the type is exactly the same, except the package where it's from is different. 
04:43:10 <dcoutts> FPtje: are you compiling the Setup.hs yourself, or via cabal ?
04:43:10 <merijn> FPtje: Did you accidentally checkin/clone the compiled Setup executable?
04:43:37 <FPtje> dcoutts, cabal configure and ghci give the same error. merijn My repo doesn't have any executables
04:43:37 <dcoutts> FPtje: if the latter, use --cabal-lib-version=1.22.3.0
04:44:13 <FPtje> dcoutts, that worked, but why?
04:44:22 <dcoutts> FPtje: longer term solution: tell the uuagc authors about this new feature to be able to specify the deps of their Setup.hs, see http://www.well-typed.com/blog/2015/07/cabal-setup-deps/
04:44:54 <dcoutts> FPtje: their Setup.hs uses an external library that had already been built against Cabal-1.22.3.0
04:48:10 <FPtje> Ah
04:48:28 <FPtje> Thanks, dcoutts, but cabal build throws the same error, and I can't give it the --cabal-lib-version=1.22.3.0 option
04:49:02 <dcoutts> FPtje: really, after running configure? It shouldn't need to rebuild the Setup.hs unless you edit it.
04:49:40 <FPtje> dcoutts, http://i.imgur.com/GT7zzvH.png
04:50:45 <dcoutts> weird, it's not actually compiling the Setup.hs in the first one
04:50:50 <FPtje> oh of course. Building is broken. Removing dist/ and trying again works
04:51:09 <dcoutts> FPtje: other workaround is to rebuild the lib that that Setup.hs uses against the later Cabal lib version
04:51:45 <dcoutts> (or test out the latest dev version of cabal-install and try out the new setup-deps feature)
04:54:57 <FPtje> I'll send an email to the UUAGC devs. It looks like it's their responsibility, and I've got a working build
04:55:00 <FPtje> thanks!
05:06:15 <nicocbg> hi, what is the meaning of the following export for a module : module SVG (module SVG, Svg) where
05:06:28 <merijn> nicocbg: Reexports module SVG
05:06:35 <dramforever> merijn: read again
05:06:48 <merijn> dramforever: I stand by my explanation
05:06:52 <merijn> You can reexport yourself
05:07:11 <tdammers> why would you do that though?
05:07:12 <dramforever> hmm...looks like we have different definitions for "meaning"
05:07:14 <nicocbg> what does that mean  to reexport yourself ?
05:07:17 <merijn> It's the same as exporting every symbol in scope
05:07:21 <merijn> The usual reason to do so is if you want to export everything AND reexport some others
05:07:34 <dramforever> oh wow
05:07:35 <merijn> Reexporting requires an export list, which would mean listing EVERYTHING in your module
05:07:44 <tdammers> oh wait, yeah, it makes sense if Svg comes from a different module
05:07:57 <merijn> If you're lazy you can reexport yourself and the other thing to avoid an explicit list of names
05:08:12 <merijn> And you're doing haskell, so of course you're lazy
05:08:15 <dramforever> lol
05:08:41 <tdammers> also, you're already dealing with the most verbose and underpowered part of the language here
05:08:49 <nicocbg> interesting
05:09:50 <merijn> hmmm
05:10:10 <nicocbg> and it differs from just saying : module SVG  where
05:10:16 <merijn> Ok, suppose I have a Free monad and I wanna annotate every node with some metadata, how could I easily annotate that?
05:10:31 <merijn> nicocbg: I'm assuming "Svg" is imported from somewhere else?
05:10:44 <merijn> nicocbg: Imports aren't reexported if you leave out the export list
05:10:52 <nicocbg> yes
05:10:53 <merijn> nicocbg: So you *have* to have an export list to reexport Svg
05:11:06 <merijn> nicocbg: But you don't wanna list all names defined inside the module SVG
05:11:15 <nicocbg> what is the best place for documentation of those things ?
05:11:21 <merijn> "module SVG (module SVG) where" is the same as no export list
05:12:46 <nicocbg> gotcha
05:15:47 <srenatus> hi there. Using conduit, how would I approach the following: Given src :: Source IO B.ByteString, I got `src $$ CB.lines =$= CL.mapM_ B.putStrLn`. What I'd like a cat :: Conduit B.ByteString IO B.ByteString such that `src $$ CB.lines =$= cat =$= CL.mapM_ B.putStrLn` outputs the content of every file, i.e. what src outputs are filenames.
05:18:22 <srenatus> current working hypothesis: I want a ZipConduit. totally wrong? ;)
05:19:33 <Guest20430> Suppose I have a conduit doing stuff on my stream, but I want to make sure it only runs x minutes! Is there a better way, than giving it the starttime at the beginning and getting current time in every "subconduit", adding x minutes to the start time and comparing it?
05:20:12 <Guest20430> ...for every item
05:21:36 <Guest20430> Or phrased in a simpler way: how can i make my conduit run at maximum x minutes even if after x minutues there are still times comming from the source?
05:23:56 <Guest20430> no one? :(
05:26:40 <catgocat> HI
05:26:55 <catgocat> is this the official haskell room?
05:27:06 <dramforever> yes
05:27:10 <pavonia> Guest20430: System.Timeout maybe?
05:27:39 <catgocat> so if I have a haskell question or I'm stuck this is the place to go?
05:28:13 <dramforever> catgocat: yes just ask
05:28:16 <dramforever> :)
05:28:18 <catgocat> ok thanks
05:29:33 <Guest20430> pavonia: Thank you, sorry, I didn't specify all correctly. I need my conduit retun the state so far computed any way. Whether it ran into the timeout or if there are no more items comming in the stream
05:30:52 <Guest20430> pavonia: ahh, I as I see, I might be able to use it anyway by putting the result in a state monad, right?
05:32:10 <pavonia> Hhm, I don't know how conduit stores its state, but if you could put it in a n MVar or so at regular intervals, that might work
05:32:34 <lamefun> can I separate modules into comparments?
05:33:18 <lamefun> eg. to isolate one part of a module from another or introduce some local renames
05:36:10 <pavonia> lamefun: I don't think so
05:36:33 <catgocat> I'm trying to install the haskell platform to start compiling haskell programs, and I got my way to here http://packages.ubuntu.com/search?keywords=haskell-platform
05:36:44 <catgocat> Which one should I install ? ^
05:37:37 <dramforever> I think haskell-platform is good enough
05:38:10 <dramforever> the doc one includes documentation, and prof one includes code that enables profiling of standard libraries
05:39:21 <catgocat> which one should I install? precise, trusty, vivid.. 
05:40:28 <catgocat> the haskell plataform has multiple options 
05:40:51 <dramforever> no you don't
05:41:01 <dramforever> apt-get install haskell-platform
05:41:07 <dramforever> oh maybe prepend sudo
05:41:07 <AshyIsMe> god i need to clean up the ghc installs on my macbook
05:41:21 <AshyIsMe> i have 7.6 and 7.8 installed in /Library and also in ~/Library
05:41:25 <catgocat> oh ok thanks
05:41:31 <AshyIsMe> and now in ~/.stack/... aswell
05:41:33 <dramforever> catgocat: precise, trusty, ... are distros
05:41:46 <catgocat> that did the job ;)
05:42:01 <dramforever> it's highly likely that you have only one distro running on your machine
05:42:17 <dramforever> well, distro versions
05:42:57 <catgocat> dramforever: what changes between distros?
05:43:26 <dramforever> catgocat: each distro version has a code name and a number
05:43:31 <dramforever> for example precise = 12.04
05:43:39 <mfng>  Proof:  in 3 [4,5,6,7] = map (4:) (in 3 [5,6,7])  map (5:) (in 3 [6,7])  map (6:) (in 3 [7])   map (7:) (in 3 []) -- y == 7, ys == []  [[3]]  [[4, 5, 6, 7, 3]]  in x (y:ys) = in x ys in 3 [4,5,6,7] = in 3 [5,6,7]  in 3 [6,7] = in 3 [7] = in 3 [] [[3]]  in x (y:ys) = (x:y:ys) : map (y:) (in x ys) in 3 [4,5,6,7] = [3,4,5,6,7] : map (4:) (in 3 [5,6,7])  = [3,4,5,6,7] : map (4:) (in 3 [5,6,7])  = [3,4,5,6,7]: map (4:) (map (5:) (in 3 [6,7
05:43:56 <catgocat> dramforever: yeah, but for me as a beginner should I care?
05:44:08 <mfng> interleave :: a -> [a] -> [[a]] interleave a [] = [[a]] interleave x (y:ys) = (x:y:ys):map (y:) (interleave x ys)
05:44:15 <dramforever> catgocat: you should ask somewhere like #ubuntu :)
05:44:28 * dramforever /j #ubuntu for fun
05:44:38 <mfng> I cannot work out the recursion for 'interleave' function
05:45:06 <mfng> I got stuck like this : in x (y:ys) = (x:y:ys) : map (y:) (in x ys) in 3 [4,5,6,7] = [3,4,5,6,7] : map (4:) (in 3 [5,6,7])  = [3,4,5,6,7] : map (4:) (in 3 [5,6,7])  = [3,4,5,6,7]: map (4:) (map (5:) (in 3 [6,7]) [3,6,7]: map (6:) (in 3 [6,7]
05:45:25 <mfng> ???
05:46:07 <mfng> in is shorthand for interleave
05:46:20 <mfng> in the above example
05:51:16 <int-e> mfng: in x (y:ys) = (x:y:ys) : map (y:) (in x ys) <-- this part looks good, but the function definition is still missing a base case
05:52:46 <mfng> sorry the complete definition is from Hutton 'Programming in Haskell' : interleave :: a -> [a] -> [[a]] interleave a [] = [[a]] interleave x (y:ys) = (x:y:ys):map (y:) (interleave x ys)
05:53:52 <merijn> hmmm
05:54:03 <mfng> interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys) (e.g.) interleave 3 [4,5,6,7] = [3,4,5,6,7] : map (4:) (interleave 3 [5,6,7])  = [3,4,5,6,7] : map (4:) (interleave 3 [5,6,7])  = [3,4,5,6,7]: map (4:) (map (5:) (in 3 [6,7]) = [3,6,7]: map (6:) (in 3 [6,7]...???
05:54:35 <mfng> = [3,4,5,6,7] : map (4:) (interleave 3 [5,6,7])  = [3,4,5,6,7]: map (4:) (map (5:) (interleave 3 [6,7]) = [3,6,7]: map (6:) (interleave 3 [6,7]...???
05:56:30 <merijn> How do I derive Eq/Ord/etc. for a newtype around FreeT? (Or even FreeT?) my attempts don't seem to be working
05:56:55 <wei2912> mfng: wait a moment
05:57:08 <mfng> so confusing
05:57:25 <WeaponX> is there a handy shortcut for tallying up words in a corpus, or do I need to do it the old-fashioned way by starting with an empty hashmap etc
05:57:34 <chpatrick> merijn: that's weird, what does it say?
05:57:54 <merijn> chpatrick: For what? For the newtype?
05:57:58 <chpatrick> iirc you can't just GND MonadFree but the rest are ok
05:58:07 <chpatrick> when you try to derive
05:58:16 <merijn> I have
05:58:17 <merijn> newtype Expr m a = Expr { unExpr :: FreeT (ExprF (Expr m)) m a } deriving (Functor,Applicative,Monad,Foldable,Traversable)
05:58:35 <chpatrick> oh I think I know why
05:58:43 <chpatrick> because you would need to say Eq (f a) for all a
05:58:55 <chpatrick> but you can't
05:58:56 <chpatrick> right?
05:59:09 <merijn> Trying to add "Eq" to the list results in "No instance for (Eq (m (FreeF (ExprF (Expr m)) a (FreeT (ExprF (Expr m)) m a))))"
05:59:19 <chpatrick> yeah that's it
05:59:26 <merijn> You can, there's the Eq1 class in prelude-extras
06:00:01 <merijn> But if I try to do "instance Eq1 m => Eq (m <stuff>)" it doesn't work either
06:00:40 <chpatrick> can you do instance Eq1 m => Eq (Expr m a)?
06:00:59 <wei2912> mfng: i'm going to do it with a smaller example
06:01:04 <chpatrick> and write the instance yourself?
06:01:08 <wei2912> mfng: because 4 elements is already annoying
06:02:21 <chpatrick> (Functor f, Eq1 f) => Eq1 (Free f)
06:02:25 <chpatrick> can't you GND Eq1?
06:04:39 <merijn> chpatrick: I can't figure out how to write the instance with the least amount of work :\
06:04:41 <wei2912> mfng: http://lpaste.net/136096
06:04:47 <merijn> Hence my original question
06:08:41 <merijn> Ah, bollocks
06:08:51 <merijn> This all worked so well until I wanted to annotate it...
06:21:53 <merijn> But I can't turn "Eq (ExprF f a)" into Eq1
06:23:15 <chpatrick> don't you have Eq1 for ExprF f?
06:24:18 <WeaponX> what's the best way in Haskell to download a remote file in chunks, without loading it entirely in memory first?
06:24:43 <WeaponX> io-streams?
06:24:53 <merijn> chpatrick: No
06:24:57 <dramforever> many lazy-bytestring-based http libs work afaik
06:24:58 <merijn> chpatrick: That's the entire problem
06:25:01 <nkaretnikov> I don't understand why insert is not strict in both arguments here: https://github.com/meiersi/HaskellerZ/tree/master/meetups/20150531-ZuriHac2015_Johan_Tibell-Performance  could anyone explain?  to me it looks exactly like the example shown above. 
06:25:07 <chpatrick> how come?
06:25:13 <merijn> chpatrick: How would I get it?
06:25:36 <merijn> chpatrick: The only way to get Eq1 for "ExprF f" is to write it out explicitly
06:25:42 <merijn> Which is exactly what I'm trying to avoid
06:26:03 <Guest20430> is there a way to make a conduit just not consume any more input and stop after a certain timeout?
06:26:28 <Guest20430> and ofc return whatever has been calculated up until then
06:28:02 <chpatrick> merijn: is it a really big type?
06:28:13 <merijn> chpatrick: It's constantly changing
06:28:19 <merijn> I'm prototyping stuff
06:28:23 <chpatrick> it's not in derive unfortunately
06:28:39 <chpatrick> I think you might have to bite the bullet and write an Eq1 yourself
06:29:06 <dramforever> hey can we make ghc spit out derived instances?
06:29:14 <dramforever> I mean, the source code
06:29:17 <merijn> This really sucks, because when I was using Free instead of FreeT it "Just Worked"
06:29:22 <merijn> dramforever: Yes
06:29:33 <dramforever> merijn: then we can use that in Eq1
06:29:45 <merijn> dramforever: How so?
06:30:13 <dramforever> oh too bad we can't derive Eq...
06:30:17 <dramforever> forget about it
06:30:29 <merijn> I already have Eq derived for ExprF
06:30:42 <merijn> But that's not good enough to obtain an Eq instance for FreeT
06:31:11 <chpatrick> hmm
06:34:52 <nkaretnikov> well, nevermind, I should have read the explanation below before asking
06:35:36 <chpatrick> merijn: I'm surprised you can't get Eq1 from Eq
06:35:44 <chpatrick> this typechecks:
06:35:44 <chpatrick> defaultEq1 :: (Eq (f a), Eq a) => f a -> f a -> Bool
06:35:44 <chpatrick> defaultEq1 = (==)
06:36:58 <dramforever> chpatrick: well interesting because I guess you can't have Eq (f a)
06:37:11 <dramforever> if you have instance (Eq1 f, Eq a) => Eq (f a)
06:37:32 <merijn> That's the default implementation for Eq1's ==#
06:38:12 <chpatrick> so why can't you get Eq1 for free for ExprF and therefore Eq1 for everything else?
06:38:22 <merijn> But writing "instance Eq1 f => Eq1 (ExprF f)" produces: "Could not deduce (Eq (F a)) arising from a use of Prelude.extras"...blahblah"
06:39:58 <merijn> Neither does "e1 ==# e2 = e1 == e2" work
06:40:10 <merijn> Again "Could not deduce the Eq (f a)"
06:44:45 <lpaste> merijn pasted “Bound and free AST” at http://lpaste.net/136097
06:45:19 <merijn> If anyone can find a way to implement Eq/Ord/Show/Read for Expr, it'd be more than welcome...
06:46:31 <s9kaan> test
06:57:02 <catgocat> I am reading the book Learn You A Haskell, and the following snippet is giving me "parse error on input `='": length' xs = sum [1 | _ <- xs]
06:57:25 <magneticDuck> length`, not length
06:57:28 <magneticDuck> length' (
06:57:35 <magneticDuck> s/(/*
06:58:39 <catgocat> magneticDuck: what you mean?
06:58:44 <ClaudiusMaximus> catgocat: ghci syntax vs file syntax is my guess, put it in a file and load it in ghci, or prefix with  let 
06:59:18 <magneticDuck> nm
06:59:35 <catgocat> ClaudiusMaximus: that worked thanks
07:07:49 <breadmonster> Hello.
07:07:54 <Intolerable> hi
07:08:36 <kuribas> hey
07:08:42 <breadmonster> A common Haskell pattern is to use a helper functions as recursive loop.
07:08:58 <breadmonster> I'm wondering if ghc has any optimizations on these functions.
07:09:11 <breadmonster> like if it optimizes them away or something.
07:09:55 <sunnymilk> why is ghc on gentoo at 7.8
07:10:41 <nkaretnikov> what's the file extension for core files that's automatically recognized by haskell-mode?
07:10:42 <breadmonster> sunnymilk: binaries are always earlier versions.
07:10:45 <maerwald> sunnymilk: it is on 7.10.1
07:10:56 <breadmonster> Oh hi maerwald 
07:10:59 <maerwald> and there is even a live ebuild
07:11:16 <maerwald> but those are in the haskell overlay
07:11:19 <maerwald> layman -a haskell
07:11:19 <sunnymilk> maerwald are you talking about-
07:11:19 <sunnymilk> ah
07:11:43 <maerwald> it is hardmasked, so you have to unmask it
07:12:15 <sunnymilk> ill have to try the official overlay
07:12:21 <sunnymilk> on gentoo without the overlay its at 7.8
07:12:58 * hodapp grumbles, imports Debug.Trace
07:14:18 <rbocquet> merijn: instance (Monad m, Eq1 m) => Eq1 (Expr m) where Expr a ==# Expr b = a ==# b ?
07:14:24 <maerwald> sunnymilk: the in-tree ebuilds are sometimes terribly outdated, most work is done in the overlay
07:14:43 <maerwald> that may change when we switch to git, but don't get your hopes up
07:23:21 <merijn> rbocquet: I don't have an Eq instance for FreeT
07:24:18 <merijn> Because that requires an Eq instance of "m (FreeF ...)", and writing "instance Eq1 m => m (FreeF...)" doesn't work without an Eq1 instance of ExprF (Expr m), etc.
07:25:17 <merijn> rbocquet: If you manage to find a way to write it without implementing Eq1 manually for ExprF in http://lpaste.net/136097 I'm curious how
07:29:39 <merijn> hmmm
07:29:48 <merijn> I think I've got it, albeit it in a horrible way
07:30:34 <chpatrick> go on
07:30:41 <breadmonster> merijn: More category theory?
07:30:59 <lpaste> merijn pasted “Ugh...” at http://lpaste.net/136098
07:31:04 <merijn> This compiles
07:32:37 <catgocat> Why is this returning a compiler error? let startsWith x y = take (length y) x == y
07:32:45 <merijn> So, like a true haskeller that must mean it works
07:33:09 <mauke{> > let startsWith x y = take (length y) x == y in ()
07:33:10 <lambdabot>  ()
07:33:16 <mauke{> catgocat: ?
07:33:44 <catgocat> mauke: why did you add the in? 
07:34:01 <Intolerable> > let startsWith x y = take (length y) x == y
07:34:02 <lambdabot>  <no location info>:
07:34:03 <lambdabot>      not an expression: ‘let startsWith x y = take (length y) x == y’
07:34:10 <Intolerable> because otherwise that happens to lambdabot
07:34:28 <Intolerable> (let without the in isn't an expression)
07:34:36 <geekosaur> catgocat, lambdabot is not ghci, nor is it a ghc top level; it accepts expressions only.
07:34:53 <catgocat> I am doing my code on ghci
07:35:00 <hodapp> okay, that's a little confusing. I see stmt =<< ... in some code (it's in a do-block) but nowhere do I see 'stmt' defined
07:35:12 <catgocat> but what's the difference between using in an not using it?
07:35:18 <hodapp> is this some way of defining 'stmt' that I'm not familiar with?
07:35:22 <catgocat> *and
07:35:22 <mauke{> catgocat: no, what's the error you're getting?
07:35:25 <geekosaur> let ... in is an expression
07:35:35 <geekosaur> let without in is specific to do block syntax
07:35:43 <geekosaur> (ghci pretends to be the inside of a do block)
07:35:47 <catgocat> hmm ok
07:35:58 <Intolerable> what does the error say?
07:36:10 <catgocat> <interactive>:62:1:     Couldn't match expected type `([a0] -> [a0] -> Bool)                                   -> [Char] -> t0'                 with actual type `[Char]'     The function `"hello"' is applied to two arguments,     but its type `[Char]' has none     In the expression: "hello" startsWith "h"     In an equation for `it': it = "hello" startsWith "h"
07:36:22 <mauke{> catgocat: that's a completely different line
07:36:26 <catgocat> this is after calling the function
07:36:32 <mauke{> exactly
07:36:38 <catgocat> it doesn't throw error when writing the function itself
07:36:43 <catgocat> only after calling it
07:36:48 <mauke{> yes. so you didn't tell us the truth
07:36:55 <mauke{> and you're not calling it
07:36:58 <mauke{> you're calling "hello"
07:37:10 <Intolerable> > let startsWith x y = take (length y) x == y in "hello" `startsWith` "hell"
07:37:11 <lambdabot>  True
07:38:16 <catgocat> Prelude> let startsWith x y = take (length y) x == y
07:38:18 <catgocat> Prelude> "hello" startsWith "h"
07:38:23 <catgocat> throws error ^
07:38:33 <geekosaur> catgocat, did you notice the backticks `` ?
07:38:37 <geekosaur> they are not optional
07:38:39 <catgocat> but when I add `in` to the function it works
07:38:53 <catgocat> oh I forgot that
07:39:14 <catgocat> oh I'm dumb
07:39:20 <Intolerable> does it work when you include that?
07:39:22 <geekosaur> startsWith is being used as an operator (infix), but it is not symbols so it must be wrapped in ``
07:39:27 <catgocat> I'm sorry guys I'm not used to this kind of syntax hehe
07:39:42 <Intolerable> glad you got it working
07:39:53 <catgocat> geekosaur: yes, thanks
07:40:10 <catgocat> this programming language is very different from what I'm used to
07:40:17 <merijn> Can anyone tell me why there's unpacked Int's in a bunch of places in this example: https://github.com/ekmett/bound/blob/master/examples/Deriving.hs ?
07:40:26 <catgocat> I choose to learn it, to see if I can improve my programming in general
07:40:28 <merijn> Just an optimisation by storign arity?
07:43:08 <breadmonster> merijn: You're the perfect person for my question.
07:43:23 <breadmonster> Does ghc automatically recognize loop helper functions?
07:43:35 <breadmonster> In particular, helper functions with TCO?
07:44:15 <latk> What do people think about the state of ghcjs? Is it getting to the point where it might be usable for a small application in production?
07:44:34 <latk> e.g. in combination with reflex
07:44:39 <merijn> Depending on your point of view, GHC either doesn't do TCO or always does TCO (even for non-recursive functions), so either way the point is moot
07:44:45 <breadmonster> eg. `fact n = let go n acc = go (n-1) (n*acc); go 1 acc = acc in go n 1`?
07:45:09 <breadmonster> merijn: In the fact example, would it help if I made acc strict?
07:45:52 <merijn> Probably
07:46:24 <hodapp> https://github.com/GaloisInc/ivory/blob/master/ivory/src/Ivory/Language/Coroutine.hs#L192 - that's the code in question. Does '>>= stmt' or 'stmt =<<' mean something special here? I cannot see 'stmt' defined anywhere (and seemingly not in any Ivory import), so I am a bit confused.
07:47:15 <mauke{> hodapp: https://github.com/GaloisInc/ivory/blob/master/ivory/src/Ivory/Language/Coroutine.hs#L298
07:47:43 <hodapp> mauke{: ...how in the hell did my repeated searches miss that? Thanks.
07:48:07 <hodapp> must have mangled something in the copy of the file I'm searching in.
07:55:43 <mfng> Hey guys, Is there any bright mind who can enlighten me by posting an answer to the question on http://stackoverflow.com/questions/31272099/haskell-recursion-interleave-function-in-programming-in-haskell-ch-11
07:55:47 <mfng> ?
07:56:07 <mfng> Thank you in advance.
08:00:23 <marchelzo_> How do you overload the return type of a function? Like if I wanted `echo s = return $ s ++ "\n"` in the case of `echo "foo" | putStr`, but `echo = putStrLn` in the case of simply `echo "foo"`
08:00:34 <mniip> mfng, you didn't do any maps
08:00:46 <mniip> oh you did
08:00:51 <mniip> but only on the first element
08:01:49 <mniip> mfng, it is not apparent to me what happens between '= [3,4,5,6,7]:map (4:) (interleave 3 [5,6,7])' and '= [3,4,5,6,7]:[4,3,5,6,7]:map (5:) (interleave 3 [6,7])' in your unfolding
08:02:28 <mniip> you seem to apply (4:) to the first element of the returned list, but then completely discard it for the rest of the list
08:02:55 * hackagebot atomic-write 0.2.0.4 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.2.0.4 (jsl)
08:18:18 <benzrf> marchelzo_: you dont
08:18:38 <benzrf> i mean you /could/, but you realllly SHOULDNT
08:18:42 <marchelzo_> benzrf: What's so bad about it?
08:19:17 <benzrf> context-sensitive stuff is the devil
08:20:08 <benzrf> that is to say. the semantics of a function or value should not vary based on what expression it is placed in
08:20:24 <benzrf> not a hard and fast rule but
08:20:35 <marchelzo_> It works well for printf imo
08:20:49 <benzrf> typeclasses violate that, of course, but there's some mitigating factors there
08:21:03 <benzrf> still, abuse of typeclasses can get ugly
08:24:04 <maerwald> benzrf: you mean like reification?
08:24:37 <maerwald> I'd say that's the "strongest" abuse I know of, although it is sort of elegant
08:24:56 <maerwald> elegantly abused :D
08:25:11 <kuribas> marchelzo_: printf can crash a program.
08:25:28 <Intolerable> doesn't lucid do some typeclass mangling?
08:25:32 <Intolerable> that's pretty neat
08:25:40 <kuribas> marchelzo_: http://chrisdone.com/posts/formatting
08:25:41 <benzrf> whats lucid
08:25:45 <benzrf> and whats reification
08:25:47 <benzrf> >:o
08:25:48 <Intolerable> https://hackage.haskell.org/package/lucid
08:25:55 <Intolerable> its a DSL for writing html
08:25:56 <marchelzo_> kuribas: I'm aware, but I don't think it's that bad.
08:26:22 <maerwald> benzrf: I am referring to ftp://madison.deas.harvard.edu/techreports/tr-15-04.pdf
08:26:45 <maerwald> @hackage reflection
08:26:45 <lambdabot> http://hackage.haskell.org/package/reflection
08:29:34 <Haskellfant> the return type overloading is what annoys me most about the haskell regex libraries
08:30:18 <fr33domlover> Q: can I copy built packages from one sandbox to another?
08:31:08 <fr33domlover> alternatively, share dependencies I built between multiple package directories (git repo cloes)
08:31:11 <fr33domlover> *clones
08:31:27 <kuribas> > printf "%d" 22.2
08:31:29 <lambdabot>      No instance for (Show a0)
08:31:29 <lambdabot>        arising from a use of ‘show_M1996330737536092364722’
08:31:29 <lambdabot>      The type variable ‘a0’ is ambiguous
08:31:46 <kuribas> > printf "%d" 22.2 :: String
08:31:47 <lambdabot>  "*Exception: printf: bad formatting char 'd'
08:32:03 <fr33domlover> > printf "%v" 2.22
08:32:04 <lambdabot>      No instance for (Show a0)
08:32:04 <lambdabot>        arising from a use of ‘show_M917264964310234153756’
08:32:04 <lambdabot>      The type variable ‘a0’ is ambiguous
08:32:32 <Haskellfant> fr33domlover: just copying doesn't work afaik. look into stack https://github.com/commercialhaskell/stack which shares them automatically for you when it's possible or nix.
08:32:53 <fr33domlover> Haskellfant, thanks
08:32:57 <S11001001> fr33domlover: you can share a sandbox between trees
08:33:32 <fr33domlover> S11001001, that would be perfect, feels stupid to build the same package 3 times :P
08:33:49 <S11001001> fr33domlover: just make the sandbox where you want it
08:34:03 <S11001001> fr33domlover: and copy the cabal.sandbox.config it creates to each directory where you want to use it
08:34:53 <fr33domlover> I will try this, thanks :)
08:35:38 <S11001001> fr33domlover: or symlink it or whatever.
08:36:13 <Haskellfant> you can also provide the location with --sandbox
08:36:29 <Haskellfant> see https://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes advanced usage
08:38:32 <gfixler> has anyone described Conal's Push-Pull FRP paper in simple Haskell code?
08:38:58 <gfixler> I don't mean an existing FRP framework/library, but more like a translation of each section into tiny, working examples
08:39:42 <gfixler> the paper is very dense for me (non maths guy, little experience with paper/denotational semantics)
08:40:20 <gfixler> A lot of it already looks mostly like Haskell, but it's not quite there
08:41:17 <kuribas> gfixler: It's haskell
08:43:02 <kuribas> The funny symbols are a translation from haskel operators to TeX symbols.
08:43:05 <bitemyapp> gfixler: it's the unicode stuff people use to be fancy.
08:43:37 <gfixler> kuribas: I'm having a hard time believing I can copy to a file and have something that does anything
08:44:06 <bitemyapp> gfixler: I may give it a shot this weekend.
08:44:17 <Haskellfant> I still don't get why people use that unicode stuff
08:44:22 <Haskellfant> it only makes it harder to understand
08:44:49 <gfixler> bitemyapp: ideally it would be this paper, with just fancy unicode stuff flattened out
08:45:12 <gfixler> this is a place I could imagine literate haskell being nice, actually
08:45:32 <gfixler> I'd love to see it in progressive stages, i.e. just the heartbeat of time first
08:45:50 <gfixler> then something that uses time, maybe to create a sine wave, or whatever
08:46:03 <gfixler> then maybe an event, or switcher something or other
08:46:17 <Phillemann> If I want to just serialize/deserialize simple Haskell data structures, what's the simplest library for that? Or is even Read/Show enough?
08:46:24 <bitemyapp> gfixler: I think this is the associated library - https://hackage.haskell.org/package/reactive
08:46:29 <bitemyapp> gfixler: can probably fill in the gaps accordingly.
08:46:47 <kuribas> gfixler: It's probably generated using lhs2TeX
08:46:47 <quchen> Phillemann: Binary is very easy to use. You can derive the instance automatically, so the programming overhead is minimal.
08:46:52 <gfixler> bitemyapp: ah, cool
08:46:53 <quchen> ?hackage binary
08:46:53 <lambdabot> http://hackage.haskell.org/package/binary
08:47:16 <kuribas> gfixler: I don't think they are unicode, probably just created in TeX using kerning, etc...
08:47:23 <quchen> gfixler: Derive a Generic instance for your type (-XDeriveGeneric), and then your Binary instance is simply "instance Binary MyType where".
08:47:49 <Phillemann> quchen: That sounds excellent!
08:50:47 <bitemyapp> gfixler: also: http://stackoverflow.com/questions/4113207/frp-reactive-how-to-use-filtere
08:52:40 <gfixler> bitemyapp: man, warnings on reactive and in the answer about reactive
08:53:11 <bitemyapp> gfixler: s'why I linked it. Doesn't mean you can't learn from it.
08:53:34 <gfixler> bitemyapp: so I guess FRP is a really cool idea that isn't fully fleshed out yet?
08:53:42 <gfixler> I've read similar warnings about other systems
08:53:45 <bitemyapp> gfixler: FRP works fine
08:54:03 <bitemyapp> we just don't have any specific implementations that are universally ideal for all projects.
08:54:04 <gfixler> bitemyapp: the concept, or the implementations?
08:54:15 <bitemyapp> such will never existed, as is the case with all things.
08:54:28 <gfixler> bitemyapp: awww, I thought we could have nice things
08:54:33 <bitemyapp> I'd say it's less mature and still a topic of research, but still a perfectly nice approach.
08:54:40 <Javran> I'm playing around with ghc, wondering how to make ghc generate recursive / non-recursive core expressions? Haskell let-expressions seem to be optimized out even with -O0
08:55:44 <Cale> Javran: Uhhh, if your definition is actually recursive, it should result in something recursive in Core...
08:55:45 <monochrom> x = 0 : x  will give you recursive core expression
08:56:31 <monochrom> your problem has an alternative explanation, likely
08:56:54 <chpatrick> is it possible to recover type parameters with generics?
08:57:36 <Cale> gfixler: Maybe look at reflex if you're interested in using FRP practically -- it's being used in production at several places.
08:58:05 <exio4> reflex is pretty cool, https://www.youtube.com/watch?v=mYvkcskJbc4
08:58:12 <bitemyapp> Javran: https://mail.haskell.org/pipermail/haskell-cafe/2009-February/056248.html
08:58:58 <gfixler> exio4: yeah, I've watched that one, and the other version of it
08:59:06 <Phillemann> I want to execute a series of HTTP GETs, preferably in parallel, and wait for all the results. Schematically: [Url] -> [Future Text] -> Future [Text] -> IO [Text]. What do I use for Future here?
08:59:18 <gfixler> Cale: good thought, though it seems to be about online/UI stuff
08:59:23 <gfixler> I'm looking more for 3D animation
08:59:50 <Cale> gfixler: That's where it's presently aimed, but the core FRP system isn't tied to any particular I/O.
09:00:00 <gfixler> Cale: good to know
09:00:12 <Cale> Technically the web-related stuff is a separate library called reflex-dom
09:00:32 <gfixler> Cale: nice, that increases my interest and confidence
09:00:32 <conal> gfixler: btw, 3d animation is where FRP started, in TBAG, ActiveVRML, and Fran.
09:00:38 <Javran> I see, thanks guys!
09:01:04 <gfixler> conal: I'm *very* curious to see FRP handle something like a full character's 3D animation 
09:01:07 <Javran> btw what about non recursive let expressions, except for top-level definitions?
09:01:39 <conal> gfixler: good. i like curiosity!
09:01:48 <maerwald> gfixler: did you read https://www.cse.unsw.edu.au/~pls/thesis/munc-thesis.pdf ?
09:02:17 <gfixler> maerwald: no, I didn't know this existed
09:02:29 <maerwald> which is the thesis that lead to the implementation of https://wiki.haskell.org/Frag
09:02:58 * hackagebot ekg-carbon 1.0.4 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.4 (OliverCharles)
09:02:59 <gfixler> maerwald: I also didn't realize Frag was made in Haskell
09:14:47 <Javran> okay, I finally made ghc to generate non-recursive let core expr by passing "-fmax-simplifier-iterations=0" to it..
09:17:19 <bdesham> I'm building a Windows DLL. my cabal file's ghc-options include "-o mylibrary.dll", which cabal points out is not necessary
09:17:30 <bdesham> what's the correct way to specify the output filename?
09:17:52 <bdesham> (I note that using the -o option here actually does change the output filename, as desired)
09:32:59 * hackagebot OpenSCAD 0.3.0.2 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.3.0.2 (MikeMeyer)
09:41:17 <haskell274> The mapping y = x is "linear" in the sense that for each x there is a single y, and for each y there is a single x. However y = x^2 does not have this property. What is the mathematical term for this?
09:41:57 <Cale> haskell274: Bijective
09:42:16 <Cale> ("linear" means something else entirely)
09:42:40 <haskell274> Cale: bijective and invertible?
09:42:46 <haskell274> y = x is also bijective
09:42:49 <c_wraith> bijective always implies invertible
09:43:09 <c_wraith> Though it doesn't imply the inverse function is efficient. :)
09:43:10 <Cale> A function between sets is invertible if and only if it is bijective.
09:43:14 <haskell274> but in y = x^2 there are 2 x for each y (except 0)
09:43:32 <haskell274> how are those functions for which there is only a one to one mapping without dupplicate elements
09:43:47 <Cale> haskell274: there are zero choices of x when y is negative
09:44:11 <haskell274> but for positive y there are 2 choices for x
09:44:38 <haskell274> there 2 different x map to the same y
09:44:53 <haskell274> im looking for the names of functions that do not have this property
09:45:06 <haskell274> while still being bijective
09:45:19 <c_wraith> "contradictory"
09:45:28 <c_wraith> bijective means they cannot have that property
09:45:35 <bdesham> you can't have two outputs map to one input with a bijective relation
09:45:40 <Testeree> is there any stack people here? how do i install a local stack package globally?
09:45:42 <edk> that is exactly the property of not being bijective, haskell274
09:45:48 <kadoban> haskell274: I think you misunderstood. y = x^2 isn't bijetive.
09:46:26 <haskell274> y = x^2 for x in R is not bijective then
09:46:46 <haskell274> y = x^2 is only bijective for x in R > 0
09:47:20 <Cale> haskell274: Given a function f: A -> B, and some b in B, the set f^-1{b} = { a in A : f(a) = b } is called the fibre of b. It's the set of elements a in A which are sent to b by the function. If for every b in B, there is at most one element in the fibre of b, then f is called injective, or one-to-one. If for every b in B there is at least one element in the fibre of b, then f is called surjective, or onto.
09:47:30 <c_wraith> Yeah, it's helpful to indicate exactly which sets you're talking about.
09:47:47 <c_wraith> f(x) = x^2 isn't even injective in C
09:47:59 <Cale> If for each b in B there is exactly one element in the fibre of b, then f is called bijective, or invertible.
09:48:38 <edk> if it wasn't obvious from that explanation, bijective is the property of being both injective and surjective
09:48:40 <Cale> A function which is both injective and surjective is easily seen to be bijective.
09:50:17 <Cale> In order to specify a function, you must say what its domain and codomain are. Choosing a different codomain will tend to change the property of being surjective or not (it's always possible to remove elements of the codomain of a function without changing its graph, such that the function becomes surjective, and of course, you can always add elements to the codomain to make it no longer surjective)
09:51:22 <Cale> You can also always restrict the domain of a function (but you must adjust the graph when you do so), such that it becomes injective (even if you have to remove all but one point from the domain to do so)
09:52:10 <c_wraith> This is why there are two different terms sometimes used to describe the results of functions..  codomain and range.  codomain is the specified result set.  range is subset of the codomain that is actually covered.
09:53:06 <Cale> Actually, perhaps a proper set-theoretical definition of function would be good here...
09:53:52 <Cale> Given sets A and B, a function f: A -> B consists of a triple (A, B, G), where G is a set of pairs (a,b) with a in A, and b in B, such that for each a in A, there is exactly one b in B for which (a,b) is in G.
09:54:07 <Cale> A is called the domain of f, B is called the codomain of f, and G is called the graph of f.
09:54:28 <Cale> When (a,b) is in G, we say f(a) = b
09:55:09 <Cale> (and this f(a) notation is unambiguous because of the condition that there is exactly one such b)
09:56:18 <c_wraith> How would you write that last condition more formally..  Forall a. (a,b1) in G and (a,b2) in G implies b1 == b2?
09:56:54 <Cale> Yeah, forall a b1 b2. (a,b1) in G and (a,b2) in G implies b1 = b2
09:57:09 <int-e> c_wraith: that's "at most once", you also need to demand that such a b exists
09:57:17 <int-e> s/once/one/
09:57:18 <c_wraith> oh, yeah, have to quantify all the variables
09:57:19 <Cale> Yeah, that's just the uniqueness part
09:57:21 <haskell274> Thanks guys, now everything is more clear :)
09:57:39 <Cale> You also need to say there exists such b, separately.
09:58:02 <c_wraith> Oh, that's true.
09:58:13 <c_wraith> Otherwise the function is partial.
09:58:20 <c_wraith> well, could be partial
09:59:26 <Cale> haskell274: Yeah, so, a lot of the time, you'll see functions described by equations like f(x) = x^2, and it's often left implicit (sadly especially in introductory materials) what the domain and codomain are. If we insist that the domain and codomain here are both R, then the function being described is really (R, R, {(x, x^2) : x in R})
10:01:49 <Testeree> finally got it to work by adding it as a dependency to the .cabal file instead of stack.yaml ? i thought stack.yaml should suffice apparentlly not. 
10:13:01 * hackagebot jammittools 0.5 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.5 (mtolly)
10:13:29 <eitanChatav> Hi. If I have a `Vector Double` in Haskell what is the best way to `foreign export ccall` it? I.e. what's the right way to convert it into I guess a `Ptr Double`?
10:14:12 <beta_cuckold> why should a new programmer learn haskell whether than lisp?
10:14:20 <beta_cuckold> *rather
10:14:39 <clrnd> beta_cuckold, because lisp has not types
10:14:44 <maerwald> beta_cuckold: I have no idea, should he?
10:15:04 <beta_cuckold> i'm a new programmer trying to figure out whether or not i should learn haskell or lisp
10:15:11 <Cale> eitanChatav: See Data.Vector.Storable and Data.Vector.Storable.Mutable
10:15:26 <beta_cuckold> haskell looks more modern and cool, but lisp seems to have history and universe-creating power
10:15:38 <beta_cuckold> (bear w/ me. i'm a noob.)
10:15:44 <nabokovian> learn both at different times
10:15:55 <clrnd> beta_cuckold, write a lisp in haskell
10:15:56 <nabokovian> that's my haphazard approach. noob here too.
10:16:14 <cite-reader> Yeah, absolutely learn at least a little of both, and then see which one you like better.
10:16:17 <dmj`> eitanChatav: storable yea, access to the C heap, looks like it's an unsafe operation
10:16:19 <dmj`> eitanChatav: https://hackage.haskell.org/package/vector-0.10.12.3/docs/Data-Vector-Storable.html#v:unsafeToForeignPtr
10:16:19 <eitanChatav> Cale: Thanks. I'm confused for those types because they use `ForeignPtr`, rather than `Ptr` which is what the export must be, right?
10:16:55 <beta_cuckold> would you guys say a language like haskell is lisp is better for a beginner than c?
10:17:04 <Intolerable> yes
10:17:05 <chpatrick> yes
10:17:19 <clrnd> beta_cuckold, yeah
10:17:22 <Denommus> beta_cuckold: I would say any language that abstracts memory management somehow is better than C for a beginner
10:17:24 <maerwald> not sure
10:17:31 <clrnd> scheme is almost made for learning
10:17:33 <Cale> eitanChatav: hmm...
10:17:34 <chpatrick> with C there are a lot of machine-level distractions that I don't think are important for a  beginner
10:17:36 <kadoban> beta_cuckold: Absolutely. C is approximately the worst possible language for a beginner. Haskell I think would be pretty good for a beginner, though possibly not the best, hard to say.
10:17:41 <eitanChatav> dmj`: thanks, I'll try to see if I can export `ForeignPtr`
10:17:45 <chpatrick> with haskell you can focus on the logic
10:17:47 <bdesham> beta_cuckold: you're about to learn your first programming language? you don't have any experience yet?
10:17:52 <chpatrick> and if it's wrong it'll tell you :)
10:17:54 <Denommus> I wouldn't bet in Haskell for a beginner. Maybe SML
10:17:55 <kadoban> C's error handling is … awful. Even experts have trouble figuring out where they went wrong.
10:18:03 <c_wraith> C is basically the language of "consult your compiler reference to know what *everything* does".  Seriously, it's amazingly hard to avoid cases of things that appear to work but are technically unspecified behavior in C.
10:18:04 <clrnd> well it depends too, for a beginnner in programming embedable systems, C might be better
10:18:20 <Intolerable> in general though, c is an awful idea if you're just started
10:18:23 <maerwald> it depends on a lot of things
10:18:23 <dmj`> eitanChatav: ForeignPtr is like Ptr, except it *may* be associated with a finalizer, that's just foreign code that is invoked to do cleanup
10:18:24 <Intolerable> *ing
10:18:32 <chpatrick> back in uni they taught us haskell, java, then C in first year
10:18:47 <beta_cuckold> bdesham: yes, and i have nothing but free-time.
10:18:49 <chpatrick> oh and assembly :)
10:18:51 <chpatrick> so higher to lower level
10:18:53 <Cale> There are very few applications these days for which C is really the correct tool to choose imo, now that, for instance, LLVM exists.
10:19:02 <maerwald> the main thing it depends on is interest and motivation, the rest only matters marginally
10:19:05 <c_wraith> eitanChatav, dmj`: potentially multiple finalizers, and they're haskell code
10:19:10 <dmj`> eitanChatav: newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
10:19:21 <Denommus> lots of my colleagues had haskell in the uni, but the professor was awful and they hated it
10:19:37 <Denommus> I had to re-teach Haskell all over again for them to understand how amazing it can be
10:19:46 <dmj`> c_wraith: docs say, "a routine invoked in the foreign language", it may be both.
10:19:56 <bdesham> I'm biased because I learned Lisp (Clojure specifically) before Haskell (with many others before both), but I'd lean toward learning Lisp first
10:20:01 <dmj`> c_wraith: "Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object."
10:20:11 <chpatrick> as for lisp: tbh I haven't used it much but I hate the parentheses, I think a bit more syntax is good. and Haskell's type system is fantastic
10:20:12 <clrnd> Denommus, simillar experience, mosth thought it was only for proving series by induction
10:20:16 <c_wraith> dmj`: In that it might be an FFI call, sure.  But there's no requirement.  Finalizers can be any haskell code
10:20:17 <beta_cuckold> bdesham: granted, i have dabbled with c, but quit and mind-boggling nested for loops. i didn't learn much that stuck; pointers still make zero sense and i never made anything more than file i/o.
10:20:35 <Denommus> I'd lean toward neither. Probably Scheme or SML are better, because they are cleaner and more focused
10:20:57 <chardan> beta_cuckold: I find it actually doesn't matter what language you learn first. You get different things from all of them. I'd say that whatever you learn, you should try to learn it /well/ so that you make the most of it. Then again, I only learned a first language once. :-) 
10:21:13 <chpatrick> my first language was pascal lol
10:21:18 <chpatrick> then perl
10:21:28 <chardan> chpatrick: Clearly, life's done for you! ;-)
10:21:36 <Intolerable> chardan: it might not matter which one you learn first, but if your first language dissuades you from programming it's probably not idea
10:21:38 <Intolerable> *ideal
10:21:40 <chpatrick> uses crt
10:21:42 <Cale> I learned Haskell before Lisp and was really disappointed in Common Lisp, and well, Scheme is okay, but unless ease of implementing an interpreter was a consideration, I'm not sure I'd choose it over Haskell for something. I can't really stand to live without types.
10:22:06 <Cale> It's so frustrating to spend an hour tracking down a bug in your Scheme program to find out it would have been caught and pointed out by the typechecker.
10:22:08 <beta_cuckold> quick question (very noob-like): if lisp is so powerful, why does haskell seemingly have a larger, more united and dedicated community and a bigger increase in its application?
10:22:16 <Cale> (if you had a typechecker, that is)
10:22:25 <beta_cuckold> like, i hear you can create universes and AIs in lisp
10:22:36 <Cale> beta_cuckold: What does "create universes" mean?
10:22:38 <chpatrick> beta_cuckold: no more than in anything else
10:23:01 * hackagebot json-rpc-client 0.2.0.0 - JSON-RPC 2.0 on the client side.  http://hackage.haskell.org/package/json-rpc-client-0.2.0.0 (grayjay)
10:23:03 <beta_cuckold> Cale: unreadable code only you can understand, from what i've gathered
10:23:03 <chpatrick> people just worship lisp because it was very early and very powerful for its time
10:23:08 <Cale> beta_cuckold: Probably you're misinterpreting someone's poetry about their emotional reaction to lisp.
10:23:09 <chpatrick> and a lot of people learnt it in college
10:23:10 <magneticDuck> beta_cuckold: I imagine you mean it the other way around
10:23:11 <kadoban> beta_cuckold: "create universes" is basically nonsense? I consider haskell more practical and fun, personally. The type system is great and it has fun/useful abstractions.
10:23:21 <chardan> Intolerable: It depends on what you want to get out of it. For instance, C++ or Python might be like deciding whether you want to play violin (where you'll probably suck for years) or guitar (you might not be /great/ at it, but you can sound ok and make some music pretty quickly).
10:23:29 <bdesham> there are *many* different flavors of lisp: clojure, common lisp, scheme, arc... lots of overlap, of course, but code written for one often needs to be adapted to some extent to work on the others
10:23:41 <maerwald> Cale: it sounds like he meant something like "turing completeness"... then again it doesn't make a lot of sense to say "lisp is turing complete", because well, err
10:23:49 <Denommus> beta_cuckold: Lisp is good, but it's never the best language that could possibly exist. Lisp advocates are just too excited about it
10:23:55 <chpatrick> it's just an xkcd reference right?
10:24:01 <merijn> hmmm
10:24:05 <chpatrick> at the end god says it's all hacked together in perl :P
10:24:07 <dmj`> c_wraith: sure, the finalizer itself isn't even a requirement
10:24:09 <bdesham> https://xkcd.com/224/
10:24:15 <merijn> Is there a sensible way to avoid the explicit type application in System F?
10:24:18 <Intolerable> chardan: i know what you mean, but recommending someone a language that will frustrate them unnecessarily (c / brainfuck etc.) is a bad idea
10:24:22 <Cale> maerwald: I imagine it might refer to the use of macros to create embedded languages. But we do a lot of that in Haskell too, both with and without macros.
10:24:28 <Denommus> beta_cuckold: all Lisp does is having great metaprogramming capabilities, but at the end of the day most people don't actually need that so much
10:24:34 <Intolerable> chardan: assuming our goal is "encourage people to program"
10:24:55 <chardan> Intolerable: Yeah, I usually ask what it is they want out of the experience. I probably wouldn't suggest C first either, myself.
10:25:08 <chpatrick> I think Haskell is a great choice
10:25:19 <chpatrick> it's easier to go lower level than higher
10:25:25 <chpatrick> and haskell's pretty high-level
10:25:28 <beta_cuckold> so, haskell >= lisp > C, in regards to what my first language should ultimately be?
10:25:33 <Cale> One thing that Lisp (or really Scheme) has going for it as a recommended language for learning is that SICP uses Scheme.
10:25:36 <Denommus> beta_cuckold: Haskell is good for other reason: it has a very powerful type system, which makes writing correct programs easier than writing incorrect programs. Also, it is pure, so you can reason about your program in terms of eta-expansion
10:26:09 <tzaeru> I still tend to almost always suggest python. almost always as in 99% of time. @_@
10:26:12 <maerwald> beta_cuckold: you missed shell before haskell :P (unless you know it)
10:26:23 <ystael> Denommus: Some Lisps are good practical compromises for other reasons; we chose Clojure over other functional languages for some projects at my work because of pre-existing commitment to the JVM
10:26:25 <chardan> beta_cuckold: I think it's worth going for something strongly typed. You will likely get good habits and focus out of it, and any frustration from it is probably going to be subsumed into the frustration you'll feel anyway. :)
10:26:26 <Cale> But you can learn Haskell and read SICP, and a lot of what SICP says will make perfect sense to you.
10:26:51 <Cale> (well, it introduces enough about scheme on its own to make sense)
10:27:02 <Denommus> ystael: well, but that's not a specific quality from a Lisp. You could just as well have chosen Kotlin
10:27:25 <beta_cuckold> in my dablling with c, stuff like nested for loops and pointers blew my mind. will haskell making understanding those concepts easier?
10:27:38 <Cale> beta_cuckold: Possibly.
10:27:43 <clrnd> beta_cuckold, mmm no, but a lot of other more general and interesting things, yes
10:27:47 <clrnd> ok lol
10:27:55 <maerwald> beta_cuckold: mostly no
10:27:57 <Cale> beta_cuckold: However, initially, you won't be using for loops or pointers.
10:28:02 <eitanChatav> Cale, dmj`, c_wraith: Apparently, `ForeignPtr a` is an "unacceptable" result type in a foreign declaration.
10:28:17 <merijn> Do we have a bot tracking when users were last seen again?
10:28:18 <__009__kk> Learning CL right now. Coming from Haskell it is awful. Any key lisp concepts I should pick up before switching back?
10:28:25 <Cale> But when you do come to them later, you'll see them in a more structured setting which might help things be clearer.
10:28:25 <beta_cuckold> honestly, do we really NEED c?
10:28:29 <kadoban> beta_cuckold: Possibly, eventually. A lot of it is more … you won't have to care anymore. C has very low-level and broken abstractions that it's better to not care about.
10:28:37 <c_wraith> eitanChatav: that's true.  Foreign declarations need to return Ptr a instead
10:28:40 <Denommus> beta_cuckold: Haskell deals with loops in a completely different way from C. And it also deals with variables in a completely different way
10:28:59 <c_wraith> eitanChatav: if you later need to convert it to a ForeignPtr, you would do that in Haskell code
10:29:01 <Denommus> beta_cuckold: so talking about pointers in Haskell only make sense under some very, very specific contexts
10:29:09 <tzaeru> beta_cuckold, in practical terms, sometimes. just rarely.
10:29:12 <eitanChatav> c_wraith: Right, so what's the best way to get a `Vector Double` converted into a `Ptr Double`?
10:29:17 <beta_cuckold> loving the interactive and quick-respond community here.
10:29:20 <kadoban> beta_cuckold: At some point we need something like C, for quite niche uses. The vast majority of programs should absolutely not be written entirely in C.
10:29:27 <Cale> __009__kk: heh, I had the same impression myself. Scheme is a lot less horrible at functional programming than CL, if you're going to use a lisp.
10:29:37 <merijn> edwardk: ping? :)
10:29:38 <c_wraith> eitanChatav: Data.Vector.Storable ?
10:29:51 <Denommus> kadoban: in the near future, I hope I may say "no new programs should be written in C"
10:30:35 <merijn> Ugh, my free + bound AST was looking so nice and elegant and then System F had to go bollocks it up >.<
10:30:37 <tzaeru> I'll excitedly wait for the "no new programs should be written in C++"
10:30:40 <hodapp> C is important at the moment at least as a sort of intermediate format that can, when necessary, be written by hand.
10:30:50 <Cale> __009__kk: The fact that Common Lisp puts functions and other values in separate namespaces is pretty obnoxious if you're trying to program in a functional style, but my impression is that most CL programmers actually avoid doing functional programming most of the time (even if it's possible).
10:30:57 <hodapp> but it may be sensible in plenty of instances to have programs generate C code for you.
10:31:15 <c_wraith> eitanChatav: If you're using Data.Vector.Storable, there are options like unsafeWith
10:31:17 <hodapp> tzaeru: oh, for the day...
10:31:24 <Cale> __009__kk: Maybe look into stuff surrounding macros, if you haven't yet.
10:31:49 <tzaeru> been having to write some c and c++ recently again, I had forgotten how verbose it ends up being
10:31:54 <cite-reader> Common Lisp also does not guarantee tail call optimization either, IIRC, though SBCL for example will go ahead and do it anyway.
10:31:55 <kadoban> tzaeru: That's already pretty much true, IMO, though it's debateable and tends to just turn into a flamewar.
10:32:00 <eitanChatav> c_wraith: I can `convert` my `Vector` into a `Storable` `Vector`
10:32:04 <catgocat> I don't understand, why does repeat' x = x:repeat' x work? The `:` operator works with lists, but where does this define a list? 
10:32:27 <catgocat> I understand the recursion, just not the list thing
10:32:35 <Cale> catgocat: (:) constructs a list from an element and another list
10:32:41 <hodapp> kadoban: What would be an example of something that's not debatable
10:32:42 <hodapp> ...?
10:32:50 <sunnymilk> is there a nice short-circuiting fold function somewhere
10:32:50 <tzaeru> kadoban, for majority of software, it's true yea. I still wouldn't write my new high-performance AI toolbox and AI design environment in anything but C++ :P
10:32:51 <catgocat> Cale: But repeat' x is not a list, so how does it do that?
10:32:53 <Cale> catgocat: repeat' x is a list
10:32:55 <tzaeru> the actual AIs though can as well be anything else
10:33:01 <c_wraith> eitanChatav: if at all possible, you should be working with Storable vectors anyway, when your goal is FFI stuff
10:33:04 <catgocat> Cale: how???
10:33:04 <eitanChatav> c_wraith: but I still don't know how to convert it to a `Ptr` and none of the functions in `Data.Vector.Storable` seem to have `Ptr` as a result type
10:33:07 <sunnymilk> something like (a -> b -> Either b b) -> b -> [a] -> b
10:33:11 <Cale> catgocat: Because it's the result of (:)
10:33:18 <sunnymilk> where Left means stop and right means keep recursing
10:33:27 <catgocat> Cale: If I do something like 3:3 it generates an error
10:33:31 <c_wraith> eitanChatav: why do they need to have it as a result type?
10:33:32 <Cale> catgocat: that's right.
10:33:36 <eitanChatav> c_wraith: that's only one goal
10:33:41 <Cale> catgocat: Because 3 is not a list, just as x needn't be in this case.
10:33:43 <MarcelineVQ> > 3:[3]
10:33:44 <lambdabot>  [3,3]
10:33:49 <Cale> > 1 : [2,3,4]
10:33:51 <lambdabot>  [1,2,3,4]
10:34:01 <eitanChatav> c_wraith: in order that I can `foreign export ccall`
10:34:07 <catgocat> Cale: But in that case repeat' x = x:repeat' x, I don't see any brackets, so how does it know it's a list?
10:34:24 <merijn> catgocat: Because "repeat' x" returns a list?
10:34:24 <kadoban> hodapp: Heh, there's not many probably. I just mean I can't objectively give a convincing argument to the other side that they should abandon C++ … our ability to judge and compare languages, as a programming community, is pretty rudimentary at this point.
10:34:29 <Cale> catgocat: Every list is either the empty list, written [], or it is a nonempty list formed as (x:xs) from a first element x, and a list (the "tail") xs.
10:34:36 <MarcelineVQ> > 3:3:3:3:3:3:[]
10:34:38 <lambdabot>  [3,3,3,3,3,3]
10:35:03 <Cale> catgocat: The square bracket notation [1,2,3] is syntax sugar for 1 : 2 : 3 : []
10:35:05 <catgocat> Cale: oh ok, so that syntax only works for parameteres, not actual values
10:35:10 <beta_cuckold> so, it seems the consensus is that c is still very usefull nowadays and will get you a job, etc.
10:35:11 <Cale> that is, 1 : (2 : (3 : []))
10:35:18 <Cale> catgocat: what?
10:35:21 <merijn> beta_cuckold: Naah
10:35:29 <merijn> beta_cuckold: You're better off knowing C++
10:35:32 <beta_cuckold> what about haskell? will it get me a job (without a degree)?
10:35:33 <tzaeru> beta_cuckold, well, here where I am, I haven't really seen a single C job ad in months..
10:35:35 <c_wraith> eitanChatav: oh, I missed that it's a foreign *export*.  ok.  look at the type of (unsafeWith v return)
10:35:36 <Cale> catgocat: The list literal syntax works in both expressions and patterns
10:35:46 <catgocat> Cale: nevermind, I got it thanks
10:35:49 <tzaeru> there are some that would require C++, but they are usually jobs that entry-level programmers wont be getting anyway
10:35:51 <MarcelineVQ> > take 2 $ 3:3:3:3:3:[]
10:35:52 <lambdabot>  [3,3]
10:36:01 <Cale> catgocat: But it's not required in order to define a list -- there are lots of other ways to construct lists
10:36:05 <c_wraith> eitanChatav: also, convert will... convert... between vector types
10:36:11 <silver> > [id 1]
10:36:12 <lambdabot>  [1]
10:36:14 <eitanChatav> c_wraith: nice!
10:36:24 <Cale> catgocat: (and in some sense (:) and [] are the most primitive ways)
10:36:26 <catgocat> Cale: sure, I was just interested in that particular case
10:36:29 <Denommus> beta_cuckold: Haskell doesn't have nearly as much market as C++. But a beginner should worry about learning how to make programmers. When he knows how to make programs, he may start worrying about learning something useful for the market
10:36:40 <bdesham> speaking of which, is there any specific place (other than the subreddit) where people post haskell hiring ads?
10:36:41 <Denommus> beta_cuckold: my first language was Pascal, and nobody uses Pascal nowadays
10:37:01 <hodapp> Denommus: as if the market even knew what it wanted :P
10:37:02 <eitanChatav> yeah, I will use `convert` to convert a normal `Vector` to a `Storable` one and then `unsafeWith v return` to get a Ptr
10:37:07 <Cale> Denommus: you mean programs, rather than programmers. You can worry about making programmers once you're an expert ;)
10:37:16 <silver> :)
10:37:23 <tzaeru> Denommus, ..and after some years, we first get into the market, get a job, then start to think about maybe learning whatever the job needs
10:37:23 <hodapp> Cale: Or, when you think you're one.
10:37:36 <tzaeru> or, if we're true professionals, we never bother to learn it properly, but just copy+paste code around and shout at our coworkers.
10:37:49 <c_wraith> eitanChatav: note the reason for the "unsafe" warning on unsafeWith.  Be careful what's done with the returned pointer.
10:38:07 <hodapp> tzaeru: And so begins the first step down the road of, "Dude, fuck this shit."
10:38:21 <tzaeru> indeed.
10:38:23 <Denommus> Cale: yeah
10:38:46 <Denommus> Cale: muscle memory
10:39:23 <Denommus> hodapp: I'm assuming it does, considering his question
10:39:25 <eitanChatav> c_wraith: Thanks. I'll be careful. In the end I'm calling this from Rust so I should be able to get some type safety/immutability.
10:39:41 <c_wraith> eitanChatav: also, there are potentially issues regarding garbage collection..  If nothing else keeps that Storable vector around, it might get GC'd
10:39:44 <ttk> Hi Guys. I am doing exercise 2 here: http://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf and I am looking for ways to improve it. I do not like the EQ case in particular, but I cannot figure out how to make it much better. My code is here: http://lpaste.net/136114
10:39:45 <Denommus> hodapp: in general, I just say "do your work in whatever you feel comfortable. Clients just care about working programs, not about what stack you used"
10:40:14 <hodapp> Denommus: That's why I'm using Haskell for embedded systems at my current job.
10:40:24 <eitanChatav> c_wraith: Hmm, that is a concern...I'll have to see if that will cause bugs
10:40:47 <silver> hodapp, what kind of systems?
10:40:52 <c_wraith> eitanChatav: in fact, unsafeWith is probably the wrong choice.
10:41:00 <hodapp> Denommus: The tricky part can be getting the access to the clients, and cutting out the middlemen who care deeply which tool, toolbox, or toy with sharp edges (sometimes people confuse those with tools) you used.
10:41:07 <eitanChatav> c_wraith: aww man, so is there a better way?
10:41:09 <Denommus> hodapp: I would probably try to use Rust, in that case. Rust is meant to things like that, and I guess it could use some help on somebody porting it
10:41:14 <hodapp> silver: Cortex-M0 via Ivory
10:41:24 <c_wraith> eitanChatav: I think there's some Storable cleverness possible.  Maybe.
10:41:33 <silver> nice
10:41:49 <hodapp> Denommus: I'm using Haskell *for* embedded systems, not *on* them. There's a little differenc, in that I have no Haskell runtime on my target.
10:42:00 <hodapp> +e
10:42:22 <hodapp> Denommus: so, I have heard that Rust has had some success on embedded systems, but in this case, the runtime may be far too heavy.
10:42:31 <eitanChatav> c_wraith: that's kind of vague :-/
10:42:57 <c_wraith> eitanChatav: still looking for details.  need a minute or two to typecheck..
10:43:07 <Denommus> hodapp: you can drop Rust's runtime
10:43:17 <eitanChatav> c_wraith: sure, no problem! thanks for the help :-)
10:43:17 <cite-reader> Rust can ditch its runtime if you use #![no_std] and friends. Though admittedly I think the embedded story isn't fully baked yet.
10:43:38 <Denommus> cite-reader: it's not. That's why I said it could use some help
10:43:53 <hodapp> cite-reader: I'd never heard yet it was a possibility to completely ditch the runtime and get it to use whatever cross-compiler I need.
10:43:57 <hodapp> cite-reader: but I need to read more about it.
10:44:34 <hodapp> Really, though, I've been pleased enough with Ivory & Haskell that I doubt switching the whole project to Rust is going to happen anytime soon.
10:44:50 <Denommus> hodapp: Rust is aimed to be just as low level as C and C++, so of course it must support ditching the runtime
10:45:00 <Denommus> hodapp: nah, I'm not saying you should
10:45:15 <Denommus> hodapp: I'm just saying what I would have done
10:45:53 <dmj`> MultiWayIf FTW
10:46:50 <hodapp> Denommus: I'm looking at Zinc and I don't know if it has a reasonable chance of supporting the hardware.
10:46:53 <felixn> https://gist.github.com/munro/c51d5a0fba50e97a6bd9 <-- is there a more succinct way to write this?  I'm grossed out every time I look at it :D
10:47:30 <c_wraith> eitanChatav: Ok, this will take me another 10-ish minutes.  So long as I'm doing it, I want to do it absolutely right.
10:47:53 <eitanChatav> c_wraith: haha, no problem. btw, `unsafeWith` code compiles
10:48:03 <Denommus> hodapp: as I said to cite-reader, yes, Rust is not ported everywhere as C is. That's why I mentioned it could use some help
10:48:03 * hackagebot csound-expression 4.8.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.8.1 (AntonKholomiov)
10:48:05 * hackagebot csound-catalog 0.2.2 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.2.2 (AntonKholomiov)
10:48:15 <c_wraith> eitanChatav: I'm sure it compiles, but I'm very worried about safety with the garbage collector around.
10:48:31 <c_wraith> eitanChatav: and it's kind of bad to claim haskell is a safe language then have memory corruption issues. :)
10:48:34 <Cale> felixn: Which monad?
10:48:55 <felixn> Cale: I've been google for away to handle exceptions without IO, but it's the list monad
10:49:00 <Cale> appType@(TypeFn fn_pres fn_posts _) <- applicationType getType value   will work in any monad for which fail s is the same as mzero
10:49:08 <beta_cuckold> wouldn't ASM be a more preferable first language, as it teaches you about computer architecture and 'under the hood' stuff?
10:49:13 <dmj`> felixn: use fmap
10:49:15 <Cale> in particular, it'll work in the list monad, yes
10:49:19 <felixn> Cale: woah, I don't believe you ... let me check
10:49:44 <Denommus> beta_cuckold: why do you think it's better to start bottom-up instead of top-down?
10:49:45 <hodapp> Denommus: What I'm talking about is that I see it running on a Cortex-M3 board with 64 KB SRAM, and a Cortex-M4 with 192 KB of SRAM. I am on a Cortex-M0 with 8 KB RAM that I have available to work with.
10:49:47 <dmj`> yea, or just the maybe monad
10:50:25 <felixn> Cale: holy monad transformations, it worked!  just had to pop an extra return on it: appType@(TypeFn fn_pres fn_posts _) <- return (applicationType getType value)
10:50:28 <hodapp> Denommus: so I am curious how well it would adapt to something with a fraction of the memory.
10:50:41 <Cale> felixn: Ah, right, of course.
10:50:51 <Denommus> hodapp: I don't know how heavy runtime-less Rust is
10:51:03 <Denommus> hodapp: but it's probably not a lot
10:51:39 <Denommus> beta_cuckold: the most important thing about programming is actually knowing about how to abstract specific concepts into general ones and fitting everything together to create a system
10:51:51 <Cale> felixn: If you're really golfing you might just write [applicationType getType value] :)
10:51:54 <Welkin> beta_cuckold: what a name
10:52:04 <Welkin> when will cuckold be out of beta?
10:52:11 <Denommus> beta_cuckold: then, if your program NEEDS to interact directly with the computer's architecture, you'll need something like ASM. But most programs don't need that
10:52:12 <hodapp> Denommus: if you can tie this figure down more than 'probably', let me know. I'm working around a pretty annoying API here that loves to hog RAM.
10:52:13 <Cale> (assuming it's just the list monad)
10:52:39 <Denommus> hodapp: I guess #rust in irc.mozilla.org can answer that for you
10:52:45 <hodapp> Denommus: but there is definitely a cognitive cost of not running Haskell directly on this CPU, but rather, running Haskell code which generates C code which runs on this CPU
10:52:56 <hodapp> so being able to actually target Rust might have promise
10:53:03 * hackagebot old-version 1.3.2 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.3.2 (chrisdotcode)
10:53:10 <beta_cuckold> denommus: i was under the impression that computer architecture and low-level manipulation was harder than algorithmic theory and such. (i'm really just regurgitating what i've read from forums and SO to see what actually rings true.)
10:54:15 <hodapp> beta_cuckold: So why would you learn the more difficult, more capricious details *first*?
10:54:34 <Denommus> beta_cuckold: I'm not talking about what is more difficult, but about what's more fundamental
10:55:15 <Denommus> beta_cuckold: why would you want to learn differential calculus before knowing the four basic operations?
10:55:26 <hodapp> beta_cuckold: Not to mention, most of these details aren't particularly fundamental (as Denommus is hinting at); they're incidental.
10:55:33 <beta_cuckold> as stated on SO somewhere, doing so established a "good foundation" and makes everything thereafter easier than it would be in the inverse.
10:56:03 <hodapp> beta_cuckold: starting out by writing programs that target incidental hardware details is rarely good practice.
10:56:15 <Denommus> beta_cuckold: the problem is that most people think that the most fundamental part of computer science are computers
10:56:18 <Welkin> beta_cuckold: computers are very simple machines at the logic gate level
10:56:18 <Denommus> beta_cuckold: it's not
10:56:32 <Cale> Welkin: Uhhh... kinda :)
10:56:35 <Denommus> beta_cuckold: computers are just a specific way people came up on how to automate computations
10:56:50 <Welkin> semiconductors are used to make transistors, transistors are placed in a specifc formation to create a logic gate, logic gates are wired together to creates a more complex circuit
10:56:54 <Denommus> beta_cuckold: the most fundamental concept of computer science is computation, which is a mathematical concept
10:57:18 <larsrh> Who runs the haskell-cafe?
10:57:31 <Cale> They're "very simple" in a way which involves the fact that nobody in the world actually understands the complete functioning of a modern CPU in its entirety, because computers are actually responsible for a large amount of their construction.
10:57:51 <Cale> (and there is a lot of division of labour as well)
10:58:22 <beta_cuckold> "... because computers are actually responsible for a large amount of their construction."
10:58:32 <beta_cuckold> isn't that a bit...dangerous?
10:58:40 <Cale> how so?
10:58:57 <Cale> We have programs which do circuit layout according to constraints.
10:59:17 <Denommus> beta_cuckold: it's less dangerous to trust automatic computers to do repetitive tasks than to trust in human beings
10:59:18 <MarcelineVQ> he's worried that the sigularity is gonna be skynet
10:59:25 <Cale> Various aspects of those programs' behaviour are mathematically proven to be correct.
10:59:34 <Denommus> MarcelineVQ: I doubt that's what he's worried about
10:59:36 <benzrf> "beta_cuckold"
10:59:41 <benzrf> great nick
10:59:47 <hodapp> Denommus: dramatically so in many cases...
10:59:55 <MarcelineVQ> Denommus: there's no other way that could be dangerous
11:00:15 <Welkin> Cale: under certain conditions
11:00:16 <Cale> MarcelineVQ: There are plenty of ways it can be dangerous
11:00:28 <Welkin> radiation can cause unpredictable behavior
11:00:42 <Cale> MarcelineVQ: Computers are put into lots of scenarios where incorrect behaviour will result in loss of human life.
11:00:48 <Welkin> which is why computers in space must have radiation shielding
11:00:50 <beta_cuckold> Cale: Denommus: it seems AI-ish, like they're treading self-awa... nevermind. i have no idea what i'm talking about.
11:00:58 <c_wraith> I can never remember..  What's fromRational .toRational called?
11:01:04 <hodapp> beta_cuckold: think more math, less movies.
11:01:13 <Cale> beta_cuckold: The danger of this automation has nothing to do with AI :)
11:01:23 <kadoban> They're simply tools for engineers that do this stuff, though they're quite complicated tools.
11:02:06 <Denommus> beta_cuckold: hah, no, the principle is not very different on how compilers translate code and are able to optimize it
11:02:19 <Cale> It *is* to some extent risky, but very sophisticated tools are used to manage that risk -- the designs of CPUs are now so complicated that it's completely out of the range of human capacity to do it manually and verify all that must be verified.
11:02:20 <Denommus> beta_cuckold: it's very far away from AI
11:02:23 <c_wraith> :t fromRational . toRational
11:02:24 <lambdabot> (Fractional c, Real a) => a -> c
11:02:29 <Denommus> beta_cuckold: that's a bit too much for you to worry about right now, though
11:03:11 <Cale> beta_cuckold: But it's more risky due to the extent that we end up relying on CPUs than anything to do with "oh no, computers are going to take over the world"
11:03:15 <c_wraith> :t realToFrac
11:03:17 <lambdabot> (Fractional b, Real a) => a -> b
11:03:19 <Welkin> that is why we have Hardware Description Languages
11:03:24 <Welkin> VHDL and Verilog
11:03:38 <hodapp> and things like Clash and Lava :P
11:04:50 <beta_cuckold> a quick query shows that lisp is like THE AI programming language. what about haskell? can it be used for AI programming?
11:04:55 <Cale> beta_cuckold: Sure.
11:04:57 <Welkin> it is not
11:05:07 <Welkin> that is only historically true
11:05:11 <Welkin> because of the MIT AI lab
11:05:16 <hodapp> beta_cuckold: that's probably because the guy who made Lisp is the guy who coined the term AI.
11:05:24 <Jello_Raptor> hmm, any suggestions on making this neater? http://lpaste.net/136116
11:05:29 <Cale> beta_cuckold: Haskell can really be used for *most* things.
11:05:31 <beta_cuckold> also, what about embedded systems, as i'm interested in electrical engineering too, like programming arduino products and stuff.
11:05:33 <Denommus> beta_cuckold: I have been a Lisper in the past. Believe me when I say that Lisp is VERY overrated. Very.
11:05:34 <Welkin> there is no reason to use lisp over other languages for AI
11:05:46 <hodapp> beta_cuckold: join #haskell-embedded.
11:05:49 <koala_man> in Europe, the historical AI language was Prolog
11:06:17 <hodapp> koala_man: interesting.
11:06:22 <c_wraith> eitanChatav: http://lpaste.net/136117
11:06:23 <Cale> beta_cuckold: For embedded systems with very limited memory and clock rates, you're better off using Haskell as a metalanguage (i.e. your Haskell program, when run, will emit the program which will run on the embedded hardware)
11:06:32 <c_wraith> eitanChatav: turned out to be a relatively small amount of code.
11:06:34 <Denommus> beta_cuckold: Haskell can be used for embedded systems, but C is the most popular language in this area. As I was discussing with hodapp, Rust is also showing itself promising in that
11:06:39 <Cale> beta_cuckold: There have been some very successful uses of this technique.
11:06:40 <hodapp> one of these days(tm) I need to learn Prolog and Mercury
11:06:52 <Cale> http://hackage.haskell.org/package/atom
11:07:02 <c_wraith> eitanChatav: notes - 1. take the advice in the comment  2. CDouble gives better compatability guarantees
11:07:08 <Denommus> beta_cuckold: and if you want to learn a low-level language, there's no better language of that kind for a beginner to learn than Rust: http://www.rust-lang.org/
11:07:33 <eitanChatav> c_wraith: cool, looks good! thanks!
11:07:34 <Cale> ^^ Atom is a Haskell EDSL for designing hard realtime embedded software. It's been put to use in writing the control software for hybrid hydraulic vehicles.
11:08:05 <hodapp> Cale: and sadly, most of the docs and examples are at this point written by me.
11:08:16 <beta_cuckold> so, haskell is equally capable at the level (embedded systems) but just not as popular as alternatives, or is it not as popular as alternatives due to not being preferable for the job?
11:08:21 <Cale> hodapp: Oh, are you Tom?
11:08:39 <hodapp> Cale: No, but the docs that he left were a bit limited.
11:08:45 <Cale> ah, I see :)
11:08:47 <Jello_Raptor> beta_cuckold: I'd argue that without an EDSL, it isn't as good for the job. 
11:09:10 <hodapp> Cale: I'm in the process of reimplementing Atom in a form that targets Ivory rather than generating C code directly.
11:09:30 <Jello_Raptor> that said i'm pretty sure Galois uses haskell for embedded development because it makes security proofs easy. 
11:09:38 <hodapp> Jello_Raptor: Ivory is from Galois.
11:09:45 <hodapp> Jello_Raptor: So is Cryptol.
11:10:00 <Cale> beta_cuckold: Well, you wouldn't use Haskell *directly* to program such systems, but Haskell is especially strong when it comes to writing programs which write other programs (compilers and the like), so it can be used profitably in that space.
11:10:08 <Jello_Raptor> hodapp: huh, i've played around with Cryptol, though this is the first i've heard of Ivory. 
11:10:23 <hodapp> Jello_Raptor: it's some very interesting work.
11:10:52 <hodapp> Jello_Raptor: sadly, lacking in docs in a lot of spots, but I'm trying to help out a little there.
11:11:10 <hodapp> the papers they're writing have a lot of good explanation though.
11:11:51 <Jello_Raptor> hodapp: fun
11:11:54 <Cale> beta_cuckold: Well, I shouldn't say that without qualification. Some "embedded" systems these days can stand to have a lot of memory and fast CPUs. You can run Haskell programs on anything as powerful as a smartphone from the last few years.
11:12:18 <hodapp> 'embedded' can mean a lot of things
11:12:32 <Cale> (and theoretically, you could run them on much smaller machines, but GHC doesn't really try to optimise for that case)
11:12:32 <MarcelineVQ> i almost always think of vending machines when​ I think of embedded
11:12:39 <hodapp> Cale: 
11:12:49 <hodapp> christiaanb's work with CLaSH is pretty interesting here
11:13:01 <hodapp> it targets a considerable part of Haskell to FPGAs
11:13:24 <Cale> Yeah, that's certainly interesting :)
11:13:37 <hodapp> Reduceron too.. though most of that goes right over my head
11:14:08 <Cale> Yeah -- I'm not sure you could use the Reduceron in an embedded setting on its own, but perhaps :)
11:14:40 <hodapp> I have only a hazy idea how Reduceron works or what it does.
11:14:43 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56 -- I wish this video weren't broken. Tom's talk was pretty good.
11:15:05 <Cale> I guess the .avi link works.
11:16:51 <beta_cuckold> what does haskell's future entail? death or prosperity (in its application/popularity). i'd hate to learn a dying language, and i've seen mixed comments regarding this.
11:17:02 <dmj`> beta_cuckold: facebook uses it
11:17:22 <Welkin> beta_cuckold: you have seen mixed comments? from who?
11:17:23 <Cale> beta_cuckold: Haskell isn't going anywhere. In fact, it's already getting too stable to keep my interest. :P
11:17:29 <Welkin> I have only ever heard positive things about haskell
11:17:34 <hodapp> Most reports on the death of a language are greatly exaggerated.
11:17:47 <Welkin> and have been using it personally and professionally for 1.5 years now
11:17:53 <Welkin> I have only seen it grow in popularity
11:17:55 <Welkin> and become more refined
11:17:58 <kadoban> beta_cuckold: Languages really don't die … and haskell is growing, not shrinking.
11:18:00 <Cale> I want a new lazy dependently typed language which doesn't exist yet :D
11:18:41 <Welkin> beta_cuckold: it is also hard to not think about your nickname when watching the conversation
11:19:03 <Welkin> it sounds like someone out of silicon valley
11:19:19 <Cale> It sounds like someone out of 4chan, tbh :D
11:19:20 <bdesham> I used the MinGHC installer on Windows. Is there any easy way to get a copy of the base module built as a shared library?
11:19:25 <Welkin> cuckold services for rich white men -- currently in beta!
11:19:30 <jackhill> I hope haskell continues to grow. I like the language and the community a lot, but am aware that when I do things in haskell, I can communicate with fewer and less varied people than if I were to use a "popular" language.
11:20:40 <porglezomp>  Welkin: I'm pretty sure the name is a parody (I hope it's a parody) of "red pill" culture
11:21:57 <porglezomp> where beta is the opposite of alpha, as in "alpha male"
11:23:17 <beta_cuckold> Welkin: well, quora users seem to agree with you guys -- the haskell is growing, but the following YouTube channel begs to differ:
11:23:20 <beta_cuckold> https://www.youtube.com/channel/UCNGLum1Lx0nDD2sNBGQ-V1Q/search?query=haskell
11:23:33 <beta_cuckold> *that
11:24:15 <silver> hodapp, what's the difference between atom and ivory? and what are benefits for atom to target ivory instead of C?
11:24:16 <MarcelineVQ> something about that search page..
11:24:28 <MarcelineVQ> is deeply unsettling
11:25:12 <Welkin> why does the popularity of a language matter?
11:25:23 <Welkin> there is no correlation between quality and quantity
11:25:23 <sunnymilk> is there a nice short-circuiting fold function somewhere in the standard library
11:25:29 <sunnymilk> or a way to make foldr short circuit
11:25:57 <Welkin> I don't use something because it is popular, I use it because it best fits my needs
11:25:59 <Cale> sunnymilk: foldr will short circuit
11:26:04 <porglezomp> What do you mean by "short circuit
11:26:13 <beta_cuckold> for a noob like myself, with no knowledge of what is actually a 'good' or 'bad' language, popularity is a prime indicator of what language should be learned, hence why python is the go-to language for most noobs, it seems.
11:26:14 <MarcelineVQ> like foldwhile?
11:26:26 <Cale> sunnymilk: Just make sure that the function you're supplying as its first argument doesn't *always* pattern match its second argument.
11:27:17 <Cale> > foldr (\x y -> if x > 100 then Just x else y) Nothing [0,7..]
11:27:19 <lambdabot>  Just 105
11:27:32 <beta_cuckold> but i'm tying to dig a bit further before just arbitrarily choosing a language.
11:27:38 <Jello_Raptor> beta_cuckold: depends on your goals. One of the reasons I like haskell is that it forces you to think in ways that most normal languages don't encourage. Once you learn those idioms, you find yourself using them in imperative languages over and over again, because they're more powerful and  easier than the standard methods. 
11:27:46 <beta_cuckold> and i've seen haskell > python, as a first language, quite a bit.
11:27:52 <kadoban> beta_cuckold: Popularity is not a good measurement at all. Some of the most popular languages are some of the worst for beginners (or in general). C is awfully popular, as is C++. Python is fairly popular, but not as popular as others.
11:28:54 <kadoban> beta_cuckold: The two I recommend to beginners are python and sometimes haskell. I'm a bit wary about recommending haskell just because the beginner materials aren't as nice and you have to understand a bit more to actually get something done.
11:29:10 <whiteline> beta_cuckold: choose a language based on problem domain and paradigms instead of popularity
11:29:37 <Cale> whiteline: Well, for general purpose programming languages, it's hard to make distinctions on problem domain.
11:29:43 <whiteline> imho python and ruby are the sanest starting languages
11:29:56 <Jello_Raptor> kadoban: exception being people with strong non-applied maths backgrounds (i.e. things that need them to write proofs more than run calculations) 
11:30:03 <silver> it depends on the learner
11:30:18 <whiteline> Cale: i knew someone would make that comment, but languages can still have paradigms they are better or worse at
11:30:24 <__009__kk> The quality of discussion surrounding a language is inversely proportional to popularity. Take a look at stack overflow. This is one consideration when deciding which languages to learn.
11:30:25 <beta_cuckold> kadoban: yes, i'm starting to realize that. python seemed ideal but a bit, i dunno', too easy; almost toy-like (once again, i'm a noob. i'll attest to my judgements being ignorant.)
11:30:25 <kadoban> Jello_Raptor: Maybe, but I don't understand that mindset very well or know very many pure-math people, so I wouldn't know.
11:30:35 <Welkin> beta_cuckold: I started with languages like mirc-scripting and php, then moved on to C, python, bash, verilog, then haskell
11:30:43 <Welkin> each time the languages got better
11:30:46 <Cale> whiteline: I guess. Most of the things which are good about Haskell apply to essentially all software though.
11:31:00 <Jello_Raptor> kadoban: I've got a number of friends of that sort, and they often feel like haskell is just maths they can run. 
11:31:02 <adarqui> python seems ideal -> for what?
11:31:11 <Welkin> haskell is good for lazy programmers who don't want to deal with runtime errors
11:31:21 <Welkin> write once, never debug
11:31:25 <kadoban> beta_cuckold: python /is/ very easy to get started. It's not a toy though, you can do serious programming in it. I don't like it as much as haskell currently, I find it easier to write better, safer, faster programs in Haskell currently. But for a beginner … it's hard for me to say.
11:31:25 <Cale> (even in cases where Haskell is inappropriate, you'd like to have access to the things which are good about Haskell, such as an expressive static type system)
11:31:26 <Welkin> (mostly)
11:31:50 <beta_cuckold> whiteline: nothing seems specific. :/ i'm interested in haskell currently and the prospect of programming hardware rather than making software.
11:31:50 <Cale> I say pick up Haskell and ask lots of questions here as you learn.
11:31:51 <silver> I would even say that something like Lisp would be good for strong students, then some subset of Haskell, then C, then a bit of Asm to get a feeling of hardware
11:31:56 <beta_cuckold> for an idea of my interests.
11:32:16 <whiteline> Cale: yes, more or less, even if some things like handling complex state is very counter-intuitive for people coming from other languages
11:32:24 <kadoban> beta_cuckold: python is called a toy by … masocists/sadists who already use really bad languages like C a lot and need some rationale for python to be a mistake, IMO.
11:32:37 <Cale> whiteline: Of course, Haskell is also *very* good at that too :)
11:32:49 <Welkin> python *is* a mistake though
11:33:01 <Welkin> the BDFL ruins it every year
11:33:03 <tonyd256> curious if anyone has tried to parse side-loaded JSON before? with aeson or something else?
11:33:08 <whiteline> beta_cuckold: for embedded you go C or forth
11:33:10 <Welkin> plus, dynamic typing = nightmare
11:33:17 <whiteline> Cale: yes, but it's not intuitive
11:33:17 <Welkin> whiteline: or asm
11:33:23 <silver> for middle school we need something which can draw pretty pictures, which is also library problem
11:33:36 <whiteline> Welkin: yes, if you're coding a bootloader or something i guess
11:33:47 <tyler569> silver: that's what scratch is designed to do
11:33:53 <Cale> But yeah, the people who I started out on Haskell have a much easier time picking up other languages (and writing good, solid code in them) than most people who have preconceptions from other languages seem to have learning Haskell.
11:33:53 <tyler569> moddle school + pictures
11:34:10 <tyler569> middle*
11:34:16 <Welkin> beta_cuckold: one piece of advice it to stay far away from OOP
11:34:16 <Cale> Haskell primes you to look at things a particular way which takes many years of experience programming in, say, Java.
11:34:18 <kadoban> beta_cuckold: Basically, I wouldn't worry too much about what language you pick … decide on one soon, realize that it's not going to be a perfect language (there isn't one), and understand that you eventually should learn many different languages.
11:35:09 <Cale> If you start out with a mostly-imperative language, it takes a lot longer to develop the good habits that Haskell simply forces you have from the outset.
11:35:49 <whiteline> Cale: it does force you to reason about your code, but then again the same could be said about C
11:36:26 <MarcelineVQ> 'sec imma just cast this into a custom datatype and... oh god'
11:36:36 <beta_cuckold> it seems like haskell is an ideal place to start, if solely for the community. lisp was another language i considered, since it has more history and hype, but i hear the community is in fringes, only remotely united due to the umbrella term that is 'LISP' (or something like that).
11:36:51 <Cale> The difference is that C forces you to reason about a lot of things which you ought not to be concerned with 99% of the time, leaving less mental energy for reasoning about the properties of your code which you really should be putting effort into.
11:37:26 <Welkin> beta_cuckold: it is unfortunate that haskell has the reputation in popular culture as being "academic" and "not practical", because I had the same misconceptions as you have when I first started learning haskell
11:37:32 <Welkin> but now I use it for everything
11:37:43 <Welkin> it is my go-to language and I build all my web applications using it
11:37:45 <whiteline> beta_cuckold: you have Common Lisp and Scheme as the surviving lisps, basically. I can code in and appreciate both
11:38:04 <whiteline> Cale: i suppose that's true yes
11:38:11 <porglezomp> If you want to program really well, you need to try a lot of things.
11:38:12 <Welkin> the community here had a major effect on my decision
11:38:22 <Welkin> this is truly the best programming language community I have ever found
11:38:27 <MarcelineVQ> omy
11:38:28 <kadoban> beta_cuckold: The haskell (and #haskell) community is /much/ better than many programming communities out there, which does help a /large/ amount.
11:38:36 <adarqui> the haskell community is by far the most impressive that i've seen, imho
11:38:42 <osfameron> Welkin: what's it like for web-apps?  I was put off by the frameworks I looked at insisting on doing html-generation in code rather than templates (also the one thing that puts me off Elm, for instanc)
11:38:42 <porglezomp> Haskell made me understand the constraints of types so much better
11:39:10 <porglezomp> But I also wouldn't have gotten the Haskell way without seeing it in another perspective (and not quite so extremely) in Rust
11:39:19 <Welkin> osfameron: I use yesod, which takes some time to learn, but once you know how to use it you can build complex applications very quickly and easily
11:39:41 <adarqui> hardly anyone talks in the various 'prog lang chans' on freenode.. #haskell is literally non stop discussion, help, fun etc.. 24/7 ;f
11:39:44 <Welkin> it uses a templating language for html/css/js called Shakespeare
11:40:28 <osfameron> oh lovely, actual templates!
11:40:32 <orion> What's the typical directory structure for a cabal project in which there exists one executable and one library?
11:40:39 <beta_cuckold> i was told by one guy that my not understanding nested for loops and pointers was indicative of my inevitable of be not being cut-out for programming (this was when i was dabbling with  C/gcc, as I'm using Ubuntu). haven't been right sense (it's a reason why i looked to something so different like haskell and lisp).
11:40:42 <Welkin> the templates con contain arbitrary haskell code too
11:40:47 <Welkin> so you can do anything with it
11:41:00 <osfameron> I saw the "compile-time guarantees on well formed content" to indicate that it was going to be combinators for generating stuff
11:41:02 <dmj`> orion: I just have src/Main.hs, then src/Library/NameSpace/Foo.hs
11:41:11 <porglezomp> I can also recomment the #rust IRC channel
11:41:11 <orion> dmj`: Ok, thank you.
11:41:16 <hodapp> beta_cuckold: was this person in ##c?
11:41:23 <Welkin> beta_cuckold: it takes time for your brain to make new connections to adjust to a new way of thinking
11:41:26 <Welkin> anyone can learn anything
11:41:28 <adarqui> orion, check some existing examples out there: https://github.com/bos .. also use cabal init, it'll bootstrap the very initial structure
11:41:29 <Welkin> it only takes time
11:41:36 <dmj`> orion: you can do it many different ways, make hs-source-dirs: tests for the test executable
11:41:39 <Welkin> more for some than others, but everyone can get there eventually
11:41:40 <whiteline> beta_cuckold: well tbh you should learn C
11:42:20 <edk> hodapp, :/
11:42:25 <whiteline> but that doesn't mean that you might want to start out with a higher-level model to grasp things easier, most people do that
11:42:35 <hodapp> edk: hrm?
11:43:06 * hackagebot network 2.6.2.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.6.2.1 (JohanTibell)
11:43:54 <thimoteus> anyone here gone through Write Yourself a Scheme?
11:44:20 <silver> yeah, me
11:44:23 <whiteline> thimoteus: i've skimmed it
11:44:23 <adarqui> beta_cuckold: that just comes down to how you study/practice.. but it's funny that someone's naive comment may have driven you to such a wonderful language
11:44:28 <silver> it's nice
11:44:44 <thimoteus> i'm wondering why when he adds in "if" to the language he does it in the eval function instead of adding it as a primitive. any thoughts?
11:45:08 <beta_cuckold> isn't haskell to c much easier than c to haskell?
11:45:14 <whiteline> thimoteus: because it requires a non-standard evaluation order?
11:45:26 <MarcelineVQ> beta_cuckold: that's really just depends on the person
11:45:37 <whiteline> beta_cuckold: no idea, I learned C as my first language.
11:45:38 <MarcelineVQ> it's good to know everything you can
11:45:48 <edk> hodapp, well i don't know how horrible you're implying ##c is, or even if i necessarily disagree with you, but it stings a bit. i try
11:46:03 <Cale> beta_cuckold: Yes, in my experience, the people who learn Haskell first have fewer problems picking up C than I see from the (admittedly much larger number of) people who do it the other way around.
11:46:11 <thimoteus> hmm, ok
11:46:27 <kadoban> ##C is a terrible place, I'll come right out and say it. I feel embarrased by proxy every time I see how a new person is treated there.
11:46:34 <adarqui> beta_cuckold: maybe, maybe not.. if you learn haskell first, you will probably have a harder time working on projects where it's a mutation/side-effect-fest all day
11:47:05 <hodapp> edk: I'm not implying that the channel is full of assholes, but the channel does have a handful of loud-mouthed, pretentious, egotistical pricks, and some of them are ops, who set the tone of the channel.
11:47:05 <whiteline> it's tied to the underlying von-neumann model of computing and thus is very confusing unless you also understand e.g. the structure of the underlying machine language and how the OS handles code loading and memory
11:47:06 <adarqui> you'd have to get your generics fix through macros lol
11:47:23 <kadoban> adarqui: I suspect that that's not true. Having a good mental separation between stateful and stateless code doesn't seem like it can be a bad thing.
11:48:06 * hackagebot ekg 0.4.0.7 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.7 (JohanTibell)
11:48:12 <edk> hodapp, i suppose i can't really dispute that
11:48:23 <hodapp> edk: the nature of your reply is telling me you're not one of them.
11:48:27 <adarqui> kadoban: right but i'm talking about working with others, who are less experienced with that
11:48:32 <adarqui> not simply working alone
11:48:52 <thimoteus> ahh whiteline, i see. primitives are implemented by eval'ing the arguments first, then applying the primitive operator
11:49:21 <whiteline> thimoteus: right. and you can't do that with an if statement
11:49:25 <kadoban> adarqui: Wellll, having one person who has good abstractions for state on a team can't be worse than having none, can it? The blind leading the blind, is that actually better somehow?
11:49:30 <Cale> Well, maybe... I must admit my own ability to deal with programs which use a lot of mutation where they don't need it has atrophied a good bit from my use of Haskell. But on the other hand, my experience with Haskell shapes my use of other languages to minimise unnecessary statefulness. I've also made use of Haskell in trying to understand obfuscated imperative programs, by translating them mechanically into Haskell, a
11:49:31 <Cale> nd then doing algebraic substitution/simplification until I get down to something which is hopefully possible to understand.
11:50:43 <hodapp> edk: so, please continue being polite and humble, because the channel could really use that.
11:50:58 <Cale> i.e. each point of control in the program becomes a function, the mutable variables in scope become function parameters, and the functions apply each other according to the control flow of the imperative program
11:51:32 <whiteline> Cale: you reduce the program to a mutually recursive state machine?
11:51:43 <ion> Cale: I began implementing a Traveling Salesman solver in a course exercise that used Python and got really frustrated at every data structure using mutation by default.
11:51:51 <beta_cuckold> omg, the vocabulary is so confusing in all IRC channels i've been. i hope this is something that comes with time. (primitives, states, von-nuemann, etc.)
11:52:15 <adarqui> welcome to computer science/programming.. tehe
11:52:16 <whiteline> beta_cuckold: that's called computer science
11:52:22 <Cale> whiteline: Yeah, basically :)
11:52:28 <Cale> whiteline: It's a mess initially
11:52:43 <beta_cuckold> it's like programming will, AT MINIMUM, introduce me to 1000 new words
11:52:44 <Cale> whiteline: But it's a mess which you can do algebraic replacement on
11:52:52 <kadoban> beta_cuckold: It does come with time, yeah. … there's a lot of confusing stuff initially.
11:53:10 <edk> hodapp, well, that's encouraging. thanks :)
11:53:30 <augur> is this a known thing?
11:53:33 <augur> fixM :: (Functor m, Monad m) => (a -> m a) -> a -> m a
11:53:33 <augur> fixM f x = join (fmap (fixM f) (f x))
11:53:54 <whiteline> Cale: it seems reasonable, intuitively. i've only used that when implementing network stacks
11:54:24 <whiteline> or rather that is the only time i have thought about a problem in those terms
11:54:27 <bitemyapp> augur: http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-Fix.html ?
11:54:50 <dmj`> :t cycle
11:54:51 <lambdabot> [a] -> [a]
11:54:54 <augur> bitemyapp: ahh nice thank you
11:55:29 <beta_cuckold> augur: not going to lie -- from what i've seen, haskell code seems far more arcane and intimidating (albeit shorter) than c code. you example reminded me of that.
11:55:44 <augur> beta_cuckold: ok
11:56:48 <kadoban> beta_cuckold: Most languages look like filth until you understand them. The languages that have tried too hard to look readable to laymen are … not great.
11:56:54 <tonyd256> posted earlier but I think it got lost in the discussion: has anyone parsed side-loaded JSON before … something like jasonapi?
11:57:28 <augur> bitemyapp: hmm. turns out that doesnt quite do what i need :x
11:57:37 <bitemyapp> augur: ok
11:58:00 <augur> maybe fix is the wrong word
11:58:42 <dmj`> tonyd256: side loaded?
11:59:20 <tonyd256> where embedded objects are at the root level instead of embedded within their parent
11:59:40 <whiteline> beta_cuckold: it's not so bad. remember that >>= and >>, ., $, and so on are just functions
12:00:25 <whiteline> the only syntactic sugar is, i think, the list and tuple notation and the do syntax
12:00:53 <tonyd256> an example might be { “posts”: [ { …, “comments”: [1, 4] } ], “comments”: [ { …
12:01:01 <whiteline> e.g. you write (1, 2) instead of Tuple2 1 2
12:01:18 <tonyd256> } ] } … to end that json
12:01:56 <dmj`> tonyd256: aeson could parse that
12:02:00 <whiteline> and [1, 2, 3] instead of List 1 2 3
12:02:08 <__009__kk> https://en.wikibooks.org/wiki/Haskell/Syntactic_sugar
12:02:51 <whiteline> :t (,)
12:02:52 <lambdabot> a -> b -> (a, b)
12:03:01 <whiteline> ah, hm.
12:03:12 <tonyd256> dmj`: isn’t only the post object passed into the fromJSON?
12:04:00 <tonyd256> how do you reference an object within another root key?
12:04:05 <geekosaur> whiteline, it's still syntax, just syntax that is made to behave like a normal constructor (sometimes)
12:04:19 <beta_cuckold> so, i'm on ubuntu and i want to learn haskell. any well-received books or resources online catered to that setup?
12:04:47 <geekosaur> (for example, there is an extension to make tuple syntax (mostly) work with section syntax, which otherwise would not work at all)
12:04:55 <Cale> beta_cuckold: A lot of people rather like this course: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
12:05:47 <whiteline> geekosaur: yeah, but it's still a confusing special case that makes it seem like i'm lying :)
12:06:07 <beta_cuckold> thanks, Cale. i'm going to go check that out.
12:06:36 <geekosaur> you should probably have expected it, though. syntax sugar that doesn't behave itself in common FP expressions is not very useful...
12:07:01 <beta_cuckold> thanks for all of the answers to my questions, haskellers (is that right?) of #haskell. :)
12:08:07 * hackagebot satchmo 2.9.7.3 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.7.3 (JohannesWaldmann)
12:08:14 <Cale> beta_cuckold: I'm not sure how it would be for a complete beginner to programming in general. It might leave out too much. There's a book by Graham Hutton called "Programming in Haskell" which might be a more solid way to get going in that case.
12:08:39 <hodapp> Graham Hutton, that name sounds familiar
12:08:42 <chardan> Cale: I really like that book, it really helped me.
12:08:51 <Haskellfant> learn you a haskell also has nearly no programming prerequisistes
12:08:56 * chardan still needs all the help me can get, though. ;-)
12:10:04 <kadoban> beta_cuckold: https://github.com/bitemyapp/learnhaskell has good advice I believe. (read http://www.haskellcraft.com/craft3e/Home.html and then do https://www.seas.upenn.edu/~cis194/fall14/spring13/index.html )
12:11:07 <dmj`> beta_cuckold: stick with haskell, researchers note haskell programmers have a longer life expectancy, and increased happiness
12:11:23 * hodapp looks at dmj`
12:12:04 * dmj` slowly glances back at hodapp
12:13:02 <hodapp> dmj`: research?
12:14:11 <dmj`> hodapp: it was a joke
12:14:25 <hodapp> figured :P
12:14:34 <hodapp> Haskell would never have side effects like that
12:14:45 <kadoban> boooo
12:15:44 <orion> At first I thought dmj` was conducting research with Hadoop.
12:16:25 <Pamelloes> How do I find out the precedence of operators?
12:16:31 <dmj`> orion: loool
12:16:55 <shiona> :i (+)
12:17:13 <kadoban> (lambdabot doesn't have :i, but ghci does)
12:17:15 <dmj`> Pamelloes: :info in ghci, what shiona said
12:17:16 * hodapp flips sign on wall: It's been _0_ days since someone made that joke about my name.
12:17:25 <Pamelloes> Ah, thanks
12:17:30 <shiona> oh, I thought lambdabot had it too
12:18:39 <Pamelloes> Does a higher infix mean it will be evaluated before a lower infix, or is it the other way around?
12:18:41 <Welkin> I always see hodapp as Hodor who develops app
12:19:44 <kadoban> Pamelloes: higher is … higher precedence ;)  (binds more strongly)
12:20:09 <Pamelloes> Alright, thanks. Though now I have to use parentheses :/
12:22:40 <Cale> Pamelloes: It doesn't affect evaluation order, just the way that the expression is parenthesised.
12:23:24 <Pamelloes> Cale: Right. Lazy evaluation.
12:23:50 <Cale> Yeah, assuming that the program is lazily evaluated, the order is outermost-first.
12:24:05 <Cale> I guess it does affect which parts of the expression are outermost
12:24:43 <Jello_Raptor> does the haskell type system have a top? 
12:24:50 <Cale> But really Haskell isn't specified to be lazily evaluated -- the compiler is free to choose any order it likes, so long as the result of the program is the same.
12:25:08 <Cale> Jello_Raptor: top? Under what ordering?
12:25:09 <Pamelloes> Really?
12:25:42 <Cale> Pamelloes: Really, that's why you'll hear some people emphasise "non-strict semantics", rather than "lazy evaluation"
12:25:54 <Jello_Raptor> Cale: instance ordering. The same way bottom can be a value of any type, is there a typeclass where every type is an instance? 
12:26:04 <Jello_Raptor> actually is that even a reasonable question? 
12:26:06 <Jello_Raptor> <_<' 
12:26:15 <Pamelloes> Cale: What's the difference?
12:26:15 <Cale> bottom is a value...
12:26:21 <geekosaur> instance Foo a where ...
12:26:51 <geekosaur> (which is what happens when people naively attempt instance Bar a => Foo a where ...)
12:27:36 <Cale> Pamelloes: Non-strict semantics refers to the result of the program (which includes its termination behaviour -- nontermination being represented by the value called "bottom"). Lazy evaluation refers to a particular systematic evaluation order which happens to be a valid way to obtain non-strict semantics, but many other evaluation orders will do just as well.
12:28:24 <Cale> Pamelloes: GHC doesn't entirely adhere to lazy evaluation -- it will often rearrange the order of evaluation to be more space efficient when it can prove that doing so won't affect the termination behaviour.
12:28:46 <kuribas> Cale: what about complexity?  Wouldn't that change when changing semantics?
12:29:14 <Cale> kuribas: The semantics doesn't consider the time or space complexity.
12:29:53 <Cale> (at least, the sort of denotational semantics we're referring to when we say that Haskell has non-strict semantics)
12:30:16 <kuribas> So "fibs" may run in O(n^2)?
12:30:28 <Pamelloes> Cale: So basically, Haskell defines a syntax and a way of converting statemetns in that syntax into an AST. Then, any evaluation of that tree should produce the correct termination/result value—it doesn't necessarily have to be a lazy evaluation.
12:30:40 <Pamelloes> Is that about right, or do I have something wrong?
12:31:01 <Cale> kuribas: Yeah, it would be valid according to spec, though foolish, to use plain outermost-first evaluation to evaluate Haskell.
12:31:14 <Cale> (i.e. do no sharing of expressions)
12:31:44 <kuribas> that surprises me...
12:32:05 <Cale> Pamelloes: Yeah, you just have to be careful that you pick an evaluation mechanism which terminates whenever some evaluation order does.
12:33:07 <thimoteus> :t undefined
12:33:08 <lambdabot> t
12:33:10 <Cale> Pamelloes: Strict evaluation, which means always picking the innermost reducible subexpressions to reduce first, will result in nontermination in cases where lazy evaluation and plain outermost-first evaluation will terminate.
12:33:45 <Pamelloes> Interesting.
12:33:48 <Cale> But there are a lot of evaluation orders in-between which can be guaranteed to terminate, and GHC uses this freedom of choice to good effect.
12:34:07 <Pamelloes> That's pretty neat. I never knew that :)
12:34:42 <Cale> (nonetheless, lazy evaluation is a really good approximation when you're trying to understand the time and space behaviour of your programs -- GHC will sometimes do something a little more clever, but it's usually okay to be pleasantly surprised)
12:37:02 <Cale> kuribas: The spec says very little, if anything at all, about the operational behaviour of evaluation. It doesn't even say you need to collect garbage, or anything at all about memory allocation, for instance.
12:38:13 <crough> cale: which is probably for the best. That's implementation detail.
12:38:17 <Cale> right
12:39:55 <kuribas> Yeah, it makes sense for allowing optimizations.
12:40:27 <dolio> There are also very different evaluation strategies that are still allowed by the Haskell spec.
12:40:35 <dolio> Although they aren't usually implemented.
12:41:22 <xplat> parallel evaluation, head normal form, optimistic evaluation, completely lazy evaluation, optimal parallel beta reduction
12:43:11 <crough> It also makes sense for allowing alternative implementation
12:45:50 <dolio> xplat: Has anyone ever actually implemented head normal form?
12:46:36 <crough> dolio: I think the consensus is that it's non-trivial with little benefit
12:46:39 <xplat> dolio: in general probably yes, for haskell probably not
12:46:43 <dolio> Also, I suspect it's not a valid reduction model for Haskell.
12:47:12 <dolio> Like, '\x -> fix id' is not in hnf.
12:47:33 <dolio> But you should not spin foreer.
12:47:35 <dolio> Forever, even.
12:47:42 <xplat> hm, maybe
12:47:54 <dolio> crough: It's definitely non-trivial.
12:48:25 <dolio> Unless you're doing something close to symbolic evaluation.
12:49:46 <dolio> I suspect head normal evaluation is about as difficult as completely lazy evaluation.
12:51:05 <xplat> i guess 'just-in-time supercompilation' is another potential reduction strategy -- with both CBN and lazy variants.  (and CBV, but that wouldn't work for haskell)
12:52:22 <xplat> (completely lazy is basically 'lazy JIT partial evaluation')
12:52:25 <notdan> 4/w 23
12:54:13 <yayfoxes> nkaretnikov: let's pick up on yesterday
12:55:07 <yayfoxes> so, I wanna design a last function
12:55:21 <yayfoxes> http://vpaste.net/ySxur
12:55:22 <bitemyapp> yayfoxes: [1, 2, 3] -> 3  ?
12:55:37 <bitemyapp> yeh okay.
12:55:44 <yayfoxes> bitemyapp: yes, but please take a look at that code
13:00:58 <bitemyapp> yayfoxes: your types don't agree.
13:01:09 <bitemyapp> yayfoxes: you can't return [a] when you're turning   a   in the other cases.
13:01:31 <bitemyapp> yayfoxes: what you've tripped on is that the type    [a] -> a   is a lie. It's a partial function.
13:01:42 <bitemyapp> yayfoxes: you have to return error (please don't)   or make it    [a] -> Maybe a
13:03:08 <kuribas> :t last
13:03:09 <lambdabot> [a] -> a
13:06:09 <mizu_no_oto> Can you use both fundeps and overlapping instances at the same time?  I'm curious about whether it's possible to implement Scala's awful CanBuildFrom hack in Haskell using typeclasses, and I think you need both fundeps and overlapping instances so e.g. mapping (+ 1) over an IntSet returns an IntSet but mapping show over the IntSet returns a Set.
13:06:25 <greymalkin> I'm trying to find something like (>>?) mzero action = action ; (>>?) (pure x) _ = pure x -- a generic "try this, and if it works, discard future statements" for monads... 
13:08:10 * hackagebot smtp-mail-ng 0.1.0.2 - An SMTP client EDSL  http://hackage.haskell.org/package/smtp-mail-ng-0.1.0.2 (alexvieth)
13:08:32 <greymalkin> Actually, I can't think of a workable type for it -- maybe that's the problem.
13:08:45 <dolio> mizu_no_oto: Yes, you can.
13:09:32 <greymalkin> nevermind... it's m a -> m a -> m a
13:09:38 <kuribas> greymalkin: how is that different from mplus?
13:11:42 <nyazdani> greymalkin: are you thinking of Alternative?
13:11:53 <mizu_no_oto> dolio: hmm.  Would it be possible to have instances that depend, for example, on whether the items of the collection have an Ord instance defined?
13:12:12 <dolio> No, that isn't possible.
13:12:41 <meditans> are strings automatically overloaded in ghc-7.10?
13:12:50 <dolio> Or, rather, deciding between overlap based on that isn't possible.
13:13:05 <meditans> in ghc-mod source, I get an error on c `elem` "!#$%&*+./<=>?@\\^|-~"
13:13:15 <greymalkin> kuribas, nyazdani: Thank you -- those look like the hints I need.
13:13:32 <nyazdani> sure thing, glad I could help
13:13:34 <meditans> I get that elem has been generalized to traversable, but what is the list then?
13:13:41 <mizu_no_oto> You could use that to decide whether or not the instance exists at all, though, right?
13:14:36 <greymalkin> Excellent... <|> has been taunting me from Control.Applicative behind my back :)
13:15:05 <geekosaur> meditans, not automatically but beware of ghc options set in the cabal file
13:15:20 <mizu_no_oto> dolio: Although there's probably a better way of bashing constrained versions of map (like Set's map) into a uniform interface.
13:15:23 <dolio> mizu_no_oto: I guess you can look at it that way. However, the reasoning doesn't go like, "this instance doesn't exist because the context isn't satisfied, so use this other instance that does exist."
13:15:51 <dolio> The reasoning is, "use this instance, and add the obligations from its context."
13:16:09 <mizu_no_oto> Right
13:16:44 <dolio> So an instance 'not existing' will appear as its preconditions not existing.
13:18:31 <meditans> geekosaur: I looked before, in fact
13:18:50 <meditans> but there isn't anything there except non interesting things
13:20:11 <geekosaur> also I think you need to build its HEAD (i.e. not from cabal) for 7.10 still
13:28:11 * hackagebot synchronous-channels 0.2 - Synchronous communication channels  http://hackage.haskell.org/package/synchronous-channels-0.2 (JesseTov)
13:34:15 <lamefun> https://github.com/commercialhaskell/stack/tree/master/src/Options/Applicative
13:34:44 <lamefun> Why does stack put its own modules in other packages' module hierarchy? Is it an accepted practice?
13:38:37 <c_wraith> lamefun: yes, it's pretty common.  Look at everything lens exports, for instance
13:38:50 <c_wraith> (and lens was just following standard practices)
13:39:02 <edwardk> lens honestly put it out there because otherwise it isn't very discoverable
13:39:09 <edwardk> its kind of a messy practice
13:39:27 <edwardk> for most of my code i tend to use my own local hierarchy and try to name things flatly there
13:39:43 <edwardk> but i figured lens was tied to enough packages that that naming convention didn't work
13:40:37 <shachaf> i,i Lens.Data.Map
13:40:49 <edwardk> exactly
13:41:01 <c_wraith> Here's a dumb random lens question while I'm at it: are there prisms for (:) and [] somewhere?
13:41:09 <edwardk> :t _Cons
13:41:10 <lambdabot> (Applicative f, Choice p, Cons s t a b) => p (a, s) (f (b, t)) -> p s (f t)
13:41:20 <edwardk> > _Cons # (1,[])
13:41:21 <lambdabot>  [1]
13:41:26 <edwardk> > _Cons # (1,[2,3])
13:41:27 <lambdabot>  [1,2,3]
13:41:29 <lamefun> What's wrong with Lens.Data.Map?
13:41:34 <edwardk> :t _Empty
13:41:35 <lambdabot> (Applicative f, Choice p, AsEmpty a) => p () (f ()) -> p a (f a)
13:41:47 <edwardk> > _Empty # () :: [Int]
13:41:48 <lambdabot>  []
13:41:49 <Peaker> edwardk: what are the other instances of AsEmpty and Cons?
13:41:59 <edwardk> Peaker: Seq, a bunch of things
13:42:07 <c_wraith> edwardk: so you're telling me I should submit a doc patch for Data.List.Lens mentioning those?
13:42:15 <edwardk> c_wraith: go for it
13:42:41 <Peaker> does lambdabot have an infinite stream type?
13:42:48 <Peaker> (and does it have a Cons instance? :-) )
13:43:55 <c_wraith> I really wish base had an infinite stream somewhere.
13:44:12 <c_wraith> 'cause talking about Cofree Identity is way less convenient. :)
13:44:50 <c_wraith> (the odds are good _Cons works with Cofree)
13:45:28 <hodapp> cofree looks too much like coffee.
13:45:30 <edwardk> c_wraith: sadly the cofree case doesn't work as it has to recurse into the same type
13:45:48 <c_wraith> Oh, I see a limitation on the type of _Cons
13:46:04 <Wizek> Good morning! 
13:46:19 <Wizek> @pl  map (\a->map (\b->(a, b)) l) l
13:46:19 <lambdabot> map (flip map l . (,)) l
13:46:27 <edwardk> at one point the Cons class had 6 arguments and could have worked with Cofree, but it was really hard to use
13:46:54 <c_wraith> That last clause seems to follow necessarily from the first one.
13:48:40 <bitemyapp> hodapp: srsly
13:50:02 <c_wraith> holy crap, lens's history is huge.
13:50:09 <notdan> 4/w 24
13:50:09 <edwardk> hah
13:50:10 <Pamelloes> Does the standard library have a Timestamp class and associated decoder?
13:50:31 <c_wraith> Pamelloes: time is *a* standard library, in that it comes with ghc
13:51:15 <Pamelloes> Huh, I wonder why google didn't turn that up...
13:51:20 <Pamelloes> I must suck at using google
13:51:30 <c_wraith> google isn't very good for searching hackage
13:51:34 <c_wraith> hoogle is better
13:51:54 <Pamelloes> Alright, time is exactly what I was looking for. Thanks :)
13:55:36 <sccrstud92_> time is what we are all looking for
13:57:39 <orion> newtype Response = Response { unResponse :: Either Error Value } -- Given a Response, is it possible to pattern match on Right and Left?
13:58:00 <c_wraith> orion: in a nested match, yes
13:58:14 <c_wraith> orion: foo (Response (Left x)) = ...
13:58:29 <orion> Ah, great! Thank you.
14:01:48 <greymalkin> Is there a good way to tell when a library uses foreign calls? (of the type that would block the runtime)
14:03:12 <c_wraith> greymalkin: not without grepping its source for "foreign import" and "unsafe"
14:05:58 <alexa_> Hey guys, I'm just getting ready to start learning haskell, and I was wondering if there existed a build tool for it that allowed one to do something akin to scala's sbt ~test, that is to say, compiling and running all tests on file change
14:06:16 <sccrstud92_> does anyone know how to expand a type alias in ghci?
14:06:32 <Peaker> alexa_: perhaps ghcid can be tweaked to do that?
14:06:39 <breadmonster_> sccrstud92_: have you tried `:info`?
14:07:43 <Haskellfant> stack test --file-watch should do the trick
14:07:51 <Haskellfant> ^ alexa_ 
14:08:10 <sccrstud92_> breadmonster_: im looking for something that also works with type family aliases
14:08:20 <alexa_> Haskellfant: stack seems like an extremely generic application name to read the documentation on. Link?
14:08:38 <alexa_> *to google
14:08:49 <sccrstud92_> https://github.com/commercialhaskell/stack
14:08:58 <Haskellfant> yeah the name is terrible, but it's a pretty piece of software :) 
14:09:01 <sccrstud92_> third link with "haskell stack"
14:09:02 <Haskellfant> yep that's the one
14:09:04 <alexa_> cheers guys
14:10:21 <alexa_> that's exactly the stort of thing I was looking for I think, Haskell's equivalent to sbt(scala build tool)
14:11:40 <lamefun> https://github.com/commercialhaskell/stack/blob/master/src/Stack/Package.hs#L160 - is it how Haskell is supposed to be written? With those prefixes?
14:12:28 <alexa_> Now the other question is, I'm going to be learning with my spouse, who will be learning haskell as a first language. Any common recommendations for editors? (I use vim, but I'm not sure what to set up my other half with.
14:12:30 <Wizek> Is there any way to evaluate a non-top level expression with GHCI? toy example: `f x = y + y where y = x + 2`and I would like to get to the intermediate `y` value
14:13:45 <bitemyapp> alexa_: I'd use something standard CUA
14:13:46 <kadoban> lamefun: Maybe. record syntax makes those functions, so it might have been a bit weird otherwise, like "flags" might be too general of a name.
14:13:55 <bitemyapp> alexa_: you don't want them trying to learn a fancy editor and a language at the same time.
14:14:16 <bitemyapp> alexa_: my coauthor had to learn to program in Haskell (never programmed before) at the same time as Linux and git and that was brutal enough.
14:14:19 <mniip> Wizek, I suppose that's doable with RTClosureInspect but that's ghc voodoo magic so the short answer is no
14:14:25 <alexa_> bitemyapp: indeed, which is why I ask? Anyone know of something with support for syntax highlighting/checking?
14:14:32 <bitemyapp> alexa_: gedit seems decent.
14:14:49 <bitemyapp> less so on the checking side, but a REPL is fine for syntax/type-checking.
14:14:55 <alexa_> okay
14:15:05 <kadoban> alexa_: I think all of the major editors have basic syntax highlighting, which is really enough to get by. If you open up a ghci session in another window and :reload the file occassionally, that's a good setup.
14:15:48 <kadoban> alexa_: I have a vim setup I kinda like, but it's still not perfect and it … takes some effort to get set up and maintain that I kinda doubt is actually worth the time it takes.
14:16:03 <bitemyapp> alexa_: yeah what kadoban describes is what I recommend people do in our book. Simple, comfortable text editor and :reload files in GHCi.
14:16:18 <Wizek> mniip, interesting, looking into RtClosureInspect
14:16:20 <bitemyapp> it "just works" the most out of all the options and avoids the tooling fussiness rabbit-hole.
14:17:11 <alexa_> kadoban: that's why I was asking about alternatives for my spouse. I'm sure my workflow will play fine with haskell in vim
14:17:28 <alexa_> since it's a multi-tool workflow (hence my asking about a tool for auto-building and running tests)
14:18:09 <mniip> Wizek, good luck with that, never got polymorphic closures to work
14:19:16 <bitemyapp> alexa_: nothing is going to work as reliably as a REPL in a terminal and a simple text editor with syntax highlighting side-by-side with the REPL.
14:19:34 <alexa_> what about vim side by side with a repl + build tool?
14:19:52 <bitemyapp> I don't know what "build tool" is, but making a new person learn vim is rough going.
14:20:03 <bitemyapp> do they really need to learn vim *right now*?
14:20:16 <alexa_> like I said, I'm not teaching them vim.
14:20:26 <alexa_> I am using vim. I'm trying to find my spouse something else.
14:20:26 <bitemyapp> alexa_: sorry, do they already know vim? I might've misunderstood.
14:20:38 <Cale> Any editor which has the ability to convert tabs to spaces, and which will maintain the indentation of the previous line will do.
14:20:40 <alexa_> They'll be using geany probably. Maybe
14:20:41 <kadoban> Oh I see, I didn't really quite understand that.
14:20:43 <alexa_> I'll be using vim.
14:20:46 <joehillen> gedit
14:20:50 <bitemyapp> alexa_: gedit should work well, it's what my coauthor uses.
14:21:03 <bitemyapp> it allows soft tabs (convert to spaces) and has Haskell syntax support.
14:21:07 <alexa_> bitemyapp: gedit has a special config that won't play nice on their setup, long story
14:21:10 <bitemyapp> it "just works" for the purposes of a new person.
14:21:13 <bitemyapp> wut
14:21:18 <alexa_> geany supports that stuff too
14:21:18 <Pamelloes> Is there a way to flush putStr?
14:21:23 <bitemyapp> okay, well whatever CUA you can find that will work and has soft spaces + syntax highlighting.
14:21:30 <Cale> Pamelloes: hFlush stdout
14:21:34 <kadoban> Maybe sublime or atom or something? They all should be basically fine.
14:21:35 <Pamelloes> Thanks
14:21:42 <bitemyapp> kadoban: yeah those would work fine too.
14:21:49 <Cale> Pamelloes: and/or you can change the buffering mode with hSetBuffering stdout NoBuffering
14:21:52 <bitemyapp> alexa_: yeah sublime and atom as kadoban suggests would be good too.
14:22:08 <bitemyapp> atom might be a little easier than sublime WRT package installation.
14:22:11 <alexa_> actually yeah, maybe atom
14:22:20 <alexa_> good call
14:22:23 <Pamelloes> Cale: Hm, are there any disadvantages to turning off buffering?
14:22:38 <Cale> Pamelloes: It hurts efficiency a bit
14:22:54 <Cale> Pamelloes: But if you're doing something which just interacts with a user, it's fine.
14:22:55 <jTT_> could anyone give me a hint reegarding a non-exhaustive patternmatch here: http://lpaste.net/136124 ?
14:23:07 <Pamelloes> Alright.
14:23:46 <joehillen> jTT_: check for 2 element list and empty list
14:23:59 <joehillen> jTT_: the guards aren't part of the pattern match
14:24:03 <jTT_> like so:
14:24:12 <kadoban> jTT_: I think you're … misunderstanding pattern matching a bit. You only have one pattern match there, (x:y:xs), so one element and zero element lists aren't covered.
14:24:12 <jTT_> | [xs == x, y] 
14:24:23 <jTT_> ahh okok
14:24:37 <Cale> Rather, 1-element list
14:24:38 <jTT_> so how i assumed that was going to be dealt with
14:24:43 <Cale> (x:y:xs) will match a 2-element list
14:24:44 <jTT_> *so i
14:24:50 <kadoban> jTT_: your first guard: | x:y:xs == [] = [] is never going to match, for instance
14:25:08 <Cale> (it matches lists of length at least 2)
14:25:41 <Cale> Yeah, it's never the case that x:xs is equal to []
14:25:47 <kadoban> (never going to succeed I probably should have said, "match" was probably confusing terminology there)
14:25:58 <jTT_> no i think  i see it now kadoban
14:26:03 <kadoban> Okay cool
14:26:15 <Pamelloes> What kind of database support is there in Haskell?
14:26:16 <joehillen> jTT_: something like this http://lpaste.net/136124
14:26:17 <jTT_> not quite sure how the syntax ought to be tough 
14:26:34 <jTT_> ah yeah, sweet! thanks joehillen
14:27:30 <jTT_> geeze, thanks guys. been pulling my hair
14:27:46 <Cale> Note, since you're repeating yourself so much, you could replace those 4 guards with y `elem` ["th","st","snd","rd"]  (also, should that really be "snd" and not just "nd"?)
14:30:07 <jTT_> Cale : yeah you’re right
14:30:17 <jTT_> (also re snd…its getting late)
14:43:14 * hackagebot Updater 0.1 - Monadic FRP library based on stm  http://hackage.haskell.org/package/Updater-0.1 (yokto)
14:44:33 * conal winces at how loosely people use the term "FRP" these days.
14:45:13 * conal considers implementing a wince-bot.
14:45:37 <kadoban> Make sure you implement it in very-loose-FRP.
14:45:44 <conal> wince
14:48:42 <alexa_> well, I got the other system set up with stack, atom, ghc etc, thanks for the advice everyone. All ready for tomorrow
14:49:10 <kadoban> Nice, good luck.
14:53:15 * hackagebot skeleton 0.1.0.0 - a tool to access the OSX keychain  http://hackage.haskell.org/package/skeleton-0.1.0.0 (rnhmjoj)
14:53:21 <vanja> Having a Triangle Float Float Float type, how would you write a function that returns a hypothenuse and a opossing point to it?
14:54:34 <sccrstud92_> vanja: how do you know it has a hypotenuse?
15:02:57 <vanja>   
15:04:40 <whiteline> vanja: define "returns and opposing point"
15:05:51 <vanja> well opossing point is the point opossite to the hypothenuse
15:06:08 <mauke> that makes no sense
15:07:12 <vanja> or lets say, the third point, the point that is not the part of the hypothenuse
15:09:33 <pavonia> slimdeviant: How do you get the points out of the three floats?
15:11:59 <benzrf> floating point numbers are scarey
15:12:27 <slimdeviant> pavonia: that was a mistake, I meant (Point Float Float)
15:13:03 <benzrf> slimdeviant: u mean (Float, Float)?
15:13:46 <slimdeviant> benzrf: In my case I have a type Point :: Float Float
15:14:00 <slimdeviant> benzrf: But you could say (Float, Float)
15:15:20 <pavonia> slimdeviant: Given two points, do you know how to calculate the distance between them?
15:15:33 <slimdeviant> pavonia: I already have that
15:16:10 <pavonia> So calculating the hypotenuse should be easy
15:17:21 <pavonia> Oh wait, you should first give an answer to sccrstud92_'s question
15:17:37 <slimdeviant> pavonia: Okay, but I need a function that returns a hypothenuse (Line Point Point) and a Point opposite to it, (Line, Point)
15:18:27 <slimdeviant> pavonia: It doesn't matter in this case
15:18:33 <slimdeviant> pavonia: All triangles in this problem have a hypothe.
15:21:34 <pavonia> So where are you stuck writing such a function?
15:21:53 <bob_twinkles> if I'm writing a function to "unwrap" an existential type, can I use unsafeCoerce? http://lpaste.net/136130 represents what I'm trying to do in code 
15:21:53 <sunnymilk> when i declare multiple instances of a typeclass in ghci it complains
15:22:01 <sunnymilk> why doesnt the later one shadow the previous ones?
15:22:09 <sunnymilk> why am i allowed to declare it at all if its just going to complain about it later
15:23:13 <yayfoxes> bitemyapp: how do you make this [a] -> Maybe a ? http://vpaste.net/ySxur
15:23:20 <slimdeviant> pavonia: I don't know how to filter the point that is opposite
15:24:04 <bob_twinkles> I'm also open to suggestions for how to do this in a cleaner/more general manner
15:24:11 <bitemyapp> yayfoxes: [] -> Nothing, (x:[]) -> Just x
15:24:49 <Denommus> yayfoxes: [] is of type [a], you want type Maybe a
15:24:51 <yayfoxes> bitemyapp: how do i unwrap a Just?
15:25:00 <pavonia> slimdeviant: To calculate the hypotenuse, you have to know the points of it, so you also know the third point
15:25:26 <orion> Is Scotty production-ready?
15:25:44 <Denommus> yayfoxes: Maybe is a monad. You can fmap, <*> or >>= over it
15:25:54 <yayfoxes> Denommus: fo
15:26:03 <Denommus> > fmap (+1) $ Just 3
15:26:03 <yayfoxes> far too advanced for me, i e
15:26:05 <lambdabot>  Just 4
15:26:13 <yayfoxes> believe
15:26:24 <Denommus> yayfoxes: sorry, I didn't know you were a beginner
15:26:27 <Welkin> think of it as a container that holds a value, or is empty
15:26:39 <yayfoxes> Denommus: o 
15:26:41 <slimdeviant> pavonia: Yeah, get that, but how to filter it?
15:26:48 <Denommus> yayfoxes: I'll try to make a quick introduction
15:26:50 <yayfoxes> I never wrote a single line of bash
15:26:57 <Denommus> yayfoxes: do you know how you can call map over a list?
15:27:08 <Denommus> > map (*3) [1, 2, 3, 4]
15:27:09 <lambdabot>  [3,6,9,12]
15:27:12 <pavonia> slimdeviant: What do you mean by filter?
15:27:21 <yayfoxes> Denommus: map (+10) [1,2,3]
15:27:42 <Denommus> yayfoxes: so, a "functor" is something that you can call fmap over it, in a similar way to "map". Maybe is a functor
15:27:49 <Denommus> > fmap (*3) (Just 3)
15:27:51 <lambdabot>  Just 9
15:27:58 <Denommus> > fmap (*3) Nothing
15:28:00 <lambdabot>  Nothing
15:28:06 <Denommus> yayfoxes: is it clear until now?
15:28:13 <yayfoxes> Denommus: bathroom break and yes
15:28:16 <slimdeviant> pavonia: extract, to have it as a single to use it somwhere else
15:29:10 <Denommus> yayfoxes: there are more functors, like Either a or lists themselves (fmap over a list is the same thing as map over it)
15:30:31 <Denommus> yayfoxes: so, there are some functors that have an operation (<*>). This operation allows a functor holding functions to be applied to other functors of the same type. This kind of functor is called applicative functor
15:30:47 <Denommus> > (Just (*3)) <*> (Just 3)
15:30:48 <slimdeviant> pavonia: I'm new to haskell, that's why I have trouble with this
15:30:48 <lambdabot>  Just 9
15:30:49 <pavonia> slimdeviant: You can get the individual point by pattern matching: func (Triangle p1 p2 p3) = ...
15:31:24 <Denommus> yayfoxes: applicative functors also have an operation called "pure" which allow you to create a functor out of a common value
15:31:27 <slimdeviant> pavonia: Okay, but which of those three is the opposite
15:31:30 <Denommus> > pure 2 :: [Int]
15:31:32 <lambdabot>  [2]
15:31:39 <Denommus> > pure 2 :: Maybe Int
15:31:41 <lambdabot>  Just 2
15:32:05 <Denommus> yayfoxes: I'll just introduce the next concept once you tell me this is clear until now
15:32:07 <pavonia> slimdeviant: How do you calculate the hypotenuse?
15:34:13 <alexa_> Okay guys, I have a painfully stupid question. I've just started my way through LYAHFGG, and the function definition syntax in the book appears to not actually.. work. I'm running GHCI 7.8.4 and attempting "doubleMe x = x + x" verbatim from the book, and getting hit by a parsing error.
15:34:19 <alexa_> <interactive>:15:8: parse error on input ‘=’
15:34:25 <Cale> bob_twinkles: I'd avoid doing what you're doing in that code there. I'd suggest something more concrete about what to do, but the example doesn't make it very clear what data it is that you're trying to represent and what the use case looks like...
15:34:31 <alexa_> Has the syntax changed, or started requiring type annotations or something?
15:34:39 <tremon> alexa_: let doubleMe ...
15:34:46 <cite-reader> This is GHCI being weird. Definitions need "let " in front of them.
15:34:56 <alexa_> ah, thanks. I found it odd that there wasn't a let or def in the book
15:34:58 <Cale> alexa_: ghci is expecting expressions, or one of a handful of special commands
15:35:04 <mauke> alexa_: ghci isn't a file
15:35:06 <yayfoxes> Denommus: not clear, too complex
15:35:12 <Cale> alexa_: You're expected to put declarations into a file and load that with ghci
15:35:19 <cite-reader> (Okay, the reason is that you're implicitly in a giant do-block.)
15:35:19 <alexa_> so, in a file let is optional, and in the repl it is required?
15:35:25 <tremon> alexa_: ghci runs in monad context (i.e. inside a do block), so it's not 100% regular syntax
15:35:27 <mauke> it's not optional
15:35:28 <yayfoxes> I need to write simpler stuff first
15:35:29 <Denommus> yayfoxes: ok, I'll try to put it another way
15:35:30 <Cale> alexa_: In a file, you can't use let at the top level.
15:35:32 <slimdeviant> pavonia: I'm not quite sure
15:35:45 <alexa_> interesting, thanks guys
15:35:49 <Denommus> yayfoxes: can you imagine a list of functions?
15:36:01 <mauke> ghci kind of sort of pretends you're inside a 'main = do ...' block
15:36:11 <alexa_> on a slightly unrelated vein. Defining a function inside another? let or no let?
15:36:23 <mauke> where, generally
15:36:30 <tremon> alexa_: mostly, I prefer where over do
15:36:34 <yayfoxes> Denommus: yes, as soon as you extract a list item it runs the function applied to any arguments in that list item
15:36:36 <tremon> argh. over let
15:36:47 <alexa_> okay thanks guys.
15:36:54 <Denommus> yayfoxes: like [(+1), (*2), (/4)]
15:37:03 <Cale> alexa_: There's (let { <declarations> } in <expression>) which is an expression form, and you can also attach a where clause to the declaration of the function as a whole
15:37:12 <Cale> where clauses scope over multiple guards
15:37:19 <yayfoxes> yes, you'd function map over it
15:37:42 <alexa_> I'll get to the differences between them later. I'm learning very basic syntax. I'm still guffawing slightly over needing backticks when using infix notation ;)
15:37:51 <Denommus> yayfoxes: <*> "extracts" the function out of the first functor, then "extracts" the element of the second functor, then applies the function to the element and creates a new functor
15:37:55 <Cale> Whenever you have the option of choosing let or where, it just comes down to personal taste and what you think makes the most sense as far as the order in which you explain what it is you're defining
15:38:05 <Denommus> > [(+1), (*2), (/4)] <*> [2, 3, 4]
15:38:06 <lambdabot>  [3.0,4.0,5.0,4.0,6.0,8.0,0.5,0.75,1.0]
15:38:30 <Cale> alexa_: You mean for f x y vs. x `f` y ?
15:38:43 <alexa_> exactly.
15:38:45 <adarqui> where desugars into let and let looks more like ocaml, if thats ur thing
15:38:47 <Denommus> yayfoxes: see that it extracted the first element of the first list, applied it to each element of the second list, then made the same with the second, then with the third
15:39:05 <mauke> > let plus = (+) in (plus 2 2, 2 `plus` 2, (+) 2 2, 2 + 2)
15:39:07 <lambdabot>  (4,4,4,4)
15:39:23 <Cale> Yeah, where desugars into let, but sometimes the desugaring is complicated because it interacts with guards and pattern matching in a nontrivial way.
15:39:42 <Denommus> yayfoxes: (I'm just explaining these things to you to make things easier for you in the future. You can probably already work with Maybe using only fmap)
15:39:51 <bob_twinkles> Cale: I'm parsing a format where every tag has a name and some component data, so I've got a bunch of discrete Tag types (TagByte, TagShort, etc.). The trouble is the Compound tag type which ends up parsing to a map of (id -> some tag type), and I'm not quite sure how to handle that polymorphism
15:39:51 <yayfoxes> Denommus: can I start on something simpler?
15:39:56 <yayfoxes> like what?
15:39:59 <pavonia> slimdeviant: You know that the hypotenuse must have the longest disctance of all, so you can check the distance of all three line segments to find the longest plus opposite point
15:40:09 <Denommus> yayfoxes: ok, simpler:
15:40:15 <Denommus> > Just (*3) <*> Just 4
15:40:16 <lambdabot>  Just 12
15:40:30 <yayfoxes> wow
15:40:39 <Denommus> yayfoxes: got it now?
15:40:41 <yayfoxes> but something simpler as in a programming exercise
15:40:51 <Cale> bob_twinkles: Okay, so that sounds like you want a type which has constructors for each of the types...
15:40:57 <yayfoxes> yes, i believe so
15:41:38 <Cale> bob_twinkles: So that you'll pick which constructor to use based on the tag, and the field of each constructor will be appropriately typed to be able to hold the required data which follows.
15:41:46 <Cale> (does that make sense?)
15:41:49 <Denommus> yayfoxes: ok, imagine you have two Maybe
15:41:53 <Denommus> yayfoxes: you want to sum them
15:41:56 <yayfoxes> Denommus: so solve all these then get back to you? https://wiki.haskell.org/99_questions/1_to_10
15:42:03 <Denommus> yayfoxes: you can make something like this:
15:42:16 <bob_twinkles> yeah, I wrote things that way first, but except for this weirdness it's a bit nicer to have discrete types for each of the tags
15:42:25 <Cale> bob_twinkles: You could use a GADT
15:42:25 <Denommus> > (fmap Just (+) (Just 3)) <*> Just 4
15:42:26 <lambdabot>      No instance for (Show a0)
15:42:27 <lambdabot>        arising from a use of ‘show_M19360486258294127027832’
15:42:27 <lambdabot>      The type variable ‘a0’ is ambiguous
15:42:32 <bob_twinkles> since there's a bunch of tags that represent lists
15:42:43 <Denommus> yayfoxes: sorry
15:42:56 <Denommus> > (fmap (Just (+)) (Just 3)) <*> Just 4
15:42:57 <lambdabot>      Couldn't match expected type ‘Integer -> Integer -> b’
15:42:57 <lambdabot>                  with actual type ‘Maybe (Integer -> Integer -> Integer)’
15:42:57 <lambdabot>      Possible cause: ‘Just’ is applied to too many arguments
15:43:15 <bob_twinkles> I've seen that acronym floating around, but I'm not familiar with what I can do with it... time to do some reading I guess
15:43:18 <obadz> Any reason "flip $" isn't a more commonly used operator in Haskell? Feels much more readable to have x |> f |> g |> h than h $ g $ f x no ? (|> is flip $ in ml)
15:43:26 <Denommus> yayfoxes: agh, I'm stupid. I don't want to get you confused, sorry
15:43:26 <lautrec> Denommus: I think you wanna drop that first "Just"
15:43:30 <Denommus> lautrec: yeah
15:43:32 <adarqui> > fmap (+1) $ (+) <$> Just 3 <*> Just 4
15:43:34 <lambdabot>  Just 8
15:43:45 <c_wraith> obadz: it shows up occasionally.  It's also in GHC 7.10
15:43:52 <Denommus> adarqui: I didn't tell him that <$> is a synonim for fmap......
15:44:04 <obadz> c_wraith: |> is in GHC ? Didn't see it in Hoogle
15:44:13 <c_wraith> obadz: it's named &
15:44:13 <Denommus> yayfoxes: so, what I wanted was (fmap (+) (Just 3)) <*> Just 4
15:44:14 <Cale> bob_twinkles: GADTs are like ordinary algebraic datatypes, except that you give the types of the constructors explicitly, and you're allowed to specialise any type parameters in the type of the result of each of the constructors.
15:44:23 <Denommus> > (fmap (+) (Just 3)) <*> Just 4
15:44:24 <lautrec> > fmap (+) (Just 3) <*> (Just 4)
15:44:25 <lambdabot>  Just 7
15:44:26 <lambdabot>  Just 7
15:44:27 <Cale> bob_twinkles: For example, you could have:
15:44:34 <Cale> data Value a where
15:44:36 <c_wraith> obadz: but it's not all that frequently used because it reverses order compared to using parens
15:44:48 <obadz> > 1 & (+ 1) & (* 2)
15:44:48 <Denommus> yayfoxes: fmap can also be written as a infix <$>
15:44:50 <lambdabot>  4
15:44:52 <Cale>   VShort :: Word8 -> Value Word8
15:44:57 <Denommus> > (+) <$> Just 3 <*> Just 4
15:44:58 <lambdabot>  Just 7
15:45:19 <obadz> c_wraith: cool, do you know why I couldn't find it on Hoogle?
15:45:23 <Denommus> > let x = Just 3 in let y = Just 4 in (+) <$> x <*> y
15:45:26 <lambdabot>  Just 7
15:45:54 <c_wraith> obadz: it might have an older version of base indexed. *shrug*
15:46:02 <obadz> c_wraith: what about flip . ?
15:46:16 <mauke> >>>
15:46:27 <yayfoxes> Denommus: well hmm I'll study math and then solve 10 of those 99 problems and get back to you
15:46:30 <adarqui> > fmap (fmap (+1)) $ traverse (:[]) $ fmap (+1) $ (+) <$> Just 3 <*> Just 4
15:46:32 <lambdabot>  [Just 9]
15:46:36 <Cale> bob_twinkles: and so on, with various constructors specialising the type parameter in different ways. You could then write a function of type  Value a -> a  for instance, which extracts the field, even though the fields all have different types.
15:46:49 <obadz> > ((+ 1) >>> (* 2)) 2
15:46:50 <lambdabot>  6
15:46:52 <adarqui> one thing i love about haskell, is how just messing around is fun in itself
15:47:02 <Denommus> yayfoxes: sorry if I confused you, I made too many mistakes, it honestly wasn't my intention
15:47:10 <obadz> mauke / c_wraith - thx
15:47:24 <Cale> bob_twinkles: and of course, that lets you restrict things at the type level as well, so in some places you might demand Value String or something.
15:48:12 <lautrec> is there a way to use infix operators in the applicative style? with "(+) <$> x <*> y" you're moving the operator to the front, and that kinda defeats the point of infix
15:48:16 <Denommus> yayfoxes: I'm trying to make you a less traumatic introduction to monads and how to use the "do" syntax. Lots of people struggle with that, when it's actually kinda simple once you understand the basic operations (return and (>>=))
15:48:18 <Cale> bob_twinkles: Pattern matching on the constructors of a GADT basically allows your function to "discover" which type the type parameter is.
15:48:22 <obadz> is there a lambdabot command to ask him in which module an operator is?
15:48:46 <Cale> bob_twinkles: It's also possible to recover that type information even after wrapping in an existential.
15:48:48 <c_wraith> lautrec: Nothing convenient.  There's a suggested syntax called "idiom brackets", but it isn't implemented in GHC.
15:49:08 <lautrec> i see
15:49:17 <c_wraith> lautrec: there is a preprocessor that supports them (SHE), and I'm pretty sure there are some quasiquoters that do.  Both add significant compilation steps
15:49:32 <Cale> bob_twinkles: However, I'm always a bit suspicious of existentials in general. More often than not there's some better option for encoding something OO-like.
15:49:32 <Denommus> lautrec: if your Applicative also implements Num, that's possible
15:49:40 <Denommus> lautrec: the type Wire in netwire does that, for instance
15:50:20 <Denommus> lautrec: but that shouldn't happen by default. If there's one thing the Python guys got right, is that explicit is better than implicit
15:50:32 <lautrec> Denommus: so like, "instance (Num a) => Num (Wire a)" ?
15:50:48 <obadz> @search &
15:50:48 <lambdabot> Unknown command, try @list
15:50:56 <Denommus> lautrec: something like that, yes
15:52:34 <lautrec> declaring instances of Num always seems to be a headache... you can't always define "signum" or "fromInteger", for example
15:52:53 <lautrec> i wish there was an easy way to overload (+) without leaving those undefined
15:53:22 <bob_twinkles> Cale: hmm... would GADTs allow me to have a polymorphic list of tags though? i.e. I need to have something like "Map String (Tag a)" and be able to put both (Tag Short) and (Tag Int8) in that map
15:53:36 <Cale> lautrec: You should basically always be able to define fromInteger, if you could define 0 and 1
15:54:33 <Denommus> :t fromInteger
15:54:34 <lambdabot> Num a => Integer -> a
15:54:39 <Cale> lautrec: fromInteger should send (0 :: Integer) to whatever the identity element for addition is, and should send (1 :: Integer) to whatever the identity element for multiplication is, and then it should satisfy the law that fromInteger (n + m) = fromInteger n + fromInteger m
15:54:47 <Denommus> lautrec: uh, fromInteger is probably just pure
15:54:48 <catsup> you can always do something like   'let (+:) = liftA2 (+)'
15:54:53 <Denommus> :t signum
15:54:54 <lambdabot> Num a => a -> a
15:54:56 <Cale> (which is enough to specify it on all other values)
15:55:09 <Cale> signum on the other hand... may be a little more awkward
15:55:13 <lautrec> Cale: I didn't know that, thanks
15:55:16 <Cale> (and probably doesn't belong)
15:55:41 <arkeet> abs and signum are kind of the awkward ones.
15:56:05 <orion> If I declare a newtype and never use its accessor (because I opted to use pattern matching instead), what's the best way to silence GHC's unused variable warning?
15:56:12 <arkeet> at least I think one should always have x = abs x * signum x
15:56:35 <fishythefish> orion, you can declare a newtype without record syntax, if that's what you mean.
15:56:35 <lautrec> catsup: yeah, i was thinking that homebrew operators for that infix applicative problem would be the way to go
15:56:45 <arkeet> orion: you could just not use an accessor. or prefix the accessor name with _
15:56:45 <orion> fishythefish: Oh, cool. I didn't know I could do that.
15:57:00 <arkeet> but yes you can just do newtype Foo = Foo Blah or something.
15:57:05 <arkeet> without record syntax.
15:57:16 <orion> ah yes
15:57:18 <orion> Thank you.
15:58:16 <Cale> orion: -fno-warn-unused-binds will also turn off that warning
15:59:16 <Cale> -Wall turns on a lot of warnings which are kind of questionable when it comes to usefulness -- personally I tend not to use it, but when I do, I just ignore anything which doesn't agree with me.
15:59:36 <bob_twinkles> I guess *need* is a strong word, but I'm not sure how else I would express that mapping... silly OO protocols with your arbitrary polymorphism
15:59:54 <orion> Thanks Cale!
16:00:07 <lautrec> > let (<+>) x y = (+) <$> x <*> y in (Just 3) <+> (Just 4)
16:00:09 <lambdabot>  Just 7
16:00:16 <Cale> bob_twinkles: Yeah, for *that* you'd need an existential.
16:00:30 <Cale> bob_twinkles: but hmm
16:00:39 <arkeet> > (sin <+> cos) (pi/4)
16:00:40 <lautrec> > let (<+>) = liftA2 (+) in (Just 3) <+> (Just 4)
16:00:41 <lambdabot>      Ambiguous occurrence ‘<+>’
16:00:41 <lambdabot>      It could refer to either ‘Control.Arrow.<+>’,
16:00:41 <lambdabot>                               imported from ‘Control.Arrow’ at L.hs:43:1-20
16:00:42 <lambdabot>  <no location info>: can't find file: L.hs
16:00:46 <arkeet> oh yeah ok.
16:00:49 <Cale> bob_twinkles: I suppose I'd want to really see more about it before committing to such a plan.
16:00:52 <arkeet> > let (<+>) = liftA2 (+) in (sin <+> cos) (pi/4)
16:00:53 <lambdabot>  1.414213562373095
16:01:32 <lautrec> > let (<+>) = liftA2 (+) in (Just 3) <+> (Just 4)
16:01:34 <lambdabot>  Just 7
16:01:57 <Cale> bob_twinkles: I guess it comes down to how much you really care about reflecting things at the type level in some cases. It's certainly easier just to go with a simple "Value" type with a bunch of constructors and no type parameter.
16:02:06 <lautrec> cool. too bad it steps on Control.Arrow's toes
16:02:20 <Cale> bob_twinkles: (but possibly you'll end up with more awkward error cases to deal with later, I guess.)
16:02:48 <c_wraith> lautrec: that's not an accident, you know.  Arrow = Category + Applicative
16:03:12 <bob_twinkles> yeah, I did actually get this working that way... but I wanted to be able to express like "sumArray :: TagIntList -> Int32"
16:03:46 <bob_twinkles> http://lpaste.net/136133 is what I have so far with the existential types approach (quite long, very repetitive)
16:03:47 <lautrec> c_wraith: i havent looked into Arrows yet (still somewhat of a Haskell novice). now i've got an excuse to, thanks
16:03:58 <arkeet> Arrows are kind of hairy.
16:04:09 <c_wraith> lautrec: I only started looking into Arrow when I started playing with the auto package
16:04:16 <Zemyla> Is there a reason why the transformers library can't have MonadST?
16:04:29 <Zemyla> Like, a MonadST class to go with the MonadIO class?
16:04:30 <arkeet> the main reason for them is to get arrow syntax, I think.
16:04:55 <c_wraith> lautrec: And even then, I thought "This would be way easier with Applicative" until I got to stuff using ArrowLoop.  Then it actually added something useful. :)
16:05:00 <Cale> Zemyla: uhh, not really, apart from the fact that it seems really really rare that anyone transforms ST
16:05:58 <Zemyla> Actually, doesn't transformers have to remain Haskell98 and it needs an s parameter as well as the m parameter?
16:06:28 <Cale> hmm
16:07:23 <arkeet> you could stick it in mtl instead then.
16:07:25 <c_wraith> Zemyla: so it would go in mtl, with all the other MPTCs, like MonadReade,etc
16:07:31 <arkeet> or just use an existing package https://hackage.haskell.org/package/monad-st
16:07:34 <Cale> oh...
16:07:34 <c_wraith> *MonadReader
16:07:47 <Cale> Right, that's a problem!
16:08:34 <c_wraith> still, arkeet's suggestion is maintained by the same guy who maintains mtl, so it's as official as you'll get
16:09:16 * c_wraith avoids naming him and therefore summoning him.  Huh.  Never noticed he has that in common with the devil.
16:09:38 <arkeet> heh.
16:09:38 <Cale> Yeah, there's an associated type there to work around the issue.
16:09:49 <Cale> liftST :: ST (World m) a -> m a
16:09:51 <Cale> heh
16:09:55 <Cale> cute
16:09:57 <arkeet> eh it could have just as easily been done with a MPTC/fundep.
16:10:17 <Cale> Yeah
16:10:27 <Cale> But still sneaky
16:10:40 <arkeet> liftST = stToIO for IO, I guess.
16:11:33 <storakatten> Another stupid question. Does haskel make any syntactic distinction between a value and a function? 
16:11:38 <hpc> nope
16:11:49 <hpc> all functions are values
16:12:00 <storakatten> but are all values functions?
16:12:04 <c_wraith> Any value can be syntactically applied as a function, too!  It's just a type error if it.. wasn't a function.
16:12:13 <hpc> all values are definitely not functions
16:12:13 <c_wraith> So no, not all values are functions.
16:12:17 <jle`> not all values are functions
16:12:17 <alexa_> It's FP, so of course functions are values.
16:12:22 <jle`> True is not a function, for example
16:12:23 <alexa_> hpc: that's what I was after, thanks
16:12:24 <hpc> that's a common misconception that comes from comparisons to java
16:12:29 <c_wraith> Only values with (->) as their type constructor are functions.
16:12:38 <hpc> where "everything is an object" gets perverted to "everything is a function"
16:12:42 <jle`> yes, values of function types are functions, heh
16:12:48 <jle`> values of Int types are integers, etc.
16:12:58 <hpc> however, in lambda calculus all values are functions
16:13:00 <hpc> (for some formulations)
16:13:03 <alexa_> hpc: I wasn't sure, because, well, haskel doesn't have mutation ostensibly
16:13:06 <hpc> it gets silly in a few places
16:13:20 <alexa_> So in my mind, lets say there was some value a that was 5
16:13:36 <alexa_> I wasn't sure if that was just a named value, or a function from unit to 5.
16:13:45 <jle`> a function from unit to 5 has a type in haskell
16:13:47 <jle`> it's () -> Int
16:13:54 <jle`> but 5 is not () -> Int, it's Int
16:14:13 <alexa_> so, lets say I do... 
16:14:17 <alexa_> let num = 5
16:14:28 <alexa_> What do I have here? () -> Int or a named container with the value 5?
16:14:29 <jle`> the 5 literal can be parsed as a function in haskell, though, but let's assume you're talking about 5 the Int :)
16:14:37 <jle`> you have num :: Int, or whatever type you want 5 to be
16:14:43 <hpc> let's switch this a bit
16:14:47 <hpc> and talk about False :: Bool
16:14:51 <hpc> just because it's simpler
16:14:59 <alexa_> Keep in mind I don't know much haskel syntax.
16:15:13 <jle`> :t True
16:15:14 <lambdabot> Bool
16:15:16 <jle`> True is a Bool
16:15:20 <jle`> :t \() -> True
16:15:21 <lambdabot> () -> Bool
16:15:29 <jle`> (\() -> True) is a function of type () -> Bool
16:15:30 <hpc> Bool values have some operations you can perform on them and their various meanings
16:15:31 <alexa_> well, I mean, I get this. But I was wondering about ::
16:15:32 <jle`> one is a function, the other is not
16:15:34 <hpc> but you can't do
16:15:37 <hpc> > True False
16:15:39 <lambdabot>      Couldn't match expected type ‘Bool -> t’ with actual type ‘Bool’
16:15:39 <lambdabot>      The function ‘True’ is applied to one argument,
16:15:39 <lambdabot>      but its type ‘Bool’ has none
16:15:40 <arkeet> x :: t means "x has type t"
16:15:41 <hpc> function application
16:15:43 <jle`> :t True :: Bool
16:15:44 <lambdabot> Bool
16:15:48 <jle`> :t True :: () -> Bool
16:15:49 <hpc> which is necessary for something to be "a function"
16:15:49 <lambdabot>     Couldn't match expected type ‘() -> Bool’ with actual type ‘Bool’
16:15:49 <lambdabot>     In the expression: True :: () -> Bool
16:15:51 <arkeet> if the type doesn't have -> in it, it's not a function.
16:15:56 <Zemyla> Oh, there needs to be a change to the monad-st package so that Control.Monad.ST.Lazy.ST is a MonadST.
16:15:58 <fishythefish> Well...
16:16:06 <fishythefish> can't you view constants as functions with 0 arguments?
16:16:11 <hpc> no
16:16:17 <jle`> you can if you want, but that's not how Haskell sees them
16:16:19 <arkeet> all functions in haskell take exactly one argument.
16:16:24 <tremon> not in haskell, as all functions have exactly one argument :)
16:16:28 <fishythefish> Ah, right.
16:16:29 <jle`> you can view functions as fishes and bowls of spaghetti
16:16:32 <jle`> it's up to you
16:16:34 <arkeet> there is (almost) an isomorphism between t and () -> t
16:16:35 <fishythefish> Realized as soon as arkeet mentioned it.
16:16:36 <jle`> but that's not how Haskell sees it
16:16:36 <arkeet> but they ar eno thte same thing.
16:16:46 <exio4> arkeet: (forall a. a) -> t and t! 
16:16:46 <arkeet> are not the.
16:16:50 <hpc> going a bit further, functions of zero arguments is a quirk of other languages
16:17:05 <hpc> your void main(); in C which takes zero arguments
16:17:09 <jle`> to haskell, the word "function" has one unambiguous definition
16:17:12 <hpc> is actually main :: IO ()
16:17:20 <jle`> but it's just a word so you can define function as whatevr you want when you talk with your friends, etc.
16:17:25 <jle`> or with your family
16:17:30 <hpc> String getLine() is not even a function at all in haskell
16:17:31 <hpc> :t getLine
16:17:32 <lambdabot> IO String
16:18:01 <alexa_> okay, so, let a = 5 would in say, scala, be val a = 5, and .. let b = () -> 5 (ignore the syntax) is a function
16:18:03 <hpc> impure languages overload function definitions to mean "take a parameter" and "don't do this right now"
16:18:18 <alexa_> and the distinction is clear.
16:18:25 <jle`> yes, the distinction is in the type
16:18:29 <Zemyla> Yeah, it is. getLine's type is State# RealWorld -> (# State# RealWorld, String #).
16:18:47 <jle`> Zemyla: IO is an abstract data type, so we talk about its interface, not its implementation
16:18:55 <jle`> saying getLine is a function is like saying Maybe is a Word8
16:18:56 <Zemyla> True.
16:18:58 * hpc didn't mean to bring IO into this
16:19:37 <storakatten> I was just starting to suspect that let a = 5 was secretly a function from unit to int where the int was always 5. Also, freenode please stop disconnecting me.
16:20:09 <hpc> storakatten: the only functions in haskell are lambdas
16:20:19 <conal> note that "let a = 5" denotes neither a function value nor a non-function value. it denotes a *definition*.
16:20:24 <jle`> yeah, in haskell, if you want to know if a value is a function or not, you just need to look at its type
16:20:28 <hpc> which are values \x -> whatever
16:20:30 <arkeet> 5 denotes a value.
16:20:33 <hpc> with types of something -> something
16:21:00 <jle`> you do have functions from unit to, say, Bool, and you do have values of type Bool
16:21:06 <jle`> they are two different types --- one is a function, the other is not
16:21:09 <alexa_> the only functions are lambdas? as in anonymous function syntax?
16:21:23 <conal> since no one else has mentioned it, http://conal.net/blog/posts/everything-is-a-function-in-haskell/
16:21:34 <arkeet> oh yeah I forgot about that article.
16:21:36 <alexa_> let square x = x * x... this is a function, is it not?
16:21:38 <hpc> alexa_: or things that end up translating to it
16:21:39 <alexa_> what is a "definition"?
16:21:41 <arkeet> square is a function.
16:21:41 <hpc> that is a function
16:21:48 <arkeet> "square x = x * x" is a definition.
16:22:01 <hpc> let square = \x -> x * x
16:22:01 <hpc> is equivalent
16:22:10 <alexa_> ah okay, so syntactic sugar basically
16:22:15 <arkeet> (there are some minor differences)
16:22:29 <conal> in part, i think there's a confusion between syntax and semantics. "function" is a semantic thing, while "expression" and "definition" are syntactic things.
16:22:34 <alexa_> in the latter, square is a value storing a function from Num -> Num?
16:22:34 <jle`> in square x = x * x, you're making a definition of what square is.  but you're defining a function named square
16:22:55 <jle`> it's a value that is the function... a value of time Int -> Int, say
16:23:07 <alexa_> yes exactly
16:23:13 <jle`> s/time/type
16:23:45 <alexa_> anyway, thanks for a few basics. Back to reading "starting out"
16:27:25 <lautrec> i'm sure this gets asked here a lot, but what's the status quo for gamedev in haskell? should i just work with SDL2? or are there viable frameworks that would make my life easier?
16:28:19 * hackagebot Frames 0.1.1.0 - Data frames For working with tabular data files  http://hackage.haskell.org/package/Frames-0.1.1.0 (AnthonyCowley)
16:28:58 <jle`> lautrec: try asking in #haskell-game too :)
16:29:34 <lautrec> jle`: ah of course, thanks
16:29:51 <Eduard_Munteanu> Gee, I thought that was the channel for deer hunters in Haskell. :P
16:30:07 <jle`> Eduard_Munteanu: they're friendly to game-dev questions too :)
16:30:21 <jle`> a very multi-talented group of people
16:30:48 <Eduard_Munteanu> Wow, the channel grew quite a bit since my last visit there.
16:31:51 <alexa_> What's [] called in haskell? Nil? ( 5:[] -> 5 cons nil )?
16:33:14 <jle`> we call it nil typically
16:33:29 <jle`> at the value level, at leasat
16:33:35 <hpc> or "empty list" or whatever
16:34:00 <hpc> nil comes from lisp which makes it a nice universal term in CS departments
16:34:30 <hpc> and lisp probably got it from somewhere else
16:34:55 <alexa_> Yeah I figured haskell probably stuck to convention
16:35:02 <lpaste> Cale pasted “here's what I was thinking anyway...” at http://lpaste.net/136136
16:35:05 <Cale> bob_twinkles: ^^
16:35:24 <Cale> bob_twinkles: The tricky bit actually is going to be TList
16:35:41 <Cale> ... maybe
16:36:16 <Cale> Because if the list is empty, we can't recover which tag type it was, because we actually lose the 'a'
16:36:59 <Cale> bob_twinkles: There's a canonical solution to that, but it's a bit obnoxious...
16:38:28 <Cale> bob_twinkles: What we really want to be able to write is something dependently typed like (not real Haskell syntax)   TList :: Text -> (a :: TagType) -> [Tree a] -> Tree TagList
16:38:57 <bob_twinkles> the application I'm interacting with doesn't handle empty lists well either (just defaults the type) so that actually works out =P
16:39:29 <Cale> haha
16:39:45 <Cale> Of course, in the actual NBT format, the data is specified.
16:39:59 <Cale> So, I dunno, if you're picky enough, there is a way to solve this
16:40:24 <Cale> You could make *another* GADT which would look like:
16:40:31 <Cale> data STagType a where
16:40:44 <Cale>   STagEnd :: STagType TagEnd
16:40:56 <Cale>   STagByte :: STagType TagByte
16:41:00 <Cale> and so on
16:41:18 <Cale> and then you'd have
16:41:38 <Cale> jeez
16:41:45 --- mode: ChanServ set +o Cale
16:42:04 <jle`> it looks a little bit like Cale got so frustrated he is going to kick himself
16:42:09 <bob_twinkles> someone having fun with Freenode apparentely
16:42:12 --- mode: Cale set +b *!*@118-163-101-67.HINET-IP.hinet.net
16:42:27 --- mode: Cale set -o Cale
16:42:32 <jle`> oh, i have join/parts hidden so i definitely did not get the context for that, heh
16:42:50 <arkeet> there's a second ip, cale
16:43:01 <arkeet> or third
16:43:35 <Cale> ah, yeah, looks like it
16:43:38 --- mode: ChanServ set +o Cale
16:44:22 <Cale> ugh, I dunno, there's several others
16:44:36 --- mode: Cale set +b *!*@178.150.229.221
16:44:38 <mniip> 118-163-101-67.HINET-IP.hinet.net 178.150.229.221 23.254.167.179 31.186.13.221
16:44:45 <HairyPolitician> With haskell-mode in emacs, anyone know how to send a single line to the REPL?
16:44:51 --- mode: Cale set +b *!*@23.254.167.179
16:44:51 <HairyPolitician> Or a block of text, for example?
16:44:57 --- mode: Cale set +b *!*@31.186.13.221
16:45:27 <bob_twinkles> in any case, if I want to pull a specific tag out of the TagCompound, don't I still need some sort of function that can coerce SomeTree -> Tree Tag*?
16:46:22 <Cale> bob_twinkles: If you pattern match, then you recover which tag it is
16:46:40 <bob_twinkles> oh, that does just turn in to a pattern math doesn't it
16:46:59 <Cale> bob_twinkles: As soon as you pattern match on the TByte constructor, for instance, it will know that you have a Tree TagByte
16:47:03 <Cale> and not some other type of Tree
16:47:16 <Cale> So you'll be able to use the value as if it were a Tree TagByte specifically
16:47:56 <Cale> so, what I was going to say about that singleton type...
16:48:12 <Cale> Well, let me just do it and show you how that would look...
16:48:20 * hackagebot base91 0.1.0 - A Base91 encoder & decoder  http://hackage.haskell.org/package/base91-0.1.0 (ajg)
16:48:22 * hackagebot quiver 0.0.0.3 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.3 (patrykz)
16:49:43 <mniip> I wonder what arbitrary choosing and order of ascii symbols does base91 use
16:50:20 <mniip> oookay that's more arbitrary than I expected
16:50:55 <lpaste> Cale annotated “here's what I was thinking anyway...” with “fun with singletons” at http://lpaste.net/136136#a136137
16:51:06 <Cale> bob_twinkles: ^^
16:51:59 <Cale> bob_twinkles: So here, when pattern matching on a TList, when we match against the various constructors of STagType a, we'll discover what 'a' is, and hence what to expect in the following list.
16:52:27 <Cale> (even if the list is empty)
16:52:56 <Cale> It's ugly, but that's the price we pay for not having real dependent types
16:52:57 <Eduard_Munteanu> Is there an abstraction for allocators? Say you have some module that wants to operate on a file without owning all of it.
16:53:17 <Eduard_Munteanu> And it may need to allocate space for stored data.
16:53:20 * hackagebot Frames 0.1.1.1 - Data frames For working with tabular data files  http://hackage.haskell.org/package/Frames-0.1.1.1 (AnthonyCowley)
16:54:24 <Cale> This gets us way more type safety than you'd have in something like Java of course, where they just do lots of downcasting :P
16:54:43 <bob_twinkles> so if I added a tag type to TagType without adding it to STagType, the compiler would blow up?
16:55:15 <Cale> bob_twinkles: Not immediately, but you wouldn't be able to construct lists of that type
16:56:23 <Cale> (because you'd write TList "foo" ... [TNewType ...] and be stuck filling in the first ellipsis, not having an appropriate value of type STagType to provide there.
16:56:29 <Cale> )
16:56:36 <bob_twinkles> ah, fair enough. And the original protocol *was* developed for a Java application, so there you go =P
16:56:45 <Cale> Yeah, it's from Minecraft ;)
16:56:54 <bob_twinkles> ayup
16:58:42 <ThermalSpan> Hey, here's a question that hoogle couldn't help me with. I'm looking for a function with the signature (a -> a -> b) -> [a] -> [b] such that the function is applied to each sequential pair in the original list. For example, If I had a distance function and list of points I would get a list of distances between those points.
16:58:42 <Cale> lol, my comment about singletons ended up inside the definition of the singleton :D
16:58:54 <lpaste> Cale revised “fun with singletons”: “No title” at http://lpaste.net/136137
16:59:06 <Cale> there, edit fail fixed :)
16:59:15 <jle`> ThermalSpan: you can have it work on consecutive pairs using zipWith f xs (tail xs)
16:59:37 <jle`> > let xs = [2,7,3,4,1] in zipWith (+) xs (tail xs)
16:59:38 <lambdabot>  [9,10,7,5]
16:59:51 <Cale> @quote zip`ap`tail
16:59:51 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
16:59:51 <arkeet> > let xs = [a,b,c,d] in zipWith (+) xs (tail xs)
16:59:52 <lambdabot>  [a + b,b + c,c + d]
17:00:06 <jle`> fun fact, this also works when xs is empty
17:00:21 <Cale> Right, this is a safe use of tail
17:00:50 <Cale> > (zip`ap`tail) [1..10]
17:00:52 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
17:01:06 <Cale> (maybe don't actually write it like that though, I dunno)
17:01:48 <Cale> Perhaps some people would be okay with reading (zip <*> tail) these days, but generally the Applicative/Monad instances for functions are considered a little obscure.
17:02:05 <jle`> @let consec = zip`ap`tail
17:02:06 <lambdabot>  Defined.
17:02:38 <ThermalSpan> jle`: Thanks! I thought it might have standard function but that is an elegant solution.
17:02:48 <Cale> Though, the Applicative instance for functions is sort of beautiful to see if you know about the SK calculus already :)
17:02:57 <zovt> anyone know how to send and read messages over a socket without having to close the socket?
17:03:06 <jle`> i use liftA2 and sequence on functions often
17:03:10 <jle`> i'm not sure if that's a good or bad thing
17:03:18 <yayfoxes> Cale: I need help with myLastButOne
17:03:23 <jle`> i feel like it's safe to use sequence for functions
17:03:26 <jle`> idk
17:03:49 <yayfoxes> Cale: http://vpaste.net/RkGlG
17:03:50 <Cale> That instance actually played a pretty significant role in convincing me that Applicative was the "right thing" in the first place.
17:04:13 <Cale> (the fact that pure = K and (<*>) = S)
17:04:25 <arkeet> :t (<*>) pure pure
17:04:26 <Cale> yayfoxes: sure :)
17:04:26 <lambdabot>     No instance for (Applicative f0) arising from a use of ‘pure’
17:04:26 <lambdabot>     The type variable ‘f0’ is ambiguous
17:04:26 <lambdabot>     Note: there are several potential instances:
17:04:29 <arkeet> oh.
17:04:48 <yayfoxes> *Main> myButLast [1,2,3,4]
17:04:50 <yayfoxes> *** Exception: funcs.hs:(7,1)-(10,28): Non-exhaustive patterns in function myButLast
17:04:56 <arkeet> :t (<*>) const const
17:04:57 <lambdabot> b -> b
17:05:23 <yayfoxes> if I move the last line up one does that fix the problem?
17:05:27 <Cale> yayfoxes: You have some weirdly named variables... usually we reserve names like xs and ys for things which are known to be lists.
17:05:46 <Cale> In (z:y:zs:[]), the zs is not a list.
17:06:04 <Cale> and in (y:ys:[]) the ys is not a list either
17:06:33 <Cale> yayfoxes: But in any case, you've only defined myButLast for lists of length at most 3
17:06:47 <Cale> [] matches only the empty list
17:06:54 <Cale> (x:[]) matches only a list of length 1
17:07:00 <yayfoxes> Cale: so how do I fix it, chop off the []?
17:07:41 <Cale> yayfoxes: Probably you want to handle all lists of length 3 and larger in the same way.
17:08:11 <zovt> Does anyone use sockets here?
17:08:12 <Cale> So, match against (x:y:z:xs), and then recurse
17:08:37 <arkeet> what is myButLast supposed to do?
17:08:44 <Cale> yayfoxes: Note, you can write myButLast [x] = ... for matching against a list of length 1, for instance
17:08:54 <yayfoxes> Cale: simpler: http://vpaste.net/VQ75t
17:08:57 <Cale> arkeet: I believe it's meant to get the second last element of the list.
17:08:58 <benzrf> arkeet: it's supposed to ensure that it is YOUR butt that comes last
17:09:00 <benzrf> not someone else's
17:09:05 <arkeet> lol
17:09:06 <benzrf> =)
17:09:22 <arkeet> Cale: that was my guess, but I didn't want to assume.
17:09:24 <Cale> yayfoxes: Yeah, that also works for sure.
17:09:44 <Cale> yayfoxes: The patterns are tried in order, after all.
17:10:10 * arkeet wonders if myButLast [x] = Just x is correct
17:10:11 <yayfoxes> Cale: question: how would you do it?
17:10:35 <Cale> arkeet: Seems weird, yeah.
17:11:16 <Cale> yayfoxes: I dunno... probably if this operation were important to me, I wouldn't be using lists.
17:11:30 <Cale> :)
17:11:56 <Cale> Another option: you could reverse the list first, making the second last element easier to get at.
17:12:05 <Cale> (because it's then just the second element)
17:12:53 <yayfoxes> Cale: soon I will have to reverse a list so how would you do that? remember: head init tail last and a reversed list is just the last sandwitched onto the init and the head
17:13:08 <yayfoxes> so, there's a ++ somewhere
17:14:44 <yayfoxes> so if i took the two last last items and swapped two elements using x ++ [y]...
17:16:45 --- mode: Cale set -o Cale
17:17:03 <Cale> yayfoxes: So... well, maybe I should explain a fancy trick you can do here.
17:17:21 <Cale> yayfoxes: Yes, you *can* recursively do  reverse (x:xs) = reverse xs ++ [x]
17:17:31 <arkeet> it's probably worth knowing how to write it that way.
17:17:43 <Cale> yayfoxes: However, xs ++ ys takes O(length xs) steps to fully reduce
17:17:55 <Cale> So, reverse will take quadratic time if you write it like that.
17:18:18 * yayfoxes 's brain explodes
17:18:39 <Cale> Ah, already? :)
17:19:01 <yayfoxes> well heheh I am a beginner
17:19:13 <yayfoxes> maybe it imploded back
17:19:15 <Cale> yayfoxes: Okay, so, you understand why this is correct, yeah?
17:19:21 <Cale> reverse [] = []
17:19:27 <jle`> when learning haskell it helps to have some backup/spare heads on hand for explosions like this :)
17:19:27 <Cale> reverse (x:xs) = reverse xs ++ [x]
17:19:47 <Cale> i.e. the reverse of a list whose first element is x, and where the rest of the list is xs
17:19:48 <arkeet> code it up, and see how long, say, length (reverse [1..100000]) takes.
17:20:01 <Cale> is the list formed by taking the reverse of xs, and appending x to the end of it
17:20:16 <arkeet> (maybe that one's too long.)
17:20:47 <yayfoxes> Cale: ok i'm not sure if I understand
17:20:54 <Cale> So, for instance
17:21:21 <Cale> reverse (1:2:3:[])
17:21:24 <Cale> = reverse (2:3:[]) ++ [1]
17:21:43 <Cale> = (reverse (3:[]) ++ [2]) ++ [1]
17:22:01 <Cale> = ((reverse [] ++ [3]) ++ [2]) ++ [1]
17:22:14 <Cale> = (([] ++ [3]) ++ [2]) ++ [1]
17:22:26 <Cale> = ([3] ++ [2]) ++ [1]
17:22:37 <Cale> = [3, 2] ++ [1]
17:22:44 <Cale> = [3, 2, 1]
17:22:56 * mniip mumbles something about pastebins
17:23:40 <Cale> I guess I could have put that on lpaste.net, but then I have to be silent for a while as I type it.
17:23:51 <Cale> Whereas this way he gets to start thinking about the first line sooner
17:24:30 <yayfoxes> Cale: I gotta go
17:24:55 <Cale> yayfoxes: All right, later ping me if you want to hear about a trick to improve the performance of reverse :)
17:25:22 <Cale> yayfoxes: Where instead of constructing a list, we construct a function, and instead of concatenating lists, we compose functions :)
17:26:00 <Eduard_Munteanu> I think I've seen some ads saying "I improved the performance of reverse using this little odd trick!".
17:26:30 <arkeet> you don't need to construct any functions.
17:26:33 <mniip> edward kmetts hate him!
17:26:49 <Cale> arkeet: You don't need to think about it that way, but I think it's an elegant way to reason about it.
17:26:58 <arkeet> reverse xs = go xs [] where go [] ys = ys; go (x:xs) ys = go xs (x:ys)
17:27:19 <maerwald> improving performance is such a boring thing, wonder if it will be obsolete one day (either through ultimate hardware or ultiamte compilers)
17:27:22 <Cale> i.e. we pass from constructing a list of type [a] to a function of type [a] -> [a] which will add elements to the beginning of the list it's given
17:27:33 <Cale> and in place of [], we then use id
17:27:39 <Cale> and in place of [x] we use (x:)
17:27:45 <Cale> and in place of (++) we use (.)
17:27:50 <arkeet> sure.
17:28:04 <Cale> and the resulting function can then be turned back into a normal list by applying it to the empty list
17:28:22 * hackagebot postgresql-cube 0.1.0.0 - Cube support for postgresql-simple  http://hackage.haskell.org/package/postgresql-cube-0.1.0.0 (inaimathi)
17:28:38 <arkeet> go [] = id; go (x:xs) = go xs . (x:)
17:28:57 <Cale> I'd call it reverse', but yeah, exactly :)
17:29:31 <jle`> reverse' xs = go xs []
17:29:51 <Cale> Well, that's ordinary reverse then :)
17:30:31 <arkeet> Cale: I'm just pointing out that 
17:30:32 <arkeet> er
17:30:41 <arkeet> my two definitions of go are equivalent.
17:30:46 <Cale> arkeet: sure
17:30:50 <arkeet> but I guess each emphasizes a different thing.
17:31:47 <Eduard_Munteanu> reverse (x:xs) = reverse xs >> tell [x]
17:31:48 <yayfoxes> Cale: whoa guys I can stay
17:31:57 <yayfoxes> what's this about composing a function?
17:32:00 <Cale> yayfoxes: Okay, so yeah
17:32:20 <Cale> So, once you understand the plain list version...
17:32:24 <Cale> reverse [] = []
17:32:31 <Cale> reverse (x:xs) = reverse xs ++ x
17:32:39 <arkeet> ++ [x]
17:32:44 <Cale> ugh, yes :)
17:32:47 <Cale> reverse (x:xs) = reverse xs ++ [x]
17:32:57 <Cale> Sorry for that
17:33:26 <Cale> So, this is inefficient because xs ++ ys takes a number of steps proportional to the length of xs, in order to fully evaluate
17:34:16 <arkeet> because fully evaluating xs ++ ys must fully evaluate xs
17:34:34 <arkeet> hm.
17:34:40 <Cale> [] ++ ys = ys
17:34:43 <arkeet> that doesn't help.
17:34:46 <yayfoxes> Cale: ok I think i'll never understand soon because I need to study algebra
17:34:47 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
17:35:11 <Cale> So for instance:
17:35:18 <Cale> [1,2,3] ++ [4,5]
17:35:26 <Cale> -> 1 : ([2,3] ++ [4,5])
17:35:28 <yayfoxes> do i just sit there on Khan Academy and listen?
17:35:37 <Cale> -> 1 : (2 : ([3] ++ [4,5]))
17:35:50 <Cale> -> 1 : (2 : (3 : ([] ++ [4,5])))
17:35:58 <Cale> -> 1 : (2 : (3 : [4,5])) -- done
17:36:08 <arkeet> I guess the important part is that evaluation of xs ++ ys cannot share work with evaluating xs
17:36:12 <arkeet> (but it can share work with ys)
17:36:14 <yayfoxes> Cale: that's amazing!
17:36:30 <Cale> So, this took 4 = 3+1 steps because [1,2,3] had 3 elements
17:36:36 <yayfoxes> what does cons run in?
17:36:40 <Cale> constant time
17:36:52 <yayfoxes> ok, any parallelism/
17:36:57 <Cale> nope
17:37:03 <yayfoxes> I have 4 cores each with one thread
17:37:07 <yayfoxes> alright :)
17:37:15 <Cale> No implicit parallelism here
17:38:24 <Cale> (it's harder than you might think to get it right -- even though you could in principle do everything in parallel in a pure functional program, forking new threads for every little thing ends up drowning you in scheduling and synchronization costs)
17:39:21 <Cale> But okay, so if you kind of have a sense for why we might want to avoid doing lots of (++)
17:39:59 <Cale> The trick I wanted to show is to, instead of constructing a list of type [a], we construct a function of type [a] -> [a] which will add elements to the beginning of the list it is given
17:40:01 <yayfoxes> Cale: i see it's more efficient...not sure if I get it
17:40:21 <Cale> So the representation for the empty list becomes the identity function id
17:40:29 <Cale> because it does nothing to the list it's given
17:40:40 <yayfoxes> Cale: that's math and I need to study math
17:40:42 <ejr> Anyone know how to make the csv9.hs CSV parser in Ch 16 Real World Haskell strip the trailing whitespace from cell values?
17:40:46 <ejr> Link: http://book.realworldhaskell.org/read/using-parsec.html
17:40:51 <Cale> I'm not sure I agree it's math?
17:40:59 <Cale> What is math?
17:41:08 <yayfoxes> calculus
17:41:14 <Cale> Calculus?
17:41:21 <Cale> I haven't used any calculus here...
17:41:22 <yayfoxes> identity function
17:41:25 <Cale> nonono
17:41:46 <Cale> The identity function is just the function:
17:41:48 <Cale> id x = x
17:42:00 <Cale> which does nothing to its argument, producing it unchanged
17:42:18 <Cale> It's defined in the Haskell Prelude
17:42:39 <Cale> It gets used a bunch throughout mathematics as well, sure, but it has nothing in particular to do with Calculus
17:42:59 <Cale> Okay?
17:43:10 <yayfoxes> ok
17:43:18 <ion> Did Haskell use to have an “interface” keyword or is this pseudocode? https://downloads.haskell.org/~ghc/0.29/docs/users_guide/user_80.html#SEC80
17:43:19 <Cale> So the reason why id is our representation for the empty list is because it doesn't add any elements to the list it's given
17:43:25 <Cale> Yeah?
17:43:38 <yayfoxes> wow, yeah1
17:43:46 <Cale> And now a list of length 1, say [x] will be represented by the function (x:) which adds x to the beginning of the list it's given
17:44:12 <Cale> and now the clever bit is that list concatenation (++) can be represented by function composition (.)
17:44:28 <Cale> That is, where (f . g) x = f (g x)
17:44:47 <Cale> Since function composition always takes exactly one step to reduce, it's fast (constant time)
17:45:24 <Cale> So, if we apply this transformation to our reverse (I'll write our original first):
17:45:27 <Cale> reverse [] = []
17:45:36 <Cale> reverse (x:xs) = reverse xs ++ [x]
17:45:38 <Cale> becomes
17:45:43 <Cale> reverse' [] = id
17:45:53 <Cale> reverse' (x:xs) = reverse' xs . (x:)
17:46:10 <Cale> So, here we have  reverse' :: [a] -> ([a] -> [a])
17:46:34 <Cale> and now to get back to something with the same type as our original, we just apply the resulting function to an empty list:
17:46:43 <Cale> reverse xs = reverse' xs []
17:47:22 <Cale> So, that will add the elements of xs, in reverse order, to the beginning of the list []
17:48:45 <Cale> But it's O(n) time, rather than O(n^2) time, which basically means the length of time that it takes grows roughly in proportion to the length of the list, rather than the square of the length.
17:49:17 <Cale> This trick is really useful to remember
17:49:41 <yayfoxes> ok, what do I study to be good at haskell?
17:49:48 <Cale> Books about Haskell
17:49:53 <yayfoxes> I really gotta know so I can leave and do it
17:49:57 <yayfoxes> ok, books. which?
17:50:09 <Welkin> @where learnhaskell
17:50:09 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:50:09 <Cale> Maybe start with Graham Hutton's book Programming in Haskell.
17:50:12 <Welkin> yayfoxes: that
17:50:19 <yayfoxes> I saw this: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
17:50:26 <Welkin> yayfoxes: yes
17:50:32 <Cale> and yeah, that's a good course
17:50:50 <Welkin> I personally enjoyed Learn You A Haskell, but it isn't the best resource
17:51:02 <Cale> yayfoxes: btw, you also don't have to completely leave -- you should stick around and ask lots of questions
17:51:32 <yayfoxes> I'll be back in 15-20 minutes, I wanna walk outside. after I get back, i discuss how to turn a number into a list of it's digits
17:51:34 <Cale> yayfoxes: While thinking for yourself is good a lot of the time, often just asking someone here can save you a lot of searching through documentation for the answer you need.
17:52:11 <Welkin> yayfoxes: there are a million ways to do it
17:52:23 <yayfoxes> well, I'd use modulus 10 to get a single digit, but I'm going to walk outside
17:53:18 <Welkin> the easiest is this
17:54:10 <Welkin> > map (\x -> read x :: Integer) . show $ 345349857945345986345656
17:54:12 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
17:54:12 <lambdabot>      Expected type: Integer -> [String]
17:54:12 <lambdabot>        Actual type: Integer -> String
17:54:13 <yayfoxes> i'll be back in a bit!
17:56:39 <Welkin> > map (\x -> read [x] :: Integer) . show $ 345349857945345986345656
17:56:41 <lambdabot>  [3,4,5,3,4,9,8,5,7,9,4,5,3,4,5,9,8,6,3,4,5,6,5,6]
17:56:44 <maerwald> using the show instance is not nice here
17:56:48 <Welkin> :)
17:57:00 <benzrf> ew
17:57:03 <Welkin> haha
17:57:06 <benzrf> thats pretty nasty
17:57:10 <benzrf> what you want is unfoldr
17:57:12 <benzrf> :t unfoldr
17:57:13 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:57:22 <Welkin> yes, that is better
17:57:28 <Welkin> but this is an example for a beginner
17:57:33 * benzrf shruggs
17:58:39 <Cale> Even if it's a little less efficient, I really like map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)
17:58:40 <benzrf> > unfoldr (\x -> if x == 0 then Nothing else Just (x `divMod` 10)) 12345
17:58:41 <lambdabot>  [1234,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:58:47 <benzrf> fff
17:58:58 <benzrf> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (x `divMod` 10))) 12345
17:59:00 <lambdabot>  [5,4,3,2,1]
17:59:00 <Cale> It's a little harder to screw up than the unfoldr ;)
17:59:09 <benzrf> :o)
17:59:21 <arkeet> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (x `divMod` 10))) (-12345)
17:59:22 <lambdabot>  [5,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
17:59:30 <benzrf> :v(
17:59:32 <Cale> 10-adic expansion
17:59:35 <arkeet> :-)
17:59:48 <benzrf> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (x `quotRem` 10))) (-12345)
17:59:49 <lambdabot>  [-5,-4,-3,-2,-1]
17:59:53 <benzrf> :^D
17:59:54 <Welkin> I haven't seen the classic benzrf face in a while
18:00:04 <benzrf> that's not my face
18:00:06 <benzrf> i'm just borrowing it
18:00:09 <arkeet> :^E
18:00:17 <Welkin> the japanese encoding one?
18:00:24 <Cale> arkeet's face it turning into some sort of pitchfork
18:00:27 <Cale> is*
18:00:28 <arkeet> (´・ω・｀)
18:01:36 <benzrf> (´･ω･`)
18:01:47 <benzrf> hmm... yours is better
18:01:49 * benzrf steals it
18:02:12 <zovt> anyone here familiar with sockets in haskell?
18:02:35 <Eduard_Munteanu> zovt, well, go ahead, ask and see
18:02:58 <zovt> https://www.reddit.com/r/haskell/comments/3chq5v/reading_and_writing_from_a_socket_without_closing/
18:03:01 <Eduard_Munteanu> Any idea why Happstack docs are broken on their website?
18:03:12 <benzrf> https://img.4plebs.org/boards/s4s/image/1400/61/1400612962978.jpg
18:03:26 <zovt> Essentially, I'm trying to keep a handle open so I can read/write to a socket, but I can't seem to read unless the handle gets closed
18:06:14 <Eduard_Munteanu> zovt, how do you test? Have you tried waiting an arbitrary amount of time without closing the socket?
18:06:41 <zovt> on the reddit post, there's some client code
18:06:45 <zovt> that I run while the server is up
18:07:02 <Eduard_Munteanu> zovt, because it should be noted TCP sockets don't send data specifically when you write()/send(), they may buffer arbitrarily.
18:07:17 <zovt> hmmm....
18:07:28 <zovt> even if I manually flush?
18:07:34 <zovt> and set NoBuffering on the Handle?
18:07:59 <Eduard_Munteanu> zovt, yes, that's the handle buffering, but there's also buffering in the network stack, I think.
18:08:46 <zovt> so is there a way to keep the socket open and have a channel between the two?
18:08:51 <Eduard_Munteanu> setsockopt()'s manpage likely talks about TCP_NODELAY and such.
18:09:47 <Eduard_Munteanu> zovt, I'm not sure what the problem is... try waiting an arbitrary amount of time before closing and see if the server receives anything.
18:10:14 <zovt> sounds good
18:10:18 <Eduard_Munteanu> e.g. _ <- getChar
18:10:25 <zovt> I'll report back in ~10 minutes
18:10:40 <zovt> I have it waiting with a getLine
18:10:49 <zovt> I'll just leave it up I suppose for a bit
18:12:48 <Eduard_Munteanu> zovt, oh, I missed that. Are you saying the server doesn't receive anything while the client waits on getLine?
18:13:34 <zovt> Yep, nothing is shown. The "Got a connection" line is printed to the console, but the next line seems to be blocked, even though some data is sent
18:13:52 <aaronlevin> any vim users encounter this bug in ghcmod-vim before? https://github.com/eagletmt/ghcmod-vim/issues/75
18:14:37 <Eduard_Munteanu> zovt, oh, I see the issue... you only call hGet once for a connection
18:14:52 <zovt> oh?
18:15:38 <Eduard_Munteanu> zovt, hGet can return with less data than requested
18:16:25 <zovt> and that blocks it?
18:16:36 <zovt> I just have 1024 there for a theoretical max
18:16:46 <zovt> ideally, clients shouldn't be sending anywhere near that
18:16:56 <Eduard_Munteanu> Wait, no, that's hGetSome... *looks*
18:18:12 <Eduard_Munteanu> zovt, right so hGet blocks until it gives you 1024 characters, and that spans over your getLine so it blocks until all data is available.
18:18:36 <zovt> ah I see
18:18:39 <Eduard_Munteanu> zovt, only when the connection is closed it realizes there can't be any more data
18:18:55 <zovt> is there a way to manually say read pls
18:19:38 <zovt> or another function that would do something similar
18:19:40 <Eduard_Munteanu> zovt, well, TCP caveats apply. Particularly, you have to know when to read, because there are no message boundaries.
18:20:25 <Eduard_Munteanu> zovt, but BSL.hGetContents should work, I think
18:20:28 <zovt> Right. I mean, I'd like it to block until a message is sent, but I don't necessarily know the length of the message coming
18:20:37 <zovt> Ok, I'll try that
18:21:39 <zovt> still no dice
18:21:41 <zovt> hmmmm
18:23:48 <Eduard_Munteanu> zovt, i'd use strict bytestrings and hGetSome, which will return partial reads
18:24:33 <zovt> Yeah, I think that's what i'll have to end up doing. I was trying to avoid that though since MessagePack uses Lazy ByteStrings, but I guess I'll have to do the conversion
18:24:34 * Eduard_Munteanu . o O (Come hGetSome!)
18:25:05 <Eduard_Munteanu> zovt, isn't there some MessagePack conduit?
18:25:45 <Eduard_Munteanu> It's nicer than using bytestrings directly.
18:25:52 <zovt> Although, I will say that doing a similar thing with the higher-level network stack worked, as in, I could send a newline character and the server would read
18:26:03 <zovt> c-conduit? ( o.o')
18:28:04 <mniip> I need a 'Set (String, String)' backed by persistent storage, i.e persisting between program invocations, what's the quickest solution for that?
18:28:05 <Eduard_Munteanu> zovt, that's another issue, MessagePack like JSON has no message boundaries, you'll have to implement those
18:28:57 <zovt> Eduard_Munteanu: why is that a problem and why do I have to implement them
18:29:03 <zovt> not trying to sound snarky, just curious
18:29:08 <Eduard_Munteanu> mniip, acid-state?
18:29:08 <zovt> I'm new to this whole networking deal
18:30:28 <mniip> transaction log sounds like low performance
18:30:46 <Eduard_Munteanu> zovt, you have to feed the messagepack library bytestrings containing one whole and only one msgpack message
18:31:37 <zovt> right, I understand that
18:31:43 <Eduard_Munteanu> zovt, so you have to break up the input somehow, preferably without parsing msgpack
18:32:03 <zovt> what do you mean by break up the input?
18:32:16 <zovt> if the client is always sending a msgpack'd array
18:32:34 <zovt> why do I need to break anything up or set boundaries
18:32:37 <groot> hello =-)
18:32:38 <Eduard_Munteanu> zovt, is it sending one big array?
18:32:43 <zovt> yep, that's it
18:33:12 <Eduard_Munteanu> zovt, the problem is many such parsers aren't streaming parsers... they expect the entire array to be available
18:33:33 <Eduard_Munteanu> groot, hi
18:33:55 * mniip wonders if it's the same groot
18:33:57 <groot> hey eduard 
18:34:05 <zovt> which is why I'd like to be able to send the entire array in one request
18:34:10 <zovt> and then wait for another array
18:34:11 <groot> probably not i just joined the channel
18:34:21 <mniip> it isn't
18:34:22 <Eduard_Munteanu> zovt, so there isn't just one array after all
18:34:43 <zovt> well, the clients would be sending and receiving multiple arrays that contain API information
18:35:02 <zovt> which is why I'd like to keep the sockets open, to prevent overhead
18:35:33 <Eduard_Munteanu> zovt, consider sending "[0, 1, 2]" then "[3, 4, 5]" from the client. The server could receive "[0, 1, 2][3" and ", 4, 5]". I'm using JSON to simplify things.
18:36:03 <Eduard_Munteanu> Or just one big "[0, 1, 2][3, 4, 5]".
18:36:13 <Eduard_Munteanu> Or three buffers etc..
18:36:49 <zovt> ok, so clients send requests in the form of [ "method name", [ args ] ]
18:37:08 <zovt> and then the server sends back [ 0/1, [ results ] ]
18:37:18 <zovt> are you suggesting that I break that up somehow?
18:38:18 <Eduard_Munteanu> zovt, no, but you need to know when you're done reading input and it's time to process it and return results.
18:38:38 <zovt> right right
18:38:52 <zovt> which is why ideally i'd like to not deal with manually checking that
18:39:03 <zovt> btw thank you you've been a great help so far
18:40:01 <Eduard_Munteanu> zovt, you should use a real messagepack-based RPC mechanism.
18:40:24 <Eduard_Munteanu> Just like JSON-RPC is for JSON.
18:40:35 <zovt> heh, I know. There is actually a messagepack-rpc for haskell, but I was thinking I'd give rolling my own a shot
18:40:52 <zovt> maybe I'll just take a look at the source and try to figure it out
18:41:35 <Eduard_Munteanu> zovt, easiest way would be to implement a length + message schema, I suppose
18:42:39 <zovt> yeah I could always do that. I just figured it would be easier to just read the request in full in one shot, but I could always do that
18:43:01 <Eduard_Munteanu> zovt, yeah, but there's no notion of request/message in TCP.
18:43:39 <zovt> Right. I just figured that I could read a message of unknown length, but I guess not
18:44:43 <zovt> brb, gotta run to the little haskellers room
18:47:22 <Welkin> I have never heard that one
18:49:04 <Eduard_Munteanu> mniip, you could have a thread write it to disk once in a while, via e.g. safecopy
18:49:13 <Eduard_Munteanu> But acid-state should be ok.
18:54:34 <zovt> I have returned
18:54:54 <zovt> hello everyone
18:58:57 <zovt> Eduard_Munteanu: https://hackage.haskell.org/package/conduit-extra-1.1.4/docs/Data-Conduit-Network.html
18:59:12 <zovt> that's what the msgpack-rpc library is using
18:59:29 <Eduard_Munteanu> zovt, yeah, that's good
18:59:53 <zovt> guess I'll just rewrite my server ; - ;
19:01:34 <zovt> $$+
19:01:39 <zovt> what does that operator do
19:02:17 <Eduard_Munteanu> zovt, do you know $$ ?
19:02:26 <Eduard_Munteanu> :t ($$)
19:02:27 <lambdabot> Doc -> Doc -> Doc
19:02:30 <Eduard_Munteanu> Er.
19:02:44 <Eduard_Munteanu> @hoogle ($$)
19:02:44 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
19:02:45 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
19:02:45 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
19:02:57 <Eduard_Munteanu> @hoogle Data.Conduit.($$)
19:02:57 <lambdabot> Parse error:
19:02:57 <lambdabot>   Data.Conduit.($$)
19:02:57 <lambdabot>        ^
19:03:04 <Eduard_Munteanu> :t Data.Conduit.($$)
19:03:05 <lambdabot> Not in scope: data constructor ‘Data.Conduit’
19:03:12 <Eduard_Munteanu> Bleh.
19:03:23 <zovt> Yeah, I've never used Conduit
19:03:25 * hackagebot base91 0.1.1 - A Base91 encoder & decoder  http://hackage.haskell.org/package/base91-0.1.1 (ajg)
19:04:12 <Eduard_Munteanu> zovt, anyway, ($$) connects a source and a sink together. ($$+) does the same, but also gives you a source for leftovers if the sink terminates early.
19:04:12 <zovt> Got some learnin' to do tonight
19:04:26 <zovt> thanks for the help
19:05:14 <Eduard_Munteanu> zovt, https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
19:05:40 <zovt> thanks <3
19:06:17 <Eduard_Munteanu> zovt, you could just use msgpack-rpc, since it does more than just request-response stuff, I think.
19:07:02 <zovt> Yeah I may end up just using that, but ideally I'd like for clients to not have to use it, since that limits the supported languages 
19:07:27 <Eduard_Munteanu> zovt, by the way, it isn't Haskell-specific
19:07:42 <zovt> yeah I know
19:08:22 <zovt> they have go, php, erlang, python, cpp, and some others 
19:08:35 <zovt> but again, that limits the supported languages
19:08:49 <Eduard_Munteanu> zovt, another alternative may be MessagePack over HTTP (which gets you message boundaries)
19:09:17 <zovt> wouldn't http be overkill though?
19:09:31 <zovt> for clients that may be sending a few dozen requests/second
19:09:37 <Eduard_Munteanu> Possibly.
19:10:21 <zovt> yeah I'd like to avoid that bottleneck
19:11:53 <Eduard_Munteanu> zovt, still, MessagePack-RPC could be implemented client-side easily. At least JSON-RPC is, just don't use more advanced features like notifications.
19:12:22 <zovt> that's true. I'll see how this ends up working out
19:13:53 <yayfoxes> alright Cale I have eaten and have fed myself water. I am now reading your haskell book
19:18:07 <Javran> @hoogle Show a => a -> Text
19:18:08 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
19:18:08 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
19:18:08 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
19:18:21 <Javran> :t pack . show
19:18:22 <lambdabot>     Not in scope: ‘pack’
19:18:22 <lambdabot>     Perhaps you meant one of these:
19:18:22 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
19:33:44 <codygman> I'm having trouble replicating this sql query with esqueleto. It seems that you can't use where on a join? Hopefully I'm just doing it wrong: http://lpaste.net/136142
19:55:02 <saulzar_> codygman, Did you mean to have ProjectId twice or should one be UserProjectUserId?
19:55:29 <saulzar_> codygman, Or rather UserProjectProjectId
19:57:21 <codygman> saulzar_: Actually it was supposed to be: UserProjectProjectId
19:57:26 <codygman> Updating/trying new stuff now
20:03:50 <codygman> I fixed it, I had misnamed currentUserId which wasn't a Key UserId at all but was a Entity User.
20:08:01 <bob_twinkles> is automatic deriving of Show/Eq instances supposed to break down for GADTs with DataKinds?
20:08:26 <exio4> you can try standalone deriving
20:08:33 <geekosaur> IIRC it just doesn't work with GADTs?
20:08:58 <bob_twinkles> standalone deriving gets closer, but the generated instances don't typecheck =P
20:09:34 <shachaf> GADT is a syntax, not a sort of type.
20:10:00 <dramforever> shachaf: no way!
20:10:15 <shachaf> What?
20:10:23 <dramforever> gadt is generalized adt right? it's even more general than existential quantifiers
20:10:54 <ferret2_> do you need any type system extensions for GADTs or just proper generation of the pattern match rules and types?
20:10:58 <shachaf> Everything you can do with GADT syntax you can do without it in GHC.
20:13:48 <nolraiU> shachaf: really?
20:14:03 <nolraiU> How?
20:14:15 <shachaf> Using other GHC extensions.
20:14:28 <exio4> yes, you just need to throw explicit foralls for the existential types in the constructors + type equalities
20:14:55 <dramforever> hmm...okay
20:15:28 <dramforever> wait if we have data A x where IntA :: A Int; BoolA :: A Bool
20:15:38 <bob_twinkles> could be I'm not expressing the standalone instancing correctly... see http://lpaste.net/136143
20:16:08 <dramforever> shachaf: can we do it without gadts?
20:16:29 <shachaf> Yes.
20:16:32 <dramforever> oh yes
20:16:33 <dramforever> ...
20:16:43 <ferret2_> can you get the types like `data F :: * -> * where foo : F (a -> b) -> F a -> F b`
20:16:59 <shachaf> Yes.
20:17:03 <dramforever> ferret2_: yes
20:17:07 <ferret2_> I don't know how to give a constructor that type without gadts
20:17:27 <dramforever> that looks what existentials could do
20:17:27 <shachaf> The answer is yes no matter what you ask. GHC doesn't represent GADTs in a special way internally.
20:17:34 <dramforever> okay
20:18:37 <dramforever> ferret2_: look
20:18:45 <dramforever> @let data F a = forall x. C (F (x -> a)) (F x)
20:18:46 <lambdabot>  Defined.
20:18:50 <dramforever> :t C
20:18:51 <lambdabot> F (x -> a) -> F x -> F a
20:19:01 <bob_twinkles> :k C
20:19:02 <lambdabot> F (k1 -> k) -> F k1 -> F k
20:19:09 <dramforever> lol datakinds
20:19:57 <ferret2_> dramforever: ok. generalizes in the obvious way to multiple constructors?
20:20:06 <dramforever> I guess so
20:20:18 <dramforever> looks like you sometimes need TypeFamilies
20:20:29 <dramforever> although I'm not really sure why...
20:22:20 <Pastaf> any idea why this might be happening?
20:22:22 <lpaste> Pastaf pasted “No title” at http://lpaste.net/136144
20:22:32 <lpaste> Exio4 pasted “silly examples of things that GADTs may desugar to in GHC” at http://lpaste.net/136145
20:23:56 <exio4> dramforever: if case you want to see the paste, for possible ways to desugar GADTs into existentials + type equalities :P 
20:24:10 <dramforever> ok
20:24:27 <ferret2_> exio4: thanks, that's clear
20:25:02 <dramforever> oh right thanks for the lesson
20:25:41 <yayfoxes> Cale: I want cake
20:26:01 <yayfoxes> found an emoticon of cake and now i want cake
20:33:18 <Pastaf> nuking .ghc did not help
20:33:44 <dramforever> hmm...interesting: http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js here the poster says one of the "many things that are attracting with Node.js" is "Events: No thread manipulation, the programmer only provides callbacks"
20:34:21 <gamegoblin> @pl \a b -> a <> x <> b
20:34:21 <lambdabot> (<>) . (<> x)
20:35:00 <dramforever> so the haskell way is thread manipulation and synchronous calls?
20:35:27 <yayfoxes> can I give another calculation for the result of double (double 2) here?
20:35:46 <dramforever> forget it never mind
20:36:26 <yayfoxes> double 2 is x + x
20:36:35 <yayfoxes> so double 92 +2
20:36:56 <yayfoxes> so double (2 +2) is double 4 which is 4 + 4 which is 8
20:37:08 <yayfoxes> any problems?
20:37:17 <dramforever> no problems
20:37:32 <dramforever> but I doubt if haskell evals that way
20:37:44 <yayfoxes> ok...
20:37:46 <mniip> to be perfectly correct, double (2+2) is (2+2)+(2+2)
20:37:57 <mniip> which is 4+(2+2) which is 4+4 which is 8
20:38:14 <mniip> or actually with GHC's graph semantics we can skip the step 3
20:38:24 <dramforever> it should be something like double (double 2) -> double (2 + 2) -> let x = (2 + 2) in x + x -> let x = 4 in x + x -> 8
20:38:27 <ferret2_> mniip: shouldn't the second one be the same thunk
20:38:37 <ferret2_> ah, yeah
20:38:44 <yayfoxes> so does double (double 2) equal 8? 
20:38:54 <dramforever> I guess my let one explains it better
20:39:11 <dramforever> > let double x = x + x in double (double 2) == 8
20:39:12 <lambdabot>  True
20:39:31 <yayfoxes> dramforever: cheater! lol
20:39:31 <dramforever> yayfoxes: if "equal" means (==), then yes
20:39:56 <dramforever> @check let double x = x + x in double (double 2) == 8 -- quickcheck for sure lol
20:39:57 <lambdabot>  <hint>:1:96:
20:39:57 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
20:40:04 <dramforever> no...
20:40:28 <yayfoxes> ok how do i show sum [x] = x for any number x?
20:40:31 <yayfoxes> @src sum
20:40:32 <lambdabot> sum = foldl (+) 0
20:40:53 <mniip> dramforever, well that's Eq equality, not universal quantification
20:41:10 <dramforever> mniip: that's why I wrote "lol"
20:41:28 <yayfoxes> su
20:41:31 <geekosaur> hah, I think @check dislikes -- comments
20:41:37 <yayfoxes> > sum [1]
20:41:38 <dramforever> maybe
20:41:39 <lambdabot>  1
20:41:48 <geekosaur> @check let double x = x + x in double (double 2) == 8 {- quickcheck for sure lol -}
20:41:50 <lambdabot>  +++ OK, passed 100 tests.
20:42:18 <geekosaur> because column 96 was well beyond what you entered, so evidently it was adding something else on the end of the line (and also the beginning)
20:42:21 <yayfoxes> erm..but how do you prove that? I've never studied mathematical proofs
20:42:52 <mniip> yayfoxes, US?
20:43:03 <yayfoxes> mniip: yes
20:43:12 <mniip> it amazes me how americans aren't taught such a basic part of mathematics
20:43:22 <mniip> not only basic but also essential
20:43:30 <yayfoxes> mniip: until high school you mean?
20:43:32 <dramforever> I guess we need to prove 2# +# 2# =math= 4# (where =math= means math equality)
20:43:45 <dramforever> and 4# +# 4# =math= 8#
20:44:13 <dramforever> wait we don't have to
20:44:14 <ferret2_> yayfoxes: symbolically evaluate sum [x]
20:44:17 <mniip> yayfoxes, in here  we figure out 'forall' and 'exists' in like... 7th grade, I think? 
20:44:49 <yayfoxes> mniip: then I need to study math
20:45:10 <mniip> it wasn't until very recently that I found out it's not the same in the us
20:46:00 <dramforever> here in China we introduce the quantifiers forall and exists in 10th grade, but we use natural language to quantify stuff before that
20:46:28 <mniip> likewise
20:46:35 <yayfoxes> you foreigners are so ahead of the times
20:46:36 <dramforever> so we know "there exists real number x such that ..." like...yeah also 7th grade
20:46:47 <dramforever> s/know/understand/
20:46:55 <mniip> and the fact that a counterexample is a disproof, but an example is not a proof
20:47:52 <mniip> yayfoxes, you know pythagoras theorem right
20:48:05 <yayfoxes> mniip: no, too behind in math
20:48:17 <Ivan97> Hi, everyone
20:48:17 <lolisa> dramforever, chinese here, doubt that they ever teach prop logic, probably differ for different region
20:48:31 <dramforever> Ivan97
20:48:33 <dramforever> hi
20:48:37 <marchelzo_> mniip: Where are you from?
20:48:41 <mniip> russia
20:48:51 <lolisa> AFAIK even if prop logic was used in gao kao, it is still extremely basic...
20:49:04 <dramforever> lolisa: oh maybe it's not 10th grade...
20:49:49 <mniip> yayfoxes, well, I can't think of an analogous theorem that you might know
20:49:49 <dramforever> lolisa: many stuff taught in textbooks are not used in gao kao
20:49:58 <lolisa> IDK, I never took gao kao (international student here)
20:50:05 <silasm> I swear some of my classmates never had to write a proof until college
20:50:05 <Ivan97> I'm trying to set up IRC server, anyone can help me?
20:50:12 <mniip> but basically you're being taught the multiplication table without knowing that 4 comes after 3
20:50:47 <dramforever> Ivan97: hmm you look weird asking that here.
20:50:58 <mniip> Ivan97, are you sure you're in the right channel
20:51:01 <lolisa> dramforever, can you read chinese?
20:51:10 <yayfoxes> mniip: so where do i go to learn all maths? Khan academy? I've been out of school for years and I really need some help
20:51:12 <Ivan97> dramforever: sorry...
20:51:15 <dramforever> lolisa: sure why not?
20:51:24 <Javran> lol
20:51:25 <lolisa> Just a check...
20:51:32 <dramforever> so much off topic discussion here
20:51:45 <dramforever> lolisa: 我还会写中文呢！
20:51:45 <Ivan97> lolisa: 哥们儿
20:51:58 <Ivan97> 你们闹呢吧…
20:52:00 <lolisa> You must use qq then... Just to let you know the haskell forum in qq is of good quality, just search :)
20:52:05 <Javran> 什么鬼...
20:52:06 <lolisa> 好多中国人。。。
20:52:10 <dramforever> ...
20:52:12 <Ivan97> 卧槽…
20:52:17 <dramforever> lolisa: try #haskell-cn
20:52:25 * mniip only knows one word in chinese... 下载
20:52:36 <marchelzo_> mniip: In what grade do they introduce the pythagorean theorem in russian curriculum?
20:52:51 <Javran> #haskell-cn is not that popular though
20:52:55 <dramforever> yeah
20:52:56 <yayfoxes> mniip: what's that? hello or bathroom or a curse word?
20:53:02 <dramforever> download
20:53:17 <mniip> yayfoxes, it says "download"
20:53:22 <mniip> marchelzo_, 8th I think
20:53:25 <yayfoxes> mniip: oh :)
20:54:00 <marchelzo_> mniip: Do they give a proof of it as well, or do they just sort of assert its hypothesis?
20:54:08 <mniip> marchelzo_, of course they do
20:54:09 <yayfoxes> I'm going to learn japanese
20:54:21 <yayfoxes> and spanish.
20:54:30 <mniip> I think the square inside the square with 4 equal triangles is the most popular one
20:54:31 <yayfoxes> but first math
20:54:32 <nshepperd> yayfoxes: khan academy might really be a good idea, it covers everything from basic arithmetic to diff eqs
20:54:34 <marchelzo_> mniip: Here it's just given. I never saw a proof of it in school.
20:54:51 <yayfoxes> nshepperd: ok then, khan academy it is
20:54:52 <nshepperd> not sure if they get you to do proofs though
20:55:42 <lolisa> Just of curiosity how much time do I have to put in japanese to reach the level of able to listen to song of it and get the meaning? I hate the fact that I've no idea what I'm listening everyday...
20:56:11 <peddie> you guys know about #haskell-blah?
20:56:54 <marchelzo_> mniip: The only theorems I remember being shown proofs of are the law of sines and the law of cosines. And before the teacher gave the proofs, she said (paraphrasing) "You don't need to know this, or do this. You won't be evaluated on it. I'm just showing you so you can see where it comes from".
20:57:29 <mniip> dramforever, some guy even taught me how to draw this thing! http://i.imgur.com/WBdTl7g.gif
20:57:53 <dramforever> lol draw this
20:57:58 <mniip> marchelzo_, I have issues remembering theorems if I don't know the truth
20:58:12 <mniip> er
20:58:18 <mniip> I got distracted
20:58:21 <mniip> marchelzo_, I have issues remembering theorems if I don't know the proof
20:58:31 * dramforever remembers being taught all sorts of proofs for cos(a - b) = cos a cos b - sin a sin b
20:58:44 <exio4> mniip: knowing the truth guides you thru a life of peace? 
20:58:47 <mniip> for one, I don't remember the proof for the sine of a sum
20:58:58 <marchelzo_> dramforever: We were just handed a sheet of trigonometric identities.
20:58:59 <lolisa> Speaking of proof, I always remember about tons of geometric proof problem in china education... They make me sick
20:59:03 <mniip> I always derive it from sh/ch representations of sin/cos
20:59:23 <dramforever> marchelzo_: the only proof I can remember is based on the cos low
20:59:24 <dramforever> *law
21:00:26 <dramforever> mniip: actually ancient chinese characters *were* drawings
21:00:38 <mniip> cos(a + b) + isin(a + b) = e^i(a + b) = e^ia * e^ib = (cos a + isin a)(cos b + isin b) = (cos a cos b - sin a sin b) + i(cos a sin b + sin a cos b)
21:00:40 <dramforever> they were just, you know, normalized
21:00:55 <lolisa> And the funny thing is ATP(automatic theorem prover) is doing a wonderful job(from what I'd read from book), better than human in proofing such... So now everytime I think about it I'm like "Why TF do they teach this in class?"
21:00:59 <mniip> if two complex numbers are equal, then their real parts and complex parts are equal
21:01:24 <dramforever> mniip: oh yes, but we don't know complex numbers when taught that
21:01:33 <mniip> true
21:01:35 <dramforever> sure sh and ch are helpful
21:01:40 <mniip> I do remember a geometric proof too
21:01:40 <shachaf> This conversation is too off-topic for this channel. Please move it elsewhere.
21:01:53 <dramforever> okay
21:02:09 <dramforever> maybe go to #haskell-blah?
21:18:38 <sccrstud92_> or ##math
21:19:03 <mniip> is there something that lets me write a select-like program in haskell
21:19:20 <mniip> i.e socket data availability based event loop
21:20:10 <dramforever> maybe look for select/epoll/libev bindings
21:20:21 <dramforever> hmm...conduits?
21:20:24 <dramforever> pipes?
21:20:24 <peddie> mniip: probably just use threads, the ghc runtime is supposed to take care of that for you
21:20:43 <dramforever> yeah that seems to be the haskell way
21:20:49 <mniip> but my program fits *very* nicely into the select loop :(
21:21:09 <dramforever> I don't know if conduits/pipes work
21:21:33 <peddie> mniip: mine did too . . .
21:22:41 <dramforever> mniip: maybe you can use a chan or something
21:22:50 <dramforever> and let threads stuff events into them
21:22:53 <dramforever> *into it
21:23:30 <peddie> the runtime is already basically using epoll to manage I/O and threading really efficiently, so what I learned is it's best to use threads/MVars/Chans to be st take advantage of the runtime authors' hard work
21:23:47 <mniip> wait what
21:23:57 <mniip> what's ProtocolNumber in Network.Socket
21:24:42 <mniip> ah
21:24:49 <peddie> mniip: man getprotoent
21:24:53 <mniip> the protocol parameter to socket(2)
21:26:30 <peddie> yes
21:40:34 <ezrios> man what gives?
21:40:38 <ezrios> Happstack Book is down?
21:40:43 <ezrios> http://www.happstack.com/docs/crashcourse/index.html
22:18:11 <sccrstud92_> is there a way to run cabal test doctests only on a single module?
22:26:37 <eckyputrady> Hello guys. I'm having problem to catch Persistent's ConnectionError ... I've tried to use Control.Exception.try but it doesn't catch the exception ... can anybody help where I am missing?
22:27:49 <dramforever> eckyputrady: post relevant part(s) of your code
22:27:56 <dramforever> @where lpaste
22:27:56 <lambdabot> http://lpaste.net/
22:28:02 <lpaste> eckyputrady pasted “Persistent Error Uncaught” at http://lpaste.net/136149
22:28:06 <dramforever> http://lpaste.net/new/haskell maybe
22:28:14 <dramforever> oh never mind
22:28:36 * hackagebot xml-types 0.3.6 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.3.6 (JohnMillikin)
22:28:38 * hackagebot quiver 0.0.0.4 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.4 (patrykz)
22:28:59 <eckyputrady> I've just pasted it ... please take a look
22:29:15 * dramforever is reading that
22:31:01 <eckyputrady> The error happens when creating the MySQL pool, specifically at `createMySQLPool (connInfo rawCfg) 10` 
22:31:51 <dramforever> what does "the program is just terminated" mean? does it give an error message?
22:32:32 <eckyputrady> I mean the program terminates, instead of going to that part of code. Yes, the error message is "*** Exception: ConnectionError {errFunction = "connect", errNumber = 2005, errMessage = "Unknown MySQL server host 'fail' (0)"}"
22:33:09 <dramforever> replace runAppIO c with return (), does error still occur or program terminates without error?
22:33:31 <dramforever> wait never mind
22:34:14 <eckyputrady> yes, it terminates without error after changing to "return ()"
22:34:37 <dramforever> oh so I think that means runAppIO is throwing the exception, not getConfig
22:35:19 <eckyputrady> oh wow
22:35:24 <dramforever> it seems that this happened again: "step 1 to undebuggable bugs: misunderstand the error"
22:35:39 <eckyputrady> let me try something
22:36:10 <eckyputrady> yeah, I could misunderstand the error, just learning haskell here :)
22:36:34 <dramforever> eckyputrady: yes, the error is not coming from getConfig
22:36:38 <dramforever> but you thought it did
22:36:50 <dramforever> *was not coming
22:42:38 <eckyputrady> Yay. Fixed it. Thanks, dramforever
22:42:44 <dramforever> yw :)
22:44:47 <Pamelloes> Are there more functions for creating a NominalDiffTime outside of Data.Time.Clock?
22:48:01 <Cale> Pamelloes: What do you want to create one from?
22:48:31 <Cale> Pamelloes: Note the various classes that NominalDiffTime belongs to
22:48:52 <Pamelloes> Oooooooh
22:48:54 <Cale> (especially the numeric ones, which treat it as a number of seconds)
22:49:24 <Pamelloes> Alright, I think I can get it from here, then :)
22:49:37 <Pamelloes> I completely missed the class instances. I feel like an idiot.
22:49:52 <dramforever> :) always read instace list
22:50:37 <dramforever> I once asked "can I serialize a WaveFile from wavy to a bytestring? it seems that I can write to a file", the answer is "look there's instance Binary WaveFile"
22:53:48 <Pamelloes> What's the infix level of function application?
22:54:15 <ferret2_> tightest possible
22:54:22 <jle`> it's the highest of the highs...except not as high as record syntax
22:54:26 <jle`> record updators
22:54:45 <Pamelloes> Interesting.
22:55:10 <jle`> yeah, it tripped me up a lot when people did things like `sin x^2`
22:55:32 <jle`> but i just see now that function application binds tighest
22:55:33 <Pamelloes> huh... so that means sin^2 x, right?
22:55:39 <jle`> it's (sin x)^2
22:55:58 <jle`> sin is applied to x first, and the result is squared
22:56:01 <Pamelloes> ugh. That''s kind of obnoxious.
22:56:07 <dramforever> lol
22:56:15 <Pamelloes> (not that that's the way it works, but that specific example)
22:56:33 <jle`> yeah heh, i wouldn't write it that way.  but knowing "function application binds tightest" is a nice handy way of understandig things fast
22:57:06 <Pamelloes> It's always nice chopping out parentheses :)
22:58:21 <dramforever> it's particularly confusing because some other languages like ruby has "implicit" function application with lowest prec and right assoc
22:58:38 <dramforever> so f g 1+1 means f(g(1+1))
22:59:02 * Pamelloes raises an eyebrow
23:08:39 * hackagebot linear 1.18.3 - Linear Algebra  http://hackage.haskell.org/package/linear-1.18.3 (EdwardKmett)
23:08:41 * hackagebot http2 1.0.0 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-1.0.0 (KazuYamamoto)
23:08:43 * hackagebot hyperloglog 0.3.3 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.3.3 (EdwardKmett)
23:19:55 <NicX> Is it possible to hide an expression from GHC rewrite rules?
23:32:13 <YellowOnion> :t iterate
23:32:14 <lambdabot> (a -> a) -> a -> [a]
23:32:34 <YellowOnion> is that function space efficent?
23:32:44 <dramforever> YellowOnion: define that
23:33:10 <YellowOnion> interate f 0 !! largeNum
23:33:10 <dramforever> what do you mean by "space efficient"
23:33:38 <dramforever> @src iterate
23:33:38 <lambdabot> iterate f x = x : iterate f (f x)
23:33:40 * hackagebot wai-app-file-cgi 3.0.8 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.8 (KazuYamamoto)
23:33:42 * hackagebot mighttpd2 3.2.9 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.9 (KazuYamamoto)
23:33:58 <YellowOnion> somethings is using up my memory, and it gets worse with larger "LargeNum"'s
23:34:07 <dramforever> YellowOnion: maybe, who knows
23:34:09 <dramforever> ...
23:34:27 <liste> thunk buildup maybe?
23:34:41 <dramforever> oh it seems so
23:34:45 <YellowOnion> -hd outputs this: http://view.samurajdata.se/psview.php?id=62725f96&page=1
23:36:33 <pacak> YellowOnion: about the same as any other iterative process. It won't hold any references to unused stuff.
23:38:08 <YellowOnion> can I use do notation to apply a function to itself x times and return the result?
23:38:50 <dramforever> YellowOnion: no why are you thinking about do notation?
23:41:44 <YellowOnion> dramforever, not sure, I think my headache is getting in the way.
23:41:52 <liste> @let iterate' f x = x : iterate f $! f x
23:41:53 <lambdabot>  .L.hs:150:16:
23:41:53 <lambdabot>      Couldn't match expected type ‘a -> b’ with actual type ‘[a]’
23:41:53 <lambdabot>      Relevant bindings include
23:42:03 <liste> @let iterate' f x = x : iterate' f $! f x
23:42:04 <lambdabot>  .L.hs:150:16:
23:42:05 <lambdabot>      Couldn't match expected type ‘a -> b’ with actual type ‘[a1]’
23:42:05 <lambdabot>      Relevant bindings include
23:42:17 <liste> @let iterate' f x = x : (iterate' f $! f x)
23:42:19 <lambdabot>  Defined.
23:42:27 <pacak> > iterate (+1) 1 !! 100
23:42:29 <lambdabot>  101
23:42:36 <pacak> > iterate (+1) 1 !! 10000
23:42:37 <lambdabot>  10001
23:42:55 <liste> > iterate' (+1) 1 !! 10000
23:42:57 <lambdabot>  10001
23:43:05 <pacak> > iterate (+1) 1 !! 100000
23:43:07 <lambdabot>  100001
23:43:42 <YellowOnion> :t ($!)
23:43:43 <lambdabot> (a -> b) -> a -> b
23:43:45 <pacak> > sum [1..100000]
23:43:47 <lambdabot>  5000050000
23:43:52 <liste> $! is a strict version of $
23:44:05 <liste> @src ($!)
23:44:05 <lambdabot> f $! x = x `seq` f x
23:47:39 <liste> maybe it would help in this case? I'm not sure
23:48:28 <liste> but if I'm right, iterate (+1) 1 !! 5 would look something like (+1) (+1) (+1) (+1) (+1) 1 in memory
23:48:46 <liste> and iterate' (+1) 1 !! 5 would be (+1) 5
23:49:31 <liste> there was a way to examine that in ghci but I forgot how
23:49:55 <LordBrain> using the set command?
23:50:24 <LordBrain> there is a flag for the set command i think
23:50:40 <LordBrain> i have not used it, but i recall reading
23:50:50 <liste> or was it :print
23:51:01 <YellowOnion> I'm still running out of memory with that as well.
23:51:07 <liste> :print [<name> ...] -- prints a value without forcing its computation
23:51:26 <jle`> for Alternative and Traversable t, is join = asum ?
23:51:31 <jle`> :t [join, asum]
23:51:32 <lambdabot>     Not in scope: ‘asum’
23:51:32 <lambdabot>     Perhaps you meant one of these:
23:51:32 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
23:51:37 <jle`> :t [join, F.asum]
23:51:37 <pacak> YellowOnion: What kind of object are you iterating over?
23:51:38 <lambdabot> (Monad m, Foldable m, Alternative m) => [m (m a) -> m a]
23:51:43 <jle`> are they suppose to be the same for every type?
23:52:48 <jle`> i'm trying to think of a type where join /= asum
23:52:51 <YellowOnion> pacak, its a list
23:53:10 <pacak> YellowOnion: Try forcinig that list on each step
23:53:48 <jle`> yeah, iterate is pretty bad space-wise
23:53:50 <jle`> ironically
23:54:00 <YellowOnion> f [] -> []
23:54:06 <jle`> i mean, indexing onto iterate
23:54:17 <jle`> you can use the normal iterate fine if you have a strict !!
23:54:38 <jle`> too bad there's no strict !! or strict iterate in the libs
23:55:22 <YellowOnion> I don't even need to use interate per-se, I just need something to profile this function a bunch of times.
23:55:38 <pacak> profile?
23:55:41 <pacak> @hackage criterion
23:55:41 <lambdabot> http://hackage.haskell.org/package/criterion
23:57:45 <YellowOnion> pacak, I wanted to test it applying the function to its output, I don't really want to have to learn an entire benchmarking suite.
23:58:31 <pacak> YellowOnion: It's relatively simple, all you need to do is to copy'n'paste an example and tweak that a bit.
23:58:59 <jle`> YellowOnion: iterate wiht strict indexing is waht i usually do
23:59:06 <jle`> or a strict iterate, or strict iterateN
23:59:12 <jle`> admittedly it's a bit annoying
