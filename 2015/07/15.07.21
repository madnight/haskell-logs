00:07:36 <jle`> i don't think there's any way to expand foldl that'll evaluate to something
00:07:39 * hackagebot limp-cbc 0.3.2.1 - bindings for integer linear programming solver Coin/CBC  https://hackage.haskell.org/package/limp-cbc-0.3.2.1 (amosrobinson)
00:07:39 * hackagebot ms 0.2.1 - metric spaces  https://hackage.haskell.org/package/ms-0.2.1 (RickyElrod)
00:37:13 <f-a> https://ghc.haskell.org/trac/ghc/wiki/Building/Compiling32on64 <-- is the reverser possible (i.e. compiling a 64 binary on 32 bit arch)?
00:37:57 <ttt_fff> TOP DOWN for the win
00:38:00 <ttt_fff> for desining haskell programs
01:12:43 <ThomasLocke> Are there any libraries out there for working with the Google cloud offerings, such as Datastore and Storage?
01:13:40 <jakeehrlich> So why not allow bi-directional pattern synonyms to contain view patterns?
01:14:53 <jakeehrlich> for instance take this pattern: Beta0 (Beta0 (SBlock_ (map Wrap1 -> x)))
01:16:24 <jakeehrlich> (map Wrap1) is a constructor and thus a bijection (and map preserves bijections). So as long as my computation is a bijection this should be allowed, right? 
01:22:37 * hackagebot cgrep 6.4.18 - Command line tool  https://hackage.haskell.org/package/cgrep-6.4.18 (NicolaBonelli)
01:32:18 <hvr> best synopsis eveer
01:32:55 <frerich> Well it might have been just 'a tool', so I'm sure glad that I can tell right away that it's not a GUI application!
01:33:38 <hnfmr> what is the recommended library for parsing command line options?
01:33:46 <hnfmr> optparse-applicative?
01:33:53 <indiagreen> hnfmr: yeah
01:33:57 <hnfmr> ok
01:49:24 <meow> Is there a place to find best practices for installing Haskell and libraries?
01:50:26 <meow> Hopefully this is not the wrong place to ask...
01:50:34 <frerich> meow: I like the Haskell Platform and happily used it since years, but for some reason that approach is somewhat unpopular around here I think. :-]
01:51:11 <frerich> meow: The 'Haskell Platform' is basically a package with the compiler and a couple of nice libraries. Maybe it doesn't work so well on all platforms though - I'm on OS X, so if you're on some other system your experience may vary.
01:51:21 <meow> <-- Ubuntu 15.04
01:51:39 <mpickering> you will get 10 different answers to this question
01:51:56 <frerich> meow: I see - I'll shut up then. Maybe somebody else running Ubuntu can shed some light. Maybe there are even nice ready-made Ubuntu packages for things.
01:52:00 <rbocquet> you should probably install ghc from https://launchpad.net/~hvr/+archive/ubuntu/ghc
01:52:08 <meow> well I mean, I ask because coming from other languages, there are tools to keep packages and such under control
01:52:32 <meow> and I'm trying to install Haskell for first time, and hope that there is a convergence on technique
01:52:44 <rbocquet> then use cabal to install packages
01:53:30 <meow> I see, so just install Haskell compiler GHC, and it'll come with Cabal?
01:53:54 <hvr> Cabal the library
01:54:31 <hvr> meow: you should also install the appropriate 'cabal-install-x.yy' package
01:55:15 <meow> Is every Cabal married to a particular GHC?
01:55:26 <hvr> yes and no
01:55:50 <hvr> in the latest GHC, Cabal could in theory be left out of the binary distribution
01:56:16 <hvr> in previous GHCs Cabal was a proper build-dep of the ghc pkg
01:56:39 <hvr> but you can usually install  a newer Cabal lib with an older GHC
01:57:03 <meow> okay woot thanks
01:57:12 <hvr> in fact, I use cabal-install-1.22 w/ GHC 7.0 through GHC 7.10
02:02:38 * hackagebot dtw 1.0.1.0 - (Fast) Dynamic Time Warping  https://hackage.haskell.org/package/dtw-1.0.1.0 (fho)
02:06:46 <ttt_fff> does anyone else feel this irressitable desire
02:06:55 <ttt_fff> to master a SQL langauge like one masters haskell?
02:07:01 <ttt_fff> but I can't find a set of exercises to get me good at postgresql
02:08:15 <meow> Is "Learn You a Haskell" still the canonical beginning Haskell book?
02:08:48 <dramforever> https://github.com/bitemyapp/learnhaskell has some guides on choosing material to work with
02:09:19 <indiagreen> ttt_fff: I did once, but I got rid of it
02:09:39 <ttt_fff> indiagreen: how ?
02:09:53 <meow> thanks @dramforever
02:10:12 <ttt_fff> meow: I've found the most effective way to be (1) writ ehaskell for a big project (2) bitch on #haskell, (3) get angry at people not answering my questions to my high demand, and (4) motivation to read docs
02:10:19 <dramforever> meow: btw you tell one to pay attention like this
02:10:23 <indiagreen> ttt_fff: by finishing the part of project that required me to use SQL
02:10:45 <wickedtrippy> Haskell has THE most trippy syntax out of ALL languages to the untrained eye, imo
02:11:16 <dramforever> wickedtrippy: how about APL?
02:11:17 <ttt_fff> there's something beautiful about sql that haskell lacks
02:11:18 <dramforever> =P
02:11:30 <ttt_fff> dramforever: see *untrianed eye*
02:11:58 <dramforever> ttt_fff: huh? so what's the trippy thing?
02:12:19 <wickedtrippy> I know Java, Python, Ruby, HTML, CSS and JS, with a little C++, yet Haskell's syntax looks more complex and mind-bending than all of those plus assembly...
02:15:09 <frerich> wickedtrippy: If you mean 'more complex' as in 'less noisy', then I agree. :-) For what it's worth, the syntax is actually quite simple but there's a lot of freedom in naming functions. Things like the '.' in 'f . g' are functions, just as in 'f $ g' the '$' is a function.
02:15:22 <frerich> Oh, I guess I'm too late.
02:16:19 <hyy> if it wasn't a hosted environment could I write a C program with no main function?
02:16:42 <hyy> I want to reboot my computer and swap it between AAAA and BBBB
02:16:49 <hyy> in C.
02:16:50 <meow> As a beginner I find the syntax rather trippy, far more than Clojure
02:17:03 <edk> hyy, you're on ##c, why not ask there?
02:17:06 <dramforever> one of my friends complained about the operators
02:17:24 <hyy> edk: wrong channel
02:17:27 <frerich> hyy: This doesn't seem like a Haskell-specific question, but you could write a C program 'int main;'.
02:17:30 <hyy> whoops.
02:17:43 <frerich> You just need the 'main' symbol.
02:17:48 <thimoteus> weird, i find haskell's syntax to be very close to what i would write by hand if i had to
02:18:14 <edk> int main; wouldn't be a correct C program. but anyway, ##c! i'll attempt to prevent any biting
02:18:52 <wickedtrippy> No wonder people say this language is for geniuses...
02:18:53 <dramforever> actually I find s-expressions  really nice when working on a computer
02:19:07 <frerich> wickedtrippy: Did you see my last message?
02:19:11 <wickedtrippy> This stuff (Haskell's syntax) is wicked trippy
02:19:25 <wickedtrippy> frerich: Nah, sorry; my computer was acting stupid
02:19:28 <edk> i like haskell's syntax, but the user-defined operators and the precedence structure are a bit odd coming from all the languages wickedtrippy listed
02:19:32 <frerich> wickedtrippy: If you mean 'more complex' as in 'less noisy', then I agree. :-) For what it's worth, the syntax is actually quite simple but there's a lot of freedom in naming functions. Things like the '.' in 'f . g' are functions, just as in 'f $ g' the '$' is a function.
02:19:50 <dramforever> wickedtrippy: so that's why you have that nick? =P
02:20:11 <frerich> wickedtrippy: And since you can define functions with names like '.' or '$', and you can apply them infix (i.e. between the arguments) you may end up thinking that it's syntax even though it's just plain function calls.
02:20:42 <dramforever> frerich: I guess that's wicked trippy enough =)
02:20:58 <frerich> I have no idea what "wicked trippy" means...
02:21:01 <edk> (you can also spell calls to infix functions with prefix notation by enclosing them in (): (+) 2 3 = 5)
02:21:20 <indiagreen> frerich: interesting, it actually never occurred to me that “.” or “$” could be seen as syntax
02:21:34 <chpatrick> a lot of haskell stuff is a language feature in other languages
02:21:36 <indiagreen> but it makes sense
02:21:42 <chpatrick> and a library in haskell
02:21:42 <dramforever> indiagreen: someone asked "what do the separators . and $ in haskell mean?"
02:23:15 <frerich> wickedtrippy: If you think that this freedom in naming (and applying) functions is 'wicked trippy', you might also enjoy a language called Tcl; it's a totally different language, but it's similiar in that it has a simplistic syntax and many things like 'if' or 'switch' are not actually part of the language but can be defined as library functions.
02:24:36 <wickedtrippy> frerich: Yes, just glancing at Haskell's pyschinostalgic syntax makes me want to try it
02:25:21 <frerich> wickedtrippy: If you're coming from Python/Ruby/Java/JavaScript -- well, that's largely the same thing really. ;-) When I started with Haskell, I thought that all programming languages are really mostly the same modulo syntactic differences. ;-)
02:25:45 <pyrtsa> '.' does play a syntactic role in module names though.
02:26:07 <indiagreen> and in qualified names
02:26:10 <frerich> pyrtsa: Sure, or in enumerations as in '[1..10];.
02:26:15 <pyrtsa> Right.
02:26:38 <pyrtsa> Yeah, *qualified* names was what I was looking for.
02:26:42 <ttt_fff> is there a good short documentation on how to implement datalog?
02:26:46 <ttt_fff> i.e. the full langauge of datalog and how to implement it
02:27:00 <frerich> ttt_fff: Maybe look at http://hackage.haskell.org/package/datalog ;-)
02:27:14 <meow> Are there some theory books I ought read to make use of Haskell?
02:27:14 <pyrtsa> For instance, you can't compose the data constructors 'A' and 'B' by writing 'A.B', you have to add spaces: 'A . B'
02:27:17 <ttt_fff> frerich: yeah, there's one on github, only one
02:27:27 <ttt_fff> frerich: the documentation is a bit light
02:27:40 <meow> Like, how important is category theory to haskell proficiency?
02:27:46 <ttt_fff> frerich: have you used that package, or are you responding beause you assumed I didn't bother to check hackage?
02:27:57 <ttt_fff> meow: it's not necessary to acheive a newb-level
02:28:02 <ttt_fff> meow: I don't know about the higher levels myself
02:28:16 <frerich> meow: I don't think so. I have no clue about math in general or category theory in Haskell and yet I happily use it for amusement and productive purposes. You pick up a few things along the way, but it's no prerequisite.
02:28:45 <peddie> meow: you don't need to know category theory to be proficient at haskell programming
02:29:02 <frerich> meow: I think a big step is to accept that there may be totally different (and ingenious) ways to make a computer do stuff than what you knew so far. So shaking off the Python mindset is a big part.
02:31:14 <indiagreen> it's entirely possible to treat Haskell as a nicer Pascal
02:31:51 <indiagreen> and some people are also trying to make it a nicer Bash
02:32:08 <naudiz> indiagreen: please don't
02:32:16 * indiagreen chuckles
02:32:33 <frerich> indiagreen: Or Basic! http://augustss.blogspot.de/2009/02/more-basic-not-that-anybody-should-care.html
02:32:40 * hackagebot cgrep 6.4.19 - Command line tool  https://hackage.haskell.org/package/cgrep-6.4.19 (NicolaBonelli)
02:36:09 <naudiz> frerich: I'm quite shocked.
02:36:53 <frerich> :-)
02:47:40 * hackagebot refact 0.2.0.0 - Specify refactorings to perform with apply-refact  https://hackage.haskell.org/package/refact-0.2.0.0 (mpickering)
02:48:28 <naudiz> I should learn for a test I'll have tomorrow but those Haskell articles just keep referencing other interesting articles
03:06:48 <noze> hi, I'm trying to get started with haskell on arch linux. What's the recommended way of installing packages from hackage? cabal? ArchHaskell?
03:07:41 <naudiz> noze: you should use cabal and always work inside a sandbox
03:08:02 <indiagreen> naudiz: and you should be studying for your test
03:08:22 <indiagreen> someone kick this slacker
03:08:28 <noze> naudiz: I see, what does `inside a sandbox' mean?
03:09:00 <mniip> cabal implements sandboxes
03:09:01 <naudiz> indiagreen: but I'm reading about language extensions :(
03:09:07 <chpatrick> you can install packages in a local directory instead of globally
03:09:11 <chpatrick> cabal sandbox --help
03:09:19 <indiagreen> naudiz: they add them faster than you can learn them anyway
03:09:23 <chpatrick> there's also stack which is the new hotness
03:09:30 <chpatrick> indiagreen: that's not really true
03:09:31 <mniip> closed environments with their own installed packages
03:09:53 <naudiz> noze: cabal package versions can collide. therefore you don't want to install most libraries globally
03:11:23 <indiagreen> chpatrick: okay, hm, you're right
03:11:23 <noze> chpatrick mniip naudiz: thanks; what's the usual workflow then? say I want to dabble with continuations, so I'll install some monad transformer package, and also I want agda. Do I set up separate sandboxes for each?
03:12:09 <mniip> otoh it's kinda hard to use sandboxes if your coding environment consists of one folder called misc
03:12:52 <indiagreen> noze: I'd say you should set up a sandbox for Agda but it's alright to install small packages globally
03:13:13 <naudiz> noze: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html maybe it's easier to read an article about it
03:13:28 <noze> thanks
03:15:32 <chpatrick> mniip: I have everything in haskell-misc :D
03:15:49 <chpatrick> having a lot of sandboxes eats a lot of disk space though
03:16:39 <noze> btrfs has deduplication, i'll worry about disk space in 2003
03:17:42 * hackagebot eigen 2.1.6 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  https://hackage.haskell.org/package/eigen-2.1.6 (OlegSidorkin)
03:18:38 <mniip> chpatrick, actually I lied
03:18:44 <mniip> mine is called r
03:18:52 <mniip> ~/r/
03:19:19 <dramforever> mniip: mine is called ~/mycode/, but I put subdirectories in it
03:19:32 <mniip> sometimes I don't even bother with filenames
03:19:47 <mniip> just edit a.hs and delete whatever was there before
03:19:50 <dramforever> so many are just like one written file ~/mycode/kanren/Kanren.hs plus a few generated one
03:19:57 <dramforever> oh and I have ~/tmp
03:20:14 <mniip> ohh I call that /t/
03:20:28 <dramforever> I have 168 files/dirs in tmp
03:20:43 <dramforever> wait is that off topic?
03:20:49 <indiagreen> I don't bother and have /tmp (without ~)
03:20:54 <mniip> I have twice that many in /r probably
03:27:00 <ttt_fff_> lst = [f1, f2, f3, f4, f5, f6] , .... how do I generate the function \x -> f1 $ f2 $ f3 $ f4 $ f5 $ f6 x
03:27:25 <frerich> ttt_fff_: It's 'foldr (.) id'
03:29:33 <ttt_fff_> frerich++
03:30:35 <jle`> btw, the answer comes pretty clearly if you see that it's (f1 . f2 . f3 . f4 . f5 . f6) :)
03:31:09 <jle`> another advantage of (f . g . h) x over f $ g $ h $ x...which hopefully nobody does in real life heh
03:31:10 <ttt_fff_> why can't I use foldl
03:31:32 <Intolerable> i wish Endo was the default function monoid instance
03:31:50 <jle`> you can use foldl, but it's a little less elegant
03:31:52 <Intolerable> :t appEndo . mconcat . map Endo
03:31:53 <lambdabot> [a -> a] -> a -> a
03:32:04 <mniip> jle`, *look of disapproval*
03:32:06 <jle`> foldr is nice because you're basically replacing every (:) with (.) and the [] with id
03:32:41 <jle`> (f:g:h:[]) beciomes (f . g . h . id)
03:33:04 <jle`> that's foldr's deal
03:33:36 <jle`> with foldl you have to think in terms of accumulators, updating accumulators, etc.
03:34:04 <jle`> that's foldl's deal :)
03:34:16 <jle`> mniip: :P
03:35:56 <frerich> ttt_fff_: There are some cases where foldl is convenient, e.g. if you want to convert a digits like '[3,4,5,2]' into the number '3452'. In this case though, foldr is nice because it matches how (.) works. So which of the two functions to use also depends on how the function passed to the fold works.
03:39:26 <neqis> @pl \f xs -> foldr ((:) . f) [] xs
03:39:26 <lambdabot> flip foldr [] . ((:) .)
03:47:15 <Sindriava> One thing I really miss in haskell are length-typed lists from Rust
03:47:28 <Sindriava> Is there an equivalent?
03:47:53 <Intolerable> Vec?
03:48:09 <frerich> Sindriava: Do you mean something other than 'Vec'? Because 'Vec' only has the element type in its type, no?
03:48:40 <Sindriava> In rust, you have a syntax like "[i32]" or "[i32; 5]"
03:48:45 <jle`> there's V from the linear package
03:48:50 <jle`> but it's not too tricky to roll your own
03:49:06 <Sindriava> Oh yeah, forgot about V
03:49:10 <Sindriava> What does Vec do?
03:49:10 <frerich> Sindriava: Yes but that simply creates a vector if integers, no? The resulting vector does not have the size (e.g. '2') encoded in its type.
03:49:16 <frerich> Sindriava: You can still grow it, I think.
03:49:29 <Sindriava> frerich: No, the TYPE is [i32; 5]
03:49:44 <Sindriava> frerich: At least that's what I gather
03:50:03 <Intolerable> aren't those just arrays?
03:50:25 <Sindriava> Intolerable: More or less. But the internal implementation is beside the point
03:50:38 <Sindriava> What I'm talking about is type-checkable length arrays
03:51:01 <Sindriava> Because I REALLY don't want to type (Int, Int, Int, Int, Int) in some cases, [Int; 5] would be much better
03:51:15 <Intolerable> so Vec (https://hackage.haskell.org/package/Vec)
03:51:46 * frerich was talking about the Rust 'Vec', not the Haskell 'Vec'. :-)
03:51:54 <frerich> The confusion! :-)
03:52:22 <Intolerable> V, Vec, Vector
03:52:27 <Intolerable> spot the differences
03:52:37 <Intolerable> i bet there's a Vect somewhere
03:52:42 <Sindriava> frerich: Ah! Nope, Rust Vecs are Vec<…>. [i32] are slices I think, basically arrays
03:52:59 <frerich> Sindriava: Right, so we're on the same page. :-)
03:53:36 <Sindriava> I guess vector make much more sense from a mathematical point of view than lists
04:04:51 <haskell393> hello i need help with System.FilePath.Find package, this one does not work as i expected: find always (filePath ~~? "./d*/*.xml") "."
04:04:56 <haskell393> Can i list paths that match pattern this way?
04:10:29 <naudiz> "circular programming" – that's it, I'm gonna learn particle physics instead.
04:11:06 <mniip> naudiz, have you read the bidirectional family inference article yet? :D
04:11:25 <naudiz> mniip: do I want to?
04:11:48 <mniip> half an hour ago you did
04:13:17 <naudiz> mniip: I'm confused, which one do you mean?
04:16:16 <ttt_fff_> what would be worse? (1) losing a pinky or (2) never being allowed to program in haskell again
04:16:57 <demize> ttt_fff_: Am I a bad person if I would say 1?
04:17:12 <demize> I'm rather bad with pain, so..
04:17:24 <ttt_fff_> demize: I dunno, I can't imagine doing CS without haskell, but I think I can do CS with 9 fingers
04:17:32 <ttt_fff_> oh
04:17:33 <chpatrick> I don't think ocaml would kill me :P
04:17:35 <ttt_fff_> (1) i sworse?
04:18:40 <maerwald> haskell has not reached nirvana, so I can imagine doing CS without it
04:20:14 <naudiz> dvorak doesn't really work with 9 Fingers
04:21:05 <mniip> naudiz, nevermimd
04:21:43 <dramforever> excuse me, but doesn't nirvana mean heaven?
04:21:44 * naudiz np: Nirvana - Rape Me
04:22:01 <maerwald> dramforever: no
04:22:27 <naudiz> dramforever: no, it means being a Buddha by breaking out of the Samsara 
04:22:32 <dramforever> okay
04:22:39 <naudiz> (at least in buddhism)
04:23:47 <naudiz> Hindu has a similar definition but the concept of Samsara is different. But I'm not sure about it.
04:24:03 <maerwald> naudiz: I don't think you need to be a buddha in order to reach bodhi, but I guess this is OT
04:24:30 <maerwald> being a buddha is just one (excellent) way to reach bodhi
04:24:45 <maerwald> but nirvana was referring to how SPJ uses it
04:26:37 <naudiz> maerwald: it is OT ;) but you're right. Although it depends on what kind of Buddhism you look at. often it's just a metaphorical concept that's free for interpretation. so it doesn't really matter that much.
04:28:49 <naudiz> of course teachers might tell people how they interpret it, but that's their job as a teacher. And it's the job of the student to draw their own conclusions.
04:31:33 * hvr would just have to invent a new Haskell dialect rather than lose any fingers
04:32:46 <jstolarek> say I have:
04:32:51 <jstolarek> foo :: Char
04:32:54 <jstolarek> foo = 'a'
04:33:07 <jstolarek> How do I pattern match on result foo using view patterns?
04:33:44 <hvr> you want the equivalent of 'bar ... |  foo == 'a' = ...'?
04:33:48 <dramforever> f (viewFunction -> resultValue) = blah
04:35:01 <hvr> or rather 'bar ... | 'a' <- foo' = ...'?
04:37:13 <jstolarek> hvr: yes
04:37:23 <jstolarek> yes to first that is
04:37:27 <jstolarek> I want equivalent of a guard
04:37:41 <hvr> jstolarek: problem is, ViewPatterns operate on function arguments
04:37:45 * hackagebot delta 0.2.1.0 - A library for detecting file changes  https://hackage.haskell.org/package/delta-0.2.1.0 (muzzle)
04:37:47 <jstolarek> not that using a guard is a big problem but I was curious if that can be done with [patterns
04:37:59 <hvr> jstolarek: or something that is a pattern
04:38:04 <jstolarek> well
04:38:16 <jstolarek> bar ch | ch == foo = ...
04:38:22 <hvr> ah
04:38:26 <jstolarek> where foo is a function that returns a Char
04:38:31 <hvr> in that case
04:38:57 <hvr> bar ((== bar) -> True) = ... 
04:38:57 <hvr> =)
04:39:04 <hvr> bar ((== far) -> True) = ... 
04:39:09 <hvr> damn... can't type today
04:40:18 <hvr> (but that'll require an Eq instance, so it's more than merely pattern-matching on foo)
04:40:30 <jstolarek> right
04:40:40 <jstolarek> TBH seems much more obscure than a guard
04:41:10 <hvr> well, that's because this is not a good application of Viewpatterns :)
04:42:32 <jstolarek> noted
04:55:27 <lpaste_> freinn pasted “slow laziness” at http://lpaste.net/137029
04:56:09 <freinn> hi, I've pasted that code cause I don't know how to do better this generator
04:56:21 <freinn> and make a quicker version of the minMaxSlow function
04:56:33 <freinn> those exercises are from http://www.seas.upenn.edu/~cis194/hw/06-laziness.pdf
04:59:17 <dramforever> freinn: hello?
04:59:22 <dramforever> are you still therE?
04:59:24 <dramforever> *there?
04:59:27 <freinn> yes I am
05:00:07 <dramforever> so the problem with the minMaxSlow is that it traverses the list twice
05:00:30 <dramforever> so before the first traversal the runtime cannot garbage collect the list
05:00:35 <dramforever> so you waste memory
05:00:44 <dramforever> but it's slow? then I don't know why
05:00:57 <freinn> really is not so slow
05:01:00 <dramforever> maybe allocation is slow
05:01:09 <freinn> the authors said it is
05:01:36 <freinn> I don't know how to make it with lazyness to not use too much memory
05:01:46 <immibis> given http://lpaste.net/137031 : will maketree run in linear time, and can count be made to run in linear time (of the number of distinct nodes in the tree, accounting for sharing)?
05:01:50 <dramforever> freinn: calculate the min and max together
05:01:54 <freinn> dramforever did you see my generator?
05:01:55 <dramforever> one traversal
05:02:01 <kuribas> jstolarek: I think you can use pattern guards: bar | 'a' <- foo = "bar"
05:02:12 <ed|win> dear Haskell, you've ruined my life. I'm here at work trying to diagnose test failures, but these tracebacks are enigmatic. After we met, I got spoiled by precise error messages that, despite some times looking like Greek, clearly pointed out silly type mismatches that I made, which were often a result of some simple typo or failed logic. Now, I have to dig through 3 or 4 dependencies in my Python code just
05:02:13 <ed|win> to determine whether there is an error in my code, someone elses's on the team, or some third-party library code. It's difficult to work now, because all I think about you, Haskell. Thank you for ruining my life as a Python software developer, Haskell. 
05:02:15 <dramforever> freinn: I'm not good at that...
05:02:41 <kuribas> > let foo = 'a'; bar | 'a' <- foo = "bar" | otherwise = "baz"; in bar
05:02:43 <lambdabot>  "bar"
05:02:51 <immibis> ed
05:02:58 <immibis> ed|win: sounds like you like static typing :P
05:03:03 <lpaste_> freinn pasted “try” at http://lpaste.net/137032
05:03:24 <freinn> dramforever: I did this function
05:03:31 <immibis> (i think there's static typing for python? but good luck having all your teammates use it)
05:03:39 <dramforever> @letlpaste 137032
05:03:40 <lambdabot>  Defined.
05:03:48 <ed|win> immibis: Specifically, there's static typing for python 3 a la mypy
05:03:53 <dramforever> > maxmin [1,7,4,9,5,3,2]
05:03:54 <ed|win> we're stuck on python 2
05:03:55 <lambdabot>  Just (9,1)
05:04:34 <frerich> immibis: I might misunderstand, but doesn't 'count' already run in linear time with respect to the number of nodes in the tree? It visits each element exactly once as far as I can see.
05:04:37 <ed|win> Yes. Static typing is a huge thing for me. I think laziness and currying are the other two big wins for me though
05:04:40 <dramforever> @check \x -> case x of [] -> True; _ -> Just (maximum x, minimum x) == maxmin x
05:04:42 <lambdabot>  +++ OK, passed 100 tests.
05:05:19 <dramforever> frerich: don't worry it's just some fairly advanced code that basically says, together with the message, your code is correct!
05:05:22 <dramforever> nice try!
05:05:47 <frerich> dramforever: Err - what? :-)
05:05:54 <zomg> immibis: are you the mc immibis? :P
05:05:54 <immibis> frerich: look at the structure of the tree 'maketree' builds - there are 63 nodes in the tree semantically, but only 6 distinct ones, and performance-wise i want to only visit those once
05:05:59 <frerich> dramforever: Oh, I guess you meant 'freinn'
05:05:59 <immibis> zomg: yes -.-
05:06:03 <zomg> heh
05:06:06 <zomg> yeah was just curious :)
05:06:11 <dramforever> freinn: your code is correct, but can be greatly improved
05:06:17 <dramforever> frerich: oh sorry =P
05:06:55 <kuribas> immibis: you want to visit equal branches only once?
05:07:03 <immibis> frerich: er, 2^31-1 nodes, and 31 distinct ones. (forgot i changed that before pasting)
05:07:26 <kuribas> immibis: You cannot, because you don't know if they are equal, without comparing then, or using another datatype.
05:07:32 <frerich> immibis: As it is, 'count' cannot make any assumptions about the structure of the tree based on what the 'Tree' type gives. So I see no way to tell how many distinct nodes there are without looking at all of them.
05:07:42 <immibis> kuribas: to my understanding ghc internally stores two references to a single object
05:07:50 <immibis> (remembering that i'm talking about performance here, not semantics)
05:08:00 <immibis> (and so implementation details are relevant)
05:08:22 <kuribas> immibis: no, each leaf has it's own storage.
05:09:02 <immibis> kuribas: if that was the case then the program should use several gigabytes of memory; it does not
05:09:12 <dramforever> immibis: I guess you are not supposed to able to tell the same trees apart
05:09:39 <dramforever> well hmm that sentence was bad...
05:10:04 <frerich> immibis: The fact that 'a' and 'b' are the same object is not visible in 'count' anymore. I.e. the explicit sharing introduced by the 'let child = ...' cannot be relied on anywhere else. Now it may be that with some aggressive inlining the compiler can see it in this particular program, I guess.
05:10:13 <dramforever> you are not supposed to tell if two trees are the same
05:10:15 <kuribas> immibis: oh I see, but still you have no way of checking if they share storage.
05:10:17 <frerich> immibis: You could check it by printing debug output in 'count' to see how many nodes it visits.
05:10:48 <immibis> dramforever: i'm not asking to tell if two trees are the same. i want the performance to be as if they were the same, and if the value of 'count n' was only computed once for each node 'n'
05:10:59 <immibis> the output of the program should be 2^31-1 either way
05:11:29 <dramforever> immibis: so what are you doing this for, btw?
05:11:33 <kuribas> immibis: you cannot.
05:11:52 <immibis> frerich: i did, `count` executes 2^31-1 times
05:12:26 <immibis> (i assume; it definitely executes a lot more than 31)
05:13:01 <immibis> dramforever: evaluating an expression with lots of shared subexpressions
05:13:16 <immibis> this is a minimal example
05:13:27 <kuribas> :t unsafePerformIO
05:13:28 <lambdabot> Not in scope: ‘unsafePerformIO’
05:13:43 <frerich> immibis: The only way to be sure that the expression is shared is to assign a common name, as you did in 'maketree'. Whether or not this sharing is still visible in other functions probably depends on compiler optimizations which you don't want to rely on too much.
05:14:10 <dramforever> immibis: an interpreter?
05:14:26 <immibis> dramforever: more or less
05:14:57 <dramforever> immibis: so I guess you could assign each expression an unique id
05:15:09 <immibis> if someone does "a = 1; b = a + a; c = b + b; d = c + c; e = d + d; f = e + e; ... z = y + y; print(z)" then it would be nice to be able to evaluate z straightforwardly and efficiently
05:15:19 <immibis> (without keeping a map of variables->values)
05:16:07 <kuribas> immibis: that's how it's normally done in haskell.
05:16:39 <kuribas> immibis: otherwise you could use STrefs
05:16:48 <dramforever> immibis: elaborate on "straightforwardly"
05:17:12 <immibis> dramforever: build a tree in a similar way to maketree, evaluate it in a similar way to count
05:17:30 <kuribas> immibis: STRefs could be faster, but more messy.
05:17:43 <immibis> i was expecting that there would be some way to evaluate the shared sub-expressions once
05:17:48 <immibis> since it's basically just memoizing a function...
05:17:51 <nshepperd> i think you really need let bindings if you want to do that
05:18:46 <dramforever> immibis: I'm not really sure how far you could get that way...
05:18:49 <frerich> immibis: In that example, each subexpression is indeed evaluated just once, e.g. in 'b = a + a', 'a' is computed just once.
05:19:14 <immibis> frerich: when building the tree, yes. when evaluating it to find the value of of 'z' (2^26), no
05:19:22 <frerich> immibis: It's a whole different story for function application though, e.g. in '(f x) + (f x)', 'f x' is possibly (likely?) evaluated twice.
05:19:24 <nshepperd> or, to construct the result at the same time as the tree
05:19:39 <mniip> [15:17] (immibis) i was expecting that there would be some way to evaluate the shared sub-expressions once
05:19:39 <mniip> array memorization
05:19:56 <dramforever> mniip: that would be "variable names", so no
05:20:08 <frerich> immibis: That's because in 'count' you apply a function. Even if you did 'count a + count a', you might not necessarily have 'count a' be evaluated just once.
05:20:10 <nshepperd> data Expr a = Add a (Expr a) (Expr a) | ...
05:20:20 <nshepperd> but that's basically so limited it's useless
05:20:33 <dramforever> immibis: btw we have a somewhat nice way to manage variable names. do you want to try it out?
05:20:35 <dramforever> @hackage bound
05:20:35 <lambdabot> http://hackage.haskell.org/package/bound
05:20:48 <immibis> frerich: right. that's also true for count a + count b, where a == b can be trivially determined at runtime
05:21:40 <frerich> immibis: For 'count a + count a' you could even trivially determine it at compile time, yet 'count' is possibly applied twice.
05:22:24 <immibis> but i'm surprised there's no way to *force* the system to apply 'count' once (within some larger expression)
05:22:46 <frerich> immibis: The way to enforce it is to use a common name, e.g. 'let x = count a in x + x'.
05:23:08 <immibis> that requires the structure of the tree to be known at compile time. which it is in the code i pasted, but not in general
05:23:39 <dramforever> immibis: why are you avoiding dealing with variable names?
05:24:07 <kuribas> immibis: are you writing an interpreter?
05:24:11 <immibis> dramforever: i will want to perform transformations on the code that can see through variables
05:24:31 <frerich> immibis: That's right. AFAIK Haskell - the language - only actually requires non-strict evaluation. I.e.  it doesn't even require that when you do 'f x x', 'x' is computed just once. It only requires that 'x' is not computed before 'f' gets called.
05:24:37 <immibis> kuribas: pretend i am
05:24:50 <dramforever> immibis: huh?
05:24:55 <kuribas> immibis: then I would use a map from variable name to value.
05:25:18 <dramforever> immibis: what do you mean by that?
05:25:38 <immibis> dramforever: say i want to replace "a+a" with "a*2". then "b = a; print(a + b)" should be replaced by "print(a*2)"
05:26:03 <immibis> that is trivial if "b = a; print(a + b)" produces the same tree structure as "print(a + a)" to start with
05:26:32 <dramforever> that looks pretty hard
05:26:54 <dramforever> I doubt if it's even decidable
05:27:04 <sweater> Hey, people. A quick sanity check and a quick question. 1. I have a big structure parsed by Parsec, to get aggregate infromation about it I expose several functions that transform this data lazily in a way that the data structure doesn't appear in those functions more than once. Am I right when I think that even though the structure is big, it (1.1) will still be garbage-collected as the parsing happens;
05:27:06 <sweater> (1.2) If we "take" parts of the aggregated data, it's also lazily evaluated; (1.3) I can use bang to force strictness.
05:27:20 <ggole> It's conceivable that a compiler could emit such tests, but telling when they are profitable seems like it would be difficult.
05:27:42 <immibis> ggole: which is why i was looking for a way to make ghc do that...
05:28:13 <kuribas> immibis: you should give a larger picture of the problem you want to solve.
05:28:53 <sweater> And the question 2. Is there a way to dump the heap to disk in such a way that infinite structures can be loaded back afterwards in the same state of thunks or something. 
05:29:08 <dramforever> sweater: (1.1) no sorry, because the structure can't be given to you until the whole parse succeed
05:29:12 <dramforever> *succeeds
05:29:16 <dramforever> *parsing
05:30:00 <dramforever> if you want to, you can parse the data chunk by chunk
05:30:19 <dramforever> although I'm not really sure how to do it
05:33:33 <quchen2> frerich: You can be non-strict by evaluating "x" in "f x" regardless of context. The compiler can simply start evaluating "x" and "f" in parallel, for example, and when "f" is done and "x" is not needed the computation can be thrown away.
05:34:21 <mniip> isn't that what stranal does
05:34:37 <Fuuzetsu> @hoogle Monad m => m (a1 -> m a) -> m a1 -> m a
05:34:38 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:34:38 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:34:38 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:34:40 <mniip> figure out what should be evaluated before it is actually demanded
05:35:18 <dramforever> Fuuzetsu: so what do you want?
05:35:24 <dramforever> :t (<*>) -- something like this?
05:35:25 <Fuuzetsu> join . ap f
05:35:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:35:32 <Zemyla_> How can I verify that a use of unsafeInterleaveST is safe and doesn't violate referential integrity?
05:35:44 <dramforever> :t ap
05:35:45 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:35:46 <Fuuzetsu> but join . ap f looks very wrong to me
05:35:54 <dramforever> Fuuzetsu: ap looks enough
05:35:55 <mniip> Fuuzetsu, you can turn 'm (a1 -> m a)' into 'a1 -> m a' with ap and join
05:35:56 <quchen2> mniip: That's impossible in general. "let f = if p then const 1 else (*2)" needs its argument based on an undecidable question (namely whether forcing p halts).
05:36:06 <Fuuzetsu> mniip: yes, that's what I have already
05:36:17 <mniip> quchen2, in general, indeed
05:36:18 <dramforever> :t ap
05:36:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:36:24 <dramforever> Fuuzetsu: this?
05:36:26 <mniip> but strictness analysis is an optimization
05:36:30 <dramforever> :t (<*>)
05:36:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:36:56 <Fuuzetsu> dramforever: no, I have m (a -> m b) not m (a -> b)
05:37:14 <dramforever> :t join . ap
05:37:15 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a1)
05:37:16 <lambdabot>     Expected type: m (a1 -> a) -> m a1 -> m a1 -> a
05:37:16 <lambdabot>       Actual type: m (a1 -> a) -> m a1 -> m a
05:37:21 <dramforever> =(
05:39:03 <sweater> dramforever: thanks! 
05:39:23 <sweater> Do we have any insights on dumping thunks on disk and restoring those?
05:39:31 <dramforever> no =(
05:39:49 <sweater> acid-state works with update monad, so it's not using any low-level hacks 
05:41:01 <kuribas> sweater: how would that work?  How would unevaluated thunks be represented?
05:49:58 <Denommus> anyone here works with groundhog?
06:03:28 <sweater> kuribas: that's a good question, I don't really know. But I'm stupid, maybe smart people figured it out. It's obviously possible on the OS-level (notice that I'm considering a memory dump along with code). To be honest, I have zero ideas about implementation details, just the general concept. Basically, I was fantasizing about per-lazy-data-structure memory dumps.
06:04:54 <frerich> kuribas: I think unevaluated thunks could be represented as Haskell programs. ;-)
06:06:03 <kuribas> So it could only be used from the program that wrote it...
06:10:03 <sweater> kuribas: which is good enough for memory-dumps.
06:10:46 <nshepperd> you can't just serialize a thunk. but you can use cloud haskell style tricks to serialize a few other things, like closures
06:11:04 <nshepperd> assuming the file will be read back in by a copy of the same program
06:13:18 <badmash> hi folks
06:13:25 <badmash> got a quick question
06:13:58 <badmash> in ghci (i am using 7.8.4 version) the :set +m doesn't seem to work
06:15:17 <badmash> for example, if i type let x = 42, hit return, and then type y = 3, and hit return, i get "parse error on input '='"
06:15:59 <badmash> any idea why this is giving this error?
06:16:20 <aweinstock> nshepperd: why can't you serialize a thunk (in a non-portable way)? just by storing a (codepointer, datapointer) pair?
06:17:06 <aweinstock> badmash: indentation on the second line? (be sure to indent y to the same amount as x)
06:17:12 <Denommus> hm
06:17:14 <miscyb_> does anyone know how to print out values from hxt for debugging purposes?
06:17:21 <badmash> the other option -- using :{ :} seems to work perfectly
06:17:45 <Denommus> selectAll in groundhog is producing the query SELECT FROM ..., which is obviously wrong
06:18:00 <badmash> aweinstock: yes, i have indented y to the same amount as x
06:18:26 <miscyb_> for instance I'm trying to use getNamespaceDecl, but I'm not sure how I would print out the strings it returns short of creating a new xml document and writing that out when I'm done
06:18:30 <miscyb_> and that just seems inefficient
06:18:36 <badmash> i still get the same error
06:19:39 <badmash> i am pasting the whole thing here
06:19:41 <badmash> ghci: ---->  let x = 42
06:19:42 <badmash> Prelude|         y = 3
06:19:42 <badmash> Prelude| 
06:19:42 <badmash> <interactive>:8:11: parse error on input ‘=’
06:19:42 <badmash> ghci: ---->  
06:20:17 <alex-v> Why there is no instance Generic Word?
06:20:18 <badmash> any idea why it is giving this error?
06:21:23 <badmash> i am on mac os x
06:21:47 <ChristianS> badmash: don't paste here, please
06:22:16 <badmash> ok, sorry, someone asked about indentation, so i did.  apologize
06:22:25 <ChristianS> badmash: if you enter each line separately into ghci, you'll need a new let for each line
06:22:58 <badmash> ChristianS: really?  i have done :set +m
06:23:45 <badmash> ChristianS: in multiline mode, shouldn't it work with just 1 let?
06:24:02 <nshepperd> aweinstock: well, I suppose you can
06:24:06 <geekosaur> ChristianS, the prompting there does indicate multiline mode
06:24:08 <nshepperd> in a very nonportable way
06:24:12 <ChristianS> badmash: it does, and it works for me if i enter the y exactly under the x
06:24:46 <mniip> what is the nowadays popular way to start learning haskell
06:24:50 <badmash> 18:53 *** _fritz_ JOIN
06:25:17 <badmash> i see, but doesn't seem to work on my machine -- i am using mac os x termina;
06:25:21 <badmash> terminal
06:25:22 <mniip> assuming above average imperative programming knowledge
06:25:41 <nshepperd> I don't know, I would expect any old thunk to have some crazy dependencies on the current rts state
06:26:12 <nshepperd> actually, because you can still get that code pointer from anywhere
06:26:42 <nshepperd> it could be from some code loaded by the dynamic linker
06:27:28 <nshepperd> aweinstock: anyway, the static pointers idea which cloud haskell uses sort of does this, but in a principled way
06:27:31 <badmash> appreciate if anyone has any inputs on this
06:28:13 <nshepperd> but you have to know more about the computation to do this than any old thunk
06:30:26 <badmash> i am just guessing -- is this some weird haskeline behavior in os x terminal?
06:31:02 <geekosaur> there are some known weird behaviors but that's not one. I do wonder if you're lining up visually instead of counting spaces, and the prompts have different sizes...
06:32:15 <keep_learning> Hello everyone. 
06:32:21 <badmash> geekosaur: ok, let me try again and see
06:32:52 * hackagebot fwgl-javascript 0.1.0.4 - FWGL GHCJS backend  https://hackage.haskell.org/package/fwgl-javascript-0.1.0.4 (ZioCrocifisso)
06:33:09 <keep_learning> I have installed emacs-prelude https://github.com/bbatsov/prelude
06:33:29 <geekosaur> (people are telling you to make sure the y lines up under the x but your main prompt is much longer than the non-settable continuation prompt)
06:33:44 <geekosaur> (so lining them up visually would actually lead to an error)
06:33:48 <keep_learning> when I was opening a file and try to load it, it was asking me to create project and other sort of stuffs. 
06:34:03 <keep_learning> so I delete the haskell-mode from elpa directory 
06:34:05 <badmash> geekosaur: thanks a ton.  you are absolutely right!
06:34:42 <badmash> geekosaur: i was actually lining up visually instead of counting spaces!!
06:34:47 <keep_learning> and followed the given instruction on https://github.com/haskell/haskell-mode
06:34:53 <Denommus> can groundhog work with sum types?
06:35:57 <keep_learning> Now when I opening a file and running C-c C-l, It's asking haskell-mode-enable-process-minor-mode: Run `C-h f haskell-mode` for instruction how to setup a Haskell interaction mode.
06:37:22 <keep_learning> Any idea on how to configure or resolve this issue 
06:37:57 <ysz> gday
06:38:09 <badmash> thanks folks for the help
06:41:53 <ysz> been a while since i last wrote low level Haskell. in case I'm calling Haskell dynamic library from C can i interleave calls to blocking foreign calls with rest of haskell computation without risk of haskell threads being blocked waiting for that foreign call to complete?
06:42:24 <ysz> what if the application which calls that Haskell library itself has many OS threads running?
06:42:32 <ysz> am i gucci still? :)
07:03:49 <badmash> hello folks
07:03:54 <badmash> quick question
07:04:23 <badmash> filter :: (a -> Bool) -> [a] -> [a]
07:05:46 <badmash> how can you get the type signature of the partial function filter :: (a -> Bool) in ghci?
07:06:58 <OutlawStar> you mean like "\a -> a == 3" ?
07:07:04 <badmash> i am new to haskell, so this might be a silly question.  please correct me if i am off the wall here
07:07:07 <ronh> :t flip filter [1,2,3]
07:07:14 <lambdabot> Num a => (a -> Bool) -> [a]
07:07:36 <ronh> you can use types holes as well if your ghci version is high enough
07:07:45 <ronh> > filter _ [1,2,3]
07:07:47 <lambdabot>      Found hole ‘_’ with type: a -> Bool
07:07:47 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
07:07:47 <lambdabot>                 the inferred type of it :: [a] at Top level
07:08:44 <badmash> shouldn't filter (a -> Bool) have a type signature?
07:09:01 <chpatrick> that doesn't make sense
07:09:08 <chpatrick> filter is a function and (a -> Bool) is a type
07:09:43 <chpatrick> you can do this though:
07:09:43 <chpatrick> Prelude> :t filter :: (Int -> Bool) -> _
07:09:43 <chpatrick> <interactive>:1:28: Warning:
07:09:43 <chpatrick>     Found hole ‘_’ with type: [Int] -> [Int]
07:09:43 <chpatrick>     In an expression type signature: (Int -> Bool) -> _
07:09:43 <chpatrick>     In the expression: filter :: (Int -> Bool) -> _
07:09:44 <chpatrick> filter :: (Int -> Bool) -> _ :: (Int -> Bool) -> [Int] -> [Int]
07:10:52 <badmash> filter is a function with an argument (a -> Bool) -- isn't that true?
07:11:49 <chpatrick> badmash: yes, but writing filter (a -> Bool) doesn't make sense
07:12:02 <chpatrick> you can't pass a type as an argument to a function
07:12:15 <chpatrick> you could pass a value of that type
07:12:18 <chpatrick> but not just the type
07:12:28 <badmash> chpatrick: i see
07:12:29 <chpatrick> :t filter (undefined :: a -> Bool)
07:12:31 <lambdabot> [a] -> [a]
07:13:25 <badmash> chpatrick: so if passed an actual function instead of (a -> Bool), i should get the type, correct?
07:13:30 <tommd> if I have `data F = F Word8 Word8` and `data G = G Word8 Word8` is it safe to `fToG :: F -> G ; fToG = unsafeCoerce` ?
07:13:32 <chpatrick> yes
07:13:50 <chpatrick> tommd: you should use Data.Coerce
07:13:51 <tommd> Or are newtypes/unboxed types the only great use of `unsafeCoerce`
07:14:04 <chpatrick> that actually checks that the representations are the samew
07:14:19 <chpatrick> unsafeCoerce would work in this situation too but nothing would check
07:14:36 <badmash> chpatrick: you are absolutely correct.  thanks a bunch for the help
07:14:41 <chpatrick> tommd: err actually I may be wrong
07:14:56 <chpatrick> not sure identical datas are Coercible
07:15:03 <Intolerable> they aren't
07:15:15 <chpatrick> ok never mind then
07:15:15 <tommd> Ah, as I feared.
07:15:21 <tommd> Different info tables or some such?
07:15:29 <chpatrick> I think unsafeCoerce would work
07:16:00 <chpatrick> I mean at runtime it's just constructor index and two Word8s I think
07:16:01 <tommd> I'll try and find segfaults or glory.
07:16:07 <Intolerable> unsafeCoerce will work
07:16:22 <tommd> OK
07:16:38 <Intolerable> coerce will die because they are different types at runtime
07:17:21 <Intolerable> whereas newtypes are identical after they're typechecked
07:17:35 <Intolerable> thus coercible
07:17:42 <tommd> Yes, that makes sense.  Thanks.
07:37:18 <eacameron> In "exceptions" the MonadThrow instance for ExceptT says "Throws exceptions into the base monad"
07:37:19 <xandaros> Hmm... what is the Point of the u in "ParsecT s u m a" (User state) - can't you just transform some MonadState to achieve this?
07:37:20 <eacameron> What does that mean?
07:37:49 <geekosaur> xandaros, imagine modifying the state inside a try
07:38:13 <geekosaur> Parsec can roll back the state correctly
07:38:28 <xandaros> ah, that makes sense, thanks :D
07:40:50 <lamefun> How to properly convert an Integer to Text?
07:40:56 <eacameron> Does anyone know what it means that "throwM" for ExceptT "throws exceptions into the base monad"?
07:41:14 <lamefun> I can of course "T.pack (show int)", but is there a better way?
07:41:34 <lyxia> eacameron: it means that throwM doesn't use ExceptT to throw an error.
07:41:52 <eacameron> lyxia: strange....
07:42:12 <eacameron> lyxia: why would it bother to have an instance for ExceptT but not use it?
07:44:22 <Denommus`> gosh
07:45:28 <lyxia> eacameron: When defining an instance of MonadThrow for ExceptT, there are two ways to do it. The one that is implemented here is to use the MonadThrow m constraint, another one is to use throwE from Except.
07:49:18 <lyxia> eacameron: ExceptT and CatchT have different notions of "exception": ExceptT can use any type as its exception, but that type has to appear as its argument, and you can't easily mix an ExceptT e m with an ExceptT e' m.
07:50:58 <lyxia> eacameron: Whereas CatchT allows to throw different types of exceptions in the same computation, as long as they are instances of 'Exception'
07:52:38 <eacameron> lyxia: hmm...that's a good point
07:56:00 <_d0t> ohai. Where can I find a manual on Persistent embedded DSL?
07:56:19 <lyxia> Actually to be able to implement MonadThrow for ExceptT e you need additional constraints on e. That's basically what CatchT does, with e = SomeException.
08:05:51 <Pamelloes> I have a function :: Value -> Parser Text and a value Parser (Maybe Value) is there some combination of operators to create a Parser (Maybe Text)? I've been messing around with combinations of <$>, mapM, and =<<. but I can't quite get it right.
08:06:33 <geekosaur> fmap . fmap ?
08:07:08 <Pamelloes> That's what I thought at first, but the function is a -> f b so that doesn't work.
08:07:12 <lpaste_> guibou pasted “Mandelbrot set” at http://lpaste.net/137043
08:07:53 <geekosaur> oh right. hm
08:07:58 <minopret> Hi, I found an anamorphism hiding in the Python code annotated @CachedFunction at http://oeis.org/A000041 and I'd like to work out how to write it in Haskell. It's the while loop there if we restrict it to the variables J and k.
08:08:03 <Pamelloes> And then the issue with fmap . =<< is close but doesn't quite match up (it flips Maybe and Parser)
08:08:14 <lpaste_> guibou pasted “Mandelbrot set” at http://lpaste.net/137044
08:08:16 <Pamelloes> Gah, I can't English. :/
08:09:14 <guillaum1> http://lpaste.net/137044 Hi. Anyone can have a look on my naive code and tell me what I'm doing wrong (mandelbrot set displayed in terminal). Especially in the main function.
08:09:23 <minopret> so I coded a function next_m of Int parameters m and i
08:09:28 <Pamelloes> It looks like there isn't a simple solution...
08:09:29 <lyxia> :t (=<<) . mapM
08:09:30 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
08:09:36 <Pamelloes> Oh
08:09:37 <Pamelloes> :D
08:10:18 <lyxia> :)
08:11:05 <Intolerable> :t (=<<) . traverse
08:11:06 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
08:11:34 <Intolerable> "surely you can drop that to an applicative constraint"
08:11:34 <Intolerable> derp
08:12:40 <minopret> Is it usual to code a function "ana" as in http://en.wikipedia.org/wiki/Anamorphism#Example ? Would you instead use something in the Prelude or Control.Monads or something?
08:13:26 <Intolerable> unfoldr?
08:13:32 <Intolerable> :t unfolder
08:13:33 <lambdabot>     Not in scope: ‘unfolder’
08:13:33 <lambdabot>     Perhaps you meant one of these:
08:13:33 <lambdabot>       ‘unfolded’ (imported from Control.Lens),
08:13:36 <Intolerable> :t unfoldr
08:13:37 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
08:13:49 <minopret> oh cool, unfoldr makes sense. Thanks.
08:13:58 <Pamelloes> Hm..... maybe a 100MB query isn't the best idea....
08:31:39 <Fuuzetsu> is there a stack IRC channel?
08:32:46 <kadoban> Fuuzetsu: #haskell-stack , though it's fairly small
08:43:36 <danilo2> Hello! :) I've got a lens :: Lens' A B and two functions  foo :: B -> C and bar :: C -> B , how can I construct Lens' A C with them ?
08:46:11 <Intolerable> :t iso
08:46:13 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
08:46:22 <navaati> hi
08:46:29 <Intolerable> :t \foo bar lens -> lens . iso foo bar
08:46:30 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> (p s (f t) -> c) -> p a (f b) -> c
08:46:57 <Intolerable> danilo2: try iso
08:47:05 <Intolerable> you might have to swap the foo and bar around
08:47:17 <ReinH> if foo and bar actually form an isomorphism
08:47:28 <navaati> a cabal build on a clean project, the ghc build pass succeeding and the linking pass failing with "undefined symbol" garbage…
08:47:28 <navaati> it's a bug right ?
08:47:45 <danilo2> Intolerable: thank you very much1 :) I'm trying it right now
08:48:03 <Intolerable> navaati: do you have everything in exposed-modules / other-modules properly?
08:48:24 <navaati> Intolerable: probably not, must be that. Thanks ?
08:48:28 <navaati> s/?/!/
08:50:02 <navaati> Intolerable: confirmed :)
08:50:16 <Intolerable> good to hear
08:54:06 <danilo2> Intolerable: thank you very much! It works great :)
08:59:27 * hackagebot interpolatedstring-perl6 1.0.0 - QuasiQuoter for Perl6-style multi-line interpolated strings  https://hackage.haskell.org/package/interpolatedstring-perl6-1.0.0 (AudreyTang)
08:59:27 * hackagebot telegram 0.1.0.0 - Telegram API client  https://hackage.haskell.org/package/telegram-0.1.0.0 (sgillis)
09:04:22 * hackagebot shelly 1.6.3 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.3 (GregWeber)
09:09:02 <Fuuzetsu> What's the purpose of the 9.9.9 version for stack on Hackage?
09:09:15 <Intolerable> accidental iirc
09:10:14 <Intolerable> yeah it was accidentally uploaded
09:10:29 <Intolerable> and u can't remove from hackage yet
09:10:33 <Intolerable> so it stays
09:10:36 <Intolerable> and gets deprecated
09:10:57 <Fuuzetsu> OK, I see
09:10:59 <Intolerable> i say "yet"
09:11:05 <Intolerable> its not planned either iirc
09:11:13 <Intolerable> what goes on hackage stays on hackage
09:17:00 <Fuuzetsu> yeah, package deletions need to really become a thing
09:17:07 <Fuuzetsu> make it on a long timescale but allow it
09:17:44 <Fuuzetsu> some months ago someone kindly gave me maintainership over a package name I want to use in the future for a different purpose and the first few versions of it are going to be some dead database backend or something ;( 
09:17:59 <Wizek> Good Morning!
09:18:25 <Peaker> Which of Control.Monad's combinators are actually Monadic, and not Applicative?
09:18:30 <Peaker> it seems almost none!
09:18:45 <Intolerable> yay for compatibility
09:18:50 <Wizek> Cabal by default eats standard out when running `cabal test`, right? And if so, can I kindly ask it to show me that output?
09:19:07 <Intolerable> do you want to show it every time?
09:19:11 <Intolerable> or just want to see it?
09:19:21 <Wizek> I am interested in both ways
09:19:43 <Intolerable> each test-suite has a log file
09:19:46 <Intolerable> in dist/test/
09:20:25 <Wizek> checking
09:21:02 <Intolerable> if you want to have it as it goes
09:21:34 <Intolerable> try cabal test --show-details=streaming
09:22:10 <Wizek> nice! Thanks Intolerable 
09:22:20 <Intolerable> np
09:22:31 <Wizek> Do you also happen to know if I can ask Cabal not to strip colors from that output?
09:22:58 <Intolerable> probably a bug
09:23:00 <Intolerable> one second
09:23:44 <Intolerable> yeah its a bug, it's targeted for the next version of cabal
09:23:47 <Intolerable> https://github.com/haskell/cabal/issues/1963
09:30:18 <Wizek> Intolerable, Cool, thanks! Intolerable, huh? Quite the opposite I would say. :)
09:36:26 <mpickering> Can you write documentaion of GADT constructors?
09:37:10 <Fuuzetsu> mpickering: no, sorry
09:37:21 <ozkar> Fuuzetsu....
09:37:32 <mpickering> what's the usual work around?
09:37:34 <ozkar> i think you are famous on 4chan dude.
09:37:48 <Fuuzetsu> ozkar: 4chan-famous, how nice
09:37:55 <Fuuzetsu> mpickering: commenting the top level
09:37:57 <ozkar> in a good way.
09:38:39 <Fuuzetsu> mpickering: the problem is that to be able to comment on new parts of the AST, patches need to go into GHC's lexer/parser because that's what does the matching up of what comment belongs where
09:39:31 <Fuuzetsu> if someone wants to hack that (or any other lexer/parser-changing things) then that'd be great, I would have no problem doing the rest of the work in Haddock
09:42:47 <Fuuzetsu> ozkar: I barely post there anymore though if you want to discuss further we can go to haskell-blah
09:43:55 <mpickering> Fuuzetsu: https://phabricator.haskell.org/D1086
09:44:04 <mpickering> that's what's needed yes?
09:46:54 <Fuuzetsu> mpickering: hoho, precisely
09:47:16 <Fuuzetsu> bgamari_: why didn't you tell me you were doing this? ;)
09:54:24 * hackagebot pipes-cereal 0.1.0.0 - Encode and decode binary streams using the pipes and cereal libraries.  https://hackage.haskell.org/package/pipes-cereal-0.1.0.0 (ian_mi)
09:55:30 <benbangert> I found a nice blog post awhile back about how to setup ghc so that you can easily have multiple versions under /opt/ghc, but can't seem to find it anymore... anyone see that article?
09:56:27 <Fuuzetsu> mpickering: seems quite a few nice Haddock-related things on phab recently, my e-mail filters need a good kick because I missed all that stuff!
09:56:31 <Fuuzetsu> benbangert: consider nix…
09:56:58 <Fuuzetsu> but I got away in the past by adjusting a symlink to ‘currently active’ GHC directory
10:02:10 <mpickering> benbangert: There's a utility called ghc-config which fiddles with your path so you can use multiple versions
10:02:32 <mpickering> although you can also just have multiple versions installed and use the -w flag when you use a cabal option
10:02:40 <mpickering> which I never found too troublesome..
10:03:43 <mpickering> Fuuzetsu: On Phab you can make a rule using Herald which subscribes you to tickets which are about a specific thing
10:04:18 <mpickering> ie.. mentions Haddock in the subject.. or changes parser.y 
10:04:37 <Fuuzetsu> mpickering: yeah, my problem is that I have a catch-all phab filter and it all goes into one large directory
10:07:46 <hodapp> shazam, haskell-src-exts is taking its time/memory to build
10:08:19 <Fuuzetsu> yes it does
10:08:44 <Fuuzetsu> haskell-src-exts and lens make me greatful for binary caches every day
10:09:35 <hodapp> hah
10:09:43 <hodapp> I'm doing a fresh build with stack on a DigitalOcean droplet
10:09:44 <mpickering> There's this ticket about it actually https://ghc.haskell.org/trac/ghc/ticket/9557
10:10:11 <Fuuzetsu> pretty sure there's more than one
10:12:17 <nitrix> Is there a semantic difference between (Ledger, IO Bool) and IO (Ledger, IO Bool) ?
10:12:24 <nitrix> Whoops
10:12:36 <nitrix> (Ledger, IO Bool) and IO (Ledger, Bool) ?
10:13:07 <stephenmac7> Is there any type of function that has behavior similar to that of a function with this type definition? (a -> m b) -> [a] -> m [b]
10:13:28 <nitrix> stephenmac7: mapM
10:14:24 <stephenmac7> nitrix: Yup, thanks.
10:19:58 <lyxia> nitrix: You may need to do IO to get a Ledger in the latter.
10:20:58 <nitrix> lyxia: The IO yields True or False, when True the Ledger is possibly mutated, otherwise it isn't.
10:21:33 <nitrix> lyxia: Aka, it writes to disk and tells you if the operation was successful. Some of the succesful ones result in a new ledger.
10:21:52 <nitrix> lyxia: So IO (Ledger, Bool) is more sensible?
10:22:10 <lyxia> Yes
10:22:57 <nitrix> Speaking of mapM, someome wants to explain to me how `mapM show [1,2,3,4,5]` type checks?
10:22:59 <lyxia> returning (Ledger, IO Bool) would mean that you can produce the Ledger without even writing anything.
10:23:24 <lyxia> :t mapM
10:23:25 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
10:23:29 <nitrix> lyxia: I could. If the IO computation fails, I'd return the ledger received as an argument untouched.
10:23:54 <lyxia> t = m = []
10:24:05 <nitrix> lyxia:   btreeInsert :: Ledger -> String -> String -> IO (Ledger, Bool
10:24:11 <lyxia> nitrix: I mean, without even *trying* to write anything.
10:24:26 <nitrix> I hear you. Okay, makes sense then.
10:24:48 <lyxia> so that the value of Ledger can't depend on the success or failure of that action.
10:26:37 <nitrix> Right. I'd be in a monadic context all along. Alright :P
10:26:50 <nitrix> lyxia: Can we check the mapM show [1,2,3,4,5] now?
10:27:22 <kuribas> :t mapM show [1, 2, 3, 4, 5]
10:27:23 <lambdabot> [[Char]]
10:27:57 <kuribas> > mapM show [1, 2, 3, 4, 5]
10:27:58 <lambdabot>  ["12345"]
10:28:15 <kuribas> :t show
10:28:16 <lambdabot> Show a => a -> String
10:28:19 <nitrix> That's the part I want to figure out. show's type isn't monadic.
10:28:37 <kuribas> nitrix: String is [Char], which is monadic.
10:28:41 <nitrix> But I know functions have a Monad instance.
10:28:45 <nitrix> OH
10:28:55 <kuribas> nitrix: but the list monad, not the IO monad.
10:29:06 <nitrix> I completely forgot.
10:29:41 <kuribas> yes, it can be confusing :)
10:29:42 <nitrix> Which is why the strings gets concatenated.
10:29:54 <nitrix> Bingo :)
10:30:02 <lyxia> > mapM show [10, 10, 10]
10:30:03 <lambdabot>  ["111","110","101","100","011","010","001","000"]
10:31:08 <nitrix> Yeah okay, it's like <$>.
10:32:20 * nitrix walks away, bouncing like a bunny.
10:44:18 <jle`> mapM f xs = sequence (f <$> xs)
10:45:26 <Fuuzetsu> :t (sequence .) (. fmap)
10:45:27 <lambdabot> (Monad m, Functor f, Traversable ((->) (a1 -> b))) => ((f a1 -> f b) -> m a) -> m ((a1 -> b) -> a)
10:45:44 <Fuuzetsu> :t (sequence .) . fmap
10:45:45 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
10:47:00 <ronh> @src mapM
10:47:00 <lambdabot> mapM f as = sequence (map f as)
10:47:11 <ronh> still an old source
10:49:17 <Fuuzetsu> those source definitions are not taken from the actual base code, there's just a file with them
10:49:39 <Fuuzetsu> the definitions in base are usually omgoptimised!1!
10:54:47 <the_2nd> how well is haskell suited for webn communication / websites?
10:57:06 <nitrix> Haskell The Markup Language 5
11:01:46 <guillaum1> Is there a way to be more clear about : forM_ listA (\a -> do forM_ listB (\b -> putStr $ show (a * b)); putStrLn "")
11:01:57 <guillaum1> this is rather ugly (I think)
11:04:12 <shachaf> Perhaps: putStr $ unlines [concat [show (a * b) | b <- listB] | a <- listA]
11:06:05 <kuribas> mapM putStr $ liftM2 (*) listA listB
11:06:59 <thimoteus> you know, i just realized something ... ever since taking up haskell, i've stopped commenting my code on what functions do
11:07:16 <guillaum1> kuribas: your solution misses the "putStrLn". Roughly I'm trying to write a grid with the value of a * b
11:07:25 <kuribas> > mapM print $ liftM2 (*) [1, 2] [3, 4, 5]
11:07:26 <lambdabot>  <IO [()]>
11:08:10 <kuribas> guillaum1: What you have isn't bad
11:08:50 <Fuuzetsu> thimoteus: there are projects where commenting is seen as potentially harmful because you should make the code obviously right and descriptive
11:08:58 <guillaum1> kuribas: ok ;)
11:09:07 <Fuuzetsu> don't know if I quite agree personally
11:09:21 <kuribas> guillaum1: use $ and some indentation.
11:09:24 <sm> forM_ listA (\a -> forM_ listB (putStr.show.(a*)) >> putStr "\n")
11:09:27 * hackagebot linklater 3.2.0.0 - The fast and fun way to write Slack.com bots  https://hackage.haskell.org/package/linklater-3.2.0.0 (hao)
11:09:35 <thimoteus> Fuuzetsu: i'm not sure how i go either way, but my comments stopped without me doing it consciously
11:10:01 <Fuuzetsu> you should add a Haddock comment to your functions anyway or you're an awful person ;P
11:10:14 <Fuuzetsu> I meant more of implementation comments in middle of functions &c
11:10:33 <thimoteus> haha
11:10:54 <guillaum1> sm: seriously, are real people writing code like that?
11:11:28 <Fuuzetsu> guillaum1: don't be fooled, real people put spaces around their operators
11:11:34 <sm> guillaum1: well, you are apparently  :)
11:11:44 <the_2nd> how well is haskell suited for webdev?
11:11:50 <the_2nd> compared to go?
11:11:56 <guillaum1> sm: please note that I putted the code in one line because of IRC ;)
11:12:01 <Fuuzetsu> give it a… go and see
11:12:06 <thimoteus> isn't surrounding spaces enforced for (.)?
11:12:14 <thimoteus> or did i read that in my imagination
11:12:28 <Intolerable> only if the lhs is titlecase
11:12:29 <Fuuzetsu> the_2nd: there are multiple frameworks, nothing really stopping you from trying
11:12:36 <Fuuzetsu> thimoteus: no
11:12:42 <Intolerable> X.y is y from module X
11:12:57 <Intolerable> X . y is X (compose) y
11:13:06 <Intolerable> thats the only "enforcing" done
11:14:30 <sm> guillaum1: I'm sure it can be made clearer, in context. I will usually take a small improvement, and often more will appear later
11:14:45 <the_2nd> Fuuzetsu, any comparision in productivity?
11:15:16 <kuribas> guillaum1: forM_ listA $ \a -> putStrLn $ unwords $ map (show.(a*)) listB
11:16:23 <the_2nd> e.g. C being way worse than PHP for webdev
11:16:53 <the_2nd> is haskell generally compareable to go / PHP/ python for webdev?
11:16:59 <catgocat> @pl fun1 = foldr (\x a -> (x - 2) * a) 1 . filter even
11:16:59 <lambdabot> fun1 = foldr ((*) . subtract 2) 1 . filter even
11:18:54 <kuribas> the_2nd: haskell is fine for webdevelopment, but it's not easy to compare, because the language is very different.
11:19:43 <sm> shachaf wins I think
11:19:48 <Fuuzetsu> the_2nd: dunno, if you asked me then any of the 4 languages you mention are worse in productivity (and other things) then Haskell but you're getting an opinion from a bit of a biased channel
11:20:00 <Fuuzetsu> than Haskell*
11:20:56 <catgocat> @pl fun2 n | even n = n + fun2 (n ‘div‘ 2) | otherwise = fun2 (3 * n + 1)
11:20:56 <lambdabot> (line 1, column 18):
11:20:56 <lambdabot> unexpected " "
11:21:11 <shachaf> sm: shachaf usually wins
11:21:20 <catgocat> @pl fun2 n = | even n = n + fun2 (n ‘div‘ 2) | otherwise = fun2 (3 * n + 1)
11:21:20 <lambdabot> (line 1, column 9):
11:21:20 <lambdabot> unexpected " "
11:21:20 <lambdabot> expecting operator
11:21:22 <sm> ha
11:21:53 <shachaf> catgocat: Please use /msg lambdabot to experiment with lambdabot, or ask if you're wondering why something is a syntax error.
11:21:54 <kuribas> the_2nd: if you want to know if haskell has frameworks for creating robust and scaleable webapplications, then the answer is yes.
11:22:32 <shachaf> In this case it's an error because you're using ‘div‘ instead of `div`, but there's no need to print five lines of errors into the channel to figure that out. :-)
11:22:34 <RedNifre> Good day everyone.
11:22:51 <sm> the_2nd: it's a complex question, the answer depends on many factors
11:24:03 <RedNifre> Weird, lambdabot sent me two messages from 9 months ago...
11:24:29 <kadoban> lambdabot has a long memory I'd assume
11:24:44 <Fuuzetsu> high latency though
11:25:04 <sm> poor lambdabot, slow down a bit #haskell :)
11:25:07 <RedNifre> Anyway, I was just wondering about the amgiuity of brackets and tuples, e.g. (f 4 3) is just a value, but (5) is a tuple and then I wondered, are 5 and (5) actually the same thing, i.e. is every single value also a 1-tuple of that value?
11:25:29 <shachaf> There's no such thing as a 1-tuple.
11:25:32 <kadoban> RedNifre: There is no 1-tuple in haskell. (5) isn't a tuple
11:25:42 <kuribas> :t Identity
11:25:43 <lambdabot> a -> Identity a
11:25:51 <RedNifre> But there's 2-tuples and empty tuples. Why are there no 1-tuples then?
11:26:54 <shachaf> I didn't decide it so I can't tell you why.
11:27:16 <kadoban> RedNifre: You can't usually generalize things over tuples in haskell, so it'd be pretty useless.
11:27:24 <sm> because it clashes with the use of parentheses for grouping probably
11:27:27 <RedNifre> Also, I'm not a mathematician, is there actually a distinction in math between 1-tuples and single values? They sort of seem like they are identical, if you think of tuples as arrangements of values instead of containers that have slots for values...
11:27:35 <kadoban> RedNifre: It'd be the same as having just whatever is inside the tuple, and the syntax would be weirdified.
11:27:55 <shachaf> There's as much of a distinction as you care to make.
11:28:13 <shachaf> You can invent what 1-tuple means in maths.
11:28:16 <RedNifre> I mean, are 1-tuples used in math anywhere, or are there a completely worthless concept?
11:28:25 <RedNifre> *they
11:28:37 <shachaf> Usually not.
11:28:42 <shachaf> But you can invent uses for them.
11:29:00 <kuribas> If tuples represent cartesian products of sets, then the zero tuple would represent the empty set?
11:29:02 <shachaf> You seem to be a fan of them. Seeing 1-tuples everywhere. So maybe you can find a use.
11:29:02 <kadoban> I would guess they're used in contexts where you're generalizing over n-tuples, and it makes sense not to exclude n==1
11:29:26 <kuribas> However the empty set has no values, and the zero tuple has one value.
11:30:09 <RedNifre> But there is one empty set, just like there is one empty tuple.
11:30:39 <kadoban> Is it even techniclaly a 0-tuple? It's called unit usually isn't it? I can't recall what the distinction would really be in practice though.
11:30:58 <Fuuzetsu> you can call () a 0-tuple or unit, it doesn't matter
11:31:05 <zmbmartin> Anyone here familiar with the rethinkdb haskell driver? I can't track down the error that I am getting. 'RethinkDB: Unexpected response: "when expecting a UTCTime, encountered Object instead"'
11:33:10 <zmbmartin> I am trying to read records that were inserted using the js driver. But the data looks correct.
11:33:45 <RedNifre> Are tuples in math thought of as containers with values inside of it where the container is a concept in and of itself, or are they thought of as arrangements of values which doesn't exist without the values?
11:35:37 <kadoban> RedNifre: I'm not really sure what the distinction would be?
11:35:50 <Fuuzetsu> it's getting pretty off-topic
11:36:00 <RedNifre> okay, never mind then.
11:36:25 <RedNifre> For more Haskell related questions, what are your views on LiveScript, PureScript and compiling Haskell to JavaScript?
11:36:35 <RedNifre> Or using Haskell on Android natively?
11:36:37 <seagreen> How can I write an arbitrary instance for `data Foo = Bar Int | Baz Int`?
11:37:23 <RedNifre> seagreen what do you mean, like using a random number to decide Bar/Baz and which Int to use?
11:37:40 <RedNifre> Or (undefined :: Foo) ?
11:38:31 <seagreen> RedNifre: I'm trying to make a nice Test.QuickCheck.Arbitrary instance for the above type, but am not sure what's the slickest way to do it.
11:40:41 <seagreen> Hmm, this isn't bad: `arbitrary = oneof [Bar <$> arbitrary, Baz <$> arbitrary]`
11:40:43 <RedNifre> I know nothing about QuickCheck but if it can generate random booleans and random ints in a tuple you could just write convert (True, number) = Bar number and convert (False, number) = Baz number.
11:41:16 <jerv> Is there any pattern of reflection for extracting the name of the function that you're in?
11:41:18 <jakeehrlich> So is there a proposal to allow bijective functions in view patterns to be used in pattern synonyms?
11:41:24 <seagreen> RedNifre: Good point, even without oneof this is very doable.
11:41:34 <jakeehrlich> *bi-direction pattern synonyms
11:41:37 <shachaf> jakeehrlich: I don't know of one.
11:42:00 <jerv> I.e. I am in a function, calling a function that expects as first parameter the name of the function from which I am calling. I am wondering if there is a "nice" way of doing this?
11:42:32 <johnw> the name, as in a string naming the function?
11:42:43 <jerv> johnw: yes
11:42:51 <johnw> and you don't want to just write that string?
11:43:08 <init> jakeehrlich: there is a way to specify a "Constructor" with GHC 7.10 IIRC
11:43:33 <jerv> johnw: well I could, but this is more a design question I guess, as I will have a lot of functions calling this function that wants to know where the call is coming from
11:43:41 <jakeehrlich> init: really? so I could make map <some_constructor> a “Constructor”?
11:44:04 <init> ah, no, it was just an open ticket 
11:44:29 <jakeehrlich> init: damn…link?
11:44:47 <RedNifre> Do function names actually exist at runtime?
11:45:07 <johnw> jerv: without knowing the higher level problem you're trying to solve, I can't say whether you're going about it the right way or not
11:45:09 <init> https://ghc.haskell.org/trac/ghc/ticket/8581 
11:46:11 <RedNifre> My understanding was that everything except values and function pointers is gone at runtime, you have no type infos and no function/type names. Is that correct?
11:46:59 <init> jakeehrlich: actually, there seems to be some kind of support
11:47:38 <jakeehrlich> so the proposd syntax is redefine the expression in a where cluase?
11:50:15 <jakeehrlich> looks like 7.8 dosn’t support it lol
11:51:18 <dredozubov> can i download documentation for the packages in cabal sandbox similar to 'cabal install --only-dep --enable-documentation' without rebuilding all that stuff?
11:51:55 <monochrom> some function names are stored as error messages, for those functions with inexhaustive patterns :)
11:52:51 <rhaps0dy> When using QuickCheck
11:53:02 <rhaps0dy> where should I define the Arbitrary instances and the properties?
11:53:06 <rhaps0dy> in the source file, or in the test file?
11:55:07 <ChristianS> rhaps0dy: test file
11:55:17 <rhaps0dy> cool, thanks
11:55:39 <rhaps0dy> and when using HSpec, should I have only one check per it ?
11:56:11 <rhaps0dy> like, it "should test something" $ do { 1 `shouldBe` 1; 2 `shouldBe` 2}
11:56:25 <rhaps0dy> should that be separated into two its ?
11:56:47 <Intolerable> i'd keep them together if they're testing the same behavious
11:57:03 <Intolerable> if they're testing two separate things, put them in two its
11:57:15 <Intolerable> it "should do this" $ {check1}
11:57:22 <Intolerable> it "should also do this other thing" $ {check2}
11:58:12 <Wizek> Can a newtype be a functor even if it is not parametric?
11:58:24 <Intolerable> no
11:58:48 <Wizek> Why not?
11:58:49 <RedNifre> Some other language has a reduce function that is just foldl but it takes the first element as the initial value and folds over the rest. But the downside would be that it no longer works for empty lists. Is it possible to write a reduce that works for empty lists and returns the monoid of the fold function? I.e. reduce (+) [1,2,3] would be 6, reduce (+) [] would be 0 and reduce (*) [] would be 1? I mean, this would require a function th
11:58:49 <RedNifre> at takes a function and a type and returns the monoid of that type for that function, which I understand is impossible since Haskell has no type type. Can this be done with template haskell?
11:58:58 <Intolerable> if it has no type variables it can't be of kind * -> *
11:59:02 <monochrom> Wizek: wrong kind
11:59:28 <monochrom> "newtype X = X Int"  X's kind is *
11:59:33 <Intolerable> RedNifre are you looking for foldl1?
11:59:37 <Intolerable> :t foldl1
11:59:38 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
11:59:46 <monochrom> this is better: "newtype Y a = Y Int".
12:00:12 <monochrom> instance Functor Y where fmap _ (Y i) = Y i
12:00:19 <Wizek> I get that part, but fmap could still be defined for it, no? It still makes sense to reach in, do some computation on the held data, and wrap it up again, no? 
12:00:25 <lyxia> :t mconcat
12:00:27 <lambdabot> Monoid a => [a] -> a
12:00:37 <Intolerable> no, because theres no type variable
12:00:37 <Wizek> monochrom, hmm that looks interesting
12:00:41 <monochrom> what is the type of fmap?
12:00:42 <Intolerable> have you seen the newtype library?
12:00:52 <sm> >jerv: actually, yes, it looks like you might be able to do that with http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Stack.html
12:00:55 <shachaf> You can write a mapping function, but it's not an instance of the class Functor and it doesn't have a function with fmap's type.
12:00:57 <Wizek> @hoogle fmap
12:00:57 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:00:57 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
12:00:57 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:01:15 <monochrom> see the "f a" there? there is no way "X" can be "f a".
12:01:21 <RedNifre> Intolerable that one has the same problem, it doesn't work for empty lists.
12:01:32 <sm> jerv: oh, only for programs built with profiling. Too bad 
12:01:46 <monochrom> whereas with my Y, you can use "f=Y, a=a, so f a = Y a"
12:03:28 <Intolerable> :t \f a -> foldr f mempty a
12:03:29 <lambdabot> (Foldable t, Monoid b) => (a -> b -> b) -> t a -> b
12:03:40 <Intolerable> that's what you want probably
12:06:29 <bananagram> :t mconcat
12:06:29 <lambdabot> Monoid a => [a] -> a
12:06:49 <catgocat> Guys how can I improve this http://lpaste.net/137050 ?
12:06:54 <bananagram> it would be cool if that was made general, but probably too hard to implement
12:07:00 <catgocat> Some people have told me to use folds, but I'm really stuck when trying to use them.
12:07:12 <catgocat> I was wondering if any of you guys could give me some tips. http://lpaste.net/137050
12:07:54 <Intolerable> RedNifre alternatively look at foldl's Foldl
12:09:03 <sm> jerv: uh.. you could get the file and line number with $__LOC__ from http://hackage.haskell.org/package/file-location-0.4.9/docs/Debug-FileLocation.html, then parse the file to find the function at that location
12:10:20 <sm> I've done this in PHP, so I was just curious how hard it is in (GHC-compiled) Haskell
12:19:29 <NemesisD> i've got a class Foo a b, how would i write newtype Bar = Bar String deriving (Foo Bar String)? it seems like deriving expects the parameter to fill to be in the final position of the typeclass
12:19:51 <NemesisD> its like i need deriving (`Foo` String)
12:21:09 <Intolerable> have you enabled MultiParamTypeClasses
12:21:14 <Intolerable> *?
12:21:51 <NemesisD> yeah, it complains "Foo Bar String does not have arity 1
12:22:07 <Intolerable> have you enabled FlexibleInstances / FlexibleContexts?
12:22:51 <NemesisD> yeah
12:23:23 <Intolerable> can you lpaste what you're trying to do?
12:26:56 <hexagoxel> NemesisD: use a stand-alone deriving declaration
12:27:35 <hexagoxel> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html
12:27:37 <lpaste_> NemesisD pasted “newtype deriving + multi param typeclass” at http://lpaste.net/137052
12:27:50 <NemesisD> standalone deriving seems to be a no-go
12:28:00 <hexagoxel> how so?
12:28:31 <NemesisD> see the paste
12:39:31 * hackagebot pipes-cereal 0.1.0 - Encode and decode binary streams using the pipes and cereal libraries.  https://hackage.haskell.org/package/pipes-cereal-0.1.0 (ian_mi)
12:43:34 <hexagoxel> ah, "GHC always treats the last parameter of the instance" even for standalone. my bad.
12:44:31 * hackagebot stackage-curator 0.10.0 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.10.0 (MichaelSnoyman)
12:44:33 * hackagebot stackage-types 1.1.0 - Shared data types between various Stackage packages  https://hackage.haskell.org/package/stackage-types-1.1.0 (MichaelSnoyman)
12:47:24 <NemesisD> hexagoxel: so sounds like i've got to write this one by hand, yeah?
12:47:36 <NemesisD> save for some sort of class-level flip
12:54:32 * hackagebot haxr 3000.11.1.1 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.1.1 (BrentYorgey)
12:54:34 * hackagebot twitter-feed 0.2.0.1 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.1 (jpvillaisaza)
13:34:33 * hackagebot http-client 0.4.18 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.18 (MichaelSnoyman)
13:34:36 * hackagebot http-conduit 2.1.7 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.7 (MichaelSnoyman)
13:40:54 <Black0range> Are there any way one could make a function that could work with both ByteString and Text data? 
13:42:42 <catgocat> @pl splitHalf l = splitAt ((length l + 1) `div` 2) l
13:42:42 <lambdabot> splitHalf = splitAt =<< (`div` 2) . (1 +) . length
13:42:48 <Fuuzetsu> Black0range: sure, such as through a typeclass or taking Either ByteString Text
13:43:08 <Fuuzetsu> I hope you're properly decoding your ByteString though ;)
13:44:47 <Black0range> Hmmmm why aren't all standard string functions class instance functions?...  
13:50:13 <Wizek> Are there some ways to observe a haskell expression being evaluated / substituted step-by-step? e.g. (sum [1..2] -> sum [1,2] -> (foldl (+) 0) [1,2] -> ... and so on?
13:50:35 <chpatrick1> Black0range: which ones do you mean?
13:51:06 <quchen> Wizek: There are tools that help you with that, yes, but it's not part of GHC.
13:51:12 <quchen> I'm afraid I don't remember their names though.
13:52:08 <Black0range> chpatrick1: ex: Data.Text Data.Bytestring 
13:52:15 <Black0range> and the lazy variants of them 
13:52:55 <Wizek> Found one! http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%2B%29+0+%5B1%2C2%2C3%5D
13:53:06 <Wizek> beautiful :)
13:54:34 * hackagebot nvim-hs 0.0.1 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.1 (saep)
14:02:42 <kuribas> > sum [a, b, c]
14:02:43 <lambdabot>  0 + a + b + c
14:03:23 <kuribas> Wizek: you can trace execution with ghci
14:04:11 <maerwald> is there any imperative language that tries to force effects into the type system like haskell does?
14:04:19 <Wizek> kuribas, you mean with breakpoints?
14:05:41 <Denommus> in GHCJS, what is the usual way of making a request to a server?
14:05:53 <Denommus> the server gives me a JSON of a type that instances both FromJSON and ToJSON
14:06:48 <jakeehrlich> so…it sounds like you already have your means of making the request
14:07:20 <jakeehrlich> Also using ajax is probably your best bet for making requests to the server when using GHCJS
14:07:43 <chromatome> I'm learning and trying to map (+1) to a list of Maybes - I'm doing it now with `fmap (+1) $ catMaybes [Just 1, Just 2, Nothing, Just 4]`. Am I missing an opportunity to compose fmap and catMaybes though?
14:08:26 <Iceland_jack> Do you want [Just 2, Just 3, Nothing, Just 5] or [2,3,5] back?
14:08:27 <shachaf> Not really.
14:08:29 <shachaf> @src catMaybes
14:08:29 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:08:36 <chromatome> [2,3,5]
14:08:36 <shachaf> You could write [x + 1 | Just x <- l]
14:09:07 <Iceland_jack> > [ 1 + x | Just x <- [Just 1, Just 2, Nothing, Just 4] ]
14:09:08 <lambdabot>  [2,3,5]
14:09:35 * hackagebot delta 0.2.1.1 - A library for detecting file changes  https://hackage.haskell.org/package/delta-0.2.1.1 (muzzle)
14:09:51 <Iceland_jack> If you want the latter
14:09:51 <Iceland_jack> > (fmap.fmap) (+1) [Just 1, Just 2, Nothing, Just 4]
14:09:52 <lambdabot>  [Just 2,Just 3,Nothing,Just 5]
14:10:14 <Iceland_jack> *former
14:10:16 <chromatome> hmm. Never thought to use fmap.fmap
14:11:15 <Iceland_jack> :t fmap.fmap :: (Int -> Int) -> [Maybe Int] -> [Maybe Int]
14:11:16 <lambdabot> (Int -> Int) -> [Maybe Int] -> [Maybe Int]
14:11:50 <jle`> Denommus: you can use websockets
14:11:55 <chromatome> :t liftA
14:11:55 <lambdabot> Applicative f => (a -> b) -> f a -> f b
14:12:05 <chromatome> Ah nvm can't use that.
14:12:22 <jle`> Denommus: or if it's just JSON you can hook onto the various ajax stuff i guess
14:12:54 <dominik1> hey Haskeller's, is there any way to resolve the qualified name of A LOT OF haskell modules efficiently in a concurrent setting?
14:13:23 <jle`> chromatome: (map . fmap) f xs is just map (fmap f) xs :)
14:13:43 <dominik1> I'm trying to use the haskell-names package, but I'm struggeling to make it efficient, e.g., using Data.Concurrent.Async :)
14:13:58 <chromatome> jle`: Thanks. I'm still getting my bearings with composition :)
14:14:16 <jle`> using it as map (fmap f) xs might be clearer
14:14:30 <jle`> both are common style i think
14:15:14 <Iceland_jack> map (fmap (+ 1)) is clearer
14:16:06 <hexagoxel> what are the differences of vector's storable variant and the storablevector implementation?
14:16:30 <chromatome> Thanks guys (and possibly girls)
14:16:31 <hexagoxel> fmap (+1) <$> []
14:17:40 <hexagoxel> reduce number of parentheses at all cost!
14:17:45 <hexagoxel> :p
14:17:53 <chromatome> but lisp
14:18:05 <Iceland_jack> fmap succ <$> [], sections count as parens
14:18:10 <Peaker> [] <&> mapped +~ 1
14:20:02 <hexagoxel> Iceland_jack: Num or Enum is the question..
14:20:36 <Iceland_jack> What ever is fine as long as it isn't Enum
14:21:21 <hexagoxel> so not succ?
14:21:24 <Iceland_jack> yup :)
14:21:35 <benzrf> are there stdlib curried versions of first and second
14:21:57 <Iceland_jack> This at least makes _Just clearer '[] & mapped._Just +~ 1'
14:23:53 <jle`> benzrf: (a -> b, (a, c)) -> (b, c) ?
14:23:59 <chromatome> What's _Just?
14:24:57 <Iceland_jack> chromatome: For this simple example it's overkill when (map (fmap (+1))) works fine, but it's a prism from the lens library
14:25:21 <chromatome> Hmm ok. I've got lots to learn still. Back to the books for me!
14:25:54 <hexagoxel> jle`: that'd be uncurry though
14:25:55 <Iceland_jack> I was just having a laugh, but there is always more to learn
14:25:59 <benzrf> jle`: er, no
14:26:07 <init> @type first 
14:26:07 <jle`> oh, yeah
14:26:08 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:26:11 <benzrf> @hoogle (a -> b) -> (a -> t -> b)
14:26:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:26:12 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
14:26:12 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
14:26:18 <benzrf> @hoogle (a -> b) -> (t -> a -> b)
14:26:18 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:26:19 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
14:26:19 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
14:26:25 <init> benzrf: you want (<$>) and (<*>) ? 
14:26:27 <benzrf> you can do it easily with (.) and const
14:26:27 <init> I think?
14:26:28 <jle`> i don't think that'd be first
14:26:31 <benzrf> but it tends to be obfuscatory
14:26:36 <init> yeah, it's not first
14:26:45 <benzrf> hm
14:27:11 <jle`> @pl \x y -> f x
14:27:12 <lambdabot> const . f
14:27:17 <init> benzrf: did you want stuff like (a -> a') -> (a' -> b -> c) -> (a -> b -> c) ? 
14:27:21 <ttt_fff> despite everything I hate about emacs lisp, there are times when dynamically-scoped varaibles work better than lexically scoped varaibles (for passing weird dynamic configs without having to rewrite all the intermediate layers) -- is there some way to get this in Haskell? (this seems very (1) unpure and (2) untype safe -- but haskellers are magical, so maybe this is possible)
14:27:31 <benzrf> er, not first
14:27:31 <ttt_fff> benzrf: how is haskell in a sptreadsheet coming along?
14:27:34 <hexagoxel> :exf -p "(a -> c) -> a -> b -> (c, b)"
14:27:35 <exferenceBot> ((,) .)
14:27:35 <benzrf> ttt_fff: shhh
14:27:38 <hexagoxel> benzrf: ^
14:27:43 <Iceland_jack> ttt_fff: Look at 'reflection' library 
14:27:46 <benzrf> crap
14:27:55 <init> ttt_fff: you can use implicit variables
14:28:09 <ttt_fff> Iceland_Jack: https://hackage.haskell.org/package/reflection <-- to double check, is this what you're referring to?
14:28:12 <Iceland_jack> Yes
14:28:22 <Iceland_jack> Using implicits is simpler though ttt_fff, if you've just started
14:28:34 <ttt_fff> init: is 'implicit variable' the same as ;implicit parameter' ?
14:28:40 <Iceland_jack> > let ?a = 42 in ?a + ?a
14:28:42 <lambdabot>  84
14:29:16 <Iceland_jack> > let foo = 10 * ?a + 20 in (let ?a = 4 in foo)
14:29:18 <lambdabot>  60
14:29:25 <ttt_fff> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters ?
14:29:32 <Iceland_jack> That's right
14:29:35 <ttt_fff> <-- is this what you mean by implicit varaibles?
14:29:36 <Iceland_jack> ttt_fff: You see that 'foo = 10 * ?a' takes no explicit parameters
14:29:45 <init> yes ttt_fff 
14:29:49 <ttt_fff> oh wtf
14:29:50 <ttt_fff> damn
14:29:51 <ttt_fff> this is sorta cute
14:29:56 <Iceland_jack> :t let foo = ord ?a + 1 in foo
14:29:57 <lambdabot> (?a::Char) => Int
14:30:03 <ttt_fff> and it's even nice that the dynamic vars are _EXPLICITLY DYNAMIC_ since they start with a "?"
14:30:44 <catgocat> @pl foldTree xs = insertNodes (getTreeHeight) xs
14:30:44 <lambdabot> foldTree = insertNodes getTreeHeight
14:30:59 <catgocat> @pl foldTree xs = insertNodes (getTreeHeight xs) xs
14:30:59 <lambdabot> foldTree = insertNodes =<< getTreeHeight
14:31:00 <Iceland_jack>     foo :: (?a :: Char) => Int
14:31:00 <Iceland_jack>     foo = ord ?a + 1
14:31:25 <maerwald> I don't think the reflection package delivers _dynamic_ configuration in the sense of "it may even change during execution". Once you called reify... you are bound to that value of your config.
14:31:55 <ttt_fff> damn it
14:32:01 <ttt_fff> edward kemmett again ! (reading reflection tutorial)
14:32:06 <catgocat> @pl getTreeHeight xs = ceiling (logBase 2 (fromIntegral $ length xs) + 1) - 2
14:32:06 <lambdabot> getTreeHeight = subtract 2 . ceiling . (1 +) . logBase 2 . fromIntegral . length
14:32:12 <ttt_fff> this guy is like the kevin bacon of ahskell
14:32:15 <maerwald> the only advantage is that it's not a parameter anymore, but just a typeclass constraint
14:32:56 <maerwald> the idea was initially from oleg though
14:36:47 <catgocat> @pl half xs = splitAt ((length xs + 1) `div` 2) xs
14:36:47 <lambdabot> half = splitAt =<< (`div` 2) . (1 +) . length
14:38:03 <catgocat> @pl insertNodes n (x:xs) = Node n (insertNodes (n-1) (fst half)) (insertNodes (n-1) (snd half))
14:38:03 <lambdabot> insertNodes = fix (flip flip tail . (ap .) . flip flip head . (((.) . const . const) .) . ap (ap . ap Node . flip flip (fst half) . (. subtract 1)) (flip flip (snd half) . (. subtract 1)))
14:38:08 <catgocat> haha
14:49:37 * hackagebot reddit 0.1.0.0 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.1.0.0 (Intolerable)
14:59:09 <catgocat> @pl map' f = foldr (\x a -> f x : a) []
14:59:09 <lambdabot> map' = flip foldr [] . ((:) .)
15:00:43 <Eduard_Munteanu> map' = map   --   :)
15:02:54 <hftf`> Hi guys, I'm really new to haskell. I'm trying to write a function extract the value of a CSS property from an inline style attribute string. for example: f "foo" "foo: bar" = "bar". Where do I start?
15:03:30 <mauke> somewhere else, hopefully
15:04:11 <mauke> like basic arithmetic, simple functions and data structures
15:04:22 <subleq> hftf`: you probably need a full css parser
15:04:26 <Zemyla> hftf`: You find a library that can parse HTML and/or CSS, and use that.
15:04:37 * hackagebot spatial-math 0.2.4.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.2.4.0 (GregHorn)
15:19:38 * hackagebot hierarchical-clustering-diagrams 0.3.1 - Draw diagrams of dendrograms made by hierarchical-clustering.  https://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.3.1 (FelipeLessa)
15:24:38 * hackagebot statistics-dirichlet 0.6.2 - Functions for working with Dirichlet densities and mixtures on vectors.  https://hackage.haskell.org/package/statistics-dirichlet-0.6.2 (FelipeLessa)
15:24:40 * hackagebot gsc-weighting 0.2.1 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  https://hackage.haskell.org/package/gsc-weighting-0.2.1 (FelipeLessa)
15:24:42 * hackagebot biostockholm 0.3.3 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  https://hackage.haskell.org/package/biostockholm-0.3.3 (FelipeLessa)
15:24:44 * hackagebot hierarchical-clustering 0.4.5 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  https://hackage.haskell.org/package/hierarchical-clustering-0.4.5 (FelipeLessa)
15:24:46 * hackagebot nonlinear-optimization 0.3.8 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.8 (FelipeLessa)
15:26:05 <ttt_fff> Is there a way to tell Haskell "pick more specializd" ? For example, suppose I have "class Render a where render :: a -> Gfx() " ... and suppose I have a "instance (Render k, Render v) => Render (Map k v) where .." <-- this is generic, now, suppose I also have a very specific "instance Render (Map Int Int) where ..." ... right now, I get a conflict about 'overlaps' -- but I'd prefer to be able to set some order of preference and te
15:27:14 <ttt_fff> https://gist.github.com/anonymous/795c59d126f7f03bc237 <-- full question. PLS ANSWER
15:27:17 <ttt_fff> HALP
15:27:38 <chpatrick1> ttt_fff: there's OverlappingInstances but it's usually frowned upon
15:27:46 <ttt_fff> why
15:27:55 <ttt_fff> I feel this is good design -- have a basicall faallback, then more specific stuff
15:28:01 <ttt_fff> What is 'the haskell approved way' to solve this problem?
15:29:10 <chpatrick1> you could use a newtype
15:29:17 <chpatrick1> what are you trying to do in this exact case?
15:29:48 * hackagebot hierarchical-clustering 0.4.6 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  https://hackage.haskell.org/package/hierarchical-clustering-0.4.6 (FelipeLessa)
15:29:49 <ttt_fff> so I have a generic routine for rendering (Map k v)
15:29:50 * hackagebot hierarchical-clustering-diagrams 0.3.2 - Draw diagrams of dendrograms made by hierarchical-clustering.  https://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.3.2 (FelipeLessa)
15:29:52 * hackagebot statistics-dirichlet 0.6.3 - Functions for working with Dirichlet densities and mixtures on vectors.  https://hackage.haskell.org/package/statistics-dirichlet-0.6.3 (FelipeLessa)
15:29:54 * hackagebot gsc-weighting 0.2.2 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  https://hackage.haskell.org/package/gsc-weighting-0.2.2 (FelipeLessa)
15:29:56 * hackagebot biostockholm 0.3.4 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  https://hackage.haskell.org/package/biostockholm-0.3.4 (FelipeLessa)
15:29:57 <ttt_fff> but I want to specialize it so that (Map Int Int) are rendered in a different way
15:30:14 <ttt_fff> I have a generic routine for rendering (Map k v), but I want (Map Int Int) to be rendered in a different way
15:30:33 <geekosaur> ttt_fff, the problem with using OverlappingInstances like that is that instances are global
15:30:54 <ttt_fff> well, I'm already guilty of orphan instances which I use all over the place
15:30:58 <chpatrick1> ttt_ff: what's different about it?
15:31:00 <geekosaur> so you start using some random library, whoops, it has an instance you didn't know about and suddenly your program's behavior changes
15:33:45 <ttt_fff> yeah
15:33:48 <ttt_fff> but this is a rendering routine
15:34:05 <ttt_fff> I'm okay with this particular routine ahving overlapping instances so I don't ahve to write tedious boiler plate to render everything and haskell cn auto generate some of them for me
15:34:10 <ttt_fff> but then I can also specialize how other data structure slook
15:34:58 * hackagebot nonlinear-optimization 0.3.9 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.9 (FelipeLessa)
15:38:09 <chpatrick1> maybe you could pull out what's different about ints into a different typeclass
15:38:35 <chpatrick1> or alternatively make a newtype IntsMap = IntsMap (Map Int Int) and make an instance for that
15:39:39 * hackagebot eprocess 1.7.1 - Basic Erlang-like process support for Haskell  https://hackage.haskell.org/package/eprocess-1.7.1 (CorentinDupont)
15:54:39 * hackagebot hint-server 1.4.1 - A server process that runs hint.  https://hackage.haskell.org/package/hint-server-1.4.1 (CorentinDupont)
16:05:30 <shergill-web> edwardk: could you clarify what you meant by your comment here: <http://www.reddit.com/r/haskell/comments/39wpi8/fusion_for_free_efficient_algebraic_effect/cs7np9z>. specifically, what "all the lazy state and lazy writer examples" are
16:44:37 <Tuplanolla> How can I create a file if it does not exist and avoid a race condition?
16:45:08 <Tuplanolla> I want an exception in case it already exists.
16:47:39 <Tuplanolla> Either I'm dumb or System.IO is crippled.
16:48:01 <geekosaur> System.IO is portable. this can be considered a form of crippling
16:48:37 <Tuplanolla> There's no way to do it on most systems?
16:48:48 <geekosaur> no reasonably portable way
16:49:23 <geekosaur> (IIRC windows adds in extra locking stuff that can be unexpected unless you use special APIs)
16:49:47 <Tuplanolla> Once again I'm reminded how terrible operating systems actually are.
16:59:42 * hackagebot xcffib 0.3.3 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.3.3 (TychoAndersen)
17:04:24 <Tuplanolla> Thanks for that though.
17:04:49 <Tuplanolla> Now I have one more thing to be sad about.
17:09:43 * hackagebot xcffib 0.3.4 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.3.4 (TychoAndersen)
18:09:48 <homa_rano> I'm having trouble convincing foldl to take Integer types instead of assuming things are Ints
18:10:54 <homa_rano> foldl (\x y -> x*y) (toInteger 1) [(toInteger 1)..(toInteger a)]
18:11:12 <homa_rano> complains that the things it wants to be Ints are Integers, but I want it to accept Integers so it doesn't overflow
18:22:19 <geekosaur> > let a = 5 in foldl (\x y -> x * y) (1 :: Integer) [(1 :: Integer) .. (fromIntegral a)]
18:22:20 <lambdabot>  120
18:22:47 <geekosaur> at least one of those `:: Integer' can be left off
18:22:48 <ttt_fff> so I'm reading about bitcask; how big does data have to get to in order for keys to not fit in RAM ?
18:22:53 <geekosaur> as long as it's a numeric constant
18:24:32 <Ryanar> hey guys, i am building a simple webapp that displays some simple table data, allows for user registration and logging in, and allows users to update data in the frontend
18:24:46 * hackagebot json-rpc-server 0.2.1.0 - JSON-RPC 2.0 on the server side.  https://hackage.haskell.org/package/json-rpc-server-0.2.1.0 (grayjay)
18:25:10 <Ryanar> is it crazy to do the backend with something like Servant for the API, Warp web server and Shakespeare templating?
18:27:41 <Ryanar> or should i build the backend with something more mainstream like ruby on rails
18:48:07 <creichert> not crazy, use haskell
18:49:47 * hackagebot nonlinear-optimization 0.3.10 - Various iterative algorithms for optimization of nonlinear functions.  https://hackage.haskell.org/package/nonlinear-optimization-0.3.10 (FelipeLessa)
18:54:28 <Ankhers> I'm playing around with forkIO. I've noticed that you can use killThread on the same thread ID multiple times, and I didn't get any sort of exception. Aside from being useless, is there anything that can go wrong when calling killThread on a given thread multiple times?
18:59:47 * hackagebot turkish-deasciifier 0.1.0.0 - Haskell port of Deniz Yuret's Turkish deasciifier.  https://hackage.haskell.org/package/turkish-deasciifier-0.1.0.0 (cattheory)
19:40:00 <haskell562> shergill-web: ping
19:44:54 <Vektorweg1> can i tell ghc/runtime to use just some amount of ram and then relay on own temp/swap? 
20:44:43 <lethjakman> haskell makes sure you return the same value from a function every time you call it with the same parameters, does that mean it's cached?
20:45:09 <Vektorweg1> lethjakman: yes.
20:45:23 <Vektorweg1> and yes, its sometimes bad. 
20:45:44 <Vektorweg1> e.g. ghc cached it usually. can be disabled of course.
20:45:47 <lethjakman> yeah, I noticed with random numbers it kinda sucks. 
20:45:53 <hiptobecubic> *sometimes*
20:45:58 <lethjakman> but it seems really useful for a lot of things too. 
20:46:04 <OutlawStar> vektorwegl: in non-side affect code, when would it be bad?
20:46:19 <hiptobecubic> OutlawStar, when something is cheap to compute but enormous to store
20:46:31 <lethjakman> OutlawStar: when you want some fun non-deterministic bugs to hunt down of course!
20:46:32 <hiptobecubic> OutlawStar, lists usually have this problem.
20:46:33 <Vektorweg1> OutlawStar: only risk is you run out of ram because of cached values.
20:46:40 <OutlawStar> ah ok
20:46:49 <OutlawStar> so it doesn't have cache expire policy?
20:47:02 <lethjakman> can't it dump the value and recalculate it if necessary?
20:47:11 <lethjakman> I don't know if it's that smart...
20:47:18 <hiptobecubic> OutlawStar, consider something like computing the mean of a list
20:47:39 <noah__> ccaching isn't really the waay to think about it
20:47:39 <hiptobecubic> the naive way is to do  (sum list) / (length list)
20:47:42 <noah__> it don't think
20:47:53 <Vektorweg1> lethjakman: its actually an optimization and can be disabled at all. the real meaning of same input leads to same output is pureness. 
20:48:46 <hiptobecubic> OutlawStar, but if you do it that way, then even if the list is something easy to compute like [0,1..10000000], it will read it into memory and hang on to it
20:48:52 <Vektorweg1> e.g. guarantees of behavior.
20:48:57 <OutlawStar> hiptobecubic: why?
20:49:00 <lethjakman> makes sense...
20:49:07 <lethjakman> I was just hoping the caching was a side effect of that.
20:49:12 <OutlawStar> hiptobecubic: it won't just hold final value?
20:49:18 <hiptobecubic> OutlawStar, because it knows while it's computing the sum that it's going to need the list again to compute the length
20:49:24 <hiptobecubic> so it can't garbage collect it
20:50:16 <OutlawStar> ah is it because, it needs to traverse entire list every time?
20:50:25 <OutlawStar> and therefore everything stays in mem?
20:50:35 <lethjakman> hiptobecubic: what's the not so niave way to find the mean of a list?
20:51:28 <hiptobecubic> basically it's because you are hanging on to head of the list and then accessing the tail. So it walks the whole list which fills memory, but it can't throw it out because you still have the reference to the head, from which you expect to be able to access the rest of it.
20:51:42 <OutlawStar> right :(
20:51:42 <hiptobecubic> lethjakman, you could walk the list one time and compute the sum and length simultaneously, for example
20:52:42 <hiptobecubic> > foldr (\item (summ, len) -> (summ + item, len +1)) (0, 0) [1..100]
20:52:43 <lambdabot>  (5050,100)
20:53:09 <OutlawStar> what determines when something is removed from cache, reference counts to the items in the cache?
20:53:30 <hiptobecubic> well certainly if there is still a live reference then the item can't be garbage collected
20:53:46 <hiptobecubic> and it's not "cache" it's just memory
20:54:13 <hiptobecubic> cache implies that it also lives somewhere else
20:54:52 <OutlawStar> right sorry, but basically if i had mean :: [Int] -> Int, if i just held onto the result, and i used the naive approach. That should get GC'd
20:55:29 <OutlawStar> the list that is
20:56:04 <Vektorweg1> hiptobecubic: sorry. ;)
20:57:28 <hiptobecubic> it will get GC'd *after* the mean is computed, but it won't compute it in constant space doing the GC as it goes
20:58:05 <Vektorweg1> i wonder if automatic concurrency would fix `sum xs / length xs` things.
20:58:21 <hiptobecubic> no
20:58:39 <hiptobecubic> well, I suppose in a magic world it could
20:58:45 <Vektorweg1> well the automatic concurrency in ghc of course. 
20:58:50 <Vektorweg1> *not
20:59:06 <Vektorweg1> uh. not ghc. because ghc can't do that magic.
21:00:17 <kristof> Strategies are pretty close to auto-concurrency.
21:00:35 <hiptobecubic> I guess in theory you could spark two threads, half the scheduler flick between them and allow the head of the list to be cleaned up as both threads move down the line, but that seems really unlikely in real world usage and I'm not sure that's how the GC is implemented anyway
21:00:42 <Vektorweg1> kristof: still sounds human-selected. 
21:01:39 <nkaretnikov> is there a "container" besides Data.Map that has a 'minView'-like function?
21:01:41 <Vektorweg1> where is the sufficiently smart compiler if we need one. 
21:01:56 <hiptobecubic> Vektorweg1, people are trying. Turns out it's really hard
21:02:44 <nkaretnikov> Vektorweg1: listen to "the death of optimizing compilers" by djb
21:02:51 <hiptobecubic> Knowing in advance whether the running time of a function will be worth the overhead of parallelism is difficult.
21:03:04 <kristof> Vektorweg1: You wouldn't want auto-concurrency. The compiler doesn't necessarily know if adding threads to your program will make it slower or faster.
21:03:28 <athan> Cale: ping
21:03:30 <kristof> Vektorweg1: Have you ever tuned a parallel application?
21:03:36 <OutlawStar> yeah i don't see how auto-concurrency would be feasible
21:03:36 <athan> Cale: Can we talk matroids for a second?
21:03:42 <Vektorweg1> i only need an approximation. i think about that for a long time now and i'm sure a ML algorithm could get in some time a sufficiently good solution. 
21:03:50 <OutlawStar> unless you did the equivalent of branch prediction
21:03:52 <hiptobecubic> athan, I love that game
21:03:56 <OutlawStar> but thats require more resources..
21:04:38 <Vektorweg1> kristof: i stopped to code for performance since i stopped using c++ . ;)
21:04:54 <athan> Cale: I feel like the only way `greedy` can find the maximum subset is if there is a homomorphism from set sizes & unions over to the abelian semigroup function combining results of the weight function used
21:05:16 <athan> Cale: Let me know if you'd like to hear more!
21:05:29 <Vektorweg1> athan: its always about a weight function.
21:06:06 <athan> Also I think that though the monotonicity, we can derive that the approach toward the maximal subset is linear, because comparing set sizes (Natural number increments) is linear
21:06:25 <athan> Vektorweg1: Weight what are you talking about?
21:10:59 <Vektorweg1> athan: that it always ends in a weighting, because a machine depends on multiple variables relative to an algorithm.
21:11:00 <kristof> Vektorweg1: Then you don't need parallelism anyway
21:12:16 <Vektorweg1> kristof: yep, manual concurrency isn't needed for an SSC. theoretically. i guess. 
21:12:43 <Vektorweg1> wonder how morte is going. 
21:15:22 <Vektorweg1> however, my model for an compiler is approximated optimization using ML algs and continuous background compilation.
21:19:50 <Vektorweg1> sorry, its late. 
22:07:07 <ghost_runner> Anyone have a link to SICP that uses Haskell instead of Scheme? Haskell > Scheme, imo, so I'd like to read this prestigious book with that language.
22:09:59 <peddie> ghost_runner: SICP doesn't talk about types . . . not sure you could just translate the book directly, but why not just work through SICP with scheme?  it's legendary as-is :)
22:10:42 <ghost_runner> Will using Scheme help me reach programming satori like /prog/ says?
22:10:44 <peddie> if you grok what you're working through, you won't have much trouble applying what you've learned to your programs in languages other than Scheme
22:10:50 <elbens> Is there a way to type this in Haskell: selfApp = λx:∀X.X→X. x [∀X.X→X] x; (this is from Pierce pg 345)
22:11:26 <peddie> ghost_runner: I'm not sure what that means, but I found SICP extremely enlightening (hadn't really programmed before, though)
22:12:14 <lispy> elbens: I can't figure out what that says
22:12:35 <lispy> (and my copy of Pierce is at work)
22:12:45 <ghost_runner> peddie: May I PM you?
22:13:06 <lispy> elbens: would the haskell version be this? \x -> x x
22:13:10 <elbens> lispy: selfApp = \(x :: (a -> a)) -> (x :: (b -> b)) x
22:13:17 <elbens> lispy: yes
22:13:29 <lispy> elbens: it's not directly typeable in haskell
22:13:48 <peddie> ghost_runner: OK
22:15:11 <lispy> elbens: This might help: http://r6.ca/blog/20060919T084800Z.html
22:17:17 <elbens> lispy: hmm, thanks. I’m trying to figure out how my toy type inferencer should deal with polymorphic things like this
22:17:28 <lispy> gotcha
22:17:41 <lispy> type checking polymorphic recursion is a known tricky topic
22:18:15 <elbens> but it is not recursion in (\x -> x x), right?
22:20:09 <lispy> It kind of is right, because x is used to define x
22:20:47 <lispy> would you say that "let x = x in x" is a recursive definition of x?
22:22:14 <lispy> The tricky part about typing selfApp is the infinite type. Most type theories (I know) don't allow infinite types. So this fails at the occurs check.
22:25:08 <elbens> Yes, I see. The tricky part isn’t clicking in my head (and it’s too late in the evening), but it feels like I want two fresh copies of x, one x :: (a -> a) and one x :: (b -> b), which seems allowable since x is polymorphic.
22:26:02 <lispy> elbens: I have not read this paper, but it looks relevant: http://www.diku.dk/hjemmesider/ansatte/henglein/papers/henglein1993a.pdf
22:31:09 <lispy> elbens: So having x at two different types is possible
22:31:10 <lispy> > let foo = (x 'a', x 1) where x = id in foo
22:31:11 <lambdabot>  ('a',1)
22:31:27 <lispy> But, it's different than here because x is bound by lambda
22:31:42 <lispy> so the type of x should be constant in the body
22:32:25 <elbens> “bound by lambda"?
22:32:33 <lispy> \x -> ...
22:33:15 <jfeltz> DAE find something like blaze-html counter-intuitive after awhile? At some point I'd like to focus on authorship, but weaving in non-declarative functions and missing multi-line strings etcl breaks my train of thought :(
22:33:20 <elbens> In your example above, the pair is the body and we see two differnet uses of x. I suppose that is because you hinted which x with your argument
22:34:06 <lispy> elbens: You could lift that where-clause right of the definition
22:34:24 <lispy> So, it's sort of like, (id 'a', id 1)
22:34:42 <elbens> yes, the type inferencer doesn’t have to unify
22:36:22 <lispy> I wonder if we could cheat with rank-2 types
22:36:32 * lispy goes off to /query lambdabot 
22:36:39 <wedens> how can I get error path when decoding with aeson? `eitherDecode` has only error message without path
22:36:51 <Cale> jfeltz: I'm not sure if I'd call it counter-intuitive, but the fact that it's a monad for no reason apart from abusing do-notation is a bit strange. Is that what you're referring to?
22:37:26 <lispy> :t let x :: forall a. a -> a; x = x x in x
22:37:27 <lambdabot> a -> a
22:37:34 <elbens> lispy: I have to go—i’ll check the thread in the morning
22:37:34 <Cale> I don't know what "non-declarative functions" are
22:37:49 <Cale> also, what do you mean by "missing multi-line strings"?
22:38:10 <lispy> elbens: that seems to have worked
22:38:34 <elbens> lispy: interestingly that is what Pierce’s example was showing, I think
22:39:11 <elbens> lispy: selfApp = λx:∀X.X→X. x [∀X.X→X] x;, X is universal for each occurence
22:39:15 <lispy> and that's not even using a rank-2 type. I just had to be explicit about the forall
22:39:51 <lispy> Not sure why I didn't think to try that sooner :)
22:41:13 <jfeltz> Cale: I'm a total noob when it comes to web development with Haskell, and I'm trying to balance the concern of writing content, and dealing with Haskell (albeit of which is very powerful for this purpose, such as creating Functors out of things like Footer { email :: Html, socialmedia :: Html }, and then fmapping CSS and other Html on that), but what I want to do is focus on authorship at times, and not necessarily worry about func. arch
22:41:13 <jfeltz> itecture, if that makes sense
22:41:36 <jfeltz> architecture*
22:41:53 <elbens> lispy: that is intersting indeed. I will have to reconsider my inferencer...
22:41:57 <elbens> goodnight!
22:42:09 <lispy> g'night
22:43:27 <Cale> jfeltz: Well, there exist templating systems like Heist which might be what you're looking for?
22:44:05 <dmwit> wedens: What is an error path?
22:44:54 <wedens> dwit: as I can see from sources parser stores some context, but if I do (o .: "a") >>= (.: "b") and it fail to find key "b" I only get "Key b not present"
22:45:21 <wedens> * dmwit
22:45:49 <wedens> dmwit: I want ssomething like "Key b not present at ["a"]"
22:46:08 <jfeltz> Cale: maybe, i think what I need at-least is add more editor tools to handle the creation of blaze functions, i suspect this will just get easier with time, types are are too good to give up on
22:46:29 <dmwit> wedens: You will probably have to hack on aeson to make that happen.
22:46:40 <dmwit> If you're up for it, that sounds like a fantastic feature to add.
22:47:09 <wedens> dmwit: aeson has this feature, but looks like it's broken
22:47:49 <wedens> dmwit: it has path in parser, path formatter etc, but there is nothing in the error :(
22:48:06 <dmwit> You have a funny definition of "has this feature". =)
22:50:08 <dmwit> Just looking at the type of `(.:)`, I don't see how it could be done. I think one would have to have an annotated (.:) that the programmer could tell about where the Object came from.
22:50:39 <wedens> `Just v -> parseJSON v <?> Key key`
22:50:44 <wedens> <?> is an annotation
22:50:49 <wedens> of path
22:51:02 <wedens> https://github.com/bos/aeson/blob/master/Data/Aeson/Types/Instances.hs#L1508
22:51:06 <dmwit> But not the path to obj; the path *from* obj, which is less useful.
22:51:53 <wedens> aeson-better-errors probably solves this
22:54:11 <unknownloner> I want to run some calculations while generating an output log. Some can fail, and if they do I want to handle that, but I still want to get the log up to that point. What'd be a good way to do this?
22:54:37 <dmwit> wedens: Notice that aeson-better-errors has a different type for its keying operation. =)
22:54:42 * dmwit feels vindicated
22:54:45 <wedens> dmwit: yeah
22:56:09 <wedens> unknownloner: WriterT Either ?
22:56:29 <dmwit> ExceptT Writer, probably
22:56:51 <dmwit> ?unmtl WriterT w Either a
22:56:52 <lambdabot> Either (a, w)
22:57:01 <dmwit> ...wat
22:57:10 <unknownloner> yeah, thats what I was running up against
22:57:15 <dmwit> ?unmtl WriterT w (Either e) a
22:57:15 <lambdabot> (Either e) (a, w)
22:57:27 <dmwit> ?unmtl ExceptT e (Writer w) a
22:57:27 <lambdabot> ExceptT e (Writer w) a
22:57:33 <dmwit> ?unmtl ErrorT e (Writer w) a
22:57:33 <lambdabot> (Writer w) (Either e a)
22:57:40 <dmwit> So yeah, ExceptT Writer.
22:59:13 <unknownloner> thanks!
23:08:59 <unknownloner> yup, that works pretty well
23:11:13 <Hafydd> I don't think ErrorT is equivalent to Either!
23:11:46 <dmwit> ErrorT and ExceptT are indeed different. But unmtl only knows about one of them.
23:12:02 <unknownloner> I don't suppose there'd be a way to stream the result of the writer would there? In other words, have output be generated in such a way that it can be used (printed to console or something) before the whole calculation is done
23:12:14 <dmwit> That is the default behavior.
23:12:15 <unknownloner> I tried using the Lazy writer, but that didn't work
23:12:49 <unknownloner> to test it I had it 'tell' something, and then go into an infinite loop
23:13:04 <dmwit> > runWriter (runExceptT (tell ["foo"] >> undefined))
23:13:06 <lambdabot>  (*Exception: Prelude.undefined
23:14:32 <dmwit> > let (a, w) = runWriter (runExceptT (tell ["foo"] >> undefined)) in (w, a)
23:14:34 <lambdabot>  (["foo"*Exception: Prelude.undefined
23:14:44 <dmwit> Seems to be working to me.
23:16:12 <dmwit> Perhaps you should try to produce a minimal example and post some code.
23:24:04 <unknownloner> alright I'll see what I can do
23:35:37 <unknownloner> Found the problem, when trying to return the log output I was relying on the value of the error message
23:35:43 <unknownloner> so it couldn't return anything until an error occured
23:50:55 <latk> How can I pass compiler flags to stack build?
23:51:29 <latk> Ah, --ghc-options looks like it will work.
