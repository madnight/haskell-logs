00:00:04 <quchen2> And the second one has a "," instead of a ".", I assume.
00:00:13 <quchen2> forall a b. a -> b   ← is a type
00:00:24 <ttt_fff> quchen2: in haskell, are all quantifiers "on the outside" ?
00:00:34 <quchen2> Yes.
00:00:40 <pharaun> ie if you see the test, i serialize both type fine but i can't read both type back in
00:00:48 <quchen2> GHC allows quantifiers "on the inside" as well when you enable RankNTypes.
00:00:49 <sydneyhacker> quchen2 what is the type of that though? 
00:00:50 <ttt_fff> so there's never a situation where I have foo -> ( forall x . some expr involving x) ?
00:01:18 <ttt_fff> coming from a Coq background
00:01:20 <quchen2> ttt_fff: Not in Haskell, no.
00:01:24 <quchen2> In GHC-Haskell yes.
00:01:26 <quchen2> :t runST
00:01:27 <lambdabot> (forall s. ST s a) -> a
00:01:28 <ttt_fff> slightly confused on how haskell mangages to force all quantifiers ot be on the outside
00:01:45 <Cale> ttt_fff: The quantifiers are on the outside if you don't specify them
00:02:01 <ttt_fff> Cale: and there is no way to force q auntifier to be on the inside?
00:02:23 <Cale> ttt_fff: In GHC you can explicitly quantify things by turning on e.g. RankNTypes
00:02:28 <sydneyhacker> si what is s and a when you have 3 different arrays, lets say one that contains strings, on with ints, one with bools
00:02:36 <Cale> But in standard Haskell, you just can't express those types at all.
00:02:40 <ttt_fff> Cale: without RankNTypes extensions, I can't do this?
00:02:43 <Cale> right
00:02:45 <ttt_fff> hmm; I'm surprised
00:02:59 <Cale> and things aren't allowed to have types which look like that -- those are not Hindley-Milner types either
00:03:15 <Cale> HM type inference doesn't quite work in the face of such types
00:03:25 <sydneyhacker> for a single array it is something like ST s (STArray s (Int, Int) Char)
00:03:26 <ttt_fff> this explains why my type checker is so fucking ahrd to write; I'm not limitng myself to Hindley-Milner types
00:04:19 <quchen2> sydneyhacker: (ST s) is something you should view to be as opaque as IO.
00:04:27 <Cale> sydneyhacker: Uh, a value of type ST s (STArray s (Int, Int) Char) is an ST computation which when executed will produce an STArray indexed by (Int, Int) containing Char values.
00:05:02 <Cale> sydneyhacker: A computation which makes use of a bunch of STArrays needn't display the fact that it does so in its type
00:05:10 <sydneyhacker> ah ok so you can use them without them in the type for intermediate computation
00:05:34 <sydneyhacker> thanks guys, it may seem silly but there is scant information on the web about this :-)
00:06:25 <sydneyhacker> and with this power i promise not to transliterate my imperative coding practices 
00:07:28 <quchen2> sydneyhacker: With great power comes great responsibility.
00:07:30 <pharaun> Cale: aha i see, i think its an limitation of hexpat-pickle, i see hxt and xml-pickler has a concept of sequence hexpat-pickle doesn't
00:07:38 <pharaun> Cale: and i think that's what is giving me the trouble here
00:07:39 * hackagebot shelly-extra 0.3.0.1 - shelly features that require extra dependencies  https://hackage.haskell.org/package/shelly-extra-0.3.0.1 (GregWeber)
00:07:39 * hackagebot chatter 0.5.2.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.5.2.0 (RoganCreswick)
00:07:41 <Cale> pharaun: aha
00:08:00 <pharaun> Cale: thanks for being a rubber duck :)
00:08:06 <Cale> pharaun: I was peeking at the hexpat-pickle docs a bit, but I'd never used it to try to parse an existing XML syntax
00:08:12 <pharaun> ahh
00:08:16 <pharaun> yeah its my first time :)
00:08:33 <pharaun> and i picked hexpat because i've had prev exp with the lower level hexpat stuff and itw as reasonable fast
00:08:35 <jTT_> hi, what does * mean in a data declaration?
00:08:39 <pharaun> hxt is nice but it could be a bit slow at times
00:08:39 <Cale> pharaun: It's much easier to work with if you don't care what the output XML looks like
00:08:54 <quchen2> jTT_: Example code?
00:08:59 <pharaun> Cale: indeed, it can serialize things just fine, but i'm kinda stuck with reading in a existing format
00:09:08 <jTT_> data CoverTree_
00:09:08 <jTT_>         ( childC :: * -> * ) -- the container type to store children in
00:09:09 <jTT_>         ( leafC  :: * -> * ) -- the container type to store leaves in
00:09:10 <jTT_>         ( dp     :: *      ) -- the type of the data points
00:09:34 <quchen2> jTT_: That's a kind annotation.
00:09:46 <quchen2> Kinds are the "types of types".
00:10:00 <jTT_> does it mean “any kind” then?
00:10:05 <quchen2> * is any kind, yes.
00:10:10 <jTT_> ah kk, thanks
00:10:19 <quchen2> * -> * is a type constructor like Maybe.
00:10:21 <quchen2> :k Maybe
00:10:22 <lambdabot> * -> *
00:10:32 <quchen2> :k MaybeT
00:10:33 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
00:10:33 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
00:10:38 <quchen2> :k StateT
00:10:39 <lambdabot> * -> (* -> *) -> * -> *
00:11:16 <quchen2> StateT takes one type parameter (the state type), one type constructor (the base Monad), and one type for the value of the monadic computation.
00:12:42 <Cale> * is not any kind, it's the kind of types which have values
00:12:55 <Cale> :k Integer
00:12:56 <lambdabot> *
00:12:59 <Cale> :k Char
00:13:00 <lambdabot> *
00:13:08 <Cale> :k Tree
00:13:09 <jTT_> quchen2 i think i got it. (also it seems it isn’t exactly the most important thing to worry about as a beginner?)
00:13:09 <lambdabot> * -> *
00:13:11 <Cale> :k Tree Integer
00:13:12 <lambdabot> *
00:13:40 <quchen2> jTT_: It's useful to have an idea what a kind is, but the code you posted didn't seem like beginner stuff at all.
00:13:49 <mercwithamouth> hi, i was wondering could someone explain 'step' offsets in functional programming? i'm a clojure guy but the channels dead right now. i'm assuming haskell has them as well or someone here is familiar
00:13:56 <Cale> jTT_: Yeah, don't worry about kinds too much, though they are pretty simple and worth understanding a bit.
00:13:56 <hyy> hi guys, where are some free Haskell books/resources?
00:14:24 <quchen2> jTT_: If you come back to the chapter about kinds in LYAH every couple of weeks when you need to know something that'll do.
00:14:28 <Cale> hyy: There's a series of lectures here which have been pretty popular lately http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
00:14:33 <Cale> @where lyah
00:14:33 <lambdabot> http://www.learnyouahaskell.com/
00:14:33 <jTT_> quchen2 i’m trying to get an idea what people can do with numerics and this seemed a promising article
00:14:37 <Cale> @where rwh
00:14:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:14:44 <Cale> ^^ there's a couple more books
00:14:53 <hyy> thanks
00:15:17 <hyy> how do you render a HTML document as a text-based PDF?
00:15:21 <jTT_> quchen2 Cale : right, cheers
00:15:26 <hyy> maybe that should be my little project
00:15:42 <quchen2> jTT_: And you can of course always crowdsource your questions here ;-)
00:15:58 <jTT_> hyy lyah is really good in my opinion
00:17:03 <Cale> hyy: There's something called Pandoc written in Haskell which might interest you
00:17:27 <jTT_> quchen2 haha now i feel guilty. it just seems to me that haskell should be great for numerical work that doesn’t have to be at the very very edge of performance. so i am trying to see what can be done esp wrt to linear algebra/matrix operations
00:18:55 <hyy> Cale: have you ever wanted to make an operating system or a video game before?
00:20:18 <mercwithamouth> forgive me...makes since with #s
00:23:12 <Cale> hyy: I've worked professionally on a video game, which sadly didn't get finished, but it was pretty fun working on it.
00:23:25 <liminalisht> :k Map
00:23:26 <lambdabot>     Not in scope: type constructor or class ‘Map’
00:23:26 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
00:23:37 <liminalisht> :t Map
00:23:38 <lambdabot>     Not in scope: data constructor ‘Map’
00:23:38 <lambdabot>     Perhaps you meant one of these:
00:23:38 <lambdabot>       variable ‘map’ (imported from Data.List),
00:23:49 <hyy> Cale: how would you make programming more fun for the beginning programmer that likes computers?
00:24:05 <hyy> I mean, it is fun discovering something new but more fun is always nice
00:24:27 <hyy> I know solving some of the 99 Haskell problems was fun
00:24:55 <Cale> hyy: That's an interesting question. It really depends on the person in question and what sorts of things they find interesting, and what their background in other areas is like.
00:26:23 <hyy> hmmz....what do I like?
00:27:09 <hyy> ok, well...first project would be an alarm clock to wake me up in the morning
00:27:23 <Cale> Yeah, making things that you'll find useful is always motivating :)
00:28:32 <hyy> also, if Linux ran on my iPad...I love Linux
00:28:53 <hyy> they said "Oh, that's imposssible. iOS is cryptographically signed"
00:29:27 <hyy> but is it really impossible if you replaced the NAND chip lol?
00:32:03 <hyy> if a bootloader attack was impossible I'd be angry and gift my iPad to somebody else
00:32:59 <nomeata> How is that a minor release? http://hdiff.luite.com/cgit/monoid-subclasses/commit/?id=164af8a90f79e0ea3c83ac2eef510ee65ffb99c1
00:33:49 <Ke> hyy: next time they will add expiration to the bootloader so you are going to have to update
00:34:07 <Ke> and re-root
00:34:39 <hyy> Ke: bwahahahah
00:35:05 <hyy> Apple sucks, they make the world's most proprietary tablets
00:35:13 <Cale> nomeata: All that's happening is one of the modules is being removed. Maybe it moved to a new package?
00:35:19 <hyy> besides BlackBerry's PlayBook
00:35:29 <nkaretnikov> hyy: how's this relevant to haskell?
00:35:44 <nkaretnikov> there's #haskell-blah for offtopic
00:37:06 <hyy> why can't GHC support dynamic libraries on Windows?
00:37:15 <hyy> that's relevant, no?
00:38:23 <ttt_fff> unless it's about porting haskell to the ipad, it's probably off topic
00:38:53 <hyy> ttt_fff: well erm...there's no way Haskell's gonna run on a jailbroken iPad, is there?
00:39:04 <ttt_fff> I don't know, and I don't care.
00:39:09 <ttt_fff> I'm pointing out what's on / off topic.
00:39:19 <hyy> ok, well...back to Haskell + Windows then?
00:40:05 <ttt_fff> type checking is sooo much easier when I can't ahve nested quantifiers
00:40:42 <nomeata> Cale: possibly, but it would still break applications using this module from this package
00:41:12 <nomeata> probably simply not PVP compilant, but no big deal, if noone used that module
00:41:13 <Cale> nomeata: Oh, you mean like "why didn't the version number change by a larger amount"
00:41:18 <nomeata> right
00:41:57 <Cale> new PVP: Every package is version 10
00:53:38 <lpaste_> SydneyHacker pasted “Mutany” at http://lpaste.net/137168
00:53:59 <sydneyhacker> Can anyone help me with the error I just pasted
00:54:21 <sydneyhacker> I am quite new to the forall and RankNTypes, so I am not sure how to resolve this one
00:56:00 <pharaun> Ok wow
00:56:02 <pharaun> i'm super stuck
00:56:11 <pharaun> how the heck do i get from Text to a ... Xml Node
00:56:41 <pharaun> Data.XML.Pickle seems to want Node type for pickling/unpickling
00:56:49 <pharaun> and all i got is ... Data.Text
00:56:56 <pharaun> and i'm finding *nothing* to convert between the two
00:57:33 <bergmark> sydneyhacker: try writing a type signature for mutaneer that declares `s'
00:58:05 <bergmark> pharaun: does this help? http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.3/docs/Text-Xml-Pickle.html
00:58:52 <pharaun> https://hackage.haskell.org/package/xml-picklers-0.3.6/docs/Data-XML-Pickle.html is the package i'm using
00:59:08 <pharaun> and it has a... t type and i can't find what it can ingest, as far as i can tell only strict text but
00:59:13 <pharaun> its not taking it
00:59:15 <sydneyhacker> I just tried 
00:59:15 <sydneyhacker> mutaneer :: ST s Int but same problem
00:59:16 <pharaun> bergmark: that's for hxt
01:00:37 <sydneyhacker> same with forall. but I think the forall. is implied right?
01:00:55 <pharaun> > Expected type: BL.ByteString -> Node
01:00:56 <lambdabot>  <hint>:1:10: parse error on input ‘type’
01:01:05 <pharaun> what the bloody hell
01:02:14 <pharaun> it really really really wants a Node type but i can't give it a Node type, and this unpickle thingy is supposed to be able to uh unpickle a tree
01:02:36 * hackagebot Southpaw 0.1.0.0 - Assorted utility modules  https://hackage.haskell.org/package/Southpaw-0.1.0.0 (SwiftsNamesake)
01:02:38 * hackagebot Southpaw 0.1.0.1 - Assorted utility modules  https://hackage.haskell.org/package/Southpaw-0.1.0.1 (SwiftsNamesake)
01:08:30 <mauke> pharaun: are you looking for an xml parser?
01:08:34 <pharaun> mauke: yes
01:08:42 <pharaun> one that can give me a 'Node'
01:08:49 <pharaun> https://hackage.haskell.org/package/xml-types-0.3.6/docs/Data-XML-Types.html#t:Node
01:09:31 <pharaun> this only defines the xml types, and Data.Xml.Pickle depends on this lib, but i can't find anything that can uh parse/get me from some sort of input (bytestring or text or whatever) to this amazing 'Node' thing
01:09:54 <pharaun> most of the stuff i'm finding like conduit/etc uses it internally but wrap it with their own event streaming interface/etc
01:11:59 <mauke> possible candidates: http://packdeps.haskellers.com/reverse/xml-types
01:12:09 <pharaun> yeah i've been poking at that list
01:12:29 <pharaun> most like for ex - http://hackage.haskell.org/package/xml-conduit - doesn't seem to directly (to me) expose a way for me to get the Node type
01:12:44 <pharaun> so i've been running in circles for a bit now :)
01:18:01 <pharaun> OverloadedStrings--
01:18:41 <pharaun> its able to magically convert string text -> node
01:18:46 <pharaun> yet i can't eugh
01:20:46 <verement> pharaun: not sure if it's the same type, but have you looked at hexpat's Text.XML.Expat.Tree.parse'?
01:21:10 <pharaun> looking
01:21:55 <verement> You'd have to do a utf8 encoding from Text, but that's easy
01:22:00 <pharaun> ya
01:22:13 <pharaun> yeah it uses a different Node type
01:22:18 <verement> ah ok
01:22:18 <pharaun> > type Node tag text = NodeG [] tag text 
01:22:19 <lambdabot>  <hint>:1:1: parse error on input ‘type’
01:22:35 <pharaun> (starting to dislike this data.xml.types package)
01:22:44 <pharaun> if there's no way to uh bloody parse to it
01:23:27 <pharaun> i mean there has to be a way, i'm just not seeing it
01:25:12 <pharaun> ok i found 2 project using xml-picklers let's see if i can figure out what their secret sauce is
01:31:38 <pharaun> hmm its using xml-conduit hmm
01:39:22 <ttt_ff> :t (\x -> \y -> length y)
01:39:23 <lambdabot> Foldable t => r -> t a -> Int
01:48:04 <ttt_fff> :t f x = \y -> x y
01:48:05 <lambdabot> parse error on input ‘=’
01:48:14 <ttt_fff> :t \x -> \y -> x y
01:48:15 <lambdabot> (r1 -> r) -> r1 -> r
01:50:44 <dot_asp> Hello. How do I rewrite this code so it has less whitespace in the left region, while retaining the case of? http://lpaste.net/7284310971202404352
01:54:57 <Axman6> dot_asp: check my annotation: http://lpaste.net/7284310971202404352
01:55:06 <Axman6> woah,. something went wrong there
01:55:30 <dot_asp> Thanks!
01:55:35 <Axman6> http://lpaste.net/137171
01:55:46 <dot_asp> I assume 1 -- yes
01:56:00 <Axman6> tabs are the root of all evil =)
01:56:01 <ttt_fff> is there a way I can do the equiv of "makeLenses" manually? (I want to reduce compile time), since I run ghc on every ":w" in vim
01:56:43 <Axman6> ttt_fff: they're pretty mechanical to write by hand (and doing so means you can avoid having a lens dependency at all)
01:56:55 <Intolerable> @hackage lens
01:56:55 <lambdabot> http://hackage.haskell.org/package/lens
01:56:58 <ttt_fff> Axman6: yeah, that's waht I thought; is there an example I can copy/paste/modify ?
01:57:05 <Intolerable> there's an example on the main lens page
01:57:08 <Intolerable> at the bottom
01:57:18 <Intolerable> "minimizing dependencies"
01:57:26 <ttt_fff> Axman6++
01:57:28 <ttt_fff> Intolerable++
01:57:51 <pharaun> god all of these xml parsers are streaming
01:58:14 <Axman6> dot_asp: your `return ()`'s are redundant by the way, putStrLn already has the type IO ()
01:58:32 <dot_asp> oh right
01:58:55 <Axman6> which means your second `do` is also redundant =)
01:59:02 <Axman6> _ -> putStrLn "NG"
01:59:46 <Axman6> you could also write: print =<< readFile ...; putStrLn "OK" (where ; would be a new line)
02:00:48 <dot_asp> :t (<<=)
02:00:49 <lambdabot>     Not in scope: ‘<<=’
02:00:49 <lambdabot>     Perhaps you meant one of these:
02:00:49 <lambdabot>       ‘<=’ (imported from Data.Ord), ‘<<<’ (imported from Control.Arrow),
02:01:03 <dot_asp> :t (=<<)
02:01:05 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:01:13 <Axman6> it's just flip (>>=)
02:01:27 <Axman6> tyou could also write readFile ... >>= print
02:01:41 <Axman6> (which is exactly what the code you've written desugars into)
02:04:43 <supki> pharaun: some, e.g. xml-conduit, have non-streaming interfaces too
02:09:44 <pharaun> supki: yeah i finally found it but xml-conduit is exporting its *own* special subset
02:09:47 <pharaun> of xml-types
02:09:59 <pharaun> which is breaking xml-pickle afaik
02:10:11 <pharaun> i'm still trying to puzzle out if i can make xml-pickle work with that instead of xml-types
02:11:24 <pharaun> ultimate experience of type tetris :)
02:16:15 <pharaun> ok i think i'm getting.... closer
02:18:32 <pharaun> supki: yeah ok, i can't use the non-streaming interface i don't think
02:18:46 <pharaun> it takes xml-type and modify and re-export the modified version
02:18:48 <pharaun> which screws me
02:19:06 <pharaun> time to copy and paste some code out of it :|
02:19:40 <pharaun> oh nifty, found hidden in a corner
02:19:44 <pharaun> some conversion bits
02:19:55 <supki> aren't there convertion functions in Text.XML?
02:20:03 <sdx23> removeDirectoryRecursive seems quite dangerous to me, following symlinks. Is there a recursive removal method that does not follow symlinks? I'm searching for the analogon to "rm -rf"
02:20:20 <pharaun> supki: yeah i found em, i'm tired its 2:20am and been frustrated with this for a while :)
02:20:30 <pharaun> finally noticed the conversion functions \o/
02:20:34 <pharaun> that will do the trick!
02:22:06 <pharaun> \o/
02:22:11 <pharaun> supki: yer my hero :p
02:22:16 <pharaun> it finally all typechecked
02:22:33 <pharaun> looks like i was able to parse the xml file finally
02:36:34 <sdx23> tests for a package I'm developing write to the filesystem. How would you recommend to ensure that no files already exist at the beginning of the test? As I understood cabal doesn't do any cleanup between "cabal test" runs.
02:38:26 <sdx23> I could have a "cleanup" testsuite that's run before all the others. Or try to delete files in each test.
02:39:38 <ttt_fff> what word means the same as 'render' but is shorter
02:39:41 <ttt_fff> 'draw'
02:39:46 <ttt_fff> can we go down to 3 chars or 2 chars?
02:39:48 <Intolerable> put
02:39:51 <ttt_fff> shorthand accepted
02:39:55 <ttt_fff> hmm, pt is used by StateT
02:40:01 <ttt_fff> *put* is used by StateT
02:40:26 <rhovland> do
02:40:38 <verement> blt (blit)
02:40:59 <ttt_fff> rhovland --
02:41:02 <ttt_fff> verment++
02:41:07 <ttt_fff> do ? do you use monads? :-)
02:41:28 <rhovland> go
02:42:13 <ttt_fff> > [ [x,y] | x <- ['a; .. 'z'], y <- ['a' .. 'z']]
02:42:13 <rhovland> I mean.. looking for 2-letter words that aren't taken?
02:42:15 <lambdabot>  <hint>:1:19: parse error on input ‘;’
02:42:26 <ttt_fff> > [ [x,y] | x <- ['a' .. 'z'], y <- ['a' .. 'z']]
02:42:28 <lambdabot>  ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao",...
02:42:34 <ttt_fff> damn it lambdabot
02:43:30 <ttt_fff> i thikn I should call it 'xxx' and make it hard for the next person to read the code
02:43:35 <Rizy> guys, mind if i asked very basic question, i just learn haskell yesterday and quite confusing on some logical syntax
02:44:00 <Intolerable> go for it
02:44:16 <rhovland> I use something like r0, if render is going to be modified
02:44:39 <Rizy> i follow upon lectures (week2) and got this syntax 
02:44:39 <Rizy> filter :: (a -> Bool) -> [a] -> [a]
02:44:57 <Rizy> i still got confused on (a -> Bool) things
02:45:13 <rhovland> function that takes a, and returns Bool
02:45:14 <Rizy> is a function that takes 1 argument and return Boolean, or what
02:45:28 <ttt_fff> rhovland what do you mean 'if render is going to be modified' ?
02:45:35 <Intolerable> yup, takes a single argument of type a and then returns a bool for it
02:46:09 <Rizy> so it means we don't care what is type of a at the moment right?
02:46:16 <Intolerable> nope
02:46:20 <Intolerable> it can be anything
02:46:37 <Intolerable> but all the "a"s have to be the same
02:46:54 <Rizy> the same with the other [a]?
02:46:54 <Intolerable> so in (a -> Bool) -> [a] -> [a] you can't choose different types for each a
02:46:59 <Rizy> i see
02:47:00 <Intolerable> they must all be the same type
02:47:37 <rhovland> ttt_fff: I mean, I tag args with 0 if they're going to be modified.. personal thing
02:47:54 <ttt_fff> rhovland: haskell is  apure lang, what do you mean by 'modified' ?
02:48:00 <Vomit_> Haskell #20 in IEEE Spectrum language ranking http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages (full ranking behind paywall, copy here http://pastebin.com/vxxSkfQ5 ) 
02:48:01 <Intolerable> i should start doing that rather than just' adding'' primes'''
02:48:57 <Vomit_> (paywall bypass = inspect HTML and delete "tp-overlay tp-reset" DIV) ;)
02:48:57 <Rizy> ok another one is fold :: (a -> b -> b) -> b -> [a] ->b
02:49:12 <Rizy> the (a -> b -> b) is just as the previous one?
02:49:21 <Rizy> takes 2 arguments, and result is b?
02:49:24 <Intolerable> yup
02:49:34 <Intolerable> it takes an "a" and a "b" and gives you back a "b"
02:49:51 <Intolerable> the "a" and "b" can be the same, but don't have to be
02:50:31 <Rizy> after we got back a "b", then that "b" is used as an argument for the rest of arrows or what>
02:50:55 <Intolerable> the "b"s in the type all must be the same
02:51:02 <Rizy> lets say we got back a "b" then the rest is -> b ->[a] -> b
02:51:51 <Intolerable> if the function you give is (Int -> String -> String), then fold gives you back a (String -> [Int] -> String)
02:52:00 <Intolerable> (for example)
02:52:49 <Intolerable> that make sense?
02:53:21 <Rizy> ok which is fold takes 2 argument, 1 is String from the function, 1 is the [Int] and the result is String?
02:53:51 <Intolerable> fold takes 3 arguments
02:53:53 <Rizy> 3 argument
02:54:05 <rhovland> foldl' is your friend
02:54:09 <Intolerable> the first is the combining function
02:54:23 <Intolerable> (so (Int -> String -> String) perhaps)
02:54:38 <Intolerable> the second is the starting element
02:54:44 <Intolerable> a String in this case
02:54:56 <Intolerable> the third is a list of Ints, which are going to be folded
02:55:15 <Rizy> i see
02:55:16 <Intolerable> and then it gives you back the final element
02:57:24 <rhovland> consider list=[1,2,3,4,5]
02:59:24 <rhovland> foldl' (\acc v->acc+v) 0 list -> 
02:59:58 <arianvp> i/win 5
03:00:03 <arianvp> heya
03:00:48 <rhovland> (same as sum $ list)
03:01:06 <Rizy> i see
03:01:29 <Rizy> thank you Intolerable and rhovland 
03:01:46 <Rizy> i think i must learn harder to understand haskell
03:01:50 <Rizy> :)
03:01:55 <Intolerable> you'll get the hang of it
03:02:55 <rhovland> it's fun
03:05:40 <rhovland> I was trying (before I gave up) to make a disjoint set forest using STRef  (in the end I stayed inside pure functional, so maybe it's ok)
03:06:28 <rhovland> but I mostly got confused trying to make data structures inside STRef
03:08:07 <rhovland> so, like, simple linked list.. how do you create a type, referring to itself, all inside a monad / ST?
03:09:33 <Rizy> hmmm hope someday i get it
03:09:35 <Rizy> :)
03:09:45 <verement> stick with it, it's worth it
03:11:03 <rhovland> oh, yeah, don't mind me, I think there's OK ways to do disjoint set
03:15:25 <danilo2> Hello! I've got a small lens-related question :) I want to build some funny lenses on top of Vectors package. They should be unsafe and read and put elements without bound checking. So I've got 2 functions right now: uncheckedGetIdx :: IndexType a -> a -> ElementOf a and uncheckedSetIdx :: (IndexType a) -> (ElementOf a) -> a -> a. How to combine them into a Lens like at or ix, but without the Maybes, because they are not needed here
03:15:29 <rhovland> what problems are definitely worse in haskell vs other languages? (I do haskell on hackerrank)
03:17:43 * hackagebot Southpaw 0.1.0.2 - Assorted utility modules  https://hackage.haskell.org/package/Southpaw-0.1.0.2 (SwiftsNamesake)
03:18:29 <guillaum1> I have a function :: StateT Something IO () and inside I want to pass the State to another function :: State Something ()
03:18:34 <rhovland> I think disjoint set / union-find, is definitely worse in haskell/functional. 
03:18:37 <guillaum1> how am I supposed to do that ?
03:19:05 <Intolerable> i.e. convert a State Something () into a StateT Something IO ()?
03:20:30 <rhovland> guillaum1: hrm.. I don't understand that function signature
03:21:02 <guillaum1> (Something is any type, for example a Float
03:21:38 <rhovland> what is "function"?
03:22:11 <Intolerable> :t StateT . (return .) . runState
03:22:12 <lambdabot> Monad m => State s a -> StateT s m a
03:22:27 <danilo2> Hello! I've got a small lens-related question :) I want to build some funny lenses on top of Vectors package. They should be unsafe and read and put elements without bound checking. So I've got 2 functions right now: uncheckedGetIdx :: IndexType a -> a -> ElementOf a and uncheckedSetIdx :: (IndexType a) -> (ElementOf a) -> a -> a. How to combine them into a Lens like at or ix, but without the Maybes, because they are not needed here
03:22:34 <guillaum1> Intolerable: thank you
03:22:53 <guillaum1> rhovland: function is a function name... Sorry ;)
03:26:18 <Rizy> how long you guys feel "i finally get it" in haskell? sometimes i smile by myself if solved on function logic.. :))
03:26:27 <Rizy> it feels like "i'm the man"
03:27:07 <guillaum1> Rizy: I read my first haskell tutorial 7 years ago ;) Since I writted a mine sweep game, a mandelbrot visualizer, a ray tracer, but I still don't understand anything ;)
03:28:32 <Rizy> but suddenly, it goes away when i see another function
03:28:42 <Rizy> whoa guillaum1 you're the man..
03:28:45 <Rizy> T_T
03:28:48 <rhovland> so many algorithms assume mutable, and doing it in haskell makes you think
03:30:02 <rhovland> and really, one awesome thing about using haskell, is you _know_ what is immutable vs not
03:30:53 <Intolerable> yeah i was writing a buildbot config yesterday
03:31:05 <Intolerable> that needs to be essentially immutable 
03:31:07 <rhovland> look at e.g. DLX dancing links.. or union-find... so many pointers getting swapped around!... 
03:31:18 <Intolerable> its in python so ofc u can't say "THIS SHOULD NOT DO IO"
03:32:00 <magistr> what is a category theory, which demands to learn haskell?
03:32:10 <rhaps0dy> http://clemens.endorphin.org/ILC07-Liskell-draft.pdf <- nice syntax
03:32:18 <rhaps0dy> magistr: what do you mean?
03:32:27 <rhovland> magistr: cat theory isn't bad
03:33:22 <Philonous> pharaun, I use xml-conduit to parse xml-types style xml. I'm not sure there's another package.
03:33:23 <magistr> rhovland, to learn Haskell, I must know category theory?
03:33:24 <rhovland> I tried to learn some category theory... so far the smullyan book about birds is better
03:33:32 <silver> magistr, no, not at all
03:33:37 <rhovland> magistr: no...
03:33:56 <Philonous> pharaun, Before that I had my home-grown solution involving expat
03:34:46 <rhovland> magistr: but ifyou want to know why some weird thing works, you may need to know some category theory
03:35:38 <kuribas> I am trying to solve the exercises from http://artyom.me/lens-over-tea-1
03:35:47 <kuribas> I have: (<%~) :: Lens s t a b -> (a -> b) -> s -> (b, t); (<%~) l f s = l (\a -> (f a, f a)) s
03:35:50 <kuribas>  
03:35:53 <kuribas> How to write it pointlessly?
03:35:59 <kuribas> @pl (\a -> (f a, f a))
03:35:59 <lambdabot> liftM2 (,) f f
03:36:20 <rhovland> ack
03:36:29 <Intolerable> @pl \ l f s -> l (\a -> (f a, f a)) s
03:36:29 <lambdabot> (. (ap =<< ((,) .)))
03:36:45 <Intolerable> (internal screaming)
03:36:46 <kuribas> yikes
03:36:54 <magistr> ok, How to learn Haskell?
03:37:16 <Intolerable> magistr: how much do you already know re: programming / haskell
03:37:20 <kuribas> magistr: read a book, try the exercises, come to irc when stuck :-)
03:37:21 <rhovland> kurbas: what exercise in particular?
03:37:23 <Intolerable> do you know any other languages?
03:37:44 <kuribas> rhovland: under "Test Yourself"
03:38:26 <magistr> kuribas, whats book?
03:38:38 <kuribas> I would consider using the Reader Monad deliberate obfuscation :)
03:38:46 <rhovland> kuribas: what are you trying to do?
03:38:56 <kuribas> magistr: I read and like Real World Haskell a lot, but it is a bit outdated now.
03:39:13 <kuribas> rhovland: get the bonus points :)
03:40:42 <kuribas> I got them, but I actually prefer the lambda.  Maybe there is a more elegant pointless solution...
03:42:18 <rhovland> I mean, I use lens to handle input, mostly
03:42:47 <kuribas> magistr: I heard good things about LYAH: http://learnyouahaskell.com/
03:43:37 <kuribas> rhovland: oh, I was just reading the article out of interest, to get a better understanding of the advanced lens side.
03:43:39 <Rizy> magistr, i think you can go to the upend CIS194 about haskell, it has good lecture there
03:43:52 <Rizy> 14 weeks, each weeks has assignment and also reference
03:44:11 <Rizy> and you can start reading the LYAH and Real World Haskell
03:44:31 <Rizy> well for now i am enjoying cis194..
03:44:59 <kuribas> magistr: also #haskell-beginners
03:45:01 <Rizy> but tryhaskell.org is quite helpful for first time
03:45:02 <rhovland> kuribas: lens is awesome for messing with things inside a structure
03:46:17 <kuribas> rhovland: yeah.  But it seems there is more to lens than just update a field of a structure, so that's why the article looks interesting.
03:48:09 <magistr> kuribas, ok, thanks
03:50:17 <indiagreen> kuribas: what's your solution?
03:50:55 <krokodil> Hello! Is there a `stack` tutorial for a complete newbie somewhere out there?
03:51:26 <krokodil> I did `stack new`. How do I tell my newly-created project, that `reactive-banana` is supposed to be my dependency?
03:51:58 <rhovland> is that spam?
03:52:24 <magistr> ./join #haskell-beginners
03:52:53 <frerich> I don't understand why people promote #haskell-beginners all the time, in my experience this channel is perfectly fine for beginner questions.
03:53:31 <rhovland> never heard of `stack` etc
03:53:52 <indiagreen> rhovland: stack has been a thing for maybe a month by now
03:54:24 <indiagreen> rhovland: https://github.com/commercialhaskell/stack
03:54:45 <rhovland> indiagreen: ty.. hm
03:55:12 <kuribas> indiagreen: the bonus one?
03:55:30 <indiagreen> kuribas: yep (for <%~)
03:55:43 <LambdaAnt> @help
03:55:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:55:49 <LambdaAnt> @list
03:55:50 <lambdabot> What module?  Try @listmodules for some ideas.
03:55:56 <LambdaAnt> @listmodules
03:55:56 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
03:56:06 <LambdaAnt> @unlambda
03:56:06 <lambdabot>   unlambda: Parse error at end of file
03:56:10 <LambdaAnt> Ooh
03:56:15 <kuribas> indiagreen: (<%~) l f s = l (liftM (,) f f) s
03:56:15 <LambdaAnt> That's fancy
03:56:42 <LambdaAnt> What's the type signature there?
03:57:08 <LambdaAnt> Oop, impossible.
03:57:18 <indiagreen> kuribas: okay, yeah, that's pretty close
03:57:20 <LambdaAnt> @karma
03:57:20 <lambdabot> You have a karma of 0
03:57:26 <LambdaAnt> @free
03:57:26 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
03:57:35 <indiagreen> the intended solution was “(<%~) l f = l ((,) <$> f <*> f)”
03:57:35 <kuribas> indiagreen: what do you have?
03:58:07 <kuribas> indiagreen: are you the author?
03:58:31 <kuribas> I cheated though, I used lambdabot :)
03:58:31 <indiagreen> yep
03:59:05 <LambdaAnt> You can reduce by hand without much difficulty, actually.
03:59:09 <kuribas> indiagreen: great article, thanks!
04:00:11 <krokodil> OK, a simpler question, what's the difference between `new-template.cabal` and `stack.yaml`?
04:00:21 <krokodil> Which one should I use on a day-to-day basis?
04:00:31 <kuribas> indiagreen: Though I prefer the lambda though.
04:01:59 <indiagreen> kuribas: yeah, but gotta award bonus points for *something*
04:02:05 <LambdaAnt> preflex: kuribas++
04:02:09 <LambdaAnt> @karma
04:02:09 <lambdabot> You have a karma of 0
04:02:31 <indiagreen> LambdaAnt: what are you doing?
04:02:36 <indiagreen> there's no preflex in this channel
04:02:45 * hackagebot tidal 0.5.1 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.5.1 (AlexMcLean)
04:02:56 <LambdaAnt> First time, just muching around :P
04:02:56 <indiagreen> and if you want to know kuribas's karma, write “@karma kuribas”
04:03:11 <LambdaAnt> *ck
04:03:16 <indiagreen> and if you want to give kuribas a point, just write “kuribas++” without preflex
04:03:33 <kuribas> indiagreen++
04:03:33 <LambdaAnt> Thanks, that's helpful actually.
04:03:37 <LambdaAnt> haha
04:03:42 <LambdaAnt> @karma indiagreen
04:03:42 <lambdabot> indiagreen has a karma of 6
04:03:49 <indiagreen> yay, sweet karma
04:03:51 <LambdaAnt> indiagreen++
04:04:02 <LambdaAnt> \join #haskell.jp
04:04:02 <kuribas> @karma indiagreen
04:04:02 <lambdabot> indiagreen has a karma of 7
04:04:10 <LambdaAnt> Ah backslashed.
04:04:12 <rhovland> wait, lambda isn't a bot?
04:04:26 <indiagreen> rhovland: lambdabot is a bot
04:10:41 <wedens> should I use prism' to create Prism' from Maybe?
04:11:50 <pacak> :t _Maybe
04:11:51 <lambdabot>     Found hole ‘_Maybe’ with type: t
04:11:52 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
04:11:52 <lambdabot>                the inferred type of it :: t at Top level
04:11:58 <pacak> :t _Just
04:11:59 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
04:12:06 <pacak> :t _Nothing
04:12:08 <lambdabot> (Applicative f, Choice p) => p () (f ()) -> p (Maybe a) (f (Maybe a))
04:12:14 <pacak> wedens: What's wrong with those?
04:12:59 <wedens> I mean from (a -> Maybe a)
04:13:24 <pacak> o_O
04:14:00 <indiagreen> wedens: yep, use prism' if you don't need type-changing
04:14:22 <wedens> pacak: what surprises you?
04:14:25 <Aejay> @help
04:14:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:14:32 <Aejay> @help unlambda
04:14:32 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
04:15:27 <wedens> indiagreen: with identity function I suppose?
04:15:52 <Aejay> @unlambda ```````````.h.e.l.l.o.w.o.r.l.di
04:15:52 <lambdabot>   unlambda: Parse error at end of file
04:15:56 <Aejay> @unlambda ``````````.h.e.l.l.o.w.o.r.l.di
04:15:56 <lambdabot>   helloworld
04:16:17 <Aejay> @unlambda ```````````.h.e.l.l.o. .w.o.r.l.di
04:16:17 <lambdabot>   hello world
04:16:33 <wedens> > let f a = if a > 5 then Just a else Nothing
04:16:34 <lambdabot>  <no location info>:
04:16:35 <lambdabot>      not an expression: ‘let f a = if a > 5 then Just a else Nothing’
04:17:01 <indiagreen> wedens: well, probably “id”. What prism are you trying to write?
04:17:08 <Aejay> > (\a -> if a > 5 then Just a else Nothing)
04:17:10 <lambdabot>  <Integer -> Maybe Integer>
04:17:14 <Aejay> > (\a -> if a > 5 then Just a else Nothing) 6
04:17:16 <lambdabot>  Just 6
04:17:21 <Aejay> > (\a -> if a > 5 then Just a else Nothing) 1
04:17:22 <lambdabot>  Nothing
04:17:29 <pacak> wedens: trying to imagine that (at the same time trying to figure out how to apply rewrite RULES to generics)
04:17:49 <Aejay> @pointfree \p a -> if p a then Just a else Nothing
04:17:49 <lambdabot> Unknown command, try @list
04:17:54 <Aejay> @list
04:17:54 <lambdabot> What module?  Try @listmodules for some ideas.
04:18:00 <Intolerable> @pl \p a -> if p a then Just a else Nothing
04:18:00 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
04:18:01 <Aejay> @list pointfree
04:18:01 <lambdabot> No module "pointfree" loaded
04:18:08 <Aejay> Ah thx
04:18:28 <Aejay> > flip flip
04:18:30 <lambdabot>      No instance for (Typeable a0)
04:18:30 <lambdabot>        arising from a use of ‘show_M58865192201409132283873’
04:18:31 <lambdabot>      In the expression:
04:18:46 <Aejay> @type
04:18:46 <lambdabot> <no location info>: not an expression: ‘’
04:18:50 <Intolerable> :t flip flip
04:18:51 <lambdabot> b -> (a -> b -> c) -> a -> c
04:18:53 <Aejay> @type flip flip
04:18:54 <lambdabot> b -> (a -> b -> c) -> a -> c
04:19:10 <Nux__> What's happening here? I run my code (http://lpaste.net/137181) in ghci and get an error message (http://lpaste.net/137182)
04:20:06 <Intolerable> instance resolution only checks the head
04:20:09 <Nux__> I'm guessing this has something to do with how print is implemented
04:20:17 <Intolerable> wait
04:20:22 <Aejay> instance (Container c, Show a) => Show (c a)
04:20:22 <wedens> :t prism' id $ (\x -> if x > 5 then Just x else Nothing)
04:20:24 <lambdabot> (Num a, Ord a, Applicative f, Choice p) => p a (f a) -> p a (f a)
04:20:37 <Aejay> Not gonna happen: instance (Container c, Show a) => Show (c a)
04:20:44 <Intolerable> yeah GHC is only checking the "a"
04:20:46 <Aejay> Container could be a []
04:20:54 <wedens> indiagreen pacak: its'a prism for zipper
04:20:54 <Aejay> and a string is a [] Char
04:20:55 <lyxia> Nux__: Show is already implemented for lists, and you just defined yet another instance.
04:20:59 <Intolerable> and they both have "a"
04:21:03 <Aejay> lyxia++
04:21:21 <Nux__> wait
04:21:30 <Nux__> is there already a Container class?
04:21:34 <Aejay> Basically, you've defined two ways of showing a string.
04:21:43 <Intolerable> no, but [] could be an instance of Container
04:21:49 <Intolerable> so GHC can't resolve it
04:22:04 <Aejay> Intolerable++
04:22:10 <Nux__> I thought I had to explicitly declare the instances of my class
04:22:11 <narendraj9> Is import (TypeClass) useful for anything? As it only imports the name of the typeclass it seems.
04:22:22 <Intolerable> it imports instances
04:22:51 <Nux__> I'm not sure what that means
04:22:53 <Intolerable> and of course it imports the name of the typeclass
04:23:00 <Intolerable> which is sometimes useful
04:23:02 <narendraj9> Intolerable: But the methods cannot be called on the instances. Can they be?
04:23:11 <narendraj9> Intolerable: I am getting a function not visible error.
04:23:16 <Intolerable> nope, but you might be calling them from other modules
04:23:26 <Aejay> You need to import (Typeclass(..))
04:23:34 <Intolerable> and you might need to import the typeclass for a type signature
04:23:42 <Aejay> (..) includes the definitions.
04:23:46 <Intolerable> if you need whats in the class, do as Aejay
04:23:58 <lyxia> importing just the type class name allows you to write more type signatures.
04:24:03 <indiagreen> wedens: if your “a -> Maybe a” function changes “a”, then you need a function that would reverse the transformation
04:24:04 <narendraj9> Aejay: I know that. I am asking what it is used for.
04:24:19 <Intolerable> Nux_: it means that in the future something else could define the Container [] instance, at which point your code would be broken
04:24:33 <Aejay> narendraj9: Importing all the methods defined in a typeclass
04:24:40 <Nux__> Intolerable, oh
04:25:08 <wedens> indiagreen: I see. thanks. I don't need contramap on a. 
04:25:11 <Intolerable> since GHC can't show that noone will ever define that instance (which of course is impossible), it gives that error
04:25:23 <Nux__> Intolerable, I see
04:25:26 <narendraj9> What would the instances be used for if I cannot call the class methods on them?
04:25:33 <Nux__> Intolerable, thanks
04:25:49 <Intolerable> some other module might call the actual methods
04:25:56 <Aejay> narendraj9: Nothing that I can think of."
04:26:06 <Nux__> I have another question, how do you make a polymorphic type an instance of a class?
04:26:07 <Intolerable> you might have a function (f :: Show a -> Int) in module A
04:26:13 <narendraj9> Aejay: So, why isn't importing the methods the default?
04:26:37 <Intolerable> then import A from module B and have a function g x = f x * 2
04:26:57 <Intolerable> where g :: (Show a) => a -> Int
04:27:00 <Intolerable> but never calls show
04:27:04 <Aejay> narendraj9: If I'm honest, I don't know. You may want to only import specific methods, or maybe just import it to resolve a superclass conflict.
04:27:21 <Nux__> By which I mean: rather than concrete instances of the polymorphic type being instances of the class, how do you make the polymorphic type itself an instance?
04:27:32 <Nux__> Prelude seems to do this with Num for example
04:27:41 <Intolerable> how do you mean?
04:27:55 <Intolerable> you're either going to get into awkward mechanisms here
04:27:57 <Intolerable> or have to newtype it
04:28:08 <Nux__> I can evaluate '2' with ghci and it will print it without consideration for what Num instance it is
04:28:29 <Aejay> Nux__: That's just builtin GHCi stuff.
04:28:44 <Aejay> It defaults to Integer, I think.
04:28:44 <Intolerable> and that isn't quite the same
04:28:45 <indiagreen> Nux__: Haskell has a bit of defaulting
04:28:54 <indiagreen> and GHCi has a bit more of defaulting
04:29:03 <Intolerable> because print :: (Show a, Num a) => a -> IO () for that 
04:29:04 <Nux__> ah ok
04:29:16 <narendraj9> Aejay: Okay. I see. I think importing specific methods make a little sense to me.
04:29:22 <narendraj9> *makes
04:29:37 <narendraj9> I mean it can be one of the reasons.
04:29:42 <Aejay> narendraj9: Tell me if you think of a really good use, though.
04:29:47 <Intolerable> narendraj9: i'll sometimes import the class name unqualified and the methods qualified
04:30:03 <Intolerable> import Data.Foldable (Foldable)
04:30:06 <narendraj9> Aejay: Sorry. A badly formed sentence.
04:30:16 <Intolerable> import qualified Data.Foldable (Foldable(..)) as Foldable
04:30:20 <Aejay> Intolerable: Oooh that's a good use!
04:30:30 <Intolerable> not with foldable tbh 
04:30:32 <Intolerable> but with other stuff
04:30:38 <Aejay> I see!
04:30:43 <Intolerable> i do that a lot with types too
04:30:47 <Intolerable> import the type name unqualified
04:30:52 <Intolerable> and then qualified import everything else
04:30:57 <Aejay> That makes making instances *much* easier!
04:31:20 <narendraj9> Okay. I see.
04:31:24 <Aejay> So, like in Data.Text, you'll import the type unqualified?
04:31:32 <Aejay> But the functions qualified?
04:32:05 <Intolerable> https://github.com/intolerable/api-builder/blob/master/src/Network/API/Builder/Query.hs
04:32:35 <Intolerable> that way you avoid Text.Text in type signatures
04:32:40 <Aejay> Wonderful!
04:32:49 <Intolerable> but don't get ambiguity in definitions
04:33:10 <narendraj9> Cool!
04:33:11 <Aejay> That's so useful.
04:33:41 <narendraj9> So, it helps keeping the types clean. 
04:34:00 <narendraj9> short, I mean. 
04:34:06 <narendraj9> Aejay: Intolerable: Thanks! :) 
04:34:17 <Intolerable> np!
04:34:22 <Aejay> No problem, that was interesting!
04:35:33 <Aejay> @djinn ((a -> b) -> b) -> a -> b
04:35:33 <lambdabot> -- f cannot be realized.
04:35:54 <Aejay> @djinn (a -> b) -> a -> b
04:35:55 <lambdabot> f a = a
04:36:15 <int-e> @djinn (((a -> b) -> b) -> b) -> a -> b
04:36:15 <lambdabot> f a b = a (\ c -> c b)
04:37:11 <Nux__> I'm interested why GHC can't see that this is always well defined: http://lpaste.net/137183
04:37:46 <Aejay> @djinn ((a -> b) -> b) -> (q -> (a -> c) -> c) -> (a -> c) -> c
04:37:46 <lambdabot> -- f cannot be realized.
04:37:54 <Aejay> @djinn ((a -> b) -> b) -> (b -> (a -> c) -> c) -> (a -> c) -> c
04:37:54 <lambdabot> -- f cannot be realized.
04:37:59 <Nux__> evaluating "show thing"
04:38:08 <int-e> Nux__: type classes are open; somebody might later add an  instance Thing (a -> b)
04:38:34 <int-e> Nux__: sorry, wait
04:38:39 <int-e> Nux__: what is the actual error?
04:38:47 <Aejay> Nux__: All typeclass definitions must be of the form Class Data a b c
04:39:00 <Nux__> http://lpaste.net/137184
04:39:20 <Intolerable> do it outside of GHC
04:39:22 <Intolerable> *GHCi
04:39:24 <Nux__> I've used the appropriate extensions to avoid that
04:39:30 <Nux__> ok
04:39:31 <JagaJaga> I have a list generator like [x | x <- [a,b,c,d] ], but is there a way to get an element before current? I mean if I have `b`, I need a``.
04:39:48 <Intolerable> x `zip` tail x
04:40:12 <Intolerable> let x = [1,2,3,4] in x `zip` tail x
04:40:18 <Intolerable> > let x = [1,2,3,4] in x `zip` tail x
04:40:19 <lambdabot>  [(1,2),(2,3),(3,4)]
04:40:45 <krokodil> Can somebody please explain the difference between `new-template.cabal` and `stack.yaml`? And which one should I use to specify dependencies and everything?
04:40:52 <JagaJaga> Intolerable: Got your idea. Thank you!
04:41:01 <Aejay> > let x = [1..10] in zipWith (+) x (tail x)
04:41:02 <lambdabot>  [3,5,7,9,11,13,15,17,19]
04:41:33 <Intolerable> Nux__: did you read this? https://downloads.haskell.org/~ghc/7.0.4/docs/html/users_guide/type-class-extensions.html#instance-decls
04:42:12 <int-e> Nux__: at the point where you add OverlappingInstances, ghc cannot rule out that a more specific instance (instance Show (Thing First) where show _ = "ActuallyThisIsAFirstThing") will come around later; at the very least it becomes very tricky.
04:42:44 <Intolerable> Nux__: you can also just define instance Show First
04:42:49 <Intolerable> which breaks the typechecker
04:43:15 * int-e is unsure about the precise rules (I avoid OverlappingInstances if at all possible, but there are people who like them...)
04:43:23 <Intolerable> check out: http://stackoverflow.com/questions/7198907/haskell-constraint-is-no-smaller-than-the-instance-head
04:43:28 <Intolerable> which is exactly your problem
04:43:42 <Aejay> "Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need. - Dons"
04:43:51 <Nux__> http://lpaste.net/137186 http://lpaste.net/137187
04:44:18 <Nux__> ok now to read all that
04:44:29 <Intolerable> yup, you're getting overlapping instances because you have "instance a where"
04:44:39 <Intolerable> which matches literally every type
04:45:03 <Intolerable> GHC tries to find a matching type, then checks the constraint
04:46:31 <Nux__> and because someone might make an instance in the future, it only check that the constraint is _possibly_ satisfied?
04:47:00 <Intolerable> no, it's because you've said "I can provide a Show instance for any type"
04:47:08 <Intolerable> since GHC only checks the instance head
04:48:20 <Intolerable> what you want is a Thingy newtype
04:48:37 <Intolerable> with an instance (Thing a) => Show (Thing a)
04:48:48 <Intolerable> *instance (Thing a) => Show (Thingy a)
04:48:51 <Intolerable> rather
04:49:40 <Nux__> I'll have to read over this a few times before I understand what's wrong exactly
04:50:16 <int-e> Nux__: right. As ghc will tell you, IncoherentInstances will allow ghc to actually pick your instance, but only if the instances that it overlaps with were also declared incoherent, and that's not the case.
04:50:22 <Intolerable> yeah typeclass resolution is something that takes a while to click
04:52:09 <int-e> However, IncoherentInstances is firmly in the domain of evil language extensions in my view; moving functions around or inlining can change the behaviour of the program, and even the compiler optimizations can affect the result.
04:52:48 * hackagebot engine-io-wai 1.0.1 -   https://hackage.haskell.org/package/engine-io-wai-1.0.1 (codedmart)
04:52:50 * hackagebot second-transfer 0.6.0.0 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.6.0.0 (dsign)
04:54:13 <JagaJaga> @hoogle m [m a] -> m [a]
04:54:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:54:13 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:54:13 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
04:54:39 <JagaJaga> @source sequence
04:54:39 <lambdabot> Unknown command, try @list
04:55:04 <int-e> @src sequence
04:55:04 <lambdabot> sequence []     = return []
04:55:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:55:07 <lambdabot> --OR
04:55:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:55:23 <JagaJaga> int-e: thank you.
04:58:08 <Aejay> :t sequence (undefined :: Monad m => m [m Int])
04:58:09 <lambdabot> (Monad t, Traversable t) => [t (t Int)]
04:58:39 <Aejay> :t sequenceA (undefined :: Monad m => m [m Int])
04:58:40 <lambdabot> (Monad t, Traversable t) => [t (t Int)]
04:58:59 <Aejay> @src filterM
04:58:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:59:25 <Aejay> :t filerM
04:59:26 <lambdabot>     Not in scope: ‘filerM’
04:59:26 <lambdabot>     Perhaps you meant one of these:
04:59:26 <lambdabot>       ‘filterM’ (imported from Control.Monad.Writer),
04:59:31 <Aejay> :t filterM
04:59:32 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
04:59:37 <ttt_fff> http://www.fileformat.info/info/unicode/category/So/list.htm is valid for haskell operator (i.e. infix operators) right?
04:59:45 <ttt_fff> which means I can use chinese verb characters as infix operators?
04:59:49 <ttt_fff> this'd be so badass
05:00:00 <Aejay> ttt_fff: Yes.
05:00:03 <Aejay> You can
05:00:17 <ttt_fff> will using unicode chinese character for infix operators piss off people?
05:00:21 <Aejay> > let あい k = k
05:00:23 <lambdabot>  <no location info>: not an expression: ‘let あい k = k’
05:00:32 <Aejay> > let あい k = k in 愛6
05:00:35 <lambdabot>      Not in scope: ‘愛6’
05:00:35 <lambdabot>      Perhaps you meant ‘_6’ (imported from Control.Lens)
05:00:38 <Aejay> > let あい k = k in 愛 6
05:00:40 <lambdabot>  Not in scope: ‘愛’
05:00:47 <Aejay> > let 愛 k = k in 愛 6
05:00:49 <lambdabot>  6
05:00:50 <ttt_fff> HAHA
05:00:56 <ttt_fff> this is amazing
05:00:59 <Aejay> Ikr
05:01:09 <ttt_fff> someday, another engineer will read my code, and I will be murdered
05:01:12 <Aejay> You can also use unicode characters as infixes.
05:01:13 <Intolerable> it's alphanumeric though?
05:01:20 <Intolerable> so it isn't infix
05:01:30 <ttt_fff> http://www.fileformat.info/info/unicode/category/So/list.htm is 'symbol' category
05:01:30 <Intolerable> (i dont know chinese)
05:01:32 <maerwald> ttt_fff: yes, it's as annoying as russian comments in code
05:01:35 <maerwald> (almost)
05:01:41 <Nux__> by the way, all I'm doing is playing at the moment, trying to learn about the limits of the language along with it's recommended use
05:01:51 <ttt_fff> well, I think russian comments is easier to grep for then single chinese characters
05:02:07 <Aejay> > let (⤇) = (>>=) in [1,2,3] ⤇ return
05:02:08 <lambdabot>  [1,2,3]
05:02:20 <ttt_fff> this is so deliciously evil
05:02:30 <ttt_fff> i'm a terible person
05:02:32 <Aejay> It's awesome though.
05:02:36 <Aejay> <3
05:02:47 <Intolerable> :t (\f -> f) :: a → a
05:02:48 <lambdabot> a -> a
05:02:55 <maerwald> it is just annoying
05:02:56 <ttt_fff> yeah, the ghc people were like "perl has ascii art? watch what we can do with infix unicode chars"
05:03:15 <ttt_fff> (agreeing wigh aejay, not maerwald)
05:03:39 <Intolerable> > let f 💩 = 💩 in f "🔘"
05:03:39 <maerwald> it is a reason to not contribute to a project
05:03:40 <lambdabot>  <hint>:1:9: parse error on input ‘=’
05:03:49 <Aejay> Intolerable: Wut??
05:04:27 <Aejay> > let f ❤️ = ❤️ in f 6
05:04:28 <lambdabot>  <hint>:1:8: lexical error at character '\65039'
05:04:38 <Aejay> Darn.
05:04:38 <Intolerable> (\f 💩 → 💩 ) "👬"
05:04:44 <Intolerable> > (\f 💩 → 💩 ) "👬"
05:04:46 <lambdabot>  <hint>:1:5: parse error on input ‘💩’
05:04:49 <Intolerable> heh
05:04:54 <Intolerable> lambdabot said 💩
05:05:18 <Nux__> :D
05:05:19 <ttt_fff> Intolerable: your 💩 code samples in trying to use 💩 as a variable name appears to be 💩
05:05:28 <Aejay> > (\心 -> 心) "やはっぉおお！"
05:05:30 <lambdabot>  "\12420\12399\12387\12361\12362\12362\65281"
05:07:17 <Aejay>  This is so ridiculous... what are we doing...
05:07:27 <Intolerable> does anyone actually seriously use unicode syntax?
05:07:36 <Intolerable> i know some people use alpha / beta / etc
05:07:45 <indiagreen> Intolerable: at one point I was using → extensively
05:07:46 <Aejay> Intolerable: I've done it before, when I was trying to redefine a few things.
05:08:01 <indiagreen> I was also using “$/” instead of “<$>”
05:08:05 <indiagreen> it wasn't the best decision
05:08:33 <Intolerable> yeah i tried using → etc
05:08:47 <Intolerable> but then noone can edit your code w/o hassle
05:08:51 <Aejay> Something I like to do is use greek characters in type signatures.
05:09:01 <Intolerable> ligatures seem a nice alternative
05:09:13 <maerwald> yes, it's a great technique to keep collaborators off
05:09:17 <Intolerable> yeah that's the one thing i see people use unicode names for 
05:09:20 <indiagreen> maerwald++
05:09:38 <demize> > let ʕᐧᴥᐧʔ = "panda"
05:09:39 <lambdabot>  <no location info>: not an expression: ‘let ʕᐧᴥᐧʔ = "panda"’
05:10:06 <Intolerable> > let ʕᐧᴥᐧʔ = "panda" in ʕᐧᴥᐧʔ
05:10:07 <lambdabot>  "panda"
05:10:09 <Intolerable> aww
05:10:16 <demize> ^_^
05:10:35 <demize> (It took me quite a while to find those middle dots that work as identifiers.
05:10:38 <demize> )
05:10:51 <Intolerable> most of them are symbols right?
05:10:57 <demize> Yeah
05:11:07 <Intolerable> put them as (++)
05:11:09 <demize> All chars in that identifier are letters though.
05:11:29 <Cale> That is clearly a koala
05:11:30 <Aejay> maerwald++
05:11:31 <Intolerable> and then have ʕ = "pa", ᴥ = "n", ʔ = "da"
05:11:34 <demize> Well that's just not the same, they pandas get claustrophobic!
05:11:40 <demize> Cale: nou
05:11:48 <Aejay> That's both evil and hilarious simeltaneously.
05:11:53 <demize> Intolerable: That would feel weird.
05:12:03 <demize> Anyway, I think the prelude totally needs a panda literaly.
05:12:05 <demize> literal*
05:12:15 <Intolerable> @hackage acme-lookofdisapproval
05:12:16 <lambdabot> http://hackage.haskell.org/package/acme-lookofdisapproval
05:12:49 * hackagebot reflex-gloss 0.1.0.2 - An reflex interface for gloss.  https://hackage.haskell.org/package/reflex-gloss-0.1.0.2 (jeffreyrosenbluth)
05:13:08 <Aejay> ...eh?
05:13:19 <Aejay> "acme-lookofdisapproval
05:13:34 <Aejay> I comprehend not.
05:13:35 <demize> Haha, awesome.
05:13:35 <ttt_fff> why i slookup: k -> Map k v -> v
05:13:35 <Intolerable> it's a handy function for when you want to error
05:13:47 <demize> Aejay: Makes ಠ_ಠ call error ;p
05:13:54 <Intolerable> but you're disgusted at bottom
05:13:55 <ttt_fff> why is "lookup : k -> Map k v -> Maybe v" but "(!) : Map k v -> k -> Maybe v" ?
05:14:00 <Aejay> demize: I WANT IT.
05:14:10 <Aejay> Cabal, cabal, cabal!
05:14:14 <Intolerable> ttt_fff: because one is designed for infix
05:14:15 <demize> Aejay: Well, you just need `ಠ_ಠ = error` so. ;)
05:14:25 <ttt_fff> Intolerable: yeah, so why is order flipped
05:14:32 <Intolerable> Map.empty ! "wat" vs lookup "wat" Map.empty
05:14:35 <ttt_fff> > let ಠ_ಠ = 1 in ಠ_ಠ 
05:14:37 <lambdabot>  1
05:14:51 <ttt_fff> why is ಠ_ಠ  varname rather than infix?
05:15:00 <Intolerable> because infix access is typically "container ! index"
05:15:06 <Intolerable> ಠ is a letter
05:15:12 <Aejay> > let ಠ_ಠ = error in ಠ_ಠ "You dun mucked up, you."
05:15:14 <lambdabot>  *Exception: You dun mucked up, you.
05:15:51 <demize> That should also be in the prelude *nods*
05:16:04 <ttt_fff> let (╯°□°）╯ x = error x in (╯°□°）╯ "exception"
05:16:11 <ttt_fff> > let (╯°□°）╯ x = error x in (╯°□°）╯ "exception"
05:16:12 <lambdabot>  <hint>:1:10: lexical error at character '\65289'
05:16:21 <ttt_fff> fuck; how do we fix this?
05:16:26 <Intolerable> ( is not a letter
05:17:18 <ttt_fff> let ʕノ•ᴥ•ʔノ = error in ʕノ•ᴥ•ʔノ "cute exception"
05:17:21 <Aejay> "Installed acme-lookofdisapproval-0.1"
05:17:24 <ttt_fff> > let ʕノ•ᴥ•ʔノ = error in ʕノ•ᴥ•ʔノ "cute exception"
05:17:25 <lambdabot>  <hint>:1:5: Parse error in pattern: ʕノ `•` ᴥ
05:17:27 <Aejay> Aw yeah.
05:17:36 <ttt_fff> > let ʕノ•ᴥ•ʔノ = error in ʕノ•ᴥ•ʔノ "cute exception"
05:17:37 <lambdabot>  <hint>:1:5: Parse error in pattern: ʕノ `•` ᴥ
05:17:49 <ttt_fff> how did lambdabot return a different ascii face ?
05:17:49 * hackagebot fast-builder 0.0.0.0 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.0 (AkioTakano)
05:18:03 <Intolerable> unicode is hard
05:18:09 <Aejay> Yup
05:18:22 <Aejay> It's better than ASCII though.
05:18:34 <Aejay> *GRIN*
05:18:50 <ttt_fff> let ༼∩☉ل͜☉༽⊃━☆ﾟ. * ･ ｡ﾟ = fmap in ༼∩☉ل͜☉༽⊃━☆ﾟ. * ･ ｡ﾟ (+2) [1, 2, 3]
05:18:56 <ttt_fff> > let ༼∩☉ل͜☉༽⊃━☆ﾟ. * ･ ｡ﾟ = fmap in ༼∩☉ل͜☉༽⊃━☆ﾟ. * ･ ｡ﾟ (+2) [1, 2, 3]
05:18:58 <lambdabot>  <hint>:1:5: lexical error at character '\3900'
05:19:26 <Intolerable> ☆ﾟis definitely *not* a letter
05:19:56 <demize> ttt_fff: use ᐧ instead of •?
05:20:10 <ttt_fff> we need to get the author of LYAH to change his illustrations to unicode
05:20:11 <Aejay> What did Goldilocks say upon seeing Maybe (b -> Either a b) ?
05:20:24 <Aejay> It's Just Right!
05:20:36 <ttt_fff> "I'm a dumbass and will steal the food of hungry bears."
05:21:01 <ttt_fff> wait
05:21:05 <ttt_fff> is it "Just Right" or "Just . Right" ?
05:21:13 <ttt_fff> :t Just Right
05:21:13 <Aejay> :t Just Right
05:21:14 <Intolerable> :t Just Right
05:21:14 <lambdabot> Maybe (b -> Either a b)
05:21:15 <lambdabot> Maybe (b -> Either a b)
05:21:15 <lambdabot> Maybe (b -> Either a b)
05:21:15 <Intolerable> lmao
05:21:18 <ttt_fff> :t Just . Right
05:21:19 <lambdabot> b -> Maybe (Either a b)
05:21:24 <Aejay> Haha 3 people at once.
05:21:37 <ttt_fff> oh right, Right is b -> Either a b
05:21:38 <Intolerable> :t sequence (Just Right) 
05:21:39 <lambdabot> b -> Maybe (Either a b)
05:21:48 <ttt_fff> so Just Right = Maybe (b -> Either a b)
05:21:53 <Aejay> Yup
05:21:54 <ttt_fff> damn, that's a cute joke
05:21:57 <Aejay> Ikr
05:21:58 <ttt_fff> Aejay ++
05:22:03 <ttt_fff> moar jokes
05:22:05 <Aejay> Awww thx
05:22:29 <Aejay> That's my best though... :(
05:22:31 <Intolerable> please no more jokes
05:22:40 <Aejay> They'd be INTOLERABLE
05:22:42 <Aejay> Hahahahahahaha
05:22:49 * hackagebot smoothie 0.4.0.1 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.0.1 (DimitriSabadie)
05:22:51 <Intolerable> i'm going to cry
05:23:03 <Aejay> I'm already crying
05:23:14 <ttt_fff>  (╯°□°）╯︵  ǝlqɐɹǝloʇuı
05:23:32 <Aejay> ttt_fff: Woah, that's cool.
05:23:40 <ttt_fff> http://www.springfrog.com/converter/upside-down-text.htm
05:24:15 <Aejay> > "zʎbʍʌnʇsɹbdouɯlʞɾıɥƃɟǝpɔqɐ"
05:24:16 <lambdabot>  "z\654b\653\652n\647s\633bdou\623l\670\638\305\613\387\607\477p\596q\592"
05:24:25 <ttt_fff> let ǝlqɐɹǝloʇuı = 20 in ǝlqɐɹǝloʇuı
05:24:32 <ttt_fff> > let ǝlqɐɹǝloʇuı = 20 in ǝlqɐɹǝloʇuı
05:24:33 <lambdabot>  20
05:24:37 <ttt_fff> OMG
05:24:38 <Aejay> Thats interesting; they make "d" "p"
05:24:51 <ttt_fff> i want to write a script that flips all var names upside down
05:24:54 <ttt_fff> teehee
05:25:09 <Aejay> Oh that's evil.
05:25:27 <Aejay> But You could probably do it with regexes.
05:25:33 <Aejay> But let's use parsec anyway <3
05:25:41 <ttt_fff> hmm, with regexes, we can substitute each char
05:25:50 <ttt_fff> but if we want the words to also be in inverse order, it'd proably require more than regexes
05:25:58 <Aejay> What about string literals?
05:26:08 <Aejay> That's already a problem
05:26:11 <ttt_fff> ddp -> ppd <== regexes would suffice
05:26:27 <ttt_fff> oh
05:26:32 <ttt_fff> what about string literals?
05:26:39 <ttt_fff> we wwant to preserve string literals?
05:26:45 <Aejay> Do we?
05:26:50 <ttt_fff> of course we do, we want to ust make the code incomprehensible while having the same input/output
05:26:50 <Aejay> I'm not sure myself.
05:26:58 <Aejay> Ah that's true...
05:27:00 <ttt_fff> we just want the code to be hard to read
05:27:12 <Aejay> Obfuscaaation@!
05:27:27 <Aejay> What about capital letters!
05:27:33 <ttt_fff> hmm
05:27:34 <Aejay> That's a problem.
05:28:11 <ttt_fff> well, let's give them some hope
05:28:20 <Aejay> Eh fair enough.
05:28:50 <Aejay> So "Maybe" would become "Mǝqʎɐ"?
05:30:14 <demize> Mmm, lambda.
05:30:19 <demize> Such a nice little letter.
05:30:40 <Aejay> lambda, yum.
05:30:55 <demize> The lambda is a proud and noble letter.
05:34:31 <catgocat> Hey
05:34:34 <catgocat> @pl landLeft n (left, right) = (left + n, right)
05:34:34 <lambdabot> landLeft = (`ap` snd) . (. fst) . ((,) .) . (+)
05:35:07 <bernalex> catgocat: first (+n)
05:35:37 <catgocat> bernalex, what?
05:35:43 <bernalex> > let n = 1
05:35:44 <lambdabot>  <no location info>: not an expression: ‘let n = 1’
05:35:49 <bernalex> wat
05:35:51 <bernalex> oh
05:35:54 <bernalex> @let n = 1
05:35:56 <lambdabot>  Defined.
05:36:00 <bernalex> @let (l, r) = (1, 1)
05:36:01 <lambdabot>  Defined.
05:36:06 <bernalex> > first (+n) (l, r)
05:36:07 <lambdabot>      Ambiguous occurrence ‘n’
05:36:07 <lambdabot>      It could refer to either ‘L.n’, defined at L.hs:166:1
05:36:07 <lambdabot>                            or ‘Debug.SimpleReflect.n’,
05:36:14 <bernalex> lol
05:36:16 <bernalex> god
05:36:22 <bernalex> @let lolol = 1
05:36:23 <lambdabot>  Defined.
05:36:26 <bernalex> > first (+lolol) (l, r)
05:36:28 <lambdabot>      Ambiguous occurrence ‘l’
05:36:28 <lambdabot>      It could refer to either ‘L.l’, defined at L.hs:167:2
05:36:28 <lambdabot>                            or ‘Debug.SimpleReflect.l’,
05:36:34 <bernalex> ok I give up
05:36:36 <bernalex> you get the idea
05:36:58 <bernalex> @let (rofl, dofl) = (1, 1)
05:37:00 <lambdabot>  Defined.
05:37:04 <bernalex> > first (+lolol) (rofl, dofl)
05:37:06 <lambdabot>  (2,1)
05:37:08 <indiagreen> > let (l, r, n) = (1, 1, 1) in first (+n) (l, r)
05:37:09 <lambdabot>  (2,1)
05:37:24 <demize> first (+L.n) (L.l, L.r)
05:37:26 <demize> > first (+L.n) (L.l, L.r)
05:37:26 <bernalex> I guess I could have just done that had I had some foresight.
05:37:27 <lambdabot>  (2,1)
05:38:20 <demize> Hmm, I forgot what I was going to do...
05:40:46 <LambdaBug> > let ಠ_ಠ = error in ಠ_ಠ "ಠ_ಠ"
05:40:48 <lambdabot>  *Exception: ಠ_
05:40:58 <demize> Lol
05:41:10 <tashjash> What is that encoding?
05:41:16 <LambdaBug> No idea.
05:41:22 <LambdaBug> but ಠ_ಠ
05:41:57 <demize> Is lambdabot's source available somewhere?
05:42:11 <indiagreen> demize: https://github.com/lambdabot/lambdabot
05:42:27 <demize> Cool, thanks.
05:44:00 <saep> Can anyone point me to a script which allows me to manually upload documentation to hackage?
05:44:22 <indiagreen> @hackage neil -- saep
05:44:22 <lambdabot> http://hackage.haskell.org/package/neil -- saep
05:44:45 <saep> indiagreen: Thanks!
05:45:10 <indiagreen> (in particular, “neil docs --user=yourhackageusername”)
05:45:52 <indiagreen> alternatively, here: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
05:45:57 <indiagreen> (but I never used this one)
05:50:16 <saep> indiagreen: Works like a charm, thanks again!
05:54:02 <demize> hmm...
05:54:05 <demize> > let ಠ_ಠ = error in ಠ_ಠ "ಠ_ಠ"
05:54:06 <lambdabot>  *Exception: ಠ_
05:54:11 <demize> You know what's weird?
05:54:17 <demize> I get different output in a PM
05:54:26 <demize> 14:54 <lambdabot>  *Exception: ಠ_??
05:54:54 <indiagreen> demize: I get same output
05:55:01 <mizu_no_oto> probably something weird with encoding
05:55:04 <indiagreen> (I mean, same output in PM and here)
05:55:13 <demize> indiagreen: That's even weirder.
05:55:18 <demize> mizu_no_oto: yeah.
05:56:57 <LambdaBug> I got that Laaaaa~mbda Buuu~g!
05:57:01 <LambdaBug> \quit
05:58:26 <indiagreen> what's going on in #haskell today
05:59:38 <maerwald> pro haskellers use unicode... it's fancy these days
06:05:40 <mokkake> hi, i'm looking for a library that provides higher functions to help with associativity, that includes, e.g <| and |>
06:06:06 <mokkake> and a lot of useful higher functions, can't remember the name of it
06:08:20 <bergmark> mokkake: http://www.stackage.org/lts-2.19/hoogle?q=%28%7C%3E%29 ?
06:10:06 <mokkake> bergmark, nope :/
06:11:37 <mokkake> the purpose of this library was at first to avoid '$'
06:11:43 <cchalmers> mokkake http://hackage.haskell.org/package/flow ?
06:12:14 <mokkake> cchalmers, I love you.
06:12:59 <Aejay> "In Soviet Russia, Haskell learns a you"
06:13:18 <cchalmers> :)
06:24:53 <pacak> Any suggestions how to help ghc to optimize generics? slapping -funfolding-(creation|use)-threshold A_LOT helps, I would like to have a bit more control, trying to figure out how to write RULES. Any suggestions?
06:37:53 * hackagebot http-conduit 2.1.7.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.7.1 (MichaelSnoyman)
06:41:12 <orion> If I import a library like aeson in to ghci, how can I get information about *where* that library is being loaded from?
06:42:00 <indiagreen> orion: you mean, what library does a module come from?
06:42:08 <Intolerable> ghc-pkg list PACKAGE_NAME
06:42:36 <Intolerable> if you're using cabal, cabal exec ghc-pkg list PACKAGE_NAME
06:47:54 * hackagebot yesod-table 1.0.2 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-1.0.2 (andrewthad)
06:51:45 <slowbait> Hi, I want to program a max-flow and I was wondering if an array of lists would be a good representation, since I'll update the graph often, and it seems like I'd be wasting much time updating it
06:52:21 <Intolerable> have you taken a look at ST?
06:52:27 <Intolerable> in particular, STArray?
06:53:30 <slowbait> No I haven't, thanks
06:53:50 <Intolerable> if that isn't fast enough, try STUArray
06:54:00 <Intolerable> see if you can get STArray working first, though
06:56:16 <init> I'd look at vector
06:57:54 * hackagebot heyefi 0.1.1.0 - A server for Eye-Fi SD cards.  https://hackage.haskell.org/package/heyefi-0.1.1.0 (ryantm)
06:58:44 <rhovland> I sort of gave up, and just used map..
06:59:20 <slowbait> Do you have an example or tutorial handy?
06:59:49 <Intolerable> https://wiki.haskell.org/Monad/ST
07:00:04 <shirt> where can i ask questions about opaleye?
07:00:14 <slowbait> ok, thanks :)
07:00:16 <sawidis> Hello everyone, beginner question here. I'm trying to get familiar with ghc error messages. Executing `group . sort [5, 5, 2, 2, 5, 5]` gives me """Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'     In the return type of a call of `sort'""". I understand why that line does not work but what I don't understand is the error message. Any hint?
07:00:19 <orion> Intolerable: Thank you
07:00:26 <Intolerable> or https://wiki.haskell.org/Arrays#Mutable_arrays_in_ST_monad_.28module_Data.Array.ST.29
07:02:29 <slowbait> Intolerable: I'll take a look, thanks
07:04:04 <Intolerable> :t group . sort
07:04:05 <lambdabot> Ord a => [a] -> [[a]]
07:04:06 <rhovland> saw: operator precedence? group . sort $ [5,5,2,2,5,5] or something should work
07:04:12 <latro`a> if you have a function makeThing = workHorse . setUp, where workHorse is locally defined, what is your convention for naming workHorse?
07:04:58 <Intolerable> sawidis: function application binds tighter than operators do
07:05:06 <latro`a> for concreteness you can assume that workHorse is recursive
07:05:08 <Intolerable> :t (.)
07:05:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:05:18 <Intolerable> :t sort [3,2,1,5,4]
07:05:20 <lambdabot> (Num a, Ord a) => [a]
07:05:26 <latro`a> an example:
07:05:41 <latro`a> make_QTree = make_rec 1 . sort
07:05:42 <latro`a>    where make_rec _ []  = Empty
07:05:42 <latro`a>          make_rec _ [x] = Leaf x
07:05:42 <latro`a>          make_rec n xs  = let (ys,zs) = span (\x -> x <= 2**(-n)) xs
07:05:42 <latro`a>                           in Tree (make_rec (n+1) ys) (make_rec (n+1) zs)
07:05:45 <Intolerable> there's no way to unify [a] as the first argument in (b -> c) -> (a -> b) -> a -> c
07:06:09 <Intolerable> because it evaluates as "group . (sort [1,2,3,4])"
07:06:25 <Intolerable> rather than "(group . sort) [1,2,3,4]" which i think you're expecting
07:06:44 <indiagreen> latro`a: “go”
07:07:15 <latro`a> indiagreen, always? or just when it's clear what it does?
07:07:21 <indiagreen> always
07:07:46 <indiagreen> (in this case it should be clear to the reader what setUp does)
07:07:53 <indiagreen> (in particular, that it sets up)
07:07:55 * hackagebot conduit 1.2.5 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.5 (MichaelSnoyman)
07:07:57 * hackagebot lambdacms-core 0.3.0.1 - LambdaCms 'core' subsite for Yesod apps  https://hackage.haskell.org/package/lambdacms-core-0.3.0.1 (cies)
07:08:06 <latro`a> setUp is clear in my application (it's actually just sort)
07:08:35 <indiagreen> like, I'm already used to the “go = main body” pattern, so there's no need to clarify that it's workHorse
07:10:06 <sawidis> Intolerable: Thanks for the reponse =) I understand that I should have written either `group . sort $ mylist` or `(group . sort) mylist` because of precedence rules but the error message still baffles me.. What do a0, [a1] and [a2] refer to? 
07:10:41 <latro`a> sawidis, the output of sort is a list, but group wants it to be a function
07:10:54 <Intolerable> when GHC tries to unify types, it labels them with the original type label with an extra digit added on
07:11:10 <indiagreen> latro`a: maybe you want groupWith?
07:11:23 <indiagreen> > groupWith (==) [1,5,3,6,2,1,4,2,5,2,3,1]
07:11:25 <lambdabot>  Not in scope: ‘groupWith’
07:11:31 * indiagreen huffs
07:12:09 <Intolerable> what version of GHC are you using?
07:12:21 <Intolerable> 7.10 is giving me much more helpful error messages
07:12:30 <sawidis> Intolerable: ah, got it =)
07:12:35 <latro`a> indiagreen, at the end I definitely want a tree, but I could be wrong about the preprocessing
07:12:35 <indiagreen> nevermind
07:12:39 <Intolerable> <interactive>:4:9:
07:12:39 <Intolerable>     Couldn't match expected type ‘a -> [a1]’
07:12:39 <Intolerable>                 with actual type ‘[Integer]’
07:12:39 <Intolerable>     Relevant bindings include
07:12:39 <Intolerable>       it :: a -> [[a1]] (bound at <interactive>:4:1)
07:12:40 <Intolerable>     Possible cause: ‘sort’ is applied to too many arguments
07:12:40 <Intolerable>     In the second argument of ‘(.)’, namely ‘sort [1, 2, 3, 4]’
07:12:41 <Intolerable>     In the expression: group . sort [1, 2, 3, 4]
07:12:50 <sawidis> latro`a, Intolerable thank you
07:12:50 <Intolerable> has a nice "possible cause" message
07:14:53 <slowbait> As a side question, I've never really understood what "forall" means, I just skip it when I'm reading the type of a function... Am I missing something?
07:15:11 <Intolerable> 90% of the time you can safely ignore it
07:15:52 <latro`a> indiagreen, I had another bug, though, which may explain why you were confused
07:16:03 <Intolerable> it's used for explicitly creating a new scope with type variables
07:17:28 <slowbait> Intolerable: why would you want that?
07:18:14 <latro`a> ordinarily, forall is on the outside, and it permits you to evaluate the function with whatever you want provided it satisfies the type constraints
07:18:44 <latro`a> when forall is on the inside, the opposite occurs: you're forced to evaluate the function with a *polymorphic* value
07:19:09 <latro`a> that outer forall is actually implicit in any signature with type variables
07:19:26 <latro`a> :t 1
07:19:28 <lambdabot> Num a => a
07:19:42 <latro`a> can also be written "forall a. Num a => a"
07:19:56 <Intolerable> :t 1 :: forall a. Num a => a 
07:19:57 <lambdabot> Num a => a
07:21:34 <slowbait> Ok, I got it so far :) What happens when is in the inside?
07:22:13 <latro`a> I don't use this much, but the simplest example I can think of is like this
07:22:31 <latro`a> silly :: forall b. Num b => (forall a. Maybe a) -> b
07:22:38 <latro`a> silly Nothing = 1
07:22:42 <latro`a> (I think that works out)
07:23:03 <Aejay> @djin 
07:23:03 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
07:23:08 <eacameron> If someone is familiar with Python's celery library, could you recommend a similar tool for Haskell?
07:23:19 <Aejay> @djinn (a -> b) -> (b -> c) -> a -> c 
07:23:19 <lambdabot> f a b c = b (a c)
07:24:20 <latro`a> slowbait, note:
07:24:21 <latro`a> :t Nothing
07:24:22 <lambdabot> Maybe a
07:25:15 <latro`a> this is reflective of the fact that there is no "fromJust" for Nothing; the type of it would have to be "forall a. a" and the "only such value" is undefined
07:25:37 <Aejay> @djinn ((a -> b) -> b) -> (a -> b) -> b
07:25:37 <lambdabot> f a = a
07:25:59 <Aejay> @djinn ((a -> b) -> b) -> (b -> (a -> b)) -> b
07:25:59 <lambdabot> -- f cannot be realized.
07:26:31 <Aejay> @djinn (a -> a) -> a
07:26:31 <lambdabot> -- f cannot be realized.
07:26:36 <Aejay> Oh sure it can.
07:26:39 <chpatrick> :)
07:26:46 <Intolerable> eacameron: is there a problem with using 0mq?
07:26:47 <geekosaur> djinn doesn't support recursive types
07:26:55 <Aejay> Such a pity :(
07:27:03 <Aejay> > let y f = f (y f) in f
07:27:05 <lambdabot>      No instance for (Show a0)
07:27:05 <lambdabot>        arising from a use of ‘show_M39649764050262262007353’
07:27:05 <lambdabot>      The type variable ‘a0’ is ambiguous
07:27:25 <slowbait> latro`a: can I have something like silly (Just a) = a ?
07:27:31 <Aejay> > let y f = f (y f) in take 5 $ y $ (:) 5
07:27:33 <lambdabot>  [5,5,5,5,5]
07:27:48 <Aejay> slowbait: D:
07:27:52 <Aejay> That's pure evil!
07:28:00 <geekosaur> :exf "(f -> f) -> f"
07:28:13 <Intolerable> let a = Just a in a
07:28:17 <Intolerable> > let a = Just a in a
07:28:18 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ Maybe a1
07:28:18 <lambdabot>      Relevant bindings include
07:28:18 <lambdabot>        a :: Maybe a1 (bound at <interactive>:1:5)
07:28:22 <latro`a> Aejay, we're talking about polymorphic values using the example of Nothing
07:28:23 <Aejay> Hahaha
07:28:25 <Intolerable> yay for infinite types
07:28:27 <geekosaur> bah
07:28:43 <Aejay> you need to make a type y-combinator
07:29:02 <Aejay> > newtype Y f = Y {unY :: f (Y f)}
07:29:04 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
07:29:21 <exferenceBot> replying took too much time (60sec), aborting.
07:29:28 <Aejay> > data Y f = Y {unY :: f (Y f)}
07:29:30 <lambdabot>  <hint>:1:1: parse error on input ‘data’
07:29:36 <Aejay> Ah darn it.
07:29:49 <Intolerable> :data Y f = Y { unY :: f (Y f) }
07:30:05 <Aejay> Ah, thx.
07:30:12 <Intolerable> i dont think that worked
07:30:20 <Aejay> Why?
07:30:25 <slowbait> latro`a: So I take it as you can't?
07:30:29 <hexagoxel> :t fix id
07:30:31 <lambdabot> a
07:30:38 <Intolerable> @let data Y f = Y { unY :: f (Y f) }
07:30:40 <lambdabot>  Defined.
07:30:43 <Aejay> hexagoxel: I love doing that...
07:30:43 <Intolerable> there u are
07:30:50 <hexagoxel> on the proof level, this would be a tautology for everything
07:30:56 <Aejay> Intolerable++
07:31:17 <Aejay> > :t let Just (Y a) = a in a
07:31:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:31:21 <geekosaur> ok, exferenceBot doesn't like fixpoints :)
07:31:28 <Aejay> :t let Just (Y a) = a in a
07:31:30 <lambdabot> Maybe (Y Maybe)
07:31:39 <latro`a> slowbait, it's defined but partial. more importantly, the first value is not forced to be polymorphic; I can pass Just (1 :: Int), which has a concrete type
07:31:41 <eacameron> Intolerable: not necessarily...but I thought it was pretty low lever
07:31:46 <eacameron> *level
07:31:51 <Aejay> :t let (Y (Just a)) = a in a
07:31:53 <lambdabot> Y Maybe
07:31:56 <latro`a> Nothing, by contrast, does not have a concrete type
07:31:58 <Aejay> Perfect!
07:32:27 <Intolerable> eacameron: is there nothing in cloud-haskell that might help?
07:32:36 <Intolerable> (i haven't really looked much into it tbh)
07:32:50 <Aejay> :t let (Y (Right a)) = a in a
07:32:52 <lambdabot> Y (Either t)
07:32:56 * hackagebot tidal 0.5.2 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.5.2 (AlexMcLean)
07:32:59 <Aejay> :t let (Y (Left a)) = a in a
07:33:00 <lambdabot>     Occurs check: cannot construct the infinite type:
07:33:01 <lambdabot>       t1 ~ Y (Either t1)
07:33:01 <lambdabot>     Relevant bindings include a :: t1 (bound at <interactive>:1:14)
07:33:07 <Aejay> Oho how interesting!
07:33:10 <hexagoxel> geekosaur: oh, it would love to use fixpoints for everything, if fix was added to the environment. but that would be bad idea.
07:33:21 <eacameron> Intolerable: There probably is... I was mainly curious if someone could compare the Haskell experience to Python's celery experience
07:33:31 <Intolerable> ah, i'm afraid i can't help you there
07:33:33 <Aejay> :t let (Y ([a])) = a in a
07:33:34 <lambdabot> Y []
07:33:40 <Aejay> :k Y []
07:33:41 <lambdabot> *
07:33:49 <Aejay> :k Y
07:33:51 <lambdabot> (* -> *) -> *
07:34:24 <eacameron> Intolerable: I'll take a gander at Cloud Haskell and see how it compares
07:35:49 <Aejay> @let newtype Mu a = Mu {unMu :: (Mu a) -> a}
07:35:51 <lambdabot>  .L.hs:144:36:
07:35:51 <lambdabot>      Ambiguous occurrence ‘Mu’
07:35:51 <lambdabot>      It could refer to either ‘L.Mu’, defined at .L.hs:173:1
07:36:01 <Aejay> :k Mu
07:36:03 <lambdabot> (* -> *) -> *
07:36:11 <Aejay> :info Mu
07:36:25 <Aejay> :i Mu
07:36:27 <gianzoo80> @pl \(x,y) -> (y,x)
07:36:27 <lambdabot> uncurry (flip (,))
07:37:11 <Aejay> @let newtype M a = M {unM :: (M a) -> a}
07:37:13 <lambdabot>  Defined.
07:37:46 <Aejay> :t (\x -> x x) (\x -> x x)
07:37:48 <lambdabot>     Occurs check: cannot construct the infinite type: r0 ~ r0 -> t
07:37:48 <lambdabot>     Expected type: r0 -> t
07:37:48 <lambdabot>       Actual type: (r0 -> t) -> t
07:38:03 <Aejay> :t (\x -> unMu x x) (Mu $ \x -> unMu x x)
07:38:04 <lambdabot>     Not in scope: ‘unMu’
07:38:04 <lambdabot>     Perhaps you meant ‘unM’ (line 173)
07:38:04 <lambdabot>     Not in scope: data constructor ‘Mu’
07:38:13 <Aejay> :t (\x -> unM x x) (M $ \x -> unM x x)
07:38:14 <lambdabot> a
07:38:18 <Aejay> Yay!
07:38:21 <latro`a> is there a convenient way to turn a floating number in [0,1] into its bits?
07:38:33 <latro`a> err, the bits of its mantissa, that is
07:38:52 <Aejay> :t (\x -> unM x x) $ M $ (\x -> unM x x)
07:38:53 <lambdabot> a
07:39:15 <latro`a> basically I have a number, if the first bit is 0 I go left, else I go right, if the second bit is 0 I go left, else I go right, etc. until I hit a leaf
07:39:46 <Aejay> :t \f -> (\x -> f (unM x x)) (M (\x -> f (unM x x)))
07:39:47 <lambdabot> (a -> a) -> a
07:39:57 <Aejay> @let fix = \f -> (\x -> f (unM x x)) (M (\x -> f (unM x x)))
07:39:59 <lambdabot>  ghc: panic! (the 'impossible' happened)
07:39:59 <lambdabot>    (GHC version 7.10.1 for x86_64-unknown-linux):
07:39:59 <lambdabot>         Simplifier ticks exhausted
07:40:10 <latro`a> Aejay, can you take that to query?
07:40:11 <athan_> :D
07:40:24 <Aejay> Sure
07:40:48 <Intolerable> latro`a: there's nothing in Data.Bits for that, is there?
07:40:50 <athan_> Aejay: Oh woah, so that's how you can write the untyped version of Y?
07:41:00 <kadoban> latro`a: Is that all one question? I don't understand how the floating point relates to the tree thing?
07:41:29 <Intolerable> :t finiteBitSize
07:41:30 <slowbait> Aejay: what just happened?
07:41:31 <lambdabot> FiniteBits b => b -> Int
07:41:37 <Aejay> athan_: Yup, pretty cool, but you have to define data M a = M (M a -> a) first.
07:41:49 <latro`a> kadoban, I have a numbe like 7.892365e-1, internally it is in binary; what I want is the actual bits, because those are enough to determine each step in the tree one after the other
07:41:59 <Aejay> slowbait: It seems @let evaluates before definition.
07:42:20 <Intolerable> \x -> map (`testBit` x)  [0..finiteBitSize x]
07:42:21 <athan_> Aejay: Still cool :)
07:42:26 <Intolerable> :t \x -> map (`testBit` x) [0..finiteBitSize x]
07:42:27 <lambdabot> Int -> [Bool]
07:42:29 <latro`a> alternately, I could generate a bit sequence directly, which might be faster
07:42:32 <Aejay> *nods vigorously*
07:42:45 <Intolerable> :t \x -> map (testBit x) [0..finiteBitSize x]
07:42:47 <lambdabot> FiniteBits b => b -> [Bool]
07:42:49 <Intolerable> that's better
07:43:19 <fractalsea> I have a series of function that return type Maybe a. I want to return the result of the first that results in a Just value. What’s the best way of doing this? I was considering putting the functions in the list and writing my own function to traverse it (couldn’t find something in a library to do this…)
07:43:30 <latro`a> and I can apply that to a double? (I haven't used data.bits for whatever reason)
07:43:33 <Aejay> > (map .testBit) [0..finiteBitSize 1]
07:43:35 <lambdabot>      No instance for (Bits [Int]) arising from a use of ‘testBit’
07:43:35 <lambdabot>      In the second argument of ‘(.)’, namely ‘testBit’
07:43:35 <lambdabot>      In the expression: map . testBit
07:43:46 <Intolerable> :t asum :: [Maybe a] -> Maybe a
07:43:47 <lambdabot>     Not in scope: ‘asum’
07:43:47 <lambdabot>     Perhaps you meant one of these:
07:43:47 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
07:43:59 <Aejay> > map (testBit 1) [0..finiteBitSize 1]
07:44:00 <lambdabot>      No instance for (FiniteBits b0)
07:44:00 <lambdabot>        arising from a use of ‘finiteBitSize’
07:44:00 <lambdabot>      The type variable ‘b0’ is ambiguous
07:44:15 <Intolerable> ugh no you can't
07:44:16 <Aejay> > map (testBit (1 :: Float)) [0..finiteBitSize 1]
07:44:17 <lambdabot>      No instance for (Bits Float) arising from a use of ‘testBit’
07:44:17 <lambdabot>      In the first argument of ‘map’, namely ‘(testBit (1 :: Float))’
07:44:17 <lambdabot>      In the expression:
07:44:26 <Intolerable> no instance (Bits Double)
07:44:29 <Aejay> Eh ah well.
07:44:47 <latro`a> huh. and the only way I can think to write one would be to do what I'm already doing
07:44:48 <Intolerable> fractalsea: use "asum" from Data.Foldable
07:44:54 <Aejay> :t asum
07:44:56 <lambdabot>     Not in scope: ‘asum’
07:44:56 <lambdabot>     Perhaps you meant one of these:
07:44:56 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
07:45:00 <Aejay> :t F.asum
07:45:02 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
07:45:06 <Intolerable> > F.asum [Nothing, Nothing, Just 5, Just 5]
07:45:06 <latro`a> namely, query_QTree q (Tree left right) | q <= 1/2  = query_QTree (2*q) left
07:45:06 <latro`a>                                 | otherwise = query_QTree (2*q-1) right
07:45:07 <lambdabot>  Just 5
07:45:11 <latro`a> stupid indentation
07:45:35 <fractalsea> F.asum [Nothing, Nothing, Just 5, Just 7]
07:45:37 <Aejay> Ooh, alternatives!
07:45:45 <fractalsea> Looks good
07:45:50 <Aejay> > F.asum [[1,2,3],[4,5,6],[7,8]]
07:45:52 <lambdabot>  [1,2,3,4,5,6,7,8]
07:46:04 <Intolerable> you need the ">" if you want to eval it
07:46:04 <fractalsea> > F.asum [Nothing, Nothing, Just 5, Just 7]
07:46:06 <lambdabot>  Just 5
07:46:26 <fractalsea> It’s a shame it doesn’t pull the value out of the Just
07:46:36 <Aejay> fractalsea: Never, ever just do that.
07:46:40 <gianzoo43> @pl \x -> (snd x, fst x)
07:46:40 <lambdabot> liftM2 (,) snd fst
07:46:48 <Aejay> Unless you're 100% sure it'll be fine.
07:46:54 <Intolerable> latro`a: are you literally just using the bits of a Double?
07:47:05 <fractalsea> Oh I see because there’s no default value
07:47:18 <Intolerable> > fromMaybe 0 $ F.asum [Nothing, Nothing, Just 5, Just 5]
07:47:20 <lambdabot>  5
07:47:21 <Aejay> precisely. You immediatley make your code unsafe.
07:47:24 <latro`a> Intolerable, effectively yes, except with the requirement that the number is already in [0,1]
07:47:27 <Aejay> Intolerable: that's fine
07:47:28 <fractalsea> I do have a default value though, so I guess I could do a wrapper
07:47:31 <Aejay> :t fromMaybe
07:47:33 <lambdabot> a -> Maybe a -> a
07:47:33 <kadoban> fractalsea: Then what would happen on  F.asum [Nothing]  ?  nothing good
07:47:38 <Aejay> :t maybe
07:47:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:47:55 <Aejay> > maybe 0 (+ 1) $ Just 6
07:47:57 <lambdabot>  7
07:47:58 <fractalsea> Great. that looks like what I need (fromMaybe)
07:47:59 <Aejay> > maybe 0 (+ 1) $ Nothing
07:48:01 <lambdabot>  0
07:48:07 <fractalsea> Thanks
07:48:15 <kadoban> Yeah 'maybe' and 'fromMaybe' are great, depending on which fits better.
07:48:15 <Aejay> fractalsea: also maybe
07:48:25 <Aejay> As kadoban says.
07:48:42 <Aejay> @karma Intolerable 
07:48:42 <lambdabot> Intolerable has a karma of 3
07:48:49 <Aejay> ooh.
07:48:50 <Intolerable> yeah i'm not sure what to do about getting Bits from Doubles
07:49:01 <Intolerable> maybe look at unsafeCoerce?
07:49:12 <Intolerable> carefully
07:49:15 <latro`a> Intolerable, the other question is about the efficiency of the RNG; is it easier to generate 53 random Bools, or to extract the 53 random digits from a random Double
07:49:37 <Aejay> Ask stack overflow, who knows who'll know!
07:49:46 <Aejay> Intolerable: D:
07:49:48 <Intolerable> if your double is always in the range [0,1], surely the random bools will be better?
07:50:01 <Intolerable> the best option is generate a random Word
07:50:07 <kadoban> latro`a: So you're generating a random Double, just to get its bits? That sounds pretty broken.
07:50:11 <Stratege> there are bitwise operations available which I'd hope don't require the use of unsafeCoerce first.
07:50:13 <Intolerable> and then use those bits
07:50:36 <Intolerable> alternatively, try benchmarking it
07:50:41 <Stratege> (also, why a random double instead of, say, a random Int?)
07:51:17 <chpatrick> latro`a: decodeFloat
07:51:17 <latro`a> the application in question (the random double is a probability) makes me think about it in terms of doubles
07:51:23 <chpatrick> :t decodeFloat
07:51:24 <lambdabot> RealFloat a => a -> (Integer, Int)
07:51:47 <latro`a> Integer is the mantissa?
07:51:59 <chpatrick> yes
07:52:23 <Aejay> Ooh, that's interesting!
07:52:28 <Aejay> > decodeFloat 0.312
07:52:30 <lambdabot>  (5620492334958379,-54)
07:52:33 <nshepperd> you can't unsafeCoerce doubles to word types (currently)
07:52:36 <Aejay> Eh?
07:52:53 <kadoban> latro`a: If you just need it as bits, and if you can generate the same (or a good enough) distribution just by … generating bits, that's going to be better. Or some Word if you really want to do that, but I wouldn't bother unless efficiency is shown to be a problem.
07:52:57 <Nux__> Why is this? http://lpaste.net/137194
07:53:03 <chpatrick> Aejay: remember it's base 2
07:53:10 <latro`a> kadoban, efficiency is a concern here definitely, I can tell that from the start
07:53:25 <chpatrick> https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:decodeFloat_Int-35-
07:53:28 <latro`a> since we're talking about drawing billions of times out of this tree
07:53:29 <Nux__> wait
07:53:29 <chpatrick> if you want to avoid the Integer
07:53:31 <Nux__> oops
07:53:47 <Intolerable> you got it
07:53:53 <kadoban> latro`a: Even if it is, you usually can't tell from the start which parts are going to cause too much slowness. Premature optimization is a vice.
07:54:04 <Nux__> yes I did
07:54:07 <Intolerable> that's why you don't call types "Thing" and "This"
07:54:08 <Intolerable> ;)
07:54:16 <Intolerable> (unless its a These)
07:54:16 <Nux__> :p
07:54:19 <Intolerable> :i These
07:54:30 <Intolerable> :t This
07:54:31 <lambdabot> Not in scope: data constructor ‘This’
07:54:37 <Intolerable> :t Data.These.This
07:54:39 <lambdabot> Not in scope: data constructor ‘Data.These.This’
07:54:41 <Intolerable> aww
07:57:16 <Aejay> @let data These a b = This a | That b | These a b
07:57:18 <lambdabot>  Defined.
07:57:32 <Aejay> (from Data.These: https://hackage.haskell.org/package/these-0.3/docs/Data-These.html)
07:57:56 <Aejay> :t These
07:57:58 <lambdabot> a -> b -> These a b
07:57:58 * hackagebot persistent-instances-iproute 0.1.0.0 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-instances-iproute-0.1.0.0 (sickmind)
08:02:58 * hackagebot Hipmunk 5.2.0.17 - A Haskell binding for Chipmunk.  https://hackage.haskell.org/package/Hipmunk-5.2.0.17 (FelipeLessa)
08:07:59 * hackagebot hs-carbon 0.1.1.0 - A Haskell framework for parallel monte carlo simulations  https://hackage.haskell.org/package/hs-carbon-0.1.1.0 (cholmgreen)
08:11:20 <Aejay>  Join, quit, join, quit.... it's all goin' round....
08:12:05 <voidzero> i hide it
08:12:29 <Aejay> How?
08:12:49 <voidzero> depends on the client
08:12:53 <voidzero> with weechat, /help filter
08:12:59 * hackagebot mangopay 1.11.4 - Bindings to the MangoPay API  https://hackage.haskell.org/package/mangopay-1.11.4 (FelipeLessa)
08:13:01 * hackagebot yesod-mangopay 1.11.4 - Yesod library for MangoPay API access  https://hackage.haskell.org/package/yesod-mangopay-1.11.4 (FelipeLessa)
08:13:03 * hackagebot extra 1.4 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4 (NeilMitchell)
08:13:05 * hackagebot lambdacms-core 0.3.0.2 - LambdaCms 'core' subsite for Yesod apps  https://hackage.haskell.org/package/lambdacms-core-0.3.0.2 (cies)
08:13:23 <frerich> I don't see join/leave/rename messages either. If you use LimeChat, you can configure it on the 'Log' tab in the preferences.
08:13:41 <Aejay> any ideas for irssi?
08:14:01 <frerich> Aejay: http://wiki.xkcd.com/irc/Hide_join_part_messages :-)
08:15:37 <Aejay> frerich: Thx
08:38:00 * hackagebot persistent-instances-iproute 0.1.0.1 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-instances-iproute-0.1.0.1 (sickmind)
08:44:36 <cow_2001> anyone knows automatic gpl notice generator?
08:47:21 <kadoban> cow_2001: "notice" generator?
08:47:26 <cow_2001> huh
08:47:27 <Aejay> \leave
08:47:29 <cow_2001> well
08:47:33 <cow_2001> awww
08:47:36 <cow_2001> aejay :(
08:48:06 <cow_2001> kadoban: it seems a tad boresome
08:48:20 <cow_2001> to add such a comment to each and every file
08:48:42 <juanpaucar> i have a question: let's say i'm working on an IO () function... so i have
08:48:52 <juanpaucar> now <- getCurrentTime
08:49:26 <bergmark> cow_2001: why do you need one in every file?
08:49:31 <glguy> juanpaucar: Note that things with type IO() aren't functions
08:49:31 <juanpaucar> and i can use ythat now on function for where, but i can't when i take for example (now, yesterday) <- getTodayAndYesterday
08:49:37 <cow_2001> some python guy's pycon catchphrase is "THERE MUST BE A BETTER WAY"
08:49:40 <juanpaucar> well inside an IO conext
08:50:10 <bergmark> cow_2001: yes, having just one license file in the project root? :)
08:50:30 <kadoban> cow_2001: You don't need one in every file … but if you really want one, get support for it in your editor. It's usually called "snippets" or something, it saves a lot of time with boilerplate.
08:50:52 <kadoban> It's basically autocomplete, but a slightly different use-case.
08:50:54 <benma> juanpaucar: don't understand your problem, can you explain?
08:50:56 <ChristianS> juanpaucar: in the expression "(now, yesterday) <- getTodayAndYesterday", now is a free variable, not a bound one
08:51:13 <cow_2001> kadoban: cool!
08:53:40 <cow_2001> what do you guys think of https://github.com/honza/vim-snippets
08:53:57 <cow_2001> that's not haskell. should i move to #haskell-blah?
08:54:55 <xandaros> When specifying dependencies in cabal, how can I enable flags for that dependency? (In particular, I want to enable to glfw flag for gloss)
08:55:26 <kadoban> cow_2001: I use that with neosnippet, it works well enough
08:55:49 <osa1> any HERMIT experts here?
08:56:08 <cow_2001> kadoban: what does it mean?
08:56:29 <kadoban> cow_2001: Which part?
08:56:36 <voidzero> 'it' i think
08:57:05 <voidzero> 'information technology'
08:57:33 <Aejay> :k Y
08:57:34 <lambdabot> (* -> *) -> *
08:58:34 <cow_2001> kadoban: how do you use them both?
08:58:40 <cow_2001> kadoban: what is the workflow?
08:59:30 <kadoban> cow_2001: AFAIK vim-snippets is just data, basically. Or if it includes an engine, I'm not using it. neosnippet is what actually makes it work.
09:03:49 <cow_2001> kadoban: what's your setup?
09:05:04 <kadoban> cow_2001: Let's take it to -blah ? I can post my vimrc if you want, it's all in there.
09:09:46 <schoppenhauer> hello. I have a record type which has no canonical Ord-instance. is it possible to define multiple Ord-instances for this type somehow?
09:09:57 <Intolerable> create a newtype for it
09:10:07 <Intolerable> take a look at Sum and Product in Data.Monoid
09:10:23 <Intolerable> (monoid instances, but you can do the same thing with Ord)
09:10:36 <schoppenhauer> ah ok thx.
09:18:07 <Aejay> Just as a question, does ghcjs bind functions as they appear in haskell code? Ie, can I write a function in haskell, compile it in ghcjs and use the function there?
09:19:49 <Gurkenglas> How do I get hylo's free theorem?
09:21:38 <Aejay> @pl \a b c d -> b c (a d) d (a b c)
09:21:38 <lambdabot> ap =<< (liftM2 flip .) . flip flip id . ((flip . (ap .)) .) . flip (flip . ((.) .))
09:21:46 <Aejay> :t \a b c d -> b c (a d) d (a b c)
09:21:47 <lambdabot>     Occurs check: cannot construct the infinite type:
09:21:47 <lambdabot>       r1 ~ r3 -> (r3 -> r2) -> r1 -> r2 -> r
09:21:47 <lambdabot>     Relevant bindings include
09:43:17 <dotxasp> What does slashed " II " mean?
09:43:20 <dotxasp> https://s0.wp.com/latex.php?latex=%5Cdisplaystyle++%5Cbegin%7Barray%7D%7Blcl%7D+%5Cmathit%7Blevels%7D+%26%3A%3A%26+%5Cmathsf%7BTree%7D%5C%3B%5Calpha+%5Crightarrow+%5B%5B%5Calpha%5D%5D+%5C%5C+%5Cmathit%7Blevels%7D%5C%3Bt+%26%3D%26+%5B%5Cmathit%7Broot%7D%5C%3Bt%5D+%3A+%5Cmathit%7Bfoldr%7D%5C%3B%28%5Cmathit%7Blzw%7D%5C%3B%28%5Cmathbin%7B%7B%2B%7D%5C%21%5C%21%5C%21%7B%2B%7D%7D%29%29%5C%3B%5B%5C%2C%5D%
09:43:21 <dotxasp> 5C%3B%28%5Cmathit%7Bmap%7D%5C%3B%5Cmathit%7Blevels%7D%5C%3B%28%5Cmathit%7Bchildren%7D%5C%3Bt%29%29+%5Cend%7Barray%7D+&bg=ffffff&fg=000000&s=0
09:43:51 <dotxasp> Uh, sorry. https://patternsinfp.wordpress.com/2015/03/05/breadth-first-traversal/
09:44:17 <fosterite> hi, a while ago I read something that was talking about typeclasses in haskell and mentioned the show.read problem as one of the worst
09:44:28 <fosterite> I'm trying to find it again
09:46:49 <fishythefish> dotxasp, looks like you're talking about ++ ?
09:47:00 <dotxasp> Oh so it's a ++
09:47:15 <dotxasp> Latex version of it confuses me
09:47:18 <fishythefish> Yeah, that's one of those Unicode equivalents for Haskell symbols.
09:47:32 <fishythefish> (Haskell supports those as well, by the way.)
09:47:51 <dotxasp> without any flag?
09:48:14 <dotxasp> anyway thanks.
09:48:31 <fishythefish> dotxasp, https://wiki.haskell.org/Unicode-symbols
09:48:53 <fishythefish> Should be just a pragma if you're using GHC.
09:56:13 <AeJay> > (\x -> unM x x) (M (\x -> unM x x))
09:56:17 <lambdabot>  mueval-core: Time limit exceeded
09:56:29 <dotxasp> > (1 / 0)
09:56:31 <lambdabot>  Infinity
09:56:42 <dotxasp> Why it returns Infinity?
09:56:52 <mniip> because it's float division
09:56:54 <sbrg> because 42 was taken
09:57:05 <mniip> > 1 `div` 0
09:57:06 <lambdabot>  *Exception: divide by zero
09:57:24 <dotxasp> oh I see.
09:57:33 <AeJay> This is fun, isn't it?
09:57:48 <AeJay> > y id
09:57:49 <lambdabot>      Couldn't match expected type ‘(a0 -> a0) -> t’
09:57:50 <lambdabot>                  with actual type ‘Expr’
09:57:50 <lambdabot>      The function ‘y’ is applied to one argument,
09:57:55 <AeJay> :t y
09:57:56 <lambdabot> Expr
09:58:25 <AeJay> @let y f = (\x -> f (unM x x)) (M (\x -> f (unM x x)))
09:58:26 <lambdabot>  ghc: panic! (the 'impossible' happened)
09:58:26 <lambdabot>    (GHC version 7.10.1 for x86_64-unknown-linux):
09:58:26 <lambdabot>         Simplifier ticks exhausted
09:58:27 <AeJay> :t y
09:58:28 <lambdabot> Expr
09:58:37 <AeJay> @let y f = f (y f)
09:58:38 <lambdabot>  .L.hs:206:10:
09:58:39 <lambdabot>      Ambiguous occurrence ‘y’
09:58:39 <lambdabot>      It could refer to either ‘L.y’, defined at .L.hs:206:1
09:58:52 <AeJay> @let fix f = f (fix f)
09:58:52 <lambdabot>  .L.hs:181:12:
09:58:53 <lambdabot>      Ambiguous occurrence ‘fix’
09:58:53 <lambdabot>      It could refer to either ‘L.fix’, defined at .L.hs:181:1
09:58:57 <AeJay> :t fix
09:58:58 <dolio> Stop.
09:58:58 <lambdabot> (a -> a) -> a
10:02:48 <tom____> question about ghcjs
10:03:13 <tom____> is there a way to set things up so that any calls to the server are guaranteed to be handled?
10:03:57 <kadoban> tom____: "the server" ?
10:04:04 <tom____> yeah, the backend
10:04:58 <tom____> so, currently my work has a tomcat instance and some javascript front end. i want to proof of concept something that would allow us to know if an ajax call is supported (or if the parameters changed) or what is using a particular entry point
10:05:23 <tom____> also an excuse to use haskell for work
10:08:07 <AeJay> @babel English Japanese "Hello"
10:08:07 <lambdabot> Unknown command, try @list
10:18:56 <Murtaugh> o/
10:20:56 * orion is really annoyed at how outdated Haskell on FreeBSD is.
10:22:10 <maerwald> orion: you mean ghc?
10:22:54 <orion> Yes.
10:22:55 <AeJay> \me is suprised that you wouldn't just get GHC from Haskell.org.
10:23:02 * AeJay is suprised that you wouldn't just get GHC from Haskell.org.
10:23:07 <AeJay> Haha, I messed up.
10:25:48 <orion> AeJay: I
10:25:51 <orion> AeJay: I'm about to do that.
10:28:07 * hackagebot delta 0.2.1.2 - A library for detecting file changes  https://hackage.haskell.org/package/delta-0.2.1.2 (muzzle)
10:29:25 <AeJay> :D
10:29:40 <AeJay> And wow, that package looks amazing...
10:29:57 <quux> hello
10:30:24 <quux> my friend likes haskell so much they wont program in any other language
10:30:39 <quux> what could i do help them branch out?
10:30:46 <AeJay> Hmmm....
10:30:54 <AeJay> Give him some ocaml?
10:31:01 <Zemyla> What other languages do you want him to program in?
10:31:22 <quux> just something different to get variety
10:31:34 <maerwald> quux: tell them to program a game in haskell. They will probably give up quite early on
10:31:44 <AeJay> That's evil maerwald 
10:31:59 <maerwald> uh, it's possible, but...
10:32:05 <quux> haha
10:32:13 <maerwald> it also shows that other languages can do that "easier"
10:32:18 <AeJay> quux: Maybe something more extreme, like idris, will make him want to branch out a bit.
10:32:24 <Zemyla> quux: Ask them to learn Prolog. It's an extremely different language that will teach them new things.
10:32:26 <orion> If you can write a window manager in Haskell, you can write a game in Haskell.
10:32:30 <AeJay> Zemyla++
10:32:40 <maerwald> orion: you can write anything in haskell
10:32:48 <mfukar> Just because you can, doesn't mean you should
10:33:08 * hackagebot gitit 0.11.1 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.11.1 (JohnMacFarlane)
10:33:20 <Zemyla> @faq Can Haskell solve the Halting problem?
10:33:21 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:33:38 <Zemyla> Aww, they changed the way @faq works.
10:33:44 <mfukar> In that sense quux's buddy should try something different than Haskell. What about "plain old" C or C++?
10:34:00 <AeJay> mfukar: D:
10:34:10 <AeJay> That's so cruel.
10:34:17 <mfukar> Yet useful
10:34:20 <AeJay> How about scala?
10:34:21 <Zemyla> mfukar: Actually, I would probably get then to learn F#, and then C#
10:34:45 <AeJay> Maybe swift? It's quite good, but still nothing on Haskell...
10:35:00 <Zemyla> Also, at some poibt, they need to learn assembly.
10:35:09 <mfukar> quux: Ask your friend to write an http server. Ask them to scale it up.
10:35:23 <koomi> quux: does he have any experience in other languages/fields?
10:35:26 <mfukar> quux: or ask him to hack on a kernel or something.
10:36:43 <Welkin> AeJay: swift is not good, it is a nightmare
10:36:45 * ww_ once you have given up on strong types, you can't go very wrong with lisp or scheme
10:37:03 <Zemyla> ww_: Or LOGO.
10:37:07 <AeJay> Welkin: Haha, it's not good with types but it's nice to play with.
10:37:11 <orion> Why would anyone give up on strong types?
10:37:49 <AeJay> orion: That's why Agda or Idris would be good.
10:39:58 <ww_> personally i use Go for things that i would have used C or Python for in the past...
10:40:15 <siddharthist> @quux @ww_ Seconded on Scheme! Racket (Scheme) has a typed version, but Lisp variants teach a new way of thinking (macros, etc.)
10:40:15 <lambdabot> Not enough privileges
10:40:45 <ReinH> siddharthist: recommend not using @ to address people since it triggers lambdabot
10:41:00 <koomi> every programmer should have a fair amount of experience programming in C
10:41:12 <siddharthist> ReinH: Oh! nice, thanks. 
10:41:16 <koomi> too much of our infrastructure is built in it to ignore it
10:41:18 <ReinH> But to your point, On Lisp is a great introduction to "thinking in lisp"
10:41:37 <nwf> Apparently my trac account isn't good enough any more; can someone mark http://trac.haskell.org/haddock/ticket/43 as closed by https://phabricator.haskell.org/D1086 in the upcoming 7.12?
10:42:19 <siddharthist> ReinH: I'm a big fan of SICP, myself. It was my introduction to FP. 
10:42:31 <ReinH> SICP is absolutely great
10:43:17 <ReinH> but it's a more general introduction, as evidenced by MIT switching to Python ;)
10:43:28 <ReinH> On Lisp is really a specific introduction to the Lisp Way.
10:46:07 <ww_> i guess it depends on what quux' friend wants to do...
10:46:25 <quux> they just want to write everything in haskell
10:46:54 <ww_> what's wrong with that if it makes them happy?
10:47:15 <Welkin> quux: so do I
10:47:22 <Welkin> and many others here
10:47:28 <Welkin> in fact, probably the majority here
10:48:11 <demize> Shocking thought.
10:49:42 <ww> it probably is a good idea to practice another language a bit to know the difference between "learning a language" and "learning to program"
10:50:01 <ww> haskell's probably as solid a base as possible to go there
10:50:33 <Welkin> knowing assembly (and macro assembly, known as C) as well as a high level language
10:53:01 <ww> C is also a good choice for a haskell programmer because it's helpful for making good bindings to libraries
10:54:22 <rowanblush> Regarding this type signature: `keyView :: (Ord k) => k -> Map k v -> Maybe (k, Map k v)` Can anyone think of a more efficient implementation than `keyView k m = (, delete k m) <$> lookup k m)`?
10:55:33 <monochrom> yes, but it requires access to Map internals
10:56:03 <rowanblush> That's what I thought.
10:56:40 <Gurkenglas> Wouldn't that be Maybe (v, Map k v)?
10:56:53 <rowanblush> Right, sorry, typo.
11:02:03 <Zemyla> I have a qiestion about Data.Vector, specifically the Chunk type in Data.Vector.Bundle.Monadic.
11:02:50 <Zemyla> Can anyone who knows it well answer some questions for me?
11:03:39 <kadoban> Zemyla: Asking to ask is always a mistake.
11:06:15 <Zemyla> Okay. Why is the chunk type Chunk v a = Chunk !Int (forall m. (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m ()) instead of Chunk a = Chunk !Int (forall m v. (PrimState m, Vector v a) => Mutable v (PrimState m) a -> m ())?
11:06:34 <Zemyla> It doesn't need to be parametetized on v at all.
11:06:50 <muzzle> Hi, I developed a haskell package to work with file system changes. I would be really glad if i could get any feedback from you guys (code style, do you like it, is it useful to you?) https://github.com/kryoxide/delta
11:07:59 <Zemyla> In fact, even better would be Chunk a = Chunk !Int (forall m v r. (PrimState m, Vector v r) => Mutable v (PrimState m) r -> (a -> r) -> m ()).
11:08:04 <edwardk> Zemyla: Mutable is a family
11:08:17 <edwardk> Chunk a = Chunk !Int (forall m mv. (PrimMonad m, MVector mv a) => mv (PrimState m) a -> m ()) -- would work
11:08:26 <Zemyla> That way, it could be a Functor as well.
11:08:32 <edwardk> guessing the author wrote it, then realized they screwed up
11:08:53 <edwardk> its not functorial, technically, because you can read/write to/from the mutable vector in there
11:08:57 <Zemyla> Also, even without any changes, Chunk could ve a monoid.
11:08:58 <edwardk> its dumb but you can do it
11:10:29 <Zemyla> mempty = Chunk 0 (const $ return ()); mappend (Chunk na pa) (Chunk nb pb) = Chunk (na + nb) (\v -> pa (M.take na v) >> pb (M.drop na v)).
11:11:09 <edwardk> given that 'v' is present it should probably drop the Vector v dictionary being passed
11:11:14 <edwardk> to let it monomorphize outside
11:11:51 <edwardk> as for the instance, Roman Leshchinskiy has a penchant for not defining any instances he's not actually using.
11:12:17 <Zemyla> Hmm. He should at least define everything Typeable.
11:12:43 <edwardk> no longer a concern. 7.10+ makes everything Typeable
11:12:51 <Pamelloes> Really?
11:12:58 <edwardk> and dolio is the new maintainer on vector these days
11:13:14 <edwardk> so if you want Typeable instances retroactively in vector, ask him.
11:13:25 <orion> https://twitter.com/sperbsen/status/403515822607716352
11:14:21 <Pamelloes> orion: My experience has been that cabal does auto-run configure when necessary....
11:15:28 <orion> Pamelloes: I am currently getting that message permanently when I try to run "cabal test" on Ubuntu/ghc 7.10/cabal 1.22
11:15:41 <Pamelloes> :/
11:15:49 <Pamelloes> Have you run cabal clean?
11:16:02 <orion> Yes.
11:16:24 <Pamelloes> Well, that's the extent of my cabal advice....
11:17:00 <demize> `cabal clean`, `make clean`, `have you tried turned it off and on again`...
11:17:06 <Zemyla> But yeah, Chunk looks almost exactly like the kind of type I want for O(1) vector concatenation. In fact, it looks almost entirely like a type I constructed for such.
11:17:38 <edwardk> O(1) vector concatenation will come at the cost of something else
11:18:24 <Zemyla> Well, yes, it comes at the cost of not being able to do anything with said vectors until they're reified as an actual vector.
11:18:43 <edwardk> ok, so you're tackling this as a standard builder affair
11:18:45 <Zemyla> They're like ByteString Builders.
11:18:55 <Zemyla> Precisely.
11:20:50 <Zemyla> But the final type I thought of both makes Chunk a functor and ensures that the builder functions have to be well-behaved and can't inspect already-built parts of the vector.
11:22:37 <Zemyla> Also, they can't care about what kind of vector they're building.
11:22:41 <edwardk> the final type isn't functorial
11:23:20 <edwardk> you're allowed by it to use any of the mutable byte array operations which includes reading... to make it functorial you'd need to know it only wrote
11:23:34 <edwardk> which means making some class for the 'write-only' side of a mutable byte array
11:23:38 <edwardk> which is missing in the vector api
11:23:44 <edwardk> _then_ you can be functorial
11:23:57 <suppi> Hello
11:24:08 <suppi> Can I include a text file with an executable and read it from my code?
11:24:23 <edwardk> suppi: yes.
11:24:29 <suppi> I'm building an interpreter and I'd like to include a file with some "standard functions"
11:24:39 <suppi> edwardk, can you point me in the right direction?
11:24:54 <edwardk> https://github.com/ekmett/hyphenation packages a number of text files using extra-data-files in the cabal file
11:24:56 <suppi> I tried using Paths_ but it didn't exactly do what I hoped
11:24:59 <Zemyla> Well, what I'm saying is that while a Chunk a can technically read a value of type r, it can't turn an r into anything and can't do anything with said r.
11:25:07 <edwardk> and then does evil things to read them at runtime using Paths_foo
11:25:22 <edwardk> suppi: you may want to investigate how i do this in there
11:25:26 <suppi> edwardk, thank you! I will take a look at it
11:26:00 <edwardk> Zemyla: i can make a chunk operation that rotates the values in the sub-array its given access to
11:26:11 <Zemyla> True.
11:26:16 <edwardk> and what i'm saying is that with the API you have there you don't have a way to write an actual _Functor_ instance.
11:26:26 <edwardk> at least not one that isn't horrendous
11:26:43 <edwardk> it'd have to make a new array of the same size a the one it is given, call the original on that, then copy over the values afterwards
11:26:49 <edwardk> yeegods
11:27:03 <edwardk> because you can't map the operations being called
11:27:03 <suppi> edwardk, I didn't find extra-data-files in the cabal file, is this perhaps extra-source-files?
11:27:24 <Zemyla> Nah, singleton a = Chunk 1 (\v f -> M.write v 0 (f a)).
11:27:25 <johnw> yes
11:27:26 <edwardk> suppi: sorry, data-files: https://github.com/ekmett/hyphenation/blob/master/hyphenation.cabal#L35
11:27:37 <johnw> extra-source-files only goes into the tarball
11:27:40 <johnw> data-files gets installed
11:27:49 <suppi> edwardk, oh, ok
11:28:05 <edwardk> Zemyla: oh you have the (a -> r) inside
11:28:08 <edwardk> that fixes it
11:28:14 <Zemyla> Yes, exactly 
11:28:19 <edwardk> Zemyla: i missed your addendum
11:28:36 <edwardk> that little yoneda trick is enough
11:29:03 <Kluns> Does anyone have experience with xhb?
11:29:26 <Zemyla> And with the Monoid operation, there shouldn't be any reason why you would be calling a chunk function on a part of the vector that's already filled.
11:30:04 <Zemyla> Though I did think of a way to have an Applicative instance for Chunk, though. :V
11:30:28 <edwardk> Zemyla: just saying that safer would be to have a more controlled subset of operations
11:30:45 <Zemyla> True, so just functor, monoid, and singleton?
11:30:59 <edwardk> well, the applicative exists, its just terrible =P
11:31:19 <Zemyla> Yeah, that's what I said, it's kind of silly.
11:31:44 <edwardk> actually, it doesn't exist does it. you have to give a size
11:31:52 <edwardk> you can get a semiapplicative / Apply instance
11:32:12 <edwardk> but you don't have an infinite list for the zippy applicative
11:32:21 <Zemyla> It has a size. Chunk a = Chunk !Int (...), remember?
11:32:23 <edwardk> or did you mean the list-like one?
11:32:41 <edwardk> if you want the list-like applicative then return is singleton
11:32:59 <edwardk> if you want the zippy applicative then return requires it giving back an infinitely long vector
11:33:16 <Zemyla> Yeah, return is singleton, and <*> is list-like.
11:33:31 <edwardk> then you can build a whole monad
11:33:47 <orion> When I install the latest cabal from hvr's PPA on Ubuntu 15.04, I see the following output: cabal-install version 1.22.6.0, using version 1.22.4.0 of the Cabal library
11:33:50 <orion> Is that wrong?
11:34:02 <Zemyla> True, but the monad would be basically building the vector, then concatMapping it.
11:34:10 <Zemyla> *foldMapping
11:34:11 <edwardk> Zemyla: didn't say it was useful
11:34:13 <edwardk> just that it existed
11:34:21 <Zemyla> Well, no, but it exists.
11:34:53 <edwardk> I kicked around a bunch of designs in this space with copumpkin a few years back
11:35:00 <edwardk> ultimately never did anything with them though
11:35:04 <Zemyla> You could also make Foldable and Traversable instances by building the vector and folding/traversing those.
11:35:23 <edwardk> (was more concerned with variants on this for streaming calculations with a rolling mutable buffer passed in.)
11:35:54 <edwardk> sure, its basically a finite vector type, just grossly inefficient for most uses
11:36:32 <suppi> edwardk, should I use the embed-file package?
11:36:47 <edwardk> suppi: oh yeah i did switch over to that in the end didn't i?
11:36:59 <Zemyla> Also, I kind of wish that either (a) there was a Vector/MVector instance that could manipulate ByteStrings and Texts, or (b) there was a Chunk instance in Data.Attoparsec for Vectors of Words or Chars.
11:37:05 <edwardk> i gave an option with the distribution of hyphenation to either load dynamically or embed the files
11:37:09 <edwardk> IIRC
11:37:15 <suppi> edwardk, you have some directives: if #EMBED
11:37:28 <suppi> edwardk, yes.
11:37:39 <suppi> edwardk, thanks, I'll use this.
11:38:39 <edwardk> embed-file bakes it into the executable. so IIRC i basically grab the data-dir at compile time if EMBED is set
11:38:47 <edwardk> and i grab it at runtime if it is not
11:38:54 <edwardk> the former yields a larger, self-contained executable
11:39:08 <edwardk> the latter lazily loads stuff from the data-dir using semi-benign effects
11:39:46 <edwardk> the latter doesn't pay for things like icelandic hyphenation if you aren't using it at all
11:39:53 <edwardk> the former pays for everything i support
11:40:31 <edwardk> which bloats the exe by ~2.5 megs or so
11:40:39 <edwardk> i could in theory gzip them or something first i guess
11:40:40 <edwardk> hrmm
11:41:15 <lspitzner> orion: nope, versions of Cabal and cabal-install may differ
11:41:16 <edwardk> that'd cut the overhead down to 1.1 megs
11:41:16 <Zemyla> Hmm, is there executable compression?
11:41:40 <edwardk> well, i can use the zlib package and i could pre-gzip the files and ungzip them when accessing them
11:41:44 <orion> lspitzner: I have no idea why cabal is broken then.
11:41:57 <edwardk> 99.99% of the time this would just be a win
11:42:29 <orion> lspitzner: When I try to run "cabal test" all I get is: "cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.22.2.0, now Cabal-1.22.4.0)."
11:42:40 <orion> Running "cabal clean" doesn't help.
11:43:01 <Zemyla> Also, edwardk, I was thinking about writing a ByteString rope, and then I saw you had made one, so I figured I probably shouldn't bother :P
11:43:26 <edwardk> Zemyla: don't put too much stock in that. i wrote it as an afterthought in an evening a few years ago, then never maintained it =P
11:43:53 <edwardk> hrmm, guess i'll try the zlib thing
11:45:32 <kost_> Hello there, people! Are there any Parsec experts
11:46:47 * ww likes attoparsec, but hardly an expert
11:48:04 <Zemyla> kost_: I've written in Parsec, but I'm not an expert either.
11:49:01 <circ-user-qf7Vl> It looks like class stands for abstract class wheras instance designates a concrete class.
11:49:27 <circ-user-qf7Vl> I wonder why Haskell decided to make this distinction
11:50:06 <circ-user-qf7Vl> We define both abstract and concrete class with same `class` keyword in normal programming languages.
11:50:24 <Zemyla> edwardk: I did realize something I would change about the Rope package, though.
11:50:46 <kadoban> circ-user-qf7Vl: Is it possible you're expecting them to map to what classes are in Java and C++ and such, they're … quite not.
11:50:49 <edwardk> there are lots of things i might change about if it i cared about it any more =)
11:50:53 <kost_> Zemyla: I have a simple question. Say I have a complex parser, constructed by combinators, etc. Is there any way I can get the entire list of parsed tokens along with the parsed value. Something like Parser a -> Parser (a, [t])?
11:51:28 <Zemyla> The monoid the FingerTree measures would not just be the size, but the Builder for the entire ByteString rope as well.
11:52:19 <ww> circ-user-qf7Vl: what haskell calls "class" is sometimes called "interface" in other languages (such as Go)
11:52:25 <edwardk> for 90% of the operations that would be rather expensive
11:53:03 <circ-user-qf7Vl> ww: that is why I called Haskell class `an abstract class`.
11:54:24 <lspitzner> orion: probably caused by https://github.com/haskell/cabal/issues/1938
11:54:47 <lspitzner> which apparently is fixed, but not published yet
11:54:53 <monochrom> even the "Haskell class is like Java interface" analogy is broken
11:55:00 <ww> circ-user-qf7Vl: right, but there is no notion of a "class hierarchy" in the sense that you might be thinking of. instead there are implementations of the interface
11:55:28 <monochrom> here is how: in Java, you can mention an interface name almost everywhere the language expects a type name.
11:55:28 <lspitzner> orion: what package is this?
11:55:33 <monochrom> in Haskell, that is false.
11:55:54 <mizu_no_oto> ww, circ-user-qf7VI: typeclasses differ from interfaces and abstract classes in a major way, though.
11:56:12 <ww> monochrome: true
11:56:22 <Zemyla> edwardk: Would it? It would just be accumulating thunks until it was needed, yes?
11:56:47 <monochrom> if you have heard of "concept" from a C++ proposal, Haskell class is more like it.
11:56:55 <edwardk> Zemyla: my experience is that you spend an awful lot of administrative time building up those thunks
11:57:03 <edwardk> its not as free as i'd like
11:57:07 <circ-user-qf7Vl> do I have to define the whole interface in the instance from scratch, given I have no class hierarchy?
11:57:15 <Zemyla> Though I suppose you could do it with an annotated rope if that's something you needed.
11:57:29 <mizu_no_oto> In particular, OO interfaces bundle implementation and data.  typeclasses put the implementation into a separate 'implemenation dictionary', basically a record/vtable with just the implementation
11:58:14 <ww> mizu_no_oto: yes, that is also the way Go does it
11:58:36 <monochrom> circ-user-qf7Vl, I don't understand the question
11:58:42 <mizu_no_oto> circ-user-qf7Vl: it depends on what you mean by 'from scratch'.
11:58:48 <monochrom> I think it comes with a lot of wrong assumptions
11:58:51 <ww> circ-user-qf7Vl: no you can have default implementations
11:59:01 <kadoban> circ-user-qf7Vl: It'll make more sense if you look at how they're used in practice. I think you're trying to map them into the exact same usage, they don't get used the same way really so it's not even answerable AFAIK.
11:59:10 <mizu_no_oto> circ-user-qf7Vl: also, it's probably helpful to really grok what a typeclass is, and how it's different from OO classes
12:01:21 <edwardk> >>> hyphenate english_US "antidisestablishmentarianism"   ==> ["an","tidis","es","tab","lish","men","tar","i","anism"] --- ok i've switched hyphenation over to use gzip
12:01:58 <monochrom> it is best to comprehend Haskell on its own terms rather than looking for "all languages are similar, just find the change of notation"
12:02:01 <Welkin> >_>
12:02:32 <monochrom> because "all languages are similar, just find the change of notation" became false 20 years go.
12:02:49 <kadoban> Especially since haskell has little in common with the languages most people come in knowing.
12:03:07 * ww finds reasoning by analogy helpful, within limits
12:03:10 <mizu_no_oto> monochrom: only 20 years ago?
12:03:19 <Zemyla> edwardk: Could you add a class in Profubctors that is basically (***) :: p a b -> p c d -> p (a, c) (b, d)? I think it's a superclass of Strong, but I'm not sure.
12:03:41 <monochrom> even between Java and C there is no simple change of notation. your Java code doesn't contain calls to "free()". how do you even translate that to C?
12:03:59 <mizu_no_oto> I'd have said ~60 years ago - Fortran and Lisp are counter-examples
12:04:05 * ww doesn't java
12:04:06 <Zemyla> And similarly (+++) :: p a b -> p c d -> p (Either a c) (Either b d).
12:04:09 <monochrom> mizu_no_oto, it is 20 or 40 or 60 depending on whether you only see mainstream languages
12:04:09 <kadoban> Well, it was never really true at all once there was lisp and algol and fortran at least, probably earlier than that. It was just easy to pretend it was true when everyone used the same boring languages based on the same exact ideas for a while there.
12:04:09 <edwardk> Zemyla: "its complicated"
12:04:19 <edwardk> i'll talk more about this issue later
12:04:26 <Zemyla> Okay.
12:05:02 <edwardk> (on a call)
12:05:20 <monochrom> every time people say "all" or "every", they have implicit constraints
12:05:25 <Zemyla> mizu_no_oto: Don't forget Greenspun's Tenth Rule, though.
12:06:31 <Welkin> in 20 years, all languages will probably look more like haskell (or ML family) than anything else
12:06:57 <monochrom> you know, people say that every year. coinductively.
12:07:01 <Zemyla> Every large-enough Fortran or C program has an informally-specified, buggy, incomplete implementation of half of Common Lisp.
12:07:11 <Zemyla> Including Common Lisp.
12:07:48 <suppi> edwardk, it works. thanks for the help!
12:08:13 * hackagebot consumers 1.0 - Concurrent PostgreSQL data consumers  https://hackage.haskell.org/package/consumers-1.0 (arybczak)
12:38:15 * hackagebot th-printf 0.3.1 - Compile-time printf  https://hackage.haskell.org/package/th-printf-0.3.1 (JoelTaylor)
12:38:55 <Zemyla> Hmm, I'm wondering if there's a way to do copy-on-write in the ST monad in Haskell.
12:40:28 <bitemyapp> Zemyla: https://mail.haskell.org/pipermail/haskell-cafe/2007-June/027429.html
12:46:41 <Zemyla> bitemyapp: Because I was looking into a type I had made, a nondeterministic list in the ST monad with a mutable vector as state.
12:55:55 <Zemyla> And I was trying to figure out if it would be doable with more than one mutable object without hideously bloating.
13:03:27 <Zemyla> Hmm, how many types are there that are Alternative but not Monad?
13:04:30 <shirt> can i use OverloadedRecordFields today?
13:07:03 <geekosaur> ?
13:07:51 <Gurkenglas> Can you recommend a memoizing strategy? (This minimaxes the game NIM.) http://lpaste.net/137201
13:08:39 <Aejay> Gurkenglas: Trees and lists are always pretty good for memosization.
13:08:45 <Aejay> That it, infinite ones.
13:09:25 <Zemyla> And how many of them would support the operation withJust :: (a -> Maybe b) -> f a -> f b, such that withJust f (pure a) = maybe empty pure (f a)?
13:10:04 <mjhoy> de
13:11:43 <Aejay> Zemyla: Alternatives.
13:12:16 <Aejay> Or MonadPlus.
13:12:57 <Zemyla> Aejay: I was asking about Alternatives that aren't Monafs that would still permit that operation.
13:13:42 <Gurkenglas> Aejay, generally I know that, I was just wondering how one might integrate those into a program like the one I pasted that uses hylo
13:26:23 <Gurkenglas> How can I visualize what thunks are forced during a WHNF bringabout?
13:28:00 <nitrix> Zemyla: Isn't your withJust the same as =<< ?
13:29:14 <Aejay> nitrix: Only when f ~ Maybe
13:29:25 <nitrix> Then use mapMaybe?
13:29:34 <Aejay> :t mapMaybe
13:29:35 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:29:50 <Aejay> But generalised to *all* applicatives/alternatives
13:29:51 <Gurkenglas> nitrix, he doesn't want to assume Monad f
13:30:16 <Gurkenglas> Aejay, he wants to see which app/alt support it
13:31:25 <Gurkenglas> Zemyla, a poster child example of an applicative that's not a monad is https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Applicative.html#t:ZipList
13:31:54 <Aejay> Then it clear, right? If it's not a monad, then it can't be done.
13:32:03 <Aejay> ^it's
13:32:09 <nitrix> Well =<< already works with all applicatives, no?
13:32:12 <Gurkenglas> Aejay, how is that clear?
13:32:15 <Aejay> nitrix: ..... no.
13:32:30 <Gurkenglas> nitrix, no, =<< works exactly with those applicatives that are also monads
13:32:33 <hiptobecubic> =<< is just flip (>>=) isn't it? So monads and up.
13:32:40 <Aejay> Gurkenglas: If you think about the algorithm involved, it would have to use `join` at some point.
13:33:09 <Aejay> ...So if it can be a monad, it can be implemented.
13:33:21 <Aejay> or more specifically, MonadPlus.
13:34:58 <Gurkenglas> (Huh, I don't see any instance on https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Applicative.html#t:Alternative that's not also a monad)
13:35:23 <Aejay> @let withJust f a = join $ fmap (maybe mzero return . f) a
13:35:24 <lambdabot>  Defined.
13:35:28 <Aejay> :t withJust
13:35:29 <lambdabot> MonadPlus m => (a1 -> Maybe a) -> m a1 -> m a
13:35:51 <johnw> Gurkenglas: I bet a ZipList could be an Alternative, and it is not a Monad
13:36:27 <Aejay> Relevant: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
13:36:53 <Aejay> > withJust (const Nothing) [1,2,3,4]
13:36:54 <lambdabot>  []
13:37:16 <Gurkenglas> (Zemyla, you probably also want the law withJust Just = id)
13:37:19 <Aejay> > withJust (\x -> if even x then Nothing else Just x) [1,2,3,4]
13:37:21 <lambdabot>  [1,3]
13:37:25 <Aejay> > withJust (\x -> if even x then Nothing else Just x) [1..10]
13:37:26 <lambdabot>  [1,3,5,7,9]
13:38:23 <Zemyla> Gurkenglas: And withJust (const Nothing) = const empty?
13:39:10 <Aejay> Zemyla: I think so, it would just return mzero
13:39:34 <Aejay> And that would satisfy the mzero identity, so it would just be, as you say, const empty.
13:40:54 <Aejay> And, as Gurkenglas said, withJust Just === id
13:41:06 <Gurkenglas> Are there more Alternative laws than just the Monoid laws?
13:41:51 <Aejay> I don't think so...
13:41:54 <Aejay> Let me check...
13:42:06 <Zemyla> Gurkenglas: I think one is f <$> (a <|> b) = f <$> a <|> f <$> b.
13:42:50 <osa1_> does anyone know what are votes in hackage pages for?
13:43:10 <Gurkenglas> There must be more, or Alternative would have been defined on top of Functor, not applicative
13:43:17 <Aejay> Gurkenglas: Hoogle doesn't mention anything other than some v = (:) <$> v <*> many v and many v = some v <|> pure []
13:44:12 <Gurkenglas> Aejay, that's just the default definition of those. There's a law that any alternative implementation of the two is to agree with this
13:44:41 <johnw> Zemyla: I'm pretty sure you can derive that one from the Monoid laws
13:44:55 <Aejay> ^
13:45:14 <Aejay> Alternative is different from Monoid only because of many and some.
13:45:19 <Aejay> And that needs pure!
13:45:50 <Aejay> (<|>) = mappend in the case of Maybe, [], and so on.
13:46:00 <Gurkenglas> I've once looked for anyone using many and some, and the only thing github code search gave me was people implementing it for their instances
13:46:03 <greymalkin> I learned an important lesson yesterday: Don't go building Monads willy-nilly just because you can/now know how to.
13:46:10 <cYmen> What is the recommended version to install ghc >= 7.8 on ubuntu vivid?
13:46:25 <josephle> greymalkin, correct. Build functors and applicatives instead! :P
13:46:49 <Aejay> Gurkenglas: Yeah I have no clue what those two do...
13:47:10 <Aejay> greymalkin: Why?
13:47:13 <greymalkin> In my case, I was hiding too much, and had really over-complicated state monads inside state monads... until the turtles anyway.
13:47:17 <kadoban> cYmen: 7.8.4 or 7.10.1, whichever you prefer. 7.10.1 has some changes and is mostly stable, but still quite new. 7.10.2 is supposed to be out … sometime soonish if the conversations I've been overhearing are correct.
13:47:37 * Aejay pats greymalkin's back in sympathy
13:48:02 <Gurkenglas> > (some $ Just () , many $ Just (), some $ Nothing, many $ Nothing
13:48:04 <lambdabot>  <hint>:1:65:
13:48:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:48:04 <Gurkenglas> > (some $ Just () , many $ Just (), some $ Nothing, many $ Nothing)
13:48:08 <lambdabot>  mueval-core: Time limit exceeded
13:48:09 <greymalkin> I dropped down to one simple monad stack (state/writer/error) for pure logic, and one for the IO that holds that state.
13:48:41 <Aejay> greymalkin: Couln't you have used monad transformers?
13:48:42 <greymalkin> Suddenly found that everything became much easier to understand; implemented yesterday and today (starting from almost scratch) something I've been working on for the last two weeks.
13:48:54 <cYmen> kadoban: and how would I install 7.8.4? Is there a good ppa or do I need to build it myself?
13:49:40 <greymalkin> Aejay: Yeah, I did... lots of them. then I'm trying to swap out StateT Something STM SomethingElse and StateT Something IO SomethingElse and the pure code was getting messy, and the IO code was getting bloated.
13:50:00 <greymalkin> It wasn't a matter of "could I" it was a matter of "at what cost to my sanity"
13:50:10 <kadoban> cYmen: Yeah, there's a PPA https://github.com/bitemyapp/learnhaskell/blob/master/install.md or you can just install it manually, like so: https://gist.github.com/ion1/2815423
13:50:13 <Aejay> I understand.
13:50:52 <cYmen> kadoban: which would you recommend?
13:51:35 <kadoban> cYmen: I do the latter … I tend to avoid PPAs just because … I dunno I don't really trust them, heh. Soon I plan to switch to just using 'stack' and not manually installing GHC or anything at all, though I haven't done that yet.
13:51:56 <johnw> greymalkin: this is one case where mtl can help a lot
13:52:09 <ion> I’m meaning to switch to stack and add that alternative to the gist at some point.
13:52:45 <Aejay> ion.... that's an awesome nam.
13:52:51 <Aejay> ^name
13:53:20 <cYmen> kadoban: stack?
13:54:05 <lpaste_> greymalkin pasted “Event loop for stateful pure logic” at http://lpaste.net/137215
13:54:12 <kadoban> cYmen: https://github.com/commercialhaskell/stack
13:54:13 <greymalkin> johnw: I'm still doing some of that initial transformation; the pain was a great learning experience. But now I have it nicely tucked away in a reuasable corner.
13:54:31 <EWB> hey, so I'm thinking of investing a bunch of time in learning haskell, but I have a few reservations. 1) There aren't as many libraries out there so I may have to reimpliment a lot 2) Finding collaborators for projects might be hard and 3) Is it possible to program in a functional way in python? That miiiight be a happy medium for me
13:54:33 <kadoban> cYmen: I don't really know everything about it yet, but it sounds like a nice idea and seems mature enough.
13:54:35 <lspitzner> osa1_: afaik work in progress, https://www.google-melange.com/gsoc/project/details/google/gsoc2015/dzackgarza/5733935958982656
13:54:37 <greymalkin> Probably not pretty code; but it handles all the cases that I need.
13:55:16 <lspitzner> osa1_: ask dzack for details
13:55:31 <Gurkenglas> Hmm. "loop" sounds a name worthy of being refactored away. You could flip evalStatT and get the forever thing out of the where clause
13:55:31 <EWB> basically I'm worried that I won't be able to use haskell for "real" projects
13:56:11 <greymalkin> EWB: What kind of libraries do you feel are lacking?
13:56:24 <kadoban> EWB: There's quite a few libraries, though not as many as in python probably. There's 1500 people just in here, haskell has a fairly serious following. Even if you can't end up using it, the ideas you learn can be helpful in other languages.
13:56:26 <exio4> EWB: the happy medium rarely enda beibg sweer as a learning method
13:56:51 <voidzero> wut
13:56:54 <exio4> ends being sweet*
13:56:54 <kadoban> EWB: Python is … fairly difficult to do much functionally in. It even has some functional primitives, but the python community is pretty hostile to anything that even smells functional.
13:57:05 <voidzero> exio4 :D
13:57:53 <exio4> EWB: learning Haskell will still improve your toolkit as a programmer
13:58:19 * hackagebot lens 4.12.2 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.12.2 (EricMertens)
13:58:21 * hackagebot vimeta 0.2.1.0 - Frontend for video metadata tagging tools  https://hackage.haskell.org/package/vimeta-0.2.1.0 (PeterJones)
13:58:26 <exio4> voidzero: wut
13:58:42 <edwardk> lens 4.12.2 now with working 'foldByOf'
13:58:43 <greymalkin> Gurkenglas: Yeah, this evolved out of building out this pattern with several actors first, then combining their commonality; e.g. some don't need the ST dispatch, some had initialing code that was not immediately obvious to me -- but overall, I'm proud of the way it came out. This is my first "going-to-production" haskell project.
13:59:03 <voidzero> exio4, oh, your typo made me laugh.
13:59:41 <voidzero> EWB, take a look at https://github.com/dbrattli/OSlash/wiki/Functors,-Applicatives,-And-Monads-In-Pictures
14:00:21 <ww> EWB: do you have any particular projects in mind?
14:00:27 <exio4> voidzero: oh, thought I mistabbed :P
14:00:29 <voidzero> your considerations will probably only be answered to your own satisfaction if you get your feet wet
14:00:35 <voidzero> ^ EWB
14:02:32 <EWB> ww, I'm finishing up a python webapp right now, but I'm thinking of doing a game next. I originally wanted to do the world simulation in C++, but I'm considering doing haskell instead (after smaller projects to get up to speed with the language, of course)
14:02:42 <EWB> voidzero, I'll check it out
14:02:50 <voidzero> it's got pictures :)
14:03:08 <voidzero> oh, the url said that. yeah.
14:03:26 <EWB> greymalkin, I'm not totally sure, it's just something that I've heard and wanted to ask about it
14:04:10 <greymalkin> EWB: Re libraries: https://hackage.haskell.org/packages/
14:09:36 <cow_2001> https://hackage.haskell.org/package/gloss-1.9.3.1 and https://hackage.haskell.org/package/gloss-1.9.4.1 don't have the Hackage documentation. What gives?
14:10:08 <Aejay> cow_2001: I find that gloss is reeeeeeeeallly easy to work out. It comes with examples, check them out.
14:10:22 <cow_2001> O_O
14:11:58 <Aejay> cow_2001, I'm not kidding, I learnt it in about 30 minutes. Give it a shot.
14:12:17 <Hijiri> cow_2001: maybe has to do with them depending on newer base?
14:12:23 <kadoban> cow_2001: The version before 1.9.3.1 has docs, apparently.
14:12:31 <cow_2001> yeah
14:12:34 <Hijiri> if you install gloss you can read the docs on your computer
14:13:38 <EWB> alright, thanks for the responses! I'll spend some time learning the language
14:16:50 <chreekat> cow_2001: cow_2001 to answer your question, Hackage docs are sometimes "non-deterministically" unavailable. I don't know why. Somebody else might.
14:17:05 <cow_2001> O_O
14:17:54 <chreekat> sorry for name-typo :P
14:18:58 <cow_2001> no problem :D
14:19:08 <cow_2001> i'm just stunned such a thing happens O_O
14:22:36 <SrPx> Is there any way to test if an implementation of lamping's abstract algorithm is correct? For example, a term that, if the net reduces it correctly, then the net itself is correct? (Probably not I guess... hmm)
14:25:06 <JamesJRH> Hi. Does anyone know Gabriel Gonzalez's real nick here on Freenode? I was told that he joins this channel sometimes.
14:25:46 <johnw> JamesJRH: Tekmo
14:25:58 <JamesJRH> Nope.
14:26:12 <JamesJRH> Tekmo is registered to someone else.
14:26:18 <JamesJRH> I've just asked.
14:26:41 <johnw> well, nonetheless, if you see Tekmo in here, it's Gabriel
14:27:13 <JamesJRH> So apparently 2 people both using the same nick, but it's not Gabriel who has it registered. :-(
14:27:14 <athan> Is there a monadic combinator for `m Bool -> (a -> m a) -> a -> m a`?
14:27:23 <athan> something like untilM / iterateM?
14:27:36 <Aejay> athan: with what behaviour?
14:27:52 <Aejay> You might be asking for forM
14:27:53 <johnw> JamesJRH: maybe not, but I've spoken to Tekmo in privmsg before, arranged a Google Hangout, and sure enough it was Gabriel that I saw :)
14:27:56 <Aejay> :t forM
14:27:57 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
14:28:03 <athan> Aejay: If the predicate is False, return the latest input, otherwise bind the function again
14:28:05 <Aejay> Ah, that's not it...
14:28:08 <athan> something like a conditional mfix
14:28:21 <Aejay> Aejay: I've seen it before, but I can't quite remember where...
14:28:23 <lisbeth> what's the command to compile file located in /foo that is type .hs
14:29:17 <athan> thing p f x = do p' <- p; if p' then f =<< thing p f x; else return x
14:29:21 <athan> Aejay ^
14:29:37 <athan> hmm
14:29:48 <Aejay> :t \p f x -> do p' <- p; if p' then f =<< thing p f x; else return x
14:29:49 <lambdabot> Not in scope: ‘thing’
14:30:01 <athan> lisbeth: I suggest you learn cabal packages, but you're probably thinking of `ghc --make foo.hs`
14:30:01 <Aejay> @let thing p f x = do p' <- p; if p' then f =<< thing p f x; else return x
14:30:03 <lambdabot>  Defined.
14:30:06 <Aejay> :t thing
14:30:07 <lambdabot> Monad m => m Bool -> (a -> m a) -> a -> m a
14:30:24 <Aejay> athan: Check out https://hackage.haskell.org/package/monad-loops-0.3/docs/Control-Monad-Loops.html
14:30:35 <athan> I might have the monadic execution in the wrong order though
14:30:42 <athan> Aejay: There's where I was just at :P
14:31:24 <Aejay> Ah, then you've made a new function. Let's test it:
14:31:43 <athan> :D!
14:32:07 <athan> p /should/ be affected by newer recursive calls
14:32:20 <Aejay> > take 5 $ [True, False] (return . (+1)) 1
14:32:22 <lambdabot>      Couldn't match expected type ‘(Integer -> m0 Integer)
14:32:22 <lambdabot>                                    -> Integer -> [a]’
14:32:22 <lambdabot>                  with actual type ‘[Bool]’
14:32:51 <athan> which i think is sound so far in my implementation
14:32:56 <Aejay> > take 5 $ thing [True, False] (return . (+1)) 1
14:32:58 <lambdabot>  *Exception: stack overflow
14:33:03 <Aejay> athan: I think you're right.
14:33:09 <cow_2001> I have a square! :D
14:33:09 <Aejay> Oh dear, stack overflow...
14:33:18 <Aejay> :}
14:33:21 * hackagebot sneathlane-haste 1 - A compositional web UI library, which draws to a Canvas element  https://hackage.haskell.org/package/sneathlane-haste-1 (JasonPriestley)
14:33:33 <AaronFriel> I'm hitting a heisenbug in QuickCheck which has me pulling my hair out
14:33:37 <Aejay> > take 5 $ thing [False] (return . (+1)) 1
14:33:39 <lambdabot>  [1]
14:34:07 <AaronFriel> Could someone help take a look at this? Anyone familiar with QuickCheck?
14:34:33 <Aejay> AaronFriel: Post it on http://lpaste.net/new/haskell
14:34:49 <AaronFriel> It's more than... a small snippet
14:34:54 <Aejay> Ah.
14:34:54 <AaronFriel> I mean lpaste couldn't compile it
14:35:14 <Aejay> Is it a parse error?
14:35:30 <AaronFriel> Not a compile error, a runtime test pass/fail issue
14:35:31 <AaronFriel> http://i.imgur.com/JlVUL9s.png
14:35:32 <Aejay> What exactly is the problem?
14:35:50 <athan> > take 5 $ thing [<6] (return . (+1)) 1
14:35:52 <lambdabot>      A section must be enclosed in parentheses thus: (< 6)
14:35:57 <AaronFriel> There is a line of code in that screenshot, all it does is print out a variable (literally, putStrLn $ show opAttribute)
14:36:02 <athan> > take 5 $ thing [(< 6)] (return . (+1)) 1
14:36:04 <lambdabot>      Couldn't match expected type ‘Bool’
14:36:04 <lambdabot>                  with actual type ‘Integer -> Bool’
14:36:04 <lambdabot>      In the expression: (< 6)
14:36:04 <AaronFriel> If that line is there, the tests pass
14:36:11 <athan> merp
14:36:13 <AaronFriel> If that line is there, the tests fail
14:36:16 <AaronFriel> is not there*
14:36:22 <athan> ha. nvm, thanks Aejay
14:36:24 <Aejay> athan: There's a nice one similar to that called filterM
14:36:35 <Aejay> :t filterM
14:36:36 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
14:36:59 <athan> Aejay: Yeah that one is great
14:37:07 <athan> I'm thinking of calling this `tillM`
14:37:31 <AaronFriel> Aejay: Specifically, if that line of code is that that does "show opAttribute", the equality test on the next line succeeds every time. (Even though it doesn't look at "opAttribute"?)
14:37:55 <hackrilehe> how are you defining tilllM?
14:37:59 <AaronFriel> Aejay: But if the line is not there, then with some probability > 0, the FFI calls get mixed up and the equality fails, and the test fails.
14:39:26 <hackrilehe> is calling this printing function accessing something the tests do not? is it chaging something the thests need by foring lazy evaluation through referencing it?
14:39:40 <Aejay> AaronFriel: I really don't know in this case...
14:40:21 <hackrilehe> i think you would have to reproduce the bug in the smallest code to understand it
14:40:49 <hackrilehe> perhas as it is FFI you dont get imutability on reference as in haskell
14:41:20 <athan> hackrilehe: tillM p f x = do p' <- p; if p' then f =<< tillM p f x; else return x
14:41:53 <AaronFriel> hackrilehe: So the test I'm performing with the database is basically a "read modify write - read again to make sure the operation succeeded"
14:42:29 <AaronFriel> hackrilehe: In this case, I'm "put"ing, a value to the kv store, modifying it, then "get"ing it back and checking to see if the modify did the right thing.
14:43:00 <AaronFriel> hackrilehe: I don't understand how the value could be nondeterministic, but I don't know how QuickCheck works?
14:43:01 <Cale> AaronFriel: That's odd. It's typically not observable whether any particular variable has been evaluated (apart from using low-level GHC heap inspection stuff)
14:43:32 <hackrilehe> is QC.run blocking?
14:43:49 <athan> no wait mine is wrong
14:44:08 <hackrilehe> if i tried to open a file handel which was already open i would have trouble reading from it
14:44:09 <athan> hackrilehe: tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x
14:44:11 <AaronFriel> hackrilehe: QuickCheck docs say it's for embedding monadic/IO actions, but don't say if it's blocking
14:44:34 <hackrilehe> :t (=<<)
14:44:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:44:45 <Cale> run :: Monad m => m a -> PropertyM m a
14:44:49 <Cale> It's just a lifting operation
14:44:52 <AaronFriel> Cale: Yeah
14:45:00 <Cale> It'll block if and only if the action you give it blocks
14:45:19 <Cale> While printing opAttribute there may force its evaluation causing subsequent tests to run faster, it shouldn't have any effect on their outcome
14:45:40 <Cale> Which test actually fails?
14:45:59 <AaronFriel> Cale: It's a blocking op, -- well it's actually async but each call returns (IO (IO a)), so you can "join" and get a synchronous call 
14:46:01 <hackrilehe> AaronFriel: try putting something to force the bugy print function to complete before proceeding, i know its not great but i use _ <- getLine, if anyone has a better way to do this please say now!
14:46:03 <Twey> Is GHCJS included in GHC these days?  I thought I heard it was
14:46:10 <pharaun> Philonous: ahh good to know, yeah it was mostly a bad combo of 2:20am tiredness, and frustration that made me miss the conversion functions. I was able to make xml-conduit parse my xml then do the conversion to xml-type and it worked great from that point on :D
14:46:18 <AaronFriel> Cale, hackrilehe: If I put the print operation anywhere before the comparison, the test succeeds.
14:47:08 <Cale> Is there somewhere that I can grab this code?
14:47:33 <JamesJRH> johnw: Okay, well when I do get in touch with Gabriel in another way, I'll ask him to resolve the naming collision so that I can be sure that things like MemoServ will go to the right person. Either he should use a variation of Tekmo or, if he feels that the nick should be his (I see that he's known as Tekmo elsewhere on the Internet), then he should try
14:47:38 <JamesJRH> to resolve it with the person who has Freenode/Tekmo registered or with Freenode staff.
14:48:21 <hackrilehe> AronFriel: which comparison are you referring too?
14:48:37 <Cale> Also, what is localOp?
14:49:01 <hackrilehe> @let tillM p f x = do p' <- p; if p' then f =<< tillM p f x; else return x
14:49:03 <lambdabot>  Defined.
14:49:13 <lisbeth> If I wanted to install ghc into a chrooted environment, what packages would I need to move?
14:49:15 <hackrilehe> :t tillM
14:49:16 <lambdabot> Monad m => m Bool -> (a -> m a) -> a -> m a
14:49:16 <augur> whats the standard idiom for when you want to program monadically with one monad, inside a context of a larger monad?
14:49:27 <AaronFriel> hackrilehe, Cale: The comparison is on line 297
14:49:52 <augur> ive got some stuff that returns Either e a and i want to program monadically with Either, but at the "leaves" so to speak, i want to use IO
14:49:56 <athan> hackrilehe: That's the wrong implementation
14:49:59 <AaronFriel> Cale: Let me commit the code, but you'll need the Hyperdex libs from hyperdex.org to compile
14:50:00 <athan> @unset tillM
14:50:00 <lambdabot> Unknown command, try @list
14:50:05 <athan> mer
14:50:10 <lisbeth> would it just be ghc and it's dependencies?
14:50:31 <Cale> lisbeth: You'll also probably need libgmp
14:50:31 <athan> @let tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x
14:50:32 <lambdabot>  .L.hs:174:1: Warning:
14:50:32 <lambdabot>      Pattern match(es) are overlapped
14:50:32 <lambdabot>      In an equation for ‘tillM’: tillM p f x = ...
14:50:48 <hackrilehe> @undefine
14:50:48 <lambdabot> Undefined.
14:50:50 <athan> :|
14:50:53 <athan> ah thanks
14:50:57 <athan> @let tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x
14:50:58 <lambdabot>  Defined.
14:51:08 <hackrilehe> :t tillM
14:51:09 <lambdabot> Monad m => m Bool -> (b -> m b) -> b -> m b
14:51:13 <athan> this way the fixed thread actually gets run
14:51:48 <hackrilehe> > tillM (return False) (Just) 0
14:51:49 <lambdabot>  Just 0
14:52:00 <hackrilehe> cool
14:52:31 <AaronFriel> Cale: I'm not sure if you want to go through all the work of building & testing, but if you do I have a commit pushed that you can try out
14:53:05 <athan> runState (tillM ((== 5) =<< get) (\a -> modify (+1) >> return (a+1)) 0) 0
14:53:22 <athan> > runState (tillM ((== 5) =<< get) (\a -> modify (+1) >> return (a+1)) 0) 0
14:53:23 <lambdabot>      Couldn't match type ‘Bool’ with ‘StateT s Identity Bool’
14:53:24 <lambdabot>      Expected type: s -> StateT s Identity Bool
14:53:24 <lambdabot>        Actual type: s -> Bool
14:53:34 <hackrilehe> can you world with the bug? it seems like it might actually be just that the tools you are using should not be used in the way you were trying to use them?
14:53:37 <Welkin> athan: hello
14:53:42 <hackrilehe> work*
14:53:48 <athan> Welkin: o/ :D
14:53:50 <athan> how's it going?
14:53:55 <Welkin> good!
14:54:17 <Welkin> let's go to -blah
14:54:22 <Cale> AaronFriel: all right, I'll give it a try. I'm curious what might be going on here.
14:54:46 <AaronFriel> hackrilehe: To give you an idea of the test failure, this is a database lib. So in a microcosm example, imagine I did "push key 5", then "modify key (+1)", then "get key". And in the tests, sometimes I get 5, and sometimes I get 6.
14:54:55 <AaronFriel> hackrilehe: Unless I have that print statement.
14:55:20 <hackrilehe> > \ x runState (tillM (return (x== 5) ) (\a -> modify (+1) >> return (a+1)) 0) 0
14:55:21 <lambdabot>  <hint>:1:40:
14:55:21 <lambdabot>      Parse error in pattern: \ a -> modify (+ 1) >> return (a + 1)
14:55:32 <athan> > runState (tillM ((<= 5) =<< get) (\a -> modify (+1) >> return (a+1)) 0) 0
14:55:33 <lspitzner> AaronFriel: have you tested if the printing or the effective deepseq is the cause?
14:55:34 <lambdabot>      Couldn't match type ‘Bool’ with ‘StateT s Identity Bool’
14:55:34 <lambdabot>      Expected type: s -> StateT s Identity Bool
14:55:34 <lambdabot>        Actual type: s -> Bool
14:55:34 <Cale> AaronFriel: I don't see how printing that could possibly affect anything.
14:55:41 <athan> mer
14:55:43 <AaronFriel> Cale: Me neither?
14:55:59 <AaronFriel> lspitzner: I just added deepseq as a dependency and am going to see if throwing that in fixes it
14:56:08 <hackrilehe> its c there is crazyess!
14:56:18 <AaronFriel> Cale: You'll need HyperDex from Cale: http://hyperdex.org/download/
14:56:24 <AaronFriel> oops, double copy-paste
14:56:27 <Cale> AaronFriel: Yeah, I have it
14:56:29 <AaronFriel> kk
14:56:33 <AaronFriel> https://github.com/AaronFriel/hyhac/tree/testfail
14:57:00 <athan> > runState (tillM (liftM (<= 5) get) (\a -> modify (+1) >> return (a+1)) 0) 0
14:57:01 <lambdabot>  (6,6)
14:57:09 <athan> >:D
14:57:20 <AaronFriel> Cale: That's my git repo, to spin up the HyperDex instance run ./scripts/start-hyperdex.sh in a background shell (I run the daemon in the foreground so I can monitor it)
14:57:33 <AaronFriel> Cale: To compile: "cabal configure -f tests --enable-tests"
14:57:50 <AaronFriel> Cale: And to run: ./dist/build/tests/tests -t "a space" -t "int-int/add"
14:57:58 <hackrilehe> athan: can you explain to me what its doing?
15:03:54 <auu> howdy
15:04:17 <Aejay> Yo.
15:04:34 <auu> What are some things you guys are building with Haskell?
15:04:47 <Aejay> All sorts of stuff.
15:05:16 <Aejay> I've built parsers and pretty printers, for instance.
15:05:30 <Aejay> All in marvellously beautiful ways.
15:06:04 <hackrilege> im writing chemestry simulation
15:06:05 <auu> Ah nice. For personal use?
15:06:16 <hackrilege> and trading tools
15:06:23 <auu> Trading tools?
15:06:27 <hackrilege> yars
15:06:32 <AaronFriel> Cale: Sorry for my absence, someone came to my door
15:06:32 <auu> Like a backtester?
15:06:36 <hackrilege> but of signal processing and a web socket
15:06:41 <hackrilege> bit*
15:06:56 <hackrilege> and some money to lose... or not really
15:06:58 <athan> hackrilege: Well, not yet :)
15:07:02 <athan> I will though!
15:07:03 <Zemyla> Why in God's name do the types in GHC.Generics not derive Functor.
15:07:30 <athan> first, though - can someone explain to me if the strictness semantics, monadically, differ between `liftM`, `=<<` and `>>=`?
15:07:31 <hackrilege> athan: sorry i dropped my connection, what are you saying!?
15:07:54 <Welkin> @info liftM
15:07:54 <lambdabot> liftM
15:08:01 <athan> hackrilege: Oh, the stuff with `tillM`
15:08:09 <athan> lawls
15:08:10 * auu
15:08:12 <hackrilege> yeh
15:08:34 <hackrilege> :t liftM
15:08:35 <athan> :t liftM
15:08:35 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:08:36 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
15:08:39 <hackrilege> :t =<<
15:08:40 <lambdabot> parse error on input ‘=<<’
15:08:45 <athan> :t (=<<)
15:08:46 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:08:46 <hackrilege> :t (>>=)
15:08:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:08:50 <hackrilege> :t (=<<)
15:08:51 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:08:53 <athan> AH
15:08:54 <athan> derp
15:09:09 <athan> But, do =<< and >>= evaluate in opposite order?
15:09:17 <ttt_fff> what's a good symbol for 'envLookup' (since lookup is (!)) 
15:09:40 <athan> ie; would `f =<< x` first evaluate `x` before the monadic result of `f`?
15:09:48 <Welkin> ttt_fff: why do you need a symbol?
15:09:51 <fizbin> @src (=<<)
15:09:52 <lambdabot> f =<< x = x >>= f
15:09:57 <athan> and would `x >>= f` evaluate `f` before `x`?
15:10:04 <athan> ahh hell
15:10:13 <ttt_fff> Welkin: ask not y; ask y not
15:10:45 <Welkin> wainaught
15:10:47 <Welkin> y0
15:10:58 <hackrilege> y not use a symbol?
15:11:17 <hackrilege> @src tillM
15:11:17 <lambdabot> Source not found. I am sorry.
15:11:22 <Cale> AaronFriel: That's okay, I'm still building dependencies :)
15:11:23 <Welkin> athan: =<< is infixr 1
15:11:25 <hackrilege> tillM
15:11:30 <hackrilege> > tillM
15:11:31 <lambdabot>      No instance for (Typeable m0)
15:11:31 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
15:11:31 <lambdabot>        arising from a use of ‘show_M776593633912969585816108’
15:11:32 <athan> Welkin: Yeah :\
15:11:40 <athan> I'm trying to devise some other dastardly plan
15:11:46 <Welkin> >>= is infixl 1
15:11:51 <hackrilege> ok so we can only get the source of things in the hackage repo..
15:12:09 <hackrilege> athan: can i get the source t tillM again?
15:12:21 <kadoban> hackrilege: @src is not very reliable or useful, it's not necessarily true and it's not very complete. It just pulls from a text file that's custom built.
15:12:27 <fizbin> So, athan, in general the question of when stuff gets *evaluated* is tricky and possibly hard to determine with laziness, etc. You can however sensibly ask about the order of monadic side effects.
15:12:33 <athan> @let tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x -- hackrilege :)
15:12:34 <lambdabot>  .L.hs:145:1: Warning:
15:12:34 <lambdabot>      Pattern match(es) are overlapped
15:12:34 <lambdabot>      In an equation for ‘tillM’: tillM p f x = ...
15:12:53 <kadoban> hackrilege: Basically you just shouldn't use it …
15:12:57 <athan> fizbin: Yeah, I'm working through it right now, not my first rodeo :) thanks though
15:13:09 <hackrilege> ok kadoban: thanks
15:13:39 <fizbin> And so far as side effects go, there's not really a way to order the side effect for "f" first.
15:13:54 <fizbin> At least, if "f" retains the type a -> m b
15:14:09 <John[Lisbeth]> Have there been any attempts to make a minimal chroot with the ability to run haskell?
15:14:11 <athan> fizbin: Idk I've ran into this before doing debugging, I wonder if I could `force` stuff around
15:14:46 <fizbin> If "f" can be changed to have type m (a -> b) then it's a different story, and you can get all sorts of side effect ordering.
15:14:47 <hackrilege> cool so we apply the IO function untill it returns false.
15:15:32 <hackrilege> John: i have built haskell in gnuroot, but not chroot
15:15:53 <athan> > evalState (tillM (liftM (<= 5) get) (\a -> modify (+1) >> return (a+1)) 0) 0
15:15:54 <lambdabot>  6
15:15:59 <athan> > evalState (tillM (liftM (<= 5) get) (\a -> modify (+1) >> return (a+1)) 0) 6
15:16:01 <lambdabot>  0
15:16:08 <athan> HA okay
15:16:11 <athan> I was wrong, this is correct
15:16:54 <Aejay> athan: Aha, good test.
15:16:57 <John[Lisbeth]> hackrilege do you think I could pick your brain on the topic in pm?
15:17:01 <athan> so you can give a monadic boolean test, and the modifying thread with an initial input, and you'll get the monadic result until the test is false
15:17:08 <athan> Aejay: lol
15:17:31 <Cale> AaronFriel: ah, you have -Wall and -Werror on, which made it not build for me initially. I don't know how you live with those options turned on, -Wall complains about a lot of things which are not problematic :)
15:17:44 <athan> or really, it runs the pure thread as many times as the stateful thread is satisifed by the stateful predicate
15:18:06 <Cale> okay, got the tests running, let's see if I can figure out what's happening
15:18:08 <hackrilege> John, i dont have too much time, and maybe some of the considerations would be best with another set of eyes looking at it, im a bit noob and some of these guys can help me out if i say stupid stuff
15:18:13 <Peaker> Cale, non-exhaustive is very problematic :)
15:18:23 <Peaker> (I think that's what you mean there?)
15:18:27 <athan> Aejay: ^ :)
15:18:30 <John[Lisbeth]> Oh well you should probably publish it so other people can see
15:18:52 <Cale> Peaker: Well, and lots of other things, like unused-do-binds and such
15:19:08 <Peaker> Cale, throwing away information is likely indicator of bugs too
15:19:30 <Cale> Peaker: In this case, it was redundant imports of Control.Applicative
15:19:38 <Peaker> (and I can take 100 false positives for 1 true bug, given that a bug costs a lot more than 100 times tiny minor fixes)
15:19:53 <hackrilege> :t (liftM (<5) get)
15:19:54 <lambdabot> (Num a1, Ord a1, MonadState a1 m) => m Bool
15:19:54 <Cale> Well, sure, but if you *also* have -Werror turned on, it's obnoxious
15:19:59 <Peaker> Cale, I use base-compat to get a consistent API across GHC versions so I don't have redundant imports
15:20:07 <hackrilege> :t get
15:20:08 <lambdabot> MonadState s m => m s
15:20:09 <athan> Cale: hey, have you seen this `tillM` construct anywhere else, maybe by a different name?
15:20:17 <athan> :t tillM
15:20:18 <Cale> athan: tillM?
15:20:18 <lambdabot> Monad m => m Bool -> (b -> m b) -> b -> m b
15:20:24 <Peaker> Cale, ghc --make doesn't "replay" old warnings, so you lose them and get bugs without -Werror :(
15:20:39 <AaronFriel> Cale: I have them on so I don't slip up for releases. I probably forgot to commit the changes so that they're not on while developing
15:20:42 <Cale> athan: I dunno, looks like something from monad-loops or whatever that package is called
15:20:51 <athan> Cale: Yeah, I just made it - it basically iterates until the monadic predicate is falsified
15:20:52 <hackrilege> athan: he needs the source
15:20:58 <athan> Cale: I can't find it in there :(
15:21:10 <athan> Cale: -- tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x -- hackrilege :)
15:21:16 <athan> er yeah
15:22:21 <kadoban> athan: Isn't "till" as-in short for until totally backwards in meaning there? That sounds like it should iterate until it's /true/
15:22:53 <athan> kadoban: I've seen the same functionality with that name too, sorry I'm being confusing
15:22:58 <athan> I just chose the name on a whim
15:23:13 <hackrilege> tillM' p f x = if (f x >>= p) then f x else x
15:23:29 <hackrilege> @let tillM' p f x = if (f x >>= p) then f x else x
15:23:31 <lambdabot>  .L.hs:148:20:
15:23:31 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘m b’
15:23:31 <lambdabot>      Relevant bindings include
15:23:49 <Cale> AaronFriel: Okay, the tests seem to fail the same way for me regardless of whether that putStrLn is there
15:23:55 <athan> hackrilege: `if` expects a type Bool, not `m Bool` :)
15:24:05 <AaronFriel> Cale: Do you have HyperDex running?
15:24:17 <Zemyla> But yeah, I really want Functor, Foldable, and Traversable instances for all the Generics types, Applicative for all of them except V1 and (:+:), and also a pony.
15:24:17 <athan> kadoban: `through`, maybe?
15:24:19 <AaronFriel> Cale: And if so, try the simplest set of tests: run with: -t "a space"
15:24:25 <hackrilege> there is no monad if?
15:24:35 <AaronFriel> Cale: Those two tests basically add and remove the key value table.
15:24:35 <athan> so it applies `f` "though" the monadic predicate?
15:24:42 <kadoban> athan: 'whileM' ?
15:24:49 <athan> kadoban: Already taken :\
15:25:06 <Peaker> Did GHC 7.10 improve performance of output programs? I heard a few anecdotes where it regressed :(
15:25:08 <hackrilege> :t whileM
15:25:09 <lambdabot> Not in scope: ‘whileM’
15:25:23 <athan> :t Control.Monad.Loops.whileM
15:25:24 <lambdabot> Monad m => m Bool -> m a -> m [a]
15:25:48 <kadoban> Ah hmm
15:25:49 <hackrilege> @src Control.Monad.Loops.whileM
15:25:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:25:58 <athan> Peaker: From what I see, my Wai apps are 20% faster at least with 7.10
15:26:04 <hackrilege> rutabaga! lol, rabbit 
15:26:08 <Peaker> athan, cool!
15:26:16 <athan> :)
15:27:11 <Cale> AaronFriel: Okay, that test appears to work regardless of whether the line is commented out or not
15:27:20 <AaronFriel> Cale: Yep, those tests are much simpler
15:27:42 <AaronFriel> Cale: The tests that I am working with can be run with arguments such as: -t "int-int"
15:28:06 <hackrilege> @let tillM' p f x = do b<- (f x >>= p); if b then f x else x
15:28:07 <lambdabot>  Defined.
15:28:20 <AaronFriel> Cale: The HyperDex KV store supports a bunch of different data types, each test tries to round-trip some value through the database
15:28:27 <athan> :t tillM'
15:28:28 <lambdabot> Monad m => (b -> m Bool) -> (m b -> m b) -> m b -> m b
15:28:52 <hackrilege> :t tillM
15:28:53 <AaronFriel> Cale: The "int-int/add" ones attempt to push a "HYPERDATA_MAP_INT64_INT64" value, run a "map_atomic_add" on it, and then get that value back.
15:28:53 <lambdabot> Monad m => m Bool -> (b -> m b) -> b -> m b
15:29:02 <athan> hackrilege: my version allows the predicate to be independent from the input type
15:29:20 <athan> but it was close :)
15:30:01 <hackrilege> tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x 
15:30:25 <Cale> AaronFriel: I get all 7 tests failing for int-int regardless of whether the putStrLn is there
15:30:38 <hackrilege> i forgot the recursive call doh!
15:31:39 <Cale> AaronFriel: er hmm
15:31:52 <Cale> AaronFriel: I don't even see where the putStrLn is executed
15:31:59 <athan> bitemyapp: ping!
15:32:07 <athan> ever seen this?
15:32:10 <athan> :t tillM
15:32:11 <lambdabot> Monad m => m Bool -> (b -> m b) -> b -> m b
15:32:13 <hackrilege> can you explain how you use get with your tillM?
15:32:26 <athan> bitemyapp: -- tillM p f x = do p' <- p; if p' then tillM p f =<< f x; else return x
15:32:54 <athan> it's kinda like an...
15:32:54 <hackrilege> > evalState (tillM (liftM (<= 5) get) (\a -> modify (+1) >> return (a+1)) 0) 0
15:32:56 <lambdabot>  6
15:32:56 <athan> almostFix
15:32:59 <athan> or something
15:33:16 <AaronFriel> Cale: Line 296 of Pool.hs should have it in your commit
15:33:20 <hackrilege> :t fix
15:33:21 <lambdabot> (a -> a) -> a
15:33:27 <athan> if `almostFix :: (a -> Bool) -> (a -> a) -> a -> a`
15:33:33 <athan> then `almostFixM = tillM`
15:33:33 <hackrilege> i dont know what does fix
15:33:37 <AaronFriel> Cale: Would a private chat work better?
15:33:44 <Cale> AaronFriel: I mean, yes, that's what I've been editing in and out
15:33:46 <athan> hackrilege: it appends those functions together forever
15:33:52 <athan> @src fix
15:33:52 <lambdabot> fix f = let x = f x in x
15:33:57 <Cale> But I don't see the output which would have been generated by that putStrLn
15:34:00 <Aejay> athan: not quite. Think about bindings.
15:34:01 <hackrilege> so you have takewhile almostfixm
15:34:06 <athan> ~ f (f (f (f ...)))
15:34:17 <AaronFriel> Cale: Does your test immediately fail w/o output?
15:34:20 <Cale> (I tried adding a bunch of recognisable garbage to the front of it, and I don't see it in the output)
15:34:20 <hackrilege> f.f.f.f.f.f.f
15:34:33 <zachk> can i use: use, %= etc. from Control.Lens with StateT? 
15:34:34 <athan> Aejay: Bindings? You mean evaluation?
15:34:43 <athan> hackrilege: yep :)
15:34:44 <Aejay> athan: no, as in (>>=)
15:34:55 <athan> ?
15:35:04 <lpaste_> Cale pasted “test results” at http://lpaste.net/137221
15:35:12 <Cale> AaronFriel: ^^
15:35:29 <glguy> zachk: You can use them with any MonadState instance
15:35:36 <athan> Aejay: So like mfix? :S
15:35:40 <Aejay> @let almostFix p f a = if p a then a else almostFix p f (f a)
15:35:41 <Cale> AaronFriel: That's with  QC.run . putStrLn $ "!!!!!!! " ++ show attributeName
15:35:41 <lambdabot>  Defined.
15:35:44 <bitemyapp> athan: I don't think I've seen that before.
15:35:44 <AaronFriel> Cale: Oh! I forgot to tell you
15:35:49 <bitemyapp> athan: it makes sense though
15:35:53 <AaronFriel> Cale: Try running it -t "a space" -t "int-int/add"
15:35:54 <Aejay> athan: Eh I guess so.
15:36:04 <athan> bitemyapp: :D
15:36:07 <AaronFriel> Cale: The test you're running assumes the table exists in the kv store
15:36:07 <athan> :::D
15:36:13 <Cale> okay, now I get more output
15:36:23 <AaronFriel> Cale: The "add a space", "remove a space" tests bracket all the other tests
15:36:36 <athan> Aejay: I think this is sub-fixpoint stuff, though
15:36:56 <Aejay> athan: :t almostFix
15:36:59 <Aejay> :t almostFix
15:37:01 <lambdabot> (t -> Bool) -> (t -> t) -> t -> t
15:37:09 <Aejay> I just defined it
15:37:17 <athan> Yeah :)
15:37:27 <Cale> AaronFriel: Okay, so while I get much more output in both cases, an identical number of passes/failures occur for that with and without the putStrLn
15:37:29 <athan> Aejay: Thanks
15:37:35 <Aejay> Np
15:37:41 <Cale> If you want, I can paste the output in both cases
15:37:59 <AaronFriel> Cale: I'd appreciate that.
15:38:03 <AaronFriel> Cale: I get passes with the putStrLn
15:38:22 <zachk> glguy: why doesn't this work? :  http://lpaste.net/137222
15:38:27 <Aejay> @let almostFixM p f a = bool <- liftM p a; if bool then a else almostFixM p f (f =<< a)
15:38:27 <lambdabot>  Parse failed: Parse error: <-
15:38:33 <Aejay> @let almostFixM p f a = do bool <- liftM p a; if bool then a else almostFixM p f (f =<< a)
15:38:34 <lambdabot>  Defined.
15:38:37 <Aejay> :t almostFixM
15:38:38 <lambdabot> Monad m => (a -> Bool) -> (a -> m a) -> m a -> m a
15:38:52 <athan> I disagree with that implementation
15:38:57 <Aejay> GO on?
15:39:02 <Aejay> Why?
15:39:17 <lpaste_> Cale pasted “with the putStrLn” at http://lpaste.net/137223
15:39:26 <athan> I think that `almostFixM`'s predicate should be independent from the pure data
15:39:34 <glguy> zachk: I give up, what was the error
15:39:47 <athan> and likewise, it should only extend the `a -> m a` structure into a longer one, not mutate it into `m a -> m a`
15:39:59 <Aejay> I'll test it a mo
15:40:22 <lpaste_> Cale pasted “without putStrLn” at http://lpaste.net/137225
15:40:33 <athan> I think that `almostFix`'s predicate _can_ depend on the pure data, but I feel like this is already implemented
15:40:36 <AaronFriel> Cale: You're not printing "opAttributes" with your print statement?
15:40:42 <glguy> zachk: My guess is that you've installed two versions of the 'transformers' package and that you're trying to use both of them at the same time
15:40:46 <zachk> glguy: here is the error http://lpaste.net/137224
15:40:50 <dominik> hey haskellers,
15:40:53 <zachk> oh how would I check that? 
15:40:56 <Cale> AaronFriel: Oh, you had show attributeName there
15:40:56 <athan> with almostFixM, we're relying only on the monad for the "almost"-ness, while fix-ing the pure data
15:41:02 <Cale> AaronFriel: Not opAttributes
15:41:03 <glguy> zachk: It looks like my guess was right!
15:41:05 <athan> Aejay: ^
15:41:06 <dmj`> dominik: oh hai
15:41:06 <Cale> I could try that :)
15:41:12 <AaronFriel> Cale: Oops
15:41:16 <zachk> glguy: what do I do to fix it ....
15:41:20 <dmj`> athan: ! 
15:41:24 <AaronFriel> Cale: I've been trying a few different things to see if forcing other values causes tests to pass
15:41:28 <athan> dmj`: :D!!!
15:41:29 <glguy> zachk: when you type ghc-pkg list mtl, you should notice more than one entry
15:41:31 <athan> what's up :)
15:41:40 <dominik> could anyone explain me what the total time of a program run with `+RTS -p` measures? 
15:42:01 <Cale> okay, now it succeeds, interesting
15:42:05 <dmj`> athan: long time no talk bro
15:42:23 <dominik> for instance when I profile my program with `+RTS -p`, it says the total running time is (say) 60 seconds
15:42:42 <zachk> glguy: yes I do, what now, and which one should I get rid of and how? 
15:42:43 <dominik> however, the unix time command tells me that this same program took 85 seconds to run
15:42:44 <glguy> zachk: You need to build whatever you're building using the same version of mtl that you built lens against. You can see which version you build lens against with "ghc-pkg describe lens"
15:43:04 <glguy> zachk: You can unregister packages with "ghc-pkg unregister <thepackagename>"
15:43:11 <zachk> glguy: could I just rebuild lens with --force-reinstalls? 
15:43:21 <Aejay> athan: I see.
15:43:22 <glguy> I'd recommend never ever using --force-reinstalls
15:43:42 <dominik> does therefore anyone know how to explain the time discrepancy between GHC's +RTS "total time" measure and the "real time" measure by the standard unix time command?
15:43:55 <glguy> zachk: unregister old versions of things before you install the new versions of things
15:46:04 <Pamelloes> Is there a way to pass a monad transformer through a litIO call?
15:46:38 <zachk> liftIO should lift the IO command/function into the transformer's space
15:48:10 <hackrilege> every package requires --force-reinstalls
15:48:11 * zachk should be back latter, thank you for your help glguy
15:48:28 <Aejay> zachk: That is, provided you've added a MonadIO instance
15:48:35 <Pamelloes> I have a function along the form withXXX :: (XXX -> IO a) -> IO a. Ideally, I'd like to be able to pass a monad transformer stack from outside of the function to inside it.
15:49:05 <dmj`> Pamelloes: you can fork threads while retaining a monad transformer, with monad-control, but not sure if you're using forkIO. Otherwise, you'd have to runStack inside of liftIO and return the result
15:49:20 <uwap> :t liftBase
15:49:21 <lambdabot> Not in scope: ‘liftBase’
15:49:25 <dmj`> :t fork
15:49:26 <lambdabot>     Not in scope: ‘fork’
15:49:26 <lambdabot>     Perhaps you meant one of these:
15:49:26 <lambdabot>       ‘forM’ (imported from Control.Monad.Writer),
15:49:47 <Pamelloes> dmj`: Hm? I'm not forking a thread.
15:49:57 <Aejay> :t liftIO
15:49:58 <lambdabot> MonadIO m => IO a -> m a
15:51:16 <Aejay> :t forkIO
15:51:17 <lambdabot> Not in scope: ‘forkIO’
15:51:25 <Cale> AaronFriel: Okay, so indeed, it has nothing to do with the terminal output. Merely forcing the evaluation of opAttribute will do it.
15:51:27 <uwap> Pamelloes, do I understand you properly that you want something like withXXX :: (XXX -> m a) -> m a for your monad transformer m?
15:51:37 <Pamelloes> Exactly
15:51:41 <AaronFriel> Cale: This is what I've found too
15:51:45 <Pamelloes> But the library I'm using has m a defined as IO
15:52:03 <AaronFriel> Cale: I'm plugging in NFData instances in a few places to see if forcing different things causes it to pass
15:52:08 <Pamelloes> I can lift the outer function via liftIO but that doesn't lift the inner function with it...
15:52:17 <uwap> Pamelloes, https://hackage.haskell.org/package/monad-control-0.3.1.4/docs/Control-Monad-Trans-Control.html#v:liftBaseWith
15:52:24 <uwap> maybe this can help you
15:53:10 <pacak> Any suggestions how to help ghc to optimize generics? slapping -funfolding-(creation|use)-threshold A_LOT helps, I would like to have a bit more control, trying to figure out how to write RULES.
15:53:35 <Pamelloes> uwap: Maybe, that looks interesting :)
15:54:48 <dmj`> Pamelloes: still, you'd have to run the stack in the IO portion
15:54:58 <dmj`> Pamelloes: liftIO escapes you into I/O neverland
15:55:13 * michaelklein waves
15:55:23 <Pamelloes> dmj`: So basically I have to recreate the stack within the IO...
15:58:34 <dmj`> Pamelloes: yea, you'd have to run it in IO. johnw does a good job of explaining the problem here: https://www.fpcomplete.com/user/jwiegley/monad-control
15:59:00 <lpaste_> AaronFriel pasted “Hyhac Test Force Everything” at http://lpaste.net/137226
15:59:21 <AaronFriel> Cale: My latest commit matches that snippet posted
15:59:58 <AaronFriel> Cale: You can see that even if I put "force" in a bunch of places, which should remove any nondeterminism in reading the array "opAttribute"
16:00:09 <AaronFriel> Cale: I still get test failures unless I force opAttribute with "rnf" later
16:00:10 <ttt_fff> which is easier to read "TSig" or "TSg" ?
16:00:18 <AaronFriel> Cale: So I'm very confused
16:00:26 <ttt_fff> for "TypeSig", what's a better name, "TSig" or "TSg"
16:00:33 <AaronFriel> Cale: Sorry, list opAttribute
16:00:45 <Cale> AaronFriel: Really, there shouldn't *be* any nondeterminism in computing opAttribute
16:00:53 <Cale> Unless something very evil is going on
16:01:17 <Cale> There clearly is, so something is breaking assumptions regarding what evaluation can behave like somewhere
16:01:32 <Cale> Are there any foreign imports with non-IO types hiding out somewhere?
16:01:34 <AaronFriel> Cale: Well, the backend code I wrote is very async, and relies on MVars and STM -- but all the tests pass other than the "Map" tests
16:01:57 <AaronFriel> Cale: No, everything I foreign import I do through c2hs, and use "{# call ... #}" notation
16:01:59 <Cale> Or unsafePerformIO? (grep didn't turn up anything...)
16:02:02 <Cale> hmm
16:02:04 <AaronFriel> Cale: No unsafety either
16:02:24 <Cale> Simply *evaluating* an expression isn't supposed to have any visible effects.
16:02:44 <AaronFriel> Cale: So if you were to run "integer/add" instead of "int-int/add", you'd see those tests pass
16:02:47 <Cale> Something really broken and unusual is taking place somewhere
16:03:00 <AaronFriel> Cale: And ditto with every test except the "type-type" map based tests
16:03:09 <AaronFriel> Cale: If I exclude the map tests, the whole suite runs
16:03:42 <AaronFriel> Cale: Which only confuses me more, if there's something fundamentally broken with my async backend, it should show up in more places than ... just there?
16:04:05 <uwap> ,0
16:08:53 <Cale> AaronFriel: Oh wait, this is interesting...
16:09:30 <Gurkenglas> https://www.reddit.com/r/haskell/comments/3ecest/haddock2161_released_with_source_code/ <- Can I view any hackage source with this or does each package have to update?
16:09:42 <AaronFriel> Cale: Go on
16:10:15 <Cale> I made it print the values of output, initial, operand, and initial `localOp` operand each time
16:10:37 <Cale> and it fails after printing operand, but before printing initial `localOp` operand
16:10:51 <Cale> Maybe I should look at what localOp actually is
16:11:20 <Cale> but before that, I'm going to see if I can catch an exception...
16:13:36 <AaronFriel> Cale: localOp is defined in lines ~430-480
16:14:14 <AaronFriel> Cale: Each atomic map operation is defined with a name, e.g.: "add", a HyperDex library fn to call, and an equivalent map operation
16:14:42 <AaronFriel> Cale: So, e.g.: "add" corresponds to (opOverMap (+)   :: Op (Map Int64 Int64)
16:16:21 <AaronFriel> Cale: So let's say we have the map that would correspond to fromList [(1,1),(2,4),(3,9)]
16:16:48 <AaronFriel> Cale: If we do opOverMap (+) (initialMap) (fromList [(1,1),(2,1)])
16:17:11 <AaronFriel> Cale: We should get the map fromList [(1,2),(2,5),(3,9)]
16:17:59 <Cale> That sounds thoroughly unproblematic...
16:24:34 <mniip> AaronFriel, sounds like you want something like fmap ($ fromList ...) $ fmap (on (+)) initialMap
16:24:49 <mniip> err hm
16:24:52 <AaronFriel> Cale: Maybe? I probably didn't write it in the most efficient way
16:24:54 <AaronFriel> Err
16:25:04 <mniip> fmap (on (+) (fromList ... !)) initialMap
16:25:22 <AaronFriel> mniip: Maybe, but what I wrote is part of a problem we're working on, and that piece of code... doesn't seem to be the problem
16:25:38 <AaronFriel> mniip: I'm sure there are more compact ways to write it than I have
16:26:20 <mniip> not entirely sure what you're trying to do though but yeah
16:26:50 <lpaste_> AaronFriel pasted “rnf weirdness” at http://lpaste.net/137228
16:27:10 <AaronFriel> Cale: Check out that snippet. Line 16 does *nothing*
16:27:25 <AaronFriel> Cale: If I uncomment line 18, test passes. Line 16 is a no-op
16:27:46 <AaronFriel> Cale: At least in terms of observing any effect of it
16:28:42 <mniip> AaronFriel, don't do that
16:28:53 <mniip> you want 'evaluate $ force opAttribute'
16:29:48 <AaronFriel> mniip: Will try
16:29:58 <Cale> AaronFriel: That's expected, executing return v does nothing, it doesn't even evaluate v.
16:30:11 <AaronFriel> Cale: ah okay
16:30:28 <arkeet> where is the code in question?
16:31:25 <arkeet> nm found it
16:35:21 <SrPx> Is there anyone in this world that could test the evaluation of a λ term using lamping's abstract algorithm for me? :( I'm getting a lot of fans and I'm not sure this is a bug or expected...
16:41:10 <Cale> AaronFriel: Another interesting piece of information
16:41:19 <Cale> QC.run . evaluate . deepseq $ mkMapAttributesFromMapUtf8 attributeName operand -- this still fails
16:41:27 <Cale> QC.run . evaluate . deepseq $ opAttribute -- with this the tests pass
16:41:30 <Cale> Even though
16:41:35 <Cale> opAttribute        = mkMapAttributesFromMapUtf8 attributeName operand
16:44:33 <lpaste_> AaronFriel pasted “Ordering weirdness” at http://lpaste.net/137229
16:44:46 <AaronFriel> Cale: If you uncomment 15, no effect. If you uncomment 17, passes.
16:45:14 <AaronFriel> So the ordering with respect to when the FFI call occurs matters?
16:45:32 <AaronFriel> Moreover, and this is the weird part
16:45:42 <AaronFriel> The force-ing has to occur *after* the FFI call?
16:45:53 <AaronFriel> that's the part I don't get. Before makes more sense.
16:51:30 <hackrilege> are you guys any closer to debugging aarons ffi?
16:52:22 <Cale> hackrilege: This basically makes no sense :D
16:52:39 <hackrilege> hmmm
16:52:45 <Cale> hackrilege: Look at my comment just above here
16:52:54 <Cale> (and Aaron's comments)
16:53:31 <Cale> hackrilege: It depends on the evaluation of the opAttribute variable itself -- evaluating the expression that opAttribute is equal to has no effect
16:53:53 <hackrilege> ww
16:54:06 <hackrilege> wow*
16:54:10 <Cale> hackrilege: Moreover, this forcing needs to occur *after* the only other usage of opAttribute in order to have an effect
16:54:18 <hackrilege> that makes no sense
16:54:22 <AaronFriel> Cale: There is one place where I use unsafe, and it's when I allocate a ByteString to pass to the FFI library. I'm going to see if that's somehow the culprit
16:55:04 <AaronFriel> Cale: I use the unsafeUseAsCString as an optimization, and take a StablePtr to the ByteString while the FFI call is occurring
16:55:37 <Cale> hmm
16:56:07 <hackrilege> i couuld see how calling opAttribute once and then again may reuse the first result, but that a statement equivilant to opAttribute may get compiled to a different memory location and not do the "force"
16:56:22 <Cale> Well, sure
16:56:27 <hackrilege> does that make sense?
16:56:37 <hackrilege> am i missing something?
16:56:46 <Cale> But that means whether or not opAttribute is in an evaluated state matters, and this is not ordinarily an observable thing.
16:56:59 <Cale> (unless you go digging through the heap inspecting GHC's structures)
16:57:43 <hackrilege> but we are using ffi
16:57:48 <Cale> yeah
16:58:04 <Cale> It's possible that something incredibly weird and screwy is happening
16:58:13 <hackrilege> so expect c type memory alocation and referencing problems...
16:58:15 <Cale> It's still bizarre that the unevaluated state is the better one :)
16:58:28 <hackrilege> it seems that is the case
16:58:29 * hackagebot hyphenation 0.6 - Configurable Knuth-Liang hyphenation  https://hackage.haskell.org/package/hyphenation-0.6 (EdwardKmett)
16:58:41 <hackrilege> that something screwy is happening
16:58:54 <Cale> Well, no wait
16:59:05 <Cale> You need opAttribute to get forced
16:59:15 <Cale> It just needs to get forced after the FFI stuff happens
16:59:20 <Cale> heheheh
16:59:24 <hackrilege> but you guys have been going for a while now, i hope this is something that will become clear eventually...
16:59:30 <AaronFriel> Cale: There actually is a bug with those uses of "unsafe"
16:59:46 <AaronFriel> Cale: It is the unsafeUseAsCString and/or unsafeUseAsCStringLen that cause it
17:00:08 <hackrilege> r u serious!?
17:00:10 <AaronFriel> Someone else actually contributed that code to the library as an optimization, because here it is in Resource.hs:
17:00:32 <lpaste_> AaronFriel pasted “Resource.hs snippet 1” at http://lpaste.net/137230
17:00:32 <hackrilege> you have the word "unsafe" in your code and you just check this now!?
17:01:33 <AaronFriel> hackrilege: There's a *ton* of code, not just in these tests, that depends on rNewCBString0
17:01:55 <AaronFriel> hackrilege: To ensure memory safety, I need to track which CStrings I've passed to the FFI, and not free them too soon
17:01:59 <hackrilege> wow i hope i never have to use that lib...
17:02:05 <AaronFriel> hackrilege: Hah
17:02:22 <AaronFriel> Cale: Changing unsafeUseAsCString fixes it, now I will look into *why*
17:02:32 <Cale> aha
17:02:44 <hackrilege> *whew*
17:02:51 <Cale> I know what's happening
17:02:57 <Cale> I think?
17:03:00 <Cale> Hang on
17:03:08 <Cale> It's not the fact that we're forcing it
17:03:15 <Cale> It's the fact that we're *retaining* it
17:03:23 <AaronFriel> Cale: ... oh
17:03:24 <Cale> It's getting GCed too soon
17:03:33 <AaronFriel> Cale: oh that's 
17:03:36 <AaronFriel> Cale: That's interesting
17:03:54 <hackrilege> its also obvious!
17:03:55 <Cale> That's the danger of unsafeUseAsCString
17:03:57 <AaronFriel> Cale: I found the bug with it too
17:04:08 <hackrilege> along comes the garbage man to trash your malloc
17:04:10 <AaronFriel> I did "newStablePtr cstr"
17:04:14 <AaronFriel> instead of "newStablePtr bs"
17:04:25 <AaronFriel> So I took a stable pointer to an attribute of the byte string
17:04:29 <AaronFriel> Which the GC ignored
17:04:34 <AaronFriel> Instead of a stable pointer to the bytestring
17:04:55 <AaronFriel>                   ptr <- newStablePtr bs -- This fixes it
17:05:16 <Cale> I honestly should have thought of the GC when you discovered that acting on it after the FFI call is what made the tests succeed
17:05:25 <hackrilege> so whats wrong with pure haskell?
17:05:27 <AaronFriel> Cale: It's obvious in retrospect
17:05:40 <AaronFriel> hackrilege: You mean, why am I doing "unsafe"?
17:06:16 <AaronFriel> hackrilege: I need create a CString in a background thread in one place, and then free it... later, asynchronously, and possibly in another thread.
17:06:26 <hackrilege> no why are you using ffi
17:06:29 <hackrilege> and cstrings and other crazyness
17:06:30 <AaronFriel> oh
17:06:36 <AaronFriel> Because I'm working with a database library
17:06:38 <AaronFriel> porting it to Haskell
17:06:41 <hackrilege> there is no pure haskell suloution?
17:06:50 <hackrilege> oh ok
17:06:53 <AaronFriel> ... no the database access library is written in C
17:06:56 <Cale> hackrilege: There are other Haskell database libraries, but no binding to this database
17:06:58 <hackrilege> good work then my friend
17:07:04 <AaronFriel> yes
17:07:15 <AaronFriel> I'm using Michael Snoyman's ResourceT to track resources
17:07:20 <AaronFriel> and I... tracked the wrong one
17:07:27 <hackrilege> omg snoyberg
17:07:31 <AaronFriel> So as you said the garbage man came along to mess my shit up
17:07:38 <AaronFriel> ;_;
17:08:10 <hackrilege> so glad you got the bug, looks hellish!
17:08:12 <AaronFriel> Cale: Thank you for looking at this so long, you are as always, abundantly helpful
17:08:36 <hackrilege> bitcoins for Cale!
17:08:50 <AaronFriel> hackrilege: Thank you, ugh, I spent 6 hours last night adding trace statements so that my Haskell library would output on stderr *equivalent C code* to every FFI call I was making
17:08:53 <AaronFriel> it literally output this:
17:09:06 <AaronFriel> attr.value = "\xfd""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xfc""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\xff""\x03""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x00""\x08""\x00""\x00""\x00""\x00""\x00""\x00""\x00""";
17:09:06 <AaronFriel> attr.value_sz = 48;
17:09:06 <AaronFriel> attr.datatype = HYPERDATATYPE_MAP_INT64_INT64;
17:09:06 <AaronFriel> op_id = hyperdex_client_put(client, "profiles", "\x04""\x10""", 2, 
17:09:06 <AaronFriel>                             &attr, 1, &op_status);
17:09:12 <AaronFriel> ^^ all of that in stderr
17:09:19 <hackrilege> urgh
17:09:29 <AaronFriel> the goal was, "Well maybe it actually is the database library doing it?"
17:09:40 <AaronFriel> Then I added a print statement at one point in my test
17:09:44 <AaronFriel> and suddenly all the tests passed
17:09:48 <AaronFriel> That was infuriating
17:09:52 <hackrilege> lol so c
17:09:56 <AaronFriel> Adding a print statement causes the test cases to pass?!
17:10:08 <AaronFriel> It took me another few hours to figure out it was a print statement doing it
17:10:33 <hackrilege> they are paying us well for this work huh...
17:11:00 <hackrilege> im really not looking forward to trying to get MPI to work...
17:11:15 <hackrilege> i dont even understand parsec!
17:11:39 <hackrilege> and then, obsidien... 
17:12:00 <hackrilege> llvm backend... so many nasties.
17:12:40 <hackrilege> i should find C libs to fortran blas i guess this will be my first c2hs
17:13:16 <hackrilege> and to get it all to work on android omg
17:13:56 <hackrilege> ill pick ur brains about it all when your fresh!
17:13:59 <AaronFriel> C2HS is awesome
17:14:04 <AaronFriel> I use it for my FFI
17:14:09 <hackrilege> well...
17:14:14 <Axman6> there are already packages for interfacing with MPI
17:14:23 <hackrilege> as we have seen, there are parts which are less than awesome
17:14:43 <hackrilege> Axman6 yes, the c2hs will be for blas
17:15:07 <Axman6> you should talk to carter_cloud, he's done a lot of work in this area IIRC
17:15:10 <lpaste_> AaronFriel pasted “C2HS + ResourceT = FFI Zen” at http://lpaste.net/137231
17:15:24 <Axman6> you're certainly not the first person to want to use blas and MPI in Haskell
17:15:26 <AaronFriel> hackrilege: Okay, so my screw up was painful
17:15:29 <hackrilege> thanks axman6:
17:15:33 <AaronFriel> hackrilege: But look at this FFI call in my library
17:15:42 <hackrilege> kk
17:15:47 <AaronFriel> hackrilege: It's very straightforward, it handles an async C library call
17:16:00 <AaronFriel> hackrilege: And ResourceT glues it together to make sure I don't release any memory early
17:16:31 <AaronFriel> (AsyncResult a b is a type alias for... IO (Either a b))
17:16:31 <hackrilege> i imagine the memory in a pig pen squeeling to be released
17:16:58 <AaronFriel> hackrilege: The memory being nicely contained, despite the squeeling noises, is what helps me sleep at night
17:17:20 <AaronFriel> hackrilege: Really working with this database is really a pain from Haskell, because all of the C calls are async
17:17:37 <AaronFriel> hackrilege: And asynchronous calls + memory management in Haskell is just so painful without ResourceT
17:18:06 <hackrilege> so you think you have much better control by getting at the c memory allocators?
17:18:16 <hackrilege> just for this application?
17:18:18 <johnw> AaronFriel: why is it painful?
17:18:32 <johnw> ResourceT is giving you scoping; why doesn't the GC work?
17:19:02 <AaronFriel> johnw: Async calls. I need to make sure the piece of memory I pass to the FFI call lives longer than the call itself
17:19:18 <AaronFriel> And it could live *arbitrarily long* in fact
17:19:37 <hackrilege> i just rely a lot on lazy evaluation for my whole haskell career (10 years, nothing pro) im really not looking forward to really geting to the heart of whats goig on. i hope it just benchmarks well without and i dont have too... but for high performance application im sure i will have to trace all the memory...
17:19:40 <AaronFriel> Because only when the async call is returned and I call a callback, and that callback returns success, is it guaranteed safe to free
17:20:29 <AaronFriel> johnw: My failure state is actually to leak memory. If something extraordinary happens in the C library, my library adopts a sort of "scorched earth" policy and never frees anything it allocated for that call.
17:20:57 <johnw> AaronFriel: I'm still not clear on what the difference is between holding onto a reference in ResourceT, and holding onto a reference as a ForeignPtr in some other state
17:21:20 <AaronFriel> johnw: Well I need to hold onto bunches of pointers. And possibly add to that list of pointers as callbacks occur.
17:21:25 <johnw> they are pretty much the same thing, except that ResourceT explicitly calls all of its finalizers at the end of runResourceT
17:21:34 <johnw> yes, you could hold onto bunches of ForeignPtrs
17:21:40 <hackrilege> i dont know why we cant just compile the c code to haskell native datatypes
17:21:47 <johnw> as soon as you let one go, it's free to be GC'd, and thus to have its finalizer called
17:21:50 <AaronFriel> johnw: Yes, but what happens when the library crashes & burns
17:22:10 <AaronFriel> johnw: Then if the C library is still doing something, the ForeignPtr frees the real memory underlaying something passed to FFI
17:22:11 <johnw> ah, you want the explicit finalization that happens when an exception passes out of runResourceT
17:22:16 <AaronFriel> johnw: Yep!
17:22:37 <johnw> ok, you could emulate the same thing by walking through your list of ForeignPtrs and calling their finalizers, but I can appreciate that ResourceT has done this for you already
17:22:59 <AaronFriel> johnw: Yeah, I'm only using a sliver of ResourceT, and I just added wrappers for malloc, mallocArray, and so on.
17:23:01 <hackrilege> you guys will never cease to amaze me 
17:23:08 <johnw> I've used ResourceT with the FFI behaviaor, and I agree that it is handy to just register a finalizer and then forget about it
17:23:15 <AaronFriel> rMallocArray sz = fmap snd $ allocateAcquire $ hAcquire (mallocArray sz) free
17:23:45 <johnw> hackrilege: c2hsc will compile the C code to native Haskell data types
17:24:03 <Forkk> Anyone know how acid state handles concurrent transactions? Is only one allowed to run at a time?
17:24:32 <johnw> stepcut or dmj` might know
17:25:02 <AaronFriel> cale, hackrilege, johnw: I have to go, but thank you all for your attention this evening
17:25:14 <Forkk> johnw, is that addressed toward me or someone else?
17:25:17 <AaronFriel> It is virtually always a pleasure to ask questions in #haskell
17:25:33 <hackrilege> goodnight brother, keep up the good work
17:25:37 <johnw> Forkk: toward you
17:25:46 <Forkk> ok
17:26:06 <johnw> AaronFriel: good evening
17:27:06 <Forkk> I'm just wondering if it would work well to design my application in a way where I have a ton of threads accessing a single acid state containing a bunch of separate sub-components, or if I should split each sub-component into a separate acid state.
17:27:23 <Forkk> If concurrent transactions block eachother, then the latter is the obvious answer
17:27:30 <Forkk> but the former solution is much easier
17:27:51 <johnw> since that's purely an optimization, I'd do what is simplest first
17:28:20 <hackrilege> johnw: i get that a cpointer is a haskell datatype, but its not in keeping with the haskell compilation aproach, so thats why i thought of it as not "pure".. im sure you could emulate the whole of C in pure haskell, but then it would be C, not pure haskell, if you get what i mean
17:28:28 <Forkk> yeah, but I'm not sure how much work that optimization might take to add later
17:28:40 <Forkk> but you're right now that I think about it. thanks :)
17:28:43 <johnw> hackrilege: I don't, actually
17:30:03 <johnw> Forkk: it's always possible that acid-state may only block all readers during a write, but otherwise allow enough asynchronicity to not cause an issue for your use case
17:30:17 <hackrilege> johnw nvm
17:30:56 <hackrilege> you couldnt make many copies of it, one for each process?
17:31:53 <Forkk> My concern is just that transactions that will never touch each other may end up being blocked and run sequentially even though they don't need to.
17:32:18 <Forkk> but it may not even matter, considering how Acid State works.
17:32:21 <hackrilege> or make it so when it is read, it copies itself first and makes the copy accessible to another process that tries to read it/
17:33:28 <hackrilege> sorry, im guessing...
17:36:27 <tomtomgps> [HELP] what does the Ord a => mean in   the line       bsort :: Ord a => [a] -> [a]   ?
17:36:44 <hyyper> Cale: I've got that book Programming in Haskell by Graham Hutton
17:36:46 <johnw> it means that whatever you choose "a" must have an instance of the Ord typeclass
17:36:58 <srhb> tomtomgps: Also called a "constraint" or "class constraint" on a
17:37:02 <hyyper> just gotta copy it from my mom's phone
17:37:45 <dmj`> Forkk: how would acid-state detect that two transactions are isolated from one another
17:37:51 <johnw> in English: bsort can only sort lists of elements that support ordering using Ord
17:38:37 <tomtomgps> Ord being ?
17:38:38 <Welkin> hi dmj` 
17:38:48 <srhb> The type class that supports Ordering operations
17:39:14 <srhb> tomtomgps: Try writing :i Ord in ghci
17:39:19 <hyyper> totte: things of type Ord are anything that can support Ordering operations
17:39:25 <hyyper> mean tomtomgps
17:39:28 <dmj`> hi Welkin
17:39:30 * arkeet suggests reading about type classes in general
17:39:38 <Zemyla> Are there laws relating Ord and Bounded?
17:39:40 <srhb> tomtomgps: At the very top of that spam you'll see what the methods defined by an Ord instance are.
17:39:40 <hyyper> arkeet: may I?
17:39:58 <hyyper> @book lyah
17:39:58 <lambdabot> Unknown command, try @list
17:40:01 <tomtomgps> ok thank you
17:40:11 <johnw> Zemyla: I would imagine that minBound <= maxBound is a requirement
17:40:13 <arkeet> Zemyla: I would hope so.
17:40:22 <Zemyla> Like forall a. (Ord a, Bounded a) => minBound <= a and a <= maxBound?
17:40:26 <srhb> tomtomgps: The rest of the spam will show you what types you have in scope that define Ord instances (ie. are valids `a`s for your function)
17:40:28 <carter_cloud> hackrilege: Axman6 my hblas code base is mostly there for blas.  Also a gsoc student is helping me add some more stuff
17:40:32 <arkeet> Zemyla: yeah like that.
17:40:57 <carter_cloud> Also there's another lower level binding or two out there that's decent.  There's certain things mine does that are kinda unique
17:41:06 <hackrilege> links?
17:41:09 <hackrilege> thaks
17:41:12 <arkeet> Zemyla: but it is not explicitly written in the documentation
17:42:08 * arkeet wonders why we do not have an instance Bounded a => Bounded (r -> a)
17:43:28 <hiptobecubic> arkeet, how would it work?
17:43:30 <Forkk> dmj`, I'm not really sure how, which is why I asked
17:43:55 <Forkk> STM is able to do that just fine, but STM works in a completely different way
17:44:31 <hackrilege> carter_cloud: I'm going to be doing a few things with cublas, but my prof wants it to work on his xenon cpu machine, so i guess i need to compile optimised blas for i7
17:44:44 <Forkk> then again, it may not even matter if the transactions are lightweight enough
17:45:09 <carter_cloud> hackrilege: you might want to checkout blis.
17:45:20 <hackrilege> thanks
17:45:42 * gouwe
17:45:54 <carter_cloud> hackrilege: the  channel #numerical-haskell  might be a good place to switch to
17:46:22 <carter_cloud> hackrilege: I think alpounet has a cublas binding on hackage
17:46:23 <hackrilege> ok, its more about hpc there? 
17:46:38 <hackrilege> there is cublas ill check alpounet
17:46:42 <hackrilege> cant find blis on hackage
17:46:46 <hackrilege> or google!
17:46:48 <carter_cloud> More about mathematical computing
17:46:51 <hackrilege> kk
17:46:54 <carter_cloud> Blis ain't on hackage
17:47:03 <hackrilege> github?
17:47:08 <carter_cloud> @google blis tensor
17:47:10 <lambdabot> http://www.cs.utexas.edu/users/flame/BLISRetreat/talks.html
17:47:10 <lambdabot> Title: BLIS Retreat
17:47:15 <carter_cloud> That project.
17:47:30 <carter_cloud> You'll find the right link via the flame project
17:47:35 <hackrilege> i found flame/blis 
17:47:42 <carter_cloud> Yup.
17:48:03 <hackrilege> ah this is great thanks
17:48:57 <carter_cloud> It's less mature than blas, but it's pretty neat
17:49:59 <hackrilege> speed is of the essence, its the most hpc critical aplication to chemistry to be ru on the national supercomputer, im getting in trouble for trying to use haskell...
17:50:37 <hackrilege> you could hint as to if i should abandon all hope or if you think i should be ok!
17:51:05 <hackrilege> i thought that with blas bindings haskell should be as fast..
17:51:13 <carter_cloud> Yeah they should be
17:51:20 <hackrilege> cool
17:51:22 <carter_cloud> Let's switch to the other channel
17:51:25 <hackrilege> kk
17:52:06 <carter_cloud> hackrilege: switch :)
18:09:20 <navaati> Hi
18:12:24 <navaati> I'm using quickcheck to test some numeric code, however the Arbitrary instance for [Double] spit lists that never contains 0.0
18:13:18 <navaati> strangely enough, the Arbitrary instance for Double does produce some 0.0
18:13:30 <navaati> anyone knows why is this ?
18:13:33 * hackagebot hadoop-tools 0.7 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-0.7 (JacobStanley)
18:16:39 <Axman6> navaati: that is pretty strange!
18:17:02 <navaati> > sample (arbitrary :: Gen Double)
18:17:04 <lambdabot>  <IO ()>
18:17:17 <navaati> meh, thx lambdabot
18:17:30 <navaati> but well, try it for yourself :)
18:33:34 * hackagebot hadoop-tools 0.7.1 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-0.7.1 (JacobStanley)
18:59:55 <kakashiAL> hey guys, I am very new in haskell
19:00:09 <kakashiAL> just wanted to know in which language haskell is written
19:00:22 <navaati> kakashiAL: in Haskell, mostly
19:00:38 <navaati> with a tiny bit of asm and, I guess, some C
19:01:15 <Gurkenglas> http://artyom.me/lens-over-tea-1 <- Ctrl-F for "Removed one" <- Shouldn't it remove the left . first (and the right one only after ([a, b] ++) is exhausted) because . is right-associative?
19:03:35 * hackagebot hourglass-fuzzy-parsing 0.1.0.0 - A small library for parsing more human friendly date/time formats.  https://hackage.haskell.org/package/hourglass-fuzzy-parsing-0.1.0.0 (TannerDoshier)
19:08:16 <nshepperd_> Gurkenglas: normally yes, but I think here they explicitly bracketed it the other way as an example
19:08:29 <nshepperd_> ((a . b) . c) instead of (a . b . c)
19:08:55 <Gurkenglas> Ah, I missed that, thanks.
19:12:09 <Gurkenglas> (Damn this guy, every time I think of a clever objection to something he says, the article continues to mention his already having thought of it.)
19:12:31 <Gurkenglas> ("The important thing is that with difference lists we do not more preliminary steps as there are lists to append" is probably even grammatically correct in some occult fashion)
19:13:36 * hackagebot hadoop-tools 0.7.2 - Fast command line tools for working with Hadoop.  https://hackage.haskell.org/package/hadoop-tools-0.7.2 (JacobStanley)
19:13:45 <hackrilege_> where can i find chatlogs for #numerical-haskell?
19:15:12 <Gurkenglas> (And yes, it might simply be the article being old and having been revised after many objections)
19:18:26 <hackrilege_> Gurkenglas: what are you talking about?
19:21:41 <XE00> -c chat.freenode.net -n myname -w mypassword
19:21:41 <XE00>    /join #haskell
19:22:10 <Gurkenglas> The masterpiece of an article linked above, "lens over tea", whose writing style (sacrificing "ease for some to understand what you are talking about" for appeal to those who would write the same way if they sacrificed the same) quickly rubbed of on me, case in point.
19:30:21 <hackrilege_> id look at it if i could find the chatlog...
19:31:03 <geekosaur> see the /topic
19:43:03 <broma0> How do records work when there are multiple constructors? Like 'data XY = X { a :: Int } | Y { b :: Int }'
19:43:37 * hackagebot almost-fix 0.0.0 - Recurse until a predicate  https://hackage.haskell.org/package/almost-fix-0.0.0 (athanclark)
19:43:39 * hackagebot almost-fix 0.0.1 - Recurse while a predicate is satisfied  https://hackage.haskell.org/package/almost-fix-0.0.1 (athanclark)
19:43:51 <navaati> broma0: in a dark way
19:43:57 <broma0> more specifically, why is this allowed? 
19:44:03 <broma0> its pretty easy to get an exception
19:44:13 <zomg> Huh? o_O
19:44:24 <navaati> yes, non exhaustive pattern
19:44:35 <zomg> Yeah that's why you run GHC with -wall
19:44:35 <zomg> :)
19:44:39 <navaati> people generally avoid to do this
19:44:49 <broma0> sounds like a good practice.. thanks
19:45:01 <Jonno_FTW> I want to install the haskell platform in a non-standard directory on linux, because I don't have root, how do I do this?
19:45:15 <zomg> I've been hanging around here for a while and this is the first time I hear anyone recommending *avoiding* multiple constructors..
19:45:35 <zomg> I mean if you just run GHC with -wall it will give warnings about non-exhaustive patterns so you don't get the problems
19:45:54 <navaati> not multiple contructors, only mixing records and sum types
19:46:20 <zomg> Ah, well his example isn't mixing anything as far as I can tell?
19:46:27 <navaati> do ghc complain if you do data Lol = Meh { x :: Int } | Onche { y :: Char } ?
19:46:38 <navaati> does*
19:46:58 <zomg> I don't think it does
19:47:45 <init> can I suggest GADTs + DataKinds + type families? :P 
19:47:48 <navaati> still, in this case x and y are of type Lol -> Int and Lol -> Char, but contain non-exhaustive patterns
19:47:59 <navaati> hence why i discourage using this
19:48:04 <broma0> navaati: no, but try" x $ Onche 'a'
19:48:34 <navaati> init: shhhhh :) !
19:49:24 <Dre3ml0rd> does anyone here know how to work with either darkbasic or AGKBasic
19:49:26 <init> data T_XY = T_X | T_Y; data XY (k :: T_XY) where X :: Int -> XY T_X ; Y :: Int -> XY T_Y ; a :: XY T_X -> Int; b :: XY T_Y -> Int
19:49:39 <geekosaur> Jonno_FTW, I don't think the Platform installs as non-root. You might install the ghc bindist, which can be installed as a user, and install the Platform libraries via cabal
19:49:55 <geekosaur> although you might want to hold off a bit on the Platform anyway as a new version is due out shortlu
19:49:59 <geekosaur> *shortly
19:50:10 <geekosaur> (along with ghc 7.10.2 with significant bug fixes)
19:51:45 <hackrilege_> can anyone link the #numrical-haskell logs to me?
19:51:49 <Jonno_FTW> geekosaur: thanks, I just edited the ghc script with my install prefix
19:52:24 <chreekat> Jonno_FTW: stack will install ghc for you, fwiw. I presume it does so in ~/.stack
19:52:33 <Jonno_FTW> thanks
19:52:41 <Gurkenglas> hackrilege_, I've heard that some people don't like logs being distributed. I know, right?
19:52:52 <Jonno_FTW> where do I get stack?
19:53:08 <athan> Jonno_FTW: Check out the readme
19:53:14 <Gurkenglas> Anyway, this is a topic for -blah methinks.
19:53:17 <athan> there's install instructions for each OS :)
19:53:53 <Gurkenglas> (Or, like, in numerical-)
19:55:49 <Jonno_FTW> there's no readme in the tar
19:56:02 <Jonno_FTW> and the online instructions say to run as root
19:56:14 <chreekat> Jonno_FTW: for stack, #haskell-stack has info
19:58:22 <lambdafan> is it possible to have a [Maybe *], where each Just is a type of kind *
19:58:35 <lambdafan> so like [Just 1,Just "foo"]
19:58:58 <lambdafan> is there a way to make that leagal?
19:58:58 <navaati> lambdafan: short answer, no
19:59:00 <lambdafan> legal
19:59:00 <athan> Jonno_FTW: On the github page, I meant
19:59:03 <lambdafan> okay
19:59:14 <athan> Jonno_FTW: https://github.com/commercialhaskell/stack I think
19:59:29 <init> lambdafan: you actually can, but it'd be useless
19:59:41 <init> lambdafan: because it'd be as useful as a list of booleans
20:00:14 <Jonno_FTW> athan: these looks like they require root
20:00:16 <lambdafan> init: I have a type Foo a, that I want to do [Foo a] but I want a to be a different type, same kind
20:00:41 <init> lambdafan: what do you actually want to do with every value in that list?
20:01:02 <navaati> if you really need, take a look at existential quantification, but i think you'd better find another solution
20:01:06 <nshepperd> data Foo = FNothing | JustInt Int | JustString String
20:01:31 <athan> lambdafan: Well...
20:01:32 <lambdafan> init: I would count it , or add/remove from list
20:01:36 <athan> kinda
20:01:36 <athan> You can have a list of types, which is what HList does
20:01:36 <athan> @hackage HList
20:01:36 <lambdabot> http://hackage.haskell.org/package/HList
20:01:39 <athan> but it uses ~advanced haskell techniques~
20:01:41 <Jonno_FTW> actually nvm
20:01:41 * athan queues the fog and strobe light
20:01:48 <init> lambdafan: note that once you lose type information, there's no way to recover it
20:01:52 <Zekka> lambdabot: Is that all? Because if so why not just use an integer?
20:02:00 <Zekka> You'll never be able to look at the values again
20:02:13 <Zekka> lambdafan*
20:02:15 <chreekat> Jonno_FTW: without using root, you can use the linux binary release (https://github.com/commercialhaskell/stack/releases/tag/v0.1.2.0)
20:02:20 <athan> super spooky
20:03:05 <lambdafan> Zekka, because what I have is this newtype Foo a = (a,Int). IThe a tells me what I am counting
20:03:16 * chreekat puts on glow-in-the-dark body paint and dances at the HList party
20:03:23 <Zekka> lambdafan: OK, but since you'll never be able to look at the a again, why not just Int?
20:03:38 * hackagebot hourglass-fuzzy-parsing 0.1.0.1 - A small library for parsing more human friendly date/time formats.  https://hackage.haskell.org/package/hourglass-fuzzy-parsing-0.1.0.1 (TannerDoshier)
20:03:53 <lambdafan> Zekka: I didn't know the a is inaccessable
20:04:04 <lambdafan> I need to re-think this
20:04:07 <Zekka> lambdafan: You can't get type information back once you've lost it
20:04:30 <Zekka> The a is accessible if you know what the a is, but if you told Haskell "the a can just be anything" then it can't tell you what operations your value supports
20:04:38 <init> lambdafan: what type would a "head" function have? 
20:05:36 <athan> Jonno_FTW: Also, if you have cabal install, you could build it in a sandbox
20:05:40 <lambdafan> Zekka, I was going to constrain what a could be with accessor functions
20:05:41 <Zekka> lambdafan: FYI, a type very close to what you want is this: data Foo = forall a. Foo a Int
20:06:05 <Zekka> lambdafan: Can't you just use an algebraic data type to describe all the things the a can include?
20:06:32 <Zekka> data Inner = AString String | AnInt Int | AStringList [String]
20:06:44 <Zekka> Then you have [(Inner, Int)]
20:07:07 <lambdafan> Zekka: oh yeah I'll do it that way!
20:07:10 <lambdafan> thanks
20:07:23 <Zekka> lambdafan: No problem, best of luck
20:12:13 <broma0> :w
20:31:11 <Jonno_FTW> how do I change where stack installs everything to? I have limited space in ~
20:32:34 <Jonno_FTW> when I run stack setup, it wants to put everything in ~/.stack, how do I change this directory?
20:32:57 <Axman6> you could symlink that path to somewhere else if you wanted
20:33:04 <Jonno_FTW> yeah just thought of that :S
20:42:36 <crusty_the_fig> How do you guys feel about teaching Haskell as a first language?
20:42:43 <Hafydd> How could I cause GHCi to preserve default rules when reloading a module?
20:42:58 <crusty_the_fig> How does it compare to Python and Java as a first language, for instance?
20:43:01 <Hafydd> One way would be to redefine all of :load, :reload, etc, I suppose; but I don't feel like doing that.
20:43:37 <kadoban> crusty_the_fig: I like the idea of it. I usually recommend it just behind python, but I haven't tutored anyone in-depth through it yet.
20:45:33 <Jonno_FTW> crusty_the_fig: I found it infinitely better than TI-basic which I also learnt at the same time
20:49:20 <chreekat> Jonno_FTW: looks lik ethere's an (undocumented?) option to set STACK_ROOT in your environment to override the default location of ~/.stack
20:50:21 <Jonno_FTW> chreekat: thanks, but I made a symlink and that works, except now it can't find libgmp.so
20:51:19 <chreekat> Jonno_FTW: Yeah, ghc needs that. Someone was just asking that question the other day, too, though I wasn't part of the conversation. I think you can install libgmp locally and tell ghc where to find it. Maybe someone can confirm/refute
20:53:03 <Jonno_FTW> I installed it but now it can't find libHSghc-prim-0.3.1.0.so
20:53:06 <crusty_the_fig> kadoban, Jonno_FTW: Are there good resources for learning the language, like there are for Python?
20:53:33 <Jonno_FTW> crusty_the_fig: yes, there's loads of free books online, everyone suggests learn you a haskell
20:56:35 <chreekat> crusty_the_fig: the haskell wiki book is also very good (So I'm told by a newbie)
20:57:22 <Jonno_FTW> I also learnt by doing project euler questions and asking for help here and on stackoverflow
20:57:39 <Jonno_FTW> you'd probably get shot for asking those sorts of questions on SO nowadays though
20:57:43 <lethjakman> what does lift do? I get that it transforms a monad...but into what?
20:58:17 <lethjakman> chreekat: I read a lot of the wiki book when LYAH didn't explain things well enough. 
20:58:31 <lethjakman> however I'm still fresh so I can't tell you the end result :)
20:59:25 <rcyr> lethjakman: lift is fmap, it applies a function to the "content" of the monad.
20:59:39 <jle`> rcyr: you might be thinking of liftM ?
20:59:50 <rcyr> Yeah :/
21:00:14 <chreekat> :t lift
21:00:15 <lethjakman> why are there so many aliases for fmap?!
21:00:16 <jle`> lethjakman: it's used for monad transformers to allow you to embed actions of the transformed monad
21:00:16 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:00:29 <meow> Does Haskell have anything like ipython notebook?
21:00:36 <meow> Basically some kind of learning workflow
21:00:39 <jle`> lambdabot: so if you had MaybeT IO a, then lift :: IO a -> MaybeT IO a
21:00:41 <kadoban> crusty_the_fig: Not that great, but there's decent stuff available.
21:00:44 <jle`> er, lethjakman 
21:00:50 <Jonno_FTW> meow: there's literate haskell
21:00:52 <jle`> meow: how about IHaskell ?
21:01:00 <lethjakman> lol
21:01:02 <jle`> lethjakman: do you know about monad transformers?
21:01:12 <kadoban> crusty_the_fig: https://github.com/bitemyapp/learnhaskell is a good guide, but for a beginner you'll want to look at that book, which I've personally never read.
21:01:16 <lethjakman> not particularly, I thought lift was a monad transformer?
21:01:25 <jle`> not quite
21:01:29 <lethjakman> oh
21:01:31 <jle`> monad transformers transform monads
21:01:31 <lethjakman> uhh
21:01:35 <jle`> like, IO
21:01:43 <lethjakman> ok
21:01:45 <jle`> MaybeT is a monad transformer
21:01:45 <kadoban> crusty_the_fig: I would shy away from relying on just LYAH or whatever, it's … lacking (in particular, it has no exercises and some other less severe faults)
21:01:50 <jle`> you apply it to IO, and you get a new monad
21:02:02 <jle`> MaybeT IO is a new monad that adds short-circuiting capabilities to IO
21:02:13 <jle`> so `MaybeT IO` is "IO with short-circuiting"
21:02:22 <meow> thanks guys
21:02:26 <lethjakman> ok
21:02:44 <lethjakman> but why do you need liftio instead of just >>=
21:02:46 <lethjakman> ?
21:02:46 <jle`> lift lets you take actions from the monad being transformed (like IO a), and lift them to the the transformed monad
21:02:50 <homa_rano> so I have a modding function, m=flip mod 101, and I want to create an adder using it, but (m.(+)) doesn't typecheck. Is there a way to composes these?
21:03:00 <jle`> so if i had an `IO a`, i can't use it with (>>=)
21:03:06 <jle`> with a MaybeT IO a
21:03:10 <jle`> because check out the type of (>>=)
21:03:12 <jle`> :t (>>=)
21:03:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:03:17 <jle`> they all have to be the same Monad m
21:03:29 <jle`> so you can't use (>>=) with a `MaybeT IO` and an `IO`
21:03:39 <jle`> er, with a `MaybeT IO a` and an `IO a`
21:03:45 <jle`> so you can "lift" the IO a into MaybeT IO a
21:03:49 <jle`> lift :: IO a -> MaybeT IO a
21:03:50 <lethjakman> :t liftIO
21:03:51 <lambdabot> MonadIO m => IO a -> m a
21:03:54 <jle`> we're talking about lift here
21:04:01 <jle`> did you want to talk about liftIO too?
21:04:06 <jle`> liftIO is a bit of a different thing
21:04:20 <lethjakman> oh, I was just trying to understand the concept of a lifter...are the two significantly different?
21:04:40 <lethjakman> sorry this question is going to sound really dumb, but MaybeT IO a
21:04:42 <jle`> yeah, lifting is a very overloaded word in haskell
21:04:50 <jle`> people use it to talk about lifting functions, lifting actions...
21:04:52 <lethjakman> is that a MaybeT wrapped around an IO wrapped around a variable?
21:05:00 <kadoban> homa_rano: It indeed doesn't typecheck. You'd need a different combinator than (.), or you can do something like   blah a = m . (+a), which is itself not really great.
21:05:12 <lethjakman> oh, well I'm working with liftIO right now
21:05:15 <lethjakman> that's a confusing concept....
21:05:25 <jle`> lethjakman: if an `IO a` is an IO action, a `MaybeT IO a` is an IO action that can short-circuit
21:05:32 <jle`> and jump to the end of the computation if any step is a failure
21:05:43 <lethjakman> ahhh
21:05:44 <jle`> these are types, not values
21:05:49 <lethjakman> I was wondering if that was a possible thing to do
21:05:55 <lethjakman> so MaybeT IO a isn't separable
21:06:00 <lethjakman> IO a isn't really related?
21:06:13 <jle`> well, MaybeT is nice because it can add short-circuiting abilities to *any* monad
21:06:24 <homa_rano> kadoban: I take it there is not such a matching combinator built in?
21:06:26 <jle`> if you had `State s`, you can add short-circuiting to State s, too
21:06:29 <lethjakman> ahhh that's cool
21:06:34 <jle`> MaybeT (State s) is a stateful computation, with short-circuiting
21:06:48 <jle`> MaybeT (Reader r) is a computation with a global environment, with short-circuiting
21:06:50 <kadoban> homa_rano: Nope :-/
21:07:03 <jle`> wrt MaybeT, lift :: m a -> MaybeT m a
21:07:21 <homa_rano> kadoban: o well, thanks anyway
21:07:25 <jle`> so it lets you basically lift your normal state actions, or your normal IO actions, or your normal Reader actions into MaybeT IO, MaybeT (State s), MaybeT (Reader r) actions
21:07:30 <kadoban> homa_rano: If you were doing the same pattern a bunch of times it's of course easy to implement yourself, but usually not worth it.
21:07:47 <jle`> so if i had a computation in `MaybeT IO a`, and i wanted to putStrLn "hello!!"
21:07:58 <jle`> i would have to make it a MaybeT IO a, to blend in with everything else
21:08:05 <lethjakman> so, how is liftIO different than this? 
21:08:11 <lethjakman> we're still talking about lift correct?
21:08:18 <jle`> lift (putStrLn "hello!") would be a MaybeT IO (), which prints a string.  we know that it always "succeeds" too
21:08:24 <jle`> yeah
21:08:35 <lethjakman> ahhhh
21:08:36 <jle`> remember lifting is one of the most overloaded terms in haskell, heh
21:08:42 <lethjakman> neat!
21:08:55 <jle`> lift is generalized to work on all things that are like MaybeT --- things that take a Monad and return a new Monad with "new effects", "new powers"
21:09:05 <crusty_the_fig> So, like, what is Haskell used for? I know it's a programming language, but what is its general purpose. Like, you know, C is for low level stuff and JS is for web-side scripting.
21:09:07 <jle`> there's also StateT s, ReaderT r, ExceptT e, etc.
21:09:18 <init> lifting? you mean fmap? or transformers' lift? or lifting values to types? 
21:09:25 <lethjakman> ugh
21:09:32 <jle`> lethjakman: StateT s takes any monad, and returns a new monad with a `s` for state
21:09:32 <kadoban> crusty_the_fig: It's a general purpose programming language. It doesn't really have a niche like either of those.
21:09:48 <jle`> lethjakman: so if IO a is an IO action, StateT s IO a is an IO action that has access to a mutable `s` state
21:10:07 <jle`> MaybeT, StateT s, they both are these "give new powers to existing monads"
21:10:14 <crusty_the_fig> kadoban: So, it can be used for embedded systems and web-side programming? Nice!
21:10:18 <jle`> MaybeT :: monad -> monad
21:10:22 <jle`> StateT s :: monad -> monad
21:10:29 <lispy> crusty_the_fig: I would recommend reading this: http://www.scs.stanford.edu/~dbg/readings/haskell-history.pdf
21:10:40 <lethjakman> so is spelling out monad different than m?
21:10:45 <lispy> crusty_the_fig: that discuses the motivations behind creating it (and other fun stuff)
21:10:47 <jle`> nah, they're just variables
21:10:58 <jle`> technically it's MaybeT :: * -> *
21:11:02 <init> crusty_the_fig: anything that has hard realtime constraints is probably not going to end so nicely with a GC'd language
21:11:03 <lethjakman> ok
21:11:03 <kadoban> crusty_the_fig: Embedded might not be a great fit particularly. It's definitely nice for web, somewhat surprisingly. There's a lot of frameworks for web of various kinds.
21:11:09 <jle`> um sorry
21:11:14 <jle`> MaybeT :: (* -> *) -> (* -> *)
21:11:19 <jle`> (* -> *) is the monad here
21:11:20 <orion> After I've compiled and installed GHC 7.10.1, how do I compile and install cabal 1.22?
21:11:23 <jle`> but you do'nt have to worry about this, heh
21:11:34 <lethjakman> ok
21:11:36 <lethjakman> lol
21:11:36 <jle`> anyways, the `lift` function abstracts over all of these "monad transformers"
21:11:53 <jle`> so if i had a StateT s Maybe a, and I had a Maybe a, then lift :: Maybe a -> StateT s Maybe a
21:12:08 <jle`> StateT s Maybe a is StateT s "transformign" Maybe, so lift lets me use a Maybe in a StateT s Maybe
21:12:49 <jle`> lift is about monad transformers, letting you use actions in the monad-that-is-transformed in the transformed monad.  it lets you use IO in MaybeT IO...it lets you use Maybe in (StateT s) Maybe
21:13:23 <jle`> `liftIO` is unrelated to monad transformers, and the naming is just because haskellers like the word lift, heh
21:13:46 <jle`> a lot of times you'll be working with monads or types that let you sequence arbitrary IO actions
21:14:06 <jle`> like the Query type in persistent...it lets you query a database, but also you can putStrLn "hello" in the middle of your query
21:14:24 <jle`> the Query type lets you sequence actions in a database query, but you can also sequence arbitrary IO, too
21:14:26 <jle`> like writing to a file
21:14:34 <jle`> or asking a network connection for something
21:14:50 <jle`> liftIO abstracts over all types that let you sequence arbitrary IO in it
21:15:11 <jle`> so `liftIO :: IO a -> Query a` here.  it lets you take any IO action, like putStrLn "hello", and use it in a Query
21:15:14 <jle`> because Query can do arbitray IO stuff
21:15:28 <jle`> it has the powa
21:15:36 <lethjakman> funny, I'm actually looking at persistant 
21:16:10 <meow> Does the recommended CIS 194 course come with video?
21:16:15 <lethjakman> jeeze, I love these types but I also find it a bit confusing. it's gonna take me a while. 
21:16:34 <jle`> lethjakman: no worries, it's normal :)
21:16:39 <jle`> that's normal to take a while, i mean
21:16:59 <lethjakman> ok so you have to liftIO any IO actions in a monad that's unrelated to that monad.
21:17:28 <jle`> you use liftIO to use any IO action in a monad that supports it
21:17:39 <jle`> monads that support arbitrary IO actions are members of a typeclass called MonadIO
21:17:49 <lethjakman> and lift is used to make a short circuit maybe
21:17:51 <lethjakman> right?
21:18:00 <jle`> lift is generalizing over "monad transformers"
21:18:06 <jle`> MaybeT is one example of a monad transformer
21:18:17 <jle`> but for every monad transformer, it gives different effects/abilities
21:18:21 <lethjakman> so it's smart and can figure out if it needs to be a StateT?
21:18:27 <jle`> yeah
21:18:38 <jle`> like how when you use `return`, it can tell if you're in IO, or State s, or Maybe, etc.
21:18:43 <lethjakman> yeah
21:18:46 <lethjakman> smart, yet confusing
21:18:48 <lethjakman> lol
21:18:56 <lethjakman> I need a way to pause in the middle of executing a program and inspect shit.
21:19:09 <jle`> yeah heh.  the type is determined by the caller, which is a bit unintuitive when coming from other languages
21:19:25 <jle`> there's a lot of these types of things in haskell though; most people encounter the `read` function
21:19:33 <jle`> where read is a different type depending on where you use it
21:19:35 <kadoban> lethjakman: Have you messed about with the stuff in Debug.Trace? That tends to turn out to be enough for debugging for me so far.
21:19:44 <lethjakman> kadoban: no...
21:19:56 <lethjakman> I'll look at it
21:19:58 <lethjakman> kadoban: 
21:20:03 <lethjakman> jle`: ahhh
21:20:14 <lethjakman> yeah, I've noticed similar things. it's definitely different
21:20:19 <lethjakman> especially since I've been doing ruby for the last 2 years
21:20:33 <jle`> heh
21:20:40 <julianleviston> Is there a very simple way I can spit out AST for some string which contains haskell? something like parseToAST “1 + 2”
21:20:41 <jle`> i was doing ruby for a while before haskell too
21:20:47 <lethjakman> yeah?
21:20:50 <jle`> at least it prepares you for some of the functional aspects
21:20:52 <lethjakman> what made you go to haskell?
21:21:02 <lethjakman> yeah, a lot of the modern ruby stuff is moving towards functioanl
21:21:07 <jle`> julianleviston: there's the haskell-src library?
21:21:27 <julianleviston> jle`: yeah, there is.
21:21:34 <julianleviston> jle`: do you know how I might use it?
21:21:42 <jle`> lethjakman: yeah, a lot of ruby idioms involve passing in anonymous functions, so you get used to the idea.  modern javascript idioms are similar too
21:21:55 <jle`> julianleviston: hm let me see
21:22:11 <lethjakman> yeah, since I've been doing more haskell my javascript has changed a lot
21:22:23 <lethjakman> for the better in my opinion
21:23:40 <ttt_fff> I want to shorten "Expr" ... to 2 chars. Is that possible?
21:23:44 <julianleviston> jle`: is it runParser ? from the ParseMonad? https://hackage.haskell.org/package/haskell-src-1.0.2.0/docs/Language-Haskell-ParseMonad.html
21:23:59 <jle`> julianleviston: yeah, but you'll need to find a parser for an HsExpr
21:24:05 <jle`> i'm seeing if they provide one
21:24:10 <lethjakman> jle`: thank you again for all your help, it all makes more sense to me now :)
21:24:25 <jle`> lethjakman: no problem :)
21:24:59 <julianleviston> jle`: ah ok.
21:25:02 <jle`> for your earlier question, i like to use haskell over ruby now because i get a lot of safety and long-term maintainability, composability, compile-time guaruntees with little cost, and faster develpment times
21:25:22 <jle`> maintaining a ruby project past six months is insane without intense discipline
21:25:25 <jle`> haskell projects are a snap
21:25:35 <Welkin> *no pun intended*
21:25:41 <Welkin> *not an endorsement for Snap*
21:25:42 <lethjakman> yeah...I'm sick of writing unit tests that don't NEED to exist. 
21:25:55 <lethjakman> and then someone comments it out or it gets out of date and people give up on them for a while. 
21:26:13 <Welkin> I never had to deal with huge prohects with problems like that
21:26:22 <Welkin> I experienced those problems with tiny web applications
21:26:25 <lethjakman> by don't need to exist I mean, if we know it's a string and restrict the parameter to a string you don't need to test for integers...
21:26:28 <jle`> julianleviston: you can use http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Parser.html with parseExp
21:26:38 <julianleviston> I prefer haskell over Ruby mostly because the data isn’t mixed up with the code, and also for any real application, Ruby execution speed is not very good. (To put it mildly). Ruby executes orders of magnitude slower, and doesn’t really do concurrency easily.
21:26:42 <lethjakman> given rspec is nice...but still
21:26:56 <Welkin> quickcheck > unit tests
21:26:59 <lethjakman> I think I'm looking into doing more Yesod work instead of rails, maintenance looks much nicer. 
21:27:09 <lethjakman> Welkin: isn't there something even better? smartcheck?
21:27:11 <Welkin> lethjakman: yesod is very easy to change
21:27:19 <julianleviston> lethjakman:  haha the maintainer of rspec works for Cognitect now. :-) (The creator of Clojure, roughly)
21:27:20 <lethjakman> Welkin: I like hearing that :)
21:27:23 <Welkin> I built a few application already in yesod
21:27:33 <julianleviston> Yesod is a bit too magic for my preference.
21:27:33 <lethjakman> lol
21:27:37 <jle`> haskell with ghc lets you refactor fearlessly, make huge refactors six months to a year after touching a project without worrying about breaking anything
21:27:38 <Welkin> made major changes to one of them already
21:27:39 <lethjakman> clojure seems interesting too. 
21:27:42 <Welkin> and it was super easy
21:27:50 <jle`> getting up to speed on a ruby project you haven't touched for even two months is impossible
21:27:51 <julianleviston> lethjakman: clojure is great.
21:27:52 <lethjakman> julianleviston: what do you use? I was thinking about the same thing, but a lot of people seem to like template haskell. 
21:27:58 <lethjakman> julianleviston: do you find yourself missing the type system?
21:28:07 <lethjakman> rust looks super cool to me too
21:28:08 <julianleviston> lethjakman:  I havent’ started, but I’ll be using snap.
21:28:14 <lethjakman> I tried go...it just doesn't seem to go far enough for me thouhg. 
21:28:25 <jle`> yesod is magic in the same way rails is magic, i think.  you're sort of following the style/way that other people have decided works best together
21:28:30 <julianleviston> lethjakman: Clojure is like halfway between ruby and haskell, IMO
21:28:31 <Welkin> why settle for less when you can just use haskell?
21:28:32 <roboguy_> ttt_fff: you mean take the String "Expr" and get back "Ex"?
21:28:42 <julianleviston> jle`: yeactly
21:28:43 <lethjakman> julianleviston: I was considering that too. the magic of Yesod looks nice since it's still compile time checked though. it just generates a lot of functions for you. 
21:28:46 <meow> Are techniques learned in Haskell highly transferrable to Clojure, and other functional programming languages?
21:28:47 <ttt_fff> no, I mean I want to find a shorter name for Expr
21:28:48 <ttt_fff> maybe Xp
21:28:54 <ttt_fff> roboguy_ ^
21:29:03 <Welkin> clojure is a dynamically typed, strict language
21:29:05 <lethjakman> Welkin: well...the repl looks nicer in clojure, but that's about it. 
21:29:13 <julianleviston> meow: yes, roughly… but Haskell is super lazy, which is interesting… and provides more power.
21:29:23 <lethjakman> meow: well clojure is more about great metaprogramming from my understanding. 
21:29:23 <Welkin> I used the clojure repl for 5 minutes and then decided to learn haskell
21:29:24 <Welkin> haha
21:29:29 <julianleviston> meow: clojure isn’t super lazy, sometimes it is… but that means you need Macros.
21:29:29 <lethjakman> and other things obviously as well. 
21:29:39 <Welkin> jvm? let me just run the other way
21:29:48 <lethjakman> Welkin: lol. yeah my buddy is way into haskell, we compare a lot. haskell sounds more interesting to me. 
21:29:51 <kadoban> meow: The basics of thinking functionally maybe … but it'd be only broad strokes.
21:29:52 <jle`> meow: in many ways.  but honestly haskell code derives its power from things different than clojur derives its power from.  so some parts will help, but i think mostly indirectly
21:30:10 <julianleviston> jle`: oh I’ll have a look at that, but I really have no clue about how to clue the things together. I’ll try now :)
21:30:21 <lethjakman> Welkin: but it's the only JVM language that remotely interests me, may be a good tool for the tool belt
21:30:29 <Welkin> the real power of haskell comes from the type system
21:30:46 <Welkin> it's basically half the language
21:30:46 <jle`> julianleviston: parseExp :: String -> ParseResult Exp, so just use it on a string
21:31:00 <julianleviston> Welkin: I kinda think curried functions is really powerful, too…
21:31:04 <lethjakman> there needs to be some amazing guide on understanding the damned thing. 
21:31:11 <lethjakman> I love curried functions
21:31:13 <jle`> julianleviston: Exp is a sum type/ADT with these constructors -- http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Syntax.html#t:Exp
21:31:18 <julianleviston> jle`: I just kinda wanted to type something into GHCi - not sure how to import that module or download it or whatever.
21:31:23 <jle`> ParseResult is more or less a glorified either
21:31:30 <jle`> julianleviston: ah, you'd use cabal
21:31:32 <julianleviston> ok I’ll take a look
21:31:37 <lethjakman> julianleviston: load it from a file
21:31:38 <lethjakman> :l
21:31:47 <julianleviston> jle`: haha erm… this doesn’t sound so simple :-)
21:31:47 <jle`> but remember to use sandboxes ^^\
21:31:56 <jle`> cabal is the main workflow for these things heh
21:32:00 <jle`> mkdir mystuff
21:32:02 <jle`> cabal sandbox init
21:32:08 <jle`> cabal install haskell-src-exts
21:32:15 <jle`> cabal exec ghci
21:32:17 <julianleviston> jle`: oh you rock.
21:32:17 <jle`> then you're good to go :D
21:32:26 <jle`> (there's a cd mystuff there)
21:32:26 <julianleviston> jle`: marry me :)
21:32:35 <Welkin> cabal exec -- <extensive command here>
21:32:38 <bitemyapp> julianleviston: no I have dibs.
21:32:40 <lethjakman> well that escalated quickly
21:32:47 <julianleviston> lol
21:32:50 <jle`> i can officiate if that's what you mean
21:32:59 <jle`> i hear the licensing process isn't too bad
21:33:10 <lethjakman> can't you just get it online?
21:33:14 <julianleviston> jle`: haha… 
21:33:33 <bitemyapp> lethjakman: there's add'l paperwork to be a legal officiant.
21:34:07 <lethjakman> bitemyapp: I guess it depends on how bad the paperwork is. 
21:35:04 <crusty_the_fig> Does anyone know if the SICP Python redesign is any good: http://composingprograms.com/
21:35:43 <Welkin> crusty_the_fig: no, because python doesn't even have proper support for recursion
21:35:54 <Welkin> nor proper lexical scoping
21:35:59 <bitemyapp> Welkin: PYTHON DOESNT EVEN
21:35:59 <Welkin> or anything else
21:36:05 <bitemyapp> Welkin: PYTHON LITERALLY CANT EVEN
21:36:08 <Welkin> or anything resembling functional programming in any way
21:36:11 <bitemyapp> sorry, couldn't help it.
21:36:35 <Welkin> bitemyapp: can't stop won't stop
21:36:39 <lethjakman> any amazing resources on the haskell type system?
21:36:40 <bitemyapp> but yeah, Welkin is right, embedding FP in Python is pointless.
21:36:43 <bitemyapp> lethjakman: yes
21:36:45 <lethjakman> I can't find anything that looks like what I want
21:36:46 <crusty_the_fig> bitemyapp: What do you think about Composing Programs?
21:37:21 <bitemyapp> crusty_the_fig: I think using languages like Python to teach "FP" impoverishes people.
21:37:29 <lethjakman> lol I got into an argument with my friend the other day because I want ruby to have proper currying...
21:37:36 <lethjakman> I think it'd fit well into any language. 
21:37:44 <julianleviston> lethjakman: yeah, but the implications don't.
21:37:56 <lethjakman> julianleviston: why's that? 
21:38:03 <lethjakman> bitemyapp: wana link me? 
21:38:15 <lethjakman> lol
21:38:17 <bitemyapp> I don't know.
21:38:21 <lethjakman> :(
21:38:30 <lethjakman> oh you're just saying it's out there?
21:38:55 <bitemyapp> lethjakman: I'm being lazy. uno momento.
21:38:59 <lethjakman> oh
21:39:08 <lethjakman> like in haskell?
21:39:24 <bitemyapp> I'm writing rn and I'm just going to dump what we reference in the book
21:39:28 <julianleviston> lethjakman: because objects? I’m not sure. Try to implement some functionality with currying.
21:39:53 <bitemyapp> lethjakman: wait a second
21:39:58 <bitemyapp> lethjakman: how well do you know Haskell?
21:40:02 <AaronFriel> bitemyapp: I don't know about that
21:40:10 <AaronFriel> bitemyapp: Re: embedding FP in Python is pointless
21:40:22 <julianleviston> jle`: is cabal install supposed to take like a long time?
21:40:26 <lethjakman> bitemyapp: I've read LYAH, some of the wiki, talked on here, and I'm reading the Yesod book
21:40:37 <bitemyapp> AaronFriel: well, I've got a decade of attempting as much in Python behind me
21:40:38 <lethjakman> so, I'm scratching the surface really
21:40:39 <julianleviston> jle`: long time = over 5 minutes?
21:40:44 <bitemyapp> AaronFriel: I'm pretty comfortable saying it's a waste of time.
21:41:06 <AaronFriel> bitemyapp: I went to a midwest computing conference and they had a college programming competition, I placed 2nd or 3rd by doing it in python and solving literally every problem in the form of generators
21:41:32 <AaronFriel> bitemyapp: I was like, "Oh, these are lazy lists! I can implement literally everything else I need based on this."
21:41:35 <lethjakman> julianleviston: there's currying in ruby, but only for lambda's
21:41:49 <Welkin> generators do not make functional programming
21:41:52 <lethjakman> which just makes it fun to use
21:42:07 <julianleviston> lethjakman: you can curry in any language that has first class functions… but that doesn’t mean it’ll be easy to implement any actual functioality in it.
21:42:08 <AaronFriel> Welkin: No, but I abused the heck out of them and wrote everything in a functional style, composing over generators.
21:42:18 <lethjakman> true
21:42:28 <AaronFriel> Welkin: Maps, folds, zips
21:43:10 <AaronFriel> Welkin: It was just a hack for me, because I didn't know Python's standard library for crap. But I did know how to invent just about any data structure or operation I needed in the form of lazy lists.
21:43:47 <lethjakman> bitemyapp: oh, wait, you're not talking about something that already exists? 
21:43:55 <lethjakman> you have to write it down?
21:44:28 <bitemyapp> lethjakman: no, it's a list of resources.
21:44:36 <bitemyapp> Start here: https://wiki.haskell.org/Research_papers/Type_systems
21:46:11 <lethjakman> sweet!
21:46:15 <lethjakman> thank you :)
21:46:29 <julianleviston> I just tried cabal exec ghci and it says exec isn’t a command… 
21:46:39 <lethjakman> another thing I've noticed...there aren't a lot of examples with the source code. is that intentional for some reason?
21:46:52 <lethjakman> s/source code/documentation/
21:47:02 <lethjakman> just seems like every time I look up something it's not greatly documented
21:48:27 <AaronFriel> lethjakman: This is an aside, but re: type theory, you may want to read or find introductory papers (like this: http://www.cs.ru.nl/~herman/onderwijs/provingwithCA/paper-lncs.pdf) to learn how to read type theory equations
21:49:07 <lethjakman> that would probably be helpful for me
21:49:12 <AaronFriel> Otherwise they will just look like gibberish. Type theory judgements (the horizontal bar, stuff on top, stuff on bottom) take getting used to
21:49:15 <lethjakman> man...all these academic papers are a total switch for me
21:49:45 <AaronFriel> lethjakman: Also keep in mind, you can be a successful Haskell programmer without any knowledge of those at all
21:49:53 <julianleviston> should `cabal exec ghci` work?
21:51:19 <lethjakman> AaronFriel: psh. not good enough. 
21:51:56 <lethjakman> ;)
21:52:27 <AaronFriel> lethjakman: I can't write a type theory paper, and I would wager most of the "productive programmers" who work with Haskell can't, or probably couldn't without a ton of front-end work to do it. I also can only barely read a lot of the type theory papers published.
21:52:42 <julianleviston> should I use stack or cabal to do things?
21:53:00 <julianleviston> I guess I should make up my own damn mind ;)
21:53:30 <AaronFriel> julianleviston: Stack is really new, so I would stick with Cabal for now unless you're really sure what you want. Stack didn't work for me because I have old (pre-Stack) projects that have dependencies that don't work cleanly with their model.
21:53:59 <AaronFriel> julianleviston: If you're doing a greenfield project... something totally new, just messing around. Stack isn't a bad place to start.
21:54:03 <julianleviston> AaronFriel: thanks. I think my problem (not having cabal exec work) might just be that I’ve got an old version or something.
21:54:15 <AaronFriel> julianleviston: If you use Cabal, I would stick with doing everything in sandboxes.
21:54:26 <AaronFriel> julianleviston: So, the first thing I do when I create a project is "cabal sandbox init"
21:54:33 <lethjakman> AaronFriel: oh, I don't want to do a write a type theory paper, I just want to understand how it's working a bit better. 
21:54:45 <julianleviston> AaronFriel: ok thanks. I’m just updating now. I did sandbox init, but my cabal doesn’t seem to have an exec!
21:54:52 <AaronFriel> ah
21:54:57 <julianleviston> AaronFriel: which seems heaps weird to me!
21:55:10 <AaronFriel> julianleviston: do "cabal install cabal-install" in a folder outside of your sandbox 
21:55:16 <AaronFriel> julianleviston: that should get you on the latest
21:55:23 <lethjakman> anyways, I've gotta get out of here, thank you everyone!
21:55:33 <julianleviston> AaronFriel: haha I just realised I’d done it insied my sandbox guhhh :) hehe will do once this has finished.
21:56:05 <AaronFriel> julianleviston: Alternatively, and this happens unfortunately often, your GHC packages can just get messed up. It's dependency hell in there (which is why I use sandboxes for everything)
21:56:13 <meow> Is Stack a replacement for Cabal?
21:56:18 <AaronFriel> julianleviston: In those cases, I actually burn everything to the ground and restart.
21:56:35 <julianleviston> meow: sort-of.
21:56:49 <AaronFriel> meow: It's a replacement for Haskell Platform, it uses cabal, but it does weird and interesting things to make it easier to build greenfield projects with a "Stable" set of Haskell packages from Hackage/Stackage
21:57:07 <julianleviston> meow: from what I understand, it’s an attempt by snoyman to improve the package management and tooling situation for haskell newbies.
21:57:11 <AaronFriel> meow: The downside is that if you are trying to move a new project to it, expect lots of build problems.
21:57:18 <AaronFriel> meow: Err, old project.
21:57:32 <AaronFriel> meow: But for new projects I've started, it seems very reliable.
21:57:56 <AaronFriel> meow: I am kind of a weirdo, and I do all my development remotely with a Linux machine "In The Cloud" using Docker
21:58:08 <meow> Ah thanks, I'm just trying to learn, so I don't think I need to support old stuff.
21:58:25 <AaronFriel> I blow away my base image (along with all the installed binaries, GHC, Stack, etc.) periodically to makes sure I can build on a clean machine
21:59:27 <julianleviston> AaronFriel: thanks for the help. I’d inc you, but I don’t know the syntax in here.
21:59:51 <AaronFriel> I don't know what incing means
21:59:58 <AaronFriel> I hope it's a good thing
22:00:04 <julianleviston> AaronFriel: haha that is in itself synatx. (+1)
22:00:26 <julianleviston> inc is clojure for increment.
22:00:34 <AaronFriel> oh
22:00:37 <AaronFriel> thank you :)
22:00:59 <AaronFriel> I will take your (+1) and apply it to a suitable instance of Num.
22:03:49 <julianleviston> Is (+1) a morphism in the category Num?
22:04:08 <chreekat> AaronFriel: I wouldn't call stack a replacement for haskell platform. Primarily it's an alternative to cabal-install. On my system it's using the existing ghc et al
22:04:11 <julianleviston> don’t answer that. It’s jus tme being silly.
22:04:56 <AaronFriel> chreekat: When I install stack on my Docker instance, it pulls a custom GHC from them, plus a set of base packages and dependencies. I never "apt-get install ghc" or "apt-get install haskell-platform [sic]" or whatever
22:05:30 <AaronFriel> chreekat: Instead, I just "stack init" in my build script. Bam. GHC, a base system with packages known to work together, etc.
22:05:54 <AaronFriel> err, "stack setup"
22:06:01 <AaronFriel> I don't have my build script in front of me
22:07:09 <AshyIsMe> stack has been really nice so far
22:07:17 <julianleviston> i don’t get it. How can I run ghci in my sandbox? I thought it was cabal exec ghci, but this doesn’t work at all - unrecognised command exec
22:07:30 <chreekat> julianleviston: cabal repl
22:07:49 <julianleviston> chreekat: oh how did I miss that? thank you! :)
22:07:54 <chreekat> :)
22:08:20 <julianleviston> chreekat: oh that doesn’t work either- it’s complaining that package has never been configuerd
22:08:23 <julianleviston> configured
22:08:45 <chreekat> AaronFriel: I suppose stack is a replacement for haskell platform *and* cabal-install. Although I thought I saw someone talking about making Haskell Platform actually just use stack under the hood
22:09:17 <chreekat> julianleviston: yeah :| The usual incantation is 'cabal sandbox init; cabal configure; cabal ...'
22:09:30 <julianleviston> chreekat: oh I missed the configure step
22:09:37 <AaronFriel> julianleviston: Also, make sure you install your dependencies in your sandbox
22:09:45 <chreekat> oh yeah, forgot that one
22:09:48 <julianleviston> huh?
22:09:51 <chreekat> cabal install --only-dependencies
22:09:56 <AaronFriel> julianleviston: I think one of the other steps does that automatically, but I do "cabal install --only-dependencies"
22:09:59 * chreekat has switched totally to stack
22:10:06 <johnw> if you have a customer you want to deploy a Haskell solution to, who knows nothing about getting GHC, cabal, etc., stack seems like it's being built to answer that kind of scenario
22:10:09 <julianleviston> chreekat: maybe I should too
22:10:27 <AaronFriel> julianleviston: Probably, as I said if you're working on a totally brand new project
22:10:36 <julianleviston> AaronFriel: yeah, all mine are.
22:10:43 <chreekat> I just switched a 3-year-old project; don't know if that counts as 'new'
22:10:53 <AaronFriel> julianleviston: If you're "git clone"ing someone else's code, that's one thing. Stack gave me pages and pages of dependency resolution problems for one of my projects
22:10:56 <johnw> I prefer Nix for my own development, but I'd be hard-pressed to want to inflict that on someone without the same devotion to the environment itself
22:11:07 <julianleviston> I generally have an aversion to magic.
22:11:21 <julianleviston> but for package managers, magic can be helpful.
22:11:24 <AaronFriel> johnw: Interesting. I went the other way around. Fully mutable, but I use Docker and rebuild my base image on the regular.
22:11:37 <johnw> yes, Docker/VMs are another good way to deploy
22:11:41 <johnw> or even just static binaries
22:11:43 <AaronFriel> johnw: Which forces me to keep my build scripts reliable
22:11:49 <AaronFriel> johnw: I actually do my development in Docker!
22:12:03 <AaronFriel> johnw: My user account is a volume mapped into a container that gets periodically recreated
22:12:14 <johnw> FP Complete makes its money selling code, so I imagine they want to give their customers a foolproof way to replicate what they build themselves
22:12:14 <AaronFriel> johnw: And then I X11 forward from that to my Windows desktop
22:12:20 <chreekat> AaronFriel: I suppose that project's dependencies are either version-constrained to something earlier than what is in a recent LTS, and/or has lots of non-hackage deps
22:12:35 <johnw> AaronFriel: VMs are pretty awesome :)
22:12:36 <AaronFriel> chreekat: Yes to the former. Lots of old deps.
22:13:06 <julianleviston> AaronFriel: I’m confused… what were the pages and pages of dependency resolution problems?
22:13:15 <AaronFriel> julianleviston: Oh, you don't have to worry about those
22:13:16 <Welkin> I need to check out nix
22:13:25 <AaronFriel> julianleviston: I have a project built on an ancient version of Yesod
22:13:33 <julianleviston> I’m just trying to try out the parseExp from haskell-src
22:13:39 <johnw> Welkin: Nix can be fantastic
22:13:42 <AaronFriel> julianleviston: Which... itself depends on old versions of Conduit and dozens of other libraries
22:13:52 <julianleviston> AaronFriel: ah ok
22:13:52 <Welkin> does it replace cabal in many ways?
22:14:01 <julianleviston> AaronFriel: well, we’ll see.
22:14:08 <johnw> it replaces it as a package manager
22:14:15 <johnw> it still uses it to do the actual building
22:14:27 <johnw> but you rarely need to interact with cabal yourself directly, unless you want to
22:15:16 <AaronFriel> johnw: And I understand it handles multiple projects fairly well, in terms of having duplicate (different version, same lib) dependencies in use by separate projects?
22:15:17 <johnw> it involves more work if you want to use a set of old packages pinned at a particular version, though
22:15:34 <johnw> AaronFriel: yes, multiple projects all share common binaries
22:15:39 <johnw> since everything is hashed and kept in an immutable store
22:16:09 <johnw> which means you get rollbacks, multiple user environments, automatic sandboxing for all projects, etc.
22:16:22 <AaronFriel> johnw: That sounds nice. Stack sort of emulates that on top of other OSes, right? Whereas if I recall, cabal sandbox might install a dependency twice.
22:16:34 <johnw> stack is doing what it does for Haskell packages only
22:16:38 <johnw> with Nix, it's turtles all the way down
22:16:42 <AaronFriel> johnw: Right, yeah
22:16:45 <johnw> to GRUB even, if you're using NixOS
22:16:52 <AshyIsMe> which is why i like stack so much i think
22:16:59 <AaronFriel> johnw: I don't peek in my sandbox folder because I don't want to break it.
22:17:05 <AshyIsMe> you don't have to go crazy hard into nix just to mess around with a h askell project
22:17:14 <nikki93> @pl get >>= \s -> put (S.insert x s) >> return (S.member x s)
22:17:14 <lambdabot> ap ((>>) . put . S.insert x) (return . S.member x) =<< get
22:17:14 <johnw> AshyIsMe: yeah, that's true
22:17:17 <AshyIsMe> i think it will be good for bringing interested people in to haskell 
22:17:25 <johnw> like I said, at this stage of the game you have to *want* to involve yourself in Nix
22:17:32 <AshyIsMe> i was confused and angry as hell with cabal when i first started with haskell
22:17:35 <AaronFriel> AshyIsMe: I agree. GHC/Stack/Cabal needs to replicate the Rust experience.
22:17:54 <AshyIsMe> i havent used rust but yeah even npm for node is a breeze to use
22:17:56 <johnw> it's sad that every language has to reinvent this same wheel, over and over and over again
22:17:59 <AaronFriel> AshyIsMe: It's so easy to get started with Rust. "cargo" this, "cargo" that. Boom, things compile so easily.
22:18:07 <AshyIsMe> (with all the horrible hidden problems of javascript of course)
22:18:10 <AaronFriel> johnw: Yeah, that's true. 
22:18:45 <AaronFriel> AshyIsMe: Well, and the fact that NPM creates a maze of labyrinthine directories that is impossible to understand
22:18:59 <AaronFriel> AshyIsMe: And blows up Windows silly short path limitations :(
22:19:18 <AshyIsMe> yeah it was just an example, it's "easy to get going" 
22:19:23 <AshyIsMe> that's what haskell needs
22:19:57 <AshyIsMe> so i can go "just install stack, git clone the project and run 'stack build'" to people and have it work for them
22:20:11 <AaronFriel> AshyIsMe: Yes, precisely. That is dearly missing from Haskell.
22:20:27 <AshyIsMe> instead of "lol, spend days(weeks?) trying to get a stable ghc and cabal setup that works with my project"
22:20:33 <chromatome> Is there a function that will concat a tuple of lists?
22:20:41 <chromatome> ([a],[a]) -> [a]
22:20:51 <johnw> uncurry (<>)
22:20:53 <AaronFriel> AshyIsMe: Previously that list of instructions would be: "go install GHC. Oh, you're on CentOS 6? Sorry, go get this RPM here and install that GHC. But make sure you delete *EVERYTING* from the old GHC install first.
22:21:12 <AaronFriel> AshyIsMe: Then make sure you wipe out Cabal. Now don't install the Haskell Platform because the dependencies for this project won't resolve if you installed it
22:21:26 <nikki93> hey all -- in the NICTA course, why is 'findM' after monad stuff but 'finding' after applicative stuff? both rely on context from previous list elements...
22:21:35 <AaronFriel> AshyIsMe: Then make sure you run "cabal sandbox init" after you git clone, then "cabal isntall --only-dependencies", then finally you can "cabal build"
22:22:06 <julianleviston> wow that’s pretty fail. I have GHC 784, and stack is now downloading it again. sigh.
22:22:10 <AaronFriel> AshyIsMe: I have ranted about Cabal being broken for new users many times.
22:22:36 <AaronFriel> julianleviston: There's a good reason Stack is getting it again. It wants to be sure your other one isn't broken. :P (And the only way to be sure is to set up its own copy in your user directory.)
22:23:16 <AaronFriel> julianleviston: Stack by default doesn't require root to run, it runs under your user account, and installs everything there. (GHC installs in /usr/bin or /usr/local/bin by default, which are privileged directories)
22:23:49 <julianleviston> AaronFriel: so this won’t happen every single time I create a new project?
22:23:53 <AaronFriel> (But there are caveats to even that, as cabal and GHC will set up package dependencies in your user directory by default, and yada yada, stuff that's not relevant)
22:24:00 <AaronFriel> julianleviston: No, it will only happen once
22:24:06 <AshyIsMe> AaronFriel: i completely agree, the old way was mental for new users
22:24:16 <AaronFriel> julianleviston: Stack will re-use what it has downloaded from now on
22:24:20 <AshyIsMe> as a new user you're thinking "god this language better be worth it"
22:24:28 <AaronFriel> AshyIsMe: Right?!
22:24:29 <julianleviston> it’s still so fiddly.
22:24:35 <julianleviston> now I have to adjust my path.
22:24:36 <julianleviston> mep.
22:24:39 <AaronFriel> julianleviston: Let me tell you of a dark age
22:24:43 <AshyIsMe> it must be something like 10-30% at most that stick with it long enough to actually learn haskell
22:24:44 <AaronFriel> julianleviston: Before cabal sandbox
22:24:53 <julianleviston> AaronFriel: nah, it’s cool. I know about dark ages. :) 
22:25:00 <AaronFriel> julianleviston: It used to be a normal thing to have to delete your entire .ghc folder
22:25:05 <AaronFriel> julianleviston: and rebuild *everything*
22:25:14 <AaronFriel> julianleviston: that's what the sages told you to do when things went wrong
22:25:25 <julianleviston> AaronFriel: yeah, I’m not that fussed about the past. I’ve lived thru my fair share of hells… that’s the point.
22:25:41 <AshyIsMe> but yeah, stack has been a breath of fresh air so far
22:25:58 <AshyIsMe> im hoping it becomes the defacto package tool for haskell
22:26:00 <julianleviston> and may its air get ever fresher :) 
22:27:28 <AaronFriel> Okay, so here's an interesting question for any learned Haskell folks that might be here 
22:28:02 <AaronFriel> I have this data access library I'm working on, it's on github here: https://github.com/aaronfriel/hyhac/
22:28:11 <AaronFriel> And I'm not happy with how ugly the backend is.
22:28:41 <johnw> AshyIsMe: I don't want it to become the de facto tool so long as it primarily serves the interests of a single commercial company.  I'd like to see receive more adoption and collaboration from the open source community.
22:29:06 <AaronFriel> Specifically I'm using associated data types (data families?) to share a back end that is similar, but has different C/FFI APIs for "admin" tasks (like creating or removing tables) and "client" tasks 
22:29:15 <AaronFriel> And that leads to type signatures like
22:29:40 <AshyIsMe> johnw: yeah that too, but so far they've developed a very nice tool
22:29:49 <julianleviston> Ooh ok now I’ve got stack set up, this is very nice! :)
22:30:23 <AaronFriel> okay so my X11 forwarding isn't perfect because the window disappeared
22:30:24 <AaronFriel> one second
22:30:37 <johnw> AshyIsMe: well, certainly if you use Linux :)
22:31:02 <AaronFriel> Okay, so I use associated data types, e.g.:
22:31:07 <jle`> julianleviston: ah i probably should have warned you, haskell-src-exts is a bit of a heavy package
22:31:07 <AshyIsMe> johnw: im on osx but yeah
22:31:10 <AaronFriel> instance HyperDex Client where
22:31:10 <AaronFriel>  data ReturnCode Client = ClientSuccess
22:31:12 <AshyIsMe> no idea how it goes on windows
22:31:19 <julianleviston> jle`: it’s cool… :)
22:31:21 <AaronFriel> AshyIsMe: it doesn't
22:31:22 <julianleviston> jle`: thanks.
22:31:32 <AshyIsMe> i stick to visual studio only projects in windows
22:31:43 <AaronFriel> AshyIsMe: you might think it does
22:31:53 <AshyIsMe> my dream is to one day never have to use windows again while still working full time as a developer
22:31:55 <AaronFriel> AshyIsMe: And Stack will do a bunch of stuff to lead you to believe it might work
22:31:58 <AshyIsMe> one day...
22:32:04 <AaronFriel> AshyIsMe: But then you get to some dependency like "network"
22:32:13 <julianleviston> AshyIsMe:  Hey I’m already at that dream!
22:32:17 <AaronFriel> AshyIsMe: And I don't know what the problem is but no one will commit changes to make it build on Windows
22:32:25 <AshyIsMe> julianleviston: nice!
22:32:48 <AaronFriel> AshyIsMe: I don't know if the devs don't care, or if they're refusing to accept patches, or if there's just no inertia, but there are a lot of packages that depend on unix-y dependencies that refuse to build on Windows
22:32:51 <AshyIsMe> AaronFriel: it's because self respecting developers dont punish themselves willingly by using windows for their hobby projects
22:33:12 <AshyIsMe> the only reason you do it is because someone is paying you, or you're working on a product you want to sell to windows users
22:33:27 <AaronFriel> AshyIsMe: I dunno, I'm running Windows 10, but yeah I do my Haskell development using a remote environment
22:33:41 <julianleviston> My last full time job sucked so hard - we had to deploy multiple versions of our app across minesites where they used winXP. Yay for IE6… and the server code had to run on many versions of windows and linux and os/x. Fun!
22:34:17 <AshyIsMe> AaronFriel: ive used osx as my main local OS for a couple years now and i could never go back to windows as a main os anymore
22:34:18 <bitemyapp> AaronFriel: lots of Windows Haskell users, very few Windows Haskell committers.
22:34:35 <orion> bitemyapp: Hi.
22:34:47 <bitemyapp> orion: hi
22:34:51 <AaronFriel> bitemyapp: Probably the problem, yes. And of course, I'm part of the problem. If I *really cared* I could probably figure out how to reliably build these packages and submit patches to get it to work on Windows
22:34:56 <AaronFriel> bitemyapp: But I don't.
22:35:00 <bitemyapp> well then.
22:35:07 <orion> bitemyapp: https://github.com/centromere/bloodhound/commit/42b0e928212a41ab6cc9f7790cdbf19ebad0de5b
22:35:14 <AshyIsMe> julianleviston: oh god that sounds painful
22:35:14 <AaronFriel> bitemyapp: I know I have no one to blame but everyone else who came before me.
22:35:27 <bitemyapp> orion: looks good 2 me
22:35:47 <AaronFriel> On another note, I am dissatisfied with my backend code for my Database library because, I'm well, not sure if it's idiomatic and is what I should be doing.
22:35:49 <AshyIsMe> julianleviston: you're australian as well im guessing?
22:35:53 <julianleviston> AshyIsMe: It was incredibly painful. Also, it was a rails (ie ruby) app… and it had to run on 3 different types of database.
22:35:55 <julianleviston> AshyIsMe: yep.
22:35:56 <bitemyapp> orion: thanks for documenting the field selection itself :)
22:36:04 <AaronFriel> See: https://github.com/AaronFriel/hyhac/blob/testfail/src/Database/HyperDex/Internal/Client.chs#L40-L52
22:36:08 <ttt_fff_> is there something like bitcask, but implemented in haskell ?
22:36:26 <orion> bitemyapp: NP!
22:36:46 <AaronFriel> I feel like that's very UnHaskell-Y
22:36:50 <bitemyapp> ttt_fff_: there's a Riak client
22:37:02 <AaronFriel> Using data families in general seems very unhaskelly
22:37:06 <AshyIsMe> julianleviston: yeah that sounds pretty painful, what are you working on now that you can avoid windows entirely?
22:37:21 <AaronFriel> And I'm not sure if I should be doing something different that's more sane
22:37:41 <julianleviston> AshyIsMe: This: www.getcontented.com.au
22:38:44 <AshyIsMe> julianleviston: ah nice, using haskell?
22:39:13 <julianleviston> AshyIsMe: not yet, sadly. 
22:39:40 <julianleviston> AshyIsMe: Originally written in Rails backend with an Ember (JS) frontend…
22:40:02 <julianleviston> AshyIsMe: Just updated the front end to clojurescript (last week actually!) which is SO much better.. 
22:40:30 <julianleviston> AshyIsMe: next am looking at transitioning the backend to clojure, and then finally will rebuild in haskell once that’s done.
22:42:29 <AshyIsMe> haha nice
22:42:36 <AshyIsMe> why not straight to haskell?
22:43:45 * hackagebot opentheory 1.200 - The standard theory library  https://hackage.haskell.org/package/opentheory-1.200 (JoeHurd)
22:43:47 * hackagebot opentheory-stream 1.46 - Infinite stream types  https://hackage.haskell.org/package/opentheory-stream-1.46 (JoeHurd)
22:43:49 * hackagebot opentheory-divides 1.63 - The divides relation on natural numbers  https://hackage.haskell.org/package/opentheory-divides-1.63 (JoeHurd)
22:43:51 * hackagebot opentheory-fibonacci 1.69 - Fibonacci numbers  https://hackage.haskell.org/package/opentheory-fibonacci-1.69 (JoeHurd)
22:44:19 <julianleviston> AshyIsMe: yeah… I’d love to just start using haskell straigtht away for front and back end, but I’m relying on too many of Rails’s magic things at the moment, and I know the clojure ecosystem better for certaint things (like web security / permissions) and before I move to Haskell I’d like to possibly switch to DynamoDB…. and really get a handle on the types I’m using… I don’t have enough haskell yet
22:46:46 <AshyIsMe> ah yeap fair enough
22:46:51 <julianleviston> AshyIsMe: I have to build some experimentation projects in Snap and Reflex (an FRP “framework in GHCJS) before I’ll be confident I can migrate our app to it.
22:46:54 <AshyIsMe> yeah i havent used haskell in anger yet either
22:47:05 <AshyIsMe> only for a couple small personal projects
22:47:07 <AaronFriel>          Properties   Test Cases  Total
22:47:08 <AaronFriel>  Passed  80           4           84
22:47:08 <AaronFriel>  Failed  0            0           0
22:47:08 <AaronFriel>  Total   80           4           84
22:47:10 <AaronFriel> feels good
22:47:37 <AaronFriel> been a long time since I saw 100% of tests pass :')
22:48:13 <julianleviston> AaronFriel: are you using generative testing?
22:48:29 <AaronFriel> julianleviston: I think by that you mean quickcheck?
22:48:38 <julianleviston> AaronFriel: yep
22:48:46 <AaronFriel> julianleviston: Most of my tests are QuickCheck properties
22:49:03 <AaronFriel> julianleviston: Which also serves as a nice (albeit limited) fuzz tester of the database I am using
22:49:52 <AaronFriel> julianleviston: The database I am working with supports non-trivial data types in a key value store, data types like maps, lists, and sets
22:50:17 <julianleviston> AaronFriel: is it dynamodb?
22:50:21 <AaronFriel> julianleviston: So I have to make sure that I can round-trip arbitrary data through the database. 
22:50:30 <AaronFriel> julianleviston: No, hyperdex (http://hyperdex.org)
22:54:08 <julianleviston> well I can’t seem to work out how to load this package into ghci… so I’m going to give up for now. Kind of sucks a bit. It keeps telling me it can’t satisfy -package new-template now. Yay ! funtimes :
22:55:51 <dibblego> nikki93: what is finding in NICTA/course?
22:56:46 <nikki93> dibblego: I meant 'filtering' sorry
22:56:50 <nikki93> it is filter but the predicate accumulates context as it goes
22:57:15 <nikki93> filtering f = foldRight (\x s -> (\a l -> if a then x :. l else l) <$> f x <*> s) (pure Nil)
22:57:37 <nikki93> (foldRight is foldr, :. is : -- they just use their own list implementation)
22:58:53 <premjg> @lambdabot
22:58:53 <lambdabot> Unknown command, try @list
22:59:42 <dibblego> nikki93: right, filtering requires Applicative only
23:00:02 <nikki93> ya I'm jut tryna think about it conceptually
23:00:22 <nikki93> that was my own implementation of filtering so I get it but the abstract idea is a bit weird
23:00:35 <dibblego> nikki93: it is also close to the given answer that is used in the course proper
23:00:47 <dibblego> \p -> foldRight (\a -> lift2 (\b -> if b then (a:.) else id) (p a)) (pure Nil)
23:01:33 <nikki93> dibblego: and here's my findM
23:01:45 <nikki93> findM p (x :. xs) = p x >>= \b -> if b then return (Full x) else findM p xs
23:01:46 <nikki93> haven't looked at the course answer for findM yet cuz I'm still doing State.hs
23:02:03 <nikki93> my question is, why does filtering require Applicative but findM require Monad... conceptually
23:02:25 <adarqui> what's the point of using the xs@ label here? span _ xs@[]            =  (xs, xs)
23:02:35 <adarqui> just readability/style?
23:03:44 <wyager> Hello all. I am trying to write some matrix math stuff in Haskell using the Vector library. I am writing a function with the type signature `Vector a -> Vector (Vector a) -> Vector a`. There are two such functions that make sense. One is, in matrix math terms, `\a b -> (transpose a) * b`. This is eloquently and efficiently expressed as `\a b -> map (sum . zipWith (*) a) b`. The other function, in matrix math terms, is `\a b -> 
23:03:44 <wyager> (transpose a) * (transpose b)`. However, I cannot seem to find a concise, clean way of expressing this operation. This is important for more than just aesthetics; using "ugly" primitives like `generate` break Vector's fusion framwork and lead to slower code. Does anyone have any suggestions for writing the second operation? 
23:03:50 <julianleviston> adarqui:  it matches empty list, and names it.
23:04:29 <nikki93> adarqui: you mean as opposed to span _ [] = ([], []) ?
23:04:33 <adarqui> ya i know but, why don't they just do ([], [])
23:04:33 <adarqui> ya
23:05:13 <julianleviston> adarqui: same reason you ever use a name/var… it helps explain intent… and gives you one place to define something.
23:05:15 <arkeet> where did you find it?
23:05:22 <adarqui> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC-List.html#span
23:05:30 <unb3k44n7> I just got told I talk in a non-human fashion. *sigh that explains a lot. 
23:05:34 <adarqui> julianleviston: right, that's my question.. is it simply style or, is there something else going on?
23:05:46 <arkeet> it may have some performance difference.
23:05:57 <arkeet> e.g. sharing the result values with the original list, instead of constructing two new []s
23:06:00 <arkeet> not sure.
23:06:42 <unb3k44n7> How do humans talk?
23:06:44 <adarqui> ah.. ya something like that makes sense.
23:06:52 <julianleviston> arkeet: tho haskell is supposed to implement structural sharing with equivalent objects anyway, isn’t it? But maybe in the latter case it has to recognise they’re identical.
23:06:59 <julianleviston> unb3k44n7: with their talky boxes.
23:07:01 <arkeet> it is?
23:07:40 <unb3k44n7> Oh yeah. Those things. Right.
23:07:50 <unb3k44n7> THanks.
23:08:19 <nikki93> dibblego: anyways, any good resources to get more and more comfortable with thinking with functor/applicative/monad?
23:08:29 <unb3k44n7> Glad that is all cleared up.
23:08:31 <julianleviston> adarqui: I guess it’s a question of “is it simply style to not repeat yourself?” same answer, really...
23:08:47 <dibblego> nikki93: the NICTA/course will be run next in Sydney, in September  that's all I can think of
23:08:48 <nikki93> dibblego: I did cis194, now doing NICTA course, and thinking to do cs240h from stanford later
23:08:53 <arkeet> repeating xs 3 times is no better than repeating [] 3 times.
23:09:07 <arkeet> and conceptually it seems weird to me that splitting an empty list should result in two copies of the "same" empty list.
23:09:09 <julianleviston> arkeet: then there’s your answer. I happen to think it is better.
23:09:23 <julianleviston> arkeet: for intent, not for “saving typing”.
23:09:31 <arkeet> see my last statement.
23:09:44 <unb3k44n7> .....
23:10:04 <julianleviston> arkeet: I thought there was only one empty list.
23:10:10 <nikki93> arkeet: maybe it's also to prevent constructing multiple empty lists
23:10:14 <julianleviston> arkeet: ergo, you split it, you get two references to it.
23:10:20 <arkeet> nikki93: that was my first statement.
23:10:35 <nikki93> arkeet: but I think haskell might deduplicate the empty list underlying
23:10:35 <nikki93> arkeet: i.e., there being only one nil instance
23:10:43 <arkeet> that's what I'm unsure about.
23:11:34 <nikki93> arkeet: the thing is, since you can't "modify" stuff, it doesn't matter whether two variables refer underlying to the same or different memory instance if they are structurally identical
23:12:04 <nikki93> arkeet: what matters is the value
23:12:14 <nikki93> arkeet: it's like saying, you know, multiply 1 x = x
23:12:25 <nikki93> arkeet: you are returning "the same number," do you find issue with that?
23:13:00 <arkeet> anyway
23:13:07 <arkeet> the two produce the same core
23:13:10 <arkeet> so there's no difference
23:13:26 <arkeet> at all
23:13:41 <arkeet> whether I write span _ xs@[] = (xs,xs) or span _ [] = ([],[])
23:13:51 <julianleviston> arkeet: no difference in value, but there is in intent.
23:14:09 <julianleviston> arkeet: one is, nominally, lazier than the other… perhaps not in this case, though.
23:14:12 <arkeet> julianleviston: I'm saying that the intent makes less sense with the as-pattern.
23:14:29 <arkeet> one says "splitting the empty list results in two copies of the same list."
23:14:35 <arkeet> the other says "splitting the empty list results in two empty lists."
23:14:56 <arkeet> the second one makes more intuitive sense to me.
23:15:03 <julianleviston> arkeet: really? xs, xs isn’t two copies of the same thing.
23:15:10 <nikki93> I don't think it says "copies"
23:15:11 <arkeet> in what universe is it not?
23:15:16 <julianleviston> arkeet:  xs, xs is just passing it through, unevaluated, isn’t it?
23:15:23 <arkeet> it's already evaluated.
23:15:25 <nikki93> that's like saying x + x is adding two copies of x, no it isn't
23:15:26 <arkeet> upon pattern matching.
23:15:29 <julianleviston> arkeet: is it?
23:15:30 <julianleviston> ah ok.
23:15:36 <arkeet> I don't mean copy in the sense of copying data from one place to another.
23:15:37 <julianleviston> I wasn’t aware of that.
23:15:45 <arkeet> I should have said two instances
23:15:49 <arkeet> or something
23:16:52 <mauke> [] is already a "variable" bound to the single global empty list
23:17:09 <nikki93> think of it this way: if x is empty, then the left-split of x is x; if x is empty, then the right-split of x is x
23:17:39 <nikki93> x could be empty, but not equal to [] -- in general among sequential data structures
23:17:40 <nikki93> I know it's sorta crazy but..
23:18:16 <nikki93> it just happens to be that all empty lists are []
23:18:18 <arkeet> mauke: yeah I looked at core to see it's operationally the same either way.
23:18:24 <unb3k44n7> I hate IRC
23:18:26 <arkeet> nikki93: yeah I get what you mean.
23:18:28 <nikki93> and that the way to check if a list is empty is matching with []
23:18:45 <nikki93> the general pattern is
23:18:45 <nikki93> span _ x | isEmpty x = (x, x)
23:18:58 <nikki93> and in the list case that becomes what you see
23:19:38 <nikki93> arkeet: would that be a convincing argument? haha
23:20:03 <arkeet> I don't know what we're arguing for.
23:20:03 <arkeet> :p
23:20:23 <unb3k44n7> Is there any channel where the users aren't paranoid, discouraging a*******
23:20:30 <mauke> ok, now let's argue what color yellow is
23:21:21 <adarqui> so, after all of that.. great dialogue.. is f xs@[] = (xs, xs) bad stylistically? :F
23:21:28 <nikki93> arkeet: you said ([], []) makes more conceptual sense than (xs, xs), I was trying to get at why not
23:21:29 <adarqui> how bout that one
23:21:38 <arkeet> unb3k44n7: you can leave at any time if you are dissatisfied.
23:21:39 <nikki93> tbh I made up this argument after-the-fact
23:21:50 <unb3k44n7> So can you.
23:22:01 <Cale> unb3k44n7: Are you having some sort of problem with people in #haskell?
23:22:11 <wyager> I think he's just trolling
23:22:19 <nikki93> reminds me of the first chapter from Nietzsche's Beyond Good and Evil about how philosophers just have intuitions then retrofit arguments around them lol
23:22:20 <adarqui> (xs, xs) is prettier maybe but someone mentioned intent earlier.. but ([], []) gives youthe intent instantly
23:22:33 <unb3k44n7> No. I'm just "trolling."
23:22:37 <nikki93> adarqui: as I said, what if the intent is
23:22:40 <Cale> unb3k44n7: Did you have a question about Haskell?
23:23:06 <nikki93> adarqui: 'span' is a function on general sequential structures, and has the law that span _ x | isEmpty x = (x, x)
23:23:17 <wyager> nikki93: That's a perfectly reasonable approach. It's often useful to find functions that approximate built-in human heuristics. After all, that's the closest thing we have to an objective morality
23:23:33 <adarqui> nikki93: ah..
23:23:37 <unb3k44n7> No. But I suppose that's a mandatory requirement.
23:24:04 <julianleviston> unb3k44n7: nah, you can also have answers about haksell...
23:24:05 <nikki93> adarqui: which would also work in the case of a sequential structure where isEmpty x && isEmpty y doesn't mean x == y
23:24:10 <julianleviston> unb3k44n7: haskell even :)
23:24:21 <julianleviston> unb3k44n7: or you can just want to chat about haskell :)
23:24:54 <adarqui> cool thanks nikki93, makes sense
23:24:59 <arkeet> nikki93: I would argue that in structures where that makes sense, then splitting an empty thing may not result in two of the same empty thing.
23:25:01 <nikki93> wyager: ya but what I mean is like, you can't convince someone through logical argument then that something is better
23:25:08 <unb3k44n7> I gave up Haskell a month ago. I don't understand it. So no. I don't have any answers either.
23:25:14 <nikki93> wyager: seems I just did tho, nvm
23:25:26 <arkeet> but I haven't seen such a structure so I'm just making stuff up.
23:25:42 <julianleviston> unb3k44n7: why’d you give it up?
23:25:52 <wyager> julianleviston: This may be a lost cause
23:25:53 <AaronFriel> julianleviston, are you still here?
23:25:55 <nikki93> arkeet: yea this might get a bit into abstract weirdness but you see the idea I guess
23:26:00 <julianleviston> AaronFriel: I am! :)
23:26:16 <AaronFriel> julianleviston: I won't bother reading all the stuff above, did you figure out how to load the package you want into GHCI?
23:26:37 <unb3k44n7> It doesn't matter.
23:26:37 <julianleviston> I think you could easily have two things which are empty but different… if they’re wrapped in a different but similar computational context, for example
23:26:39 <arkeet> unb3k44n7: if you have nothing haskell-related to talk about, then please leave the channel clear for on topic discussion.
23:26:44 <nikki93> arkeet: maybe the structure has some other info stored like "a list, plus some id saying which country the list was manufactured in" or something
23:26:45 <julianleviston> unb3k44n7: it does to me.
23:26:58 <julianleviston> AaronFriel: no.
23:27:13 <AaronFriel> julianleviston: What package are you trying to play with? Maybe I can help?
23:27:16 <nikki93> arkeet: so that when you an empty list from Canada you get two empty lists from Canada, but when it's from France you get two from France 
23:27:22 <unb3k44n7> You can leave the channel since your message is off-topic as well. 
23:27:27 <unb3k44n7> That can be an option for you. 
23:27:36 <AaronFriel> An example of two "empty" things that are different:
23:27:36 <rcyr> What are you people waiting to take out the trash?
23:27:39 <AaronFriel> [[]] vs []
23:27:48 <julianleviston> AaronFriel: I sadly didn’t. I installed stack. Then I did stack new, stack install haskell-src-exts then stack setup then the install again, then stack ghci and it said it cannot satisfy -package new-template
23:27:59 <nikki93> AaronFriel: [[]] isn't empty tho...
23:28:01 <AaronFriel> oh weird
23:28:07 <AaronFriel> nikki93: For certain definitions of empty ;
23:28:08 <AaronFriel> ;)
23:28:10 <arkeet> > length [[]]
23:28:11 <lambdabot>  1
23:28:19 <nikki93> AaronFriel: if you mean 'empty' is in (== 0) . length
23:28:27 <AaronFriel> Well now you're being more specific
23:28:40 <nikki93> ya :D
23:28:49 <julianleviston> tho then they probably wouldn’t pattern match on [] very well
23:28:57 <AaronFriel> Well another trivial example is a data structure that uses hysteresis and/or mutability
23:28:57 <nikki93> but the point is in list empty is already defined as a property of the data structure
23:29:05 <AaronFriel> For example
23:29:07 <AaronFriel> a B-Tree
23:29:09 <nikki93> so when you start writing [... you've already told us what you mean by empty, no?
23:29:35 <AaronFriel> A B-tree that has been "emptied" is semantically equivalent to a B-Tree with an empty root
23:29:42 <AaronFriel> at least in terms of external interface
23:29:44 <nikki93> because haskell for example has the function contains, which intuitively would return false for an empty list, but contains [] [[]] is true
23:29:45 <julianleviston> AaronFriel: I’m trying to do a parse to AST…
23:29:56 <AaronFriel> julianleviston: Okay, let me see if I can replicate what you did
23:29:59 <nikki93> so that the definition of emptiness is established "by law"
23:30:02 <julianleviston> AaronFriel: so I was wanting to run ghci with the haskell-src-exts package.
23:30:04 <nikki93> in the case of [a]
23:30:41 <nikki93> arkeet: that was a good question though :)
23:30:58 <nikki93> arkeet: are you still learning haskell? what resources? I'm working through NICTA atm
23:31:09 <dibblego> nikki93: I wrote NICTA/course
23:31:47 <adarqui> thanks for the help every1, bbl
23:31:47 <adarqui> !
23:31:48 <nikki93> dibblego: dude... nice :D
23:31:49 <arkeet> nikki93: not really.
23:32:17 <nikki93> dibblego: conceptually so far I've understood that Applicative is still a little less flexible than Monad
23:32:25 <lpaste_> AaronFriel pasted “Haskell src exts” at http://lpaste.net/137243
23:32:29 <dibblego> nikki93: this is true, Applicative is a weaker constraint
23:32:32 <nikki93> dibblego: how does that extra flexibility allow findM which otherwise wouldn't work in Applicative?
23:32:36 <AaronFriel> julianleviston: Check out that paste
23:32:42 <dibblego> nikki93: I am working on an answer to this question
23:32:46 <AaronFriel> julianleviston: In it you can see me type wrong things and not know how to make GHCi work
23:32:53 <arkeet> conceptually in terms of "effects", Monad lets you have effects that depend on the results of other effects
23:32:59 <nikki93> dibblego: talking at a conceptual level rather than code level
23:33:09 <AaronFriel> julianleviston: But also you can see what I do is "stack install haskell-src-exts"
23:33:11 <arkeet> when just using Applicative, the "sequence of effects" is fixed.
23:33:12 <dibblego> nikki93: I am working on both
23:33:26 <AaronFriel> julianleviston: If you're just trying to play with a common package using Stack
23:33:36 <AaronFriel> julianleviston: It's probably 99% of the time safe to just do "stack install packagename"
23:33:46 <nikki93> dibblego: thanks :)
23:33:52 <julianleviston> AaronFriel: I’ve done that.
23:34:04 <AaronFriel> julianleviston: hm
23:34:19 <AaronFriel> julianleviston: What do you get when you run "which ghci"
23:34:19 <nikki93> arkeet: yeah but Applicative still has the effects depend on the results of other effects right? like in an applicative parser, if a previous effect reads more stuff then you have less stuff left in the next effect
23:34:31 <julianleviston> oh… so you can just use ghci without stack in front… ok..
23:34:36 <AaronFriel> I get 
23:34:43 <AaronFriel>  /home/developer/.stack/programs/x86_64-linux/ghc-7.8.4/bin/ghci
23:34:49 <AaronFriel> If you're getting the wrong ghci
23:34:53 <AaronFriel> you could run into problems
23:34:53 <julianleviston> AaronFriel: yeah, I get the stack one.
23:34:55 <AaronFriel> ok
23:35:07 <arkeet> nikki93: with just Applicative you can't write a parser where you decide what to parse next depending on the result of a previous parse.
23:35:19 <AaronFriel> "stack ghci" also works for me
23:35:22 <julianleviston> AaronFriel: but it doesn’t work. It doesn’t load the package
23:35:24 <AaronFriel> huh
23:35:25 <julianleviston> I’ll try reinstalling it
23:35:30 <AaronFriel> what do you get? Could you paste it into lpaste
23:36:04 <nikki93> arkeet: right... so what you mean is in a <*> b, a can decide what b gets, but b can't decide based on what "comes in"? sorta?
23:36:05 <julianleviston> AaronFriel: sure one sec
23:36:34 <arkeet> sorta
23:36:36 <julianleviston> AaronFriel: I appended mine to yours: http://lpaste.net/137243
23:37:04 <AaronFriel> oh yeah that's weird
23:37:21 <AaronFriel> So I would do what the sages used to tell me to do in the bad old days
23:37:30 <AaronFriel> uninstall stack, uninstall ghc, haskell-platform, err'thin
23:37:44 <AaronFriel> and make sure you delete your ~/.stack and ~/.ghc and etc folders
23:37:46 <AaronFriel> and start over
23:37:57 <julianleviston> AaronFriel: oh sorry I’m an idiot. Haha… so I just spelt the package name without an s as you did first up.
23:38:06 <mauke> :t readLn >>= \n -> if even n then getLine else (putStrLn "cool beans" >> return "skub")
23:38:07 <AaronFriel> oh
23:38:07 <lambdabot> IO String
23:38:10 <julianleviston> AaronFriel: works fine now :)
23:38:14 <julianleviston> AaronFriel: thanks!
23:38:17 <AaronFriel> or it's that
23:38:19 <AaronFriel> you know
23:38:23 <AaronFriel> I could just be giving you bad advice
23:38:44 <julianleviston> AaronFriel: oh no actually it didn’t work.
23:38:47 <AaronFriel> hahaha
23:38:51 <AaronFriel> okay maybe my advice isn't so bad
23:38:54 <julianleviston> AaronFriel: this really isn’t simple.
23:38:59 <nikki93> dibblego: I'm gonna go nap for a bit, but will you be around later? or you could pm me your explanation, I'll be online
23:39:02 <julianleviston> AaronFriel: :) funtimes.
23:39:13 <AaronFriel> julianleviston: What OS are you using?
23:39:13 <dibblego> nikki93: I am nearly finished, and no I will not
23:39:20 <julianleviston> AaronFriel: osx
23:39:32 <unb3k44n7> I don't even know anymore
23:39:48 <nikki93> dibblego: k I'll wait before I nap
23:40:23 --- mode: ChanServ set +o mauke
23:40:23 --- mode: mauke set +q *!*@74-47-200-245.dsl1.rhnl.wi.frontiernet.net
23:41:08 <dibblego> nikki93: https://gist.github.com/tonymorris/31478af4620443c8d4ba
23:42:23 --- mode: mauke set -o mauke
23:42:24 --- mode: ChanServ set +o mauke
23:42:49 <lpaste_> AaronFriel pasted “Setting up Rust and Haskell” at http://lpaste.net/5104060858787430400
23:42:55 <AaronFriel> lol
23:42:59 <AaronFriel> just as I click that it says down for maintenance
23:43:06 <AaronFriel> And it's up!
23:43:16 <AaronFriel> julianleviston: Okay, well apt-get won't be useful to you
23:43:18 <AaronFriel> julianleviston: BUT
23:43:36 <AaronFriel> julianleviston: That paste shows what I install in order to get Stack and Rust (Cargo) running on Linux
23:43:44 <julianleviston> AaronFriel: Yeah, it won’t. I don’t mind following multiple steps, I just want to understand what I’m doing.
23:43:44 <AaronFriel> julianleviston: So if you decide to develop on *nix
23:43:57 <AaronFriel> julianleviston: You might be better off on not OS X, for reasons of better support
23:44:43 <nikki93> dibblego: wow, thanks so much! will ponder this for a bit
23:44:45 <AaronFriel> julianleviston: It wouldn't surprise me actually if OS X had some fatal bug where Stack didn't work well ;_;
23:45:05 <julianleviston> AaronFriel: thanks for the… um… “help”. lol :)
23:45:40 <julianleviston> AaronFriel: nevermind, I’ll continue working on it when I’ve got time. 
23:45:44 <AaronFriel> julianleviston: Well I assumed you were on a Linux distro and my advice might have worked
23:45:46 <AaronFriel> ;_;
23:47:21 <nikki93> dibblego: so it's because in findM (x : xs) you have to choose whether you just return or look in xs based on the (effectful) p computation
23:47:34 <nikki93> dibblego: but in filtering, you always have to include the result in xs
23:48:20 <dibblego> nikki93: verbal language is too imprecise for me to be certain that you are understanding correctly, but  probably :)
23:48:32 <AaronFriel> julianleviston: Within a week or two I may have OS X running on my laptop
23:48:40 <AaronFriel> julianleviston: In that case, I may try to give you some help
23:48:51 <julianleviston> AaronFriel: how are you supposed to specify dependencies? Using install? or some other way
23:49:14 <nikki93> dibblego: yeah, I was worried about that
23:49:36 <AaronFriel> julianleviston: Stack uses Cabal files just like Cabal, so if you are in a project folder with a "project.cabal"
23:49:42 <AaronFriel> julianleviston: You specify your dependencies in there
23:49:50 <julianleviston> AaronFriel: I think that was what I was missing
23:49:58 <julianleviston> AaronFriel: did you do that when you loaded GHCI?
23:49:58 <dibblego> nikki93: simply, an effectful expression depends on the result of a previous effectful expression, ∴ Applicative is insufficient
23:50:06 <AshyIsMe> julianleviston: im also on osx and stack works quite nicely for me
23:50:28 <julianleviston> AshyIsMe: cool so how would I load ghci with a particular package installed?
23:50:31 <AaronFriel> julianleviston: Nope, I think you're hitting some other issue...
23:50:42 <AaronFriel> julianleviston: I didn't do anything special to install haskell-src-exts
23:50:58 <julianleviston> AaronFriel: how did you install it tho? It’s not installed by default
23:50:59 <nikki93> dibblego: yup, but... even in applicative an effectful expression depends on the result of previous, no? like in parsers, what the later thing parses depends on what previous one read
23:51:26 <nikki93> dibblego: so I guess the question is regarding the nature of this 'dependence'
23:51:27 <AaronFriel> julianleviston: Tell you what - would you want to do a screen share and see if I can help? 
23:51:34 <julianleviston> AaronFriel: no.
23:51:34 <AshyIsMe> julianleviston: you should be able to do "stack ghci" and then "import My.Package"
23:51:39 <AaronFriel> julianleviston: Okay, no worries
23:51:44 <julianleviston> AshyIsMe: thanks I’ll try.
23:52:07 <dibblego> nikki93: with Applicative, the effect itself cannot depend on the result of a previous effect. Put another way, it cannot be done with lift2 (or some variation), since liftN also cannot access those previous values.
23:52:08 <AshyIsMe> julianleviston: are you within a project source folder or you just want to mess around in the repl?
23:52:09 <julianleviston> AshyIsMe: if I do stack ghci, it says <command line>: cannot satisfy -package new-template
23:52:11 <AaronFriel> julianleviston: I'm pretty privacy-concerned myself and I'd never tell someone else "yes" to that, so don't feel as though you may have offended me.
23:52:27 <AaronFriel> julianleviston: Have you run "stack setup"?
23:52:33 <julianleviston> AaronFriel: yes.
23:52:37 <AaronFriel> julianleviston: Wait that was a stupid question, you said so earlier
23:52:39 <dibblego> nikki93: not all parsers exhibit this dependences property  therefore, they might choose to weaken to Applicative.
23:52:40 <AaronFriel> julianleviston: yop
23:53:01 <nikki93> dibblego: is the difference that in the parser case the "dependence" is simply implicit in the context of the applicative instance, whereas monads allow other kinds of dependences?
23:53:30 <julianleviston> oh… I had to say stack install?
23:53:30 <nikki93> dibblego: ah yeah looking at it with liftN helps
23:53:32 <AaronFriel> julianleviston: Wait- is the folder you're doing "stack ghci" in, one that you've done "stack init" in?
23:53:45 <julianleviston> guh… NOW I can load stack ghci. ok.
23:54:08 <AaronFriel> julianleviston: Hey I figured it out!
23:54:19 <AshyIsMe> julianleviston: as a test can you try this?  "mkdir tempHaskell; cd tempHaskll; stack new; stack ghci"?
23:54:30 <AaronFriel> julianleviston: You ran "stack new" in a folder and it did this right:
23:54:34 <dibblego> nikki93: suppose two values (Parser Int), we might use them to produce two Int values and (+) them. We could do this using the parser's Applicative. However, if we said one of the (Parser Int) values changes behaviour depending on the (Int) produced by the other one, we must use the Monad.
23:54:37 <julianleviston> AshyIsMe: Ok I’ll try that.
23:54:39 <AshyIsMe> that should initialize a new template project that you can start hacking on
23:55:07 <AshyIsMe> julianleviston: also, have a read of this when you get a chance: https://duplode.github.io/posts/casual-hacking-with-stack.html
23:55:10 <lpaste_> AaronFriel pasted “stack new” at http://lpaste.net/7367815851380047872
23:55:40 <AaronFriel> julianlevisto: I have figured out your problem!
23:55:46 <AaronFriel> julianleviston: rather
23:56:05 <julianleviston> AshyIsMe: ok I tried that. Same problem. 
23:56:07 <AaronFriel> julianleviston: You ran "stack ghci" in a folder in which you previously ran "stack new"
23:56:10 <julianleviston> AaronFriel: oh have you?
23:56:17 <AaronFriel> julianleviston: I duplicated it on my machine!
23:56:38 <julianleviston> AaronFriel: so why is that bad?
23:56:47 <lpaste_> AaronFriel revised “stack new”: “No title” at http://lpaste.net/7367815851380047872
23:57:01 <AaronFriel> okay, see that paste?
23:57:24 <AaronFriel> I'll explain what I did, and why it caused the problem
23:57:31 <AaronFriel> "stack new" creates a new project with a bunch of default settins
23:57:34 <AaronFriel> settings*
23:57:35 <julianleviston> yeah that’s hwat it does.
23:57:43 <AaronFriel> And so it creates a whole bunch of files, and sets you up to build a project
23:57:48 <mauke> oh, is "new-template" the default package name?
23:57:51 <AaronFriel> Yep!
23:57:54 <AaronFriel> When you run "stack ghci" in a folder that contains a project
23:57:55 <mauke> like untitled document
23:57:56 <julianleviston> yep
23:57:59 <nikki93> dibblego: I think I get it now
23:58:08 <AaronFriel> it tries to import your project into GHCi
23:58:10 <AaronFriel> BUT
23:58:14 <AaronFriel> you've never built your project!
23:58:27 <julianleviston> AaronFriel: yeah, I know… I built it before, and it worked.
23:58:29 <AaronFriel> so your project (new-template) doesn't exist as a package it can load
23:58:34 <julianleviston> AaronFriel: but I still couldn’t import it.
23:58:41 <julianleviston> AaronFriel: yeah, that’s what the error was saying.
23:58:46 <AaronFriel> Yep
23:58:47 <nikki93> dibblego: x <*> y is just "combine them" whereas with x >>= \a -> ... y ... you can say "combine them depending on this logic"
23:58:57 <AaronFriel> So here's where I'm going to make a distinction between two things
23:59:01 <AaronFriel> If you JUST want to play around in GHCI
23:59:06 <AaronFriel> don't use "stack"
23:59:21 <AaronFriel> and don't operate in a folder in which you've used stack or cabal
23:59:27 <julianleviston> AaronFriel: um… I want to know what’s going on.
23:59:30 <AaronFriel> Sure sure
23:59:38 <julianleviston> AaronFriel: which I think I already do.
23:59:50 <nikki93> dibblego: btw are we supposed to try to avoid 'do notation' in the NICTA solutions? cuz it hasn't been introduced so far in the course
23:59:55 <julianleviston> AaronFriel: but the thing I’m missing is why it’s not importing this package.
23:59:58 <AshyIsMe> weird thaht it worked for me though but i think stack is using 7.10 for me
