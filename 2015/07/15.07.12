00:01:06 <DosShashliks> woah big channel
00:03:36 * hackagebot operational-class 0.2.0.1 - MonadProgram typeclass for the operational package  http://hackage.haskell.org/package/operational-class-0.2.0.1 (srijs)
00:12:14 <adarqui> these operators in Data.Functor.Contravariant look like insects: >$< and >$$<
00:14:47 <alexa_> adarqui: bzzz bzzz
00:16:19 <adarqui> lul. sup
00:34:34 <adarqui> this type sig is wrecking me: contramap' :: (a -> b) -> f b -> f a
00:34:38 <adarqui> without the tick
00:39:08 <Cale> adarqui: What about it?
00:40:14 <hunteriam> Anyone know any I can find Haskell star
00:40:27 <hunteriam> Sry accidental send
00:40:32 <adarqui> dno, just confusing me.. (b -> a) -> f b -> f a makes sense .. which would be the normal functor/fmap type sig: fmap :: (a -> b) -> f a -> f b
00:40:39 <hunteriam> Anyone know any Haskell startups in NYC?
00:40:49 <hunteriam> Or possibly any looking for interns?
00:42:29 <Cale> adarqui: Consider something like  newtype Comparison a = C (a -> a -> Bool)
00:42:46 <Cale> adarqui: and think about how you might write a function (a -> b) -> Comparison b -> Comparison a
00:43:06 <adarqui> cool, trying
00:53:38 * hackagebot operational-class 0.2.0.2 - MonadProgram typeclass for the operational package  http://hackage.haskell.org/package/operational-class-0.2.0.2 (srijs)
00:56:31 <rowanblush> Is this function actually missing a pattern? https://gist.github.com/rowanblush/599bf42a778fc91a8c42
00:57:42 <rowanblush> I don't think so, but GHC is making me doubt my own sanity.
00:58:51 <verement> GHC probably can't be sure at least one of the guards will return True
00:58:53 <Deewiant> rowanblush: What if you have a type for which _ < _ = False; _ > _ = False; _ == _ = False
01:01:20 <adarqui> Cale,
01:01:20 <adarqui> newtype Cmp a = Cmp (a -> a -> Bool)
01:01:21 <adarqui> test :: (a -> b) -> Cmp b -> Cmp a
01:01:21 <adarqui> test f (Cmp cmpb) = Cmp (\b1 b2 -> cmpb (f b1) (f b2))
01:01:37 <Deewiant> rowanblush: What you can do is case analysis on the result of 'compare x y' which basically forces one of the three situations to be true
01:01:39 <rowanblush> Deewiant: Dang, you're right. I can't believe I've never stumbled into that pit before.
01:01:45 <adarqui> even though that's probably a bit nutty.. it did help a bit, i see how i'm transforming the b's in Cmp b to a's for Cmp a
01:01:52 <adarqui> does that make sense?
01:01:54 <Cale> adarqui: yep
01:02:30 <Cale> adarqui: The point is, the type parameter for a data type needn't be the type of a contained value or result of a computation, but it can also be the type of input to some computation
01:02:55 <adarqui> ya, glad you helped me work that out by myself :f
01:03:31 <adarqui> going to sleep, then get this contravariant code to work tmw.. definitely made progress
01:03:34 <adarqui> gn!
01:03:38 * hackagebot nationstates 0.1.0.2 - NationStates API client  http://hackage.haskell.org/package/nationstates-0.1.0.2 (ChrisWong)
01:03:45 <Deewiant> rowanblush: Note that a real-world value which would fail with your current implementation is a floating-point NaN. (Turns out the result of 'compare (0/0) (0/0)' is GT, though. Some feel that this points to a problem in the definition of Ord.)
01:08:32 <rowanblush> Deewiant: Good example. IIRC though isn't Data.Ord only for totally ordered datatypes?
01:09:02 <Deewiant> rowanblush: Yes, some feel that Floats and Doubles shouldn't have Ord instances. :-)
01:09:26 <rowanblush> I think I just spontaneously converted.
01:22:18 <Guest36275> hi there! I have some minor issues with this code for generating primes http://lpaste.net/136383
01:22:42 <Guest36275> i don't understand bracket abuse and redundant lamba...
01:22:59 <Guest36275> plus i have in issue benchmarking it with deepseq...
01:23:57 <wei2912> Guest36275: could you change your nick?
01:24:04 <Cale> Neither of those are a big deal. Function application binds tighter than any infix operator, so the brackets around mod x are not required.
01:24:13 <wei2912> ^^
01:24:36 <Cale> and whenever you have something like  f x = \y -> expr you can always rewrite that as f x y = expr instead
01:24:41 <Cale> it means the same thing
01:24:41 <wei2912> ^^
01:25:02 <Guest36275> ok, thanks Cale, i get it!
01:25:03 <wei2912> also i don't see any deepseq in that
01:25:21 <joco42_> \me thinks Scala is a gateway drug to Haskell
01:25:26 <Guest36275> well, i'd like to benchmark it listing some 1 million primes
01:25:35 * joco42_ thinks
01:25:45 <Guest36275> but when i compile it and 'time' it, nothing happens.
01:25:59 <Guest36275> thought it was laziness
01:26:04 <MarcelineVQ> is it perhaps just taking a long time to finish
01:26:14 <Cale> Guest36275: What exactly did you compile?
01:26:19 <Guest36275> so i forced the list but didn't change...
01:26:20 <Cale> There's no 'main' in that code
01:26:28 <Guest36275> ok here it is, just one sec
01:27:19 <Guest36275> http://lpaste.net/136383
01:29:40 <MarcelineVQ> I think you don't tell it to print anything
01:30:13 <Guest36275> seems that without doing something with the list, it won't be created anyway
01:30:29 <Guest36275> but if i print it, priting would spoil the benchmark
01:30:59 <MarcelineVQ> oh you're benchmarking
01:31:17 <Guest36275> just a simple time measurement with time
01:32:06 <Cale> Guest36275: Yeah, you're not going to evaluate anything there.
01:32:14 <Cale> The result of main is always ignored.
01:32:46 <Cale> You should use evaluate from Control.Exception
01:32:55 <Cale> :t Control.Exception.evaluate
01:32:57 <lambdabot> a -> IO a
01:33:07 <Cale> (kind of silly that it's in Control.Exception, but whatever)
01:33:26 <Guest36275> ok, i'll dig more into this
01:33:43 <Guest36275> this channel seems great!, thanks!!
01:33:44 <Cale> main = evaluate $ deepseq founded ()
01:34:07 <Guest36275> ok ok
01:34:13 <Guest36275> lemme do this...
01:38:28 <Guest36275> Ok then, thanks guys. Benchmarking was successful....even if awful...hehe more than 1 m for just a million primes...
01:39:24 <MarcelineVQ> if you're after prime speeds there's a pretty nice primes package in hackage
01:40:30 <Guest36275> sure it must be. Thanks. it's to see if i could code something little but working in the end. But i'll check the package you spotted
01:40:46 <Guest36275> thanks again guys!
01:41:39 <MarcelineVQ> @hackage primes
01:41:40 <lambdabot> http://hackage.haskell.org/package/primes
01:42:23 <Cale> Guest36275: primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)  is about twice as fast
01:43:05 <Cale> and yeah, these aren't really good algorithms
01:43:17 <MarcelineVQ> cale using fancy multiples checking up to the square of the number
01:43:57 <MarcelineVQ> math wizardry
01:44:24 <Guest36275> well, this is really interesting! thanks for improving it, making it one-liner also!!
01:50:23 <Guest36275> a question:  do you think that takeWhile results are cached by the runtime?
01:50:57 <Guest36275> supposing that calling takeWhile a second time produces a result that is a superset of the previous
01:52:51 <Cale> Guest36275: primes is effectively "cached" because it remains in scope the whole time
01:53:14 <Cale> (and is a single variable)
01:53:53 <Cale> The results of function applications are not memoised, but any given variable will be computed at most once as long as it remains in scope
01:54:09 <Guest36275> i thought that successive calls to takeWhile were a pity, because everytime it builds a slighlty bigger list out of primes, which is made up of the previous calculation plus some items
02:01:06 <solatis> hmmm, a high level design issue on a background task processor
02:01:18 <tomjaguarpaw> latk: "Is it possible to use an Aggregator in opaleye to have a query return [SomeCol] ?" -- Do you mean a list of columns?  If so, yes, the latest version on Github supports this.  Can you tell me more about exactly what you want to do?  I can try to help you out.
02:01:19 <solatis> my tasks need access to a database connection pool
02:02:05 <solatis> would it be better to submit a task to the task processor, and have this connection pool be part of the task, or have the background task processor 'know' about the connectionpool itself ?
02:02:19 <solatis> maybe i'm phrasing my question a bit wrong, i think the high level issue is this:
02:02:42 <solatis> is it better to submit a *function* onto the background task processor, or *data* ?
02:03:18 <solatis> my intuition tells me it is best to just have the task processor accept something that returns IO a, and make it completely unaware of how this task is processed in practice
02:11:28 <latk> tomjaguarpaw: I have a table A that has a FK relationship to table B. This relationship is not always present, but could also occur multiple times. I want to construct a query that returns B with null for the A value if there is no relationship, or returns a list of B with the A value. I looked a bit more, and it seemed like I might be able to do this with a left join, but I didn't see how to convert my table A to nullable. 
02:11:35 <latk> Sorry, this is probably a terrible explanation!
02:12:56 <tomjaguarpaw> latk: OK, that sounds different from what I was anticipating.
02:13:03 <tomjaguarpaw> It sounds like left join is the correct thing.
02:13:17 <latk> tomjaguarpaw: I was flailing wildly between several solutions, stemming from my ignorance :)
02:15:13 <Yuken> Hi!
02:15:31 <tomjaguarpaw> latk: I would guess you want a left join with A as the first argument and B as the second.  Let me know if you need help getting the types sorted out.
02:16:06 <Yuken> What is Haskell good for?
02:16:20 <solatis> Yuken: many things! what exactly are you looking for?
02:16:31 <latk> tomjaguarpaw: Will do. Thanks for making the library, when I realised how you could compose queries like you can it blew my mind!
02:16:44 <tomjaguarpaw> :-)
02:16:59 <Yuken> Well, just learning a new language. AllI know is BY*ND, which isn't... the most efficient language.
02:17:47 <Yuken> Er, BYOND actually.
02:17:58 <solatis> tomjaguarpaw: didn't hear about opaleye before, looks like you did a pretty nifty job there!
02:18:55 <solatis> Yuken: if you are looking for a language with high expressiveness, decent performance, and a headache for several weeks, you might give Haskell a shot :)
02:19:33 <Yuken> What can it be used for, is my main question.
02:20:26 <solatis> Yuken: well pretty much everything. there are big banks using it internally, but there also are many web frameworks, etc
02:20:42 <solatis> for what it's worth, I'm currently building a bitcoin anonymization application in Haskell
02:20:49 <solatis> so you can build 'actual stuff'
02:21:28 <solatis> if you are looking for a language with big mainstream adoption, Haskell might not be the best choice though
02:21:31 <hsk3> Why does the state monad have   s -> (a,s) ?   Why the a? Why not bundle a into s itself?
02:21:53 <tomjaguarpaw> solatis: I obviously haven't been promoting it loudly enough then!
02:22:09 <solatis> tomjaguarpaw: or i haven't been paying attention :)
02:22:24 <Yuken> solatis, on a scale of Python to Assembly, how hard is Haskell to learn?
02:22:28 <tomjaguarpaw> solatis: What do you pay attention to, new-release-wise?
02:22:36 <Yuken> solatis, wait... BASIC to Assembly.
02:22:38 <solatis> Yuken: both are easier to learn than Haskell, I would say :)
02:22:56 <solatis> it completely depends
02:23:16 <solatis> a language like ASM is easy to learn, but hard to master
02:23:28 <solatis> i would say haskell is hard to learn, even harder to master
02:23:48 <solatis> but, once you *know* haskell, your productivity is a lot higher than in ASM
02:23:54 <solatis> so it's not an apples/apples comparison
02:24:16 <solatis> why don't you tell me what your goals are, and i can give you a good suggestion for a language to learn ?
02:24:36 <solatis> do you wish to make yourself more likely to land a job in a big corporation ?
02:25:03 <Yuken> solatis, just learning everything I can. Young 8th grade hobbyist, not getting a job anytime soon.
02:25:12 <solatis> right
02:25:35 <solatis> well, i can definitely say that Haskell will teach you to think about programs, and flow of data, differently
02:25:55 <solatis> my Haskell knowledge has changed the style I use in my C++ code a lot
02:26:15 <solatis> so i would definitely recommend studying it for a few weeks
02:26:40 <solatis> if only to learn about concepts like partial function application, function composition, etc
02:27:14 <solatis> but, be prepared, it will take you anywhere between 2 and 200 weeks to get productive in Haskell
02:27:55 <Yuken> solatis, I will try. My current... rig... is very old. A 1.5GHz mobile C2D, 2GB of DDR2, and an iGPU so bad it is beaten by a 1995 card, the RAGE Fury MaXX
02:28:20 <solatis> that doesn't matter that much
02:28:23 <solatis> what OS are you running ?
02:28:40 <Yuken> Sadly, windows 7. Would rather use XP or Linux
02:28:46 <solatis> i'm using 2GB DDR2 on my laptop too, windows 8.1
02:29:21 <solatis> anyway, i would say, downloads minghc https://github.com/fpco/minghc 
02:29:27 <solatis> install it
02:29:37 <solatis> and try to get your first haskell application up and running!
02:30:13 <solatis> (minghc is a very easy to use toolkit to get started with Haskell under Windows)
02:30:47 <stegman_> would you all agree that haskell has one of the coolest names and logos out of any programming language (if not THE coolest)?
02:31:18 <solatis> stegman_: i think you have selection bias in your poll
02:31:50 <stegman_> solatis: meh, i've yet to find any language with cooler name, logo/name-logo combo than haskell
02:32:13 <stegman_> haskell just sounds so... artsy; so... professional, imo
02:33:12 <solatis> you do know that it is named after Haskell Curry? https://en.wikipedia.org/wiki/Haskell_Curry
02:33:28 <solatis> in other words: you can name your son Haskell
02:33:51 <kgnotte> he's a cool dude wrote a lot of good books on logic
02:34:09 <solatis> also, currying
02:34:16 <solatis> (yes, i know that is also logic)
02:34:49 <dramforever> solatis: don't do it =P I've seen a few packages/functions that I don't like because I know someone/something else also called that name
02:34:51 <kgnotte> yeah he has one of the cleanest expositions on godel numbering I have seen
02:34:55 <dramforever> example:
02:35:01 <dramforever> :t forever -- =P
02:35:02 <lambdabot> Monad m => m a -> m b
02:36:13 <stegman_> does haskell have a future? i feel like it's just a niche now and won't be relevant like c in, say, 15-20 yrs.
02:36:14 <solatis> dramforever: yeah why do all these people insist naming their languages after my exes.. i would never touch Julia lang with a mile foot pole!
02:36:17 <stegman_> scary i know.
02:36:49 <solatis> stegman_: it succeeded pretty well in its original goals, which is creating an environment where (language) developers can try out new techniques
02:37:04 <solatis> which is why haskell embraces the language extensions so much
02:37:26 <solatis> if anything, haskell community is growing
02:37:36 <dramforever> solatis: well I guess you know our motto =P
02:40:08 <stegman_> solatis: will it ever reach python/ruby status? the haskell community has a lot to do in regards to catching haskell up to speed.
02:40:41 <solatis> well 20 years ago it would be almost unthinkable the entire world would be using OOP
02:40:44 <solatis> yet here we are
02:40:57 <solatis> maybe in 20 years people find out that FP is the new hot thing ?
02:41:12 <solatis> you can already see it happening, a lot more people are using functional programming now than, say, 5 years ago
02:46:16 <stegman_> what are the advantages of learning haskell as a first language? i heard on reddit that some schools in europe teach it as a first to students.
02:48:06 <solatis> stegman_: unbiased, lots of people that know how to write code imperatively think FP is weird and too difficult
02:48:30 <solatis> for example, compare writing loops in PHP with writing loops in Haskell
02:48:32 <solatis> major difference
02:48:57 <Maxdamantus> Haskell is still pretty much the only popular language with a decent type system, for some reason.
02:49:10 <solatis> c++'s type system is pretty decent too, imho
02:49:17 <dramforever> so to me the answer is: haskell is different
02:49:21 <Maxdamantus> (doesn't have much to do with FP)
02:49:30 <dramforever> solatis: I agree
02:49:47 <Maxdamantus> C++ avoids type systems with generics.
02:49:51 <edk> the major problem with c++'s type system is that it isn't one
02:50:05 <Maxdamantus> yes, and it's a horrible alternative.
02:50:17 <solatis> i wasn't saying it's perfect, but compared to other languages, it is pretty decent
02:50:25 <solatis> obviously haskell is better
02:50:54 <solatis> but it is better than, say, Java's type system
02:51:06 <Maxdamantus> I prefer Java's.
02:51:11 <stegman_> so haskell probably would have been a lot easier to learn if i was a complete beginner then :/
02:51:27 <dibblego> stegman_: yes
02:51:43 <solatis> yeah, most likely
02:52:03 <Maxdamantus> since Java still actually uses a type system, you can consider the types as denoting what is statically valid.
02:52:33 <solatis> Maxdamantus: isn't that also the case with c++ ?
02:52:52 <solatis> you can make a lot of type checks in c++
02:53:05 <stegman_> java is pretty lackluster, just saiyan.
02:53:15 <Maxdamantus> in C++, you might be able to express foo<int> but not foo<double>, but the distinction might not be made clear by any type signatures.
02:54:10 <solatis> Maxdamantus: yes, usability is the major pain point in c++'s type system -- the usability sucks
02:54:27 <solatis> that doesn't make the guarantees it provides any less valuable
02:54:36 <solatis> and you would probably just get a linker error with foo<double>
02:54:52 <solatis> or 10 screendumps full of g++ errors
02:54:52 <Maxdamantus> It can be a compilation error.
02:55:15 <solatis> yeah i know, decyphering c++ compile errors is a special form of art
02:55:36 <Maxdamantus> because it doesn't restrict things using a type system.
02:55:45 <solatis> yes, yes it does
02:56:18 <solatis> http://www.boost.org/doc/libs/1_57_0/libs/concept_check/concept_check.htm
02:56:21 <solatis> take a look at that
02:56:38 <Maxdamantus> if the error is in the middle of someone else's code, that's because generics aren't part of the type system.
02:56:54 <dramforever> Actually I saw one guy's blog post that said haskell's class/instance system is useless, because it doesn't do anything more than simple overloading
02:57:03 <dramforever> interestingly, he is right =P
02:57:31 <solatis> LISP is pretty simple too, that doesn't make it useless
02:57:52 <solatis> just because the implementation is simple, doesn't make it useless -- it is the way it is applied that is powerful
02:57:54 <edk> solatis, it's not about simplicity. simplicity is a good thing
02:57:56 <dramforever> solatis: well the "doesn't do anything more" part can't be more right
02:58:02 <dibblego> it's false
02:58:10 <dramforever> if you think about it
02:58:11 <dibblego> and it has been debunked, repeatedly
02:58:13 <edk> but C++ typing is not simple and also doesn't do very much
02:58:20 <dibblego> yesterday was the most recent debunking 
02:58:28 <dramforever> well...hmm the "useless" is wrong
02:58:39 <solatis> "limited" would be a better description
02:58:43 * hackagebot honk 1.3.0.0 - Cross-platform interface to the PC speaker.  http://hackage.haskell.org/package/honk-1.3.0.0 (ChrisWong)
02:58:55 <dramforever> solatis: yes
02:59:09 <solatis> but, without hyperbole, you cannot get traction on your blog post
02:59:39 <edk> typeclasses and instances aren't "nothing more than simple overloading", they're overloading done right
02:59:52 <edk> (by being part of the type system)
03:00:10 <dramforever> edk: IIUC "it doesn't do anything more" is right, because there's more checking
03:02:06 <Maxdamantus> solatis: generics have about as much to do with a type system as C preprocessor macros do.
03:02:19 <edk> dramforever, well, the big difference is that typeclasses can be used as type constraints
03:03:04 <Maxdamantus> solatis: if you pass in an invalid argument, you might get a type error, but that's because you expanded a macro incorrectly.
03:04:06 <Maxdamantus> solatis: the same thing happens with generics; an argument can be considered invalid if it doesn't substitute into someone else's code.
03:05:28 <Maxdamantus> with a type system, that's not the case. you get something that signifies what you can pass in, and it's not the code itself (and its context)
03:05:31 <solatis> Maxdamantus: not really, since you can partially implement a generic
03:05:50 <edk> dramforever, if you wanted to express "has an overload for X" in a language without them, you'd be kind of screwed. in C++ you could ignore the issue by using a template, which might work but which wouldn't express the constraint in your type signature
03:06:14 <dramforever> edk: yes, that's why templates do more than instances =P
03:06:19 <solatis> you can easily use a generic like 'ForwardTraversable' so you know for sure that it is an iterator you can i++
03:06:23 <dramforever> well, *no less
03:06:39 <edk> no, they don't expose this information to the type system
03:07:00 <dramforever> but they allows more...usage
03:07:24 <edk> they also aren't present in a majority of languages that feature overloading, which is what i thought we were talking about - i only mentioned them incidentally
03:07:24 <solatis> well, let's hope they get concepts right in c++18
03:07:35 * dramforever is kinda playing devil's advocate
03:08:40 <Maxdamantus> add :: forall a. typeof (@a + @a); add a b = a + b
03:08:57 <Maxdamantus> that's the sort of guarantee you have with generics.
03:09:10 <edk> typeclasses also allow you to require a complete system of overloads
03:09:38 <dramforever> yes I know
03:10:36 <edk> generally i think overloads really don't do any more than typeclasses, and templates do but only in the sense that they allow you to make more kinds of error
03:10:54 <dramforever> yes that's what that guy is doing
03:11:40 <edk> well, i can't imagine being allowed to make more kinds of error is an advantage...
03:12:19 <solatis> edk: people in c++ land value their freedom to make mistakes
03:12:26 <solatis> edk: it's a kind of job protection
03:12:38 <solatis> c++ is very, very expert-friendly
03:13:04 <solatis> so the more ways to shoot yourself in the foot, means more ways c++ experts can distinguish themselves from juniors
03:13:17 <solatis> (or am i thinking too much into it?)
03:13:19 <dramforever> to me the big thing about haskell's type system is not expressiveness, not more power, not static guarantees
03:13:31 <dramforever> the big thing is it's *different*
03:14:15 <solatis> haskell feels like c++'s template meta programming as the first level of abstraction
03:15:22 <dramforever> Just for reference, I'm talking about this guy's post: http://www.yinwang.org/ , but his posts are in Chinese so I wouldn't expect most of you to read them
03:15:24 <Maxdamantus> That's probably because you're thinking of C++ templates as the intuitive class system in Haskell, which it's not.
03:16:01 <solatis> Maxdamantus: yeah, it did allow me to catch up on a lot of things in Haskell fairly quickly
03:16:13 <dramforever> Actually I don't really think it's fair to compare haskell to other "conventional" languages
03:17:50 <edk> i think it's reasonable. you can solve a lot of problems with either haskell or another language
03:18:01 <dramforever> you say this foo part of haskell is no better than the bar in that other language, but foo neither designed to be resemble bar nor to supersede it
03:18:26 <dramforever> edk: well it took a while for me to figure out this ^
03:18:50 <dramforever> I mean that kinds of comparsions
03:23:54 <toad__> I've got a small question concerning foldl and foldr
03:24:12 <toad__> does foldl go through the list beginng from the left and foldr beginng from the right or is ith the other way around?
03:24:25 <toad__> I've seen conflicting definitions of these two functions and I'm confused...
03:25:10 <dramforever> it's hard to say...does the source code make sense to you?
03:25:20 <solatis> toad__: i think this is what you're looking for https://wiki.haskell.org/Foldr_Foldl_Foldl'
03:25:37 <dramforever> wow =)
03:26:30 <toad__> I've been on that site already and still didn't get what they were trying to say
03:26:39 <toad__> so could you just say if my interpreation is correct or not?
03:26:42 <dramforever> toad__: well I agree =)
03:26:58 <dramforever> toad__: it's very hard to say, because haskell is non-strict (a.k.a lazy)
03:27:57 <solatis> toad__: foldr f z (x:xs) = x `f` foldr f z xs
03:28:01 <solatis> what does that tell you ?
03:29:28 <toad__> I have no idea...
03:31:11 <solatis> try to understand the way that makes the list being evaluated
03:32:33 <solatis> as you can (maybe) see, it first enters recursion until the last element is reached, then goes back up to the stack to apply reduce all items
03:33:07 <solatis> in the case of [1,2,3], it is applied as 1 `f` (2 `f` 3)
03:33:20 <solatis> as such, it means that the list is traversed from right to left
03:33:56 <solatis> (yes i know, i'm forgetting about z, but that's beyond the scope here)
03:34:04 <ronh> not really.. if f doesn't evaluate the second argument recursion will never happen
03:34:04 <programo> hi , from REPL I am unable to do a function type declaration addThree :: Int -> Int -> Int -> Int, but I can do the same when I save the function in a file as a .hs script.
03:34:33 <programo> Is there any way to declare a function type from REPL ?
03:34:44 <solatis> ronh: yeah i know, laziness... but he was simply asking whether foldl and foldr represent left-to-right and right-to-left respectively
03:34:59 <ronh> and if f is lazy in the second argument recursion will be delayed until those values need to be evaluated
03:35:00 <solatis> that question in itself is an oversimplification of what is going on
03:35:16 <solatis> but i think he's just looking for a simple answer..
03:36:52 <dramforever> programo: let addThree :: ... ; addThree ... = ...
03:37:41 <dramforever> programo: well what version of ghc are you using? ghci should have printed it
03:37:58 <programo> I am using ghci
03:38:24 <dramforever> well?
03:38:40 <gmanny> how does one deploy yesod website? do you need a dedicated web server?
03:40:08 <dramforever> programo: let addThree :: ... ; addThree ... = ... should work
03:40:41 <Haskellfant> gmanny: depends on what you mean by dedicated webserver. it won't run on a webspace where you can only upload html & php via ftp
03:42:06 <lpaste> programo pasted “Funtion Type declaration ” at http://lpaste.net/136392
03:42:13 <Flonk> What was the command to ask lambdabot for the source of a function again?
03:42:31 <Haskellfant> @src map
03:42:31 <lambdabot> map _ []     = []
03:42:31 <lambdabot> map f (x:xs) = f x : map f xs
03:42:41 <Flonk> duh
03:42:44 <Flonk> Haskellfant: Thank you, haha
03:42:49 <gmanny> Haskellfant: do I need to have permission to run arbitrary executables?
03:43:35 <Haskellfant> yep
03:43:50 <programo> dramforever,  I had tried as you had told , but I still got errors http://lpaste.net/136392
03:44:01 <gmanny> are webservers like that expensive?
03:44:01 <Haskellfant> Flonk: np :)
03:44:42 <dramforever> programo: your code is incorrect
03:44:48 <dramforever> hint: haskell is case sensitive
03:44:52 <Haskellfant> gmanny: not really. some webspaces give you ssh access and allow you to run executables and cost something between 1-5€. vservers tend to be in the range from 5€-10€ per month
03:45:59 <gmanny> I need something a bit more reliable, so $5-10 is what the cost will be?
03:46:20 <gmanny> hmm, wont executable only run for as long as ssh session is live?
03:46:36 <Haskellfant> no?
03:47:47 <programo> Yeah got it , it was a silly mistake Thank you dramforever 
03:49:52 <dramforever> gmanny: well something like PaaS will do
03:49:57 <dramforever> like heroku
03:50:28 * dramforever didn't mean to do advertisement...sorry
03:58:07 <rowanblush> gmanny: I have a pretty easy to follow example on my GitHub of deploying a Haskell app on AWS using NixOS, if you've never used AWS before you will probably be able to get a year's worth of free tier credit.
03:58:34 <rowanblush> http://github.com/rowanblush/saluton-hs-nix
04:00:22 <rowanblush> I host and deploy my personal site and web app with that workflow.
04:09:08 <gmanny> rowanblush: cool Ill check it out
04:18:04 <gmanny> what are haskell's main advantages over python?
04:18:47 * hackagebot ether 0.3.0.0 - Monad transformers and classes  http://hackage.haskell.org/package/ether-0.3.0.0 (int_index)
04:18:49 * hackagebot data-flagset 1.0.0.0 - An efficient data type for sets of flags  http://hackage.haskell.org/package/data-flagset-1.0.0.0 (TobiasBrandt)
04:19:47 <maerwald> gmanny: it's a functional language?
04:20:12 <pacak> gmanny: It's harder to shoot yourself in the foot in Haskell.
04:20:36 <maerwald> pacak: because you can't make the gun work in the first place :P
04:20:51 <pacak> maerwald: You can if you know what a monad is...
04:20:58 <maerwald> err
04:21:16 <mauke> gmanny: haskell has local variables
04:21:32 <pacak> mauke: There are no variables in haskell. Only constants.
04:21:51 <mauke> then what is x in (\x -> 2 * x + 1)?
04:21:55 <pantsman-> I'd say the advanced type system is the main advantage for me.
04:22:11 <pacak> A constant that will be assigned some value you'll pass later.
04:22:15 <maerwald> pacak: see https://wiki.haskell.org/Variable
04:22:19 <mauke> also known as a "variable"
04:22:21 <pacak> But once it's assigned - it's that value.
04:22:31 <peterson> pacak: 'binding' perhaps?
04:23:19 <pacak> "a given variable's value never varies during a program's runtime"
04:23:26 <pacak> peterson: Binding fits, yes.
04:23:33 <maerwald> and you can have mutable variables in haskell, it's just not the "default"
04:30:44 <gmanny> how can you have mutable variabes in haskell?
04:30:52 <gmanny> variables
04:31:25 <maerwald> gmanny: I don't want to answer that question :P because if you do that in the beginning, it's most certainly the wrong way
04:31:45 <maerwald> but there are use cases where that's a valid solution
04:31:57 <maerwald> check https://wiki.haskell.org/Mutable_variable for an example
04:32:15 <dramforever> maerwald: you mean it's an XY Problem ( http://xyproblem.info ) ?
04:32:36 * dramforever is pretty fond of the concept "XY Problem" =P
04:33:10 <maerwald> dramforever: well I mean... you could start with unsafePerformIO when you teach people haskell for the first time, but that's probably not a good idea =D
04:33:45 <maerwald> some tools should stay hidden from beginners, but I just wanted to throw that in for completeness
04:34:23 <dramforever> maerwald: "so you could solve the real problem without mutable vars, but you ask us about mutable vars so we have nothing so answer", right?
04:34:30 <dramforever> *could probably
04:35:58 <gmanny> I am not actually solving any problems. was just wondering what haskell brings to table over python
04:36:35 <gmanny> but it got me curious because I have heard that variables are immutable in haskell
04:37:31 <dramforever> gmanny: yes
04:37:35 <maerwald> gmanny: well yeah, they are, but there are always special ways you can "circumvent" these base rules, either in a safe or unsafe manner
04:38:25 <dramforever> maerwald: I don't know this well, but I don't think you can mutate variables. IIUC you can only mutate where references point to
04:38:43 <dibblego> crikey
04:39:32 <dramforever> gmanny: IIUC the idiomatic haskell way of changing some data is return the new data
04:43:07 <quchen> IORefs are mutable variables.
04:43:17 <quchen> MVars too, and TVars.
04:43:27 <dramforever> quchen: to me they are references, as it's name suggests
04:44:03 <quchen> Well, as a reference they're immutable, but what they're referring to is mutable. So in practice it's pretty much the same as a mutable variable.
04:44:28 <maerwald> it matters how you use them IMO not the implementation details
04:44:30 <dramforever> yeah I agree that
04:44:58 <dramforever> but it isn't quite like mutable variables in other languages
04:45:11 <dibblego> ummm, this is a bit out of control
04:46:09 <quchen> IORefs have a read operation and a write operation that changes its contents. That sounds very mutable to me.
04:46:37 <dramforever> quchen: well never mind, the name is not *that* important
04:46:41 <maerwald> quchen: and mutable variables are very useful for impure bindings like Gtk which are not very "haskell" anyway
04:47:01 <maerwald> it's a pain to work with those bindings anyway
04:49:26 <maerwald> I wonder if we confused gmanny now :/
04:50:42 <dramforever> gmanny: how are you now? we sort of...got out of control
04:50:44 <dramforever> sorry
04:51:26 <bernalex> dibblego: thank you for recognising it. sheesh.
04:52:06 <gmanny> haha, no it is fine. I like how lively this channel is
04:52:37 <dramforever> gmanny: I doubt if *that's* why people call #haskell friendly
04:52:46 <dramforever> =P
04:53:00 <maerwald> gmanny: https://www.youtube.com/watch?v=iSmkqocn0oQ this somewhat explains the difference between haskell and python :P
04:54:55 <LnL> is there some way to reload ghci when a file changes?
04:55:44 <dibblego> LnL: :r
04:56:29 <LnL> dibblego: I mean that ghci runs :r automatically when a file change is detected
04:56:29 <bernalex> I think they mean automatically
04:57:10 <LnL> something like halive, but with a plain ghci repl
05:02:00 <zipper> How can I do something like this in my cabal file: `if not os(windows)` 
05:03:50 <bernalex> can you? I would have guessed you needed CPP in Setup.hs or summat. I'm not sure. :)
05:04:00 <maerwald> zipper: did you try "if !os(windows)"?
05:04:03 <LnL> zipper: if !os(windows)
05:07:21 <LnL> I can pipe ":r" into ghci, but then the repl does not work anymore
05:08:30 <benzrf> does :r reset local bindings
05:08:45 <benzrf> in particular, does it keep anything that just restartig ghci would destroy
05:08:57 <maerwald> LnL: do you happen to use vim? Cause I just found this https://stackoverflow.com/questions/7705717/automatically-reloading-ghci-running-hlint-on-file-updates with some suggestion to use BufWrite
05:10:25 <LnL> well that's a hack, I could do something like that with tmux
05:11:21 <LnL> I'm wondering if it would be hard to build something that uses the ghc api, like halive does
05:24:09 <chreekat> Thinking of getting into some html parsing. Any lib recommendations?
05:30:01 <gmanny> just one more question before I dive into learn you a haskell.. how good is haskell at utilizing multiple cores/cpus?
05:30:55 <maerwald> gmanny: pretty good, because of purity and controlled effects
05:31:28 <maerwald> in impure languages it is a mess, because you need to make sure that nothing blows up because of shared variables and whatnot
05:31:56 <maerwald> and even then you might just hit a random invalid memory state
05:37:32 <Flonk> gmanny: In a lot of cases you can just replace `map` with `parMap` and you're done
05:37:41 <Flonk> Because of what maerwald said
05:37:49 <Darwin226> Hey guys, here's an interesting one. How do I compute a cartesian product of a list with itself ([a] -> [(a, a)]) such that no element is paired with itself. I want to avoid doing actual comparisons (possibly not require Eq at all) and hopefully keep it n^2
05:37:55 <benzrf> gmanny: hey
05:38:02 <benzrf> gmanny: dont use learn you a haskell, it has some problems
05:38:34 <benzrf> gmanny: i mean, you can use it if you want, but there are better options
05:38:36 <Darwin226> benzrf: What problems?
05:39:04 <benzrf> well, lyah is OK at serving as a kind of reference, but it's not all that great at making the really new concepts intuitive
05:39:28 <hpc> i always thought it was the other way around
05:39:28 <Flonk> > map (\(x:xs) -> map (x,) xs) . tails $ [1,2,3,4]
05:39:29 <lambdabot>  [[(1,2),(1,3),(1,4)],[(2,3),(2,4)],[(3,4)],[],*Exception: <interactive>:3:6-...
05:39:34 <Flonk> hmm
05:39:37 <benzrf> hpc: well, not really a /referene/
05:39:37 <hpc> RWH was the reference, LYAH was the walk you through concept by concept
05:39:41 <benzrf> up to some point it's fine for the basics if you already know about recursion and so on, but
05:40:02 <benzrf> maybe not so much intuition as, like, how to think
05:40:09 <Flonk> Darwin226: something along these lines :P
05:40:10 <Fuuzetsu> LYAH is fine
05:40:27 <benzrf> lyah sort of explains things in a way that makes sense in the moment, but it's not great for learning the ability to actually work with the concepts it tries to teach
05:40:35 <hpc> well yeah, nothing's going to force you to figure out recursion other than you looking at examples and torturing your brain for a while
05:40:35 <benzrf> one big problem there is that it has no exercises
05:40:42 <maerwald> I started with the cis course, but you really have to read the lectures more than once
05:40:49 <benzrf> that's true yeah
05:40:57 <benzrf> CIS194 has pretty great exercises though :)
05:41:14 <benzrf> better than lyah's nonexistent ones, at least :}
05:41:42 <benzrf> you could use lyah and cis194 supplementarily but i wouldnt go a path without exercises
05:41:47 <benzrf> heres some good resources https://github.com/bitemyapp/learnhaskell
05:42:00 <marchelzo_> benzrf: What do you think of the NICTA course exercises?
05:42:13 <hpc> you can sort of get by if you have one big project you want to do
05:42:22 <benzrf> well, honestly i'm kind of just parrotting what bitemyapp has said
05:42:26 <benzrf> he's written up a whole blog post on it
05:42:31 <benzrf> er, on various resources
05:42:32 <Phillemann> Is there an XML lens library available in stackage?
05:42:35 <benzrf> i think it might be linked from that repo
05:42:36 <hpc> but then part of the work is figuring out without any other prior work, which abstraction applies
05:42:54 <benzrf> marchelzo_: NICTA is pretty good but it's not necessarily appropriate for someone who's just starting out
05:43:16 <Darwin226> Flonk: Hey yeah, that's actually pretty good. I don't even need both (x,y) and (y, x)
05:43:19 <Darwin226> Flonk: thanks
05:47:27 <lamefun> is there a built-in function to check if a list is at least a certain length?
05:47:29 <Phillemann> Oh, xml-lens is in stackage. Great. :)
05:51:29 <silver> > lenght [1,2,3] >= 2
05:51:30 <lambdabot>      Not in scope: ‘lenght’
05:51:30 <lambdabot>      Perhaps you meant one of these:
05:51:30 <lambdabot>        ‘length’ (imported from Data.List),
05:51:39 <silver> > length [1,2,3] >= 2
05:51:41 <lambdabot>  True
05:51:45 <silver> lamefun, ^
05:55:02 <lamefun> > let crazy = 1:crazy in length crazy >= 2
05:55:07 <lambdabot>  mueval: ExitFailure 1
05:55:10 <lamefun> silver: ^
05:58:51 * hackagebot spdx 0.2.0.0 - SPDX license expression language  http://hackage.haskell.org/package/spdx-0.2.0.0 (phadej)
05:59:51 <lamefun> I want something that doesn't break down when given infinite lists.
06:00:59 <Flonk> > (zipWith (\w (x:xs) -> (x, init w ++ xs)) <$> (tail.inits) <*> (init.tails)) >=> (\(a,as) -> map (a,) as) $ [1,2,3] -- Darwin226, just for good measure
06:01:00 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
06:03:20 <gmanny> Flonk: whoa? 
06:03:27 <gmanny> what does that do
06:03:48 <Flonk> gmanny: calculate the cartesian product, where no element is paired with itself
06:03:51 <Flonk> But he left, I see
06:04:51 <joehh> I've looked on hackage and googled, but haven't managed to find an implementation of http digest authentication for scotty/wai
06:04:57 <joehh> is there one commonly used?
06:08:44 <nkaretnikov> what are the ways to get an Int64 from a ByteString?  read does what I want, but I want the speed of Data.Binary.decode (which converts differently)
06:10:59 <silver> > let {isLarge [] _ = False; isLarge _ 1 = True; isLarge (x:xs) n = isLarge xs (n-1);} in isLarge [1..] 13
06:11:00 <lambdabot>  True
06:11:27 <silver> lamefun, it's not built-in but you get the idea
06:13:52 * hackagebot hakyll-R 0.1.0.3 - A package allowing to write Hakyll blog posts in Rmd  http://hackage.haskell.org/package/hakyll-R-0.1.0.3 (CorentinDupont)
06:14:29 <lamefun> let {isLarge [] _ = False; isLarge _ 1 = True; isLarge (x:xs) n = isLarge xs (n-1);} in isLarge [1..] -1
06:14:37 <lamefun> > let {isLarge [] _ = False; isLarge _ 1 = True; isLarge (x:xs) n = isLarge xs (n-1);} in isLarge [1..] -1
06:14:38 <quchen> isLarge xs n = not (null (drop n xs))
06:14:39 <lambdabot>      No instance for (Typeable a0)
06:14:39 <lambdabot>        arising from a use of ‘show_M377779439559425488213101’
06:14:39 <lambdabot>      In the expression:
06:14:54 <lamefun> > let {isLarge [] _ = False; isLarge _ 1 = True; isLarge (x:xs) n = isLarge xs (n-1);} in isLarge [1..] 8
06:14:56 <lambdabot>  True
06:16:13 <silver> quchen, nice
06:17:07 <gmanny> what is haskell's enum equivalent?
06:17:35 <gmanny> enum in c, c#, etc
06:17:50 <quchen> data Foo = A | B | Hamster | C
06:17:55 <quchen> "Sum types"
06:18:41 <gmanny> ok thanks
06:19:50 <quchen> They're much better than the enums you're used to because you get compile-time checks of their validity
06:22:04 <gmanny> can you expand on compile-time checks of their validity? I am not sure I get it
06:23:25 <quchen> You can't forget checking for all alternatives
06:23:54 <arw> and there won't be any surprises like an enum containing some weird unnamed value
06:24:06 <lamefun> Doesn't gcc have switch enum warning as well?
06:24:34 <arw> (which can happen in c since enum is an int and if ununitialized or abused, you get weird unnamed states)
06:33:13 <arw> lamefun: yes, clang as well iirc. 
06:35:45 <kuribas> gmanny: There's a Enum typeclass which you can derive automatically.
06:37:50 <bernalex> gmanny: since our data types are algebraic you can have sum types with product types. like data Maybe a = Nothing | Just a
06:38:40 <bernalex> so you can have data Shape = Circle {radius :: Int} | Rectangle {width :: Int, height :: Int} | Square {size :: Int} -- and similar.
06:39:14 <bernalex> *much* more useful than enums.
06:39:44 <kuribas> gmanny: If you derive the Enum typeclass, you can do anything which you would do in a C enum, like convert to Int.
06:39:49 <arw> even more useful than unions of structs plus enums (which would do the same in c)
06:40:08 <bernalex> arw: a lot. and far less cumbersome.
06:40:56 <bernalex> now you can super easily write a polymorphic collide :: Shape -> Shape -> Maybe Vector -- which works on all the different permutations of shapes.
06:41:07 <gmanny> I wanted a haskell equivalent of enum { male, female }
06:41:20 <gmanny> data Sex = Male | Female?
06:41:21 <bernalex> data Gender = Male | Female
06:41:24 <bernalex> sure
06:41:49 <bernalex> then you can have data Person = MkPerson Gender
06:41:57 <bernalex> MkPerson Male, MkPerson Female.
06:42:00 <marchelzo_> Does Enum imply Ord?
06:42:33 <ronh> no
06:42:38 <bernalex> no.
06:42:41 <ronh> you can derive it though
06:42:55 <bernalex> nor does it imply Bounded, nor Eq. you can derive all of it though.
06:43:13 <marchelzo_> It could though, couldn't it?
06:43:38 <marchelzo_> cmp = comparing fromEnum
06:43:53 <marchelzo_> err
06:43:58 <marchelzo_> you know what I mean
06:44:10 <bernalex> Ordering is an instance of Enum.
06:44:31 <kuribas> You may want to derive your own instance.
06:44:56 <marchelzo_> Oh, that makes sense.
06:46:55 <zipper> Hey can't I use an #ifdef in a case statement? Like here: http://lpaste.net/6718698009208553472
06:48:03 <bernalex> why is the ifdef not post the | condition? anyway I'd think that should work fine since it's cpp
06:48:05 <marchelzo_> Would it be possible make everything with an Enum instance have on Ord instance?
06:48:56 <maerwald> by deriving it
06:48:59 <bernalex> zipper: do you have {-# LANGUAGE CPP #-} ?
06:49:17 <bernalex> zipper: what's the problem/error/etc?
06:49:19 <marchelzo_> maerwald: I mean write one instance that applies to all Enums
06:49:49 <marchelzo_> Like instance Ord (forall a. Enum a => a) where { compare = ... }
06:49:59 <zipper> bernalex: Parse error in pattern: ifdef
06:50:00 <bernalex> marchelzo_: just write an orphaned instance for it
06:50:15 <bernalex> zipper: uh do you have the lang pragma as mentioned above?
06:50:22 <zipper> bernalex: Yes
06:50:40 <zipper> bernalex: {-# LANGUAGE ScopedTypeVariables, TemplateHaskell, CPP #-}
06:51:17 <bernalex> zipper: should it maybe be completely deindented? IDR CPP -- I use it so seldom in haskell.
06:51:28 <marchelzo_> bernalex: What does that look like?
06:51:47 <maerwald> @hoogle GenXML
06:51:48 <lambdabot> No results found
06:51:48 <bernalex> marchelzo_: like any other instance. orphaned just means it's not written in the same place as the typeclass itself.
06:52:30 <marchelzo_> bernalex: So how would you write it? I keep getting errors.
06:54:03 <zipper> bernalex: Ha I figured out part of the issue. Line 2 should end with a ->
06:54:18 <zipper> bernalex: I added it and it says parse error on #
06:55:36 <bernalex> marchelzo_: oh. right. Ord. Ord is *->*. why do you want that? there's instance Enum Ordering.
06:56:15 <marchelzo_> bernalex: Oh. So it's not possible?
06:56:20 <maerwald> XMLGenT (HSPT XML IO) (XMLType (HSPT XML IO)) -- great API
06:56:37 <bernalex> maerwald: I don't think you can just redefine Enum like that.
06:56:48 <marchelzo_> bernalex: I don't actually want/need it, I was just curious if/how it could be done.
06:56:50 <maerwald> bernalex: wat?
06:56:59 <bernalex> maerwald: sorry; that was for marchelzo_.
06:57:18 <maerwald> hsp/hsx is horrible
06:58:06 <zipper> Where can I read about #ifdef in haskell
06:58:09 <marchelzo_> So Monad implying Applicative, is that something that had to be done beneath the level of the language itself?
06:58:23 <zipper> GHC docs don't seem to be helping
06:58:35 <kuribas> zipper: It's just CPP
06:58:38 <bernalex> marchelzo_: no it is done in the way monad and applicative are defined.
06:58:51 <kuribas> zipper: Don't CPP directives have to be on column one?
06:59:15 <bernalex> marchelzo_: what I'm saying is that I don't think you can just extend Enum like that. we can of course change Enum in GHC's base to be like that.
06:59:16 <zipper> kuribas: You see any issue with? http://lpaste.net/6718698009208553472
06:59:18 <marchelzo_> bernalex: Oh, so Ord could have been defined in such a way that Enum implied Ord, but it wasn't.
06:59:23 <bernalex> marchelzo_: yes.
06:59:30 <zipper> kuribas: Oh you mean the entire function should be in the ifdef.
06:59:43 <marchelzo_> bernalex: I see. Thanks.
07:00:00 <ronh> marchelzo_, actually, Enum could have been defined in such a way that it implied Ord
07:00:27 <kuribas> zipper: http://lpaste.net/6718698009208553472
07:00:43 <bernalex> marchelzo_: it's just simple 'class Foo a => Bar a'.
07:00:52 <ronh> class Ord a => Enum a where ...
07:01:26 <bernalex> yes.
07:02:21 <marchelzo_> And that is in the class definition for Ord, or Enum?
07:02:29 <ronh> Enum
07:03:00 <marchelzo_> It looks like that's saying Ord implies Enum. But that can't be right.
07:03:26 <monochrom> => is punctuation. don't attach a meaning to it
07:04:09 <monochrom> "class .... => X a where" defines X, not ...
07:04:46 <monochrom> the problem with meaningful syntax is that there are so many meanings to choose from
07:04:50 <marchelzo_> So that defines, a class Enum, and also makes it so that when you have an Enum instance, you get an Ord instance as well.
07:04:53 <marchelzo_> s/,//
07:05:06 <bernalex> marchelzo_: it's saying that the a which must be an Enum must also be an Ord.
07:05:08 <monochrom> no, not get. require.
07:05:19 <monochrom> there is no free instance
07:05:53 <bernalex> monochrom: Ord is * -> Constraint. 'Ord a => ...' means "witness that a is bound by Ord", i.e. that it must be Ord.
07:05:57 <bernalex> uhm marchelzo_ ^
07:06:06 <bernalex> my tab-completion-fu is not too great today
07:06:17 <marchelzo_> I see. The syntax makes more sense in that case...
07:06:34 <gmanny> it helps to type more than one letter in a 1400-channel room :)
07:06:40 <marchelzo_> So there is no way to write a class definition that gives a free instance of another class.
07:06:49 <maerwald> I hope not
07:06:51 <gmanny> that is an impressive number btw
07:07:00 <bernalex> gmanny: my tab-completion is based on who last spoke. sometimes I forget to pay attention to people who speak after the one I'm replying to. lol.
07:07:14 <gmanny> bernalex: ah
07:07:35 <kuribas> zipper: that seems to work
07:08:23 <bernalex> maerwald: typeclasses are not for giving you free stuff. typeclasses are a form of bounded qualification.
07:08:34 <bernalex> ok
07:08:36 <bernalex> I'm giving up
07:08:40 <bernalex> going to go get an energy drink now
07:08:49 <bernalex> my brain is not up for irc or haskell right now. :)
07:08:53 <marchelzo_> Wait so in the case of "class Ord a => Enum a ... ", what does the `Ord a =>` do for you? Do types with Ord instances automatically get Enum instances? Otherwise what's the point?
07:09:00 <maerwald> does someone know how to construct a "GenXML (HSPT XML IO)" from a String? It looks almost impossible to me, because there can't be a meaningful Read instance and it's very nasty monad burrito
07:09:07 <marchelzo_> Wait no that's not possible.
07:09:15 <ronh> marchelzo_ it forces you to define Ord instance before you can define Enum instance
07:09:22 <kuribas> Does ghc have a builtin CPP?
07:09:25 <monochrom> actually, you can define after
07:09:32 <ronh> if you define just Enum instance you'll get a compile error
07:09:39 <ronh> yes, order doesn't matter
07:09:40 <marchelzo_> Why would you want that, though?
07:09:55 <bernalex> ronh: bar the right set of -Xs. :)
07:10:14 <edk> marchelzo_, suppose Enum implies all the functionality embodied in Ord
07:10:26 * bernalex >>= shopping
07:10:39 <monochrom> suppose I define "yyy :: Enum a => a -> a -> a". inside the body of yyy, I can use both Enum methods and Ord methods
07:10:42 <edk> wouldn't it make more sense to require an Ord instance, rather than describe that interface again for the sake of Enum?
07:11:10 <nshepperd> marchelzo_: in objected oriented land you might call it "extending an interface"
07:11:35 <nshepperd> "An Enum thing is an Ord thing that also does foo, bar, and baz"
07:11:42 <kuribas> zipper: it's possible that ghc enforces that a directive must start on the first column, which cpp doesn't.
07:11:52 <programo> Hi can any body explain why such an error occured in this code http://lpaste.net/136401
07:12:30 <monochrom> rad's type is defaulted to Double
07:12:38 <kuribas> programo: ghci automatically chooses Double
07:12:41 <marchelzo_> I see, but Enum seems to provide a superset of Ord's functionality regardless of whether the type already has an Ord instance.
07:12:45 <mniip> kuribas, zipper, I think cpp does enforce # to be the first symbol
07:12:50 <marchelzo_> It seems weird to me that you can't take advantage of that.
07:12:50 <mniip> but it can be followed by whitespace
07:12:59 <mniip> #     ifdef ...
07:13:21 <edk> cpps have not enforced that for a long time, iirc
07:13:54 * hackagebot libravatar 0.1.0.0 - Use Libravatar, the decentralized avatar delivery service  http://hackage.haskell.org/package/libravatar-0.1.0.0 (akrasner)
07:14:10 <mniip> hmm
07:14:13 <kuribas> edk: ghc seems to enforce it.
07:14:22 <kuribas> edk: does ghc have a builtin cpp?
07:14:25 <edk> then i guess that is indeed a difference
07:14:29 <mniip> edk, maybe, but definitely not a long time
07:14:30 <nshepperd> marchelzo_: remembering that classes don't provide any functionality but just define an interface, that's exactly why you add the constraint
07:14:37 <joneshf-laptop> Coyoneda lets you take any type constructor and turn it into a free monad, but can you use this for anything meaningful without the underlying tyCon being a Functor?
07:15:08 <edk> marchelzo_, Enum a implies that a has a total ordering, but it doesn't give you an interface to compare things using that order
07:15:16 <joneshf-laptop> It seems that if you want to use iter or the like, you need that underlying Functor
07:15:32 <marchelzo_> edk: Exactly. It could, though.
07:15:40 <nshepperd> actually Enum is not a good example for this, because the Enum type is a bit silly
07:15:46 <edk> that is true
07:16:17 <nshepperd> marchelzo_: but for instance we write 'class Eq a => Ord a', because if you can compare something you can certainly check it for equality
07:16:48 <programo> kuribas,  if ghci automaticaly chooses Double then it should choose the circumference 5.0 as also as double and there should be type mis match as I had declared the function as Float->Float
07:17:02 <programo> But I have got the result for that
07:17:16 <monochrom> no, you gave a type to circumference. you dictated it.
07:17:22 <edk> programo, you gave the type for circumference explicitly, there was no defaulting
07:17:30 <marchelzo_> nshepperd: That also seems odd :|
07:18:02 <marchelzo_> nshepperd: I get why it has to be that way, though.
07:18:04 <nshepperd> marchelzo_: this means that when you write a function that uses both Eq and Ord, you can safely write (Ord a) => a -> Foo instead of (Eq a, Ord a) => a -> Foo
07:18:18 <ronh> marchelzo_ what is odd about it?
07:18:27 <nshepperd> and still be able to use (==)
07:18:40 <marchelzo_> ronh: Ord could give you Eq for free, but instead it requires you already have it.
07:18:55 * hackagebot resolve-trivial-conflicts 0.3.0.2 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.0.2 (EyalLotem)
07:20:17 <skrio> Hello, new to haskell and having a bit of a type error I can't straighten out. Anyone mind lending me a hand for a moment?
07:20:57 <programo> Yeah had mentioned the circumference as   Float->Float ; when I initialize a variable rad=5.0 and then call the function circumference rad ; I got an error ..Where as if I call the function as circumference 5.0 , it works .How is this possible ?
07:21:20 <monochrom> 5.0 is polymorphic
07:21:21 <nshepperd> well, what you often do is 'instance Eq Foo where { (==) = defaultUsingOrd }; instance Ord Foo where { actual code }'
07:21:57 <bitemyapp> skrio: best to just jump to posting the code and asking your question, culturally IRC users don't really do explicit hand-offs for question slike this and you'll get your answer faster by going straight to the question.
07:21:58 <nshepperd> which is sort of formally telling the compiler 'how' to make the Eq instance 'for free'
07:22:08 <marchelzo_> nshepperd: Exactly. It seems like that should be done automatically.
07:22:22 <skrio> @bitemyapp thanks :)
07:22:22 <lambdabot> Unknown command, try @list
07:22:30 <marchelzo_> nshepperd: I guess it would cause more problems than it would solve though, as you don't always want the default.
07:22:48 <monochrom> please don't use @. it's a bot command. also, IRC is not twitter
07:22:59 <skrio> monochrom: my bad
07:23:02 <dramforever> skrio: you should do this
07:23:16 <dramforever> oh you already know it =P
07:23:25 <nshepperd> marchelzo_: yes, it's really better to be explicit about it, generally
07:24:00 <programo> monochrom,  I did not get it can you please elaborate on it ?
07:24:21 <nshepperd> marchelzo_: even if only for the benefit of the person reading the code who wonders where the Eq instance is coming from
07:24:46 <kuribas> mniip, zipper, edk: you can indent preprocessor directives when using an external preprocessor (for example -pgmP cpp),but not with the default preprocessor.
07:25:00 <programo> monochrom, http://lpaste.net/136401
07:25:29 <skrio> So: I'm trying to filter [Element] using the prelude function for it. However, the function requires a function Element -> Bool, and the closest I can get it is Element -> m0 Bool. Is there any clean way to get filter to accept m0 Bool or allow my function to return Bool?
07:25:51 <mniip> programo, ghci has to assign a monomorphic type to 'rad', and following defaulting rules, it gets a type of Double
07:26:04 <mniip> and you can't apply a Float->Float with a Double
07:26:19 <kuribas> :t filterM
07:26:20 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
07:26:30 <kuribas> skrio: use filterM from Control.Monad
07:26:48 <skrio> kuribas: duh, thanks :)
07:27:24 <kuribas> skrio: or alternatively, first get the pure list using sequence, and then use filter.
07:30:58 <maerwald> does anyone know how to mix inline xml in hsx with e.g. xml data from a file or a string?
07:32:21 <StrangeLoop> Hi, I am trying to write a small image processing library. I have a matrix data structure I implemented, and I want to do some calculations. The calculations require me to create a new matrix given an existing one and calculate each pixel from several pixels of the initial matrix (so an ordinary map seems to be problematic), is there any "haskell-ish" way to do it?
07:32:30 <programo> So if I say circumference 5.0 ; then 5.0 gets defaulted to Double?
07:32:36 <maerwald> StrangeLoop: JuicyPixels
07:32:58 <maerwald> StrangeLoop: I have done some very basic image processing, it works well with that library
07:33:08 <dramforever> StrangeLoop: that sounds like what a comonad could do
07:33:24 <dramforever> :t extend -- something like this
07:33:25 <lambdabot> Not in scope: ‘extend’
07:33:29 <dramforever> =(
07:33:32 <StrangeLoop> maerwald: I need to implement it using only stuff in prelude
07:33:36 <maerwald> ugh
07:33:55 * hackagebot splay 0.0.6 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.6 (dramforever)
07:34:34 <dramforever> StrangeLoop: so what are the operation like?
07:34:55 <dramforever> *operations
07:35:14 <StrangeLoop> Like, calculating connectivity components, or convolutions, nothing fancy. I just need to show I can implement something in Haskell which is not trivial.
07:35:39 <kuribas> StrangeLoop: The haskellish way would be to use an optimized library like https://hackage.haskell.org/package/repa, https://hackage.haskell.org/package/accelerate, etc... If you cannot use that than you'll be limited to arrays (if you want performance).
07:35:54 <dramforever> kuribas: no not even arrays
07:35:59 <kuribas> heh
07:36:06 <StrangeLoop> I already implemented matrices
07:36:14 <kuribas> using lists?
07:36:49 <monochrom> why do you limit yourself to Prelude?
07:36:51 <StrangeLoop> Yup.
07:36:55 <maerwald> StrangeLoop: JuicyPixels has a function called generateImage which takes a function of the form (\x y -> dostuff with it)... so it's not exactly a map and you feed it the original image. Then you can get the surrounding pixels by simple calculation since you have the x and y coordinate of the current pixel
07:36:58 <StrangeLoop> monochrom: Its a school project
07:37:10 <dramforever> StrangeLoop: so it must be image processing?
07:37:34 <maerwald> StrangeLoop: and out of that information you just create the new pixel
07:37:35 <nkaretnikov> is there a data.map-like api for hashmaps somewhere?
07:37:36 <monochrom> I don't see why "school project" logically implies "limited to Prelude"
07:37:38 <dramforever> StrangeLoop: hmm...so you are learning haskell in school?
07:37:48 <StrangeLoop> dramforever: Nope, I chose the project. But now I am stuck with it, and I don't think it should be too hard either. I am just trying to avoid pat peeves
07:38:04 <dramforever> really must avoid anything outside of prelude?
07:38:08 <StrangeLoop> dramforever: Yup, graduate school though
07:38:59 <nkaretnikov> StrangeLoop: have you looked at image-processing libs already?
07:39:14 <StrangeLoop> dramforever: OK, I was trying to hide a shameful truth. Thing is, I don't have a computer, so I have to use the school computers, where I don't have permissions to install anything (nope, no hsenv)
07:39:37 <StrangeLoop> So I am trying to do with what I have :/
07:39:39 <dramforever> you can just download ghc and unpack it and use it
07:40:22 <maerwald> StrangeLoop: do you get the idea? So not an ordinary map, but one that allows you to access both x and y coordinates... and those you can use to compare the matrices
07:40:23 <StrangeLoop> But I am sure I can code something reasonable with core tools, I mean, I did similar things in other languages
07:40:27 <StrangeLoop> Oh, I have ghci with prelude
07:40:29 <monochrom> you do not need sysadmin access to install libraries. you only need normal user access. are you a normal user?
07:40:52 <nkaretnikov> StrangeLoop: you can still look at the libs, can't you?
07:40:55 <dramforever> StrangeLoop: no, ghc comes with quite a few extra packages
07:41:00 <dramforever> try import Data.Array
07:41:00 <nkaretnikov> StrangeLoop: to learn how things are done, no?
07:41:01 <monochrom> you only need your home directory to be writable by you
07:41:13 <StrangeLoop> Ohh ohhh sorry, yes. I meant "anything default", not just prelude
07:41:19 <monochrom> is your home directory writable by you?
07:41:20 <dramforever> [ (10:38:52 PM) StrangeLoop: dramforever: OK, I was trying to hide a shameful truth. Thing is, I don't have a computer, so I have to use the school computers, where I don't have permissions to install anything (nope, no hsenv) ]
07:41:24 <StrangeLoop> monochrom: Yes
07:41:36 <dramforever> StrangeLoop: does import Data.Array work?
07:41:37 <monochrom> then you already have privilege to install libraries
07:42:05 <monochrom> dramforever: I am saying that the sentence is false.
07:42:08 <StrangeLoop> monochrom: How? I tried...
07:42:19 <nkaretnikov> StrangeLoop: nothing shameful about that.  note that you still can program on a piece of a paper.  I used to do that a lot when I was in a similar situation.
07:42:21 <StrangeLoop> dramforever: and I agree with monochrom, I can install anything which can be installed locally
07:42:23 <dramforever> monochrom: which sentence?
07:42:37 <monochrom> "I don't have permission to install anything"
07:42:37 <nkaretnikov> s/a paper/paper/
07:44:12 <monochrom> download http://hackage.haskell.org/package/cabal-install-1.22.6.0/cabal-install-1.22.6.0.tar.gz
07:44:17 <dramforever> btw that "no computer" thing is another XY Problem: http://xyproblem.info, TL;DR: in the beginning you should have asked about installing libraries without admin rights, rather than insisting on staying inside prelude. Don't worry, that happens to all of us at times
07:44:34 <monochrom> unpack it. follow its readme or whatever it's called
07:44:53 <monochrom> it is all home-directory only. no system-wide stuff.
07:44:58 <dramforever> =) Horray, things got waaaaaaay easier
07:45:14 <StrangeLoop> The thing is, even if I can use a library, I think I'd rather just implement it myself. I want to learn about Haskell, I already know image processing (that's why I took this project).
07:45:44 <StrangeLoop> I think I'll try maerwald's suggestion
07:46:45 <dramforever> I don't think it's possible to implement an array type with O(1) indexing with "ordinary" haskell types
07:47:15 <maerwald> StrangeLoop: https://hackage.haskell.org/package/JuicyPixels-3.2.5.2/docs/Codec-Picture.html#v:generateImage that's the type signature
07:47:26 <maerwald> the implementation looks weird, but the type signature should give you an idea
07:47:44 <maerwald> so you just do that for your own code base
07:50:27 <maerwald> hysteresis was horrible to implement in haskell
07:50:40 <maerwald> and I was only able to do it with a dirty hack
07:51:22 <kuribas> StrangeLoop: can't you find a second hand laptop or so?  I bought a very good netbook for 120€ on ebay, which is good enough for any development.
07:53:23 <StrangeLoop> Actually, I don't miss one too much. I mean I have an office with all I need to work (which usually amounts to a browser and LaTeX), and I never do work at home anyway. Also, computers are pretty expansive here...
07:53:38 <hodapp> StrangeLoop: where's 'here'?
07:53:52 <StrangeLoop> Israel
07:56:58 <maerwald> oh, and the gap between toy image processing (as I did) and performant image processing in haskell is WAY bigger than in C++
07:58:32 <kuribas> StrangeLoop: You could use an online server, like hcoop: https://hcoop.net/
07:58:56 * hackagebot operational-class 0.3.0.0 - MonadProgram typeclass for the operational package  http://hackage.haskell.org/package/operational-class-0.3.0.0 (srijs)
08:00:49 <kuribas> StrangeLoop: And do your code over ssh, using emacs in a terminal.
08:08:23 <bernalex> sometimes I wish that . = fmap because I think <$> is too many characters. am I going mad?
08:08:50 <monochrom> yes
08:08:51 <bernalex> map should be what is today fmap, and . should be what is today <$>
08:11:53 <zzubzzub> Do people advise against the Haskell Platform?
08:12:01 <bernalex> zzubzzub: some people.
08:12:32 <zzubzzub> bernalex: Is their advice relevant if I'm a beginner?
08:12:55 <monochrom> I recommend the Haskell Platform. I also use it myself.
08:13:14 <monochrom> but I know all the pros and cons arguments.
08:13:43 <monochrom> as usual, you need to know the future before you know why one side is true for you and the other side false.
08:13:44 <bernalex> zzubzzub: maybe.
08:14:06 <zzubzzub> Well, reference to a list of pro-cons then, please?
08:14:08 <bernalex> zzubzzub: what system are you on? usually you can just get the platform. if you find out you dislike it, you can just uninstall it.
08:14:23 <monochrom> the list has only one item
08:14:48 <zzubzzub> bernalex: I'm unlikely to uninstall anything unless it bugs the hell out of me. Also: Windows 7.
08:15:06 <bernalex> zzubzzub: I don't know how to windows. you can probably get the platform and live happily ever after.
08:15:14 <monochrom> if you will add a lot of libraries much newer than what comes with the Haskell Platform, you will find the Haskell Platform an obstacle.
08:15:16 <zzubzzub> monochrom: Don't be a tease :-/
08:15:30 <zzubzzub> monochrom: Oh, thanks
08:15:35 <monochrom> else, you will find it a help
08:15:51 <ronh> bernalex, I am not sure if I'd like . to be <$>
08:15:53 <bernalex> if you're on a system like Gentoo it's easier to just emerge cabal-install and be done with it. on windows the HP is probably fine.
08:16:08 <bernalex> ronh: well it already is. just monomorphic to funtions.
08:16:18 <ronh> I meant polymorphic
08:17:55 <monochrom> I conjecture that very few people are on systems like gentoo
08:18:07 <monochrom> and among beginners, even fewer
08:18:09 <ronh> which is what you meant as well, no? that we should have . which should work on all functors
08:18:27 <kaste> monochrom: out of my haskell class, five out of twelve :p
08:18:41 <joel135> Hi, a quick question. I try to define a data type through "data Computer = {hdd :: String}" but I get a parse error from ghci. Why?
08:18:43 <bernalex> monochrom: just because most people use windows or mac os x, that does not mean we should assume everyone does. I'm just saying that gentoo is an example where the HP is not your best option.
08:18:52 <bernalex> ronh: yep.
08:18:54 <kaste> statistical anomalies are fun
08:18:56 <c_wraith> joel135: it doesn't have a constructor.
08:19:10 <c_wraith> joel135: data Computer = Computer { hdd :: String }
08:19:10 <monochrom> gentoo are arch are about the only examples
08:19:20 <joel135> c_wraith, thanks !
08:19:37 <monochrom> also, in my biased data set, most people use ubuntu
08:19:50 <c_wraith> I used to use ubuntu, 'til they went crazy.  Now I use debian.
08:19:59 <bernalex> monochrom: I don't know if you are trolling/being difficult on purpose, but I have no interest in "arguing" about this.
08:20:59 <bernalex> c_wraith: don't teach people that please =/
08:21:12 <monochrom> this is because you made a wrong assumption about me. you assumed that I assumed that most people use windows or mac os x.
08:21:15 <bernalex> c_wraith: joel135: data Computer = MkComputer {hdd :: String}
08:21:18 <c_wraith> bernalex: naming the constructor the same as the type?
08:21:31 <c_wraith> bernalex: Why not?  People need to be able to read real code.
08:21:34 <bernalex> c_wraith: yes. people are confused about it almost daily.
08:21:43 <bernalex> c_wraith: and it's really annoying for error messages.
08:21:50 <bernalex> I think it's a terrible habit.
08:22:46 <bernalex> I would not tell everyone that comes in here "use C++ instead" because "people need to be able to read real code", nor would I refer them to other common anti-patterns in haskell.
08:23:23 <c_wraith> I also don't think it's an anti-pattern.
08:23:57 <cjay> bernalex: what naming convention do you suggest for types that have only one constructor?
08:23:57 <kuribas> Since when is that an anti-pattern?  I always did this and it never confused me.
08:24:07 <exio4> I don't think it's an anti-pattern, it also means you understood the haskell type system has a strong separation between types and values 
08:24:13 <bernalex> cjay: I use MkFoo, like SPJ in his talks.
08:24:27 <maerwald> bernalex: +1
08:24:32 <monochrom> the dilemma of the two of you can be easily resolved by beginning with "data Computer = Ctor ..." and then remarking that you can s/Ctor/Computer
08:24:45 <StrangeLoop> http://lpaste.net/136404 <-- can anyone help me understand this error?
08:25:46 <mauke> StrangeLoop: you can't use floor on Ints
08:25:48 <OutlawStar> curious, is there a preferred way of naming the ctor? I've always used the name as the type
08:26:04 <ronh> StrangeLoop floor takes RealFrac as an argument. 50 may appear to be Int (just like your x variable) but it is really a Num a => a.
08:26:04 <OutlawStar> same name*
08:26:11 <monochrom> see above
08:26:12 <ronh> > 50 :: Double
08:26:13 <lambdabot>  50.0
08:26:43 <cjay> bernalex: MkFoo ("make foo") sounds too much like a one-way operation imho, it seems weird when deconstructing
08:26:44 <ronh> :t 50
08:26:45 <lambdabot> Num a => a
08:26:49 <kuribas> StrangeLoop: and sin
08:27:14 <bernalex> I find that ADTs that are data Foo = Foo are very often completely unecessary and basically just type synonyms. my ADTs are more often things like data Shape = Circle... | Rectangle...
08:27:47 <StrangeLoop> I am using floor on (sin x), that should be a float
08:27:50 <monochrom> but newtype faces the same naming question
08:27:54 <bernalex> ymmv in this regard, of course. in games I often have a data Game = MkGame or similar for convenience.
08:28:00 <kuribas> :t sin -- StrangeLoop
08:28:01 <lambdabot> Floating a => a -> a
08:28:07 <mauke> StrangeLoop: no, because x is an Int
08:28:25 <mauke> StrangeLoop: thus sin x is also an Int (and you can't use sin on Ints, so that's the second error)
08:28:50 <kuribas> > sin (2::Int)
08:28:51 <lambdabot>      No instance for (Floating Int) arising from a use of ‘sin’
08:28:51 <lambdabot>      In the expression: sin (2 :: Int)
08:28:58 <kuribas> mauke: sin doesn't take Int.
08:28:59 <StrangeLoop> So what am I supposed to do then?
08:29:15 <monochrom> sin (fromIntegral x) etc
08:29:44 <ronh> you need fromIntegral around y as well
08:30:05 <kuribas> StrangeLoop: also, sin takes radians, not degrees.
08:30:06 <StrangeLoop> This is really ugly :/
08:30:15 <StrangeLoop> kuribas: Yeah, I know
08:30:26 <ronh> StrangeLoop, less ugly than implicit lossy conversions
08:30:30 <mauke> kuribas: yes, that's what I said
08:30:54 <kuribas> mauke: ah, right
08:31:48 <kuribas> StrangeLoop: why would you want to take the sine of an Int?  What do you want to do?
08:32:02 <StrangeLoop> kuribas: Just plotting
08:34:01 <lpaste> Exio4 pasted “messy exceptions” at http://lpaste.net/136405
08:34:03 <exio4> ^ working with some code that uses threads, and exceptions at the thread-level (any exception thrown in the thread shouldn't leak to the rest of the program, instead killing the thread and leaving every other thread alone, doing the proper cleanup and showing why (if an exception happened, because it's the only way to `quit` from a thread)), instead, the whole program crashes, would anyone know why that
08:34:04 <exio4> could happen? 
08:34:08 <exio4> woops, wall of text
08:34:10 <kuribas> StrangeLoop: Double is a more logical choice, because then you can change the scale of the X axis.
08:34:59 <StrangeLoop> kuribas: Yes, but I am just test driving a function which generates an image as a function of the coordinates of the pixels
08:35:18 <maerwald> StrangeLoop: generate :: (Int -> Int -> Float) -> Int -> Int -> Image -- would that work? I converted all my images to float images to some point just to avoid all the conversions
08:35:36 <exio4> basically, I am throwing an exception inside a thread, trying to catch it from within it, somewhat my code doesn't work 
08:35:51 <kuribas> StrangeLoop: anyway, if you really want an Int, you can use Monochroms suggestion "sin (fromIntegral x)".
08:36:45 <kuribas> StrangeLoop: But personally I would just use Double.
08:38:06 <ttt_fff> is there a way to define a macro "assert" s.t. assert (x == y) ==> when (not (x == y)) error "(x ==y)" ++ "failed"
08:38:51 <monochrom> @hoogle assert
08:38:51 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:38:52 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:38:52 <lambdabot> Control.OldException assert :: Bool -> a -> a
08:39:11 <monochrom> it is already in Control.Exception. furthermore, it enjoys the magic of telling you line numbers
08:39:41 <ttt_fff> well, I need to be able to 'capture' these exceptions
08:39:48 <ttt_fff> and output them via SVG
08:40:01 <ttt_fff> I also need the filename
08:40:26 <ronh> why is error not enjoying the same magic?
08:40:29 <monochrom> ok, since it lives in Control.Exception, I bet all it does is to raise an exception you can catch
08:41:09 <monochrom> probably just historical. assert is newer
08:41:22 <exio4> ttt_fff: using `catch`? and a proper exception type? 
08:41:47 <ttt_fff> okay
08:41:47 <monochrom> the name of the exception is AssertionFailed
08:41:49 <ttt_fff> so I really need macros
08:42:05 <monochrom> how do I know? by reading Control.Exception.assert doc
08:42:15 <exio4> oh, nice
08:42:50 <monochrom> why am I doing all the legwork?
08:43:26 <monochrom> one would think that if I brought up "it's already in Control.Exception" then I would be done and you would be the one reading docs
08:46:18 <exio4> anyway, does anyone know about my problem with exceptions + threads? :/ 
08:46:58 <monochrom> it's a long program, and I am too lazy to install the lua binding, so I don't know what caused it
08:47:45 <kuribas> exio4: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
08:48:10 <monochrom> if I were a consultant for this, I would first do very compartmentalized unit tests to check your hypothesis. (read: refute your hypothesis)
08:48:48 <exio4> ah, right, I just checked, being within lua is the problem
08:49:41 <kuribas> exio4: I can recommend reading this book, because it describes your issues.
08:49:54 <ttt_fff> monochrom: it's the XY problem, I have problem X, I thought a minimal test case for it would be "how do I solve y"; unfortunately, you solved Y in a way that does not generalize to my need for solving X
08:50:22 <exio4> kuribas: really? nice, will check!
08:50:25 <ttt_fff> monochrom: I have a stack frame that implements 'stack frames' so I can track what's calling what
08:50:35 <ttt_fff> monochrom: and on error, it dumpts the entire stack frame as a SVG file, so I can get the callgraph
08:53:56 <kuribas> Is this *core flaw* of pipes fixed?  http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit
09:04:14 <hiptobecubic> @hoogle Either a b -> Maybe b
09:04:14 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
09:04:15 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
09:04:15 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
09:04:40 <hiptobecubic> I guess just   "either (const Nothing) Just"?
09:07:04 <kadoban> hiptobecubic: There's also http://haddock.stackage.org/lts-2.17/errors-1.4.7/Control-Error-Util.html#v:hush or http://haddock.stackage.org/lts-2.17/errors-1.4.7/Control-Error-Safe.html#v:rightMay or probably others, in packages.
09:07:13 <kadoban> Probably not worth pulling some in for though …
09:08:59 * hackagebot hmm-hmatrix 0.0.0.1 - Hidden Markov Models using HMatrix primitives  http://hackage.haskell.org/package/hmm-hmatrix-0.0.0.1 (HenningThielemann)
09:15:03 <xpilot> hello
09:15:11 <xpilot> anyone here have experience with accelerate?
09:15:41 <xpilot> I've been unable so far to see any performance boost over hmatrix
09:15:59 <hiptobecubic> hmatrix is *very* fast.
09:16:16 <hiptobecubic> so if your problem is not well suited to the GPU, I wouldn't be surprised.
09:16:27 <xpilot> matrix-vector multiplication
09:16:35 <hiptobecubic> how large?
09:17:01 <xpilot> well I've tried a very wide range of sizes, and hmatrix is consistently faster
09:17:11 <hiptobecubic> if it's not huge or many many iterations, the overhead of initializing it and shipping it to the gpu and back will be too much
09:17:46 <hiptobecubic> have you tried the accelerate examples themselves? Are you able to benchmark differences with those?
09:17:51 <nkaretnikov> I doubt so, but still: can you have constant time cons and index access?
09:18:03 <xpilot> the accelerate examples work fine
09:18:11 <xpilot> I'm not sure what to compare them to
09:18:34 <hiptobecubic> You *are* using the gpu backend, right? :)
09:18:39 <xpilot> yeah
09:18:53 <nshepperd> nkaretnikov: you can, with exponentially resizing mutable arrays
09:19:01 <xpilot> I've also tried the interpreter backend and it's much slower :)
09:19:20 <nkaretnikov> nshepperd: any packages for that?
09:19:30 <xpilot> maybe I need to do more operations than just 1 matrix-vector product
09:20:39 <hiptobecubic> It may just be that your problem is too simple for the gpu to be useful. GEMV is hard to beat.
09:20:54 <xpilot> but with hmatrix 5-10x faster even on 4000x4000 matrices, I'm not too hopeful
09:21:15 <xpilot> ok
09:21:21 <hiptobecubic> The problem is initializing the gpu and shipping over the data, then shipping the result back
09:21:28 <xpilot> I was hoping something so parallelizable would see easy wins
09:21:45 <nkaretnikov> nshepperd: I've been thinking of using something like (Int, [a]) where an Int is the index I care about.  consing is constant time, but indexing is O(n) in the worst case.
09:21:53 <hiptobecubic> even if solving the problem was instantaneous, the overhead of those things makes it slower than doing things locally sometimes
09:22:03 <xpilot> I'd like to see a simple program where the gpu clearly wins
09:22:19 <hiptobecubic> xpilot, it will win where the amount of computation per data is higher
09:22:24 <nkaretnikov> nshepperd: obviously I want as little overhead as possible
09:22:27 <xpilot> but yeah I hear what you're saying
09:22:41 <sccrstud92_> is there a way to turn a runtime int into a type-level nat that can be used with Mod from Data.Modular?
09:27:13 <sccrstud92_> i might have figured it out
09:28:03 <nshepperd> nkaretnikov: I don't know of any packages for it
09:29:18 <nshepperd> nkaretnikov: Data.Sequence is O(1) cons, O(log(n)) index, but the constant factors are biggish, iirc
09:30:59 <nkaretnikov> nshepperd: nevermind, I'll just use a recursive function.  will make the index an argument, and then it's just pure consing/indexing without repacking, I think
09:34:36 <nshepperd> what do you actually need this for?
09:35:42 <nshepperd> because Data.Vector has constructN, if you're just building a vector with dependent values
09:41:29 <nshepperd> or my favourite thing to do with dynamic programming problems, to build a big boxed array all at once, containing every step of the solution
09:43:30 <zedbourbaki> nshepperd: could you re-post what you said prior to your last message? I am curious and I just got into the channel : )
09:50:25 <nshepperd> nshepperd | because Data.Vector has constructN, if you're just building a vector with dependent values
09:51:33 <nshepperd> the context is that nkaretnikov asked about a data structure with O(1) cons and index, but actually you can often do without that by just building your final result lazily
09:53:50 <zedbourbaki> nshepperd: thanks : )
09:54:01 * hackagebot hjsonpointer 0.2.0.3 - JSON Pointer library  http://hackage.haskell.org/package/hjsonpointer-0.2.0.3 (seagreen)
09:59:01 * hackagebot pandoc-placetable 0.1.0 - Pandoc filter to include CSV files  http://hackage.haskell.org/package/pandoc-placetable-0.1.0 (mb21)
10:04:02 * hackagebot http-client 0.4.16 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.16 (MichaelSnoyman)
10:04:04 * hackagebot hjsonschema 0.6.0.1 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.6.0.1 (seagreen)
10:23:51 <Jookia> Hey, is there a way to generalize 'sequenceBoth f g = \a b c -> f a b c >> g a b c'
10:24:13 <Jookia> pointfree*
10:26:01 <maerwald> Jookia: you want the pointfree version?
10:26:47 <Jookia> maerwald: Mmm, perhaps not. I want a function that can remove the need for the 'a b c' duplication
10:29:06 <nshepperd> liftA2³ (>>)?
10:29:32 <kuribas> :t sequence_ [f, g] (a, b, c)
10:29:33 <lambdabot>     No instance for (FromExpr a0) arising from a use of ‘f’
10:29:33 <lambdabot>     The type variable ‘a0’ is ambiguous
10:29:33 <lambdabot>     Note: there are several potential instances:
10:29:38 <kuribas> sequence_ [f, g] (a, b, c)
10:29:46 <kuribas> > sequence_ [f, g] (a, b, c)
10:29:47 <lambdabot>      No instance for (FromExpr a0) arising from a use of ‘f’
10:29:47 <lambdabot>      The type variable ‘a0’ is ambiguous
10:29:47 <lambdabot>      Note: there are several potential instances:
10:30:06 <kuribas> :t \f g -> sequence_ [f, g] (a, b, c)
10:30:07 <lambdabot> ((Expr, Expr, Expr) -> a) -> ((Expr, Expr, Expr) -> a) -> ()
10:30:56 <Jookia> i kind of need the final result
10:32:50 <nshepperd> :t (\f g a b c -> (liftA2.liftA2.liftA2) (>>) f g a b c) :: Monad m => (a -> b -> c -> m x) -> (a -> b -> c -> m y) -> a -> b -> c -> m y
10:32:52 <lambdabot> Monad m => (a -> b -> c -> m x) -> (a -> b -> c -> m y) -> a -> b -> c -> m y
10:33:25 <nshepperd> iow, (liftA2.liftA2.liftA2) (>>) f g
10:34:45 <Jookia> hmm
10:35:17 <Jookia> is there a way to have a liftA2 that works multiple times depending on arguments?
10:35:33 <nshepperd> aww, lambdabot doesn't like unicode ³
10:36:39 <maerwald> Jookia: the pointful version is easier to read. It is instantly clear what happens
10:36:49 <Jookia> maerwald: i'm just curious, that's all
10:37:10 <phadej> Jookia: http://okmij.org/ftp/Haskell/polyvariadic.html
10:37:16 <phadej> Jookia: /possible/
10:38:45 <kuribas> liftA2 is liftM2 for a monad?
10:38:54 <phadej> for applicative
10:38:56 <phadej> yes
10:39:14 <kuribas> ok
10:43:15 <phadej> Jookia: but it's very hard problem. E.g. the type 'a -> b -> c' could be intepreted as 'a -> (b -> c)' i.e. single argument function, or two-argument function. But with new enough GHC you probably can write something like: `liftAN (Proxy :: Proxy 3)`
10:43:34 <Jookia> i see
10:43:49 <phadej> if we could have a bit lighter syntax for proxies
10:45:31 <Hafydd> "could be interpreted as"?!
10:45:57 <naudiz> is there a way to only read the last line of a file?
10:45:59 <phadej> Hafydd: where from compiler could know do you want liftA2 or liftA3 there
10:46:15 <phadej> sorry, liftA or liftA2
10:46:21 <naudiz> I mean, a quick way
10:46:44 <Hafydd> I don't think it's a matter of interpretation, given that the syntax "a -> b -> c" literally means a -> (b -> c).
10:47:04 <mauke> naudiz: I don't know if anyone has packaged it as a module
10:47:04 <phadej> naudiz: last time i needed that i didn't found (something like reading file from the end and reversing the input)
10:47:44 <mauke> ... can you even create synthetic Handles with ghc?
10:48:12 <naudiz> that's unfortunate... well, in my way I can still extract it using vim
10:48:23 <kadoban> Hafydd: Well, there's two ways to see it. As a two-argument function (given an 'a' and a 'b' it'll give you a 'c'), or as a function that given an 'a' will give you a (b -> c). Haskell itself always sees it as the latter, but it's sometimes useful to see it as the former, as a programmer.
10:48:36 <mauke> naudiz: how big is your file / does it have to be efficient?
10:49:03 * hackagebot StrappedTemplates 0.2.0.2 - General purpose templates in haskell  http://hackage.haskell.org/package/StrappedTemplates-0.2.0.2 (hansonkd)
10:49:19 <kadoban> Of course haskell beginners are usually conditioned to /only/ see the former, which is something they need to outgrow eventually.
10:50:37 <naudiz> mauke: 225MB, it's a one time thing but I'd prefer it to be efficient
10:51:02 <phadej> naudiz: lazy io will be efficient enough, especially if it's one time thing
10:51:30 <mauke> one time? then I'd use perl
10:51:35 <hsk5> https://pastee.org/sp5vf
10:51:36 <hsk5> Is there a simpler way to extract hello, world, boom out of that foo all at once?
10:51:39 <naudiz>  phadej even in ghci? 
10:51:51 <hsk5> and also is there a way to avoid those underscores to distinguish those variables? kinda painful imo
10:51:54 <phadej> i.e. something like 'last . lines <$> readFile "foo.txt"`
10:51:57 <hsk5> i could use ' instead, but still painful
10:51:59 <phadej> naudiz: yes
10:52:12 <erisco> here is my new fun function to play with
10:52:16 <naudiz> vim is just killing my ram right now... 
10:52:22 <erisco> > propagate (map . (+)) [1..10]
10:52:23 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
10:52:38 <exio4> @type propagate
10:52:39 <lambdabot> (t -> [t] -> [t]) -> [t] -> [t]
10:53:24 <hiptobecubic> Monad transformer question. I'm writing a brainfuck interpreter and the only way it can fail is by running out of input. When this happens I'd like it just terminate and retrun "Left errmsg" rather than "Right memoryState". I'm using a Writer to gather output and I want to be able to access that regardless of failure midway through. Does this make sense? http://vpaste.net/4cLRf
10:53:25 <naudiz> phadej: I hope so... I asked because I've experienced lots of memory overflows with big files
10:53:29 <mauke> perl -MFile::ReadBackwards -we 'print scalar File::ReadBackwards->new($ARGV[0])->readline' yourfile.txt
10:53:30 <erisco> @let mynub = propagate (filter . (/=))
10:53:31 <lambdabot>  Defined.
10:53:32 <mauke> # untested
10:53:41 <erisco> > mynub [1,3,2,6,3,7,1]
10:53:42 <mauke> someone should probably port that to haskell
10:53:43 <lambdabot>  [1,3,2,6,7]
10:53:56 <phadej> naudiz: tell us, if it doesn't work so. It should :)
10:54:53 <phadej> mauke: my new year resolution was to write all ad-hoc little scripts in Haskell (and not in perl or bash)
10:54:59 <hpc> mauke: s <- system "perl -MFile::ReadBackwards -we 'print scalar File::ReadBackwards->new($ARGV[0])->readline' yourfile.txt"
10:55:03 <naudiz> phadej: right now I'm just hoping vim won't force a shutdown because I'm out of memory :/ sometimes I'm just very stupid
10:55:23 <mauke> ^Z
10:55:25 <mauke> kill %1
10:55:26 <breadmonster> mauke: port what?
10:55:32 <mauke> breadmonster: File::ReadBackwards
10:55:35 <hpc> heh
10:56:05 <hpc> mauke: second idea - import Pugs
10:56:06 <hiptobecubic> Specifically, I would like it *not* to raise a damn exception when it fails.
10:56:15 <mauke> hpc: does that still exist?
10:56:21 <hpc> probably not
10:56:53 <naudiz> mauke: don't want to kill it because of other opened documents... vim creates back-ups but I still prefer not to kill it
10:57:27 <exio4> hiptobecubic: you shouldn't be using `fail`
10:57:44 <hiptobecubic> exio4, I don't intend to in the end, if I ever figure out how this stack works
10:57:57 <hiptobecubic> but returning "Left whatever" doesn't do what want
10:58:05 <hiptobecubic> such as type check
10:58:09 <breadmonster> hiptobecubic: Could I see the source?
10:59:04 * hackagebot edit-distance 0.2.2.1 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.2.1 (phadej)
10:59:46 <lpaste> hiptobecubic pasted “Brainfuck” at http://lpaste.net/136409
10:59:58 <hiptobecubic> breadmonster, The entire program? Sure. I clipped this little bit out because it captures the problem. Here is the entire thing so far (loops are apparently broken at the moment). ^^
11:00:51 <hiptobecubic> I've reimplemented a lot of things myself as finger exercises, so ignore the parsers
11:02:10 <exio4> hiptobecubic: note that StateT Input (WriterT Output m) a has `m` at the bottom of the stack, you could move it to the top, (also, using ExceptT, which has a nicer interface, and is just a wrapped Either), such that runExceptT has as type :: ExceptT Err (StateT Input (Writer Output) a -> StateT Input (Writer Output) (Either Err a) 
11:02:22 <cow_2001> why do people do it? why do people import modules wholesale into their module's namespace? :(
11:02:55 <hiptobecubic> cow_2001, because they don't want to constantly update the import list during development.
11:03:09 <cow_2001> aren't there tools for that?
11:03:43 <hiptobecubic> maybe? There aren't editors though :)
11:03:50 <cow_2001> wait, why don't i have that plugin which tells me exactly which name is which
11:04:49 <hiptobecubic> exio4, doesn't moving it to the top ruin everything? I don't want failure to mean I can no longer examine the partial output
11:05:10 <cow_2001> ghc-mod does that, no?
11:06:17 <exio4> hiptobecubic: it shouldn't mean that?
11:06:26 <hiptobecubic> How is this easier than just importing modules and cleaning up later when you've got everything sorted out? You'll still have to go clean up the list anyway unless you manage to write the entire module without changing your mind about which functions you want to us.
11:06:28 <hiptobecubic> use*
11:07:22 <hiptobecubic> exio4, oh. I misread that type. I'm confused about how ExceptT works 
11:08:18 <kuribas> I normally just import qualified, especially for modules with many colliding names like Data.Vector or Data.Map
11:08:33 <exio4> hiptobecubic: the monad transformers `compose` backwards, yeah :P
11:08:53 <exio4> cow_2001: well, would you import Data.IORef qualified? and then use IORef.newIORef? 
11:09:27 <exio4> cow_2001: or Data.Dynamic as Dyn and then use Dyn.toDyn?
11:10:27 <adarqui> i think he's saying to be explicity aboutthe imports, import Control.Concurrent (IORef, newIORef) . i do what hiptobecubic says, import everything then clean up at the end
11:11:24 <monochrom> you know, I am unable to discern whether cow_2001 is really asking a question or just lamenting. in fact, I'm inclined to lamenting.
11:11:38 <cow_2001> lamenting
11:11:41 <hiptobecubic> adarqui, i understand what he's commenting on. I just don't think it's worth the overhead when you are still making drastic changes to everything. :)
11:11:47 <hiptobecubic> or she, depending
11:11:53 <monochrom> and you do not comfort a person mourning a death by a rational discussion of biology.
11:12:05 <hiptobecubic> maybe *you* don't :)
11:12:06 <adarqui> hiptobecubic: nah i was saying that to exio4.. and ya i agree with you ;f
11:12:10 <monochrom> you give them a hug and send them flowers. and then move on.
11:12:14 <hiptobecubic> I'm very popular at funerals
11:12:41 <monochrom> heh
11:12:56 <hiptobecubic> "It's ok you bought the ugly casket. In a few months everything will be worm food."
11:13:10 <cow_2001> oh god cabal install ghc-mod is taking ages ;_;
11:13:48 <cow_2001> hiptobecubic: you are invited to my funeral
11:14:53 <kuribas> When you specialize a function, do all the functions it depends on (in the module) get specialized as well?
11:15:59 <monochrom> I think you've got the whole process backwards
11:16:35 <hiptobecubic> exio4, wait. So in a stack like "StateT s m a", is 'm' at "the bottom" or the "top" ?
11:17:00 <monochrom> the compiler does not spontaneously, out of the blue, decide "let's specialize fromIntegral!" and then "oh wait, how many callers are affected?"
11:17:58 <exio4> hiptobecubic: bottom
11:18:00 <monochrom> instead, clearly, the compiler looks at a call site, finds that this call site uses fromIntegral for Int->Integer only (say), and so specialize fromIntegral for this call site
11:18:14 <monochrom> and this doesn't affect other call sites
11:18:54 <mauke> monochrom: callees, not callers
11:19:47 <monochrom> then I don't know
11:20:24 <kuribas> ok, so suppose I specialize an exported function from (Floating a) to Double, which calls non-exported functions of (FLoating a).  Then the other functions are specialized to Double as well, right?
11:21:32 <kuribas> So I can be lazy and leave out the SPECIALIZE pragmas for the not-exported functions.
11:24:43 <Gurkenglas> What libraries should one use to get the mouse/keyboard input, per-frame graphical output and being-on-a-webpage needed to make an agar.io clone?
11:25:34 <Gurkenglas> ...if it was singleplayer.
11:26:37 <bernalex> Gurkenglas: hey I'm making an agario clone in haskell lol
11:26:50 <bernalex> Gurkenglas: mine is not on a webpage though. if it were for the Web, I'd write it in elm. :)
11:27:40 <Gurkenglas> Eh, it doesn't really have to be on a webpage, that's just what the incremental game subreddit expects if they're supposed to try something out, as opposed to a download.
11:28:09 <Gurkenglas> And it's not really an agar.io clone I think, except for the first-glance look maybe and the same input/output interfaces
11:28:14 <bernalex> Gurkenglas: mine isn't on the web. it's not an agario clone either tbh. but it will very much look like one initially. I've had an idea similar to agario since long before that came. :)
11:28:17 <bernalex> Gurkenglas: haha
11:28:29 <bernalex> Gurkenglas: so we're doing the same thing but different. good to meet you. :D
11:28:36 <Gurkenglas> Except if you would call it a clone if I probably wouldn't have thought of it if I hadn't seen agar.io.
11:29:18 <Gurkenglas> I think the general ideaspace around agar.io is obvious enough that everyone's thought of something kinda like it. Hell I have.
11:29:24 <bernalex> agario was more a sort of motivation for me. "someone did almost the game I thought about -- get off your arse and do it!" :) they have some things I would do very differently though. and it's proprietary -- mine is free software.
11:29:29 <bernalex> yeah I agree
11:29:57 <bernalex> my idea originally came when I was a child and saw the aquarium screensaver for windows 95 where bigger fish gulp the smaller fish as they swim around.
11:30:07 <Gurkenglas> Is yours open source too? If I could just steal your framework, it would save a ton of trouble :P
11:30:19 <bernalex> I only have a shitty alpha (the first one) out, hehe
11:30:58 <Gurkenglas> Gimme, I'm feeling like making code suggestions right now
11:30:58 <bernalex> the only reason I pushed it out was to motivate me. public shaming is great motivation. ;) and I knew if I didn't put it online, I'd lose interest and not get back to it. so prior to my big personal mess (I'm moving, so very busy atm!), I just put what I had up, hehe.
11:31:13 <bernalex> https://github.com/plaimi/blubber-server
11:31:16 <bernalex> https://github.com/plaimi/blubber-client
11:33:49 <bernalex> I'm working on a menu clientside atm. my colleague is working on improving the udp stuff serverside. that's arguably more important, as the game is quite laggy, which is noticeable if you are a very small blub -- because then you go so fast that you react to input much more quickly, so it's really confusing.
11:35:16 <bernalex> the plans for alpha 2 are
11:35:19 <bernalex>   -AI blub
11:35:21 <bernalex>   -optimise performance
11:35:23 <bernalex>   -menus / nice way of starting the game
11:35:25 <bernalex>   -testing with AI blub & at least two players
11:35:31 <bernalex> oh, and while I have your attention, do you know about #haskell-game? some of us game devs hang out there. :)
11:36:15 <Gurkenglas> Hmk, this would probably be more ontopic there
11:36:40 <Gurkenglas> Tried #haskellgamedev and #haskellgame, then /list haskell overflowed everything on my Freenode tab ^^
11:36:44 <cow_2001> that's a good example of explicit imports https://github.com/plaimi/blubber-server/blob/master/src/Blubber/Server/World.hs
11:37:41 <cow_2001> bernalex++
11:37:44 <bernalex> cow_2001: most people give me credit for this style, which I "invented" (it's not a stroke of genius exactly, so there's probably loads of people who've done it before me) quite early on. but a lot of people hate how verbose it is. I get about an equal amount of love and hate for it. :)
11:38:48 <cow_2001> they can just search backwards for "import" and start reading from there D:<
11:39:37 <bernalex> cow_2001: it falls a bit apart when it gets to Map, Set, etc, since we don't have nice polymorphism for it like e.g. Idris has.
11:39:53 <bernalex> although some would argue that style of polymorphism makes things opaque. I would disagree but ymmv. :)
11:40:09 <Peaker> Hey, why is so much stuff crammed into the "base" package which must come with GHC and cannot coexist with other versions?  Wouldn't it be better to have "base" be as minimal as possible (or even hidden inside GHC) so that the exposed base can be installed from multiple versions simultaneously?
11:40:23 <cow_2001> bernalex: please explain?
11:40:25 <bernalex> Peaker: technical debt. too late to change that now, I feel. :)
11:41:26 <bernalex> cow_2001: in haskell you must do M.filter this and S.map that and L.foldr here and T.traverse there. it's very annoying to me. in idris no such thing is necessary. in idris I could e.g. import map from both Map and Set, and use it with just "map", and then the types decide which one is used. :)
11:41:56 <cow_2001> ah
11:41:59 <bernalex> related: I really wish there were a vim plug-in that lets me hover my mouse over an expression to get its type. or even just mark it in visual mode and hit some keybind. I envy IDE users this feature.
11:42:34 <cow_2001> bernalex: what about ghc-mod?
11:42:40 <bernalex> cow_2001: does it do this?
11:42:41 <cow_2001> bernalex: ghcmod-vim
11:42:55 <cow_2001> https://github.com/eagletmt/ghcmod-vim
11:42:57 <fabianhjr> bernalex: have you tried and IDE with vim-mode plugin and the haskell ones?
11:42:59 <bernalex> can ghc-mod tell me that the map I've imported is on Maps rather than lists?
11:43:14 <cow_2001> UGH why won't ghc-mod compile i want to die ;_;
11:43:14 <bernalex> fabianhjr: I cannot parse that sentence
11:43:25 <fabianhjr> s/and/an/
11:43:52 <cow_2001> maybe i should get a previous version?
11:44:12 <fabianhjr> https://atom.io/packages/vim-mode <- this is vim-mode for atom.io
11:44:13 <bernalex> cow_2001: oh wow it actually works
11:44:17 <bernalex> how have I never seen that in action
11:44:20 <cow_2001> bernalex: :D
11:44:24 <bernalex> but how can I use it on a big expression?
11:44:32 <bernalex> can I do it on "map foo" rather than just map or foo?
11:44:40 <cow_2001> fabianhjr: is this atom thing good
11:44:47 <fabianhjr> good enough
11:45:05 <bernalex> I thought atom was proprietary? maybe I'm misinformed
11:45:12 <silver> this is javascript desktop app
11:45:15 <silver> open source
11:45:15 <fabianhjr> No, open source. By github
11:45:15 <cow_2001> i'm waiting for peaker to die for our sins
11:45:47 <recursion-ninja> Say I have headMay :: [a] -> Maybe a from the Safe package, and I want to define indexMaybe :: Int -> [a] -> Maybe a by applying headMay "monadically" n times. Is there a nice way to use existing monadic functions to do that?
11:46:00 <fabianhjr> Good thing about atom.io is that it has become quite popular.(Along with all thr js popularity) So there is a ton of development.
11:46:12 <bernalex> cow_2001: ok it's working quite nice. this is very neat. I'm an idiot for not finding this sooner. thanks. :)
11:46:30 <cow_2001> bernalex: :D
11:46:36 <cow_2001> bernalex: it won't compile for me ;_;
11:46:48 <bernalex> cow_2001: yes there are massive problems with it :'(
11:46:50 <cow_2001> i want to cry :(
11:46:56 <bernalex> I am using 4.1.6-r1
11:46:59 <bernalex> 5 is hopeless
11:47:00 <cow_2001> how come it's... oh
11:47:04 <cow_2001> ah
11:47:18 <bernalex> cow_2001: do you still have a beard? maybe that will catch your tears. so your keyboard is safe. let it all out, man.
11:47:22 <cow_2001> cool!
11:47:30 <cow_2001> it's growing back again :/
11:47:37 <cow_2001> i hate it
11:47:44 <ski> recursion-ninja : you'd need to use a `tailMay' in that case ..
11:48:20 <bernalex> cow_2001: I have almost zero growth. I used to be frequently made fun of for it. but now I don't really have any friends, so there's no one left to make fun of me. ;)
11:48:47 <silver> :(
11:48:55 <cow_2001> bernalex: you gotta get friends
11:49:23 <cow_2001> loneliness is a health hazard
11:49:26 <ski> recursion-ninja : you could possibly use something like `foldr (>=>) return (replicate n tailMay) >=> headMay (or using `<=<', if you prefer)
11:49:47 <cow_2001> irc is the empty calories of social interaction
11:49:57 <bernalex> cow_2001: haha
11:50:25 <StrangeLoop> cow_2001!!!
11:50:36 <cow_2001> O_O
11:50:40 <cow_2001> strangleloop!
11:50:49 <cow_2001> StrangeLoop: sup!
11:51:28 <fr33domlover> hello
11:51:42 <fr33domlover> can I announce a package to the haskell@ ML?
11:51:48 <fr33domlover> without any special formatting?
11:51:53 <fr33domlover> I just never did this before
11:52:10 <bernalex> fr33domlover: I wish people didn't unless it was truly unique/important or central to our community.
11:52:24 <bernalex> but anyway just search the list archives for how other people have done it
11:56:29 <StrangeLoop> \msg cow_2001 
11:56:33 <StrangeLoop> :P
11:56:39 <cow_2001> ?!
11:56:39 <lambdabot> Maybe you meant: v @ ? .
11:56:45 <cow_2001> !?
11:58:13 <Fuuzetsu> ?type ()
11:58:14 <lambdabot> ()
11:59:22 <Peaker> ?kind ()
11:59:23 <lambdabot> *
11:59:31 <Peaker> ?sort *
11:59:31 <lambdabot> Maybe you meant: src part more
11:59:46 <fr33domlover> bernalex, I want to announce a libravatar library
11:59:52 <fr33domlover> for testing and awareness of it
11:59:59 <fr33domlover> to replace gravatar
12:00:11 <fr33domlover> where would be a good place?
12:01:14 <noteventime> fr33domlover: haskell-cafe mailing list?
12:02:11 <fr33domlover> noteventime, hmm ok, will announce there then
12:06:29 <hiptobecubic> exio4, I realized the problem
12:06:40 <exio4> hiptobecubic: \o/ 
12:06:44 <hiptobecubic> exio4, ExceptT does work, it just don't do what I want because what I want makes no sense :)
12:07:50 <exio4> hiptobecubic: heh, it happens, :P 
12:08:41 <hiptobecubic> I guess when the interpreter fails, I'm really just interested in the output from the Writer and the error message.
12:09:21 <hiptobecubic> And when it succeeds i'm only interested in the output from the Writer.
12:12:06 <hiptobecubic> And I suppose the structure doesn't really make sense. All my functions are of type (Ptr -> BrainFuck) rather than (Input -> BrainFuck)
12:12:10 <hiptobecubic> Sigh
12:12:27 <cow_2001> which version works for you, bernalex?
12:12:45 <bernalex> cow_2001: 4.
12:12:46 <lamefun> Is there some library that's like ncurses or at least allows to get terminal width/height and put colored letters?
12:12:47 <cow_2001> goddamn type errors
12:13:08 <exio4> lamefun: vty/vty-ui?
12:13:15 <cow_2001> bernalex: 4.0.0?
12:13:28 <bernalex> cow_2001: 4.x.y.z
12:13:33 <cow_2001> ding :/
12:13:35 <lamefun> thx
12:13:50 <cow_2001> i've cabal install 'ghc-mod < 5'
12:14:10 <bernalex> I am using 4.1.6 on Gentoo with no problems.
12:14:55 <exio4> cow_2001: using ghc-mod 5.2.1.2 here
12:15:42 <bernalex> doesn't 5 depend on something that makes precludes something else working, because that needs another version of the same dependency? IDR the details. I just remember it was a mess.
12:16:20 <sm> lamefun: http://hackage.haskell.org/package/ansi-terminal
12:17:00 <exio4> bernalex: I just installed it, didn't work, checked wiki, apparently some issue with new cabal and old ghc, downgraded cabal, reinstalled ghc-mod, it worked
12:17:24 <bernalex> exio4: right you must downgrade cabal? that's not really an option to me.
12:17:42 <exio4> which cabal version are you using right now?
12:17:55 <bernalex> 1.22.4.0.
12:18:55 <exio4> hm, no idea, IIRC that version switched to the binary format, which broke the hacks in ghc-mod? 
12:19:16 <exio4> maybe you are using ghc-7.10
12:19:32 <bernalex> I'm actually not. but I expect to be using it very soon.
12:29:07 * hackagebot stable-memo 0.3.1 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.3.1 (JakeMcArthur)
12:36:01 <ttt_fff> is https://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification supported in haskell cpp amcros system?
12:36:05 <ttt_fff> I can't get stringigifaciton to work
12:38:05 <mauke> what have you tried?
12:38:50 <ttt_fff> mauke: #define logAssert(X) (logAssertRaw __FILE__ (__LINE__ :: Int) (X) #X)  
12:38:55 <ttt_fff> I get error on "#"
12:38:58 <nkaretnikov> Concurrent.STM.TVar has readTVarIO but not writeTVarIO, why?
12:39:12 <mauke> I see
12:39:18 <ttt_fff> mauke: what should I be trying?
12:39:29 <mauke> that, unfortunately
12:39:50 <ttt_fff> so does haskell macro processing not support stringification? (serious question; not familiary with macros in Haskell)
12:41:51 <nkaretnikov> well, nevermind, I'll try IORefs
12:48:40 <mauke> oh god
12:48:55 <mauke> where's ttt_fff
12:50:32 <Zemyla> Hmm, question. If I have a lazy list made from arrays of increasing size, would they be better doubling in size each time, or gorwing as the Fibonacci sequence?
12:51:59 <kadoban> Zemyla: I suspect that that's nowhere near enough information to go on?
12:52:36 <Zemyla> Yeah, true.
12:54:58 <kadoban> Both are exponential growth, so it may not matter that much, possibly? Really hard to say though. Sounds interesting if you want to explain more.
12:55:52 <nkaretnikov> Zemyla: could it be that you need a different data structure?
12:55:58 <lelf> Can somebody explain why this fail: parseOnly (char 'a' <* option '?' (char 'b') *> lookAhead (char 'b')) "ab"  {- => Left "'b': not enough input" -}
12:56:11 <Zemyla> Nah, I'm just trying to figure out what would be better performance-wise.
12:56:37 <nkaretnikov> Zemyla: well, it depends on what you're doing with it
12:56:45 <mauke> it's better to grow by 1
12:56:54 <mauke> because that minimizes memory use for a list of length N
12:57:08 <Zemyla> Well, I'm trying to use it as a lazy list that supports O(log n) drop and O(1) head.
12:57:23 <Zemyla> That's why I need exponential growth of the vector.
12:57:52 <Gurkenglas> How would you drop the first 10 arrays and half of the 11th one?
12:58:13 <Zemyla> Gurkenglas: By storing an offset with each array.
12:58:27 <mauke> lelf: do you know regexes?
12:58:41 <Gurkenglas> Zemyla, then why not just store one array and one offset?
12:58:52 <lelf> mauke: yes
12:59:18 <Zemyla> Because I don't want to have to process the entire (potentially infinite) list.
12:59:36 <mauke> this roughly corresponds to ab?+(?=b)
12:59:48 <mauke> or a(?>b?)(?=b)
13:01:20 <fishburne> why does this tail recursive function run out of memory http://lpaste.net/136421
13:02:56 <mauke> it probably builds a huge structure
13:03:26 <mauke> depends on how you use it, though
13:03:42 <mauke> also on what trainNetwork does
13:03:53 <fishburne> mauke: how can I prevent it from doing so......
13:04:22 <mauke> by removing the code
13:04:55 <fishburne> mauke: I didn't get you. 
13:05:44 <lelf> mauke: ok, but I don't understand why it doesn't backtrack
13:06:01 <mauke> lelf: because parsers generally never backtrack
13:06:10 <fishburne> mauke: this is the complete code if it helps...http://lpaste.net/136423
13:09:09 * hackagebot leksah 0.15.1.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.1.0 (HamishMackenzie)
13:22:16 <fishburne> can some one please tell me why this tail recursive function run out of memory http://lpaste.net/136421
13:22:56 <mauke> fishburne: why do you think it's this function?
13:24:00 <mauke> (also, tail recursion is less relevant in a language without a call stack)
13:25:15 <fishburne> mauke: please takea look here. http://lpaste.net/136423  I have added the calls made from ghci that cause this error 
13:25:42 <hiptobecubic> exio4, Success at last!
13:25:52 <exio4> hiptobecubic: congratz! :P
13:26:00 <hiptobecubic> exio4, ended up just stuffing *everything* into state
13:26:27 <hiptobecubic> So the memory state and input both are there and most statements take no other arguments
13:27:04 <exio4> how do you handle the 'errors' or so? just stopping the "loop"? or how? :P
13:27:56 <fishburne> mauke, in line 182, I call this function. But it returns immediatly. Due to lazyness, I suppose.  In the next line, I request the weights of the resulting network returned by the previous call. This causes the errors. Again I suppose this is because it is only new the haskell tries to evaluate the result of the preceeding call
13:30:58 <hiptobecubic> exio4, assuming I understood it correctly, throwE
13:31:39 <lifter> anyone know much about esqueleto? I'm trying to write a function that reads any of my db tables and returns all of the table's contents in the form of the a Haskell list containing the corresponding Haskell types. I don't know if it is possible to write such a polymorphic function, tho
13:31:48 <exio4> hiptobecubic: ah, I see
13:33:11 <lelf> mauke: attoparsec backtracks
13:33:18 <hiptobecubic> exio4, So you end up with ((Either String (), World), Output)
13:33:22 <hiptobecubic> if you keep everything
13:33:55 <ski> hiptobecubic : not with `Either' at the outside, then ?
13:34:12 <exio4> ski: he wants the partial output to be available 
13:34:18 <hiptobecubic> ski, the point was to be able to inspect the World and Output so far if it fails
13:34:20 <exio4> hiptobecubic: I'd use a proper ADT for the errors
13:34:23 <ski> hiptobecubic : i see
13:34:49 * ski seconds exio4
13:35:20 <hiptobecubic> exio4, yeah, it would be better
13:40:47 <cow_2001> so i'm following the single sandbox many packages thing here http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
13:43:03 <mpickering> is anyone using the new container infrastructure on travis? Is it worth caching anything
13:47:28 <nkaretnikov> is there a constant I could use to determine whether my program is running on a 64-bit machine or not?
13:47:38 <nkaretnikov> with cpp, I mean
13:48:11 <cow_2001> "Note: when using a sandbox, all packages are required to have consistentdependencies. Try reinstalling/unregistering the offending packages orrecreating the sandbox."
13:48:12 <cow_2001> wat
13:49:38 <cow_2001> i don't know what to do :|
13:49:45 <nkaretnikov> cow_2001: you need to let cabal-install come up with a build plan, then install
13:50:05 <nkaretnikov> cow_2001: usually it's done by creating a .cabal file and running cabal install --only-dep
13:50:17 <nkaretnikov> or cabal install --only-dep --enable-tests if you have tests
13:50:21 <cow_2001> ooh
13:50:37 <nkaretnikov> cow_2001: you might want to look into stack.  fp complete provides consistent sets of deps for you
13:50:42 <cow_2001> i'm using both a sandbox and stackage's cabal.config
13:50:56 <nkaretnikov> I don't use it myself, so I can't tell, sorry :\
13:51:05 <cow_2001> a cabal sandbox init --sandbox /some/shared/sandbox/
13:53:46 <nkaretnikov> okay, arch_HOST_ARCH is probably what I need
13:54:19 <greymalkin> Does anyone know what Network.WebSockets (runServer) means by "real server"?
13:56:00 <lpaste> hiptobecubic revised “Brainfuck”: “Brainfuck2” at http://lpaste.net/136409
13:56:29 <hiptobecubic> exio4, ended up looking like that ^
14:01:29 <Darwin226> Hey guys. I have a problem I'd like to get help on. I have code in the Rand monad, I wrote a function manyRand :: Rand a -> Rand [a] that's more or less sequence . replicate. The problem is that I can't use the resulting Rand [a] to do more computations in Rand because, even if I only take a part of the produced list
14:01:35 <Darwin226> to bind it further I need the resulting generator passed to the next step, which has to wait for the last element in infinite list. I've solved this by splitting the generator in the manyRand
14:01:40 <Darwin226> function. This worked well, but now I want to add logging to the stack and I'm facing the same problem with the WriterT. How can I apply the same trick here with discarding the log?
14:02:11 <Darwin226> without* discarding
14:02:43 <hiptobecubic> you wait for the last element of an infinite list?
14:02:58 <Darwin226> hiptobecubic: That could take a while
14:03:19 <hiptobecubic> right, it was a question
14:03:22 <hiptobecubic> I assume not :)
14:03:42 <hiptobecubic> I think the problem is that you build up one giant action that gives you a list of a when it's done.
14:03:50 <naudiz> hey, it's me again, trying to extract the last line of a large file
14:04:08 <Darwin226> hiptobecubic: The problem is that I can manipulate the inner list as usual and only take a piece of it, but the state in the monad doesn't care how much I took, it needs to know how the whole effect chain works out so it can know what state folows
14:04:27 <hiptobecubic> hmm
14:04:41 <hiptobecubic> you have StateT s (Rand) a or something?
14:04:47 <naudiz> I just don't get it working, it always runs out of memory :( I'm doing: let str = last $ lines $ file
14:04:55 <naudiz> (in ghci)
14:05:03 <Darwin226> hiptobecubic: WriterT [String] Rand
14:05:14 <naudiz> file is: file <- readFile "filename"
14:05:14 <exio4> don't keep a reference to the head naudiz 
14:05:26 <exio4> (last . lines) <$> readFile "filename" directly 
14:05:43 <hiptobecubic> naudiz, what exio4 said ^^
14:05:57 <naudiz> exio4: can you explain the difference?
14:06:04 <hiptobecubic> naudiz, if you hang on to 'file' and tell it to read to the end, it has to keep the first and last elements around so it just hangs on to the whole list
14:06:36 <exio4> naudiz: the garbage collector can't know you don't want to access `list` anymore, thus leaving the whole file in memory 
14:06:43 <hiptobecubic> naudiz, exio4's example doesn't have an explicit reference to the file, so the garbage collector can clean up as it goes
14:06:57 <exio4> naudiz: if you make sure the list becomes garbage as long as you traverse it, the GC should do its work
14:07:08 <exio4> what hiptobecubic said :P 
14:07:21 <naudiz> so the trick is not to save the file in a string?
14:07:28 <Twey> Darwin226: Fundamentally, if you execute the action infinite times then you might have infinite logs; you can't get around that
14:07:52 <naudiz> or rather not to assign a variable to the file?
14:07:57 <Darwin226> Twey: Yeah, but I'd like to somehow tie that more tightly with how much of the actual information I take in the end
14:08:20 <hiptobecubic> naudiz, no. the trick is to make sure that once you are done with a part of the file, there is *no way* to access it again so that the GC will clean it up
14:08:23 <Twey> Darwin226: You could take the easy option of making manyRand not produce logs, i.e. require lifting into the WriterT
14:08:44 <Darwin226> Twey: In the end I feel like if I had IO instead of WriterT I could just log what ever I wanted and it would work out, wouldn't it?
14:08:56 <naudiz> I don't really get it but it seems to work, so thank you
14:08:59 <hiptobecubic> naudiz, in exio4's example, it's done by not having a reference to the file itself.
14:09:05 <Twey> Darwin226: Or you could take the slightly trickier option of attempting to keep your infinite logs separate from your finite ones, by using e.g. a ([String], [String]) for your log type
14:09:08 <ski> Darwin226 : are you attempting to use `WriterT [String] Rand' for `manyRand' as well ?
14:09:19 <Darwin226> ski: Yeah
14:09:40 <ski> Darwin226 : try `lift'ing, as Twey also suggested ?
14:09:58 <Twey> Darwin226: If you were using IO then the first execution of manyRand would never terminate
14:10:04 <hiptobecubic> naudiz, imagine I was handing you pages of a huge book and I said to you "I might need you to tell me what any page so far has said" vs "I might need you to read the last page back to me"
14:10:20 * ski . o O ( `unsafeInterleaveIO' )
14:10:26 <hiptobecubic> naudiz, in one case, you have to save everything just in case, and in the other you can throw them out as you go.
14:10:28 <Twey> ski: Shh, we dare not speak its name ;)
14:10:58 * ski thinks it's not in the same ballpark as `unsafePerformIO'
14:11:30 <ski> Twey : well, i'm only thinking it ;)
14:11:41 <Darwin226> Twey: Are you saying that (take 10 <$> (sequence . replicate (print "a" >> return 1))) would never terminate?
14:11:41 <Twey> ski: They have all the same problems.  unsafeInterleaveIO just requires that you have some IO in your program, *somewhere*, to get unsafeInterleaveIO-equivalent behaviour.
14:11:44 <hiptobecubic> naudiz, so the "trick" is to make sure you are telling the compiler to do the latter instead of the former, and you do this by not holding on to any references to earlier data that you no longer need (such as the head of the giant list in your case)
14:11:46 <Twey> Hehe.
14:12:06 <naudiz> hiptobecubic: I kind of see now why ghci is so horrible when it comes to memory consumption. I'm just to stupid to use it 
14:12:14 <Twey> Darwin226: I presume you mean ‘repeat’ rather than ‘replicate’.  And yes.
14:12:45 <ski> Twey : the latter one is much worse, you can break equational reasoning with it, and even break type safety
14:13:18 <Twey> Darwin226: Try it and see
14:14:05 <Twey> Darwin226: fmap (take 10) . sequence . repeat $ print "a" >> return 1  (FTFY)
14:14:11 <Darwin226> I see the problem is a bit deeper than I originally thought,,,
14:14:33 <Twey> ski: Can you not do the same with -Interleave-?
14:14:34 <Darwin226> Ok guys, thanks. I'll see which workaround to take
14:15:14 <Twey> ski: In both cases you can construct a situation in which you have a pure value that, on forcing, executes some IO action
14:15:32 <ski> Twey : type safety, no. equational reasoning, not imho (possibly depending on how much you have pinned down I/O semantics)
14:15:39 <Cale> btw, sequence . replicate n = replicateM n
14:15:53 <Cale> I don't know what else is going on here :)
14:15:58 <Twey> Cale: Darwin226 meant ‘repeat’
14:16:05 <Cale> ah, okay
14:16:12 <ski> Twey : you can "explain away" it as indeterminacy due to I/O (comparable to the one you get with concurrency)
14:16:18 <Cale> In that case, forever
14:16:42 <Twey> Yeah
14:20:49 <ski> Twey : if you fix a particular reduction model with forcing of thunks (and separate execution steps that interact with the world), then yes, that probably breaks. if you only talk about denotational (or axiomatic ..) semantics, then i'm not sure where it would have to break
14:23:31 <Twey> ski: Hm, yeah, I guess you're right
14:23:58 <Twey> ski: It's a bit worse than concurrency, because the value isn't necessarily determined, but no worse than concurrency+non-termination, I guess
14:24:28 <ski> Twey : anyway, i think of it as scheduling an I/O operation to possily happen (probably at most once ?) sometime in the future (in a separate "thread" if you will), and providing the future answer now ("blocking on access if not computed yet". compare with "futures" in some other languages, like e.g. Alice ML)
14:25:32 <Twey> ski: Yeah.  The problems just stem from there potentially not being a future answer ever, but having no way of handling that
14:39:29 <naudiz> how does it even come that a 250MB file needs multiple GB when read via readFile?
14:45:25 <verement> :t readFile
14:45:26 <lambdabot> FilePath -> IO String
14:46:11 <Twey> naudiz: Turns out lazy linked lists of Unicode characters aren't the best storage format for contiguous sequences of bytes
14:47:06 <Twey> Char holds arbitrary Unicode codepoints, so is at least 21 bits wide
14:47:39 <Twey> That's a 3× blow-up right there.  Plus intermediate pointers, I guess
14:48:30 <fishburne> can some one please tell me why this tail recursive function run out of memory http://lpaste.net/136421
14:48:38 <naudiz> Twey: thanks for the explanation 
14:48:54 <geekosaur> on a 64-bit platform each Char ends up taking 16 bytes (8 for constructor ID, 8 for value --- GHC doesn't work with values smaller than a machine word)
14:49:16 <geekosaur> fishburne, you keep saying tail recursive as if it is somehow relevant
14:49:42 <geekosaur> in one sense all functions in Haskell are tail recursive. in the sense you mean, it's not relevant at all
14:50:00 <geekosaur> graph reduction does not work the way you are used to thinking
14:51:05 <geekosaur> also, I don't see where your recursion bottoms out
14:51:23 <geekosaur> oh wait, duh
14:52:16 <geekosaur> I don;t think there's enough there to know where you're building up stuff though
14:52:26 <Gurkenglas> Running cabal install -j in a subfolder of a folder where cabal sandbox init was run will still count as installing it into that sandbox, right?
14:54:06 <Welkin> Gurkenglas: cabal must be able to see the sandbox
14:54:17 <Welkin> .cabal-sandbox directory
14:54:46 <Welkin> I think yuo need to run the commands from whever the .cabal-sandbox is located
14:54:57 <Twey> naudiz: The alternative with sane memory usage is either ByteString (for meaningless bytes) or Text (for human-readable text), of course
14:54:58 <Welkin> wherever*
14:56:09 <Welkin> there may be a flag/option to specify where a sandbox is located though
14:56:14 <Welkin> you'd have to check the docs
14:57:31 <Welkin> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
14:57:37 <Welkin> there is some informatin on shared dandboxes there
14:57:44 <Welkin> sandboxes*
14:58:16 * geekosaur has been known to symlink .cabal-sandbox and cabal.sandbox.config into the subdir (which is arguably evil)
14:59:13 * hackagebot Quickson 0.2 - Quick JSON extractions with Aeson  http://hackage.haskell.org/package/Quickson-0.2 (ssadler)
15:16:52 <fishburne> geekosaur: here is the full code if it helps http://lpaste.net/136423
15:18:59 <testingmystuff> https://www.youtube.com/watch?v=wQMNLLMKPJ4
15:22:12 <quxbam> is there something like performUnsafeIO, but without the asumption, that the result can be cached?  Is it possible to do "real" io in a pure context?
15:25:03 <shapr> @seen bonus
15:25:03 <lambdabot> bONU$
15:25:05 <shapr> aww
15:25:38 <benzrf> @last bonus
15:25:38 <lambdabot> No module "bonus" loaded
15:25:42 <benzrf> pff
15:26:45 <Welkin> shapr: the @seen module was disabled
15:26:58 <benzrf> why, Welkin
15:26:58 <geekosaur> quxbam, it is not, caching comes from purity
15:27:14 <geekosaur> or rather the potential for caching does
15:27:15 <Welkin> benzrf: int-e  said it was something about instability
15:28:06 <quxbam> geekosaur: ok, thanks
15:28:12 <benzrf> huh
15:29:07 <nikki93> hey guys
15:29:09 <geekosaur> they tried reactivating ti recently and lb went rather weird/unstable, yeh
15:29:30 <nikki93> I'm working through cis194 for teh lulz (mostly to learn haskell), and I was working homework 3, which is 'code golf' to write as short stuff as possible
15:29:50 <nikki93> wondering what you think of my solution for 'histogram' -- code here: https://github.com/nikki93/cis194/blob/master/03-rec-poly/main.hs#L14 , problem statement here: http://i.imgur.com/AMnwzSI.png
15:34:49 <hodapp> this hcoop thing that kuribas pointed out earlier is interesting...
15:34:57 <hodapp> I don't totally understand what it is, but it uses SML for configuration?
15:35:00 <hodapp> Dr. Harper would be proud, I'm sure
15:37:48 <hiptobecubic> There's a pretty intense community of haskell haters out there. I guess Haskell is finally popular :)
15:38:06 <nikki93> lel
15:39:13 <fishburne> is there a way to forcefully evaluate an expression (non-lazy, and discard the intermediate structure) in haskell?
15:39:46 <Welkin> add bangs
15:40:47 <fishburne> Welkin: isnt that for data definitions only?
15:41:05 <adamse> fishburne: seq will evaluate
15:41:38 <hiptobecubic> fishburne, no, also works on pattern matches with {-# LANGUAGE BangPatterns #-}
15:42:27 <mniip> fishburne, by "forcefully evaluate an expression" do you mean bring it to normal form?
15:42:32 <mniip> or weak-head normal form?
15:44:03 <fishburne> mniip: I am not sure. I have this function which runs out of memory when it is evaluated....
15:44:15 * hackagebot buffer-builder 0.2.4.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.4.0 (chadaustin)
15:44:32 <fishburne> mniip: http://lpaste.net/136423 line 153
15:44:37 <mniip> that could mean a lot of things
15:45:02 <fishburne> mniip: at the bottom you will see the calls in ghci that lead to the error
15:47:02 <mniip> fishburne, sounds like Neuron and Layer should use arrays instead of lists
15:47:09 <mniip> because list!!n is O(n)
15:47:24 <mniip> might even consider unboxed lists
15:47:36 <mniip> because your datatype is prim-able
15:48:19 <fishburne> mniip: prim-able?
15:48:26 <Axman6> can be unboxed
15:48:40 <Axman6> using lists for this sort of work is extremely inefficient
15:49:18 <mniip> fishburne, unboxed arrays by the way would automatically solve the strictness issue
15:49:45 <Axman6> 9if that is actually an issue)
15:50:51 <fishburne> mniip, Axman6, but can you tell me what is going on...I understand it is because it builds some kind of big structure. But I cannot see how...
15:51:11 <mniip> fishburne, also a lot of your code can be simplified with predicates
15:51:25 <Axman6> fishburne: I don't have the few hours required to figure that out ;)
15:51:37 <ski> fishburne : do you know `foldl' ?
15:51:50 <mniip> er
15:51:55 <fishburne> Axman6: Oh. no problem. I didn't think it was that involved ....
15:52:01 <mniip> fishburne, also a lot of your code can be simplified with combinators
15:52:02 <fishburne> ski: yes
15:52:21 <nikki93> @pl \d -> length $ filter (== d) ns
15:52:21 <lambdabot> length . flip filter ns . (==)
15:52:31 <ski>      foldl (*) 1 [1,2,3,4,5]
15:52:40 <ski>   =  foldl (*) (1 * 1) [2,3,4,5]
15:52:48 <ski>   =  foldl (*) ((1 * 1) * 2) [3,4,5]
15:52:50 <nikki93> @pl \c -> if c >= n then '*' else ' '
15:52:50 <lambdabot> flip (flip if' '*' . (>= n)) ' '
15:52:55 <ski>   =  foldl (*) (((1 * 1) * 2) * 3) [4,5]
15:52:56 <JamesJRH> Hi. Is anyone here using a Haskell shell instead of something like Bash?
15:53:01 <nikki93> wow
15:53:06 <ski>   =  foldl (*) ((((1 * 1) * 2) * 3) * 4) [5]
15:53:14 <ski>   =  foldl (*) (((((1 * 1) * 2) * 3) * 4) * 5) []
15:53:21 <ski>   =  ((((1 * 1) * 2) * 3) * 4) * 5
15:53:26 <ski>   =  (((1 * 2) * 3) * 4) * 5
15:53:30 <ski>   =  (((2 * 3) * 4) * 5
15:53:36 <ski>   =  ((6 * 4) * 5
15:53:41 <ski>   =  24 * 5
15:53:44 <ski>   =  120
15:54:08 <fishburne> mniip: can you  please show an example,..
15:54:16 * hackagebot MonadStack 0.1.0.1 - Generalizing lift to monad stacks  http://hackage.haskell.org/package/MonadStack-0.1.0.1 (bhurt)
15:54:18 * hackagebot MonadStack 0.1.0.2 - Generalizing lift to monad stacks  http://hackage.haskell.org/package/MonadStack-0.1.0.2 (bhurt)
15:54:19 <ski> fishburne : using an accumulator that isn't forced at each step, you build a giant expression that eats memory, and is only evaluated at the end
15:54:32 <mniip> fishburne, for example, trainLayer (Layer neurons) dact input lerrors = Layer $ zipWith (trainNeurons dact input) neurons lerrors
15:54:43 <ski> fishburne : that *could* be a problem with your code
15:54:44 <fishburne> ski yes, i get that...Oh. you mean, I use list as an accuminator?
15:55:17 <ski> fishburne : in your case `network', which it stepped by `trainNetwork' in `trainedNetworkForInputs', is your accumulator
15:55:28 <fishburne> ski: that I use lists to return results...?
15:55:55 <mniip> also reading this let-bound code is really hard
15:56:00 <mniip> you should invest into some where-bindings
15:56:57 <fishburne> mniip:I am  pretty new to haskell. 3 weeks or so....
15:57:13 <JamesJRH> ski: I've just joined the conversation but what you are talking about reminds me of this: https://wiki.haskell.org/Foldr_Foldl_Foldl%27
15:57:26 <JamesJRH> Was that with fishburne?
15:57:34 <Natch> how do I alias :T to :t in ghci?
15:58:51 <ski> Natch : try `:def T \s -> return (":type " ++ s)' ?
15:59:30 <Natch> ski: thanks
16:00:59 <benzrf> Natch: def takes a function from arg string to an io operation that returns a new string to execute in the ghci
16:00:59 <fishburne> ski: thanks for that demonstration.
16:04:50 <ski> fishburne : unrelated, but `trainLayers' is always passing a `Just' in the recursive call. i'd attempt to see if i could separate the two cases (preferably without duplicating code)
16:05:25 <ski> fishburne : `makePatternFromString' can be written using `map'
16:05:34 <Cale> fishburne: Yeah, it really does look like this is happening with trainedNetworkForInputs. It calls itself repeatedly, building up a gigantic expression which looks something like  (trainNetwork (trainNetwork (trainNetwork ...) ...) ...)
16:06:00 <Cale> Without ever forcing the evaluation of that expression, because it doesn't pattern match on it or use seq/bang patterns
16:07:26 <sbrg> Natch: not a bad idea
16:07:29 <sbrg> I might do that
16:11:36 <JamesJRH> Is anyone here using a Haskell shell instead of something like Bash? How can I start using a Haskell shell? Which one should I use?
16:11:51 <JamesJRH> Also, can I make its interface work in a similar manner to this?: http://pengines.swi-prolog.org/apps/swish/
16:12:18 <kqr> is there a way to get ... prettier pretty printing with TH? the pprint function includes module prefixes and variable suffixes which aren't very nice to read (ex. "GHC.Classes.not x_1627409646" where the code said "not x")
16:14:47 <JamesJRH> Things that I like about that interface is that running a command never locks the input while the command is running and commands have their own scrollable output window which can be deleted, paused, etc..
16:15:14 <JamesJRH> And minimised but not deleted.
16:15:23 <ghost_runner> high guys. would i learn more from SICP as a beginner than i would using haskell or c?
16:15:31 <JamesJRH> Those things would be soooo useful!
16:16:03 <Axman6> ghost_runner: depends what you want to learn. that's a pretty odd question though
16:17:15 <ghost_runner> Axman6: what are the applications of both (learning from SICP or C)? fyi, i'm interested in robotics and stuff like that
16:18:31 <Axman6> then perhaps you should learn abhout robotics :P What background do you have? Are you inteterested in directly controlling hardware or do you want to make machines think?
16:18:40 <Urchin[emacs]> ghost_runner: good materials for learning haskell are hard enough to find as it is
16:20:34 <ghost_runner> Axman6: tough question. do you mean ai in regards to "making machines think"? i'm quite interested in both (robotics and ai), if that's the case
16:21:48 <Axman6> do you have any programming experience?
16:22:04 <Welkin> robotics has little to do with programming
16:22:29 <Welkin> and has everything to do with mechanics
16:22:35 <Welkin> the programming is just incidental
16:22:45 <ghost_runner> Axman6: i'm reading the first chapter of SICP and know how to define functions in scheme
16:23:12 <ski> ghost_runner : have you found the videos as well ?
16:23:28 <Axman6> the videos are pretty fun
16:23:38 <ghost_runner> ski: the lectures?
16:23:44 <ski> yep
16:23:47 <ghost_runner> yeah
16:24:36 <ghost_runner> i thought c was associated with robotics due to its low-level nature
16:26:56 <Twey> ghost_runner: What makes you think robotics requires low-level code?
16:27:00 <orion> In aeson, if I receive JSON like this: {"result": ...}, how do I save whatever the value of "result" is without parsing, and then make it available unchanged if the data structure is re-encoded?
16:28:05 <Welkin> Twey: because of embedded systems
16:28:50 <ghost_runner> Twey: robots are programmed, are they not?
16:28:53 <Welkin> orion: what?
16:29:05 <Welkin> orion: you need to parse it, otherwise it is just a bytestring
16:29:34 <Twey> ghost_runner: They require code, to be sure
16:30:03 <mniip> Twey, depends on the definition of "require"
16:30:04 <orion> Welkin: I don't want to convert it to a specific type.
16:30:17 <mniip> sure there's some low-level code involved
16:30:19 <orion> What I'm doing currently is converting it to a "Value" type prodiced by aeson.
16:30:25 <mniip> any high-level structure is supported by low-level code
16:30:39 <orion> Unfortunately, when I try to reencode it, my application does not respond.
16:30:42 <mniip> whether running in an embedded system or on a regular computer
16:30:45 <orion> (The thread stops)
16:30:48 <Twey> mniip: Well, yes, but that's not usually the robot-specific code one needs to write
16:31:18 <Welkin> orion: you should be able to turn Valuei nto anything you want
16:31:20 <Welkin> into*
16:31:49 <Axman6> I think he wants to avoid using Value at all
16:32:16 <Axman6> just knowinf that there is an already encoded value at key "result" and accessing that value without decoding it
16:32:33 <orion> Welkin: I *don't* want to convert it to anything in particular.
16:33:01 <orion> I just want it to remain a Value until I want to generate JSON again.
16:33:16 <Axman6> oh, that's easy then
16:34:14 <Axman6> orion: using aeson-lens, it would just be bs ^? key "result" :: Maybe Value I think
16:34:23 <Axman6> assuming you actually weant the parsed Value
16:34:58 <Axman6> > import Data.Aeson.Lens
16:34:59 <lambdabot>  <hint>:1:1: parse error on input ‘import’
16:35:02 <Axman6> :(
16:35:18 <ski> @let import Data.Aeson.Lens
16:35:18 <lambdabot>  .L.hs:62:1:
16:35:18 <lambdabot>      Failed to load interface for ‘Data.Aeson.Lens’
16:35:18 <lambdabot>      Perhaps you meant
16:35:43 <Axman6> > "{\"result\":1}" ^? Data.Aeson.Lens.key "result" :: Maybe Value
16:35:44 <lambdabot>  Not in scope: ‘Data.Aeson.Lens.key’Not in scope: type constructor or class ‘...
16:35:50 <Peaker> aeson-lens doesn't make the key be a lens of Maybe (like "at") instead of an affine traversal (like "ix")?  It means you need more APIs to add/remove keys!
16:35:51 <Axman6> :(
16:36:24 <Axman6> eh?
16:36:25 <Peaker> Axman6: it's from a string, and not from an Aeson.Value?
16:37:08 <Axman6> key works on any AsValue type, which includes String and ByteString
16:37:10 <Peaker> > M.empty & at 'x' .~ Just 123 & at 'y' .~ Just 456
16:37:12 <lambdabot>  fromList [('x',123),('y',456)]
16:37:13 <Axman6> as well as Value
16:37:26 <Peaker> Axman6: ah, that's a little nuts! :)
16:37:38 <Axman6> https://hackage.haskell.org/package/lens-aeson-1.0.0.3/docs/Data-Aeson-Lens.html handeh though =)
16:38:11 <Peaker> it would be more sane to have a parse/build prism so you do   "string here" ^? json . key ".."    so the "json" part is a prism and the "key" part is a lens (to a Maybe)
16:39:06 <Peaker> lens is all about composition, so it's a bit weird to throw all that magic into "key" rather than composing with a parser prism
16:39:42 <Axman6> most of the combinators work on AsValue's
16:39:56 <Axman6> I've never used anything but the Value isntance actually
16:40:25 <Axman6> there's also a _JSON prism
16:41:42 <Peaker> Axman6: where? not in http://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html ?
16:42:01 <Peaker> oh, the edwardk one! :)
16:42:11 <Axman6> yes =)
16:43:08 <Peaker> there's _Value :: Prism' t Value
16:43:37 <Peaker> that's what I referred to, but I guess he wanted that auto-fused into all the other traversals for convenience
16:43:46 <Peaker> but then he loses the nice vocabulary shrinkage of "at"
16:44:19 <orion> Ok, here's a better question: I am writing a Scotty application, and when I attempt to use aeson to encode an object in to JSON, the thread stops, and is eventually killed by Wrap's reaper. What's the best way to debug this issue?
16:44:29 <phylene> say I have a source file Foo.hs, and I build it as a library package using cabal
16:44:37 <phylene> how can I make it so it is accessable as
16:44:39 <phylene> import Foo
16:44:46 <phylene> i mean not that
16:44:49 <phylene> import Data.Foo
16:44:56 <phylene> or import Control.Foo or whatever 
16:51:42 <Welkin> phylene: name the module Data.Foo
16:58:46 <phylene> Welkin: I tried that, it didn't owrk
16:58:57 <phylene> you could still only import it as Foo
16:59:13 <Welkin> put it in a directory Data
16:59:19 <Welkin> Data/Foo.hs
16:59:22 <phylene> tried that too
16:59:30 <phylene> same thing
16:59:47 <phylene> compiling with exposed-modules: Data.Foo
17:03:03 <Iceland_jack> "M.empty & at 'x' .~ Just 123 & at 'y' .~ Just 456" can be written with (?~) for the record
17:03:03 <Iceland_jack> > M.empty & at 'x' ?~ 123 & at 'y' ?~ 456
17:03:04 <lambdabot>  fromList [('x',123),('y',456)]
17:03:47 <Iceland_jack>     a ?~ b = a .~ Just b
17:14:07 <c_wraith> :t (?~)
17:14:08 <lambdabot> ASetter s t a (Maybe b) -> b -> s -> t
17:14:15 <c_wraith> Ah
17:14:52 <c_wraith> that kind of seems weirdly specialized
17:15:05 <shachaf> It's useful for things like at
17:15:20 <shachaf> > M.fromList [('a',1)] & at 'b' ?~ 2
17:15:20 <c_wraith> It seems like at is about 90% of its use cases
17:15:21 <lambdabot>  fromList [('a',1),('b',2)]
17:15:41 <shachaf> Well, at is really a collection of different use cases.
17:16:08 <shachaf> "at and things like at". Anywhere where you have a lens onto a value that might be deleted or created.
17:30:41 <yayfoxes> product :: [Integer] -> Integer
17:31:15 <yayfoxes> product (x:xs) = x * product xs
17:31:28 <yayfoxes> is that a proper product function?
17:31:41 <yayfoxes> opps
17:31:42 <Iceland_jack> yayfoxes: What happens with "product []"
17:31:50 <yayfoxes> Iceland_jack: yeah that
17:32:00 <Iceland_jack> It is otherwise
17:32:05 <yayfoxes> add this above the second line and it's ok: product [] = 1
17:32:33 <uwap> > foldl (*) 1 [2,3]
17:32:34 <lambdabot>  6
17:32:35 <maerwald> @src product
17:32:35 <lambdabot> product = foldl (*) 1
17:32:36 <Iceland_jack> It can go below as well
17:33:16 <yayfoxes> > let product' [] = 1 in let product' (x:xs) = x * product xs in product' [2,3,4]
17:33:17 <lambdabot>  24
17:33:30 <yayfoxes> > let product' [] = 1 in let product' (x:xs) = x * product' xs in product' [2,3,4]
17:33:32 <lambdabot>  *Exception: <interactive>:3:28-60: Non-exhaustive patterns in function product'
17:33:41 <yayfoxes> erm a little help please?
17:33:41 <maerwald> I wonder why that is a left fold
17:34:06 <Twey> yayfoxes: Those are two different product' functions
17:34:06 <uwap> maerwald, why should it be right fold? 
17:34:08 <Welkin> yayfoxes: let x = 4 in x
17:34:11 <Twey> yayfoxes: One shadowing the other
17:34:25 <Iceland_jack> yayfoxes: 
17:34:26 <Iceland_jack>     > let product' [] = 1; product' (x:xs) = ...
17:34:35 <yayfoxes> Twey: crap then how do I make it all one functions?
17:34:48 <Welkin> yayfoxes: it is all one function
17:34:50 <Twey> > let product' [] = 1; product' (x : xs) = x * product' xs in product' [2, 3, 4]
17:34:51 <lambdabot>  24
17:34:53 <Iceland_jack> You write a semicolon instead of the second "in let"
17:34:59 <yayfoxes> ok
17:35:04 <maerwald> uwap: why should it be left fold?
17:35:09 <Welkin> if it has the same name, it is the same function
17:35:35 <yayfoxes> can we define qsort so I can modify it to make a reverse sorted version of a list instead?
17:35:46 <Twey> Welkin: You are confused
17:35:51 <Twey> yayfoxes: Of course, but you don't need to
17:35:54 <yayfoxes> that way Cale and I will be happier
17:36:16 <uwap> maerwald, arbritrary. it is equal for commutative functions.
17:36:31 <maerwald> uwap: obviously
17:36:33 <Welkin> Twey: ?
17:37:07 <Twey> Welkin: Since they belong to different lets, the two clauses define two separate partial functions, not one total function
17:37:14 <Welkin> oh, no
17:37:16 <uwap> maerwald, I guess foldl is more commonly used, but I'm not too sure about this
17:37:18 <Welkin> I was talking about top-level
17:37:28 <Twey> Ah
17:37:28 <maerwald> uwap: I am pretty sure it's the other way around
17:37:34 <Twey> yayfoxes was confused by the lets, I think.
17:37:34 <yayfoxes> > let qsort [] = []; qsort (x : xs) = qsort smaller ++ [x] ++ qsort larger where smaller = [a | a <- xs, a <= x]; larger = [b | b <- xs, b > x]
17:37:35 <lambdabot>  <no location info>:
17:37:36 <lambdabot>      not an expression: ‘let qsort [] = []; qsort (x : xs) = qsort smaller ++...
17:37:39 <ski> uwap : associative with neutral element. finite lists
17:37:50 <yayfoxes> Twey: I'm still confused
17:38:00 <yayfoxes> the lets are confusing me
17:38:04 <uwap> ski? 
17:38:08 <Twey> yayfoxes: Your definition is correct, but lambdabot requires that you type an expression
17:38:17 <Twey> yayfoxes: In this case, something of the form let … in …
17:38:34 <Welkin> yayfoxes: don't use let
17:38:41 <Welkin> yayfoxes: do not write programs in ghci
17:38:42 <yayfoxes> > let qsort [] = []; qsort (x : xs) = qsort smaller ++ [x] ++ qsort larger where smaller = [a | a <- xs, a <= x]; larger = [b | b <- xs, b > x] in qsort [3,5,1,2,7]
17:38:44 <lambdabot>  [1,2,3,5,7]
17:38:48 <maerwald> shouldn't "foldr (*) 1 [0..]" actually short circuit or do I expect too much of (*) here
17:38:51 <Welkin> if it is more than one line, write it in a file and save it as .hs
17:38:53 <ski> uwap : `foldr (+) z [a,b,c] = a + (b + (c + z))', `foldl (+) z [a,b,c] = ((z + a) + b) + c'
17:39:02 <yayfoxes> > let qsort [] = []; qsort (x : xs) = qsort larger ++ [x] ++ qsort smaller where smaller = [a | a <- xs, a <= x]; larger = [b | b <- xs, b > x] in qsort [3,5,1,2,7]
17:39:04 <lambdabot>  [7,5,3,2,1]
17:39:04 <Welkin> then run it using runhaskell, or load it into ghci for testing
17:39:08 <yayfoxes> WOW
17:39:13 <yayfoxes> HOW FUN!
17:39:32 <Iceland_jack> :) I love hearing someone enjoy learning Haskell
17:39:38 <ski> yayfoxes : abstract out the comparision, and flip it around
17:40:01 <maerwald> > foldr (*) 1 [0..]
17:40:03 <lambdabot>  *Exception: stack overflow
17:40:05 <maerwald> mh
17:40:12 <Twey> It's already abstracted out, of course
17:40:33 <uwap> > foldr (*) 0 [1..]
17:40:34 <lambdabot>  *Exception: stack overflow
17:40:35 <Twey> Since (<=) and (>) are generic
17:40:47 <Cale> yayfoxes: Did you need me for something?
17:41:00 <Twey> You can use the ‘Down’ newtype to reverse the ordering on a type
17:41:01 <yayfoxes> Cale: oh no, I'm just having fun reading your book and learning haskell
17:41:03 <maerwald> Cale: do you know why it doesn't short circuit? :P
17:41:04 <uwap> > foldl (*) 0 [1..]
17:41:08 <lambdabot>  mueval-core: Time limit exceeded
17:41:15 <Cale> It's not really my book, it's Graham Hutton's book :)
17:41:24 <uwap> interesting
17:41:26 <Welkin> maerwald: uwap: I believe it has to do with the fact that (+) and (*) require their parameters to be fully evaluated
17:41:28 <Cale> maerwald: Why what doesn't? Multiplication?
17:41:37 <maerwald> > foldr (*) 1 [0..]
17:41:38 <lambdabot>  *Exception: stack overflow
17:41:53 <Cale> > 0 * undefined
17:41:55 <lambdabot>  *Exception: Prelude.undefined
17:41:58 <Cale> > undefined * 0
17:41:59 <lambdabot>  0
17:41:59 <maerwald> yeah, how unfortunate
17:42:01 <maerwald> wat
17:42:04 <maerwald> :D
17:42:04 <Twey> > let qsort [] = []; qsort (x : xs) = qsort smaller ++ [x] ++ qsort larger where smaller = [a | a <- xs, a <= x]; larger = [b | b <- xs, b > x] in map (\(Down x) -> x) . qsort $ map Down [3,5,1,2,7]
17:42:05 <lambdabot>  [7,5,3,2,1]
17:42:07 <Cale> heh, which type is that?
17:42:21 <yayfoxes> how do I use where?
17:42:22 <Cale> > undefined * 0 :: Integer
17:42:24 <lambdabot>  0
17:42:28 <Cale> whaaaaaa
17:42:32 <Cale> Since when?
17:42:33 <yayfoxes> the "where" keyword
17:42:34 <maerwald> uhm
17:42:35 * Twey blinks.
17:42:37 <maerwald> my ghci shows Num
17:42:42 <Cale> @undefine
17:42:42 <lambdabot> Undefined.
17:42:44 <Cale> > undefined * 0 :: Integer
17:42:45 <lambdabot>  0
17:42:51 <Cale> Fair enough?
17:42:54 <Cale> that's interesting
17:42:57 <Twey> That's nice
17:43:06 <maerwald> it doesn't work here :/
17:43:06 <Twey> Strange choice of argument, though
17:43:14 <maerwald> ghc 7.10?
17:43:16 <Twey> maerwald: With the type annotation?
17:43:27 <maerwald> undefined * 0 doesn't work in my ghci at all
17:43:29 <Welkin> > undefined + 3
17:43:30 <lambdabot>  *Exception: Prelude.undefined
17:43:34 <Welkin> > undefined + 3 :: Integer
17:43:36 <lambdabot>  *Exception: Prelude.undefined
17:43:37 <Cale> yayfoxes: Well, is there something in particular you'd like to know about it? You attach it to a declaration, and put a bunch of function/value declarations inside it, lining them up vertically
17:43:41 <Welkin> > undefined * 3 :: Integer
17:43:42 <lambdabot>  *Exception: Prelude.undefined
17:43:53 <Welkin> > 3 * undefined
17:43:55 <lambdabot>  *Exception: Prelude.undefined
17:44:03 <_slade_> > undefined + 0 :: Integer
17:44:04 <lambdabot>  *Exception: Prelude.undefined
17:44:15 <Cale> maerwald: I wouldn't expect it to, but it appears to in 7.10.1
17:44:32 <Cale> Very interesting
17:44:35 <maerwald> > foldr (flip (*)) 1 [0..]
17:44:36 <lambdabot>  0
17:44:37 <maerwald> LOL
17:44:40 <Twey> It's weird that there is no Data.Ord.unDown
17:44:47 <maerwald> this is crazy
17:45:34 <Welkin> > foldr (flip (*)) 1 [3..]
17:45:35 <maerwald> so the first argument is lazy
17:45:36 <lambdabot>  *Exception: stack overflow
17:45:37 <ski> > foldr (++) [] [[0 .. n-1] | n <- [0 ..]]
17:45:39 <lambdabot>  [0,0,1,0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,4,5,0,1,2,3,4,5,6,0,1,2,3,4,5,6,7,0,1...
17:45:40 <ski> > foldl (++) [] [[0 .. n-1] | n <- [0 ..]]
17:45:45 <lambdabot>  mueval-core: Time limit exceeded
17:45:45 <lambdabot>  mueval: ExitFailure 1
17:45:46 <ski> uwap ^
17:45:49 <yayfoxes> Cale: let me see if I'm getting this where stuff straight
17:45:55 <yayfoxes> if it compiles it's fine
17:46:05 <Welkin> > foldr (flip (*)) 1 [1..]
17:46:06 <lambdabot>  *Exception: stack overflow
17:46:09 <Welkin> > foldr (flip (*)) 1 [0..]
17:46:10 <lambdabot>  0
17:46:15 <Welkin> it only works with 0
17:46:19 <maerwald> ofc^^
17:46:24 <maerwald> how else can it work
17:46:46 <uwap> ski, why is that? o. o
17:47:07 <MarcelineVQ> 0*x = 0
17:47:36 <Welkin> MarcelineVQ: yes, but this must be a new optimization in ghc
17:47:36 <maerwald> Cale: we need to get to the bottom of this
17:47:39 <ski> uwap : `foldl' is tail-recursive, it won't stop until it reaches the base case (the end of the list). it is "bulky", while `foldr' can be incremental (depending on the function argument)
17:47:57 <yayfoxes> What would be the effect of replacing ≤ by < in the definition of qsort ? Hint: consider the example qsort [2, 2, 3, 1, 1].
17:48:24 <uwap> ski, ah. right. dualities.
17:48:33 <maerwald> @src (*)
17:48:33 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:48:38 <maerwald> :o
17:48:38 <Welkin> hahaha
17:48:44 <maerwald> what the...
17:48:47 <Welkin> that is the best insult from lambdabot I have heard yet
17:48:51 <yayfoxes> well, I dunno Cale , I'm not very skilled in math or programming, but here goes
17:49:13 <ski> > 0 `min` undefined :: Natural
17:49:15 <lambdabot>  0
17:49:22 <exio4> maerwald: is this defined enough for you? (I# x#) * (I# y#) = I# (x# *# y#) :D
17:49:27 <maerwald> argh
17:49:29 <exio4> it's for Int though!
17:49:57 <Iceland_jack> it's "plusInteger" from GHC.Integer no?
17:50:00 <yayfoxes> maybe it sticks 2 first? I dunno
17:50:04 <ski> @src () (*)
17:50:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:50:10 <yayfoxes> can we discuss this further?
17:50:16 <Iceland_jack> https://hackage.haskell.org/package/integer-gmp-0.5.1.0/docs/src/GHC-Integer-Type.html#plusInteger
17:50:38 <Iceland_jack> There is a "isTrue# (c ==# 0#)" check
17:51:23 <maerwald> someone should kick lambdabot for these insults :P
17:52:18 <Iceland_jack> 'plusInteger' uses GHC.Prim.addIntC# which has this comment "Add with carry. First member of result is (wrapped) sum; second member is 0 iff no overflow occured."
17:52:37 <ski> @keal
17:52:38 <lambdabot> with KealDigit quantum crackproof encryption possible
17:52:53 <maerwald> > 0 `div` undefined
17:52:54 <lambdabot>  *Exception: Prelude.undefined
17:53:07 <maerwald> > 0 / undefined
17:53:08 <lambdabot>  *Exception: Prelude.undefined
17:53:17 <ski> > 15 `mod` 0
17:53:19 <lambdabot>  *Exception: divide by zero
17:53:20 <ski> :(
17:53:24 <Welkin> anything divided by 0 is undefined
17:53:26 <Welkin> er
17:54:01 <ski> > 0 `gcd` 0  -- otoh, ...
17:54:02 <lambdabot>  0
17:54:51 <maerwald> Welkin: that depends on the axioms
17:55:01 <maerwald> but most of the time yes
17:55:28 <anonymous_guppy> between python and haskell, which is best for beginner?
17:55:40 <maerwald> anonymous_guppy: for...?
17:55:49 <Welkin> anonymous_guppy: take waste your time with python
17:55:58 <Welkin> haskell is fine for beginners, and worth the extra effort up front
17:55:58 <anonymous_guppy> beginning programming
17:56:09 <Welkin> haskell makes you a much better programmer
17:56:17 <Welkin> it guides you along and helps you when you mess up
17:56:19 <Welkin> python does not
17:56:37 <anonymous_guppy> hmm. noted.
17:56:39 * ski also suggests Scheme, with SICP
17:57:11 <yayfoxes> ok Cale , it considers something less than the middle item to be equal
17:57:34 <yayfoxes> or man, translating it into english really messes me up
17:58:11 <anonymous_guppy> ski: sicp?
17:58:12 <Welkin> anonymous_guppy: start with the UPenn course
17:58:18 <Welkin> @where learnhaskell
17:58:18 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:58:32 <Welkin> that is a list of the best resources for beginners learning haskell
17:59:02 <Welkin> anonymous_guppy: you can also joined #haskell-beginners for additional help with the material
17:59:06 <Welkin> join*
17:59:20 <maerwald> anonymous_guppy: python is much more widely used, has more libraries, tutorials and whatnot and gives a pretty good introduction in different programming paradigms (imperative, OOP). It's also easier to learn than haskell. On the other hand... it doesn't teach you anything about what a purely functional lazy language like haskell can do.
17:59:50 <ski> anonymous_guppy : <http://community.schemewiki.org/?SICP>
18:00:02 <maerwald> so I don't really know what to recommend. Check on both and see what fascinates you more
18:00:07 <ski> @where SICP
18:00:08 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
18:00:11 <anonymous_guppy> maerwald: i'm not to concered with ease. i just want language that will make me a better programmer in long run
18:00:16 <Welkin> I recommend starting with haskell
18:00:50 <exio4> anonymous_guppy: there's no doubt that between Python and Haskell, Haskell will make you a better programmer in the long run 
18:01:14 <Welkin> I would argue that python will make you a *Worse* programmer
18:01:19 <Peaker> Welkin: why?
18:01:20 <ski> anonymous_guppy : at some point, you might also like checking out logic programming. which almost certainly means Prolog
18:01:42 <exio4> I was going to suggest that Haskell is not the only way, and that other languages can be good for learning PL concepts
18:01:49 <Welkin> Peaker: it lets you mess up without telling you, and do things in terrible ways that may work, but are still horrible
18:02:02 <ski> @where CTM
18:02:02 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
18:02:08 <Peaker> Welkin: Python is not too lenient on errors, it doesn't ignore them, it just catches them late
18:02:32 <ski> is a cool book, that teaches several paradigms, including logic programming, using a language called Oz (Mozart is the implementation)
18:02:35 <maerwald> people are exaggerating again. Python is an ok language
18:02:44 <Iceland_jack> Second maerwald 
18:03:02 <exio4> maerwald: as long as you don't care about broken scoping ... ;) 
18:03:04 <Welkin> not in my experience
18:03:16 <Welkin> but I feel the same way about any dynamically typed language
18:04:26 <Iceland_jack> Haskell should be a good enough language not to have to poo-poo other languages when you recommend it imo
18:05:19 <maerwald> Welkin: The type system only catches type errors. That's not even a fraction of all possible errors/bugs you can program. It's a huge advantage
18:05:20 <hpc> it's just an easy comparison to make because python and haskell are opposites in pretty much every way you can observe
18:05:25 <maerwald> but not everything
18:06:06 <anonymous_guppy> ski: so do you say scheme with sicp over haskell for beginner to learn?
18:06:09 <ski> anonymous_guppy : .. at some point, you should also take a look at low-level programming (to round out your understanding of such things). preferably some (hopefully not horrible) assembler. also compilers. but you probably shouldn't hurry to do this
18:06:47 <ski> anonymous_guppy : i'm not sure. try both, and see which seems most fun at the time ? having fun is important for learning
18:07:26 <yayfoxes> anonymous_guppy: I'm loving Haskell. Want a book?
18:07:29 * ski encountered Haskell before Scheme
18:07:37 <maerwald> if I had to start over and could send me a message through time I would tell myself to learn languages this order: shell -> C -> prolog -> haskell
18:07:47 <yayfoxes> anonymous_guppy: if so just ask Cale
18:08:28 <ski> (i also started with BASIC, and then assembler, so perhaps i'm broken ?)
18:08:46 <yayfoxes> ski: no you're older
18:09:26 <exio4> I started with Pascal because I heard it was good for beginners :P 
18:09:40 <Iceland_jack> I started with Visual Basic :)
18:09:49 <maerwald> exio4: did you use that turtle thingy to draw stuff?
18:10:34 <ski> oh, i did a little Logo in second class or something as well .. almost forgot that
18:11:15 <gfixler> I typed BASIC in from a book to my dad's Tandy ColorComputer 2
18:11:30 <ski> (someone stole the school computers, so we couldn't continue :/ )
18:11:33 <gfixler> (not understanding any of it)
18:11:37 <exio4> maerwald: no, that's Logo
18:11:46 <maerwald> exio4: Logo?
18:11:46 <exio4> ski: wow, that's sad
18:12:05 <exio4> maerwald: the "turtle thingy to draw stuff" :P 
18:12:24 <maerwald> exio4: it is pascal what I mean
18:12:42 <maerwald> there was an extension for it
18:12:46 <maerwald> or somesuch
18:12:56 <exio4> never heard of it then 
18:13:24 <maerwald> http://www.philocomp.net/programming/turtlepascal.htm
18:13:31 <gfixler> Apparently Logo was a dialect of Lisp, and a FP lang
18:13:43 <ski> yes
18:13:56 <gfixler> well, Logo was multi-paradigm
18:14:00 <maerwald> so, how did we derail that much? :o
18:15:31 <exio4> maerwald: join #haskell-blah!
18:16:02 <anonymous_guppy> why is lisp and its family called hackers language
18:16:25 <hpc> because lispers tried really hard for 40 years to make people call it that
18:16:58 <hpc> (also because at the time, it was true)
18:19:21 * hackagebot hledger-lib 0.26 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.26 (SimonMichael)
18:19:23 * hackagebot hledger 0.26 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.26 (SimonMichael)
18:19:26 * hackagebot hledger-web 0.26 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.26 (SimonMichael)
18:19:34 <hiptobecubic> If I use "Writer String" as a log, it's going to be slow as balls isn't it? Is it using (++) ?
18:20:20 <ski> depends on whether you're left-nesting
18:20:31 <ski> perhaps use `Endo String' ?
18:21:42 <ski> (and, yes, it's `mappend')
18:22:09 <linman32> in hxt, how does one check if a tag has two attributes of given values?
18:23:49 <hiptobecubic> I don't see how Endo works
18:24:03 <hiptobecubic> you define a function from your type to itself and it composes them?
18:24:06 <ski> it uses `(.)' instead of `(++)'
18:24:16 <exio4> hiptobecubic: are you familiar with `difference lists`?
18:24:30 <hiptobecubic> i was just about to say, "so difference lists?"
18:24:45 <hiptobecubic> I am familiar with them but haven't implemented them
18:24:46 <linman32> ok, problem solved. nm
18:24:51 <hiptobecubic> so "familiar"
18:25:27 <ski> instead of `((as ++ bs) ++ cs) ++ ds' you get something like `(((as ++) . (bs ++)) . (cs ++)) . (ds ++)', which is better
18:25:29 <hiptobecubic> > ('a':) . ('b':) . id $ []
18:25:30 <lambdabot>  "ab"
18:26:06 <anonymous_guppy> what is lambda? i thought it was a half life (game) concept
18:26:48 <ski> anonymous_guppy : it's a random greek letter chosen to express a function value (not necessarily named)
18:27:02 <hiptobecubic> It's also a delicious farm animal.
18:27:43 <ski> anonymous_guppy : in Haskell, `\x -> ..x..' is the approximation of the mathy `λ x. ..x..'
18:28:31 <ski> anonymous_guppy : `\x -> x^2 + 1' is "the function that, when given an input (call it `x'), yields the square of `x', incremented by one"
18:29:25 <ski> anonymous_guppy : if you want to give it a name, you can say `f = \x -> x^2 + 1'. `f x = x^2 + 1' is a shorthand notation for this (in math, one'd write `f(x)' instead of `f x')
18:29:59 <ski> anonymous_guppy : if you're only going to use a function once, then often you don't bother with giving it a name
18:30:14 * ski idly wonders whether this makes any sense at all to anonymous_guppy
18:30:24 <anonymous_guppy> ski: aaah
18:31:06 <maerwald> > (\x -> x^2 + 1) 3
18:31:07 <lambdabot>  10
18:31:33 <ski> > map (* 10) [0,1,2,3]
18:31:35 <lambdabot>  [0,10,20,30]
18:31:41 <ski> > map (\x -> x^2 + 1) [0,1,2,3]
18:31:43 <lambdabot>  [1,2,5,10]
18:32:03 <hiptobecubic> My brainfuck interpreter is apparently very slow :(
18:32:10 <ski> `map' takes a function, and a list, and "runs" the function on every element of the list, collecting the results into a new result list
18:32:41 <ski> `(* 10)' is the function that multiplies by ten. it is a shorthand for `\x -> x * 10'
18:33:01 <exio4> hiptobecubic: profiling! care to link to the code (and test .bf) again? 
18:33:27 * ski stares at anonymous_guppy
18:33:57 <anonymous_guppy> why r u doing that
18:34:04 <anonymous_guppy> stop it
18:34:22 * hackagebot higher-leveldb 0.3.0.0 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.3.0.0 (jeremyjh)
18:34:23 <ski> i'm wondering if your following, or if anything is unclear
18:34:32 <ski> s/your/you're/
18:34:36 <hiptobecubic> exio4, I'm looking at the profiling output now. It isn't cabalized at the moment either :(
18:35:20 <exio4> hiptobecubic: wah! I normally start an ad-hoc cabal project with its own sandbox as I do import Data.Map or Data.Set :p 
18:36:36 <lpaste> hiptobecubic revised “Brainfuck”: “Brainfuck3” at http://lpaste.net/136409
18:36:58 <hiptobecubic> exio4, started out as a coding challenge on a website
18:37:53 <hiptobecubic> The only nonstandard import is Hspec, you can just comment it out if you need
18:38:26 <ski> > let  squareThenAddOne x = x^2 + 1  in  map squareThenAddOne [0,1,2,3]  -- anonymous_guppy, you *can* name the function like this, but often you can't think of any very natural name. sometimes no name at all is better (more readable) than a (mostly useless) name
18:38:28 <lambdabot>  [1,2,5,10]
18:38:57 <hiptobecubic> exio4, basically it spends most of its time allocating garbage in the two sets of incr and decr functions it seems
18:40:28 <hiptobecubic> It does some silly things like rereading and re-composing all of the functions inside Loop terms each time it gets to one (although it can run the loop multiple times without doing so)
18:42:13 <hiptobecubic> For never having implemented a compiler of any kind before, this went surprisingly well I must say. Only took a day
18:42:43 <hiptobecubic> Granted it does no optimization whatsoever, but it *does* run and produce correct results as far as I can tell
18:44:55 <hiptobecubic> Some simple things like collapsing repeated incr and decr operations would help, but that's kind of a different problem.
18:45:21 <yayfoxes> hiptobecubic: teach me! What would be the effect of replacing <= with < in the definition of qsort? Consider the example input list of [2,2,3,1,1]
18:46:26 <hiptobecubic> None. qsort is pure and integers are all indistinguishable from one another :)
18:46:36 <hiptobecubic> (integers of equal value)
18:47:41 <ski> yayfoxes : try it, form a hypothesis, and reason why it is so ?
18:47:46 <yayfoxes> hiptobecubic: teach me in math why it is?
18:47:59 <yayfoxes> ski: I need to be taught the scientific method
18:48:09 <silver> yayfoxes, this affects stability
18:48:14 <yayfoxes> ski: I never tried it
18:48:16 <hiptobecubic> "in math", it isn't, for the reasons i just mentioned.
18:48:26 <yayfoxes> AH
18:48:27 <hiptobecubic> in practice, it will affect stability as silver mentioned
18:48:35 <silver> https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
18:50:01 <ski> hiptobecubic : it has an effect
18:50:03 <yayfoxes> hiptobecubic: I think I get it now
18:50:22 <yayfoxes> I wish you could view my raw brainwaves and see that yes, he gets it
18:55:53 <JamesJRH> Has anyone here tried Turtle?
18:58:30 <JamesJRH> Does the author of http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html come in here?
18:58:58 <exio4> JamesJRH: I am using it for some scripts on my computer
18:59:44 <anonymous_guppy> java vs haskell
18:59:50 <exio4> JamesJRH: and I know he does, I don't know how often though, someone else may know
19:00:00 <JamesJRH> Nice.
19:01:08 <JamesJRH> exio4: I'm looking to switch from Bash to a Haskell shell, and in the process I want to revamp the whole workflow. (I hate the current workflow.)
19:01:27 <rcyr> anonymous_guppy: Java is more accessible... Haskell is nicer.
19:02:32 <exio4> JamesJRH: well, Turtle is more for writing scripts than as an interactive shell
19:02:56 <jasonkuhrt> Are there any long-time Haskellers here who can talk to the growth of this channel's activity?
19:03:00 <jasonkuhrt> Just curious
19:03:22 <jasonkuhrt> like change from 2005 -to 2015 
19:03:48 <peddie> jasonkuhrt: http://ircbrowse.net/haskell
19:03:48 <JamesJRH> exio4: Currently I type a command and it does something, but my prompt disappears until the command finishes, or I have to use Ctrl-Z and Bash's job control, which is cumbersome and alos doesn't help the output from being messy.
19:04:31 <JamesJRH> exio4: A better way is how it is done here: http://pengines.swi-prolog.org/apps/swish/
19:05:11 <jasonkuhrt> peddie: Awesome
19:05:13 <jasonkuhrt> thanks
19:05:29 <JamesJRH> exio4: For scripts, I tend to start off with commands, and as they grow I decide to put them in a file.
19:05:48 <lisk> is there anyway to make this function typeable? http://pastebin.com/ipJkBTL2
19:06:11 <JamesJRH> Well, a file /other/ than my history file. :-)
19:06:32 <JamesJRH> s/file/files/
19:07:21 <exio4> JamesJRH: I try to keep my .sh files in the <25LOC range, as soon as I start getting past that soft limit, I start looking for alternatives, so, our workflows are a bit different :) 
19:07:26 <JamesJRH> I have a pretty nifty history system. I save each Bash session in its own history file.
19:07:47 <JamesJRH> My too.
19:07:50 <JamesJRH> Me*
19:08:25 <elben> Why do I projects import things “as X”, example: https://github.com/NICTA/course/blob/master/src/Course.hs
19:08:27 <JamesJRH> But if I was using Haskell from the start then I wouldn't even need that soft limit.
19:10:00 <dibblego> elben: it groups a number of modules into one module, which gives a user the option of importing all those modules as one import.
19:10:05 <anonymous_guppy> why is java so popular and haskell not?
19:10:09 <anonymous_guppy> doesnt java blow?
19:10:23 <ski> lisk : `liftO :: (forall f. f a -> f b) -> HList f a -> HList f b' is probably not useful, i suppose ..
19:10:24 <elben> dibblego: perfect, thansk
19:14:17 <lisk> ski: i thought something using constraint kinds might work, but i haven't been able to come up with anything. i've got a bunch of zippy functions written with specific constraints (num, traversable, etc) and i want to factor out the recursion into a single function, but i dunno if it's possible :(
19:15:05 <ski> lisk : yes, i was going to suggest adding a restraining constraint, but i got distracted
19:17:28 <ski> lisk : something like `data HList (c :: (* -> *) -> Constraint) :: [* -> *] -> * -> * where HCons :: c f => f a -> HList c fs a -> HList c (f ': fs) a; HNil  :: HList c f a' and `liftO :: (forall f. c f => f a -> f b) -> HList c fs a -> HList c fs b', perhaps .. or separately claiming that every `f' in `fs' satisfies `c f', maybe
19:18:00 <JamesJRH> exio4: What is Gabriel Gonzalez's IRC nick?
19:18:07 <anonymous_guppy> ski: how long would it take me to understand all of that?
19:19:30 <ski> anonymous_guppy : hm, this is relatively advanced type hackery. more than a year, i suppose ..
19:19:53 <anonymous_guppy> i have 2 months of pure free time. how much do you think i could learn then?
19:19:58 <ski> anonymous_guppy : Java has more funding and hype
19:20:17 <bob_twinkles> also a much lower learning curve
19:20:22 <ski> and momentum, because it has a bigger community
19:21:01 <lisk> i was thinking of moving the constraints into the data type, but sometimes the constraints are over the specific (f a)'s and sometimes just f's, and it seemed a little brittle
19:21:05 <ski> anonymous_guppy : the basics, at least
19:21:17 <exio4> JamesJRH: Tekmo? I think? 
19:22:05 <ski> anonymous_guppy : in case you've not seen it before, check out <http://norvig.com/21-days.html>
19:22:34 <lisk> though i can just keep writing the recursion manually for each instance declaration i need to write; it's just a little boilerplatey
19:22:37 <bob_twinkles> lisk: from what I've seen it's generally frowned upon to have constraints like "data ConstrainAllTheThings a => SomeType a = ..." (also you can't even write that without GHC telling you you're a bad person)
19:23:55 <bob_twinkles> instead you write "data SomeType a = ..." and only export stuff like "mkSomeThing :: (Eq a) => ParamType1 -> ParamType2 -> SomeType a"
19:23:56 <ski> bob_twinkles : i don't think that's what lisk meant
19:24:14 <ski> (icbwb ..)
19:25:33 <exio4> when you are doing type hackery, having existential types + constraint kinds + type families seems pretty ok :P 
19:26:21 <bob_twinkles> *reads more context* nope, probably not. I've been staring at TH all day and now my brain is a bit fried =P
19:26:46 <bob_twinkles> (spending 6 hours writing code to save 15 minutes of copy/paste sounds about right)
19:27:12 <lisk> haha. that's pretty much what the problem is
19:28:01 <lisk> every use i have of the function will have some specific constraint, and it's easily typeable with a specific constraint and type families
19:28:27 <JamesJRH> exio4: Okay, thanks. I've searched and found someone referring to Tekmo pointing to his blog, so it must be right. Last seen on NickServ 2015 Jun 20 21:38:07, so I'll send a memo via MemoServ.
19:28:56 <lisk> JamesJRH: yeah, i know that's his reddit user
19:29:55 <ski> Tekmo seems to be connected at the moment
19:30:25 * ski idly wonders whether lisk is related to liskell
19:30:36 <JamesJRH> Oh?
19:30:47 <lisk> ski: kind of. i just needed something to put in as a nick and liskell came to midn
19:30:49 <lisk> *mind
19:31:51 <ski> JamesJRH : idle over three weeks
19:33:23 <JamesJRH> /who says there is someone with the nick Tekmo so I think they mustn't have identified to NickServ.
19:33:49 <ski> hm. you're right
19:33:52 <JamesJRH> ski: Indeed, that's what NickServ says.
19:34:28 <ski> (could have been an auto-reconnect i suppose. or maybe someone else sitting on the nick)
19:38:18 <exio4> hiptobecubic: btw, checking at the code, getMem / setMem, have you checked lens? 
19:38:47 <anonymous_guppy> ski: what books 4 leanring haskell?
19:39:10 <JamesJRH> Yep. I've messaged them. When they reply, that might reveal the answer (though the latter can't necessarily be ruled-out without Gabriel identifying to NickServ).
19:39:16 <JamesJRH> ski: ↑
19:39:48 <ski> anonymous_guppy : i used "Haskell: The Craft of Functional Programming". there are others that people seem to like as well
19:40:40 <ski> anonymous_guppy : oh .. i also hung around on this channel :)
19:41:31 <anonymous_guppy> ski: will that book do for a complete noob?
19:44:20 <ski> anonymous_guppy : i think so (though i already knew some programming before). <https://github.com/bitemyapp/learnhaskell> (suggested on #haskell-beginners) apparently recommends starting with the Craft, for people new to programming
19:44:21 <JamesJRH> anonymous_guppy: I use the Wikibook. I haven't read all of it though because I like to read pages as I need them.
19:45:33 <bob_twinkles> there's "Learn You a Haskell for Great Good" and "Real World Haskell", though I think there is some out of date information in both
19:45:34 <ski> anonymous_guppy : please refer to this channel (or that one) if there's anything unclear, when you're learning. (you can also use the mailing lists, i suppose)
19:46:01 <ski> anonymous_guppy : one can also learn stuff here by lurking, and attempting to figure out what others are talking about
19:47:34 <ski> anonymous_guppy : .. and, in case you want to frequent this channel, you may (at least after a while) want to use a proper IRC client, instead of a web-based one
19:49:26 <ski> @wiki Books
19:49:26 <lambdabot> http://www.haskell.org/haskellwiki/Books
19:49:30 <JamesJRH> anonymous_guppy: I don't know how it compares because I haven't read all of any Haskell book, but I find the Wikibook easy to referrence. Also, where books refer to previous chapters, at least with a Wikibook it has a link straight to the relevant page.
19:49:35 <ski> anonymous_guppy : that ^ has a list of some more books
19:52:49 <ski> some people like "The Haskell School of Expression", some Bird's book. i've also seen talk about Hutton's book, and "The Haskell Road to Logic, Maths, and Programming"
19:52:58 <ski> @wiki Learning Haskell
19:52:58 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
19:53:00 <yayfoxes> guys, where's Hugs, the most widely used implementation of haskell?
19:53:01 <ski> has some more info
19:53:10 <yayfoxes> I have Arch Linuc
19:53:12 <yayfoxes> Linux*
19:53:23 * hodapp looks at yayfoxes
19:53:50 <ski> @where HuGS
19:53:50 <lambdabot> http://haskell.org/hugs
19:53:53 <rcyr> yayfoxes: Is there anyone who uses hugsÉ
19:53:54 <rcyr> ?
19:54:01 <ski> HuGS is no longer in development
19:54:13 <rcyr> yayfoxes: That's like saying that Windows Phone is the most popular mobile phone on the market.
19:55:00 <hodapp> rcyr: well, Hugs once was rather popular, and has mostly only been called Hugs, whereas Windows Phone never was popular and has been known under a dozen different names.
19:55:53 <rcyr> True that.
19:56:09 <yayfoxes> lol hodapp , rcyr : it's in package hugs98
19:56:26 <rcyr> yayfoxes: These days, only GHC exists.
19:56:30 <yayfoxes> ok
19:56:40 <hodapp> you can build Hugs all you want, though; the source is out there.
19:56:48 <yayfoxes> how do I run a haskell program as a script?
19:56:50 <hodapp> but it doesn't support a lot of 'modern' Haskell stuff.
19:56:56 <yayfoxes> that's basically what I'd use hugs for
19:57:02 <_slade_> yayfoxes: runghc
19:57:24 <yayfoxes> ok I need caffeine
19:57:24 <exio4> runhaskell
19:57:57 <yayfoxes> I wish it were possible to send an email with a soda description and the robot just makes it and serves it up in a coffee cup
19:58:07 <hodapp> x_X
19:58:18 <hodapp> Just brew some tea. It'll clear you head a bit while you make it.
19:58:29 <yayfoxes> ok :)
19:58:38 <hodapp> did you get caught in a time machine or something, and come back to 2015 looking for Hugs?
19:59:24 <exio4> well, asking for hugs in a public place sure sounds weird
19:59:31 <exio4> maybe asking a friend..
19:59:58 <hodapp> I've seen 'free hugs' folks around before
20:04:26 * hackagebot aeson-better-errors 0.9.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.9.0 (hdgarrood)
20:05:04 <ttt_fff> anyone here doing data mining in haskell?
20:05:11 <yayfoxes> hodapp: yes, Hutton's book Programming in Haskell was the quartz time crystal that sent me back in time
20:05:29 <yayfoxes> see, it's Back To The Future part 2
20:09:04 <ttt_fff> anyone here doing data mining in haskell?
20:13:40 <pavonia> ttt_fff: Why are you asking?
20:14:10 <ttt_fff> pavonia: I want to see if there is a way to do data mining in haskell instead of matlab
20:15:48 <pavonia> There are libraries for that: https://hackage.haskell.org/packages/#cat:Data%20Mining
20:16:07 <hodapp> yayfoxes: ah, I have not read that book.
20:29:27 * hackagebot rubberband 0.1.0.2 - Binding to the C++ audio stretching library Rubber Band  http://hackage.haskell.org/package/rubberband-0.1.0.2 (mtolly)
20:32:55 <Jafet> @hoogle Maybe [a] -> [a]
20:32:56 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
20:32:56 <lambdabot> Prelude cycle :: [a] -> [a]
20:32:56 <lambdabot> Data.List cycle :: [a] -> [a]
20:33:54 <yayfoxes> hodapp: ok, I drank two coffee cups full of tea
20:34:05 <yayfoxes> I'm buzzed and am happier for it
20:34:41 <yayfoxes> @src reverse
20:34:41 <lambdabot> reverse = foldl (flip (:)) []
20:34:46 <nitrix> Jafet: That's a common transformation. Anything more precise in mind?
20:34:52 <yayfoxes> let's discuss the reverse function
20:34:58 <yayfoxes> how do you make it faster?
20:35:28 <rcyr> yayfoxes: Perhaps by using foldr... but I'm a noob so...
20:35:44 <yayfoxes> there's another way to optimize it
20:35:57 <yootle> coffee cups full of tea?
20:36:07 <yootle> like a tea cup full of tea?
20:36:33 <yayfoxes> yeah, 8 fl. oz each of tea
20:36:37 <yayfoxes> per cup
20:36:56 <yayfoxes> or is it 7 fl oz. per cup of tea
20:36:57 <Jafet> :t Foldable.fold :: Maybe [a] -> [a]
20:36:58 <lambdabot> Not in scope: ‘Foldable.fold’
20:37:03 <Jafet> :t Data.Foldable.fold :: Maybe [a] -> [a]
20:37:04 <lambdabot> Maybe [a] -> [a]
21:19:29 * hackagebot jammittools 0.5.0.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.5.0.1 (mtolly)
21:41:48 <bkolera> (Lemme know if this is better suited to #ghc) Does anyone here know the tradeoffs in building ghc 7.10.1 on centos6 (gmp 4.3.1 + glibc 2.12) from source? There's no binary distribution and I'm wondering if it is better to be on a slightly dodgy 7.10.1 or properly released 7.8.4? We're a bit off upgrading to centos7, so it'll hurt if we are stuck on the 7.8.4
21:41:48 <bkolera> stack till the end of the year from a haskell dependency point of view. :(
21:48:12 <turrentfunction> Can cool, dynamic games be written in Haskell?
21:53:35 <Zearen> Can someone explain to me how to pass a Lens' as an argument?
21:53:40 <yayfoxes> hey guys, I'm going to read that book again
21:53:50 <yayfoxes> playing video games isn
21:53:55 <yayfoxes> isn't as much fun
21:55:11 <benzrf> Zearen: you can enable rank2types, or you can accept ALens'
21:55:29 <Iceland_jack> Zearen: Pass it ALens'
21:55:50 <benzrf> Zearen: ALens' is a cool hack
21:56:16 <Zearen> Oh, I see.
21:56:21 <benzrf> Zearen: basically it's a monomorphic type that a Lens' will specialize to, but it turns out that that particular specialization doesnt actually lose anything
21:56:24 <benzrf> and you can get a Lens' back out
21:56:54 <Zearen> I don't need that kind of power, but it's good to know.
21:57:36 <benzrf> its not really /power/
21:57:36 <Iceland_jack> If you want to get the lens back use 'cloneLens'
21:57:37 <Iceland_jack>     cloneLens :: ALens' s a -> Lens' s a
21:57:39 <Zearen> Thanks ^^ (I haven't worked with these since Data.Lens and they seem to have grown... complex).
22:03:51 <yayfoxes> I'm tired so erm...what do I do to stay awake?
22:03:55 <yayfoxes> I need to stay up
22:04:02 <rcyr> Coffee
22:04:12 <yayfoxes> I have no coffee
22:04:23 <yayfoxes> and coffee tastes like tin foil
22:04:28 <rcyr> Tea?
22:04:36 <yayfoxes> Tea mmmm...
22:04:38 <yayfoxes> ok
22:04:45 <yayfoxes> More tea!
22:05:13 <zedbourbaki> yayfoxes: play tetris. or 2048. or something ridiculously simple and addictive.
22:11:31 <yayfoxes> when it turns to 8am I'm gonna get me some sode
22:11:38 <yayfoxes> it's a new slang word for soda
22:12:22 <yayfoxes> what if we all wrote a genetic algorithm based on a base soda recipe do you like it yes / no / maybe and got rich?
22:12:32 <yayfoxes> we'd all have soda brands
22:12:58 <yayfoxes> if you guys managed that can I have $10 per week to buy that soda?
22:13:18 <yayfoxes> how do you do genetic algorithms in haskell?
22:13:40 <peddie> yayfoxes: https://hackage.haskell.org/package/moo-1.0/docs/Moo-GeneticAlgorithm.html
22:44:42 <eds> Am I using Either in a wrong way? http://lpaste.net/136444
22:44:52 <eds> Line 21
22:45:48 <jle`> eds: on line 53, you say eval(FlaotExp num) = num
22:45:56 <jle`> but num is a Float
22:46:02 <jle`> you need an `Either Int Float`
22:46:25 <eds> I know. but it gives me an error for eval (IntExp num) = num, too
22:46:35 <jle`> yeah, in that case, num is an Int
22:46:41 <jle`> but you need an Either Int Float
22:46:50 <jle`> luckily, there is a function that takes any Float into an Either Int Float
22:47:01 <jle`> it's called Right :: Float -> Either Int Float
22:47:11 <jle`> and there's also Left :: Int -> Either Int Float
22:47:21 <jle`> which gives you values of the type you need :)
22:48:49 <eds> I see. that worked. :D
22:48:54 <jle`> :D
22:49:02 <eds> jle` thanks
22:49:09 <jle`> 'Either Int Float' isn't a special syntactic construct that lets you use either an Int or a Float
22:49:16 <jle`> it's just a normal data type that you can define yourself
22:49:21 <eds> didnt know about right and left
22:49:25 <jle`> data Either e a = Left e | Right a
22:49:33 <jle`> do you know about ADT's?
22:49:36 <jle`> like Maybe?
22:49:44 <jle`> data Maybe a = Nothing | Right a
22:49:52 <jle`> er, Just a
22:49:59 <jle`> data Maybe a = Nothing | Just a
22:50:31 <jle`> it means that: for a type `Maybe Int`, there are two ways to have a value:  You can have 'Nothing', or you can have 'Just x', where x is an Int
22:50:31 <eds> oh so if I wanted to have choose between Int Float String [List] Bool. Should I define one myself like
22:51:00 <jle`> so for Either Int Float, there are two ways to have a value:  You can have 'Left x', where x is an Int, or 'Right y', where y is a Float
22:51:27 <eds> data Either = one Int | two Float | three String | four [List] | five Bool ?
22:51:49 <eds> Yea I know Maybe. I see. that made sense.
22:51:53 <jle`> yeah, but you should probably call it something other than Either, because there's already a type called Either in prelude :)(
22:51:56 <jle`> :)
22:51:58 <jle`> might be confusing
22:52:08 <jle`> also, constructors (one, two, three) have to be capitalized
22:52:13 <jle`> but you get the idea
22:52:36 <jle`> data MySum = MSInt Int | MSFloat Float | MSString String | MSFour [List] | MSFive Bool
22:52:39 <eds> yea I know. Name it data Option.
22:52:43 <jle`> assuming you had a data type somewhere called List
22:53:22 <eds> I have not made it yet. How about I import Data.List and use that?
22:53:30 <jle`> there is no type called List in Data.List
22:53:37 <jle`> we have [a], which is a list of a's
22:53:50 <eds> yea that would work :D, right?
22:54:04 <ski>   data Exp = EInt IntExp | EFloat FloatExp | EList ListExp | EArith ArithExp | EComp CompExp  -- perhaps ?
22:54:26 <eds> and a could be any type! so any type of list would work. 
22:54:29 <jle`> eds: yeah, it depends on what you want to do.  and you can't really have a useful "polymorphic list" in a data type like that...you'd have to parameterize your data type on it
22:54:40 <jle`> data MySum a = ... | MSList [a] | ...
22:54:51 <ski> eds : btw, you're not using GADTs .. did you mean to use it yet ?
22:55:04 <jle`> you can't really do data MySum = ... | MSList [a] | ... in a useful way
22:55:17 <jle`> because if you have a MySum and you pattern match on MSList, how would you know what type is in the list?
22:55:23 <eds> ski: but I need my eval to turn IntExp/FloatExp to Int and Float that I can output.
22:55:28 <jle`> it could be anything :O
22:55:37 <eds> No I am not using GADT.
22:55:39 <zipper> What can I get that is similar to forkGhcProcess that is not from the unix package?
22:56:27 <jle`> you can do something like MySum = ... | MSList [MySum] | ..., so it'd be like, recursive and stuff.  but it really depends on what you want
22:56:45 <eds> jle` : oh yeah that made sense. So what should be my take on this.
22:56:51 <jle`> just, if you want to have it be a polymorphic list, you'd probably want to paramaterize the data type on it
22:57:02 <jle`> well, i really don't know what you want to do
22:57:06 <jle`> those are just some options :)
22:57:50 <ski> using GADT, it might look something like
22:57:52 <ski>   data Exp :: * -> *
22:57:54 <ski>     where
22:59:18 <ski>     EInt   ::            IntExp   -> Exp Int
22:59:37 <ski>     EFloat ::          FloatExp   -> Exp Float
22:59:55 <ski>     EList  ::           ListExp a -> Exp [a]
23:00:45 <joncol> I want to add a HUnit test for when a parsec parse fails with a ParseError (parse returns Left ParseError with some source location). I don't want to have to specify the source location in my unit test. Is there a nice way of testing for an error without having to know the exact source location?
23:00:46 <ski>     EArith :: Num a => ArithExp a -> Exp a
23:01:09 <ski>     EComp  :: Ord a =>  CompExp a -> Exp Bool
23:01:44 <eds> ski: that seems like a good idea *_*
23:03:00 <ski> with `data ListExp a = MkListExp [Exp a]',`data ArithExp a = Add (Exp a) (Exp a) | Sub (Exp a) (Exp a) | Mul (Exp a) (Exp a)' and `data CompExp a = Eq (Exp a) (Exp a) | Lt (Exp a) (Exp a | Gt GenExp Exp a)'
23:03:22 <ski> er, last one should be `data CompExp a = Eq (Exp a) (Exp a) | Lt (Exp a) (Exp a) | Gt (Exp a) Exp a)'
23:05:53 <ski> eds : oh, and you'd get `eval :: Exp a -> a'
23:11:20 <ski> eds : getting anywhere ?
23:11:42 <eds> ski: yeah the eval confuses me. So, data Exp, data ListExp, data ArithExp and data CompExp. And then eval function with type Exp a -> a for all these data, right?
23:14:32 <ski> eds : yep
23:14:34 * hackagebot uhttpc 0.1.1.0 - Minimal HTTP client library optimized for benchmarking  http://hackage.haskell.org/package/uhttpc-0.1.1.0 (HerbertValerioRiedel)
23:15:20 <eds> ski: Let me try that real quick and I'll get back to you.
23:38:40 <eds> ski: what should be kind signature for data Exp? umm something like this data Exp :: GenExp -> * ?
23:43:27 <ski> eds : see above ?
23:44:25 <eds> data Exp :: * -> * ?
23:45:52 <eds> ski
23:56:24 <yayfoxes> guys, where is a syntax error in all of this? N = a `div` length xs where a = 10; xs = [1,2,3,4,5]
23:57:40 <rowanblush> yayfoxes: I think the capital N at the beginning?
23:57:56 <yayfoxes> second syntax error must be the things around div
23:58:07 <yayfoxes> didn't actually write it out here how they had it
23:58:29 <yayfoxes> oh, and a = 10; is supposed to be on the same column as xs = ...
23:58:38 <adarqui> use hastebin/lpaste
23:58:40 <adarqui> ;)
23:58:55 <rowanblush> Yes, please post the actual code somewhere.
