00:01:42 <julianleviston> sweet… so uncurry ((,) Just) is what I wanted. great! thanks both.
00:01:51 <julianleviston> sorry uncurry ((,) . Just)
00:01:59 <dramforever> hmm...
00:02:17 <dramforever> I just noticed that there's a "Votes" thing on hackage
00:02:22 <dramforever> anyone know what it is?
00:06:22 <haskelltroll> yeah, it allows people to vote packages up/down
00:06:56 <arkeet> :t uncurry ((,) . Just)
00:06:57 <lambdabot> (a, b) -> (Maybe a, b)
00:06:58 <dramforever> haskelltroll: so so you have any more info on it?
00:07:03 <arkeet> :t first Just
00:07:04 <lambdabot> (b, d) -> (Maybe b, d)
00:07:16 <dramforever> julianleviston: ^
00:07:24 <dramforever> first is from Control.Arrow
00:07:29 <arkeet> where first is from eithr Control.Arrow or Data.Bifunctor
00:07:38 * hackagebot gtk3-mac-integration 0.3.1.1 - Bindings for the Gtk/OS X integration library.  https://hackage.haskell.org/package/gtk3-mac-integration-0.3.1.1 (HamishMackenzie)
00:07:38 * hackagebot gtk-mac-integration 0.3.1.1 - Bindings for the Gtk/OS X integration library.  https://hackage.haskell.org/package/gtk-mac-integration-0.3.1.1 (HamishMackenzie)
00:07:51 <dramforever> oh yeah if your are on 7.10 you should use Data.Bifunctor
00:08:34 <julianleviston> dramforever: ah.
00:08:39 <dramforever> =)
00:08:48 <arkeet> :t over _1 Just
00:08:49 <lambdabot> Field1 s t a (Maybe a) => s -> t
00:08:54 <arkeet> oops.
00:08:59 <arkeet> :t over _1 Just :: (a,b) -> (Maybe a,b)
00:09:00 <lambdabot> (a, b) -> (Maybe a, b)
00:09:04 <arkeet> lens :-)
00:09:17 <arkeet> :t over _2 Just :: (a,b,c,d) -> (a,Maybe b,c,d)
00:09:18 <lambdabot> (a, b, c, d) -> (a, Maybe b, c, d)
00:10:10 <julianleviston> dramforever: wasn’t there mention that Control.Arrow is obsolete yesterday? or did I misunderstand? I thought perhaps Functors had “eaten their lunch” or something?
00:10:11 <dramforever> btw I found this amusing
00:10:17 <julianleviston> I’m probably up the garden path.
00:10:28 <dramforever> > ((), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), ())
00:10:30 <lambdabot>      No instance for (Show
00:10:30 <lambdabot>                         ((),
00:10:30 <lambdabot>                          (),
00:10:39 <lispy> julianleviston: not everyone likes arrows, but that's nothing new.
00:11:02 <dramforever> julianleviston: it can't be, if so tell me what supersedes it
00:11:03 <julianleviston> lispy: is it a case of many ways to skin a rabbit?
00:11:09 <julianleviston> dramforever: I wasn’t saying this.
00:11:10 <dramforever> s/if so/otherwise
00:11:17 <dramforever> julianleviston: dunno then
00:11:25 <julianleviston> dramforever: so, nevermind :) I just thought you were here then.
00:11:40 <lispy> julianleviston: I'd say they have distinct advantages/disadvantages AND overlap with others things.
00:11:57 <julianleviston> lispy: cool.
00:11:59 <dramforever> yeah I agree
00:12:36 <julianleviston> Is there a pronunciation guide for operators? I wish Hoogle had one… so when I looked up (,) it would say “pronounced “pair””
00:12:44 <julianleviston> (assuming it is)
00:12:56 <arahael> julianleviston: How do you pronounce "pair"? :)
00:12:56 <lispy> I tend to call it tuple, but pair is just as good
00:13:11 <dramforever> "pair"
00:13:21 <slack1256> sometimes are mentioned on the docs
00:13:26 * dramforever saw this yesterday: https://wiki.haskell.org/Pronunciation
00:13:33 <slack1256> >>= bind; (<*>) ap; etc
00:13:37 <arahael> I imagine that varies hugely depending on accent, country, and language.
00:13:43 <julianleviston> sweet.
00:13:47 <julianleviston> dramforever: thanks!
00:13:50 <lispy> >> is sometimes called then
00:13:52 <dramforever> =)
00:13:54 <haskelltroll> it's pronounced pear, like the fruit
00:14:55 <slack1256> but that is only if you are in glasgow 
00:15:52 <dramforever> arahael: w.r.t "language", yes I can confirm (,) is neither called "pair" nor "tuple" in Chinese =)
00:16:40 <arahael> dramforever: I was wondering if everybody calls it the same way all over the world.  Would not some pronounced it more similar to "pare", or "pier", or "peeare"?
00:17:07 <arahael> I think there is an international phonetic alphabet, but I don't think that alphabet has a standard pronounciation.
00:17:21 <dramforever> arahael: I think there is
00:17:29 <arkeet> it wouldn't be a very good phonetic alphabet if it didn't.
00:17:32 <julianleviston> arahael: um I’m pretty sure the IPA has a standard pronunciation… (that’s the international phonetic alphabet)
00:18:11 <arahael> julianleviston: So why is it we don't have a perfect speech-to-text algorithm, then?
00:18:36 <julianleviston> arahael: because people don’t speak with the same accents.
00:18:40 <julianleviston> arahael: I’m guessing?
00:18:47 <dramforever> let's /j #haskell-blah
00:19:00 <arahael> julianleviston: It's because the *phonetic* alphabet is not the same.
00:19:05 <arahael> But anyway, enough of this. :)
00:19:08 <julianleviston> yes.
00:19:12 <dramforever> enough
00:20:31 <funfunctor> Hi
00:20:53 <julianleviston> hi ! :)
00:21:09 <adarqui> > let us = const "#haskell" in us "#haskell-blah"
00:21:10 <lambdabot>  "#haskell"
00:22:41 <julianleviston> ooh (,) is a Functor!
00:23:05 <adarqui> > fmap (+1) (1,1)
00:23:06 <lambdabot>  (1,2)
00:23:25 <funfunctor> I am trying to sort a list of type :: [(Double, Double)] ageist a particular :: (Double, Double) not in the list. I have a function that takes :: (Double, Double) -> (Double, Double) -> Double that measures (is a metric) the distance between two points. I need some help coming up with a function to do the sorting
00:23:25 <wordsarewind> (,) a is a Functor
00:23:53 <dramforever> :t sortBy
00:23:54 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
00:23:59 <dramforever> no...
00:24:05 <dramforever> wait it is
00:24:09 <julianleviston> wordsarewind:  oh sorry, I read it wrong, when i did :i (,) at GHCI.
00:24:10 <funfunctor> I came up with http://lpaste.net/136906
00:24:38 <funfunctor> dramforever: yea sortBy is what I started thinking with but it is a three way compare
00:24:46 <dramforever> =(
00:25:42 <funfunctor> basically the list is of a bunch of points and I want to know which one (actually the top 5) is closest under my metric
00:26:08 <funfunctor> I have the metric :: (Double, Double) -> (Double, Double) -> Double   written and working
00:26:44 <funfunctor> I have the point :: (Double, Double) and the list :: [(Double, Double)]   also
00:26:53 <dramforever> I don't understand it
00:27:02 <julianleviston> funfunctor: what is the pair of double pairs?
00:27:15 <dramforever> what makes a point closer than another?
00:27:16 <wordsarewind> a point I imagine
00:27:17 <julianleviston> as in… the first arg?
00:27:25 <dramforever> julianleviston: (Double, Double) -- double pair =)
00:27:31 <funfunctor> lol
00:27:36 <funfunctor> :)
00:27:41 <julianleviston> dramforever: no, ((Double, Double), (Double, Double))
00:27:48 <funfunctor> so a geopoint :: (Double, Double)
00:27:50 <dramforever> =)
00:27:55 <julianleviston> dramforever: what is that? It’s the first arg, isn’t it?
00:27:59 <funfunctor> so that is a pair of geo points
00:28:00 <julianleviston> dramforever: or did I misread?
00:28:01 <dramforever> dunno
00:28:04 <julianleviston> oh ok
00:28:21 <funfunctor> Should I reexplain?
00:28:42 <julianleviston> no I’m probably just dense.
00:29:01 <dramforever> funfunctor: what makes a point "better" than another?
00:29:14 <funfunctor> fix the concept of geopoint :: (Double, Double) in your mind and you will see what I am trying to do
00:29:19 <julianleviston> dramforever: its closeness to the comparing point, I think...
00:29:26 <funfunctor> the metric being smaller
00:29:40 <julianleviston> funfunctor: maybe you should type GeoPoint = (Double,Double) lol :) all good tho. I get it now.
00:29:42 <funfunctor> metric :: (Double, Double) -> (Double, Double) -> Double
00:29:56 <funfunctor> metric == 0 is optimal otherwise metric > 0
00:29:59 <dibblego> funfunctor: http://hackage.haskell.org/package/coordinate
00:30:14 <dramforever> can you get a function getMetric :: (Double, Double) -> Double
00:30:33 <julianleviston> funfunctor: so your code doesn’t work?
00:30:42 <funfunctor> I have the metric written and it works
00:31:05 <funfunctor> dibblego: thanks i'll grok that now..
00:31:07 <dramforever> funfunctor: can you write such a getMetric?
00:32:20 <funfunctor> dibblego: cute representation but does not really solve my problem
00:33:08 <dibblego> funfunctor: I don't know your specific problem, but I saw you representing a geodetic point as (Double, Double) and I know that is a problem.
00:33:34 <funfunctor> dramforever: well the metric has the type :: GeoPoint -> GeoPoint -> Double  using julianleviston 's  GeoPoint = (Double,Double)
00:33:52 <funfunctor> dibblego: why is it a problem?
00:34:08 <funfunctor> works fine for my usecase
00:34:40 <dibblego> because what geodetic point (assuming WGS84) is (181, 91)?
00:35:22 <dibblego> when represented accurately, reliable library support can be built
00:35:54 <funfunctor> dibblego: you mean it lacks some type safety sure.. but that is not really helping my problem right now..
00:36:16 <funfunctor> It just adds complexity while I am dealing with simpler problems currently
00:36:23 <dibblego> ...and subsequent reliable library support
00:36:26 <julianleviston> funfunctor: I still don’t really understand your problem.
00:36:33 <julianleviston> funfunctor: I’ll go re-read it
00:36:39 <dibblego> we may disagree on what "add" means
00:37:01 <dramforever> funfunctor: hey so you have point :: GeoPoint right?
00:37:20 <dramforever> and you want to compare the distance to the point?
00:38:00 * dramforever was gone for a while, sorry
00:38:03 <dibblego> http://hackage.haskell.org/package/geodetic-0.1.4/docs/Data-Geo-Geodetic-Vincenty.html
00:38:25 <dramforever> funfunctor: you know the thing called partial application right?
00:38:34 <dramforever> so metric point is exactly what you want
00:38:58 <julianleviston> dramforever: I think he already has a function that gets the distance between two points,
00:39:03 <dramforever> yes
00:39:09 <julianleviston> dramforever: oh, sorry
00:39:10 <dramforever> (metric point) is an expression
00:39:18 <julianleviston> cool
00:39:29 <julianleviston> so why can’t he just compare using sortBy?
00:39:32 <julianleviston> I’m stumped
00:39:34 <dramforever> he can
00:39:38 <dramforever> funfunctor: hello?
00:39:52 <julianleviston> dramforever: oh haha that’s what you’re saying - use a partial application across the sortBy lol
00:40:02 <dramforever> yeah
00:40:10 <julianleviston> dramforever: sorry I thought it was more complex than that for some reason.
00:40:12 <funfunctor> dramforever: yep sorry.. was just making a tea
00:40:26 <dramforever> oh does (metric point) work?
00:40:43 <dramforever> or it's more complexed than that?
00:40:47 <funfunctor> metric takes two points
00:40:58 <julianleviston> funfunctor: not if you partially apply it
00:41:04 <dramforever> do you know partial application?
00:41:05 <funfunctor> but I have three points! two from the list and one external
00:41:22 <julianleviston> funfunctor: just like (+) takes two nums, but (+ 1) takes one num.
00:41:25 <dramforever> so why is the list not [(GeoPoint, GeoPoint)] ?
00:41:50 <dramforever> btw didn't you say "well the metric has the type :: GeoPoint -> GeoPoint -> Double  using julianleviston 's  GeoPoint = (Double,Double)"
00:41:54 <dibblego> all haskell functions take one argument
00:42:06 <julianleviston> dibblego:  yes.
00:42:18 <dramforever> funfunctor: well =( I still didn't understand the problem
00:42:57 <funfunctor> I have a db which contains addresses, I get back [Address] and do a geo-lookup so I wind up with [GeoPoint] I have another seperate GeoPoint and I want to ask "which top 5 GeoPoint's in the list are the closest under my metric"
00:42:58 <julianleviston> dibblego: sorry for the shorthand.
00:43:31 <dramforever> funfunctor: so you compare each point by distance to the separate point?
00:43:33 <dibblego> julianleviston: that's OK, it's not clear to me what is going on, so I thought I'd just say a true thing, that appears related to whatever on earth is happening :)
00:43:37 <julianleviston> funfunctor: sor you need to map over ALL the points, finding their distance, then sortBy, then take 5.
00:43:52 <dramforever> :t sortWith
00:43:53 <lambdabot> Not in scope: ‘sortWith’
00:44:01 <dibblego> @type sortBy
00:44:02 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
00:44:15 <dibblego> > sortBy snd ("abc", 4) ("aaa", 7)
00:44:16 <dramforever> dibblego: seriously? nothing like sort by some key?
00:44:16 <lambdabot>      Couldn't match expected type ‘([Char], Integer) -> t’
00:44:16 <lambdabot>                  with actual type ‘[a0]’
00:44:16 <lambdabot>      The function ‘sortBy’ is applied to three arguments,
00:44:25 <funfunctor> yep I understand sortBy
00:44:25 <dibblego> > sortBy snd [("abc", 4), ("aaa", 7)]
00:44:26 <lambdabot>      Occurs check: cannot construct the infinite type:
00:44:26 <lambdabot>        t ~ ([Char], t) -> Ordering
00:44:26 <lambdabot>      Expected type: ([Char], t) -> ([Char], t) -> Ordering
00:44:29 <dibblego> sorry
00:44:38 <funfunctor> yea yea, I get the type signature
00:45:03 <dramforever> funfunctor: comparison separatePoint a b = compare (metric separatePoint a) (metric separatePoint b)
00:45:05 <dramforever> isn't it?
00:45:25 <dramforever> btw I think you can cache the metric
00:45:46 <dramforever> by mapping each point to a pair of the point and it's metric
00:45:51 <julianleviston> dramforever: hopefully not in the database, as it will be different for each lookup point.
00:45:56 <funfunctor> well I came up with http://lpaste.net/136906 as a three way compare but.. I think I am thinking along the wrong path..
00:46:17 <dramforever> funfunctor: 1. get rid of that tuple
00:46:19 <julianleviston> funfunctor: it looks like a case of trying to do too many steps at once.
00:46:24 <dramforever> no
00:46:49 <dramforever> funfunctor: partially apply that function with the separate x
00:47:11 <funfunctor> ok so my metric is called earthHaversine btw
00:47:24 <dramforever> 3. that big guard can be simplified down to compare (earthHaversine x a) (earthHaversine x b)
00:47:29 <funfunctor> i.e. earthHaversine :: (Double, Double) -> (Double, Double) -> Double
00:47:33 <dramforever> yes
00:47:40 <funfunctor> :t compare
00:47:40 <dramforever> do you get what I mean?
00:47:41 <lambdabot> Ord a => a -> a -> Ordering
00:47:45 <funfunctor> ok I see
00:48:03 <dramforever> so what's making you do a 3-way compare?
00:48:19 <dramforever> are you trying to compare by distance to point x?
00:48:40 <dramforever> oh wait it's earthHaversine to point x
00:48:57 <funfunctor> the list is "static" and the external point x is user provided, I want to know the top 5 in the list that is closest to x
00:49:11 <dramforever> funfunctor: I don't see why it makes a difference
00:49:38 <funfunctor> yea I am probably being dim myself.. Just explain what you think first..
00:52:41 <ttt_fff> C has a (a < b ? c : d) in ahskell, can I write that in a way shorter than if a< b then c else d
00:52:56 <dibblego> @type bool -- ttt_fff 
00:52:57 <lambdabot> a -> a -> Bool -> a
00:53:07 <lpaste_> dramforever annotated “No title” with “No title” at http://lpaste.net/136906#a136907
00:53:08 <ttt_fff> ??
00:53:10 <dibblego> same as ?: with the arguments in the correct order
00:53:15 <ttt_fff> oh, "boo" is a function?
00:53:16 <ttt_fff> wtf
00:53:17 <dramforever> funfunctor: does it make sense?
00:53:19 <ttt_fff> @src bool
00:53:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:53:23 <zipper> Given this is the definition of type `ParserInfo a` https://hackage.haskell.org/package/optparse-applicative-0.11.0.2/docs/Options-Applicative-Types.html#t:ParserInfo
00:53:38 <dibblego> bool f _ False = f; bool _ t True = t
00:53:45 <funfunctor> dramforever: essentially I want to wind up with a function that looks like :: [(Double, Double)] -> (Double, Double) -> [(Double, Double)]  where the resulting list is the top 5 geo coordinates under my metric
00:53:47 <zipper> How is opts of type ParserInfo a here http://lpaste.net/5334470267781513216
00:54:00 <dramforever> funfunctor: does the lpaste post make sense?
00:54:06 <dramforever> http://lpaste.net/136906#a136907
00:54:09 <zipper> The whole code sample is here https://github.com/pcapriotti/optparse-applicative#getting-started
00:54:44 <funfunctor> dramforever: reading now, but yes I don't have a problem understanding that
00:55:25 <dramforever> :t on
00:55:26 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
00:56:15 <funfunctor> i've used on before yes
00:56:20 <julianleviston> ttt_fff:  it’s in bool-extras.
00:56:40 <julianleviston> ttt_fff: Data.Bool.Extras
00:56:46 <funfunctor> dramforever: I didn't really understand line 17..
00:57:03 <dramforever> funfunctor: compareByEarchHaversine point is an expression
00:57:04 <ttt_fff> I just rewrote it myself
00:57:12 <ttt_fff> ite :: Bool -> a -> a -> a, ite b x y = if b then x else y
00:57:22 <dramforever> :t if'
00:57:23 <lambdabot>     Not in scope: ‘if'’
00:57:23 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
00:57:33 * hackagebot nonlinear-optimization-ad 0.2.1 - Wrapper of nonlinear-optimization package for using with AD package  https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.1 (MasahiroSakai)
00:57:38 <funfunctor> dramforever: yea, did you eta reduce that?
00:57:49 <dramforever> funfunctor: yes
00:58:04 <funfunctor> dramforever: can you un-reduce it so I can follow a bit better please
00:58:35 <dramforever> comparison = \a b -> compareByBlah point a b
00:58:43 <dramforever> sortBy comparison
01:00:33 <dramforever> funfunctor: sorry gotta go, bye and good luck trying to figure that out
01:00:47 <dramforever> also I think some other people can also help you
01:01:26 <ttt_fff> yeah
01:01:27 <ttt_fff> I'm helpful
01:01:38 <ttt_fff> but you have to type in "ttt_fff++" before each question
01:11:56 <dibblego> @type \f t -> fmap (\p -> if p then f else t)
01:11:57 <lambdabot> Functor f => b -> b -> f Bool -> f b
01:12:03 <dibblego> generalised ^^
01:13:59 <julianleviston> dibblego: can’t you just flip then apply bool?
01:14:17 <julianleviston> dibblego: compose flip with bool? probably not I’m guessing
01:14:32 <julianleviston> :t bool
01:14:33 <lambdabot> a -> a -> Bool -> a
01:14:44 <julianleviston> ah ok.
01:15:33 <julianleviston> ah that confuses me. :) 
01:16:21 <julianleviston> nvm.
01:17:53 <dibblego> why flip?
01:26:06 <funfunctor> :t uncurry
01:26:07 <lambdabot> (a -> b -> c) -> (a, b) -> c
01:26:36 <wordsarewind> :t curry
01:26:37 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:26:46 <wordsarewind> if only there was a function to fix me some curry for lunch
01:26:52 <wordsarewind> :/
01:36:40 <funfunctor> @hoogle [Maybe a] -> [a]
01:36:41 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
01:36:41 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:36:41 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:02:38 <ttt_fff> what this world needs, more than anything else, is a dsl in haskell that outputs erlang
02:02:42 <ttt_fff> so you can get benefit of haskell's type checking
02:02:46 <ttt_fff> and get erlang's distributed nature
02:05:12 <slack1256> like cloud haskell?
02:20:20 <LnL>  I'm trying to make a lambdabot plugin, but I can't figure out how to get the result back
02:22:39 <LnL> looking at lambdabot-irc-plugins it looks like `received' and `addServer' are used to pipe the message to lambdabot
02:27:37 * hackagebot draw-poker 0.1.0.0 - playing draw poker  https://hackage.haskell.org/package/draw-poker-0.1.0.0 (outoftune)
02:27:39 * hackagebot libsystemd-journal 1.3.3 - Haskell bindings to libsystemd-journal  https://hackage.haskell.org/package/libsystemd-journal-1.3.3 (OliverCharles)
02:50:34 <freinn> hi
02:50:42 <freinn> I have trouble with a Data.Map
02:50:44 <freinn> http://lpaste.net/136911
02:51:54 <slack1256> oh haskell in spanish. let me see
02:51:57 <freinn> why it works with (+) (negate quantity) and not with (-) quantity?
02:52:03 <freinn> xDDD
02:54:21 <funfunctor> Suppose I have some data Foo = Foo { this :: ..., that :: ... , baz :: Maybe Int },  how can I case on that inner baz but keep all of Foo
02:54:32 <slack1256> freinn: also what was the input for those cases?
02:54:34 <dramforever> :t Data.Map.insertWith
02:54:35 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
02:54:39 <dramforever> =(
02:55:18 <dramforever> freinn: you've run into a RTFM problem =)
02:55:22 <dramforever> *an
02:55:32 <mauke> funfunctor: x@Foo{ baz = Just y }
02:55:33 <freinn> what is RTFM?
02:55:33 <freinn> xD
02:55:39 <slack1256> it typecheck it doesn't produce the right answer
02:55:40 <slack1256> it seems
02:55:43 <freinn> how can I name you in red?
02:55:45 <dramforever> Read the f**king manual
02:55:47 <dramforever> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#v:insertWith
02:55:54 <freinn> ahh okok xD
02:55:57 <mauke> funfunctor: what?
02:55:59 <mauke> er
02:56:00 <mauke> freinn: what?
02:56:17 <dramforever> slack1256: because types don't help there
02:56:22 <funfunctor> what does that @ syntax mean mauke ?
02:56:32 <freinn> slack1256: prueba = let ts = [ Transaction { from = "Haskell Curry"                                 , to = "Simon Peyton Jones"                                 , amount = 10                                 , tid = "534a8de8-5a7e-4285-9801-8585734ed3dc"                                 }                   ]          in getFlow ts
02:56:37 <dibblego> funfunctor: as pattern
02:56:46 <mauke> funfunctor: var@pat is a pattern that matches pat but also binds the whole thing to var
02:56:54 <funfunctor> can you contrive a example please?
02:57:15 <augur> aeson is kind of frustratingly clever
02:57:25 <funfunctor> augur: hehe true!
02:57:31 <mauke> > case ("hello", 42) of x@(_, y) -> (y, x)
02:57:33 <lambdabot>  (42,("hello",42))
02:57:55 <augur> funfunctor: i dont mean that its frustrating that it's so clever, i mean that it tries to be clever (and often is) but this causes frustrating problems
02:58:05 <mauke> > case "hello" of x@(y : z) -> (x, y, z)
02:58:07 <lambdabot>  ("hello",'h',"ello")
02:58:09 <augur> like, it tries to be efficient, right, so it represents data as minimally as necessary
02:58:34 <freinn> thanks for the answer houys!
02:58:38 <freinn> guys*
02:58:43 <funfunctor> augur: parsing is normally frustrating to be honest..
02:58:46 <augur> but this means that the representations are in flux and there's no single representation you can rely on
02:58:54 <augur> funfunctor: no the parsing is fine, its the optimization
02:59:02 <funfunctor> mauke: thanks, thats very interesting
03:00:10 <augur> and im not sure if aeson is overly flexible or not, too
03:00:13 <augur> itd be good if it were
03:02:38 * hackagebot haskell-coffee 0.1.0.2 - Simple CoffeeScript API  https://hackage.haskell.org/package/haskell-coffee-0.1.0.2 (KevinVanRooijen)
03:05:09 <indiagreen> augur: overly flexible?
03:05:26 <augur> indiagreen: data Foo = Foo  ;  encode Foo == "[]"
03:05:45 <augur> so of course if i do
03:05:58 <augur> decode "[]" :: Foo   itll return Foo :: Foo, correctly
03:06:20 <funfunctor> > case ("hello", Just 42) of x@(_, y) -> (y, x)
03:06:22 <lambdabot>  (Just 42,("hello",Just 42))
03:06:23 <augur> but:   if i do    decode "{ 'tag': 'Foo', 'contents': [] }" will it as well?
03:06:25 <augur> dunno!
03:06:29 <augur> experimenting now to see
03:06:51 <indiagreen> my bets are on “no”
03:08:14 <augur> the answer is........ no!
03:09:54 <augur> interestingly, it's not overly optimizing either
03:10:11 <indiagreen> overly optimising?
03:10:12 <augur> it makes a representation choice by the whole data type rather than individual constructors
03:10:35 <augur> data Bar = Bar0 | Bar1   produces encodings "Bar0" and "Bar1"
03:10:46 <augur> while data Baz = Baz0 | Baz1 Int   produces tagged encodings
03:11:05 <augur> { "tag": "Baz0", "contents": [] }   and   { "tag": "Baz1", "contents": [] }
03:11:14 <augur> instead of "Baz0" for the first
03:11:53 <indiagreen> well, it just kinda sounds sensible
03:12:45 <indiagreen> I definitely wouldn't expect it to have different *shape* for different constructors
03:12:58 <indiagreen> also I guess it's easier to implement
03:13:01 <augur> eh.
03:13:18 <augur> i would expect that if Aeson is going to optimize constructors at all, it should do it on a per-constructor basis
03:45:50 <maerwald> > join (.) id 3
03:45:51 <lambdabot>  3
04:03:28 <merijn> Ok, so is there any good explanation of the cofree comonad? I feel like I've figured out Free for awhile now, but Cofree has me so lost...
04:09:23 <merijn> Actually, I guess the Cofree thing itself makes enough sense on it's own. I just find myself needing both a Free and Cofree representation and I'm lost how to combine the two...
04:11:47 <nkaretnikov> how can I load a test executable in haskell-mode repl?  if I do the usual :cd tests, :l Test, it complains about missing modules
04:12:41 * hackagebot eigen 2.1.3 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  https://hackage.haskell.org/package/eigen-2.1.3 (OlegSidorkin)
04:15:49 <Gurkenglas> merijn, you're trying to build a hylomorphism out of it?
04:17:07 <merijn> Gurkenglas: I have no idea what that means, so maybe :p
04:17:36 <Gurkenglas> "iter (...) . (...) . coiter (...)"
04:17:50 <Gurkenglas> *merijn
04:18:30 <merijn> Gurkenglas: Maybe? I dunno
04:18:41 <merijn> Gurkenglas: Basically, I have this Free based AST at the moment: http://lpaste.net/136912
04:18:51 <Gurkenglas> "Construct a cofree comonad, turn it into a free monad, tear it down"?
04:19:02 <merijn> Gurkenglas: And I realised that I want to 1) annotate it with source locations and 2) annotate it with typechecking info
04:19:14 <merijn> Now, annotations on every node looks like Cofree
04:19:45 <merijn> But, the last parameter for Cofree (the annotation) is different from the current last parameter in Free (the type of a variable name)
04:20:06 <merijn> And I dunno how to sensibly add what I need to the current Free based AST
04:20:47 <Gurkenglas> I think the "looks like" for Cofree and Free is more that Free monads can be iterated into a single value, and Cofree comonads can be coiterated from a single value.
04:21:53 <Gurkenglas> If you write the whole construct yourself with annotations included, I have the feeling a slightly more complex Free monad is to be applied
04:22:41 <merijn> Gurkenglas: Well, I initially used FreeT with ((,) Annotation) as base monad to generate an annotated AST, but this has a problem
04:22:56 <merijn> i.e. I can't access the "closest" annotation when at a Pure leave
04:23:03 <merijn> So I have no way to access typing info
04:23:24 <merijn> Now, with a comonad I could do that, but then I no longer understand what I'm doing >.>
04:23:57 <merijn> Oh, wait...could it be as simple as making my base FreeT monad a Comonad too?
04:27:10 <merijn> oh, no...that'd do the exact opposite of what I want, I guess...
04:47:14 <Gurkenglas> Why is cutoff implemented twice in https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Trans-Free.html#cutoff / https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Trans-Iter.html#cutoff ?
04:47:42 * hackagebot draw-poker 0.1.0.1 - playing draw poker  https://hackage.haskell.org/package/draw-poker-0.1.0.1 (outoftune)
04:48:37 <ttt_fff> is there a builtin/short hand for: flip (.) ?
04:48:44 <mniip> >>>
04:48:54 <ttt_fff> :t >>>
04:48:55 <lambdabot> parse error on input ‘>>>’
04:48:56 <latk> Is there some way to use Data.Aeson.Lens to decode with an error message if it fails? It currently is Maybe a.
04:49:04 <int-e> Gurkenglas: those functions have different types...
04:49:05 <Gurkenglas> :t (>>>)
04:49:05 <indiagreen> :t (>>>)
04:49:06 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
04:49:06 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
04:49:43 <Gurkenglas> int-e: https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Iter.html#t:IterT <- IterT ~ FreeT Identity
04:49:47 <ttt_fff> mniip++
04:49:58 <ttt_fff> Gurkenglas++
04:50:11 <ttt_fff> indiagreen -- // for silly stuff about ttt_tff :-)
04:50:24 <ttt_fff> wtf is cat ?
04:50:33 <indiagreen> ttt_fff = 0
04:50:44 <ttt_fff> @karma ttt_fff
04:50:44 <lambdabot> You have a karma of 1
04:50:50 <ttt_fff> @karma indiagreen
04:50:50 <lambdabot> indiagreen has a karma of 3
04:51:07 <Gurkenglas> A generalization of functions.
04:51:22 <Gurkenglas> :t ((>>>) :: (a -> b) -> (b -> c) -> a -> c)
04:51:23 <lambdabot> (a -> b) -> (b -> c) -> a -> c
04:51:43 <Gurkenglas> So you can use it on functions and itll work, but itll also work for some other stuff
04:51:52 <ttt_fff> do I want the one from Control.Category or the one from Control.Arrow ?
04:52:22 <Gurkenglas> Control.Arrow
04:52:37 <indiagreen> why? the Arrow one is just a reexport
04:52:56 <Gurkenglas> I always see Control.Arrow imported, so I guessed it must have a reason
04:53:32 <ttt_fff> indiagreen: how do you recommned I study up on COntrol.Arrow ?
04:53:34 <Gurkenglas> class Category a => Arrow a, so you should use Arrow when its applicable because its more powerful? *guess*
04:54:08 <Gurkenglas> https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Arrow.html seems pretty informative... aww I wasnt asked :D
04:54:15 <indiagreen> first of all, this is exactly not how it works
04:54:20 <indiagreen> you use the least powerful thing you can
04:54:23 <indiagreen> not the most powerful
04:55:01 <int-e> Gurkenglas: there may be an isomorphism between the two types, but they're still not the same, nor easily convertible. But in any case that begs the question why the two implementations look so different...
04:55:07 <indiagreen> second, people have been mostly using Control.Arrow for “first”, “second”, “&&&”, and “>>>”
04:55:28 <indiagreen> we have Data.Bifunctor now and >>> comes from Category anyway
04:56:21 <Gurkenglas> We could deprecate Control.Arrow? Nevermind then :D
04:56:32 <indiagreen> well, people still do use it for FRP
04:56:53 <indiagreen> it's just that people don't use FRP much either
04:56:54 <indiagreen> yet
04:57:18 <funfunctor> :t fmap
04:57:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:57:56 <funfunctor> I really got to learn lens soon!
04:58:18 <Peaker> funfunctor: start with SPJ's intro talk about them, it's great :)
04:59:19 <funfunctor> Peaker: where is that?
05:00:42 <Peaker> funfunctor: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation <-- I think you might need to log in to watch :(
05:01:31 <funfunctor> Peaker: I have :: [Foo]  where  data Foo = Foo { this :: .. , that :: .. , baz :: Maybe Int }   and I need to filter out the Nothing ones.. I know of mapMaybe perhaps
05:02:22 <dramforever> funfunctor: btw did you solve that sorting problem?
05:02:28 <merijn> If you're comfortable with Const and Identity types then edward's talk is pretty good too
05:02:43 <Peaker> funfunctor: just filter out, or convert them perhaps to [(Foo, Int)] for the concent of the Just?
05:03:25 <Peaker> funfunctor: without lens, this works:  [(foo, x) | foo <- foos, Just x <- [baz foo]] :)
05:03:54 <int-e> Gurkenglas: oh it's just that either (Left . f) (Right . [fmap] g) = bimap f g, because IterT uses Either where FreeT uses a custom datatype with two constructors, and the [fmap] disappears in the IterT version because the functor is the identity functor.
05:04:05 <Peaker> I am not sure lens is useful here anyway, if you don't need the content of the Just: filter (isJust . baz)  works
05:04:27 <merijn> Why not "[x | x@Foo{baz = Just _} <- foos] "?
05:04:32 <merijn> Pretty sure that should work
05:04:36 <ttt_fff> is there something like: a -> (a -> b) -> b ?
05:04:38 <funfunctor> dramforever: Yes thanks! but the data types I was working with are inside some types.. i.e. I was working with :: Point but that is inside Address, so now I need to generalise..
05:04:45 <indiagreen> ttt_fff: &
05:04:46 <dramforever> =)
05:04:48 <indiagreen> :t (&)
05:04:49 <merijn> @define data Foo = Foo { bar :: Int, baz :: Maybe Int }
05:04:50 <lambdabot> a -> (a -> b) -> b
05:04:50 <lambdabot>  .L.hs:156:1:
05:04:50 <lambdabot>      Multiple declarations of ‘Foo’
05:04:50 <lambdabot>      Declared at: .L.hs:145:1
05:04:54 <merijn> @undefine
05:04:54 <lambdabot> Undefined.
05:04:56 <merijn> @define data Foo = Foo { bar :: Int, baz :: Maybe Int }
05:04:57 <lambdabot>  Defined.
05:04:59 <int-e> Gurkenglas: so everything is as expected: since the types are different, the FreeT functionality is reimplemented for IterT.
05:05:03 <indiagreen> it's new in Data.Function
05:05:17 <indiagreen> (since GHC 7.10)
05:05:26 <merijn> > [x | x@Foo{baz = Just _} <- [ Foo 1 (Just 2), Foo 2 Nothing, Foo 3 (Just 4)]
05:05:27 <lambdabot>  <hint>:1:77:
05:05:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:05:32 <merijn> > [x | x@Foo{baz = Just _} <- [ Foo 1 (Just 2), Foo 2 Nothing, Foo 3 (Just 4)]]
05:05:33 <lambdabot>      No instance for (Show Foo)
05:05:34 <lambdabot>        arising from a use of ‘show_M893996990354682015411198’
05:05:34 <lambdabot>      In the expression:
05:05:38 <merijn> eh, whoops
05:05:40 <merijn> @undefine
05:05:40 <lambdabot> Undefined.
05:05:41 <ttt_fff> indiagreen++
05:05:47 <indiagreen> ha
05:05:48 <merijn> @define data Foo = Foo { bar :: Int, baz :: Maybe Int } deriving (Show)
05:05:49 <lambdabot>  Defined.
05:05:51 <funfunctor> merijn: its ok, I get what your saying..
05:05:51 <merijn> > [x | x@Foo{baz = Just _} <- [ Foo 1 (Just 2), Foo 2 Nothing, Foo 3 (Just 4)]]
05:05:53 <lambdabot>  [Foo {bar = 1, baz = Just 2},Foo {bar = 3, baz = Just 4}]
05:05:53 <ttt_fff> indiagreen: haskell is amazing, you can -- ppl and they'll help you :-)
05:05:59 <funfunctor> merijn: thx
05:06:25 <ttt_fff> > t (&)
05:06:27 <lambdabot>      Couldn't match expected type ‘(a0 -> (a0 -> b0) -> b0) -> t’
05:06:27 <lambdabot>                  with actual type ‘Expr’
05:06:27 <lambdabot>      The function ‘t’ is applied to one argument,
05:06:29 <merijn> Pattern match failure not being an error in list comprehensions is a great way to filter by constructor :)
05:06:35 <ttt_fff> :t (&)
05:06:36 <lambdabot> a -> (a -> b) -> b
05:06:48 <ttt_fff> where does (&) come from? I can't find it in hoogle
05:06:54 <indiagreen> Data.Function
05:06:57 <merijn> ttt_fff: Data.Function (in recent GHCs)
05:07:09 <indiagreen> also lens
05:07:10 <merijn> Otherwise lens in older versions
05:07:25 <ttt_fff> indiagreen++
05:07:28 <ttt_fff> merijn++
05:07:50 <Peaker> merijn: I somewhat dislike record pattern match syntax
05:09:17 <merijn> Peaker: Sure, but it's hard to be more concise than my example :)
05:09:36 <funfunctor> merijn: wont mapMaybe id work just as well somehow..?
05:09:49 <merijn> :t mapMaybe
05:09:49 <lambdabot> (a -> Maybe b) -> [a] -> [b]
05:09:59 <merijn> funfunctor: I guess
05:10:33 <merijn> funfunctor: But you need to change that so that it returns "Just x" whenever "baz x == Just _", which is annoying to write
05:10:55 <Peaker> :t [mapMaybe id, catMaybes]
05:10:56 <lambdabot> [[Maybe b] -> [b]]
05:11:37 <Peaker> funfunctor: if you want only the content of the Justs, mapMaybe can be an easy way to get it all.. that's where lens is even easier
05:11:45 <Gurkenglas> @check \xs -> mapMaybe id xs == catMaybes xs
05:11:47 <lambdabot>  +++ OK, passed 100 tests.
05:11:58 <merijn> That doesn't address the fact that the outer data structure is not a Maybe, but a Foo
05:12:06 <funfunctor> awesome!
05:12:06 <shourya> Hey, I need help, does anyone here know how to edit a text intro for a YouTube channel?
05:12:19 <funfunctor> merijn: true
05:12:23 <Peaker> :t \xs -> mapMaybe id xs == catMaybes xs
05:12:24 <lambdabot> Eq b => [Maybe b] -> Bool
05:12:41 <Peaker> @check \xs -> mapMaybe id xs == reverse (catMaybes xs)
05:12:42 <indiagreen> shourya: this is the wrong channel for that
05:12:43 <lambdabot>  +++ OK, passed 100 tests.
05:12:55 <Peaker> ^^ GHC defaulting + quick-check == no good! :)
05:13:18 <Peaker> @check instantiates unrestricted type variables to (), making most checks mostly meaningless
05:13:19 <lambdabot>  <unknown>.hs: 1: 27:Parse error: type
05:13:47 <Peaker> @check \(xs::[Maybe Int]) -> mapMaybe id xs == reverse (catMaybes xs)
05:13:47 <lambdabot>  <unknown>.hs: 1: 20:ScopedTypeVariables is not enabled
05:13:55 <Gurkenglas> It still might reject the null hypothesis of correctness!
05:14:19 <Peaker> @check \xs -> mapMaybe id (xs::[Maybe Int]) == reverse (catMaybes xs)
05:14:21 <lambdabot>  *** Failed! Falsifiable (after 8 tests and 7 shrinks):
05:14:21 <lambdabot>  [Just (-2),Just (-5),Just (-6)]
05:14:26 <Peaker> @check \xs -> mapMaybe id (xs::[Maybe Int]) == catMaybes xs
05:14:26 <merijn> @check \xs -> xs == reverse xs
05:14:28 <lambdabot>  +++ OK, passed 100 tests.
05:14:29 <lambdabot>  +++ OK, passed 100 tests.
05:14:43 <Gurkenglas> Why didn't it shrink it one further?
05:15:39 <Axman6> shourya: does that have anything to do with Haskell?
05:25:13 <shourya> Axman6: oooooh. Sorry, didn't see what channel I was posting on.
05:43:19 <ttt_fff> @check forall a b c, a^3 + b^3 != c^3
05:43:19 <lambdabot>  <unknown>.hs: 1: 13:Parse error: ,
05:44:19 <Gurkenglas> merijn, what do you mean by closest annotation?
05:44:31 <funfunctor> http://lpaste.net/136913  so I need a bit of a hand getting my types right here
05:45:00 <Gurkenglas> @check \a b c -> a^3 + b^3 /= c^3
05:45:02 <lambdabot>  *** Failed! Falsifiable (after 1 test):
05:45:02 <lambdabot>  0 0 0
05:45:07 <funfunctor> I am looking for reduceSCList :: Address -> [Address] -> [Address]
05:46:26 <Gurkenglas> funfunctor, imma guess that relates to http://lpaste.net/136906 ?
05:46:57 <funfunctor> Gurkenglas: correct yes
05:47:18 <funfunctor> I am trying to get it to work on the inner type of Address
05:47:32 <funfunctor> because Point is a member type of the Address type
05:48:22 <Gurkenglas> You want to sort by the point, but keep the addresses, right?
05:49:24 <funfunctor> Gurkenglas: thats correct yes
05:50:51 <merijn> Gurkenglas: At the variables I need to access their type, which, if I use ((,) Type) as base monad for FreeT is hidden out of the view of Pure
05:52:42 <Gurkenglas> funfunctor, this should work: http://lpaste.net/136914
05:53:09 <Gurkenglas> Umm, this.
05:55:51 <funfunctor> Gurkenglas: thx! does that need   TemplateHaskell ?
05:56:12 <Gurkenglas> Yes, that's what allows turning functions into infix operators with ''
05:56:37 <Gurkenglas> Possibly you need to put brackets around the . term?
05:56:58 <indiagreen> not 'on', `on`
05:57:09 <Gurkenglas> Huh, sorry.
05:57:19 <funfunctor> indiagreen: ah just figured it out :)
05:57:24 <funfunctor> not a problem
05:57:46 <entity> is implementing a generic Y combinator a fun exercise?
05:58:08 <Gurkenglas> (Also in this case, an easier way might be just wrapping the Points back into addresses with (map (Address . Just)))
05:58:20 <ghost_runner> so... is there any point in learning low-level C/asm stuff when there are languages like Haskell and Lisp(s)? would doing so just be a waste of time?
06:00:32 <benzrf> ghost_runner: they are worth knowing
06:00:35 <funfunctor> Gurkenglas: yea that function looks hellish to understand..
06:00:39 <benzrf> understanding how computers work is good
06:00:49 <benzrf> and half of modern computing is built with C
06:05:07 <circ-user-Xc4po> Is there a way to check function defined is total or not. Something to check if I have not missed any cases
06:05:12 <jabesed> entity: no...
06:06:38 <entity> i see
06:07:36 <jabesed> entity: denotationally the Y operator is a primitive, and used to implement recursion
06:07:45 * hackagebot leksah-server 0.15.0.5 - Metadata collection for leksah  https://hackage.haskell.org/package/leksah-server-0.15.0.5 (HamishMackenzie)
06:07:46 <jabesed> entity: in haskell you have recursion
06:07:59 <entity> jabesed: I know
06:08:11 <jabesed> entity: so all you'll be doing is writing a one liner... 
06:08:13 <entity> but you can still implement a generic Y comb. just for the fun of it
06:08:34 <jabesed> entity: yes but it's just a  trivial one liner 
06:09:51 <funfunctor> @hoogle singleton
06:09:52 <lambdabot> Data.Text.Internal.Builder singleton :: Char -> Builder
06:09:52 <lambdabot> Data.Text.Lazy.Builder singleton :: Char -> Builder
06:09:52 <lambdabot> Data.ByteString.Char8 singleton :: Char -> ByteString
06:10:20 <funfunctor> @hoogle [a] -> a
06:10:20 <lambdabot> Prelude head :: [a] -> a
06:10:21 <lambdabot> Data.List head :: [a] -> a
06:10:21 <lambdabot> Prelude last :: [a] -> a
06:10:43 <Gurkenglas> circ-user-Xc4po, you could use quickcheck, but it'll only prove your function is partial or fail to prove it
06:11:22 <circ-user-Xc4po> Gurkenglas: I think agda has such a mechanism, wanted to know haskell has one too
06:11:36 <entity> jabesed: that is a point, i suppose
06:11:52 <Wizek__> Good morning!
06:12:11 <jabesed> entity: it's just    y f = f (y f)
06:13:42 <Wizek__> Is it possible with some package (e.g. haskell-src-meta) to parse a string for the longest valid haskell expression, and when an unexpected token is reached just return a tuple of the matched and remaining string fragments?
06:13:52 <latk> Is there a function that is like groupby, but it is more of a "chain" ?
06:14:14 <latk> so you keep applying the check function to the last element that passed, rather than the first one of that group
06:14:32 <Gurkenglas> circ-user-Xc4po, how does agda prove that the function "\x -> (p,q) primes with p+q==2x+4" is total on the naturals?
06:15:46 <Gurkenglas> (*"lexicographically smallest" to make it a function)
06:18:05 <circ-user-Xc4po> Gurkenglas: Yeah, you are right. It may not always be possible. But if you define natural numbers as Nat = Zero | Succ Nat, then you cannot write such a function
06:18:54 <circ-user-Xc4po> No, wait. Sorry
06:18:57 <soultadu> #f
06:19:07 <funfunctor> Gurkenglas: have you looked at Idris yet?
06:19:21 <quchen> jabesed: Your definition is denotationally correct, but the actual defintion is "fix f = let x = f x in x", which has better sharing.
06:19:37 <circ-user-Xc4po> Gurkenglas: How are you defining the functuon?
06:21:47 * nshepperd thinks that number 1 on the list of "myths about the halting problem" should be "the undecidability in general means that prove programs to halt is always impossible or useless"
06:21:48 <circ-user-Xc4po> Gurkenglas: Okay, I see your point.
06:22:08 <merijn> nshepperd: Not to mention it only applies to Turing complete languages and those are overrated anyway!
06:23:03 <circ-user-Xc4po> Gurkenglas: Oh, yeah, functions in Agda are always primitive recursive
06:26:25 <circ-user-Xc4po> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Totality
06:33:37 <Saizan> they aren't always primitive recursive..
06:34:23 <Saizan> at least, you don't have to write them like that, however they could in principle be translated into (dependent) primitive recursion
06:34:59 <hodapp> nshepperd: Move that to number 2, and put at number 1 that Turing completeness is required to do any all "real" work.
06:35:04 <hodapp> nshepperd: because much of it stems from that.
06:36:43 <hodapp> Saizan: can it handle Walter recursion or something?
06:38:09 <circ-user-Xc4po> hodapp: Whats walter recursion?
06:38:45 <hodapp> circ-user-Xc4po: I may be using the wrong term, but it's some kind of well-founded recursion that provably terminates, but encompasses more than primitive recursion
06:39:04 <hodapp> IIRC it handles things like the Ackermann function
06:40:17 <hodapp> circ-user-Xc4po: it might be related to requiring that the function always 'descend' (in whatever sense around deconstructing applies) on one of its arguments, or I might be confusing that with something else
06:42:07 <circ-user-Xc4po> hodapp: Agda can handle Ackerman. http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Totality#Structuralrecursion
06:42:28 <hodapp> circ-user-Xc4po: structural recursion might have been what I confused it with.
06:42:36 <hodapp> in either case, more powerful than primitive recursive, I thought.
06:42:47 * hackagebot api-builder 0.8.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.8.0.0 (Intolerable)
06:47:47 * hackagebot stomp-queue 0.2.1 - Stompl Client Library  https://hackage.haskell.org/package/stomp-queue-0.2.1 (TobiasSchoofs)
06:57:29 <indiagreen> is it possible to subscribe to HWN without subscribing to the mailing list?
06:57:47 * hackagebot stomp-queue 0.2.2 - Stompl Client Library  https://hackage.haskell.org/package/stomp-queue-0.2.2 (TobiasSchoofs)
06:58:47 <indiagreen> there was talk about setting up RSS a month ago, maybe they have done it by now
07:12:48 * hackagebot engine-io-wai 1.0.0 -   https://hackage.haskell.org/package/engine-io-wai-1.0.0 (codedmart)
07:14:29 <htebalaka_> does anyone know what the * indicates in data.reflection's hackage documentation? in the reify instances specifically, the reify class takes two type parameters, but the instances include 3
07:14:42 <htebalaka_> https://hackage.haskell.org/package/reflection-2/docs/Data-Reflection.html
07:17:15 <geekosaur> it's haddock not understanding kind constraints, I think
07:18:53 <geekosaur> so it output * as a type instead of using a type variable (probably "s" for consistency), because of a (s :: *) kind constraint in the declaration
07:19:40 <htebalaka_> ah, i figured it was something weird like that
07:49:28 <zmbmartin> Anyone that can help me with this error. Not sure if the code snippet is enough but I still struggle with types https://gist.github.com/codedmart/a84f7ea215b221642625#file-chat-hs-L8
07:52:57 <htebalaka_> zmbmartin: does it compile if you remove the type signature? i think you just didn't include the MonadReader constraint in the type
07:53:55 <zmbmartin> htebalaka_: I don't have a type signature on that section of code.
07:56:17 <htebalaka_> hmm...maybe add a type signature to eioServer then to find out why it's not inferring the MonadReader constraint. you'll still have a type error, but the error message might move closer to the actual problem
07:56:59 <ely-se> how come "k" is strictly applied to "a" in "bindIO (IO m) k = IO $ \ s -> case m s of (# new_s, a #) -> unIO (k a) new_s" (from GHC.Base)?
07:57:48 <ely-se> Since otherwise k doesn't use a then the I/O wouldn't be performed for as far as I can tell.
08:00:04 <ely-se> such as in "putStrLn "hi" `bindIO` (\_ -> return ())"
08:07:48 <nshepperd> ely-se: that's what the use of new_s is for
08:08:14 <nshepperd> among other things
08:09:28 <nshepperd> well actually, since it's a case statement the evaluation of m s is forced either way
08:09:32 <ely-se> why would the use of new_s force evaluation of a?
08:10:15 <nshepperd> evaluation of a isn't required
08:10:45 <ely-se> then how is the I/O performed?
08:11:02 <ely-se> I thought the I/O was a side-effect of evaluating a. Is it a side-effect of evaluating new_s instead?
08:11:59 <nshepperd> I believe it's a side effect of evaluating the unboxed tuple
08:12:31 <ely-se> hmm
08:12:31 <nshepperd> evaluating (m s) into the unboxed tuple result
08:13:44 <ely-se> I'm implementing a similar system in another lazy language and I basically did the equivalent of "unIO (k $! a) new_s" which seems to work
08:16:10 <merijn> ely-se: If you care about implementation, I'd recommend the "Lazy Functional State Threads" paper
08:16:24 <ely-se> nshepperd: thanks, makes sense.
08:16:28 <ely-se> merijn: I'll look it up.
08:16:40 <merijn> ely-se: It explains how to implement ST and then (if I remember correctly) shows how it can be generalised so that both IO and ST are a specialisation of the same thing
08:16:50 <merijn> ely-se: http://www.researchgate.net/profile/Simon_Peyton_Jones/publication/2295326_Lazy_Functional_State_Threads/links/0046351edd5bb96287000000.pdf
08:18:59 <ely-se> gotta eat. bye!
08:40:58 <ferdinand> can anybody help me with this? http://paste.ofcode.org/Pqn7SjSFktrbsMPuJg5kRC
08:41:34 <NeverDie> How hard would be it to make a codecademy clone but for Haskell, for example?
08:43:28 <mauke> ferdinand: you can't
08:44:07 <ferdinand> darn
08:46:48 <merijn> ferdinand: Usual solutions: 1) Tons of typehackery that's probably not worth it and 2) make a newtype with unexported constructor and make a smart constructor
08:47:40 <ferdinand> merijn: could you post a quick example? not sure what  a "smart constructor" is
08:47:56 <ely-se> "smart constructor" is a fancy word for "function"
08:48:17 <ferdinand> how would that allow me to constrain the "Futon" type?
08:48:55 <merijn> ferdinand: https://wiki.haskell.org/Smart_constructors
08:49:41 <ely-se> ferdinand: basically do this: https://gist.github.com/rightfold/e160b2e59bd2f7cdb302
08:50:18 <ferdinand> ah
08:50:19 <ferdinand> thanks
08:54:36 <ferdinand> are there no type parameters in haskell like in java?
08:55:11 <ely-se> there are
08:55:14 <int-e> :t id
08:55:14 <lambdabot> a -> a
08:55:28 <ely-se> e.g. data Maybe a = Just a | Nothing
08:55:31 <ferdinand> right
08:55:45 <ferdinand> hmmmmmm i have an idea
08:56:10 <ely-se> me too.
08:56:39 <chpatrick> it would be nice if you could use template haskell to make new files
08:56:55 <srhb> chpatrick: Make new files? TH can do IO..
08:56:56 <merijn> chpatrick: Why couldn't you?
08:57:32 <geekosaur> maybe the right question is "what actual problem are you trying to solve?"
08:57:35 <chpatrick> I mean new haskell files
08:57:53 <chpatrick> from scratch as opposed to embedding generated bits into an existing one
08:58:03 <indiagreen> you mean generating new modules?
08:58:07 <chpatrick> yes
08:58:21 <indiagreen> I think I saw a ticket about it somewhere on GHC Trac
08:59:09 <chpatrick> I mean it has all the machinery for doing it, there's just no way to do emitModule :: FilePath -> DecsQ ->Q ()
08:59:35 <lpaste_> Yrarr pasted “Paralell Strategies for pure monads” at http://lpaste.net/4092459021057916928
08:59:45 <int-e> chpatrick: how is ghc --make supposed to work under such circumstances?
09:00:27 <merijn> Obligatory "ghc --make" is deprecated observation
09:00:39 <chpatrick> well it wouldn't have to operate the way TH usually does as a compile-time pass
09:00:56 <chpatrick> you would just use it as a library to generate haskell when you want
09:01:32 <Yrarr> Hello #haskell! I'd like to ask you one question. I try to parallize my code inside a Rand monad, but anyway I fail to do so - there's no benefit when setting +RTS -N2. Is there something I've missed ? Is inter_islands evaluated to normal form due to mapM ? http://lpaste.net/4092459021057916928
09:01:36 <chpatrick> actually I wonder if this is already possible with a bit of abuse
09:01:41 <geekosaur> hm, if you actually just want generating source and not adding a module to ghc's current build list, I thought there was a thing for haskell-src-exts?
09:01:46 <chpatrick> you could just write the TH AST types to a file
09:01:50 <geekosaur> although I don't think I see how that would be useful
09:02:06 <chpatrick> my use case is generating bindings
09:02:25 <chpatrick> and it would be nice to be able to use all the quotation and stuff you usually get with TH
09:03:06 <chpatrick> I wonder if this is possible with the Quasi instance for IO
09:03:13 <chpatrick> plus Language.Haskell.TH.Pretty
09:03:49 <chpatrick> hmm actually I could make my own Quasi
09:03:58 <chpatrick> which also supports reify unlike IO
09:04:20 <geekosaur> http://hackage.haskell.org/package/haskell-src-exts-qq
09:05:04 <chpatrick> ah that's nice
09:05:07 <geekosaur> although I think that still leaves emitting it (but that may be Language.Haskell.TH.Pretty or one of the printers in haskell-src-exts)
09:05:49 <geekosaur> unfortnately I'm having a vague recollection that getting h-s-e and TH on the same page is either annoying or not yet done yet...
09:05:57 <geekosaur> *not quite done yet
09:06:15 <chpatrick> I'll experiment with getting TH to emit with a  custom Quasi instance
09:13:18 <orion> :t (>=>)
09:13:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:13:28 <orion> :t (>>=)
09:13:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:14:15 <merijn> I like the fish operator a lot more than bind...it's a lot more elegant in combination with return
09:14:25 <orion> :t (>>)
09:14:26 <lambdabot> Monad m => m a -> m b -> m b
09:15:31 <orion> merijn: A function I am trying to use requires me to pass a (a -> IO b). I want to insert a threadDelay 1000000 at the end, but I am unsue of what operator to use.
09:17:25 <merijn> Assuming 'f :: a -> IO b', then "\x -> do { result <- f x; threadDelay 1000000; return result }"?
09:17:36 <orion> merijn: doStuff :: (a -> IO b) -> IO () 
09:18:41 <Peaker> merijn: debugging more exception safety issues, I'm beginning to suspect code in "async" could be it (as it uses the Control.Exception primitives for exception handling, arrrg)
09:18:55 <Peaker> merijn: gotta land that patch in GHC, everything's unreliable everywhere!
09:19:51 <chpatrick> is there a handy way to get a functor for a free monad given a typeclass?
09:20:03 <merijn> Peaker: Fun times :p I finished most of the patch a week ago, but then I had a summer school and vacation next week, I'm hoping to get it on Phab when I get back
09:20:40 <merijn> chpatrick: I don't understand your question? A free monad is by definition already a functor...
09:20:59 <Peaker> merijn: That guy did so much harm to that thread, by bringing up misguided objections, delaying the fix :(
09:21:02 <chpatrick> I mean the f in Free f
09:21:06 <htebalaka> chpatrick: do you mean you want "Free f" to be a monad even if "f" isn't a functor?
09:21:19 <c_wraith> chpatrick: given a type class?
09:21:33 <c_wraith> chpatrick: do you mean given a type class that already defines monadic operations?
09:21:34 <chpatrick> no, I mean I'd like to auto-generate an f that has one constructor for each method in a typeclass
09:21:38 <chpatrick> yes
09:21:38 <merijn> chpatrick: That has to be a Functor
09:21:46 <merijn> chpatrick: If 'f' is not a Functor, then "Free f" is not a monad
09:21:51 <chpatrick> I know merijn
09:21:52 <c_wraith> chpatrick: use Coyoneda of a GADT that matches the method signatures
09:22:06 <c_wraith> chpatrick: Or use Operation instead of free, as it embeds the Coyoneda
09:22:07 <chpatrick> c_wraith: no it can be a functor
09:22:15 <chpatrick> I just want don't want to write the GADT by hand :P
09:22:19 <c_wraith> chpatrick: Coyoneda is always a functor
09:22:23 <chpatrick> I know
09:22:27 <chpatrick> that's not the problem
09:22:27 <orion> @pl whileNext t e $ \r -> do { forM_ r indexPost; threadDelay 1000000 }
09:22:28 <lambdabot> (line 1, column 26):
09:22:28 <lambdabot> unexpected '{'
09:22:28 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
09:22:37 <orion> :<
09:22:47 <c_wraith> *operational (for posterity's sake)
09:23:06 <c_wraith> chpatrick: so..  You're saying you want template haskell?
09:23:12 <c_wraith> ...  Can TH even introspect a class?
09:23:12 <htebalaka> i'm sure you could do it if you use template haskell
09:23:17 <chpatrick> yes it can
09:23:33 <chpatrick> I was just wondering if there's a handy package for "give me an instance of a class for free"
09:24:24 <c_wraith> I can't imagine wanting to automate that
09:24:34 <c_wraith> since it's about 0% of the work involved in using a free monad.
09:25:03 <chpatrick> that's not the point though
09:25:18 <c_wraith> It's why it hasn't been done.
09:25:38 <merijn> c_wraith: If you want more complicated questions about Free(T), I've got some for you ;)
09:25:49 <Peaker> Wouldn't Control.Exception.*mask* make more sense in Control.Concurrent than in Control.Exception?
09:26:20 <c_wraith> Peaker: Eh..  Async exceptions are still exceptions.  Even if they are a consequence of concurrency as well
09:26:26 <c_wraith> merijn: go for it. :)
09:27:54 * hackagebot rdf4h 1.3.2 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-1.3.2 (RobStewart)
09:29:03 <geekosaur> @. pl undo whileNext t e $ \r -> do { forM_ r indexPost; threadDelay 1000000 }
09:29:03 <lambdabot> whileNext t e ((>> threadDelay 1000000) . flip forM_ indexPost)
09:29:14 <merijn> c_wraith: So I have the following Free based AST http://lpaste.net/136912 and I find myself needing annotations on it (i.e. source locations, inferred types, etc.), so initially I figured I'd use "((,) Annotation)" as base Monad for FreeT, which seemed like an elegant solution. But then I realised that if I wanna work with the annotation I don't have access to them in the leaves (Pure being the variables I
09:29:20 <merijn>  wouldn't have a way to access the annotated type/source location of a variable when dealing with it, since the tuple isn't visible there)
09:30:01 <geekosaur> and I see @pl doesn't know that flip forM_ is mapM_
09:30:03 <merijn> c_wraith: Then I thought it looked a lot like a Cofree comonad (annotations on every node), but couldn't figure out how to sanely implement that, as Cofree wants the annotation's type as last argument, whereas my AST has the type of variables as last type argument
09:31:29 <merijn> In other words, I had a problem and I thought "I know, I'll use Free", now I have a fixpoint of problems >.>
09:31:45 <c_wraith> So you're saying you Fixed the problem?
09:32:03 <merijn> Wouldn't Fix be Mu instead of Free? :p
09:34:10 <Peaker> I use withAsyncWithUnmask, which needs to be run under uninterruptibleMask to be safe (due to its use of Control.Exception primitives), but then the new thread starts as "masked-uninterruptible", and there's no way to move it to "masked" without going through "unmasked" in the middle
09:34:22 <Peaker> I wonder how the "unmask" interacts with an extra mask_ around it
09:34:59 <c_wraith> merijn: it seems to me that you'd still have the location.  The Pure constructor won't have it, but the full value you'll have at that point will be (Annotation, Pure ...)
09:36:07 <Peaker> Until Control.Exception is fixed, using any code built upon it and preserving exception safety seems to be near impossible :(
09:36:21 <merijn> c_wraith: hmm, maybe I'm just approaching it wrong and should use lenses instead of pattern matching to make it more convenient
09:36:46 <c_wraith> merijn: Do you need source locations in the model?
09:36:57 <c_wraith> merijn: or do you only need them when interpreting?
09:37:31 <c_wraith> merijn: if the latter, you can deal with them in the interpreter only, and forget FreeT
09:37:31 <merijn> c_wraith: I only need source for error reporting, but type annotations I need at various times too
09:38:06 <c_wraith> meretrix: if the former, you should move them into the operations modeled, such that you can call something like "getAnnotation" at any time.
09:38:21 <c_wraith> meretrix: err, sorry, meant merijn 
09:38:35 <c_wraith> merijn: Then you can also go back to using Free instead of FreeT
09:38:38 <merijn> There's isn't only an interpreter, because System Fω needs to do some interpreting during typechecking
09:38:44 <Peaker> merijn: Reusing Cofree and friends on your AST is really not that important.. "duplicating" the code of CoFree for an AST is a trivial violation of DRY :)
09:39:02 <merijn> Peaker: Cofree would be the replacement of Free
09:39:10 <merijn> But that doesn't really make sense
09:39:12 <Peaker> merijn: Cofree makes sense for AST annotations
09:39:12 <Gurkenglas> https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/src/Data-Functor-Foldable.html#Foldable <- Why did he eta-reduce cata, but not para?
09:39:44 <merijn> Peaker: Except that it'd ruin the way I currently use bound for substitution
09:40:29 <merijn> Peaker: Because in Cofree the annotations are the functor argument, whereas in bound it's the variable types
09:40:40 <Peaker> merijn: the primary benefit of using bound is Eq being meaningful alpha-eq, right?
09:40:51 <Peaker> merijn: we just use https://github.com/Peaker/Algorithm-W-Step-By-Step/blob/master/Lamdu/Expr/Val.hs#L191-L215, we don't use bound, we just do alpha eq manually
09:41:13 <merijn> Peaker: But that's a pain, and I'm lazy
09:41:21 <Peaker> I guess capture-avoiding substitution is a problem too if you use manual names and not GUIDs like we do :-) )
09:41:46 <Peaker> merijn: how do ekmett's ASTs look like?
09:42:06 <merijn> Peaker: His examples use a custom ADT without Free
09:42:12 <Peaker> merijn: btw, what about newtype'ing the CoFree result to permute the type params?
09:42:13 <merijn> Peaker: But then you still don't have annotations
09:42:26 <Peaker> merijn: I don't see how Free makes sense for annotations (as opposed to Cofree)
09:42:45 <merijn> Peaker: FreeT plus ((,) Annotation) as base monad?
09:42:55 <Peaker> merijn: what you said about the leaves..?
09:43:24 <merijn> Peaker: You still have them at the level above as c_wraith pointed out
09:43:34 <merijn> Peaker: And I don't really see how to make Cofree work either
09:43:42 <Peaker> merijn: newtype permute?
09:44:18 <merijn> I could try, I guess I'm still just a bit confused about what the hell I'm doing :p
09:44:19 <Peaker> merijn: if you just have a single "leaf expression", how does it look like with Free ((,) Annotation) ?
09:44:50 <merijn> You'd get "(Annotation ?, Pure ?)
09:46:28 <merijn> Well "FreeT (Annotation ?, Pure ?)", but you get the idea
09:46:30 <Peaker> merijn: that representation has 0-N annotations on that pure
09:46:35 <Peaker> iiuc, at least
09:46:39 <merijn> Peaker: Why?
09:46:52 <Peaker> merijn: i.e: Free (Annotation ?, Free (Annotation ?, Pure ?))
09:47:15 <merijn> Peaker: No
09:47:37 <Peaker> merijn: I'm using the "Free" type from http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free.html
09:47:48 <Peaker> merijn: and f=(,) Annotation
09:48:06 <Peaker> merijn: Oh, you said FreeT with a base monad
09:48:22 <merijn> Something like: FreeT (Annotation ?, App (FreeT ?) (Annotation ?, Pure ?)
09:48:41 <merijn> So the annotation happens at every recursion level, but that's basically annotating every tree node
09:48:42 <Gurkenglas> Couldn't you put the annotation into both the a and the f of Free?
09:48:46 <merijn> Which is exactly what you want
09:49:16 <merijn> Anyway, time to stop thinking about work
09:49:22 <Peaker> merijn: ah, now I see, FreeT f m a,  f=Non-leaf Expr type. m=Annotation type, a=Leaf type?
09:49:30 <nshepperd> would it help to define the type you want manually and then turn it back into a combination of co-things once you figured out what it is
09:50:57 <Gurkenglas> Or you could have f contain an annotation for each contained child node, then only the root wouldn't have an annotation
09:52:20 <merijn> Peaker: Yeah
09:52:49 <merijn> Gurkenglas: But the problem is then modifying the annotation type
09:53:04 <merijn> with FreeT and monad I can use mmorph to transform annotations
09:53:30 <Gurkenglas> Make f a bifunctor, first type argument is the annotation type and turns it into Free's functor?
09:54:02 <Gurkenglas> Then use hoistFree to get any changes in the annotation type into the ast
09:54:36 <merijn> Anyhoo, I'll play with this again later, thanks for the suggestions :)
09:54:58 <Peaker> I think I gotta avoid using "async" due to exception safety issues, doh
09:55:11 <Gurkenglas> (Wait, Bifunctor f => Functor (f a) isn't in https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html ?)
09:57:07 <indiagreen> Gurkenglas: it would've been an orphan instance
09:58:41 <orion> Where do I report bugs in the documentation of base?
09:59:55 <Gurkenglas> indiagreen, Haskellwiki: "An orphan instance is a type class instance for class C and type T which is neither defined in the module where C is defined nor in the module where T is defined." C is Functor and T is f a? The constraint doesn't count?
10:00:18 <geekosaur> constraints are part of the problem
10:00:26 <geekosaur> they don't get applied until after the instance has been selected
10:01:58 <indiagreen> oh, right
10:01:58 <Gurkenglas> The "orphan instance" concept was introduced so you could check whether a non-orphan instance exists by checking in only two places, yes?
10:02:05 <indiagreen> it's not even about orphan instances then
10:02:10 <indiagreen> geekosaur++
10:02:56 <indiagreen> Gurkenglas: also because without this rule, 2 instances could be created in 2 separate packages
10:03:09 <indiagreen> and since you can't not import instances, you just wouldn't be able to use those packages together
10:32:01 <fishburne> Can someone help he figure out why this http://lpaste.net/136926 happens? (Type inference fails when I remove an unused argument of  a function)
10:34:59 <Saizan> fishburne: {-# LANGUAGE NoMonomorphismRestriction #-}
10:35:45 <fishburne> Saizan: let me try.
10:37:07 <fishburne> Saizan: it worked! 
10:39:01 <fishburne> Sorella: Thanks. 
10:39:13 <fishburne> Saizan: Thanks..
10:39:29 <fishburne> Sorella: Pls ignore.
10:41:29 <Gurkenglas> Can I use something like ApplicativeDo to turn ZipList (a -> Maybe b) and ZipList (b -> Maybe c) into ZipList (a -> Maybe c)?
10:41:56 <Gurkenglas> (Preferably without having to explicitly say >>= for the Maybes)
10:42:06 <Saizan> fishburne: cheers
10:43:20 <htebalaka> dot_Laptop: do { x <- f ; y <- g ; pure (x >=> y) } ?
10:46:20 <humanoyd> Anyone here who has experience with the Turtle lib?
10:50:59 <chpatrick> :t liftA2 (>=>)
10:50:59 <lambdabot> (Monad m, Applicative f) => f (a -> m b) -> f (b -> m c) -> f (a -> m c)
10:51:35 <chpatrick> Gurkenglas: ^
10:52:50 <gganley> :t liftA2
10:52:51 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:52:59 <gganley> wow thats cool
10:55:17 <Gurkenglas> I am amaze, though I hoped for something like an applicative transformer MaybeA to be used with do notation :D
10:58:05 <Gurkenglas> Though it wouldn't be an applicative transformer because it would incorporate binds... hence confusion and asking here
10:59:28 <indiagreen> Gurkenglas: we don't need applicative transformers, because applicative functors already compose
10:59:40 <indiagreen> https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html
11:00:00 <Gurkenglas> Yep I was just reading https://wiki.haskell.org/Applicative_functor#Applicative_transformers and noticed that shouldn't work because we're still binding Maybes
11:17:58 * hackagebot active 0.2.0.4 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.4 (bergey)
11:19:27 <nkaretnikov> can I explicitly free memory?
11:20:24 <indiagreen> nkaretnikov: you can explicitly trigger a garbage collection
11:20:48 <indiagreen> https://hackage.haskell.org/package/base-4.8.0.0/docs/System-Mem.html
11:22:58 * hackagebot force-layout 0.4.0.2 - Simple force-directed layout  https://hackage.haskell.org/package/force-layout-0.4.0.2 (bergey)
11:23:00 * hackagebot diagrams-core 1.3.0.2 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.2 (bergey)
11:27:58 * hackagebot diagrams-lib 1.3.0.2 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.2 (bergey)
11:28:00 * hackagebot diagrams-contrib 1.3.0.4 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.4 (bergey)
11:28:02 * hackagebot diagrams-svg 1.3.1.4 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.4 (bergey)
11:28:04 * hackagebot diagrams-cairo 1.3.0.3 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.0.3 (bergey)
11:28:06 * hackagebot diagrams-postscript 1.3.0.2 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.2 (bergey)
11:28:10 <nkaretnikov> indiagreen: are you sure that's the only way?
11:28:23 <nkaretnikov> indiagreen: I expect to be quite slow
11:28:35 <indiagreen> nkaretnikov: nope, I'm very much not an expert on these things
11:29:44 <nkaretnikov> all the experts are on #ghc, but that'd be offtopic there :\
11:30:21 <thoughtpolice> nkaretnikov: I guess it depends on what you mean by 'free memory', but if a GC qualifies, then those are your options. A minor collection should be relatively fast.
11:30:44 <thoughtpolice> Which I think has been exposed since 7.8.4. The functions are literally just calls around some 'void f(void)' functions in the RTS.
11:30:48 <Kluns> When you have to pass two distinct configurations around, what is considered best practise? Having two ReaderT's in your transformer stack, or using a combining data type?
11:31:21 <nkaretnikov> thoughtpolice: :) thanks for the answer!
11:33:08 * hackagebot diagrams-rasterific 1.3.1.3 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.3 (bergey)
11:33:10 * hackagebot diagrams-canvas 1.3.0.2 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.2 (bergey)
11:33:12 * hackagebot diagrams-html5 1.3.0.2 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.2 (bergey)
11:33:14 * hackagebot diagrams-builder 0.7.1.1 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.1.1 (bergey)
11:33:16 * hackagebot diagrams-haddock 0.3.0.6 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.3.0.6 (bergey)
11:33:34 <thoughtpolice> nkaretnikov: Also, reading the code (see scheduleDoGC() in the RTS source code; Schedule.c), I believe the semantics are:
11:35:00 <thoughtpolice> performGC MAY perform a major GC, if it determines it's necessary. It will always do a minor collection regardless. performMajorGC will ALWAYS perform a major GC and subsequently a minor GC.
11:35:34 <thoughtpolice> I think.
11:38:12 <htebalaka> Kluns: i'd prefer combining data types, but there's also Data.Reflection
11:38:18 * hackagebot yesod-transloadit 0.3.0.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.3.0.0 (boblong)
11:39:25 <indiagreen> thoughtpolice: currently it looks like performGC is simply defined as performMajorGC, has it been changed in GHC HEAD or are you simply say that “MAY perform a major GC, if it determines it's necessary” is its stated semantics?
11:42:33 <thoughtpolice> indiagreen: Oh yes, I forgot about that stupid definition. It's sort of dumb because the logic is kind of backwards; performGC actually performMajorGC, despite the fact in the RTS, performGC is actually what does a *minor* collection.
11:42:46 <thoughtpolice> Which is actually a wrapper around a function that does both major/minor collections depending on the arguments.
11:43:43 <thoughtpolice> It could all stand to be cleaned up a bit.
11:44:44 <orzo> should i upvote people i disagree with because they have unust negative scores on their comments? heh
11:44:49 <orzo> unjust
11:44:56 <orzo> oh wrong window, sorry
12:12:36 <Gurkenglas> http://lpaste.net/4202984755970441216 <- I don't get either of the remaining hlint outputs
12:12:55 <Gurkenglas> (Also, suggestions on code style welcome!)
12:13:46 <comprehension> how can i write an escaped hex literal next to another character without a space? 
12:13:54 <geekosaur> comprehension, \&
12:14:00 <comprehension> i.e. i want the character \x27 followed by the character D
12:14:03 <geekosaur> (it stops the previous escape silently)
12:14:03 <comprehension> but not \x27D
12:14:08 <comprehension> geekosaur: thanks
12:14:19 <mniip> Gurkenglas, you're importing a module twice
12:14:22 <mniip> Data.Maybe
12:14:33 <Gurkenglas> ._.
12:14:45 <Gurkenglas> (The 6 lines of German comments are for the benefit of my bosses who don't speak Haskell, but know what the code is for)
12:14:51 <geekosaur> also, I generally ignore the use fewer imports "error"
12:15:07 <Peaker> geekosaur: you can use a project-wide annotation
12:15:43 <Gurkenglas> geekosaur, why? It seems to have gone away after I collapsed the two import declarations into one
12:17:34 <geekosaur> mostly because it comes up in other circumstances (notably my xmonad config...)
12:17:52 <geekosaur> where that is not the cause
12:18:00 * hackagebot dynamic-pp 0.2.0 - A pretty-print library that employs a dynamic programming algorithm for optimal rendering.  https://hackage.haskell.org/package/dynamic-pp-0.2.0 (emc2)
12:18:37 <geekosaur> btw it looks to me like the $ on line 139 (which it claims is on 136) really is redundant
12:19:20 <geekosaur> although you may have to adjust indentation on line 140
12:21:06 <greeny> Gurkenglas: if you are a vim user, tools like ghcmod will help you write good code
12:23:33 <Gurkenglas> w00t first time windows comes in handy with haskell
12:24:53 <Gurkenglas> Oh wait vim not windows ._.
12:25:38 <tamasgal> vim 4 ever :P
12:25:57 <kaste> there is vim for windows :P
12:26:10 <kaste> it's not as much fun though
12:26:36 <nkaretnikov> is list a good (i.e., time/space efficient) data structure if I just want to store a bunch of objects in it before printing?  or is there something better?
12:27:13 <Eduard_Munteanu> nkaretnikov, if you access it sequentially, it's fine, yes
12:27:30 <nkaretnikov> Eduard_Munteanu: what do you mean by that?
12:27:44 <nkaretnikov> I just cons stuff into it, then mapM
12:27:50 <nkaretnikov> mapM_, I mean
12:27:52 <Eduard_Munteanu> nkaretnikov, that's fine then.
12:28:15 <Cale> nkaretnikov: Lists are really good at basically one thing: accessing the elements of the list in the order in which they occur in it.
12:29:43 <Cale> Just like a loop either doesn't occur (e.g. because its precondition isn't met) or else consists of an iteration followed by another loop, a list is either empty, or consists of an element followed by another list.
12:30:05 <Cale> So lists are like the data structure equivalent to loops.
12:30:45 <nkaretnikov> nice analogy!
12:34:21 <jmcarthur> lists are really good at being purely functional stacks, too
12:39:05 <nkaretnikov> Cale: ah, wait, I also sort before printing
12:39:19 <nkaretnikov> Cale: would it be better to insert in the right order instead?
12:39:46 <nkaretnikov> using a data structure other than list
12:39:55 <nkaretnikov> a*
12:45:39 <tamasgal> kaste: i dont know windows
12:45:56 <tamasgal> but i guess that every tool is a pain under windows ;)
12:47:24 <joncol> What are there mechanical rules for converting expressions from pointfree to pointful style?
12:48:31 <Gurkenglas> Why is foldr (a -> b -> b) -> b -> [a] -> b, not (a -> b -> b) -> [a] -> b -> b?
12:49:42 <voidzero> joncol, I saw a website a while ago that allows you to convert from one to the other
12:49:53 <voidzero> but i have no idea what the URL was
12:49:54 <xandaros> Gurkenglas: probably so you can use partially apply the fold and then use it on multiple lists. Probably not that useful the other way around
12:49:55 <nkaretnikov> voidzero: lambdabot can do that
12:50:14 <voidzero> lambdabot can do almost everything
12:50:16 <indiagreen> http://hackage.haskell.org/package/pointfree
12:50:20 <nkaretnikov> absolutely!
12:50:51 <voidzero> :{
12:50:52 <indiagreen> joncol: pointfree to pointful... well, like, you just add “$ x”
12:50:54 <voidzero> :) *
12:51:02 <indiagreen> maybe the opposite?
12:51:21 <Gurkenglas> indiagreen, @unpl does more than just that
12:51:37 <joncol> voidzero, there are cabal tools (pointfree and pointful). But I want to know the intermediate steps so that I can get a good understanding of how the stuff works
12:51:38 * indiagreen didn't know about unpl
12:52:22 <indiagreen> hackage.haskell.org/package/pointful-1.0.6/docs/src/Lambdabot-Pointful.html#pointful
12:52:22 <voidzero> http://pointfree.io/
12:52:29 <indiagreen> there's a list of rules there
12:52:30 <indiagreen> combinatorModule
12:53:02 * hackagebot refact 0.1.0.0 - Specify refactorings to perform with apply-refact  https://hackage.haskell.org/package/refact-0.1.0.0 (mpickering)
12:53:09 <indiagreen> I guess it just expands everything and then optimises the expression (look at optimizeE)
12:54:24 <joncol> indiagreen> interesting, I'll look at those rules
12:55:01 <indiagreen> it's not really interesting, it's just a bunch of definitions for functions that pointfree often uses to generate pointfree code
12:57:01 <indiagreen> and expansion is done like “expand plain combinators, then expand sections, then expand >>= in some particular case, the end” (in uncomb')
12:57:51 <xtreak> Is there any rules about indenting haskell code..
12:58:52 <roboguy_> xtreak: yeah https://en.wikibooks.org/wiki/Haskell/Indentation
12:59:02 <mightybyte> Has anyone used haskell-mode with spacemacs?
12:59:11 <sccrstud92> does the universal property of a construction tell you everything (or derive from it, everything) that there is to know about that construction?
13:00:11 <indiagreen> while optimisation is “try to apply lambdas, combine lambdas like “\x -> \y ->” into one “\x y ->” lambda, remove extra parens, and convert things like “\x -> f x” into just “f” (eta reduction)”
13:02:24 <sccrstud92> by that I mean, does the universal property of a construction subsume all other properties of the construction?
13:03:15 <broma0> Is generic programming something to use in everyday haskell programs? Or is it more for libraries?
13:04:05 <Cale> sccrstud92: Universal mapping properties uniquely determine objects up to isomorphism.
13:05:03 <sccrstud92> and isomorphic objects are indistringuishable from the categorical perspective, correct?
13:05:14 <Cale> right
13:05:25 <Cale> They may not be *equal*
13:05:41 <Cale> But they have all the same properties with respect to the rest of the category
13:08:17 <xandaros> Would someone mind having a quick glance at my code and giving some style suggestions? https://github.com/Xandaros/GithubNotify/tree/master/src
13:13:02 <Peaker> What would be a nice way to do the equivalent of catMaybes (or in reality, Data.Either.rights) on a Map (or other traversable) rather than a list?
13:13:18 <Peaker> i.e: Map k (Either l r) -> Map k r  (throwing away Lefts)
13:18:04 <indiagreen> Peaker: Traversable doesn't support it
13:18:13 <indiagreen> it can't change the shape of the structur
13:18:14 <indiagreen> *e
13:18:29 <indiagreen> I think you need something like Witherable
13:18:36 <indiagreen> http://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html
13:19:51 <Peaker> indiagreen: true, I'm looking for any generalization that already exists and would work on Data.Map :)
13:20:25 <Peaker> indiagreen: thanks, I'll write a one-off thing rather than add a dep for that :)
13:20:50 <latk> stupid question - how do I apply a lens getter to a list ?
13:21:35 <indiagreen> Peaker: why not use mapEither ?
13:22:12 <indiagreen> Peaker: “snd . M.mapEither id” should do exactly what you want
13:22:37 <indiagreen> latk: yourList ^. yourGetter
13:22:48 <indiagreen> or did you mean “to every element of the list” or something?
13:23:11 <latk> Yeah, every element
13:23:21 <latk> Oh :p
13:23:28 <Peaker> indiagreen: didn't see mapEither, thanks!
13:23:57 <indiagreen> latk: yourList ^.. each.yourGetter
13:25:07 <sccrstud92> > [(1,2), (3,4)] ^.. traverse . _1
13:25:08 <lambdabot>  [1,3]
13:25:25 <sccrstud92> traverse also works
13:26:05 <indiagreen> each is shorter and looks nicer
13:26:55 <Codex_> what you think of using adjunction for rendering?
13:30:40 <Gurkenglas> http://lpaste.net/8114881689752174592 <- Can pair be defined to use (,) in place of Pair?
13:30:46 <Gurkenglas> *P
13:32:40 <Gurkenglas> (Can we enable TemplateHaskell for lamdabot?)
13:32:47 <roboguy_> Gurkenglas: I don't think so. You would need a type level function like (\t a -> t a a) and I don't think that can exist in Haskell
13:34:31 <Codex_> the rule that allows rendering with adjunction looks like this: f(x,y) |- exists y.f(x,y)
13:35:29 <Codex_> its the unit of (exists -| *) -adjunction.
13:35:42 <roboguy_> Codex_: what do you mean by rendering?
13:36:43 <Codex_> roboguy_: like the normal process of describing 3d points with data, and then projecting them to 2d, and then drawing triangles that span the points.
13:38:26 <Codex_> roboguy_: I mean, given (x,y,z) point in 3d, you can use projection matrix to project it to 2d to get (x_1,y_1) point which describes the status of a ray in 3d space.
13:39:33 <Codex_> s/ray/ray that hits the (x,y,z) point/
13:39:51 <roboguy_> Codex_: ah, ok. I understand the linear algebra-type stuff there, but I don't see how adjunctions fit in. Of course, I only have a vague idea of adjunctions anyway
13:40:26 <Codex_> I learned this adjunction stuff from Awodey's "Category Theory"
13:40:39 <roboguy_> I have a copy of that, but I haven't gotten that far yet
13:40:52 <roboguy_> I mostly know about them from the catsters videos
13:40:58 <Codex_> its page 223 and 224
13:41:56 <JuanDaugherty> none of the web frameworks does cloud haskell?
13:42:15 <JuanDaugherty> (the majors)
13:42:34 <c_wraith> None depend on it.
13:42:42 <c_wraith> I'm pretty sure all could integrate with it just fine
13:43:04 * hackagebot hvect 0.2.0.0 - Simple strict heterogeneous lists  https://hackage.haskell.org/package/hvect-0.2.0.0 (AlexanderThiemann)
13:43:06 * hackagebot dump 0.2.0 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.0 (Wizek)
13:43:21 <JuanDaugherty> right, didn't expect pkg level dependency
13:43:47 <JuanDaugherty> just support of some kind
13:44:07 <JuanDaugherty> and actually don't expect that either
13:44:50 <michaelavila> Hello, I hope all is well. Does anyone have docs or an explanation for `nonvoid`? I'm seeing it for the first time.
13:45:47 <indiagreen> michaelavila: can you say where you saw nonvoid? Hayoo can't find it
13:46:22 <voidzero> obviously i have no idea
13:47:45 <michaelavila> @indiagreen I'm seeing it in a book called "Good Math" from the pragprog.com
13:47:45 <lambdabot> Unknown command, try @list
13:47:52 <nkaretnikov> is it possible to define a new constant for cpp?
13:48:17 <nkaretnikov> michaelavila: avoid @ since it triggers the bot
13:49:04 <michaelavila> yeah, my apologies, thanks nkarentnikov
13:49:57 <roboguy_> michaelavila: could you give some more information about what you've seen about it?
13:50:09 <roboguy_> I've never heard of it
13:51:03 <pavonia> nkaretnikov: Can't you use #define?
13:51:07 <roboguy_> michaelavila: oh, is it a function or is the word "nonvoid" being used as an adjective or something like that?
13:51:35 <nkaretnikov> pavonia: probably, let me explain what I'm trying to do
13:52:32 <michaelavila> sorry, it took me a minute to put the gist together, here's the exact portion of the code https://gist.github.com/michaelavila/4a7f5f799188845dfa4e
13:53:05 <nkaretnikov> pavonia: well, nevermind, I just realized that it's pointless anyway...  testing code that uses iorefs is hard
13:53:13 <michaelavila> nkaretnikov (also, sorry for misspelling your name earlier)
13:53:21 <nkaretnikov> michaelavila: heh, np
13:54:41 <mauke> michaelavila: that's just the name of a variable used in the code
13:54:55 <mauke> like re_one or c
13:56:41 <michaelavila> mauke: I don't see it being defined anywhere though, it's possible that the code listing is partial (though that's not indicated in the text), let me attempt to get it type checking at the very least
13:56:52 <roboguy_> michaelavila: the case branches define it
13:57:05 <nkaretnikov> pavonia: or not, meh, I'm not sure.  well, what I'd like to know is whether it's possible to set such a constant by passing a command line argument.  I'd like to change a definition for testing purposes but don't want that to affect performance otherwise.  so I gathered I could (ab)use cpp for this, but it's probably not possible :\
13:57:13 <roboguy_> > case ('a', 3) of  (x, y) -> x
13:57:15 <lambdabot>  'a'
13:57:16 <michaelavila> roboguy_: OH
13:57:41 <pavonia> nkaretnikov: You can by -DFOO, I think
13:57:44 <michaelavila> roboguy_: aye, thank you very much, not sure why I put so much meaning into `nonvoid`
13:58:02 <roboguy_> no problem!
13:58:23 <michaelavila> in fact, thank you all for the quick responses
13:58:44 <hodapp>  
13:59:14 <nkaretnikov> pavonia: I'll look into it, thank you!
13:59:28 <pavonia> No problem
14:05:47 <ecognium> hello everyone, I am trying to generate a JSON for a wrapper. I am not sure best way to reuse my previous instance declaration. 
14:06:06 <ecognium> If I have data Wrapper = SomeId Wrap
14:06:43 <ecognium> I already have a ToJSON for Wrap. So I just want to reuse it in my ToJSON for Wrapper. I am not sure how to do it
14:07:27 <Cale> ecognium: toJSON (SomeId x) = toJSON x  ?
14:07:29 <ecognium> I do toJSON (Wrapper sid w) = object ["id" =. sid] ??? How do i invoke w's toJson? 
14:07:44 <Cale> Or yeah, you could make them distinguishable somehow
14:08:07 <Cale> Just how you'd use toJSON anywhere else in your program
14:08:22 <ecognium> Cale: I would like to concatenate them but not sure how to do it. 
14:09:01 <ecognium> object is returning a `Value` and so does `toJSON`. How do I concatenate them so they appear as one JSON Value?
14:09:35 <indiagreen> ecognium: .= invokes it automatically
14:09:43 <Cale> What type of JSON value do you want the result to be?
14:09:56 <Cale> I'm not sure what "concatenate" means in this context. JSON objects aren't strings.
14:10:38 <Cale> (Well, the ones which are Strings are :)
14:11:37 <ecognium> Cale: I meant I wanted a JSON that looked like {"someId" : 1, "wrapper" : {'a':1, 'b':2}} , etc. I meant joining 'someId' and 'wrapper' in the same object. You answered it by saying .= should give me what I wanted. 
14:12:10 <Codex_> roboguy_: I made a tutorial for rendering with adjunction: http://sivut.koti.soon.fi/~terop/Rendering_with_adjunction.html
14:12:12 <indiagreen> ecognium: the type of (.=) is “ToJSON a => Text -> a -> Pair”. Next, “object” makes a JSON object out of a list of pairs
14:12:12 <ecognium> I just did object ["someId .= sid, "wrapper" .= w]
14:12:34 <Cale> ecognium: yep, that looks right.
14:12:54 <Cale> Well, assuming that sid and w are JSON values
14:13:12 <Cale> If they're not, you might want to apply toJSON to them
14:13:20 <indiagreen> Cale: no
14:13:22 <ecognium> Thanks, Cale. Yup, they are. It type checks and gives me the right result. 
14:13:28 <indiagreen> .= already invokes toJSON
14:13:40 <Cale> Oh, right, it does
14:13:46 <Cale> cute
14:14:09 <ecognium> Thanks Cale and indiagreen.  
14:16:34 <rvxi> hi
14:17:13 <bergmark> hi rvxi!
14:17:35 <rvxi> hi bergmark
14:18:05 * hackagebot fwgl 0.1.2.0 - FRP 2D/3D game engine  https://hackage.haskell.org/package/fwgl-0.1.2.0 (ZioCrocifisso)
14:18:07 * hackagebot fwgl-glfw 0.1.0.4 - FWGL GLFW backend  https://hackage.haskell.org/package/fwgl-glfw-0.1.0.4 (ZioCrocifisso)
14:18:41 <rvxi> i'm trying to avoid python for scientific computing but stuff like vispy is really impressive
14:19:46 <nkaretnikov> I want weird control flow: https://gist.github.com/nkaretnikov/7ab0a48c9dc8eeecd4c1  I want the version of main that's below --, is it possible?  cont comes to mind, but I don't know how to do it offhand or whether it can be done at all.
14:20:16 <nkaretnikov> the reason is that 'f' is provided by a library, so I cannot change its definition
14:21:11 <Cale> nkaretnikov: Can you return a value from the loop (which might then contain the IO action with which to proceed)?
14:21:50 <orion> Is it a bad idea to declare an instance FromJSON [Foo]? Are FlexibleInstances bad?
14:22:20 <roboguy_> orion: why not just make instance FromJSON Foo?
14:22:22 <nkaretnikov> Cale: not sure, could you show some pseudocode?
14:22:51 <roboguy_> orion: there's already instance FromJSON a => FromJSON [a]
14:23:47 <indiagreen> orion: yes, it's a bad idea, due to a general instance already existing (as roboguy_ said)
14:24:02 <init> it'd need OverlappingInstances 
14:24:05 <init> which is, indeed, evil 
14:24:15 <orion> roboguy_: I am working with Facebook's graph API. When they want to return multiple objects, they do: { "data": [ object, object, object ] } But when they want to return only one object, they do: object
14:24:18 <Cale> nkaretnikov: I don't really understand what you're trying to do or what the types involved are well enough to actually write something too meaningful...
14:24:26 <nkaretnikov> :(
14:24:37 <roboguy_> init: I think that uses pragmas rather than an extension on 7.10 these days
14:24:42 <Cale> nkaretnikov: But I guess I could try. It would really help just to see real code instead of stuff with foo and bar in it.
14:25:07 <Cale> (or at least to know what 'f' is)
14:25:45 <Welkin> ((->) e) is confusing me, even though I have long ago written instances for it
14:25:57 <Welkin> if it is supposed to represent a "read-only" environment, why does it take a parameter?
14:25:59 <indiagreen> orion: really, just make a newtype and call it FBData or FBResponse
14:26:10 <Welkin> why not just have type e?
14:26:17 <indiagreen> it would be better *and* clearer
14:26:22 <init> Welkin: because it has to be explicit
14:26:32 <Cale> Welkin: hm?
14:26:36 <orion> indiagreen: ok
14:26:39 <init> Welkin: but still, it's just an analogy
14:26:49 <roboguy_> Welkin: well, you can only read from a parameter, not write to it...
14:26:55 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:26:57 <lambdabot>  ("hello","olleh","HELLO")
14:27:03 <Cale> ^^ does this example help?
14:27:47 <Welkin> hm, roboguy_ I see
14:27:49 <roboguy_> that's my favorite example I've seen for the reader monad
14:27:52 <roboguy_> still
14:27:57 <Welkin> Cale: was that for me?
14:28:00 <Cale> Welkin: yes
14:28:22 <Welkin> it is really the definition for <*> that is confusing me
14:28:35 <Cale> Don't worry about <*> until you understand the Monad instance
14:29:03 <nkaretnikov> Cale: sorry, I cannot show more at this point.  nevermind, I'll try to figure this out myself
14:29:36 <roboguy_> Welkin: have you typed out the specific type signature and moved the parentheses, etc?
14:29:36 <Cale> nkaretnikov: When f finishes, does it produce a result?
14:29:44 <Cale> nkaretnikov: What does its type look like?
14:29:52 <Welkin> @src (>>=) ((->) e)
14:29:52 <lambdabot> Source not found. You speak an infinite deal of nothing.
14:30:09 <Welkin> @src (>>=) Reader e
14:30:09 <lambdabot> Source not found. My brain just exploded
14:30:33 <Welkin> roboguy_: I get that part, that ((->) e) can be replaced by f
14:30:38 <Cale> (f >>= g) x = let v = f x in g v x
14:31:02 <roboguy_> Welkin: did you fully simplify the signature though?
14:31:15 <Welkin> I have
14:31:15 <roboguy_> if you just make that replacement without simplifying, it looks pretty confusing
14:31:28 <Cale> "running" a function in this monad means applying it to the overall function's parameter
14:33:33 <Cale> So (f >>= g) x, that is, (do v <- f; g v) x  will first "run" f, applying it to x in order to obtain v, and then it will "run" (g v) by applying it to x
14:33:53 <roboguy_> > reverse >>= (,) $ "hello"
14:33:54 <lambdabot>  ("olleh","hello")
14:34:14 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:34:16 <lambdabot>  ("hello","olleh","HELLO")
14:34:22 <Welkin> I think I see how it works now (at least for <*>)
14:35:22 <Welkin> given an environment, extract the value from the environment, then apply the function to that value, ut wrap it in a new environment
14:35:43 <Cale> What do you mean "wrap it in a new environment"?
14:35:56 <Welkin> a lambda with one parameter
14:37:58 <Cale> mf <*> mx is generally an action which will run both mf and mx, obtaining a function and an argument for it, and then return the result of applying the function to the argument. In this case, an action is just a function parameterised over a value of type e, and "running" an action means applying it to the parameter.
14:38:24 <roboguy_> Welkin: I usually find that look at a bunch of examples helps the most and the intuition comes later. Starting with intuition might be tricky
14:38:28 <Cale> So (mf <*> mx) e = mf e (mx e)
14:38:59 <Welkin> pure = const
14:39:02 <Welkin> according to the source
14:39:09 <Cale> Right
14:39:11 <Welkin> which makes sense
14:39:26 <monochrom> "run" as a verb, as "something to do", can mislead you a lot when the example you look at is purely functional and therefore there is nothing to be done.
14:39:37 <Cale> Perhaps
14:40:13 <monochrom> i.e., you will be looking hard for a description that says things like "perform this task, then perform that task, lastly add the finishing touch of doing this task", where there is none.
14:40:15 <Cale> In this case, it doesn't matter the order in which we "run" things, because obviously, the result of applying a function to the same argument is the same every time.
14:40:52 <monochrom> (f >>= g) *is* ((f x) & g) x. there is nothing to do. there is only a value.
14:40:59 <monochrom> err
14:41:02 <monochrom> (f >>= g) x *is* ((f x) & g) x. there is nothing to do. there is only a value.
14:41:18 <Cale> But still, I think it's easiest to start with understanding the do-notation example, and work back from there to the definition of (>>=) :)
14:41:23 <Cale> somehow
14:41:46 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello" -- I mean this example
14:41:47 <lambdabot>  ("hello","olleh","HELLO")
14:42:47 <Cale> It's sort of intuitive what's going on there: the argument to which the whole function has been applied, that is, "hello", is being distributed to each of the functions: id, reverse, map toUpper (and indeed, to return (x,y,z) as well, though return = const, so it is being ignored there)
14:43:06 * hackagebot highjson 0.1.0.0 - Very fast JSON parsing  https://hackage.haskell.org/package/highjson-0.1.0.0 (AlexanderThiemann)
14:43:08 * hackagebot bake 0.4 - Continuous integration system  https://hackage.haskell.org/package/bake-0.4 (NeilMitchell)
14:43:46 <monochrom> and "((f x) & g) x" is much simpler and cuts to the mustard than "unwrap this, do that, wrap again" which is exactly trying too hard to look for a task to perform.
14:44:30 <Cale> Yeah, I wouldn't ever say the word "wrap" as part of this discussion
14:44:38 <Cale> In fact, I hate that word in general.
14:44:45 <Cale> It's so rarely appropriate.
14:45:01 <davidfetter> how about rap?
14:45:58 <Cale> The computational analogy does work here though. We could also use the container one :)
14:46:30 <Welkin> :t (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))
14:46:31 <lambdabot> [Char] -> ([Char], [Char], [Char])
14:46:36 <Cale> Thinking of a function e -> a as being like a giant box indexed by values of type e, having in each cell, a value of type a
14:47:24 <Cale> and then return v is the container which has v in every cell
14:48:54 <roboguy_> It can be tempting to abuse the Applicative instance of ((->) e) sometimes
14:49:16 <Welkin> :t \e -> id e >>= (\x -> reverse e >>= (\y -> map toUpper e >>= (\z -> return (x,y,z))))
14:49:17 <lambdabot> [Char] -> [(Char, Char, Char)]
14:49:17 <monochrom> yeah, e->a is an array or dictionary, key type e, value type a
14:49:42 <Welkin> :t \e -> id e >>= (\x -> reverse e >>= (\y -> map toUpper e >>= (\z -> (x,y,z))))
14:49:43 <lambdabot>     Couldn't match type ‘(,,) Char Char’ with ‘[]’
14:49:43 <lambdabot>     Expected type: [Char]
14:49:43 <lambdabot>       Actual type: (Char, Char, Char)
14:51:04 <Welkin> :t \e -> id e >>= (\x -> reverse e >>= (\y -> map toUpper e >>= (\z -> return (x,y,z))))
14:51:05 <lambdabot> [Char] -> [(Char, Char, Char)]
14:51:07 <Welkin> :t (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))
14:51:08 <lambdabot> [Char] -> ([Char], [Char], [Char])
14:51:13 <Welkin> hm, what is wrong here
14:51:23 <Cale> You don't need the e
14:51:38 <Cale> @undo (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))
14:51:38 <lambdabot> (id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z))
14:52:02 <Welkin> :t id >>= (\x -> reverse >>= (\y -> map toUpper >>= (\z -> return (x,y,z))))
14:52:03 <lambdabot> [Char] -> ([Char], [Char], [Char])
14:52:21 <roboguy_> Welkin: the right hand argument of (>>=) must take a two argument function, for this instance
14:53:00 <Cale> Welkin: You were accidentally using the list monad
14:53:02 <roboguy_> well "two argument"
14:53:53 <Cale> If you want to be using the function monad, your computations need to be functions.
14:53:59 <Cale> (In this case, functions of strings)
14:54:26 <Welkin> :t \e -> reverse e (id e)
14:54:27 <lambdabot>     Couldn't match expected type ‘[a] -> r’ with actual type ‘[a]’
14:54:28 <lambdabot>     Relevant bindings include e :: [a] (bound at <interactive>:1:2)
14:54:28 <lambdabot>     The function ‘reverse’ is applied to two arguments,
14:58:06 <roboguy_> > ((&&) <$> even <*> (<10))  6  -- This is the sort of thing I'm always tempted to do with Applicative ((->) e)
14:58:07 <lambdabot>  True
14:59:51 <Welkin> something that always bothered me about Reader was the fact that it is defined using a newtype wrapper
15:00:29 <roboguy_> why does that bother you?
15:00:32 <Welkin> particularly in this NICTA course (where they like to rename everything) they left it naked, as ((->) e)
15:01:36 <roboguy_> the main reason for that, as far as I know, is to make it a monad transformer
15:01:38 <Welkin> because all of the explanations of Reader use the newtype wrapper
15:01:48 <Welkin> not a single one explains it without
15:02:50 <Welkin> so, I still don't feel confident in my understanding of reader
15:03:55 <roboguy_> It's the same thing though, really. Maybe it's supposed to help you "campartmentalize" the idea or something like that, but I don't use the newtype wrapper when I explain it
15:04:25 <Welkin> how would you define (>>=) for it then?
15:04:33 <roboguy_> what do you mean?
15:04:42 <roboguy_> You unwrap and then rewrap it
15:05:34 <Welkin> you cannot pattern match on it
15:06:16 <dibblego> Welkin: nothing in NICTA/course is renamed. It used to be though.
15:06:29 <Welkin> dibblego: flatMap?
15:06:33 <dibblego> ((->) e) is a typical name.
15:06:40 <dibblego> Welkin: ok sure, a few things are.
15:07:06 <dibblego> ((->) e) has a Monad instance in Control.Monad.Instances
15:07:13 <Welkin> actually, they use ((->) t), but that is beside the point
15:07:26 <dibblego> that's just the name of a type variable
15:07:51 <roboguy_> Welkin: you can if you want to
15:07:54 <muzzle> Hi, so I'm working on a library that can monitor filesystem changes (new files, deleted files, etc) and I want to include an executable that can run an arbitrary command once there is a change. I would be interested in what features you would also like to see in something like that. You can use it e.g. for recompiling when a source file changes.
15:08:07 * hackagebot api-builder 0.9.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.9.0.0 (Intolerable)
15:08:47 <Welkin> roboguy_: I tried
15:08:49 <Welkin> it never worked
15:09:38 <dibblego> Welkin: are you in Australia? I am at an airport now, going to Melbourne, to run the course in person.
15:09:54 <dibblego> Welkin: the "reader monad" has an explanation, but it's more a verbal exchange
15:10:21 <dibblego> it's all about the kinds
15:10:33 <Welkin> dibblego: no, in the US
15:10:52 <dibblego> ok, when I get a sec, I will call you and explain reader, k?
15:12:27 <Welkin> okay
15:12:50 <monochrom> the NICTA course has to rename everything to avoid name clashes with the Prelude
15:13:08 <dibblego> Prelude is hidden. It used to be in scope and renamed.
15:13:13 <roboguy_> Welkin: http://lpaste.net/136933
15:13:14 <dibblego> (>>=) is overloaded
17:18:49 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
17:18:49 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
17:18:49 --- names: list (clog sinkensabe ens_ AndroUser2 netj brantje1 j4cknewt creichert whiteline Literphor GeissT xeno rvxi amiri dot_Laptop eigensheep thimoteus Zanzare z5h adam_hardkey_shi zipper roboguy_ huserl jlang0 L8D latro`a_ S3thc0n raichoo predator117 sp0on adek tripped pgokeeffe michaelavila reduceleft divinegod pacak lspitzner exferenceBot hexagoxel funfunctor subleq__ timemage enaqx CindyLinz slack1256 _flow_ nrk- tinyblak cross brezel tamasgal dan_f c-rog hzjd teclo-)
17:18:49 --- names: list (michaelneale blue_deref CMCDragonkai nkhodyunya C4Cypher conal tvh ValicekB centrinia Eldrad heyj ubitux jbhatta marek_varro egis gothicsouth MrWoohoo lkba whaletechno xinming lvh sujeet tuv armyriad miscyb skeet70_ Goplat` petermw BallmerPeak_ jabesed erikd ndrei Spinfuzor aib killerswan martinbjeldbak Welkin FireFly fuzzyhorns muzzle bergey OrangeShark bitwiggler tabemann clynamen s00pcan P1RATEZ natanjmai MoALTz orbitalo rcyr NeverDie godel MrScout rmlhhd)
17:18:49 --- names: list (Perdulous yfeldblum argent0 yrdz fizbin nekomune dustinm Ulrar paf31_away yqt _sjs vili davidfetter turtil marchelzo_ sgwizdak dhil emanuelz alexa_ j201 Swizec Kluns pavonia cchalmers rstone chromatome Sixmsj aidanh kosorith fengshaun dhrosa licensed Lokathor ellipsis_ fishburne skyres bufferloss rasen _ashbreeze_ nocturne777 Sorella robogoat thetallguy sleblanc hiptobecubic tiler Tesseraction triliyn bobvh ceii joneshf-laptop tmtwd Stratege sepp2k tg dwins)
17:18:49 --- names: list (hprincip joshc mada c_wraith codesoup jud solrize catsup stoopkid Noldorin deam Oxyd prkc mjo rrbm823 ronh obadz johtso dxld Wizek__ vin-ivar rgr tomh- Rastus_Vernon jinblack_ nshepperd mountaingoat maartyl entity abra0 frodwith ropav jaen jrslepak acidjnk sdothum lyxia Gurkenglas poga Jellydog geekosaur plutoniix byaruhaf mcbonz ClaudiusMaximus silver nkartashov xahry beckyconning_ xintron RegEchse u-ou mauke indiagreen sprang Guest67851 SoupE dibblego)
17:18:49 --- names: list (hackagebot Ralith DenSchub nisstyre phaskell Qfwfq quaestor xacktm kyren rcsgns bgamari- bgamari otto_s_ jedws orcus xificurC zaquest ryantrinkle chishiki mach atomi grohne ion junmin_ OmnipotentEntity cscorley permagreen mattp_ wagle verement icicled torpig sivoais noteness adlan chrisdotcode prophile Deadhand louispan_ rabbidrabbit psy_ vmeson tromp FreeFull ninegrid lexi-lambda kawaii-imouto nakal_ Paradisee wat pavlicek stelleg mpereira eslammostafa)
17:18:49 --- names: list (thunderrd Pamelloes flori dcoutts augur petercommand brixen kini lokulin kaste Quashie_ fikusz PlasmaStar tazjin emlun benonsoftware shesek _deepfire boj cyborg-one ThreeOfEight Saimeidae michaf hiberno thorkilnaur_ eazar001 DrCode isocliff_ gnusosa skulls prosodyContext otjura telser h4nnibal seangrove Sonderblade citizen11 gfixler gws comboy code_crimes eamelink dgorbik_ Encapsulation jordanl pikhq WashIrving Jonno_FTW sys9mm micro_ dgonyeo- dgonyeo ph88)
17:18:49 --- names: list (boris`` uber Jesin ybian SegFaultAX drewdavis Cr8 wizzo Hugglesworth acfoltzer jrib Tourist|AFK balaji wzjke vikraman Xnuk ruukasu gmaslov mceier jlyndon Tritlo lancetw sephiap samertm CLaxware steshaw jkarni1 lala seabre bitemyapp codyopel lyonsb Or1 jang1 loor rossberg cdidd leino newsham vemek nuttycom wedens elementalest_ sweater juri_ Limezacore arahael rootnode oish zinfandel Elsi ij burp emik senseibaka ring0` noexcept mitchty andyo noteventime joco)
17:18:49 --- names: list (sewilton besenwesen d-snp dalmahal ghorn ljhms fr33domlover R0b0t1 biscarch JonasH__ bcavalier nbouscal shennyg jroesch Xorlev lacrosse andreypopp_ Internet13 cstrahan jamiis noplamodo dju kalz Polarina drdo Cale fling carter_cloud lahwran rul peddie dicioccio1 tarcwynne_ aaron7 chelfi fnordbert coeus_ mietek GHCI hc pfoetchen Drezil tomphreek hx_ KaneTW Taneb quicksilver eyck Walther n1ftyn8_ xiphos_ Dodek whoops Boreeas Atlanis ParahSailin_ iyzsong brotknust)
17:18:49 --- names: list (znutar ilmig_ ww_ phuu freusque_ mankyKitty joedevivo cnf dsantiago hamishmack abh tomboy65 earldouglas qnikst peterbat pdxleif dgorbik ousado staffehn esssing Natch Noinia grol etabot maerwald abbe yac Haskellfant helgar kaol flx_ flux cyphase moonlily platz srcerer wtw nwf theDon jo__ fiddlerwoaroof ChongLi ryankarason heath xelxebar shachaf carc sbauer322 usr kongo2002 mtbottle Artpicre dabradley mkollar farn lattenwald Enigmagic gargawel thelastinuit k1i)
17:18:49 --- names: list (fryguybob frontendloader jmct mimi_vx dschoepe mirsal Moggle dolio vodkaInferno spindas tswett therealklanni thomas optocoupler yarou tgeeky relrod eddsteel ahungry Klumben serutsubi ggherdov zero7 Heero glowcoil trig-ger dlackty___ hoey_ _6a68 shelling__ pchiusano folsen zrl joeyadams spdionis ayberk stasku wizonesolutions anttih jonrh NemesisD doppioslash yminsky otherchas_ rfw reem si14 edwardk sweenzor S11001001 bitonic mrsolow nrw peterood c9sould__)
17:18:49 --- names: list (puzza007 rslima nmenne recycle`` jfokkan yrashk chriswk lambdahands idnar IbnFirnas jonathanj_ mno2 MMuse_______ mystor ehamberg milessabin Raynos kjnilsson mrb_bk alphonse23_ ocharles_ bsummer4 cojy kanak lohkey PotatoGim bkolera hellschreiber dstockwell alekst_ akahn bigs joco42 seancorfield aloiscochard sclv nkpart posco mindos_cloud____ mbrcknl alexlord AlainODea perrier tv Orwell84 pygospa aupiff_ aupiff jakutis klarrt arkeet canta davean janne phadej_)
17:18:49 --- names: list (flaiw AntiSpamMeta cheater lf94 sh1ken __main__ l3france mmaruseacph2 DT-sama julm chirpsalot Chobbes crough atn34 boot13 zymurgy AlexStraunoff themagician martingale bananagram dario` hodapp malllle jokester keko_ lieven sbrg djanatyn martinhath max-m qz gbarboza dami0 dmiles_afk akurilin michaelpj gienah CoconutCrab dogetime keix anoe melter Soft jcurbo hbar Th0mas_ amiller Sornaenst drbean_ PHO_ eagleflo Mandus zyoung_ marens_ joehh1 bcoppens TimWolla)
17:18:49 --- names: list (sunnavy_ haroldwu_ Biohazard_ wrengr_a1ay brotknus- Tehnix Flonk StoneToad Kharn hsyl20 rola defanor PpPyg fl3 edk nopf asjo milli MarcelineVQ davesilva jle` otterdam mt integral Nik05 greymalkin jameseb Guest20390 falafel ixian dropdrive voidzero maw ricardo82 solarus ahihi nullvoid8 Entroacceptor cow_2001 tumdedum thomassgn Fuuzetsu mrmyers emmanueloga fuziontech seanparsons dh myfreeweb moy srid avdi zpconn__________ RGamma albel727 brennie raid SuperTux88)
17:18:49 --- names: list (xxpor lpaste_ sunfun paperManu_ mjrosenb derekv2 Diabolik condy lamilami dpn` drone- KorriX dwoos geekingfrog julienXX ThePhoeron _ikke_ froztbyte absence zerokarmaleft jaspervd1 maurer larsen__ Adios_ AshyIsMe `0660_ runde_ module000 marko__ dgvncsz0` Khisanth benzrf japesinator sw1nn avn MitchW jasu0 haBuu^ timothyh Sigyn bernalex jtobin tilpner Thra11 hiratara hpd sLite spanner supki saurik MasseR yusukesuzuki Yaiyan nille Iceland_jack ortmage josephle)
17:18:49 --- names: list (andrewalker jaffachief so erhandsome @ChanServ Ke Rembane cYmen_ niluje jayne sgronblo init vladan lenstr oconnore Reyu jstolarek Eliel arianvp myme ndeine ibid dexterph linduxed Fylwind KitC kandinski davl_ greeny mrshoe dilinger magicman OutlawStar dmilith mortberg kosmikus jpiche d3lxa ahf machineslearn alynn hyPiRion dreamdust jlouis oherrala iteratee e4x_ tumdum Eagle_Erwin SHODAN agrif orbekk thebnq aristid tomaw monsieurp erg eivuokko xxx monty)
17:18:49 --- names: list (thorsten` Adeon zenzike Fubar^ bjornars diginet LeaChim_ dredozubov DigitalKiwi lispy eikke sys carter sellout annulus Uritomi2 noctux zeroskillor edran Tene BillyIII_ TallerGhostWalt malglim Watcher7_ vpm mero igniting Guest90609 hrnz Deewiant Profpatsch pmade amontez_ Ezku_ RlyDontKnow mikeplus32 numberten koomi tolt brent80_plow Guest83834 statusfailed bergmark bshelden ice799 wayne eyenx brolin_empey saiam Kneiva ackthet radens yukonjack surtn JamesJRH)
17:18:49 --- names: list (cjh` ziman mechairo` thoughtpolice mikedanese caasihuang kmicu Phillemann gabiruh_ Dykam_ wenzowski sleepynate jrp6 Cerise brackets krgn jix_ adarqui gdsx_ rs0 sunnymilk osnr callumacrae Gothmog_ Pucilowski_ sdboyer cjwelborn wolf_mozart skarn_ Tiktalik Guest70208 _di BrianHV mitu liyang s4msung bydo sokoll bbee fold alpounet Sagi mpickering ephemeron cameronfr electrogeek seliopou pingu hegge rudi_s Bigcheese PinealGlandOptic rhaps0dy honza killerpty Forkk)
17:18:49 --- names: list (kriztw pyrtsa ido s1n4 scpike pharpend tridactyla kaw_ marienz zyla pieter ski itsmonktastic funrep WSergio henryhere averell SLi sm Hijiri nemesit|znc Brando753 arch_ CosmicRay jb55 wto drmegahertz Laney _fritz_ DanZimm Desoxy kloeri naudiz lykkin nathan7 demolithion djh benbangert Vbitz sevcsik shiona pfeyz mgaare chandankumar Ornedan Pennth Rutger` ashleyis opqdonut aweinstock tnks tdammers robbert kwantam codahale mlen darkowlzz|afk stiell ft)
17:18:49 --- names: list (constantinexvi Ptival spwhitt narendraj9 hemite lpsmith SparkySparkyBoom Jorgon thomie avocado owa zeiris RayNbow`TU shirt MK_FG buoto spaceships ollef Nimatek gridaphobe jbalint aaronm04 sabauma Schrostfutz_ simon _klm lassulus JPohlmann jlind_ zomg Baughn_ Maxdamantus Saizan scopedTV_ dlundy_ phaazon liff ec\_ xnyhps OliPicard alevy- fall__ aatxe kirjs________ anachron shwouchk zz_rabisg DANtheBEASTman mak` Twey ircbrowse cin_ pharaun benwf haasn da-x kvalle)
17:18:49 --- names: list (fergusnoble ChristianS kqr lsep ezrios chuy gbiv flebron GGMethos runeks timloh psacrifice LnL themasterchef [swift] wjm mikeizbicki hiredman ReinH andrewsw betawaffle dqd tristero Freundlich harski unsymbol LordDeath abrar kjanosz cow-orker stbuehler sagelywizard kvieta fmapE dunj3 notOnIRC joeyh mokus tomku ScRaMbLe zhulikas_ rbocquet xplat eL_Bart0 hvr srhb boxfire levi neki fionnan doctorin1 knyppeldynan shapr Guest34843 RazorX Tazca AWhetter tzaeru tekacs)
17:18:49 --- names: list (yorick rphillips EnergyCoffee mendez slasktask bonobo_ Blkt_ codehero Intensity alang roo iross tomjaguarpaw Jello_Raptor petantik jaseemabid_ dino- kidnapped_robot Starfire meretrix chaptastic irishsultan barrucadu osfameron ttuegel samgd viitap Phlogistique bjobjo chris2 happy0 majoh Zemyla Philonous hive-mind M-ou-se mrowe_away bolmar dan64 David cods mniip Erebe lusory ElderFain oberstein rj-code jnoah cursork Reiser sohum sea-gull JZTech101 kaictl kgadek)
17:18:49 --- names: list (zimbatm noddy gothos moop seagreen pleiosaur rom1504 PigDude Draggor monochrom kess luzie Kruppe darthdeus royadav subleq gcollins cbm80 Axman6 pranz sinopeus_ klugez agjohnst valdyn erethon gratimax Boney niklasb fugyk dp_wiz cmn cpup orion yeltzooo Wamanuz earthy WelpAnon arcanine CARAM__ jmcarthur notdan zacts adnap tsani frawgie_ gsingh93 lyddonb TRManderson low-profile reynir certainty Proteumus ps-auxw dfranke milesc22 Myrl-oneechan blue_feint conehead)
17:18:49 --- names: list (crixer brisbin alem0lars lachenmayer alanz killtheliterate taksuyu bsmt spacebug Xe adamse schoppenhauer reqq456 chattered greenskeleton ajp lstrano keaml tomasos__ ma82 deni hausdorff jacksnipe Plastefuchs bob_twinkles przembot lambdabot _rgn jvd keemyb pm5 RageD technomad hpc bjorkintosh hongminhee dzack Chousuke lokydor jlewis andjjj23 Lemmih rowanblush statusbot cbaines Willis mathu s_e otulp jorj cschneid irclogger_com zxtx_ Jaxan Nickeeh ]OLI[ Guest39551)
17:18:49 --- names: list (Liskni_si mgomezch z16 DrAwesomeClaws rofer nurupo nyuszika7h ipuustin felixsch inr fractalcat padre_angolano banjiewen Voldenet tessier saep infinity0 Lutin` joehillen hattusili_III nicola rdema RevJohnnyHealey geal pgorla int-e cryon elgot asm89 TDJACR dixie liste felixn endojelly Igloo steinar_ spion fyolnish Geir dmwit DustyDin1o loz-- Zekka kakos taruti elben Razz paul01_ eevar_ nesqi huonw troydm ctag mephx orzo zq SwashBuckla tedkornish mrd kragniz eyem)
17:18:49 --- names: list (AustinMatherne tlevine obcode Hafydd Clint fall` kriwil zso koala_man ggreg swistak35 stass cpa apo_ sajith friden soija stomp mami cjay ByronJohnson Ankhers solirc andreass_ luite ernst mads- cynick Jaak tero- joeytwiddle buttproblem BlakeRain karshan adimit ephess Draconx derekbrown hator Spockz jackhill Dtgr rseymour sebastard akuhlens capisce porglezomp bartavelle ajf epta xandaros rossimo MindlessDrone natte uwap nathanic Factionwars unknownloner gseitz)
17:18:49 --- names: list (corso SaidinWoT obiwahn horlicks_ xaimus iDavid hanDerPeder sdx23 schlumpi karls Belgarion0 Athas kipras`away Cathy tych0 somenick sku1d stvc deavid Vq neanias ivan\ gpampara nitrix XMunkki etrepum arnihermann Bane^ zph bgyss tinchos dkua niko)
17:52:40 <mada> :t const
17:52:41 <lambdabot> a -> b -> a
17:57:01 <subleq__> roboguy_, if you're still around, I think I am able to do my bash thing with operational
17:57:49 <lpaste_> subleq__ pasted “bash operational” at http://lpaste.net/136942
18:04:22 <funfunctor> Anyone know how these Splice things work in Snap?
18:04:45 <subleq__> operational is pretty darn cool
18:04:55 <subleq__> Although how does it and free compare?
18:04:55 <funfunctor> well technically more to do with Heist https://hackage.haskell.org/package/heist-0.6.0.1/docs/Text-Templating-Heist.html#t:TemplateState
18:05:07 <subleq__> I can't seem to grasp free but operational is super easy
18:13:53 <Gurkenglas> @letlpaste 136945
18:13:54 <lambdabot>  Defined.
18:13:59 <Gurkenglas> There we go. http://lpaste.net/136945
18:14:09 <Gurkenglas> > abc
18:14:10 <lambdabot>  <Moonoid [Char] -> [Char]>
18:14:53 <Gurkenglas> > abc (Moonoid [] (++))
18:14:54 <lambdabot>  "abc"
18:15:46 <Gurkenglas> Dang, wrong channel.
18:15:52 <hiptobecubic> cool feature
18:16:10 <Welkin> I see
18:18:38 <benzrf> :t (return :: a -> IO a) (++"foo")
18:18:39 <lambdabot> IO ([Char] -> [Char])
18:18:41 <benzrf> erm
18:18:43 <benzrf> > (return :: a -> IO a) (++"foo")
18:18:44 <lambdabot>  <IO ([Char] -> [Char])>
18:18:48 <benzrf> ah, parens
18:23:15 * hackagebot inflections 0.2.0.0 - Inflections library for Haskell  https://hackage.haskell.org/package/inflections-0.2.0.0 (jsl)
18:23:17 * hackagebot twitter-feed 0.2.0.0 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.0 (jsl)
18:29:41 <subleq__> where does the name coyoneda come from?
18:37:07 <timemage> subleq__, "A covariant Functor suitable for Yoneda reduction";    Yoneda lemma;   Nobuo Yoneda apparently.
18:56:00 <saulzar> The elm todomvc benchmark seems pretty good at finding event ordering bugs!
18:56:07 <saulzar> Oops. Wrong channel
18:56:55 <dominik> Hey Haskellers
18:57:50 <dominik> I'm a newbie and I was wondering how can the function sequence :: (Monad m) => [m a] -> m [a] ensure that the actions are evaluated left to right?
18:59:19 <dominik> all I see is that it is implemented with a right fold which, if I do the evaluation right, will, eventually evaluate to: sequence [m1, m2, m3] ==>* m1 `k` (m2 `k` (m3 `k` return []))
18:59:43 <dominik> however, why does this guarantee that the actions are evaluated left to right?
19:00:16 <dominik> for instance, what prevents the compiler from first evaluating the inner (m3 `k` return []) first?
19:01:02 <geekosaur> @src sequence
19:01:02 <lambdabot> sequence []     = return []
19:01:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:01:02 <lambdabot> --OR
19:01:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:01:30 <geekosaur> either way it's going through >>= which forces the sequencing if the monad does (and in many cases, sequencing is the reason it's a monad)
19:05:39 <sccrstud92> does V.fromList [1..n] build the whole list in memory?
19:06:36 <benzrf> dominik: sequence isnt about evaluation
19:07:02 <benzrf> dominik: it puts the /effects/ in order (inasmuch as values in a monadic type carry 'effects')
19:07:26 <benzrf> dominik: like how concat puts the elements of the lists in order, even if it doesnt guarantee which order they are eval'd in
19:07:44 <dominik> hmm, ok.
19:08:00 <dominik> but still, how does >>= guarantee ordering? 
19:08:08 <dominik> err sequency
19:08:39 <dominik> I mean do I understand it correctly, that no matter how you evaluate it, the order will be left to right?
19:09:50 <geekosaur> usually by some data dependency
19:10:18 <geekosaur> where the result of a later one depends on the result of an earlier one, so the earlier one must be executed first
19:11:10 <c_wraith> dominik: it doesn't necessarily guarantee ordering.
19:11:19 <geekosaur> (in GHC, the IO machinery carries around a hidden "baton" that is passed to and returned from every I/O action, the monad machinery makes sure it is passed and captured on return, and the resulting data dependency forces actions to be executed in sequence)
19:11:32 <geekosaur> (other compilers do it different ways)
19:12:51 <dominik> c_wraith: what do you mean?
19:12:56 <c_wraith> > evalState (let go = do x <- get ; modify (+1) ; xs <- go ; return (x:xs) in go) 0  -- dominik - this doesn't eval things in the order (>>=) would dictate.
19:12:57 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:12:59 <dominik> geekosaur: yea, I read about that
19:13:17 <c_wraith> dominik: oh, if you meant IO specifically, then (>>=) works like geekosaur says
19:18:43 <mniip> all IO actions take such a baton as an argument and return it in a tuple with the result (akin to state). All good actions force the input baton before executing, and finish execution before providing the baton
19:19:12 <mniip> the baton is zero-cost because it vanishes at Cmm (I think?) state but the demand semantics remain
19:19:16 <c_wraith> the best part about that is that the baton doesn't really exist.
19:19:33 <c_wraith> Yeah, it has to be present in the STG stage
19:19:59 <mniip> oh yeah
19:20:30 <mniip> it vanishes when argument passing an returning conventions are calculated
19:21:20 <mniip> neat trick
19:21:58 <mniip> oh yeah and
19:22:10 <mniip> exaples of bad IO actions
19:22:18 <mniip> hGetContents
19:22:27 <mniip> interact
19:22:38 <c_wraith> don't forget readFile
19:22:56 <mniip> yeah that too
19:22:57 <subleq__> Why do I need FlexibleContexts for allocateVar :: (MonadState Integer m) => m Var
19:23:08 <geekosaur> or, cutting to the chase: unsafeInterleaveIO
19:23:08 <mniip> subleq, because MPTC
19:23:09 <c_wraith> subleq__: because of the Integer part
19:23:34 <c_wraith> subleq__: Without FlexibleContexts, the type arguments to a class must all be type variables
19:23:37 <Gurkenglas> Is interact bad because of getContents or putStr?
19:23:44 <geekosaur> getContents
19:23:50 <geekosaur> which uses unsafeInterleaveIO
19:23:54 <geekosaur> which si the real evil
19:24:13 <Gurkenglas> Where is it defined?
19:24:29 <mniip> GHC.IO
19:24:39 <Gurkenglas> Oh wait there it is. Weird that I didnt see it with ctrl-f
19:24:41 <mniip> it's hard to understand though
19:25:33 <mniip> I'll save you time
19:25:35 <mniip> unsafeDupableInterleaveIO (IO m) = IO (\s -> let r = case m s of (# _, res #) -> res in (# s, r #))
19:26:16 <subleq__> Is there any problem with enabling FlexibleContexts?
19:26:24 <c_wraith> subleq: No.  It's entirely harmless.
19:26:26 * Gurkenglas reads first line of http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-IO-Handle-Text.html
19:26:29 <c_wraith> err.  subleq__ 
19:26:35 <Gurkenglas> "{-# LANGUAGE Trustworthy #-}" suuuuure
19:27:58 <subleq__> ok thanks c_wraith 
19:28:14 <c_wraith> subleq__: it's behind an extension because the haskell specification doesn't allow it.  It turns out it's easy, useful, and harmless.
19:29:57 <geekosaur> basically the haskell language definition is *extremely* conservative. and tried to keep things simple to make it easier for there to be other implementations (not that that ever worked out...)
19:32:48 <c_wraith> Admittedly, it's a lot *more* useful when you also have MPTCs, which are more controversial
19:33:45 <orion> :t (<>)
19:33:46 <lambdabot> Monoid m => m -> m -> m
19:33:56 <orion> What is that called? ^
19:34:27 <ttt_fff> benzrf:
19:34:33 <ttt_fff> how is haskell in a spreadsheet coming along?
19:34:40 <c_wraith> :t mappend
19:34:41 <lambdabot> Monoid a => a -> a -> a
19:34:55 <c_wraith> orion: usually it's called mappend, because it's just an infix version of it.
19:35:01 <c_wraith> orion: though I've also seen things like "box"
19:35:20 <orion> I see.
19:35:30 <benzrf> ttt_fff: not at all
19:35:33 <benzrf> :>
19:36:31 <ttt_fff> awww
19:37:27 <benzrf> well
19:37:33 <benzrf> i could probably make something shitty fairly quickly
19:37:42 <benzrf> but something nonshit would require a lottt of thought
19:44:30 <ttt_fff> benzrf: the greatest performance improement is from non-existent to shitty
19:44:40 <dominik> geekosaur, benzrf, c_wraith, mniip: ok
19:44:49 <dominik> thanks for all your answers :)
19:44:51 <benzrf> ye but whatever shitty thing i make would not be something you can build something nonshit on
19:44:56 <benzrf> youd have to throw it out
19:45:00 <benzrf> nd start over
19:45:44 <ttt_fff> benzrf: if you build a shitty version, and it tortures you at night thinking about how shitty it is, and forces you to build a non-shitty version, taht'd work too
19:46:02 <dominik> so can I say that since the IO monad acts kind of like a state Monad this ensures sequency of >>= and hence sequence, etc.?
19:47:32 <dominik> I mean, even though there is no guarantee on how things evaluate, eventually all >>= will need an initial world in order to proceed.
19:48:07 <dominik> and then this world is passed according to the definition of >>= for IO from the first bind occurence, to the second, and so on, and that is how sequency is ensured
19:48:21 <dominik> is this the simple picture? :)
19:48:28 <ttt_fff> the way that I understood monads
19:48:37 <ttt_fff> (and this took me a while becuase despite people telling me, I continued to ignore it)
19:48:54 <ttt_fff> is to (1) say "FUCK INTUITION", (2) read the type signature, and (3) understnd monads
19:49:14 <ttt_fff> in particular, it's helpful to read the source of >>= / return
19:49:36 <init> it's more helpful to try to write the implementations without looking at the source but the types, too :)
19:49:44 <init> (and the monad laws)
19:49:58 <ttt_fff> yeah, what init said is better
19:50:17 <ttt_fff> so here's waht you want to do (1) look up documentation on statemonad (2) copy down the type signatures, and (3) try to figure out how to impelment >>= and return on your own
19:50:28 <ttt_fff> and then .... BAM .... you get monad brain cells
19:50:34 <ttt_fff> and you start seeing monads everywhere
19:50:38 <ttt_fff> it's like that scene in the matrix
19:50:42 <dominik> hahaha, yea I did it already :)
19:51:16 <dominik> that's why I'm asking if I can think of IO as sort of a state monad and whether this is the reason for IO's sequency
19:51:22 <ttt_fff> domink ++
19:51:24 <ttt_fff> @karma dominik
19:51:24 <lambdabot> dominik has a karma of 0
19:52:23 <ttt_fff> i guess you can think of "IO a" as "State THE-F*CKING-WORLD a" i.e. a state monad where the state is the entire world
19:52:31 <ttt_fff> @karma init
19:52:31 <lambdabot> init has a karma of 1
19:52:35 <ttt_fff> @karma ttt_fff
19:52:35 <lambdabot> You have a karma of 1
19:52:51 <init> dominik: I would try to look at it axiomatically
19:53:13 <benzrf> dominik: dont think of IO as state!
19:53:22 <benzrf> the 'pass the world' thing is not super helpful
19:53:30 <init> dominik: the State# RealWorld# hack is just a hack 
19:53:38 <benzrf> dominik: instead, think of it purely as descriptions of effects
19:53:54 <ttt_fff> benzrf: are we disagreeing?
19:54:01 <benzrf> ttt_fff: no, just dogpiling
19:54:02 <ttt_fff> I challenge you to a arm wrestling contest
19:54:19 <benzrf> dominik: imagine that a value of type 'IO String' is secretly the code for a shell script whose output is the result of the action
19:54:33 <benzrf> dominik: and then (>>=) makes a new script by mashing pieces together
19:55:41 <Cale> dominik: I'm fairly sure there's no state type which would actually make it work correctly as a state monad, even if we assume that there can be some external interpreter that will make things happen, and that the lazy state monad is used. Concurrency in particular throws a monkey wrench in that kind of representation.
19:57:23 <Cale> It's better to think of it as something like a free monad over a type with a bunch of primitive commands (which includes enough to represent arbitrary FFI calls). Even if that's not how GHC does things, it's possible to do it that way without as much hackery.
19:59:24 <benzrf> Cale: not sure that dominik knows about free monads :>
20:02:11 <dominik> haha, no, I don't :D
20:03:18 <dominik> hmm, ok, recipe for a computation...
20:05:07 <Cale> Yeah, if you don't know what free monads are, don't worry about it. Just think of it as if there are a bunch of primitive IO actions and then ways to glue them together into larger actions (which includes the monad operations among other stuff)
20:05:59 <Cale> and an action of type IO t is just a description of something which could be done (and have effects) in order to produce a result of type t, provided that it finishes normally
20:06:44 <Cale> (as opposed to running forever or throwing an exception or something)
20:10:27 <dominik> Cale: hmm, ok. And when gluing descriptions together using >>=, e.g., m1 >>= \x -> m2 >>= \y -> m3, this creates a big recipe that has a notion of sequecy, i.e., m1 is executed before m2, which is executed before m3
20:11:02 <dominik> I mean the big description basically describes to first execute m1, and then m2, and only at the end m3
20:11:11 <dominik> is that adequate thinking?
20:14:27 <Cale> dominik: yeah
20:14:39 <dominik> ok, thanks
20:14:46 <dominik> :)
20:14:51 <Cale> dominik: Well, which thing should happen second actually depends on the result of m1 in the case of >>=
20:15:48 <Cale> (i.e. m2 and m3 there can actually have occurrences of x in them)
20:16:05 <Cale> That's what >>= gives you over >>
20:16:39 <dominik> ok, I see. You mean in m1 >>= \x -> m2, the m2 can depend on the value of x?
20:17:06 <dominik> or put differently, depending on what x m1 yields, you may choose to execute a different m2?
20:18:45 <dominik> and is this the additional power that Monads (specifically >>=) have over Applicatives, where you cannot adjust a future context based on what value you get from a previous computation?
20:19:06 <Cale> yeah
20:19:07 <init> dominik: yes, exactly
20:19:25 <dominik> ahhh, awesome, ok.
20:21:23 <dominik> so basically in m1 >>= \x -> m2, m2 may depend on the concrete shape of x and hence the computational context of m2 may be completely different depending on x. However, in m1 <*> m2 the contexts of m1 and m2 are fixed and all we can do is to apply m1's result to m2's result.
20:22:26 <dominik> I guess this elaborates a little more of what I understand from the difference between Applicative's and Monads.
20:35:36 <nitrix> How were the days in Haskell before Monad?
20:37:51 <Cale> nitrix: If you're interested in how IO was done, you can look at the old pre-1.3 Haskell Reports. You defined a lazy function [Response] -> [Request]
20:39:11 <SparkySparkyBoom> i've got two types with common fields
20:39:43 <SparkySparkyBoom> ive also got a function that operates on these fields
20:40:17 <SparkySparkyBoom> in java, i would have the function take a superclass of the two types
20:40:46 <Cale> You can define a third type which has that subset of the fields, and include a value of that new type instead of directly having those fields.
20:41:22 <Cale> Or simply define a function from the existing types to the new type.
20:47:37 <SparkySparkyBoom> Cale: what if i want to create a list containing the two types?
20:53:38 <Cale> SparkySparkyBoom: You instead think about what you're going to do with the things when you get them out of the list again, and put *that* in the list.
20:55:42 <Cale> SparkySparkyBoom: If you really want to retain all information about the values, you could use something like [Either A B], but usually there's something better.
20:56:43 <__hao> In Java, it’s a lot of work to create new types but in Haskell it’s encouraged and usually one of the first strategies you try to solving problems. That’s how I usually think about it, dunno if that helps.
20:57:04 <SparkySparkyBoom> i made the two types an adt
20:57:21 <Cale> SparkySparkyBoom: For instance, you could define a new record type whose fields correspond to what would be the methods of your "base class", and then define functions which produce records of that type from your other types.
20:57:24 <SparkySparkyBoom> and popped that into the another type containing the common fields
20:57:43 <Cale> SparkySparkyBoom: and then make a list of those records
20:57:52 <SparkySparkyBoom> then i can pattern match on that
20:59:41 <SparkySparkyBoom> yeah i think that's exactly what i did
20:59:43 <SparkySparkyBoom> thank you
21:03:46 <sveit> is Data.Sequence more performant than list for sequences with fewer than ~10 elements, but where frequent random access is required?
21:03:57 <sveit> or sorting/resorting?
21:08:09 <c_wraith> sveit: Data.Sequence is pretty slow, in terms of constant factors.  But if you're not frequently changing the contents, Data.Vector sounds like the best fit for what you describe
21:10:07 <sveit> c_wraith: really? I am working with sequences less than 10 elements, usually 2-5. vector isn't overkill?
21:10:28 <sveit> or rather, constant factors on vector are better than list and sequence even at this scale?
21:10:38 <sveit> what is the point of using sequence ever then? :)
21:10:56 <c_wraith> sveit: sequence is good for cases where you want a dequeue
21:11:43 <c_wraith> sveit: vector always has really good constants - except for when you update it frequently.
21:12:23 <sveit> c_wraith: is vector creation cheap as well?
21:13:03 <sveit> c_wraith: i may need to make many instances of the 2-5 element sequences
21:13:07 <nshepperd> sequence is for when you want a really big list that you can acces at both ends and in the middle
21:13:24 <init> adding elements to a vector means making a copy of it
21:13:27 <c_wraith> sveit: It's cheaper than allocating anything else with the same number of elements.  It's when you update lots that vector loses.
21:14:06 <nshepperd> er, access and update, that is
21:14:42 <c_wraith> sveit: so if you often make new structures that are the previous one slightly modified, vector is bad.  If that's rare, vector is usually pretty good.
21:16:04 <sveit> c_wraith: wow, thank you! i never knew that about vector. it seems like a really amazing library the more i learn about it. is there somewhere i can learn about it's design/architecture? the codebase itself seems pretty large
21:16:14 <c_wraith> sveit: it's just an array
21:17:04 <c_wraith> sveit: I mean, there's lots of other stuff that can go on to optimize certain use cases.  But everything I've been talking about here is just basic properties of an array.
21:18:51 <sveit> c_wraith: my understanding was the author implemented his own data structure, not something primitive to GHC. also looking at the source it's filled with stream/unstream operators. i'm interested in learning how someone managed to make something in Haskell with such tight constants
21:19:29 <c_wraith> sveit: The underlying data structure is GHC's primitive Bytearray# type
21:19:40 <c_wraith> sveit: the stream/unstream stuff is for stream fusion
21:22:49 <sveit> c_wraith: thanks! i'll look for some papers on stream fusion myself, but are there any canonical references you know of off the top of your head?
21:23:59 <c_wraith> don't know of anything offhand that describes vector's approach
21:24:43 <sveit> c_wraith: is that an approach that uses lots of rules?
21:25:00 <c_wraith> sveit: very much so.
21:26:51 <sveit> c_wraith: thanks. out of curiosity, what is the structure to use if i have want to have "previous structure, slightly modified"?
21:27:45 <c_wraith> sveit: depends on the use case.  There are *so* many factors to consider.
21:28:33 <init> sveit: which kind of modification? how much is slightly? which operations will be the one you are doing most? ... there's no silver bullet there
21:29:07 <sveit> c_wraith: short (<10) seqences of unboxable types, where 1-3 elements are modified at a time?
21:29:34 <sveit> modification is generically arithmetic (multiplicatoin, addition)
21:30:50 <c_wraith> If the sequences are sufficiently small, vector can still win because there's so little copying going on.  I'm not sure where that size threshold is.  It's certainly the best option at size 2, for instance.
21:31:23 <c_wraith> Well, no.  At size 2, the best option is probably an unboxed pair. :)
21:31:51 <c_wraith> But you know, aside from that..  It's hard to guess what's best at super-small sizes.  You really need to measure.
21:32:20 <init> sveit: I would just a vector, or an intmap, just based on which one has the nicest API for what I would be doing
21:32:38 <init> if it is really a bottleneck, profiling should show thaT :P
21:34:20 <sveit> thank you! i suspected that at small sizes list might even win out over everything else, but it seems as a structure for sequences it is never the best option?
21:34:57 <c_wraith> list is pretty much never the best option for cases where you expect the whole thing to be in memory at once
21:35:56 <nshepperd> list is a loop waiting to happen :)
21:37:17 <sveit> i always learn a lot, thanks very much! someone should write up a comprehensive resource on performance details like these
22:18:11 <themk> Is there a way to define a function inductively on a Nat?
22:18:21 <themk> Something like what I am trying to do here...  http://lpaste.net/136954
22:18:25 <themk> (a type level Nat)
22:18:26 * hackagebot aur 3.0.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-3.0.0 (fosskers)
22:33:46 <lpaste_> nocturne777 pasted “OK to throw exception here?” at http://lpaste.net/136958
22:34:20 <nocturne777> I don't like throwing an exception here like the way I do, but in thise case I don't think I have a good alternative
22:34:50 <nocturne777> json is already being parsed in the IO layer
