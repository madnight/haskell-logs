00:00:10 <Fluent> I'm not your typical scrubby beginner, I pick up fast. I will use both resources, though
00:00:37 <wedens> I have `data X = Int [Int]` and `X <$> (get "a" :: Result (Identity Int)) <*> (getList "b" :: Result [Int])` how can I avoid doing `runIdentity <$> get "a"` explicitly?
00:01:40 <mauke> Fluent: what other programming languages do you know?
00:01:44 <wedens> get looks like `get :: (Traversable t, MyTypeClass a) -> Text -> Result (t a)`
00:02:34 <Fluent> No other functional languages. I grok Ruby and PHP, but I also know Python, MySQL, Java, etc
00:04:57 <adarqui> i will never code without using -Werror.. (hopefully)
00:07:37 * hackagebot amazonka-route53 0.3.6.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-0.3.6.1 (BrendanHay)
00:07:37 * hackagebot gridland 0.1.0.2 - Grid-based multimedia engine  https://hackage.haskell.org/package/gridland-0.1.0.2 (jxv)
00:27:37 <ely-se> Is Happstack still being maintained?
00:29:21 <zalatovo> can haskell-interactive-mode in Emacs be used with a file that's not in a Cabal project? I'm having some trouble getting the interpreter to run that way
00:31:35 <happy0> hullo. i think i've managed to completely screw up cabal. when i try to cabal install a package i get the following: 
00:31:38 <happy0> Warning: The package list for 'hackage.haskell.org' does not exist. Run 'cabal
00:31:40 <happy0> update' to download it.
00:31:42 <happy0> hhowever
00:31:47 <happy0> when i do 'cabal update' i get the following:
00:31:57 <happy0> Skipping download: Local and remote files match.
00:32:00 <happy0> Skipping download: Local and remote files match.
00:32:02 <happy0> woops
00:32:19 <zalatovo> happy0: maybe just delete ~/.cabal and ~/.ghc directory (or move them)
00:32:20 <happy0> does anybody have any suggestions? i've tried nuking .cabal and .ghc to no success ;x
00:32:33 <happy0> zalatovo: yeah, i tried that :<
00:40:00 <zalatovo> happy0: if you're on Linux I would suggest running strace -e stat -e signal=none cabal install ...
00:40:12 <zalatovo> that will at least tell you where cabal install is looking for the package index
00:40:20 <zalatovo> for me that's somewhere in ~/.cabal
00:40:33 <happy0> zalatovo: thanks, i'll give that a try c:
00:42:39 <happy0> zalatovo: looks like it's .cabal, yeah =p
00:43:02 <zalatovo> happy0: and then try the same with cabal update to see where that one is looking
00:43:57 <happy0> one thing that looks interesting in the strace for cabal install is:
00:44:03 <happy0> stat("/home/happy0/.cabal/packages/hackage.haskell.org/00-index.tar", 0x7f7ef832e120) = -1 ENOENT (No such file or directory)
00:44:06 <happy0> stat("/home/happy0/.cabal/packages/hackage.haskell.org/00-index.tar", 0x7f7ef832e120) = -1 ENOENT (No such file or directory)
00:44:08 <happy0> stat("/home/happy0/.cabal/packages/hackage.haskell.org/00-index.tar", 0x7f7ef832e120) = -1 ENOENT (No such file or directory)
00:44:10 <happy0> stat("/home/happy0/.cabal/packages/hackage.haskell.org/00-index.tar", 0x7f7ef832e120) = -1 ENOENT (No such file or directory)
00:44:12 <happy0> stat("/home/happy0/.cabal/packages/hackage.haskell.org/00-index.tar", 0x7f7ef832e120) = -1 ENOENT (No such file or directory)
00:45:26 <zalatovo> happy0: did it show the message 5 times?
00:45:33 <happy0> argh, sorry about that :|
00:45:35 <happy0> i'm on the train at the moment
00:45:37 <happy0> and i thought it was just failing to paste
00:45:41 <happy0> nope
00:45:50 <Xe> happy0: http://gist.github.com
00:45:51 <ely-se> maybe there's permission problems?
00:45:51 <happy0> i'm just on a dodgy internet connection
00:45:53 <happy0> and for some
00:46:01 <happy0> reason i thought hammering the paste button was a great idea
00:46:07 <happy0> while nothing was happening
00:46:47 <happy0> ely-se: thanks, i'll pursue that =p
00:47:11 <fr33domlover> should "ghc-options -threaded" be used in .cabal files, and in which cases?
00:47:23 <sbrg> once you grok conduit it really starts being enjoyable to use. thank god for conduit-combinators as well
00:47:27 <zalatovo> happy0: the stat call from cabal install fails with ENOENT even after you've run cabal update?
00:47:33 * hackagebot keter 1.4.3.1 - Web application deployment manager, focusing on Haskell web frameworks  https://hackage.haskell.org/package/keter-1.4.3.1 (ChristopherReichert)
00:48:14 <happy0> zalatovo: yup, and i manually checked that the file it was looking for is there =p
00:48:55 <happy0> one sec
00:50:40 <happy0> cabal: Codec.Compression.Zlib: premature end of compressed stream
00:50:49 <happy0> i did get that when i did cabal update there
00:50:57 <happy0> i wonder if that's anything to do with my dodgy train wifi connection
00:51:01 <happy0> maybe it's creating the file;
00:51:21 <happy0> ehh, actually, never mind that half finished thought :P
00:54:16 <zalatovo> happy0: are you in a cabal sandbox?
00:54:55 <happy0> zalatovo: nah, although the same behaviour happens in my cabal sandbox as well =p
00:55:22 <ely-se> inb4 rebooting fixes the problem.
00:55:54 <zalatovo> happy0: I can reproduce the exact same problem on my system by deleting index-00.tar and leaving the other files alone
00:56:19 <zalatovo> happy0: so looks like it might be your dodgy wifi train connection after all
00:56:47 <zalatovo> cabal update skips download and cabal install complains about missing package list for me now
00:57:33 * hackagebot opaleye-sqlite 0.0.0.1 - An SQL-generating DSL targeting SQLite  https://hackage.haskell.org/package/opaleye-sqlite-0.0.0.1 (tomjaguarpaw)
01:02:33 <happy0> thanks for all the help. my train just got in to Glasgow so I'll try again later
01:03:15 <happy0> will try with a stable connection later, zalatovo
01:05:01 <ely-se> You're closer to the Glowgow Haskell Compiler so it should work better now.
01:07:05 <merijn> ely-se: I'm pretty sure SPJ is at MSR in Cambridge, so that doesn't really help :p
01:08:44 <ely-se> Did I say Glowgow? I obviously meant Glowing Cow.
01:09:41 <adarqui> hey if i'm compiling with -Werror and I get a warning that I need to allow.. can I silence it in that specific file?
01:12:34 * hackagebot libpafe 0.1.1.0 - Wrapper for libpafe  https://hackage.haskell.org/package/libpafe-0.1.1.0 (haru2036)
01:23:02 <solatis> ok, massive bikeshed topic: what is the command line option parsing library du jour ?
01:23:08 <solatis> just optparse-applicative ?
01:23:10 <merijn> adarqui: Depends on the warning
01:23:16 <merijn> solatis: optparse-applicative, yes
01:23:24 <merijn> solatis: It has been for a long while
01:23:42 <merijn> solatis: There's a bunch of others, but IMO they use too much magic/voodo/TH
01:24:03 <solatis> yeah right, i want to stick with what people are most familiar with
01:24:30 <solatis> i found that stack/stk is using optparse-applicative, so i figured there must be good reason for it
01:25:37 <merijn> solatis: It's the most straightforward one to use if you're comfortable with the standard haskell idioms using Applicative, Monoid, etc. imo
01:25:58 <solatis> thanks
01:26:30 <solatis> how can i get an account to edit the wiki, btw? there are some inaccuracies in the wiki pages about option parsing (linking to deprecated libs, etc)
01:26:56 <adarqui> hey merijn thanks.. I got it with this: {-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
01:28:04 <merijn> solatis: login links for wiki says: "NOTE: Automatic wiki account creation has been disabled. If you would like an account please email "wiki-account-request" (at the domain haskell dot org) or, if you find that unresponsive, on the haskell-cafe mailing list."
01:28:13 <solatis> thanks
01:28:46 <merijn> adarqui: Why not add a dummy pattern for that missing one? "foo _ = error "Impossible case for foo""?
01:30:47 <adarqui> ya that's the safest way, just wanted to figure out how to silence it through some kind of ghc options
01:31:39 <merijn> That silences all warnings in the file though
01:31:50 <merijn> So if you later add another function and forget a case there, no warning!
01:32:25 <adarqui> ya, bad stuff hehe
01:38:17 <adarqui> thanks for the help, gn!
01:47:36 * hackagebot hsqml-datamodel 0.0.0.0 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.0.0.0 (mjmrotek)
01:48:10 <kuribas> :t round
01:48:11 <lambdabot> (Integral b, RealFrac a) => a -> b
01:48:48 <kuribas> > fromIntegral . round 3.24
01:48:49 <lambdabot>      Could not deduce (Integral a0)
01:48:49 <lambdabot>      from the context (Integral a1, Integral (a -> a1), Num c)
01:48:49 <lambdabot>        bound by the inferred type for ‘e_1324’:
01:48:57 <kuribas> > fromIntegral . round $ 3.24
01:48:58 <lambdabot>  3
01:49:19 <kuribas> Is there an efficient Double -> Double round?  
01:49:39 <kuribas> It should ideally compile to a single instruction FRNDINT.
01:52:36 * hackagebot hsqml-datamodel-vinyl 0.0.0.0 - HsQML DataModel instances for Vinyl Rec.  https://hackage.haskell.org/package/hsqml-datamodel-vinyl-0.0.0.0 (mjmrotek)
01:52:49 <merijn> kuribas: If it truly *HAS* to be a single instruction you might need to look and see if there's some voodoo in ghc-prim for that instruction
01:53:28 <merijn> kuribas: Looks like "double2Int# :: Double# -> Int#" would be the way to go?
01:53:37 <JanBessai> is there a way to ignore the global package db in a cabal sandbox?
01:53:43 <kuribas> merijn: no, I need Double# -> Double#
01:54:17 <merijn> kuribas: "int2Double# . double2Int#" ?
01:54:24 <kuribas> merijn: http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc111.htm
01:54:33 <merijn> Not sure whether that guarantees a single instruction, though
01:55:00 <merijn> kuribas: Might be easier to go through FFI to get inline ASM?
01:55:01 <ely-se> Maybe you can use inline assembly in C--.
01:55:19 <kuribas> merijn: right
01:55:23 <merijn> Do primops allow inline asm?
01:55:57 <merijn> I know we have foreign primops now
01:56:00 <ely-se> IIRC GHC is able to inline C-- code but I'm not 100% sure.
01:56:41 <merijn> kuribas: Look into "Foreign out-of-line PrimOps and foreign import prim" for low level voodoo :)
01:56:52 <kuribas> ok, thanks
02:02:37 * hackagebot microlens-th 0.1.1.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.1.1.0 (Artyom)
02:02:57 <kuribas> I found: https://hackage.haskell.org/package/cmath-0.3
02:04:22 <JanBessai> I have some global packages installed via my linux packet manager (portage). Now I'd like to profile a program without a system-wide reinstal of the global libs with profiling enabled
02:04:59 <JanBessai> so how can I teach a cabal sandbox to reinstall them locally?
02:08:44 <kuribas> ah Data.Fixed.mod' was what I wanted.
02:08:54 <kuribas> :t Data.Fixed.mod'
02:08:55 <lambdabot> Real a => a -> a -> a
02:09:06 <ReinH> JanBessai: that's what sandboxes do: install things locally.
02:09:17 <ReinH> You don't need to do anything special.
02:10:23 <kuribas> mod' is pretty inefficient: "mod' n d = n - (fromInteger f) * d where f = div' n d"
02:10:49 <JanBessai> ReinH: I am using a sandbox, but it still sees stuff installed globally into the syystem
02:10:57 <kuribas> IMO haskell should have a primitive "Double -> Double" round
02:11:17 <JanBessai> then it fails because transformers and other libs were build without profiling in the global version
02:12:38 * hackagebot OrchestrateDB 1.0.0.0 - Unofficial Haskell Client Library for the Orchestrate.io API  https://hackage.haskell.org/package/OrchestrateDB-1.0.0.0 (dwd31415)
02:17:35 <kuribas> Or at least ghc could have rewrite rules to write fromInteger . round into efficient machine code.
02:28:39 <ReinH> JanBessai: that doesn't make sense. Sandboxes don't use the userdb.
02:28:52 <ReinH> Unless the package manager installs them into the global db, which is stupid
02:29:02 <JanBessai> ReinH it does install them there
02:29:07 <ReinH> well, that's stupid
02:29:24 <ReinH> OS and language package managers often don't play well together
02:29:58 <ReinH> Suggest not using the OS-level package manager
02:30:01 <ReinH> for haskell packages
02:32:14 <ely-se> kuribas: this is the GHC implementation of round: https://github.com/ghc/ghc/blob/c5911479f295242e16e396eb5d1369f2e4ce8de0/libraries/base/cbits/primFloat.c#L337
02:32:32 <ely-se> Maybe using the FFI and an assembly function results in enough speedup for you?
02:33:38 <ReinH> This sounds like premature optimization
02:33:39 <kuribas> ely-se: why doesn't it use math.h?
02:34:02 <ely-se> vOv
02:36:27 <kuribas> ReinH: maybe.  The point is why haskell makes a really basic operation so inefficient.
02:37:03 <ely-se> Maybe Haskell's round has different semantics and they can't use C's implementation because of that.
02:37:39 * hackagebot language-javascript 0.5.14.1 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.1 (ErikDeCastroLopo)
02:38:06 <mauke> people use round?
02:38:27 <kuribas> mauke: what do you use?
02:39:01 <merijn> Probably floor/ceil/truncate
02:39:14 <merijn> FYI, round uses banker's rounding
02:39:35 <merijn> Which surprises many people, because it's not "middle school rounding"
02:39:47 <merijn> Although it's the correct default for IEEE754
02:40:17 <merijn> > (round 1.5, round 2.5)
02:40:18 <lambdabot>  (2,2)
02:40:45 <Cale> It should make sense why it's a good idea as soon as you see it though.
02:40:49 <solatis> merijn: damn you are right, some of these option parsing libraries use so much magic it makes C preprocessor macros look clean
02:40:57 <merijn> solatis: :)
02:41:00 <mauke> kuribas: not Doubles, mostly
02:41:02 <kuribas> merijn: I need to make each number an integer time a small floating number `eps`
02:41:05 <hunteriam> Why is it a good idea? I'm a little late to this chat
02:41:12 <hunteriam> @src round
02:41:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:41:12 <kuribas> merijn: times
02:41:13 <mauke> at least if you care about integers vs. fractional numbers
02:41:21 <Cale> hunteriam: It prevents bias
02:41:23 <merijn> hunteriam: Banker's rounding? Because it guarantees fairness
02:41:37 <merijn> hunteriam: Rounding 0.5 means you round up slightly more numbers than you round down
02:42:23 <hunteriam> So you round down every other .5 or something?
02:42:23 <merijn> hunteriam: By rounding to nearest even (banker's rounding) you guarantee 50% of 0.5 values are rounded up, and 50% down, avoiding a bias where slightly more fractions are rounded up than down
02:42:26 <solatis> merijn: how's your pure haskell zmq implementation coming along btw?
02:42:36 <kuribas> In scheme round returns another floating point number, like in most languages.
02:42:50 <Cale> hunteriam: Yeah, you round to even
02:42:52 <merijn> hunteriam: No, it's "round to nearest even", which effectively the same as "every other", I suppose :)
02:43:44 <merijn> solatis: Has been on hold for a while, I've been moving and busy with paper deadlines. I still owe Peaker a patch to "fix" Control.Exception's bracket too >.<
02:43:53 <ReinH> kuribas: what do you do with these very small numbers?
02:44:13 <solatis> merijn: ok, sounds familiar :)
02:44:24 <hunteriam> >round 3
02:44:32 <ReinH> Because this sounds like a potential catastrophe of floating point error waiting to happen
02:44:32 <solatis> > round 3
02:44:33 <kuribas> ReinH: For snapping curves to a grid.
02:44:34 <lambdabot>  3
02:44:43 <ReinH> Oh, ok
02:44:47 <ely-se> ReinH: salami slicing
02:44:50 <merijn> hunteriam: This is only for exactly x.5 values, everything else is rounded "as normal"
02:44:59 <kuribas> ReinH: The tolerance is given by the user.
02:45:03 <merijn> > (round 3.5, round 3.50000000000000000001)
02:45:05 <lambdabot>  (4,4)
02:45:11 <merijn> eh, bad example, I guess :p
02:45:17 <merijn> > (round 2.5, round 2.50000000000000000001)
02:45:18 <lambdabot>  (2,2)
02:45:25 <ReinH> kuribas: I was concerned that you might be adding a bunch of them, etc.
02:45:26 <merijn> really? I hate floats
02:45:30 <merijn> > (round 2.5, round 2.500000000000001)
02:45:32 <lambdabot>  (2,3)
02:45:36 <merijn> there we go
02:45:45 <ely-se> Don't use floats for monetary values.
02:45:55 <merijn> kuribas: Sane people say "screw floats" and use Ratio :p
02:46:05 <merijn> ely-se: I don't think anyone was suggesting that?
02:46:10 <Cale> Fixed point tends to be good for currency
02:46:20 <kuribas> merijn: sane people care about performance...
02:46:25 <ReinH> I still think this is premature optimization.
02:46:28 <ely-se> Fixed points have a problem with division and subsequent multiplication.
02:46:35 <merijn> Cale: Or integer at sufficient fine granularity
02:46:42 <ReinH> Sane people care about performance when it matters
02:46:43 <ely-se> You want 0.05 / 2 * 2 to yield 0.05, not 0.04.
02:46:55 <merijn> Cale: I think Colin Percival does accounting for tarsnap in picodollars :)
02:47:12 <ReinH> ely-se: what?
02:47:38 <ReinH> ah n/m, missed a line
02:47:50 <kuribas> merijn: floating point is hardware accelerated.  I can imagine taking the sine or square root of a Ratio would be really slow.
02:48:04 <merijn> > ((5 % 100) / 2) * 2 -- \o/
02:48:06 <lambdabot>  1 % 20
02:48:14 <ReinH> Cale: truly paranoid indeed.
02:48:18 <merijn> kuribas: FSVO of slow
02:48:49 * merijn repeats the mantra of profile before microoptimising
02:49:07 * ReinH coughs and it sounds like "premature optimization"
02:49:29 <kuribas> merijn: You are right, but a Ratio is out of the question.
02:49:38 <longBack_> newb here.... is there a way to make hoogle respond with  just text only result  instead of html fragments?
02:49:46 <ely-se> merijn: profile after microoptimizing
02:49:59 <merijn> ReinH: I don't like "premature optimisation", people use it as an excuse to never optimise, whereas global/high level optimisation SHOULD happen early
02:50:12 <merijn> ReinH: It's microoptimisation where things are generally counter-intuitive
02:50:31 <ReinH> Well, if it should happen early then doing it early is not premature.
02:50:42 <merijn> kuribas: There's fixed precision datatype in Data.Fixed
02:50:58 <ReinH> merijn: but I agree, "premature optimization" isn't the best way to describe the problem
02:51:14 <ReinH> The bigger problem is "optimization by guessing"
02:51:21 <ReinH> or at least a similarly sized problem
02:51:42 <merijn> ReinH: My favourite example is the SO question going "my array traversal is 3x faster if my array is sorted, WTF?" one :)
02:51:56 <ReinH> CPUs how do they work
02:51:56 <merijn> ReinH: https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array
02:52:03 <ReinH> merijn: branch prediction right?
02:52:17 <merijn> Yeah, also note ICC's insanity defeating the benchmark at the bottom :)
02:52:31 <ReinH> merijn: same reason fib heaps are faster than binary heaps ;)
02:52:39 <hunteriam> ;)
02:52:45 <ReinH> binary heaps have pessimal branch prediction performance for obvious reasons
02:53:10 <ReinH> s/are/can be
02:53:22 <ely-se> merijn: that's fun if you use 
02:53:27 <ely-se> ugh
02:53:34 <merijn> I remember trying to be fancy and optimise by using a fibonacci heap instead of a set because I needed cheap insertion and cheap access of minimal element
02:53:47 <ReinH> or skew heaps or whatever the cool kids are doing these days
02:53:54 <ReinH> edwardk has a thing about them somewhere that's pretty cool
02:53:56 <merijn> It was faster than a set, but after spending 3 days to make it "fast enough"
02:54:02 <ely-se> I hit return instead of cntrol+K.
02:54:33 <merijn> I found out that it was faster to do the traversal twice (precalculate size first time), allocate an array, append to array and then sort the array
02:54:41 <ReinH> heh
02:54:54 <merijn> After a few lessons like that I finally learned that arrays are the universal data structure :)
02:55:01 <ReinH> ha
02:55:02 <merijn> Everything else is stupid slow for large N :)
02:55:17 <ely-se> http://i.stack.imgur.com/4EfWk.png
02:55:43 <ely-se> run-length encoding is amazing
02:56:14 <ReinH> imma let you finish but fm-indexes.
02:56:42 <merijn> ReinH: I'm not even joking, I replaced a lot of data structure and "optimal algorithms" by simply doing a traversal twice to precompute sizes and then preallocate an array and use that
02:56:52 <merijn> Turns out modern CPUs are pretty fast at looping over an array :)
02:56:57 <ReinH> merijn: It didn't occur to me that you would be joking.
02:57:17 <uiop> ely-se: lol http://i.stack.imgur.com/4EfWk.png
02:57:23 <merijn> Anyhoo, lunch time!
02:57:29 <ReinH> ttfn
02:57:34 <ReinH> Should be sleep time for me
03:04:27 <happy0> 7
03:05:33 <hunteriam> 6
03:05:34 <tero-> is ghc's iOS support stable? 
03:07:06 <frerich> merijn: Is that SO question specific for arrays though? I think a better example in favor of arrays would be something which shows how a linear search through an array easily outperforms an O(log N) search (e.g. through some sorted set) due to cache locality.
03:10:22 <kuribas> ReinH: the "premature optimization" quote often gets abused.  Knuth is actually a fan of agressive optimizations.
03:11:29 <kuribas> ReinH: "fromInteger . round" goes via an unbounded integer, which is ridiculously expensive for an operation which should be free.
03:12:15 <indiagreen> what are the laws for Alternative?
03:12:52 <ReinH> kuribas: yes, and that might not matter at all for your application
03:13:00 <kuribas> ReinH: that's true
03:13:27 <kuribas> But I also believe that such small inefficiencies build up.
03:13:44 <ReinH> If it doesn't matter, it doesn't matter.
03:15:35 <kuribas> I wouldn't be surpriced if it does have an impact.
03:17:33 <ReinH> then profile it
03:19:24 <nshepperd_> it's all about the hot loops! (and the waiting on network sockets)
03:28:38 <ReinH> nshepperd_: hot loops, that's a cereal right?
03:37:17 <nshepperd_> either that or a dubstep magazine
03:38:51 <ReinH> nice
03:45:43 <merijn> ok, I think I asked before, but I'm again/still confused about predicative vs impredicative types and what the problem is with the latter
03:50:33 <ttt_fff_> for education purposes, I'd like to reimplement bitcask (backend of riak) in haskell; what is recommende reading for how haskell interacts with the OS, as well as guarnatees in terms of crash / recovery
03:52:42 <srhb> ttt_fff_: What do you mean with OS interaction? Generally you'll only have to pay a lot of attention if you're doing synchronization across OS threads or fiddling with memory via the FFI directly.
03:52:54 <ttt_fff_> guarnteees on writes / flushes
03:53:01 <ttt_fff_> for dbs, it's important that on crash, they can recover
03:53:09 <ttt_fff_> so it's rather imporatnt ot know when shit actually gets written to the disk
03:53:15 <kuribas> ttt_fff_: If you are using concurrency, I can recommend "parrallel and concurrent programming in haskell".
03:53:20 <ttt_fff_> so for haskell IO functions, I need to understand what the OS promises
03:53:27 <ttt_fff_> kuribas: yeah, I have simon's book
03:53:29 <uiop> ttt_fff_: you can call C functions through ffi directly
03:53:41 <srhb> ttt_fff_: Same as any other program, you can flush when you want. The OS doesn't behave specially here.
03:53:51 <uiop> ttt_fff: "unsafe" will not go throught rts before call
03:54:16 <kuribas> ttt_fff_: and did you read it?
03:54:26 <ttt_fff_> kuribas: simon's book?
03:54:29 <ttt_fff_> kuribas: no
03:54:39 <kuribas> ttt_fff_: then read part two about concurrency.
03:54:39 <ttt_fff_> single threaded bitcastk would make me happy
03:55:22 <uiop> ttt_fff: well "safe" ffi call wont delay calling C function either
03:55:24 <kuribas> ttt_fff_: you know about bracket?  http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception-Base.html#v:bracket
03:56:13 <ttt_fff_> kuribas: all I know is that { do; h <- openFIle; s <- readh; closeFile h; print s } // can result in "" on non-empty h, since the file gets closeFile before the call on readH, and therefore, I should use conduits
03:56:24 <ttt_fff_> so basically I know that I'm an idiot, but I have no idea what te right thing is
03:57:01 <uiop> ttt_fff_: oh, i see how you mean
03:57:03 <kuribas> Just don't use lazy IO
03:57:33 <merijn> pipes-safe or conduit + strict IO is the way to go for streaming applications
03:57:34 <uiop> ttt_fff_: so wrt laziness when you need to know if you've completely read it all in before closing it
03:57:52 <ttt_fff_> yeah; otherwise it's  a thunk evaluated after the file has closed
03:58:37 <uiop> basically if you ever have to close it dont use lazy IO
03:58:58 <uiop> or if you do, know how to force it all just right before close
04:00:03 <ttt_fff_> hmm; maybe I do this in erlang instead?
04:00:15 <ttt_fff_> after all, what advantage will haskell offer me if I want to implement a db? (not trolling, serious questions)
04:00:33 <chpatrick> type safety?
04:00:34 <kuribas> ttt_fff_: if it's lazy, the documentation will tell you so.
04:00:59 <kuribas> ttt_fff_: haskell is the best imperative programming language in the world :-)
04:01:09 <ely-se> ttt_fff_: depends on your requirements
04:01:10 <chpatrick> kuribas_: yeeaaaaahhhh...
04:01:21 <ttt_fff_> kuribas: is this haskell + monad to generate llvm code?
04:01:22 <chpatrick> not convinced on that yet :)
04:01:42 <kuribas> ttt_fff_: for example...
04:02:18 <ely-se> Haskell is the best language for problems that are best solved with Haskell.
04:03:48 <ReinH>  ttt_fff_ type safety, extremely performant IO, other things I'll tell you about once I finish building mine.
04:04:06 <ttt_fff_> ReinH: you're writing a db in haskell?
04:04:09 <kuribas> ttt_fff_: haskell has good concurrency support.
04:04:14 <ReinH> I'm writing a time-series db for a client.
04:04:30 <kuribas> ttt_fff_: lightweight threads.
04:04:39 <ttt_fff_> kuribas: erlang wins on concurrency
04:04:48 <merijn> ttt_fff_: Oh? Why?
04:05:02 <ReinH> Erlang wins on distributed systems. Not necessarily on concurrency,
04:05:09 <merijn> ReinH++
04:05:19 <ttt_fff_> fine, what ReinH said
04:05:29 <ely-se> Erlang wins on particular concurrency problems.
04:05:32 <ely-se> Haskell wins on particular concurrency problems.
04:05:38 <ely-se> Without clear requirements you can't choose a technology.
04:06:31 <ttt_fff_> implementing bitcask + a simple relational DB for educational purposes
04:06:46 <ttt_fff_> feel like I should write some thing from scratch before giving opinions about this whole SQL noSQl bit
04:07:01 <srhb> They are both great tools for the job. Especially if you can live with the lack of proper types in Erlang :)
04:07:39 <chpatrick> @hackage distributed-process -- what about this?
04:07:39 <lambdabot> http://hackage.haskell.org/package/distributed-process -- what about this?
04:07:40 <merijn> Even Joe Armstrong regrets erlang's lack of types :p
04:07:58 <srhb> chpatrick: It's a bit raw.
04:08:00 <ReinH> srhb: people have been living with it pretty well for the last 30-some years :p
04:08:08 <srhb> ReinH: Yes, "people."
04:08:09 <chpatrick> merijn: hello joe
04:08:10 <ely-se> I'm implementing a statically typed language that targets Erlang. Just wait forever till I finish it. :P
04:08:18 <ttt_fff_> merijn: link? I cna't find the joearmstrong / erlang / types article
04:08:20 <tomjaguarpaw> ttt_fff_: If you want you can get Opaleye to generate an SQL query which you can upload as a stored procedure.  Opaleye doesn't have any support for an programmatic constructs besides querying though.
04:08:39 <ttt_fff_> tomjaguarpaw: what? I don't wnat to use postgresql
04:09:06 <ReinH> tomjaguarpaw: Opaleye looks pretty neat, I need to find an excuse to use it.
04:09:14 <ely-se> ttt_fff_: what are the goals of the RDBMS?
04:09:15 <mniip> :o I wonder if Haskell is possible without a GC
04:09:28 <mniip> that would remove the need for an RTS
04:09:36 <merijn> ttt_fff_: I don't have a direct link, but there was an interview where someone asked him "Why no types in Erlang?" and his answer was basically "Well, if I had known anything about types when I started, I would've added them..."
04:09:39 <ReinH> mniip: sure, you just need infinite memory.
04:09:53 <ReinH> RTS does things other than GC
04:10:11 <ttt_fff_> tomjaguarpaw: I had a question for you
04:10:14 <tomjaguarpaw> ttt_fff_: I was replying to this http://ircbrowse.net/browse/haskell?id=21124686&timestamp=1438020274#t1438020274
04:10:17 <ttt_fff_> tomjaguarpaw: I now remember it
04:10:22 <tomjaguarpaw> tomjaguarpaw: Yes that was my response!
04:10:26 <ely-se> mniip: you need automatic memory management, because manual memory management implies mutating state.
04:10:28 <ttt_fff_> tomjaguarpaw: is it possible to do typed stored proceudres in opaleye?
04:10:32 <tomjaguarpaw> lol
04:10:38 <tomjaguarpaw> This conversation is backwards
04:10:39 <ttt_fff_> tomjaguarpaw: damn it, you beat me
04:10:39 <mniip> ReinH, you could predict collection at compile time, or use some fancy refcounting
04:10:48 <ely-se> C++ and Rust have automatic memory management without GC. You could look into that.
04:11:04 <ttt_fff_> tomjaguarpaw: I was looking at https://github.com/begriffs/postgrest ... and I thought ... it'd be really cool to do the postgresql stored procedures in sql as well
04:11:12 <tomjaguarpaw> ReinH: Thanks.  Do you have any use for SQLite?  I've just released a preliminary version.
04:11:13 <ttt_fff_> tomjaguarpaw: s/sql/opaleye/
04:11:15 <ely-se> In Rust it's even saf.
04:11:16 <ely-se> safe*
04:11:26 <mniip> ely-se,  I'm not talking about no memory management at all
04:11:27 <ReinH> tomjaguarpaw: hmm, not particularly, but why not?
04:11:44 <mniip> just no explicit gc that runs once a while
04:11:47 <tomjaguarpaw> ttt_fff_: What do you want the stored procedures to do?  Just queries, or other fancy programmatic stuff?
04:11:47 <ely-se> mniip: You were talking about GCs, and GCs do memory management.
04:12:08 <ttt_fff_> tomjaguarpaw: I think the begriffs postgrest idea is to push all 'busness logic' into stored procedures in postgres
04:12:10 <ReinH> tomjaguarpaw: might be nice for native desktop apps
04:12:14 <ely-se> Without GC, you need another memory management system.
04:12:21 <ttt_fff_> tomjauarpaw: so for a web app, all the logic would be in the db stored procedures
04:12:22 <mniip> right
04:12:32 <ttt_fff_> tomjaguarpaw: and I was thinking, if I'm doing that, I'd prefer to use a typed language, say OPaleye instead of SQL
04:12:45 <ReinH> ttt_fff_: ime that's a pretty awful idea
04:12:54 <ttt_fff_> ReinH: why?
04:12:57 <ely-se> PL/pgSQL is statically typed.
04:13:21 <ReinH> SPs are very hard to test, debug, and maintain. Writing them in Haskell really only helps with one or two of those.
04:15:50 <uiop> mniip: "you could predict collection at compile time" is impossible statically unfortunately, "or use some fancy refcounting" would be slower than copying gc with how haskell is constantly writing to new mem
04:16:32 <ely-se> refcounting doesn't work with cycles which are common in haskell due to laziness
04:16:40 <ely-se> you need a separate cycle collector anyway
04:16:45 <uiop> yeah that too
04:17:10 <ReinH> SPs can be good for complex aggregations and access control, not for business logic.
04:17:15 <mniip> well
04:17:50 <mniip> I have an idea for loop detection, but it's a performance killer
04:18:01 <ReinH> Oh, and calling out to some other Oracle DB over a VPN because yes you can actually do that.
04:18:13 <ely-se> foreign tables are amazing
04:20:17 <ReinH> There aren't really any advantages to SPs these days. SQL queries get compiled too in most modern databases.
04:20:37 <ReinH> Unless you're doing some sort of complex, multi-stage aggregation that you couldn't do with SQL anyway
04:21:50 <ReinH> They lack error handling and code reuse features. Etc.
04:22:39 <ReinH> I guess this is turning into a rant now so I'll stop.
04:22:52 <ely-se> How do they lack those?
04:23:02 <ReinH> By not having them, mostly.
04:24:27 <uiop> > fix id
04:24:31 <lambdabot>  mueval-core: Time limit exceeded
04:25:08 <ReinH> Error handling varies from DB to DB. try/catch often doesn't catch all errors. Propagation isn't very easy. Code reuse via UDFs or subqueries usually imposes too high of a performance cost.
04:25:35 <hpc> ReinH: you'd be surprised the complexity SQL compilers/optimizers can handle
04:26:49 <ReinH> Also the idea that your entire application can live inside a single database is shortsighted. Architectures often become heterogeneous as they grow in scale and complexity.
04:28:38 <ReinH> Oh, also version control is painful, which adds to the maintenance burden.
04:28:58 <ely-se> Soon I will use SQLite.
04:32:44 * hackagebot hsqml-datamodel 0.0.0.1 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.0.0.1 (mjmrotek)
04:40:08 <ReinH> hpc: I often am.
04:41:48 <mniip> wow
04:42:28 <mniip> they changed the highlighting style on hackage
04:42:55 <mniip> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html
04:44:46 <ely-se> only for base
04:45:05 <ReinH> mniip: ooh nice
04:45:05 <JanBessai> ReinH: I'm fed up with solving my cabal problem and switching to vagrant now ;)
04:45:14 <mniip> oh, I never realized instance Monoid Ordering exists... that makes a lot of things simpler
04:45:15 <ReinH> JanBessai: :D
04:45:29 <ReinH> mniip: oh yes it does!
04:46:08 <ReinH> Especially when combined with instance Monoid b => Monoid (a -> b)
04:46:31 <merijn> mniip: <3 Monoid Ordering and "Monoid b => Monoid (a -> b)"
04:46:56 <mniip> (a,b) `compare` (c.d) = (a `compare` c) `mappend` (b ` compare` d)
04:47:28 <mniip> sorry for the syntax I'm on mobile
04:47:28 <merijn> mniip: I'll blow your mind
04:47:37 <merijn> :t compare `mappend` compare
04:47:39 <lambdabot> Ord a => a -> a -> Ordering
04:47:44 * hackagebot OrchestrateDB 1.0.0.1 - Unofficial Haskell Client Library for the Orchestrate.io API  https://hackage.haskell.org/package/OrchestrateDB-1.0.0.1 (dwd31415)
04:48:08 <ReinH> :D
04:48:11 <mniip> merijn,  that isn't a very interesting function, is it
04:48:21 <mniip> just 'compare'
04:48:35 <merijn> hmmm, I think I did that wrong
04:49:09 <mniip> xs `compare` ys = mconcat $ zipWith compare xs ys
04:49:11 <mniip> :o
04:49:20 <merijn> I think I wanted
04:49:26 <merijn> :t comparing fst <> comparing snd
04:49:27 <lambdabot> (Ord a, Ord a1) => (a1, a) -> (a1, a) -> Ordering
04:49:43 <mniip> comparing isn't from base tho
04:49:50 <merijn> > let foo= comparing fst <> comparing snd in foo (1,2) (1,3)
04:49:51 <lambdabot>  LT
04:49:54 <merijn> mniip: wut
04:50:06 <merijn> mniip: comparing is in Data.Ord
04:50:13 <mniip> wat
04:50:23 <merijn> mniip: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ord.html#v:comparing
04:50:45 <mniip> I thought it's a byproduct of Data.Function's "on"
04:50:59 <merijn> on is a generalisation of comparing
04:51:08 <merijn> comparing was invented first and later generalised to on
04:53:16 <merijn> Anyone know around what time edwardk is on these days? Or alternatively, has anyone used stuff based on bound's examples/Deriving.hs?
04:54:06 <guillaum1> I have the feeling that I missed something. Why is there no function dispatch based on the type of the argument. For exemple, there is unwords in Prelude (:: [String] -> String) and unwords in Data.Text (:: [Text] -> Text). Why must I explicitly tell which one I'm using when the argument I'm using is obviously a Text or a String ?
04:54:19 <ReinH> merijn: bound is annoyingly named when you want to search for it
04:54:33 <opqdonut> guillaum1: that's called a type class
04:54:47 <opqdonut> guillaum1: there could be a "class Unwords a where unwords :: [a] -> a" and it would work
04:54:54 <dramforever> guillaum1: because they are different functions
04:55:02 <guillaum1> opqdonut: yes, right. But that's not the case ;)
04:55:42 <dramforever> guillaum1: not the case?
04:55:50 <mniip> merijn,  the simultaneous genius and simplicity of these things is what i like about haskell
04:56:13 <guillaum1> dramforever: unwords is not part of a typeclass.
04:56:29 <dramforever> guillaum1: and those two "unword"s are not the same function
04:56:42 <dramforever> they just happen to have the same name, and they are in different modules
04:56:48 <merijn> ReinH: I've found plenty of stuff, just not what I need
04:57:23 <dramforever> guillaum1: oh I know, you are talking about overloading aren't you
04:57:29 <merijn> ReinH: The deriving example shows how to generate all this fancy Pattern/Alt/Case stuff, but not an example how to manipulate those things....
04:57:37 <guillaum1> dramforever: Yes, exactly ;)
04:57:50 <dramforever> guillaum1: and can you understand my explaination?
04:57:55 <merijn> guillaum1: Looks like you want monoid
04:57:57 <merijn> :t mconcat
04:57:58 <lambdabot> Monoid a => [a] -> a
04:58:00 <dramforever> of the situation, of course
04:58:10 <dramforever> merijn: and IsString
04:58:12 <dramforever> > fromString
04:58:13 <lambdabot>      No instance for (Typeable a0)
04:58:13 <lambdabot>        arising from a use of ‘show_M87391993334272279312212’
04:58:13 <lambdabot>      In the expression:
04:58:14 <dramforever> uh oh
04:58:17 <dramforever> :t fromString
04:58:18 <lambdabot> IsString a => String -> a
04:58:26 <dramforever> guillaum1: just sayin' =P
04:59:10 <merijn> ReinH: Like, so I have a "Case (f a) [Alt Exp a]", but I have no clue how I'd write an interpreter to evaluate that...
05:00:02 <dramforever> guillaum1: by the way I don't really think you gain much by giving different things the same name
05:00:22 <guillaum1> ok, too much talk in parallel ;) merijn. I agree it is a monoid, but there is a difference between mconcat and unwords. dramforever I also agree they are both two differents functions from two different modules. But in C++ (for exemple), I can gave the same name and let the dispatch by type choose the correct function.
05:00:37 <mniip> merijn,  got a link?
05:00:42 <dramforever> yes you are right
05:00:58 <dramforever> and the designers of haskell avoided that
05:01:07 <merijn> mniip: https://hackage.haskell.org/package/bound and https://github.com/ekmett/bound/blob/master/examples/Deriving.hs
05:01:38 <guillaum1> dramforever: Could you give me a pointer or something to a discussion explaining the reason of that choice ?
05:01:48 <dramforever> guillaum1: IMHO we get nice types of functions in return
05:02:36 <dramforever> and you can be sure which function you are calling
05:03:30 <guillaum1> dramforever: I can understand the point of "being sure"
05:03:59 <dramforever> I'm pretty sure overloading is full of wtfs
05:06:00 <merijn> guillaum1: Overloading costs you parametricity
05:06:20 <guillaum1> merijn: Could you develop a bit?
05:06:24 <merijn> guillaum1: Parametricity is the principle that the behaviour of a function cannot depend on polymorphic parts of the type
05:06:26 <dramforever> merijn: and *much* *much* more =P
05:06:47 <merijn> guillaum1: i.e. "id :: a -> a" can only do one thing, because it can't special case "id :: Int -> Int" to be "(+1)"
05:07:37 <merijn> guillaum1: Overloading is similar to "type-casing", i.e. dispatching based on the type of a value. The ability to do that makes it hard/impossible to generalise properties of functions
05:08:09 <dramforever> hmm...there's a Chinese idiom which basically means "getting yes from no", and I believe it describes the idea of parametricity pretty well
05:08:35 <merijn> This is related to the paper "Theorems for Free" which shows that parametricity lets you get, well...theorems for free. I you can prove things based on their type without knowing the implementation
05:08:48 <dramforever> @free f :: a -> a
05:08:48 <lambdabot> g . f = f . g
05:09:35 <dramforever> lemme see...
05:09:55 <guillaum1> merijn: thank you. I'll have a look at the paper and I found a page on haskell wiki about Ad-hoc polymorphism which details a bit the issue.
05:10:11 <dramforever> yes it implies forall a. f a = a
05:12:31 <mniip> merijn, wow
05:12:45 * hackagebot cgrep 6.4.21 - Command line tool  https://hackage.haskell.org/package/cgrep-6.4.21 (NicolaBonelli)
05:13:06 <mniip> the deriving stuff
05:17:00 <kuribas> Wouldn't it be possible to automatically generate dependency version numbers inside a cabal file?
05:17:37 <kuribas> It's tedious to look for the earliest version which works with your package.
05:22:32 * mniip wonders whether edwardk's new invention can be used to implement a sometimes-applicative do
05:25:42 <mniip> for example, (\f x -> f >>= \f -> x >>= \x -> return (f x)) :: Applicative f => f (a -> b) -> f a -> f b
05:25:52 <srhb> mniip: Which new invention?
05:25:53 <mniip> instead of Monad
05:26:05 <srhb> And didn't Marlow basically implement applicative do?
05:26:10 <mniip> srhb, that deriving stuff
05:26:14 <srhb> Ah
05:28:56 <chpatrick> mniip: not sure I follow
05:35:32 <Peaker> @type Data.Vector.Generic.create
05:35:34 <lambdabot> Data.Vector.Generic.Base.Vector v a => (forall s. ST s (Data.Vector.Generic.Base.Mutable v s a)) -> v a
05:36:00 <Peaker> The fact that the ST computation here is not allowed to return any extra information out (besides the "v a") is intentional, or an oversight?
05:36:19 <aweinstock> Peaker: that's the whole point of ST
05:36:40 <aweinstock> (that the return value can't contain state information, so the computation-as-a-whole is pure)
05:36:50 <aweinstock> :t runST
05:36:51 <lambdabot> (forall s. ST s a) -> a
05:36:53 <Peaker> aweinstock: It could be: (forall s. ST s (MVector s a, b)) -> (Vector s a, b)
05:36:59 <Peaker> aweinstock: I think you misunderstood my question
05:37:05 <dramforever> Peaker: it couldn't
05:37:10 <Peaker> dramforever: why not?
05:37:18 <dramforever> well I mean those two s aren't the same thing
05:37:26 <Peaker> oops, the "Vector s a" above should be "Vector a"
05:37:27 <ggole> The s isn't in scope there, right?
05:37:40 <Peaker> It could be: (forall s. ST s (MVector s a, b)) -> (Vector a, b)
05:37:41 <dramforever> Peaker: okay
05:38:01 <dramforever> Peaker: why don't you run it two times?
05:38:06 <Peaker> Like runSTArray -- Vector.create seems like it forbids extra information threading through the runST unnecessarily
05:38:19 <Peaker> dramforever: the ST action?
05:38:22 <dramforever> oh yes that's a problem...
05:38:42 <Peaker> So I guess it was an oversight and not intentional.. Fortunately the unsafe APIs underneath are accessible to fix it
05:38:50 <Peaker> (to create a better runSTArray/Vector.create)
05:40:32 <dramforever> Peaker: I wonder if it's really useful
05:40:41 <dramforever> for example, could ghc optimize ST?
05:41:06 <Peaker> dramforever: if ST is useful?
05:41:24 <dramforever> Peaker: I mean, if you run it twice like this:
05:42:11 <dramforever> let vec = Vector.create (fst <$> action); result = runST (snd <$> action)
05:42:34 <dramforever> it's possible that action is only run once
05:43:20 <Peaker> dramforever: I doubt it would optimize that
05:43:24 <kuribas> Peaker: I think it's intentional.
05:43:29 <dramforever> Peaker: it should
05:43:49 <dramforever> kuribas: really? can you explain it?
05:44:15 <kuribas> dramforever: it's supposed to work with pure code.
05:44:16 <nshepperd_> optimizing that seems a bit fraught
05:44:57 <dramforever> kuribas: so why is that code impure if passing extra data is possible?
05:45:33 <Peaker> kuribas: why would it be? It seems to be safe to pass an extra output
05:45:45 <Peaker> kuribas: and impossible to use it for various purposes because you can only get the array out
05:46:36 <Peaker> if the extra output references any mutable state from "s" it'll be unusable anyway (as "s" would escape its scope)
05:47:31 <quicksilver> do you even need to use unsafe stuff to recreate it?
05:47:31 <kuribas> Peaker: what extra output do you need?
05:47:39 * quicksilver forgets the Vector API
05:47:41 <Peaker> kuribas: for example, indices into that vector
05:47:47 <quicksilver> isn't there a safe freeze?
05:47:51 <Peaker> quicksilver: it seems to be so disorganized everywhere
05:47:54 <Peaker> quicksilver: that copies?
05:50:10 <kuribas> Peaker: but in that case, you can use "new" and runST?
05:50:14 <quicksilver> Peaker: ah yes. So you can do it semantically fine, but pay the cost of the copy
05:50:26 <quicksilver> or if you want to avoid that cost you can use unsafeFreeze
05:50:26 <Peaker> kuribas: but it will only return a vector out, and nothing else?
05:50:44 <Peaker> quicksilver: yeah, that's what I'm doing, but I was wondering if I'm missing some loophole or such that I'm introducing that way
05:50:54 <quicksilver> I don't think so
05:50:58 <kuribas> Peaker: you can return what you want from a ST monad.
05:51:22 <Peaker> kuribas: I know... but if you want to return a frozen vector safely, that's what Vector.create is for, but it's not useful enough :(
05:51:36 <dramforever> you lose generality for safety
05:52:01 <kuribas> Peaker: unsafeFreeze is only unsafe if there the mutable vector can be accessed somewhere.
05:53:21 <kuribas> Peaker: but returning from a ST monad ensures that any mutable vectors inside cannot be referenced anymore.
05:53:27 <Peaker> kuribas: indeed, and the fact you also runST at the same time makes it safe, so it's nice to wrap it up in the "Vector.create" function
05:53:40 <Peaker> kuribas: Yes, I know I can replicate the safe behavior myself with the unsafe functions -- but I find that ugly
05:54:00 <Peaker> So it would be much nicer to get all the benefits from purely safe functions
05:54:11 <nshepperd_> I wonder if 'create :: Traversable f => (forall s. ST s (f (MVector s a))) -> f (Vector s a)' would be possible and/or safe
05:54:12 <kuribas> Peaker: create probably uses unsafeFreeze under the hood.
05:55:17 * nshepperd_ feeling the senseless need to generalize that
05:55:57 <Peaker> nshepperd_: yeah that would be even nicer
05:57:39 <nshepperd_> er, I also put in the wrong additional 's'
05:58:35 <nshepperd_> ooh, it works
05:59:53 <nshepperd_> my_create s = runST (s >>= traverse unsafeFreeze)
06:03:06 <gc__> @pl sum
06:03:07 <lambdabot> sum
06:03:41 <nshepperd_> I think it should be safe, since action only happens once, and the traversable can't hold any other reference to the mutable state without 's' escaping its scope
06:09:24 <nshepperd_> my_create ((,) <$> pure 8 <*> M.replicate 3 'a') = (8,fromList "aaa")  -- yay :)
06:12:46 <merijn> gah :\
06:13:10 <merijn> If I try to use the Bound.Name I break my ability to derive Functor and friends from my AST :\
06:20:10 <meretrix> If I use "Control.Monad.Trans.State.Strict" with the lazy version of "modify", what exactly is lazy?
06:20:49 <chpatrick> I don't think strict state monad is strict in the state anyway
06:20:50 <meretrix> Will that ensure that no old state thunks are kept around, but that the current state could still be a thunk?
06:20:52 <dramforever> meretrix: I doubt if you could actually do that
06:20:57 <chpatrick> it's in the ordering  of the actions
06:21:11 <dramforever> oh wait I misunderstood that
06:21:27 <nshepperd_> Peaker: What do you think? I was thinking I'd post an issue on github with my suggested implementation of the generalised 'create'
06:22:10 <meretrix> chpatrick: So, does that mean I could still get space leaks with State.Strict?
06:22:25 <Peaker> nshepperd_: seems nice to me :)
06:22:30 <meretrix> If I'm updating it many times without getting its value..
06:22:34 <chpatrick> yes I think so
06:22:40 <Peaker> nshepperd_: a pull request could be more effective than an ordinary issue
06:22:55 <chpatrick> tbh default seq isn't that useful anyway if you have nested data
06:23:02 <chpatrick> since it just forces the topmost constructor
06:23:03 <JanBessai> this is great: https://robots.thoughtbot.com/easy-haskell-development-and-deployment-with-docker
06:23:04 <meretrix> Then in what sense is State.Strict strict?
06:23:12 <dramforever> meretrix: head stricy
06:23:15 <dramforever> *strict
06:23:34 <meretrix> Hmm.. ok, I thought that was what "modify'" was for.
06:23:42 <JanBessai> thoughtbot / Tony DiPasquale: thanks if you are here!
06:23:51 <meretrix> So, I should be using modify' then if I want to avoid space leaks?
06:24:16 <meretrix> Eh.. I better just create a test case.
06:24:17 <Cale> The difference between the lazy and strict state monads is whether you have  x >>= f = State $ \s -> let (v,s') = runState x s in runState (f v) s'  or  x >>= f = State $ case runState x s of (v,s') -> runState (f v) s'
06:24:31 <kuribas> :t mapM
06:24:32 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:24:39 <Cale> i.e. it's about strictness regarding the intermediate pairs
06:25:19 <Cale> oops, missed a lambda in the second version there :)
06:25:26 <Cale> x >>= f = State $ \s -> case runState x s of (v,s') -> runState (f v) s'
06:25:28 <Cale> of course
06:25:58 <dramforever> hmm interesting
06:26:06 <nitrix> How does one specifies command line arguments when using cabal's repl to invoke main ?
06:26:15 <dramforever> :main args
06:26:34 <nitrix> Fancy :)
06:26:36 <meretrix> Cale: Thanks Cale, I'll have to think about that. :)
06:26:36 <dramforever> should have thought of that, huh? =)
06:34:12 <nshepperd_> wow, the stream fusion framework in vector is a lot more sophisticated than I thought
06:34:29 <meretrix> Cale: Isn't the case statement only matching that runState is returning a tuple?  It doesn't need to evaluate the contents of the tuple, right?
06:34:49 <meretrix> And it's already known that runState returns a tuple, so no evaluation is needed..
06:35:11 <meretrix> It's not like pattern matching a ADT with many constructors.
06:35:19 <meretrix> (Obviously I'm missing something..)
06:35:55 <dramforever> meretrix: well the tuple has to be evaluated
06:36:05 <dramforever> s/has/still has/
06:37:26 <meretrix> What does it mean for the tuple to be evaluated?
06:37:42 <meretrix> Is the modification of the state evaluated?
06:37:52 <dramforever> I'm afraid no
06:38:00 <dramforever> but I'm not really sure about this...
06:38:02 <meretrix> Then what else is there to evaluate?
06:38:21 <dramforever> sorry maybe someone else could help you
06:38:29 <dramforever> I'm starting to get confused
06:38:43 <meretrix> No worries, just trying to get the bottom of it. :)
06:38:44 <Cale> meretrix: runState x s is an expression which evaluates to a pair, but it is not immediately in the form of a pair
06:39:06 <Cale> meretrix: Work needs to be done to put it in the form (v,s') in order that it can match the pattern
06:39:44 <meretrix> Cale: Ok, but not enough work to actually modify the state?
06:39:49 * hodapp kicks ErrorT to the curb and uses 'fail' instead
06:39:59 <Cale> With let, this work is deferred until either the evaluation of v or s' is demanded
06:40:20 <Cale> With case, the work is not deferred
06:40:50 <Cale> hodapp: For which monad?
06:41:00 <Cale> hodapp: There's usually a better option than using fail
06:41:35 <hodapp> basically just State
06:42:33 <hodapp> http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ - that link is old, admittedly, but I was looking at #4
06:42:34 <Cale> fail for State is just error
06:43:14 <Cale> (State is a good example of why fail shouldn't be in the Monad class)
06:43:43 <nitrix> Does cabal's repl let you change a function definition while main is running?
06:44:15 <nitrix> I'm doing mostly IO and it's a pain to reload with :r and get the same conditions again to test.
06:44:42 <Cale> nitrix: nope -- even if you did, it wouldn't affect which main was running.
06:45:01 <nitrix> I see. So there's no monkeypatching support.
06:45:54 <chpatrick> @hackage foreign-store -- <- nitrix
06:45:54 <lambdabot> http://hackage.haskell.org/package/foreign-store -- <- nitrix
06:45:57 <hodapp> Cale: yeah, I'm looking for little else at this point than the ability to have things fail with some string error
06:46:06 <sleeper> ghc automatically links cabal libraries, right?
06:47:07 <Cale> hodapp: Yeah, just use error
06:47:31 <sleeper> i'm compiling a module that uses a function from missingh and the linker reports undefined references
06:47:32 <Cale> hodapp: If you want the whole program to die with a message in case the expression is ever evaluated, that's what error is for.
06:47:48 <sleeper> likely a bug in the package or am i neglecting to do something?
06:48:31 <hodapp> Cale: well, this will be integrating at some point into my Shake build, and Shake does use exceptions in some form... so I'd like to be able to catch errors and pass them along to Shake if, for instance, it's running 10 builds and wants to still run the other 9
06:48:41 <hodapp> but I don't want it coupled with Shake
06:49:39 <chpatrick> hodapp: ExceptT?
06:50:01 <Cale> hodapp: If it were an IO action, it would be more reliable to use throwIO
06:50:18 <Cale> Catching exceptions thrown by error is tricky.
06:50:41 <Cale> (because you have to sequence the execution of catch carefully with the evaluation of the expression)
06:50:44 <hodapp> well, the Shake build works in a monad that derives from IO
06:50:51 <hodapp> chpatrick: perhaps that's what I want
06:51:24 <Cale> It might be a good idea just to make it an IO action, and use liftIO to turn it into a Shake action or whatever.
06:51:50 <hodapp> to make what an IO action?
06:53:05 <hodapp> the monad I'm trying to raise exceptions within?
06:54:03 <kuribas> Wouldn't it be possible to define a lightweight monad instance over (s -> (a, s))?
06:54:29 <chpatrick> kuribas: that's State
06:54:42 <sleeper> doing something wrong, my bad
06:55:08 <kuribas> chpatrick: State from mtl is "type State s = StateT s Identity"
06:55:32 <chpatrick> if you unwrap all the newtypes you get s -> (a, s)
06:55:37 <chpatrick> @unmtl State
06:55:37 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
06:55:58 <chpatrick> @unmtl State Int Int
06:55:58 <lambdabot> Int -> (Int, Int)
06:56:18 <chpatrick> :t state
06:56:19 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
06:56:24 <chpatrick> :t runState
06:56:25 <lambdabot> State s a -> s -> (a, s)
06:56:38 <kuribas> chpatrick: so as far as ghc is concerned, they are the same?
06:56:49 <chpatrick> I believe so
06:57:34 <kuribas> I could try two functions, one with hand threaded state, and compare core...
06:57:55 <merijn> gah
06:58:12 <merijn> I have a newtype around FreeT and I can't find the right instance declarations to let it derive Eq :\
06:58:26 <hodapp> I'm looking at example 2 in http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html and must I transform IO in order to be able to handle exceptions in IO?
06:58:28 <merijn> I know I got this working in the past, but I don't remember which instances I derived/declared
06:58:43 <chpatrick> hodapp: if you're using IO you can just use the stuff in Control.Exception
06:58:48 <chpatrick> no need for ExceptT
06:59:56 <hodapp> chpatrick: ahh, okay
07:00:12 <hodapp> I have gotten 25 different answers on how one should handle errors, so I'm trying to navigate all this
07:00:47 <hodapp> Control.Exception looks like it should work
07:01:29 <chpatrick> for me at least: if it's just IO then exceptions, if the error means something is fundamentally wrong then error, otherwise ExceptT
07:02:55 <hodapp> chpatrick: yeah, I just have FooMonad that derives from State, and almost all of the processing on it will occur in IO (or in one of Shake's monads that one can lift IO action into)
07:04:12 <merijn> No one?
07:06:30 <clynamen> I took this code from real world haskell. What compiler flags should I use with the current ghc in order to compile it? http://pastie.org/10318403
07:08:34 <kuribas> chpatrick: they are pretty identical: http://lpaste.net/137531
07:09:48 <kuribas> clynamen: add FlexibleInstance to the LANGUAGE pragma.
07:10:49 <clynamen> kuribas: thanks, it works. 
07:11:11 <kuribas> "FlexibleInstances"
07:12:09 <kuribas> I hardly use the state monad, because I thought here was overhead using it, but apparently I was wrong.
07:12:11 <chpatrick> kuribas: there you go :)
07:14:11 <nkaretnikov> is there a built-in version of 'comp f g x = f x >> g x' ?
07:15:28 <nitrix> Why does cabal shows me errors about "cannot satisfy -hide-package MonadCatchIO-mtl" even though there's literally no such rules in my cabal file?
07:15:34 <nitrix> I'm importing snap and snap-core.
07:16:03 <nkaretnikov> ah, looks like (>=>) might work
07:16:24 <kuribas> :t liftM (>>)
07:16:32 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 b -> m1 b)
07:16:39 <mniip> nkaretnikov, >=> is something else
07:16:48 <kuribas> :t \f g x -> f x >> g x'
07:16:54 <lambdabot>     Not in scope: ‘x'’
07:16:56 <chpatrick> :t liftA2 (>>)
07:17:00 <lambdabot>     Perhaps you meant one of these:
07:17:06 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
07:17:10 <kuribas> :t liftM2 (>>)
07:17:18 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 b) -> m (m1 b)
07:17:22 <nkaretnikov> mniip: yeah, I've already found out :(
07:17:45 <chpatrick> :t liftA2 (>>) :: Monad m=> (a -> m ()) -> (b -> m ()) -> m ()
07:17:50 <chpatrick> bleh
07:17:54 <lambdabot>     Couldn't match type ‘m1 ()’ with ‘()’
07:18:04 <chpatrick> :t liftA2 (>>) :: Monad m=> (a -> m ()) -> (a -> m ()) -> a -> m ()
07:18:10 <nkaretnikov> chpatrick: if you're trying to help me, it won't work
07:18:12 <lambdabot> Monad m => (a -> m ()) -> (a -> m ()) -> a -> m ()
07:18:20 <chpatrick> nkaretnikov: why not?
07:18:26 <mniip> liftA2 (>>) sounds right
07:18:30 <nkaretnikov> it throws away the result
07:18:40 <nkaretnikov> let me show you
07:18:41 <chpatrick> what result do you want?
07:18:45 <chpatrick> the one from the right?
07:18:49 <mniip> @
07:18:52 <mniip> er
07:18:56 <aweinstock> :t (>=>)
07:18:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:19:13 <nkaretnikov> @let f x = print $ "f got" <> show x
07:19:15 <lambdabot>  Defined.
07:19:18 <fr33domlover> nkaretnikov, random guess: perhaps using arrows?
07:19:18 <chpatrick> :t liftA2 (>>) :: Monad m=> (a -> m ()) -> (a -> m r) -> a -> m r
07:19:20 <nkaretnikov> @let g x = print $ "g got" <> show x
07:19:20 <lambdabot> Monad m => (a -> m ()) -> (a -> m r) -> a -> m r
07:19:21 <lambdabot>  Defined.
07:19:30 <nkaretnikov> liftA2 (>>) f g $ 2
07:19:33 <nkaretnikov> > liftA2 (>>) f g $ 2
07:19:34 <lambdabot>      Ambiguous occurrence ‘f’
07:19:34 <lambdabot>      It could refer to either ‘L.f’, defined at L.hs:144:1
07:19:34 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
07:19:39 <nkaretnikov> :(
07:20:14 <nkaretnikov> > liftA2 (>>) L.f g $ 2
07:20:16 <lambdabot>      Ambiguous occurrence ‘g’
07:20:16 <lambdabot>      It could refer to either ‘L.g’, defined at L.hs:145:1
07:20:16 <lambdabot>                            or ‘Debug.SimpleReflect.g’,
07:20:21 <nkaretnikov> > liftA2 (>>) L.f L.g $ 2
07:20:25 <lambdabot>  <IO ()>
07:20:31 <nkaretnikov> ah, right
07:20:36 <chpatrick> it works mate
07:20:39 <chpatrick> what result do you want?
07:21:07 <nkaretnikov> I want to see "f got: 2", "g got: 2"
07:21:16 <nkaretnikov> I only get "g got: 2"
07:21:29 <chpatrick> that's different from your comp function though
07:21:34 <chpatrick> since that throws it away too
07:21:57 <nkaretnikov> lol
07:22:00 <nkaretnikov> you're right
07:22:00 <nullvoid8> I think nkaretnikov needs Data.Functor.Compositon?
07:22:07 <nkaretnikov> let me see
07:22:09 <chpatrick> I would just write these things by hand
07:22:10 <nullvoid8> or .Compose, something like that
07:22:12 <chpatrick> unless you need it _really_ often
07:22:17 <fr33domlover> :t (+ 1) >>> (+ 1)
07:22:18 <lambdabot> Num c => c -> c
07:22:33 <nullvoid8> chpatrick: so would I, but that's the abstraction
07:22:53 <chpatrick> I mean these itty-bitty combinators just make things harder to read
07:22:53 <chpatrick> imo
07:23:08 <chpatrick> same as the multi-argument compose everyone wants to write when they're starting out
07:23:37 <chpatrick> :t \f g -> runReaderT $ (,) <$> ReaderT f <*> ReaderT g
07:23:38 <lambdabot> Applicative m => (r -> m a1) -> (r -> m a) -> r -> m (a1, a)
07:23:46 <chpatrick> there you go
07:23:56 <mniip> you think (f .) . g is better?
07:24:02 <chpatrick> no I think that's also ugly
07:24:11 <chpatrick> better to not pointfree at all
07:24:23 <hodapp> :t (f .) . g
07:24:25 <lambdabot>     Ambiguous occurrence ‘f’
07:24:25 <lambdabot>     It could refer to either ‘L.f’,
07:24:25 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:144:1
07:24:42 <hodapp> :t (\f g -> (f .) . g)
07:24:43 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:24:57 <aweinstock> :t L.f >=> L.g
07:24:58 <lambdabot> Show a => a -> IO ()
07:25:01 <merijn> @undefine
07:25:02 <lambdabot> Undefined.
07:25:13 <aweinstock> > (L.f >=> L.g) 2
07:25:15 <lambdabot>  Not in scope: ‘L.f’Not in scope: ‘L.g’
07:26:49 <naudiz> hey, inside an RWST Monad with IO, why can't I use print and getLine?
07:26:58 <chpatrick> naudiz: you need to liftiO
07:27:04 <chpatrick> :t liftIO
07:27:06 <lambdabot> MonadIO m => IO a -> m a
07:27:07 <aweinstock> naudiz: liftIO $ print "something"
07:27:21 <cheater> can someone suggest inexpensive led modules i can hang on the wall or ceiling in the cellar and just supply them with mains? they need to have enough of an enclosure that there's no exposed mains. they use screw terminals preferrably. i'd like to install them using nails or pegs and screws, not sure yet.
07:27:26 <cheater> sorry, wrong window.
07:27:34 <naudiz> should I consider using IO (RWS ...) instead?
07:27:52 <chpatrick> naudiz: that doesn't make sense
07:28:00 <naudiz> okay, thanks
07:28:35 <nomeata> The naturals are the base of everything, even of nothing. Or why else does installing "void" require installing "nats"?
07:29:20 <chpatrick> nomeata: looks like void has a semigroup instance which pulls in nats
07:29:29 <Xe> :t (.)
07:29:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:29:42 <chpatrick> don't know why void needs semigroup in particular :)
07:29:48 <nomeata> hmm. sometimes I get the impression people do take me serious
07:30:11 <Xe> nomeata: you need something in order to represent nothing
07:30:23 <nullvoid8> ed just likes to throw instances at the wall and see what sticks
07:30:25 <Xe> by comparison you can't compare anything to anything else without an opposite
07:30:46 <chpatrick> surely you can make Void an instance of anything where it appears as a method parameter
07:43:31 <fr33domlover> vty-ui question: How can List item values be modified?
07:43:52 <fr33domlover> Looks like the only way is to remove and re-insert the list row
07:44:37 <Welkin> can anyone explain how RankNTypes is working in this example for ST? https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/explicit-forall#use-case--the-st-monad
07:44:43 <Welkin> I don
07:44:53 <Welkin> I don't understand why it works
07:45:12 <naudiz> How can I transform "RWS r w s" into "RWST r w s IO"?
07:45:15 <Welkin> the function named `illegal`
07:47:53 * hackagebot shelly 1.6.3.2 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.3.2 (GregWeber)
07:48:46 * merijn headdesk
07:48:54 <naudiz> I have a function f :: RWS r w s () that I want to call inside another function g :: a -> RWST r w s IO ()
07:49:11 <naudiz> and I don't know how I do so
07:49:29 <merijn> Blah, my neat "use a tuple as base monad for FreeT to get annotations" failed miserably on account of me forgetting that tuples are only a monoid if the first value is a Monoid :\
07:49:36 <cheater> naudiz: what are RWS and RWST?
07:49:55 <Intolerable> the read-write-state monad and accompanying transformer
07:49:59 <naudiz> cheater: https://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-RWS-Lazy.html#t:RWST
07:50:23 <naudiz> RWS r w s  is RWST r w s Identity
07:50:29 <hexagoxel> `mapRWST (return . runIdentity)`
07:50:40 <orion> What does {-@ ... @-} do?
07:50:48 <Intolerable> naudiz: try RWST . (return .) . runRWS
07:51:00 <Intolerable> :t RWST . (return .) . runRWS
07:51:01 <lambdabot> RWS r w s a -> RWST r w s ((->) s) a
07:51:05 <Intolerable> welp
07:51:07 <Intolerable> don't do that
07:51:55 <cheater> if I were you I'd grep MTL for lines that contain both RWS\> and RWST.
07:51:58 <hexagoxel> :t mapRWST (return . runIdentity)
07:52:00 <lambdabot> Monad n => RWST r w' s Identity b -> RWST r w' s n b
07:52:16 <Intolerable> that'll work
07:52:25 <Intolerable> :t hoist
07:52:26 <lambdabot> Not in scope: ‘hoist’
07:52:27 <cheater> there likely is an efficient approach that doesn't involve return aka re-wrapping the value.
07:52:42 <naudiz> thanks 
07:52:53 * hackagebot fsnotify 0.2.0.3 - Cross platform library for file change notification.  https://hackage.haskell.org/package/fsnotify-0.2.0.3 (GregWeber)
07:53:03 <Intolerable> :t Control.Monad.Morph.hoist
07:53:04 <lambdabot> (Monad m, Control.Monad.Morph.MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
07:53:17 <Intolerable> :t Control.Monad.Morph.hoist (return . runIdentity)
07:53:18 <lambdabot> (Monad n, Control.Monad.Morph.MFunctor t) => t Identity b -> t n b
07:53:48 <Intolerable> :t Control.Monad.Morph.hoist (return . runIdentity) :: Monad m => RWS r w s a -> RWST r w s m a
07:53:50 <lambdabot> Monad m => RWS r w s a -> RWST r w s m a
07:54:02 <Intolerable> also there's generalize
07:54:06 <Welkin> https://hackage.haskell.org/package/mmorph
07:54:06 <Intolerable> :t Control.Monad.Morph.generalize
07:54:07 <Welkin> :D
07:54:08 <lambdabot> Monad m => Identity a -> m a
07:54:10 <Welkin> I forgot about that one
07:55:49 <Zemyla> :t lift . runIdentityT
07:55:50 <lambdabot>     Not in scope: ‘runIdentityT’
07:55:51 <lambdabot>     Perhaps you meant ‘runIdentity’ (imported from Control.Monad.Identity)
07:55:56 <cheater> looking outside of mtl you will not find an efficient approach
07:56:26 <cheater> being able to cast those types from one to the other requires knowledge of the internals which only the library author has
07:56:28 <naudiz> I guess I'll stick to the first one, thanks
07:57:34 <naudiz> I could also use IO for everything but that doesn't seem to be a good idea
07:58:52 <Intolerable> yeah, don't do that
08:12:54 * hackagebot moesocks 0.1.0.4 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.4 (JinjingWang)
08:12:56 * hackagebot Win32 2.3.1.0 - A binding to part of the Win32 library  https://hackage.haskell.org/package/Win32-2.3.1.0 (BenGamari)
08:21:40 <pchiusano> I am using Aeson's TH support, but need to add an additional constraint to my FromJSON
08:21:48 <pchiusano> how do I do that
08:22:11 <chpatrick> instance MyConstraint Foo => FromJSON Foo where
08:22:49 <pchiusano> yes, but if I am using TH to generate the FromJSON, how do I specify that
08:23:34 <pchiusano> $(https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson-TH.html#v:deriveJSON https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson-TH.html#v:defaultOptions ''Foo)'
08:23:37 <pchiusano> f
08:24:00 <pchiusano> $(deriveJSON defaultOptions ''Foo)
08:24:04 <pchiusano> does not work
08:24:35 <RyanGlScott> What is (~)'s fixity?
08:24:57 <pchiusano> I want to say like $(MyConstraint Foo => deriveJSON defaultOptions ''Foo), or something, but have no idea how to do that
08:25:44 <chpatrick> ah I see
08:25:58 <chpatrick> could you tell me the constraint?
08:26:03 <RyanGlScott> pchiusano: Can you do instance (MyConstraint Foo) => FromJSON Foo where parseJSON = $(mkParseJSON defaultOptions ''Foo)?
08:26:06 <pchiusano> it seems like deriveJSON just assumes only `FromJSON a => FromJSON (Foo a)`
08:26:07 <chpatrick> I imagine TH adds FromJSON constraints automatically
08:26:20 <pchiusano> chpatrick: it is Ord
08:26:24 <chpatrick> ah
08:26:31 <chpatrick> so you have something inside that is only FromJSON if it's Ord?
08:26:41 <pchiusano> correct
08:27:09 <chpatrick> maybe you could use mkToJSON
08:27:09 <pchiusano> or rather, the overall Foo a is only FromJSON if a is Ord
08:27:16 <chpatrick> and write the instance declaration yourself
08:27:51 <chpatrick> instance Ord a => FromJSON (Foo a) where fromJSON = $(mkToJSON defaultOptions ''Foo)
08:28:11 <chpatrick> err
08:28:15 <chpatrick> mkParseJSON rather
08:28:20 <pchiusano> oh, I see, what RyanGlScott just said, heh
08:28:23 <RyanGlScott> Note that you may have to write $(return []) before that instance if Foo is defined in the same module
08:28:26 <chpatrick> ah didn't see that
08:28:34 <pchiusano> lemme try that, thanks, one min..
08:31:53 <Intolerable> if i'm using async
08:32:03 <Intolerable> and i want my errors to have useful data
08:32:16 <Intolerable> can i just make up some data type and give it an Exception instance?
08:32:24 <Intolerable> will that work properly?
08:32:45 <monochrom> yes
08:33:14 <Intolerable> can i use ExceptT
08:33:26 <Intolerable> then at the end, newtype the Either and throw it?
08:34:01 <monochrom> I don't know
08:34:30 <monochrom> "newtype the Either" sounds confused
08:34:51 <Intolerable> yeah that's wrong
08:34:53 <Intolerable> i want to
08:34:59 <Intolerable> :t either throw return
08:35:01 <lambdabot> (Monad m, Exception e) => Either e a -> m a
08:35:03 <pchiusano> worked!
08:35:24 <pchiusano> RyanGlScott: can you explain your comment about $(return [])
08:35:30 <monochrom> that's better. but I wonder why it is not throwIO
08:35:33 <hseg> I'm trying to use OverlappingInstances to construct a function that given a list containing lists of lists of... of a will construct a rose tree with leaves of type a. This is what I have so far, but GHC complains my instances are conflicting http://lpaste.net/137533
08:35:36 <pchiusano> that wasn't needed for me, but why did you think that
08:35:42 <Intolerable> yeah it should be
08:35:42 <Intolerable> ty
08:35:59 <Intolerable> (don't use exceptions often)
08:36:42 <geekosaur> hseg, they are overlapping
08:36:47 <hseg> I'm basically trying to answer this question http://comments.gmane.org/gmane.comp.lang.haskell.beginners/15643
08:37:09 <geekosaur> you might include the actual error message
08:37:31 <RyanGlScott> phciusano: One sec, let me prepare an example where it is necessary
08:37:33 <hseg> geekosaur: Yes, but to my understanding, OverlappingInstances permits overlap, and will then pick the most specific instance.
08:38:11 <hseg> Conflicting family instance declarations: Elem [a] -- Defined at .... Elem a -- Defined at:
08:39:58 <RyanGlScott> pchiusano: http://lpaste.net/137534
08:40:11 <RyanGlScott> As for why that error can occur, see this: https://ghc.haskell.org/trac/ghc/ticket/9813#comment:2
08:40:19 <joco42> does anyone know if codex makes tags for dependencies of dependencies ?
08:40:32 <joco42> because it seems that it does not
08:40:52 <RyanGlScott> Essentially, there's no guarantee about the order in which splices occur, but you can guarantee at least some order by using declaration splices (like $(return []), for instance)
08:40:53 <lamefun> https://hackage.haskell.org/package/cryptonite-0.5/docs/Crypto-PubKey-RSA.html#t:PrivateKey - Private key as plain integers? Is that safe?
08:41:37 <joco42> how can i make tags for every registered package using codex?
08:41:50 <kadoban> lamefun: That what they are anyway. I'm not sure how it'd be unsafe? (I don't know what it'd do with a negative Integer I guess?)
08:42:57 <geekosaur> hseg: sorry, out of my league --- except I seem to recall this may be one of the cases that fundeps handles "better" than associated types
08:42:59 <kadoban> lamefun: I guess my question to you would be, what would be safer, in your mind?
08:43:08 <chpatrick> lamefun: hand-written untested crypto? is that safe? :)
08:43:28 <chpatrick> the funny thing is that a lot of vincent's code still does pointer math and stuff for the sake of efficiency
08:43:46 <hseg> Yeah. I'm also a bit out of my league. Then again, that should have been expected when trying to adapt oleg code.
08:43:48 <chpatrick> for example he does hex conversion by looking up in a big string primitive literal
08:43:58 <chpatrick> which is funny because it actually had a typo
08:44:02 <lamefun> chpatrick, there's non-hand-written crypto?
08:44:12 <chpatrick> ok, "self-rolled" then
08:44:15 <hseg> Specifically http://okmij.org/ftp/Haskell/vararg-fn.lhs
08:44:21 <merijn> If there's any free/cofree masochists, I need some input on: https://mail.haskell.org/pipermail/haskell-cafe/2015-July/120579.html
08:44:39 <lamefun> kadoban, I mean, don't the plain integers stay in memory after they've been garbage-collected?
08:44:44 <chpatrick> openssl may be a mess but at least we know that every attack we know if fixed on it
08:44:47 <wraithm> lamefun: chpatrick is more making a point about the fact that it's not battlehardened, like say openssl or gpg are.
08:44:48 <chpatrick> and there are a lot of attacks
08:44:53 <kadoban> At some point someone does have to implement crypto, but … yeah the closer you are to the actual implementors usually the higher the likelihood that /someone/ is making a mistake.
08:44:57 <chpatrick> with vincent's stuff, who knows
08:45:26 <lpaste_> xevz pasted “Why list?” at http://lpaste.net/6318488111844163584
08:45:29 <chpatrick> and as I said it still makes dumb compromises imo for efficiency
08:45:34 <chpatrick> which kinda defeats the point
08:46:14 <lpaste_> xevz revised “Why list?”: “Why list?” at http://lpaste.net/6318488111844163584
08:46:34 <hseg> xevz: Look at the type of the line following the error.
08:46:40 <kadoban> lamefun: Yeah, plain haskell doesn't have a good way to express that kind of thing, but I don't see that another type would help. You'd have to implement something special to avoid that particular hole.
08:46:42 <hseg> xevz: What monad is that in?
08:47:09 <xevz> hseg: You tell me. :) I'm playing around, trying to learn. :)
08:47:12 <chpatrick> xevz: it looks like you're trying to do IO in a pure ocmputation
08:47:27 <chpatrick> getTree needs to return IO [ MyFileInfo ]
08:47:51 <xevz> chpatrick: Yeah, I figure getting the filesize is a one-time deal, not something I need IO for in the futuure.
08:48:12 <chpatrick> you can't do it without IO though
08:48:16 <hseg> xevz: Well, the top-level function you're applying in that line is (:), so assuming the line is fully applied, the line is of type [a] for some probably more specific a.
08:48:29 <hseg> xevz: ^
08:48:53 <xevz> chpatrick: So, once I've used IO, I'm forever "bound" by it?
08:49:13 <hseg> xevz: Yep. Unless you do weird unsafe stuff
08:49:29 <xevz> Hm, ok.
08:49:38 <chpatrick> xevz: the idea is that you use IO at the "top level" of your program, and then you embed pure computations into it
08:49:44 <hseg> xevz: It basically boils down to there being no function of type IO a -> b where b is not of the form IO c
08:49:50 <geekosaur> well. final results have to be in IO --- but note that (main :: IO a) does not force you to put all functions in IO
08:50:11 <geekosaur> what you do is have an IO "part" and lift pure functions into it, then you can ignore IO in the pure part
08:50:21 <lamefun> chpatrick, how is it self-rolled? It's a library, not a part of a program.
08:50:29 <xevz> Oh, so I've basically got it the other way around.
08:50:31 <chpatrick> lamefun: as in it's written by one guy
08:50:38 <xevz> I was figuring "one IO part of the application".
08:51:10 <chpatrick> xevz: your whole application has to go in main, which is IO ()
08:51:24 <chpatrick> but the subcomponents can (should) be pure
08:51:25 <chpatrick> if possible
08:51:37 <xevz> Got it :)
08:52:50 <xevz> So, is IO [MyFileInfo] preferred over MyFileInfo { myFileSize : IO FileOffset }?
08:53:23 <chpatrick> yes
08:53:38 <chpatrick> I mean
08:53:43 <chpatrick> either you want all your file info in that record
08:53:49 <chpatrick> or you can find it later from the filename anyway right?
08:54:01 <chpatrick> putting a partially-applied fileSize function in it isn't that useful
08:54:59 <lamefun> chpatrick, and how does that make it insecure?
08:55:22 <wraithm> lamefun: Again, it's not really tested against all sorts of attacks. We don't know if it's secure. That's really the point. We don't know.
08:55:24 <chpatrick> because there are a million things that can and do go wrong and at least with openssl we know what a lot of them are
08:55:43 <chpatrick> haskell is pretty niche so there's not much attacking or defending going on
08:55:46 <wraithm> And we don't know probably means it's not secure.
08:56:13 <danilo2> Hello Guys! :) Is there anything like FastString for GHCJS? When I try to compile my code using the GHCJS I get error, that it could nod find the "ghc" package (which is exposed and compiles fine without the --ghcjs flag)
08:56:27 <chpatrick> I mean there is some cool stuff in ocaml with the bitcoin pinata :)
08:56:41 <chpatrick> but they seem to be very disciplined in their implementation
08:56:47 <mpickering> danilo2: luite said that you had to modify the build system a bit if you want to depend on ghc
08:56:52 <chpatrick> and I don't think the haskell crypto stuff is
08:57:01 <mpickering> probably best asking in #ghcjs
08:57:22 <danilo2> mpickering: hmm, would you (or Luite) be so nice and provide a little more info about it? 
08:57:34 <danilo2> mpickering: I will ask there anyway! :)
08:57:38 <chpatrick> lamefun: see also http://www.leonmergen.com/haskell/crypto/2015/03/21/on-the-state-of-cryptography-in-haskell.html
09:02:31 <mpickering> danilo2: I don't know any more about it other than what I just said.. it was my first time using ghcjs so I didn't want to dive too deep
09:02:58 <mpickering> how much of the ghc api do you want?
09:03:24 <danilo2> mpickering, quite: Thanks guys! :)
09:06:19 <xevz> chpatrick: So, um... How would I return IO [MyFileInfo]? http://lpaste.net/8568415074975219712
09:06:28 <xevz> Perhaps a new function is the cleanest way?
09:06:45 <kadoban> chpatrick: Nice/scary link.
09:07:17 <chpatrick> xevz: you need to do
09:07:18 <chpatrick> fsizes <- getTree xs
09:07:26 <chpatrick> return (fsize : fsizes)
09:07:28 <xevz> Ah
09:07:32 <chpatrick> or use for :)
09:07:33 <chpatrick> :t for
09:07:34 <lambdabot>     Not in scope: ‘for’
09:07:35 <lambdabot>     Perhaps you meant one of these:
09:07:35 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
09:07:37 <chpatrick> :t T.for
09:07:38 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
09:07:57 <chpatrick> :t T.for :: [ a ] -> (a -> IO b) -> IO [ b ]
09:07:58 <lambdabot> [a] -> (a -> IO b) -> IO [b]
09:09:56 <xevz> chpatrick: Thanks :)
09:10:36 <wraithm> chpatrick: I had not seen the bitcoin pinata :D That's absolutely fantastic. The haskell community could set something like that up for cryptonite... "The private key for <bitcoin address> is encrypted with cryptonite's RSA implementation. Break it for some bitcoins."
09:11:30 <chpatrick> wraithm: 5 minutes later... :P
09:11:35 <wraithm> Exactly!
09:11:39 <wraithm> Great way to lose some btc :D
09:11:58 <chpatrick> I saw the bitcoin pinata guys' presentation at CCC
09:12:05 <chpatrick> they're writing a whole OS too
09:12:13 <chpatrick> https://mirage.io/
09:12:14 <wraithm> Link?
09:12:19 <wraithm> Neat :D
09:12:26 <wraithm> in ocaml?
09:12:40 <chpatrick> yep
09:12:46 <rhaps0dy> the original unikernel was also in ocaml!
09:12:47 <chpatrick> maybe it's time to learn it :D
09:12:48 <rhaps0dy> :D
09:13:00 <raichoo> Haskell has the HalVM project :)
09:13:31 <raichoo> I know one of the guys behind OCaml TLS :)
09:14:49 <chpatrick> raichoo: HalVM looks pretty cool
09:14:57 <raichoo> Indeed.
09:16:19 <wraithm> Ocaml is neat. I recommend learning it :)
09:16:26 <hodapp> unikernels look like quite a relevant idea.
09:16:28 <raichoo> btw, I started a github organization to improve Haskell suport for Neovim, if you folks are interested: https://github.com/neovimhaskell
09:17:00 <hodapp> ACM had a nice article on Mirage, IIRC
09:17:14 <chpatrick> what does ocaml do better than haskell?
09:17:17 <chpatrick> apart from strictness
09:17:18 <wraithm> raichoo: Cool! I'm a neovim/haskell user. I was actually just messing around with ghc-mod for syntastic with neovim.
09:17:42 <hodapp> http://queue.acm.org/detail.cfm?id=2566628 here we go
09:17:57 * hackagebot csound-expression-typed 0.0.7.7 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.7.7 (AntonKholomiov)
09:17:59 * hackagebot csound-expression-opcodes 0.0.3 - opcodes for the library csound-expression  https://hackage.haskell.org/package/csound-expression-opcodes-0.0.3 (AntonKholomiov)
09:18:01 * hackagebot csound-expression 4.8.2 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-4.8.2 (AntonKholomiov)
09:18:02 <wraithm> chpatrick: The module system is really interesting. It's a very different model for doing abstraction from Haskell's module and typeclass system.
09:18:14 <raichoo> wraithm: I finished a very basic script for neovim and ghcmod yesterday https://vimeo.com/134767975
09:18:24 <hodapp> wraithm: from what I've read, it's something of a dual to Haskell's typeclasses, not so much a very different model
09:18:35 <chpatrick> is it the whole functor thing from ml?
09:18:38 <chpatrick> I've heard a little about it
09:18:49 <raichoo> ml functors are functions from modules to modules
09:19:09 <wraithm> hodapp: Yeah, that's not really true. It's really really different.
09:19:11 <YellowOnion> has anyone been able to get llvm to build a functional app on windows using openGL?
09:19:52 <ggole> OCaml has a bunch of interesting structural typing stuff, too 
09:20:04 <ggole> Although it isn't used much in practice (particularly objects)
09:20:08 <chpatrick> how's the ecosystem?
09:20:17 <wraithm> ggole: Yeah, polymorphic variants
09:20:23 <chpatrick> haskell has a lot of nice abstractions now
09:20:25 <wraithm> chpatrick: Bad, but improving-ish
09:20:32 <chpatrick> I guess I'd miss the ekmettverse
09:20:33 <ggole> opam is really nice, the build tools are... less nice
09:20:41 <chpatrick> also I've heard it only just got multicore
09:20:51 <hodapp> wraithm: Being 'really really different' doesn't exactly contradict what I said
09:21:18 <raichoo> ggole: I had a lot of fights with opam. Heck, I find cabal-install less troublesome these days…
09:21:26 <wraithm> hodapp: They're not really dual to each other. ML Modules are way crazy more powerful than typeclasses. However, I much prefer typeclasses exactly because they're less powerful.
09:21:58 <raichoo> Coherence is a big plus when it comes to typeclasses.
09:22:03 <wraithm> Exactly.
09:22:03 <xevz> I come from O'Caml, can testify it's nice. :D
09:22:09 <hodapp> wraithm: http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf for instance.
09:22:59 <bigs> haha yeah and as a haskeller who just dedicated a lot of time learning ocaml, the module system is significantly different
09:23:14 <bigs> build system is rough, but opam/utop are fantastic
09:23:14 <ggole> Modules are highly explicit, so building complex things with them can get very heavy.
09:23:20 <wraithm> hodapp: I've messed around with that paper. They sorta show that typeclasses can be subsumed by modules, but not the other way around.
09:23:22 <rhaps0dy> the ekmettverse, nice
09:23:56 <wraithm> at least as far as I understand it
09:24:24 <hodapp> wraithm: "This article demonstrates how to translate essential features of ML modules to
09:24:26 <raichoo> wraithm: Do you lose coherence that way? I guess you do.
09:24:26 <hodapp> Haskell type classes and vice versa. Both translations come with a formalization,
09:24:29 <hodapp> sorry, mis-paste
09:24:49 <hseg> Question: Is it possible to construct a type family Elem that satisfies the equations Elem [a] = a, Elem a = a for a not of form [_] ?
09:25:22 <hodapp> raichoo: what does coherence mean here?
09:25:23 <wraithm> hodapp: I need to reread the paper. I may not have understood it.
09:25:24 <chpatrick> hseg: with a closed type family
09:25:42 <chpatrick> type family Elem a where
09:25:42 <chpatrick>   Elem [ a ] = a
09:25:42 <chpatrick>   Elem a = a
09:26:07 <raichoo> hodapp: Maybe coherence is the wrong word, I recall ezyang stated that "global uniqueness of instances" is a better term.
09:26:10 <chpatrick> @hackage mono-traversable -- <- sounds like this
09:26:10 <lambdabot> http://hackage.haskell.org/package/mono-traversable -- <- sounds like this
09:26:15 <ggole> raichoo: coherence is that different paths to the same place have the same meaning, right? But with ML modules, paths are explicit.
09:26:22 <ggole> You get exactly what you ask for.
09:26:33 <chpatrick> hseg: http://hackage.haskell.org/package/mono-traversable-0.9.2.1/docs/Data-MonoTraversable.html#t:Element
09:26:44 <hodapp> raichoo: I don't think it's the wrong word, just a word that I don't understand readily :P
09:26:58 <hseg> Hm. Thanks. Let's see if I can get my code to work now.
09:27:00 <chpatrick> hseg: or https://hackage.haskell.org/package/lens-4.12.2/docs/Control-Lens-At.html#t:IxValue
09:27:01 <ggole> The semantics seem pretty clear to me, the downside being that you have to ask for it.
09:27:09 <wraithm> raichoo: You're talking about "implicit modules". You do lose coherence with implicit modules, but ml modules are fully explicit so that you don't have to worry about coherence.
09:27:11 <bigs> hseg: you'll need the type families extension as a heads up!
09:27:23 <hseg> Of course.
09:27:48 <Cale> bigs: It's pretty hard to construct a type family at all without it ;)
09:27:54 <raichoo> hodapp: It guarantees that you only have one instance of a typeclass globally, so your code works the same everywhere and is not depending on imports.
09:28:20 <bigs> Cale, hseg: haha yep, but i try not to assume everyone knows what is/isn't bundled in by default
09:28:31 <hseg> Sure, ok.
09:28:33 <hodapp> raichoo: that makes sense
09:28:44 <hodapp> raichoo: and I can see how violating that might cause problems
09:28:56 <raichoo> hodapp: That's not the csase for e.g. scala.
09:29:40 <ggole> My understanding is that Scala lets you break, eg, ordering assumptions in a map
09:29:46 <raichoo> Otoh, you end up with big monolithic modules as well es newtype wrappers to work around that.
09:29:52 <ggole> That's impossible with ML modules (assuming the Map module is correctly constructed, of course)
09:30:21 <raichoo> ggole: You can break that as well in Haskell using GeneralizedNewtypeDeriving.
09:30:36 <hodapp> hm, I've not messed with Scala in a few years... 
09:31:07 <raichoo> ggole: That's way SafeHaskell does not allow GND.
09:31:45 <ggole> Hmm, that does seem a bit off
09:31:58 <glguy> type roles are supposed to address that
09:32:04 <raichoo> glguy: yep
09:32:20 <raichoo> But you still have to annotate some roles manually.
09:32:31 <hackrilege> im going to try and build my first cabal repo today!
09:32:35 <ggole> ML modules do have their problems though
09:32:48 <ReinH> raichoo: I don't think that's why SafeHaskell disallows GND
09:32:55 <raichoo> ggole: So do typeclasses. It's "pick your poison" :D
09:33:03 <hodapp> type roles? OH GOD ANOTHER CONCEPT
09:33:04 * hodapp runs away
09:33:07 <ggole> Eg, it's common to have a sig type t ... end thing, but now you've fixed the arity of t.
09:33:19 * glguy closes the door behind hodapp
09:33:21 <raichoo> ReinH: Well, it's one of the reasons. It's stated in the paper.
09:33:24 <hodapp> hey...
09:33:34 <hodapp> I was just getting coffee
09:33:46 <glguy> sorry, door's closed
09:33:50 <hackrilege> i will try to get it to build a library, an executable and a test suite. I hope you can supervise me, ill let you know how I get along
09:34:13 <ggole> raichoo: it's not a soundness problem or anything like that, just a pain in the ass
09:34:31 <raichoo> ggole: Yep :)
09:34:33 <ggole> Since you get less polymorphism than you would naturally expect
09:34:48 <ggole> But that's ML for you
09:34:53 <thomasd> does anyone know of resources regarding how to lexically scope a program that I parse line by line, delimited by semi colons?
09:34:55 <albeit> If I have a Vector.Unboxed.Mutable, is it possible to treat it temporarily as a Vector.Unboxed so that I can fold over it?
09:35:08 <hodapp> pondering learning F# or OCaml, but... time.
09:35:11 <thomasd> I use an ExceptT monad transformer
09:35:43 <hackrilege> thomasd: haskell should be great for this! maybe try splitAt
09:35:45 <hackrilege> @src splitAt
09:35:45 <lambdabot> splitAt n xs = (take n xs, drop n xs)
09:36:13 <thomasd> and want to carry the reader monad environment inside of the ExceptT transformer around, to lexically scope the program
09:36:18 <hackrilege> sorry thats not the one i mean... 1 sec
09:36:23 <thomasd> maybe fold over the list of exprs, and carry the context around
09:36:31 <hackrilege> @src splitOn
09:36:31 <lambdabot> Source not found. My pet ferret can type better than you!
09:36:35 <thomasd> I've tried a while and am lost... but it probably needs more explanation than I'm giving
09:36:48 <Cale> thomasd: Shouldn't you worry about scope after you have the parse tree?
09:36:52 <ReinH> raichoo: More recent discussion on GND in SafeHaskell is at https://ghc.haskell.org/trac/ghc/ticket/8827
09:36:54 <thomasd> I have the parse tree
09:36:55 <hackrilege> @src Data.List.Split.splitOn
09:36:55 <lambdabot> Source not found. Do you think like you type?
09:37:09 <raichoo> ReinH: Anyway, the example in the Safe Haskell paper can be prevented to compile using type roles: https://gist.github.com/raichoo/8a94fbc706501a4e7864
09:37:10 <Cale> Okay, so your question has nothing to do with parsing really.
09:37:18 <hackrilege> omg lamdabot...
09:37:23 <thomasd> but right now I just construct a parse tree for each line of the program, delimited by semicolons
09:37:23 <hackrilege> :t Data.List.Split.splitOn
09:37:24 <lambdabot> Eq a => [a] -> [a] -> [[a]]
09:37:36 <ReinH> raichoo: Yes.
09:37:50 <hackrilege> thomasd: have you seen splitOn?
09:38:08 <hackrilege> > splitOn ';' "hello;world"
09:38:09 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
09:38:09 <lambdabot>      In the first argument of ‘splitOn’, namely ‘';'’
09:38:09 <lambdabot>      In the expression: splitOn ';' "hello;world"
09:38:11 <raichoo> ReinH: Ah thanks, looks interesting I'll put that on my reading stack :)
09:38:12 <Cale> thomasd: Construct the parse tree for the *whole* program, and then traverse that recursively with a function which takes an environment of bindings as a parameter.
09:38:17 <thomasd> splitOn doens't help me I think... I parse exprs and get hte parse tree line by line with this func:
09:38:24 <hodapp> huh, so OCaml does record polymorphism... that seems common in a lot of not-Haskell-but-FP-ish languages
09:38:26 <hackrilege> > splitOn ";" "hello;world"
09:38:28 <lambdabot>  ["hello","world"]
09:38:38 <thomasd> topLevel :: Parser [DimlExpr] topLevel = many $ do    e <- expr <* reservedOp ";"    return e 
09:38:51 <hodapp> is it mostly a bridge to OOP-ish stuff?
09:39:08 <Cale> Basically, if you're still parsing, don't worry about the scope of variables in your program.
09:39:18 <thomasd> let's say I have everything parsed
09:39:34 <thomasd> I have a list of Parser DimlExprs
09:39:38 <Freundlich> hodapp: Yes, Subtyping is motivated by OOP.
09:39:43 <thomasd> where DimlExpr is my cfg
09:39:53 <Cale> thomasd: You shouldn't have a list of parsers...
09:40:03 <hodapp> Freundlich: all subtyping?
09:40:05 <thomasd> ok, I was thinking that was the wrong way to go
09:40:13 <thomasd> should I just use ";" as an operator?
09:40:19 <Cale> thomasd: You should have already run the parsers, and have a single tree structure that contains the whole program.
09:40:19 <Freundlich> hodapp: I'm not sure if it's useful elsewhere.
09:40:22 <thomasd> right now I'm using it to delimit separate expressions
09:40:28 <thomasd> ok
09:40:42 <thomasd> so use the semicolon as an operator and get something like:
09:41:52 <hodapp> Freundlich: alright, good to know.
09:41:56 <thomasd> Semi (Equal (VarExpr "x") (DInt 5)) (Equal (VarExpr "x") (Add (VarExpr "x") (DInt 5))
09:41:57 <Cale> You'll probably want some sort of constructor somewhere among the types involved in your syntax tree which takes a list of statements as a parameter.
09:41:58 <hackrilege> one question I have initially about my cabal build, I do not wish to use the MIT licence, does anyone know of an "open source" licence which forbids coppying without reference?   
09:42:01 <thomasd> something like that?
09:42:19 <thomasd> if I want to set x = 5 and then x = x + 1
09:42:29 <thomasd> so: x = 5; x = x+1;
09:42:46 <hodapp> Freundlich: I suppose that'd make sense with Scala (having to integrate with Java) supports it
09:43:00 <Freundlich> Yeah.
09:43:08 <Cale> yeah, you could do that
09:43:17 <thomasd> what about the last semi colon?
09:43:24 <thomasd> it has nothing as the second expr
09:43:31 <thomasd> should I make a Void expr? :/
09:43:33 <Cale> Well, use sepEndBy, I guess.
09:43:40 <Cale> But I think it's better to collect entire sequences of statements
09:43:46 <thomasd> or should semicolons be left associative unary operators?
09:44:12 <thomasd> :t sepEndBy
09:44:13 <lambdabot> Not in scope: ‘sepEndBy’
09:44:18 <Cale> Note that you also might run into (and want to handle?) multiple semicolons with nothing in between.
09:44:38 <Cale> I'm assuming you're writing the parser with something like Parsec
09:44:59 <thomasd> yrds
09:45:00 <thomasd> yes
09:45:07 <Cale> http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Combinator.html#v:sepEndBy
09:45:16 <thomasd> just looked it up myself, thanks
09:45:30 <Cale> So you'll get a list of statements that way
09:46:11 <thomasd> I have a function that returns: Parser [DimlExpr]
09:46:13 <thomasd> I already have that though
09:46:26 <thomasd> but I want to lexically scope those dimlExprs (during typechecking)
09:46:36 <thomasd> so if I declare x = 5;
09:46:36 <Cale> and it'll probably be most convenient to just apply a constructor to that list, like  Block [Assign (Var "x") (DLit 5), Assign (Var "x") (Add (Var "x") (DLit 1))]
09:46:41 <thomasd> everything after the semicolon sees that
09:46:56 <bergey> hackrilege: BSD licenses require the copyright notice be retained, IIUC.
09:46:57 <thomasd> but I'm having trouble passing around the Reader env with the ExceptT monad transforme r:/
09:47:19 <hackrilege> thans bergey:
09:47:36 <thomasd> hmm, a new constructor. I might  try that
09:47:55 <thomasd> denoted by curly braces? how would I know if something is a "Block" or not?
09:48:02 <hackrilege> im going to use AllRightsReserved until i understand it better, ill look into BSD, it sounds perfect
09:48:09 <Cale> thomasd: Well, what is the syntax of your language?
09:48:57 <thomasd> well, right now it's just basic functional programming syntax, a bit like haskell, but using semi colons to delimit toplevel exprs
09:49:04 <Cale> thomasd: Typically, languages which have sequences of semicolon-delimited statements like this have places where it's okay to put such a sequence of semicolon-delimited statements, and places where it's not okay.
09:49:11 <thomasd> ahh
09:49:13 <Cale> It depends on the language.
09:49:27 <chpatrick> ooh GHC 7.10.2
09:49:54 <Cale> chpatrick: and it seems lambdabot is already running it
09:50:09 <Cale> chpatrick: The unsafeCoerce bug doesn't work :D
09:50:11 <thomasd> what if I want a top level, one line expr to be delimited by semi colons
09:50:19 <Cale> (the one which got fixed by 7.10.2)
09:50:20 <thomasd> like:
09:51:07 <thomasd> x = 5;\nx = x + 1;\nfun f(y:int):int = y + x;\ny x;
09:51:32 <Cale> It might help to look at http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Syntax.html
09:51:37 <thomasd> I want that to be a valid program, and for it to be lexically scoped
09:52:01 <kadoban> Hot damn, 7.10.2 got released? Nice. I wonder how that works with stack, if it'll figure out it exists or what …
09:52:03 <thomasd> Cale: I meant "f x" as the last statement
09:52:09 <Cale> In particular, notice how the Module constructor takes a [Decl] argument
09:52:09 <dolio> tommd: Ping.
09:52:25 <tommd> dolio: Hi
09:52:45 <tommd> dolio: Ping wrt vector-algorithms, yes?
09:52:48 <dolio> tommd: I'm pretty sure the function you want is in vector.
09:52:54 <tommd> Really, hurm...
09:52:55 <dolio> Which is why it's no longer in vector-algorithms.
09:52:59 * hackagebot cgrep 6.4.22 - Command line tool  https://hackage.haskell.org/package/cgrep-6.4.22 (NicolaBonelli)
09:53:04 <Cale> This is the sequence of declarations (which are technically semicolon delimited, once the offside rule gets applied to insert the semicolons) which is at the top level of a Haskell module.
09:53:10 <dolio> Data.Vector.Generic.modify
09:53:59 <kadoban> *reading the release blog thing* -XStrict is apparently a thing, that's … kinda interesting.
09:54:03 <tommd> dolio: Wow, very nice. Now I can just `sort = modify Tim.sort` it seems.  Thanks for the info!
09:54:03 <thomasd> I think I'm just lacking in knowledge right now. probably have to bang my head against it more.
09:54:14 <dolio> Yep. No problem.
09:54:35 <Cale> thomasd: and if you scroll down and find the Exp type, you'll notice that Let takes an argument of a type called Binds, and in turn one of the constructors of Binds is BDecls which takes a list of Decl values again
09:55:22 <thomasd> Cale: are you saying I should add a data constructor for a declaration? That might make it easier to lexically scope?
09:55:24 <Cale> thomasd: Or perhaps an even better example is the Do constructor for Exp
09:55:28 <thomasd> ok
09:55:29 <Cale> which takes a [Stmt]
09:55:45 <Cale> This has nothing at all to do with scope
09:55:55 <Cale> this is just about representing your complete program as a value
09:55:56 <thomasd> damn
09:56:13 <thomasd> so once I have that, scoping will be easy?
09:56:19 <thomasd> or, easier
09:56:42 <Cale> Uh, well, it ought to be. You shouldn't be thinking about parsing and concrete syntax things like semicolons when you're working out the scope of variables.
09:57:10 <Cale> That's conceptually at a later stage of the game, at least, in the normal way of doing things.
09:57:38 <thomasd> Right, because one is "parsing" and the other is "type checking"
09:57:55 <thomasd> but let's assume I'm done with the parsing (which I thought I was) and I just have a Parser [DimlExpr]
09:58:02 <thomasd> I am trying to lexically scope that
09:58:09 <thomasd> just during typechecking
09:58:15 <Cale> yeah -- well, scoping isn't necessarily type checking, but it's definitely after parsing regardless
09:58:38 <thomasd> but doesn't scoping just have to do with what variable has what type given a particular state of the program?
09:59:17 <hseg> OK. I'm at the home stretch. Why doesn't this work? http://lpaste.net/137541
10:00:30 <YellowOnion> Intolerable, thanks for the help yesterday.
10:00:44 <Intolerable> no problem
10:00:45 <Intolerable> happy to help
10:00:57 <thomasd> Cale: Thanks for the discussion. I'm at work so I've already spent too much time here XD
10:01:11 <thomasd> I may be back in a few days and let you know my progress
10:02:54 <YellowOnion> hseg, I was dealing with something like that yesterday, if I were to guess the type of 'c' is too general
10:03:13 <hseg> Hm. Ideas?
10:04:03 <YellowOnion> I was lazy, and just made my type that it needed to be.
10:04:42 <hseg> YellowOnion: Problem is, here the application itself demands polymorphism.
10:04:45 <geekosaur> the renaming of a to a0 suggests to me that the forall is preventing unification that might otherwise let it infer a Show instance?
10:05:14 <hseg> geekosaur: More likely it's the type family application.
10:05:15 <YellowOnion> hseg, indeed.
10:05:30 <hseg> geekosaur: We can deal with the Show instance later.
10:06:02 <hseg> Replacing the print with return and deleting Show a from the context, the problem of deducing c~Char remains.
10:07:32 <YellowOnion> Hmm, curious behaviour, I was expecting errors, but looks like Unboxed Vector is just slower than Boxed...
10:08:06 <xBlackyII> #elnoobs
10:08:20 <hseg> Actually, the problem is more basic. Given the definition of Elem, shouldn't ['a', ['b']] be able to be typed as [forall c. Char ~ Elem c => c] ?
10:09:11 <hseg> Hm, that's interesting. We do not have [1,'a'] :: [forall a. a]
10:09:24 <hseg> So attempts of this kind won't work.
10:09:26 <geekosaur> right, lists don't type that way
10:09:31 <hseg> Oh?
10:09:38 <geekosaur> afaik the only way to do that si a newtype
10:09:51 <YellowOnion> > [1, 'a']
10:09:52 <lambdabot>      No instance for (Num Char) arising from the literal ‘1’
10:09:52 <lambdabot>      In the expression: 1
10:09:52 <lambdabot>      In the expression: [1, 'a']
10:10:07 <hseg> :(. That kind of beats what I'm trying to do.
10:10:19 <hseg> Or does it...
10:10:32 <geekosaur> wasn't there discussion about that in the thread?
10:11:00 <hseg> There was a thread on this, yes. But I don't recall this point being discussed.
10:12:42 <dolio> The problem it's complaining about is that you turned on impredicative types, so when it goes to show your Tree (forall c ...), it can't find the Show instance for 'forall c. ...', which will never exist, because quantified types can't be class instances.
10:13:09 <dolio> Oh, that's just the first complaint, actually.
10:14:28 <YellowOnion> Oh, first issue found, only using 1 thread, so 6cores -> 1 core is pretty good for 70ms -> 120ms
10:14:29 * geekosaur wanted to try something but this ubuntu box has the wrong version of ghc...
10:14:30 <dolio> The other problem is that 'forall a. a' is not 'exists a. a'.
10:14:43 <dolio> But you're using 'forall a. a'.
10:14:54 <hseg> Oh? So how do you write exists a. a
10:14:55 <hseg> ?
10:15:11 <dolio> It's not a first-class thing like forall. You need to use a data type.
10:15:13 <geekosaur> (now that 7.10.2 is out I will be looking into replacing the system haskell install; next stop, the hp release which should happen within a day or so)
10:15:25 <dolio> data ExistsAA = forall a. EAA a
10:16:18 <dolio> Or: data ExistsAA where EAA :: forall a. a -> ExistsAA
10:17:51 <hseg> OK, I'll try that.
10:18:38 <magistr> forall it is all set of types in one typed variable
10:21:16 <Denommus> in push-pull FRP, can a event have multiple occurences at the same point of time?
10:21:19 <Denommus> like "occs ev" evaluating to "[(1,foo),(1,bar)]"?
10:22:21 <hseg> dolio: Awesome, I now have http://lpaste.net/137541 which compiles.
10:22:38 <hseg> All that remains is to get the resulting Tree to print.
10:24:07 <hseg> If I'd manage to type the resulting tree as Tree Char, I'd be done.
10:26:34 <conal> Denommus: yes. it has to, since it's faithful to the denotation.
10:26:55 <dolio> hseg: So, your tree is going to be Tree (Containing Char).
10:27:33 <Denommus> conal: ok, thanks
10:27:33 <hseg> Right. So either I need to find a way to unpack that, or I need to define a Show instance for Show a => Containing a
10:27:39 <conal> Denommus: you bet!
10:28:50 <Denommus> conal: are you aware of any library that I can use the source as a reference on how to implement the semantics efficiently?
10:28:51 <conal> i regret that the paper title ("push-pull frp") doesn't make clear that there's a simple, precise specification/denotation, independent of the push-pull (implementation) bit.
10:29:23 <dolio> hseg: You could add Containing to the family and so on.
10:29:39 <Denommus> conal: ah, I understand that. I just don't know exactly how to call those semantics, though. "Modern FRP"?
10:29:49 <hseg> dolio: So Elem (Containing a) = a?
10:30:03 <dolio> I'm not exactly sure this is a great design for, well, anything, though. Never mind if you're just trying things out, though.
10:30:09 <dolio> Right.
10:30:12 <hseg> dolio: Won't that self-reference cause trouble?
10:30:15 <conal> Denommus: some pretty old ones: http://conal.net/papers/plilpalp98/ and http://conal.net/papers/padl99/
10:30:35 <dolio> Which self-reference?
10:31:01 <hseg> dolio: Containing's constructor has Elem in its context.
10:31:08 <conal> Denommus: it's really the *presentation* of the semantics that was new in that paper, namely using the style i called "type class morphisms".
10:31:12 <dolio> Oh, I don't know if that will be a problem.
10:31:29 <hseg> dolio: So you might have C (C 'c')) :: Containing Char,
10:31:53 <Denommus> conal: so I can call it just "FRP"?
10:32:20 <hseg> dolio: This is only going to production in my nightmares.
10:32:24 <dolio> Yes, that part isn't really a problem, at least.
10:32:32 <conal> Denommus: the presentation comes out very elegantly & inevitably using this semantic-TCM style. it's equivalent to my old API & denotation, as mentioned in https://github.com/conal/talk-2014-lambdajam-denotational-design  and https://github.com/conal/talk-2015-more-elegant-frp 
10:33:07 <hseg> dolio: It's just an exploration of whether it is possible to well-type a function accepting a heterogeneous list of lists... of elements of the same type and return the corresponding tree.
10:33:27 <dolio> Okay. Carry on, then. :)
10:33:37 <conal> Denommus: yes. though be warned that many people these days use "FRP" much more loosely, even when there's no (implementation-independent) specification at all, let alone a simple & precise denotation, and even when they don't use continuous time.
10:33:48 <hseg> dolio: Right. Testing it out, it breaks all the equations which assume that Elem will only unpack [].
10:33:59 <hseg> dolio: I will, thanks :)
10:34:40 <conal> Denommus: see also https://github.com/conal/talk-2015-essence-and-origins-of-frp (better fit than the denotational-design talk I pointed you to).
10:34:55 <Denommus> conal: some colleagues have raised this issue as soon as I started studying FRP, fortunately. Also, I have seen your presentation "the essence of FRP"
10:35:33 <conal> Denommus: super.
10:36:37 <Denommus> conal: anyway, what I'm dreaming about is writing a FRP library for interactive systems on top of some lower-level language (in the "closer to the machine sense", not in the "less abstractions" sense). In my case, Rust
10:37:27 <conal> Denommus: ah. are you trying to use an implementation-independent specification?
10:38:09 <Denommus> conal: I'm reading as many papers and watching as many presentations as I can
10:39:02 <hseg> dolio: Hm. Somehow, I feel that I should be able to define a Show instance for Containing a for showable a, since the only possible values of type Containing a are of form C [[...[a]...]]
10:39:06 <conal> Denommus: if you'd like help understanding the specification (and even its motivation), let me know.
10:39:24 <hseg> i.e., comprised of showable types
10:39:25 <tommd> gcollins: Ping (re: io-streams PR)
10:39:42 <hseg> But GHC disagrees with me.
10:40:04 <Denommus> conal: absolutely. Thanks for your attention
10:40:15 <conal> Denommus: you're welcome. good luck!
10:41:11 <gcollins> tommd: I just moved house this past weekend, I might not get to it until Sunday or later
10:41:23 <tommd> gcollins: No problem, I'll ping another maintainer
10:41:26 <tommd> Thanks
10:41:56 <hseg> dammit. Turns out C ['a', ['b']] isn't well-typed either.
10:41:58 <hseg> Ugh.
10:42:12 <hseg> Wait....
10:42:22 <hseg> Dammit, I'
10:42:43 <hseg> ve been working so much on this that I've stopped thinking about whether what I want is possible.
10:42:58 <Darwin226> Hey guys, is there any benefit of `newtype D a b = D (a, b)` over `data D a b = D a b`?
10:43:05 <hseg> There isn't a way to well-type ['a',1], right?
10:43:14 <tommd> Darwin226: One is possible, the other is not.
10:43:36 <Darwin226> tommd: Why?
10:44:06 <quchen> Both are possible.
10:44:17 <tommd> Darwin226: Arg, my brain broke, never mind.
10:44:21 <quchen> The difference is in the subtleties of pattern matching, where newtypes get special treatment.
10:44:37 <cocreature> hseg: using a number of extensions you can have heterogeneous lists parametrized over a list of types
10:44:40 <tommd> Darwin226: The main thing about newtypes is behavior surrounding bottom and laziness.
10:45:27 <Darwin226> quchen: Anything in particular?
10:45:39 <hseg> cocreature: Yeah, but can I have a list of well-typed terms of any type? e.g. [1,'a',[[[True]]],Just(Just(False))] ?
10:45:47 <Darwin226> tommd: What behavior?
10:46:01 <cocreature> hseg: not a standard haskell list
10:46:18 <quchen> Darwin226: Do you know the difference between `data` and `newtype`?
10:46:22 <dolio> hseg: Any time you want something heterogeneous, under this scheme, you need to wrap the things in existentials.
10:46:29 <hseg> cocreature: Right, which defeats the purpose of the exercise. Damn.
10:46:46 <mniip> not really
10:46:48 <Darwin226> quchen: As far as I know, the newtype one has the identical representation to the hing it's holding at runtime.
10:46:55 <dolio> That includes inside the existentials, if there are multiple levels of heterogeny.
10:46:58 <Darwin226> thing*
10:47:15 <mniip> you could have a heterogeneous list with proper typing
10:47:33 <quchen> Darwin226: Right. This means that if a newtype's content is bottom, then that newtype itself is bottom.
10:47:36 <hseg> dolio: Right. So e.g. I need to write [C 'a', C [C'b', C ['a']]]
10:48:02 <quchen> ?let newtype Newtype a = Newtype a
10:48:03 <lambdabot>  Defined.
10:48:06 <hseg> mniip: Heterogeneous lists in general, yes. Heterogeneous lists of a type matching [a] for some a, no.
10:48:14 <quchen> > Newtype (error "newtype strictness") `seq` ()
10:48:15 <lambdabot>  *Exception: newtype strictness
10:48:38 <hseg> ?let data Newdata a = Newdata a
10:48:39 <lambdabot>  Defined.
10:48:43 <quchen> On the other hand, if we use `data`, then we don't necessarily have that behaviour.
10:48:52 <Darwin226> quchen: Yeah, I see. But in my example I have a tuple in the newtype and NO tuple in the data
10:48:52 <mniip> hseg, heterogeneous lists of a makes no sense by itself
10:48:53 <hseg> > Newdata (error "data laziness") `seq` ()
10:48:55 <lambdabot>  ()
10:48:56 <cocreature> if your heterogeneous list matches [a] it is not heterogeneous
10:49:19 <quchen> Darwin226: Your newtype is going to look identical to a tuple during runtime then.
10:49:39 <dolio> hseg: Yes, something like that.
10:49:55 <quchen> Darwin226: Your "D" type has the same shape as a tuple as well.
10:50:00 <Darwin226> quchen: Yeah, so I'm asking if there's a benefit of using a newtype around a tuple instead of introducing my own tuple-like type
10:50:15 <hseg> cocreature: mniip What I mean by "Types matching [a]" is all types matching this scheme. Including [forall a. a]
10:50:30 <hseg> cocreature: mniip Which isn't well-typed.
10:50:48 <SrPx> Hey this is kinda cool http://stackoverflow.com/questions/31707614/why-are-%CE%BB-calculus-optimal-evaluators-able-to-compute-big-modular-exponentiation
10:50:55 <quchen> Not really. I never had to worry about this except as intellectual exercise. But there are (observable) differences between the two, exposed as mentioned during pattern matching.
10:51:01 <mniip> data E = forall a. E a
10:51:12 <quchen> If you're interested in that you should have a look at the corresponding section in the Report.
10:51:15 <mniip> [E] there you go
10:51:17 <quchen> I'm afraid I don't have an example handy.
10:51:23 <ReinH> mniip: Ah, so by "types matching [a]", you don't mean "types matching [a]". Gotcha
10:51:35 <Darwin226> quchen: I see. Good to know then.
10:51:46 <mniip> ReinH,  wrong target?
10:52:11 <ReinH> mniip: Er. Yes.
10:52:28 <hseg> ReinH: :). Yeah...
10:53:01 * hackagebot binary 0.7.6.1 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.7.6.1 (LennartKolmodin)
10:53:12 <quchen> Darwin226: The gist of it is that newtypes can only ever have a single constructor, so pattern matching skips checking for whether that constructor is even there.
10:53:21 <hseg> ReinH: Rearticulating what I was trying to say, there is no way to well-type the naive heterogeneous list ['a', 1], right?
10:53:41 <mniip> you mean the syntactic sugar?
10:53:47 <quchen> Darwin226: A data type on the other hand does not have that guarantee. So if we want to decouple the semantics of pattern matching from the shape of the specific data matched, we cannot optimize the constructor away.
10:54:01 <Darwin226> quchen: I understand. In my case that doesn't matter though since the tuple constructor is protecting me from the bottom inside of it anyways. Right?
10:54:26 <quchen> "Does not matter" for most practical purposes.
10:54:49 <hseg> mniip: yeah. The expression ('a' : 1 : []) has no well-type, right?
10:54:53 <quchen> As mentioned, there are observable differences. But I think they're irrelevant for everyday coding, yet maybe useful to be aware of.
10:56:07 <hseg> Still, the exercise was useful in that it showed me that some constraints need to be plumbed through one's code.
10:56:15 <hseg> I hadn't thought of that.
10:56:23 <quchen> ?let data DataTuple a b = DT (a,b)
10:56:24 <lambdabot>  Defined.
10:56:37 <quchen> ?let data NewtypeTuple a b = NT a b
10:56:38 <lambdabot>  Defined.
10:56:54 <quchen> > case undefined of DT ("hello","world") -> "foo"
10:56:56 <lambdabot>  "*Exception: Prelude.undefined
10:57:28 <quchen> Eh that won't work. 
10:57:30 <quchen> One moment.
10:58:01 <hseg> OK, and now - to work! Thanks guys, for the enlightening conversation.
10:58:11 <quchen> I should save these examples for when I need them every couple of months :-þ
10:59:51 <Darwin226> quchen: haha
11:00:35 <quchen> Actually I'm thinking of the harder version of this, but the following will do:
11:00:36 <quchen> > case undefined of Newtype _ -> ()
11:00:38 <lambdabot>  ()
11:00:46 <quchen> > case undefined of Data _ _ -> ()
11:00:48 <lambdabot>  *Exception: Prelude.undefined
11:01:20 <quchen> You can observe differences even when your `data` type is strict in its arguments.
11:02:58 <Darwin226> Interesting
11:03:05 <quchen> newtype Newtype a = Newtype a
11:03:07 <hakujin> for those attending ICFP: you can select AM & PM sessions for the Haskell Symposium events on 9/3 and 9/4. will these two sessions have different content?
11:03:09 <quchen> data SData a = SData !a
11:03:14 <quchen>  > case undefined of Data _ -> ()
11:03:21 <quchen> > case undefined of SData _ -> ()
11:03:22 <quchen>  > case undefined of Data _ -> ()
11:03:23 <lambdabot>  *Exception: Prelude.undefined
11:03:24 <quchen> > case undefined of Data _ -> ()
11:03:25 <lambdabot>      Not in scope: data constructor ‘Data’
11:03:26 <lambdabot>      Perhaps you meant one of these:
11:03:26 <lambdabot>        ‘SData’ (line 144), variable ‘cata’ (line 147)
11:03:30 <quchen> > case undefined of SData _ -> ()
11:03:31 <lambdabot>  *Exception: Prelude.undefined
11:05:24 <ReinH> heh
11:08:33 <quchen> Darwin226: Hello again. This little session of not being able to use uparrow correctly got me k-lined for a couple of minutes. :-s
11:08:52 <kadoban> XD
11:09:02 <quchen> Serves me right I guess :-C
11:23:03 * hackagebot ZEBEDDE 0.1.0.0 - Polymer growth simulation method  https://hackage.haskell.org/package/ZEBEDDE-0.1.0.0 (hackrilege)
11:25:46 <jaseemabid> I have a particular source file compiling fine with GHC 7.10, but will fail with error `Not in scope: ‘<$>’` with GHC 7.8. I haven't explicitly imported <$>, but it somehow is available and things are working fine with 7.10. How do I debug this? Can I see how this function got imported?
11:26:32 <arkeet> @hoogle <$>
11:26:33 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
11:26:33 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:26:42 <arkeet> it's in Prelude in 7.10
11:26:44 <geekosaur> it's in the Prelude in 7.10 as part of the Applicative-Monad reorganization
11:26:48 <arkeet> but you have to import one of those to get it in earlier versions
11:27:42 <jaseemabid> arkeet: geekosaur Ah! That explains it. How do I write code to that works with both 7.8 and 7.10? 
11:27:52 <arkeet> just do the import.
11:28:34 <hackrilege> hello guys, I just uploaded my first package with cabal, but i cant use cabal install to download it! even after "cabal update". the source is at https://hackage.haskell.org/package/ZEBEDDE, does anyone know whay cabal does not download it with "cabal install zebedde"
11:28:50 <arkeet> case sensitive
11:28:52 <naudiz> is there a difference between Data.Functor.(<$>) and Control.Applicative.(<$>)?
11:28:54 <jaseemabid> arkeet: I get a warning that Data.Functor import is redundant. Can I supress that somehow? 
11:28:57 <arkeet> naudiz: no
11:29:12 <arkeet> jaseemabid: in 7.10? put "import Prelude" at the end of your import list.
11:29:15 <arkeet> it's kind of a hack.
11:29:42 <hackrilege> cabal install ZEBEDDE also fails
11:29:47 <arkeet> hmm.
11:30:01 <naudiz> that also reminds me... is there a way to apply NoImplicitPrelude to a whole project?
11:30:07 <jaseemabid> Should I import from data.functor or control.applicative? Applicative is a dependency for the project already
11:30:26 <benma> hi. is it bad practice to only have an application in your .cabal file and no library? i am trying to figure out how to unit test the application, but it seems you can only unit test the library
11:30:40 <benma> (with the test-suite section in .cabal)
11:30:44 <arkeet> naudiz: put extensions: NoImplicitPrelude in your cabal file
11:30:55 <naudiz> arkeet: thanks
11:31:13 <hackrilege> arkeet: any idea what went wrong?
11:31:40 <arkeet> hackrilege: works for m
11:31:41 <arkeet> e
11:31:46 <arianvp> why isn't Chan a functor?
11:31:48 <arianvp> :t Chan
11:31:50 <lambdabot> Not in scope: data constructor ‘Chan’
11:31:54 <arianvp> :k chan
11:31:55 <lambdabot> Not in scope: type variable ‘chan’
11:31:55 <hackrilege> ill run cabal update again i guess
11:31:56 <arianvp> :k Chan
11:31:57 <lambdabot>     Not in scope: type constructor or class ‘Chan’
11:31:57 <lambdabot>     Perhaps you meant ‘Char’ (imported from Data.Char)
11:32:05 <hackrilege> thanks for testing
11:32:12 <arkeet> arianvp: how would it work?
11:33:04 * hackagebot vty 5.2.10 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.2.10 (CoreyOConnor)
11:33:27 <jaseemabid> arkeet: The same warning with prelude in the end too. 
11:33:37 <arkeet> arianvp: at best, for chan :: Chan a, fmap f chan could be a duplicate channel with f mapped over the things in the channel.
11:33:42 <arkeet> wait never mind.
11:33:58 <arkeet> not duplicate in the sense of dupChan, but something with new inputs and outputs.
11:34:10 <arkeet> arianvp: but then "fmap f id = id" would fail. so it's no good.
11:34:23 <hackrilege> looks like my cabal is bust... fails on cabal install cabal-install
11:34:35 <arkeet> jaseemabid: then use something else from Prelude.
11:34:41 <arkeet> that's not covered by other imports.
11:35:00 <arkeet> jaseemabid: it's kind of a hack because it working is conditional on you using something from Prelude that's not in any other imports.
11:35:24 <jaseemabid> arkeet: Its ok. I can live with this warning. not a big issue. Thanks a lot mate! 
11:35:39 <naudiz> hackrilege: it might be a good idea to switch to stack
11:35:52 <hackrilege> seems like i have this bug https://mail.haskell.org/pipermail/haskell-cafe/2013-September/110337.html
11:36:09 <hackrilege> stack? ill have a look
11:36:11 <arkeet> jaseemabid: I think you can disable the warning with -fno-warn-unused-imports
11:36:15 <hackrilege> i like cabal...
11:37:18 <naudiz> hackrilege: stack solves a lot of problems with cabal-install. but you should get cabal-install working again first
11:37:38 <hackrilege> i have a completely clean build of windows, i did a factory reset today, i have just installed the haskell package fresh, maybe this is a bug?
11:38:04 * hackagebot cql 3.0.5 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-3.0.5 (ToralfWittner)
11:38:11 <kadoban> Why get cabal-install working? *shrug*
11:38:27 <naudiz> kadoban: to do cabal install stack
11:38:53 <hackrilege> kadoban it was my intended distribution chain, and as far i was aware, the standard way to interface with the hackage repo
11:39:49 <naudiz> hackagebot: no idea about windows. Can't imagine lots of people using haskell there
11:40:00 <hackrilege> wierd, cabal install stack fails with the same error, but cabal install openGL proceeds smoothly
11:40:20 <monochrom> what is the current version of cabal-install you're using?
11:40:22 <hackrilege> naudiz: im on windows
11:40:35 <monochrom> and preferrably also GHC version
11:40:44 <hackrilege> 1.18.1.3
11:40:56 <naudiz> hackrilege: don't install too many packages globally. that's the main problem with cabal
11:40:59 <hackrilege> 7.8.3
11:41:13 <monochrom> then I don't know what caused it
11:41:18 <naudiz> s/cabal/cabal-install
11:41:44 <hackrilege> monochrom: why?
11:41:53 <naudiz> hackrilege: I understood that you are on windows. I was implying that the build might be broken
11:42:02 <hackrilege> naudiz: im not sure what you ment by that last comment...
11:42:19 <hackrilege> ok
11:42:36 <kadoban> naudiz: You can just install stack via your OS instead.
11:43:03 <kadoban> hackrilege: It's standard as-in most people use it, but if you're going to end up using stack anyway I probably wouldn't bother.
11:43:27 <naudiz> hackrilege: I meant that there might be a lack of care about Windows
11:43:29 <geekosaur> this is not an issue with too many packages. it sounds like an older cabal-install trying to read a package list that requires a newer one... except I don't think there was any such change recentlyu
11:43:34 <arkeet> or you can just grab a stack binary.
11:43:35 <hackrilege> not cool!
11:44:12 <naudiz> kadoban: I forgot that most people use binary distributions
11:44:34 <hackrilege> im going to very carefully try and reinstall the haskell platform, i hope it works, cabal has never broken on me like this before...
11:45:10 <arianvp> hmm
11:45:54 <hackrilege> i have always used windows and haskell, with msys and mingw sometimes cygwin and more recently just using the windows command prompt. from these years i can report one finding, unix packages cannot be built on windows even with these unix emulators
11:46:02 <arkeet> hmmmm
11:46:24 <Fuuzetsu> hey, check out what Haddock's GSOC student implemented http://fuuzetsu.co.uk/images/1438195536.png , pretty cool, no?
11:46:32 <monochrom> hackrilege: there are files in %APPDATA%\cabal you may like to clear before you declare "I am starting clean"
11:46:37 <naudiz> hackrilege: maybe you should think about switching to Gentoo? ;)
11:46:47 <hackrilege> thanks monochrom:
11:46:55 <monochrom> (is it %APPDATA%?)
11:46:58 <kadoban> gentoo … such a pain to actually use.
11:47:00 <arkeet> (it is)
11:47:06 <Fuuzetsu> NixOS ;)
11:47:33 <naudiz> kadoban: not for me, but NixOS also seems to be great
11:47:41 <arkeet> Fuuzetsu: cool
11:47:51 <arkeet> can/will it also show associated types?
11:47:57 <Denommus> I'm curious about nix, it seems interesting
11:47:59 <hackrilege> naudiz: it is important haskell is well supported cross platform tool. i can forgive it cant handle unix as that is the fault of the emulator, but i will continue to build on windows and android as these are the most common opperating systems
11:48:20 <hexagoxel> :q
11:48:24 <Denommus> can I use it for server virtualization, like people do with docker?
11:48:29 <Fuuzetsu> arkeet: only like this http://fuuzetsu.co.uk/images/1438195664.png , apparently we can't get the info we need out of GHC though I have not myself looked yet
11:48:31 * hexagoxel heh
11:48:37 <arkeet> aw
11:49:36 <naudiz> hackrilege: I would never recommend Windows for programming, working, browsing or any other important stuff, but do as you want. 
11:49:59 <circ-user-eYIpW> What is the functor in Functor A with fmap?
11:50:16 <ReinH> circ-user-eYIpW: what do you mean?
11:50:38 <circ-user-eYIpW> DO I define a functor when specify A and fmap or fmap(myfunc) defines a concrete functor?
11:51:26 <hackrilege> naudiz: kids dont use arch! keep haskell accessible 
11:51:30 <naudiz> circ-user-eYIpW: you define a functor with instance Functor A where ...
11:51:34 <jaseemabid> Looks like 7.10 changed `(<*)` too. Adding explicit imports. 
11:52:02 <ReinH> jaseemabid: changed?
11:52:22 <Fuuzetsu> circ-user-eYIpW: the instance is the functor
11:52:33 <jaseemabid> ReinH: <* is probably part of prelude. Compiles fine on 7.10. Need explicit import for 7.8 
11:52:37 <Fuuzetsu> you use the functor's operation by using ‘fmap’
11:53:22 <circ-user-eYIpW> Wait, if List defines fmap, it is a functor, therefore. It already provides mapping between types.
11:53:29 <monochrom> kids can easily learn all three of Haskell, Linux, and Hungarian at the same time
11:54:01 <naudiz> hackrilege: that's on you Windows users, then. I'm not gonna support proprietary software, especially not spyware. Besides, Microsoft doesn't really make it easier to develop for their platform.
11:54:03 <hackrilege> its important cabal works out the box in windows, its the windows users way to obtain all things haskell, including stack.
11:54:35 <geekosaur> naudiz, please take the OS activism elsewhere
11:55:00 <kadoban> hackrilege: https://github.com/commercialhaskell/stack/wiki/Downloads#windows
11:55:03 <ReinH> hackrilege: Yes, it is. Please don't mind the troll.
11:55:05 <monochrom> I seldom use haskell on windows. but when I did, cabal worked.
11:55:15 <kadoban> Not that cabal shouldn't work, but …
11:55:18 <naudiz> geekosaur: I just explained myself to hackrilege.
11:55:18 <Fuuzetsu> circ-user-eYIpW: well, in a way we'd usually say that lists are a functor, or that maybe are a functor; in Haskell we just mean that they have a Functor instance
11:55:32 <Fuuzetsu> or that Maybe is a functor*
11:55:47 <ReinH> That said, ghc and cabal-install do work on Windows. IINM, Haskell Platform is still a reasonable way to get both.
11:56:06 <hackrilege> naudiz: the haskell platform for windows made my life a lot easier, and yes, as i said, the reason i will continue to use windows is to hopefully to be able to support this port. I only hope im not the only one! 
11:56:06 <monochrom> yes, I got mine from Haskell Platform, too
11:56:07 <geekosaur> there's also minghc
11:56:27 <hackrilege> thanks kadoban:
11:56:37 <monochrom> and I emphatically completely ignored "there is a new version of cabal-install. to update, blah blah blah"
11:56:54 <monochrom> err s/update/upgrade/
11:56:59 <ReinH> circ-user-eYIpW: Are you asking how Functor instances are functors in the category theoretical sense?
11:57:06 <circ-user-eYIpW> Functors provide mappings between types. Which kind of mapping does List provide?
11:57:18 <ReinH> The type constructor and implementation of fmap provide the object and morphism mappings, respectively
11:57:21 <hackrilege> im also trying to get ghc working on android, with some success, there is a great app at the playstore called gnuroot, which i have built the haskell platfor targeted at wheezy
11:57:35 <monochrom> think about it. if it's such a good idea to upgrade, why isn't it automatic? answer: it is not a good idea, so they want to trick you and still put the liability on you
11:57:36 <ReinH> Functor instances are endofunctors on Hask, the category of haskell types and functions.
11:58:00 <naudiz> hackrilege: please do so. I was just saying that if you want support for your platform, don't demand anything. most Haskell tools are free software
11:58:05 * hackagebot cql-io 0.14.5 - Cassandra CQL client.  https://hackage.haskell.org/package/cql-io-0.14.5 (ToralfWittner)
11:58:11 <dolio> monochrom: That line of reasoning isn't very good. :)
11:58:30 <ReinH> monochrom: Yes, sneaky, sneaky cabal install maintainers. ;)
11:58:34 <hiptobecubic> circ-user-eYIpW, not sure i understand your question
11:58:42 <hackrilege> naudiz: im glad there is support on those fronts also
11:58:57 <mauke> circ-user-eYIpW: List maps a type T to List T
11:58:59 <ReinH> hackrilege: [], as a type constructor, is a mapping between types
11:59:03 <ReinH> Like all type constructors
11:59:11 <hackrilege> i think in all likelyhood i broke my cabal when uploading my first package to hackage just now
11:59:26 <dolio> "If it's such a good idea to re-run 'cabal configure', why isn't it automatic?" (Prior to the last couple versions of cabal-install.)
11:59:27 <hiptobecubic> circ-user-eYIpW, (fmap f list) is a list with f applied to each of the elements in order
11:59:42 <ReinH> hiptobecubic: or not in order
11:59:49 <circ-user-eYIpW> Let's take Maybe a. Does it map a to Maybe a or Maybe a to Maybe b?
11:59:49 <hackrilege> ReinH: I think you misdirected that to me...
11:59:55 <ReinH> hackrilege: yep sorry
11:59:58 <hackrilege> kk
12:00:06 <mauke> circ-user-eYIpW: 'Maybe a' is not a Functor
12:00:12 <ReinH> circ-user-eYIpW: [] is a mapping between types, like all type constructors.
12:00:18 <ReinH> circ-user-eYIpW: Maybe maps a to Maybe a
12:00:35 <ReinH> [a] (a.k.a., [] a)  maps a to [a]
12:00:37 <ReinH> etc
12:00:38 <hiptobecubic> ReinH, sure. I mean the fmap that's defined in Haskell.
12:00:41 <ReinH> That is the object mapping.
12:01:11 <ReinH> er, [] map a to [a]
12:01:12 <hiptobecubic> ReinH, I don't understand what you mean by not in order?
12:01:49 <hiptobecubic> ReinH, `fmap id` should be `id`, no?
12:02:13 <hackrilege> yes cabal install cabal-install working now... i wonder why it broke...
12:02:20 <ReinH> hiptobecubic: We're just talking about different things
12:02:33 <hackrilege> required a full reinstall...
12:05:39 <ReinH> hiptobecubic: reverse . map f . reverse is a valid definition of fmap that doesn't map the elements "in order", but that's not what you meant by "in order". ;)
12:06:04 <quchen> ReinH: No, because it won't work on infinite lists
12:06:15 <ReinH> lalalala can't hear you infinite lists don't real
12:06:34 <joco42> hamishmack: I am trying out Leksah dmg under Mac, what metadata sources should I add ? http://snag.gy/Bn0N9.jpg
12:06:40 <ReinH> anyway, you get my point and you see that it isn't very interesting.
12:07:53 <joco42> hamishmack: what does the directory need to contain such that Leksah can generate metadata from ? cabal files ?
12:08:01 <hiptobecubic> ReinH, is it, actually? Does it not matter than fmap id and id will not be substitutable becaues of _|_?
12:08:02 <quchen> :t \f zs -> let (xs,ys) = splitAt 5 zs in (reverse (map f (reverse xs))) ++ map f ys -- ReinH :-)
12:08:03 <lambdabot> (a1 -> a) -> [a1] -> [a]
12:08:06 <hiptobecubic> because*
12:08:32 <quchen> hiptobecubic: [1,1..] is not ⊥.
12:08:51 <hiptobecubic> quchen, isn't `reverse [1,1..]` ?
12:08:56 <quchen> Oh, that one is.
12:08:58 <ReinH> hiptobecubic: Well, it isn't becuse of what quchen said.
12:09:16 <dolio> Just stipulate that you're talking about finite lists, which you can also define in Haskell.
12:09:25 <ReinH> But other versions that apply f in a different evaluation order, but still element-wise, work
12:09:29 <ReinH> It's also boring.
12:09:32 <quchen> dolio: Via strict (:)?
12:09:40 <dolio> Yeah.
12:10:24 <ReinH> circ-user-eYIpW: Does that make sense?
12:10:37 <hackrilege> should I still use HUnit for unit tests to be performed by cabal?
12:11:09 <circ-user-eYIpW> I define fmap for Maybe. Maybe must be a functor.
12:11:41 <ReinH> circ-user-eYIpW: When you say "functor", what specifically do you mean?
12:11:42 <hackrilege> :t (Just 0)
12:11:43 <lambdabot> Num a => Maybe a
12:12:08 <circ-user-eYIpW> That is my question. I got that meaning from you.
12:12:22 <kadoban> circ-user-eYIpW: Maybe is a Functor, yes.
12:12:38 <ReinH> A functor is a mapping between categories. Do you know what categories are?
12:12:49 <hackrilege> does anyone have any unit testing suites they prefer to HUnit for use with cabal?
12:13:08 <ReinH> hackrilege: hunit is pretty good, especially combined with quickcheck
12:13:24 <hackrilege> thanks for the headsup on quickcheck i didnt know that one
12:13:27 <ReinH> So is hspec
12:13:29 <quchen> A functor can be many things, depending on who's asking. In C++ a functor is an object with overloaded () operator. But that won't help a beginner in Haskell either.
12:13:36 <ReinH> Some people are using tasty as a testing framework to manage both
12:13:55 <hackrilege> tasty! cool, it works with cabal?
12:13:56 <ReinH> quchen: Yes, this is why I stopped to define terms.
12:14:18 <ReinH> hackrilege: yep
12:14:40 <quchen> What I meant to say is "don't suggest category theory" :-þ
12:14:45 <hackrilege> from wiki on categorys, In mathematics, a category is an algebraic structure that comprises "objects" that are linked by "arrows"
12:14:52 <hackrilege> so i guess we need a definition of arrow
12:14:55 <kadoban> ReinH: That's kind of a bad question though … if I got that question it would make me look up CT and it kind of implies that category theory is vital to the conversation.
12:15:20 <ReinH> kadoban, quchen: If they want to know what a functor is besides "a typeclass in Haskell", what else would you suggest?
12:15:21 <ww> hmmm... attoparsec problem: http://lpaste.net/137549
12:15:52 <ww> this is meant to be able to parse "x" and "x*y"
12:16:00 <ReinH> If they don't: A Functor is a typeclass with a method fmap, implementations of which must satisfy a law.
12:16:06 <hackrilege> ]it seems to me that a category is simply a collection of objects and mappings between them 
12:16:16 <ReinH> hackrilege: with some structure
12:16:32 <quchen> ReinH: It provides an operation to modify a data structure with a sense of changing the data, but not the shape of it. Here are some good examples (e.g. lists). Here are some less obvious examples (e.g. parsers). Here's a trivial example (Identity, Proxy).
12:16:34 <ww> as is, it does not parse "x*y" and returns an error. if i change line 25 to read 'times <|> var' instead, it spins the cpu...
12:16:34 <hackrilege> associativity and identity
12:16:36 <ReinH> e.g., a graph is also a collection of objects and mappings between them, but a graph is not a category.
12:16:37 <ww> help?
12:16:55 <ReinH> quchen: fair enough
12:17:23 <quchen> ReinH: What it means to "not change the shape" is covered by the functor laws, of which you only have to understand the first for the most part: modifying the structure with a NOOP is a NOOP.
12:17:50 <quchen> ReinH: What it *means* to "not change the shape" is covered by working with it until you find out yourself. :>
12:18:00 <ReinH> ww: you have two options: back tracking and left factoring.
12:18:23 <ReinH> quchen: I like that explanation.
12:18:39 <quchen> ReinH: It works for monads too. :-)
12:18:44 <ReinH> quchen: yep :)
12:18:49 <ReinH> It's very similar to the one I use.
12:18:55 <kadoban> ReinH: Does he actually want to know that? I didn't see a part that suggested it.
12:18:55 <quchen> What's yours?
12:19:00 <ww> ReinH: elaborate?
12:19:01 <ReinH> Basically that.
12:19:22 <ReinH> quchen: Although I lean a bit less on analogies and more on experimentation
12:19:24 <kadoban> Maybe he did ask … nevermind then.
12:19:52 <quchen> > let reinH'sExplanation = whatQuchenSaid; whatQuchenSaid = reinH'sExplanation in whatQuchenSaid
12:19:56 <lambdabot>  mueval-core: Time limit exceeded
12:20:02 <ReinH> quchen: :p
12:20:11 <hackrilege> a category is a collection of objects and mappings which who can be compared associatively, where the identity is equivalence  
12:20:20 <quchen> ReinH: For Applicative I haven't found anything yet though.
12:20:23 <YellowOnion> is there a case for repeating a monad x times (replicateM?) I need a monadic iternate of sorts.
12:20:30 <ReinH> not "compared associatively"
12:20:34 <Iceland_jack> :t replicateM
12:20:35 <lambdabot> Monad m => Int -> m a -> m [a]
12:20:37 <ReinH> There is composition of mappings, which is associative.
12:20:58 <quchen> ReinH: I skip Applicative when explaining Functor/Monad for that reason. I briefly mention there's a useful stage between and that's about it.
12:21:06 <hackrilege> no its a composition of comparisons between mappings
12:21:21 <ReinH> hackrilege: What is "a comparison between mappings"?
12:21:34 <ReinH> Because that is not a part of any definition of category that I have seen.
12:21:48 <hackrilege> for every three objects a, b and c, a binary operation hom(a, b) × hom(b, c) → hom(a, c) called composition of morphisms
12:21:58 <Zemyla> ReinH: Talk about parsers for applicative.
12:22:03 <ReinH> That isn't the question
12:22:08 <bitemyapp> ReinH: tell me about your childhood
12:22:14 <ReinH> bitemyapp: :p
12:22:19 <bitemyapp> ReinH: talk about purple elephants
12:22:25 <bitemyapp> ReinH: SCHNELL SCHNELL
12:22:37 <bitemyapp> ./topic Give orders, take orders - functionally
12:22:42 <YellowOnion> Iceland_jack, ghci is giving me type errors that are a bit over my head.
12:22:49 <hackrilege> im getting this from https://en.wikipedia.org/wiki/Category_(mathematics)
12:22:50 <bitemyapp> splain :: IO ()
12:22:52 <Iceland_jack> What do you want to do YellowOnion 
12:23:07 <ReinH> hackrilege: What is "a comparison between mappings"?
12:23:32 <hackrilege> ReinH: for every three objects a, b and c, a binary operation hom(a, b) × hom(b, c) → hom(a, c) called composition of morphisms
12:23:34 <ReinH> The wikipedia article doesn't include the word "comparison"
12:23:36 <YellowOnion> > iterate (+1) 1 !! 4
12:23:37 <lambdabot>  5
12:23:51 <quchen> "comparable" is probably a form of "related to via".
12:23:52 <ReinH> That is not "a comparison between mappings". That is a definition of composition.
12:23:58 <YellowOnion> Iceland_jack, I'm trying to make replicateM do that
12:23:58 <ReinH> What is "a comparison of mappings"?
12:24:15 <hackrilege> well gee it seems i am retarded, my apologies 
12:24:55 <YellowOnion> :t replicateM 4 (fmap (+1))
12:24:56 <lambdabot> (Functor f, Num b) => f b -> [f b]
12:24:58 <hackrilege> a category is a collection of objects and mappings which who can be composed associatively
12:25:43 <hackrilege> a category is a collection of objects and mappings which who can be composed associatively including the identity mapping
12:26:00 <int-e> :t foldr (>=>) return (replicate ?n ?f)
12:26:01 <lambdabot> (Monad m, ?f::c -> m c, ?n::Int) => c -> m c
12:26:37 <hackrilege> anyway, it seems the discussion has moved on, what did we need the definition of a category for?
12:26:47 <hackrilege> something to do with functors...
12:27:31 <hackrilege> quchen: actually i completely misread composed as compared... doh
12:29:06 <monochrom> several years later, an O-category will have you compare morphisms, too :)
12:29:07 <hackrilege> sets and functions between them including the identity form a category for example
12:31:08 <hackrilege> i dont like this category O
12:31:43 <monochrom> Oh! Category. Oh! Calcutta.
12:33:59 <ReinH> hackrilege: I was asking someone else if they knew to try to figure out the proper way to explain something
12:34:28 <ReinH> I am familiar with categories.
12:34:43 <hackrilege> yes but what were you about to explain
12:34:47 <ReinH> functors
12:34:55 <ReinH> And how Functors are functors
12:35:02 <ReinH> But apparently that wasn't the question being asked
12:35:06 <hackrilege> im slowly learning about functors as its all people talk about here
12:35:16 <ReinH> Well, they're kind of a big deal
12:35:30 <ReinH> Although not as big a deal as all that
12:35:41 <ReinH> Especially in Haskell, where they're pretty boring.
12:35:46 <hackrilege> how is a Functor a functor? (seems a strange point to be making, but thats probably cos i dont know what you mean)
12:36:21 <ReinH> Instances of the Functor typeclass have an object mapping (the type constructor) and an arrow mapping (the implementation of fmap). The Functor laws are the functor laws.
12:36:26 <arkeet> anything of kind * -> * defines a mapping of types (objects in Hask)
12:36:32 <hackrilege> thanks Cpt_obv:
12:36:38 <arkeet> the Functor instance just gives the mapping on morphisms
12:36:52 <ReinH> hackrilege: you asked the question.
12:36:54 <arkeet> which is required by the definition of a functor
12:37:23 <hackrilege> ReinH: yes, im happily reading the answer, I was just laughing with ggVGc
12:37:36 <ReinH> Oh, you weren't calling me captain obvious.
12:37:39 <hackrilege> sorry..
12:38:39 <hackrilege> why 2 mappings only? or why not 1?
12:38:59 <ReinH> That's the definition of a functor.
12:39:06 <hackrilege> h!
12:39:08 <hackrilege> oh!
12:39:13 <hodapp> ho?
12:39:22 <hackrilege> sorry, i was still thinking about categories...
12:39:31 <hackrilege> how is a functor related to a category?
12:39:53 <ReinH> A functor is a mapping between categories
12:40:00 <hackrilege> aha!
12:40:30 <ReinH> it works on the structure of a category, which is objects and arrows, so it takes objects to objects and arrows to arrows
12:40:32 <hackrilege> 2 mappings...
12:40:49 <hackrilege> great thanks
12:40:53 <ReinH> It also preserves the properties of a category, so it preserves identities and composition.
12:40:56 <ReinH> those are the laws
12:41:06 <hackrilege> brilliant! finally
12:41:12 <hackrilege> thanks
12:41:13 <sdegutis> Those of you who have come from Clojure to Haskell, how do you deal with not having the thread-last macro (->>) when transforming deeply nested collections?
12:41:28 <Cptn_obv> ReinH: haha, it wasn't for this channel. It was in #vim
12:41:31 <Cptn_obv> sorry
12:41:34 <ReinH> Cptn_obv: :p
12:41:48 <ReinH> Cptn_obv: I got that from ggVGc ;)
12:43:25 <hackrilege> so e.g. numbers are objects, and addition and multiplication are arrows, so what is an example of a functor on this category?
12:43:59 <hackrilege> (i guess actually there are infinitly many n arrows (+n) and (*n))
12:44:51 <aweinstock> hackrilege: the identity functor, mapping every object/arrow to itself?
12:45:14 <hackrilege> or (*2)?
12:45:27 <ReinH> hackrilege: first, define the category
12:45:30 <hackrilege> taking e.g. (+2) -> (+4)
12:45:31 <ReinH> and show that it is, in fact, a category
12:46:05 <hackrilege> my category is the integers and my arrows are (+n),(*n) forall n
12:46:26 <arkeet> hackrilege: arrows go from one object to another object.
12:46:39 <arkeet> what are the two objects for the "addition" arrow?
12:46:47 <arkeet> or (+2) or whatever.
12:46:51 <hackrilege> yes for object m the opperation (+n) for some n takes m to m+n
12:46:57 <arkeet> that's not an answer.
12:47:02 <naudiz> should you really call it "objects"?
12:47:23 <naudiz> "operands" would be more precise
12:47:24 <arkeet> an arrow has a single source object and a single target object.
12:47:34 <hackrilege> !? what is wrong with this...
12:47:42 <arkeet> what is the source and target of (+2)?
12:47:51 <arkeet> (if (+2) is an arrow)
12:47:59 <hackrilege> (+2) given m returns m+2
12:48:09 * hodapp realizes he just reinvented applicative style, badly, using... badly-done applicative style
12:48:11 <hodapp> GRAAAH
12:48:14 <hackrilege> an integer, so an object within my category
12:48:27 <arkeet> which integer?
12:48:33 <hackrilege> m+2
12:48:39 <arkeet> what's m
12:48:45 <arkeet> ok let's start over.
12:48:50 <hackrilege> supplied as the object the arrow was opperating on...
12:49:02 <arkeet> no, arrows don't "operate" on objects.
12:49:07 <hackrilege> lets not start over!
12:49:10 <naudiz> hackrilege: wrong is that there are no objects in haskell, although you could implement something similar
12:49:21 <arkeet> a category consists of such data:
12:49:30 <arkeet> - a collection of things which we call objects
12:49:37 <arkeet> - another collection of things, which we call arrows (or morphisms)
12:49:42 <hackrilege> naudiz: the definition of a category is that it consists of objects and arrows
12:50:00 <arkeet> - for each arrow, there are two corresponding objects, called the source and target (or domain and codomain) of the arrow.
12:50:26 <hackrilege> arkeet, im not sure you understand me, im sure i have not said anything wrong. making me repeat what is not incorrect is timewasting
12:50:41 <naudiz> hackrilege: so it's a precise definition? in that case, nevermind.
12:50:46 <ReinH> naudiz: we aren't talking about OOP
12:50:50 <arkeet> hackrilege: what are the objects and the arrows of your category?
12:51:01 <hackrilege> just cut to the chase, i already gave the definitions you repeated
12:51:18 <arkeet> (I didn't finish the definition of category, but there are identity arrows and composition)
12:51:26 <hackrilege> my category is the integers and my arrows are (+n),(*n) forall n
12:51:28 <aweinstock> arkeet: is (+5) a set of arrows between (1,6), (2,7), ...?
12:51:33 <aweinstock> (an infinite set of arrows)
12:51:41 <arkeet> aweinstock: don't ask me.
12:51:48 <arkeet> a set of arrows isn't an arrow.
12:51:52 <ReinH> (+n) is not an arrow
12:52:00 <ReinH> It does not have a defined domain and codomain
12:52:17 <arkeet> hackrilege: so objects are integers?
12:52:24 <ReinH> I can't ask dom((+n)) and get an answer
12:52:24 <hackrilege> integers are objects
12:53:02 <shachaf> Objects are a red herring.
12:53:09 <arkeet> ok, so which integer is the source/domain of (+2)?
12:53:12 <hackrilege> so given objects n,m the arrow (-n+m) takes n to m
12:53:28 <shachaf> People hear "a category has objects and arrows" and they think "objects, well, that sounds concrete" and they focus on the objects.
12:53:36 <ReinH> shachaf++
12:53:49 <shachaf> But the arrows are the concrete thing in a category. The objects don't even matter. You can make a category without objects, no problem.
12:53:56 <arkeet> hackrilege: ok, here's a category:
12:54:04 <hackrilege> thanks
12:54:08 <hodapp> kinda like how people started focusing just on the objects in OOP instead of the messaging, which Alan Kay later lamented.
12:54:13 <arkeet> - this category has one object, the set of integers.
12:54:24 <arkeet> - for each integer, an arrow (+n) from the set of integers to the set of integers.
12:54:29 <arkeet> for each integer n
12:54:34 <hackrilege> the domain is the integers as is the codomain
12:54:42 <arkeet> yes.
12:54:46 <arkeet> but 
12:54:53 <arkeet> when viewed as a category,
12:54:58 <arkeet> objects have *no internal structure*
12:55:00 <sdegutis> Ping?
12:55:02 <hackrilege> that was the definition i just gave!!!
12:55:16 <ReinH> hackrilege: no, dom and codom give objects
12:55:29 <arkeet> if I say "the set of integers" is an object
12:55:36 <mauke> no, you said <hackrilege> so e.g. numbers are objects
12:55:38 <arkeet> an integer is not an object.
12:55:38 <ReinH> they give the objects that are the domain and codomain of the arrow.
12:55:40 <arkeet> 5 is not an object.
12:55:46 <arkeet> 5 is not the set of integers.
12:55:53 <hackrilege> i thought the codomain was the collection of objects mapped to from a domain, which is also a set
12:56:02 <ReinH> So "the domain is the integers" is a type error
12:56:19 <ReinH> the domain and codomain *of an arrow* are objects.
12:56:22 <shachaf> The category has one object, which is the string "the integers".
12:56:51 <ReinH> an arrow maps from an object to an object. domain and codomain give those objects.
12:57:13 <hackrilege> so (\ 5 -> 5+2) is an arrow?
12:57:29 <hackrilege> with domain 5 and codomain 7?
12:57:30 <ReinH> "integers are objects" is, at best, like saying "plants are trees"
12:57:58 <arkeet> time to give up and get some lunch.
12:58:29 <hackrilege> thanks for your help anyhow, sorry if i got a bit frustraited
12:58:53 <mauke> the lunch arrow goes from food to your mouth
12:59:30 <hackrilege> so i think Maybe is a functor, so that must mean it maps both objects to objects, and mappings between these objects to mappings between objects...
12:59:45 <hackrilege> :t fmap.Just
12:59:47 <lambdabot>     Couldn't match type ‘Maybe a1’ with ‘a -> b’
12:59:47 <lambdabot>     Expected type: a1 -> a -> b
12:59:47 <lambdabot>       Actual type: a1 -> Maybe a1
13:00:02 <hackrilege> :t fmap
13:00:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:00:16 <hackrilege> :t (fmap id).Just
13:00:17 <lambdabot> b -> Maybe b
13:00:22 <ReinH> :t fmap `asAppliedTo` Nothing
13:00:25 <lambdabot>     Couldn't match expected type ‘a -> b’ with actual type ‘Maybe a0’
13:00:25 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘Nothing’
13:00:25 <lambdabot>     In the expression: fmap `asAppliedTo` Nothing
13:00:30 <ReinH> woops
13:00:39 <ReinH> :t flip fmap `asAppliedTo` Nothing
13:00:41 <lambdabot> Maybe a -> (a -> b) -> Maybe b
13:00:44 <ReinH> that's annoying
13:00:54 <ReinH> Anyway, fmap for Maybe is (a -> b) -> Maybe a -> Maybe b
13:00:55 <uiop> :t asAppliedTo
13:00:56 <lambdabot> (a -> b) -> a -> a -> b
13:01:02 <ReinH> which is your arrow mapping
13:01:12 <ReinH> and Maybe, the type constructor, is your object mapping
13:01:31 <ReinH> It helps if you read that type as (a -> b) -> (Maybe a -> Maybe b)
13:02:08 <hackrilege> (+2) `asAppliedTo` 3 4
13:02:21 <hackrilege> > (+2) `asAppliedTo` 3 4
13:02:22 <lambdabot>      Could not deduce (Num a0)
13:02:22 <lambdabot>      from the context (Num b, Num a, Num (a -> b))
13:02:22 <lambdabot>        bound by the inferred type for ‘e_1234’:
13:02:30 <hackrilege> > (+2) `asAppliedTo` 3 
13:02:32 <lambdabot>  <Integer -> Integer>
13:02:41 <hackrilege> urgh
13:02:53 <hackrilege> :t (+2) `asAppliedTo` 3 
13:02:54 <lambdabot> Num b => b -> b
13:03:05 <hackrilege> ( (+2) `asAppliedTo` 3 ) 4
13:03:15 <hackrilege> > ( (+2) `asAppliedTo` 3 ) 4
13:03:16 <lambdabot>  6
13:03:20 <hackrilege> omg
13:03:34 <hackrilege> > ( (+2) `asAppliedTo` 5 ) 1
13:03:35 <lambdabot>  3
13:03:46 <hackrilege> i have nno ide what is going on
13:04:16 <ReinH> @djinn (a -> b) -> a -> a -> b
13:04:16 <lambdabot> f a b _ = a b
13:04:48 <hackrilege> > ( (+2) `asAppliedTo` 5 ) 2
13:04:49 <lambdabot>  4
13:04:50 <ReinH> Well, djinn picked the wrong one
13:05:00 <hackrilege> > ( (+2) `asAppliedTo` 6 ) 2
13:05:02 <lambdabot>  4
13:05:04 <hackrilege> ok
13:05:05 <ReinH> it's f a _ b = a b
13:05:14 <ReinH> It uses the supplied argument for its type information and discards the value
13:05:23 <ReinH> allowing type inference to give a specialized type for a
13:05:42 <hackrilege> arse error
13:05:43 <arkeet> ReinH: that's not exactly the same.
13:05:45 <hackrilege> parse*
13:05:56 <ReinH> arkeet: oh no?
13:05:59 <arkeet> ReinH: because with your definition, f _|_ x /= _|_
13:06:02 <uiop> :t \f a b -> f (asTypeOf b a)
13:06:03 <lambdabot> (a -> r) -> a -> a -> r
13:06:12 <ReinH> arkeet: Ah right
13:06:34 <uiop> @pl \test->test
13:06:34 <lambdabot> id
13:06:40 <uiop> @pl \f a b -> f (asTypeOf b a)
13:06:40 <lambdabot> (. flip asTypeOf) . (.)
13:07:07 <hackrilege> so if something other than 6 also could have (+2) applied to it, then if i wrote that it would fix the type of (+2) to opperate o objects of that type
13:07:16 <uiop> :t [asAppliedTo, (. flip asTypeOf) . (.)]
13:07:17 <lambdabot> [(c -> b) -> c -> c -> b]
13:07:29 <arkeet> hackrilege: arrows, in general, don't "operate on" things.
13:07:33 <arkeet> they are just arrows.
13:07:42 <hackrilege> which are?
13:07:59 <arkeet> anything you like.
13:08:05 <hackrilege> mappings between the objects of a category?
13:08:17 <arkeet> that's how one might interpret them, but 
13:08:24 <hackrilege> so "opperate on" these objects?
13:08:25 <arkeet> the definition of a category doesn't specify what objects or arrows "are".
13:08:44 <arkeet> you just have one collection of things, which you give the name "objects"
13:08:51 <arkeet> and another collection, which you give the name "arrows"
13:10:24 <hackrilege> i think actually the arrow is strictly defined as a pair of objects
13:10:26 <arkeet> it is perfectly valid for arrows to be functions, or numbers, or points in space, or bananas, etc.
13:10:56 <arkeet> no. there is a mapping from the collection of arrows (in a category) to the collection of pairs of objects (in the same category)
13:10:59 <hackrilege> it must not be a banana, it must map an object to another object
13:11:05 <arkeet> but you can have many arrows (or none) corresponding to any pair of objects.
13:11:37 <arkeet> well yes, I can declare that my objects are 1 and yellow, and the banana has domain 1 and codomain yellow.
13:11:41 <hackrilege> since the mapping you described is bijective it is equivalent? 
13:11:42 <arkeet> that is a perfectly valid thing to do.
13:12:22 <arkeet> there are also indentity arrows from 1 to 1 and yellow to yellow.
13:12:30 <hackrilege> so how is the terminolgy that a banana operates on 1 and returns yellow?
13:12:37 <arkeet> again, arrows don't operate on things.
13:12:44 <arkeet> they are not functions.
13:12:55 <arkeet> (in general.)
13:13:01 <hackrilege> and the 2 identity arrows opperate on each of the respective objects?
13:13:08 <ReinH> You keep using that word.
13:13:18 <hackrilege> they cast objects to objects...
13:13:19 <mauke> I'll operate on your face.
13:13:24 <arkeet> they don't *do* anything.
13:13:26 <arkeet> they just exist.
13:13:26 <ReinH> They don't operate. They don't cast.
13:13:27 <Welkin> wtf is going on in here?
13:13:43 <mauke> Welkin: abstract nonsense
13:13:50 <arkeet> there are relations between objects and arrows.
13:13:53 <bitemyapp> Welkin: nothing is true, everything is permitted
13:13:54 <arkeet> but
13:13:56 <Welkin> how do I learn abstract nonsense?
13:14:04 <bitemyapp> Welkin: hi magistr.
13:14:15 <arkeet> "object" and "arrow" are just names.
13:14:27 <lamefun> What's the recommended digital signature library?
13:14:29 <hackrilege> apparently an the banana arrow which "arrows" from 1 to yellow is not "opperating" on 1 and "returning" yellow, and this is very important for as yet some unclear reason
13:14:55 <ReinH> ...
13:15:05 <mauke> it's not very important but you keep bringing it up
13:15:05 <ReinH> Are you trying to make people not want to help you?
13:15:22 <ReinH> Because that's how you make people not want to help you.
13:15:35 <hackrilege> im trying to get you to see that the distinction you are making is not one you have made clear
13:15:35 <arkeet> when you define a category, you define the meaning of "object" and "arrow".
13:15:44 <arkeet> which are just terminology anyway.
13:15:52 <sdegutis> Can anyone see this?
13:15:56 <ReinH> sdegutis: yes
13:16:00 <sdegutis> Okay thanks.
13:16:08 <arkeet> it would have been equally valid to use "nork" and "wibble" instead of "object" and "arrow".
13:16:14 <sdegutis> I guess my question was just uninteresting thne.
13:16:26 <hackrilege> your honestly really confusing me, i dont understand why these semantics are so important?
13:16:46 <arkeet> a category is an abstract structure.
13:17:09 <arkeet> in some categories, arrows are functions.
13:17:16 <arkeet> in others, they aren't.
13:17:31 <arkeet> because their definition gives the name "arrow" to some other kind of thing.
13:17:38 <ReinH> Because "what does it mean for something to be an arrow" is important when you're trying to understand what an arrow is.
13:17:58 <lamefun> With hGetContents, etc. if I only use a part of the input, will the file get closed anyway?
13:17:59 <ReinH> You're literally asking about what the semantics are and then complaining when we try to describe the semantics accurately.
13:18:22 <hackrilege> i get pretty upset, i try always to state things clearly, i become confused only when things are not explained clearly. if you want to tell someone something, please just tell them that thing, and not information eluding to that thing.
13:18:31 <ReinH> We are telling you the thing.
13:18:41 <bitemyapp> telling ain't doing
13:18:45 <mauke> lamefun: eventually, yes, I think (when the list gets garbage collected)
13:18:45 <ReinH> We are telling you that arrows don't operate on or cast anything. That's the thing we're telling you.
13:18:46 <bitemyapp> they need doing to grok
13:18:53 <bitemyapp> telling ain't gonna grokify.
13:19:10 <mauke> hackrilege: did you mean "alluding"?
13:19:10 <bitemyapp> Need exercises yo. More gab won't help.
13:19:27 <arkeet> or at least some other examples of categories.
13:19:36 <hackrilege> a category is a collection of "objects" and "arrows", which are equivalent to pairs of objects. is this ok? 
13:19:40 <arkeet> no.
13:20:20 <arkeet> there can be many arrows corresponding to a given pair of objects. or none.
13:20:28 <mauke> arkeet: can I model arrows as a SQL table with a synthetic primary key?
13:20:32 <hackrilege> could you provide a better definition please?
13:20:41 <arkeet> I already started on that way above.
13:20:44 <mauke> (id, domain, codomain)
13:20:53 <hackrilege> so that such a frustraiting conversation need not happen again
13:20:56 <arkeet> but, briefly.
13:20:59 <arkeet> a category consists of
13:21:06 <ReinH> https://en.wikipedia.org/wiki/Category_(mathematics)#Definition
13:21:08 <dolio> mauke: Probably not.
13:21:09 <arkeet> - a collection of "objects" and a collection of "arrows"
13:21:20 <dolio> Unless your SQL tables can be uncountably large.
13:21:24 <arkeet> - two mappings from "arrows" to "objects", called "domain" and "codomain"
13:21:30 <mauke> dolio: I'm OK with that
13:21:34 <arkeet> - a mapping from "objects" to "arrows", called "identity arrow"
13:21:35 <mauke> might need a hardware upgrade
13:21:39 <quchen> Trying to give a cohrent explanation without interruptions in a channel of 1500 people is an interesting exercise in typing speed.
13:21:45 <arkeet> - a mapping from pairs of "arrows" to "arrows", called "composition"
13:21:50 <arkeet> - some laws relating these mappings
13:22:20 <hackrilege> a category is a collection of "objects" and "arrows", which are mapped bijectivly to pairs of objects. a Functor is...
13:22:30 <mauke> arkeet: does every object have exactly one identity arrow?
13:22:32 <arkeet> there is no bijection.
13:22:37 <arkeet> mauke: that is implied by "mapping"
13:22:44 <arkeet> ("mapping" means "function")
13:23:02 <hackrilege> mauke: yes!
13:23:06 <arkeet> oh, composition is a partial operation.
13:23:14 <arkeet> I could have defined it differently.
13:23:47 <mauke> hackrilege: ?
13:23:56 <arkeet> on "pairs of arrows, where the domain of the first arrow is the codomain of the second"
13:24:01 <ReinH> Probably better to go through Lawvere's Conceptual Mathematics and do the exercises if you want to learn what a category
13:24:08 <ReinH> is
13:24:34 <ReinH> As bitemyapp says, the knowing is in the doing.
13:24:46 <arkeet> hackrilege: "bijective" comes in nowhere, here.
13:24:55 <arkeet> no one said anything about anything being bijective.
13:25:06 <arkeet> I'll stop.
13:25:29 <ReinH> arkeet: I mean, it's fun to watch you give the same definition of categories 3 times. Like our own little groundhog day.
13:25:46 <quchen> (n+1) time's a charm
13:26:03 <hackrilege> as id1 x = x, id2 x = x, => (1) id1 x = id2 x, (2) id1 x = id1^(-1) x so applying (2) to (1) we get x = id1^(-1) id2 x and then id1=id2
13:26:38 <ReinH> hackrilege: Where does ^(-1) come from?
13:26:41 <mauke> hackrilege: what are you talking about?
13:26:42 <ReinH> No one said anything about invertibility
13:27:05 <hackrilege> proving there is one identity. im tryingint to write inverse ReinH:
13:27:27 <ReinH> hackrilege: There's no ^(-1)
13:27:27 <quchen> for all x, id1(x) = id2(id1(x)) = id2(x)
13:27:30 <hackrilege> i define f^(-1) . f = id
13:27:39 <arkeet> quchen: what does id1(x) mean?
13:27:45 <hackrilege> thanks quchen:
13:27:56 <ReinH> hackrilege: And categories don't have that, so you can't use it.
13:27:57 <latro`a> suppose I have a list xs and a bunch of predicates p1,...,pn, and I want to make a list whose ith entry is the number of members of xs that satisfy pi. can I do this in one traversal?
13:28:13 <monochrom> do you know what does "identity" refer to? It doesn't refer to inverses.
13:28:13 <quchen> "The first identity morphism applied to its object" arkeet
13:28:15 <ReinH> There is nothing in the definition of a category that implies that arrows have such an inverse.
13:28:25 <hackrilege> ReinH: ok, but quchen has got it
13:28:40 <ReinH> hackrilege: has got what?
13:28:58 <monochrom> for all f of the right type, f . id = f.  for all g of the right type, id . g = g
13:29:00 <mauke> a type error
13:29:01 <hackrilege> mauke: ReinH: for all x, id1(x) = id2(id1(x)) = id2(x)
13:29:06 <ReinH> hackrilege: what about it?
13:29:19 * frerich glances over https://en.wikipedia.org/wiki/Category_(mathematics)#Definition and - as somebody who's married to a swedish girl - approves of the category 'Met'
13:29:21 <ReinH> We are aware that identities are unique.
13:29:23 <monochrom> so you do not need inverse. you don't even need parameters.
13:29:33 <hackrilege> a nice proof that there is a unique identity arrow
13:29:47 <mauke> hackrilege: wrong
13:29:56 <hackrilege> ReinH: actually mauke asked for a proof
13:30:01 <quchen> Unique up to isomorphism. But isomorphic things are exactly equal (up to isomorphism).
13:30:01 <ReinH>  hackrilege No, he didn't.
13:30:03 <jle`> for some categories it doesn't make sense to "apply an arrow"
13:30:09 <monochrom> it is easy to design a category in which "inverse" and even "parameter" don't exist
13:30:12 <mauke> hackrilege: no, I didn't
13:30:14 <jle`> it only makes sense to "apply a function"
13:30:21 <hackrilege> WHAT DID HE DO!?
13:30:28 <mauke> hackrilege: scroll up and read
13:30:32 <jle`> but you can't in general "apply an arrow"...it doesn't make sense in some categories
13:30:35 <quchen> Here's a category without that many inverses:     * ----> *
13:30:50 <ReinH> Alright then.
13:31:44 <mauke> ok, now why I think this "proof" is broken: "identity arrow" is supposed to map objects to arrows
13:31:59 <ReinH> mauke: er?
13:32:05 <mauke> let id1, id2 be "identity arrows". then id2(id1(x)) is a type error
13:32:16 <ReinH> arrows map objects to objects...
13:32:43 <mauke> <arkeet> - a mapping from "objects" to "arrows", called "identity arrow"
13:32:50 <ReinH> what
13:33:00 <arkeet> for each object, there is the identity arrow of that object.
13:33:06 <ReinH> Ah.
13:33:15 <ReinH> That's a weird way of thinking of identity arrows, but ok.
13:33:20 <monochrom> ReinH, mauke means that "for each object, there exists an identity arrow. Skolemize. there is a function that maps each object to its identity arrow"
13:33:53 <arkeet> arrows don't map anything.
13:34:03 <arkeet> just as objects don't map anything.
13:34:14 <monochrom> and it is also supported by the notation "id subscript X". subscripting is a popular way to write function application without admitting it
13:34:50 <ReinH> arkeet: sure they do. They're even called morphisms.
13:35:06 <ReinH> monochrom: I understand the definition.
13:35:08 <quchen> Mapping a category to its arrow category does precisely that - map morphisms (in C) to objects (in C→). So that would give you an "identity mapping" in the above sense.
13:35:21 <arkeet> ReinH: morphisms are abstract things.
13:35:31 <ReinH> so are mappings
13:35:41 <arkeet> when I said "mapping" I meant "function"
13:35:43 <ReinH> Anyway, it isn't an essential part of my point.
13:36:26 <ReinH> mauke: id1 and id2 aren't the function from object to arrow. They are the identity arrows themselves. This is made a bit confusing by an unfortunate collision of "identity arrow" to mean both things.
13:36:55 <mauke> what do you mean by "identity arrow" then?
13:37:45 <ReinH> the usual: an arrow a -> a for all a in C such that f . id = f and id . g = id for all arrows f : a -> b, g : c -> a
13:37:49 <ReinH> er, id . g = g
13:38:26 <mauke> sorry, I don't know what . and id are
13:38:28 <ReinH> If "identity arrow" means "a function from object to arrow" then I'm not the one using arrow and function in confusing ways :p
13:38:37 <arkeet> maybe I should have called it "the identity arrow mapping"
13:38:41 <jle`> i think usually category theorists talk about every object as having its own uniquely defined identity arrow
13:38:49 <ReinH> since, as already stated by arkeet, arrows are not functions
13:38:53 <jle`> there might not be a general schema for constructing the "a -> a for all a"
13:39:05 <jle`> for some categories you might have to go through all a's and construct it specifically for that a
13:39:15 <jle`> all that is required is that every a has one unique one
13:39:19 <ReinH> Anyway, an identity arrow is... an identity arrow. The usual one.
13:39:26 <ReinH> It isn't a function from object to arrow.
13:39:28 <mauke> ReinH: I don't know what that is
13:39:33 <monochrom> fortunately, I am not married to a constructivist. :)
13:39:38 <ReinH> mauke: pick a definition of category
13:39:46 <mauke> I'm using what arkeet said above
13:39:48 <ReinH> there are plenty, and they all agree on what an identity arrow.
13:39:51 <arkeet> you could omit the "identity arrow mapping" from the definition of category, and just require the existence of left and right identities for composition.
13:39:54 <ReinH> ... is.
13:39:59 <arkeet> I think that's what ReinH is trying to do maybe.
13:40:06 <mauke> ReinH: apparently not
13:40:07 <arkeet> er, two-sided identities.
13:40:19 <ReinH> what I'm trying to do is point out that "arrows are not functions" and "the identity arrow is a function from object to arrow" is incoherent.
13:40:34 <ReinH> and also not what "identity arrow" is taken to mean in every definition of category ever
13:40:36 <arkeet> but whichever way you do it, you always end up with a function from objects to arrows
13:40:38 <mauke> not really, it just means "identity arrow" is not an "arrow"
13:40:41 <arkeet> that maps an object to the identity arrow on the object.
13:40:48 <ReinH> mauke: yes, that's the incoherent part.
13:41:01 <ReinH> arkeet: You're using "identity arrow" to mean both things.
13:41:04 <ReinH> That's what I'm saying.
13:41:05 <arkeet> and that function is what I (perhaps confusingly) called "identity arrow"
13:41:09 <monochrom> ok, by this point, are you arguing over wording?
13:41:18 <arkeet> maybe I should have called it something else, like "apple"
13:41:21 <arkeet> or "i"
13:41:24 <ReinH> monochrom: Well, it's a rather important bit of wording, don't you think?
13:42:14 <jle`> yeah, it might come at an inconvenient time, because you're trying to define arrow, and using arrow in a way that you're defining it not to be
13:42:59 <monochrom> I would like to say yes. then I recall that most programmers prefer to code like this: "hash_value k = 3984*k `mod` 31337". therefore, hash_value is not a hash value.
13:43:29 <monochrom> and somehow programmers prefer it that way!
13:44:18 <arkeet> nicely put.
13:44:21 <ReinH> If you want to talk about the actual mapping between an object and its identity arrow, it's probably best not to also call that mapping an "identity arrow". I didn't think this would be a controversial statement.
13:44:26 <mauke> length is not a length
13:44:35 <ReinH> But I guess I underestimated #haskell
13:44:39 <arkeet> it's not "an identity arrow"
13:44:42 <arkeet> it's "the identity arrow mapping"
13:44:53 <ReinH> arkeet: You're the one that called it an "identity arrow"
13:44:56 <monochrom> there is a way to set up an analogy between "hash_value :: Key -> HashValue_This_Time_It's_Real" and "identity_arrow :: Object -> IdentityArrow"
13:44:58 <arkeet> I did not say "an"
13:45:05 <ReinH> jesus christ
13:45:13 <haskell936> Hi, I had this type newtype Board = Board (Map.Map Position ChessPiece)
13:45:16 <mauke> makes perfect sense to me
13:45:21 <haskell936> emm let me start over
13:45:21 <arkeet> I believe my wording was precise, but also potentially confusing.
13:45:27 <arkeet> sorry about the latter. and only the latter.
13:45:29 <mauke> "length" is a function. "a length" is a number
13:45:30 <ReinH> This is ridiculous.
13:45:53 <ReinH> arkeet: If you want to be this ridiculously pedantic, I didn't say that you called it "an" identity arrow.
13:46:09 <meditans> guys, I was reading some code and I found: [x : p | x <- [1..n], p <- ps !! (n - x), x <= head p]
13:46:20 <arkeet> ok, let's call it identity_arrow
13:46:25 <meditans> what is the "<=" stuff? I never saw it before!
13:46:26 <arkeet> identity_arrow :: Objects -> Arrows
13:46:35 <mauke> meditans: "less or equal"
13:46:38 <haskell936> it's a filter
13:46:40 <ReinH> Let's not call it an arrow at all, since it isn't an arrow, per *your* definition.
13:46:45 <monochrom> closing remark: I just taught my students about "random variables", which are neither random nor variables... then again, to my credit, I told them that too, it's a bad name
13:46:47 <ReinH> Which I agree with.
13:46:52 <arkeet> it's not an arrow. 
13:46:54 <arkeet> it's a function.
13:46:59 <ReinH> Then don't call it an arrow.
13:47:03 <arkeet> I didn't.
13:47:09 <ReinH> Yes. You did.
13:47:10 <mauke> we're not calling "an arrow", we're calling it "arrow"
13:47:13 <ReinH> This is idiotic and I'm done.
13:47:16 <arkeet> me too.
13:47:30 <haskell936> http://learnyouahaskell.com/starting-out#im-a-list-comprehension
13:47:41 <meditans> mauke: wow, I'm getting dumb! After a day hacking in Agda, I see strange stuff xd
13:47:50 <meditans> mauke, thanks 
13:47:54 <mauke> meditans: :-)
13:48:08 <kadoban> meditans: Haha, it took me a sec too to realize it wasn't syntax XD
13:48:08 <quchen> haskell936: … continue! :-)
13:48:14 <mauke> one thing's certain: <= is not an arrow
13:48:21 <jle`> > 3 <= 5
13:48:23 <lambdabot>  True
13:48:39 <quchen> Can we stop this turned-hostile discussion about what an arrow is? :-|
13:48:42 <meditans> kadoban: I was looking at that arrow in disbelieve, cause I never encountered it in many years xd
13:49:15 <haskell936> Hi, I had this type "type Board = Map.Map Position ChessPiece", but I had to implement a typeclass on it, so I changed it to "newtype Board = Board (Map.Map Position ChessPiece)". The problem is that I was using Board as a map everywhere, so how do I actually make the change transparent?
13:49:45 <mauke> quchen: too late. we already did
13:50:03 <mauke> haskell936: you can't
13:50:35 <jle`> haskell936: yeah, unfortunately, there isn't really a way.  that's actually one of the purposes of a newtype in the first place...so you can't use one as the other
13:50:47 <meditans> haskell936: the purpose of the newtype is exactly to insulate yourself from considering those two types equal
13:50:47 <monochrom> quchen: :)
13:50:56 <jle`> luckily the compiler will help point out every place that you have to switch
13:50:58 <jle`> :)
13:50:59 <ReinH> quchen: too slow *moves hand away quickly*
13:51:22 <YellowOnion> :t Repa.sumAllS
13:51:23 <lambdabot> Not in scope: ‘Repa.sumAllS’
13:51:48 <YellowOnion> Anyone familiar with Repa?
13:51:55 <haskell936> okay, well, I don't really care if it's a newtype or something else, as long as my typeclass can be implemented on it
13:52:56 <arkeet> haskell936: why can't you just make Board an instance of the class?
13:53:12 <arkeet> (you'll have to either expand out the type synonym yourself, or use TypeSynonymInstances"
13:53:15 <arkeet> )
13:54:42 <juanpaucar> is there a better way to do this? a more idiomatic way?
13:54:44 <juanpaucar> http://lpaste.net/137554
13:55:10 <bigs> Gurkenglas: thanks for the writeup -- enjoyed
13:55:18 <haskell936> arkeet: it doesn't work I have "Illegal instance declaration for ‘Serialize Board'’
13:55:22 <arkeet> juanpaucar: lines 4-6 can be replaced with: return $ fmap pandoc doc
13:55:48 <arkeet> actually
13:55:54 <arkeet> if you really wanted:
13:56:05 <mauke> fmap (fmap pandoc) (filePathToPandocData filePath)
13:56:08 <arkeet> filePathToPandoc filePath = fmap (fmap pandoc) (filePathToPandocData filePath)
13:56:22 <arkeet> but now it's starting to get obscure.
13:56:24 <mauke> (fmap . fmap) pandoc (filePathToPandocData filePath)
13:56:31 <mauke> inb4 lens
13:56:32 <jle`> filePathToPandoc filePath = fmap pandoc <$> filePathToPandocData filePath    -- ?
13:56:37 <arkeet> fmap (fmap pandoc) . filePathToPandocData
13:56:41 <arkeet> jle`: better.
13:56:43 <jle`> or you can use right, to make it less confusing
13:56:45 <arkeet> or worse.
13:56:56 <jle`> filePathToPandoc filePath = right pandoc <$> filePathToPandocData filePath
13:57:04 <arkeet> mauke: I don't see the value in rewriting f (g x) as (f . g) x if you aren't going to lose the point.
13:57:11 <juanpaucar> thanks to all... i knew it XD i just totally forgot about the functor instance for Either
13:57:35 <arkeet> except I do.
13:57:37 <arkeet> so never mind.
13:57:38 <jle`> maybe using right instead of fmap here is clearer in the sense of using map instead of fmap, (.) instead of fmap, etc.
13:57:44 <mauke> arkeet: the next step is fmap fmap fmap pandoc <$> filePathToPandocData
13:57:52 <arkeet> :-)
13:58:20 <latro`a> http://lpaste.net/137555
13:58:23 <juanpaucar> thanks (Y)
13:58:28 <latro`a> ^how might I generalize this to more than four options?
13:58:35 <latro`a> (short of simply using a larger tuple)
13:58:36 <arkeet> don't use a tuple.
13:58:51 <monochrom> arkeet: I like (f . g) because it is easier to edit to (f . h . g) for example. I think you thought of that, too
13:58:59 <arkeet> monochrom: no, I just like (fmap . fmap)
13:59:03 <latro`a> arkeet: I agree, but what to do instead in this case?
13:59:23 <monochrom> I am scared of (fmap . fmap)
13:59:28 <mauke> latro`a: Data.Map?
13:59:32 <mauke> I mean, this is a histogram, right?
13:59:58 <mhall> is Control.Concurrent.SampleVar not part of base anymore?
14:00:02 <mhall> (if it ever was?)
14:00:10 <arkeet> monochrom: it was more scary before lens.
14:00:10 <latro`a> mauke: so you mean still traversing the list recursively and updating like this
14:00:28 <latro`a> mauke: the explicit recursive traversal was the other thing I wanted to be rid of
14:00:41 <mauke> latro`a: that's just a fold
14:01:12 <latro`a> so it is
14:01:16 <latro`a> thanks
14:01:36 <edwardk> mhall: was it ever in?
14:01:37 <mauke> foldl (\z x -> z `incrementAt` x) empty
14:01:56 <Gurkenglas> latro`a, I think you forgot go's recursive call there?
14:02:04 <edwardk> guess so https://hackage.haskell.org/package/base-4.2.0.1/docs/Control-Concurrent-SampleVar.html
14:02:06 <shachaf> monochrom: Are you scare of fmap (fmap (+1)) [Just 1, Just 2]?
14:02:19 <shachaf> (fmap . fmap) (+1) is very close to fmap (fmap (+1))
14:02:52 <edwardk> mhall: http://markmail.org/message/enmnn5345djelkqb <- seems to indicate that it was just flat broken
14:02:59 <latro`a> Gurkenglas: I did, yes
14:03:11 <edwardk> mhall: so that appears to be what killed it
14:03:53 <edwardk> mhall: https://mail.haskell.org/pipermail/libraries/2012-June/017886.html
14:04:39 <mhall> ty edk :)
14:04:47 <edk> you mised
14:04:50 <edk> also missed
14:04:56 <Fylwind> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#mapM_ so it claims that mapM_ is just traverse_ with a specialized signature, but the source code doesn't seem to agree with that
14:05:53 <arkeet> Fylwind: they are the same, assuming (>>) and return are the same as (*>) and pure.
14:06:30 <arkeet> which ought to be true.
14:07:34 <Fylwind> I feel that the docs are claiming that the implementation of mapM_ defers to traverse_, which is an even stronger statement
14:08:04 <Fylwind> *shrugs* maybe I'm reading too much into it
14:09:12 <athan> Fylwind: Usually there are corellations like that, but the implementations are optimized
14:09:15 <athan> @src mapM_
14:09:16 <lambdabot> mapM_ f as = sequence_ (map f as)
14:09:19 <athan> @src traverse_
14:09:20 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:09:22 <athan> erm
14:09:33 <athan> @src Data.Traversable.traverse_
14:09:33 <lambdabot> Source not found. Whoa.
14:09:59 <monochrom>  @src doesn't give you real actually-used source anyway
14:10:03 <indiagreen> traverse_ f = foldr ((*>) . f) (pure ())
14:10:09 <athan> monochrom: Oh crud, sorry
14:10:33 <monochrom> it gives you someone's handwritten, for-pedagogy code
14:10:50 <Cale> ... mostly :)
14:10:53 <athan> :x
14:11:09 <glguy> Artisan source
14:11:09 <Cale> It's a bit spotty, sometimes you randomly get a GHC definition
14:12:27 <ReinH> free trade src
14:14:14 <arkeet> now it's just outdated.
14:14:29 <arkeet> since AMP
14:14:59 <arkeet> er, the other thing.
14:15:05 <arkeet> :t mapM_
14:15:06 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
14:15:30 <arkeet> :t \ f as -> sequence_ (map f as)
14:15:31 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m ()
14:21:11 <minad> hi
14:21:31 <liscju> anybody with experience with Parsec can take a look at https://gist.github.com/liscju/655c33c5913dfd0657d6 and tell me why "optionMaybe (hexPrefix <|> octalPrefix)" when hexPrefix fails dont try octalPrefix?
14:22:20 <mauke> because hexPrefix consumes the '#'
14:22:38 <mauke> in a <|> b, if a consumes any input, b is not tried
14:23:03 <lpaste_> Gurkenglas annotated “counting” with “latro`a, here's one for any list of conditions and one that only checks for equality.” at http://lpaste.net/137555#a137556
14:23:12 * hackagebot simpleirc 0.3.1 - Simple IRC Library  https://hackage.haskell.org/package/simpleirc-0.3.1 (DominikPicheta)
14:23:56 <minad> can someone explain how existentially quantified types are equivalent to type generativity? Maybe this is a bit out of scope of Haskell, but I think I "understand" existentially quantified types in Haskell, but not type generativity (as for example in ML functors)
14:25:18 <bitemyapp> minad: existentially quantified types don't unify with each other even if they share a representation, only from within the interface.
14:25:23 <lpaste_> Gurkenglas revised “latro`a, here's one for any list of conditions and one that only checks for equality.”: “No title” at http://lpaste.net/137556
14:25:46 <bitemyapp> minad: whereas    (id 1) + (id 1)   unifies just fine because id is universally quantified.
14:27:30 <Gurkenglas> (Let me just express my amazement when an opportunity to use "flip snd" presented itself. Woo.)
14:28:05 <kuribas> :t flip snd
14:28:06 <lambdabot> b -> (a, b -> c) -> c
14:28:09 <jle`> haha
14:28:51 <liscju> @mauke what should i do to only consume '#" and 'h' if its all on input,or otherwise return it to input?
14:28:51 <lambdabot> Unknown command, try @list
14:29:09 <liscju> mauke what should i do to only consume '#" and 'h' if its all on input,or otherwise return it to input?
14:29:42 <kuribas> :t flip head
14:29:43 <lambdabot> b -> [b -> c] -> c
14:29:44 <Zemyla> :t flip uncurry
14:29:45 <lambdabot> (a, b) -> (a -> b -> c) -> c
14:29:59 <minad> bitemyapp: so you basically say that the representation is hidden for the existentially quantified types?
14:31:39 <glguy> You can either factor matching the '#' out of the two parsers or use 'try hexPrefix <|> octalPrefix' and leave it duplicated
14:31:50 <mauke> liscju: try (char '#' >> char 'h')
14:32:49 <liscju> thank you guys
14:32:52 <liscju> :P
14:32:57 <bitemyapp> minad: hiding is somewhat orthogonal to what's going on here unless you want to play the "who knows what" game for forall /exists
14:33:43 <bitemyapp> exists a . a   ~ "I pick a, you don't get to know what it is and so cannot assume any given a will equal the a you're thinking of"
14:34:13 <bitemyapp> forall a . a        ~ "You pick a, I don't know what it is so I can't use information specific to a particular a but you can recover information about the original 'a'"
14:35:19 <johnw> bitemyapp: those statements are from the callee's point of view
14:35:53 <Zemyla> minad: Haskell doesn't quite have exists, but forall used in a negative argument is equivalent to exists.
14:36:40 <Zemyla> Like how runST's type is forall a. (forall s. ST s a) -> a.
14:36:49 <minad> Zemyla: yes, I've seen that
14:37:12 <Gurkenglas> lpaste should make "Hlint couldn't typecheck your code" and "Hlint finds everything peachy" distingiushable.
14:37:23 <Zemyla> Have you seen Coyoneda?
14:38:00 <quchen> Gurkenglas: HLint doesn't typecheck your code I think.
14:38:05 <Zemyla> data Coyoneda f a = forall r. Coyoneda (r -> a) (f r).
14:38:17 <quchen> Gurkenglas: But I agree that some of its suggestions are very debatable. η reduction, for example.
14:38:17 <minad> no
14:39:02 <Zemyla> Basically, like say you pattern-match on a value of Coyoneda [] Int.
14:39:22 <kuribas> quchen: and flip
14:39:59 <Gurkenglas> When is eta reduction bad?
14:40:06 <kuribas> I mean (flip f x) == (`f` x)
14:40:35 <quchen> Gurkenglas: When it takes away a name that you need
14:40:53 <Zemyla> When you have Coyoneda fn ls, ls is a list of some type you don't know. You can pattern-match on the list, you can calculate its length, you can find its head or tail or replicate it, but you can't do anything with the elements, because they're of an unknown type r.
14:41:15 <Zemyla> You can't do amything with the elements, that is, except apply fn to them.
14:41:16 <arkeet> what was that thing edwardk said about hlint
14:41:45 <arkeet> that's the one http://www.reddit.com/r/haskell/comments/33n76x/why_is_vs_datamonoidmappend_v_better_than_vs_v/cqnb4ei
14:42:16 <arkeet> "My usual way to use HLint is to treat it like a drunken undergraduate doing a code review for me."
14:42:17 <minad> Zeymla: What is the type of fn then?
14:42:56 <Zemyla> ls is of type [r], and fn is of type r -> a.
14:43:55 <Zemyla> You know what a is, but not r.
14:43:59 <arkeet> the thing is that you can't know what r actually is.
14:44:10 <arkeet> only that it's the same in both the [r] and r -> a
14:44:37 <arkeet> so the only thing you can do with an r is apply the r -> a to it.
14:44:44 <minad> yes, but if I use fn and fn has the type r->a, I know r?
14:45:04 <arkeet> no.
14:45:07 <ReinH> r must be polymorphic
14:45:14 <minad> ok that's what I was asking
14:45:21 <Zemyla> The only thing you can use fn om are things from the list.
14:46:13 <arkeet> Coyoneda of something that's already a Functor doesn't really get you anything new. it just has some different performance characteristics.
14:46:45 <Zemyla> arkeet: Yeah, but it works as an example.
14:46:49 <Stratege> what's the purpose of Coyoneda?
14:47:17 <arkeet> there are a couple uses.
14:47:31 <arkeet> one is for performance as I said. (in some cases.)
14:47:42 <arkeet> the other is that it lets you turn *anything* (of kind * -> *) into a Functor.
14:49:23 <Stratege> huh. That's cool.
14:49:36 <Zemyla> Or even some things that aren't.
14:49:38 <ReinH> arkeet: Isn't Yoneda more commonly used for that since Coyoneda is contravariant?
14:49:54 <arkeet> ReinH: Coyoneda isn't contravariant.
14:50:04 <Zemyla> ReinH: Coyoneda is covariant. Look where the a is.
14:50:04 <ReinH> https://hackage.haskell.org/package/kan-extensions-4.2.2/docs/Data-Functor-Contravariant-Coyoneda.html
14:50:06 <arkeet> actually, there are covariant and contravariant versions of both.
14:50:14 <arkeet> er
14:50:25 <edwardk> ReinH: you're looking at Contravariant.Coyoneda, there is also just Coyoneda
14:50:35 <ReinH> Ah right.
14:50:43 * edwardk had to collect them all
14:50:47 <Zemyla> But yeah, you could have data ByteStringF a = BSF (Char -> a) ByteString.
14:50:48 <ReinH> Yep.
14:51:10 <Zemyla> And it's a Functor and a Foldable.
14:51:31 <arkeet> I guess the usefulness of turning anything into a functor, abstractly, is
14:51:38 <Zemyla> Don't know if it's Traversable, though.
14:52:22 <ReinH> Zemyla: Coyoneda f is Foldable and Traversable iff f is
14:52:25 <edwardk> Zemyla: its not traversable
14:52:34 <edwardk> not in the way you'd expect
14:52:40 <arkeet> uh
14:53:07 <arkeet> basically it's the "free Functor"
14:53:52 <arkeet> so say I have F, G :: * -> *
14:53:58 <Zemyla> Well, it is Foldable, though.
14:54:00 <arkeet> where F is anything you like, but G is a functor.
14:54:23 <arkeet> and some polymorphic n :: forall x. F x -> G x
14:54:44 <arkeet> then Coyoneda F is 
14:54:46 <arkeet> 1. an honest functor
14:55:03 <arkeet> 2. any such n gives me a natural transformation Coyoneda F x -> G x
14:55:34 <ReinH> Isn't n natural as well?
14:55:43 <arkeet> F isn't a functor, so that doesn't make sense.
14:56:17 <arkeet> I guess the point is that 
14:56:50 <arkeet> if I have f :: A -> B, and a :: F A
14:57:20 <arkeet> then <commutative square>
14:57:34 <Zemyla> arkeet: Take F = Endo, G = Identity, and n = Identity . fix . appEndo.
14:57:53 <arkeet> in place of fmap f (n a), I can lift the a to Coyoneda, and fmap it there before pushing it through n.
14:58:02 <Zemyla> That is a natural transformation.
14:58:12 <arkeet> Zemyla: F isn't a functor.
14:58:26 <arkeet> natural transformations go between functors.
14:58:36 <Zemyla> No, but there is a natural transformation.
14:58:46 <arkeet> there is one, perhaps, but n isn't one.
14:59:02 <Zemyla> Why not? It's type-agnostic.
14:59:09 <arkeet> because Endo isn't a functor.
14:59:11 <Fylwind> does anyone know why 'coerce' is needed to define 'folding :: Foldable f => (s -> f a) -> Fold s a' ? (I mean besides the obvious fact that it doesn't typecheck without it, I can't help but wonder if there's a deeper reason)
14:59:29 <arkeet> n is just a polymorphic function, forall x. Endo x -> Identity x
14:59:41 <ReinH> arkeet: Right, and parametricity is stronger than naturality
14:59:41 <arkeet> natural transformations by definition map between functors.
14:59:53 <ryantrinkle> does anyone have advice on how to figure out which foreign calls a haskell capability is blocking on?
15:01:45 <minad> thank you all for the explanations concerning existential types. I couldn't follow all of it though :)
15:02:38 <ReinH> arkeet: I didn't say that F was the functor :p
15:03:40 <arkeet> Fylwind: it's just to make it typecheck, I'd say. :p
15:03:51 <Fylwind> -.-
15:03:59 <arkeet> let me rename f
15:04:06 <naudiz> what was the language extension called where you could define a class that depends on two types?
15:04:11 <arkeet> folding :: Foldable t => (s -> t a) -> Fold s a
15:04:31 <Intolerable> MultiParamTypeClasses?
15:04:59 <arkeet> Fold s a = forall f. blah => (a -> f a) -> (s -> f s), where blah implies that f's type parameter is a phantom.
15:05:23 <arkeet> if we didn't use coerce, then the best you could do from (s -> t a) is (a -> f a) -> (s -> f (t a))
15:06:04 <naudiz> Intolerable: isn't that the one where one type is dependend on the other one?
15:07:20 <arkeet> Fylwind: what it's supposed to "look like" is (a -> m) -> (s -> m)
15:07:25 <arkeet> for any Monoid m
15:07:28 <arkeet> :t foldMap
15:07:30 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:07:56 <Gurkenglas> How should be determined into which module an instance definition should be put? Beyond orphan concerns.
15:08:00 <Fylwind> arkeet: so I found my first source of confusion: Control.Lens.Interal.Getter.coerce != Data.Coercible.coerce
15:08:09 <arkeet> the (Contravariant f, Applicative f) constraint just means that f is isomorphic to Const m for some monoid m.
15:08:14 <arkeet> ah yes, that's important. :p
15:08:24 <edwardk> fylwind: we're slowly eliminating that combinator. Data.Coercible.coerce came along later
15:08:39 <Fylwind> edwardk: what will become of it?
15:08:59 <Fylwind> arkeet: I'm trying to parse what you're saying but not too familiar with contravariant functors
15:09:00 <edwardk> Fylwind: it moved upstream: http://hackage.haskell.org/package/contravariant-1.3.1.1/docs/Data-Functor-Contravariant.html#v:phantom and became 'phantom'
15:09:12 <arkeet> Fylwind: it's not terribly important what Contravariant means here.
15:09:13 <edwardk> moving it upstream and keeping the name wouldn't have helped
15:09:15 <Fylwind> edwardk: ah
15:09:24 <sbrg> https://gist.github.com/091e3d5f8a8bd7b797ee what exactly is the problem here? I'm not quite following.
15:10:11 <edwardk> Fylwind: (Contravariant f, Functor f) means that you can't use the argument at all.. not and pass both the laws for Contravariant and for Functor.
15:10:17 <Fylwind> arkeet: but I want to understand _why_ it's phantom (or equivalently why it's isomorphic to Const m)
15:10:34 <naudiz> say, I have an amount of types A, B, C, ... Now I want to switch between them in runtime (depending on the users input), so now I need a way to specify what types can be converted to each other. Kind of like the type pottern in C++
15:10:38 <arkeet> well, because coerce/phantom exists.
15:10:42 <edwardk> :t contramap (const ()) . fmap (const ())
15:10:44 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
15:10:44 <Fylwind> oh right
15:10:46 <arkeet> f a ~ f () for all a
15:10:50 <Fylwind> Functor => Applicative
15:10:55 <arkeet> so f ~ Const (f ())
15:10:59 <arkeet> (where ~ just means isomorphism)
15:11:14 <arkeet> and Const r is Applicative iff r is a monoid.
15:11:19 <edwardk> so knowing f is both Functor and Contravariant means f a ~ x  for some x.
15:11:24 <edwardk> that is independent of a
15:12:10 <glguy> phantom x 07= () 07<$ x 07$< ()
15:12:12 <edwardk> upgrading that to (Contravariant f, Applicative f)  you have mempty = pure (whatever you want to pass, it can't use the argument)
15:12:14 <glguy> You didn't use the new operator :)
15:12:25 <naudiz> now my idea was to have a class Convert a b where conv :: a -> b that says which types can be converted
15:12:32 <edwardk> and mappend = (*>)
15:12:44 <Welkin> colors!
15:12:50 <edwardk> naudiz: that infers terribly
15:13:12 <edwardk> -- does "conv . conv" do? that intermediate type is unknown
15:13:15 <edwardk> er what does
15:14:11 <Zemyla> Oh, edwardk, there are two things that should be addressed with Control
15:14:11 <naudiz> edwardk: I haven't exactly thought this to the end :/
15:14:22 <Zemyla> *Control.Monad.Free.Church.
15:14:34 <edwardk> Zemyla: ?
15:15:06 <Zemyla> 1) The Foldable instance should probably define foldMap, as it's more efficient than doing it with foldr.
15:15:08 <naudiz> edwardk: what I want in the end is something like convOnInput :: a -> Text -> b
15:15:22 <edwardk> Zemyla: patch away
15:15:42 <Zemyla> My computer I can patch with died.
15:16:08 <monochrom> oh! so GHC 7.10.2 is out
15:16:12 * arkeet wishes Foldable had (m -> m -> m) -> m -> (a -> m) -> t a -> m or something.
15:16:24 <edwardk> :t foldMapByOf
15:16:25 <lambdabot> (forall s. Getting (Control.Lens.Internal.Fold.M r s) t a) -> (r -> r -> r) -> r -> (a -> r) -> t -> r
15:16:31 <edwardk> :t foldMapBy
15:16:32 <lambdabot> Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
15:16:40 <edwardk> you're welcome
15:16:42 <arkeet> I mean without using reflection.
15:16:51 <Zemyla> And 2) There's a fairly simple way of doing cutoff for F without having to convert it to and from the tree form.
15:17:09 <edwardk> Zemyla: patch patch patch or at the very least write up how to do it and submit an issue
15:17:37 <Zemyla> Okay. Where do I submit?
15:17:38 <edwardk> a lot of this stuff gets put in in placeholder form until someone puts eyeballs on the problem
15:17:44 <edwardk> github.com/ekmett/free/issues
15:17:57 <Fylwind> > :t contramap (const ()) . fmap (const ())  <-- this helped a lot, thanks edwardk and arkeet!
15:17:59 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:18:03 <naudiz> or is there a way to do this with a single function? Is "conv :: forall a. forall b. (Class a, Class b) => a -> Text -> b" a valid type that makes sense?
15:18:11 <edwardk> :t fmap absurd . contramap absurd
15:18:12 <lambdabot> Not in scope: ‘absurd’
15:18:12 <lambdabot> Not in scope: ‘absurd’
15:18:19 <edwardk> @let import Data.Void
15:18:21 <lambdabot>  Defined.
15:18:23 <edwardk> :t fmap absurd . contramap absurd
15:18:24 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
15:18:25 <arkeet> naudiz: hm? what's the Text for?
15:18:30 <edwardk> Fylwind: ^- the other way to define it
15:18:53 <Fylwind> :t absurd
15:18:54 <lambdabot> Void -> a
15:18:56 <edwardk> but the const () one is better because it can use (<$) on Functor
15:19:07 <naudiz> arkeet: I want to convert types that implement different program behaviour on user input
15:19:19 <Fylwind> edwardk: I see
15:19:19 <edwardk> so it may be a bit more defined
15:19:33 <edwardk> (probably not though)
15:22:30 <Fylwind> arkeet: foldl3 f z g = foldl' (\ x y -> f x (g y)) z ?
15:22:58 <arkeet> :t \f z g = foldl' (\ x y -> f x (g y)) z
15:22:59 <sbrg> https://gist.github.com/saevarb/091e3d5f8a8bd7b797ee anyone have an idea what is going wrong here? "Illegal polymorphic or qualified type"
15:23:00 <lambdabot> parse error on input ‘=’
15:23:06 <arkeet> :t \f z g -> foldl' (\ x y -> f x (g y)) z
15:23:07 <lambdabot> Foldable t => (b -> r -> b) -> b -> (a -> r) -> t a -> b
15:23:14 * hackagebot contravariant 1.3.2 - Contravariant functors  https://hackage.haskell.org/package/contravariant-1.3.2 (EricMertens)
15:23:20 <arkeet> Fylwind: no, I meant something like foldMap, but without the Monoid constraint.
15:23:25 <arkeet> where you pass in the monoid operations yourself.
15:23:41 <arkeet> it exists, but needs reflection.
15:23:52 <arkeet> because it isn't in the class.
15:24:29 <ReinH> arkeet: Hmm... how does that differ from just foldr?
15:24:58 <ReinH> since foldr takes exactly the monoid operations
15:25:04 <arkeet> foldr associates to the right.
15:25:11 <Stratege> sbrg your Writer uses m without having it be explicitly mentioned as a type parameter. To allow that you need RankNTypes.
15:25:20 <ReinH> arkeet: Ah, I missed the part where you want a left fold. Sorry.
15:25:28 <arkeet> no, I don't want a left fold either.
15:25:36 <ReinH> Oh. See, I missed it. :)
15:25:40 <arkeet> I want foldMap.
15:26:00 <arkeet> :t foldMapBy
15:26:01 <lambdabot> Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
15:26:28 <arkeet> I can't remember why I wanted it last.
15:26:31 <hasket> Anybody have a second to talk to me about designing large systems with haskell? Just a couple quick questions!
15:26:31 <ReinH> Right, but it's a monoid, so you can just pick a direction since they're equivalent because associativity?
15:26:37 <hasket> You can PM me
15:26:59 <kadoban> hasket: Why not talk in public? More fun and useful for other people.
15:27:03 <ReinH> something something list homomorphism
15:27:55 <arkeet> ReinH: but performance can be asymptotically worse.
15:27:59 <sbrg> Stratege: hmm
15:28:02 <ReinH> arkeet: Ah!
15:28:06 <ReinH> arkeet: full ack.
15:28:08 <sbrg> i guess I just don't grok rankntypes
15:28:35 <YellowOnion> Is there a better way to do > foldr (<=<) return (replicate n MonadicFunc)
15:28:50 <arkeet> :t \n -> foldr (<=<) return . replicate n
15:28:51 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
15:29:08 <arkeet> :t iterateM
15:29:09 <lambdabot>     Not in scope: ‘iterateM’
15:29:09 <lambdabot>     Perhaps you meant one of these:
15:29:09 <lambdabot>       ‘iterate’ (imported from Data.List),
15:29:10 <Stratege> sbrg yeah can't say I exactly do either, best I can tell you is that you need explicit foralls when you want to use type variables without making them part of your type. And that requires rankntypes to my knowledge.
15:29:15 <hasket> kadoban: Will do, I just don't want to disturb anything interesting. I'm basically trying to create a backend. I've made a ton of small programs in haskell, but nothing substantial. So, what's the general advice? Design types first, then move on to implementation? Also, I've created a Model.hs for a few ways of interacting with the database, but I'm not sure what the return types of some of these functions should be. I'm using spock
15:29:15 <hasket>  for serving, but I'm not sure if making the database have types with spock would be too tightly coupling my code. Phew, that's most of my questioning out of the way
15:29:19 <arkeet> I thought that existed.
15:30:01 <kadoban> hasket: Sounds like an interesting topic. I probably don't have much advice for you, but others probably will.
15:30:21 <YellowOnion> arkeet, is replicateM kinda what you're for?
15:30:30 <arkeet> YellowOnion: nope
15:30:55 <hasket> Like loginUser :: T.Text -> T.Text -> SqlPersistM (Maybe UserId) is from the spock example, but that seems to be coupling sql with any other part of the program that wants to interact
15:31:27 <naudiz> that doesn't work... seems I can throw my program away again
15:31:52 <xandaros> Is there some easy way to download/generate haddock for a library and all its dependencies? I often work offline, could be quite useful
15:32:11 <hasket> xandaros: go to $HOME/.cabal/config
15:32:20 <hasket> xandaros: documentation: True
15:32:40 <hasket> All the documentation will be there when you download any library
15:32:47 <hasket> Also, I recommend Dash if you use OSX
15:33:02 <YellowOnion> arkeet, I would have thought this was a common enough pattern for various things, that there was a function to do this.
15:33:03 <xandaros> Ah, awesome. What happens if I use a sandbox? (I'm on Linux :P)
15:33:11 <arkeet> YellowOnion: well, foldM exists.
15:33:12 <hasket> yeah, it'll still download the docs
15:33:19 <hasket> It'll put them in the sandbox folder
15:33:36 <arkeet> :t \n f z -> foldM (\a _ -> f a) z (replicate n ())
15:33:37 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
15:33:42 <hasket> highly recommended to change a few things in the cabal config file
15:33:47 <sbrg> Stratege: I see. https://gist.github.com/f9837fc27cc057ae072d if you don't mind taking another look, I have added an explanation and a copule of extra types to explain what I'm trying to accomplish.
15:33:50 <hasket> Like library-profiling: true
15:33:52 <xandaros> Yeah, I'll have a look at it
15:33:53 <arkeet> :t \n f z -> foldM (\a _ -> f a) z [1..n]
15:33:54 <lambdabot> (Enum a, Monad m, Num a) => a -> (b -> m b) -> b -> m b
15:33:56 <Stratege> hasket can't you design your program to be mostly independent functions and then have some other functions that take care of combining them to create your larger functionality, recursively doing that until you have your final program? (that would still mean anything that needs the UserId has to go through loginUser ... but how much does have to do that?)
15:34:05 <arkeet> :t \n f z -> foldM (\a _ -> f a) z [1..n::Int]
15:34:06 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
15:34:09 <YellowOnion> I can never figure out how to use anything in ghci without it complaining about abiguous types
15:34:36 <naudiz> isn't there any way to implement something like the state pattern in Haskell?
15:34:39 <xandaros> YellowOnion: That's why you have type annotations :P
15:34:41 <hasket> Stratege: Yes, yes I can. It's just hard having never done it before and some of the types are quite weird
15:34:48 <arkeet> what's the state pattern?
15:35:56 <YellowOnion> xandaros, Still can't get anything working :(
15:35:59 <Denommus> naudiz: isn't the state pattern just a poor man's sum type?
15:36:01 <naudiz> arkeet: different types define different behaviour and you switch between those in runtime. a common pattern in C++
15:36:17 <Fylwind> Denommus: it looks like just that based on my cursory reading atm
15:36:39 <naudiz> Denommus: what do you mean?
15:36:43 <Fylwind> basically a means of dynamic dispatch
15:36:58 <jmcarthur_> hasket: I like to find a good model for what I am trying to do, then design an interface for that model, then implement it such that it satisfies the model. If the implementation involves some other interface I need to implement, I do the same thing at that lower level. I wouldn't quite call the approach top-down or bottom-up, exactly; it's sort of a bottom-up approach with a very clear view of what the top
15:37:00 <jmcarthur_> is.
15:37:03 <nuttycom> naudiz: usually in Haskell you just pass a function, using some other information to choose the function you pass.
15:37:18 <jmcarthur_> hasket: This is all ideals, though. In practice, sometimes I end up just prototyping a few times until I'm happy with it.
15:37:44 <Denommus> naudiz: like data Foo = Bar of Int | Baz of String
15:37:57 <Denommus> naudiz: ignore the "of", this is OCamlism
15:37:59 <naudiz> nuttycom: in this case I want a whole set of functions
15:38:06 <Luke> where's the haskell.org website code managed now?
15:38:10 <Luke> i can't seem to find there repo
15:38:23 <Denommus> naudiz: if you create a function that takes a Foo as parameter, you have to match against both Bar and Baz
15:38:24 <nuttycom> naudiz: then use a data constructor
15:38:27 <Hijiri> naudiz: you can pass a data structure with a bunch of functions
15:38:30 <naudiz> Denommus: you can't easily expand this
15:38:32 <Stratege> sbrg basically the easiest way to get your thing to work is to change your writer definition to: "type Writer m = MonadIO m => Message -> IrcT m ()" at which point you can drop the "MonadIO m" part since it's going to get inferred automatically when used in that context (and has to be specified anyway when usd in that context, afaik)
15:38:37 <hasket> jmcarthur_: Cool, that makes sense. I'll update when it's further along
15:39:12 <nuttycom> data MyFns = MyFns { f1 :: Some -> Other, f2 :: Bar -> Baz } 
15:39:14 <nuttycom> etc
15:39:14 <Denommus> naudiz: ah, you want open extension?
15:39:25 <Denommus> naudiz: you could do that with type families
15:39:28 <naudiz> Denommus: yes
15:39:44 <naudiz> nuttycom: that seems to be a good idea, thanks
15:40:23 <naudiz> Denommus: how would you do that? I'm failing at switching on runtime
15:40:38 <sbrg> Stratege: ah. Well, I found another workaround which is acceptable -- type Writer = Message -> IO (). Doesn't really matter all that much
15:40:57 <arkeet> naudiz: pass the data needed to decide to wherever you do the switching.
15:41:50 <Denommus> naudiz: you don't "switch", whenever you need the behavior you apply the value to a function
15:41:58 <Stratege> sbrg particular reason you killed the IrcT part of it?
15:42:01 <Denommus> naudiz: a type families defines something similar to what you want
15:42:33 <Fylwind> why not just define a simple data type that encapsulates the behavior? data Behavior = Behavior { doThis :: IO (); doThat :: IO (); … }
15:42:34 <Stratege> sbrg also note, my suggestion would preserve the full functionality of what I think you had in mind instead of being limited to IO :)
15:43:26 <sbrg> Stratege: If I add m as a type parameter, then I'll surely need to add it to Environment as well, no? data Environment m = Evironment { ..; writer :: Writer m; ..; } or some such?
15:43:32 <naudiz> Denommus: the switching depends on user input and the current type, that's my problem. but I guess I'll just stick to the suggestion from nuttycom
15:43:58 <naudiz> didn't even think about functions being type variables
15:44:09 <arkeet> you can't pick types of things at runtime.
15:44:10 <arkeet> but you can pick values.
15:44:14 <arkeet> values go a long way.
15:44:49 <Denommus> naudiz: is your system interactive like a GUI, or is it a batch system?
15:44:53 <naudiz> so my ansatz can't work. nice to gnow
15:45:06 <naudiz> Denommus: it's a prompt
15:45:08 <Stratege> sbrg yeah, if you want Environment to not be forced to specialize (or start mucking with foralls)
15:45:13 <Denommus> naudiz: a batch system, then
15:45:25 <Denommus> naudiz: honestly, I don't think you should program in Haskell trying to use the same idioms as a OO language
15:45:57 <Denommus> naudiz: so, if you have a different behavior depending on the user input, a sum type seems the right choice. I don't see why overcomplicating it with other things
15:46:15 <naudiz> Denommus: in this case I think it's a good abstraction... if you aren't as stupid as I am, that is :D
15:46:31 <Denommus> naudiz: if you really, really, REALLY need to know all the functions associated with your sumtype, create a separate module and put your sumtype and its associated functions there
15:46:44 <davean> naudiz: I think you think its a good abstraction because its the abstraction you expect
15:47:23 <Denommus> naudiz: you don't need to be smart, the compiler will enforce you'll do the right thing (actually, it won't, because Haskell isn't as sound as it could be there. But at least it will give you a warning that you're not matching everything)
15:47:33 <sbrg> Stratege: aye, I'd rather not do that. I suspect it will lead to all sorts of other stuff. In this scenario, having access to the state provided by the IrcT monad isn't even necessary. The only thing the writer does is write to a server-specific input queue which is then handled by a server-specific thread that sends it on. There should never be any need for the state
15:47:49 <naudiz> Denommus: my idea now was to have a type with a lot of functions and specify concrete values of that type with the sets of functions necessary for a certain behaviour
15:49:11 <Denommus> naudiz: that's a sum type
15:49:26 <Denommus> naudiz: actually, sum types are even more powerful than that
15:49:42 <naudiz> Denommus: isn't a sum type something like type S = A | B | ...?
15:49:49 <Denommus> naudiz: yes
15:50:03 <naudiz> Denommus: then it's not a sum type
15:50:09 <Denommus> naudiz: imagine each variant as your concrete value in question
15:50:28 <Denommus> naudiz: then, when you match against your value, you get a whole independent behavior
15:51:00 <Denommus> naudiz: and it's even better than what you want, because you can associate your variants with arbitrary data!
15:51:32 <naudiz> Denommus: but that would mean defining all instances in one type definition. I want it to be kind of modular
15:52:04 <Denommus> naudiz: again, stop trying to program in Haskell as you would in an OO language
15:52:14 <Denommus> naudiz: there's nothing "non-modular" about this approach
15:52:52 <Denommus> naudiz: unless you really need to use a specific variant completely isolated from the others - but, provided your use-case, that's really not the case
15:53:53 <naudiz> Denommus: If I understand you correctly, you suggest type State = State1 | State2 | State3 | ..., right?
15:54:22 <Denommus> naudiz: yes
15:54:40 <Denommus> naudiz: and some states may even come encoded with some associated data!
15:54:59 <Sindriava> How come a lot of libraries on Hackage don't have docs?
15:55:00 <Denommus> naudiz: like data State = State1 Int | State2 | State3 String
15:55:07 <Sindriava> e.g. the modules aren't clickable
15:55:46 * geekosaur wonders if the builder broke again
15:56:08 <naudiz> Denommus: but consider you want to add a new state, you had to add it to the list and pattern mach every function against it
15:56:09 <lpaste_> erikd pasted “GADT with an operator?” at http://lpaste.net/137560
15:56:10 <geekosaur> Sindriava, might bring that up in #haskell-infrastructure in case the builder's stuck again or something
15:56:26 <Sindriava> geekosaur: Thanks!
15:56:38 <erikd> anyone have a clue on that lpaste? ^^^^
15:56:44 <geekosaur> erikd, defined that way you need to wrap it in parens
15:56:53 <geekosaur> either x <&> y = ... or (<&>) = ...
15:57:03 <naudiz> Denommus: I'd like to have all the behaviour for one state in one file
15:57:57 <Denommus> naudiz: I have another question
15:58:10 <Denommus> naudiz: if you really need to extend later, why isn't your "state" just a function?
15:58:24 <Denommus> naudiz: and the function that will run it just takes it as a parameter?
15:58:34 <erikd> geekosaur: tried "(<&>) x y" and "x <&> y". both resulted in a parse error
15:58:36 <Denommus> naudiz: then if you need a new "state", you just create a new function
15:58:45 <Denommus> naudiz: you can even create inline states with lambda!
15:59:16 <geekosaur> oh, right, constructor
15:59:24 <geekosaur> infox constructors must start with :
15:59:28 <geekosaur> *infix
15:59:47 <naudiz> Denommus: I have a bunch of functions that are supposed to do all kinds of stuff depending on the current state
15:59:53 <geekosaur> and yes, if you're defining a GADT, it's a constructor not a function
16:00:12 <Denommus> naudiz: so you're telling me you're matching against state anyway? :-P
16:01:03 <Denommus> naudiz: is your code open source? Can I look at it?
16:01:04 <naudiz> Denommus: no, what I did until now is having a class as an interface
16:01:30 <Sindriava> I've yet to see a blog with code highlighting that can properly handle ' as part of an identifier
16:01:38 <Denommus> naudiz: you hardly ever need to create your own typeclass
16:01:52 <Denommus> naudiz: what are you actually trying to do?
16:02:18 <naudiz> Denommus: it is, but it is kind of embarassing because it's probably not good code
16:02:39 <erikd> geekosaur: thanks. (:&:) worked
16:02:56 <Denommus> naudiz: that's okay
16:03:01 <Denommus> but i got to go
16:03:28 <naudiz> Denommus: what I wan't to do in the end is writing a text adventure where the states are different locations, so e.g. "look" should do something different at each place
16:03:40 <naudiz> oh, that was quick
16:04:05 * geekosaur off the top of his head thinks this sounds like it might be better as a record or even a map
16:04:13 <geekosaur> (er, record of functions or record of maps
16:05:27 <naudiz> geekosaur: that's what my new approach would be like, yes
16:06:18 <naudiz> well, thanks. I'm just going to try this out.
16:06:27 <Zemyla> Why is it so hard to write Traversable instances for Church-encoded monads?
16:06:29 <dreams> naudiz: you could otherwise have a dispatch function.
16:07:03 <naudiz> dreams: could you explain that, please?
16:09:16 <dreams> naudiz: have a function that pattern match each state and calls the relevant function.
16:10:56 <naudiz> dreams: that way I would lose modularity, as I explained earlier. It's just not really what I want, but thanks for the suggestion.
16:11:17 <dreams> naudiz: in what way?
16:12:33 <naudiz> dreams: when adding a new state I had to pattern match against it in each function. I'd rather have all the behaviour for one state in its own file.
16:13:57 <naudiz> I'll try something out tomorrow and go to bed now. good night
16:14:06 <dreams> naudiz: I didn't say pattern match in every function; the dispatch function only.
16:14:13 <dreams> mkay.
16:15:09 <naudiz> I'll look into it tomorrow. tiredness and Haskell don't go well together
16:19:52 <Zemyla> Hmm, I want to write a Minesweeper monad that keeps the board in a hidden mutable state and only allows interaction with it using monadic commands.
16:21:18 <naudiz> Zemyla: sounds like StateT
16:22:06 <erikd> anyone know of a small SYB (scrap your boilerplate) example that actually works? i've found a bunch of them on the web, but none of them seem to work.
16:22:20 <Zemyla> Kind of, but I want the board state to be an MVector so it's not continually copying.
16:23:09 <jle`> Reader (MVector s Board) ?
16:24:24 <jle`> although for the typical minesweeper implementation, storing the board is probably not going to be a bottleneck
16:28:46 <jle`> you can also make a Monoid instance for possible changes to your board/moves, and use Writer
16:28:56 <shachaf> erikd: I doubt the API has changed.
16:31:13 <erikd> shachaf: no, but most of the code i find is incomplete snippets or doesn't compile
16:32:11 <erikd> eg none of the code in http://www.andres-loeh.de/SYB0-Talk.pdf works, but i can't figure out which bits should compile and which bits are just hypothetical
16:34:00 <shachaf> > everywhere (mkT (\x -> x * 2 :: Integer)) ('a',5)
16:34:04 <shachaf> ('a',10)
16:34:07 <shachaf> Seems to work.
16:36:16 <mpickering> anything more specific you are trying to do erikd?
16:37:04 <shachaf> Yes, that's a better thing to say.
16:37:22 <shachaf> "doesn't work" is not a problem description, as mauke says.
16:37:29 <shachaf> Show real code and real error message.
16:37:41 <shachaf> If you want to look at slides, look at http://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt
16:39:00 <mpickering> it's also demystifying to look at the implementation which is often just a few lines
16:39:54 <hpc> "doesn't work" is the kind of problem description that leads to solutions like "you zoomed out really far in your outlook"
16:41:14 <mfng>  Couldn't match expected type ‘text-1.1.0.0:Data.Text.Internal.Text’                 with actual type ‘T.Text’     NB: ‘text-1.1.0.0:Data.Text.Internal.Text’           is defined in ‘Data.Text.Internal’ in package ‘text-1.1.0.0’         ‘T.Text’           is defined in ‘Data.Text.Internal’ in package ‘text-1.2.1.1’     In the expression: maybe err id . lookup x $ assocs     In an equation for ‘context
16:41:33 <hpc> oh, also use lpaste
16:41:36 <mfng>  Couldn't match expected type ‘text-1.1.0.0:Data.Text.Internal.Text’                 with actual type ‘T.Text’     NB: ‘text-1.1.0.0:Data.Text.Internal.Text’           is defined in ‘Data.Text.Internal’ in package ‘text-1.1.0.0’         ‘T.Text’           is defined in ‘Data.Text.Internal’ in package ‘text-1.2.1.1’     In the expression: maybe err id . lookup x $ assocs     In an equation for ‘context
16:41:41 <erikd> mpickering: i have an AST ( https://github.com/erikd/language-javascript/blob/new-ast/src/Language/JavaScript/Parser/AST.hs#L37 ). i like to write a generic map function that traverses the AST and applies a function to all the JSAnnot nodes.
16:42:21 <mfng> I cannot figure what the problem is
16:42:40 <geekosaur> you are trying to mix two different versions of the text package
16:42:45 <Hijiri> is there a library like graphviz that works on GHC 7.10?
16:42:57 <geekosaur> and please use lpaste.net next time, it's hard to read those things jammed into a single line
16:43:57 <shachaf> Especially double-UTF8-encoded, or whatever that is.
16:44:16 <lpaste_> mfng pasted “Not working any more?” at http://lpaste.net/137564
16:44:23 <mpickering> erikd: An example like shachaf's should work great here, "everywhere (mkT modifyJsAnnot)"  where modifyJsAnnot :: JsAnnot -> JsAnnot
16:44:45 <shachaf> Of course, you need to derive Data.
16:44:58 <geekosaur> mfng, you are trying to mix two different versions of the text package
16:45:01 <shachaf> But I shouldn't guess what the problem is. Instead I should encourage you to post full code and full error.
16:45:12 <erikd> shachaf: already have Data :-)
16:45:34 <shachaf> See? Guessing is bad for everyone.
16:45:39 <mfng> How should I unmix it..?
16:46:34 <lpaste_> mfng pasted “Full error msg.” at http://lpaste.net/137565
16:47:12 <geekosaur> I don't know since I don't know what libraries you have installed. it looks to me like possibly Data.Text.Template is built against text-1.1.0.0 and needs to be rebuilt against text-1.2.1.1
16:47:25 <geekosaur> or you need to force use of text-1.1.0.0
16:47:31 <geekosaur> how are you building this?
16:48:18 <mfng> Would appreciate how I do that.
16:48:39 <mfng> That seems to be exactly the problem.
16:49:15 <geekosaur> how are you building this?
16:49:20 <mfng> If I do "cabal install text-1.1.0.0", will "text-1.2.1.1" be overwritten?
16:49:32 <geekosaur> no, it will not
16:49:57 <geekosaur> text-1.1.0.0 is likely already installed
16:50:19 <mfng> How can I force only to use 1.1.0.0?
16:50:19 <geekosaur> if you are building this by hand then add `-package text-1.1.0.0' to the ghc command line
16:50:30 <geekosaur> again: how are you building this?
16:50:52 <mfng> I guess I am building by hand
16:51:12 <mfng> just makiing a sing Main.hs file on the emacs
16:51:21 <mfng> single
16:51:26 <geekosaur> that's editing, not building.
16:52:02 <mfng> and I run the file to produce a text output in a modified version of the code.
16:52:17 <mfng> .txt output
16:52:57 <mfng> I will add `-package text-1.1.0.0'
16:58:16 <mfng> @geekosaur That works. Thank you.
16:58:16 <lambdabot> Unknown command, try @list
17:02:27 <lpaste_> newcomer pasted “literals_vs_variables” at http://lpaste.net/137567
17:03:24 <newcomer> so, why can literals have "type class" types?
17:03:46 <geekosaur> because the haskell report says so, in the case of numeric literals
17:04:06 <kadoban> newcomer: Why not?
17:04:07 <geekosaur> there are some extensions to extend this to strings and lists\
17:04:47 <newcomer> can variables have (Num a) type for example?
17:05:16 <geekosaur> there are no variables :) bindings are not necessarily polymorphic by default but can be made so
17:05:19 <kadoban> newcomer: Num a isn't a type.   Num a => a     is, and yes, things can have that type.
17:05:51 <guillaum2> Am I missing something or Data.Vector.Unboxed Vector is not an instance of Foldable or Traversable ? And if not, is there a reason ?
17:05:56 <newcomer> geekosaur, kadoban: OK cool.
17:05:59 <kadoban> newcomer: Actually, literal integers in your code have that type, although they'll be defaulted if something else doesn't narrow them down first.
17:06:41 <kadoban> newcomer: So if you have a  5 in your sourcecode, the type of that is   :: Num a => a     (though it'll end up Int or Integer if nothing else requires it to be something different)
17:06:53 <geekosaur> the point of this for numeric literals is so you don't need to annotate 4.0 to be Float vs. Double or 4 to be Int vs Integer vs Float vs Double, etc.
17:07:26 <geekosaur> or e.g. say 4.0 when you want to use 4 in a context that will require a Double
17:07:40 <geekosaur> since strongly typed languages do not implicitly "cast" things
17:08:49 <newcomer> geekosaur, nice, got it.
17:09:05 <glguy> guillaum2: The unboxed Vector type only works for arguments that are instances of Unbox, but Foldable and Traversable have class methods that need to work for all types
17:09:08 <geekosaur> (you will run into this again the first time you attempt division, I suspect :)
17:09:32 <kadoban> (in which case, remember `div` ^)
17:09:52 <newcomer> but this explains why literals are type classes. Why do bindings fall into a certain type by default?
17:10:25 <mfng> How can I force GHCi to use the package 'text-1.1.0.0' by inserting it in the source code? I don't want to build a native file. Just want to run it by double clicking the file.
17:10:33 <kadoban> newcomer: You mean why does the defaulting stuff exist? Because otherwise you'd get weird errors instead of output if you just did some math and didn't specify a type.
17:10:33 <guillaum2> glguy: ok, I understand then... This sucks... Thank you.
17:11:20 <kadoban> > 5 + 5
17:11:22 <lambdabot>  10
17:11:49 <kadoban> newcomer: With defaulting, that ^ would be some bizarre error about "What 'Num a' instance should I use?", which would be a bit annoying.
17:11:57 <kadoban> without*
17:12:03 <newcomer> OK. What if  I want a binding with a type class (Num a => a)?
17:12:14 <srhb> That's a type, not a type class. 
17:12:28 <kadoban> newcomer: (Num a => a) is a type, by the way. But if you want that, you just have to specify it     f :: Num a => a    f = 5
17:18:45 <newcomer> kadoban, f + 3.0 is of type (Fractional a => a). Isn't that kind of implicit downcasting?
17:19:31 <srhb> No, the a will be picked by the caller (or by defaulting, if it's completely unconstrained.)
17:19:40 <srhb> There is no casting.
17:20:16 <srhb> It never has one type and is then converted to some other except if you explicitly use some conversion function on it. It just has the right type from the start.
17:23:19 * hackagebot nationstates 0.2.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.0 (ChrisWong)
17:24:29 <mfng> eclipseFP no longer maintained. What's the best alternative?
17:28:32 <srhb> newcomer: Not sure if that was clear enough. in the case of (f :: Num a => a) + (5.0 :: Fractional b => b) -- we must unify a and b because of the type signature for (+). Since Num is a superclass of Fractional, we have to pick one of the Fractional types. In this case we have no more information to pick an actual type, so defaulting kicks in, and Double is chosen for both a and b.
17:28:36 <newcomer> one last question, does defaulting occur with bindings only? Free unbinded literals don't default. That would defeat the purpose. right?
17:28:43 <srhb> Yes they do.
17:28:59 <lyonsb> mfng: Terminal(s), vim/emacs, browser open to documentation pages (I also put VimFX or Pentadactyl on the browser) for quick alt-tabbing (or w/e your app switch shortcut is).  (My opinion only, I don't dev. haskell with it much yet, but I'm fairly sure I'll have the features I want/need with it)
17:29:04 <srhb> Compare
17:29:06 <srhb> > 5
17:29:07 <lambdabot>  5
17:29:08 <srhb> > 5 :: Double
17:29:09 <lambdabot>  5.0
17:30:43 <kadoban> newcomer: Defaulting occurs when it needs to use a value, but the only type it knows so far is too polymorphic to actually use. I don't think it matters if it's a binding or whatever, it's more how you use the value and what type it is (and what it has to unify with)
17:31:08 <kadoban> There's only a few things that default too, it's mostly numbers AFAIK.
17:31:52 <kadoban> newcomer: I would say it's not really something you have to understand in-depth, especially because you should usually give type annotations, especially to top-level bindings.
17:32:52 <srhb> I agree. :)
17:33:04 <newcomer> kadoban, Well, I'd like to really understand the type system. so your answers are really helping.
17:34:24 <srhb> I think kadobans point was that this is a part of the type system that you hardly ever interact with, because it just works transparently. :) But sure, curiousity and all that.
17:34:39 <srhb> (It's almost not a part of the type SYSTEM as such...)
17:35:01 <newcomer> I'm actually repeatedly reading all your answers :)
17:35:52 <srhb> The only other example I can think of offhand is the type of things like Nothing or empty list.
17:36:29 <newcomer> I just want to understand how haskell manages polymorphism and being strongly typed at the same time. Seems that it's not an easy thing to manage.
17:36:33 <lpaste_> mfng annotated “Not working any more?” with “Not working any more? (annotation) (annotation)” at http://lpaste.net/137564#a2489332292795760640
17:36:40 <srhb> newcomer: That's the magic of type classes. :)
17:37:04 <srhb> newcomer: And it _is_ one of the most defining features of Haskell, and a breakthrough in practical polymorphism.
17:37:06 <kadoban> (Which are surprisingly free of magic once you understand them … which is part of their magic? ;)
17:37:15 <srhb> Indeed. :)
17:37:20 <srhb> So simple, so powerful.
17:37:44 <tyler569> like most of haskell
17:37:54 <newcomer> you guys are writing poetry :)
17:38:57 <kadoban> :)
17:50:16 <lpaste_> mfng annotated “Not working any more?” with “Not working any more? (annotation) (annotation) (annotation)” at http://lpaste.net/137564#a1650601754858881024
17:57:14 <Ankhers> Would someone mind taking a quick look at http://lpaste.net/137577 and explain the best way to write aeson instances for enum types?
18:00:41 <srhb> mfng: text-1.2.1.1 /= text-1.1.0.0
18:00:49 <srhb> mfng: Isn't that the issue?
18:01:16 <pacak> Ankhers: Either via read/show or fromEnum/toEnum
18:02:29 <geekosaur> srhb, runhaskell apparently doesn't seem to work with PackageImports
18:02:34 <srhb> Oh.
18:02:56 <geekosaur> (the question was to solve the text incompatibility with runhaskell aka double clicking a .hs file in Explorer)
18:03:13 <srhb> Ah, okay. :)
18:07:39 <nitrix> Hi, why does cabal complain about "cannot satisfy -hide-package MonadCatchIO-mtl" and "cannot satisfy -hide-package monads-fd" when using the project generated by `snap init barebones` ?
18:08:07 <nitrix> I looked at the cabal file and those flags are mentioned nowhere. I'm very meticulous so those errors are bothering me.
18:18:39 <Ankhers> pacak: I figured, but I don't understand how to do it.
18:26:48 <hasket> nitrix: Did you run cabal install --dependencies-only
18:26:48 <hasket> ?
18:27:24 <hasket> nitrix: also probably want a sandbox "cabal sandbox init"
18:32:14 <nitrix> Interesting, it was trying to hide packages I didn't have installed?
18:32:29 <nitrix> (Almost done compiling)
18:34:04 <hasket> Not sure what's going on in the backend, but I'm guessing it has something to do with the cabal file saying to hide packages that weren't installed
18:35:53 <tcs> I'm on Windows - is it possible to make `cabal install cabal-install` build in a custom directory (i.e. not /C/Users/Name/AppData/Roaming) ?
18:36:19 <nitrix> hasket: Although, the cabal file doesn't say such things. It's almost like it's a preprocessor directive from the snap package.
18:36:36 <nitrix> hasket: Anyway, moment of truth... same error.
18:37:50 <dmj`> tcs: use a sandbodx
18:37:54 <dmj`> sandbox
18:38:34 <hasket> nitrix: hmmm okay then I'm out of ideas. What are you running when you're getting the error?
18:38:44 <nitrix> http://whiteboard.debian.net/57de2d.wb
18:39:10 <tcs> so I can run `cabal sandbox init` without having installed `cabal-install`?
18:39:27 <hasket> nitrix: Aha, that's probably your ghci file. 
18:40:24 <hasket> you can safely ignore it if you want. Or if it bugs you, just remove those lines temporarily from the file
18:40:33 <dmj`> tcs: you asked if you could 'cabal install cabal-install' which means you already have 'cabal-install' installed
18:41:36 <dmj`> tcs: You can download prebuilt binaries of cabal-install for a variety of platforms
18:41:44 <nitrix> hasket: Which file?
18:41:47 <dmj`> tcs: here's one for windows, https://www.haskell.org/cabal/release/cabal-install-1.22.0.0/cabal-1.22.0.0-i386-unknown-mingw32.tar.gz
18:42:28 <tcs> ah ok - that makes sense
18:43:00 <nitrix> hasket: That doesn't show up for any other projects. Just this one.
18:44:02 <tcs> dmj`: if I use a prebuilt binary, create a sandbox and then run `cabal install cabal-install` it will put everything that normally goes in the ../AppData/ directory into the sandbox?
18:45:20 <tcs> I'll go give that a try - thanks
18:47:07 <dmj`> tcs: if you download a prebuilt binary you won't have to run 'cabal install cabal-install'
18:47:32 <dmj`> tcs: no, it will put all your packages into the sandbox directory
18:47:39 <dmj`> .cabal-sandbox
18:48:38 <dmj`> tcs: unless your prebuilt binary is out of date, in that case, yes, do cabal sandbox init, cabal install cabal-install, then move .cabal-sandbox/bin/cabal to your $PATH
18:58:06 <ptanes> Is there any way to obtain the solutions ebook for Haskell the Craft 3/e? 
18:58:15 <ptanes> Why don't they sell it..?
19:01:34 <Ankhers> Would someone mind explaining how to write the following aeson instances? http://lpaste.net/137577
19:02:50 <dmj`> Ankhers: you need a ToJSON for Foo
19:03:00 <dmj`> Ankhers: er, a FromJSON
19:03:17 <dmj`> instance FromJSON Foo where parseJSON (String "Bar") = pure Bar.. etc
19:03:34 <Ankhers> It doesn't come in as a string though, it comes in as a number.
19:03:42 <Ankhers> That is my problem.
19:03:55 <nitrix> Hi, lost connection. Does anyone know why cabal shows me these two errors with hide-package? Steps to reproduce: http://whiteboard.debian.net/57de2d.wb
19:04:07 <AshyIsMe> this is pretty crazy https://github.com/billpmurphy/hask
19:04:18 <AshyIsMe> a bunch of haskell features added to python
19:04:26 <dmj`> instance FromJSON Foo where parseJSON (Number x) = pure $ case coefficient x of { 4 -> Bar; otherwise -> Baz }
19:04:42 <dmj`> Ankhers: whole number?
19:04:46 <nitrix> AshyIsMe: Does it has this: http://danielvelkov.blogspot.ca/2014/08/easy-haskell-profiling.html ?
19:05:09 <Ankhers> dmj`: Yes. I figured the {to,from}Enum functions could be useful.
19:06:03 <dmj`> Ankhers: you could (fromMaybe Baz $ fmap snd $ lookup x (zip [0..] [Bar..]))
19:06:07 <AshyIsMe> nitrix: i doubt it. also, that looks awesome
19:06:59 <dmj`> Ankhers: oh I see what you're saying, just do modulo
19:07:41 <dmj`> toEnum (x `mod` (length $ [Bar..])) :: Foo
19:07:47 <dmj`> no need for $
19:08:04 <dmj`> toEnum (x `mod` length [Bar..]) :: Foo   
19:08:05 <AshyIsMe> nitrix: i need to look into haskell profiling more, ive only done it once and i remember it being incredibly tedious with cabal recompiling the world and breaking everything
19:08:20 <arkeet> eh
19:08:27 <arkeet> shouldn't it just be an error for out of range stuff
19:08:34 <AshyIsMe> nitrix: i wonder if stack has some nice profiling features
19:09:05 <arkeet> if only Enum was safer
19:10:23 <Ankhers> dmj`: I seem to get an error on the `]` in `[Bar..]`.
19:10:42 <LordBrain> i'd ask in #leksah but the room seems dead. I forget how to get context sensitive help in leksah, anyone know?
19:11:14 <arkeet> it should be [Bar ..]
19:11:43 <dmj`> > take 4 $ [1..]
19:11:45 <lambdabot>  [1,2,3,4]
19:11:50 <dmj`> arkeet: should it?
19:11:52 <arkeet> > [False..]
19:11:53 <lambdabot>  <hint>:1:9: parse error on input ‘]’
19:11:59 <dmj`> arkeet: ah :)
19:12:01 <dmj`> you win
19:12:08 <arkeet> yes, otherwise it thinks you're referring to the operator . from the Bar namespace.
19:12:20 <dmj`> oh hrm.. intellesting.. 
19:12:24 <Ankhers> Couldn't match expected type ‘Int’ with actual type ‘Scientific’
19:12:25 <arkeet> kind of annoying.
19:12:34 <dmj`> Ankhers: use `coefficient`
19:12:35 <arkeet> I still wouldn't use mod.
19:12:38 <arkeet> because that doesn't make sense.
19:12:54 <Ankhers> arkeet: How would you do it?
19:13:05 <dmj`> arkeet: but what if he uses a number greater than the range of the Enum?
19:13:06 <arkeet> < arkeet> shouldn't it just be an error for out of range stuff
19:13:19 <dmj`> :t coefficient
19:13:20 <lambdabot> Not in scope: ‘coefficient’
19:13:20 <athan> Is there an easy way to syntactially group funcion pattern matches, without necessarilly using lambda pattern matches? Something like `type BiEndo a = a -> a -> a; foo :: a -> BiEndo a; foo x (y z) = ...`? Instead of `foo x y z = ...`?
19:13:29 <athan> Maybe without making a newtype? :P
19:13:32 <Ankhers> I would expect parsing to fail and return a Nothing.
19:13:34 <arkeet> athan: how is that supposed to work?
19:13:44 <athan> arkeet: I have no idea haha
19:14:04 <dmj`> I have to go get ice cream
19:14:26 <athan> dangit
19:14:42 <athan> What's a pattern synonym?
19:14:42 <nitrix> Could someone help me with http://whiteboard.debian.net/57de2d.wb ?
19:15:15 <arkeet> Ankhers: so check the value of i, if it's in range use toEnum, otherwise fail the parser.
19:17:22 <arkeet> if <i is in range> then return (toEnum i) else fail "out of range" or something.
19:17:41 <arkeet> or mzero instead of fail. or whatever.
19:18:15 <Ankhers> arkeet: What is the best way to test if something is in range?
19:18:42 <Fylwind> Conjoined looks really scary :(
19:18:51 <Ankhers> length [Bar ..]?
19:18:59 <arkeet> Ankhers: just like
19:19:04 <arkeet> 0 <= i && i < 3
19:19:18 <bananagram> <3
19:19:22 <arkeet> oh wait.
19:19:24 <arkeet> it better be an integer too.
19:19:26 <arkeet> how annoying.
19:20:21 <arkeet> because it's Scientific, not Int.
19:20:26 <Ankhers> I was hoping to avoid the i < 3 part, in the case that things were added at a later time.
19:20:33 <arkeet> yeah I know.
19:20:38 <arkeet> so you can put length if you want.
19:21:28 <arkeet> well you can't use i, but
19:21:33 <arkeet> https://hackage.haskell.org/package/scientific-0.3.3.8/docs/Data-Scientific.html#t:Scientific
19:21:42 <arkeet> floatingOrInteger seems like the best thing to use here??
19:22:00 <arkeet> case floatingOrInteger i of
19:22:40 <Ankhers> arkeet: Thanks for the help. I need to go. I will try an figure this out another time.
19:22:41 <arkeet>   Right n | 0 <= n && n < length [(minBound :: Foo) ..] -> return (toEnum n)
19:22:47 <arkeet>   _ -> mzero
19:22:48 <arkeet> or something.
19:23:14 <arkeet> I don't like Enum.l
19:24:51 <Gurkenglas> Why is Key from https://hackage.haskell.org/package/keys-3.0.1/docs/Data-Key.html#t:Key a "global" type family and ComonadCofrees base functor ( https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree-Class.html ) is part of the instance?
19:25:10 <Gurkenglas> (Why aren't the two cases handled the same way? (I like the second one better.)
19:25:14 <Gurkenglas> *)
19:27:31 <arkeet> Gurkenglas: ?
19:28:14 <arkeet> probably Key is top level instead of being an associated type because it's used in multiple classes.
19:29:00 <arkeet> I don't know what you mean about Cofree
19:29:19 <Gurkenglas> (An instance of ComonadCofree looks like "ComonadCofree Maybe NonEmpty", an instance of Keyed looks like "Keyed []" (and type instance Key [] = Int)
19:29:25 <Gurkenglas> *)
19:29:38 <arkeet>  < arkeet> probably Key is top level instead of being an associated type because it's used in multiple classes.
19:29:49 <arkeet> namely, at least Keyed and Lookup.
19:30:20 <Fylwind> is there a way to load module via the command line in ghci? like: ghci -m Control.Lens or something?
19:30:37 <arkeet> otherwise it could have been an associated type, or a class parameter (with functional dependency)
19:30:43 <Gurkenglas> You could associate the representing type with each of those classes, right?
19:30:43 <YellowOnion> Fylwind, import Control.Lens
19:30:49 <arkeet> ?
19:30:56 <YellowOnion> oh wait you want from the command line
19:31:17 <Fylwind> YellowOnion: yes
19:31:42 <YellowOnion> Fylwind, you would think ghci --help would say how.
19:31:42 <arkeet> Gurkenglas: which class would you put it in?
19:31:42 <Gurkenglas> Make it "Keyed [] Int", "Indexable Int", and so on for anything that includes Key in its type signatures
19:31:48 <arkeet> Keyed and Lookup both need Key
19:31:52 <Gurkenglas> *"Indexable [] Int"
19:32:57 <arkeet> I guess you could put it in all.
19:32:59 <nitrix> Could someone help me with http://whiteboard.debian.net/57de2d.wb ?
19:33:01 <arkeet> with functional dependencies everywhere.
19:34:07 <arkeet> Gurkenglas: it doesn't make a huge difference, anyway.
19:34:23 <Azoth> Evening, everyone.
19:35:39 <Gurkenglas> Maybe Haddock should annotate instances of classes that refer to type families with the according type family value...
19:46:23 <Adeon> anyone know how I can make stack more verbose when it's building my project
19:46:26 <Adeon> it shows it's compiling packages
19:46:29 <Adeon> but not individual modules
19:46:32 <Adeon> doesn't show warnings either
19:46:36 <Adeon> unless something errors
19:49:40 <kadoban> Adeon: Dumb question: you've tried -v, right?
19:49:50 <Gurkenglas> Why isn't there an instance Representable IntMap?
19:50:07 <Adeon> -v is extremely verbose
19:50:14 <Adeon> and it actually doesn't show warnings either!
19:50:20 <kadoban> Ah, heh.
19:50:26 <geekosaur> maybe try -v1
19:50:36 <Adeon> -v1 doesn't seem to be valid
19:50:48 <Adeon> there is --verbose and it seems to take strings parameters like debug and info
19:51:03 <geekosaur> ah. ghc and cabal, -v has levels and -v2 or -v3 is default or something silly like that
19:51:11 <Adeon> er, --verbosity
19:51:36 <kadoban> Yeah --verbosity exists, but … if even the most verbose doesn't show the info you want, probably not helpful I guess.
19:51:40 <Adeon> I tried modifying cabal config but I don't know if stack even looks at it, maybe Cabal library does?
19:51:50 <kadoban> I wonder if it throws logs something? Hmm.
19:52:19 <Adeon> they probably are in logs somewhere
19:52:22 <Adeon> but that's not good enough
19:52:50 <Adeon> well I could probably hack something but I would feel stupid for working around something like that
19:53:01 <kadoban> Well, it would be for me, though I can see why you'd want the usual compiler spam.
19:53:25 <Adeon> I have a project that has many individual cabal projects
19:53:34 <Adeon> when I compile them all with stack, it doesn't tell me about warnings and stuff
19:54:06 <Adeon> I could try opening a SO question
19:55:04 <kadoban> Remember it's a fairly new project, I'd imagine there's some options/use-cases that nobody really handled yet. Might consider opening an issue if there really isn't a way (which I don't see one)
19:55:29 <Adeon> it's been awesome so far
19:55:32 <Adeon> except for this little thing
19:55:55 <kadoban> Yeah so far I'm quite impressed by it.
19:56:05 <Adeon> hmm, I'll try the latest git version of stack before opening anything
19:56:19 <bitemyapp> are Functor instances uniquely determined for a datatype?
19:56:33 <geekosaur> ?
19:56:37 <bitemyapp> or is there some catch or contradictory example?
19:56:57 <bitemyapp> geekosaur: is there one law-abiding Functor instance given an arbitrary datatype?
19:57:05 <bitemyapp> I'm thinking of DeriveFunctor here.
19:57:10 <davean> bitemyapp: pair?
19:57:26 <davean> bitemyapp: whats the "correct" functor instance for ,?
19:57:29 <bitemyapp> davean: data Pair a a = Pair a a -- this one?
19:57:32 <geekosaur> I thought list was a counterexample? the one we have and a ziplist thing?
19:57:41 <bitemyapp> geekosaur: that's applicative, yeah?
19:57:52 <bitemyapp> there's only one Functor for List so far as I was aware.
19:58:01 <geekosaur> ok
19:58:10 <davean> bitemyapp: Pair a b
19:58:13 * geekosaur may not be braining well at this point...
19:58:39 <bitemyapp> davean: has to map over b because of application order, doesn't it?
19:58:56 <kadoban> davean: You can't write   instance Functor (Pair ? b), there's no syntax for that or anything AFAIK
19:59:16 <bitemyapp> kadoban: can I just assume I'm right and proceed?
19:59:55 <Azoth> What versions of LLVM are supported by haskell>
19:59:57 <Azoth> ?
19:59:58 <bitemyapp> I was really asking as a sanity check, I was 90% certain to begin with.
19:59:59 <kadoban> bitemyapp: I personally don't know of one … I'm … thinking of perhaps irrelevant things, like what it actually means for there to only be one possible instance. Like, what about types where you could write the same instance two different ways?
20:00:19 <bitemyapp> kadoban: care about denotation here I think.
20:00:31 <bitemyapp> kadoban: or equivalence given inputs/outputs.
20:00:42 <bitemyapp> so, ignoring strictness and operational semantics.
20:01:08 <bitemyapp> pretty sure there's a semantically unique Functor for a given datatype representation. You could think of it as a set of implementations that share the same input/output relations.
20:01:16 <kadoban> bitemyapp: Right, that seems like the right approach. But yeah, given that I … don't know of one and I think I doubt a counter-example exists at least.
20:01:18 <bitemyapp> but the plurality in this case is irrelevant for my purposes.
20:01:28 <bitemyapp> kadoban: 'bout what I expected then. Thank ye.
20:01:33 <kadoban> 'sure
20:01:41 <bitemyapp> kadoban: next question
20:01:57 <bitemyapp> kadoban: non-uniqueness of Applicative - is this attributable (in whole or part?) to the structural monoid?
20:02:43 <bitemyapp> monoids are in general often not unique for a given datatype, accordingly, the monoidal bit of monoidal functor would appear to be the vector for non-uniqueness of applicative instances.
20:03:08 <kadoban> I personally don't really know what that is XD
20:03:39 <davean> kadoban: Thats an issue with writing haskell, not Functor.
20:03:57 <bitemyapp> @ty (<*>)
20:03:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:04:02 <bitemyapp> kadoban: ^^ two f.
20:04:07 <bitemyapp> kadoban: returns one f
20:04:13 <davean> kadoban: There is a world of difference between "haskell is only capible of implimenting a single functor instance" and "only one exists"
20:04:17 <bitemyapp> kadoban: ya need a monoid as ye apply the function.
20:04:36 <kadoban> Ohh … that totally makes sense
20:04:58 <kadoban> davean: Well, I think we were discussing haskell's Functor here
20:05:18 <bitemyapp> davean: that's fair, I'll add a note to the Functor chapter and consider talking about it
20:05:51 <bitemyapp> because I really want them to be thinking about parametricity and how many valid, law-abiding possibilities there are for a given product of (typeclass x type)
20:18:24 <Gurkenglas> (bitemyapp, just in case, not all (* -> *) have a possible Functor instance.)
20:21:18 <hasket> nitrix: If you're still there, ~/.ghci file
20:21:39 <hasket> nitrix Still not 100% sure where it comes from though
20:33:28 <goodalice> anyone understand why these don't compile? http://lpaste.net/137586
20:39:20 <joco42> hamishmack: when I try Leksah on MacOS (the prebuilt dmg 7.8.3 version) then the metadata browser only shows one package (even though the startup took some 2 minutes - i guess it was collecting metadata) - any idea what might be going wrong ? here is a snapshot http://snag.gy/G4XYu.jpg
20:51:42 <felixn> joco42: if Leksah isn't working for you, try Atom with https://atom.io/packages/ide-haskell, I'm really happy with it
20:53:01 <joco42> felixn: there is one important feature in Leksah that i really find useful and no other ide i tried gives this - the ability to quickly find the defintion of anything
20:53:58 <felixn> joco42: that does sound nice!
20:53:58 <joco42> Atom uses codex under the hood to get jump to definition capability
20:55:11 <joco42> but codex seems to only give definitions of identifiers that are in packages that are defined as dependencies in your cabal file
20:56:34 <joco42> Leksah otoh collects metadata from everything installed ... so you can really see the definition of everything installed on your system 
20:57:09 <joco42> with the only limitiation - afaik that sandboxes are not supported yet
20:57:29 <felixn> joco42: nice, actually they don't have any jump to/search definition support yet, but they're constantly updating it, not sure what they're doing if they're not doing that!
20:58:28 * hackagebot ewe 0.1.0.43 - An language using in Programming Languages teaching  https://hackage.haskell.org/package/ewe-0.1.0.43 (JuanFranciscoCardonaMcCormick)
20:58:47 <joco42> felixn: the problem is that even if they do that... they will probably use codex - which has the problem - seemingly - that it only can jump to definitions of dependencies declared in the current cabal file
20:59:24 <joco42> so if you want to go deeper to see the definition of say putStrLn then codex seems to fail
21:00:05 <joco42> for example i tried https://github.com/begriffs/haskell-vim-now with codex and this is what happened
21:00:35 <Gurkenglas> Why isn't there an instance Representable IntMap?
21:05:02 <joco42> hamishmack: it seems that Leksah correctly unpacks the sources http://snag.gy/8EIWg.jpg
21:07:28 <joco42> however, the cabal version seems wrong :
21:07:34 <joco42> https://www.irccloud.com/pastebin/NtPhOCWh/
21:21:32 <porges> any pipes gurus about?
21:21:41 <johnw> porges: ask away
21:21:46 <porges> I'm pretty sure what I'm doing is 100% wrong
21:23:12 <porges> https://gist.github.com/Porges/153837bd72ccc739da8b
21:23:56 <porges> I'm trying to yield things from within an bracketed-style operation - in this case an HTTP request 
21:24:06 <porges> it "works" but I think all the characteristics are going to be wrong
21:24:26 <johnw> hmm
21:25:10 <johnw> well, let's see what you're doing
21:25:20 <johnw> with an HTTP connection, if you get a response body, you're creating a producer out of it
21:25:29 <johnw> which should be fine, because you do actually have the body
21:25:35 <porges> (this is using pipes-http)
21:25:44 <johnw> then you just cat that producer, basically
21:25:55 <johnw> you should be able to drop the second part entirely
21:26:03 <johnw> just return the producer from lift
21:26:23 <porges> that doesn't compile :)
21:26:27 <johnw> as long as MonadSafe is governing the resource associated with the response body (assuming it's being streamed in), you're OK
21:26:37 <johnw> if it doesn't compile, try "generalize"ing it
21:26:53 <porges> this is within a wider IO-using operation
21:27:59 <johnw> one of the pipes laws is: for s yield = s
21:29:01 <porges> yeah, but it doesn't make sense here - let me update the gist
21:33:12 <porges> there we go, that should give a bit more context
21:34:43 <porges> my concern is that either a) this is going to force the whole request before yielding anything downstream or b) it's going to break the resource management
21:36:47 <mjrosenb> can anyone explain why the value 'maybe' has that name?
21:36:47 <johnw> you really should be able to drop that last line
21:37:19 <johnw> the same with the other "for x yield" that you're using
21:37:21 <johnw> it's the same thing as x
21:38:44 <porges> don't mind the inner one, it's simplified a bit from what I'm actually doing (it's not really yielding ByteStrings)
21:39:23 <johnw> so, this producer you make is just going to keep calling brRead on the response body
21:39:47 <johnw> and a BodyReader is an IO action
21:39:53 <jle`> mjrosenb: you mean the function from Prelude?
21:39:58 <johnw> so whatever resources it needs, are going to be managed by that IO action
21:40:09 <johnw> since it supports calling it multiple times to continue the reading
21:40:10 <porges> oh yes, I can replace it just with "yields"
21:40:11 <jle`> maybe it's the catamorphism?
21:40:20 <jle`> so it's a special sort of function for the Maybe type
21:40:28 <johnw> porges: if you can replace it with just "yields", then you can say:
21:40:29 <jle`> but then we should call foldr "list"
21:40:36 <jle`> i wouldn't mind that
21:40:38 <johnw> join $ x ..., instead of yields <- x ... ; yields
21:41:05 <mjrosenb> jle`: ja.
21:41:22 <johnw> porges: anyway, the real answer to your concern is an http-client question, not a pipes question
21:41:27 <jle`> maybe you can say that `maybe` turns a Maybe a into the church encoding of a `Maybe a`
21:41:35 <johnw> i.e., can you keep calling brRead after leaving withHttp
21:41:42 <jle`> with weird parameter orders
21:41:43 <johnw> which it looks like you can
21:47:14 <porges> that's strange
21:48:09 <porges> oh - withHttp is actually the function supplied by pipes-http
21:48:12 <porges> doh
21:48:34 <porges> that makes sense that it would all be happy then
21:57:43 <mjrosenb> Is is possible to get a Read instance for Foo -> Foo, where Foo is a datatype?
21:59:08 <Gurkenglas> What do you know about the datatype?
21:59:41 <mjrosenb> it has a single constructor and a bunch of monomorphic named fields
22:00:39 <mjrosenb> I just want something that will turn "{a = 4, b = True}" into \x -> x {a=4, b=True}
22:01:00 <jle`> would probably be considered an abuse of Read at best
22:02:24 <mjrosenb> I'm ok with a little abuse, it is consentual.
22:02:41 <Gurkenglas> (\x -> x {a=4, b=True}) would not be Foo -> Foo
22:02:54 <Hijiri> the Read typeclass isn't even sentient enough to give consent
22:03:11 <jle`> by that i mean, you won't find any easy way to do things that Read isn't supposed to do, heh
22:03:51 <mjrosenb> although, I suspect I can make another typeclass, and automatically derive it with TH
22:04:03 <mjrosenb> ReadUpdate or somesuch.
22:04:09 <Gurkenglas> (Nevermind, it would, I made a mistake back there)
22:04:20 <jle`> if you have Foo, might as well write a parser
22:04:22 <jle`> for Foo
22:04:31 <jle`> unless you want to write one that is derivable
22:04:39 <jle`> then you probably don't have to use TH for that; you can just use Generics or Data
22:05:26 <jle`> if you want to write one that's derivable for different types you're going to have a to write a parser anyway
22:05:35 <mjrosenb> I do want to write one that is derivable
22:05:51 <jle`> yeah, then you can use Generic or Data to generate a parser based on the data type
22:05:56 <mjrosenb> mostly because I don't want to have to update the parse every single time I update the type.
22:07:55 <mjrosenb> I have not heard of Data before, can you give a link for it?
22:13:24 <mjrosenb> !seen sbidin
22:33:32 * hackagebot warp 3.1.1 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.1 (KazuYamamoto)
22:41:05 <newsham> is there anything like Programatica that still exists and is maintained for haskell, for proving haskell code in some theorem prover?
22:41:24 <SrPx> I'm not sure I asked this already, but why sometimes the main page on a hackage package doesn't have the documentation? https://hackage.haskell.org/package/gloss
22:42:32 <Cale> SrPx: You can find out by clicking the build log link next to "Docs not available"
22:43:12 <SrPx> It doesn't say a lot to me
22:43:22 <Cale> SrPx: It's usually either because the package was just uploaded and generating the docs hasn't been attempted yet, or due to build failures on the server (usually because of dependencies)
22:43:41 <SrPx> I see... alright !
22:44:14 <Cale> In this case, the current version of gloss says that it requires base-4.8.* but the version installed on the Hackage server is base-4.7.0.1
22:45:14 <Cale> SrPx: It's possible for the package maintainer to fix this by manually uploading the docs
22:46:21 <Cale> http://neilmitchell.blogspot.ca/2014/10/fixing-haddock-docs-on-hackage.html -- heh apparently ndm has even made a tool for it :)
22:46:54 <Cale> http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html explains how to do it manually
22:49:04 <johnw> newsham: I've been using Coq for that purpose
22:49:30 <johnw> newsham: but it's nowhere near as developed as Programatica looks like it became
22:56:39 <newsham> johnw: do you automated it somehow or do you manually translate or use coq prog extraction?
22:56:52 <johnw> both of the latter, depending on what the objective is
22:57:01 <johnw> there is an hs-to-gallina project, but it didn't work for any real code
22:57:10 <johnw> however, I would like to continue exploring this avenue
22:57:30 <johnw> I'm building https://github.com/jwiegley/coq-haskell, which means that syntactic translation is getting smaller and smaller in scope
22:57:55 <newsham> i saw a blog of someone recently coding haskell, rewriting it in HOLite, and then generating haskell code from it
22:58:02 <johnw> yeah, I did too
22:58:10 <johnw> kind of the exact same kind of thing in spirit to what I'm doing
22:58:11 <newsham> that seems similar in spirit.. but.. less automated still
23:04:44 <newsham> johnw: ty
23:05:55 <newsham> do you mostly use it for pure code or do you use something like hoare/separation logic for monadic stuff too?
23:06:16 <djanatyn> n
23:06:37 <johnw> right now I do prove code over Monad m, but not for a particular monad
23:06:44 <johnw> for that I'd probably use a hoare logic
23:07:29 <newsham> thank you for the info.. I gotta run.. cheers
23:13:33 * hackagebot fsnotify 0.2.1 - Cross platform library for file change notification.  https://hackage.haskell.org/package/fsnotify-0.2.1 (GregWeber)
23:39:41 <pacak> hmatrix fails to compile with ghc 7.10.2 <no location info>: ghc: phase `Assembler' failed (exitcode = 1)
23:53:35 * hackagebot wai-routes 0.7.2 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.7.2 (AnupamJain)
