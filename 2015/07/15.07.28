00:01:43 <quchen2> Saizan: Aaaah. (I have no idea what that means.)
00:02:19 <quchen2> magistr: You can semi-easily build one yourself, but if you're looking for a library, have a look at cloud haskell.
00:02:28 <pharaun> jle`: :P
00:02:32 <quchen2> (Which is the Erlang equivalent in Haskell.)
00:13:10 <solatis> ok, cross-platform GUI apps in Haskell -- am I setting myself up for disaster when trying to do this ?
00:13:47 <solatis> right now I'm using a www interface as the GUI, but yesod has severe problems compiling on windows
00:13:50 <jle`> just use html5 + js :)
00:14:33 <rcyr> Hmm, not a bad idea actually.... Electron + ghcjs ?
00:14:44 <rcyr> + reflex perhaps
00:14:49 <solatis> hmm
00:15:16 <solatis> what is electron ?
00:15:24 <rcyr> http://electron.atom.io/ This
00:15:59 <solatis> oh damn that looks pretty neat
00:16:36 <rcyr> One day, I might just try a setup like that
00:16:47 <solatis> hmmm
00:17:11 <solatis> looks like it makes simple things simple, but complex things even more complex ?
00:17:41 <solatis> i mean, i need background worker threads, connections with all kinds of 3rd party services, etc
00:18:24 <rcyr> Then hmm, I don't know. JS itself is single-threaded and everything is done async.
00:18:32 <Hijiri> there's threepenny, I haven't used it much though
00:19:07 <rcyr> Hijiri: What's that?
00:19:08 <solatis> i just want a "real" GUI with a "real" Haskell application, not ghcjs
00:19:19 <solatis> i would guess => https://hackage.haskell.org/package/threepenny-gui
00:19:24 <Hijiri> rcyr: threepenny is a GUI library that uses a webpage as a display
00:19:49 <Hijiri> it starts a web server and you connect to it in a browser to see the interface
00:20:00 <solatis> "A program written with Threepenny is essentially a small web server that displays the user interface as a web page to any browser that connects to it. You can freely manipulate the HTML DOM and handle JavaScript events from your Haskell code." => exactly what i need
00:20:27 <solatis> i wonder how well it integrates with an OS
00:20:40 <Axman6> I think it's possible with threepenny-gui to create standalone apps which embed webkit
00:20:41 <jle`> ghcjs can compile any haskell tho, effectively
00:20:55 <jle`> so your current haskell programs can be run out of the box
00:20:59 <rcyr> Axman6: Ha, I was going to ask which browser it uses (webkit?)
00:21:01 <jle`> just with gui
00:21:30 <Axman6> well, it doesn't use any browser per se, it just producer a webserver
00:21:33 <Axman6> produces*
00:21:36 <solatis> jle`: i would guess that getting around the browser javascript restrictions would be very difficult ?
00:21:55 <jle`> what restrictions are you talking about?
00:22:05 <solatis> i mean, if i want to connect through a SOCKS proxy to a remote Tor hidden service using ghcjs, for example ?
00:22:17 <solatis> and definitely DO NOT WANT dns requests to be leaked
00:22:30 <Axman6> ghcjs does a very good job of getting haskell (including threading) working well in the browser
00:22:38 <mniip> I woder whether ghcjs uses some emulation like asm.js or if it outputs js from the backend
00:22:47 <jle`> it outputs js i believe
00:22:55 <rcyr> Axman6: I guess that if I were to use electron, the only pain would be FFI?
00:22:59 <solatis> yes, but the browser has a lot of restrictions for its sandboxed javascript environment
00:23:01 <Axman6> it produces something that loos like a VM
00:23:07 <Axman6> the code is pretty fascinating to read
00:23:19 <Axman6> rcyr: what's electron?
00:23:20 <mniip> jle`, is it meaningful js I mean
00:23:27 <jle`> not quite
00:23:32 <Axman6> "no"
00:23:38 <jle`> it's not "semantic js"
00:23:46 <jle`> like, say, coffeescript or purescript
00:23:51 <Axman6> it's very low level
00:23:53 <mniip> nonono
00:23:54 <rcyr> Axman6: It's something that is more of less like the fusion of node.js + chrome... github uses it for their Atom Editor
00:24:06 <solatis> doesn't haskell use llvm for ghcjs ?
00:24:07 <Axman6> right
00:24:08 <jle`> solatis: yeah, it's probably not the best if you're going to be making tor connections
00:24:33 <jle`> most networking you would be doing with javascript based networking, like websockets
00:24:42 <mniip> I mean it could be an STG machine and still be meaningful
00:24:44 <solatis> i could separate the presentation layer with the background worker service, but.. ugh
00:25:32 <jle`> i think that's essentially what threepenny tries to offer as a library
00:25:45 <solatis> yeah
00:25:53 <solatis> i'm going to look into threepenny
00:26:08 <solatis> if i could have the GUI talk to a different background / worker service, i'll be ok
00:32:00 <YellowOnion> If I have a Data type V3 (V2), is there a better way to do this with lens?: (~._x) . (\V2 x y -> ..)
00:33:15 <jle`> what do you mean V3 (V2) ?
00:33:23 <jle`> *mean by
00:34:19 <YellowOnion> jle`, there's 3 V2's inside a V3
00:34:29 <jle`> ah so like V3 (V2 a) ?
00:34:41 <YellowOnion> yeah
00:34:54 <jle`> and what's (~.) ?
00:35:45 <jle`> do you mean like, apply a (V2 a -> V2 a) to the first field in a V3 (V2 a) ?
00:35:53 <YellowOnion> yeah
00:36:02 <jle`> you can just use over _x f, right?
00:36:15 <mjrosenb> oh no, does sdl2-ttf only build with 7.10, and not 7.8?
00:36:38 <jle`> over _x (\V2 x y -> ...)
00:38:43 <YellowOnion> ahh thats nicer, just to make sure, would that return V3 modified or just V3's x value?
00:39:02 <jle`> that will modify the x value of the V3
00:39:10 <jle`> over _x :: (a -> a) -> V3 a -> V3 a
00:39:16 <phaazon> oh god.
00:39:21 <phaazon> I just discovered something cool
00:39:24 <phaazon> :k Proxy
00:39:25 <lambdabot> k -> *
00:39:27 <phaazon> k!
00:39:32 <jle`> yeah, polykinded :o
00:39:37 <jle`> :k Proxy Monad
00:39:38 <lambdabot> *
00:39:44 <phaazon> @let type P = Proxy (forall a. Num a)
00:39:45 <lambdabot>  .L.hs:150:1:
00:39:45 <lambdabot>      Illegal polymorphic or qualified type: forall a. Num a
00:39:45 <lambdabot>      Perhaps you intended to use ImpredicativeTypes
00:39:55 <phaazon> how do we set extension?
00:39:56 <jle`> impredicative types still not ok
00:40:06 <indiagreen> is there some cool use of polykinded Proxy that I can't think of?
00:40:10 <YellowOnion> jle`, ahh sorry I miss interp'd ~. is equilevent to view (getter?)
00:40:28 <jle`> indiagreen: it's useful so you can use it for Nat and other data kinds
00:40:29 <phaazon> @let type P = Proxy Nat
00:40:29 <indiagreen> YellowOnion: ~. is “set”
00:40:30 <lambdabot>  .L.hs:150:16: Not in scope: type constructor or class ‘Nat’
00:40:37 <phaazon> @let import GHC.TypeLits
00:40:38 <lambdabot>  Defined.
00:40:40 <phaazon> @let type P = Proxy Nat
00:40:41 <lambdabot>  Defined.
00:40:43 <phaazon> god.
00:40:44 <jle`> (.~) is set, actually
00:40:51 <ely-se> > "Hello, #haskell!"             & (++ "ely-se!") . take 7
00:40:53 <lambdabot>  "Hello, ely-se!"
00:40:58 <phaazon> I’ve never really played with kinds
00:41:20 <indiagreen> okay, then ~. is some new weird thing which still looks suspiciously like .~ with a typo
00:41:22 <phaazon> but I read somewhere something in the lines of « type V3 = Vec 3 »
00:41:28 <jle`> (~.) is not a thing, heh
00:41:30 <phaazon> DataKinds to promote natural numbers
00:41:42 <phaazon> I thought there’re only two kinds
00:41:45 <phaazon> *, and Constraints
00:41:57 <jle`> DataKinds lets you define arbitrary kinds
00:41:59 <phaazon> (and of course (->) to link them)
00:42:00 <jle`> so you can make new kinds
00:42:03 <phaazon> yeah
00:42:03 <jle`> like you can make new types
00:42:08 <phaazon> that’s amazing
00:42:09 <YellowOnion> oh god I wrote the function in thing
00:42:21 <YellowOnion> I gotta go get dinner bbs
00:42:24 <phaazon> so a kind is a type of type
00:42:31 <jle`> mhm
00:42:40 <YellowOnion> (^.) is what I mean
00:42:40 <phaazon> yeah
00:42:44 <phaazon> in the type level
00:42:45 <phaazon> 3 is a type
00:42:45 <jle`> only types of kind * (ignoring unboxed types) can have values
00:42:51 <phaazon> and its kind (the type of type) is Nat
00:43:03 <jle`> yeah, so you can't have a value of type 3
00:43:09 <phaazon> well
00:43:13 <jle`> because you can only have values of types that are of kind *
00:43:15 <phaazon> I guess you can convert from Nat -> *
00:43:26 <jle`> yeah, it's used for phantom types like that
00:43:41 <phaazon> I’ve been using Haskell for almost three years
00:43:48 <phaazon> and I still get amazed by the language
00:43:58 <phaazon> is there any other language with kinds support?
00:44:00 <jle`> well, DataKinds are a relatively new thing, heh
00:44:01 <phaazon> and kinds manipulation?
00:44:12 <johnw> jle`: I'm pretty sure that there is a value of type 3; it's the singleton inhabiting 3
00:44:21 <johnw> otherwise, 3 would be equivalent to Void
00:44:28 <jle`> well, dependently typed languages merge data, types, and kinds to be the same level/one thing
00:44:37 <jle`> johnw: you can have `x :: 3` ?
00:44:51 <johnw> I think that in GHC you need to say it as "Sing 3" to reify it
00:45:00 <jle`> yeah, to make it a *
00:45:13 <johnw> but it does have an inhabitant
00:45:32 <phaazon> :t undefined :: 3
00:45:35 <lambdabot>     Expected a type, but ‘3’ has kind ‘Nat’
00:45:35 <lambdabot>     In an expression type signature: 3
00:45:35 <lambdabot>     In the expression: undefined :: 3
00:45:35 <jle`> my point was that you have to have something of kind * to have inhabitants
00:45:38 <phaazon> nope :)
00:45:57 <phaazon> :k Sing
00:45:59 <lambdabot> Not in scope: type constructor or class ‘Sing’
00:46:44 <jle`> that's sort of what's special about * in the first place
00:47:11 <jle`> it's not really a statement about the type 3 itself, more about haskell syntax and spec, heh
00:47:18 <phaazon> now
00:47:22 <phaazon> the question.
00:47:28 <phaazon> what’s the point of passing around Constraint as kinds?
00:47:39 <phaazon> like, Proxy (forall a. Num a)
00:48:16 <johnw> i didn't say the inhabitant's type was of kind *
00:49:08 <jle`> so you can have (normal boxed) haskell values whose types are not of kind * ?
00:49:17 <johnw> these aren't values
00:49:29 <johnw> let me find you a code example
00:50:03 <phaazon> I guess inhabitent value requires *
00:50:09 <phaazon> # doesn’t have inhabitants
00:50:17 <mjrosenb> Were there any changes in the types of TH related functions recently?
00:50:29 <mjrosenb> notable ForallT.
00:50:31 <johnw> mjrosenb: I tihnk 7.8 made a lot of changes
00:50:37 <johnw> but I'm not sure which
00:51:08 <mjrosenb> hrmm, I'm using 7.8
00:51:16 <mjrosenb> but it works on 7.10.
00:52:16 <mjrosenb> type Pred = Type
00:52:39 <mjrosenb> oh, well that makes the error more confusing
00:52:41 <mjrosenb>     Couldn't match expected type `Pred' with actual type `Type'
00:57:02 <johnw> > natVal (undefined :: Proxy 3)
00:57:04 <lambdabot>  3
00:57:28 <jle`> Proxy 3 is * tho
00:57:54 <johnw> there is a bijection here between the inhabitant of *, and the inhabitant of Nat
00:58:07 <johnw> we use functions in TypeLits to go between them
00:58:27 <johnw> sorry, that was completely confused
00:58:35 <phaazon> hm
00:58:40 <johnw> anyway, if there weren't a thing that Proxy 3 referred to, you couldn't turn it into a value
00:58:51 <johnw> it's just that what it refers to is not a value
00:58:56 <phaazon> ok, so how I can I write a type who expects a Nat?
00:59:02 <phaazon> data Vec Nat = … ?
00:59:03 <jle`> phaazon: kind signatures
00:59:04 <johnw> :t natVal
00:59:05 <lambdabot> KnownNat n => proxy n -> Integer
00:59:13 <jle`> phaazon: data Vec :: Nat -> * where ...
00:59:31 <phaazon> like for GADts, actually
00:59:33 <johnw> yeah, kind signatures for working with the lifted type
00:59:45 <jle`> johnw: okay, i see your point :p
00:59:50 <phaazon> thanks, johnw 
01:00:01 <johnw> jle`: thanks :)
01:01:10 <phaazon> thanks chain!
01:01:31 <johnw> the KnowNat+proxy trick lets you use the inferred type (say, 3 : : Nat) as a value (3 :: Int), giving you a certain degree of value dependence
01:02:49 <johnw> intro article on the above: http://ponies.io/posts/2014-07-30-typelits.html
01:03:33 * hackagebot amazonka-ec2 0.3.6.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-0.3.6.1 (BrendanHay)
01:04:29 <phaazon> jle`: I think you’re wrong for KindSignatures
01:04:36 <phaazon> looks like the syntax is simpler than that
01:04:43 <phaazon> data (k :: Nat) = …
01:04:49 <phaazon> oops
01:04:51 <phaazon> data Vec (k :: Nat) = …
01:06:20 <johnw> i think either way works fine
01:08:35 <phaazon> johnw: I think the where clause is for GADTs
01:09:42 <johnw> yes
01:09:53 <johnw> it's pretty common to use GADTs when you are using kind signatures
01:10:04 <johnw> since otherwise, you can't take much advantage of them
01:10:21 <johnw> what you want is for constructors to vary in the type they produce
01:10:48 <johnw> Vnil :: Vec 0 a, Vsuc :: a -> Vec n a -> Vec (n + 1) a, etc.
01:10:56 <johnw> err, Vcons
01:12:07 <YellowOnion> OK, so whats the getter variant of over? (foldMapOf?)
01:12:20 <johnw> YellowOnion: how do you mean?
01:12:46 <johnw> > (1,2) ^. _1.to (+5)
01:12:48 <lambdabot>  6
01:14:20 <YellowOnion> johnw, Unless view is all I need, I wanted to make (\V2 a ->..) . (^._x) less of a mess.
01:15:28 <phaazon> hm, now…
01:15:35 <phaazon> data (d :: Nat) = ?
01:15:37 <jle`> foo ^. _x . to (\V2 x y -> ... ) ?
01:15:43 <phaazon> I guess I need to use GADTs.
01:15:44 <phaazon> like
01:15:55 <jle`> phaazon: did you forget the constructor?
01:16:02 <johnw> GADTs are pretty awesome
01:16:05 <phaazon> data Vec :: Nat -> * where
01:16:09 <johnw> for a while, I didn't understand what they were useful for
01:16:17 <phaazon>   V1 :: a -> Vec 1
01:16:23 <phaazon> I guess I need a as well
01:16:25 <phaazon> Nat -> * -> *
01:16:30 <YellowOnion> jle`, I'm trying to use it in a map so having foo at the start isn't ideal.
01:16:48 <phaazon> johnw: I use them only to enable ctors to have different types
01:16:53 <jle`> view (_x . to (\V2 x y -> ...)) ?
01:17:19 <phaazon> I guess Data :: Nat -> * -> * where should make it
01:17:24 <phaazon> goddamit
01:17:26 <phaazon> am I drunk?
01:17:28 <jle`> you might not want to name your constructor Data though
01:17:31 <jle`> idk you can if you want
01:17:35 <phaazon> data Vec :: Nat -> * -> * where
01:17:54 <johnw> doesn't data Vec (n :: Nat) a where also work?
01:17:56 <phaazon>   V1 :: a -> Vec 1 a
01:18:01 <phaazon>   V2 :: a -> a -> Vec 2 a
01:18:09 <jle`> if you just wanted to smart-constructor-wrap a Data.Vector vector, you can be okay with data Vec (n :: Nat) a = V (V.Vector a)
01:18:12 <phaazon> johnw: I don’t know
01:18:17 <jle`> that's what the linear package does, effectively
01:18:18 <YellowOnion> jle`, ahh thanks, so view is what I need, what is "to"?
01:18:25 <johnw> so, in some languages it makes a difference
01:18:31 <phaazon> jle`: well, that’s a bit odd
01:18:40 <johnw> data Vec (n :: Nat) :: * -> * where would have a particular meaning
01:18:44 <phaazon> because I won’t enable anything else than 1–4 dimensional vectors
01:19:16 <jle`> instead of Nat you can use a kind with 4 type inhabitants
01:19:50 <phaazon> what do you mean?
01:19:51 <jle`> for some extra kind-safety :)
01:20:01 <jle`> Nat has an infinite amount of types inhabiting the kind
01:20:14 <jle`> so you could do x :: Vec 100 Int, for example, which would be a meaningless type for you
01:20:25 <phaazon> indeed
01:20:27 <jle`> if your type only represents things that are 1 to 4
01:20:31 <phaazon> so
01:20:34 <jle`> so you can use a kind with only 4 types
01:20:39 <phaazon> data D = D1 | D2 | D3 | D4
01:20:43 <phaazon> and lift that 
01:20:46 <jle`> yea
01:20:57 <phaazon> I already have that type, actually :D
01:21:09 <johnw> data Vec :: D -> * -> * where !
01:21:39 <phaazon> yep :)
01:21:43 <jle`> YellowOnion: a `Getter s a` is something that can "get" an a from an s
01:21:49 <jle`> and the "getting" is done using `view`
01:22:18 <jle`> for a simplified picture, you can imagine type Getter s a = s -> a, and view = ($)
01:22:46 <jle`> that's what `to` does.  it takes an (s -> a) and gives you a `Getter s a`
01:23:02 <jle`> to :: (s -> a) -> Getter s a
01:23:04 <phaazon> does DataKinds imply PolyKinds?
01:23:14 <jle`> it's actually in the flowchart thing on the lens homepage
01:23:23 <jle`> http://hackage.haskell.org/package/lens
01:23:32 <jle`> under the Getter s a box, to :: (s -> a) -> Getter s a
01:23:36 <jle`> view :: Getter s a -> s -> a
01:23:57 <jle`> (simplified picture)
01:24:16 <jle`> the neat thing about how the lens library is constructed is that you can actually use a Lens s s a a as if it were a Getter s a
01:24:18 <jle`> the types unify
01:24:18 <ttt_fff> Im reading "Beginning Haskell" chatper 14, and I'm wondering -- what problem does Attribute Grammars / UUAGC solve? It seems like it's to avoid writing a function which traverses  datatype -- but I don't see how the attr grammars are shorter
01:24:40 <jle`> so any `Lens' s a` (like _x) will unify with the type Getter s a
01:24:43 <jle`> so you can use it with `view`
01:24:45 <jle`> it's kinda neat
01:25:11 <ttt_fff> here's jle` again, explaining complicated procedures and making everyone feel welcome
01:25:18 <jle`> _x :: Lens' (V3 a) a (made unpolymorphic for simplicity)
01:25:23 <jle`> and so _x :: Getter (V3 a) a
01:25:26 <jle`> so you can use it with `view`
01:25:43 <ttt_fff> jle`++
01:25:50 <jle`> oh ty :)
01:25:54 <jle`> o
01:25:59 <jle`> i'm honestly a lens noob tho
01:26:23 <ttt_fff> now, let's get back to my question, :-) // (i'm kidding, sorta) // Im reading "Beginning Haskell" chatper 14, and I'm wondering -- what problem does Attribute Grammars / UUAGC solve? It seems like it's to avoid writing a function which traverses  datatype -- but I don't see how the attr grammars are shorter
01:26:30 <ttt_fff> lens is awesome
01:26:33 <ttt_fff> I know how to use getter and setter
01:26:36 <ttt_fff> and wondering wtf the daigrams mean
01:26:44 <ttt_fff> I know about view, over, ^. , and that's about it
01:27:57 <YellowOnion> thanks, jle` I have some coding using just ^._x without "to" and it seems to work, so I'm trying to understand why "to" is required.
01:29:19 <jle`> YellowOnion: _x means "view the first field".  `to f` as a Getter for arbitrary f takes a bit of imagination.  to (+2) is, "view this number as if it were (+2) higher"
01:29:23 <jle`> > 4 ^. to (+3)
01:29:25 <lambdabot>  7
01:29:40 <jle`> so we're viewing the 4 as if it were (+3) higher, kinda
01:30:04 <jle`> so view (_x . to f) is "view the first field as if it were applied to `f`"
01:30:26 <YellowOnion> > 4 ^. (+3)
01:30:29 <lambdabot>      No instance for (Show a0)
01:30:29 <lambdabot>        arising from a use of ‘show_M528705056801944943718326’
01:30:29 <lambdabot>      The type variable ‘a0’ is ambiguous
01:30:37 <jle`> (+3) is not a Getter
01:30:42 <jle`> to (+3) is
01:31:03 <jle`> view (_x . to f) is the same as f . view _x, essentially...
01:31:15 <jle`> it's "view the first field, but view it as if you applied f to it"
01:32:00 <YellowOnion> Oh I think I get it now
01:32:54 <YellowOnion> f (4 ^._x) is the same as 4 ^._x to f
01:33:06 <jle`> you dropped a dot there, but yeah
01:33:21 <jle`> > preview hex "deadbeef"
01:33:23 <lambdabot>  Just 3735928559
01:33:36 <jle`> > preview (hex . to (+1)) "deadbeef"
01:33:38 <lambdabot>  Just 3735928560
01:34:01 <wordsarewind> :t to
01:34:02 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optical' p p f s a
01:34:12 <jle`> view the string as its hex-encoded number, vs. view the string as its hex encoded number and as if you applied (+1) to that number
01:34:16 <jle`> to :: (s -> a) -> Getter s a
01:36:01 <YellowOnion> is it possible to make that output "deadbeeg" (or what ever the text equiv is)
01:36:09 <jle`> yeah, with over
01:36:24 <jle`> > over hex (+1) "deadbeef"
01:36:26 <lambdabot>  "deadbef0"
01:36:36 <jle`> (over hex) is like an fmap over the hex-encoded value
01:37:13 <YellowOnion> ok that looks like it would with something else I was doing.
01:37:24 <YellowOnion> would help*
01:37:51 <YellowOnion> my brain is hating English
01:45:10 <fr33domlover> is "data Monad m => Action s m = Action ..." considered good practice?
01:45:25 <fr33domlover> as in, should it even be used in code
01:45:49 <fr33domlover> I remember something saying it's was suggested for removal from the language
01:45:56 <jle`> it's considered a bad idea
01:46:30 <jle`> usually the preferred alternative is to just add the Monad constraint to the functions that use Action
01:47:15 <jle`> for example, instead of data Ord s => Set s, we just have functions like insert, member, etc. be things like member :: Ord s => s -> Set s -> Bool
01:48:20 <fr33domlover> jle`, does that also apply to functions that are record members?
01:48:35 * hackagebot MoeDict 0.0.3 - Utilities working with MoeDict.tw JSON dataset  https://hackage.haskell.org/package/MoeDict-0.0.3 (AudreyTang)
01:48:38 <jle`> record accessor functions can be implemented without the constraint
01:48:43 <jle`> they're auto-implemented
01:48:51 <jle`> i'm not sure what you mean exactly though
01:49:56 <fr33domlover> jle`, I mean if a record field it of function type
01:50:24 <fr33domlover> data Monad m => Action s m = Action { apply :: s -> m s }
01:50:33 <jle`> same deal
01:50:50 <jle`> you'd add the constraint to functions that use Action s m's
01:51:18 <fr33domlover> data Action s m = Action { apply :: Monad m => s -> m s }
01:51:21 <fr33domlover> like this?
01:51:33 <jle`> no, i mean, whenever you actually use an Action in your code
01:51:36 <jle`> you'd add the constraint there
01:51:48 <jle`> like, you might want to write a Monoid instance
01:52:26 <fr33domlover> oh I see
01:52:34 <AndChat194889> Korning
01:52:43 <AndChat194889> Morning *
01:52:43 <jle`> instance Monad m => Monoid (Action s m) where mempty = return; mappend a1 a2 = Action $ \x -> apply a2 =<< apply a1 x
01:53:03 <jle`> oneAfterTheOther :: Monad m => Action s m -> Action s m -> Action s m
01:53:18 <jle`> oneAfterTheOther a1 a2 = Action $ \x -> apply a2 =<< apply a1 x
01:53:22 <AndChat194889> 👣
01:53:26 <jle`> the constraint is on the oneAfterTheOther function, not on the type itself
01:53:33 <jle`> morning!
01:54:22 <AndChat194889> Can I entry on the subject
01:55:14 <YellowOnion> jle`, it just occured to me that I could make a lens for this conversion...hmmm.
01:55:29 <jle`> yay :)
01:56:10 <YellowOnion> I have no clue how, but it seems I need a lens for V3 -> Draw.Image
01:56:31 <YellowOnion> from graphics-drawingcombinators
02:04:04 <merijn> fr33domlover: Lemme answer your question by observing that "DatatypeContexts" (the constraint in a data declaration) are, in fact, such a bad idea they were removed from the language altogether in Haskell2010
02:05:05 <merijn> jle`: I think the constraint on the record field requires RankN, though, no? Although RankN is perfectly sensible, unlike DatatypeContexts...
02:06:43 <jle`> not quite RankN, because m is in the constructor
02:06:58 <jle`> but it's also probably not what fr33domlover wanted to do in the first place
02:07:54 <jle`> RankN would be data Action s = Action { apply :: forall m. Monad m => s -> m s }, which is probably not a very useful type
02:07:57 * merijn runs of to try
02:08:33 <merijn> jle`: Nope
02:08:45 <fr33domlover> Indeed I wanted the m to be bound to the one in Action s m
02:08:50 <merijn> Requires RankN with with the original too
02:09:06 <fr33domlover> I'm removing the datatype context
02:09:07 <jle`> hm, but what does the original even mean?
02:09:43 <fr33domlover> I'll just use => where Action is actually used, like jle` said
02:10:41 <merijn> jle`: I'm not quite sure, tbh :p
02:10:51 <jle`> the RankN comes from the constructor, but...
02:13:45 <fred-fri> haskell noob with a stupid question, be gentle http://pastebin.com/r9URxRPj
02:15:13 <jle`> well, ghc has the Natural type, which can only hold positive integers
02:15:26 <jle`> non-negative, that is
02:15:31 <merijn> fred-fri: Easiest solution would be to not export the constructor
02:15:59 <fred-fri> to clarify, im looking for the most correct rather than easiest solution
02:16:04 <jle`> but using Natural is a bit awkward...i haven't found a good use for it
02:16:11 <merijn> fred-fri: And then export a "makePosition :: Integer -> Integer -> Direction -> Integer -> Integer -> Maybe Position"
02:16:13 <jle`> > (-1) :: Natural
02:16:16 <lambdabot>  *Exception: Natural: (-)
02:16:48 <fred-fri> merijn: but wouldnt such a signature allow attempting to call with negative numbers?
02:16:57 <merijn> fred-fri: That is the most correct, if you don't export the constructor and only expect "smart constructors" (i.e. functions with validation) no one can ever create "wrong" values
02:17:02 <merijn> fred-fri: Yes, hence the Maybe result :)
02:17:11 <fred-fri> if possible id like to disallow even attempting to do so
02:17:20 <merijn> fred-fri: That function would have to validate the numbers/upper limits and return Nothing if they're wrong
02:17:43 <merijn> fred-fri: Not possible in Haskell without a ton of hacks, you might wanna look into liquidhaskell
02:18:29 <jle`> would you want to disallow it at compile-time, or at runtime?
02:18:31 <fred-fri> i was under the impression haskells type system was all powerful and allowed a greater share of bugs at compile time
02:19:02 <fred-fri> if i wrote this in java id wrap the bigdecimal class and call that class capital
02:19:02 <merijn> fred-fri: It's more powerful than most languages, but certainly not "all powerful"
02:19:19 <fred-fri> that class would contain the logic for disallowing instantiation of what i deem invalid values
02:19:23 <jle`> if you disallow it at compile-time, you have to sort of limit the things you are allowed to do, becuase it's impossible to resolve arbitrary numbers at compile-time without the possibility of non-terminating compilation
02:19:35 <fred-fri> users would have to instantiate the capital object first before sending it to the position
02:19:44 <merijn> jle`: Unless you sacrifice Turing completeness, because it's overrated anyway :)
02:20:06 <jle`> heh. yeah, i'm saying you can do this, but you sort of limit the range of what you're allowed to say because of this
02:20:58 <fred-fri> yeah but isnt that the point? =)
02:21:09 <jle`> there are ways to do this at compile-time using the haskell type system alone, but generally they revolve around stating things in a way that the compiler can garutnee, and guaruntee that the check itself is terminating
02:21:40 <fred-fri> hm i dont want to terminate though, simply inform the caller that theyre sending invalid arguments
02:21:48 <jle`> yes, but at compile-time?
02:21:49 <dzy> Hey all, I'm new to Haskell (working through Learn a Haskell) and was wondering where to find the implementation of hmap for 2-tuples?
02:21:55 <jle`> what if checking that the argument is positive is non-terminating?
02:22:22 <jle`> what if i called `makePosition (sum [1..]) 4` ?
02:22:31 <jle`> if i wanted to check that it's positive at compile-time, it'd never compile
02:22:53 <fred-fri> jle`: im being a unclear... what id like to do is create a type capital that is really just a Number but with the extra rules id like to add
02:23:05 <fred-fri> id like to use that capital type as the signature for instantiation of positions
02:23:12 <jle`> yeah, in that case you'd use merijn's smart constructor method
02:23:20 <jle`> data Capital = C Integer
02:23:25 <jle`> mkCapital :: Integer -> Maybe Capital
02:23:33 <fred-fri> to signal to the caller that the whole range of numbers and integers arent allowed here
02:23:55 <jle`> and you'd not export `C`, so if a user ever has a `Capital`, it is guarunteed that C contains a positive number
02:24:08 <jle`> mkCapital x | x >= 0 = Just x | otherwise = Nothing
02:24:22 <fred-fri> of course this simply moves the problem to the capital, ie calling capital with -1 i dont care about preventing so much, theyll just get an error back
02:24:35 <jle`> yeah, or in this case they'll get `Nothing`
02:24:53 <jle`> instead of `Just 10`
02:25:15 <fred-fri> what if i wanted to send more info rather than just nothing? ie the equivalent of an exception in java saying "capital must be positive signum and max 10 000" or whatever
02:25:17 <merijn> dzy: What's hmap?
02:25:37 <merijn> fred-fri: "Either String Capital" or "Either MyError Capital"?
02:25:37 <dzy> haha sorry, I meant fmap
02:26:14 <tomasos> I have question regarding testing in general and how I could do it in Haskell. If I have a function 'dieroll' which returns a number between 1 and 6 (dieroll :: Int), is there a nice way to test that this function returns a random number and not the same all the time? I mean I could write a test that is very unlikely to fail (like 10 dieroll calls must no all return the same number). Is that a good soluti
02:26:20 <fred-fri> merijn: string doesnt necessarily imply error info though
02:26:20 <tomasos> on or should I just not test that function?
02:26:27 <jle`> mkCapital x | x >= 0 = Right x | otherwise = Left "capital must be positive"
02:26:36 <tomasos> I know it's not a Haskell only question but I think that there are many good developers here.
02:26:42 <merijn> fred-fri: That's why you can use MyError as error type
02:26:53 <fred-fri> cool
02:27:03 <merijn> Or really, any type
02:27:09 <fred-fri> sorry for asking so nooby questions but trying to wrap my head around this haskell =) as a java dev is tricky
02:27:11 <merijn> "data Either a b = Left a | Right b"
02:27:30 <jle`> in haskell we like to have first-class errors that can be manipulated like normal values
02:27:45 <merijn> dzy: Good question, I figured it'd be Data.Tuple, but no, tbh I think defining fmap for tuples is easier than finding where it is located :p
02:28:04 <jle`> there are some exceptions though
02:28:06 <jle`> ha ha ha
02:28:10 <merijn> dzy: "fmap :: (a -> b) -> (x, a) -> (x, b); fmap f (x, y) = (x, f y)"
02:28:27 <merijn> Hell, that looks like it's probably a free theorem
02:28:39 <jle`> @djinn (a -> b) -> (c, a) -> (c, b)
02:28:39 <lambdabot> f a (b, c) = (b, a c)
02:28:44 <merijn> hmmm, too slow :p
02:28:55 * jle` drops mic
02:28:58 * jle` heads to bed
02:29:21 <ely-se> goodbye
02:29:56 <merijn> I thought new haddock had source links for typeclasses? Why doesn't hackage have those yet? :(
02:30:08 <jle`> goodbye ely-se 
02:30:48 <dzy> merijn: haha ok, thanks!
02:30:51 <jle`> merijn: do you mean for instances?  i've seen them here and there
02:31:32 <merijn> jle`: Not for functor in base, apparently :)
02:31:53 <jle`> yeah, idk why some have them and some don't ><
02:31:54 <lpaste_> guibou pasted “Slow f” at http://lpaste.net/137475
02:32:14 <guillaum1> amazing... So you can help me to optimize this simple piece of code ?
02:32:58 <merijn> guillaum1: I expect order of magnitude speed up by moving to Text and attoparsec
02:33:05 <merijn> guillaum1: String and 'read' are both stupid slow
02:33:20 <guillaum1> merijn: I'll have a look at Text and attoparsec, thank you
02:34:08 <merijn> guillaum1: Keep in mind String is a "linked list of characters" (this can mean it takes as much as 24 bytes PER CHARACTER and has lots of pointer indirections), whereas Text is densely packed unicode
02:34:44 <merijn> As for 'read', it uses a braindead and slow parsing mechanism, attoparsec on the other hand is FAST
02:35:06 <merijn> Not to mention, the attoparsec parser will be easier to maintain/extend :)
02:36:01 <guillaum1> merijn: I'm looking forward to get parsing safety (my first naive implementation was using readMaybe in f and a mapMaybe to filter the incorrect lines, but it was slow as hell...
02:42:26 <merijn> guillaum1: Are you familiar with parsec yet? (Attoparsec is basically the same, but sacrifices some error reporting flexibility for speed)
02:43:13 <guillaum1> merijn: I played a bit with it, but not really.
02:43:40 <guillaum1> merijn: for now I'm trying the Text.Reader interface to get a quick result, then I'll have a look at attoparsec
02:43:55 <merijn> The chapter in Real World Haskell is a pretty good intro (a lot of the code examples have bitrotted, but they high level overview is still accurate and useful)
02:46:40 <cchalmers> guillaum1: another problem minmax isn't strictly walking over the list because tuples aren't strict, so it needs to keep the whole list in memory
02:47:07 <cchalmers> using something like data Coord = Coord !Int !Int should let it run in constant memory
02:47:53 <merijn> cchalmers: Might be easier to just use BangPatterns instead
02:50:00 <deyn> onThreeLines' :: String -> String -> String -> String
02:50:01 <deyn> onThreeLines' a b c = a ++ "\n" ++ b  ++ "\n" ++ c
02:50:05 <deyn> onThreeLines :: IO ()
02:50:07 <deyn> onThreeLines = putStr onThreeLines'
02:50:22 <deyn> can someone explain why this won't work?
02:50:32 <guillaum1> cchalmers: to be honest, the full list will have to stay in memory later, but I'll have a look.
02:50:45 <merijn> deyn: "onThreeLines'" is a function and you're passing it to putStr
02:50:53 <merijn> deyn: putStr wants a String as argument
02:51:32 <deyn> ahh thanks, I'm an idiot...
02:51:44 <fred-fri> merijn jle` what do you think about the accepted answer to this question? it appears to relate to what you explained earlier http://stackoverflow.com/questions/6290712/using-either-in-haskell
02:52:26 <cchalmers> guillaum1: if you need the full list in memory you should an unboxed vector to store coords
02:53:17 <guillaum1> cchalmers: thank you, I'll have a look too.
02:53:18 <merijn> cchalmers: Is there an easy way to parse from attoparsec to an unboxed vector? If not, I wouldn't invest that effort until AFTER switching to Text and attoparsec
02:53:40 <merijn> guillaum1: I wouldn't jump into that directly, I suspect Text+attoparsec might be sufficiently fast already
02:53:54 <catgocat> I understand laziness, but I can't seem to get this: http://lpaste.net/137476 << How does concatMap work here? How does it know what to concat ???
02:54:09 <guillaum1> merijn: I started with Text, I'll have results soon ;)
02:54:14 <catgocat> s/to concat/to concat and map
02:55:42 <merijn> catgocat: "concatMap f" is literally just "concat . map f"
02:55:44 <merijn> :t map
02:55:45 <lambdabot> (a -> b) -> [a] -> [b]
02:55:46 <merijn> :t concat
02:55:47 <lambdabot> Foldable t => t [a] -> [a]
02:56:01 <merijn> :t concat :: [[a]] -> [a]
02:56:02 <lambdabot> [[a]] -> [a]
02:56:07 <merijn> :t concatMap
02:56:08 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
02:56:23 <cchalmers> merijn: currently coords :: [(Int, Int)], if you're going to reuse it, keeping it as a list will be a lot slower and take up much more memory
02:56:28 <merijn> Why would it need to know "what to concat"?
02:56:32 <merijn> It just concats every single list...
02:56:45 <merijn> cchalmers: Which may, or may not be problem
02:57:03 <merijn> cchalmers: Whereas String and 'read' are DEFINITELY problems :)
02:57:51 <catgocat> merijn: I know..
02:57:54 <Cale> catgocat: Note that the first few elements of sequence will just be elements of strings
02:58:21 <Cale> catgocat: so by the time it gets past that point, the first few elements will have been determined, so concatMap will have no trouble pattern matching on sequence
02:58:29 <catgocat> Cale: I also get that, I don't understand is how the recursion works there
02:58:37 * hackagebot Spock 0.7.12.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.7.12.0 (AlexanderThiemann)
02:59:12 <Cale> Maybe try evaluating stringSequence "ab" by hand
02:59:13 <esimp> For documentation, I have to generate some data-flow/block diagrams from my haskell code.  Is there a haskell package to generate a 'dot' diagram?
02:59:39 <catgocat> ok
03:00:04 <kuribas> I noticed Data.Set.toDescList is defined in terms of foldl.  Doesn't that make it unnecessary strict?
03:00:43 <Cale> kuribas: quite possibly, yes
03:01:20 <kuribas> since "head . Data.Set.toAscList would be O(log n)", but "head . Data.Set.toDescList " would be O(n)
03:01:46 <kuribas> why didn't they implement reverseFolds or efficient toDescList?
03:02:12 <guillaum1> merijn: ok, from String to Text I get a 25% improvment. But my f function is still convoluted and use Data.Text.Read which may not be the solution. I'll have a look at attoparsec now.
03:02:57 <esimp> ...nevermind, the SourceGraph seems to do what I need :-)
03:04:00 <kuribas> I can repeatedly to deleteFindMax, but that seems less efficient.
03:04:01 <catgocat> Cale I still dont get it, I ended up writing something like
03:04:21 <merijn> guillaum1: Like I said, give the Real World Haskell chapter on Parsec a read too, it should give you a useful highlevel overview on what a (atto)parsec parser would look like
03:04:22 <catgocat> a b ++ cc [ a b ++ cc [ ...
03:04:43 <kuribas> Cale: should I send a patch?
03:04:54 <catgocat> it never reaches a point where the "bracket" closes
03:06:42 <Cale> kuribas: Oh, it doesn't use the list foldl somehow, it uses the Map function foldlWithKey of course.
03:07:10 <Cale> kuribas: Both foldlWithKey and foldrWithKey have similar properties as far as laziness is concerned (look at their implementation)
03:07:32 <kuribas> Cale: but toDescList still builds the list in the wrong order?
03:07:45 <kuribas> Or did I miss something?
03:07:46 <Cale> hm?
03:07:57 <Cale> toDescList :: Map k a -> [(k,a)]
03:07:57 <Cale> toDescList = foldlWithKey (\xs k x -> (k,x):xs) []
03:08:02 <Cale> Is what I'm seeing
03:08:28 <Cale> @src concatMap
03:08:29 <lambdabot> concatMap f = foldr ((++) . f) []
03:08:33 <Cale> @src concat
03:08:33 <lambdabot> concat = foldr (++) []
03:09:00 <Cale> catgocat: well, okay, let's imagine this concatMap then (which is equivalent to the real one)
03:09:10 <Cale> concatMap f [] = []
03:09:21 <Cale> concatMap f (x:xs) = f x ++ concatMap f xs
03:09:49 <kuribas> Cale: you're looking at Map?
03:09:49 <Cale> catgocat: See how it doesn't need to know the entirety of the list before it can start doing work
03:09:54 <Cale> kuribas: yeah
03:09:57 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers/src/Data-Map-Base.html#toDescList
03:10:05 <catgocat> yeah I understand how that works
03:10:11 <catgocat> f x ++ f x ++ f x ...
03:10:29 <Cale> > concatMap (\x -> [x]) [1..]
03:10:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:10:33 <kuribas> Cale: Data.Set has "toDescList = foldl (flip (:)) []"
03:10:33 <kuribas>  
03:10:43 <Cale> catgocat: Is it clear enough why this works even though the list is infinite?
03:10:44 <catgocat> but what if the recursion happens after concatMap
03:10:52 <catgocat> yeah Cale
03:10:54 <kuribas> Cale: so to get the first element, it has to walk the whole tree.
03:11:02 <Cale> kuribas: oh, sorry
03:12:22 <Cale> kuribas: Look at foldl vs. foldr for Data.Set
03:12:31 <Cale> https://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Set-Base.html#foldr
03:12:40 <Cale> they're perfectly symmetrical
03:13:51 <Cale> catgocat: Okay, so maybe a simpler example...
03:14:05 <Cale> > let xs = [1,2,3] ++ xs in xs
03:14:05 <catgocat> Cale: I understood that example
03:14:06 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
03:14:14 <Cale> No problem, right?
03:14:22 <catgocat> Cale: but I don't see how it works when the recursion happens in an argument of concatMap
03:15:10 <Cale> > let xs = [1,2,3] ++ concatMap (\x -> [x,10*x]) xs in xs
03:15:12 <lambdabot>  [1,2,3,1,10,2,20,3,30,1,10,10,100,2,20,20,200,3,30,30,300,1,10,10,100,10,100...
03:15:26 <Cale> maybe that's not the best example function...
03:15:39 <kuribas> Cale: it's not...
03:16:14 <Cale> > let xs = [1] ++ concatMap (\x -> [x+1,x*10]) xs in xs
03:16:17 <lambdabot>  [1,2,10,3,20,11,100,4,30,21,200,12,110,101,1000,5,40,31,300,22,210,201,2000,...
03:17:11 <Cale> You can more easily keep track of where each element came from with that one :)
03:17:25 <Cale> (at least for the early portion of the list)
03:17:29 <catgocat> what..
03:17:38 <Cale> So, our list xs starts out with 1
03:17:51 <Cale> and that's followed by concatMap (\x -> [x+1,x*10]) xs
03:18:05 <catgocat> can you give me like a code-like example ?
03:18:13 <Cale> So, we know the next two elements are obtained by adding 1 to 1, and multiplying 1 by 10
03:18:21 <Cale> So xs starts out 1,2,10
03:18:25 <catgocat> something like , for x = 1 + x, x = 1 + 1 + 1 + 1 ..
03:18:42 <Cale> and then the next two elements are produced by (\x -> [x+1,x*10]) 2
03:18:53 <Cale> (2 being the second element of the list as we've already determined)
03:19:01 <Cale> i.e. they're 3 and 20
03:19:07 <catgocat> I think I'm getting it
03:19:21 <Cale> and then the next two elements are produced by (\x -> [x+1,x*10]) 10
03:19:28 <Cale> which gives us 11 and 100
03:21:05 <Cale> Have you ever seen this:
03:21:23 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:21:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:21:49 <Cale> No concatMap, but it's a similar idea, with a list being constructed recursively in terms of itself
03:21:56 <catgocat> I am lost after 1 and 2 though
03:22:03 <catgocat> how does 11 show up there?
03:22:12 <catgocat> I suppose is by 10 + 1
03:22:13 <Cale> 11 is 10 + 1
03:22:16 <catgocat> but I don't see where that happens
03:22:16 <Cale> yeah
03:22:17 <kuribas> Cale: hm, I think I get it...  z' if evaluated lazily right?
03:22:41 <Cale> catgocat: Well, (\x -> [x+1,x*10]) is being applied to each of the elements of xs and the results are being concatenated to form xs
03:23:32 <YellowOnion> is there a better way to do (Ord a, Floating a, Num a)?
03:23:37 <Cale> kuribas: Yeah
03:23:48 <kuribas> Cale: ok I see, thanks!
03:23:59 <Cale> kuribas: But it *does* have to blast through the whole tree structure
03:24:20 <kuribas> Cale: which is log(n)
03:24:25 <Cale> kuribas: Until it reaches a Tip at least.
03:24:26 <Cale> yeah
03:24:55 <kuribas> Cale: of course, because log(1) (head $ toAscList) is impossible
03:25:13 <Cale> Impossible for this representation, anyway
03:25:27 <kuribas> yeah
03:25:39 <Cale> YellowOnion: You can leave out the Num a
03:25:48 <Cale> YellowOnion: Because Floating is a subclass of Num
03:25:56 <catgocat> and why does [1] get applied over and over?
03:26:05 <catgocat> since it is being appended
03:26:09 <Cale> catgocat: Well, it doesn't really...
03:26:12 <catgocat> sorry, why doesnt
03:26:26 <Cale> catgocat: 1 is just the first element of the resulting list
03:26:42 <Cale> We use it when we apply (\x -> [x+1,x*10]) the first time
03:26:45 <catgocat> but since it is the first element of `xs` and concatMap goes over `xs`
03:26:49 <catgocat> shouldn't xs include [1] ?
03:26:52 <Cale> but from then on, we're using other elements of the list
03:27:00 <Cale> Indeed it does
03:28:04 <YellowOnion> Cale, where would I find a list of type classes so I can find the one I need, currently ghc is just recomending me a lot of different ones.
03:29:20 <Cale> YellowOnion: Well, which operation do you need? You can ask for its type
03:29:56 <Cale> YellowOnion: You can get documentation on the Prelude type classes from here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Prelude.html
03:30:20 <Cale> (the instance lists are kind of obnoxiously long, unfortunately)
03:30:58 <Cale> https://www.haskell.org/onlinereport/basic.html includes a diagram of basic Prelude classes and their interrelationships
03:31:03 <YellowOnion> my function was V2 Float -> V2 Float I want to generalise it
03:31:16 <sinelaw> Hi, is there a standard "dual" applicative of Maybe? such that Nothing >> Just x >> Just y .... would return "Just x"?
03:31:40 <YellowOnion> I tried V2 a -> V2 a but then a bunch of type class errors came up.
03:31:41 <sinelaw> I know I can use a flipped Either
03:36:02 <sinelaw> in other words: Maybe a  is like Either () a, so what is like Either a () ?
03:36:25 <Cale> sinelaw: Do you really mean  Nothing >>= (\a -> Just x >>= (\b -> Just y))  ?
03:36:25 <AshyIsMe> um, wow
03:36:36 <AshyIsMe> 2gb ram is not enough to "stack install ghc-mod"
03:36:50 <Cale> Because in that case, what happens to   Nothing >>= (\a -> Just a >>= (\b -> Just y)) ?
03:36:52 <sinelaw> Cale, yes, just a silly example
03:37:26 <sinelaw> Cale, I'm assuming the types match; my point is that I want it to continue the computation on Nothing and stop on Just
03:37:54 <Cale> sinelaw: I think you're just looking for mplus and or Alternative with <|>
03:38:09 <Cale> > Nothing `mplus` Just 1 `mplus` Just 2
03:38:11 <lambdabot>  Just 1
03:38:18 <sinelaw> Cale, thanks
03:38:19 <Cale> > Nothing <|> Just 1 <|> Just 2
03:38:20 <lambdabot>  Just 1
03:38:24 <sinelaw> that's exactly what I want.
03:59:01 <sinelaw> Cale, is there a type like Maybe where the roles of <|> and >>= are flipped?
04:02:27 <longBack_> ghc 7.10.2 cant build hoogle
04:04:18 <Cale> sinelaw: I don't think it makes sense
04:04:38 <sinelaw> Cale, as I mentioned earlier, Either () a vs. Either a ()
04:04:48 <sinelaw> that one exists because Either has two type parameters
04:05:05 <sinelaw> why wouldn't it make sense?
04:05:07 <Cale> sinelaw: Like, what becomes the argument to the function with  Nothing >>= (\x -> ...) ?
04:05:31 <sinelaw> I guess it would have to be a monoid
04:05:35 <sinelaw> the type parameter
04:05:44 <sinelaw> or default, or whatever
04:05:46 <Cale> Well, maybe in that case...
04:06:08 <sinelaw> if it's a monoid, you could also imagine one where Just's are mappended
04:06:21 <sinelaw> but I'm talking about one where the first Just shortcuts
04:06:27 <Cale> There might be some monad on the category of monoids or something... I'm still not sure it'd satisfy the monad laws.
04:11:12 <dadada> hi, I'm interested in haskell, but only have some rudimentary knowledge/ideas about it from presentations I saw on youtube etc., I'm thinking it might be cool to write a whole new GUI library, desktop environment, 3d game, stuff like that in haskell... but then I saw some examples where haskell was slow (http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs
04:11:18 <dadada> -haskell), so I wonder is haskell a usable for projects that are traditionally writting in imperative languages and have a high need for speed/efficiency?
04:12:16 <dadada> for example, let's say I wanted to write a modern 3d engine completely in haskell, could I expect performance anywhere near other modern engines?
04:14:03 <Axman6> dadada: Facebook seems to think Haskell is pretty fast - every user even is processed through a haskell based anti-spam system called Sigma which is now written in Haskell. Handles 1,000,000 requests per second
04:14:18 <Axman6> event*
04:14:31 <Intolerable> also that SO question has awful haskell code
04:14:32 <tzaeru> dadada, majority of stuff in modern 3d engines tends to take place in the GPU.
04:14:34 <Axman6> hmm, I must be tired, I'm repeating myself
04:14:44 <Intolerable> the top answer is "it's as fast as C for this problem"
04:14:56 <tzaeru> very few things are particularly CPU intensive and are more dependant on the game itself and game requirements rather than the game engine alone.
04:15:06 <Intolerable> that said, its a misleading benchmark
04:16:13 <Axman6> dadada: my point is, yes, Haskell can be fast enough to do those tasks
04:16:35 <dadada> Intolerable: I was just giving this as an example, I'm not endorsing the benchmark :_)
04:16:50 <Intolerable> fair enough
04:17:26 <Intolerable> (in my experience) it's not particularly slow
04:17:34 <dadada> keep in mind I'm an amateur so don't get annoyed with me quickly :-)
04:17:46 <Intolerable> and if you're doing something and need more speed, you can easily write something mutable / in ffi
04:17:58 <dadada> let's say I've a 3d game with 1000s of characters in a world
04:18:05 <dadada> those characters walk around and do things
04:18:21 <dadada> in a traditional language they are represented by something like a class
04:18:30 <Axman6> people are more annoyed with (others) using posts like that as examples of Haskell being slow. #haskell is a very beginner friendly place to me - ask a question, you'll almost certainly get 1 or many useful answers
04:18:55 <dadada> and when they walk their coordinates change with them, so one or more values in the class are changed
04:19:01 <dadada> but in haskell apparently values aren't mutable
04:19:11 <Intolerable> aren't mutable *by default*
04:19:19 <Axman6> Intolerable: shh
04:19:33 <dadada> so you would need to "add" a new value to change the old value every time thus creating a lot of overhead?
04:19:37 <Maxdamantus> it seems weird to me to talk about "mutable values"
04:19:50 <Axman6> telling people that makes them search for familliar solutions, rather than learning =)
04:19:55 <Intolerable> if you need the performance, it's simple to have something be mutable
04:19:59 <Maxdamantus> values would be something like the number 4 or the address of an object.
04:20:10 <Maxdamantus> what does it mean to change the number 4?
04:20:29 <Maxdamantus> 4 = 5 -- now 2 + 2 = 5
04:20:37 <dadada> I mean, changing the coordinates of the "object", changing their value
04:20:55 <Intolerable> Axman6: i'd normally agree, but this is someone who wants high-performance modification
04:21:16 <Maxdamantus> you mean changing what values are stored in a coordinates object?
04:21:24 <Intolerable> put it this way
04:21:30 <dadada> yeah, you could put it that way
04:21:32 <Intolerable> i had a prototype emulator
04:21:32 <merijn> I would say that writing high performance video games in haskell is tricky business and not something I would recommend to absolute beginners
04:21:39 <Intolerable> which initially used immutable state
04:21:46 <dadada> merijn: it's a theoretical question
04:21:47 <Intolerable> and when that got a little too slow
04:21:56 <Axman6> Intolerable: performance is something that should be dealt with when it becomes a problem, unless the system specifically needs absolute performance (not many do, high frequency trading is one of the few that comes to mind)
04:22:02 <Intolerable> i switched it to mutable state
04:22:13 <Intolerable> in about 3 hours
04:22:28 <merijn> dadada: It's certainly possible to write video games as an experienced haskeller. Cale was working on a video game for iOS in haskell, although they stopped because they ran out of funding, but I heard it worked well
04:23:16 <maerwald> sounds like it took longer than expected then?
04:23:17 <Axman6> merijn: yeah the demos I saw of that game were pretty cool - shame to hear about the funding, I had several friends working on that
04:23:39 <Axman6> maerwald: soing something no one has ever done before often does =)
04:23:41 * hackagebot fast-builder 0.0.0.1 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.1 (AkioTakano)
04:23:41 <dadada> merijn: it would be very interesting to have a howto / walkthrough on even a simple efficient 3d game in haskell "done right", meaning done as power/performance/memory efficient as possible, while also using the haskell advantages
04:23:53 <merijn> maerwald: Yeah, I mean, cross-compilation was more brittle back then, and there's no libraries yet
04:24:22 <merijn> dadada: Ask Cale when he's around (not sure if it was 3d), they're stuff was based on FRP
04:24:27 <merijn> *their
04:24:32 <dadada> FRP?
04:24:41 <merijn> dadada: Functional Reactive Programming
04:24:43 <merijn> @where frp
04:24:43 <lambdabot> I know nothing about frp.
04:24:44 <merijn> hmmm
04:25:00 <maerwald> Axman6: afaik FRP based gaming has been done before
04:25:09 <merijn> dadada: This is a good intro paper on FRP: http://conal.net/fran/
04:25:47 <Axman6> maerwald: not on iOS using Haskell though
04:25:51 <merijn> And http://conal.net/papers/push-pull-frp/
04:25:52 <maerwald> that might be true
04:26:16 <merijn> @where+ frp http://conal.net/fran/ http://conal.net/papers/push-pull-frp/
04:26:16 <lambdabot> Nice!
04:27:44 <merijn> dadada: Personally I think that if you want to do something AAA 3d like the best approach would be to use an existing C/C++ engine like Unreal/Source2/Unity/whatever and than use the FFI to write gameplay/world code in haskell
04:27:54 <dadada> I just wonder if anyone is working on an innovative "desktop environment" with OpenGL rendering written in haskell
04:28:04 <merijn> You could do everything in haskell, but I'm not sure it's worth it
04:28:13 <Cale> maerwald: Well, it was about as much an experiment as it was a business venture. We did spend quite a lot of time getting the FRP system right, but it was rather nice to use. Ryan Trinkle (my boss) has gone on to develop Reflex using similar ideas, and that's getting used in production now.
04:28:19 <merijn> dadada: It's on my long-term "I will never get to this" todo list :)
04:28:24 <Cale> (though not for games)
04:28:29 <Cale> (yet)
04:29:31 <Axman6> hmm, this looks interesting - I'd be interested to some benchmarks: https://hackage.haskell.org/package/fast-builder-0.0.0.1/docs/Data-ByteString-FastBuilder.html
04:29:36 <dadada> merijn: I agree, but the real reason that it's really hard to write a competitive new engine in any language, so it's better to start with something existing and work on top of that
04:29:52 <Axman6> claims 2x-10x speed improvements over Data.ByteString.Builder
04:30:23 <merijn> dadada: Sure, but I would say that soft-realtime applications like games are probably not one of haskell's strongest sides :)
04:30:24 <dadada> merijn: but it might be that IF someone did go through that fundamental challenge that the inherit advantages of procedural/functional programming might lead to new innovations?!
04:30:58 <merijn> dadada: There's a lot of innovations than can be applied to gaming, Tim Sweeney (from Epic) had a nice talk on "the next big programming language"
04:31:15 <Cale> We got the action RPG to the point where you could run around in a big open world (which was mostly empty of AIs, but had lots of terrain and props and stuff), and we had a few melee and ranged combat AIs which were reasonably fun to fight against, but we still needed to do a lot of the rest of the stuff which you'd imagine would go into an action RPG
04:31:23 <merijn> Slides here: https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
04:32:02 <Axman6> Cale: any chance any of the work will be open sourced?
04:32:19 <Axman6> (apart from the iOS stuff, which IIRc is already?)
04:32:21 <dadada> Cale: any chance you can release some of the code as open source or write a few tutorials based on what you learned?
04:32:21 <Cale> Axman6: I don't know how much of it even builds at this point, but you'd want to ask Ryan about that
04:32:31 <dadada> Axman6: beat me to it
04:33:28 <maerwald> I doubt we will see a breakthrough of gaming in haskell at all. Mainly because it's hard enough to find haskell developers, but even harder to find someone who has done haskell game development. Companies who develop games are mostly short on money and time and don't have time for "elegant solutions".
04:33:53 <peddie> dadada: John Carmack had some pretty positive comments about Haskell in one of his QuakeCon talks
04:34:00 <maerwald> that was a while ago
04:34:04 <merijn> Yeah
04:34:05 <dadada> maerwald: sounds like an ideal scenario for an open source project of enthusiasts
04:34:18 <Axman6> yeah I believe he's been using Haskell quite a lot in recent years
04:34:26 <maerwald> dadada: all that will achieve is better jobs for those guys, look at openmw
04:34:35 <merijn> I don't think haskell will ever become a big game language, but I do think there's a lot of important lessons to learn from haskell for game programmers
04:34:39 <Axman6> dadada: go forth and reserrect Frag =)
04:34:41 <Axman6> @where frag
04:34:41 <lambdabot> http://www.haskell.org/haskellwiki/Frag
04:34:59 <merijn> Both Sweeney and Carmack seem convinced the next big gaming language will be more like haskell than what they're using now
04:35:08 <Cale> Frag was written in like 1 weekend :D
04:35:18 <Axman6> heh really?
04:35:24 <merijn> Carmack seems to be doing Scheme now, he was thinking of using Scheme/Racket for their VR headset's scripting language
04:35:26 <Axman6> I thought it was a bigger effort than that
04:35:40 <Cale> Axman6: Well, it's using q3a resources
04:36:03 <Cale> At least, I remember dons saying something along those lines. Might've been a week or something
04:36:06 <YellowOnion> Anyone here familiar with verlet/leafrog integration? I can't figure out why my system is losing momentum.
04:36:10 <Axman6> edwardk might have something to say about this, he's been doing some really cool stuff with OpenGL and iirc ray tracing
04:36:31 <Cale> and apparently it was Mun Hon Cheong's first Haskell project
04:36:48 <Axman6> YellowOnion: it needs more motivation! Tome for a Team Building Exercise!
04:36:50 <ww> YellowOnion: somewhat
04:36:50 <Cale> at least, if my memory serves me :)
04:36:51 <Axman6> Time*
04:37:12 <merijn> dadada: Of course, when you're not wanting to write FPS or other twitchy games, but for example turn based or strategy/civ games, then Haskell suddenly becomes a ton more feasible
04:37:16 <YellowOnion> Axman6, :P
04:37:45 <YellowOnion> ww, I'll past my code.
04:38:23 <lpaste_> YellowOnion pasted “Integrator” at http://lpaste.net/137479
04:38:29 <kuribas> merijn: how good is haskell for realtime performance?  Like rendering a complex scene in as little FPS as possible?
04:38:38 <ww> I'm also interested in collecting stories about using functional languages for numerical work, to motivate getting a proper environment on archer.ac.uk, incidentally
04:38:42 <dadada> merijn: my main thoughts center around this, sorry if I begin to sound really crazy now
04:38:56 <dadada> we haven't seen any real GUI innovations since the 80s
04:39:03 <YellowOnion> ww, http://lpaste.net/137479
04:39:04 <dadada> that's my opinion, it's all just incremental steps
04:39:12 <merijn> kuribas: I think the problem with haskell for soft-realtime isn't throughput, but jitter
04:39:16 <dadada> but all those toolkits are basically inflexible
04:39:30 <Intolerable> gc?
04:39:35 <merijn> dadada: Writing an FRP based GUI toolkit would be awesome
04:40:03 <dadada> and it annoys me that the desktop "enviroment" isn't really a place where information can be "manipulated"/"viewed"/"combined" in flexible ways
04:40:07 <kuribas> merijn: yes, each frame must be rendered in approximately the same time.
04:40:12 <merijn> dadada: I started with that, but hit a bug (now fixed) and haven't gotten back to it. I'd <3 you forever if you design and implement a nice functional FRP based GUI environment :)
04:40:14 <YellowOnion> kuribas, don't you want most fps as possible?
04:40:22 <maerwald> @hackage FRPNow
04:40:22 <lambdabot> http://hackage.haskell.org/package/FRPNow
04:40:28 <kuribas> YellowOnion: yeah, right!
04:40:30 <maerwald> @hackage FRPNow-GTK
04:40:30 <lambdabot> http://hackage.haskell.org/package/FRPNow-GTK
04:40:38 <merijn> dadada: It's certainly not an unreasonable idea
04:40:40 <maerwald> uh er
04:40:50 <maerwald> https://github.com/atzeus/FRPNow
04:41:02 <broma0> Does anyone know of a talk online somewhere discussing the relationships and hierarchy of haskells standard type classes?
04:41:03 <dadada> I think with OpenGL and with a more information centric approach and a "free flowing" GUI where there's NOT the concept of APPs, but the concept of interacting informational/elements you could have a whole new paradigm of using your computer
04:41:08 <kuribas> ww: I am writing a library for manipulating bezier curves: https://github.com/kuribas/cubicbezier
04:41:11 <dadada> I know it sounds crazy ;-)
04:41:29 <maerwald> I don't want opengl on my desktop
04:41:56 <YellowOnion> kuribas, People are using Mono/dotNet and Java for games these days, just got to be careful about how you use data, so garbage collection isn't an issue.
04:42:20 <kuribas> ww: I think haskell is great for numerical computing, but existing languages lack portability, they all have their own incompatible data structures.
04:42:22 <merijn> dadada: Sounds a lot like some of Conal's ideas that inspired FRP
04:42:30 <maerwald> YellowOnion: I know a few developer from OpenRA (written in C#) and they regret the decision of using C# somewhat
04:42:37 <dadada> maerwald: it's just a way of rendering graphics using your GPU not more, rendering graphics using CPU is DUMB, sorry
04:42:41 <kuribas> YellowOnion: So if Java works for games, then I'd say haskell should work too.
04:42:52 <merijn> dadada: I would highly recommend reading the earlier links I send you and http://conal.net/papers/Eros/
04:43:06 <ww> YellowOnion: that doesn't look unreasonable to me -- actually it's nice and succinct :)
04:43:17 <YellowOnion> Kerbal Space Program had a pretty good halt every few seconds with the garbage collection.
04:43:46 <kuribas> ww: if you look at hackage, how many ways there are to get a 2D matrix... In Octave or Julia (and maybe numPy) there is just one.
04:43:47 <maerwald> dadada: what graphics is there to render?
04:43:47 <lamefun> how to get rid of repitition when defining newtypes? http://lpaste.net/5955146230928506880
04:43:56 <maerwald> I don't want fancy graphics on my desktop
04:44:32 <maerwald> sounds like you want some next generation window compositing thing
04:44:39 <maerwald> I think that's a dead end
04:44:43 <dadada> maerwald: everything you see on your screen right now is some sort of "graphic", it has nothing to do with "fancy"
04:44:54 <YellowOnion> ww, my code? yeah it looks nice but my objects don't stay in orbit :(
04:45:00 <Axman6> lamefun: what's the problem?
04:45:01 <hodapp> kuribas: Given that Octave and Julia are languages oriented around numerical computation, and NumPy is not a language but a specific Python library, I'm not sure that's really a meaningful comparison.
04:45:06 <maerwald> dadada: the cpu time required to render that is so minimal that no one really cares
04:45:09 <lamefun> Axman6, the repetition.
04:45:27 <kuribas> hodapp: but numPy is pretty much the standard library for numerical work, right?
04:46:04 <dadada> maerwald: I don't really care what you think no one cares about
04:46:09 <peddie> @where typeclassopedia  -- broma0 
04:46:10 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:46:10 <ww> kuribas: yes, that's true, but i'm kind of after a higher level than that -- scientific questions being answered using FP techniques rather than basic operations
04:46:59 <ww> YellowOnion: do you adapt dt? or is it fixed?
04:47:07 <YellowOnion> ww, fixed
04:47:12 <broma0> peddie, reading that now actually. I was looking for a supplemental video
04:47:13 <kuribas> ww: you mean like composing abstractions in terms of low level libraries?  Data.Vector does that.
04:47:21 <Axman6> lamefun: my immediate though (which is horrible) is to use CPP: #define MKTEXTTHING(name, predicate,classes) data name = name {un#name :: Text} deriving classes; mk#name ...
04:48:01 <Axman6> lamefun: but I have a string feeling that won't work, string concatenation in Haskell code using CPP is broken somehow (for fairly fundamental reasons)
04:48:10 <Axman6> lamefun: time to learn TH =)
04:48:22 <peddie> broma0: sorry, not aware of one
04:48:37 <maerwald> dadada: I'm confused why you share your opinion publicly then if you don't care about other peoples opinions (or get defensive when someone mentions his opinion)
04:48:53 <dadada> maerwald: let me explain this in more detail if you wish
04:49:08 <maerwald> not sure if I care anymore
04:49:28 <dadada> maerwald: my problem was your use of the phrase "no one"
04:49:39 <dadada> maerwald: you extrapolate from your perspective to everyone else
04:49:43 <kuribas> ww: you cannot have higher level abstractions without a good lower level interface.
04:49:52 <kuribas> ww: which is kind of lacking.
04:49:56 <peddie> broma0: you could check out lectures on Functor, Applicative and Monad from the Brisbane FP Group at https://github.com/bfpg/cis194-yorgey-lectures
04:50:08 <peddie> broma0: not sure about talks on some of the other type classes
04:50:17 <kuribas> ww: though a lot of interesting work is done with accelerate, repa, etc...
04:50:18 <ww> kuribas: yes, but who is simulating what systems in that way -- it's clear to me that it might be a good idea to do things like that, but they're interested in "what new scientific communities would a haskell compiler bring to the supercomputer facility"
04:51:17 <ww> YellowOnion: so if you make dt smaller, you lose momentum less quickly, right?
04:51:43 <maerwald> dadada: I don't know anyone who cares. I thought that the nature of my generalization is clear from the context.
04:51:47 <dadada> maerwald: when I know there's a large portion of people that do care about this and that do think it's sensible to render everything by the GPU, that's why it's done this way on Mac, Windows and the modern Linus DEs, it brings additional advantages besides compositing, it does save CPU time for where it's needed, it allows for quicker and more complex operations, and can't even count the advantages, so I w
04:51:53 <dadada> on't go into this and recommend you read up on it, but you can keep YOUR opinion that it has no advantage for YOU and you don't care about minimal CPU waste and maybe there are others like you
04:52:20 <maerwald> dadada: that's just because they have fancy graphics
04:52:31 <dadada> we are going in circles now
04:52:35 <dadada> I've no interest in this
04:52:51 <YellowOnion> ww, trying with 1/10 the size
04:52:53 <maerwald> and I'm not sure why you call those DEs "modern"
04:53:07 <dadada> I don't mean the DEs
04:53:22 <dadada> I meant the "display servers"
04:53:35 <dadada> if that's the correct term
04:53:35 <YellowOnion> ww, ok looks like it was maybe just that, stupid me.
04:54:27 <maerwald> dadada: we still have xserver, if you mean that
04:54:28 <ww> if you let it run longer, it'll still diverge... only more slowly
04:54:32 <maerwald> and it's nowhere near modern
04:54:53 <maerwald> and still runs fine (although the code is horrible)
04:55:10 <dadada> maerwald: yes, but I meant one specific part of it and that was kind of modernized recently, certainly wayland goes into the right direction, but please not digressions
04:55:27 <dadada> I think you know what I meant, otherwise we can go in circles of course, no interest in that
04:55:29 <maerwald> wayland will need another 5-10 years to break through in Linux, not sure about other OS
04:55:47 <maerwald> I just think that's micro-optimization, not a breakthrough
04:55:52 <ww> it is possible to calculate what timestep will give you what error margin. that will change depending on the configuration of the system. adaptive timestep methods will change the timestep accordingly, mostly for efficiency since you don't want to use too small a timestep when a larger one would do.
04:55:56 <dadada> the next gnome release will probably work in wayland
04:56:18 <maerwald> dadada: I mean until the linux eco system has largely switched to wayland it will take a long time
04:56:43 <dadada> maerwald: KDE/gnome worlds are the two large parts of the GUI linux worlds and they ARE currently transitioning
04:56:50 <maerwald> I know
04:56:54 <dadada> so it will be a while until it's perfect, but not 5-10 years
04:56:54 <peddie> YellowOnion: https://hackage.haskell.org/package/hmatrix-gsl-0.16.0.3/docs/Numeric-GSL-ODE.html
04:56:58 <dadada> more like 2 years IMO
04:57:04 <kuribas> dadada: what does it give besides eye candy?
04:57:11 <dadada> kuribas: what do you mean?
04:57:20 <maerwald> dadada: I don't think they will switch really, they will add wayland support
04:57:22 <dadada> why are we going into all those digressions?
04:57:35 <dadada> maerwald: again, you know what I mean
04:57:44 <maerwald> dadada: but again: my point was "micro-optimization, not a breakthrough"
04:57:46 <dadada> is it normal that people are splitting words in here
04:57:53 <kuribas> dadada: I don't see what problem rendering UIs on the GPU is trying to solve.
04:57:57 <maerwald> dadada: you started it ;)
04:58:10 <dadada> maerwald: NO YOU STARTED IT! :_)
04:58:17 <maerwald> glad we agree
04:58:26 <kuribas> dadada: it's not that rendering a UI is such a performance heavy problem.
04:58:41 <maerwald> exactly
04:58:57 <maerwald> I was about to say "there are better ways to spend your time" :P
04:58:58 <kuribas> But the GPU has advantages for realtime rendering such as vector graphic applications.
04:59:14 <kuribas> like inkscape
04:59:17 <dadada> kuribas: there are many corner cases where it helps a lot and even if you can optimize perfomance I a little it helps a lot, think about battery usage for example
04:59:34 <ww> peddie: gsl's ode integrator is not great... 
04:59:42 <kuribas> dadada: the GPU also needs power.
04:59:43 <ww> a really useful project would be bindings to cvode...
04:59:45 <peddie> ww: what's wrong with it?
05:00:07 <peddie> ww: I am 95% done SUNDIALS bindings right now, but I've rarely had any trouble with GSL's integrators
05:00:19 <ww> it's pretty basic... and not so good for stiff systems
05:00:23 <peddie> and in particular, they're heaps better than someone's hand-rolled forward Euler scheme
05:00:26 <ww> peddie: re: sundials, very cool!
05:00:27 <dadada> kuribas: the GPU runs anyhow, it's rendering to the screen anyhow, the CPU is just an extra inefficient steps, where the GPU has more optimized thus less power hungry pipelines for the same things
05:00:34 <ww> peddie: well yes, of course
05:00:41 <dadada> kuribas: I've no interest in educating you, all I can tell you is this
05:00:43 <peddie> ww: which one?  msadams and bsimp have seved me well
05:01:00 <dadada> kuribas: I've written a 2d platformer, that had both a software and a opengl renderer written by me
05:01:10 <maerwald> dadada: so if this is a mobile device thing, then it might make sense. do we know that it actually improves battery performance or is this a guess?
05:01:14 * ww afk
05:01:20 <peddie> ww: I agree that rkf45 and rkck are not so good on stiff systems, but GSL provides decent stiff integrators . . .
05:01:24 <peddie> ok adios :)
05:02:29 <dadada> kuribas: the difference it made to the smoothness of 2d grahics is very visible and the cpu usage dropped from 100% to 0%, it's definitely worth it to render 2d with an optimized pipeline, you also don't want to decode mpeg and stuff like that with the cpu, at least not without optimized instructionsets or the graphics card as a "helper"
05:02:31 <YellowOnion> peddie, Thanks, but half the reason I wrote this was to do it myself.
05:02:41 <dadada> kuribas: think of the graphics card as a "helper tool"
05:02:43 <kuribas> dadada: in games, sure.
05:03:18 <peddie> YellowOnion: OK, as you like . . . you may want to look at some of those methods for inspiration, though, they'll work a lot better than forward Euler ;)
05:03:26 <dadada> maerwald: it's not a guess
05:03:31 <kuribas> UI's are probably already accelerated to some extend (copying bitmaps...)
05:03:42 * hackagebot probable 0.1.1 - Easy and reasonably efficient probabilistic programming and random generation  https://hackage.haskell.org/package/probable-0.1.1 (AlpMestanogullari)
05:04:10 <YellowOnion> peddie, am I using forward euler? coz I was reading the wikipage for verlet integration.
05:04:17 <dadada> kuribas: GTK3 Qt4/qt5 and the windows/mac counterparts are nowadays rendered with the gpu
05:04:24 <dadada> kuribas: that's what it's about
05:04:49 <dadada> kuribas: also iOS and android guis are rendered with gpu
05:06:04 <peddie> YellowOnion: looks like forward euler to me
05:06:30 <kuribas> dadada: That's the first I heard of that.  Even canvas doesn't even use openGL.  Do you have any links?
05:06:44 <peddie> YellowOnion: doesn't Verlet integration go straight from positions to accelerations?
05:07:58 <YellowOnion> peddie, actually sorry mines based on leapfrog, the last one I used had the same issue, and was using verlet
05:08:52 <maerwald> gtk+3 will get opengl support, but I don't know that it uses opengl under the hood for anything
05:09:07 <maerwald> it currently does not link to opengl
05:09:14 <peddie> YellowOnion: also, you have no damping; I think bsimp would eat this problem up ;)  but you sure don't want to code that yourself!
05:09:40 <ww> ... back
05:09:42 <dadada> maerwald: I thought cairo was using OpenGL, but I may be wrong and it may be some other form of acceleration
05:10:08 <ww> leapfrog is a little better than symplectic euler
05:10:12 <maerwald> cairo has optional opengl support
05:10:46 <ww> and i think it's very valuable to have these clean, pretty implementations because they help understand how the algorithms work. great for teaching and learning
05:11:17 <ww> re: gsl, adams-moulton isn't implicit i think, so no good for stiff stuff
05:11:51 <peddie> they also have a BDF method
05:12:17 <AshyIsMe> how do i read from a linux fifo file with haskell?
05:12:22 <YellowOnion> peddie, I wrote the dampening in to the gravity function.
05:12:27 <peddie> bsimp is fine on any moderately stiff problems I have tried, though on those kinds of problems, it does a lot of function evaluations
05:12:28 <AshyIsMe> er, in a line by line fashion i mean
05:13:43 * hackagebot language-javascript 0.5.14.0 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.0 (ErikDeCastroLopo)
05:14:08 <peddie> ww: anyway, CVODE or LSODA or IDA is certainly better than the GSL ones, but the GSL ones are perfectly fine for tons of problems
05:14:25 * ww agrees
05:14:42 <AshyIsMe> actually, i think my real question is why is this chewing cpu instead of blocking on the readFile call? https://github.com/AshyIsMe/hircules/blob/master/app/Main.hs#L89-L92
05:15:20 <peddie> ww: my SUNDIALS bindings compile OK, but I tried to port the IDAS example as a test, and I have a segfault I haven't tracked down yet!  so whenver I dig into that again . . .
05:15:38 <ww> YellowOnion: for that kind of many body problem, you also might want to look at the Barnes-Hut approximation. it turns it from an n^2 to an nlogn problem
05:16:15 <YellowOnion> ww, is that the btree algo?
05:16:29 <peddie> ww, nice chatting with you, I'm going to bed :)
05:16:32 <ww> more like an r-tree, but yes
05:16:35 <ww> 'night
05:16:42 <YellowOnion> peddie, night.
05:18:13 <ww> one problem with all these bindings is that for implicit methods where you want the jacobian, it would be nice to get it using automatic differentiation.
05:18:35 <ww> which of course we have, but in practice it's tricky to get that to type cleanly...
05:18:43 * hackagebot hjsmin 0.1.5.0 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.5.0 (ErikDeCastroLopo)
05:18:58 <peddie> ww, you could use the casadi bindings, which can call sundials for you
05:19:05 <peddie> goodnight YellowOnion 
05:19:28 * ww doesn't know about casadi and looks
05:19:40 <YellowOnion> even with a dt of 0.003 its still losing energy, somethings not right
05:20:03 <ww> peddie: ah, but we have perfectly good AD in the language already :)
05:20:25 <peddie> ww: CasADi is ~5x faster when I've compared
05:21:10 <kuribas> dadada: no, cairo is not accelerated.
05:23:03 <maerwald> kuribas: cairo can use opengl as a backend
05:23:40 <maerwald> http://cairographics.org/OpenGL/
05:23:48 <maerwald> http://cairographics.org/backends/
05:24:40 <maerwald> interesting is this part "Cairo can translate that canvas model into GPU primitives using OpenGL (among others), but the canvas model does not often translate efficiently to the GPU."
05:26:05 <kuribas> maerwald: I wonder if that backend actually draws curves and primitives using hardware, rather than drawing it on an image and copying.
05:26:55 <kuribas> maerwald: this is interesting: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch25.html
05:27:17 <maerwald> I guess if you want high efficiency, you won't use cairo anyway
05:27:28 <mjrosenb>     Could not deduce (Functor m) arising from a use of `fmap'
05:27:28 <mjrosenb>     from the context (MonadIO m)
05:27:29 <maerwald> but be more low level
05:27:43 <mjrosenb> Did that change recently?
05:27:47 <kuribas> maerwald: nvidia has a path rendering extension: https://developer.nvidia.com/nv-path-rendering
05:27:52 <mjrosenb> e.g. in 7.10?
05:28:18 <maerwald> interesting
05:28:26 <Axman6> mjrosenb: that's an odd error, I would've thought that MonadIO implied Monad, and that Monad implied Functor (that should definitely be the case in 7.10 anyway, I think)
05:29:17 <mjrosenb> right, but this system only has 7.8 on it.
05:29:45 <Intolerable> Monad doesn't imply functor
05:29:47 <nshepperd> yes, 'Functor f => Monad f' was only added in 7.10
05:29:51 <Intolerable> use liftM
05:29:57 <nshepperd> so MonadIO won't have the constraint
05:29:59 <int-e> AshyIsMe: `readFile` opens files with O_NONBLOCK ... though I'm not 100% sure why.
05:30:06 <tzaeru> kuribas, nice that nvidia's cpu gem ^^ I wouldn't have though of using the shader stage interpolation as a way to simplify excluding fragments from inside a spline shape
05:30:10 <Intolerable> MonadIO doesn't imply Functor, no
05:30:27 <merijn> Intolerable: It does
05:30:30 <tzaeru> pretty novel and probably pretty good in performance.
05:30:44 <merijn> Intolerable: MonadIO has Monad as superclass and Functor is a superclass of Monad
05:30:50 <Intolerable> in 7.8 though
05:30:51 <merijn> Therefore Functor is a superclass of MonadIO
05:30:52 <nshepperd> it "implies" Functor, but the (pre-7.10) compiler doesn't know that
05:31:05 <merijn> oh, I missed the earlier discussion :)
05:31:09 <Intolerable> fair
05:31:20 <merijn> s/fmap/liftM, problem solved :)
05:31:28 <Intolerable> the pre-7.10 "can't use fmap" thing catches me out every time
05:31:45 <Intolerable> https://github.com/intolerable/reddit/commit/c19ea75429575b521903af6bf97438afc98a77fb
05:31:53 <int-e> AshyIsMe: but effectively it only blocks if something is connected to the other end of the fifo.
05:31:55 <Intolerable> so many commits like this
05:32:25 <nshepperd> hooray for 7.10 :D
05:33:43 <Intolerable> hooray for having to support back to 7.6 \o/
05:34:41 <Axman6> nah, no one needs to do that. Leave Ubuntu to eventually sort itself out
05:35:15 <Axman6> (the only place where I've run into having 7.6 as the default haskell compiler)
05:35:32 <Intolerable> yup its an ancient ubuntu version
05:36:06 <Axman6> just use stack =)
05:36:23 <ww> YellowOnion: wait, shouldn't you be using dt/2 in there?
05:36:25 <hodapp> stack has worked well for me thus far.
05:36:34 <hodapp> of course I've never even really tried to learn to use cabal.
05:36:54 <Axman6> it has some wrinkles, but it's definitely helped us build things much more reliably
05:36:54 <YellowOnion> ww, I spotted that too, didn't help :(
05:38:19 <hodapp> Axman6: I was surprised at how quickly I created a build with it, and had it far simpler than I ever could with cabal
05:39:02 <Axman6> yeah, me too, it's been a real pleasure to use. One project of mine which I'd managed to get into a very fragile state took 5 minutes to port, and should build reliably everywhere now
05:39:18 <ww> how are you measuring "degrading"
05:39:33 <ww> presumably you expect total momentum and total energy to be preserved.
05:39:38 <Axman6> I no longer fear running cabal sandbox delete and then not being able to build my app again
05:39:49 <ww> so do you calculate these at each step?
05:40:03 <hodapp> Axman6: my silly use-case was that I needed to use a package where the upstream git master is way, way newer than the hackage release
05:40:04 <Axman6> (for more than the fact I don't need cabal sandboxes anymore)
05:40:12 <int-e> AshyIsMe: http://stackoverflow.com/questions/14594508/fifo-pipe-is-always-readable-in-select seems relevant, so it looks like you could use   openFile fifoname ReadWriteMode >>= hGetContents   instead of  readFile fifoname, and even leave out the `forever` call.
05:40:47 <ww> YellowOnion ^^
05:40:54 <hodapp> Axman6: I need to figure out how to integrate the Emacs tooling with this, but that's about the only remaining wart in the setup
05:41:10 <lpaste_> guibou pasted “Slow parsing” at http://lpaste.net/137482
05:41:30 <Axman6> I'm hoping for sublime to support using stack soon - I made a poor attempt but lost interest quickly
05:42:17 <YellowOnion> ww, I got some visualisation going on (graphics-drawingcombinators)
05:42:17 <guillaum1> merijn: stuff improved a bit (something like 10%), but I'm still ten times slower than the naive python implementation.
05:42:47 <ww> YellowOnion: try putting some numbers to it -- total energy in particular should be relatively easy to calculate.
05:43:10 <ww> it's a symplectic integrator, so regardless of what's in the picture, if total energy doesn't change much, it's doing its job
05:43:44 * hackagebot http-link-header 0.2.0 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  https://hackage.haskell.org/package/http-link-header-0.2.0 (myfreeweb)
05:44:21 <YellowOnion> ww, my orbits are decaying, isn't that a good indictor it isn't working?
05:45:29 <ely-se> I read that as "my armpits are decaying"
05:45:47 <merijn> guillaum1: Can you show what you have now?
05:47:03 <merijn> guillaum1: "split the file and then apply the parser N times" <- ouch
05:47:12 <merijn> guillaum1: Why not write a parser that returns a list instead?
05:47:38 <ww> well, think about it. smaller orbit means more potential energy, but if the movement is correspondingly slower, you have same total energy.
05:48:02 <ww> symplectic integrators are designed to preserve this invariant. 
05:49:21 <guillaum1> merijn: look at getContrib', it does exactly that, and runs ten time slower
05:49:53 <merijn> guillaum1: oh, I got confused by the multiple names
05:50:27 <merijn> guillaum1: Is the file newline terminated? i.e. lastline ends with \n too? If so, why not move the "P.char '\n'" into 'parser' and use 'many' instead of sepBy?
05:50:37 <ww> and again, you should know what your error tolerance is, and adjust the timestep as you go to meet that tolerance.
05:51:26 <ww> (or just pick the smallest one that you are sure will give you the right error margin and waste some cpu)
05:51:50 <merijn> hmmm, looks like it's spending 30% reading the file, I wonder if not reading the entire file into memory first would be faster...
05:52:01 <guillaum1> merijn: I tried "many' (do {l <- parser; P.char '\n'; return l})" which must be roughly equivalent, and it is as slow as getContrib'
05:53:13 <guillaum1> merijn: actually I think that the 30% are because the file loading is not Lazy, so it load the 130 MB of data, and apply the parser only on the firs 100000 (if lazyness works correctly). So the time for the file reading is not really an interesting measurement
05:53:15 <ww> global error with this method is something like O(t^2), so if you halve the time-step so the orbit should degrade four times as slowly
05:53:23 <Axman6> the list can't be returned until the whole thing is parsed, so it'll fill up memory quichly
05:53:25 <merijn> guillaum1: Unrelated question is the "Left _ -> (Coord 0 0, RGB 0 0 0)" right? Don't you want to ignore failed parses?
05:53:27 <Axman6> ck*
05:54:07 <guillaum1> merijn: actually, yes, I like to ignore them, but I did not yet understood how I'm supposed to do that, so for now I'm putting dummy values
05:54:15 <merijn> guillaum1: If so, you could do "lefts $ map (P.parseOnly parser) list"
05:54:32 <merijn> The map gives you [Either ParseError (Coord, RGB)]
05:54:36 <merijn> And lefts
05:54:40 <merijn> :t lefts
05:54:41 <lambdabot> [Either a b] -> [a]
05:54:41 <merijn> eh
05:54:43 <guillaum1> merijn: beautiful, thanks
05:54:45 <merijn> Obviously I meant
05:54:48 <merijn> :t rights
05:54:49 <lambdabot> [Either a b] -> [b]
05:55:40 <merijn> guillaum1: This is with -O2, yes?
05:55:41 <chpatrick> guillaum1: have you considered https://hackage.haskell.org/package/conduit-extra-1.1.9.1/docs/Data-Conduit-Attoparsec.html#v:conduitParserEither ?
05:55:50 <merijn> (And building attoparsec with -O2 too)
05:55:52 <chpatrick> for streaming a file into atto
05:56:16 <merijn> chpatrick: I thought about suggesting pipes, but given this simple case it might be overkill, don't wanna overload people :)
05:56:28 <merijn> Reading 130MB into memory should be that problematic
05:56:42 <chpatrick> actually could you just mmap it?
05:56:49 <Intolerable> pipes / conduit looks like massive overkill for this yeah
05:57:11 <Axman6> should be simple to use though
05:57:11 <merijn> chpatrick: I don't think there's a convenient way to treat mmap'ed memory as Text
05:57:22 <merijn> chpatrick: I've been thinking of implementing something like that
05:57:25 <chpatrick> does this parser need unicode?
05:57:29 <guillaum1> merijn: with O2 yes
05:57:41 <chpatrick> @hackage bytestring-mmap
05:57:41 <lambdabot> http://hackage.haskell.org/package/bytestring-mmap
05:57:59 <merijn> This might be able to get away with ByteString, I guess
05:58:03 <Axman6> there is a library for mmapped bytestrings, and surely there's a way to make a Text from a ByteString by saying "trust me, this is UTF16)
05:58:25 <YellowOnion> ww, Maybe RK4 is better for my needs.
05:58:31 <chpatrick> Axman6: I don't think so
05:58:42 <chpatrick> bytestring is a foreignptr and text is a bytearray
05:58:45 <guillaum1> merijn: wait, I just realize something. By default, cabal install build with -O? ?
05:58:59 <Axman6> bleh, right
05:59:04 <merijn> guillaum1: Yes, maybe even -O0
05:59:15 <merijn> guillaum1: You can change the default in .cabal/config
05:59:21 <guillaum1> merijn: so perhaps I'm just stupid ;)
05:59:38 <merijn> Axman6: Sure, but that doesn't give you easy mutable updates
06:00:07 <merijn> Although I guess I'm not sure I need that, now that I think about it
06:00:10 <Axman6> who needs that?
06:01:01 <merijn> Axman6: People who wanna deal with huge amounts of unicode data
06:01:21 <merijn> Axman6: Actually, "trust me, this is UTF16" is useless, since I'd be giving it UTF8 (obviously)
06:01:36 <merijn> But I hardly feel like rolling my own UTF-8 version of Text >.<
06:02:20 <chpatrick> do you know if there's an existing library that exposes string constants as Ptrs?
06:02:47 <Axman6> merijn: I think I'm missing some context here
06:03:04 <chpatrick> I wrote one that stores strings either as Text or as a CChar and has a RULES to use the latter when it's made from a string literal
06:03:07 <merijn> chpatrick: FFI can convert String to Ptr CChar
06:03:14 <chpatrick> I mean
06:03:27 <merijn> Axman6: I have UTF-8 that I wanna mmap and run Text functions on
06:03:30 <chpatrick> string constants are sitting in memory as UTF-8
06:03:58 <chpatrick> with RULES you can just hang on to the Ptr and pass it directly to something that needs UTF-8 without any marshalling
06:04:00 <Axman6> merijn: ah. must it be mmapped?
06:04:11 <chpatrick> I've done this in my own code but I'm wondering if there's a package for it
06:04:13 <merijn> Axman6: And I want to avoid the overhead of copying/decoding to Text
06:04:15 <merijn> Axman6: Yes
06:04:42 <guillaum1> merijn: I rebuilded attoparsec and text in O2 but that does not change anything, so there is something else ;) I'll continue to investigate.
06:05:00 <chpatrick> guillaum1: try running it on a mmaped ByteString
06:05:11 <chpatrick> assuming it's ASCII
06:05:15 <Axman6> merijn: does https://hackage.haskell.org/package/text-icu provide what you're after?
06:05:39 <guillaum1> chpatrick: I'll do it
06:05:53 <alanz> I just registered for ICFP, there were no options for the monday/tuesday. Is that correct?
06:06:25 <Axman6> I wish I was going to ICFP :(
06:06:26 <AshyIsMe> int-e: cheers
06:06:35 <Axman6> Hopefully next year in Japan
06:06:43 <merijn> Axman6: Oh! That looks like it might be useful!
06:09:48 <AshyIsMe> int-e: i would still need the forever call though i think, this code should read from that fifo and write each line to the socket.  the fifo will be written by a different process
06:10:05 <AshyIsMe> int-e: it should loop forever while the process is still running
06:18:13 <AshyIsMe> int-e: i want to be able to read continually from a linux fifo without busy looping or explicitly sleeping/polling
06:18:23 <int-e> AshyIsMe: try it; the writing end of the fifo is never closed, because your process still has write access to it
06:19:44 <AshyIsMe> OH
06:21:37 <AshyIsMe> int-e: sweet that works
06:21:54 <AshyIsMe> so why don't i need the forever in there?
06:23:33 <AshyIsMe> oh god, it's because of laziness isnt it, think i just had a mindsplosion
06:24:07 <int-e> AshyIsMe: yes. the `readFile` returns immediately in any case
06:25:36 <orion> Does anyone know how to make this ResourceT exception handler "do nothing" where I've marked it?: http://lpaste.net/2590530114655617024
06:25:49 <guillaum1> merijn: hooo, in fact the lazyness of the parser is less smart that what I thought. So it was parsing the whole file and then take only 100000 of them. I used the lazy parser and now stuff are more correct (I'm *only* 5 times slower than naive python)
06:26:00 <orion> (Line 6)
06:27:07 <Intolerable> http://lpaste.net/2590530114655617024
06:27:11 <Intolerable> how's that look
06:27:48 <orion> Intolerable: Hmm...
06:28:42 <ely-se> it looks intolerable
06:29:12 * Intolerable ticks off July 28th in the "shitty username pun" calendar
06:29:20 <merijn> Axman6: Sadly you can't do much with a CharIterator, apparently :\
06:30:00 <Axman6> I've never used the package, so wasn't sure if it'd be of use. it's a bos package, so I had high hopes =)
06:30:39 <merijn> Axman6: It seems to only allowd Eq/Ord and passing to collateIter
06:31:27 <merijn> I think I want like a lens/iso from Ptr Word8 to Text so I can use lens magic to let people run Text functions on my binary data...
06:32:50 <orion> Intolerable: That doesn't typecheck.
06:33:07 <Intolerable> error?
06:33:24 <Intolerable> oh
06:33:26 <Intolerable> return Nothing
06:33:27 <Intolerable> not just Nothing
06:33:47 <orion> ah
06:40:05 <phaazon> hm
06:40:07 <cchalmers> guillaum1: I had a go using lazy bytestring instead of lazy text and it runs around 4x faster for me
06:40:09 <phaazon> what is the kind BOX for?
06:40:17 <phaazon> I thought it was like *
06:40:32 <merijn> phaazon: Mu
06:40:39 <merijn> phaazon: Your question does not make sense
06:40:45 <merijn> BOX is a sort, it doesn't have a kind
06:41:07 <phaazon> ?!
06:41:11 <lambdabot> Maybe you meant: v @ ? .
06:41:15 <merijn> If types are the types of values, and kinds are the types of types, then sorts are the types of kinds
06:41:17 <phaazon> I thought it was a kind
06:41:26 <phaazon> oh god.
06:41:34 <phaazon> what’s the sort of * then?
06:41:37 <merijn> And in haskell there is only one sort, that sort is BOX and every kind has sort BOX
06:41:43 <Intolerable> whats the type of sort
06:41:49 <phaazon> even Constraint?
06:42:06 <merijn> phaazon: BOX, because the sort of every kind is BOX in haskell :p
06:42:42 <phaazon> al…right… :D
06:42:47 <phaazon> I don’t have to worry about that then
06:42:49 <merijn> phaazon: In CoC you have an infinite hierarchy, so the gave up on giving them names and just went with "Type_0", "Type_1", etc.
06:43:34 <merijn> In haskell you have only 4 layers, instead of infinite (terms, types, kinds and sorts) and the code you can write can only use the first three (i.e. sorts are only something used inside the compiler)
06:43:57 <phaazon> well
06:44:08 <phaazon> we can manipulate kinds and types
06:47:08 <shock_one> merijn: what's CoC?
06:47:48 <phaazon> Clash Of Clans.
06:47:51 <phaazon> (sorry)
06:48:58 <y> merijn: wouldn't that last change to the type system, unifying kinds and types change that?
06:49:11 <phaazon> unifying?
06:49:15 <phaazon> you made him quit
06:49:18 <phaazon> he couldn’t bare it.
06:49:19 <phaazon> :D
06:49:34 <phaazon> it doesn’t unify
06:49:36 <phaazon> not really
06:49:40 <phaazon> it “promotes”
06:49:54 <y> http://www.cis.upenn.edu/~eir/packages/nokinds/
06:51:11 <merijn> Whoo, that was the daily "university wifi craps out"...
06:51:16 <merijn> phaazon: http://jozefg.bitbucket.org/posts/2014-02-10-types-kinds-and-sorts.html
06:52:01 <quicksilver> shock_one: Calculus of Constructions
06:52:38 <phaazon> thanks merijn 
06:52:46 <shock_one> quicksilver: thank you.
06:53:00 <phaazon> flummoxed? :D
06:53:03 <phaazon> what the hell does that mean
06:53:10 <merijn> phaazon: baffled
06:53:14 <merijn> stupified
06:53:35 <merijn> I can't think of other fun synonyms
06:54:38 <quicksilver> merijn: bamboozled
06:54:52 <quicksilver> merijn: discombobulated
06:54:56 <merijn> quicksilver: Isn't bamboozled more like tricked?
06:55:12 <quicksilver> dunno. Don't distract me with precision.
06:55:24 <merijn> Yeah, bamboozled is tricked/conned
06:55:26 <quicksilver> merijn: flabbergasted
06:55:37 <merijn> oh, I forgot perplexed
06:58:36 <deejay08> hi everyone... haskell newbie here. was practicing real world haskell when I saw that foldr (+) 0 [1..10000000] seems much faster than the foldl counterpart. 
06:58:44 <deejay08> Is there a specific reason?
06:59:07 <deejay08> I think they should be doing almost the same amount of thunking, given the laziness feature in haskell
06:59:38 <phaazon> I think a foldl is supposed to be faster because of tail-recursion
06:59:58 <deejay08> I noticed it the other way... foldr was much faster!
07:00:00 <deejay08> :O
07:00:04 <phaazon> let me guess
07:00:07 <phaazon> and think
07:00:08 <phaazon> wait
07:00:09 <Intolerable> where are you running it?
07:00:20 <deejay08> win32/emacs
07:00:44 <Intolerable> interactively?
07:00:56 <deejay08> yup. ghci
07:01:03 <chpatrick> deejay08: with foldr you can lose the intermediate list
07:01:30 <chpatrick> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html#id3184636
07:01:59 <chpatrick> so with foldr it's literally equivalent to 1 + 2 + 3 + 4...
07:01:59 <deejay08> Umm... can't the same be done with foldl? We could always assign a null return from the step function... haskell won't execute the rest then...
07:02:33 <chpatrick> so some lists are internally represented as \f b -> 1 `f` 2 `f` 3 `f` 4 `f` b
07:02:43 <chpatrick> so essentially a fold waiting for a function and an initial value
07:02:59 <chpatrick> if you foldr this list then haskell doesn't actually have to do anything, it can just pass in the function and the value
07:03:05 <deejay08> okay... how does that go with foldr?
07:03:21 <chpatrick> well foldr is the same thing
07:03:41 <chpatrick> if you do foldr (+) 0 [ 1, 2, 3] it's equivalent to 1 + 2 + 3 + 0
07:03:52 <merijn> foldl' is faster, probably. foldl should be stupid slow
07:03:55 <chpatrick> 1 + (2 + (3 + 0))
07:04:00 <deejay08> yeah... but ghci's environment would force an eval... and hence reduce the list, right?
07:04:02 <chpatrick> oh yeah and laziness
07:04:07 <aweinstock> what makes reallyUnsafePtrEquality# "reallyUnsafe", as opposed to just "unsafe"?
07:04:26 <chpatrick> deejay08: but only at the end
07:04:37 <merijn> aweinstock: It compares to values by their pointers, but GHC is free to move/copy/duplicate/etc. pointers since everything is immutable
07:04:38 <chpatrick> once it's made a huge thunk
07:04:58 <quicksilver> aweinstock: it can have false positives as well as false negatives
07:05:00 <merijn> aweinstock: So there's absolutely no guarantees on when it will or won't return equality
07:05:01 <deejay08> hmm... i get that much...
07:05:44 <deejay08> let me do some more experiments... thanks chpatrick for the pointers!
07:05:55 <merijn> aweinstock: Probably one of the few things that's even less safe than accursedUnutterablePerformIO :)
07:06:28 <merijn> aweinstock: See https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L590-L622
07:06:35 <Gurkenglas> Can you find a better way to represent "\f -> let r = [ f $ take i r | i <- [0..] ] in r", using a fold or something?
07:07:07 <aweinstock> merijn: I already assumed it wasn't referentially transparent due to GCing, but I'm still not sure why it's less safe than unsafePerformIO
07:07:33 <deejay08> chpatrick++
07:07:47 <quicksilver> aweinstock: it's not really. After all, the worst it can do is return the wrong number.
07:07:52 <merijn> aweinstock: unsafePerformIO is still somewhat predictable
07:08:07 <merijn> aweinstock: This thing isn't
07:08:26 <merijn> Of course, I guess it's still safer than unsafeCoerce, which can just segfault everything :p
07:08:30 <deejay08> @help
07:08:30 <quicksilver> aweinstock: I'm pretty sure the 'really' is because it's obvious that it might return false instead of true.
07:08:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:08:41 <quicksilver> aweinstock: (but not so obvious that it might in principle return true instead of false)
07:08:48 <deejay08> @help list
07:08:49 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
07:08:57 <quicksilver> so it's a reminder that your naive expectations are wrong.
07:09:03 <quicksilver> who knows, though? :) I wonder who named it.
07:09:25 <deejay08> @pl takeWhile
07:09:26 <lambdabot> takeWhile
07:09:37 <Intolerable> is there some way of sensibly building up a command to send to a shell to run?
07:09:39 <quicksilver> merijn has a point though that unsafePerformIO is referentially transparent but at least deterministic. Whilst reallyUnsafePtrEquality is completely non-deterministic.
07:09:47 <Intolerable> (it's over ssh)
07:10:00 <quicksilver> missing 'not' somewhere there :)
07:10:33 <aweinstock> @src unsafePerformIO
07:10:34 <lambdabot> Source not found.
07:10:42 <aweinstock> @src System.IO.Unsafe.unsafePerformIO
07:10:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:10:50 <aweinstock> @src System.IO.unsafePerformIO
07:10:50 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
07:11:27 <quicksilver> the source code for unsafePerformIO is not that enlightening. It really just shows you how GHC's implementation language works. It's almost a no-op.
07:12:50 <chpatrick> :t \f -> fix $ map f . inits
07:12:51 <lambdabot> ([a] -> a) -> [a]
07:12:56 <chpatrick> Gurkenglas: ^
07:12:58 <aweinstock> I'm trying to understand the differences between unsafePerformIO, unsafeDupablePerformIO, and accursedUnutterablePerformIO
07:12:59 <chpatrick> haven't tried it though :P
07:13:19 <aweinstock> i know the difference between the first two is a matter of thread-safety, not sure about the latter though
07:13:45 <aweinstock> what does "lazy" do in https://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-IO.html#unsafeDupablePerformIO
07:13:59 <merijn> aweinstock: That's from GHC.Prim
07:13:59 <Gurkenglas> Dangit, I thought of how inconvenient it is that there is tails but not something for the other end and didn't even hoogle it
07:14:03 <merijn> iow voodoo
07:14:15 <merijn> Gurkenglas: You mean inits? ;)
07:14:21 <quicksilver> aweinstock: builds a thunk, I think. A.k.a. delays computation until forced. However I'm not sure.
07:14:22 <aweinstock> (since that seems to be the only difference between unsafeDupablePerformIO and accursedUnutterablePerformIO)
07:14:32 <chpatrick> I tried it with (\xs -> product xs + 1) and it crashed my terminal :D
07:14:38 <Gurkenglas> merijn, yep, chpatrick just used it
07:14:49 <Gurkenglas> > inits [1..]
07:14:51 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
07:14:54 <zalatovo> I'm having some trouble getting interactive-haskell-mode to work in Emacs. When I call haskell-interactive-bring, I get a prompt showing \lambda> yet when I press enter the prompt doesn't respond at all. Has anyone had this problem before?
07:15:08 <merijn> aweinstock: https://downloads.haskell.org/~ghc/7.2.2/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:lazy
07:15:24 <Gurkenglas> > (\f -> fix $ map f . inits) $ (+1) . product
07:15:28 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
07:15:45 <Gurkenglas> chpatrick, seems to work fine?
07:15:46 <merijn> quicksilver: No, lazy is a no-op that is made out of magic strictness-analyzer pixie dust
07:15:55 <quicksilver> oh that's right.
07:16:00 <broma0> Why are monads the primary way to structure large codebases as opposed to applicatives ?
07:16:01 <chpatrick> yeah, but I think it grows pretty quickly
07:16:07 <chpatrick> so it oomed when I just let it run in ghci
07:16:21 <quicksilver> broma0: they aren't (in my opinion)
07:16:24 <broma0> Look at YI, there's a monad for each part of the editor. Why not an applicative?
07:16:31 <quicksilver> monads are a model for certain kinds of computation
07:16:41 <quicksilver> they're definitely not a primary tool for abstraction or modularity
07:16:43 <broma0> quicksilver. How do you do it then?
07:16:58 <quicksilver> modules. data types. functions.
07:17:01 <Gurkenglas> That shouldn't oom, its memory usage should be equal to its output file size.
07:17:11 <broma0> I'm so used to making a new monad with type and then defining a runType
07:17:18 <chpatrick> Gurkenglas: it makes some very big Integers
07:17:32 <merijn> broma0: But then you already have an Applicative...
07:17:46 <merijn> broma0: Since all monads are by definition (since 7.10 disclaimer) Applicatives
07:17:50 <phaazon> hey, is there a new standard planned to be released?
07:17:51 <broma0> merijn, my point exactly.
07:17:53 <phaazon> like Haskell2016?
07:17:58 <phaazon> or something like that?
07:18:05 <broma0> Then why not emphasize the use of applicatives?
07:18:16 <Gurkenglas> chpatrick, as soon as they are calculated and put into memory, they are outputted, and longer integers take more output space
07:18:17 <chpatrick> phaazon: not as far as I know
07:18:30 <merijn> phaazon: Not really
07:18:33 <chpatrick> it would be nice to have a lot of basic stuff on by default
07:18:42 <YellowOnion> :t mkStdGen <$> [0..3]
07:18:44 <lambdabot> [StdGen]
07:18:46 <chpatrick> FlexibleContexts, MultiParamTypeClasses, LambdaCase
07:18:53 <chpatrick> everything uncontroversial
07:19:13 <mniip> 1 is pretty hard actually
07:19:15 <chpatrick> it's just boilerplate at this point
07:19:20 <merijn> phaazon: The standard is mostly descriptive (i.e. it describes existing implementations), but given the absence of competing compilers there's not a lot of interest in standardisation. Although I heard Haskell Prime is starting up again
07:19:23 <mniip> and so is 2
07:19:45 <chpatrick> I mean realistically 99% of people use GHC right?
07:19:48 <merijn> chpatrick: FlexibleContexts isn't uncontroversial, some people strongly disagree on adding that
07:19:52 <chpatrick> really?
07:19:53 <chpatrick> why?
07:19:57 <merijn> chpatrick: I dunno
07:20:07 <phaazon> merijn: well
07:20:07 <merijn> I've run into a few of them, though
07:20:08 <chpatrick> I mean there's just so much extension noise at this point
07:20:10 <phaazon> as said above
07:20:19 <phaazon> I’d love to have a lot of extensions on by default
07:20:27 <chpatrick> and I never even use "dodgy" ones like overlappinginstances
07:20:29 <mniip> it complicates typechecking and just because ghc can do it, doesn't mean everything can
07:20:33 <phaazon> GADTs, DataKinds, PolyKinds, Flexible*, Multi*, and so on
07:20:46 <merijn> phaazon: Those make type inference really hard
07:20:46 <chpatrick> is that worth inconveniencing the 99% of people that use ghc?
07:21:03 <mniip> "inconveniencing"
07:21:07 <phaazon> people that?
07:21:08 <chpatrick> yeah
07:21:09 <phaazon> what
07:21:16 <aweinstock> is NoMonomorphismRestriction uncontroversial?
07:21:22 <chpatrick> I mean
07:21:35 <chpatrick> imagine if you had to put 5 lines of boilerplate on the top of every haskell file
07:21:39 <merijn> aweinstock: Yes, I would strongly oppose that
07:22:05 <phaazon> chpatrick: I put my extensions in the default-extensions of my .cabal
07:22:14 <chpatrick> me too
07:22:14 <phaazon> or for very local ones, LANGUAGE pragma + other extensions
07:22:16 <merijn> aweinstock: NoMonomorphism turns a loud, explicit failure into a subtle, hard to debug and spot issue and avoiding MMR issues is trivial
07:22:21 <chpatrick> but it's just a pain to turn it on every time I do anything
07:22:29 <phaazon> NoMono
07:22:36 <phaazon> it’s the extension for, huh:
07:22:47 <phaazon> foo :: Int -> IO ()
07:22:49 <phaazon> foo = \x -> …
07:22:51 <phaazon> that’s it?
07:23:30 <phaazon> ohoh! Idris looks sexy! I wonder whether it has FFI support like Haskell has (to bind to C libraries)
07:23:42 <merijn> phaazon: No, it means that "x = [1..10]" has one type i.e. [Int], etc. instead of type "Num a => [a]"
07:24:09 <phaazon> oh yeah
07:24:12 <phaazon> I hate that.
07:24:28 <phaazon> GHC should infer the most general type
07:24:37 <merijn> phaazon: No, it should not
07:24:46 <phaazon> merijn: well
07:24:52 <merijn> That's why we have the Monomorphism restriction
07:24:56 <phaazon> if x is used only once, of course it should not
07:24:58 <phaazon> if it’s used more than once
07:25:08 <merijn> phaazon: That's exactly when it SHOULD fail
07:25:09 <phaazon> it should infer the more generally restrictive type for both the uses
07:25:14 <phaazon> ahah :)
07:25:28 <merijn> phaazon: Because if 'x' is used multiple times it ends up recomputing everytime
07:25:37 <merijn> phaazon: Imagine I have an expensive computation producing a list
07:26:01 <deejay08> @src map
07:26:02 <lambdabot> map _ []     = []
07:26:02 <lambdabot> map f (x:xs) = f x : map f xs
07:26:14 <deejay08> @src groupBy
07:26:14 <lambdabot> groupBy _  []     =  []
07:26:14 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
07:26:14 <lambdabot>     where (ys,zs) = span (eq x) xs
07:26:32 <merijn> I define "myList = someExpensiveFunction 10", now every time some code uses myList it recomputes someExpensiveFunction! Because polymorphic code like "Num a => [a]" has to be recomputed because it might be a different type each time
07:26:46 <merijn> phaazon: Whereas if "myList :: [Int]" it's only computed once and shared
07:27:07 <phaazon> merijn: I meant
07:27:11 <phaazon> used for several types
07:27:17 <phaazon> if GHC infer the uses share the same type
07:27:22 <merijn> MonomorphismRestriction prevents you from accidental recomputation by loudly complaining anytime you (potentially) introduce recomputation
07:27:27 <merijn> phaazon: Then MMR already works
07:27:43 <phaazon> right :)
07:27:47 <merijn> phaazon: MMR *only* fails and complains if you use it for different types, because that's the only time you might accidentally produce recomputation
07:27:55 <phaazon> so working with NMMR might introduce performance issues
07:28:05 <phaazon> if we’re not extremely careful
07:28:07 <merijn> phaazon: So basically MMR forces you to explicitly tell GHC "it's ok to recompute this every time"
07:28:24 <aweinstock> so MMR is an intentional protection against subtle performance degradation?
07:28:27 <phaazon> right, so it should be on by default, which is the case
07:28:29 <merijn> aweinstock: Yes
07:28:51 <phaazon> well, there are extensions that could be set on by default
07:29:10 <merijn> aweinstock: Because disabling MMR might result in recomputation you did not intend and *with* MMR it fails at compile time telling you "you're using this as different types" (implying it's recomputing every time)
07:29:34 <phaazon> like MultiParamTypeClasses, PolyKinds, DataKinds, KindSignatures, GADTs, Flexible*, Multi*, ScopedTypeVariables, GeneralizedNewtypeDeriving, TypeOperators, Typefamilies, all the Derive* ones
07:29:46 <phaazon> MultiWayIf, which is cool
07:30:10 <merijn> aweinstock: You can shut up it's complaints by prodiving an explicit type, i.e. "Num a => [a]" which explicitly specifies it should be polymorphic (and thus be recomputed)
07:30:39 <merijn> aweinstock: But I'll take explicit compile time failures over silent performance degradation any time :p
07:31:37 <YellowOnion> How would one generate a list of random tuples of type (a, a, a, a)? this is awfully close> randomRs (-1, 1) . mkStdGen <$> [1..4]
07:31:51 <shachaf> What is MMR?
07:32:01 <phaazon> MonomorphicRestriction
07:32:04 <merijn> shachaf: MonoMorphismRestriction
07:32:08 <shachaf> Oh.
07:32:14 <phaazon> Morphism*
07:32:19 <shachaf> You mean the MMRR, MonoMorphism RestRiction, I guess.
07:32:27 <Intolerable> :t state
07:32:31 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:32:35 <indiagreen> YellowOnion: don't use mkStdGen on consecutive values
07:32:45 <indiagreen> the last time I tried it, I got very bad randomness
07:32:47 <Intolerable> :t state randomR
07:32:50 <lambdabot>     Couldn't match type ‘g0 -> (a0, g0)’ with ‘(a, (a0, a0))’
07:32:50 <lambdabot>     Expected type: (a0, a0) -> (a, (a0, a0))
07:32:50 <lambdabot>       Actual type: (a0, a0) -> g0 -> (a0, g0)
07:32:58 <Intolerable> :t state random
07:33:00 <merijn> shachaf: I'm just stealing the acronyms from the wiki
07:33:03 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
07:33:10 <hodapp> glguy: ping? do you, being a Galois-er, know why their projects seem to prefer monadLib over some more common solutions?
07:33:14 <Intolerable> :t (,,,) <$> state random <*> state random <*> state random <*> state random
07:33:16 <lambdabot> (MonadState s f, RandomGen s, Random a, Random a1, Random a2, Random a3) => f (a3, a2, a1, a)
07:33:26 <merijn> YellowOnion: use "randoms"?
07:33:28 <shachaf> I declare "MR" the correct acronym.
07:33:38 <Intolerable> :t runState $ (,,,) <$> state random <*> state random <*> state random <*> state random
07:33:42 <lambdabot> (RandomGen s, Random a, Random a1, Random a2, Random a3) => s -> ((a3, a2, a1, a), s)
07:33:46 <merijn> > randoms (mkStdGen 1) :: [(Int, Int, Int, Int)]
07:33:48 <lambdabot>      No instance for (Random (Int, Int, Int, Int))
07:33:48 <lambdabot>        arising from a use of ‘randoms’
07:33:48 <lambdabot>      In the expression: randoms (mkStdGen 1) :: [(Int, Int, Int, Int)]
07:33:53 <merijn> Really?
07:34:02 <merijn> Not Random instance for tuples? o.O
07:34:19 <Intolerable> :t runState $ (,,,) <$> state random <*> state random <*> state random <*> state random :: Random a => StdGen -> ((a,a,a,a), StdGen)
07:34:22 <lambdabot> Random a => StdGen -> ((a, a, a, a), StdGen)
07:34:34 <Intolerable> YellowOnion: like that
07:34:52 <Intolerable> :t getStdRandom $ runState $ (,,,) <$> state random <*> state random <*> state random <*> state random :: Random a => StdGen -> ((a,a,a,a), StdGen)
07:34:54 <lambdabot>     Couldn't match expected type ‘StdGen -> ((a4, a4, a4, a4), StdGen)’
07:34:54 <lambdabot>                 with actual type ‘IO (a3, a2, a1, a0)’
07:34:54 <lambdabot>     In the expression:
07:35:06 <Intolerable> :t getStdRandom $ runState $ (,,,) <$> state random <*> state random <*> state random <*> state random :: Random a => IO (a,a,a,a)
07:35:08 <lambdabot> Random a => IO (a, a, a, a)
07:35:34 <YellowOnion> hmm OK
07:36:38 <Intolerable> state random is a really helpful snippet
07:36:46 <Intolerable> i use that a lot in random things
07:37:25 <YellowOnion> wait IO?
07:37:32 <merijn> Someone should submit a patch adding Random instance for tuples with "(Random a, Random b) => Random (a,b)"
07:38:42 <Intolerable> there's one further up without IO
07:38:45 <Intolerable> :t runState $ (,,,) <$> state random <*> state random <*> state random <*> state random :: Random a => StdGen -> ((a,a,a,a), StdGen)
07:38:47 <lambdabot> Random a => StdGen -> ((a, a, a, a), StdGen)
07:40:22 <bigs> Gurkenglas: out of curiosity, what was the proposed application of your function?
07:40:58 <YellowOnion> Intolerable, is that making a list anymore?
07:41:30 <Intolerable> do you want a list rather than tuples?
07:41:35 <Intolerable> :t replicateM
07:41:36 <lambdabot> Monad m => Int -> m a -> m [a]
07:41:40 <YellowOnion> I want a list of tuples
07:42:09 <Intolerable> tuples of what
07:42:10 <YellowOnion> :t randomRs (-1, 1) . mkStdGen <$> [1..4]
07:42:11 <lambdabot> (Num a, Random a) => [[a]]
07:42:23 <Intolerable> what length tuples
07:42:32 <YellowOnion> 4
07:42:48 <Intolerable> \n -> runState $ replicateM n $ (,,,) <$> state random <*> state random <*> state random <*> state random
07:42:54 <Intolerable> :t \n -> runState $ replicateM n $ (,,,) <$> state random <*> state random <*> state random <*> state random
07:43:07 <lambdabot> (RandomGen s, Random a, Random a1, Random a2, Random a3) => Int -> s -> ([(a3, a2, a1, a)], s)
07:43:27 <Intolerable> if you want a particular length that'll do
07:43:32 <Intolerable> or do you want it infinite?
07:44:00 <YellowOnion> I'm feeding V.fromListN with it so infinite
07:44:34 <Intolerable> gonna have to newtype tuple probably
07:44:38 <Intolerable> and give it a Random instance
07:45:31 <Intolerable> eh, actually
07:48:16 <Intolerable> :t unfoldr (\g -> Just $ runState ((,,,) <$> state random <*> state random <*> state random <*> state random) g) :: Random a => StdGen -> [(a,a,a,a)]
07:48:16 <Intolerable> unfoldr (\g -> Just $ runState ((,,,) <$> state random <*> state random <*> state random <*> state random) g) :: Random a => StdGen -> [(a,a,a,a)]
07:48:20 <lambdabot> Random a => StdGen -> [(a, a, a, a)]
07:48:31 <Intolerable> unfoldr (\g -> Just $ runState ((,,,) <$> state random <*> state random <*> state random <*> state random) g)
07:48:33 <Intolerable> should work
07:50:03 <aweinstock> merijn: so presumably the point of accursedUnutterablePerformIO is to ensure that ByteStrings are as fast as possible (and it's taking shortcuts that are only safe with very careful consideration)?
07:50:05 <YellowOnion> I actually don't need a tuple, but I need a function that takes 4 paramters. but this should work.
07:50:23 <merijn> aweinstock: Yeah
07:50:24 <Intolerable> switch random for (randomR (-1,1)) if u need a range
07:50:40 <YellowOnion> Intolerable, I was on the right track with applicative though!
07:50:51 <Intolerable> yup, applicative is good for that
07:51:09 <Intolerable> would be nice if the state random "trick" was documented somewhere, but oh well
07:51:43 <YellowOnion> Intolerable, You don't happen to browse /r/Dota2?
07:51:59 <Intolerable> yup, that's me
07:52:18 <Intolerable> nazi mod extraordinaire
07:52:24 <indiagreen> Intolerable: /r/haskelltil, maybe (but documenting it in System.Random would've been better)
07:53:04 <aweinstock> merijn: are there blogposts or something explaining the proof obligations/design considerations for accursedUnutterablePerformIO/ByteString?
07:53:15 <YellowOnion> Ahh, I knew one of the bots was written in haskell, put two and two together.
07:54:12 <Intolerable> all of our bots are haskell
07:54:25 <Intolerable> they used to be php
07:54:32 <Intolerable> but maintaining them was awful
07:54:43 <hodapp> PHP?!
07:55:02 <YellowOnion> I like the complete 180 of langs
07:55:06 <Gurkenglas> bigs, I'm trying to implement subsequences.
07:55:23 <Intolerable> yeah we used to have a cron job that would run a php script that would connect to redis and update the sidebar every minute
07:55:37 <hodapp> YellowOnion: hey, Facebook pretty much made their own non-sucky PHP using OCaml :P
07:55:49 <Intolerable> we couldn't add features to it because it was a huge mess
07:56:08 <Intolerable> https://github.com/intolerable/sidebar-bot
07:57:02 <YellowOnion> hodapp, yeah haha, I don't understand why they didn't just write their own lang at that stage.
07:57:39 <Intolerable> never underestimate the terror of legacy code
07:58:26 <Xe> https://gist.github.com/Xe/c2109ded3774b1c578ef
07:58:32 <Xe> what am I doign wrong?
07:58:34 <hodapp> YellowOnion: well, they more or less did, it just happened to be a PHP subset
07:58:47 <Xe> i'm trying to make a blaze html renderer for this datatype
07:58:49 <bigs> Gurkenglas: ah -- been working through a practical use of that fn and am getting closer. anything more concrete than that? it's an interesting exercise
07:59:18 <Intolerable> H.img ! A.src $ unpack (avatar user)
07:59:20 <Intolerable> is wrong
07:59:24 <Xe> Intolerable: How?
07:59:28 <bigs> Gurkenglas: like, i can see that (\f -> map f . inits) is essentially 'fold f over every "prefix" of a list'
07:59:40 <bigs> but the least fixed point kind of muddles things for me
07:59:40 <YellowOnion> Intolerable, so which package do I get this state from?
07:59:46 <Intolerable> it's (H.img ! A.src) (unpack (avatar user))
08:00:11 <Intolerable> src isn't getting any arguments
08:00:24 <Intolerable> :t Control.Monad.Trans.State.state
08:00:28 <lambdabot> Monad m => (s -> (a, s)) -> StateT s m a
08:00:32 <Intolerable> @hackage transformers
08:00:34 <lambdabot> http://hackage.haskell.org/package/transformers
08:00:56 <YellowOnion> There's also mtl
08:01:15 <Intolerable> pick your poison
08:01:53 <Gurkenglas> bigs, fix turns it into a list where every element is the f-combination of the elements to its left. After the fix, the whole thing has the form ([a] -> a) -> [a]
08:01:59 <Intolerable> :t Control.Monad.State.state
08:02:02 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
08:02:04 <Xe> Intolerable: didn't work, appares to have the same compiler errors
08:02:21 <Intolerable> what does line 27 read now?
08:02:30 <Xe> (H.img ! A.src) (unpack (avatar user))
08:02:41 <YellowOnion> Well it looks like I have something already installed, I just use that
08:02:43 <Intolerable> that's exactly what the first one expands to
08:03:05 <Intolerable> you need to probably do H.img ! A.src (unpack (avatar user))
08:03:28 <Intolerable> otherwise you're trying to do H.img ! A.src on its own
08:03:31 <Intolerable> which is nonsensicle
08:03:33 <Intolerable> *al
08:03:34 <bigs> Gurkenglas: yeah, some type exploration kind of got me there, but i suppose i'm a bit cloudy on what my `f` might look like in order to actually extract something from it
08:04:05 <aweinstock> > let foo f = fix $ map f . inits
08:04:07 <lambdabot>  <no location info>:
08:04:07 <lambdabot>      not an expression: ‘let foo f = fix $ map f . inits’
08:04:09 <bigs> Gurkenglas: for instance if we `let foo = <our fn>`, then `foo sum` yields zeroes
08:04:19 <bigs> which is, i suppose, identity
08:04:22 <bigs> for addition
08:04:22 <aweinstock> @let foo f = fix $ map f . inits
08:04:25 <lambdabot>  Defined.
08:04:36 <bigs> > take 1 $ foo sum
08:04:39 <lambdabot>  [0]
08:04:42 <Gurkenglas> This thing is, inventing words here, termination-stable, meaning that any f at all that always terminates will get you a list that can be lazily evaluated as far out as you want
08:04:43 <aweinstock> > foo head
08:04:45 <lambdabot>  [*Exception: Prelude.head: empty list
08:05:23 <Gurkenglas> head isn't total :P
08:05:28 <aweinstock> I don't see how to get it to do anything interesting (where do the elements come from, other than the base cases of the functions?)
08:05:38 <tzaeru> mmh, I just realized that shader programming too has kind of taught me to try and think more functionally about solving problems related to computing..
08:05:45 <Gurkenglas> > foo ((+1) . product)
08:05:48 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
08:05:59 <aweinstock> > foo product
08:06:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:06:05 <bigs> ahhhhhhh the composition with the +1 is what i was looking for :)
08:06:15 <tzaeru> you've a clearly defined, limited amount of input and output, and clearly defined chain of functions that use the output values of last functions as their inputs
08:06:16 <aweinstock> > foo (product . (1+))
08:06:20 <lambdabot>      No instance for (Show a0)
08:06:20 <lambdabot>        arising from a use of ‘show_M594739462847798118224734’
08:06:20 <lambdabot>      The type variable ‘a0’ is ambiguous
08:06:23 <bigs> > take 10 $ foo ((+ 1) . sum)
08:06:24 <Gurkenglas> :t product
08:06:25 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
08:06:26 <lambdabot> (Num a, Foldable t) => t a -> a
08:06:27 <aweinstock> > foo (product . (1+)) :: [Int]
08:06:30 <lambdabot>      No instance for (Num [Int]) arising from a use of ‘+’
08:06:31 <lambdabot>      In the second argument of ‘(.)’, namely ‘(1 +)’
08:06:31 <lambdabot>      In the first argument of ‘foo’, namely ‘(product . (1 +))’
08:06:34 <Gurkenglas> :t sum
08:06:42 <aweinstock> > foo (product . map (1+))
08:06:42 <Gurkenglas> You can't just add one onto a list.
08:06:47 <lambdabot> (Num a, Foldable t) => t a -> a
08:06:48 <lambdabot>  [1,2,6,42,1806,3263442,10650056950806,113423713055421844361000442,1286493868...
08:07:06 <aweinstock> does lambdabot have a builtin OEIS lookup?
08:07:15 <Gurkenglas> @oeis [1, 2, 4, 8]
08:07:16 <lambdabot>  Sequence not found.
08:07:19 <indiagreen> @oeis 1 2 3
08:07:52 <lambdabot> Plugin `oeis' failed with: <<timeout>>
08:08:06 <bigs> so you need some sort of "incrementer" involved in order to escape your identity
08:08:08 <bigs> essentialy
08:08:09 <aweinstock> "Number of ordered trees having nodes of outdegree 0,1,2 and such that all leaves are at level n." (foo (product . map (1+))
08:08:11 <bigs> essentially**
08:08:26 <bigs> hence sum => 0s and product => 1s
08:08:31 <bigs> Gurkenglas: that sound accurate?
08:08:45 <aweinstock> is it possible to make it return factorial?
08:08:50 <dot_Laptop> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
08:08:51 <lambdabot>  <no location info>:
08:08:52 <lambdabot>      not an expression: ‘let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)’
08:09:06 <aweinstock> > foo (sum map (*2))
08:09:10 <lambdabot>      Couldn't match type ‘[b0]’ with ‘[a] -> a’
08:09:10 <lambdabot>      Expected type: (a0 -> b0) -> (a1 -> a1) -> [a] -> a
08:09:10 <lambdabot>        Actual type: (a0 -> b0) -> [a0] -> [b0]
08:09:11 <aweinstock> dot_Laptop: it's @let
08:09:17 <aweinstock> > foo (sum . map (*2))
08:09:21 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:09:27 <dot_Laptop> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
08:09:31 <lambdabot>  Defined.
08:09:31 <aweinstock> > foo ((1+) . sum . map (*2))
08:09:33 <Gurkenglas> bigs, I don't think you got it yet: Every element is simply f applied to the elements left of it. Apply f to [], you get the first element. Apply f to the list containing only that element, you get the second. etc.
08:09:35 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
08:09:40 <dot_Laptop> > fibs
08:09:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:09:59 <bigs> Gurkenglas: yeah, it's taking shape now :)
08:10:21 <dot_Laptop> Does lambdabot take commands from private messages?
08:10:25 <bigs> i suppose what i was referring to is that product and sum have multiplicative and additive identities hardcoded into them
08:10:37 <aweinstock> > foo ((+1) . product . map (subtract 1))
08:10:41 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
08:10:46 <bigs> which lead to some confusing initial trials
08:10:50 <bigs> but i think i'm gettin it
08:10:53 <bigs> Gurkenglas: thanks!
08:11:28 <Gurkenglas> Not hardcoded :I
08:11:40 <bigs> well
08:11:46 <Gurkenglas> replicate n 0 just happens to sum to 0 for all n
08:12:18 <bigs> doesn't it essentially reduce to `foldl mconcat mempty`
08:12:56 <Gurkenglas> Hm? Explain.
08:13:06 <bigs> and sum is an instance where mempty = 0, mconcat = (+)
08:13:51 * hackagebot kmeans-vector 0.3.1 - An implementation of the kmeans clustering algorithm based on the vector package  https://hackage.haskell.org/package/kmeans-vector-0.3.1 (AlpMestanogullari)
08:14:15 <xplat> anyone here used haxl?
08:16:03 <chpatrick> >foo (\xs -> if null xs then 1 else sum xs)
08:16:14 <kuribas> I mis a function lookupIndexGT in Data.Set :-(
08:16:19 <chpatrick> > foo (\xs -> if null xs then 1 else sum xs)
08:16:23 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
08:16:52 <chpatrick> > foo length
08:16:54 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:17:21 <xplat> kuribas: what would it do?
08:17:53 <kuribas> xplat: find the index of the first element greater than the given element.
08:18:31 <xplat> :t findIndex
08:18:33 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
08:18:50 <xplat> :t findIndex.(<)
08:18:52 <lambdabot> Ord a => a -> [a] -> Maybe Int
08:19:24 <xplat> (findIndex.(<)) 3 [1,2,4,8]
08:19:27 <xplat> > (findIndex.(<)) 3 [1,2,4,8]
08:19:30 <lambdabot>  Just 2
08:19:36 <chpatrick> xplat: you can do it in log time on a map though
08:19:43 <kuribas> xplat: that's not a Set...
08:19:54 <xplat> oh, hrm, right
08:20:06 <Intolerable> :t Data.Set.findMin
08:20:07 <chpatrick> kuribas: lookupIndex doesn't seem so complicated
08:20:08 <lambdabot> S.Set a -> a
08:20:10 <chpatrick> you could probably write it
08:20:33 <chpatrick> it's probably just a one line change actually
08:20:40 <chpatrick> @src S.lookupIndex
08:20:40 <lambdabot> Source not found. I feel much better now.
08:21:29 <kuribas> @src Data.Set.lookupIndex
08:21:29 <lambdabot> Source not found. There are some things that I just don't know.
08:22:16 <Intolerable> :t Data.Set.findGT
08:22:18 <lambdabot> Not in scope: ‘Data.Set.findGT’
08:22:27 <Intolerable> :t Data.Set.lookupGT
08:22:29 <lambdabot> Ord a => a -> S.Set a -> Maybe a
08:24:00 <kuribas> Well, the next best thing is "lookupGT a set >>= flip findIndex set", but it does every comparison twice.
08:25:06 <Intolerable> what are we trying to do here?
08:25:15 <Intolerable> get the index of the smallest element bigger than X?
08:25:18 <kuribas> yes
08:25:29 <Intolerable> foldr it? 
08:26:06 <Hijiri> what I would do is get the set of everything X or smaller
08:26:10 <chpatrick> Intolerable: you can do it in O(log n)
08:26:10 <Hijiri> then take its size
08:26:58 <Hijiri> but you would have to check that you don't just get the whole set
08:26:59 <chpatrick> ah good idea
08:27:28 <kuribas> Hijiri: I can use split, but I still do every comparison twice.
08:27:34 <chpatrick> why?
08:27:55 <chpatrick> :t \x m -> S.size $ fst $ S.split x m
08:27:57 <lambdabot> Ord a => a -> S.Set a -> Int
08:28:12 <chpatrick> split is O(log n)
08:28:32 <juri_> ugh. "the output format is Float, so let's do all of our math that way!"
08:28:44 <YellowOnion> Yay 60fps @ 1000 bodies
08:28:44 <chpatrick> @let lookupIndexGT x = S.size . fst . S.split x
08:28:46 <lambdabot>  Defined.
08:29:03 <kuribas> Hijiri: erm, maybe not...
08:29:10 <chpatrick> lookupIndexGT  5 $ S.fromList [ 1, 2, 3, 7, 8, 9 ]
08:29:16 <chpatrick> > lookupIndexGT  5 $ S.fromList [ 1, 2, 3, 7, 8, 9 ]
08:29:17 <lambdabot>  3
08:29:24 <chpatrick> > lookupIndexGT  3 $ S.fromList [ 1, 2, 3, 7, 8, 9 ]
08:29:26 <lambdabot>  2
08:29:35 <chpatrick> looks right to me
08:30:04 <xplat> lookupIndexLT x xs = lookupGT x xs >>= flip lookupIndex xs
08:31:08 <xplat> lookupIndexLT x xs = do y <- lookupGT x xs; lookupIndex y xs
08:31:41 <kuribas> alright, thanks
08:32:55 <xplat> generally you could have lookupMono and lookupIndexMono
08:33:06 <xplat> which take a monotone predicate
08:33:21 <xplat> if i made a feature request i guess that is what i'd ask for
08:34:31 <xplat> that way you could do the same kind of thing you'd do with list and still get logtime
08:34:53 <xplat> nobody has used haxl?
08:34:56 <Gurkenglas> @let subseqs = map reverse . concat . fix . (([[]] :) .) . (. tail . inits) . zipWith ((. concat) . map . (:)) -- bigs, I'm done :D
08:34:58 <lambdabot>  Defined.
08:35:20 <xplat> Gurkenglas: whaaaaahat?
08:35:27 <bigs> Gurkenglas: awesome!
08:35:39 <Gurkenglas> > subseqs [1..]
08:35:41 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
08:35:46 <bigs> ahhh perfect
08:35:56 <bigs> Gurkenglas: who says point free style isn't readable... lmao
08:36:17 <xplat> mmm, delicious alphabet soup
08:37:28 <bigs> Gurkenglas: not being sarcastic here -- a writeup of that fn would make a lovely quick blog post
08:38:18 <Gurkenglas> Where does one put blog posts if one has no blog?
08:38:35 <bigs> gist.github.com :)
08:38:51 <xplat> you could write it and shop it around as a guest post
08:38:54 <bigs> Gurkenglas: i've done a few little markdown writeups and thrown em up as a gist. tends to work well :)
08:39:02 <bigs> or what xplat said -- not a bad idea
08:40:51 <bigs> Gurkenglas: i'd certainly read it :P
08:48:41 <slack1256> conal: You mentioned yesterday that if you want to learn about denotational design you should read some richard bird books. Care to give further references?
08:48:52 * hackagebot headergen 0.1.1.0 - Creates a header for a haskell source file.  https://hackage.haskell.org/package/headergen-0.1.1.0 (bash0r)
08:49:09 <slack1256> I want to read about design with without yet touching type classes morphisms
08:49:58 <dolio> slack1256: Try Pearls of Functional Algorithm Design, perhaps.
08:51:04 <conal> slack1256: that recommendation was about giving clean specifications, separate from implementations. for denotational design, there's my blog and a talk i gave. you'll find TCMs in there, but maybe you can learn something from the denotations before I rephrase them as TCMs.
08:52:30 <slack1256> yeah I am particulary interested on denotation before the TCMs. I've already read the TCM paper and your talk on 2014, reading the FPR paper
08:53:04 <slack1256> yet I wanted the original work for it, is Pearls of Functional Algorithm Design a good source?
08:53:06 <conal> slack1256: besides the slides at http://conal.net/talks/denotational-design-lambdajam-2015.pdf, there's http://conal.net/talks/essence-and-origins-of-frp-lambdajam-2015.pdf
08:53:36 <conal> slack1256: i assume so (pearls), but i haven't read it. sorry for the dearth of good intros!
08:54:41 <dolio> It's a good book in any case, even if it doesn't teach you exactly what you want to know. :)
08:55:29 <dolio> Bird's approach is typically more like, "write down an obviously correct solution, then successively refine it in obviously correct ways until it performs adequately."
08:55:37 <slack1256> Oh I haven't read the slides from 2015, will read. No probs, the slides are good enough to pitch me the concepts
08:55:54 <phaazon> hey
08:55:59 <phaazon> I have type
08:56:08 <phaazon> data a :. b = a :. b
08:56:16 <phaazon> what is the alignment (Storable’s)?
08:56:23 <phaazon> the max of the alignments?
08:56:52 <rbocquet> the lcm ?
08:57:11 <phaazon> lcm?
08:57:30 <conal> slack1256: as dolio said, bird not only gives a (usually executable) elegant spec; he also transforms it incrementally into an efficient implementation. i use that practice as well when i'm able.
08:57:39 <mauke> phaazon: depends on how you represent it
08:57:44 <rbocquet> least common multiple
08:57:53 <phaazon> mauke: well, contiguous memory
08:57:55 <phaazon> packed
08:58:42 <mauke> alignment a
08:58:48 <mauke> hmm
08:58:50 <mauke> no, wait
08:59:06 <phaazon> is there a Storable instance for (,)?
08:59:21 <phaazon> sounds there is not :(
08:59:40 <mauke> lcm sounds right, but in practice it'll probably be a power of two, so it decays to max
09:00:19 <phaazon> maybe that type is way too more powerful for my need
09:00:57 <Kron> everytime I try to upgrade a haskell-core package, it ends up barfing a "haddock: internal error: /usr/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)" error message at me. For every package.
09:01:04 <mauke> I've only used Storable to FFI with C
09:01:07 <Zemyla> phaazon: Storable is for things with an unambiguous memory representation.
09:01:12 <Kron> along with ghc-pkg saying it can't find the package either
09:01:32 <Kron> is there any way I can reset my package system so it stops looking for ancient ghcs that don't exist?
09:01:34 <phaazon> Zemyla: I know.
09:01:42 <phaazon> I might change the :. type then
09:01:46 <phaazon> thanks anyways :)
09:01:47 <xplat> Storable is for fun
09:02:13 <xplat> succinct data structures ahoy
09:02:16 <Zemyla> I mean, you could probably make an instance of Storable using Generics, actually.
09:02:18 <kuribas> Data.Set doesn't allow duplicate elements?
09:02:38 <Zemyla> kuribas: No, that's the point of Data.Set.
09:02:44 <xplat> kuribas: if it did it would be Data.Bag
09:02:48 <kadoban> kuribas: No, that's basically the point of a set. You might want a multiset … I'm not sure what a multiset is called in haskell though.
09:02:52 <conal> @hackage multiset
09:02:54 <lambdabot> http://hackage.haskell.org/package/multiset
09:03:00 <conal> kuribas: ^^
09:03:02 <xplat> Zemyla: more precisely it's half the point
09:03:27 <Zemyla> Or just do it as a Data.Map, with the number of instances as a Wprd.
09:03:38 <kuribas> canta: thanks!
09:03:44 <kuribas> conal: thanks!
09:03:53 * hackagebot text 1.2.1.2 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.1.2 (BenGamari)
09:04:02 <conal> kuribas: you bet. i think it's implemented as Zemyla suggested.
09:04:17 <YellowOnion> how does someone forkIO and get the result of a pure function?
09:04:51 <xplat> one does not simply forkIO and get the result of a pure function into Mordor.
09:04:53 <Intolerable> what are you trying to do?
09:05:02 <xplat> (one uses par and pseq)
09:05:21 <Zemyla> xplat: The sorting is only to make it easier to keep it unique.
09:05:53 <xplat> Zemyla: no, the sorting is also to abstract over the order of values and to speed up lookups by value
09:06:01 <phaazon> oh
09:06:07 <phaazon> let’s try that.
09:06:16 <xplat> Zemyla: otherwise everyone would have told kuribas to use Data.List
09:06:33 <YellowOnion> Intolerable, I've got a basic do loop to run my OpenGL stuff, and a function that takes a while to compute, I want to do them asyncly
09:06:39 <Zemyla> YellowOnion: https://hackage.haskell.org/package/parallel-3.1.0.1/docs/Control-Parallel-Strategies.html
09:06:41 <codehero> @src words
09:06:44 <lambdabot> words s = case dropWhile isSpace s of
09:06:46 <lambdabot>     "" -> []
09:06:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:06:49 <Intolerable> yeah, you want par / pseq
09:07:13 <Zemyla> Or you use forkFinally, and store the result in an MVar.
09:07:39 <YellowOnion> how do you compose that with some other IO function?
09:07:51 <phaazon> do we have TypeOperators here?
09:08:34 <phaazon> @let data a :. b = a :. b
09:08:36 <lambdabot>  Defined.
09:08:41 <phaazon> :t Free
09:08:43 <lambdabot> Not in scope: data constructor ‘Free’
09:08:51 <phaazon> @let import Control.Monad.Fre
09:08:53 <lambdabot>  .L.hs:57:1:
09:08:53 <lambdabot>      Failed to load interface for ‘Control.Monad.Fre’
09:08:53 <lambdabot>      Perhaps you meant
09:08:56 <phaazon> @let import Control.Monad.Free
09:08:57 <lambdabot>  <no location info>:
09:08:57 <phaazon> @let import Control.Monad.Free
09:08:57 <lambdabot>      The package (profunctors-4.4.1) is required to be trusted but it isn't!
09:09:00 <lambdabot>  <no location info>:
09:09:00 <lambdabot>      The package (profunctors-4.4.1) is required to be trusted but it isn't!
09:09:03 <phaazon> oh noes :(
09:09:05 <phaazon> sorry for spamming
09:09:19 <phaazon> type InfiniteTuple a = Free ((:.) a)
09:10:38 <YellowOnion> Intolerable, I could never get my head around composing par/pseq
09:11:00 <codehero> damn. i'm too stupid to implement words using a fold
09:11:11 <Zemyla> YellowOnion: Try using Control.Parallel.Strategies?
09:12:34 <YellowOnion> Zemyla, I'm not sure how that makes things easier :P
09:13:45 <Welkin> codehero: words = splitOn " "
09:14:20 <xandaros> Hmm, ghc-mod is always complaining about packages being hidden, even though they are in my .cabal file - any ideas?
09:14:21 <Welkin> > splitOn " " "you are old, father william"
09:14:24 <lambdabot>  ["you","are","old,","father","william"]
09:14:33 <Welkin> @src splitOn
09:14:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:14:55 <YellowOnion> I assume pureFunc `par` doIOsomething should work, but it doesn't
09:15:38 <dolio> Is pureFunc a function? Because evaluating a function doesn't usually take much time.
09:15:48 <dolio> Evaluating the result of a function would.
09:16:38 <dolio> But also, you need to share the result of that function for the parallel work to do any good.
09:16:45 <codehero> Welkin: well. it's an exercise for folds, but i think i'll just skip that one
09:17:32 <hodapp> slowly, slowly, I make sense of this ridiculous monadic code.
09:17:34 <Welkin> codehero: you can look at the definition of words
09:17:39 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#words
09:17:39 <hodapp> maybe I should learn monadLib properly.
09:17:50 <y> Welkin: I wouldn't
09:17:56 <Welkin> why not?
09:18:01 <Welkin> I always find it helpful
09:18:12 <Welkin> then you can implement it in a couple different ways
09:18:19 <codehero> wait a second. i can just pattern match for the first two characters using (x:y:rest) right?
09:18:32 <Welkin> sure
09:18:45 <codehero> k. that should make it easier
09:18:46 <Welkin> you can also use dropWhile
09:18:53 * hackagebot moesocks 0.1.0.3 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.3 (JinjingWang)
09:18:55 <Welkin> to drop spaces
09:19:19 <codehero> oh. wait. it's a fold. i only get one character at a time... this is just stupid
09:19:34 <codehero> it's a trick question. it has to be
09:19:35 <xandaros> implementing words using a fold seems a bit weird to me tbh
09:19:59 <codehero> k. then i'm not the only one
09:20:10 <Welkin> what assignment is this?
09:20:13 <codehero> the exercises in real world haskell are a bit too difficult imo
09:20:24 <codehero> Welkin: http://book.realworldhaskell.org/read/functional-programming.html
09:20:28 <Welkin> oh
09:21:29 <codehero> hell. they demonstrated foldl using the adler32 algorithm which uses loads of bit operations
09:21:30 <codehero> why
09:21:32 <codehero> just why
09:21:48 <y> codehero: remember you can have tuples as the accumulators
09:22:16 <y> codehero: and that you can then do "snd (fold ...)" for getting what you actually want
09:22:16 <kadoban> codehero: Why not? Using it for something real seems fine to me.
09:22:54 <codehero> kadoban: well. the problem is not using something real. it's just that with those bit operations, the code is rather hard to comprehend
09:23:50 <codehero> y: hm
09:23:54 * hackagebot clafer 0.4.0 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.0 (mantkiew)
09:24:11 <YellowOnion> dolio, to be precise its a result of a function
09:24:44 <kadoban> codehero: True I guess. It seems better than using it for only really basic stuff though.
09:24:55 <codehero> yeah. sure
09:25:13 <codehero> after all, the book is called real world haskell
09:28:59 <y> codehero: as a small hint, what "things" do you keep while "looping"? 
09:33:52 <Welkin> codehero: I just implemented `words` as foldr in 4 lines
09:34:01 <Welkin> it's simpler than I thought, actually
09:34:47 <xandaros> took me 6 ://
09:35:05 <y> I implemented it with foldr and foldl
09:35:36 <sunnymilk> is there a function to do something like C <$> f <*> f <*> f... with n number of applications of f?
09:35:51 <Welkin> sunnymilk: liftA#
09:35:57 <Welkin> :t liftA2
09:35:58 <shachaf> With what type?
09:36:14 <Welkin> @type liftA2
09:36:24 * Welkin looks for lambdabot 
09:36:26 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:36:28 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:38:02 <sunnymilk> Welkin im a bit confused, how do i get n applications of f <*> ... with liftA2?
09:38:14 <Welkin> it goes up to 8
09:38:18 <Welkin> so, for n up to 8
09:38:23 <Welkin> @type liftA8
09:38:26 <lambdabot>     Not in scope: ‘liftA8’
09:38:26 <lambdabot>     Perhaps you meant one of these:
09:38:27 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
09:38:30 <Welkin> hm
09:38:34 <Welkin> maybe it only goes to 6
09:38:36 <Welkin> @type liftA6
09:38:37 <kadoban> Welkin: He wants to not to have to type 'f' n times though.
09:38:37 <lambdabot>     Not in scope: ‘liftA6’
09:38:38 <lambdabot>     Perhaps you meant one of these:
09:38:38 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
09:38:40 <Welkin> @type liftA5
09:38:41 <lambdabot>     Not in scope: ‘liftA5’
09:38:41 <lambdabot>     Perhaps you meant one of these:
09:38:41 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
09:38:43 <Welkin> @type liftA4
09:38:44 <chpatrick> :D
09:38:45 <lambdabot>     Not in scope: ‘liftA4’
09:38:45 <lambdabot>     Perhaps you meant one of these:
09:38:45 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
09:38:48 <Welkin> @type liftA3
09:38:48 <Welkin> wow
09:38:50 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
09:38:51 <Welkin> what?
09:38:53 <Welkin> only 3?
09:38:58 <Welkin> @type liftM8
09:39:02 <lambdabot>     Not in scope: ‘liftM8’
09:39:02 <lambdabot>     Perhaps you meant one of these:
09:39:02 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
09:39:05 <Welkin> @type liftM5
09:39:05 <chpatrick> do you even liftM8
09:39:07 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
09:39:12 <Welkin> @type liftM6
09:39:13 <lambdabot>     Not in scope: ‘liftM6’
09:39:13 <lambdabot>     Perhaps you meant one of these:
09:39:14 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
09:39:15 <Welkin> hm
09:39:17 <Welkin> only up to 5
09:39:19 <julianleviston> this is fun
09:39:36 <xandaros> lambdabot: Stop spamming! :D
09:39:36 <chpatrick> I can't really think of a good use for n > 3 tbh
09:39:41 <rbocquet> <$><*> is usually more convenient
09:39:59 <mayuresh> hello :)
09:40:08 <julianleviston> mayuresh: hello!
09:40:09 <mayuresh> i am new here, and even newer to haskell.
09:40:21 <julianleviston> mayuresh: welcome!
09:40:22 <maerwald> chpatrick: uhm, a lot actually. But then people just use <*>
09:40:33 <mayuresh> julianleviston: thank you. :)
09:40:51 <shachaf> Welkin: That's way too many lambdabot errors.
09:40:52 <chpatrick> maerwald: yeah exactly
09:40:57 <maerwald> the term "lift" even confuses me, so I just stick to <*> and friends
09:40:58 <Yuu-chan> mayuresh: there is no friendlier place for Haskell newcomers than this room
09:41:04 <kadoban> chpatrick: It's easy to think of some, especially in parsing. If you want some record built from like 10 parsed things, that's not exactly hard to imagine.
09:41:04 <shachaf> Welkin: Please don't abuse the bot.
09:41:07 <sunnymilk> my f :: Parsec Integer and my C :: Integer -> Integer -> ... (7 Integers)
09:41:17 <julianleviston> maerwald:  it might help to know that you’re lifting a function, not a value.
09:41:19 <mayuresh> yuu-chan: thanks for the hint. :)
09:41:22 <chpatrick> I mean I can't really think of a situation where it's better than <$> <*>
09:41:27 <maerwald> julianleviston: doesn't help
09:41:32 <maerwald> maybe I just don't lift ;)
09:41:33 <julianleviston> maerwald: oh, sorry.
09:41:35 <chpatrick> A2 and A3 can be useful for some nice short things
09:41:59 <mayuresh> i have been a programmer for close to 25 years, but it's been 8 years since i last wrote a full-blown program.
09:42:08 * Yuu-chan tends to use infix `liftM` for an unknown reason
09:42:18 <mayuresh> have taken the conscious decision to re-enter the world of software development
09:42:21 <chpatrick> Yuu-chan: why not <$>?
09:42:26 <julianleviston> maerwald: I always think of it as you have this thing that does something to x, and a y… and you need a function that changes that function so it operates on ys.
09:42:35 <mayuresh> wondered if "learn you a haskell" be a good start for someone like me.
09:42:38 <dmj`> mayuresh: well #haskell is the place to be
09:42:47 <julianleviston> maerwald:  so you’re lifting the function into the new context.
09:42:54 <mayuresh> hello dmj. :)
09:43:01 <dmj`> hello :)
09:43:01 <Welkin> mayuresh: use learnhaskell
09:43:03 <xandaros> mayuresh: If you want to get started with haskell, that is the perfect book :)
09:43:05 <Welkin> @where learnhaskell
09:43:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:43:09 <kadoban> mayuresh: IMO not really. In addition to other more subtle problems, it lacks exercises.
09:43:13 <dmj`> mayuresh: https://github.com/bitemyapp/learnhaskell
09:43:14 <maerwald> julianleviston: I understand applicatives and functors and monads and C <$> f <*> g notation, but not what "lift" should mean in that context
09:43:19 <mayuresh> xandaros: thanks. :)
09:43:25 <kadoban> mayuresh: So you can read it and still not be able to write a word of haskell … people don't learn by only reading.
09:43:27 <maerwald> I think the word is just misplaced
09:43:43 <dmj`> mayuresh: haskell keeps software dev fun
09:43:53 <Yuu-chan> chpatrick: I dunno! :( Probably because I usually import a whole Control.Monad, and is too laaazy to add yet another import for a single operator
09:43:57 <julianleviston> maerwald:  does this help? http://mathworld.wolfram.com/Lift.html
09:44:01 <Yuu-chan> s/is/am
09:44:06 <YellowOnion> Intolerable, figured it out -> 89% CPU load
09:44:06 <chpatrick> Yuu-chan: it's in the Prelude since 7.10
09:44:08 <Welkin> mayuresh: what did you do instead of software during that time?
09:44:17 <mayuresh> management
09:44:20 <julianleviston> maerwald: being a general explanation of what lifting is from category theory.
09:44:28 <mayuresh> and i hated every living moment of it. :(
09:44:29 <Yuu-chan> chpatrick: I use Platform
09:44:33 <Welkin> haha
09:44:38 <mayuresh> :)
09:45:00 <Welkin> well, haskell is a great wya to get back into software
09:45:20 <Welkin> it's actually fun
09:45:22 <julianleviston> maerwald: sorry if it’s no help.
09:45:36 <kadoban> Yuu-chan: Why not `fmap` instead of `liftM` anyway?
09:45:44 <mayuresh> welkin: it looks very scary, and that's what i find so attractive. ;)
09:46:02 <Welkin> mayuresh: that is what makes it fun!
09:46:08 <mayuresh> :D
09:46:13 <kadoban> mayuresh: Heh, it's much less scary than it looks actually, but it is fun.
09:46:25 <swish_> Quick question: how to tell cabal/stack to compile *.c file and link it to the project?
09:46:44 <xandaros> Always fun when you look at code that uses a library you don't know yet with lots of operators and you have no clue what is going on :D (Looking at you, lens)
09:47:04 <Yuu-chan> kadoban: Good question
09:47:30 <mayuresh> kadoban: thanks for the encouragement. :)
09:47:32 <nitrix> :t <&>
09:47:34 <lambdabot> parse error on input ‘<&>’
09:47:38 <nitrix> :t (<&>)
09:47:43 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:47:57 <mayuresh> okay, let me start reading up "learn you a haskell" and see how it goes for me.
09:48:05 <nitrix> xandaros: A flipped fmap. They don't seem too bad.
09:48:06 <mayuresh> thanks for the tips. :)
09:48:19 <Yuu-chan> mayuresh: btw, why have you chosen Haskell?
09:48:23 <julianleviston> mayuresh: I would actually recommend something else.
09:48:27 <xandaros> nitrix: Well, plus a million other operators. lol
09:48:28 <kadoban> mayuresh: Ehhh, look at the other guide instead, the learnhaskell one by bitemyapp linked above
09:48:33 <julianleviston> mayuresh: http://haskellbook.com
09:49:01 <nitrix> oh god (^@.)
09:49:04 <kadoban> julianleviston: That's unfinished though, so I'd be wary of recommending it yet.
09:49:11 <nitrix> (^@!?) :: Monad m => s -> IndexedActing i m (Leftmost (i, a)) s t a b -> m (Maybe (i, a))
09:49:17 <nitrix> Whaow. Okay, lens isn't for me yet.
09:49:26 <mayuresh> yuu-chan: the first real language i worked with as "AutoLisp", loved functional programming back then, but now AutoLisp is dead, but Haskell seems good enough. :)
09:49:45 <glguy> nitrix: You don't have to pollute your code with lots of operators to use the lens library effectively
09:49:53 <julianleviston> kadoban: it is.
09:49:55 <xandaros> nitrix: Lens is amazing. Even if you just stick to the basics (view, set, over), it helps a lot
09:49:59 <nitrix> mayuresh: Yuu-chan: And by "good enough", he means ahead of its time, 40 years ago and still today.
09:50:27 <mayuresh> nitrix: spot on. :)
09:50:56 <glguy> nitrix: and if you're actually interested and not just doing the typical look at a lens type and putting your hands up, look at the haddocks if you want to know about something in lens rather than :t
09:51:03 <nitrix> Although, Haskell is like what, 25 years old?
09:51:25 <xandaros> pretty much
09:51:36 <blue_deref> I thought it was like 35 now
09:51:52 <johnw> depends on whether you track the history of its Miranda roots, and the other languages whose ideas folded into its design
09:52:01 <mayuresh> alrighty, time for me to go now, time to hit bed. see you guys tomorrow. :)
09:52:06 <swish_> The moment I will s t a b my code with lenses, I retire
09:52:21 <blue_deref> johnw: that's probably why I thought that
09:52:23 <chpatrick> I think lens can be very nice as long as you don't overdo it
09:52:25 <chpatrick> like point-free
09:52:42 <kadoban> I don't think stabbing things with lenses would work very well. You could try to burn them, like ants.
09:53:12 <swish_> Lens b u r n,, hmm
09:54:02 <julianleviston> multi-focus lenses make things pretty freaking easy that would otherwise be a complete nightmare.
09:54:02 <xandaros> I think lens is amazing. You can either use them everywhere and make it clear someone needs to know lens to understand the code, or stick to the basics and just use them to circumvent haskells shortcomings with records
09:54:07 <julianleviston> never used them in haskell tho
09:54:55 <johnw> prisms are nearly magical too
09:55:04 <hodapp> hmmmm
09:55:38 <Faucelme> Is there a package somewhere with an attoparsec parser for escaped strings?
09:55:52 <maerwald> I find it a bit awkward that we need something that complicated to do stuff that is implemented in languages like java via '.'
09:55:56 <maerwald> but yeah, trade offs
09:56:02 <johnw> Faucelme: that should be rather easy to write
09:56:13 <swish_> Guys, I'm very enjoying your lens party, but I came here to ask something else. How to tell cabal/stack to compile *.c file and link it to the project?
09:56:27 <xandaros> maerwald: It will be fixed eventually, I hope. But lens is not that complicated, really
09:56:33 <maerwald> sure it is
09:56:41 <xandaros> Well, if you look at the whole library it is
09:56:47 <chpatrick> maerwald: it does a lot lot more than that
09:56:51 <maerwald> even if you only look at a single type
09:57:03 <maerwald> doesn't even need to be the whole library
09:57:10 <johnw> swish_: it's in the Cabal manual, I don't remember the flags
09:57:19 <johnw> swish_: you can look at the .cabal file for the gitlib-libgit2 project, it does it
09:57:20 <maerwald> chpatrick: yes
09:57:23 <chpatrick> maerwald: they're pretty much all the same type
09:57:27 <chpatrick> with different constraints
09:57:33 <johnw> inside https://github.com/jwiegley/gitlib
09:57:34 <chpatrick> on the functor
09:57:45 <chpatrick> took me a bit to realize that
09:57:47 <Yuu-chan> Edward Kmett will give a talk about lenses in this August's FPConf in Moscow. If only I'd be there :(
09:58:58 <nkaretnikov> Yuu-chan: you'd also need to pay 6000RUB to attend ;)
09:59:18 <maerwald> I've seen multiple of his talks on lenses, I didn't understand a single one. I've used lenses sparingly when dealing with library APIs... always ignoring their types and just sticking to the usage examples. You can argue all day long about the power, but it's still awkward.
09:59:26 <julianleviston> maerwald:  I guess the problem with “.” is that it’s bound to its context.
09:59:30 <chpatrick> I don't know about that
09:59:44 <chpatrick> I felt that way before I started looking into it
09:59:45 <Yuu-chan> nkaretnikov: that's what actually stops me. Also, 7000 now
09:59:49 <chpatrick> there's definitely a bump on the learning curve
09:59:55 <chpatrick> but that happens in haskell
10:00:20 <maerwald> the fact that you have to learn a whole new DSL for something as basic as what lenses try to solve... IS awkward
10:00:28 <chpatrick> it's not basic at all though
10:00:31 <nkaretnikov> Yuu-chan: haha, that's ridiculous!!!
10:00:48 <chpatrick> for example I have some code that operates on the C++ AST with lens
10:00:57 <chpatrick> that's not just record access
10:01:03 <chpatrick> look at Control.Lens.Plated
10:01:04 <Yuu-chan> nkaretnikov: what's exactly?
10:01:14 <glguy> maerwald: You know lens isn't limited to nested record access right?
10:01:19 <maerwald> yes
10:01:21 <nkaretnikov> Yuu-chan: the price for such a conference
10:02:02 <chpatrick> most things in lens are like a partially-applied traverse with some constraint on the functor you want
10:02:06 <chpatrick> :t traverse
10:02:14 <glguy> maerwald: and for the most part you aren't learning a new DSL, you're learning that if you add Of to the end of a combinator you already knew it becomes generalized
10:02:19 <maerwald> it's as awkward as IO in haskell. Very powerful, useful... and still somewhat awkward ;) Don't misinterpret what I am saying
10:02:33 <shachaf> sOf, kOf, iOf
10:02:36 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:02:47 <julianleviston> maerwald: I don’t think IO is awkward in Haskell, tho.
10:02:52 <chpatrick> me neither
10:03:12 <chpatrick> I think the awkward things in lens are the error messages and the mass of operators
10:03:35 <nitrix> The type signatures too.
10:03:39 <chpatrick> yeah
10:03:39 <xandaros> the types in lens are the worst for me, yeah
10:03:48 <Yuu-chan> nkaretnikov: when FPConf was initially planned to be run in June (and had half the theses), it was 13K. Probably organisers decided that something isn't just right.
10:03:52 <julianleviston> chpatrick: honestly, I think the operators scare people away sometimes.
10:03:58 <glguy> Thanchaf
10:03:59 <chpatrick> they sure scared me
10:04:06 <bollu> if I'm using Lens, can I "construct" an object using the lens? like, my fields all start with _ now on my record type because I'm using makeLenses on the record. So, while constructing the object, can I use the lenses to "assemble" the object?
10:04:19 <shachaf> you're welguy
10:04:26 <chpatrick> bollu: you can make an object from a big tuple
10:04:32 <chpatrick> if you makePrisms
10:04:33 <bollu> and.. how do I even begin to understand Lens?
10:04:42 <bollu> chpatrick: um, demonstration? 
10:05:01 <bollu> I'm trying to pick up Haskell libraries as an ascension to "real world haskell"
10:05:05 <shachaf> The best way to understand lens is to invent it.
10:05:07 <bollu> and Lens is just.. confusing?
10:05:14 <xandaros> bollu: You don't have to use record syntax to construct a record, you can use it like any constructor
10:05:18 <arkeet> or reinvent it.
10:05:19 <chpatrick> bollu: https://hackage.haskell.org/package/lens-4.12.2/docs/Control-Lens-TH.html#v:makePrisms
10:05:37 <bollu> xandaros: yeah, but my fields all start with _ now
10:05:40 <bollu> which is kinda.. ugly?
10:05:48 <nkaretnikov> Yuu-chan: I have no words...
10:05:55 <chpatrick> so it give you a prism that can maybe turn your record into a tuple, or turn a tuple into your record
10:05:59 <arkeet> you can reinvent it as you read, for example, http://artyom.me/lens-over-tea-1
10:06:00 <xandaros> Well, I actually use declareLenses, so I am only left with lenses, without any field accessors
10:06:58 <josephle> shachaf, you too could've invented lens/monads/applicative functors/<exotic haskell pattern here>!
10:07:04 <josephle> I'm sensing a pattern in these tutorials
10:07:22 <xandaros> bollu: Also, what I meant was, if you have A {_q, _w, _e}, you can still do A j k l to construct it
10:07:23 <shachaf> josephle: I didn't say you could've invented lens.
10:07:31 <shachaf> josephle: Just that that's the best way to understand it.
10:07:49 <shachaf> I'm not sure that I could have invented spectral sequences.
10:07:51 <indiagreen> josephle: you're just bitter because you could've invented the “you could've invented <something>” pattern but didn't
10:07:58 <julianleviston> shachaf: isn’t the best way to understand it to feel the pain of the problem that it solves?
10:08:03 <xandaros> I agree on functor, applicative and monad, though. I probably would have eventually come up with it
10:08:16 <josephle> indiagreen, it's true. I'm very jealous I couldn't get my own "You could've invented X" tutorial
10:08:27 <shachaf> http://www.ams.org/notices/200601/fea-chow.pdf is the original.
10:08:31 <hodapp> yeah, I tried to invent FRP myself like 7-8 years ago
10:08:32 <arkeet> you could have invented josephle!
10:08:39 <hodapp> but in retrospect it's definitely a good thing that someone else did
10:09:50 <Yuu-chan> nkaretnikov: though, when tickets are usually paid by companies, here I don't think a mainstream programmer can find a plausible reason for their managers, and for a single enthusiast the price is quite... ridiculous
10:10:32 <josephle> shachaf, is that paper where this snowclone comes from?
10:11:03 <julianleviston> josephle: it is.
10:11:46 <josephle> I learn some history every day
10:11:53 <julianleviston> josephle: if you read the monad one, he references it http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:12:21 <dmj`> you could have invented the 'you could have invented' series
10:13:20 <nkaretnikov> Yuu-chan: yeah, that's what I meant, too.  I guess we should stop offtopic or move to -blah, though. ;)
10:13:56 <Yuu-chan> dmj`: recursive jokes have the most depth, sometimes infinite
10:14:22 <julianleviston> Yuu-chan: self-similar jokes… are.
10:14:35 <bollu> *sigh* lens is so _huge_ :(
10:14:39 <bollu> where's the handbook?
10:15:21 <bollu> on the other hand, Pipes tutorial is _awesome_
10:15:38 <hodapp> I need to learn pipes... someday...
10:16:15 <xandaros> I quite like the lens tutorials on fpcomplete
10:16:21 <julianleviston> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing
10:16:26 <julianleviston> that one?
10:16:40 <xandaros> among others
10:16:53 <julianleviston> bit light on, that one.
10:17:13 <xandaros> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial was pretty good imo
10:18:19 <julianleviston> xandaros: ooh cool I’ll look
10:19:07 <dmj`> Yuu-chan: :)
10:19:23 <julianleviston> ah here’s another reference to “moral correctness” in a mathematical context. I might have to look that up again.
10:19:34 <dmj`> pipes has a lot of type variables
10:20:02 <dmj`> i i' o o' m a, or Pipes a' a b b' m r
10:20:15 <dmj`> a' a b' b
10:20:23 <shachaf> Any bay are folks around here? Should I do a repeat of my lens talk from last year sometime?
10:20:40 <arkeet> you did a lens talk last year?
10:20:44 <shachaf> At BayHac.
10:20:48 <arkeet> ah.
10:20:57 <dmj`> that's the thing about pipes / conduits, you can test them purely, io-streams, not so much
10:21:23 <shachaf> arkeet: You don't count because you're already a lenxpert.
10:21:42 <dmj`> hodapp: pipes would be easier to learn if there were a way to preserve the type aliases for things in ghci
10:22:31 <julianleviston> dmj`: Hm I was reading something the other day about a hot-swappable ghci… 
10:22:45 <julianleviston> dmj`:  I think it did that - all lets persisted thru reloads.
10:23:18 <julianleviston> dmj`:  oh yeah, this, I think… http://chrisdone.com/posts/ghci-reload
10:27:30 <dmj`> julianleviston: yea, this isn't even values though, if you have an Effect in pipes, it's just a type alias on Proxy, type Effect = Proxy X () () X, same with Producer / Consumer. 
10:27:57 <dmj`> julianleviston: to my knowledge the type aliases aren't preserved in ghci
10:28:18 <julianleviston> oh I thought that kept all things you put into ghci. all good.
10:28:55 <Yuu-chan> Can someone tell in few words about pipes to a person with only a limited knowledge of conduits?
10:29:19 <merijn> Yuu-chan: "basically the same, but slightly different philosophical opinion"
10:29:22 <chpatrick> it's by tekmo and has more type parameters :D
10:29:36 <julianleviston> dmj`: that’s a little disappointing, coming from LISP
10:29:59 <merijn> Yuu-chan: The way they deal with early termination differs, pipes tries to be more theoretically conservative
10:30:01 <julianleviston> dmj`: mind you, REPL-driven development in that context has its own set of problems.
10:30:17 <merijn> Yuu-chan: So you need, i.e. pipes-safe to deal with resource freeing or pipes-parse to detect early termination
10:30:37 <merijn> Yuu-chan: Whereas conduit throws it all into a big pragmatic pile (which is better depends on your point of view)
10:30:57 <Yuu-chan> Googled the question. "One of the primary differences between PVC pipe and PVC conduit is that PVC conduit is not tested for pressure the way that PVC pipe is."
10:31:10 <merijn> julianleviston: ghc(i) tries to preserve type aliases where explicitly provided, but doesn't attempt to fold inferred types into aliases where possible
10:31:28 <merijn> Yuu-chan: Pipes has a nice tutorial: https://hackage.haskell.org/package/pipes-4.1.5/docs/Pipes-Tutorial.html
10:31:41 <Yuu-chan> merijn: thank you!
10:32:04 <mauke> dmj`, julianleviston, merijn: you're using different meanings of "preserve"
10:32:55 <merijn> Yuu-chan: I would say that pipes is conceptually cleaner and more elegant, whereas conduits more focussed on pragmatism and speed, but there's not a very big difference, I think
10:32:58 <julianleviston> mauke: no doubt. 
10:33:21 <dmj`> Yuu-chan: the core type of conduit its `data ConduitM i o m r`, and everything else is a type alias on it, i's for input types, o's for output type, m for Base monad (side-effecting or not), r for a return value, it forms a functor,applicative,monad, and a transformer
10:33:56 * hackagebot claferIG 0.4.0 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.0 (mantkiew)
10:35:05 <Yuu-chan> merijn: the explanation of conceptual difference is just what I needed
10:40:52 <Faucelme> Yuu-chan: pipes can be bidirectional.
10:49:57 <merijn> Oh, that too
10:53:57 * hackagebot claferwiki 0.4.0 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.0 (mantkiew)
11:00:14 <latk> Is there a way to read a bytestring into an int, using lenses?
11:00:32 <shachaf> What does it mean to read a bytestring into an int?
11:01:36 <kadoban> latk: A ByteString is just bytes with no inherent encoding or meaning. What meaning do you want to assign to the bytes, and how does that map to an Int? (or do you mean something other than Int?)
11:02:49 <latk> I know that this bytestring is an int. It is returned in a HTTP header. I access this header with a lens, and then wish to do ByteString -> Maybe Int, and then use this function in the lens pipeline that I currently have.
11:03:34 <nkaretnikov> latk: anything wrong with readInt from bytestring?
11:03:51 <kadoban> latk: That didn't answer my question /at all/
11:04:09 <latk> nkaretnikov: I don't know, haven't come across this function before :)
11:04:15 <aweinstock> :t reads
11:04:17 <latk> nkaretnikov: Where does it live.
11:04:17 <lambdabot> Read a => ReadS a
11:04:45 <nkaretnikov> aweinstock: read is slow
11:04:54 <nkaretnikov> aweinstock: because it does much more
11:05:02 <chpatrick> :t folding (fst . readInt)
11:05:03 <lambdabot>     Couldn't match type ‘(Char -> Bool) -> (Char -> Int) -> ReadS a1’
11:05:03 <lambdabot>                    with ‘(f0 a, b0)’
11:05:03 <lambdabot>     Expected type: a1 -> (f0 a, b0)
11:05:11 <nkaretnikov> latk: Data.ByteString.Char8 or Data.ByteString.Lazy.Char8
11:05:18 <chpatrick> :t folding readInt . _1
11:05:23 <nkaretnikov> latk: use fpcomplete.com/hoogle
11:05:37 <latk> kadoban: The ByteString represents utf8 characters that correspond to an integer. I don't think this is hard to infer from what I said?
11:05:42 <lambdabot>     Could not deduce (Foldable ((->) (Char -> Bool)))
11:05:42 <lambdabot>       arising from a use of ‘folding’
11:05:43 <lambdabot>     from the context (Num a,
11:06:18 <chpatrick> :t readInt
11:06:23 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
11:06:26 <chpatrick> ah
11:06:30 <latk> nkaretnikov: I haven't found hoogle on the fpcomplete site to be that great, sadly :s
11:06:34 <chpatrick> :t folding BSC.readInt . _1
11:06:36 <lambdabot> (Applicative g, Contravariant g) => (Int -> g b) -> BSC.ByteString -> g t
11:06:45 <chpatrick> latk: compose with that ^
11:06:55 <latk> chpatrick: Awesome, that works.
11:07:21 <chpatrick> although that doesn't check there's nothing after the int...
11:07:41 <latk> chpatrick: Unless the headers are malformed it shouldn't have to.
11:07:50 <latk> if they are malformed I have bigger problems!
11:08:06 <nkaretnikov> latk: what are you parsing?
11:08:10 <sinelaw> Hey, I'm trying to track down a space leak; heap profiling shows they are ByteStrings, but I can't figure out who/where they are. Tried -hr (retainer) but it is ignoring them
11:08:32 <sinelaw> is there a way to analyze the heap?
11:08:37 <chpatrick> :t folding (\h -> BSC.readInt h >>= \( i, h' ) -> i <$ guard (BSC.null h'))
11:08:40 <lambdabot> (Applicative g, Contravariant g) => LensLike g BSC.ByteString t Int b
11:08:47 <jle`> latk: there are actually a lot of ways to encode an Integer using bytestrings :)  utf8 characters is actually probably one of the more uncommon ways actually ^^
11:08:48 <chpatrick> that checks too
11:08:48 <latk> nkaretnikov: 429 rate limiting response has a Retry-After header, trying to extract that and wait the appropriate time.
11:08:58 * hackagebot headergen 0.1.1.1 - Creates a header for a haskell source file.  https://hackage.haskell.org/package/headergen-0.1.1.1 (bash0r)
11:09:46 <kadoban> latk: Nothing I saw specified an encoding, before your last message to me. How would I know?
11:11:26 <latk> kadoban: I guess you couldn't. Your response just annoyed me a bit, as it seemed like one of these pedantic without being helpful replies. I apologise for being annoyed by it, and understand your point.
11:12:40 <kadoban> Sorry if it seemed pedantic, but yeah I think it's an important question that's often ignored. There's like … 4 obvious ways off the top of my head to go ByteString -> Int, probably /many/ more.
11:18:58 * hackagebot ib-api 0.1.0.1 - An API for the Interactive Brokers Trading Workstation written in pure Haskell  https://hackage.haskell.org/package/ib-api-0.1.0.1 (rbermani)
11:19:33 <aweinstock> I wrote a chess game in Haskell a while ago, a friend of mine recently decided to host it on their server (104.131.30.187:8000), the source is at https://github.com/aweinstock314/chess-server
11:22:17 <dt16> have a question
11:22:30 <aweinstock> dt16: ask it
11:24:03 <hiptobecubic> aweinstock, i think i crashed it
11:24:21 <dt16> wat are the good examples of haskell implementation?
11:24:55 <jle`> congrats aweinstock :)
11:24:57 <aweinstock> hiptobecubic: the person running it appearently didn't run it inside screen (and it doesn't daemonize automatically), so he's restarting it in screen now
11:25:02 <dt16> like are there any think well known application that runs on haskell?
11:25:04 <jle`> dt16: do you mean implementations of the haskell language?
11:25:07 <jle`> ah
11:25:09 <aweinstock> (so I don't think you crashed it)
11:25:12 <jle`> pandoc is sorta famous
11:25:16 <jle`> and so is xmonad
11:25:26 <jle`> facebook has a lot of backend that runs on facebook, and that's famous
11:25:28 <jle`> to a degree
11:25:31 <jle`> *runs on haskell
11:25:55 <Clint> git-annex
11:25:59 <dt16> wat exactly?  can you narrow it down?
11:26:14 <jle`> their spam detection and filtering services internally are written in haskell
11:26:37 <jle`> and a lot of other internal things i believe
11:26:50 <dt16> okey!
11:26:52 <dt16> thanks
11:27:08 <jle`> there are probably a lot more, that's just all i can think of at the top of my head :)
11:27:33 <aweinstock> hiptobecubic: it should be up again now
11:29:10 <dt16> thanks!
11:29:40 <geekosaur> git-annex
11:31:55 <dmj`> haskell is eating the world
11:36:26 <aweinstock> who am I currently playing chess against?
11:37:29 <hiptobecubic> me?
11:37:33 <hiptobecubic> It said you disconnected
11:37:36 <hiptobecubic> or something
11:37:43 <hiptobecubic> I don't know what's going on, there are no identifiers :)
11:37:51 <frerich> aweinstock: I'm currently black playing somebody in white, and I hav eno idae what I'n doing - I already lost my queen :-)
11:37:58 <frerich> I'm reading the code of the HTML page in another tab...
11:38:24 <aweinstock> I'm currently playing white, and took someone's queen early into the game
11:38:34 <frerich> aweinstock: Well damn I guess that would be me then :-)
11:38:48 <frerich> aweinstock: The good thing is - the game seems to work. but the figures look somewhat fuzzy on my screen.
11:39:00 <frerich> I see you used a canvas for that, I wonder whether it's realted to my high-dpi screen
11:39:13 <JamesJRH> Hi.
11:39:30 <aweinstock> the chess pieces are unicode characters, rendered to canvas
11:40:13 <Gurkenglas> @letlpaste 137495
11:40:16 <lambdabot>  Defined.
11:40:24 <Gurkenglas> > subseqs [1..]
11:40:27 <frerich> aweinstock: Sorry for the delay, I'm clicking the figures to enjoy the greenish colors so that I can see where I can move... :-)
11:40:28 <lambdabot>  [[]*Exception: stack overflow
11:40:29 <Gurkenglas> Why do I get a stack overflow?
11:40:36 <aweinstock> frerich: :)
11:41:42 * JamesJRH is planning to go to the 2nd Birmingham Functional Programmers meeting tomorrow night. (And wonders if there's an off-chance that anyone in here is in in Britain and near enough or already planning to go.)
11:42:01 <frerich> aweinstock: It would be nice to be able to see the other players last move. I don't watch the board all the time (still reading your JS code) and it happened a few times that I see that it's my turn but I didn't notice what changed... maybe I'm not a representative player though.
11:42:26 <hiptobecubic> The lag makes it pretty unbearable as well. Really needs some kind of visual feedback as soon as you click
11:42:52 <Gurkenglas> It seems from lambdabot's response that resolving the resulting list to whnf searches infinitely down the tree, but working out with pen and paper what it should do works out fine
11:43:04 <aweinstock> frerich: that sounds like a useful feature, maybe red highlighting under the last piece that the opponent moved?
11:43:05 <frerich> hiptobecubic: It works almost instantly for me. My loss is a mere seconds away ;-)
11:43:11 <aweinstock> hiptobecubic: I'm not noticing any lag
11:44:03 <hiptobecubic> You all have lower latency than I, it would seem.
11:44:08 <frerich> aweinstock: One thing I notice: once it is my turn, it appears that some (random?) piece is selected, which in turn causes some other fields to get highlighted in green.
11:44:14 <frerich> aweinstock: Is there a pattern to that?
11:45:13 <aweinstock> frerich: multiple clicks being (incorrectly) cached, probably (it's a known bug, and I added some workarounds which must've made them less frequent, but not completely gone)
11:45:32 <frerich> aweinstock: And what's clear: a chat function would be nice including a button for an 'ha-ha, blunder!' emote.
11:45:55 <geekosaur> Gurkenglas, is it me or is "subseqs" starting out by trying to reverse an infinite list?
11:46:20 <aweinstock> yeah, chat would probably helpful (to avoid clogging #haskell with chess-related talk) :)
11:47:11 <aweinstock> hiptobecubic: I had security in mind when designing it (not performance), so the client just sends grid coordinates of clicks, and all the logic is server-side
11:47:29 <nitrix> Is ! for strict members in records a Haskell or GHC feature?
11:47:29 <aweinstock> hiptobecubic: so I can see how latency effects could be multiplied by the architecture
11:47:45 <dolio> nitrix: Haskell.
11:47:47 <aweinstock> hiptobecubic: (also, it's sending giant readable JSON blobs, rather than something binary)
11:47:57 <frerich> aweinstock: Another feature which more ambitious (or just curious) features might appreciate: a timer.
11:48:21 <nitrix> dolio: Should I always use it? It seems like a very popular thing. I'll admit every records I see are using those.
11:48:31 <Gurkenglas> geekosaur, no, why'd you think that?
11:48:45 <dolio> No, you shouldn't "always" use it. :)
11:48:54 <nitrix> dolio: Strict datatypes + lazy functions seems idiomatic.
11:48:58 <aweinstock> frerich: what should happen when a timer expires? (presumably a per-turn timer?)
11:49:22 <aweinstock> frerich: since adding a "pass" action changes strategies for chess (I think)
11:49:22 <frerich> aweinstock: Maybe, yeah.
11:49:24 <geekosaur> hm, misparsing a demonstration of why "pointless" is
11:49:31 <geekosaur> probably
11:50:07 <aweinstock> frerich: (that is, there are boards where whoever's turn it is is worse off)
11:50:09 <iteratee> nitrix: there are times when you don't want it. tibbe recently gave a presentation that covered this at zurihack
11:50:37 <nitrix> Do you gain any performance or is it solely for the user's convenience?
11:51:05 <frerich> aweinstock: Since I'm not a terribly interesting opponent, I just checked in another tab and I think using SVG might be useful for generating pretty boards and figures which also scale very nicely.
11:51:06 <indiagreen> iteratee: do you have a link?
11:51:43 <dolio> Putting ! on your data type fields will not automatically make things faster.
11:51:51 <dolio> Not in all cases, at least.
11:52:08 <aweinstock> frerich: I think I did something involving parsing the url to determine an optional size for the tiles (can't be rescaled mid-game though)
11:52:17 <hiptobecubic> aweinstock, sure. The usual way is to have the client anticipate state update and just accept whatever the server finally responds with
11:52:23 <iteratee> https://www.youtube.com/watch?v=_pDUq0nNjhI&index=4&list=PLSIUOFhnxEiAN9-X3OB87OCmoJT36HccP
11:52:52 <dolio> For instance, I'm pretty sure that way back, someone experimented with Data.Map just having ! on the things that were strict, instead of using seq and whatnot. And it got slower.
11:52:57 <jle`> nitrix: the typical rule of thumb is strict fields and lazy spines, but you should always think it through instead of blindly following rules :)
11:53:03 <jle`> and benchmark
11:53:05 <johnw> dolio: great article on unsafeInterleaveIO, you opened my eyes
11:53:12 <iteratee> dolio: exactly it's not a panacea, but for record like types, it's likely better.
11:53:25 <iteratee> nitrix: tibbe finds that strict spines are better for caches.
11:53:29 <Gurkenglas> bigs, https://gist.github.com/Gurkenglas/252f3ce87857aa3ff428 done
11:53:41 <dolio> johnw: Thanks.
11:53:56 <aweinstock> hiptobecubic: as in, do the highlighting/move calculations client-side, and display the updated board after a move, and rollback if the server disagrees?
11:54:20 <dolio> Of course, that Data.Map thing was a long time ago, so I'm not sure it's still true. But you can't just follow a rule without thinking. You have to try things out and figure out what's best.
11:54:44 <Zemyla> Does anyone use MonadZip for anything?
11:54:57 <frerich> aweinstock: http://s8.postimg.org/s7hueqfet/chess_fiasco.png shows what I see - note that the captions at the top are somewhat blurry.
11:55:17 <hiptobecubic> aweinstock, well i'd say don't go that far. The problem is that you click and you have no idea if it "worked" at all. I'd just have the client highlight the square immediately, for example. If the server disagrees it can be unhighlighted later.
11:55:56 <dolio> Similarly, UNPACK isn't always good, even if the field is strict, and if it's an Int. There are occasional cases where it'll be worse.
11:55:58 <aweinstock> hiptobecubic: so just the highlighting, but not speculative board updates
11:56:02 <johnw> dolio: the analogy to concurrency in particular was just the piece I was missing
11:56:40 <hiptobecubic> aweinstock, since the game isn't supposed to feel realtime, yeah. It's still good to let the user know that the game is not just ignoring them, though.
11:57:03 <dolio> johnw: Yeah. I've thought of it that way for a long time. But way back there was no way to get the same kind of interface as interleaving. But then I realized a couple days before I wrote that that IVar is the missing piece.
11:57:22 <aweinstock> hiptobecubic: I already have the move calculation logic in a seperate file from the connection handling, maybe I can GHCJS that and actually reuse the same move calculation code?
11:57:58 <dolio> Or, certain IVar APIs, at least.
11:59:19 <chpatrick> Gurkenglas: personally I really don't like stuff like (. stuff ) .
11:59:55 <hiptobecubic> aweinstock, worth trying?
12:00:05 <chpatrick> I don't think everything should be pointsfree
12:00:16 <hiptobecubic> You still leave the game state on the server entirely so you can't "cheat" in any meaningful way
12:00:41 <aweinstock> hiptobecubic: yup, I'll work on it
12:00:47 <AaronFriel> Hey everyone, thanks for being awesome and answering my questions (when you could) over the past week. I launched a project and applied for funding to see where I can take it. I've been working on a next generation web proxy, and it's entirely written in Haskell.
12:01:02 <jle`> Zemyla: huh, that's interesting.  when did this get into base?
12:01:09 <jle`> congrats AaronFriel :)
12:01:09 <AaronFriel> I can't answer too many technical questions, but you can check it out (and see how it breaks currently) at https://reactr.io
12:01:13 <dfeuer> edwardk: is there a reason the hyperloglog stuff doesn’t offer a coerceConfig :: forall p q . (HLL.ReifiesConfig p, HLL.ReifiesConfig q) => HLL.HyperLogLog p -> Maybe (HLL.HyperlogLog q) ?
12:01:37 <AaronFriel> It's fast, it's fairly reliable, and it only fails to load about half of the modern web ;)
12:01:40 <chpatrick> AaronFriel: gonna beat nginx? :)
12:01:47 <AaronFriel> This isn't that type of proxy
12:01:54 <AaronFriel> This is a web proxy, not a reverse proxy.
12:02:08 <AaronFriel> It can be used as a reverse proxy, but it loads *other websites* in your browser. 
12:02:34 <AaronFriel> So you can do things like, say... Set up an account on Reddit, and share it with other people without them getting access to the password, or even the cookies that authenticate them.
12:02:46 <jle`> Zemyla: ah it looks like it's mostly used in desugaring monad comprehensions?
12:03:08 <AaronFriel> As for "beating nginx", it runs on Warp/Wai, so it already supports HTTP/2 :)
12:03:16 <AaronFriel> I think that means I beat Nginx?
12:03:54 <indiagreen> AaronFriel: is there some way to subscribe for updates?
12:04:23 <jle`> :t \xs ys -> [(x, y) | x <- xs | y <- ys]
12:04:25 <lambdabot> [t] -> [t1] -> [(t, t1)]
12:04:47 <jle`> ^ with -XMonadComprehensions on that would be MonadZip m => m t -> m t1 -> m (t, t1), Zemyla 
12:04:49 <ttt_fff> AcidState: Acid-state does not write your data types to disk every time you change it. It instead keeps a history of all the functions (along with their arguments) that have modified the state. Thus, recreating the state after an unforeseen error is a simple as rerunning the functions in the history log. .... OMG Isn't this slow? Being forced to re-evaluate all functions?
12:04:53 <ttt_fff> how is this ever a good idea?
12:05:26 <johnw> I believe you can checkpoint the database from time to time, to restart the log from a saved state
12:05:28 <bigs> Gurkenglas: cheers!
12:05:45 <mauke> unforeseen errors rarely happen
12:05:46 <johnw> otherwise, welcome to how databases work
12:05:56 <Gurkenglas> Is lambdabot slow to respons lately?
12:06:25 <ttt_fff> johnw: well, I feel taht with most db logs, there's a gc step which then creates a checkpoint you can recover from, so you don't ahve to replay the log from the beginning of time
12:06:37 <ttt_fff> but you're write, there is a checkpoint functionality in acid state
12:06:38 <ttt_fff> Take a snapshot of the state and save it to disk. Creating checkpoints makes it faster to resume AcidStates and you're free to create them as often or seldom as fits your needs. Transactions can run concurrently with this call.  This call will not return until the operation has succeeded.
12:06:39 <jle`> i wonder why there isn't a MonadZip instance for Maybe
12:06:42 <johnw> ttt_fff: you know that acid-state doesn't do this?
12:06:43 <Gurkenglas> :t liftM2 (,)
12:06:46 <lambdabot> Monad m => m a -> m b -> m (a, b)
12:06:56 <ttt_fff> johnw: it was simply not stated in the README
12:07:06 <ttt_fff> johnw: but it is stated in the documentation (the checkpoint functionality)
12:07:14 <Zemyla> jle`: Yes, but even monad transformers don't define MonadZip.
12:07:51 <jle`> it feels like a forgotten typeclass
12:08:17 <johnw> that and MonadFix, and MonadCant
12:08:18 <Gurkenglas> Why does it need a typeclass? mzip = liftM2 (,) works for all monads.
12:08:19 <johnw> MonadCont
12:08:33 <jle`> Gurkenglas: yeah, but it's not the desired behavior for []
12:08:40 <jle`> MonadFix I still use on the daily
12:09:28 <Gurkenglas> Oh, that kind of zip. But it'd work for Maybe, right?
12:09:54 <jle`> yes
12:10:12 <Zemyla> Gurkenglas: It would also theoretically work for Identity. But that's not really zipping.
12:10:29 <Gurkenglas> jle was asking why there isn't a MonadZip instance for Maybe.
12:12:33 <Gurkenglas> Though I guess one could make a case for the instance because it's the only possible one.
12:12:43 <jle`> Gurkenglas: btw the monad laws aren't strong enough to prove the second law
12:12:52 <jle`> if mzip = liftM2 (,)
12:12:59 <jle`> it's an unlawful instance for [], even
12:13:10 <Gurkenglas> Huh, right, didn't think of that
12:13:19 <jle`> > munzip (mzip [1,2,3] [4,5,6])
12:13:22 <lambdabot>  ([1,2,3],[4,5,6])
12:13:24 <jle`> > munzip (liftM2 (,) [1,2,3] [4,5,6])
12:13:25 <lambdabot>  ([1,1,1,2,2,2,3,3,3],[4,5,6,4,5,6,4,5,6])
12:13:57 <Welkin> jle`: o?
12:14:00 <Welkin> er
12:14:04 <Welkin> jle`: o/
12:14:07 <jle`>  \o
12:14:16 <frerich> aweinstock: It might be nice to flash the tab title (is that even possible? maybe by periodically changing the title of the web page?) once it's your turn.
12:14:17 <Nik05> \1/
12:14:47 <Gurkenglas> A game? Where? :D
12:15:13 <bogdanteleaga> is there a way to completely remove haskell from an arch system in order to reinstall it? I installed cabal from git then removed it(or at least the parts I found), then reinstalled it using pacman and now ghc-pkg cannot find 'installed' packages
12:15:13 <nuttycom> Better to use liftA2 in this case anyway
12:15:37 <nuttycom> (and then make sure that the type you're using has the applicative semantics you want)
12:15:42 <Welkin> bogdanteleaga: rm -rf ~./cabal ~./ghc
12:15:56 <Welkin> bogdanteleaga: depending on how you installed it
12:16:27 <bogdanteleaga> Welkin: I ran runhaskell Setup.hs {configure,build,install}
12:16:41 <Welkin> okay
12:16:42 <Zemyla> I can figure out how to do MonadZip for ReaderT, WriterT, and ErrorT, but not StateT or ContT.
12:16:44 <bogdanteleaga> Welkin: then I decided to remove /usr/share/lib/<some-haskell>/cabal*
12:16:48 <Welkin> then it's probably only those directories
12:17:01 <aweinstock> frerich: it looks like it's possible to dynamically adjust the favicon in some browsers, but not others. Maybe putting a unicode chess piece with color based on whose turn it is in the title would be a good idea?
12:17:16 <Welkin> oh, alsolook in  /usr/local
12:17:21 <johnw> Zemyla: isn't is usually just liftM2 zipWith for a transformer?
12:18:02 <johnw> (with appropriate type wrapping)
12:18:04 <frerich> aweinstock: Yeah, something which attracts attention might be nice.
12:18:06 <bogdanteleaga> Welkin: it's still trying to look for cabal-1.23.0.0 when I've got 1.22 installed from the package manager
12:18:31 <Welkin> remove everything through the package manager
12:18:37 <Welkin> then remove anything left over
12:18:47 <Welkin> and reinstall ghc + cabal from the bindist
12:20:26 <Zemyla> johnw: No, that doesn't work at all.
12:20:34 <Zemyla> :t liftM2 zip
12:20:39 <lambdabot> Monad m => m [a] -> m [b] -> m [(a, b)]
12:21:08 <Zemyla> :t mzip
12:21:11 <lambdabot> MonadZip m => m a -> m b -> m (a, b)
12:21:25 <Welkin> :t munzip
12:21:27 <lambdabot> MonadZip m => m (a, b) -> (m a, m b)
12:21:36 <Welkin> never knew about that one
12:21:41 <johnw> ah, I meant liftM2 (,)
12:21:47 <Zemyla> @src munzip
12:21:48 <lambdabot> Source not found. :(
12:21:58 <Welkin> the src function is terrible
12:22:06 <Welkin> someone should fix it :)
12:22:13 <Zemyla> :t \m -> (liftM fst m, liftM snd m)
12:22:14 <lambdabot> Monad m => m (a, r) -> (m a, m r)
12:22:23 <Zemyla> That's what munzip is.
12:22:53 <bogdanteleaga> Welkin: yeah seems I still had /usr/lib/<ghc>/package.conf.d/<git-cabal>.conf
12:22:59 <bogdanteleaga> Welkin: thanks :)
12:23:11 <dyoung_> Zemyla: isn't there a risk that you might run the same action twice?
12:23:18 <Zemyla> But yeah, I really can't see how to do MonadZip for StateT or ContT.
12:24:30 <Zemyla> From Control.Monad.Zip: "munzip mab = (liftM fst mab, liftM snd mab)"
12:24:42 <quchen> Zemyla: Functor is enough to do that operation
12:24:51 <johnw> :t \x y -> StateT $ \s -> runStateT x s >>= \(a, s') -> runStateT y s' >>= \(b, s'') -> return ((a, b), s'')
12:24:53 <lambdabot> Monad m => StateT s m t -> StateT s m t1 -> StateT s m (t, t1)
12:25:20 <quchen> Welkin: It's a static database and you can just send pull requests if you think something's missing.: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source 
12:25:28 <Zemyla> johnw: That's still not zipping. How many times do I have to explain this?
12:26:36 <Gurkenglas> Wouldn't the second MonadZip law follow from uncurry mzip . munzip === id?
12:27:53 <Welkin> quchen: I get 404
12:28:12 <quchen> Welkin: Oh. I need to update my autoreplacement then. :-|
12:28:52 <quchen> int-e: Who's running Lambdabot nowadays? Your repo is down
12:29:40 <indiagreen> quchen: I think it's lambdabot/lambdabot
12:29:51 <indiagreen> quchen: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source
12:29:53 <Welkin> well
12:29:58 <Welkin> it is on lambdabot/lambdabot
12:30:01 <quchen> indiagreen: That's the main repo, but people used to fork it for this channel specifically
12:30:09 <indiagreen> quchen: it has a freenode branch
12:30:14 <quchen> Ah.
12:30:29 <Welkin> https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Source.hs
12:30:32 <Welkin> here?
12:31:08 <johnw> Zemyla: not sure you can implement it for StateT
12:31:09 <johnw> :t \x y -> StateT $ \s -> (\((a, _), (b, s'')) -> ((a, b), s'')) <$> mzip (runStateT x s) (runStateT y s)
12:31:11 <lambdabot> MonadZip m => StateT t m t1 -> StateT t m t2 -> StateT t m (t1, t2)
12:31:21 <johnw> there is no way to "merge" the states from both sides
12:31:55 <frerich> aweinstock: What's the virtual equivalent of offering the other player to shake hands? :-}
12:32:21 <frerich> aweinstock: I could use that feature right now. ;-)
12:32:38 <Welkin> frerich: "gg"
12:32:45 <aweinstock> frerich: as in, a forfeit thingy?
12:33:09 <aweinstock> s/thingy/feature
12:33:12 <frerich> aweinstock: As in, resigning, yeah :-)
12:33:38 <Welkin> frerich: "I concede"?
12:34:02 * hackagebot unagi-streams 0.1.3 - Unagi Chan IO-Streams  https://hackage.haskell.org/package/unagi-streams-0.1.3 (LukeHoersten)
12:34:21 <aweinstock> frerich: if you disconnect, it does show "your opponent has disconnected" with a unicode sadface
12:35:06 <frerich> aweinstock: Tried that now... I thought it was amusing, I haven't played chess in years and had more than one 'Oh, yeah, I forgot you could do that...' moment :-)
12:35:10 <AaronFriel> aaronfriel
12:35:14 <AaronFriel> Oops, ctlr-f failure
12:35:26 <johnw> AaronFriel: I thought it was just self-affirmation
12:35:31 <frerich> aweinstock: I see the game was at least good for a couple of issue tickets in your github project, so I guess it can be considered a win either way ;-)
12:35:31 <AaronFriel> Yeah that too
12:35:41 <AaronFriel> I have to say my name three times for myself to appear
12:36:30 <aweinstock> frerich: :)
12:37:00 <aweinstock> think I might try to do something fancy with splines & arrows for showing the opponent's last move
12:37:00 <frerich> aweinstock: Did the disconnect work? I merely closed the browser tab.
12:37:05 <aweinstock> yes
12:37:50 <aweinstock> "\u2639" === ☹
12:41:56 <ely-se> pfft
12:42:06 <ely-se> U+1F574 is far better than that.
12:42:54 <Hijiri> where can I find this game people are talking about?
12:43:35 <Welkin> Hijiri: it's a mystery
12:44:00 <ely-se> I wrote a type checker and now I have to write the unit tests. :(
12:44:17 <Welkin> ely-se: type checker for what?
12:44:32 <ely-se> Welkin: toy language
12:45:39 <dfeuer> quchen: did you get my message?
12:45:52 <quchen> dfeuer: I did, and it confused me.
12:45:59 <quchen> I'll have to revisit the thread I guess. :-)
12:46:27 <dfeuer> quchen: yeah, I think I must talk too much, so you figured if someone said something it had to be me.
12:46:52 <quchen> dfeuer: You're David Feuer and I don't think that's why I thought it was you.
12:47:05 <quchen> Unless you're not David Feuer, then I would be even more confused.
12:47:10 <dfeuer> I am David Feuer.
12:47:21 <dfeuer> There are others, but I don’t know of any others who do Haskell.
12:48:40 <quchen> I'm in the lucky position to have a very unique name. Source: I know all the people alive with my family name. :-D
12:48:58 <johnw> quchen: likewise
12:49:04 <quchen> Really?
12:49:14 <johnw> every Wiegley in the world is my relative, or by marriage
12:49:18 <arkeet> there are a few people with the same first and last name as me that I don't know :(
12:49:29 <arkeet> fun
12:49:51 <arkeet> my last name isn't terribly common either
12:50:29 <johnw> well, if your last name were Mr. Terribly Common Either, it would be difficult
12:50:53 <brycelane> I have a beginner question: in Scala, I often make type hierarchies, eg sealed trait A; case object FooA extends A; sealed trait B extends A; case object Foo1B extends B; case object Foo2B extends B. Its nice to be able to restrict the result of a function to the descendents of B yet they are still usable in a context where all of A is relevent. So the question: how is the done in Haskell (if it can be) and what do you lose when doing this?
12:52:05 <aweinstock> Hijiri: https://github.com/aweinstock314/chess-server
12:52:22 <Hijiri> thanks
12:54:03 * hackagebot monoidal-containers 0.1.2.2 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.1.2.2 (BenGamari)
12:54:32 <Welkin> aweinstock: HackUMass is happening now?
12:54:48 <Welkin> oh, 4 months ago
12:55:15 <Welkin> make a Go server!
12:55:25 <Welkin> making a Go AI would be more of a challenge
12:55:57 <hodapp> write it in... Go?
12:56:08 <Welkin> ...
12:56:13 <Welkin> no
12:56:16 <Welkin> write it in haskell
12:56:18 <hodapp> yes!
12:56:22 <Welkin> I mean Go the chinese board game
12:56:29 <Welkin> also known as WeiQi
12:56:32 <hodapp> pfffft
12:57:25 <kadoban> Go AIs are pretty interesting nowadays. I wonder how hard it is to do based on modern techniques …
13:00:20 <aweinstock> Welkin: HackUMass happened this April, I'm still working on the project intermittently
13:00:58 <eacameron> Is there a good library for keeping track of units and conversions, specifically I need time (sec, minute, nanosec, etc)
13:02:54 <Welkin> eacameron: perhaps the time package?
13:03:14 <Zemyla> Hmm, do some and many make any sense for types that aren't like parsers and such?
13:03:36 <Welkin> what is `some`?
13:03:47 <Welkin> I only know of `one` and `many`
13:04:08 <kadoban> :t some
13:04:10 <indiagreen> Welkin: some is many1
13:04:10 <lambdabot> Alternative f => f a -> f [a]
13:04:46 <Nik05> one '.', many '*', some '.*'
13:04:50 <Nik05> something like that?
13:05:17 <Welkin> ah
13:05:19 <Welkin> I see
13:05:51 <Welkin> in regex notation, some (many1) is + I think
13:12:03 <mmachenry> Let's say I have an infinite loop that reads IO and prints IO as a result. Sometimes I need to fork and produce said IO later while continuing the loop. Is there a good wait to ensure that if the main loop dies, the child will also be killed? 
13:12:26 <ely-se> Infinite loops don't die.
13:12:39 <deech> Is this the right place to ask about haskell-mode?
13:12:42 <mmachenry> ely-se: Yes. They can raise exceptions. 
13:13:31 <mmachenry> I'm using async and issuing an Async.link ensures that if the child dies, the main loop will also have the exception rethrown. But I'm sure of an easy way to ensure that if the main loop dies, the children are all killed. 
13:13:41 <mmachenry> I'm trying to use ResourceT for this.
13:14:28 <mmachenry> The problem is that if I allocate a resource to Async.cancel any thread that I spawn off, the allocate objects create a space leak. 
13:14:32 <johnw> mmachenry: can you use withAsync outside your main loop?
13:14:50 <johnw> also, resourceForkIO will let you share resources among threads
13:14:56 <mmachenry> johnw: I don't think so but maybe. It's the main loop that's deciding to create them.
13:15:33 <johnw> also, you can have the thread release its resource handle when it dies
13:15:54 <dolio> Doesn't the whole program die when the main thread dies?
13:16:09 <johnw> i assumed he was running the main loop in some control thread
13:16:12 <mmachenry> The actual thing going on here is that my main loop is reading and writing to a TCP client. If the client disconnects, all forked actions it's created need to be reaped immediately. 
13:16:12 <SrPx> Can someone remember me how I type a mutable vector? `new :: ... => Int -> m (MVector (PrimState m) a)`, the type is confusing me. "vec <- (new 10 :: IO (MVector ??? Int))" 
13:16:35 <johnw> mmachenry: well, as dolio said, if this loop is in your main thread, when it dies, bye bye process
13:17:06 <mmachenry> johnw: Well, no the process isn't dying here. 
13:17:17 <mmachenry> johnw: It's just the client's read/write main loop
13:17:29 <johnw> so, when you register your cancellation, you can cancel based on the contents of an IORef, and that way the thread can access this IORef and release the resource before it exits
13:17:37 <mmachenry> The entire server is protected from a crash with a catch making sure that no one client exception will bring down the server.
13:17:43 <johnw> if you're worried about building up tons of no-op cancellations
13:17:44 <dolio> Oh.
13:17:49 <johnw> however, this is sounding like a problem that's been solved before
13:18:15 <mmachenry> So typical TCP server here. Server loop reads in connections, creates a handle, and then some client handler is then forked off and reads and writes to the handle forever.
13:18:22 <dolio> SrPx: RealWorld
13:18:45 <dolio> Or 'PrimState IO'
13:18:53 <johnw> mmachenry: and you want any exception anywhere to bring down everyone immediately, including the control loop?
13:18:54 <mmachenry> That client loop can create a fork which needs to be reaped if the client loop dies for any reason (like the very real possibility of a client disconnecting )
13:19:30 <mmachenry> johnw: No. And exception anywhere brings down the client that raised that exception. Assume that the main server loop is free of exceptions.
13:19:56 <SrPx> dolio: works, thank you!
13:19:59 <mmachenry> johnw: But if the client sends me data I can't parse? Boom kill that client and it's thread and clean up the handle. But the server still is running.
13:20:23 <mmachenry> johnw: The problem there, however, is that if that thread has a child, it will still continue to run. That's bad. I need to clean that up.
13:21:16 <ttt_fff> can if-then-else be implemented in terms of case, or does it's syntactical structure require it be a ghc builtin (due to parsing)
13:22:01 <mmachenry> ttt_fff: I'm pretty sure it needs to be a built in unless you account for template haskell.
13:22:12 <voidzero> debian is unable to update from download.fpcomplete.com
13:22:16 <voidzero> is the server down?
13:22:18 <kadoban> ttt_fff: I don't understand the question. It's syntax … it's part of GHC regardless. What would the difference be?
13:22:25 <voidzero> http://download.fpcomplete.com/ < looks like some issue
13:22:44 <ttt_fff> ite :: Bool -> a -> a -> a // this can be writen in user space as a libraryfunction
13:22:45 <mmachenry> kadoban: I think he means if we had Haskell without if-then-else could we write it?
13:22:55 <ttt_fff> mmachenry ++
13:23:13 <kadoban> Ah
13:23:28 <mmachenry> kadoban: I think the answer is no simply because it has specially words as syntax. But the spirit of that functionality could easily be written as a function. You just don't get the nice syntax.
13:23:58 <mmachenry> ttt_fff: I haven't used Template Haskell but it might be able to implement that. 
13:24:19 <Gurkenglas> @letlpaste 137502
13:24:21 <lambdabot>  Defined.
13:24:23 <Gurkenglas> > nnot True
13:24:26 <lambdabot>  False
13:24:30 <mmachenry> Anyway, johnw did I make that clear, or are you still confused about the TCP server exceptions I'm working with?
13:24:31 <Gurkenglas> I don't see the problem
13:24:39 <ttt_fff> mmachenry: well, you can do all syntactical things with TH, since by definition, you can rewrite stuff
13:24:48 <mmachenry> Perhaps you don't know how to fix this issue and you've given up which is cool too. :)
13:25:02 <kadoban> mmachenry: Yes, you could write the same thing as just a function 'if', but then you don't get 'then' and 'else'
13:25:25 <Welkin> you can do anything with case expressions
13:25:43 <mmachenry> ttt_fff: Well, I would not say by definition certainly and there are limits to all templating systems. That being said my guess would be that's it's powerful enough. It's not regexp replace. It's not ultimately flexible for good reason. 
13:26:17 <verement> > let f x = x + (case even x of False -> 2; True -> 3) in map f [1..4]
13:26:19 <lambdabot>  [3,5,5,7]
13:26:22 <mmachenry> Welkin: No. Not anything. You can't recreate the syntax of an if-then-else with case. 
13:27:24 <Welkin> why not?
13:27:53 <Welkin> case pred x of True -> ...; False -> ...
13:28:15 <mmachenry> Because you can't insert a bareword "then" and "else" into an arbitrary expression and have it parse properly. 
13:28:15 <johnw> mmachenry: I had to step away to attend other things
13:28:34 <mmachenry> johnw: Nonsense. I'm more important. :-P
13:28:49 <johnw> I'm not saying you're wrong :)
13:29:30 <ttt_fff> johnw: how would you compare something like acid-state vs typical strorage backends of postgresql / mysql / ... ?
13:29:32 <mmachenry> Welkin: That gives you the functionality of the if-the-else, not the syntax. 
13:30:03 <johnw> ttt_fff: acid-state keeps it all in memory
13:30:55 <ww> you *can* do completely arbitrary parsing of strings with quasi quotes...
13:30:58 <johnw> plus, there is a massive maturity difference
13:32:12 <Peaker> johnw: did you get my msg about the AST trick working nicely? :)
13:32:23 <johnw> i did, nice to hear it
13:32:51 <Peaker> instead of type-level tuple (ast1, ast2),  use an isomorphic: (2 -> AST) (i.e: a type-param::2 for a GADT)
13:42:26 <Peaker> if I have: data AST tag ast where A :: AST SomeTag ast ; Extend :: Foo -> ast (CompositeTag c) -> AST (CompositeTag c) ast ;  and I write: instance (Pretty (ast SomeTag), Pretty (ast (CompositeTag c))) => Pretty (AST tag) where .. I can't use the Pretty (ast (CompositeTag c)) constraint because "c" seems to be existential instead of universal in my instance context :(
13:44:05 * hackagebot haskellscrabble 1.1 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.1 (happy0)
13:45:02 <Peaker> In other words: If a GADT has a polymorphic index type and a polymorphic field according to it, you can't really get an instance constraint for it like the above..
13:54:32 <voidzero> the fpcomplete debian repo, is it down for everyone or just me?
13:54:58 <broma0_> Can someone help me understand why "monads capture key architectural designs in types" (http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell)
13:58:06 <voidzero> hmm, seems the problem is not with fpcomplete, never mind me
13:58:14 <Peaker> broma0_: your application requires certain language capabilities (perhaps some global state, global env/config, perhaps it can output certain things, etc). The set of capabilities is described by the monad and tells you a lot about the architecture
13:58:28 <JamesJRH> How much cryptography is implemented in Haskell?
13:59:09 <JamesJRH> I've recenly been told about Poly1305, which I find very interesting.
13:59:39 <JamesJRH> But I wonder how to use it / implemented in Haskell.
13:59:50 <JamesJRH> Or whether anyone already has done that.
13:59:54 <Peaker> I think cryptography usually cares about timing attacks, so it's best to write it in a language that can give timing guarantees (sometimes assembly..)
14:00:07 <JamesJRH> Oh.
14:00:13 <Peaker> (not all cryptography, but at least some)
14:00:23 <ttt_fff> all crypto cares about timing attacks
14:00:33 <Peaker> ttt_fff: an offline crypto thing you run locally doesn't
14:00:34 <kadoban> There's libraries for a lot of the common crypto that I've looked for, but I don't know how well analyzed any of it is.
14:00:41 <kadoban> ttt_fff: That's very untrue.
14:01:06 <ttt_fff> crypto is about hiding secrets
14:01:08 <ttt_fff> timing attacks leak info
14:01:11 <hodapp> ohh, *that's* why various Galois projects use monadLib... its maintainer is a Galois employee, for one thing
14:01:13 <dyoung_> yeah, unfortunately the GC behavior of GHC might make it a bit tricky to do crypto in Haskell overall
14:01:15 <ttt_fff> therefore, all crypto care about timing attacks
14:02:01 <JamesJRH> Also, timing attacks could be avoided by decoupling the timing from the algorithm, such as by adding jittered delay.
14:02:07 <oconnore> there are more than just timing attacks... cache analysis, branch prediction, power usage
14:02:14 <JamesJRH> Yep.
14:02:18 <oconnore> JamesJRH: no, you just bump the sample size to account for jitter
14:02:40 <dyoung_> oconnore: even auditory analysis!
14:03:11 <JamesJRH> oconnore: But you could delay all operations to be as long as the longest.
14:03:18 <dyoung_> http://www.tau.ac.il/~tromer/acoustic/
14:04:21 <JamesJRH> As in, the jitter time is from the start of the operation, rather than since it finishes.
14:04:24 <broma0_> Peaker: so each major component of your app could be wrapped in a monad that contains the "extra" functionality required by the component?
14:04:44 <dyoung_> JamesJRH: how do you know how long the longest is and how do you know how long a given operation will be to know how much to delay it by?
14:04:59 <oconnore> JamesJRH: for fixed length inputs, assuming that you can't use trickery to bump it over the edge of the timer, sure
14:05:23 <JamesJRH> Indeed.
14:05:53 <JamesJRH> dyoung_: Depends. For some things you can't.
14:06:08 <Peaker> broma0_: if it can be composed with the monad of the rest of the application, yeah
14:06:22 <SrPx> Is anyone able to spot what is wrong with my derivingUnbox definition? http://lpaste.net/137505
14:06:22 <JamesJRH> But anyway, can I use Poly1305 in Haskell?
14:06:26 <oconnore> where "some" = any dynamically sized input = basically all applications
14:06:49 <Peaker> broma0_: another technique is not using concrete monads but type-classes: so each component can be exposed only to a subset of the monad's capabilities via a type-class
14:07:04 <JamesJRH> Oh...
14:07:07 <Peaker> broma0_: and then the whole application does use a single powerful monad, but you see exactly what power is used by each little component
14:07:09 <JamesJRH> http://hackage.haskell.org/package/cryptonite-0.5/docs/Crypto-MAC-Poly1305.html
14:07:15 <voidzero> \o/
14:07:20 <JamesJRH> I didn't notice that.
14:07:52 <oconnore> JamesJRH: there are a few sodium ffi's as well
14:09:50 <catgocat> Can anyone explain me the *why* of difflists? LYAH writes difference lists, but never explains why.
14:10:03 <JamesJRH> oconnore: So wait, is that like written in Haskell or is it some other language with timing guarantees but using the FFI?
14:10:03 <catgocat> Is it the same as doing right list appending?
14:10:18 <johnw> catgocat: difflists are where, instead of appending lists, you compose functions that append lists
14:10:31 <johnw> this way, you can right-associate the final series of appends
14:10:58 <JamesJRH> I think it's all Haskell, isn't it.
14:11:10 <catgocat> so is it the same as using list ++ recursive-list?
14:11:23 <catgocat> can you give me an example?
14:11:29 <Peaker> catgocat: if your list appends are right-associative anyway, it wouldn't matter
14:11:31 <JamesJRH> Hmm, actually not.
14:12:13 <dyoung_> capisce: left associated appends are generally less efficient
14:12:20 <dyoung_> ^ catgocat
14:12:47 <catgocat> so right associated appends are the same as using difflists?
14:12:48 <JamesJRH> {-# LANGUAGE ForeignFunctionInterface #-}
14:12:56 <johnw> > ("Hello " ++) . ("Kind " ++) . ("World" ++) $ ""
14:12:58 <JamesJRH> I've never used the FFI before.
14:12:58 <lambdabot>  "Hello Kind World"
14:13:27 <johnw> (.) is O(1), (++) is O(n), where n is the size of the list on the left
14:13:42 <johnw> so, a left-associated series of ++ will pay the same n over and over again
14:14:05 <catgocat> johnw: can you write some example on lpaste?
14:14:08 <catgocat> some very simple example
14:14:10 <johnw> examples of what?
14:14:18 <johnw> that was an example just now
14:14:20 <catgocat> of left associative vs right associative
14:14:32 <catgocat> I still don't understand, can you try to be more clear?
14:14:37 <johnw> ("a" ++ "b") ++ "c" is left associated
14:14:42 <catgocat> Why does left associative have to evaluate everything again and again?
14:14:53 <johnw> so, "a" ++ "b" will create a new "a"
14:15:01 <johnw> ("a" ++ "b") ++ "c" will create a new "ab"
14:15:01 <catgocat> "ab"
14:15:06 <johnw> so, we had to re-create "a" twice
14:15:12 <johnw> "a" ++ ("b" ++ "c")
14:15:14 <Peaker> catgocat: it's not about evaluating again and again. It's about having to copy the entire list, just to be able to replace the final [] constructor with a reference to another list
14:15:14 <johnw> creates a new a, and a new b
14:16:10 <Peaker> catgocat: lists are immutable linked lists.  You have : constructors pointing to more : constructors finally pointing to [].  So to append a++b, 'b' can remain unchanged. But 'a' has to be copied in its entirety, just so its end can be replaced with a reference to b
14:16:20 <oconnore> JamesJRH: the latter. The library you linked to is also written in C, although I have no confidence that the author has accounted for side channels.
14:16:42 <catgocat> ("a" ++ "b") ++ "c" first constructs "ab" and then constructs "abc"
14:16:49 <catgocat> or am I wrong? :/
14:16:49 <Peaker> catgocat: so the trick is: instead of creating a big "a" and then append it, you build "a" with the "thing it will be appended to" in mind in the first place
14:16:50 <quchen> catgocat: I suggest evaluating ("ab" ++ "cd") ++ "ef" and "ab" ++ ("cd" ++ "ef") by hand, manually, in a text editor or on a piece of paper. Then compare which one took more steps. This way of reasoning about Haskell programs is pretty common (and you get used to it very quickly, it looks a bit tedious in the beginning).
14:17:21 <Peaker> catgocat: first constructs "ab", and then copies "ab" to suffix it with "c"
14:17:37 <Peaker> @src (++)
14:17:37 <quchen> Being able to do that sort of manual evaluation is one of the great benefits of Haskell if you ask me.
14:17:37 <lambdabot> []     ++ ys = ys
14:17:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:17:38 <lambdabot> -- OR
14:17:38 <lambdabot> xs ++ ys = foldr (:) ys xs
14:17:59 <catgocat> quchen: I have done it as you say, and both take the same steps, first evaluate what is in the parentheses and then concatenate
14:18:11 <Peaker> catgocat: see how (++) works internally
14:18:17 <Peaker> catgocat: don't take it as a primitive/given
14:18:18 <johnw> you have to unfold ++
14:18:52 <johnw> alternatively, define your own version of ++ that adds a tracing statement for each cons cell it creates
14:19:30 <johnw> i.e.: [] ++ ys = ys; (x:xs) ++ ys = trace "cons made" (x : (xs ++ ys))
14:20:08 <quchen> catgocat: Now review your code and see how often you passed by the "a" when doing the evaluation.
14:20:51 <quchen> catgocat: You'll find out you had to do that twice (and likewise for the "b"). In other words, there were two steps doing something like ('a' : XXX) → 'a' : (XXX).
14:21:15 <catgocat> quchen: aaaaaaaaaaaaaaaaaaaah I see
14:21:20 <quchen> When you associate to the right, this is only done once. And those steps are what costs performance.
14:21:30 <catgocat> first "a" gets appended to "b", and then the list has to be appended again to "c"
14:21:42 <catgocat> which means the list has to be loop over 
14:21:45 <johnw> yep
14:21:53 <Welkin> > length “haskell”
14:21:55 <lambdabot>  <hint>:1:8: lexical error at character '\8220'
14:21:58 <Welkin> aw
14:22:05 <Welkin> it doesn't work with fancy quotes
14:22:08 <Welkin> only double primes
14:22:35 <verement> double prime is another character, probably not what you're thinking
14:22:36 <Welkin> > length "“haskell”"
14:22:39 <catgocat> but as with "a" ++ ("b" ++ "c"), doesn't "bc" has to be looped over too? or only the left argument is?
14:22:39 <lambdabot>  9
14:22:49 <Welkin> " is double prime I thought
14:22:55 <Welkin> it is not a quote mark
14:23:02 <verement> ″
14:23:07 <Welkin> hm, okay
14:23:40 <verement> " is quotation mark
14:23:45 <quchen> Welkin: Debatable. Typographers love to be trolled by this. Since computers have " on their keyboards they became double quotes, end of story.
14:24:16 <quchen> Haskell demands ASCII double quotes as string delimiters and nothing else.
14:24:19 <Welkin> lol
14:24:25 <catgocat> but as with "a" ++ ("b" ++ "c"), doesn't "bc" has to be looped over too? or only the left argument is?
14:24:36 <johnw> only the left argument is
14:24:41 <johnw> the right argument is shared
14:24:51 <johnw> that's what immutability gains you
14:26:28 <quchen> catgocat: The key point here is that each time you check "is there another character" or "is there a (:) left" you pay a price. It's a low-level "if it's cons then … else …".
14:27:11 <quchen> So you'd like to minimize the number of times you have to switch on the constructor. Left-associating ++ is the bad way.
14:27:15 <broma0_> Peaker: Can you expand on this other technique? You have one "all powerful" monad and then typeclasses for each component? or typeclasses for each layer of the monad?
14:27:38 <catgocat> but why does (++) only do this for the left argument?
14:28:23 <Peaker> broma0_: someComponent :: SomeMonadCapability m => ... -> m Foo     
14:28:38 <Peaker> broma0_: someComponent can only use whatever capabilities are advertised in SomeCapabilityMonad, no matter how powerful the "m" actually is
14:28:45 <quchen> catgocat: (++) does not have to inspect its right hand argument at all. It does "is the left arg empty? Yes? Then prepend it to the rest. Else the result is only the rest."
14:28:48 <Peaker> broma0_: a different component might use the same "m" but via different constraint
14:29:01 <catgocat> quchen, probably with (:) 
14:29:05 <catgocat> right?
14:29:06 <quchen> catgocat: When you look at the source of (++) you won't see it considering its right argument's shape at all.
14:29:08 <quchen> ?src (++)
14:29:08 <lambdabot> []     ++ ys = ys
14:29:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:29:09 <lambdabot> -- OR
14:29:09 <lambdabot> xs ++ ys = foldr (:) ys xs
14:29:12 <broma0_> Peaker: thats really cool.. is "m" an arbitrary monad, or this "all powerful" one?
14:29:17 <quchen> ys is simply passed through here.
14:30:47 <Peaker> broma0_: whatever the caller chooses
14:30:52 <Peaker> broma0_: that satisfies the class
14:31:31 <Peaker> broma0_: so maybe your "main" has a specific Monad like GodMonad it's using, and it composes the various components, they all see just the relvant subset of functionality of GodMonad
14:31:39 <Peaker> broma0_: but main seamlessly composes them on the same "m"
14:31:49 <Peaker> broma0_: easier to compose code that actually uses the same "m"
14:31:57 <sbrg> Anyone know of a guide/article on using conduit that takes the conduit-combinators package into account as well?
14:32:31 <broma0_> Peaker: when you say "compose the components" im thinking 'ReaderT X (StateT y IO) a'
14:33:08 <broma0_> so something like - type GodMonad = ReaderT X (StateT Y IO) a
14:33:54 <JamesJRH> oconnore: Indeed. Surely though there are security benefits in implementing in Haskell in terms of maintainability, the guarantees of the type system, etc. to reduce the chance of bugs that create security vulnerabilities. Cryptography is much about functions so surely a functional language would be well-suited, if timing and other cryptanalytic weaknesses could be addressed.
14:33:57 <broma0_> and then have a class like 'class SomeComponent where launchMissles :: GodMonad ()'
14:34:23 <Peaker> broma0_: ah, I meant binding stuff together as composing them (which is indeed less clear)
14:35:39 <broma0_> Peaker: is there a dead simple example you can provide to illustrate what you're saying? (similar to how i put 'ReaderT X (StateT Y IO) a'
14:41:03 <dyoung_> broma0_: (a generalized version of that already exists, with Writer thrown in for good measure: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-RWS-Lazy.html)
14:42:49 <catgocat> what is a function that I can write to make list appending right associative?
14:42:52 <catgocat> I've tried
14:42:55 <catgocat> -- Right associative? (++-) :: [a] -> ([a] -> [a]) (++-) s = (++s)
14:44:02 <johnw> you can't control the association in ++
14:44:09 <broma0_> dyoung_: Wow. That is the GodMonad
14:44:11 <johnw> i can always use your function to write ("a" ++ "b") ++ "c"
14:44:33 <catgocat> how to write something that does right associative?
14:44:36 <verement> (++) is already right-associative
14:44:40 <johnw> you use a difference list
14:44:43 <catgocat> what
14:44:53 <catgocat> isnt ++ left associative?
14:45:05 <johnw> the association problem here isn't with ++
14:45:26 <bitemyapp> I mean, it's not anyway.
14:45:29 <johnw> the ++ operator is right-associative
14:45:56 <johnw> but that doesn't mean it isn't used in situations where the ultimate placement of parentheses results in left-association
14:45:58 <johnw> i.e.
14:46:08 <johnw> "a" ++ "b" ++ "c" == "a" ++ ("b" ++ "c")
14:46:20 <Gurkenglas> When any append of two lists is evaluated to whnf, the head must be separated from the tail. This information is always in the left side of the append, the implementation doesn't matter.
14:46:21 <johnw> however, I can still write ("a" ++ "b") ++ "c", and the costs are worse
14:46:36 <quchen> (++) is *parsed* as if it was right-associative. When you parenthesize manually, you can still explicitly use it in a left-associative way of course.
14:47:01 <quchen> Operator precedence and all that is only ever used during the parsing stage.
14:47:11 <catgocat> johnw: for a recursive function that yields list, what is more expensive func ++ list or list ++ func
14:47:22 <johnw> what does that difference mean?
14:47:22 <catgocat> I supose the first one
14:48:28 <broma0_> dyoung_: so using that, any idea how Peaker meant to use "someComponent :: SomeMonadCapability m => ... -> m Foo" to organize a large application?
14:48:40 <Gurkenglas> (++) runs in O(length of the left argument). So you want whichever of the two is longer on the right side.
14:49:29 <catgocat> Gurkenglas nice
14:49:43 <dyoung_> broma0_: didn't keep track of the context of the conversation, but maybe using things like MonadWriter for SomeMonadCapability. Then you know that someCapability only requires the Monad to be able to be used as a Writer
14:50:49 <Peaker> broma0_: it's just (potentially) very high-level constraints you place on your APIs.. since they're very high-level, they may help you understand the architecture/organize
14:51:49 <catgocat> How can I make a list that appends always right associative ?
14:51:54 <catgocat> Difference Lists?
14:52:01 <Peaker> broma0_: for example, I had a parser that could follow file paths to read them too. I wanted to memoize it correctly. So instead of having the parser use IO, it used MonadReadFile class to read files. It couldn't do IO. So I knew that if my provided monad instance does the read-files while tracking inputs, my memo must be correct (high-level guarantee)
14:52:06 <quicksilver> yes. That is precisely their purpose, catgocat 
14:52:34 <Peaker> broma0_: so a big part of the application is the parser - and the monad typeclass helped me organize in the sense that it was restricted in its access to the outside world
14:53:15 <catgocat> quicksilver, what is the deal with difference lists? if I am appending the longest list on the right, then what's the difference?
14:53:33 <broma0_> Peaker: so what would the type of an api function be? parse :: MonadReadFile a -> a String?
14:54:04 <Peaker> broma0_: parse :: MonadReadFile m => FilePath -> m ParsedResult
14:54:09 <quicksilver> catgocat: nothing at all. The longest list will still be on the right. But it does ensure that if you do two appends, they are executed right associatively.
14:55:30 <deech> x-post from #haskell-mode "I recently started having an issue where buffer switching between Haskell buffers hangs for a few seconds and then comes back with an error like: ghc-check-syntax: ghc process may have hung." 
14:55:47 <deech> Any ideas appreciated. Can't reproduce the issue consistently.
14:56:20 <bitemyapp> deech: ghc-mod yeah?
14:56:25 <deech> yeah.
14:56:28 <deech> It's there.
14:56:33 * Peaker happily uses ghci-ng 
14:56:36 <bitemyapp> deech: is that the ghc mode you're in when you switch buffers or is it hlint?
14:56:44 <broma0_> Peaker: interesting. so calling parse inside of a monad stack with a base of IO would give me the power of my god monad and control over the functions called from it?
14:56:53 <bitemyapp> deech: I dropped ghc-mod because it had too many problems and was slow, I went to using hlint in my Emacs alone.
14:57:07 <bitemyapp> deech: regardless, the only people who will know what's going on are the ghc-mod devs.
14:57:15 <Peaker> broma0_: yeah, or instead of god monad, whatever type-class constraint you have in scope
14:57:23 <bitemyapp> deech: because your mode is 'ghc not 'haskell-mode and the ghc-mod people are the ones that know why it might be hanging.
14:57:29 <deech> bitemyapp: So ghc-mod is the culprit.
14:57:35 <bitemyapp> deech: it almost always is, yes.
14:57:39 <Peaker> bitemyapp: yes, ghc-mod was terrible.  ghci-ng is instantenous, fast, jumps to definitions, etc. 
14:57:46 <broma0_> Peaker: and in the case of this example, the monad or class constraint would have to include IO
14:57:53 <deech> bitemyapp: Thanks! Will uninstall.
14:58:07 <bitemyapp> deech: ditch -- (require 'ghc) in your emacs config and it'll clear up :P
14:58:11 <Peaker> I really recommend setting up ghci-ng instead. It sped up my Haskell programming by 5x I think :)
14:58:27 <deech> Peaker: Sold!
14:58:30 <Peaker> broma0_: the class constraint doesn't have to include IO, the real monad that will implement it will
14:58:53 <Peaker> bitemyapp: deech: take a look at https://github.com/chrisdone/emacs-haskell-config
14:58:54 <deech> Peaker: Does it work well for Haskell/C/C++ hybrid projects too? 
14:59:12 <Peaker> deech: It's a haskell-mode thing. I don't think it affects C/C++ handling in any way
14:59:24 <Peaker> deech: not sure what features are expected for such a hybrid
14:59:36 <bitemyapp> Peaker: I know about ghci-ng and done's config.
14:59:50 <bitemyapp> Peaker: I stopped using ghci-ng before because it was too unstable at the time, but if you say it's stable, I may try it again.
14:59:54 <bitemyapp> Peaker: do you know if it works with Stack?
15:00:05 <bitemyapp> Peaker: I also stopped ghci-ng because it seemed like people were moving over to ide-backend.
15:00:20 <broma0_> Peaker: I'm not getting what you mean by "the real monad that will implement it"
15:00:22 <Peaker> bitemyapp: no idea about stack
15:00:36 <Peaker> bitemyapp: but chrisdone is at FP complete, I think, so I'd expect it to play nicely
15:01:35 <Peaker> broma0_: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Makefile/Parser.hs#L614 <-- no IO there, that's the point.  A caller might itself be type-class constrained similarly (but isn't, in my case)
15:01:52 <Peaker> bitemyapp: I don't know what people are doing, but ghci-ng is far far better than nothing+hlint :)
15:02:03 <Peaker> bitemyapp: even if it was abandoned I'd use it
15:02:18 <bitemyapp> Peaker: I wouldn't expect that given he stopped working on ghci-ng last I looked, but okay.
15:02:52 <Peaker> bitemyapp: my feedback loop for type errors anywhere in my program is <200ms (usually much shorter -unnoticeable)
15:03:02 <bitemyapp> That's quite good.
15:03:07 <bitemyapp> better than my current cabal repl reloading.
15:03:12 <bitemyapp> er, stack ghci
15:03:13 <bitemyapp> whatever.
15:03:16 <Peaker> bitemyapp: does your cabal repl jump to errors?
15:03:24 <bitemyapp> jump?
15:03:32 <bitemyapp> it's stack ghci in a terminal mate :)
15:03:34 <Peaker> bitemyapp: set your cursor to the exact position of the error
15:03:41 <tromp_> > 1<<20
15:03:43 <Peaker> bitemyapp: well, that's part of the feedback loop :)
15:03:44 <lambdabot>      Not in scope: ‘<<’
15:03:44 <lambdabot>      Perhaps you meant one of these:
15:03:44 <lambdabot>        data constructor ‘Seq.:<’ (imported from Data.Sequence),
15:03:57 <athan> tromp_: Bit shift?
15:04:00 <Peaker> bitemyapp: make a change, press a key, jump directly to the place it causes an error, in <200ms
15:04:02 <tromp_> > 1 `shiftL` 20
15:04:04 <lambdabot>  1048576
15:04:05 <Peaker> bitemyapp: without tediously reading error msgs
15:04:08 <broma0_> Peaker: looking at 'src/Lib/Makefile/MonadClass.hs' was very enlightening
15:04:11 <Peaker> bitemyapp: to figure out line number/etc
15:04:16 <athan> tromp_: Have you seen Cryptol?
15:04:31 <athan> bitemyapp: o/
15:04:36 <Peaker> broma0_: cool :)
15:04:40 <tromp_> yes, athan
15:04:49 <athan> tromp_: Just checking :)
15:05:01 <Peaker> broma0_: it was an easy way to make sure I don't accidentally read inputs I didn't track (I remember what files I read so I can safely cache it)
15:05:38 <Peaker> broma0_: unfortunately, using a typeclass instead of a concrete monad made it MUCH slower, until I added INLINE pragmas on ALL the constrained functions. Then it was as fast again, but compile time jumped to like 20 seconds for a single module!
15:05:59 <Peaker> (had to tell GHC to run many more simplifier steps, too)
15:06:13 <Peaker> I think SPECIALIZE would be enough, rather than INLINE, but SPECIALIZE is such a pain to use
15:06:31 <Peaker> {-# SPECIALIZE_ALL_THE_THINGS foo #-} would be great
15:06:43 <broma0_> Peaker: Damn! If you were going to use a concrete monad, you'd have to use IO, right?
15:06:57 <shachaf> Peaker: One thing you can do is evil-mangle the assembly generated by GHC in a reasonably straightforward way to make perf understand it.
15:08:12 <Peaker> broma0_: nope, I use this: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Makefile/Monad.hs#L67
15:08:38 <Peaker> shachaf: that sounds very evil :)
15:08:52 <Peaker> broma0_: or rather, I use transformed-IO, if that's what you mean
15:08:54 <shachaf> Peaker: Sure, but if it's just for debugging it might not be too bad.
15:09:22 <Peaker> shachaf: what kind of mangling?
15:10:11 <shachaf> Peaker: Delete lines of the form ".type Foo_bar_info, @object"
15:11:05 <Peaker> shachaf: oh, right, you said "assembly", I was thinking on the executable itslef
15:11:20 <shachaf> You can do that too if you want.
15:11:27 <Peaker> yeah, easier on the assembly :)
15:11:52 <Peaker> shachaf: how do you tell GHC to stop at the assembly, and then what's the continuation from there?
15:11:58 <shachaf> ghc -S Foo.hs; mangle Foo.s; ghc Foo.s
15:12:00 <shachaf> Something like that.
15:12:08 <Peaker> ooh, ghc takes .s files?
15:12:16 <Peaker> that's nice :)
15:12:19 <shachaf> It takes .c files too.
15:12:25 <shachaf> Very versatile.
15:12:37 <Peaker> does it do its linking magic on whatever gcc generates?
15:12:55 <shachaf> I think so?
15:24:37 <kadoban> Yay, finally got my copy of Pearls of Functional Algo Design
15:25:37 <shirt> which is the recommended library for storing passwords? pwstore-fast or bcrypt or something else?
15:26:56 <tommd> shirt: Consider the 'script' library for computing the stored data and use whatever backend you desire.
15:28:04 <tommd> shirt: Notice that cryptonite (which you might already depend on) includes an scrypt implementation.
15:28:52 <shirt> thanks i'll look into it
15:29:11 <athan> kadoban: It's so good T_T
15:29:44 <athan> tommd: Is scrypt going to be the new standard for secure password storage? Moreso than SHA512, or something else?
15:30:10 <bitemyapp> athan: SHA512 is *not* for storing passwords.
15:30:11 <kadoban> SHA512 isn't a standard for password storage. It's a hash. (there's a fairly big difference)
15:30:18 <athan> bitemyapp: :x
15:30:41 <athan> well, um... okay I'll use scrypt then :D
15:30:43 <d-snp> scrypt is also a hash
15:30:49 <koala_man> you might be thinking of sha512crypt 
15:30:52 <bitemyapp> athan: bcrypt is more common, scrypt is more secure.
15:30:53 <d-snp> so you can't store a password with that either :P
15:31:02 <tommd> athan: SCrypt has been the unofficial standard for a time now.  A recent competition, not too popular, has agreedon Argon2 iirc but I don't expect it to catch on.
15:31:07 <athan> bitemyapp: Cause of memory hardness, or something?
15:31:13 <bitemyapp> athan: yeah
15:31:21 <athan> tommd: Thank you
15:31:29 <athan> okay cool, now to code for huge corporations
15:31:30 <bitemyapp> but using bcrypt instead of a hash helps a lot by itself.
15:31:50 <d-snp> I don't think using scrypt is very standard
15:31:55 <tommd> PBKDF2 is at least a widely supported thing and easy to do with just _insert hash here_
15:31:58 <athan> bitemyapp: Hmm, okay
15:32:04 <athan> tommd: That's what I was thinking of
15:32:10 <d-snp> most projects use bcrypt, and pbkdf2 is recommended by the experts
15:32:24 <tommd> d-snp: "the experts"?
15:32:34 <tommd> perhaps we are off topic here, should go to -blah or -crypto
15:32:39 <tommd> That is ##crypto
15:32:59 <kadoban> d-snp: scrypt is a key-derivation function, isn't it? It's not a hash.
15:33:11 <ttt_fff> I know about tupile sections, so I can do things like:  >> (1, , 3) = \x -> (1, x, 3) // now, I want to know if I can do "constructor sections" so that  (Foo a *** b) = \x -> (Foo a x b)
15:33:26 <athan> ttt_fff: Like `Foo`?
15:33:35 <athan> a `Foo` b?
15:33:40 <chpatrick1> what
15:33:46 <ttt_fff> well, there's more than 2 args
15:33:47 <ttt_fff> to the contructor
15:33:48 <chpatrick1> 's wrong with \x -> Foo a x b? :)
15:33:52 <ttt_fff> so I don't think making it infix fixes it
15:33:52 <athan> oh shoot
15:34:06 <athan> ttt_fff: For that stuff, I use unweildy `.` combinators:
15:34:08 <ttt_fff> chpatrick1: \x -> Foo a x b? looks like Haskell freshmen; I want to write Haskell sophmore code
15:34:11 <athan> @hackage composition
15:34:11 <lambdabot> http://hackage.haskell.org/package/composition
15:34:18 <athan> also
15:34:21 <athan> for more combinator hell:
15:34:27 <athan> @hackage composition-extra
15:34:27 <lambdabot> http://hackage.haskell.org/package/composition-extra
15:34:40 <chpatrick1> athan: looks like a nice way to write write-only code
15:35:04 <d-snp> kadoban: oh sorry you are correct
15:35:22 <d-snp> been a long time since I researched this stuff I admit :P
15:35:40 <athan> chpatrick1: :) maybe, I've found some uses
15:35:50 <athan> like <$$> and <$$$> instead of having to pull in lens
15:36:05 <athan> the <~~.> stuff is rediculous, though :\
15:36:35 <ttt_fff> "write only code" == job security
15:36:46 <ttt_fff>  // I'm kidding
15:38:42 <sbrg> For conduit.. how do I do something like: lineC (yieldMany "foo\nbar\baz") $$ printC
15:39:50 <iteratee> I was looking at HoleyMonoid, and trying to get my head around it.
15:40:09 <iteratee> I realized that it's just the indexed continuation monad with the arguments in a different order.
15:42:05 <sbrg> nevermind -- didn't know about runConduit, heh.
15:46:10 <Kluns> I newtyped a monad transformer stack, and now I would like to use 'lift' in this monad. However, my new monad is not an instance of MonadTrans. How should I solve this problem?
15:46:47 <kadoban> Kluns: *slightly guessing* make it an instance, perhaps with GeneralizedNewtypeDeriving ?
15:46:57 <broma0_> Kluns: can you add deriving (MonadTrans)
15:47:02 <broma0_> kadoban: you beat me
15:47:08 <kadoban> :)
15:47:27 <Kluns> broma0_, kadoban I tried that, but it does not seem to work.
15:47:34 <broma0_> Kluns: did you do what kadoban suggested?
15:47:47 <Kluns> Which makes sense, since the stack is not a monad transformer but a regular monad.
15:47:51 <broma0_> Kluns: you might need to add {-# LANGUAGE GeneralizedNewtypeDeriving #-}
15:48:08 <Kluns> Yes, I did enable the extention.
15:48:39 <broma0_> Kluns: getting this: Class ‘MonadTrans’ expects an argument of kind ‘(* -> *) -> * -> *’??
15:48:49 <Kluns> broma0_, Indeed!
15:49:10 <broma0_> Kluns: I just tried to derive it myself, im currently working on a haskell project
15:49:17 <broma0_> Kluns: maybe i can figure it out... 
15:49:51 <kadoban> Kluns: Is the code short enough to share, or is it easy to make an example?
15:50:32 <kadoban> Kluns: BTW, usually I just use a type alias for my Monad stacks I believe, if that helps.
15:51:12 <broma0_> kadoban: what's the benefit of type over newtype or vice versa in this monad stack example?
15:51:18 <Kluns> kadoban: I'm using 'StateT a []'. I would like to 'branch' in the underlying list monad.
15:52:22 <sbrg> nah okay, I don't get how to use lineC
15:52:32 <kadoban> broma0_: I'm not sure I could come up with anything intelligible in response to that … I just don't tend to use newtype like that. I use newtype when I have an exact type I want to "copy", but don't want to be able to confuse the original type with my newtype. In a transformer stack, that just … doesn't apply I don't think.
15:52:36 <sbrg> In conduit, how would I take a string and split it into lines and then print it?
15:54:13 <kadoban> Kluns: Oh I see … yeah the kinds just don't match up do they. I'd try the type alias instead if you can, is the newtype important to you?
15:55:12 <broma0_> kadoban: seems to make sense.. 
15:55:23 <Kluns> kadoban, I'd like to use the newtype to revoke access to the internals of the monad.
15:55:37 <RnbwUncrn> Hey
15:55:44 <RnbwUncrn> I wanna learn haskell
15:55:52 <Kluns> But if I'm not mistaken, 'NewtypeConstructor . lift' does the job
15:56:02 <chpatrick1> Kluns: I would make my functions general over the monad using MonadState, MonadReader etc
15:56:04 <kadoban> Kluns: Hmmmm. Sorry, I'm not sure then :-/ I'm sure there's people /much/ more knowledgeable about this though.
15:56:18 <RnbwUncrn> I think you're right
15:56:23 <chpatrick1> Kluns: and then only decide on a monad when you actually run them
15:56:33 <chpatrick1> that way you get a nice effect system and don't have to commit to anything :)
15:56:47 <kadoban> RnbwUncrn: Nice. This is a good guide: https://github.com/bitemyapp/learnhaskell
15:57:28 <chpatrick1> I used to do the monad-newtype-stack thing but now it feels like an antipattern
15:58:32 <glguy> chpatrick: It's a better way to go than exposing various MTL typeclasses
15:58:52 <chpatrick1> why?
15:59:13 <chpatrick1> I mean I would make all my functions like doStuff :: MonadState s m => m () or whatever, depending on what effects they need
15:59:31 <chpatrick1> and then decide on a concrete implementation only in the end when I do run...
16:00:04 <chpatrick1> that makes the functions a bit more typesafe too since they can't do stuff you didn't intend them to
16:00:37 <glguy> chpatrick: Because MonadState is rarely the right abstraction, even if you were writing your functions in terms of typeclasses describing the functionality your program needed it wouldn't be the generic typeclasses that MTL offers
16:02:02 <miscyb> has anyone been having issues getting yesod to install with cabal?
16:02:27 <miscyb> i'm getting problems with vector >= 0.11.0.0
16:02:41 <miscyb> i think vector-algorithms doesn't like it
16:03:06 <tommd> miscyb: Numerous packages have yet to bump their upper bounds wrt vector 0.11
16:03:49 <miscyb> tommd: so it's a problem with those packages and not yesod? what is everyone else using to build yesod packages?
16:04:12 <broma0_> I'm still struggling with how to design a large-scale app using a "God Monad" and typeclasses for the subcomponents. If my monad is 'type App a = ReaderT Config (StateT AppState IO) a', what would the subcomponent classes look like?
16:04:21 <tommd> miscyb: I'd file a bug report with vector-algorithms then add the top-level constraint 'cabal install yesod --constraint vector==0.10.12.3
16:04:23 <creichert> miscyb: I'm checking it out right now, I can bump the version if I can reproduce it
16:05:42 <miscyb> alright i'll give that a shot
16:06:12 <miscyb> i tried to update vector-algorithms myself, however i think the yesod install complained about a different package for the same reason
16:06:25 <miscyb> i'll go check it out to see what fails
16:08:06 <miscyb> yeah it looks like vector-instances is having the same problem
16:08:10 <miscyb> i'll try that one too
16:09:38 <cow_2001> what are some logical control functions that chain if then elses?
16:10:40 <tommd> dolio: Every time I want to sort a vector what I really want is a 'thaw v >>= Tim/Flag/Radix.sort >>= unsafeFreeze' .
16:10:52 <tommd> dolio: Would you accept a patch that provides this pattern?
16:11:03 <tommd> dolio: (talking about vector-algorithms here)
16:11:21 <Welkin> cow_2001: bind
16:12:47 <athan> Welkin: I think function application would just work, too
16:13:14 <cow_2001> something that isn't if-than-else, guards or cases
16:13:17 <athan> f True . g False . h someBool where f b = if b then x else y ...
16:13:22 <cow_2001> oh
16:13:24 <cow_2001> huh
16:13:55 <athan> cow_2001: It depends on what you want to encode in the monad
16:14:19 <athan> the monad kinda takes away one of the branches :\
16:16:10 <cow_2001> i'm not sure if it's a good way to do what i want to do, using the maybe monad thing
16:16:52 <tommd> Why doesn't lambdabot support @seen these days? I miss that.
16:17:03 <chpatrick1> cow_2001: what are you trying to do?
16:17:11 <Welkin> tommd: it was disabled for stability reasons
16:17:26 <kadoban> tommd: It was pretty spammy and I think it was one big memory leak.
16:17:29 <tommd> So seen was buggy or lambdabot being buggy made seen less useful?
16:17:35 <tommd> Ah, ok
16:17:44 <aweinstock> what did @seen do?
16:17:57 <tommd> Told you the last time it saw someone (in channel and last time they spoke)
16:18:27 <Welkin> it's a common bot trigger on irc
16:18:31 <Welkin> usually !seen
16:19:04 <kadoban> I mostly remember than @seen lambdabot would spam a bunch of crap, and don't remember seeing anyone use it for anything else, heh.
16:19:10 <Xe> is there a tutorial on how to make a WAI middleware?
17:03:06 <creichert> Xe: I would look in wai-extra, there are several commonplace middlewares that are good to learn from
17:04:19 <creichert> Xe: for example, http://hackage.haskell.org/package/wai-extra-3.0.10/docs/src/Network-Wai-Middleware-AddHeaders.html#addHeaders
17:07:02 <creichert> the only other important bit is that a middleware is a type aliase: type Middleware = Application -> Application
17:13:06 <orion> Is there any good way to simplify this code?: http://lpaste.net/8092035925481095168
17:16:24 <ttt_fff> orion: yes
17:17:14 <ttt_fff> fmap (\DocumentParent (DocID p) -> p) parent
17:20:16 <orion> ttt_fff: Hmm: Constructor ‘DocumentParent’ should have 1 argument, but has been given none
17:20:48 <KaneTW> needs more brackets
17:21:09 <ttt_fff> fmap (\(DocumentParent (DocID p)) -> p) parent
17:21:26 <orion> ah
17:21:41 <ttt_fff> does that work?
17:21:46 <orion> That's really cool. I never knew I could pattern match within a lambda. Thanks ttt_fff.
17:35:42 <sm> tommd: I miss it too
17:35:42 <Zemyla> Hee, I had occasion to unsafeCoerce putStrLn to an ST s ().
18:04:16 * hackagebot roundtrip-aeson 0.2.0.0 - Un-/parse JSON with roundtrip invertible syntax definitions.  https://hackage.haskell.org/package/roundtrip-aeson-0.2.0.0 (ThomasSutton)
18:05:49 <Javran> today I heard "boolean blindness", what are concerns about it?
18:06:11 <Axman6> I don't understand the question
18:06:45 <athan> Javran: If you're encoding your behaviour with booleans, then you only know that it takes a bool
18:07:07 <Javran> from what I understand, it basically says by collapsing information into just 1 bit, you'll have to extract things somewhere else?
18:07:15 <athan> but, if you make your own datatype encoding - `data MySwitch = ReadStdout | ReadFile`, then you have more "visibility"
18:07:33 <athan> (at the type level)
18:07:36 <Cale> Well, that doesn't solve boolean blindness
18:07:47 <athan> Cale: My mistake, that's just how I heard of it
18:07:48 <Javran> so "visibility" means it's carrying more infomation?
18:08:10 <Cale> The real information being lost is *why* the Bool was True or False
18:08:39 <Cale> i.e. instead of a Bool, the idea is that you ought to produce some sort of proof of some property
18:08:39 <athan> Cale: Ahh, okay. Thank you
18:08:47 <Cale> It's tricky in a non-dependently-typed language
18:09:07 <Cale> Our case expressions have the unfortunate property that you can rearrange the branches and it'll always typecheck
18:09:24 <athan> Cale: Lots of nesting? Where constructors represent separate results during a computation?
18:09:33 <elben> I’m trying to understand monad transformers (using transformers library). In this snippet, I don’t get how I’m suppose to get the State while in the ExceptT monad: https://gist.github.com/elben/ac45285f11cedce05d15 
18:09:48 <Cale> I mean, if you have case x of ReadStdout -> e1; ReadFile -> e2
18:10:05 <Cale> it'll still typecheck if you write  case x of ReadStdout -> e2; ReadFile -> e1
18:10:09 <Cale> always
18:10:12 <Cale> right?
18:10:24 <athan> Oh! Wow okay
18:10:45 <athan> We need to affiliate data with routines?
18:10:57 <Cale> So, the idea is to avoid this kind of failure by making the constructors carry additional information which will need to be used
18:11:15 <Javran> I see
18:11:18 <Cale> A simple example is that instead of casing on whether a list is empty or not, we typically pattern match on [] and (x:xs)
18:11:49 <Cale> I mean, instead of case null xs of False -> ... ; True -> ...
18:12:24 <athan> Cale: Because the x and xs variables are bound to the rest of the routine :) ahh okay, I got it
18:12:25 <athan> thank you
18:12:27 <Cale> So that at least in the nonempty case, we get to use x and xs, and then it's no longer possible to have things the wrong way around
18:12:33 <Hafydd> case null xs of xs | [] <- xs
18:12:37 <Javran> and RHS of alternatives are expected to use these values extracted from pattern matching on constructors? 
18:12:39 <Hafydd> Whoops.
18:12:50 <Cale> Yeah, that's kind of the idea
18:12:51 <athan> elben: Do you know what `lift` does?
18:12:58 <Zemyla> How would you have dependently tuped case expressions?
18:13:10 <elben> athan: I am actually reading up on it now—I had a feeling that was I needed
18:13:14 <Zemyla> Whoops, I was scrolled baxk.
18:13:23 <athan> elben: It's pretty easy once you get the hang of it :)
18:13:24 <athan> :t lift
18:13:24 <Cale> Now, in dependently typed languages, there's *way* more opportunity for avoiding boolean blindness, because the type of the result you produce can depend on the value which got matched.
18:13:25 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
18:13:32 <athan> :t lift . lift
18:13:33 <lambdabot> (Monad m, Monad (t1 m), MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
18:13:51 <athan> elben: Where the `m` is the target computation (from `get`)
18:14:13 <Cale> and you can carry around proofs of properties instead of booleans
18:14:45 <Cale> Like, instead of having null produce a Bool, you could have it produce  Dec (xs = [])
18:15:14 <Cale> Where Dec is a two constructor type whose constructors take a proof or refutation respectively of the given property
18:15:43 <Javran> hmm, sounds like `maybe` and `either`
18:15:47 <Cale> and then no information about what would have been a Boolean gets lost
18:16:04 <Cale> When you pattern match on the Dec, you pull out a proof that the list really is empty or not
18:16:29 <gwaszczuk> Yeah, it works like that in Idris. Having a proof of "xs = []" makes it easy to rewrite it with functions like "rewrite : (a = b) -> f a -> f b
18:16:39 <Cale> right
18:17:13 <gwaszczuk> Having a contradiction makes it a little tougher to work with though, in a programming context (you need to create lots of lemmas that prove things by contradiction usually)
18:18:39 <Javran> just thinking, applying the same idea, for Either a b, when a ~ b, there are still chances you mess up two branches?
18:18:52 <Cale> Javran: yes
18:19:05 <Javran> I see
18:19:48 <Cale> Of course, you can't always completely eliminate this possibility, but the original blog post which introduced the term was all about how dependent types can help you avoid this kind of situation more often.
18:20:32 <Javran> is there a link to the post?
18:20:33 <Cale> But yeah, even in Haskell, we can often design our APIs so that things produce more informative results, rather than Bool values
18:21:00 <Cale> https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
18:21:41 <Javran> Cale: thanks!
18:22:26 <Cale> Whenever you take some sophisticated property and then crunch it down to one bit of information, no matter how that bit is represented, you have boolean blindness :)
18:23:10 <Cale> You need to know something about where that bit came from in order to know what it means, and the type system can't help you any longer.
18:23:56 <Zemyla> Bec
18:23:58 <ReinH> Cale: all bits are equal but some are more equal than others
18:24:36 <elben> athan: not sure if Control.Monad.Trans.Except provides an implementation of `lift` (https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Except.html)—I had to do it via liftM: https://gist.github.com/elben/ac45285f11cedce05d15
18:24:48 <Zemyla> :t \xs -> if null xs then Just (head xs) else Nothing
18:24:49 <lambdabot> [a] -> Maybe a
18:25:02 <Zemyla> You see what's wrong with that?
18:25:13 <Cale> Maybe it could be argued that having newtypes of Bool (or enumerated types) with constructors that are hidden by a module boundary can be useful.
18:25:20 <Javran> from my understanding, type system makes sure you are using the expected set of values, but it's hard to guarantee things beyond that.
18:26:05 <Cale> Javran: Well, the type system also determines what "set of values" means there :)
18:26:29 <Cale> Javran: and fancier ones can be better at refining what it is that you're allowed to do
18:27:33 <Javran> so that's dependent type comes into play xD
18:27:39 <Cale> yeah
18:28:25 <Cale> I want a dependent Haskell or a lazy Idris to come along :)
18:29:36 <Cale> There are apparently some difficulties combining lazy evaluation with the type level evaluation of open terms, which would be interesting to sort out.
18:29:40 <Zemyla> Cale: I want an F# that's more Haskelly
18:29:58 <dibblego> with higher kinds and type-classes
18:30:08 <Cale> Zemyla: At some point there was a plan to get Haskell running on .net
18:30:19 <Cale> Zemyla: Not sure what happened to that
18:30:39 <uiop> elben: 
18:30:42 <uiop> :t lift get :: ExceptT String (State Int) Int
18:30:44 <lambdabot> ExceptT String (State Int) Int
18:31:11 <mindtree> hey all :) is anyone around who has had experience using haskell for audio DSP?
18:32:41 <Zemyla> Does anyone know if F# has anything like RankNTypes?
18:32:46 <gwaszczuk> Idris is total though. It can't be a non-strict language since it has no bottom, right?
18:33:12 <gwaszczuk> Though you could still have some sort of lazy evaluation, even for total functions, I guess
18:34:01 <Axman6> mindtree: I haven't, but I know there are several projects which do it. have a look at the stuff used for "algorave" live coded music
18:34:06 <gwaszczuk> It may not change semantics, but it could change performance
18:34:07 <wuvumunchy> Idris has typed lazyness though! I have never played with it
18:34:19 <Cale> gwaszczuk: It's optionally total.
18:34:34 <Cale> gwaszczuk: You have to explicitly ask for totality checking where you want it
18:34:47 <Cale> and yeah
18:35:08 <Cale> Just because you know that something terminates doesn't mean strict evaluation is necessarily the best way to compute it
18:35:15 <elben> uiop: ah, thanks. I had to import Control.Monad.Trans.Class
18:35:27 <gwaszczuk> Oh yeah. I default to totality all the time, so I just take it as total though
18:35:34 <Cale> A lot of the benefit of laziness comes from being able to compose things in a fashion where you have intermediate structures which are combinatorially large.
18:35:55 <wuvumunchy> or infinite ;)
18:36:02 <Cale> Or infinite, sure :)
18:37:23 <Cale> But there are a lot of game trees and such which are actually finite and whose computation you might be able to prove terminates, and yet you still wouldn't necessarily want to compute the whole thing.
18:37:50 <gwaszczuk> I wonder if the "laziness" problem will ever be solved. You cant seem to have totally lazy languages and totally strict ones without lots of headaches (in each)
18:38:13 <Zemyla> Hmm, there are some things where bools would be necessary, though.
18:38:18 <Zemyla> Like filter.
18:39:18 * hackagebot keter 1.4.3 - Web application deployment manager, focusing on Haskell web frameworks  https://hackage.haskell.org/package/keter-1.4.3 (ChristopherReichert)
18:39:44 <Cale> gwaszczuk: For the time being, I prefer having lazy as the default, since it's like a recessive gene when you're combining programs -- anything which is strict will tend to ruin it, and so if you make strictness the default, even if lazy is an option, your libraries tend to fill up with things that can't be used in lazy programs.
18:39:47 <Zemyla> Also, in a dependently typed language, where the length of a list is part of its type, how do you do something like filter?
18:40:25 <gwaszczuk> :Zemyla There are 2 options I think
18:40:38 <gwaszczuk> Existential pairs, or computing the length as well
18:41:34 <Zemyla> Though it'd probably be less filter and more mapMaybe :: (a -> Maybe b) -> f a -> f b.
18:41:41 <arkeet> mapMaybe is good.
18:41:56 <Cale> Zemyla: First you could do  filterVecToList :: Vec n a -> [a]
18:42:32 <Cale> Zemyla: and then you could write  filterVec :: (xs :: Vec n a) -> Vec (length (filterVecToList xs)) a
18:42:51 <Cale> (not sure if that's actually useful!)
18:42:56 <Cale> But it's an option
18:43:31 <Guest89788> Hi, is there anyone who has detailed information about SqlValue operations like fromSql? I was encountered with something that is puzzling to me. Thanks a lot.
18:43:35 <Zemyla> I wish there were a typeclass for mapMaybe, which could have some things that aren't full monads, but can be filtered.
18:44:14 <Cale> Zemyla: Reflex has that class in it just because it's not somewhere better
18:44:32 <Zemyla> I imagine it'd be a subclass of Alternative, and MonadPlus would be a subclass of it.
18:44:38 <Cale> Guest89788: Do you have a more specific question than that?
18:45:27 <Cale> Guest89788: Also, which SqlValue? :)
18:45:47 <Cale> Guest89788: There are a lot of database libraries for Haskell, and I'm pretty sure there's more than one which defines a type like that
18:46:20 <Guest89788> A minute, please. I'll run my program again and see the error message.
18:46:30 <wuvumunchy> Maybe you could get around the dependent/lazy problem like this: you have the category "hask" and everything inside it is lazy in some sense. Everything outside Hask which you use to parameterize types is strict
18:49:12 <Guest89788> Cale: Here is the error message I've got when running my program containing a fromSql function:
18:49:15 <Guest89788> Convertible: error converting source data SqlString "0-01-01-09" of type SqlValue to type Char: String length /= 1
18:51:03 <Cale> Guest89788: How large is your program? Could you put it on lpaste.net?
18:51:32 <Cale> Obviously, something is trying to convert a string to a Char when it shouldn't be.
18:52:07 <Cale> Guest89788: You're using HDBC?
18:52:15 <Guest89788> I looked through Database.HDBC.SqlValue but didn't get what I want. So I suppose there are some other source of information which may have more details.
18:52:28 <Guest89788> Cale: What is lpaste.net?
18:52:50 <Cale> Guest89788: It's a paste bin, where you can paste a bunch of code and let others look at it
18:53:47 <Cale> (since pasting more than a couple lines of text into the IRC channel is rude and will generally get you kicked out :)
18:55:38 <Guest89788> Sorry to be so fresh that I don't know how to do it indeed. But the line supposed to bear this error is following. I  hope it is helpful.
18:55:45 <Guest89788> forM_ rows $ \row -> putStrLn $ map fromSql row
18:56:00 <Cale> Aha!
18:56:08 <Axman6> looks like that should be print?
18:56:19 <Cale> Yeah, probably you either want print there
18:56:24 <Cale> or mapM_ putStrLn
18:56:31 <Axman6> or perhaps it doesn't know what type of value you're expecting to return from the call to fromSql (and is probably defaulting to () )
18:56:40 <Cale> It's Char
18:56:47 <Cale> because putStrLn wants a String
18:56:51 <Axman6> right
18:57:02 <Cale> and so  map fromSql row  needs to produce a String, which is [Char]
18:57:04 <Axman6> but is the data actually a Char?
18:57:13 <Cale> So fromSql applied to each element needs to produce a Char
18:57:41 <Cale> even though the SqlValues are actually SqlString values of longer length
18:58:00 <Cale> and so the conversion to Char fails
18:58:39 <Cale> Guest89788: Make sense?
18:59:57 <Guest89788> Cale: I am trying to understand your words. Thank you very much! One more question - Could you tell me the command to quit here? I failed quite a lot of times last time I was here :(
19:00:32 <uiop> heh
19:00:36 <Axman6> /quit
19:00:51 * Axman6 came very close to just writing /quit
19:00:56 <Guest89788> Thank you :)
19:01:07 <Axman6> I'm sure there's a bach.org quote about that somewhere...
19:01:13 <uiop> Axman6: that's what he was hoping for
19:01:21 <Cale> Guest89788: But feel free to stick around and ask lots of questions if you're learning Haskell
19:01:31 <Guest89788> Axman6: Thank you :)
19:01:34 <Axman6> http://bash.org/?362137
19:02:00 <uiop> heh
19:02:02 <Guest89788> Cale: Thank you. I'll surely come back. This is a warm place. :)
19:02:03 <Axman6> Guest89788: yeah, as Cale said, you're here to help. so stick around and ask questions
19:02:28 <Axman6> also, try using /nick <your preferred nickname>
19:03:12 <Guest89788> Axman6: for what to type /nick?
19:03:41 <Axman6> it changes your name on IRC
19:03:58 <Axman6> at some point in the long distant past I types /nick Axman6, and the rest is history :P
19:04:04 <Axman6> typed*
19:04:32 <Guest89788> Axman6: Got it. Thank you :)
19:04:58 <Guest89788> Thank you all!
19:06:36 <wuvumunchy> window page_down
19:06:39 <wuvumunchy> window page_down
19:06:41 <wuvumunchy> window page_down
19:06:46 <wuvumunchy> window page_down
19:06:48 <wuvumunchy> window page_down
19:06:50 <wuvumunchy> window page_down
19:06:57 <uiop> :! sudo halt
19:06:59 <wuvumunchy> sorry
19:06:59 <uiop> :! sudo halt
19:07:00 <wuvumunchy> lol
19:07:10 <uiop> :)
19:07:20 <wuvumunchy> trying to get weechat to work
19:12:50 <Fylwind> a lot of the times when fixing type errors I would really like some sort of explanation why GHC thinks xyz has type Abc
19:14:11 <Fylwind> something like: "xyz :: Abc" because "f expects Abc as argument", because "foo in the body of f uses argument with the function bar :: Abc -> …" etc
19:14:28 <Fylwind> kind of like a 'stack trace' but for the type inference engine
19:19:20 * hackagebot morte 1.2.1 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.2.1 (GabrielGonzalez)
19:19:38 <osa1> having an extensible command line argument parser for criterion(like tasty's options) would be really awesome.
19:20:04 <dot_Laptop> Hello, what is the name of library to send email from windows?
19:21:15 <osa1> most criterion programs I wrote have some hacky argument parsing
19:28:54 <mindtree> hey all, I'm trying to derive `Num` on a newtype, but I get told to `Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension`. How do I do this?
19:29:15 <godel> mindtree: mind sharing code?
19:30:01 <mindtree> godel: `newtype Bars = Bars Int deriving (Eq, Num, Ord, Read, Show)`
19:30:16 <godel> mm
19:30:21 <godel> don't you mean
19:30:29 <godel> data Bars = Bars Int ?
19:30:41 <Kluns>  mindtree: It's a language pragma. You can enable it by putting {-# LANGUAGE GeneralizedNewtypeDeriving #-} in your file :)
19:30:43 <peddie> mindtree: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/deriving.html#newtype-deriving
19:30:49 <benzrf> godel: why
19:30:56 <pacak> godel: it would be slower.
19:31:02 <mindtree> Kluns: oohh thanks :)
19:31:05 <godel> ok
19:31:06 <mindtree> peddie: thanks, will read
19:32:49 <mindtree> Kluns: hmm seem to be getting the same message even when adding that pragma to my file
19:33:33 <mindtree> Kluns: ahh it worked (just needed to put it riiight at the top)
19:48:39 <Nik05> oops, thought (-2) would subtract 2...
19:48:49 <Nik05> guess thats why there is a 'subtract'
19:52:26 <Cale> Nik05: Yeah, 'subtract' is a concession to that little wrinkle in the syntax.
19:54:21 * hackagebot coordinate 0.0.19 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.0.19 (TonyMorris)
19:55:03 <Xe> what can I use for a key->value haskmap in haskell?
19:55:21 <pacak> :t Map
19:55:22 <lambdabot>     Not in scope: data constructor ‘Map’
19:55:22 <lambdabot>     Perhaps you meant one of these:
19:55:22 <lambdabot>       variable ‘map’ (imported from Data.List),
19:55:49 <pacak> Xe: Data.Map ?
19:55:58 <geekosaur> Data.Map (containers), Data.HashMap (unordered-containers)
19:56:22 <Cale> Xe: Data.Map is the usual thing to use, though it makes no use of hashing (which is actually often a good thing -- hashing can be expensive)
19:56:37 <Xe> Cale: How would I use it?
19:56:39 <pacak> Data.IntMap, Data.EnumMap
19:57:08 <nkaretnikov> Xe: just like in other languages
19:57:10 <Cale> Xe: Typically, you want to  import qualified Data.Map as Map; import Data.Map (Map)
19:57:17 <Axman6> is EnumMap a wrapper around IntMap using from/toEnum
19:57:18 <Axman6> ?
19:57:22 <Cale> and then use the things from here:  https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers/Data-Map-Lazy.html
19:57:26 <pacak> Axman6: Yep
19:57:32 <Cale> (Data.Map re-exports this stuff)
19:58:11 <Cale> Usually fromList along with lookup and/or findWithDefault are the most important operations
19:58:16 <Cale> fromListWith is also very handy
19:59:21 * hackagebot hgearman 0.1.0.0 - A Gearman client for Haskell.  https://hackage.haskell.org/package/hgearman-0.1.0.0 (jperson)
19:59:31 <Xe> nkaretnikov: I mean do you know of an example I can look at?
19:59:36 <Cale> Data.HashMap is almost a drop-in replacement for Data.Map if you want to try and see if hashing gets you better performance. In my experience, it's a bit of a toss-up. Data.Map is very well optimised.
20:00:37 <Cale> There are a whole bunch of examples of how to use various things in the Data.Map documentation I linked.
20:01:09 <Cale> For instance, look at the example for lookup
20:01:32 <Cale> (That example also shows how to use the fact that Maybe is a monad to combine lookups nicely.)
20:02:27 <Xe> hmm
20:02:39 <Xe> how would I add like 500 elements to a map efficiently?
20:03:03 <Cale> fromList and union
20:03:34 <Cale> i.e. make a Map of those 500 elements, and then union it with the original
20:04:22 <Xe> hmm
20:04:38 <Xe> what if i have a record with a unique id and want to use that as the lookup key?
20:04:59 <Cale> Use lookup?
20:05:15 <Cale> I'm not sure what you're asking exactly :)
20:05:16 <Xe> no i mean
20:05:26 <Xe> to construct it
20:05:49 <Cale> fromList [(uniqueId r, r) | r <- records]
20:05:55 <Cale> something like that?
20:06:23 <Cale> Well, it'd be Map.fromList if you imported it like I suggested above :)
20:08:43 <Xe> hmm I think I see
20:10:26 <benzrf> map (uniqueId &&& id) records
20:10:50 <benzrf> there oughta be shorthand for (&&& id) and (id&&&)
20:11:17 <johnw> um, isn't that second and first?
20:11:30 <Xe> ugh
20:11:38 <Xe> the database layer returns stuff stuck in IO
20:12:31 <roboguy_> :t (&&& id)
20:12:33 <lambdabot> (c' -> c) -> c' -> (c, c')
20:12:46 <marchelzo_> :t second
20:12:47 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
20:13:13 <benzrf> johnw: no, that's for (***)
20:14:04 <johnw> ah
20:14:11 <roboguy_> :t ((,) <$> id <*>)
20:14:13 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
20:14:37 <Xe> Cale: it's complaining about this: userMap <- Map.fromList [(User.oID u, u) | u <- (Db.query_ conn "SELECT * FROM Users" :: IO [User.User])]
20:14:39 <Xe> https://gist.github.com/Xe/75207ef1515e72f90d62
20:14:40 <Cale> Xe: Yeah, because talking to the database server causes real-world effects. It shouldn't be too hard to execute the IO actions...
20:14:53 <Cale> You need to execute the action beforehand.
20:15:04 <Cale> Also, userMap <- Map.fromList ...  is almost certainly wrong
20:15:25 <Cale> Because a Map is not an IO action, and Map k isn't a monad.
20:15:38 <Xe> that took away the longger error
20:16:07 <Cale> You probably want something like  do users <- Db.query_ conn "SELECT * FROM Users" :: IO [User.User]; let userMap = Map.fromList [(User.oID u, u) | u <- users]; ...
20:16:37 <Cale> You want to execute the query, getting the list of results users
20:16:45 <Cale> and then you want to define the userMap in terms of that
20:17:15 <Cale> Inside an IO action do-block, when you write v <- x it means "execute the action x, and call its result v"
20:17:18 <Cale> If x :: IO t, then v :: t
20:17:49 <Xe> okay
20:17:53 <Cale> and when you write  let v = x  by contrast, it defines v and x to be the same thing
20:18:30 <Cale> So if x were an action in that case, v would simply be defined to be the same action -- no effects would occur.
20:18:46 <Xe> oh dear jesus
20:18:52 <Cale> hm?
20:18:53 <Xe> bringing in pandoc made my binary 74 MB
20:18:57 <Cale> heh
20:19:09 <Xe> is there a way to have it eliminate dead code?
20:19:15 <Cale> Yeah, pandoc has a fair number of dependencies it gets statically linked against
20:20:04 <Cale> I wouldn't worry too much about it -- if you really really care, you can dynamically link, at the cost of making the resulting executable way less portable, since most people don't have the relevant shared objects on their machine.
20:20:30 <Cale> But for the most part, it's a constant term -- your executable won't get that much larger from there.
20:21:00 <Cale> (and 74MB is not really that large these days)
20:21:21 <Xe> yeah
20:21:23 <Xe> still
20:21:30 <Xe> it feels large to me
20:21:41 <Cale> It *is* a lot for code.
20:22:08 <Cale> But when you have hundreds of high level dependencies, this is what happens :)
20:24:00 <Gurkenglas> :t ap (,) -- roboguy
20:24:01 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
20:24:19 <roboguy_> oh yeah
20:24:23 <jle`> i'm going to petition for a MonadFix instance for Maybe
20:24:39 <jle`> by petition i mean mention it a couple of times on irc until i get bored
20:24:56 <Cale> jle`: huh? That instance exists.
20:24:56 <Gurkenglas> jle`, https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Monad-Fix.html#line-61
20:25:09 <Gurkenglas> You mean MonadZip?
20:25:09 <jle`> whaat
20:25:13 <jle`> i mean MonadZip
20:25:15 <jle`> yes
20:25:17 <jle`> heh
20:25:19 <jle`> two letters off >_>
20:25:23 <jle`> a MonadZip instance for Maybe
20:25:27 <johnw> jle`: send a proposal to the libraries list then
20:25:44 <jle`> i'm just at the stage where i'm raising awareness for a grass roots movement
20:25:46 <johnw> though it'll be hard to get people excited about it
20:25:50 <Gurkenglas> jle`, why not liftA2 (,)?
20:25:51 <johnw> since liftM2 (,) works just fine
20:26:10 <jle`> but you can't use it in code polymorphic over MonadZip
20:26:19 <jle`> that's the big deal
20:26:21 <johnw> and how much of that code is there?
20:26:36 <jle`> maybe the reason there isn't much code is because there's no Maybe instance!
20:26:57 <jle`> [ f x y | x <- xs | y <- ys ], idk
20:27:06 <jle`> should work on more things than just IO and []
20:27:10 <jle`> *Identity
20:27:21 <Gurkenglas> Is there a combination of constraints that gurantees there's only one value of the underlying type in a functor? Like (Functor, Contravariant) for none
20:27:23 <jle`> it'd be neat if you could use it with Maybe too
20:27:30 <johnw> jle`: I'd be more excited about having Monoidal, and its instance for maybe
20:27:31 <Gurkenglas> So you could define a MonadZip instance for all of those at once
20:27:37 <Gurkenglas> -only one+up to one
20:27:42 <johnw> https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
20:28:02 <jle`> Monoidal is redundant tho
20:28:09 <roboguy_> Gurkenglas: that sounds like something that would need some kind of substructural types, like linear types
20:28:26 <jle`> unless you give the [] the Zippy instance
20:28:31 <jle`> and then i guess it would match up
20:28:35 <Gurkenglas> Monoidal is Alternative modulo Applicative / MonadPlus modulo Monad??
20:28:37 <Gurkenglas> -?
20:28:45 <jle`> Monoidal is Applicative
20:28:53 <jle`> they're anagrams
20:28:59 <jle`> in a methaphorical sense
20:28:59 <Gurkenglas> *synonyms
20:29:07 <jle`> rearrange monoidal and you get applicative
20:36:30 <Gurkenglas> "In particular we consider (x,()) ≅ x ≅ ((),x) and ((x,y),z) ≅ (x,(y,z))." <- I would have liked it if that said "In particular we consider Identity to satisfy."... but then I also like pointfree style, and that _is_ a didactic text.
20:36:32 <roboguy_> it doesn't give you the unzip though
20:37:40 <Gurkenglas> roboguy_, https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Monad.Zip.html#munzip
20:37:56 <roboguy_> Gurkenglas: yeah, that's the unzip I mean
20:38:11 <Gurkenglas> It follows from the rest, I mean
20:38:21 <roboguy_> what do you mean?
20:38:34 <jle`> yeah but those laws don't let you prove the munzip laws
20:38:44 <jle`> the Applicative laws aren't strong enough to prove the munzip laws
20:38:58 <Gurkenglas> umm, you don't even need the rest. f (a,b) -> (f a, f b) only needs Functor.
20:39:41 <jle`> yeah, but munzip from MonadZip has laws
20:39:59 <jle`> munzip (mzip (x, y)) = (x, y), when () <$ x == () <$ y
20:40:27 <jle`> so Applicative is not as powerful as MonadZip
20:40:30 <Gurkenglas> That seems more like a law of mzip, since any implementation of munzip has to agree with the one that follows from Functor
20:41:17 <jle`> yeah, i guess saying it leads to a munzip-mzip disagreement is more accurate
21:24:25 * hackagebot amazonka-route53 0.3.6.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-0.3.6.1 (BrendanHay)
21:47:40 <shirt> what's the best way to decode a lazy bytestring to Text?
21:49:51 <peddie> @hoogle Data.ByteString.Lazy.ByteString -> Data.Text.Text
21:49:52 <lambdabot> Parse error:
21:49:52 <lambdabot>   Data.ByteString.Lazy.ByteString -> Data.Text.Text
21:49:52 <lambdabot>        ^
21:50:05 <peddie> @hoogle ByteString -> Text
21:50:05 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
21:50:05 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
21:50:05 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
21:50:10 <peddie> hm
21:50:12 <arkeet> what are you looking for?
21:50:40 <peddie> I was trying to answer shirt's question with hoogle and failing :(
21:50:48 <arkeet> oh.
21:51:01 <arkeet> shirt: what encoding is the text in the ByteString?
21:51:08 <shirt> should i convert lazy bytestring -> strict bytestring -> encode text
21:51:16 <peddie> anyway, shirt, I think you want something from Data.Text.Encoding
21:51:23 <shirt> or should i convert  lazy bytestring -> decode lazy text -> strict text
21:51:43 <arkeet> my guess is to go via lazy text.
21:51:49 <shirt> which is more efficient? there doesn't seem to be a direct way
21:51:55 <shirt> oh, ok. thanks
21:51:57 <arkeet> but the real answer is: benchmark it!
21:52:16 <peddie> shirt: I would be curious to know what the result of the benchmark is, that's an interesting question
21:52:44 <arkeet> the reason for my guess is that if you go via strict bytestring, you have to hold the entire bytestring in memory at some point.
21:53:01 <arkeet> but maybe it's not actually slower that way.
22:04:15 <Fylwind> hrm I wonder if having foldl' as :: [b] -> a -> (a -> b -> a) -> a would make it more convenient to use (you can do foldl' l z0 $ \ z x -> … )
22:05:52 <arkeet> :t foldl . foldl . foldl
22:05:54 <lambdabot> (Foldable t, Foldable t1, Foldable t2) => (b -> a -> b) -> b -> t (t1 (t2 a)) -> b
22:06:11 <dmj`> jle`: ping !
22:06:25 <jle`> hi :o
22:07:37 <Fylwind> arkeet: huh, that's actually useful
22:09:40 <arkeet> Fylwind: generally it's the list that varies, not the other parameters, so it is most convenient for partial application for the list to come last.
22:10:10 <arkeet> :t foldl' (+) 0
22:10:12 <lambdabot> (Num b, Foldable t) => t b -> b
22:13:21 <Fylwind> arkeet: that's another good point
22:13:57 <arkeet> I think that's the main point.
22:19:27 * hackagebot gridland 0.1.0.2 - Grid-based multimedia engine  https://hackage.haskell.org/package/gridland-0.1.0.2 (jxv)
23:00:13 <joco42> hamishmack: is this https://github.com/leksah/leksah/tree/master/xobl using the improved base ?
23:00:25 <joco42> is there a way to use the old-base?
23:01:07 <joco42> hamishmack: afaik it uses improved base
23:02:20 <joco42> hamishmack: there was some problem with getting leksah work with ghcjs, it had to do something with improved base... but i can't remember what it was, and you also suggested some fix for it...
23:02:24 <hamishmack> joco42: It uses the improved-base version of ghcjs
23:02:51 <joco42> hamishmack: yes, then i remembered correctly, how can i use old-base?
23:03:29 <joco42> hamishmack: i try to understand ghcjs-jquery with old-base and then move it to improved-base... but first i want to start with old base...
23:04:35 <joco42> something here had to change https://github.com/leksah/leksah/blob/master/xobl/setup.sh#L124
23:05:26 <hamishmack> joco42: And this.. https://github.com/leksah/leksah/blob/master/xobl/setup.sh#L131
23:05:33 <wedens> what is common practice to make `Identity -> a` and `a -> Identity a` less explicit?
23:05:53 <lolisa> Cale, do you remember the joke about monad that you told me a while ago? ("A monad is just blablabla, what's the problem?" Where blablabla is not moniod under category of endofunctor but something else that is also related to cat theory)
23:06:16 <joco42> hamishmack: right maybe the discussion is here on the log, i can find that perhaps
23:06:17 <hamishmack> also I think you will need to add something to install ghcjs-prim
23:06:58 <joco42> ok
23:07:06 <hamishmack> as per https://github.com/ghcjs/ghcjs#install-ghcjs
23:07:17 <joco42> hamishmack: so i just do a plain ghcjs install....
23:08:03 <hamishmack> joco42: You will need to do ghcjs-boot --dev --ghcjs-boot-dev-branch ghc-7.10
23:08:24 <joco42> hamishmack: cool, i try to do that
23:08:26 <joco42> today
23:08:50 <lolisa> Cale, thx, I find it.
23:10:18 <Cale> lolisa: It's only half a joke, a monad on C really is a monoid object in the monoidal category of endofunctors on C.
23:10:36 <Cale> It just takes a little work to unpack the definitions.
23:14:14 <Peaker> I'm seeing a huge performance hit when using "traverse foo someEmptyMap", where I'd expect it to be a cheap O(1) operation
23:15:15 <shachaf> someEMptyMap = Data.Map.empty?
23:15:22 <pacak> Peaker: Is it empty as a result of being created empty or as a resaly of removing all the things?
23:15:37 <Peaker> pacak: created empty
23:15:39 <Peaker> shachaf: yeah
23:16:03 <shachaf> Well, traverse _ M.empty = pure M.empty, without using f
23:16:27 <pacak> Peaker: How are you measuring this?
23:17:03 <ttt_fff> haskell is like a abusive SO
23:17:06 <ttt_fff> it makes me feel stupid
23:17:06 <Peaker> hmm.. now that I INLINE the function that does the traverse, it becomes cheap again, I think
23:17:09 <ttt_fff> and I keep on coming back for more
23:17:12 <Peaker> I changed too many things
23:17:16 <shachaf> Peaker: What if you replace foo with undefined?
23:17:20 <shachaf> Should have the same behavior.
23:17:48 <Peaker> shachaf: I'll try as soon as I figure out which of my changes brought all the perf back :)
23:19:07 <Peaker> ok, if my bitraverse and its only caller are both INLINE'd, there's no perf penalty to that traverse. I'm guessing the INLINE lets it specialize that traverse to a specific applicative
23:20:30 <Peaker> shachaf: very weirdly, changing the f to undefined slows down noticeably (though not a huge hit like the traverse was without INLINE)
23:21:00 <Peaker> shachaf: (I guess with a specific "f", GHC can simplify it more than with undefined)
23:27:31 <Wollan> I feel like I'm missing some basic imports, getting: parse error on input `deriving'
23:28:07 <shachaf> A parse error is an error in parsing, which happens before imports.
23:29:14 <Wollan> data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)
23:29:30 <Wollan> That's the line causing the parse error, can't see anyhting.
23:29:42 <shachaf> Post your full code and full error message.
23:30:08 <Axman6> Anyone know if you can find out what's changed between LTS Haskell releases?
23:30:33 <shachaf> I wish those folks wouldn't use names like "LTS Haskell"
23:30:34 <Wollan> I'm following one of the later example in lyah, 'a very simple file system' : http://learnyouahaskell.com/zippers#a-very-simple-file-system
23:30:49 <cocreature> Axman6: you probably could diff the cabal.config files
23:31:04 <shachaf> That makes it sound like a Haskell thing rather than an independent third-party thing.
23:31:09 <pacak> Wollan: Show your code. And error message. The problem is probably a few lines bellow that
23:31:22 <chattered> Does anyone use Free for implementing interpreters along the lines of https://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern?
23:31:38 <Axman6> cocreature: that's less satisfactory than I'd hoped for :(
23:32:08 <Axman6> cocreature: lots of people do. dibblego I believe has done a fair amount with them, but there's plenty of others
23:32:17 <Axman6> uh, chattered, not cocreature 
23:32:39 <Wollan> You're correct pacak & shachaf. Located the typing error. Thanks.
23:33:43 <chattered> Axman6: The problem I have with them is figuring out how to do transformations on the resulting free AST, for optimisation and stuff. But the Free constructor makes the pattern matching really verbose. I've tried using pattern synonyms but it's still pretty horrible. Is there a better way?
23:36:15 <Romefeller> Hi all
23:36:27 <Hijiri> hi rome
23:37:22 <Romefeller> Anyone knows any free host that supports haskell?
23:38:15 <pacak> chattered: There's retract
23:38:40 <pacak> chattered: Or other stuff that perform folding
23:41:59 <chattered> pacak: Yeah, that was my current line of thinking. If I can largely the same sort of expressive power I'm happy enough. My alternative is to unfold the AST to get rid of the Free bits. But then I've got to write a load of my own instances.
23:42:06 <chattered> *If I can largely get the...
23:43:20 <Hijiri> Romefeller: what kind of host? You could rent a VPS and install ghc on it
23:43:30 <Hijiri> oh, free
23:43:33 <Hijiri> heroku?
23:46:18 <Romefeller> Hijiri i have tested heroku. I looking another option. I have no success hehe.
23:47:01 <Romefeller> *am
23:56:07 <Fluent> Hey everyone, I'm learning Haskell currently, and hope this channel will prove helpful in the future :D
23:58:04 <chattered> Fluent: There's also #haskell-beginners, though you're welcome to use both.
23:59:49 <Fluent> Oh, awesome. Thank you chattered.
