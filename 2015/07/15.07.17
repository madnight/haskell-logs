00:01:15 <julianleviston> what’s an identity arrow?
00:01:25 <julianleviston> Just watching the lenses, folds, and traversals video… 
00:01:49 <julianleviston> sometimes I find parts of Haskell so impenetrable
00:03:15 <julianleviston> ooh nevermind, I’m reading this now https://www.haskell.org/arrows/
00:07:36 * hackagebot angel 0.6.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.6.2 (MichaelXavier)
00:07:36 * hackagebot text1 0.0.3 - Non-empty values of `Data.Text`.  http://hackage.haskell.org/package/text1-0.0.3 (TonyMorris)
00:08:04 <quchen2> hunteriam: Identity is a Functor, and it's quite useful.
00:08:13 <quchen2> newtype Identity a = Identity a
00:11:49 <sewilton> I've been trying to learn category theory, and there's something that's been confusing me about functors. First, functors are the morphisms in the category of small categories, Cat. Since endofunctors are functors that map a category to itself, this would mean that in Cat, all identity morphisms are endofunctors. Now, the part that confuses me is that since
00:11:49 <sewilton> the identity morphism for an object is unique, this would mean that Hask has one unique endofunctor. Obviously, this isn't the case (Unless it is, and Maybe a, List a, etc form isomorphic functors), so where have I gone wrong?
00:14:21 <funfunctor> how can I get :: m [a] -> IO [a]
00:14:41 <funfunctor> impossible right?
00:14:56 <quchen2> Yes.
00:15:04 <pavonia> :t liftIO
00:15:05 <lambdabot> MonadIO m => IO a -> m a
00:15:10 <pavonia> Err
00:16:45 <funfunctor> yea I know liftIO
00:17:06 <quchen2> sewilton: The identity morphism is unique, but you can still have many morphisms from an object to itself. In a Monoid for example, *all* arrows are from the object to itself, but only one of them is the identity.
00:17:28 <sewilton> quchen2: Ooh. Of course. Not sure how I missed that. Thanks!
00:17:42 <funfunctor> I have this action that gets a value inside some complex monad.. I want to evulate the action and use the result in another lower monad
00:17:48 <julianleviston> is there a good place to learn about arrows?
00:18:07 <julianleviston> haskell.org/arrows didn’t quite cut it for me.
00:19:09 <hunteriam> quchen2: what is it useful for?
00:19:39 <fosterite> julianleviston: not really, there aren't many Arrow tutorials. try the typeclassopedia
00:19:52 <julianleviston> fosterite:  thanks
00:20:12 <hunteriam> Are arrows actually useful for anything?
00:20:26 <quchen2> hunteriam: Identity? It's the type-level analogon of the identity function. The identity function is useful if you have other functions that are parametrized, and you want to fill that parameter with "do nothing", for example "filter id". The Identity type often serves a similar purpose, for example it's the identity of monad transformers.
00:20:29 <fosterite> applicatives pretty much ate their lunch
00:20:56 <hunteriam> Also, are they very distinct from ->
00:21:09 <julianleviston> e-kmett keeps referencing them
00:21:22 <hunteriam> Also, what are applicatives actually useful for?
00:21:24 <forgottenone> what does <$ do in functor class
00:21:35 <quchen2> ?src <$
00:21:36 <lambdabot> (<$) = (<$>) . const
00:21:47 <hunteriam> :t comet
00:21:48 <lambdabot> Not in scope: ‘comet’
00:21:55 <hunteriam> :t const
00:21:56 <lambdabot> a -> b -> a
00:22:05 <quchen2> > 5 <$ Just 10
00:22:07 <lambdabot>  Just 5
00:22:12 <hunteriam> :t (<$>)
00:22:13 <quchen2> 5 <$ [1,2,3,4]
00:22:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:22:16 <quchen2> > 5 <$ [1,2,3,4]
00:22:17 <lambdabot>  [5,5,5,5]
00:22:33 <quchen2> It's "fmapping with a constant function"
00:22:44 <hunteriam> Why not ju
00:22:45 <funfunctor> Can someone help me break down this type-checking issue please? http://lpaste.net/136778
00:22:48 <hunteriam> Oh I see
00:23:02 <forgottenone> quchen2: i see thanks
00:23:12 <supki> julianleviston: really? where?
00:23:15 <hunteriam>  funfunctor can you include the code it's referencing?
00:26:14 <funfunctor> hunteriam: http://lpaste.net/136778
00:26:59 <julianleviston> supki: oh maybe I was somewhat deluded - I can’t find it now… I thought it was in this video early on https://youtu.be/cefnmjtAolY
00:29:19 <julianleviston> supki: oh no, it was because I was looking up comonads and then that referenced arrows. So much to learn!
00:30:36 <julianleviston> supki: oh no, he says “and that there’s an idenitity arrow” or something - and I wanted to know what that meant, here https://youtu.be/cefnmjtAolY?t=405
00:30:52 <julianleviston> and I have no clue what an identity arrow is
00:32:58 <sewilton> julianleviston: I haven't watched the video yet, but I'd imagine he means this: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Arrow.html#returnA
00:33:23 <julianleviston> sewilton: ahhh thanks!
00:33:37 <supki> julianleviston: oh, there "arrow" simply means function
00:34:50 <sewilton> julianleviston: Ah whoops, sorry for misleading you. I hadn't opened the video, and thought you were still asking about arrows
00:35:25 <supki> yeah, Control.Arrow is completely unrelated
00:35:55 <julianleviston> oh… ok. is (->) also pronounced arrow?
00:36:05 <julianleviston> also by the way, how do you pronounce (-> r) ?
00:37:12 <fosterite> REader monad
00:38:48 <supki> julianleviston: in category theory, "arrow", "function", and "morphism" are used interchangeably
00:39:05 <wetmore> hey, is there anyone here who could answer some questions about cabal problems?
00:39:16 <supki> julianleviston: in the video, Lens (Store id) :: Lens a a is the identity morphism in the category Lens
00:39:55 <julianleviston> supki: thanks.
00:40:59 <raichoo> supki: Not exactly. Functions are morphisms but not over morphism is a function.
00:41:20 <raichoo> In categories like "Set" this is true.
00:42:33 * hackagebot potato-tool 0.1.0.2 - Command line Dreamcast VMU filesystem toolset.  http://hackage.haskell.org/package/potato-tool-0.1.0.2 (RossMeikleham)
00:42:34 <raichoo> s/over/every/
00:46:06 <julianleviston> supki: do you have any recommendations for learning category theory?
00:46:19 <wetmore> where does the hash at the end of "dependency "blaze-builder-0.3.3.4-be3a6e246d3e4fa0b5468437aaf3041e" doesn't exist" mean?
00:46:39 <ttt_fff> i wonder if there is a market for a tinder for haskellers
00:46:49 <raichoo> julianleviston: Steve Awodey's "Category Theory" is my favorite.
00:49:44 <julianleviston> raichoo: cool… got it. I’ll read it. Thanks.
00:50:13 <raichoo> julianleviston: It'll take some time to work through this book. There is also a lecture by awodey on youtube.
00:50:30 <raichoo> julianleviston: It's called "Category Theory Foundations" if I'm not mistaken.
00:50:37 <julianleviston> raichoo: yeah, I already saw it
00:51:19 <julianleviston> raichoo: is he bad at explaining things? why will it take a long time?
00:51:25 <julianleviston> or is category theory hard? 
00:51:57 <raichoo> It's just way more abstract that I thought it would be ^^. Maybe I'm just slow. But it takes time to get used to these very abstract concepts.
00:52:01 <fosterite> ttt_fff: maybe if you made it a general programming one
00:52:31 <julianleviston> raichoo: ah ok… guess we’ll see. 
00:52:34 <raichoo> It's easy to learn some mathy sounding words but it's harder to really get an intution for what is going on.
00:52:50 <raichoo> "intuition" that is
00:53:46 <julianleviston> is interpunkt functional composition in category theory? (ie middle circle)
00:54:19 <quchen2> It's from math in general.
00:54:23 <raichoo> composition is pretty much one of the main themes of CT. ^^
00:54:27 <wetmore> its composition of morphisms
00:54:31 <ttt_fff> wtf is CT ?
00:54:36 <raichoo> Category Theory
00:54:40 <wetmore> CT = category theory
00:54:44 <julianleviston> nevermind I’ll be ok.
00:54:58 <julianleviston> yeah, that’s what I thought. cool.
00:55:04 <julianleviston> just wasn’t used to the nomenclature.
00:55:06 <wetmore> composition of morphisms is more general; it's one of the definition operations of a category
00:55:53 <raichoo> Once you grok categories you see them popping up everywhere, not just the ones with functions as morphisms.
00:56:20 <julianleviston> I have no problem with semantics - all my problems come from syntax or lexicon
00:57:17 <raichoo> Anyway, "meeting time". I hope I'm not dying of boredom :P See you around.
00:58:04 <ttt_fff> category theory, that thing where only category theory phd students understand
00:58:27 <raichoo> ttt_fff: I'm a college dropout, here to prove you wrong ;)
00:58:27 <hunteriam> Ttt I'm just some random undergrad and I found a presentation that explains it pretty well
00:58:29 <hunteriam> If you want
00:59:00 <julianleviston> hunteriam: do want! :)
00:59:08 <hunteriam> http://yogsototh.github.io/Category-Theory-Presentation/
00:59:11 <ttt_fff> raichoo: college drop out + having a Phd are not mutually exclusive
00:59:22 <mniip> [10:57:27] <ttt_fff> category theory, that thing where only category theory phd students understand
00:59:24 <hunteriam> I recommend googling and asking about anything that it doesn't explain well enough
00:59:25 <julianleviston> oh good old yogsoth… he was here earlier
00:59:30 <quchen2> ttt_fff: There are plenty of others who learned those things in their spare time here.
00:59:34 * mniip <- 17
00:59:34 <raichoo> ttt_fff: I don't have a Phd, I'm far from it :D
00:59:40 <raichoo> Ok, really gotta go now.
00:59:42 <hunteriam> I've been going through it for the past day or two
00:59:45 <hunteriam> Cya raichoo
01:00:45 <seku> mh, looks like a nice presentation
01:01:08 <ttt_fff> hunteriam: that looks nice, will study it later when am not so sleepy
01:01:23 <mniip> I had a decent knowledge of haskell when I started figuring out CT though, it helped a lot
01:01:24 <ttt_fff> how can I tell lambdabot to remember the url ?
01:01:32 <ttt_fff> mniip: you're only 17?
01:01:40 <hunteriam> Good luck! What always put me off CT was all the terms I didn't understand
01:01:42 <mniip> yeah
01:01:44 * dramforever is thinking about the "monoid on the category of endofunctors" thing for like...half an hour?
01:01:52 <ttt_fff> mniip: where are you going to for college next year?
01:01:53 <hunteriam> Yesterday I just started googling them recursively
01:02:12 <ttt_fff> #haskell // where teenagers make you feel stupid
01:02:14 <mniip> ttt_fff, next? I'm entering a university this year
01:02:14 <dramforever> hunteriam: lol I did the same same 
01:02:20 <adarqui> ttt_fff: lmfao..
01:02:21 <ttt_fff> mniip: which school?
01:02:28 <ttt_fff> MIT? Caltech?
01:02:37 <mniip> wrong country :P
01:02:41 <ttt_fff> Oxford?
01:02:43 <ttt_fff> Tsinghua?
01:02:55 <julianleviston> guh. this presentation sucks.
01:03:05 <hunteriam> Hey I'm only a year ahead of him and definitely not at a prestigious university
01:03:08 <julianleviston> or put a different way, I suck.
01:03:14 <hunteriam> Although maybe that year is all the difference lol
01:03:34 <dramforever> ttt_fff: seriously is tsinghua *that* famous?
01:03:38 * dramforever is from China
01:03:57 <ttt_fff> dramforever: yeah, it's the only university from China
01:04:02 <ttt_fff> there are other schools in China?
01:04:02 <hunteriam> Well, I've never heard of it, but I'm pretty out of the loop
01:04:13 <mniip> dramforever, describe "category of endofunctors"
01:04:28 <julianleviston> talk to you later. thanks everyone
01:04:31 <ttt_fff> dramforever: (I actually don't know; just some people I know of really like Tsinghua)
01:04:37 <hunteriam> Man, when people bring up age and school I get so insecure...
01:04:48 <adarqui> hunteriam: why?
01:04:52 <ttt_fff> yeah; I think I
01:04:55 <ttt_fff> ''m the oldest here
01:04:59 <ttt_fff> whihc makes me from the dinosaur age
01:05:12 <hunteriam> I think I'm ashamed of my school, and not sure of my intelligence/value
01:05:15 <ttt_fff> I bet simon peyton jones is older than me though; so I houldn't feel too bad
01:05:40 <mniip> well I come from a very ordinary school though
01:05:41 <hunteriam> Lol sorry for bringing that up ##haskell..
01:05:42 <ttt_fff> whenever I feel bad about myself, I look at my code, and think, ... atleast I'm not using OCaml
01:06:26 <adarqui> github.com/janestreet seems like a fun place to work.. they are an ocaml shop
01:06:27 <mniip> dramforever, seriously describe "category of endofunctors", I'm intrigued
01:06:35 * dramforever doesn't know
01:06:49 <mniip> are endofunctors objects? what are morphisms then
01:06:51 * dramforever is recursively googling it
01:06:55 <hunteriam> Lol
01:06:56 <adarqui> i've gotten into 'math and haskell' at age 32.. so i'm a late starter, but whatever.. i just want to keep learning and improving, that's all i care about
01:06:58 <Haskellfant> natural transformations 
01:06:59 <adarqui> ;d
01:07:02 <mniip> hm
01:07:09 <hunteriam> mniip: endofunctor a are functors from A-> A
01:07:20 <mniip> yeah I know what endofunctors are
01:07:43 <hunteriam> Oh I understand your question
01:07:48 <mkollar> adarqui: seems like a dreamjob...
01:08:05 <hunteriam> I'd assume endofunctor a are objects and morphisms are natural transformations like haskellfant said
01:08:10 <adarqui> mkollar: janestreet?
01:08:33 <mkollar> adarqui: yes
01:08:53 <hunteriam> I wish I had any job lol, terrified at my lack of job
01:09:01 <hunteriam> In college so it's not totally justified
01:09:15 <hunteriam> Still though, getting a job is terrifying, and seemingly random
01:09:26 <adarqui> ya, definitely.. seems like a great place to work. they talk alot about it in their blog too.. great perks ;f
01:09:40 <seku> talking about jobs... youll end up someplace you didnt think about later :)
01:09:58 <mniip> dramforever, that seems like a specialization of the endofunction monad
01:10:07 <mniip> monoid*
01:10:28 <mkollar> adarqui: you know their puzzle page? https://www.janestreet.com/puzzles/
01:10:39 <mniip> mzero = id :: f a -> f a
01:10:56 <dramforever> well I guess it would be type NaturalTransformation f g = forall a. f a -> g a
01:11:07 <dramforever> so it's a generalization
01:11:14 <mniip> mconcat = (.) :: (f a -> g a) -> (h a -> f a) -> h a -> g a
01:11:36 <dramforever> 1. you mean mappend
01:11:41 <dramforever> 2. it doesn't work =(
01:11:45 <mniip> er yeah, mappend
01:11:50 <dramforever> because the two arguments need to be the same type
01:12:23 <mniip> I should sleep
01:12:27 <adarqui> mkollar: ya i've never done any though.. that puzzle is cool, considering the 'identifying new problems in the financial markets and ways to solve them' angle
01:12:30 <mniip> those are 'id' and '<<<'
01:12:35 <dramforever> bingo! I think i'm getting the "monoid in the category of endofunctors" thing =)
01:12:57 <wetmore> you know what a monoid in a category is
01:12:58 <wetmore> ?
01:13:29 <mniip> you fix an object and examine morphisms from that object to itself?
01:13:36 <adarqui> oh i think igot tricked.. ;f , it's at /current-puzzle/
01:13:38 <adarqui> <- noob
01:14:00 <mkollar> adarqui: this months puzzle looks nice, though I haven't had chance to look into it deeper due to my current job :-)
01:14:15 <wetmore> mniip: yeah
01:14:47 <mniip> in case of natural transformations that seems rather boring
01:15:53 <dramforever> This is my understanding: first we need a monoidal category (C, (*), Id) such that (*) : C x C -> C is a bifunctor and Id is the left and right identity of (*), up to natural isomorphisms
01:17:14 <dramforever> so here we have C = End(Hask), x is Compose, Id is Identity
01:17:17 <hunteriam> So, a Functor is represented as a collection of morphisms, right?
01:17:45 <dramforever> Disclaimer: here are my understandings, they might be wrong
01:17:54 <hunteriam> A Functor is just any collection of morphisms that maps a category to a category
01:18:05 <mniip> an endobifunctor is a biendofunctor!
01:18:09 <mniip> that's ingenious
01:18:33 <dramforever> hunteriam: and satisfies some laws
01:20:26 <hunteriam> Well, for one, the morphisms don't have to behave identically, like they do in Haskell, right?
01:20:29 <dramforever> and a monad M requires two more things, eta(a.k.a return) : I -> M, and mu(a.k.a join) : M x M -> M
01:20:30 <mniip> hunteriam, a functor is a bijection between two categories' objects and morphisms
01:20:50 <dramforever> why bijection?
01:21:01 <mniip> hm
01:21:04 <mniip> yeah not a bijection
01:21:10 <hunteriam> That's not actually true
01:21:14 <dramforever> hunteriam: remember the functor laws?
01:21:18 <hunteriam> Cause it doesn't have to be one to one
01:21:22 <dramforever> something like that
01:21:23 <mniip> it's a function
01:21:28 <hunteriam> Let's see, composition, and something else
01:21:35 <dramforever> identity
01:21:45 <mniip> a function from objects to objects, and a function from morphisms to morphisms
01:22:20 <hunteriam> Right, but the Functor itself doesn't have to have some unifying theme in the way it maps the objects from cat to cat
01:22:34 <hunteriam> A Functor is just an observation that such morphisms exist
01:22:38 <wordsarewind> quick question
01:22:43 <hunteriam> Maybe?
01:23:06 <mniip> hunteriam, huh
01:23:07 <wordsarewind> can tuples contain any number of values?
01:23:22 <wordsarewind> or are they restricted to some number (say 20)?
01:23:26 <dramforever> no, IIRC in ghc, up to 63
01:23:27 <mniip> wordsarewind, by the report, yes
01:23:32 <mniip> but GHC can only handle 62
01:23:32 <Axman6> I think GHC has a max of 63
01:23:42 <wordsarewind> ah
01:23:48 <mniip> it's 62 guys
01:23:57 <Axman6> we annoyingly ran into an instance where (some TH generated) code used 63 tuples -_-
01:24:18 <mniip> Axman6, https://ghc.haskell.org/trac/ghc/ticket/10648
01:24:25 <dramforever> wordsarewind: oh and large tuples don't have some instances defined
01:24:32 <hunteriam> mniip: in Haskell, functors are defined by a single function fmap and the type constructor, but in CT, the morphisms of the Functor don't have to all do the same thing to get from object a to b, right?
01:24:34 <dramforever> > ((),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),())
01:24:36 <lambdabot>      No instance for (Show
01:24:36 <lambdabot>                         ((),
01:24:36 <lambdabot>                          (),
01:24:37 <ttt_fff> WHAT? only 63 tuples?
01:24:46 <wordsarewind> ah right
01:25:06 <mniip> hunteriam, I don't follow
01:25:08 <wordsarewind> well thanks
01:25:27 <hunteriam> So in Haskell fmap from type A to B does the same thing regardless of what's in the type, but in general a Functor doesn't have to do the same thing for every object it maps
01:25:27 <Axman6> mniip: ... that's awesome, heh
01:25:30 <mniip> fmap is a function that maps Hask morphisms to F Hask morphisms
01:25:32 <ttt_fff> > let f 0 _ = (); f i x = f (i-1) (x, ()) in f 20
01:25:34 <lambdabot>      Occurs check: cannot construct the infinite type: t1 ~ (t1, ())
01:25:34 <lambdabot>      Relevant bindings include
01:25:34 <lambdabot>        x :: (t1, ()) (bound at <interactive>:1:21)
01:25:40 <ttt_fff> pls help me debug code
01:25:41 <mniip> type constructor is a function that maps Hask objects to F Hask objects
01:25:54 <mniip> ttt_fff, what is the type of your function
01:26:05 <wetmore> yeah sure there are functors you can't write with a formula
01:26:09 <ttt_fff> f :: Int -> oh shit --> does not type check
01:26:17 <ttt_fff> that is the type of my function
01:26:26 <mniip> ttt_fff, which is why you can't implement it
01:26:43 <ttt_fff> i just got schooled
01:26:48 <ttt_fff> by someone who's not even in college yet
01:26:53 <ttt_fff> i should turn in my programmer badge
01:26:55 <hunteriam> Yes, but a Functor is not a single Morphism, a Functor is the existence of all the random morphisms that map between categories
01:26:59 <hunteriam> Is that right?
01:27:21 * ttt_fff hands off 'haskeller badge' to hunteriam
01:27:25 <wetmore> huh
01:27:38 <wetmore> you can see a functor as a morphism in the category of categories
01:28:37 <augur> ttt_fff: the second arg of f is a in one instance, but (a,()) in another
01:28:42 <hunteriam> And that Morphism only exists because a bunch of morphisms exist in the categories to map the objects and morphisms to the related ones
01:29:52 <augur> ttt_fff: ideally this should be possible, because f can be polymorphic in the second arg but i think that type inference can't find that solution
01:29:57 <wetmore> morphisms do not map between categories
01:30:00 <wetmore> they are internal
01:30:16 <augur> ttt_fff: if you explicitly say that the type is  f :: Int -> a -> ()   then it should be fine
01:30:37 <augur> ttt_fff: but right now haskell doesn't know that it needs to be quite so polymorphic in the second arg
01:30:52 <ttt_fff> > let f 0 = (); f i = (f i-1, ()) in f 20
01:30:53 <lambdabot>      Couldn't match expected type ‘()’ with actual type ‘((), ())’
01:30:54 <lambdabot>      In the expression: (f i - 1, ())
01:30:54 <lambdabot>      In an equation for ‘f’: f i = (f i - 1, ())
01:30:59 <ttt_fff> is there a way to get that code to compile?
01:31:25 <augur> ttt_fff: like i said, give it a type signature
01:31:31 <ttt_fff> augur: how?
01:31:36 <dramforever> augur: are you sure?
01:31:42 <ttt_fff> augur: please enlighten me
01:31:43 <augur> well, not THAT code, sorry
01:31:44 <wetmore> hunteriam: if I understand you correctly you are saying that a functor F : C -> D where C, D are categories is like a bookkeeping reference to the fact that there is a morphism between some objects in C and some in D
01:31:45 <augur> the previous one
01:32:07 <augur> > let f :: Int -> a -> () ; f 0 _ = () ; f i x = f (i-1) (x,()) in f 20
01:32:08 <lambdabot>      No instance for (Typeable a0)
01:32:08 <lambdabot>        arising from a use of ‘show_M635972334871388265328534’
01:32:08 <lambdabot>      In the expression:
01:32:16 <augur> ugh, lambdabot
01:33:07 <augur> > let f :: Int -> a -> () ; f 0 _ = () ; f i x = f (i-1) (x,()) in f 20 "foo"
01:33:08 <lambdabot>  ()
01:33:37 <augur> > let f 0 _ = () ; f i x = f (i-1) (x,()) in f 20 "foo"
01:33:38 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ (t, ())
01:33:38 <lambdabot>      Relevant bindings include
01:33:38 <lambdabot>        x :: (t, ()) (bound at <interactive>:1:22)
01:33:49 <hunteriam> Wetmore yes that is what I was saying, the morphism between the two categories, is that what the Functor actually is, or is that just a way to think of it?
01:33:51 <wetmore> hunteriam: however it doesnt "typecheck" to have a morphism from an object in C to an object in D unless you are talking about them in some larger category, in which case you might as well just view C and D as two objects in Cat and see the functor as a morphism
01:34:07 <augur> ttt_fff: see? the explicit type annotation declaring the second arg to be polymorphically quantified pre-empts the type inference system
01:34:58 <wetmore> hunteriam: I think you are focusing too much on being able to explicitly define things?
01:35:53 <wetmore> hunteriam: a functor is just a mapping
01:36:08 <wetmore> like "you give me something in C and I give you the object it maps to in D"
01:36:29 <wetmore> but you dont need to encode this mapping in the language of category theory
01:36:44 <augur> ttt_fff: whats happening is that the second clause causes a conflict. the LHS of the = says   f :: Int -> S -> T   for some S and T that we dont know, and the right handle side says   f :: Int -> (S,()) -> T
01:37:12 <wetmore> as an analogy, when we define a function in set theory we say a function f : A -> B assigns each element of the set A an element of the set B
01:37:15 <augur> ttt_fff: these two together say S = (S,()) but this equation can't be true, so the type inference system is confused and doesnt know what to do
01:37:42 <dramforever> oh the occurs check is done when doing unification
01:38:10 <wetmore> but you don't ask about what connects the elements from A to B
01:38:14 <dramforever> the unifier checks that a variable cannot unify with a expression that has that variable occuring free, unless the whole expression is just the variable
01:39:39 <augur> ttt_fff: this is only happening because type inference is being used. it's trying to guess the type you intended. the inference system, however, doesn't know how to introduce polymorphism to handle these cases
01:39:43 <augur> im not sure if it should or not
01:39:56 <ttt_fff> jyeah
01:40:00 <augur> i think it only knows how to introduce polymorphism at the very end
01:40:01 <ttt_fff> but I think either way, I can't get a haskell function to output
01:40:05 <ttt_fff> (), ((), ())
01:40:11 <ttt_fff> followed by (((), ()), ())
01:40:14 <dramforever> use typeclasses maybe?
01:40:19 <ttt_fff> folowed by ((((), ()), ()), ())
01:40:34 <augur> like, it produces a type   S -> T   where S and T are still unknown, and then, at the very end, it can do it by hitting them all with a type var
01:40:56 <augur> ttt_fff: what do you mean "output"?
01:41:19 <augur> you mean you want to do   f n ()  and itll produce the n-th such nesting?
01:41:36 <augur> f 0 () = ()    f 1 () = ((),())   f 2 () = (((),()),())
01:41:37 <ttt_fff> augur: yes
01:41:37 <augur> etc?
01:41:45 <ttt_fff> augur: yes ... pure evil, isn't it?
01:42:11 <wetmore> hunteriam: Suppose there is a functor F : C -> D, and c is an object in C. There is not necessarily a morphism from c to F(c)
01:42:35 * hackagebot timers 0.2.0.3 - Simple package that implements timers.  http://hackage.haskell.org/package/timers-0.2.0.3 (PetrPilar)
01:42:46 <augur> ttt_fff: the type of the result is dependent on the value of the first input, so it's no surprise you cant make it work
01:43:06 <augur> but you can use datakinds to get some cheap dependency that might do it (probably not tho!)
01:43:28 <augur> if you used peano nats, datakinds should work tho
01:44:36 <augur> or singletons, since you need to get runtime data up into the types
01:44:59 <augur> haskell's kind of ugly for this sort of thing. dependently typed systems make it easy tho
01:45:08 <augur> i think in idris this would be somthing like
01:45:41 <augur> Nested : Nat -> Type  ;  Nested Zero = ()  ;  Nested (Suc n) = (Nested n, ())
01:46:03 <augur> f : (n : Nat) -> Nested n  ;  f Zero = ()  ;  f (Suc n) = (f n, ())
01:47:43 <mniip> ttt_fff, were you looking for something like
01:47:49 <lpaste_> mniip pasted “tuples” at http://lpaste.net/136780
01:48:28 <ttt_fff> mniip: {-# LANGUAGE DataKinds, TypeOperators, TypeFamilies, FunctionalDependencies, FlexibleInstances, FlexibleContexts, UndecidableInstances #-} <-- LOL
01:48:45 <mniip> no other way
01:48:50 <augur> ttt_fff: welcome to the land of no dependent types :)
01:48:54 <mniip> oh also
01:49:02 <mniip> 1 is not a value parameter but a type parameter
01:49:12 <ttt_fff> mniip: what does "Proxy" and "Ordering" meant to mean/represent?
01:49:28 <mniip>  > tuple (Proxy :: Proxy 1)
01:49:28 <mniip> ((),())
01:49:50 <mniip> ttt_fff, data Proxy (a :: k) = Proxy
01:49:58 <mniip> Ordering is from Prelude
01:50:09 <ttt_fff> oh, from deriving (Eq, SHow, Ord) ?
01:50:17 <jle`> i defined a type family ++
01:50:23 <mniip> data Ordering = LT | EQ | GT 	-- Defined in ‘GHC.Types’
01:50:31 <ttt_fff> ah
01:50:38 <jle`> is there any way to prove to ghc that if vs ++ us ~ '[], then vs ~ '[] and us ~ '[] ?
01:51:32 <mniip> jle`, as a fundep maybe
01:51:45 <jle`> how do i go about that :|
01:52:00 <mniip> scratch type families and enter the land of MPTC?
01:52:28 <jle`> boo
01:52:41 <jle`> thanks though
01:53:52 <mniip> I had to solve a similar problem earlier today
01:54:48 <mniip> having type family Replicate (n :: Nat) e where Replicate 2 e = (e, e); Replicate 3 e = (e, e, e) ...
01:54:50 <jle`> hm, having trouble formulating the MPTC with fundeps
01:55:03 <jle`> this sounds like a job for stack overflow
01:55:11 <mniip> I wanted it to be able to infer n~3, e~x from Replicate n e ~ (x, x, x)
01:56:12 <jle`> mniip: how did you do it? :o
01:56:43 <mniip> I used []
01:57:01 <jle`> ah
01:57:10 <jle`> and then a length typeclass?
01:57:30 <mniip> nah
01:57:50 <mniip> hmm
01:58:04 <mniip> I messed up :D
01:58:10 <zipper> Which haskell testing frameworks should I use for a haskell program written today?
01:58:18 <zipper> I'm thinking HUnit and quickcheck?
01:58:30 <dramforever> zipper: what's the program like?
01:59:30 <mniip> I think I got an idea
01:59:39 <jle`> thanks anyway :)
01:59:56 <mniip> (r ~ Replicate n e, n ~ Length r, e ~ Head r) => r
01:59:58 <zipper> dramforever: I have it on github. Wanna see?
02:00:14 <mniip> I think that would provide the required amount of inference
02:00:38 <dramforever> zipper: quickcheck and smallcheck are property checkers
02:00:40 <zipper> dramforever: I'm not sure how to write unit tests for it because it's kinda stateful. I don't know how to check that it's doing compilation. etc.
02:00:55 <dramforever> =(
02:01:11 <zipper> dramforever: Why the sad face?
02:01:18 <zipper> I think I told you about it yesterday.
02:01:28 <dramforever> I don't know what should I do
02:01:49 * dramforever checks yesterday's irc log
02:02:41 <dramforever> oh yesod-devel
02:03:19 <zipper> dramforever: Yes
02:03:34 <dramforever> no, I don't know how to test it
02:03:37 <zipper> Don't be saddish, have a raddish.
02:03:50 * dramforever eats the raddish
02:05:19 <mniip> jle`, omg
02:05:20 <mniip> it works
02:05:26 <jle`> :o
02:06:16 <mniip> you need an inversion-like type family I guess
02:06:54 <mniip> cut rs xs = drop (length xs) rs
02:06:56 <mniip> but in type families
02:07:17 <FixBit> hi
02:07:19 <jle`> but this is only invertable for the [] case
02:07:23 <jle`> hi FixBit :)
02:07:26 <mniip> then you can have (r ~ a ++ b, b ~ Cut a r) => r
02:07:58 <FixBit> first time here
02:09:17 <jle`> hm, i'll look at that :)
02:09:19 <jle`> FixBit: welcome :)
02:09:24 <jle`> learning haskell?
02:09:51 <ttt_fff> FixBit: run away, before you get addicted to monads, typeclasses, the type system ... and become unable to use any other language
02:09:55 <FixBit> yep. Just started exploring
02:10:05 <FixBit> lol
02:11:36 <mniip> jle`, check this out
02:11:55 <lpaste_> mniip pasted “Replicate” at http://lpaste.net/136781
02:12:14 <jle`> ty ty
02:12:23 <mniip> Head and Length enforce no extra constraints on the argument
02:12:50 <mniip> so for example, Length (Num a => a, Num b => b) doesn't freak out
02:13:21 <mniip> and instead Head (Num a => a, Num b => b) returns Num a => a, which is then fed into Replicate 2, which returns (Num a => a, Num a => a)
02:13:25 <jle`> omg it worked
02:13:26 <mniip> which is unified with the original
02:13:27 <jle`> your Cut type family
02:13:30 <jle`> how did this even happen
02:13:32 <jle`> what
02:13:34 <jle`> i don't even know
02:13:41 <jle`> urrhghgh
02:13:46 <jle`> i'm so confused right now
02:14:00 <mniip> show code?
02:14:35 <jle`> have to go but i'll try to clean somethingn up eventually heh
02:14:47 <mniip> omg
02:14:56 <mniip> I think I pretty much nailed the inference issue
02:15:13 <mniip>  > :t unpack (undefined, undefined)
02:15:13 <mniip> [t]
02:16:09 <hunteriam> What happened jle`
02:16:19 <hunteriam> Wait what's going on here
02:16:22 <jle`> i don't even know
02:16:27 <hunteriam> What inference issue mniip
02:16:32 <hunteriam> Lol
02:16:57 <mniip> hunteriam, look at the Replicate family: http://lpaste.net/136781
02:17:15 <hunteriam> First question, type family?
02:18:03 <mniip> if we have a function of type Replicate n e -> D n e
02:18:17 <mniip> should've named it
02:18:26 <mniip> if we have a function foo :: Replicate n e -> D n e
02:18:37 <mniip> how do we make GHC understand that foo ((), ()) :: D 2 ()
02:18:51 <mniip> whatever D is
02:19:33 <mniip> the reverse is obvious, given n e, GHC can infer Replicate n e by following the definition of the type family
02:20:29 <hunteriam> This looks like a dependant type
02:20:45 <hunteriam> Esp since I didn't know you could use numbers like that in Haskell
02:21:11 <sveri> Hi, I want to read from stdin some ints like "148 3 5" and have it read as a list of Nums / Ints like this [148, 3, 5] is that possible without parsing the string I get with getLine?
02:21:28 <mpickering> What is a pattern binding?
02:21:43 <dramforever> > words "foo bar baz" -- sveri check this
02:21:44 <lambdabot>  ["foo","bar","baz"]
02:22:01 <dramforever> btw read is parsing the string =)
02:22:03 <mniip> > read "148" :: Int -- sveri check this
02:22:05 <lambdabot>  148
02:22:25 <Cale> mpickering: A pattern binding is a binding which has just a pattern on the left side of the = sign, often a single variable
02:22:33 <Cale> For example, like x = 5
02:22:37 * hackagebot Spock-digestive 0.1.0.1 - Digestive functors support for Spock  http://hackage.haskell.org/package/Spock-digestive-0.1.0.1 (AlexanderThiemann)
02:22:41 <Cale> or (x:xs) = [1,2,3,4]
02:22:51 <mpickering> thanks Cale 
02:23:37 <sveri> dramforever: thanks, I guess I just use words
02:23:42 <Cale> This is contrasted with function bindings which consist of the function's name followed by one or more patterns to match against the arguments
02:31:36 <hunteriam> mniip: what's the significance of the replicate thing?
02:31:54 <mniip> hunteriam, configurable inference
02:32:03 <mniip> fundeps in type families
02:33:51 <hunteriam> I wish I knew the significance of those things lol
02:37:37 * hackagebot rest-gen 0.17.1.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.1.2 (ErikHesselink)
02:58:40 <exfalso> hi, i have a binary linked with profiling enabled, AND all packages it depends on are also profiled
02:58:47 <exfalso> however +RTS -xc only prints call centers of the main executable
02:59:05 <exfalso> *cost centres
02:59:24 <exfalso> how can i get it to print cost centres from packages it depends on?
03:00:40 <beta_cuckhold> Man, K&R sucks ass compared to SICP
03:00:52 <beta_cuckhold> SICP is better written and a better intro to Scheme than K&R is to C, which is sad, since its intention wasn't to teach Scheme at all
03:01:00 <beta_cuckhold> That's how god awful K&R is
03:02:58 <beta_cuckhold> All of my time using this garbage book to learn C has been wasted, because K&R is trash
03:03:51 <beta_cuckhold> I probably could have learned more from LYAH or something
03:04:18 <Cale> exfalso: You'd have to build the libraries not just with profiling on, but also with -fprof-auto or something, so that they would have cost centres
03:04:44 <Cale> beta_cuckhold: Quality of books about C is a little offtopic here...
03:04:47 <exfalso> Cale: ty, will try that
03:05:20 <beta_cuckhold> Cale: It's just THAT bad; sooo overrated, as a beginners book
03:06:44 <dramforever> do we have a negated isn't?
03:06:45 <dramforever> :t isn't
03:06:47 <lambdabot> APrism s t a b -> s -> Bool
03:06:59 * dramforever didn't find one in Control.Lens.Prism
03:07:27 <maerwald> wat
03:07:34 <maerwald> interesting
03:07:37 <supki> dramforever: it's in Control.Lens.Extras
03:07:41 <dramforever> hmm..
03:07:46 <beta_cuckhold> By how much (0-10) do you guys prefer Haskell over C?
03:07:59 <dramforever> supki: wow
03:08:07 <supki> also you should use has instead
03:08:29 <dramforever> okay
03:08:51 <maerwald> beta_cuckhold: 6, because it depends on the job, but in general it's just more fun (most of the time) to do haskell
03:09:45 <Cale> dramforever: Control.Lens.Extras defines 'is'
03:10:00 <dramforever> yes supki already told me
03:10:07 <dramforever> oh thanks to all =)
03:10:29 <Cale> beta_cuckhold: I wouldn't use C for anything at this point, so I guess 10.
03:10:40 <dramforever> 10, I use C++
03:10:53 <Cale> There are other languages which are more appropriate for the stuff that C is better at than Haskell.
03:11:24 <maerwald> I don't think NASA will switch to Haskell :P
03:11:37 <maerwald> or anything else than ASM/C
03:11:48 <beta_cuckhold> Yeah, to Hell with C. I am DONE with this unnecessarily technical language and this abysmally shit book that is K&R!
03:12:10 <maerwald> I can sense a very small amount of frustration
03:13:17 <lieven> maerwald: NASA isn't the ultimate arbiter on programming languages.
03:13:26 <maerwald> never said that
03:13:31 <beta_cuckhold> maerwald: I am pissed with this overrated book
03:13:34 <lieven> maerwald: and they have already used Common Lisp in the past 
03:13:43 <beta_cuckhold> Waste of time, this book
03:13:51 <maerwald> I just disagree with the broadness of "There are other languages which are more appropriate for the stuff that C is better at than Haskell."
03:14:26 <bjornars> beta_cuckhold: seems like K&R is wasting its time with you.. stop whining
03:14:33 <lieven> personally for some of the lower level stuff I would use Ada
03:15:27 <beta_cuckhold> bjornars: The books a cult hit, like a religion -- something people praise blindly
03:16:12 <beta_cuckhold> You criticize it at all like Zed Shaw and you're raped by angry cultists -- no condom or lube
03:16:20 <tdammers> beta_cuckhold: the value of K&R lies in the fact that it was written by the people who invented C
03:16:50 <beta_cuckhold> Yeah, that's about it; that makes people think that by default it's amazeballs
03:16:59 <tdammers> beta_cuckhold: it's not supposed to be the best book for learning C, but because it describes the original vision of the C programming language from the point of view of its inventors, it gives some unique insights
03:17:14 <tdammers> and that part *is* amazeballs
03:17:20 <Cale> beta_cuckhold: Please try to watch the language.
03:17:48 <tdammers> if, however, you are looking for something other than this kind of insight, then K&R is maybe not the best book
03:17:51 <Cale> (in fact, if you could pick a more appropriate nick, that would also be good)
03:17:58 <maerwald> :o
03:18:11 <lieven> back in the days, I thought Harbison & Steele was a better C intro text
03:18:27 <wei2912> is this some C vs Hasell flame war
03:18:30 <wei2912> Haskell*
03:18:30 <beta_cuckhold> Cale: It's what I am, though
03:18:31 <Fuuzetsu> am I still in #haskell or in #c
03:18:35 <wei2912> or a K&R bash?
03:18:42 <beta_cuckhold> ^
03:18:48 <lieven> Steele seems to get drawn to documenting languages
03:19:11 <lieven> too bad Oracle killed his Fortress project
03:19:19 <beta_cuckhold> SICP at least lives up to its 'beginner' hype
03:20:35 <Cale> beta_cuckhold: That doesn't make it appropriate.
03:21:12 <beta_cuckhold> I'd be better off learning Java, honestly
03:22:23 <BartAdv> anyoni had luck trying FRPNow library? I can't build it. Got: can't find source for Control/FRPNow in .
03:23:04 <BartAdv> (cabal 1.22.2.0)
03:23:38 <jakeehrlich> I have an issue, involving GDATs and multiparameter type classes, in which a type is used in a multiparameter type class but does not occur in an argument type or the return type. Thus it is ambigous.
03:23:49 <jakeehrlich> Does anyone know a clean way around this?
03:24:04 <dramforever> functional dependencies might solve your problem
03:24:27 <jakeehrlich> The dependencies of the type classes are set in a particular way and shouldn’t be changed
03:24:58 <Cale> jakeehrlich: Then you're out of luck, I suppose.
03:24:58 <dramforever> not really, it makes some type variables uniquely determine other type variables
03:25:21 <dramforever> Cale: I don't know if we understood the question 
03:25:39 <Cale> Functional dependencies sound like exactly the solution to that problem
03:25:40 <jakeehrlich> no no, I set them that way for good reasons after discovering the way they should be.
03:25:55 <dramforever> jakeehrlich: what do you mean?
03:26:12 <dramforever> functional dependencies are for type variables of the class, not between classes
03:26:32 <jakeehrlich> Say there are two types in the typeclass. There are two ways to set the dependencies. Setting them one cuases an issue, and setting them the way I have them now cuases this issue
03:27:02 <dramforever> I didn't understand that, how about an example:
03:27:13 <Cale> jakeehrlich: Maybe you should tell us what the type class is, and what your program actually is meant to do
03:27:18 <dramforever> yeah
03:27:29 <dramforever> I don't really understand the "setting" part
03:27:45 <Cale> Often when you run into trouble like this, the correct solution is just to stop using type classes altogether
03:27:47 <jakeehrlich> eh… “defined” is perhaps a better word
03:28:03 <Cale> Instead, use a record type whose fields consist of the methods of your class
03:28:06 <rasen> Hi! Can I ask a small stupid question about ICFP?
03:28:13 <Cale> and pass/construct values of that type explicitly
03:28:27 <dramforever> jakeehrlich: can you post your code?
03:28:37 <jakeehrlich> @Cale: yea what I basically want to do is ‘pass’ the typeclass that I want along
03:28:37 <lambdabot> Unknown command, try @list
03:28:59 <dramforever> jakeehrlich: how about this example:
03:29:12 <jakeehrlich> @dramforever: class (Hilbert schema var, Show concrete, Eq concrete) => Matchable concrete schema var | concrete -> schema
03:29:12 <lambdabot> Unknown command, try @list
03:29:13 <Cale> jakeehrlich: Yeah, just use good ol' functional programming without type classes in that case
03:29:22 <jakeehrlich> class (UniformlyEquaitable var, Show (var schema), Eq schema, Show schema) => Hilbert schema var | schema -> var
03:29:34 <dramforever> jakeehrlich: oh you are already using fundeps
03:29:43 <jakeehrlich> yes, and they must be set the way that I have them
03:29:58 <jakeehrlich> well, at least the way I have them or be removed all togethor
03:30:13 <dramforever> jakeehrlich: can you post full code? http://lpaste.net/new/haskell
03:31:02 <jakeehrlich> eh…there is a lot of it spread over multiple files. I’ll post the bits that are concerned here with a discription. Sound good?
03:31:11 <rasen> When selecting workshops there are seperate choices for AM/PM. Is that ok to select the same workshop for both AM and PM? I mean isn't that a repeat of the same talks?
03:31:16 <dramforever> jakeehrlich: okay
03:35:29 <BartAdv> any clues for 'can't find source for XXX in .' error?
03:35:37 <BartAdv> the source code *is* there
03:35:43 <BartAdv> so there is no need for hs-source-dirs
03:39:34 <beta_cuckhold> Python has much better support that C
03:40:17 <Fuuzetsu> rasen: just ask
03:41:35 <lpaste_> jakeehrlich pasted “Ambiguity error” at http://lpaste.net/136782
03:41:55 <jakeehrlich> dramforever: there you go
03:42:03 <dramforever> /me is reading that
03:42:26 <jakeehrlich> \me how does /me work?
03:42:33 * jakeehrlich how does /me work
03:42:37 <Cale> jakeehrlich: The places where you wrote "--stuff here" were actually the part I was interested in seeing
03:43:17 <dramforever> jakeehrlich: your irc clients sends /me ...
03:43:33 <dramforever> and transforms those messages into what you see when displaying
03:44:11 <Cale> actually, I think it sends ACTION instead of PRIVMSG, doesn't it?
03:44:46 <jakeehrlich> Cale: really? they don’t really matter (I think). I would have to post more types that you might not know about. Want me to edit it?
03:44:51 <beta_cuckhold> Is it true that Python is the top language of hackers?
03:45:02 <Cale> maybe I'm wrong about that
03:45:06 --- mode: ChanServ set +o Cale
03:45:10 <dramforever> jakeehrlich: do you have schema -> concrete or var -> concrete or something?
03:45:10 --- mode: Cale set +b *!*@gateway/web/freenode/ip.184.6.47.36
03:45:10 --- kick: beta_cuckhold was kicked by Cale (beta_cuckhold)
03:45:14 --- mode: Cale set -o Cale
03:45:40 <Cale> jakeehrlich: Well, it affects how the class gets used
03:46:24 <jakeehrlich> dramforever: what do you mean? As the type of one of those functions?
03:46:25 <Cale> jakeehrlich: Generally I'm happiest if there's enough source code that I can actually compile something
03:46:39 <dramforever> jakeehrlich: no I mean functional dependencies
03:46:42 <Cale> But if you want to just put the methods in, I can probably suggest something...
03:46:55 <jakeehrlich> Cale: Can do
03:47:15 <jakeehrlich> dramforever: I currently have concrete -> schema
03:47:55 <dramforever> so can a var or a schema uniquely determine a concrete?
03:48:00 <jakeehrlich> I had schema -> concrete before simply becuase it resolved the most conflicts. It turned out we wanted cases where a schema was a schema for multiple things however
03:48:14 <jakeehrlich> dramforever: no, just look at the deps I provided
03:48:15 <Cale> Ah, right, /me translates to CTCP ACTION
03:49:21 <lpaste_> jakeehrlich revised “Ambiguity error”: “No title” at http://lpaste.net/136782
03:51:20 <jakeehrlich> Cale: any thoughts?
03:52:28 <dramforever> anyway, if you can't sort out the fundeps you could always let your function take this as an argument:
03:52:36 <dramforever> :k Proxy
03:52:37 <lambdabot> k -> *
03:52:54 <frerich_> I'm working on a game which is similiar to a Patience card game in that many moves consist of moving cards from one group (or 'set') into another, such that eventually all sets satisfy some criteria. The types involved are basically like in http://lpaste.net/136785
03:53:24 <frerich_> I'm very unhappy with how movement of cards is modelled though, all the 'Int' values are annoying and error prone. Can anybody think of a nice way to 'reference' a card in some set other than by using its position?
03:54:19 <jakeehrlich> dramforever: care explaining a bit further?
04:00:54 <lpaste_> Cale annotated “Ambiguity error” with “Ambiguity error (annotation)” at http://lpaste.net/136782#a136786
04:01:13 <Cale> jakeehrlich: Maybe something like that ^^ ?
04:02:21 <jakeehrlich> yea somthing like that might work
04:02:58 <Cale> jakeehrlich: Note that putting a class context where I did there requires either GADTs or ExistentialQuantification to be turned on, and results in the type class dictionaries being packed into the data, so that when you pattern match on the constructor, you get to discharge those constraints
04:03:15 <Cale> (you may or may not need that)
04:03:18 <jakeehrlich> I’m already using GADTs
04:03:36 <jakeehrlich> I’m using them to do just this with Mapping in fact haha
04:05:19 <jakeehrlich> I’m not sure I like “freeVars (hilbert matchable) someSchema” quite as much but it certianlly isn’t a bad way to do this
04:07:42 <jakeehrlich> Cale: I think I’ll sleep on this and give it a try. I like it overall (and looks way better than I was expecting truth be told) It does preety much what I thought I wanted sans the layer of indirection for the hilbert object. Top marks, nice trick
04:09:05 <jakeehrlich> Why the heck do typeclasses even matter if we have this trick? Did we not figure this out until after we had typeclasses?
04:09:40 <jakeehrlich> This is literally just named typeclasses
04:09:44 <nomeata> Get rid of unwanted type classes using just this one weird tricks.
04:09:59 <AshyIsMe> hmm, so does ghc-mod work with stack and ghc 7.10 yet?
04:10:02 <dramforever> jakeehrlich: IIUC it's a bit cubersome
04:10:43 <jakeehrlich> only slightly really…then again I havn’t worked with it so I’m speculating
04:24:11 <jakeehrlich> Anyways, thanks guys! I’ve got to go now.
04:27:58 <dredozubov> is it possible to pull all constructors(and argument types) from GADT T which result in T X with GHC.Generics?
04:31:48 <Cale> @tell jakeehrlich That is pretty much what functional programmers were doing long before type classes were around. Type classes are for the case where you *want* the compiler to sort out based on the type information which implementation to use. As soon as you'd prefer to be specific about that, you should just use a data type.
04:31:49 <lambdabot> Consider it noted.
04:40:48 <arekfu> Hi all. I have recently started learning Haskell and it is my first functional language. I'm trying to understand how to implement dynamic programming solutions in Haskell. For example, is there a way to memoize Haskell function calls? Or does ghc automatically do it?
04:42:43 * hackagebot json-autotype 1.0.7 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.7 (MichalGajda)
04:43:07 <ChristianS> arekfu: most functions are pure, so ghc can memoize them automatically if it thinks it appropriate
04:43:59 <drdo> There are also libraries for that (check hackage)
04:44:06 <maerwald> all functions are pure, unless you do unsafePerformIO or similar tricks
04:44:43 <ChristianS> arekfu: it's generally a good idea -O2 to enable optimizations
04:44:43 <dramforever> arekfu: you can also use an array
04:45:40 <drdo> maerwald: Of course you will have to do some dirty tricks :)
04:45:57 <dramforever> arekfu: you can do dynamic programming with arrays like this
04:45:58 <maerwald> drdo: I have never used them
04:46:03 * dramforever is coming up with an example
04:48:09 <dramforever> @let f ar 0 = 1; f ar 1 = 1; f ar n = (ar ! (n - 1)) + (ar ! (n - 2))
04:48:10 <lambdabot>  Defined.
04:48:21 <fishburne> My thoughts after 1+ months of learning Haskell  -  "Any sufficiently advanced type system is indistinguishable from magic" - and I have only just entered Type Families....Damn!
04:49:00 <dramforever> > let ar = array (0, 200) (map (\n -> f ar n) (range (0, 200)))
04:49:02 <lambdabot>  <no location info>:
04:49:02 <lambdabot>      not an expression: ‘let ar = array (0, 200) (map (\n -> f ar n) (range (...
04:49:05 <dramforever> =(
04:49:16 <dramforever> > let ar = array (0, 200) (map (\n -> f ar n) (range (0, 200))) in ar ! 200
04:49:17 <lambdabot>      Ambiguous occurrence ‘f’
04:49:17 <lambdabot>      It could refer to either ‘L.f’, defined at L.hs:170:1
04:49:17 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
04:49:23 <dramforever> =(
04:49:35 <dramforever> arekfu: are you there?
04:49:53 <maerwald> > let ar = array (0, 200) (map (\n -> L.f ar n) (range (0, 200))) in ar ! 200
04:49:54 <lambdabot>      Occurs check: cannot construct the infinite type: e1 ~ (i, e1)
04:49:54 <lambdabot>      Expected type: Array i (i, e1)
04:49:54 <lambdabot>        Actual type: Array i e1
04:50:00 * dramforever is in http://xkcd.com/386 mode
04:58:25 <nkaretnikov> ChristianS: any reference on automatic memoization?
04:59:08 <ChristianS> nkaretnikov: no, but i think that ghc is pretty smart
04:59:14 <dramforever> I don't think so
05:00:24 <arekfu> dramforever: sorry, I'm back
05:00:31 <dramforever> never mind
05:00:35 <frerich> arekfu: There is no 'automatic memoization' at all. If you do 'f (g x) (g x)', there is nothing which requires the compiler to evaluate 'g x' just once. If you want memoization, you have to assign names to things yourself (e.g. 'let y = g x in f y y').
05:01:09 <dramforever> arekfu: lazy evaluation makes dynamic programming nicer
05:01:47 <arekfu> dramforever: I saw some similar solutions on the web
05:01:54 <dramforever> basically you make an array, where each element a is assigned to (f a)
05:01:55 <nkaretnikov> ChristianS: could it be that you meant inline not memoize?
05:02:14 <dramforever> inside f, instead of recursively calling f, index the array instead
05:02:21 <flux> frerich, there is, though, this: https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination - but as it says, CSE is not a trouble-free optimization
05:02:44 * hackagebot rake 0.0.1 - Rapid Automatic Keyword Extraction (RAKE)  http://hackage.haskell.org/package/rake-0.0.1 (TobiasSchoofs)
05:02:55 <arekfu> dramforever: but can I define the array as a top-level variable and use it in several functions? will that work? or should I pass the array along as a parameter to all the functions that should need it?
05:03:12 <dramforever> top level is fine
05:03:15 <frerich> flux: Right, that page says 'GHC doesn't actually perform CSE as often as you might expect' and 'If you care about CSE, do it by hand.' -- and I agree with that. :-)
05:03:47 <dramforever> arekfu: oh wait there's a problem
05:04:02 <dramforever> if you have a top level array then you can't make it depend on input
05:04:10 <ChristianS> frerich: "If you do 'f (g x) (g x)', there is nothing which requires the compiler to evaluate 'g x' just once." right, but there is also nothing that requires the compiler to evaluate it twice.
05:04:46 <dramforever> hmm....
05:04:52 <arekfu> dramforever: right!
05:05:31 <frerich> ChristianS: With that in mind, it seems to be a good idea to not assume any automatic elimination of common subepressions at all and rather just do it by hand, no?
05:05:36 <arekfu> dramforever: so perhaps I have to define the array as a partially applied function? but then I need to pass it along everywhere
05:06:06 <dramforever> no the function can be top level
05:06:23 * dramforever is writing up an example
05:12:23 <broma0> Why do finger trees have multiple elements at each leaf node? Why not just one??
05:12:57 <dramforever> broma0: IIUC it's *much* more complicated than that
05:13:03 <arekfu> I actually have a follow-up question: suppose I have devised some technique to apply memoization. How do I check that it is actually working, i.e. that I am not calling my function with the same parameters more than once?
05:13:28 <dramforever> arekfu: write out the code and read it
05:13:53 <dramforever> at least the code I'm writing here convinces me that it's not calling the function with the same params more than once
05:14:33 <Cale> If you wanted to be extra sure, you could use Debug.Trace.trace
05:15:03 <Cale> Sometimes it's nice to add a guard which will always fail, but uses trace to show the arguments
05:15:28 <dramforever> btw *never* use that do write actual output
05:15:32 <dramforever> *to
05:15:45 <arekfu> Cale: that makes sense, thanks
05:15:47 <Cale> like   foo x y | trace (unwords ["foo", show x, show y]) False = undefined
05:16:00 <Cale> (added at the beginning)
05:16:34 <Cale> broma0: They have multiple elements at the branch nodes, and sometimes single elements at the leaves, don't they?
05:17:31 <dramforever> Cale: isn't it Node a at the first level, Node (Node a) at the second, etc. ?
05:17:47 <broma0> dramforever, how so? I imagine this as a sufficient definition 'Ft a = Empty | Single a | Deep a (Ft a) a'
05:18:04 <dramforever> no it's actually something weirder
05:18:32 <dramforever> IIRC the original is Ft a = Empty | Single a | Deep (Digit a) (Ft (Digit a)) (Digit a)
05:18:50 <kuribas> I read that the FRPNow uses unsafePerformIO to make it work...
05:19:10 <broma0> dramforever, why the digit stuff? Why not just 'a'??
05:19:25 <broma0> I've seen that as the standard definition
05:19:35 <dramforever> broma0: otherwise how do you implement those fast operations?
05:19:39 <dramforever> *fast*
05:19:57 <dramforever> oh hmm...
05:19:59 <nesqi> How should I think about using (*>) or (>>) when constucting parsec parsers. They are equivalent right? To me it seems strange to mix (>>) with (<*) in the same expressin and therefore I'm thinking that only using (*>) and (<*) is the "correct" think to do. Am I right?
05:20:00 <broma0> Well O(1) push/pop is essy
05:20:06 <broma0> At both ends
05:20:19 <kuribas> I didn't know unsafePerformIO was used in production code.
05:20:22 <dramforever> broma0: are you sure?
05:20:52 <Cale> broma0: I think it has to do with complexity of rebalancing on insertion
05:20:57 <dramforever> nesqi: I'm not really sure how idiomatic is this, but I almost never use (>>)
05:21:12 <dramforever> broma0: try to write that thing
05:21:37 <nesqi> dramforever: in general or when writing parsec code?
05:21:43 <dramforever> in general
05:22:14 <Wizek__> Good Morning!
05:22:57 <Wizek__> is there a (template) haskell syntax that looks like this? `(fn |something something|)`
05:23:16 <Cale> broma0: The paper unfortunately doesn't seem to give the proofs of the complexity analysis, but I think it would become clearer why the "2 or 3" choice is clever if it did.
05:23:34 <Cale> broma0: You might look up corresponding proofs for ordinary 2-3 trees
05:24:02 <dramforever> Wizek__: no, but there's one line [foo| something something |]
05:24:04 <Cale> (which ought to be easier to find, since it's a reasonably popular data structure)
05:24:08 <dramforever> s/line/like
05:24:35 <broma0> I think I see why
05:24:35 <dramforever> Cale: I'm afraid that those finger trees are very different
05:24:56 <Cale> dramforever: They're different, but the choices are made for similar reasons
05:25:08 <dramforever> maybe
05:25:11 <broma0> Without the digits, push pop needs a full rebalance
05:25:29 <dramforever> isn't 2-3 tree a special case of B-tree?
05:25:40 <broma0> Sound right?
05:26:09 <Cale> dramforever: yeah
05:26:38 <dramforever> so the reason is that "it's better than a linked list"
05:27:03 <Cale> Uhh
05:27:43 <Cale> Well, there are other ways of balancing binary trees
05:27:53 <Cale> Other than the 2-3 tree strategy
05:28:06 <Cale> But finger trees are distorted 2-3 trees
05:28:16 <nkaretnikov> arekfu: you can just run it and see for yourself
05:28:20 <nkaretnikov> whether it's faster or not
05:28:31 <Cale> (They're like 2-3 trees where you pull up both ends, making them easier to access)
05:28:32 <nkaretnikov> arekfu: with fib or something
05:28:34 <dramforever> nkaretnikov: he/she wants to know for sure
05:28:43 <nkaretnikov> well, with fib you'll know
05:28:44 <nkaretnikov> for sure
05:28:48 <dramforever> how?
05:29:01 <nkaretnikov> because unmemoized version will be slow
05:29:04 <dramforever> maybe it's calling the function twice per number?
05:29:16 <dramforever> isn't very much slower isn't it
05:29:20 <dramforever> *is it
05:29:26 <Cale> dramforever: It's exponentially slower
05:29:44 <dramforever> wait no it isn't
05:29:55 <Cale> If we're talking about
05:29:57 <Cale> fib 0 = 0
05:29:59 <Cale> fib 1 = 1
05:30:06 <Cale> fib n = fib (n-1) + fib (n-2)
05:31:45 <nkaretnikov> dramforever: that also depends on how you do memoization 
05:31:50 <dramforever> yes
05:31:55 <Cale> This fib n does O(phi^n) applications of fib
05:32:19 <dramforever> arekfu said "How do I check that it is actually working, i.e. that I am not calling my function with the same parameters more than once?"
05:32:45 <Cale> So if you do fib 800 or something, it will be immediately obvious if it's memoised or not
05:33:06 <dramforever> that makes sense
05:33:44 <ocharles_> Does atzeus tend to hang out here?
05:36:34 <lpaste_> arekfu pasted “memoized and unmemoized Fibonacci” at http://lpaste.net/136793
05:36:40 <arekfu> OK I got this: http://lpaste.net/136793
05:36:49 <arekfu> oops
05:37:01 <arekfu> the difference is huge
05:37:07 <dramforever> arekfu: listArray is nicer =)
05:37:11 <arekfu> I can't use the unmemoized version past 50 or so
05:37:33 <dramforever> arekfu: yes DP v.s. naive is a usually a huge difference
05:37:45 <dramforever> well, I mean memoized and non-memoized
05:38:02 <arekfu> dramforever: OK I realize now that my stumbling block was that I thought arrays were lazy in the indices
05:38:32 <dramforever> :t mapM
05:38:33 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:38:35 <dramforever> :t traverse
05:38:36 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:38:38 <arekfu> dramforever: and I thought "if you need to force all the list to get to #500, that's not the best you can do"
05:39:36 <arekfu> dramforever: but I just read on Hackage that arrays are strict in the indices, which makes sense
05:40:23 <arekfu> but this raises another question: can I use Maps to memoize more complex arguments, for instance?
05:40:40 <dramforever> arekfu: I think so
05:40:49 <dramforever> IIRC Map is strict in the keys
05:41:33 <arekfu> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-Map-Lazy.html says you are right
05:41:37 <kuribas> arekfu: you could even use an infinite tree to memoize all integers.
05:42:16 <arekfu> kuribas: how? if the map is strict in the keys...?
05:42:33 <dramforever> arekfu: oh it's something else
05:45:04 <kuribas> arekfu: For example "data Tree a = Tree a a (Tree a) (Tree a)".
05:45:11 <frerich> arekfu: You can also get memoization by defining a list 'fibs' in terms of itself, such that previously computed values are reused. As in 'fib n = fibs !! n where fibs = 1 : 1 : zipWith (+) fibs (tail fibs)'
05:45:24 <danilo2> Hello! Could somebody tell me if it is possible (and how) to enable ghc output in terminal when using `cabal install`. Right now when I'm using `cabal install` ghc does not print output even when using gcc-flags of -ddump-splices when I'm compiling a library. It does hoverer when compiling executable. Does anybody know how can I enable this output?
05:45:27 <dramforever> oh sure that saves space
05:45:38 <kuribas> arekfu: at depth 0, you get 0 and 1, depth 1: 3, 4, 5 and 6, etc...
05:45:44 <dramforever> danilo2: IIUC -j1
05:46:01 <kuribas> arekfu: So you can memoize a function over N.
05:46:46 <arekfu> frerich: OK so this is the typical example where I'm not sure of what is going on behind the scenes
05:47:20 <arekfu> frerich: my naive understanding would be that fibs is reconstructed from scratch every time I call fib
05:47:41 <danilo2> dram forever: I know about it, but even with -j1 I get no ghc output :(
05:47:52 <arekfu> frerich: but obviously this is not true...? so fibs is "cached" between calls to fib?
05:48:15 <dramforever> no, all the fibs are one
05:48:20 <frerich> arekfu: I think that are the semantics, right - simply replacing all uses of 'fibs'. However, what happens is that since you use the exact same term 'fibs' all the time, you actually *reuse* the existing list. And 'tail fibs' gets you a pointer to the second element of the existing list.
05:49:19 <frerich> A while ago somebody here actually did a really pretty hand-drawing of what's going on and then photographed it (arkeet?). I wish I could find that again.
05:50:43 <frerich> arekfu: There is just one list around all the time for the same reason why there is just one list in 'ones = 1 : ones'. The 'ones' usage at the right side of the '=' actually points to the exact same list. Not 'another list'.
05:51:21 <Gurkenglas_> Tell me I'm wrong: for types r with at least two distinguishable values, Cont r a is isomorphic to a.
05:51:36 <danilo2> dramforever: H! It works! Oh stupid me! If you pass -j1 you get no output unless you change the source files :D
05:51:47 <dramforever> oh huh
05:51:48 <arekfu> frerich: OK I'm getting a bit confused but I think there are two separate issues. One is how to efficiently build a list of Fibonacci numbers: and that is elegantly solved by the fibs method. The other thing is using a list, an array, a map... for memoization
05:51:49 <dramforever> =)
05:52:14 <dramforever> arekfu: yeah
05:52:20 <frerich> arekfu: The thing is - a list can be used for memoization if you make sure that you use the exact same list.
05:52:28 <danilo2> dram forever: Thank you! :)
05:52:37 <dramforever> that's one of the problems of #haskell: we get easily carried away by questions
05:52:59 <Denommus> Hi
05:53:01 <dramforever> danilo2: =) yw
05:53:18 <arekfu> frerich: right, but I feel unsure about when it is the SAME list. However, using a list instead of an array means that !! is O(n), right?
05:53:45 <bitonic> Do `INLINE` in class methods definitions have any effects?
05:53:46 <dramforever> except that we are not using !!
05:54:00 <bitonic> I'm asking because it's a bit puzzling that you can both `INLINE` definitions and instances
05:54:13 <nkaretnikov> arekfu: where did you get the (secs, bytes) tuple?  is it something that's available in ghci, or did you paste it from the profiler report?
05:54:21 <Gurkenglas_> frerich, did they post in on the channel? Do you remember any of the words people said nearby that? We could look through the logs. Maybe where he posted it?
05:54:31 <Gurkenglas_> -in+it
05:54:46 <frerich> arekfu: It is definitely the same list if it has the same name. You might also find https://wiki.haskell.org/Tying_the_Knot interesting in this context.
05:54:47 <arekfu> nkaretnikov: :set +s in ghci I think
05:55:17 <frerich> Gurkenglas_: It was posted on the channel, yes - and I remember asking something along the lines of 'Did you just draw that by hand' and later referring to it as 'pretty image'. :-)
05:55:19 <nkaretnikov> arekfu: wow, nice!  til
05:55:43 <frerich> Gurkenglas_: People discussed this exact issue IIRC and somebody made a drawing with a pen involving boxes and arrows, and that made it really clear to me *why* it worked the way it does.
05:56:05 <frerich> He drew it, photographed it and posted the link here. I'm afraid that even if we can find the link, it may be a 404 by now.
05:57:00 <Gurkenglas_> "<frerich> 	arkeet: You didn't just draw and photograph that yourself, did you?"
05:57:15 <Gurkenglas_> http://ircbrowse.net/browse/haskell?id=20882312&timestamp=1434571247#t1434571247
05:57:34 <frerich> Hah, you found it!
05:57:36 <frerich> http://puu.sh/isDAc/a70bc263c5.jpg is it
05:57:45 <frerich> Ok, it's not fibonacci but still - same thing.
05:57:46 <Gurkenglas_> Noo he said to read the other thing first you foooool
05:58:03 <frerich> Gurkenglas_: 'The other thing' is about the notation used in http://puu.sh/isDAc/a70bc263c5.jpg ;-)
05:58:37 <frerich> IIRC the discussion was about how many multiplications are performed to get the first 100 powers of 2 I think.
05:59:00 <frerich> I.e. whether it's linear or quadratic. I initially argued for the latter but later realized I was wrong because of what arkeet painted.
05:59:29 <arekfu> frerich: so this is meant to illustrate map (*2) ones, right?
06:00:18 <frerich> arekfu: No, it's more like 'powersOf2 = 1 : map (*2) powersOf2'
06:00:25 <Gurkenglas_> It illustrates fix (\xs -> 1 : map (*2) xs)
06:00:28 <frerich> I.e. each value is twice its predecessor.
06:00:50 <Gurkenglas_> (That image is indeed pretty neat)
06:01:03 <frerich> And in particular, it illustrates why there is memoization in place, i.e. why taking the first 100 elements actually only needs 99 multiplications instead of 1 + 2 + 3 + ... + 98
06:01:36 <arekfu> frerich: of course, I'm stupid
06:02:44 <Gurkenglas_> (Of course what happens in the image requires someone to force that part of the spine)
06:04:25 <frerich> arekfu: Don't worry. Not too long ago, I apparently wrote http://ircbrowse.net/browse/haskell?id=20881945&timestamp=1434567682#t1434567682 which was stupid, too :-)
06:06:41 <arekfu> OK guys, thank you all. I am one step further on my journey to FP enlightenment
06:06:43 <arekfu> ;)
06:08:14 <wei2912> just a note, you can write powersOfTwo this way:
06:08:16 <wei2912> > iterate (* 2) 1
06:08:17 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:09:58 <dramforever> @src iterate
06:09:59 <lambdabot> iterate f x = x : iterate f (f x)
06:11:17 <quux> hi
06:11:41 <pacak> o/
06:11:44 <quux> does anyone have fgl code to work with chordal graphs? (e.g. check chordal, produce an elimination ordering)
06:27:48 * hackagebot extra 1.3.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.3.1 (NeilMitchell)
06:33:53 <Gurkenglas_> Is NeilMitchell here?
06:36:39 <Saizan> used to be ndm but he's not been here much
06:38:02 <kuribas> arekfu: http://lpaste.net/136798
06:38:06 <jTT_> :t liftIO
06:38:07 <lambdabot> MonadIO m => IO a -> m a
06:38:26 <kuribas> arekfu: you can memoize any function over (positive) integers.
06:39:25 <jTT_> if i have a function:  fxn :: b-> IO a, and another fxn2 :: b -> c, how can i apply fxn2 to fxn in ghci?
06:41:30 <kuribas> jTT_: you mean compose?
06:41:44 <lyxia> jTT_: What would the result though?
06:41:51 <lyxia> *do though
06:42:31 <jTT_> kuribas: i mean in ghci i wanna test fxn2, so i do >let tmp = fxn a:  and then i get a type mismatch if trying fxn2 $ tmp
06:43:16 <mauke> jTT_: what are the actual types?
06:43:46 <kuribas> jTT_: fxn a has type IO a, so you cannot pass it through fxn2, since it takes an argument of type "b"
06:43:59 <jTT_> fxn :: Text -> IO Cursor; fxn2 :: Cursor -> [Text]
06:44:24 <mauke> oh hello
06:44:38 <kuribas> jTT_: liftM fxn2 (fxn "tekst")
06:44:41 <mauke> you said fxn2 was b -> c and it's actually c -> [b]
06:45:04 <jTT_> true
06:45:08 <jTT_> sry
06:45:09 <kuribas> :t liftM
06:45:10 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:45:19 <jTT_> ah cool, thanks
06:45:22 <kuribas> :t <$>
06:45:25 <lambdabot> parse error on input ‘<$>’
06:45:28 <kuribas> :t (<$>)
06:45:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:58:55 <orion> bitemyapp: Your tests on bloodhound don't build.
07:02:49 * hackagebot conf 0.1.1.0 - Parser for Haskell-based configuration files.  http://hackage.haskell.org/package/conf-0.1.1.0 (carymrobbins)
07:21:47 <orion> Is there a way for me to prevent cabal from using any system packages when working in a sandbox?
07:24:46 <geekosaur> no
07:25:00 <geekosaur> very specifically no, as base can only come from global and is mandatory
07:25:12 <orion> Ok. :(
07:27:07 <geekosaur> (if something is telling you that you need a different version of base, what it really means is you need a different version of ghc)
07:27:35 <orion> I just had an issue where my system package manager installed QuickCheck as part of GHC, but it was 2.6, and a project I was working on needed a more recent version.
07:27:57 <orion> Really, the project needs to set a minimum version number in the cabal file.
07:28:06 <Denommus> can persistent work on already existing types, instead of having to quasi-quote them?
07:28:48 <geekosaur> orion: try --constraint='QuickCheck > 2.6'
07:29:16 <orion> geekosaur: ok
07:29:54 <geekosaur> (better yet, try setting it == the version you need)
07:30:18 <geekosaur> I think you can add that to cabal.sandbox.config (as constraint: ...)
07:33:15 <nkaretnikov> Denommus: not sure what you mean by quasiquote in this context, but you need to define (two) instances, so your types could be serialized to the db
07:34:12 <nkaretnikov> Denommus: you can use whatever you like as long as you can write and read it
07:34:50 <chamo> hi all
07:35:08 <tdammers> yeah, the quasi-quotation thing is just a convenience feature that allows you to define the persistence types and instances in one go
07:35:17 <nkaretnikov> Denommus: there are functions that help with deriving, but in some cases it's better to write instances by hand
07:35:49 <Denommus> the thing is that I have the types in question in a "common" library to be shared between the frontend and backend
07:36:19 <nkaretnikov> so, what's the problem exactly?
07:36:35 <nkaretnikov> just write the needed instances
07:36:53 <nkaretnikov> or do they poorly map to the db layer?
07:37:06 <Denommus> they'll have to be orphaned, sadly
07:37:18 <nkaretnikov> ah
07:37:22 <nkaretnikov> you could write a newtype
07:37:27 <nkaretnikov> and instantiate that
07:37:42 <Denommus> won't that be a problem?
07:37:51 * hackagebot instant-aeson 0.1.0.1 - Generic Aeson instances through instant-generics  http://hackage.haskell.org/package/instant-aeson-0.1.0.1 (RenzoCarbonara)
07:38:08 <nkaretnikov> that's a common workaround for dealing with such situations
07:38:32 <nkaretnikov> this way your instances will be next to the type
07:38:50 <Denommus> ok, thanks
07:38:55 <nkaretnikov> np
07:42:51 * hackagebot instant-bytes 0.1.0.1 - Generic Serial instances through instant-generics  http://hackage.haskell.org/package/instant-bytes-0.1.0.1 (RenzoCarbonara)
07:47:40 <Denommus> nkaretnikov: it would be a lot nicer if the macros generated a new instance from an existing type, instead of having to define the type inside of the macro, though
07:47:51 <jackhill> How would I generalize this so I can pass in the length of the sample I want: sample5 cs = [a:b:c:d:e:[] | a <- cs, b <- cs, c <- cs, d <- cs, e <- cs ]
07:49:20 <S11001001> jackhill: sequence, then join
07:49:27 <jackhill> :t sequence
07:49:28 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:49:32 <S11001001> jackhill: that is, repeat, sequence, join
07:49:49 <S11001001> @let cs = [1,2,3]
07:49:50 <lambdabot>  Defined.
07:50:08 <S11001001> @ty repeat
07:50:09 <lambdabot> a -> [a]
07:50:30 <S11001001> > join . sequence . repeat $ cs
07:50:31 <lambdabot>  *Exception: stack overflow
07:50:41 <S11001001> oh right, the take
07:50:53 <S11001001> > join . sequence . take 4 . repeat $ cs
07:50:55 <lambdabot>  [1,1,1,1,1,1,1,2,1,1,1,3,1,1,2,1,1,1,2,2,1,1,2,3,1,1,3,1,1,1,3,2,1,1,3,3,1,2...
07:51:15 <S11001001> jackhill: that's for 4.  And so forth
07:51:41 <jackhill> S11001001: cool, thanks!
07:52:42 <S11001001> jackhill: if you wanted the sublists, leave out the join
07:52:51 * hackagebot lambdacms-core 0.2.0.0 - LambdaCms Core subsite for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.2.0.0 (cies)
07:52:53 * hackagebot instant-hashable 0.1.0.1 - Generic Hashable instances through instant-generics  http://hackage.haskell.org/package/instant-hashable-0.1.0.1 (RenzoCarbonara)
07:52:55 * hackagebot instant-deepseq 0.1.0.1 - Generic NFData instances through instant-generics  http://hackage.haskell.org/package/instant-deepseq-0.1.0.1 (RenzoCarbonara)
07:54:16 <aweinstock> @src sequence
07:54:16 <lambdabot> sequence []     = return []
07:54:16 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:54:16 <lambdabot> --OR
07:54:16 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:57:48 <Denommus> screw it, I'm using acid-state
07:57:51 * hackagebot pusher-haskell 0.1.0.0 - A Pusher.com client written in Haskell  http://hackage.haskell.org/package/pusher-haskell-0.1.0.0 (sidraval)
07:57:53 * hackagebot lambdacms-media 0.3.0 - LambdaCms "media" extension  http://hackage.haskell.org/package/lambdacms-media-0.3.0 (cies)
07:58:45 <Gal3rielol> I can find a readable AlgorithmW tutorial here https://github.com/wh5a/Algorithm-W-Step-By-Step, I'm curious is there any tutorial about constraint-based type checker?
07:59:10 <Gal3rielol> with sample code.
08:05:25 <quchen> Hm. The more I write on my literate version of this very subject, the more already existing ones I stumble upon. :-|
08:12:33 <orion> Denommus: What are you trying to do?
08:12:52 * hackagebot wordpass 1.0.0.4 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.4 (MichalGajda)
08:15:06 <mniip> jle`, I still can't get over how nice these looped type family constraints are
08:20:06 <danilo2> Hi! I just started using GHC 7.10 and I've observed a strange thing. In 7.8 I could create a data Foo = A | B and a type family : type family Fam a :: Foo (using -XDataKinds). Now I'm getting error: ‘Foo’ of kind ‘*’ is not promotable. What does it mean ?
08:22:10 <mniip> danilo2, full source and error message?
08:22:17 <mniip> (can't reproduce)
08:22:33 <danilo2> mniip: ok, brb
08:24:23 <danilo2> mniip: here it is: http://lpaste.net/136803
08:25:41 <mniip> danilo2, Int is not promotable
08:25:43 <danilo2> mniip: Ugh, strange, this code doest work in 7.8 either. Do you have any idea why?
08:25:53 <danilo2> mniip: Ah Right!
08:26:02 <danilo2> mniip: thank you!: )
08:29:35 <bennofs> :t '3
08:29:36 <lambdabot> parse error on input ‘3’
08:30:00 <bennofs> is Integer promoted to Nat though?
08:30:15 <bennofs> or GHC's new Natural?
08:31:21 <Aruro> anyone tried compiling haskell-emacs? does not work for me even in sandbox.
08:32:19 <danilo2> mniip: Would you be so nice and look again on this snippet? I've just hit another error and maybe you know why its happening here? http://lpaste.net/136803 . I was sure we can do something like that, can't we?
08:34:29 <bennofs> danilo2: FracBase -> FracBaseOf
08:34:33 <bennofs> in line 9
08:34:47 <danilo2> bennofs: Oh, I've got to be tired .. heh, thanks :)
08:39:27 <muzzle> hi, I'm currently looking at some older c bindings from a library. When I try to build the library I get the following error: c2hs: Feature not yet implemented:
08:39:28 <muzzle>   GenBind.evalCCast: Casts are implemented only for integral constants
08:39:47 <muzzle> has anyone got an idea what is the cause for this ?
08:42:30 <muzzle> The code is specifically this: https://github.com/hesselink/kqueue/blob/master/src/System/KQueue.chs
08:43:17 <lifter> If I have "MyType <$> field <*> field <*> field", how can I rewrite it such that the value corresponding to the first "field" is actually ignored/dropped?
08:43:42 <bennofs> lifter: MyType <$ field <*> field <*> field I think
08:44:10 <lifter> bennofs, ah let me try that. Last night I was fooling around with (<*)
08:44:33 <bennofs> > (,) <$ pure 3 <*> pure 4 <*> Just 5
08:44:34 <lambdabot>  Just (4,5)
08:44:52 <bennofs> > (,) <$ pure 3 <*> pure 4 <*> Just 3 <* Just 5 <* Just 6
08:44:54 <lambdabot>  Just (4,3)
08:45:04 <bennofs> > (,) <$ pure 3 <*> Just undefined <* pure 4 <*> Just 3 <* Just 5 <* Just 6
08:45:05 <lambdabot>  Just (*Exception: Prelude.undefined
08:45:18 <lifter> awesome!
08:45:27 <bennofs> > (,) <$ pure 3 <* Just undefined <*> pure 4 <*> Just 3 <* Just 5 <* Just 6
08:45:29 <lambdabot>  Just (4,3)
08:45:32 <zmbmartin> What can I use to run a command every so often. Like every 30 seconds?
08:45:49 <lifter> zmbmartin, concurrency
08:45:52 <bennofs> zmbmartin: command? as in, shell command like kill?
08:48:03 <geekosaur> https://en.wikipedia.org/wiki/Watch_(Unix) ?
08:48:24 <geekosaur> in haskell, you'll need a bit more work to do it (and it depends on the command)
08:48:33 <geekosaur> ...and there are probably better ways to do whatever it is
08:48:45 <geekosaur> what exactly are you monitoring?
08:49:28 <zmbmartin> I am using rethinkdb. There is a changes command I call that returns a cursor. When changes are made they are added to the cursor. I need to call next cursor to get the results if there are any. So I need to call next cursor every so often to check.
08:50:04 <c_wraith> aren't there rethinkdb bindings that avoid using the command line?
08:50:45 <zmbmartin> c_wraith: I don't want to use command line. I just need to call next cursor every so often.
08:50:49 <zmbmartin> All in haskell.
08:51:09 <c_wraith> zmbmartin: ah.  You confused people by saying "run a command"
08:51:16 <zmbmartin> Oh sorry
08:51:32 <c_wraith> zmbmartin: in any case, look at forkIO and threadDelay from Control.Concurrent
08:51:38 <quchen> geekosaur: I don't think it's hard to do at all. forever (threadDelay N >> runCommand) -- or am I missing something?
08:52:08 <c_wraith> quchen: you can only use a capital letter for N if it's a pattern synonym. :P
08:52:30 <quchen> c_wraith: I'm using figurative speech here.
08:52:44 <quchen> I use CPP to implement said figurative speech in real source code. :-þ
08:52:50 <geekosaur> (a) presumably you are capturing output (b) does that output require a pty? do you need to worry about buffering? (c) time from last trigger, or time from when the last check ended? (and in the former case, what to do if the first one is still running?)
08:53:00 <geekosaur> partial list, there's more where those came from :)
08:56:02 <catgocat> Why does `read "\"hi\""` triggers the error of being an ambiguous call? For example `read $ show "hi"`
08:56:28 <catgocat> Why do I have to add `:: String` to it so it doesn't trigger an error?
08:56:30 <chpatrick> catgocat: because it doesn't know what type you would like to read
08:56:32 <rbocquet> > read "hi" :: Int
08:56:34 <lambdabot>  *Exception: Prelude.read: no parse
08:56:41 <catgocat> Isn't it obvious for the compiler?
08:56:44 <Welkin> read need a type to work with
08:56:45 <catgocat> That it's a string?
08:56:47 <chpatrick> no, why would it be?
08:56:55 <chpatrick> :t read
08:56:56 <lambdabot> Read a => String -> a
08:56:58 <Welkin> :t read
08:56:59 <lambdabot> Read a => String -> a
08:56:59 <chpatrick> it doesn't know what the a is
08:57:02 <quicksilver> it is obvious, in this case, but only because you're looking at the contents of the string
08:57:06 <Welkin> it doesn't know a
08:57:14 <Welkin> and it cannot guess it
08:57:18 <quicksilver> it's not obvious to the compiler because the compiler never looks at the contents
08:57:19 <Welkin> there isn't enough information
08:57:21 <quicksilver> just the type
08:57:31 <catgocat> Ok ok
08:57:35 <mniip> and as a last point
08:57:41 <mniip> what is 'read "1"'
08:57:51 <mniip> there's like 15 types that can read that
08:57:54 <bitemyapp> orion: taking a look
08:57:59 <catgocat> but that's a number
08:58:03 <catgocat> "hi" can only be a string
08:58:10 <catgocat> or am I wrong?
08:58:11 <chpatrick> there are lots of different numbers
08:58:17 <mniip> :t "hi"
08:58:18 <c_wraith> catgocat: read needs to know what type it's decoding to *at compile time*
08:58:18 <lambdabot> [Char]
08:58:18 <quchen> catgocat: Is "1hi" also only a string?
08:58:21 <mniip> aw
08:58:22 <chpatrick> even if the compiler could figure it out somehow
08:58:30 <quchen> catgocat: Is "1h"? Why is "1" not a string but a number?
08:58:32 <c_wraith> catgocat: it's not allowed to look at its argument and thend ecide
08:58:51 <catgocat> Ok got it
08:59:01 <rowanblush> "hi" could also be a Text value, or a RelativeTemperature value, or anything.
08:59:09 <lifter> bennofs, using (<$) worked, thanks!
08:59:22 <Welkin> :t (<$)
08:59:24 <lambdabot> Functor f => a -> f b -> f a
08:59:42 <lifter> applicative ninja magic
09:00:17 <c_wraith> It's really just Functor ninja magic. :)
09:00:27 <c_wraith> :t fmap . const
09:00:28 <lifter> ah
09:00:29 <lambdabot> Functor f => b -> f a -> f b
09:00:32 <lifter> indeed
09:00:49 <Wizek__> Are there some examples on how I could use parsec's commaSep or sepBy functions? I get type errors that I have difficulty understanding when I try to use either one of those.
09:01:18 <quchen> Wizek__: Show us!
09:01:44 <quchen> The documentation gives the example commaSep p  = p `sepBy` (symbol ",")
09:02:14 <quchen> It parses a `p`, and then a ",", and then a `p`, and then …
09:03:03 <Wizek__> quchen, https://gist.github.com/Wizek/c655734a28d857ed461c
09:05:05 <quchen> Wizek__: Have you tried giving the top-level definitions type annotations?
09:05:35 <quchen> The problem seems to be that GHC cannot infer which of the possible Stream instances you want.
09:06:11 <quchen> It's a similar issue to what catgocat had just 5 minutes earlier, but with more complex types.
09:06:27 <quchen> ("Why won't `read . show` work")
09:07:16 <Wizek__> Well, I am trying right now with type holes, but I am afraid I will have to sprinkle a lot of `ParsecT s u m a` in there, and I wouldn't find that very nice or meaningful. brb
09:07:45 <quchen> Wizek__: Text.Parsec.{String,Text,...} define useful synonyms for ParsecT stuff.
09:08:00 <quchen> Parsec use almost always starts with importing one of those modules.
09:08:33 <quchen> When you've done so, you have a "Parser" type synonym at hand, and "ParsecT s u Identity a" becomes "Parser a"
09:10:07 <Wizek__> hmm
09:10:09 <Wizek__> interesting
09:18:32 <Wizek__> hmm, it seems to work better now, thanks quchen 
09:24:02 <muzzle> how can i install a package from source into a sandbox ?
09:24:08 <muzzle> (cabal)
09:25:18 <pmade> muzzle: Grab the source and use `cabal sandbox add-source <path>'
09:25:50 <pmade> Then `cabal install <name>'
09:31:40 <Javran> muzzle: you can use "cabal get <package>" to get the source, version number can also be given optionally
09:32:12 <dirk103> Heyo
09:32:35 <muzzle> is there a way I can use runghc with a sandbox
09:32:36 <muzzle> ?
09:32:39 <dirk103> Im having some trouble understanding this: sumList (x:xs) = x + sumList xs
09:32:48 <muzzle> it's for an example file in a cabal project that i want to run
09:33:41 <dirk103> How come I can just supply that function with a single param that is a list? Eh  sumList [10, 20, 30] and i dont need to give it something like sumList 10:[15,30,45]
09:34:19 <pmade> dirk103: [1, 2, 3] is shorthand for 1:2:3:[]
09:34:33 <ski> dirk103 : `[10,20,30]' is syntactic sugar for `10:[20,30]'
09:34:45 <pmade> dirk103: listen to ski, I misspoke.
09:34:47 <dirk103> ohh ok
09:35:46 <ski> dirk103 : listen to what pmade says
09:36:00 <pmade> :)
09:36:12 <pmade> Never listen to me.
09:36:47 <dirk103> infinite loop detected
09:37:39 <pmade> Well darn, 1:2:3:[] is correct.  I need a break.
09:37:43 <Darwin226> Hey guys. ve read Okasaki's Purely functional data structures and I was wondering what to take up next. I'm not looking for specific papers but more content of the same style. Something more substantial (in terms of size) that I can print out and read when I have time.
09:38:04 <Darwin226> Any suggestions?
09:38:17 <Welkin> Darwin226: https://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki/1550#1550
09:38:30 <ski> (also, did you read the book or the thesis ?)
09:38:47 <Darwin226> Welkin: Awesome!
09:39:02 <Darwin226> ski: Well, I've read the 180 page one. Don't know which that is
09:39:10 <phaazon> hey, I have a weird behavior
09:39:19 <Darwin226> ski: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf this one
09:39:32 <Darwin226> ski: What's different in the book?
09:39:34 <Welkin> Darwin226: there is a printed version that is updated/edited
09:39:44 <Welkin> it has complete exmaples in haskell
09:39:48 <Welkin> examples*
09:39:48 <phaazon> http://lpaste.net/8867164569064177664
09:39:52 <phaazon> with ScopedTypeVariables
09:39:56 <phaazon> still doesn’t compile
09:40:06 <phaazon> says that a and a0 aren’t the same :/
09:40:20 <chpatrick> you need forall a.
09:40:33 <ski> Darwin226 : iiuc, the book is somewhat more expanded
09:40:38 <lpaste_> chpatrick annotated “No title” with “No title (annotation)” at http://lpaste.net/8867164569064177664#a136805
09:40:41 * ski hasn't compared closely
09:40:42 <phaazon> chpatrick: oh yeah
09:40:44 <phaazon> forgot that
09:40:45 <phaazon> thanks
09:40:56 <chpatrick> err that's in the wrong plac
09:40:56 <Darwin226> Welkin: Yeah, that SE answer is great stuff. This will do just fine
09:41:00 <chpatrick> before the context :)
09:41:10 <lpaste_> chpatrick revised “No title (annotation)”: “No title” at http://lpaste.net/136805
09:46:04 <dirk103> why do i have (x:ss) as the argument in my sumList function?
09:48:13 <dirk103> does (x:xs) as the argument somehow split up a supplied list as the first member of it and the rest of the list?
09:48:16 <dirk103> it
09:48:46 <Aruro> dirk103: it does
09:48:50 <dirk103> it's confusing me because i am working with the assumption that : can only add a single member to a list of the same type?
09:48:52 <Aruro> dirk103: called pattern
09:49:01 <dirk103> so : has two functions depending on context?
09:49:38 <Aruro> (:) is data constructor
09:49:49 <Aruro> this permits him to be part of patterns
09:49:55 <S11001001> dirk103: you use a screwdriver to put the screw in.  How do you get the screw out?
09:49:56 <Javran> :t (:)
09:49:57 <lambdabot> a -> [a] -> [a]
09:50:17 <Aruro> @src (:)
09:50:17 <lambdabot> Source not found. You untyped fool!
09:50:25 <Aruro> @src List
09:50:25 <lambdabot> Source not found. Just try something else.
09:50:45 <Javran> consider list to be defined as "data [] a = [] | (:) a ([] a)"
09:51:01 <Javran> both "[]" and "(:)" are data constructors
09:51:09 <Aruro> (:) is just Cons in wordly definition of lists
09:51:36 <Javran> @let cons = (:)
09:51:38 <lambdabot>  Defined.
09:51:45 <Javran> > cons 1 (cons 2 []))
09:51:47 <lambdabot>  <hint>:1:19: parse error on input ‘)’
09:51:54 <Javran> hmm, anyway
09:52:03 <dirk103> ohh okya cool
09:52:21 <ski> dirk103 : ": can only add a single member to a list of the same type" -- yes
09:52:22 <dirk103> i did let (x:xs) = [10, 20,30,40,50] and it did the right thing :)
09:52:22 <Aruro> dirk103: please read basics of patters, you seem lack knowledge in theory
09:52:36 <ski> > let x:xs = [10, 20,30,40,50] in (x,xs)
09:52:37 <lambdabot>  (10,[20,30,40,50])
09:53:03 <dirk103> Aruro I am reading that right now but the author didn't clarify it very well before moving on.
09:53:46 <Aruro> (:) is list constructor on the left is one elemet on the right always the rest of the list
09:53:54 <ski> dirk103 : the brackets are only needed in `sumList (x:xs) = x + sumList xs', because without them `sumList x:xs = x + sumList xs' will be parsed as `(sumList x):xs = x + sumList xs' -- which is not what you want. iow, because of operator (`:') (vs. application) precedence
09:54:01 <dirk103> Aruro: Cool
09:54:21 <ski> dirk103 : for the same reason, you can say `let x:xs = ...' without brackets
09:54:38 <Aruro> dirk103: construction like xs:x , where x is last element of list is not possible
09:54:54 <dirk103> Okay thanks guys this is all clear now. I'm really enjoying learning this language.
09:55:09 <Aruro> dirk103: which book do you read btw?
09:55:26 <rcyr> > ((:) x xs) = [1, 2, 3] in (x, xs)
09:55:28 <lambdabot>  <hint>:1:12: parse error on input ‘=’
09:55:31 <Denommus> orion: I need a simple storage for a web application
09:55:45 <rcyr> > let ((:) x xs) = [1, 2, 3] in (x, xs)
09:55:47 <lambdabot>  (1,[2,3])
09:56:11 <ski> > let (:) x xs = [0,1,2] in (x,xs)
09:56:11 <dirk103> Real World Haskell
09:56:12 <lambdabot>  (0,[1,2])
09:56:17 <Aruro> dirk103: you can read about patters also here https://www.haskell.org/tutorial/patterns.html
09:56:21 <Aruro> very clear text.
09:56:23 <ski> > unwords (words "i'm a little teapot short and" ++ ["stout"])
09:56:24 <lambdabot>  "i'm a little teapot short and stout"
09:56:43 <Jello_Raptor> do people here have reccomendations for sensible record libraries that that work with Control.Lens (https://hackage.haskell.org/package/record is what i'm leaning towards, but it seems to choke on literate haskell)  
09:59:25 <Gurkenglas> I made a thing! Should it or something like it be in Control.Comonad.Cofree.Class, because https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html has it?
09:59:46 <Gurkenglas> @let levels = Data.Foldable.toList . unfold (liftM extract &&& (Identity . (unwrap =<<))) . return
09:59:47 <lambdabot>  .L.hs:168:5:
09:59:47 <lambdabot>      Not in scope: ‘Data.Foldable.toList’
09:59:47 <lambdabot>      Perhaps you meant ‘Data.Foldable.fold’ (imported from Data.Foldable)
09:59:59 <Gurkenglas> (Wait what it just worked in a query.)
10:02:05 <dirk103> everyone uses GHC?
10:03:09 <Gurkenglas> Take two: http://lpaste.net/136807
10:03:14 <Gurkenglas> @letlpaste 136807
10:03:15 <lambdabot>  Defined.
10:04:11 <nkaretnikov> dirk103: not everyone, but the majority I'd say
10:09:56 <dirk103> f s@(x:xs)             = x:s
10:10:00 <dirk103> what's the @ called?
10:10:08 <geekosaur> as-pattern
10:14:00 <dogetime> For now
10:16:28 <Denommus> I don't get how to use safecopy with acid-state
10:18:28 <nadirs> is there a specific place where I could ask questions about stackage?
10:21:43 <Denommus> oh, great
10:21:52 <Denommus> the documentation for acid-state and safecopy in happstack is down
10:22:25 <bergmark> Denommus: there's a message on the happstack mailing list about it
10:24:12 <Denommus> bergmark: so where can I find comprehensive documentation on how to use safecopy and acid-state together?
10:24:19 <Denommus> bergmark: they look awesome, but I'm clueless
10:24:39 <nadirs> Denommus: I know nothing about those packages but does this help? http://acid-state.seize.it/safecopy
10:24:51 <nitrix> Denommus: It's Scarlet, with the Toaster, in the Bathtub.
10:25:04 <Denommus> nadirs: not a lot, no
10:25:17 <Denommus> nitrix: har har
10:26:40 <alpounet> Denommus: have you seen https://github.com/acid-state/acid-state/tree/master/examples ?
10:30:04 <Jello_Raptor> okay yeah :/ i think I just don't know how to set up cabal to use record-preprocessor 
10:30:22 <Jello_Raptor> Trying to use it as a preprocessor has it choke on the recursive module name
10:30:37 <Denommus> alpounet: yes, none of these examples really show safecopy's migration in action :-/
10:31:10 <Denommus> alpounet: I understand how safecopy works and how acid-state works, but not how they work TOGETHER, get it?
10:31:27 <Denommus> or maybe I don't quite understand
10:31:36 <Denommus> well, I guess I'll read the reference manual for both
10:31:45 <Denommus> but not right now, back to real world Java work :-/
10:32:39 <caconym> Denommus: this may not be particularly helpful but I was able to use acid-state at one point without understanding anything about safecopy
10:33:07 <caconym> Denommus: I just set up whatever instances according to examples I found and boom it worked
10:33:16 <Denommus> caconym: as I said, I can use acid-state all by itself, but I really need the data migration part
10:33:32 <caconym> Denommus: ah, sorry
10:34:38 <ttt_fff> suppose, hypothetially, my friend wrote a piece of code in a large haskell codebase with an infinite loop; what would be the easiest way for her to debug it?
10:35:55 <nitrix> ttt_fff: GHCi
10:36:33 <nitrix> ttt_fff: You can set breakpoints, step through/in/out, stop a running computation, inspect values, etc.
10:37:11 <ttt_fff> nitrix: thanks
10:37:36 <cow_2001> how do i use a non-hackaged git package?
10:37:59 * hackagebot satchmo 2.9.9 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.9 (JohannesWaldmann)
10:38:04 <cow_2001> within my cabal configuration
10:38:08 <Welkin> cow_2001: cabal sandbox add-source /path/to/source
10:38:13 <cow_2001> woooo
10:38:17 <cow_2001> thanks welkin!
10:41:46 <Denommus> nitrix: doesn't lazyness makes a bit harder to reason about breakpoints?
10:42:24 <nitrix> Why is that? 
10:43:31 <nitrix> You still control the execution flow.
10:47:59 * hackagebot yesod-routes-flow 1.0 - Generate Flow routes for Yesod  http://hackage.haskell.org/package/yesod-routes-flow-1.0 (FelipeLessa)
10:50:25 <Gurkenglas> @let instance ComonadCofree [] Tree where unwrap = subForest
10:50:27 <lambdabot>  Defined.
10:50:28 <Mings> hi, i've got a quick question.if i've already wrote an instance for a data type for typeclass show, is there a way to reuse that for instanciating the typeclass read?
10:50:30 <Gurkenglas> Why isn't this standard?
10:50:38 <lpaste_> relrod pasted “Am I missing something obvious here?” at http://lpaste.net/136815
10:52:09 <chpatrick> Mings: I've done some work related to this but it might take a bit of work :)
10:52:11 <chpatrick> @hackage codec
10:52:12 <lambdabot> http://hackage.haskell.org/package/codec
10:54:12 <Mings> chpatrick: thnx. so there is no other buildin way? An example, if Ive got the data type Days with data constructors Mon | Tue | ... and an instance like show Mon = "Monday", there is no easy way to tell ghc, that it should reverse it for instance Read?
10:54:40 <chpatrick> nopw
10:54:43 <chpatrick> nope
10:55:02 <drdo> relrod: It's probably just that in the first case the "b" can't be any b, it depends on a
10:56:12 <Mings> chpatrick: I am not too far in the haskell stuff, but isn't that a feature that could easily be integrated? sorry if it sounds pretentious
10:57:08 <chpatrick> Mings: reversing a general function is not so easy :)
10:57:31 <chpatrick> you could make a map from Days to Stirng
10:57:39 <chpatrick> and then look up the day for show and look up the string for read
10:57:44 <aweinstock> relrod: I'm not sure, but I think that pattern-matching on the FloatingWrapper constructor brings the "Floating a =>" constraint into scope in a way that unwrap doesn't
10:57:45 <indiagreen> Mings: Haskell often does with libraries what other languages have to build in
10:57:47 <chpatrick> not very efficient but it does the job
10:59:18 <indiagreen> it's bad because you often get less-than-perfect syntax and have to abuse type system to achieve what you want to achieve, but it's also good because you don't have to learn new syntax and because lots of different approaches could be tried without making any “the official” one
10:59:29 <mauris> i bet haskell could derive (Bounded a, Enum a, Eq a, Show a) => Read a !! :)
10:59:45 <drdo> getByteString :: Int -> Get ByteString, getLazyByteString :: Int64 -> Get ByteString . But why?
10:59:52 <drdo> (the Int vs Int64)
11:00:05 <relrod> aweinstock: hm...
11:00:06 <indiagreen> probably because lazy bytestrings can potentially be much longer
11:00:28 <chpatrick> hmm
11:00:32 <drdo> indiagreen: I would seriously just use Word for both, i don't understand why Int is used for sizes
11:00:38 <chpatrick> int == int64 on 64-bit though
11:01:00 <chpatrick> maybe there's something about the implementation of lazy bytestrings that needs the fixed size
11:01:11 <Mings> okay, thanks chpatrick and indiagreen :-)
11:03:02 <Gurkenglas> relrod, "Error: Eta reduce" probably refers to it wanting you to write "thing x = unwrap x" as "thing = unwrap", which should work no less.
11:06:59 <MichaelPlow_> anyone know how to get your dev server (the one that starts when you call yesod devel) to show up at your public IP as oppsed to your local host
11:07:14 <cow_2001> what if i don't use cabal sandbox, welkin?
11:07:15 <relrod> Gurkenglas: it doesn't - I get the same type error. I guess I should just have the class method be parameterized over something with a Floating constraint... e.g. class Foo a where thing :: Floating b => a b -> b
11:08:34 <relrod> Gurkenglas: or rather have "a" be parameterized*
11:08:47 <geekosaur> cow_2001, get the source, cd into its directory, "cabal install" (no package name)
11:09:14 <catgocat> I have a question about pure functions
11:09:16 <cow_2001> could i define that inside *.cabal?
11:09:43 <nkaretnikov> catgocat: just ask
11:10:07 <cow_2001> there's extra-lib-dir or somesuch, but that's for something else, not haskell packages
11:10:15 <catgocat> If Haskell can so well distinct pure code from impure code, why doesn't it cache the result from pure code so that if a function is invoked twice with the same parameters it doesn't need to actually run twice and can return the result from the previous call
11:10:36 <guest_haskeller> Hi everyone, I'm trying to get haskell to compile to android. I have found https://github.com/neurocyte/ghc-android which should do this. Could someone take a look at the build instructions on that page and advise me as to which of either cygwin minGW+MSYS or a debian virtualbox i should use to build this project? thanks in advance
11:10:45 <geekosaur> relrod, remember that in thing :: Floating b => a -> b, it's the caller of thing that gets to choose b
11:10:50 <Gurkenglas> catgocat, because that would overflow the memory instantly with entries like 2+2=4, 2.623463+7.3635... you get the picture
11:11:02 <aweinstock> catgocat: you don't have infinite memory
11:11:27 <Gurkenglas> catgocat, Haskell caches exactly those things that have a top-level name without any arguments, iirc
11:11:28 <geekosaur> your line 14 is not using the same a but a new one, so it doesn't actually specify a type and pi (which is polymorphic) can match what the caller specifies
11:11:29 <catgocat> Gurkenglas, but can't the compiler figure out if functions are being called with same parameters, and then cache the result if so?
11:11:38 <aweinstock> (does GHC do LRU caching for pure functions with some fixed cachesize)?
11:11:42 <geekosaur> the way you're trying to do it, you want to control what the caller controls
11:12:08 <mauris> i bet at some point, looking something up in your enormous memoization table takes longer than just recomputing it
11:12:32 <MichaelPlow_> anyone know how to get your dev server (the one that starts when you call yesod devel) to show up at your public IP as oppsed to your local host
11:12:38 <Gurkenglas> catgocat, that can't be figured out at compile-time, see halting problem. What can be done is caching ("memoizing") it if there is only one way to give an argument: when there are no arguments.
11:12:53 <guest_haskeller> i have had this problem with yesod
11:12:59 <guest_haskeller> i talked to snoyberg and he was no help
11:13:04 <catgocat> hmm
11:13:21 <guest_haskeller> i used nginx to portforward
11:13:25 <geekosaur> cow_2001, as far as I know you cannot
11:13:31 <relrod> geekosaur: Ok, that makes sense... But I'm not sure of the best way to fix it.
11:13:32 <geekosaur> currently
11:13:46 <cow_2001> geekosaur: dingit :(
11:13:47 <geekosaur> stack does support it, and the cabal-install devs are poking at ways to support it
11:14:04 <guest_haskeller> but a better solution i found was just to use Network.HTTP
11:14:05 <geekosaur> (at least it's my understanding that stack supports it)
11:14:18 <catgocat> still, I still believe the compiler could analyze the code and optimize (pure) function calls with the same parameters. I'm sure the problem here is not that the compiler "can't do it", but rather it would have other implications which I'm not quite sure
11:14:45 <geekosaur> catgocat, it could do so but it has implications with respect to sharing and memory usage
11:14:59 <catgocat> How is dad?
11:15:00 <guest_haskeller> I use Network.HTTP instead of yesod
11:15:02 <geekosaur> it's been found better to make the programmer specify
11:15:04 <catgocat> s/dad/that
11:15:04 <Gurkenglas> ("fibs = 1 : 1 : zipWith (+) fibs $ tail fibs" memoizes, "fib 1 = 1; fib 2 = 1; fib n = fib (n-1) + fib (n - 2)" doesn't.)
11:15:39 <guest_haskeller> MichaelPlow: did you catch that
11:16:05 <Gurkenglas> catgocat, oh, I thought you meant the compiler to figure out in advance which parameters were gonna be used a lot.
11:16:10 <MichaelPlow_> guest_haskeller: so you use Network.HTTP
11:16:22 <guest_haskeller> sorry to repost;  Hi everyone, I'm trying to get haskell to compile to android. I have found https://github.com/neurocyte/ghc-android which should do this. Could someone take a look at the build instructions on that page and advise me as to which of either cygwin minGW+MSYS or a debian virtualbox i should use to build this project? thanks in advance
11:16:41 <Gurkenglas> Note that there are libraries that memoize functions for many input parameter types.
11:17:00 <catgocat> For example if the compiler faced something like "bigCalculation 1e91 1e23" four times in the code, it could optimize it memoize it
11:17:01 <Gurkenglas> It'll cost memory for every caching though.
11:17:19 <guest_haskeller> MichaelPlow: yes, I could never get yesod to serve to anything but localhost and did not want to have to portforward with nginx, but you can use this to achieve what you want
11:17:24 <ttt_fff> so I'm reading Data.Map.Strict of Haskell, and am wondering "why are there so amny functions?"
11:17:28 <ttt_fff> Data.Strict.Map has more functions then women have shoes
11:17:40 <ttt_fff> there needs to be lookup, insert, delete, .... yet there's all this otther stuff
11:17:44 <geekosaur> ???
11:18:11 <relrod> geekosaur: if I fix this by changing thing to: thing :: Floating b => a b -> b, then I lose the ability to abstract over types that take multiple type parameters, I think. Like if I have a FloatingWrapper2 that has { unwrap2 :: (Floating a, Floating b) => (a, b) }, I can't write an instance for that.
11:18:21 <Gurkenglas> catgocat, I think if your sourcecode contains 4 times the same function application phrase, something else is going wrong
11:19:23 <geekosaur> ttt_fff, aside from the questionable nature of your comparison, I'm not sure what you are expecting
11:19:25 <relrod> er, if I have: FloatingWrapper2 a b
11:19:42 <geekosaur> Data.Map.Strict is an exact copy of Data.Map.Lazy but with operations made strict
11:20:01 <ttt_fff> geekosaur Data.Map has so many functions
11:20:04 <geekosaur> Data.Map is the same structure for both; it's the *operations* that change
11:20:06 <ttt_fff> i'm buidling flashcards for memorization
11:20:11 <ttt_fff> so many functions
11:20:17 <ttt_fff> 12 fucking pages of functions to memorize
11:20:22 <geekosaur> so you want something that is solely tutelary and not useful?
11:21:10 <ttt_fff> ELI5: what does tutelary mean?
11:21:28 <geekosaur> "fior teaching"
11:21:47 <Gurkenglas> You don't need to memoize it. hoogle code identifiers you don't know and type signatures you end up needing
11:21:50 <guest_haskeller_> sorry, got disconnected
11:21:56 <geekosaur> also consider you don't need to teach *all* of it
11:21:57 <Gurkenglas> *memorize lol
11:22:09 <ttt_fff> hoogle is a bit slow
11:22:19 <ttt_fff> I'm building a file of all bindings I commoly use, so I can just grep for them from within vim
11:22:19 <htebalaka> ttt_fff: if you aren't afraid of lenses then you can use https://hackage.haskell.org/package/lens-4.12.1/docs/Data-Map-Lens.html, which covers quite a few use cases
11:22:21 <Gurkenglas> Your brain is a bit slow! Sorry.
11:22:34 <guest_haskeller_> can someoe look at these build instructions with me? https://github.com/neurocyte/ghc-android
11:22:45 <ttt_fff> Gurkenglas: is this the #haskell variant of the short penis insult?
11:22:50 <Jgcoded> Hello, I want to make a Haskell program that grabs data from a Web API. What monad is best for the job?
11:22:57 <Gurkenglas> It just fit in two ways at once so I had to say it D:
11:23:25 <guest_haskeller_> Jgcoded, what do you mean monad? you mean library?
11:23:26 <htebalaka> though there's quite a bit more to memorize to use lens effectively, a lot of it can be re-used for different data types
11:23:29 <ttt_fff> Jgcoded: probably IO Monad, as this is not a pure operation
11:24:09 <guest_haskeller_> yes its n IO () monad but I think you also should look at https://www.haskell.org/hoogle/?hoogle=simpleHTTP
11:25:22 <Jgcoded> I figure that monads are the thing that structure your program
11:25:33 <guest_haskeller_> im trying to build ghc-android on windows, im not sure if i need a debian virtual machine or if minGW will do... I think this page could be understood by a more experienced haskell user to answer this question; https://www.haskell.org/hoogle/?hoogle=simpleHTTP
11:25:56 <htebalaka> ttt_fff: things like "someMap & at key .~ Just value" to insert, "someMap & at key .~ Nothing" to remove, or "someMap ^? ix key" to view
11:26:16 <guest_haskeller_> Jgcoded, yes, when using opperations that require realtime data, you can use the IO monad
11:26:18 <Gurkenglas> Why doesn't https://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Strict.html#v:alter list the other lens law as well?
11:26:32 <ttt_fff> htebalaka : yeah, I feel like I need to master lens one of these days
11:26:36 <Jgcoded> Thanks
11:26:42 <ttt_fff> htebalaka: my current leve is just view/over
11:27:03 <guest_haskeller_> oops wrong link in my last post, i meant; https://github.com/neurocyte/ghc-android
11:27:39 <htebalaka> or with less operators, "set (at key) (Just value) someMap", "set (at key) Nothing someMap", or "preview (ix key) someMap"
11:27:45 <guest_haskeller_> htebalaka: can you give us a helpful statement about lenses for those who have not been introduced to them?
11:28:40 <h1fuelcell> I <3 optimus'
11:28:42 <h1fuelcell> hehehe
11:28:52 <htebalaka> ttt_fff: i spent the better portion of a long weekend carefully going over a good portion of the lens api (operators, type synonyms, etc.) before i was really comfortable with it
11:29:03 <h1fuelcell> https://wiki.haskell.org/How_to_read_Haskell#What_the_heck_is_xyz.3F
11:29:43 <ttt_fff> htebalaka: any doc you suggest I read ?
11:30:02 <ttt_fff> it seems like the thing that once i master, will simplify much of my code
11:30:18 <ttt_fff> so much of non-pure monadic code is: grab this vlalue, do some shit to it, and update that value
11:30:23 <htebalaka> guest_haskeller_: they provide getters/setters which compose, so you can do things like "view (x . y . z) someObject" to view nested fields in datatypes
11:30:23 <guest_haskeller_> but what is it!?
11:30:48 <htebalaka> like in other languages, doing someObject.x.y.z
11:31:08 <guest_haskeller_> ok acn you patern match with them?
11:31:23 <indiagreen> sort of, with prisms
11:31:35 <guest_haskeller_> oh god!
11:32:21 <htebalaka> kind of. they're pretty general, so you can also do things like have lenses (traversals technically) which target multiple datatypes, so you can do things like "toListOf (x . y . z) someOtherObject" to get everything that they the "x . y . z" traversal targets
11:32:44 <htebalaka> ttt_fff: i started with https://hackage.haskell.org/package/lens-4.12.1/docs/Control-Lens-Operators.html
11:32:45 <Welkin> is there an easy way to install threadscope on osx?
11:32:58 <Welkin> I want to be able to run it from the terminal
11:33:09 <Welkin> all I have is this one package threadscope.app
11:33:14 <htebalaka> i made a big table of which all the operators, and what they do, so i could get a better sense of the operator naming scheme
11:33:28 <htebalaka> which incidently gives you a pretty big picture of the overal lens api
11:33:37 <ttt_fff> htebalaka: OMG, 31 pages
11:34:09 <htebalaka> and then i found the non-operator versions of as many of the functions as i could, because yeah, there's a lot
11:34:41 <htebalaka> view = (^.), preview = (^?), toListOf = (^..), etc
11:34:45 <indiagreen> ttt_fff: or you could just look at this table: https://github.com/ekmett/lens/wiki/Operators
11:35:12 <indiagreen> it's missing type signatures, but still pretty useful
11:35:18 <ttt_fff> you know that scene in heroes, where sylan rips out people's brains, and gains their powers?
11:35:20 <ttt_fff> I need that ability
11:35:22 <guest_haskeller_> will it work with datatypes defaul set method e.g. "view (getRightBranch.getLeftBranch) ((LeftBranch (RightBranch 1.0))::(Tree Double))"
11:35:31 <chreekat> guest_haskeller_: a lens is a first class, composable thing you can use for accessing and manipulating records in a type.
11:35:53 <indiagreen> ttt_fff: as someone who's spent like a day by now trying to understand how Isos are implemented in lens, I would very much like this ability too
11:36:05 <htebalaka> no, but there's a function which makes prisms (lenses which can fail) out of the a getter/setter
11:36:25 <chreekat> guest_haskeller_: you use a lens instead of the 'default set method'. An individual lens will wrap that method in a composable way.
11:36:33 <htebalaka> guest_haskeller_: and a lot of libraries include prisms. there is a _Left and _Right prism in the lens library for instance
11:36:59 <htebalaka> for Either. you would need a different one for binary trees
11:37:01 <edwardk> indiagreen: the trick with understanding isos in lens is to take the signature of a lens and ask yourself "how can i make something that i can turn around and run in the other direction and still have it unify with this other signature?"
11:37:02 <guest_haskeller_> cool thanks
11:37:51 <indiagreen> edwardk: yes, but I'm also trying to present it all as “here's how you could've thought it up by yourself, and that's assuming you've never heard about profunctors before”
11:37:53 <edwardk> indiagreen: once you beat on it for a while the solution comes out one of two ways, you can try to change the (a -> f b) -> s -> f t     --  by changing either the outer ->      to get p (a -> f b) (s -> f t)    or you can change the (->)'s inside each side to get p a (f b) -> p s (f t) -- for some 'p'
11:38:11 <indiagreen> and the outer thing was done in lens-3.6 and earlier
11:38:16 <edwardk> he word profunctor doesn't enter into it until you ask yourself what properties 'p' should have
11:38:18 <edwardk> correct
11:38:26 <indiagreen> this goes under the subsection “obvious solution” in my post
11:38:39 <htebalaka> but they unify a lot of things. for Either for instance, instead of needing `fmap :: (a -> b) -> Either c a -> Either c b`, `isRight :: Either a b -> Bool`, `getRight :: Either a b -> Maybe b`, you have "over _Right" "has _Right", and "preview _Right"
11:38:48 <guest_haskeller_> hmm, guys, no one wants to look into, https://github.com/neurocyte/ghc-android with me?
11:38:50 <edwardk> the problem with the obvious solution is it doesn't quite work. you wind up with a bunch of unsafe coerce noise or something evil like we used to have
11:39:03 <edwardk> whereas the profunctor solution just works with concepts that exist for more fundamental reasons
11:39:16 <edwardk> and gives a pattern that generalizes to transducers, etc.
11:39:26 <htebalaka> but because they compose if you have a nested Either inside a list inside another Either you could do things like "has (_Right . ix 5 . _Left)" to see if the left branch of the 5'th element of the right branch is non-empty
11:39:41 <chreekat> I was going to link to SPJ's intro to lens, but it looks like I have to log in to skillsmatter.com to see it now? 
11:39:46 <indiagreen> what's a transducer, actually? I heard about them in... Clojure, I think? but not in Haskell
11:39:49 <edwardk> chreekat: sadly true
11:40:02 <edwardk> :t foldl
11:40:04 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:40:08 <edwardk> :t foldl.foldl
11:40:09 <lambdabot> (Foldable t, Foldable t1) => (b -> a -> b) -> b -> t (t1 a) -> b
11:40:27 <htebalaka> if you google "lens over tea" there's a pretty detailed introduction that shows how they're built
11:40:29 <edwardk> :t foldl.foldl.foldl
11:40:30 <lambdabot> (Foldable t, Foldable t1, Foldable t2) => (b -> a -> b) -> b -> t (t1 (t2 a)) -> b
11:40:37 <chreekat> edwardk: who do we write to explain that that is a terrible idea?
11:40:39 <guest_haskeller_> are compilation and build procedures not discussed in #haskell?  
11:41:06 * chreekat calms down
11:41:10 <edwardk> ^- transducers. hickey likes to say that the 'b' isn't really typeable in haskell but its mostly that he likes to shoehorn a bunch of things into the transducer mold that are harder to fit in haskell
11:41:16 <htebalaka> i'd help if i knew more about android, sorry :(
11:41:25 <edwardk> chreekat: no idea, kosmikus may know the organizers there
11:41:36 <Welkin> fuck apple's package formats
11:41:43 <Welkin> wrong channel
11:41:56 <tolt> I'm getting a really confusing error. When I use https://hackage.haskell.org/package/wreq, there's an issue with passing in Value for post
11:42:15 <tolt> When I try, I get no instance for Postable Value
11:42:33 <edwardk> indiagreen: basically transducers are left folds as functional units obtained by realizing that foldl :: (x -> a -> x) -> (x -> [a] -> x)  -- has the same kind of pattern as a lens, its a function from something with the same kind of shape as its result, so they compose naturally with (.)
11:43:16 <edwardk> indiagreen: in a strict functional setting left folds are more fundamental, so it makes a lot more sense in that setting.
11:43:33 <voidzero> I'm trying to build optparse-applicative on a 32 bit box
11:43:38 <edwardk> in the presence of arbitrary effects they are a much more general purpose pattern as well
11:43:57 <voidzero> but it fails, because of a duplicate module definition for x86.get_pc_thunk.bx
11:44:12 <dmj`> does this funtion exist? f :: MonadIO m => (e -> EitherT f m a) -> EitherT e m a -> EitherT f m a    
11:44:23 <voidzero> anything I can do about it?
11:45:15 <htebalaka> dmj: i think there's an EitherRT newtype, which makes it a monad in its error parameter
11:45:22 <dmj`> I know with bifunctors I can `fmap` over the Left, but I need a mapM_ style for fmapping
11:45:26 <htebalaka> in which case that would just be (>>=)
11:46:17 <htebalaka> dmj: http://hackage.haskell.org/package/errors-2.0.0/docs/Data-EitherR.html
11:46:23 <dmj`> I need a function where I can perform effects over the e in an m and return a f 
11:46:59 <dmj`> I need mapM on the left ! 
11:47:20 <dmj`> swapEitherT isn't satisfying, but that might work, and then just do mapM
11:47:25 <chreekat> dmj`: htebalaka is giving you a solution. :)
11:47:30 <dmj`> htebalaka: hrmm
11:47:34 <dmj`> chreekat: sort of
11:47:56 <dmj`> I wouldn't call throwing depedencies at the problem a solution, EitherT and the current abstractions we have should provide this ootb
11:48:06 <dmj`> dependencies
11:48:24 <chreekat> which "current abstractions" do you mean?
11:48:59 <htebalaka> you could always look at the monad (>>=) definition for ExceptRT, and just copy it if you don't want to pull in the dependency
11:50:40 <dmj`> :t swapEitherT
11:50:41 <lambdabot>     Not in scope: ‘swapEitherT’
11:50:41 <lambdabot>     Perhaps you meant one of these:
11:50:41 <lambdabot>       ‘IM.mapEither’ (imported from Data.IntMap),
11:50:56 <dmj`> :t \f -> join . mapM f
11:50:57 <lambdabot> (Monad m, Traversable m) => (a1 -> m a) -> m a1 -> m a
11:51:07 <dmj`> doing that, and then swapping both sides works
11:51:19 <dmj`> htebalaka: I'm not going to change the monad instance for EitherT
11:51:40 <dmj`> chreekat: foldable, traversable, functor, bifunctor, profunctor
11:52:22 <htebalaka> under the ExceptT newtype you could "fmap (either Right Left)" to swap the arguments, then perform bind, then swap them back
11:53:17 <indiagreen> edwardk: so a transducer is basically a Fold which – instead of using a monoid – combines everything it sees with an accumulator we give to it beforehand?
11:54:07 <htebalaka> i think, something like "errorBind (ExceptT m) f = case ExceptT (fmap (either Right Left) m) >>= f of { ExceptT m' -> ExceptT (fmap (either Right Left) m')
11:56:15 <nitrix> Hi, what if I want only one module to know about a record's fields?
11:56:48 <htebalaka> factor out the "ExceptT . fmap (either Right Left) . runExceptT" and you've got something like "errorBind m f = swapExceptT (swapExceptT m >>= f)
11:56:54 <nitrix> As soon as I expose those for my wrapper module, then anyone could directly access those and not use my wrapper, right?
11:58:09 <rowanblush> nitrix: Usually you create another level on the hierarchy beneath the module you're working on called Whatever.Internals, and trust that your users won't needlessly shoot themselves in the foot by importing it without understanding the invariants.
11:59:14 <rowanblush> You re-export the opaque type from the module Whatever.
11:59:19 <edwardk> indiagreen: yeah. its a left-biased fold
12:00:05 <nitrix> rowanblush: Okay but they could still theorically import Whatever.Internal.X, right?
12:00:29 <nitrix> rowanblush: And whatever's in there, except the name's giving away that you might be bypassing something?
12:00:38 <bergmark> nitrix: you can have un-exposed modules
12:00:45 <nitrix> bergmark: How?
12:00:57 <bergmark> list them under other-modules instead of exposed-modules
12:01:13 <rowanblush> Right, but at the end of the day they're compiling your code anyway.
12:01:46 <nitrix> bergmark: I don't use exposed nor other modules. Letting cabal do the work for me.
12:02:28 <bergmark> huh? this is a cabal feature...
12:02:28 <rowanblush> nitrix: `other-modules` and `exposed-modules` are fields that can be placed in your cabal file.
12:04:08 <rowanblush> nitrix: http://www.haskell.org/cabal/users-guide/developing-packages.html#modules-included-in-the-package
12:04:23 <nitrix> It's not secrecy or anything, I just don't want someone to accidently use one of four operations, that, without their wrapper, would not leverage caching and that could lead to discrepancies instead of eventual consistency.
12:05:03 <nitrix> bergmark: What if they aren't using cabal. I'm not asking for a tool solution, but language-wise.
12:07:49 <c_wraith> nitrix: other-modules vs exposed-modules is a package thing, not a cabal thing.
12:08:46 <c_wraith> nitrix: but in general, the correct choice is giving users access to everything, but via a module labeled "you can badly break your code if you use this"
12:08:58 <c_wraith> nitrix: because usually, you guess wrong when you guess what people actually need.
12:09:14 <c_wraith> nitrix: whereas if you give people everything, they can do stuff you never considered.
12:09:30 <nitrix> I'm aware of all this.
12:09:48 <nitrix> I wouldn't be asking for an idiomatic way otherwise.
12:10:09 <c_wraith> That *is* the idiomatic way
12:10:20 <nitrix> So I assume it's a problem that Haskell isn't trying to solve.
12:10:23 <c_wraith> If you already know it, I don't know what you're asking for.
12:10:24 <nitrix> No the solution is terrible.
12:10:44 <c_wraith> It also works, unlike every solution I've seen elsewhere.
12:10:54 <nitrix> It doesn't address the issue, it's just a convenience option in the toolkit, not a language feature.
12:12:12 <catgocat> I am follow the real-world-haskell book and in some point of the chapter, the author uses this import: `import System.IO.Error (catch)`, however I get an error that catch is not imported by System.IO.Error
12:12:16 <catgocat> what should I do?
12:12:29 <c_wraith> The fundamental problem is that the author of the library is the wrong person to decide what the library exposes.
12:12:37 <c_wraith> No language can solve that.
12:13:11 <c_wraith> catgocat: real world haskell is quite old
12:13:26 <c_wraith> catgocat: if you're using the online version, the comments often include updates on what correct current code is.
12:13:47 <c_wraith> catgocat: to fix this particular one, use `import Control.Exception(catch)`
12:14:00 <catgocat> does it work the same way as system.io.error?
12:14:12 <nitrix> c_wraith: It's not about exposing it or not, this is taken care of properly. The issue is interoperability that can be restricted between modules.
12:14:26 <burp> I think yes, only module changed
12:14:29 <indiagreen> nitrix: would -a “whitelist” keyword letting you specify which modules are allowed to import a module- be considered a solution?
12:14:47 <c_wraith> catgocat: no, it's significantly more powerful..  And sometimes slightly harder to use.
12:15:03 <nitrix> This way, one extends this safety to how modules are composed, instead of giving that responsability to the toolkits.
12:15:04 <c_wraith> catgocat: the exception system was changed to be extensible, instead of working only with a few predefined exception types.
12:15:14 <nitrix> indiagreen: Per module though, yes.
12:15:35 <c_wraith> catgocat: but that means sometimes you need to tell it what kind of exception you actually want to catch.
12:16:02 <indiagreen> I'm entering the land of cranky proposals now, but
12:16:04 <nitrix> indiagreen: Otherwise, the only option is a big module with everything in is, which in my case isn't possible because of cyclic dependencies.
12:16:35 <nitrix> So that library has to be decomposed into multiple modules and some modules aren't safe to use.
12:16:40 <catgocat> Now I get this error:
12:16:41 <catgocat>   No instance for (GHC.Exception.Exception e0)       arising from a use of `catch'
12:16:58 <indiagreen> let each module be signed by developer's private key, and the whitelist keyword would take a list of signatures of modules that are allowed to use it
12:17:01 <lpaste_> catgocat pasted “error on catch” at http://lpaste.net/136820
12:17:02 <Gurkenglas> Is there a cranky proposal list :D?
12:17:21 <catgocat> can anyone check out my lpaste?
12:17:45 <catgocat> it triggers an error in the catch call
12:17:47 <nitrix> indiagreen: I see where you're comming from, but that's not the idea.
12:18:15 <c_wraith> catgocat: that's what I was talking about.  You need to tell it what exception you want to catch, and your handler doesn't.
12:18:31 <catgocat> I don't get it
12:18:35 <catgocat> can you show me how to do it?
12:18:36 <indiagreen> nitrix: actually I just thought “but wouldn't we need a better way to identify modules than simply their names”
12:19:11 <indiagreen> (and in reality, the fact that modules are identified by their names does make me very slightly uncomfortable)
12:19:15 <nitrix> indiagreen: If anyone really wanted, they could just copy-paste the code and use it without the key. It's not that kind of authorship/protection I'm suggesting.
12:19:23 <indiagreen> I know, I know
12:19:29 <indiagreen> which is why I labelled it as “cranky”
12:20:19 <catgocat> renaming catch to catchIOError seems to fix the problem
12:20:24 <nitrix> indiagreen: It's not actual security, it's more of a safety thing to avoid the user trying to import that module and not knowing about the existance of the wrapper for that module he's supposed to be using.
12:20:27 <c_wraith> catgocat: actually, it looks like System.IO.Error has some compatability stuff..  You might want to just use catchIOError from System.IO.Error.  It's the same function, but with the types fixed so you don't get ambiguity errors
12:20:52 <rowanblush> nitrix: Why don't you name the fields `unsafeUseTheVersionInModuleFooWhateverInsteadFieldA`?
12:21:02 <nitrix> indiagreen: Sure, I can name it X.Internal.Y, that's sufficient for most of us, but somehow, I feel like there's an idiot somewhere that'll risk using it, because the interface is easier.
12:21:03 <indiagreen> nitrix: yep, but is this really a concern considering that everyone I know seems to use cabal anyway?
12:21:42 <indiagreen> I mean... okay, fine, maybe I'm just ignorant. So, a question
12:21:43 <nitrix> indiagreen: Well, that's another topic, but I strongly believe a language should be agnostic of the tools that exists for it.
12:21:47 <indiagreen> are there people who don't use cabal?
12:21:55 <nitrix> What about stack?
12:22:04 <indiagreen> cabal-the-library, then
12:22:06 <rowanblush> nitrix: Still based on cabal the library.
12:22:18 <reindeernix> so I seem to get a NaN from somewhere in my program but I have no idea where it happens first. I would like to ask if there is a way to find out exactly when the first NaN is calculated
12:22:49 <reindeernix> I am using not-gloss but I have tested it and it's not what's wrong here, something in my calculations are doing it
12:22:58 <nitrix> Anyway, still another topic that I'm very opiniated so might want to wait for that one.
12:23:46 <nitrix> rowanblush: `unsafe` prefix could work somehow, but personally I find it more related to type safety and IOs.
12:24:12 <rowanblush> reindeernix: Try `import Debug.Trace (trace)`.
12:24:13 <nitrix> Maybe because of unsafePerformIO.
12:24:41 <reindeernix> rowanblush, alright thank you, will try it
12:25:02 <rowanblush> nitrix: Whatever word you like. Maybe, `shamblingHorrorsAwaitYouHereForUsingThisFieldAccessorDirectly`.
12:25:50 <nitrix> Humourous tips, but it's not really addressing the problem.
12:26:12 <nitrix> I'll thinker and see if I can come up with a decent proposal.
12:26:20 <c_wraith> nitrix: the problem being that some people will always find a way to do the wrong thing?  You can't prevent that, either.
12:26:35 <rowanblush> Yeah I think your problem is pretty unique to you.
12:26:48 <rowanblush> Are you really not using cabal files to package your project?
12:26:58 <rowanblush> I'm kind of interested what you're developing and for who.
12:27:07 <hodapp> Are there any fairly standard calls that can handle formatting an Integer as hex, and a little cleaner than Text.Printf?
12:27:44 <ski> > showHex 100 ""
12:27:45 <lambdabot>  "64"
12:27:47 <rowanblush> hodapp: Numeric.showHex
12:28:19 <ski> > (showString "0x" . showHex 100 . showString " = " . shows 100) ""
12:28:21 <lambdabot>  "0x64 = 100"
12:29:22 <nitrix> rowanblush: Distributed file system, with mojette transformation, probabilistic compression of encrypted data, on write-once-read-many fixed block-based storage devices. It's implemented as a rope for files and b-tree for the FS. Keys and values have variable lengths, so it's a knapsack problem.
12:29:26 <ski> > showHex (-100) ""
12:29:28 <lambdabot>  "*Exception: Numeric.showIntAtBase: applied to negative number -100
12:30:09 <hodapp> rowanblush: I need a little more formatting than showHex, e.g. something like "%08X"
12:30:15 <nitrix> rowanblush: The backend supports multiple implementations through a common CRUD (create,read,update,delete) interface, accross all providers, and lastly, its size is unlimited.
12:30:20 <wzjke> hello ok who use telegram?
12:30:35 <rowanblush> nitrix: Sounds intense.
12:30:43 <indiagreen> wzjke: is this going to be Haskell-related?
12:30:56 <indiagreen> (also, I do)
12:31:09 <nitrix> rowanblush: I've been working on it for 3 years and rewrote it in 6 languages, because the complexity became too large.
12:31:43 <nitrix> The Go one looked very solid but then Haskell gave me hope.
12:32:26 <nitrix> So here I am.
12:33:01 <rowanblush> nitrix: Well, good luck! I hope besides your export issue you're finding Haskell valuable to your latest attempt.
12:33:28 <nitrix> Yeah, I'm very pleased by a lot of the language features.
12:34:15 <nitrix> There are things that blows my mind. Like Prelude.head throwing an exception when it's totally recoverable and we have types whose sole purpose are to express these things, like Maybe. 
12:34:41 <kosmikus> chreekat: regarding the login barrier to skillsmatter videos: I've certainly explained to them that I think this is "wrong", and doesn't do them an advantage. but they think otherwise, it seems.
12:34:49 <geekosaur> head is for lisp addicts (car ...)
12:34:58 <nitrix> At least someone wrote headMay, but I just find it strange we still have the old mold.
12:35:14 <rowanblush> The weight of history on that one, unfortunately.
12:35:15 <kosmikus> chreekat: I'd still suggest that overall, it's great that they're making all videos available for free and in good quality, and we should let them make their choice about what kind of barriers they want to place.
12:35:48 <bergmark> nitrix: you can't fix everything at once, head is also perfectly safe on infinite lists
12:35:54 <nitrix> rowanblush: This is sort of what I meant by safety first. There are quirks. But I think the pros outweights the bads for the moment.
12:36:04 <exio4> nitrix: using head is probably wrong there then
12:36:57 <nitrix> Infinite lists bothers me somehow. Not that I'm a coq advocate, but I like weak normalization.
12:37:06 <nitrix> We'll see how it goes.
12:37:20 <exio4> they are handy :) 
12:37:27 <ChristianS> in the company in work for, the use of unsafe partial functions such as head is totally forbidden
12:38:22 <nitrix> Is it a least deprecated?
12:39:48 <gfixler> nitrix: I think part of the reason head is still there is newb-friendliness
12:40:01 <nitrix> import noobFriendly
12:40:01 <exio4> if anything, it's unfriendly
12:40:08 <gfixler> not that exceptions are cuddly, but if a new user just wants to get the head of a list...
12:40:12 <chreekat> kosmikus: Yes it would be much worse if it was a paywall. Still questionable to require login, but in the grand scheme of things..
12:41:03 <gfixler> nitrix: I suggest/have seen suggested multiple preludes
12:41:14 <gfixler> by default, a newb-friendly prelude is used
12:41:24 <nitrix> gfixler: I'm not sure, but aren't most languages returning a null or similar value when it's empty? Haskell's Nothing seem like a perfect candidate. It's way less surprising than an exception and it's expressed by the type system.
12:41:30 <nitrix> I personally find it more noob friendly.
12:41:41 <nitrix> Except it enforces you to learn about functors sooner.
12:41:52 <iteratee> I saw online that hackage-server was in need of maintenance. I'm looking to do more visible contribution to the haskell community. Is there someone familiar with hackage-server around with suggestions about where to start?
12:42:04 <gfixler> nitrix: yeah, that second one is the issue
12:42:07 <kosmikus> chreekat: I absolutely agree with you, and I don't understand their logic. And you can be assured that I'll point it out again. But I'm also sure that lots of other people already have, and they don't seem to be inclined to change it.
12:42:16 <gfixler> hang out in #haskell-beginners for awhile, and watch the angst of new users
12:42:23 <bergmark> iteratee: try #hackage
12:42:28 <gfixler> ready to the leave the language, because they have to learn a monad just to print something
12:42:42 <kosmikus> chreekat: and as I said, I'm still grateful that they make the videos available at all. and they're usually really fast in doing so (same day or one day after the event)
12:42:55 <iteratee> bergmark: thanks
12:43:33 <nitrix> gfixler: To be fair, the amount of people that comes on ##c with a misconception about pointers is just as large. It's actually very simple, if you invest a little time to learn things one step at a time, shouldn't be too bad.
12:44:09 <nitrix> Anyway, you don't go very far with Hello World. You'll have to fuel your learning further more to get going.
12:44:15 <gfixler> nitrix: I think you're feelings (which are good) are the overwhelming minority, and there seems to be a push to make haskell easy for new users
12:44:27 <gfixler> I'm a from-first-principles sort, and 2 years in, I'm still writing very small programs
12:44:48 <gfixler> I don't really agree with the advanced folks in here that think all of these things are newb-friendly
12:45:02 <Jello_Raptor> gfixler: but they don't <_<, you can treat IO as a special case and use it effectively long before you need ot understand that monad generalization. 
12:45:02 <gfixler> they're "more correct," but they have a higher investment cost, IMO
12:45:10 <gfixler> Jello_Raptor: I know
12:45:26 <gfixler> Jello_Raptor: have you spent a lot of time in #haskell-beginners?
12:45:50 <Jello_Raptor> gfixler: nope, should I? given that compared to the people in here I clearly am one :P 
12:46:03 <gfixler> Jello_Raptor: well, it's eye-opening sometimes
12:46:13 * Jello_Raptor nods, joins
12:46:19 <gfixler> people coming in after hours of fighting CIS194, still lost as can be
12:46:20 <Welkin> how can I tell ghc to use a sandbox for the packages?
12:46:23 <Jello_Raptor> gfixler: lots of burritos? 
12:46:32 <Jello_Raptor> CIS194? 
12:46:35 <gfixler> no, it's a burrito-free zone, by order of the magistrate
12:46:50 <dolio> How do you know that people in #haskell-beginners are a representative sample of haskell beginners?
12:47:03 <gfixler> Jello_Raptor: byorgey's UPenn course - http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
12:47:05 <Jello_Raptor> ahh, good on them. That analogy confused me so much >_<
12:47:16 <gfixler> Jello_Raptor: often recommended for beginners (I'm still in week 10!)
12:47:24 <Jello_Raptor> cool :) 
12:47:57 <gfixler> Jello_Raptor: there are 3 versions - newest here (link to older ones at the top): http://www.seas.upenn.edu/~cis194/
12:48:12 <Jello_Raptor> gfixler: the thing that made monads click was the "monad as way to overload the ';' operator" 
12:48:33 <Welkin> cabal exec did the job
12:48:42 <gfixler> Jello_Raptor: monads have clicked for me, and unclicked, many times
12:48:56 <Welkin> cabal exec -- ghc -O2 rpar.hs -threaded
12:49:19 <Jello_Raptor> gfixler: that stopped after I figured out how monad transformers sorta work. Need to put that into practic\e though. 
12:49:30 <Jello_Raptor> gfixler: well, it's stopped for a while. 
12:49:35 <gfixler> Jello_Raptor: I'm just on the cusp of grokking transformers
12:49:37 <rcyr_> gfixler: Even when you get them... you need to learn about monad transformers... then while doing it, you don't really get the difference between MTL and transformers.
12:49:50 <gfixler> rcyr_: I don't get that difference, true
12:50:06 <rcyr_> Haskell... I love it but it's painful.
12:50:12 <gfixler> rcyr_: I used hole-driven haskell to create a Monad instance for MaybeIO at a recent meetup
12:50:19 <gfixler> but didn't really grok what to do once I had it :)
12:50:24 <rcyr_> Hehe :)
12:50:29 <gfixler> as a group, we pushed our way through to using it for something
12:50:44 <gfixler> but I'm still a long way out, I think
12:50:55 <Jello_Raptor> gfixler: actually scratch that, In truth I still don't really understand Free, Cont and their transformer versions. 
12:51:07 <gfixler> rcyr_: https://gist.github.com/gfixler/b5002dfacbd972aea6e8 <- what we wrote
12:51:13 <gfixler> Jello_Raptor: :)
12:51:29 <rcyr_> Haha :)
12:52:10 <gfixler> there's a quality to all of these things, though
12:52:16 <Jello_Raptor> Like, I get what they do and how to use them, but have no intution as to when using them is a good idea. Not to mention there's a big hole where I should have a mental model of how FreeT works. 
12:52:35 <gfixler> once I see how they're done, they always seem a lot smaller and simpler than I expected
12:52:40 <gfixler> and never look anything like the model in my head
12:52:59 <gfixler> and then I have to fight that, too - that feeling of "This isn't what I thought this was going to be"
12:53:16 <gfixler> hard to shed the wrong worlds I build up in my mind
12:53:26 <gfixler> parsing into a tree was like that, e.g.
12:53:39 <gfixler> I thought it was going to be a huge, convoluted, 2kloc ordeal
12:53:49 <gfixler> but then I've seen toys in haskell in half a page of code
12:54:13 <Jello_Raptor> gfixler: monadic parsing was one of the first models which really clicked for me, and therefore List as well
12:56:02 <Jello_Raptor> gfixler: having that fit together, and reazing that laziness turns the breadth first search into a depth first one was so cool. 
12:56:27 <Welkin> I found a mistake in Parallel and Concurrent Haskell
12:56:39 <Welkin> where should I report it?
12:57:04 <Welkin> rpar/rseq should be rpar/rpar in the first example of chapter 2
13:05:16 <kyclark> Given a tab-delimited line of integer file input, how can I most efficiently split and convert to integers?
13:05:17 <kyclark> let p = map (\x -> read x  :: Int) splitOn "\t" line
13:05:23 <kyclark> That doesn't work
13:06:19 <Sindriava> Is there some sort of "no-old-stuff" warning switch for GHC?
13:06:34 <Sindriava> Like warning for using "map" instead of "fmap" and so on
13:07:23 <P4Titan> Hello all, what would happen if I did Nothing <*> Just (2) for example
13:07:53 <exio4> you can easily try]
13:07:54 <Sindriava> P4Titan: Why not try?
13:08:01 <exio4> > Nothing <*> Just 2 
13:08:02 <lambdabot>  Nothing
13:08:06 <indiagreen> Sindriava: not that I know of
13:08:13 <P4Titan> I did not know How to execute stuff n lambdabot
13:08:25 <P4Titan> s/n /in /
13:08:37 <P4Titan> > Nothing <*> Just 2
13:08:38 <lambdabot>  Nothing
13:08:45 <Sindriava> indiagreen: Shame. I'd really like to build good habits for writing modern Haskell, but a lot of the resources are older
13:08:56 <Jello_Raptor> Is there a module hierarchy guide for haskell something like "Things that deal with data structures should be submodules of Data, things that deal with raw numberic types should be in Data.Numeric"?  
13:09:14 <indiagreen> Sindriava: I don't think abolishing map is a part of modern Haskell
13:09:14 <Jello_Raptor> found it, I think https://wiki.haskell.org/Hierarchical_module_names
13:09:47 <indiagreen> if you really want *that*, you should spend effort learning pipes, lenses, etc
13:09:57 <indiagreen> but map vs. fmap and ++ vs <> isn't worth it
13:10:30 <whiteline> is lenses worth learning
13:10:57 <wzjke> hey any body - help! who can say me - where i can do this - " I need create something REALLY NEW in this world, not computer, not car, nor telephone, not robot ! my goal greate something new like Quantum / Quantum world" Any body please help me find place for me!
13:11:48 <exio4> probably not #haskell
13:12:19 <Welkin> wzjke: try rational wiki: http://rationalwiki.org/wiki/Roko%27s_basilisk
13:12:28 <indiagreen> Welkin: tsk
13:12:48 <indiagreen> whiteline: I'd say that how to *use* lenses (and prisms and traversals) is worth learning in any case, but other stuff depends on what you're doing
13:13:04 <P4Titan> :t (<*>)
13:13:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:13:33 <indiagreen> in particular, avoid the “lens over tea” posts (which, coincidentally, I am an author of) because they focus too much on implementation
13:13:53 <Sindriava> indiagreen: Hm… Maybe. But I keep seeing that I should use fmap instead of map O.o
13:13:56 <P4Titan> > [1, 2] *> [3, 4]
13:13:58 <lambdabot>  [3,4,3,4]
13:14:10 <indiagreen> Sindriava: hm, where?
13:14:31 <P4Titan> > [1, 2] <|> [3, 4]
13:14:32 <lambdabot>  [1,2,3,4]
13:14:33 <Sindriava> indiagreen: Some of the discussions online and some posts seem to use it
13:15:00 <indiagreen> Sindriava: I do see a lot of questions like “what do we need map for when we have fmap”
13:15:02 <P4Titan> What is the point of defining Alternative for [] if [] and (++) exist?
13:15:26 <indiagreen> but they are more often asked by beginners
13:15:57 <indiagreen> perhaps you've seen such advice given by people who just learned about fmap and decided on their own that map must be obsolete then
13:15:57 <P4Titan> I guess my question is the exact same as map v fmap
13:15:59 <Sindriava> indiagreen: Yeah, I'm well aware of the differences (and that's why I like fmap more than map), but I have no idea of what's the "right way"
13:16:27 <indiagreen> there's no right way, the same way there's no right way to name things
13:16:39 <indiagreen> use map instead of fmap when it makes things clearer
13:16:43 <Welkin> I love that in haskell, there are many correct ways to do something
13:16:44 <Sindriava> indiagreen: There IS a right way to name things
13:16:49 <Sindriava> indiagreen: Not naming things
13:17:01 <indiagreen> why?
13:17:02 <P4Titan> map is more explicit with lists
13:17:19 <indiagreen> for me, naming things often helps understand the code
13:17:20 <Sindriava> indiagreen: Only in some cases, of course :)
13:17:21 <P4Titan> fmap refers to the Functor class which happens to be analogous for map with lists
13:17:26 <P4Titan> but not for non-lists
13:17:36 <indiagreen> I name things even when I can perfectly avoid naming them
13:17:46 <Sindriava> indiagreen: For me, it adds too much mental overhead most of the time
13:17:49 <nocturne777> what library do you guys use for logging?
13:18:32 <indiagreen> Sindriava: and that's why there's no right way to name things in general – you don't know who is going to read your code. You can only act on probabilities.
13:18:43 <Sindriava> P4Titan: Because [a] makes perfect sense for the alternative typeclass, when you consider how it behaves monadically
13:18:54 <Sindriava> indiagreen: Fair enough.
13:18:55 <P4Titan> > [1, 2] >>= return . (+1)
13:18:57 <lambdabot>  [2,3]
13:19:43 <Sindriava> P4Titan: The default instance for [a] in Haskell is that it behaves like a nondeterministic computation
13:19:57 <P4Titan> ok
13:20:11 <Sindriava> P4Titan: [1, 2] isn't a list of 2 values, but rather ONE value, that can be either 1 or 2
13:20:21 <Sindriava> P4Titan: For the other instance, there's ZipList
13:20:35 <P4Titan> Are you explaining for the <|> when we already have ++?
13:20:48 <Sindriava> P4Titan: They don't do the same thing.
13:20:56 <P4Titan> In list they do though
13:21:04 <Sindriava> P4Titan: You don't always have lists.
13:21:05 <P4Titan> > [1,2] <|> [3, 4]
13:21:06 <lambdabot>  [1,2,3,4]
13:21:19 <mniip> [23:18:06] <Sindriava> P4Titan: Because [a] makes perfect sense for the alternative typeclass, when you consider how it behaves monadically
13:21:23 <P4Titan> You mean for variadic functions?
13:21:31 <mniip> that's just beacause ZipList Monad is unsustainable
13:21:40 <Sindriava> P4Titan: Alternative is a typeclass.
13:21:44 <P4Titan> yes
13:21:52 <indiagreen> P4Titan: I think the real reason we have <|> when we have ++ is that we have the Alternative class which is useful for *other things*, and once you have a class you want to add instances for everything that makes sense
13:22:01 <Sindriava> P4Titan: You can have a function that take (Alternative a) => 
13:22:12 <Sindriava> P4Titan: Then it uses <|> on a
13:22:12 <indiagreen> I don't think anyone actually uses <|> instead of ++ when ne knows ne has a list
13:22:14 <P4Titan> Exacltly
13:22:30 <Sindriava> P4Titan: That's not what the instance is for, you're missing the point
13:22:39 <P4Titan> so like myFunc :: Alternative a => a b -> b
13:22:47 <Sindriava> P4Titan: Alternative for [a] is so you can pass [a] to functions that expects Alternative
13:23:00 <Sindriava> P4Titan: Not so you can use <|> on lists
13:23:01 <P4Titan> and get something out
13:23:06 <P4Titan> ok
13:23:26 <Sindriava> :src (<|>)
13:23:43 * Sindriava is off to google how lambdabot works
13:23:46 <jackhill> @src (<|>)
13:23:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:24:05 <indiagreen> @src Applicative []
13:24:05 <lambdabot> Source not found. There are some things that I just don't know.
13:24:13 <indiagreen> @src [] Alternative
13:24:13 <lambdabot> Source not found. Whoa.
13:24:19 <indiagreen> hm
13:24:25 <P4Titan> instance Alternative [] where
13:24:26 <P4Titan>     empty = []
13:24:26 <P4Titan>     (<|>) = (++)
13:24:34 <Sindriava> Yep, exactly
13:24:41 <Sindriava> That's what I was trying to demonstrate
13:25:08 <P4Titan> It is so that I can pass a list into a function expecting Alterative a => a b -> a b, and get something out
13:25:27 <Sindriava> P4Titan: Alternative instance of [] exists so you can pass [] to stuff that expects Alternative, NOT a list
13:25:42 <Sindriava> Because [] makes perfect sense for Alternative
13:25:59 <P4Titan> by [] you mean lists, correct?
13:26:03 <indiagreen> aha, I figured it out
13:26:04 <Sindriava> P4Titan: Yup
13:26:05 <indiagreen> @src [] (<|>)
13:26:05 <lambdabot> (<|>) = (++)
13:26:13 <Sindriava> indiagreen++
13:26:15 <P4Titan> And please describe "perfect sense"?
13:26:23 <Sindriava> P4Titan: Oh, gimme a sec to write it up
13:26:36 <P4Titan> @src [] fmap
13:26:36 <lambdabot> fmap = map
13:26:39 <P4Titan> tee-hee
13:26:53 <Sindriava> @src map
13:26:53 <lambdabot> map _ []     = []
13:26:53 <lambdabot> map f (x:xs) = f x : map f xs
13:27:18 <Sindriava> P4Titan: By default, [1, 2, 3] behaves like "an Int, that's either 1 or 2 or 3 and we don't know which"
13:27:25 <Sindriava> P4Titan: That's why:
13:27:26 <P4Titan> OK
13:27:39 <Sindriava> > (+) <$> [1, 2] <*> [4, 6]
13:27:40 <lambdabot>  [5,7,6,8]
13:27:43 <P4Titan> so where is the ferfect sense?
13:27:52 <P4Titan> /s/ferfect/perfect/
13:27:56 <Sindriava> Wait a second FFS
13:28:02 <Sindriava> Does all the possible combinations
13:28:31 <Sindriava> So when you have [1, 2] <|> [3, 4], what it really reads out is: "(1 or 2) OR (3 or 4)"
13:28:47 <Sindriava> which is the same as "1 or 2 or 3 or 4", which is [1, 2, 3, 4]
13:29:09 <P4Titan> Ok, theoretically, I get it, in practice, ...
13:29:23 <Sindriava> In practice it means, that Alternative and lists are very similar
13:29:23 <P4Titan> (+) <$> [1, 2]
13:29:47 <Sindriava> (+) <$> [1, 2] is a function, that adds either 1 or 2 to a value
13:29:51 <P4Titan> Ok, I'll keep this in mind, just that at least at my level, I don't see its practibility
13:30:10 <Welkin> > (+) $> [1,2] <*> [4,6]
13:30:10 <P4Titan> > [(+1), (+2)] <*> [1, 2]
13:30:11 <lambdabot>      Couldn't match expected type ‘[a0]’
13:30:11 <lambdabot>                  with actual type ‘Integer -> Integer -> Integer’
13:30:11 <lambdabot>      Probable cause: ‘(+)’ is applied to too few arguments
13:30:11 <lambdabot>  <no location info>: can't find file: L.hs
13:30:17 <Sindriava> P4Titan: practibility of what?
13:30:26 <P4Titan> Alternative and list
13:30:47 <Sindriava> P4Titan: List is a list (I hope I don't have to explain why that's useful)
13:30:49 <P4Titan> > [1, 2] <|> empty <|> [3, 4]
13:30:51 <lambdabot>  [1,2,3,4]
13:31:00 <Sindriava> P4Titan: and Alternative represents something that you can choose from
13:31:07 <P4Titan> maybe in that sense I see something
13:31:27 <Sindriava> P4Titan: Alternative isn't a THING, it's a WAY something behaves
13:31:27 <P4Titan> > Just 1 <|> Just 2 <|> Nothing
13:31:28 <lambdabot>  Just 1
13:31:54 <Sindriava> P4Titan: and list DOES behave that way, that's why it's instance of Alternative
13:31:55 <nkaretnikov> ReinH: hi, are you planning to release more episodes of the haskell cast?  there hasn't been any for a while
13:31:58 <P4Titan> Alternative behaves differently with Maybe and []
13:32:14 <Sindriava> P4Titan: No it doesn't, not in the sense of alternative
13:32:44 <Sindriava> P4Titan: It does something different, but in the same WAY, or with the same IDAE
13:32:45 <P4Titan> I would expect [1,2] <|> empty <|> [3, 4] to return the first non-empty thing, which is [1,2] as Maybe does
13:32:47 <Sindriava> *IDEA
13:33:03 <Sindriava> P4Titan: That's not what alternative does.
13:33:06 * hackagebot dump 0.1.0 - Dumps the names and values of expressions to ease debugging.  http://hackage.haskell.org/package/dump-0.1.0 (Wizek)
13:33:28 <P4Titan> I am sorry for making you get frustrated with me if you are.
13:33:33 <P4Titan> Its new stuff
13:33:36 <Sindriava> P4Titan: Nah, it's okay
13:33:43 <Sindriava> Haskell is weird shit when you first see it
13:33:47 <P4Titan> so what is the idea of alternative
13:34:01 <Sindriava> P4Titan: Alternative allows you to choose from multiple things. e.g. you have "Alternatives", hence the name
13:34:11 <Welkin> Alternative is very useful in parsing
13:34:21 <Sindriava> @type (<|>)
13:34:22 <lambdabot> Alternative f => f a -> f a -> f a
13:34:36 <Sindriava> P4Titan: You see, it has to preserve the type and the context.
13:35:03 <Sindriava> P4Titan: In other words, it takes two things of the same type and returns a thing of the same type
13:35:22 <Sindriava> P4Titan: Now in Maybe, you have "Maybe Int", so the result has to be "Maybe Int"
13:35:46 <naudiz> should I use ClassicPrelude or BasePrelude?
13:35:49 <Sindriava> P4Titan: And Alternative instance for Maybe tries to find a Just
13:35:53 <P4Titan> Ok, so if it chooses from multiple things as Just 1 <|> Just 3 <|> Nothing, it chooses Just 1. Why does [1, 2] <|> empty <|> [3, 4] choose everything?
13:36:12 <Sindriava> P4Titan: Because a list already represents a choice in a monadic sense.
13:36:15 <Welkin> P4Titan: that is how lists work
13:36:30 <indiagreen> P4Titan: maybe it'll be easier if you think of Maybe as of 0-or-1 list
13:36:42 <indiagreen> then it's logical that Just 1 <|> Just 3 <|> Nothing would return that
13:36:49 <Sindriava> P4Titan: List as a Monad behaves like a value, that you don't yet know, but you know what it can be
13:37:01 <indiagreen> it kinda *tries* to combine things, but Maybe just can't return more than 1
13:37:15 <geekosaur> and Maybe is biased in general to return first
13:37:44 <Sindriava> You want to return first, because you don't want to do more work than necessary
13:37:45 <Sindriava> like OR
13:37:50 <Sindriava> > True || undefined
13:37:51 <lambdabot>  True
13:38:12 <naudiz> P4Titan: maybe it helps to read <|> as "or" whereas [] is a list of elements linked by "or"s
13:38:15 <Sindriava> You see? You never try to evaluate the "undefined", because "True || A" is True regardless of A
13:38:15 <P4Titan> I kinda get this stuff. Since in a list, nothing is definite yet, you cant exit early
13:38:23 <geekosaur> it in fact used to be a thing that some functions were parameterized over Monad so you could select pick-first by using Maybe or pick-all by using lists
13:38:54 <indiagreen> geekosaur: hm, when? that sounds interesting
13:39:04 <P4Titan> yes
13:39:06 * indiagreen likes history of Haskell
13:39:11 <Sindriava> indiagreen++
13:39:29 <Sindriava> I like to call it "History of people using their heads to design a language"
13:39:39 <indiagreen> ah so
13:39:43 <indiagreen> Sindriava++
13:39:50 * Sindriava fades of into the distance rambling about C++
13:39:52 <hodapp> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Proxy.html - when I see something like Generic (Proxy * s), what does that mean?
13:40:04 <hodapp> particularly, the star.
13:40:18 <geekosaur> lemme dig up some old API docs
13:40:23 <P4Titan> How do those fancy messages about indiagreen likes history of Haskell appear?
13:40:27 <Sindriava> hodapp: Is that a type?
13:40:29 <cow_2001> does anyone know if stackage-sandbox is obsolete?
13:40:34 <indiagreen> P4Titan: “/me text”
13:40:41 * P4Titan Hello
13:40:55 <Sindriava> P4Titan: It's used to denote actions on IRC
13:41:02 * Sindriava shows P4Titan how to use "/me"
13:41:04 <P4Titan> So the sender writes ti
13:41:11 <Sindriava> Yup
13:41:25 <hodapp> Sindriava: See the link - it's under 'Instances' for data Proxy t
13:42:10 <Sindriava> hodapp: Now I'm just guessing, but I think it's to denote over what it's parametrized
13:42:33 <Sindriava> hodapp: Like you do instance Functor over * -> *
13:42:58 <hodapp> oh... it says Proxy is poly-kinded so perhaps that's a hint
13:43:04 <Sindriava> "instance Functor Maybe where" for example, because maybe needs one more thing to be a type (hence * -> *)
13:43:22 <indiagreen> Sindriava: actually, I would love love love a book detailing not only history of code, but also touching things like “who was pushing for what”, wars like pipes vs conduit, maybe even personalities / amusing facts about members of the community
13:43:30 <geekosaur> compare https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-Map-Lazy.html#v:lookup to https://downloads.haskell.org/~ghc/6.6.1/docs/html/libraries/base/Data-Map.html#v%3Alookup
13:43:44 <Sindriava> indiagreen Sign me up
13:44:09 * Sindriava finally really fades off into the distance, as his laptop battery drains a few last milliamps
13:44:14 <geekosaur> indiagreen, compare https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-Map-Lazy.html#v:lookup to https://downloads.haskell.org/~ghc/6.6.1/docs/html/libraries/base/Data-Map.html#v%3Alookup
13:44:20 <indiagreen> geekosaur: but here it's more like MonadFail, right?
13:44:35 <Sindriava> hodapp: http://stackoverflow.com/questions/22807728/what-does-the-star-mean-in-this-haskell-code
13:44:57 <P4Titan`> Ok, well I sort of get Alternative and that lists are non-deterministic, so one cannot exit on the first occurance. It is a slight quirk that makes the overall look like it is behaving differently, but deep down it is all unified by a single law. It is like special relativity in haskell.
13:45:08 <geekosaur> well, yes, that was the whole point
13:45:09 <P4Titan`> Thanks for your helps!
13:45:12 <hodapp> Sindriava: that doesn't really say anything about instances there
13:45:23 * indiagreen likes this old lookup
13:45:29 <indiagreen> when/why was it changed?
13:45:58 <geekosaur> ...but note that you don't *have* to do it via fail; it was done that way back then because neither Applicative nor Alternative existed back then
13:46:21 <joco42_> luite: what do you recommend reading/ compiling if I want learn about ghcjs's ffi ? for example if I want to write this http://jsfiddle.net/TroyAlford/ZZEk8/ in haskell ?
13:46:21 <Zemyla> Okay, question. Why don't the types in GHC.Generics implement things like Functor, Foldable, etc.?
13:46:49 <hodapp> so I guess it's saying that for any type 'Foo' that is parametrized over type 's', Proxy (Foo s) is an instance of Generic?
13:46:51 <hodapp> I don't know...
13:47:21 <geekosaur> hm, I vaguely recall the discussion on -cafe (this also predated the libraries list IIRC) but it was considered Monad "abuse" (compare your comment about fail!) and that the list instance wasn't really used much
13:47:42 <indiagreen> hm
13:47:57 <indiagreen> I'd think it'd be used more for IO and not for lists
13:48:17 <geekosaur> the decision might have gone differently if they'd had Applicative / Alternative around back then
13:49:10 <indiagreen> like, when I want to unwrap something in IO and I'm fine with crashing if it's not in the map, I can use lookup instead of lookup+fromJust or something
13:49:32 <geekosaur> but it wasn't itended for use that way and it wasn't used that way
13:49:43 <geekosaur> and in practice nobody used it with anything but Maybe
13:49:51 <indiagreen> okay, I see
13:49:52 <indiagreen> thanks
13:52:16 * indiagreen wants to ask “how did we lose isProperSubmapOf” and then finds out that it's still there
13:53:27 <joco42_> luite: which version of ghcjs can i compile these examples https://github.com/ghcjs/ghcjs-examples/tree/master/weblog ? will the current master https://github.com/ghcjs/ghcjs work ?
13:56:30 <cow_2001> with stackage's stack, how do i use a module located in a package that is not listed on hackage?
13:58:59 <jTT__> hi! I am wondering how to make this nicer: I want to split a text at “and” or “&” and came up with this solution. I guess that there is an alternative with fmap maybe, but im not sure how. 
13:59:00 <jTT__> map ( concat . map ( splitOn "and" ) . ( splitOn "&" ) ) 
14:00:38 <hodapp> wellll, I just solved a problem by using (Proxy :: Proxy (Proxy Foo)) instead of (Proxy :: Proxy Foo). Somehow I think I am not using this as-intended.
14:01:23 <jTT__> :t map ( ( concat . map ( splitOn "and" ) ) . ( splitOn "&" ) )
14:01:25 <lambdabot> [[Char]] -> [[[Char]]]
14:01:26 <hodapp> but the former is an instance of Generic, while the latter is not.
14:02:04 <hodapp> is there some other more kosher way to turn (Proxy s) into (Proxy * s)?
14:02:06 <rowanblush> jTT__: You could use concatMap instead of `concat . map`.
14:02:18 <rowanblush> :D
14:02:24 <c_wraith> hodapp: not really.
14:02:32 <jTT__> rowanblush: that’s defo a nice way :)
14:03:00 <hodapp> c_wraith: seems strange, but perhaps I did something right.
14:03:19 <hodapp> only 'cleaner' way I see 
14:03:30 <hodapp> ...is to do some sort of Proxy (Proxy ...) type synonym.
14:03:40 <c_wraith> hodapp: how did that situation even come about?
14:05:03 <hodapp> c_wraith: I have a list of configurations of some form for Shake, and I must call addOracle on some component of these configurations. addOracle requires a unique type for every invocation.
14:05:42 <hodapp> c_wraith: so I am using basically SomeSymbol to get that unique type, but I must make it derive from Show, Eq, Typeable, Hashable, NFData, Binary, Generic
14:06:41 <indiagreen> jTT__: this won't help you much, but I can say that there isn't a nicer way that uses the split library
14:06:52 <indiagreen> due to the way it's implemented
14:07:14 <jTT__> indiagreen: one less thing to look at then.
14:07:19 <hodapp> c_wraith: but, the only Generic instance that I seem to have at my disposable for a Proxy is not Generic (Proxy s), but Generic (Proxy * s).
14:07:36 <c_wraith> hodapp: Oh.
14:07:48 <c_wraith> hodapp: what version of ghc?
14:07:58 <hodapp> c_wraith: I'm looking at http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Proxy.html
14:08:18 <c_wraith> hodapp: I got a similar issue corrected in GHC head a while back, regarding the monoid instance
14:08:51 <hodapp> This is an issue? I figured it was intentional due to the nature of (blah blah type crap that hodapp doesn't grasp fully)
14:10:00 <c_wraith> hodapp: looks like a bug to me.  Instances should really be either on (Proxy *) like the Functor family, or (Proxy k s) like..  everything except Generic
14:10:12 <hodapp> c_wraith: huh
14:10:31 <hodapp> c_wraith: but if it's (Proxy k s) how does it change things for me?
14:10:44 <c_wraith> oh, the Data instance is also on (Proxy * t)
14:10:48 <friden> I'm trying to read content from a file using readFile, the problem is that the content is from the Swedish language, and contains characters like "åäö", but these gets interpreted as \229, \228, and \246. Is there any easy way to read them as Chars, or do I need to translate them manually in some way?
14:11:01 <c_wraith> Maybe that's intended somehow, as Data and Generic are for the same purpose (though they work differently)
14:11:09 <mauke> friden: ??? \229 is a char
14:11:13 <c_wraith> I guess I should look at the class definitions a bit better.
14:11:23 <mauke> > 'ö'
14:11:25 <lambdabot>  '\246'
14:11:31 <mauke> friden: and they're even the right chars
14:11:35 <friden> mauke: yeah, but when i print them with printStrLn, they show up as \246 xd
14:11:40 <mauke> friden: no, they don't
14:11:47 <mauke> also, what is printStrLn?
14:12:20 <friden> wait, ill confirm that it's not only sublime that is messing things up...
14:13:08 <friden> its printing \246 when run in ghci too
14:13:13 <Welkin> > chr 229
14:13:15 <lambdabot>  '\229'
14:13:30 <Welkin> > show $ chr 229
14:13:31 <lambdabot>  "'\\229'"
14:13:34 <Welkin> lol
14:13:55 <Welkin> > show $ chr 96
14:13:56 <lambdabot>  "'`'"
14:14:01 <ttt_fff> damn it, I want MS Excel with Haskell as the scripting language; someone create this :-)
14:14:04 <Welkin> chr 64
14:14:12 <Welkin> > chr 65
14:14:14 <lambdabot>  'A'
14:14:20 <mauke> friden: run what?
14:14:52 <mniip> ttt_fff, https://github.com/quchen/articles/blob/master/loeb-moeb.md#spreadsheets
14:15:08 <friden> when I run my program that reads swedish characters from a file and prints it using putStrLn
14:15:29 <friden> but it seems like lambdabot here can use it without problem, so i will check my program again
14:15:30 <Welkin> friden: nothing is wrong with it
14:15:36 <Welkin> it is reading the data properly
14:15:44 <Welkin> it just isn't displaying it how you like
14:15:48 <mniip> friden, did you forget to intersperse 'f'
14:16:01 <geekosaur> > text "\229"
14:16:03 <lambdabot>  å
14:16:04 <mauke> friden: show your code
14:16:22 <Welkin> :t text
14:16:23 <friden> kay, ill will simplyfy it and link a pastebin
14:16:23 <lambdabot> String -> Doc
14:16:34 <Welkin> nice function
14:16:49 <Welkin> @src Doc
14:16:49 <lambdabot> Source not found. :(
14:18:08 * hackagebot dump 0.1.1 - Dumps the names and values of expressions to ease debugging.  http://hackage.haskell.org/package/dump-0.1.1 (Wizek)
14:18:22 <geekosaur> http://hackage.haskell.org/package/pretty/docs/Text-PrettyPrint.html#t:Doc although I don't know which prettyprinter instantiation lb uses
14:19:05 <c_wraith> hodapp: I'm pretty sure both of those instances can be written for (Proxy k t) instead of (Proxy * t), and it's just a bug that they are more limited than that.
14:20:59 <c_wraith> hodapp: It's the kind of thing that should be thrown at the libraries@ mailing list.
14:21:11 <indiagreen> friden: if you use putStrLn, it should work. If you use print or show on the String before outputting it, well, that's another thing
14:21:40 <chreekat> Can ghc tell me about unused constraints?
14:22:56 <indiagreen> chreekat: at least 3yr ago it couldn't, and I haven't heard of it being implemented
14:23:26 <chreekat> indiagreen: Didn't think so. Is that just a "nobody has gotten around to it yet" thing, or is there a tradeoff?
14:23:51 <friden> indiagreen: im using show on a data structure containing two strings, may that be the issue?
14:24:00 <indiagreen> friden: yes
14:24:25 <c_wraith> chreekat: it certainly can be detected, in theory...  Maybe until advanced extensions come into play.
14:25:32 <friden> indiagreen: interesting, can I read about this somewhere? or what is the problem?^^
14:26:16 <indiagreen> whoa
14:26:20 <indiagreen> https://mail.haskell.org/pipermail/ghc-devs/2015-January/007892.html
14:26:25 <cow_2001> argh how do i compile this thing
14:26:48 <indiagreen> so warn-redundant-constraints was implemented at some point
14:28:08 <lpaste_> Peaker pasted “Formula for this?” at http://lpaste.net/136829
14:28:26 <chreekat> indiagreen: sweet!
14:28:50 <Peaker> Seems like a formula for this ought to be trivial but I am missing it :)
14:29:19 <indiagreen> but it doesn't work for me on 7.1
14:29:23 <int-e> Peaker: don't you see the Pascal triangle? (binomial coefficients...)
14:29:23 <indiagreen> 7.10
14:29:58 <Peaker> int-e: I see the relationship to Pascal's triangle, but I didn't remember it had a formula :)
14:29:58 <chreekat> indiagreen: yeah, the message is from just six months ago, so that makes sense
14:30:23 <indiagreen> but 7.10 was released in March
14:30:44 <geekosaur> doesn't mean it got accepted
14:30:54 <geekosaur> I think 7.10 was already slushy by then
14:31:06 <Peaker> int-e: I'm solving a riddle "how many interleavings are there for list of length a and list of length b" :)
14:31:09 <indiagreen> okay, hopefully it'll be in 7.12
14:31:21 <geekosaur> (i.e. anything that might change the API would not be actively considered)
14:31:49 <int-e> Peaker: so you choose a elements of a+b elements.
14:32:11 <indiagreen> friden: the problem is that whenever you see your string in ""-quotes, you also will see characters in it escaped
14:32:23 <indiagreen> this includes all Show-ing
14:32:56 <chreekat> indiagreen: oh, sorry, didn't understand your typo at first. yes, hopefully 7.12
14:33:17 <indiagreen> so if you use show to display your data, there's nothing you can do apart from wrapping things in a newtype which would have a different show implementation
14:33:21 <Peaker> int-e: but the order inside each list matters
14:33:25 <int-e> > take 6 $ iterate (scanl1 (+)) [1,1,1,1,1,1]
14:33:27 <lambdabot>  [[1,1,1,1,1,1],[1,2,3,4,5,6],[1,3,6,10,15,21],[1,4,10,20,35,56],[1,5,15,35,7...
14:33:27 <indiagreen> you can, of course, just not use show for display
14:33:40 <friden> indiagreen: oh, i see what you mean now. Can i get around that behaviour if i were to implement show myself for that datatype instead of deriving it?
14:34:16 <int-e> Peaker: you can pick the slots where the first sequence goes, then fill them in order
14:35:06 <mniip> > map (take 6) $ iterate (scanl1 (+)) $ repeat 1
14:35:08 <lambdabot>  [[1,1,1,1,1,1],[1,2,3,4,5,6],[1,3,6,10,15,21],[1,4,10,20,35,56],[1,5,15,35,7...
14:35:10 <indiagreen> friden: I would consider it a tiny bit dirty, but yep, you can
14:35:13 <Peaker> int-e: ah, indeed, I missed that :)
14:35:21 <Peaker> int-e: simpler than I thought
14:35:53 <friden> indiagreen: what is the alternatives? creating a function for showing the data type?
14:36:07 <friden> *printing
14:36:11 <int-e> Peaker: it should get more interesting (actually I don't have a solution) if the two sequences have elements in common.
14:39:53 <indiagreen> friden: if you are outputting it for your users, you shouldn't use show in the 1st place because “how it would look in Haskell code” isn't the best way to present data to your users (and then you should write a printing function). If you use read/show to store data or transmit it or something, this wouldn't matter to you at all (and then you should do nothing). Finally, if you're using show for debugging/etc, then I guess it's
14:39:53 <indiagreen> alright to write a custom instance of Show
14:40:58 <int-e> Peaker: For example, interleaving [1,2] with [1,2] gives only two possibilities, 1122 and 1212, instead of 6 for interleaving [1,1] and [2,2].
14:41:02 <indiagreen> I'm still wary of doing it in e.g. a library, but that might only be because of the fear of being different
14:41:28 <friden> indiagreen: im writing an ai that eventually will communicate to its users via a irc framework, so right now its just for debugging purposes
14:41:43 <Peaker> int-e: Yeah, I understand
14:42:05 <Peaker> int-e: It sounds like the solution would be more tedious than elegant
14:42:06 <friden> i just wanted to learn what the problem was, and the best way to "solve" it. thanks for your help^^
14:42:31 <Wizek__> Good Morning!
14:43:19 <Wizek__> Could it be that `cabal sdist && cabal upload` only uploads source files to hackage but not haddock documentation ?
14:43:28 <indiagreen> it's exactly the case
14:43:43 <indiagreen> if you want to upload the docs, use neil
14:43:47 <catgocat> I am using interact, and trying to uppercase an input string and shout it to the terminal with the prefix `Your data in uppercase is:`. However, the prefix only works the first time I type something. After that, the uppercase function keeps working, but the (++) operator doesn't.
14:43:47 <indiagreen> @hackage neil
14:43:47 <lambdabot> http://hackage.haskell.org/package/neil
14:43:51 <lpaste_> catgocat pasted “here” at http://lpaste.net/136830
14:44:01 <catgocat> ^^^^
14:44:27 <indiagreen> in particular, you'll have to do “neil docs --user YourHackageUsername”
14:44:37 <mniip> catgocat, interact is called on the entire input
14:44:40 <mniip> not line-wise
14:44:42 <Wizek__> indiagreen, use him? https://www.google.com/search?q=neil+haskell :D
14:45:06 <mniip> s/is called/works/
14:45:10 <indiagreen> no, the package I asked lambdabot to link
14:45:11 <catgocat> So it's evaluated lazily?
14:45:19 <mniip> yeah it uses nasty lazy IO
14:45:28 <catgocat> Ok thanks
14:45:29 <glguy> Just normal lazy IO
14:45:29 <indiagreen> @hackage neil -- ^ Wizek__ 
14:45:29 <lambdabot> http://hackage.haskell.org/package/neil -- ^ Wizek__
14:45:50 <indiagreen> well, or maybe you were just kidding
14:45:55 <indiagreen> then I shall be embarrassed
14:46:43 <Wizek__> indiagreen, I saw that, but before I did I tried to google for neil, and that's what came back, so I was attempting humor.
14:46:58 <Wizek__> checking it out atm
14:47:29 <int-e> Peaker: But there must be some nice special cases. For example, for interleaving [1..n] with [n,n-1..1], the answer will be C(2n,n)/2, because the only ambiguity comes from the pair of equal elements that such an interleaving necessarily contains.
14:48:09 * hackagebot lambdacms-core 0.3.0.0 - LambdaCms Core subsite for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.3.0.0 (cies)
14:48:12 <int-e> Peaker: (I'm looking at pairs of successive elements in the list.)
14:49:40 <Peaker> int-e: I think the riddle comes from an engineering problem where the lists contain unique elements
14:49:53 <Peaker> (and the engineering benefit was part of the allure for me :-) )
14:51:09 <fishburne> what does it mean to have a kind of [*] ?
14:52:19 <glguy> Proxy :: Proxy (Bool ': Integer ': '[])
14:52:25 <glguy> It's a list of types
14:52:53 <glguy> Where instead of being a value-level list it's a type-level one
14:53:53 <glguy> In that example the Proxy type constructor is instantiated at type: [*] -> *
14:54:00 <glguy> err, at kind
14:55:14 <fishburne> glguy: oh..I see. Do you know somewhere I can read more about this?
14:55:44 <glguy> You can start here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
14:56:14 <glguy> There's a link to a paper there and an explanation of how it works in GHC
14:57:19 <fishburne> glguy: Thanks!
14:58:09 * hackagebot lambdacms-media 0.3.0.1 - LambdaCms "media" extension  http://hackage.haskell.org/package/lambdacms-media-0.3.0.1 (cies)
15:03:31 <Wizek__> indiagreen, it worked, thanks! Is most everyone who posts packages to hackage uses neil or uploads manually?
15:04:21 <Clint> Wizek__: i use cabal upload
15:04:36 <Wizek__> Clint, even for docs?
15:04:43 <glguy> Wizek__: There are a number of ways to upload docs to hackage. I wrote/use https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh (it's not lens specific) presumably some people use neil
15:04:44 <Peaker> criterion is giving me wildly unstable results across different runs over the same code :(
15:04:48 <glguy> there are other scripts floating around
15:05:04 <indiagreen> Wizek__: based on a not-really-representative sample of http://hackage.haskell.org/packages/recent, most people don't bother at all
15:05:10 <indiagreen> “Hackage will build it eventually”
15:05:32 <Clint> Wizek__: oh, no, not docs
15:06:19 <Wizek__> oh, I see, that makes sense. So maybe I can also just wait when I have the next release and haddock will add docks automatically
15:06:19 <Sindriava> Is there an elegant way to fold multidimensional structures?
15:06:40 <Sindriava> Only sane thing I've come up is writing my own `fold2d :: ([a] -> a) -> ([a] -> a) -> [[a]] -> a`
15:06:50 <indiagreen> the Hackage way is also better sometimes because if you don't have docs installed for all libraries you're using, they won't be autolinked
15:07:10 <indiagreen> well, this is irrelevant for most people because docs-building is turned on by default
15:07:21 <Wizek__> I see
15:07:28 <indiagreen> but I have turned it off for speed and some others probably have as well
15:07:34 <Wizek__> Sindriava, Perhaps fold into 1d, then fold over that?
15:08:00 <Wizek__> indiagreen, speed?
15:08:12 <Sindriava> Wizek__: That's basically what I'm doing, with fold2d f g = f . fmap g
15:08:13 <indiagreen> speed of cabal install, of course
15:08:31 <Sindriava> Wizek__: But that's only 2d, I was wondering if there's something shiny :D
15:09:18 <indiagreen> Sindriava: lens! 
15:10:21 <indiagreen> no, or maybe not lens
15:10:36 <Sindriava> indiagreen: I don't think lens are suited for folding
15:10:54 <c_wraith> Sindriava: Control.Lens.Fold, maybe?
15:11:09 <Sindriava> What I want is a function that "given N folders, folds an N dimensional structure into a single value"
15:11:12 <c_wraith> Sindriava: (lenses actually are quite well-suited for folding)
15:11:34 <Sindriava> c_wraith: Interedaradasting! I'll check that out, thanks"
15:11:48 <Peaker> if I have code like:  data Foo = Foo Bar Baz ; {-# INLINE f #-} f :: Foo -> Res ; ... ; f (Foo .. ..)   will GHC be smart enough to remove the "Foo" intermediate altogether?
15:12:08 <c_wraith> Peaker: often, but I don't know if I'd count on it.
15:12:26 <Peaker> c_wraith: I refactored a bunch of params to a nicer record
15:12:55 <Peaker> c_wraith: And I also use some (inlined) conversion on that record before passing it into another function
15:13:53 <Sindriava> c_wraith: A rather canonical example for my problem would be showing a matrix
15:14:13 <c_wraith> :t foldMapOf
15:14:14 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
15:14:32 <Sindriava> heheh
15:14:46 <c_wraith> > foldMapOf (traverse . traverse) show [[1,2,3],[4,5,6]]
15:14:47 <lambdabot>  "123456"
15:15:05 <c_wraith> I mean..  That's not quite what you want.
15:15:09 <Sindriava> c_wraith: Well, you cant just flatten it then
15:15:10 <Peaker> Well, it does seem the new INLINE annotations got rid of the performance regression
15:15:24 <Sindriava> c_wraith: Yeah, you want to newline the two arrays, which needs 2 folder functions
15:15:30 <c_wraith> Sindriava: the flattening was mostly the result of using foldMap
15:15:39 <Peaker> Does having polymorphic types inside newtypes only count as having RankNTypes?
15:15:44 <c_wraith> Peaker: yes
15:16:02 <Peaker> cool, then Lamdu now has RankNTypes (not well tested enough to know it's not buggy though :) )
15:16:07 <shachaf> GHC calls that PolymorphicComponents. But these days it's the same as Rank2Types and RankNTypes.
15:16:21 <Peaker> shachaf: PC lets you put forall on any record field type
15:16:30 <c_wraith> Peaker: It's awkward to use, but it can do everything you can get out of ImpredicativeTypes, even.
15:16:38 <shachaf> PC?
15:16:44 <Peaker> shachaf: PolymorphicComponents
15:16:51 <Peaker> c_wraith: Yeah, I know it's equivalent in power, I was just wondering if I can use the "marketing term" and not lie :)
15:17:00 <c_wraith> Peaker: I'd call it a lie. :P
15:17:03 <shachaf> Peaker: Oh, specifically on newtypes. OK.
15:17:06 <Peaker> c_wraith: heh, why?
15:17:16 <c_wraith> Peaker: because I want the nice syntax. :)
15:17:39 <Peaker> shachaf: in Lamdu we use a structural type system (allowing anonymous row-typed/column-typed products/sums) but also have nominal types that allow isorecursive types and "foralls"
15:17:59 <Peaker> Sticking "forall" support in our nominal type wrappers seemed like the easiest way to get the power of RankNTypes
15:18:08 <Peaker> (without complicating type inference much)
15:18:15 <c_wraith> Peaker: also, because it is a sort of cheat at the type level - you're not passing around values with polymorphic types, you're passing around monomorphically-typed values that encapsulate them..
15:18:25 <c_wraith> Peaker: which is why it's so much easier to implement. :)
15:18:32 <Peaker> c_wraith: having implemented it, I know! :)
15:19:19 <Peaker> c_wraith: re-nice syntax, Lamdu is all about a smart UI for code editing, so nominal type wrappers/unwrappers don't have to pollute your actual syntax (AST presentation on screen & key inputs to edit) much
15:19:54 <Peaker> We're not settled on exactly how nominal types (IOW: newtypes) should look like and behave, but we think that most of them should be quite transparent in the UI
15:20:33 <c_wraith> Peaker: That's really helpful actually, but I think that if the forall doesn't appear in the type signature, it's a bit of a lie to say it's higher-rank or impredicative types.
15:20:45 <c_wraith> Peaker: Not saying it's not a great feature to have. :)
15:22:44 <mauris> hm, where would be a good place/article/paper to start learning about the inner workings of ghc (or compiling functional languages in general)?
15:22:45 <Peaker> c_wraith: I think Rank1 is enough for most of my programming needs, and in the relatively rare occasions I reach for RankN I think it's OK if it's just a bit awkward (if it simplifies the Rank1 experience)
15:23:03 <indiagreen> Sindriava: to be honest, I think making your fold2d an operator would be better here
15:23:14 <indiagreen> @let f ./ g = f . fmap g; infixr 8 ./
15:23:15 <lambdabot>  Defined.
15:23:29 <indiagreen> unlines./unwords./show $ [[1,2,3],[4,5,6]]
15:23:36 <indiagreen> > unlines./unwords./show $ [[1,2,3],[4,5,6]]
15:23:37 <lambdabot>  "1 2 3\n4 5 6\n"
15:23:45 <Sindriava> indiagreen: …
15:23:55 <Sindriava> indiagreen: Fuck me sideways, that's actually pretty damn sweet
15:24:17 <indiagreen> just don't give it a restrictive type
15:24:30 <Sindriava> Yeah, I'll use functors instead
15:25:26 <Sindriava> thanks, that's really smart!
15:25:41 <Sindriava> indiagreen: On a related note, how do I decide on the fixity of my operators?
15:25:53 <Sindriava> primarily the precedence
15:26:03 <Sindriava> is there a 'golden rule'
15:26:05 <Sindriava> ?
15:26:07 <mauris> > unlines./unwords./show./sum $ [[[1,10],[2,20],[3,30]],[[4,40],[5,50],[6,60]]]
15:26:09 <lambdabot>      No instance for (Show b0) arising from a use of ‘show’
15:26:09 <lambdabot>      The type variable ‘b0’ is ambiguous
15:26:09 <lambdabot>      Note: there are several potential instances:
15:26:35 <mauris> ok, that didn't work the way i expected it to! it's late at night.
15:26:49 <indiagreen> mauris: replace the last ./ with .
15:27:04 <mauris> Sindriava: basically i guess you would expand (a*b)*c and a*(b*c) and then decide which of those you want a*b*c to mean
15:27:11 <indiagreen> Sindriava: no idea, I used 8 because . is 9 and I wanted mauris's case to work
15:27:32 <indiagreen> and I used right fixity to make several ./s in a row work
15:28:03 <Sindriava> indiagreen: Fair enough
15:28:10 <Sindriava> Still, this is really clever, thanks ^^
15:34:17 <Sindriava> Here's a paste of the final product, it might come in handy to someone http://lpaste.net/136831
15:34:33 <Sindriava> Related note, is there a good OSX application for saving code snippets?
15:34:53 <Welkin> just put it on github
15:35:00 <Welkin> or some other online repo
15:35:36 <Welkin> https://gist.github.com/
15:36:39 * indiagreen goes to sleep
15:37:22 <cow_2001> :(
15:37:27 * mniip wonders where jle` is
15:44:46 <Sindriava> Welkin: Fair enough
15:45:55 <lpaste_> cgroza pasted “monads” at http://lpaste.net/136832
15:47:21 <cgroza> hi, is there a way to evaluate a monad, perform another monad for side effects and return the value of the first monad without the do notation?
15:47:39 <cgroza> example at http://lpaste.net/136832
15:48:18 <glguy> cgroza: use (<*)
15:48:23 <geekosaur> a Monad is (or, for older ghc versions, should bve) an Applicative, so <* should work
15:48:38 <cgroza> glguy: geekosaur: i will look into it, thank you
15:49:36 <Welkin> <* is just sequence with the parameters swapped
15:49:37 <Welkin>  :D
15:49:51 <Welkin> (>>)
15:50:07 <glguy> kind of, it preseves the order of the "sequencing"
15:50:26 <glguy> while simply flipping (>>) wouldn't
16:13:12 * hackagebot dump 0.1.2 - Dumps the names and values of expressions to ease debugging.  http://hackage.haskell.org/package/dump-0.1.2 (Wizek)
16:15:14 <jle`> mniip: hi :)
16:16:23 <mniip> jle`, so while figuring out the inverted type families idea I accidentally created a blog
16:16:43 <Welkin> mniip: you accidentaly made a baby
16:16:54 <mniip> because I realized I have to serialize my ideas somewhere :P
16:16:58 <jle`> mniip: nice
16:17:04 <jle`> that's how all good blogs are formed :)
16:17:06 <jle`> not all
16:17:09 <jle`> maybe i should say
16:17:12 <mniip> jle`, http://mniip.com/pages/BidirectionalTypeFamilyInference
16:17:13 <jle`> that's how some good blogs are formed :)
16:17:19 <jle`> that's how many?
16:17:25 <zachk> so I just started using lens from Control.Lens and I am doing something like : worldState ^. rooms . (0,0,0) which returns a room object in a Just, but I want to do something more sort of like : worldState ^. rooms . at (0,0,0) . fmap roomTitle (I know that is incorrect, how do I do it?)
16:18:02 <mniip> zachk, over?
16:18:19 <mniip> :t over
16:18:20 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:18:22 <jle`> mniip: thanks :) i'll look it over.  it turns out i was sort of looking at things from the wrong angle anyways, but this will likely come in handy anyway
16:18:33 <nocturne777> jle`: I am trying to install a local package into my sandbox. I am doing  "cabal sandbox add-source /my/patched/library"
16:18:46 <nocturne777> do I still need to mention the package name in build-depends section
16:18:53 <jle`> zachk: you can turn any (a -> b) into a Getter so you can compose it with other lenses, using `to`
16:19:07 <jle`> so you can chain `to roomTitle` in the middle of your lens chain
16:19:12 <jle`> s/middle/end
16:19:18 <nocturne777> when I do that, it tries to download the package
16:19:30 <jle`> nocturne777: you might need to deregister it
16:19:35 <jle`> from the package registry
16:19:38 <jle`> if you already had it installed
16:19:54 <jle`> but by the way, cabal sandboxes don't care about cabal packages/cabal files
16:20:00 <jle`> they're per-directory, not per-project
16:20:18 <jle`> so you can just `cabal install my-lib` and it'll install it from the source you gave it, too
16:20:26 <jle`> if it's in build-depends then it'll install it from there as well
16:20:37 <nocturne777> I removed it from build-depends
16:20:51 <nocturne777> is build-depends only for downloading ?
16:21:11 <jle`> build-depends is for what the cabal project depends on
16:21:21 <jle`> but cabal projects are independent of cabal sandboxes
16:21:43 <jle`> if you cabal install a project, then in the process of installing the project, it'll install everything in the project's build-depends
16:22:02 <jle`> but you can also install whatever packages you want as well
16:22:10 <nocturne777> I am just trying to install a local package into my sandbox
16:22:24 <jle`> yeah, you can just do `cabal install the-package`
16:24:13 <nocturne777> jle`: when I add the local package as a source, does it not become part of the installation process automatically?
16:24:22 <zachk> errr... so how I compose a lens I already have over Just SomeRecord? 
16:24:59 <rasen> Hey, guys! That's maybe a stupid question but... When selecting workshops on ICFP registration there are seperate choices for AM/PM. Is that ok to select the same workshop for both AM and PM? I mean isn't that a repeat of the same talks?
16:25:12 <jle`> nocturne777: it depends on what you are installing
16:25:28 <jle`> if you're installing the local package itself, then yes, it'll install from the local directory
16:25:52 <jle`> if you're installing a cabal project, then if that project depends on that package, then it'll install it from the local directory
16:26:04 <jle`> if you're installing a cabal project that doesn't need that local package, then it won't be installed
16:27:05 <jle`> just like if you're installing a cabal project that doesn't require acme-php package, then it won't install acme-php :)
16:27:12 <srhb> zachk: More details?
16:27:20 <jle`> zachk: so you're composing two lenses right now -- rooms and at (0,0,0)
16:27:37 <jle`> you can compose one more, (to roomTitle)
16:27:49 <jle`> so you can do worldState ^. rooms . at (0,0,0) . to roomTitle
16:28:02 <srhb> Oh, I didn't see the first message. Sorry.
16:28:02 <zachk> tried it in ghci, it barfed some error message
16:28:32 <jle`> oh i see, at is a lens with a Maybe
16:28:34 <jle`> that's weird
16:28:48 <zachk> Couldn't match type ‘String -> f String’ is the error
16:28:48 <jle`> sorry, haven't seen it before
16:29:03 <jle`> maybe you can do `to (fmap roomTitle)`
16:29:38 <jle`> or you can just ditch the operator and do it in a less insane and more readable way heh
16:29:46 <zachk> I have a monolithic state record for everything in a game, and each record field is a Data.Map or Data.IntMap and `at` works over those fine, but then the value I get out is Just SomeRecord or Nothing, yea i'll try it 
16:29:53 * zachk likes insane ways.
16:30:17 <jle`> roomTitle . (view (rooms . at (0,0,0)) $ worldState
16:30:17 <srhb> I don't think it's insane, in fact I think it's very in line with the Lens ideology. :)
16:30:29 <zachk> I can just fmap (view lens) $ theOtherSTuff here 
16:30:38 <jle`> um there's an extra parentheses
16:30:47 <jle`> fmap roomTitle (view (rooms . at (0,0,0))) worldState
16:30:53 <jle`> er
16:30:57 <jle`> fmap roomTitle (view (rooms . at (0,0,0)) worldState)
16:31:16 <zachk> well it's fmap (view rooms) that might work though...
16:31:37 <jle`> if it works and is nice, then use it :)
16:32:08 <zachk> kind of want that strange lensy composotion for readability, its gonna be a lot of code eventually going through the monolithic state
16:33:00 <jle`> then you can do worldState ^. rooms . at (0,0,0) . to (fmap roomTitle)      -- but maybe there's a synonym for (to . fmap) that is obvious and i can't see, heh
16:33:01 <glguy> In this case: preview (rooms . ix (0,0,0) . to roomTitle)
16:33:28 <jle`> oh yeah, ix is a Prism
16:33:33 <zachk> the to (fmap roomTitle) doesn't seem to work 
16:33:40 <glguy> and there's a way to go for trailing to's
16:33:51 <glguy> previews (rooms . ix(0,0,0)) roomTitle
16:34:46 <glguy> zachk: ^
16:35:26 <glguy> jle`: ix is a Traversal and is being used as a Fold here, but it's not a Prism
16:35:41 <jle`> oh, that makes sense.  thanks for correcting :)
16:37:10 <zachk> still not working, it seems...
16:37:29 <glguy> You'll have to show some code, then, because that's how you'd do it
16:39:25 <zachk> glguy: error : Couldn't match type ‘RoomObject’ with ‘String -> f String’
16:39:52 <glguy> ?paste
16:39:52 <lambdabot> Haskell pastebin: http://lpaste.net/
16:39:59 <zachk> aight one minute.
16:40:31 <glguy> is roomTitle a Lens?
16:42:08 <zachk> http://lpaste.net/136839
16:42:25 <zachk> yes roomTitle is an autogenerated lens using TemplateHaskell 
16:42:26 <nocturne777> jle`: for some reason it is not installing for me
16:42:30 <glguy> ok, then:   preview (rooms . ix(0,0,0) . roomTitle)
16:43:21 <ttt_fff> if I master lens, will my haskell code look like APL / Perl ?
16:43:39 <glguy> No, you don't have to use all the operators to master lens
16:43:40 <jle`> nocturne777: are you typing "cabal install packagename" ?
16:44:08 <zachk> thank you 
16:44:11 <zachk> :D
16:44:15 <glguy> zachk: The way to do it like you were trying originally is:
16:44:17 <glguy> view (rooms 07. at (040,040,040) 07. traversed 07. roomTitle)
16:44:29 <glguy> rather than "fmap roomTitle"
16:47:33 <zacts> yes?
16:47:35 <zacts> oh zachk
16:47:42 <zacts> o_O
16:48:15 <zachk> is there a way using the (.) to get it return the Maybe so I can error handle on it, right now if it doesn't find something it's just "" for String fields, and I might have an empty string in a field and not have it be an error
16:49:23 <glguy> use preview
16:49:35 <zachk> oh preview... durrr.. is there a shorthand for preview like ^. for view? 
16:49:42 <arkeet> ^?
16:50:18 <arkeet> > "abc" ^? ix 0
16:50:20 <lambdabot>  Just 'a'
16:50:30 <zachk> oh wow
16:51:45 <nocturne777> jle`: when I do that it is still trying to download it from hackage
16:52:18 <jle`> hm, is the directory name the same as the library name?
16:52:24 <jle`> what happens when you start over with a new sandbox?
16:53:07 <nocturne777> jle`: makes no difference when I do "cabal clean; ..." either
16:53:18 <augur> edwardk: if you're around, i finally wrote up that chart parser as a proper blog post
16:53:28 <nocturne777> jle`: the directory name is the same as the library name
16:53:53 <jle`> hm, same when you rm the sandbox?
16:53:54 <nocturne777> I modified a library I downloaded 
16:53:56 <jle`> then i don't know, sorry :|
16:54:02 <jle`> what library is it?
16:54:22 <nocturne777> jle`: https://github.com/ixmatus/snaplet-hslogger
16:54:35 <jle`> ah, so not a built-in package with ghc
16:54:50 <jle`> hm
16:55:05 <nocturne777> it is also available on hackage
16:55:08 <jle`> sorry, i am not really knowledgeable enough to help here :(
16:55:58 <Welkin> nocturne777: what is the problem?
16:56:08 <Welkin> if you have the source for the library
16:56:16 <Welkin> just add it as a source to your sandbox
16:56:25 <Welkin> cabal sandbox add-source /path/to/package
16:56:33 <Welkin> and then add it as a dependency in your .cabal
16:56:51 <nocturne777> Welkin: that did not work either
16:57:04 <Welkin> cabal install --only-dependencies
16:57:24 <nocturne777> Welkin: you mean to add in build-depends section, correct?
16:58:50 <Welkin> yes
17:01:53 <nocturne777> Welkin: it is still trying to get it from the hackage
17:03:11 <Welkin> that is strange
17:03:16 <Welkin> try this
17:03:17 <Welkin> cabal sandbox add-source /path/to/package --snapshot
17:03:34 <Welkin> you should also try to delete the sadnbox and start fresh
17:03:47 <Welkin> cabal sandbox delete
17:06:14 <jle`> maybe it's an issue of absolute vs relative paths?
17:07:40 <Welkin> I always give an absolute path
17:09:20 <zachk> how would I set a value, if the composed getters and head object(?) is worldState ^? creautures . ix 1 . creatureTitle ? 
17:20:02 <emmanuel_erc> hello there everyone!
17:20:09 <zachk> hiya emmanuel_erc 
17:20:13 <emmanuel_erc> Have any of you installed structured haskell mode
17:20:26 <emmanuel_erc> in emacs that is...
17:20:35 <emmanuel_erc> (I know this is a really basic question)
17:21:49 <rom1504> likely
17:23:32 <Cale> emmanuel_erc: I did it briefly before discovering that it was way too awkward for me to use. :)
17:23:44 <jle`> zachk: you can't set or change a value with a getter, but if everything in your chain is at least a Setter/Lens/Traversal etc., you can use `set` or (.~)
17:24:11 <emmanuel_erc> Cale: What didn't you like about it?
17:24:40 <Cale> emmanuel_erc: Just found the keys unnatural
17:24:54 <Cale> I'm too used to pressing enter, for instance
17:25:00 <Cale> and it doesn't want you to ever do that
17:28:37 <emmanuel_erc> Cale: I see
17:28:52 <jle`> just got the weirdest and craziest type-level gadt trick datakinds project/proof of concept i've ever tried to work
17:28:54 <jle`> haskell is weird
17:29:28 <mniip> jle`, :o
17:29:49 <jle`> mniip: ended up not needing any type familiesor mptc's
17:29:53 <jle`> all datakinds and gadts
17:30:03 <zachk> jle`: what if it in a Maybe, like before and I have to use preview or ^? 
17:30:07 <mniip> I did a weird type thing trick recently too
17:30:08 <jle`> actaully no datakinds either
17:30:22 <mniip> Implemented a SSE GADT
17:31:08 <jle`> nice :0
17:31:15 <mniip> primops right next to type families
17:31:15 <mniip> fun
17:31:27 <mniip> oh yeah all of this spiced with template haskell
17:31:30 <mniip> to avoid repetition
17:33:02 <mniip> jle`, just show your type-level gadt trick datakinds project/proof of concept already
17:33:30 <jle`> i'm not sure it's in a readable state haha
17:33:38 <Welkin> mniip: but he derives great pleasure from teasing us!
17:34:23 <mniip> jle`, can't be worse than mine
17:34:42 <jle`> but it's the extension of the AST thing that every haskell 101 course does with an adt representing ints, simple functions, reified lambdas, function application/substitution
17:35:04 <jle`> but the lambdas are typechecked to only have variables in scoped and that are the wrong type
17:35:12 <mniip> jle`, http://lpaste.net/1713249131385847808
17:35:29 <jle`> so (\x -> x + 4) typechecks but (\x -> x + y) doesn't, but (\y -> (\x -> x + y)) does
17:35:46 <jle`> and only of the types match
17:35:52 <jle`> beautiful, mniip 
17:36:33 <jle`> and yeah at the top level you can only evaluate expressions with no free variables
17:36:58 <mniip> jle`, but hey check this out
17:37:04 <mniip>  :t packVector (1, 2, 3, 4 :: Float)
17:37:05 <mniip> Vector 4 Float
17:38:08 <jle`> that's p sweet :o
17:38:11 <jle`> sweet p
17:38:31 <mniip> where data Vector (n :: Nat) e where ... VecFloatX4# :: FloatX4# -> Vector 4 Float ...
17:40:29 <mniip> jle`, there are some caveats though
17:41:10 <mniip>  > packVector (1 :: Int64, 2, 3, 4)
17:41:10 <mniip> Illegal instruction
17:41:27 <jle`> such illegal
17:41:51 <jle`> oops i found a bug in mine
17:43:39 <mniip> what do I do now \o/
17:43:40 <mniip> so bored
17:44:48 <nocturne777> cabal spits out this and I don't get this : trying: lens-4.12.1 (dependency of foobar-0.1)
17:45:09 <nocturne777> nowhere in the cabal file am I specifying anything above lens 4.11
17:45:32 <nocturne777> foobar is the name of my project
17:45:36 <geekosaur> but do you depend on something else that might pull it in?
17:46:20 <geekosaur> also try installing the right version of lens manually if it isn't already, then: cabal configure --constraint="lens installed" 
17:46:42 <geekosaur> (or cabal install if that's what you'ree doing)
17:48:16 * hackagebot persist2er 0.1.0.0 - Transforms persist's quasi-quoted syntax into ER format  http://hackage.haskell.org/package/persist2er-0.1.0.0 (fgaray)
17:49:49 <nocturne777> geekosaur: this is the first line of the error message and it is complaining about it as the requirement of the application. It does not indicate what depends on lens-4.12.1
17:49:55 <nocturne777> that I find very annoying
17:50:19 <nocturne777> this is occured when I deleted the sandbox 
17:50:28 <geekosaur> you generally need to crank up the detail output to get that, sadly
17:53:16 * hackagebot persist2er 0.1.0.1 - Transforms persist's quasi-quoted syntax into ER format  http://hackage.haskell.org/package/persist2er-0.1.0.1 (fgaray)
18:07:16 <nocturne777> geekosaur: are you talking about the versbosity of cabal?
18:07:22 <geekosaur> yes
18:08:14 <nocturne777> I added the -v option
18:08:19 <nocturne777> which was not very helpful again
18:08:22 <lpaste_> nocturne777 pasted “dependencies not resolved” at http://lpaste.net/136841
18:08:43 <nocturne777> geekosaur: that is the output
18:09:36 <geekosaur> I think you need -v3... and put it after the command verb, otherwise it means print the version
18:09:51 <geekosaur> e.g. cabal install -v3 ...
18:10:41 <geekosaur> life-goals3 is your package?
18:10:49 <geekosaur> how did you specify the lens dependency?
18:11:03 <azsx_> if you were to create a compiler, how would you go about creating something like CONST or FINAL for variables?
18:11:19 <WashIrving> Do you know of any useful resources for building intuition for the fixed point datatype? I.e. 'data Fix f = Fix { unFix :: f (Fix f) }'. I've witnessed the correspondence between some simple ASTs and the fixed point of their pattern functors, but clarity isn't coming.
18:12:06 <mniip> WashIrving, edwardk is a useful resource
18:15:09 <nocturne777> geekosaur: currently I am going through that huge output, figuring it out slowly. 
18:18:23 <WashIrving> mniip: Any repositories worth diving into, or just wait for him to catch that highlight?
18:18:27 <lpaste_> geekosaur pasted “dependencies” at http://lpaste.net/136842
18:18:39 <geekosaur> o.O
18:18:54 <geekosaur> supposed to put your username there, not mine
18:19:01 <nocturne777> sorry, I goofed up
18:19:26 <mniip> WashIrving, https://wiki.haskell.org/Catamorphisms
18:20:14 <WashIrving> mniip: Thank you, that's yielded a new keyword ('Mu'), and may yield more still.
18:21:22 <mniip> WashIrving, there's Mu and Nu fixpoints, and in Hask they are the same type
18:21:53 <geekosaur> hm. the meaning of those kinds of dependencies is somewhat strange; it is entirely possible that `>= 3.7.6    && < 4.11.1' doesn't do what you intend. but I don't know for certain
18:23:48 <geekosaur> in any case, I don't think lens is your problem here, it looks like it's between snap-core, vector, and attoparsec
18:25:20 <geekosaur> you can't peg both attoparsec and vector the way you did without excluding all versions of snap-core on hackage
18:28:02 <Welkin> life-goals3?
18:28:08 <Welkin> what happened to 1 and 2?
18:28:13 <nocturne777> Welkin: name of the stupid project ahaha
18:28:15 <Welkin> are you on yur 3rd life?
18:28:20 <nocturne777> ahaha
18:28:46 <nocturne777> geekosaur: [__5] trying: lens-4.12.1 (dependency of life-goals3-0.1)
18:28:46 <nocturne777> [__6] trying: lens-4.12.1:!bench
18:28:46 <nocturne777> [__7] trying: lens-4.12.1:!test
18:28:57 <geekosaur> yes, you arr focused on that
18:29:15 <geekosaur> and ignoring the fact that it fails because of what I mentioned, which never mentions lens at all
18:29:25 <geekosaur> you have worse dependency issues than lens to sort out
18:29:30 <nocturne777> why is it looking for 4-12.1?
18:30:03 <Welkin> geekosaur: you ARRRR!
18:30:10 * Welkin makes a pirate grin
18:30:27 <geekosaur> [18 01:21] <geekosaur> hm. the meaning of those kinds of dependencies is somewhat strange; it is entirely possible that `>= 3.7.6    && < 4.11.1' doesn't do what you intend. but I don't know for certain
18:31:15 <Welkin> this is using snap?
18:31:30 <Welkin> with yesod, the way I resolved some dependency issues was to remove the upper bounds
18:31:39 <Welkin> and see what happened
18:31:51 <Welkin> sometimes I had to manually try out different versions of a package until I found one that worked
18:32:41 <Welkin> when you do find a set of packages that works, make sure to cabal freeze
18:34:40 <nocturne777> this has been a working build, just had to install a local package and it devolved into this after deleting the sandbox
18:34:55 <Welkin> nocturne777: always use cabal freeze
18:35:03 <Welkin> then you can always replicate your working state again
18:35:15 <Welkin> it generates a cabal.config
18:37:31 <nocturne777> Welkin: I also think that after I add a new package I should  alway delete  sandbox and re-init for testing purposes
18:39:00 <jle`> my workflow today in haskell is gasping out loud and dropping my mouth every half hour when my code is able to compile
18:42:48 <nocturne777> cabal is stupid: attoparsec-0.13.0.1 (dependency of postgresql-simple-0.4.10.0)
18:43:12 <nocturne777> it is trying to get the latest version of attoparsec
18:44:30 <nocturne777> yet even the latest version pf postgresql-simple does not explicitly require that : attoparsec (>=0.10.3)
18:48:05 <Welkin> nocturne777: cabal gets the latest by defaults if there are no constraints to the contrary
18:48:26 <Welkin> this is why you use a cabal.config with explicit constraints
18:48:41 <Welkin> specifying the exact version of each package
18:49:50 <nocturne777> I think aeson has been causing the problem
18:56:04 <nocturne777> Welkin: in that case I would say that postgres-simple package is causing the problem
18:56:27 <nocturne777> it's depency filter is pretty loose
19:23:32 <nocturne777> geekosaur: FYI, "lens < 4.9" solved my problem
19:24:58 <ttt_fff> what is the main disadvantage of debrujin index?
19:25:09 <ttt_fff> it seems to solve many problems with term rewriting
19:26:30 <mniip> ttt_fff, all the math necessary for recalculating
19:26:41 <mniip> other than that it's objectively better than named variables
19:27:31 <ttt_fff> mniip: https://en.wikipedia.org/wiki/De_Bruijn_index where is the recalculatingon ?
19:29:48 <dolio> ttt_fff: Consider: \. (\. \. 0 1) 0
19:30:12 <ttt_fff> \x (\y \z z y) x
19:30:16 <ttt_fff> yeah, what about it?
19:31:12 <dolio> If you reduce, then if you just substitute blindly, you'd get: \. \. 0 0
19:31:18 <dolio> But that's incorrect.
19:31:40 <dolio> So you have to do arithmetic to prevent capture, just like with names.
19:33:27 <Welkin> :t (\.)
19:33:28 <lambdabot>     Not in scope: ‘\.’
19:33:28 <lambdabot>     Perhaps you meant one of these:
19:33:28 <lambdabot>       ‘.’ (imported from Data.Function),
19:33:29 <ttt_fff> how did you go from \. (\. \. 0 1) 0 to \. \. 0 0 ?
19:33:34 <Welkin> what is \.?
19:33:56 <lpaste_> mniip pasted “de-bruijn substitution” at http://lpaste.net/136843
19:33:58 <dolio> I substituted 0 in.
19:34:18 <mniip> these are the maths
19:34:25 <dolio> (\. \. 0 1) 0 --> \. 0 0
19:34:33 <dolio> The correct answer is \. 0 1
19:35:14 <dolio> Also if you have a more complicated example: \. (\. \. 0 1) (\. 0 1) --> \. \. 0 (\. 0 2)
19:35:26 <Welkin> what is \.?
19:35:33 <mniip> abstraction
19:36:33 <dolio> So you have to increment 'free' indices but not 'bound' indices when substituting.
19:36:53 <ttt_fff> mniip: reading your code
19:37:12 <mniip> dolio, consider this too
19:37:12 <ttt_fff> dolio: so you're saying: named = app = easy, subs = hard, debrujin = subst easy, app hard
19:37:32 <mniip> (\\1) (\1)
19:37:50 <mniip> okay that was bad
19:38:14 <mniip> (\\\2) (\1)
19:38:27 <dolio> I'm not sure what you mean by that. They both have capture issues.
19:38:28 <mniip> naive application would retult in \\1
19:38:32 <mniip> while in reality it's \\2
19:38:38 <dolio> Just the way you solve them is the opposite in some sense.
19:39:00 <mniip> ttt_fff, de-bruijn indices are better beause you're working on numbers
19:39:10 <mniip> you don't have to "generate" names or anything
19:39:16 <mniip> it's all calculable
19:40:13 <dolio> If f[e] means substituting e into an expression with a hole f, then with de Bruijn indices, you fix up things in e, whereas with string names you fix up things in f.
19:40:31 <mniip> dolio, you fix up f too
19:40:39 <mniip> and e too
19:40:47 <mniip> basically both have to fix up both parts
19:40:59 <dolio> That doesn't seem right to me.
19:41:03 <mniip> (\\\2) (\1)
19:41:14 <mniip> gotta fix up the argument
19:41:29 <dolio> Right, that's the e part.
19:41:38 <mniip> (\x. \y. x) y
19:41:42 <mniip> gotta fix up the function
19:41:51 <dolio> Right. That's the f part. :)
19:42:07 <ReinH> relevant to your interests: https://www.fpcomplete.com/user/edwardk/bound
19:42:48 <mniip> dolio, you want the opposite?
19:43:11 <mniip> (\\0 1 3) (\0)
19:43:14 <mniip> gotta fix up the function
19:43:16 <dolio> No, I'm just saying de Bruijn is always fixing e, and string names is always f (alpha renaming).
19:43:35 <dolio> No.
19:43:47 <dolio> \\(\0) 1 3
19:43:56 <mniip> no?
19:44:01 <mniip> \\0 (\0) 2
19:44:04 <mniip> \0 (\0) 2
19:44:07 <mniip> *
19:44:55 <dolio> Hmmm....
19:45:50 <dolio> When do you fix up the argument with names?
19:46:27 <ttt_fff> http://www.cs.cmu.edu/~fp/courses/15312-f04/recitations/r03-debruijn.pdf <-- page 2, what does {3/1} mean in {3/1} \lambda. 2 1 ?
19:46:51 <dolio> This might lower my opinion of de Bruijn indexing further.
19:47:45 <mniip> dolio, that I'm not sure
19:47:52 <dolio> I don't think that ever happens.
19:47:56 <mniip> yeah
19:48:03 <dolio> So de Bruijn is kind of worse, even.
19:48:07 <mniip> nope
19:48:10 <mniip> it's still math
19:48:53 <dirk103> heyo
19:49:06 <dolio> Anyhow, I dislike both.
20:02:22 <ttt_fff> argh
20:02:27 <ttt_fff> what is a good tutorial on debrujin index?
20:03:18 <athan> ttt_fff: Check out... 
20:03:45 <ttt_fff> athan .... ?
20:03:47 <athan> (wait for it)
20:04:15 <athan> @hackage monad-unify ttt_fff (in the meantime)
20:04:15 <lambdabot> http://hackage.haskell.org/package/monad-unify ttt_fff (in the meantime)
20:04:49 <ttt_fff> wtf, this is exaclty what I need
20:04:51 <ttt_fff> I am implementing unification
20:05:18 <ttt_fff> how did you know?
20:05:26 <athan> @hackage bound ttt_fff
20:05:26 <lambdabot> http://hackage.haskell.org/package/bound ttt_fff
20:05:26 <athan> this is better
20:05:48 <athan> ttt_fff: I've got a PR on upstream! Maybe edit that one? :D
20:07:00 <ttt_fff> athan: what's PR ?
20:07:34 <bufferloss> ttt_fff, pull request, I think
20:07:38 <bufferloss> it's a git thing
20:07:43 <athan> yep :)
20:07:54 <athan> ttt_fff: http://github.com/athanclark/monad-unify :D!
20:08:10 <ttt_fff> PR on upstream confused me,
20:08:18 <ttt_fff> I didnt' realize (upstream :: Git Term)
20:08:25 <ttt_fff> I thought (upstream :: video streaming service)
20:08:32 <ttt_fff> so I'm like wtf is a "PR" in the context if live streaming ahskell code
20:08:41 <athan> I don't know exatly, I thought upstream meant the origin / official repository
20:08:43 <bufferloss> is there a good "functional database" for lack of a possibly better term that people use with haskell?
20:08:50 <athan> :x
20:08:59 <bufferloss> or do most folks just use e.g. postgres/mysql/mongodb/whatever
20:09:03 <athan> bufferloss: You mean like acid-state?
20:09:07 <athan> :)
20:09:11 <bufferloss> athan, I'm not sure actually :)
20:09:14 * hodapp ponders using some Scala again just to stick it on his resume...
20:09:26 <athan> I think vcache also has some permanent storage ability
20:09:27 <bufferloss> like, clojure has datomic, wondering if there was an equivalent in haskell
20:09:38 <athan> hodapp: ._.
20:09:38 <bufferloss> I'm gonna play around with building a haskell web app
20:09:40 <athan> I should do that
20:09:42 <hodapp> athan: WHAAAT
20:09:55 <athan> bufferloss: Use my lib!!
20:09:55 <bufferloss> clojure > scala :P
20:09:57 * bufferloss ducks
20:09:59 <ttt_fff> bufferloss: I think datomic, underthe hood, uses eithe rpostgresql or hbase or some other backend
20:10:02 <bufferloss> athan, uh, ok sure, what is it?
20:10:03 <hodapp> bufferloss: yeah, prolly.
20:10:04 <athan> @hackage nested-routes bufferloss
20:10:04 <lambdabot> http://hackage.haskell.org/package/nested-routes bufferloss
20:10:06 <bufferloss> ttt_fff, yes it does
20:10:12 <teurastaja> im trying to translate the code of permutations into scheme and i cant grasp the meaning of        interleave xs r = let (_,zs) = interleave' id xs r in zs
20:10:24 <bufferloss> ttt_fff, but it exports data in EDN which is the lisp equivalent of JSON
20:10:45 <teurastaja> i think the pattern matching on tuples are confusing me
20:11:24 <hodapp> teurastaja: do you know how something like "let (a,b) = ..." behaves?
20:11:36 <athan> bufferloss: Let me know if you need help using it :)
20:11:40 <bufferloss> so I've got haskel v 7.6, is that considerably out of date given that we appear to be up to 7.8.4?
20:11:43 <bufferloss> or is that reasonable?
20:11:53 <teurastaja> well you can access a and b after the =
20:11:57 <rcyr> bufferloss: AFAIK, 7.10.1 is out.
20:12:11 <hodapp> bufferloss: it's not exactly stone age, but if you have the option of upgrading without much trouble and you have no need for 7.6 compatibility, you may as well upgrade.
20:12:24 <bufferloss> oh, wait, there's a PPA, nm, lemme check that
20:12:39 <bufferloss> hodapp, yeah no need, I'm just starting a hobby project fresh right now
20:12:58 <teurastaja> but let (_,zs) = interleave' id xs r in zs?
20:13:05 <bufferloss> well, hobby project with an eye toward using it in a real project, but just wanna try it for myself, investigate etc
20:13:10 <athan> bufferloss: I think you should get the latest GHC :\
20:13:14 <athan> it makes life a lot easier, and you get faster executables
20:13:26 <athan> bufferloss: What arch are you on?
20:13:44 <athan> bufferloss: You just installed haskell-platform, huh?
20:13:50 <hodapp> teurastaja: does let (_,zs) = foo in zs make sense to you?
20:14:03 <teurastaja> no
20:14:04 <athan> maybe you could try stack, it automates the installation of GHC
20:14:09 <athan> bufferloss: ^
20:14:28 <teurastaja> the snd of the tuple is the answer?
20:14:36 <teurastaja> i dont understand
20:14:44 <hodapp> teurastaja: but you are familiar with let ... in ...?
20:14:52 <athan> bufferloss: There's a lot of libraries you can use - yesod is the most popular & stable, but it can be complicated
20:14:58 <bufferloss> what's haskell-platform?
20:14:59 <athan> also there's scotty for a sinatra-like appeal
20:15:15 <bufferloss> athan, I'm just planning to install via the PPA instructions on https://www.haskell.org/downloads/linux
20:15:19 <bufferloss> PPA = win :)
20:15:24 <athan> bufferloss: It's an outdated installation package for ubuntu
20:15:28 <athan> oh! nice!!
20:15:57 <athan> Yeah my lib uses some pretty advanced haskell features :\ it might be hard finding help if you run into an error
20:15:59 <teurastaja> hodapp: yes
20:16:44 <athan> especailly because the errors are redicuously vague
20:16:58 <hodapp> teurastaja: well, given the knowledge of how tuples are unpacked, where are you then lost in "let (_, zs) = foo in zs"?
20:16:59 <bufferloss> hmm, looks like 7.10 hasn't made it in to the PPA yet
20:17:19 <hodapp> teurastaja: you were correct with the earlier case of being able to access 'a' and 'b' after
20:17:22 <geekosaur> likely waiting ion 7.10.2 because 7.10.1 has a number of bugs including some linker bugs
20:17:57 <bufferloss> so, did it jump from 7.8 to 7.10?
20:18:03 <geekosaur> (7.10.2 is in release candidate stage. an updated Platform using it is also in RC, they having waited because the bugs in 7.10.1 were too severe)
20:18:03 <teurastaja> but 'b' being the answer? what does it mean?
20:18:13 <geekosaur> even numbers are releases, odd numbers are devel
20:18:21 <dirk103> http://lpaste.net/136845
20:18:21 <bufferloss> ah ok cool
20:18:32 <teurastaja> what does the rest after the = and before the in do with that?
20:19:09 <hodapp> teurastaja: that's an expression which must return a tuple with 2 elements (or else it's a type error)
20:19:18 <hodapp> > let (a,b) = (10, 20) in b
20:19:19 <lambdabot>  20
20:19:22 <hodapp> > let (a,b) = (10, 20, 30) in b
20:19:23 <lambdabot>      Couldn't match expected type ‘(t1, t2)’
20:19:23 <lambdabot>                  with actual type ‘(Integer, Integer, Integer)’
20:19:23 <lambdabot>      Relevant bindings include
20:19:43 <dirk103> when i load that code it says print is applied to three arguments.
20:19:52 <athan> bufferloss: https://gist.github.com/yantonov/10083524 !
20:19:58 <teurastaja> how can i translate this part in scheme? doesnt look like a normal let
20:20:09 <dirk103> I'm trying to print out the list nicely one item at a time
20:20:21 <hodapp> teurastaja: it's a pretty normal let
20:20:38 <bufferloss> athan, cool, I think I'll wait for the PPA to update for now
20:20:52 <bufferloss> besides, I don't feel like waiting for the compile right now :)
20:21:06 <teurastaja> hodapp: can you translate this let in scheme?
20:21:16 <hodapp> teurastaja: I don't know enough Scheme to know how it would be translated
20:21:44 <hodapp> teurastaja: so I'm trying to help you read the Haskell
20:22:19 <teurastaja> yeah... without pattern matching with that tuple how would you write it in haskell?
20:22:49 <athan> bitemyapp: Can i make an alternative to this clause: https://github.com/bitemyapp/learnhaskell/blob/master/install.md#ubuntu for GHC 7.10 https://gist.github.com/yantonov/10083524 ?
20:22:57 <hodapp> well, there are the functions 'fst' and 'snd' which return first and second elements in a 2-element tuple
20:23:11 <athan> bufferloss: no doubt :) sorry
20:23:19 <hodapp> they're not especially common, the norm is probably pattern matching (and past 2 elements, it's the only option)
20:23:23 <teurastaja> this could be car and cdr
20:23:28 <athan> I'm not sure if stack has a docker image for 7.10 yet
20:23:34 <bitemyapp> athan: it's on hvr's PPA
20:23:41 <bitemyapp> athan: I don't know about docker, but stack has 7.10
20:23:45 <bufferloss> athan, nah don't be sorry, it's all good
20:23:47 <athan> bitemyapp: Oh! shoot sorry
20:23:53 <athan> :x
20:24:10 <hodapp> teurastaja: lists and tuples are very different in Haskell, so that's up to how the Scheme is representing things
20:24:14 <athan> bufferloss: ^ see, stack has 7.10 :)
20:24:27 <bufferloss> what are alex and happy?
20:24:34 <bufferloss> athan, also what's stack? I've heard of docker
20:24:45 <hodapp> teurastaja: lists in Haskell can have any length but are parametrized over a single type of element; tuples in Haskell are fixed-length but each element can have a different type
20:24:46 <athan> bufferloss: also here's a better PPA https://github.com/bitemyapp/learnhaskell/blob/master/install.md#ubuntu
20:24:48 <bufferloss> that is, I generally know what docker is but haven't heard of stack yet
20:25:08 <bitemyapp> athan: it's fine.
20:25:09 <athan> bufferloss: stack is an alternative to cabal-install, a build tool
20:25:18 <bufferloss> ah
20:25:19 <ttt_fff_> \ x1 x2 x3 x4 .... ( (\ y1 y2 .... yn) ... (\ z1 z2 .... -> ) ) --- so the problem we have with debrujin, is that when I subst the (\ z1 z2 ... ) as some y_i, my bindings to any x_j needs to take the # of y_i's I'm under into account right?
20:25:19 <bitemyapp> athan: I haven't updated it out of laziness and because I'm waiting for more libraries to catch up.
20:25:26 <ttt_fff_> this is the main issue with debrujin, and nothing else, no ?
20:25:26 <athan> it downloads a GHC docker image and installs /different versions/ for you!
20:25:31 <bufferloss> is cabal-install bad in some way?
20:25:31 <bitemyapp> athan: new people don't really "need" 7.10 over 7.8 that badly, as a rule.
20:25:32 <teurastaja> im trying to understand what goes into (_,zs) in that definition of permutations
20:25:37 <athan> bitemyapp: For sure :)
20:25:45 <bufferloss> ah ok so stack is cabal-install but with docker integration
20:25:50 <athan> bufferloss: yeah :\ dependency conflicts can be hard to fix
20:26:06 <ttt_fff_> mniip: \ x1 x2 x3 x4 .... ( (\ y1 y2 .... yn) ... (\ z1 z2 .... -> ) ) --- so the problem we have with debrujin, is that when I subst the (\ z1 z2 ... ) as some y_i, my bindings to any x_j needs to take the # of y_i's I'm under into account right?
20:26:09 <ttt_fff_> this is the main issue with debrujin, and nothing else, no ?
20:26:12 <athan> bitemyapp: Oh crap, sorry I didn't realize how new he was
20:26:20 <bitemyapp> athan: 7.10?
20:26:24 <athan> s/he/he\/she
20:26:33 <bitemyapp> who?
20:26:58 <athan> bitemyapp: bufferloss, someone using 7.6 :\
20:27:04 <hodapp> teurastaja: I don't know offhand what interleave' is or whether it's an internal thing
20:27:11 <teurastaja> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#permutations
20:27:30 <teurastaja> its a where clause in the definition of permutations
20:27:30 <bufferloss> nah I'm on 7.8.4
20:28:06 <hodapp> teurastaja: then the definition of interleave' is right below
20:28:10 <bitemyapp> athan: oh that's rough.
20:28:12 <bitemyapp> oh, 7.8.4
20:28:16 <bitemyapp> bufferloss: you should be okay then.
20:28:33 <athan> x_x derp, sorry guys
20:28:40 * athan should stop multitasking
20:28:41 <bitemyapp> athan: you're fine, just tryin' ta help. :)
20:28:46 <athan> :)
20:28:56 <bitemyapp> module ‘Database.Bloodhound.Client’ is a package module   -- doctests pls
20:29:03 <P4Titan> :t read
20:29:04 <lambdabot> Read a => String -> a
20:31:46 <P4Titan> :t min
20:31:48 <lambdabot> Ord a => a -> a -> a
20:35:11 <bufferloss> athan, haha, apparently you were not wrong
20:35:19 <bufferloss> "cabal: Could not resolve dependencies"
20:35:30 <bufferloss> so will stack help with that?
20:35:42 <bufferloss> that was from cabal install hws
20:35:48 <bitemyapp> bufferloss: are you installing a sandbox?
20:35:53 <bitemyapp> installing in a*
20:35:56 <geekosaur> it can, but it can also require more work
20:36:07 <bufferloss> bitemyapp, not to my knowledge, should I be? you mean like a chroot jail?
20:36:12 <bufferloss> it's just for local development
20:36:21 <bufferloss> I'm not gonna run a prod server off of this machine
20:36:28 <geekosaur> cabal-install relies on ghc's package database (and ghc's somewhat unusual library behavior). stack supplements with a yaml file
20:36:57 <bufferloss> so how should I go about trying to solve that dependency issue?
20:37:02 <Welkin> like cabal.config?
20:37:07 <geekosaur> because ghc itself doesn't keep enough useful information (and if left iot itself will screw up even more often and worse than cabal does)
20:37:11 <bufferloss> is it a dep missing from ubuntu? or is it actually a dep missing from hackage?
20:37:17 <geekosaur> *left to
20:38:06 <geekosaur> stack.yaml has rather more information than cabal.config, since cabal isn't out to replace the more annoying limitations of ghc-pkg
20:38:07 <bufferloss> hmm, nm it appears perhaps hws is out of date I suppose
20:38:09 <bitemyapp> bufferloss: mkdir pick-a-dir-name && cabal sandbox init && cabal install thing-you-wanted
20:38:27 <bitemyapp> but yes, if your library is out of date, you'll just have to clone it and bump the deps and see if it still works.
20:38:47 <bufferloss> rejecting: base-4.7.0.2/installed-bfd... (conflict: hws => base>=4.2 && <4.4)
20:38:56 <bufferloss> but it's trying to get like 4.7 or so
20:39:04 <bufferloss> oh, well yes that's apparent already I suppose
20:39:53 <bitemyapp> bufferloss: <4.4 is pretty effin' old.
20:40:04 <bitemyapp> bufferloss: cabal unpack hws && cd hws && cabal sandbox init && get-hackin'
20:42:06 <bufferloss> k
20:54:45 <AshyIsMe> ok ghc-mod not working with stack is driving me crazy
21:01:32 <albeit> With hmatrix, how can I convert a value of type "RealOf Double" to Double?
21:02:30 <mniip> hmm
21:02:59 <mniip> dropFronEnd with peano in typefamily format
21:03:04 <mniip> dropFromEnd*
21:04:00 <albeit> mniip: I can't find dropFromEnd on Google or Hoogle... any pointers?
21:04:13 <mniip> albeit, oh I wasn't talking to you, sorry
21:04:16 <albeit> I'm simply trying to print the RealOf Double 
21:04:30 <albeit> mniip: Oh! ha okay. I saw type family and I know RealOf is a type family, thought it was related
21:04:47 <funfunctor> Hi, I am trying to work though this type issue http://lpaste.net/136846
21:07:55 <geekosaur> funfunctor, you need to distribute the liftIO instead of doing it at the top
21:08:28 <geekosaur> because inside the liftIO, you no longer have access to the Handler
21:08:43 <echo-area> In pattern matching, is this the simplest way to express a non-empty list?  x:_
21:09:03 <geekosaur> echo-area, yes
21:09:11 <echo-area> geekosaur: Thanks
21:09:20 <geekosaur> well, _:_ arguably, but non-empty list is then all you know about it :)
21:09:45 <funfunctor> geekosaur: I tried that :|
21:09:59 <echo-area> geekosaur: I had thought of that too after posting my message :-P
21:10:54 <geekosaur> funfunctor, apparently didn't try it right? I'd remove the liftIO from line 2 and apply it on lines 3, 5, 6, 7 (but NOT 11)
21:10:57 <funfunctor> geekosaur: I end up with http://lpaste.net/136847
21:11:41 <funfunctor> geekosaur: yep that is exactly what I did
21:11:44 <geekosaur> I was wondering about that, tbh. I don't know Snap, but I presume that means you need something more concrete than MonadSnap
21:12:12 <geekosaur> or that you need some other lift operation within a MonadSnap
21:12:33 <geekosaur> but you still need that first part before you can even look into the second
21:12:41 <geekosaur> (that is, moving the liftIO)
21:12:59 <geekosaur> someone who knows snap will have to help you with the rest, unfortunately
21:14:12 <funfunctor> geekosaur: i've fixed the distribution of liftIO already..
21:14:13 <dirk103> eyo
21:15:41 <dirk103> http://lpaste.net/136850
21:15:58 <dirk103> if someone has a moment i'd really appreciate a little nudge
21:16:02 <dirk103> I'd like to print each address one line at a time separating each Customer entry with a "-----------------------------"
21:16:26 <dirk103> i figured out a unlines function, but i'm not sure how to put this all together
21:17:01 <P4Titan> :t const
21:17:02 <lambdabot> a -> b -> a
21:19:27 <julianleviston> dirk103: main = do { print $ unlines a }
21:19:39 <P4Titan> :t $>
21:19:41 <lambdabot> parse error on input ‘$>’
21:19:43 <julianleviston> ooh oops
21:19:49 <P4Titan> :t ($>)
21:19:50 <lambdabot>     Not in scope: ‘$>’
21:19:50 <lambdabot>     Perhaps you meant one of these:
21:19:50 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
21:20:46 <julianleviston> dirk103:  do {print $ unlines $ map customerAddress a}
21:20:50 <geekosaur> funfunctor, so as I read this it sounds like you can't use MonadSnap m => m because it's too general
21:20:58 <P4Titan> What package has the $> defined in it for Functor?
21:21:06 <julianleviston> dirk103:  does that work? assuming you’ve derived show
21:21:15 <geekosaur> you need to use the (Handler b App) directly
21:21:25 <funfunctor> geekosaur: I tried to restrict down to Handler App App ()
21:21:40 <funfunctor> yea, no good.. I just run into walls everywhere
21:21:57 <geekosaur> but beyond that you really do need someone who knows this stuff --- I'm just going by haddocks
21:22:08 <geekosaur> not a webdev and not particularly interested
21:23:14 <geekosaur> @index ($>)
21:23:14 <lambdabot> Data.Functor
21:23:38 <P4Titan> I get not in scope when I import Data.Functor, could it be a version thing?
21:23:40 <geekosaur> P4Titan, also consider using hayoo or hoogle
21:23:49 <geekosaur> quite possibly, yes
21:24:21 <julianleviston> dirk103:  oh you want hyphens interspersing it, too… then import Data.List, then : main = do {print $ unlines $ intersperse "-------------" $ map customerAddress a} - that should point you in the right direction
21:24:25 <geekosaur> in older versions of ghc / base it may be in Control.Applicative
21:24:43 <geekosaur> in still older ones it may not even exist, but hopefully you don'[t have one that old
21:25:13 <P4Titan> The docs say it was added to Functor since 4.7
21:25:20 <P4Titan> I have base 4.6, how should I update?
21:25:21 <dirk103> julianleviston: Thanks one sec!
21:25:35 <geekosaur> upgrade ghc
21:25:40 <geekosaur> base is wired in, you cannot update it
21:25:46 <P4Titan> ugh
21:25:48 <geekosaur> that is why I said ghc and not base
21:26:02 <P4Titan> ok
21:26:05 <P4Titan> I'll try
21:27:47 <julianleviston> Does anyone know of a declarative reactive-style DOM update library, along the lines of Phooey (https://wiki.haskell.org/Phooey) but for HTML? (running in GHCJS)
21:28:18 <funfunctor> geekosaur: thanks I worked my way around those unholy types..
21:28:22 <rcyr> julianleviston: Something like Reflex?
21:28:31 <julianleviston> rcyr: I’ll go look.
21:29:01 <julianleviston> rcyr: thank you! :)
21:29:07 <rcyr> You're welcome :)
21:30:13 <julianleviston> rcyr: oh haha I’ve actually checked this out before. LOL
21:30:20 <rcyr> Hehe :)
21:30:27 <julianleviston> rcyr: great, though. I needed to be reminded obviously...
21:30:44 <rcyr> #reflex-frp seems to be the official channel on Freenode
21:33:05 <AshyIsMe> is there a channel for stack on freenode?
21:34:08 <bitemyapp> AshyIsMe: #haskell-stack
21:34:46 <julianleviston> rcyr: strange… watching this video - an intro to reflex to NYC Haskell UG, and he’s spent 11 minutes selling pure functonal programming… very odd https://www.youtube.com/watch?v=mYvkcskJbc4
21:38:15 <funfunctor> I really think the web frameworks of Haskell need better documentation! They are more powerful than they first seem
21:38:31 <julianleviston> funfunctor: same with everything in Haskell, I guess.
21:39:24 <funfunctor> julianleviston: well some packages are pretty well documented
21:40:15 <funfunctor> julianleviston: I tried to document mine well https://hackage.haskell.org/package/hlibBladeRF
21:40:37 <funfunctor> julianleviston: feel free to make issues on my github if you find documentation issues!
21:42:29 <dirk103> julianleviston: What is the $ called in the code you gave me?>
21:43:25 * hackagebot yesod-media-simple 0.1.0.0 - Simple display of media types, served by yesod  http://hackage.haskell.org/package/yesod-media-simple-0.1.0.0 (MichaelSloan)
21:45:38 <dirk103> nm found it
21:46:22 <julianleviston> ricardo82: oh… I don’t know - what is it called? 
21:46:33 <julianleviston> dirk103:  ^ what’s $ called?
21:47:21 <julianleviston> funfunctor: documentation is hard because it presupposes there’s only one audience, and there are often many kinds of audience - technical, non-technical, etc.
21:47:54 <julianleviston> funfunctor: I think you’re usually going well if you describe prerequisites for your docs.
21:48:45 <funfunctor> julianleviston: good point about describing prerequisites! file a issue and I will listen
21:49:33 <julianleviston> funfunctor: I’m not that interested in your library, sadly. But good luck with it!
21:49:36 <dirk103> julianleviston: Apparently intersperse wnats [Char] but i'm supplying it [String]
21:49:50 <julianleviston> dirk103:  oh sorry… yeah, 
21:49:59 <julianleviston> > intersperse “hey” [“1”, “2”]
21:50:01 <lambdabot>  <hint>:1:13: lexical error at character '\8220'
21:51:01 <julianleviston> hm… weird. I wonder why
21:51:10 <julianleviston> oh… coz of curly quotes
21:51:30 <julianleviston> > intersperse "hey" ["1", "2"]
21:51:31 <lambdabot>  ["1","hey","2"]
21:51:41 <julianleviston> dirk103: can you pastie your code?
21:51:59 <dirk103> yesssss
21:52:05 <julianleviston> dirk103: I’ve obviously led you up some garden path, sorry.
21:52:16 <julianleviston> dirk103:  but I’ll gladly correct it.
21:52:17 <dirk103> well it's close i think one second
21:52:23 <dirk103> thanks a lot!
21:52:35 <julianleviston> dirk103: I’m very happy that I can actually help someone! :)
21:53:25 * hackagebot yesod-media-simple 0.1.0.1 - Simple display of media types, served by yesod  http://hackage.haskell.org/package/yesod-media-simple-0.1.0.1 (MichaelSloan)
21:55:17 <dirk103> julianleviston: http://lpaste.net/136851
21:55:35 <dirk103>     Couldn't match type `[Char]' with `Char'
21:55:35 <dirk103>     Expected type: Customer -> [Char]
21:55:35 <dirk103>       Actual type: Customer -> [String]
21:55:36 <dirk103> sry
21:56:28 <julianleviston> dirk103:  oh… sorry… before interperse, you want to join the strings into one string, right?
21:56:59 <julianleviston> so put concat $ in front of it.
21:57:20 <julianleviston> that concatenates all the strings together...
21:57:40 <julianleviston> dirk103: concat ( intersperse "---------------" (map customerAddress a))
21:59:21 <julianleviston> dirk103: gosh. I’m leading you further up that path. Sigh. Sorry.
22:00:32 <dirk103> :P That's cool learning stuff
22:00:39 <dirk103> when i type: intersperse "---------------" (map customerAddress a))
22:00:50 <dirk103> on the GHCI prompt it gives the error above 
22:01:08 <julianleviston> dirk103:  yeah that won’t work coz they’re different types in the same list (a list can only have the same type, usually)
22:01:23 <julianleviston> a customerAddress is of type [String], I see
22:01:57 <julianleviston> so you’d have mixed [String] and String in the same List.
22:03:09 <julianleviston> dirk103: just the map part gives you this: [["317 - 5411","51 Ave","Edmonton, AB"],["12324 Saskatchewan Dr","Edmonton, AB"]]
22:03:27 <julianleviston> you want to make them single strings before interspersing them
22:04:15 <dirk103> okay
22:04:23 <dirk103> ah i better read up some more. thanks for the help!
22:04:32 <julianleviston> dirk103: hang a sec.
22:09:26 <julianleviston> dirk103: so, if you create a function that takes a single Customer and spits out a String, it’d look like this: customerToAddress = concat . (intersperse "," ) . customerAddress
22:09:37 <julianleviston> I’ve actually tested this, so it makes sense ;-)
22:10:01 <julianleviston> dirk103:  spits out a comma-separated address String, I should say.
22:10:45 <julianleviston> dirk103:  at that point, you can then take that function and create an experssion to map over all customers and spit out a string with hyphens in between, all joined up using unlines: unlines . intersperse "-------" $ map customerToAddress a
22:11:11 <julianleviston> dirk103: let me know if you don’t understand anything, and I’ll do my best to explain.
22:11:26 <dirk103> thanks a lot for your time. Got to chew all this over
22:12:46 <julianleviston> dirk103:  ok. :) $ just means “parens from here to the end of the line” and . just means compose two functions together: make a new function out of these two by joining them together, that does the job of them joined up.
22:13:09 <dirk103> i need something plainly said. can i have a main function like  main = print "hello there" \n print "im a cat"\nprint "no i;m a dog"
22:13:24 <julianleviston> dirk103: no.
22:13:44 <julianleviston> you need a do.
22:13:57 <dirk103> functions are more like mathematical algebraic functions as opposed to sequential statements eh?
22:14:07 <dirk103> even main?
22:14:09 <julianleviston> dirk103: oh sorry my bad, apparently that will work fine
22:14:27 <julianleviston> dirk103: uh yes.
22:14:36 <dirk103> it isn't for me it says i'm supplying 5 arguments to print 
22:14:44 <julianleviston> dirk103: you can totally do the sequential stuff, you just need to put it in a do block… 
22:15:00 <dirk103> oh okay
22:15:04 <julianleviston> dirk103: oh sorry I misinterpreted what you meant
22:15:22 <julianleviston> you can do this: main = do {print “hey” ; print “yo”} 
22:16:02 <dirk103> ahh perfect. 
22:16:05 <julianleviston> dirk103: the do lets you sequence things together
22:16:06 <mniip> well to be fair
22:16:12 <dirk103> is that "bad form" ?
22:16:14 <julianleviston> dirk103: it’s just a special syntax.
22:16:18 <mniip> 'do' is just an abstraction over monads
22:16:19 <julianleviston> dirk103: no, not at all.
22:16:36 <julianleviston> mniip: yes, let’s not confuse the poor person!
22:16:38 <mniip> that internally manage all the mathematical algebraic reresentation
22:16:55 <dirk103> julian: i can take it
22:16:58 <mniip> julianleviston, you're making it sound as if 'do' is 'unsafePerformIO'
22:17:10 <julianleviston> mniip: am I?
22:17:13 <mniip> which is true in ML, but not in haskell
22:18:04 <julianleviston> dirk103: ok, well main is an IO Monad, and a do block gets compacted to a series of binds which join all the objects together, and pass world-states between each other which is how they sequence things. 
22:18:28 <julianleviston> mniip: feel free to correct that description! :)
22:19:18 <mniip> if I were pedant mode, I'd mention that IO
22:19:24 <mniip> 1) does not export worldstate passing
22:19:29 <mniip> 2) does not actually pass world states
22:19:42 <julianleviston> dirk103: I should say, there are lots of different kinds of Monads, IO is just one… IO passes worlds and allows side effects, but other Monads to different things, and do syntax works on Monads, not only for the IO Monad.
22:20:12 <julianleviston> mniip: maybe that’s good, but I don’t understand what worldstate passing means there… 
22:20:30 <mniip> well
22:20:33 <julianleviston> mniip: so I’m not really sure what you’re saying, sadly. You’ll have to define your terms for me (us?)
22:20:48 <mniip> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:20:55 <julianleviston> mniip: dude.
22:20:57 <bitemyapp> that's not a great way to explain IO.
22:21:00 <mniip> true
22:21:08 <julianleviston> bitemyapp: what’s not a great way to explain IO?
22:21:09 <bitemyapp> it doesn't tell them anything, it's not real, and it has zero predictive value.
22:21:16 <julianleviston> bitemyapp: what is?
22:21:16 <bitemyapp> realworld blah-dee-blah.
22:21:22 <julianleviston> bitemyapp: huh?
22:21:28 <bitemyapp> 05:20 < mniip> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:21:33 <julianleviston> bitemyapp: oh.
22:21:34 <mniip> I know I know
22:21:40 <bitemyapp> it's a confusing waste of time
22:21:44 <mniip> I was just answering what worldstate passing is
22:21:47 <bitemyapp> oh, dang.
22:21:53 <bitemyapp> I try to steer people away from that generally.
22:22:05 <mniip> also "it has zero predictive value" - not true after a certain point
22:22:06 <bitemyapp> it's not real anyway, so why bother?
22:22:10 <bitemyapp> there is no world state.
22:22:23 <bitemyapp> it is not a representation of the outside world.
22:22:35 <julianleviston> yeah, perhaps we should limit our discussion to things of semantic value?
22:22:41 <bitemyapp> there's a state token that gets erased at compile time, but it's nothing to do with the outside world.
22:22:47 <bitemyapp> julianleviston: that's just it, IO is purely operational.
22:22:48 <mniip> it's a demand forcing trick that gets optimized away by return conventions
22:22:58 <bitemyapp> julianleviston: there is no denotation for it. the closest equivalent is Identity.
22:23:52 <mniip> bitemyapp, I'd say Compose Identity Identity
22:24:09 <julianleviston> Haskellers generally need to learn to limit their explanations to those that are likely to actually be understood. I know there’s a temptation to get involved in extreme pedantry, but it’s really not helpful.
22:24:18 <bitemyapp> I'm not engaging in pedantry.
22:24:24 <mniip> the outer Identity is patternmatched at compose time, the inner identity is patternmatched when demanded, i.e at runtime
22:24:28 <julianleviston> that is, if their intent is actually communicate something
22:24:38 <bitemyapp> mniip: nifty distinction.
22:24:40 <julianleviston> bitemyapp: it was a general observation, apologies if the cap fit. 
22:24:49 <bitemyapp> julianleviston: I've taught a lot of people Haskell, IO too.
22:25:00 <bitemyapp> julianleviston: when I say something is counter-productive, I'm not speaking to what I personally prefer.
22:25:10 <julianleviston> bitemyapp: yeah, I know you have.
22:25:19 <julianleviston> bitemyapp: yep.
22:25:42 <julianleviston> bitemyapp: I’ve actually read quite a lot of your stuff. I think you once told me not to use Datomic.
22:26:01 <bitemyapp> I probably did you a favor then.
22:26:12 <mniip> basically IO is about magical values of type 'IO a' which represent an action that results in 'a'. you can sequence them in do blocks using semicolons, and use their results in do blocks using <-
22:26:17 <julianleviston> bitemyapp: haha probably. I’m not sure why because you didn’t give me any reasons :)
22:26:24 <bitemyapp> julianleviston: CBA
22:26:32 <julianleviston> bitemyapp: all good :)
22:26:43 <julianleviston> bitemyapp: CBA = couldn’t be arsed, right?
22:26:47 <bitemyapp> yeap
22:26:58 <bitemyapp> you can only explain how terrible a data store is so many times before the topic makes you nauseous.
22:27:06 <bitemyapp> eventually you just stop caring if anybody will listen
22:27:18 <julianleviston> bitemyapp: I was / am interested.
22:27:25 <bitemyapp> julianleviston: okay, here's the story.
22:27:25 <julianleviston> bitemyapp: I like saving myself pain.
22:27:28 <bitemyapp> julianleviston: don't use Datomic.
22:27:29 <bitemyapp> Boom.
22:27:29 <dirk102> julianleviston: do you still have the working code? I froze my IRC client and lost something
22:27:50 <julianleviston> dirk102: customerToAddress = concat . (intersperse "," ) . customerAddress
22:27:57 <julianleviston> dirk102:  unlines . intersperse "-------" $ map customerToAddress a
22:27:57 <bitemyapp> mniip: are you familiar with call by (value | name | need) terminology?
22:28:11 <mniip> very much so
22:28:25 <bitemyapp> mniip: my understand is that IO flips the switch from need to name. Am I wrong?
22:28:28 <bitemyapp> understanding*
22:28:44 <julianleviston> bitemyapp: What would you recommend to store a tree structure? I was thinking of doing amazon’s whatsitcalled thingie… um…. DynamoDB
22:30:05 <mniip> bitemyapp, uh, I don't think so
22:30:20 <julianleviston> bitemyapp: I quite liked the idea that datomic has of local computation contexts, but that’s probably as much a case of creating myself a declarative data description language rather than datomic’s structure or implementation per-sey.
22:30:25 <mniip> IO is really about demanding the result of the previous action before starting the next
22:30:36 <bitemyapp> mniip: you're focusing on the wrong bit.
22:30:40 <julianleviston> mniip: isn’t that just strict evaluation?
22:30:48 <bitemyapp> mniip: put aside the sequencing for a moment.
22:31:11 <mniip> without sequencing there's nothing to "apply"
22:31:12 <bitemyapp> on second thought, nevermind.
22:31:20 <mniip> or rather, "call"
22:31:58 <bitemyapp> mniip: I've discussed IO with Hammond, I'm pretty sure one of the main things it does for us is make it so the thunks never get bounced from the code.
22:32:36 <bitemyapp> So it's a type that has call-by-name eval semantics rather than call-by-need.
22:33:03 <nshepperd> can you not explain IO as a free monad of some ffi operation set?
22:33:10 <bitemyapp> nshepperd: not really no.
22:33:22 <julianleviston> haha all this for hello world.
22:33:24 <nshepperd> except that unsafePerformIO still requires magic in that case
22:33:38 <bitemyapp> nshepperd: unsafePerformIO is pretty uninteresting.
22:33:50 <mniip> unsafeInterleaveIO
22:34:14 <bitemyapp> julianleviston: IME, IO brings out a lot of weird unfalsifiable ontological claims. Best to ignore it until you understand how Haskell code evaluates.
22:34:51 <mniip> "unfalsifiable"
22:35:03 <mniip> any claims provided by IO are falsifiable if you import the right primitives
22:35:16 <nshepperd> I'm referring to that "free monads for less" stuff
22:36:08 <fred-fri> does haskell have a type "non-empty list" (or string)
22:36:11 <bitemyapp> nshepperd: that's fine. That's not how IO works and Free is considerably harder to understand than IO anyway so it doesn't really save you anything.
22:36:20 <bitemyapp> fred-fri: http://hackage.haskell.org/package/semigroups
22:36:24 <mniip> I wonder what semantics does 'foo :: IO (); foo = IO $ \_ -> (# realWorld#, () #)' have
22:36:36 <julianleviston> bitemyapp: Yeah, this was mostly for dirk102 more than me.
22:36:36 <nshepperd> it's not how IO works in haskell, obviously
22:36:38 <mniip> it's like unsafeInterleaveIO that covers the preceding part of the IO block
22:36:51 <nshepperd> because haskell has this state token shit instead
22:37:27 <bitemyapp> The way IO works in GHC and YHC is pretty simple.
22:37:39 <mniip> nshepperd, there is a problem
22:37:50 <mniip> "some ffi operation set" would be closed
22:38:31 <mniip> whereas with state tokens you can do pretty much anything you want
22:38:59 <bitemyapp> nshepperd: ^^ yeah what mniip said.
22:39:13 <bitemyapp> I'm also not sure the way Free defers interpretation is precisely how IO behaves either.
22:39:36 <mniip> it is
22:39:56 <mniip> assuming I'm thinking of the right Free
22:40:08 <bitemyapp> is there some way to prove this?
22:40:41 <nshepperd> the free monads for less post implied the ffi set doesn't need to be closed
22:41:17 <mniip> how would you maintain an open set
22:41:43 <mniip> (I need to read up on what free monads actually are)
22:42:06 <fred-fri> http://pastebin.com/n85GwyaM is this really a good way to write a function that capitalizes strings? Why, given an empty string, would you want to return "Empty string, woops!" instead of simply returning an empty string or do the equivalent or throwing an exception (yes im a java dev and a haskell noob) or even better forbid calling with empty strings through type nonemptystring in the first place?
22:43:26 <zomg> fred-fri: if the specification of your application says that capitalizing empty strings must result in that specific string, then it's a good way, but really there is no technical precent for it =)
22:43:59 <mniip> fred-fri, from what I see "capital" has nothing to do with capitalization
22:44:02 <julianleviston> fred-fri: it totally depends what you’re trying to do. Personally, I’d capitalise “” to “”.
22:44:40 <fred-fri> its from learn you a haskell, im assuming its just an attempt at a pedagogical example which over analyzing people like me would be inclined to think is a poor example
22:44:58 <julianleviston> capital all@(x:xs) = (toUpper x):xs
22:45:20 <nshepperd> off the top of my head, data FFI i o = FFI ({pointer to some code that takes a i and produces o})
22:45:31 <zomg> fred-fri: yep, it really looks like just an example how pattern matching can be used
22:46:07 <julianleviston> fred-fri: LYAH is a bit annoying if you want fully detailed truthful explanations. It’s pretty good for getting rough ideas of things, though.
22:46:20 <nshepperd> i'm sure there are better ways
22:46:21 <julianleviston> fred-fri: it’s also free, which is pretty great! :)
22:46:29 <bitemyapp> julianleviston: you'll have to excuse me.
22:46:32 <fred-fri> right. i personally kind of dislike examples which imply poor practices, should i look to some other resource than learn you a haskell for learning haskell?
22:46:39 <julianleviston> bitemyapp: how come?
22:46:41 <bitemyapp> fred-fri: I'm going to disagree with Julian here and say you can do a fair bit better than LYAH.
22:47:14 <julianleviston> fred-fri: I found Thinking Functionall With Haskell quite good
22:47:15 <bitemyapp> fred-fri: I have a guide which recommends free resources that seem to have worked better for people than LYAH et al. - https://github.com/bitemyapp/learnhaskell
22:47:15 <nshepperd> btw, a free monad is basically just a tree with a functorful of branches
22:47:29 <julianleviston> bitemyapp: I agree with that, though!
22:47:54 <julianleviston> bitemyapp: your guide ironically refers to LYAH quite a bit! :)
22:48:02 <julianleviston> bitemyapp: or rather, the works in your guide.
22:48:04 <gfixler> bitemyapp: your guide is missing a section
22:48:08 <nshepperd> well, Free is basically that
22:48:18 <julianleviston> bitemyapp: BTW, thank you SO much for that guide. 
22:49:23 <julianleviston> fred-fri: I also quite liked Programming in Haskell by Hutton… 
22:49:34 <bitemyapp> julianleviston: no it doesn't.
22:49:45 <bitemyapp> gfixler: that being?
22:49:55 <gfixler> bitemyapp: Just below "DO NOT INSTALL HASKELL PLATFORM"
22:50:04 <gfixler> you need "OMG TOO LATE WTF!?"
22:50:26 <bitemyapp> julianleviston: you're welcome. I removed all mention of LYAH. People were still trying to learn Haskell from LYAH so I removed it so they'd stop thinking I endorsed it.
22:51:06 <bitemyapp> Programming in Haskell has some pretty annoying roadblocks for new self-learners. One of them is the unicode syntax.
22:51:09 <julianleviston> bitemyapp: Oh, sorry. I thought it refered to the Yorgey’s CS coure, which references it - a lot...
22:51:20 <bitemyapp> julianleviston: yes, that's not ideal either.
22:51:25 <julianleviston> bitemyapp: lol
22:51:34 <bitemyapp> julianleviston: with Yorgey's permission, I started a respin of his cis194 course.
22:51:44 <bitemyapp> I haven't had time to work on it.
22:51:49 <julianleviston> bitemyapp: sadtimes.
22:52:09 <bitemyapp> not according to my readers :P
22:52:19 <julianleviston> bitemyapp: huh?
22:52:22 <mniip> [08:44:34] <nshepperd> off the top of my head, data FFI i o = FFI ({pointer to some code that takes a i and produces o})
22:52:28 <mniip> sounds intriuingly implementable
22:52:33 <julianleviston> bitemyapp: sadtimes you haven’t had time to work on it.
22:52:36 <bitemyapp> julianleviston: http://haskellbook.com/
22:52:37 <gfixler> julianleviston: have you seen Hutton's guest lecture for Erik Meijer's course, based on Hutton's book?
22:52:46 <bitemyapp> julianleviston: I haven't had time to work on it because of the book.
22:52:49 <AshyIsMe> bloody regex, anyone used Text.Regex.Posix before?
22:52:51 <julianleviston> bitemyapp: We do need an excellent textbook / reference work… something like real world haskell but simpler, and more real world, ironically.
22:53:09 <AshyIsMe> how the hell do i match any chars up until first whitespace?
22:53:21 <bitemyapp> AshyIsMe: do you really need regex?
22:53:53 <bitemyapp> AshyIsMe: you have a backhoe and you're trying to dig a ditch with a teaspoon. Fire up Parsec.
22:53:56 <fred-fri> does haskell have an equivalent of "effective java"?
22:54:00 <bitemyapp> not yet
22:54:23 <mniip> nshepperd, you have to be very careful with the 'i' bit
22:54:36 <gfixler> AshyIsMe: "^\S*"
22:54:37 <mniip> any laziness in there and you're screwed
22:55:07 <gfixler> AshyIsMe: don't know Text.Regex.Parsec, but that's a somewhat typical way to match that
22:55:24 <AshyIsMe> gfixler: Text.Regex.Posix still matches spaces with that one
22:55:25 <bitemyapp> Text.Regex.Parsec - does it make the kessel run?
22:55:45 <julianleviston> bitemyapp: what does “Has the type” mean? 
22:55:45 <AshyIsMe> bitemyapp: i want a simple way to match some cases in some user supplied strings
22:55:51 <AshyIsMe> so yeah, this is a job for regex
22:55:59 <julianleviston> bitemyapp: that trips me up… shouldn’t it be “is of the type”?
22:56:11 <AshyIsMe> im not trying to parse html...
22:56:14 <mniip> julianleviston, that's the same
22:56:24 <julianleviston> mniip: not really.
22:56:43 <bitemyapp> julianleviston: huh?
22:56:47 <julianleviston> mniip: My friend has a child, and another child.
22:57:02 <gfixler> AshyIsMe: good, because... http://stackoverflow.com/a/1732454/955926
22:57:04 <mniip> ignoring polymorphism, any object is only of one type
22:57:14 <julianleviston> mniip: yep.
22:57:19 <AshyIsMe> λ: getAllTextMatches $ "foo bar baz" =~ "[^\\S]*" :: [String]
22:57:20 <AshyIsMe> ["foo bar baz",""]
22:57:23 <julianleviston> has type != is of type.
22:57:26 <bitemyapp> what are we talking about changing?
22:57:31 <julianleviston> nothing.
22:57:35 <AshyIsMe> gfixler: ^ see how it still includes the spaces
22:57:50 <mniip> which is why "has type" which has function semantics is equivalent to "is of type" of relational semantics
22:57:52 <AshyIsMe> [^:space:]*   does the same thing
22:57:54 <gfixler> AshyIsMe: maybe T.R.Posix doesn't doesn't have the \S thing
22:57:56 <julianleviston> is of type implies only one.
22:57:58 <gfixler> or your magic level is off
22:58:05 <bitemyapp> julianleviston: okay, I know you're trying to be helpful
22:58:08 <nshepperd> mniip: I think you only really need to implement primops with this, so you could conceivably restrict i,o to be unboxed types
22:58:10 <bitemyapp> julianleviston: but right now, it's you vs. Bob Harper
22:58:15 <gfixler> AshyIsMe: oh, you're trying to use a \S in a [] block
22:58:18 <julianleviston> bitemyapp: huh?
22:58:18 <gfixler> often those don't work in there
22:58:19 <AshyIsMe> gfixler: i can build an explicit list of allowed chars i guess 
22:58:24 <bitemyapp> julianleviston: "has the type"
22:58:27 <bitemyapp> julianleviston: I got it from Bob's work.
22:58:28 <mniip> nshepperd, hmm interesting idea
22:58:28 <Cale> fred-fri: hm... I haven't read Effective Java to know what it focuses on. If you're looking for books about stylistic approaches to the design of programs, maybe something by Bird would be interesting.
22:58:33 <mniip> nshepperd, but
22:58:33 <julianleviston> bitemyapp: That’s ok.
22:58:37 <bitemyapp> julianleviston: you want to send him an email nitpicking his wording? go ahead.
22:58:46 <mniip> nshepperd, how do you interpret a value of the type
22:58:57 <mniip> you can't be polymorphic in unboxed types
22:59:09 <bitemyapp> also common, "has type"
22:59:18 <bitemyapp> http://www.amazon.com/Practical-Foundations-Programming-Languages-Professor/dp/1107029570
22:59:21 <gfixler> AshyIsMe: why not something from Data.List.Split?
22:59:24 <bitemyapp> https://existentialtype.wordpress.com/
22:59:28 <nshepperd> oh, yeah
22:59:29 <bitemyapp> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
22:59:34 <julianleviston> to have is not quite the same as to be.
22:59:47 <julianleviston> but all good :)
23:00:12 <nshepperd> maybe not
23:00:15 <julianleviston> has the type without explanation of the fact that an only be one implies a possible multiplicity, is all.
23:00:29 <julianleviston> that there can *
23:00:35 <gfixler> bitemyapp: I'm reading Robert Harper for a meetup these day
23:00:36 <gfixler> s
23:00:39 <mniip> "is of type" is Value -> Type -> Constraint
23:00:45 <mniip> "has type" is Value -> Type
23:00:49 <gfixler> Practical Foundations for Programming Languages - we're doing a chapter per week
23:00:50 <nshepperd> or, make a box to hold the value, and just evaluate it to whnf before feeding it into the ffi op
23:00:54 <mniip> types are unique, the two are equivalent
23:00:55 <mniip> qed
23:00:58 <julianleviston> mniip: then it should be explained.
23:01:14 <mniip> julianleviston, that's type theory
23:01:21 <mniip> a bit too early for a beginner
23:01:30 <bitemyapp> julianleviston: type theory happens to be something Harper knows something about.
23:02:04 <bitemyapp> in general, if I don't have domain expertise, I use the wording of those that do.
23:02:11 <julianleviston> You’re writing a book for people. 
23:02:25 <bitemyapp> julianleviston: I didn't know that
23:02:29 <bitemyapp> I thought i was writing it for horses.
23:02:43 <julianleviston> bitemyapp: ok I won’t talk.
23:02:44 <gfixler> "Haskell for Horses" - I'd check that out
23:02:46 <mniip> I should read your book
23:02:48 * mniip <- is a pony
23:02:50 <julianleviston> aplogies if I’ve annoyed you.
23:02:55 <subleq__> I have a function compile :: AST -> String
23:02:57 <bitemyapp> julianleviston: we nitpick our own wording pretty agressively
23:03:00 <bitemyapp> aggressively*
23:03:02 <julianleviston> bitemyapp: I quite like your book so far.
23:03:14 <subleq__> the code for it looks terrible, and i want to add pretty printing
23:03:14 <bitemyapp> julianleviston: and we make scrutinize anything a reviewer mentions as being confusing
23:03:21 <subleq__> is there a way to clean that kind of thing up?
23:03:27 <mniip> gfixler, http://haskell.on-a-horse.org/
23:03:31 <bitemyapp> but if nobody objects and it's in keeping with the jargon of experts, we're not going to change it.
23:03:37 <julianleviston> bitemyapp: It’s cool. You don’t want my feedback, no worries! :)
23:03:45 <bitemyapp> julianleviston: you're fine, it just feels like a very bikesheddy thing to zero into.
23:03:54 <mniip> your feedback has been objectively criticised and proven invalid
23:03:58 <julianleviston> lol
23:04:01 <bitemyapp> julianleviston: to justify the distinction/change, I'd need to know how it relates to type theory.
23:04:02 <julianleviston> so objective.
23:04:06 <julianleviston> We’re all programmers.
23:04:13 <bitemyapp> and why it's meaningful. I don't know why it would be meaningful yet.
23:04:14 <gfixler> mniip: I'm glad we have a Haskell for cowboys
23:04:19 <julianleviston> bitemyapp: it’s not about type theory. It’s about explanation.
23:04:40 <julianleviston> bitemyapp: all I was trying to say is it’s not clear that things can have only one type at once from that.
23:04:52 <bitemyapp> okay, that's a worthwhile to thing to mention.
23:04:55 <mniip> julianleviston, you're not supposed to infer it at that point
23:05:25 <nshepperd> mniip: or, you can just live with the laziness and make sure the code asks the rts to evaluate any value before using it, I suppose
23:05:50 <gfixler> I do like quantified things in learning materials
23:05:55 <mniip> nshepperd, getLine >> return ""
23:05:57 <gfixler> it's like having a progress bar on your mental model
23:06:08 <bitemyapp> gfixler: quantified things? like what?
23:06:12 <julianleviston> bitemyapp: this stuff - writing books like this - is incredibly hard. I know you’ve put a lot of work in because it’s evident in the quality of the writing. I really like that.
23:06:14 <bitemyapp> quite curious as to what you mean.
23:06:19 <bitemyapp> julianleviston: well, my coauthor's work too.
23:06:21 <mniip> julianleviston, I suppose at the point you have an intuitive assumption about it because the inverse has not been mentioned
23:06:31 <gfixler> bitemyapp: There are two key things that you need to understand to understand foo...
23:06:35 <julianleviston> bitemyapp: yep. you = people writing it.
23:06:47 <julianleviston> mniip: lol. um.
23:07:00 <nshepperd> mniip: yes, that tells the rts to get a line and then result in ""
23:07:01 <gfixler> bitemyapp: Let's look at 3 instances of X, but note that there are dozens of instances in use.
23:07:02 <julianleviston> mniip: you don’t have to defend this.
23:07:03 <bitemyapp> gfixler: like dependencies?
23:07:11 <bitemyapp> gfixler: oh you mean more than that.
23:07:11 <gfixler> bitemyapp: no, like how many of things there are
23:07:19 <mniip> julianleviston, I see you have a problem with implied assumptions/contexts
23:07:26 <julianleviston> mniip: yes.
23:07:26 <mniip> You asked what <= is the other day
23:07:30 <julianleviston> mniip: I have such a problem.
23:07:32 <gfixler> I don't like just randomly hearing info, with no basis, no idea of the end goal
23:07:44 <bitemyapp> julianleviston: thank you. I do want your feedback. I pattern-matched on the specific recommendation as being bikesheddy. Sorry if I offended.
23:07:54 <julianleviston> bitemyapp: not at all.
23:08:04 <bitemyapp> the concern about "expressions can't have more than one type" is credible, I'll keep it in mind.
23:08:17 <julianleviston> bitemyapp: sorry, I wasn’t trying to tell you how to write your book.
23:08:21 <bitemyapp> we're tracking the progress of one reviewer who hasn't had trouble with that specifically we *think*, but
23:08:31 <bitemyapp> they've had a problem with the value/type phase separation.
23:08:44 <bitemyapp> but now I have another possible problem to keep in mind with them. I'll stew on it.
23:09:10 <bitemyapp> one problem with coming out and explicitly saying, "can have only one type" is that polymorphic values will (appear to) violate that understanding.
23:09:12 <julianleviston> bitemyapp: this is REALLY hard.
23:09:13 <gfixler> bitemyapp: I'm currently being impressed by a particular paper by conal
23:09:19 <bitemyapp> Num a => a    can become    Int, Integer, etc.
23:09:40 <gfixler> bitemyapp: specifically because it's so conversational, and I'm following it so easily
23:09:42 <julianleviston> bitemyapp: because you really need to hook up who your audience is. 
23:09:46 <gfixler> I've had trouble with the other two I've read
23:10:01 <mniip> bitemyapp, you could terminologically define "has type" to mean the most general type
23:10:13 <fred-fri> bitemyapp: the cis194 course appears much better than learn you a haskell
23:10:14 <fred-fri> thanks
23:10:16 <bitemyapp> mniip: we talk "around" principal typing and "most general type"
23:10:19 <bitemyapp> fred-fri: cheers :)
23:10:22 <bitemyapp> gfixler: which?
23:10:30 <julianleviston> bitemyapp: I don’t think you can overstate the importance of understanding your audience - effectively being explicit about THEIR type.
23:10:43 <mniip> bitemyapp, no, I mean that makes sure "has type" is still a function
23:10:45 <bitemyapp> julianleviston: we know who we're targeting.
23:10:55 <julianleviston> bitemyapp: I’m interested - who is it?
23:11:02 <bitemyapp> julianleviston: this was actually one of the debates we had with the publisher before we parted ways.
23:11:06 <gfixler> bitemyapp: http://conal.net/papers/genuinely-functional-guis.pdf
23:11:23 <bitemyapp> julianleviston: if I tell you, you either won't believe me or it'll start a discussion longer than I can do justice.
23:11:34 <julianleviston> bitemyapp: cmon give me the benefit of the doubt.
23:11:40 <bitemyapp> briefly, people that haven't programmed before.
23:11:45 <julianleviston> bitemyapp: ok.
23:11:46 <bitemyapp> some computer savvy expected. Not a lot else.
23:11:50 <julianleviston> bitemyapp: I do believe you.
23:12:02 <bitemyapp> however, this is a decision consciously made with the understanding that most of our readers will be programmers already.
23:12:08 <julianleviston> bitemyapp: have you tested it on lots of them?
23:12:20 <bitemyapp> depends on how you define lots.
23:12:29 <julianleviston> bitemyapp: between 50 and 100
23:12:35 <bitemyapp> we've spent the most time working with reviewers that are new to programming.
23:12:36 <mniip> for some locally small value of lots
23:12:46 <bitemyapp> in terms of number of people, mostly programmers.
23:13:01 <bitemyapp> We think it's (mostly) forcing us to be more careful in ways that'll make it easier to learn Haskell.
23:13:17 <bitemyapp> you can't lean on past knowledge in substantially useful ways when a programmer learns Haskell.
23:13:22 <julianleviston> bitemyapp: inevitably focussing on the low end is good for most people.
23:13:22 <bitemyapp> they rarely know anything relevant to Haskell anyway.
23:13:28 <bitemyapp> you're very lucky if they know what call by value is.
23:13:35 <bitemyapp> so why assume they'd know anything useful?
23:13:47 <julianleviston> bitemyapp: yep. 
23:13:50 <julianleviston> bitemyapp: very nice.
23:13:53 <bitemyapp> comparison/analogies are pretty useless and often counter-productive.
23:14:01 <bitemyapp> that said, it does make things harder, especially in the first couple chapters.
23:14:08 <bitemyapp> the first ~4'ish chapters were agonizing.
23:14:10 <mniip> monads are like burritos
23:14:19 <bitemyapp> I'm very glad we don't have to work on those much anymore.
23:15:40 <bitemyapp> julianleviston: we've been talking to the organizer of our local Women Who Code to see if we could get more people willing to test/review.
23:15:41 <julianleviston> bitemyapp: what do you think of explaining haskell through a lot of reading? 
23:15:57 <zomg> It's interesting to hear the logic behind choices like that in your stuff
23:16:10 <zomg> since I'm also working on some educational material like that, although not related to haskell :)
23:16:10 <bitemyapp> julianleviston: well, the book is pretty intensely focused on learning through doing. You're supposed to type the examples in and modify them, for example.
23:16:15 * gfixler spent more than a year reading; was able to do very little as a result
23:16:19 <julianleviston> bitemyapp: by reading, I mean exposing the reader to a lot of well written examples.
23:16:21 <bitemyapp> this is partly why I haven't prioritized the ebook format. You're supposed to be working - not reading.
23:16:33 <bitemyapp> we do show them a lot of examples, but you want to type them in.
23:16:34 <julianleviston> bitemyapp: have you studied educ at all?
23:16:48 <bitemyapp> I have nothing to say about that.
23:16:52 <julianleviston> bitemyapp: huh?
23:17:00 <julianleviston> bitemyapp: nothing but that sentence ;-)
23:17:32 <julianleviston> bitemyapp: because I’ve found a two-phase approach quite useful …. that is, passive, then reinforcement in the passive while also doing an active reinforcing phase.
23:17:49 <bitemyapp> there's some of that in the book because you see prose and examples, then exercises.
23:17:54 <bitemyapp> but we really prefer if people type the examples in.
23:18:09 <julianleviston> bitemyapp: passive for allowing the mind to understand on a shallow level, and for you to learn how to read well, and then active for the creating phase.
23:18:29 * hackagebot netwire-input 0.0.4 - Input handling abstractions for netwire  http://hackage.haskell.org/package/netwire-input-0.0.4 (Mokosha)
23:18:36 <julianleviston> bitemyapp: I’ve found this really useful in language learning (human languages)
23:18:56 <bitemyapp> julianleviston: my coauthor is a linguist.
23:19:05 <julianleviston> bitemyapp: we’re often better at passive skill (reading / listening) than we are creating
23:19:08 <bitemyapp> julianleviston: whether by happenstance or otherwise, we agreed on pedagogy before we started working together.
23:19:23 <julianleviston> bitemyapp: interesting, but I find most linguists, like most programmers, don’t really understand much about how we learn.
23:19:23 <bitemyapp> we learned from each other, but the broad-strokes we already agreed on I think.
23:19:40 <bitemyapp> julianleviston: she spent most of her masters teaching other people.
23:20:14 <julianleviston> bitemyapp: and most teachers actually understand very very little about teaching. Sorry, not trying to be too annoying or confrontational here. Just what I’ve found.
23:20:30 <bitemyapp> julianleviston: for the record, I haven't found most lectures or books written by profs very helpful.
23:20:35 <julianleviston> bitemyapp: and obviously this is your story, so you’ll do the judging.
23:20:41 <julianleviston> bitemyapp: yep.
23:20:41 <mniip> julianleviston, I have to say, learning haskell in fact changes the way you learn
23:20:47 <bitemyapp> julianleviston: so I feel you here, but my coauthor is a very intelligent and careful person WRT teaching.
23:20:47 <mniip> at least it did for me
23:20:47 <julianleviston> mniip: it does.
23:21:03 <julianleviston> mniip: altho I found that with most things I’ve learned.
23:21:05 <bitemyapp> julianleviston: and I know TAs/grad students that take teaching as a discipline in its own right seriously.
23:21:13 <julianleviston> bitemyapp: sweet :)
23:21:23 <mniip> I can read the definition of some mealy/moore mumble-jumble and understand what's it about
23:21:31 <julianleviston> bitemyapp: I learned teaching from learning.
23:21:44 <gfixler> I like an empathetic approach to didacticism, too
23:21:44 <bitemyapp> julianleviston: both, for me.
23:22:03 <mniip> meanwhile in pre-haskell times I'd have to read a lot of articles/things explaining what those are and how are they used
23:22:05 <julianleviston> bitemyapp: you taught learning from teaching?
23:22:11 <julianleviston> bitemyapp: heh sorry :)
23:22:28 <bitemyapp> teaching from teaching, teaching from learning.
23:22:39 <julianleviston> mniip: interesting, but I have most of the semantic of things, it’s the lexicon and syntax that bother me, mostly.
23:22:49 <gfixler> I've had a number of people try to teach me Haskell (and other) things, and when I don't understand, we get into a kind of confrontation, where I say "Yes, but I don't get that," and they just reiterate it more forcefully
23:23:12 <gfixler> I like to have people explain things back to me, and I ask them questions if I don't see how they're seeing it
23:23:16 <bitemyapp> gfixler: breadth of experience in teaching a particular topic can help.
23:23:26 <bitemyapp> gfixler: then you can have fallback explanations / a mental runsheet
23:23:33 <mniip> julianleviston, oh yeah, remember that time when we recursively iterated through terms?
23:23:36 <gfixler> then I can say "Oh, you're thinking that x is a foo here. Ah, I see. X is actually..." and I lead them from their understanding back to mine
23:23:36 <zomg> gfixler: there's a disconnect between experts and beginners where the expert feels something is so obvious the begniner has to know it
23:23:51 <julianleviston> mniip: you mean yesterday?
23:23:58 <mniip> julianleviston, you asked what something is and I provided an answer with even more unknown words
23:24:10 <gfixler> zomg: that happens to me now, and it's exciting :)
23:24:10 <julianleviston> mniip: yes. I remember that. 
23:24:17 <julianleviston> mniip: I didn’t like it.
23:24:22 <mniip> not sure about other people, but I can learn that way
23:24:25 <mniip> also thanks to haskell
23:24:39 <gfixler> it's hard to empathetically teach from a book
23:24:40 <zomg> gfixler: yeah, the trick is to spot when it happens so you can explain it better
23:24:48 <gfixler> but it can be done, if you know common gotchas
23:24:49 <julianleviston> mniip: my problem was that the definitions ended up being somewhat recursive.
23:24:58 <mniip> julianleviston, not really
23:25:07 <gfixler> e.g. "At this point, you might be thinking that x is a foo. This is a common misstep - keep in mind that x..."
23:25:08 <julianleviston> mniip: sorry, self-referential was what I meant.
23:25:12 <mniip> we only hit an issue when you asked what a set is
23:25:23 <mauke> gfixler: ♥
23:25:30 <mniip> because that's a complicated mathematical topic that is fixed with an intuitive assumption
23:25:51 <gfixler> I also like a bit of repetition - can't stand the thing papers do - define something once in page one, and then in page 8, use it, like I remember, like some purely logical entity
23:25:53 <julianleviston> mniip: no, the problem was I didn’t know enough of the terminology to usefully understand what you were trying to say.
23:26:32 <gfixler> I feel like a List Zipper with most papers, flipping back and forth, reminding myself of what some symbol means
23:26:36 <mniip> julianleviston, haskell gives you the skill to learn from these
23:27:01 <julianleviston> mniip: I looked up what you were trying to explain to me after we talked and found a one sentence explanation that worked just fine.
23:27:03 <mniip> go to hackage, open a random package by edward kmett, open a random file
23:27:15 <mniip> what the hell is a Representable? ah, it's an addition to Indexable
23:27:19 <mniip> what the hell is Indexable
23:27:19 <julianleviston> mniip: I’m pretty aware of this :) 
23:27:28 <gfixler> mniip: MY GOD, IT'S FULL OF STARS
23:27:43 <julianleviston> mniip: the trouble is when they start looping over, and then there’s no bottom explanation.
23:27:48 <mauke> full of s t a b s, more like
23:28:10 <mniip> mauke, sensible chuckle
23:28:21 <julianleviston> mniip: and perhaps I don’t feel like spending 20 minutes looking up definitions and keeping them in my mind only to find out that the thing they’re talking about is an incredibly simple structure.
23:28:23 <mniip> julianleviston, this is haskell
23:28:24 <bitemyapp> i s t a b u
23:28:26 <mniip> there always is
23:29:28 <julianleviston> mniip: my favourite was “morphism” and “arrow” from that youtube video where he was using CT terms, and I was supposed to know that.
23:29:33 <mniip> if it's defined in haskell it can be split into combinations of a couple simple primitive definitions
23:29:54 <julianleviston> mniip: not “arrow” from haskell arrows, or the other def’s of morphism from other parts of math or anything. Context! :)
23:30:36 <mniip> morphisms and arrows have a pretty damn fixed meaning in context of CT
23:30:42 <julianleviston> mniip: yes.
23:30:50 <mniip> they are things that make up categories, the subject of CT
23:30:52 <julianleviston> mniip: but this video was on lenses, not CT.
23:30:57 <julianleviston> mniip: yes.
23:31:00 <mniip> lenses ~ CT
23:31:09 <julianleviston> mniip: ~ = ?
23:31:27 <mauke> ~ = =
23:31:30 <mniip> In haskell, ~ is the type equivalence operator
23:31:38 <julianleviston> ah ok.
23:31:40 <julianleviston> thanks. 
23:31:48 <julianleviston> that’s actually very handy!
23:32:26 <bitemyapp> it really is.
23:32:46 <julianleviston> > "hello" ~ ['h', 'e', 'l', 'l', 'o']
23:32:47 <lambdabot>      Pattern syntax in expression context: ~['h', 'e', 'l', ....]
23:32:49 <julianleviston> this won’t work.
23:33:09 <mauke> none of those are types
23:33:28 <julianleviston> > [Char] ~ String
23:33:29 * hackagebot netwire-input-glfw 0.0.4 - GLFW instance of netwire-input  http://hackage.haskell.org/package/netwire-input-glfw-0.0.4 (Mokosha)
23:33:30 <lambdabot>      Not in scope: data constructor ‘Char’
23:33:30 <lambdabot>      Perhaps you meant one of these:
23:33:30 <lambdabot>        ‘Chr’ (imported from Text.PrettyPrint.HughesPJ),
23:33:40 <WashIrving> mniip: Thanks again for the pointers. Also, wow, 'recursion-schemes'.
23:33:49 <mauke> > 42 :: (Char ~ Char) => Int
23:33:51 <lambdabot>  42
23:34:05 <bitemyapp> > 42 :: (Char ~ Bool) => Int
23:34:06 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Char’
23:34:06 <lambdabot>      In the expression: 42 :: (Char ~ Bool) => Int    Couldn't match type ‘Ch...
23:34:06 <lambdabot>      Inaccessible code in
23:34:07 <bitemyapp> kaboom
23:34:12 <bitemyapp> I love kaboom.
23:34:28 <mauke> > 42 :: (Int ~ a) => a
23:34:29 <lambdabot>  42
23:35:10 <julianleviston> None of this makes sense to me, but that’s fine.
23:35:14 <mauke> :t id :: (a ~ b) => a -> b
23:35:15 <lambdabot> b -> b
23:35:26 <mauke> julianleviston: what's unclear in the first one?
23:35:51 <mniip> :t (undefined :: String ~ f a => a)
23:35:52 <lambdabot> Char
23:35:58 <fishburne> Is there someone with experience in Spock web framework?
23:36:10 <julianleviston> mauke: assuming this is the first one? 42 :: (Char ~ Char) => Int
23:36:17 <mauke> yes
23:36:20 <julianleviston> mauke: ok. 
23:36:39 <julianleviston> mauke: so… 42 is 42. I get that. :: means um has type… 
23:36:44 <mauke> right
23:36:45 <julianleviston> mauke: then I get lost
23:36:58 <mauke> have you seen => before?
23:37:03 <julianleviston> yeah
23:37:09 <mniip> 'a => b' is a type that is b, but only when conditions in a are met
23:37:12 <julianleviston> it specifies the type of the thing on the right
23:37:19 <mauke> no
23:37:23 <julianleviston> mniip: I didn’t think it was technically a constraint?
23:37:30 <mniip> it is called exactly that
23:37:33 <mauke> it's CONSTRAINT => TYPE
23:37:33 <mniip> a constraint
23:37:39 <julianleviston> ok. 
23:37:57 <julianleviston> so what dose (Char ~ Char) mean? Why not just write (Char) => Int ? Which makes no sense to me
23:38:03 <mauke> Char is not a constraint
23:38:05 <mniip> Char is a type
23:38:08 <mniip> (Char ~ Char) is a constraint
23:38:17 <bitemyapp> asserting two different type variables are equal makes a type less general so it can be thought of as being a constraint in those terms I think.
23:38:26 <mniip> (a ~ b) is a condition that is "met" when a and b are the same type
23:38:37 <julianleviston> mniip: THAT makes more sense to me.
23:38:53 <julianleviston> mniip: but I still really don’t know what that means
23:39:13 <julianleviston> why not just write 42 :: Int ?
23:39:16 <mauke> "42 has type Int, provided Char is the same type as Char"
23:39:22 <mauke> julianleviston: because this is a silly example
23:39:23 <mniip> because that wouldn't demonstrate the meaning of ~
23:39:26 <julianleviston> mau ehm… 
23:39:35 <julianleviston> mniip: but this doesn't.
23:39:35 <mniip> otherwise nothing's stopping you
23:39:58 <julianleviston> I actually don’t know what that whole expression means… 
23:40:12 <mauke> it means "42 has type Int, provided Char is the same type as Char"
23:40:13 <julianleviston> it also doesn’t seem to work in GHCi
23:40:33 <julianleviston> mauke: but is it an expression?
23:40:36 <mauke>     Illegal equational constraint Char ~ Char
23:40:36 <mauke>     (Use GADTs or TypeFamilies to permit this)
23:40:52 <mauke> julianleviston: er. yes?
23:41:01 <julianleviston> mauke: what’s its value?
23:41:07 <mauke> EXPR := EXPR :: TYPE
23:41:10 <mniip> (I# 42#)
23:41:13 <mauke> julianleviston: 42
23:41:14 <mniip> I mean 42
23:41:20 <julianleviston> oh.
23:41:25 <julianleviston> why can’t you just write 42 ?
23:41:32 <julianleviston> or… how does it differ from 42
23:41:37 <mauke> :t 42
23:41:38 <lambdabot> Num a => a
23:41:41 <mauke> :t 42 :: Int
23:41:43 <lambdabot> Int
23:41:47 <julianleviston> :t 42 :: (Char ~ Char) => Int
23:41:48 <lambdabot> Int
23:41:51 <julianleviston> Ahhhh
23:41:56 <julianleviston> eureka.
23:41:58 <julianleviston> Thank you! LOL
23:42:07 <julianleviston> it’s very silly.
23:42:14 <julianleviston> but can’t you just say
23:42:18 <julianleviston> :t 42 :: Int
23:42:19 <lambdabot> Int
23:42:26 <julianleviston> yeah, so I still don’t get the difference.
23:42:29 <mniip> :t (undefined :: String ~ f a => a)
23:42:30 <lambdabot> Char
23:42:48 <julianleviston> mniip: you always make things way more complicated than i understand, sadly.
23:42:51 <mauke> what difference?
23:43:04 <julianleviston> mauke: is there a diff between 42 :: Int and 42 :: (Char ~ Char) => Int ?
23:43:07 <mauke> no
23:43:10 <mniip> julianleviston, less complicated things seem to be rejected by you because of being useless
23:43:10 <julianleviston> oh.
23:43:24 <julianleviston> mniip: in this instance, ok.
23:43:41 <mauke> Char ~ Char is trivially true
23:43:44 <julianleviston> mniip: so this needs a complicated example to explain?
23:43:49 <mniip> no
23:43:55 <julianleviston> ok.
23:43:58 <mauke> this isn't an explanation, this is examples
23:44:01 <mniip> what I'm saying is
23:44:05 <julianleviston> lol
23:44:06 <mniip> I give you a simple example
23:44:11 <mniip> you say "who not just"
23:44:15 <mauke> *why
23:44:18 <mniip> why*
23:44:24 <julianleviston> mniip: I’m trying to work out what ~ does.
23:44:28 <mniip> I give you a complex example
23:44:32 <mniip> "that's too complicated"
23:44:35 <fishburne> does any one know how to access a POST array variable in Spock web framework. For example, when there are multiple checkboxes with name like student_name[]. 
23:44:37 <julianleviston> mniip: I’m sorry about that.
23:45:13 <mniip> julianleviston, it is a condition, a constraint, that is only satisfied when types to the right and to the left are the same
23:45:20 <mniip> that's it
23:45:25 <julianleviston> ah ok.
23:45:25 <mauke> julianleviston: it's like we're trying to explain what + does and one of the examples is 42 + 0. and you're like "why not just write 42?"
23:45:49 <mniip> "Your 42 + 1 example is too complicated"
23:46:02 <julianleviston> mauke: I’m sorry about that, but your examples aren’t enlightening me. My bad. 
23:46:14 <julianleviston> am I really that frustrating?
23:46:46 <mauke> hmm. I wouldn't say frustrating
23:46:51 <julianleviston> ok let’s look at this undefined one… but there, I’m going to want to know what undefined is.
23:47:03 <mauke> :t undefined
23:47:04 <lambdabot> t
23:47:10 <julianleviston> what is t?
23:47:14 <mauke> a type variable
23:47:23 <mauke> undefined can be used at any type
23:47:30 <mniip> julianleviston, it gives an impression that you're not even trying to understand
23:47:33 <julianleviston> oh… ghci returns undefined :: a gotcha
23:47:38 <julianleviston> mniip: my apologies.
23:47:39 <mauke> > undefined :: Int
23:47:40 <lambdabot>  *Exception: Prelude.undefined
23:47:48 <mauke> and if you look at its value, it explodes
23:48:03 <julianleviston> I don’t understand this syntax.
23:48:03 <julianleviston> (undefined :: String ~ f a => a)
23:48:15 <julianleviston> that means undefined has type...
23:48:15 <mauke> but that's the same syntax as before?
23:48:34 <bitemyapp> julianleviston: undefined has any type you want :)
23:48:38 <mniip> we take the value undefined, and annotate it to the type 'String ~ f a => a'
23:48:39 <nshepperd> (undefined :: (String ~ f a) => a)
23:48:42 <julianleviston> type String which is equivalent to f a => a?
23:48:44 <julianleviston> guh
23:48:50 <mniip> no
23:48:52 <bitemyapp> julianleviston: type String = [Char]
23:48:52 <mniip> see above
23:48:52 <julianleviston> nshepperd:  OMG I love you
23:48:53 <mauke> julianleviston: ah, precedence
23:49:03 <julianleviston> bitemyapp: yeah, I know that one.
23:49:05 <bitemyapp> julianleviston: f ~ [], a ~ Char
23:49:06 * nshepperd can see the future
23:49:15 <bitemyapp> julianleviston: I figured, just building up to that bit.
23:49:23 <bimbash> from LYAH
23:49:23 <bimbash>  Let's take our good friend, the max function. It looks like it takes two parameters and returns the one that's bigger. Doing max 4 5 first creates a function that takes a parameter and returns either 4 or that parameter, depending on which is bigger. Then, 5 is applied to that function and that function produces our desired result. That sounds like a mouthful but it's actually a really cool concept.
23:49:35 <bimbash> how does this correspond to 
23:49:35 <bimbash>  Let's examine the type of max. It's max :: (Ord a) => a -> a -> a. That can also be written as max :: (Ord a) => a -> (a -> a). That could be read as: max takes an a and returns (that's the ->) a function that takes an a and returns an a. That's why the return type and the parameters of functions are all simply separated with arrows.
23:50:08 <mauke> String ~ f a  >>>  [Char] ~ f a  >>>  [] Char ~ f a  >>>  ([] ~ f, Char ~ a)
23:50:31 <julianleviston> so...
23:50:43 <julianleviston> (String ~ f a) means String is type equivalent to the function on a?
23:50:43 <mniip> julianleviston, I used undefined because I am too lazy to provide a value while I only need a type
23:50:47 <julianleviston> f of a?
23:50:55 <mauke> bimbash: uh. "perfectly"?
23:51:10 <mauke> julianleviston: parameterized types
23:51:29 <mniip> julianleviston, it's a type constructor f applied to type a
23:51:35 <julianleviston> mniip: yep.
23:51:44 <julianleviston> mniip: like Maybe Int or something.
23:51:45 <zipper> mniip: Such as `Maybe a`?
23:51:46 <mniip> yes
23:51:58 <mniip> String is [Char]
23:52:05 <bimbash> OK, is "Doing max 4 5 first creates a function that takes a parameter and returns either 4 or that parameter" basically the bracketed (a->a) 
23:52:06 <mniip> which is the [] type constructor applied to type Char
23:52:19 <julianleviston> I strill don’t know what this does tho… (undefined :: String ~ f a => a)
23:52:32 <mniip> which is why when we say (String ~ f a) the compiler understands that f is [] and a is Char
23:52:34 <mauke> bimbash: I don't understand the question
23:52:34 <bimbash> that is the partially applied function, max 4 is now a function that takes 5 
23:52:42 <mniip> or as mauke said, (f ~ [], a ~ Char)
23:52:44 <julianleviston> String is equiv to some type constructor applied to a concrete type?
23:52:50 <bimbash> sorry, hard for me to write cleraly
23:53:04 <bimbash> OK
23:53:08 <zipper> mniip: what does `~` mean?
23:53:08 <mniip> julianleviston, type String = [Char]
23:53:17 <bimbash> basically in the 2nd and 3rd paragraphs
23:53:18 <bimbash> http://learnyouahaskell.com/higher-order-functions
23:53:18 <mniip> zipper, hahaha we've come full circle
23:53:32 <mauke> bimbash: let's assume Int. then max :: Int -> (Int -> Int);  max 4 :: Int -> Int;  (max 4) 5 :: Int
23:53:44 <julianleviston> mniip: hahahahaha :) zipper.
23:54:09 <julianleviston> (undefined :: String ~ f a => a) Oh… the f is [] and the a is Char ?
23:54:14 <mniip> yes
23:54:16 <zipper> I was serious :( I understand it as being "is"
23:54:18 <julianleviston> mniip: oh … that’s what you said above.
23:54:31 <julianleviston> but I didn’t get that at all from what you said.
23:54:39 <bimbash> is the author trying to match up the max :: (Ord a) => a -> a -> a  AND max :: (Ord a) => a -> (a -> a), to the previous paragraph talking about partial application
23:54:40 <mauke> zipper: sure, but this whole discussion is an explanation of what ~ means
23:54:41 <mniip> let
23:54:45 <mauke> zipper: it's just that you came in in the middle
23:54:51 <bimbash> ahh i think you answered it
23:54:54 <julianleviston> zipper:  they’re laughing because I’ve been asking the very same question.
23:55:04 <mniip> let's substitute with [] and a with Char
23:55:11 <julianleviston> zipper:  and been VERY SLOWLY getting there
23:55:23 <julianleviston> ok I think I get it now.
23:55:25 <mniip> (undefined :: [] Char ~ [] Char => Char)
23:55:29 <julianleviston> thanks everyone. Sorry I’m so slow.
23:55:32 <bimbash> mauke: so the max 4 is the (a->a) in max :: (Ord a) => a -> (a -> a)
23:55:38 <mniip> the context is trivially true and thus it's dropped off
23:55:40 <bimbash> mauke:?
23:55:47 <mauke> bimbash: yes
23:55:54 <bimbash> mauke:thanks alot !
23:56:02 <julianleviston> I find this syntax very confusing, though. 
23:56:25 <mniip> it is unambiguous though
23:56:40 <julianleviston> mniip: if you know all the precedence rules.
23:57:07 <mniip> true, it was my oversight that I didn't mention ~ binds tighter than =>
23:57:10 <julianleviston> I wish you could ask Haskell to add all the parens.
23:57:17 <julianleviston> mniip: Oh! does it?
23:57:23 <julianleviston> mniip: ok cool.
23:57:27 <mauke> wtf
23:57:38 <julianleviston> mniip: I’ve never really understood precedence very easily.
23:57:47 <julianleviston> mniip: not 2 sure why.
23:58:37 <julianleviston> I’m actually still completely unsure how ~ would be practically useful, but I’ll now know when I see it.
23:58:43 <mniip> just like * has higher precedence than +
23:58:49 <mniip> ~ has higher precedence than =>
23:59:11 <mauke> julianleviston: personally I've never used it
23:59:17 <julianleviston> I didn’t know that either. I guess that’s a function of having learned about 10 languages in my life/
23:59:36 <mniip> mauke, you should read my article thingy!
23:59:51 <mniip> http://mniip.com/pages/BidirectionalTypeFamilyInference
