00:05:23 <ttt_fff_> i'm about to build a Haskell DSL -> JavaScript compiler for fun. Is there a recommended set of JavaScript immutable libraries? (Things like Map, Set, List, ...)
00:49:21 <naudiz> :t (<>)
00:49:22 <lambdabot> Monoid m => m -> m -> m
01:20:11 <AshyIsMe> AaronFriel: i ended up writing a blog post with an intro to stack from a beginners point of view: http://aaronash.com.au/posts/helloworldhaskell/
01:20:38 <AshyIsMe> AaronFriel: not sure how useful it is but it might help some people new to stack/haskell
01:22:53 <AaronFriel> AshyIsMe: Thanks for pinging me on that, I'm deep in my own project but I opened your post up. I'll take a look in a moment
01:28:18 <AshyIsMe> we were talking someone through getting going with stack the other night, thought it'd make sense to put it down somewhere a bit more permanent
02:02:26 <chimpinspace> AshyIsMe: How is stack different from cabal-install?
02:05:26 <bigbarba> hi everybody
02:07:29 <bigbarba> I'm studying the type inference algorithm. There is something in the Exp language that I don't quite understand. I know this is not the exact topic, but I guess you know something about functional languages
02:10:30 <bigbarba> we can use v to denote a sintax element, and D to denote a domain.
02:10:31 <bigbarba> We can use v?D to have one of the following:
02:10:31 <bigbarba> - true if there is a d in D associated to v,
02:10:31 <bigbarba> - Bottom (the undefined symbol) if there is not d in D associated to v,
02:10:31 <bigbarba> - false otherwise...
02:10:40 <bigbarba> what is the "otherwise"?
02:11:13 <bigbarba> are there chances other than v having or not aving a d in D associated?
02:18:07 <Lemmih> bigbarba: Might be a mistake. Or the text was copied incorrectly. Or you're reading it wrong, somehow.
02:19:10 <bigbarba> ok, I'll go on and see if that makes more sense later. Thanks
02:33:11 <AshyIsMe> chimpinspace: it doesnt break the world all the time
02:33:42 <AshyIsMe> chimpinspace: also it shares built packages between sandboxes instead of rebuilding the whole world every time
02:34:04 <AshyIsMe> chimpinspace: there's a good post here: https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
02:36:43 <ddellacosta> so, is there a way to do this?  I can't seem to figure out how to refer to 'x' inside the where sub-expression: let f = \x -> y + z where y = x + 2; z = 1
02:37:27 <dramforever> ddellacosta: you cannot use where there
02:37:35 <ddellacosta> dramforever: okay, thanks for confirming that
02:37:42 <dramforever> you could use something like let f = \x -> let ... in y + z
02:37:50 <dramforever> where is really tricky
02:37:53 <ddellacosta>  yeah, I've got a different version w/let actually
02:38:00 <ddellacosta> was just curious if there was a way w/where
02:38:35 <ddellacosta> it's funny, I've started feeling relatively comfortable with more complex algebraic structures in Haskell
02:38:40 <ddellacosta> but stuff like this still trips me up. :-p
02:39:29 <dramforever> ddellacosta: I only write where clauses in top level functions
02:39:41 <dramforever> that's the most common way
02:39:42 <ddellacosta> dramforever: gotcha, I'll keep that rule of thumb in mind
02:39:47 <dramforever> ddellacosta: don't
02:39:53 <dramforever> that's only what I do
02:39:54 <ddellacosta> dramforever: no?
02:40:22 <ddellacosta> I guess I should simply get a deeper grasp of how where is evaluated...but it's good to have simple heuristics when you start
02:40:41 <dramforever> ddellacosta: where is desugared into let
02:41:19 <Vomit_> ddellacosta: i guess the f = \x ->  is deliberate, if not you can just write f x = ... and add where clauses in which you can use x
02:43:07 <ddellacosta> dramforever: okay thanks, will dig deeper into it
02:43:11 <dramforever> =) yw
02:43:31 <ddellacosta> Vomit_: yeah, this was simply to see if it worked in the lambda context...
02:45:55 <minad> hi! I am wondering about pretty printing. What do you prefer? GenericPretty or pretty-show. The one polutes the namespace with instances, the other feels like a hack by parsing with happy etc. Which one do you prefer? 
02:47:20 <minad> with polluting I mean that one has to derive always from Generic and add these Out instances, which also doesn't feel so nice
02:47:27 <srhb> I don't think instances are really any kind of namespace pollution.
02:47:28 <srhb> Ah
02:47:53 <minad> only that I have to add deriving (Generic) to every data
02:49:20 <chimpinspace> AshyIsMe: yes I have read it. But I can't get the reasons it is different, except the author says it does not break things. What are the situations in which cabal break things while stack does not?
02:49:24 <minad> if I only use deriving (Show), this is not sufficient. There has to be an Out instance which is magically made by deriving (Generic)
02:49:47 <minad> so it seems I cannot use it for arbitrary data structures 
02:51:21 <srhb> minad: I don't see the problem. Without looking, I guess there's a instance Generic a => Out a ... somewhere
02:51:35 <srhb> minad: Show has very specific invariants, so I don't see how that factors in. :)
02:52:28 <minad> srbh: yes, there is such an instance. however if I have a datastructure made of my own types and library types I cannot pretty print this since the library types are not Generic
02:53:01 <srhb> minad: Can't you just standalone derive them?
02:53:28 <minad> srhb: how is this done, a standalone deriving? I mean this is generated with -XDeriveGeneric
02:54:17 <srhb> minad: deriving instance Generic TourType
02:54:37 <srhb> Your*
02:54:47 <srhb> minad: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#stand-alone-deriving
02:54:52 <minad> srhb: ok thx, could have probably hoogled that :)
02:55:15 <srhb> minad: Specifically: "The standalone deriving declaration does not need to be in the same module as the data type declaration."
02:55:55 <minad> yeah otherwise it wouldn't make sense. but how does this relate to these weird orphan instances?
02:56:38 <srhb> minad: Follow the link in the manual. :)
02:57:28 <dramforever> srhb: yes StandaloneDeriving really rocks
02:57:29 <minad> srhb: asking without looking... you should have just given me the link, not the syntax ;)
02:57:35 <srhb> minad: :-)
02:57:37 <dramforever> makes debugging in ghci much easier
03:02:21 <kuribas> How do you handle nested conditionals?
03:02:29 <GLM> How can I have a seperate variabe in a foldr to count how many values I've seen so far?
03:02:46 <srhb> GLM: Tupleize your accumulator
03:03:11 <kuribas> like myfun x y | x == 2 && y == 3 = 4 | x == 2 && y == 4 = 2 | otherwise = 1
03:03:30 <dramforever> GLM: you can do that by having a separate variable
03:03:40 <dramforever> no I'm not joking
03:03:48 <srhb> GLM: foldr (\x (acc, num) -> (..., num+1) (unitvalue, 0) [...]
03:04:12 <GLM> Thanks all
03:04:16 <srhb> Be careful with strictness and such.
03:04:29 <dramforever> foldr (\x acc n -> ... acc (n + 1)) blah [...] 1
03:04:32 <dramforever> or 0
03:04:52 <kuribas> The best solution I found is multiWayIf, but I wonder if there is a better way.
03:05:08 <dramforever> kuribas: is it long?
03:05:16 <dramforever> I mean, longer than that example
03:05:20 <kuribas> dramforever: 3 tests
03:05:37 <dramforever> if it were longer you could use lookup
03:05:44 <dramforever> :t lookup
03:05:45 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:05:59 <dramforever> it's simple enough that if the table is static, ghc can optimize it away
03:06:16 <dramforever> s/can/might be able to/
03:07:35 <kuribas> dramforever: http://lpaste.net/137386
03:07:45 <kuribas> a table will not work.
03:07:55 <dramforever> oh
03:08:14 <dramforever> =(
03:08:31 <srhb> kuribas: Unrelated note: Why not error "find midway" instead of undefined -- find midway
03:08:47 <dramforever> actually I really want an arithmetic if sometimes
03:08:47 <kuribas> srhb: I haven't implemented it yet :-)
03:08:53 <srhb> kuribas: Yes, exactly.
03:08:53 <minad> srhb: standalone deriving doesn't work. the library doesn't expose the constructor :/ they don't want to be pretty printed. I need yet another ghc extensions OverwriteModuleExports :-P
03:09:04 <srhb> kuribas: undefined = error "undefined"
03:09:15 <srhb> kuribas: prefer error "Not implemented yet, midway"
03:09:15 <kuribas> srhb: oh I see...
03:09:17 <srhb> :)
03:09:32 <kuribas> srhb: right, but I was going to implement right away.
03:09:36 <srhb> OK. :P
03:09:43 <kuribas> srhb: I'll remember your suggestion though
03:10:05 <dramforever> kuribas: I would recommend a hole there
03:10:15 <dramforever> and -fdefer-typed-holes or something like that
03:10:46 <kuribas> I always use undefined, since that was recommended in RWH
03:11:30 <srhb> minad: Oh well. It sounds like you need to generate a bunch of pretty printers, and in that case there's no good solution. I tend to just write standalone pretty printers, but of course that's cumbersome for many similar ones.
03:11:47 <srhb> kuribas: Many recommendations in RWH can be safely ignored, forgotten and never spoken of again.
03:12:03 <kuribas> srhb: like?
03:12:07 <srhb> Well, that one. :P
03:13:20 <minad> srhb: either use pretty-show which is less flexible, use my own types which are isomorphic to the lib types or write the Out instance by hand. plenty of possibilities :)
03:14:25 <srhb> minad: Actually I'm a little confused about the types not being exported. That sounds like you won't even be able to newtype them. I wonder when that's desirable.
03:15:22 <srhb> minad: You won't even be able to write type signatures with those types -- that's weird. What module is this?
03:15:51 <srhb> (In other words I would expect these types to be only for internal use of whatever module we're talking about.)
03:15:57 <minad> srhb: parsec sourcepos
03:16:09 <kuribas> srhb: should I put -fdefer-typed-holes in my cabal file?
03:16:53 <srhb> kuribas: Doesn't that just defer the error until runtime?
03:16:55 <minad> srhb: they provide accessors for everything. is this usual coding style? seems like c++ private?
03:17:28 <srhb> minad: Mostly _data(/value)_ constructors are hidden if some kind of sanitation is required
03:17:44 <srhb> minad: Ie. you can only create such values by using functions (smart constructors, as they are called)
03:17:48 <kuribas> multiwayif crashes hlint :-(
03:18:46 <srhb> kuribas: Usually -fwarn-typed-holes is all you want, which is on my default. 
03:18:52 <srhb> by*
03:18:55 <kuribas> srhb: ok
03:19:58 <dramforever> oh sure since you are going to write it in right away
03:20:52 <srhb> kuribas: Can you link the module in question?
03:20:59 <srhb> Er
03:21:01 <srhb> Wrong person
03:21:06 <srhb> minad: Can you link the module in question?
03:23:32 <minad> srhb: yes, Text.Parsec.Pos. it works and has these smart constructors as you described. I am not using the type now in my data structure
03:23:55 <srhb> minad: OK, I'm just confused because that module does seem to export SourcePos
03:24:00 <srhb> Which I assume is the type you want to get at.
03:25:25 <srhb> minad: Or more clearly, it exports the type constructor SourcePos, not the value constructor SourcePos. But you don't need the latter to standalone derive instances.
03:26:14 <minad> yes, exactly. the value constructor is missing and made opaque with a smart constructor as you described
03:26:34 <minad> ah you say it should work?
03:26:39 <srhb> minad: Yes.
03:26:55 <srhb> Unless I'm not awake or something. :P
03:26:58 <minad> The data constructors of `SourcePos' are not all in scope
03:26:58 <minad>         so you cannot derive an instance for it
03:26:58 <minad>     In the stand-alone deriving instance for `Generic SourcePos'
03:27:18 <minad> Can't make a derived instance of `Generic SourcePos`
03:27:23 <srhb> Huh, okay. I am wrong then.
03:28:03 <minad> I think this generic needs it. maybe has something to do with that, not only with the standalone deriving?
03:28:38 <minad> hmm but the error message suggest that standalone deriving is the culprit
03:28:39 <srhb> minad: Yes. I don't exactly understand the requirement, because it's not needed for eg. Typeable, but I suppose that's actually Typeable being a special case, not Generic.
03:29:12 <srhb> Yes, actually, that does make sense now. Sorry for the misinformation.
03:30:00 <minad> srhb: thx a lot. if you know about typeable, do you also know about uniplate?
03:30:22 <srhb> Afraid not.
03:30:23 <kuribas> It would be nice to have a literate programming tool for haskell.
03:30:28 <srhb> kuribas: Don't we?
03:30:43 <srhb> kuribas: Or are you referring to something more specific than lhs?
03:30:51 <kuribas> srhb: I am using markdown+lhs with pandoc, but you don't get cross references.
03:31:00 <srhb> Ah.
03:31:20 <kuribas> srhb: In Knuth web each function has a link to functions it uses, and functions that use it.
03:31:21 <minad> srhb: ok, I think I am trying to use too many of those code generating extensions to avoid boilerplate. I should write by hand :D
03:31:52 <srhb> minad: Well as far as I can see you're talking about a single type that you want to pretty print. imho that only warrants writing a printSourcePos function :)
03:32:16 <srhb> Of course, not having the data constructor is annoying even there.
03:32:20 <kuribas> srhb: it would be nice to have automatic hyperlinks to definitions in the source.
03:32:27 <srhb> kuribas: Yes indeed.
03:34:22 <srhb> I wonder if there would be a market for one-way data deconstructors.
03:34:44 <srhb> exporting SourcePos{SourcePos-} -- allowing only pattern matching and not construction of SourcePos-values.
03:34:50 <srhb> That seems very useful.
03:36:33 <minad> srhb: it is no problem to write it. I am just looking for smart ways since I don't know haskell its limitations well
03:36:55 <srhb> minad: It isn't? I don't see how, since I can't pattern match on SourcePos
03:37:18 <Peaker> srhb: why not export catas/traversals instead?
03:37:30 <srhb> Peaker: Care to elaborate?
03:37:38 <srhb> I'm not sure if that gives you the same power.
03:37:43 <srhb> (Probably does!)
03:37:54 <minad> no, I mean to solve my problem. I cannot pattern match. I am unwrapping sourcepos now
03:38:21 <Peaker> srhb: A Prism is equivalent in power to a data constructor (modulo exhaustiveness checking)
03:38:38 <srhb> Peaker: Well that's certainly interesting. :)
03:38:48 <Peaker> srhb: A Prism consists of "Review" (construct) and "Traversal" (deconstruct)
03:39:02 <Peaker> srhb: you can export whichever part of the prism
03:39:18 <srhb> Peaker: I'll have to look up prisms then. Right now I don't understand how Traversals work at all.
03:39:53 <kuribas> Aren't traversals just listlike things?
03:39:57 <Peaker> they apply a function you give them to all the elements and then combine all the results Applicative-ly back to the original type
03:40:29 <kuribas> Peaker: so a fold?
03:40:52 <Peaker> kuribas: a fold doesn't do the recombination
03:41:22 <Peaker> for example, a traversal of the first in a list would be:  first f [] = pure [] ; first f (x:xs) = (:xs) <$> f x
03:41:55 <srhb> Peaker: Can you dumb it down? Assuming I have a data Foo = Foo' Bar Baz -- and I export a prism for Foo, how can I use a traversal to manipulate the values of Bar and Baz without having Foo' in scope?
03:42:03 <Peaker> > let first f [] = pure [] ; first f (x:xs) = (:xs) <$> f x in ([1..10] ^? first, [] ^? first)
03:42:05 <lambdabot>  (Just 1,Nothing)
03:43:08 <benma> hey everyone. is there a stack equivalent of `cabal run`? the wiki says 'stack build && stack exec <program-name>', but that is not so helpful
03:43:45 <Peaker> srhb: You'd have a: Prism' Foo (Bar, Baz)
03:43:45 * hackagebot JuicyPixels 3.2.5.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.5.3 (VincentBerthoux)
03:43:52 <benma> b/c 1) it is compiled and not ran (as in runhaskell), and 2) the compiled binary is somewhere deep inside .stack-work/ and not on my PATH
03:44:29 <Peaker> srhb: foo :: Prism' Foo (Bar, Baz), and then you can use:  fooVal ^? foo :: Maybe (Bar, Baz)
03:44:41 <srhb> Peaker: OK, so some combinator used with a function \(bar, baz) -> ... allows me to read, but not create Foo values?
03:44:49 <srhb> I see.
03:44:57 <Peaker> srhb: (to extract), or:  fooVal & foo . _1 .~ newBar    to modify the Bar to a newBar val
03:45:31 <Peaker> srhb: The Traversal part of a prism is really just equivalent to a function like:   Type -> Maybe ConsFields
03:45:36 <srhb> Peaker: Hmm. Okay. Thanks.
03:46:10 <Peaker> (But the fancy way it is presented allows its type to unify with all the other nice things, and get nice subtyping)
03:46:12 <srhb> (I should have realized there was a lensy solution to this problem, but I'm still surprised. The need for the data constructor in the deconstruction feels so fundamental)
03:46:39 <Peaker> srhb: your idea could still be nice for exhaustiveness checking, as that is missing when using custom functions to "pattern match"
03:46:43 <kuribas> :t (^?)
03:46:43 <lambdabot> s -> Getting (First a) s a -> Maybe a
03:46:44 <srhb> But I suppose it's no different from exporting an extractFromFoo (Foo bar baz) = (bar,baz)
03:47:15 <srhb> Peaker: Yes.
03:47:27 <kuribas> srhb: you can also use viewpatterns.
03:47:42 <Peaker> srhb: extractFromFoo will have to wrap the result in a Maybe
03:48:06 <srhb> Peaker: Why?
03:48:23 <srhb> kuribas: Sure. :)
03:48:40 <Peaker> srhb: assuming you have other constructors that don't necessarily have Bar,Baz inside them
03:48:48 <srhb> Peaker: Ah, yes, of course.
03:48:51 <kuribas> PatternSynonyms are nice, but they allow reconstruction...
03:48:53 <Peaker> srhb: if you don't, then you don't really need a prism, just a lens
03:48:58 <Peaker> srhb: or even an Iso
03:49:33 <srhb> kuribas: It's always possible to reexport an isomorphic type that cannot be converted back into it's original, but that feels like a lot of indirection.
03:49:46 <srhb> Peaker: Brave new world. :-)
03:50:11 <kuribas> srhb: That's what I used.
03:50:21 <Peaker> srhb: it's pretty cool, the subtyping hierarchy using nothing but type-class constraints and CPS :)
03:50:30 <srhb> kuribas: ReadOnlyFoo... :-)
03:50:37 <Peaker> (Well, I guess some type families sprinkled in, etc)
03:50:45 <kuribas> Peaker: I don't get the (:xs) part, if you only need the first?
03:51:43 <kuribas> srhb: I had Expr, with a complicated optimized type, and export it to SimpleExpr, which can be read and written to by the library user.
03:52:05 <Peaker> kuribas: the idea is that a traversal lets you "degenerate" it to a fold(reader of many values) in which case you don't need the (:xs). But a traversal has more power, it can also modify the value, and then you need to re-attach it to (:xs) to build back the list with the modified first
03:52:06 <kuribas> Hopefully it's more refactor-proof.
03:52:07 <srhb> kuribas: Right. :)
03:52:24 <srhb> kuribas: I still feel like that could be solved by having "read only constructors"
03:52:27 <srhb> Or rather, deconstructors.
03:52:30 <Peaker> > let first f [] = pure [] ; first f (x:xs) = (:xs) <$> f x in ([1..10] & first +~ 100, [] & first +~ 100)
03:52:31 <lambdabot>  ([101,2,3,4,5,6,7,8,9,10],[])
03:52:36 <srhb> And I feel like it would be a rather nice solution.
03:52:43 <Peaker> kuribas: See the above ^^ it does need the (:xs)
03:53:05 <kuribas> srhb: readonly PatternSynonyms would do that, but I don't know if that's possible.
03:53:22 <srhb> Of course, it could probably be done in a generic way by transparently making an isomorphic type with the constructors exported with some read only-ish name
03:53:42 <srhb> Not sure how scary that would be vs. resource usage though.
03:53:51 <kuribas> Peaker: like a lens, I get it :)
03:54:37 <Peaker> kuribas: A lens knows it has exactly 1 value to get/modify.   A traversal is similar, but it has 0-N values to get/modify
03:55:45 <kuribas> right
03:55:52 <Peaker> kuribas: the nice thing about the "lens" lib is the unification of all the types.  Unify lens&traversal, and you get a traversal (intersection of the capabilities)
03:56:15 <Peaker> unify prism and lens, also get a traversal.  Unify a lens and an iso, get a lens, etc.
03:58:09 <kuribas> srhb: I think an unidirectional pattern synonym does exactly what you want.
03:58:18 <srhb> kuribas: Yep, I just realized that :P
03:58:32 <srhb> pattern Foo i <- i ?
03:58:40 <kuribas> yes
03:58:46 * hackagebot informative 0.1.0.12 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.12 (implementation)
03:59:26 <kuribas> srhb: the good news is that they can be used without the extension!  (but not defined).
03:59:57 <srhb> kuribas: Putting some responsibility on the library authors is acceptable, I think. :-)
04:00:18 <srhb> Though sometimes I too feel like being able to say reallyImportHidden ...
04:01:05 <kuribas> srhb: hiding stuff allows library authors to change internals without changing the API.
04:01:23 <srhb> Yes, I realize the motivation. :)
04:01:48 <kuribas> A backdoor would break existing apps.
04:01:56 <srhb> Yes, I know. :P
04:38:47 * hackagebot hset 1.1.0 - Primitive heterogenous read-only set  https://hackage.haskell.org/package/hset-1.1.0 (AlekseyUymanov)
04:44:11 <AaronFriel_> Any way to have "yesod devel" use "-O2" for development? 
04:46:05 <Cnky> I need some help with Cabal, I want to compile a haskell project but the dependencies it needs are old, can't find a way to use the old ones
04:46:37 <mpickering> Cnky: What are you trying to install?
04:46:40 <AaronFriel_> Cnky: Edit the dependencies in the .cabal file so that they have upper bounds
04:46:58 <AaronFriel_> Cnky: you may need to specify exact versions, e.g.: containers == x.y.
04:47:00 <AaronFriel_> z
04:47:12 <Cnky> I'm tryign to install https://github.com/xintron/Hirc
04:47:28 <Cnky> AaronFriel_: thanks, I'll try
04:48:00 <AaronFriel_> ah
04:48:05 <AaronFriel_> try to edit the "base" line
04:48:23 <AaronFriel_> so that it is just "base >= 4.7"
04:48:57 <mpickering> or just try installing with --allow-newer
04:49:02 <AaronFriel_> the problem with that package might actually be that the bounds are *too* close together, such that they won't work with other things you've installed
04:51:18 <Cnky> Edited the file, still can't.
04:57:11 <Intolerable1> is there a printf variant for Data.Text?
04:57:45 <dramforever> > printf "foo %s" "bar" :: Data.Text.Text
04:57:47 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
04:58:00 <dramforever> > printf "foo %s" "bar" :: Text
04:58:01 <lambdabot>  Not in scope: type constructor or class ‘Text’
04:58:49 <maerwald_> :t printf
04:58:51 <lambdabot> PrintfType r => String -> r
04:58:58 <maerwald_> mh
04:59:16 <Intolerable1> i think i can do without it actually
05:02:39 <kuribas> Is there something like a generic zip with failure?  Like genericZip (,) [1, 2] [3, 4] == Just [(1, 3), (2, 4)]
05:03:51 <hexagoxel> kuribas: an example of Nothing would be?
05:04:11 <kuribas> genericZip (,) [1, 2] [3, 4, 5]
05:04:42 <kuribas> Like for unification of similar structures in a logic language.
05:05:35 <kuribas> What I want to know if there is a way to test if two structures are structurally the same.
05:06:29 <kuribas> never mind, it's just a crazy idea.
05:07:02 <dramforever> kuribas: it wouldn't work with infinite lists that way
05:07:28 <kuribas> dramforever: that's true
05:18:49 * hackagebot informative 0.1.0.13 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.13 (implementation)
05:18:51 * hackagebot moesocks 0.1.0.0 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.0 (JinjingWang)
05:28:13 <ak5> hey guys, I am trying out some haskell and liking it so far. Since I am from the web side of things (I know, I know...) I wanted to check out wai/warp - docs seem kinda sparse on it though - anywhere I should be looking?
05:32:58 <srhb> ak5: I _think_ most "end users" of the web programming tend to move one further layer up in abstraction and use _something_ that uses wai+warp
05:33:42 <dramforever> Interesting
05:33:45 <pacak> ak5: Reading sources might help.
05:33:50 <dramforever> type role Cofree nominal nominal
05:34:05 <dramforever> I wonder why the second nominal is there
05:34:39 <dramforever> oh wait I think I know it now
05:34:52 <srhb> ak5: If that's not interesting to you, perhaps something like this might interest you: http://langnostic.blogspot.com/2013/02/wai-without-yesod-simple-example-of_10.html
05:34:57 <raichoo> ak5: Perhaps this might help: http://www.yesodweb.com/book/understanding-request
05:35:12 <srhb> ak5: I'm not sure it's perfectly up to date (it's probably not) but it should clue you in on how to operate directly on wai/warp
05:35:23 <pacak> dramforever: and the answer is?
05:35:37 <dramforever> because the first is nominal
05:35:58 <dramforever> and data Cofree f a = a :< f (Cofree f a)
05:36:09 <dramforever> wait how about this
05:36:26 <dramforever> this data type relies on f, which we know nothing about
05:41:49 <kuribas> Is there a performance penalty using StateT and ErrorT?
05:42:05 <dramforever> kuribas: yes of course there is
05:42:20 <kuribas> So I'll better define my own type then...
05:42:39 <dramforever> yes, but *after* you finish your whole program first
05:42:57 <ak5> srhb: thanks for the link, this is what I was lookign for
05:42:59 <dramforever> because otherwise it's premature optimization
05:43:54 <ak5> srhb: the application I want to make seems extremely simple, the previous (production) version is written in nginx+lua but i feel like I should give haskell a fair chance and hey its the weekend :D
05:44:38 <ak5> srhb: however, I will check for stuff on top of wai, thanks
05:44:48 <srhb> ak5: I'd still go with spock or something to make it extra easy. Or at least I think you should try such an approach to see how it simplifies some of the nitty gritty things. :)
05:44:59 <srhb> ak5: But sounds like you have a good approach already, so have fun with it! :-)
05:45:18 <ak5> cool, I'll check it out, thanks
05:53:51 * hackagebot informative 0.1.0.14 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.14 (implementation)
06:01:13 <Guest12009> o/
06:06:29 <Sindriava> Why do all people that port SDL to other languages seem to disregard any types that language might already have? O.o
06:07:15 <Sindriava> Haskell's sdl2 package is like the fifth one that I've seen do this. Is there a deeper reason?
06:11:36 <Diskord|temp> hi people
06:13:51 <ely-se> hi person
06:27:52 <ak5> hey guys, is there a good solution for "watching" and recompiling with cabal based projects? My favorite build tool - tup - doesn't support things like cabal...
06:33:06 <ysangkok> what is up with the hoogle links on fpcomplete? they seem broken: https://www.fpcomplete.com/hoogle?q=System.Random.getStdGen
06:35:45 <srhb> ak5: There was a talk about this recently on /r/haskell -- I think the conclusion was to set up your project so you can reload it in ghci. Another would be to use... ghcid? Or something like that.
06:44:26 <ak5> /r/haskell is a good community?
06:44:30 <ak5> thanks for that
06:46:53 <srhb> ak5: I think it's pretty decent. :)
06:49:27 <Haskellfant>  stack has a --file-watch option
06:49:44 <Haskellfant> there is also ghcid
06:57:15 <sub0> What is the useless skin around the vagina called?
06:57:15 <sub0> WOMAN!
06:57:33 <srhb> Go away.
06:58:03 <srhb> @ops -- apparently going through all the channels...
06:58:03 <lambdabot> Maybe you meant: pl oeis docs
06:58:05 <srhb> @where ops
06:58:05 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:58:33 --- mode: ChanServ set +o Saizan
06:58:38 --- mode: Saizan set +b *!*therapist@46.188.227.*
06:58:39 --- kick: sub0 was kicked by Saizan (sub0)
06:58:48 --- mode: Saizan set -o Saizan
07:28:23 <Andrej_T> is there a data structure in haskell that's equivalent to collections.Counter in python?
07:30:17 <srhb> Andrej_T: Which properties of Counter are you looking for?
07:30:24 <nshepperd> @hackage multiset
07:30:25 <lambdabot> http://hackage.haskell.org/package/multiset
07:30:31 <nshepperd> ^^
07:30:37 <srhb> Andrej_T: For instance, Data.Set has O(1) size.
07:31:49 <srhb> Andrej_T: (So does Data.Map, and a number of others.)
07:32:40 <Andrej_T> i think multiset is what i'm looking for
07:32:48 <srhb> Ok. :)
07:32:58 <kuribas> can I generate an applicative from a monad automatically?
07:40:12 <kuribas> hm (<*>) == liftM2 ($), right?
07:43:48 <peddie> :t ap
07:43:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:02:07 <benzrf> @src ap
08:02:07 <lambdabot> ap = liftM2 id
08:02:14 <benzrf> ($) = id
08:03:56 * hackagebot refact 0.3.0.1 - Specify refactorings to perform with apply-refact  https://hackage.haskell.org/package/refact-0.3.0.1 (mpickering)
08:08:56 * hackagebot informative 0.1.0.20 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.20 (implementation)
08:15:22 <ttt_fff> is there a way to abbrevaite "Constructor" and "Constraint" in such a way that (1) they don't both end up as "cons", adn (2) I don't use more than 4 chars?
08:15:27 <ttt_fff> and (3) one is not a substring of the otehr ?
08:15:34 <ttt_fff> and (4) it's obvious which is which?
08:16:14 <benzrf> ttt_fff: lol
08:16:21 <benzrf> Ctor
08:16:29 <nolraiU> Tor and taint? :P
08:16:31 <ttt_fff> benzrf: go back into your spreadsheet writing cave :-)
08:16:43 <ttt_fff> cons vs ctor is nice
08:16:55 <mniip> constructors are usually called Con
08:16:56 <srhb> ttt_fff: Now what about actual cons?
08:17:10 <mniip> datacon, typecon
08:17:12 <ttt_fff> srhb: we don't use cons/car/cdr here, what are you, a schemer?
08:17:26 <srhb> ttt_fff: Sure we do. (:) is pronounced cons.
08:17:27 <mniip> constraints are usually not abbreviated
08:17:36 <ttt_fff> the problem with Con + Cons, is that I may confuse [Con], a list of Constructors, with Cons, a Constraint
08:17:49 <srhb> (But that's short for construct(or?) anyway...)
08:17:51 <ttt_fff> maybe I call "Constraint" "Equation", and abbrevaite it as Eqn instead
08:18:03 <srhb> But... That's not what it is. :|
08:18:43 <ttt_fff> a constraint is an equation that returns a Bool
08:18:43 <mniip> ttt_fff, how about
08:18:45 <mniip> Cxt
08:18:51 <srhb> Context?
08:18:51 <mniip> ttt_fff, wrong
08:18:59 <ttt_fff> mniip? how so?
08:19:11 <mniip> you can't "invert" a constraint
08:19:16 <mniip> it's not boolean logic
08:19:44 <mniip> srhb, well yes, contexts are just constraints?
08:20:01 <ttt_fff> hmm, maybe Cons = Constructor, Cstr = Constraint ?
08:20:04 <mniip> and there isn't a whole lot of places where you can put constraints other than in a context
08:20:19 <mniip> ttt_fff, I strongly advice using Con for constructor
08:20:35 <ttt_fff> why?
08:20:45 <ttt_fff> is Cons too similar to (:) ?
08:21:09 <ttt_fff> okay, fine, made the change via sed
08:21:20 <mniip> that's what GHC and a lot of base libraries call them
08:22:12 <ttt_fff> fuck, "ConsoleLayout" just became "ConoleLayout"
08:22:21 <mniip> \<Cons\>
08:22:59 <ttt_fff> taht doesn't work, I have things like DCons, TCons ... but I just did ConoleLayout -> ConsoleLayout, not many words with "Cons" as a substring and meaning somethig else
08:23:24 <monochrom> you need a tokenizer
08:24:34 <ttt_fff> maybe I should write a parsec module for parsing haskell code, just to rename Cons to Con in the right place
08:24:36 <ttt_fff> s
08:25:04 <srhb> The yak shaving is strong here.
08:25:06 <srhb> :-)
08:25:15 <mpickering> what are you actually trying to do?
08:25:28 <newbie___> its very hard to do permutation and combination in functional language :(
08:25:32 <srhb> Ambiguating words, I think. :P
08:26:28 <ttt_fff> yeah, trying to map "Constructor" and "Constraint" down to shorter words
08:28:55 <ttt_fff> mniip: how do you know so much about haskell at such a young age?
08:29:03 <ttt_fff> is your dad simon peyton jones?
08:29:09 <mniip> I wish
08:29:12 <srhb> I feel like you've picked the wrong number of letters. Perhaps the critical number is 5!
08:29:18 <maerwald_> mniip: sure about that? ;)
08:29:39 <ttt_fff> srhb: what would you do with 5 chars?
08:30:28 <srhb> I was mostly joking. I don't think I'd abbreviate these at all if I needed to use both regularly. Otherwise V/TCon and Cxt
08:30:42 <mniip> VCon?
08:30:48 <srhb> value concstructor.
08:30:51 <srhb> constructor*
08:30:53 <mniip> you mean DataCon?
08:30:57 <mniip> also it's called TyCon
08:31:04 <srhb> No, I emphhatically mean value constructor.
08:31:12 <mniip> :|
08:31:25 <srhb> They are synonymous, and one is way more ambigous than the other. :)
08:32:22 <srhb> But my brain also complains when I have to write data Foo = Bar ... and Foo is NOT a data something. :P
08:33:19 <monochrom> my solution is to regard "data" as a meaningless mandatory keyword rather than an English word
08:33:50 <monochrom> it is Martian for "sum and product types"
08:34:02 <srhb> monochrom: Agreed. Good approach.
08:34:12 <monochrom> if you regard every keyword as Martian, nothing is confusing
08:34:21 <srhb> Such a simple solution...
08:34:58 <srhb> {-# LANGUAGE NoImplicitKeywords, NoImplicitPrelude, NoSanity #-}
08:39:06 <mniip> [18:33:28] <monochrom> it is Martian for "sum and product types"
08:39:10 <mniip> for algebraic datatype
08:39:10 <lamefun> What's that NoSanity extension? Disables some checking?
08:39:15 <naudiz> do I have to understand the concept of "roles"?
08:39:22 <mniip> lamefun, removes KitchenSink
08:39:35 <monochrom> "algebraic datatype" is Vulcan for "sum and product type"
08:39:55 <horatiohb> always sounded Romulan to me...
08:40:09 <lamefun> What's KitchenSink? An extension on by default?
08:40:50 <mniip> monochrom, you can generalize an algebraic datatype, but you can't generalize sum and product types :)
08:41:56 <mniip> naudiz, it's a rarely used concept, but it's not a hard one
08:42:12 <newbie___> i'm totally lost 
08:43:34 <naudiz> mniip: I don't understand why you would annotate them manually. isn't type always nominal and newtype always representational?
08:43:44 <mniip> huh
08:43:46 <mniip> no?
08:44:18 <naudiz> then I misunderstood them
08:44:26 <mniip> I don't think I ever had to annotate type roles manually
08:44:37 <mniip> but I did use the concept with coerce and unsafeCoerce
08:45:36 <raichoo> naudiz: Sometimes you have to annotate them. Think about the key type of a Map.
08:46:17 <raichoo> Having Map representational representational would let you coerce between different orderings.
08:47:08 <raichoo> Therefore you annotate the map key type with nominal.
08:47:21 <naudiz> I think I'll have to read about the concept again
08:47:41 <raichoo> Even though it gets inferred as representational since there are no type families involved.
08:52:34 <saep> How can I start a ghci session from a sandboxed haskell programm that does not inherit the settings (package-bd etc.) from the sandbox? :S
08:55:23 <srhb> saep: Can you explain why your request is not contradictory? ghci opens a ghci session from a directory with a cabal sandbox, but without using the sandbox. cabal repl does the opposite.
08:57:16 <srhb> saep: If the problem is that running the program (ie. cabal run) inherits it, I guess you'll have to get a fresh shell.
08:57:38 <srhb> saep: Ie. like env -i
08:59:45 <saep> I'm using the library part of ghcid. It just uses `createProcess` to execute the given command I give verbatim (e.g. "ghci -ilib xmonad.hs" inside the directory (Just "~/.xmonad")).
09:00:32 <saep> It works fine from a `cabal repl` session from inside the sandbox, but not if it is executed inside the compiled program that I excute with `cabal exec`.
09:02:45 <srhb> saep: I think what you want is to clear the environment, reload the user environment but not the sandbox environment (ie. by spawning a shell that loads it) and then executing whatever ghci command you wanted.
09:02:50 <srhb> Oh
09:02:52 <srhb> Wait
09:02:56 <srhb> It doesn't work in the compiled program.
09:02:59 <srhb> Err! No idea then.
09:03:33 <srhb> Wait, cabal exec specifically inherits the sandbox env.
09:03:39 <srhb> Why are you not running the executable directly?
09:04:25 <saep> I don't want to install all those packages in the user/global package path.
09:06:07 <srhb> I think I'm misunderstanding your question completely so I'll shut up now. Perhaps some lpasting of what you expect and what you get would help. :)
09:06:54 <beaar> htx does not seem to support Data.Text? what library does?
09:07:20 <nolraiU> So anyone know why my haskell vim is turning :+: into what looks like a candle or a block face lowercase i?
09:08:34 <demize> 'block face lowercase i'?
09:08:40 <demize> Anyway, are you on OS X?
09:09:15 <demize> On OS X many things seem to be in love with using emojis everywhere.
09:09:53 <hexagoxel> saep: `cabal exec` just sets GHC_PACKAGE_PATH. so my guess what you want is to clear that again from the environment.. srhb's suggestion using some `env` invocation seems the right path
09:09:57 <beaar> is there a html/xml parser with Text support?
09:10:03 <nolraiU> A narow hollow vertical rectangle with a solid dot over it. And nope, but the vim extention does replace things, just..usually its some standard symbol.
09:11:03 <saep> https://github.com/saep/nvim-hs-config-example/blob/ghcid/lib/Neovim/Ghcid/Internal.hs <-- ```startGhcid "ghci -ilib xmonad" "~/.xmonad"`` should fill the quickfix list with the compile errors I get with `ghci -lib xmonad` in the ~/.xmonad directory.
09:11:49 <demize> nolraiU: Which vim extension?
09:12:50 <saep> hexagoxel: I should try that before I write anything more.
09:13:48 <demize> nolraiU: Oh, also, could you copy the replaced character and paste in here?
09:14:16 <demize> nolraiU: Oh.. https://github.com/enomsg/vim-haskellConcealPlus/blob/master/after/syntax/haskell.vim#L356
09:14:56 <demize> nolraiU: ⅈ is  "DOUBLE-STRUCK ITALIC SMALL I"
09:15:11 <nolraiU> Hmm.
09:15:32 <nolraiU> It looks just like a sans serif version of that.
09:16:09 <nolraiU> And I can't select the character, because vim detects mouse clicks.
09:16:35 <nolraiU> Well there it is!
09:16:36 <nolraiU> Hmm.
09:16:42 <nolraiU> Now why is that there?
09:17:01 <nolraiU> What does lower case block I mean?
09:18:22 <srhb> nolraiU: Blocks are ranges in unicode lingo.
09:18:51 <demize> lower case block?
09:18:55 <srhb> I don't think there's officially one called lowercase though.
09:18:56 <zoug> hello, I have problems (again) with the tree type of structure in Haskell, defined as either "Empty" or "Node Tree something Tree"
09:19:07 <srhb> zoug: Yes?
09:19:15 <nolraiU> I meant blackboard like.
09:19:31 <zoug> I want to print every "something" on the tree, starting from the lower one
09:19:32 <srhb> zoug: (You probably mean Empty| Node (Tree a) a (Tree a)
09:19:39 <zoug> yes srhb exactly
09:20:09 <zoug> I tried using a f'n and pattern matching against (Node Empty a topTree)
09:20:13 <demize> nolraiU: https://github.com/enomsg/vim-haskellConcealPlus/commit/79d9c7191cf5934532580ee9afaf3a9ad008cbdd hmm
09:20:28 <zoug> but that doesn't work
09:20:41 <zoug> how could I access every element in my tree? one after the oter?
09:20:43 <zoug> *other
09:21:19 <srhb> zoug: I think what you are asking for is what is called a breadth-first  preorder traversal. If your root (ie outer) tree contains the first node you want to deal with.
09:22:38 <joco42> cabal/ ghc question if there is a package A with version 1 and 2 , and library B that uses version 1 of A , then is it possible to write a haskell software that uses B and version 2 of A ?
09:22:41 <zoug> srhb: I think that's it yeah
09:22:44 <demize> zoug: basically, you do pattern matching to bind the two trees, and then you call the function again in both of those trees
09:22:56 <zoug> yeeees
09:23:03 <zoug> I haven't thought of that!
09:23:24 <zoug> but then I'd lose the middle element each time?
09:23:26 <zoug> no?
09:23:35 <saep> srhb, hexagoxel: unsetting 3 environment variables works. I should have thought of that. 
09:23:37 <saep> Thanks!
09:23:43 <demize> zoug: Well, that depends on what you want to do with it.
09:23:58 <zoug> If I want to, for example, build a list containing every "something" from the first one of the tree to the last one
09:24:01 <srhb> saep: :)
09:24:11 <nolraiU> "breadth' (Node l a r) = [a] : zipwith append (breadth' l) (breadth' r)" would work for balenced trees I think.
09:24:29 <nolraiU> (With breadth = concat . breadth)
09:24:45 <demize> zoug: then you could do   (call function on left tree) ++ (current something) ++ (same on right tree)
09:25:12 <demize> And then your base case would just return an empty list
09:25:27 <hexagoxel> saep: hmm 3? which ones (just curious)
09:26:27 <zoug> thank you demize I think I can figure it out now
09:26:35 <zoug> I'll come back if I'm still stuck.. :p
09:27:05 <demize> zoug: Cool. If you give up I can show you the solution for something like that I made for an exercise.
09:27:20 <demize> (The exercises in <https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf>, to be specific.)
09:28:07 <zoug> demize: it's exactly that I'm trying to do hahah
09:28:14 <demize> ^_^
09:29:02 <demize> My solution to exercise 4 is basically, though not quite, what I wrote earlier.
09:32:27 <demize> (And if it makes you feel better it took me a while to come up with it as well.)
09:33:48 <whythat> Is anyone left on #xmonad?
09:34:25 <srhb> whythat: Often not. Sometimes yes.
09:35:17 <demize> That reminds me that I've been planning on testing xmonad out sometime..
09:36:05 <whythat> srhb: I wander if there is still any work on it, or community decided that it is already perfect?:)
09:36:28 <srhb> whythat: Yes there is, but it's pretty darn stable, so most of it is just keeping up with ghc versions.
09:37:42 <zoug> demize: haha thanks
09:37:46 <zoug> I think I got it
09:38:05 <demize> zoug: Awesome :D
09:38:57 <whythat> srhb: I was just thinking that it would be great to try to port this great piece if art to Wayland, just for fun.
09:39:08 <geekosaur> a lot of people in there just lurk. I think kmicu and I are most active
09:39:12 <srhb> whythat: You're not the first. :)
09:39:18 <srhb> To have that thought, that is.
09:39:19 <geekosaur> that wouldn't be a port
09:39:40 <geekosaur> would need to be a complete rewrite, because sjanssen wrote xmonad to be very close to xlib
09:39:57 <geekosaur> he looked into porting to xcb at one point and gave up because all the types would change incompatibly
09:40:06 <zoug> demize: could you check if you have something similar? http://arin.ga/8aUS8e
09:40:48 <saep> hexagoxel: "GHC_PACKAGE_PATH" "CABAL_SANDBOX_CONFIG" "CABAL_SANDBOX_PACKAGE_PATH"
09:40:49 <whythat> Oh, I know, i 'be seen lots of proposals, but, still, no one seems to have actually started 
09:41:20 <hexagoxel> saep: interesting, thanks
09:42:48 <geekosaur> and to be honest, most of us think wayland is at X11R1 level and is going to be rediscovering the hard way all the things that eventually led to X11R4
09:42:49 <whythat> Btw, sorry for typos, bad touchscreen skills)
09:42:49 <hexagoxel> (that means that my description in `cabal help exec` is slightly misleading, as it only mentions one of those three.. hum)
09:43:36 <demize> zoug: Mostly similar, yeah. Though your second pattern in inOrder is unnecessary, but I guess it could be faster since it's two function calls less.
09:43:51 <ttt_fff> I have "envLookup :: blah -> Monad Maybe x", now, I'd like a 1 char addition to "envLookup "to have type ":: blah -> Monad x" // whereit logs some error in the monad if it is a Nothing, what is a one char addition to indicate taht "things are fucked up if this fails" ?
09:44:25 <demize> zoug: My parseMessage function is quite different though, and I'm not entirely happy with it. And ex3 I accidentally did on my own while testing the other functions out, hehe.
09:44:47 <demize> Well, ex3 is a subcase of what I wrote.
09:45:29 <zoug> demize: hahaha I was just talking about ex4! you hadn't to check it all out, but that's really nice of you
09:45:33 <Cnky> How does one enable FlexibleContexts?
09:45:48 <demize> zoug: No big deal. ;)
09:45:51 <zoug> yeah my parseMessage is quite weird I admit
09:45:52 <srhb> ttt_fff: Logs an error in the monad? What monad?
09:46:02 <ttt_fff> no no, the part is not the monad part
09:46:07 <demize> zoug: Mine's a bunch of weird functions ;p
09:46:08 <ttt_fff> the question is, what chaar should I add to envLookup 
09:46:09 <Big_G> How do I acheive a number of precision greater than Int like Long in Java
09:46:12 <srhb> I'm just ocnfused by the Monad Maybe notation
09:46:13 <ttt_fff> envLookup! does not work
09:46:25 <demize> zoug: anyway, when you're done with ex 5, my solutions are for github if you want to look.
09:46:29 <maerwald_> Big_G: Integer?
09:46:43 <zoug> yeah! can you give me the link?
09:46:46 <ttt_fff> hmm
09:46:47 <maerwald_> > 109290312093192083109290831290812308912309812389012389090831290812308931208913290812 :: Integer
09:46:47 <ttt_fff> let me rethink
09:46:48 <lambdabot>  1092903120931920831092908312908123089123098123890123890908312908123089312089...
09:47:15 <demize> zoug: https://github.com/kyrias/cis194-2013-exercises
09:47:16 <srhb> Big_G: Integer is unbounded.
09:47:25 <Big_G> Awesome. That was what I needed
09:47:56 <srhb> Big_G: Note that depending on what you do, it can be slow.
09:48:09 <zoug> demize: great thanks
09:48:19 <srhb> Big_G: Int64 is, I think, the same size as a java long.
09:48:26 <whythat> OK, so about xmonad, does anyone know if there are any problems with xmonad-contrib darcs repo because I wasn't able to clone it, it just hangs all the time
09:48:36 <zoug> I'll first start to do it on my own though
09:48:41 <zoug> ofc ^^
09:48:48 <demize> zoug: ^_^
09:51:26 <maerwald_> whythat: did you use --lazy?
09:51:28 <geekosaur> works here
09:51:46 <Big_G> How do I iterate over a second value in foldr? i.e. let n be the number of values seen
09:52:20 <Welkin> Big_G: eh?
09:52:34 <Welkin> you mean, every second element of the list?
09:52:56 <Big_G> Welkin, No. I want the regular operation like sum but also how far along the list I am
09:53:21 <Welkin> you can zip the list with [1..]
09:53:28 <Welkin> or [0..] is you prefer to start at 0
09:53:39 <Big_G> Welkin, perfect
09:53:47 <Welkin> > zip [5,7...] [1..]
09:53:49 <lambdabot>      A section must be enclosed in parentheses thus: (7 ...)
09:53:51 <Welkin> er
09:54:02 <Welkin> > zip [1..] [5,7..]
09:54:03 <lambdabot>  [(1,5),(2,7),(3,9),(4,11),(5,13),(6,15),(7,17),(8,19),(9,21),(10,23),(11,25)...
09:54:22 <whythat> maerwald_: nope, I'm not really that good with darcs, this is the first time in my 1year xmonad usage that I decided to contribute
09:55:39 <geekosaur> note that the repo name is actually XMonadContrib
10:10:47 <Big_G>  How do I zipWith in the opposite direction like foldl/foldr
10:11:15 <zomg> Maybe you can just reverse the lists?
10:11:25 <Big_G> I did but that seems inefficient
10:11:30 <zomg> Not sure if there's a zipWithR :)
10:12:19 <Welkin> why do you need to zip in the opposite direction?
10:12:36 <Welkin> are you zipping with a counter?
10:12:46 <mniip> Big_G, reverse one of the lists
10:12:47 <geekosaur> Big_G, since lists are singly linked lists, going the other direction will always be inefficient
10:12:51 <Welkin> or zipping to apply a list of functions at some regular interval?
10:12:53 <geekosaur> just reverse the list
10:12:58 <mniip> geekosaur, wrong
10:13:00 <Big_G> Welkin, Yeah
10:13:08 <mniip> foldl isn't neccesarily inefficient
10:13:43 <geekosaur> we were speaking of zipWith. foldl isn't quite the same thing
10:13:48 <mniip> true
10:13:56 <geekosaur> (it "goes the other direction" via associativity)
10:14:04 <mniip> well it still takes linear time to produce the first element
10:14:27 <Welkin> > zipWith ($) [id, (*2)] [1..]
10:14:29 <lambdabot>  [1,4]
10:14:39 <Welkin> > zipWith ($) (cycle [id, (*2)]) [1..]
10:14:40 <lambdabot>  [1,4,3,8,5,12,7,16,9,20,11,24,13,28,15,32,17,36,19,40,21,44,23,48,25,52,27,5...
10:15:03 <Welkin> > zipWith ($) (cycle [id, (*2)]) (reverse [1..100])
10:15:05 <lambdabot>  [100,198,98,194,96,190,94,186,92,182,90,178,88,174,86,170,84,166,82,162,80,1...
10:15:25 <Cnky> If anyone has an idea what am I doing wrong, help would be much appreciated. http://hastebin.com/husomebomu.vhdl
10:17:08 <Cnky> It says to use FlexibleContexts, but I've no idea how
10:17:33 <geekosaur> {-# LANGUAGE FlexibleContexts #-} at the top, or -XFlexibleContexts as ghc parameter
10:18:07 <geekosaur> (and, standard Haskell is rather conservative about what it allows in instances; FlexibleContexts is commonly used and quite safe)
10:19:18 <Cnky> geekosaur, the first option, is that a flag behind 'make'?
10:20:05 <geekosaur> it would presumably go in the Makefile wherever -XBangPatterns and -XForeignFunctionInterface is being specified
10:20:24 <Cnky> Ah, thanks, I'' try.
10:35:39 <Cnky> Darn, i'm doing something wrong
10:49:58 <mniip> how would I floor a Ratio Integer
10:50:58 <int-e> > floor (7/3  :: Ratio Integer)
10:50:59 <lambdabot>  2
10:51:10 <Welkin> :t 3 % 4
10:51:11 <lambdabot> Integral a => Ratio a
10:51:12 <int-e> (also note that Ratio Integer = Rational)
10:51:43 <mniip> > floor (3 % 2) :: Rational
10:51:44 <lambdabot>      No instance for (Integral Rational) arising from a use of ‘floor’
10:51:44 <lambdabot>      In the expression: floor (3 % 2) :: Rational
10:51:46 <Welkin> > floor $ fromIntegral (3 % 4)
10:51:47 <lambdabot>      Could not deduce (Integral (Ratio a0))
10:51:47 <lambdabot>        arising from a use of ‘fromIntegral’
10:51:47 <lambdabot>      from the context (Integral b)
10:51:58 <mniip> I need a rational as output
10:52:10 <mniip> toRational . floor seems like a hack
10:52:42 <Welkin> >:t fromRational
10:52:44 <Welkin> :t fromRational
10:52:45 <lambdabot> Fractional a => Rational -> a
10:52:45 <int-e> I'd probably use  fromIntegral . floor  then
10:52:58 <int-e> err,  fromInteger . floor
10:53:00 <Welkin> > fromRational (3 % 4) :: Integer
10:53:01 <lambdabot>      No instance for (Fractional Integer)
10:53:02 <lambdabot>        arising from a use of ‘fromRational’
10:53:02 <lambdabot>      In the expression: fromRational (3 % 4) :: Integer
10:53:15 <Welkin> > fromRational (3 % 4) :: Double
10:53:17 <lambdabot>  0.75
10:54:02 <Welkin> > toInteger $ floor $ fromRational (3 % 4) :: Integer
10:54:03 <lambdabot>  0
10:54:05 <Cnky> geekosaur: it worked! Thanks
10:54:10 <Welkin> > floor $ fromRational (3 % 4) :: Integer
10:54:12 <lambdabot>  0
10:54:28 <Welkin> I've never used ratio before
10:54:34 <Welkin> is there a good example of where to use it?
10:56:18 <geekosaur> ratio's useful for exact math (as opposed to floating point)
10:56:27 <mniip> Welkin, when you need rational numbers
10:56:36 <mniip> for example I'm counting probabilities
10:56:54 <mniip> 165992845975342083 / 830823264240025 isn't something you'd store in a float
10:56:57 <roconnor> > floor (3 % 4 :: Rational)
10:56:59 <lambdabot>  0
10:58:27 <roconnor> Which do you folks think is better a) futurePlotAmounts & traverse._2 %~ (^._1)  or b) [(d, v) | (d,(v,_,_)) <- futurePlotAmounts]
10:58:59 <mniip> b
10:59:35 <mniip> a looks like some perl abomination
10:59:40 <roconnor> heh
11:00:03 <Peaker> roconnor: the latter is much nicer
11:00:23 <roconnor> I'm also leaning towards b), even though I dislike pointfull notation.
11:03:24 <mpickering> does anyone know the history of the AlternativeLayoutRule extension?
11:04:07 <roconnor> mniip: I remember I was comparing doubles vs rational for some probability calculation I was doing.  Using doubles it ran instantly, and using Rational, it took seconds.  I was happy to wait seconds to get an answer I knew woudln't be corrupted by floating point rounding. :D
11:04:30 <nagyf> Hi! I have a custom data type: newtype World = World [Cell] deriving (Show, Eq). I want to make this an instance of Functor typeClass but it complains about my type has a kind of *, but it requires * -> *. Why Functor requires * -> *. Is it possible to make my type an instance of it?
11:05:33 <roconnor> nagyf: functor types look like newtype Foo a = ... a ...
11:07:17 <nagyf> roconnor: I know but I want to be able to use fmap on my type
11:07:28 <roconnor> nagyf: you will either have to write your own mapCell :: (Cell -> Cell) -> World -> World
11:07:32 <nagyf> Is it impossible with Functor?
11:07:40 <roconnor> :type fmap
11:07:53 <roconnor> @type fmap
11:07:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:08:10 <roconnor> fmap takes an (a -> b) argument, and it has to work for any a and any b.
11:08:46 <nagyf> roconnor: hmm okay, I understand now, thanks. I will write my own mapCell implementation as you suggested
11:09:57 <roconnor> nagyf: In principle you can write a custom traversal for your World type and use one of the Lens libraries, but it is a bit advanced, and I'm not sure what your Haskell experience level is.
11:10:37 <nagyf> roconnor: I don't think so, I'm newbie :)
11:11:18 <nagyf> I implement a custom mapCell function
11:12:11 <roconnor> A custom mapCell will work fine.
11:28:57 <Welkin> what is wrong with just using [Cell]?
11:29:02 <Welkin> why is it wrapped in a newtype?
11:29:15 <Welkin> then you can just use `map f cells`
11:29:41 <Welkin> you can use a type synonym `type World = [Cell]`
11:47:05 <nschoe> Hi! What is the "best" way to change a single value in a matrix (from the hmatrix package)? My best idea for now it to flatten the matrix into a vector, use a combination of "take n", "insert" new value and concatenate with "drop n" of the vector, then reshape. But it seems ... hardcore.
11:48:22 <athan_> nschoe: There must be some kind of modify function, one sec
11:48:43 <nschoe> athan_, yes I thought so, I still hope. But either I missed it or it is not present.
11:50:50 <athan_> nschoe: Maybe `atIndex`?
11:51:22 <athan_> It's more frustrating than I had anticipated ;)
11:51:52 <nschoe> athan_, nah, it returns the element at this index, it doesn't allow to modify it.
11:52:14 <athan_> shoot. Have you considered a lens-based solution?
11:52:16 <nschoe> athan_, see? My thought exactly, I was like "what? No way we can't do that". But apparently, yes way?
11:52:22 <nschoe> athan_, Ah, I am not familair with Lens ;/
11:52:33 <nschoe> I've read about it, but never used it.
11:53:40 <nschoe> I think I'll go with my flatten-take-concat-drop-reshape approach. But this is gonna be long. Especially since I must do it 1,000 or 10,000 times :/ (This is for Numerical Gradient Checking in a neural network)
11:53:44 <lpaste_> Blair pasted “Euler-Problem-10.hs” at http://lpaste.net/137390
11:54:06 * hackagebot yesod-bin 1.4.13.1 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.13.1 (MichaelSnoyman)
11:54:25 <athan_> nschoe: :\ sorry, it just doesn't look like matricies are designed to be modifiable, like vectors or arrays
11:55:07 <nschoe> Doesn't seem indeed, but it's a shame, I need to ^^
11:55:10 <roconnor> nschoe: have you seen accum?
11:55:15 <nschoe> Thanks for taking the time, anyway.
11:55:29 <nschoe> roconnor, hum let me check that.
11:55:40 <blaird> Hey, I was hoping to get some advice on how to make some code a little bit faster
11:55:46 <roconnor> https://hackage.haskell.org/package/hmatrix-0.16.1.5/docs/Numeric-LinearAlgebra-Data.html#v:accum
11:56:30 <nschoe> roconnor, OMG, this might just be it indeed. It seems to take the index annd the value.
11:56:47 <nschoe> Holly crap, I missed it. There *is* everything you need in Haskell. Thanks, seriously.
11:56:58 <athan_> `accum` you later!
11:57:09 <roconnor> use can use const (or probably flip const) for the update function
11:57:33 <roconnor> or, more likely, you do actually want to accumulate with (+)
11:57:59 <nschoe> roconnor, yes I do, It's very simple now, It's just (+ myValue). Cool thanks !
11:58:17 <sccrstud92> do MonadIO and MonadBaseControl IO attempt to accomplish the same thing?
11:58:17 <nschoe> (athan_ nice one btw, I caught it ^^)
11:58:28 <blaird> How fast should a laptop with 6gb of ram and an i5 be able to find all primes below 2 000 000? If it's written well-ish
11:58:33 <roconnor> heh, I've never used the library.
11:59:07 * hackagebot hreader 0.2.0 - Generalization of MonadReader and ReaderT  https://hackage.haskell.org/package/hreader-0.2.0 (AlekseyUymanov)
11:59:12 <mjrosenb> I should be able to say foo :: forall t. Ord t => [t] -> t; then within the definition of f, give values types involving t, right?
11:59:47 <sccrstud92> mjrosenb: I think you need ScopedTypeVariables for that
11:59:49 <dertrand179> I have set out to learn haskell. Will somebody guide me to a great haskell resource (other than ones on google- didn't work for me)?
11:59:54 <sccrstud92> otherwise ghc thinks its a different t
12:00:11 <athan_> @learn dertrand179
12:00:12 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
12:00:16 <athan_> :)
12:00:37 <blaird> @dertrand179 I found a combo of RealWorldHaskell and LearnYouAHaskellForGreatGood was best for me
12:00:37 <lambdabot> Unknown command, try @list
12:00:49 <mjrosenb> even with forall t.?
12:01:01 <mjrosenb> oh, I guess it gave me rank-n types
12:01:09 <mjrosenb> which also uses forall t.
12:01:13 <mjrosenb> but differently
12:01:17 <roconnor> you need some flag to use the keyword forall
12:01:36 <mjrosenb> I have a flag, I suspect it is just the wrong flag.
12:02:19 <athan_> I feel like monad-control is a generalization of mtl-style monad transformers
12:02:26 <athan_> - induction over hypothesis, maybe?
12:04:07 * hackagebot protocol-buffers 2.1.4 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.4 (k_bx)
12:04:08 <blaird> In this code, http://lpaste.net/137390 am I failing to do something that could make it faster? My machine is struggling a little
12:04:09 * hackagebot protocol-buffers-descriptor 2.1.4 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.4 (k_bx)
12:04:11 * hackagebot hprotoc 2.1.4 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.4 (k_bx)
12:05:40 <lpaste_> Blair revised “Euler-Problem-10.hs”: “No title” at http://lpaste.net/137390
12:08:18 <athan_> blaird: Strictness is super important fyi
12:09:14 <dertrand_> Please help me to begin learning this language. What should I begin with?
12:09:59 <blaird> Oh for sure, but I think that foldl' only helps the summation. I think that most of that stuff is strict right?
12:10:10 <int-e> blaird: are you compiling the code? I'm sceptical because of the 'return' in 'main'...
12:10:21 <LeoTal> dertrand_: Try http://learnyouahaskell.com/
12:10:35 <athan_> @learn -- and this dertrand_
12:10:36 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
12:10:46 <blaird> It runs
12:11:01 <blaird> I just tested it in ghci to double check
12:11:28 <Gurkenglas> When I have a mathematical and technical representation of a piece of data with a bijection between the two, how am I to go about embedding transformations on the mathematical representation into transformations on the technical representation? I thought of fmap and defined something like (Math -> Math) -> Tech -> Tech, but is there a more idiomatic way? (Or even a naming convention for this kind of function?)
12:11:36 <kadoban> dertrand_: https://github.com/bitemyapp/learnhaskell <-- that's a good guide
12:14:17 <roconnor> Gurkenglas: you could use isomorphisms from the lens library for this sort of thing.
12:14:42 <roconnor> if it is really a bijection.
12:15:59 <Gurkenglas> As much as Int is as large as Word16.
12:16:16 <roconnor> if the Math embedds into Tech, then you could use a Prism or Lens or Partial Lens, depending on the sort of embedding, or just say screw it and use an isomorphism anyway.
12:16:25 <int-e> blaird: I think using Data.Sequence is wrong here... in fact, the standard  let primes = 2:Prelude.filter isPrime [3,5..] where isPrime p = Prelude.all (\q -> p `mod` q > 0) $ takeWhile (\q -> q*q <= p) primes in foldl' (+) 0 $ takeWhile (<2000000) primes  is faster than your code
12:16:48 <roconnor> Gurkenglas: I think Haskell guarentees an Int is at least 30 bits or so...
12:16:58 <Gurkenglas> I know :P
12:17:17 <blaird> Wow. Really?
12:18:24 <broma0> Using template haskell, is there a way to generate a list of the names all functions in a file? Like generate 'mylist = ["foo", "bar", "baz"]' where foo bar and baz are functions
12:19:18 <athan_> broma0: You might find better luck parsing your files with haskell-src-exts
12:21:09 <broma0> athan_: hmm my goal is basically to create a function that takes the name of a function as an argument, and then invokes the corresponding function
12:21:20 <broma0> (if one exists)
12:23:12 <naudiz> Is Nix really a good alternative to cabal?
12:23:42 <voidzero> stack is the alternative to cabal
12:23:50 <voidzero> nix is a system package manager
12:23:57 <voidzero> NixOS is an OS around Nix
12:24:05 <voidzero> or distribution, rather.
12:24:14 <int-e> blaird: there are a few faster sieves on hackage, for example https://hackage.haskell.org/package/NumberSieves or the tuned sieve of Eratosthenes in https://hackage.haskell.org/package/arithmoi
12:24:28 <blaird> int-e: Did that code run for you? I can't get the same thing to work
12:25:06 <naudiz> voidzero: some people recommended it as a package manager around cabal to get out of cabal hell
12:25:13 <blaird> int-e: the primes in the where clause is what it's complaining about (But that will be beautiful if that works)
12:25:41 <voidzero> naudiz, yes, but now we have stack for that
12:25:56 <voidzero> which, tbh, is still i have yet to test myself
12:26:01 <voidzero> still something*
12:26:08 <naudiz> voidzero: what is a good place to start reading about stack?
12:26:37 <voidzero> https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
12:26:49 <int-e> blaird: http://lpaste.net/137392 should work
12:26:58 <naudiz> okay, that's also the first thing I found. thanks :)
12:27:07 <voidzero> naudiz, ok hf :)
12:27:51 <blaird> int-e: R U a Wizard? You can define a list recursively?
12:28:10 <int-e> blaird: that's lazy evaluation for you
12:28:34 <blaird> Wow
12:29:01 <int-e> blaird: note that when 3 is tested, the 2 is already in the list, and 2*2 > 3. and it goes on like that; for every number tested, there are already enough primes in the list to let q*q <= p fail for one of them.
12:29:05 <roconnor> blaird: http://r6.ca/blog/20081116T213644Z.html
12:29:16 <blaird> int-e: For sure, it totally makes sense
12:29:37 <blaird> int-e: the sqrt bound keeps everything safe too. But wow
12:30:58 <Cnky> Back with another problem, I've compiled a Haskell bot, and now when trying to run it, I get in: Error occured: <socket: 3>: Data.ByteString.hGetLine: resource vanished. Any ideas?
12:31:28 <int-e> blaird: you can use the sqrt test as well, I just happen to dislike mixing in floating point into integer arithmetic.
12:31:43 <Cnky> I think the bot was built on debian, but I'm on Arch.
12:32:42 <int-e> Cnky: that usually means the socket (or pipe... but since "socket" occurs in the error, it's probably a socket) was closed from the other side
12:33:02 <blaird> int-e: I agree, that's much better
12:33:40 <lcevans> \quit
12:34:07 <blaird> roconnor: I'm with asdftimo "that is so fucking cool"
12:37:39 <demize> If I have a binary tree, is there any easy way to render that to eg an svg?
12:38:01 <demize> Like eg networkx in python can easily make dot graphs.
12:39:08 * hackagebot myo 0.1.0.0 - Haskell binding to the Myo armband  https://hackage.haskell.org/package/myo-0.1.0.0 (AlfredoDiNapoli)
12:39:28 <maerwald_> demize: mh, I have done that, I have to look up how I did that
12:40:09 <naudiz> can I use stack with Hackage?
12:40:29 <demize> maerwald_: Appreciate it.
12:40:52 <demize> I'm currently writing a function to balance the tree, but it's a bit hard to visualize without a rendered tree :/
12:42:25 <maerwald_> @hoogle renderTree
12:42:25 <lambdabot> No results found
12:42:37 <maerwald_> uhm, have to find out where I got that function from
12:43:14 <demize> Hmm, https://hackage.haskell.org/package/diagrams-contrib-0.1.1.0/docs/Diagrams-TwoD-Layout-Tree.html ?
12:43:44 <maerwald_> right
12:43:52 <maerwald_> so you have to convert your binary tree to a roseTree
12:44:03 <maerwald_> and then you can just use diagrams to make a diagram out of it
12:44:09 <maerwald_> and diagrams can save it to an svg
12:44:20 <maerwald_> @src Tree
12:44:20 <lambdabot> Source not found. My brain just exploded
12:44:30 <maerwald_> @src Data.Tree.Tree
12:44:30 <lambdabot> Source not found. I am sorry.
12:44:40 <maerwald_> it's quite simple to convert trees to roseTrees
12:45:51 <demize> data RoseTree a = RoseTree a [RoseTree a]  ahh, that'll be simple indeed.
12:45:56 <demize> maerwald_: Awesome, thanks. :)
12:46:18 <Zemyla> Does enabling unicode syntax mean that ½ is a Fractional literal with the value of 1/2?
12:46:37 <hpc> you can define it that way
12:46:42 <int-e> > ½ -- no
12:46:43 <lambdabot>  <hint>:1:1: lexical error at character '\189'
12:46:50 <hpc> oh, or not
12:47:02 <int-e> mm, did I break that?
12:47:06 <Zemyla> @let ½ = 1/2
12:47:07 <lambdabot>  Parse failed: Illegal character ''\189''
12:47:09 <int-e> > let ä = 1 in ä
12:47:10 <lambdabot>  1
12:47:17 <hpc> unicode syntax means using the unicode double-colon character and the arrow characters for -> and =>
12:47:27 <hpc> and maybe others i am forgetting?
12:48:18 <Zemyla> So what characters can be used in alphanumeric names, and what characters can be used in operators?
12:48:41 <Zemyla> > [1…10]
12:48:43 <lambdabot>  Not in scope: ‘…’
12:48:51 <Cnky> int-e: you were right, thanks for help!
12:48:52 <Welkin> I think you can use anything in function names
12:49:07 <Zemyla> So … doesn't automatically work the same as ..?
12:49:09 * hackagebot ruby-marshal 0.0.1 - Parse a subset of Ruby objects serialised with Marshal.dump.  https://hackage.haskell.org/package/ruby-marshal-0.0.1 (filib)
12:49:51 <Welkin> > let 葡萄= (+1) in 葡萄 4
12:49:52 <lambdabot>  5
12:50:04 <hpc> Zemyla: by default, anything unicode defines as "it's a letter" you can use in an identifier
12:50:17 <hpc> Zemyla: (ditto for "it's a symbol" and in operator identifiers)
12:50:51 <hpc> Zemyla: http://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
12:50:54 <Welkin> > let … = (..) in [1…]
12:50:55 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
12:51:11 <Welkin> > let (…) = (..) in [1…]
12:51:11 <hpc> Zemyla: (click "Source" at the top to see that no extensions are used)
12:51:12 <lambdabot>  <hint>:1:12: parse error on input ‘..’
12:51:45 <Zemyla> .. isn't an operator, it's a syntactic element.
12:52:16 <int-e> > let (…) = enumFromTo in 1…5 -- oh well.
12:52:17 <lambdabot>  [1,2,3,4,5]
12:52:47 <Welkin> ah yes, enumFromTo
12:54:09 * hackagebot xlsx 0.1.0.5 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.1.0.5 (KirillZaborsky)
13:00:20 <lelf> Hello! Is there a nice way to write "proc x -> case x of { Just v -> returnA -< v; Nothing -> zeroArrow -< () }" ?
13:01:59 <nolraiU> So how do I get stack to install ghc 7.10?
13:02:36 <myfreeweb> nolraiU: use stackage nightly in your stack.yaml and run stack setup
13:03:06 <bitemyapp> nolraiU: stack setup 7.10
13:03:25 <brojo> I have a theorical question
13:03:34 <brojo> can i create a webpage with an iframe
13:03:55 <brojo> and when the user navigates the iframe i grab data from the iframe
13:04:09 * hackagebot servant-pandoc 0.4.1.1 - Use Pandoc to render servant API documentation  https://hackage.haskell.org/package/servant-pandoc-0.4.1.1 (mpickering)
13:05:10 <brojo> im trying to scrape a website that has a currently unbeatable captcha. But i was thinking of just buying traffic to a page that had this page iframed, and then the user fills captcha and the data that come on the next page exported to a db
13:05:12 <brojo> is this possible?
13:06:12 <demize> Well, that's a JS question, not a Haskell one.
13:06:54 <kristof> Did SML have bounded polymorphism before Haskell did?
13:19:10 * hackagebot opaleye-sqlite 0.0.0.0 - An SQL-generating DSL targeting SQLite  https://hackage.haskell.org/package/opaleye-sqlite-0.0.0.0 (tomjaguarpaw)
13:39:47 <solrize> kristof since when does sml have bounded polymorphism?  there are ways to do it with the module system but that's not really similar to haskell
13:43:21 <Peaker> There's the tick-Type-Var thing for Eq constraint :)
13:46:11 <jmcarthur_> i don't even know what is meant by "bounded polymorphism"
13:50:31 <the_2nd> which IDEs do you guys use?
13:50:37 <maerwald_> vim
13:50:45 <demize> jmcarthur_: Type classes in Haskell are an example of bounded polymorphism
13:51:47 <the_2nd> everyone using vim or other suggestions?
13:51:49 <demize> Binding the polymorphism to certain types.
13:51:54 <the_2nd> maerwald_, thanks so far
13:51:59 <silver> the_2nd, emacs also
13:52:10 <Peaker> What's a nice way to manually declare Functor,Foldable,Traversable instances with minimal boilerplate? I declare Traversable manually, have fmap=(traverse%~), but what can I do for Foldable?
13:52:14 <maerwald_> the_2nd: actually, emacs has better haskell support, but I won't switch my editor for just that
13:52:22 <silver> I know a man who uses mc edit
13:52:34 <maerwald_> there is also leksah, which is a real haskell oriented IDE (probably the only one?)
13:52:46 <silver> I bet there are peopla who use sublime text, atom etc.
13:52:51 <merijn> the_2nd: If you're already comfortable with a specific editor, I would just use that one
13:53:17 <the_2nd> I wanted to use leksah, but seems broken for arch
13:53:20 <maerwald_> merijn: I sometimes wonder why IDEs don't provide a feature to embed arbitrary editors within them
13:53:23 <merijn> the_2nd: A large portion here uses vim and emacs, and then it's all the usual suspects like sublime, atom, etc. some people use EclipseFP, but I think it's no unmaintained
13:53:25 <the_2nd> and dont feel like compiling from source
13:53:30 <maerwald_> I know, it's probably more complicated
13:54:14 <y> Peaker: isn't DeriveFoldable/Functor/Traversable/etc working?
13:54:15 <maerwald_> when I use leksah... I like the additional features it provides, but it's nowhere close to the editor experience of vim
13:54:19 <maerwald_> and I can't mix them
13:54:22 <Peaker> y: Nope, GADTs :(
13:54:39 <merijn> Peaker: I think then it can still work together with standalone deriving
13:55:01 <Peaker> merijn: it (incorrectly) complains about existentials
13:55:32 <Peaker> Oh wait, it no longer does after some (supposedly) unrelated changes
13:55:52 <merijn> Peaker: Are you sure you didn't accidentally have an existential after all?
13:55:53 <nikki93> is it true that <*> == lift2 ($)
13:55:54 <Peaker> merijn: btw, what's up with that? Why would standalone deriving be more powerful than "deriving" for the canonical deriving form?
13:55:58 <Peaker> merijn: pretty sure :)
13:56:04 <demize> maerwald_: Which additional features does it have over eg vim?
13:56:30 <maerwald_> demize: I don't even know how to call them
13:56:52 <maerwald_> like function definition/type lookup that does not suck
13:56:55 <the_2nd> okay, thanks all! I'll stick with vim/atom/subl then for haskell
13:56:56 <maerwald_> with some sort of dictionary
13:57:10 <the_2nd> IDE is always nice when just starting, but I'll figure it out
13:57:21 <demize> maerwald_: Mmm, there is a hoogle script for vim IIRC though
13:57:22 <merijn> :t liftA2 ($)
13:57:23 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
13:57:28 <maerwald_> demize: that's not even close to it
13:57:32 <merijn> nikki93: Basically, yes
13:57:54 <demize> Hehe, oh?
13:57:57 <MP2E> ooh
13:58:11 <MP2E> I feel like it should be obvious that liftA2 ($) is fmap, but that still surprised me :>
13:58:22 <MP2E> oh wait
13:58:24 <MP2E> i mean <*>
13:58:28 <MP2E> heh
13:58:51 <merijn> liftA2 is just "liftA2 f a b = fmap f a <*> b"
13:59:32 <merijn> "fmap ($)" onto "f (a -> c)" just produces "f (a -> c)" again
13:59:46 <merijn> So you can easily see it's indeed identical to <*>
14:01:11 <MP2E> ahhh
14:03:16 <citizen11> the_2nd: I use geany.
14:03:23 <citizen11> Oh, he left...
14:07:59 <catgocat> I have implemented a treeFold function, but it supringily returns an empty tuple for "Empty"
14:08:10 <lpaste_> catgocat pasted “treefold” at http://lpaste.net/137397
14:08:18 <catgocat> It's the treeMax I am refering to
14:08:26 <catgocat> treeMax Empty gives () why ?
14:08:54 <merijn> Whoo! Defaulting!
14:09:02 <merijn> catgocat: Try "treeMax foo :: Int"
14:09:19 <catgocat> merijn: I don't really want a solution, I want to know why
14:09:27 <merijn> catgocat: Basically, it doesn't know which "Bounded" instance you wanted, so GHCI defaults to using ()
14:09:39 <catgocat> why doesn't it throw an error?
14:10:15 <catgocat> and where is this behaviour referenced in the docs?
14:10:24 <merijn> Well, it's not an error. It just that the result is "treeMax foo :: (Bounded a, Ord a) => a", if you compiled this it would warn about an ambiguous type
14:10:40 <merijn> ghci has extended defaulting where ambiguous constraints can get defaulted to ()
14:10:50 <merijn> Since () is both an instance of Bounded and Ord
14:11:23 <merijn> See here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#extended-default-rules
14:24:43 <Peaker> > data M = M { x :: !(Map !Int !String) }
14:24:44 <lambdabot>  <hint>:1:1: parse error on input ‘data’
14:24:54 <Peaker> > data M = M { x :: !(Map Int String) }
14:24:55 <lambdabot>  <hint>:1:1: parse error on input ‘data’
14:26:22 <Peaker> Given that a strictness annotation in type subexpressions is not allowed, why does the ! need parenthesis at all? It's a silly oversight!
14:26:23 <demize> Unsure what the nicest way to convert my binary search tree to a rose tree is, hmrf.
14:26:48 <lpaste_> catgocat revised “treefold”: “sum” at http://lpaste.net/137397
14:26:56 <catgocat> I don't understand the lpaste
14:27:15 <catgocat> How does the Sum instance work if we don't use pattern match
14:27:20 <catgocat> and directly apply (+) to mappend ?
14:27:28 <catgocat> s/apply/attribute
14:27:49 <maerwald_> catgocat: close your sed statement
14:27:59 <Peaker> catgocat: "Sum" has a Num instance
14:28:03 <geekosaur> it's just a straight substitution: if that instance is selected, mappend is "replaced" by (+)
14:28:06 <Welkin> (+) is defined in Num
14:28:09 <catgocat> yeah but
14:28:13 <catgocat> Sum 1 + Sum 2 doesnt work
14:28:14 <merijn> catgocat: "Num a => Num (Sum a)"
14:28:27 <geekosaur> and that's a shorter way to say "mappend a b = a + b"
14:28:30 <merijn> > Sum 1 + Sum 2
14:28:32 <lambdabot>  Sum {getSum = 3}
14:28:36 <merijn> Works here :)
14:28:37 <Welkin> > (Sum 1) + (Sum 2)
14:28:38 <catgocat> what
14:28:38 <lambdabot>  Sum {getSum = 3}
14:28:50 <geekosaur> :t (+)
14:28:51 <catgocat>     No instance for (Num (Sum a0)) arising from a use of `+'     Possible fix: add an instance declaration for (Num (Sum a0))     In the expression: Sum 1 + Sum 2     In an equation for `it': it = Sum 1 + Sum 2
14:28:51 <lambdabot> Num a => a -> a -> a
14:28:54 <merijn> catgocat: 'Sum a' is a Num instance if 'a' is a Num instance :)
14:29:03 <merijn> catgocat: oh, which GHC version? Maybe this is new
14:29:21 <catgocat> Version 7.6.3
14:29:49 <Peaker> catgocat: What I do is I install base-compat, and use NoImplicitPrelude, and then import Prelude.Compat, and get the same API for all GHC versinos
14:29:50 <merijn> Right, this Num instance seems to have been added in 7.8
14:30:00 <catgocat> oh ok
14:30:04 <Peaker> The coupling of "base" with GHC is silly!
14:30:10 <catgocat> thanks
14:30:17 <Peaker> (or rather, the coupling of the Prelude API with GHC versions is very silly)
14:30:18 <merijn> catgocat: So you're looking at new source, but using an old version :)
14:30:28 <catgocat> how to upgrade
14:30:32 <catgocat> im on ubuntu
14:30:40 <geekosaur> use hvr's ppa
14:31:22 <geekosaur> https://launchpad.net/~hvr/+archive/ubuntu/ghc
14:34:13 * hackagebot lambdacms-media 0.4.0.0 - LambdaCms "media" extension  https://hackage.haskell.org/package/lambdacms-media-0.4.0.0 (cies)
14:37:21 <lpaste_> catgocat revised “treefold”: “myinstance” at http://lpaste.net/137397
14:37:29 <catgocat> Challenge: how would you make function types an instance of Monoid?
14:37:33 <catgocat> is that lpaste valid??
14:37:54 <catgocat> the challenge is not mine, but from an introductory book
14:38:27 <catgocat> or mappend = (.)
14:39:54 <merijn> catgocat: There's actually two sensible ones
14:40:06 <catgocat> tell me
14:40:26 <merijn> catgocat: There "instance Monoid a => Monoid (r -> a)" and "instance Monoid (a -> a)"
14:40:47 <merijn> The former has "f <> g = \x -> f x <> g x"
14:40:48 <catgocat> how is the second one defined?
14:41:08 <mzero> (<>) = (.)
14:41:17 <mzero> or perhaps
14:41:21 <mzero> (<>) = flip (.)
14:41:31 <merijn> The latter has mappend as (.), but it has a minor issue in that "Monoid (a -> a)" overlaps a bunch of stuff, so in base there is 
14:41:49 <merijn> "newtype Endo a = Endo (a -> a)" which is the composition version of the function Monoid
14:41:55 <catgocat> but why (a -> a) ? maybe because a function has to both return and accept the same type so it can be chained
14:42:06 <mzero> exactly
14:42:08 <merijn> catgocat: "mappend :: m -> m -> m"
14:42:16 <merijn> catgocat: Both arguments to mappend need to have the same type
14:42:36 <merijn> How can you compose two functions that have the same type, but don't have identical in and output types?
14:42:58 <merijn> "mappend :: (a -> b) -> (a -> b) -> (a -> b)" <-- clearly can't use composition
14:43:15 <merijn> Whereas "mappend :: (a -> a) -> (a -> a) -> (a -> a)" can use composition
14:44:27 <Welkin> hm
14:44:48 <Welkin> so mappend for (->) r can be (.), but fmap is also (.)
14:45:01 <ely-se> funfact: (.).(.) is fmap fmap fmap
14:46:36 <y> Welkin: (<>) :: (a -> a) -> (a -> a) -> (a -> a) vs fmap :: (b -> c) -> (a -> b) -> (a -> c)
14:47:01 <y> Welkin: there are way more implementations of (<>) than fmap there 
14:47:30 <y> @type (\f g x -> x) :: (a -> a) -> (a -> a) -> (a -> a)
14:47:31 <lambdabot> (a -> a) -> (a -> a) -> a -> a
14:47:41 <y> @type (\f g x -> f x) :: (a -> a) -> (a -> a) -> (a -> a)
14:47:42 <lambdabot> (a -> a) -> (a -> a) -> a -> a
14:47:44 <merijn> Welkin: mappend for "(->) r" can't exist, because (->) r has the wrong kind
14:47:53 <y> @type (\f g x -> f (g x)) :: (a -> a) -> (a -> a) -> (a -> a)
14:47:54 <lambdabot> (a -> a) -> (a -> a) -> a -> a
14:49:14 * hackagebot highjson 0.2.0.0 - Very fast JSON serialisation and parsing library  https://hackage.haskell.org/package/highjson-0.2.0.0 (AlexanderThiemann)
14:54:14 * hackagebot reroute 0.3.0.1 - abstract implementation of typed and untyped web routing  https://hackage.haskell.org/package/reroute-0.3.0.1 (AlexanderThiemann)
14:57:59 <GLM> How do I reverse a maybe list?
14:58:28 <catgocat> merijn: it has to be concret then?
14:58:55 <silver> GLM, fmap
15:01:14 <wagle> hmm..  haskell platform is dead?
15:01:30 <mzero> no, it is not
15:01:44 <mzero> there will be a new release - concurrent with GHC 7.10.2
15:01:52 <wagle> oic
15:02:01 <mzero> ETA of both sometime this week
15:02:08 <mzero> (I know as I've already built the masters!)
15:02:12 <geekosaur> 7.10.1 is buggy and the platform was tripping over some of the bugs
15:02:13 <wagle> heh
15:02:28 <geekosaur> (notably on OS X)
15:02:49 <wagle> so i waited just long enough to wake up and wonder
15:03:45 <wagle> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
15:03:48 <merijn> !!!!!
15:04:03 <merijn> ezyang on twitter: "Paradoxically, working on Backpack has helped me figure out how to remove hs-boot files."
15:04:08 <merijn> That would be the best thing ever...
15:04:15 * hackagebot fsnotify 0.2.0.1 - Cross platform library for file change notification.  https://hackage.haskell.org/package/fsnotify-0.2.0.1 (GregWeber)
15:04:25 <mzero> oy - the old trac wiki is dead - we should remove all the pages!
15:04:28 <Welkin> what are hs-boot files?
15:04:41 <wagle> oh..  whats the new?
15:05:01 <mzero> Welkin: they are for when you have modules that cross-reference each other
15:05:03 <merijn> Welkin: The lame hack to support recursive imports that GHC currently has
15:05:20 <mzero> wagle: github: https://github.com/haskell/haskell-platform
15:05:29 <mzero> but to be honest - we need a wiki librarian there too!
15:06:17 * wagle considers that and will stew for a couple days
15:07:26 <wagle> a half done wiki udate would be worse than now
15:09:31 <hotpocket> I'm running ghci in conque within vim and it doesn't seem to recognize when I backspace, move my cursor, or anything like that really
15:10:07 <hotpocket> like, if I hit backspace before pressing enter it'll tell me "lexical error at character '\b'"
15:10:12 <hotpocket> is there any way to fix that?
15:10:20 <wagle> printenv TERM in your shell
15:11:15 <wagle> oh..  i think that environment variable is odd or missing
15:11:28 <wagle> dunnoo how to fix
15:11:42 <hotpocket> if I do it in vim it says xterm-256color
15:11:47 <hexagoxel> why is (round :: Float->Int32) so stupidly slow? and allocates tons of memory per operation, relatively speaking?
15:11:49 <hotpocket> within ghci it says vt100
15:11:53 <hotpocket> I'm using cygwin btw
15:12:15 <wagle> both those should work, maybe thst isnt it
15:12:26 <wagle> both those should work, maybe that isnt it
15:13:03 <wagle> did you build with ncurses?
15:13:24 <hotpocket> don't know what that is so probably not haha
15:13:39 <wagle> did you build ghci?
15:13:53 * geekosaur suspects that it will simply not work right, because Windows doesn't really know how to do that properly
15:14:12 <geekosaur> (windows does not have a pty abstraction like unix does)
15:14:15 * hackagebot Ebnf2ps 1.0.14 - Peter's Syntax Diagram Drawing Tool  https://hackage.haskell.org/package/Ebnf2ps-1.0.14 (FranklinChen)
15:14:25 <hotpocket> I actually don't remember how I got ghci in cygwin
15:14:34 <hotpocket> probably through the setup
15:14:35 * wagle doesnt use cygwin/windows
15:15:07 <wagle> ok, geekosaur might have it as far as I know
15:15:17 <Peaker> does this have a standard name: newtype EffectOnly f a = EffectOnly (f ()) deriving (Functor) and the "obvious" Applicative instance ?
15:15:34 <hotpocket> I'm not very familiar with anything linux, I've just begun learning haskell recently and vim's editing appealed to me
15:16:21 <wagle> canrun linux in a virtual machine like virtualbox, or whatever the hot new thing is
15:17:08 <wagle> but stickaround to see if you can make it work in windows/cygwin from someone other than me
15:17:27 <hotpocket> alright
15:18:05 <geekosaur> yeh, not a lot of windows expertise around here. last time I poked at it, pretty much anything involving interactive buffers on windows emacs was an utter hack, though
15:19:15 * hackagebot highjson 0.2.0.1 - Very fast JSON serialisation and parsing library  https://hackage.haskell.org/package/highjson-0.2.0.1 (AlexanderThiemann)
15:19:17 * hackagebot reroute 0.3.0.2 - abstract implementation of typed and untyped web routing  https://hackage.haskell.org/package/reroute-0.3.0.2 (AlexanderThiemann)
15:19:48 <hotpocket> I guess I could just run it in a separate window, it only bugs out within vim
15:20:29 <wagle> i'm surprised that cygwin doesnt hack a pty abstraction somehow...  maybe there's a pty or ncurses cygwin package?
15:20:32 <geekosaur> (emacs and vim would have to have custom terminal emulators built in which understood the magic system calls Windows uses in place of escape sequences)
15:20:44 <geekosaur> it's been tried. it never worked well
15:20:54 <geekosaur> the whole concept is foreign to Windows
15:22:04 <hotpocket> also another weird thing
15:22:30 <hotpocket> if I run a haskell program within vim that does putStrLn then getLine, it does getLine first
15:22:34 <hotpocket> even with hFlush stdout
15:22:40 <hotpocket> but it does it the other way around in windows cmd
15:24:38 <geekosaur> yeh, that's pretty much to be expected, I think.
15:24:50 <geekosaur> windows simply does not provide the appropriate stuff for this to work well
15:25:41 <subleq__> is there a function \x -> forM_ [0..x] anywhere?
15:26:18 <subleq__> actually \x m -> forM_ [0..x] (\_ -> m)
15:26:29 <mniip> replicateM
15:26:57 <kristof> subleq__: zipWithM_?
15:27:05 <pavonia> :t \x m -> forM_ [0..x] (\_ -> m)
15:27:05 <lambdabot> (Enum a, Monad m, Num a) => a -> m b -> m ()
15:27:12 <subleq__> thanks mniip 
15:27:26 <kristof> subleq__: Oh, you didn't need the actual enumeration
15:27:40 <kristof> subleq__: If you did, I would use zipWithM_
15:27:40 <subleq__> :t zipWithM_
15:27:41 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
15:28:32 <Adeon> how do I make stack show warnings
15:28:42 <Adeon> like I write stack build and it builds but it doesn't show warnings even though my cabal file has -Wall
15:28:54 <Adeon> if I write stack build --verbose then it's too verbose
15:31:22 <Adeon> actually stack build --verbose doesn't show warnings either
15:31:28 <Adeon> I can see warnings in ghci
15:32:03 <the_2nd> is there some sort of auto-solver? or how can I implement one?
15:32:10 <the_2nd> having multiple function definitions
15:32:19 <the_2nd> a = 3.0 * b
15:32:28 <the_2nd> a = 2.0 * f
15:32:41 <the_2nd> b = 7.0 * e * g
15:32:47 <mniip> is it a system of linear---
15:33:00 <the_2nd> any type of function
15:33:14 <the_2nd> in c++ is solved it like to:
15:33:17 <mniip> nope it's not solvable in general I don't think
15:33:38 <the_2nd> if(!defined(a) && defined(b) && defined(c) {
15:33:51 <the_2nd> a = method(b, c); }
15:34:11 <the_2nd> having all methods defined like so
15:34:17 <mniip> huh
15:34:19 <the_2nd> and the program loop over the ifs
15:34:50 <the_2nd> and I think it can be solved better in haskell, thanks to lazyness
15:35:33 <mniip> the_2nd, I don't follow
15:35:34 <joobus> the_2nd: solved as in a system of linear equations?  you have 2 equations and 4 unknowns.  not solvable.
15:35:54 <mniip> the_2nd, what exactly do you want as the output
15:36:01 <mniip> and how does one 'loop over the ifs'
15:37:08 <the_2nd> paste coming
15:38:24 <the_2nd> mniip, http://pastebin.com/R1AP74g5
15:38:37 <the_2nd> joobus, see above
15:39:09 <the_2nd> if there's any way to solve the problem with the given parameters
15:39:15 <the_2nd> it will find it
15:40:13 <mniip> so
15:40:16 <mniip> what is defined()?
15:40:29 <the_2nd> I init all floats to some certain value
15:40:32 <the_2nd> and check for it
15:40:46 <the_2nd> once it's ever been changed, defined will return true
15:41:12 <wagle> express it in a let in haskell and see if it works?
15:41:18 <mniip> that doesb;t sound like C++
15:41:23 <mniip> doesn't*
15:41:29 <geekosaur> I don't know that anyone has written one, but I'd certainly think it doable. perhaps with a tying-the-knot technique, although the failure mode is kinda bad (bottom, expressed as an infinite loop)
15:41:51 <wagle> geekosaur: ya
15:42:10 <geekosaur> ...wait. loeb?
15:42:15 <mniip> hmm
15:42:17 <the_2nd> mniip, why not? I could have used a boolean for each parameter
15:42:25 <mniip> sounds like a unification problem
15:42:28 <the_2nd> but it's like 100-200 parameters
15:42:54 <dmj`> :/
15:42:55 <wagle> are the dependencies a tree?
15:43:34 <the_2nd> wagle, I think it's more 'random'
15:43:37 <mniip> solve the '(a ~ 3 * b, a ~ 2 * f, b ~ 7 * e * g, e ~ 2, g ~ 3) => a' constraint
15:44:01 <mniip> that's hidney-milner
15:44:16 * hackagebot hsdev 0.1.4.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.4.1 (AlexandrRuchkin)
15:44:58 <lpaste_> subleq__ pasted “Did I just reinvent pipes?” at http://lpaste.net/137401
15:45:42 <the_2nd> mniip, so I wrote hidney milner in my c++ and there's an easier way in haskell?
15:45:55 <mniip> nope that wasn't hidney milner
15:46:05 <the_2nd> but solveable with it?
15:46:13 <mniip> yeah I misunderstood the task
15:46:43 <mniip> sounded like you wanted to solve stuff like 'x = y - 1', 'y = 2 * x' without any input
15:47:03 <geekosaur> "Hindley-Milner", if you're trying to look this up somewhere
15:47:10 <the_2nd> currently checking out its wiki page
15:47:24 <the_2nd> looks too complicated for how late it is
15:47:28 <Pamelloes> Is there a version of  when :: m Bool -> m a -> m a?
15:47:30 <Peaker> @tell johnw ski had a nice idea: GADT AST instead of mutually recursive AST, allowing for a single fixed point. Working nicely so far
15:47:31 <lambdabot> Consider it noted.
15:47:33 <the_2nd> I'll check it out tomorrow
15:47:55 <geekosaur> https://github.com/quchen/articles/blob/master/loeb-moeb.md
15:48:27 <geekosaur> (this is not H-M, it is what I mentioned earlier: Löb's theorem, usually aka "loeb" in Haskell)
15:48:50 <the_2nd> mniip, you pasted a "solve the ..." above
15:49:07 <the_2nd> is this useable like that in haskell? or just an example?
15:50:01 <juri_> Yay. I just worked my way through my first really big haskell problem. ;)
15:51:02 <joobus> juri_: +1 :P
15:52:29 <juri_> upgrading to the newest optparse, from 9.1.1. difficulty: writing a Read instance for an enum.
15:53:26 <the_2nd> mniip, thanks
15:55:10 <joobus> is there a module/function in prelude for fetching a web page?
15:55:30 <joobus> or do i need to install a separate module?
15:56:42 <hexagoxel> seriously, manually unpacking the Float#, truncating to Int#, transforming to Word# and packing pack is faster than `truncate` ?
15:56:49 <hexagoxel> pssh, i am disapoint
15:57:05 <hexagoxel> s/pack /back /
16:06:53 <Darwin226> Say I'm writing a quasi quoter. Once I have the string in the quote, is there any way to run it through the default (e) quoter to get the Haskell AST out of it?
16:33:41 <__dd> hi, is there a way to find the element that occurred the most in a list without composition? (i.e. using a single function)
16:35:53 <MrMeowMeow> my instinct says to sort the list
16:36:06 <MrMeowMeow> when list is sorted, it'll be easier to check of items that occurred most
16:37:15 <y> __dd: why does it need to be a single "function"?
16:37:32 <__dd> y: not a specific reason, just experimenting :)
16:39:19 * hackagebot pontarius-xmpp 0.4.2.2 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.4.2.2 (JonKristensen)
16:39:29 <y> @type snd . maximumBy (compare `on` fst) . map (length &&& head) . group . sort
16:39:30 <lambdabot> Ord a => [a] -> a
16:39:58 <y> I think that should do it, but it's not what you want
16:40:38 <y> @type (snd . maximumBy (compare `on` fst) . map (length &&& head) . group . sort) ([3,3,4] ++ [1..10])
16:40:39 <lambdabot> (Enum a, Num a, Ord a) => a
16:40:45 <y> > (snd . maximumBy (compare `on` fst) . map (length &&& head) . group . sort) ([3,3,4] ++ [1..10])
16:40:46 <lambdabot>  3
16:45:06 <Intolerable> does lens have a Lens' a a?
16:45:13 <y> Intolerable: `id` 
16:45:42 <y> @type id :: Lens' a a
16:45:43 <lambdabot> Functor f => (a -> f a) -> a -> f a
16:45:51 <Intolerable> i assumed that wouldn't work
16:45:54 <Intolerable> but clearly does
16:45:55 <Intolerable> derp
16:45:56 <Intolerable> ty
16:46:00 <__dd> y: thanks
16:48:08 <Gurkenglas> snd . maximumBy (compare `on` fst) . map (length &&& head) looks like the kind of pattern that should be replaced by head . maximumBy (compare `on` length), but the memoization is the problem, and maximumBy can't be made to memoize because its argument might give independent results on its quadratically many calls. Should there be a version of on that memoizes its second parameter?
16:50:00 <y> Gurkenglas: I didn't even think of using compare `on` length, 
16:50:31 <y> s/,//
16:52:08 <Gurkenglas> (Actually, maximumBy's parameter giving rise to a linear ordering should mean that it factorizes through an Ord. Is there a reason not to just make maximumBy's type (Foldable t, Ord b) => (a -> b) -> t a -> a?)
16:53:03 <y> @type maximumBy 
16:53:03 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
16:54:35 <y> Gurkenglas: the actual type is more general, as you can always recover that version of maximumBy with `on`, I think?
16:55:01 <Gurkenglas> y, but then you get the memoization problem mentioned above
16:55:47 <y> Gurkenglas: I'd have a different function for that then
17:02:21 <Gurkenglas> y, the point is that the two types seem equally general, since afaik you're supposed to give maximumBy a relation that obeys transitivity, and thus it should be expressible via some Ord b => (a -> b).
17:18:49 <Intolerable> another lens question
17:19:06 <Intolerable> can i 'filtered' something then 'ix' it somehow?
17:51:43 <Pamelloes> Is there a standard library that provides the function getURL :: Text -> Bytestring?
17:52:06 <y> Pamelloes: what'd getURL do?
17:52:23 <Pamelloes> y: Get the contents at the provided url
17:52:52 <Pamelloes> So getURL "http://google.com/" would download the page at google.com
17:53:49 <y> ah, it's missing the IO part, makes sense
17:54:06 <Pamelloes> Oh yeah.... ooops.
17:54:37 <y> Pamelloes: have you looked at `HTTP`? 
17:55:33 <Pamelloes> That seems a little over the top for what I'm trying to do...
17:57:34 <Pamelloes> So google turns up the download package (https://hackage.haskell.org/package/download) which seems exactly what I'm looking for. It doesn't have too many downloads though, so if there is a more popular alternative I'm all ears :)
17:57:58 <y> Pamelloes: I haven't really played much with this, so I don't really know, I'd ignore me
17:58:40 <Pamelloes> hehe, no problem
17:58:49 <linman32> what are good places to look for haskell contract work?
18:00:13 <Pamelloes> Whelp the build of download failed. Clearly I should be using a different package :)
18:04:01 <khanage> Pamelloes: if you install HTTP, you should be able to do something like simpleHTTP (getRequest "http://www.haskell.org/") >>= getResponseBody
18:04:29 <Pamelloes> khanage: Oh, cool. Will that work with https?
18:04:30 <tuxtgz> hey where cani find haskell projects
18:04:30 <khanage> provided you import Network.HTTP
18:05:33 <Clint> Pamelloes: you may be better off with http-client-tls
18:06:14 <Pamelloes> Aside: what on earth is with HTTP's version system?
18:06:21 <ReinH> Pamelloes: depending on what you're doing, you might like wreq
18:07:22 <khanage> tuxtgz: https://hackage.haskell.org
18:07:23 <Pamelloes> Clint: That's not as high level as I'd like...
18:08:30 <Pamelloes> ReinH: Hm, that actually looks pretty nice.
18:08:42 <tuxtgz> is it still to lern haskell?
18:09:25 <codehero> http://lpaste.net/137405 is there any way to do this more elegant?
18:09:33 <ReinH> Pamelloes: it's pretty nice
18:09:42 <codehero> not asking about error handling but more about the converting string to int aspect
18:10:00 <codehero> i know that i wouldn't want to use error in real code, this is just an exercise
18:10:05 <Pamelloes> ReinH: Will it support https?
18:10:09 <ReinH> codehero: any reason for not using read?
18:10:45 <codehero> oh. well. it's an exercise on real world haskell
18:10:55 <codehero> i guess read would be optimal, but it would defeat the challenge
18:11:08 <codehero> the purpose also
18:11:55 <codehero> it's an exercise for folds
18:12:14 <ReinH> codehero: ah
18:12:23 <codehero> yupp
18:12:34 <codehero> but i'm not sure if i could get it more compact perhaps
18:12:36 <codehero> dunno
18:12:59 <y> codehero: I'd move the patterns a little bit
18:13:06 <ReinH> Well, (-1) * = negate, but I'm not sure why that's there
18:13:20 <codehero> oh. there's a negate function?
18:13:26 <codehero> oh. cool
18:13:36 <y> srToInt [] = error ""; strToInt ('-':xs) = (-1) * strToInt xs ; strToInt xs = code_working_with_positive_numbers 
18:13:37 <ReinH> seems like a bug to always negate the result
18:13:48 <ReinH> right
18:13:49 <codehero> ReinH: oh. lol
18:13:51 <codehero> yeah
18:13:53 <codehero> damn
18:14:02 <codehero> didn't notice that
18:14:16 <ReinH> y: where code_working_with_positive_numbers is strToInt
18:14:19 <codehero> and i thought i was being smart
18:14:25 <ReinH> oh right yeah
18:14:28 <ReinH> that's what you said
18:14:53 <y> ReinH: strToInt xs = strToInt xs is cheating
18:15:00 <ReinH> well yes
18:15:02 <codehero> y: that's what i was looking for. this looks perfect
18:15:25 <codehero> why did i not think about matching ('-':xs) D:
18:17:28 <y> codehero: minor suggestion, using foldl' instead of foldl
18:17:29 <codehero> thanks. works perfectly. i still have a long way to go, apparently
18:18:12 <codehero> yeah. foldl' is a lot better
18:18:33 <codehero> wouldn't want to use foldl with a number like "123456789"
18:18:36 <codehero> or longer
18:18:49 <codehero> well. 9 digits isn't that much
18:18:51 <codehero> but well
18:19:14 <y> it's just that there's no point in using foldl 
18:19:45 <codehero> true
18:20:15 <dramforever> > foldl' (\x acc -> x * 10 + (digitToInt acc)) 0 "12324356776524345678756432"
18:20:17 <lambdabot>  -5172841374303651248
18:20:22 <dramforever> =( overflow
18:20:31 <dramforever> > foldl' (\x acc -> x * 10 + (digitToInt acc)) 0 "12324356776"
18:20:32 <lambdabot>  12324356776
18:20:38 <y> change the type, s/Int/Integer/ :p  
18:20:47 <geekosaur> there is no digitToInteger
18:20:53 <geekosaur> but you could fromIntegral the result of that
18:20:57 <dramforever> anyway I remembered something about polynominals
18:21:21 <dramforever> exactly this way isn't it
18:21:22 <codehero> oh wow. defining concat with foldr was so hard. not
18:21:32 <codehero> at least i'm not braindead
18:21:52 <dramforever> codehero: you need to define a helper function don't you
18:22:05 <dramforever> okay so what functions do you have?
18:22:26 <codehero> dramforever: helper function for what?
18:23:00 <dramforever> for appending two lists together
18:23:21 <codehero> oh. nah
18:23:26 <codehero> concat' = foldr (++) []
18:23:29 <codehero> that's what i did
18:23:30 <dramforever> yes that's it
18:23:38 <dramforever> that's the correct solution
18:23:41 <codehero> yay
18:55:40 <Pamelloes> Lens' doctests take forever...
18:57:20 <tuxtgz> ''''''''''''''''''''''''''''''''''''''
18:58:30 <tuxtgz> '''''''''''
18:58:37 <tuxtgz> ''''''''########################################################################################################
18:58:37 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:38 <tuxtgz> #
18:58:39 <tuxtgz> #
18:58:39 <tuxtgz> #
18:58:58 <Pamelloes> Um...
18:59:12 <pacak> o_o
18:59:19 <geekosaur> cat?
18:59:21 <dogetime> Either cat on keyboard or flood fail
18:59:40 <dogetime> I hope just the first
18:59:54 <Pamelloes> How does a cat produce "#"?
19:00:08 <geekosaur> non-us keyboard?
19:00:18 <ackthet> cats are very talented
19:00:20 <geekosaur> not every keyboard layout has the symbols shifted
19:00:23 <gfixler> I tend to type a lot of ks when I fall asleep at the keyboard - strongest finger
19:00:25 <dogetime> Well on my keyboard the right shift and ~ are next to each other
19:00:33 <dogetime> So it'd be very easy
19:00:34 <nshepperd> one foot on shift, the other on 3
19:00:34 <Pamelloes> https://xkcd.com/1530/
19:01:08 <rom1504> it's a smart cat
19:01:26 <dogetime> European cat lol
19:01:30 <tuxtgz> ##############################################################################################################################################################################################################################
19:01:32 <Pamelloes> lens' doctests are still running..... :/
19:01:37 --- mode: ChanServ set +o geekosaur
19:01:42 <dogetime> Ok not a cat
19:01:49 <dogetime> lol
19:01:49 <Pamelloes> Spider.
19:01:55 <Pamelloes> Definitely spider.
19:01:59 <dogetime> Spider cat
19:02:11 <Pamelloes> Spider cat; Spider cat; Does whatever a spider cat does.
19:02:19 <dogetime> Haha
19:03:52 <dogetime> I really want to learn haskell, I idle here to remind me that I should start
19:04:04 <geekosaur> *snort* hexchat apparently thinks a line of #s is a url
19:04:18 <dogetime> Oh you're right, ha
19:04:19 <pacak> dogetime: Why don't you start right now? What exactly are you waiting for?
19:04:23 <dramforever> dogetime: start
19:05:15 <dogetime> The concepts feel kind of alien to me, I mean coming from C/C++
19:05:26 <geekosaur> oh, no, it thinks it's a channel name. doesn't even check the max name length...
19:05:27 <dogetime> It feels like I'm gonna have to set a big chunk of time aside to get my head around it
19:05:51 <geekosaur> it will definitely twist your mind a bit, in a good way
19:05:52 <pacak> dogetime: So? Sitting here and doing nothing - won't help you.
19:05:58 <Pamelloes> dogetime: Big chunks of time are made of little chunks of time :{
19:06:00 <Pamelloes> * :P
19:06:08 <pacak> dogetime: On the other hand if you start writing some haskell...
19:06:10 --- mode: geekosaur set -o geekosaur
19:06:13 <Pamelloes> "Yesterday you said tomorrow"
19:06:28 <dramforever> dogetime: just start =)
19:06:39 <dramforever> we are here to help you when you get stuck
19:07:14 <pacak> dogetime: https://www.google.com.sg/trends/explore#q=diet%2C%20gym%2C%20fitness&cmpt=q&tz=Etc%2FGMT-8 
19:07:20 <pacak> dogetime: looks familiar?
19:08:37 <pacak> dogetime: They are also waiting for something.
19:08:58 <dogetime> Heh I will start, I can't right now because it's 3am and I'm falling asleep but I will tomorrow
19:09:23 <dramforever> dogetime: are you sure? tomorrow?
19:09:30 <dogetime> Well technically today
19:09:38 <pacak> dogetime: Sure, they will start as well. Next year.
19:09:42 <Pamelloes> dogetime: 3 am is the best time to start! You will read stuff. It will make no sense. And then you will go to sleep. And then it will magically make sense!
19:09:54 <Pamelloes> Or it won't.
19:09:57 * Pamelloes shrugs
19:10:10 <dogetime> Ok, I'll read a bit ha
19:10:32 <pacak> Pamelloes: Usually works for me.
19:11:16 <Pamelloes> pacak: I think it's 50/50
19:12:35 <dogetime> Oh wow, there's a school of haskell, I missed these tutorials last time I was looking
19:12:56 <dogetime> Unless there's somewhere better I should be looking
19:13:22 <pacak> dogetime: lyah
19:13:26 <pacak> @whereis lyah
19:13:26 <lambdabot> Maybe you meant: where+ where
19:13:30 <pacak> @where lyah
19:13:30 <lambdabot> http://www.learnyouahaskell.com/
19:14:03 <dogetime> Hmm site is down for me
19:14:36 <dramforever> interesting
19:14:42 <dramforever> down here too
19:14:43 <pacak> Same here. Oh noes!
19:14:49 <dogetime> I'll bookmark it though, the title looks promising
19:15:36 <pacak> dogetime:  https://github.com/igstan/learn-you-a-haskell-kindle
19:16:34 <dogetime> Aha, thanks!
19:17:03 <dogetime> I actually have a kindle so now I can learn on the go ha
19:29:00 <subleq__> is this basically what pipes or conduits does? https://gist.github.com/gavinwahl/8e6f90b7143bbac9bced
19:31:09 <latro`a> any thoughts on a less wasteful but still readable way to write: (xLeft,xRight) = splitAt n xs; yLeft = map f xLeft; yRight = map g xRight; y = yLeft ++ yRight
19:31:40 <latro`a> there's an obvious way to do this with a single explicit traversal, but that's a bit ugly
19:32:26 <dramforever> latro`a: what about a counter when traversing?
19:32:38 <latro`a> that would be the obvious way to do it
19:32:43 <pacak> latro`a:  zipWith ($) (replicate n  f ++ repeat g) xs
19:32:56 <dramforever> pacak: that's more wasteful
19:33:17 <latro`a> the wasteful thing is the ++; no ++ is actually required
19:33:27 <Pamelloes> lens' doctests are still running. It's been 45 minutes D:
19:33:57 <latro`a> (it's a nicer approach than mine for pretty much the same efficiency, though)
19:34:05 <pacak> latro`a: You can create first list using list comprehensions
19:34:09 <dramforever> @free (a -> b) -> [a] -> [b]
19:34:09 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
19:34:13 <dramforever> Huh?
19:34:31 <dramforever> okay should have added map::
19:35:01 <Gurkenglas> :t \f g n -> uncurry (++) . (f *** g) . splitAt n
19:35:02 <lambdabot> ([a1] -> [a]) -> ([a1] -> [a]) -> Int -> [a1] -> [a]
19:36:00 <latro`a> actually, you can also make the list of functions with map, so that would be smooth
19:36:07 <pacak> zipWith ($) [if i >= n then f else g | i <- [0..]] xs
19:36:47 <pacak> map (\i -> if i >= n then f else g) [1..]
19:37:30 <Gurkenglas> (You'd need to zip the last one with xs afterwards.)
19:37:49 <pacak> Right.
19:38:06 <Gurkenglas> But what's wasteful about replicate n f ++ repeat g?
19:38:25 <pacak> Gurkenglas: ++ is not very efficient.
19:38:40 <Gurkenglas> @src (++)
19:38:40 <lambdabot> []     ++ ys = ys
19:38:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:38:40 <lambdabot> -- OR
19:38:40 <lambdabot> xs ++ ys = foldr (:) ys xs
19:38:51 <Gurkenglas> Doesn't look that bad to me
19:39:02 <pacak> It needs to traverse first list
19:39:15 <Big_G> How can I pass something in a monad to a non-monadic function that takes another non-monadic value
19:39:17 <Gurkenglas> But it's lazy, so it doesn't need to do that immediately
19:39:38 <pacak> Gurkenglas: Sure, but it needs to traverse it anyway
19:39:52 <pacak> Big_G: fmap
19:40:03 <dramforever> Big_G: or bind it to a variable first
19:40:08 <Big_G> pacak, How specificallly?
19:40:13 <pacak> > fmap (+1) (Just 4)
19:40:14 <lambdabot>  Just 5
19:40:39 <pacak> (+1) - non-monadic function, (Just 4) - monad
19:40:40 <Gurkenglas> The whnf of (1:2:[]) ++ (2:3:[]) is just 1 : ((2:[]) ++ (2:3:[]))
19:41:06 <Big_G> pacak, Let me clarify. I want to use zipwith on a mybe list and a list
19:41:12 <Gurkenglas> You need to traverse both lists anyway to apply f
19:41:16 <Gurkenglas> (and g)
19:41:42 <pacak> Gurkenglas: Right, but first list will be traversed twice.
19:41:49 <pacak> that's why we have dlists
19:42:16 <Gurkenglas> Once you do two traversal's, I wouldn't bet against the compiler fusing them into one
19:42:34 <pacak> Gurkenglas: It can't.
19:42:47 <y> Big_G: can you tell me the types of what you are doing?
19:42:57 <dramforever> Big_G: yes, what's the problem with it?
19:42:59 <pacak> > (zipWith (+) [1..]) <$> (Just [1..10])
19:43:01 <lambdabot>  Just [2,4,6,8,10,12,14,16,18,20]
19:43:05 <pacak> > (zipWith (+) [1..]) <$> (Nothing)
19:43:07 <lambdabot>  Nothing
19:43:25 <y> > zipWith (+) <$> Just [1..] <*> Nothing
19:43:26 <lambdabot>  Nothing
19:43:32 <Big_G> dramforever, y They're of type Maybe [Int] and [Int]
19:43:44 <dramforever> yes so look out:
19:43:48 <pacak> Big_G: ^
19:44:01 <dramforever> :t zipWith (+) ([1,2,3,4,5] :: [Int])
19:44:02 <lambdabot> [Int] -> [Int]
19:44:06 <dramforever> :t fmap
19:44:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:44:26 * hackagebot base-orphans 0.4.1 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.1 (ryanglscott)
19:44:30 <dramforever> :t fmap :: ([Int] -> [Int]) -> Maybe [Int] -> Maybe [Int] -- specialize
19:44:30 <lambdabot> ([Int] -> [Int]) -> Maybe [Int] -> Maybe [Int]
19:44:35 <Gurkenglas> The weak head normal form of zipWith ($) (replicate 10 F ++ repeat G) [1..] is (($) F 1) : (replicate 9 F ++ repeat G) [1..], which took constant time to produce.
19:44:37 <dramforever> and here you are
19:45:38 <dramforever> Gurkenglas: that's still wasted constant time
19:45:38 <pacak> Gurkenglas: But once you evaluate everything you will find that first list was traversed twice. Check about dlist, costrength transformation and other similar stuff.
19:45:45 <nshepperd> (++) adds a 'layer of overhead' to calculation of each element of the resulting list every time you use it
19:47:10 <latro`a> by contrast, a function that returns (xs,map f xs) should, in principle, be able to be fused, right?
19:47:11 <nshepperd> well, to each element of the first part
19:47:12 <pacak> Gurkenglas:   foldl' (\acc x -> acc  ++ [x]) []  [1..10000]
19:47:17 <y> that's the reason a ++ (b ++ (c ++ d)) is "better"
19:47:26 <pacak> Gurkenglas: O(n^2) complexity.
19:47:35 <Gurkenglas> pacak, but we only have one ++.
19:47:46 <nshepperd> I wouldn't say (++) is intrinsically bad on its own
19:48:03 <nshepperd> ie. when you use it once
19:48:18 <Gurkenglas> I would compare the overhead we got from it with that the if i<=n solution would generate
19:48:19 <nshepperd> but you do still pay a O(n) cost
19:48:44 <y> it's an O(n) cost that you pay "as you go"
19:49:19 <latro`a> I wound up with this: http://lpaste.net/4824247703707844608
19:49:30 <y> also, a ++ (b ++ c) means you can return something in constant time, (a ++ b) ++ c is where it becomes dirty
19:49:33 <latro`a> which I think is OK; I can force the fusion if need be
19:49:52 <latro`a> anyone disagree?
19:50:44 <pacak> latro`a: comps  could be a bunch of 0 and 1 and you can use (>) instead of ($)
19:50:45 <Gurkenglas> Someone please tell me lambdabot has a command to benchmark two implementations of a function
19:51:10 <Pamelloes> ReinH: Thanks for recommending Wreq :) I just finished compiling it and it's working beautifully.
19:51:19 <geekosaur> nope, sorry. mostly because lb times out a bit earlier than you'd like for a benchmark
19:51:58 <latro`a> (I had one type error, but it was actually better with the other type); nbd
19:53:32 <Gurkenglas> Hmm. Can we get as close as we can within that time limit? Maybe zip the computations to reduce time-local error etc
19:54:18 <y> map (\n -> if n <= stepEdge then (>1) else (>0)) [0..] smells like map (flip (>)) (replicate (stepEdge+1) 1 ++ [0,0..])
19:56:39 <y> zipWith ($) (map f xs) ys =? zipWith f xs ys 
19:57:05 <dramforever> y: you can try to prove that =)
20:09:42 <y> dramforever: indeed you can 
20:09:47 <dramforever> =)
20:20:33 <Javran> :t foldMap
20:20:35 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:20:37 <Javran> :t zipWith
20:20:38 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:21:06 <dramforever> :t traverse
20:21:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
20:21:16 <dramforever> :t liftA2
20:21:17 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:21:27 <Javran> @hoogle (Foldable t, Monoid m) => (a -> b -> m) -> t a -> t b -> m
20:21:28 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
20:21:28 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
20:21:28 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
20:22:05 <Javran> or something more general ...
20:22:07 <dramforever> Javran: that doesn't really make sense
20:22:33 <dramforever> how do you expect it to behave?
20:24:00 <Javran> :t foldMap ?a (zipWith ?b ?c ?d)
20:24:01 <lambdabot> (?a::a -> m, ?b::a1 -> b -> a, ?c::[a1], ?d::[b], Monoid m) => m
20:24:27 <dramforever> zippily?
20:24:29 <dramforever> =)
20:24:32 <Javran> it's just a concatMap in disguise
20:24:44 <dramforever> :t concatMap
20:24:45 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
20:25:05 <dramforever> maybe
20:25:12 <Javran> maybe I should said foldMap but with n-foldables
20:25:18 <Javran> n=2 in this case
20:27:14 <dramforever> Bifoldable?
20:28:37 <Javran> sometimes I feel lisp is more convenient of doing this... for example map and zip are the same thing in it
20:29:02 <dramforever> Javran: I'm still not sure what you are trying to do....
20:31:54 <ttt_fff> does allowing 'non-global-root-level functions' screw up type checking
20:32:15 <ttt_fff> it seems that if I force all labmdas to be at the global level, only top level exprs are quantified, and everything else are not quantified
20:32:37 <ttt_fff> but if I allow let blah = \x -> ... , then even inside a "local env", I have to allow expressiont o have types of the form (forall a .... )
20:33:38 <Cale> ttt_fff: I don't understand what you mean...
20:33:49 <ttt_fff> Cale: I'm trying to write a type checker, and I'm an idiot
20:33:49 <Cale> What's a root level function?
20:34:50 <ttt_fff> imagine for a moment, we're using scheme instaed of haskel, if I have something like (defn (concat x y) (++ x y)), then we get something like "++ :: _0 -> _0 -> _0"
20:35:04 <ttt_fff> damn it, I can't expalin it
20:35:17 <ttt_fff> the type is osmething like (\a -> a -> a -> a)
20:35:24 <ttt_fff> actually, I don't know
20:35:26 <Cale> uhhh
20:35:37 <ttt_fff> I know taht I'm confused
20:35:39 <ttt_fff> I don't know much else
20:35:41 <Cale> You want some indication that it has something to do with lists in there probably
20:35:55 <dramforever> ttt_fff: I don't know, but why are you making every lambda top level *while* giving them types?
20:36:02 <ttt_fff> I don't know.
20:36:04 <ttt_fff> I'm confused.
20:36:15 <ttt_fff> imagine I'm using debruijin indices for representing types
20:36:30 <ttt_fff> there are two types of types, things of the form:  "_2 -> _3 -> _1"
20:36:41 <ttt_fff> and thpes of the form "\x \y \z -> _2 -> _4 -> _1"
20:36:49 <dramforever> ttt_fff: can you do lambda lifting *after* erasing types?
20:36:50 <ttt_fff> now, types of the first form don't have quantifiers; types of the 2nd form do
20:37:12 <Cale> ttt_fff: Is it intentional that x, y and z don't appear to the right of the -> ?
20:37:26 <dramforever> ttt_fff: maybe I'm stupid, but I don't see why you need lambda lifting
20:37:32 <ttt_fff> Cale: yeah, in "\x \y \z "  we have _0 maps to 0, _1 maps to y, _2 maps to x
20:37:38 <Cale> With de Bruijn indices, you normally don't indicate which variable the lambda is
20:37:50 <ttt_fff> Cale: agreed, how should I write it instead?
20:37:55 <ttt_fff> \.\.\. _2 -> _3 -> _1 
20:37:57 <ttt_fff> ?
20:38:02 <dramforever> \ \ \ _2 -> _3 -> _1
20:38:05 <Cale> yeah, pretty much
20:38:23 <Cale> Of course, that should also probably be forall instead of lambda
20:38:24 <dramforever> if you used the greek letter lambda it will look much better
20:38:32 <ttt_fff> okay, so type A = _2 -> _3 -> _1, type B = \ \ -> _2 -> _3 -> _1
20:38:33 <Cale> But the difference is pretty minor
20:38:40 <ttt_fff> now, anytime I use a lambda, it seems I get a type of the form "Type B"
20:39:09 <Cale> You're worried about where let generalisation should occur?
20:39:18 <Cale> Are you using the lambdas here to indicate polymorphism?
20:40:56 <ttt_fff> (thinking)
20:41:24 <ttt_fff> why the fuck am I worired about this?
20:41:31 <ttt_fff> haskel doesn't even support polymorphism, and ask ppl to use type classes instead
20:41:42 <Cale> Huh?
20:41:53 <Cale> It does have parametric polymorphism
20:41:58 <Cale> :t (\x -> x)
20:41:59 <lambdabot> r -> r
20:42:04 <Cale> ^^ no type classes here
20:42:27 <Cale> Of course, that's really  forall r. r -> r
20:42:31 <ttt_fff> okay okay, I have figured out my stupidity
20:42:34 <dmj`> :t id
20:42:35 <lambdabot> a -> a
20:42:39 <ttt_fff> I can now exaplgin what is confusing me, and you guys can help me
20:42:47 <dmj`> no typeclasses there
20:42:56 <dramforever> dmj`: so?
20:42:56 <y> Cale: and ghc even has higher-rank types! :P 
20:42:59 <Cale> We have the weird convention that foralls at the top level of a type annotation or signature are left implicit, and capture all free variables
20:43:20 <ttt_fff> I have the following: TSig = TSigInt Int | TSigTo TSig TSig ; TSigQ = TSigQ Int TSig ; where the Int = # of lambdas
20:43:21 <dmj`> dramforever: he said haskell didn't support polymorphism, but it asks people to use type classes instead
20:43:29 <dramforever> dmj`: he?
20:43:35 <dmj`> ttt_fff: ?
20:43:37 <ttt_fff> now, I'd like my expressions to have type TSig, rather than TSigQ
20:43:49 <dmj`> dramforever: ttt_fff
20:43:52 <ttt_fff> I will verify that I am indeed a 'he'
20:44:00 <dmj`> I apologize he/she
20:44:01 <ttt_fff> now, the problem is that I have a function "=="
20:44:04 <dramforever> dmj`: it?
20:44:05 <fishburne> do anyone here have used "Database.PostgreSQL.Simple.Arrays" to run queries that use array_agg function to return grouped result as postgresql arrays?
20:44:08 <ttt_fff> I'm pretty sure ttt_fff is a he.
20:44:22 <ttt_fff> Anywy, I have a function ==, which is of form \ _0 -> _0 -> Bool
20:44:25 <ttt_fff> and now I
20:44:37 <ttt_fff> and now I'm said, since it has type TSigQ, but I wanted to represent exprs / symbols with type TSig
20:44:38 <dramforever> dmj`: what's that "it" in the sentence?
20:44:47 <ttt_fff> and now I realize this is because == is polymorphim (or in haskell, uses typeclasses)
20:44:56 <dramforever> *polymorphic
20:45:08 <ttt_fff> dramforever : 'it' = haskell, haskell asks ppl to use typeclasses
20:45:10 <Cale> ttt_fff: Right, (==) isn't normally parametrically polymorphic
20:45:19 <dmj`> dramforever: what ttt_fff said
20:45:23 <jmcarthur_> (==) uses ad hoc polymorphism. that just means its implementation depends on the type it is being used with.
20:45:23 <dramforever> wtf
20:45:48 <Cale> Or type class polymorphism instead of ad-hoc, like in Haskell
20:46:36 <Cale> Something like map provides a better example of parametric polymorphism, or if you want something simpler, but still not entirely trivial, flip
20:46:49 <jmcarthur_> i always considered type class polymorphism to just be a specific kind of ad hoc polymorphism. am i wrong?
20:46:49 <Cale> :t flip
20:46:50 <lambdabot> (a -> b -> c) -> b -> a -> c
20:47:30 <Cale> jmcarthur_: You can think of it that way, but I prefer to reserve "ad hoc polymorphism" for the sort of polymorphism where the implementation being chosen can't be deferred.
20:47:35 <jmcarthur_> (ignoring the dictionary passing model, which could be seen as either making it not truely ad hoc polymorphism or as just an implementation detail...)
20:47:57 <Cale> jmcarthur_: The cool thing about type class polymorphism is that you can define new type class polymorphic things just by using other type class polymorphic things
20:48:12 <Cale> Like just by using (<=), you get a polymorphic sort
20:48:27 <codehero> could someone give me an example of what groupBy does?
20:48:32 <Cale> and you're not forced to determine the type of (<=) at its call site -- that choice can be deferred until later
20:48:39 <jmcarthur_> i guess i'm so used to type class polymorphism that i am not used to thinking about the limitations of other approaches.
20:48:49 <Javran> :t groupBy
20:48:50 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
20:49:00 <Javran> > groupBy "aaabcbbbccccc"
20:49:01 <lambdabot>      Couldn't match expected type ‘a -> a -> Bool’
20:49:01 <lambdabot>                  with actual type ‘[Char]’
20:49:01 <lambdabot>      In the first argument of ‘groupBy’, namely ‘"aaabcbbbccccc"’
20:49:06 <jmcarthur_> codehero: are you familiar with what group does?
20:49:12 <Javran> > groupBy (==)  "aaabcbbbccccc"
20:49:14 <lambdabot>  ["aaa","b","c","bbb","ccccc"]
20:49:19 <dmj`> @src group
20:49:19 <lambdabot> group = groupBy (==)
20:49:56 <Javran> > groupBy ((==) `on` (`mod` 2)) [1..10]
20:49:58 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
20:50:30 <solatis> hmmm is it possible to downgrade cabal ?
20:51:06 <dmj`> solatis: cabal install cabal-install-<old-version> ?
20:51:20 <solatis> dmj`: oh d'oh :/
20:51:22 <solatis> i'm stupid
20:51:24 <fishburne> do anyone here have used "Database.PostgreSQL.Simple.Arrays" to run queries that use postgres array_agg function to return grouped result as an array? I don't know how to specify the type of the result set.
20:51:27 <dmj`> solatis: no you're not :)
20:51:39 <Cale> codehero: groupBy p xs will partition the list xs into nonempty parts whose concatenation is xs, and such that for each part (y:ys), you have p y z for each z in ys, and lastly, such that the sequence of lengths of the parts is lexicographically maximal (i.e. it's greedy about adding things to earlier parts rather than starting a new part)
20:51:41 <solatis> didn't realize that was a feature, couldn't find it anywhere documented!
20:51:58 <codehero> hm
20:52:03 <Javran> I think cabal-install contains a script for bootstrapping, just in case the current cabal is broken
20:52:05 <dmj`> solatis: yea I don't think it is either :/
20:52:51 <codehero> is there any other use for groupBy than with (==)?
20:53:27 <Cale> > groupBy (<) [1,1,2,1,2,3,1,2,1,2,3]
20:53:28 <jmcarthur_> > groupBy ((==) `on` snd) (zip [0..] "aaabbcccccddddddddddeff")
20:53:29 <lambdabot>  [[1],[1,2],[1,2,3],[1,2],[1,2,3]]
20:53:30 <lambdabot>  [[(0,'a'),(1,'a'),(2,'a')],[(3,'b'),(4,'b')],[(5,'c'),(6,'c'),(7,'c'),(8,'c'...
20:53:37 <pacak> :t groupBy odd
20:53:38 <lambdabot>     Couldn't match type ‘Bool’ with ‘a -> Bool’
20:53:38 <lambdabot>     Expected type: a -> a -> Bool
20:53:38 <lambdabot>       Actual type: a -> Bool
20:53:50 <codehero> well odd is a -> Bool
20:54:05 <pacak> Right, my bad.
20:54:09 <Cale> Despite the fact that the Report says that groupBy is only specified for equivalence relations, I've actually had more than one occasion on which groupBy (<) was useful
20:54:44 <Cale> One example was when I was breaking a document with 1.2.3.4 style section numbers up into a tree
20:54:48 <jmcarthur_> groupBy could definitely benefit from a tighter specification
20:55:23 <Javran> I think most of the time you'd see something like "groupBy ((==) `on` f)" where f extracts a property from elements
20:55:34 <codehero> :t on
20:55:35 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:55:39 <codehero> oO
20:55:40 <jmcarthur_> @src on
20:55:40 <lambdabot> (*) `on` f = \x y -> f x * f y
20:56:02 <fishburne> how can I use postgresql simple to run a query that return arrays in its result?
20:56:05 <Cale> Using groupBy comparing the number of segments in the section numbers broke the list of sections into a list of lists where the first element of each list had fewer section parts than the rest (which would then be its children in the tree)
20:56:08 <codehero> oh. that looks simpler, but what's the (*)?
20:56:16 <codehero> i assume it's not multiplication
20:56:22 <jmcarthur_> codehero: (*) is just what they chose to name the argument
20:56:29 <codehero> oh
20:56:31 <codehero> k
20:56:51 <Cale> So (==) `on` fst for example is \x y -> fst x == fst y
20:57:07 <jmcarthur_> i think naming arguments as operators is usually a bit... gratuitous
20:57:08 <Javran> > sortBy (compare `on` snd) [(1,3),(2,4)]
20:57:10 <lambdabot>  [(1,3),(2,4)]
20:57:20 <codehero> Cale: now i see. easy
20:57:21 <Javran> > sortBy (compare `on` fst) [(1,3),(2,4)]
20:57:22 <lambdabot>  [(1,3),(2,4)]
20:57:25 <Javran> :t comparing
20:57:27 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:57:35 <Cale> > groupBy ((==) `on` fst) [(1,'a'),(1,'b'),(2,'c'),(2,'d')]
20:57:37 <lambdabot>  [[(1,'a'),(1,'b')],[(2,'c'),(2,'d')]]
20:58:15 <codehero> that looks useful. somehow
20:58:20 <jmcarthur_> > map unzip (groupBy ((==) `on` snd) (zip [0..] "aaabbcccccddddddddddeff"))
20:58:21 <lambdabot>  [([0,1,2],"aaa"),([3,4],"bb"),([5,6,7,8,9],"ccccc"),([10,11,12,13,14,15,16,1...
21:00:23 <fishburne> anyone here with experience in postgresql-simple library?
21:09:48 <lethjakman> so...the yesod guide suggests not compiling your application on the server...but how do you do that with haskell if you're using osx for development and linux for your server? 
21:10:05 <dmj`> how would I mimic redis's TTL functionality with just an IORef and a Map, would I have to fork a thread for each new key in the map and then self-destruct at a given interval?
21:10:08 <lethjakman> maybe docker would be better for this...
21:10:33 <dmj`> lethjakman: use a continuous integration server like travis / circleci
21:10:41 <lethjakman> dmj`: good idea!
21:11:52 <lethjakman> seems like I'd want an exact replica though...maybe I should attempt this with jenkins or something. 
21:12:58 <dmj`> lethjakman: yea I'd make sure the CI server and deploy server are the same flavor of linux
21:13:20 <lethjakman> yeah, seems a bit more finicky with a compiled language
21:14:41 <dmj`> lethjakman: yea, but only needing a single binary is clean.
21:14:52 <lethjakman> true
21:14:59 <lethjakman> honestly I'm thinking docker might be nice
21:15:03 <dramforever> maybe docker
21:15:04 <lethjakman> that way I only ever have one environment
21:15:05 <dramforever> yes
21:15:07 <lethjakman> lol
21:15:11 <lethjakman> or rocket!
21:15:22 <dramforever> and don't compile your app in the docker container!
21:15:27 <lethjakman> dramforever: have you done a lot of docker compiles?
21:15:30 <lethjakman> er
21:15:31 <dramforever> no
21:15:34 <dramforever> =(
21:15:37 <lethjakman> I read that when I was typing
21:15:39 <lethjakman> I meant docker deploys
21:15:47 <lethjakman> dramforever: if you don't compile it in the container what do you do?
21:15:56 <dramforever> I just heard about it
21:16:01 <dramforever> lethjakman: compile outside
21:16:06 <lethjakman> I was assuming I could compile it locally in the container and either commit that or push it up. 
21:16:11 <lethjakman> dramforever: but I'm running on OSX
21:16:15 <dramforever> =(
21:16:22 <dramforever> sorry gotta run
21:16:39 <lethjakman> you're fine
21:16:43 <lethjakman> cya!
21:16:47 <dmj`> lethjakman: circle ci can do different things based on the branch you are building against, so if master you can build a docker file from a base image and upload it to a hub, or if dev deploy to a dev box, etc. O/w just run tests.
21:16:57 <dmj`> https://github.com/freebroccolo/docker-haskell
21:17:20 <lethjakman> nice find!
21:17:21 <zilinc> I have a datatype `Monad m => [m (Maybe t)]', I'd like to do some kind of fold that, if all elements in the list are `m Nothing', return Nothing, otherwise for `m Nothing'-elements I have a generator which returns some `b::t' for the fold, for `m (Just a)'-elements, I just use `a::t' in the fold. What data structure (i.e. classes) can I use for that? I feel Reducer might be useful but not quite.
21:17:44 <johnw> m Nothing does not make sense
21:17:57 <dmj`> lethjakman: I've never tried, but you could compile to LLVM
21:18:11 <lethjakman> dmj`: what do you mean?
21:18:17 <zilinc> johnw: sorry I know.. my description wasn't formal
21:18:32 <johnw> I don't even really know what you mean by m Nothing
21:18:36 <lethjakman> compile to llvm
21:18:42 <dmj`> lethjakman: well ghc has an llvm backend, from there you can go from llvm->native. It's an extra step, but agnostic
21:18:59 <lethjakman> think it'd save some compile time?
21:19:02 <dmj`> lethjakman: http://llvm.org/
21:19:03 <lethjakman> that's a brilliant idea
21:19:13 <lethjakman> I know llvm, I just didn't know there was a such thing as compiling to llvm
21:19:21 <lethjakman> I thought it was just a C++ compiler
21:19:32 <rcyr> lethjakman: Nah, LLVM is not even a C++ compiler
21:19:49 <lethjakman> then I've been horribly confused. 
21:19:59 <lethjakman> that's neater than I thought it was
21:20:04 <lethjakman> osx talks about it like it's a compiler
21:20:14 <dmj`> lethjakman: nah, not really. If you use Circle CI you can pull build artifacts (so you can download the compiled binary (from debian) to your osx desktop), and scp it somewhere
21:20:19 <zilinc> johnw: I mean that running the monad on the element returns Nothing
21:20:52 <rcyr> lethjakman: LLVM is a low level virtual machine. It's representation is LLVM IR and compilers, like CLang (For C++) generates that format.
21:20:59 <johnw> there's no way to know that the action will yield Nothing without using another action
21:21:05 <lethjakman> dmj`: you seem to use CI's a lot, do you prefer circle ci or another?
21:21:06 <ttt_fff> :t (\x -> flip)
21:21:07 <lambdabot> r -> (a -> b -> c) -> b -> a -> c
21:21:29 <rcyr> Then that LLVMIR format can be optimized then translated to your favorite CPU instruction set.
21:21:31 <johnw> you can sequence [m (Maybe t)] to m [Maybe t] or even m (Maybe [t])
21:21:46 <zilinc> johnw: yes it's monadic-ish
21:21:49 <johnw> but you can't just fold on the list and "ask" which actions will yield Nothing
21:21:59 <dmj`> lethjakman: circle ci for projects where you don't need to support multiple version of ghc, it's free and supports ghc 7.10. O/w travis, since it will build pull reqs against multiple ghcs.
21:22:06 <ttt_fff> (forall a) -> (forall b) ... is NOT equiv to (forall a b: a -> b), yet why can we do :t (\x -> flip) ?
21:22:14 <johnw> foldM would work, but I don't know if it matches what you described
21:22:18 <lethjakman> dmj`: circle seems to cost money for more than one project, no?
21:22:38 <lethjakman> seems like it gets expensive quickly
21:23:35 <dmj`> lethjakman: If you have a large project with frequent pushes from a lot of users yea you should scale up, but for a few people on one project, I've never felt the need.
21:23:41 <zilinc> johnw: it's like Monad on Maybe, but the condition is different. Moand Maybe says if anything is Nothing, then we just Nothing. What I want is, if all are Nothing, then I just Nothing
21:24:04 <zilinc> s/just/just get/
21:24:15 <johnw> zilinc: then sequence to m [Maybe t], and fmap catMaybes
21:24:17 <lethjakman> dmj`: hmmm, well this is gonna be a pet project for two guys for a while. any recommendations for that?
21:24:36 <johnw> then you'll have an action that results in an empty list if they were all Nothing
21:24:52 <dmj`> lethjakman: do you need to support multiple versions of ghc? Or is it proprietary?
21:25:21 <lethjakman> dmj`: proprietary for now, probably only one version of ghc
21:25:29 <lethjakman> but potentially a few projects. 
21:25:40 <lethjakman> bamboo looks cool too...
21:25:42 <dmj`> lethjakman: I'd recommend circle, nice github, slack and AWS integration. 
21:25:54 <lethjakman> sweet
21:25:58 <lethjakman> thank you for the recommendation :)
21:26:25 <ttt_fff> \x -> id
21:26:27 <dmj`> lethjakman: it holds any keys securely really, then you can just scp anywhere and run remote shell commands to automate the rest of the deploy
21:26:28 <ttt_fff> :t \x -> id
21:26:31 <lambdabot> r -> a -> a
21:26:41 <zilinc> johnw: uhmmm, yes I think that will do. I'll have a try. Thanks.
21:26:52 <lethjakman> oh wow
21:27:02 <lethjakman> dmj`: codeship has a great pricing plan for individual developers
21:27:05 <ttt_fff> look, (forall a) -> (forall b) is NOT the same as (forall a b: a -> b), ... yet why can we have :t \x -> id have type "r -> a -> a" instead of "r -> forall a (a -> a)" ?
21:27:29 <johnw> r -> forall a. (a -> a) is the same thing as forall a. r -> a -> a
21:28:40 <dmj`> lethjakman: never tried them, but you should, and let me know what you think :)
21:29:59 <dmj`> lethjakman: the circle.yml file can run any shell script at any time, but it lets you specify what ghc compiler version you want *and* gives you access to redis, postgresql, etc. etc. on demand
21:30:13 <lethjakman> dmj`: I think I might. in general how long do large haskell projects take to test? 
21:30:16 <dmj`> supports many different db's w/o you having to install them manually
21:30:34 <lethjakman> dmj`: ooo flexible!
21:30:59 <dmj`> lethjakman: I run 130 test in 1-2 seconds.
21:31:10 <dmj`> lethjakman: it depends on what you're testing really
21:31:33 <lethjakman> dmj`: mostly yesod at the moment...I'm not to their testing section of their book yet. 
21:31:46 <dmj`> those are mostly integration tests (impure), unit tests (pure) could take longer for randomly generated data.
21:31:56 <lethjakman> I come from the rails world where people like to go overkill with feature specs and give me 30 minute testing suites. 
21:32:12 <lethjakman> dmj`: does it have goot integration testing support?
21:32:36 <solatis> yeah rails is really weird when it comes to unit tests
21:32:44 <dmj`> lethjakman: yea, I use hspec
21:32:49 <johnw> I like hspec too
21:32:49 <solatis> they're erring on the side of "unpragmatic"
21:33:14 <lethjakman> solatis: yeah...great and terrible. I'm hoping haskell will let me get away from a lot of the redundant untit specs. 
21:33:24 <lethjakman> unit
21:33:51 <lethjakman> oooo parallel test execution. 
21:34:14 <solatis> lethjakman: otoh you might have to be like that in a dynamic language, since the compiler doesnt catch type errors
21:34:27 <lethjakman> you definitely do
21:34:48 <solatis> i've heard great things about tasty by the way, http://hackage.haskell.org/package/tasty
21:35:11 <lethjakman> solatis: ooo looks cool
21:35:35 <solatis> haven't gotten around converting my packages to tasty yet
21:35:51 <lethjakman> so, when I think integration tests I'm thinking selenium. is that supported? 
21:35:53 <solatis> but it seems to combine the best of the integration and unit tests into one big world
21:35:56 <lethjakman> or something similar. 
21:36:12 <lethjakman> huh, I'll definitely give that a shot
21:36:26 <solatis> selenium is browser testing right ?
21:36:52 <solatis> you said you're using yesod, i assume you have seen yesod-test ?
21:36:56 <dmj`> lethjakman: If you layout your types right for dealing with json using GHC.Generics (auto deriving instances), you won't have to manually perform isomorphism tests \x -> decode (encode x) == x, so that removes some boilerplate
21:37:01 <solatis> it's integration testing for yesod
21:37:16 <fishburne> do anyone here have used "Database.PostgreSQL.Simple.Arrays" to run queries that use postgres array_agg function to return grouped result as an array? I don't know how to specify the type of the result set.
21:37:41 <lethjakman> solatis: ahhh, no I'm not that far in the book yet
21:38:00 <solatis> lethjakman: well what i mean is, when you initialize a yesod project, have you taken a look at the test/ directory ?
21:38:02 <lethjakman> dmj`: well I'll need to make sure my javascript is working correctly though, no?
21:38:15 <lethjakman> solatis: no, not yet. 
21:38:22 <solatis> do that
21:38:26 <solatis> i think it's what you're looking for
21:39:24 <solatis> https://github.com/yesodweb/yesod/blob/master/yesod-test/test/main.hs#L29
21:39:26 <solatis> for an example
21:39:51 <dmj`> lethjakman: moreso for internal consistency when testing your web server.
21:40:45 <solatis> anyway, headless browser integration is not (yet) implemented in haskell i think
21:41:03 <solatis> https://hackage.haskell.org/package/webdriver
21:41:06 <solatis> i was wrong
21:41:17 <lethjakman> solatis: I think that looks about right. 
21:49:15 <lpsmith> fishburne, you can use Vector or PGArray in the Types module IIRC;  you don't actually have to import Database.PostgreSQL.Simple.Arrays.
21:50:01 <lpsmith> so let's say postgres is returning something of type _int8,  then you could use Vector Int64 in postgresql-simple.
21:50:06 <fishburne> lpsmith: wow. the author himself?
21:50:24 <lpsmith> well,  lots of other people have made significant contributions too :)
21:50:25 <solatis> fishburne: get used to it, haskell package authors have no life
21:50:39 <solatis> just kidding
21:50:57 <lpsmith> well,  that's pretty accurate in my case at the moment :-/
21:50:59 <solatis> it's awesome that you usually get answers straight from the horse's mouth here
21:55:09 <fishburne> lpsmith: I tried this. query_ c "select array_agg(image_oid) from product_to_image group by product_id"  :: IO [Vector Oid ]  , But still giving that error.
21:56:26 <lpsmith> fishburne, what error?
21:56:49 <lpsmith> Oh,  you need a IO [Only (Vector Oid)],  that should work fine.
21:56:57 <fishburne> lpsmith: tried this also,   query_ c "select array_agg(image_oid) from product_to_image group by product_id"  :: IO [PGArray (Only Oid)]
21:57:19 <lpsmith> IO [Only (PGArray Oid)]  would also work
21:57:31 <fishburne> lpsmith: Oh ok. let me try. 
21:58:55 <lpsmith> but note it's essentially   instance FromField a => FromField (PGArray a),   not instance FromRow a => FromRow (PGArray a)
21:59:14 <lpsmith> Only turns something that's a field into a row.
22:01:21 <fishburne> lpsmith: you mean turn something that is a field into another type of field...right?
22:01:49 <lpsmith> "Only" turns a field into a row.   "PGArray" turns a field into another kind of field, correct.
22:02:48 <lpsmith> Only is a one-tuple,  basically,  but since Haskell doesn't have 1-tuples in the base language...
22:03:03 <fishburne> lpsmith: I tried: query_ c "select array_agg(image_oid) from product_to_image group by product_id"  :: IO [Only (PGArray Oid)] , but I got error:  No instance for (Data.Typeable.Internal.Typeable Oid)  arising from a use of `query_'
22:03:10 <lpsmith> Haskell has 0 tuples,  and n >= 2 - tuples.
22:03:33 <lpsmith> fishburne, interesting.
22:03:43 <lpsmith> That may be an oversight in libpq, let me check.
22:05:11 <lpsmith> yeah, Oid is a type that's defined in postgresql-libpq and reexported from postgresql-simple
22:05:32 <lpsmith> postgresql-libpq doesn't define any typeable instances
22:05:55 <fishburne> lpsmith: I am actually importing Oid from LargeObjects module....
22:06:14 <lpsmith> Right,  it's actually defined in an entirely different package.
22:06:33 <lpsmith> LargeObjects uses the same newtype-d integer defined in postgresql-libpq
22:07:02 <fishburne> So I should hide it while importing large objects and instead import it from postgresql-libpq?
22:07:10 <lpsmith> no, it won't make a difference
22:07:29 <lpsmith> You could add an instance Typeable Oid as a temporary workaround...
22:07:52 <fishburne> lpsmith: ok. I will try that.
22:08:10 <fishburne> lpsmith: Or should I try using Vector first?
22:08:21 <lpsmith> Won't make a difference :-/
22:09:11 <fishburne> lpsmith: ok. Cool.
22:14:27 <lpsmith> fishburne,  alternatively you can recompile postgresql-libpq from the commit I just pushed to master:  https://github.com/lpsmith/postgresql-libpq/commit/c3d414c9d1519e160200c8e4f8e90b8491259f91
22:14:34 <lpsmith> I'll try to get a new release out in a few days.
22:14:45 <AaronFriel> Anyone familiar with yesod devel? Is there a way to get it to be *faster*?
22:15:01 <fishburne> lpsmith: Wow. Thankyou!
22:15:03 <AaronFriel> Alternatively, my performance sensitive code is not in the same project. Can I selectively compile certain modules at -O2?
22:15:28 <lpsmith> Anyhows,  I'm going to try to get some sleep.  Later :) 
22:15:31 <AaronFriel> I would like to have a perf-sensitive library (that doesn't change much) be -O2 compiled, while the web frontend uses Yesod Devel's faster -O0
22:20:46 <pacak> AaronFriel:  You can put {-# OPTIONS -O2 #-} at top of some files.
22:21:40 <AaronFriel> whoa that works?
22:21:46 <AaronFriel> AWESOME
22:22:17 <AaronFriel> Yesod devel seems to ignore my compilation flags for GHC - or it doesn't seem to perform any better than GHCi or -O0 builds
22:24:32 <AaronFriel> pacak: For reference, it looks like GHC docs say the pragma is "OPTIONS_GHC"
22:24:39 <AaronFriel> pacak: But awesome, I think this is what I needed
22:25:05 <pacak> AaronFriel: Well, it tries to pretend that there's other haskell compilers around.
22:25:09 <ttt_fff> omg polymorphic type checking sucks
22:25:11 <ttt_fff> to implement
22:27:16 <AaronFriel> pacak: that seems hard to believe. I would be very surprised if Yesod/Wai/Warp and their dependencies could compile with JHC or run in HUGS
22:27:49 <AaronFriel> pacak: Especially considering Yesod compiles with -XEvenTheKitchenSink
22:28:27 <pacak> AaronFriel: Right. So OPTIONS also works.
22:29:07 <AaronFriel> pacak: Oh, are you saying the pragma can be OPTIONS or OPTIONS_GHC?
22:29:33 <pacak> AaronFriel: ghc will parse OPTIONS as OPTIONS_GHC
22:29:42 <AaronFriel> pacak: Gotcha
22:34:33 * hackagebot pipes-async 0.1.1 - A higher-level interface to using concurrency with pipes  https://hackage.haskell.org/package/pipes-async-0.1.1 (JohnWiegley)
22:34:43 <AaronFriel> pacak: Next question, then, and this may depend on your familiarity with Stack. Can I have Stack compile libs at -O2?
22:34:58 <Clint> are you sure you want to
22:35:37 <pacak> AaronFriel: I've never used stack, but if that's impossible - I would consider it broken.
22:36:02 <AaronFriel> Clint: Yes
22:36:23 <AaronFriel> Clint: I want Yesod Devel to be fast.
22:36:45 <Clint> -O2 isn't always faster than -O
22:37:02 <AaronFriel> Clint: It looks like Yesod Devel is essentially doing -O0
22:37:25 <AaronFriel> Clint: In terms of perf, I get equally bad perf using GHCi or Yesod Devel
22:38:09 <Clint> AaronFriel: i'm not surprised
22:38:09 <AaronFriel> Clint: I would expect all the really important stuff is in the dependencies, most likely Conduit and Warp/Wai. 
23:39:35 * hackagebot bet 0.1.2.3 - Betfair API bindings. Bet on sports on betting exchanges.  https://hackage.haskell.org/package/bet-0.1.2.3 (Adeon)
23:41:29 <mjrosenb> I want to make a 'smart constructor', which automatically fills in certain fields, but still allows them to use the named-field syntax
23:41:35 <mjrosenb> Is this reasonable?
23:43:28 <Cale> mjrosenb: You can often do this just by defining a value of the type
23:43:40 <ChristianS> mjrosenb: yes, define a default value, then call defVal { customFieldA = X, customFieldB = Y }
23:43:45 <Cale> mjrosenb: The record update syntax can be used to fill in the remaining fields
23:54:18 <mjrosenb> Cale: but the default value depends on other fields
23:54:37 <mjrosenb> e.g. isMouseOver depends on the width, height, x, and y fields.
23:56:29 <ChristianS> mjrosenb: then define a function that takes the required values (plus optional values as Maybe) and constructs an instance
23:57:28 <mjrosenb> right, but then the required values can't be passed in with the field initialization syntax.
23:58:25 <Cale> mjrosenb: I guess you could define a normalisation function which takes a possibly invalid value and fixes it, but only if you're allowed to construct invalid values temporarily.
