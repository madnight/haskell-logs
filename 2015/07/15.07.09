00:00:01 <mniip> jle`, there's no sensible implementation of ListT that obeys associativity
00:00:42 <jle`> maybe you need to look in your heart
00:00:48 <jle`> and find the answer within
00:01:21 <gfixler> :k Heart
00:01:22 <lambdabot> Not in scope: type constructor or class ‘Heart’
00:01:25 <gfixler> :(
00:01:44 <jle`> :k Heart
00:01:45 <lambdabot> *
00:01:57 <gfixler> yay, I knew lambdabot had a kind Heart
00:04:13 <jle`> ^_^
00:04:50 <jle`> johnw: i was particularly interested in whether or not asum was okay and not join on line 54
00:05:23 <jle`> because i had a lot of pure's going on and maybe the degenerate cases where asum /= join for law-abiding traversables wouldn't show up
00:07:38 * hackagebot pipes-parse 3.0.3 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-3.0.3 (GabrielGonzalez)
00:07:38 * hackagebot linear 1.19 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19 (EdwardKmett)
00:07:40 <johnw> jle`: functor laws proven
00:07:53 <jle`> yay
00:08:05 <jle`> it's the functor that comes from DeriveFunctor, so i would hope so :)
00:08:55 <gfixler> jle`: so, Alternative instance - do I need a Functor first?
00:09:03 <johnw> I can't see how any of these laws would fail to pass
00:09:06 <johnw> this is really trivial
00:09:33 <jle`> gfixler: hm, what do you mean?
00:09:39 <jle`> Functor on what?
00:10:00 <gfixler> whatever I'm making an Alternative instance of
00:10:05 <jle`> oh
00:10:15 <jle`> yeah, Alternative requires Applicative, which requires Functor
00:10:28 <jle`> but i had assumed you made a Functor instance already because Monad requires Applicative which requires Functor
00:10:35 <gfixler> jle`: I cheated
00:10:39 <jle`> :o
00:10:47 <gfixler> I jumped straight to Monad, laughing
00:10:55 <jle`> was the compiler laughing too?
00:11:08 <gfixler> well, I don't have that constraint on Monads yet
00:11:10 <gfixler> is that even out yet?
00:11:19 <jle`> yeah, it's been out for a few months now
00:11:32 <jle`> i guess i have to keep on remembering that it's new-ish
00:11:40 <gfixler> my compiler was all "This is fine."
00:11:50 <jle`> not even a warning? :o
00:12:44 <gfixler> Nope, it said "Good job, this is beyond flawless."
00:13:26 <jle`> johnw: what laws are you talking about?
00:13:38 <gfixler> I don't know how to update - I just apt-got the haskell-platform, and it's still 'up to date'
00:13:44 <jle`> ah i see
00:13:49 <johnw> jle`: functor/applicative/monoad
00:13:51 <jle`> yeah, aptitude repos are pretty out of date
00:13:52 <gfixler> I don't like not knowing how Haskell is really installed
00:14:07 <jle`> i think they're still on 7.6, which is like...four years ago?
00:14:19 <gfixler> !
00:14:21 <gfixler> 7.6.3
00:14:44 <jle`> if you're on ubuntu you can use hvr's nice ppas -- https://launchpad.net/~hvr/+archive/ubuntu/ghc
00:15:21 <gfixler> can I just do this without breaking the platform?
00:16:11 <jle`> hm. platform
00:16:21 <jle`> i think so?
00:16:27 <jle`> can't give you a sure answer though :|
00:16:35 <jle`> i think every ghc version keeps its own packages to itself
00:16:38 <jle`> so i'd assume so
00:16:47 <gfixler> I can probably recover, regardless
00:35:56 <andrevm> whats the difference between an Arrow and a Profunctor?
00:37:37 <shachaf> Almost everything about Arrow.
00:37:58 <pacak> andrevm: Arrows are composable and can represent various stuff, profunctor is  a functor/contravariant functor in one datatype
00:38:03 <lpaste> mniip pasted “D and T” at http://lpaste.net/136231
00:38:13 <mniip> jle`, here's my work on TraversableT
00:38:22 <pacak> > "Arrow" // "Profunctor"
00:38:23 <lambdabot>      Couldn't match expected type ‘Array i e’ with actual type ‘[Char]’
00:38:23 <lambdabot>      In the first argument of ‘(//)’, namely ‘"Arrow"’
00:38:23 <lambdabot>      In the expression: "Arrow" // "Profunctor"    Couldn't match type ‘Char’...
00:38:41 <pacak> > "Arrow" \\ "Profunctor"
00:38:42 <lambdabot>  "Aw"
00:38:57 <jle`> ty mniip :)
00:40:42 <frogpoooooow> if you keep your haskell heap pretty small(no more than a few megs), will pause times stay under a few milliseconds?
00:40:42 <jle`> johnw: wait, but isn't the type not a Monad for some t?
00:46:41 <johnw> jle`: haven't gotten there yet
00:46:49 <johnw> it's a monad for every t that distributes with m
00:47:19 <mniip> jle`, I guess the reason for so many people doing the same thing is that haskellers naturally prefer generalization, and Traversable is an easily followable path
00:48:11 <johnw> jle`: the main reason being that if t distributes with m, then m (t (m (t x))) -> m (t (t (m x))), which is trivial
00:48:34 <johnw> if not, then without knowing which t, you can't join the two m's on either side
00:48:52 <jle`> what do you mean by 'distributes'?
00:48:59 <johnw> m (t x) -> t (m x)
00:49:08 <johnw> the opposite of sequence
00:49:11 <jle`> following some laws?
00:49:16 <johnw> yes
00:49:19 <johnw> see http://hackage.haskell.org/package/distributive
00:49:21 <jle`> what laws?
00:49:24 <jle`> ah i see
00:49:32 <johnw> s/opposite/dual
00:49:34 * mniip points out the D in his paste
00:49:42 <johnw> mniip: :)
00:50:23 <johnw> jle`: the basic question you're getting to is: what is the weakest condition that allows two functors composed to be a monad?  And much has been written on this subject.
00:50:37 <johnw> the end result being: distributivity
00:51:10 <johnw> that's why my TraversableT tried to do t (m x) instead of m (t x), so that I could use sequence to achieve what I needed, but it didn't work
00:51:29 <jle`> i think what i'm getting at is if Traversable's laws are strong enough that the monad can be proven for such a definition
00:51:39 <jle`> or well, that's my actual question
00:51:48 <jle`> and i think the answer is no
00:51:56 <johnw> it's the wrong direction on the arrow
00:52:07 <johnw> you need distribute, not sequenceA
00:52:34 <jle`> distribute is necessary?
00:52:37 <johnw> yes
00:53:00 <johnw> see Composing Monads by Jones and Duponcheel (1993)
00:53:02 <jle`> welp
00:54:06 <johnw> in fact, for any m . n, if m distributes over n, then n only needs to be applicative for the composition to be a monad
00:54:46 <johnw> (that proof I have in Coq, even)
00:55:07 <johnw> based on the Composing Monads work
00:57:39 <mniip> I wonder if haskell can offer a scalable graph drawing library
00:58:01 <merijn> Define scalable
00:58:07 <mniip> scalable as in I have a digraph with 30k nodes and 90k edges
00:58:34 <merijn> I'd say, unlikely, the state-of-the-art in graph visualisation is pathetic
00:58:38 <johnw> does just emitting a DOT file count?  or do you want it to render it to SVG or something?
00:58:50 <mniip> johnw, I want a layout
00:58:58 <merijn> The most popular visualisation tool (I forget the name) is written in Java and craps out at like 10k nodes
00:59:00 <mniip> I didn't manage to make graphviz output something comprehensible yet
00:59:10 <quchen2> merijn: Gephi?
00:59:12 <mniip> http://i.imgur.com/dAG41Bo.png
00:59:16 <merijn> quchen2: Ah, yeah, that's the one
00:59:31 <merijn> tbh, if you want something that works on non-trivial graphs you're probably better of writing it yourself
00:59:38 <quchen2> It has a built-in timer that crashes or issues an NPE every couple of minutes, but apart from being utter crap it builds nice graph visualizations.
00:59:54 <mniip> well
01:00:03 <mniip> "nice" is out of the question right now
01:00:11 <mniip> "readable" is enough I'd say
01:00:29 <merijn> quchen2: It completely breaks for any non-trivial graph
01:00:46 <merijn> quchen2: i.e. around 10k you start getting exceptions, crashes, etc.
01:00:59 <quchen2> But at least it's pretty. https://raw.githubusercontent.com/quchen/amoeba/master/doc/network_example_hires_amoeba_n359_5-10-3cluster.png
01:01:15 <quchen2> And watching the graph layout figure itself out is calming :-D
01:01:22 <mniip> I'm currently feeding the graph through tred (transitivity reduction), will see if it helps anything
01:01:23 <merijn> I think some master students implemented layouting based on Gephi that should scale better
01:01:27 <merijn> lemme see if I can find source
01:02:35 * hackagebot http2 1.0.1 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-1.0.1 (KazuYamamoto)
01:03:19 <merijn> hmmm, this is not as standalone as I was hoping...
01:03:45 <merijn> Not sure if it's easily reusable
01:04:19 <merijn> mniip: Anyway, you might wanna look for "ForceAtlas2" which is a layout algorithm for graphs
01:07:25 <zipper> When trying to build a package I am getting the following error: https://gist.github.com/urbanslug/96e1a0e49cd3562f65e6
01:07:34 <zipper> What do you guys think?
01:07:55 <mniip> merijn, I'm actually thinking of rendering the layout with graphviz's "neato" but in 3- or 4-dimensional space
01:08:05 <mniip> since it has support for that
01:08:13 <mniip> (only in the C library though)
01:08:30 <merijn> zipper: You're trying to build something unix based on windows
01:08:52 <merijn> zipper: "Posix.hsc:60:20: fatal error: HsUnix.h: No such file or directory" <- using unix specific source
01:10:25 <merijn> Depends on unix, a bit odd that that's not failing to begin with
01:10:35 <merijn> zipper: Are you sure that's supposed to work on windows?
01:10:59 <zipper> merijn: No I'm not sure.
01:11:44 <merijn> I'd double check that first :)
01:11:54 <zipper> merijn: In case I know where to find the file HsUnix.h
01:12:03 <zipper> Where would you suggest I put it?
01:12:19 <mniip> on an actual unix system?
01:12:24 <merijn> zipper: I'm not convinced that will make it actually work
01:12:38 <merijn> zipper: ide-backend-server depends on unix, which AFAIK doesn't actually work on windows
01:13:00 <suppi> I'm trying to learn about lenses and wreq from here: http://www.serpentine.com/wreq/tutorial.html
01:13:03 <zipper> :(
01:13:09 <suppi> but I'm not sure why this works: ghci> r ^. responseStatus . statusCode
01:13:32 <zipper> I have to try.
01:13:45 <suppi> i mean, what is evaluated first? shouldn't responseStatus . statusCode be statusCode . responseStatus ?
01:14:05 <merijn> suppi: (.) for lenses composes the reverse way of functions
01:14:27 <suppi> merijn, so this is not the regular (.) ?
01:14:44 <mniip> it is the regular .
01:14:47 <jle`> it's the regular (.), but not really regular functions :)
01:14:50 <merijn> suppi: It is the regular (.), but the way lenses are defined means the result is different
01:15:08 <merijn> suppi: If you're interested edwardk has a pretty good in-depth talk explaining lenses on youtube
01:15:09 <suppi> hmm :\
01:15:16 <merijn> (And by in-depth I mean 2 hours long...)
01:15:18 <mniip> it's just that lenses are functions of functions, which thanks to some black type wizardy makes the composition reverse
01:15:26 <merijn> @where lens
01:15:26 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
01:15:28 <jle`> it's similar to how traverse, fmap, etc. compose
01:15:31 <merijn> See that last link
01:15:40 <suppi> thank you all
01:15:45 <jle`> > (fmap . map) (*2) (Just [1,2,3])
01:15:46 <lambdabot>  Just [2,4,6]
01:15:59 <suppi> I've tried watching this lecture but it's straight away too complicated for me
01:15:59 <jle`> the map works on the innermost sturcture and the fmap works on the outermost structure
01:16:11 <jle`> > (fmap . map . fmap) (*2) (Just [Just 2, Nothing, Just 4])
01:16:13 <lambdabot>  Just [Just 4,Nothing,Just 8]
01:16:25 <jle`> the "last" one is the "most innermost structure"
01:16:37 <jle`> although that second example was poorly chosen, heh
01:16:41 <suppi> jle`, I see
01:16:42 <merijn> tbh, so far I've mostly avoided lenses
01:17:10 <merijn> If you get to lost my them there's no real reason to force yourself to use them before you're more comfortable with the rest of the language
01:17:13 <suppi> merijn, me too. but I would like to try writing a web client and wreq seems pretty robust
01:17:35 * hackagebot relational-record-examples 0.2.0.2 - Examples of Haskell Relationa Record  http://hackage.haskell.org/package/relational-record-examples-0.2.0.2 (yuga)
01:17:48 <merijn> Depending on what you need to do I've found http-conduit works fairly simply and plugs nicely into html-conduit for scraping HTML :)
01:17:50 <suppi> merijn, I think I am comfortable enough
01:17:56 <jle`> to me lens gives a generalized `traverse`, which has become pretty useful on many occasions for working with various data types i've made
01:18:01 <suppi> merijn, alright, cool
01:18:31 <merijn> suppi: I'm not sure about all the REST/JSON stuff people wanna do these days
01:18:47 <merijn> But for just webscraping it's nice :)
01:19:04 <suppi> merijn, I would like to write a simple cli web server
01:20:01 <merijn> Ah, but wreq/http-conduit are more aimed at being clients (there's a server http conduit too, but I haven't used it). Maybe look at WAI?
01:20:10 <suppi> oops
01:20:15 <suppi> I meant browser
01:20:16 <suppi> :)
01:20:28 <merijn> ok, then it should work fine
01:21:01 <suppi> appreciate all the help, merijn jle` and mniip!
01:21:16 <zipper> Unix-compat provides a HSunix-compat but when I change that to require HSunix-compat it just won't do it.
01:21:23 <merijn> suppi: Here's a simple concurrent web scraper I wrote a while ago: https://gist.github.com/merijn/d8188ddd129718ffcfb0
01:21:41 <suppi> merijn, thanks!
01:21:50 <merijn> suppi: Although it doesn't work as is, since I removed the domain to avoid people overloading it while testing this :p
01:22:10 <suppi> haha, ok :)
01:22:13 <merijn> It basically crawled a series of index pages for comic links, then visited the comics to grap the JPGs so I could read locally
01:23:05 <merijn> (The QSem is effectively a rate limiter to avoid sending 1000s or hundreds of thousands of concurrent request to a small server :p)
01:24:27 <suppi> oh, pretty useful
01:28:59 <merijn> Mind you, this basically does zero error-handling, the "responseBody <$> httpLbs" on line 43 should check for HTTP errors and retry (or retry with a maximum number of retries)
01:29:09 <merijn> But that should be fairly easy to add
01:37:36 * hackagebot relational-query 0.5.1.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.1.1 (KeiHibino)
01:39:37 <merijn> ok, I'm STILL confused by the difference between predicative and impredicative types...
01:49:26 <Geraldus> hi friends! 
01:49:46 <mniip> hello friend!
01:50:33 <Geraldus> I'm missing simple function, which checks that given value is in given range, e.g. inRange x a z = x >= a && x <= z
01:50:55 <Geraldus> is there something in Prelude?
01:51:20 <Geraldus> mniip: how do you do?
01:52:37 <verement> > map inRange (1, 3) [0..4]
01:52:38 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
01:52:38 <lambdabot>                  with actual type ‘[a0 -> Bool]’
01:52:38 <lambdabot>      The function ‘map’ is applied to three arguments,
01:52:58 <verement> > map (inRange (1, 3)) [0..4]
01:52:59 <lambdabot>  [False,True,True,True,False]
01:53:22 <Geraldus> this is from Data.Ix?
01:53:29 <Geraldus> is this*
01:53:31 <verement> right
01:53:53 <Geraldus> oh, and Data.Ix is in base, good
01:57:10 <ttt_fff> is there a way to 'overload' a typeclass? i.e. I want "class Lookup k s v where lookup :: k -> s -> Maybe v" ... or "class Lookup k m v where lookup :: k -> m v" ... and I want to use just the word "lookup" instead of having two separate functions
02:03:11 <bennofs> is there a applicative-monoid wrapper with mappend = liftA2 (<>) somewhere already?
02:03:48 <Haskellfant> meh, regex-applicative seems kinda cool but it seems to be very painful to use it with Text instead of String
02:04:07 <breadmonster> Haskellfant: Use Parsec?
02:04:20 <merijn> Blah, why doesn't haskell have union types? :(
02:04:26 <merijn> bennofs: You mean Alternative?
02:04:33 <dramforever> merijn: ?
02:04:42 <dramforever> what do you mean by that
02:04:43 <merijn> Oh, not quite
02:04:56 <Haskellfant> breadmonster: I just want to use it to grep some small piece out of a longer text. parsec doesn't make that easier
02:05:05 <bennofs> merijn: no, i mean data ApplicativeMonoid f a = ApplicativeMonoid (f a); instance (Applicative f, Monoid a) => Monoid (ApplicativeMonoid f a) 
02:05:14 <merijn> bennofs: I don't think so?
02:05:17 <breadmonster> merijn: Umm `data Either a b = Left a | Right b`?
02:05:22 <dramforever> newtype maybe?
02:05:34 <bennofs> yeah newtype ofc. data was shorter :D
02:05:34 <merijn> breadmonster: That's not a union type, that's an ADT with a union
02:06:22 <breadmonster> merijn: Can you give me an example?
02:06:23 <liste> does unpacking Text and running it thru regex-applicative cost performance?
02:06:33 <merijn> liste: Almost certainly
02:06:40 <zipper> Anyone familiar with the error "Perhaps you haven't installed the "dyn" libraries for package ..."
02:06:41 <duscae> i'm trying to permanently change the prompt in ghci but i can't access the config file (can't find it)
02:06:43 <duscae> any help?
02:06:47 <duscae> on ubuntu
02:06:48 <merijn> Now that I think about it, I don't think I want union types anyway
02:06:53 <merijn> duscae: ~/.ghci
02:06:53 <breadmonster> duscae: ~/.ghci
02:07:09 <breadmonster> merijn: What exactly are union types?
02:07:22 <liste> if regex-applicative works character-by-character
02:07:44 <merijn> liste: Why not use, for example, attoparsec directly on your Text?
02:07:48 <siarheit> zipper, for which package does it want dyn?
02:07:54 <bennofs> zipper: sounds like shared: False in cabal.config + GHC 7.8 or later + TemplateHaskell
02:08:13 <duscae> merijn: bread: "No such file or directory."
02:08:20 <merijn> duscae: Sure, it doesn't exist by default
02:08:22 <zipper> base
02:08:25 <zipper> siarheit: ^
02:08:26 <merijn> duscae: You have to create it
02:08:35 <bennofs> (reason: GHc 7.8 or later requires dynamic libraries for dynamic code loading, so for GHCi/template haskell)
02:08:45 <bennofs> zipper: is this while compiling a package that uses TH or when using GHCi?
02:08:48 <dramforever> Haskellfant: I agree because of the instance (char ~ Char, string ~ String) => IsString (RE char string)
02:08:56 <dramforever> other than that what's the problem?
02:08:58 <duscae> merijn: how so?
02:09:06 <merijn> duscae: How so what?
02:09:23 <dramforever> I don't think it's painfun
02:09:27 <dramforever> *painful
02:09:34 <zipper> bennofs: When compiling
02:09:44 <bennofs> zipper: ok, do you use TH?
02:09:53 <Haskellfant> dramforever: "match :: RE s a -> [s] -> Maybe a" seems to require to have a list of single elements
02:09:55 <merijn> Ok, so I currently have a datatype similar to https://github.com/ekmett/bound/blob/master/examples/Deriving.hs#L39-L45
02:10:09 <zipper> bennofs: It's not 100% my code
02:10:21 <merijn> And I want to basically have a datatype that only has VarP and WildP, but I can't figure out how to do that without needless duplication :\
02:10:23 <zipper> It could be that it is being used.
02:10:25 <siarheit> does it set -dynamic explicitly somewhere in .cabal?
02:10:26 <bennofs> zipper: hmm ok, check if you have installed the dynamic libraries for base :)
02:10:36 <bennofs> zipper: what system are you on?
02:10:42 <zipper> bennofs: Windows
02:10:56 <Haskellfant> dramforever: note: I might just be too stupid to understand how it's supposed to be used
02:10:58 <zipper> I'm so confused I don't know how to check for stuff.
02:11:05 <zipper> I don't know where stuff is installed.
02:11:07 <zipper> FML
02:11:07 <bennofs> uh, I don't know anything about windows, sorry :/
02:11:16 <dramforever> Haskellfant: it seems that I'm also too stupid...
02:11:17 <liste> merijn I usually do that, just wondering how regex-applicative works under the hood
02:11:27 <zipper> bennofs: But you said the issue could be in the cabal file?
02:11:40 <dramforever> oh okay I understand it now
02:11:41 <zipper> I can just change whatever is causing the issue.
02:11:45 <dramforever> Haskellfant: oh yes sorry...
02:11:46 <bennofs> zipper: well, check if it sets -dynamic anywhere
02:11:48 <dramforever> =P
02:12:04 <zipper> bennofs: ghc-options: dynmic
02:12:07 <duscae> merijn: i've got it (i think).
02:12:11 <zipper> *dynamic
02:12:14 <bennofs> zipper: what GHC version, btw? Is this a package available somewhere?
02:12:42 <zipper> bennofs: 7.10 It is on github
02:12:43 <Haskellfant> attoparsec doesn't allow me to search through the text for something that matches my parse right? So I would need to write a parser that matches everything except the thing I'm interested in, and then the stuff I am interested in
02:12:46 <siarheit> i suggest just removing that -dynamic flag :)
02:12:48 <bennofs> zipper: do you have a link?
02:13:09 <zipper> bennofs: https://github.com/fpco/ide-backend/tree/master/ide-backend-server
02:13:19 <zipper> Well that's not the current state
02:13:20 <dramforever> Haskellfant: unfortunately that's surprisingly hard, isn't it?
02:13:45 <dramforever> =P
02:13:46 <bennofs> zipper: ah, yeah, then just removing -dynamic on windows might work [not sure if ghc 7.10 uses the dynamic linker on windows?]
02:13:46 <Haskellfant> dramforever: yeah that's the reason why I am trying to just use some regex library for it in the first place :)
02:14:06 <merijn> It's really not
02:14:09 <zipper> bennofs: Justy remove or modify it to say static?
02:14:15 <bennofs> zipper: just remove it
02:14:50 <dramforever> Haskellfant: yeah we need a better regex lib
02:14:50 <merijn> Well, it depends on how efficient you wanna be, I guess...
02:16:24 <duscae> merijn: it's ignoring my config file -- "is writable by someone else, IGNORING!"
02:16:34 <duscae> y?
02:16:55 <tdammers> Haskellfant: something with manyTill, maybe?
02:17:26 <merijn> duscae: So change the permissions so that it's not writable by everyone?
02:17:28 <Haskellfant> tdammers: ah that seems like what I am looking for, thanks
02:17:53 <duscae> merijn: how do i do that?
02:18:01 <tdammers> only issue there is that manyTill returns the 'many', not the 'till'
02:18:16 <zipper> bennofs: Thanks it fixed it I think.
02:18:21 <zipper> Too early to know
02:18:45 <zipper> Windows is a night that is dark and full of terrors
02:19:21 <bennofs> zipper: well, the reason the flag is there is that GHC 7.8 and later requires it for the GHC API to work with dynamic linking on linux / macosx afaik. Not sure about the state on windows though :D
02:21:09 <merijn> duscae: On linux you'd use chmod
02:24:18 <siarheit> bennofs, that flag shoud never appear in .cabal file (same as -fPIC, -static and  -prof). It's either some obscure bug workaround or attempt to save some space on disk
02:24:28 <bennofs> siarheit: no, it is not
02:24:43 <bennofs> siarheit: only linux, the GHC API only works if it is dynamically linked with the program using it
02:24:59 <siarheit> cabal already builds
02:25:00 <bennofs> siarheit: so as ide-backend-server is using the GHC API, this is really required
02:25:01 <siarheit> sorry
02:25:24 <bennofs> (at least on linux)
02:25:49 <bennofs> siarheit: does cabal have special code in it to detect when there is a dependency on the 'ghc' library?
02:26:17 <siarheit> i don't understand where dynamic linkage requirement comes from
02:26:46 <bennofs> siarheit: the GHC API uses the system dynamic loader to load code at runtime (required for TH and GHCi-style interactive linking)
02:26:59 <bennofs> siarheit: somewhere there was a bug that made it crash if the GHC API was statically linked itself
02:27:34 <bennofs> siarheit: see for example https://ghc.haskell.org/trac/ghc/ticket/8376
02:27:43 <lunaris> Suppose you need a type that is going to hold only (e.g.) Floats: data Box = Box { left :: Float, right :: Float, middle :: Float }
02:28:15 <lunaris> Do you instead make it: data Box' a = Box { left :: a, right :: a, middle :: a }; type Box = Box' Float in order to provide e.g. Functor, Foldable, Traversable instances?
02:28:22 <bennofs> siarheit: specially, https://ghc.haskell.org/trac/ghc/ticket/8376#comment:6
02:28:33 <lunaris> Or is that considered "abusing" Functor et al. to get cheap mutation functions?
02:28:46 <dramforever> lunaris: no, but sounds like something lens could help
02:29:14 <lunaris> dramforever: I'm not so much concerned with what's inside, but the structure as a whole.
02:29:29 <lunaris> E.g. scaleBox x = fmap (* x)
02:29:42 <lunaris> (Ignoring the fact that this is wrong due to e.g. middle; it's just a [broken] example)
02:29:47 <dramforever> mapBox :: Setter' Box Float
02:30:01 <breadmonster> Do van Emde Boas heaps have a fast functional implementation?
02:30:03 <bennofs> lunaris: you could write a traversal: boxFloats :: Applicative f => (Float -> f Float) -> Box -> f Box
02:30:05 <dramforever> well maybe Traversal
02:30:07 <dramforever> yes
02:30:26 <bennofs> lunaris: lens will then provide functions to use that like fmap: scaleBox x = over boxFloats (* x)
02:30:29 <lunaris> dramforever: So you'd not expose the Functorial structure etc. and use lens (for instance) to get it "back"?
02:30:32 <breadmonster> dramforever: Was that for me?
02:31:08 <dramforever> lunaris: I've never met this problem before, but that's my first idea on it
02:31:15 <dramforever> maybe there's a better one
02:31:33 <lunaris> dramforever: I'm not looking for a "one size fits all" solution of course.
02:31:52 <bennofs> lunaris: well, you could say that 'boxFloats' is just a function "exposing the functorial structure". But yes, I think it's better not to make a Functor instance in this case
02:32:01 <merijn> System Fω without recursion is strongly terminating, right?
02:32:01 <lunaris> I'm just reminded of e.g. edwardk's talk on "just write dumb data types" and exploit the fact that there is so much rich structure that can be added after the fact.
02:32:30 <dramforever> yeah
02:32:35 <breadmonster> merijn: Yes.
02:32:41 <bennofs> lunaris: hmm right. linear does data V3 a = V3 !a !a !a
02:33:07 <lunaris> bennofs: Indeed; there are other examples too.
02:33:16 <lunaris> I don't think it's a wrong/right thing.
02:33:29 <dramforever> @let Box = Box { left :: !Float, middle :: !Float, right :: !Float } -- I don't need lenses for these three fields
02:33:29 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
02:33:31 <lunaris> More interested in anecdotal evidence around "prefer fmap" / "prefer lens" etc.
02:33:34 <breadmonster> Has any of you implemented van Emde Boas heaps?
02:33:43 <lunaris> Even though of course lens itself exploits fmap and other structure just fine.
02:33:49 <bennofs> merijn: found something: http://hackage.haskell.org/package/reducers-3.10.3.2/docs/Data-Semigroup-Applicative.html
02:33:51 <dramforever> @let data Box = Box { left :: !Float, middle :: !Float, right :: !Float }
02:33:52 <lambdabot>  Defined.
02:34:17 <breadmonster> dramforever: What's the point of making it strict?
02:34:28 <dramforever> @let boxer f (Box l m r) = Box <$> f l <*> f m <*> f r
02:34:29 <lambdabot>  Defined.
02:34:32 <bennofs> breadmonster: probably to unbox it (if you compile with -funbox-strict-fields)
02:34:39 <lunaris> breadmonster: Most people would argue that primitive fields are usually worth making strict.
02:34:51 <breadmonster> bennofs: Okay wow I had no idea that was a flag.
02:35:04 <dramforever> breadmonster: I don't know...I often see number types marked strict
02:35:07 <breadmonster> lunaris: Interesting. We should collect all this wisdom into a book on Haskell design patterns.
02:35:07 <lunaris> breadmonster: Yep; GHC's a clever clogs :)
02:35:19 <dramforever> @undefine
02:35:19 <lambdabot> Undefined.
02:35:26 <dramforever> forget about it you already get the ide
02:35:29 <dramforever> *idea
02:35:33 <lunaris> breadmonster: https://wiki.haskell.org/Performance (bit outdated but still relevant)
02:35:40 <lunaris> dramforever: Not at all; much appreciated.
02:36:07 <dramforever> lunaris: um...that "forget about it" is an explaination to @undefine
02:36:23 <lunaris> Aye; I was about to :t boxer but I've got it now.
02:36:30 * lunaris is too lazy sometimes.
02:36:50 <siarheit> bennofs, yes, that T8376 is clearly a ghc bug :) (both adding and removing -dynamic will break package depending on how you have built ghc even on a single platform)
02:37:11 <bennofs> siarheit: yes, but comment 6 says that in future, it might not work without -dynamic
02:37:22 <lunaris> Hmm; guess I'll have to think on this more.
02:37:39 * hackagebot relational-record 0.1.2.0 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.1.2.0 (KeiHibino)
02:39:15 <siarheit> bennofs, i'd expect it that future TH would stop working as well on static setup
02:39:42 <bennofs> siarheit: yes, cabal already takes care to build dynamic versions of libraries when other-extensions contains TemplateHaskell
02:42:39 * hackagebot servant 0.4.3 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.4.3 (ChristianMarie)
02:42:41 * hackagebot servant-client 0.4.3 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.4.3 (ChristianMarie)
02:42:43 * hackagebot servant-docs 0.4.3 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.4.3 (ChristianMarie)
02:42:45 * hackagebot servant-jquery 0.4.3 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.4.3 (ChristianMarie)
02:42:47 * hackagebot servant-server 0.4.3 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.4.3 (ChristianMarie)
02:47:49 * hackagebot servant-examples 0.4.3 - Example programs for servant  http://hackage.haskell.org/package/servant-examples-0.4.3 (ChristianMarie)
02:47:51 * hackagebot servant-blaze 0.4.3 - Blaze-html support for servant  http://hackage.haskell.org/package/servant-blaze-0.4.3 (ChristianMarie)
02:47:53 * hackagebot servant-lucid 0.4.3 - Servant support for lucid  http://hackage.haskell.org/package/servant-lucid-0.4.3 (ChristianMarie)
03:01:37 <ttt_fff> for web apps, is ther ea good balance / guide for haskell=erlang on the backend, or sholud one always go with just one and ignore the other ?
03:02:53 <bergmark> i don't think anyone can answer that, it depends
03:03:08 <tdammers> ttt_fff: I'm not very familiar with erlang, but I don't believe there is a clear-cut answer to that
03:03:27 <bergmark> we just do haskell because we don't know erlang ;-)
03:04:09 <tdammers> if you want strong compile-time guarantees, haskell is your friend; if you want to support massive concurrency and insane uptime requirements, then erlang is probably the better choice
03:04:42 <tdammers> for almost all new projects, however, the right answer is probably "use what your team is most comfortable with"
03:05:30 <tdammers> that said, erlang is on my bucket list...
03:05:49 <bergmark> i'm dreaming that someone will revive the erlang type checker
03:06:04 <tdammers> heh
03:06:06 <ttt_fff> well
03:06:19 <ttt_fff> waht if I want massive concurrency and insane uptime requirements and compie time guarnatees
03:06:34 <bergmark> ttt_fff: then you dream that someone will revive the erlang type checker!
03:06:45 <tdammers> I suppose at this point, a more realistic expectation would be for someone to come up with tooling that somehow gives you erlang's actor model in a typed language like Haskell or Rust
03:06:48 <ttt_fff> I do not see anything, in the law of computations, where it says "compile time gaurantees" + "concurrency + uptime" ... pick only one
03:07:04 <ttt_fff> in fact, I'd argue that compile time guarntees helps uptime
03:07:05 <tdammers> ttt_fff: no, and there isn't anything
03:07:09 <tdammers> it'
03:07:10 <ttt_fff> and should at, the very least, not hurt concurrency
03:07:16 <tdammers> s just that erlang happens to be dynamically typed
03:07:44 <dramforever> I guess haskell being non-strict by default is a huge block
03:07:45 <tdammers> and erlang happens to have been designed with fault tolerance and concurrency in mind
03:07:55 <dramforever> but it follows our motto, right? =P
03:08:13 <ttt_fff> why is simon marlow not working to solve this problem?
03:08:17 <dramforever> *huge block to being used in production
03:08:19 <ttt_fff> he already wrot the book parallel + concurrent haskell
03:08:53 <bergmark> he also wrote haxl...
03:09:12 <maerwald> dramforever: well, a lot of people argue that in order to keep things compositional (at least at the current level) you NEED laziness by default. But afaik there will be a compiler pragma to make a whole module strict by default
03:09:15 <maerwald> so maybe that will help
03:09:28 <maerwald> but then others argue it will make things worse
03:10:16 <ttt_fff> WHAT?
03:10:20 <ttt_fff> where is this compiler pragma?
03:10:24 <ttt_fff> I want this compiler pragma
03:10:50 <bennofs> ttt_fff: https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
03:11:03 <dramforever> maerwald: it's kinda (yes only kinda) stupid
03:11:07 * dramforever away for supper
03:11:25 <bennofs> ttt_fff: not implemented yet afaik though
03:11:41 <ttt_fff> is it anything more than 'sprinkle ! everywhere' ?
03:11:45 <bennofs> ttt_fff: also https://ghc.haskell.org/trac/ghc/ticket/8347
03:12:17 <bennofs> ttt_fff: and there is a patch at https://phabricator.haskell.org/D1033
03:12:32 <ttt_fff> bennofs: stop spamming links
03:12:35 <ttt_fff> I can't process this fast
03:12:38 <bennofs> ttt_fff: :)
03:21:45 <breadmonster> bbl
03:29:43 <ttt_fff> okay, so I think forcing haskell and erlang to have a baby involves the following options: (1) add haskell's type system to erlang, or (2) add erlang's OTP + error handling (i.e. sending msg on dying) + per thread heap to haskell
03:29:49 <ttt_fff> option (2) seems the easier of the two
03:57:30 <merijn> Ok, so I have a FreeT monad over a Functor and now I want to traverse every leaf, but in my traversal function I wanna use info from the transformed monad, I'm unsure how to tackle that, though?
03:58:39 <pacak> merijn: Write a function for that!
03:59:00 <lunaris> merijn: Thinking aloud as usual; you want something of type traverseFreeT :: Monad m => (a -> m b) -> FreeT m a -> ...?
03:59:17 <lunaris> As in, can you not specialise the traversal's functor accordingly? Or am I missing the point?
04:00:00 <merijn> Wait, maybe I want Foldable
04:00:20 <merijn> No, I want "(m a -> b) -> FreeT m a -> b"
04:00:24 <lunaris> What's the goal? Are you wanting to collect/rename free variables?
04:00:32 <lunaris> Oh, interesting.
04:00:47 <merijn> lunaris: In bound I can use "isClosed" to change the type of variables
04:00:56 <merijn> But, that returns "Nothing" if there's free variables
04:01:05 <merijn> I wanna return a list of the free variables
04:01:19 <merijn> But the 'm' contains the source info of where they were parsed
04:01:32 <lunaris> Ok.
04:01:40 <merijn> So it's not enough to fold the free variables, I need to gather their source info from 'm' too
04:01:41 <lunaris> So isClosed will be your "m a -> b".
04:02:01 <merijn> No
04:02:08 <merijn> I need to reimplement isClosed
04:02:20 <lunaris> Oh, apologies.
04:02:28 <merijn> eh, closed, I mean
04:02:51 <merijn> "closed :: Traversable f => f a -> Maybe (f b); closed = traverse (const Nothing)"
04:02:55 <lunaris> Again, probably obtuse, but could you write the function by explicit runFreeT/pattern matching on FreeF and see what it looks like?
04:03:09 <lunaris> And try to work back to a traversal from that
04:03:29 <merijn> I know what it looks like, I just don't know if there's an existing combinator
04:03:45 <lunaris> Ok; sorry.
04:04:27 <lunaris> So, traverse gets you everything except the source location, right?
04:04:46 <merijn> Yeah
04:05:09 <merijn> So I somehow need to push the source loc from FreeT into 'a'
04:05:11 <lunaris> What applicative have you picked for traverse to get that sans-source behaviour?
04:05:21 <alexa_> Am I right that :: simply indicates a type annotation?
04:05:41 <lunaris> alexa_: I think so; I read it as " has the type "
04:05:48 <lunaris> alexa_: Or, " is of type ".
04:06:09 <alexa_> cheers
04:06:14 <dramforever> alexa_: it's kinda like an assertation
04:06:33 <merijn> lunaris: That's just the reader applicative (i.e. (r ->))
04:06:41 <lunaris> dramforever: Discounting things like scoped type variables?
04:06:50 <dramforever> *assertion
04:07:00 <dramforever> lunaris: dunno
04:07:02 <merijn> dramforever: Not really, assertions are generally runtime
04:07:09 <dramforever> well hmm...
04:07:22 <alexa_> It's what I'm accustomed to calling a type annotation basically
04:07:26 <alexa_> from your answers
04:07:26 <dramforever> I mean it's sort of like a proposition that you can also tell the compiler to look at
04:08:04 <merijn> alexa_: They're called type annotation in the report and most places, so yes
04:08:05 * dramforever messed it up again, ignore those crap
04:08:25 <alexa_> thanks
04:08:41 <lunaris> merijn: I can't think of a combinator that does what you want because presumably it would have to know that it's looking at something with "two levels" of structure -- the traversable bit and the monad transformer bit.
04:09:18 <lunaris> However, me not being able to think of something is probably not a great litmus test for existence.
04:10:19 <ttt_fff> haskell so great
04:10:53 <alexa_> oh wow Haskell you beautiful creature, partial application doesn't require special syntax. Presumably because all haskell functions are always curried?
04:11:17 <lunaris> alexa_: Indeed :)
04:11:17 <mauke{> alexa_: yes, assuming you always want to partially apply in the right order
04:11:33 <siarheit> > id id id 4
04:11:34 <lambdabot>  4
04:11:36 <lunaris> I think juxtaposition as application is one of the smartest decisions ever made.
04:12:23 <lunaris> That and some of Haskell's other blessed syntax tricks are why I've not to date been able to see the "homoiconicity is the only answer" argument
04:12:43 <alexa_> I know some of these words.
04:13:05 <mauke{> juxtaposition = putting things next to each other
04:13:20 <lunaris> f x y as opposed to f(x, y)
04:13:37 <alexa_> I know the meaning of juxtapose, just not in this context.
04:13:46 <lunaris> homoiconicity refers to e.g. LISP where everything "looks the same" -- code and data; it's all just lists.
04:13:48 <alexa_> "homoiconicity" was actually where I was like WHUT
04:13:52 <mauke{> homoiconicity = I don't know but I suspect it's content-free
04:13:57 <mauke{> some kind of buzzword
04:14:13 <lunaris> Which means you have no syntax (or whatever syntax you like, depending on how you look at it)
04:14:26 <dramforever> “homoiconicity (from the Greek words homo meaning the same and icon meaning representation) is a property of some programming languages in which the program structure is similar to its syntax, and therefore the program's internal representation can be inferred by reading the text's layout." -- wikipedia
04:14:31 <lunaris> (At the cost of parentheses, in the case of the latter)
04:14:45 <mauke{> dramforever: yeah, that doesn't actually mean anything
04:14:57 <quchen2> Haskell's syntax is similar to its AST, and the similarity is defined by the parser
04:14:59 <merijn> ugh, where are all the Free wizards when I need them :(
04:15:10 <mauke{> if a program's representation cannot be inferred by reading the source text, you can't write a parser for it
04:15:24 <ttt_fff> what?
04:15:25 <mniip> quchen2, touche, and lisp's parser is id
04:15:33 <mauke{> mniip: no, it's not
04:15:48 <quchen2> mniip: id parses "wlajdlfjldf..." which is not Lisp, therefore id is not a parser for Lisp.
04:15:58 <lunaris> Ah man.
04:16:02 <mauke{> furthermore, id :: String -> String
04:16:03 <lunaris> I've started a syntax fight.
04:16:12 <mniip> I was trying to make a joke :(
04:16:19 * lunaris reluctantly gets the popcorn.
04:16:19 <hpc> my AI professor said lisp has no syntax
04:16:21 <mauke{> what's the punchline?
04:16:31 <lunaris> hpc: It doesn't really.
04:16:31 <quchen2> Your AI professor is wrong
04:16:39 <hpc> yeah he was
04:16:43 <mauke{> just say you have no hands, then punch him in the face
04:16:49 <hpc> i wish i remembered what he said about haskell, it was priceless
04:16:55 <hpc> something like it has no loops, or something
04:17:17 <mauke{> in the sense that scheme has no loops
04:17:18 <lunaris> Ok, I'll be dumb.
04:17:24 <lunaris> Haskell doesn't have loops, right?
04:17:30 <tdammers> discussions about lisp parsers and lisp syntax usually fail on the weird fact that there are two levels of "syntax" in a lisp, and lispers usually imply higher-level one, whereas non-lispers think of the lower-level one
04:17:33 <mauke{> depends on your definition of "loop"
04:17:51 <mniip> haskell has no explicit loop constructs but it has plenty of ways to achieve repetition
04:17:55 <siarheit> thereis a forevertfunction. works somehow
04:17:57 <lunaris> mauke{: An imperative control flow construct that has the semantics "do this thing over and over"; I think.
04:18:08 <tdammers> (the lower level one being the part where character streams are parsed into s-expressions, and the higher-level one being where s-expressions are interpreted as forms, or something like that)
04:18:12 <lunaris> mniip: Sure, but it doesn't have loops.
04:18:13 <mauke{> lunaris: we have that as a library function
04:18:17 <hpc> i mean, every language sort of has multiple levels anyway
04:18:19 <quchen2> A loop is something that jumps back and does stuff repeatedly. In haskell we model this behaviour with recursion, so you might call certain kinds of recursion loops.
04:18:25 <tdammers> on the higher level, `id` is a parser for lisp
04:18:27 <hpc> you don't look at just the lexer and say "C has no concept of balanced parens"
04:18:36 <lunaris> mauke{: I think I classify a loop as something which has constant space properties.
04:18:37 <mauke{> tdammers: I disagree
04:18:41 <dramforever> hmm...
04:18:42 <lunaris> But perhaps I'm looking at it all wrong.
04:18:56 <mauke{> lunaris: that function runs in constant space
04:18:59 <mniip> lunaris, and what about 'forever' is not constant space?
04:19:11 <tdammers> mauke{: on which part?
04:19:16 * dramforever is probably constant space =P
04:19:29 <mauke{> tdammers: that id is a parser on any level
04:19:42 <tdammers> mauke{: ok
04:19:47 <lunaris> mauke{: True, I suppose one can define tail-recursive functions as Haskell's loops.
04:19:53 <lunaris> Like I sa.
04:19:55 <lunaris> said*
04:19:57 <mauke{> lunaris: no, those aren't imperative
04:19:59 <hpc> id is a parser for HQ9+
04:19:59 <lunaris> I'm looking at it all wrong.
04:20:04 <lunaris> But in my eyes, Haskell has recursion.
04:20:11 <hpc> it translates a string into a list of operations
04:20:18 <dramforever> actually I think s-expr is *not* the syntax
04:20:22 <lunaris> mauke{: Any non-tail-recursive call is going to touch the stack, no?
04:20:24 <dramforever> it's a syntax *style*
04:20:27 <merijn> lunaris: I think the problem is that I need Cofree instead of Free
04:20:29 <mauke{> lunaris: no, Haskell has no call stack
04:20:31 <mauke{> lunaris: it's lazy
04:20:44 <dramforever> iiuc it has a "case" stack
04:20:51 <hpc> haskell says nothing about stacks
04:20:55 <hpc> ghc has an evaluation stack
04:21:00 <mauke{> and probably an apply stack
04:21:12 <dramforever> dun...no
04:21:13 <mauke{> pattern matching and application force things, I think
04:21:33 <lunaris> mauke{: I'm reminded of the adage which refers to one opening one's mouth and confirming that one is an idiot, as opposed to being silent and merely having everyone else suspect it.
04:21:34 <ronh> so what impreative loops does haskell have? and what does even qualify as an imperative loop
04:21:39 <tdammers> the language doesn't demand a stack, but the obvious ways of implementing it involve stacks
04:21:46 <hpc> function application will seq a lambda in order to do beta reduction, at the very least
04:21:57 <mauke{> right
04:22:14 <lunaris> mauke{: I guess, to me, loops are "free" in some sense. They promise iteration without space overheads.
04:22:19 <quchen2> mauke{: I think only case forces evaluation.
04:22:22 <kuribas> Strange, I get "Could not find module ‘Criterion.Main’", but I just installed it...
04:22:25 <lunaris> Now, you can achieve that in Haskell
04:22:31 <lunaris> So, maybe Haskell has loops.
04:22:36 <mauke{> lunaris: the "problem" is that our "imperative control flow constructs" are just values
04:22:36 <Saizan> quchen2: forcing (f x) will force f
04:22:39 <mniip> quchen2, lhs of application too
04:22:40 <quchen2> mauke{: Where case is strict in its argument and can perform pattern matching.
04:23:01 <lunaris> But again, my lexicon lacks enough precision to make an argument on the matter.
04:23:04 <dramforever> > case undefined of _ -> "well, no"
04:23:05 <quchen2> On a higher level yes, but at STG?
04:23:06 <lambdabot>  "well, no"
04:23:07 <mauke{> quchen2: how are you going to 'f x' without forcing f?
04:23:26 <mniip> dramforever, that case is eliminated at core stage
04:23:27 <mauke{> oh, I'm behind
04:23:34 <tdammers> the thing is, in a language where the fundamental paradigm is that a program is a pure lazy expression, the entire concept of a "loop" doesn't really make sense at all
04:23:38 <quchen2> mauke{: Maybe I misunderstood what context we're in here.
04:23:50 <quchen2> I thought it was looow.
04:23:57 <quchen2> ...level
04:24:19 <siarheit> > let loop = loop in loop
04:24:21 <tdammers> but then, just like a pure expression can represent an impure computation, it can also represent an imperative loop, I guess
04:24:23 <lambdabot>  mueval-core: Time limit exceeded
04:25:33 <quchen2> I don't think "loop" is such a well-defined word.
04:26:17 <quchen2> In the end we're talking about abstractions around JMP, and loops and recursion do that sort of thing.
04:26:29 <tdammers> well, yes
04:26:38 <tdammers> except that some abstractions are closer to the metal than others
04:26:45 <mniip> quchen2, loop in classical sense is specific to languages that have a well-defined instruction pointer of some sort
04:27:18 <tdammers> "label X; do thing; if condition goto X" is closer to the metal than "do { thing } while (condition)"
04:27:36 <mauke{> depends on your metal
04:27:49 <tdammers> and the latter is closer to the metal than "let x = if condition then f x else x
04:27:52 <tdammers> eh
04:27:55 <mauke{> if you're a mathematician and your metal is paper, ...
04:27:55 <tdammers> whatev
04:28:07 <tdammers> let's assume our metal is a van Neumann type computer
04:28:08 * quchen2 wonders why computers are close to "metal" and not "semiconductors"
04:28:10 <tdammers> von
04:28:37 <tdammers> and yes, good questions, especially considering how it doesn't even matter what they're made of
04:28:49 * dramforever uses "box"
04:29:00 <tdammers> "closer to the box"
04:29:01 <alexa_> I'm going to refer to mine as dog.
04:29:02 <mniip> quchen2, because actual bipolar junctions don't make up the majority of the die?
04:29:10 <alexa_> Von Neuman is close to dog.
04:29:25 <tdammers> you could get a dog and name it "von Neumann"
04:29:34 <mauke{> btw, there's a language without conventional loops, jumps, or recursion. it achieves repetition by letting the program copy parts of itself to the end of the instruction stream :-)
04:30:06 <siarheit> is it an m4?
04:30:13 <hpc> lol
04:30:14 <mniip> mauke, is it called x86 microcode?
04:30:17 <tdammers> and there's Malbolge, of which I believe nobody knows yet whether loops in the traditional sense are possible, or avoidable
04:30:23 <mauke{> no and no
04:31:00 <mniip> tdammers, and that given malbolge is rather close to the dog
04:33:34 <mauke{> tdammers: http://www.lscheffer.com/malbolge.shtml#Turing
04:36:22 <tdammers> ah yeah, right
04:38:40 <tdammers> I like the "it could be worse" section, which implies that Malbolge is ultimately a failure
05:01:40 <Hafydd> Hahaha.
05:09:04 <kqr> speaking of loop not being well-defined
05:09:14 <kqr> I consider foldr and friends to be loops
05:09:22 <kqr> because they're basically explicit versions of foreach loops
05:09:26 <kqr> but people don't like that idea :(
05:09:56 <kuribas> Is there a monad besides the identity monad where evaluation is not from left to right in 'a >>= b'?
05:10:41 <mauke{> reverse state monad
05:10:56 <tdammers> reader monad
05:11:02 <tdammers> no particular evaluation order
05:11:03 <bennofs> kuribas: list monad? cont monad?
05:11:21 <kuribas> > [] >>= undefined
05:11:22 <lambdabot>  []
05:11:49 <tdammers> > undefined >>= \_ -> []
05:11:50 <lambdabot>  *Exception: Prelude.undefined
05:11:52 <|f`-`|f> sounds like a bi<effect> monad, mauke
05:11:59 <tdammers> hum
05:12:31 <kuribas> unsafePerformIO (putStrLn "hello")
05:12:33 <kuribas> > unsafePerformIO (putStrLn "hello")
05:12:34 <lambdabot>  Not in scope: ‘unsafePerformIO’
05:12:38 <kqr> haha
05:12:50 <kqr> that's lambdabot smacking you on the fingers
05:12:58 <nomeata> Darn. I cannot find a simple, elementary construction of a model for the lambda calculus along the lines of "D = (D → D)". Does anyone know a good reference?
05:13:07 <frerich> Debugging a Malbolge interpreter is probably tricky. Or very easy, since you can hardly tell whether it's buggy. :-)
05:13:13 <kuribas> tdammers: reader monad is from left to right.
05:13:43 <bennofs> kuribas: such a monad would need to not inspect the first argument of >>= to get the value to apply the second argument to
05:13:54 <|f`-`|f> Someone will tame the bulge of malbolge, frerich 
05:14:02 <|f`-`|f> It will be like the Battle of the Bulge
05:14:22 <kuribas> bennofs: it does?
05:14:28 <bennofs> > Control.Monad.Writer.execWriter $ undefined >>= \_ -> return 3
05:14:29 <lambdabot>  ()
05:14:36 <bennofs> > Control.Monad.Writer.runWriter $ undefined >>= \_ -> return 3
05:14:37 <lambdabot>  (3,())
05:14:37 <tdammers> runReader (undefined >>= const "hi")
05:14:39 <tdammers> > runReader (undefined >>= const "hi")
05:14:40 <lambdabot>      Couldn't match expected type ‘ReaderT r Identity a’
05:14:41 <lambdabot>                  with actual type ‘[Char]’
05:14:41 <lambdabot>      In the first argument of ‘const’, namely ‘"hi"’
05:14:52 <tdammers> > runReader (undefined >>= const "3)
05:14:54 <lambdabot>  <hint>:1:35:
05:14:54 <lambdabot>      lexical error in string/character literal at end of input
05:14:54 <tdammers> > runReader (undefined >>= const 3)
05:14:55 <lambdabot>      No instance for (Typeable r0)
05:14:55 <lambdabot>        arising from a use of ‘show_M668114674394075338910775’
05:14:55 <lambdabot>      In the expression:
05:15:03 <tdammers> > runReader (undefined >>= const ())
05:15:04 <lambdabot>      Couldn't match expected type ‘ReaderT r Identity a’
05:15:04 <lambdabot>                  with actual type ‘()’
05:15:04 <lambdabot>      In the first argument of ‘const’, namely ‘()’
05:15:05 <bennofs> > Control.Monad.Reader.runReader $ undefined >>= \_ -> return 3
05:15:07 <lambdabot>      No instance for (Typeable r0)
05:15:07 <lambdabot>        arising from a use of ‘show_M806533833420192967110801’
05:15:07 <lambdabot>      In the expression:
05:15:15 <bennofs> tdammers: you're missing the return, no?
05:15:28 <bennofs> > flip Control.Monad.Reader.runReader () $ undefined >>= \_ -> return 3
05:15:30 <lambdabot>  3
05:15:47 <tdammers> > runReader (undefined >>= const (return ())) ()
05:15:49 <lambdabot>  ()
05:15:57 <tdammers> also missing the value to be read :D
05:16:19 <tdammers> but anyway, it doesn't evaluate left-to-right
05:16:35 <tdammers> it evaluates lazily
05:16:53 <|f`-`|f> so when asked "Does it evalutate left or right"
05:16:57 <|f`-`|f> The answer is: Mu
05:17:06 <tdammers> which is pretty much what I said
05:17:13 <tdammers> it evaluates in whichever order makes sense
05:17:19 <|f`-`|f> So much for the buddhist joke
05:17:31 <kuribas> hmm, I see.
05:18:11 <tdammers> |f`-`|f: when I read the documentation for hastache not too long ago, when I first encountered MuType and MuValue, I thought there was some sort of Zen meaning to those names
05:18:25 <tdammers> turns out, they're just short for "MUstache"
05:19:17 <|f`-`|f> well when it's hasSTACHE
05:19:21 <|f`-`|f> I can't see why
05:19:43 <dramforever> well mu is the greek letter right?
05:20:06 <dramforever> often used to mean "recursive" or something similar
05:20:06 <|f`-`|f> It's a joke about a monk being asked whether or not a dog can be enlightened
05:20:13 <dramforever> oh hmm...
05:20:53 <frerich> dramforever: https://en.wikipedia.org/wiki/Mu_(negative)
05:21:26 <kuribas> > runReader (undefined >>= const (return ())) undefined
05:21:28 <lambdabot>  ()
05:22:13 <dramforever> hmm...
05:22:22 <dramforever> frerich: I'm Chinese =P
05:22:56 <frerich> dramforever: I'm German. Hello there!
05:23:38 <dramforever> frerich: I mean, I know wu means something is absent
05:23:41 <dramforever> but not mu...
05:23:56 <tdammers> "mu" is the buddhist way of un-asking questions that cannot be answered
05:23:56 <Rembane> Maybe its greek?
05:24:56 <tdammers> I think in the original kōan, the monk asks the master whether the dog they are looking at is buddha-natured
05:24:58 <frerich> dramforever: I recognized 'Mu' as being the way to un-asking questions ("The question cannot be answered because it's based on incorrect assumptions"), which makes sense in the Japanese Zen trying to overcome dualism (i.e. no 'right' and 'wrong').
05:25:12 <tdammers> and the master says "mu", and the monk is enlightened, or something like that
05:25:37 <dramforever> frerich: something like this?
05:25:40 <dramforever> > 1 == "1"
05:25:41 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
05:25:41 <lambdabot>      In the first argument of ‘(==)’, namely ‘1’
05:25:41 <lambdabot>      In the expression: 1 == "1"
05:25:46 <dramforever> ghc says "mu"
05:26:12 <frerich> dramforever: I guess with a lot of good will that could be considered 'Mu', yes ;-)
05:27:49 <phaazon> god
05:27:52 <phaazon> pipes is so great
05:28:01 <phaazon> what have I not used that before
05:28:17 <phaazon> I've always looked for loose coupling in Haskell
05:28:38 <tdammers> in what sense?
05:29:21 <dramforever> phaazon: I guess you mean external standard interface rather than custom interface?
05:30:29 <zhutao> 泥蒙壕~
05:31:06 <phaazon> tdammers: in the sense of yielding values
05:31:10 <phaazon> and consumming them later on
05:31:18 <phaazon> a bit like Free can be used for decoupling
05:31:37 <tdammers> well, I guess you can make your coupling as loose or as tight as you want in Haskell
05:32:09 <tdammers> you could serialize everything to JSON if you want to go extreme, for example
05:32:25 <dramforever> phaazon: it's like BEFORE a -> b -> c, AFTER a -> pipes -> b -> pipes -> c
05:32:29 <|f`-`|f> Half of the research I've seen in haskell is finding "Mu"
05:32:53 <|f`-`|f> Want your Push and Pull arrays?
05:33:25 <phaazon> tdammers: dramforever: as in MVC, actually
05:33:37 <dramforever> well it can benifit a lot if we get ghc to respond with something as far away as possible from mu when dealing with errors
05:33:39 <phaazon> like, I want to be able to write a GUI without having to care about the render part
05:33:46 <phaazon> and plug a system on the tree later on
05:33:53 <phaazon> I think pipes could be great to implement that
05:33:56 <nabokovian> is mu recursion?
05:33:59 <JagaJaga> How to do "if 3rd arg is empty then make it "foo"" via Options.Applicative?
05:34:13 <tdammers> nabokovian: if you squint a little, mu is bottom
05:34:21 <dramforever> phaazon: I don't really think mvc is good...
05:34:26 <phaazon> JagaJaga: fromMaybe "foo"
05:34:31 <phaazon> dramforever: why so?
05:34:34 <tdammers> dramforever: depends which interpretation of the gospel you use
05:34:37 <merijn> Is there an error accumulating Either?
05:34:41 <phaazon> decoupling model from view is good.
05:34:43 <aznashwan> zhutao: 日本莳萝草
05:34:46 <JagaJaga> phaazon: thx
05:34:56 <tdammers> the MVC Gospel Of Rails is pretty terrible
05:34:59 <dramforever> zhutao: 你好 你暴露了
05:35:02 <merijn> i.e. "instance Monoid m => Monad (Either m)"?
05:35:06 <dramforever> =)
05:35:11 <zhutao> ~
05:35:19 <dramforever> merijn: I doubt if that could be implemented
05:35:26 <dramforever> I think an Applicative one exists
05:35:39 <tdammers> the original MVC is really just the input/logic/output model applied to long-running stateful GUI programming
05:36:11 <tdammers> "modern" "MVC" is really just the oldschool three-tier model brushed up and relabeled to appeal to web 2.0 hipsters
05:36:28 <merijn> dramforever: Eh, Applicative is good enough, I guess
05:36:32 <dramforever> zhutao: consider joining #haskell-cn, there aren't many people there, but (at least I think) we are trying to build it up
05:37:00 <supki> @hackage validation -- merijn
05:37:00 <lambdabot> http://hackage.haskell.org/package/validation -- merijn
05:37:07 <|f`-`|f> What about MVA, tdammers 
05:37:17 <phaazon> tdammers: so what do you suggest?
05:37:29 <tdammers> phaazon: keep doing what you're doing, I guess?
05:37:43 <|f`-`|f> It's more or less "OUT doesn't need to go to a GUI"
05:37:52 <|f`-`|f> And IO is many-many
05:40:25 <|f`-`|f> seems brushed up
05:41:57 <kuribas> Has anyone ever had a problem because of *dangerour reinstalls*?
05:42:05 <merijn> kuribas: Plenty of people
05:42:26 <dramforever> hmm..."because of"
05:42:47 <kuribas> merijn: it often seems necessary for me...
05:42:48 <dramforever> merijn: well we get something like missing symbols when linking?
05:43:22 <tdammers> my strategy: when cabal suggests dangerous reinstalls, make sure I'm in a sandbox, then do them anyway, and if anything breaks, wipe the sandbox and start from scratch
05:43:57 <dramforever> tdammers: yeah, and I make sure that I only use stackage outside a sandbox
05:44:03 <nkaretnikov> kuribas: you should avoid installing anything globally, if possible
05:44:12 <nkaretnikov> kuribas: in addition to what tdammers said
05:44:21 <tdammers> yeah, sandboxes wherever possible
05:44:33 <nkaretnikov> since it imposes additional restrictions on what you can have in a sandbox
05:44:36 <kuribas> is stack going to replace cabal?
05:44:38 <tdammers> outside the sandbox, I prefer installing debian packages
05:44:45 <dramforever> quick question: does makeLenses generate prism/iso/... ?
05:44:49 <dramforever> or it's lenses only
05:44:57 <nkaretnikov> kuribas: I don't think so, not in the short term at least
05:45:05 <nkaretnikov> kuribas: it's just one of the available solutions
05:45:24 <dramforever> oh never mind =P
05:45:29 <nkaretnikov> kuribas: tastes differ, so folks prefer different tools
05:46:28 <nkaretnikov> kuribas: there are other tools besides stack and cabal-install (that I'm aware of): nix and cabbage
05:46:38 <nkaretnikov> kuribas: oh, and skete!
05:47:06 <nkaretnikov> which is a bit different, but still in the same space
05:47:23 * dramforever is going to try nix
05:50:14 <peterson> hey all .. quick cabal qn
05:50:22 <peterson> i'm getting started with hunit
05:50:49 <aznashwan> > 3 + 4
05:50:50 <lambdabot>  7
05:50:58 <peterson> in order to make "cabal test" work, i had to do a manual "cabal install shelltestrunner" to pull down HUnit and other deps
05:51:30 <nkaretnikov> peterson: you need to do: cabal install --only-dep --enable-tests
05:51:30 <peterson> my qn: is there any way to specify these "test" deps in the cabal file, so that "cabal install --only-dependencies" will install them to the sandbox for the project?
05:51:42 <peterson> ahah :)
05:51:42 <nkaretnikov> and it should pull everything including the test libs
05:51:50 <peterson> magic .. many thx
05:51:58 <nkaretnikov> np
05:53:13 <JagaJaga> phaazon: but there are no function returning Maybe in that library.. How to use your suggestion?
05:55:43 <kuribas> I wish there was a numPy equivalent in haskell.
05:57:22 <learnhaskellordi> @kuribas why? python > haskell
05:57:22 <lambdabot> Unknown command, try @list
05:57:31 <learnhaskellordi> kuribas why? python > haskell
05:58:33 <tdammers> learnhaskellordi: by what metric?
05:58:46 <quchen2> > "python" > "haskell"
05:58:48 <lambdabot>  True
05:58:56 <kuribas> learnhaskellordi: Depends on your instance.
05:58:58 <tdammers> oh, right, ofc
05:59:02 <|f`-`|f> isn't numPy just a C wrapper, so isn't C > Python? learnhaskellordi 
05:59:51 <tdammers> seriously though, I believe one of the reasons numPy is necessary in the first place is because Python by itself performs atrociously when it comes to number crunching
06:00:10 <tdammers> but by offloading the heavy lifting to C in a clever way, you can make it happen
06:00:17 <tdammers> which is what numPy does
06:00:30 <kuribas> tdammers: But it is comprehensive, and has a standard representation for matrices, etc...
06:00:31 <dramforever> tdammers: haskell can also behave weirdly
06:00:40 <tdammers> dramforever: sure
06:00:43 <dramforever> if you run into strictness problems, you know
06:00:48 <kuribas> tdammers: haskell numeric libraries all have their own incompatible representations.
06:00:54 <dramforever> yeah
06:01:26 <nshepperd> I thought it was mostly a fortran wrapper
06:01:43 * dramforever wonders if (co)monadic stuff can be incorprated into lens
06:02:14 <|f`-`|f> it'd only run faster, nshepperd 
06:02:48 <learnhaskellordi> i wish there'd be a numpy in assembler /s https://xkcd.com/378/
06:02:59 <bananum> hello anybody; I'm a newbie and I have an HUbigraph issue. Precisely, examples do not work, I'm getting "connect: does not exist (Connection refused)" error, but 1) python examples from archive with Ubigraph work fine, and 2) connectTo from Network package works fine, I can get proper Handle for socket. Is this a haxr (XML-RPC) issue?
06:03:45 <dramforever> learnhaskellordi: real programmers write that themselves
06:06:20 <axsz> has anyone in here used haskell on phones
06:06:26 <merijn> ok, so I get how https://github.com/ekmett/bound/blob/master/examples/Deriving.hs constructs trees, but I don't get how you would, for example, evaluate applying a lambda there?
06:06:27 <axsz> like android
06:07:10 <tdammers> I'm toying with the idea of combining ghcjs and phonegap :x
06:08:04 <axsz> that would be neat
06:08:40 <bananum> Specifically, I've got example code from https://github.com/smly/hubigraph and http://stackoverflow.com/questions/5267963/tree-visualisation-and-animation/5295652#5295652
06:09:35 <tdammers> compiling haskell to native android an iOS code would be neater, but I have no idea if anything exists in that arena
06:11:59 <tdammers> but for now, I believe going through phonegap would at least produce results faster
06:11:59 <phaazon> JagaJaga: poste code please
06:12:08 <phaazon> I can't help you if I'm blinded :)
06:13:11 <JagaJaga> phaazon: parsePath = strOption $ short 'p' (OR RETURN "FOO"). Smth like that :)
06:17:22 <phaazon> I don't know that library
06:17:28 <phaazon> @hoogle strOption
06:17:28 <lambdabot> No results found
06:17:42 <phaazon> what is the type of short?
06:20:16 <fractalsea> Could someone help me with an overlapping instances issue when I’m trying to mock some IO actions using typeclasses please? Code: http://lpaste.net/136235
06:23:07 <JagaJaga> phaazon: https://hackage.haskell.org/package/optparse-applicative-0.11.0.2
06:23:59 <phaazon> JagaJaga: alright
06:24:06 <phaazon> so you want to return "foo" if the parser fails?
06:24:16 <JagaJaga> phaazon: yup ^_^
06:24:24 <JagaJaga> phaazon: <|> ? "foo"
06:24:39 <JagaJaga> ? -- means I don't know what to paste there
06:24:46 <phaazon> well
06:24:57 <tdammers> how about "pure"
06:25:00 <phaazon> strOption (short 'p') <|> pure "foo"
06:25:02 <phaazon> that should do it
06:25:18 <supki> JagaJaga: you can set default values with `value`
06:25:38 <phaazon> I guess in your case that pure "foo" will just return "foo" without consumming the upstream source
06:25:42 <phaazon> like parsec does
06:25:44 <JagaJaga> phaazon: f. My brains don't work today. Thank you and tdammers!
06:26:20 <JagaJaga> supki: that's what I need. Thank you.
06:30:23 <mauke{> fractalsea: you have an instance for MonadHTTP (ReaderT r m) and one for MonadHTTP (ReaderT (Response BL.ByteString) m)
06:30:39 <mauke{> fractalsea: r and Response BL.ByteString overlap. what's unclear?
06:30:55 <mauke{> s/overlap/unify/ maybe?
06:32:30 <fractalsea> mauke{: But I wouldn’t expect it to match the MonadHTTP (ReaderT r m) instance because it doesn’t satisfy the constraint that MonadHTTP m =>
06:33:14 <mauke{> those are irrelevant for instance selection
06:33:47 <mauke{> instances work a bit like functions, only at the type level
06:33:52 <fractalsea> Oh..
06:34:13 <mauke{> MonadHTTP (ErrorT e m) = (Error e, MonadHTTP m)
06:34:17 <fractalsea> That’s dissapointing. Is there a workaround for this? Other than flexible instances
06:34:26 <mauke{> MonadHTTP (ReaderT r m) = MonadHTTP m
06:34:42 <mauke{> MonadHTTP (ReaderT (Response BL.ByteString) m) = Monad m
06:34:52 <mauke{> ^ typechecker pseudocode
06:34:59 <fractalsea> Ah right
06:35:09 <mauke{> flexible instances won't save you
06:35:12 <fractalsea> So the constraints are not check basically
06:35:27 <mauke{> overlapping instances can do this but I don't trust that extension
06:36:35 <fractalsea> Is there another way I can structure this that doesn’t involve language extensions? I basically need the main ReaderT instance for my main program, and my HTTP server is also modelled as a ReaderT. I guess I could just use StateT for the mock, but that seems like a bit of a hack
06:36:43 <merijn> Hmmm, is System Fω inferable?
06:37:07 <tdammers> fractalsea: stack two ReaderT's, lift explicitly?
06:37:33 <mauke{> tdammers: how will that solve anything?
06:37:51 <tdammers> mauke{: don't know, probably didn't read enough scrollback, ignore me, I'm sorry
06:37:53 <mauke{> fractalsea: well, you can always newtype around the reader
06:38:11 <mauke{> tdammers: we want different instances but in this case both are ReaderT
06:38:28 <tdammers> ah, right
06:38:33 <tdammers> yeah, then newtype, I'm afraid
06:39:01 <mauke{> fractalsea: newtype MockServer m = MockServer (ReaderT (Response BL.ByteString) m)
06:39:04 <mauke{> or something like that
06:39:32 <mauke{> except that's not well typed, is it?
06:39:43 <mauke{> newtype MockServer m a = MockServer (ReaderT (Response BL.ByteString) m a)
06:40:06 <fractalsea> mauke{: Ah I see. Thanks I will give that a try
06:40:12 <fractalsea> Seems like the best solution
06:40:16 <fractalsea> Thanks
07:06:06 * vanja
07:07:40 <slimdeviant> Hey guys! Looking at the Prelude source, any function: "any p = getAny #. foldMap (Any #. p)", what does #. mean???
07:08:22 <mauke{> slimdeviant: it's defined right there
07:08:51 <bennofs> slimdeviant: I think it's just a more efficient version of (.) for when one argument of it is a newtype constructor / destructor
07:11:29 <slimdeviant> mauke{: can you please elaborate?
07:13:11 <mauke{> slimdeviant: uh... 33 lines further down?
07:13:57 <P4Titan> Hello all, is there a haskell data type that closest resembles a regular array. Constanst size, O(1) access to values and O(1) updating of a single value?
07:14:28 <slimdeviant> mauke{: thank you very much!
07:14:47 <mauke{> P4Titan: STArray?
07:15:14 <P4Titan> Why do I need a state monad for an array?
07:15:21 <quicksilver> is it time for my rant about O(1) not existing?
07:15:22 <mauke{> because you want to modify it
07:15:32 <mauke{> also ST is not a state monad
07:15:40 <P4Titan> what is ST?
07:15:42 --- mode: quicksilver set -o quicksilver
07:15:54 <mauke{> locally mutable variables
07:16:19 <frerich> quicksilver: You're alive! Long time no see!
07:16:30 <quicksilver> :)
07:16:33 <mauke{> for example because you have an algorithm that's externally pure but uses mutable variables on the inside
07:16:41 <P4Titan> Ok, why should I use STArray over IOArray?
07:16:54 <mauke{> because you want to provide a pure interface
07:17:10 <P4Titan> Could you please explain?
07:17:39 <chpatrick> P4Titan: I recommend MVector
07:17:45 <mauke{> explain what?
07:18:07 <P4Titan> "provide a pure interface"
07:18:12 <chpatrick> P4Titan: https://hackage.haskell.org/package/vector-0.10.12.3/docs/Data-Vector-Mutable.html
07:18:19 <mauke{> what's unclear?
07:18:19 <tdammers> P4Titan: an interface that doesn't involve IO
07:18:33 <chpatrick> P4Titan: with ST you can do "ST a -> a"
07:18:39 <chpatrick> that's not allowed with IO
07:19:19 <chpatrick> ST is a bit like IO except the only side effects you can have are modifying mutable variables/arrays
07:19:20 <P4Titan> You mean, ST's contents can be extracted while IO's cannot?
07:19:28 <poincare101> Quick question: why doesn't GHC automatically memoize pure functions?
07:19:28 <chpatrick> well more like its result can be extracted
07:19:41 <P4Titan> results?
07:19:43 <mauke{> poincare101: all functions are pure
07:19:46 <chpatrick> poincare101: how would it know when to memoize?
07:19:55 <chpatrick> it can't keep every output
07:20:00 <mauke{> sure it can
07:20:06 <mauke{> it'll just get slow
07:20:12 <chpatrick> ok not feasibly :)
07:20:22 <chpatrick> P4Titan: yeah like the the a in IO a
07:20:22 <poincare101> chpatrick: what if it did something like an LRU cache of outputs
07:20:31 <P4Titan> What do you mean by result
07:20:35 <mauke{> defining a lookup table for values that can't be compared is also tricky
07:20:43 <chpatrick> well it's wrong to say ST's "contents"
07:20:51 <P4Titan> why?
07:20:55 <chpatrick> because it's not a container
07:20:58 <chpatrick> it's a computation
07:21:07 <P4Titan> Ok...
07:21:19 <chpatrick> so the a in IO a means what kind of result you'll get
07:21:29 <chpatrick> it's like a plan to make a value of type a
07:21:38 <chpatrick> it's not a wrapper or a container around a or anything like that
07:22:14 <P4Titan> Ok, I am only used to the IO monad. I know that IO a -> a is not possible. Why is it possible in ST; both are state monads.
07:22:15 <mauke{> firefox is not an archive of web pages
07:22:19 <exio4> poincare101: also, results may be arbitrary large and you might want to not `cache `them
07:22:34 <chpatrick> P4Titan: because ST is "sandboxed" so that it doesn't have real-world side effects
07:22:46 <mauke{> P4Titan: because IO is weird. also how is IO a "state monad"?
07:22:51 <chpatrick> the only side effect an ST computation can have is to mutate its internal state
07:23:06 <exio4> P4Titan: being `state monads` is part of the implementation details, looking at the implementation hacks gives you the wrong idea
07:23:23 <tdammers> both are monads, and both can model stateful computations, but neither is a state monad
07:23:45 <P4Titan> So, all ST can do is modify its internals why IO can print and write to file and such?
07:23:53 <geekosaur> because IO is IO
07:24:02 <geekosaur> it's not strange because it's a monad, it's strange because it is IO
07:24:17 <aweinstock> :t unsafePerformIO
07:24:19 <lambdabot> Not in scope: ‘unsafePerformIO’
07:24:22 <geekosaur> ST is not IO, its only strangeness is a type hack that prevents values from being visible outside of it
07:24:30 <aweinstock> :t System.IO.Unsafe.unsafePerformIO
07:24:31 <lambdabot> IO a -> a
07:24:38 <mauke{> aweinstock: you're fired
07:24:52 <geekosaur> so you can do "evil" (== mutable) inside of it and they can't affect the rest of the program
07:25:50 <P4Titan> Why couldn't they affect the rest of the program?
07:26:15 <P4Titan> Changing the inside of ST a should affect something
07:26:46 <mauke{> ah, fun with the type system
07:26:47 <exio4> ST is different to IO, IO is different to ST, the fact that you they're implemented "somewhat" using the same hacks in GHC is different, you could think of both of them as ASTs (a la free monads)
07:26:54 <aweinstock> something to do with the state thread parameter of ST enforcing that ST computations can only depend on their input?
07:27:10 <mauke{> P4Titan: the variables you can modify are STRefs
07:27:17 <slimdeviant> How to get the element that satisfied the condition of any function???
07:27:32 <geekosaur> the specific way something could affect the rest of the program is sharing, where some result can be reused elsewhere. (for example, if you nsert a node into a tree, you get a new tree back which shares most of its structure with the old tree, and some other part of the program may well have the old tree)
07:27:40 <mauke{> P4Titan: more specifically, they have type STRef s X for some type X
07:28:00 <geekosaur> the type hack in ST ensures that no such sharing can occur, because only a final result can be seen outside of ST
07:28:23 <lpaste> fractalsea pasted “newtype approach” at http://lpaste.net/136236
07:28:27 <mauke{> P4Titan: the way ST is defined, you can't create an STRef outside of ST and you can't share variables between different ST computations and you can't return an STRef from a computation
07:28:30 <P4Titan> So, older values held inside of the ST are overwritten?
07:28:36 <geekosaur> and it prevents you from using mutable components in that result because outside of the ST they cannot be given a type
07:29:12 <lexi-lambda> Random question: is there a function that works something like this? (a -> x -> b) -> (c -> x -> d) -> x -> ((a -> b), (c -> d))
07:29:13 <fractalsea> mauke{: This is how far I’ve got implementing the mock server with a newtype. Any chance you could let me know where I’m going wrong/workarounds. Thanks. http://lpaste.net/136236
07:29:23 <fractalsea> Feel like I’m getting out of my depth with this stuff :(
07:29:53 <P4Titan> Ok, this is a tad confuzling. Could someone explain ST and STRef again. Sorry, this stuff is new.
07:30:14 <lexi-lambda> This sort of thing would work, too: (a -> x -> b) -> (c -> x -> d) -> x -> (a -> c -> (b, d))
07:30:17 <geekosaur> it's going to be confusing, because ST is all about a type "trick"
07:30:46 <aweinstock> mauke{: is the state thread concept used in st (what geekosaur is refering to as the "type hack") related to linear/affine types?
07:30:48 <geekosaur> so, ST looks superficially like a state monad. but the state is something that is inaccessible, and it can't even be given a type outside of runST
07:31:10 <mauke{> fractalsea: why do you need a MonadError instance?
07:31:12 <P4Titan> Then how is ST a -> a possible?
07:31:42 <chpatrick> because a given ST s a will always have the same result
07:31:52 <fractalsea> Because the function I am testing that does HTTP has type (A.FromJSON a, Functor m, MonadError String m, MonadHTTP m)
07:31:52 <chpatrick> since it's isolated from everything else
07:31:53 <fractalsea>   => T.Text
07:31:54 <fractalsea>   -> [(T.Text, B.ByteString)]
07:31:54 <fractalsea>   -> m a
07:32:09 <geekosaur> (basically the "state" has type (forall a. a) for which the only value is undefined, and its type is not visible from "outside" so the compiler will refuse to have anything to do with values "outside")
07:32:30 <geekosaur> you can do ST s a -> a under one condition: a does not use or refer to s
07:32:40 <P4Titan> what is s now?
07:32:42 <geekosaur> ST also gives you mutable cells; these by construction refer to s
07:32:54 <geekosaur> [09 14:31] <geekosaur> (basically the "state" has type (forall a. a) for which the only value is undefined, and its type is not visible from "outside" so the compiler will refuse to have anything to do with values "outside")
07:33:31 <fractalsea> I guess I could use UndecidableInstances. I wanted to avoid it, but judging by the standard instances defined in the Control.Monad.Error library uses this approach
07:34:11 <P4Titan> I amn't getting this. Should I just read the Haskell Wiki on Monad/ST?
07:34:13 <frerich> slimdeviant: You could combine all your predicates into a list in e.g. 'let p x = and (map ($ x) [p1, p2, p3]) in filter p xs'
07:34:18 <geekosaur> so, within a runST you can use STRef-s to do mutable things as you compute some a. as long as the final result does not actively refer to any STRef-s (which ensures that it is pure), it can then be passed back as the result of runST
07:35:15 <geekosaur> the point here is that "s" doesn't really exist, it is what we call a "phantom type"
07:35:27 <P4Titan> Then why is it useful?
07:35:32 <geekosaur> any value which has "s" in its type is tagged as mutable and can't be returned
07:35:34 <chpatrick> P4Titan: so s is a tag for a given ST computation. You're only allowed to run ST computations that don't look at the tag, which guarantees that they're not using something left over from somewhere else
07:35:45 <geekosaur> but we can use it for intermediate results in computing something
07:35:48 <chpatrick> it's a bit convoluted
07:36:24 <frerich> slimdeviant: Ah, instead of 'and + map' one could use 'all', like 'filter (\x -> all ($ x) [p1, p2]) xs'
07:36:31 <geekosaur> so: we can now use mutating algorithms like you might use in an impure language, via STRef-s. and because an STRef is tagged with this phantom "s", they cannot "leak" mutability.
07:36:34 <chpatrick> if you were to use an STRef left over from another ST computation, it would have a particular tag
07:36:42 <chpatrick> so any computation on it would have a particular tag
07:36:50 <chpatrick> but you're only allowed to run computations that work for any tag
07:37:01 <geekosaur> but your final result, provided that it does not refer to an STRef (i.e. does not have "s" in its type), is pure and can be returned safely
07:37:04 <chpatrick> rather than a particular one
07:37:59 <P4Titan> Is there something I should read that has examples or something? I get what you say suferficially, I don't fully understand how the a remains pure, even when it has been changed...
07:38:46 <chpatrick> P4Titan: it hasn't been changed though
07:38:57 <chpatrick> ST s a is an immutable plan to compute an a
07:38:57 <geekosaur> because the only ways it can become impure cause it to be "tagged" with that phantom "s"
07:39:12 <geekosaur> and then that type cannot be seen outside of runST
07:39:22 <chpatrick> or rather (forall s. ST s a) is an immutable plan to compute an a
07:39:30 <geekosaur> so it can never escape (and if you try the compiler tells you that "s" is trying to escape)
07:39:46 <chpatrick> they're both immutable but the second one will always have the same result
07:39:58 <chpatrick> sorry for being confusing :P
07:40:17 <chpatrick> if you want to just get stuff done I'd just use IOVector :)
07:40:23 <P4Titan> Is there a /simple/ example somewhere?
07:40:28 <geekosaur> note also that there is a difference between an STRef (tagged with "s" and cannot escape) and the value inside of it (which may or may not be pure; its type will indicate it)
07:41:56 <geekosaur> which is how you can use mutable STRef-s to build a pure value
07:42:44 <aweinstock> is GHC able to do more optimizations inside ST than inside IO?
07:42:56 * hackagebot ViennaRNAParser 1.2.5 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.2.5 (FlorianEggenhofer)
07:43:20 <geekosaur> yes, because the only weirdness is in STRef-s
07:43:40 <geekosaur> IO, because it is IO, can do just about anything and therefore the compiler can trust nothing :)
07:44:11 <geekosaur> well, it can trust one thing: that IO actions will happen in a particular order
07:44:58 <geekosaur> and that IO actions can't affect pure values. but they can do anything else
07:46:21 <fractalsea> mauke{: Oh I get a (typechecker) loop with undecidable instances
07:47:34 <aweinstock> geekosaur: isn't it possible for IO actions to affect pure values by doing something like scribbling on the heap with Foreign.Marshall?
07:48:34 <geekosaur> they can, but I don't think they can do so purposefully (that is, knowing *what* they are changing)
07:48:36 <slimdeviant> But I was asking how to get the element that conformed to the function passed as an argument to any, i.e. that returned True to the Boolean function passed to the 'any' as argument???
07:48:43 <chpatrick> aweinstock: they can't modify pure values modify serious abuse :P
07:48:47 <geekosaur> they can scribble randomly, but that is no different from any other bottom
07:48:47 <chpatrick> *modulo
07:49:07 <chpatrick> :t find
07:49:08 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
07:49:13 <chpatrick> slimdeviant: ^
07:50:20 <slimdeviant> chpatrick: I didn't quite understand that, part me, I'm a beginner haskeller :)
07:50:33 <slimdeviant> chpatrick: Would you please elaborate further?
07:52:57 * hackagebot clash-lib 0.5.9 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.9 (ChristiaanBaaij)
07:52:59 * hackagebot clash-vhdl 0.5.8 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.8 (ChristiaanBaaij)
07:53:01 * hackagebot clash-ghc 0.5.10 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.10 (ChristiaanBaaij)
07:55:27 <aweinstock> :t Prelude.find
07:55:28 <lambdabot>     Not in scope: ‘Prelude.find’
07:55:28 <lambdabot>     Perhaps you meant one of these:
07:55:28 <lambdabot>       ‘Prelude.and’ (imported from Prelude),
07:55:36 <aweinstock> :t Data.List.find
07:55:37 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
07:56:11 <aweinstock> that's alot more generic than what i'm getting on a local ghci
07:56:23 <chpatrick> you're not on 7.10 right?
07:56:30 <aweinstock> :t find :: (a -> Bool) -> [a] -> Maybe a
07:56:31 <lambdabot> (a -> Bool) -> [a] -> Maybe a
07:56:52 <chpatrick> we burnt the bridges and made everything general :)
07:56:52 <aweinstock> 7.4.1, it seems (debian wheezy)
07:56:57 <chpatrick> woah that's old
07:57:00 <srhb> aweinstock: In 7.10 a lot of functions were generalized to use Foldable and stuff.
07:57:09 <srhb> chpatrick: Not THAT old... 2014 still, isn't it?
07:57:14 <chpatrick> that's three releases ago
07:57:15 <srhb> We're just moving very fast. :-)
07:57:28 <tdammers> wheezy is oldstable right
07:57:36 <jacereda> I can't figure out what's consuming obscene amounts of memory in my program... http://lpaste.net/2304917160293564416
07:57:37 <tdammers> I'd upgrade to jessie ASAP
07:57:38 <nitrix> When is the next Haskell report due for?
07:58:02 <tdammers> but anyway, I installed 7.8 from the haskell platform website yesterday, and it turned out ridiculously easy
07:58:33 <Athas> Installation is not the hard part.  Maintenance, on the other hand...
07:58:49 <aweinstock> slimdeviant: find takes a predicate (a -> Bool), and a container (Foldable t => t a), and returns the first element in the container for which the predicate returns true, if there is one (Maybe a)
07:58:50 <jacereda> any hint on how to go about debugging memory issues?
07:58:50 <tdammers> in general, yes
07:58:53 <chpatrick> slimdeviant: so the idea is that you give it a predicate like with any, and a list for example, and it gives you a result if there is one
07:59:17 <nitrix> What's the difference between functors and foldables?
07:59:34 <chpatrick> :t fmap
07:59:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:59:36 <chpatrick> :t foldMap
07:59:37 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
08:00:00 <chpatrick> foldable is about computing something by folding over all the values "inside"
08:00:11 <nitrix> It implies there are functors that aren't foldable, but I can't conceptualize that :/
08:00:30 <aweinstock> isn't IO a Functor that isn't Foldable?
08:00:40 <lsix> Hi, is there a function somewhere as : Int -> UTCTime (to interplet a regular timestamp) ?
08:00:54 <nitrix> aweinstock: Ah, that could be a good example. Do you have more?
08:01:00 <slimdeviant> aweinstock: chpatrick: Thank you guys
08:01:07 <chpatrick> hmm surely you could make anything a degenerate Foldable
08:01:17 <chpatrick> foldMap _ = mempty
08:01:28 <chpatrick> are there rules for it?
08:01:59 <bennofs> nitrix: (->) r
08:02:08 <aweinstock> chpatrick: possibly relevant: http://www.reddit.com/r/haskell/comments/32wjoz/lawful_foldable/
08:02:57 <chpatrick> hmm interesting
08:03:31 <chpatrick> so you upgrade it to a functor with traversable and then use the default foldable instance right?
08:03:38 <chpatrick> *with Coyoneda
08:04:23 <aweinstock> I'm not sure I understand it, I just had it bookmarked for some reason
08:12:58 * hackagebot hakyll-R 0.1.0.0 - A module allowing to write Hakyll blog posts in Rmd  http://hackage.haskell.org/package/hakyll-R-0.1.0.0 (CorentinDupont)
08:13:00 * hackagebot hakyll-R 0.1.0.1 - A module allowing to write Hakyll blog posts in Rmd  http://hackage.haskell.org/package/hakyll-R-0.1.0.1 (CorentinDupont)
08:16:59 <epta> how to use `--constraint` flag in `cabal configure` command properly? http://lpaste.net/raw/8058100117565079552
08:18:45 <geekosaur> epta, the question is what constraints are on the packages it names
08:18:53 <ocramz> hi there! how does the RULES pragma work? e.g. in {-# RULES "scale.solve/ssolve"   ; forall k a y. a <\>  (k *> y) = ssolve k a y  -#}
08:20:13 <epta> geekosaur: isn't --constraint flag suppose to override them?
08:20:40 <geekosaur> putting a constraint on zlib won't magically force another package to not require a different zlib version, unless that other package's constraints allow a compatible one to be selected. so if streaming-commons is only available in a version requiring a newer zlib, or sopmethingh else is depending explicitly on that version that needs a newer zlib, all you have done is ensure the package won't configure
08:21:16 <jacereda> what does ".\" at the end of a function mean in a .prof report?
08:21:44 <geekosaur> jacereda, an anonymous lambda within that function
08:21:50 <jacereda> geekosaur: great, thanks
08:22:12 <aweinstock> ocramz: I think that "/" in the name "scale.solve/ssolve" is to be read as "replace" (i.e. "replace scale.solve with ssolve")
08:23:14 <aweinstock> ocramz: I'm guessing that (<\>) is solve and (*>) is scale, in this context, which would mean that the pragma is replacing the lefthand of the equals with the righthand
08:23:44 <ocramz> aweinstock: yes it's from the BLAS bindings
08:23:47 <aweinstock> (presumably ssolve is optimized and uses fewer operations than scaling and solving seperately)
08:23:48 <ocramz> thanks
08:24:16 <aweinstock> ocramz: for more detail, this looks like the relevant documentation: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
08:24:50 <ocramz> aweinstock: but making sure that rhs == lhs is left to the user, I guess?
08:25:51 <aweinstock> ocramz: yes, the rules pragma is manually specifying optimizations that GHC wouldn't be able to devise on it's own
08:26:31 <ocramz> aweinstock: such as functional equivalence. Makes sense
08:26:39 <aweinstock> so if you specify something that changes the meaning, and GHC applys the rule, it'll change the meaning of the expression
08:26:58 <ocramz> quite dangerous, per se
08:28:55 <aweinstock> ocramz: http://lpaste.net/136238
08:29:20 <ocramz> aweinstock: ^_^
08:30:56 <jellie> Can a file descriptor be any int?
08:33:19 <exio4> osa1_: ping? I am working with your lua bindings and I wonder if there's any reason there aren't instances of StackValue for (StackValue a, StackValue b) => Either a b and/or (StackValue a) => Maybe a ? (I am sure it's about the `valuetype` function, but whatever)
08:33:51 <exio4> unless they aren't yours bindings :P 
08:35:13 <aweinstock> jellie: they're typically small positive integers, but you shouldn't be doing arithmetic to them (unless it's for an obfuscated code contest or something)
08:35:43 <jellie> aweinstock: No because I thought that a file descriptor had to be a 0 and 1.
08:36:36 <aweinstock> 0 is stdin, 1 is stdout, and 2 is stderr, and subsequent numbers are allocated by things like open(2)
08:36:42 <geekosaur> file descriptor can be whatever the OS says it is
08:36:44 <jellie> aweinstock: So the OS somehow decides that this file descriptor means stdin and another means stdout. and this changes how often?
08:36:46 <keko_> if it could only be 0 or 1, you could only have two files open
08:36:53 <aweinstock> (at least on POSIX)
08:36:59 <geekosaur> 0, 1, and 2 are typically predefined on POSIX and on Windows
08:37:36 <jellie> keko_: What do you mean?
08:37:42 <edk> jellie, stdin and stdout and stderr will almost certainly never change value as long as file descriptors exist
08:37:47 <geekosaur> exactly what they said
08:38:02 <jellie> edk: but when do they change value?
08:38:09 <geekosaur> ???
08:38:11 <edk> how do you mean, when?
08:38:16 <aweinstock> jellie: you can reassign them with calls like dup2
08:38:20 <jellie> and won't that confuse the programmer
08:38:21 <geekosaur> do you understand what a file descriptor is?
08:38:24 <jellie> or the OS
08:38:26 <jellie> something
08:39:24 <jellie> geekosaur: I read that it is a value that is a handle to a file. It tells the OS which "state" a file currently is in.
08:39:38 <jellie> :s/read/understood/
08:39:58 <jellie> The current state that the file is in according to the OS in terms of read or write.
08:40:00 <geekosaur> when you open a file, the kernel gives you a file descriptor
08:40:11 <geekosaur> all operations between user and kernel space use that file descriptor
08:40:15 <aweinstock> jellie: file descriptors are identifiers that refer to open files/sockets/devices, on a per-process basis
08:40:52 <aweinstock> when a program starts, stdin is assigned to 0, stdout to 1, and stderr to 2
08:40:59 <jellie> geekosaur: We pass around the file descriptor and the file? 
08:41:07 <geekosaur> "and" the file?
08:41:31 <jellie> geekosaur: During operations between kernel and user space.
08:41:53 <geekosaur> here is an example of an operation using a file descriptor: write(fd, buffer, size)
08:42:23 <jellie> geekosaur: size is the size of what exactly?
08:42:26 <dfranke> Is anyone aware of any research on using types to statically verify that a change to relational (or perhaps entity-relationship) database maintains uniqueness and foreign key constraints? (edwardk?)
08:42:50 <geekosaur> it is however much data is in the buffer. this interface is not typed; "buffer' does not know its size or its contents
08:42:59 * hackagebot hpack 0.5.2 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.5.2 (SimonHengel)
08:42:59 <geekosaur> so you must supply a size separately
08:43:20 <aweinstock> jellie: the command `man 2 write` brings up documentation for the "write" syscall
08:43:38 <geekosaur> the low level interface between the kernel and a user process is not intelligent
08:43:55 <aweinstock> write(fd, buffer, size) writes size bytes from buffer to the file referred to by fd
08:43:56 <geekosaur> which is why languages always implement things on top of it such as Handles or C's (FILE *)
08:44:14 <geekosaur> you provide a memory address and a number of bytes
08:44:21 <geekosaur> it knows nothing about what is at that address
08:44:24 <aweinstock> (e.g. write(1, "hello\n", 6) would write the 6 bytes "hello\n" to file descriptor 1, which is stdout)
08:46:21 <jellie> If the data in the buffer is more than the specified size there will be an error, right?
08:46:30 <mauke{> no
08:46:32 <geekosaur> ???
08:46:38 <geekosaur> it does not know anything about that
08:46:57 <jellie> So it'll just read the first size bytes from the buffer
08:47:02 <mauke{> the kernel is not concerned with your puny variables and data structures
08:47:07 <geekosaur> buffer is a raw memory address
08:47:08 <aweinstock> jellie: write(1, "hello, world!", 5) just writes "hello" to stdout
08:47:41 <geekosaur> the only thing that can go wrong there is that (buffer + size) extends into memory addresses that are not allocated in your process
08:47:48 <aweinstock> write(1, "hello, world!", 65535) might do something dangerous
08:47:56 <jellie> I see
08:47:59 <geekosaur> otherwise, it knows it has a memory address and a size, and nothing else
08:47:59 * hackagebot hakyll-R 0.1.0.2 - A module allowing to write Hakyll blog posts in Rmd  http://hackage.haskell.org/package/hakyll-R-0.1.0.2 (CorentinDupont)
08:48:23 <jellie> I though a file descriptor changes from file to file.
08:48:40 <geekosaur> each open() call returns a distinct file descriptor
08:48:42 <jellie> So it's just the kernel representation of stdin stdout and stderr
08:48:48 <geekosaur> ...
08:48:54 <jellie> Oh boy
08:49:16 <jellie> geekosaur: So say I call open on a file, right?
08:49:28 <geekosaur> yes, it returns a new file descriptor
08:49:32 <jellie> geekosaur: What will I pass to open that will represent the file?
08:49:49 <geekosaur> if you open() the same file twice, you get two independent file descriptors (and it's your problem to make sure they don't conflict)
08:49:49 <mauke{> a string / filename
08:50:20 <mauke{> also, the kernel doesn't care about stdin/stdout/stderr
08:50:23 <mauke{> those are just conventions
08:50:29 <jellie> geekosaur: and I assume I have to pass a param to open so it knows whether I want to read to or write to the file, right?
08:50:37 <aweinstock> int fd = open("/tmp/hello.txt", O_CREAT); // will return a filedescriptor pointing to the newly created file "/tmp/hello.txt", which is probably 3, but i'd be bad practice to write code that depends on that
08:50:38 <mauke{> yes, or both
08:50:39 <geekosaur> (or both)
08:50:44 <aweinstock> s/i'd/it'd/
08:51:04 <mauke{> there are three major modes, O_RDONLY, O_WRONLY, and O_RDWR
08:51:13 <mauke{> plus some extra flags (like O_CREAT)
08:51:44 <mauke{> so aweinstock's line is technically invalid
08:52:01 <aweinstock> s/O_CREAT/O_WRONLY | O_CREATE/
08:52:09 <geekosaur> also it's missing the permissions to assign to the newly created file
08:52:17 <mauke{> yeah
08:52:22 <aweinstock> oops
08:53:55 <nicocbg> hi, i dont quite understand the error I get : (The package 'gloss-examples' requires Cabal library version
08:53:56 <nicocbg> 1.18.1.5 but no suitable version is installed.)
08:54:04 <nicocbg> https://gist.github.com/nrolland/9f28b91f19162b8d13ed
08:54:47 <nicocbg> the cabal file of gloss-examples does requires only cabala-library >= 1.10 
08:54:58 <nicocbg> and I have 1.18.1.4 installed (haskell platform)
08:55:34 <ttt_fff> am I going blind, or is "ti_lookup_var" easier to read than "tiLookupVar" ?
08:56:04 <nicocbg> as shown in the gist, while *cabal install* says the configure step failed, running *cabal configure* actually succeeds..
08:56:05 <aweinstock> jellie: int fd = open("/tmp/hello.txt", O_WRONLY | O_CREAT, 0666); write(fd, "hello\n", 6); close(fd); // I think this is correct
08:56:33 <geekosaur> aweinstock, correct modulo error checking (there is no actual guarantee that you can create that file...)
08:56:35 <jellie> aweinstock: Thanks
08:56:43 <jellie> I think that clears a few things up
08:56:44 <dcoutts> nicocbg: this is fixed in cabal head, but the workaround is to install a suitable version of the Cabal lib.
08:57:05 <nicocbg> ok thks good to know
08:57:08 <dcoutts> nicocbg: or another workaround is to use -j1
08:57:23 <geekosaur> ttt_fff, it seems to be a personal preference thing, sadly. a lot of people think camelcase is easier to read, I've always found the underscore one easier
08:57:49 <geekosaur> afterAllWeDon'tAllWriteSentencesLikeThis
08:57:51 <jellie> The kernel doesn't care about std* but it cares about the modes the file is in so it technically cares, am I right?
08:57:53 <aweinstock> jellie: also: char tmp[64]; read(0, tmp, 128); // is almost certainly a security vulnerability
08:57:57 <ttt_fff> geekosaur: IfCamelCaseWasBetterWhyDoPeopleUseSpaceAtAllAndNotTypeLikeThis?
08:57:59 <ttt_fff> :-D
08:58:16 <jellie> aweinstock: Because it will read beyond allocated memory?
08:58:24 <dcoutts> ttt_fff: the romans wrote like that (sometimes, in stone iirc)
08:58:35 <nicocbg> dcoutts : thank you i will read more about similar options
08:58:45 <aweinstock> "read" reads from a file descriptor into a buffer, "write" writes a buffer to a file descriptor
08:58:54 <jellie> ttt_fff: What? Where is this argument coming from?
08:59:01 <ttt_fff> dcoutts: Well,TheRomansAlsoHadAScrewedUpNumericSystemWhichMadeMultiplicationReallyReallyHard.IWouldNotTakeTheirAdviceForEasyOnTheEyes.
08:59:09 <dcoutts> :-)
08:59:26 <maerwald> ttt_fff: the argument for haskell was always, that a whitespace has kind of special meaning compared to other languages and that an underscore might increase the chance you misread things
08:59:28 <geekosaur> jellie, read/write mode is not the only thing that distinguishes between standard input/output and other files you might have open
08:59:38 <ttt_fff> jellie: ThisIsADebateAboutWhetherCamelCaseOr _using_underscores_makes_code_easier_to_read
08:59:40 <aweinstock> the above line is dangerous because it writes user input past the end of the buffer (which, if the buffer is stack-allocated, probably contains a return address)
08:59:48 <geekosaur> the point of standard input/output is that there needs to be some convention for communicating with a program
09:00:09 <geekosaur> if it wants to prompt for input, which file descriptor does it use? if it wants to output an error message, which file descriptor does it use?
09:00:17 <ttt_fff> okay, gentlemen, I have convinced myself I like underscores
09:00:20 <ttt_fff> sorry for the spam, tahnks for tolerating me
09:00:30 <ttt_fff> s/gentlemen/ladies and gentlemen/g
09:00:33 <jellie> ttt_fff: spaces mean something in haskell. So it's much easier to distinguish curried functions and a single function name for example.
09:00:38 <geekosaur> the *kernel* does not care; this is all behavior at a level above the kernel. but users need to know, so there are conventions at the library and program level
09:00:40 <aweinstock> jellie: the classic paper "Smashing the stack for fun and profit": http://insecure.org/stf/smashstack.html
09:01:18 <jellie> Well geekosaur aweinstock This is what I was reading. I will reread and ask questions if I don't get it. http://beej.us/guide/bgipc/output/html/multipage/pipes.html
09:01:21 <geekosaur> if I am using a program as a filter, I feed it input on its file descriptor 0 and get the output on file descriptor 1; any errors are written to file descriptor 2.
09:01:26 <jellie> I wish there was one using haskell
09:01:35 <geekosaur> otherwise I would have to somehow tell the program which of its file descriptors to use for which purpose
09:01:57 <geekosaur> so we have conventions
09:02:17 <aweinstock> @hackage System.Posix
09:02:17 <lambdabot> http://hackage.haskell.org/package/System.Posix
09:02:38 <geekosaur> the program may itself open other files, which will have other file descriptors; or create or accept network connections, which will have other file descriptors
09:02:49 <aweinstock> does lambdabot have a way to find packages by their module name?
09:03:05 <geekosaur> it's all in the same "namespace" (the namespace of file descriptors)
09:03:11 <geekosaur> @hoogle module Data.Text
09:03:12 <lambdabot> No results found
09:03:20 <geekosaur> bah
09:03:24 <aweinstock> @hoogle System.Posix
09:03:24 <lambdabot> System.FilePath.Posix module System.FilePath.Posix
09:03:24 <lambdabot> System.Posix module System.Posix
09:03:24 <lambdabot> System.Posix.Unistd PosixVersion :: SysVar
09:04:21 <ttt_fff> jellie: wait wait wait
09:04:35 <jellie> I didn't know that I was doing stuff that close to the kernel.
09:04:39 <ttt_fff> your argument is: in haskell style, the importance thing is *separating func names* and NOT *separting out words of a func name*
09:04:48 <ttt_fff> and thus, camelCase is better than underscore_names
09:05:09 <maerwald> ttt_fff: f x c and f_x_c
09:05:09 <ttt_fff> since camelCase makes it easier to separate out the different funcs/names, whereas underscore_name focuses on separating out words within a single 'atomic unit' 
09:05:11 <ttt_fff> is that correct?
09:05:22 <ttt_fff> f x c vs 'f_x_c" aren't related
09:05:24 <jellie> ttt_fff: Uh yes because of what maerwald said
09:05:30 <ttt_fff> ah
09:05:31 <srhb> ttt_fff: It is at least an argument.
09:05:37 <ChristianS> ttt_fff: actually the best way is to stick to the conventions of the programming language you're using. in case of haskell, it happens to be camelCase.
09:05:49 <ttt_fff> maerwald: what is your argument? that "f x c" and "f_x_c" are hard to separate 
09:05:55 <jellie> It's easier to skim over the code.
09:05:58 <jellie> ttt_fff: Yes
09:05:59 <maerwald> right
09:06:05 <jellie> When you've been reading code for hours
09:06:09 <maerwald> you might accidentially misread some stuff
09:06:11 <ttt_fff> ChristianS: well, I'm a unique snowflake
09:06:17 <ttt_fff> maerwald , jellie: okay, I buy this argument
09:06:22 <ttt_fff> I'm sold
09:06:23 <ttt_fff> thanks
09:06:23 <jellie> ttt_fff: :D
09:06:32 <jellie> I won an argument on the internet.
09:06:42 <jellie> It wasn't really an argument since haskellers are so nice.
09:06:46 <jellie> but still
09:06:51 <jellie> \o/
09:06:53 <jellie> haha
09:06:55 <maerwald> O.o
09:07:16 <maerwald> :t O.o
09:07:17 <lambdabot> Not in scope: ‘O.o’
09:07:23 <geekosaur> it matters when it's hard for me to distinguish someFunctionThatDoesAThing from someFunctionThatDoesBThing
09:07:33 <ttt_fff> jellie: go buy lottery tickets // this is not financial advice, not responsbile for financial loss
09:07:50 <maerwald> I have an idea... let's use smileys for lenses. Maybe that makes things prettier
09:08:36 <jellie> geekosaur: I've never actually encountered function names that differed by one or two letters.
09:08:43 <mauke{> some-function-that-does-a-thing
09:08:44 <ttt_fff> I have a better idea; ghc type errors should have pictures of puppies and kittens in the background
09:08:48 <jellie> most are e.g getSource getData etc.
09:08:57 <geekosaur> it does happen, sadly
09:09:01 <mauke{> strspn, strcspn
09:09:18 <maerwald> well, actually "^._2._1" almost is a smiley
09:09:18 <geekosaur> I'd like to say that experienced programmers avoid that, but 'tain't always true :/
09:09:34 <mauke{> malloc, calloc, realloc
09:10:00 <mauke{> fmap, map, ap
09:10:08 <mauke{> mapM_, mapM, map
09:10:49 <maerwald> mauke{: are you making a point or just typing in functions?
09:11:01 <mauke{> <jellie> geekosaur: I've never actually encountered function names that differed by one or two letters.
09:11:10 <mauke{> now you have :-)
09:11:12 <jellie> lol
09:11:19 <geekosaur> strtoi, strtod, strtol
09:11:21 <mauke{> (examples taken from C and Haskell)
09:11:27 <jellie> That's not haskell
09:11:39 <geekosaur> there are worse ones in the C standard library where the difference is hidden somewhere in the middle
09:11:45 <mauke{> geekosaur: strtoi doesn't exist, fortunately
09:11:45 <jellie> oh the map ones
09:11:50 <ttt_fff> whoa, camercale my code already looks better
09:13:15 <mauke{> get/set/put technically qualify
09:13:27 <favetelinguis> is it ok to have an exposed modules part in a executable cabal file?
09:13:39 <Profpatsch> Considering the record field problem:
09:13:39 <maerwald> mauke{: argh, plz don't remind me of java
09:13:50 <maerwald> getFoo, setFoo
09:13:55 <ttt_fff> in haskell convention, should varaible names (not func names) also be acmelcase, or should they have underscores?
09:13:56 <maerwald> all over the place
09:14:00 <Profpatsch> If I have data Foo = Foo { bar :: X, baz :: Y }
09:14:16 <Profpatsch> Why not simple make it possible to access them as Foo.bar and foo.baz?
09:14:20 <favetelinguis> i find this only in library cabal but i want it so i can load mudules when i cabal repl
09:14:27 <Profpatsch> *Foo.baz
09:14:32 <jellie> Everything is camelCase
09:14:49 <Profpatsch> Or even Foo/bar and Foo/baz if one so desires.
09:14:59 <mauke{> maerwald: getMVar, putMVar?
09:15:19 <geekosaur> Profpatsch, https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
09:15:25 <maerwald> mauke{: I think such abbreviations are ok if the functions is really widely used, but I've seen people doing that regardless of the use pattern. fF, tF and sC... guess the meaning
09:15:49 <maerwald> so when it's something really special, I'd avoid abbreviations
09:15:52 <Profpatsch> geekosaur: I knew I couldn’t be the first.
09:15:55 <mauke{> what abbreviations?
09:16:05 <geekosaur> with respect to (.), it's already so overloaded and this usage would be effectively the reverse of its normal usage with few ways to distinguish whether you meant application or field lookup
09:16:33 <geekosaur> and the type errors you would get if it guessed wrong would be insane
09:16:43 <maerwald> mauke{: err, you don't consider "ap" an abbreviation?
09:16:54 <mauke{> oh, that
09:17:00 <Profpatsch> geekosaur: I know, that’s why I thought of / as e.g. Clojure does it.
09:17:09 <Profpatsch> If I remember right.
09:17:21 <Profpatsch> Or use :: :P
09:17:23 <mauke{> data Foo = Foo { foo_bar :: X, foo_baz :: Y } ?
09:17:29 <mauke{> no language extension required
09:18:04 <Profpatsch> Maybe that whole problem boils down to modules in the end.
09:18:15 <mauke{> (also, why has it taken me this long to figure out write() on a read-only fd returns EBADF?)
09:18:27 <Profpatsch> Because it’s already possible to do Module.function
09:19:01 <Profpatsch> mauke{: In my opinion all boilerplate indicates a design problem.
09:19:26 <Profpatsch> That’s why I don’t like languages where you need a snipped system in your editor.
09:19:30 <jellie> geekosaur: aweinstock In this code http://lpaste.net/3533785295990292480 how does L21 know what `buf` is? I don't see how `buf` an array of chars was written to without us explicitly doing so.
09:19:32 <Profpatsch> *snippet
09:19:37 <Profpatsch> I can’t write today.
09:23:17 <geekosaur> jellie, it doesn't know
09:24:16 <geekosaur> you are calling read, which takes a memory address (which C happens to know is a (char *), but the read syscall doesn't) and a size to read, and copies that many bytes from the data source identified by the file descriptor (here, a pipe) into buf
09:24:59 <geekosaur> file descriptors work in terms of bytes, and they don't know anything about what those bytes might mean
09:28:39 <aweinstock> jellie: before the read on line 21 executes, buf is uninitialized data on the stack. a pointer to buf is passed to read, which populates it with 5 bytes read from the pipe
09:29:55 <aweinstock> jellie: (also, in case you don't already know this about C, "test" is shorthand for {'t','e','s','t','\0'}, the 5th byte is the null-terminator)
09:31:19 <jellie> So buf is automatically populated with 5 bytes from the pipe?
09:31:33 <jellie> Where is this done?
09:31:53 <jellie> Oh when we call read
09:32:07 <aweinstock> not automatically, the "read" function reads 5 bytes from pfds[0] (one end of the pipe), and stores it into buf
09:32:24 <jellie> Ah it's copied from the read end of the pipe into buf
09:32:33 <jellie> I see
09:32:42 <lpaste> chpatrick pasted “Embedding the Java typesystem in Haskell” at http://lpaste.net/136240
09:32:45 <aweinstock> "read" and "write" are named based on what they do to the file descriptor, they do the opposite to the buffer
09:32:48 <chpatrick> is this cool or what
09:33:59 <ttk> Hi guys. I have downloaded the haskell platform (WINDOWS), but it is using the wrong location for cabal packages. Anyone know how to change that?
09:34:03 <mauke{> INTERCAL has a READ OUT command that "reads out" the value of a variable to the screen
09:34:20 <mauke{> and a WRITE IN command that writes user input to variables
09:34:33 <bitemyapp> ttk: wrong location?
09:35:05 <aweinstock> chpatrick: does that actually work with calling java from haskell? or is it a more theoretical thing?
09:35:09 <ttk> bitemyapp:it uses it's own directory, but cabal by default uses %appdata%\roaming
09:35:27 <ttk> I would like to use %appdata%\roaming when using haskell platform
09:35:45 <chpatrick> aweinstock: I was just trying to see if I can represent the java type system
09:35:47 <chpatrick> I think it works
09:35:57 <aweinstock> mauke{: INTERCAL is the language famous for "come from" statements, right?
09:36:03 <chpatrick> I could write a binding generator that uses these types
09:36:08 <chpatrick> then next step haskell on android :)
09:37:07 <aweinstock> chpatrick: there's already a JVM haskell, as a possible alternate approach: https://github.com/Frege/frege
09:38:01 * hackagebot yesod-static-angular 0.1.6 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.6 (JohnLenz)
09:38:06 <chpatrick> a lot of people use scala and closure and stuff though just because they have a lot of existing java stuff
09:38:19 <chpatrick> it'd be pretty sweet if you could use full blown haskell
09:38:21 <renzhi> is there a cabal repository in China? Doing cabal update takes days, and gets timeout all the time from Shanghai :(
09:38:36 <ttk> bitemyapp any ideas?
09:38:58 <geekosaur> ttk, it's generally a bad idea to mix packages provided by an installer with packages installed manually (e.g. by cabal install)
09:39:01 <bitemyapp> ttk: no, I haven't run into anybody that cared about this before
09:39:30 <geekosaur> you *can* do it, but if you start running into conflicting package versions then your only option is wipe all the haskell stuff and reinstall
09:39:36 <geekosaur> cabal install --global
09:39:45 <aweinstock> chpatrick: https://github.com/Frege/frege/wiki/Differences-between-Frege-and-Haskell
09:39:47 <geekosaur> soon you will learn why we don't do this
09:39:50 <ttk> geekosaur: the cabal provided with haskell platform installs it to %appdata%, but the ghci provided with haskell platform uses a different location
09:40:09 <ttk> I am just trying to have ONE place for my packages
09:40:27 <geekosaur> [09 16:39] <geekosaur> you *can* do it, but if you start running into conflicting package versions then your only option is wipe all the haskell stuff and reinstall
09:40:34 <chpatrick> aweinstock: well there you go
09:40:36 <geekosaur> really, don't do that
09:41:27 <geekosaur> if anything, we are tending in the other direction, installing stuff in individual sandboxes so they don't conflict
09:42:55 <ttk> geekosaur how should I install new packages then? my cabal installs to %appdata%, but ghci uses a diffferent location.. Should  I install them and move them manually?
09:43:16 <geekosaur> ghci should be looking in *two* places
09:43:20 <geekosaur> ghc-pkg list
09:43:41 <geekosaur> should show packages in the system package directory and packages in the user package directory
09:43:49 <Profpatsch> geekosaur: I think the TDNR proposal is not a good idea.
09:44:16 <Profpatsch> It looks great at first, but there seem to be a lot of exceptions.
09:44:41 <Profpatsch> I don’t want Haskell to become Scala. :P
09:45:29 <ttk> it shows 2 places, none of them where cabal install packages to
09:46:00 <ttk> the ghc-pkg helped me to continue my search :) Thnaks
09:46:50 <geekosaur> if cabal is not installing packages to those places then you probably have a cabal config file hanging around somewhere from some earlier install
09:46:58 <geekosaur> unfortunately, I don't know where that would be on Windows
09:47:14 <geekosaur> (or even a cabal.exe compiled with different defaults)
09:51:59 <dmj`> so.... there's really no way possible to derive instances of classes that contain associated types? 
09:52:26 <dmj`> this would be super helpful
09:53:43 <ajg_> is there a concept/class for a Monoid (mempty, mappend) plus a way to put things in it (e.g. return or pure) but without the bind/fail (i.e. Monad)?
09:54:44 <ttk> geekosaur: do you know how I can configure ghc-pkg where to look?
09:56:17 <dmj`> ajg_: you're probably looking for Alternative, you can put things into it with 'pure' since its superclass is Applicative. empty is like mempty, (<|>) is mappend, but it's not a monad
09:57:41 <geekosaur> sounds to me like they want a notional ApplicativePlus
09:58:02 * hackagebot darcs 2.10.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.10.1 (GuillaumeHoffmann)
09:58:04 * hackagebot rdf4h 1.3.1 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.3.1 (RobStewart)
09:58:43 <ajg_> dmj`: thanks, that's a good lead
10:01:26 <dmj`> geekosaur: why can't I derive instances of classes that have associated types, esp. if the newtype I'm using is wrapping a type that is an instance of an class w/ assoc. types
10:02:18 <geekosaur> I think you're going to have to ask someone else :(
10:02:20 <dmj`> suppose I have newtype Foo = Foo VUUID deriving (Show, DynVal), where VUUID is an instance of DynVal, and DynVal is a class w/ an associated type
10:02:42 <geekosaur> associated types are not something I'm very familiar with
10:02:47 <dmj`> I mean, there's only one instance possible to use there
10:02:51 <dmj`> ok
10:09:16 <orion> If you're working within a Monad transformer stack supplied by a library and they define their own instance of liftIO which automatically catches exceptions, is it possible to perform IO actions from within that Monad, but in such a way where you skip their error handler?
10:10:07 <phaazon> salut
10:10:09 <phaazon> hi
10:10:10 <phaazon> sorry :D
10:19:50 <dmj`> orion: if that monad is an instance of MonadIO, yea
10:23:35 <orion> dmj`: https://hackage.haskell.org/package/scotty-0.10.1/docs/src/Web-Scotty-Internal-Types.html#line-152
10:23:36 <zovt> guys lenses are blowing my mind
10:23:47 <orion> instance (MonadIO m, ScottyError e) => MonadIO (ActionT e m) where ...
10:24:29 <orion> The issue I have is that Scotty's error handling is not sufficient for my purposes, and I want to ditch it completely and rely on WAI/Warp's exception handling instead.
10:25:22 <ttk> Hi guys - anyone knows how to install packages with haskell platform on windows? Should I download them manually and use ghc-pkg?
10:25:43 <dmj`> orion: yea imposing error handling is convenient, but probably not one size fits all
10:25:55 <dmj`> orion: you could newtype ActionT but that probably wouldn't be worth it
10:26:19 <dmj`> ttk: cabal-install works on windows
10:26:57 <ttk> dmj`: that install to %appdata%\roaming\cabal - but ghc-pkg uses <haskellplatformpath>
10:26:58 <dmj`> orion: you can insert your own error handling before theirs is run
10:28:03 * hackagebot linearscan 0.7.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.7.0 (JohnWiegley)
10:28:07 <dmj`> ttk: you should be using sandboxes anyways, but you can probably change that path from your global cabal.config
10:28:39 <orion> dmj`: If I throw an exception from within ActionT, currently I get the desired behavior. It's only when the exception is thrown within liftIO that problems happen.
10:28:39 <ttk> thanks
10:29:15 <orion> I achieved this by using setOnException and setOnExceptionResponse as part of Warp's settings.
10:30:53 <dmj`> orion: using exceptions as application control flow behavior probably isn't the best idea. I never throw exceptions, just catch them, then return them purely.
10:32:02 <dmj`> orion: the fact of the matter is that any I/O action can raise an async exception at any time (along with synchronous exceptions too). I'd check out enclosed-exceptions. 
10:32:28 <johnw> dmj`: they can be raised at any time by the OS, even
10:32:38 <sebboh> You know, I have a lot of trouble building haskell programs.  So much that I would have given up a while ago if not for the fact that there are some really cool programs out there that happen to be built in haskell... Anyway, here's my question: What operating system and/or distribution do most haskellers use?
10:32:57 <lamefun> Can memory outages be dealt with in Haskell (ie. a program waits for memory to become available or frees some non-essential data)?
10:32:58 <johnw> sebboh: I use OS X with the Nix package manager
10:33:04 * hackagebot linearscan-hoopl 0.7.0 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.7.0 (JohnWiegley)
10:33:36 <Hi-Angel> sebboh, Kubuntu here
10:33:38 <dmj`> sebboh: I second johnw's recommendation, osx and stack might be easier to get started with if you're new though
10:33:47 <orion> dmj`: There are times when throwing exceptions makes sense.
10:34:12 <Ralith> I use NixOS, but wouldn't recommend it to a novice
10:34:22 <mada> sebboh: Arch linux with only a few packages handled by pacman (xmonad and some deps) and the rest through cabal sandboxes.
10:34:28 <orion> dmj`: For example, what if I'm connected to a RabbitMQ server and the connection dies?
10:35:40 <dmj`> orion: Then the thread that manages that rabbitmq connection will be thrown an async exception. You'll want an exception handling library that properly masks it (turns it from async to sync), and allows you to clean it up. You shouldn't be rethrowing it though
10:36:10 <sebboh> Who said anything about novice? ;)  My problem is that Debian clearly doesn't believe in the haskell/cabal way of doing things and vice versa.  I had similar problems in Arch.  Though, mada, I used xmonad-git.
10:37:28 <dmj`> orion: catch it, log it, then return Left to your monad stack if you're in an EitherT or ExceptT. No need to throw though. 
10:37:58 <orion> dmj`: If exceptions should never be used, why does Haskell support them?
10:38:12 <johnw> orion: exceptions still need to be dealt with
10:38:47 <dmj`> orion: because exceptions are a reality of life, just the nature of dealing with I/O. 
10:39:28 <sebboh> Is it common that haskellers will use their computer for haskell and little else?  ..I'm just trying to figure out what I'm missing here.  If I didn't *know* that people are doing interesting, productive things in haskell, because of all those articulate blogs out there, I'd assume that haskell is a low quality product, based on my own experience with it.  Thus my question re: OS/distro.  I did note that nobody answered 'debian'. :/
10:40:19 <Hi-Angel> sebboh, I answered Kubuntu, you may consider it as a Debian ☺
10:40:31 <johnw> sebboh: um, your sample group is incredibly small right now
10:40:31 <warbo> sebboh: I was a happy Debian + Haskell user for years; switched to NixOS last year though
10:40:36 <glguy> sebboh: Active developers with Haskell typically don't bother with the libraries packaged by their OS distributions, they manage things using cabal directly
10:41:35 <creichert> i use debian
10:41:42 <warbo> sebboh: My advice would be, use Haskell applications from dpkg/apt (eg. pandoc), but anything you plan on compiling/developing should come from cabal
10:41:51 <creichert> When actively developing packages, i use cabal/hackage/stackage
10:42:17 <johnw> glguy: I haven't used cabal in over a year
10:43:12 <glguy> johnw: Well, that's certainly not the common case
10:43:40 <dmj`> johnw: not even nix-shell --command 'cabal configure' ?
10:43:46 <johnw> nope
10:43:48 <aweinstock> sebboh: I use debian
10:43:53 <johnw> that's not how you do it in haskell-ng anymore
10:44:09 <johnw> nix-shell --command --pure 'ghc --make Setup; ./Setup configure'
10:44:35 <dmj`> hmmm :) 
10:44:36 <dmj`> cool
10:45:41 <Cale> sebboh: I use Linux Mint, but I don't use my distribution for any Haskell-related things. I use the generic Linux binary GHC, and I build my own cabal-install etc.
10:45:55 <Profpatsch> const 5 vs (\_ -> 5)
10:46:02 <sebboh> Hi-Angel: ah yes, you're right.  warbo: did you do it like glguy did?  Anyone: presently I'm encountering the same problem described here: http://git-annex.branchable.com/forum/build_from_source_on_Linux_fails___40__out_of_memory__41__/ .. and it sounds like one solution would be to use a newer cabal.  I *just* built this machine.  I just installed the latest GHC from debian sid (unstable). And some build dependencies recommended by the
10:46:02 <sebboh> git-annex author.  So, I'd be happy start again... Is there a correct way to run my entire haskell environment out of my home directory?  I mean, ~/bin/ghc (perhaps a symlink to some ~/src/foo/Build/ghc-2015.whatever), etc.
10:46:02 <Profpatsch> What do you prefer?
10:46:04 <warbo> johnw: what's the advantage? that you can use --pure to avoid having a global/user cabal?
10:46:04 <Cale> sebboh: btw, Haskell itself isn't a product, you might be referring to the Haskell compiler GHC?
10:46:22 <johnw> warbo: --pure just makes sure I'm using exactly the ghc+packages that I think I am
10:46:34 <sebboh> Cale, it's likely that I am. :)
10:47:35 <dmj`> johnw: what about running tests and benchmarks
10:47:44 <johnw> nix-shell --command --pure 'ghc --make Setup; ./Setup configure --enable-tests'
10:47:49 <warbo> johnw: does that mess up CPP, etc.?
10:47:57 <johnw> CPP?  no
10:48:08 <sebboh> Cale, and your setup sounds like what I am interested in.  Maybe.  I don't *really* want to grab some statically linked binary from whoknowswhere and put it in ~/bin... but neither do I think my system is physically capable of compiling ghc from scratch (or bootstrapped via the distro's ghc, or whatever.).
10:48:10 <johnw> Nix is smart enough to bring the compiler into scope if necessary
10:49:40 <dmj`> johnw: the derivation that cabal2nix produces doesn't mention benchmarks or tests though, at least in my *.nix file
10:49:41 <Cale> sebboh: Usually what I like to do is to get the generic linux binary as appropriate from https://www.haskell.org/ghc/download_ghc_7_10_1 and then grab the tarball of cabal-install from its page http://hackage.haskell.org/package/cabal-install on hackage: http://hackage.haskell.org/package/cabal-install-1.22.6.0/cabal-install-1.22.6.0.tar.gz
10:50:13 <johnw> dmj`: it's all implied by the cabal builder
10:50:16 <Cale> actually, there are a few more beneficial steps which could be inserted here, let me get you a link
10:50:17 <sebboh> Cale, I will look into that.  Thank you.
10:50:20 <dolio> sebboh: What kind of machine do you have? If you just built it, it'd be kind of surprising if it couldn't build GHC.
10:50:49 <sebboh> dolio, I have a machine that can't build haskell applications. ;)
10:51:12 <johnw> sebboh: we'll need more information than that to help
10:51:17 <Cale> hmm... where was that little guide :)
10:51:17 <sebboh> dolio: (but where does the hardware stop and the distro start? I do not know.)
10:51:25 <Cale> I think it was maybe ion's? :)
10:51:29 <Cale> ion: are you here?
10:51:32 <dmj`> johnw: but how would ghc --make know what the hs-source-dirs for my test executable is?
10:51:45 <ion> Cale: This? https://gist.github.com/ion1/2815423
10:51:46 <dolio> I mean bootstrapped from the distro GHC.
10:51:48 <johnw> dmj`: the Setup that is build links against the Cabal library
10:51:57 <johnw> which reads the foo.cabal that comes with the project
10:52:12 <Cale> ion: Yeah, that one is good :)
10:52:12 <johnw> I said *I* don't use cabal, not that Nix doesn't :)
10:52:16 <dmj`> johnw: ahh :) cool
10:52:16 <warbo> johnw: that's cheating ;)
10:52:19 <ion> Cale: stack might be a viable alternative now. I’m going to add that as an alternative at some point.
10:52:22 <ion> to the gist
10:52:38 <johnw> warbo: Nix uses the Cabal library as a builder, not as a package manager
10:52:58 <johnw> imagine maven, but not using any of the dependency resolution or downloading bits
10:53:04 <Cale> I actually don't usually install ghc to my home directory, but yeah, the other steps are important regardless :)
10:53:30 <dmj`> we still use Cabal just not cabal :)
10:53:39 <Cale> Especially details like EXTRA_CONFIGURE_OPTS=-p
10:53:54 <sebboh> ion: thanks! You too, Cale.
10:54:04 <lamefun> Haskell not a product? Isn't GHC Haskell == the Haskell?
10:54:19 <joncol> Hi, I've just started to use optparse-applicative, and I wanted to ask if there's a good way to select a specific alternative of an algebraic datatype (for instance: data Options = Plane | Point), instead of using a String, as I currently am doing. There's a gist available at https://gist.github.com/joncol/c147bc4d3a019591f15c, to make it a bit clearer...
10:54:21 <Cale> lamefun: Well, Haskell is just a language
10:54:45 <Cale> lamefun: GHC is the best implementation of that language right now
10:54:48 <bernalex> lamefun: GHC is a compiler that implements Haskell 2010 and various extensions.
10:55:18 <sebboh> lamefun: the same distinction applies to every other computer language that has a compiler, but only the haskellers noticed. O=)
10:55:21 <bernalex> Cale: that's an understatement. GHC is *the only* really viable option for production use. it has been for a while, and will likely continue to be for a long time.
10:55:29 <lamefun> Cale: so no programming language is a product (as it's possible to make an alternative compiler for any language)?
10:55:46 <Cale> lamefun: Right, languages are not products :)
10:55:52 <Cale> Implementations of them are
10:56:23 <johnw> bernalex: I know some people that would disagree with you
10:56:35 <Cale> (It's also a bit weird to refer to GHC as a product, for a different reason, but it's closer to being okay)
10:56:36 <warbo> some languages could be described as "whatever implementation X accepts", eg. Python with CPython throughout the 90s
10:56:37 <johnw> Standard Chartered has their own Haskell compiler, and they definitely use it in production
10:56:43 <bernalex> johnw: they don't use haskell
10:56:47 <lamefun> Cale: not even Apple Swift?
10:56:48 <bernalex> johnw: they have their own strict language based on haskell.
10:57:09 <warbo> Haskell has had a few implementations for a while though (eg. hugs)
10:57:12 <dmj`> bernalex: not ghc haskell, but still haskell
10:57:26 <dolio> No, it's not Haskell.
10:57:28 <sebboh> ok I'm gonna /part here for a while.
10:57:34 <bernalex> dmj`: do they call it haskell? I mean... it's strict... that's a big change for the standardised lazy language...
10:57:38 <dolio> It's just similar to Haskell.
10:57:47 <bernalex> I have not heard them call it haskell at least
10:58:00 <dmj`> bernalex: I think they call it Mu-haskell
10:58:05 <bernalex> in any event this is all a bit of a bikeshed, since it's proprietary and not available to the general public. :)
10:59:43 <joncol> nvm, think I figured it out using a Read instance...
11:03:13 <lamefun> I mean, if there's one strongly dominant implementation, I think it's justifiable to refer the (language + implementation) as a product until a viable alternative implementation is developed, even if in a colloquial sense.
11:04:28 <porglezomp> lamefun: I still think it's important to distinguish the language from the implementation, even in that sense.
11:05:37 <mmachenry> I believe Standard Chartered uses both real Haskell and their own strict dialect. I think that was mentioned on the Haskell Cast, wasn't it?
11:06:57 <mmachenry> porglezomp: Separating language from implementation is very important in understanding these things. But strict vs. lazy is not an implementation detail. It's part of the language in the same way as dynamic vs. static or call by name vs. call by value, etc. 
11:07:08 <dmj`> mmachenry: yea, they use real haskell to build their dialect, at least parts of it
11:07:53 <Hi-Angel> I have a conceptual question. I want to implement a function that works on a single element and the same function for a list of elements. Since here is no a function overloading, how am I supposed to deal with that? Btw, the single element version unlikely would ever be used except as in the second version.
11:08:14 <shachaf> Give them two different names.
11:08:24 <mmachenry> dmj`: I think they have developers implementing a lot of infrastructure in it as well. I believe the way it works is that Haskell developers use GHC Haskell to build the static Haskell as well as all of the stuff that that static Haskell is doing. Like talking to the network to make an automated trade is done in Haskell.
11:08:36 <warbo> lamefun: "until" doesn't really make sense; it's not that we're waiting for more implementations than GHC, it's that GHC kept adding features which the other implementations don't support
11:08:46 <dolio> dmj`: They don't use an in-house actual Haskell compiler to build the in-house strict variation, though, right? That'd be pretty weird.
11:09:02 <chpatrick> is there a really efficient mutable intmap/hashmap?
11:09:03 <warbo> lamefun: if we talk about Haskell 98, there's more than just GHC
11:09:09 <eds> Can somebody help me out on how I can define the functions in an instance of class  IsGenExp . I am having a hard time implementing it. Code: http://lpaste.net/132328 
11:09:14 <chpatrick> or is the best bet to pass around an unordered-containers one
11:10:21 <dmj`> dolio: yea, that's my understanding, that would be weird. 
11:10:24 <warbo> Hi-Angel: there is function overloading; that's what typeclasses are for :)
11:10:30 <lamefun> warbo: is any of the non-GHC implementation useful for real complex production programs?
11:12:27 <c_wraith> lambdabot: well, Mu is used by one of the big finance companies - but it's not open.
11:12:33 <dmj`> Think it depends on the team, the reporting guys use Mu, the strats guys seem to use ghc haskell. But I think the people on that team built parts of Mu using ghc haskell (at least the parser), mu has a virtual machine written in c++.
11:13:13 <Hi-Angel> lol
11:13:42 <porglezomp> mmachenry: I wasn't arguing that point, I know that to be Haskell it has to be strict.
11:13:44 <warbo> lamefun: depends on your definition of "useful" and "real complex production programs"
11:14:30 <warbo> lamefun: you'd need a really good reason to NOT use GHC, but if GHC didn't exist I'm sure there would be people getting along just fine with hugs or something
11:14:45 <dmj`> I think Mu has really nice visual studio integration. 
11:15:34 <maerwald> I'd be surprised if more than ~15% of the current widely used libraries compile under non-GHC compilers. But ofc that's probably not the fault of non-GHC compilers.
11:16:05 <Zemyla> maerwald: I assume containers is in that 15%?
11:16:21 <aweinstock> Hi-Angel: if you have "f" which operates on single elements, "map f" operates on lists of elements
11:17:10 <Hi-Angel> aweinstock, no, I thought about it  the function is unlikely would ever be used with a single element, so there's no reason to leave it to use map every time
11:17:10 <maerwald> Zemyla: I can't really say... I am just roughly basing this on the experience of the early days of clang when people realized how much code is actually compiler-dependant
11:17:41 <aweinstock> Hi-Angel: so use "map" in the definition of the function?
11:17:54 <maerwald> Zemyla: and then you have all those GHC pragmas which might or might not be implemented in alternative compilers
11:17:55 <Zemyla> Well, I know containers looks like it works hard to be relatively compiler-independent, with a shitton of conditional compilation.
11:18:41 <Hi-Angel> aweinstock, yes, but that is where I decided to ask  because then there would be two overloaded functions, where one would use the other. But the overloading was the problem
11:18:45 <maerwald> That's why I'm not a fan of compiler-extensions. Instead, they should extend the language.
11:19:25 <c_wraith> maerwald: how do you think the language should be extended without first proving the concept sound, implementable, and useful?
11:19:43 <warbo> Hi-Angel: if your list-version is the only thing that's going to use the element-version then you could make it local, using "let", "where" or (depending on the size of your project) explicit module exports
11:19:50 <lamefun> warbo: if GHC didn't exist but eg. Hugs took its place as the only dominant compiler, I'd still consider Haskell a de-facto product.
11:20:27 <aweinstock> Hi-Angel: can you be more specific about what it's doing?
11:20:54 <aweinstock> Hi-Angel: possible paste a draft of the code on lpaste.net?
11:20:58 <warbo> lamefun: it all depends on what you're using those words to mean
11:21:02 <Zemyla> Are AMP and FTP just compiler extensions, or will they actually change the Haskell specification?
11:21:03 <maerwald> c_wraith: that's not really what I said. I doubt most of the pragmas are even considered to be added to the language.
11:23:38 <dmj`> Zemyla: I don't think either, AMP didn't change what a typeclass is, just the definition of a typeclass
11:24:00 <Zemyla> Well, yes, but a conforming program before the change could be non-conforming after.
11:24:09 <ttk> God it is a hassle getting haskell to work on windows!
11:24:15 <Zemyla> (If it didn't define an Applicative instance for a Monad.)
11:24:44 <Hi-Angel> aweinstock, well, that's just a code for my student project about databases  I thought to implement a projection which would work for a row, and overload it to work with a list of rows (which is table). But I think I indeed would try to implement it with just where  without a separate function.
11:24:50 <Hi-Angel> Thank you.
11:25:04 <dmj`> Zemyla: yea, but that's not really a language change
11:25:43 <warbo> Hi-Angel: it's possible to overload input and output types like that, but not necessarily wise
11:26:07 <porglezomp> ttk: It's a hassle getting just about any programming language that's not sponsored by Microsoft to work on Windows
11:26:23 <ttk> I disagree :)
11:26:28 <warbo> Hi-Angel: you may end up having to write a lot of type annotations to disambiguate them; in which case you may as well have separate functions
11:27:19 <porglezomp> ttk: Doesn't the Haskell Platform have a windows version?
11:27:55 <Hi-Angel> warbo, why? It would be obvious where a function for a row, and where for a list of rows. Why would am I  write annotations?
11:27:57 <ttk> porglezomp: yes, but it comes packaged with a version of cabal that fails to update
11:28:06 * hackagebot heist 0.14.1.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.14.1.1 (DougBeardsley)
11:28:43 <ttk> I heard the 32 bit versions works though, but I want the 64
11:28:54 <maerwald> porglezomp: haskell is sponsored by microsoft, lol
11:29:18 <porglezomp> Well, perhaps Microsoft should get to work on compatibility
11:29:24 <porglezomp> haha
11:29:34 <ttk> perhaps someone in the community should make a good windows installer :)
11:33:04 <Zemyla> I think there should be a showFoldable method in Data.Foldable, which is showFoldable :: (Foldable t, Show a) => t a -> ShowS, and is equivalent to shows . toList but faster.
11:33:24 <warbo> Hi-Angel: you can get ambiguity when chaining function calls together, eg. (a silly example) `project (project "foo") :: Row`, where `project :: (Projectable a, Projectable b) => a -> b`.
11:33:25 <sm> ttk: have you tried stack ?
11:33:35 <ttk> sm stack? what is that?
11:33:42 <ttk> ohh stackoverflow?
11:33:53 <sm> no, https://github.com/commercialhaskell/stack/releases/
11:34:37 <Hi-Angel> Hm, interesting
11:34:44 <Zemyla> :t \l s -> '[':maybe (']':s) id (foldr (\a r -> Just $ shows a $ maybe (']':s) (',':) r) Nothing l)
11:34:46 <lambdabot> (Show a, Foldable t) => t a -> [Char] -> [Char]
11:34:52 <ttk> am no, never heard of that! thanks sm
11:35:12 <Zemyla> That would be faster than shows . toList, right?
11:36:54 <warbo> Hi-Angel: as a more realistic example, I've used `reString = (fromString . toString) :: (Stringable a, Stringable b) => a -> b` using the "stringable" package, and ran into that problem
11:38:06 * hackagebot wai-extra 3.0.8.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.8.2 (MichaelSnoyman)
11:38:22 <Zemyla> It even works for infinite lists, because the value returned by the function in foldr is always of the form Just _.
11:38:54 <Zemyla> It doesn't try to evaluate the previous value until that part of the list is desired.
11:39:09 <warbo> Hi-Angel: my intention was to avoid having to juggle conversions between Text, String, ByteString, etc. by instead running "reString" on all my inputs and reString on my output; but GHC just gets confused because it doesn't know what intermediate type to use :)
11:40:07 <Hi-Angel> warbo, thank you, that's an interesting case, indeed
11:40:29 <ChristianS> warbo: maybe the string-conversions package can help: https://hackage.haskell.org/package/string-conversions
11:43:24 <warbo> ChristianS: Thanks, I've bookmarked it :) reString is actually fine as long as a conversion is necessary; applying it to everything "just in case" is what causes problems
11:51:49 <sm> ttk: "stack setup" worked well here on windows 7 except you need to manually add the PATH dirs it shows
11:52:16 <ttk> sm : I installed everything manually, and I am very close to have it all working! :D
11:52:42 <sm> it's easy once you've done it a few times, nightmarish otherwise :)
11:53:35 <ttk> do you know how to remove a package.conf.d from ghc-pkg?
11:54:54 <sm> that is not something you should have to be thinking about at this stage..
11:55:33 <ttk> well I have two package repos, and I only want 1
11:56:35 <topo> ciao
11:56:39 <sm> it's standard for ghc-pkg to use two
11:56:51 <sm> you can override it with GHC_PACKAGE_PATH perhaps
11:57:02 <sm> but you're on your own
11:57:06 <topo> !list
11:57:06 <monochrom> topo: http://lpaste.net/browse
11:58:46 <ttk> ah ok
12:05:32 <ttk> sm I am just worried what happens if I have 2 of the same packages but with different versions in the different locations?
12:07:36 <sm> ttk it can handle that
12:07:44 <ttk> ah ok. Cool
12:08:01 <sm> it will pick just one to use when building something
12:14:48 <jfeltz> is there a pre-canned solution for doing IPC/RPC over file handles in haskell? I don't want to use the network, due to overkill for this case and security/practicality (i'ts to control a custom web-server)
12:18:25 <arw> there should be some implementation of a dbus api somewhere.
12:18:44 <favetelinguis> what am i missing in this code? https://gist.github.com/favetelinguis/23370f37ce55db90263e im still having a hard time understanding this type of errors :(
12:20:26 <sm> favetelinguis: it's a precedence problem. parenthesise line 4
12:20:48 <t7> Could not find module `Graphics.Gloss'  -> cabal install gloss -> All the requested packages are already installed:
12:21:01 <arw> jfeltz: oh, and if you like the option of adding real networking later on, try 0mq. there are haskell bindings and you can use ipc://tmp/somesocket as local transport.
12:21:03 <t7> can runghc do cabal sandbox?
12:21:13 <hexagoxel> how to write/read a vector of floats efficiently to/from file?
12:21:42 <jfeltz> arw: thanks
12:21:42 <int-e> t7: cabal exec runghc ...  may work
12:22:17 <int-e> t7: runghc by itself won't recognize a cabal sandbox, but cabal exec sets appropriate environment variables
12:22:33 <t7> int-e: perfect thankyou!
12:22:54 <favetelinguis> sm: thanks that works
12:28:51 <solidus-river> hey all, does stack still play nicely with hackage and hoogle?
12:31:16 <t7> gloss is broken on my distro :(
12:31:18 <t7> god damnit
12:31:50 <cow_2001> gus gus! i have a state type synonym `type MyState = TZ.TextZipper Text` but in practice i shove it into an `IORef MyState`. Should I just call `type MyState = IORef (TZ.TextZipper Text)`?
12:43:10 * hackagebot lucid-svg 0.5.0.0 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.5.0.0 (jeffreyrosenbluth)
12:43:12 * hackagebot hcltest 0.3.7 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.7 (BennoFuenfstueck)
12:52:08 <osa1_> exio4:  The problem is given a Lua value there's no easy way to determine what will be the corresponding Haskell value, without using valuetype. How would you test if a Lua value is supposed to be popped as Haskell Either a b or (a, b), for example? Not that it's impossible -- you can always write a function that runs arbitrary tests on Lua values and then pop using existing StackValue instances, you have all you need. It just doesn't 
12:52:09 <osa1_> make sense to add lots of instances because other than most basic ones they all need some conventions like how to push a Haskell `StackValue a, StackVlaue b => Either a b` to Lua etc.
12:52:29 <osa1_> exio4: feel free to send emails, I'm sometimes missing IRC messages.
12:55:00 <jfeltz> cow_2001: to me that's obfuscation, but it depends on frequency of use in your API
12:56:35 <cow_2001> jfeltz: should i just use `IORef (TZ.TextZipper Text)`?
12:56:40 <exio4> osa1_: ah, I see, thanks!
12:56:58 <albeit> I have a simple function that should take the same time to run each time, but the first iteration takes an order of magnitude longer to run. What's going on? The code is here http://lpaste.net/136249
13:00:11 <jfeltz> cow_2001: i would lean towards that, simply because I know in most cases I won't be able to grok those kind of type synonyms during maintenance several months later, i might even create a macro to handle the creation of that type
13:02:32 <cow_2001> jfeltz: a macro O_O
13:02:45 <cow_2001> jfeltz: how do you do that?
13:03:09 <jfeltz> cow_2001: as in an editor macro, e.g. http://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html
13:05:55 * cow_2001 googles for the vim equivalent of abbrevs
13:07:03 <SaidinWoT> cow_2001: They're also called abbreviations. http://vim.wikia.com/wiki/Using_abbreviations
13:07:06 <cow_2001> woah
13:07:12 <cow_2001> i've just used it
13:07:33 <cow_2001> amazing.
13:08:11 * hackagebot streams 3.2.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.2.1 (EdwardKmett)
13:30:50 <hexagoxel> anyone know how to fix import-statements lacking a newline when pretty-printing with hindent?
13:48:55 <yac> How does this work https://github.com/ekmett/keys/blob/master/src/Data/Key.hs#L82-L83 ?
13:50:00 <Tuplanolla> Just fine, thanks for asking.
13:50:01 <mauke> as usual
13:50:05 <bitemyapp> what takes priority, cabal.config or cabal.sandbox.config?
13:50:17 <Tuplanolla> You get to avoid having to write HashMap.HashMap.
13:53:13 * hackagebot yaml-light-lens 0.3.2 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.2 (AnthonyCowley)
13:56:57 <albeit> Is there any reason why the first FFI call in a program (such as printing something, or getting the current time), would take much longer than subsequent calls?
13:57:55 <albeit> (Like ~50us longer)
13:58:33 <geekosaur> hm. FFI calls that could block I think run in a separate thread (even in the non-threaded runtime); maybe that thread is being started?
13:58:34 <lispy> albeit: an FFI call might take longer if dynamic linking needs to happen
13:58:43 <lispy> albeit: you can try setting LD_BIND_NOW=y if you are on linux
13:58:49 <lispy> (that's an env variable)
13:59:10 <Tuplanolla> This might also require some hand waving about caching.
14:00:21 <albeit> lispy: I'll try that.. I don't think theres any dynamic linking though. The simplified code that shows it is here http://lpaste.net/136252
14:00:56 <lispy> albeit: and if use the ldd command on your executable?
14:01:06 <lispy> albeit: that should list any dynamic dependiences
14:01:21 <lispy> libc is typically list
14:01:37 <quchen> I'm getting a strange "non-exhaustive pattern" warning that I don't understand, does anyone see the mistake? http://lpaste.net/136253
14:02:24 <albeit> lispy: Yes there are some libraries... libgmp, libc, libpthread, and some others
14:02:25 <quchen> Full code, if it helps: http://lpaste.net/894079098580631552 -- Error's on line 537
14:02:35 <albeit> lispy: Buy setting LD_BIND_NOW doesn't help
14:03:01 <sm> quchen: parenthesise s:upply ?
14:03:15 <quchen> Tried that already, didn't help.
14:03:20 <lispy> albeit: cool, then it's probably not the cost of dynamic linking
14:03:24 <geekosaur> I was wondering if they needed to be indented beyond the "case"
14:03:34 <geekosaur> but I'd expect a syntax error in that case
14:03:37 <quchen> Yeah
14:03:40 <sm> worth a try
14:03:41 <quchen> Similarly with the parentheses
14:03:48 <quchen> Can you reproduce the warning (-Wall)?
14:04:09 <quchen> When I mock everything away I don't get the warning anymore: http://lpaste.net/232292399966060544
14:04:14 <rui> How do you fmap a function to a functor in a functor? Such as (^2) to an IO Maybe Double? Something better than ((^2)<$>)<$> x ?
14:04:21 <quchen> rui: fmap.fmap
14:04:27 <quchen> :t fmap . fmap
14:04:29 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:04:35 <albeit> lispy: Does anything in the lpaste strike you as something that should cause a slowdown the first iteration?
14:04:57 <rui> quchen: Looks better than the nested parenthesis, thanks
14:05:15 <quchen> rui: It's also a pattern that works well with other functions when mapping over nested things
14:05:18 <quchen> :t traverse . traverse
14:05:19 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
14:05:40 <quchen> :t fold . fold
14:05:41 <lambdabot> (Foldable t, Foldable t1, Monoid c, Monoid (t c)) => t1 (t c) -> c
14:06:01 <quchen> :t foldMap . foldMap
14:06:02 <Tuplanolla> You could define (<$$>) = fmap . fmap if you intend to use it a lot, rui.
14:06:02 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t (t1 a) -> m
14:06:08 <sm> maybe "case" is parsed as an argument ? I've never seen it written quite so tightly as that
14:06:13 <cow_2001> vty-ui guy wrote me back and recommended i use https://github.com/jtdaugherty/brick
14:06:33 <rui> Great!
14:06:40 <quchen> sm: When I expand the \case to \x -> case x of, I still get the warning
14:06:54 <geekosaur> sm, that's the lambdacase extension
14:07:00 <sm> aha
14:07:20 <quchen> It's really tiny and really useful. Although lots of people think otherwise and call it nonsensical and trivial.
14:07:21 <exio4> quchen: does it still happen when you change the order of the patterns? 
14:07:43 <quchen> exio4: Yes, it does, same error
14:08:04 <geekosaur> *same* error? doesn't switch to the other case?
14:08:07 <Tuplanolla> How about _ as the last pattern?
14:08:19 <geekosaur> are you sure the warning is for that \case?
14:08:43 <quchen> geekosaur: Well, it's for that line.
14:09:13 <sm> cow_2001: brick sounds nice, thanks for the link
14:09:16 <quchen> Hah, when I change the [] to _ the warning is gone.
14:09:54 <quchen> I guess it's time to figure out a minimal broken example.
14:10:00 <geekosaur> o.O
14:12:16 <supki> quchen: these warning happen when -XOverloadedLists is enabled
14:12:24 <quchen> supki: Aaah!
14:12:39 <quchen> That makes sense. Although I'd say it's a bug, no?
14:12:55 <quchen> The pattern is list-monomorphic after all by unification with the other case
14:13:14 * hackagebot text-zipper 0.1 - A text editor zipper library  http://hackage.haskell.org/package/text-zipper-0.1 (JonathanDaugherty)
14:18:14 * hackagebot base91 1.0.0 - A Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-1.0.0 (ajg)
14:22:40 <ttk> Anyone using Atom for haskell?
14:25:20 <hodapp> ttk: Atom the editor or Atom the real-time synchronous EDSL?
14:25:28 <ttk> editor :)
14:25:45 <hodapp> then no
14:25:50 <hodapp> need to try it soon though!
14:28:15 * hackagebot base91 1.0.1 - A Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-1.0.1 (ajg)
14:28:49 <ttk> I am having an issue where i reports error on import even though the file with the module is in the same folder
14:33:02 <Tuplanolla> I'm looking for a system to manage personal data such as item catalogs and contact information. I currently use tables in plain text files and version them with Git, but it's getting cumbersome as more entries appear. I also tried SQLite, but it was equally unpleasant. Is there a purely functional, visual and otherwise user-friendly database system suited for this task?
14:34:34 <Tuplanolla> Haskell library recommendations are also fine, because I suspect I have to write my own anyway.
14:37:45 <zomg> Excel
14:37:46 <zomg> err
14:40:42 <asxz> how would  go about creating an emulator
14:48:15 * hackagebot text-zipper 0.1.1 - A text editor zipper library  http://hackage.haskell.org/package/text-zipper-0.1.1 (JonathanDaugherty)
14:54:01 <slack1256> What interpreted languages offer static typing and a reasonable binary size?
14:54:01 <bitemyapp> carter_cloud: around?
14:54:11 <bitemyapp> slack1256: runhaskell
14:54:21 <slack1256> reasonable binary size?
14:54:43 <geekosaur> define reasonable
14:55:03 <geekosaur> most of the small ones don't bother with things like types (or syntax...)
14:55:35 <ttk> anyone know how to make ghci search in the same folder as the file for modules?
14:55:57 <ttk> ghc-mod*
14:56:14 <slack1256> Mmm maybe something on the size of Lua or some schemes
14:57:18 <bitemyapp> slack1256: Moscow ML should be smaller than GHC
14:57:27 <bitemyapp> slack1256: but you're going to have to write everything yourself. Few libraries.
14:57:31 <geekosaur> lua is one of the things I meant with "most of the small ones"
14:57:34 <geekosaur> (also tcl)
14:57:46 <geekosaur> lua admittedly has more syntax than tcl, but still not very much... and forget about types
14:57:54 <geekosaur> type machinery takes up space
14:58:11 <bitemyapp> OCaml has more libraries, but might also be smaller than GHC. I haven't really thought to check though.
14:58:31 <bitemyapp> Moscow ML is probably the smallest one of the three (Moscow ML / OCaml / GHC Haskell) that has static types and an interpreter.
14:58:42 <bitemyapp> I hope you know SML :)
14:59:31 <slack1256> Well I can learn :-). Also can be a good to learn it once our backpack overlords arrive.
14:59:43 <slack1256> I going to check out moscowML then
15:00:04 <geekosaur> (I could imagine someone compiling a subset of Haskell to lua or even tcl, after the fashion of fay or haste, but don;t know of anyone doing so yet)
15:00:21 <bitemyapp> slack1256: could you do me a favor?
15:00:38 <bitemyapp> slack1256: whatever you land on, tell me the total size of the self-contained deployment for the interpreter.
15:00:55 <bitemyapp> geekosaur: compiling yes, but making a portable interpreter is annoying unless you make a custom one.
15:01:06 <bitemyapp> geekosaur: GHC API doesn't make it easy to make a self-contained interpreter. Wish it did.
15:01:24 <bitemyapp> I guess it doesn't because the binaries would be big :)
15:01:25 <slack1256> bitemyapp: OK, will do
15:01:38 * geekosaur not sure what ghc api has to do with it; he specifically left ghcjs out of that list :)
15:01:56 <bitemyapp> slack1256: if it were me though, I'd just require GHC to be on the machines and use runhaskell.
15:02:07 <bitemyapp> slack1256: or just build the jobs/scripts and deploy those as binaries.
15:02:11 <bitemyapp> (I'd prefer the latter)
15:02:26 <bitemyapp> there's really no reason to have source code on the deployment targets usually.
15:02:53 <geekosaur> I did at one point mock up a scm system based on runhaskell
15:03:27 <geekosaur> but, well, some of the systems I wanted to support are not targeted by ghc, or at least weren't back then
15:03:49 <geekosaur> (some of them are irrelevant now; I am no longer herding Digital UNIX boxes, hurrah)
15:04:20 <geekosaur> (or AIX 4.3)
15:05:39 <slack1256> bitemyapp: I was think on doing some work on combinatorrent and let the user do some logic about the torrents download (ie, download two file at the same time unless you pass a certain speed limit, on that case put all the bandwidth on one alone)
15:06:06 <slack1256> At that point I asked myself. Why can allow some lightweight scripting on the program?
15:07:57 <slack1256> oh, morte looks interesting
15:09:12 <bitemyapp> slack1256: I think it'd be nicer for end-users to just have config or arguments.
15:09:21 <bitemyapp> slack1256: and offer it as a binary that just works
15:09:42 <bitemyapp> all your other options involve completely rewriting combinatorrent
15:09:50 <bitemyapp> slack1256: I'd also like to know you update combinatorrent.
15:10:29 <bitemyapp> know if you*
15:10:38 <bitemyapp> slack1256: xmonad, for example, requires that you have GHC installed in order to script it.
15:11:08 <bitemyapp> so your most-likely-to-work options are, "require GHC to be installed" or "add support for sufficiently clever configuration/argument-passing"
15:11:27 <slack1256> Yes, I dislike that. I don't have a better idea though
15:12:04 <slack1256> there is a tension between a "self contained executable" and being "extensible enough"
15:13:16 * hackagebot reflection 2 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-2 (EdwardKmett)
15:15:56 <shachaf> edwardk: 2?
15:16:12 <shachaf> No minor version number?
15:16:26 <edwardk> shachaf: required a major bump because it breaks lens
15:16:32 <glguy> edwardk doesn't do trailing zeros
15:16:42 <edwardk> what glguy said
15:16:56 <glguy> hvr: doesn't like it because it breaks the ability to write:   4.*
15:17:01 <glguy> because 4 doesn't match that
15:17:13 <edwardk> which i view as a bug
15:17:30 <arkeet> why no trailing zeros?
15:17:41 <edwardk> arkeet: how many should i add? 2, 4? 20?
15:17:44 <edwardk> when do i stop?
15:17:50 <arkeet> infinitely many.
15:17:50 <hvr> arkeet: 0.0.0.0.0.0.0.0.0...
15:17:51 <edwardk> it has a banananananana problem
15:18:16 <edwardk> so i write the minimum number required to get prettier versions
15:18:33 <arkeet> glguy: you're talking about cabal?
15:18:55 <glguy> arkeet: specifically the build-depends:
15:18:57 <arkeet> yes.
15:19:05 <arkeet> I thought it worked.
15:19:21 <hvr> edwardk: although if you take the PVP as a hint of alignment, padding to 4 components could be argued
15:19:35 <arkeet> the version after 4 should be 4.0
15:19:40 <arkeet> and then 4.0.0, and 4.0.0.0, etc.
15:19:47 <edwardk> hvr: it could be argued. it'd also dramatically inflate the size of the 'version history' in all my packages, so screw it.
15:20:04 <glguy> arkeet: I never tried. I released utf8-string-1 at one point and then hvr sent me a message about it
15:20:11 <arkeet> heh.
15:20:33 <arkeet> but according to cabal user guide.
15:20:38 <arkeet> The last is just shorthand, for example base == 4.* means exactly the same thing as base >= 4 && < 5.
15:20:47 <hvr> ideally, hackage would block uploading two versions which only differ by number of trailing 0s
15:21:09 <hvr> (but there are already a dozen such cases on Hackage)
15:21:24 <edwardk> hvr: that fact makes me sad
15:21:56 * hvr compiled a list some time ago but can't find it right now
15:22:04 <arkeet> do you remember any examples?
15:22:45 <sm> Tuplanolla: are you asking for something like that that's written in haskell ?
15:23:05 <hvr> hah... found it: http://lpaste.net/118312
15:23:12 <hvr> arkeet, edwardk: ^^
15:23:17 <Tuplanolla> Not necessarily, sm.
15:23:25 <arkeet> fun.
15:23:39 <arkeet> I like lojban.
15:23:58 <arkeet> they should have kept going with 0.0.0.0
15:24:21 <sm> Tuplanolla: what about org-mode or taskwarrior
15:24:48 <arkeet> are there any packages with more than 4 version components?
15:25:43 <Tuplanolla> Let's take a look, sm.
15:26:57 <edwardk> do you know if any of those that differ in version number by number of 0s actually differ in content at all?
15:27:01 <edwardk> e.g. is this fixable
15:27:24 <Tuplanolla> Org-mode seems to be a way to edit text and Taskwarrior looks like a to-do list instead of an interactive database system. Am I wrong?
15:28:53 <jle`> just wrote a haskell in vietnamese.  but i don't speak vietnamese ><
15:28:58 <jle`> hope it's readable and understandable
15:29:01 <jle`> *a haskell article
15:29:04 <sm> Tuplanolla: this is a bit off topic here, but I would say org is worth a closer look if you like storing complex data (including tabular) in text files
15:30:00 <sm> the other one I heard spoken well of by a haskeller, and I guessed it might store more than todos, but I haven't tried it
15:30:18 <Tuplanolla> I'd prefer a relational algebra system, but I guess I'll have to build something myself.
15:31:34 <sm> you might enjoy one of the db libs on hackage then. persistent works with sqlite, eg
15:32:06 <Tuplanolla> It's really strange that something like this doesn't already exist.
15:32:46 <sm> http://hackage.haskell.org/package/haskelldb also works with sqlite.
15:32:50 <Tuplanolla> I guess people enjoy clicking through spreadsheets and losing data every now and then.
15:33:18 * hackagebot lens 4.12 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.12 (EdwardKmett)
15:34:38 <sebboh> Earlier, I was in here complaining.  Now, I'd like to acknowledge that the advice I got here was great and cabal sandboxes are great.  Cheers. :)
15:39:05 <jle`> :)
15:48:37 <sebboh> During cabal update, I think during network activity, the process hangs and I have to kill it.  (ctrl+c does not work.)  Now, I think the same thing is happening during cd ~/src/foo; cabal sandbox init; cabal install --only-dependencies ...
15:50:25 <sebboh> Well, maybe it's not during network activity.  It says Downloading HUnit-1.2.5.2... Downloading [others...] Configuring [others]. The last line is Installed ansi-terminal-0.6.2.1.  Does this indicate that all the downloads are done, or is that unknown?
15:52:55 <arkeet> you're building multiple things in parallel? try --jobs=1
15:52:57 <arkeet> and maybe also -v
15:53:18 * hackagebot linear 1.19.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19.1 (EdwardKmett)
15:53:45 <sebboh> Oh! there are five "Downloading..." lines.. Three "Configuring", three "Building", and three "Installed".  So maybe some downloading jobs are stuck?  Can I kill this thing and start again, or do I have to wipe everything out?  ..Since I did a sandbox, nothing has been written outside of the current directory, right?
15:54:08 <sebboh> arkeet, if parallel is default, then sure.
15:54:12 <arkeet> you can just kill it and start again
15:54:21 <arkeet> it might just be that one thing is taking a really long time.
15:54:37 <arkeet> --jobs=1 will do one at a time.
15:54:37 <sebboh> no cpu, disk, or network activity.
15:54:43 <arkeet> huh.
15:54:56 <arkeet> (it will also show the build log for the package that's building)
15:55:06 <arkeet> (but maybe you can look at build logs too)
15:55:06 <sebboh> jobs=1 sounds good to me, I've only got one core in this VM.
15:58:18 * hackagebot hyperloglog 0.3.3.1 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.3.3.1 (EdwardKmett)
16:00:42 <sebboh> It would be nice if hackage.haskell.org had a reverse DNS set up.
16:01:36 <Tuplanolla> I'm looking at persistent-sqlite, but I don't see how it solves my problem, sm.
16:02:06 <SrPx> Just a quick and probably obvious question, but if you have a lambda term with id based variables (not bruijn indices), and you are sure those ids are unique, is there any possibility of name capture?
16:03:18 * hackagebot folds 0.6.3 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.6.3 (EdwardKmett)
16:08:19 * hackagebot tagged-transformer 0.8 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.8 (EdwardKmett)
16:09:53 <sebboh> I think the network link between here and hackage.haskell.org is weak.  Does the community consider this hackage.fpcomplete.com mirror to be reliable and trustworthy?
16:10:44 <kadoban> sebboh: It's certainly more reliable, and I trust it *shrug*
16:11:20 <sebboh> They both are http by default, so *shrug* here too. :)
16:11:37 <kadoban> sebboh: You can fix that using some stackage CLI tools
16:11:41 <johnw> sebboh: I'm sure it's trustworthy, I just don't know about trusting it to always be there, and in the best interest of the open source community.  One would certainly hope so, but it's not under our control.
16:12:05 <johnw> whereas the real Hackage is directly controlled by the haskell.org committee and its admins
16:12:12 <sebboh> are the package contents pgp signed or something?
16:12:19 <shachaf> No.
16:12:24 <johnw> that has very recently been worked on
16:12:29 <johnw> but is not the norm yet
16:12:55 <sebboh> the real Hackage has a /maintain on each package that asks for a user/pass via what appears to be HTTP BASIC AUTH.
16:12:57 <sebboh> ;P
16:13:06 <johnw> it should be over HTTPS though
16:16:10 <carter_cloud> bitemyapp: I'm free now. 
16:16:20 <carter_cloud> Sup?
16:17:02 <sebboh> none of these complaints are legit for me at this time, since I can't read .hs and wouldn't know a trojan if it was on my screen in the clear.  But for those of you who use this stuff in prod... remember that old prank where you stick a proxy inbetween somebody's browser and the net and it makes all the web pages come in upside down?  The proxy altered the html and image content on the fly, get it?  In 2015, most SSL sites are
16:17:02 <sebboh> vulnerable to that, too.  I mean, google and facebook aren't.  You bank might not be.  Your credit union is.  ...I'm going to make a guess about where hackage sits. ;P
16:17:28 <bitemyapp> carter_cloud: weird trustworthy/unsafe issue with vector-bytestring and Stack.
16:17:53 <kadoban> sebboh: Yeah, it's a complete crap situation. Which is why I use 'stackage update' and 'stackage install' instead.
16:18:03 <bitemyapp> carter_cloud: trustworthy and unsafe aren't incompatible right? That's the whole point of trustworthy vs. safe
16:18:04 <johnw> sebboh: it's not a fear I'm adding to my todo list just yet
16:18:07 <carter_cloud> I'm not familiar with that package 
16:18:19 * hackagebot linear 1.19.1.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19.1.1 (EdwardKmett)
16:18:43 <carter_cloud> bitemyapp: unsafe code can be marked trustworthy.
16:18:54 <carter_cloud> Safe code can't have fusion.
16:19:05 <bitemyapp> carter_cloud: yeah, that's what I thought
16:19:07 <bitemyapp> which is why I'm confused.
16:19:08 <bitemyapp> vector-bytestring/Data/Vector/Storable/ByteString/Internal.hs:12:14-19: Incompatible Safe Haskell flags! (Trustworthy, Unsafe)
16:19:22 <Zemyla> Hmm, can anyone explain who Stefan Reich is and why he's repeatedly stirring up shit on the Haskell mailing list?
16:19:43 <bitemyapp> carter_cloud: GHC command has, "-XTrustworthy"
16:19:53 <bitemyapp> Zemyla: #haskell-blah
16:19:55 <carter_cloud> Idk. 
16:20:02 <Zemyla> Okay.
16:20:12 <sebboh> johnw, you maintain Hackage, right?  It's really, really obvious that injection attacks against cabal users are not on the maintainers' radar.  But at least there's no illusion about it--users that care can be careful.  I mean, me, for example.. I'm in a VM. ;)
16:20:17 <kadoban> sebboh: A lot of sites aren't vulnerable to what you describe, unless something has changed that I don't know of.
16:20:27 <carter_cloud> bitemyapp: i bet you're on 7.10 and it was a previously allowed combo
16:20:43 <bitemyapp> $ ghc --version
16:20:43 <bitemyapp> The Glorious Glasgow Haskell Compilation System, version 7.8.4
16:20:46 <bitemyapp> carter_cloud: ^^
16:20:49 <kadoban> sebboh: Are you talking about SSL stripping or something? Hard to tell.
16:20:54 <johnw> sebboh: We are aware that nefarious opportunities abound.  But we're also a small, volunteer group; assistance is welcome.  We're getting there.
16:21:17 <carter_cloud> Ok.  Idk.
16:21:25 <bitemyapp> carter_cloud: GHC 7.10 was overlapping instances specific right?
16:21:29 <carter_cloud> How old is that package I'm afk
16:21:42 <bitemyapp> carter_cloud: fucking ancient which is why we have a vendored copy of it in our monorepo.
16:21:50 <bitemyapp> carter_cloud: but cabal repl loads it up fine, it's only Stack that blows up.
16:22:04 <carter_cloud> Disable werror
16:22:43 <carter_cloud> Also I bet you can switch to storable vectors
16:22:53 <carter_cloud> I'm super tired
16:23:05 <bitemyapp> carter_cloud: not enabled.
16:23:05 <sebboh> johnw, cool. kadoban, a quick web search turned this up: http://crypto.stanford.edu/ssl-mitm/
16:23:19 * hackagebot hsass 0.3.0 - Integrating Sass into Haskell applications.  http://hackage.haskell.org/package/hsass-0.3.0 (jakubfijalkowski)
16:23:20 <bitemyapp> carter_cloud: I'll see about doing that, since I think that's partly why it's unmaintained.
16:23:27 <bitemyapp> carter_cloud: thank you :)
16:23:32 <bitemyapp> carter_cloud: I'll leave you be since you're tired.
16:23:56 <carter_cloud> Use vector storable
16:24:02 <carter_cloud> Gluck
16:24:03 <kadoban> sebboh: That doesn't sound like it'll get accepted by … any machine unless you modify the target machine first to add your own root cert.
16:24:54 <sebboh> kadoban: it's old and probably doesn't work.  But the concept is alive and well.  I don't really understand this stuff, but, I believe that no MITM stuff is possible unless the bad actor has complete control of the network between you and the legit site.  ie, your router, or your ISP's routers.
16:25:30 <sebboh> I think DNS manipulation counts.  Long story short?  Client-side certs. :)
16:25:34 <kadoban> sebboh: Even if they do, it's still not possible unless you can get a forged SSL cert signed by a trusted CA
16:25:56 <johnw> this isn't really the place to discuss possible network attacks, though
16:29:34 <sebboh> kadoban: I guess... I guess the question of whether or not today's average SSL is safe depends on how deep you imagine the bad guys' pockets are. :)  But yeah, sorry for going off topic johnw.
16:32:55 <KaneTW> is there any way to get to do the equivalent of "-package ghc" without a compiler flag
16:33:05 <KaneTW> command-line flag, sorry
16:33:25 <KaneTW> something like {-# OPTIONS_GHC -package ghc #-}, except that doesn't work
16:40:29 <pavonia> KaneTW: Why do you want to specify that in the module? It usually belongs to the cabal file
16:41:51 <KaneTW> pavonia: i'm playing around with a friend's bot that executes haskell code by putting it in a file, then running ghc on it
16:41:59 <KaneTW> and i want to get it to simulate :t
16:42:11 <KaneTW> using the ghc compiler api and exprType
16:42:54 <pavonia> There's an extension to allow package specifications on imports
16:43:21 <ttk> Anyone up for helping me out with homework 5? http://www.seas.upenn.edu/~cis194/spring13/lectures.html I cannot figure out how solve ex3.. I just need something to get started on.. This is the code I have now: http://lpaste.net/136258
16:43:24 <KaneTW> hmm let's try that
16:43:29 <pavonia> KaneTW: "PackageImports " apparently
16:44:33 <KaneTW> it still complains, sadly
16:44:58 <pavonia> Yeah, I think that doesn't actually "loads" the package
16:45:12 <KaneTW> yup
16:45:20 <KaneTW> it just helps resolve ambiguities
16:46:29 <arkeet> ttk: you almost have it
16:46:44 <arkeet> it's just that 
16:46:45 <ttk> should lit be int -> a?
16:46:47 <ttk> Integer -> a?
16:46:55 <arkeet> "instance Expr a" makes an instance of Expr for *every* type a
16:47:02 <arkeet> but you just wnat it for ExprT.
16:47:13 <arkeet> oh, there is also that yes.
16:49:20 <ttk> I think I had that solution once, but then when I get to ex4 I have new problems. I canoot use that implementation for the exercise arkeet
16:49:35 <ttk> Ah, you are in both channels :)
16:49:53 <jle`> b 21
16:53:06 <arkeet> ttk: let's stick to -beginners then 
16:53:16 <ttk> ya
17:00:41 <Zemyla> Which free monads are also comonads? Because I know the free monad over the identity functor is also a comonad.
17:05:07 <arkeet> Zemyla: how do you define extend/duplicate?
17:05:12 <johnw> perhaps that's because the Identity monad is also a comonad
17:05:23 <johnw> or rather, Identity is both a monad and a comonad
17:05:49 <Zemyla> arkeet: extract (Pure a) = a; extract (Free f) = extract (runIdentity f);
17:06:00 <arkeet> I didn't ask about extract.
17:06:00 <Zemyla> duplicate m = m <$ m
17:06:03 <Fuuzetsu> https://hackage.haskell.org/package/comonad-4.2.6/docs/Control-Comonad.html lists some existing instances which is probably a start
17:06:32 <arkeet> then again, Free Identity a ~ (Nat, a)
17:06:39 <Zemyla> arkeet: It's because Free Identity is isomorphic to Writer Nat.
17:07:13 <Zemyla> So Free Identity a ~ Cofree (Const Nat) a, actually.
17:08:07 <sknudsen> :j mcgill
17:13:21 * hackagebot base91 1.1.0 - A Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-1.1.0 (ajg)
17:18:22 <Tuplanolla> I want to briefly return to my previous query: is there a relational database system with full undo tree history (like Vim's u, C-r, g+ and g-)?
17:19:46 <greymalkin> Yay Sodium + State monad!
17:23:22 * hackagebot linear 1.19.1.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19.1.2 (EdwardKmett)
17:28:12 <andrus> Can anyone share a Template Haskell example for constructing a simple GADT?
17:28:22 * hackagebot fast-tagsoup 1.0.7 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.7 (VladimirShabanov)
17:28:32 <andrus> I'd like to build something like: data Foo i a where Foo :: a -> Foo 'True a
17:29:16 <andrus> But I haven't had much success with DataD and ForallC...
17:30:20 <dmj`> andrus: can you paste your code
17:33:06 <dmj`> andrus: I'd check out persistent, it gens GADTs w/ TH pretty sure
17:35:42 <andrus> dmj': sure, just cleaning it up a bit. i'll look at persistent as well
17:38:12 <lpaste> andrus pasted “Template Haskell and GADTs Question” at http://lpaste.net/6357282489844629504
17:38:47 <andrus> dmj`: neat, looks like lpaste just posted it ^^
17:39:00 <Tuplanolla> I'm looking at hasql and relational-query on Hackage, but I don't know if they do what I want.
17:45:10 <stephenmac7> I have a question about Data.Text: why does it store things in UTF-8 but then not correctly handle operations on UTF-8?
17:46:02 <shachaf> That's not a very useful question.
17:46:25 <shachaf> The answer is that it doesn't and couldn't, respectively.
17:46:36 <Eduard_Munteanu> stephenmac7, Data.Text isn't UTF-8
17:46:45 <stephenmac7> shachaf: I'm guess the real question is: is there any library that handles unicode correctly?
17:46:58 <shachaf> Data.Text
17:47:06 <stephenmac7> Eduard_Munteanu: It isn't? I guess I didn't realize that.
17:47:30 <Eduard_Munteanu> stephenmac7, it stores UTF-16 internally
17:47:46 <stephenmac7> Oh.
17:48:21 <shachaf> You're being kind of hostile here. Imagine that the people in the channel aren't your enemies and that your Unicode problems aren't their fault, but maybe they want to help you anyway because they're nice.
17:48:33 <Eduard_Munteanu> stephenmac7, secondly, other than Data.Text.Encoding, it's encoding-agnostic.
17:48:34 <shachaf> (That last part might exclude me.)
17:49:03 <stephenmac7> shachaf: Sorry about that, I didn't realize how it sounded until I re-read what I had written.
17:50:30 <Tuplanolla> Is there a channel better suited for discussing purely functional databases?
17:50:48 <verement> stephenmac7: maybe it would help to describe what you're trying to do
17:51:10 <Eduard_Munteanu> Tuplanolla, I think acid-state can do that, with ixset as the relational store
17:51:44 <stephenmac7> verement: I'm trying to find a library which will allow me to perform normal text operations (length, reverse, etc) with not unicode oddities 
17:51:50 <stephenmac7> *no unicode
17:51:51 <Eduard_Munteanu> It's not SQL or anything close though.
17:52:20 <Eduard_Munteanu> stephenmac7, Data.Text is fine for that
17:52:21 <shachaf> "length" isn't necessarily an easy thing to compute (or even define) if you want to do Unicode properly.
17:52:44 <stephenmac7> Eduard_Munteanu: It seems to do strange stuff with accents
17:52:51 <geekosaur> yes
17:52:57 <geekosaur> good luck fixing that
17:53:14 <geekosaur> your enemy here is unicode itself
17:53:39 <shachaf> saying "not correct", "strange stuff", etc. won't help you solve your problems.
17:53:56 <shachaf> Figure out what you want to do and then maybe people here can help you do it.
17:53:59 <stephenmac7> True, maybe I should be more specific
17:54:12 <stephenmac7> It moves the accents in non-English text
17:54:27 <geekosaur> a combining character (e.g. accent) is a separate unicode code point. *some* characters happen to also have combined representations (mostly, the ones that are there for ISO8859 compatibility)
17:54:43 <geekosaur> but the whole thing is just a nasty sewer
17:55:16 <Tuplanolla> This looks certainly interesting, but I have no idea what is going on with all these extensions and very little documentation, Eduard_Munteanu.
17:55:19 <shachaf> You should be so specific that anyone who reads what you say can reproduce it completely on their own.
17:55:21 <geekosaur> (and if you survive the sewer ratsh, you find shoggoths hiding in the unexplored reaches)
17:55:41 <shachaf> For example, you can show your code, its output, and your expected output.
17:55:42 <stephenmac7> I mean, it handles CJK beautifully
17:57:03 <Eduard_Munteanu> Tuplanolla, acid-state or ixset?
17:57:15 <Tuplanolla> Just acid-state at the moment.
17:57:36 <verement> stephenmac7: it's possible you may find some of the functionality from the text-icu package to be helpful
17:58:32 <Eduard_Munteanu> Tuplanolla, it serializes updates to data into a log that can be replayed
17:59:37 <Tuplanolla> That doesn't sound like what I'm after.
18:00:27 <Eduard_Munteanu> Tuplanolla, the idea is it ends up keeping a history of the modifications
18:00:57 <Tuplanolla> I'll have to come back to this tomorrow.
18:01:22 <Tuplanolla> My real goal is to find or build a system for curating various kinds of everyday data.
18:02:19 <dgpratt> I asked this in #ghc-mod, but it's very...quiet over there...
18:02:22 <dgpratt> is ghc-mod the secret sauce that is allowing flycheck to do syntax checking of my Haskell code?
18:03:06 <johnw> no, flycheck can do that without ghc-mod
18:03:13 <johnw> it just runs ghc itself
18:03:24 <dgpratt> how does it know how?
18:03:28 <johnw> ghc-mod is for querying the GHCI api for things like "What type is this expression?"
18:03:35 <johnw> there is a flycheck recipe for GHC
18:03:46 <johnw> see https://github.com/flycheck/flycheck-haskell
18:04:43 <dgpratt> keeping in mind that I'm a total emacs noob, unless flycheck-haskell is simply part of flycheck, I don't think I have it configured
18:04:58 <Pamelloes> Can you do recursive do in IO?
18:05:38 <dramforever> yes
18:05:44 <johnw> it may have some default, I'm not sure if it does anymore
18:05:47 <dramforever> :t System.IO.fixIO
18:05:48 <lambdabot> (a -> IO a) -> IO a
18:06:04 <dgpratt> the background of this line of questions is that I want to try to switch to hdevtools
18:06:05 <johnw> type C-c ! s, and see if there is a "ghc" or "haskell" checker available
18:06:08 <dramforever> :t mfix :: (a -> IO a) -> IO a
18:06:09 <lambdabot> (a -> IO a) -> IO a
18:06:11 <dgpratt> but I'm afraid of making a mess
18:06:16 <johnw> don't bother with hdevtools if you have a fast machine
18:06:23 <dgpratt> I'm already well in over my head :)
18:06:24 <johnw> all it buys you is speed, but with *lots* of headache
18:06:33 <johnw> I stopped using hdevtools
18:06:52 <dgpratt> I heard it works for stack, which I'm trying to use also
18:07:23 <dgpratt> TRY ALL THE THINGZ! that seems to be my motto of late
18:07:26 <Eduard_Munteanu> Any idea what's wrong with the happstack website? The docs links aren't working.
18:08:34 <Zer000> So I'm trying to learn more about network programming with haskell and (from Network.Socket) it says " Essentially the entire C socket API is exposed through this module; in general the operations follow the behaviour of the C functions of the same name (consult your favourite Unix networking book)." So can anyone here recommend a good book? Preferrably free and online?
18:09:32 <dgpratt> johnw, what does C-c ! s actually do? I'm almost embarrased to say that I'm...I'm also trying spacemacs
18:10:14 <Eduard_Munteanu> Zer000, you might want to start with a better API such as conduit's, e.g. look at conduit-extra
18:10:21 <dramforever> Zer000: sadly it's not
18:10:22 <Eduard_Munteanu> s/better/nicer/
18:10:33 <creichert> dgpratt: the nice thing about emacs is the documentation is discoverable. Try M-x describe-key, then type the sequence and the docs should pop-up
18:10:48 <johnw> dgpratt: it lets you select a flycheck checker for the current buffer
18:11:01 <dramforever> I tried using AF_PACKET with Network.Socket. Failed.
18:11:11 <johnw> pretty much anything that can output line-based information is eligible to be a checker, if you define one in elisp
18:12:31 <Eduard_Munteanu> ##networking might also have some ideas
18:13:43 <Zer000> dramforever, did I miss something, it's not what?
18:14:07 <Zer000> thanks
18:14:09 <dramforever> Zer000: I encountered a part that unix sockets can do, Network.Socket can't
18:14:21 <dramforever> but...it's unlikely that you will ever need it
18:14:24 <dramforever> so don't worry
18:14:29 <Zer000> oh I see
18:14:46 <Zer000> I don't need anything super crazy, just trying to use UDP
18:15:06 <ackthet> how profitable is oil
18:16:03 <fr33domlover> hello. I wrote a function named 'join' and GHC 7.8.4 warns that a future Prelude will have a function by that name, in GHC 7.10
18:16:08 <arkeet> correct.
18:16:13 <johnw> fr33domlover: yes, avoid that
18:16:13 <dmj`> :t join
18:16:13 <fr33domlover> it says "applicative monad proposal"
18:16:14 <lambdabot> Monad m => m (m a) -> m a
18:16:24 <dramforever> fr33domlover: and 7.10 has been out for quite a while
18:16:31 <fr33domlover> johnw, is that the join in Control.Monad ?
18:16:35 <johnw> yes
18:16:36 <arkeet> yes.
18:16:41 <arkeet> except now it is moved into the Monad class.
18:16:41 <dramforever> fr33domlover: it will be in prelude
18:16:49 <dramforever> or rather, we already have it in prelude
18:16:53 <fr33domlover> when? :) and why
18:16:54 <dramforever> *the prelude
18:17:08 <arkeet> except it's not, never mind.
18:17:11 <dramforever> fr33domlover: ghc 7.10 has been out for a while, your distro hasn't updated it
18:17:20 <dramforever> obviously
18:17:30 <shachaf> arkeet: Maybe it should be, but it's not.
18:17:39 <fr33domlover> dramforever, it's not the distro, I choose to use 7.8.4
18:17:45 <dramforever> okay
18:17:46 <fr33domlover> can move to 7.10 easily
18:17:56 <dramforever> fr33domlover: but you should avoid it
18:18:00 <arkeet> join isn't in the Prelude though.
18:18:05 <dramforever> oh?
18:18:12 <arkeet> but you should still avoid it.
18:18:13 <fr33domlover> why is it moving though?
18:18:16 <dramforever> ?
18:18:19 <dramforever> wow why?
18:18:22 <fr33domlover> I never used join so far in my code
18:18:42 <fr33domlover> (but I'm a beginner)
18:18:48 <dramforever> fr33domlover: sadly join isn't in the prelude even in 7.10.1, but it might be in the future
18:19:18 <fr33domlover> Yes, I understand that
18:19:23 <fr33domlover> thanks
18:19:35 <dramforever> > map join [Just Nothing, Nothing, Just (Just 3)] -- IMHO join is for flattening monads
18:19:36 <lambdabot>  [Nothing,Nothing,Just 3]
18:19:37 <fr33domlover> but I'm curious *why* it's moving
18:19:54 <fr33domlover> into Prelude
18:20:21 <dramforever> fr33domlover: it's a...somewhat basic function
18:20:34 <dramforever> but yeah, I don't think I'll ever need it *that* often
18:20:46 <dramforever> I mean as often as something as const or id or something
18:21:00 <fr33domlover> I just haven't needed it so far so I'm curious whether I miss anything :P
18:22:27 <johnw> fr33domlover: I use join often enough
18:23:24 <roboguy_> fr33domlover: hmm, what does your join do?
18:24:20 <Eduard_Munteanu> I wish they moved join into Monad.
18:24:48 <dramforever> Eduard_Munteanu: just like Comonad?
18:25:00 <Eduard_Munteanu> dramforever, yes
18:25:18 <fr33domlover> johnw, mind sharing a use case? :)
18:25:31 <fr33domlover> roboguy_, totally unrelated.... it joins an IRC channel 
18:25:37 <roboguy_> ah
18:26:33 <roboguy_> > join [[1,2,3], [4,5,6]]  -- This one's pretty handy, but usually not called join
18:26:34 <lambdabot>  [1,2,3,4,5,6]
18:26:46 <Eduard_Munteanu> fr33domlover, you could use qualified imports and define it in a module with {-# LANGUAGE NoImplicitPrelude #-}
18:26:53 <johnw> fr33domlover: say I have a map like Map Int (Maybe Float), and I just want to lookup a float: join $ lookup x myMap.  Join flattens the Maybe from the value with the Maybe from the lookup.
18:27:13 <roboguy_> > join (*) 3  -- This one's kinda fun
18:27:14 <lambdabot>  9
18:27:29 <dramforever> oh the W combinator
18:27:47 <johnw> Eduard_Munteanu: I too would rather it was an optional alternative to defining >>= in instances
18:28:05 * Pamelloes is upset. recursive do didn't magically make things work.
18:29:03 <fr33domlover> johnw, thanks
18:29:55 <fr33domlover> Eduard_Munteanu, I think I'll just change the function's name
18:30:12 <dramforever> joinChannel maybe
18:30:14 <fr33domlover> I'll make it joinChannel
18:30:17 <fr33domlover> yeah
18:30:19 <dramforever> lol =)
18:30:46 <Eduard_Munteanu> Or maybe ircJoin, but maybe you already have other commands.
18:30:50 <fr33domlover> someLongNameCosSelfishPreludeTookTheName
18:31:14 <fr33domlover> Eduard_Munteanu, I did think about adding a prefix
18:31:20 <fr33domlover> but isn't that redundant?
18:31:30 <fr33domlover> I mean, people can use qualified
18:31:40 <Eduard_Munteanu> Yeah, true.
18:31:49 <fr33domlover> e.g. import Module as Irc, then Irc.join etc.
18:32:00 <fr33domlover> perhaps I'm wrong though :P
18:32:19 <fr33domlover> I have one library with prefixes, but in this one I decided to try without them
18:32:36 <fr33domlover> I hoped 'join' would quietly sit in Control.Monad :)
18:33:18 <Eduard_Munteanu> fr33domlover, by the way, you could always do   import Prelude hiding (join)   later on.
18:34:16 <fr33domlover> Eduard_Munteanu, I happily will - but I got this Warning from GHC
18:34:19 <fr33domlover> so I got worried
18:34:33 <fr33domlover> It's the first time I get a warning :P
18:34:53 * dramforever sometimes name his var "id" and get a warning
18:35:06 <dramforever> fr33domlover: do you use -Wall?
18:35:28 <fr33domlover> dramforever, no, I use regular `cabal configure && cabal build`
18:35:43 <dramforever> oh it's someone else's code
18:35:47 <dramforever> =P
18:35:51 <fr33domlover> dramforever, ?
18:36:00 <dramforever> oh no no
18:36:08 <xendo> Hey there. I downloaded haskell through the haskell platform. I'm trying to uninstall it, but I can't find it on my computer. I've checked ~/Library/Haskell, ~/Library/Frameworks/GHC...and a few other places. Any tips?
18:36:13 <dramforever> never mind
18:36:18 <fr33domlover> lol
18:36:35 <fr33domlover> it's code I'm writing, an IRC bot library
18:36:42 <dramforever> okay
18:37:08 <fr33domlover> (since Haskell doesn't have enough of those... ;-)
18:37:11 <Pamelloes> xendo: there's probably an uninstaller in /usr/bin
18:37:15 <pharaun> lool
18:38:43 <xendo> Pamelloes: Looking now. I don't see anything yet
18:38:57 <Pamelloes> xendo: I think it's called uninstall-platform
18:39:01 <stephenmac7> verement: Thank you
18:39:14 <albeit_> Is there anything that implies that the first call to a modules methods takes longer than subsequent calls? Or is a module loaded lazily, and evaluated when it is first used? I'm trying to work out a weird thing where the first call to certain functions are way slower than subsequent ones... also posted a haskell-cafe thread here http://thread.gmane.org/gmane.comp.lang.haskell.cafe/117260
18:39:51 <felixn> oh my glob, how come nobody told me about diagrams?  I've been doing lame graphviz concatenation
18:40:45 <dramforever> albeit_: might be relevant: I think ghc caches top level values
18:41:38 <dramforever> oh never mind
18:42:45 <dgpratt> got pulled away and didn't get a chance to say thanks, johnw
18:43:12 <dgpratt> haskell-ghc is the only haskell related option in the select checker list
18:43:35 <xendo> Pamelloes: So, I'm not sure if this is right. The ONLY place I could see Haskell was under my apps. Everything was there. I just deleted the entire directory 
18:43:40 <dgpratt> I gather that comes built-in to flycheck
18:44:48 <Pamelloes> xendo: That could be right. Check over the directories listed at https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090170.html just to be sure, but if nothing's there then you're good :)
18:45:19 <Cale> albeit_: Does this only happen with putStr and/or other terminal I/O?
18:47:32 <Cale> albeit_: Putting hFlush stdout before the replicateM_ causes the first iteration to be much faster (though still not quite as fast as the others)
18:48:44 <Cale> albeit_: I suspect there's a bunch of time spent on terminal I/O related CAFs
18:48:46 <albeit_> Cale: No, it happens with getCurrentTime as well
18:49:08 <albeit_> Cale: Which someone on the mailing list narrowed down to something with Data.Fixed
18:49:51 <albeit_> Cale: But I also think I've seen it on far more general things (which I thought it might be something to do with modules), its just hard to narrow it down
18:51:00 <Cale> albeit_: hmm, the thing about Fixed doesn't change things nearly as much as hFlush does for me
18:51:40 <albeit_> Cale: Yeah, it is less drastic, but still significantly slower the first time
18:51:51 <Cale> albeit_: Try  hSetBuffering stdout NoBuffering
18:51:55 <Cale> before the loop
18:51:59 <Cale> that's even more effective
18:52:30 <Cale> I suspect it's a bunch of stuff related to stdout's Handle getting evaluated for the first time.
18:53:00 <Cale>     hSetBuffering stdout NoBuffering
18:53:01 <Cale>     hFlush stdout
18:53:09 <Cale> will cause the *second* iteration to be slower, haha
18:55:37 <albeit_> Cale: I actually see all iterations behaving the same with those two lines. So that's one down! But what about with a non-output-IO thing like this http://lpaste.net/136254?
18:58:10 <Cale> albeit_: I don't see a significant difference between iterations with that.
18:58:34 <Cale> (they're all 0 or 1)
18:58:35 <Cale> (they're all 0 or 1)
18:58:38 <Cale> oops :)
19:00:35 <albeit_> Cale: Interesting... what version GHC and platform are you on?
19:00:37 <Cale> oh, nevermind, the force really does change things... weird, I can't imagine why
19:02:20 <albeit_> So strange! It is bugging me to no end
19:02:22 <Cale> Let's have a look at the NFData instance for it, I guess
19:02:55 <Cale> ah, okay
19:03:01 <Cale> it's a record with two nonstrict fields
19:03:14 <Cale> Not too surprising that force does something then.
19:03:33 <albeit_> But why just the first time? Should't it affect it every time?
19:03:36 <Cale> albeit_: There are a lot of CAFs all over the place
19:04:16 <johnw> Why is decaf the cheapest type of coffee?  There are no cost centers.
19:04:27 <Cale> albeit_: Have you looked at the profiler output?
19:05:14 <albeit_> Cale: I have not... what should I look for there? And by CAFs I guess you're saying that some parts of the program are evaluated just once and "reused" by the subsequent computations?
19:05:35 <dramforever> "dramforever: albeit_: might be relevant: I think ghc caches top level values"
19:05:38 <lpaste> Cale pasted “profiling” at http://lpaste.net/136261
19:05:49 <dramforever> yeah I mentioned that earlier
19:05:50 <Cale> albeit_: Yeah, constant applicative forms
19:05:52 <alexa_> Hey guys, coming from scala where Unit is basically just the void return type, should I throw away that notion and be ready to learn a new meaning for Unit?
19:06:04 <albeit_> dramforever: I saw that... but didn't know what that meant. Sorry probably should have asked for clarification
19:06:14 <shachaf> When people say "unit" they usually mean the same thing.
19:06:16 <dramforever> alexa_: you mean ()?
19:06:25 <dramforever> albeit_: =P
19:06:27 <alexa_> dramforever: that's the notation in scala, I don't know about haskell
19:06:29 <shachaf> When they say "void" they mean something different, though, so they'll get confused if you use that word.
19:06:43 <Cale> albeit_: Constant expressions which end up at the top level, and are evaluated once, and retained as long as the program holds any reference to them.
19:06:43 <dramforever> alexa_: () is also the unit in haskell =P
19:06:44 <alexa_> basically just meaning a function returning no useful value
19:06:46 <alexa_> okay
19:07:04 <dramforever> alexa_: however haskell is (almost entirely) pure
19:07:22 <dramforever> so something like putStrLn has type String -> IO ()
19:07:25 <alexa_> I know this, so basically I should expect to VERY SELDOM see ()
19:07:39 <dibblego> alexa_: the practical difference to scala is that () has only one value, where in scala, it has infinity values
19:07:41 <dramforever> alexa_: well, you are going to see it pretty often
19:07:46 <Cale> albeit_: Unfortunately, the program didn't run long enough for the time profiler to tell us much which is useful, but by %alloc, we see everything is CAFs
19:08:00 <Cale> Maybe I can turn up the tick resolution...
19:08:07 <alexa_> dibblego: that's why I was asking, since I heard the other day talking about something else a different use of the term
19:08:16 <dibblego> alexa_: the type of print("hi") in Scala, is Unit, and for Haskell, it is IO (). This changes everything.
19:08:21 <alexa_> monoids specifically have a unit value(addition is 0)( * is 1)
19:08:22 <albeit_> Cale: So I guess I thought of that a bit while I was trying to figure it out... but isn't most of the program non-CAF-able because its just doing IO calls?
19:08:30 <dibblego> unless you use Scalaz, which has print: IO[Unit] (pure-functional print)
19:08:41 <dibblego> alexa_: this is a different use of the term unit
19:08:46 <alexa_> okay
19:09:08 <Cale> albeit_: The program does almost nothing
19:09:10 <alexa_> should I cleanly separate in my head those two concepts of unit?
19:09:18 <roboguy_> alexa_: maybe it would be better to call the monoid unit "identity" instead
19:09:18 <Cale> albeit_: So a teeny tiny constant term looks big
19:09:28 <alexa_> okay, so, yes, totally different thing
19:09:29 <alexa_> got it
19:09:35 <alexa_> that's basically what lead me to the question.
19:10:57 <Cale> albeit_: You see all those CAFs in GHC.IO.* though. There are a bunch of constant expressions in there, things like setting up the text encoding and stuff to do with I/O handles
19:11:01 <dramforever> :t ()
19:11:02 <lambdabot> ()
19:11:07 <dramforever> :k () -- lol
19:11:08 <lambdabot> *
19:11:20 <dramforever> :k '()
19:11:21 <lambdabot> ()
19:11:46 <albeit_> Cale: But that all happens after the two timing calls, so shouldn't it not affect it?
19:12:13 <albeit_> And follow on... is there a way to pre-evaluate CAFs before the program is run? If they are constant expression, it seems like there should be a way to do so
19:12:49 <Cale> albeit_: I don't think there's a way to request all CAFs to be evaluated.
19:12:53 <dramforever> albeit_: if you can afford it... force that in the beginning of main
19:13:51 <albeit_> dramforever: How do I force a CAF?
19:14:16 <dramforever> albeit_: I guess fooCAF `deepseq` return () might do
19:15:33 <Cale> Well, most of these CAFs are in GHC.IO.*
19:15:48 <Cale> and may not even be in scope
19:16:27 <dramforever> oh
19:16:29 <dramforever> =P
19:17:30 <Cale> :q
19:17:37 <Cale> dang focus :P
19:17:44 <albeit_> So if I have a program that I want to be maximally performant when required, I should try and call every function that might be called at startup? To hopefully evaluate any and all CAFs?
19:18:14 <Cale> I'm not sure I'd be especially worried about them, but yeah, I guess.
19:19:22 <Cale> As always, you should go with what the profiler actually tells you about your program's performance.
19:19:50 <albeit_> Cale: And it seems to be telling me there are a bunch of CAFs that get evaluated on first runs ;)
19:20:09 <Cale> Well... this is only visible because we're doing essentially nothing at all
19:20:19 <Cale> So a very very short delay is noticeable
19:20:55 <albeit_> Well this popped up when timing a part of a larger program, and I know for sure there are tooons of CAFs, so its probably whats happening there too
19:21:28 <albeit_> First run ~90us and futures runs are ~10us, for example. I think it still lines up, because the delay is still relatively small to evaluate the CAFs, but there
19:22:35 <Cale> Compile with -prof -fprof-auto -fprof-cafs  and then run the program with +RTS -p
19:23:05 <Cale> It may not even be CAFs but even expressions in some intermediate scope
19:23:53 <Cale> There are a lot of reasons for the first iteration of anything to be slower than the rest under lazy evaluation, because you're potentially evaluating a lot of shared expressions for the first time
19:24:26 <Cale> and thereafter the result is being retained and reused
19:24:29 <albeit_> Okay. I was trying to reduce that by deepseq'ing all my data structures on startup, but I guess that only does so much.
19:24:39 <Cale> (which is good -- otherwise you'd pay every time)
19:25:05 <albeit_> What you say it may be expressions in some intermediate scope, what is "it"?
19:25:20 <Cale> I mean the reason for the first iteration to take longer
19:25:54 <Cale> Under lazy evaluation, any bound variable is evaluated at most once, and the resulting value is shared between the occurrences of the variable.
19:26:43 <Cale> So when you pass some expression as an argument to a function, if the corresponding function parameter occurs more than once or is otherwise used more than once in the body of the function, that argument will still be evaluated at most once.
19:27:17 <Cale> (it may be evaluated zero times of course)
19:27:18 <dramforever> any one thunk is evaluated at most once
19:27:23 <dramforever> right?
19:27:25 <albeit_> Okay. So when I do the profiling, I'm looking for a CAF cost-center(s) that takes up some decent portion of the processing time? That would indicate where the speedup on the second iteration is comign from?
19:27:39 <Cale> dramforever: Right, thunks being the runtime representation of expressions
19:27:41 <dramforever> because it wouldn't be a thunk after that right =P
19:28:02 <dramforever> Cale: oh well ghc might sometimes duplicate thunks
19:28:22 <Cale> albeit_: Well, look at everything :P
19:28:37 <Cale> albeit_: You might find that the CAFs aren't very significant after all, I don't know
19:28:54 <Cale> If you want, put the code and profile somewhere we can look at them
19:29:28 <albeit_> The code is... large. But if I'm able to reduce it and post I shall (though at a later time...)
19:29:59 <Cale> albeit_: Actually, you may want to go without the -fprof-cafs option at first
19:30:14 <Cale> albeit_: Without that option, all the CAFs are lumped together into a single cost-centre.
19:30:38 <Cale> (because usually we don't care too much about the time spent on CAFs because they're a constant term)
19:30:41 <albeit_> Cale: One more question. When you said that expressions in intermediate scope may be causing the initial slowdown, would those be non-CAF thunks that end up getting evalated just once on repeated calls of the function?
19:31:00 <Cale> Yeah, for example...
19:31:11 <albeit_> How would I notice if they were responsible for slow downs? Like how can I identify them?
19:31:34 <Cale> > let f x = map (x +) [1..1000] in f (product [1..100000])
19:31:37 <lambdabot>  mueval-core: Time limit exceeded
19:31:41 <Cale> > let f x = map (x +) [1..1000] in f (product [1..10000])
19:31:43 <lambdabot>  [284625968091705451890641321211986889014805140170279923079417999427441134000...
19:31:57 <Cale> The product will be evaluated once, and reused.
19:32:11 <Cale> So the first iteration there will take a lot longer
19:38:02 <Cale> albeit_: I suppose if you suspect that some subexpression in particular is responsible for a sizeable cost, you can add an {-# SCC "some unique name" #-} annotation before it, and it will show up in the profile separately.
19:38:28 * hackagebot Ebnf2ps 1.0.13 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.13 (FranklinChen)
19:38:42 <Cale> albeit_: and if this ends up being the case, you can try moving it out of whatever loop, binding it to a variable, and using seq/deepseq to force it beforehand.
19:38:58 <Cale> albeit_: I'm not sure I understand your concern for making the first iteration exactly as fast as the others...
19:39:47 <Cale> Usually the constant costs are the last thing you'd want to focus on with profiling :)
19:40:04 <rotaerk> anyone else feel like "haskell vim now" is a little too... monolithic?
19:40:24 <Cale> rotaerk: What's "haskell vim now"?
19:40:53 <rotaerk> Cale: https://github.com/begriffs/haskell-vim-now
19:41:33 <rotaerk> I installed it, which was *easy* though took forever, but it essentially took over vim..
19:42:02 <Cale> I guess I do, seeing as I don't use it, and instead use all sorts of other separate tools to accomplish the tasks it seems to be concerned with.
19:43:07 <rotaerk> hmm yea..
19:43:40 <alexa_> rotaerk: I wouldn't find such a thing attractive, personally
19:43:50 <alexa_> one of the reasons I use vim is because I don't like monolithic applications
19:44:03 <alexa_> I use multiple terminals for different things, I write in a different window than I lint etc
19:44:06 <albeit_> Cale: It's just the first time has to be as fast as possible, and if subsequent calls of the exact same function are faster, it must be as fast as possible...
19:44:12 <rotaerk> it's easy to install, but that doesn't make it necessarily any easier to learn
19:48:59 <albeit_> Cale: Thanks for the help!
19:52:03 <Cale> I honestly don't feel like I've been paid back for all the time I've spent learning stupid editor features
19:52:51 <shachaf> Cale: Maybe if you'd learned one more editor feature it'd all've been worth it.
19:52:56 <Cale> heh
19:53:17 <Pamelloes> Can my main module be something of them form xxx.Main?
19:53:43 <Cale> Pamelloes: You *can* change which module main is, but... why?
19:54:16 <Cale> Pamelloes: Usually you just leave the module declaration off of any .hs file which is intended to be an executable, and the module name defaults to Main then.
19:54:33 <felixn> that's probably a good measurement if an editor feature is worth learning, is if you have to learn it
19:54:47 <Pamelloes> Because all of my modules are in ApplicationName.*, so it feels weird to not have Main in that module as well
19:55:13 <Cale> Pamelloes: What does it matter? Nothing is going to import it.
19:56:47 <Pamelloes> It doesn't actually matter, I'd just prefer my module naming scheme to be homogenous and not have Main be sticking out. It's silly, I know, but I like having things like this be consistant.
19:56:57 <Cale> Where does it appear?
19:57:11 <shachaf> The answer is -main-is.
19:57:26 <dramforever> module Main (main) where import Application.Main
19:57:29 <dramforever> maybe?
19:57:29 <Cale> Like, normally it's completely transparent, because Main won't even appear in that module, you just won't have a module declaration at all.
19:57:49 <dramforever> oh wow we have -main-is
19:58:11 <Cale> yeah, -main-is can be used to set it, but it just adds a complication to building your program
19:58:16 <Pamelloes> Cale: when I go to edit the file it's vim src/Main.hs instead of src/ApplicationName/xxx for every other file
19:58:24 <shachaf> Cale: Putting Main.hs in a different directory is a different kind of complication.
19:58:29 <Cale> I guess
19:58:57 <Pamelloes> shachaf: is there a cabal flag or do I have to add that to ghc-options?
19:59:18 <shachaf> I don't know.
19:59:27 <Pamelloes> ok
20:02:03 <Pamelloes> shachaf: Hm, it doesn't seem to work with having Main in a differend directory
20:02:05 <Pamelloes> aw well :/
20:02:50 <andrevm> @topic
20:02:50 <lambdabot> Unknown command, try @list
20:02:51 <shachaf> I say it works.
20:03:08 <Pamelloes> Then it's probably just cabal being stupid.
20:18:29 * hackagebot pandoc-crossref 0.1.2.2 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.2.2 (lierdakil)
20:28:47 <ocramz> morning !
20:33:30 * hackagebot static-canvas 0.2.0.2 - DSL to generate HTML5 Canvas javascript.  http://hackage.haskell.org/package/static-canvas-0.2.0.2 (jeffreyrosenbluth)
20:34:59 <alexa_> Hey guys, I know this is probably a stupid question, but if I'm using stack, does there not exist a run command from within the project?
20:35:18 <alexa_> as in something that will build if changes exist, then call main?
20:35:47 <kaidelong> why do people complain about Haskell error messages when C++ exists
20:36:07 <kaidelong> seriously
20:36:13 <kaidelong> there is no comparison
20:36:39 <dramforever> kaidelong: I guess it's because they scare off newbies
20:36:48 <dramforever> rather than make newbies ask
20:37:28 <kaidelong> oh, wrong channel, sorry
20:47:33 <alexa_> Hello haskell friends. Someone told me this yesterday and I didn't save it, and cannot find it in docs... How do you tell stack to build and run tests on file change?
20:47:50 <felixn> http://projects.haskell.org/diagrams/haddock/Diagrams-TwoD-Shapes.html#v:septagon <-- subtle humor :D
20:48:14 <dramforever> alexa_: "someone" told you here?
20:48:30 <felixn> alexa_: http://ircbrowse.net/browse/haskell?q=alexa_
20:48:34 <dramforever> if so check logs :P they are in the topic
20:49:07 <alexa_> dramforever: looking, thanks guys
20:49:14 <dramforever> =)
20:49:59 <alexa_> I rarely read topic messages to know that I should echo it to myself for the link ;)
20:51:20 <alexa_>  stack test --file-watc
20:51:22 <alexa_> yay!
20:51:56 <alexa_> oh shit now I need to figure out how to make it ignore *.swp files
20:53:08 <pacak> alexa_: If that's for vim - you should be ignoring *.sw? 
20:54:49 <alexa_> pacak: vim, and it is indeed .swp
20:55:05 <alexa_> but I'm not sure of the syntax for the ignore since I'm having trouble finding file-watch docs
20:55:09 <citizen11> anyone know of a codeacademy place for haskell?
20:55:14 <felixn> http://projects.haskell.org/diagrams/haddock/Diagrams-TwoD-Arrow.html <-- I'm feeling some sexual undertones in this documentation
20:55:15 <dramforever> sw* I guess?
20:55:26 <pacak> alexa_: "sw?", or "sw*"
20:55:43 <alexa_> *.swp is what I wish to ignore.
20:55:58 <alexa_> I have never ever seen my vim generate the legendary .swo
20:56:16 <dramforever> try starting two "empty" vim's
20:56:16 <pacak> I've seen them, but it's up to you.
20:56:30 <alexa_> ah, maybe that's why. I only ever run once instance of vim.
20:58:41 <alexa_> I think I might just have to deal with it for now. I don't think --file-watch supports arguments.
20:59:18 <bananagram> my home directory has .swp through .swb...
20:59:25 <bananagram> should clean those up
20:59:28 <alexa_> haha
21:03:20 <alexa_> I think I'll just accept the pain for now.
21:03:58 <jle`> was going to convert Data.Time.Calendar.Day values into Int's or something so i can use Data.Ix stuff on it 
21:04:04 <jle`> but it turns out Day has an Ix instance
21:04:16 <jle`> now i'm indexing vectors and arrays on dates
21:04:25 <jle`> typeclasses are interesting
21:04:56 <dramforever> huh?
21:05:00 <dramforever> wow!
21:10:50 <yayfoxes> Cale, I deleted all my files accidentally and i need that book back
21:13:33 * hackagebot bound 1.0.6 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0.6 (EdwardKmett)
21:15:30 <Welkin> yayfoxes: downloading your files back from the leechers?
21:17:07 <pdxleif> Do people have a favorite simple web lib on top of WAI?
21:17:29 <pdxleif> I had an app directly on WAI 2. WAI 3 looks even more low-level.
21:17:39 <pdxleif> Maybe writing my own session handling support is good for the soul...
21:19:45 <yayfoxes> lol Welkin, is this product? product (x:[]) = (*x) product (x:xs) = x * product xs
21:20:38 <tedkornish> pdxleif: I'm a fan of Scotty
21:20:57 <tedkornish> Also, does anyone know of an open-source codebase which uses the reflex FRP library?
21:21:08 <tedkornish> I'm having trouble understanding proper usage from the hackage docs by themselves
21:22:22 <pdxleif> tedkornish: That was my first thought. Think I've seen people use it, and some others in that category.
21:23:15 <pdxleif> I just get all cantankerous when those kind of libraries feel like making choices for me; tying my hands just to get some cute syntax or something.
21:26:00 <yayfoxes> Cale, I need help writing product'. it takes a list and r
21:26:15 <yayfoxes> produces a product of each of its numbers
21:26:46 <Welkin> yayfoxes: write out the function using math notation
21:26:54 <Welkin> then you will be 90% there
21:27:05 <yayfoxes> I don't know math
21:27:28 <Welkin> well your explanation is unclear
21:27:31 <Cale> yayfoxes: Okay, so the product of an empty list is 1
21:27:45 <yayfoxes> Cale, tried that, ok good
21:28:04 <Cale> yayfoxes: and the product of a nonempty list whose first element is x is x times the product of the rest of the elements of the list
21:28:06 <yayfoxes> what to do for product' (x:[]) ?
21:28:11 <Cale> nothing special
21:28:13 <yayfoxes> oh wait
21:28:13 <Welkin> oh, you mean the product of a list
21:28:39 <yayfoxes> LOL nothing special :)
21:28:48 <yayfoxes> two lines of code LOL
21:29:24 <Cale> (x:[]) should be handled by the (x:xs) case
21:29:28 <Cale> with xs = []
21:29:42 <yayfoxes> yes, that is clear now
21:29:54 <Welkin> > foldr (*) 1 [1,2,3,4]
21:29:55 <lambdabot>  24
21:30:03 <Welkin> > foldr1 (*) [1,2,3,4]
21:30:05 <lambdabot>  24
21:30:21 <yayfoxes> wow, how do you make it faster?
21:30:23 <jle`> yayfoxes: so plugging into the definition, product (x:xs) = x * product xs.  so product(x:[]) = x * product []
21:30:38 <jle`> yayfoxes: it looks like the only thing missing then is product [] = ???
21:30:59 <yayfoxes> or product [] = 1
21:31:22 <yayfoxes> so the final step is x * 2
21:31:27 <yayfoxes> mean x * 2
21:31:33 <yayfoxes> grr, x * 1
21:31:38 <pacak> :t cata
21:31:39 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
21:31:39 <jle`> yup
21:31:52 <jle`> congrats!
21:32:36 <yayfoxes> how do you get experience in just sitting down and designing the logic, and from the logic, the function definitions?
21:32:49 <yayfoxes> by saying the logic I might be going too far
21:33:05 <jle`> for cases like this it helps to just write down the constructors of the type in question and handling each case
21:33:07 <Welkin> break it down into a series of steps, then combine them together int oa pipeline
21:33:13 <jle`> for lists you just have [] and x:xs
21:33:15 <jle`> so just write:
21:33:18 <jle`> product [] = ????
21:33:23 <jle`> prodcut (x:xs) = ????
21:33:26 <Welkin> or, when writing a recursive function, write the base case first, then take care of all the other cases
21:33:33 <adarqui> well for something like product, start with your expected input/outputs and your terminating condition(s)
21:35:26 <yayfoxes> does Hexchat log IRC convos or do I have to dig up the logs on the internet?
21:35:35 <adarqui> writing doctests first is nice too.. so, you write your doctest:
21:35:40 <adarqui> >>> product [1,2,3,4]
21:35:42 <adarqui> 24
21:35:52 <adarqui> >>> product []
21:35:52 <adarqui> 0
21:36:13 <jle`> i'm not sure about hexchat, but the logs in this channel are in the topic up there ^^
21:36:24 <adarqui> then you can run doctest on your source, see it break.. then code in your product function and get it to work
21:36:48 <yayfoxes> is product [] = 1 necessarily wrong?
21:36:57 <yayfoxes> shouldn't it be 0?
21:37:35 <adarqui> could even be a Left "error" hehe
21:38:31 <yayfoxes> ok guys, for the qsort algorithm how do you modify it so it's a reverse sorted list that comes back up on the screen?
21:38:32 <adarqui> but ya, 1 makes more sense.. since if you multiply by your terminal condition with 1, you keep your result.. instead of multiplying it by zero
21:38:35 <adarqui> ;f
21:38:35 * hackagebot ad 4.2.3 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2.3 (EdwardKmett)
21:38:42 <exio4> yayfoxes: product [] = 0? I'd like product (xs ++ ys) to be equal to product xs * product ys 
21:39:01 <yayfoxes> exio4, ah
21:39:34 <exio4> yayfoxes: product (xs ++ []) == product xs , product (xs ++ []) == product xs * product [] ; thus product xs = product xs * product [] 
21:40:11 <yayfoxes> wow
21:41:38 <exio4> you can even derive the function with that `law`, I think
21:42:01 <exio4> (basically, doing the inverse of the proof by induction?) 
21:42:02 <yayfoxes> I gotta go to bed, I'll see you guys later
21:42:09 <jle`> yayfoxes: the "empty product" (product of no numbers) being 1 is a useful choice in many fields in math
21:42:11 <jle`> :)
21:42:23 <jle`> night!
21:42:29 <adarqui> gn jle` 
21:42:43 <adarqui> o
21:42:47 <adarqui> gn yayfoxes 
22:01:29 <adarqui> glad my haskell roulette fell on the 'keys' library tonight
22:02:43 <tedkornish> adarqui: haskell roulette?
22:05:22 <adarqui> sounds cool right? just picks a random lib out of my stackage cabal.config.. then i pull down the lib and read it/do some code with it.. tehe
22:06:03 <scutigera>      inputStr <- hGetContents inh
22:06:03 <scutigera>      let x = case parseIt inputStr of
22:06:07 <tedkornish> That's awesome! Figured as much from the name, but still curious. How long have you been making a habit of it?
22:06:19 <scutigera> Couldn't match expected type ‘T.Text’
22:06:19 <scutigera>                 with actual type ‘Data.Text.Internal.Lazy.Text’
22:06:19 <scutigera>  
22:06:39 <scutigera> i'm not using anything lazy- but getting that type error...
22:06:50 <scutigera> sorry- not intentionally using anything lazy...
22:06:56 <adarqui> tedkornish: about two weeks! instead of just constantly trying to code stuff i need to get better at reading other people's code, and learn from it etc
22:06:59 <adarqui> so that's why i'm doing it
22:07:14 <scutigera> my code will give you a challenge :-)
22:07:28 <tedkornish> Makes sense - in most environments you spend a lot more time reading code than writing it, and writing unprincipled code is still less than optimally productive anyways.
22:08:12 <adarqui> scutigera: parseIt requires lazy text stream? something has to be of type lazy text no? dno
22:08:25 <adarqui> tedkornish: ya
22:08:27 <tedkornish> scutigera, are you importing a text library as `T`?
22:08:33 <scutigera> yes.
22:08:43 <tedkornish> Which text library?
22:08:50 <scutigera> import qualified Data.Text as T
22:08:58 <tedkornish> I bet you this is as simple as a simple lazy to strict conversion.
22:09:08 <scutigera> but why should i have to ?
22:09:23 <scutigera> seems like there's something wonky here
22:09:36 <scutigera> attoparsec is deciding that i'm really using lazy text when i'm not
22:09:41 <scutigera> or something.
22:10:02 <tedkornish> I wouldn't be surprised if attoparsec is deciding to use lazy text for performance reasons, though I'm not sure.
22:10:26 <tedkornish> Maybe running something through `Data.Text.Lazy.toStrict` would solve the problem?
22:11:25 <scutigera> that's very frustrating. there's no reason they should be getting mixed.
22:11:40 <scutigera> nothing has a type which indicates use of lazy text
22:11:48 <shachaf> There are no magical decisions.
22:11:58 <scutigera> and if it's happening behind the scenes and then bleeding out into my code- that seems incredibly broken
22:11:59 <shachaf> There are two distinct types, Data.Text.Text and Data.Text.Lazy.Text
22:12:20 <adarqui> there's not much lazyness in the attoparsec package either.. takeLazyText and such
22:12:23 <adarqui> it seems
22:12:25 <shachaf> They work like any other pair of distinct types. You can't mix them. That's all.
22:12:37 <adarqui> scutigera: lpaste?
22:12:38 <adarqui> ;f
22:12:44 <scutigera> well i'm looking at Data.Text now
22:12:45 <shachaf> Just look at the types of each of the things you're using and see which one of them uses Lazy Text.
22:12:53 <scutigera> and it's Data.Text and Data.Text.Lazy
22:12:58 <scutigera> and i'm not using Lazy
22:13:10 <shachaf> The universe must be conspiring against you.
22:13:24 <scutigera> http://lpaste.net/136264
22:13:41 <scutigera> shachaf: my point exactly. lol.
22:15:08 <scutigera> adarqui: just updated with exactly error message.
22:15:53 <adarqui> force type sig on parseIt
22:15:57 <adarqui> for a test
22:16:21 <adarqui> also i don't see the error you pasted in here, in there.. the lazy text one. you meant you updated it with that?
22:16:24 <adarqui> ooh
22:16:24 <adarqui> i see it now sorry
22:16:31 <adarqui> scutigera: force the type sig
22:16:50 <scutigera> adarqui: yeah- trying to figure out what it should be...
22:17:55 <adarqui> cabal repl it, and :t it, might surprise u.. also, it might be like, parseIt :: T.Text -> Result a <-- fill in the a
22:18:05 <Pamelloes> Is there a way to pass a set of monad transformers through a liftIO call?
22:18:14 <scutigera> wait- wtf- it just compiled...
22:18:17 <scutigera> without the type
22:18:25 <scutigera> the universe IS out to get me
22:18:37 * hackagebot quiver-csv 0.0.0.1 - Quiver combinators for cellular CSV data processing  http://hackage.haskell.org/package/quiver-csv-0.0.0.1 (patrykz)
22:18:57 <scutigera> uh- that's totally messed up.
22:19:30 <scutigera> adarqui: you can see that error message. i tried to establish the type. couldn't figure it out, commented out the line and the next time I did :r it worked.
22:19:33 <scutigera> aaaaaargh
22:19:42 <adarqui> type signatures will save you.. i mean, maybe it's somehow using the lazy text type signature for parse, instead of the strict text one.. I have no clue why that would be but: Data/Attoparsec/Text/Internal.hs vs Data/Attoparsec/Text/Lazy.hs for example, both have parse.. one strict, one lazy
22:20:00 <scutigera> parseIt :: T.Text -> Result [LineTypes]
22:20:07 <adarqui> word!
22:20:29 <scutigera> courtesy of GHC of course.
22:20:34 <adarqui> for fun, import qualified Data.Attoparsec.Text.Lazy as L .. and do, parseIt :: L.Text -> Result [LineTypes]
22:20:41 <adarqui> see if you get your previous error message
22:21:42 <scutigera> oh - i get a bazillion error messages
22:21:48 <scutigera> it really doesn't lik ethat...
22:21:51 <adarqui> ha
22:22:15 <adarqui> ok cool well, with the explicit type sig, it's working?
22:22:39 <scutigera> uh- it worked WITHOUT the explicit type sig.
22:22:48 <scutigera> but yeah- works with it too- so there's that.
22:23:45 <scutigera> ok that's weird
22:23:57 <adarqui> odd how it didn't before, and does now.. but ya, seems like SOMEHOW it was using parse from Data.Attoparsec.Text.Lazy .. turns out the universe was truly out to get you, or shachaf logged into your box and patched your ghc.
22:24:23 <Zemyla> Okay, question. This page https://csks.wordpress.com/2012/10/22/safe-polykinded-universally-quantified-constraints-part-3-of-3/ attempts to derive a Forall on constraints by using a type like p (Skolem p).
22:24:25 <scutigera> my home directory is nfs mounted. i wonder if i had some weird stale file thing.
22:24:57 <scutigera> and the newly written file wasn't registering. i _did_ exit ghci and reload and that didn't seem to help.
22:25:13 <adarqui> your nfs ever lockup? on some stale file handle or permanently blocked syscall?
22:25:17 <Zemyla> Is there a way to, for instance, define a type like Skolem (f :: * -> *), derive Eq (f (Skolem f)) => Eq (Skolem f), and use that somehow to derive Eq1 f?
22:25:44 <scutigera> NFS: nfs4_reclaim_open_state: Lock reclaim failed!
22:25:46 <scutigera> hmmmm....
22:26:08 <adarqui> wrecked.. sadface@nfs
22:26:27 <scutigera> well- everything seems to be ok. i wonder if it's a problem due to coming out of suspend.
22:26:33 <scutigera> anyway- badly off topic
22:26:55 <scutigera> back on topic : parseTest double $ T.pack "999"
22:27:01 <scutigera> Partial _
22:27:03 <scutigera> ???
22:27:25 <adarqui> i dealt with that the other night... was torture. the only thing I could do was use parseOnly
22:27:48 <adarqui> Run a parser that cannot be resupplied via a 'Partial' result.
22:27:58 <adarqui> fixed my issues with that Partial _
22:28:00 <adarqui> result
22:28:18 <alexa_> Haskell still blows my mind with how simply declarative the syntax is
22:28:31 <scutigera> wow attoparsec sure is a pain in the ass
22:28:50 <adarqui> it's a pain in the ass until we figure out how to use it. lul
22:29:01 <scutigera> double is the built-in number parser, you'd think it would work with parseTest.
22:29:51 <scutigera> To indicate that you have no more input, supply the Partial continuation with an empty Text.
22:29:51 <scutigera>  
22:29:51 <scutigera>  
22:33:08 <dramforever> scutigera: yes what do you want to do?
22:33:34 <scutigera> i want parseTest double $ T.pack "999." to print 999.0
22:33:51 <scutigera> so i'm writing a function now to dispatch on the IResult
22:33:59 <dramforever> what do you mean by posting that?
22:34:17 <scutigera> i'm getting : Partial _ 
22:34:20 <dramforever> maybe parseOnly ?
22:34:47 <dramforever> something like http://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#v:parseOnly
22:35:01 <scutigera> right- i'm looking at that now...
22:35:02 <dramforever> I think the text-based module also has this
22:36:54 <scutigera> dramforever: yes - that's the ticket. case r of Left etc...
22:37:01 <dramforever> :)
22:37:09 <scutigera> on the results of parseOnly. Thank you
22:37:18 <dramforever> yw =)
22:37:22 <scutigera> what's the purpose of parseTest then ?
22:38:33 <scutigera> well- something i'll have to ponder on tomorrow.
22:46:08 <alexa_> Probably stupid question, but... What's the accepted norm for indentation levels in haskell? 2 or 4 spaces?
22:46:13 <alexa_> 4
22:46:15 <alexa_> ?
22:48:26 <Zemyla> alexa_: I've seen some 2s and some 4s. I don't know if there's a standard or anything.
22:48:39 <liste> alexa_ many align rather than indent
22:49:06 <liste> depends of the situation of course
22:50:33 <alexa_> kay thanks guys
22:50:49 <jle`> i think if you find your own style and stick to it, nobody will complain :)
22:51:00 <jle`> i have my own bit of ad-hoc style myself >_>
22:51:04 <alexa_> I tend to use 2 for most languages, but I'm looking around and 4 seems pretty common
22:51:09 <alexa_> I'll probably go with 4 in haskell
22:51:18 <Zemyla> Nobody will complain? On the Internet? You must be new here.
22:51:19 <adarqui> i see 2 more than 4
22:51:36 <alexa_> really? well, hell I guess I get to be spoiled and keep my 2.
22:51:41 <adarqui> just looking at kmett libs, mostly 2.. and bos libs, a mix between 4 and 2, 4 for module exports/class definitions, 2 for code
22:52:01 <jle`> i do 4 for the initial indent and 2 ever after
22:52:16 <jle`> let blocks make you indent 4 to make the compiler happy
22:53:24 <alexa_> All I know is the abolition of tabs in haskell fills me with self-righteous glee.
22:54:05 <jle`> :)
22:54:06 <adarqui> same ;f
22:54:34 <alexa_> if that's not a reason to use haskell I don't know what is
22:55:20 <jle`> i can probably name a few :)
22:55:38 <alexa_> I dunno, self-righteous glee is a strong emotion.
23:00:29 <Haskellfant> can I use the Connection in sqlite-simple from multiple (haskell) threads?
23:13:20 <adarqui> dno, looks like it's using direct-sqlite under the hood. in there, Direct.open returns a IO .. Ptr.. no idea ;f
23:13:41 <adarqui> newtype Database = Database (Ptr CDatabase)
23:13:57 <Haskellfant> adarqui: yeah that's as far as I got. I assume I probably shouldn't use it from multiple threads
23:14:20 <adarqui> ya if i had to bet money on it.. doesn't look too threadsafe, that was my hunch on it
23:16:40 <adarqui> if that is the case.. you could perhaps make an execSafe function which uses an MVar to synchronize access to that Database handle.. u know?
23:16:57 <Haskellfant> yeah, I was just trying to avoid this because I'm lazy
23:17:00 <adarqui> execSafe :: MVar Database -> Text -> IO () which calls exec
23:17:04 <adarqui> cool ;f
23:17:15 <Haskellfant> thanks for your help
23:17:23 <adarqui> sure np!
23:17:24 <alexa_> Can I safely think of a where binding as basically being a nested scope level within a function body?
23:17:36 <alexa_> wherein one can define nested functions(closures) etc etc etc?
23:18:30 <EponymicCycloid> Is is possible to use `GeneralizedNewtypeDeriving` on `MultiParameterTypeClasses`? Specifically, I'm making a newtype wrapper `Neuron a` for a `Vector a`, and I would like to automatically derive an instance for `Data.Vector.Generic.Vector Neuron a`, because doing it manually is a pain in the ass.
23:19:13 <Axman6> quite possibly. I've used things like deriving (MonadState Int) before
23:19:48 <adarqui> alexa_: you can definitely nest your where's and they scope.. and those all fall under the scope of the function so
23:20:14 <alexa_> adarqui: so decent analogue for the time being until my brain fully inegrates the differences(if any)?
23:20:34 <adarqui> wut ;f
23:21:01 <alexa_> where clauses ~> block scope levels in other functional block scoped languages
23:21:03 <alexa_> Sort of kind of
23:21:16 <alexa_> Until my brain understands a distinct concept of a "haskell where clause"
23:21:27 <adarqui> i always picture them as let's, at the top
23:21:32 <adarqui> so maybe that helps?
23:21:46 <adarqui> let in's
23:21:48 <adarqui> yo brb!
23:21:51 <alexa_> :P
23:25:02 <EponymicCycloid> Damn. "We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter."
23:25:24 <EponymicCycloid> The newtype is the first param... 
23:26:45 <EponymicCycloid> Is there such a thing a constraint synonym?
23:26:56 <EponymicCycloid> *as a
23:27:08 <alexa_> Anyone have know of any good haskell learning exercises? I'm reading through LYAHFGG but could do with exercises to reinforce my knowledge. I might just do some project euler otherwise
23:27:36 <MarcelineVQ> euler is good but have a look here: https://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
23:27:46 <MarcelineVQ> there's exercises to do after each reading
23:28:00 <alexa_> thanks MarcelineVQ 
23:29:08 <liste> alexa_ I suppose where is pattern scoped
23:29:37 <alexa_> yeah it looked like let in is local scope and where in is pattern scope
23:29:48 <alexa_> I'm sure I'll assimilate the exact nature over time
23:29:59 <alexa_> I just wanted a mental analogue to work with and apply when reasoning about things
23:30:03 <alexa_> And refine it as I go
23:30:26 <EponymicCycloid> No go using Constraint synonyms a la ConstraintKinds. I get `Illegal deriving item ‘MyGeneric a’`
23:32:45 <kadoban> alexa_: The haskell report is pretty readable compared to many language specifications. I'm sure it'd have a precise definition of the scope of a 'where'
23:33:35 <Cale> Yeah, where scopes over multiple guards
23:33:40 * hackagebot buffer-builder 0.2.3.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.3.0 (chadaustin)
23:34:28 <Cale> (but not over multiple patterns, the variables bound by the matched pattern are in scope in the where block)
23:42:05 <tedkornish> You can get around where not scoping over multiple patterns by replacing pattern matching syntax with a case...of statement.
23:42:13 <tedkornish> the former is, after all, syntactic sugar for the latter
23:43:56 <liste> and -XLambdaCase makes it prettier (:
