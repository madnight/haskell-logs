00:07:37 * hackagebot deterministic-game-engine 0.1.0.0 - Simple deterministic game engine  http://hackage.haskell.org/package/deterministic-game-engine-0.1.0.0 (tgolson)
00:07:37 * hackagebot hpack 0.4.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.4.0 (SoenkeHahn)
00:18:40 <kqr> does lens-family have lenses for tuple elements?
00:20:11 <kqr> I guess not. though it's not a big deal in my case since I can just replace "ls . _2 %~ f" with "ls %~ second f"
00:36:25 <ronh> kqr hmm, aren't _1 _2 _3 lenses for tuple elements?
00:39:11 <kqr> ronh, not in `lens-family`, only in `lens` :)
00:40:48 <kqr> (using lens-family instead of lens to convince irrational acquiantances that lenses don't have to mean you have to wait for half an hour compile times =) )
00:42:31 <ronh> oh, I missed less-family being mentioned 
01:34:21 <tamasgal> @pl \f g x y -> f (x ++ g x) (g y)
01:34:21 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
01:37:34 * hackagebot genders 0.1.0.0 - Bindings to libgenders.  http://hackage.haskell.org/package/genders-0.1.0.0 (MathieuBoespflug)
01:42:03 <breadmonster> Is there a way to statically guarantee the lengths of lists?
01:42:17 <breadmonster> Something like dependent types?
01:42:27 <dramforever> yes
01:42:34 <breadmonster> How?
01:42:59 <mniip> you can make a GADT
01:43:27 <dramforever> data Vec :: Nat -> * -> * where Nil :: Vec Z a ; Cons :: a -> Vec n a -> Vec (S n) a
01:43:40 <dramforever> where S is nat succ, Z is nat zero
01:43:42 <breadmonster> Fantastic.
01:44:25 <breadmonster> dramforever: What's the performance? I'm trying to build a library for exponential trees.
01:44:55 <dramforever> breadmonster: IIUC as good as normal data []
01:45:06 <breadmonster> IIUC?
01:45:13 <dramforever> If I understand correctly
01:45:19 <dramforever> or any tense
01:45:24 <breadmonster> okay.
01:45:33 <breadmonster> fantastic, actually.
01:45:37 <dramforever> yay
01:46:03 <breadmonster> What extensions do I need to use Nat?
01:46:41 <dramforever> DataKinds and data Nat = Z | S Nat
01:46:53 <dramforever> and GADTs for gadts
01:47:34 * hackagebot genders 0.1.0.1 - Bindings to libgenders.  http://hackage.haskell.org/package/genders-0.1.0.1 (MathieuBoespflug)
01:47:51 <dramforever> hmm....that happens all the time
01:48:05 <dramforever> 2 releases in a row
01:49:30 <Ainieco> hello
01:49:40 <dramforever> Ainieco: yes?
01:49:42 <Ainieco> will OverloadedRecordFields land in 9.10.2?
01:49:56 <Haskellfant> are you talking about 7.10.2?
01:50:06 <Ainieco> ugh, yes
01:50:15 <dramforever> IMO unlikely
01:50:28 <Haskellfant> it's only a minor release. afaik it's planned for 7.12
01:50:35 <Haskellfant> so it might be in 9.10.2 :)
01:50:49 <Ainieco> ha-ha, i hope it won't be in 9
01:50:58 <Ainieco> waited for it for so long already
01:51:17 <dramforever> Ainieco: lens?
01:51:20 <Ainieco> no
01:51:21 <dramforever> maybe?
01:51:40 <dramforever> yeah we badly need need lens-core :P
01:52:02 <edwardk> https://github.com/ekmett/lens/wiki/faq#lens-core
01:52:17 <dramforever> edwardk: actually i'm aware of it
01:52:26 <breadmonster> edwardk: You should automate that, it's a (FA)^2Q.
01:52:26 <dramforever> so I wrote ":P"
01:53:03 <dramforever> and that's where I got the name "lens-core"
01:53:48 <edwardk> =)
01:55:12 <saulzar_> Is this http://lpaste.net/135788 a good way to constrain a hierarchy (html) with phantom types? I've not much experience with this kind of thing, but it seems to work okay.
01:56:04 <saulzar_> Using a type family to constrain which child/parent relationships are allowable, I'm guessing the same thing could be done with typeclasses but I was worried that there might be situations where you'd want a disjunction ...
01:57:09 <dramforever> saulzar_: consider making a new kind data HtmlElement = Body_ | Div_ | ...
01:57:18 <dramforever> *maybe consider
01:57:27 <dramforever> ...
02:01:00 <saulzar_> dramforever, Ah yes, will give it a play
02:05:32 <saulzar_> I was looking around for another example of such a thing - but I couldn't find one
02:12:35 * hackagebot sparse 0.9.2 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.9.2 (EdwardKmett)
02:16:20 <lunaris> Getting "undefined symbols for architecture x86_64" when building on OSX -- using stack build if that matters; any ideas?
02:16:31 <lunaris> Wondering if it's the game where I have to expose all private modules.
02:20:33 <jiada> quit
02:48:27 <joco42_> Guest33674: is spamming me
02:50:30 <dramforever> joco42_: consider calling freenode staff
02:52:37 * hackagebot cgrep 6.4.15 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.15 (NicolaBonelli)
03:03:35 <joco42_> dramforever: is he spamming you too ?
03:03:39 <joco42_> in pm?
03:03:44 <dramforever> joco42_: no
03:04:02 <dramforever> but I saw one earlier and someone told me to do that
03:04:22 <joco42_> dramforever: ok, i keep in mind
03:04:28 <dramforever> spamming in pm is really...annoying
03:17:38 * hackagebot minisat 0.1.2 - A Haskell bundle of the Minisat SAT solver  http://hackage.haskell.org/package/minisat-0.1.2 (JeroenBransen)
03:32:38 * hackagebot ViennaRNAParser 1.2.1 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.2.1 (FlorianEggenhofer)
03:43:22 <meditans> hi all, I have a problem with the Chart library
03:44:03 <meditans> I'm trying to plot list of points in a 2D plot, but I want the x axis to go between 0 and 2 * pi
03:44:21 <meditans> so I tried inserting: layout_x_axis . laxis_generate .~ scaledAxis def (0, 2*pi)
03:44:43 <meditans> but the problem is that the plot, when plotted, goes from 0 to 7
03:45:14 <meditans> I mean, the points do go up to 2*pi, but the plot continues,empty, till 7
03:45:36 <meditans> do you have any suggestion?
03:47:39 * hackagebot ClustalParser 1.1.2 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.1.2 (FlorianEggenhofer)
03:51:01 <kgadek> hi. anyone uses 'stack' here? I'm wondering how to incorporate protocolbuffer files compilation into the process
03:51:18 <Beardful> I deleted .cabal, which means I should have a fresh install, and now I can't cabal install GPipe. What up w/ dat?
03:54:04 <kuribas> Beardful: I think you also need to delete .ghc
03:54:17 <Beardful> kuribas: Will try.
04:07:50 <m_ryan> hi can anyone help me about yesod esqueleto here is my problem: http://lpaste.net/135712
04:10:32 <Tuplanolla> You might want to ask #yesod if such a channel exists, m_ryan.
04:11:30 <m_ryan> Tuplanolla: i ask already still waiting :)
04:12:23 <whiteline> so it turns out the new cabal depends on directory which depends on new cabal
04:12:33 <whiteline> how do i get out of circular dependency loops like this?
04:13:05 <dramforever> whiteline: I believe the two "new"s are not the same
04:13:28 <whiteline> dramforever: well, it says "Cabal libraries"
04:13:39 <whiteline> can't find anything like that in cabal list
04:14:12 <dramforever> forget about it...
04:14:16 <dramforever> I don't know
04:16:25 <pavonia> m_ryan: I not familiar with the packages you use, but it looks like StrainsId isn't translated correctly to the internal SQL query string. Did you write any instances for the type of StrainsId by hand that could be missing the ID string?
04:16:30 <whiteline> bah, i'll just make a sandbox and see what happens
04:17:55 <m_ryan> pavonia: StrainsId is in my model.
04:18:35 <pavonia> So that's all auto-generated?
04:19:27 <breadmonster> Is there a way to do low level stuff in Haskell?
04:20:03 <breadmonster> In particular: how do I ensure that certain assembly commands are emitted when compiling on specific platforms?
04:20:25 <breadmonster> Like Haswell processors have stuff like PEXT and PDEP, and so on?
04:20:40 <pavonia> You can always call C functions via the FFI
04:20:40 <m_ryan> pavonia: yes
04:22:07 <merijn> breadmonster: GHC has some primitives for things like vector operations
04:22:24 <breadmonster> merijn: Sure, but otherwise?
04:22:41 <breadmonster> I was thinking of implementing fusion trees, but they require a fair bit of bit twiddling.
04:22:41 <merijn> breadmonster: Otherwise you have to go via C
04:22:58 <merijn> GHC has a fair bit of bit twiddling primitives too, afaik
04:23:13 <kuribas> breadmonster: look at Data.Vector, which is quite efficient.
04:23:22 <pavonia> m_ryan: No idea then, sorry
04:23:25 <breadmonster> kuribas: Will do, thanks.
04:23:33 <breadmonster> merijn: What libraries are they in?
04:23:57 <kuribas> breadmonster: It uses fusion, type families and unboxed types for maximum efficiency.
04:23:58 <merijn> Dunno of the top of my head
04:24:36 <m_ryan> pavonia: it's ok still hoping for the other for me to help :)
04:24:48 <Beardful> Is there a global cabal library (for all users), because I removed all cabal related directories, but installing GPipe still leads me to cabal hell.
04:29:04 <merijn> Beardful: "still leads to cabal hell" is not a problem description. What error are you getting? Isn't GPipe just bitrotted?
04:31:56 <Beardful> merijn: "Backjump limit reached" seems like the problem.
04:32:59 <merijn> Beardful: Computing a coherent set of dependencies is an NP-complete problem, so by default if it takes to long to find a dependency set cabal just gives up.
04:33:22 <merijn> Beardful: iow, the dependency set of GPipe is so big cabal isn't able to compute a set of dependencies that works
04:33:37 <merijn> Bitrot seems likely
04:33:41 <merijn> The last version is from 2012
04:33:52 <Tuplanolla> The same applies to Hakyll.
04:34:00 <Tuplanolla> You can try --max-backjumps -1 if you have enough memory and patience.
04:43:25 <Beardful> Is there an alternative for GPipe maybe?
04:44:13 <dramforever> hmm...cabal hell...
04:44:49 * dramforever remembered someone asking about "weird referential transparency problem", which turned out to be a type error
04:48:13 <Haskellfant> hm what do the arrows from Control.Arrow correspond to in category? it looks like without 'arr' the tuple stuff represents products and the arrows themselves exponentials so it represents a ccc and arr is a functor that is the identity on objects and arr on morphisms. does this make sense or am I missing something?
04:49:28 <Haskellfant> s/category/category theory/
04:57:41 * hackagebot regex-applicative 0.3.2 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.2 (RomanCheplyaka)
04:58:02 <ParahSailin_> mauke: do you mind if i post a version of printf-mauke that is compatible with utf8-string 1 to hackage?
04:58:25 <supki> Haskellfant: there's a paper about what Arrows are
04:58:36 <supki> Haskellfant: http://www-kb.is.s.u-tokyo.ac.jp/~asada/papers/arrStrMnd.pdf
04:58:49 <Haskellfant> supki: cool, thanks
05:00:35 <sailorswift> What is "<-" used for? I'm having difficulties googling it since google seems to just ignore it
05:00:46 <dramforever> try hoogle maybe?
05:00:53 <sailorswift> I'm assuming it's assigning the variable on the left side
05:00:57 <dramforever> iirc haskell.org/hoogle
05:01:06 <dramforever> sailorswift: it's special syntax in do notation
05:01:09 <sailorswift> Ahh, that worked perfectly. Thank you
05:01:39 <dramforever> sailorswift: it seems that you are a beginner :)
05:04:02 <lunaris> Rational: bad choice for money or not? Is it universally agreed that one should use fixed point and consistently apply (e.g) bankers' rounding to every calculation?
05:04:47 <lunaris> I could e.g. do Integer cents, but then there's division; looked at e.g. Data.Scientific but it has warnings about divergence for certain division etc.
05:05:01 <Taneb> lunaris, http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Fixed.html#t:Centi
05:05:07 <sailorswift> dramforever: Yep! Reading through code atm to learn before attempting a project
05:05:31 <dramforever> sailorswift: whoa, what are you reading?
05:05:43 <sailorswift> Nothing too crazy, https://github.com/elisehuard/game-in-haskell/blob/master/src/StateFRP.hs#L42
05:05:47 * dramforever is interested
05:06:28 <dramforever> whoa that's "nothing too crazy"?
05:06:32 <dramforever> it's FRP!!!
05:06:44 <lunaris> Taneb: But that will introduce rounding, right?
05:06:57 <Taneb> lunaris, yes, I think so
05:07:11 <dramforever> sailorswift: looks like you need to learn more
05:07:12 <lunaris> I mean, bankers' rounding will be unbiased.
05:07:19 <dramforever> btw good luck :)
05:07:33 <sailorswift> Thank you !
05:07:38 <dramforever> y
05:07:39 <dramforever> yw
05:07:45 <lunaris> But does that necessarily imply that all possible sequences of operations end in the same result
05:07:47 <lunaris> ?
05:08:09 <Taneb> lunaris, I think so
05:08:29 <Taneb> It's implemented as an integer with a fixed denominator
05:09:39 <lunaris> I guess I'm just wondering if Rational is overkill.
05:09:54 <lunaris> Or even wrong (if a degree of rounding is expected).
05:10:06 <lunaris> That said, if the performance doesn't hurt, it's the "right" choice, no?
05:10:18 <Taneb> Rational is overkill, I would seriously use Data.Fixed
05:10:42 <lunaris> Yea, I'm coming round to that.
05:10:54 <lunaris> There's also the issue of persistence I expect.
05:11:14 <lunaris> Which is probably non-trivial for Rationals that aren't themselves implicitly bounded in size.
05:11:18 <lunaris> In some way.
05:11:25 <lunaris> I will give Centi a go; thanks Taneb.
05:11:39 <Taneb> I hope it goes well for you!
05:12:05 <lunaris> You and me both ;)
05:12:30 <lunaris> I've got a newtype around it so hopefully changing won't be a pain if the calculations start looking wrong.
05:26:42 <Nux__> hi I'm having difficulty running the very first example given at https://wiki.haskell.org/Type_arithmetic
05:26:56 <Nux__> does it require some unspecified extension?
05:27:13 <Taneb> Nux__, MultiParamTypeClasses and FunctionalDependencies
05:27:22 <Nux__> thanks
05:27:28 <Taneb> Maybe FlexibleInstances and FlexibleConstraints too...
05:27:43 * hackagebot seqalign 0.2.0.0 - Sequence Alignment  http://hackage.haskell.org/package/seqalign-0.2.0.0 (rcallahan)
05:28:00 <dramforever> maybe you also need UndecidableInstances for later examples
05:28:32 <Taneb> Nux__, generally the error messages will tell you which you need to enable for this kind of thing
05:29:18 <Nux__> Taneb, unfortunately not in this case
05:29:30 <Nux__> Taneb, it just gave a parse error
05:29:46 <Nux__> Taneb, no wait my mistake
05:29:57 <Nux__> Taneb, that was after my "correction" to it
05:30:01 <Nux__> thanks
05:30:05 <Taneb> :)
05:31:14 <k_bx> Does anyone know what should I do to make documentation links working after I upload a package? http://hackage.haskell.org/package/protocol-buffers
05:31:28 <dramforever> k_bx: wait
05:31:39 <k_bx> dramforever: will do, thanks!
05:31:50 <dramforever> k_bx: maybe also upload docs manually
05:31:57 <dramforever> dunno how...
05:32:25 <k_bx> I’ve found some Nail’s posts regarding fixes, but I just wanted to ask if it’s resolved currently and needed or not. Ok, I’ll wait for few hours.
05:32:43 * hackagebot protocol-buffers 2.1.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.1.0 (k_bx)
05:32:45 * hackagebot protocol-buffers-descriptor 2.1.0 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.0 (k_bx)
05:32:47 * hackagebot hprotoc 2.1.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.1.0 (k_bx)
05:32:49 * hackagebot seqalign 0.2.0.1 - Sequence Alignment  http://hackage.haskell.org/package/seqalign-0.2.0.1 (rcallahan)
05:37:43 * hackagebot sequent-core 0.5.0.1 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.5.0.1 (lukemaurer)
05:50:41 <saulzar_> Could anyone with some use of the singetons library tell me where I'm going wrong here? http://lpaste.net/135797 I'm trying to reflect the value back using fromSing in about the simplest case I can make it
05:52:49 <rbocquet> you need forall c. to bind c
05:52:59 <saulzar_> Oh, doh
05:53:24 <saulzar_> Thanks - I should have known..
05:55:50 <breadmonster> :t Data.List.insert
05:55:51 <lambdabot> Ord a => a -> [a] -> [a]
05:55:59 <breadmonster> :t Data.List.(++)
05:56:00 <lambdabot> Not in scope: data constructor ‘Data.List’
05:56:07 <breadmonster> :t Data.List.++
05:56:09 <lambdabot> parse error on input ‘Data.List.++’
05:56:34 <saulzar_> :t (Data.List.++)
05:56:35 <lambdabot> [a] -> [a] -> [a]
05:56:43 <breadmonster> So if the module Foo exports some operator (!-!) and Foo is imported qualified, how do I access the operators?
05:56:48 <breadmonster> Oh perfect that's how.
05:56:53 <saulzar_> :)
05:56:56 <Absolute0> How can I define types inside of ghci?
05:57:07 <breadmonster> Absolute0: data declarations work fine.
05:57:11 <Absolute0> let data X = Int doesn't expose X
05:57:17 <dramforever> don't write let
05:57:48 <Absolute0> Ahh I didn't derive Show...
05:57:57 <breadmonster> > data X = X Int deriving (Show); X 3
05:57:58 <lambdabot>  <hint>:1:1: parse error on input ‘data’
05:58:01 <dramforever> lol
05:58:07 <breadmonster> Okay, lambdabot refuses.
05:58:12 <breadmonster> But ghci is less fussy.
05:58:12 <dramforever> @let data X = X -- lambdabot special
05:58:14 <lambdabot>  Defined.
05:58:25 <dramforever> :t X -- aww I forgot to derive show
05:58:26 <lambdabot> X
05:58:50 <Absolute0> > data X = Boo deriving (Show)
05:58:52 <lambdabot>  <hint>:1:1: parse error on input ‘data’
05:58:55 <Absolute0> > Boo
05:58:56 <lambdabot>  Not in scope: data constructor ‘Boo’
05:58:57 <Absolute0> whatever
05:59:03 <Absolute0> worked in ghci
05:59:52 <breadmonster> dramforever: How does the deriving mechanism work?
06:00:00 <breadmonster> For nontrivial classes that is.
06:00:09 <dramforever> dunno
06:00:33 <dramforever> if doc of some lib says so then you can use it
06:00:37 <dramforever> ^ that's all I know
06:00:46 <Absolute0> When learning haskell everything is cool and novel and it seems like it's a bunch of great ideas. But does it hold up in the real world (compared to imperative programming)?
06:01:13 <maerwald> Absolute0: depends on the area/use case, I'd say
06:01:21 <maerwald> but mostly yes
06:01:25 <Absolute0> maerwald: say a web app
06:01:29 <Absolute0> or a desktop gui
06:01:30 <maerwald> sure, works
06:01:32 <breadmonster> dramforever: I'm trying to figure out the magic behind -XDeriveFunctor
06:01:33 <Absolute0> or a server
06:01:41 <breadmonster> maerwald: Though FRP is still a bit rusty...
06:01:42 <dramforever> yeah they work
06:01:46 <Absolute0> or an FPS game
06:01:56 <dramforever> I think it's possible
06:01:56 <maerwald> Absolute0: FPS game is a very difficult topic
06:01:56 <lunaris> Absolute0: Currently writing a typical "web application backed by REST API".
06:02:04 <breadmonster> Absolute0: You can use Haskell for anything that's not high performance computing and number theoretic algorithms.
06:02:10 <Absolute0> I heard that the laziness of haskell get's in the way
06:02:13 <lunaris> Absolute0: Still on just the "domain model/pure business logic" bit.
06:02:23 <lunaris> But for that alone, it's already worth it.
06:02:24 <dramforever> well, haskell is pretty fast
06:02:43 <lunaris> breadmonster: How high performance? I thought the recent Facebook results were quite reassuring.
06:02:47 <Absolute0> I saw a benchmark comparing golang to haskell
06:02:53 <maerwald> Absolute0: you can force strictness whenever you need it, that's not the problem
06:02:57 <Absolute0> golang execute in 4ms where haskell took about 49ms
06:02:57 <lunaris> breadmonster: And Haskell's C interop has worked very well for me in the past.
06:03:00 <dramforever> Absolute0: haskell isn't good at implementing traditional imperative algorithms
06:03:10 <dramforever> lunaris: exactly
06:03:12 <breadmonster> lunaris: Ah, I was talking about stuff like what CERN does, there's it's pretty painful to use Haskell where you'd normally use FORTRAN.
06:03:26 <kgadek> hi. bumping my question from quite a while ago: is anyone doing something like stack + shake? 
06:03:42 <kgadek> I need to compile protobuf files before the build
06:03:42 <dramforever> haskell is fast enough for most cases IF YOU ARE DOING IT THE RIGHT WAY
06:04:04 <Absolute0> dramforever: the only way to do things the right ways is to have you guys handhold me as I code. :)
06:04:12 <Absolute0> or with a few additional years of experience.
06:04:16 <breadmonster> dramforever: The right way is fairly complicated at times, reading Okasaki atm :P
06:04:16 <saulzar_> I don't know, you could happily write a FPS game in Haskell, but it would be a lot of work, as it would be in an imperative language 
06:04:20 <dramforever> not me, I don't know how to do it
06:04:24 <dramforever> breadmonster: not that
06:04:29 <koomi> "C is safe enough for most case IF YOU ARE DOING IT THE RIGHT WAY"
06:04:42 <dramforever> I mean something like not messing up laziness, etc
06:04:56 <Absolute0> Is there at least some blogpost or wiki guide for doing haskell "THE RIGHT WAY"?
06:05:08 <breadmonster> Absolute0: Sure, search for Real World Haskell.
06:05:12 <dramforever> Real World Haskell has a chapter on it
06:05:16 <Absolute0> ah
06:05:16 <lunaris> Absolute0: Not that I can see; hence my relative pestering on here recently.
06:05:18 <dramforever> it's about optimization
06:05:24 <lunaris> Been writing Haskell for about 8 years
06:05:25 <dramforever> but rather simple ones
06:05:28 <breadmonster> dramforever: The whole book is about Haskell THE RIGHT WAY.
06:05:32 <Absolute0> I am using learn you a good haskell
06:05:33 <dramforever> lol
06:05:34 <lunaris> But first shot into industry with it and I needed guidance.
06:05:50 <lunaris> I quite liked https://www.fpcomplete.com/school/using-fphc/recommended-libraries
06:05:52 <Absolute0> are there any actual haskell jobs
06:05:55 <breadmonster> lunaris: Do you have any idea how deriving clauses work?
06:05:57 <Absolute0> or people just use it for side projects?
06:06:17 <dramforever> Absolute0: I think there are a few haskell jobs out there
06:06:21 <icicled> I'm trying to use throwError from within a monad but I'm having a bit of trouble (I'm slightly confused). Could someone please have a look at http://lpaste.net/8551546792783642624 ?
06:06:21 <lunaris> breadmonster: Not sure what you mean -- they generate instances for you :)
06:06:25 <dramforever> IIRC some banks use them
06:06:32 <dramforever> lunaris: but how?
06:06:40 <dramforever> that's the problem :)
06:06:50 <breadmonster> lunaris: Yeah, which is the strange bit...I don't get how ghc derives Functor instances for instance.
06:07:01 <dramforever> hmm...
06:07:03 <lunaris> Absolute0: I will be hiring a developer soon; if this first foray pans out it will be a Haskell position (amongst others; polyglot with a penchant for type systems and other Haskell-rich qualities is probably more accurate)
06:07:17 <mniip> icicled, try error instead
06:07:41 <breadmonster> mniip: Any advice, mate?
06:07:46 <mniip> on what
06:07:46 <lunaris> breadmonster: Well, Functor instances are unique if they exist.
06:07:54 <breadmonster> wait what?
06:08:18 <mniip> breadmonster, for any given type there is either 0 or 1 law-conforming functor instances
06:08:18 <Absolute0> lunaris: are you a hipster?
06:08:19 <lunaris> breadmonster: https://mail.haskell.org/pipermail/haskell-prime/2007-March/002137.html is something I just dug up; not sure if it's the exact algorithm GHC uses but it's the gist.
06:08:25 <lunaris> Absolute0: Ouch
06:08:41 <Absolute0> :)
06:08:52 <mniip> breadmonster, any contravariant appearance of the contained type ensures there are no such instances
06:08:54 <lunaris> Absolute0: More likely zealot or elitist I think.
06:08:59 <mniip> if none such appearances appear, there is one
06:09:03 <mniip> and only one
06:09:10 <icicled> mniip: that would throw an exception... I was hoping to have ExceptT return a Left
06:09:15 <Absolute0> I say hipster.
06:09:18 <icicled> like it does a few lines above
06:09:18 <merijn> Absolute0: "Are there actually any haskell jobs" <- Facebook's spam detection backend is now all haskell, afaik, there's several banks with substantial haskell codebases
06:09:27 <breadmonster> Absolute0: That escalated quickly..
06:09:43 <hodapp> Absolute0: I use Haskell at my day job for embedded stuff, for one thing.
06:09:56 <Absolute0> I didn't know facebook dabbled with haskell.
06:10:14 <hodapp> Absolute0: it wasn't "a Haskell job"; I was simply granted sufficient freedom to solve things with the tools that I saw fit, and at some point that became Haskell and Ivory.
06:10:15 <Absolute0> https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
06:10:19 <mniip> icicled, oh
06:10:35 <hodapp> Absolute0: yes, Facebook loves their functional languages, especially ML and lately Haskell.
06:10:47 <mniip> icicled, what are your imports
06:10:48 <icicled> I'm guessing it might have something to do with the fact that at that point it is "inside" the IO monad?
06:10:55 <mniip> sounds like something might be shadowing throwError
06:11:01 <Absolute0> well if you hire smart people, one of them is bound to like haskell...
06:11:01 <lunaris> Well, they hired Simon Marlow; it would be nuts not to invest in his skillset.
06:11:20 <icicled> mniip: imports - http://lpaste.net/6392726398217224192
06:11:35 <zomg> lunaris: I doubt the decision to hire Simon came before the decision to invest in his skillset.. I'm sure there were many companies who wanted to hire him
06:11:45 <lunaris> zomg: I didn't mean it like that.
06:12:04 <zomg> ah yeah :) just mean that they hired him because of the skills rather than hired him and then he convinced them to do X
06:12:11 <lunaris> I meant, if you've hired someone that smart and possessing an incredible amount of domain knowledge, you'd be wise to try and exploit it.
06:12:17 <mniip> icicled, and the exact error?
06:12:23 <zomg> aye
06:12:25 <lunaris> I won't speak as to whether or not that was decided before/after the hiring process; I have no idea.
06:12:43 <mniip> icicled, ohh I see the issue
06:12:50 <zomg> yeah tbh it's entirely possible they wanted him specifically to introduce ways to improve their codebase
06:13:14 <icicled> the error - http://lpaste.net/4408836031592267776
06:13:44 <mniip> icicled, throwError raises exception in the IO monad instead of ErrorT
06:16:04 <icicled> mniip: ah gotcha that makes sense. Is there a way to get it to raise it in ExceptT/ErrorT on those lines?  Or should I simply propagate the result & then check it in the outer block?
06:17:37 <Absolute0> Is real world haskell better than learn you a good haskell?
06:17:45 * hackagebot seqalign 0.2.0.2 - Sequence Alignment  http://hackage.haskell.org/package/seqalign-0.2.0.2 (rcallahan)
06:18:09 <mniip> icicled, lift
06:18:09 <spew> I asked that exact question about two/three months ago here
06:18:19 <lunaris> Absolute0: I can only speak from personal experience, but for me: it's about learning the language and then just using libraries over and over until you learn which ones are worth using.
06:18:38 <lunaris> (Or in my case, trying to get a head start on the latter by asking in here and scouring the internet)
06:18:43 <merijn> Absolute0: Define better
06:18:56 <lunaris> Absolute0: That said, the big players are pretty well touted -- e.g. lens, aeson, text.
06:19:04 <Absolute0> merijn: makes you a better haskell programmer
06:19:13 <merijn> Absolute0: Learn You a Haskell covers the basics more in-depth, Real World Haskell glosses over a bunch of thigns to cover some important real world libraries
06:19:26 <lunaris> But in terms of learning the language, that's a general skill set that can be (should be?) acquired regardless of "real world" labels.
06:19:36 <lunaris> But this is just my 2c and YMMV.
06:19:40 <mniip> Absolute0, you know what makes you a better haskell programmer than any of those two
06:19:44 <mniip> reading both
06:19:50 * lunaris holds his breath
06:19:58 <Absolute0> http://book.realworldhaskell.org/read/
06:20:00 <lunaris> Oh, I was expecting a CT snipe :)
06:20:14 <Absolute0> everything is free nowadays
06:20:19 <Absolute0> I was very tempted to pirate it
06:20:25 <Absolute0> but they stole that right from me :(
06:22:45 * hackagebot inline-c 0.5.4.2 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.4.2 (FrancescoMazzoli)
06:22:47 * hackagebot seqalign 0.2.0.3 - Sequence Alignment  http://hackage.haskell.org/package/seqalign-0.2.0.3 (rcallahan)
06:24:42 <kuribas> Doesn't anyone want to support this?  https://github.com/jgm/pandoc/pull/1689
06:26:29 <icicled> mniip: I must not be doing it right - http://lpaste.net/4408836031592267776
06:27:00 <mniip> icicled, ohhh
06:27:08 <mniip> your transformer stack is wrong
06:27:25 <mniip> in the original paste, on line 16 you do liftIO
06:27:32 <mniip> the action inside is just IO
06:27:40 <mniip> it has no knowledge about the surrounding EitherT
06:28:51 <icicled> so the function that liftIO takes on doesn't know about EitherT so therefore throwError is expecting an IOException since it is in IO?
06:29:30 <mniip> yes
06:29:32 <mniip> more or less
06:29:35 <icicled> got it
06:29:58 <icicled> I just read the monad transformer paper last night & got excited & now I'm stuck heh
06:30:18 <icicled> what would your suggestion be to re-order my stack?
06:36:32 <mniip> icicled, split liftIO into more liftios
06:36:56 <ParahSailin_> how do i get a header file included into the tarball uploaded to hackage
06:37:18 <kuribas> To write literate haskell in markdown, you cannot use ## as headings, because ghc gives an error.  I'd like pandoc to support == instead for headings.
06:37:30 <ParahSailin_> tried this: https://hackage.haskell.org/package/seqalign-0.2.0.3/seqalign.cabal
06:37:41 <kuribas> The patch is already written, but I got no response for it.
06:37:59 <dcoutts> ParahSailin_: extra-source-files
06:39:02 <kuribas> And html style subheaders don't work for latex.
06:39:13 <ParahSailin_> dcoutts: "Unknown fields: extra-source-files"
06:39:23 <dcoutts> ParahSailin_: lives at the top level
06:39:29 <dcoutts> weirdly
06:39:33 <dcoutts> ought to be per-component
06:40:05 <ParahSailin_> dcoutts: wow
06:40:18 <kuribas> It's just a simple, non-intrusive patch, I don't know why at hasn't gotten any attention.
06:40:24 <dcoutts> ParahSailin_: hmm?
06:40:39 <icety3> :quit
06:41:11 <ParahSailin_> dcoutts: just that there would have been no way for me to figure that out
06:41:31 <dcoutts> ParahSailin_: not even if you looked at the user guide?
06:41:54 <insitu> I have troubles using hp2ps on Mac os X : the graph output only shows one type of object and is all black
06:41:58 <ParahSailin_> dcoutts: well that was what i looked at first
06:42:46 * hackagebot seqalign 0.2.0.4 - Sequence Alignment  http://hackage.haskell.org/package/seqalign-0.2.0.4 (rcallahan)
06:42:53 <dcoutts> ParahSailin_: want to send a patch for the user guide?
06:43:09 <insitu> it might be that ARR_WORDS far outweigh other allocated objects, but still
06:43:11 <dcoutts> it's just markdown
06:43:49 <ParahSailin_> dcoutts: maybe a patch to cabal/stack instead, given that there is a per-component field called includes
06:44:21 <dcoutts> ParahSailin_: you mean to allow extra-source-files to be per-component?
06:45:02 <dcoutts> ParahSailin_: note that there's install-includes, perhaps that's what you want
06:45:41 <ParahSailin_> dcoutts: what is the difference between includes and install-includes
06:46:08 <ParahSailin_> dcoutts: in this particular package, the header file is only needed to build c-sources
06:46:11 <dcoutts> ParahSailin_: as it says in the user guide, install-includes are .h files from the package that get installed onto the system
06:46:19 <dcoutts> ParahSailin_: ok, in that case it's not appropriate.
06:46:22 <ParahSailin_> dcoutts: i dont need the .h file after this
06:46:40 <dcoutts> ParahSailin_: the problem is, "includes" can be for system includes too, so it's not just files within the package.
06:46:57 <ParahSailin_> dcoutts: the "includes" field in the version 0.2.0.3 appears to be a noop wrt cabal/stack packaging tarball
06:47:23 <dcoutts> ParahSailin_: no, it means it's a .h file that's used by the component.
06:47:55 <dcoutts> ParahSailin_: and in particular its existence and validity is checked, and is passed to some ffi preprocessors
06:48:26 <dcoutts> ParahSailin_: historically it also had to be passed to ghc, but newer ghc versions don't use them, except for "capi" imports.
06:48:52 <dcoutts> ParahSailin_: if it's only used by the C code, not by the hs code, then you don't need to list it in includes.
06:49:17 <dcoutts> ParahSailin_: though if you do, the configure step will check that it can be used (ie will do a test compile)
06:58:21 <epta> how to make withSystemTempDirectory https://hackage.haskell.org/package/temporary-1.1/docs/System-IO-Temp.html#v:withSystemTempDirectory return new directory on each call?
06:59:27 <epta> it calls openTempFile internally, which uses process id (or smth like that) as a random number
07:01:07 <GLM> Is anyone here from Seattle?
07:02:46 <frerich> epta: Well the first argument to withSystemTempDirectory is the directory name template. The template format is documented for openTempFile. 'XXX' will basically get replaced with some random number.
07:02:52 <dcoutts> epta: it will return a new one on each call. If you let the old ones be deleted then it can reuse the names, but they're guaranteed to be new and to be unique for the duration of their use.
07:03:05 <epta> frerich: I'm not sure
07:03:27 <epta> frerich: > withSystemTempDirectory "123-XXX" $ \x -> putStrLn x
07:03:29 <epta> /run/user/1000/123-XXX2535
07:03:52 <epta> XXX is not a part of the template, it's just a format of how these random numbers would be generated
07:04:53 <epta> dcoutts: http://lpaste.net/raw/7684576041716678656
07:05:17 <epta> is it because of ghci?
07:05:25 <dcoutts> epta: yes, that's completely consistent with what I said. It is behaving correctly.
07:05:39 <dcoutts> they're guaranteed to be new and to be unique for the duration of their use.
07:05:53 <epta> Ah, got it
07:06:13 <dcoutts> but obviously it deletes the dir at the end of withSystemTempDirectory
07:06:21 <frerich> epta: You could try nesting two withSystemTempDirectory calls to see whether you get different names.
07:07:54 <epta> frerich: dcoutts: so if one needs to have unique directories for each call, he should provide unique prefix, right?
07:08:15 <dcoutts> epta: or make their lifetimes overlap
07:11:49 <insitu> ok, might be because the ARR_WORDS allocation is really really much much more than the rest...
07:12:12 <tmtwd> > map (*) [1,2]
07:12:13 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
07:12:24 <tmtwd> why doesn't that work?
07:13:05 <mniip> tmtwd, define "doesn't work"
07:13:17 <tmtwd>     No instance for (Show (a0 -> a0)) arising from a use of `print'
07:13:29 <mniip> tmtwd, you can't print functions
07:13:33 <Haskellfant> what do you want todo?
07:13:39 <mniip> map (*) [1, 2] is a list of functions
07:13:57 <tmtwd> okay I see
07:13:57 <frerich> tmtwd: If you apply '*' to a single value, you get a function.
07:14:13 <icicled> mniip: I fixed it :) - http://lpaste.net/8551546792783642624
07:14:15 <saep> map (*) [1, 2] = [(1*), (2*)]
07:14:26 <icicled> I don't like the nested case statements though
07:16:16 <Taneb> icicled, you could use something like ExceptT
07:16:47 <icicled> Taneb: I am using it? Or can I do better?
07:16:49 <mniip> Taneb, but he is
07:17:07 <Taneb> Ah
07:17:19 <Taneb> I mean another layer of ExceptT to deal with the nested cases
07:17:30 <Taneb> No, wait
07:17:45 <Taneb> I don't know, sorry
07:18:31 <icicled> I think this is good progress :)
07:18:59 <icicled> I read the monad transformer paper last night & started hacking on this since 4am sooooo ya!
07:19:55 <tmtwd> product_of_squares_of_odd_elements ys = foldr (*) 1 [map square (filter odd ys)]
07:20:20 <tmtwd> I tried this function like product_of_squares_of_odd_elements [1,2,3]  <interactive>:65:1-16:
07:20:20 <tmtwd>     No instance for (Num [b0]) arising from a use of `productofsquares'
07:20:20 <tmtwd>     Possible fix: add an instance declaration for (Num [b0])
07:20:20 <tmtwd>     In the expression: productofsquares [1, 2]
07:20:44 <mniip> map square (filter odd ys) is a list of numbers
07:20:44 <tmtwd> Anyone know the problem
07:20:50 <mniip> [map square (filter odd ys)] is a list of lists of numbers
07:22:44 <Tuplanolla> The error message says you're trying to treat a list of things as a number, tmtwd.
07:24:18 <insitu> :t [10]
07:24:19 <lambdabot> Num t => [t]
07:24:46 <insitu> :t [map (+1) [1,2,34]]
07:24:47 <lambdabot> Num b => [[b]]
07:26:16 <insitu> :t foldr (*) 1
07:26:17 <lambdabot> (Num b, Foldable t) => t b -> b
07:26:41 <mauke> :t product
07:26:42 <lambdabot> (Num a, Foldable t) => t a -> a
07:27:32 <breadmonster> mauke: For a binary tree, a left fold would be O(n)?
07:28:23 <breadmonster> If the function operates in O(1).
07:28:27 <tmtwd> can the x in (x:xs) be a list or just a single element?
07:29:01 <mniip> if x is a list then xs will have to be a list of lists
07:29:04 <notdan`> tmtwd: well, if (x:xs) itself is a list of lists..
07:29:28 <tmtwd> okay
07:29:32 <tmtwd> so it can be a list
07:29:33 <mauke> > case [[1,2], [3,4,5], [6]] of x : xs -> x
07:29:34 <lambdabot>  [1,2]
07:29:36 <mauke> yep
07:30:55 <tmtwd> http://pastebin.com/XcvFcqT4
07:31:05 <tmtwd> how do I fix this function so it is actual haskell code?
07:31:36 <tmtwd> it is more like pseudohaskell code now?
07:32:00 <mauke> remove 'where'
07:32:07 <mauke> also you're missing an 'in'
07:32:18 <mauke> the syntax is let DEFINITIONS in BODY
07:32:25 <mauke> > let x = 2 in x * 5
07:32:27 <lambdabot>  10
07:32:50 <mauke> and map is missing its second argument, the input list
07:33:40 <mniip> also you can't use ++ there
07:34:30 <tmtwd> http://pastebin.com/9rT0Usza is this more haskelly?
07:35:39 <mniip> it is but it doesn't typecheck
07:36:08 <tmtwd> mniip is the ++ good there, at least?
07:36:12 <mniip> no
07:36:25 <tmtwd> isn't ++ just append
07:36:33 <mniip> ++ joins two lists together
07:36:36 <mniip> x is not a list
07:37:00 <mniip> the operation you're probably looking for is called :
07:37:07 <tmtwd> is there a list function?
07:37:16 <tmtwd> to make a single element a list?
07:37:19 <mniip> "a list function"?
07:37:29 <mniip> there is 'return'
07:37:30 <grohne> is there a simple way to emulate ftp/bbp on ghc 7.8?
07:37:33 <mniip> but you want to use : instead
07:37:34 <tmtwd> I thought that x is (x:xs) could potentially be a list?
07:38:01 <mniip> tmtwd, the types of x and (x:xs) are linked together
07:38:05 <tmtwd> oh
07:38:12 <mniip> x can be a list if and only if (x:xs) is a list of lists
07:38:19 <tmtwd> so it automatically makes them work
07:38:24 <mniip> not automatically
07:38:34 <mniip> the very opposite
07:43:51 <tmtwd> http://pastebin.com/VbryU8tX
07:44:02 <tmtwd> now it throws : *** Exception: productofsquares.hs:8:1-15: Non-exhaustive patterns in function subsets
07:44:16 <marchelzo_> tmtwd: look at the name
07:44:24 <marchelzo_> `subset` vs `subsets`
07:44:36 <tmtwd> huh, now it runs
07:44:48 <tmtwd> subsets [1,2,3] -> []
07:45:13 <mniip> tmtwd, you have a mistake in your logic
07:45:24 <mniip> how many subsets of the empty set are there
07:45:44 <Nux__> ooh ooh I know this
07:45:50 <tmtwd> oh I need to have another case
07:46:11 <marchelzo_> tmtwd: no
07:50:58 <Nux__> tmtwd, x can be a list, but in that case that list is one element of a list of lists.
07:51:15 <tmtwd> i see
07:51:33 <tmtwd> oh [x]
07:51:42 <Nux__> tmtwd, you're probably thinking of a language like prolog where you can give a list of elements in the head
07:51:53 <Nux__> you can't do that in haskell
07:51:58 <tmtwd> ohhh
07:52:03 <icety3> :quit
07:52:03 <Nux__> haskell is strict about the head being a single element of the list
07:52:04 <tmtwd> i was thinking of scheme actually
07:52:24 <Nux__> k
07:52:49 <marchelzo_> tmtwd: If you add [x] to the result, you'll still be missing one subset.
07:53:28 <Nux__> what they're saying is you're forgetting the improper subset
07:53:46 <Nux__> I think
07:54:27 <marchelzo_> > let subsets [] = []; subsets (x:xs) = let others = subsets xs in [x] : (others ++ map (x:) others) in subsets [1,2,3]
07:54:29 <lambdabot>  [[1],[2],[3],[2,3],[1,2],[1,3],[1,2,3]]
07:54:43 <marchelzo_> Notice that there is one subset missing.
07:55:12 <Nux__> ah so it's the other trivial one you were talking about
07:55:20 <mniip> tmtwd, still not it
07:56:29 <Nux__> to be clear, a subset can be defined as a set such that there is no element that isn't in the larger set
07:56:36 <Nux__> that might make it more obvious
07:57:53 <marchelzo_> Nux__: In a sense, it is the improper subset. The problem stems from the fact that subsets [] has been defined as [].
07:58:32 <Nux__> so it's improper by the time it gets to it
07:58:35 <Nux__> I see
07:58:50 <Tuplanolla> The naming stems from a silly convention in mathematics.
08:00:30 <Tuplanolla> The notation for strict or proper subsets is commonly ⊊ instead of ⊂, because ⊂ is usually taken to mean ⊆.
08:01:56 <Tuplanolla> Ideally those would be analogous with inequalities.
08:02:13 <Nux__> It could be that ⊂ was used before ⊆ or inequality notation was even a thing
08:02:17 <Nux__> I don't know
08:03:03 <Nux__> there's a lot of confusing things that we keep for legacy reasons
08:05:16 <Nux__> tmtwd, if you're still there: it's the empty set
08:05:26 <tmtwd> im still here
08:05:29 <tmtwd> just reading
08:05:53 <Nux__> The empty set has no elements that aren't in the larger set. This is known as a vacuous truth.
08:05:53 <Tuplanolla> I don't remember the origins, but it's likely that mathematicians simply went for the notation that requires the least effort, as usual.
08:07:42 <Tuplanolla> Why plan ahead when it's easier not to?
08:10:51 <Nux__> Why not adopt a new convention that has less problems? Because that would cause a bigger problem of having to qualify everything you say to people who don't know the new convention, defying the point of using the notation.
08:11:17 <Nux__> as in I agree with you
08:11:48 <Nux__> it causes problems now to fix problems later, which is unfortunately impractical for working mathematicians
08:11:49 <tmtwd> what is the parse error at in for? http://pastebin.com/k1YmdG5K
08:12:41 <mniip> tmtwd, once again
08:12:47 <mniip> what are the subsets of []
08:12:57 <tmtwd> []?
08:13:07 <mniip> yes
08:13:25 <mniip> but on line 1 you write that there are no subsets of []
08:13:43 <Nux__> as in, the set of subsets could be written [[]]
08:14:06 <Tuplanolla> We already have new notation for formal logic and, to some extent, education.
08:14:35 <nitrix> Am I the only one to think his subsets function is overkill :/
08:15:31 <ParahSailin_> is old-locale deprecated?
08:16:05 <mniip> nitrix, no
08:16:13 <mniip> filterM (const [True, False])
08:16:27 <bergmark> ParahSailin_: time 1.5 obsoletes it
08:16:32 <bennofs> :t filterM
08:16:33 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
08:16:40 <nitrix> filter ((==0) . sum) . yourSubsets
08:16:53 <bergmark> ParahSailin_: or perhaps something is missing from there... I don't remember since I'm using time-locale-compat
08:16:59 <bennofs> mniip: ooh, that is nice :)
08:17:23 <nitrix> tmtwd: What's the criteria on choosing the subsets you want? 
08:17:59 <tmtwd> it has to have unique values, for on
08:18:41 <nitrix> Oh, so all the permutations of a list?
08:19:12 <nitrix> If you explain your requirements better, I'm sure we could find an easier way.
08:20:14 <tmtwd> " We can represent a set as a list of distinct elements,
08:20:14 <tmtwd> and we can represent the set of all subsets of the set as a list of
08:20:14 <tmtwd> lists. For example, if the set is (1 2 3) , then the set of all subsets is
08:20:14 <tmtwd> (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) ."
08:22:49 <Nux__> I think you were trying to do this http://pastebin.com/KvMD2b3p
08:22:51 * hackagebot hwsl2-reducers 0.1.0.0 - Semigroup and Reducer instances for Data.Hash.SL2  http://hackage.haskell.org/package/hwsl2-reducers-0.1.0.0 (srijs)
08:25:28 <nitrix> tmtwd: Got it. In that casem then you aren't very far. Just [[]] instead of []. Nux__'s version should help you figure it out.
08:25:39 <tmtwd> oh right
08:25:58 <tmtwd> I forgot that you don't really need full lambdas in haskell
08:26:21 <nitrix> I just like his use of 'new' and 'old' in that 'let/in'.
08:26:28 <nitrix> Seems much cleaner to me.
08:26:37 <Nux__> :)
08:26:44 <tmtwd> ie  (\arg -> x : arg)  = (x:), right?
08:27:16 <MarcelineVQ> what were those called again, operator slices?
08:27:17 <nitrix> :t (x:)
08:27:18 <lambdabot> [Expr] -> [Expr]
08:27:25 <tmtwd> http://pastebin.com/cYyU3Uf7
08:27:31 <tmtwd> thats the scheme version, 
08:27:48 <tmtwd> I find haskell to be much more readable that lisp in many cases
08:27:51 * hackagebot xlsior 0.1.0.1 - Streaming Excel file generation and parsing  http://hackage.haskell.org/package/xlsior-0.1.0.1 (rcallahan)
08:28:05 <nitrix> MarcelineVQ: Slices? Pattern matching maybe? He's using cons.
08:28:41 <Tuplanolla> Operator sections, MarcelineVQ?
08:28:57 <MarcelineVQ> yeah
08:29:16 <nitrix> Ah, I guess I'm out of context.
08:29:19 <Tuplanolla> The TupleSections extension gives it away.
08:31:09 <rphillips> is there a pure haskell postgres driver?
08:34:06 <tmtwd> im trying to turn all my scheme notes into haskell because I find haskell more readable
08:34:48 <Tuplanolla> You can install pointfree to get rid of that excess readability, tmtwd.
08:35:11 <monochrom> don't be so sure
08:35:22 <Nux__> tmtwd, though some things are transferable, the two languages differ in some important ways
08:35:39 <Nux__> tmtwd, not least of which is in haskell's type system
08:35:56 <Tuplanolla> @pl \ x (f, y) z -> f x y
08:35:56 <lambdabot> (`ap` snd) . (. fst) . ((const .) .) . flip id
08:36:09 <Nux__> tmtwd, you should learn to use it as it would have made some of the mistakes you made very obvious
08:36:58 <tmtwd> I read through 1st half of lyah
08:37:09 <tmtwd> I'm still a very new programmer
08:37:44 <mniip> Tuplanolla, here's a more readable pointfree version
08:38:09 <mniip> curry . ((const .) .) . flip id
08:38:30 <Nux__> tmtwd, I've still got plenty to learn myself.
08:39:27 <Nux__> tmtwd, I like to test myself in a few languages (Scheme, prolog, C++, haskell and python)
08:40:02 <Nux__> tmtwd, the idea is to take good lessons from each (and generally it's cool to learn these things)
08:40:20 <tmtwd> the type system in haskell I need to pick up more
08:40:29 <mniip> Tuplanolla, s/curry/uncurry/
08:40:34 <Nux__> gotta go now seeya guys
08:40:43 <tmtwd> bye
08:40:44 <Nux__> good luck tmtwd
08:40:47 <Nux__> seeya
08:41:24 <lethjakman> tmtwd: what do you mean by "converting notes"?
08:41:30 <lethjakman> like the notes you have from school?
08:41:38 <tmtwd> no
08:41:38 <mniip> Tuplanolla, generally human-made pointfrees end up being more readable than pl ones
08:41:47 <tmtwd> I'm reading through sicp
08:42:04 <tmtwd> so less notes, than the code from sicp
08:42:20 <tmtwd> not all of it of course
08:42:30 <Tuplanolla> The intention was to get rid of readability, mniip.
08:42:48 <tmtwd> just the ones where it would seem to fit well in haskell
08:45:13 <jmcomets> Hi all! I was doing me some list comprehensions since I haven't really worked a lot with them (booooo). I was wondering why the following didn't work: [x | x <- [2..], y <- [2..x], y * y < x, x `mod` y /= 0]
08:45:40 <jmcomets> note that "didn't work" means that I don't get the list of prime numbers
08:52:13 <tmtwd> so let y = [[1,2], 3 4] is illegal in hakell? in the sense that the head must be a single element?
08:53:06 <slack1256> y = [1, 2] : 3 : 4 : [] is equal
08:53:10 <slack1256> @type (:)
08:53:11 <lambdabot> a -> [a] -> [a]
08:53:47 <slack1256> > 3 : []
08:53:49 <lambdabot>  [3]
08:53:55 <slack1256> > [1] : 3 : []
08:53:56 <lambdabot>      No instance for (Show t0)
08:53:57 <lambdabot>        arising from a use of ‘show_M48784056781019960758893’
08:53:57 <lambdabot>      The type variable ‘t0’ is ambiguous
08:54:24 <tmtwd> > [1,2] : 3 : 4 : []
08:54:25 <lambdabot>      No instance for (Show t0)
08:54:26 <lambdabot>        arising from a use of ‘show_M84388442075195538848903’
08:54:26 <lambdabot>      The type variable ‘t0’ is ambiguous
08:54:29 <tmtwd> i see
08:54:39 <tmtwd> so its not allowed
08:54:39 <nitrix> tmtwd: No, [[1,2], 3, 4] is illegal because the type of your list isn't homogeneous.
08:54:53 <slack1256> > [1, 2] : [1] : [3] : []
08:54:54 <lambdabot>  [[1,2],[1],[3]]
08:55:09 <nitrix> tmtwd: You cannot have :: [Int] and :: [[Int]] at the same time.
08:56:04 <tmtwd> okay
08:56:14 <Denommus> there are some ways to have an heterogenous list
08:56:31 <slack1256> yes, but it isn't what you usually want
08:56:32 <Denommus> you could have a sum type for the different types the list can hold
08:56:56 <Denommus> or, if you want something extensible, but A LOT harder to work with, you can have RankNTypes
08:58:05 <mniip> [18:52:35] <nitrix> tmtwd: No, [[1,2], 3, 4] is illegal because the type of your list isn't homogeneous.
08:58:05 <mniip> well technically
08:58:33 <Unhammer> http://sprunge.us/KMdC?haskell ← is there a way to generalise over the constructors here? (or some completely different way that's better)
08:59:30 <mniip> @let instance Num a => Num [a] where fromInteger x = replicate (fromInteger x) (fromInteger 1); (+) = undefined; (*) = undefined; abs = undefined; signum = undefined; negate = undefined
08:59:31 <lambdabot>  Defined.
08:59:38 <mniip> > [[1, 2], 3, 4] -- nitrix
08:59:39 <lambdabot>  [[1,2],[1,1,1],[1,1,1,1]]
08:59:48 <slack1256> tmtwd: I also recommend inspecting the type of (:)
08:59:51 <slack1256> @type (:)
08:59:52 <lambdabot> a -> [a] -> [a]
08:59:52 <mniip> because polymorphism is cray
09:00:02 <slack1256> and replace a with [Int] to see what is happening
09:00:20 <Denommus> mniip: ewwwww
09:00:21 <nitrix> mniip: That's cheating! :<
09:00:39 <nitrix> mniip: Tell me that's not permanent.
09:01:08 * slack1256 puts mniip on santa's naughty lists
09:02:06 <jmcomets> Not to repeat myself, but by curiosity, can you guys explain why the following doesn't return the list of primes? [x | x <- [2..], y <- [2..x], y * y < x, x `mod` y /= 0]
09:03:00 <orzo_> can you explain why you expect it to?
09:03:40 <nitrix> He just wants a list of primes.
09:04:09 <orzo_> http://hackage.haskell.org/package/primes
09:04:17 <jmcomets> nitrix: yeah but I was trying to get it with a simple list comprehension
09:05:00 <nitrix> Doesn't it needs to be recursive?
09:05:41 <gb479> Is there some function which add two Word64 and return value and carry? I tried but was not able to find..
09:07:52 * hackagebot ViennaRNAParser 1.2.2 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.2.2 (FlorianEggenhofer)
09:07:54 * hackagebot pipes-bgzf 0.2.0.1 - Blocked GZip  http://hackage.haskell.org/package/pipes-bgzf-0.2.0.1 (rcallahan)
09:08:19 <nshepperd> jmcomets: that takes an x for every y < sqrt x such that x `mod` y /= 0
09:09:30 <jmcomets> Crapola. I was thinking that the problem was in that y * y < x optimization.
09:09:30 <ReinH> > [(x,y) | x <- [2..], y <- [2..x]]
09:09:32 <lambdabot>  [(2,2),(3,2),(3,3),(4,2),(4,3),(4,4),(5,2),(5,3),(5,4),(5,5),(6,2),(6,3),(6,...
09:10:05 <ReinH> 4 isn't prime, but 4 `mod` 3 =/= 0
09:10:26 <nshepperd> jmcomets: so, you'll get for instance, I think, two copies of 11, for the case y = 2 and y = 3
09:10:39 <jmcomets> > [(x,y) | x <- [2..], y <- [2..x], x `div` y != 0]
09:10:41 <lambdabot>      Not in scope: ‘!=’
09:10:41 <lambdabot>      Perhaps you meant one of these:
09:10:41 <lambdabot>        ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
09:10:46 <jmcomets> > [(x,y) | x <- [2..], y <- [2..x], x `div` y /= 0]
09:10:48 <lambdabot>  [(2,2),(3,2),(3,3),(4,2),(4,3),(4,4),(5,2),(5,3),(5,4),(5,5),(6,2),(6,3),(6,...
09:11:04 <ReinH> you want `mod`
09:11:53 <jmcomets> Yeah I was just playing with the bot. :) So long and thanks for all the fish!
09:12:00 <nshepperd> if you're to do it that way, you really want (filter isPrime [2..]) for some suitable definition of isPrime
09:12:04 <ReinH> x `div` y is only 0 when x is 0 and x is never 0
09:12:29 <nshepperd> [x | x <- [2..], isPrime x]
09:12:54 <ReinH> which is inefficient
09:13:20 <nshepperd> yes, there are more efficient ways of producing primes
09:13:55 <MarcelineVQ> there a primes package that elimates by multiples in an efficient way, more efficient than anything I could write up anyway
09:14:29 <ReinH> There's also about two dozen examples at
09:14:32 <ReinH> @google haskell primes
09:14:33 <lambdabot> https://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html
09:14:39 <ReinH> er, https://wiki.haskell.org/Prime_numbers
09:15:23 <jmcomets> like I said, I wasn't interested in *really* producing primes, just in list comprehensions and their inner workings
09:15:36 <MarcelineVQ> list comprehensions are super cool
09:17:05 <maerwald> what for, when you have the list monad instance
09:18:29 <YellowOnion> Anyone here want to see my NBody simulation I wrote (and video)?
09:18:33 <MarcelineVQ> brackets are prettier than do :>
09:18:54 <maerwald> MarcelineVQ: less powerful
09:19:12 <MarcelineVQ> And less safe
09:19:21 <maerwald> err wat?
09:19:27 <maerwald> monads are ot safe?
09:19:38 <MarcelineVQ> No
09:19:41 <maerwald> aha
09:19:42 <MarcelineVQ> I mean
09:19:52 <maerwald> desugaring of do-notation?
09:19:59 <MarcelineVQ> "maerwald: less powerful and less safe"
09:20:10 <maerwald> I cannot follow
09:20:24 <MarcelineVQ> I was agreeing and adding
09:21:42 <jmcomets> here we go... /summon haskell_hardcores
09:21:44 <MarcelineVQ> I'm not especially attached to comprehensions, I just think they look nice asthetically
09:22:20 <Tuplanolla> They're much more useful with MonadComprehensions.
09:30:35 <gb479> Is there some function which add two Word64 and return value and carry? there is a function plusWord2# in GHC.Prim, but I am not able to use it. Can someone help me please.
09:37:54 * hackagebot pipes-illumina 0.1.0.0 - Illumina NGS data processing  http://hackage.haskell.org/package/pipes-illumina-0.1.0.0 (rcallahan)
09:54:06 <cpup> is there anyway to pass a type family to another type?
10:03:34 <tmtwd> how do I fix this code? http://pastebin.com/cNgVGywC
10:03:51 <tmtwd> nvm ignore that
10:04:16 <slack1256> cpup: isn't it just enought having: 'type App (a :: * -> 
10:04:22 <joel135> Hi, I tried to create a function to find a minimum element of a list. As a base case I chose "let listmin [a] = a". Then I wrote "let listmin (a:as) = min a listmin(as)". Why do I get an error message?
10:04:29 <tmtwd> I get this error from that file
10:04:29 <tmtwd> productofsquares.hs:11:33:
10:04:30 <tmtwd>     Occurs check: cannot construct the infinite type: a1 = [a1]
10:04:30 <tmtwd>     Expected type: [[a1]]
10:04:30 <tmtwd>       Actual type: [a1]
10:04:31 <slack1256> cpup: isn't it just enought having: 'type App (a :: * -> *) b = a b ?
10:04:49 <tmtwd> nvm
10:05:05 <slack1256> cpup: I guess you need some extensions though
10:05:57 <slack1256> joel135: checkout the type of min
10:05:59 <slack1256> @type min
10:06:00 <lambdabot> Ord a => a -> a -> a
10:06:05 <slack1256> > min 2 5
10:06:07 <lambdabot>  2
10:06:17 <slack1256> that definition doesn't typeCheck
10:06:34 <Unhammer> oh what's the term for where you think of the solution right after you ask …
10:07:00 <mpickering> slack1256: why not?
10:07:10 <slack1256> The idea for the function you want is to traverse the list with a currently minimum value and examine the head, if it is less that the current value, take that and continue until the end
10:07:45 <slack1256> mpickering: min is applied only to a single argument
10:08:17 <slack1256> oh forget it. I though there was a (:) in there
10:09:18 <slack1256> > foldr1 min [2,5,6,10]
10:09:20 <lambdabot>  2
10:09:26 <slack1256> > foldr1 min [2,5,6,10,1]
10:09:27 <lambdabot>  1
10:09:51 <slack1256> I think that's what basically you are trying to acomplish but with manual recursion right?
10:10:15 <cpup> slack1256: it says missing argument: http://lpaste.net/135809
10:10:29 <Welkin> :t min
10:10:30 <lambdabot> Ord a => a -> a -> a
10:10:33 <Welkin> hm
10:10:37 <Welkin> isn't there a min for lists?
10:10:45 <joel135> slack1256, Yes
10:10:53 <slack1256> @type minimum
10:10:54 <lambdabot> (Ord a, Foldable t) => t a -> a
10:10:56 <Welkin> h
10:10:59 <Welkin> ah, yes
10:11:20 <slack1256> Oh it now on Foldable
10:11:24 <Welkin> :P
10:11:32 <Welkin> only for 7.10
10:11:47 <Welkin> I'm still on 7.8.4 because of stability issues
10:12:03 <slack1256> I think it is still useful to do in manually. To show the magic behind the curtain
10:12:04 <joel135> I found one error. listmin(as) should be (listmin as).
10:12:18 <mpickering> what is the error message joel135 ?
10:12:55 <mpickering> Is this in a source file or ghci?
10:15:28 <joel135> mpickering, ghci http://lpaste.net/135810
10:15:43 <joel135> That was the initial error.
10:17:06 <joel135> This is the new session with (listmin as) instead of listmin(as): http://lpaste.net/135811
10:17:46 <geekosaur> listmin doesn't handle the empty list
10:17:48 <mniip> joel135, your second let-block overrides the first
10:18:06 <geekosaur> also the second case doesn't do anything because the first (x:xs) matches [x]
10:18:07 <mniip> ghci's let has semantics like that of a do block
10:18:16 <slack1256> > minimum []
10:18:18 <lambdabot>  *Exception: Prelude.minimum: empty list
10:18:25 <slack1256> well minimum also doesn't :-)
10:19:29 <joel135> geekosaur, Would x:[] be better than [x]?
10:19:52 <geekosaur> no
10:19:54 <geekosaur> in fact that just shows why (x:xs) matches it first
10:19:55 <mniip> joel135, it's the same
10:20:09 <geekosaur> (xs becomes [])
10:24:03 <joel135> It works!    let {listmin [a] = a; listmin (a:as) = min a (listmin as)}
10:25:14 <Encapsulation> nice work joel135 
10:25:16 <Encapsulation> this is groundbreaking stuff
10:26:18 <joel135> So there were three errors in total: placement of parenthesis, order of definitions and accidental undefinition. Thanks :)
10:26:59 <obadz> anyone got much luck writing Excel UDF functions in Haskell?
10:27:06 <slack1256> joel135: be adviced that your definition is very similar of what 'foldr1 min [1,2,55]' does
10:32:11 <joel135> slack1256, Absolutely
10:34:52 <Jello_Raptor> hmm, is ApplicativeDo in the ipeline for being added to GHC? 
10:41:46 <Jello_Raptor> hmm, is ApplicativeDo in the pipeline for being added to GHC? (i.e. is there an expected release number with it in?) 
10:42:46 <mpickering> yes 7.12
10:42:54 <mpickering> there is a patch on phabricator now
10:43:06 <Cale> Jello_Raptor: https://phabricator.haskell.org/D729
10:43:29 <mpickering> https://phabricator.haskell.org/D729
10:45:29 <mniip> hmm
10:45:53 <mniip> I should investigate this weird performance drop
10:53:10 <YellowOnion> Does anyone here know how to get Linear and Repa working together?
10:56:32 <lispy> YellowOnion: I don't, but what's the issue you're stuck on?
10:57:38 <YellowOnion> lispy, I Just trying to wrap my head around how to use Repa, and add it to my existing project
10:58:15 <lispy> YellowOnion: I think the documentation for Repa is mostly in the papers written about it
10:58:24 <lispy> So, I would start there if I were you
11:11:52 <Haskellfant> there is also a wiki page https://wiki.haskell.org/Numeric_Haskell:_A_Repa_Tutorial and the examples package https://hackage.haskell.org/package/repa-examples
11:12:06 <YellowOnion> lispy, Those papers look far too indepth for my needs.
11:12:53 <YellowOnion> Haskellfant, I've been browsing those for the last hour, and still have no clue how to do anything other than a simple map that ignores the structure of the array.
11:13:22 <Haskellfant> YellowOnion: sorry I can't help you much more, I haven't really used repa myself
11:13:34 <Haskellfant> I was planning to at some point which is why I still have those links :)
11:18:15 * hackagebot pipes-illumina 0.1.0.0 - Illumina NGS data processing  http://hackage.haskell.org/package/pipes-illumina-0.1.0.0 (rcallahan)
11:18:15 * hackagebot phash 0.0.5 - Haskell bindings to pHash, the open source perceptual hash library  http://hackage.haskell.org/package/phash-0.0.5 (MichaelXavier)
11:24:45 <obadz> What's the state of the art linear algebra library?
11:26:07 <Tuplanolla> I want to repeat that question for symbolic algebra.
11:26:48 <obadz> Tuplanolla: you mean manipulating simple expression?
11:27:56 <Tuplanolla> Not necessarily simple.
11:28:29 <obadz> Tuplanolla: what's an example of what you want to do?
11:28:46 <Tuplanolla> Risch integration.
11:29:50 <Tuplanolla> (Not really, but the question stands.)
11:31:58 <obadz> Is that what Mathematica uses?
11:33:03 <tmtwd> how can I fix this function?
11:33:05 <tmtwd> http://pastebin.com/GLX51nr0 
11:33:14 <Tuplanolla> I don't know. It's proprietary.
11:33:55 <tmtwd> http://pastebin.com/ab11yXN0 theres the error
11:34:12 <mniip> tmtwd, what are you trying to do
11:34:35 <tmtwd> basically trying to count up all the elements of a list
11:34:42 <tmtwd> a list of nested lists
11:35:19 <mniip> tmtwd, huh?
11:35:41 <tmtwd> like [[1,2] ,[3], [4]] return 4
11:35:51 <tmtwd> because there are 4 elements in the list
11:36:09 <Tuplanolla> So sum . fmap length?
11:36:12 <mniip> count_leaves (x:xs) = length x + count_leaves xs
11:38:10 * hackagebot pandoc 1.15.0.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.4 (JohnMacFarlane)
11:42:16 <tmtwd> mniip, thank you :)
11:46:38 <jascase901> I am writing some haskell that uses xml-conduit to parse xml, and then output lua code. Does it make sense for me to first convert the xml to haskell records and data types. And then write functions that take those datatypes and generate lua code.  Or should I just make code that takes the xml nodes directly and generates lua code.
11:47:39 <Tuplanolla> An intermediate representation makes sense.
11:49:14 <jascase901> thanks Tuplanolla. I figured that was the case. But I wasn't sure if I was wasting time or not.
11:57:12 <fizbin> Hey, for GHC 7.10, what's the deal with Foldable and Traversable? How was the question presented in https://ghc.haskell.org/trac/ghc/wiki/Prelude710 decided?
12:05:03 <sccrstud92_> the prelude was changed
12:08:52 <doomlord> is there a versoin of fold that requires an associative function    , is there a special name for that.
12:09:36 <doomlord> (a version fold that uses the knowledge that the function is associative, would allow more parallelizing)
12:19:17 <lyxia> doomlord: repa has foldP
12:19:38 <doomlord> thanks
12:20:56 <doomlord> what i have in mind would be able to take advantage of associativity to fold in random order (i.e. whatever order the source turns up). The example use is: zbuffer compositing.  (you can think of that as folding primitives into an image+zbuffer)
12:22:02 <edwardk> reddit is sometimes exhausting
12:22:24 <ocharles__> edwardk: are you stuck in lolcats again?
12:22:32 <edwardk> fizbin: PlanFTP won: 83% in favor
12:22:40 <edwardk> ocharles__: heh
12:22:49 <edwardk> nah, just having to be pedantic https://www.reddit.com/r/haskell/comments/3brce1/why_does_sort_in_datadiscrimination_claim_to_be_on/csr36k3
12:22:50 <ocharles__> also, Edward Frenkel replied to my AMA question on HTT :) https://www.reddit.com/r/IAmA/comments/3bvydv/iama_edward_frenkel_mathematician_and_author_of/csr9ebv?context=3
12:23:12 <fizbin> edwardk: Aka, the "burn the bridges" plan?
12:23:19 <edwardk> fizbin: yes
12:23:43 <edwardk> fizbin: so bridges burned, and while the interim state is a bit noisy in terms of CPP, i'm getting largely positive feedback from folks
12:24:23 <edwardk> ocharles__: ^- on the plus side if made me spell out _precisely_ how the asymptotics of discrimination work out
12:24:35 <ocharles__> edwardk: maybe worth moving to Data.Discrimination itself?
12:24:41 <edwardk> probably is
12:24:44 <fizbin> Some day I'll be able to stop building for Ubuntu LTS 12 and may be able to enter that nice new world.
12:25:08 <ocharles__> and soon you'll have Dominic's mathjax-in-haddock code to have nice rendering :)
12:25:08 <nitrix> Question, I have multiple providers implementations for a distributed file system, all required to implement two things, a push and pull operation (it's block-based).
12:25:19 <nitrix> I'm wondering if it makes sense to make Provider a class.
12:25:33 <nitrix> Or should classes be restricted to more abstract concepts?
12:25:55 <ocharles__> nitrix: maybe have a look at this approach: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
12:26:15 <ocharles__> nitrix: the idea is you bundle up all the necessary functions into a data type itself, rather than use type classes
12:26:53 <nitrix> I can do that with a record, a Provider { get :: a -> b, put :: a -> b } sort of thing.
12:27:19 <ocharles__> yep, exactly
12:27:24 <nitrix> And have a list of providers that's that multiple of those records set accordingly.
12:28:42 <nitrix> Is that idiomatic though? I thought it'd be nice to enforce each provider to provide their own implementation and inforce it, like the existing class/instance system.
12:29:00 <nitrix> But then I'd need phantom types, ProviderX, ProviderY, for each provider, right?
12:31:20 <ocharles__> nitrix: one thing to note is that anything you can do with a type class, you can do with data types
12:31:41 <ocharles__> I think it's idiomatic - I do it this way with my `engine-io` library
12:32:05 <ocharles__> I have https://hackage.haskell.org/package/engine-io-1.2.9/docs/Network-EngineIO.html#t:ServerAPI and implementations like https://hackage.haskell.org/package/engine-io-snap-1.0.3/docs/Network-EngineIO-Snap.html
12:32:11 <ocharles__> it's worked well for me so far
12:33:38 <rjayatilleka> (Not OP) Are there performance costs/enefits to using a ADT of functions instead of class?
12:33:42 <rjayatilleka> *benefits
12:34:05 <edwardk> ocharles__: i confess that ed frenkel's AI-doomsaying moments kind of turn me off of the rest of his message, but it is a pretty popular line among populist presenters
12:34:46 <ocharles__> edwardk: I haven't read about that. I've only read Love and Math (which is fantastic)
12:35:09 <nitrix> ocharles__: I actually did similar, except, I was grouping the individual operations elsewhere, at the same place my list of Providers is defined. You did it a bit differently, as in, you have this EIO.ServerAPI constructor called snapAPI.
12:36:14 <nitrix> ocharles__: So I'd have a providerLocal for example that'd return a Provider with its fields being the immediate implementation.
12:36:24 <nitrix> Now there's no parts exposed outside of the module. I like it.
12:36:31 <ocharles__> yep, that's the idea
12:36:46 <nitrix> ocharles__: Sold :)
12:36:47 <ocharles__> the nice thing is you can easily have "provider transformers" that are just functions of the type Provider -> Provider
12:37:08 <ocharles__> so you can have things like: "logPuts :: Provider -> Provider" which does pre/post composition on the 'put' function it's given to write to STDERR
12:37:09 <ocharles__> or something
12:37:16 <ocharles__> that's a cute little bonus
12:37:40 <rjayatilleka> ocharles__: Are there performance implications to using an ADT of functions vs using a typeclass?
12:38:12 <ocharles__> in general, probably not - if you have some very polymorphic code then you *might* benefit by just psasing the ADT around, but I'm not sure it's much different to the dictionary passing GHC does anyway
12:38:27 <ocharles__> probably needs to be timed, rather than hands being waved
12:39:00 <rjayatilleka> I see.
12:39:13 <rjayatilleka> Thanks.
12:39:31 <nitrix> ocharles__: So, we can agree that typeclasses and classes in general should be reserved to more abstract language concepts, not application specific?
12:40:16 <rjayatilleka> nitrix: Wait, is there a difference between a class and a typeclass in Haskell?
12:40:21 <nitrix> rjayatilleka: Sure.
12:40:45 <rjayatilleka> nitrix: What is the difference?
12:40:52 <ocharles__> nitrix: I tend to loosely follow the ideas that type classes should be used in situations where there is a canonical choice, the functions have some sort of law that lets us reason about them polymorphically, and they should be small (a handful of functions)
12:41:08 <ocharles__> it's a rule of thumb, not a strict requirement
12:41:23 <bergmark> nitrix: i don't agree with that, it's very cumbersome to have to manually pass nested dictionaries to do recursion
12:41:24 <ocharles__> (what exactly constitutes a useful law, for example, is difficult to pin down)
12:42:28 <rjayatilleka> ocharles__: Can you give some examples of what you would use a typeclass for and what a useful law would be for it?
12:43:33 <bergmark> rjayatilleka: there's no difference between "class" and "type class" in normal conversation
12:44:01 <rjayatilleka> bergmark: Ok thanks. That's what I thought.
12:45:04 <bergmark> or, in normal haskell conversation i should say ;)
12:45:17 <nitrix> rjayatilleka: Actually I misunderstood the question. But, I tend to say Eq is the typeclass and `Eq a` is the class.
12:45:56 <Denommus> I wish Haskell and OCaml would be merged in a third language with almost everything from Haskell, except it replaces typeclasses with module implicits
12:46:02 <nitrix> They really are the same, I don't know why I do that.
12:46:04 <Denommus> then all this problems we have with correct typeclass hierarchies would be unnecessary
12:46:14 <rjayatilleka> nitrix: I see.
12:47:09 <nitrix> rjayatilleka: I find it more consistant because you can have multiple class definitions for the typeclass, if it isn't polymorphic, I think.
12:47:34 <nitrix> I haven't tried. Now I'm curious.
12:47:51 <edwardk> ocharles__: https://www.youtube.com/watch?v=lbLI9aX5eVg
12:47:53 <rjayatilleka> nitrix: Do you mean type classes with no parameters?
12:48:15 <ocharles__> edwardk: cool, will keep it on the list for now
12:48:18 <ocharles__> is it worth a watch?
12:49:34 <nitrix> rjayatilleka: Well like, I'm thinking having a `class Eq Int`, `class Eq String`, instead of having a polymorphic `class Eq a` and then instances for it. Is that even a thing?
12:50:02 <rjayatilleka> nitrix: Give me a sec and I'll see if that even syntax checks.
12:50:11 <marchelzo_> So system from System.Process doesn't do tilde expansion and stuff. What should I use to spawn a shell process that will do that?
12:50:12 <nitrix> I'm doing the same.
12:50:19 <nitrix> rjayatilleka: If so, that could be a reason to distinguish typeclasses from classes. Otherwise, I really don't know.
12:50:49 <ParahSailin_> say i have a cabal package that has a few similar executables that import a common module defined in the package, is there a way to have cabal only compile common modules once?
12:51:11 <ParahSailin_> or do i need to refactor that into a separate library dependency?
12:51:33 <marchelzo_> nitrix: What would `class Eq Int` do?
12:51:56 <nitrix> Have a (==) operator with a type signature that only works with Int?
12:52:08 <rjayatilleka> marchelzo_: Presumably it wold be equivalent to a no parameter typeclass wouldn't it?
12:53:00 <nitrix> marchelzo_: (==) :: Int -> Int -> Bool
12:53:01 <rjayatilleka> Nitrix: No I don't think that would happen. Because there aren't an tpye parameters on the class declaration, there's no actual need to have any of the class methods reference Int.
12:53:16 <nitrix> Ahh :/
12:53:18 <bergmark> (==) :: Int -> Int -> Bool is a normal function
12:53:28 <marchelzo_> ^
12:53:47 <nitrix> So the whole typeclass/class thing is just words getting conflated?
12:53:58 <rjayatilleka> Yes
12:54:06 <bergmark> well, the keyword is class
12:54:16 <rjayatilleka> Btw, that idea does NOT syntax check.
12:54:32 <nitrix> rjayatilleka: Probably a good thing :P
12:54:49 <rjayatilleka> Indeed. I don't think either of us really expected it to check either.
12:54:59 <rjayatilleka> But experiments are fun!
12:55:32 <nitrix> Meh. Anyway, I say typeclass when I'm talking about types and say class when I'm in a context where the methods it has is relevant.
12:55:35 <bergmark> ParahSailin_: you need a library section
12:55:39 <mniip> you can create parameterless typeclasses in MPTC iirc
12:55:45 <ParahSailin_> bergmark: tried that
12:55:53 <mniip> just as a way to populate the Contraint kind
12:56:35 <mniip> oh
12:56:39 <mniip> NullaryTypeClasses
12:56:48 <Weebz`> how do I find the INSTALL file of a pip package?
12:57:08 <bergmark> Weebz`: i think you are in the wrong channel
12:57:17 <Weebz`> hah, yes. sorry
12:57:50 <rjayatilleka> mniip: Yeah I'm looking at ocharles blog post on it and implicit parameters now.
13:00:18 <rjayatilleka> Is there a good tutorial on ML modules for Haskellers?
13:00:27 <nitrix> ocharles__: The more I think about it, the more it makes sense. I don't want extra types per provider implementations. The typeclass would guarantee that the type (if it existed) would implement specific methods, but it doesn't make sense to see those as new types.
13:00:35 <nitrix> ocharles__: Very appreciated :)
13:00:50 <ocharles__> :)
13:00:53 <nitrix> A provider's a Provider, that's it.
13:02:14 <rjayatilleka> nitrix: Coincedentally enough, I was thinking about the same question. It's probably pretty common among people learning FP after OOP. And I got a great answer from ocharles as well!
13:02:33 <ocharles__> time to go buy some pizza. ciao!
13:02:53 <rjayatilleka> Though I feel like that idea of 'Java interface -> Record of functions` should be documented somewhere.
13:03:01 <rjayatilleka> ocharles__: Later! Thanks.
13:03:07 <nitrix> rjayatilleka: I've done Haskell for a couple months now. I sort of understand the idiomatic way by now, but eventually you end up in a situation where your old habits wants to kick in again. That's totally fine.
13:03:48 <nitrix> rjayatilleka: Afterall, learning a new language isn't about syntax; Haskell is the first language I can say I had to truly learn new concepts along the way, and so far, those are paying off, so it's just a matter of killing the bad habits now :P
13:04:08 <rjayatilleka> nitrix: I've actually been working in Haskell for 8 months now, but only dabbling on and off.
13:04:33 <rjayatilleka> I'm spending today working on making an authenticated Todo web app to really start getting into Haskell.
13:04:35 <nitrix> rjayatilleka: Not the easiest thing, it takes commitment. But I believe in the whole thing :]
13:05:02 <nitrix> Its got its heart in the right place.
13:05:13 <rjayatilleka> nitrix: Are you doing your job in Haskell, or as a hobbyist?
13:05:19 <nitrix> Hobbyist.
13:05:19 <rjayatilleka> I'm a hobbyist.
13:05:56 <nitrix> As if any workplace would hire you if you didn't you the language they expect you to work in.
13:06:16 <rjayatilleka> Ha. I'm interning at Amazon for the second summer now. My first sumer, I worked in Scheme, then switched to Java at the very end for some other stuff. I realized how much nicer coding in scheme was. That's what got me started in Haskell and FP.
13:06:34 <rjayatilleka> Eh I didn't know scheme when I got hired at Amazon.
13:06:43 <rjayatilleka> Though it's a pretty simple language.
13:07:13 <nitrix> Well, Facebook seemed interested by my haskell baggage.
13:07:42 <rjayatilleka> They've been doing a lot of stuff in Haskell these days.
13:07:53 <ParahSailin_> rjayatilleka: how is amazon, im considering an offer from them
13:08:29 <rjayatilleka> It depends a lot on your team in a company this big, but speaking about Kindle (my first summer) and S3 (this summer), I really like them both.
13:09:03 <rjayatilleka> AWS in general is a lot more intense, but the work is also way more interesting. Whereas Kindle was just generic webservices and not a lot of technically challenging problems.
13:09:30 <ParahSailin_> im worried about the noncompete mostly
13:09:33 <rjayatilleka> The pay is competitive, perks are not particularly great compared to Microsoft/Google/FB.
13:09:44 <rjayatilleka> Okay the noncompete is definitely annoying if you enjoy hackathons.
13:09:54 <rjayatilleka> I ran into it before.
13:10:14 <rjayatilleka> And its way too strict, so you basically can't do hackathons (techincally).
13:10:17 <ParahSailin_> interns probably dont have the same 18 month deal that full time folks do, right?
13:10:17 <marchelzo_> @pl \f a b -> liftM2 g (f a) (f b)
13:10:17 <lambdabot> flip =<< (((.) . liftM2 g) .)
13:10:23 <rjayatilleka> But my manager this time doesn't care.
13:10:34 <rjayatilleka> 18 months? Outs is 9 months after we leave.
13:10:38 <rjayatilleka> *Ours
13:10:48 <nitrix> rjayatilleka: So far, I'm just toying with the idea of a distributed file system. It's just crazy all the features haskell has that makes this project a breeze.
13:10:58 <nitrix> rjayatilleka: So it's a good toy project to learn :)
13:12:10 <marchelzo_> Anyone have any tips for debugging parsec code? I want something to parse successfully but it's being rejected and the error message isn't terribly helpful.
13:12:18 <rjayatilleka> nitrix: It sounds pretty complex to me. I think I prefer to start on a simple single machine server to start with.
13:12:38 <rjayatilleka> Though I should really get back to work.
13:12:49 <ParahSailin_> rjayatilleka: PM
13:12:57 <rjayatilleka> PM?
13:13:15 <rjayatilleka> Are you getting an offer as a project manager?
13:13:16 <ParahSailin_> private message
13:13:23 <rjayatilleka> IRC does private messages?
13:13:28 <rjayatilleka> I didn't even know that.
13:13:45 <rjayatilleka> Ok bye.
13:16:26 <nitrix> Even normal messages are PRIVMSG commands to a channel D:
13:16:38 * nitrix slaps rjayatilleka
13:17:22 <slack1256> I am doing a emacs' calc clone. How would I represent a number on such setting? I would like use Ratio Int because I can do multiple views of them as with many digits I want
13:17:35 <slack1256> Yet to give the illusion of Real numbers maybe there are other options
13:17:39 <sm> marchelzo_: I like this debug helper: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils/Debug.hs#L226
13:18:05 <marchelzo_> sm: Thanks, I'll try it out!
13:18:29 <sm> or just https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils/Debug.hs#L55
13:27:45 <weasel__> linear logic question: does upside-down & have a computational interpretation?
13:33:57 <gamegoblin> Since the Monoid laws require using equality (mappend mempty x == x, etc), does it follow that all Monoids should be Eq ?
13:34:50 <slack1256> Monoid laws are encoraged not required :-p
13:35:00 <slack1256> Also I think those are different notions of Equality
13:35:12 <weasel__> gamegoblin: no, that equality can hold on a meta-level e.g. beta equivalence
13:35:20 <slack1256> mappend mempty x reduce to the same value that x
13:35:35 <y> gamegoblin: if you want an example of a monoid that doesn't have Eq, look at Endo 
13:36:10 <gamegoblin> y: thanks, good example
13:38:34 <marchelzo_> I'm calling createProcess with a CreateProcess that I made using proc, with std_out = Inherit, and it's not outputting anything even though it should be.
13:39:21 <tmtwd> how to write a flatten function so flatten [[1,2], [3], [4]] return [1,2,3,4]
13:39:21 <tmtwd> ?
13:39:53 <verement> > concat [[1,2], [3], [4]]
13:39:55 <lambdabot>  [1,2,3,4]
13:39:56 <weasel__> tmtwd: concat?
13:41:21 <slack1256> > join http://en.wikipedia.org/wiki/Special:Search?go=Go&search=2,3],[9],[8
13:41:22 <lambdabot>  <hint>:1:52: parse error on input ‘=’
13:41:28 <slack1256> > join http://en.wikipedia.org/wiki/Special:Search?go=Go&search=2,3],[9],[8
13:41:29 <lambdabot>  <hint>:1:52: parse error on input ‘=’
13:41:30 <slack1256> wtf
13:41:35 <tmtwd> yup thanks
13:42:03 <verement> > join [[1,2], [3], [4]]
13:42:05 <lambdabot>  [1,2,3,4]
13:42:18 <verement> :t join
13:42:19 <lambdabot> Monad m => m (m a) -> m a
13:46:56 <adarqui> tmtwd: also, hoogle "[[a]] -> [a]"
13:47:11 <slack1256> @hoogle http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a -> [a]
13:47:12 <lambdabot> Parse error:
13:47:12 <lambdabot>   http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a -> [a]
13:47:12 <lambdabot>             ^
13:47:16 <slack1256> god dammit
13:49:43 <weasel__> @hoogle [[a]]->[a]
13:49:44 <lambdabot> Prelude concat :: [[a]] -> [a]
13:49:44 <lambdabot> Data.List concat :: [[a]] -> [a]
13:49:44 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
13:53:15 * hackagebot old-version 1.3.1 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.3.1 (chrisdotcode)
13:53:24 <chrisdotcode> :D
13:54:28 <bergmark> :o
14:06:53 <tmtwd> > if even 3 then True
14:06:54 <lambdabot>  <hint>:1:1:
14:06:54 <lambdabot>      parse error in if statement: missing required else clause
14:12:13 <latk> what are peoples favourite libs for dealing with filepaths? There seem to be a few options.
14:12:36 <bergmark> chris done's new `path' library is neat
14:13:03 <bergmark> it requires that you want/can distinguish between files and directories though
14:13:37 <latk> That is cool.
14:13:41 <latk> I'll have a look.
14:16:45 <joel135> When talking about lists, is the s in xs the same as that in cats, dogs, houses?
14:17:05 <shachaf> Yes.
14:17:07 <ferret__> joel135: yes
14:18:52 <Tuplanolla> It's also the "excess".
14:19:16 <joel135> That's nice.
14:21:47 <tmtwd> If I have a list [[[1,2], [3,4]] [43,54], [2]], is the type [[[a]]]?
14:22:40 <fr33domlover> :t 5
14:22:41 <lambdabot> Num a => a
14:22:45 <ferret__> tmtwd: no, because you are trying to make a list with elements [[a]] and [a], it doesn't typecheck
14:23:00 <fr33domlover> :t [[[1,2], [3,4]] [43,54], [2]]
14:23:01 <lambdabot>     Couldn't match expected type ‘[Integer] -> [t]’
14:23:01 <lambdabot>                 with actual type ‘[[Integer]]’
14:23:01 <lambdabot>     The function ‘[[1, 2], [3, 4]]’ is applied to one argument,
14:23:05 <slack1256> tmtwd: also ghci to the rescue
14:23:27 <fr33domlover> tmtwd, see example above ^
14:24:00 <fr33domlover> (probably easier to use ghci directly though)
14:24:41 <tmtwd> >  let a :: Int ; a = [[[1,2], [3,4]] [43,54], [2]]
14:24:42 <lambdabot>  <no location info>:
14:24:42 <lambdabot>      not an expression: ‘let a :: Int ; a = [[[1,2], [3,4]] [43,54], [2]]’
14:24:54 <fr33domlover> you missed a ',' there
14:24:58 <fr33domlover> :t [[[1,2], [3,4]], [43,54], [2]]
14:24:59 <lambdabot> Num t => [[[t]]]
14:27:32 <ion> Heh, lambdabot has some evil instances.
14:27:44 <ion> > [[[1,2], [3,4]], [43,54], [2]]
14:27:46 <lambdabot>  [[[1,2],[3,4]],[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:28:02 <ion> @undefine
14:28:02 <lambdabot> Undefined.
14:28:15 <ion> > [[[1,2], [3,4]], [43,54], [2]]
14:28:16 <lambdabot>      No instance for (Show t0)
14:28:17 <lambdabot>        arising from a use of ‘show_M918418340762828398714063’
14:28:17 <lambdabot>      The type variable ‘t0’ is ambiguous
14:28:31 <tmtwd> >  let a :: Num; a =  [[[1,2], [3,4]], [43,54], [2]];
14:28:32 <lambdabot>  <no location info>:
14:28:32 <lambdabot>      not an expression: ‘let a :: Num; a =  [[[1,2], [3,4]], [43,54], [2]];’
14:29:10 <fr33domlover> tmtwd, 'a' can't be a list and a number at the same time :P
14:29:29 <ion> tmtwd: > only supports expressions. “let” without an “in” is not an expression.
14:29:39 <latro`a> what exactly was that infinite list from the finite list
14:29:53 <ion> Also Num is not a type.
14:29:57 <latro`a> ion> > [[[1,2], [3,4]], [43,54], [2]]
14:29:57 <latro`a> <lambdabot>  [[[1,2],[3,4]],[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:29:58 <latro`a> ^that
14:29:59 <latro`a> what was that?
14:30:11 <ferret__> fr33domlover: I have written a Num instance for [something] on purpose
14:30:33 <ferret__> I later regretted it and unwrote it, but there is at least one real purpose for it
14:30:36 <ion> Someone had defined an instance that looks like Peano numerals.
14:30:48 <latro`a> oh dear
14:31:14 <fr33domlover> yeah, it could make sense in some contexts - although perhaps a newtype should wrap it -
14:31:25 <ion> It was probably not infinite.
14:31:31 <fr33domlover> anyway, lambdabot doesn't know these custom instances, does it
14:31:57 <ferret__> It ended up being yet another case of Num.+ being the wrong concept
14:32:32 <Tuplanolla> > instance Num [a] where {x + y = []; x * y = []; x - y = []; abs x = []; signum x = []; fromInteger x = []}
14:32:34 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
14:33:16 <geekosaur> use @let instead of >. or better, don't :)
14:34:10 <Tuplanolla> Beginners love this instance.
14:34:43 <breadmonster_> Interesting.
14:34:56 <breadmonster_> Wait, are there any other interesting instances like that?
14:35:10 <breadmonster_> I remember Maybe is a monoid for some godforsaken reason.
14:35:26 <breadmonster_> > Just 3 `mappend` Just 4
14:35:28 <lambdabot>      No instance for (Show a0)
14:35:28 <lambdabot>        arising from a use of ‘show_M828128979547445897614204’
14:35:28 <lambdabot>      The type variable ‘a0’ is ambiguous
14:35:39 <breadmonster> > Just (3 :: Int) `mappend` Just 4
14:35:41 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mappend’
14:35:41 <lambdabot>      In the expression: Just (3 :: Int) `mappend` Just 4
14:35:54 <slack1256> Int is not a monoid
14:35:57 <Tuplanolla> It's Monoid a => Monoid (Maybe a).
14:35:59 <breadmonster> > (Just (3 :: Int)) `mappend` (Just 4)
14:36:01 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mappend’
14:36:01 <lambdabot>      In the expression: (Just (3 :: Int)) `mappend` (Just 4)
14:36:08 <slack1256> I mean it is, but it has two possible instances
14:36:11 <ion> Semigroup a => Monoid (Maybe a) would be reasonable.
14:36:18 <breadmonster> Isn't Num a a monoid under (+)?
14:36:25 <slack1256> but also under (*)
14:36:30 <slack1256> which do we pick?
14:36:32 <geekosaur> there's no good reason to pick (0,+) over (1,*)
14:36:37 <breadmonster> Yeah, but it seems to be instantiated to neither instance.
14:36:38 <geekosaur> so both are newtyped: Sum, Product
14:36:46 <freeman42> geekosaur, hey, you happen to be there? :) could you have a look at the last issue comments please https://github.com/commercialhaskell/stack/issues/466#issuecomment-118427579, related with the talk we had the day before
14:36:55 <breadmonster> geekosaur: oh okay (;
14:37:05 <slack1256> Just (Sum 5) <> Just (Sum 9)
14:37:07 <slack1256> > Just (Sum 5) <> Just (Sum 9)
14:37:09 <lambdabot>  Just (Sum {getSum = 14})
14:38:47 <breadmonster> Everything I had learned about typing just shattered.
14:38:51 <breadmonster> :t length . show
14:38:52 <lambdabot> Show a => a -> Int
14:38:57 <breadmonster> ...that's okay.
14:38:58 <geekosaur> hm?
14:39:03 <breadmonster> :t seq . length . show
14:39:04 <lambdabot> Show a => a -> b -> b
14:39:07 <breadmonster> wtf?
14:39:19 <ferretp_> :t seq
14:39:20 <lambdabot> a -> b -> b
14:39:27 <breadmonster> :t (.)
14:39:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:39:29 <geekosaur> freeman42, I would expect they do add up, yes. they do on POSIX
14:39:30 <ferretp_> :t const
14:39:31 <lambdabot> a -> b -> a
14:39:55 <ferretp_> breadmonster: seq is like `flip const`
14:39:57 <breadmonster> geekosaur: Isn't (.) only used to compose one argument functions?
14:39:59 <ferretp_> :t flip const
14:40:00 <lambdabot> b -> c -> c
14:40:08 <geekosaur> but my understanding of Windows is somewhat limited, for example I don't know if it passes envars the same way POSIX does
14:40:14 <breadmonster> ferretp_: No, I know what seq does, it's just that the types line up...
14:40:38 <freeman42> geekosaur, thank you, then that might very well be the problem, I'm thinking that stack does not use the cabal library the same way as cabal-install does, and it is subjected to the 8192 character command line length limit instead of the 32767 one
14:40:52 <breadmonster> Why do the types unify?
14:40:59 <Hijiri> breadmonster: seq is a oneargument function
14:41:05 <Hijiri> seq :: a -> (b -> b)
14:41:22 <ferretp_> :t (.) seq
14:41:24 <lambdabot> (a -> a1) -> a -> b -> b
14:41:26 <slack1256> > (seq . length . show) 59 "gato" 
14:41:28 <lambdabot>  "gato"
14:41:29 <breadmonster> Hijiri: Oh okay, now it's clear.
14:41:35 <breadmonster> Interesting.
14:41:39 <thimoteus> :t (.) . (.)
14:41:41 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:41:44 <geekosaur> freeman42, that seems likely. you'd have to ask people who know more about stack's internals *and* someone who knows more about Windows APIs though
14:41:57 <geekosaur> it's also possible they're using different APIs, note
14:42:22 <thimoteus> woooh movie finished
14:42:24 <thimoteus> time to WATCH
14:42:37 <breadmonster> Sometimes, getting types to line up is a bit like rocket science.
14:42:37 <geekosaur> it's not at all uncommon for there to be a Foo with one limit and a FooEx with a different limit, for example
14:43:30 <ferretp_> does anyone know if there's a largest field with decidable equality?
14:43:55 <freeman42> geekosaur, I would not mind trying to figure out the issue in the code if it was C#, but cause of the state of Haskell IDEs it's hard to find something that does at least go to definition properly, and that is invaluable when reading existing code
14:44:08 <ferretp_> not counting constructions like R -> C
14:44:11 <breadmonster> freeman42: fpcomplete has that.
14:44:36 <slack1256> hasktags?
14:44:42 <freeman42> breadmonster, yes, and probably quite good one, but, does it allow to edit stack in there?
14:44:57 <breadmonster> I'm not sure.
14:45:05 <freeman42> only tried it with small code bases, and it was really really good support
14:46:10 <freeman42> slack1256, most plugins/IDEs seems to have problem with a lot of symbols, some go to definition, some do not, in C#/Java/Scala IDEs, that just works all the time (TM, sort of)
14:46:53 <slack1256> I mostly use hasktags ETAGS and with operator a little grep-fu works wonders
14:47:08 <slack1256> Seriously I only *discovered* grep 2 years ago and my life changed
14:50:01 <benzrf> slack1256: cripes
14:50:14 <ferretp_> on a related note, is there a matrix library that does the optimal evaluation order algorithm?
14:51:43 <freeman42> slack1256, grep is cool, but when you can use tools that actually understand your code, that is much much better
14:52:42 <gfixler> Personally, and historically, I've not much liked things that understand my code
14:53:01 <slack1256> the usually pretend to understand it
14:53:15 <gfixler> I've run screaming from all IDEs
14:53:18 <ferret2_> hblas doesn't seem to
14:53:27 <gfixler> back to the welcoming, GUIless arms of Vim
14:53:38 <slack1256> or kate
14:53:47 <latk> I'm looking at system-filepath, which seems quite nice. However, I can't quite work out how you actually can then use these filepaths. For instance, I have constructed a FilePath, and wish to write a file at that location. All functions I see to do this need a Prelude.FilePath.
14:54:08 <latk> Are you just supposed to use show? This seems like a bad way of doing it.
14:54:12 <ferret2_> most of the things an IDE would do for me in say java GHC does better already
14:54:32 <slack1256> latk: but that way you only have to trust the Show instance
14:54:52 <slack1256> as in at least the construction of such path should not be incorrent
14:54:55 <slack1256> *incorrect
14:55:18 <latk> slack1256: Hmm, I guess. Somehow seems wrong, though!
14:55:29 <slack1256> latk: But it feeels so right!
14:55:57 <slack1256> seriously, our senses of aesthetics are wrapped
14:56:01 <Cale> latk: There's encodeString/decodeString
14:56:22 <latk> Cale: Where do these live? I must have missed them.
14:56:29 <Cale> Filesystem.Path.CurrentOS
14:56:53 <latk> Cale: Yeah, that is what I was expecting. No idea how I missed it. Cheers!
15:02:05 <latk> If I have something with  ToJSON instance, what is the easiest way to pretty print this type to a file as JSON ?
15:02:17 <latk> something of this type, I mean
15:04:46 <tmtwd> How can I do this correctly such that I get a list of only every other index? doubleEveryOther xs = [x * 2 | x<-xs, xs !! n `mod` = 0 ]
15:07:52 <ferret2_> tmtwd: you want every other element, all multiplied by two?
15:08:03 <tmtwd> ferret2_,  yes ...
15:08:07 <Tuplanolla> You could zip xs together with [0 ..] first.
15:08:20 <tmtwd> oh yeah
15:09:57 <gamegoblin> I want to make a function like "consumable :: a -> IO (Maybe a)" that, the first time the action is performed, it returns "Just a". All subsequent calls return "Nothing". Best way to do this? Something with MVars or IORefs maybe?
15:10:24 <Tuplanolla> IORef Bool should do.
15:10:56 <gamegoblin> Tuplanolla: Any chance you can throw together an example?
15:11:12 <hpc> you probably don't want that type signature, also
15:11:26 <Tuplanolla> Not at the moment.
15:11:29 <gamegoblin> hpc: what should it look like?
15:11:30 <hpc> consumable :: a -> someSortOfState -> IO (Maybe a)
15:12:01 <gamegoblin> Not sure I follow
15:12:01 <hpc> using hidden state like that gives me the heeby-jeebies
15:12:16 <hpc> you need some sort of state in consumable to know how many times it has been called
15:12:30 <hpc> and you could make it implicit, which is weird to implement
15:12:33 <ferret2_> hpc: I think he wants the state to be in the action produced
15:12:36 <hpc> or just pass the state in along with the thing
15:12:39 <gamegoblin> So if this were entirely IO, the signature would look like a -> IO (IO a) ?
15:13:06 <gamegoblin> That is pretty hairy
15:14:29 <hpc> basically, if you're defining consumable as a top-level function, it has to use some kind of global state
15:14:36 <tmtwd> any tips on this function? doubleEveryOther xs = [x * 2 | x<- (map head (zip xs [0..]))]
15:14:47 <hpc> and then the question moves from "how to implement consumable" to "how to implement global state"
15:14:53 <hpc> and the answer is "unpleasantly"
15:15:01 <gamegoblin> hpc: sounds like IO
15:15:06 <tmtwd>  i get this error   Couldn't match type `(a1, b0)' with `[a0]'   Expected type: [[a0]]
15:16:05 <hpc> https://wiki.haskell.org/Top_level_mutable_state -- gamegoblin
15:16:16 <hpc> it's not just "sounds like IO", it's much weirder
15:17:49 <Tuplanolla> Here's an old version of a toy project of mine that uses your idea to implement io, gamegoblin: https://github.com/Tuplanolla/eigenlanguage/tree/30e01b8ad1c58c8cb862dcfce7b969f53342d19f/haskell
15:18:01 <kqr> is there a good introduction to actually making property testing work in a real application with a bit more hairy functions? (i.e. not just "here's how we can test that reverse . reverse = id")
15:18:14 <hpc> the simplest way out of that mess is to take the state as another parameter
15:18:15 <Tuplanolla> Look at data Expression inside Common.hs.
15:18:30 <ferret2_> tmtwd: map (*2) . filter ??? . zip [0..] or sometihng
15:20:39 <hpc> kqr: depends on the application; writing tests is a bit of an art form
15:21:17 <hpc> kqr: but pick some invariants you want to hold, and decide how you want to assert they are true
15:22:09 <hpc> for reverse . reverse = id, it might just be [] -> [], "123" -> "321"
15:22:29 <hpc> er
15:22:43 <hpc> (that, except testing reverse . reverse, not reverse)
15:23:22 <hpc> in some places, you can just test a couple of things and say that parametricity makes the same invariant hold in many more cases
15:23:51 <kqr> as a concrete example, I have a function called "moveP" that reaches into a record and updates the position field of a thing to be +~ its speed
15:24:05 <kqr> I could write a test that makes sure the new thing has a position that's the old thing + its speed
15:24:20 <kqr> but that feels incredibly wasteful when that's exactly what the implementation is saying anyway
15:24:45 <MisaMisa> what's the purpose of using Bag in GHC source code? for O(1) concatenation?
15:24:49 <hpc> it's pretty wasteful in that case, yeah
15:24:49 <MisaMisa> Bag.hs: https://github.com/ghc/ghc/blob/master/compiler/utils/Bag.hs
15:25:08 <hpc> kqr: but if moveP also accounted for gravity or obstructions, that'd be worth testing for
15:25:37 <kqr> MisaMisa, a bag is a set which allows duplicates, so the purpose is anything you'd use a set for except when you want to allow duplicates
15:25:45 <kqr> MisaMisa, be it for the performance or the api
15:25:50 <kqr> /interface, not api
15:26:05 <hpc> kqr: or if you decide your entity is moving over a world that wraps at the edges, and that's good to test too
15:26:08 <kqr> hpc, how come that'd suddenly make it worth testing for?
15:26:11 <ferret2_> kqr: is it basically a sorted list then?
15:26:54 <kqr> ferret2_, well, a set needn't be sorted
15:27:02 <kqr> ferret2_, in fact, the order of a set is supposed to be irrelevant
15:27:15 <kqr> hpc, I guess maybe my problem is in knowing what's worth testing for
15:27:18 <hpc> kqr: the extra functionality would lift it out of triviality
15:27:21 <hpc> kqr: exactly
15:27:29 <ferret2_> kqr: I've internalized the implementation details :(
15:28:01 <y> for a game, I would go with a function checkInvariants :: GameState -> Maybe Error, that you would hook, checking for invariants after every step (in some kind of test-mode) 
15:28:04 <hpc> it's probably worth testing anyway to make sure it actually moves the entity
15:28:15 <y> (plus any other kind of test)
15:28:25 <hpc> but eventually there's always some threshold of "it's obvious" where you stop writing tests
15:28:46 <hpc> and finding that threshold is purely educated guessing and opinion
15:28:55 <ferret2_> y: I've seen people include a full save/reload cycle in that function to really check everything
15:28:57 <kqr> hpc, but at some point, by testing too much, you are literally taking more than 200% of the time needed, because you need to write the implementation twice and then whenever you change the structure of the code you need to rewrite the tests too, no?
15:29:08 <hpc> yep
15:29:22 <hpc> a good rule of thumb is
15:29:33 <kqr> maybe it's especially tough for me because I prototype a lot and refactor very aggressively
15:29:52 <y> it'd make sure the entities are in the "rooms", that the current game state makes sense (if there are entities with hp=0, something's wrong, if there is a player with negative points (when that'd be invalid), something bad happened..) 
15:29:57 <hpc> if there's room for multiple (worthwhile to actually write and use) implementations of a function
15:30:14 <kqr> y, that's a good point actually, I was just thinking about that too
15:30:18 <hpc> without observably changing the function
15:30:22 <kqr> y, but that borders on unit testing, not property-based testing
15:30:41 <hexagoxel> what llvm version (upper bound) to use with ghc?
15:30:46 <hpc> then it's worth testing and your test would be another implementation
15:30:51 <y> I was talking about some kind of testing, that I actually would find normally useful :P 
15:31:24 <y> because if you know the invariant got violated in the function xyz, which is funnily enough just 4 lines, then you know where to check :P 
15:31:28 <hpc> all testing is more or less the same anyway, as far as the art of writing tests vs not writing tests goes
15:32:00 <mwmwmwm> :quit
15:32:30 <y> testing is checking what we can't put in our type systems! 
15:32:46 <hpc> monte-carlo proofs ;)
15:32:47 <kqr> y, yeah, it's just that when I write code 4 line functions pop up and disappear again within the hour, so it'd feel wasteful to write tests for them just to throw them out again an hour later
15:33:28 <hpc> kqr: so delay writing tests for that module until it's got a more stable api
15:34:07 <kqr> then it never happens lol
15:34:13 <hpc> heh
15:34:19 <y> I'd try to refactor the types then
15:34:21 <kqr> but yeah maybe I should just have more discipline in actually taking the time to write tests later
15:34:25 <hpc> at the end of the day, testing is a technique to automate "eh, works for me"
15:34:44 <hpc> and not every project needs tests
15:34:57 <y> adding newtypes and using phantom types and going with the compiler checking things
15:35:03 <hpc> you'll know it when you run into a bug and go "dammit, this could have been caught so much earlier"
15:35:24 <Tuplanolla> Spend too much time planning and write proofs instead.
15:35:35 <ferret2_> is it common to put a parameter into the type just for parametricity? that's one of my more common "tests"
15:35:38 <kqr> most of my projects probably don't need tests, but I'd like to write them anyway to get better at it
15:35:45 <Tuplanolla> If they become useless, just release them as spin-offs.
15:35:55 <y> ferret2_: it's also useful when things may change
15:36:37 <hpc> kqr: as a small anecdote, i have an on-and-off package i am writing that interfaces with imagemagick
15:36:53 <hpc> and when i write in a bit of functionality, i use some images to screw around with it and see how it works
15:37:17 <hpc> so i stick all those manipulations i write into a Tests.hs that just runs them in sequence
15:37:30 <hpc> and then run it every so often and look at the images and go "eh, looks close enough to what i want"
15:37:48 <y> data Game meta = Game { _points :: ..., _players :: ..., _metadata :: meta, ... }
15:37:49 <kqr> hpc, yeah, that's what I have been doing to learn unit testing, but I don't feel like it's quite the same thing as property-based testing
15:37:56 <kqr> hpc, my manual tests tend to be unit-y, not property-y
15:38:38 <kqr> but I'll read a bit and watch a couple of presentations on it
15:38:41 <kqr> and we'll see where I end up
15:38:44 <kqr> thanks for the advice
15:40:03 <hexagoxel> hexagoxel: llvm-3.5. you are welcome.
15:41:48 <hpc> actually, here's a good example of a property test you could use on movement
15:41:59 <hpc> property: moving into a wall stops you
15:42:11 <hpc> to test the property, set up a person and a wall at random orientations
15:42:19 <hpc> have the person move directly towards the wall for a while
15:42:25 <hpc> and then test that the person is touching the wall
15:43:43 <hpc> you'll get used to it with practice and understanding; testing is a pretty fuzzy problem
15:47:09 <kqr> that's a good idea, yeah
15:53:20 * hackagebot rethinkdb-client-driver 0.0.19 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.19 (wereHamster)
15:53:22 * hackagebot hscrtmpl 1.3 - Haskell shell script template  http://hackage.haskell.org/package/hscrtmpl-1.3 (DinoMorelli)
15:56:48 <gamegoblin> hpc: this works http://lpaste.net/8998314835716341760
15:57:21 <hpc> gamegoblin: nice
16:01:40 <ew_> hi, which is the best way to add many pairs of (key,values) to a Data.Map?
16:02:06 <ew_> I'm using Map.union m1 $ Map.fromList suchList
16:02:13 <ew_> is it efficient?
16:03:54 <gamegoblin> ew_: I’m sure it’s not too bad. If you really want, you could make a fold or call insert recursively. Not sure which would be better.
16:06:10 <ew_> foldl (\m (k,v) -> Map.insert k v m) m1 suchList ?
16:06:18 <sccrstud92_> @pl f x = (x, x)
16:06:19 <lambdabot> f = join (,)
16:06:20 <ew_> :type fold
16:07:09 <ew_> :t foldl
16:07:11 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
16:07:27 <sccrstud92_> my guess is they have the same asymptotics
16:09:59 <ew_> another question, I'm writing a search in a state space 
16:10:16 <ew_> http://acm.timus.ru/problem.aspx?space=1&num=1060
16:10:20 <ew_> for this problem
16:10:38 <ew_> are there any patterns to do this kind of search?
16:11:25 <Tuplanolla> Recursive backtracking?
16:11:31 <ew_> yes
16:11:44 <Tuplanolla> You can just write out all the paths. Laziness makes it easy.
16:11:48 <ferret2_> ew_: bit boards might be useful
16:12:01 <ew_> I'm using an int to model my board
16:12:27 <ew_> already. But my haskell program is using 2 times the memory of the C++ version
16:12:35 <ew_> and 2 times the excecution time
16:12:43 <ew_> I'm trying to figure out why
16:13:05 <ew_> https://github.com/wuerges/maratona/blob/master/Flip.cc
16:13:11 <ew_> https://github.com/wuerges/maratona/blob/master/Flip.hs
16:14:11 <kqr> hpc, this was very enlighening: https://www.youtube.com/watch?v=shngiiBfD80
16:14:46 <Tuplanolla> Have you tried -fvia-C -optc-O2, ew_?
16:18:25 <ew_> -fvia-c is not in 7.10 anymore, I think
16:18:39 <ew_> so, no
16:20:26 <ew_> uhmmm
16:20:36 <ew_> I'll try using an IntMap later
16:20:40 <ew_> instead of Map
16:26:23 <Tuplanolla> BangPatterns comes into mind, but I don't really know how to make good use of them here.
16:27:36 <Tuplanolla> Tell me when you figure it out.
16:46:33 <mzero> ew_: so, you are trying to find the minimal number of xor mask operations it takes to get a number by enumerating from all zeros or all ones - right?
16:47:33 <mzero> first, as written, you should be using Data.Map.Strict - since I think you are building up a bunch of thunks in a Map that you, in generall, always need
16:50:55 <mzero> Second - it might be easier - and more space efficient, to generate the "TODO List" as an actual lazy list - rather than as a Set
16:55:02 <edwardk> also a 4x4 board is 16 bits. you can enumerate all the boards and all the transitions between them very easily
17:08:40 <edwardk> ew_: Seq is a usable queue, but it isn't the most efficient one in terms of space
17:13:05 <athan> > data Cons a = Cons a (Maybe (Cons a)) -- is there a name for this style of list encoding?
17:13:06 <lambdabot>  <hint>:1:1: parse error on input ‘data’
17:13:13 <athan> :x
17:13:54 <y> it's just a reorganization of the definition of a non-empty-list 
17:16:43 <tabemann> I haven't worked with Haskell for quite some time, so what is the generally recommended Haskell version to work with?
17:20:05 <tabemann> okay, so the Haskell platform is still using 7.8.3... so I'll stick with what I have
17:20:56 <lpaste> lamefun pasted “Why is monomorphism restriction handling so broken?” at http://lpaste.net/135820
17:21:41 <appl12> does anyone know of lightweight ghc?
17:21:49 <appl12> like small
17:22:28 <tabemann> lightweight ghc?
17:22:37 <appl12> yea like the ghci
17:22:49 <appl12> smaller than the regular one
17:22:53 <tabemann> ghci isn't "lightweight", it's just a toplevel
17:24:03 <tabemann> there really is no "lightweight" Haskell implementation that is compatible with GHC
17:25:11 <tabemann> you can run GHC without the whole Haskell Platform, but GHC isn't that useful that way
17:30:57 <ew_> edwardk, but I'm appending items to the queue
17:31:04 <ew_> even son is it better to use the lazy list?
17:31:10 <ew_> even so*
17:31:21 <edwardk> ew_: no, just indicating that Seq and [] aren't your only choices
17:31:52 <edwardk> here you are working ephemerally so you don't need to care too much about fancy operations to keep things from having pathological step costs
17:32:51 <ew_> uhm, the problem is that these problems
17:32:58 <ew_> are meant to be solved using C
17:33:09 <ew_> so they have very tight memory and runtime limits
17:34:10 <ew_> often you have to use bamboozle a solution that would scale well 
17:34:13 <ew_> to a smaller scale
17:34:29 <edwardk> so you could use something like data Queue a = Queue [a] [a]; push (Queue f r) a = Queue f (a:r); pop (Queue (a:f) r) = Just (a, Queue f r);  pop (Queue [] [])  = Nothing; pop (Queue [] r) = case reverse r of (a:f) -> Just (a, Queue f []);
17:34:56 <edwardk> ^- that woulld have less than half the memory foot print of a Seq, and for ephemeral access better constant factors
17:35:10 <edwardk> okasaki's book shows how to win even when you have persistent access
17:35:33 <edwardk> so i'm offering you a solution that has better constant factors, less code and uses less memory. that is all
17:36:24 <edwardk> here the queue is just a pair of lists, the second of which is stored in reverse order, when the first one runs out we reverse the second and slop it over to the first
17:36:37 <edwardk> ou don't need random access in your queue, just a queue
17:36:48 <edwardk> Seq is "too much" for your needs
17:38:11 <edwardk> second, if you really want to minimize space you can replace the map with a mutable array in ST or something, so now you just have a queue in the form of two lists and a fixed sized mutable array and an ST calculation that mimics the c code exactly
17:38:26 <edwardk> and the unboxed array will use a lot less memory than any map
17:42:44 <eds> I am learning how to use forall and it gives me the following error: http://lpaste.net/135821
17:43:07 <edwardk> {-# LANGUAGE ExistentialQuantification #-}
17:43:14 <edwardk> not {-# ExistentialQuantification #-}
17:46:38 <eds> ahh thank you!
17:46:43 <eds> edwardk
17:53:29 <appl12> > let ab = [x:xs]
17:53:31 <lambdabot>  <no location info>: not an expression: ‘let ab = [x:xs]’
17:54:11 <tabemann> you want: let ab = x : xs in ...
17:54:20 <tabemann> well wait
17:54:24 <appl12> i want to use list for arguments
17:54:30 <appl12> function arguments
17:54:45 <appl12> instead of add x y
17:55:05 <tabemann> let ab = [x : xs] in ... should be okay - lpaste your entire code
17:55:24 <y> appl12: do you really want a list and not a tuple?
17:55:37 <tabemann> I was thinking that too
17:55:37 <y> > let f (x,y,z) = x+y*z in f (2,3,4) 
17:55:38 <lambdabot>  14
17:56:16 <tabemann> you probably don't want to put arguments in a list, unless you have a good reaosn for it
17:56:34 <tabemann> but then, typically there is nothing to be gained by putting arguments in a tuple either
17:56:40 <y> appl12: considering lists are of unknown length, also, I think you might be using the wrong pattern, [x:xs] is a single-element list, with that first element being a list, whose head is `x` and its tail is `xs` 
17:56:55 <y> > let f [x:xs] = x in f [[1,2,3]]
17:56:57 <lambdabot>  1
17:57:06 <y> > let f [x:xs] = x in f [[1,2,3],[4,5]]
17:57:08 <lambdabot>  *Exception: <interactive>:3:5-16: Non-exhaustive patterns in function f
17:58:06 <geekosaur> also note that [x:xs] is a list of lists
17:58:14 <geekosaur> (x:xs) is a list in decomposed format
18:01:37 <appl12> > let alg [x:xs] = x in alg [3,4]
18:01:39 <lambdabot>      No instance for (Show a0)
18:01:39 <lambdabot>        arising from a use of ‘show_M260136556707817225617433’
18:01:39 <lambdabot>      The type variable ‘a0’ is ambiguous
18:02:38 <y> > let alg (x:xs) = x in alg [3,4]  
18:02:39 <lambdabot>  3
18:02:56 <y> appl12: ^ as geekosaur said, [x:xs] represents a list of lists 
18:20:17 <lamefun> Does laziness mean that IO can happen inside pure code?
18:24:01 <drbean_> Isn't [[1,2,3],[4,5]] also a list of lists?
18:30:03 <ew_> edwardk, what
18:30:06 <ew_> great idea
18:30:09 <ew_> what's this book?
18:30:11 <ew_> Okasaki?
19:14:07 <creichert> ew_: Purely Functional Data Structures
19:14:56 <creichert> the queue he is referencing is introduced very quickly too
19:17:08 <P4Titan> Hello all, is it possible to make a newtype SomeType = SomeType Int and then do something line 1 + (SomeType 2) and it come out to 3?
19:18:03 <P4Titan> Disregard that, it is silly
19:28:48 <rvxi> anyone know  how to get runhaskell to recognize a shared sandbox?
19:31:17 <geekosaur> cabal exec?
19:34:19 <rvxi> how's that?
19:34:22 <rvxi> cabal exec bash
19:34:27 <rvxi> ?
19:34:40 <rvxi> cabal exec bash
19:34:42 <rvxi> followed by
19:34:47 <rvxi> runhaskell Main.hs
19:34:53 <rvxi> doesn't seem to use the shared sandbox
19:35:29 <slack1256> rvxi: cabal repl 
19:35:44 <slack1256> that is like 'cabal exec ghci'
19:37:56 <rvxi> should cabal exec ghci use the sandbox?
19:38:01 <rvxi> shared sandbox i mean
19:38:10 <slack1256> yep
19:38:22 <slack1256> cabal repl though
19:39:13 <rvxi> hm weird
19:39:23 <rvxi> cabal exec runhaskell Main.hs -v
19:39:31 <rvxi> seems to say its using the shared sandbox
19:39:41 <rvxi> but ghci can't find the module
19:39:56 <slack1256> and cabal repl?
19:41:20 <Bruno_> Hi, I'm trying to install the latest version of threadscope on windows, which need GTK. Does I need to download GTK+ 3.x or GTK+ 2.x? 
19:41:46 <rvxi> still not working
19:41:52 <rvxi> when i launch ghci from emacs
19:42:00 <rvxi> and point ti to the sandbox from the emacs prompt it works
19:42:09 <MarcelineVQ> you only need gtk if you're compiling don't you?
19:42:17 <MarcelineVQ> https://wiki.haskell.org/ThreadScope#Installing_ThreadScope tried the zip here?
19:43:26 <MarcelineVQ> if you really do need it though it looks like gtk2
19:43:28 <Bruno_> Ya, but I'm having a crash on this version (0.2.2) which is fixed by the version 0.2.3, which doesn't have a binary lol
19:43:30 * hackagebot mueval 0.9.1.1.2 - Safely evaluate pure Haskell expressions  http://hackage.haskell.org/package/mueval-0.9.1.1.2 (GwernBranwen)
19:45:12 <Bruno_> okay thanks MarcelineVQ 
19:55:14 <ferret2_> So I am aware (but do not grok) that Moore machines are an efficient way to represent DFAs. Could I usefully use them for the transitions in a kripke structure
19:56:13 <ferret2_> I would like a representation for the paths in tree temporal logic that only contains possible paths, so I need something better than a list of states
19:59:59 <ferret2_> currently I just have ([s], s -> [s])
20:01:09 <slack1256> so something like a Lazy Map with tying the knot recursion? 
20:01:14 <slack1256> or I am overcomplicating?
20:01:39 <dramforever> maybe just usual maps are enough
20:02:18 <ferret2_> I don't know if I'm able to tie the knot with that format
20:02:47 <dramforever> ferret2_: maybe
20:03:08 <ferret2_> dramforever: ([s], Map s s)?
20:03:25 <dramforever> maybe (Set s, Map s s)
20:03:38 <dramforever> I don't know if that works
20:05:02 <ferret2_> I don't know if that will memoize, or how to determine that
20:05:56 <ferret2_> Also, I was confused about what the data structure is
20:06:20 <Bruno_> Hi, I'm having trouble installing GTK2 on windows, it fail at the "Gtk2Hs Bindings" step. The tutorial say that I have to "After installing gtk2hs-buildtools, make sure that gtk2hsC2hs is in a directory that is on your %PATH%", how does I check if that's the case?
20:06:20 <ferret2_> (s, Map s [s]) represents all possible paths from the current state
20:06:51 <ferret2_> but I want to specify one single path forward
20:06:51 <dramforever> Bruno_: run echo %PATH% in a cmd window
20:07:06 <dramforever> dunno
20:07:54 <Bruno_> well, I can see all the directories of my path, but it doesnt tell me where gtk2hs-buildtools is lol
20:08:00 <ferret2_> (s, Map s [s], s -> [s] -> s) specifies one path, but it doesn't feel like the right answer
20:09:48 <ferret2_> Path s = Path s (s -> [s]) (s -> [s] -> s) is at least correct
20:10:55 <ferret2_> ah, no it isn't. I need to think on it more
20:12:35 <ferret2_> thanks for rubber-duck services
20:25:16 <ttt_fff> WTF: so "FooT Bar" --> this makes Bar the "outer monad" and Foo the "inner moand" ?
20:26:02 <ReinH> @unmtl StateT s m a
20:26:02 <lambdabot> s -> m (a, s)
20:26:35 <mniip> ttt_fff, that adds the Foo's effect on top of Bar's effect
20:26:42 <mniip> not necessarily inner and outer
20:26:43 <ReinH> compare
20:26:49 <ReinH> @unmtl State s a
20:26:49 <lambdabot> s -> (a, s)
20:43:57 <jle`> i think i often hear the completely meaningless terminology choice of Foo as the outer 'wrapping' Bar the inner, but the words wrap, inner, and outer really have no meaning in the sense of the words wrap, inner, and outer in english
20:46:41 <jle`> i think people have this mental image of monad transformers like those nested russian dolls
20:47:55 <sailorswift> https://leanpub.com/gameinhaskell Does anybody know if this book is worth the purchase?
20:48:21 <lethjakman> is * an alias of `mappend` for monoids?
20:48:29 <lethjakman> I'm not quite sure how to check that
20:48:50 <felixn> sailorswift: i mean, it's sliding scale, $10 isn't very much :D  be impulsive
20:49:02 <sailorswift> Looks like I'll be impulsive then :)
20:49:54 <ferret2_> jle`: I recall an stack overflow post from a while back that made monad transformers by turning every monad into from and back transformations and then actually nesting them. I will search for it
20:50:26 <jle`> lethjakman: (*) usually is multiplcation from the Num typeclass
20:50:33 <jle`> but there's an alias for mappend in Prelude, <>
20:50:36 <Javran> hello, I find "HasDynFlags" typeclass in ghc, and the only method is getDynFlags :: m DynFlags, most use of it I find in the code base is inside a do-notation, e.g "dynFlag <- getDynFlags", so my question is, for "HasDynFlags m", does m have to be at least Functor to make this typeclass useful?
20:50:46 <jle`> you can usually search in hoogle or hayoo for operators like that
20:50:48 <jle`> :)
20:51:38 <Clint> lethjakman: are you asking about Monoid (Product a)?
20:52:27 <lethjakman> I'm confused about the multWithLog function here: http://learnyouahaskell.com/for-a-few-monads-more
20:52:37 <lethjakman> where they're multiplying (a*b)
20:53:11 <lethjakman> those are two tuples aren't they? 
20:54:32 <mniip> no
20:54:57 <Javran> :t writer
20:54:59 <lambdabot> MonadWriter w m => (a, w) -> m a
20:55:04 <mniip> a and b are Ints
20:55:27 <Javran> this is a function accepting pairs
20:56:05 <lethjakman> so logNumber returns a Writer (x, []) 
20:56:42 <lethjakman> how does it have [] in the rutnr of multWithLog since it's returning (a*b) and that's the last thing in the function?
20:56:56 <mniip> logNumber  returns Writer [String] Int
20:57:03 <Javran> actually mzero is fed by runWriter
20:57:22 <mniip> oh
20:57:50 <lethjakman> but where is the array being handled in the multWithLog function?
20:57:55 <Javran> Writer itself doesn't care what's already in the "log"
20:57:57 <lethjakman> it should just disappear shouldn't it?
20:58:12 <lethjakman> or is something magical happening in the background because of Writer
20:58:19 <Javran> it's in the (>>=)
20:58:20 <mniip> lethjakman, the log is managed by the writer monad
20:58:31 <Javran> (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
20:58:35 <lethjakman> ahhh
20:58:43 <Javran> see mappend there?
20:58:46 <lethjakman> being in >>= would make more sense to me
20:58:58 <Javran> :)
20:59:27 <mniip> Javran, I don't think mzero comes from runWriter
20:59:28 <lethjakman> so, did they override * for Writer?
20:59:37 <mniip> instead 'return' feeds it
20:59:42 <Javran> :t runWriter
20:59:43 <lambdabot> Writer w a -> (a, w)
20:59:44 <mniip> lethjakman, no, why?
21:00:11 <Javran> oh right, it's from return
21:00:30 <lethjakman> how is the [] being handled in the background? 
21:00:39 <lethjakman> being in return makes sense, but where does the [] disappear to?
21:00:45 <Javran> I just though runWriter like runState
21:01:02 <mniip> lethjakman, which [] you mean
21:01:20 <lethjakman> but I never see it anywhere. <- takes it off into a magical variable behind the scenes then return wraps it back in to my return value?
21:01:29 <lethjakman> I mean the Writer(x, [])
21:01:33 <lethjakman> the array in Writer
21:01:48 <mniip> where did you get 'Writer(x, [])' from
21:02:05 <lethjakman> logNumber
21:02:12 <lethjakman> sorry I'm probably confused and being unclear
21:02:21 <mniip> logNumber doesn't return [] in there
21:02:45 <citizen11> Anyone got tips for installing haskell on Arch?
21:02:46 <lethjakman> " Writer (x, ["Got number: " ++ show x])  "
21:02:59 <mniip> lethjakman, that's a one-element list, not empty list
21:03:20 <lethjakman> citizen11: https://wiki.archlinux.org/index.php/Haskell#Haskell_platform
21:03:34 <lethjakman> haskell platform was great in my experience
21:03:50 <citizen11> Ah, ok, wasn't sure about that one. I'll give it a try. Thanks!
21:03:51 <lethjakman> mniip: sorry, I was just using [] to denote an array
21:04:07 <lethjakman> how would I write out a one-element list?
21:04:11 <mniip> that's not an array
21:04:23 <lethjakman> no?
21:04:27 <mniip> lists are not arrays
21:04:36 <lethjakman> how are they different?
21:04:51 <ferret2_> arrays have constant-time access
21:04:59 <mniip> usually arrays are fixed size, with O(1) indexing
21:05:04 <lethjakman> oh
21:05:25 <mniip> and lists are variable size, most often linked lists, with O(i) indexing
21:05:29 <lethjakman> that makes sense
21:05:34 <lethjakman> I think I read that and forgot about it
21:05:40 <mniip> anyway
21:05:52 <mniip> logNumber returns  Writer (x, [...])
21:05:53 <mniip> se
21:05:54 <mniip> so*
21:07:14 <lethjakman> but <- sets a = to an integer though doesn't it?
21:07:19 <mniip> yes
21:07:33 <lethjakman> and ["Got number.."] disappears somewhere off into the background 
21:07:44 <mniip> it is handled by other parts of >>=
21:07:48 <citizen11> Damnit AUR haskell-platform build failed...
21:07:50 <lethjakman> then return (a*b) would return the value with that reattached somehow?
21:08:12 <mniip> lethjakman, just look at the definition of 'return' and '>>=' for Writer
21:08:21 <eckyputrady> Hi guys, I'm currently writing functional test for my API server written with Scotty. I want to clear the database every time a test run. However, after checking persistent docs, I can't find any function to drop table. Can anyone give pointer on how this usually done?
21:08:51 <lethjakman> mniip: I was actually attempting to do that here: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Class.html
21:08:56 <lethjakman> but it doesn't seem to have >>=
21:09:02 <lethjakman> I'm sure I'm looking at the wrong thing somehow
21:09:08 <mniip> yes
21:09:16 <mniip> the closest you have to Writer is WriterT
21:09:33 <mniip> which is a transformer, and is a whole layer of complexity on top of monads
21:09:42 <mniip> lethjakman, the LYAH page you linked includes the definition
21:11:28 <lethjakman> thank you for your help
21:15:55 <mniip> lethjakman, I'm not sure you understood very well what operation does <- do
21:17:39 <lethjakman> mniip: it just does >>= doesn't it?
21:18:19 <mniip> it is >>= coupled with an abstraction
21:18:33 <bb010g> If I'm using `stack`, should I use Stackage, or will normal Hackage work just fine?
21:18:41 <mniip> 'x <- m; ...' -> 'm >>= \x -> ...'
21:20:11 <mniip> lethjakman, so that function for example
21:20:31 <mniip> logNumber 3 >>= \a -> logNumber 5 >>= \b -> return (a * b)
21:28:43 <lethjakman> mniip: that makes sense to me
21:28:54 <lethjakman> I was just having issues figuring out what the return did
21:29:17 <mniip> lethjakman, return wraps the value in a dummy context
21:29:30 <mniip> in writer's case, it adds an empty log
21:52:06 <eckyputrady> Hi guys, I'm currently writing functional test for my API server written with Scotty. I want to clear the database every time a test run. Can anyone give pointer on how this usually done?
21:54:17 <sailorswift> I would just mock your database.  You're using an external library for your database, right?
21:55:28 <dmj`> eckyputrady: which database?
21:55:49 <dmj`> eckyputrady: hspec has a nice "before" combinator for performing arbitrary IO actions before a test is run
21:57:13 <eckyputrady> It's MySQL ... I don't want to mock my DB because I'm doing something like "end-to-end" test
21:57:49 <eckyputrady> Yep, there is "before" in hspec, however I'm struggling with the actual code on dropping existing tables
21:58:00 <eckyputrady> I'm using persistent FYI
21:58:12 <mjrosenb> @hoogle (a -> IO (Maybe b)) -> [a] -> b -> IO b
21:58:13 <lambdabot> No results found
21:58:14 <eckyputrady> can't find any function to drop tables
21:59:48 <mjrosenb> I want to apply some function to every element in a list, stopping at the first one that returns (Just foo)
22:02:37 <mniip> mjrosenb, and if all of them return Nothing?
22:02:55 <dmj`> :t \f -> takeWhile (/= Just "foo") . map f
22:02:56 <lambdabot> (a -> Maybe [Char]) -> [a] -> [Maybe [Char]]
22:03:22 <mjrosenb> mniip: that is what the b argument was for in the signature I searched for.
22:05:02 <mniip> mjrosenb, I think you'll have to implement it yourself
22:06:26 <mniip> foo f (x:xs) = do { s <- f x; case s of Just r -> return r; Nothing -> foo f xs }
22:06:37 <mniip> oops needs the default argument too
22:07:02 <likecolacola> out of curiosity... are C and Haskell equivalents in terms of overall software speed?
22:07:23 <mniip> likecolacola, languages don't have speed
22:07:34 <nolrai666> Really good C is faster.
22:07:42 <mniip> really good haskell can be faster
22:08:32 <likecolacola> mniip, i heard that often in ##C, that languages don't have speed... i was talking about the speed of software which go through very good implementation 
22:08:39 <nolrai666> Really good C is written by like 200 people in the world.
22:09:05 <likecolacola> in which case and simplifying the question, you are saying that Haskell is faster than C?
22:09:13 <mniip> no?
22:09:31 <rotaerk> it's faster than light
22:09:31 <likecolacola> ok..
22:09:32 <jle`> mniip: you can do asum or msum
22:09:35 <jle`> er, mjrosenb 
22:09:54 <mniip> ohh
22:10:03 <mniip> msum with the First monoid
22:10:10 <jle`> > asum $ map (\x -> if even x then Just x else Nothing) [1..10]
22:10:11 <lambdabot>      Not in scope: ‘asum’
22:10:11 <lambdabot>      Perhaps you meant one of these:
22:10:11 <lambdabot>        ‘F.asum’ (imported from Data.Foldable),
22:10:16 <jle`> > F.asum $ map (\x -> if even x then Just x else Nothing) [1..10]
22:10:18 <lambdabot>  Just 2
22:10:24 <MP2E> It is very difficult to compare language performances. I find that Haskell I write routinely outperforms C that I write, but to state in every case that Haskell beats C would be absurd. Haskell has slow GC for mutable arrays currently(via GHC) so some things like emulators just aren't fast
22:10:25 <mniip> jle`, there's a few issues though
22:10:31 <jle`> oh yeah, there's foldMap too haha
22:10:31 <mniip> everything is in IO
22:10:49 <jle`> well, we just need a different Alternative instance :)
22:10:51 <mniip> and I assume the action need not to be performed if a Just is found
22:11:12 <jle`> we're thinking about `Maybe a`'s <|>
22:11:18 <jle`> but what about `IO (Maybe a)`'s <|>?
22:11:33 <jle`> of course we need a newtype wrapper over IO (Maybe a) that defines such an Alternative instnace
22:11:50 <jle`> but luckily there's one that comes in `transformers`
22:11:57 <mniip> alternatively we could unsafeInterleaveIO
22:11:59 <likecolacola> MP2E, and about difficulty.. is it easier or faster to produce code in Haskell overall?
22:12:10 <jle`> it's MaybeT
22:12:16 <likecolacola> i mean, once you're accustomed to the language obviously
22:12:17 <jle`> so map MaybeT and then asum it
22:12:36 <jle`> :t runMaybeT . msum . map MaybeT
22:12:37 <lambdabot> Not in scope: ‘runMaybeT’
22:12:37 <lambdabot>     Not in scope: data constructor ‘MaybeT’
22:12:37 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
22:13:04 <jle`> :t runMaybeT . msum . map MaybeT
22:13:05 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
22:13:18 <jle`> :t \f -> runMaybeT . msum . map (MaybeT . f)
22:13:19 <lambdabot> Monad m => (a1 -> m (Maybe a)) -> [a1] -> m (Maybe a)
22:13:19 <mniip> likecolacola, depends on how accustomed you are
22:13:31 <kadoban__> likecolacola: Compared to what?
22:13:35 <MP2E> likecolacola: I find both to be about the same, in terms of difficulty to tune. The main way I optimize Haskell is by reducing work being done, or by using more efficient data structures to represent the problem
22:13:45 <jle`> the runMaybeT and the MaybeT are just newtype unwrappers and wrappers, so you can just use `coerce` if you want
22:13:53 <MP2E> either way, being comfortable with lazy evaluation really ehlps
22:13:59 <likecolacola> MP2E, mniip, thanks!
22:14:02 <jle`> but this is just like using Sum/Product/First monoids, etc., with first/sum/etc. monoid newtype wrappers
22:14:34 <likecolacola> kadoban, a comparison between writing Haskell and C
22:15:09 <mniip> likecolacola, there are basically 3 ways to write fast haskell
22:15:17 <mniip> 1) write simple code
22:15:29 <kadoban> likecolacola: haskell is /far/ faster to write a program in, once you know it. C is a low-level language without good abstractions. It's not even a contest.
22:15:47 <mniip> 2) write code that with a specific implementation in mind, such that you know how it will be optimized
22:15:59 <likecolacola> kadoban, are you fluent in C?
22:15:59 <mniip> 3) write low-level code
22:16:30 <kadoban> likecolacola: I'm rusty in it, but I still know it well.
22:17:11 <likecolacola> mniip, nice
22:17:30 <mniip> likecolacola, I wrote a prime sieve with 3rd method as a joke
22:17:32 <mniip> http://lpaste.net/135622
22:20:30 <MP2E> haha nice! :P
22:20:35 <MP2E> this is pretty cool to read
22:20:36 <likecolacola> mniip, thanks a lot for sharing......!
22:34:29 <wei2912> ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
22:34:34 <wei2912> how would i fix this error?
22:35:34 <wei2912> which happens when i run "cabal build" on my library, https://github.com/wei2912/counter
22:36:00 <wei2912> cabal-install is 1.18.0.5, cabal library is 1.18.1.3, ghc is 7.10.1
22:41:02 <verement> wei2912: I think you need to upgrade to cabal-install 1.22, which you may need to do with ghc 7.8
22:41:25 <verement> I'm not sure if there's a simpler solution
22:45:00 <wei2912> verement: thanks
23:21:16 <sailorswift> Is the accepted amount of spaces per tab 4?
23:21:23 <sailorswift> I saw that was the default in Stylish Haskell.
23:22:11 <solrize> so i wanted to count the primes in an interval:    n = length . filter isPrime $ interval  where  interval = 2:[3,5..limit]     and limit is around 10**8
23:22:25 <solrize> trouble is that since interval was a named object(?) it built up the whole list in memory
23:22:43 <solrize> when i wrote it as length . filter isPrime $ 2:[3,5..limit]
23:22:50 <solrize> i.e. without binding it to a name, there was no space leak
23:23:05 <verement> sailorswift: you shouldn't use tabs, so you never have to answer this question
23:23:13 <solrize> is there a reasonable way to bind it and not leak space?  did i do something dumb?
23:23:37 <sailorswift> My apologies for not being more specific, verement.  I am using the tab key to put in spaces
23:23:40 * hackagebot counter 0.1.0.1 - An object frequency counter.  http://hackage.haskell.org/package/counter-0.1.0.1 (wei2912)
23:23:52 <sailorswift> and was curious what the accepted amount of spaces per 'indentation level' was
23:23:59 <sailorswift> I think that is a better way to ask the question
23:24:09 <verement> ah. yes
23:24:10 <pharaun> heh, i usually use 4 but sometime i use 2 (where)
23:25:20 <yayfoxes> how do I tackle this challenge?
23:26:26 <yayfoxes> http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
23:26:40 <yayfoxes> it wants me to learn patterns
23:31:39 <yayfoxes> hell can somebody teach me all this?
23:33:53 <sailorswift> http://www.seas.upenn.edu/~cis194/lectures/01-intro.html read this
23:34:10 <sailorswift> the Defining basic functions section goes over pattenrs
23:34:20 <yayfoxes> hold on
23:35:02 <yayfoxes> tell me if this snippet is correct: double (x:(y:ys)) = x : y*2 : double ys
23:35:51 <yayfoxes> double [] = []
23:35:53 <yayfoxes> double (x:[]) = [x]
23:35:55 <yayfoxes> double (x:(y:ys)) = x : y*2 : double ys
23:36:34 <yayfoxes> Try It and See?
23:36:48 <sailorswift> What do you get when you try it? :)
23:38:27 <yayfoxes> here's a problem: double [1,2,3] -> [1,4,3], double [1,2,3,4] -> [1,4,3,8]
23:39:34 <yayfoxes> I need (x:y:(z:zs)) I think
23:39:40 <yayfoxes> am I going down the right path?
23:40:15 <yayfoxes> lol wait
23:40:16 <wei2912> yayfoxes: why do you need to access three elements of the list at once?
23:40:23 <yayfoxes> wei2912: I shouldn'
23:40:24 <yayfoxes> t
23:40:42 <yayfoxes> but, I wanna double every two digits beginning from the right
23:40:59 <wei2912> that's the problem -- beginning from the right, not the left
23:41:11 <yayfoxes> lol so I do this?
23:41:20 <yayfoxes> double x:y:[]
23:41:28 <wei2912> your code begins from the left
23:41:49 <ttt_fff> is there a nice binding for vim + "cabal repl" ? basially I want to be able to get type signatures of functions from vim without leaving vim
23:41:55 <yayfoxes> this code begins from the right, I think: double [] = []    then    double (x:y:[]) =
23:41:56 <ttt_fff> I'd also like ot have my "cabal repl" as a vim "buffer"
23:42:11 <wei2912> yayfoxes: it doesn't, actually
23:42:22 <yayfoxes> whoa!
23:42:34 <wei2912> yayfoxes: note that when you do pattern matching it's always seperating the head and tail, and the head is on the left
23:42:41 <wei2912> is the leftmost element*
23:43:01 <yayfoxes> lol so what do I do?
23:43:07 <yayfoxes> can you make me figure it out?
23:43:21 <wei2912> yayfoxes: easiest way is to just reverse the list :P
23:43:29 <ttt_fff> is there a shorter way to write "(\x -> fst $ execRWS (ll_advance d) () x)"
23:43:46 <yayfoxes> wei2912: I thought I'd reverse the list but it's stupid
23:43:53 <yayfoxes> any other way?
23:44:23 <yayfoxes> is double []:xs valid code?
23:44:32 <Welkin> no
23:44:37 <Welkin> you cannot cons a list onto a list
23:44:43 <Welkin> :t (:)
23:44:44 <lambdabot> a -> [a] -> [a]
23:44:46 <ttt_fff> what?
23:44:55 <ttt_fff> [] : [Nil]
23:44:58 <ttt_fff> >t [] : [[1]]
23:45:02 <ttt_fff> > [] : [[1]]
23:45:04 <lambdabot>  [[],[1]]
23:45:09 <ttt_fff> ha, I just cons a list onto a list
23:45:09 <yayfoxes> then erm...what's the non obvious way to solve this issue besides reversing a list?
23:45:11 <wei2912> yayfoxes: that works, but you're not handling a list of a list
23:45:13 <Welkin> ttt_fff: no
23:45:26 <wei2912> yayfoxes: whoops, ttt_fff wrote that :P
23:45:33 <Welkin> > [] : [5]
23:45:34 <lambdabot>      No instance for (Show t0)
23:45:34 <lambdabot>        arising from a use of ‘show_M248581259622292949522521’
23:45:34 <lambdabot>      The type variable ‘t0’ is ambiguous
23:45:43 <yayfoxes> > [] : 1
23:45:45 <lambdabot>      No instance for (Show t0)
23:45:45 <lambdabot>        arising from a use of ‘show_M116527588635650984622533’
23:45:45 <lambdabot>      The type variable ‘t0’ is ambiguous
23:45:56 <Welkin> the type says it all
23:46:00 <wei2912> yayfoxes: well, the other approach is to find the length, then go through the list starting from the left. with the length you can figure out how to go about doubling the elements
23:46:33 <wei2912> for example, if the length is odd (like [1, 2, 3]), then you should skip the first element and then double every second element, to get [1, 4, 3]
23:47:02 <yayfoxes> wei2912: this is way over my head
23:47:11 <wei2912> s/second element/two elements/
23:47:12 <Welkin> what's wrong with map?
23:47:16 <yayfoxes> and my eyes are about to explode
23:47:22 <yayfoxes> map (+1) list
23:47:34 <yayfoxes> > map (+1) [1,2,3]
23:47:36 <lambdabot>  [2,3,4]
23:48:04 <wei2912> yayfoxes: yeh, that's the problem. just get a working solution out first then we can discuss further
23:48:13 <wei2912> yayfoxes: it's hard to explain this without going deep
23:49:31 <yayfoxes> let's think more about the solution involving reversing the list?
23:50:09 <wei2912> yayfoxes: get a solution by reversing the list, then discuss how to improve it
23:50:15 <yayfoxes> ok
23:55:16 <yayfoxes> wei2912: how do I erm...reverse a list without using any built in functions?
23:55:48 <yayfoxes> I mean intelligently
23:56:38 <yayfoxes> I have (y:[]) , (x:y:[]) = y : x : [] , and what else do I need?
23:56:53 <yayfoxes> (y:[]) = [y] is what it says
23:57:38 <wei2912> yayfoxes: you just need to consider the head and tail of a list. you don't appear to be familiar with recursion... so let me see if i can help you out there
23:58:19 <wei2912> let's say we have a list, `1 : xs`. we don't care about what's inside `xs`, other than the fact that it is of type [Int].
