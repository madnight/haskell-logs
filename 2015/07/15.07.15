00:53:03 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
00:53:03 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
00:53:03 --- names: list (clog doodleha_ adeln thetallguy zipper Soft sinkensabe doodlehaus wraithm shesek grrz tamasgal Palmik Iskarlar tabemann erikd edsko cj3kim ohpesky raichoo msgodf hamid_ bennofs optocoupler nomeata dramforever AlexStraunoff nopf asjo nilg mattyw dschoepe albertid pacak wordsarewind thomas gensym2 xificurC edwinvdgraaf seppho jomg inhortte petermw marcus-aurelius srenatus howdoi hackagebot freeman42-sp vin-ivar frerich nikki93 ttof fridim_ jimstutt wuch l3dx)
00:53:03 --- names: list (montagy free_beard nyazdani enaqx milli kamatsu marr calvinx MarcelineVQ slack1256 eatman xinming aswins ast054 danvet zcourts xpika odi pt1 cyborgIone CurryWurst coeus grizwako Swizec wvdhaute_ ybian gentleben arckai circ-user-YmKkx porvak quchen2 ThomasLocke doomlord MultiPur_ ixti blackh vlatkoB L8D bramgg ens_ lritter KarolisK kp666 ryantrinkle yfeldblum icosa mjo-work fishburne1 dibblego martinium xacktm sobaken jamiis davesilva mitchty tromp__)
00:53:03 --- names: list (fuzzyhor_ Deadhandd dmh nshepperd andrevm ahungry gomi_ningen lamefun geekosaur boot13 ThatOtherPerson cyphase zettablade fintler gfixler MrWoohoo jle` wizzo CMCDragonkai darkf maraoz khanage FreeFull otto_s_ thimoteus jordanl beauby dgorbik- dgorbik carc teclo- stoopkid mountaingoat Pastaf dimday vmeson jedws dsantiago netj echo-area citizen11 ValicekB mimi_vx Ralith FreeBirdLjj Stratege_ verement robogoat pavonia loor seangrove odyReichertC Fr4n)
00:53:03 --- names: list (Coldblackice otterdam mteufel integral plutoniix Nik05 dreixel thunderrd louispan aidanh Artpicre cic blz37 AntiSpamMeta cognominal lahwran gdoteof greymalkin jameseb Guest20390 roconnor_ flux CLaxware falafel predator117 nrk- Jesin exferenceBot lspitzner hexagoxel divinegod r4yan2 ixian joeyadams dropdrive tomboy64 voidzero maw ricardo82 solarus ahihi timbod7 curios PatrickRobotham nullvoid8 chrisdotcode Entroacceptor saulzar atomi Pamelloes cow_2001 lkba_)
00:53:03 --- names: list (ruukasu tumdedum alexa_ junmin zinfandel thomassgn phaskell Fuuzetsu bb010g araujo qnikst dan_b mrmyers sephiap Xorlev ggherdov emmanueloga folsen fuziontech joco42 mindos_cloud____ seanparsons lohkey glowcoil AlainODea rslima lexi-lambda shennyg Heero skulls dh ayberk Sorella myfreeweb aloiscochard moy samertm cojy srid avdi zpconn__________ spdionis RGamma dario` qz gbarboza edwardk davean martinhath jroesch keko_ bz malllle bananagram lieven rike cdidd_)
00:53:03 --- names: list (sbrg jokester theorbtwo zymurgy nuncanada albel727 brennie Mon_Ouie davidfetter lodin_ whaletechno ceii benjamingr raid SuperTux88 SegFaultAX peddie emik paf31_away xxpor lpaste_ sunfun jlang0 paperManu_ mjrosenb_ mirsal derekv2 ljhms Diabolik condy pdxleif lamilami ij dpn` drone- KorriX_ dwoos LaGrenouille_ julienXX ThePhoeron _ikke_ lyxia_ froztbyte absence_ flori_ flaivv Guest97548 zerokarmaleft jaspervd1 maurer larsen__ Adios_ Tehnix_ AshyIsMe eyck_)
00:53:03 --- names: list (heath_ tismith_ `0660_ runde_ module001 hodapp wagle marko__ ess_sing dgvncsz0` CodyReichert _slade_ amiri_ guampa HylianSavior skeet70 ubuntor julm Denommus Violetta_ themagician emanuelz chishiki Khisanth renekooi creichert benzrf japesinator xahry sw1nn _sjs agjacome EvanR staffehn avn MitchW rootnode _ashbreeze_ miscyb solrize jasu0 davidstone haBuu^ shelf yac segf Nux_ johtso isocliff ronh joco Sigyn whiteline nkartashov jang oish dmiles_afk bernalex)
00:53:03 --- names: list (mauke moonlily utdemir SoupE xelxebar sp0on jtobin tilpner chirpsalot Chobbes psy_ fengshaun PotatoGim andyo CoconutCrab platz quaestor1 Thra11 pygospa hiratara kawaii-imouto hbar m4lvin _flow_ hpd brezel sLite besenwesen maerwald Tourist Xack supki saurik rfw MasseR Eiam brotknust_ aupiff_ yusukesuzuki s00pcan Yaiyan nille Iceland_jack Regulator9 ortmage josephle tgeeky andrewalker jaffachief so erhandsome Orwell84 niko nkpart dkua bcavalier anttih tinchos)
00:53:03 --- names: list (yminsky bgyss idnar mankyKitty Internet13 carter_cloud zph sweenzor puzza007 MMuse_______ Bane^ si14 arnihermann bigs etrepum mno2 XMunkki tarcwynne jfokkan nitrix gpampara FireFly ivan\ kini neanias Vq dju Tristan-Speccy aaron7 deavid tswett stvc sku1d somenick tych0 Cathy kipras noexcept Athas dabradley Belgarion0 karls schlumpi sdx23 hanDerPeder iDavid xaimus horlicks_ obiwahn SaidinWoT tuv burp corso gseitz LonelyCloud unknownloner Factionwars nathanic)
00:53:03 --- names: list (uwap Th0mas_ natte MindlessDrone rossimo xandaros epta ajf bartavelle leino porglezomp capisce akuhlens vikraman sebastard rseymour dicioccio1 Dtgr jackhill Spockz hator derekbrown Draconx ephess adimit karshan BlakeRain buttproblem joeytwiddle senseibaka sternenseemann tero- Jaak mads- ernst Atlanis Drezil_ cynick eamelink kaol luite andreass_ solirc Ankhers ByronJohnson cjay jmct mami stomp wrengr_away soija sbauer322 apo_ cpa Mandus Biohazard stass)
00:53:03 --- names: list (swistak35 ggreg friden sajith bitemyapp koala_man zso jrslepak eagleflo kriwil fall` Clint Hafydd obcode lvh tlevine d-snp eyem kragniz AustinMatherne mrd tedkornish abh zq SwashBuckla orzo mephx Johannes13_ skyres saml dxld ctag MarkusBarthlen Kharn mach troydm noteness obadz Xnuk huonw nesqi Or1 tromp_ frodwith eevar_ PlasmaStar zaquest jakutis joncol paul01_ Razz iyzsong elben taruti prinsen kakos thalleralexander Zekka loz-- DustyDin1o trolling whoops)
00:53:03 --- names: list (dmwit Geir xeno_ telser zariuq lf94 vili elementalest fyolnish spion steinar_ Igloo edwtjo phadej endojelly felixn liste dixie TDJACR asm89 joehh elgot cryon int-e pgorla geal hiberno ousado RevJohnnyHealey C4Cypher rdema nicola CindyLinz bgamari- bgamari mceier yrdz fr33domlover noplamodo hattusili_III joehillen tomphreek tomasos torpig Lutin` infinity0 saep tessier Voldenet Tesseraction banjiewen fling padre_angolano fractalcat inr catsup felixsch sh1ken)
00:53:03 --- names: list (ipuustin nyuszika7h michaf nurupo rofer DrAwesomeClaws z16 mgomezch kyren serutsubi Liskni_si Guest39551 ]OLI[ Nickeeh Jaxan shadowdaemon zxtx_ irclogger_com cschneid cnf jorj pii4 otulp s_e Dodek haroldwu lokulin mathu Willis Noinia dhrosa znutar cbaines statusbot dustinm Enigmagic rowanblush peterhil` rcsgns Lemmih melter andjjj23 jlewis magbo lokydor heyj ParahSailin relrod farn Chousuke flxx dzack hongminhee dolio bjorkintosh hpc technomad RageD pm5)
00:53:03 --- names: list (klarrt keemyb hx jvd _rgn lambdabot ubitux przembot bob_twinkles Plastefuchs djanatyn jacksnipe hausdorff deni ma82 xiphos tomasos__ Eldrad keaml lstrano ajp tsou nuttycom kongo2002 Qfwfq permagreen greenskeleton ryankarason gmaslov hsyl20 chattered petercommand reqq456 schoppenhauer adamse Xe lyonsb rossberg uber mpw defanor spacebug __main__ sivoais bsmt taksuyu killtheliterate alanz lachenmayer alem0lars brisbin crixer conehead dalmahal blue_feint)
00:53:03 --- names: list (Zanzare Myrl-oneechan arkeet mmaruseacph2 Lakkthereof milesc22 lala Encapsulation Natch StoneToad dfranke ps-auxw Proteumus keix certainty cchalmers reynir ilmig ghorn sunnavy low-profile TRManderson lyddonb gsingh93 frawgie_ tsani adnap augur ninegrid zacts notdan canta drbean srcerer jmcarthur CARAM__ ehamberg alexlord jo__ sclv arcanine alekst_ joedevivo atn34 WelpAnon earthy Wamanuz yeltzooo orion cpup cmn dp_wiz fugyk niklasb ClaudiusMaximus fikusz)
00:53:03 --- names: list (Boney gratimax erethon valdyn agjohnst klugez sinopeus_ pranz Axman6 cbm80 Ulrar mattp Guest72507 dgonyeo gcollins ChongLi subleq royadav Jellydog darthdeus Kruppe martingale luzie joneshf-laptop kess thorkilnaur monochrom Draggor jbhatta PigDude rom1504 kaste pleiosaur seagreen abra0 moop gothos gargawel boris`` noddy zimbatm eazar001 tv kgadek kaictl JZTech101 sea-gull sohum Reiser cursork jnoah rj-code oberstein Haskellfant ElderFain drdo mietek Elsi gws)
00:53:03 --- names: list (blenny bsummer4 cstrahan steshaw ocharles_ lusory marens n1ftyn8_ bkolera hellschreiber kjnilsson Erebe cheater tusj mniip cods David dan64 bolmar mrowe_away M-ou-se hive-mind Philonous perrier Zemyla majoh happy0 nakal_ chris2 gnusosa bjobjo jkarni1 benonsoftware Phlogistique viitap aupiff Taneb samgd ttuegel osfameron barrucadu juri_ irishsultan chaptastic meretrix shachaf usr stelleg Starfire kidnapped_robot dino- jaseemabid_ petantik Jello_Raptor)
00:53:03 --- names: list (tomjaguarpaw iross roo alang Intensity MoALTz codehero Polarina phuu Blkt_ Sonderblade bonobo_ slasktask frontendloader mendez EnergyCoffee rphillips yorick tekacs tzaeru reem AWhetter Tazca RazorX andreypopp_ Guest34843 nbouscal shapr max-m knyppeldynan doctorin1 fionnan neki levi ring0` lattenwa1 boxfire srhb hvr eL_Bart0 xplat rbocquet zhulikas_ ScRaMbLe tomku mokus tazjin joeyh notOnIRC dunj3 fmapE kvieta sagelywizard stbuehler fnordbert hc cow-orker)
00:53:03 --- names: list (kjanosz abrar LordDeath unsymbol harski Freundlich tristero freusque dqd betawaffle brotknust andrewsw ReinH hiredman mikeizbicki wjm [swift] Cale themasterchef Sgeo_ lancetw ckw Paprikachu LnL rul psacrifice Boreeas dstockwell dlackty___ timloh jlyndon jonrh runeks Tritlo GGMethos flebron gbiv chuy ezrios lsep kqr kalz NemesisD ChristianS kav fergusnoble helgar kvalle da-x haasn benwf pharaun cin_ spindas ircbrowse Twey nekomune mak` DANtheBEASTman)
00:53:03 --- names: list (zz_rabisg shwouchk anachron kirjs________ aatxe fall__ alevy- OliPicard jonathanj_ trig-ger zero7 abbe xnyhps ec\_ Jonno_FTW liff phaazon dlundy_ scopedTV_ Saizan Maxdamantus zyoung pfoetche1 Baughn_ zomg jlind_ joshc JPohlmann lassulus _klm simon lokodo Schrostfutz_ nrw lacrosse yrashk S11001001 sabauma aaronm04 jbalint gridaphobe Nimatek ollef Dan39 spaceships buoto MK_FG shirt RayNbow`TU zeiris owa avocado thomie Jorgon SparkySparkyBoom lpsmith hemite)
00:53:03 --- names: list (narendraj9 spwhitt Ptival constantinexvi ft stiell darkowlzz|afk mpereira quicksilver mlen codahale kwantam h4nnibal robbert tdammers tnks jrib aweinstock opqdonut ashleyis Rutger` Pennth Ornedan chandankumar mgaare pfeyz shiona sevcsik Vbitz newsham u-ou amiller benbangert djh sujeet demolithion nathan7 lykkin naudiz kloeri nwf recycle`` Desoxy MelodyKH3 DanZimm mrsolow bitonic _fritz_ Laney drmegahertz wto jb55 TimWolla nmenne CosmicRay arch_ Brando753 tg)
00:53:03 --- names: list (k1i nemesit|znc fryguybob Hijiri sm SLi averell henryhere WSergio funrep Cr8 itsmonktastic ski pieter zyla marienz kaw_ tridactyla pharpend scpike s1n4 noteventime ido pyrtsa kriztw akahn Forkk therealklanni killerpty honza mudphone rhaps0dy PinealGlandOptic Bigcheese acfoltzer rudi_s drewdavis hegge pingu seliopou electrogeek cameronfr ephemeron cross grol mpickering Hugglesworth Sagi alpounet fold bbee sokoll bydo s4msung liyang mitu BrianHV _di)
00:53:03 --- names: list (Guest70208 Klumben Tiktalik skarn_ biscarch wolf_mozart cjwelborn sdboyer Pucilowski_ Gothmog_ Walther c9sould__ callumacrae osnr sunnymilk rs0 dcoutts gdsx_ adarqui jix_ krgn brackets wizonesolutions Cerise mbrcknl stasku jrp6 prosodyContext Raynos pchiusano mystor sleepynate milessabin wenzowski seancorfield doppioslash Dykam_ gabiruh_ Phillemann peterood kmicu zrl caasihuang chriswk hoey_ mikedanese thoughtpolice mechairo` ziman cjh` JonasH__ JamesJRH)
00:53:03 --- names: list (surtn alphonse23_ yukonjack radens chelfi mrb_bk ackthet KaneTW seabre kanak Kneiva saiam brolin_empey R0b0t1 eyenx wayne ice799 bshelden bergmark statusfailed Guest83834 brent80_plow kloplop321 tolt Guest75051 koomi numberten c-rog mikeplus32 RlyDontKnow Ezku_ amontez_ pmade cscorley Profpatsch wtw brixen ion Deewiant hrnz yarou Guest90609 igniting mero vpm Watcher7_ malglim ThreeOfEight sys9mm_ grohne TallerGhostWalt BillyIII_ Tene edran zeroskillor)
00:53:03 --- names: list (shelling__ _6a68 otherchas_ noctux IbnFirnas Uritomi2 annulus sellout carter sys eikke lispy DigitalKiwi comboy vodkaInferno dredozubov LeaChim_ diginet bjornars Sornaensis lambdahands Fubar^ zenzike Adeon thorsten` monty nisstyre xxx eivuokko erg monsieurp tomaw posco aristid thebnq orbekk agrif SHODAN Eagle_Erwin tumdum e4x_ PHO iteratee oherrala jlouis j0llyr0tten bcoppens dreamdust hyPiRion alynn machineslearn ahf d3lxa jpiche kosmikus etabot mortberg)
00:53:03 --- names: list (dmilith OutlawStar magicman dilinger mrshoe DenSchub greeny davl_ kandinski KitC Fylwind linduxed dexterph ibid ndeine michaelpj_ myme arianvp Eliel jstolarek Reyu oconnore lenstr @ChanServ Ke Rembane cYmen_ niluje jayne sgronblo exio4 vladan arw)
00:57:52 <Hijiri> freeman42-sp: isn't slack proprietary? (I already sent this message but I think it got lost)
01:00:26 <freeman42-sp> Hijiri, I don't know and honestly don't care that much about that aspect since I'm not an evil villain (yet) 
01:00:47 <Hijiri> I guess the FSF must be full of evil villains
01:01:04 <wordsarewind> It's their headcourters
01:02:05 <klugez> In what sense would it be propietary?
01:02:41 <wordsarewind> in the sense that all that is presented is binary, compiled code
01:02:48 <wordsarewind> with no access permitted to the source
01:03:35 <wordsarewind> looks like they have an open API, though...
01:06:24 <klugez> wordsarewind: Ah, sorry. I misread slack as stack and was confused. :P
01:09:48 <aupiff_> i have a cbits/ directory whose code is rebuilt on every `cabal test` although nothing has changed. how do I avoid this?
01:12:36 * hackagebot shortcut-links 0.1.0.0 - Link shortcuts for use in text markup  http://hackage.haskell.org/package/shortcut-links-0.1.0.0 (Artyom)
01:25:30 <jTT_> hi, i am trying to use xml-conduit to achieve this: go down the cursor to a certain tag of an html document. treat any children of this node as text. i.e. dont only get the content of the children as text, but also the tags of children themselves. so for example, <p> this is <i>good</i> </p> should return ‚Äúthis is <i>good</i>‚Äù. I keep having trouble that seem related to encoding, for i get ‚Äúthis is \9080i\90708good\9080/i\9070‚Äù   (the numbers 
01:25:30 <jTT_> are not the actual ones im getting). I struggle to find out where this incorrect encoding/decoding is taking place. can anyone help?
01:31:01 <tempvar> Will ghc always respect a correct OPTIONS_GHC pragma or could it possibly ignore it? I am submitting code to an online judge and my code doesn't run fast enough there but seems to be within the time limits locally, on the expected size of input, when I compile with -O2.
01:32:00 <dramforever> tempvar: 1. it's possible that the online judge removes those pragmas
01:32:09 <dramforever> 2. maybe the oj is slow....
01:32:38 <dramforever> tempvar: does the oj ignore incorrect OPTIONS_GHC pragmas?
01:32:52 <tempvar> I will test. Good idea.
01:36:46 <bennofs> tempvar: some flags are static and cannot be set from an OPTIONS_GHC pragma. -O2 could be such a flag
01:37:16 <bennofs> tempvar: also, maybe the online judge is using a different version of GHC?
01:37:27 <tempvar> Ok, the oj compiles with incorrect pragmas. But when compiling locally, ghc just warns about incorrect pragma but does compile.
01:37:59 <dramforever> tempvar: is it a public oj?
01:38:01 <arkeet> -O is a dynamic flag.
01:38:14 <bennofs> arkeet: yeah, just looked it up and came to the same conclusion .)
01:38:14 <ghost_runner> Which book is more preferable to a beginner: K&R or SICP?
01:38:25 <arkeet> idea: also add -Werror.
01:38:30 <tempvar> Yes, it is public https://open.kattis.com/
01:38:46 <arkeet> ghost_runner: a beginner of what?
01:40:24 <ghost_runner> arkeet: Learning how to really program. Both seem to be the most recommended, Python/web-based stuff aside.
01:40:39 <bennofs> tempvar: according to https://kth.kattis.com/help/techinfo, it uses  -O2 -ferror-spans -threaded -rtsopts
01:40:45 <bennofs> tempvar: with GHC 7.6.3
01:41:26 <tempvar> ok thanks, bennofs.
01:42:26 <tempvar> Back to profiling then :)
01:44:57 <arkeet> or coming up with a faster algorithm :-)
01:45:15 <dramforever> tempvar: yes that's the best way
01:45:40 <dramforever> usually if your program is not very long then the answer you'll get by profiling is: \
01:46:04 <dramforever> "Oh my function computing the answer is too slow"
01:47:45 <tempvar> It is the closest pairs problem where I have implemented the Shamos algo in newbie haskell :)
01:48:04 <tempvar> But the profiling with ghc is so nice.
01:48:40 <eds> I get this error when I am making my 'data Expr' and instance of Data (line 44). I have pasted the error and code on : http://lpaste.net/136444. Can anyone help me out?
01:48:55 <eds> an instance of Data*
01:49:26 <Hijiri> maybe you need a Data constraint on a
01:50:11 <dramforever> Hijiri: no, just typeable
01:50:40 <dramforever> IIR&UC it's called a nominal phantom type
01:50:49 <Hijiri> I just noticed there's no actually occurences of a
01:50:52 <Hijiri> in the type
01:51:52 <dramforever> eds: wait are you making a genetic programming expression generator?
01:51:59 <dramforever> wow
01:52:51 <eds> dramforever: yeah ':)
01:53:28 <eds> so I need a typeable constraint on a?
01:53:34 <dramforever> yes
01:54:11 <dramforever> wait doesn't new ghc derive typeable automatically?
01:54:46 <dramforever> @let data X = X
01:54:47 <lambdabot>  Defined.
01:54:50 <dramforever> > typeOf X
01:54:51 <lambdabot>  X
01:54:55 <dramforever> horray!
01:55:23 <arkeet> dramforever: yes, but that doesn't remove the need for the constraint.
01:55:54 <dramforever> arkeet: well it might remove the need for deriving instance Typeable a => Typeable (Expr a)
01:56:03 <arkeet> true.
01:56:32 <dramforever> I was stupid, I mixed up Data and Typeable
01:57:30 <eds> So, typeable constraint on a still does not solve it. 
01:59:11 <eds> Data constraint on a does not work either.
02:00:22 <eds> dramforever hijiri
02:00:36 <dramforever> dunno =(
02:03:30 <eds> dramforever np thanks :)
02:03:37 <dramforever> yw =)
02:10:09 <aupiff_> does anyone have experience with managing the re-compilation by cabal of files in a cbits directory? 
02:11:02 <aupiff_> I am working with a library with a really big templated .cpp file that takes forever to recompile, and it recompiles with every cabal command...
02:21:27 <comerijn> Quick question: What's the difference between a magma and a semigroup?
02:22:15 <quchen2> A magma doesn't need to be associative iirc
02:22:16 <Freundlich> comerijn: A semigroup requires its operation to be associative.
02:22:51 <comerijn> That's what I guessed
02:38:59 <anohigisavay> hi, i'm quite new to haskell. how can i apply pattern matching to a single extracted value in a list comprehension?
02:39:16 <dramforever> yes, like this:
02:39:33 <dramforever> > [x | Just x <- [Just 1, Just 2, Nothing, Just 3]]
02:39:34 <lambdabot>  [1,2,3]
02:41:07 <anohigisavay> dramforever: um... is it possible to match against a single value?
02:41:26 <dramforever> anohigisavay: I didn't understand that question, maybe give an example?
02:41:42 <anohigisavay> [x | x <- [Just 1, Just 2, Nothing, Just 3], {- any change to pattern match this x? -}]
02:41:51 <anohigisavay> *any chance
02:42:23 <dramforever> so what's the proble of the code I gave?
02:42:48 <dramforever> *problem
02:43:01 <anohigisavay> i want to apply a function to each value extracted from the list and then map against them
02:43:06 <anohigisavay> pfff
02:43:11 <catsup> how can i silence specific unused variable warnings?
02:43:12 <anohigisavay> i want to apply a function to each value extracted from the list and then match against them
02:43:23 <anohigisavay> i know i can use map
02:44:08 <anohigisavay> but i wonder if it's possible to get rid of it
02:44:10 <dramforever> catsup: can you replace the variables with _ or remove them?
02:44:30 <catsup> dramforever: no, i have definitions generated by TH
02:44:36 <dramforever> =(
02:45:17 <dramforever> anohigisavay: oh did you know you could use let in list comp?
02:45:34 <dramforever> wait no
02:45:45 <dramforever> anohigisavay: how about this: use as-patterns
02:46:06 <dramforever> [(x, y) | y@(Just x) <- [Just 2, Just 1, Nothing, Just 3]]
02:46:11 <dramforever> > [(x, y) | y@(Just x) <- [Just 2, Just 1, Nothing, Just 3]]
02:46:12 <lambdabot>  [(2,Just 2),(1,Just 1),(3,Just 3)]
02:46:31 <dramforever> anohigisavay: ^
02:47:42 <anohigisavay> dramforever: cool! i think that's what i need
02:47:50 <anohigisavay> dramforever: thanks :D
02:47:53 <dramforever> =)
02:49:14 <comerijn> You can do it even simpler
02:49:22 <comerijn> Well, simpler for non Maybe matches
02:49:44 <dramforever> comerijn: well it's a general question isn't it
02:49:48 <comerijn> > [x | x@Just{} <- [Just 2, Just 1, Nothing, Just 3]]
02:49:49 <lambdabot>  [Just 2,Just 1,Just 3]
02:49:54 <Gurkenglas> Is there a way to define (:..:) Maybe = MaybeT, (:..:) (Reader r) = ReaderT r, etc.?
02:50:23 <comerijn> As in, that works for constructors that have more than one argument (if you didn't care about the arguments and don't want to list them)
02:50:24 <dramforever> Gurkenglas: 1. type families?
02:50:28 <comerijn> Gurkenglas: Type families?
02:50:29 <dramforever> 2. what are you doing?
02:50:47 <dramforever> comerijn: 3. are you merjin or someone else?
02:51:01 <dramforever> *merijn
02:51:27 <comerijn> dramforever: Yes, it's my "I got DCed and my nick is taken" name :p
02:51:36 <Gurkenglas> dramforever, I have the feeling writing "ReaderT (MaybeT IO) a" as "(Reader :..: Maybe :..: IO) a" would look better, and appending T introduces unnessecary names
02:51:59 <comerijn> dramforever: Incidentally, freenode will tell you this for registered nicknames on freenode (i.e., it lists "account: merijn" :p)
02:52:17 <dramforever> Gurkenglas: why are you listing them more than once in your code?
02:52:53 <dramforever> you should always use a newtype (for exported monads/cleaner code) or a type synonym for monad transformer stacks
02:53:53 <Gurkenglas> Even if it's only used once. But as I haven't been using those much yet, I'm not sure the stacks shouldn't be different in different functions
02:54:28 <dramforever> Gurkenglas: you can't put the functions together if they don't have the same stack
02:54:36 <Gurkenglas> It's just that I see "MaybeT, ReaderT, ListT, WriterT" and think "That should be abstracted away"
02:54:47 <dramforever> abstract away the T?
02:54:49 <dramforever> oh man...
02:55:34 <catsup> the T ought to distribute
02:55:59 <Gurkenglas> dramforever, match cases to make the stack smaller, use lift to make it bigger, so you can use different stacks
02:56:00 <catsup> (Maybe+Reader+List+Writer)T
02:56:20 <Gurkenglas> catsup, that + is not commutative
02:56:26 <bennofs> Gurkenglas: normally, if you use mtl, you write all functions like: MonadReader r m => m something
02:56:28 <catsup> it's a joke
02:56:54 <Gurkenglas> Typeclasses for each of them too? Abstract away!
02:57:12 <bennofs> Gurkenglas: then, you define newtype AppMonad a = AppMonad (ReaderT r (WriterT w ....))) deriving (Functor, Applicative, Monad, MonadReader r, MonadWriter w, ....) 
02:57:51 <dramforever> bennofs: except the stacks are not the same for different functions
02:57:58 <dramforever> but the contraint one works
02:58:28 <bennofs> dramforever: yeah, that's why you only use constraints. You add constraints for everything you need (so you still only need the minimal features), but then run them all in the same stack that needs to implement all possible constraints
02:59:14 <dramforever> bennofs: except that I never used different stacks in the same module
02:59:23 <Gurkenglas> (And that line should look like "newtype AppMonad a = AppMonad ((Reader r :..: Writer w :..: Ö ) a)")
03:00:39 <bennofs> Gurkenglas: wouldn't it work if you just defined type (:$:) a b = a b (using -XTypeFamilies) 
03:00:59 <bennofs> Gurkenglas: and then write newtype AppMonad a = AppMonad (ReaderT r :$: MaybeT :$: WriterT w :$: a)
03:01:19 <bennofs> at least that avoids all the parentheses
03:01:22 <catsup> but that doesn't remove the T
03:02:04 <Gurkenglas> Was gonna say something like "Oh shiny, but the names still overflow", but you guys said everything :P
03:02:27 <catsup> i'm still joking
03:02:37 <jle`> it'd be tricky becasue MaybeT, ReaderT, ListT, WriterT all have different kinds
03:02:41 * hackagebot hwsl2 0.3.1.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.3.1.0 (srijs)
03:02:56 <jle`> so they aren't really all the same thing according to the type system
03:03:09 <bennofs> jle`: we need kind families!
03:03:14 <Gurkenglas> jle', MaybeT, ReaderT r, ListT and WriterT w don't, and that's what I want to be usable with (:.:)
03:03:26 <Gurkenglas> *(:..:)
03:03:55 <jle`> i guess you can type family it, but it might be a bit messy and of limited use,  heh
03:04:10 <bennofs> Gurkenglas: type family Upgrade a :: * -> *; type instance Upgrade Maybe = MaybeT; type instance Upgrade (Writer w) = WriterT w; ....
03:04:11 <jle`> you can abstract over MaybeT and EitherT though with a single TraversableT
03:05:08 <Gurkenglas> bennofs, yay! Can we substitute the data definitions of MaybeT, WriterT etc. and get rid of the names altogether?
03:05:26 <bennofs> Gurkenglas: no, type families are name-based
03:05:30 <dramforever> Gurkenglas: I have an idea:
03:05:39 <dramforever> what about renaming them to remove all the T
03:05:48 <bennofs> haha
03:05:54 <dramforever> and append something like M to those non-transformer versions?
03:06:10 <bennofs> module Better where type Maybe = MaybeT; type Writer = WriterT; .... 
03:06:33 <Gurkenglas> The problem is the names per introduced monad. Reader should add "Reader" to the dictionary, not "Reader", "ReaderT" and "MonadReader"
03:06:52 <jle`> MonadReader isn't inherently tied to Reader, though
03:07:03 <jle`> it's actually somewhat unrelated to Reader and ReaderT
03:07:09 <jle`> they can exist independently of the other
03:07:11 <bennofs> yeah. (->) r is an instance of MonadReader to
03:07:14 <Gurkenglas> Isn't? It's what I thought the discussion earlier said, soz
03:07:19 <bennofs> > ask $ 3
03:07:21 <lambdabot>  3
03:07:21 <jle`> MonadReader doesn't really have much to do with Reader at all
03:07:28 <bennofs> :t ask
03:07:29 <lambdabot> MonadReader r m => m r
03:07:41 * hackagebot frpnow 0.12 - Principled practical FRP  http://hackage.haskell.org/package/frpnow-0.12 (AtzeVanDerPloeg)
03:07:52 <jle`> so introducing Reader and ReaderT doesn't really introduce Reader
03:07:55 <jle`> er MonadReader
03:08:05 <jle`> any more than introducing Maybe introduces Monad
03:08:07 <bennofs> Reader/ReaderT are from transformers
03:08:11 <bennofs> @hackage transformers
03:08:12 <lambdabot> http://hackage.haskell.org/package/transformers
03:08:16 <bennofs> and MonadReader is from mtl
03:08:18 <bennofs> @hackage mtl
03:08:18 <lambdabot> http://hackage.haskell.org/package/mtl
03:08:19 <jle`> we could rename MonadReader to something elss confusing
03:08:27 <jle`> HasEnvironment
03:08:42 <jle`> then people would stop thinking it has anything to do with Reader and ReaderT, heh
03:09:02 <Gurkenglas> "transformers" and "monad transformer library"? What's the difference?
03:09:11 <jle`> transformers defines monad transformers
03:09:32 <jle`> mtl gives a typeclasses for abstracting over monads with different sorts of effects
03:09:39 <jle`> mtl is not a monad transformer library, incidentally
03:09:45 <jle`> so the naming decision was a bit unfortunate
03:09:49 <Gurkenglas> nevermind then ^^
03:10:08 <jle`> so mtl gives a typeclass for, say, all monads that have read-only environments
03:10:26 <jle`> so things like (->) r, ReaderT, etc.
03:10:48 <quchen2> Why isn't State a MonadReader?
03:10:49 <Phillemann> Might be a stupid question, but: there is old-locale. Is there a new-locale somewhere? Am I supposed to not use old-locale anymore?
03:11:03 <jle`> quchen2: i think the reason is so that you can use ask for StateT s (Reader r)
03:11:15 <dramforever> Phillemann: yes, you should use locale not old-locale
03:11:33 <jle`> i think it might also violate the semantics of reader maybe in some way but i'm not sure
03:11:41 <Phillemann> dramforever: The thing is, time depends on it.
03:11:49 <quchen2> Hm. Maybe because ask=get for that instance.
03:12:05 <jle`> but for practical reasons it's nice to be able to use ask and get for StateT s (Reader r)
03:12:09 <jle`> for two different things
03:12:48 <jle`> it'd sort of violate the implied contract that `ask` will give the same thing throughout a sequence of actions though, i think
03:13:02 <quchen2> Is that a law?
03:13:15 <jle`> mtl doesn't really give any laws, heh
03:13:15 <quchen2> Isn't it only implied by the fact that it's closely tied to Reader? :>
03:13:24 <aupiff_> I can run quickcheck tests on a property like `i == decode (encode i)` for a custom `Data.Binary` instance I wrote, but when I read to /from file I am missing the first 64 bits of the saved binary file and everything is decoded incorrectly...
03:13:40 <aupiff_> has anyone seen that before?
03:13:53 <jle`> i guess it's not a codified implication
03:14:06 * jle` throws up papers into the air
03:14:08 <quchen2> aupiff_: Serializing a Bytestring adds its length as a prefix, I think
03:14:20 <quchen2> So when you deserialize raw data you don't have that prefix
03:14:33 <quchen2> ‚Ä¶ but I'm not entirely sure about this.
03:15:07 <jle`> all of the MonadReader instances i've ever written i've tried to uphold this but maybe it's just me this whole time ;_;
03:15:26 <aupiff_> there is no prefix in my saved file, but I guess Data.Binary.decodeFile is looking for one?
03:16:06 <quchen2> aupiff_: Did you save a Binary-encoded Bytestring to the file, or did you use Bytestring-the-library's write-to-file?
03:16:43 <quchen2> Or better: show us the code
03:17:46 <aupiff_> https://github.com/aupiff/haskell-eigen/blob/sparse-serialize/Data/Eigen/SparseMatrix.hs#L286-L321
03:18:06 <aupiff_> is my binary instance, and the same repo has tests that verify decode . encode == id
03:18:13 <Node_> Hi, I started a forum for cracking/hacking/linux etc, you can join and help us grow a community if you want . http://syntaxcore.com
03:18:46 <aupiff_> am using Binary's `encodeFile` and `decodeFile`
03:20:24 <Node_> Hi, I started a forum ( http://syntaxcore.com ) for cracking/hacking/linux etc, you can join and help us grow a community if you want . We are looking for staff 
03:20:59 <indiagreen> Node_: please stop advertising your forum here, it's not the place
03:21:04 <quchen2> aupiff_: encodeFile/decodeFile should be inverses of each other.
03:21:29 <Node_> Ok, sorry
03:21:51 <dramforever> hmm...I dislike the "craking/hacking/linux" part
03:21:56 <aupiff_> I know. but decodeFile is skipping the first 64 bits...
03:22:42 * hackagebot shortcut-links 0.2.0.0 - Link shortcuts for use in text markup  http://hackage.haskell.org/package/shortcut-links-0.2.0.0 (Artyom)
03:23:24 <ghost_runner> As a beginner, should I use a LYGH-Haskell combo or a SICP-Scheme one?
03:23:55 <dramforever> ghost_runner: to be fair, you shouldn't ask this question here, nor in #scheme or something like that
03:24:15 <dramforever> also IIUC, it's LYAH not LYGH
03:24:22 <arw> ghost_runner: try both, do what seems more appropriate/easier/better to you.
03:24:27 <quchen2> "Haskell, of course" /end chrus
03:24:49 <arw> ghost_runner: learning is a very individual thing, so there is no one best solution.
03:25:12 <Walther> ghost_runner: Do you have previous programming experience?
03:25:43 <jle`> ghost_runner: what are you a beginner to, and what are you trying to learn/do in the end?
03:26:25 <ghost_runner> Walther, jle`: Newbie interested in security/hacking.
03:26:51 <dramforever> security/hacking???
03:27:16 <dramforever> to me it doesn't make sense
03:27:20 <Walther> ghost_runner: Have you done any programming any language?
03:27:49 <ghost_runner> Walther: Not yet, no.
03:28:16 <dramforever> ghost_runner: can you explain what's "security/hacking"? you mean software security and cracking?
03:28:16 <ghost_runner> dramforever: Technical man, eh? "Cracking" then.
03:28:22 <quchen2> aupiff_: Works for me.
03:28:28 <Walther> For security and hacking perspective, you might want to look into Python, it's very widely used in linux scripting, and linux is something that is used a lot in the security field
03:28:38 <quchen2> encodeFile "test.txt" (Data.ByteString.Char8.pack "hello world")
03:28:44 <ghost_runner> White hat pen-testing.
03:28:44 <dramforever> ghost_runner: they still don't make sense together, security and hacking are very different
03:28:51 <quchen2> decodeFile "test.txt" >>= Prelude.putStrLn . Data.ByteString.Lazy.Char8.unpack
03:28:56 <Walther> dramforever: two sides of the same coin though
03:29:09 <ghost_runner> dramforever: Not really.
03:29:20 <dramforever> well haskell has really nice features for writing secure software
03:29:23 <Walther> to design better security, you need to know what the attacking people will try to do
03:29:40 <quchen2> I don't know what "security/hacking" is, but it's not Haskell so this isn't the channel for it.
03:29:42 <dramforever> hmm...
03:29:43 <bennofs> ghost_runner: for this, you probably need a lowlevel understanding of how programs operate, so you will probably at some point encounter C
03:29:46 <dramforever> that's making more sense
03:30:14 <dramforever> ghost_runner: anyway, my advice is neither haskell nor scheme is good for that
03:31:07 <ghost_runner> dramforever, bennofs: So, C (yikes)?
03:31:24 <Walther> C and Python, very likely
03:31:27 <yarou> microcorruption 
03:31:28 <bennofs> ghost_runner: why yikes?
03:31:46 <saep> C/Assembler + some convenient scripting language (e.g. python, ruby)
03:31:50 <Walther> oh yeah, ghost_runner check out microcorruption
03:32:33 <ghost_runner> C is so...low.
03:36:17 <dramforever> ghost_runner: well security/cracking is so...low
03:37:06 <tero-> for web service security / cracking a high-level language will do
03:37:49 <maerwald> I don't even understand what "security" is either, because it could refer to a number of very different things including cryptography
03:38:06 <catsup> ghc runtime is still implemented in c
03:38:36 <dramforever> maerwald: that's basically why I said "that's making more sense" instead of "that makes sense"
03:39:47 <bennofs> Where is the channel where the people with rights to edit hackage cabal data are?
03:40:06 <dcoutts> bennofs: some hang around in #hackage
03:41:24 <ronh> catsup there's an effort is to rewrite ghc runtime in haskell though
03:41:29 <catsup> regarding the off-topic question above, i'll just say that kr was never intended to teach beginning programmers, it was meant to teach programmers how to use the c language...  whereas sicp is a cs101 textbook
03:41:29 <ronh> s/is//
03:41:33 <catsup> ronh: i know
03:41:56 <Gurkenglas> @instances-importing Control.Comonad.Cofree ComonadCofree
03:41:58 <lambdabot> Couldn't find class `ComonadCofree'. Try @instances-importing
03:42:00 <Gurkenglas> What did I do wrong?
03:42:05 <petrus> where does stack install executables? Can this be changed?
03:42:18 <haskell595> if I newtype Unit and give the new type a semantic meaning outside the type system, is this new type isomorphic to Unit ?
03:42:36 <catsup> petrus: it puts them in .stack-work/install/...
03:42:43 * hackagebot hwsl2 0.3.1.1 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.3.1.1 (srijs)
03:42:57 <catsup> petrus: i mean, after building.  if you run 'stack install' it uses ~/.local/bin/
03:43:51 <Gurkenglas> Why doesn't https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Comonad-Cofree-Class.html#line-33 include an instance ComonadCofree [] Tree?
03:44:13 <haskell595> Like in Rust there are marker Traits like Send and Sync that are "empty" but have the extra meaning that it safe them to share them between threads
03:44:17 <haskell595> are they isomorphic to unit?
03:44:24 <petrus> catsup, thanks. is that documented anywhere, can be changed, what if there is no ~/.local/bin/
03:44:46 <catsup> petrus: i don't know; i don't know; and it will create the directory as needed
03:45:37 <catsup> you can of course just copy the binaries wherever you want to by whatever means you like
03:46:09 <petrus> catsup, sure once I found them.
03:46:54 <petrus> the execs are not in .stack-work/install/ as far as I can see.
03:47:15 <catsup> petrus: ls .stack-work/install/*/*/*/bin/
03:48:39 <petrus> catsup, nope, that must be temporary, once the install finished there is nothing there (in my case)
03:49:05 <catsup> that's where 'stack build' puts it, and leaves it
03:49:38 <catsup> maybe you're not actually building your executable?
03:49:45 <petrus> catsup, I was talking about install
03:50:01 <catsup> 'stack install' puts it in ~/.local/bin/
03:51:13 <petrus> well, it should be documented, not everybody has this dir and/or in their path.
03:52:38 <petrus> in particular, there is no uninstall
03:54:28 <johnycr> in what ways is haskell better than C#?
03:55:20 <Walther> johnycr: that completely depends on your usage scenario
03:55:26 <Walther> there aren't better or worse languages, in general
03:55:32 <dramforever> Walther: "in what ways"
03:55:44 <catsup> Walther: well, you don't need to take it that far
03:56:03 <Walther> sure
03:56:22 <petrus> johnycr, better language, much worst tooling -- sorry could not resist, just struggling with a new "easier" tool
03:56:42 <johnycr> yeah the question doesnt assume haskell is better. there are probably things C# does better as well.
03:57:02 <johnycr> I am curious about the things haskell does better, though
03:57:18 <dramforever> more declarative?
03:58:06 <catsup> johnycr: why do you ask?
03:58:47 <koomi> johnycr: some supposed advantages are a higher level of abstraction and better static guarantees via the type system
04:00:07 <johnycr> catsup curiosity. and maybe need some additional motivation for learning a new language. i am not looking for diplomatic answers :)
04:00:53 <koomi> johnycr: more abstraction allows for more code reuse, meaning less code for the job, which helps with maintainance
04:01:04 <dramforever> oh yes code reuse
04:01:24 <quchen2> Code reuse isn't a very good argument. OOP promises code reuse too.
04:01:48 <catsup> johnycr: the main things that haskell has are type inference, typeclasses, lazy evaluation, and pure code as the standard idiom
04:01:55 <dramforever> haskell has many "design patterns done right" stuff
04:02:26 <quchen2> ezyang has a nice post about what the GOF patterns correspond to in Haskell. Half of it is "functions".
04:02:38 <dramforever> yeah that's what I mean
04:02:38 <catsup> johnycr: there are two elements to type classes: the language support for type classes, and the library of actual type classes that exist
04:02:44 <quchen2> http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
04:02:51 * dramforever wonders if the rest corresponds to stuff in lens =P
04:03:20 <dramforever> quchen2: well by functions you mean library functions or functions you define?
04:03:32 <catsup> johnycr: another thing haskell has is runtime concurrency magic, and software transactional memory
04:03:39 * quchen2 suggests reading the article linked above
04:03:45 * dramforever is reading
04:04:03 <dramforever> well actually it's still loading
04:04:03 <catsup> i'm probably missing something, but i think that i've gone through most of what is different about haskell
04:05:43 <catsup> oh and the syntax is also very terse and nice.  currying and partial application are very nice.
04:07:15 <koomi> I don't think a list of more or less unique features of haskell is a good answer to "in what ways is haskell better than X"
04:07:44 * hackagebot soap 0.2.2.7 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.7 (AlexanderBondarenko)
04:11:27 <obadz> Any good documentations to understand "*" in types ?
04:12:04 <maerwald> :k Monad
04:12:05 <lambdabot> (* -> *) -> Constraint
04:12:07 <maerwald> this?
04:17:46 <johnycr> thanks for response everyone. what is the best way to learn haskell for someone who has a lot of experience with OOP and imperative languages, but little ir no experience with functional languages?
04:18:48 <Walther> johnycr: There's lots of amazing resources, like:
04:18:52 <Walther> @where lyah
04:18:52 <lambdabot> http://www.learnyouahaskell.com/
04:18:57 <Walther> @where rwh
04:18:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:19:16 <Walther> I've also written a short tutorial aimed at experienced programmers, http://walther.guru/one-hour-haskell
04:20:46 <daimonos> Which function can I use to create a file. Close it. Then edit it. Then close it.
04:21:35 <Walther> readFile, writeFile
04:21:39 <Walther> :t readFile
04:21:40 <lambdabot> FilePath -> IO String
04:21:43 <Walther> :t writeFile
04:21:44 <lambdabot> FilePath -> String -> IO ()
04:21:56 <maerwald> :t doesFileExist
04:21:57 <lambdabot> Not in scope: ‚ÄòdoesFileExist‚Äô
04:21:59 <maerwald> er
04:22:04 <dramforever> daimonos: close and edit?
04:23:09 <daimonos> dramforever: Hmmmm I close then open then edit then close.
04:23:22 <daimonos> It seems that appendFile doesn't close after it opens. I'm not sure
04:23:28 <ronh> writeFile will create a file if it does not exist or write over it if it does
04:23:44 <dramforever> withOpenFile "filename" WriteMode (return ()) -- might do
04:23:49 <dramforever> create the file
04:23:55 <ronh> daimonos are you reading the file in between the writes?
04:24:00 <ronh> in haskell]
04:24:31 <daimonos> ronh: Does it release immidately after?
04:26:15 <ronh> appendFile and writeFile do close the file. readFile doesn't, since it is reading the file lazily (it won't be closed until you evaluate entire string that it returned)
04:26:34 <ronh> file handle*
04:26:56 <maerwald> daimonos: check "withFile" in the code https://hackage.haskell.org/package/base-4.8.0.0/docs/src/System-IO.html
04:27:05 <maerwald> withFile name mode = bracket (openFile name mode) hClose
04:27:12 <maerwald> looks like it closes it
04:27:57 <daimonos> Here is my code and the test http://lpaste.net/80994695131430912
04:28:04 <daimonos> The code works but the test fails
04:28:36 <daimonos> I think it might be something to do with the reading and writing files.
04:29:05 <FPtje> Is this the right place to ask for help about sublimelinter-ghc? It doesn't understand subfolder modules: when GLua.Parser imports GLua.Lexer it says it can't find the module. The problem is caused by ghc -Wall not running from the right directory, but I can't find a setting anywhere.
04:33:23 <FPtje> A better question might be, why does ghc not understand that module GLua.Parser is in a subfolder called GLua? Isn't that how these things work in haskell?
04:33:50 <Taneb> FPtje, what is the file called?
04:34:00 <FPtje> Taneb, Parser.hs of course
04:34:10 <Taneb> How are you calling GHC?
04:34:52 <FPtje> Taneb, that's the thing, if I go to the GLua/ folder and run ghc -Wall Parser.hs, it errors. If I go one folder up and run ghc -Wall GLua/Parser.hs it works
04:35:13 <Taneb> FPtje, that I think is behaving as intended
04:35:18 <FPtje> Taneb, I need it to work in in the GLua folder, because the sublime linter has no option "run from folder" as far as I can tell
04:35:47 <dramforever> wow I just learned in ghc "some string"# :: Addr# and is a primitive string literal
04:35:56 <dramforever> the value is the address of the string
04:35:56 <FPtje> The whole linter becomes utterly useless because GHC is too stupid to figure out that module GLua.Parser is in a subfolder called GLua, and that import GLua.Lexer must be right next to it
04:37:18 <dramforever> hmm...I can't reproduce the problem here
04:37:34 <dramforever> FPtje: ^
04:37:46 * hackagebot shortcut-links 0.3.0.0 - Link shortcuts for use in text markup  http://hackage.haskell.org/package/shortcut-links-0.3.0.0 (Artyom)
04:38:08 <dramforever> FPtje: are you there?
04:38:10 <FPtje> dramforever, hold on, I'll make you a zip to reproduce it
04:38:28 <zipper> Hey can I get some help with this failing test: http://lpaste.net/80994695131430912
04:38:37 <zipper> What's going on?
04:38:55 <zipper> Also how can I assert a type in HUnit?
04:39:51 <dramforever> zipper: if the type is wrong the code doesn't compile
04:40:16 <zipper> dramforever: No I want to assert that the type returned is of a certain type.
04:40:28 <FPtje> dramforever, have an image instead, probably easier: http://i.imgur.com/ILSOnmm.png
04:40:32 <zipper> In  this case I want to make sure a function returns and IO Socket.
04:41:31 <FPtje> dramforever, A.hs is just module Yes.A where import Yes.B
04:41:43 <FPtje> dramforever, B.hs is module Yes.B where a = 1
04:41:47 <indiagreen> dramforever: regarding ‚Äúhow can I assert a type‚Äù: this isn't really relevant in the situation but I was amused by this: https://github.com/CRogers/should-not-typecheck
04:42:24 <dramforever> zipper: I have no more suggestions
04:42:44 <dramforever> or in Prolog's words, No.
04:43:12 <dramforever> FPtje: oh okay now I reproduced it
04:47:20 <FPtje> dramforever, is it me or is that incredibly stupid? The module name (Yes.A) tells GHC exactly where it is relative to other modules.
04:47:45 <dramforever> FPtje: well I guess the answer is "that"
04:48:03 <FPtje> dramforever, "that"?
04:48:13 <dramforever> ghc is incredibly stupid
04:48:23 <FPtje> damnit
04:48:27 <dramforever> 1. you can report a feature request 2. try -ipath/to/main/code/dit
04:48:31 <dramforever> s/dit/dir
04:49:27 <FPtje> dramforever, I can't edit the cli call of sublimelinter-ghc, which is crippled by this nonsense
05:00:25 <FPtje> Taneb, you said it's intended behaviour. Could you explain why? I mean I'm sure literally every haskell coder has faced this problem at least once in their career, but what makes it "intended"?
05:00:49 <Taneb> I'm not sure, it's just the behaviour I expect
05:01:40 <FPtje> Taneb, But all the information is there. It really just looks in the wrong folder
05:03:19 <FPtje> The thing is, I don't want to come across like an idiot when I report this bug. For all I know there might be some mechanism that would cause huge conflicts if it started looking in the right place.
05:06:38 <Flonk> > (("......"++cycle['a'..'z'])!!).ord <$> "shachaf"
05:06:39 <lambdabot>  "funpuns"
05:06:44 <Flonk> \o/
05:07:35 <maerwald> why do you write it like scala?
05:07:38 <Iceland_jack> > mapM(flip(!!))[0,4,1,2,4,1,3]"fnpsu"
05:07:39 <lambdabot>  "funpuns"
05:08:05 <Flonk> Iceland_jack: not bad
05:12:47 * hackagebot hwsl2 0.3.2.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.3.2.0 (srijs)
05:14:29 <dramforever> hi
05:14:53 <dramforever> I'm interested in the bound package, is there a good tutorial?
05:18:00 <johnycr> how can I fix this simple program? main = putStrLn ("Hello " ++ getLine) 
05:18:04 <johnycr> Couldn't match expected type `[Char]' with actual type `IO String' ‚Ä¶
05:18:23 <hamid_> johnycr, look at this:
05:18:25 <joco> I was trying to write a parser that takes a csv file and turns it into a wav file, however, when running on large .csv files, the program is killed because it consumes 4 gigs of ram, any idea why ? here is the code : http://lpaste.net/136658
05:18:26 <hamid_> :t getLine
05:18:27 <lambdabot> IO String
05:18:30 <hamid_> :t (++)
05:18:31 <lambdabot> [a] -> [a] -> [a]
05:18:39 <hamid_> :t "Hello"
05:18:40 <lambdabot> [Char]
05:19:04 <dramforever> johnycr: you are confusing side effect containers and pure values
05:19:10 <marchelz_> > putStrLn ("Hello " ++ unsafePerformIO getLine)
05:19:11 <lambdabot>  Not in scope: ‚ÄòunsafePerformIO‚Äô
05:19:16 <dramforever> no don't do that
05:19:25 <marchelz_> It's evil.
05:19:47 <dramforever> :t putStrLn =<< ("Hello" ++) <$> getLine
05:19:47 <lambdabot> IO ()
05:19:55 <dramforever> johnycr: that ^
05:20:26 <barrucadu> Or, perhaps more simply, main = do { name <- getLine; putStrLn ("Hello " ++ name); }
05:20:26 <marchelz_> preferably using do notation
05:20:29 <johnycr> ?
05:20:39 <dramforever> johnycr: ??
05:21:24 <dramforever> johnycr: what are you trying to "?" for?
05:21:53 <johnycr> how can I put getLine inline though, without assigning it to a variable?
05:22:22 <dramforever> it's not assign, it's bind
05:22:56 <dramforever> it's like take the string out of the side-effects enabled container (a.k.a. IO)
05:23:05 <frerich_> johnycr: That code barracuda posted is equivalent to 'getLine >>= \name -> putStrLn ("Hello " ++ name )'. Which is the same as 'getLine >>= putStrLn . ("Hello " ++)'
05:24:35 <bennofs> johnycr: there is a very good reason you cannot put getLine inline. Assume that was possible. Now conside putStrLn (getLine ++ getLine): in what order would those two calls to getLine be executed?
05:24:36 <dramforever> johnycr: see? haskell is very different from most other languages
05:25:15 <dramforever> johnycr: in haskell side effects enabled functions are wrapped and cannot be confused with pure values
05:25:16 <nshepperd> johnycr: http://www.vex.net/~trebla/haskell/IO.xhtml might be what you need to read
05:26:20 <johnycr> bennofs: I would expect them to be executed in order
05:26:41 <dramforever> johnycr: did you see my messages?
05:26:55 <bennofs> johnycr: the question is: in what order? from left to right?
05:27:09 <johnycr> yes and yes
05:27:21 <dramforever> johnycr: do they make sense?
05:27:31 * dramforever hopes so
05:27:52 <johnycr> not much. I started learning haskell half an hour ago
05:27:54 <keko_> in Haskell, a function must always return the same value when called with the same arguments
05:29:27 <johnycr> keko_: how can that be true for getLine?
05:29:41 <nshepperd> the key distinction to make is
05:29:51 <keko_> there's this trick where you don't return a string but rather instructions for getting a string
05:29:52 <nshepperd> "Hello" :: String is the string "Hello"
05:30:03 <keko_> and then you combine those instructions with the instructions for printing a string
05:30:03 <koomi> johnycr: getLine is not a function
05:30:17 <koomi> it's a computation that produces a String
05:30:23 <keko_> and yeah, getLine isn't really a function but rather a constant
05:30:26 <shoggoth> when I run hsenv ‚Äîghc=7.10.1 (or any other version) I get a segmentation fault‚Ä¶ I'm running linux mint and the apt-get'd version of ghc is 7.6.3; can anyone give me an idea of how to fix this?
05:30:34 <nshepperd> getLine :: IO String is a demon that can produce a string by arcane magic
05:30:47 <marchelz_> Functions typically have a '->' in their type signature.
05:30:53 <keko_> a constant where the value represents the action for reading a string from standard input
05:37:02 <Nux_> are there any haskell libraries serving as wrappers for SDL?
05:37:28 <dramforever> Nux_: hoogle for SDL
05:38:08 <Nux_> not sure why I asked BEFORE doing that
05:38:13 <Nux_> thanks
05:38:23 <Nux_> any recommended similar libraries?
05:42:02 <alpounet> Nux_: note that there's a #haskell-game channel, which many people behind the modern opengl, sdl, openal etc bindings
05:42:29 <Nux_> thanks for the info
05:42:42 <alpounet> err, s/which/with/
05:43:02 <azsx> why dont you guys use C instead
05:44:12 <maerwald> because you only have so much time in life
05:44:24 <edk> because different people and different problems elicit different solutions?
05:45:44 <solatis> i heard that Oculus VR is going to use LISP for its SDK ?
05:46:04 <solatis> oh wait, Scheme
05:46:07 <indiagreen> azsx: I'll be honest: primarily because I don't know C and am too lazy to study it because studying Haskell was fun but studying C is probably not going to be
05:46:33 <dramforever> azsx: oh why can't I use C *and* haskell?
05:46:34 <solatis> indiagreen: studying C is also fun, and a great excercise
05:46:43 <asthasr> indiagreen: C is fun, in a certain way. Just don't try anything mission-critical at first.
05:47:07 <solatis> you learn a lot about difference between stack and heap, performance implications, pointers, etc
05:47:23 <solatis> all very useful knowledge which you will apply, possibly without realizing, in other languages
05:47:32 <asthasr> solatis: oddly I think raw structs are one of the most interesting aspects I learned
05:47:42 <bennofs> is there even a global repository of packages with a little bit documentation for C "packages"?
05:47:48 * hackagebot digestive-functors-aeson 1.1.16 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.16 (OliverCharles)
05:47:50 * hackagebot json-assertions 1.0.7 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.7 (OliverCharles)
05:48:09 <arw> bennofs: nope.
05:48:14 <solatis> bennofs: nop, not really -- package managers are inside the OS, documentation is anarchy
05:48:17 <asthasr> i have a "theory" that types, OO classes, database tables, and structs are essentially all the same, along a continuum of abstraction (where types are the most abstract and structs the least)
05:48:45 <arw> bennofs: for the very basic libc kind of stuff, documentation is manpages. for the rest, it depends on the library.
05:48:49 <solatis> bennofs: what i do is use the quality of the documentation as a ballpark figure for the quality of the overall library
05:49:05 <koomi> bennofs: it's called the web and it sucks
05:49:16 <solatis> oddly enough, c/c++ programmers consider it a non-problem
05:49:16 <lpaste_> shoggoth pasted ‚Äúhsenv segfault‚Äù at http://lpaste.net/136659
05:49:48 <azsx> how about using C for a web framework
05:49:59 <azsx> or would haskell be a better choice
05:50:07 <koomi> solatis: they try hard to keep the number of external dependencies down
05:50:16 <arw> solatis: usually one considers the existence of a package manager for $language living beside the system's package manager a problem.
05:50:48 <bennofs> arw: well, I use haskell because I like sum types: data Command = CommandA CommandAData | CommandB CommandBData
05:50:53 <shoggoth> I'm getting a segfault from hsenv; http://lpaste.net/136659; can anyone suggest why I'd be getting this?
05:51:50 <bennofs> arw: if I'd consider an alternative, it would probably be rust, but not C
05:51:53 <solatis> koomi: that's kind of hard when your language doesn't even support basic data structures like maps
05:52:18 <solatis> azsx: C as a web framework is doable, but not worth the time imho
05:52:44 <arw> solatis: not really. you just implement everything all over again. which is usually necessary anyways since generic programming in C is complicated
05:53:14 <solatis> arw: yeah, but how is that a good thing ?
05:54:10 <arw> solatis: it isn't. i just meant that its not hard to just implement some crappy map-workalike for your usecase.
05:54:21 <solatis> i know, i've did my share
05:54:25 <maerwald> and by that you increase the possible sources of bugs, yes
05:54:42 <solatis> but when you implement, say, a tree structure, it's easy to get (re)balancing wrong, for example
05:55:26 <solatis> guess that's why i'm not paid for writing C :)
05:55:34 <arw> yes. but most c programs just don't use those kinds of complex data structures if its not absolutely necessary.
05:55:54 <tero-> if C is an option, then why not go C++?
05:56:25 <arw> tero-: because c++ is, contrary to the propaganda, not a sensible replacement for most places where c is necessary.
05:56:31 <solatis> thats why i get paid for writing c++, it's much more sane :)
05:56:48 <solatis> arw just gave the real answer tho
05:57:16 <maerwald> no, you guys just use haskell. period. :P
05:57:44 <arw> tero-: c++ needs a runtime system, it is hard to create binary-compatible c++ libs and programs and c++ is a treasure trove of extremely complex and dangerous features
05:58:30 <maerwald> because it cannot hide the complexity and it leaks through in a lot of corner cases, yes
05:58:35 <arw> tero-: and the runtime system makes c++ a non-option for embedded and OS work (not always but often) and the binary compatibility problem is bad for creating libraries in c++
05:58:45 <solatis> woa arw is on a rant
05:58:51 <arw> solatis: sorry
05:59:31 <solatis> what do you mean with binary compatibility tho? shared libraries?
06:00:01 <solatis> i know that in practice, in production, most people use static linking
06:00:04 <maerwald> if binary compatibility matters for you... stay away from haskell, *g*
06:00:06 <arw> solatis: yes. name mangling for example.
06:00:13 <arw> maerwald: i know.
06:00:27 <maerwald> which also makes it a nightmare to package
06:00:30 <solatis> can i enjoy writing c++ and haskell at the same time ?
06:01:11 <arw> .oO( I don't presume to dictate what you can and can't enjoy  ;)
06:01:43 <maerwald> solatis: only if you take a shower before you switch from c++ to haskell programming during the day
06:01:44 <maerwald> :P
06:01:52 <tero-> arw: good points. but maybe for stand-alone application development C++ strictly dominates C?
06:01:59 <arw> for me, generic programming in haskell was (after seeing what c++ templates look like) a dream come true.
06:01:59 <solatis> maerwald: i shower myself with monads when i do, yes
06:02:03 <maerwald> haha
06:02:18 <maerwald> solatis >>= shower
06:02:45 <maerwald> I think we are almost at #haskell-blah level now
06:02:45 <arw> tero-: yes, that is possible and often true. e.g. for gui, I know of no better environment than c++ and Qt.
06:02:46 <solatis> arw: yes, totally -- haskell feels like writing code the way i want to write my c++ code, if that makes sense ?
06:03:02 <bennofs> arw: you might try hsqml and Haskell :)
06:03:38 <arw> bennofs: thats next on my "play around" list. i'm trying to port some perl-Qt application to hsqml :)
06:03:45 <maerwald> arw: uh, I still prefer C and gtk over c++ and qt a lot
06:04:41 <maerwald> and gui in haskell sucks all the way, unfortunately
06:07:04 <asthasr> I think it's fortunate that we can, de facto, use the web as our GUI for most applications these days
06:07:09 <asthasr> otherwise almost no languages would be viable
06:07:19 <asthasr> besides C++, C#, and, uh... maybe Java?
06:07:37 <FPtje> Well guys, I reported the thing: https://ghc.haskell.org/trac/ghc/ticket/10643
06:07:42 <azsx> asthasr what do you think aboult mobile
06:07:48 * bennofs lobbies for HsQML
06:07:48 <zipper> Not specifically a haskell issue. More like a github issue.
06:07:49 <azsx> like android
06:07:52 <bennofs> (re: gui)
06:07:55 <bennofs> @hackage hsqml
06:07:55 <lambdabot> http://hackage.haskell.org/package/hsqml
06:08:05 <zipper> So I want to make it possible for a repo I have to be pulled without requiring SSH keys or some form of auth.
06:08:11 <maerwald> bennofs: it's a binding, so you still have all your IO stuff everywhere, it's not a real haskell-like framework
06:08:32 <solatis> asthasr: can i tell you a secret
06:08:35 <zipper> It's a submodule in my repo that led to the following failure: https://travis-ci.org/urbanslug/yesod-devel/jobs/71073153
06:08:35 <bennofs> maerwald: writing a reflex-frp binding for it atm :)
06:08:39 <maerwald> cool
06:08:42 <zipper> Any help?
06:08:48 <aweinstock> fishburne1: pong
06:08:55 <solatis> i'm developing a windows desktop application, and have to write a GUI... i'm using haskell + yesod :/
06:09:10 <zipper> brisbin: Hello
06:09:12 <tero-> solatis: embed a webview?
06:09:20 <zipper> Turanian: hello
06:09:24 <solatis> tero-: but but.. haskell
06:09:43 <tero-> ghcjs to the rescue
06:09:54 <asthasr> azsx: Well, for the most part mobile is a walled garden. Although even there a lot of people are following solatis' example and packaging web apps as native :p
06:09:57 <zipper> solatis: What's the issue?
06:10:03 <zipper> Windows just sounds painful
06:10:13 <solatis> zipper: writing portable GUI applications in haskell
06:10:35 <kuribas> solatis: there is also wxhaskell
06:10:35 <zipper> Oh I'm having issues with the same but at a lower level.
06:10:39 <solatis> i found that using a browser as my GUI would be acceptable
06:10:40 <bennofs> tero-: yeah, you can even use ghc and compile a GHCJS app to native with a gtkwebkit backend
06:10:55 <zipper> solatis: Why not make it a web app?
06:10:55 <asthasr> solatis: There is actually a very nice looking Go server client that was written in ClojureScript and deployed as a "native" app. I will find a link.
06:11:01 <zipper> solatis: Oh
06:11:22 <solatis> zipper: well it is an .exe, it just launches a http server and opens a browser window to 127.0.0.1
06:11:35 <zipper> Nice
06:11:40 <asthasr> solatis: http://pandanet-igs.com/communities/gopanda2
06:11:55 <solatis> i want to get the core functionality working first, transitioning to a real GUI can always be something that can be done in the future
06:12:30 <tero-> bennofs: can you do that in Windows?
06:12:54 <bennofs> tero-: hmm, haven't tried it, but I assume getting gtkwebkit to compile will be quite a challenge, I agreee
06:13:42 * kuribas doesn't understand the attractiveness of browser UI's.
06:14:50 <arw> if it needs to be "on the net", its usually the only option. but compared to e.g. winforms or Qt, all Web UIs are very lacking imho.
06:14:54 <tero-> HTML+CSS+JS is a very nice way to do UIs these days IMO
06:15:35 <solatis> kuribas: web programming is what i have been doing for a very, very long time and feels very natural to me. i have a finite amount of time, and need to decide where to focus my attention on -- in my case, i believe my target audience would be ok with a web GUI
06:15:43 <maerwald> I think it's terrible. But doing it without web usually involves more coding, that's why people do it. Not because it's a better idea.
06:16:11 <kuribas> maerwald: GUI programming isn't *that* difficult.
06:16:13 <silver> tero-, it sounds terrible actually
06:16:17 <maerwald> kuribas: I know
06:16:17 <solatis> maerwald: exactly what i'm saying
06:16:50 <tero-> ok I've leveraged frameworks like ExtJS which make it more bearable
06:17:05 <arw> GUI programming with the likes of delphi/lazarus, visual studio or qt designer is easier and faster by far, compared to web programming.
06:17:30 <kuribas> Even manually laying out things in wxHaskell isn't really that hard.
06:17:49 <maerwald> err, it's not about how to arrange GUI widgets, that's the same everywhere
06:17:49 <kuribas> I'd say easier than doing it in a web app.
06:18:15 <bennofs> yes, I haven't really found a gui lib that allows the flexible layout of web apps
06:18:34 <tero-> bennofs: have you tried ExtJS?
06:18:35 <arw> maerwald: no, layout is just the first step. e.g. in delphi, you just bind a database table to a widget and it fills in and changes data automatically. all the crud stuff takes 5s. 
06:18:51 <maerwald> arw: I know, I've been using delphi 10 years ago
06:20:09 <maerwald> I just think doing something like a git web interface in javascript or whatnot is easier hacked up than a GTK ui
06:20:52 <chpatrick> arw: I think web programming is really easy these days
06:21:02 <maerwald> I am talking about web based stuff really
06:21:11 <chpatrick> there are hundreds of really good libraries for client side
06:21:26 <hodapp> That's part of the problem.
06:21:28 <chpatrick> making it look good is way easier
06:21:42 <chpatrick> the server just needs to send JSON
06:21:47 <arw> chpatrick: yes. but making it work right is far harder, since you always need to sync up client and server.
06:22:06 <arw> chpatrick: e.g. checking things always needs to be done twice, and errors must be passed, etc.
06:22:07 <chpatrick> you can just make the server expose a nice API though
06:22:26 <chpatrick> as if the frontend was just any old client
06:22:28 <arw> chpatrick: yes, but thats overhead you only need because web.
06:22:56 <bennofs> arw: well, even with QtQuick, you have to interface QML <-> C++
06:24:09 <arw> bennofs: yes, but qtQuick is just one option you have. you still can just create widgets in c++ code or automatically bind your callbacks to widgets.
06:24:27 <arw> bennofs: i'm not saying that there won't be any work there, but its far better automated and easier imho
06:24:57 <maerwald> probably because you are more used to it
06:25:29 <arw> possible.
06:26:16 <danilo2> Hello! Can we somehow in current GHC haskell implementation export everything from a module but a set of functions? Such question was asked 2 years ago on SO, but it was not possible that time: http://stackoverflow.com/questions/17241491/haskell-hide-specific-functions-in-module-exports
06:26:47 <bennofs> danilo2: i think it possibe, let me check
06:26:55 <wordsarewind> I doubt it...
06:27:44 <bennofs> danilo2: ah, I was thinking of the answer in the comments
06:27:51 <bennofs> s/comments/the only answer
06:27:52 <azsx> hey did you guys know that CRAIGSLIST made money with a gui that looks like it was made by Haskell
06:28:07 <danilo2> bennofs: heh O was trying that, unfortunetally I don't see any way (known to me) that allows it
06:28:44 <danilo2> bennofs: That would be such simple extension and so powefull at the same time ... 
06:29:18 <bennofs> danilo2: just make an YourModule/Internal.hs module, put all your stuff there, and then make a YourModule that imports Internal and exports everything except some stuff 
06:30:08 <bennofs> danilo2: also makes it easier for users to do something that you didn't think of with your libn
06:30:09 <danilo2> bennofs: I know, I know, but this is just not so clear and nice like the desired solution. You know, I can clutter all my files and libraries, but they start to be not so clear for the users :)
06:30:35 <danilo2> bennofs: correct! Unless I exactly know nobody should ever touch it. Never ever! :D
06:31:03 <bennofs> danilo2: in practice, I feel like you just haven't thought of the reason to touch it yet :)
06:31:37 <kuribas> danilo2: well, ghc warns when you have a function that isn't exported and isn't used.
06:33:27 <bennofs> danilo2: hmm right, I think haddock doesn't produce nice docs in that case :|
06:35:40 <danilo2> bennofs: heh :)
07:07:52 * hackagebot matrix 0.3.4.4 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.4.4 (DanielDiaz)
07:12:52 * hackagebot frpnow 0.13 - Principled practical FRP  http://hackage.haskell.org/package/frpnow-0.13 (AtzeVanDerPloeg)
07:32:53 * hackagebot engine-io 1.2.10 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.10 (OliverCharles)
07:32:55 * hackagebot socket-io 1.3.3 -   http://hackage.haskell.org/package/socket-io-1.3.3 (OliverCharles)
07:40:30 <robstewartuk> What do library developers need to know about stack, in order to have their existing cabal-ised libraries supported by stack commands?
07:40:45 <robstewartuk> Any modifications for the .cabal file?
07:45:00 <Haskellfant> nope
07:45:11 <Haskellfant> just use stack init, and then stack build instead of cabal build
07:45:28 <robstewartuk> Haskellfant: thanks.
07:45:32 <Haskellfant> if you have dependencies that are not in stackage you need to add them to your stack.yml file but iirc stack init or stack build tells you about that
07:47:54 * hackagebot hwsl2-bytevector 0.1.0.0 - A hashed byte-vector based on algebraic hashes and finger trees  http://hackage.haskell.org/package/hwsl2-bytevector-0.1.0.0 (srijs)
07:51:13 <zmbmartin> Has anyone done a engine-io ServerAPI for wai? https://github.com/ocharles/engine.io/blob/master/engine-io-yesod/src/Network/EngineIO/Yesod.hs
07:51:53 <zmbmartin> I don't know yesod or snap the two provided and am not following what is going on very well.
08:05:22 <narendraj9> @type (fmap . fmap) (+) (+)
08:05:23 <lambdabot> Num a => a -> a -> a -> a
08:05:26 <narendraj9> @type (fmap . fmap) (+) 
08:05:27 <lambdabot> (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 (a -> a))
08:05:45 <narendraj9> What exactly is f (f1 a) here?
08:06:00 <johnw> functor composition
08:06:09 <kadoban> narendraj9: Two possibly different instances of Functor
08:06:10 <narendraj9> (+) :: (-> a ((->) a ))
08:06:13 <johnw> fmap = fmap . fmap for the functor (f ‚àò f1)
08:06:23 <Iceland_jack> :t (fmap . fmap) (+) :: Maybe [Int] -> Maybe [Int -> Int]
08:06:25 <lambdabot> Maybe [Int] -> Maybe [Int -> Int]
08:07:04 <narendraj9> I mean when (+) is passed as an argument to ((fmap . fmap) (+)) which required two functors, what are the functors?
08:07:17 <c_wraith> narendraj9: indeterminate
08:07:20 <johnw> (->) and (->) I bet
08:07:21 <kadoban> narendraj9: Haskell doesn't care, you get to pick them.
08:07:22 <c_wraith> narendraj9: it's determined by context
08:07:39 <narendraj9> @type (fmap . fmap) (+) 
08:07:40 <lambdabot> (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 (a -> a))
08:07:49 <c_wraith> narendraj9: when the inferred type has type variables, it means you as the programmer get to choose what gets put in those variables.
08:07:53 <kadoban> johnw: Naw, it'd say that if only (->) was allowed.
08:08:03 <johnw> @type (fmap . fmap) (+) (+)
08:08:04 <lambdabot> Num a => a -> a -> a -> a
08:08:05 <narendraj9> Is looking for a value of type f (f1 a) and give it (+).
08:08:19 <c_wraith> :t fmap . fmap
08:08:20 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:08:24 <johnw> i believe the functors chosen here are f = ((->) a) and f1 = ((->) a)
08:09:00 <c_wraith> Those are the only possible choices, given the type of (+), yes
08:09:18 <narendraj9> In that case what should f (f1 (a -> a)) be? I am not able to derive (a -> a -> a -> a)
08:09:40 <narendraj9> Hey wait. It's simple substitution now.
08:09:50 <c_wraith> all unification is simple substitution. :)
08:10:03 <c_wraith> At least in Haskell 98 or 2010
08:10:29 <aweinstock> > (fmap . fmap) (+) [[1,2,3],[4,5,6]]
08:10:30 <lambdabot>  [[<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>],[<Integer ...
08:10:35 <narendraj9> Okay. I see. f (f1 (a -> a)) is ((a -> a) -> b) -> b
08:10:47 <narendraj9> and b somehow happens to be the same as a.
08:11:01 <johnw> the somehow being because of (+)
08:11:30 <narendraj9> But how does ((a -> a) -> b) -> b translate to (a -> a -> a -> a) because (->) is right associative.
08:11:31 <c_wraith> I think you got that backwards
08:11:49 <c_wraith> It should be (a -> (a -> (a -> a)))
08:12:07 <narendraj9> Yes, it should be like that.
08:12:08 <johnw> ((a -> a) -> b) -> b would imply that f and f1 are contravariant
08:12:08 <c_wraith> The functor instance is on ((->) a), not (-> a)
08:12:48 <c_wraith> If ghc allowed type-level sections, that would be (a ->)
08:13:10 <c_wraith> But type-level sections aren't allowed for the same reason type-level lambdas are not allowed.
08:13:43 <narendraj9> If f = (->) a and f1 = (->) a, then f (f1 b) = a -> f1 b = a -> a -> b
08:14:02 <narendraj9> f (f1 b) for b = a -> a is (a -> a -> a -> a). That makes sense.
08:15:02 <narendraj9> c_wraith: I didn't get the thing about type-level lambdas.
08:16:24 <c_wraith> narendraj9: just consider it an unimportant aside for now. :)
08:16:51 <narendraj9> c_wraith: Okay. Thanks for the help :)
08:17:14 <narendraj9> johnw: Thanks to you too! :)
08:17:29 <johnw> :)
08:18:35 <hodapp> johnw: any other thoughts, for the example structures I gave, of what benefits an applicative may have?
08:18:46 <johnw> hodapp: none at the moment
08:19:07 <hodapp> johnw: alright, just curious, as I'm not exactly very clueful on applicatives, but they seem beneficial in parsers
08:19:24 <johnw> applicatives let you build up expressions that allow analysis
08:19:50 <johnw> because <*> receives two contextual arguments, rather than >>= which must "execute" a contextual value to yield the next contextual value
08:20:15 <johnw> so even with a huge applicative composition, you can "see" the whole tree, depending on your applicative
08:20:38 <johnw> but with monads, you can only ever see the next step at any time
08:21:54 <johnw> (unless you defer bind by lifting up into the Free monad, where you can again analyze, although you won't know which branch will be taken by an "if", for example; applicative doesn't have "if", so you avoid that quandry)
08:23:52 <johnw> ocharles has written some nice articles on using Applicative to do query optimization, which take advantange of this difference
08:24:32 <quicksilver> I'm not sure that quite came out right
08:24:40 <quicksilver> lifting up into the Free monad isn't some magic trick
08:24:51 <hodapp> johnw: sounds something like what Facebook did
08:25:02 <johnw> quicksilver: why did you think I was saying it was?
08:25:06 <quicksilver> any implementation could do smoethign a bit like that, just creating algebraic data structures
08:25:27 <quicksilver> "unless you defer bind by lifting up into the Free monad" sounds like that is the *only* way you can defer bind
08:25:41 <johnw> ah, no, it's just the most general way, in that it works for any monad
08:25:44 * quicksilver nods
08:26:20 <quicksilver> the thing that's easy to get wrong is lifting up into explicit data structures and not remembering to quotient by the laws
08:27:25 <hodapp> johnw: e.g. https://ocharles.org.uk/blog/posts/2014-05-28-pure-batched-queries.html ?
08:32:56 * hackagebot acme-operators 0.1.0.0 - Operators of base, all in one place!  http://hackage.haskell.org/package/acme-operators-0.1.0.0 (phadej)
08:37:56 * hackagebot esqueleto 2.2.8 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.8 (FelipeLessa)
08:47:56 * hackagebot mangopay 1.11.3 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.11.3 (FelipeLessa)
08:49:54 <aweinstock> does reducing an arithmetic expression to WHNF (e.g. "(1+2+3) `seq` ()") fully-evaluate 1+2+3 to 6?
08:50:01 <quicksilver> yes.
08:50:17 <quicksilver> ignoring what you wrote in parentheses
08:50:45 <quicksilver> your words made sense. The example in parentheses is wrong and probably confusing.
08:50:46 <Perlkonig> depends on its type
08:51:11 <quicksilver> true. I was assuming the built-in numeric types.
08:51:22 <quicksilver> You can imagine arithmetic types for which WHNF is not fully evaluated.
08:52:13 <infandum> Does pipes have a nub function (that continues to stream, not folded to a result)?
08:53:14 <aweinstock> quicksilver: how is the "(1+2+3) `seq` ()" thing wrong/mistaken? I thought it reduces 1+2+3 to WHNF, then ignores that and returns unit?
08:53:39 <Perlkonig> strictnesswise it's equivalent to 1+2+3
08:53:44 <aweinstock> quicksilver: (or is the point that since it's pure, that's optimizable to just unit)?
08:53:56 <Perlkonig> the `seq` () buys you nothing
08:54:52 <aweinstock> Perlkonig: in that case, it seems like I'm misunderstanding what seq does
08:55:25 <slack1256> but (1+2+3) `seq` () does what you said
08:55:29 <Perlkonig> seq links one expression to another, basically
08:55:48 <slack1256> evaluates (1+2+3) to whnf (ie 6) and then return ()
08:55:53 <quicksilver> aweinstock: (1+2+3) `seq` () is an expression which, when reduced to WHNF, ensures that (1+2+3) is reduced to WHNF
08:56:02 <monochrom> you know what, they don't even have the same type
08:56:05 <quicksilver> but then again the simpler expression (1+2+3) shares that property.
08:56:12 <monochrom> @type (1+2+3) `seq` ()
08:56:13 <lambdabot> ()
08:56:17 <monochrom> @type (1+2+3)
08:56:18 <lambdabot> Num a => a
08:56:35 <quicksilver> true. that's a different aspect of the problem :)
08:56:51 <aweinstock> :t \x -> writeIORef x (1+2+3)
08:56:52 <mniip> also WHNF is (1+2+3) is not always 6
08:56:53 <lambdabot>     Not in scope: ‚ÄòwriteIORef‚Äô
08:56:53 <lambdabot>     Perhaps you meant ‚ÄòwriteSTRef‚Äô (imported from Data.STRef)
08:56:58 <aweinstock> :t \x -> writeSTRef x (1+2+3)
08:56:59 <lambdabot> Num a => STRef s a -> ST s ()
08:57:13 <monochrom> the solution is to "instance Num () where ..."  then they will be Liskov-substitutable
08:57:16 <quicksilver> so many different possible axes of pedantry :p
08:57:31 <Perlkonig> mniip: repost
08:57:34 <quicksilver> personally I'd pretend it was 1::Int and at least rule out that angle.
08:57:38 <slack1256> mniip: on standard haskell numeric types?
08:57:46 <mniip> define standard
08:57:53 <slack1256> It's in base
08:57:58 <aweinstock> does that (applied to an actual STRef) evaluate 1+2+3 to 6 before storing it into the STRef? or does it store the thunk representing 1+2+3 into the STRef?
08:58:01 <mniip> sure, in instances of Num in the base package that is not the case
08:58:06 <geekosaur> mniip, we already stipulated the numeric types that are present in base
08:58:14 <geekosaur> it was one of the first comments raised
08:58:18 <quicksilver> aweinstock: it stores a thunk.
08:58:36 <aweinstock> :t ($!)
08:58:37 <lambdabot> (a -> b) -> a -> b
08:58:47 <quicksilver> let y = (1+2+3) in y `seq` writeIORef x y
08:58:51 <aweinstock> :t \x -> writeSTRef x $! 1+2+3
08:58:52 <lambdabot> Num a => STRef s a -> ST s ()
08:58:53 <quicksilver> is one way to make it be evaluated
08:58:58 <quicksilver> $! is another way, yes.
08:58:59 <slack1256> being fair I came up later to the discussion, so I was asking mniip
08:59:01 <jTT_> does anyone know how to treat the children of a node in xml-conduit as ‚Äúcontent‚Äù?
08:59:36 <monochrom> modifyIORef' will evaluate for you
08:59:50 <jTT_> so as to ‚Äúflatten‚Äù the xml structure? 
08:59:56 <nshepperd> :t evaluate (1+2+3)
08:59:57 <lambdabot> Num a => IO a
09:00:01 <nshepperd> <_<
09:00:04 <monochrom> then again its implementation does what quicksilver says
09:01:43 <nshepperd> I tend to think of the basic numeric types as "shallow" because of that, only having one 'level' of evaluation to do
09:02:04 <mniip> slack1256, I'm okay with PMs but private notices are urgh
09:02:04 <slack1256> best level
09:02:05 <nshepperd> whereas lists or lazy nats are kinda "deep"
09:02:35 <mniip> slack1256, [Bool] can represent an integer
09:03:04 <mniip> it can be pretty lazy if least significant bit is in the head
09:03:25 <slack1256> Oh I am gonna checkout that instance give a sec
09:03:29 <mniip> wrt addition and multiplication at least
09:03:30 <Perlkonig> > error "a" :+ error "b" `seq` ()
09:03:31 <lambdabot>  *Exception: a
09:07:41 <slack1256> mniip: You are right about [Bool] representing integers, but I was thinking on (+) on Num, as said above I also got the idea everything that implemented Num was shallow as said above
09:12:57 * hackagebot yesod-core 1.4.11.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.11.1 (MichaelSnoyman)
09:19:10 <danilo2> Hello guys! I've got a strange problem regarding installing a package. When I'm trying to install the newest containers, I get such error message: http://lpaste.net/136667 . I do not understand it, because it indicates that adjunction's is in conflict with containers, but it is not as far as I see. Would somebody be so nice and look at it? 
09:21:23 <dolio> You're using a sandbox?
09:22:54 <slack1256> seems like something --allow-newer can help
09:23:06 <dolio> It looks like the problem is that you installed adjunctions into a sandbox with one version of containers, and you're trying to install a different version of containers into that sandbox.
09:23:14 <danilo2> Yep. I know why! Its because it is not possible to use the new containers with GHC 7.8.3, because it would have to update templatehaskell, which will break the ghc lib
09:23:19 <dolio> Which, as it says there, is not allowed.
09:23:28 <dolio> Only one version of any package is allowed in a sandbox.
09:24:13 <bennofs> danilo2: you probably installed adjunctions compiled against containers==0.5.5.1 in the sandbox. This means that you can't also install another version of containers into the sandbox
09:24:31 <danilo2> I want only one version. the newest one. But together with lenses I cannot satisfy the deps . Hmm anyway I know now where is the clash, thanks! :)
09:24:35 <bennofs> ah, that's what dolio just said :)
09:24:59 <bennofs> danilo2: maybe you can re-install adjunctions to compile it against the new containers?
09:25:14 <danilo2> bennofs: After cleaning the sandbox and creating new one and evaluating: cabal install containers-0.5.6.3 lens  it does not work, because of some conflicts. It is the cause for that
09:25:31 <bennofs> danilo2: oh, can you show the conflicts? 
09:26:00 <bennofs> danilo2: [just wondering if it is already updated in lens, because lens is normally pretty fast in adapting to new versions of libraries IMO]
09:26:25 <bennofs> oh, I can just try myself I guess
09:26:26 <danilo2> bennofs: http://lpaste.net/136669
09:26:27 <bennofs> :)
09:26:29 <danilo2> bennofs: brb
09:26:44 <beta_cuckhold> You can only use on language for the rest of your life.
09:26:50 <beta_cuckhold> Which do you pick: Haskell or Lisp?
09:27:00 <beta_cuckhold> Choose wisely.
09:28:48 <bennofs> danilo2: ah, it doesn't have to do with lens. you cannot install a newer containers on that GHC version if you also use TH
09:29:17 <htebalaka> @pl \g f a -> g a
09:29:17 <lambdabot> const
09:29:22 <kuribas> beta_cuckhold:  So choose between a modern evolving language, and a old relic from the past?
09:30:27 <bennofs> kuribas: I think there are modern lisps too, no?
09:30:37 <kuribas> bennofs: scheme
09:31:17 <Iceland_jack> Clojure
09:31:31 <P4Titan> Hello all! What is the best way to derive the Unbox instance for a vector in Haskell?
09:31:55 <beta_cuckhold> I only have two choices for a first language: C++ or Haskell. I literally have no other options.
09:32:00 <beta_cuckhold> I can only choose one.
09:32:19 <kuribas> P4Titan: https://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector-Unboxed.html
09:32:30 <aweinstock> P4Titan: just use Data.Vector.Unboxed? (or are you asking something more subtle?)
09:32:47 <P4Titan> aweinstok: I have my own type that I want to put in a vector
09:32:57 <bennofs> P4Titan: this: https://hackage.haskell.org/package/vector-th-unbox-0.2.0.1/docs/Data-Vector-Unboxed-Deriving.html
09:33:08 <P4Titan> beta_cuckhold: You are in a haskell irc, I am perrty sure you will get biased info :D
09:33:28 <P4Titan> bennofs: But that requires some ugly includes
09:33:32 <bennofs> P4Titan: oops sorry, old link. Current is: https://hackage.haskell.org/package/vector-th-unbox-0.2.1.2/docs/Data-Vector-Unboxed-Deriving.html
09:33:43 <htebalaka> beta_cuckhold: you're first language, as in you don't have any other programming experience?
09:33:46 <bennofs> P4Titan: ugly includes? You mean extensions?
09:33:53 <kadoban> bennofs: Haskell by far. C++ is a ‚Ä¶ pretty tough and not very rewarding first language.
09:34:08 <danilo2> bennofs: Yep I see that! :)
09:34:09 <kadoban> bennofs: Sorry ‚Ä¶ not you obviously.
09:34:14 <bennofs> ;)
09:34:15 <kadoban> beta_cuckhold: ^
09:34:19 <danilo2> bennofs: thnaks! :)
09:34:33 <P4Titan> bennofs: Yes, extensions
09:34:35 <maerwald> C++ is the worst thing to start with (if you don't know C beforehand)
09:34:42 <P4Titan> I agree
09:34:58 <bennofs> maerwald: even worse if you know C :P
09:34:59 <kadoban> C and C++ are kinda tied for worst first languages, IMO.
09:35:03 <P4Titan> C builds for good C++ programming. Otherwise, you will find yourself writing some crap
09:35:06 <P4Titan> in C++
09:35:07 <maerwald> bennofs: because you hate it more then? ;)
09:35:13 <kuribas> kadoban: C is easier than C++.
09:35:19 <P4Titan> arguable
09:35:21 <bennofs> maerwald: because I don't like malloc and printf in my C++ code :)
09:35:23 <glguy> The merits of C and C++ are off topic for #haskell, generally
09:35:30 <P4Titan> true dat
09:35:37 <aweinstock> C++ was my first language, and I think I turned out ok
09:35:39 <kadoban> kuribas: Yes, but it also completely lacks good abstractions. C++ at least has some, even if they're kinda hard to get teaching good enough to tell you to use them.
09:35:39 <kuribas> kadoban: And C is a good language for low level programming, like embedded systems.
09:35:56 <P4Titan> So, about Unbox. Are those extensions using derivingUnbox the only way
09:35:57 <kadoban> kuribas: Yes, but even if that's your goal I still think it's an awful first language.
09:36:17 <beta_cuckhold> htebalaka: Nope. I need a language that will give me the power to do anything. These are my only two options, though.
09:36:21 <josephle> at #haskell-blah, we'll discuss the (de)merits of C/C++ with no restrictions :)
09:36:23 <maerwald> the point is... if someone said "choose between C and haskell as your first language" I wouldn't know what to say... for "choose between C++ and haskell" the answer is definitely haskell
09:36:24 <bennofs> P4Titan: hmm, there are not much other options I think since vector is focused on perfomance, and code generation is really the most guarranted way to achieve that. Other generic instance derivations mechanisms can be slow in some cases
09:37:02 <kuribas> P4Titan: you can write it by hand.  I did...
09:37:15 <kuribas> P4Titan: just copy the source, and put in your own definitions.
09:37:18 <aweinstock> P4Titan: you could manually write the derivation by following what the macro does: https://hackage.haskell.org/package/vector-th-unbox-0.2.1.2/docs/src/Data-Vector-Unboxed-Deriving.html#derivingUnbox
09:37:44 <aweinstock> is there a good reason to avoid TH for this sort of thing though?
09:37:59 * hackagebot lens 4.12.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.12.1 (EricMertens)
09:37:59 <htebalaka> beta_cuckhold: i personally would choose haskell, but i'm working on some stuff where i'll be generating code in other languages. if that's allowed it's an option
09:38:42 <P4Titan> That is ugly!
09:38:51 <aweinstock> (my understanding is that TH is useful for the same reasons as defmacro, that all the lisp advocates advocate)
09:40:36 <bergmark> aweinstock: partially at least, both are easy to abuse ;-)
09:41:27 <aweinstock> bergmark: all powerful features are necessarily abusable, that doesn't mean that you shouldn't use them as appropriate
09:42:45 <glguy> Speaking of lens updating for new versions of libraries, 4.12.1 has support for the new vector
09:44:04 <bergmark> aweinstock: one difference is that template haskell typically isn't used to create new language constructs, in contrast to dolist and friends in lisp
09:48:01 <aweinstock> bergmark: dolist == forM_ (in some sense the "base" language in haskell is more powerful, which is why TH is used less often, but it's still occasionally appropriate)
09:49:02 <bergmark> haskell also has generics that can be used instead of th a lot of the time
09:49:08 <aweinstock> bergmark: or is it more accurate to say that mapc == forM_, and that \ vs "lambda" is a *very* significant difference?
09:49:45 <aweinstock> generics referring to parametric polymorphism? or some feature I'm not yet aware of?
09:50:05 <bergmark> no in haskell generics is https://wiki.haskell.org/Generics
09:51:19 <bergmark> i'm trying to refresh my memory on what mapc is :-)
09:51:30 <bergmark> mapc function &rest lists+ => list-1 WHAT
09:51:59 <aweinstock> bergmark: mapc == forM_ (it calls a side-effecting procedure on each element of the input list)
09:52:17 <bergmark> ah okay
09:52:37 <bergmark> i guess list-1 means "the first list in lists+"
09:53:23 <aweinstock> yeah, i'm not really sure why that's a useful thing for it to do (for it to be side-effecting, but also act kind of like id?)
09:53:42 <bergmark> but iirc dolist is superfluous, it's just crazier syntax for other operations
09:54:53 <bergmark> if you think writing lambda and progn is too much typing :)
09:54:53 <aweinstock> dolist expands into mapc + lambda (it's just shorter than typing out "lambda" explicitly, hence my comment about haskell's lambda being just backslash being a huge win)
09:55:11 <bergmark> aye
09:55:39 <bergmark> had to implement dolist so many times while doing sicp that i learned to hate it
09:56:39 <aweinstock> why would you have had to implement it more than once?
09:57:28 <bergmark> as a primitive in the interpreter, as a macro, in the register-machine dsl, ...
09:58:39 <aweinstock> I've only worked through the first couple chapters of sicp
09:59:12 <P4Titan> I am deriving Unbox using template haskell. I get this following warning, how do I dissolve it?     No explicit method or default declaration for `Data.Vector.Generic.Mutable.basicInitialize'
09:59:13 <P4Titan>     In the instance declaration for `Data.Vector.Generic.Mutable.MVector
09:59:13 <P4Titan>                                        MVector TreeNode'
10:00:51 <aweinstock> P4Titan: what version of GHC? the documentation mentions some extra imports needed for 7.4
10:01:35 <P4Titan> 7.63
10:01:38 <beta_cuckhold> I read online that, "Haskell is for math geeks."
10:01:40 <P4Titan> 7.6.3
10:01:57 <P4Titan> beta_cuckhold: Wait, wats an integral?
10:02:31 <beta_cuckhold> I dont know. I failed math.
10:02:37 <bergmark> beta_cuckhold: that's true, fortunately it's also for other people
10:03:14 <P4Titan> Anyone know something of my issue?
10:03:17 <aweinstock> P4Titan: it's a generalization of summations of functions (if you were to sum infinitesmally-fine slices of a function)
10:03:26 <aweinstock> (regarding integrals)
10:03:44 <bergmark> i... think he was sarcastic
10:03:50 <lexluthor1> Guys, what do you think about http://gostash.it ?
10:03:51 <P4Titan> ye
10:03:58 <P4Titan> thanks for the explanation
10:03:59 <P4Titan> tho
10:04:02 <P4Titan> :)
10:04:35 <bergmark> lexluthor1: too much php
10:04:47 <P4Titan> Unbox anyone?
10:05:22 <bergmark> P4Titan: are you writing the th yourself?
10:05:29 <kuribas> P4Titan: I did it by hand and it works fine.
10:05:52 <aweinstock> P4Titan: it looks like the TH expansion has a bug, and doesn't write a definition for basicInitialize?
10:05:58 <P4Titan> No, I am using the Data.Vector.Unboxed.Deriving
10:06:21 <lexluthor1> Sorry for Russian language - http://gostash.it/users/challenge
10:06:48 <P4Titan> I should just use a boxed, Vector. My data type is TreeNode Int Int, should I change it to (Int, Int) and use boxed or no. What is the benefit of boxed v. unboxed?
10:07:19 <dolio> Oh. I didn't know that deriving stuff existed. So I missed it when I added basicInitialize.
10:07:41 <aweinstock> P4Titan: in the source here: https://hackage.haskell.org/package/vector-th-unbox-0.2.1.2/docs/src/Data-Vector-Unboxed-Deriving.html#derivingUnbox (after "let instanceMVector ="), there's no clause in the list for M.basicInitialize
10:08:00 * hackagebot pandoc 1.15.0.6 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.6 (JohnMacFarlane)
10:08:11 <P4Titan> Is that a bug?
10:08:20 <dolio> Yes.
10:08:21 * bergmark queues a new build @ http://matrix.hackage.haskell.org/package/vector-th-unbox
10:08:53 <aweinstock> P4Titan: congratulations, you've found a library bug!
10:08:59 <bergmark> \o/
10:09:00 <P4Titan> should I use the regular vector that does not need Unbox then or (Int, Int)
10:09:12 <bergmark> P4Titan: if you don't n
10:09:18 <P4Titan> n?
10:09:27 <bergmark> * P4Titan: if you don't know if you need unboxing you don't need unboxing
10:09:44 <P4Titan> what is it used for?
10:09:47 <aweinstock> P4Titan: unboxing is for performance
10:10:28 <aweinstock> P4Titan: if you're ok being Java-speed instead of C-speed, you can use a regular Vector instead of Vector.Unboxed
10:10:35 <P4Titan> An unboxed vector is like the C equivalent: TreeNode array[nElems];? A boxed vector is: TreeNode *array[nElems];?
10:10:35 <kuribas> dolio: are you the author of Data.Vector?
10:10:55 <dolio> I'm the de facto maintainer.
10:11:03 <dolio> Oh, ve
10:11:04 <aweinstock> P4Titan: essentially, yes
10:11:09 <P4Titan> dolio: So will that get fixed? ;)
10:11:10 <dolio> Oh, the deriving is in a completely separate package.
10:11:14 <P4Titan> dang
10:11:18 <P4Titan> thats right
10:11:28 <dolio> With bad version bounds, presumably.
10:11:53 <dolio> Yeah, no upper bound.
10:11:58 <P4Titan> Should I implement by hand the basicInitialize or scrap the template haskell and use the boxed vectors?
10:12:13 <aweinstock> is it possible to manually provide basicInitialize in a seperate "instance ... where" clause, while using TH for the rest of them?
10:12:30 <dolio> I doubt you can provide a single extra method.
10:12:40 <dolio> Without a lot of work.
10:12:51 <dolio> You'd probably have to fiddle with the TH structure.
10:12:53 <P4Titan> You know what, templates make my code look so ugly. I'll use the boxed vector
10:13:27 <dolio> P4Titan: You could go back to vector 0.10 for the time being, too.
10:13:33 <dolio> That won't have this issue.
10:13:48 <P4Titan> but this is not an issue with vector but th-vector
10:13:51 <kuribas> dolio: I was wondering, if I have a datatype Point {x::a, y ::a}, can I have a constant time destructuring of Vector Point, like unzip for Vector (a,a)?
10:14:14 <P4Titan> map?
10:14:32 <dolio> It could, with the right vector type.
10:15:04 <P4Titan> Ohh, well. I'll unstall the th-vector package and go with boxed vectors
10:15:07 <P4Titan> Thanks guys!
10:15:17 <kuribas> dolio: suppose I have a Unbox instance for Point
10:15:21 <dolio> Unboxed vectors are structure of arrays, so they'd be implemented in a way that you could constant time unzip.
10:16:46 <kuribas> yes, but how?
10:17:04 <dolio> Which part?
10:17:05 <kuribas> is "map x" constant time?
10:17:16 <dolio> No.
10:17:47 <dolio> You'd need access to the constructors, which you may not have at the moment, but we're planning on adding it.
10:18:06 <kuribas> ok
10:18:15 <dolio> Once you had that you could write a rule that rewrites 'map x' into something constant time, I guess.
10:19:50 <kuribas> That's true. But I find messing with rewrite rules a bit of a black art.  I found it hard to predict when a rules fires, with INLINEing and such.
10:22:30 <dolio> Yeah, and there's probably no reason for you to want to write 'map x' when you could instead write the guaranteed-faster thing.
10:23:00 * hackagebot esqueleto 2.2.9 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.9 (FelipeLessa)
10:24:23 <johnw> it would be neat to GHC to print every rewrite/inline/substitute rule as it fires
10:24:52 <dolio> I guess the one possibility would be if you were trying to do some fusion thing, where 'map x' gets used if stream stuff is happening, but if it's a concrete vector, you use the constant-time unzip. But that'd probably be very fragile.
10:25:02 <hodapp> johnw: hmm, that ocharles article is giving a little bit of hint why applicatives might be handy.
10:27:32 <johnw> also read sclv's amazing series starting with http://comonad.com/reader/2012/abstracting-with-applicatives/
10:28:01 * hackagebot linear 1.19.1.3 - Linear Algebra  http://hackage.haskell.org/package/linear-1.19.1.3 (EricMertens)
10:28:24 <pyon> Could anyone please quickly remind me what the Scott encoding achieves that the Church encoding doesn't?
10:28:26 <hodapp> johnw: thanks, will do
10:28:41 <johnw> pyon: scott encoding let you do case analysis
10:28:47 <johnw> Church encoding is a fold
10:28:57 <pyon> Oh.
10:29:13 <hodapp> johnw: right now the code is a big pile of Template Haskell but I don't know if the thing I'm trying to solve can be done sanely without TH
10:29:28 <johnw> nearly anything can be solved sanely without TH
10:29:32 <pyon> johnw: Thanks!
10:33:03 <hodapp> johnw: the particular thing that I am still trying to wrap my head around is how to achieve strongly-typed field access on something built up in this manner; you could use existentials, but how would you sanely get the type 'out' of it?
10:34:54 <hodapp> johnw: e.g. if I build up a struct with fields Uint8 "field1", Uint8 "field2, Uint16 "field3, I can extract field1 with something like... foo <- deref (blah ~> field1), and then 'foo' is a Uint8; field1 is what they generate with TH (though it could take various forms)
10:38:11 <aweinstock> johnw: -ddump-rule-firings (it's already a thing that GHC does)
10:38:20 <hodapp> and this is consistent with, say, how you access an array (foo <- deref (arr ! 0)) or just any Ivory variable (foo <- deref var)
10:53:02 * hackagebot smoothie 0.3.3.3 - Smooth curves via several interpolation modes  http://hackage.haskell.org/package/smoothie-0.3.3.3 (DimitriSabadie)
10:57:07 <dyoung_> How do you generate a hoogle database from cabal? "cabal install --haddock-hoogle" doesn't seem to be working
10:57:47 <fr33domlover> Q: is FlexibleInstances the only/best way to write class instances for tuples?
10:57:49 <dcoutts> dyoung_: it makes the hoogle input text files, there's another step to make a hoogle db.
10:58:20 <dyoung_> dcoutts: do they have the .txt extension? I don't see those either, actually
10:58:37 <dcoutts> dyoung_: iirc, yes.
10:58:59 <johnw> aweinstock: cool!
10:59:07 <dcoutts> dyoung_: and you've got hoogle on the path presumably
10:59:11 <dominik> any ideas on how to best parallelize the following problem: I have a list of unique haskell files and would like to read in and then parse all of these files using haskell-src-exts.
10:59:38 <dyoung_> dcoutts: yeah, I have hoogle installed
10:59:59 <dcoutts> dyoung_: actually hoogle isn't even needed, it's haddock that makes the .txt files
11:00:10 <dominik> so essentially I would like to use strategies to parse all the file's contents in parallel. However, I'm not sure if I can do so due to the taint of the IO monad.
11:00:42 <dcoutts> dyoung_: see what's happening with the haddock --hoogle step, run with -v
11:03:49 <dyoung_> dcoutts: hmm, if it's using the haddock executable, it isn't showing it in the -v log. It only says that it finds haddock and never mentions it again
11:04:07 <dcoutts> dyoung_: are you generating docs at all?
11:04:12 <dcoutts> you need to tell it to do that
11:07:28 <dyoung_> dcoutts: ahh, that looks like it was part of it. It still looks like it's only generating HTML docs though, no .txt files or .hoo files
11:07:45 <dyoung_> oh, oops, yeah there is
11:07:51 <dyoung_> thanks!
11:11:18 <dcoutts> dyoung_: so accoring to the code, you can enable docs, but disable html, and enable hoogle. If you don't want html too of course.
11:12:13 <dcoutts> dyoung_: ie in the /.cabal/config, documentation: True, and then in the haddock section, hoogle: True  and html: False
11:12:28 <dyoung_> dcoutts: will that fail to install if hoogle isn't installed?
11:12:39 <dyoung_> (I mean the whole build, not the docs)
11:12:51 <dcoutts> dyoung_: no, it doesn't need hoogle, just haddock
11:13:03 * hackagebot aeson-schema 0.3.0.7 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.7 (TimBaumann)
11:13:20 <dcoutts> dyoung_: since it only generates the hoogle input .txt files, it doesn't run hoogle to build/rebuild the aggregate db
11:13:38 <dcoutts> the latter would be useful of course, cabal does that for the combined haddock doc index
11:14:12 <dyoung_> dcoutts: is there a way to tell it to install the hoogle database into the place where hoogle looks for databases?
11:14:49 <dcoutts> dyoung_: that's the bit that it doesn't do, that's what I meant above
11:14:59 <dyoung_> ahh
11:15:04 <dcoutts> send a patch :-)
11:16:26 <dcoutts> dyoung_: see http://hackage.haskell.org/package/hoogle-index
11:18:06 <dyoung_> dcoutts: that looks like what I want
11:21:56 <rowanblush> Oh wow, does anyone know anything about the new Numeric.Natural in base-4.8.0.0? I hadn't heard anything about this. Was there an announce somewhere?
11:23:41 <quchen> rowanblush: Not really. The changelog has to suffice.
11:24:08 <rowanblush> I am just so excited.
11:24:15 <quchen> Quite a nice hidden feature, yes :-)
11:33:04 * hackagebot smoothie 0.4 - Smooth curves via several interpolation modes  http://hackage.haskell.org/package/smoothie-0.4 (DimitriSabadie)
11:38:00 <zipper> So ghc has this `ghc --show-iface` according to the docs it does "Display the contents of an interface file"
11:38:06 <zipper> What is an interface file?
11:38:34 <bennofs> zipper: the .hi file ghc generates when it compiles a module
11:38:34 <zipper> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/IfaceFiles
11:38:37 <zipper> Oh
11:38:49 <quchen> Roughly "a compiled header file"
11:39:02 <zipper> bennofs: Is there a place I can read about the compilation process?
11:39:11 <bennofs> yeah, it contains stuff like definitions of functions [for inlining], types of functions [for typechecking] etc
11:39:27 <zipper> So there is a hi file for each module?
11:39:29 <quchen> zipper: This is a pretty good overview: http://www.aosabook.org/en/ghc.html
11:39:31 <bennofs> zipper: yes
11:39:40 <zipper> quchen: Thanks.
11:39:58 <bennofs> quchen: it doesn't mention hi though afaik
11:40:18 <zipper> Oh boy
11:40:20 <quchen> Well, he wanted a writeup of the compilation process. :-)
11:40:34 <quchen> The flowchart is particularly useful to keep in mind.
11:44:20 <dyoung_> okay, something weird is happening: if I run "hoogle --info rhsR", it gives me back the (local) hoogle docs for rhsR and it says "From hermit-shell package", but if I try "hoogle --info rhsR +hermit-shell" it says it can't find the database for hermit-shell
11:44:33 <Gurkenglas> @instances-importing Control.Comonad.Cofree ComonadCofree
11:44:35 <lambdabot> Couldn't find class `ComonadCofree'. Try @instances-importing
11:44:37 <Gurkenglas> What did I do wrong?
11:47:16 <dyoung_> Gurkenglas: is ComonadCofree not already in scope?
11:47:20 <geekosaur> assumed that lambdabot has that package around?
11:47:27 <dyoung_> :t unwrap
11:47:28 <lambdabot> ComonadCofree f w => w a -> f (w a)
11:47:46 <Gurkenglas> @undefine
11:47:46 <lambdabot> Undefined.
11:47:49 <Gurkenglas> :t unwrap
11:47:50 <lambdabot> Not in scope: ‚Äòunwrap‚Äô
11:47:56 <Gurkenglas> I had just imported it :P
11:48:01 <Gurkenglas> (in a query)
11:48:04 * hackagebot pandoc-types 1.12.4.5 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4.5 (JohnMacFarlane)
11:48:45 <geekosaur> dyoung_, if hermit-shell docs are in the main database, you couldn't use or want +dbname
11:49:11 <geekosaur> (hm, I may be understanding that incorrectly)
11:49:33 <dyoung_> geekosaur: what I'm trying to fix is that it's looking in the wrong package first
11:49:36 <Gurkenglas> @instances Monad
11:49:37 <lambdabot> Alt f, Cofree f, ExceptT e m, First, Gen, IO, Identity, Last, Maybe, Proxy, ReaderT r m, Seq.Seq, StateT s m, Tree, WrappedMonad m, []
11:49:45 <Gurkenglas> ...has Cofree, so the package should be around
11:49:59 <dyoung_> geekosaur: I want it to always start by looking in hermit-shell
11:50:22 <zmbmartin> Can anyone give me some pointers/insight into this error https://gist.github.com/codedmart/036dc531cd45093810d0
11:50:26 <bitemyapp> Anybody here have production Haskell experience that would be interested in a Haskell gig? Remote or Austin, TX local.
11:54:39 <dyoung_> zmbmartin: the type is "srvTerminateWithResponse :: Int -> BS.ByteString -> Builder.Builder -> forall a . m a", so you need to give back something that doesn't pick a specific a. Does ServerAPI have a MonadPlus instance?
11:55:18 <dyoung_> oh, I mean SocketM
11:59:48 <Zemyla> Hmm. How well do you think this vector intermediate type would work out? I'm trying to have O(1) concatenation.
12:00:31 <Zemyla> data CVector a = CVector !Int (forall v s r. (MVector v r) => v s r -> (a -> r) -> ST s ())
12:06:06 <zmbmartin> dyoung_: I was told I need to give it a monad. I am a little lost on this
12:06:51 <dyoung_> zmbmartin: what do you mean by give it a monad?
12:07:11 <Cale> zmbmartin: What's SocketM?
12:07:36 <zmbmartin> Cale ReaderT (Request, Response -> IO ResponseReceived) IO
12:08:27 <Cale> dyoung_: Is there an explicit type signature hanging around?
12:08:36 <Cale> oh, your code is below
12:08:39 <Cale> sorry, didn't see it
12:08:44 <zmbmartin> dyoung_: I was told 'make a choice of what 'm' is' in ServerAPI and suggested to use 'ReaderT (Request, Response -> IO ResponseReceived) IO1
12:08:55 <zmbmartin> Oops 'ReaderT (Request, Response -> IO ResponseReceived) IO'
12:11:17 <Cale> Ah, I see
12:11:39 <Cale> Interesting choice of types :)
12:12:04 <Cale> srvTerminateWithResponse :: Int -> ByteString -> Builder -> forall a. m a
12:12:04 <Cale> Send a response with the given status code, content type and body. This should also terminate the web request entirely, such that further actions in m have no effect.
12:12:25 <Cale> I'm guessing there's probably some explicit way to terminate the request that you're meant to use.
12:12:52 <Cale> The idea is that the thing shouldn't return normally, and the type system is being used to check for that.
12:14:00 <zmbmartin> Cale: I am trying to understand this error Couldn't match type ‚Äòa‚Äô with ‚ÄòResponseReceived‚Äô
12:14:37 <Cale> The action your function gives is *required* to be polymorphic in its result type
12:14:50 <Cale> This is because whatever action it is, is not supposed to return normally.
12:15:04 <martinvlk> Hi folks, anyone has experience using stack for testing? I find when I make changes to my code and then re-run "stack test", it doesn't pick up changes.. which means it runs tests with old compiled version..
12:15:31 <Cale> zmbmartin: I'm guessing there's some explicit way to terminate the web request which you're meant to use.
12:16:55 <Cale> finishWith :: MonadSnap m => Response -> m a Source
12:16:55 <Cale> Short-circuits a Snap monad action early, storing the given Response value in its state.
12:17:09 <Cale> ^^ this is what gets used in the Snap version
12:18:06 <zmbmartin> Cale: Hmm‚Ä¶
12:20:22 <zmbmartin> Cale: Doesn't seem like the yesod one is doing anything fancy https://github.com/ocharles/engine.io/blob/master/engine-io-yesod/src/Network/EngineIO/Yesod.hs#L31-L32
12:20:28 <zmbmartin> But I don't know yesod either.
12:21:08 <Cale> sendResponseStatus :: (MonadHandler m, ToTypedContent c) => Status -> c -> m a
12:24:48 <zmbmartin> Cale: OK, I will keep seeing what I can come up with. I am a little lost with all this. Slightly above my head at the moment.
12:28:41 <dyoung_> zmbmartin: you can't pick a specific 'a'. It's sort of like why you can't have "bad :: Maybe a; bad = Just 'z'"
12:28:47 <Cale> zmbmartin: Yeah, it's conceivable that you may end up having to mess around with exceptions or some tricky control nonsense to make this fit.
12:30:06 <zmbmartin> Thanks guys! I will see what I can come up with.
12:30:32 <SrPx> Is type erasure possible in any type system? That is, for any term in any language, you can always get a corresponding term with the types erased?
12:31:18 <dyoung_> SrPx: In *any* type system?
12:31:24 <SrPx> yes
12:31:55 <dyoung_> C doesn't need types at runtime
12:33:06 <Cale> SrPx: No, some type systems can't do this.
12:33:14 <maerwald> s/need/have/
12:33:47 <dyoung_> SrPx: you mean in all type systems or in any type system?
12:34:02 <SrPx> Sorry I mean in all type systems.
12:34:05 <SrPx> Cale: thanks
12:34:35 <quchen> Depends on what you mean with erasure. Java erases all types while adding tags during runtime.
12:34:37 <dyoung_> oh, yeah. You can't fully erase types in GHC Haskell I believe, because of things like polymorphic recursion
12:35:13 <mauke> polymorphic recursion is haskell tho, not ghc
12:35:28 <dyoung_> oh, Haskell in general then maybe
12:35:41 <shachaf> You can erase types with polymorphic recursion.
12:36:00 <Cale> SrPx: Erasure is tricky business in most dependently typed systems. You can't really hope for complete erasure, because types get so involved in the computation which is taking place.
12:36:07 <mauke> what's type erasure?
12:36:19 <dyoung_> shachaf: really? how does that work?
12:36:32 <shachaf> Same way it works anywhere else.
12:37:04 <dyoung_> are you counting the type class dictionary as part of the type itself (that is, something that would be erased by type erasure)?
12:37:13 <Cale> dyoung_: Polymorphic recursion doesn't require inspection of the types at runtime as it is
12:37:17 <shachaf> No.
12:37:19 <dyoung_> ah
12:37:29 <shachaf> If you count that, you can't erase types in Haskell at all, polymorphic recursion or not.
12:37:36 <shachaf> Class dictionaries are pretty important.
12:37:44 <hodapp> @_@
12:37:49 * hodapp stumbles off to look up cat pictures
12:37:53 <mauke> shachaf: that looks wrong
12:38:05 <mauke> class dictionaries aren't even in the language
12:38:12 <int-e> shachaf: well, as jhc demonstrated you can get away without class dictionaries... if you add explicit runtime type information
12:38:21 <shachaf> mauke: Type erasue isn't in the language either.
12:38:38 <int-e> (For Haskell 98 ... I'm not sure about most extensions)
12:38:45 <mauke> ok?
12:39:47 <shachaf> Maybe in Haskell 98 without polymorphic reursion you can just monomorphize.
12:41:21 <SrPx> Could always translate a dependently typed term to a Haskell DSL of tuples of value/types, and an apply operation? For example, `type Term = (Value, Type), apply :: Term ‚Üí Term ‚Üí Term`, right? For example, you have ((double :: Int ‚Üí Int) (x :: Int)) - you could translate it to (apply (double, (Arr Int Int)) (x, Int))
12:42:00 <hodapp> int-e: JHC has no class dictionaries?
12:42:12 <SrPx> This was a bit poorly phrased, excuse me.
12:44:20 <geekosaur> hodapp, jhc does whole-program compilation and can probably optimize all dictionaries away at compile time as a result
12:44:35 <dyoung_> SrPx: I think you could run into issues with types that you don't fully know until runtime, like certain uses of idris's filter : (a -> Bool) -> Vect n a -> (p ** Vect p a)
12:45:19 <borklaser> why do people say haskell is a language for geniuses
12:45:32 <hodapp> who says that?
12:45:34 <mauke> they don't
12:45:43 <mauke> I know; I've talked to people
12:45:48 <SrPx> Ah that makes sense... I think. Hm...
12:45:52 <geekosaur> people who want to use that as an excuse to not bother with haskell?
12:45:58 <hodapp> ^
12:47:12 <maerwald> maybe because some concepts in haskell are more difficult to understand than for-loops and pointers
12:47:32 <maerwald> but it doesn't really relate to geniuses
12:47:38 <borklaser> does haskell have for loops AND pointers PLUS those harder concepts too?
12:47:58 <flux> because they look at the programs at language shootout ;-)
12:48:16 <mauke> not C-style for loops
12:48:21 <mauke> pointers yes, if you use the FFI
12:48:21 <SrPx> Lets be honest, Haskell is used mostly by academics and you can't do a lot in Haskell without reading a lot of advanced material. For example, things as simple as deep updates "a.b.c.d = 7" (javascript) needs either a ton of boilerplate, or Lens... and 90% of Lens documentation consists of words you would only find in a phd thesis 
12:48:21 <dyoung_> pointers are not explicitly used very often and the thing that's like a for loop is really a function so it's not quite the same
12:48:41 <maerwald> SrPx: yeah, sometimes it is like that
12:48:43 <hodapp> for loops are really not used much in any functional-ish language
12:48:50 <int-e> hodapp: afair, it did something like this: http://lpaste.net/5208258917167005696 ... another ingredient to make it work is that jhc is a whole program compiler; and a third is that it relies heavily on partial evaluation to erase most of the explicit type reperentations even when type classes are used.
12:48:58 <maerwald> SrPx: but I wouldn't generalize it
12:49:21 <flux> what is easy in Haskell that is easy in JavaScript? asking only half-trolling ;-)
12:49:32 <dyoung_> SrPx: there's always lens-family-core
12:49:32 <flux> oops, "that is hard in JavaScript" of course
12:49:47 <shachaf> mauke: What did you mean about class dictionaries not being in the language?
12:49:51 <mauke> flux: type checking
12:49:56 <mauke> er
12:49:58 <mauke> oops
12:50:14 <flux> mauke, type checking JavaScript is dead simple :)
12:50:23 <flux> though your program might still fail..
12:50:29 <mauke> flux: not if you want to detect errors at compile time :-)
12:50:41 <SrPx> flux: ah a lot of things, actually. Like writing a parser. Haskell IMO makes impossible things easy, and easy things hard
12:50:57 <flux> mauke, of course, the point is detecting errors. and it's not all that difficult in js.
12:51:02 <mauke> shachaf: I mean they're an implementation detail in ghc, not part of the spec
12:51:04 <quchen> Checking your program against failing at runtime is pretty hard for most compilers.
12:51:13 <mauke> flux: show me
12:51:15 <flux> mauke, at least for a beginning developer
12:51:17 <maerwald> SrPx: then again... writing a _performant_ parser is a totally different story
12:51:19 <flux> with small programs.
12:51:42 <dyoung_> maerwald: well... I'm not sure it would be easier to write a fast parser in JavaScript than it would in Haskell...
12:51:47 <mauke> weirdly enough, unicode strings are unnecessarily hard in JS
12:51:53 <hodapp> maerwald: is that the real reason people like EDSLs so much in Haskell? :P
12:51:58 <SrPx> maerwald: true
12:52:01 <flux> in fact, deciphering type errors can make quite tedious, when the compiler doesn't give an example of the problem as you may get when debugging a javascript program :-o
12:52:30 <maerwald> dyoung_: I think the difference in haskell between toy implementations and high-performance implementations is higher than in other languages (not sure about javascript though)
12:53:27 <maerwald> but that's a terrible generalization and might be wrong for a lot of things
12:53:36 <maerwald> however, I feel that way
12:53:41 <dyoung_> maerwald: attoparsec is also supposed to be pretty fast.
12:54:02 <borklaser> I keep reading stuff like "Haskell will be dead in x years" where x is usually 20.
12:54:24 <dolio> Where?
12:54:28 <quchen> Haskell has been a temporary fad since the 1990s, so it'll probably be dead within the next 10 years for a couple of decades.
12:54:31 <mauke> I've literally never heard that one
12:54:36 <t7> anyone ever play with automated unit tests in haskell?
12:54:41 <maerwald> I think it will stay for as long as something like java, but will never reach that popularity
12:54:45 <shachaf> mauke: Oh, rereading that conversation, I see what you mean.
12:55:08 <dmj`> borklaser: how would it die? Everyone who uses it would have to die first
12:55:29 <mauke> assassinate SPJ
12:55:43 <maerwald> mauke: I think we don't have such a high bus factor
12:55:47 <borklaser> dmj`: I guess in the same way lisp 'died'
12:56:20 <dmj`> borklaser: did it though? 
12:56:23 <hodapp> if Lisp is dead then it needs to quit having babies all over the place
12:56:34 <dmj`> mauke: that might have the opposite effect
12:56:51 <maerwald> now this discussion turns weird :D
12:56:52 <quchen> And even when a language dies it's still not *gone*. Suppose everyone wanders off to Idris, then we have a Haskell-inspired language to carry on. Although I doubt that'll happen in the near future.
12:56:56 <martinvlk> hodapp: :-)
12:57:00 <Cale> borklaser: Haskell has probably crossed the threshold of immortality at this point.
12:57:12 <SrPx> but honest question, why do we need **Haskell**? Why can't we just create an evaluator for functional programs, optimize the hell out of it, and then use it as a compiler target to whatever functional language you like?
12:57:28 <Cale> SrPx: huh?
12:57:33 <quchen> SrPx: What's a "functional program"?
12:57:51 <geekosaur> SPJ's not as involved with ghc as he used to be, so I doubt that would work anyway
12:57:52 <Cale> Yeah, what's a "functional program"? :)
12:57:53 <mauke> "just"
12:57:55 <borklaser> Cale: You sure about that?
12:58:02 <Cale> borklaser: Pretty sure
12:58:03 <slack1256> SrPx: as morte?
12:58:09 <dmj`> borklaser: facebook uses it in production... they wouldn't do that unless there was some merit to its existence
12:58:34 <SrPx> slack1256: yes, as morte... which is not optimized the hell out yet but yes yes
12:58:42 <flux> dmj`, companies have used silverlight for production
12:58:46 <borklaser> Facebook is dying though
12:58:58 <mauke> netcraft confirms
12:59:07 <flux> dmj`, besides, you're talking about a company that uses (used) php for production :P
12:59:08 <hodapp> Journalists who write about technology N dying are dying.
12:59:12 <Cale> borklaser: Of course, it depends on what you mean by "dead" -- is a language dead when the language itself stops changing, or when people stop using it?
12:59:28 <slack1256> SrPx: Those are in the plans for world domination (*evil laugh*)
12:59:31 <asthasr> Why worry about Haskell "dying?" It has been an excellent laboratory for functional concepts and types
12:59:33 <SrPx> quchen: anything based on the lambda calculus, correct? If we had a very, very fast evaluator for the lambda calculus itself, we could compile haskell for that evaluator by erasing the types, get the result (normal form) back and then connect the cables for io, etc 
12:59:35 <Cale> borklaser: The rate of change of Haskell's specification is definitely lower now than it used to be.
12:59:36 <asthasr> I have certainly learned a lot from it
12:59:52 <mauke> that is not dead which can eternal lie
12:59:59 <borklaser> Cale: I'd say its the latter, from a general perspective; i.e. C has stopped changing yet still rules the world
13:00:12 <Cale> borklaser: Well, to *me*, C is really dead.
13:00:19 <Cale> heheh
13:00:27 <Cale> It depends on how you look at things I guess.
13:00:36 <quchen> SrPx: We already have lambda calculi we compile Haskell to that we use for optimization and to evaluate a result and connect cables.
13:00:42 <quchen> Core is one, STG is another.
13:00:47 <borklaser> Cale: C rules the hardware.
13:00:49 <Cale> I'm not really very interested in using languages which are not incorporating the best of current research.
13:00:52 <dmj`> flux: yes, but silverlight's creator  microsoft, killed it, they were trying to quantify this new html5 trend, people were fired over that decision. Microsoft has made a few good choices, haskell being one of them. Haskell has no corporate entity guiding it's creation for profit, its abstractions are discovered, not created
13:00:53 <borklaser> It dominates electeng
13:01:00 <asthasr> borklaser: God, I hope not for long. Please, Gods of Programming, let Rust succeed...
13:01:01 <slack1256> but for him is dead
13:01:19 <maerwald> Cale: I'd see it this way: a language is dead if no one is running programs written in it anymore
13:01:37 <Cale> maerwald: My point is there are many different types of "death"
13:01:39 <slack1256> the success of rust depends pretty much on how well it interoperates with C, there is simply too much code written
13:01:44 <SrPx> Cale: I'm confused, is there a fundamental difference between those "feature-wise"? Aren't they equivalent? 
13:01:45 <Cale> maerwald: That's one, for sure.
13:01:48 <quchen> dmj`: Microsoft doesn't develop Haskell. They pay a research position for SPJ so he can do things that benefit Microsoft, and him doing Haskell happens to do that.
13:02:01 <Cale> SrPx: "those"?
13:02:28 <SrPx> Cale: ah nevermind I'm not sure I understand this ;(
13:02:50 <hodapp> borklaser: C rules the hardware in the same sense that electrons, transistors, and semiconductors rule the hardware.
13:02:59 <hodapp> borklaser: Only in certain cases do you actually need to work at that level.
13:03:00 <Cale> SrPx: Sorry, I just didn't understand which part of the conversation you were referring to, since there are a bunch of threads going on here.
13:03:07 <Cale> SrPx: Pronouns are tricky
13:03:15 <SrPx> yep let the things calm down a little bit
13:03:21 <johnw> maerwald: I hope that by "running programs" you include merely type-checking them :)
13:03:44 <Cale> borklaser: Now that LLVM exists, I'm not sure there's any particular project I'd actually start using C in.
13:03:44 <dolio> Why would anyone include that?
13:04:02 <hodapp> Cale: Have you worked with LLVM much? I've heard its Haskell bindings are quite nice.
13:04:11 <johnw> dolio: in order to determine language death
13:04:23 <dmj`> quchen: yea, indirectly helps. No money, no research, no haskell. Some languages are created solely to solve industry problems.
13:04:24 <quchen> Cale: How is LLVM an alternative to C? Aren't they completely different languages?
13:04:35 <Cale> quchen: They're both compiler target languages ;)
13:04:35 <SrPx> Cale: how? You wouldn't write LLVM by hand right?
13:04:46 <hodapp> SrPx: I sure avoid writing C by hand.
13:04:47 <quchen> Cale: Hehe, careful where you say that sort of thing ;-)
13:04:47 <koala_man> you wouldn't write C by hand either
13:04:57 <hodapp> I still have to, of course, but not nearly as much.
13:05:10 <hodapp> mostly just glue, wrappers, and initialization.
13:05:11 <SrPx> you wouldn't? What if you need to manually tune the performance, the memory layout etc?
13:05:19 <uwap> :t forkIO
13:05:20 <lambdabot> Not in scope: ‚ÄòforkIO‚Äô
13:05:32 <quchen> :: IO () -> IO ThreadId
13:05:49 <hodapp> SrPx: Then write that part by hand. It will almost never be the entire program.
13:06:04 <Cale> SrPx: If I care about fine-grained performance at that level so much, I'd usually much rather write a program in a language like Haskell which wrote the low-level program for me.
13:06:13 <uwap> is there a forkMonadIO :: MonadIO m => m () -> m ThreadId?
13:06:20 <Cale> SrPx: e.g. see FFTW for a great example of this
13:06:22 <hodapp> SrPx: or, do what I do, and hand-write 0.5% of it in C, and let the other 99.5% of it be modeled in an EDSL like Ivory which brings you some of Haskell's abstraction, just not all of it
13:06:33 <johnw> uwap: you can use monad-control to do that
13:06:34 <quchen> uwap: I haven't seen that anywhere, no
13:06:37 <Cale> It's an O'Caml program which emits C programs for computing fast Fourier transforms.
13:06:41 <johnw> uwap: see liftBaseDiscard
13:06:43 <SrPx> lgmt
13:06:45 <borklaser> hodapp: if youre a typical programmer (software), no
13:06:52 <johnw> as in: liftBaseDiscard fork $ do ...
13:07:04 <hodapp> borklaser: Do I look like someone who gives a rat's ass what a "typical" programmer does?
13:07:11 <borklaser> that level is kind of necessary for electeng and has been for about 3-4 decades
13:07:37 <hodapp> borklaser: Yes, I know. Electrical engineering is my degree.
13:07:47 <quchen> Cale: That begs the question what a compiler is. That program sounds like it compiles OCaml (or a DSL via OCaml) to C.
13:07:52 <uwap> johnw, oh. that looks good
13:08:01 <hodapp> Cale: FFTW is written that way? That's neat, I was not aware of that.
13:08:08 * hackagebot yesod-transloadit 0.2.1.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.2.1.0 (boblong)
13:08:13 <borklaser> hodapp: It's still a necessary level for your field, whether you like it or not
13:08:19 <hodapp> borklaser: What is a necessary level?
13:08:25 <borklaser> low-level
13:08:27 <borklaser> duh
13:08:30 <mauke> didn't djb beat FFTW using hand-written code?
13:08:36 <SrPx> hodapp: hm interesting
13:08:45 <borklaser> an intimate level with the hardware -- which C grants
13:08:47 <Cale> quchen: It doesn't exactly compile OCaml to C, it basically compiles integers (FFT size) to C programs for computing FFTs
13:09:17 <borklaser> maybe rust'll get big and you electeng guys can formally switch to that, but for now, most of you are still predominately using C
13:09:31 <hodapp> borklaser: have you paid attention to anything I just said about my workflow?
13:09:36 <quchen> I'm not using C *at all*.
13:09:38 <Cale> (in a somewhat brute-forcey way, trying many possible options and finding out what runs best on the given platform by testing)
13:09:43 <quchen> I use programs using opcodes.
13:09:59 <quchen> C is something that we can translate to opcodes.
13:10:01 <quchen> I don't.
13:10:17 <hodapp> borklaser: yes, I'm using C, no, I am not writing the majority of it by hand, but rather generating it from a higher-level description that happens to be written in Haskell and also happens to allow me to interface fairly readily with what low-level functionality is needed.
13:10:34 <Cale> borklaser: It's often pretty nice to just write high level programs in Haskell or something which, when run, emit programs to run on embedded hardware.
13:11:00 <hodapp> Cale: some of the work with modeling LLVM behavior in Coq looks interesting too.
13:11:07 <hodapp> Cale: were you the one who pointed me to that?
13:11:21 <Cale> uhhh... I don't think so for that :)
13:11:41 <borklaser> hodapp: well, thats good then. it still dominates your field, as of now, regardless
13:11:52 <hodapp> Cale: http://www.cis.upenn.edu/~stevez/vellvm/
13:12:02 <hodapp> borklaser: what exactly is your point here?
13:12:12 <hodapp> borklaser: besides trying to lecture me on my old field.
13:12:23 <quchen> hodapp: You're no true Scotsman.
13:12:33 <hodapp> quchen: I'm not any kind of Scotsman :(
13:12:57 <borklaser> hodapp: Not a lecture
13:13:00 <hodapp> more of a... Franco-Kraut-Dutch-Brit.
13:13:06 <Cale> borklaser: Yeah, the question is: is that actually a good thing? Being dominant isn't necessarily an indication that something is even a good approach. There are a lot of factors which contribute to popularity of a language, and the quality of the resulting software and the relative amount of effort spent on maintenance aren't even necessarily the biggest ones.
13:13:31 <borklaser> "borklaser: Only in certain cases do you actually need to work at that level."
13:13:33 <borklaser> ^ that
13:14:12 <maerwald> does anyone know what this argument was about without scrolling the chat?
13:14:17 <maerwald> ...
13:14:19 <dolio> What is the point of this conversation, other than to be inflammatory?
13:14:20 <borklaser> Those "certain cases" are still very prevalent, I'd say, hence C's popularity to this day; that's all
13:14:32 <borklaser> not an argument (at least I didn't interpret it as such)
13:14:48 <maerwald> then it's sort of a random statement I guess
13:14:57 <borklaser> yeah
13:15:18 <hodapp> borklaser: yes, those 'certain cases' indeed exist.
13:18:31 <zmbmartin> Is there a way in haskell to set a method to something so you can type check the file but that method is todo?
13:18:43 <Cale> zmbmartin: undefined ?
13:18:44 <zmbmartin> Kind of like skipping writing the method for the time being.
13:18:45 <hodapp> zmbmartin: you can use 'undefined' I suppose.
13:18:46 <slack1256> type holes?
13:18:51 <eds> I get an error when I make my 'data Expr' an instance of Data, Line 44. Code and error: http://lpaste.net/136444. Though the error says No instance for (Typeable a) :/ Uhh compiler line 41. What am I missing here?
13:19:05 <dmj`> what Cale said
13:19:15 <Cale> and yeah, typed holes are often useful for that sort of thing, it's like using undefined, but the compiler will tell you what type of thing you need to fill in there
13:20:48 <zmbmartin> Thanks!
13:22:19 <Cale> eds: hmm
13:24:08 <Cale> deriving instance Typeable a => (Expr a)
13:24:21 <Cale> Did you mean to write  deriving instance Typeable a => Typeable (Expr a) ?
13:25:13 <Cale> (there are issues deriving the instance of Data regardless, I don't think that's really supposed to work for GADTs)
13:25:39 <Cale> eds: I'm surprised that you didn't get a complaint like:
13:25:48 <Cale> Expected a constraint, but ‚ÄòExpr a‚Äô has kind ‚Äò*‚Äô
13:26:11 <Cale> Might be a bug in whatever version of GHC you're using
13:27:00 <eds> Yeah my bad. that got rid of typeable error. But the Error with instance of Data still exists.
13:27:04 <arkeet> zmbmartin: you can also use a hole, put _
13:27:08 <arkeet> and use -fdefer-typed-holes
13:27:28 <Cale> eds: Yeah, there're a bunch of tricky things about trying to write a Data instance for this type
13:27:43 <eds> cale: I have KindSignatures enabled. That is why it might not have shown Expr a has kind *
13:27:49 <Cale> ... if it's even possible
13:28:02 <arkeet> zmbmartin: this has the advantage that you can't forget about them when you're finished and remove that flag
13:28:03 <eds> GHC version is 7.10
13:28:13 <Cale> hmm, yeah, I'm on 7.10.1 as well
13:28:21 <eds> ahh I see.
13:28:49 <eds> they don't work with GADTs. 
13:29:23 <Cale> eds: Yeah, it'll try to write the instance anyway now, but yeah, it's not really designed to work with GADTs
13:30:15 <eds> ahh. Without that I won't be able to make Expr an instance of Genprog
13:30:23 <eds> which makes me sad
13:31:05 <ttt_fff> is there a shorter way to write the following:
13:31:09 <ttt_fff> logPopFrameV la = la >>= \x -> logPopFrame >> return x 
13:31:16 <ttt_fff> logPopFrameV :: Log a -> Log a
13:31:53 <eds> if it's even possible, has anyone tried to make it work with GADTs in the past? Is there a post/article/example on it?
13:31:56 <eds> cale
13:33:27 <Cale> hmm
13:33:35 <Cale> I don't know of anything in particular about that
13:33:53 <eds> np thanks :)
13:33:54 <Denommus> :t la >>= \x -> undefined >> return x
13:33:55 <lambdabot>     Not in scope: ‚Äòla‚Äô
13:33:55 <lambdabot>     Perhaps you meant one of these:
13:33:55 <lambdabot>       ‚Äòa‚Äô (imported from Debug.SimpleReflect),
13:34:02 <Denommus> :t undefined >>= \x -> undefined >> return x
13:34:03 <lambdabot> Monad m => m b
13:34:57 <uwap> > undefined >>= \x -> undefined >> return x
13:34:59 <lambdabot>      No instance for (Show (m0 b0))
13:34:59 <lambdabot>        arising from a use of ‚Äòshow_M329410548369480511526273‚Äô
13:34:59 <lambdabot>      The type variables ‚Äòm0‚Äô, ‚Äòb0‚Äô are ambiguous
13:35:19 <uwap> hmm :D I wonder what it outputs. undefined I guess?
13:35:46 <Cale> eds: It seems like an obvious direction for some future research...
13:37:06 <Denommus> uwap: I'm using undefined as a placeholder
13:37:09 <eds> hmm. should I submit a ticket?
13:37:57 <uwap> Denommus, yeah. sure.
13:38:20 <Cale> eds: Well, it's quite likely that if it's possible to do, it will require a re-work of the Data class and its operations (maybe not, but it seems likely to me)
13:38:26 <Denommus> ttt_fff: you could probably write it as logPopFrameV la = (logPopFrame >>) . return =<< la
13:38:39 <Denommus> ttt_fff: but I think the original is much more readable
13:38:47 <ttt_fff> Denommus: that is simultaneously (1) what I asked for and (2) hideous
13:38:51 <cow_2001> :t Either a a -> a
13:38:53 <lambdabot> parse error on input ‚Äò->‚Äô
13:38:55 <cow_2001> err
13:38:57 <cow_2001> oops
13:39:00 <Cale> eds: I don't think anyone's likely to be able to do anything with the ticket for now. Maybe you could ask them to add a warning that it doesn't work with GADTs
13:39:02 <Denommus> ttt_fff: you could also use the do syntax :P
13:39:09 <cow_2001> what's theh opposite of :t?
13:39:10 <ttt_fff> Denommus: do syntax ends up being 3 lines
13:39:19 <ttt_fff> Denommus: either way, thanks for your suggestion, I learned something new
13:39:25 <Denommus> logPopFrameV la = do { x <- la; logPopFrame; return x }
13:39:51 <Cale> eds: Trying to derive GHC's Generic class produces an error which complains about the non-vanilla constructors of the type.
13:40:05 <Cale> eds: So, maybe something similar would be in order for Data
13:40:07 <cow_2001> >hoogle Either a a -> a
13:40:30 <Cale> cow_2001: @djinn ?
13:40:37 <Cale> @djinn Either a a -> a
13:40:38 <lambdabot> f a =
13:40:38 <lambdabot>     case a of
13:40:38 <lambdabot>     Left b -> b
13:40:38 <lambdabot>     Right c -> c
13:40:56 <eds> cale: ohh. I'll mention both of those things.
13:40:58 <Cale> :t either id id
13:40:59 <lambdabot> Either c c -> c
13:42:13 <lspitzner> :exf "Either a a -> a"
13:42:13 <exferenceBot> either (\ g -> g) (\ i -> i)
13:42:59 <Denommus> either id id :P
13:43:25 <cow_2001> so there's no existing function to unpack an Either
13:44:00 <Denommus> cow_2001: it makes no sense to talk about "unpack" an Either, just like it makes no sense to talk about "unpack" a list
13:44:13 <cow_2001> yeah
13:44:40 <Denommus> cow_2001: but you could do it by forcing an error in case it is wrong, or convert it to a Maybe
13:44:44 <SrPx> Does anyone know if there is any implementation of an inferencer for elementary affine logic I can download? In haskell or whatever? http://www.cs.unibo.it/~martini/papers-to-ftp/EA-typing.pdf
13:44:51 <Denommus> let fromRight (Right x) = x
13:44:56 <Denommus> @let fromRight (Right x) = x
13:44:57 <lambdabot>  Defined.
13:45:03 <Denommus> > fromRight (Right 1)
13:45:05 <lambdabot>  1
13:45:09 <Denommus> > fromRight (Left "a")
13:45:11 <lambdabot>  *Exception: L.hs:145:1-23: Non-exhaustive patterns in function fromRight
13:45:45 <Denommus> @let fromRightMaybe (Right x) = Just x
13:45:46 <lambdabot>  Defined.
13:45:57 <Denommus> @let fromRightMaybe (Left x) = Nothing
13:45:58 <lambdabot>  Defined.
13:46:10 <Denommus> > fromRightMaybe (Right 1)
13:46:11 <lambdabot>  Just 1
13:46:16 <Denommus> > fromRightMaybe (Left "a")
13:46:18 <lambdabot>  Nothing
13:46:18 <uwap> @let fromRightDefault (Right x) _ = x
13:46:19 <lambdabot>  Defined.
13:46:28 <uwap> @let fromRightDefault (Left _) x = x
13:46:29 <lambdabot>  Defined.
13:46:35 <uwap> fromRightDefault (Left 10) 11
13:46:39 <uwap> > fromRightDefault (Left 10) 11
13:46:40 <lambdabot>  11
13:46:44 <uwap> Denommus, :P
13:46:49 <Denommus> uwap: that function exists and is called "either"
13:46:50 <josephle> :t either x Nothing -- just use the elimination form, people :P
13:46:51 <lambdabot>     Couldn't match expected type ‚Äòa -> c‚Äô with actual type ‚ÄòExpr‚Äô
13:46:52 <lambdabot>     In the first argument of ‚Äòeither‚Äô, namely ‚Äòx‚Äô
13:46:52 <lambdabot>     In the expression: either x Nothing
13:46:58 <josephle> aww
13:47:02 <uwap> :t either
13:47:03 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:47:13 <uwap> Denommus, not exactly
13:47:14 <uwap> :P
13:47:15 <josephle> ahhh
13:47:28 <Denommus> josephle: I am aware of either, I was just showing how to do it "from scratch"
13:47:32 <josephle> :t either Just (const Nothing)
13:47:33 <lambdabot> Either a b -> Maybe a
13:47:45 <josephle> Denommus, ah, ok
13:49:12 <dmj`> marlow accepted the pull, `forConcurrently = flip mapConcurrently` is going into async
13:49:37 <quchen> Hm.
13:50:00 <dmj`> quchen: it's a play on forM and mapM 
13:50:11 <quchen> Sure.
13:52:29 <johnw> dmj`: now get it into lifted-async :)
13:53:58 <eds> cale: would this work - http://stackoverflow.com/questions/12573669/how-can-i-derive-a-data-instance-for-a-gadt-in-haskell
13:55:44 <sailorswift> Are there any tutorials for stack yet? For dummies? :)
13:56:44 <dmj`> johnw: that's the plan! could have bypassed async and just put it into lifted-async directly, still debating that one
13:56:48 <ChristianS> sailorswift: it's supposed to be so simple that you don't need any tutorials, i think
14:01:20 <Cale> eds: Possibly something like that could work, but you'll have to write the instances by hand, I think.
14:01:27 <elfen> hi all, another round of silly questions, paste's here  https://dpaste.de/wTfd; in short, all I want is a function with a constructor type. can it be done with data kinds or something?
14:02:04 <eds> I see. I'll try
14:02:44 <Cale> elfen: The problem with your code is that newtype data constructors are required to have a field.
14:03:01 <Cale> elfen: (every newtype must define exactly one constructor with one field)
14:03:17 <elfen> oh, ok, thanks
14:03:32 <Cale> Your SendableEvent has a single data constructor (named Event, but having no relation to the type which is also called Event), but it has no field.
14:03:58 <elfen> ok, lets forget about SendableEvent for a second
14:04:01 <dmj`> johnw: https://github.com/maoe/lifted-async/pull/18
14:04:13 <ttt_fff_> damn it, I need this "strinification" # macro to work in haskell; so I can do things like "DEBUG x" => addText "x" >> render x
14:04:19 <elfen> what about constructor type, is it possible?
14:04:22 <Cale> elfen: Oh, I suppose after that, you have the problem that you're writing a function which is supposed to take a value of type 'Ping
14:04:23 <ttt_fff_> is there anyway ot get stringification to work?
14:04:37 <Cale> But 'Ping doesn't have kind *, it has kind Event
14:04:46 <Cale> and so it's a kind mismatch for (->)
14:04:50 <Cale> :k (->)
14:04:51 <lambdabot> * -> * -> *
14:04:57 <elfen> Cale, yeah, that's what i'm talking about
14:05:08 <Cale> elfen: What do you even want that to mean?
14:05:36 <Cale> Even if 'Ping were allowed there, it's a type with no values, so you'd never be able to apply the function mkSendable
14:05:43 <elfen> Cale, mkSendable would compile only if Event is constructed be Ping
14:05:53 <elfen> s/be/by/
14:06:03 <Cale> Ah, no, that's not what that means at all
14:06:14 <Cale> and you can't do that.
14:06:26 <voidzero> stop!
14:06:28 <voidzero> hammertime.
14:06:37 <voidzero> did i get that right this time?
14:06:40 <Cale> What?
14:06:54 <voidzero> oh, no, it was "can't touch this" not "can't do that".
14:07:01 <voidzero> I'm making cheesy jokes. I'll take them elsewhere.
14:07:11 <elfen> xD
14:07:34 <elfen> but DataKinds.. I hope they can do stuff like this
14:07:45 <elfen> some magic extension and puf
14:07:50 <Cale> elfen: Having the compiler be able to check that any given Bool is True for instance, is pretty tricky.
14:08:16 <Cale> elfen: You might end up having to do arbitrary amounts of computation and/or proving arbitrary theorems at compile time.
14:09:18 <elfen> Cale, well, it seems so at the end
14:09:30 <elfen> thanks :(
14:09:32 <Cale> With dependent types, you could have a type something like  mkSendable :: (x :: Event) -> (x = Ping) -> ...
14:09:39 <Javran> @hoogle MonadPlus m => m Bool -> m ()
14:09:40 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
14:09:40 <lambdabot> Data.Generics.Aliases mkR :: (MonadPlus m, Typeable a, Typeable b) => m b -> m a
14:09:40 <lambdabot> GHC.Conc.Sync always :: STM Bool -> STM ()
14:10:05 <elfen> mm, sounds interesting
14:10:19 <Cale> elfen: Which would require the user to be able to provide a proof
14:10:21 <Javran> I can do "True <- m" in do notation, not sure if this is idomatic, or is there a function I can use?
14:10:41 <Cale> elfen: Of course, it's a little silly in this case, because why have an argument there at all if there's only one valid value which can be supplied? :)
14:11:09 <elfen> Cale, here's some suggested solution data EventType = Ping | Pong; data Event (a::EventType) = Event; mkSendable :: Event 'Ping -> Event a
14:11:16 <Cale> elfen: But more generally, once you have types depending on values, you can have a type for evidence that two values are equal.
14:12:24 <elfen> but i can't tell if this make any sense
14:12:25 <Cale> elfen: That'll "work", but I'm not sure exactly what you're going to do with it
14:13:05 <elfen> i'm isn't sure either 
14:13:57 <t7> :t mappend
14:13:58 <lambdabot> Monoid a => a -> a -> a
14:14:24 <t7> is a monoid the simplest thing where (a + (b + c)) = (a + b) + c) and a + 0 = a ?
14:14:48 <monochrom> I think so. monoid says nothing more than that.
14:15:02 <monochrom> unless I misinterpret your "simplest"
14:15:07 <t7> look at me using type classes for my own structure :D
14:15:38 <monochrom> I think ironically, there is a sense of "simplest" such that "a field is simpler than a monoid for satisfying those laws"
14:15:50 <augur> hmm. if ive got a library w/ a hierarchical dir structure, how do i get ghci to use it?
14:16:00 <t7> no wait my things doesnt satisfy this :D
14:16:11 <augur> ive got a cabal setup going for it, but cabal exec with GHCi doesnt work
14:16:37 <dcoutts> augur: can you just use cabal repl?
14:16:46 <augur> oh right! cabal repl!
14:16:58 <zipper> Which library exposes the GHC API?
14:17:02 <augur> <3 thank you dcoutts
14:17:18 <dcoutts> zipper: 
14:17:21 <dcoutts> oops,
14:17:24 <dcoutts> zipper: 'ghc'
14:17:36 <zipper> dcoutts: Thanks.
14:17:40 <zipper> :t parser
14:17:41 <lambdabot> Not in scope: ‚Äòparser‚Äô
14:19:12 <SrPx> You are programming an editor, "type Sexp = Tree String". This editor can be rendered into a on-screen tree: "type RenderedSexp = Tree (V2 Int, String)". Each node of RenderedSexp corresponds to a node of Sexp. When the user clicks on the node of RenderedSexp, you want to focus on the corresponding node of Sexp. How would you do that in Hskell?
14:19:19 <zipper> dcoutts: Are you sure there is a library called ghc? There isn't on hackage.
14:19:34 <dcoutts> zipper: it's not on hackage, it's installed with ghc
14:19:41 <Javran> is there a "whenM"? something like whenM m = m >>= (`unless` mzero)
14:19:49 <dcoutts> zipper: see: ghc-pkg list ghc
14:20:10 <zipper> dcoutts: I want to see it's modules. Specifically.
14:20:14 <zipper> Okay on it.
14:20:19 <Clint> Javran: yes
14:20:20 <dcoutts> zipper: the docs for it are on the ghc site, next to the ghc user manual
14:21:00 <dmj`> @hoogle whenM
14:21:00 <lambdabot> No results found
14:21:19 <Javran> maybe I should call it guardM?
14:21:42 <Javran> for now I just do "True <- m" in a do notation
14:22:13 <Javran> btw does "fail" in MonadPlus result in mzero?
14:24:06 <Javran> never mind, I feel stupid now
14:24:08 <quchen> Javran: fail and MonadPlus are independent of each other.
14:24:24 <quchen> Javran: For *most* monads that have a sensible fail, it is equal to `const mzero` though.
14:24:44 <quchen> STM is the only exception I know here.
14:25:20 <Javran> I think by falling a pattern matching I'm using fail implicitly, by (`unless` mzero) I
14:25:26 <Javran> am using MonadPlus
14:27:11 <ChristianS> Javran: there is a whenM in Control.Conditional
14:29:36 <Javran> ChristianS: found it, thanks!
14:32:51 <t7> how to construct NaN
14:32:53 <t7> ?
14:33:00 <Javran> 0/0 ?
14:33:08 <Javran> > 0/0
14:33:12 <lambdabot>  NaN
14:35:49 <ttt_fff_> is there a short hand for "sequence $ zipWith foo lst1 lst2" ?
14:36:26 <ttt_fff_> zipwithM
14:36:40 <xintron> Why is it that [1,3..10] works but not [1,2,3..10]?
14:37:04 <hpc> :t enumFromThenTo
14:37:05 <lambdabot> Enum a => a -> a -> a -> [a]
14:37:13 <maerwald> > [1,2] ++ [3..10]
14:37:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:38:03 <maerwald> seems it cannot parse it
14:38:22 <quchen> xintron: The syntax is pretty rigid.
14:38:24 <Javran> xintron: [1,3..10] is a syntactic sugar for enumFromThenTo, but there is no syntactic support for [1,2,3..10]
14:38:56 <xintron> Ah, makes sense now
14:39:16 <maerwald> Javran: but it could convert it to that ++ thing
14:39:27 <maerwald> maybe file a feature request
14:39:37 <danza> that expression is confusing
14:39:40 <maerwald> but it's pretty minor anyway
14:39:59 <danza> what happens if i write [1,2,5...10] ?
14:40:04 <quchen> maerwald: It's not minor at all! A change like that is quite a thing.
14:40:07 <danza> the first two are all that is needed
14:40:14 <Javran> yeah, thinking about the exact question
14:40:15 <maerwald> quchen: you mean it's too confusing?
14:40:28 <silver> > [1,2,5...10]
14:40:29 <lambdabot>      Could not deduce (Num (Over p f c0 c0 a b))
14:40:29 <lambdabot>      from the context (Num (Over p f s t a b),
14:40:29 <lambdabot>                        Num (Over p f c c a b),
14:40:36 <silver> :(
14:40:39 <quchen> maerwald: Keep in mind that you're changing the language standard adding such a thing. You'd have to prove it adds significant value to the users in order for it to become an extension even.
14:40:53 <danza> and it doesn't
14:40:53 <maerwald> I don't think it does add much
14:40:53 <Javran> wait, what?
14:41:04 <quchen> maerwald: Syntactically it's tiny, yes, but that's just the very surface.
14:41:05 <Javran> :t (...)
14:41:05 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
14:41:06 <silver> > [1,2,5..10]
14:41:07 <lambdabot>  <hint>:1:7: parse error on input ‚Äò..‚Äô
14:41:41 <maerwald> but naturally I would expect something like [9,3,5..10] == [9,3] ++ [5..10]
14:41:42 <Javran> ah, (...) is a vaild symbol
14:41:59 <quchen> maerwald: Why not [9] ++ [3,5..10]?
14:42:22 <maerwald> or even arbitrary [1,2,5..10,3,2,2..7]
14:42:53 <maerwald> quchen: I find the first form more clear
14:43:18 <quchen> That's not a very compelling argument.
14:43:29 <maerwald> I don't see an argument for the opposite either
14:44:00 <silver> haskell should lookup https://oeis.org/
14:44:33 <quchen> You can't do that in non-IO code.
14:45:13 <silver> offline immutable database then?
14:45:18 <quchen> You can't do that in non-IO code.
14:45:28 <dyoung_> > let (...) = enumFromTo in (1 ... 10)
14:45:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:45:32 <dyoung_> hm
14:45:36 <quchen> Unless by offline you mean "compiled into the executable".
14:45:41 <silver> yeah
14:45:43 <quchen> Then that would be possible, and also a terrible idea :-√æ
14:45:48 <silver> :)
14:47:40 <dyoung_> > let (...) = enumFromTo in map (...10) [1..8]
14:47:41 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
14:48:12 <dyoung_> that's kinda fun
14:52:01 <Javran> dyoung_: you can use RebindableSyntax to make enumFromTo do whatever you want
14:52:16 <Javran> https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html
14:52:58 <Javran> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
14:53:13 <Javran> oops, should be OverloadedList, not RebindableSyntax
14:53:27 <dyoung_> Javran: You can't change the meaning of [..] though, I think
14:53:44 <dyoung_> I'm just thinking that what I did was nicer than "map (`enumFromTo` 10) [1..8]"
14:54:09 <Javran> dyoung_: well, actually you can :) just follow my last link
14:56:11 <l3france> hi, is there a reason why the OpenGL API pages are not on haskell.org/hoogle ? (and yet still show up in the search results)
14:56:42 <dyoung_> Javran: yeah, but I don't think you can do a section with it
14:56:56 <dyoung_> which is why (...) = enumFromTo seemed interesting
14:58:08 <quchen> l3france: Which packages Hoogle indexes and which ones it does not is a bit mysterious.
14:58:20 <quchen> l3france: Consider using Hayoo if you're not happy with the results.
14:58:32 <quchen> (I use them both all the time.)
15:00:48 <kadoban> I tend to use the hoogle on stackage's website
15:03:20 <l3france> quchen: kadoban I'll check those out, thanks!
15:10:31 <Haskellfant> there is also the new hoogle that indexes all of stackage http://hoogle.haskell.org/
15:10:47 <Haskellfant> sadly type search doesn't work atm, but if you just want to search for names it's great
15:13:30 <Javran> I think the search bar in http://www.stackage.org/ also do
15:14:43 <Javran> I find the old Hoogle search link from FPComplete redirects to it
15:28:14 * hackagebot acme-operators 0.2.0.0 - Operators of base, all in one place!  http://hackage.haskell.org/package/acme-operators-0.2.0.0 (phadej)
15:35:00 <broma0> Can anyone help out with a list-zipper question?
15:35:57 <rowanblush> Go for it, broma0.
15:39:21 <erikd> is there a tool for stripping an lhs file back to plain hs?
15:39:34 <broma0> rowanblush: I'm struggling with trying to come up with a way to model the selection of a subset of elements in the zipper. My first though was (Zip [a] [a] [a]), but im wondering if theres an accepted way of doing this
15:40:19 <broma0> an issue with (Zip [a] [a] [a]) is that that middle list should have O(1) insert/delete at both ends
15:43:48 <rowanblush> erikd: You could try github.com/ghc/ghc/blob/master/utils/unlit
15:44:20 <erikd> thanks rowanblush 
15:44:21 <rowanblush> broma0: So you want a filter function on zippers?
15:44:28 <Hijiri> broma0: Seq will give you O(1) insert/delete at the ends
15:44:58 <Hijiri> although maybe it would feel odd to have a more complicated data structure in the zipper for a list
15:45:32 <rowanblush> Oh you want to be "focusing" on a subsequence? Hm.
15:46:01 <Hijiri> I think there are simpler dequeues out there, but I don't know much about them
15:46:12 <broma0> rowanblush: not just a filter, more of a selection that can grow and shrink.. think of a text editor where the text is a zipper - how can I model text selection? 
15:47:10 <broma0> rowanblush: yes, exactly.
15:47:22 <Hijiri> broma0: I think ropes are popular for representing text editor buffers
15:47:40 <Hijiri> I don't know anything about those either, though
15:48:18 <rowanblush> Yeah I think Hijiri has basically called it, a zipper with a Seq or some sort of fancy rope.
15:50:04 <whiteline> a rope zipper is perfectly doable isn't it?
15:50:25 <Welkin> a rope zipper?
15:50:51 <mrmyers> It's a bit difficult to undo. You're better off just using buttons.
15:51:01 <broma0> im looking into ropes now.. i never have before
15:51:21 <rowanblush> mrmyers: Ha!
15:51:33 <whiteline> Welkin: yes, a zipper over a rope
15:51:37 <whiteline> it's just a tree after all
15:51:49 <mrmyers> #haskell-bdsm
15:52:19 <whiteline> ha
15:52:31 <Welkin> oh, I didn't know what a rope was
15:52:42 <broma0> know of any good documentation on the rope data structure?
15:52:50 <rowanblush> #haskell-bdsm: I'd join later, but I'm a bit tied up at the moment.
15:53:22 <Welkin> broma0: https://hackage.haskell.org/package/rope
15:53:39 <broma0> rowanblush: haha!
15:53:46 <broma0> Welkin: thanks
15:56:59 <Welkin> broma0: http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/CedarRope/rope-paper.pdf
16:04:52 <broma0> Welkin: ropes are cool
16:07:48 <SrPx> So a Rope is a binary tree of strings? data Rope = Concat Rope Rope | String String ?
16:17:49 <Hafydd> These metaphors are getting out of control.
16:21:44 <Welkin> Hafydd: put them under control with git
16:22:21 <Guest44711> Hi guys, is this a good channel for a complete beginner to ask questions or is there another channel
16:22:43 <rowanblush> Guest44711: Go for it.
16:22:57 <kadoban> Guest44711: All skill levels welcome
16:23:05 <adarqui> Guest44711: the channel is very beginner friendly, but, there's also #haskell-beginner
16:23:12 <adarqui> gr, beginners
16:24:11 <rowanblush> Don't growl at the beginners, adarqui. ;-)
16:24:27 <Hafydd> git is good at sensible metaphors, like this picture of a giant mutant Linus Torvalds eating whole trees, which represents distributed version control: http://s3.amazonaws.com/bundlr-app-production/content_images/images/large/5364111ab7c27a00020000bb/git-logo.png
16:25:10 <Guest44711> I have a text file with multiple lines defining an adjacency matrix of a graph. I'd like to read in one line at a time and build the graph with a list of the edges
16:26:51 <Welkin> what?
16:26:55 <rowanblush> Hafydd: What a beautiful mental image you have painted.
16:26:56 <Welkin> that looks like a tree monster
16:27:02 <Welkin> he isn't finnish enough to be linus
16:27:10 <Guest44711> I can read in the contents no problem, I want to take a line imagine it's the first line in the file so matches the node (1): 0 1 0 1 and  the edges would be [(1,2), (1,4)]
16:27:11 <Welkin> and he isn't saying "fuck" enough
16:27:34 <Hafydd> What is a tree monster? What is its systematic placement?
16:28:00 <hpc> it's the topological explanation of version control
16:28:04 <hpc> the tree monster is a torus
16:28:22 <Hafydd> Is the hole its digestive tract?
16:28:27 <hpc> no comment
16:28:39 <rowanblush> Guest44711: So you've used `getContents` to get the whole file, and your question is how to split it into lines?
16:29:14 <Guest44711> nope, i have the lines, I'd like to iterate over chars in that line and with a counter track which column == 1
16:30:45 <Hafydd> It sounds like you want to zipWith the non-space characters in a string with [1..].
16:31:12 <rowanblush> Got it. So the elements are position encoded, separated by whitespace.
16:31:17 <glguy> > (elemIndices "1" . words) "0 1 0 1 1"
16:31:18 <lambdabot>  [1,3,4]
16:31:48 <rowanblush> Socrates lies dead at my feet.
16:32:02 <glguy> There's lots of stuff in http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-List.html for working through lists
16:32:03 <Welkin> :t elemIndices
16:32:04 <lambdabot> Eq a => a -> [a] -> [Int]
16:32:07 <marchelzo_> > elemIndices '1' "01011"
16:32:08 <lambdabot>  [1,3,4]
16:32:14 <marchelzo_> Cool
16:32:33 <glguy> rowanblush: no worries at all. If the guest would like to work through writing it out manually it's still an option.
16:32:57 <Guest44711> cool, that's a good way to get the columns
16:33:15 <Guest44711> I need to iterate over the file and get the row number nuow, then combine the two at each step
16:33:42 <mniip> :t findIndices
16:33:43 <lambdabot> (a -> Bool) -> [a] -> [Int]
16:33:50 <Hafydd> It would be better to separate this computation from the impure act of reading from a file.
16:34:19 <Guest44711> Hafydd: by readingthe entire contents of the file first?
16:34:30 <Welkin> yes
16:34:50 <Welkin> create a pipeline of function
16:34:51 <Hafydd> Guest44711: the effect might not actually be that the whole file is read at once, because of "lazy I/O".
16:34:55 <Welkin> pure functions*
16:35:36 <Guest44711> Yeah I was reading about lazy I/O
16:37:09 <ReinH> Can someone remind me what the magic invocation is to add a remote repo source to the cabal.config file for a cabal package? I have remote-repo: http://whatever but no dice
16:37:31 <ReinH> I can't find any docs on it either
16:38:43 <Welkin> cabal sandbox --add-source
16:38:44 <Welkin> I think
16:39:12 <Welkin> er
16:39:14 <Welkin> no --
16:39:48 <Welkin> ReinH: why not just git clone the repo to /some/dir/ then add-source /some/dir/ ?
16:39:50 <ReinH> Noi
16:40:01 <ReinH> Welkin: Well, because I don't want to...
16:40:07 <ReinH> I want to install it from the remote hackage server
16:42:28 <ReinH> Oh, I had the syntax wrong. It's remote-repo: name:http://url
16:43:40 <rowanblush> Can I ask how you figured that out? Just for my own edification.
16:44:23 <ReinH> rowanblush: I looked at the entry in ~/.cabal/config
16:45:02 <ReinH> It doesn't appear to be documented otherwise
16:45:52 <rowanblush> Cool, thanks.
16:47:09 <creichert> ReinH: remote-repo: private-repo:http://url
16:47:19 <ReinH> creichert: yep
16:47:26 <creichert> ah :), missed that
16:47:30 <ReinH> thanks though!
17:02:18 <sebastianrkg> Is it possible to use the Tasty test framework inside a CmdArgs command-line application?
17:03:03 <sebastianrkg> Seems to blow up and give me the CmdArgs app's --help output once it encounters the defaultMain(WithIngredients) call from Tasty
17:08:20 <kristof> I was like at " map f xs `using` ParList rseq " and couldn't wrap my head around it
17:08:21 <lamefun> Is there a library for threaded tasks with progress report?
17:08:23 <kristof> *looking at
17:08:44 <kristof> "Doesn't map f xs just get evaluated?" And it doesn't. But only to head normal form.
17:09:05 <kristof> *weak head normal form. And then I realized that lazy evaluation is not just some hat trick.
17:10:46 <bitemyapp> kristof: hat trick? Does that mean it evaluated three times?
17:11:16 <bitemyapp> kristof: progress report sounds like codata
17:11:50 <kristof> bitemyapp: you are sometimes so esoteric it hurts
17:12:40 <bitemyapp> kristof: I live to make you suffer
17:12:56 <kristof> then you are doing a good job
17:13:13 <bitemyapp> I'm awesome like that
17:13:41 <bitemyapp> I wonder how many people know they can just import GHC.Stack (currentCallStack)
17:14:00 <bitemyapp> http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Stack.html#v:currentCallStack wish it was more structured though.
17:14:15 <Clint> neat
17:14:27 <bitemyapp> who wants to write a parser for the stacktrace format? :P
17:15:46 <kristof> bitemyapp: You don't work for fpcomplete now, do you? :P
17:19:08 <bitemyapp> kristof: no
17:19:17 <bitemyapp> but I'm very fond of what they do
17:43:20 * hackagebot yesod-sass 0.1.2.0 - A simple quasiquoter to include sass code in yesod  http://hackage.haskell.org/package/yesod-sass-0.1.2.0 (fgaray)
18:00:06 <mightybyte> What do people do when the haskell-src-exts parser fails because of CPP?
18:04:01 <orion> Does there exist a good way to simplify this code?: http://lpaste.net/6976060502648553472
18:05:13 <htebalaka> orion: you can probably pull out the liftIO's, though *maybe* that will effect strictness
18:06:15 <orion> htebalaka: I know I wrote "main = do ..." but I want to note that I am not in the IO monad.
18:06:24 <kadoban> Pulling out the liftIO implies to a reader that they're pretty related though ‚Ä¶ or maybe that's true but I don't know what most of that means.
18:10:02 <htebalaka> like this: main = liftIO $ do { x <- processX $!! foo ; return $!! foo }
18:12:17 <rowanblush> What's the point of line 3? Just to deepseq x?
18:12:51 <htebalaka> and you could factor out the bind with: let f <$!!> x = do { a <- x ; return $!! f a }, to get `liftIO $ id <$!!> processX $!! foo` (<$!>) already exists, so i'm surprised the deepseq version doesn't
18:14:02 <htebalaka> or `(id $!!) <$> (processX $!! foo)`, though i think that would be subtly different
18:14:51 <htebalaka> err: `liftIO $ (id $!!) <$> (processX $!! foo)`
18:15:17 <htebalaka> in regards to strictness that is
18:17:15 <orion> rowanblush: To force pending exceptions.
18:17:41 <orion> The issue is that since I'm not working in the IO monad, exceptions thrown by aeson don't get caught properly.
18:17:57 <boj> not sure how to repeat this, but yesterday i was building a project with stack.  even after completely removing .work-stack and the like, phantom traceM's continued to print out until i _rebooted_ and rebuilt my project.  any ideas?
18:18:51 <rowanblush> I think you can use force instead then, right?
18:19:33 <rowanblush> Something like x <- liftIO $ force <$> (processX $!! foo)
18:19:36 <rowanblush> Not sure if that type checks.
18:20:25 <orion> Oh, I forgot about `force'.
18:20:36 <lamefun> Is there a library for threaded tasks with progress report?
18:21:30 <lamefun> Or is it so easy to do that there are none?
18:22:04 <dmj`> lamefun: what do you mean by progress report? 
18:22:08 <orion> rowanblush: That won't typecheck because it's trying to evaluate IO X.
18:22:33 <lamefun> dmj`: whatever feeds the progress bar.
18:28:08 <dmj`> @package terminal-progress-bar
18:28:08 <lambdabot> http://hackage.haskell.org/package/terminal-progress-bar
18:30:08 <lamefun> dmj`: I don't want a progress bar implementation, I'm looking for a framework for tasks that feed it.
18:33:26 <dmj`> lamefun: when you download a file the header (content-length) will tell you what the expected size received is, from there you can just do (received/total * 100)
18:34:25 <fishythefish> Say I have a shell command `paste` that creates a pastebin/lpaste/whatever online, e.g. `echo foo | paste`. What's the best way to pipe a String to it from within Haskell?
18:36:14 <kadoban> fishythefish: putStr ?
18:37:12 <fishythefish> kadoban, that just writes to stdout?
18:37:20 <fishythefish> I want to invoke paste and pipe to it from within Haskell.
18:37:30 <geekosaur> it'd be hPutStrLn
18:37:49 <geekosaur> but you might be interested in http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:readProcessWithExitCode
18:37:56 <kadoban> fishythefish: Oh I misunderstood your goal possibly.
18:38:19 <fishythefish> geekosaur, ah, lovely.
18:38:21 <lethjakman> what is the {-# thing?
18:38:27 <fishythefish> I was mainly looking for a way to specify stdin for the process.
18:38:27 <lethjakman> {-# LANGUAGE OverloadedStrings     #-}
18:38:36 <geekosaur> lethjakman, it's a pragma
18:38:38 <fishythefish> lethjakman, that's a pragma.
18:38:52 <lethjakman> thank you! it was hard to google without knowing the name
18:39:33 <lethjakman> also, I tried to pass a data structure directly into a function the other day, and couldn't get it to work. but then I assigned it to a variable and passed the variable in and it worked. 
18:39:38 <lamefun> dmj`: but what about composing heterogeneous tasks (eg. download files, unzip, calculate checksums, check signatures, load images, etc.)
18:39:43 <lethjakman> does haskell do something to data structures when it's assigned to a variable?
18:39:53 <geekosaur> lethjakman, my guess is you needed parentheses
18:40:04 <Denommus`> hi
18:40:12 <Denommus`> is there a nice DSL-ish library for SQLite?
18:40:14 <kadoban> lethjakman: It's the same to haskell, as long as the syntax is correct.
18:40:31 <geekosaur> for example, `foo Just True` passes 2 parameters to foo, `foo (Just True)` passes one parameter
18:41:02 <lethjakman> that's it!
18:41:06 <geekosaur> remember, Haskell is functional, passing things that can behave as functions *by themselves* is perfectly sensible
18:41:06 <lethjakman> I was wondering why that was
18:41:14 <lethjakman> was it  just passing in the type? 
18:41:24 <geekosaur> just the constructor, likely
18:41:33 <geekosaur> I'd have to see the actual code to be sure
18:41:43 <lethjakman> it did
18:41:45 <lethjakman> thank you!
18:41:53 <lethjakman> that makes a lot more sense
18:47:51 <bitemyapp> dmj`: new BH release
18:48:22 * hackagebot bloodhound 0.7.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.7.0.0 (bitemyapp)
18:49:22 <bitemyapp> oh, there it goes.
18:49:22 <dmj`> bitemyapp: nice !
18:49:41 <bitemyapp> dmj`: query filter, new stackage release compat, and optimistic concurrency control.
18:49:53 <dmj`> lamefun: I dunno :/ that'd be quite a framework
18:50:09 <dmj`> bitemyapp: ah nice, I needed the query filter
18:50:17 <bitemyapp> lamefun: is that kinda like Async?
18:50:21 <bitemyapp> dmj`: well, there you go :)
18:50:36 <lethjakman> why does haskell compilation take so much longer than Go?
18:50:49 <lethjakman> just because the type system is more advanced?
18:51:47 <pacak> lethjakman: More optimizations?
18:52:01 <lethjakman> pacak: you mean in the finalized code?
18:52:19 <pacak> ghc does more optimizations
18:52:19 <dmj`> bitemyapp: perfect
18:52:25 <lethjakman> huh
18:52:26 <lethjakman> interesting
18:53:08 <bitemyapp> lethjakman: multi-pass compiler makes a big diff
18:53:38 <bitemyapp> inlining specifically adds a fair bitta time.
18:53:46 <lethjakman> what does that do in the long run?
18:53:54 <bitemyapp> lethjakman: our compiler doesn't have to be dumb.
18:54:14 <lethjakman> lol
18:54:23 <lethjakman> fair enough...
18:54:51 <lethjakman> I'm curious what exactly the speed difference is. it'd be hard to write a 1 to 1 comparison between the two though
18:54:53 <lamefun> Why does Go compiler have to be dumb?
18:55:07 <dmj`> lethjakman: the type system being more advanced provides more possibility for optimization
18:55:31 <lethjakman> hmm
18:56:02 <dmj`> lethjakman: and the compilation pipeline is far more advanced, many stages
18:56:41 <lethjakman> is it difficult to work on?
18:57:00 <dmj`> lethjakman: http://www.aosabook.org/images/ghc/hscpipe2.png
18:57:32 <dmj`> lethjakman: this is a fairly recent 2014? and great read on ghc, http://www.aosabook.org/en/ghc.html
18:57:36 <lethjakman> oooo interesting. 
18:57:43 <lethjakman> thank you!
18:57:49 <dmj`> lamefun: Go isn't dumb, it just wasn't written over the course of 20 years
18:58:36 <lamefun> Hm, why is Go generally same/faster than Haskell even though it doesn't have as many optimizations? http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=ghc&lang2=go
18:58:49 <funfunctor> how do I write this instance? http://lpaste.net/136683
19:01:23 <pacak> lamefun: Have you tried refactor large haskell projects?
19:01:43 <lamefun> pacak: no, what does it have to do with compilation speed?
19:02:23 <pacak> lamefun: It's not just about performance, it's about making it easier to maintain and modify your code. Types add safety and compiler must check all that stuff.
19:03:25 <lamefun> I don't know much about Go, but isn't it statically typed too?
19:03:46 <funfunctor> pacak: folks who talk about speed only don't write software tomorrow is going to care about.
19:04:50 <dmj`> lamefun: it doesn't seem like haskell is too far off in those benchmarks. But tbh people care way too much about speed. If you're in HFT I understand, but as pacak says, the benefit of haskell code is lower maintenance cost, reduced bugs and faster release cycle. Albeit ghc can produce *very* fast code, facebook seems to think so. Check the section on performance:
19:04:50 <dmj`> https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
19:05:20 <pacak> funfunctor: I do talk about speed and I do write software I've been caring about for a while.
19:05:34 <funfunctor> pacak: I said "speed only"
19:05:39 <funfunctor> i.e. nothing else
19:06:35 <funfunctor> most folks have not realised yet that compilers are smarter than programmers now
19:08:03 <exio4> lamefun: the point of idiomatic Haskell is to be easy to mantain, the fact that you can start optimizing to the point while staying within the language is some kind of extra bonus
19:08:13 <exio4> lamefun: also, the type system of Go is extremely limited
19:09:35 <exio4> lamefun: in the other hand, GHC implements pretty much a small logic programming language for resolving constraints in presence of multi param typeclasses, and you may need to evaluate complex expressions to actually typecheck the code (type families can be recursive..) 
19:14:28 <Denommus`> is acid-state nice for a straightforward web application?
19:15:04 <dmj`> Denommus`: I'd say yes, but use the remote module. Also acid-state distributed coming to a hackage near you this summer
19:15:45 <Denommus`> dmj`: why remote?
19:16:13 <dmj`> Denommus: https://www.google-melange.com/gsoc/project/details/google/gsoc2015/mcv1/5757334940811264
19:17:34 <lethjakman> dmj`: are you a go fan? 
19:17:37 <Denommus`> dmj`: cool
19:18:43 <lamefun> exio4: What's wrong with Go's type system?
19:19:01 <dmj`> Denommus: running everything in the same process is kind of bloaty, nice to have a seperation, still fast like redis, just way more type-safe
19:19:26 <exio4> lamefun: it's primitive compared to Haskell's 
19:19:55 <dmj`> lethjakman: I'd choose rust over it, the array syntax in go is kind of interesting... 
19:20:04 <lethjakman> rust looks super cool
19:20:24 <lethjakman> I kinda liked the weird structy object things, but then I started getting into haskell
19:21:06 <nocturne777> not related to Haskell, but what REST API tool do you guys use for documentation?
19:21:34 <dmj`> lethjakman: yea being able to reason about code is very beneficial, it just takes a while to get to a point of productivity, but when you do, it's a good thing.
19:21:52 <dmj`> @package swagger
19:21:53 <lambdabot> http://hackage.haskell.org/package/swagger
19:21:57 <lethjakman> I think I'm willing to sacrafice some time for the type system. 
19:21:59 <dmj`> nocturne777: ^
19:22:10 <lethjakman> it really does look to me like it will save time with the amount of testing it could save
19:22:13 <lethjakman> (I'm coming from ruby)
19:22:36 <dmj`> nocturne777: but it's based on the 1.0 api version, if you want to help me port it to 2.0 that'd be very nice :) *and* make and adaptor package for servant
19:22:48 <dmj`> s/and/an
19:23:28 <dmj`> lethjakman: yea, I used to do dynamic langs, types feel heavy in the beginning, but they have your back when things get hairy
19:23:36 <nocturne777> dmj`: I hear that 2.0 version has bugs
19:23:46 * dmj` gasps
19:23:50 <dmj`> I'm sure 1.0 did too :)
19:24:31 <dmj`> nocturne777: at least 2.0 is only one json file, 1.0 you had to setup this weird structure where on file would have an object that contained urls that linked to your other files that had objects, etc. 
19:24:38 <dmj`> one*
19:25:15 <dmj`> nocturne777: you could just use servant-docs, the nice thing about swagger is that swagger-ui lets you interactively query your api
19:25:38 <lamefun> exio4: I've read that it's a conscious decision for better compilation times / developer experience.
19:25:40 <dmj`> nocturne777: but you can't share types in the current haskell swagger package, between your json instances and the swagger models you define
19:25:41 <nocturne777> dmj`: I actually like 1.0's file structure better
19:26:10 <dmj`> nocturne777: well, then, yea, I mean I just like less stuff to worry about
19:27:17 <exio4> lamefun: opinions differ there :)
19:27:50 <dmj`> lamefun: compilation times are async if you use a CI server, for everything else there's ghci and it's pretty quick
19:27:54 <cow_2001> when package A depends on package B's library and not B's executable, is there a way to compile only the dependencies of B's library?
19:28:22 <cow_2001> within package A's cabal file
19:28:59 <dmj`> cow_2001: is package A installing dependencies from package B's executable build-depends section?
19:30:22 <cow_2001> dmj`: yes!
19:30:27 <dmj`> that doesn't sound right...
19:31:02 <nocturne777> dmj`: do you think it's better to define the docs in Haskell instead of in JSON?
19:31:28 <exio4> lamefun: type inference can also take exponential time, as a silly thing 
19:32:36 <dmj`> nocturne777: I think it'd be best if haskell types could be converted automatically to swaggers type specification, but reflection isn't that straightforward, and once you encode your type w/ aeson you lose some information, like 'is this field optional?' etc.
19:33:51 <dmj`> nocturne777: might be best to make a SwaggerType typeclass for this sort of thing.
19:35:05 <dmj`> nocturne777: everything is really manual in the current pkg
19:35:41 <nocturne777> at work we write  API documentation entirely in JSON
19:36:39 <nocturne777> I find that a bit cumbersome. if the object contains other objects, you have to define sub-objects and reference them.
19:39:09 <dmj`> nocturne777: my swagger haskell code more or less has to do the same
19:40:09 <dmj`> nocturne777: the swagger 2.0 spec is pretty straight forward
19:41:38 <nocturne777> dmj`: does it make it easier?
19:41:46 <cow_2001> could i use custom packages i've tweaked instead of the dependencies?
19:41:50 <nocturne777> dmj`: I came across this apiary thing
19:42:16 <dmj`> nocturne777: I saw that too, it's not free, and the richard stallman in me pitched a fit
19:44:28 <dmj`> nocturne777: even so, if money isn't an issue, not sure the spec would be any better, you'd still have to define types, which would mean reflection
19:44:43 <dibblego> is there a reasonable way to write unsnoc for Data.Text, given that it does not export constructors?
19:47:55 <dmj`> dibblego: unsnoc x | null x = Nothing | otherwise = Just (last x, init x)
19:49:42 <dibblego> dmj`: yeah, best I can do too
19:49:52 <jle`> dibblego: if you import the internal modules then i guess you can follow the pattern for uncons :)
19:49:54 <jle`> http://hackage.haskell.org/package/text-1.2.1.1/docs/src/Data-Text.html#uncons
19:50:22 <jle`> the constructor is exported in Data.Text.Internal
19:50:24 <funfunctor> alright, this is as close as I could get to the instance I need http://lpaste.net/136683
19:51:14 <funfunctor> why do I get; Couldn't match expected type ‚ÄòMaybe Data.ByteString.Internal.ByteString‚Äô with actual type ‚Äò(Maybe Data.ByteString.Internal.ByteString, Maybe Data.ByteString.Internal.ByteString)‚Äô
19:51:18 <dibblego> jle`: good idea, thanks
19:55:08 <mjrosenb> just checking, there is nothing that combines lookupWithDefault and update, right?
19:55:16 <mjrosenb> uhh, for Data.Map
19:56:42 <dmj`> mjrosenb: like an upsert?
19:57:20 <mjrosenb> well, updateWithDefault
20:00:17 <mjrosenb> oh, my bad, it is findWithDefault, not lookupWithDefault
20:03:24 <silentforest> hi
20:04:38 <dmj`> hi
20:09:26 <lamefun> How can I avoid writing eg. entityThink $ entityMove $ entityUpdate $ entityThink $ worldFindObject world key (eg. in C++ I can write world.findObject(key).update().move().think())?
20:10:06 <mniip> lamefun, I don't see a difference
20:10:32 <lamefun> mniip: no entity, world prefixes
20:11:01 <mniip> you mean OOP namespaces?
20:11:04 <agsolur> Hi I need help with getting my project to a online server . can anyone help me with that ?
20:11:21 <exio4> lamefun: using lenses?
20:11:29 <dmj`> lamefun: sounds like a state monad
20:11:34 <joneshf-laptop> does anyone have an example of how you can use coyoneda to make a free monad without defining a functor on the base type?
20:11:57 <lamefun> exio4: how can lenses help get rid of prefixes?
20:12:10 <exio4> lamefun: well, State + Lenses
20:12:22 <Zekka> exio4: I still don't follow you
20:12:27 <Zekka> This seems like it's totally a namespacing issue
20:12:46 <joneshf-laptop> I can't seem to get the types to line up
20:13:25 <exio4> ah, I nevermind, I see what's the actual problem
20:13:54 <agsolur> I have a dynamic web project running on my local environment but now I want others to access the project and so i need to upload to a  online server
20:14:02 <agsolur> But i dont know how to do it
20:14:11 <agsolur> can anyone please help me
20:14:42 <mniip> and this is related to haskell how?
20:15:02 <exio4> lamefun: a compromise I would use is define every function in its own module, thus having module Entity (think) .. and then import it qualified and do E.think
20:15:30 <dmj`> > flip execState (1,1) $ _1 += 1 >> _2 -= 1
20:15:32 <lambdabot>  (2,0)
20:15:43 <dmj`> lamefun: lenses + state
20:15:59 <Zekka> dmj`: All that stuff isn't really necessary to get suffix application, right?
20:16:01 <dmj`> what exio4 said
20:16:04 <Zekka> And the namespacing issue is still there afaik
20:16:53 <dmj`> not sure, seems more like a state management issue to me
20:16:55 <Zekka> this is all you need to get suffix application: x # f = f x
20:17:12 <Zekka> dmj`: That's not the case if the two snippets he gave are actually equivalent
20:17:13 <mniip> Zekka, it's called &
20:17:20 <Zekka> mniip: Yes, that's the alias Lens gives it
20:17:31 <mniip> that's the alias base gives it
20:17:39 <Zekka> mniip: For real? I didn't know.
20:17:55 <mniip> :t (Data.Function.&)
20:17:55 <lambdabot> a -> (a -> b) -> b
20:18:14 <dmj`> Zekka: yea, but he wants to abstract that out, yes a state monad is just applying many functions repeatedly over a value, but that's ugly w/o a monad
20:18:28 <lamefun> exio4: is there any advantage to having to prefix everything?
20:18:40 <dmj`> that's just flip &
20:18:41 <mniip> dmj`, a state monad is constant in the type of the state
20:18:41 <Zekka> dmj`: But if the functions aren't actually producing or updating state, they're the same, except you've got to throw 'return's in
20:19:00 <mniip> from what I see their case is not constant in the type of object operated on
20:19:11 <lamefun> why can't I have "think $ move $ update $ findObject world key"?
20:19:14 <Zekka> If he's not actually producing state I don't know what the point is of using a state monad
20:19:24 <mniip> lamefun, uh, you can...
20:19:28 <lamefun> and compiler find the fitting functions for me
20:19:43 <Zekka> lamefun: Because Haskell's namespacing/overloading means it typically won't have a good way to deal with name collisions
20:19:59 <Zekka> (You can hack out a solution using typeclasses, but probably shouldn't)
20:20:03 <mniip> lamefun, you could define a typeclass
20:20:08 <mniip> but that's not the idiomatic way
20:20:09 <dmj`> Zekka: I guess I assumed he wanted to do more than just apply 4 functions to a value
20:20:10 <exio4> lamefun: if you _really_ want to do that, you can use typeclasses hacks, but it's really ugly and you shouldn't 
20:20:18 <Zekka> dmj`: He literally asked how to apply four functions to a value.
20:20:36 <mniip> the idiomatic way is unique function names
20:20:38 <Zekka> If I seem a little cross it's because it seems like people fell over themselves to introduce really complicated machinery like State and lens when his problem was really simple
20:21:30 <dmj`> Zekka: his C++ example looks monadic to me, it looks like C# linq, which is actually monadic
20:21:55 <mniip> dmj`, but they were talking about namespace
20:22:03 <mniip> they mentioned it a couple times at least
20:22:37 <Zekka> dmj`: What about it is monadic? All you know is that he's applying four functions to a value, and he indicates that the equivalent Haskell code is not monadic, and when explicitly asked he said the difference was that he had to use prefixes (and later asked why Haskell preferred prefix application to suffix)
20:23:39 <Zekka> Sorry, I'm probably being kind of a jerk, but if I'm a curious beginner the last thing I want to be told is "use this library with ten million dependencies along with this type you probably don't understand yet"
20:23:43 <dmj`> Zekka: I don't really know what prefixes are sorry
20:24:13 <Zekka> dmj`: Prefix-application: the function comes before the argument. Prefixes for words are first parts that are common between words
20:24:24 <Zekka> So between entityThink and entityUpdate, entity is a common prefix.
20:24:45 <dmj`> oh I see, I thought that was some kind of C++ jargon. Prefix function application makes sense
20:24:46 <Zekka> A prefix is a thing that comes before, a suffix is a thing that comes after, and something infix is something that comes in between
20:25:27 <dmj`> Zekka: lenses the concept are very simple, but yes, lens the library is not as simple
20:25:52 <dmj`> Zekka: I never told him to install lens
20:25:55 <Zekka> dmj`: They're pretty complicated conceptually, imho, and I'm speaking as someone who understands how they work
20:26:13 <Zekka> dmj`: You said "use lenses" -- what did you want him to do, invent them out of thin air?
20:26:57 <Zekka> I guess of course you can maintain the interface for plain lenses with much simpler types
20:27:35 <Zekka> But the reason you recommended them seems to have been the Stateful operators lens comes with, which are specific to Kmett's lens implementation afaik
20:29:33 <dmj`> Zekka: if you look at his code sample it seems that he is persisting some kind of state called 'entity', which can 'think', be updated, etc. That's why I reached for the State monad. lenses was mentioned later. lambdabot happens to have those handy and there are some MonadState instances for them I believe
20:29:56 <dmj`> Zekka: my intention was not to confuse, and I apologize if it came across that way
20:30:05 <lamefun> Zekka: "and later asked why Haskell preferred prefix application to suffix" - I don't mind prefix application, what I'm talking about is having to prefix functions with types/modules.
20:30:16 <Zekka> lamefun: Oh, I think I misunderstood you
20:31:06 <Zekka> dmj`: To be fair, you're right that often OOP code has arbitrary effects on outside state
20:32:06 <Zekka> lamefun: FWIW I really don't have a good solution to your problem, and it's one of the things that really annoys me about Haskell, even though there's an argument to be made that it's pretty insignificant
20:32:15 <lamefun> eg. in C++ you can still write entityUpdate(entityThink(entityMove(worldFindObject(world, key))))
20:32:32 <Zekka> (I tend to take the position that Haskell is a lot more verbose than people treat it as being)
20:34:16 <dmj`> lamefun: yea, sounds like you want a monad, if you like at the type of bind (>>=) :: Monad m => m a -> (a -> m b) -> m b, it's similar to what you're doing, take a value, unwrapping it, transforming it, rewrapping it, doing it again.
20:34:41 <Zekka> I'm still confused, how has what he's said indicated he wants a monad?
20:35:22 <exio4> I don't think, I would go with E.update $ E.think $ E.move $ W.findObject world key (even though I still think it's ugly) 
20:35:24 <Zekka> From what I can tell he just wants the names of the functions he's using to be shorter
20:35:29 <exio4> I don't know * 
20:36:16 <Zekka> I'm at the point where I think a monad interface is something he'll probably want at sme point, but it doesn't solve the problem he asked about afaik
20:37:42 <dmj`> lamefun: it sounds like world is hashmap, key is a possible key of the hashmap, if you can find this entity, mutate it, and store it back in the world, otherwise if not found do nothing
20:38:11 <lamefun> dmj`: I'll probably need something like that in real entity code.
20:38:34 <lamefun> but it won't solve the need to prefix every entity function with 'entity' or 'E.'
20:39:17 <dmj`> lamefun: yea, function names will have to be unique, unless you use a typeclass that has a member function, then you can apply it to any instance. Real handy
20:40:12 <lamefun> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign
20:40:28 <dmj`> class HasEntity a where; updateEntity :: Int -> a -> a; etc...
20:41:10 <dmj`> lamefun: can you paste your code?
20:43:24 <dmj`> lamefun: yea, not sure the status of that
20:45:12 <lamefun> I'm not writing entity code, that was just an example.
20:46:07 <dmj`> Zekka: to be fair, since functions are monads, his original code was monadic :)
20:46:30 <lamefun> wow
20:46:32 <lamefun> what's that?
20:47:47 <lamefun> Whe are so many people timing out at once?
20:48:50 <exio4> lamefun: irccloud issues, apparently
20:49:20 <lamefun> exio4: what irccloud?
20:49:52 <exio4> lamefun: http://irccloud.com/
20:49:54 <dmj`> lamefun: functions are just unwrapped reader monads, and functors under composition
20:50:24 <benzrf> irccloud is butt
20:50:31 <benzrf> run your own goddamn bouncer
20:51:14 <lamefun> exio4: web IRC client?
20:51:34 <exio4> lamefun: + bouncer, pretty much
20:57:08 <hiptobecubic> I don't know why people even bother lurking full time, really
20:57:26 <hiptobecubic> lambdabot can send you messages if it's that important
20:58:30 * hackagebot hpack 0.5.3 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.5.3 (SoenkeHahn)
21:05:26 <SrPx> JavaScript... state.board.hitCounters[state.board.hitCounters.length - 1] = Math.min(state.board.hitCounters[state.board.hitCounters.length - 1] + 1, 60) ... Haskell... state^.board.hitCounters.last %~ (min 60 . (+ 1)) ... zzzzzz
21:06:42 <benzrf> wrong, SrPx
21:06:47 <benzrf> u arent doin a view here
21:06:56 <SrPx> wooops
21:06:58 <SrPx> state& *
21:07:10 <benzrf> :t last
21:07:11 <lambdabot> [a] -> a
21:07:15 <benzrf> that aint no lens
21:07:32 <SrPx> non standard... what is the last lens called? 
21:07:40 <exio4> @type _last
21:07:41 <lambdabot> (Applicative f, Snoc s s a a) => (a -> f a) -> s -> f s
21:07:49 <SrPx> clone enough :)
21:08:03 <lamefun> not state^.stateBoard.boardHitCounters.last?
21:08:12 <SrPx> so, state&board.hitCounters._last %~ (min 60 . (+ 1)) , right?
21:11:40 <exio4> SrPx: maybe board.hitCounters._last %= min 60 . (+ 1) ? :p 
21:12:24 <SrPx> I never know when to use what 
21:13:03 <exio4> l %= f is modify (\s -> s & s %~ f) 
21:13:21 <exio4> uhh, modify (\s -> s &l %~ f) , sorry
21:36:16 <hhhelp> hello folks, beginner question, I have a list of lists [ [7,8], [9,0] ] and would like to end up with a list of tuples combining the index of each list and it's items. So the expected output would be [ (1,7),(1,8),(2,9),(2,0)] 
21:37:48 <exio4> indexes starting at 1 or 0? 
21:37:53 <hhhelp> at 1
21:38:39 <exio4> > (concat . zipWith (\n -> map (n,)) [1..]) [ [7,8] , [9,0] ]
21:38:40 <lambdabot>  [(1,7),(1,8),(2,9),(2,0)]
21:38:54 <exio4> (using TupleSections)
21:40:01 <hhhelp> exio4: what does using tuplesections mean? should I add it to the file near the imports
21:41:07 <hhhelp> because i got an error: a1.hs:42:40: Illegal tuple section: use TupleSections
21:41:12 <exio4> hhhelp: it's a ghc extension, in this case you can just replace (n,) with (\x -> (n,x)) 
21:41:48 <exio4> anyway, do you know what zipWith and concat do? 
21:42:57 <hhhelp> Perfect that worked
21:44:09 <hhhelp> exio4: sort of, I am supposed to implement a program in python vs. haskell for a comparative programming languages course and I realise haskell needs some getting familiar with before I can write it
21:44:33 <exio4> ehm, it was homework, I shouldn't have written it I think
21:44:34 <hhhelp> Unfortunately there isn't a lot of time, got to have it done by friday!
21:44:47 <dramforever> hhhelp: yes sure, but it gets cleaner in haskell
21:45:04 <dramforever> hhhelp: so have you been learning haskell?
21:45:12 <dramforever> *how long have
21:45:28 <hhhelp> Well, the homework assignment doesn't care if we copy paste the code even, teachers words. It's more about the analysis and coparison of the languages
21:46:06 <dramforever> oh that's fine I guess
21:46:40 <ttt_fff> try implement it in brainfuck
21:46:43 <hhhelp> Since yesterday. Used the graph library to do dfs, but built the graph edges by hand. Now I am reading from file and hoping to test it out
21:47:04 <ttt_fff> dfs is like 10 lines of code
21:47:32 <dramforever> ttt_fff: no it's zero, there's a library function for that
21:47:40 <hhhelp> actually one line using the Data.Graph
21:47:49 <hhhelp> but there is no bfs function in that library
21:48:00 <ttt_fff> dramforever: I mean from scratch
21:48:22 <dramforever> ttt_fff: oh that would depend on how "scratch" it is
21:48:49 <ttt_fff> dramforever: by 'scratch', I mean you install haskell platform and don't cabal anything else
21:49:25 <dramforever> ttt_fff: I think fgl is in haskell-platform
21:51:33 <hhhelp> dramforever: is fgl different han Data.Graph ?
21:51:40 <dramforever> I don't know
21:52:04 <hhhelp> is there a way to find out what libraries are available to me?
21:52:16 <ttt_fff> hhhelp: dramforever is not in 'help hhhelp' mode, dramforever is in https://xkcd.com/386/ mode
21:52:33 <ttt_fff> cabal list; cabal install
21:52:38 <ttt_fff> cabal hell
21:52:45 * dramforever is always in xkcd 386 mode
21:53:11 <ttt_fff> dramforever: I like that in a coworker, as long as they're compotent
21:53:44 <dramforever> you mean competent?
21:53:57 <hhhelp> :)
21:54:27 <ttt_fff> I want to take a laptop, no internet connection, and move into wyoming for a year
21:54:30 <ttt_fff> and do nothing but just study haskell
21:54:54 <ttt_fff> it'd the kungfu-movie equiv of going to a monastery until you learn the hidden-dragon-crouching-tigher-five-step-crane-finger-push-style
21:55:46 <dramforever> interesting that "hidden-..." part in Chinese is one character per part
21:55:50 <dramforever> </off-topic>
21:56:37 <ttt_fff> hidden-monad-RWST-Either-IO-List-Maybe-style
21:57:09 <ttt_fff> somsone needs to make an RPG, where leveling up / casting new spells requires typing in haskell expressions that (1) type check and (2) pass quickcheck
21:59:33 <ricochet1k> The idea reminds me of VIM Adventures
22:02:18 <ttt_fff> we shoudl call it monadic journeies
22:02:32 <ttt_fff> or, Maybe [Adventure]
22:02:50 <ttt_fff> or Either Death [ CoolStoriesBro ]
22:07:32 <exio4> ttt_fff: [CoolStoryBro]
22:07:59 <exio4> ttt_fff: the list represents plurality 
22:09:12 <hhhelp> thanks for the help guys, bye
22:22:40 <numberten> anyone have experience with this error? "Cannot find fixpoint binary [fixpoint.native]" in liquidhaskell?
22:37:55 <ecognium> Hi everyone, I have a question regarding Aeson. data Test = Test { d :: Day } and the incoming JSON will be formatted as 07/15/2015. I wrote a little function that takes a data text and converts it to something that I can feed into `read`. This conversion function returns a `Maybe Day`. How can I make this a parse error in my FromJson instance? 
22:38:30 <dramforever> :t maybeZero
22:38:31 <lambdabot> Not in scope: ‚ÄòmaybeZero‚Äô
22:43:22 <numberten> got it :)
22:45:01 <exio4> ecognium: maybe mzero return ? 
22:45:05 <exio4> @type maybe mzero return 
22:45:06 <lambdabot> MonadPlus m => Maybe a -> m a
22:52:30 <numberten> I was referring to the wrong binary, specifically the one in dist/ not .cabal-sandbox/
23:04:26 <hunteriam> https://www.irccloud.com/pastebin/H7j8ASKI
23:04:31 <hunteriam> newtype Fix f = Fx (f (Fix f))
23:04:55 <hunteriam> So in this case f :: * -> *
23:05:13 <hunteriam> I don't understand how this data type is useful
23:06:03 <hunteriam> I found it in a tutorial on f algebra, since I'm trying to delve into the category theory of Haskell. Always faxcinated me, but scared me off
23:06:18 <hunteriam> If anyone could help me understand its use, that'd be really great
23:06:58 <jle`> hunteriam: one neat thing you can do is factor out the old 'expression adt' that everyone learns in haskell
23:07:24 <jle`> data Expr = ExprInt Int | ExprPlus Expr Expr | ExprMult Expr Expr | ...
23:07:49 <jle`> you can turn it into data ExprF a = ExprInt Int | ExprPlus a a | ExprMult a a | ...
23:07:56 <jle`> and then type Expr = Fix ExprF
23:08:53 <hunteriam> Ah, so it makes the type for expr come from a general place, but it'd be quite annoying to program with this setup, because you'd have stray FXs everywhere?
23:09:16 <jle`> writing an evaluation function is a little nicer i think
23:09:24 <jle`> for the one based on fix
23:09:33 <jle`> or well, you can write it using more general higher order functions
23:09:42 <hunteriam> I think the tutorial may cover this, and I'm just jumping the gun
23:09:43 <jle`> the evaluator function that would be like eval :: Expr -> Int
23:09:59 <exio4> one nice thing is that you generalize things like `folds` to arbitrary structures 
23:10:21 <jle`> yeah, so now instead of writing your own evaluator function from scratch using recursion
23:10:29 <jle`> you can just use a higher order "folding" function
23:10:44 <jle`> explicit recursion is messy and error prone and makes code sometimes hard to really read/see
23:10:49 <jle`> eval (ExprInt i) = i
23:11:00 <jle`> eval (ExprPlus x y) = eval x + eval y
23:11:04 <jle`> explicit recursion etc.
23:11:22 <jle`> but with Fix the library provides a higher order function to abstract over catamorphisms like this
23:12:25 <jle`> so you don't have to munge around with explicit recursion anymore
23:12:33 <hunteriam> Thanks
23:12:56 <adarqui> i've been messing around "porting the matrix library" to GHC.Arr.. the matrix package (hackage.haskell.org/package/matrix) uses vector which uses Data.Primitive.Array, which uses GHC.Prim which is doing some crazy stuff.. i guess my question is, why isn't any of this using GHC.Arr (ghc's native array impl) ?
23:13:26 <jle`> hunteriam: so eval = cata $ \x -> case x of ExprInt i -> i; ExprPlus x y -> x + y; ExprMult x y = x * y
23:13:38 <jle`> see, no more explicit recursion :)
23:13:42 * hackagebot text1 0.0.2 - Non-empty values of `Data.Text`.  http://hackage.haskell.org/package/text1-0.0.2 (TonyMorris)
23:14:11 <jle`> that's because you define how to work with an `Expr Int`, which is easy --- `ExprMult` just has two Ints, which you can multiply.
23:14:21 <jle`> cata :: (Expr Int -> Int) -> Fix Expr -> Int
23:17:47 <jle`> hunteriam: there's even cataM :: Monad m => (Expr Int -> m Int) -> Fix Expr -> m Int, so you can define your Expr Int -> Int's in monadic contexts :)  the whole idea is to generalize over this common catamorphism pattern using higher order functions that let you state your intent more directly instead of making everyone resort to explicit recursion
23:18:08 <hunteriam> Christ I wish I could keep up
23:18:26 <hunteriam> I'm actually only reading about f algebra cause I wanted to know what catamorphisms were
23:18:33 <jle`> heh
23:18:37 <hunteriam> There's so many important words I have to digest at,
23:18:39 <hunteriam> Atm
23:18:40 <jle`> you can think of catamorphisms as tear-downs of recursive structures
23:18:42 * hackagebot hpack 0.5.4 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.5.4 (SoenkeHahn)
23:18:51 <ecognium> exio4:  It looks like my conversion function has to work with Aeson's Value and not Text.  This is probably getting a bit messy so may be I will just create an orphan instance for `Day` and put my parsing logic there
23:18:52 <jle`> the most famous catamorphism to a haskeller is foldr
23:19:15 <jle`> foldr f z replaces the recursive list structure's (:) with f, and [] with z
23:20:54 <hunteriam> See, I've heard these things, and it just doesn't click. Its like when the Internet  tried to explain OOP to me
23:21:03 <hunteriam> I think the in depth tutorial is good though
23:21:38 <yayfoxes_> I'm lost at Chapter 4 Cale
23:21:42 <exio4> ecognium: nice :)
23:22:00 <yayfoxes_> I don't know how to do exercise 4.8.1
23:22:16 <hunteriam> Thanks anyways
23:22:36 <hunteriam> These chats are really useful but I'm no good at learning big concepts quickly like this
23:22:52 <yayfoxes_> if I made a halve function, it'd have to return a function somehow and something to do with the identity functio
23:22:55 <yayfoxes_> function*
23:23:45 <hunteriam> What are you reading  yayfoxes_
23:23:58 <yayfoxes_> Graham Hutton's Programming in Haskell
23:24:04 <dmj`> foldr also has to build up an expression in its entirety before it can evaluate
23:24:09 <yayfoxes_> I think I need something simpler
23:24:16 <dmj`> :t foldr (>>) 
23:24:17 <lambdabot> (Monad m, Foldable t) => m b -> t (m a) -> m b
23:24:39 <dmj`> :t foldl' (>>)
23:24:40 <lambdabot> (Monad m, Foldable t) => m a -> t (m a) -> m a
23:24:41 <yayfoxes_> in fact, something simpler that encourages real world exercises / stuff
23:24:52 <hunteriam> yayfoxes_: I can try and help with that problem if you want, what exactly is it asking?
23:25:02 <dmj`> jle`: why isn't sequence_ defined in terms of foldl' ? would that change order of effects
23:25:44 <exio4> dmj`: what do you mean with foldr building building up an expresion? 
23:26:14 <exio4> > foldr (\x xs -> x : x+1 : xs) (error "bam") [0,2..]
23:26:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:26:33 <dmj`> exio4: this explains it well: https://wiki.haskell.org/Foldr_Foldl_Foldl'
23:26:37 <yayfoxes_> hunteriam: I'm stuck but here goes: Using library functions, define a function halve :: [a] -> ([a],[a]) that splits an even lengthed list into two halves
23:26:46 <exio4> dmj`: I just saying foldr can be lazy on the second argument
23:27:07 <hunteriam> Does it want you to split them down the middle or?
23:27:10 <exio4> dmj`: if anything, foldl(') are the ones that need to "traverse" the whole list before they can return anything
23:27:10 <hunteriam> yayfoxes_: ^
23:27:54 <yayfoxes_> hunteriam: well, I guess that's what they mean
23:27:55 <dmj`> exio4: sure but foldl' will reduce as it traverses
23:28:05 <yayfoxes_> if I made a function that only took half of a list
23:28:12 <yayfoxes_> but how?
23:28:27 <hunteriam> yayfoxes_: i can show you how I would do it, if you think that would help
23:28:29 <jle`> it'd be nice for sequence_ to work on infinite lists right?
23:28:43 * hackagebot getopt-generics 0.8 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.8 (SoenkeHahn)
23:28:43 <jle`> > sequence (repeat Nothing)
23:28:45 <lambdabot>  Nothing
23:29:04 <yayfoxes_> hunteriam: it wouldn't because I'm stuck at this chapter, I don't think I'm understanding the material
23:29:15 <yayfoxes_> maybe this:
23:30:22 <hunteriam> :t foldr
23:30:23 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:30:32 <yayfoxes_> halve :: [a] -> ([a],[a])
23:30:46 <jle`> > foldr (>>) (return ()) (repeat Nothing)
23:30:48 <lambdabot>  Nothing
23:30:56 <jle`> > foldl' (flip (>>)) (return ()) (repeat Nothing)
23:31:01 <lambdabot>  mueval: ExitFailure 1
23:31:41 <dramforever> ?
23:31:47 <yayfoxes_> oh god I'm so stuck
23:31:47 <funfunctor> @hoogle lex
23:31:48 <lambdabot> Prelude lex :: ReadS String
23:31:48 <lambdabot> Text.Read lex :: ReadS String
23:31:48 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
23:31:53 <hunteriam> I would do halve = foldr (\(a:b:xs) (as,bs) -> (a:as,b:bs)) ([],[])
23:31:58 <hunteriam> yayfoxes_:
23:32:11 <hunteriam> It's not my favorite answer but that's probably what i would come up with
23:32:16 <hunteriam> I can explain if you want
23:32:23 <hunteriam> Or does it mean to use other functions?
23:32:23 <yayfoxes_> but then ... any other way of doing it?
23:32:33 <hunteriam> Yes I think there are a probably a lot
23:32:37 <yayfoxes_> it means to use other functions introduced in the book already
23:32:38 <hunteriam> Let's see if I can think of any
23:32:47 <hunteriam> Ah any functions in mind?
23:33:34 <yayfoxes_> hunteriam: um...no
23:33:50 <adarqui> cool blog article on git as a purely functional data structure: http://www.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/
23:33:51 <hunteriam> Have they introduced a lot?
23:33:58 <yayfoxes_> no sir
23:34:27 <hunteriam> Hmm.. I can guess at what they have introduced, or if you think it'd be possible is there a list of functions you have so far somewhere?
23:35:45 <yayfoxes_> hunteriam: please guess
23:36:03 <jle`> maybe they want you to do two traversals
23:36:07 <yayfoxes_> but they have introduced tail, length, drop, and take
23:36:13 <jle`> and do splitOn (length xs `div` 2)
23:36:22 <jle`> *splitAt
23:36:59 <jle`> it's a bit of a wasteful implementation but if it's an intro to haskell texts that might be what they're looking for, heh
23:37:41 <hunteriam> jle`: out of curiosity, how would you do this with no restrictions?
23:37:57 <yayfoxes_> I'd do this then: (take numItems xs, drop numItems xs) where numItems = length xs `div` 2
23:38:39 <jle`> i'm not sure if a single traversal version is possible but i'd be very curious
23:38:42 <jle`> i suspect that it is
23:38:45 <yayfoxes_> the numItems prevents going thru the list 4 times as opposed to 2 times with numItems
23:39:09 <jle`> nice :)
23:39:27 <hunteriam> jle`: what about the foldr I wrote above? In a real setting do you think that's the best solution?
23:39:35 <hunteriam> Assuming it's even correct
23:39:40 <exio4> I would use the right data structure
23:39:41 <yayfoxes_> jle`: do this: a mapping that returns a function instead of a value and reduce it down to an id function a la optimized quicksort
23:39:56 <yayfoxes_> that's from somebody else's mouth
23:40:14 <yayfoxes_> but it should work here; I, for one, have not a clue how any of that works
23:40:25 <jle`> hunteriam: i thought we were chopping a list in half, instead of zig zagging them.  that foldr one would probably be the nice way if it's zig zaggy
23:40:49 <hunteriam> yayfoxes_: do you know if you have to split it down the middle?
23:40:56 <yayfoxes_> hunteriam: yes, you do
23:41:08 <hunteriam> jle`: if it was zig zaggy, do you know of a better solution?
23:41:31 <yayfoxes_> if it's an odd number of list items the first item in ([a], [a]) will have an odd number of items in it
23:41:47 <jle`> i can think of more fun solutions maybe :)
23:42:03 <hunteriam> If you don't mind I'd love to see them
23:42:10 <yayfoxes_> jle`: yeah yeah , take mine :)
23:42:22 <hunteriam> Haskellers the only language where seeing other peoples code is so interesting to me
23:42:30 <yayfoxes_> I'm confident it'll wor
23:42:33 <yayfoxes_> work*
23:42:41 <hunteriam> I like your solution a lot yay foxes
23:42:51 <dmj`> jle`: did you see the forConcurrently merge?
23:43:01 <exio4> if I actually need to do operations like that, I'd go with some structure that isn't potentially infinite :D 
23:43:10 <yayfoxes_> but how do you find the solution if you return a function somewhere insted of a value?
23:43:13 <jle`> dmj`: where?
23:43:15 <exio4> (and allow O(1) slicing/length operations)
23:43:31 <hunteriam> yayfoxes_: is that a different exercise?
23:43:46 <dmj`> jle`: https://github.com/simonmar/async/pull/30#event-356530954
23:43:54 <yayfoxes_> hunteriam: what I posted is how to make an optimized quicksort algorithm
23:44:11 <yayfoxes_> maybe you can optimize this split list in half stuff the same way
23:44:27 <yayfoxes_> I wish Cale were here
23:44:33 <yayfoxes_> we could just talk and talk
23:44:45 <funfunctor> anyone happen to be a postgreSQL guru and knows some haskell at the same time? I have a tricky one
23:45:49 <hunteriam> Sry man I'm not as experienced as Cale
23:46:01 <lpaste_> funfunctor pasted ‚ÄúNo title‚Äù at http://lpaste.net/136692
23:46:32 <hunteriam> I'm not sure how returning a function would help you split a list, if that's what you're saying. Hopefully someone else here can help with that
23:46:40 <funfunctor> ^ looking to get that instance going so I can use the postgres point type and marshell it back to a Haskell (a, a)
23:48:37 <jle`> ah yeah you sent it to me
23:48:39 <jle`> nice :D
23:48:41 <jle`> o/
23:48:59 <funfunctor> jle`: ?
23:49:09 <jle`> to dmj` 
23:49:18 <dmj`> \o/
23:49:25 <funfunctor> oh ah sry
23:49:30 <jle`> > unzip . map head . takeWhile (not . null) . iterate (drop 2) . ap zip tail $ [1..10]
23:49:31 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
23:49:37 <jle`> ^^ hunteriam 
23:50:13 <hunteriam>  :t ap
23:50:17 <yayfoxes_> jle`: can you do all that without reordering the list items?
23:50:19 <hunteriam> :t ap
23:50:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:50:21 <jle`> it's (<*>)
23:50:31 <jle`> yayfoxes_: that was meant to be the solution to the zig zaggy version, heh
23:51:11 <yayfoxes_> jle`: oh so zig zaggy means it'll reorder stuff, ok
23:52:00 <yayfoxes_> jle`: can you link me to some more Haskell resources? I want to code but getting stuck here is a problem
23:52:32 <jle`> i think your solution there is good :)
23:52:37 <jle`> it's probably the one the text you're using wants
23:52:46 <jle`> what are you learning haskell thorugh?
23:53:09 <yayfoxes_> Graham Hutton's Programming in Haskell
23:53:21 <jle`> @where learnhaskell
23:53:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:53:23 <jle`> has some stuff
23:53:26 <jle`> @where lyah
23:53:26 <lambdabot> http://www.learnyouahaskell.com/
23:53:28 <jle`> is another
23:53:42 <dmj`> > (filter even [1..10] , filter odd [1..10]) 
23:53:43 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
23:53:51 <yayfoxes_> my question would be how to write the tail function
23:53:57 <yayfoxes_> what does tail even do?
23:54:04 <dmj`> jle`: see, you don't need all that extra work
23:54:08 <exio4> it's an evil function!
23:54:09 <dramforever> yayfoxes_: where did you see the question?
23:54:21 <dramforever> well, who asked you to write it?
23:54:23 <jle`> dmj`: :p someone asked for the *fun* way :)
23:54:38 <yayfoxes_> this haskell book Programming in Haskell by Graham Hutton
23:54:46 <jle`> you'd probably use pattern matching
23:54:50 <jle`> have they taught you about pattern matching yet?
23:54:58 <yayfoxes_> they did, but I need more practice
23:55:08 <jle`> so fill in the blank
23:55:13 <jle`> tail takes a list, right?
23:55:16 <yayfoxes_> yes
23:55:17 <jle`> and a just can be (x:xs)
23:55:20 <jle`> tail (x:xs) = ???
23:55:26 <yayfoxes_> tail (x:xs) = xs
23:55:32 <jle`> yea nice job
23:55:35 <jle`> but here's the problem with tail
23:55:41 <jle`> there's another pattern a list can be
23:55:44 <jle`> tail [] = ??????
23:55:49 <jle`> there's no real answer you can give here
23:55:59 <jle`> or well, there is >_>
23:55:59 <exio4> @type tail [] 
23:56:00 <lambdabot> [a]
23:56:09 <jle`> i was thinking of head, heh
23:56:19 <yayfoxes_> there is, just return the empty list in that case
23:56:21 <jle`> tail is defined to be undefined when given [] as input
23:56:28 <jle`> something about historical reasons...
23:56:30 <jle`> blah blah...
23:56:38 <dramforever> > tail [] -- yayfoxes_ well the Prelude says otherwise
23:56:40 <lambdabot>  *Exception: Prelude.tail: empty list
23:56:48 <yayfoxes_> heh
23:56:48 <jle`> it's just historical baggage i think
23:57:03 <yayfoxes_> this is just a reworking of that that won't throw an exception
23:57:08 <jle`> from the historical origins of the tail function, it's specifically defined to not be defined for []
23:57:14 <jle`> as in like, it's in the spec
23:57:21 <exio4> @type head [] -- this one is tough though
23:57:22 <lambdabot> a
23:57:23 <dramforever> yayfoxes_: why do you ever need tail when you can pattern matcg soooooo cleanly =P
23:57:32 <dramforever> *match
23:57:42 <exio4> tail is sometimes handy 
23:57:42 <dramforever> I mean, you probably well use it only sparingly
23:58:14 <yayfoxes_> wail I have a question; how would you write tail using an if statement?
23:58:27 <hunteriam> Does anyone have a good resource for understanding what a category is?
23:58:39 <jle`> tail (x:xs) = if Truen then xs else error "what are you even trying to do?"
23:58:47 <jle`> *if True
23:59:15 <yayfoxes_> no they don't want me to use pattern matching with the if statement, and I'm trying to finish the exercise
23:59:17 * dramforever someone give me this link earlier today http://yogsototh.github.io/Category-Theory-Presentation/
23:59:22 <dramforever> hmm...
23:59:28 <dramforever> hunteriam: ^
23:59:35 <jle`> hunteriam: there's also ##categorytheory :)
23:59:46 <yayfoxes_> if I get stuck here I might not be a good programmer
23:59:50 <exio4> yayfoxes_: there's no way to pattern match with an if expression
23:59:55 <yayfoxes_> ok then...
23:59:57 <yayfoxes_> OH
23:59:59 <yayfoxes_> wait
