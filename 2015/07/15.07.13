00:00:09 <rowanblush> Also, the "things around div" are called backticks.
00:00:11 <MarcelineVQ> yayfoxes: ` marks turn a function into infix form
00:00:21 <MarcelineVQ> > 20 `div` 10
00:00:23 <lambdabot>  2
00:00:26 <MarcelineVQ> > div 20 10
00:00:29 <lambdabot>  2
00:00:56 <yayfoxes> http://hastebin.com/wejisowexe
00:01:34 <adarqui> add a .hs extension after your hastebin and it'll syntax highlight specific to haskell (i think)
00:01:37 <adarqui> http://hastebin.com/wejisowexe.hs
00:02:09 <yayfoxes> so they are not backticks in their code for what's around div
00:02:17 <adarqui> i don't use hugs but, functions need to start with lowercase letters.. and those don't look like backticks
00:02:19 <rowanblush> adarqui: It seems to have highlighted fine without the extension.
00:02:22 <yayfoxes> in their code, what's around div are single quotes
00:02:36 <adarqui> did you copy it from a pdf?
00:02:36 <MarcelineVQ> http://lpaste.net/ is popular and helps with syntax
00:02:43 <yayfoxes> adarqui: yes
00:02:47 <adarqui> yayfoxes: that's why
00:02:58 <adarqui> you'll have to replace those backticks you copy from the pdf, usually, with actual backticks
00:03:01 <adarqui> they copy/paste as '
00:03:51 <yayfoxes> could last be implemented like this?:
00:04:05 <MarcelineVQ> are you pasting into ghci?
00:04:10 <yayfoxes> no sir
00:04:15 <MarcelineVQ> alright, the parse error is not using let if you are
00:04:41 <yayfoxes> last (x:xs) = x : xs !! (length x:xs)
00:05:00 <yayfoxes> last xs lol
00:05:05 <MarcelineVQ> copying your N = a `div` length xs where a = 10; xs = [1,2,3,4,5] and changing the n to lower case doens't have any parse errors for me
00:05:31 <adarqui> yayfoxes: no that doesn't make sense.. if you are writing a 'last' function, show us your type signature first
00:05:40 <adarqui> a type sig will help fix your reasoning about that function
00:06:08 <yayfoxes> adarqui: type sig would be last :: [a] -> a
00:06:28 <adarqui> cool, so why in your function are you consing with : ? etc?
00:06:43 <yayfoxes> being not very smart
00:07:16 <adarqui> nah, it's fine.. but, the function you pasted indicates more of a last :: [a] -> [a], just from a glance
00:07:38 * hackagebot jammittools 0.5.0.1 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.5.0.1 (mtolly)
00:07:38 * hackagebot uhttpc 0.1.1.0 - Minimal HTTP client library optimized for benchmarking  http://hackage.haskell.org/package/uhttpc-0.1.1.0 (HerbertValerioRiedel)
00:07:59 <yayfoxes> adarqui: there's another problem: where's the base case?
00:08:01 <ski> eds : hm. yes
00:08:04 <adarqui> forget !! and length for now.. is my advice.. go simply for pattern matching
00:08:05 <yayfoxes> a single list item
00:08:14 <adarqui> yayfoxes: yup..
00:08:36 <adarqui> do this in hugs: last []
00:08:38 <adarqui> last [1]
00:08:43 <yayfoxes> adarqui: I'm really tired but I had to get up and make my laptop transfer it's backups
00:08:44 <eds> ski. gives me an error. saying illegal kind signatures.
00:08:51 <yayfoxes> its*
00:08:58 <adarqui> i'm tired too, about to sleep
00:09:08 <yayfoxes> adarqui: and I'm using ghc, not hugs
00:09:16 <adarqui> oh ok, saw something about hugs in your paste
00:09:17 <adarqui> nice
00:09:37 <yayfoxes> adarqui: I gotta sleep too, goodnight!
00:09:57 <adarqui> gn!
00:10:37 <ski> eds : paste ?
00:11:06 <ski> eds : you enabled `KindSignatures', right ?
00:11:36 <eds> Oops, I guess not. Let me try that. 
00:11:39 <eds> ski
00:13:08 <MarcelineVQ> tried making one for fun, is this a reasonable implementation of last? http://lpaste.net/136456
00:13:32 <MarcelineVQ> doesn't have a case for empty list, I haven't done much with Maybe yet
00:13:33 <adarqui> ya, just need last [] though
00:13:56 <adarqui> using Maybe a would be more of a lastSafe function
00:14:23 <adarqui> i mean you'd expect to see lastSafe :: [a] -> Maybe a , in some safe prelude library.. is what i mean ;d
00:14:51 <MarcelineVQ> hmm
00:14:59 <MarcelineVQ> how do you do a []? we don't know what a is and I can't return a list
00:15:06 <MarcelineVQ> last [] = undefined ?
00:15:16 <adarqui> basically, do last [] in ghci
00:15:26 <adarqui> it'll show you how it's implemented
00:15:32 <adarqui> it's that nasty case of.. error
00:15:37 <ski> or `last [] = error "{last []}"', or something like that
00:15:50 <MarcelineVQ> @src last
00:15:50 <lambdabot> last [x]    = x
00:15:50 <lambdabot> last (_:xs) = last xs
00:15:50 <lambdabot> last []     = undefined
00:15:54 <MarcelineVQ> hmm
00:16:18 <MarcelineVQ> neat I implemented the same as base appearantly
00:16:21 <MarcelineVQ> *prelude
00:16:21 <adarqui> @src lastSafe
00:16:21 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:16:22 <adarqui> ya
00:16:24 <adarqui> @src lastMaybe
00:16:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:16:35 <adarqui> was wondering if they had some lib imported
00:17:14 <adarqui> MarcelineVQ: regarding the Maybe idea, https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html
00:18:08 <MarcelineVQ> Yeah there's lots of options, I haven't done much with actually using type constructors myself yet though so​ I haven' used Maybe
00:18:46 <adarqui> cool. Maybe is a good place to start though, go for it
00:18:50 <adarqui> i'm out, gn!
00:19:00 <MarcelineVQ> bai
01:02:35 * hackagebot hmm-hmatrix 0.0.1 - Hidden Markov Models using HMatrix primitives  http://hackage.haskell.org/package/hmm-hmatrix-0.0.1 (HenningThielemann)
01:07:35 * hackagebot pandoc-placetable 0.1.1 - Pandoc filter to include CSV files  http://hackage.haskell.org/package/pandoc-placetable-0.1.1 (mb21)
01:12:35 * hackagebot text-binary 0.2.1 - Binary instances for text types  http://hackage.haskell.org/package/text-binary-0.2.1 (JakubWaszczuk)
01:23:02 <jle`> does text have a Binary instance now...
01:23:16 <jle`> oh it's had one since May
01:29:45 <prinsen> Im trying to run Haskell on Android. I have successfully build a cross compiler of GHC 7.8.2, but android complains that the executable need to be a PIE (position independent executable). Is it possible to build a PIE with GHC?
01:40:48 <ocramz> hi there
01:42:19 <mvaenskae> cheers, i am currently learning haskell and reading the online book "learn you a haskell for great good" and am stuck at understanding foldr/foldl; am i correct to assume that 'foldl' basically splits the list given as input into head and tail (and operates with the head-part) and 'foldr' splits it into init and end (where end is being used)?
01:42:40 <ocramz> I'm wrapping a C library, and all the return values are integer error codes. What is a good way of mapping them to e.g. exceptions? a separate exception per error code? and how to represent the 0 case (no error), just return () ?
01:43:04 <mvaenskae> pardon, not 'end' but 'last' :)
01:44:40 <ocramz> mvaenskae: foldr/foldl are resp. right and left-associative
01:44:43 <bergmark> ocramz: how about one datatype with a constructor for each error type?
01:45:48 <ocramz> bergmark: and they all should be made instance of Exception, iiuc
01:46:13 <dramforever> ocramz: no I think bergmark means just one big data type
01:46:21 <timothyh> consider just returning an Either instead of exceptions
01:46:31 <ocramz> oh, yes I understood
01:46:34 <ocramz> thanks
01:46:36 <dramforever> ocramz: so how are the errors like?
01:46:57 <jle`> mvaenskae: that's a nice way to look at it, i think :)  but most people usually see it as, l assocates from the left, and r assocates from the right
01:47:26 <ocramz> dramforever: what do you mean?
01:47:45 <jle`> mvaenskae: so foldr (+) 0 [x,y,z] is ((x + y) + z) + 0, where foldl (+) 0 [x,y,z] is ((0 + x) + y) + z
01:47:52 <jle`> > foldr (+) 0 [x,y,z]
01:47:53 <lambdabot>  x + (y + (z + 0))
01:47:54 <dramforever> ocramz: IO error? key not found in db? invalid arguments?
01:48:03 <jle`> um yeah that's what i meant, heh
01:48:06 <jle`> > foldl (+) 0 [x,y,z]
01:48:08 <lambdabot>  0 + x + y + z
01:48:25 <jle`> foldr (+) 0 [x,y,z] is x + (y + (z + 0)), sorry
01:48:36 <jle`> mvaenskae: but what you do notice is actually a nice insight
01:48:38 <ocramz> dramforever: IO errors, for the most part. Stuff happening outside
01:48:55 <jle`> mvaenskae: for foldl, you're basically eating the list by splitting up head and tail, and chomping it up
01:49:09 <jle`> mvaenskae: for foldrl, you apply the function to the list from the "inside out", starting form the last element
01:49:40 <dramforever> ocramz: then *maybe* (yes only maybe) you should do that with exceptions
01:49:43 <ocramz> timothyh: I thought of Either as well but I have a whole host of error cases (not even sure how many error codes the underlying library has)
01:49:44 <jle`> foldr is nice because if your outermost layer doesn't require any inner layers, then laziness means you never have to think about or evaluate the inner layers
01:49:47 <mvaenskae> jle`: ah, that example makes it clearer to me :) i will see if i can understand the scanl/scanr functions with that now :)
01:49:57 <jle`> > foldr (||) False [True, True, True, undefined]
01:49:59 <lambdabot>  True
01:50:09 <dramforever> ocramz: I think exceptions are suitable for IO errors
01:50:11 <Flonk> :t x
01:50:12 <lambdabot> Expr
01:50:18 <Flonk> oh?
01:50:21 <jle`> that's True || (True || (True || (undefined || False)))
01:50:30 <jle`> and becuase || short-circuiters, it doesn't need anything past the very first True
01:50:31 <jle`> to be True
01:50:36 <jle`> *short-circuits
01:50:49 <jle`> Flonk: it's just a type from a library that has neat Num instances
01:50:57 <dramforever> > foldr const 1 (_ : undefined)
01:50:58 <lambdabot>      Found hole ‘_’ with type: b
01:50:59 <lambdabot>      Where: ‘b’ is a rigid type variable bound by
01:50:59 <lambdabot>                 the inferred type of it :: b at Top level
01:51:09 <dramforever> =( Why did I do that...
01:51:16 <jle`> just for fun?
01:51:17 <dramforever> > foldr const 1 (2 : undefined)
01:51:19 <lambdabot>  2
01:51:20 <jle`> for the thrill of it?
01:51:24 <Flonk> jle`: Pretty cool
01:51:24 <jle`> the power
01:51:35 <jle`> Flonk: yeah, the show instance goes like show x = "x"
01:51:48 <ocramz> dramforever: so one good way to think of it is that I `throw` only when error happens, otherwise I just return the value ?
01:51:58 <jle`> and the num instance goes like show (e1 + e2) = show e1 ++ " + " show e2
01:52:02 <jle`> it's pretty nift
01:52:06 <jle`> ** ++ show e2
01:52:06 <mvaenskae> jle`: out of interest on the order of evaluation, is ((x + y) + z) + 0 evaluated starting with (x + y) or what is the starting point? :)
01:52:07 <ocramz> I mean, the actual return value of the computation, not the side effect
01:52:33 <jle`> mvaenskae: it depends on the implementation of (+) you're talking about, because every type can define its own (+)
01:52:49 <jle`> um
01:52:49 <jstolarek> anyone here submitting a paper for Haskell Symposium?
01:53:01 <jle`> actually for a more useful answer, things usually move from the outside-in in ghc evaluation
01:53:02 <sveri> Hi, I am using spacemacs and haskell-mode and I hit this bug: https://github.com/kazu-yamamoto/ghc-mod/issues/491 I guess. This happens when I call haskell-process-load-file after I have a different file loaded before. So what I want to do is switch the files I am loading in ghc.
01:53:27 <jle`> mvaenskae: that expression basically generates a tree of expressions, with (+) at the top, a leaf with 0 and a leaf with (x + y) + z
01:53:41 <dramforever> ocramz: actually it's very hard to decide, but I guess it's okay =P
01:53:45 <jle`> and to evaluate the top layer it tries to evaluate the two leaves later, etc.
01:54:15 <jle`> so evaluation begins at considering the outermost (+), but the first actual addition that happens is x + y, for the normal instances at least
01:54:30 <ocramz> dramforever: anything that could help my judgement? what should I consider?
01:54:37 <mvaenskae> jle`: thanks, that makes it very clear :)
01:54:44 <jle`> if you had a bad instance of Num that chose to ignore the left side completely, then it wouldn't ever evaluate the left side
01:54:50 <jle`> for example i could define:
01:55:01 <jle`> instance Num MyType where _ + x = x
01:55:15 <jle`> but yeah, you get the picture i'm sure :)
01:55:40 <mvaenskae> i think this time i just might understand haskell and have a better foundation :)
01:55:55 <jle`> haha yeah, it usually takes a few times :)  patience is key
01:55:57 <dramforever> ocramz: well I usually think about how boring is the error. if it's something like "disk full" or "network disconnected" then I throw an exception, if it's like "key not found in db" I use an Either
01:56:16 <jle`> the best advice i've gotten on that is...try to remember how long it took you to originally learn how to program
01:56:22 <jle`> and compare your haskell progress to *that*
01:56:41 <jle`> typically for most people, they learn haskell much faster than they learned their first language.  but because that was so long ago, it feels like it takes a lot longer
01:56:50 <dramforever> and for "invalid arguments" and "internal" I use error, but it's actually a kind of exception
01:56:54 <ocramz> dramforever: but doesn't Either imply that there will be a single mode of failure? (Left e) ?
01:56:56 <mvaenskae> hehe, i am still learning C :D (but that might be because my studies are always distracting me from fully understanding it and shifting focus to other parts, like upcoming exams)
01:56:56 <dramforever> *internal error
01:57:17 <jle`> mvaenskae: ah okay.  so you understand that languages take a long time to learn in general :p
01:57:25 <dramforever> ocramz: I've never encountered a case where there are more than a few interesting error cases
01:57:36 <dramforever> ocramz: wait what do you mean?
01:58:02 <ocramz> dramforever: no, sorry, I got mixed up
01:58:54 <jle`> dramforever: neat thing with that way is you can use `left` to be able to use error sources from more than one type in a single do block for Either or EitherT :)
01:59:03 <ocramz> dramforever: Exception e => Left e just means that the return type of this will be of exception type, then the actual exception will depend on the branch taken
01:59:04 <dramforever> =)
01:59:35 <mvaenskae> jle`: is there any good ressource on how haskell works in detail and some advanced material covering topics that are not usually taught but are common knowledge in an every-day haskell environment?
01:59:36 <jle`> wait, i hope nobody is doing Exception e => Left e
01:59:41 <circ-user-YmKkx_> which Const is he talking about, http://bartoszmilewski.com/2015/04/07/natural-transformations?
01:59:41 <ocramz> jle`: do you have an example of that I can look at?
01:59:49 <dramforever> ocramz: unfortunately you are wrong
01:59:51 <circ-user-YmKkx_> Is this a standard Haskell function?
02:00:06 <ocramz> dramforever, jle` : please correct
02:00:11 <dramforever> circ-user-YmKkx_: maybe Const b a = Const { getConst :: b }
02:00:18 <jle`> mvaenskae: i think there are a few nice guides on haskell evlauation out there that i've seen posted on reddit, but i can't remember any of them in specific myself
02:00:23 <jle`> usually though you just pick it up along the way :)
02:00:27 <jle`> subscribe to the reddit ^_^
02:00:43 <mvaenskae> jle`: thanks for that recommendation, already on it :)
02:00:44 <dramforever> ocramz: that means I can give you any exception type YOU want
02:00:58 <dramforever> where for the SomeException type, it's the exception type *I* want
02:01:09 <jle`> circ-user-YmKkx_: it looks like the type dramforever posted, yeah
02:01:15 <jle`> circ-user-YmKkx_: it's in base and comes with GHC :)
02:01:18 <dramforever> well, you = function user, I = the function
02:01:45 <jle`> circ-user-YmKkx_: it's in the Control.Applicative module
02:03:05 <dramforever> ocramz: oh do you know the quantifiers exists and forall?
02:03:22 <jle`> ocramz: the strategy is, let's say you have library foo that has a function that return Either FooError Int, and a library bar that has a function that returns Either BarError Int
02:03:29 <ocramz> dramforever: haven't used them yet, but I know they exist
02:03:36 <jle`> ocramz: if you have a way to reduce the two to one big type, or combine them into one
02:03:49 <jle`> say, f :: FooError -> BigError, g :: BarError -> BigError
02:03:52 <dramforever> ocramz: I mean in logic
02:04:00 <jle`> then you can do `left f :: Either FooError a -> Either BigError a`
02:04:00 <ocramz> dramforever: yes
02:04:06 <jle`> and `left g :: Either BarError a -> Either BigError a`
02:04:22 <jle`> so you can combine the two into one common `Either e`, and then use do notation on that, or EitherT, etc.
02:04:30 <dramforever> so type variables in haskell can only be universally quantified
02:04:59 <dramforever> i.e. in Exception e => Either e Val the function user gets to pick the e
02:04:59 <ocramz> dramforever: for all
02:05:02 <circ-user-YmKkx_> when you say that morphisms are not functions, do you mean that they can be one to many, unlike function or soemthing different?
02:05:37 <ocramz> jle` : I will need to process your example offline, thanks :)
02:05:47 <ski> dramforever : in `forall e. Exception e => Either e Val', the function user gets to pick the `e'
02:05:49 <jle`> np!
02:05:53 <dramforever> ski: yes
02:06:01 <dramforever> hmm...why are you posting that?
02:06:56 <ski> dramforever : if you have just `Exception e => Either e Val', then it could e.g. occur as the argument type in `forall e. (Exception e => Either e Val) -> ..e..', and then the user of this function argument does *not* get to pick `e'
02:07:23 <ocramz> ski: I'm afraid I don't follow
02:07:37 <ski> it's the placement (and the kind) of quantifier that determines who gets to pick
02:07:39 <dramforever> ski: hmm...that's interesting =P I admit I'm sloppy
02:08:19 <ski> ocramz : in `Exception e => Either e Val' `e' is not bound. you can't say who gets to pick it, without more context
02:09:28 <ski> `exists' is useful in reasoning about types (e.g. refactoring them)
02:09:43 <ocramz> so e.g. Marlow p.149 does a .. coercion? (e :: SomeException)
02:10:30 <ski> when you actually implement, you need to express it either with an "existentially quantified data type" (somewhat of a misnomer), or encoded via CPS
02:11:49 <ski> (i think LHS actually supports `exists' in syntax, but only as a function argument type, so one doesn't really get more power, just perhaps somewhat more convenience (if one can hide it behind a type synonym))
02:11:56 <ski> (er, s/LHS/LHC/)
02:12:33 <ocramz> ski: LHC ?
02:12:51 <ski> @where LHC
02:12:51 <lambdabot> http://lhc.seize.it/
02:15:39 <ski> given a type `t', you can express it as `forall o. (t -> o) -> o' (CPS wrapping)
02:16:36 <ski> given a type `t', you can express it as `exists s. (s,s -> t)'
02:17:41 <dbushenko> hi all!
02:17:46 <ocramz> ski: why the tuple notation in particular?
02:17:51 <dbushenko> is there a ghc-mod which works with stack?
02:17:51 <ski> given a type `f t', `f' being a (covariant) functor, you can express it as `forall o. (t -> o) -> f o' (Yoneda)
02:18:24 <ski> given a type `f t', `f' being a (covariant) functor, you can express it as `exists s. (f s,s -> t)' (CoYoneda)
02:19:13 <ski> ocramz : that is a tuple type
02:20:23 <ski> (for `f' a contravariant functor, you use `o -> t',`t -> s' in place of `t -> o',`s -> t')
02:22:04 <ocramz> ski: Yoneda and CoYoneda seem to be statements on the non-emptiness of range and domain, respectively
02:22:07 <ski> given an inductive type `mu o. ..o..' (`..o..' being covariant in `o'), you can express it as `forall o. (..o.. -> o) -> o'
02:22:45 <ski> given a coinductive type `nu s. ..s..' (`..s..' being covariant in `s'), you can express it as `exists s. (s,s -> ..s..)'
02:23:06 <ocramz> ski: ok, I admit all of this is way out of my depth. It all started as a request for advice regarding mapping of error handling across languages
02:25:58 <ski> e.g., the list type `[a]' is iso to `1 + a * [a]'. ignoring non-finite lists, it is inductive, so `[a]' is `mu o. 1 + a * o', so it can be expressed as `forall o. ((1 + a * o) -> o) -> o', which is `forall o. (1 -> o) * (a * o -> o) -> o', which is `forall o. o * (a -> o -> o) -> o', which is `forall o. o -> (a -> o -> o) -> o'
02:26:47 <ski> @type \nil cons -> foldr cons nil [False,True,False]
02:26:47 <lambdabot> b -> (Bool -> b -> b) -> b
02:27:00 <ocramz> ski: I mean, don't get me wrong, thank you for all this explanation but I'm not a PL theorist and don't quite see the connections yet
02:27:00 <ski> represents that list of booleans in this form
02:28:03 <ski> do you follow the derivation from `[a]' ?
02:29:10 <ski> btw, the above statements were just intended as example type refactorings where it can be useful to conceptually use `exists' (and `forall')
02:30:08 <ski> (also, perhaps you can elaqborate on your "non-emptiness of range and domain" comment, since i didn't understand what you had in mind)
02:32:31 <ski> ocramz : .. i missed the start of the discussion. i was just chiming in a bit on `forall' and `exists'
02:33:33 * ski has been pondering the last few days how one could possibly use the `exists s. (s,s -> ..s..)' form to get a kind of list fusion
02:34:10 <ski> (btw, in case it's not clear, the types `0
02:34:45 <ski> (btw, in case it's not clear, the types `0',`1',`a + b',`a * b' are just a more "algebraic" notation for the Haskell `Void',`()',`Either a b',`(a,b)')
02:36:41 <ski> (.. and `a -> b' corresponds to `b^a'. i used the general law `c ^ (a + b)  =  (c ^ a) * (c ^ b)' above, as well as `c ^ (a * b)  =  (c ^ b) ^ a' and `a ^ 1  =  a')
02:40:28 <ocramz> ski: so logical implication is associative, or smthg
02:42:28 <ocramz> no, I should rephrase
02:42:45 <ocramz> we have an associative operation over types with a neutral element
02:44:56 <ski> mvaenskae : assuming call-by-need (or call-by-name), `((x + y) + z) + 0' starts by handing over control to the outermost `+', which may or may not then demand to know the outermost data constructor of its arguments in some order
02:45:38 <ski> ocramz : hm, yes. i think when `Exception e => Either e Val' was mentioned. probably `exists e. Exception e *> Either e Val' was intended
02:46:35 <ski> ocramz : `->' is not associative (`*'/`(,)' is, with `1'/`()' as neutral element. also `+',`Either' is, with `0',`Void' as neutral element)
02:46:57 <dramforever> actually IIUC (exists a. P(a)) -> (forall r. (forall a. P(a) -> r) -> r)
02:47:11 <ski> (also, this is ignoring partial values with bottoms, which often doesn't matter anyway)
02:47:35 <ski> dramforever : yes, that's the CPS encoding
02:48:05 <dramforever> ski: hmm...yes it is
02:48:16 <dramforever> but I'm referring to logic
02:48:18 <ski> `exists a. ..a..' is (by CPS) `forall r. ((exists a. ..a..) -> r) -> r', which by a logical law is `forall r. (forall a. (..a.. -> r)) -> r'
02:48:38 <dramforever> wait are you sure?
02:48:56 <prinsen> Im trying to run Haskell on Android. I have successfully build a cross compiler of GHC 7.8.2, but android complains that the executable need to be a PIE (position independent executable). Is it possible to build a PIE with GHC?
02:49:02 * ski is referring to both logic and types, at the same time
02:49:14 <dramforever> I doubt if ski was correct
02:49:24 <ski> dramforever : which step do you doubt ?
02:49:47 <dramforever> "by CPS", I doubt if you could do that with an existential quantifier
02:50:12 <dramforever> prinsen: I found the flag -fPIC, try it
02:50:16 <ski> i was using
02:50:20 <ski> <ski> given a type `t', you can express it as `forall o. (t -> o) -> o' (CPS wrapping)
02:50:24 <dramforever> PIC = position independent code
02:50:38 <prinsen> drewdavis: ghc says that -fPIC or -dynamic cant be used on the platform
02:50:45 <ski> and i was allowing the meta-variable `t' to stand for a (existentially) quantified type
02:50:47 <dramforever> ski: Hmm...okay if that's right =P
02:50:48 <prinsen> dramforever: ^
02:51:07 * dramforever doesn't really know about it, he just heard of this flag
02:51:14 <dramforever> in gcc docs, actually
02:53:20 <ski> dramforever : to prove `(forall r. (forall a. ..a.. -> r) -> r) -> (exists a. ..a..)' you'd need to (impredicatively ?) instantiate `r' with `exists a. ..a..'
02:53:52 <ski> (or else you can wrap `exists a. ..a..' behind a new data type)
02:54:07 <dramforever> yeah I'm not really sure about the "impredicatively" part =P
02:56:58 <ski> @let data Exists f = forall x. Wrap (f x)
02:56:59 <lambdabot>  Defined.
02:57:06 <ski> @type let fwd :: Exists f -> (forall r. (forall a. f a -> r) -> r); fwd (Wrap fx) far = far fx in fwd
02:57:07 <lambdabot> forall (k :: BOX) (f :: k -> *) r. Exists f -> (forall (a :: k). f a -> r) -> r
02:57:11 <ski> @type let bwd :: (forall r. (forall a. f a -> r) -> r) -> Exists f; bwd far = far Wrap in bwd
02:57:12 <lambdabot> forall (k :: BOX) (f :: k -> *). (forall r. (forall (a :: k). f a -> r) -> r) -> Exists f
02:58:57 <dramforever> =) thanks now I believe it
02:59:06 <dramforever> it did took a while =)
03:01:00 <ski>      bwd . fwd
03:01:07 <ski>   =  \(Wrap fx) -> bwd (fwd (Wrap fx))
03:01:17 <ski>   =  \(Wrap fx) -> bwd (\far -> far fx)
03:01:29 <ski>   =  \(Wrap fx) -> Wrap fx
03:01:33 <ski>   =  id
03:01:38 <dramforever> =)
03:07:44 <ski> hm .. i wonder whether the other direction requires parametricity
03:17:41 * hackagebot lentil 0.1.2.5 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.5 (fffaaa)
03:20:13 <d125q> Can anyone point me to some docs that explain how the layout rule comes into play with regards to the scope of the bindings in a where-expression?
03:32:41 * hackagebot lentil 0.1.2.6 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.6 (fffaaa)
03:47:15 <bennofs> Is there a testing library to test more complex, multi-threaded functions? I'm writing a library helping the implementation of FRP frameworks, and I'd like to test such things as "when I trigger event A, event B fires as a result"
03:56:30 <cYmen> Are there any good hs->js compilers? Anything somebody actually uses...? :)
03:59:20 <bennofs> cYmen: ghcjs supports almost all of Haskell (event TemplateHaskell) and is used afaik
04:00:22 <bennofs> cYmen: I heard that people used in production together with reflex/reflex-dom (FRP library) to build web apps
04:04:52 <cYmen> okay
04:04:55 <cYmen> sounds interesting
04:07:43 * hackagebot cef 0.1.2 - CEF log format  http://hackage.haskell.org/package/cef-0.1.2 (utdemir)
04:09:11 <mniip> under curry-howard correspondence, ∨ is Either, right
04:10:20 <dramforever> yes, it corresponds to sum type(s?)
04:12:33 <mniip> hmm
04:12:40 <ski> intuitionistic disjunction, yes
04:12:43 * hackagebot MonadStack 0.1.0.3 - Generalizing lift to monad stacks  http://hackage.haskell.org/package/MonadStack-0.1.0.3 (bhurt)
04:13:02 <mniip> curry-howard correspondence can't handle classical logic though, that is, negation and lem
04:13:16 <mniip> or can it
04:13:30 <dramforever> mniip: well what about type Not a = a -> Void
04:13:31 <ski> or, alternatively, classical logic can't handle curry-howard
04:14:05 <ski> @djinn NotNot (Either a (Not a))
04:14:05 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
04:14:17 <mniip> dramforever, Either a b ~ (a -> Void) -> b ?
04:14:30 <dramforever> wait what's ~
04:14:44 <mniip> in this case, isomorphic equality
04:15:01 <dramforever> why do you think so
04:15:09 <ski> @djinn Not (a,b) -> NotNot (Either (Not a) (Not b))
04:15:09 <lambdabot> f a b = void (b (Right (\ c -> void (b (Left (\ d -> a (d, c)))))))
04:15:32 <mniip> because in classical logic, a or b == not a => b
04:15:32 <dramforever> @djinn NotNot a -> a
04:15:32 <lambdabot> -- f cannot be realized.
04:15:42 <ski> `NotNot' is a monad
04:16:13 <dramforever> yeah it's an instance of codensity
04:16:23 <ski> @djinn (a -> Not b) -> (b -> Not a)
04:16:24 <lambdabot> f a b c = a c b
04:16:51 <mniip> @djinn (a -> b) -> (Not a -> Not b)
04:16:51 <lambdabot> -- f cannot be realized.
04:17:03 <mniip> oops
04:17:04 <mniip> @djinn (a -> b) -> (Not b -> Not a)
04:17:05 <lambdabot> f a b c = b (a c)
04:17:05 <ski> @djinn (a -> b) -> (Not b -> Not a)
04:17:05 <lambdabot> f a b c = b (a c)
04:17:12 <ski> @djinn Either (Not a) b -> (a -> b)
04:17:12 <lambdabot> f a b =
04:17:12 <lambdabot>     case a of
04:17:12 <lambdabot>     Left c -> void (c b)
04:17:12 <lambdabot>     Right d -> d
04:17:20 <ski> @djinn (a -> b) -> Not (a,Not b)
04:17:21 <lambdabot> f a (b, c) = c (a b)
04:17:36 <mniip> what about
04:17:50 <mniip> @djinn Either a b -> (Not a -> b)
04:17:50 <lambdabot> f a b =
04:17:50 <lambdabot>     case a of
04:17:50 <lambdabot>     Left c -> void (b c)
04:17:50 <lambdabot>     Right d -> d
04:17:54 <mniip> okay
04:18:04 <ski> @djinn NotNot (Either (a -> b) (b -> a))
04:18:04 <lambdabot> f a = void (a (Right (\ b -> void (a (Left (\ _ -> b))))))
04:18:36 <mniip> so what's NotNot
04:18:51 <ski> @djinn (Either a (Not a) -> Not b) -> Not b
04:18:51 <lambdabot> f a b = void (a (Right (\ c -> a (Left c) b)) b)
04:18:57 <ski>   type NotNot a = Not (Not a)
04:19:23 <mniip> interesthing
04:19:29 <ski> @djinn (Not a -> b) -> Either a b
04:19:29 <lambdabot> -- f cannot be realized.
04:19:32 <dramforever> @@ @pl @djinn (a -> b) -> (Not b -> Not a)
04:19:32 <lambdabot>  f = flip (.)
04:20:13 <ski>   void :: Void -> a
04:20:19 <ski>   void v = case v of {}
04:20:50 <mniip> so bascially bottom
04:21:03 <ski> no terminating alternative
04:21:34 <mniip> technically speaking bottom does include terminating computations
04:21:42 <mniip> specifically ones that result in errors
04:21:55 <mniip> @djinn (Not (Not a -> b) -> c) -> (Not a -> (Not b -> c))
04:21:55 <lambdabot> f a b c = a (\ d -> void (c (d b)))
04:21:56 <ski> (operationally, that ought to force `v', to blame the appropriate error or `undefined', if passed in)
04:22:30 <mniip> so how does one interpret this proof...
04:22:34 <ski> well, by terminating, i intended "normally terminating" (as opposed to aborting)
04:24:08 <ski> the `void' there is redundant
04:25:59 <ski> we have `a :: Not (Not a -> b) -> c',`b :: Not a',`c :: Not b'. we assume `d :: Not a -> b' and form `d b :: b' and then `c (d b) :: Void'. thus we have `\d -> c (d b) :: Not (Not a -> b)' and so we can form `a (\d -> c (d b)) :: c', as required
04:27:05 <ski> (`void' there was used with type `Void -> Void', but this is just `id', and so can be removed)
04:30:36 <narendraj9> How do you type the comments at the top of a module? Some snippet? Or manually?
04:33:08 <tdammers> narendraj9: using a keyboard? idk, what is your problem?
04:34:40 <narendraj9> tdammers: How are the colons are all aligned in the modules on hackage? If I type everything, I may have to re-adjust the column of the colons. Module: Copyright: License: {These colons}.
04:35:33 <narendraj9> Anyways. I was just curious if there are any tools that I am missing. Maybe there aren't any.
04:36:05 <bergmark> M-x align-regexp? :-)
04:36:40 <skrio> Does anyone know how Database.Persist represents Lists in the database? Say you tell it to store ['a','b','c'], how is that represented in the database table?
04:36:40 <dramforever> narendraj9: I copy from other code, for example when I start I go into lens and pick a file and copy the header
04:36:52 <dramforever> when I create more modules I copy the header
04:36:57 <dramforever> oh of course I edit them
04:37:20 <narendraj9> dramforever: Okay. 
04:37:40 <narendraj9> bergmark: That looks useful. Let me read the help. Thanks.
04:37:55 <dramforever> narendraj9: btw I don't think you'll remember how many dashes you need to type =)
04:38:53 <narendraj9> dramforever: C-u 80 -
04:38:56 <narendraj9> ;)
04:39:13 <dramforever> oh you actually know the number !!! =P
04:40:37 <narendraj9> :-D 80 is slightly less arbitary than any other number, thanks to the Linux guys. But I checked the module that I am looking into now, it has 77. 
04:40:55 <narendraj9> 76.
04:41:02 <bergmark> my limit is when i have the screen split in half, currently 114
04:41:44 <dramforever> Actually I don't know how many dashes I have
04:42:28 <narendraj9> bergmark: I have global whitespace mode on for the 80-rule. Not that I follow it strictly, just a reminder than I need to do something about it.
04:44:00 * dramforever has OCD, that works waaaaaay better
04:46:43 <fr33domlover> hello
04:46:47 <maerwald> I am confused why there is no such a thing like "maybeReadFile :: FilePath -> IO (Maybe String)" which returns Nothing if the file does not exist
04:47:12 <fr33domlover> can Haddock generally take document for function arguments of record fields that are functions?
04:47:15 <maerwald> or some other thing that has even better error handling
04:47:22 <lpaste> ryantrinkle revised “DataKind with custom proxy”: “No title” at http://lpaste.net/136471
04:47:56 <fr33domlover> maerwald, maybe it uses exceptions for that?
04:48:11 <dramforever> @wiki Type witness
04:48:11 <lambdabot> http://www.haskell.org/haskellwiki/Type_witness
04:48:25 * dramforever is reminded of this ^
04:48:55 <ryantrinkle> does anyone have a suggestion for how I can improve the pasted code?  I have a simple enumeration type that i'm promoting, and I'd like to create a Proxy-like type to use with it
04:49:19 <ryantrinkle> the trouble is that i need to be able to case on the Proxy to recover the type information
04:49:21 <maerwald> fr33domlover: the documentation of readFile does not say anything about exceptions or error handling
04:49:39 <ryantrinkle> so, right now, i'm writing out a GADT that just mirrors the promoted type
04:49:43 <ryantrinkle> is there a better way?
04:49:46 <ryantrinkle> http://lpaste.net/136471
04:50:08 <fr33domlover> *** Exception: lolz: openFile: does not exist (No such file or directory)
04:50:11 <fr33domlover> maerwald, ^
04:50:11 <Rasvi> Hi guys
04:50:15 <fr33domlover> this happens
04:50:27 <fr33domlover> maerwald, before usage, check if the file exists...
04:50:38 <fr33domlover> or catch the exception, depending on your logic I guess
04:50:48 <dramforever> Rasvi: hi =P
04:50:54 <maerwald> fr33domlover: err, I know... I have already written the function, but I wonder why it is not there
04:51:15 <maerwald> because I think that's a fairly common use case
04:51:30 <maerwald> e.g. opening configuration which might or might not be there
04:51:33 <maerwald> or whatnot
04:51:47 <fr33domlover> maerwald, that would be common only for totally optional files you open at once
04:51:53 <fr33domlover> config files are usually parsed etc.
04:52:04 <fr33domlover> s/open at once/read at once
04:52:27 <maerwald> fr33domlover: yes, I use Data.ConfigFile for that
04:52:57 <maerwald> I still think it is weird to not have an "openFile" function that has proper _haskell_ error handling
04:53:02 <maerwald> as in: not random exceptions
04:54:48 <maerwald> but represented by the type system
05:02:04 <Gurkenglas> http://hackage.haskell.org/package/random-1.0.0.2/docs/System-Random.html <- "but very little work has been done on statistically robust implementations of split" <- does this mean recursive splits might get me a significant slowdown, or using split might break some randomness properties of the generator, or what?
05:02:42 <tdammers> it means that nobody knows for sure what the randomness properties are for an RNG created with split
05:02:43 <dramforever> IIUC "statistically robust" means "good randomness"
05:02:45 * hackagebot docker 0.2.0.1 - Haskell wrapper for Docker Remote API  http://hackage.haskell.org/package/docker-0.2.0.1 (denibertovic)
05:03:30 <maerwald> Gurkenglas: use case? cryptography?
05:03:45 <maerwald> then I'd avoid it probably
05:04:02 <tdammers> yeah, if randomness is important, don't use System.Random
05:04:54 <Gurkenglas> Nothing important, just worrying whether these few code lines in a game map generator can be without consequence replaced by splitting, taking the first three out of a stream, then throwing it away.
05:08:32 <dramforever> IIUC you should use newStdGen to get a generator rather than getStdGen
05:08:55 <dramforever> newStdGen does the split for you
05:13:02 <Phillemann> I have a file that contains certain XML tags as well as other stuff, so "foo<x>bar</x>baz<x>qux</x>...". I'd like to extract the XML tags and return ["<x>bar</x>","<x>qux</x>"]
05:13:11 <Phillemann> Would you use parsec/attoparsec for that?
05:13:19 <ski> @type replicateM 3 randomIO
05:13:19 <Phillemann> I'd need some lookahead
05:13:20 <lambdabot> Random a => IO [a]
05:13:23 <ski> @type System.Random.getStdRandom . runState . replicateM 3  :: State StdGen a -> IO [a]
05:13:24 <lambdabot> State StdGen a -> IO [a]
05:13:38 <cow_2001> GUS!
05:13:44 <cow_2001> :t (.)
05:13:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:13:49 <cow_2001> :t (<<<)
05:13:50 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
05:14:02 <cow_2001> they look the same but different!
05:14:17 <ski> yes ?
05:14:36 <ski> `(<<<)' is a generalization
05:14:38 <cow_2001> (.) is (<<<) on (->)!
05:14:40 <dramforever> :t Control.Category.(<<<)
05:14:41 <lambdabot>     Not in scope: data constructor ‘Control.Category’
05:14:52 <ski> @type (Control.Category.<<<)
05:14:53 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
05:14:53 <cow_2001> ZOMFG
05:14:54 <ChristianS> Phillemann: why not use a dedicated xml parser such as hexpat?
05:15:07 <Phillemann> ChristianS: The thing is, the whole file is not XML, just parts of it (it's a log file).
05:15:32 <ChristianS> Phillemann: oh, that sounds like a mess
05:15:36 <cow_2001> where's bernalex i want to frown at him
05:16:00 <Phillemann> ChristianS: Well, I could just use the functions from Data.Text, but that's tedious.
05:16:12 <Phillemann> The problem is easy because I know which tag to extract, and it's just one.
05:16:57 <dramforever> looks just plain text searching will do =)
05:31:52 <Gurkenglas> cow_2001, because he used (<<<) where (.) would have done?
05:31:59 <cow_2001> !tell bernalex why use (>>>) instead of (.) in blubber-server.hs?
05:32:09 <cow_2001> !say bernalex why use (>>>) instead of (.) in blubber-server.hs?
05:32:12 <Gurkenglas> wait
05:32:19 <Gurkenglas> before you use @tell or anything
05:32:27 <cow_2001> yes
05:32:40 <cow_2001> i'm confused
05:32:49 <Gurkenglas> It's because (>>>) is flip (.) and he probably likes it more when data comes from the left where you start reading and is passed to the right
05:33:01 <cow_2001> huh
05:33:35 <cow_2001> but then you have that input sitting on the right
05:34:05 <cow_2001> it's used instead of three lets
05:34:10 <cow_2001> in a do block
05:35:02 <silver> it must be hard, you guys write form right to left all the time :P
05:35:12 <Gurkenglas> >>> composes functions, and the result is still a function that has to be applied. If he was told of it, he might have used (&) instead of ($) to put the data into the left end.
05:35:29 <silver> oh wrong channel ;(
05:35:29 <tdammers> silver: is that why people invented =<< ?
05:36:07 <Gurkenglas> If he used let, he would have to invent names for all the intermediate results. I have the feeling that the longer you program, the more painful choosing names gets.
05:36:35 <cow_2001> silver: hebrew?
05:36:55 <silver> yeah
05:40:55 <cow_2001> Gurkenglas: where do i get &
05:41:18 <maerwald> @hoogle (&)
05:41:19 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
05:41:19 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
05:41:19 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
05:41:55 <nabokovian>  @hoogle (<$>)
05:42:08 <Gurkenglas> Weird, that hoogle must be based on something deprecated. https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Function.html
05:42:21 <maerwald> hm
05:43:09 <cow_2001> cool!
05:48:01 <cow_2001> awww it's not on stackage lts :(
05:48:23 <cow_2001> base-4.7.0.2 on lts
05:51:12 <comprehension> what's the point of using "cabal install --dependencies-only" vs "cabal install"?
05:51:36 <maerwald> comprehension: when you don't want to install it, but just build
05:51:52 <maerwald> e.g. local development
05:51:56 <comprehension> maerwald: so if i'm using a sandbox, they're equivalent?
05:52:00 <maerwald> no
05:52:05 <maerwald> it installs it in the sandbox then
05:52:49 <comprehension> maerwald: okay. is there a situation where that could cause a problem, as long as it stays confined to the sandbox?
05:53:09 <comprehension> i see why i would be worried about polluting the global package database
05:53:32 <tdammers> faster compilation maybe
05:56:56 <c_wraith> usually you use --dependencies-only when you're working on a package
05:57:48 * hackagebot formatting 6.2.1 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.2.1 (ChrisDone)
05:57:58 <nomeata> Hi. Anyone else here that is accepted at Haskell'15 and is confused about us now having to use a different LaTeX class file than for the initial submission?
06:01:31 <Taneb> nomeata, I'm afraid this is a channel for the programming language Haskell, which has no connection to the similarly-named university
06:02:48 * hackagebot hledger-irr 0.1.1.7 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.7 (JoachimBreitner)
06:03:07 <maerwald> Taneb: we should have named it "Curry", less confusion :P
06:03:19 <pharpend> maerwald: that name was taken
06:03:34 <pharpend> maerwald: so was "brooks"
06:03:43 <bernalex> too many jokes with "curry".
06:04:14 <pharpend> maerwald: This is the first confusion I've witnessed. Haskell is a good name for a programming language
06:04:43 <maerwald> make it NewCurry then
06:04:46 * geekosaur *eyeroll*
06:05:20 <bernalex> I've also never heard anyone confuse it with the university before. and anything involving "curry" would be asking for weird jokes.
06:05:31 <c_wraith> People do confuse it with Pascal, though.
06:05:43 <c_wraith> Which is odd, since they're really not pronounced anything alike.
06:06:21 * geekosaur is pretty sure Haskell'15 refers to a conference related to the programming language...
06:06:28 <geekosaur> (esp. since nomeata is not a newcomer)
06:06:46 <bernalex> c_wraith: ? they're quite similarly pronounced
06:06:54 <pharpend> geekosaur: quit it with your facts. It's too early in the morning for people to actually read stuff
06:06:55 <geekosaur> https://www.haskell.org/haskell-symposium/2015/
06:07:15 <bernalex> c_wraith: one of the ways to pronounce pascal is ˈpæskl̩, and you may pronounce haskell 'hæskl.
06:07:36 <c_wraith> bernalex: As far as I've ever heard, Pascal has stress on the second syllable, not the first.
06:07:42 <bernalex> maybe if you're American it's more different.
06:07:56 <pharpend> bernalex: I don't know IPA, but I've only heard Haskell pronounced the normal way with the emphasis on either syllable
06:08:10 <pharpend> bernalex: Emphasis on the first syllable is much more common 
06:08:17 <bernalex> c_wraith: there's the pæskəl pronounciation, and I've heard haskell pronounced similarly.
06:08:20 <maerwald> very interesting
06:08:29 <bergmark> when i was in the us several software-ish people asked me about my work and thought i said "Pascal"
06:08:47 <ryantrinkle> fwiw, in NYC everyone says HASK-ul
06:08:49 <pharpend> bernalex: I had a friend in high school who would habitually say the word "patent" with a hard A
06:08:56 <geekosaur> pas-CAL v HAS-k'l
06:09:09 <c_wraith> Lots of Americans don't know how to pronounce Pascal, though.  Americans are terrible at French names.
06:09:14 <pharpend> hasKELL
06:09:34 <pharpend> c_wraith: pay scale
06:09:36 <maerwald> I say paskall and häskell
06:09:50 <bernalex> pharpend: I don't know what you mean by a "hard a" really. I would pronounce it ˈpeɪtənt.
06:09:52 <c_wraith> maerwald: but where do you put the stress?
06:10:01 <c_wraith> bernalex: hard a as in cake
06:10:09 <bernalex> I do that
06:10:19 <pharpend> bernalex: it might be an american way of describing the a as in "bakery" or "fake"
06:10:22 <bernalex> that's one of the two ways it's pronounced in English.
06:10:51 <maerwald> c_wraith: for paskall the second syllable, for häskell the first... and you can't stop me :D
06:11:05 <c_wraith> maerwald: why would I?  Those are the correct syllables. :)
06:11:13 <maerwald> coincidence
06:11:26 <pharpend> It's "pay scale" and "hay skull"; end of discussion
06:11:28 <pharpend> =p
06:11:31 <bernalex> I'd say ˈpæskl̩ with emphosis on the first and 'hæskl with emphasis on the first.
06:11:45 <bernalex> emphasis as well as emphosis. :p
06:11:45 <maerwald> how did we end up here?
06:12:11 <bernalex> "people can't confuse pascal and haskell because they're not pronounced similarly"
06:12:22 <maerwald> glad we talked about it
06:12:29 <pharpend> maerwald: someone asked about a conference, someone else interpreted that as asking about Haskell-the-university, someone complained about the name "Haskell", we started talking about pronounciation
06:12:42 <bernalex> were I speaking French I'd say pas.kal fwiw.
06:12:45 <comprehension> why is cabal telling me i'm missing alex and happy right after it installs them? error: http://lpaste.net/136475
06:12:59 <pharpend> comprehension: because you aren't using stack =p
06:13:03 <bergmark> comprehension: the executables are needed in your PATH
06:13:08 <geekosaur> because the directory it installed them in is not in your $PATH
06:13:17 <pharpend> comprehension: yep, $PATH stuff
06:13:27 <maerwald> yep, cabal cannot handle build-tools very well
06:13:34 <geekosaur> this will be ~/.cabal/bin on most unixes, may be ~/Library/Haskell/bin on OS X. I don't know what directory on Windows
06:13:36 <pharpend> comprehension: that has to be the weirdest $PS1 I've ever seen
06:13:47 <maerwald> geekosaur: he's in a sandbox
06:13:52 <comprehension> okay. i had been trying to install it in a sandbox --- should i just grab it from apt-get instead?
06:13:55 <maerwald> /home/patrick/hacking/haskell/ansi-parser/.cabal-sandbox/bin probably
06:14:02 <comprehension> pharpend: it's on zsh
06:14:06 * geekosaur just got the paste loaded, yeh
06:14:13 <pharpend> comprehension: you should add this to your zshrc
06:14:22 <maerwald> comprehension: export PATH="/home/patrick/hacking/haskell/ansi-parser/.cabal-sandbox/bin:$PATH"
06:14:23 <pharpend> comprehension: PATH=$PATH:.cabal-sandbox/bin
06:14:45 <pharpend> comprehension: don't do maerwald's thing, because mine will work with *any* sandbox, not just that particular sandbox
06:14:50 <geekosaur> hm, actually shouldn't cabal be automatically adding the sandbox bin dir to its $PATH?
06:14:59 <comprehension> pharpend: neat trick, that didn't occur to me
06:15:12 <comprehension> i didn't know relative paths in your $PATH worked like that
06:15:15 <bergmark> geekosaur: only if you do cabal repl i think
06:15:28 <maerwald> relative stuff in $PATH is dangerous
06:15:31 <bernalex> geekosaur: no but you can just use cabal run, so it's not an issue imo.
06:15:32 <geekosaur> ^
06:15:43 <pharpend> maerwald: it's voodoo
06:15:44 <bernalex> and relative stuff in $PATH is a bad idea.
06:15:49 <maerwald> exactly
06:15:58 <pharpend> bernalex: maerwald why do you say it's a bad idea?
06:16:03 <geekosaur> that seems kinda broken, I should not need to add stuff to $PATH, especially relative stuff
06:16:15 <comprehension> i guess i'll just make a script and source it whenever i'm working on this package
06:16:21 <pharpend> geekosaur: stack does it properly, but ... i dunno
06:16:28 <geekosaur> pharpend, programs may change directory to places you do not have control over which have unexpected stuff in those paths
06:16:36 <bernalex> comprehension: sorry, why do you need things in $PATH?
06:16:48 <maerwald> bernalex: because of build tools like alex
06:16:58 <maerwald> that was almost a pun
06:17:05 <geekosaur> bernalex, the start of this is that cabal installed alex and happy in the sandbox and then couldn't find them
06:17:10 <bernalex> omg
06:17:11 <pharpend> comprehension: it would be a good idea to install alex and happy globally
06:17:23 <bernalex> well that's embarrassing
06:17:27 <pharpend> comprehension: then you wouldn't need to deal with a relative path
06:17:53 <comprehension> bernalex: cabal complains that it can't find alex and happy after installing them
06:18:02 <bergmark> i have a sandbox for all executables like this that i put in my path
06:18:08 <pharpend> geekosaur: hmm. I use relative $PATH entries, never seen that happen. *shrug*
06:18:12 <bernalex> comprehension: yes I looked at the paste. it's silly.
06:18:27 <pharpend> comprehension: that's the weirdest $PROMPT I've ever seen =p
06:18:43 <pharpend> comprehension: also yay another zsh user
06:18:51 <bernalex> ? it's very common. I've seen it.
06:19:03 <geekosaur> pharpend, an old way to steal root access, back when . was a common thing in $PATH, was to leave a trojan "test" somewhere and get a sysadmin to run a shell script where it was
06:19:06 <comprehension> bah, global installation it is, i guess
06:19:18 <bernalex> I even had it before I changed it a bit
06:19:25 <maerwald> > 4 & odd
06:19:26 <lambdabot>  False
06:19:30 <bernalex> I now have '→                                                                                                        alexander@hackintosh:/home/alexander/git/blubber/blubber-server git:(master)' heh
06:19:34 <pharpend> wat
06:19:56 <maerwald> > 4 & odd & not
06:19:57 <lambdabot>  True
06:19:59 <maerwald> xD
06:20:07 <maerwald> I like it
06:20:20 * pharpend grabs maerwald and tosses him to #ruby
06:20:22 <maerwald> need ghc 7.10 for that?
06:20:23 <bernalex> that's a very tedious way to write it
06:20:25 <geekosaur> (the "test" copied /bin/sh somewhere the stealing user could access it and chmod u+s it, then exec()ed the real one)
06:20:37 <bernalex> maerwald: I put it in base (Data.Function) for 7.10.
06:20:44 <bernalex> maerwald: it's also in lens -- of course.
06:20:49 <bernalex> maerwald: you can just define it yourself though.
06:20:58 <maerwald> bernalex: I am lazy
06:21:02 <maerwald> but I know^^
06:21:08 <bernalex> well I mean
06:21:12 <bernalex> x & f = f x
06:21:19 <bernalex> it's not exactly hard work lol
06:21:21 <maerwald> right, still a lot of work to write
06:21:39 <bernalex> & = flip id
06:21:48 <maerwald> I'd rather spend 30minutes trying to install ghc-7.10 and then break all my haskell packages
06:21:50 <bernalex> since you know $ is just id monomorphic to functions anyway
06:22:54 <bernalex> (well, tbf, it's not, it has special typing rules which makes it magic)
06:23:11 <bernalex> (note that & does not have these magic superpowers)
06:23:24 <maerwald> bernalex: afair that was something because of donation and stuff?
06:23:36 <bernalex> donation?
06:23:41 <maerwald> do-notation
06:23:43 <maerwald> xD
06:24:13 <maerwald> omg, that must have sounded weird
06:24:45 <boj> so awkward
06:26:06 <bernalex> maerwald: $ has a special typing rule that gives it impredicative polymorphism. GHC can't do that in general.
06:26:26 <comprehension> so i added alex and happy to my path, but still no dice: http://lpaste.net/136476 what am i missing here?
06:26:31 <bernalex> according to SPJ afair, impredicative polymorphism was "Too Jolly Complicated to live in GHC".
06:28:39 <adamse> comprehension: does --with-happy=/path/to/happy and --with-alex=... make any difference?
06:29:53 <comprehension> adamse: for configure or build?
06:29:59 <adamse> configure
06:30:09 <adamse> I would assume
06:31:26 <comprehension> adamse: no
06:31:52 <comprehension> it also keeps reinstalling them every time i run cabal install. i'll try nuking the sandbox and rebuilding it
06:34:52 <comprehension> adamse: trying "cabal install --with-alex=$(which alex) --with-happy=$(which happy)" fails with "cabal: InstallPlan: internal error: configured package depends on a non-library package"
06:35:22 <adamse> what is the package you are trying to build?
06:35:48 <comprehension> adamse: my own package
06:36:56 <adamse> from that error my guess is that you have alex or happy in your build-depends, while they should be in build-tools
06:37:17 <comprehension> adamse: that fixed it, thank you
06:37:49 * hackagebot frpnow 0.1 - Principled practical FRP  http://hackage.haskell.org/package/frpnow-0.1 (AtzeVanDerPloeg)
06:42:50 * hackagebot frpnow-gloss 0.1 - Program awesome stuff with Gloss and frpnow!  http://hackage.haskell.org/package/frpnow-gloss-0.1 (AtzeVanDerPloeg)
06:42:52 * hackagebot frpnow-gtk 0.1 - Program GUIs with GTK and frpnow!  http://hackage.haskell.org/package/frpnow-gtk-0.1 (AtzeVanDerPloeg)
06:51:12 <catgocat> What is a good book for someone who is relatively new to Haskell, but has previous programming experience? I have read the first 9 chapters of Learn You A Haskell, but I find the rest of the book too confusing. I also gave a glance at Real World Haskell, but 768 pages is just too much.
06:52:15 <dramforever> catgocat: I've seen others recommend checking https://github.com/bitemyapp/learnhaskell
06:53:12 <FofG_> hey all
06:53:39 <dramforever> just ask, people will reply if they see it and know the answer
06:53:43 <catgocat> dramforever: I've also ended up there but it seems quite confusing, the lessons are reading material? I thought lessons meant video or something so I was not quite sure.
06:54:03 <maerwald> catgocat: http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html
06:54:19 <dramforever> catgocat: I think those are lecture notes
06:54:41 <catgocat> dramforever, maerwald: so where should I start? where is the real lecture stuff?
06:54:53 <dramforever> in the university =P
06:54:53 <maerwald> catgocat: click the links on the page?
06:55:00 <dramforever> those notes are not enough?
06:55:16 <catgocat> I am new to haskell, not a pro, is that enough for me?
06:55:30 <maerwald> yes, but read it carefully
06:55:32 <maerwald> it's dense
06:55:43 <maerwald> not so verbose like lyah
06:56:17 <dramforever> it's a perfectly normal lecture notes collection =)
06:56:21 <catgocat> I see that there are only 12 links, so only 12 pages?
06:57:18 <dramforever> catgocat: hmm how about this: when you find something confusing, ask
06:57:28 <dramforever> so what's the thing confusing you in lyah?
06:57:57 <maerwald> catgocat: there are 12 lectures and 12 links to those lectures
06:58:11 <maerwald> I don't understand the problem
06:58:54 <dramforever> catgocat: is that number too big/small or what?
06:59:16 <bernalex> how can they say anything about that before they've been through them? :)
06:59:25 <catgocat> dramforever: I don't know, I see books in 700 pages, that seems small for me, or am I wrong
06:59:39 <dramforever> catgocat: 1. that's 12 *web*pages
06:59:53 <maerwald> catgocat: quantity doesn't say anything about quality
06:59:58 <dramforever> 2. it's very dense, because it's not a tutorial, it's lecture notes
07:00:10 <catgocat> ok I am going to read those and do the homeworks
07:00:12 <nrk-> Some schools teach their intro to programming courses with Haskell. The Australian National University does, I think. I figure that would be as unconfusing as possible since it’s targeted at very new programmers
07:00:19 <catgocat> I hope it's not too difficult for me
07:00:37 <maerwald> the parser homework is challenging, but also fun once you get through it
07:02:49 <chpatrick> yeah my uni started with haskell
07:02:52 * hackagebot frpnow 0.11 - Principled practical FRP  http://hackage.haskell.org/package/frpnow-0.11 (AtzeVanDerPloeg)
07:03:58 <bernalex> nrk-: I think for e.g. experienced OOP programmers you need to address their expectations. they will have ideas about what a type*class* should be. you need to dismantle them quickly IMO.
07:04:02 <chpatrick> our exam was making a type inference system
07:04:10 <maerwald> chpatrick: mine had a crash-cource in the 6th semester of 4 weeks haskell. The 4th lecture already was about monads (without monoids, functors or applicative being discussed)
07:04:12 <chpatrick> after three months
07:04:34 <maerwald> pretty everyone from that class hates haskell now I think
07:04:44 <chpatrick> we had a basic course for everyone and an advanced haskell course running in parallel with really crazy shit
07:04:49 <chpatrick> ad etc
07:04:59 <chpatrick> that was optional
07:05:10 <dramforever> actually it can get kinda weird because programs update before courses do
07:05:14 <chpatrick> we had a really charismatic teacher that's been teaching haskell for 20 years or something so everyone has a positive impression of the language
07:05:26 <chpatrick> but most people forget it pretty quickly
07:05:45 <chpatrick> I wish they put videos of the lectures online for everyone
07:06:05 <bernalex> chpatrick: academia hates the general public. -_o_-
07:06:12 <bernalex> everything is about money I guess.
07:06:18 <doomlord> the repurposing of the word 'class' is a bit unfortunate, but not a showstopper
07:06:49 <ski> it's a class in the math sense
07:06:54 <bernalex> doomlord: not at all, but I think pretending there's no source of confusion for OOP programmers is doing them a disservice.
07:07:18 <bernalex> ski: exactly. it's not more or less confusing than haskell variables, which are variables in the maths sense not in the C++ sense.
07:07:24 <maerwald> I think the repurposing didn't happen in haskell
07:07:26 <chpatrick> OOP doesn't have exclusive use of the word :)
07:07:46 <maerwald> it is just re-repurposed now
07:07:50 <dramforever> "repurposing" hmm....
07:07:56 <maerwald> err
07:08:03 <maerwald> close enough
07:08:24 <dramforever> so you assumed haskell people deliberately did it just to follow the motto?
07:09:55 <ski> @quote motto.of.Haskell
07:09:56 <lambdabot> Baughn says: "<dpratt71> so I read somewhere that the unofficial  motto of Haskell was \"avoid success at all costs\"...<Baughn> dpratt71: Yeah. We failed."
07:15:45 <catgocat> What is “literate Haskell document”, what it's useful for?
07:16:03 <hnfmr> Does forkOS in a forkIO still create a bound thread?
07:16:46 <maerwald> catgocat: when you write more documentation than code basically
07:16:56 <c_wraith> hnfmr: yes
07:17:01 <hnfmr> thanks
07:17:18 <catgocat> maerwald: I don't understand, why `.lhs`? Is the file runnable?
07:17:18 <bergmark> catgocat: lines that start with a > is code, the rest is comments
07:17:35 <hnfmr> actually i can check it by calling "isCurrentThreadBound" function
07:17:40 <ski> catgocat : when you want to write a coherent document text that explains something, interspersed with the implementation bits. instead of comments being the "exceptional case", here code is the "exceptional case"
07:18:11 <c_wraith> catgocat: lots of haskell blog posts are actually literate haskell files (well, when the markup is stripped out)
07:18:15 <ski> catgocat : you can compile it like a normal source file
07:18:29 <catgocat> is there any example I can see
07:19:00 <c_wraith> http://neilmitchell.blogspot.com/2009/01/small-scripts-with-haskell.html
07:19:12 <bernalex> sel4's haskell files are .lhs and may be compiled into a pdf book. very nice.
07:19:18 <c_wraith> catgocat: the content of the main pane can be copied directly to a .lhs file
07:19:29 <c_wraith> catgocat: no need to isolate the code from the prose
07:19:37 <maerwald> https://www.reddit.com/r/haskell/comments/2r0prx/is_literate_haskell_a_dead_concept/
07:19:52 <catgocat> should I worry about it right now?
07:19:56 <c_wraith> No
07:20:01 <c_wraith> It's still just haskell
07:20:25 <c_wraith> The only difference is that it's assumed all text is comments, unless specially marked up.
07:22:11 <catgocat> thanks I got it
07:22:30 <ski> catgocat : here's an oleg example <http://okmij.org/ftp/Haskell/Mr-S-P.lhs>
07:22:53 * hackagebot docker 0.2.0.2 - Haskell wrapper for Docker Remote API  http://hackage.haskell.org/package/docker-0.2.0.2 (denibertovic)
07:26:40 <catgocat> If I want multiple variables to have one type, is it ok to write var1,var2,var3 :: Int for example?
07:27:00 <c_wraith> yes
07:27:25 <bergmark> catgocat: you can even do (var1,var2,var3) = (1,2,3) on the top level
07:27:53 * hackagebot ig 0.3 - Bindings to Instagram's API.  http://hackage.haskell.org/package/ig-0.3 (FelipeLessa)
07:28:25 <catgocat> bergmark: assuming 1, 2 and 3 are types like Int right?
07:29:30 <ski> > let  var1,var2,var3 :: Int;  (var1,var2,var3) = (1,2,3)  in  var1 + var2 * var3
07:29:32 <lambdabot>  7
07:29:37 <catgocat> oh ok 
07:33:47 <ski> > let  var1,var2 :: Double;  var3 :: Int;  (var1,var2,var3) = (1,2,3)  in  floor (sqrt (80 * var1) + var2) `mod` var3
07:33:48 <lambdabot>  1
07:34:30 <ski> catgocat : .. so the components of the triple doesn't all have to have the same type
07:37:09 <catgocat> What is the difference between double precision and single precision, Double and Float in Haskell?
07:37:18 <catgocat> Does it have to do with memory? I mean, why use Float instead of Double
07:37:29 <catgocat> I know one offers less precision.
07:37:56 <kadoban> catgocat: That's the difference. Just use Double unless you have some good reason, if you're going to use one of those two.
07:38:04 <ski> `Float' uses less memory (and i suppose *maybe* less cycles)
07:39:05 <c_wraith> Float is more common than Double in 3d graphics, because of that.
07:39:06 <liste> with a FPU, there's usually no difference, both Double and Float are truncated
07:39:18 <c_wraith> Your meshes can have twice as many points in the same memory
07:39:28 <liste> for cycles, I mean
07:39:41 <Gurkenglas> What completes the rectangle of Monad, Applicative and Comonad?
07:39:45 <liste> not sure about GPUs, maybe they work more efficiently with single-precision?
07:39:47 <nikki93> @pl \x -> if even x then x `div` 2 else 3 * x + 1
07:39:50 <lambdabot> ap (liftM2 if' even (`div` 2)) ((1 +) . (3 *))
07:42:48 <silver> liste, most likely
07:43:01 <silver> I remember news about super fast Doubles in AMD gpus
07:44:34 <silver> but it might have changed in recent years
07:45:42 <silver> or the "speed" is just reference to throughput, not actual cycles
07:47:09 <ski> Gurkenglas : rectangle ?
07:47:54 * hackagebot frpnow-gloss 0.11 - Program awesome stuff with Gloss and frpnow!  http://hackage.haskell.org/package/frpnow-gloss-0.11 (AtzeVanDerPloeg)
07:49:25 <Gurkenglas> ski: "Monad is to Applicative as Comonad is to _"
07:49:28 <maerwald> > 3 & odd & not & return & head
07:49:30 <lambdabot>  False
07:50:31 <bernalex> > 3 & (head . return . not . odd)
07:50:34 <lambdabot>  False
07:50:44 <noah_> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69 describes a coapplicative
07:50:59 <bernalex> I find using & & & & & & & & instead of compositions as ugh as using $ $ $ $ $ $ $ $.
07:51:38 <c_wraith> those parens aren't needed
07:51:46 <c_wraith> (.) has precedence 9
07:51:56 <quchen> Is there a name for Haskell's type system without classes? F-omega with Hindley-Milner constraint?
07:52:32 <bernalex> c_wraith: yes, true. I just thought about a self-defined & in ghci or whatever. the one in Data.Function will work fine with (.).
07:52:39 <catgocat> What is idiomatic haskell?
07:52:45 <catgocat> What does this term mean?
07:52:48 <bernalex> catgocat: not agreed upon.
07:52:54 * hackagebot libravatar 0.1.0.1 - Use Libravatar, the decentralized avatar delivery service  http://hackage.haskell.org/package/libravatar-0.1.0.1 (akrasner)
07:52:58 <quchen> Gurkenglas: There is ComonadApply, but it comes one step after Comonad.
07:53:03 <c_wraith> catgocat: it means that it's written in a style that's widely accepted.
07:53:20 <maerwald> as in: undefined
07:53:23 <bernalex> catgocat: idiomatic means conforming to a way of expressing things that is characteristic of a language.
07:53:25 <c_wraith> catgocat: it's not about code formatting as often as it's about how a particular problem is solved
07:53:39 <catgocat> Oh so it means a good practice standard
07:53:48 <catgocat> Something like that
07:54:12 <quchen> catgocat: Unidiomatic Haskell would be writing everything with IO and mutating state all over the place, for example.
07:54:26 <quchen> catgocat: Unidiomatic C++ is spamming Lambdas all over the place.
07:54:29 <maerwald> quchen: like haskell web frameworks?
07:54:30 <catgocat> Got it thanks
07:55:09 <bernalex> catgocat: it's kind of about writing something "in the spirit of" the language. but what this nebulous "spirit" actually is, is of course very much contested.
07:56:32 <bernalex> especially in haskell which includes both expression style and declaration style equally.
07:57:54 * hackagebot text-regex-replace 0.1.1.0 - Easy replacement when using text-icu regexes.  http://hackage.haskell.org/package/text-regex-replace-0.1.1.0 (EricRochester)
07:59:22 <maerwald> bernalex: and even if we could agree upon a term for "idiomatic" it's debatable whether you can write useful things without breaking that "idiomacy"
07:59:45 <bernalex> maerwald: I don't know why that would be so.
08:00:17 <Gurkenglas> Is there a list of unusually idiomatic code implementations, in the sense of a problem being solved using code that's more idiomatic than usual to the problem?
08:01:28 <maerwald> bernalex: popular example being the quicksort implementation. Then look at web frameworks that stuff IO all over monad burritos, but try to hide it. Then there is the discussion about lens and whatnot
08:01:36 <maerwald> I think the term just doesn't get us very far
08:01:43 <bernalex> IO is not unidiomatic
08:01:49 <maerwald> bernalex: I did not say that
08:02:21 <bernalex> monad burritos are not unidiomatic either. I don't think a proper quicksort implementation is unidiomatic either. not exactly pretty but...
08:02:32 <maerwald> I think it is quite unidiomatic
08:02:52 <bjornars> a tad idiotic, maybe
08:02:52 <maerwald> but it doesn't really matter, does it?
08:04:02 <bernalex> I think idiomatic code is more of a symptom of doing the Right Thing, than it is a holy grail/goal in itself.
08:04:28 <catgocat> Why can't I create tuples of bigger lengths?
08:04:36 <catgocat> (1,2,3,4,5,6,7,8,9,1,2,2,2,3,3) works, but more one and it doesn't compile.
08:04:54 * sm thinks idiomatic is a machine for making idiots 
08:04:56 <bernalex> catgocat: uh that should compile fine
08:04:59 <catgocat> I would use a list instead but I am curious
08:05:02 <maerwald> sm: haha
08:05:11 <quchen> catgocat: I think you can go up to 62-tuples
08:05:21 <quchen> catgocat: After that there are technical limitations
08:05:23 <ski> @let maximumRec :: Ord a => [a] -> a;  maximumRec [    ] = undefined;  maximumRec (x:xs) = last ys  where  ys = x : [x `max` y | x <- xs | y <- ys]
08:05:25 <catgocat> It doesn't work, I'm using ghci
08:05:26 <lambdabot>  Defined.
08:05:29 <ski> > maximumRec [4,2,8,5,7,1]
08:05:31 <lambdabot>  8
08:05:35 <bernalex> quchen: 62 is indeed GHC's max.
08:05:57 <bernalex> catgocat: it does work.
08:06:02 <maerwald> catgocat: (1,2,3) is a different type than (1,2)... while [1,2] has the same type as [1,2,3]
08:06:06 * ski idly wonders what sm thinks about "idiology"
08:06:10 <catgocat> oh, it's because bigger tuples are not derived from Show
08:06:11 <bernalex> catgocat: it just doesn't print, because there's no Show instance for tuples of that length.
08:06:32 <catgocat> yeah it makes sense
08:06:36 <sm> in fact I have a dark suspicion I might be using the idomatic right now
08:06:42 <ski> > fst ('0',True)
08:06:43 <lambdabot>  '0'
08:06:52 <sm> idiomatic. See that!
08:06:58 <kadoban> catgocat: In practice you won't be using tuples anywhere near that big, so it won't matter.
08:07:00 <ski> > head ['0',True]  -- type error, list elements have to have the same type !
08:07:01 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Bool’
08:07:01 <lambdabot>      In the expression: True
08:07:01 <lambdabot>      In the first argument of ‘head’, namely ‘['0', True]’
08:07:08 <catgocat> kadoban: sure thanks
08:07:32 <bernalex> if someone has a 62-length tuple in their program, they might need to reevaluate their life.
08:07:46 <c_wraith> If you need 63 elements, create a data type. :)
08:08:08 <kadoban> If you need … 4 elemenets, create a data type, heh.
08:08:24 <maerwald> bernalex: use a list and the dynamic type, then write down on sheet of paper which one has which type :P
08:08:31 <catgocat> Is there a way to create an account in this chat?
08:08:39 <ski> > let ignored = (1,2,3,4,5,6,7,8,9,1,2,2,2,3,3,"one more") in (2 + 2,2 * 2,2 ^ 2)  -- catgocat, seems to work here
08:08:41 <lambdabot>  (4,4,4)
08:08:41 <bernalex> catgocat: /msg nickserv help
08:08:48 <kadoban> catgocat: You can register with freenode, yeah that ^
08:08:57 <quchen> Heh, GHC even tells you that 62 is the maximum tuple size.
08:08:59 <quchen> (\(x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x) (1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
08:09:04 <quchen> > (\(x,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_)->x) (1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
08:09:06 <lambdabot>      A 63-tuple is too large for GHC
08:09:06 <lambdabot>        (max size is 62)
08:09:06 <lambdabot>        Workaround: use nested tuples or define a data type    A 63-tuple is t...
08:09:14 <bernalex> yes.
08:09:25 <quchen> I thought it was only in the comment
08:09:27 <bernalex> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
08:09:29 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 ->
08:09:29 <lambdabot> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63)
08:09:36 <ski> whee
08:09:40 <catgocat> bernalex: is that suposed to do something?
08:09:46 <bernalex> catgocat: yes.
08:10:05 <kadoban> I wonder why it starts at t28
08:10:17 <catgocat> bernalex: I typed /msg catgocat help and nothing happens
08:10:27 <bernalex> catgocat: why did you message yourself? lol
08:10:35 <bernalex> catgocat: you need to talk to the nickserv bot.
08:10:39 <catgocat> bernalex: oh never mind
08:10:40 <ski> catgocat : `/msg NickServ help', not `/msg catgocat help'
08:11:02 <bernalex> now I want to try to message myself and see what weechat does
08:11:08 <ski> kadoban : well, it *is* a perfect number ..
08:11:11 <bernalex> it opens a buffer for it. nice.
08:11:21 <bernalex> and echoes what I type in it. that's uhm useful probably.
08:11:52 <catgocat> what client are you guys using? webchat.freenode.net?
08:12:02 * ski is not using a web client at all
08:12:06 <ski> (Irssi, here)
08:12:07 <bernalex> weechat.
08:12:17 <neanias> textual
08:12:24 <catgocat>  /msg NickServ VERIFY REGISTER catgocat puuwbkcvsmbe
08:12:32 <quchen> ಠ_ಠ 
08:12:35 <catgocat> hm
08:12:36 <maerwald> ok thanks for sharing your password
08:12:37 <bernalex> right you might want to change your password.
08:12:47 <ski> catgocat : try e.g. `/ctcp ski version'
08:12:58 <maerwald> I hope he doesn't use it for fb or something
08:13:10 <catgocat> oh I am registered
08:13:29 <catgocat> my psswd is loveshrek1337
08:13:50 <maerwald> good
08:13:51 <catgocat> ha gotcha!!
08:14:27 <catgocat> ok back to coding >.>
08:14:38 * ski isn't sure whether the webchat opens a new tab or frame or something, for private messages, or for multiple channels joined
08:17:41 <geekosaur> I was seeing multiple tabs back when I used it
08:18:32 <nikki93> is 'xor = foldr (/=) False' a correct way to implement "whether there is an odd number of 'True's in the given list of Bools"?
08:19:42 <dolio> > foldr (/=) False [False]
08:19:43 <lambdabot>  False
08:20:58 <kadoban> > True `xor` True -- nikki93
08:20:59 <lambdabot>  False
08:21:14 <bernalex> I'd probably just do 'odd . length . filter (==True)'. then again I'm not very clever.
08:21:15 <kadoban> You can just directly use xor, then it's easy to see if it's correct or not …
08:21:38 <ski> @let  foldlRec :: (r -> a -> r) -> r -> [a] -> r;  foldlRec f z xs = last zs  where  zs = z : [f z x | x <- xs | z <- zs]
08:21:39 <lambdabot>  Defined.
08:21:45 <ski> > foldlRec (+) 0 [2,3,5,7]
08:21:46 <lambdabot>  17
08:22:04 <kadoban> nikki93: https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Bits.html#v:xor
08:22:13 <dolio> ski: Been writing cryptol?
08:22:34 <nikki93> kadoban: ya I just used the 'xor is same as /= for Bools' hack but that's good that data bits has an xor already defined
08:22:55 <ski> dolio : well, reading about it ;)
08:24:59 <quchen> nikki93: FWIW you can also use QuickCheck in here via ?check
08:25:07 <quchen> ?check \x -> x*2 == 2*x
08:25:08 <lambdabot>  +++ OK, passed 100 tests.
08:25:16 <quchen> ?check \x -> x*2 == 3*x
08:25:18 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 2 shrinks):
08:25:18 <lambdabot>  -2
08:25:20 <ski> @check True
08:25:21 <lambdabot>  +++ OK, passed 100 tests.
08:25:27 <ski> @check False
08:25:28 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:25:31 <quchen> Careful with defaulting though.
08:25:38 <quchen> ?check \xs -> xs == reverse xs
08:25:39 <lambdabot>  +++ OK, passed 100 tests.
08:26:36 <ski> @check \x y z -> (x + y) + z == x + (y + z :: Float)
08:26:37 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 73 shrinks):
08:26:37 <lambdabot>  1.1485413 -5.1392138e-2 -0.16169429
08:26:48 <quchen> 73 shrinks, woah
08:28:21 <frerich> quchen: What's that 'defaulting' you mean which makes 'xs == reverse xs' pass?
08:28:36 <ski> frerich : `xs :: [()]'
08:28:36 <hiptobecubic> it defaults to () i think?
08:28:39 <hiptobecubic> right
08:28:47 <frerich> Ah... good point.
08:28:55 <Welkin> there are some pretty creative names in here
08:29:02 <quchen> ?check \xs -> xs == reverse (xs :: [Int])
08:29:03 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 5 shrinks):
08:29:03 <lambdabot>  [1,-3,-2]
08:29:08 <Welkin> CoconutCrab sets up an amusing visual
08:29:18 <quchen> Welkin: Those animals exist.
08:29:23 <hiptobecubic> CoconutCrab is a real animal.
08:29:25 <Welkin> really?
08:29:31 <hiptobecubic> yes. Enormous.
08:29:34 <quchen> Yeah. Look them up. Hold onto your seat. :-)
08:29:39 <Welkin> wiw
08:29:40 <Welkin> https://en.wikipedia.org/wiki/Coconut_crab
08:29:42 <Welkin> wow
08:30:04 * CoconutCrab crawls away
08:30:11 <Welkin> omg
08:30:23 <Welkin> they actually cling onto coconuts
08:30:26 <quchen> Back to Quickchecking stuff,
08:30:30 <quchen> ?check \xs -> odd (length (filter (== True) xs)) == foldr (/=) False xs
08:30:32 <lambdabot>  +++ OK, passed 100 tests.
08:30:44 * quchen wonders whether id is clearer than (== True) but that's not the point
08:32:26 <Welkin> "Coconut crabs may be responsible for the disappearance of Amelia Earhart's remains, consuming them after her death and hoarding her skeletal remnants in their burrows.[39]" o.o
08:32:39 <kadoban> Even if it's correct (I think it is), it's still kind of hard to read. Better would be either using xor, or alternatively explicitly checking if the number of True values is odd (depending on which makes more sense in context).
08:33:32 <ski> @check liftA2 (==) (sum . map fromEnum) (length . filter (True ==))
08:33:34 <lambdabot>  +++ OK, passed 100 tests.
08:33:51 <Twey> ski: What's this [ e | p₁ ← e₁ | p₂ ← e₂ ] syntax?
08:34:07 <ski> Twey : parallel list comprehensions. `zipWith'y stuff
08:34:47 <Twey> ski: Oho
08:35:32 <Twey> ski: Is that standard?
08:35:38 <ski> extension
08:35:40 <Twey> Ah
08:35:45 <Twey> Thanks
08:36:18 <maerwald> quchen: if there is some Bool somewhere in the typesignature probably, otherwise I'd rather say confusing
08:36:50 <Twey> I think ‘filter id’ is obvious
08:36:51 <catgocat> How do I submit my solutions to the homework? 
08:37:00 <ski> Twey : Cryptol seems to encourage such recurrences in place of recursive functions
08:37:01 <catgocat> In the CIS194 lectures
08:37:03 <Twey> catgocat: What homework?
08:37:46 <maerwald> catgocat: :D those assignments are long gone
08:37:47 <Twey> catgocat: This is a global Haskell channel: it isn't affiliated with your university.
08:38:06 <ski> whee .. netsplit
08:38:09 <catgocat> Twey: I'm 15 I don't go to uni
08:38:30 <ski> Twey : people here suggested those course notes
08:38:32 <maerwald> catgocat: for most of the assignments you can check yourself whether the code does what it's supposed to do, for everything else, just use lpaste and give a link here
08:38:40 <kadoban> catgocat: You don't submit them. You can chat about them here or in #haskell-beginners and share you solutions for review.
08:38:42 <ski> @paste
08:38:43 <lambdabot> Haskell pastebin: http://lpaste.net/
08:38:52 <lpaste> catgocat pasted “todigits” at http://lpaste.net/136478
08:38:55 <ski> catgocat : if in doubt, you can use that ^ and ask us
08:38:58 <catgocat> http://lpaste.net/136478
08:39:08 <ski> lpaste already gave the link :)
08:39:26 <catgocat> yeah didn't know that xD
08:39:48 <catgocat> is it alright?
08:39:48 <maerwald> @let toDigits n = map (toInteger . digitToInt) $ show n
08:39:49 <lambdabot>  Defined.
08:40:02 <maerwald> > toDigits 3234
08:40:03 <lambdabot>  [3,2,3,4]
08:40:30 <maerwald> > toDigits 0
08:40:32 <lambdabot>  [0]
08:40:33 <catgocat> I also used an import to Data.Char
08:40:55 <catgocat>  > toDigits -32
08:40:59 <maerwald> were you supposed to do that?
08:41:03 <Twey> catgocat, ski: Ah, okay.
08:41:06 <maerwald> afair I did something with modulus there
08:41:20 <catgocat> maerwald: the import? I don't know oO
08:41:36 <fishythefish> catgocat, no leading space
08:41:50 <fishythefish> > toDigits (-32)
08:41:51 <lambdabot>  [*Exception: Char.digitToInt: not a digit '-'
08:41:52 <maerwald> catgocat: I think you were not supposed to use helper functions
08:42:11 <maerwald> except stuff in prelude
08:42:20 <ski>   "`toDigits' should convert positive `Integers' to a list of digits. (For `0' or negative inputs, `toDigits' should return the empty list.)"
08:42:21 <catgocat> maerwald, hm.. I could do a recursive function and use `mod` 10 to get the lastest digit
08:42:52 <bernalex> I'd use mod.
08:42:56 * hackagebot formatting 6.2.2 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.2.2 (ChrisDone)
08:43:07 <maerwald> catgocat: I did a combination of "get the first digit of an integer" and "get the integer minus the first digit" and then you can do your recursive thing for example
08:43:17 <ski> > (583 `div` 10,583 `mod` 10)
08:43:19 <lambdabot>  (58,3)
08:43:25 <ski> > 583 `divMod` 10
08:43:27 <lambdabot>  (58,3)
08:43:52 <ski> > let (q,r) = 583 `divMod` 10 in q - r
08:43:54 <lambdabot>  55
08:45:32 <lpaste> catgocat pasted “dasdas” at http://lpaste.net/136480
08:45:36 <catgocat> http://lpaste.net/136480
08:45:44 <catgocat> see that guys tell me what you think
08:46:21 <catgocat> it's quite smart
08:48:04 <maerwald> looks ok
08:52:56 * hackagebot event 0.1.1 - Monoidal, monadic and first-class events  http://hackage.haskell.org/package/event-0.1.1 (DimitriSabadie)
08:58:26 <maerwald> wasn't there a way to map over an Integer with lens?
08:58:41 <ski> catgocat : hmm
08:58:49 <catgocat> ski: what
08:58:51 <ski> catgocat : how does that handle `0' ?
08:59:00 <catgocat> [0]
08:59:08 <ski>   "`toDigits' should convert positive `Integers' to a list of digits. (For `0' or negative inputs, `toDigits' should return the empty list.)"
08:59:09 <catgocat> check the second guard
08:59:17 <catgocat> the first sorry
08:59:42 <ski> yes. i was thinking it didn't agree with the quoted requirements ^
09:00:47 <ski> the basic recursion looks fine. i'm just also wanting the edge cases to be right :)
09:01:31 <maerwald> mh, (n `div` 10) gives me a liquid type error, I don't know why
09:01:48 <ski> (also, there's a lesson here about reducing the base case(s) to the minimum possible (as far is natural), letting the recursive case handle the rest)
09:01:51 <catgocat> oh no, you are right
09:01:54 <catgocat> I didn't read the question right
09:02:26 <ski> it's no worry. you got it mostly right, which is good :) it's just the final details that are missing
09:03:04 <lpaste> catgocat pasted “gasdgasdgas” at http://lpaste.net/136482
09:03:18 <catgocat> fixed
09:03:42 <ski> catgocat : btw, if you use the "Annotate" button on the existing paste, then the new paste you make will appear on the same page (for easy comparision) .. that's handy for making updated versions, and for other people to make larger comments with code
09:03:54 <ski> (that's just a hint)
09:04:01 <maerwald> catgocat: the second guard is obsolete now :)
09:04:23 <maerwald> line 4
09:04:28 <ski> catgocat : nice :)
09:04:46 <ski> catgocat : can you tell me (without trying) what will happen if you remove the `    | n < 10    = [n]' line ?
09:04:55 <maerwald> 9 `div` 10 will get you 0 and the recursion stops
09:05:05 <catgocat> ski: it will loop forever
09:05:12 <maerwald> nope
09:05:15 <catgocat> ski: I think
09:05:35 <ski> catgocat : try it now :)
09:05:38 <catgocat> ok
09:06:00 <catgocat> it worked
09:06:06 <ski> can you see why ?
09:06:16 <catgocat> yes, because once it reaches 0 it creates an empty list which finishes the operation
09:06:24 <catgocat> because previously I hadn't the <= 0 there, that's why
09:06:30 <ski> yes
09:06:47 <ski> catgocat : this is what i meant by "reducing the base case(s) to the minimum possible (as far is natural), letting the recursive case handle the rest"
09:06:59 <catgocat> yes yes
09:07:05 <catgocat> nice catch btw
09:07:23 <ski> in this way, one can often write less code, and at the same time clearer code (at least once one get used to this idea of reducing base cases as far as possible)
09:07:53 <ski> for illustration, here's an evaluation trace :
09:08:14 <ski>      toDigits 8128
09:08:36 <ski>   =  toDigits (8128 `div` 10) ++ [8128 `mod` 10]
09:08:49 <ski>   =  toDigits 812 ++ [8]
09:09:10 <ski>   =  (toDigits (812 `div` 10) ++ [812 `mod` 10]) ++ [8]
09:09:20 <ski>   =  (toDigits 81 ++ [2]) ++ [8]
09:09:40 <ski>   =  ((toDigits (81 `div` 10) ++ [81 `mod` 10]) ++ [2]) ++ [8]
09:09:49 <ski>   =  ((toDigits 8 ++ [1]) ++ [2]) ++ [8]
09:10:06 <ski>   =  (((toDigits (8 `div` 10) ++ [8 `mod` 10]) ++ [1]) ++ [2]) ++ [8]
09:10:07 <kuribas> why not cons instead of append?
09:10:18 <ski>   =  (((toDigits 0 ++ [8]) ++ [1]) ++ [2]) ++ [8]
09:10:27 <ski>   =  ((([] ++ [8]) ++ [1]) ++ [2]) ++ [8]
09:10:32 <ski>   =  (([8] ++ [1]) ++ [2]) ++ [8]
09:10:39 <ski>   =  ([8,1] ++ [2]) ++ [8]
09:10:46 <ski>   =  [8,1,2] ++ [8]
09:10:49 <ski>   =  [8,1,2,8]
09:11:22 <ski> catgocat : it can sometimes help to get a better feel for how a recursion is going to work, to manually work through a simple example like this
09:11:49 <maerwald> kuribas: because the left hand side would be a list
09:11:51 <catgocat> ski: yeah, I think I am comfortable with recursion, I used to do a lot of it in javascript
09:11:59 <ski> good
09:16:53 <safinaskar> is this possible to automatically parallelize haskell program when needed/possible? without explicit commands in the program. for example, i write "let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n + 2) in fib 4" and this computation automatically parallelizes?
09:18:03 <ski> safinaskar : afaiui, the hard problem is determining when the overhead is worth it
09:18:15 <ski> (also, itym s/n + 2/n - 2/)
09:18:50 <kadoban> safinaskar: Possible? Yes. Does GHC do it? I don't believe so, but you can do it yourself fairly easily. Of course in that case there's a better way (fix your code so it's not so horribly performing)
09:18:51 <ski> in this particular case, it's better to memoize/table (dynamic programming)
09:18:58 <kuribas> > let toDigits = reverse . toDigits'; toDigits' n | n < 10 = [n]; toDigits' n = (n `mod` 10): toDigits' (n `div` 10) in toDigits' 8128 -- maerwald
09:18:59 <lambdabot>  [8,2,1,8]
09:19:02 <levi> That would probably be up to the particular haskell implementation. I don't think GHC attempts to do it.
09:19:17 <kuribas> maerwald: and O(n) instead of 0(n^2)
09:19:55 <maerwald> kuribas: I'd expect GHC to optimize that anyway
09:20:00 <maerwald> but maybe I am wrong
09:20:35 <kuribas> maerwald: probably not
09:20:56 <maerwald> kuribas: probably not "I am wrong" or "GHC optimizes that"
09:21:36 <kuribas> maerwald: that GHC optimizes it.
09:23:39 <Gurkenglas> Should there be an instance ComonadCofree [] Tree?
09:26:03 <lpaste> catgocat pasted “homework1.hs” at http://lpaste.net/136485
09:27:40 <Gurkenglas> > map minimum $ tree
09:27:44 <lambdabot>  mueval-core: Time limit exceeded
09:27:45 <Gurkenglas> > minimum $ head tree
09:27:46 <lambdabot>  1
09:27:49 <Gurkenglas> What is this?
09:28:02 <Welkin> > tree
09:28:04 <lambdabot>  [[1],[2],[4],[8,1],[16,2],[32,5,4],[64,10,8,1],[128,21,20,3,16,2],[256,42,40...
09:28:16 <Gurkenglas> Shouldn't lazy evaluation give me the first output before it times out?
09:28:29 <ttt_fff> damn it, implementing my own stack frames suck; does 7.10 offer stack frames ? (on exceptions)
09:28:31 <Welkin> Gurkenglas: that doesn't make sense for minimum
09:28:42 <ttt_fff> I don't care if it makes my code 10x slower, this is only for debugigng purposes
09:28:44 <Welkin> it must search the whole list
09:28:51 <ttt_fff> in fact, I'd even be okay with 100x slower
09:29:03 <ttt_fff> just fucking give me stackframes so I can debug my code :-)
09:29:05 <Gurkenglas> Welkin, I used map minimum
09:29:11 <geekosaur> Gurkenglas, how does it know it has the minimum item if it has not scanned the entire list?
09:29:22 <Welkin> oh
09:29:23 <Welkin> I see
09:29:44 <Hijiri> lambdabot sometimes messes up laziness I think
09:32:57 <maerwald> catgocat: where l = 1 : 2 : l can be written as "cycle [1,2]"
09:33:05 <maerwald> :t cycle
09:33:06 <lambdabot> [a] -> [a]
09:33:10 <catgocat> maerwald: ah yes, I forgot that
09:33:14 <maerwald> > cycle [1,2]
09:33:15 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
09:33:28 <ski> catgocat : it's basically good, i think. here's some comments : `toDigitsRev' could be more efficient (more efficient than your `toDigits' is). i'm not sure it would be worth it to write `doubleEveryOther' with direct recursion. `sumDigits' calls itself on a second "level", and for these calls, `n >= 10' is always false (a wasted test)
09:33:39 <ski> catgocat : it would be possible to avoid that
09:33:39 <catgocat> > concat $ repeat [1,2]
09:33:40 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
09:34:06 <catgocat> ski: yes, I am going to make some changes
09:34:11 <catgocat> *making some changes*
09:34:24 <ski> catgocat : try the "Annotate" button this time ? :)
09:34:36 <catgocat> Annotate?
09:34:49 <ski> on <http://lpaste.net/136485>, at the top
09:34:54 <catgocat> How is that different from edit?
09:35:14 <ski> <ski> catgocat : btw, if you use the "Annotate" button on the existing paste, then the new paste you make will appear on the same page (for easy comparision) .. that's handy for making updated versions, and for other people to make larger comments with code
09:35:27 <catgocat> yes got it
09:35:39 <maerwald> > reverse . (zipWith (*) .) cycle [1,2] . reverse $ [1, 2, 3, 6]
09:35:40 <lambdabot>  [2,2,6,6]
09:35:57 <maerwald> oops
09:36:07 <ski> catgocat : "Edit" is more for superceding a version with a corrected one (like typos)
09:36:08 <maerwald> order wrong
09:37:42 <ski> (with "Edit", you'll only see the older versions if you click some history or diff link)
09:37:59 <lpaste> catgocat annotated “homework1.hs” with “homework1.hs (annotation)” at http://lpaste.net/136485#a136486
09:38:22 <catgocat> ok I changed the cycle thing and digitsRev
09:38:33 <maerwald> catgocat: and reversing twice is not really necessary
09:38:49 <maerwald> > (zipWith (*) .) cycle [1,2] $ [1, 2, 3, 6]
09:38:50 <lambdabot>  [1,4,3,12]
09:39:16 <catgocat> maerwald, brilliant
09:39:32 <phaazon> that’s funny how (a -> IO ()) is not a Functor
09:39:37 <catsup> what's a convenient way to get the first Just from three Maybe variables
09:39:38 <phaazon> but ((a -> IO ()) -> IO ()) is :)
09:39:43 <ski> > zipWith (*) . cycle [1,2] $ [1,2,3,6]
09:39:44 <lambdabot>      Couldn't match expected type ‘[Integer] -> [c]’
09:39:44 <lambdabot>                  with actual type ‘[Integer]’
09:39:44 <lambdabot>      Possible cause: ‘cycle’ is applied to too many arguments
09:39:59 <catsup> (or Nothing, of course)
09:40:19 <maerwald> ski: that doesn't work :P... but I guess it's better to write it without (.)
09:40:22 <glguy> > msum [Nothing, Just True, Just False]
09:40:24 <lambdabot>  Just True
09:40:37 <ski> maerwald : yea, i just realized why :)
09:40:38 <catgocat> maerwald, well but that doesnt work, you see I can only double the values starting from the right, two by two
09:40:58 <catsup> cool.  isn't there an operator though that doesn't require a list?
09:41:05 <catgocat> it doesn't work for  [8,7,6,5]
09:41:14 <ski> phaazon : well, one is contravariant, and the other is covariant
09:41:18 <catgocat> where it should == [16,7,12,5]
09:41:28 <maerwald> ah you want it that way
09:41:39 <phaazon> ski: yep :)
09:41:54 <maerwald> > (zipWith (*) .) cycle [2,1] $ [8,7,6,5]
09:41:54 <catgocat> maerwald, from the end, [1, 2, 3] would equal [1, 4, 3]
09:41:55 <lambdabot>  [16,7,12,5]
09:42:02 <phaazon> ski: I cannot find any link stating that covariance and contravariance are a bit like 1 and -1 under *
09:42:03 <ski> phaazon : aka, `a' occurs negatively in one and positively in the other
09:42:15 <catgocat> maerwald that doesnt work for [1, 2, 3]
09:42:18 <phaazon> covariance and covariance is covariance
09:42:23 <maerwald> > (zipWith (*) .) cycle [2,1] $ [1,2,3]
09:42:25 <lambdabot>  [2,2,6]
09:42:25 <phaazon> covariance and contravariance is contravariance
09:42:32 <phaazon> contravariance and contravariance is covariance
09:42:41 <maerwald> catgocat: maybe I haven't read the exercise lol
09:42:45 <maerwald> what does it say
09:42:53 <catgocat> http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
09:43:22 <maerwald> beginning from the right, ah
09:43:52 <ski> phaazon : yes. it's a context that may be covariant or contravariant (or both or neither). iow you need to specify both a subexpression (or a hole where a subexpression may be placed) *and* which containing expression you're asking about variance *wrt* 
09:44:09 <Denommus> hi
09:44:28 <ski> catgocat : it would be possible to walk to the end, and then start multiplying on the way back .. but i'm not sure it would be much better than the reversing
09:44:56 <ski> catgocat : however, your `toDigits' could now be written more efficiently, in terms of `toDigitsRev'
09:45:17 <catgocat> ski: I have re-written toDigitsRev, have you seen the annotation?
09:45:18 <safinaskar> ski: kadoban: thanks
09:45:32 <ski> catgocat : yes, i was talking about that annotation
09:45:37 <catgocat> oh
09:45:44 <catgocat> so how would you do it?
09:46:01 <catgocat> ops
09:46:02 <catgocat> ops
09:46:03 <catgocat> ops
09:46:03 <catgocat> ops
09:46:05 <catgocat> wait 
09:46:23 * ski waits
09:46:32 <lpaste> catgocat annotated “homework1.hs” with “homework1.hs (annotation) (annotation)” at http://lpaste.net/136485#a136487
09:46:50 <catgocat> ok I changed it again
09:47:21 <ski> catgocat : oh .. sorry, i missed that typo
09:47:29 <catgocat> by bad hehe
09:47:41 <Denommus> is there a recommended task runner for Haskell?
09:47:46 <ski> catgocat : anyway, do you want a hint, or do you want to ponder it first ?
09:48:01 <dmj`> Denommus: shake maybe
09:48:02 <catgocat> ski: oh, so it could even be better ?
09:48:08 <dmj`> @package shake
09:48:08 <lambdabot> http://hackage.haskell.org/package/shake
09:48:22 <ski> catgocat : yes, by "however, your `toDigits' could now be written more efficiently, in terms of `toDigitsRev'" comment applies to thge untypoed version ;)
09:48:25 <catgocat> I could use `show` and map it over and turn the chars to integers.. but I am not allowed to use toDigitInt
09:48:27 <ski> s/thge/the/
09:49:16 <Denommus> dmj`: is it easy to use it on top of cabal?
09:49:24 <catgocat> ok give me a hitn
09:49:30 <catgocat> s/hitn/hint
09:49:33 <ski> catgocat : the hint : what is the (conceptual) difference between `toDigits' and `toDigitsRev' ?
09:49:58 <ski> what is the observable difference, in terms of inputs and outputs
09:50:00 <ski> ?
09:50:03 <dmj`> Denommus: not sure
09:50:09 <catgocat> I could do `reverse` if that's what you are saying
09:50:32 <catgocat> but it would be more expensive
09:50:42 <ski> catgocat : yes, but `reverse' for which of them ?
09:50:47 <catgocat> or maybe not, because concatenating lists is expensive..
09:50:58 <catgocat> I should use reverse for toDigits because ++ is expensive
09:51:23 <catgocat> is that it?
09:51:31 <ski> yes, you could do that, and it would improve the efficiency :)
09:51:32 <ski> however
09:51:57 <ski> concatenating lists isn't (overly) expensive in itself. `xs ++ ys' needs to run through `xs' to the end to copy it (sharing `ys', since everything is immutable)
09:52:29 <safinaskar> my question: http://paste.debian.net/281967/ . (in short: how to write imperative-like code in haskell?)
09:52:41 <kuribas> ski: it's O(n^2) on the output list.
09:52:54 <catgocat> ski: so your initial hint was related to (++) ?
09:52:59 * hackagebot scotty 0.10.2 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.10.2 (ryanglscott)
09:53:02 <ski> however, *left-nested* concatenation like `((as ++ bs) ++ cs) ++ ds' *is* needlessly expensive, since first `as' will be copied, then the copy of `as' and also `bs' will be copied, then that copy of `as' and the copy of `bs' and also `cs' will be copied
09:53:18 <catgocat> oh I see
09:53:42 <catgocat> very nice
09:53:48 <safinaskar> catgocat: good nick :) it means "concatenate, go, concatenate!", right? :)
09:53:56 <ski> for longer *left*-nested concatenation chains, the number of copies will grow as the *square* of the number of lists, instead of the expected *linear* growth
09:54:08 <catgocat> safinaskar: it has multiple meanings
09:54:10 <chpatrick> safinaskar: I think it depends on what you're trying to do
09:54:20 <chpatrick> maybe you can do it without modification
09:54:30 <catgocat> ski, toDigits = reverse . toDigitsRev ?
09:54:31 <safinaskar> chpatrick: >_<. no i need modification
09:54:31 <ski> catgocat : and in this case, the left-nesting is hidden in the recursion `toDigits n ... = toDigits (n `div` 10) ++ [n `mod` 10]'
09:54:41 <kuribas> safinaskar: What are you trying to do?  That code doesn't even work.
09:54:55 <safinaskar> chpatrick: i have multiply big data structures (data.maps, data.sets etc) and i want to change them
09:55:11 <kuribas> safinaskar: The type of f is wrong (if it's haskell).
09:55:17 <ski> catgocat : so, it's good to learn to spot this sort of recursion trouble and fix it. often by adding stuff to the list in the other order, and then doing a single final reverse at the end (if the order matters)
09:55:25 <ski> catgocat : so, yes :)
09:55:55 <catgocat> ski: very nice, it seems I just want to get the job done but I sometimes forget that these little details matter
09:56:30 <chpatrick> safinaskar: are you certain though? just want to make sure it's not some imperative thinking talking :)
09:56:38 <chpatrick> can you give more context?
09:57:09 <ski> catgocat : it's better to learn to keep an eye out for simple stuff like this, so that you can use the tips and tricks in the more complicated cases, and learn to look for various common problems and improvements :)
09:57:22 <safinaskar> kuribas: okey, fixed version: http://paste.debian.net/281968/ . but this doesn't matter. this is just example code
09:57:31 <orion> Is it legal to write a class instance for a type synonym?
09:57:57 <mniip> no
09:57:58 <ski> catgocat : iow, it probably doesn't matter that much for simple code as this, but learning the principles and such matters
09:58:04 <mniip> orion, no
09:58:12 <ski> orion : with extensions
09:58:22 <chpatrick> yeah it is
09:58:28 <chpatrick> but not any methods
09:58:29 <chpatrick> it's weird
09:58:34 <mniip> ski, how would the instance deduction work in that case
09:58:47 <ski> orion : however, if you have `type Foo = Maybe Bar', then you can't have one instance for `Foo' and another for `Maybe Bar' (since they're equal types, the same type, just different names, ways to refer to it)
09:59:11 <ski> mniip : expand type synonyms first
09:59:17 <chpatrick> oh sorry I thought you meant constraintkinds
09:59:26 <chpatrick> yes with flexibleinstances/typesynonyminstances
09:59:44 <kuribas> safinaskar: The functional way is to return all the variables that you want to modify.
10:00:04 <ttt_fff> what are the most important things that haskell has but ocaml lacks? [strictness + lack of stack frames are killing me]
10:00:12 <maerwald> safinaskar: I don't really know what you are doing but there is Data.Judy in the judy package as a mutable replacement for Data.IntMap. It's all IO based
10:00:17 <chpatrick> ttt_fff: purity?
10:00:37 <safinaskar> chpatrick: kuribas: okey, i will give you context, wait a minute
10:00:58 <maerwald> and it's supposed to be fast and efficient
10:01:08 <kuribas> safinaskar: http://xyproblem.info/
10:02:00 <maerwald> otherwise, people just mix Data.Map with the state monad
10:02:21 <maerwald> I think there are some examples on stackoverflow
10:04:17 <ski> safinaskar : with `ST s' or `IO', you can use `STRef s' or `IORef'. if you want to enforce read-only, then you can do a "coyoneda trick" : `data ReadOnly ref b = forall a. RO (ref a) (a -> b)'. `ReadOnly IORef' and `ReadOnly (STRef s)' can only be read from
10:04:25 <ski> (safinaskar : to be pedantic, you can actually write stuff like `undefine' and `error ...'. but not anything less polymorphic)
10:04:36 <maerwald> but I have seen that mutable structures are sometimes slower, e.g. when I was playing with image processing and JuicyPixels... which has mutable images. So you shouldn't really think that mutable stuff is always faster
10:05:16 <ski> (another name for `ReadOnly' is `CoYoneda')
10:05:22 <maerwald> I think it might be because you lose some compiler optimization, because of that
10:06:22 <kuribas> maerwald: and parallelism
10:06:32 <maerwald> yeah
10:06:35 <ski> maerwald : iirc, something about older GC generations referring to newer ones could impact
10:06:57 <ski> (but thunks ought to be able to incure such by themselves)
10:07:27 <maerwald> and it matters if you have a few million pixels
10:08:19 <kuribas> maerwald: were you using repa or accelerate?
10:08:52 <safinaskar> chpatrick: kuribas: i am writing proof assistant in haskell. current code here: http://paste.debian.net/281969/ , comments are in english and russian. in pa.hs i have lots of variable structures. for example, some function are in so-called unification context. this means that this is natural to modify the following data in this context: uVs :: [Maybe (String, UPTerm)], uUVs :: [UPTerm] and uEqs :: Data
10:08:58 <safinaskar> .Map.Map Int UPTerm. so i created data UnifState = UnifState { ... } and "type UnifMonad = StateT UnifState (Either String)". the problem is: this is not the context in my program. i. e. i have other contexts. and in other context there is other variables that are natural to modify in the context. so, this is too bad to create new monad for every new such context. also, there is a problem: how to call 
10:09:04 <safinaskar> function in one context from function in another context? i requires manual wrapping and unwrapping from one monad to another monad, i don't want this. (of course, i mean calling less strong function from more strong function, i. e. "f" may modify "a" and it call "g", which can read "a")
10:09:32 <safinaskar> *it calls
10:10:04 <maerwald> kuribas: I was mainly just using JuicyPixels API, not sure what they use under the hood
10:12:34 <safinaskar> kuribas: "The functional way is to return all the variables that you want to modify" - so there will be too many of this return variables. i will often repeat this code. and this will be difficult to call one function from another
10:13:33 <kuribas> safinaskar: So the real question is how to combine state monads with different state types?
10:14:22 <kuribas> safinaskar: I would just create a state type that has all contexts, and use that as the state.
10:15:12 <kuribas> safinaskar: And create helper function to modify individual components.
10:15:25 <kuribas> safinaskar: But lenses maybe useful in your case.
10:17:45 <safinaskar> chpatrick: kuribas: ski: again: my problem is: how to write function "f" which is allowed to change "a", "g" - to change "a" and "b" and how to call "f" from "g"? and i don't want to write "do { ...; newA <- return $ g oldA; ...; }". solution should be as easy as "do { ...; g; ...; }"
10:18:25 <safinaskar> ski: you said something about ST and IO. does they allow what i want? i. e. to write such "f" and "g" and have ability to easily call "f" from "g"?
10:22:20 <chpatrick> safinaskar: how about State + lens?
10:22:24 <safinaskar> kuribas: "So the real question is how to combine state monads with different state types?" - yes :) (but i not neccesary use state monads)
10:23:05 <safinaskar> kuribas: "I would just create a state type that has all contexts, and use that as the state" - but then all function will have too strong type
10:23:36 <chpatrick> then why not pass in what you need and return the updated ones?
10:23:39 <kuribas> safinaskar: you can write a HOF to lift function on parts of the state into the complete state.
10:23:50 <safinaskar> kuribas: "But lenses maybe useful in your case" - okey, how to do this with lenses? i know basic lenses, i know "+=". but i don't see how to solve my problem using lenses
10:24:13 <chpatrick> with ST you can pass STRefs around
10:24:21 <chpatrick> but that doesn't feel like the right approach to me
10:24:47 <safinaskar> chpatrick: "State + lens" - how to do this? again, i don't want too strong type of my functions. i. e. it should be clear from function type what variables it allowed to modify
10:24:48 <kuribas> safinaskar: heh, I am not a lens expert, but lens could help you lift those partial state functions into the total state function.
10:25:15 <kuribas> safinaskar: That's what lens is for, modifying parts to modify the whole.
10:25:25 <chpatrick> safinaskar: then take them as parameters?
10:25:39 <safinaskar> chpatrick: "then why not pass in what you need and return the updated ones?" - you mean just return them as tuple? okey, but then it will be difficult to call one function from another
10:25:41 <chpatrick> modifySomething :: TheThing -> TheThing
10:26:18 <kuribas> ST is neat, but it is just a performance optimization.
10:26:20 <chpatrick> :t zoom
10:26:22 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
10:27:16 <chpatrick> I don't know tbh I never felt like I needed this
10:27:26 <chpatrick> usually when I have state then it's ok for most things to mess with it
10:27:32 <chpatrick> if you don't want that then pass it explicitly
10:27:37 <chpatrick> you'll have to do that one way or another
10:28:51 <safinaskar> kuribas: what is HOF? maybe you will give me some link?
10:29:01 <kuribas> safinaskar: higher order function
10:29:48 <kadoban> safinaskar: Basically it's just a function that has another function-type as an argument or result. It's using functions as values. It's quite powerful.
10:29:55 <safinaskar> chpatrick: "STRefs around" - i already considered STRefs and IORefs. they are not for my problem
10:31:13 <naudiz> I'm looking for some easy-to-read books about "advanced" Haskell. I really liked "Efficient C++", is there something similar for Haskell for example?
10:31:29 <safinaskar> naudiz: real world haskell :)
10:31:29 <kuribas> safinaskar: I think your safest bet is to make a datatype that has all your contexts, and use lens combinators to lift functions that work on part of the state into the whole state.
10:31:38 <S11001001> naudiz: how about Parallel and Concurrent Haskell?
10:31:50 <S11001001> naudiz: or are you more interested in advanced typey stuff
10:32:09 <S11001001> naudiz: (not that PCH doesn't have interesting types)
10:32:29 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html -- link to that book
10:33:00 <kuribas> naudiz: http://dev.stephendiehl.com/hask/
10:33:21 <kuribas> naudiz: and https://ocharles.org.uk/blog/
10:33:33 <Cale> Even though it's not exactly Haskell, you might enjoy Benjamin Pierce's "Types and Programming Languages", if you want a better understanding of type systems like Haskell's.
10:33:38 <naudiz> S11001001: I'd like to know how to write "better" code, information on common mistakes, some witchcraft and stuff like that
10:34:21 <naudiz> safinaskar: had a look at it when I started Haskell and found it very confusing... maybe I'll have another look at it
10:34:22 <safinaskar> naudiz: again, i recommend you "real world haskell"
10:34:23 <maerwald> Cale: did you uncover the undefined * 0 thing?
10:35:15 <naudiz> kuribas: those look nice at first glance, thanks
10:36:02 <naudiz> S11001001: also I don't know if I'll ever need concurrent stuff in a larger scale
10:36:17 <S11001001> naudiz: you might never need all the magic spells
10:37:58 <naudiz> I'll have a look at those recommendations... and another one on Real World Haskell. thank you :)
10:38:57 <ski> safinaskar : yes .. another option is to simply use `State RecordOfMutables' -- but then i'm not sure you can control who gets to read (i imagine it can probably be done, but can't see it atm)
10:39:26 <ski> safinaskar : what didn't you like about `STRef s's/`IORef's ?
10:39:38 <nitrix> Hi guys, quick question, why aren't the IO functions documented that they may fail with an IOException ?
10:40:12 <nitrix> IOError I mean
10:40:36 <nitrix> System.IO.Error says "Any I/O operation may raise an IOError instead of returning a result."
10:40:37 <kuribas> :t over
10:40:38 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
10:40:55 <nitrix> But the IO module itself isn't documenting this. It's really bothering me.
10:41:23 <nitrix> I'll make a pull request, I just doubt that I'm the first one catching that.
10:41:27 <nitrix> No pun intended.
10:41:56 <safinaskar> ski: it is not possible to write f which is allowed to change a, g - a and b and call f from g some simple way. i tried
10:42:15 <liste> nitrix at least haddock for openFile has "This operation may fail with:"
10:42:38 <nitrix> I'm on hackage.
10:42:55 <safinaskar> ski: (this was about STRefs)
10:42:58 <nitrix> liste: Oh yeah, I see it.
10:43:04 <liste> http://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO.html#v:openFile
10:43:10 <nitrix> liste: The other ones aren't documented similarly though.
10:43:34 <nitrix> Is writeFile guaranteed to work?
10:44:08 <ski> safinaskar : pass `IORef A' and `IORef B' to `g', pass `IORef A' and `ReadOnly IORef B' to `f' ?
10:44:34 <ski> safinaskar : same with `STRef s's
10:44:50 <P4Titan> Hello all, could someone help me with using the STVector?
10:45:36 <safinaskar> nitrix: of course, no
10:45:49 <safinaskar> nitrix: but it is possible that it ignores errors
10:46:01 <safinaskar> nitrix: so, for example, try to write data to /dev/full on gnu/linux
10:47:11 <safinaskar> ski: okey, but then f will have explicit arguments. and i will have to specify them when i want to call f
10:47:52 <P4Titan> This code is ugly, but I hope it is understood what is intended: http://lpaste.net/136490
10:47:54 <nitrix> Prelude System.IO> writeFile "/dev/full" "Hi!"
10:47:56 <nitrix> *** Exception: /dev/full: hClose: resource exhausted (No space left on device)
10:48:17 <nitrix> Not ignoring errors. This should be documented imo.
10:48:34 <nitrix> I'll open a pull request :) !
10:48:41 <safinaskar> chpatrick: kuribas: ski: well, okey, thanks. i will think about this. probably i will write some new module using template haskell. or maybe i will switch to another language
10:48:48 <liste> awesome nitrix (:
10:49:34 <safinaskar> nitrix: write more. for example, 1MiB-string.   just "hi!" is too short. it is cached. and real writing is attempted only when closing file
10:49:54 <safinaskar> nitrix: or disable caching
10:50:07 <Cale> maerwald: I don't know which change introduced it, but it definitely works like that in 7.10.1
10:50:07 <kuribas> safinaskar: Why aks for advice, and then discard the solution given?
10:50:20 <exio4> nitrix: what should be documented?
10:50:27 <P4Titan> Can anyone help with my issue with STVector?
10:50:41 <safinaskar> kuribas: i don't like any your solution
10:50:49 <nitrix> exio4: writeFile that may fail.
10:50:59 <Cale> maerwald: Oh, right, there was meant to be a new implementation of Integer, perhaps it just came along with that.
10:51:24 <kadoban> P4Titan: You haven't really asked a question yet or anything that I saw … you pasted some code, that's about it?
10:51:43 <maerwald> Cale: wait, so it's Integer specific?
10:51:46 <maerwald> let's see
10:51:53 <maerwald> > foldr (flip (*)) 1 [0..] :: Integer
10:51:54 <lambdabot>  0
10:51:57 <maerwald> > > foldr (flip (*)) 1 [0..] :: Int
10:51:59 <lambdabot>  <hint>:1:1: parse error on input ‘>’
10:52:02 <maerwald> meh
10:52:06 <maerwald> > foldr (flip (*)) 1 [0..] :: Int
10:52:07 <lambdabot>  *Exception: stack overflow
10:52:12 <maerwald> right, cool
10:52:19 <safinaskar> nitrix: oops, sorry. writeFile opens file, then writes and then closes. so, yes, writeFile really can fail
10:52:34 <P4Titan> Ohh, sorry, I though the question was kinda self-evident from the code. Basically, I can extract the values of the STVector with the <- in the do, however, I want to return a regular Bool. How can I escape this monad that is a result of the reading of the individual values
10:52:44 <nitrix> safinaskar: I tried with a larger string, still happens at the close, probably due to the lazyness.
10:52:54 <maerwald> Cale: is it desired behavior even? Because it feels kinda weird
10:53:07 <maerwald> or is it a side effect of other decisions
10:53:21 <nitrix> safinaskar: Anyway, has to be documented, since it's part of the steps that writeFile undergoes. Imo.
10:53:24 <safinaskar> nitrix: but i think there is no documentation bug. you just said "System.IO.Error says Any I/O operation may raise...", so all is okey
10:53:26 <kuribas> safinaskar: well, I can hardly believe you really tried, since you asked 10 minutes ago... But wathever, use what you like.
10:53:50 <nitrix> safinaskar: Yeah, but, you don't know that until you learn about System.IO.Error.
10:53:55 <nitrix> safinaskar: I didn't know.
10:53:55 <safinaskar> nitrix: haskell docs just are not precise such as docs for unix c api
10:54:09 <Cale> maerwald: It probably doesn't hurt much, but I don't know if it's desired or not.
10:55:21 <P4Titan> Anyone know?
10:57:08 <lpaste> Cale pasted “timesInteger” at http://lpaste.net/136491
10:57:19 <glguy> P4Titan: You'll need the type to be: quickUnionConnected :: Int -> Int -> STVector s Int -> ST s Bool
10:57:20 <Cale> maerwald: ^^ there's the new implementation of timesInteger
10:57:24 <kadoban> P4Titan: I assume that type isn't (sanely) possible. That has to be inside a Monad at least.
10:57:26 <safinaskar> nitrix: and even posix guys said to me: "The issue of having to read the introductory text rather than simply finding this copied in the description of each function also exists in ISO C, and it seems unlikely to change there... In any case, there is a lot of language in the standards whose meaning is not entirely obvious until you take the time to study it. This is generally inevitable. Writing a form
10:57:31 <safinaskar> al specification that reflects existing practice is hard work, and the more details you add, the more room there is or mistakes and unintended contradictions. I do think it would be possible to make the text for these functions much more clear and understandable, but it would require extraordinary amounts of work to ensure that the new text has the exact same meaning as the old text, and I think it wou
10:57:37 <safinaskar> ld be hard to justify such a project". http://austingroupbugs.net/view.php?id=895
10:57:38 <maerwald> Cale: it makes so much sense now, lol... not^^
10:58:05 <nitrix> safinaskar: I agree with you, except, those are two separate modules.
10:58:06 <maerwald> my eyes hurt just from looking at it
10:58:13 <lpaste> Cale annotated “timesInteger” with “timesInteger -- older implementation” at http://lpaste.net/136491#a136492
10:58:15 <glguy> P4Titan: and then you can use "runST" around the whole computation (including the creation of the STVector) to remove the "ST s" at the end
10:58:16 <nitrix> And you shoudn't need to know about module X to use module Y.
10:58:36 <Cale> maerwald: The key point is this first line:  timesInteger _       (S# 0#) = S# 0#
10:58:44 <P4Titan> Ok, I think I understand glguy
10:58:47 <P4Titan> thanks
10:58:48 <maerwald> ahaaa
10:59:05 <maerwald> but... the second line does the same
10:59:10 <maerwald> why does it not work though
10:59:21 <Cale> Because the first line already pattern matched on the second argument
10:59:24 <maerwald> ah right
10:59:50 <safinaskar> kuribas: i really tried STRefs/IORefs. about lenses: it is not obvious how to solve my problem using them. and you didn't give some concrete ideas about them. same for state monads
11:00:44 <safinaskar> nitrix: haskell docs are not intended to be tutorial. i. e. it is okey that you don't understand something directly from them. same for any other docs in existense :)
11:01:04 <Cale> maerwald: and in the older implementation, you can see the first line pattern matches both arguments immediately
11:02:08 <nitrix> safinaskar: It's not a misunderstanding though. It's the reference documentation for how the System.IO module behaves, and nowhere in that module does it say that writeFile might fail. You have to read System.IO.Error, to know that.
11:02:15 <Wizek> Is it possible to have Sublime Text tell me what the type is of certain expressions when I select them? Or if not, what is the easiest editor with which I could have this feature? I may even consider using vim. :)
11:02:40 <safinaskar> nitrix: they are two separate modules, but they are still parts of core library. and so they should be dealed as a whole
11:02:42 <nitrix> safinaskar: If you're looking solely at System.IO, you see that openFile may fail, but nothing for writeFile, so you assume it's fine, except it isn't.
11:02:52 <kadoban> Wizek: You can do it in vim and emacs with plugins. I don't know about sublime, I'd assume there's a way. Look into ghc-mod integration perhaps?
11:03:02 * hackagebot atom-basic 0.2.2 - Basic Atom feed construction  http://hackage.haskell.org/package/atom-basic-0.2.2 (cbaatz)
11:03:04 * hackagebot reflex-dom-contrib 0.1 - A playground for experimenting with infrastructure and common code for reflex applications  http://hackage.haskell.org/package/reflex-dom-contrib-0.1 (DougBeardsley)
11:03:05 <Cale> Wizek: Normally, I keep a ghci window open at the same time as my text editor, and ask it for the types of things using :t <expression>
11:03:16 <nitrix> safinaskar: I think it's the wrong attitude. If openFile is documented, so should be writeFile. There's no argument here.
11:04:02 <nitrix> https://git.haskell.org/packages/base.git, 2014, that seems old.
11:04:30 <nitrix> https://git.haskell.org/packages/haskell2010.git maybe?
11:04:48 <ion> > do 1 == 2 == False
11:04:52 <lambdabot>      Precedence parsing error
11:04:54 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
11:04:58 <ion> It seems the Report expects that to parse as
11:05:04 <ion> > (do { 1 == 2 }) == False
11:05:06 <lambdabot>  True
11:05:11 <ion> Note 6, https://www.haskell.org/onlinereport/syntax-iso.html#layout
11:06:13 <arkeet> > False == do 1 == 2
11:06:15 <lambdabot>  True
11:07:12 <arkeet> ion: fun.
11:08:22 <P4Titan> All of the mutable vector types have this as a type 'm (MVector (PrimState m) a)', how do I express that in my function. I want to use ST are the "state" holder. Currently all I have is 'MVector s Int', what is the 'm'?
11:08:29 <ely-se> Has anyone got experience deploying Haskell programs on servers? I don't want to install GHC on the target machine. Preferably I'd just upload the binary from dist/build emitted by cabal.
11:08:45 <ely-se> but do I need to install extra libraries and stuff?
11:08:56 <arkeet> P4Titan: m is ST s, there.
11:09:04 <arkeet> PrimState (ST s) = s
11:09:21 <ski> safinaskar : hm. the explicit arguments make it so that you see in the interface (type signature) of the operation which mutables are required (or really, the types of them, though i suppose one could invent a new dummy type for each distinct one, hmm ..)
11:09:32 <P4Titan> So would my type be ST s (STVector s Int)?
11:09:45 <arkeet> ST s (MVector s Int)
11:09:51 <P4Titan> yes
11:10:02 <arkeet> or STVector yeah.
11:10:05 <arkeet> since that's a type synony.
11:10:06 <arkeet> m
11:10:40 <P4Titan> That is ugly, is there a way to form a type that is both meaningful and also cleaner?
11:10:59 <arkeet> I can't imagine how it could be cleaner?
11:11:24 <P4Titan> I dont want type MyVector s = ST s (MVector s Int) since that is not really meaningful that it is a ST with a MVector, etc.
11:11:36 <ski> safinaskar : .. i suppose it would possibly be more useful to express the dependency not as an explicit argument. iow either as as argument of your idiom/monad, or (which would be nicer, if it could be done) as constraints
11:11:36 <P4Titan> I am not sure, it looks un-haskell like
11:11:39 <arkeet> ST s (MVector s Int) isn't a vector.
11:11:41 <arkeet> it's a ST action.
11:11:56 <P4Titan> Yes, inside is the vector, correct?
11:12:01 <arkeet> the result is a vector.
11:12:20 <safinaskar> ely-se: if this is gnu/linux (or maybe some another unix-like system), then just do "ldd" on compiled haskell binary and see whatever it really depends on some missing libraries
11:12:22 <P4Titan> I know "inside" is not proper when refereing to things like ST and IO, but I picture it like that
11:12:26 <kuribas> safinaskar: <chpatrick> :t zoom
11:12:32 <kuribas> :t zoom
11:12:33 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
11:12:36 <safinaskar> ely-se: or just try to run this binary on server
11:12:36 <P4Titan> Ok, I'll try the full type
11:12:40 <glguy> P4Titan: You'd pass just a "MVector s Int" as a function argument
11:12:51 <P4Titan> Say again?
11:13:02 <safinaskar> ely-se: if there is no some library, you will see an error "missing library libblabla.so"
11:13:12 <ely-se> ok
11:13:16 <ely-se> let's try that
11:13:24 <kuribas> safinaskar: https://hackage.haskell.org/package/lens-3.2/docs/Control-Lens-Zoom.html
11:13:26 <glguy> myFunction :: MVector s Int -> ST s SomeResult
11:13:27 <nitrix> Worst than missing library are improper library versions.
11:13:41 <P4Titan> And then use the >>= to combine functions?
11:13:48 <nitrix> Personally, I build, test and deploy my applications from whitin the same docker containers.
11:14:04 <ely-se> safinaskar: seems to depend only on libiconv and libc, nice :)
11:14:07 <glguy> P4Titan: Yes. >>= directly or do-notation
11:14:14 <ely-se> thanks!
11:14:21 <P4Titan> I'll try to make it work with my code. Thanks to all!
11:14:33 <P4Titan> Could applicative monads be used here?
11:14:47 <safinaskar> ski: if i use explicit arguments, i can ocasionally swap them
11:14:50 <glguy> "ST s" is a Functor, Applicative, and Monad instance
11:15:12 <P4Titan> Are all monads by nature applicative and functors? This may be a silly question. ;P
11:15:22 <ely-se> yes
11:15:23 <arkeet> yes
11:15:30 <P4Titan> Ok
11:15:32 <P4Titan> thanks
11:15:34 <ely-se> in the latest version it's even required through the type system
11:15:38 <greymalkin> I think you'll all appreciate this: I have finally grokked Monads -- and I'm not going to write a blog post about it ;)
11:15:46 <ely-se> you can't instantiate Monad without also instantiating Applicative and Functor
11:15:48 <ski> safinaskar : yes, unless you manually disambiguate the types
11:16:23 <ski> P4Titan : and all applicative functors are functors
11:16:26 <ely-se> P4Titan: functors are appliicatives: fmap f x = pure f <*> x
11:16:44 <P4Titan> :t pure
11:16:45 <ski> ely-se : other way around
11:16:45 <lambdabot> Applicative f => a -> f a
11:16:56 <chpatrick> yeah applicatives are functors
11:16:57 <P4Titan> :t (<$>)
11:16:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:17:13 <P4Titan> :t fmap
11:17:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:17:16 <ski> @type let fmap f x = pure f <*> x in fmap
11:17:17 <lambdabot> Applicative f => (a -> b) -> f a -> f b
11:17:43 <ski> if you have already implemented `pure' and `(<*>)', then that gives you an `fmap' for free
11:18:03 <P4Titan> yes, I understand the types now
11:18:04 <ski> it is called `liftA'
11:18:07 <ski> @type liftA
11:18:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
11:18:24 <ely-se> you can also implement all methods in Applicative using only return and >>=
11:18:39 <chpatrick> :t ap
11:18:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:18:47 <chpatrick> you don't need >>=
11:18:59 <ski> so, sometimes you'd do `instance Functor Blah where fmap = liftA' and also `instance Applicative Blah where pure x = ..x..; .. <*> .. = ...'
11:19:04 <P4Titan> what is the difference between liftA and fmap?
11:19:11 <ely-se> nothing
11:19:19 <P4Titan> Ok
11:19:20 <chpatrick> they're equivalent but liftA is defined in terms of Applicative stuff
11:19:31 <P4Titan> Any reason to prefer one over the other?
11:19:37 <Denommus> P4Titan: none, it's just a different name because liftA2, liftA3, and et cetera also exist
11:19:40 <Denommus> :t liftA2
11:19:41 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:19:45 <Denommus> :t liftA3
11:19:46 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:19:46 <chpatrick> fmap because it's the more general one
11:19:53 <P4Titan> ok
11:19:57 <chpatrick> or usually <$> if it's convenient to use infix
11:20:13 <ski> `liftA' can be used as a default implementation of `fmap', if you have already made an `Applicative' instance (without cyclically using `fmap'/`(<$>)' for the type you're making an instance of)
11:20:27 <ely-se> I use `fmap` infix because I'm too lazy to upgrade GHC and to import Control.Applicative ((<$>))
11:20:28 <ely-se> :P
11:20:39 <ski> `(<$>)' is just another name for `fmap'
11:20:48 <chpatrick> ely-se: it's in the Prelude now
11:20:55 <chpatrick> since 7.10
11:20:55 <ely-se> Yes, I know.
11:21:00 <ely-se> I'm still on 7.8.
11:21:03 <ski> if you have already made a (working) instance of `Functor' and `Applicative', then there's no difference
11:21:05 <chpatrick> oh sorry I didn't see upgrade
11:21:29 <ski> similarly, `ap' can be used as a default implementation of `(<*>)', if you already have a `Monad' instance
11:21:47 <ski> (and `liftM' as a default `fmap', if you have `Monad')
11:22:22 <ski> (.. and obviously `return' can be used for `pure' (or the other way around))
11:22:40 <Gurkenglas> Why is it class Functor f => Applicative f, not class Applicative f and instance Applicative f => Functor f?
11:23:08 <chpatrick> because all applicatives are functors, not the other way around
11:23:20 <ski> `class Functor f => Applicative f' means that for it to possibly be an applicative, it must already be a functor
11:23:24 <chpatrick> and the second instance would overlap with everything
11:23:29 <ski> and that
11:23:57 <Gurkenglas> chpatrick, what I wrote is consistent with what you said
11:24:10 <Gurkenglas> ski, instance Applicative f => Functor f means the same
11:24:17 * ski employs "idiom" as a synonym for "applicative (functor)"
11:24:20 <fishythefish> Gurkenglas, no, that means in order to be a functor, you must be applicative.
11:24:21 <ski> Gurkenglas : no
11:24:43 <Gurkenglas> ???
11:24:52 <fishythefish> The LHS of "=>" is a precondition
11:25:07 <fishythefish> The RHS is the actual thing you're talking about.
11:25:12 <Gal3rielol> Hi, I'm using a (State SourcePos) as the inner monad of ParsecT. I'm also using LanguageDef to generate some token parser. but when I provide `letter` as identStart, it doesn't type check.
11:25:29 <Gurkenglas> instance Applicative f => Functor f is what you write before an implementation that will for each applicative describe its functor instance
11:25:41 <ski> `instance Applicative f => Functor f' means that every idiom is a functor .. but because of overlapping rules, that would also disallow explicit stuff like `instance Functor (Either e)' and so on
11:25:52 <ski> iow "overlap with everything"
11:26:14 <Gal3rielol> it says no instance SourcePos arising from a use of Text.Parsec.Char.letter
11:26:47 <fishythefish> Gurkenglas, oh, sorry, didn't see you swapped "class" and "instance"
11:26:51 <ski> `=>' in an `instance' declaration is implication. i think `=>' in a `class' declaration is more like a presupposition
11:27:02 <Gurkenglas> That overlap would have the overlapping instance declarations be equivalent where they overlap, right?
11:27:05 <mniip> Gal3rielol, paste full error message and relevant code snippet?
11:27:36 <Gurkenglas> (But a way to resolve that problem would be to remove the functor instance declaration for everything that has an applicative instance declaration... that seems sane anyway)
11:27:42 <mniip> Gurkenglas, assuming fmap f x = pure f <*> x, yes
11:27:52 <ski> Gurkenglas : overlapping instances are disallowed. it'd simply not work with any concrete instances
11:27:58 <Gurkenglas> mniip, isn't that a law?
11:28:36 <ski> (there is an extension that allows it, but it's usually considered a bad thing (and the incoherent instances extension even more))
11:28:36 <mniip> it follows from the laws yes
11:29:36 <mniip> Gurkenglas, I meant a definition of fmap, as you proposed implementing a functor instance using applicative
11:29:49 <Gurkenglas> Okay sure, let's follow the conversation down the path where all those functor instance declarations for types with applicative declarations are removed.
11:29:54 <ski> (.. undecidable instances is another thing. if your compile (or maybe the compilation of the client using your library) terminates, you're fine)
11:30:28 <chpatrick> Gurkenglas: it's not about the instance declarations, instance Functor f overlaps with _everything_
11:30:46 <Gurkenglas> remove _everything_ /s
11:30:55 <chpatrick> what if they're not applicative?
11:31:03 <Gurkenglas> then don't remove
11:31:08 <ski> it doesn't work
11:31:10 <chpatrick> but then they overlap
11:31:14 <ski> the compile will complain
11:31:22 <Gurkenglas> remove only where they're applicative?
11:31:34 <chpatrick> then it still overlaps for everything else
11:31:41 <safinaskar> chpatrick: kuribas: ski: "zoom" is not for me. first argument for "zoom" is explicit lens which convert one state to another. i want solution where i don't need to specify explicit state converter
11:32:02 <chpatrick> safinaskar: it's not possible man
11:32:06 <chpatrick> only with STRefs
11:32:14 <Gurkenglas> How would instance Applicative f => Functor f overlap with fs that aren't applicative?
11:32:18 <chpatrick> otherwise one way or other the function will be able to modify the state
11:32:23 <chpatrick> even if it promises only to touch parts of it
11:32:50 <mniip> Gurkenglas, because instance head is the overlapping part
11:32:53 <chpatrick> instance ... Functor f will overlap with any other Funcotr instance
11:32:55 <mniip> context is checked last
11:32:57 <ski> Gurkenglas : only instance heads are (conservatively) considered for overlapping, not the instance body/context
11:33:03 <chpatrick> it doesn't check the instance context
11:33:08 <Hijiri> safinaskar: How would it know how to embed the inner state in the outer state?
11:33:17 <ski> Gurkenglas : it commits to the head without looking at the part before the `=>'
11:33:20 <Hijiri> For example, data Pair a = Pair a a
11:33:34 <Hijiri> if you have a state function for a, that could be either editing the first or second element
11:33:37 <Hijiri> Or both, or neither
11:33:38 <ski> Gurkenglas : and then, if there's another candidate instance with an overlapping head which matches, you have a problem
11:33:39 <chpatrick> Gurkenglas: if what you really want is like a pointer parameter in C then use STRefs
11:33:44 <chpatrick> err
11:33:49 <chpatrick> *safinaskar
11:33:50 <Hijiri> The implicit function would have no idea what you are trying to do
11:33:58 <Gurkenglas> Well that sucks. Why does it do that?
11:34:10 <chpatrick> I think it's a decidability thing
11:34:18 <chpatrick> to make sure compiling terminates
11:34:22 <safinaskar> chpatrick: "it's not possible" - i think this is possible. i probably will write my module using something like template haskell
11:34:33 <safinaskar> Hijiri: same for you
11:34:44 <chpatrick> safinaskar: is it really worth all that effort just to avoid passing parameters around?
11:35:02 <safinaskar> chpatrick: yes
11:35:03 <chpatrick> I mean what would the type of these functions look like with your solution?
11:35:12 <chpatrick> they'll need access to the state somehow right?
11:35:38 <mniip> Gurkenglas, because only lawful instances of functor and applicative agree
11:35:42 <ski> chpatrick(,safinaskar) : (i think) they (more or less) want to express statically which in *scope* mutables they want to use (and whether it's write-only, read-only, or read-write) .. with a minimum of fuss when crossing boundaries (within the same outer scope)
11:35:45 <Hijiri> safinaskar: do you have any specific reasoning that addresses what I said, or is it just a hunch
11:35:53 <mniip> in case of unlawful instances, or instances of another pair of typeclasses
11:35:57 <mniip> you will have an ambiguity
11:36:11 <mniip> the fact that instances are an open world is also a problem
11:36:26 <safinaskar> chpatrick: just pass parameter is worst solution. because it means very ugly do { a1 <- return $ f a; a2 <- return $ f a1; ... } (this is very error-pone/prone). also, this is very possible to ocasionally swap function parameters
11:36:28 <ski> chpatrick(,safinaskar) : so, not values representing a mutable location (which could be replaced by any other reference/location of the same type), but a static name for the location itself
11:36:43 <chpatrick> safinaskar: ok, so why not strefs?
11:36:57 <chpatrick> you could pass in an STRef (Map foo bar) and then let it modify it
11:37:04 <chpatrick> exactly like you want
11:37:10 <ski> safinaskar : at least i've earlier wanted what i'm describing .. and i'm suspecting this is more or less what you want
11:37:15 <safinaskar> chpatrick: "I mean what would the type of these functions look like with your solution?" - currently i don't know
11:37:17 <Hijiri> I remember you could do something like implicit inference of which mutable using extensible efects
11:37:30 <Hijiri> You would have one state effect for each state thing you wanted
11:37:47 <Hijiri> and it will infer the type of put and get based on what the argument is
11:37:54 <safinaskar> ski: "(i think) they (more or less) want to express..." - yes
11:38:04 <Hijiri> but to use that solution you would have to use eff
11:38:15 <Hijiri> maybe it could be adapted to be independent
11:38:40 <mniip> Gurkenglas, imagine something like this http://lpaste.net/5920524894692442112
11:39:09 <ski> chpatrick : "I mean what would the type of these functions look like with your solution?" -- either the mutables are accounted for in some parameter of the idiom/monad, or one uses some kind of (new) constraint (cf. effect typing systems)
11:39:12 <Hijiri> http://fho.f12n.de/posts/2014-10-25-easily-extensible-entity-enigma.html this uses the implicit state type thing I mentioned
11:39:18 <Hijiri> but it's not the main focus of the post
11:39:29 <Hijiri> or rather, it's just part of the whole thing
11:39:32 <mniip> Gurkenglas, when file 1 is compiled, value becomes False
11:39:38 <safinaskar> Hijiri: "do you have any specific reasoning..." - yes i have. i think i can do this using something like code generation. i. e. at first i generate lots of botterplate code which describes my very own monads. and then i simply call one monad from another. i still don't know all details, my idea is not implemented yet
11:39:58 <mniip> but when file 2 is compiled, value should be True, because it is an instance of Eq
11:40:01 <mniip> but file 1 is already compiled
11:40:13 <ski> chpatrick : heterogenous maps are complicated
11:40:27 <Hijiri> safinaskar: It sounds like you would still have to specify which slot to mutate
11:40:46 <safinaskar> ski: "but a static name for the location itself" - probably
11:40:54 <ski> Hijiri : ty
11:41:25 <Gal3rielol> it's my mistake, I imported the wrong State
11:41:29 <safinaskar> chpatrick: "ok, so why not strefs?" - i will have to specify all arguments when i call one function from another. and i can ocasionally swap arguments
11:41:33 <xyh> are there any IRC channels about type theory, proof theory and type system ? 
11:41:59 <mniip> xyh, #haskell is the best fit probably
11:42:34 <chpatrick> safinaskar: could you have a typeclass for each thing that you want to access? then your type would be (MonadState s m, HasFoo s, HasBar s) => m ()
11:42:39 <Welkin> xyh: #categorytheory
11:42:48 <chpatrick> that way it couldn't mess with anything else because it's polymorphic in the state
11:43:03 <JamesJRH> xyh: There is also ##cs, which it would be on-topic on.
11:43:11 <chpatrick> the typeclass could contain a lens for the given field
11:43:20 <JamesJRH> (But not specifically so.)
11:43:41 <Gurkenglas> mniip, the way I imagine it is that file 1 or file 2 alone should work, and compiling both should have everything break in subtle and hilarious ways because the law of instances being equal where they overlap has been broken... now that I say that out loud, I can understand why others would prefer instance overlaps being outlawed in general. (Of course, this is all assuming that instance contexts really can't be f
11:43:41 <Gurkenglas> actored into the decision)
11:43:45 <Welkin> xyh: er, ##categorytheory
11:44:13 <xyh> Welkin: thx :)
11:44:28 <Welkin> what is lambdabot doing in #unicycling?
11:44:32 <mniip> Gurkenglas, there is no way to prove that a type isn't an instance of a typeclass
11:44:39 <mniip> because it can always be made one at a later time
11:44:47 <ski> xyh : there is ##typetheory, and ##hott. also #coq,#agda,#idris,#epigram,#twelf,...
11:44:52 <mniip> well except for kind mismatches
11:44:56 <chpatrick> safinaskar: I think makeClassy from lens might do this automatically
11:45:35 <chpatrick> err maybe not
11:45:37 <ski> xyh : and #constructive-math (and i suppose ##logic) is also partly related
11:45:56 <chpatrick> safinaskar: actually it's makeFields
11:46:35 <ski> xyh : .. and #compilers
11:46:45 <safinaskar> Hijiri: i will see your link
11:47:02 <uwap> :t catch
11:47:03 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
11:47:12 <uwap> is there an implementation like this for MonadIO?
11:47:33 <mniip> uwap, lift catch?
11:47:38 <mniip> er liftIO catch
11:47:59 <ski> @hackage extensible-effects
11:47:59 <lambdabot> http://hackage.haskell.org/package/extensible-effects
11:48:00 <uwap> more like (Exception e, MonadIO m) => m a -> (e -> m a) -> m a
11:48:00 <chpatrick> uwap: MonadCatch?
11:48:04 * hackagebot diagrams-hsqml 0.1.0.0 - HsQML (Qt5) backend for Diagrams  http://hackage.haskell.org/package/diagrams-hsqml-0.1.0.0 (mjmrotek)
11:48:05 <P4Titan> Could someone guide me to make this work? http://lpaste.net/136500 I am trying to use the ST to have a mutable vector. There is some interference between this dubious `s` in the ST monad.
11:48:06 <safinaskar> Hijiri: "have to specify which slot to mutate" - when i modify one variable, then, of course, i specify which variable i modify. but when i call one function from another, i don't want to specify lots of arguments or some explicit state-modify function
11:48:13 <mniip> ah you need the monad stack in the handler
11:48:16 <ski> safinaskar : that ^ package was mentioned in that post
11:48:57 <mniip> uwap, as a workaround you could always do liftIO try
11:49:22 <uwap> :t try
11:49:23 <lambdabot> Exception e => IO a -> IO (Either e a)
11:49:34 <chpatrick> uwap: https://hackage.haskell.org/package/exceptions-0.3.1/docs/Control-Monad-Catch.html
11:49:44 <catgocat> Why can I reassign a variable with `let`, in ghci? let x = 10; let x = 11;
11:49:51 <uwap> hmm. nah. the part that throws the exception isn't an IO, but an IO transformer.
11:50:00 <catgocat> x; -- returns 11
11:50:01 <ski> P4Titan : which package is `STVector' from ?
11:50:19 <chpatrick> ski: vector
11:50:32 <Hijiri> catgocat: The second assignment is really a new variable in a new scope
11:50:34 <Hijiri> with the same name
11:50:35 <ski> catgocat : shadowing. the second `x' is a different variable
11:50:38 <uwap> chpatrick, that might work. thanks
11:50:51 <catgocat> ski: wait, does this work on source files too?
11:50:56 <Hijiri> You can think of it like let x = 10 in let x = 11 in x
11:51:01 <P4Titan> ski: STVector is an alias to MVector from the mutalbe vector package
11:51:05 <verement> > let x = 10 in let x = 11 in x
11:51:07 <lambdabot>  11
11:51:11 <ski> catgocat : try `let x = 10', then `let f y = x + y' and then `let x = 11'. if you now call `f', the `x' it uses will still refer to `10'
11:51:14 <catgocat> verement: that makes sense
11:51:53 <catgocat> ski: and is this normal behavior in source files too?
11:51:54 <Hijiri> catgocat: ghci input is sort of like a big do-block, in terms of how let works
11:52:00 <P4Titan> catgocat: I believe it is called lexical scope
11:52:16 <ski> catgocat : at the top-level of a source file, all bindings are (conceptually) mutually recursive (so you can write definitions in any order you like). the same for bindings after `where', and for bindings between `let' and `in'
11:52:18 <Hijiri> So you can do similar things in a do-block, but not in general in a source file
11:52:47 <ski> catgocat : if you write `let x = 10' and then `let x = 11' in the interactor, then that is similar to saying `let x = 10 in let x = 11 in ...', which would be shadowing
11:53:13 <catgocat> however doing this in top-level gives an indentation error
11:53:48 <P4Titan> Anyone have ideas on the issue I have with the ST?
11:53:55 <catgocat> so this only happens within ghci right?
11:54:03 <verement> > Just 10 >>= \x -> Just 11 >>= \x -> return x
11:54:05 <lambdabot>  Just 11
11:54:43 <liste> catgocat it works that way inside do
11:54:44 <liste> too
11:54:46 <chpatrick> p4titan: you're not meant to return stvectors/refs from an ST
11:54:54 <chpatrick> they're sandboxed
11:55:02 <P4Titan> meaning?
11:55:20 <chpatrick> get rid of the runST 
11:55:21 <liste> @undo do {let x = 5; let y = 6}
11:55:21 <lambdabot> <unknown>.hs: 1: 16:Parse error: let
11:55:30 <P4Titan> What will that do?
11:55:32 <liste> @undo do {let x = 5; let y = 6; return ()}
11:55:33 <lambdabot> <unknown>.hs: 1: 16:Parse error: let
11:55:43 <chpatrick> you should only do runST at the very top of your computation
11:55:56 <ski> P4Titan : <https://hackage.haskell.org/package/vector> ?
11:56:01 <chpatrick> if you do two st-related things they should both be in ST
11:56:05 <P4Titan> What do you mean top?
11:56:11 <chpatrick> like where you get the final result
11:56:24 <P4Titan> What if I want that to be my final location?
11:56:24 <chpatrick> the intermediate bits should return ST s (...)
11:56:33 <ski> @undo do let {x = 10}; let {x = 11}; return ()}  -- liste,catgocat
11:56:33 <lambdabot> <unknown>.hs: 1: 41:Unexpected }
11:56:38 <chpatrick> then you shouldn't return STVector because it doesn't make sense
11:56:39 <ski> @undo do let {x = 10}; let {x = 11}; return ()  -- liste,catgocat
11:56:40 <lambdabot> let { x = 10} in let { x = 11} in return ()
11:56:57 <P4Titan> why does it not make sense?
11:57:01 <ski> catgocat : there you see the nested `let'-`in's, which gives you shadowing
11:57:05 <chpatrick> because you can only use an STVector in ST
11:57:11 <chpatrick> not outside
11:57:18 <P4Titan> I dont mean to be asking so many questions, but why?
11:57:37 <ski> P4Titan : you should only use `runST' when you're done modifying your mutable stuff
11:58:06 <P4Titan> should I do something like freeze $ runST $ ... to return a regular vector?
11:58:27 <kadoban> P4Titan: The entire point of STVector is to keep it isolated in a contained ST, basically. If you don't want that … you can use a different vector?
11:58:45 <ski> P4Titan : `runST' encapsulates the mutable state inside itself, ensuring it doesn't leak out. if it were allowed to leak out, then since that computation is no longer sequenced wrt other such mutating computations, it would be hard to predict in which order modifications would happen
11:58:59 <P4Titan> I need STVector to change single elements at O(1)
11:59:51 <ski> P4Titan : `ST' means "State Thread", which conceptually should be thought of as an initial creation of an empty "heap", then later allocations of mutable cells and arrays (and vectors and so on) in it, with all accesses and modifications explicitly sequenced by the `ST s' monad (or something derived from that)
12:00:38 <ski> P4Titan : at the end, you compute some final result whose type doesn't mention `s' (`runST' ensures this), so that you can then hide the fact that you've used mutable state internally, by using `runST'
12:00:40 <P4Titan> Ok, ... here is my real question how can I make a Vector Int out of ST s (STVector s Int) after I am all done?
12:01:10 <ski> P4Titan : a separate use of `runST' is a distinct state thread. overlap (one thread reading mutables of another) is not allowed
12:01:37 <ski> P4Titan : you need to freeze the vector into an immutable version (or otherwise summarize it) before using `runST'
12:01:38 <P4Titan> Because this fails: quickUnionMethod nNums pairs >>= V.unsafeFreeze >>= runST
12:02:47 <P4Titan> With this: Couldn't match type `forall s. ST s (ST s0 b0)' with `Vector Int'
12:02:47 <P4Titan>     Expected type: Vector Int -> ST s0 b0
12:02:47 <P4Titan>       Actual type: (forall s. ST s (ST s0 b0)) -> ST s0 b0
12:03:05 * hackagebot regress 0.1 - Linear and logistic regression through automatic differentiation  http://hackage.haskell.org/package/regress-0.1 (AlpMestanogullari)
12:03:05 <ski> P4Titan : `... >>= runST' is wrong', you should have `runST (...)'
12:03:19 <P4Titan> derp
12:03:34 <ski> P4Titan : something like `runST (V.unsafeFreeze =<< quickUnionMethod nNums pairs)' might work
12:03:37 <catgocat> ski: yes, nice
12:04:12 <P4Titan> It works, finally! Thank you all. Now that I have working state Haskell code, I can go back and try to fix up things to make it prettier and all. Thanks!
12:04:21 <ski> @hoogle runSTArray
12:04:21 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
12:04:21 <lambdabot> Data.Array.ST.Safe runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
12:04:27 <catgocat> ski: although I don't think it's that pretty
12:06:11 <P4Titan> Is it possible in a do to have a if without the else?
12:06:46 <ski> P4Titan : `runSTArray' is built similarly, using `runST' and `unsafeFreezeSTArray' -- it would probably be nicer in your case to make an `runSTVector :: (forall s. ST s (MVector s e)) -> Vector e' or something like that, encapsulating the `V.unsafeFreeze' in a nicer way
12:06:50 <catgocat> if expressions have to return something
12:07:04 <ski> P4Titan : use :
12:07:10 <ski>   when ... $ do
12:07:12 <ski>     ...
12:07:17 <ski> or `unless' instead of `when'
12:07:23 <P4Titan> :t when
12:07:24 <lambdabot> Applicative f => Bool -> f () -> f ()
12:07:41 <safinaskar> chpatrick: yes, makeFields is very good. but let's assume i have g :: Foo -> Foo and f :: Bar -> Bar. how to call f from g? i assume Foo and Bar from example in Lens.TH
12:07:42 <catgocat> :t unless
12:07:43 <lambdabot> Applicative f => Bool -> f () -> f ()
12:07:47 <catgocat> what is the difference?
12:08:04 <ski> `when' runs the "body argument" when the boolean is `True'
12:08:05 * hackagebot regress 0.1.1 - Linear and logistic regression through automatic differentiation  http://hackage.haskell.org/package/regress-0.1.1 (AlpMestanogullari)
12:08:10 <safinaskar> catgocat: maybe first argument is inversed?
12:08:15 <ski> `unless' runs it unless it is `True'
12:08:46 <catgocat> oh right i'm dumb
12:08:57 <ski> catgocat : you don't think shadowing id that pretty ? or something else ?
12:09:04 <P4Titan> Than you all!
12:09:08 <P4Titan> bye!
12:09:15 <ski> have fun !
12:10:12 <catgocat> ski: when I was learning haskell for the first time I used ghci for everything, and I stuck like 10 minutes trying to figure why `x = 10` gave an error, till I found let
12:10:35 <catgocat> so.. it's not that intuitive I think
12:10:58 <ski> oh, you mean that the interactor is more or less like the commands in a `do'-expression. so that you need `let' for bindings
12:11:16 <kadoban> I found ghci ridiculously confusing at first. It's much better, IMO, if you kind of just write all of the definitions in a file to start with, and :load in into ghci to play with (and then :reload occasionally)
12:11:34 <nitrix> Is there an easy way to call a IO function inside the IO monad if something is a Just value?
12:11:43 <nitrix> Is this a case for applicative functors?
12:11:52 <Hijiri> if what is a Just value?
12:11:55 <kadoban> catgocat: So if you find yourself defining big functions or whatever in ghci, I'd say you're probably doing in wrong, IMO.
12:11:58 <Gurkenglas> Why are when and unless (Bool -> f () -> f ()), not (Bool -> f a -> f a) ?
12:12:01 <nitrix> Let me post a snippet actually.
12:12:07 <ski> having the interactor act more like the source file top-level doesn't work that well, since then one'd expect bindings to be (potentially) mutually recursive, iow recursive with stuff you haven't entered yet
12:12:21 <ski> (though you can enter multiple lines with `:{' and `:}' in GHCi)
12:12:27 <Gurkenglas> nitrix, give us a type signature?
12:12:39 <ski> nitrix : `forM_' or `forM' ?
12:12:47 <nitrix> providerUpdate :: Provider -> BlockId -> Block -> IO (Maybe BlockId)
12:13:18 <nitrix> Update will be implemented as calling providerCreate, if successful, will call providerDelete on the old resource and return a new one.
12:13:25 <Peaker> wouldn't it be nice if GHC figured out whether the results are used and had avoided accumulating the list if it is unnused?
12:13:37 <ski> Gurkenglas : what should be monadically (or idiomatically) returned, in the other case ?
12:13:39 <Hijiri> there might be something in monad-loops
12:13:54 <Gurkenglas> Rather, give us the shortest type signature whose inhabitant you could transform into a solution to your problem
12:13:56 <Peaker> (OTOH, forM_/mapM_ have a strong justification for existing, Foldable instead of Traversable requirement)
12:14:07 <ski> Gurkenglas : an alternatice would be to have `Bool -> f a -> f (Maybe a)'. `Bool -> f a -> f a' wouldn't work
12:14:23 <Hijiri> nitrix: whileJust from monad-loops
12:14:37 <Hijiri> or whileJust' to throw away the intermediate BlockIds
12:14:43 <Gurkenglas> ski, right, for some reason I thought there was someting like mzero.
12:15:00 <Hijiri> I mean whileJust_
12:15:03 <ski> Peaker : something like the modes and insts in Mercury could possibly be used to statically figure out that some parts of the output won't be demanded at all, and so doesn't need to be constructed
12:15:20 <liceoprova> ciao
12:15:23 <Peaker> ski: what are modes and insts?
12:15:25 <liceoprova> !list
12:15:25 <monochrom> liceoprova: http://okmij.org/ftp
12:15:26 <maerwald> Gurkenglas: you looking for something like this? http://lpaste.net/136501
12:15:50 <ski> Gurkenglas : well, yes. those combinations can also be useful (`guard' and `guard . not' i suppose)
12:15:50 <Gurkenglas> Exactly. Though it sounds like it should be "ApplicativePlus"
12:16:01 <Peaker> ski: it sounds like an easy problem to solve statically (for cases that discard without conditionals)
12:16:13 <maerwald> Gurkenglas: I use that function, no idea why it's in no library
12:16:21 <Hijiri> :t whileJust
12:16:22 <lambdabot> Monad m => m (Maybe a) -> (a -> m b) -> m [b]
12:16:40 <ski> Peaker : in logic programming, you compute stuff by *relating* values via relations, rather than mapping inputs to outputs via functions
12:18:52 <Gurkenglas> Is whileJust useful for any monad that's not a transformer stack with IO at the bottom?
12:19:02 <ski> Peaker : there's no inherent "forward" or "backward" for such relations. often they will work in several directions (like if you could use `(++)' (one single implementation) to do the job of `isPrefixOf' and `stripPrefix', e.g.. and just one predicate instead of `ord' and `chr')
12:19:12 <nitrix> http://lpaste.net/136503
12:19:19 <Peaker> ski: Yeah, I know that part :)
12:19:31 <nitrix> Any way to make providerUpdate more concise?
12:19:47 <ski> Peaker : in Prolog, the predicate call `append(As,Bs,AsBs)' expresses that `AsBs' is the concatenation of `As' and `Bs' (cf. `asbs = as ++ bs')
12:20:12 <Peaker> ski: Yeah -- I know the (very basics of) Prolog -- I don't know what "modes and insts" are
12:20:37 <ski> Peaker : one *mode* of calling append/3 is `(+,+,-)', meaning that you provide the first two arguments, and (in case of a success/solution), append/3 computes the third argument
12:20:42 <Hijiri> Gurkenglas: You could use it for a stateful computation that can end early
12:21:02 <Hijiri> intermediatething -> State s (Maybe intermediatething)
12:21:15 <Gurkenglas> Hmm. Of course.
12:21:18 <ski> Peaker : other useful modes are `(+,+,+)' (testing), `(+,-,+)' (stripping a prefix), and `(-,-,+)' (splitting a list in two, in every possible way)
12:21:34 <Peaker> ski: cool
12:21:39 <Peaker> ski: and what are "insts" ?
12:22:46 <ski> (Peaker : each mode is also associated with how many solutions it can have. `det' (deterministic) is one, `semidet' (semideterministic) is at most one, `multi' (multideterministic) is at least one, `nondet' is any number of solutions (`failure' for a mode that always fails, `erroneous' for one that never returns (perhaps raising an exception)))
12:23:23 <Gurkenglas> nitrix, why is the return type of providerUpdate Maybe BlockId? Aren't you wrapping in Just in all the leaves anyway?
12:23:58 <ski> Peaker : `+' means the argument is fully known (fully instantiated, ground) before the call (and also after every success). `-' means the argument is completely unknown (uninstantiated) before the call, ground after any success
12:24:12 <nitrix> Gurkenglas: You're right, it'd be always a BlockId in this case.
12:24:49 <ski> Peaker : however, having a value be partially known can also be useful. e.g. you could have a finite map, where keys are known, but values are yet unknown (to be filled in (instantiated) by some predicate .. this is different from mutation)
12:25:23 <Peaker> ski: sounds like more flexible evaluation order
12:25:24 <nitrix> Gurkenglas: Let me fix that quickly.
12:25:40 <Peaker> ski: though I guess "evaluation" is stretching that word
12:26:14 <Hijiri> ski: I think I have heard the +/- are related to the arguments being in positive or negative position
12:26:17 <Hijiri> is that right?
12:26:22 <ski> Peaker : so, Mercury allows you to specify user-defined insts (instantiation states). `free' and `ground' are predefined ones. `+' and `-' (`in' and `out' in Mercury as opposed to Prolog) are shorthand for the instantiation state transitions `ground >> ground' and `free >> ground'
12:26:58 <nitrix> Gurkenglas: I think this is what I want: http://lpaste.net/136503
12:27:10 <Peaker> ski: ah, for mapM rewrite to mapM_ I think very simple automatic deduction needs to take place
12:27:21 <ski> Peaker : but you can define a (parameterized) inst `list(I)', and use e.g. `free >> list(free)' to specify the mode of an argument that will be filled in with a list skeleton, but arguments will still be unknown
12:27:23 <Peaker> ski: (none of that out there stuff :-) )
12:27:35 <Gurkenglas> nitrix, your initial question seems to be of the form "#haskell, give me an inhabitant of this type". Can you give us the shortest type signature whose inhabitant you could transform into a solution to your problem?
12:27:51 <Peaker> ski: (though it is indeed very interesting)
12:27:53 <Gurkenglas> nitrix, those lpastes are identical
12:28:03 <Gurkenglas> so are the links
12:28:08 <ski> Peaker : you can also define `non_empty_list(I)' and other such things which resemble refinement types (a version of subtyping where you restrict your sum type, instead of enlarge it)
12:28:15 <nitrix> Gurkenglas: You must refresh.
12:28:31 <Gurkenglas> yup, still identical
12:28:40 <nitrix> Impossible, you should have an if case now.
12:29:00 <Gurkenglas> Welp, you're right. I was expecting the Maybe to disappear.
12:29:10 <nitrix> And the return type is now a Nothing for the Nothing case.
12:29:34 <nitrix> To is the behavior that I want. I want the update to call create, if that works, then it calls delete on the older resource, if that too works, then it returns the new resource.
12:29:37 <ski> Peaker : anyway, for constraint logic, it's very hard to statically keep track of the exact instantiation (or rather constraint) states. e.g. keeping track of the fact that `A' is known to be an integer between `3' and `46' that must be strictly less than `B' and also distinct from `C'
12:29:44 <xyh> reading Haskell Curry's free reachable books like <<foundations-of-mathematical-logic>>, I am his fans now, but unable to download his paper from jstor. where can I read more free reachable works of Haskell Curry ?
12:29:45 <nitrix> Otherwise, the old resource is the good one, and thus, Nothing is return.
12:30:01 <ski> Peaker : so, Mercury here opted for dynamic insts, using an `any' inst (compare with `Dynamic) for such things
12:30:05 <Gurkenglas> Ah, now we can help. (case a of Just x -> f x; Nothing -> Nothing) can be replaced by a >>= f
12:30:06 <nitrix> Gurkenglas: Gosh my english. I can rephrase.
12:30:39 <ski> Peaker : internally, there's a `dead' inst that is used for variables (and parts of structures) that won't be referenced (statically) (compile-time GC)
12:31:35 <ski> Peaker : so. one could imagine using `dead' oneself in mode specifications, to specify that a predicate supports an implementation where some output is not demanded (and thus the compiler can remove the code that computes it)
12:32:37 <ski> Peaker : i should have mentioned that every separate mode of a predicate in Mercury compiles to separate low-level code (selection of modes is done statically. the language enforces that the different modes of a single predicate coheres declaratively with each other)
12:33:07 <Gurkenglas> nitrix, a first refactoring: http://lpaste.net/136503
12:33:26 <Gurkenglas> Waaait, I can edit that thing and it goes onto the same link? o.o
12:33:50 <ski> (if you really want/need to, you can define a mode of a predicate separately, with a different algorithm. but then you have to use a "promise" language construct to promise that it is declaratively equivalent to the main implementation)
12:34:04 <nitrix> Gurkenglas: Yeah it's public.
12:34:22 <nitrix> Gurkenglas: I have the new and old tab open, don't worry. Watching the changes. 
12:34:35 <ski> Peaker : btw, i should also mention that at least the basic modes of a predicate not only have the above procedural "state transition" interpretation, but also a declarative interpretation
12:36:08 <nitrix> I see where you're comming from with the >>= reduction. What I wonder is if it'll end up being chained with the providerDelete?
12:37:01 <ski> Peaker : e.g. `:- mode append(out,out,in) is multi.' declaratively means `all [AsBs] some [As,Bs] append(As,Bs,AsBs)' and `:- mode append(in,out,in) is semidet.' declaratively means `all [As,AsBs] unique [Bs] append(As,Bs,AsBs)' (shorthand for `all [As,AsBs,Bs0,Bs1] ( append(As,Bs0,AsBs),append(As,Bs1,AsBs) => Bs0 = Bs1 )')
12:37:26 <Gurkenglas> nitrix, rephrase?
12:37:40 <ski> Hijiri : yes, there is some relation there
12:38:30 <nitrix> Gurkenglas: We did it for providerCreate, I wonder if providerDelete will look the same. If so, if those will end up chained one after another. That reminds me of monads where any computation that fails, return Nothing.
12:38:47 <Gurkenglas> Huh, I think my first refactoring is wrong. I'll get out a Maybe (IO (Maybe BlockId)).
12:39:10 <nitrix> Gurkenglas: Maybe that's a use case for the Maybe monad? Or even, some monad transformers? *shivers*
12:39:27 <Gurkenglas> The >>= was from the Maybe monad.
12:39:32 <ski> Peaker : CTM talks about the three conceptually separate phases of using an (immutable variable). (a) bringing it into scope by binding it; (b) instantiating it by associating it with a computation with a single definite result; (c) actually computing the result
12:39:35 <Gurkenglas> And yes, I think MaybeT is called for
12:39:36 <ski> @where CTM
12:39:36 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
12:40:24 <nitrix> Gurkenglas: I understand their purpose, but I never used them. It's hard without examples :(
12:40:56 <ski> Peaker : most languages force (a-c) to happen all at once. non-strict languages decouples (a-b) from (c). logic programming decouples (a) from (b-c). some experimental languages try to all decoupling all of them (Oz,Alice ML)
12:41:01 <nitrix> ski: Can I borrow your immense knowledge?e
12:41:10 <Gurkenglas> Same for me :P let me try cobblin something together
12:42:11 <nitrix> Gurkenglas: If you want a testable use case, just declare Block and BlockId as Strings and drop the extra imports.
12:42:12 <ski> Peaker : ok, this turned into a longer rant than i intended. sorry
12:42:29 <nitrix> Block is actually a ByteString but meh.
12:42:36 <nitrix> Irrelevant.
12:44:03 <nitrix> ski: How would you simplify this? The Maybe monad comes to mind, or a transformer? MaybeT? http://lpaste.net/136510
12:44:45 <nitrix> ski: I haven't used both, so anything from you would help me a long way.
12:45:08 <nitrix> ski: providerUpdate is the nasty function I want to reduce.
12:45:39 <cowboysauce> I have a small question about ghc. How do I add a package database file using ghc-pkg? I've tried ghc-pkg --package-db=path, but I get the error message "ghc-pkg: missing command".
12:46:02 <Gurkenglas> nitrix, revert to your first paste version, the current one is wrong
12:46:26 <nitrix> Gurkenglas: Done.
12:46:39 <nitrix> Gurkenglas: I gave ski and you two different links, just in case :]
12:47:45 <safinaskar> chpatrick: ski: (other people i talked): extension-effect seems to be exactly what i want
12:48:09 <ski> safinaskar : great. perhaps you could later talk about your experience with ?
12:48:22 <ski> s/with/with it/
12:49:14 <mrkkrp> What a hell is this: https://github.com/haskell/haskell-mode/issues/762 and https://github.com/haskell/haskell-mode/issues/763 . I see such a jerk on GitHub for the first time.
12:49:17 <Noinia> hmm question: Is there a name for the thing that I obtain when I combine a Prism with a lens? i.e. something like: _Right._1 
12:49:18 <safinaskar> chpatrick: ski: in fact, i have not only state monads, but also IO monad and Parsec monad. and i want to compose them some way. for example, i want to call Parsec-only-function from Parsec-IO-function with minimum code
12:49:31 <safinaskar> ski: of course :)
12:49:43 <catgocat> What does `non-pathological function` means?
12:50:07 <Noinia> it produces a unweildy signature, that is no longer as general as a Prism
12:50:09 <ski> nitrix : you can use `mapM' or `forM' in `providerUpdate'
12:50:14 <kadoban> catgocat: What kind of context?  At a guess, something not like:  f x = error "wheeee"
12:50:38 <catgocat> kadoban: "There is a deep mathematical sense in which any non-pathological function of type (a,b) -> a must do exactly what fst does. "
12:50:53 <ski> safinaskar : which "Parsec-only-function" ?
12:51:06 <catgocat> I'm still confused
12:51:28 <ski> catgocat : "pathological" here means one that uses `error' or `undefined' or similar
12:51:35 <kadoban> catgocat: Then yeah, basically it means a function that doesn't use 'error', 'undefined' or recurse infinitely is "non-pathological" in that sentence.
12:51:37 <ski> catgocat : .. or which loops infinitely
12:52:04 <catgocat> ok
12:52:17 <ski> (also `seq' / bang-patterns complicate stuff, so we often ignore those for such purposes as this)
12:52:36 <jTT_> in the yesodweb xml book there is a mention of Nodes, Elements and Documents implementing instances of  ToHtml. Has this perhaps changed? It seems further that Text.Blaze.Html uses ToMarkup and not ToHtml. I am a bit at a loss, all i wanted to so is to take a cursor, and from a certain level in a DOM traversal simply render the nodes and children thereof (i.e. get the html). would be great if someone could point me in the right direction 
12:53:59 <ski> catgocat : if you have `mystery :: (a,b) -> (a,Bool)', then polmorphism in Haskell ensures that `mystery' can't inspect the input values of type `a' and `b' (since the types `a' and `b' are completely unknown to `mystery', the caller gets to pick what actual types, like e.g. `Int' and `String' to use for them)
12:54:26 <arkeet> @free mystery :: (a,b) -> (a,Bool)
12:54:26 <lambdabot> $map_Pair f $id . mystery = mystery . $map_Pair f g
12:54:49 <exio4> is there any kind of standard function that'd add some byte to a bytestring until it has certain length? I basically want to complete a "packet" (they are 31 bytes) with extra data
12:55:11 <ski> catgocat : this is very useful, because it means that you can be use that `mystery' doesn't mess with those inputs of type `a' and `b', it can't decide to do different things depending on whether you call `mystery (4,"yes")' or `mystery (-7,"yes")'
12:55:12 <exio4> f 10 0 "abc" = "abc\0\0\0\0\0\0\0" 
12:55:28 <Hijiri> @free applecobbler :: a -> ((a -> Void) -> Void)
12:55:29 <lambdabot> applecobbler x (g . f) = applecobbler (f x) g
12:55:45 <Peaker> ski: was interesting :) are the declarations about modes just for checking against inferred info? when you say "is semidet", isn't that already inferrable?
12:55:56 <arkeet> I guess $map_Pair is bimap.
12:55:56 <Denommus> anyone here using nix on Arch Linux?
12:56:17 <liste> Denommus me
12:56:29 <Denommus> liste: how did you install it? From AUR?
12:56:57 <ski> catgocat : it is most useful for functions which accept *callback* arguments (iow higher-order functions). if we know `something :: (a -> Bool) -> [a] -> [a]', then we know that `something can't mess with the `a' values in the input list. it can only rearrange them in the output list, possibly dropping some and duplicating some, possibly depending on whether the argument predicate of type `a -> Bool' says `True' or `False' for them
12:57:23 <liste> Denommus no, from nixos.org/nix/
12:57:29 <exio4> I basically need padding bytes, hm
12:57:32 <liste> the aur nix is different
12:57:41 <liste> it's multi-user
12:57:45 <ski> catgocat : .. so, basically, we're ensured, just by looking at the interface (the type) of `something' that it will only pass list elements unadultered to our callback predicate
12:58:07 <arkeet> @free something :: (a -> Bool) -> [a] -> [a]
12:58:07 <lambdabot> $map f . something (g . f) = something g . $map f
12:58:19 <nitrix> Gurkenglas: This is so much harder than it should be.
12:58:25 <ski> catgocat : in several other languages, you can inspect the type of any value at run-time, and then you don't get the above very useful property (which is called "parametricity", btw)
12:58:31 <catgocat> ski: but how does that relate to pathological?
12:58:55 <nitrix> Gurkenglas: I have nested >>= for the IO and Maybe monads now, with lambdas...
12:58:58 <catgocat> I think I am missing the meaning of that word in the sense of programming and mathematics
12:59:02 <catgocat> I'm foregin
12:59:05 <catgocat> foreign*
12:59:09 <kadoban> catgocat: It does in the sense that it only applies to non-pathological functions. You can intentionally break the intuition, if you're trying to, but a well-behaved function is restricted in its behavior.
12:59:11 <Gurkenglas> nitrix, here: http://lpaste.net/136517
12:59:24 <ski> catgocat : well, if we have `f :: (a,b) -> a', then assuming `f' isn't pathological, it must terminate, and return some non-error/exception. of type `a' !
12:59:31 <Denommus> liste: hm. I wish I could register it on the system's package manager. Oh, well
12:59:51 <Gurkenglas> I haven't tested it, but feeding http://lpaste.net/136513 to lamdabot (via @letlpaste 136513) compiled, so it should work. Insert those imports, of course.
13:00:03 <kadoban> catgocat: For now you could just assume it means: "if an evil bastard didn't write this function, it's non-pathological"
13:00:04 <ski> catgocat : but the only value of type `a' it could possibly return is the one in the first component of the argument pair. therefore, unless `f' is pathological, `f' must effectively be `fst'
13:00:22 <liste> Denommus single-user nix uses your home folder
13:00:47 <liste> the only system-wide part is /nix/
13:00:51 <catgocat> ski: but doesn't a mean "the same type" ? I can return something that is the same type as a, for example if a is "hello", I can return "ello"
13:00:59 <catgocat> s/a/that
13:01:15 <arkeet> catgocat: the point is that you can't, because you don't know whether a is String or something else.
13:01:17 <catgocat> and it's not fst
13:01:29 <catgocat> oh I see, so the compiler will complain
13:01:30 <ski> Peaker : the `is semidet' (the determinism annotation on the mode) is checked, along with the argument modes (before and after inst). there's also some support for inferring completely, but that is mostly used for non-exported predicates/functions, afaiui
13:01:37 <catgocat> because it wouldn't work for other types
13:01:37 <arkeet> the implementation of the function must work for every type 
13:01:48 <catgocat> got it got it
13:01:55 <catgocat> makes so much sense
13:01:59 <arkeet> and you can't inspect what that type actually is.
13:02:13 <catgocat> unless it throws an error, which in that case would be pathological
13:02:26 <ski> Peaker : in the implementation, each explicit mode will be compiled to a separate low-level procedure (though they can be mutually recursive)
13:02:41 <arkeet> @free f :: (a,b) -> a
13:02:41 <lambdabot> g . f = f . $map_Pair g h
13:02:53 <catgocat> I think I got it
13:02:55 <catgocat> thanks
13:03:22 <nitrix> Gurkenglas: trying
13:03:23 <ski> Peaker : given any mode, you get implied modes by supplying more info in arguments before the call (but then the call can possibly fail, if the output it intended to give didn't match the one you provided)
13:04:19 <Peaker> ski: can this kind of stuff be an EDSL inside Haskell? :)
13:04:56 <ski> Peaker : so `:- mode append(in,in,in) is semidet.' is implied from `:- mode append(in,in,out) is det.', e.g. (compiling a call `append(As,Bs,AsBs)' in the first implied mode into a call `append(As,Bs,AsBsTmp),AsBsTmp = AsBs', which will check equality (may fail) after calling the other mode)
13:05:40 <Gurkenglas> Why does http://lpaste.net/136513 work, but not http://lpaste.net/136520 ? Can you not import constructors?
13:06:20 <ski> Peaker : but in the implementation, if you explicitly specify a mode that would be implied otherwise, then the effect is that that is a hint that you'd like that mode to be compiled as a separate procedure (it might be more efficient that way than using the default implied implementation sketched just above. especially if the predicate is recursive)
13:06:41 <Gurkenglas> (nitrix, http://lpaste.net/136517 has the imports. What are you trying?)
13:06:53 <catgocat> Because `last` can throw an exception, is it pathological?
13:07:08 <nitrix> Gurkenglas: Just understanding it by hoogling the types of everything :]
13:07:33 <ski> Peaker : also, if you use insts to simulate refinement types, you can then use extra specified modes to statically check more properties (e.g. that if you append a list with a non-empty list, the answer is always non-empty. or that if you select an element from a non-empty list, then that can't fail (there's at least one solution))
13:07:35 <Gurkenglas> catgocat, I'd say yes, as is head. See https://hackage.haskell.org/package/safe
13:07:40 <maerwald> :t lastMay
13:07:41 <lambdabot> Not in scope: ‘lastMay’
13:08:09 <Gurkenglas> @let import Safe
13:08:10 <lambdabot>  Defined.
13:08:15 <Gurkenglas> :t lastMay
13:08:16 <lambdabot> [a] -> Maybe a
13:08:31 <ski> catgocat : given `f :: (a,b) -> a', `f' doesn't get a say on what types `a' and `b' will be. only the caller of `f' will determine that. to `f' they act as unknown placeholders, that can't be inspected
13:08:34 <liste> catgogat also, for future googling, the term "partial" is used for such functions
13:08:44 <liste> as opposed to "total"
13:09:09 <jTT_> could someone translate this for me? my understanding is that Cursor does not know what it’s instance for ToMarkup should be . Yet it seems the xml-conduit is suggesting such an instance should exist
13:09:09 <jTT_>  No instance for (blaze-markup-0.7.0.2:Text.Blaze.ToMarkup Cursor)
13:09:15 <catgocat> ski: yes I understand
13:09:29 <ski> Peaker : you can relatively easily make an EDSL with logic variables which can be uninstantiated and instantiated (done that)
13:09:33 <nitrix> Gurkenglas: e.g. I'm curious what does `MaybeT IO BlockId` yield with '<-'. `Maybe BlockId` or `IO Maybe BlockId` ?
13:09:45 <maerwald> catgocat: if you know that "last" cannot fail in the current context, then it is fine to use it. But then you expose yourself to refactoring-bugs where you forgot something
13:09:48 <ski> Peaker : statically specifying insts&modes, and determinisms, i think would be harder
13:09:58 <nitrix> Gurkenglas: It doesn't run the computation unless you do runMaybeT, right?
13:10:05 <Gurkenglas> nitrix, in the do-block, the variable left to <- gets type BlockId
13:10:20 <nitrix> What if it can't?
13:10:22 <nitrix> Oh, it will.
13:10:25 <ski> catgocat : btw, when you need it, there are ways around "can't inspect which type a type variable actually is in this call". but then you must change your interface
13:10:31 <nitrix> Since we're in the MaybeT IO !
13:10:32 <Peaker> ski: "statically" has 2 possible meanings for an EDSL like this -- in the host(Haskell) type system or when you compile the EDSL (at Haskell runtime)
13:10:51 <Peaker> (though the latter is obviously doable with a deep embedding, but with fewer of the benefits of embedding)
13:10:57 <nitrix> Gurkenglas: Wow, that's powerful.
13:10:59 <Gurkenglas> If it gets Nothing, it immediately exits the do block, returning "return Nothing".
13:11:19 <nitrix> Mhm. That's too much power to handle D:
13:11:26 * nitrix explodes in confetti
13:11:45 <nitrix> Monad transformers are actually great.
13:11:48 <Gurkenglas> runMaybeT simply unpacks the, one might say composed IO and Maybe monads back into their constituent parts, so that another do block would have its <- look only into the IO
13:12:05 <Gurkenglas> (and the variable left to the <- would get the type Maybe BlockId)
13:12:11 <nitrix> Right. Okay, I'm following.
13:12:12 <ski> catgocat : if you say `f :: Typeable b => (a,b) -> a', then `f' determine whether `b' is `Int' or `[String]' or whatever (and then, based on that, it can inspect the input of type `b'). but it still can't check what `a' is, since there's no `Typeable a' constraint in the type signature. so you can still determine the "parametricity" behaviour by looking at the interface only
13:12:19 <nitrix> :t runMaybeT
13:12:20 <lambdabot> MaybeT m a -> m (Maybe a)
13:12:37 <nitrix> So, IO (Maybe a), which becomes Maybe a with the bind operation.
13:12:53 * maerwald looks for nitrix in all that confetti
13:13:03 <ski> catgocat : another example `sort :: Ord a => [a] -> [a]' can use the fact that `a' is known to be an orderable type (elements can be compared for ordering) .. but it can't use any other knowledge about `a'
13:13:08 * nitrix shakes. Wasn't me.
13:13:36 <lpaste> catgocat pasted “exercise” at http://lpaste.net/136522
13:13:45 <catgocat> Please check
13:13:59 <Gurkenglas> @undefine
13:13:59 <lambdabot> Undefined.
13:14:02 <ski> catgocat : the `Ord a =>' and `Typeable b =>' parts of these type signatures are known as "constraints". they are constraints on how callers can use the operations (can't use `sort' on a list of elements of a type with no defined ordering, duh !)
13:14:03 <Gurkenglas> :t runMaybeT
13:14:04 <lambdabot> Not in scope: ‘runMaybeT’
13:14:13 <Gurkenglas> Note that it was only in scope because I had done:
13:14:22 <catgocat> ski: good to know
13:14:23 <Gurkenglas> @letlpaste 136513
13:14:25 <lambdabot>  Defined.
13:14:28 <kadoban> catgocat: Did you try running foo on some example inputs? What happened?
13:14:36 <ski> catgocat : on the side of the callee (the operation itself), the "constraint" acts as extra knowledge about the type variables, that it can use
13:14:46 <catgocat> kadoban: returns the first element of the list, or no?
13:14:54 <joncol_> Are there any conventions on where to put helper functions? Above or below the functions that use them? :)
13:15:06 <nitrix> Gurkenglas: Anyone can define anything? That makes for fun pranks, just saying.
13:15:22 <kadoban> catgocat: What about   'foo []' ?
13:15:23 <ski> Peaker : hm, yes
13:15:24 <catgocat> ski: and it is denoted with a fat arrow
13:15:38 <geekosaur> it does occasionally lead to surprises
13:15:43 <catgocat> kadoban: it was an example, in that case it obviously needs a pattern-matching for []
13:15:45 <Gurkenglas> Correct. There's some further publically accessible magic that makes for even better pranks, just saying :D
13:15:45 <geekosaur> but there are limits as to what you can do
13:15:59 <ski> catgocat : aye
13:16:14 <kadoban> catgocat: Ah. Well the rest of what you say in there seems sound.
13:16:15 <geekosaur> (like, if the unqualified name is already in scope, @let will fail with an error)
13:16:19 <catgocat> ski: aren't those constraints, type constructors?
13:16:42 <ski> catgocat : `Int' is a type constructor, `Maybe' is another type constructor, `IO' a third
13:16:48 <catgocat> kadoban: I'm doing the exercises from real world haskell, the more I read the more I know
13:17:20 <catgocat> ski: Int is a type constructor? I thought Integral was
13:17:42 <geekosaur> Integral is not a type constructor, it is a typeclass
13:17:53 <ski> catgocat : there's also the syntax `[Int]' (e.g.) for the type of lists of ints. that syntax is sugar for `[] Int'. you can think of this as reading `List Int' : "list-of ints"
13:17:57 <geekosaur> Int is a nummary type constructor, conventionally known as a type
13:18:01 <geekosaur> *nullary
13:18:10 <catgocat> ski: so I can write [Int] -> [] Int ?
13:18:25 <Peaker> Is it customary to name "Int" a type-constructor?
13:18:28 <geekosaur> Maybe is a unary type constructor, which is to say it takes a type as a parameter and the result is a type
13:18:32 <Peaker> (rather than just a type?)
13:18:43 <geekosaur> Peaker, it varies.
13:18:44 <ski> > let f :: [Int] -> [] Int; f xs = [0] ++ reverse xs ++ [1]  in  f [2,3,4,5]
13:18:45 <lambdabot>  [0,5,4,3,2,1]
13:18:49 <ski> catgocat : yes
13:18:51 <kadoban> Peaker: It's both I believe, but it depends.
13:18:55 <catgocat> ski: wow cool
13:18:56 <geekosaur> where it gets confusing is: data Foo a = Foo a
13:19:07 <geekosaur> "Foo" is both type constructor and data constructor
13:19:08 <Peaker> geekosaur: "unary" doesn't necessarily mean *->*, but ?->*
13:19:26 <ski> catgocat : if you have a value of type `[] Int', then you have zero or more `Int's (in a given order). if you have a value of type `Maybe Int', they you have zero or one `Int'
13:19:36 <geekosaur> (or: data Foo = Foo Int; now the type constructor is nullary (a "type") but the data constructor is unary)
13:19:39 <ski> catgocat : `Maybe' is used for operations which might fail
13:19:54 <Peaker> and for values that may be missing
13:19:56 <rfw> hi, i have a question about ApplicativeDo – does it mean that expressions inside the do body can run out of order?
13:20:19 <Peaker> rfw: if the Applicative in question does that -- but that has less to do with ApplicativeDo
13:20:35 <rfw> like for instance, do { x <- getLine; y <- getLine; print $ x ++ y } --> (\x y -> print $ x ++ y) <$> getLine <*> getLine
13:20:36 <geekosaur> Peaker: takes a type, produces a type, so * -> *
13:20:44 <rfw> Peaker: does the compiler make guarantees about which getLine is executed first?
13:20:48 <geekosaur> with extensions, there are other things possible e.g. constraints
13:20:52 <Peaker> geekosaur: wouldn't: (* -> *) -> *   be considered unary?
13:20:55 <rfw> er, does the language rather
13:21:00 <ski> catgocat : i prefer making definitions like `data Foo = MkFoo [Int]' rather than naming both the type constructor and the data constructor the same
13:21:04 <geekosaur> Peaker, yes
13:21:05 <Peaker> rfw: Applicative has a well-defined order for the effects, yes
13:21:13 <exio4> Peaker: does it? 
13:21:19 <geekosaur> and the parameter would be something like e.g. `Maybe`
13:21:22 <exio4> IO _does_ has, but Applicative?
13:21:26 <rfw> Peaker: i don't understand how
13:21:34 * ski can't recall if catgocat has seen `data' declarations yet .. they define new data types
13:21:36 <Peaker> exio4: well-defined order in the same way that (-) has a well-defined order between its arguments
13:21:42 <catgocat> I have, but I am not very used to
13:21:53 <catgocat> data YesNo = False | True deriving (Show, Eq, Ord)
13:21:59 <rfw> Peaker: is it that applicative has an order, or function application in general?
13:22:02 <catgocat> replace False and True with Yes and No
13:22:07 <catgocat> sorry hehe
13:22:22 <geekosaur> that is, a thing that takes a type and produces a type. you do this whenever you use a monad transformer; one of the parameters is the next monad down the stack, hence kind (* -> *)
13:22:29 <rfw> oh, i see what you mean now
13:22:30 <Peaker> rfw: when you use Applicative to compose values, the composition is not necessarily commutative, that is all I mean by that
13:22:35 <Hijiri> Is there a function that will render a template haskell Exp as a haskell expression (in a String)
13:22:41 <ski> catgocat : `Maybe' is defined as `data Maybe a = Nothing | Just a'. this means that if you get an `Maybe Int', then it is either of the shape `Nothing', or it is of the shape `Just n', where `n' is an `Int'
13:22:45 <rfw> Peaker: yup, got it :) thanks
13:22:50 <lpaste> catgocat pasted “exercise02” at http://lpaste.net/136523
13:22:54 <catgocat> check please
13:23:08 <Zemyla> Oh, you know edwardk's article about replacing failure with a heap of successes, and his use of states with a right monoidal action?
13:23:13 <ski> catgocat : here `Maybe' is a type constructor, and `Nothing' and `Just' are the data constructors that belong to it
13:23:18 <catgocat> ski: actually, wasn't it Just a | Nothing ? because Just 1 > Nothing
13:23:39 <catgocat> or I'm confusing things
13:23:52 <ski> catgocat : the order doesn't matter (except if you derive `Enum' or `Ord')
13:24:06 <ski> (and `Ix' i suppose ?)
13:24:09 <catgocat> maybe is derived from ord
13:24:29 <ski> > Nothing < Just False 
13:24:31 <lambdabot>  True
13:25:00 <ski> catgocat : which means that it's `data Maybe a = Nothing | Just a deriving Ord'
13:25:02 <nitrix> Maybe is derived from Eq and Ord, if I recall.
13:25:10 <ski> (well, a bunch of more things derived as well)
13:25:24 <catgocat> ski: what about Just a | Nothing ? because I read somewhere that the more left it is, the greater it evaluates
13:25:24 <nitrix> It should be only those two actually.
13:25:43 * ski would express it as the `Maybe' declaration deriving `Eq' and `Ord' instances
13:26:00 <ski> (the instances for `Maybe' are derived, not `Maybe' itself)
13:26:20 <ski> catgocat : the other way around, if i'm not terribly mistaken
13:26:23 <ski> let's try
13:26:35 <ski> @let data AB = A | B deriving (Eq,Ord)
13:26:36 <lambdabot>  Defined.
13:26:40 <ski> > A < B
13:26:41 <lambdabot>  True
13:26:55 <catgocat> oh I see, I was confusing things
13:26:56 <Zemyla> cI figured out another advantage of using right monoidal actions with applicative.
13:27:09 <ski> so earlier alternatives after the `=', separated by `|', counts as lesser in the ordering
13:27:16 <catgocat> yes yes, got it
13:27:24 <alexa_> how do I write a function that takes no arguments( forgoing the fact that I shouldn't) aka Unit -> List
13:27:27 <catgocat> also have you seen my lastest paste?
13:27:34 <alexa_> I tried () -> [Int] but no deal
13:27:43 <ski> alexa_ : every function Haskell takes exactly one argument
13:27:57 <ski> alexa_ : if you want to, you could have an argument that is a nullary tuple :
13:28:05 <ski>   foo :: () -> [Int]
13:28:09 <alexa_> aah
13:28:12 <Zemyla> You could have MState w s 
13:28:13 <ski>   foo  () = ....
13:28:19 <ski> or you could just say
13:28:23 <ski>   foo :: [Int]
13:28:23 <nitrix> Can't you just write :: Int
13:28:25 <ski>   foo = ...
13:28:29 <nitrix> Can't you just write :: [Int]
13:28:39 <nitrix> Right.
13:28:49 <catgocat> ski: http://lpaste.net/136523
13:28:56 <ski> alexa_ : but the definition (and any uses of it, like calls) has to agree with the type signature
13:29:15 <Zemyla> MState s w a = Static w (s -> a) | Dynamic (s -> (a, w)).
13:29:15 <nitrix> alexa_: someoneSpecial :: String
13:29:20 <nitrix> alexa_: someoneSpecial = "alexa_"
13:30:30 <ski> catgocat : perhaps you should define it recursively yourself, without using helper functions, to make sure you grok the recursion that would be needed. unless you're satisfied that you already understand that well
13:30:50 <catgocat> I'll do it recursively
13:30:51 <alexa_> thanks guys
13:30:57 <ski> catgocat : you could add explicit cases for when the function is partial, yes
13:31:03 <ski> alexa_ : yw
13:31:19 <Zemyla> And then two Statics woyld form another Static.
13:32:08 <lpaste> catgocat annotated “exercise02” with “exercise02 (annotation)” at http://lpaste.net/136523#a136526
13:32:12 <catgocat> ^^^
13:32:31 <catgocat> what about that
13:33:05 <jfeltz> just noticed that ghc's exec -> import -> obj -> source dependency tracking is much better than any other language compiler that I've used, that really should get more love/press
13:33:43 <ski> exio4 : `Applicative' (and `Monad') has a well-defined (conceptual) ordering. particular instances might behave the same for different orderings
13:33:53 <catgocat> x:y:[] could be written [x, y] btw
13:34:11 <exio4> ski: hm, ok
13:34:27 <ski> exio4 : this is really the same as the general idea of monoids having a well-defined ordering, while particular monoids might not care about the ordering (to lesser or greater extent)
13:35:19 <ski> exio4 : if you have `forall i. Applicative i => i Foo', polymorphic in the idiom, then you can always instantiate `i' to something where the ordering is observable
13:35:20 <exio4> ski: ah, I see
13:35:26 <liste> catgocat looks ok
13:36:09 <ski> exio4 : if you have `Reader R Foo', then `Reader R' is also an idiom, one that happens to not care about the ordering inherent in the idiom operations
13:36:50 <exio4> ski: makes sense, thanks 
13:37:11 <ski> catgocat : fyi, `(x:y:[])' could be replaced by `[x,y]'. matter of personal taste/style
13:38:12 <ski> exio4 : hence i think that it's correct to say e.g. "monads are inherently about sequencing/ordering (with some details that makes them differ from idioms)"
13:38:32 <t7> is there a haste compiler channel?
13:38:47 <Welkin> t7: #haste-lang or something
13:39:37 <ski> exio4 : however, it would be a mistake to think that "sequencing/ordering" here means evaluation ordering. it is a *conceptual* ordering. in the case of the list monad, it correponds to "nesting loops", which one perhaps isn't used to think of as "sequencing", but which abstractly is a kind of sequencing
13:40:05 <ski> > do x <- [0,1,2,3]; y <- [0 .. x]; return (x,y)
13:40:06 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
13:40:39 <exio4> ski: yeah, "conceptual" ordering/sequencing totally makes sense 
13:41:13 <ski> in the monad case, it's also related to the dataflow dependencies of e.g. `x' and `y' in the example above
13:41:41 <ski> (unless you use `RecursiveDo') those dependencies can only go in one direction
13:43:38 <ski> `1 * 2 * 3' is conceptually ordered in a different way than `3 * 2 * 1', still if `(*)' happens to be commutative (and associative), the result value will turn out the same, making the ordering a "difference that makes no difference"
13:45:59 <safinaskar> ski: "which "Parsec-only-function"" - i mean some function which returns some parsec parser monadic value
13:46:06 <ski> (btw, i'm expanding on this point here because there has been a lot of confusion about this in the past, in the channel. and i think i've gradually understood the issue better and better, by trying to justify my vague intuition. hopefully others find it useful as well)
13:46:16 <ski> safinaskar : concrete example ?
13:48:07 <safinaskar> ski: f = char '_'
13:49:26 <ski> @type Text.Parsec.char
13:49:27 <lambdabot> Text.Parsec.Prim.Stream s m Char => Char -> Text.Parsec.Prim.ParsecT s u m Char
13:49:58 <ski> safinaskar : first a nitpick. `f' is an action, not a function
13:51:15 <ski> safinaskar : `f' has type `ParsecT s u m Char' here. iirc `m' could be `IO', and so you should be able to invoke this from "Parsec-IO-actions"
13:51:54 <ski> safinaskar : is there a reason why you can't do something like that ?
13:52:10 <t7> is there a fromReal like fromInteger?
13:52:32 <mauke> t7: what would its type be?
13:53:20 <t7> fromReal :: (FromRealable a) ... => 
13:53:23 <ski> @type realToFrac  -- *might* be what you're looking for, t7
13:53:24 <lambdabot> (Fractional b, Real a) => a -> b
13:53:30 <t7> i mean Double -> a
13:53:31 <ski> otherwise, perhaps one of
13:53:36 <GLM> Any ideas on why this code creates this error?
13:53:37 <GLM> generateKeyPair (mkStdGen 52)
13:53:45 <t7> like fromInteger has magic 
13:53:45 <GLM> <interactive>:15:1:
13:53:45 <GLM>     No instance for (crypto-api-0.13.2:Crypto.Random.CryptoRandomGen
13:53:45 <GLM>                        StdGen)
13:53:45 <GLM>       arising from a use of ‘generateKeyPair’
13:53:45 <GLM>     In the expression: generateKeyPair (mkStdGen 52)
13:53:45 <GLM>     In an equation for ‘it’: it = generateKeyPair (mkStdGen 52)
13:53:52 <ski> @type [floor,ceiling,truncate,round]
13:53:53 <lambdabot> (Integral b, RealFrac a) => [a -> b]
13:54:05 <t7> GLM: stdgen aint a cryptogen
13:54:15 <ski> @type fromRational  -- there's also this
13:54:16 <lambdabot> Fractional a => Rational -> a
13:54:31 <ski> t7 : magic in what sense ?
13:54:40 <t7> 0 :: V2   i can d othis
13:54:49 <t7> i wanna do   3.14 :: V2
13:55:10 <mauke> :t 3.14
13:55:11 <lambdabot> Fractional a => a
13:55:14 <t7> ab fractional?
13:55:17 <t7> ah*
13:55:18 <mauke> so implement Fractional
13:56:19 <ski> t7 : specifically, `fromRational' needs to be implemented
13:57:40 <GLM> t7:but the signature asks for a RandomGen, not a Cryptogen
13:58:03 <t7> must be CryptoRandomGen
14:01:03 <catgocat> I have just finished reading the chapter 2 of the book real world haskell, the author explains things very nicely
14:01:17 <GLM> t7:Looks like you're right. GHCI says it is cryptogen but hackage disagrees
14:01:24 <safinaskar> ski: "is there a reason why you can't do something like that" - in this concrete example, yes, i can. but i also want to combine this with some state monad. and need not usual state monad but special state monad i described earlier
14:01:37 <t7> make sure you are looking at the correct version on hackage GLM 
14:02:09 <GLM> t7:How do I do thnat?
14:02:24 <t7> there is a big list of versions as links
14:03:12 <GLM> t7:Thanks
14:04:08 <GLM> How would I get to that list from this link?
14:04:09 <GLM> https://hackage.haskell.org/package/RSA-1.0.6.2/docs/Codec-Crypto-RSA.html
14:05:51 <maerwald> how can I recover my programming skills after so much time with haskell? I am unable to write the simplest things in imperative languages now
14:05:55 <maerwald> :/
14:06:13 <ski> safinaskar : `hoist' at <https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html> might be useful for changing the "monad under a monad transformer"
14:06:22 <hiptobecubic> maerwald, simple. Write haskell.
14:06:47 <Welkin> maerwald: I had exactly that problem
14:06:49 <maerwald> I just tried to write a tree in ruby. I just couldn't. And then I gave up.
14:07:07 <Welkin> the way I got around it was to start writing C and javascript again
14:07:13 <Welkin> lol
14:07:20 <safinaskar> maerwald: :)
14:07:26 <Welkin> I can't work in dynamic languages at all anymore
14:07:26 <ski> maerwald : perhaps try in assembler first
14:07:32 <safinaskar> maerwald: look at glibc sources :)))
14:08:21 <catgocat> maerwald: do javascript
14:08:25 <safinaskar> maerwald: or implement "map" etc etc in c++14 :)
14:08:39 <catgocat> it makes it easier to combine functional and imperative language code
14:08:50 <maerwald> I guess I'll start from scratch and pretend I have never known any imperative language...
14:08:59 <safinaskar> ski: i already said: i will look at exteff
14:09:09 <catgocat> maerwald: I'd recommend javascript
14:09:46 <Welkin> catgocat: I would not
14:09:51 <catgocat> why not?
14:09:53 * ski nods
14:09:59 <kadoban> maerwald: Just pretend it's all in IO, and the types suck and the combinators aren't very good.
14:10:03 <Welkin> it is better to use C
14:11:05 <catgocat> I said javascript because it would be easier to slowly recover imperative language habits and practices
14:11:25 <catgocat> since it is a mix of functional and imperative
14:11:30 <Welkin> I write javascript like it is C
14:11:42 <Welkin> it is not a "mix of functional and imperative"
14:11:57 <Welkin> the way in which javascript is "functional" is nothing like the way that haskell is "functional"
14:12:02 <Welkin> the terms are ill-defined
14:12:33 <Welkin> I don't see any resemblance
14:12:35 <catgocat> that's the point, it helps with the transition
14:12:50 <catgocat> it's functional, but not completely functional 
14:13:06 <quchen> That helps developing a strange mix between the two.
14:13:16 <catgocat> or helps slowly with the transition
14:13:24 <quchen> You don't learn French by sometimes using a French word.
14:13:42 <catgocat> you don't learn French, by not speaking English while you are learning
14:15:32 <kadoban> catgocat: To some extent you can, and it's a quick way to learn.
14:21:51 <mazur> i have a question about lambda calculus notation: \x:t . x:t -> t
14:22:02 <mazur> is supposed to be the identity function
14:22:38 <mazur> is the precedence here (\x:t.x):t -> t ?
14:23:09 <quchen> x:t on the right hand side of the "." is a bit strange.
14:23:21 <mauke> mazur: I hope so
14:23:28 <mauke> it doesn't make much sense otherwise
14:23:33 <quchen> Oh, the spacing.
14:23:47 <mazur> i thought so (i added the spaces)
14:23:48 <quchen> I thought that had something to do with parenthisation.
14:24:06 <quchen> (\(x:t).x) : t -> t
14:24:38 <mazur> but then i have trouble with this one for the K-combinator: \x:s.\y:t .x:s -> t -> s
14:25:24 <quchen> (\x:s y:t . x) : s -> t -> s
14:25:25 <mazur> looks like (\(x:s).\(y:t).x) : s -> t -> s
14:25:36 <quchen> s x y = x -- is what you'd write in Haskell
14:25:49 <quchen> :t \s t -> s
14:25:50 <lambdabot> r1 -> r -> r1
14:26:05 <Welkin> :t const
14:26:06 <lambdabot> a -> b -> a
14:26:14 <mazur> oh wait, K is the constant function :), i was thinking it was supposed to be the S combinator
14:26:19 <mazur> ok that makes sense then
14:26:30 <quchen> :t \f g x -> f x (g x)
14:26:31 <lambdabot> (r2 -> r1 -> r) -> (r2 -> r1) -> r2 -> r
14:26:32 <quchen> That's S.
14:26:51 <tromp_> :t join
14:26:52 <lambdabot> Monad m => m (m a) -> m a
14:26:53 <chpatrick> :t (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c)
14:26:54 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
14:26:58 <quchen> join is not S.
14:27:05 <quchen> `ap` is, for Reader.
14:27:17 <quchen> join f x = f x x, in that case.
14:27:54 <chpatrick> :t pure :: a -> b -> a
14:27:55 <lambdabot> a -> b -> a
14:28:55 <quchen> mazur: To help your parsing, the syntax is roughly "\var:type . body : type-of-everything"
14:29:02 <tromp_> so SKI is ap const id, or const`ap`id
14:29:21 <chpatrick> <*> pure id
14:29:29 <quchen> There's a Hello World with only SKI combinators.
14:29:45 <quchen> https://gist.github.com/shangaslammi/3438688
14:30:03 <mazur> quchen: ok thanks a lot, i was cathing up reading what you wrote :) the first time i saw the S combinator it didn't really make immediate sense, but seeing it in haskell is helping (and learning the connection to <*>!)
14:30:09 <chpatrick> nice one
14:31:18 <chpatrick> I'm surprised you need to bracket it thoug
14:31:56 <exio4> hiptobecubic: btw, the bf interpreter, I have been working on it locally, I rewrote the code that managed the stack, using an IntMap now, I also made a special ad-hoc bytecode (and wrote (de)serializing routines for it), I also added a few optimizations, I might start working on a bytecode interpretrer using mutable vectors :P 
14:32:35 <hiptobecubic> exio4, !
14:32:36 <kristof> Is there any reason why Haskell didn't inherit SML's functor/module system?
14:32:51 <exio4> hiptobecubic: hi!
14:33:01 <hiptobecubic> exio4, what are you referring to as the stack?
14:33:30 <nitrix> Could this be made more concise? http://lpaste.net/136530
14:33:43 <nitrix> I tried <$> and >>= with no success. My brain's hurting ;-;
14:34:15 <exio4> hiptobecubic: instead of using [Word8] Word8 [Word8], it's now IntMap Word8 !Int (basically, using IntMap like it was an array) 
14:34:50 <quchen> nitrix: fmap isRight (tryIOError (removeFile ("data/" ++ blockId)))
14:34:53 <hiptobecubic> exio4, ah ok, sure. I had the same idea actually because it allows for easier optimization of ptr shifting later on
14:34:57 <exio4> hiptobecubic: oh, I also rewrote the parser, it's now using attoparsec 
14:35:16 <quchen> do x <- action; return (f x)   ===   fmap f action
14:35:37 <nitrix> quchen: I tried `isRight <$>`, but that didn't work because the type I'm returning is an IO Bool.
14:35:44 <nitrix> Or something like that...
14:35:44 <hiptobecubic> exio4, the whole point of it in the beginning was to learn how to write the parser. The evaluation was just a nice way to make sure I could parse bf programs correctly :)
14:35:47 <nitrix> Let me try again.
14:36:06 <exio4> hiptobecubic: I know, I was just bored \o/
14:36:10 <quchen> nitrix: Sounds like a precedence error. <$> binds tighter than $.
14:36:17 <nitrix> Oh!
14:36:23 * ski . o O ( "Compile-time garbage collection for the declarative language Mercury" (Ph.D. thesis) Nancy Mazur in 2004-05 at <https://www.mercurylang.org/documentation/papers.html#mazur-thesis> )
14:36:29 <quchen> nitrix: You can look up the precedence of an operator with :i in GHCi.
14:36:38 <hiptobecubic> exio4, i was planning on using it as my 'learn how compilers work' project
14:36:43 <quchen> nitrix: (Nothing displayed means infixl9)
14:36:55 <hiptobecubic> but clearly you've already gone down that rabbit hole :)
14:37:06 <exio4> heh 
14:37:27 <nitrix> quchen: Works now with <$>. Interesting, precedence issue. Noted :x
14:37:33 <nitrix> quchen: Thanks ;-;
14:37:41 <hiptobecubic> so far all of my optimization has been at the source level, not optimizing the interpreter itself, or writing any kind of compiler
14:38:12 <quchen> Don't overdo it with infix operators, often "fmap" is much more readable than "<$>". The latter lends itself more to Applicative style when you pair it with <*> a lot.
14:38:31 <hiptobecubic> collapsing neighboring incrs and decrs, introducing a 'ValSet i' primitive for replacing chunks of code with known results like [-], etc
14:39:22 <exio4> hiptobecubic: I pretty much implemented every optimization in http://calmerthanyouare.org/2015/01/07/optimizing-brainfuck.html (minus scanleft/scanright)
14:40:13 <exio4> hiptobecubic: I am now going to work on a tracker for identifying things that can get referenced by absolute positions 
14:41:40 <exio4> hiptobecubic: I implemented that bytecode-ish stuff mainly for avoiding counting the optimizations and the interpreter together
14:42:45 <hiptobecubic> Well now that i'm reading about compilers somewhat (never studied them) I can see that I was already implementing an IR and my optimizations were being done on that
14:42:51 <hiptobecubic> then I just had an interpreter for them
14:42:51 <ocramz> hi there! FFI question: how do I get out (C -> Hs) a string represented as a Ptr Char ?
14:43:12 * hackagebot diagrams-pgf 0.1.0.2 - PGF backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-pgf-0.1.0.2 (cchalmers)
14:43:16 <ocramz> it's like the inverse of withCString
14:43:28 <hiptobecubic> I was planning on eventually outputting C or llvm IR or something
14:43:38 <hiptobecubic> instead of just evalutating it in haskell
14:43:38 <arkeet> peekCString?
14:43:41 <arkeet> https://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-C-String.html
14:43:48 <hiptobecubic> I guess outputting haskell itself would also be interesting
14:43:58 <ocramz> arkeet: thanks :)
14:44:05 <arkeet> ...or just use withCString
14:44:08 <arkeet> wait never mind.
14:44:57 <exio4> hiptobecubic: heh, I haven't played with the llvm IR, good luck with it :P
14:46:00 <hiptobecubic> exio4, well that step was not going to be any time soon i'm sure
14:48:46 <exio4> hiptobecubic: still good luck, if you thought of any kind of magic optimization that wasn't in that page, and seems 'easy' to implement, tell me! :P 
14:48:59 <hiptobecubic> haven't read the page yet
15:00:05 <hiptobecubic> exio4, you've already done everything on the page?
15:00:12 <hiptobecubic> scanloops etc?
15:01:28 <GLM> How do I use something of type Either a b with a function tghat only takes a b?
15:02:14 <Welkin> GLM: use bin (=<<)
15:02:17 <Welkin> bind*
15:02:20 <glguy> GLM: Use case to figure out if you have an 'a' or a 'b'. If you have a 'b', pass that to your function
15:02:20 <exio4> hiptobecubic: minus scanloops, everything else 
15:02:29 <tromp_> :t either
15:02:30 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:03:24 <hiptobecubic> exio4, neat. I only had up to "clearloop"
15:03:27 <GLM> Welkin:Is this what you're thinking of?
15:03:29 <GLM> generateKeyPair =<< g 2
15:04:25 <GLM> where g is of type Either a b
15:05:12 <t7> x * f y / 2  == x * (f y) / 2  right?
15:05:24 <kadoban> GLM: That doesn't appear to make sense (specifically the   g 2   part, if g :: Either a b)
15:06:01 <GLM> kadoban:The function generateKeyPair takes two arguments. something of type b (From the Either) and an int
15:06:16 <GLM> I want to see how I can get the b from the Either into the function GenerateKeyPair
15:07:02 <glguy> 07case g 042 07of Left a 07-> do_something_in_this_case; Right b 07-> generateKeyPair b
15:07:40 <exio4> hiptobecubic: yeah, they are nice optimizations, I don't know if I am doing every optimization in `every` possible case because I don't apply them one after the other, though, :P 
15:07:46 <shachaf> whoa, colors
15:07:48 <catgocat> Is there any haskell guide for style? Things like spaces, indentation and stuff
15:07:56 <catgocat> and variable names
15:08:00 <monochrom> tibbe has a style guide
15:08:01 <kadoban> glguy: What exactly is the type? Yes you can do explicit case matching like that ^ that's going to be the most understandable right now. You can also use the Functor insntance to use fmap or something.
15:08:08 <hiptobecubic> exio4, i used 'fix' for that :)
15:08:16 <exio4> hiptobecubic: my "optimizers" are functions [Term] -> [Term]
15:08:22 <monochrom> https://github.com/tibbe/haskell-style-guide
15:08:26 <hiptobecubic> mine was as well
15:08:33 <glguy> kadoban: Someone who doesn't know how to use case on an 'Either a b' doesn't need to worry about fmap or =<< yet
15:08:39 <exio4> I was going to ask how you were working with them :P 
15:08:56 <hiptobecubic> exio4, http://vpaste.net/eSoZN
15:09:11 <kadoban> glguy: Which is why I only mentioned that it existed and didn't say "f*** that, use fmap"
15:09:30 <glguy> sounds good
15:09:58 <hiptobecubic> exio4, essentially just applies smoosh over and over until the result has stabilized
15:10:45 <hiptobecubic> `go` could probably be written more nicely, but it works alright
15:11:30 <hiptobecubic> oh a bug :(
15:11:40 <exio4> hiptobecubic: nice, my `go` functions are just recursive, I am using no combinators 
15:11:50 <hiptobecubic> [ValSet i] is only equivalent to (ValSet i) when i == 0
15:12:01 <hiptobecubic> otherwise the loop is actually _|_
15:13:13 * hackagebot directory 1.2.3.0 - Platform-agnostic library for filesystem operations  http://hackage.haskell.org/package/directory-1.2.3.0 (Rufflewind)
15:15:23 <hiptobecubic> exio4, writing the optimizer as a fold makes it hard to do some of these optimizations. Needs a way to maintain a temporary stack of terms for finding things like scanloops, etc
15:15:41 <hiptobecubic> or I could just do it in multiple stages, it's not like any of this takes very long.
15:16:13 <bollu> How common is to realize that some structure you've been using already exists in haskell and would actually make code neater? I've been using this thing for a while and it turned out to be StateT (Either e) a
15:16:20 <bollu> I really like haskell so far :)
15:16:31 <exio4> hiptobecubic: so far, I have 5 "optimizer_something" functions, and my final "optimizer" is just the composition of those
15:16:39 <kadoban> bollu: Quite common :)
15:16:42 <hiptobecubic> bollu, pretty common i'd say.
15:17:03 <hiptobecubic> exio4, sure.
15:17:19 <zcourts> Given that typeclasses allow default implination of funcs. - does Haskell have the diamond problem found in other languages with multiple inheritance e.g. C++, if not, why not?
15:17:33 <bollu> Ah, question in relation to StateT. What if I wanted something of the form s -> (Either e a, s) rather than s -> Either e (a, s) ?
15:17:44 <bollu> like, how would I monadify the first behaviour?
15:17:47 <hiptobecubic> zcourts, there can only be one typeclass instance for a given type.
15:18:45 <Boney> ;win 13
15:18:46 <kadoban> bollu: I think that's EitherT e (State s)  possibly
15:18:46 <monochrom> @unmtl StateT s (Either e) a
15:18:46 <lambdabot> s -> (Either e) (a, s)
15:19:01 <monochrom> @unmtl EitherT e (State s) a
15:19:01 <lambdabot> EitherT e (State s) a
15:19:07 <exio4> bollu: you could move the stack around, ExceptT e (StateT s m) a instead of StateT s (ExceptT e m) a 
15:19:14 <monochrom> I guess @unmtl doesn't know EitherT
15:19:20 <monochrom> @unmtl ErrorT e (State s) a
15:19:20 <lambdabot> (State s) (Either e a)
15:19:21 <hiptobecubic> zcourts, so if you have a Functor Foo, it has a single definitition of fmap. Period.
15:19:24 <bollu> I didn't know EitherT existed
15:19:27 <bollu> where does it live?
15:19:38 <monochrom> oohhh, it doesn't know State either :)
15:19:39 <hiptobecubic> bollu, you usually want ExceptT I think.
15:20:00 <bollu> hiptobecubic: what's the difference between the two?
15:20:09 <hexagoxel> @hackage either
15:20:09 <lambdabot> http://hackage.haskell.org/package/either
15:20:21 <hiptobecubic> Honestly I don't remember, despiting reading a blog post about it by snoyman the other day.
15:20:26 <hiptobecubic> despite*
15:20:32 <kadoban> Oh ExceptT looks better, yeah. It's just from a more common package, heh.
15:20:44 <kadoban> Maybe? Not sure.
15:20:59 <sccrstud92> ExceptT doesnt require the error type to implement an Error typeclass
15:21:03 <sccrstud92> i think is the difference
15:21:09 <glguy> The "either" package existed before ExceptT was added to transformers
15:21:23 <glguy> The difference in ErrorT and ExceptT is what happens in the case of "fail"
15:21:27 <exio4> ExceptT e m a is defined as m (Either e a) 
15:22:05 <bollu> question: why is the "m" in the middle? 
15:22:12 <bollu> like, in StateT as well
15:22:23 <bollu> the "m" is in between. is there a reason? is it styistic?
15:22:29 <bollu> stylistic*
15:22:29 <glguy> bollu: Because it's a monad transformer and needs to have the kind: (* -> *) -> (* -> *)
15:22:32 <glguy> after you apply the 'e'
15:23:55 <bollu> ah
15:24:03 <bollu> so that way you can compose them?
15:24:47 <glguy> One reason in particular is so you can make an instance of MonadTrans
15:24:47 <glguy> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Class.html
15:27:16 <bollu> type InterpM = StateT Store (R.ReaderT Env (E.ExceptT Err []))
15:27:24 <bollu> how do you know in which order to layer the transformers?
15:28:02 <sccrstud92> is there an extension that lets you do something like
15:28:10 <sccrstud92> case <- monadicAction
15:28:16 <sccrstud92> Nothing -> ...
15:28:19 <sccrstud92> Just x -> ...
15:28:43 <sccrstud92> similar in spirit to LambdaCase but for monadic binding?
15:29:16 <exio4> sccrstud92: monadicAction >>= \case 
15:29:49 <lisk> sccrstud92: exio4's example is pretty much 90% of my uses of lambda case
15:30:02 <sccrstud92> alright thanks
15:30:36 <catgocat> How can I do something like this: type (A,B) = (Int,Integer)
15:31:08 <monochrom> cannot. use two clauses
15:31:16 <monochrom> type A = Int; type B = Integer
15:31:20 <glguy> bollu: "ErrorT e (State s) a" is "s -> (Either a e, s)" while "StateT s (Either e) a" is "s -> Either e (a,s)"
15:31:28 <glguy> bollu: You pick the one that gives you the effect you wanted
15:31:41 <glguy> Should state persist in the face of exceptions
15:32:11 <glguy> For some types like State and Reader it doesn't matter; they commute
15:34:37 <catgocat> well that sucks
15:36:39 <hiptobecubic> exio4, https://github.com/stedolan/bf.sed/blob/master/bf.sed
15:39:20 <exio4> hiptobecubic: the last comment is amazing
15:39:48 <exio4> hiptobecubic: "this won't work if you write a brainfuck program longer than 64k, but if you do that you're even more nuts than me"
15:40:24 <exio4> hiptobecubic: btw, the tracker works!
15:40:54 <hiptobecubic> exio4, you are much faster at this than I am :)
15:41:26 <exio4> hiptobecubic: nah! 
15:41:53 <hiptobecubic> Man, this one gets hello world all the way down to a puts() call. https://bitbucket.org/lifthrasiir/esotope-bfc
15:42:59 <exio4> hiptobecubic: yeah, that's my final goal, doing so many optimizations constants can be interpreted at compile-time
15:46:31 <ocramz> in a signature f :: CInt -> Ptr CChar -> IO CInt, I would like to fish out the string with peekCString, what's a good way ?
15:47:17 <arkeet> ocramz: what is the difficulty?
15:48:40 <ocramz> arkeet: given the first CInt say `n` , peekCString :: Ptr CChar -> CString matches the input of `f n`
15:48:56 <tnks> people pronounce >>= as "bind"... what about >>?
15:49:09 <arkeet> no, peekCString :: Ptr CChar -> String
15:49:26 <arkeet> ocramz: I don't understand what you're trying to do
15:49:29 <ocramz> tnks: sequence
15:49:36 <kadoban> tnks: "don't bind" ?  (I dunno, not all of these have names … trying to speak them is kinda pointless past a certain point)
15:49:38 <arkeet> are you writing f, or using it?
15:49:46 <exio4> tnks: then? 
15:49:53 <tnks> kadoban: it just comes up in conversation.
15:50:11 <kadoban> "then" seems like a decent answer I didn't immediately think of, heh.
15:50:13 <tnks> exio4: yeah, sounds about right to me.
15:50:44 <ocramz> arkeet: maybe it's the late hour, but I feel like I'm missing something obvious: I'm using f, which returns in IO
15:50:48 <tnks> I'm /certainly/ not looking for a spoken word prounciation for every symbolic function.
15:50:57 <ocramz> but I'm really interested in that CString in the middle
15:51:00 <tnks> probably would drive myself crazy with haskell-lens
15:51:12 <kadoban> Haha
15:51:13 <arkeet> ocramz: so you must pass it a CString
15:51:25 <Wizziee> hello, I'm creating a server in haskell  for client-server program which allows client to invoke commands on server (think of it as kind of remote control). The question is: which way should I develop the network interface for this? REST API, working on plain TCP/IP, other options?
15:51:44 <kadoban> tnks: That sounds like a fun idea for an acme- package though … spoken lens operators.
15:52:58 <rowanblush> AKA acme-grawlix
15:53:14 * hackagebot orgmode 0.1.0.0 - Org Mode library for haskell  http://hackage.haskell.org/package/orgmode-0.1.0.0 (lally)
15:53:18 <monochrom> I am worried that hackage's "preferred versions" does nothing. I did "cabal install hxt". it selects 9.3.1.15. later, I found out that this version is deprecated, expressed in hackage's preferred versions ">=9.3 && <9.3.1.5 || >9.3.1.5". cabal-install does not say a thing, even with -v3
15:54:19 <monochrom> I discovered it by blind luck. so imagine how many similar cases no one noticed.
15:54:21 <kadoban> rowanblush: That sounds like a great name for it.
15:55:35 <bennofs> monochrom: prefered constraints are soft AFAIK, not hard. for hard bounds, edit the cabal file to add a impossible dep, base<0 is commonly used and add a comment explaining why this version should be disabled
15:56:22 <monochrom> bennofs: you are saying, after I notice a deprecation, I know how to add it by hand.
15:56:38 <ClaudiusMaximus> monochrom: did you make a typo in those numbers?
15:56:47 <monochrom> no typo
15:56:58 <Wizziee> hello, I'm creating a server in haskell  for client-server program which allows client to invoke commands on server (think of it as kind of remote control). The question is: which way should I develop the network interface for this? REST API, working on plain TCP/IP, other options?
15:57:19 <monochrom> I see what you mean. I made no typo. but I'm blind. 5 is not 15.
15:58:00 <monochrom> alright, no problem then. thank you and sorry.
15:58:15 <kadoban> Wizziee: I would hope there's something better than raw TCP/IP. REST, json-rpc, something else I'm not thinking of.
15:59:22 <bennofs> monochrom: I wanted to say that if package authors really want to make sure that a given version cannot be installed (because of broken upload for example), then they can use the 'edit cabal file' feature of hackage for this version to add a bound base<0 for this version. This will make the cabal solve ignore that version, since base<0 can never be satisfied
16:00:49 <Wizziee> kadoban json-rpc looks great, but I  also need to fetch the list of commands from the server, so it's not enough ;(
16:01:02 <Wizziee> propably gonna stick with rest
16:01:55 <Wizziee> oh, I was wrong, I can get the result with json-rpc
16:01:59 <kadoban> Wizziee: I'm not the most experienced in that kinda thing, but fetching the possible commands from the server sounds a bit sketchy-ish. Shouldn't the client already know?
16:02:05 <ocramz> arkeet : so, I have f :: CInt -> Ptr CChar -> IO CInt , then I write f2 n = peekCString $ \s -> f n s, but GHC is missing somewhere to return to; what's an idiomatic way to do it?
16:03:29 <Wizziee> kadoban not in my app :D I want clients to be independent of the server, the server can add or remove possible commands at any time
16:03:59 <kadoban> Wizziee: Heh okay :)
16:18:04 <Moanad> I was just trying to implement data Tree a = Tree a [Tree a] and I decided to try to make it an instance of Monad. I came up with 
16:18:26 <Moanad>     Tree a ts >>= f = let (a', ts') = unapply $ f a in 
16:18:37 <Moanad>                       Tree a' (ts' ++ map (>>= f) ts) 
16:19:21 <Moanad> then I found in Hoogle, for a similar Tree type, they have
16:19:47 <Moanad>     Tree x ts >>= f = Tree x' (ts' ++ map (>>= f) ts) 
16:20:00 <Moanad>                        where Tree x' ts' = f x   
16:20:30 <Moanad> (ignoring the fact that their constructor is called Node, not Tree)
16:22:01 <Moanad> even though my implementation and the library one seems to be identical, I don't really understand how the pattern matching, Tree x' ts', works in the library version
16:23:14 <Moanad> (PS mu unapply just splits the values that make up the tree into a tuple (a, [Tree a]) )
16:24:53 <Moanad> can anybody explain how the pattern matching works the way it is used in the library implementation?
16:27:02 <rowanblush> So your unapply function is `unapply (Tree a ts) = (a, ts)`, right?
16:27:23 <Moanad> does my question make sense? I understand how it does the same as my implementation, and I can see it is probably more elegant, bu I don't quite understand how it is matching
16:27:44 <Moanad> yep
16:28:16 <Moanad> probably because I couldn't work out another way to get _inside_ th eTree
16:30:04 <rowanblush> Oh well I guess the answer is just "that's how pattern matching works".
16:30:27 <Moanad> do you agree that the library implementation is more elegant than mine? ;) Or at least more idiomatic? 
16:30:29 <rowanblush> You can pattern match directly on values in a where or let clause.
16:31:06 <Moanad> yes, but the thing that has confused me is the actual pattern in their where clause
16:31:14 <rowanblush> In an Occam's Razor sort of fashion, yeah. Don't needlessly multiply entities.
16:31:36 <Moanad> where Tree x' ts' =
16:31:53 <rowanblush> Right, that's just something you can do.
16:32:11 <rowanblush> Does it make more sense if you write it as
16:32:13 <Moanad> they seem to be matching on actual values rather than a pattern
16:32:18 <rowanblush>   where (Tree x' ts') =
16:33:11 <Moanad> whereas in my pattern match (in my unapply) I am matching on a _pattern_
16:33:42 <rowanblush> Can you give me your definition of "pattern"?
16:33:52 <rowanblush> And "value"?
16:34:13 <rowanblush> Because I think you are making a distinction that does not in fact exist.
16:34:32 <Moanad> that's OK, but the thing that is confusing me is that the x' and ts' in the where need to be named the same as the ones in the parent body
16:34:46 <Moanad> no doubt ;)
16:35:11 <geekosaur> > let Just a = Just 5 in a
16:35:12 <lambdabot>  5
16:35:14 <Moanad> but in my pattern match, I can call the x' and ts' whatever I like
16:36:06 <rowanblush> Well so a where clause is like a let clause, but reordered.
16:36:47 <rowanblush> So where in your version you introduce new value names with `let (a', ts') = ...`, the other version introduces them with `where Tree x' ts' = ...'.
16:37:20 <Moanad> perhaps it's because the match in th ewhere is clever enough to match _through_ the opening paranthesis in the body ie Tree x' (ts' ++ ...)
16:37:48 <Moanad> right, I understand that.
16:38:26 <ski> "Tree x' (ts' ++ map (>>= f) ts)" is not involved in the matching
16:38:30 <rowanblush> I don't think that line has anything to do with it.
16:39:03 <ski>   foo x y = ..x..y..a..b
16:39:06 <ski>     where
16:39:14 <ski>     Blah a b = ..x..y..
16:39:19 <ski> is the same as
16:39:29 <ski>   foo x y = let Blah a b = ..x..y..
16:39:35 <rowanblush> Do you see that you could write your own version as `let Tree x' ts' = f x`?
16:39:39 <ski>              in ..x..y..a..n
16:40:24 <Moanad> yes, thanks, and I am quite certain, BTW, that I am chasing something bogus, but I don't get why
16:40:27 <Moanad>     Tree x ts >>= f = Tree x' (ts' ++ map (>>= f) t                        where Tree x'' ts' = f x    
16:40:46 <Moanad> does not compile
16:41:10 <monochrom> looks like nothing defined x'
16:41:28 <Moanad> maybe I am confusing it with a function call, where you can call the formal parameters whatever yo ulike
16:41:55 <rowanblush> But you are calling them whatever you like. You're giving them names in the where clause.
16:42:02 <monochrom> you can call the formal parameters whatever you like. but you have called them x, ts, and f. no x' in sight.
16:42:18 <monochrom> let me just tell you what I see.
16:42:18 <rowanblush> It could just as easily be `where Tree value trees = f x`.
16:42:36 <Moanad> this must be very frustrating for all of you that it is "obvious" for, but maybe I have not asked my question very well
16:42:36 <monochrom> Tree x ts >>= f = Tree where_in_the_world_is_carmen_sandiego (ts' ++ map (>>= f) t                        where Tree x'' ts' = f x
16:44:09 <Moanad> does that compile? (with the x'' in the where rather than x')
16:44:46 <monochrom> I am not sure what you mean. you should simply give your code afresh
16:45:47 <Moanad> I wrote 
16:45:49 <Moanad> --     Tree a ts >>= f = let (a', ts') = unapply $ f a in --                       Tree a' (ts' ++ map (>>= f) ts) 
16:46:03 <Moanad> unapply              :: Tree a -> (a, [Tree a])    unapply (Tree a ts)  =  (a, ts)                   
16:46:34 <Moanad> so I am already using pattern matching and I usually understand it ;)
16:47:05 <monochrom> you commented out "Tree a ts >>= f ="...  should I keep it commented out?
16:47:11 <Moanad> but for some reason,  in the following
16:47:12 <Moanad>     Tree x ts >>= f = Tree x' (ts' ++ map (>>= f) ts)                            where Tree x' ts' = f x           
16:47:36 <Moanad> I don't get why the where clause MUST have x' and ts'
16:47:50 <rowanblush> The where clause is where you are defining x' and ts'.
16:47:56 <Moanad> oops I will paste again
16:48:18 <rowanblush> It's the `Tree x' (ts' ...` line that MUST have x' and ts'.
16:48:22 <Moanad>      Tree a ts >>= f = let (a', ts') = unapply $ f a in                       Tree a' (ts' ++ map (>>= f) ts)
16:48:36 <rowanblush> Because those are the new names you've bound to those values, which are the result of `f x`.
16:48:50 <Moanad> yes, but I don't see why ;)
16:50:02 <Gurkenglas> Should there be an instance ComonadCofree [] Tree, akin to the ComonadCofree Maybe NonEmpty seen here? https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html#t:ComonadCofree
16:50:08 <rowanblush> And I can't imagine why not. :-P
16:50:13 <Moanad> so what is the actual matching done on? It does not seem to be same as what I usually do, for example, in mu unapply (where the names are irrelevant, only the PATTERN matters
16:51:49 <monochrom> suppose f x evaluates to "Tree 45 [Tree 32 [], Tree 5 []]"
16:51:50 <rowanblush> The names are irrelevant though. It's their position as arguments to `Tree` that matters, because the where clause is enabling you to do another inline pattern match right there, without defining a new function.
16:52:13 <monochrom> then x' becomes 45, ts' becomes [Tree 32 [], Tree 5 []].
16:53:04 <ski>   let f (x,y) = x + y
16:53:09 <ski>    in f (2,3)
16:53:12 <monochrom> let's go to a really basic example.
16:53:15 <ski> computes the same thing as
16:53:18 <Moanad> add (x,y)  = plus x y where plus carmen san_diego = carmen + san_diego
16:53:19 <ski>   let (x,y) = (2,3)
16:53:21 <ski>    in x + y
16:53:29 <ski> Moanad : do you understand this ?
16:53:49 <Moanad> in the where here, I can call the parameters what I like
16:53:49 <monochrom> if I write "where (x,y) = (0,'x')", you know x becomes 0, y becomes 'x'
16:54:07 <Moanad> yes, I do know that
16:54:36 <Moanad> if you look at my implementaion, I use pattern matching already
16:54:48 <monochrom> if I write "where (x,y) = quotRem 11 3", then x becomes 3, y becomes 2. this is because quotRem 11 3 evaluates to (3,2)
16:55:17 <Moanad> for some reason, for the first time, something seems to be different about the pattern match in question that is confusing me :)
16:55:37 <monochrom> therefore, if f x evaluates to Tree 45 [Tree 32 [], Tree 5 []], then "where Tree x' ts' = f x" makes x' become 45, ts' become [Tree 32 [], Tree 5 []]
16:56:43 <Moanad> OK, yes, ski. Let me see if I can better explain what I don't understand!
16:56:57 <monochrom> only the notation is different. "(x,y)" doesn't look like "Ctor var1 var2". but I can make it so
16:57:18 <monochrom> > let (,) x y = quotRem 11 3 in show x ++ " " ++ show y
16:57:19 <lambdabot>  "3 2"
16:57:36 <monochrom> "Tree x' ts'" is like "(,) x y"
16:57:45 <monochrom> hell, in fact...
16:57:55 <monochrom> > let (,) x' ts' = quotRem 11 3 in show x' ++ " " ++ show ts
16:57:56 <Moanad> right monochrom, that is what I meant when it seems to be matching on the values rather than the pattern - does that not make any sense to anybody else?!
16:57:57 <lambdabot>      Not in scope: ‘ts’
16:57:57 <lambdabot>      Perhaps you meant one of these:
16:57:57 <lambdabot>        ‘ts'’ (line 1), ‘s’ (imported from Debug.SimpleReflect),
16:58:00 <monochrom> > let (,) x' ts' = quotRem 11 3 in show x' ++ " " ++ show ts'
16:58:02 <lambdabot>  "3 2"
16:58:17 * hackagebot purescript 0.7.1.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.7.1.0 (PhilFreeman)
16:58:37 <monochrom> I don't think the wording is important
16:59:03 <Moanad> wht can I write: add (x,y)  = plus x y where plus carmen san_diego = carmen + san_diego
16:59:09 <monochrom> the only important is whether your prediction of program behaviour complies with computer's actual behaviour.
16:59:19 <monochrom> i.e., whether you have predictive power or not
16:59:20 <rowanblush> Values are visually indistinguishable from patterns.
16:59:52 <Moanad> but I cannot change the x' in the "where" in question to x''?? Am I confusing function params with Constructor arguments??
17:00:19 <monochrom> you can. I will do it
17:00:28 <monochrom> > let (,) x'' ts' = quotRem 11 3 in show x'' ++ " " ++ show ts'
17:00:30 <lambdabot>  "3 2"
17:01:52 <ski> Moanad : you have to make the renaming change consistently. renaming both the defining (binding) occurance (in the pattern) and the use occurances (in the expression(s)) at the same time (to the same thing)
17:01:55 <Moanad> right, but the thing I don't get is why you can do that, but not change the x' to x'' in the where clause in question (Monad Tree's >>=)
17:02:34 <monochrom> I don't understand the question. in my most recent example, I have x'' everywhere
17:02:53 <ski> Moanad : if i say `let x = 3 in x * x', then this is the same as `let y = 3 in y * y' (where i changed both the binding `x' in `x = 3' as well as the two uses of `x' in `x * x' to `y')
17:03:07 <monochrom> if you want my example to really use "where", I can take a minute to do it.
17:03:12 <glguy> Moanad: Can you paste the code that you expected to work but it didn't
17:03:22 <glguy> and possibly explain why you thought it would work
17:03:35 <glguy> http://lpaste.net/new/haskell
17:03:36 <ski> Moanad : however, neither (e.g.) `let y = 3 in x * x' nor `let y = 3 in x * y' nor `let x = 3 in y * y' mean the same thing
17:03:38 <Moanad> yes, exactly - you can change it there, as I also demonstrated in my carmen example
17:04:38 <Gurkenglas> Does some package provide a neat 2-dimensional drawing of a plot? Akin to http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html#v:drawTree
17:04:49 <monochrom> "plus carmen san_diego = carmen + san_diego" defines "plus". "carmen" and "san_diego" are invisible to outsiders. not even to "add"
17:05:09 <Moanad> I am trying really hard to understand what is confusing me - it's obvious you are all trying to help and can feel my frustration ;)
17:05:19 <Moanad> ... and I can feel yours!
17:05:25 <monochrom> "(,) x' ts' = whatever" does not define (,). instead, it defines x' and ts'. x' and ts' are visible to outsiders.
17:06:10 <Moanad> so you think maybe it's a scoping issue that i sconfusing me
17:06:11 <Moanad> ?
17:06:16 <monochrom> no
17:06:45 <Moanad> ree x ts >>= f = Tree x' (ts' ++ map (>>= f) ts)
17:06:53 <monochrom> "plus carmen san_diego = ..." defines "plus". it does not define anything else
17:06:56 <Moanad> Tree x ts >>= f = Tree x' (ts' ++ map (>>= f) ts)
17:07:25 <monochrom> "Tree x' ts' = whatever" defines x' and ts'
17:07:47 <Moanad> so the pattern match seems to be able to get inside the Tree x' ts', even though the ts' will have its siblings attached
17:07:53 <monochrom> just like "Just x = Just 45" defines x to be 45
17:08:05 <monochrom> "Tree x' ts'" is a pattern
17:08:16 <ski> > let Just x = Just 45 in x - 10
17:08:18 <lambdabot>  35
17:08:37 <rowanblush> Woah see there is where I think the problem is.
17:08:44 <Moanad> monochrom, I think that is the point, let me digest that (and expel of my previous interpretation)
17:08:49 <eds> Line 46. Error with pattern matching while implementing GADT. Code and Error pasted here: http://lpaste.net/136444. If somebody can explain me that.
17:09:08 <eds> ski: the idea that you gave yesterday, worked :D
17:09:29 <eds> I needed KindSignatures ':)
17:09:39 <rowanblush> You aren't appending anything to ts' until AFTER you have bound ts' in the pattern matching that is happening in the where clause.
17:10:00 <drdo> Is there a good reason why fromString . toString is not the identity? (in Data.ByteString.UTF8)
17:10:19 <ski> eds : perhaps you meant to say `If :: Expr Bool -> Expr Int -> Expr Int -> Expr Int'
17:10:28 <rowanblush> drdo: Almost certainly due to unicode normalization.
17:11:08 <eds> If (Condition) then Int else Int. Umm yea, my bad.
17:11:09 <Moanad> OK, I think that's it. the x' and ts' are being defined then consumed above (I think I have only ever used where clauses for sub-functions before, where you're defining the function and matching patterns of the params). I think I et it now.
17:11:09 <geekosaur> drdo: unicode is Hard(tm)
17:11:15 <eds> ski
17:11:56 <ski> eds
17:11:57 <rowanblush> drdo: Actually the docs say that for toString "invalid characters are replaced with '\xFFFD'"
17:12:07 <Moanad> ... thanks for your patience and explanations.
17:12:15 <ski> no worry
17:12:43 <eds> ski: voila, worked. I should have been able to figure out that pattern matching.
17:15:52 <Moanad> what should I read for precise rules on exactly how and when the definition of x' and ts' is/can be deferred to the where clause, and how the scoping works (ie when can one override var names in a where that are used already in the main body )?
17:16:25 <Moanad> s/override/shadow 
17:16:27 <glguy> Moanad: They aren't being overriden. Without defining them in the where clause you'd just get an error
17:16:40 <monochrom> I read the Haskell 98 Report eventually. (Haskell 2010 did not exist back then.)
17:16:42 <glguy> "Not in scope"
17:17:06 <Moanad> yes, I see that now. But when I write a function in the where, that has params, I can name them what I like
17:17:25 <eds> Is there something like getRandom that would generate a random list of integers?
17:17:27 <rowanblush> http://www.haskell.org/onlinereport/decls.html Section 4.5
17:17:42 <rowanblush> Or somewhere around there.
17:18:03 <Moanad> in this case, the x' and ts' (which are the params to a Tree constructor, probably what threw me is that they are params) are actually being defined in the where
17:18:15 <monochrom> the trouble is that "where <pattern> = <expr>" is not a function definition
17:18:25 <Moanad> thx rowanblush
17:18:52 <Moanad> yes, I think that's the problem I had
17:19:22 <ski> Moanad : in `f <pattern> ... = <expression> where <local definitions>', the variables bound by `<pattern>'s, and those bound by `<local definitions>', are in scope in `<expression>' (if you have guards, then all these variables are also bound in the guards)
17:19:28 <Moanad> I thought wheres are just for declaring sub-functions for use in the scope of the parent function
17:20:03 <Moanad> right ski, thanks. 
17:20:31 <monochrom> "where <pattern> = <expr>" is discussed under the name "pattern binding" IIRC
17:20:53 <Moanad> now I can see one can bind values in a where too, via pattern matching. It is very powerful, took me by surprise.
17:21:28 <ski> Moanad : if you have `f <pattern> ... = let <local definitions> in <expression>', then this is parsed as `f <pattern> ... = (let <local definitions> in <expression>)'. it means basically the same as the previous case above ^, except that variables bound by `<local definitions>' won't be in scope in any guards (since `let ... in ...' is an *expression*, as opposed to `where ...' which attaches to a definition `... = ...')
17:22:00 <ski> Moanad : but variables but by `<pattern>'s will still of course be in scope in any guards
17:22:05 <Moanad> 4.4.3  Function and Pattern Bindings
17:22:16 <monochrom> you once wrote "let (a', ts') = unapply $ f a in ...".  "(a', ts') = unapply $ f a" is also a pattern binding. <pattern> = <expr>
17:23:23 <ski> s/variables but by/variables bound by/
17:23:42 <greymalkin> confused: Have StateT X STM (stuff), want StateT X IO (stuff)
17:23:45 <Moanad> yes, but I think the fact that the x' and ts' are used as params to the Tree ctr , at the pattern match site, is what may have thrown me
17:25:02 <monochrom> greymalkin: every human-made type error is a cognitive dissonance.
17:25:17 <greymalkin> (hence the confusion ... :)
17:26:05 <ski> @type StateT . (Control.Monad.STM.atomically .) . runStateT
17:26:06 <lambdabot> StateT s GHC.Conc.Sync.STM a -> StateT s IO a
17:26:24 <ski> greymalkin : or `hoist atomically', see <https://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html>
17:29:50 <Moanad> in 4.4.3.2...
17:30:00 <Moanad> "It is usually straightforward to tell whether a binding is a pattern binding or a function binding, but the existence of n+k patterns sometimes confuses the issue. Here are four examples:     x + 1 = ... -- Function binding, defines (+) -- Equivalent to   (+) x 1 = ...    (x + 1) = ... -- Pattern binding, defines x..."
17:30:34 <arkeet> fortunately, n+k patterns don't exist anymore.
17:30:38 <hpc> n+k bindings are no longer a default feature
17:30:41 <arkeet> (by default)
17:30:43 <Moanad> I just confused by something else, not the +. Cheers
17:30:43 <hpc> and they were considered bad before
17:31:43 <Moanad> you see a lot of n+1 in param patterns, saves doing n-1 in the body
17:32:19 <kadoban> Moanad: Well, you don't see it a lot anymore, at least I don't.
17:32:44 <geekosaur> it was removed from Haskell2010
17:32:53 <greymalkin> Huh... I haven't seen the (fn .) part before -- silly me.
17:33:06 <geekosaur> in ghc you can turn it back on (LANGUAGE NPlusKPatterns) but few do
17:34:01 <greymalkin> That could actually solve a lot more ugliness that I have lying around.
17:35:00 <Moanad> today is the first time I have tried to actually write haskell code (rather than just read about it), so I will try not to ignore such conventions.
17:36:15 <hpc> a tip: if a convention on writing code seems to result in you writing more confusing code, ignore it while you are still learning to protect your own sanity
17:36:38 <ski> > let (memoArr (0,12) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib 12  -- strange-looking binding
17:36:40 <lambdabot>  144
17:37:38 <Javran> sometimes I'll ignore hlint point-free refactors, not usually end up being good for reading :(
17:38:30 <geekosaur> view pattern?
17:38:47 <ski> yes
17:39:32 <ski> unfortunately i can't say `(memoArr (0,12) -> fib) n = ..n..', much less `(memoArr (0,12) -> fib) 0 = 0; (memoArr (0,12) -> fib) 1 = 1; (memoArr (0,12) -> fib) n = fib (n-1) + fib (n-2)'
17:41:12 <monochrom> but you can use lambda-case :)
17:41:29 <ski> yes
17:41:48 <ski> > let n0 = 12; (memoArr (0,n0) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib n0  -- and for some strange reason, `n0' is not in scope in the expression in the view pattern, here
17:41:50 <lambdabot>      Not in scope: ‘n0’
17:41:50 <lambdabot>      Perhaps you meant ‘n’ (imported from Debug.SimpleReflect)
17:42:38 <monochrom> that's very subtle
17:42:49 <arkeet> Moanad: don't use n+k patterns.
17:43:11 <Moanad> OK!
17:43:16 <arkeet> > let n0 = 12 in let (memoArr (0,n0) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2) in fib n0
17:43:18 <lambdabot>  144
17:43:24 <arkeet> strange indeed.
17:43:52 <arkeet> :t memoArr
17:43:53 <lambdabot> Ix i => (i, i) -> (i -> e) -> i -> e
17:47:46 <ski>  @let memoArr :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArr ix f = (arr !) where arr = listArray ix [f i | i <- range ix]
17:48:30 <ski> > let (memoArr (0,12) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; (stripAddend 2 -> Just n) -> fib (n+1) + fib n in fib 12  -- simulating `n+k'-patterns
17:48:35 <lambdabot>  144
17:50:14 <nikki93> what is the 'singleton list constructor function'?
17:50:19 <nikki93> i.e., a synonym for (: [])
17:50:37 <rowanblush> Presumably.
17:51:48 <Moanad> when do you use camel case and when small letters only?
17:52:27 <Moanad> so bestGuess vs bestguess, for example, in a pattern match
17:52:45 <rowanblush> Are you looking at that example in something?
17:53:22 <rowanblush> I don't think there is a widely known (or even personally known to me) *reason* to not use camelcase.
17:53:29 <Moanad> no, I just notice that a lot of Haskell code has all small letters 
17:53:47 <rowanblush> I'd say it depends on personal style then.
17:53:55 <Moanad> right
17:54:18 <Moanad> in java'land, things are not so liberal!
17:54:36 <rowanblush> I (think?) I always use camel case when a name is made up of two words.
17:54:46 <Moanad> and the comventions are, miraculously, almost universally adhered to
17:55:15 <rowanblush> Sounds awful. ;-D
17:55:19 <Moanad> many years ago, there was even a big debate about whether acronyms sb camelcased
17:55:43 <monochrom> that should alert you to the fundamental problem of camel case
17:55:45 <Moanad> hTTP vs http
17:56:00 <Fuuzetsu> http
17:56:13 <Moanad> yes, that won in the end
17:56:22 <Moanad> and as class name, Http
17:56:38 <Moanad> but even the standard libs fal fowl of this in a few places
17:56:49 <Moanad> this = this convention
17:56:54 <rowanblush> Oh man I don't know if I agree with that decision!
17:57:07 <rowanblush> HTTP is an initialism, not an acronym.
17:57:16 <Fuuzetsu> ok, what about IP?
17:57:18 <Fuuzetsu> ip vs iP
17:57:43 <Fuuzetsu> guess that's an initiaalism as well
17:57:54 <rowanblush> You don't say "ihp"?
17:57:57 <monochrom> I reject camel case in principle for this reason. in practice, I compromise when other people are more comfortable (and when these pathological cases don't happen)
17:57:58 <Moanad> the distinction being the pronouciation
17:58:33 <Fuuzetsu> rowanblush: no, most of the English-speaking world say eye pee
17:58:56 <rowanblush> It was a dry joke. :-P
17:59:11 <Moanad> I think HTTP is more rational too, but, as advised here too, conventions are usually not a bad thing
17:59:36 <Moanad> no, but it makes a difference.
18:00:03 <Moanad> if its just initials, and there is no new pronounciation, then all caps makes more sense, IMO 
18:00:25 <Moanad> SQL!
18:00:26 <rowanblush> Okay but what are your feelings on unicode operators in source code?
18:00:43 <monochrom> I want to use emoji
18:00:59 <rowanblush> monochrom: We're friends now.
18:01:24 <Moanad> what is >>= if now an emoji?
18:02:16 <rowanblush> Looks a bit like a tipped over y-airer.
18:08:21 * hackagebot elocrypt 0.4.1 - Generate easy-to-remember, hard-to-guess passwords  http://hackage.haskell.org/package/elocrypt-0.4.1 (sgillespie)
18:09:45 * ski . o O ( unicode sillines <https://bitbucket.org/aogborn/evil/src/d1933e4d9b34aeb300cf1653e74fcebe69fdd053/prolog/%28%29%29%29.pl> )
18:18:12 <rowanblush> ski: Beautiful and terrible. I don't have a prolog interpreter (and I think nor would I attempt running this...), what does it do?
18:23:40 <mniip> https://translate.google.com/translate?sl=hi&tl=en&u=https%3A%2F%2Fbitbucket.org%2Faogborn%2Fevil%2Fsrc%2Fd1933e4d9b34aeb300cf1653e74fcebe69fdd053%2Fprolog%2F%2528%2529%2529%2529.pl
18:27:50 <ttt_fff> hmm, I have reached this point in my life, where I'm like "hmm, taht looks like a monad. I can make my code shorter if I build a new monad with these sematnics"
18:29:36 <ski> rowanblush :  '8c)'(Qकुल,Qकाम)  temporarily asserts `लक्ष्य(Qकुल)', for the duration of `Qकाम'. logically speaking it's an (implementation of) implication `( लक्ष्य(Qकुल) => Qकाम )'.  ':c['(Qकुल, Qकाम)  , if executed in a dynamic context with `लक्ष्य(Qकुल)' assumed, will call `Qकाम', otherwise aborting with an exception
18:29:44 <hiptobecubic> mtl? transformers? 
18:30:19 <ski> rowanblush : '(((('/1 is just a silly way to spell writeln/1 (cf. `print' in Haskell)
18:30:35 <ttt_fff> ski: wtf
18:31:17 <ski> rowanblush : i suspect that '8c)'/2 and ':c['/2 are supposed to be used together, to establish a tagged dynamic context, and to assert at some point that you're in that context
18:36:10 <mniip> ttt_fff, that's pretty easy to parse actually
18:36:40 <mniip> I mean once you know prolog, you only have to tell equal patterns of symbols apart :)
18:42:10 <ttt_fff> ha
18:42:11 <ttt_fff> just now
18:42:14 <ttt_fff> I am implementing "unify"
18:42:39 <ski> on types ?
18:42:44 <mniip> what's your typestem
18:42:50 <mniip> typesystem
18:43:11 <ttt_fff> yeah, I'm implementing a typed-scheme in haskell
18:43:36 <ski> with typed macros ?
18:43:40 <eds> If I generate a random List say of type [Int] . Is there a way to wrap/convert into a monad?
18:43:46 <ttt_fff> no macros yet, just typed expressions
18:43:53 <ttt_fff> what's so special about typed macros?
18:43:58 <eds> maybe I am framing the question wrong. But I don't know how else to put it.
18:44:08 <ttt_fff> eds: a 'random' list will probably have to be Random [Int]
18:44:10 <ski> i think typed macros could be cbv, instead of cbn
18:44:27 <ski> eds : which monad ?
18:44:44 <eds> umm yea monadRandom
18:45:05 <monochrom> you can use "return" to wrap into a monad
18:45:24 <ski> .. into a monadic action
18:45:28 <monochrom> for example: [4,1,5,6] :: [Int]  (this is a randomly chosen list)
18:45:51 <monochrom> therefore, return [4,1,5,6] :: IO [Int]  (if you want IO)
18:46:14 <ski> eds : `MonadRandom' is a type class. presumably, if `m' is in that class, `m' is a monad as well
18:48:21 <eds> monochrom eds : so if I want it to be wrapped by monadRandom should I return [1,2,3] :: m [Int]?
18:49:06 <ski> eds : yes. if you had a plain list before
18:49:28 <ski> eds : have you made an instance for `Rando (Expr [Int])' ?
18:49:40 <eds> yes! http://lpaste.net/136444
18:51:10 <eds> a mistake in there. I replaced main2 with randlist*
18:54:05 <ski> eds : btw, i think you could have `L :: [a] -> Expr [a]' and `PlusList :: Expr [a] -> Expr [a] -> Expr [a]', if you wanted to
18:55:26 <ski> eds : also, a value of type `Expr [Int]' can't contain any data constructors of `Expr', except `L' and `PlusList'. similarly, values of type `Expr Int',`Expr Bool' can't contain `L's and `PlusList'
18:56:09 <ski> eds : so you effectively currently have two separate types, that have been grafted weakly together. perhaps you're going to change this
18:58:05 <eds> yeah. I just tried but I was not sure how to proceed
18:58:12 <ski> eds : a possible alternative type for `L' would be `[Expr Int] -> Expr [Int]', or even `[Expr a] -> Expr [a]'. then at least `Expr [Int]' can contain other `Expr' constructors than `L' and `PlusList'
18:58:45 <ski> eds : for the other direction, i suppose one could e.g. have a `Sum :: Expr [Int] -> Expr Int'
18:58:48 <eds> Lets start with [Expr a] -> Expr [a]/
18:59:11 <eds> Yeah. I had thought about sum, product and foldl
18:59:51 <eds> Plus was something I just created to see if rando (Expr [Int]) would accept
19:00:03 <eds> something
19:00:05 <lyxx> Hey guys, could I get some help with this error message I'm getting http://pastebin.com/Ap1hcT5b
19:00:27 <lyxx> I'm trying to take a list of a certain type and transform it into a list of an arbitrary type.
19:02:04 <eds> ski: So I defined, L :: [Expr a] -> Expr [a]
19:02:27 <eds> instance Rando (Expr [a]) where
19:02:28 <kadoban> lyxx: What happens when the caller of the function wants it to be   flattenExpr :: PyExpr -> SomeTypeYouDontKnow   ?
19:02:48 <kadoban> lyxx: Sorry, flattenExpr :: PyExpr -> [SomeTypeYouDontKnow]   
19:02:52 <lyxx> kadoban I'm struggling with the flattenList function
19:02:59 <lyxx> flattenPyList
19:03:00 <lyxx> **
19:03:28 <ski> with `L :: [a] -> Expr [a]' and `PlusList :: Expr [a] -> Expr [a] -> Expr [a]' you'd need `instance Random a => Rando (Expr [a])'
19:03:30 <kadoban> Wow I really screwed up, haha.  That's the function I was looking at …   let's try again:    flattenPyList :: PyExpr -> [SomeType]
19:03:32 <eds> rando 1 = L <$> 'I need some kind of monadic finite random list'. Since, getRandoms gives me infinite list.
19:03:33 <ski> i think
19:03:57 <lyxx> flattenPyList :: [PyExpr] -> [SomeType] ***
19:04:01 <lyxx> =P
19:04:01 <ski> with `L :: [Expr a] -> Expr [a]', probably `instance Rando (Expr a) => Rando (Expr [a])'
19:04:02 <kadoban> lyxx: Do you see why the type you've written /has/ to allow it to be used for that, but you have no way to make values of SomeType ?
19:04:18 <kadoban> lyxx: Haha … shit … yeah.
19:04:23 <eds> I removed PlusList. so there is that. But ok instance Random a would make sense, because it would not accept a as a concrete type right?
19:04:29 <eds> ski
19:04:43 <lyxx> Cuz I want to deconstruct the data in the list a certain way depending on the type of PyExpr coming in.
19:05:04 <lyxx> Like if it's a list of PyStrings I want to flatten that list a certain way 
19:05:16 <lyxx> If it's a list of PyInts I want to do something different
19:05:18 <ski> eds : generate a list length `n', then use `replicateM n (rando ...)' ?
19:05:36 <lyxx> So I just want to write a function that takes in a list of PyExprs and return an arbitrary list.
19:05:53 <ski> eds : `a' is a type variable, not a completely specified type, right
19:06:03 <kadoban> lyxx: Do you understand why the type doesn't work, and the error you get though?
19:06:12 <rowanblush> What if you get a heterogenous [PyExpr]?
19:06:20 <lyxx> kadoban: No I don't.  I'm very new to haskell
19:06:22 <Fuuzetsu> eds: I haven't followed but what's wrong with taking afinite numeber of elements from the list generated by getRandoms?
19:06:26 <hiptobecubic> I don't understand "extra-source-files"
19:06:48 <lyxx> rowanblush: I guess I'm operating under the assumption that the list will be homogenous
19:06:57 <lyxx> Well I don't guess that.  That is my assumption
19:06:57 <eds> how would I do that Fuuzetsu !!!
19:06:59 <rowanblush> Haskell doesn't allow you to make that assumption.
19:07:12 <ski> eds : when you had `Rando (Expr [Int])', then it worked because it already knew `Random Int'. but if you have `L :: [a] -> Expr [a]', then `Rando (Expr [a])' doesn't work, since it doesn't work for any `a', only those that are in `Random' so that `getRandoms are defined
19:07:30 <lyxx> So would I need to create a new typeclass and instance it in order to get the functionality I'm looking for?
19:07:57 <eds> ski: Ahh I see.
19:08:04 <eds> that does make sense.
19:08:06 <Fuuzetsu> eds: take 10 <$> getRandoms?
19:08:08 <rowanblush> Not necessarily.
19:08:11 <ski> eds : .. however, if you use `L :: [Expr a] -> Expr [a]' instead, then i think you want to have a constraint with `Rando' involving `a', not one with `Random'
19:08:23 * hackagebot http2 1.0.2 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-1.0.2 (KazuYamamoto)
19:09:19 <ski> eds : because now you don't need to generate some random `a's, but instead a bunch of random `Expr a's, and your `Rando' type class is, afaiui, meant for generating random `Expr's, provided a max depth argument or somesuch
19:09:22 <eds> ski: so I have generated a randomlist of length 10. now? use replicateM(rando randlist)?
19:09:38 * Fuuzetsu → bed
19:09:47 <ski> eds : pass the count to `replicateM'
19:09:48 <rowanblush> lyxx: You could have functions like `pyInts :: [PyExpr] -> [Int]` or `pyStrings :: [PyExpr] -> [String]`.
19:09:52 <ski> @type replicateM
19:09:53 <lambdabot> Monad m => Int -> m a -> m [a]
19:10:39 <eds> ahh that made sense. Rando knows what Expr a's is and my list will be made up of those so it won't have a problem. wow.
19:10:59 <lyxx> rowanblush: Cool.  I didn't think of that.
19:11:08 <eds> what is afaiui? 
19:11:14 <eds> @afaiui
19:11:14 <lambdabot> Unknown command, try @list
19:11:26 <ski> "as far as i understand it"
19:11:36 <rowanblush> lyxx: Or `pyPartition :: [PyExpr] -> ([Int], [String], [String], [[PyExpr]])`.
19:11:42 <eds> heh, ok
19:22:35 <lyxx> rowanblush thanks for you help!!
19:22:42 <lyxx> I figured out how to get what I wanted. You rock!
19:25:37 <GLM> How can I encde arbitary data as JSON?
19:26:12 <KaneTW> https://hackage.haskell.org/package/aeson/docs/Data-Aeson-Generic.html maybe?
19:26:29 <KaneTW> that's outdated, sorry
19:26:31 <KaneTW> hold on
19:26:57 <GLM> KaneTW:I already looked at it but encode failed
19:27:01 <KaneTW> either https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson-TH.html or use GHC generics directly
19:27:38 <eds> ski: rando 1 = L <$> replicateM 10 (rando 2) does this look alright? Though I don't seem to understand how replicateM would work here. Would it create [2,2,2,2,2..] of length 10. and  2 is Expr Int?
19:28:11 <GLM> KaneTW:For example, how do I encode Just 5 or Right "Hey"
19:28:51 <KaneTW> mkToJSON is what you want then
19:29:03 <GLM> Thanks
19:29:15 <KaneTW> e.g.
19:29:22 <hiptobecubic> Specifically, I don't understand why  extra-source-files does not appear to do anything
19:29:36 <rowanblush> lyxx: Glad I could help.
19:29:40 <gcganley> is there anywhere that i could buy a haskell sticker to put on the back of my laptop
19:29:57 <KaneTW> encodeLeft :: Either -> Value; encodeLeft = $(mkToJSON id ''Either)
19:30:02 <KaneTW> encodeEither, not left
19:30:07 <ski> eds : `replicateM n act' executes `act' `n' times, collecting the results in a list
19:30:18 <hiptobecubic> gcganley, i have a great one
19:30:33 <gcganley> hiptobecubic: is there a link I could buy it from?
19:30:38 <hiptobecubic> gcganley, someone at the austin haskell meetup had some made. You could do the same. let me search my history
19:30:40 <GLM> KaneTW: Is mkToJSON in Aeson? I checked the type of it and it doesn't know of the function?
19:30:55 <dmj`> gcganley: https://www.stickermule.com/marketplace/3377-haskell-logo
19:31:01 <eds> Ahh so a list of 2 of length 10 would be created, right.
19:31:12 <KaneTW> GLM: Data.Aeson.TH, requires -XTemplateHaskell
19:31:17 <gcganley> hiptobecubic: I could go to the boston one where edwardk goes to
19:31:21 <eds> I will be right back in 10 mins.
19:31:39 <ski> eds : so, given `rando 2 :: m (Expr a)' (where `MonadRandom m'), you get `replicateM 10 (rando 2) :: m [Expr a]', and then finally `L <$> replicateM 10 (rando 2) :: m (Expr [a])'
19:31:45 <gcganley> dmj`: thank you
19:31:45 <hiptobecubic> I think it was similar to this one: https://www.stickermule.com/marketplace/1783-haskell-sticker
19:32:08 <hiptobecubic> ah here it is https://www.stickermule.com/marketplace/3377-haskell-logo
19:32:14 <hiptobecubic> gcganley, ^
19:32:48 <hiptobecubic> I get a lot of compliments on it :)   It came out well.
19:32:51 <dmj`> gcganley: I have an old white one on my laptop
19:32:55 <KaneTW> if it complains about the first argument's type, try defaultOptions
19:32:55 <ski> eds : however, i think it would probably be better with something like `rando d = L <$> replicateM 10 (rando (d-1))'. .. you could also generate a random count, instead of hardcoding `10' in there
19:32:58 <dmj`> hiptobecubic: just bought it
19:32:59 <Javran> seems like "cabal exec" sometimes outputs extra message to stdout, which messes up my autoscripts. would "cabal exec -v0 -- " be guaranteed not to ouput any extra message? 
19:33:36 <hiptobecubic> I like the purple one over the gray, personally
19:33:38 <gcganley> dmj`, hiptobecubic: I'm trying to get a sticker for every language that I've been good in. So right now im getting a haskell sticker and a clojure sticker
19:33:49 <hiptobecubic> But both are pretty solid.
19:34:24 <ski> eds : `rando d = do n <- getRandomR (0,2*d); L <$> replicateM n (rando (d-1))' or whatever you want to do
19:37:14 <dhruvio> hi everyone, i am new to haskell, and this my first time on this channel :)
19:38:18 <bernalex> dhruvio: hi.
19:38:26 <dmj`> dhruvio: you've come to the right place
19:38:41 <dhruvio> dmj, bernalex: thanks! 
19:38:49 <dhruvio> dmj` *
19:40:36 <dhruvio> my background is in full stack development, mainly javascript, python and a little java — really excited about diving in
19:47:31 <lyxx> How do you pass in a data constructor as an argument to a funciton?
19:48:13 <Cale> lyxx: The same way you pass anything as an argument to a function
19:48:25 <lyxx> I'm trying that, but it's throwing an error at me.
19:48:31 <bernalex> lyxx: I don't understand the question. you make a function that takes the data constructor.
19:48:31 <Cale> lyxx: Which error?
19:48:33 <arkeet> show code/error?
19:48:47 <arkeet> a data constructor (used as an expression) is just a function.
19:49:03 <arkeet> (or not a function, if it takes no arguments)
19:49:24 <Cale> lyxx: Note that if the data constructor is a function, the function you're passing it to had better accept a function as an argument
19:49:48 <slack1256> >:t Just
19:49:52 <arkeet> :t Just
19:49:53 <lambdabot> a -> Maybe a
19:50:13 <slack1256> > map Just [5,6,9]
19:50:14 <lambdabot>  [Just 5,Just 6,Just 9]
19:50:37 <lyxx> http://pastebin.com/r1VS3iVJ
19:50:46 <bernalex> lyxx: please use lpaste rather than pastebin.
19:51:03 <arkeet> ah, your problem is in the type of createList.
19:51:07 <bernalex> that's a type error.
19:51:13 <lyxx> bernalex I was told to use pastebin my first time around
19:51:36 <Cale> lyxx: When you use a variable like f there, it means that the type of the argument to createList can be literally any type.
19:51:38 <adarqui> would anyone do anything different to this factorial function (using State & Break): https://github.com/adarqui/toybox/blob/master/haskell/gonzalez/break/src/TB/Break/Examples.hs
19:51:44 <bernalex> lyxx: are you sure they did not say "a pastebin", as in a pastebin service? pastebin.com is pretty bad -- we prefer lpaste in here. it's fine for now though, just a ffr. :)
19:52:07 <lyxx> Oh maybe it was a misunderstaanding on my behalf.  To lpaste I go!
19:52:11 <Cale> lyxx: However, you're using listType as a function (passing it to map), which means that whatever type it has had better actually be a function type.
19:52:33 <lyxx> So do I have to bind f to a specific type?
19:52:55 <lyxx> createList :: PyExpr -> [a] -> [PyExpr]
19:52:55 <lyxx> Like that?
19:53:01 <Cale> First of all, try just commenting out or deleting the type signature for createList and have a look at what type ghci infers.
19:53:09 <adarqui> maybe execState go, and have a 'where go = '
19:53:29 <lyxx> Oh okay.  I forget that Haskell can infer data types
19:53:44 <Cale> It probably ought to be:  createList :: (a -> PyExpr) -> [a] -> PyExpr
19:53:44 <lyxx> But now taht I see it it makes a ton of sense
19:53:48 <lyxx> yup
19:54:01 <lyxx> That makes 100% sense.  
19:54:10 <mniip> if x :: Int, and PyInt x :: PyExpr
19:54:16 <mniip> then PyInt :: Int -> PyExpr
19:54:28 <lyxx> I'm new to Haskell so I'm still getting that knowledge under my belt.  I appreciate how helpful this channel is =) You guys continue to rock
19:58:27 <codygman> What would the initial reader state be here? I don't remember Persistent entities being wrapped in a ReaderT before either, so a bit confused. Any ideas? ghci session: http://lpaste.net/136563
20:00:35 <Cale> codygman: Something that might help while reading the documentation is that SqlPersistT is a type synonym for ReaderT SqlBackend
20:00:54 <Cale> codygman: Probably you're meant to apply the runSqlite function
20:01:14 <codygman> Cale: Thanks for the tip about the type synonym.
20:01:26 <codygman> Cale: That's what my runDB function does
20:01:37 <codygman> well what I think it does
20:01:40 <Cale> yeah
20:01:53 <Cale> Do you get a type error from runDB (selectFirst ...) ?
20:04:56 <codygman> No type error, actually `question <- runSqlite "yesod-polls.sqlite3" (selectFirst [QuestionText ==. "What's new"] [])` does what I was expecting... but my combinator doesn't seem to work right.
20:06:18 <codygman> Cale: Nevermind I think it's working now for some reason...
20:19:45 <srobert> I've been following Hutton's "Programming in Haskell" book. There are some recursive definitions that involve "n+1" on the left of the equation. Is this deprecated? ghci doesn't seem to accept it.
20:20:04 <slack1256> yes it is deprecated
20:20:08 <benzrf> srobert: ye
20:20:17 <benzrf> p
20:20:26 <benzrf> srobert: it's completely misleading, syntactically
20:20:55 <srobert> Thank you. I also saw in Wadler's video that he was bragging about getting that notation into Haskell.
20:21:07 <srobert> He must be disappointed.
20:21:30 <pingu> srobert: they're called n+k patterns
20:21:39 <pingu> https://ghc.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
20:23:12 <srobert> pingu: thanks I was googling for an explanation.
20:23:26 * hackagebot free-http 0.1.0.1 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.0.1 (aaronlevin)
20:28:27 * hackagebot free-http 0.1.0.2 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.0.2 (aaronlevin)
20:32:29 <yayfoxes> aw man Cale , can we work on Exercises listing 2.6.4 together?
20:34:09 <Cale> yayfoxes: okay
20:35:21 <yayfoxes> if I defined it in my own terms it'd be last (x:[]) = x; last (_:xs) = last xs
20:35:32 <Cale> Sure
20:36:05 <Cale> Of course, that's not in terms of library functions :)
20:36:26 <lethjakman> is there a command line way to do what hoogle does?
20:36:27 <yayfoxes> but it proves I know what to do for my own stuff, right?
20:36:35 <Cale> sure
20:36:36 <KaneTW> lethjakman: you could install hoogle locally
20:36:39 <yayfoxes> lethjakman: surfraw might support that
20:36:41 <Cale> There are a bunch of ways to compute the same thing in terms of the functions that get introduced in section 2.2
20:36:49 <KaneTW> also hsdev might support that
20:37:17 <yayfoxes> Cale: drop ((length xs) - 1)
20:37:27 <lethjakman> ooo cool
20:37:30 <lethjakman> but these all seem browser based
20:37:32 <Cale> Close, but not quite the right type :)
20:37:35 <lethjakman> is there a way to do a CLI lookup?
20:37:43 <lethjakman> I like staying in my terminal
20:38:27 * hackagebot vector 0.11.0.0 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.11.0.0 (DanDoel)
20:38:29 * hackagebot free-http 0.1.1.0 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.1.0 (aaronlevin)
20:38:32 <yayfoxes> Cale: head (drop ((length xs) - 1))
20:38:51 <KaneTW> hsdev is local
20:39:13 <KaneTW> it might query the web though, you'd need a local hoogle install for a completely local setup
20:39:36 <lethjakman> oooo ghci on acid
20:40:25 <yayfoxes> but then, how would I just make a function that takes a singleton list and returns it's element? singletonelem (x:[]) = x; singletonelem (x:xs) = error "More than one list item detected"
20:40:31 <yayfoxes> just like that Cale ?
20:40:54 <yayfoxes> fun!
20:41:56 <yayfoxes> I'd also name it unwrapsingleitem
20:43:56 <yayfoxes> > drop 1 (flip (tail :))
20:43:57 <lambdabot>      Couldn't match expected type ‘[a]’
20:43:57 <lambdabot>                  with actual type ‘b0 -> [[a0] -> [a0]] -> c0’
20:43:57 <lambdabot>      Probable cause: ‘flip’ is applied to too few arguments
20:48:28 * hackagebot free-http 0.1.1.1 - An HTTP Client based on Free Monads.  http://hackage.haskell.org/package/free-http-0.1.1.1 (aaronlevin)
21:00:25 <Exxon> how do i haskell
21:01:11 <Exxon> i have heard good things about this channel
21:03:36 <Exxon> :<
21:05:14 <bob_twinkles> ?books
21:05:14 <lambdabot> Unknown command, try @list
21:05:17 <bob_twinkles> =(
21:09:45 <slack1256> @where lyah
21:09:45 <lambdabot> http://www.learnyouahaskell.com/
21:10:03 <bob_twinkles> @where books
21:10:03 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
21:10:06 <MarcelineVQ> I miss exxon
21:10:08 <bob_twinkles> got my channel bots confuzed =P
21:10:26 <slack1256> I don't, I lost too many stocks that day
21:18:29 * hackagebot range 0.1.1.1 - This has a bunch of code for specifying and managing ranges in your code.  http://hackage.haskell.org/package/range-0.1.1.1 (RobertMassaioli)
21:22:30 <felixn> I feel like a derp, how would I use the list monad wrapped in either?  so far I know this is not right: do { x <- liftM [1,2,3]; return (x * 2); }
21:26:53 <benzrf> do you mean lift [1, 2, 3]
21:26:55 <benzrf> :t liftM
21:26:57 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:26:57 <benzrf> :t lift
21:26:58 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:30:37 <MarcelineVQ> "<benzrf> what the heck is a retrogression" hehe
21:32:43 <benzrf> ?
21:32:54 <lethjakman> hey, I'm getting an error while trying to compile the coin functions from LYAH: https://gist.github.com/lethjakman/deb5f200748a951875a2
21:33:02 <lethjakman> any clue why line 14 throws that error?
21:33:13 <lethjakman> if I comment out line 14 it works...and Prob exists because it was used in flatten
21:33:32 <arkeet> you're on ghc 7.10?
21:33:38 <arkeet> Monad has an Applicative superclass now.
21:34:03 <arkeet> the easiest thing to do is just instance Applicative Prob where pure = return; (<*>) = ap
21:34:08 <arkeet> (and import Control.Applicative)
21:35:44 <lethjakman> arkeet: ahhh that was it!
21:35:59 <lethjakman> that actually makes sense anyways, thank you.
21:43:15 <felixn> benzrf: hey thanks, I'm just going to convert my errors into [] ... this is confusing :D runEitherT $ do { x <- lift [1,2,3]; left "nope"; y <- lift [0..x]; return (x*y) } == [Left "nope",Left "nope",Left "nope"]
21:46:49 <eds> ski: I implemented along your lines and it worked :). thanks
21:48:40 <eds> When I create my random AST it goes on for a infinite period of time if a particular length of List is selected as node. What kind of checks/tags can I set to ensure the tree generation does not go on for a longer period of time? http://lpaste.net/136444
21:49:34 <eds> Like example: (L [I (-515431072909441152)])) (If (Lt (If (B True) (Sum (L [I  (-9221785155308563670)]) (L [Times (Times (If (Eq (Sum (L [Times (Plus (I (-595 4816561359204945)) (Plus (Plus (Plus (PluInterrupted.
21:50:56 <lethjakman> ok, so this is probably a dumb question, but I'm having issues using the flatten in my previous post
21:50:57 <felixn> eds: you'll have to keep track of how much AST you want to generate, so you could limit the depth, or node code
21:51:02 <lethjakman> I'm attempting to use it like this: flatten [ ( Prob [('a',1%2),('b',1%2)] , 1%4 ), ( Prob [('c',1%2),('d',1%2)] , 3%4 ) ]
21:51:10 <lethjakman> and several other ways, but I'm not entirely sure what I'm doing wrong
21:51:20 <lethjakman> I can't seem to match the type
21:51:25 <lethjakman> https://gist.github.com/lethjakman/deb5f200748a951875a2
21:51:30 <lethjakman> this is my post if it makes it easier to access
21:52:04 <eds> felixn: how would I do that? I think I am limiting this one to depth 5. But it still goes on.
21:52:26 <yayfoxes> hey guys, is there any way possible to fix Haskell on Windows to use dynamic libraries, be build split-objs, and use LLVM?
21:56:11 <felixn> eds: hmm, yea, I guess it's too exponential unless you missed a place, you could pop it in StateT and limit nesting at like 500 nodes
21:56:34 <eds> @StateT
21:56:34 <lambdabot> Unknown command, try @list
21:56:50 <slack1256> > :info StateT
21:56:51 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:56:55 <slack1256> @info StateT
21:56:55 <lambdabot> StateT
21:57:28 <eds> heh lambdabot kidding
21:58:10 <eds> StateT, could you elaborate? I don't know what it is
21:58:23 <eds> felixn slack1256
21:58:37 <felixn> eds: sure
21:58:38 <felixn> > runStateT (do { put "100 nodes"; n <- lift $ getRandomR (0, 10); return n }) ""
21:58:39 <lambdabot>  Not in scope: ‘getRandomR’
21:58:46 <felixn> eds: do that locally ^_^
21:59:28 <felixn> eds: you can keep track of some arbitrary state across your whole algo
21:59:44 <eds> oh niceee!
22:00:16 <eds> what does n do here?
22:00:30 <slack1256> magic
22:00:30 <felixn> that stateful goodness we all know and love
22:00:48 <felixn> eds: n is where I put a random number, to show you how to pull one out
22:01:31 <slack1256> > runStateT (modify (+1) >> get) 5
22:01:33 <lambdabot>      No instance for (Show (m0 (a0, a0)))
22:01:33 <lambdabot>        arising from a use of ‘show_M401457020420918480520587’
22:01:33 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
22:01:52 <felixn> lethjakman: what are you trying to do?  find all possible solutions to a problem?
22:02:31 <lethjakman> felixn: I'm trying to figure out how that flatten is working and how to use it, because I'm not understanding something about the type signature
22:02:36 <slack1256> > runState (modify (+1) >> get) 5
22:02:37 <lambdabot>  (6,6)
22:03:06 <lethjakman> and I'm not understanding how it actually flattens...
22:03:15 <lethjakman> cause it looks like it'd return an array to me
22:04:16 <eds> Yeah but then how does it keep a check of 100 nodes? Is it that it would create 100 random n's was what I thought. felixn
22:04:34 <eds> Also, what library should I import for runStateT?
22:04:42 <arkeet> @hoogle runStateT
22:04:43 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s a -> s -> m (a, s)
22:04:43 <lambdabot> Control.Monad.State.Strict runStateT :: StateT s a -> s -> m (a, s)
22:04:43 <lambdabot> Control.Monad.Trans.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
22:04:58 <arkeet> bah. if you used web hoogle it would tell you it's in transformers.
22:05:04 <felixn> eds: just keep subtracting 1 from the total everytime you nest, if there is none left, only let the AST choose terminating nodes
22:05:16 <zcourts> Given that typeclasses allow default implination of funcs. and you can apply a class constraint which demands 2 or more type classes - does Haskell have the diamond problem found in other languages with multiple inheritance e.g. C++, if not, why not?
22:06:24 <felixn> lethjakman: http://stackoverflow.com/questions/25598311/understanding-bind-of-newtype-prob maybe this would help explain it
22:06:34 <slack1256> zcourts: I don't know about multiple inheritance problems of C++, but what you are looking for is the FunDeps extensions for multi-parameters typeclasses
22:06:45 <arkeet> zcourts: there is no overriding, thus no diamond problem.
22:07:00 <dirk103> heyo
22:07:00 <dirk103> im having trouble with this
22:07:00 <dirk103> Prelude> :type [[True],[False,False]]
22:07:00 <dirk103> [[True],[False,False]] :: [[Bool]]
22:07:14 <dolio> There's no inheritance.
22:07:19 <dirk103> shouldn't that be of type :: [[Bool],[Bool,Bool]] ?
22:07:27 <arkeet> types aren't lists.
22:07:34 <felixn> lethjakman: also if you use an editor like Atom with haskell integration, you can hover over the words to get type info which is also helpful to figuring these things out
22:07:42 <arkeet> [[Bool]] is the type of lists whose elements are lists whose elements are Bools.
22:08:04 <eds> @felixn: what would be the total here?
22:08:04 <lambdabot> Unknown command, try @list
22:08:09 <eds> And lift is a member of what class/library?
22:08:09 <lethjakman> felixn: I'm reading this, thank you. 
22:08:18 <lethjakman> do you mean Prob (Prob a) -> Prob a?
22:08:21 <lethjakman> or something eles?
22:08:23 <eds> :t lift
22:08:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:08:34 <felixn> dirk103: lists only can contain one type, so [Bool] only makes sense, the length of a list is not part of the type
22:08:57 <dolio> Perhaps it would be clearer if [] weren't used both for list values and types.
22:09:14 <arkeet> perhaps.
22:09:14 <dolio> [[True],[False,False]] :: List (List Bool)
22:09:26 <bitemyapp> dolio: slapping Mk on the front of data constructors can help disambiguate for new people. the syntactic conflation is unfortunate but it may well be worth it.
22:09:36 <bitemyapp> the type constructor probably should've just been List.
22:09:53 <bitemyapp> (,) et al. suffer from the same issue.
22:10:11 <dolio> Yes. There are several reasons why all that is bad. But it's too late now.
22:10:15 <bitemyapp> some of the benefit of newbie preludes is side-stepping that until you can explain it properly.
22:10:18 <eds> @hoogle lift
22:10:18 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
22:10:18 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
22:10:18 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
22:10:26 <felixn> dolio: yea, i could see that being less confusing, let's ask dirk103 :D does this make more sense? [[True],[False,False]] :: List (List Bool)
22:10:27 <bitemyapp> yeah, I have no illusions of it being fixed. We work around it in the book.
22:10:39 <bitemyapp> not that big of a deal, just a papercut :)
22:11:31 <felixn> eds: read about the state monad!  when you do runStateT you can set the initial state, which would be max number of nodes
22:12:05 <eds> ahh state monad. On it. I see. 
22:13:06 <felixn> lethjakman: sorry I can't help you more, not familiar with the prob stuff, and too lazy to look into it, it all just looks like operator soup to me
22:13:56 <dirk103> hmm
22:14:18 <dirk103> why can't I have a list like [[Int],[Bool][Bool]] ?
22:14:30 <arkeet> lists only have one element type.
22:14:42 <dirk103> ok
22:14:53 <dirk103> is that a limitation or am i looking at this wrong?
22:15:01 <adarqui> [a] means list of one type
22:15:23 <dirk103> not [A] ?
22:15:31 <adarqui> you could define a data type which is perhaps, data Blah = Xint Int | XBool Bool.. and then have [Blah]
22:15:32 <lethjakman> fair enough
22:15:36 <lethjakman> lol I agree it's pretty confusing
22:15:38 <adarqui> for example..
22:15:51 <adarqui> nah, lowercase a means it's a 'polymorphic type'
22:15:53 <arkeet> dirk103: it's from the definition of a list.
22:16:15 <dirk103> what does | mean again
22:16:19 <eds> runStateT gives following error. What does it mean? GenericGP.hs:14:1:     Couldn't match type `[Char] -> m0 (a0, [Char])' with `Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]'  Expected type: Language.Haskell.TH.Lib.DecsQ  Actual type: [Char] -> m0 (a0, [Char])     Probable cause: `runStateT' is applied to too few arguments   In the expression: runStateT    (do { put "100 nodes";  n <- lift $ getRandomR (0, 10);         
22:16:32 <dirk103> eee
22:16:58 <arkeet> eds: 
22:17:01 <arkeet> @paste your code and error.l
22:17:02 <lambdabot> Haskell pastebin: http://lpaste.net/
22:17:24 <verement> :t [(3::Int,True),(5,False),(2,True)]
22:17:26 <lambdabot> [(Int, Bool)]
22:17:26 <nshepperd> dirk103: [Bool] means "list of Bools"
22:18:18 <dirk103> ohhh okay
22:18:27 <dirk103> i see 
22:18:32 <felixn> eds: the error says exactly what's wrong :D  couldn't of said it better "Probable cause: `runStateT' is applied to too few arguments"
22:20:02 <dirk103> in my C++ i like to define big data structures that hold all sorts of different data in class{} or struct{}  do you do it in the same thought process in haskell?
22:20:12 <dirk103> grouping a bunch of stuff under one typename?
22:22:04 <adarqui> check out tuples, records, type classes
22:22:32 <slack1256> dirk103: nah
22:22:41 <slack1256> you usually define the data structure (say a queue)
22:22:50 <slack1256> and implement on the same module the operations you want
22:23:08 <slack1256> Data.Map is a good example of that (on a high level view)
22:23:43 <dirk103> oh ok
22:24:50 <slack1256> you usually want dumb data definitions and a core set of smart functions that preserv the semantics you want
22:25:05 <lethjakman> wtf
22:25:14 <lethjakman> if I assign Prob  [( Prob [('a',1%2),('b',1%2)] , 1%4  )  ,( Prob [('c',1%2),('d',1%2)] , 3%4 )  ] to a variable I can use it in flatten
22:25:21 <lethjakman> if it's going straight into flatten it doesnt' work
22:25:57 <dirk103> slack: that helps a lot
22:25:59 <lethjakman> :t is different when it's assigned to a variable too
22:26:00 <lambdabot>     Not in scope: ‘is’
22:26:00 <lambdabot>     Perhaps you meant one of these:
22:26:00 <lambdabot>       ‘id’ (imported from Data.Function),
22:26:21 <eds> arkeet: code and error: http://lpaste.net/136444
22:26:57 <eds> felixn: yea. some argument is missing. I thought you would know since you framed the statement. :D
22:28:52 <felixn> eds: I'm not going to tell you for you own good, when make it to president of math club, you'll thank me
22:29:52 <eds> heh alright I'll look into state monad!
22:36:29 <funfunctor> What does this type check error mean? http://lpaste.net/136573
22:36:57 <Mysticeti> hey guys, I have been wanting to learn a programming language, and Haskell looks pretty awesome, but I find one awkward problem here, I do not know what direction I would like to work towards. Is there any suggestion? (Web-apps, desktop apps, network, etc) I have no idea
22:37:07 <funfunctor> seem to have a issue with postgresql-simple when one of my fields is a tuple type :: (Float, Float)
22:37:42 <arkeet> funfunctor: indeed there is no instance for tuples http://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple-FromField.html
22:38:21 <funfunctor> Mysticeti: if you are just starting programming, web tends to have too many components (none complex) leading to complexity of the system. I would advise starting with project euler problems or something very restricted in scope
22:38:40 <funfunctor> arkeet: hmm? how do I handle data with a point data type?
22:38:49 <hiptobecubic> exio4, I took the time to set up a proper project. https://github.com/johntyree/brnfckr
22:38:56 <funfunctor> arkeet: I wish to store geo coordinates
22:39:00 <arkeet> funfunctor: what does it look like in the db?
22:39:20 <Mysticeti> funfunctor: thank you!
22:39:43 <funfunctor> arkeet: http://lpaste.net/136574
22:40:02 <exio4> nice hiptobecubic 
22:40:19 <hiptobecubic> exio4, took way too long to figure out how that crap works.
22:40:40 <hiptobecubic> exio4, things like data-files and getting tests working, etc.
22:41:00 <funfunctor> Mysticeti: your welcome. good luck and don't give up!
22:41:05 <exio4> hiptobecubic: I was checking that, far from organized than anything I ever do :P
22:41:24 <hiptobecubic> but `stack exec brnfckr programs/bottles.bf` works now. So I'm calling it a night.
22:41:44 <hiptobecubic> stack is amazing.
22:41:46 <hiptobecubic> all hail stack
22:42:09 <arkeet> funfunctor: I don't see anything for working with points.
22:42:35 <funfunctor> arkeet: really?!
22:43:21 <hiptobecubic> exio4, it says i have non-exhaustive pattern matching, but I don't see it :(
22:43:30 <funfunctor> what a huge pain
22:43:34 <arkeet> funfunctor: perhaps you can write your own FieldParser for points.
22:43:54 <exio4> hiptobecubic: the compiler should tell you where
22:43:58 <funfunctor> arkeet: deadline.. got to write too much code before tomorrow..
22:44:05 <hiptobecubic> exio4, it does. I just don't see how it's true.
22:44:16 <hiptobecubic> exio4, http://vpaste.net/vRDqU
22:44:25 <hiptobecubic> says go doesn't match "[]"
22:44:41 <hiptobecubic> But hte last one should.
22:45:26 <arkeet> funfunctor: field = fieldWith fromField, where fromField is the FieldParser from the FromField instance.
22:45:31 <arkeet> look at how some of the FromField instances work.
22:45:47 <funfunctor> ok
22:46:01 <arkeet> then you can possibly define some FieldParser (Float,Float)
22:46:03 <zcourts> Given that typeclasses allow default implination of funcs. and you can apply a class constraint which demands 2 or more type classes - does Haskell have the diamond problem found in other languages with multiple inheritance e.g. C++, if not, why not?
22:46:05 <arkeet> that you can give to fieldWith
22:46:24 <hiptobecubic> exio4, nevermind. I am seriously retarded.
22:46:56 <hiptobecubic> It just so happens that line 113 in another file is also a subfunction named 'go'
22:47:04 <hiptobecubic> Was looking at the wrong one :(
22:48:33 * hackagebot takahashi 0.2.1.0 - create slide for presentation.  http://hackage.haskell.org/package/takahashi-0.2.1.0 (outoftune)
22:48:35 <peddie> zcourts: it's not inheritance; you define an instance of a type class for a particular type, so I don't think there would be a conflict of any kind
22:48:35 * hackagebot takahashi 0.2.2.0 - create slide for presentation.  http://hackage.haskell.org/package/takahashi-0.2.2.0 (outoftune)
22:50:59 <funfunctor> arkeet: it is not really clear to me what to write in the instance because I am not really a db guy
22:51:02 <funfunctor> http://www.postgresql.org/docs/9.4/static/datatype-geometric.html#DATATYPE-GEO-TABLE
22:51:12 <funfunctor> can't see anything that says pg_point
22:51:32 <arkeet> I don't know anything about postgres or anything.
22:52:29 <zcourts> peddie: Okay. That makes sense. I misread the second point under “Comparison to other langauges” on https://www.haskell.org/tutorial/classes.html
22:52:54 <arkeet> I'm guessing you'll have to parse something in (x,y) or x,y format.
22:53:17 <arkeet> which means writing a Parser.
22:55:09 <funfunctor> ugh
22:55:50 <funfunctor> the union of two things I have horrible at, Parsers U Databases
22:55:52 <peddie> zcourts: another way to look at it is that the instance of some type class instance for some type can't override the method definitions given in the instance of the superclass -- you can't redefine (==) when you define an Ord instance for your type; the definition is given only once in the Eq instance
22:55:57 <exio4> hiptobecubic: at least it's not a bug due to shadowing because all your variables are called either `x` or `y` :D
22:56:22 <hiptobecubic> :)
23:06:27 <zcourts> peddie: I see. So no matter how many constraints require Eq, there’s only one def of (==), so class class (Eq a)=> A a where
23:06:54 <zcourts> class (Eq a)=> B a where
23:06:54 <zcourts> class (A a, B a)=> C a where
23:06:54 <zcourts> as in ^^
23:07:04 <peddie> zcourts: precisely; in C++, a subclass's definition of a method can override the superclass's definition, but not in Haskell
23:12:26 <zcourts> peddie: Gotcha. Thanks
23:12:52 <peddie> you're welcome?  :)
23:16:00 <funfunctor> @hoogle [Either a b] -> [b]
23:16:00 <lambdabot> Data.Either rights :: [Either a b] -> [b]
23:16:01 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
23:16:01 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
23:16:11 <funfunctor> oh sweet
