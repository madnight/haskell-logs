00:01:38 <liste> sounds broken
00:02:05 <liste> the sandbox check, at least
00:04:16 <adarqui> i just want to keep reading this pipes tutorial and not sleep
00:07:04 <MarcelineVQ> link it and we can both feel that way
00:08:23 <adarqui> MarcelineVQ: https://hackage.haskell.org/package/pipes-4.1.5/docs/Pipes-Tutorial.html
00:08:28 <adarqui> :F
00:08:43 <liste> gabriel is awesome but the blogger UI sucks :(
00:08:54 <adarqui> for his haskellforall blog?
00:08:58 <liste> yeah
00:09:08 <liste> I'm trying to find his pipes posts
00:10:17 <liste> clicking open the hierarchy year by year, month by month
00:11:36 <adarqui> what happens to a pro haskeller when they get a non-haskell job, ie scala/ocaml etc..
00:11:51 <adarqui> sounds like a quora question hehe.
00:12:06 <MarcelineVQ> liste write a spider in haskell to search for the post :> You'll prob want to use pipes and, uh, oh shit
00:12:08 <wizek> liste: I've recreated the sandbox, and now I get just the warnings: http://lpaste.net/6698047119254618112
00:12:21 <liste> wizek that looks good
00:13:15 <wizek> liste: however, when I try to compile, I get the same error message related to random-1.0.1.1:System.Random.StdGen
00:14:06 <shachaf> If your error message has a version number in it, that probably means you hve multiple versions of the same package.
00:14:39 <gfixler> how much more of a pain is working with monad transformers than working with plain monads?
00:14:52 <gfixler> is it significantly more fuss?
00:15:09 <johnw> that really depends on the nature of the transformer, and what you're doing
00:15:13 <liste> wizek what imports do you have when the error shows up
00:15:48 <jle`> it really depends on the situation, really
00:16:08 <jle`> sometimes writing a monad is nicer than using a monad transformers and sometimes the transformer is a nice shortcut to what you'd do by hand anyway
00:16:24 <jle`> for example today i wanted to chain and sequence `s -> IO (a, s)`'s
00:16:25 <adarqui> gfixler: from a basic perspective, not much at all. check some of the transformers source: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-State-Lazy.html
00:16:43 <liste> gfixler with mtl classes (MonadReader, MonadWriter) the monadic code is identical but the type signatures and running the stack are more complex
00:16:47 <jle`> i could make a newtype wrapping an s -> IO (a, s) function and define its functor, applicative, monad instance etc.
00:16:53 <adarqui> ie how they create State s as StateT s Identity etc..
00:16:56 <jle`> or i could just use State t IO s
00:17:05 <jle`> *StateT s IO a
00:17:11 <jle`> and the instances are already written for me :)
00:17:35 <liste> (and there's of core MonadState etc...)
00:17:36 <gfixler> jle`: sure - I've been wondering about thinking in layers
00:17:48 <jle`> saves me the trouble of writing my own instances for my newtype MyComputation a = MC (s -> IO (a, s))
00:17:48 <gfixler> i.e. constantly thinking "oh, right, that's 2 layers in, so I need to ___"
00:18:06 <timothyh> hey, anyone good with SYB?
00:18:07 <jle`> ah yeah
00:18:13 <jle`> i don't ever actually program *to* monad transformers
00:18:19 <jle`> i don't think it's good practice to, really
00:18:29 <gfixler> Is there a 'simplest' monad transformer with which to get my feet wet?
00:18:31 <jle`> you should be programming to an interface --- ie, programming to things that are monads
00:18:34 <jle`> things that are functors
00:18:35 * hackagebot GLFW 0.5.2.4 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.2.4 (PaulLiu)
00:18:42 <jle`> things that can do IO, things that can do state, things that can error, etc.
00:18:43 <johnw> gfixler: start with ReaderT
00:18:51 <gfixler> johnw: ok
00:18:53 <timothyh> I have a GADT with some polymorphic subterms and i want to write a query to replace them with a different type that still satisfies the constraint
00:19:08 <gfixler> johnw: that's funny - I found Writer a lot easier to grok than Reader
00:19:14 <gfixler> I still have to think a lot about Reader
00:19:15 <jle`> monad transformers are just simple ways to build a type that can fulfil the interface that you want, without writing the instances yourself
00:19:21 <johnw> yeah, but you end up using  ReaderT a *lot*
00:19:41 <jle`> for example, you can say, "I want to work in a type that can is a Functor...is a Monad...can do arbitrary IO...and has state."
00:19:49 <jle`> "monad transformers" shouldn't really be what you are consciously thinking about
00:19:56 <timothyh> like assume something like (Measurement :: Length a => a -> T), and i want to convert that length to metres
00:20:08 <timothyh> any good way?
00:20:22 <jle`> you can just write a function polymorphic over things that are all monads, functors, can do arbitrary io, and have state
00:20:40 <jle`> and then eventually you have to chose the concrete type you want.  you can (1) write it yourself from scratch
00:20:50 <augur> gfixler: in principle, monad transformers ought to be simple
00:20:52 <jle`> and write the instances youreslf b yhand
00:21:02 <jle`> or (2) use monad transformers to give you the types "for free" with the instances for free
00:21:12 <jle`> sometimes i do (1), sometimes i do (2)
00:21:44 <gfixler> jle`: I've been feeling a sharp lack of monad transform information
00:22:01 <augur> gfixler: about reader tho, a good way to think of it is that there's a secret variable that you can always access
00:22:06 <gfixler> lots of monad tutorials, but I haven't found too much for transformers that isn't a bit over my head
00:22:19 <jle`> MaybeT is probably my favorite monad transformer in terms of clarity of implementation
00:22:31 <jle`> newtype MaybeT m a = MaybeT (m (Maybe a))
00:22:45 <gfixler> augur: the simplest I've seen reader presented is: http://www.mjoldfield.com/atelier/2014/08/monads-reader.html
00:22:48 <jle`> the monad instance is "obvious"
00:22:52 <jle`> if you sit down and think about it
00:23:08 <jle`> you want a (>>=) :: m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)
00:23:15 <gfixler> jle`: I've just started looking into Compose - this feels identical
00:23:19 <augur> gfixler: you know how JavaScript has "this"?
00:23:27 <jle`> which is a very sensible sort of function to think about, and one you might have written/used in real life
00:23:31 <gfixler> jle`: via: http://carlo-hamalainen.net/blog/2014/1/2/applicatives-compose-monads-do-not
00:23:35 <gfixler> augur: yes
00:23:42 <augur> gfixler: Reader is the "this" monad
00:23:47 <gfixler> augur: right :)
00:23:49 <augur> only its "ask" instead
00:23:54 <jle`> yeah, MaybeT m is more or less `m . Maybe`
00:24:08 <gfixler> augur: I've understood reader many times, but it always gets fuzzy again while I'm away from it
00:24:21 <jle`> i think a lot of the clarity for me when thinking about monad transformers comes when i just realize that monad transformers are nothing more than a fancy name for newtype wrappers that give us the instances we want
00:24:26 <mniip> :t ask
00:24:28 <lambdabot> MonadReader r m => m r
00:24:32 <mniip> that's just id...
00:24:37 <gfixler> augur: it just doesn't seem to want to stick - I kind of just want to start using it *a lot* so it gets jammed into my head finally
00:24:46 <jle`> for example, we can newtype-wrap Maybe to give us First, Last, etc., --- which gives us the Monoid instance that "we want"
00:25:03 <jle`> or we can newtype-wrap Int with Sum, Product, to give us the monoid instance that we want for a given situation
00:25:10 <gfixler> jle`: right
00:25:15 <jle`> ther'es nothing fundamental or category theoretic there...it's just typeclass hacking
00:25:23 <augur> gfixler: implement an LC with "this" :)
00:25:25 <adarqui> things get fuzzy for me too, but i havn't mastered typeclassopedia
00:25:25 <jle`> ugly typeclass hacks for us to have the write implements
00:25:32 <adarqui> which is what i need to do
00:25:42 <jle`> using newtype wrappers over Bool like And and Or to give us the right monoid instnace for a situation so we can use mconcat, etc.
00:25:43 <augur> gfixler: actually, if you implement an LC at all, you'll want to use Reader
00:25:53 <augur> gfixler: because "this" is a special case of a more general notion: variables!
00:26:02 <jle`> it's the same thing for monad transformers, and lots of monads too
00:26:13 <augur> gfixler: if you're implementing the LC, instead of "this" you'll have "the environment"
00:26:24 <jle`> for example, we have a handy combinator (<|>) :: Alternative f => f a -> f a -> f a
00:26:35 <jle`> we have a nice instance for Maybe, which is like "choice"
00:26:40 <jle`> > Just 2 <|> Just 0
00:26:42 <gfixler> augur: LC?
00:26:42 <lambdabot>  Just 2
00:26:43 <augur> gfixler: and you'll define something like    eval (Var x) = do { env <- ask ; lookup x env }   or something like that
00:26:47 <augur> gfixler: Lambda Calculus
00:26:52 <gfixler> augur: ah
00:26:59 <jle`> so we have an instance for Maybe to give us (<|>) :: Maybe a -> Maybe a -> Maybe a
00:27:02 <gfixler> augur: been going to an LC meetup for awhile now
00:27:11 <jle`> but what if we wanted (<|>) :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a) ?
00:27:18 <augur> gfixler: oh?
00:27:36 <gfixler> augur: re: "this": https://twitter.com/psygnisfive/status/617823274429480960
00:27:39 <gfixler> just saw that today
00:28:02 <augur> :)
00:28:17 <jle`> to do this, all we need to do is write a newtype wrapper over (IO (Maybe a)), like newtype MaybeIO a = MaybeIO (IO (Maybe a)), and then now we can write our Alternative instance with (<|>) on IO (Maybe a), and we can now use (<|>) on IO (Maybe a)'s
00:28:35 * hackagebot leksah-server 0.15.0.4 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.15.0.4 (HamishMackenzie)
00:28:37 * hackagebot leksah 0.15.0.6 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.0.6 (HamishMackenzie)
00:28:47 <gfixler> jle`: yeah, this is reminding me a lot of that Compose link I sent
00:28:47 <jle`> there's nothing really super magical going on, it's just using newtype wrappers to give us instances that we want for typeclasses like Alternative, Monad, etc.
00:29:13 <jle`> yeah, and that's really what "monad transformers" are, except you can't compose "in general", you have to write specific (. m) compositions
00:29:34 <jle`> MaybeT = (. Maybe), etc.
00:29:41 <gfixler> jle`: yeah, the title of the link is "Applicatives compose, monads do not" :)
00:30:03 <jle`> i think seeing them as just newtype wrappers to give instances with the behavior that you want is a nice way t understnad what something does
00:30:04 <gfixler> jle`: even that was confusing me a bit today, though
00:30:14 <gfixler> data Compose f g x = Compose (f (g x))
00:30:27 <gfixler> I forgot the outer ()'s, and got f -> g x
00:30:30 <gfixler> in the type
00:30:34 <gfixler> not sure how/why
00:31:01 <jle`> heh yeah, it's nice to keep track of those :)
00:31:16 <gfixler> so this nesting of types isn't fully in my brain yet
00:31:43 <jle`> you don't really have to think of it as nesting of types, i think
00:31:45 <gfixler> I mean, I get [Maybe a], and Maybe (Sum Int)
00:31:54 <jle`> just try to write a Monad instance for IO (Maybe a)
00:32:07 <gfixler> jle`: that's a good first attempt
00:32:11 <gfixler> I should go do that now
00:32:35 <gfixler> that's kind of what I've been looking for - been wondering what I should try to do first
00:32:46 <gfixler> so I don't jump into some deep end without knowing it
00:32:49 <jle`> yeah, and to me the interesting thing is that it's not really some magical transformation of Maybe, but it's just...a newtype over a monad instance for IO (Maybe a)
00:33:03 <jle`> like, "I have an IO (Maybe a), and i have an a -> IO (Maybe b).  How do I bind them?"
00:33:19 <jle`> well, you can bind them manually by writing a manual function to do the binding and the case matching and the unwrapping
00:33:23 <gfixler> jle`: perfect, gonna try that, bbl :)
00:33:36 <jle`> or you can just define a monad intance for IO (Maybe b), and then have (>>=) for that monad be exactly what you are looking for
00:33:52 <gfixler> hmm
00:34:19 <jle`> just like, you can manually use &&, sure,, or you can write a Monoid instance for Bool that does exactly what you're looking for
00:34:34 <jle`> so you can use <> and mempty and mappend instead of && and True
00:34:53 <jle`> so here you can use >>= and return instead of writing the ugly manual binds and (return . return) every time
00:35:26 <jle`> if you wanted an (a -> IO (Maybe a)), you'd have to write (return . return).  but you can also write a newtype wrapper that makes `return` be an a -> IO (Maybe a)
00:35:49 <gfixler> jle`: sounds like you're just describing why we have monoids and monads in the first place
00:36:14 <jle`> yeah, so the thing here is that we sometimes want more than one monoid instance for the same type
00:36:32 <jle`> like Sum and Product, or First and Last
00:36:50 <jle`> in this case, we want a Monad instance for Maybe, a Monad instance for IO...but we also want a Monad instance for `IO . Maybe`, that'd be nice too.
00:36:58 <gfixler> jle`: right
00:37:06 <jle`> so our haskell go-to strategy: use newtypes
00:39:15 <adarqui> gn folks
00:39:26 <jle`> night adarqui :)
00:40:07 <wizek> liste: I've created a minimal example of the error showing up for me: http://lpaste.net/4276901907638779904
00:40:21 <wizek> you can see the imports there too
00:41:20 <wizek> if I comment out line 20-21 and enable line 19 instead, it runs for me
00:42:00 <liste> seems your genetic algorithm library uses different version of random than you do
00:42:24 <wizek> liste: How cound I use the same version?
00:42:26 <liste> did you install it with cabal install --only-dependencies ??
00:42:43 * gfixler is trying to use noisy holes to flesh out his MaybeIO monad instance
00:42:59 <wizek> liste: I don't think so, but I did try --reinstall once when I tried to install a normal distribution random number generator.
00:43:49 <merijn> wizek: Are you using cabal to build your project?
00:44:41 <wizek> merijn: I run this in my shell: "ghc main.hs -package-db .cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d -O2 && ./main"
00:45:25 <liste> that doesn't tell ghc which version of random to use
00:45:33 <merijn> You should really use cabal to build your packages so it decides on a consistent set of dependencies
00:45:54 <wizek> How can I try that<
00:45:55 <wizek> ?
00:46:17 <merijn> Run "cabal init" in the folder with your source and follow the instructions :)
00:47:20 <sveri> Hi, is there a short tutorial on how to setup a new project with stack?
00:51:21 <gfixler> jle`: It's going to be: instance Monad MaybeIO where, right?
00:53:36 * hackagebot hset 1.0.1 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-1.0.1 (AlekseyUymanov)
00:54:10 <nshepperd> yay, nshepperd gained the power of... SomeNat!
00:54:20 <jle`> gfixler: mhm :)
00:55:05 * nshepperd feels somewhat godlike, with this new power over type-level nats
00:55:06 <liste> sveri "how to use" section in https://github.com/commercialhaskell/stack/#readme
00:56:14 <gfixler> jle`: return x = MaybeIO (return (return x)) ?
00:56:31 <jle`> mhm
00:57:01 <gfixler> jle`: now for bind
00:57:09 <wizek> wow, now it compiles and executes! Thanks liste and merijn!
00:57:12 <gfixler> (btw - I used holes to find that)
00:57:27 <jle`> holes have been pretty valuable for me too ><
00:57:47 <jle`> (btw i'd use do notation for defining bind)
00:58:06 <liste> wizek no problem (:
00:58:25 <sveri> liste: thx, I missed that -.-
00:58:40 <gfixler> jle`: I don't know how to pattern match on IO
00:58:46 <gfixler> jle`: is that why I should use do?
00:59:10 <jle`> you have to interact with IO using either (>>=) or do notation
00:59:20 <jle`> i'd use do notation in this case, the result is much cleaner, i think
00:59:26 <wizek> I am a bit confused as to why though. cabal forces all packages to use the same version of random? Why doesn't ghc do that by default? Isn't it most likely that the same versions are needed?
01:00:32 <gfixler> jle`: okay
01:02:36 <liste> wizek not necessarily, if two packages use different versions of a dependency only internally
01:03:32 <merijn> gfixler: You can't (well, you can, but shouldn't unless you really know what you're doing!) pattern match on IO
01:03:36 * hackagebot postgresql-query 1.4.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.4.0 (AlekseyUymanov)
01:04:03 <gfixler> merijn: don't tell me what I can't do! :)
01:04:35 <liste> wizek if you want only one version (at a time) of each package, use stackage
01:04:57 <wizek> liste: So in my .cabal file I need to specify the verison number if 2 or more of my dependencies export the same type, right? But if they use it only internally, I dont need to specify it, right?
01:05:31 <liste> wizek or have that type anywhere in their APIs
01:05:59 <liste> but you need to specify it anyway because you depend on some version of the api
01:06:23 <gfixler> this is tricky; <- is fighting because of mismatched monad types
01:06:48 <liste> if you use package X, specify the version you use
01:07:19 <liste> if you don't use it, don't add it to your .cabal file, even if package Y depends on it
01:07:51 <wizek> Yes, I think I understand, thanks!
01:07:55 <liste> (actually, specify the version bounds as PVP specifies)
01:08:21 <liste> @where PVP
01:08:21 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
01:08:26 <ken__> How can I ask small quesion about a code I found on the net? can I paste here?
01:08:36 <gfixler> why doesn't m >>= k = m work?
01:08:41 <liste> @where lpaste -- ken__
01:08:41 <lambdabot> http://lpaste.net/
01:08:54 <gfixler> not that it's the answer
01:09:00 <ken__> thanks
01:09:13 <liste> gfixler m >>= k isn't a pattern
01:09:14 <gfixler> I thought I'd be able to pass the monad through, as a first step
01:09:35 <liste> or gfixler actually it is if you're defining the Monad isntance
01:09:35 <gfixler> liste: inside an instance Monad etc?
01:09:39 <gfixler> yeah, i'm in one
01:09:51 <gfixler> instance Monad MaybeIO where
01:10:04 <gfixler> Couldn't match type `a' with `b'
01:10:05 <geekosaur> :t (>>=)
01:10:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:10:17 <geekosaur> note that the type changes as it goes through
01:10:22 <gfixler> only from a to b
01:10:27 <gfixler> but they can be the same
01:10:33 <geekosaur> the type changes to whatever k's type is
01:10:41 <gfixler> geekosaur: ah
01:10:44 <geekosaur> but you cannot force them to be the same
01:10:47 <gfixler> so k is the deciding vote here
01:10:50 <geekosaur> only the caller of (>>=) can
01:10:59 <geekosaur> by supplying you a k
01:11:16 <jle`> if i have an `m Int` and a `Int -> m Bool`, then the result better be `m Bool`, not `m Int` :)
01:11:42 <gfixler> jle`: yeah, I see it now
01:12:06 <ken__> Ok, here's the code I wonder
01:12:06 <gfixler> I was thinking that because I didn't know anything about k, the compiler wouldn't either - silly me
01:12:07 <ken__> https://gist.githubusercontent.com/kenokabe/96d2ddf5c63eead9a98d/raw/4e62b0bf63f74440ccbe1eb7e2affc9b3d44791b/haskell%20code
01:12:26 <ken__> I found the following code:
01:12:27 <ken__>  eTrans (EventKey (MouseButton LeftButton) Up _ _ ) n = n + 1
01:15:10 <ken__> I understand Haskell prohibit the destructive assignment
01:15:29 <merijn> ken__: There is no assignment at all
01:15:31 <gfixler> so I'm thinking I need a let, because if I do MaybeIO x >>= k = do etc, then everything in the do has to be MaybeIO b, so I can't just <- things out of the IO and Maybe monads in there
01:15:45 <ken__> merijn : why is that?
01:15:48 <gfixler> unless I'm missing something
01:16:01 <liste> ken__ n+1 is the result of the function
01:16:16 <liste> and n is an argument
01:16:17 <merijn> ken__: Assignment is about "memory locations" and storing values in there. In haskell you can just name values and you can't reason about their location
01:16:58 <merijn> gfixler: You need to first pattern match on the MaybeIO which gives you an "IO (Maybe a)" and then you can use >>= and friends on first IO and then Maybe
01:17:22 <ken__> liste merin is this Recursive Function??
01:17:41 <merijn> No, why?
01:17:47 <gfixler> merijn: well, I have MaybeIO x >>= k, so that's matching the MaybeIO bit and x :: IO (Maybe a)
01:17:47 <merijn> recursive functions call themselves
01:17:53 <merijn> eTrans just calls "n + 1"
01:18:09 <merijn> gfixler: That example doesn't parse for me
01:18:12 <ken__> eTrans as a function name?
01:18:21 <liste> ken__ yes
01:18:28 <liste> and to arguments
01:18:35 <liste> two*
01:18:47 <merijn> This sort of code is the reason I've started using type signatures even for local declarations
01:18:50 <geekosaur> eTrans is defined as a function. that function is passed to a function called play; there's no detail in your gist as to what it does with it
01:19:29 <geekosaur> also note that eTrans actually has an implicit case statement, because there is another definition below that one (for when the first parameter doesn't match the pattern in the first definition)
01:20:40 <ken__> thank you geekosaur
01:20:54 <ken__> thank you liste merijn
01:21:09 <mjrosenb> Are there hooks in cabal for generating code?
01:21:11 <ken__> I will investigate, and maybe asking later..
01:21:37 <merijn> mjrosenb: There's hooks, not specifically for generating code, but there's no reason you can't use them for that
01:21:52 <jle`> gfixler: your MaybeIO takes an IO (Maybe a), so you can build up the IO (Maybe a) using do/>>= for IO
01:22:04 <jle`> (MaybeIO x) >>= f = MaybeIO $ do ...
01:22:08 <jle`> and that do block is IO
01:22:15 <merijn> mjrosenb: I use c2hsc to generate code from a hook here: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
01:22:28 <jle`> the only thing is at the end it has to be IO (Maybe a)
01:23:45 <gfixler> jle`: ah, I see
01:24:10 <gfixler> jle`: all of these type idioms don't come naturally to me at all, even 2 years in
01:24:23 <gfixler> I just don't think this way - it's always an uphill climb
01:25:10 <jle`> no shame :)
01:25:55 <liste> the only way to get higher is to climb uphill
01:26:43 <liste> (unless there's a vehicle involved)
01:27:48 <mjrosenb> merijn: neat-o.
01:28:16 <mjrosenb> I'm guessing Setup.hs won't be auto-generated from the .cabal file if it already exists?
01:30:20 <merijn> mjrosenb: No, Setup.hs replaces cabal's behaviour when using "Build-Type: Custom"
01:33:50 <lamefun> Why don't data types create their own namespace?
01:34:03 <lamefun> Like in C++ or C#.
01:34:41 <dramforever> I guess it's not designed as so in the beginning
01:34:59 <Geraldus> hi friends!
01:35:11 <dramforever> maybe they were trying to avoid Bool.True Bool.False, Maybe.Nothing ... everywhere?
01:35:22 * dramforever is hi-ed by Geraldus
01:35:24 <merijn> lamefun: Because then it becomes hard (impossible?) to infer things?
01:35:44 <ken__> so, allow me to back to the code I found
01:35:45 <ken__> https://gist.githubusercontent.com/kenokabe/96d2ddf5c63eead9a98d/raw/4e62b0bf63f74440ccbe1eb7e2affc9b3d44791b/haskell%20code
01:35:50 <merijn> lamefun: Suppose two types have the same constructor named Foo. Now I see "Foo True" written in source, how do I infer the type of that expression?
01:35:51 <dramforever> oh maybe something like types
01:35:52 <ken__> is this code efficient ?
01:36:03 <ken__> or any serious problem included??
01:36:10 <dramforever> merijn: you can't, it's an ambigous reference to Foo
01:36:50 <merijn> dramforever: That was my point...
01:37:03 <lamefun> merijn: you write Type1::Foo True?
01:37:16 <dramforever> merijn: data types create new namespaces
01:37:22 <dramforever> lamefun: maybe Type1.Foo
01:37:30 <merijn> lamefun: That becomes cumbersome FAST
01:37:40 <dramforever> merijn: nah
01:37:44 <merijn> lamefun: What if different modules specify the same Type name?
01:38:01 <merijn> Anyway, if you want this it's not so hard to just wrap it in a module, imo
01:38:10 <dramforever> hey how about nested modules? that's much easier :P
01:38:12 <merijn> I would rather avoid having to write "Maybe::Just" everywhere
01:38:31 <liste> ken__ it looks good
01:38:41 <dramforever> merijn: I guess you could import Maybe
01:38:51 <dramforever> oh maybe Prelude could re-export it
01:38:57 <ken__> liste thank you
01:39:33 <merijn> dramforever: But then you still have the same problems you have now...
01:39:33 <dramforever> ken__: wow you actually managed to...write like that :)
01:39:41 <merijn> I would support nested modules, actually.
01:39:47 <dramforever> merijn: haha
01:40:17 <dramforever> nested modules is a bit easier to manage if you have a number of small but isolated modules
01:40:19 <merijn> I've seen racket with nested modules and the ability to have modules export different things at different phases (i.e. different export list during testing) seemed nice
01:40:34 <ken__> dramforever nah, I found the sample code, do you think it sophisticated?
01:40:46 * dramforever mumbles something about CPP
01:40:53 <dramforever> ken__: no it's....very elegant
01:41:08 <dramforever> it took me a while to realize that this is the whole program :)
01:41:18 <liste> the magic of gloss
01:41:26 <dramforever> lol
01:41:33 * dramforever gotta learn gloss
01:42:07 <ken__> dramforever do you think this code method can be applied for complicated UI?
01:42:17 <ken__> like facebook React
01:42:33 <dramforever> yeah that's also how I like to do graphics
01:42:34 <ken__> I found this code is not Functional Reactive Programming, so I wonder
01:42:43 <dramforever> gloss isn't very frp
01:43:00 <liste> ken__ not very complicated, it's better for pretty visualizations with not very complex interactions
01:43:13 <liste> simple games, also
01:43:43 <dramforever> liste: interesting, because I don't really see any problem w.r.t complexed stuff
01:43:44 <ken__> liste thank you
01:44:13 <liste> well, complex UI:s usually have widgets
01:44:28 <dramforever> and?
01:46:00 <ken__>  liste dramfoever excuse my lack of knowledge, but I wonder how the code deal state without FRP
01:46:15 <dramforever> ken__: dunno
01:46:19 <ken__> does this pass event itself to the function? as an argument
01:46:28 <liste> you'd have to reinvent them. but you're right, I don't really see why gloss wouldn't scale
01:46:32 <dramforever> I was just talking about generic stuff
01:46:43 <dramforever> liste: oh so gloss isn't really complete
01:47:00 <dramforever> okay I think I get it
01:47:45 <liste> ken__ the (EventKey...) stuff is the event
01:47:49 <liste> that's passed to eTrans
01:48:20 <ken__> I see thanks liste
01:48:26 * dramforever wonders if Automaton could be used with gloss
01:48:59 <liste> dramforever Automaton?
01:49:19 <dramforever> the arrow
01:50:23 <dramforever> liste: simplified: newtype Automaton b c = b -> (c, Automaton b c)
01:50:38 <jle`> yeah, it's pretty straightforward actually
01:50:42 * liste is looking it up Haddocsk
01:50:51 <jle`> if you use the Auto as the state parameter
01:50:52 <dramforever> looks like Automaton Event Picture will be able to make it
01:51:20 <dramforever> jle`: okay that makes it more frp-like :P
01:51:42 <jle`> yeah, or Automaton (Either Event Float) Picture
01:51:46 <dramforever> I'm not wondering about the implemention, I'm wondering about how well it works
01:51:58 <ken__> liste, if you pass event or callback to some function, is there any danger for stack size overflow?
01:52:20 <dramforever> wow stackage is *perfect*, I finally get gloss installed
01:52:22 <jle`> yeah, you can specify your entire peogram as an Auto, using some library that gives you tools to write program logic compositionally using that type
01:52:22 <ken__> I see this is somewhat recursive structure so
01:52:27 <jle`> and then just plug it into gloss :)
01:52:48 <dramforever> ken__: I don't see much of a recursive structure
01:53:01 <ken__> ok dramforever
01:53:41 <bob_twinkles> is there a clean way to get both the left and right side of a sequence?
01:54:06 <dramforever> oh sure if you don't eval the state and build up thunks you get stack overflow
01:54:20 <merijn> bob_twinkles: Yes, Data.Sequence :)
01:54:24 <lamefun> "<merijn> lamefun: That becomes cumbersome FAST" - at least I can rename the type "eg. type T = MyType" and use its functions as "T.abc or T.thinkTruth" instead of "myTypeAbc or myTypeThinkTruth".
01:54:45 <bob_twinkles> merijn: I may be blind as a bat, but nothing is jumping out at me =P
01:54:58 <dramforever> merijn: I think bob_twinkles is talking about viewl and viewr being too cubersome
01:55:25 <dramforever> bob_twinkles: oh so are you using something from Data.Sequence or just [] lista
01:55:27 <dramforever> *lists
01:55:45 <merijn> bob_twinkles: viewl and viewr
01:55:53 <bob_twinkles> pretty much yeah, it seems like there should be a way to handle them more symetricly
01:56:10 <ken__> dramforever and do you observe the code eval the state properly??
01:56:19 <ken__> so no danger for stack overflow?
01:56:28 <dramforever> looks like it does to me
01:56:29 <merijn> Oh, if viewl/viewr is too cumbersome, look into ViewPatterns
01:57:00 * dramforever wonders why => view patterns aren't implemented
01:57:46 <merijn> dramforever: Sentence doesn't parse
01:58:12 <dramforever> merijn: oh right
01:58:22 <dramforever> (f => x) desugars to (f -> Just x)
01:58:56 <ken__> what is the _ in this code??
01:59:17 <ken__> https://gist.githubusercontent.com/kenokabe/96d2ddf5c63eead9a98d/raw/4e62b0bf63f74440ccbe1eb7e2affc9b3d44791b/haskell%20code
01:59:17 <merijn> ken__: Wildcard pattern
01:59:21 <ken__> oh
01:59:28 <merijn> ken__: i.e. "I don't care about the value of this argument"
01:59:52 <ken__> so what 
01:59:54 <ken__>   eTrans _ n = n
01:59:59 <ken__> does this do ??
02:00:13 <merijn> ken__: Takes two arguments, ignores the first and returns the second
02:00:32 <ken__> oh I see thanks merijn
02:01:46 <dramforever> rather simple question, but when I installed a package I specified --haddock-all, where did it go?
02:01:56 <dramforever> s/,/./
02:01:58 <ken__> so merijn do you also think this code has no danger for stack-overflow for a long run
02:03:06 <MarcelineVQ> depends if it runs in constant space, idk how to check that, but that's the term to look for
02:16:42 <raulfpl> I'm having some basic problems with Parsec. Can someone tell me why the last funtion in this code fails? http://lpaste.net/3892844222633476096
02:17:51 <merijn> raulfpl: parsec doesn't backtrack
02:17:56 <merijn> raulfpl: Not by default, anyway
02:18:14 <dramforever> raulfpl: wrap FieldAccess <$> ... <*> ... in try (...)
02:18:22 <ttt_fff> what do I need to learn in order to do haskell auth via the google-login ?
02:18:29 <ttt_fff> i.e. I wnat to use people'sgmail address as the authentication
02:18:33 <merijn> So it will ALWAYS try to parse "baseTerm followed by dot and identifier" and by the time it fails to parse a dot the baseterm is already consumed
02:18:36 <dramforever> oh merijn already mentioned that
02:18:38 <ttt_fff> what do I need to learn on th ehakell side to make this happen
02:19:51 <dramforever> ?hackage google-oauth2
02:19:51 <lambdabot> http://hackage.haskell.org/package/google-oauth2
02:19:55 * dramforever found ^
02:20:09 <dramforever> ttt_fff: is this what you are talking about?
02:20:37 <ttt_fff> dramforever: I think so; let me look into it
02:21:12 <raulfpl> thanks. now it works
02:21:37 <merijn> raulfpl: See also this post: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
02:22:21 <dramforever> ttt_fff: aww it looks weird...
02:22:48 <dramforever> I think you need lower-level steps, otherwise it doesn't look suitable
02:24:22 <ttt_fff> dramforever: hmm, I'm looking at the example
02:24:30 <ttt_fff> what are these 'lower-level' steps I need ?
02:24:43 <dramforever> ttt_fff: bottom of the haddock page
02:24:49 <dramforever> it's the section title
02:27:53 <merijn> hmmm, is let polymorphism redundant if you have explicit type arguments in your functions?
02:28:09 <merijn> i.e. explicit forall'ed type variables instead of implicit?
02:28:23 <Bazuul> !list
02:28:23 <monochrom> Bazuul: http://hackage.haskell.org/packages/
02:33:17 <merijn> oh, nvm, TaPL actually suggest doing exactly that to avoid needless type checking
02:33:40 * hackagebot emacs-keys 0.0.2.0 - library to parse emacs style keybinding into the modifiers and the chars  http://hackage.haskell.org/package/emacs-keys-0.0.2.0 (cocreature)
02:36:10 <tdammers> morning all
02:36:37 <mjrosenb> Is there a function like isPrefixOf, but rather than String -> String -> Bool, does String -> String -> Maybe String, where it returns Just the suffix, or Nothing, if it isn't a prefix?
02:36:44 <tdammers> I've been playing around with an approach to haskell preprocessing where the meta-language is also haskell, but otherwise similar to CPP
02:37:56 <tdammers> wrote a little proof-of-concept even, but I'm wondering if this is something others have been experimenting with
02:37:58 <dramforever> oh like template haskell but more textual?
02:38:01 <tdammers> yes
02:38:53 <tdammers> what I have right now is a tool that takes "hspp" source code, parses out the meta-bits, and generates a Haskell source file which, when compiled and run, will print the actual haskell source on stdout
02:39:00 <merijn> What's the advantage over TH?
02:39:12 <tdammers> it's all string-based
02:39:22 <tdammers> that's both an advantage and a downside
02:39:32 <tdammers> but it's not meant as a replacement for TH, but for CPP
02:39:52 <merijn> What do you mean by "the meta-language is also haskell", then?
02:40:19 <tdammers> the meta-language is Haskell, rather than CPP's minilanguage
02:40:48 <tdammers> for example, you can write something like this:
02:40:51 <merijn> tdammers: Have you got an example source file?
02:41:09 <tdammers> {@ name @} :: String; {@ name @} = "Variable: {@ name @}"
02:41:15 <tdammers> hold on
02:41:57 <dramforever> wow I guess you shouldn't have do that inside strings
02:41:58 <tdammers> http://lpaste.net/135989
02:42:03 <dramforever> *done
02:42:24 <tdammers> the preprocessor doesn't even care that they're string literals
02:42:35 <tdammers> it's all completely stringly
02:42:42 <dramforever> okay so it's a generic template language?
02:42:48 <tdammers> pretty much, yes
02:43:10 <merijn> Ok, the more I see, the more it seems just a strictly worse TH
02:43:30 <tdammers> again, it's not supposed to replace TH
02:43:33 <dramforever> the more I see, the more it seems just a hs template language
02:43:33 * mjrosenb has wanted something almost like this, but completely different.
02:43:41 <tdammers> hehe
02:43:55 <tdammers> and yes, it's just haskell used as a template language
02:44:01 <merijn> tdammers: No, I'm not expecting it to replace TH
02:44:13 <merijn> tdammers: I'm saying "every possible usecase I can imagine seems better served by TH"
02:44:14 <dramforever> why call it hspp....
02:44:27 * mjrosenb wants something like
02:44:33 <merijn> dramforever: to be fair, my own CPP reimplementation for haskell also got hspp as name :p
02:44:37 <merijn> I never finished it, though
02:44:44 <dramforever> ha
02:44:46 <tdammers> tee hee
02:44:57 <dramforever> merijn: I guess everyone has written a program called test
02:45:02 <dramforever> but not the real test
02:45:17 <merijn> mjrosenb: Have you looked at TH?
02:45:21 <tdammers> merijn: does every possible use case include the ones that people use CPP for?
02:45:27 <mjrosenb> buildDate :: String; buildDate = compileIO (System.Cmd.system "date")
02:45:38 <merijn> tdammers: No, but I don't think this is well suited to what people use CPP for either
02:45:48 <merijn> tdammers: I would prefer CPP over this, I think
02:45:59 <merijn> mjrosenb: Right, so basically trivial TH?
02:46:07 <mjrosenb> where it will take more-or-less arbitrary IO-ful haskell code, and execute it at compile time, storing the value as a non-IO value
02:46:10 <tdammers> merijn: I'm curious as to why
02:46:17 <merijn> mjrosenb: Like, REALLY trivial TH :)
02:46:19 <dramforever> mjrosenb: well th can do that
02:46:26 <dramforever> +1 really trivial
02:46:31 <mjrosenb> merijn: I read a couple of TH tutorials, none of them mentioned IO c.c
02:46:37 <merijn> mjrosenb: TH is MonadIO
02:46:45 <dramforever> merijn: Q is MonadIO
02:46:55 <mjrosenb> that would have been very useful information.
02:47:01 <dramforever> mjrosenb: ^ meant to address you
02:47:07 <merijn> mjrosenb: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#v:runIO
02:47:21 <dramforever> lol always read instance list
02:47:52 <tdammers> anyway, I've just been reading the recent discussion on the mailing list about how CPP is awful but cannot be removed completely
02:47:52 <merijn> mjrosenb: No ordering guarantee on which order TH splices are run, but for something like date it should just work
02:48:14 <mjrosenb> I'll have to poke around a bit with this new knowledge.
02:48:24 <merijn> tdammers: We'd be better of defining a stripped down CPP for haskell
02:48:40 * hackagebot b9 0.5.8 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.8 (SvenHeyll)
02:48:41 <merijn> tdammers: That major problem is that CPP tokenization is absed on C tokenization which doesn't work for haskell
02:48:47 <merijn> tdammers: Which is why all the CPP tools are so brittle
02:48:51 <tdammers> merijn: yes, I know
02:49:08 <merijn> If we define a haskell PP that uses haskell tokenization than CPP restricted to conditional compilation isn't that bad
02:49:47 <tdammers> but if we do that, why not use haskell as the meta language instead of a stripped-down version of an ad-hoc minilanguage from the 1970s?
02:49:49 <merijn> tdammers: And "#ifdef FOO\n source here\n#else\n other source#endif" seems easier than having to do "putStr "my source here""
02:50:03 <tdammers> you don't have to putStr
02:50:21 <merijn> tdammers: Do you have an example of conditional compilation using your scheme?
02:50:36 * dramforever is thinking of...PHP!
02:50:48 <tdammers> I haven't written anything to support environment variables, but I don't see how that would be problematic
02:51:01 <dramforever> pretty haskellish, pal
02:51:01 <merijn> tdammers: No, it's the conditional I care about
02:51:07 <merijn> Also, CPP doesn't use environment variables
02:51:36 <tdammers> "environment", then... you pass variables to CPP through command line args, yeah
02:51:55 <tdammers> I could have the compiled generator accept command-line args, sure
02:52:06 <tdammers> the conditional is already possible as-is
02:52:26 <merijn> tdammers: I wanna see what it looks like :)
02:52:38 <tdammers> hold on
02:53:57 <lpaste> tdammers pasted “conditional compilation” at http://lpaste.net/135990
02:54:22 <tdammers> the "@@@" token to delimit literal from meta is a completely arbitrary choice btw
02:54:41 <dramforever> okay that looks even more like php now
02:54:49 <dramforever> no insults :)
02:54:52 <tdammers> yeah it does, doesn't it
02:54:59 <tdammers> <?haskell ?>
02:55:03 <merijn> tdammers: That seems really cumbersome syntax compared to the current CPP
02:55:41 <merijn> tdammers: Conditional compilation probably covers 70-80% of the uses of CPP in haskell code, if not more, so I think anything that makes it MORE of a hassle is doomed
02:55:43 <lpaste> tdammers annotated “conditional compilation” with “conditional compilation (annotation)” at http://lpaste.net/135990#a135991
02:55:52 <tdammers> this would probably work too
02:56:14 <dramforever> tdammers: #if condition works even better!
02:56:22 <lpaste> tdammers annotated “conditional compilation” with “conditional compilation (annotation) (annotation)” at http://lpaste.net/135990#a135992
02:56:33 <dramforever> heh
02:56:36 <tdammers> I could probably even make this work without much trouble
02:57:00 <merijn> tdammers: But then are we basically back at CPP with slightly different and unfamiliar syntax?
02:57:36 <tdammers> the "when" there is "when" from Control.Monad
02:57:48 <tdammers> nothing special about it, it's the same Haskell syntax you'd use in GHCI
03:02:46 <mjrosenb> eww, unoriented delimiters
03:03:14 <lpaste> saep pasted “Top level if-then-else as an alternative to CPP directives” at http://lpaste.net/135993
03:03:20 <dramforever> aww aww this triggers my OCD
03:03:26 <dramforever> https://www.reddit.com/r/haskell/comments/3c9x9h/question_finding_the_source_of_incomplete_record/
03:03:33 <dramforever> oops sorry..
03:08:46 <mjrosenb> saep: ooh, could you also have top-level case statements?
03:09:37 <saep> Why not? It was just a quick idea that popped up in my head. 
03:09:41 <mjrosenb> also, if you want to have something shaped roughly like a cpp drop in, that will totally break the parser.
03:12:09 <saep> I don't see a lot of gain over CPP though. It is implemented, it works and it is equally short to write..
03:19:24 <tdammers> CPP is brittle and introduces another language into the chain, is all
03:20:21 <tdammers> IMO it makes sense to use Haskell as the meta-language for a dumb textual preprocessor for Haskell
03:20:33 <tdammers> we're already using it as the meta-language for TH
03:22:17 <bennofs> tdammers: but TH sucks
03:22:34 <tdammers> bennofs: CPP sucks more!
03:23:09 <tdammers> plus I think that Haskell being the meta-language is what sucks about TH
03:23:16 <tdammers> s/is/is not/
03:24:34 <bennofs> I think it is, because it makes preprocessing dependent on running haskell code which may itself have dependencies ... (loading code at compile time is bad IMO)
03:25:13 <tdammers> which is why most people prefer to avoid TH if possible
03:25:52 <tdammers> but I believe if you want something comparably powerful, you won't be able to avoid compile-time code loading and dependencies
03:27:45 <tdammers> anyway, I just coded this up for fun yesterday, just checking if anyone else has gone in that direction and whether it's worth pursuing
03:33:42 * hackagebot resolve-trivial-conflicts 0.3 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.3 (EyalLotem)
03:34:28 <lamefun> Is stack a future replacement for Cabal?
03:38:42 * hackagebot resolve-trivial-conflicts 0.3.0.1 - Remove trivial conflict markers in a git repository  http://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.0.1 (EyalLotem)
03:42:43 <frerich> I bet there's some paper which shows that software releases are often done in a 'gallopping' style in which releases always come in pairs: the initial commit and then shortly afterwards a fixup release.
03:42:56 <frerich> s/commit/release/
03:44:19 <ttt_fff> do people here mostly do top down or botton up design? back in lisp days, all the hype was 'do bottom up; build the LANGUAGE up toward your domain; i.e. DSLs via Macros" .... however, with Haskell + GHC, I'm starting to find that it's more fun to do top down, then sprinkle "error "blah"" and "_" 's everywhere, have the computer bitch at me, and fix it up later
03:45:34 <arw> ttt_fff: depends on mood/problem set/time of day. usually, for anything larger, its kind of "pinching it from both sides"
03:45:57 <ttt_fff> hmm
03:46:13 <ttt_fff> I get the impression, that via using >> error "blah" ... I can "type check" how all the modules fit together before doing any impl
03:46:29 <ttt_fff> whereas ith bottom up, I often get into the issue taht I write a module, and then realize "OH SHIT, this DOES NOT FIT WITH THE REST"
03:47:21 <arw> ttt_fff: yes. but just as often, I know I will need some special sauce in some part of my application to do something essential.
03:47:41 <arw> ttt_fff: then its easier to first implement the special sauce module and design the rest around it.
03:50:33 <arw> ttt_fff: of course, for the boring "I already know how its done, I just need to type it in"-case, top-down is simpler, also because as soon as you have the top part, you can delegate the "details" to some available minion :>
03:50:52 <ttt_fff> oh, this is not the "I know how it's done case"
03:50:57 <ttt_fff> this is the "this is huge, and I haveno fucking clue"
03:51:05 <ttt_fff> which is where I think top-down works better
03:51:13 <ttt_fff> since it allows you to plan out how modules and parts talk to each other
03:51:25 <saep> You usually go up and down and up and down and up and down and up and down. :D
03:51:56 <ttt_fff> only 8 times? that's pretty quick
03:52:10 <saep> s/./...
03:52:24 <arw> yep. because as soon as you know how modules will talk, you implement some module and find out that it won't really work. so you have to redo the top part again.
03:52:43 <arw> thats what I meant by "pinching it from both sides"
03:53:24 <arw> of course this becomes crazy when there is more than one person working at things.
03:59:42 <ttt_fff> so we all agree that "mistakes will be made when designing a large systeM', the question is -- is it cheaper to (1) design on paper, (2) design top-down by ghc, or (3) design botton up in ghc, or (4) do arw's pinch method
04:00:09 <merijn> ttt_fff: FYI, with GHC 7.10 you can use typed holes instead of "error "blah"" to fit things together
04:00:24 <merijn> ttt_fff: Because 7.10 has -fdefer-typed-holes, which lets you run code with holes in it
04:00:37 <ttt_fff> I don't ind "error blah" .... where "blah" involves __FILE__ and __LINE__ , so I know where to fix it
04:00:41 <merijn> The advantage over error is that you can have the compiler check at compile time that you didn't forget any holes
04:00:56 <ttt_fff> oh
04:00:59 <merijn> ttt_fff: Holes auto-insert file and line numbers too
04:01:02 <ttt_fff> as in I can turn off -fdeter-typed-holes ?
04:01:08 <ttt_fff> oh
04:01:22 <merijn> ttt_fff: -fdefer-types-holes is off by default, I only turn it on during testing
04:01:29 <merijn> And if it's off the holes are compile errors
04:01:33 <ttt_fff> I like this
04:01:34 <merijn> (with it on they turn into warnings
04:01:47 <merijn> And you can then use -fno-warn-typed-holes to silence the warnings
04:03:44 * hackagebot rest-gen 0.17.1.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.1.1 (AdamBergmark)
04:33:45 * hackagebot tar 0.4.2.0 - Reading, writing and manipulating ".tar" archive files.  http://hackage.haskell.org/package/tar-0.4.2.0 (DuncanCoutts)
04:33:47 * hackagebot htar 0.4.0.2 - Command-line tar archive utility.  http://hackage.haskell.org/package/htar-0.4.0.2 (DuncanCoutts)
04:35:08 <merijn> Does anyone know what the theoretical difficulties with ImpredicativeTypes is?
04:56:32 <chattered> What does the "<->" mean here in the Haskell grammar on right-sections https://www.haskell.org/onlinereport/exps.html#sect3.5 ?
04:58:03 <chattered> Oh nevermind. It just displays funny in w3m.
05:01:32 <rbocquet> merijn: i think you can't give principal types in system F to Rank-N types when (N > 2), so you don't have e.g. (|- u[x:=a] : ty) => (|- (\x. u) a : ty), as the "a"s in u[x:=a] may need different types
05:02:40 <merijn> rbocquet: How does that prevent principal types?
05:02:58 <merijn> That just means that "(\x.u) a" doesn't typecheck
05:03:55 <merijn> Actually, this example seems to just be let-polymorphism? So that's only a subset of impredicativity, no?
05:06:07 <merijn> The main problem I can see with Impredicativity would be, for example "Maybe (forall x . Eq x => x)" needing to effectively existentially quantify the typeclass there
05:06:37 <merijn> But I don't really understand why, for example "Maybe (forall x . Foo x)" or "Maybe (forall x . x -> x)" pose problems
05:07:06 <rbocquet> merijn: there should be a better description of the difficulties in http://gallium.inria.fr/~remy/work/mlf/icfp.pdf
05:08:06 <merijn> The abstract seems to suggest the main problem is inference?
05:08:25 <merijn> I'd happily sacrifice large parts of inference for impredicativity
05:09:59 <dramforever> merijn: "let" inference looks enough to me
05:10:35 <dramforever> oh never mind
05:10:44 <merijn> dramforever: Nowadays I annotate most (all?) where/let bindings with types too in my own code
05:11:45 <dramforever> merijn: I often annotate functions
05:12:01 <merijn> I took annotate global declarations like functions as a given
05:12:05 <merijn> *annotated
05:12:22 <hunteriam> What is existential quantification Merijn
05:13:10 <dramforever> like if you have data X = forall a. C a => X a
05:13:22 <dramforever> then you case X of X a -> ...
05:13:32 <merijn> dramforever: That's hardly a very descriptive explanation of the issue :)
05:13:41 <dramforever> ...
05:13:46 * dramforever messed it up...
05:13:46 * hackagebot codecov-haskell 0.4.0.2 - Codecov.io support for Haskell.  http://hackage.haskell.org/package/codecov-haskell-0.4.0.2 (killy971)
05:13:49 <merijn> hunteriam: Existential quantification lets you hide (part) of a type from the signature
05:14:08 * dramforever isn't good at explaining things
05:14:33 <merijn> hunteriam: So that you can express "this datatype holds a value of SOME type, but we don't know which"
05:14:59 <merijn> hunteriam: But there's only a limited number of uses for this, most of them involving elaborate hacky voodoo in the type system :p
05:23:30 <phaazon> ahah, CPS is so overwhelming :)
05:24:28 <phaazon> and that's funny how I my brain freezes in front of uncommon stuff that is actually pretty simple
05:24:34 <phaazon> like how to implement pure for ContT
05:25:05 <dramforever> phaazon: thinking them as functions taking callbacks helped me
05:26:11 <phaazon> yeah but I mean
05:26:18 <phaazon> I was trying to figure how to « store » a value
05:26:19 <phaazon> like
05:26:26 <phaazon> pure x = {- store x -}
05:26:29 <phaazon> which is wrong, of course
05:26:43 <phaazon> pure x = ContT $ ($ x)
05:26:45 <phaazon> :)
05:26:52 <dramforever> not quite
05:26:52 <phaazon> -$
05:27:06 <dramforever> you are storing x into a function
05:27:24 * dramforever mumbles something about contravariance
05:27:34 <phaazon> nope
05:27:38 <phaazon> it's covariant
05:28:01 <phaazon> that is the correct implementation
05:28:06 <phaazon> pure x = ContT ($ x)
05:28:10 <dramforever> (->) is contravariant in the first argument
05:28:17 <phaazon> yes
05:28:27 <merijn> :t ContT
05:28:28 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
05:28:37 <dramforever> so two contravariants makes a covariant
05:28:49 <merijn> :t ContT . ($'c')
05:28:50 <lambdabot> (Char -> (a -> m r) -> m r) -> ContT r m a
05:29:03 <merijn> :t ContT ($'c')
05:29:04 <lambdabot> ContT r m Char
05:29:12 <merijn> oh, right
05:29:16 <phaazon> :)
05:29:17 <merijn> brainfart
05:29:31 <dramforever> lol johnw told me to /query lamdabot before using
05:29:43 <dramforever> similar situation happened to me :)
05:30:12 <phaazon> I'm trying to design an abstraction over callbacks
05:30:18 <phaazon> for interfacing with reactive systems
05:30:27 <phaazon> and I fail to provide any kind of instances
05:30:30 <phaazon> like Functor or whatever
05:30:35 <phaazon> because I need IO everywhere :(
05:30:55 <phaazon> I'm stating something like
05:31:17 <phaazon> newtype Future a = Future { futureRef :: IORef [a -> IO ()] }
05:31:28 <phaazon> that is, my Future type is a handle to a list of callbacks
05:31:33 <phaazon> so that I can inject callbacks
05:31:50 <phaazon> but it's pretty opaque...
05:33:02 <phaazon> the good think is that I can just return a Future (Double,Double) for the mouse position by throwing the IORef into the callback
05:33:10 <phaazon> and inject callbacks using the Future (Double,Double)
05:33:17 <phaazon> s/think/thing
05:33:43 <merijn> phaazon: Do you ever remove callbacks from the list?
05:33:45 <dramforever> hmm...
05:34:07 <phaazon> merijn: nope
05:34:10 <phaazon> if I need
05:34:18 <phaazon> I'll just change my Future type
05:34:20 <phaazon> to something like
05:34:33 <dramforever> maybe want something like this? newtype Future a = Future { register :: (a -> IO ()) -> IO () }
05:34:34 <merijn> oh, nvm, "IO x" isn't a Monoid yet in 7.10
05:34:56 <phaazon> newtype Future a = Future { futureRef :: IORef [a -> IO ReleaseKey] }
05:35:01 <phaazon> or an IntMap
05:35:14 <phaazon> dramforever: sure
05:35:23 <nabokovian> curious, what do you use that type for? (Future a)
05:35:39 <phaazon> nabokovian: I have an example, wait for lpaste
05:35:40 <dramforever> newtype Future k a = Future { register :: (a -> IO ()) -> IO k, delete :: k -> IO () }
05:35:43 <phaazon> wait a sec
05:36:33 <phaazon> lpaste.net/2657212733216260096 nabokovian 
05:36:44 <phaazon> scroll down
05:37:10 <phaazon> it's a way to handle reaction (like in reactive and even-driven programming), but with first-class citizens
05:37:35 <bennofs> dramforever: why not newtype Future a = Future { register :: (a -> IO ()) -> IO (IO ()) } ?
05:37:43 <dramforever> ...
05:37:53 <merijn> bennofs++
05:38:54 <phaazon> then, something like this is possible:
05:38:56 <nabokovian> thanks for the example
05:38:56 <phaazon> fut <- foo
05:39:01 <phaazon> print `asSoonAs` fut
05:40:07 * dramforever is thinking about something really weird
05:40:18 <phaazon> dramforever: don't go naked please.
05:40:25 <dramforever> if we could serialize functions we could do a lot of interesting stuff!
05:40:34 <phaazon> dramforever: you can
05:40:38 <phaazon> well, you *can*
05:40:40 <merijn> dramforever: We already partially can
05:40:46 <dramforever> phaazon: ha!
05:40:53 <merijn> dramforever: Look at StaticPointers in recent GHC
05:41:03 <phaazon> yep
05:41:04 <merijn> They can even serialise some closures
05:41:05 <dramforever> merijn: oh yeah I'm partially aware of it
06:03:06 <merijn> Anyone know a reference on the topic of "record kinds"?
06:03:13 <cow_2001> http://learnyouahaskell.com/zippers
06:10:01 <ttt_fff> is there anything from Oberon that translates well to Haskell 
06:10:10 <ttt_fff> Oberon (as in Nick Wirth's work)
06:13:49 * hackagebot protocol-buffers 2.1.1 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.1.1 (k_bx)
06:18:49 * hackagebot haskell-awk 1.1.1 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.1.1 (gelisam)
06:37:30 <merijn> edwardk: ping?
06:39:44 <merijn> Or anyone else that knows bound, for that matter
06:48:04 <rbocquet> merijn: I know bound a bit
06:50:04 <merijn> rbocquet: I was going over https://www.fpcomplete.com/user/edwardk/bound#bird-and-paterson--part-1 and I don't understand the way the Exp datatype there works especially I don't understand "Lam (Exp (Maybe a))"?
06:50:13 <merijn> The link to the Bird & Patterson paper seems down :\
06:51:44 <rbocquet> the parameter of Exp is its variables, so Exp (Maybe a) can use one more variable than Exp a (the variable bound by the lambda)
06:53:14 <earthy> merijn: http://staff.city.ac.uk/~ross/papers/debruijn.ps.gz
06:53:44 <earthy> (which google will helpfully display to you, if so required)
06:54:42 <merijn> rbocquet: That's what I figured, but I don't think I understand how to subtitute then
06:56:14 <rbocquet> (>>=) :: Exp a -> ( a -> Exp b) -> Exp b is the substituion of all variables of an expression
06:56:53 <rbocquet> to define substituion for Lam, you need Exp (Maybe a) -> (a ->  Exp b) -> Exp (Maybe b)
06:59:02 <merijn> hmmm, I need to meditate on this
06:59:21 <rbocquet> this is (>>=) with MaybeT Exp
07:00:09 <__monty__> When ghc reports errors it uses fully qualified names, this is very precise but I'm finding it hard to read. Is there an option I can pass to use unqualified names?
07:03:31 <merijn> __monty__: It should use unqualified names unless things are indirectly imported and/or conflicting
07:03:43 <merijn> __monty__: Do you have an example error?
07:08:09 <__monty__> merijn: Here you go: http://lpaste.net/135996, I have no imports in this module. However, you're right, if I run ghc from the cli it uses unqualified names. I'm actually using syntastic with ghcmod but it's not supposed to give options to ghc by default, so why would it use fully qualified names?
07:08:33 <merijn> Am I grokking it right that the "Bird & Patterson, Part 2" trick is that it's basically doing codensity to speed up the binding?
07:09:06 <merijn> __monty__: I don't really use ghcmod, so I'm not sure?
07:10:46 <rbocquet> merijn: i thought codensity is more about representing a monad by its morphisms (or something like that). But i'm not sure
07:12:04 <merijn> rbocquet: codensity is basically CPSing the monad
07:12:10 <merijn> i.e. generalised DList
07:12:29 <pharpend> Hey everyone
07:12:35 <merijn> At least, that's my understanding of codensity :p
07:12:37 <pharpend> http://lpaste.net/135997 <-- I have this code
07:13:05 <pharpend> http://ix.io/jvR <-- getting this compiler error, which I can't figure out
07:13:32 <pharpend> I've tried wrapping the `shouldBe` expression with runIO, with pure, I can't seem to get the types lined up
07:13:42 <pharpend> (this is HSpec by the way)
07:13:51 * hackagebot bimap-server 0.1.0.0 - Two-column database server.  http://hackage.haskell.org/package/bimap-server-0.1.0.0 (DanielDiaz)
07:16:25 <pharpend> If you want to look at the library functions I'm testing, the entire tree can be found here: https://github.com/pharpend/comarkdown
07:16:38 <pharpend> (I haven't pushed the broken tests, for obvious reasons)
07:18:04 <heatsink> pharpend: It looks like parse calls undefined
07:18:35 <pharpend> heatsink: yes, but that won't cause a compile error
07:18:52 * hackagebot bimap-server 0.1.0.1 - Two-column database server.  http://hackage.haskell.org/package/bimap-server-0.1.0.1 (DanielDiaz)
07:18:54 <merijn> Which compile error?
07:18:59 <heatsink> pharpend: The errors you showed are not compile errors
07:19:07 <merijn> I only see a bunch of tests running and failing
07:19:29 <pharpend> so it compiles all of the sudden
07:19:38 <pharpend> i was getting compile errors before
07:19:40 <pharpend> heh
07:19:48 <pharpend> never mind, fixed the issue myself =p
07:20:14 * pharpend says that pretending to know how he fixed the issue
07:20:47 <pharpend> (I didn't read the errors on the last run, I piped them to the pastebin, which is why I thought they would be compile errors)
07:40:19 <pharpend> AHA!
07:40:28 <pharpend> I've come upon a bug in stack!
07:40:35 <pharpend> That's why I looked like an idiot before!
07:43:53 * hackagebot protocol-buffers 2.1.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.1.2 (k_bx)
07:43:55 * hackagebot protocol-buffers-descriptor 2.1.2 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.2 (k_bx)
07:43:57 * hackagebot hprotoc 2.1.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.1.2 (k_bx)
07:46:43 <pharpend> https://github.com/commercialhaskell/stack/issues/525 <-- world's weirdest bug
07:59:47 <heatsink> pharpend: Can you reproduce the behavior starting from a clean copy of the sources?
08:01:44 <pharpend> heatsink: I can reproduce the behavior, and I have the latest Git version of stack
08:02:06 <pharpend> I installed it yesterday, and it's still the latest version somehow
08:02:11 * pharpend is suspicious
08:06:50 <maia> hello folks
08:06:55 <maia> I'm trying to run this example https://github.com/thoughtbot/snap-api-tutorial
08:07:20 <maia> but I'm getting a maxbumps exceed error
08:07:27 <maia> when setting maxbumps to -1
08:07:36 <maia> cabal install never ends
08:10:16 <pharpend> maia: that's because there are circular deps
08:10:26 <pharpend> maia: I'm guessing that tutorial is pretty old
08:12:17 <maia> hummm
08:14:23 <bergmark> pharpend: why do you think it's circular deps?
08:15:12 <bergmark> maia: for some reason it's hard to find an install plan for you, cabal will finish but it can take a loong time sometimes
08:15:29 <bergmark> maia: starting in a clean sandbox usually helps, or using stack/stackage
08:16:15 <maia> oh well, I'm giving up; I'll try my luck with javascript
08:16:15 <maia> haskell is too hard
08:16:39 <maia> 3 days to make a algorithm, 2 days trying to make a simple rest api
08:17:03 <maia> thanks for the help guys, hope you the best of luck
08:17:39 <bergmark> i wonder why he asked for help when he didn't want it :-(
08:17:42 <pharpend> bergmark: bah! not circular deps, difficult-to-resolve deps!
08:18:35 <srhb> bergmark: They were probably expecting a one line fix. :)
08:19:18 <pharpend> bergmark: He is probably at that stage in his programming career where picking up new programming languages is really easy. Then, you happen upon Haskell, which isn't as easy to pick up, and then you give up because Haskell is too hard
08:19:35 <pharpend> bergmark: I gave up on Haskell many times before eventually deciding to actually learn it
08:19:53 <joehillen> pharpend: same here
08:20:43 <pharpend> I got to that annoying stage where I didn't know Haskell well enough to write it effectively, but I would get frustrated with other languages because they weren't Haskell (e.g. no currying, no reduction)
08:20:51 <pharpend> no sum types
08:20:55 <tdammers> haha... well, I can make a simpe REST API in half an hour in either Haskell or JavaScript, but the Haskell one won't fall on its face
08:21:10 * pharpend should probably learn what REST actually means
08:21:27 <pharpend> I've supposedly been writing RESTful applications for a couple of years
08:21:41 <joehillen> JSON over HTTP = REST
08:21:48 <pharpend> I have a feeling that it's one of those words like "framework" where nobody actually knows what it means
08:21:50 <Clint> no, REST has nothing to do with JSON
08:21:50 <tdammers> lesson 1: when people say "REST", they don't usually mean actual REST, but rather just "use HTTP and GET and POST and JSON to implement a web service"
08:22:06 <joehillen> Clint: tell that to every REST API in the universe
08:22:18 * Clint grumbles.
08:22:18 <pharpend> ooh a flame war
08:22:22 * pharpend grabs some popcorn
08:22:25 <tdammers> I'm with Clint though
08:22:58 <tdammers> actual REST is pretty much just "hey, did you notice that you can use HTTP to transport other things than HTML pages, images, javascript, stylesheets and CSS?"
08:23:21 <joehillen> I'm not starting a flame war, I know the original definition of REST doesn't involve JSON, but history has proven otherwise
08:23:22 <tdammers> well, that, plus actually using all the verbs that HTTP specifies and no browser implements
08:23:41 <tdammers> and fwiw, even modern real-world REST isn't limited to JSON really
08:23:42 <jackhill> I thought REST (in part) had to do with who was responsible for tracking state
08:24:21 <nrk-> Isn’t REST stateless?
08:24:43 <pharpend> nrk-: HTTP is supposed to be stateless, although there are ways around it, much like Haskell
08:24:52 <arw> a little... there is still authentication plus a session as state.
08:24:52 <tdammers> IMO the core idea is abandoning the RPC idea ("map procedure calls to HTTP request/response cycles, sending a request equals calling a procedure, sending a response equals returning from a procedure")
08:25:53 <tdammers> HTTP is stateless, and so is REST; if you want state, you have to pass some sort of identifier back and forth
08:26:43 <Peaker> tdammers: The RPC idea seems to me to be compatible with statelessness?
08:26:47 <arw> HTTP hasn't really been stateless since the invention of cookies.
08:27:18 <arw> (which is an identifier that is passed, but with the additional property of optional persistence)
08:27:27 <tdammers> arw: the underlying request/response paradigm is still fundamentally stateless on some level
08:28:00 <tdammers> arw: it's not like, say, a long-lived SSH connection where once you have established identity you can just keep working under the assumption that it remains valid
08:28:30 <tdammers> arw: you have to re-authenticate on every request, and sessions and cookies are kind of a way to make that more palatable
08:28:43 <nrk-> Cookies are client-side state. I don’t think that necessarily makes the protocol stateful
08:28:49 <tdammers> indeed
08:29:00 <tdammers> the HTTP standard as a whole, sure there's statefulness there
08:29:50 <tdammers> Peaker: yes, of course - the paradigm shift isn't really in making things stateless
08:29:58 <arw> I agree that HTTP can be used in a stateless way, as opposed to ssh. 
08:30:18 <tdammers> the paradigm shift from RPC to REST is that requests no longer represent procedure calls, but CRUD operations on "resources"
08:31:27 <Peaker> tdammers: isn't the latter a special case of the former?
08:32:22 <tdammers> Peaker: and vv.
08:32:30 <tdammers> in a way
08:32:31 <nrk-> You all just reminded me I might have to learn SOAP for work. I hear it’s terrible
08:32:52 <tdammers> you can express procedure calls as CRUD operations on job queues
08:33:25 <tdammers> i.e., first you PUT a request to call a certain procedure, and you receive a response that tells you the identifier for your request
08:33:44 <tdammers> and then you can issue GET requests to check on your pending procedure call
08:33:50 <tdammers> something like that
08:34:12 <tdammers> and of course if the procedure finishes immediately, the response to your PUT will give you the result immediately
08:34:43 <arw> Peaker: RPC just uses arbitrary object handles with arbitrary operations. REST simplifies this to "a handle is the objects URL" and "operations are the basic verbs".
08:35:41 <arw> Peaker: which doesn't mean that REST can do less, its just that for the basic case its far simpler since the standard CRUD stuff always is the same.
08:36:16 <delcici> Would it be fair to say that REST is simply a set of somewhat-well-defined semantics that more or less could be done as RPC?
08:36:41 <tdammers> anything that could be done as RPC could also be done as REST, one way or another
08:37:45 <delcici> Then the biggest "win" of REST is that of naming w/respect to resources and operations?
08:38:05 <arw> plus some nice ideas like actually using all those header fields like accepted content types instead of 20 layers of xml namespace hell.
08:40:38 <tdammers> not really
08:41:31 <tdammers> the biggest win, IMO, is realizing that 99% of the API stuff we do on the web maps perfectly onto HTTP itself and doesn't benefit from the OOP method approach
08:42:16 <tdammers> there's also the advantage that REST is naturally more honest wrt HTTP semantics, e.g., a RESTful GET request behaves like an HTTP GET request is supposed to
08:42:29 <tdammers> you can cache it, you can load-balance it, etc.
08:42:42 <TheKing444> Google is trying to make bidireftional http by the way.
08:43:15 <tdammers> but with RPC, the semantics of the procedure call aren't reflected in anything vanilla HTTP tools recognize
08:43:22 <cite-reader> Soon all protocols will be HTTP. And we will have application protocols inside our application protocols.
08:43:43 <arw> cite-reader: more like "for the last 10 years"?
08:43:51 <tdammers> cite-reader: that's where things were heading with SOAP
08:44:02 <tdammers> cite-reader: REST is kind of a move in the opposite direction
08:44:19 <arw> cite-reader: i've seen vendors wrapping anything in http and claiming its nicer that way since you only need to open port 80 in your firewall...
08:44:39 <tdammers> they aren't even wrong, from a pragmatic point of view
08:45:55 <augur> edwardk: ping
08:46:00 <edwardk> pong
08:46:33 <augur> edwardk: i just listened to your ep of Haskell Cast :)
08:47:52 <augur> edwardk: you've done some stuff with parsing right?
08:48:07 <edwardk> here and there
08:48:18 <hodapp> don't be modest :P
08:48:39 <augur> can i write up some thoughts on chart parsers and get your thoughts?
08:48:41 <marchelzo_> "here and there" - author of trifecta
08:48:45 <bernalex> edwardk: you dabble in haskell, right?
08:48:54 <augur> well let me rephrase :p
08:49:03 <augur> edwardk: you've done some stuff with natural language parsing right?
08:49:19 <edwardk> sure. have you read the bernardy and claessen paper? http://www.cse.chalmers.se/~bernardy/PP.pdf
08:49:55 <edwardk> ^- that updates a valiant parser (a CYK variant) to use efficient sparse matrix routines
08:50:10 <augur> i think i've probably see it, yeah
08:50:14 <TheKing444> \pong
08:50:25 <augur> the approach im looking at is rather different, but
08:50:36 <edwardk> marchelzo_: trifecta is pretty basic honestly. the main thing it does is pretty error messages, beyond that it is comparatively naive.
08:51:11 <edwardk> augur: anyways sure, feel free to send me whatever you've got written up and i'll fire back some feedback
08:51:58 <augur> edwardk: there's a way to use chart parsing over sets (rather than lists) to generate ASTs from semantics, and it turns out (afaict) that you can abstract away from the set/list choice and design a more generic parsing algorithm
08:52:06 * geekosaur will note that edwardk has his fingers in so many pies that, for him, it might well *be* "here and there" comparatively...
08:52:22 <edwardk> mmm. pie
08:52:53 <augur> geekosaur: as of 2013, he had something like 150 github repos
08:53:01 <augur> goodness knows how many now
08:53:09 <augur> its DEFINITELY only "here and there" :)
08:54:02 <edwardk> sounds a bit like some stuff i've been talking to ryan wisnesky about -- you can connect the notion of a multicategory / coloured operad to that of a context free grammar and use it to talk about pretty much any sort of tree structure using CFG vocabulary
08:54:17 <augur> edwardk: what ends up happening is that the structure becomes vaguely like some kind of state machine spitting out next-match's
08:54:24 <augur> oh yeah, multicats are CFGs!
08:54:35 <augur> multicats are also the correct categories for type theory :)
08:54:59 <edwardk> not sure i'd go that far, but the are nice toys to play with
08:55:16 <augur> people love CCCs for the LC but CCCs are a special case of multicategories, and its really the multicategory that you want
08:55:31 <edwardk> there i largely agree
08:55:43 <hodapp> closed cartesian categories?
08:55:48 <augur> just as an example of why: its perfectly possible to have a type theory with just function types, but the CCC forces you to have pairs as well
08:55:58 <edwardk> hodapp: cartesian-closed categories, but yes
08:56:04 <augur> but a multicat lets you do exactly the -> lambda calculus
08:56:33 <nitrix> Hi. How do I solve a cyclic dependency like this? http://lpaste.net/136002
08:56:51 <nitrix> I cannot see anywhere where it'd make sense to have `providers` other than the Provider module :/
08:56:58 <augur> CCCs dont distinguish between structural connectives (the , in a typing context) and propositional/type connectives (producting) but multicats do
08:57:34 <hodapp> I need to read about Conal's stuff with CCCs...
08:57:41 <augur> actually, edwardk, where's a generalization of multicats to arbitrary monads instead of lists, and this gives you all the interesting logics :)
08:57:58 <edwardk> arbitrary cartesian monads anyways
08:58:00 <chpatrick> do you know a clever way to recover a promoted value to a value in template haskell?
08:58:30 <augur> like, if you look at various type logical grammars, for instance, there are varieties of like.. non-commutative linear logics where the relevant monad is trees of type decls
08:58:34 <geekosaur> nitrix, if all else fails, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion
08:58:58 <chpatrick> so I've got a complicated promoted value as a TH Type, and I'd like to recover a demoted value
08:59:30 <nitrix> geekosaur: I feel like this is a simple case enough that it could easily compile even if the types are mutually recursive :/
08:59:38 <augur> anyway, ok, edwardk, ill write something up and shoot it your way. i want to make a library of this, but i want the code to be vaguely nice, not the grungy particulars that i've got currently
08:59:48 <augur> so i figured, i should probably talk to you
08:59:51 <geekosaur> but ghc does not implement even simple solutions to recursive modules (yet)
08:59:56 <augur> tho you'll probably tell me to hit it with yoneda :)
09:00:07 <geekosaur> apparently someone is actively looking into it for 7.12 finally
09:00:26 <geekosaur> (if I understood backscroll in #ghc correctly)
09:00:49 <hodapp> I'm still looking for a good way around the fact that I have several modules where nearly every single definition inside it is parametrized around the same value
09:01:18 <hodapp> so it's either a lot of duplication, or everything inside of one giant record constructor
09:01:21 <geekosaur> hm also I assume line 9 of Provider should have :: instead of =
09:02:09 <geekosaur> hm, this does make me thing `providers` just belongs in Provider.Local
09:02:14 <nitrix> geekosaur: Correct, small typo.
09:02:22 <geekosaur> *think
09:02:30 <nitrix> geekosaur: The problem is there are multiple of those providers.
09:02:32 <geekosaur> granting that it's not the ideal place for it conceptually
09:03:15 <kqr> @pl \x -> f (g x) x
09:03:15 <lambdabot> f =<< g
09:03:28 <kqr> oh really
09:05:59 <geekosaur> nitrix, fwiw lambdabot handles this by the equivalent of: each of the local providers exports its provider, and a separate module imports Provider and all the local providers
09:06:28 <wizek> Hello, is there a consice way to express this without list comprehention? [(x,y) | x <- [1..3], y <- [1..3]]
09:06:59 <exio4> wizek: (,) <$> [1..3] <*> [1..3] ? 
09:07:26 <nitrix> geekosaur: I was actually thinking about this. Provider.Internal, Provider.X/Y/Z and a final Provider that imports Provider.Internal(Provider) and all the providers.
09:07:33 <geekosaur> (except that `providers` is actually local config; see Plugins)
09:07:40 <kqr> wizek, or liftA2 (,) [1..3] [1..3]
09:07:43 <nitrix> Maybe that's why ByteString has a Internal module too?
09:07:56 <nitrix> It's the only thing I could relate to.
09:08:45 <geekosaur> no, ByteString doesn't try to abstract over strict vs. lazy for the most part, Internal is for those rare things that need to poke at the implementation.
09:08:59 <geekosaur> but what you suggest is a reasonable rearrangement of what LB does
09:09:22 <geekosaur> ideally there'd be some way to collect them all automatically but that requires runtime introspection
09:10:16 <geekosaur> (you might actually be able to pull that off if you made Provider a typeclass and the providers instances with Data instances... but urgh.)
09:11:26 <Eduard_Munteanu> Is there any work on getting a disk-based ixset? I wonder if a pure interface is possible.
09:11:47 <Eduard_Munteanu> Would it be so bad to mmap and unsafePerformIO?
09:12:28 <nitrix> geekosaur: I think typeclasses should be reserved for more generic concepts to extend the language, not application specific. Don't know if that makes sense.
09:12:38 <geekosaur> yes, that was the "but urgh"
09:12:50 <nitrix> geekosaur: I think the Internal thing is going well, let me fix the type errors quickly...
09:12:53 <geekosaur> it's doable but terrible
09:14:32 <Eduard_Munteanu> (Admittedly even memory allocations aren't side-effect free either.)
09:16:46 <nitrix> geekosaur: https://github.com/nitrix/udfs/tree/haskell/src
09:16:50 <nitrix> geekosaur: What do you think now?
09:17:45 <nitrix> geekosaur: Needs some cleanup with stray import/exports but yeah
09:22:30 <nitrix> I love it. I masqueraded the type complexity with modules :] !
09:22:46 <nitrix> Take that, ML !
09:24:24 <cnf> can anyone tell me how to get the style suggestions etc from lpaste?
09:24:28 <cnf> locally, i mean
09:24:44 <ttt_fff> nitrix: tell us more!
09:25:19 <mauke{> https://hackage.haskell.org/package/hlint
09:25:48 <nitrix> ttt_fff: It was recursive types, solved with an Internal module. You missed it :)
09:26:06 <delcici> are there other quality/style tools besides hlint?
09:28:39 <Eduard_Munteanu> Anyway, ixset is awesome.
09:28:57 * hackagebot VKHS 0.5.4 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.5.4 (SergeyMironov)
09:30:59 <saulzar_> cnf, It's hlint I think
09:31:05 <cnf> hmm
09:31:22 <cnf> i want to get it in vim
09:31:45 <saulzar_> I'm sure there's a vim plugin for that, not familiar with it myself 
09:32:30 <cnf> ok, syntastic does hlint
09:32:52 <cnf> it has ghc-mod.vim    hdevtools.vim  hlint.vim      scan.vim
09:33:40 <cnf> ok, so... i guess i need to figure out how to get hlint
09:33:58 * hackagebot HaskellNet 0.4.5 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4.5 (JonathanDaugherty)
09:34:16 <augur> edwardk: i just tweeted you two pictures of notes
09:34:18 <saulzar_> cnf, cabal install hlint would probably do the trick
09:34:25 <cnf> oh, hmm
09:34:34 <cnf> saulzar_: I am frightfully new to haskell, i fear
09:34:46 <augur> edwardk: who needs code and crap, when you can pretend to be conor lol
09:34:46 <cnf> where would cabal install things?
09:34:58 <saulzar_> .cabal/bin
09:35:05 <cnf> oh
09:35:24 <saulzar_> Can be useful to add that to your path
09:35:39 <cnf> on OSX it's  /Users/cnf/Library/Haskell/bin it seems
09:35:54 <saulzar_> Ah
09:35:54 <cnf> right, time for some zsh plugin stuff
09:36:43 <pharpend> Yayy Snoyberg fixed the Stack bug
09:36:49 <pharpend> Here's my compile error now: http://ix.io/jw6
09:37:00 <nitrix> Quick sanity checkup: Maybe is a type constructor, Maybe String is a type, Just is a value constructor, Just "Hi" is a value ?
09:37:16 <mauke{> nitrix: yes
09:37:33 <mauke{> (modulo lifted types :-)
09:37:37 <nitrix> Are these the same terms GHC are using?
09:37:44 <pharpend> http://lpaste.net/136005
09:37:52 <pharpend> ^ the Spec.hs file
09:38:47 <pharpend> slightly out of date entire tree -> https://github.com/pharpend/comarkdown
09:42:08 <augur> edwardk: this emitter-consumer coupling seems to me quite like something machine-y or iteratee-y or whatever. im not sure how much of the chart access control can or should be encoded via types, either
09:44:18 <augur> edwardk: the saturation approach gives some amount of laws tho, at least. so like, reading a symbol onto the chart then emitting a symbol should emit exactly the symbol just read onto the chart
09:44:36 <edwardk> augur: heading in to the office, will be back in a bit
09:44:40 <augur> regardless of what kind of chart you're using (whether its list-like or set-like)
09:44:47 <augur> okies. see you soon!
09:44:55 <augur> i think ill run out and get something to eat
09:45:55 <ttk> C2HS qustion: I am trying to decide whether to use newtype in #pointer or not. ({#pointer fmi2Component as Fmi2Component newtype#}) - should I use it or not? Anyone knows when to use it?
09:47:32 <ttk> It generates newtype Fmi2Component = Fmi2Component (Ptr (Fmi2Component)) vs type Fmi2Component = Ptr (()) -- which one should I use?
09:48:08 <osa1_> is this wrong cycle detection in cabal going to be fixed? e.g. tests depend on a package that depends on library and cabal thinks there's a cycle
09:50:27 <ttk> question rephrased: When to use newtype and when to use type?
09:58:01 <bergmark> ttk: if you care about the difference, use a newtype
09:58:50 <ttk> thanks
09:58:52 <bergmark> if you need other instances than the base type has, also use a newtype
09:58:59 * hackagebot byteset 0.1.0.0 - Set of bytes.  http://hackage.haskell.org/package/byteset-0.1.0.0 (DanielDiaz)
09:59:05 <ttk> oaky thanks
09:59:06 <ttk> :)
09:59:30 <bergmark> i almost never use type aliases
10:08:05 <cnf> saulzar_: it works!
10:08:21 <cnf> my laptop isn't very fast, took a while to compile it all :P
10:08:24 <saulzar_> cnf, Great :)
10:08:33 <cnf> i like having my code linted on save
10:08:51 <cnf> best way, imo, to learn to write clean code
10:09:02 <saulzar_> It does give good tips, always seems to find something where I go ... "Oh yeah.. that's better"
10:09:33 <cnf> 10" keystone
10:09:37 <cnf> oops, wrong screem
10:13:08 <magneticDuck> I wonder what a 10 inch keystone is
10:13:21 <cnf> hehe
10:13:35 <magneticDuck> now you're obliged to tell us
10:13:39 <cnf> you want an actual answer, or should i just let the joke stand?
10:13:48 <pharpend> magneticDuck: My guess is either oil drilling or a sex toy
10:14:24 <magneticDuck> but not both?
10:14:36 <magneticDuck> you need to think more creatively (but anyway, #haskell-blah)
10:15:15 <Sindriava> Who said `sex toy` and what did I miss? :D
10:15:51 <cnf> magneticDuck: keystones are stuff like http://loja.ciareles.com.br/image/cache/data/plugs_cabos/keystone-500x500.jpg and https://www.firefold.com/Assets/keystone-jacks/usb-keystone-jack-b.jpg, keystones are a standardised format for them
10:15:53 <magneticDuck> the best thing on #haskell in literally the last 20 minutes
10:15:55 <cnf> 19" is an IT sized pannel, 10" is a telecom sized panel
10:16:28 <cnf> http://www.hardwarewebwinkel.nl/pi/delock-10-inch-keystone-patch-panel-12-port-43259-delock/large/51a8b0c3523c67.36044302.jpg
10:16:57 <ttt_fff> i'm on osx; wha tis the easiest way to get 7.10 ?
10:17:08 <cnf> ttt_fff: brew install
10:17:17 <Sindriava> ttt_fff: Or nix-env -i
10:17:34 <ttt_fff> Sindriava: does nix-env also have ghcjs ?
10:18:03 <magneticDuck> Sindriava: I feel like you have some sort of alert daemon that monitors the channel via a VPN and plays an alarm whenever somebody says "sex toy"
10:18:03 <Sindriava> ttt_fff: Probably, nix-env has the whole hackage, I'd be suprised if ghcjs wasn't in there
10:18:12 <magneticDuck> another brilliant use for haskell. Also, yes, nix is cool
10:18:19 <cnf> i guess no one was actually looking for an answer for that, after all :P
10:18:23 <Sindriava> magneticDuck: That is ridiculous
10:18:56 <ttt_fff> cnf: brew install is useful
10:19:01 <magneticDuck> cnf: I was kinda interested a bit when I saw the photo
10:19:03 <Sindriava> Nix is cool but has a ridiculous learning curve, I feel
10:19:05 <pharpend> cnf: 404s on the links I've clicked so far
10:19:10 <magneticDuck> nix is worth the learning curve
10:19:21 <cnf> pharpend: really?
10:19:26 <Sindriava> magneticDuck: No arguing there.
10:19:27 <ttt_fff> nix's learning curve makes vim look intuitive
10:19:28 <magneticDuck> we should have been using it a long time ago
10:19:31 <cnf> pharpend: clicked again, all work here
10:19:32 <Sindriava> ttt_fff++
10:19:38 <pharpend> cnf: the firefold one
10:19:46 <magneticDuck> Sindriava: I once met a guy who had convincing arguments against using nix, it was insane
10:19:51 <pharpend> oh oh 
10:20:00 <pharpend> cnf: stupid termite putting the , in the url
10:20:03 <magneticDuck> they were mainly practical arguments though, hinging on the fact that only a small part of the linux community uses it
10:20:07 <Sindriava> magneticDuck: Really? In favor of something else, or just generally/
10:20:09 <earthy> ttt_fff: nah. it's just... immutable. that takes getting used to.
10:20:21 <cnf> pharpend: :P
10:20:32 <pharpend> magneticDuck: I don't like NixOS. I haven't tried Nix-the-tool extensively, though
10:20:47 <Sindriava> I'm currently battling my way through setting up development environments on NixOS
10:21:10 <cnf> pharpend: the last one shows it all, anyway
10:21:11 * geekosaur thinks nixos could learn some usability tips from netbsd :)
10:21:23 <Sindriava> geekosaur: Like what?
10:21:29 <cnf> just looking to clean up my LackRack a bit
10:21:32 <magneticDuck> geekosaur: such as
10:21:35 <ttt_fff> the nixos documentation sucks
10:21:39 <ttt_fff> it's fucking unreadble
10:21:42 <Sindriava> geekosaur: Wait, that sounded a bit rude. It was an honest question, I've never used netbs
10:21:43 <magneticDuck> that's unfortunately a bit true
10:21:49 <Sindriava> ttt_fff++, It's a mess
10:21:50 <geekosaur> siiigh, never try sarcasm, clearly
10:21:57 <ttt_fff> every time I try it, I can't get ghcjs up and I'm like fuck it, this is all wnat I wnated nixos for, and it sucks
10:22:04 <magneticDuck> arch linux documentation + nixos ideology + netbsd design pattern = world domination
10:22:08 <magneticDuck> just give it another 5 years
10:22:11 <geekosaur> (netbsd used to be rather infamous because you started by formatting the disk and manually copying stuff onto it)
10:22:18 <Sindriava> Oooh
10:22:22 <ttk> Can someone tell me what to do about this? Unacceptable result type in foreign declaration: …
10:22:22 <ttk>       IO Foreign.C.Types.CInt
10:22:22 <ttk>     When checking declaration:
10:22:22 <ttk>       foreign import ccall safe "dynamic" c_fmi2SetDebugLogging
10:22:22 <ttk>         :: FunPtr Fmi2SetDebugLoggingTYPE -> Fmi2SetDebugLoggingTYPE
10:22:41 <pharpend> ttk: on-topic conversation is strictly forbidden here
10:22:49 <magneticDuck> you're interrupted our off-topic conversation about nixos ttk!
10:22:59 <Sindriava> How dare you
10:23:05 <magneticDuck> aaadmin!!
10:23:06 <ttk> haha feel bad for interrupting the fun :)
10:23:07 <pharpend> ttk: get out of here. Take your on-topic conversation to one of the nerd channels
10:23:17 <pharpend> ttk: like #haskell-beginners
10:23:53 <ttk> anywas -> this is the type: type Fmi2SetDebugLoggingTYPE = (((Fmi2Component) -> (CInt -> (CUInt -> ((Ptr (Ptr CChar)) -> (IO CInt))))))
10:23:53 <pharpend> ttk: I have no idea how to solve your problem
10:24:17 <pharpend> NixOS I think is technically on-topic, although not really
10:24:22 <magneticDuck> ttk: first off, this isn't lisp
10:24:37 <magneticDuck> if anybody finds those parens in your type signatures, you're getting sent to #haskell-beginners for sure
10:24:40 <magneticDuck> ;D
10:24:45 <pharpend> magneticDuck: I think he doesn't understand operator associativity
10:24:47 <ttk> magneticDuck: it is c2hs creating the signatures like that :)
10:24:52 <magneticDuck> ah okay =P
10:24:53 <pharpend> ah okay
10:25:01 <Sindriava> ah okay
10:25:03 <pharpend> it's c2hs not understanding operator associativity
10:25:24 <ttk> magneticDuck: is there coming a second off with the solution/cause of my problem? :)
10:25:39 * magneticDuck reading through ffi docs
10:25:49 <magneticDuck> lols, I haven't used ffi much in haskell myself, sorry
10:25:53 <pharpend> ttk: I think eve --- it's apparently monday, I thought it was sunday
10:25:57 <ttk> hehe
10:25:58 * pharpend should look at a calendar
10:26:08 <magneticDuck> I just thought it was fun to point at how silly that type signature is
10:29:11 <Sindriava> ttk: For the record, you can inline C in Haskell
10:29:22 <Sindriava> ttk: Might be better than messing around with FFI in some cases
10:30:00 <ttk> Sindriava: not possible in my situation. I need to invoke functions on several libraries
10:30:16 <Sindriava> ttk: Then FFI it is, I guess
10:30:32 <Sindriava> ttk: I have never used ffi, so I won't be able to help there :/
10:31:01 <ttk> ok thanks though :)
10:34:01 * hackagebot hdevtools 0.1.1.9 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.1.9 (SchellScivally)
10:37:15 <geekosaur> don't those errors usually mean something wasn't imported?
10:37:42 <geekosaur> used to be you could get away with not explicitly importing various types used in FFI import/export, even though the Report requires it
10:38:12 <ttk> geekosaur it did!
10:39:03 <ttk> After I imorted Foreign.C.Types it work - but I do not understand why. I have defined Fmi2SetDebugLoggingTYPE in the module Fmi2TypesPlatform, and I am importnig this module. Why do I have the import the types again?
10:41:47 <geekosaur> ttk, because the FFI specification requires it. GHC used to violate the spec by not requiring explicit import, implicit was sufficient.
10:42:07 <geekosaur> but ghc has a goal of sticking to the Report unless extensions are specifically enabled, so they changed it
10:42:39 <ttk> ah okay. How come it does not work if I import the specific types e.g. import Foreign.C.Types (CChar, CInt, CUInt, CDouble)? But it works if I just import Foreign.C.Types
10:43:51 <geekosaur> possibly because they are `type`s on other types you are not importing (e.g. CUInt is often Word32)
10:44:05 <geekosaur> either you have to track those yourself and import manually, or just import the whole module
10:44:56 <ttk> ah ok. Thanks a lot
10:45:00 <geekosaur> I am assuming the reason for this is that the FFI could be implemented by a relatively dumb tool that can't track the types down properly like ghc can. (specifically thinking here of Hugs which was still active when the original FFI spec was drafted)
10:51:32 <weasel__> why don't we just use type classes like `Monoid m f` where `f : m -> m -> m` to solve the Ring problem?
10:51:48 <weasel__> this is an obvious idea so I assume it has a standard answer
10:52:33 <bennofs> weasel__: is that Haskell code? and what is the ring problem?
10:52:38 <weasel__> by the Ring problem I mean how you need two interacting monoids
10:52:59 <weasel__> but both monoids are on the same type
10:53:21 <weasel__> bennofs: it's pseudocode, the where isn't part of the "code"
10:54:17 <weasel__> I'm guessing it breaks on things like Set because you have to include the order in the type
10:54:48 <bennofs> weasel__: so a type class with the `mappend` function as argument?
10:55:03 <weasel__> bennofs: Yeah
10:55:37 <bennofs> weasel__: well, for one, how do you decide if functions are equavilent?
10:55:39 <weasel__> bennofs: then you could write `class Ring m f g where...`
10:56:06 <bennofs> weasel__: also, this kind of defeats the purpose of the typeclass if you always have to write the function again
10:56:14 <cite-reader> `f` and `g` would have to be types, though.
10:56:40 <weasel__> bennofs: if they're the exact same function. dict passing handles that
10:56:52 <weasel__> cite-reader: I am asking about a hypothetical extension
10:57:15 <lyxia> Uh, how do you know which mappend you use in Ring m mappend mappend ?
10:57:41 <lyxia> uhm...
10:57:51 <bennofs> weasel__: if you do that, you could just as well use mconcat :: (m -> m -> m) -> [m] -> m instead of mconcat :: Monoid m => [m] -> m, and a similar translation would be possible for other functions (ok, you'd have to pass around mempty too, but is that then really so much of a difference?)
10:58:02 <weasel__> lyxia: I'm assuming the use case will be `(+) : Ring m f g => m -> m -> m`
10:58:31 <weasel__> lyxia: the typeclass gives them new names
10:58:33 <bennofs> weasel__: this is basically the idea of named instances
10:58:41 <bennofs> weasel__: idris has them
10:58:55 <weasel__> bennofs: I hoped it was meaningfully distinct
10:59:18 <greymalkin> Is there a way to override a particular lens so that makeLenses works for all but one field?
11:01:09 <Gaara> HI all, I am a beginner here and I am trying "Filter positions in list" program from https://www.hackerrank.com/challenges/fp-filter-positions-in-a-list
11:01:20 <bennofs> greymalkin: I think you can do that with http://hackage.haskell.org/package/lens-4.11/docs/Control-Lens-TH.html#v:lensField
11:01:21 <Gaara> This is my implementation http://pastebin.com/LyARHUCA
11:01:40 <Gaara> But I dont understand why do I get errors during compilation.
11:01:57 <weasel__> bennofs: If it's explicitly allowing a typeclass to have 'named' instances you don't open up the entire bag of named instance danger
11:02:27 <lyxia> Gaara: ++ expects two lists as arguments but x is an a.
11:03:09 <Gaara> lyxia: thanks for the comment. so, should i try with ":" rather than "++"
11:03:17 <lyxia> Gaara: Correct.
11:03:34 <lyxia> Gaara: BTW odd n == True is just odd n.
11:03:36 <greymalkin> Gaara: or use ++ [x]
11:03:59 <weasel__> bennofs: thank you for your comments, I suppose the best way to check is to try to write it
11:04:13 <Gaara> lyxia: greymalkin: awesome. thanks guys . it works now
11:08:33 <weasel__> bennofs: You are right. It's precisely named instances where you can decide for a class if named instances will be allowed
11:08:57 <weasel__> bennofs: it even has the part where you have to do boilerplate occasionally
11:09:42 <bennofs> I still do not really see how this will improve things
11:10:08 <bennofs> instead of specifying the Sum or Product 
11:10:13 <weasel__> it won't, it's only useful for writing numeric hierarchies afaik
11:10:20 <bennofs> newtype wrapper you now have to specify (*) or (+)
11:12:14 <bennofs> > ala Sum foldMap [1,2,3,4] -- weasel__ is your idea going to be better than this?
11:12:16 <lambdabot>  10
11:12:34 <bennofs> > alaf Sum foldMap (+1) [1,2,3,4]
11:12:36 <lambdabot>  14
11:14:10 <weasel__> bennofs: all it would do is give you `foldMap (+1) [1, 2, 3, 4] :: Ring m f g => m` or something close
11:14:24 <weasel__> whether that's an improvement depends on your point of view
11:29:03 * hackagebot hsexif 0.6.0.3 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.6.0.3 (EmmanuelTouzery)
11:30:45 <zovt> Hey everyone, has anyone here used the MessagePack library for Haskell?
11:34:03 * hackagebot temporal-media 0.6.0 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.6.0 (AntonKholomiov)
11:34:05 * hackagebot temporal-music-notation 0.4.1 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.4.1 (AntonKholomiov)
11:34:07 * hackagebot csound-expression-typed 0.0.7.6 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.6 (AntonKholomiov)
11:34:53 <obadz> Question to all: do you guys ever log stuff that goes in non-IO functions? If so, how do you pass around a log datastructure? Use unsafePerformIO? etc.
11:35:19 <ghorn> obadz: you could use a Writer monad
11:35:37 <obadz> ghorn: so pass stuff around?
11:36:11 <ghorn> obadz: yeah, but it happens under the hood, and the monad handles it for you
11:36:38 <obadz> ghorn: got an example/github link?
11:37:25 <lpaste> chpatrick pasted “Demoting DataKinds from Template Haskell” at http://lpaste.net/136016
11:37:45 <ghorn> obadz: give me a minute to whip something up
11:38:58 <chattered> > runWriter (do { x <- return 1; tell "hello"; y <- return 2; tell "world"; return (x + y) })
11:38:59 <lambdabot>  (3,"helloworld")
11:39:04 * hackagebot csound-expression 4.8 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.8 (AntonKholomiov)
11:39:59 <obadz> chattered: doesn't it bother you to do see the writer monad all over your log function's signature?
11:40:28 <obadz> I understand it's the price of purity..
11:40:47 <chattered> obadz: I've usually got my own monad, and just have it derive MonadWriter.
11:40:51 <ghorn> obadz: you can use something custom instead of Writer if you like
11:41:29 <obadz> I guess having Logger in the type signature isn't the end of the world
11:42:27 <chattered> obadz: If you're in some monad anyway, it's no extra overhead in the signature.
11:43:29 <obadz> http://learnyouahaskell.com/for-a-few-monads-more#writer <= this is on point
11:43:51 <obadz> chattered: could you explain that?
11:44:04 * hackagebot csound-sampler 0.0.6.2 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.6.2 (AntonKholomiov)
11:44:13 <exio4> obadz: a `normal` thing in your apps is to have newtype ThisThing m a = ThisThing (WriterT ..) plus functions that "wrap" things nicely, so you'd have things like log :: Text -> Game () 
11:45:15 <silver> some make debug mode and unsafePerformIO from pure code
11:46:20 <silver> in those cases logging is not part of "normal" execution process I guess
11:46:54 <obadz> how unsafe is unsafePerformIO exactly? If used exclusively for printing logs, can it ever do bad things?
11:46:58 <favetelinguis> Why am i getting the following error? Wery basic code that should not fail? https://gist.github.com/favetelinguis/b6281985da19033733ad
11:48:04 <obadz> favetelinguis: any reason you have a dot after org?
11:48:29 <koala_man> favetelinguis: have you tried it with a url that exists, like https://en.wikipedia.org./wiki/Narwhal ?
11:48:35 <mizu_no_oto> obadz: You can probably run into issues with interleavedIO in the file.
11:48:55 <silver> obadz, I think that if you need to log in production you shouldn't use unsafePerformIO, but instead use some kind of monad
11:49:28 <silver> but if you can get away with logs only in debug mode unsafePerformIO is fine
11:50:10 <favetelinguis> i have updated the link, now i get a tls error when i removed the dot?
11:50:14 <glguy> favetelinguis: When you go to the http:// URL wikipedia redirects you to the SSL page
11:51:07 <favetelinguis> glguy: ok so i can not do a get request for that page then?
11:51:14 <glguy> The trailing dot on the domain name is fine. It indicates an absolute name
11:52:28 <verement> obadz: one of the troubles with unsafePerformIO is that you don't have much control over when or how often (!) the IO is performed
11:52:45 <obadz> interesting
11:53:06 <obadz> much more down to earth question: has anyone written Excel UDF addins with Haskell?
11:53:46 <glguy> favetelinguis: The HandsomeSoup library appears to use the HTTP library, which doesn't support TLS
11:54:04 * hackagebot bytes 0.15.0.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.15.0.1 (EdwardKmett)
11:59:05 * hackagebot hyperloglog 0.3.2 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.3.2 (EdwardKmett)
11:59:07 * hackagebot approximate 0.2.2.1 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.2.2.1 (EdwardKmett)
12:03:13 <favetelinguis> glguy: ok thanks for finding that
12:04:05 * hackagebot log-domain 0.10.1.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.10.1.1 (EdwardKmett)
12:04:07 * hackagebot uniform-io 0.1.0.0 - Uniform IO over files, network, watever.  http://hackage.haskell.org/package/uniform-io-0.1.0.0 (marcosdumay)
12:21:54 <sccrstud92__> is there an applicative that can be used to traverse a Tree in breadth first order rather than depth first
12:22:45 <sccrstud92__> perhaps something with continuations
12:25:36 <chpatrick> sccrstud92__: you could do it with lens I think
12:29:39 <Sindriava> I'm not sure that Applicatives are a good thing to depend on regarding order, no?
12:30:09 <sccrstud92__> why not?
12:30:48 <sccrstud92__> chpatrick: my question isnt really about the easiest way to do a breadth first traversal. its more about how to do it with the "traverse" function, if possible
12:31:21 <xplat> Sindriava: actually it is reasonable to depend on order with applicatives
12:31:47 <xplat> sccrstud92__: you'd have to use a newtype
12:31:53 <Sindriava> xplat: Is it? I always thought order was more of a Monad thing and that Applicatives mere more "parallel"
12:32:10 <chpatrick> sccrstud92__: are you trying to extract some information or change the tree?
12:32:35 <poincare101> Hi. I recently uploaded this package and I'm trying to figure out why the build is failing: https://hackage.haskell.org/package/DCFL
12:32:50 <xplat> Sindriava: the order of the values is completely visible with some Applicatives (e.g. State, or Const, or Writer)
12:32:54 <poincare101> I'm not sure if I quite understand why it is failing
12:33:12 <Sindriava> xplat: Yeah, but aren't those applicatives also monads?
12:33:16 <sccrstud92__> chpatrick: lets say obtain a tree flattened in breadth first order
12:33:43 <sccrstud92__> xplat: why?
12:34:25 <shachaf> Sindriava: The ones that are monads are monads.
12:34:43 <xplat> Sindriava: yeah but even if you don't define the Monad instance for them you can still use them to observe the order of values in a traversal.  also Const is only a monad when the argument is (), it's applicative for any monoid and can still see the order.
12:35:36 <Sindriava> xplat: I didn't say you can't observe the order, just that you can't depend on Applcative to provide an order (in all cases), is that not correct?
12:35:57 <Sindriava> shachaf: You can do tautologies! Good job.
12:36:29 <xplat> sccrstud92__: traverse's interface does expose the order of values, but no hierarchy or nesting.  or rather, you can observe a hierarchy with an invalid Applicative instance, but there's no particular reason to suppose it's the one you want
12:36:33 <Jello_Raptor> is there any way to express "everything of typeclass A should also be an instance of typeclass B according to the following rules..." ? It seems like it would be an UndecidableInstances sort of thing though
12:37:03 <lpaste> chpatrick pasted “BFS on Plated” at http://lpaste.net/136023
12:37:13 <chpatrick> sccrstud92__ ^
12:37:41 <geekosaur> Jello_Raptor, usually a newtype is used, because the instance would actually match *every* type and only afterward check for an instance of A
12:37:48 <xplat> sccrstud92__: for example, the obvious way to implement Traversable for rose trees will give you the 'wrong' hierarchy of values even if you break Applicative laws to observe it
12:37:48 <chpatrick> works on anything with a Plated instance
12:37:57 <chpatrick> like Tree
12:38:06 <geekosaur> which, yes, is very UndecidableInstances
12:38:32 <Jello_Raptor> geekosaur: ahh, do any of those extensions handle constraints well? 
12:39:11 <geekosaur> you cannot make ghc handle constraints as part of instance selection with any extension, so no
12:39:20 <Jello_Raptor> in particular if you have "instance Bar a => Foo a" and "instance Foo a" it'll use the former 
12:39:21 <Jello_Raptor> ahh okaqy
12:39:24 <Jello_Raptor> okay*
12:39:43 <xplat> Sindriava: when using 'traverse' you get to choose which Applicative, so it only matters that some Applicatives can see the ordering, you don't need them all to
12:40:17 <xplat> Sindriava: also, Reader is a monad and *doesn't* see the ordering in the sense we're talking about
12:40:27 <Sindriava> xplat: Ah, I see… Yeah, that makes sense
12:40:53 <geekosaur> the rules will *try* to do what you intend, but the open world nature of instances makes it difficult
12:42:25 <geekosaur> (that is, the compiler cannot assume that the instances it knows about are the only possible ones; someone could well use a library having such an undecidable instance set, with an instance it got from somewhere else. and no, you can't prevent instances from being globally visible and thereby hide it from anyone else who might want to make such an instance
12:42:44 <Jello_Raptor> mhmm
12:43:20 <poincare101> How do I upload HTML for my package docs on package?
12:43:24 <poincare101> *hackage
12:43:36 <xplat> basically, OverlappingInstances is the only extension that changes how instance resolution is done really (causes Most Specific selection instead of Unique)--the rest of the things just turn off safety/sanity checks
12:44:07 * hackagebot DCFL 0.1.4.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.4.0 (dpandya)
12:44:28 <Jello_Raptor> xplat: ahh
12:45:14 <Sindriava> Does anyone have experience with using Nix?
12:45:29 <dolio> Incoherent instances changes it, too.
12:45:40 <poincare101> hackagebot: thank you for mentioning my package (yes, I know it's a bot)
12:46:05 <exio4> dolio: let's assume incoherent instances isn't even a thing 
12:46:52 <dolio> Do you also assume overlapping instances aren't a thing? Because they're actually the same thing, ultimately.
12:48:09 <sccrstud92__> Sindriava: I use Nix
12:48:18 <xplat> somehow i can never seem to say something intelligent about IncoherentInstances
12:48:44 <rjeli_> Hi, I'm having trouble with some syntax
12:48:53 <Sindriava> sccrstud92__: I'm having some trouble with setting everything up, but I think I'm too tired for today… The Nix documentation is rubbish and I can't find anything in it
12:48:53 <rjeli_> dropEvery xs = concatMap (take 2) . (flip chunksOf) xs
12:48:55 <rjeli_> works
12:49:02 <rjeli_> but when i take out xs, it doesnt type check
12:49:07 <rjeli_> to make it point free
12:49:23 <geekosaur> ??dmr
12:49:47 <Sindriava> rjeli_: Did you provide a type for it?
12:49:59 <rjeli_> Yes
12:50:10 <rjeli_> [a] -> Int -> [a]
12:50:12 <sccrstud92__> @let dropEvery xs = concatMap (take 2) . (flip chunksOf) xs
12:50:13 <lambdabot>  Defined.
12:50:25 <sccrstud92__> @let dropEvery = concatMap (take 2) .: (flip chunksOf)
12:50:26 <lambdabot>  .L.hs:141:32:
12:50:26 <lambdabot>      Not in scope: ‘.:’
12:50:26 <lambdabot>      Perhaps you meant one of these:
12:50:49 <geekosaur> whoops, maybe I'm too tired if I use the wrong bot syntax :p
12:50:54 <sccrstud92__> @let (f .: g) x y = f (g x y)
12:50:55 <lambdabot>  Defined.
12:50:57 <geekosaur> (and I guess irrelevant anyway)
12:50:58 <sccrstud92__> @let dropEvery = concatMap (take 2) .: (flip chunksOf)
12:50:59 <lambdabot>  .L.hs:145:1:
12:50:59 <lambdabot>      Multiple declarations of ‘dropEvery’
12:50:59 <lambdabot>      Declared at: .L.hs:141:1
12:51:08 <Sindriava> What the hell does .: do?
12:51:14 <sccrstud92__> how do you delete a definitoin?
12:51:36 <sccrstud92__> rjeli_: replace the . with .: from Data.Composition
12:51:37 <whoops> geekosaur: that's ok, I understand :-p
12:51:49 <rjeli_> ok thanks
12:51:53 <sccrstud92__> Sindriava: its in Data.Composition
12:51:55 <rjeli_> I'll stare at it for a while
12:51:58 <Sindriava> Oh, I see
12:51:59 <rjeli_> and figure it out
12:52:04 <Sindriava> composition for two arguments
12:52:07 <Sindriava> That's nasty
12:53:21 <ttk> Which language is the easiest to implement concurrency in? Haskell or Scala? I am trying to decide which one to go with
12:54:00 <xekmafcert> Can anyone confirm for me that the Haskell Platform brew for Mac works ok? (I'm not a Mac user, so I can't check for myself)
12:54:33 <Sindriava> xekmafcert: Worked fine about a week ago
12:54:40 <xekmafcert> Sindriava: Thanks. ^_^
12:54:42 <nitrix> I was thinking to build a web framework skeleton in haskell that can scale. What do you guys think of webskell.
12:54:48 * nitrix giggles
12:55:04 <Sindriava> Haskelleton?
12:55:31 <nitrix> heh
12:55:53 <ttk> Skelleweb
12:56:00 <ttk> skeleweb*
12:56:07 <Sindriava> 2spoopy4me
13:03:19 <cow_2001> The zipper chapter of lyah is divine.
13:06:14 <amf> how do you convert one HashMap's (from unordered-containers) values from one type to another? im unmashelling what aeson gives back and need to convert it
13:07:15 <amf> i believe i need Data.HashMap.Strict.traverseWithKey, but not sure how to create the new data structure as its not an Data.List.mapAcculL-like
13:09:08 * hackagebot cql 3.0.4 - Cassandra CQL binary protocol.  http://hackage.haskell.org/package/cql-3.0.4 (ToralfWittner)
13:09:08 <arkeet> amf: what do you mean by convert from one type to another?
13:09:36 <arkeet> are you just looking for fmap?
13:09:58 <amf> arkeet: aeson gives you back a parsed structure but using their types (Value, Array, etc); im writing the FromJSON instance into my own data structure
13:10:07 <amf> arkeet: i might be
13:14:08 * hackagebot cql-io 0.14.4 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.14.4 (ToralfWittner)
13:16:22 <aweinstock> amf: is using Data.Aeson.TH.deriveJSON to automatically write ToJSON/FromJSON not an option in this case?
13:18:12 <amf> aweinstock: i have 0 experience with TH, so its more of a plan b
13:20:15 <elbiot> Noob here, trying to get data in and out of Haskell. 
13:20:34 <lpaste> elbiot pasted “How to parse a csv to my data type?” at http://lpaste.net/136029
13:23:00 <sccrstud92__> elbiot: you seem to be attempting to only parse a single line
13:23:01 <quchen> elbiot: Do you want to write your own CSV parser? If not, Cassava might be the lib that does CSV for you.
13:23:07 <quchen> ?hack cassava
13:23:07 <lambdabot> http://hackage.haskell.org/package/cassava
13:24:03 <sccrstud92__> quchen: he has a very simple use case. just a simple csv, not an arbitrary one.
13:24:37 <sccrstud92__> its not really a csv parser, its a "this specific format" parser
13:24:47 <sccrstud92__> which just happens to be a subset of csv
13:24:57 <aweinstock> amf: what's the underlying datatype that's being serialized as JSON?
13:25:37 <sccrstud92__> elbiot: did you mean
13:25:42 <elbiot> I'd like to know how the standard tools work.  I'm coming from python and try not to import a specialized library for every basic thing.
13:25:53 <sccrstud92__> many1 (line `endBy` newline) <* eof
13:26:04 <Welkin> elbiot: everything in base is standard
13:26:08 <elbiot> sccrstud92__: I'd have to install casava? 
13:26:14 <Welkin> but you need to import the modules you need from it
13:26:29 <sccrstud92__> elbiot: not im not recommending cassava
13:26:39 <sccrstud92__> elbiot: i just think your parser is incorrect
13:26:50 <amf> aweinstock: its an object of nested objects or arrays. e.g { 'x' : { 'y' : { 'z' : [1,2,3] }}}, no limit on how deeply they nest
13:26:54 <sccrstud92__> elbiot: it looks like it was written to parse a single line file
13:26:55 <elbiot> oh sorry, that was quchen
13:27:30 <elbiot> It parses a multi line file:
13:27:37 <sccrstud92__> so its working?
13:27:52 <delcici> Is there a safe network library (e.g. one that doesn't throw exceptions)?
13:28:12 <aweinstock> amf: is there specific data you're trying to extract from the JSON object?
13:28:32 <elbiot_> sorry, back
13:28:50 <sccrstud92__> you said it parses a multiline file
13:28:58 <sccrstud92__> does that mean its working correctly?
13:29:04 <elbiot_> For a two line file with four number per line i get  Right [["1","2","3","4"],["2","4","7","9"]]
13:29:39 <elbiot_> No, it's giving me strings.  I want a list of [Line]
13:30:05 <sccrstud92__> oh i see. i misunderstood how endBy works
13:30:09 <elbiot_> [[Double]] is probably a step on that path too
13:30:18 <sccrstud92__> what is a Line?
13:30:30 <sccrstud92__> oh i see
13:30:32 <sccrstud92__> u defined it
13:30:36 <amf> aweinstock: yes, "type Blah = HashMap Text (Vector [Int])"
13:31:22 <elbiot_> I'm learning, so I'd be happy just to know how to convert the strings to doubles and figure out the type contruction myself
13:31:56 <sccrstud92__> :t read
13:31:57 <lambdabot> Read a => String -> a
13:32:06 <sccrstud92__> > read "2.345"
13:32:08 <lambdabot>  *Exception: Prelude.read: no parse
13:32:13 <sccrstud92__> > read "2.345" :: Double
13:32:14 <lambdabot>  2.345
13:32:35 <sccrstud92__> that converts a string to a double
13:33:16 <nitrix> The array package doesn't seem to document what happens if you attempt to use an index that is out of bounds.
13:33:19 <athan> ugh. wai-session seems bit rotted :(
13:33:34 <athan> led me down a rabbit hole with no bunnies
13:33:47 <sccrstud92__> nitrix: it throws a runtime exception
13:33:49 <nitrix> It has a `bounds` function, so I assume it's fairly aware of those boundaries. Yet, no behavior is clearly defined.
13:33:53 <Welkin> bunnies are vermin
13:33:55 <nitrix> sccrstud92__: It doesn't for me though.
13:34:05 <sccrstud92__> well it has for me
13:34:11 <sccrstud92__> what is it doing for you?
13:34:40 --- mode: ChanServ set +o mauke
13:34:40 --- mode: mauke set -b *!*@62.109.31.*
13:34:42 <nitrix> `bounds providers` yields `(0,1)`. There's 2 elements.
13:34:51 <sccrstud92__> okay
13:35:00 <nitrix> Then `providers ! 100` yields what looks like the last element of the array.
13:35:17 <sccrstud92__> yeah thats weird
13:35:23 <sccrstud92__> :t (!)
13:35:24 <lambdabot> Ix i => Array i e -> i -> e
13:35:32 <sccrstud92__> :t listArray
13:35:33 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
13:35:40 <elbiot> Sorry, I did see what you said about read though
13:35:52 <sccrstud92__> > listArray (0,1) [10,100] ! 0
13:35:54 <lambdabot>  10
13:35:55 <sccrstud92__> > listArray (0,1) [10,100] ! 1
13:35:57 <lambdabot>  100
13:35:59 <sccrstud92__> > listArray (0,1) [10,100] ! 2
13:36:00 <lambdabot>  *Exception: Ix{Integer}.index: Index (2) out of range ((0,1))
13:36:02 <elbiot> I tried that already though.  I'll post the error
13:36:03 <sccrstud92__> > listArray (0,1) [10,100] ! 100
13:36:05 <lambdabot>  *Exception: Ix{Integer}.index: Index (100) out of range ((0,1))
13:36:37 <sccrstud92__> nitrix: ^ thats what I expected
13:36:37 <nitrix> I get that result for int and string values, yeah, but the behavior is different when it's my ADT.
13:36:40 --- mode: mauke set -o mauke
13:37:03 <sccrstud92__> nitrix: maybe make a paste?
13:37:12 <amf> aweinstock: and what makes it more confusing, the x, y, z keys name values are unknown
13:37:43 <sccrstud92__> nitrix: also,, why did you choose arrays over vectors?
13:37:49 <lpaste> elbiot pasted “Parse error” at http://lpaste.net/136031
13:38:16 <elbiot> Am I disconnected?
13:38:32 <sccrstud92__> elbiot: you need to use fmap read instead of read
13:38:48 <sccrstud92__> and change the type
13:38:51 <elbiot> I tried that also.  Let me try again
13:38:57 <sccrstud92__> from Parsec String () String
13:39:02 <sccrstud92__> to Parsec String () Double
13:39:06 <sccrstud92__> and remove the :: Double
13:39:44 <aweinstock> amf: so the goal is to turn "{\"foo\": [1,2,3], \"bar\": []}" into a HashMap Text (Vector Int)?
13:42:11 <elbiot> @sccrstud92__ that worked!  Having to change the type makes sense
13:42:12 <lambdabot> Unknown command, try @list
13:42:30 <amf> aweinstock: close, "foo" can point to something just like your data structure
13:42:33 <sccrstud92__> elbiot: do you understand why you have to use fmap there?
13:43:30 <nitrix> sccrstud92__: http://lpaste.net/136032
13:43:47 <nitrix> sccrstud92__: It prints "Very lazy!".
13:43:56 <nitrix> Even though it's out of bounds.
13:44:03 <elbiot> No.  I don't
13:44:25 <elbiot> Something to do with functors? Which I don't know about yet
13:44:53 <amf> aweinstock: or a tree where each node is some fragment of a url and the node's data is the vector of ints. e.g. example.com/a/b would be a tree of 3 nodes, with "example.com" being the root, "a" being its child, and "b" is a child of "a"
13:45:14 <sccrstud92__> nitrix: what happens if you seq p before returning "Very lazy"
13:45:38 <sccrstud92__> nitrix: I dont think its even running the indexing into the array
13:45:51 <nitrix> Which is weird, isn't it?
13:45:54 <aweinstock> amf: so something like this type would capture the possible recursion: "data Blah = Node (HashMap Text Blah) | Leaf (Vector [Int])"
13:45:57 <sccrstud92__> nitrix: not in Haskell
13:46:23 <sccrstud92__> elbiot: yeah its because Parser String () is a functor
13:46:54 <amf> aweinstock: yes, but i want to leverage the HashMap to be the tree-like structure
13:47:06 <sccrstud92__> aweinstock: that looks kinda like a trie
13:47:48 <haskell625> Is data Bool = False | True the same as data Bool = True | False ? If not, why not?
13:47:55 <amf> sccrstud92__: thats exatly it (*smacks self for not recalling that term)
13:48:07 <haskell625> Is the order of the types in the sum types important?
13:48:07 <sccrstud92__> haskell625: depends on what you mean by "the same"
13:48:23 <sccrstud92__> the order matters when you automatically derive instances
13:48:30 <sccrstud92__> like Ord
13:48:33 <haskell625> sccrstud92__: how so?
13:48:45 <sccrstud92__> if you automatically derive Ord
13:48:46 <nitrix> sccrstud92__: Yeah, now I guess an exception if I try to use `p`.
13:48:50 <sccrstud92__> in one version
13:48:51 <nitrix> sccrstud92__: get*
13:48:53 <sccrstud92__> False < True
13:48:55 <sccrstud92__> in the other
13:48:58 <sccrstud92__> True < False
13:49:08 <sccrstud92__> nitrix: cool
13:49:35 <nitrix> sccrstud92__: Sort of. Is there an array variant that yields Maybe?
13:49:35 <sccrstud92__> haskell625: it also matters when deriving Enum I think
13:49:52 <sccrstud92__> nitrix: not that I know of :/
13:50:11 <sccrstud92__> nitrix: you can define your own infix operator though
13:50:24 <nitrix> That's so weird. It could totally be avoided.
13:50:26 <aweinstock> amf: I'm not entirely sure what you mean, or if it's possible to have a tree structure without explicitly tagging the nodes/leaves
13:50:28 <sccrstud92__> nitrix: that checks the bounds using inRange and returns Just or Nothing
13:50:29 <haskell625> sccrstud92__: and for maybe the same? That is  data Maybe a = Just a | Nothing is different than data Maybe a = Nothing | Just a 
13:50:44 <nitrix> sccrstud92__: Yeah, but I find it silly that it isn't out there yet.
13:50:55 <haskell625> for maybe it would seem that Maybe can hold values of two different types
13:51:00 <sccrstud92__> haskell625: in the way that the automatically created instances are derived, yes
13:51:05 <haskell625> the order shouldn't matter
13:51:17 <amf> aweinstock: i might take this to cafe, im getting jumbled up in trying to do too many things at once, thanks for helping though
13:51:37 <haskell625> does it make sense to compare a Maybe containing a Just a with one containing a Nothing?
13:52:11 <sccrstud92__> haskell625: if Maybe instantiates Ord then it makes sense
13:52:30 <sccrstud92__> you could have Nothing be larger than any Just
13:52:32 <sccrstud92__> or smaller
13:52:51 <haskell625> i'm trying to wrap my head about this but it feels weird
13:53:10 <haskell625> feels like comparing apple with oranges, they are different types
13:53:56 <sccrstud92__> haskell625: the mechanism that auto derives instances has no idea of the semantics you intend ur type to have
13:53:58 <sccrstud92__> so it guesses
13:53:59 <haskell625> I see how one can order two Maybes containing a Just a
13:54:00 <quchen> The order of constructors doesn't matter as far as the type's capabilities are concerned, but when you automatically generate code based on a declaration the generator might take the order into account (e.g. Ord).
13:54:26 <quchen> You can convert back and forth between "Maybe1 a = Just a | Nothing" and "Maybe2 a = Nothing | Just a", so their informational content is the same.
13:54:28 <haskell625> so it is just that deriving works this way
13:54:34 <quchen> Yes.
13:54:44 <haskell625> but if I don't derive anything
13:54:57 <sccrstud92__> then they should be the same
13:54:59 <Pamelloes> How do you print a String without quotes?
13:55:07 <quchen> Pamelloes: putStrLn
13:55:11 <sccrstud92__> Pamelltoes: putStr, putStrLn
13:55:13 <Pamelloes> Thanks :)
13:55:44 <quchen> Pamelloes: "print" calls "show" on its argument before printing it, and "show" for a String adds quotes (and escapes newlines and so on).
13:55:49 <quchen> ?src print
13:55:49 <lambdabot> print x = putStrLn (show x)
13:55:54 <haskell625> I guess what I wanted to ask is: why cannot I substitute one type by the other?
13:56:04 <haskell625> they are equivalent
13:56:13 <oconnore> When you're writing "script" like code -- how do you consume Maybe values without cluttering your code or killing debuggability?
13:56:23 <sccrstud92__> haskell625: because just because you know they are equivalent doesnt mean the compiler sees them as equivalent
13:56:30 <haskell625> data T = A | B = B | A
13:56:54 <sccrstud92__> conversely, if they are equivalent, why do you have both of them?
13:57:06 <oconnore> it's not an application, I have no interest in intelligently handling the lack of a configuration variable
13:57:15 <haskell625> by giving them different names I'm making them different types
13:57:15 <quchen> haskell625: They are equivalent the same way the even integers are equivalent to the odd ones: you can convert back and forth between them freely, but they're still different things.
13:57:16 <oconnore> I just want the program to blow up in a way that's debuggable later
13:57:22 <sccrstud92__> oconnore: fromJust
13:57:25 <sccrstud92__> :t fromJust
13:57:25 <lambdabot> Maybe a -> a
13:58:01 <quchen> > fromJust Nothing -- fromJust is evil, stay away
13:58:03 <haskell625> basically if I have data T = A | B in my program, and change it later to data T = B | A I would expect my program to remain identical
13:58:03 <lambdabot>  *Exception: Maybe.fromJust: Nothing
13:58:03 <oconnore> sccrstud92__: yeah, but then I just get "Maybe.fromJust: Nothing"
13:58:08 <sccrstud92__> oconnore: if you want something more debugger friendly use
13:58:18 <sccrstud92__> fromMaybe (error "specific err msg")
13:58:23 <sccrstud92__> :t fromMaybe
13:58:24 <lambdabot> a -> Maybe a -> a
13:58:30 <fishythefish> Quick check: if I export a type without exporting its constructors, what does that expose to the clients of the module (vs. not exporting the type at all)?
13:58:37 <Welkin> :t maybe
13:58:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:58:44 <sccrstud92__> fishythefish: just the type
13:58:48 <oconnore> sccrstud92__: ah, putting the error there is nice
13:58:49 <quchen> haskell625: If you're not deriving stuff then yes, switching constructor order should not alter your program's behaviour.
13:59:09 <fishythefish> sccrstud92__, right, but what does that allow you to do?
13:59:13 <fishythefish> e.g. specify a function type with it?
13:59:19 <haskell625> yes that is my expectation, when changing the definition of data T = A | B to data T = B | A, I expect that this is not "observable"
13:59:20 <fishythefish> Define other types with it?
13:59:29 <sccrstud92__> fishtthefish: yes. but you cant pattern match.
13:59:35 <quchen> fishythefish: You can still use the type in libraries, but you cannot pattern match on the constructors, for example. Data.Map works that way.
13:59:35 <sccrstud92__> which might be what you want
13:59:38 <fishythefish> Okay, that's what I thought, thanks.
13:59:41 <sccrstud92__> np
13:59:48 <fishythefish> No, I don't wanna pattern match (and that would require the data constructor).
13:59:59 <fishythefish> For some reason, I started doubting that knowledge.
14:00:31 <fishythefish> Er, instances are still exposed, though, right?
14:00:36 <sccrstud92__> yes
14:00:40 <fishythefish> E.g. could still read/show in shell.
14:00:43 <fishythefish> Okay, thanks again.
14:03:12 <nitrix> Why does it frustrates me so much that the Array library doesn't have a   (!) :: Ix i => Array i e -> i -> Maybe e
14:03:42 <nitrix> It's unconceiveable to me that they let the function throw an exception when this could be handled so idiomatically by the very constructs that makes Haskell nice to use.
14:03:55 <nitrix> Exceptions should be reserved for, well, exceptional stuff.
14:04:48 <Dynasty> Can anyone recommend a generics library to me? There are so many on hackage
14:05:28 <freeman42> working one some codewars haskell problems I ran into this `hidden` function http://lpaste.net/6827578964920238080 any idea part of which package/module it is? I can't seem to find it on hoogle
14:05:34 <nitrix> Why am I the only one angry at this. That's genuinely disgusting. Maybe I have too high expectations from a language I'm investing so much time in?
14:06:42 <aweinstock> nitrix: arr !? i = if inRange (bounds arr) i then Just (arr!i) else Nothing
14:06:47 <rhaps0dy> nitrix, you can add it yourself though.
14:07:05 <koala_man> is it an efficiency thing? 
14:07:16 <freeman42> nitrix, you are not the only one angry at it, maybe there will be a `!` Maybe proposal :p
14:07:17 <rhaps0dy> koala_man: no, a don't crash when out of bounds thing
14:07:22 <sccrstud92__> nitrix: no one said Array has a good api
14:07:22 <ronh> nitrix you're not the only one bothered by this. see safe package that provides safe alternatives for various functions 
14:07:32 <merijn> nitrix: ! is explicitly meant as failing indexing
14:07:39 <sccrstud92__> nitrix: I always choose Vector over it if I dont need a special type of index
14:07:45 <nitrix> ronh: the safe package is doing a very nice job for lists, but the array bothers me.
14:07:47 <merijn> It is in Map, etc. too
14:08:11 <sccrstud92__> merjijn: Map also has lookup though
14:08:23 <merijn> Array has bounds
14:08:38 <nitrix> aweinstock: I get that, but I'm still disgusted it's even a possibility that the user forgets a `inRange` at some point and the application crash from a runtime error that could be avoided.
14:09:00 <sccrstud92__> merijn: he didnt want bounds, he wanted the equivalent of lookup
14:09:11 <koala_man> rhaps0dy: I mean, is it partial for efficiency reasons? !! is partial for legacy reasons, but Array is surely newer
14:09:50 <freeman42> actually, can't find FromModule that takes 2 strings either
14:10:00 <sccrstud92__> you guys seem to be missing the point. its not bad that (!) is provide, its bad that a safe version isnt provided
14:10:18 <rhaps0dy> koala_man: no ide3a really
14:10:20 <nitrix> When is (!) failing any useful?
14:10:32 <merijn> sccrstud92__: Well, that's easy enough to fix by adding a safe version via pull request, no?
14:10:33 <freeman42> sccrstud92__, it's bad that the safe ! is not the default
14:10:34 --- mode: ChanServ set +o Cale
14:10:41 <koala_man> it seems bad that ! is not safe. if you provide one, it should be called unsafeIndex or something
14:10:43 <merijn> nitrix: When you know it can't fail because you know the bounds
14:10:44 <sccrstud92__> nitrix: when the only recourse is to crash anyway
14:10:53 <rhaps0dy> nitrix: when you know you're accessing only good indices and don't want to bother getting the Maybe out.
14:11:03 <rhaps0dy> I'd likley just use fromJust, which crashes too
14:11:10 <sccrstud92__> koala_man: then that conflists with the versions that can segfault, etc.
14:11:28 <nitrix> Point granted, but there should be a safe version, for sure.
14:11:45 <sccrstud92__> does vector have a safe version of !?
14:11:52 <rhaps0dy> nitrix: I agree
14:12:08 <sccrstud92__> freeman42: default what?
14:12:40 <nitrix> I'm looking at vector and it already seems a lot better.
14:12:45 <sccrstud92__> merijn: assuming its being actively maintained, yeah its easy. but I use Vector, so it doesnt really affect me
14:12:46 <nitrix> The unsafe functions are called unsafe.
14:13:05 <nitrix> And there you go, safe indexing (!?)
14:13:07 <nitrix> <3
14:13:15 <rhaps0dy> huh, I didn't know about Vector.
14:13:29 <rhaps0dy> is it a resizable array?
14:13:36 <Hafydd> (!?) :: i -> Array i a -> Maybe a
14:14:03 <sccrstud92__> if Vectors had support for arbitrary Ix a index types I would literally never use Array
14:14:04 <Hafydd> ...wait, never mind.
14:14:34 <sccrstud92__> I should make a vector-index package which does that actually ....
14:14:53 <freeman42> sccrstud92__, think I got stuff confused, you were talking about (!) and I was thinking of (!!)
14:14:55 <sccrstud92__> rhaps0dy: its not resizable
14:14:58 <aweinstock> is it ever useful to have an unsafeIndex-like function that does an implicit fromJust (as opposed to one that segfaults, which is useful for efficiency)?
14:15:03 <sccrstud92__> freeman42: np
14:15:24 <sccrstud92__> aweinstock: convenience
14:15:48 <freeman42> sccrstud92__, in the case of (!!) the default implementation should be replaced to return a Maybe cause that would make things safer
14:15:49 <sccrstud92__> aweinstock: also u can catch the exception in IO, right?
14:15:49 <rhaps0dy> sccrstud92__: guess I'll read the haddock then
14:15:54 <merijn> aweinstock: Where did the segfaulting indexing get into the discussion?
14:16:11 <sccrstud92__> freeman42: same issue with head and tail. its just too big a change now
14:16:15 <merijn> aweinstock: Array certainly doesn't segfault
14:16:27 <sccrstud92__> merijn: when we were talking about unssafe functions
14:16:34 <merijn> freeman42: It doesn't matter, because you shouldn't be using !! anyway
14:16:43 <freeman42> sccrstud92__, avoid, success at all costs? not that hard to refactor... just a lot
14:16:50 <Aruro> merijn: what should you use?
14:17:05 <merijn> Aruro: Lists are terrible for numeric indexing, so !! is always a bad idea
14:17:16 <sccrstud92__> freeman42: a lot of work == hard
14:17:18 <koala_man> could a low level check in the implementation of the library be faster than what GHC can produce from a Maybe plus fromJust? 
14:17:20 <merijn> Aruro: If you need to access by index, use a different data structure
14:17:25 <rhaps0dy> sccrstud92__: ah, cool
14:17:35 <aweinstock> merijn: 17:13:38 < sccrstud92__> koala_man: then that conflists with the versions that can segfault, etc.
14:18:03 <merijn> freeman42, sccrstud92__: head and tail would still exist because they're useful in case where you know they can't fail where unwrapping Maybe isn't gonna work
14:18:27 <freeman42> sccrstud92__, I meant hard as in requiring more thinking to refactor
14:18:28 <sccrstud92__> merijn: always bad? whats wrong with something like .... iterate f seed !! n
14:18:54 <sccrstud92__> merijn: (!!) is useful in situations when u know the minimum length of the list
14:19:04 <merijn> sccrstud92__: iterate doesn't have the right strictness/sharing, I think
14:19:11 <nitrix> Honestly, the opitimizer part of the compiler should take care of that. 
14:19:11 <aweinstock> if there were "safeHead :: [a] -> Maybe a", what's the difference between "head" and "fromJust . safeHead"?
14:19:16 <sccrstud92__> merijn: I dont understand
14:19:26 <sccrstud92__> aweinstack: error msg usefullness
14:19:33 <nitrix> Honestly, the opitimizer part of the compiler should take care of that.  As far as the language is concerned, it should always be safe.
14:19:59 <merijn> nitrix: You can't do that in a Turing complete language
14:20:24 <merijn> nitrix: Take a look at Agda/Coq, those have termination checking, so you can guarantee absence of failing behaviour
14:20:25 <monochrom> honestly, you should write an optimizer that does what you say
14:20:31 <merijn> But they're not particularly high performance
14:20:33 <monochrom> put your time where your mouth is
14:21:00 <nitrix> monochrom: No need to be rude.
14:21:10 <monochrom> I agree
14:21:18 <aweinstock> sccrstud92__: is "Prelude.head: empty list" significantly more helpful an error message than "Maybe.fromJust: Nothing"?
14:21:51 <sccrstud92__> aweinstock: yeah, especially if all similar cases are treated the same way
14:21:52 <nitrix> monochrom: You know as well as me that this isn't a one man project, so it's worth discussing.
14:22:18 <ronh> merijn you don't need termination checking to not have trivially partial functions like head or (!!)
14:22:38 <sccrstud92__> aweinstock: otherwise every partial function gets the same error msg
14:23:03 <monochrom> I agree. but I only see claims, not discussion
14:23:33 <sccrstud92__> monochrom: because he requires another person to participate...
14:24:26 <quchen> merijn: I wouldn't call (!!) to be *always* a bad idea. On infinite lists it's sometimes quite handy, for example, e.g. for iterate.
14:24:38 <quchen> But (!!) for random access is terrible of course.
14:24:59 <quchen> (Random as in multiple times back and forth and what not)
14:25:31 <sccrstud92__> another infinite case
14:25:35 <sccrstud92__> fibs !! n
14:25:37 <geekosaur> so it looks like that "hidden" function is actually specific to code wars kata, not in the standard hspec?
14:26:05 <geekosaur> https://github.com/Codewars/codewars-runner/blob/master/frameworks/haskell/Test/CodeWars/BlackList.hs
14:26:58 <sccrstud92__> is there a way to require that a list-like type be finite without having a type level representation of the length?
14:27:30 <sccrstud92__> without requiring strictness
14:27:33 <exio4> you might use strictness anotations... 
14:27:35 <exio4> damn :P
14:27:45 <sccrstud92__> haha srry that solution popped into my head too
14:27:46 <sccrstud92__> lol
14:27:57 <monochrom> you could "data F = Nil | Cons Int !F". this forbids infinite lists.
14:28:29 <SegFaultAX> monochrom: What does !F mean?
14:28:30 <monochrom> I don't think there is any other option
14:28:35 <magneticDuck> monochrom: that requires strictness, so
14:28:47 <magneticDuck> I guess the answer is "probably not, seeing monochrom doesn't know
14:28:56 <sccrstud92__> lol
14:29:09 <geekosaur> SegFaultAX, ! there is a strictness annotation, which means that it must evaluate the value for F when constructing a value
14:29:11 <sccrstud92__> i would guess not as well
14:29:14 <quchen> "Requires strictness" isn't a very good argument.
14:29:22 <geekosaur> for an infinite list, that would diverge
14:29:23 <monochrom> if you paid me 10000 bitcoins, I could write a proof...
14:29:39 <sccrstud92__> quchen: it wasnt an argument so much as it doesnt fall within the parameters of the question
14:29:53 <magneticDuck> monochrom: do you accept 8bit coins?
14:29:57 <geekosaur> (which is to say, hang or throw an exception depending on how exactly the infinite list is implemented)
14:30:01 <monochrom> haha
14:30:22 <quchen> sccrstud92__: Oh, I missed that line, sorry.
14:30:23 <geekosaur> super monochromio brothers?
14:30:44 <sccrstud92__> quchen: np
14:31:08 <merijn> Does it have to be arbitrary length list?
14:31:31 <merijn> You could probably do some trick like encoding odd/even length in the type signature and then enforce either odd or even
14:31:55 <merijn> Not sure that'd work in haskell, though
14:32:05 <magneticDuck> sccrstud92__: oh, maybe a newtype with an custom exposed constructor?
14:32:11 <magneticDuck> I'm too tired to think that one through properly though
14:32:38 <monochrom> how badly do you need a finite list? how strong do you want the guarantee to be?
14:33:14 <magneticDuck> sccrstud92__: you can always just add a stern warning in the documentation
14:33:23 <magneticDuck> or some sort of EULA that strictly prohibits laziness
14:33:44 <monochrom> for example, even if you accept strictness annotation, it is only a case of "if a program tries to build an infinite list, it won't terminate" rather than "the type checker knows your list is finite"
14:34:02 <magneticDuck> true
14:34:43 <|f`-`|f> so
14:34:50 <|f`-`|f> no extensions, infinite list
14:34:51 <sccrstud92__> the idea was to somehow separate the [] type into two types, representing finite lists and infinite lists. infinite is easy, its just a Stream, but I couldnt think of something for finite
14:34:53 <magneticDuck> if you have a way to append an element to the list, there's nobody stopping from constructing the fixed point, so I guess it depends on your context
14:35:10 <monochrom> oh infinite list is easy. "data G = Gtor Int G"
14:35:28 <sccrstud92__> monochrom: did you stop reading what I wrote halfway through?
14:35:39 <magneticDuck> sccrstud92__: the fact that what you're trying to do is impossible is an interesting point
14:35:43 <monochrom> yes. I didn't read everything. sorry!
14:35:47 <sccrstud92__> np
14:35:59 <|f`-`|f> "#haskell"
14:36:03 <|f`-`|f> "reading"
14:36:05 <|f`-`|f> pick one
14:36:12 <magneticDuck> none of the above
14:36:14 <magneticDuck> 3) sleep
14:36:15 <exio4> sccrstud92__: is GADTs + DataKinds + Type Families ok?
14:36:20 <|f`-`|f> Math so wizardric that they just know
14:36:32 <int-index> Where can I find `foldM` with arguments flipped so the function is last?
14:36:33 <|f`-`|f> Don't even need to read
14:36:43 <|f`-`|f> :t foldM
14:36:44 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:36:49 <|f`-`|f> damo
14:36:55 <sccrstud92__> :t forM
14:36:56 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
14:37:06 <sccrstud92__> int-index: ^
14:37:17 <quchen> That's flipped mapM, not flipped foldM.
14:37:24 <sccrstud92__> oh oops
14:37:25 <|f`-`|f> :t whileM
14:37:26 <sccrstud92__> sorry
14:37:26 <lambdabot> Not in scope: ‘whileM’
14:37:29 <|f`-`|f> shit
14:37:42 <lautrec> sccrstud92__: have you read this? http://blog.sigfpe.com/2007/07/data-and-codata.html
14:37:46 <monochrom> I haven't heard of a name for flip foldM
14:38:09 <|f`-`|f> @pl \b bs f -> foldM f b bs
14:38:09 <quchen> It's more than just flip if you want to have the function as the third argument.
14:38:09 <lambdabot> flip . flip foldM
14:38:14 <sccrstud92__> lautrec: not in a while. but last time I didnt understand everything, so I should probably read it again
14:38:14 <|f`-`|f> there we go
14:38:22 <bitemyapp> Cale: may I query you?
14:38:25 <sccrstud92__> :t foldM
14:38:26 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:39:42 <quchen> It would be a lot of redundant definitions if there was a zoo of functions with different argument permutations, that's why only the most used ones are there (actually, I can only think of traverse+for).
14:39:42 <lautrec> sccrstud92__: according to him, the def for infinite lists is the same as yours. but the def for finite lists is the same as []
14:40:17 <quchen> Ah, and & $ as of lately.
14:40:42 <int-index> quchen: I know there's no such function in base, but perhaps lens or other package with utilities defined.
14:42:07 <lautrec> sccrstud92__: there's also this blog post, essentially stating the same thing http://www.tac-tics.net/blog/data-vs-codata
14:45:59 <Cale> bitemyapp: Oh yeah, sure :)
14:47:23 <augur> edwardk: so, any thoughts?
14:49:07 <mitochon> hi I have a newbie question: after running 'cabal install hoogle' should 'hoogle' be available as a bash command? (I'm on Max OS)
14:50:01 <augur> mitochon: fwiw you're better off just bookmarking the hoogle site
14:50:09 <augur> either the hackage one or the fpcomplete one
14:50:28 <bitemyapp> Cale: sent you a couple messages
14:50:49 <mitochon> @augur I'm trying to do ghci integration
14:50:49 <lambdabot> Unknown command, try @list
14:51:10 <augur> mitochon: i know :)  but i think youll find that its not useful to do so
14:51:11 <mitochon> e.g. https://wiki.haskell.org/Hoogle#GHCi_Integration
14:52:54 <Hijiri> mitochon: By default (and if you aren't in a sandbox) cabal will install executables in .cabal/bin, so that has to be in your PATH
14:53:06 <Hijiri> ~/.cabal/bin
14:54:07 <geekosaur> on OS X that may be ~/Library/Haskell/bin
14:54:24 <geekosaur> also note that using ~ in $PATH may break, depending on your shell (and version of that shell, for bash)
14:54:37 <geekosaur> expressing it as $HOME is safer
14:56:10 <elbiot> Hey all, I haven't gotten anywhere.
14:56:15 <lpaste> elbiot pasted “Parser -> Data type” at http://lpaste.net/136049
14:56:43 <elbiot> I was trying to abuse fold to do this.
14:57:26 <elbiot> I tried `line =  Point $ cell `sepBy1` char ','`
14:57:42 <mitochon> Hijiri I don't see a bin directory under cabal
14:57:48 <elbiot> But Point doesn't take a list as an argument
14:57:58 <geekosaur> [06 21:53] <geekosaur> on OS X that may be ~/Library/Haskell/bin
14:57:59 <Hijiri> maybe it's in the directory geekosaur suggested then
14:58:23 <dwins> elbiot: I think you'd be better off writing a parser that can get a Point from two csv data elements and using many1 to get a list
14:59:24 <mitochon> yes I see it. Thanks geekosaur, Hijiri
14:59:56 <geekosaur> elbiot, you could wrap line with something that takes the list, ensures it's length 2, and returns a Point from its elements
15:01:18 <marchelzo_> elbiot: sepBy1 parses 1 or more occurrences or its first argument. The 1 doesn't mean that it just does (p, sep, p) one time.
15:01:31 <elbiot> geekosaur: so make a function like [a] -> Point
15:01:48 <geekosaur> with no error checking, this would be something like: linePoint = line >>= \[x,y] -> return (Point x y) -- note this will throw an exception if it's not a length-2 list, which your parser does *not* ensure
15:02:31 <elbiot> Marchelzo, I only have pairs of numbers on a line.  Right now the result is [[1.0,2.0],[2.0,4.0],[3.0,9.0]]
15:03:33 <marchelzo_> elbiot: I see. So it should be fine, then, as long as you do as geekosaur said.
15:04:23 <elbiot> Thanks, I'm brand new here so I just want to get something that works under strict conditions and worry about being robust later
15:06:26 <monochrom> use group theory to re-order arguments :)
15:07:28 <marchelzo_> elbiot: You could instead do: Point <$> cell <*> (char ',' >> cell)
15:10:17 <mitochon> one other question ... trying to run 'cabal install ghc-mod' -> getting 'cabal: The following packages are likely to be broken by the reinstalls:
15:10:20 <mitochon> warp-3.0.13 conduit-1.2.4.2 hoogle-4.2.41 hoogle-4.2.40 hlint-1.9.20 Use --force-reinstalls if you want to install anyway.
15:11:30 <elbiot> marchelzo_ I could but I have no idea what that does
15:11:43 <elbiot> the $ and * have to do with applicative?
15:11:55 <marchelzo_> <$> is just an infix version of fmap
15:12:06 <marchelzo_> <*> is from Applicative
15:13:10 <Denommus> (<*>) is on Prelude now
15:13:23 <marchelzo_> I just meant the Applicative type class
15:13:57 <Denommus> ah, right
15:14:04 <marchelzo_> (char ',' >> cell) is of type Parsec String () Double
15:14:18 <marchelzo_> cell is of type Parsec String () Double
15:14:40 <marchelzo_> Point is Double -> Double -> Point
15:15:26 <marchelzo_> so Point <$> cell has type Parsec String () (Double -> Point)
15:15:31 <marchelzo_> now look at <*>
15:15:35 <marchelzo_> @type (<*>)
15:15:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:15:51 <marchelzo_> f is Parsec String ()
15:16:00 <marchelzo_> a is Double
15:16:03 <marchelzo_> b is Point
15:16:18 <marchelzo_> We have f (a -> b), and cell is f a
15:16:40 <elbiot> Sorry, f has to do with a functor?
15:17:26 <marchelzo_> Yes, the letter f is used because it is representative of functor, but (<*>) requires Applicative which is a sub-class of Functor
15:17:52 <jle`> elbiot: f is just a type variable here really, so it can be anything.  but the letter f was chosen to evoke memories of functors :)
15:18:07 <marchelzo_> (Parsec a b) has a Monad instance, which means that it also has Functor and Applicative instances.
15:18:42 <mitochon> ghc-mod seems to be common package .. how do people install it without the risk of breaking other things
15:19:23 <mitochon> run 'cabal sandbox init' for each project before installing ghc-mod?
15:19:53 <solrize> so is there some big change in ghc 7.10 vs 7.8.3 that would make a carefully coded loop run 3x faster?
15:20:02 <elbiot> Hey marchelzo, I'm going to copy and paste what you said for later.  I need to read more about functors and monads and applicative
15:20:50 <elbiot> I appreciate you trying to explain it, but I just don't have the basic understanding
15:21:15 <elbiot> By the way is anyone in here in Austin Texas?
15:21:32 <elbiot> I would really like an in person tutor
15:21:55 <marchelzo_> elbiot: Certainly. It takes a lot of time and a lot of thought to wrap your head around some of this stuff. I didn't expect you to immediately understand, but just keep exploring.
15:23:35 <jle`> elbiot: i think btw that applicative, monad, etc. aren't really *too* relavant here
15:23:51 <chpatrick1> sccrstud92__: I think I have your BFS Traversable
15:24:04 <jle`> elbiot: (<*>) :: Parser (a  -> b) -> Parser a -> Parser b
15:24:18 <jle`> elbiot: so you can understnad (<*>) here without uunderstanding Functor, Applicative, etc. at all, really
15:24:33 <elbiot> okay.  I can see that
15:24:36 <jle`> elbiot: what it does is it takes something that parses an (a -> b) function, and something that parses an a, and turns it into a "mega-parser" that parses a b
15:24:47 <lpaste> chpatrick pasted “BFS Traversable for Tree” at http://lpaste.net/136051
15:25:26 <jle`> elbiot: `parser_f <*> parser_x` will run parser_f to parse a function, then run parser_x to parse a value, and then the final result will be the parsed function applie to the parsed value
15:33:34 <elbiot> jle`, marchelzo_, so Point <$> cell is parser_f and (char ',' >> cell) is parser_x?
15:34:27 <monochrom> yes
15:34:56 <elbiot> and `Point <$> cell`could be `fmap Point cell`?
15:35:02 <monochrom> yes
15:35:16 <jle`> elbiot: ah yeah, it would be.  `cell` parses a Cell, and Point :: Cell -> Cell -> Point, i'm guessing
15:35:48 <jle`> so what `fmap f myParser` does is that it runs `myParser` like normal, and then applies `f` to the result before "returning" it
15:36:18 <jle`> like if f :: Int -> Bool, it takes a `Parser Int`, runs it, and returns f applied to the int.  it'd be a `Parser Bool`
15:37:36 <jle`> one way i like to do it instead is to do `liftA2 :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
15:37:52 <elbiot> yes, Cell -> Cell -> Point
15:37:59 <jle`> which takes a "combining" function and two parsers, and returns a parser that runs the two parsers and applies the combining function on the two results
15:38:17 <jle`> so liftA2 f parser_x parser_y would run parser_x, then parser_y, and then apply f to the results at the end
15:38:39 <jle`> you might be able to do sometihhg like `liftA2 Point cell (char ',' >> cell)
15:39:03 <elbiot> what does (char ',' >> cell) do?
15:39:06 <jle`> which runs `cell` to parse a Cell, `char ',' >> cell` to parse another cell, and then apples Point to the end
15:39:21 <jle`> (>>) takes two parsers and runs them one-after-the-other
15:39:27 <jle`> and returns the result of the second thing
15:39:40 <jle`> `char ','` is a parser that returns ',' if the next character is ','
15:39:47 <elbiot> so (char ',' >> cell) like skips ahead in the parsing, giving me two adjacent results at a time?
15:39:49 <jle`> so it "eats" the ','
15:39:55 <jle`> and then cell parsers a cell
15:40:05 <jle`> so first it uses char ',' to parse a ',', and then cell to parse a cell
15:40:21 <jle`> it only gives you the result of the `cell` parser, though, not `char ','`
15:41:14 <jle`> `parser_x >> parser_y` = a new parser that runns parser_x, then parser_y, and returns the result of parser_y
15:41:33 <adarqui> "write you a haskell" by sdiehl is great ;f
15:41:46 <elbiot> So, what I really want is to have four values on a line and get a Line, which is two points.  So I could use (char ',' >> cell) three times?
15:42:18 <jle`> how do you make a Line?
15:42:22 <jle`> are the values separated by ',' ?
15:42:42 <elbiot> data Point = Point Float Float
15:42:44 <monochrom> what is the input format?
15:42:57 <elbiot> data Line  = Line Point Point
15:43:32 <elbiot> I'm just using four floats per line seperated by commas as the input
15:43:43 <elbiot> It can be anything since I'm just trying to learn
15:44:11 <jle`> so if you have a parser for a float, we can call it parseFloat
15:44:20 <jle`> we can make a parser for a Point
15:44:41 <jle`> parsePoint = liftA2 Point parseFloat (char ',' >> parseFloat)
15:44:51 <jle`> and then you can make a parser for a line from the point paresrs
15:45:06 <jle`> parseLine = liftA2 Line parsePoint (char ',' >> parsePoint)
15:45:14 <rui> I need to write a wav file with "save :: WAV -> IO()" and then play it with System.Process.system. What's the canonican way to make sure the file is fully saved before I try to read it?
15:45:38 <jle`> rui: is save blocking?
15:46:26 <freeman42> anyone finding first solution easier to read than the 2nd? http://i.imgur.com/IpK5aMt.png first time seeing that compose trick
15:46:46 <c_wraith> rui: *usually*, you wait until the action completes.  Most actions don't complete until they are... well, complete.
15:46:47 <rui> jle`: I think it is
15:46:56 <jle`> freeman42: the first one is definitely less readable
15:47:06 <jle`> i hope nobody does that
15:47:09 <jle`> like, in real life
15:47:25 <jle`> the second way is instantly readable
15:47:43 <freeman42> jle`, I find it less readable too, but maybe it is my lack of experience,... that answer has 3 best practices votes, maybe luck or first come first voted
15:47:49 <jle`> am sad that the first one has the best practices votes
15:48:09 <MuffettMan> freeman42: To put in a newb's perspective, first one is definitely less readable
15:48:12 <rui> c_wraith: But given that System.Process.system doesn't require a value of "save", laziness will bite me without seq or something?
15:48:16 <maerwald> freeman42: (foo .) can be used as an idiom, but it still sucks, because it doesn't add anything valuable
15:48:17 <jle`> yes nobody should ever do the first one if they want their code to be readable
15:48:26 <jle`> i can't think of any good reason
15:48:29 <freeman42> jle`, gave 2nd one a vote, so it is at least equal now
15:48:29 <rui> I hope its blocking
15:48:30 <MuffettMan> What is the website this is from? Seems kinda cool
15:48:33 <maerwald> and it is in fact used in some real world code 
15:48:48 <jle`> freeman42: good job :)
15:48:50 <freeman42> MuffettMan, http://www.codewars.com/ awesome place to exercise new languages
15:49:02 <c_wraith> rui: System.Process.system shouldn't return until the subprocess completes.  If it does, that's a sever violation of expectations for system
15:49:18 <c_wraith> *sever
15:49:22 <MuffettMan> Thanks freeman42, checking it out now!
15:49:24 <c_wraith> ... *severe.  I wish I could type
15:49:42 <jle`> you could say it severs expectations
15:49:51 <maerwald> freeman42: btw. I don't even like the second one
15:50:21 <jle`> i think the second one is clear in like, intent and denotation
15:50:29 <rui> c_wraith: Haha. I meant I hope "saveWav" is blocking. Otherwise my question would be not only about how to make sure it "starts" before "System.Process.system" but also that it finishes.
15:50:39 <jle`> but i think it's opinion at this point
15:50:40 <dfeuer_> Edwardk, is there a reason construct is not marked inline, or at least inlinable? It looks like it doesn't get inlined, at least in 7.8
15:50:49 <maerwald> partial eta reduction is ugly, unless it expresses an "expected" use case of partial application
15:51:25 <jle`> hm, i don't really see it as eta reduction, i see it as stating what "all" is
15:51:27 <maerwald> I don't think that's the case here, so it sucks
15:51:32 <jle`> all f is just map f, then and it all
15:51:44 <jle`> map if, then all it
15:51:47 <jle`> *and it
15:51:52 <jle`> map f, then and it
15:51:59 <jle`> any is map f, then or it
15:52:11 <jle`> it seems like a simple way to describe what any and all are doing
15:52:34 <freeman42> MuffettMan, your welcome, my solution ended up being http://i.imgur.com/JfBjhF7.png was not sure if and . map was working in a lazy way, but it seems it is
15:52:58 <jle`> mapM f = sequence . map f.  map f, then sequence it
15:55:03 <maerwald> jle`: I don't like showing only some parameters before the implementation, unless it makes sense for the use case (e.g with (<=<))
15:55:23 <jle`> mapM f xs = sequence (map f xs) seems a little more obfuscated to me, but i think it's close enough to be a judgment call.  you see the actual applications, but it's not as clear that mapM is just a "map and a sequence"
15:55:24 <maerwald> so I usually go with "none or all"
15:55:54 <maerwald> "some" is crap most of the time
15:56:00 <jle`> all f xs = and (map f xs) is a little less immediately clear to me than all = and . map f
15:56:03 <jle`> er, all f = and . map f
15:56:39 <jle`> i think i tend to pay less attention to amount of parameters and just see what statement denotes what i intend the clearest and most immediately understandable
15:57:47 <maerwald> if you have to jump a lot between signature and definition, then something is wrong. I had to look twice in the second example. I only had to look once in the first, because I happened to know the idiot of (foo .), although I would never use it myself
15:58:00 <maerwald> s/idiot/idiom/
15:58:03 <maerwald> almost the same :P
15:58:04 <adarqui> hah
15:59:14 <jle`> hm. i don't really think you need to know the signature to understand `all f = and . map f`.  "map f, then all".  but i guess maybe it depends on what you're used to reading
15:59:16 * hackagebot conceit 0.3.2.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.3.2.0 (DanielDiazCarrete)
15:59:44 <jle`> *map f, then and
15:59:54 <lpaste> elbiot pasted “Wow! it's working!” at http://lpaste.net/136067
16:00:16 <jle`> congrats elbiot :)
16:00:38 <jle`> btw, you can also do it monadically if it's more clear to you
16:00:49 <jle`> parsePoint = do
16:00:56 <jle`>     x <- parseFloat
16:01:00 <jle`>     char ','
16:01:03 <jle`>     y <- parseFloat
16:01:08 <jle`>     return (Point x y)
16:01:27 <maerwald> jle`: used to reading readable code, the definition context does not immediately tell me what is the last "missing parameter" I can apply "all f" to. I have to look at the type signature again. Where an "xs" would immediately tell me by the given haskell coding standards that it is a list
16:02:04 <elbiot> Is the way I posted a little janky, to have each parser increment through to the next ','
16:02:07 <maerwald> although it's a "map" not an "fmap" lol
16:02:13 <maerwald> so yeah
16:03:02 <elbiot> I saw the monadic example here: http://stackoverflow.com/questions/29108338/haskell-converting-data-from-file-to-data-type
16:03:27 <jle`> maerwald: point recognized :)
16:03:32 <elbiot> But I didn't understand it or the applicative version
16:03:50 <maerwald> jle`: but then again, the story is very different for something like (<=<)
16:03:56 <maerwald> :t (<=<)
16:03:57 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:04:18 <maerwald> imo it would be ugly to do something like "(<=<) f g a = ..."
16:04:30 <nshepperd> and . fmap f would also work for any foldable functor
16:04:56 <jle`> elbiot: i think the monadic approach is like, "parse things and name things and do stuff with the named things later", where an applicative approach is like "take a bunch of parsers and combine their results with a function"
16:05:11 <maerwald> nshepperd: yeah, I somewhat missed that it's only "map", I barely use it
16:05:12 <shachaf> nshepperd: Given that you have foldMap, there's no reason to require it to be Functor.
16:05:48 <jle`> in your case you just took two parsers --- parseFloat and (char ',' >> parseFloat), and combined their results with Point
16:06:45 <hexagoxel> maerwald: but `f <=< g $ a` ?
16:07:30 <maerwald> hexagoxel: I'd probably do "f <=< g = \a -> ..." which better expresses the chaining purpose
16:09:09 <maerwald> so I really think that the way you write your parameters can be considered part of the documentation
16:09:20 <hexagoxel> ah, you meant for definition. `(f <=< g) a = .. ` looks fine to me
16:10:58 <elbiot> Well, thanks jle` and sccrstud92__ and others who chimed in.  I may have actually learned something today!
16:12:10 <jle`> np :)
16:12:45 <nshepperd> getAny . foldMap (Any . f), indeed
16:13:14 <noexcept> hi
16:14:01 <noexcept> how do you speak the "->" in the function type declarations?
16:14:14 <maerwald> maps to?
16:15:05 <mauke> "minus greater-than"
16:15:25 <maerwald> :o
16:15:26 <kadoban> noexcept: "to"
16:15:51 <noexcept> do you also speak it as maps to when it's in parenthesis such as when a function accepts another function argument?
16:17:16 <chpatrick1> also "to" here
16:18:30 <maerwald> in the currying page on wikipedia they say "y -> z" is a function that maps an argument y to result z
16:19:06 <maerwald> and z can ofc be a function too
16:19:23 <maerwald> that doesn't change anything
16:24:17 * hackagebot align 0.1.1.0 - Sequence alignment algorithms.  http://hackage.haskell.org/package/align-0.1.1.0 (literon)
16:27:35 <noexcept> yes, but how do you speak (a->b)->[a]->[b]?
16:28:20 <c_wraith> "(a to b) to list of a to list of b".  Have fun pronouncing the parens. :)
16:28:33 <c_wraith> I usually do it by varying the tempo of my speech.
16:28:39 <c_wraith> Listeners usually get it.
16:32:42 <hiptobecubic> It seems like Haskell doesn't have the kind of unifying pile of libraries that would be needed to replace python for "data-sciencey" work.
16:32:49 <noexcept> that's exactly my problem, why don't you just pronounce it "function taking a function from a to b and a list of as returning a list of bs"
16:33:01 <hiptobecubic> There are a lot of libraries for doing various things, but they all use different arrays or this or that and it ends up being terrible to glue them together
16:33:39 <sccrstud92__> elbiot: np
16:33:45 * geekosaur imagines Korzybski parentheses
16:34:18 <hiptobecubic> can't you just say "function" ?
16:34:32 <noexcept> it would seem much more intuitive that way
16:34:45 <hiptobecubic> It takes a function from a to b, a list of a's, and returns a list of b's ?
16:34:51 <noexcept> yeah
16:34:55 <hiptobecubic> blahblah currying 
16:35:04 <noexcept> yeah well everyone knows about currying
16:35:06 <hiptobecubic> but when talking to other humans and not trying to be pedantic
16:35:08 <noexcept> you can do that in C++ too
16:35:09 <noexcept> std::bind
16:35:46 <exio4> I wonder how nice it scales when you throw rankntypes and type families to the mix
16:35:51 <noexcept> why the need to obfuscate the intent of the function's signature just for the sake of making every potential currying combination explicit
16:35:53 <exio4> and constraint kinds 
16:36:37 <noexcept> and you could also curry arguments out-of-order, no?
16:36:44 <noexcept> so the arrows don't even match up
16:36:55 <noexcept> at least you can in c++ with std::bind
16:36:59 <exio4> noexcept: making currying explicit makes it annoying syntax-wise 
16:37:11 <noexcept> exio4: exactly my point
16:37:15 <exio4> ? 
16:37:22 <SaidinWoT> you can curry out-of-order by changing the argument order
16:37:31 <noexcept> the arrow notation makes the return type hard to read
16:37:36 <exio4> noexcept: it doesn't
16:37:48 <cite-reader> When you're talking about currying here: do you actually mean "partial application"?
16:37:54 <exio4> noexcept: also, the `return` type isn't the last thing naively, when you have high order functions
16:37:55 <noexcept> yeah, std::bind
16:38:04 <exio4> @type maxBound 
16:38:05 <lambdabot> Bounded a => a
16:38:18 <cite-reader> I don't speak C++, I'm afraid. Off to Google.
16:38:58 <exio4> noexcept: would you say maxBound is a constant? or that fromInteger is a "single-argument" function?
16:39:03 <exio4> @type fromInteger
16:39:04 <lambdabot> Num a => Integer -> a
16:39:43 <noexcept> exio4: maxBound I would say is a zero-argument function, like std::numeric_limits<int>::max()
16:39:57 <noexcept> fromInteger sounds like a single argument function, yes
16:40:11 <exio4> maxBound can easily be a function
16:40:21 <Cale> noexcept: Well, *really* it's a function taking a function from a's to b's, and producing a function from lists of a's to lists of b's.
16:40:34 <Cale> (map, that is)
16:40:41 --- mode: Cale set -o Cale
16:40:50 * Cale can't remember why he's +o
16:41:04 <exio4> @let instance Bounded (a -> a) where minBound = id; maxBound = id
16:41:04 <noexcept> Cale: yeah but that's just pedantic imo, and makes the semantics very cumbersome
16:41:05 <lambdabot>  Defined.
16:41:19 <hiptobecubic> noexcept, it depends on context
16:41:24 <noexcept> Cale: No one would read function signatures like that in C++, even though you can do partial application with std::bind
16:41:25 <Cale> noexcept: It makes the semantics lovely -- we make use of this property all the time!
16:41:30 <Cale> noexcept: Consider:
16:41:31 <hiptobecubic> but if you're planning on fully applying it right away, then yes
16:41:41 <Cale> > map (map (*10)) [[1,2,3],[4,5,6]]
16:41:42 <lambdabot>  [[10,20,30],[40,50,60]]
16:41:53 <Cale> It's really nice to be able to write things like that
16:41:56 <Cale> without needing a lambda
16:42:19 <Cale> Once you're passing functions as arguments to other functions, having functions which compute other functions for you to supply as arguments is really nice.
16:42:28 <noexcept> yeah but the same thing is possible in "imperative" languages, except we don't repeat it at every function signature, because it's simply assumed that you can supply some arguments in advance
16:42:51 <Cale> Well, I don't know what this discussion is about really. I'm just talking about Haskell.
16:43:08 <Cale> But at least in Haskell, this is definitely a good design decision.
16:43:31 <Cale> (if it weren't, we'd just write functions which took tuples all the time instead)
16:44:33 <Cale> You eventually just come to regard "functions of multiple arguments" and "functions which produce other functions as their result" as the same thing.
16:45:13 <shachaf> Usually you only reach that point after multiple arguments.
16:45:28 <noexcept> Yeah, exactly what I feel. But the functions which produce other functions etc seems much more convoluted and unfriendly to beginners trying to learn the language
16:46:01 <noexcept> Since you pretty much learn to parse it as function of multiple arguments, as you said
16:46:19 <monochrom> at some point you have to stop working at the lump-everything-together level of "my function maps a function to a function", and starting working at the high-precision level of "the type is (Int -> Bool) -> (String -> Char)"
16:46:46 <noexcept> ls
16:46:47 <noexcept> oops
16:46:49 <monochrom> because, clearly, Int->Bool, String->Char, and (Int -> Bool) -> (String -> Char) are 3 different types
16:46:49 <Cale> noexcept: Perhaps, if especially so due to unfamiliarity due to the fact that this doesn't happen so often in any languages less obscure than Haskell. However, it turns out to be convenient in most cases, and essential to performance in some.
16:47:50 <Cale> Yeah, just using correct notation rather than trying to stomp on everything and turn it into English is probably the better idea most of the time.
16:48:28 <noexcept> Cale: Essential to performance? It seems more like a purely syntax issue, as other languages with partial application handle it just fine too
16:49:09 <exio4> having (.) work with _any_ function is also pretty cool
16:49:34 <exio4> @type (map . map) (+1)
16:49:35 <lambdabot> Num b => [[b]] -> [[b]]
16:49:36 <noexcept> if you wrote [b] map(b(a), [a]) instead, why would currying not still work?
16:50:24 <Cale> noexcept: In some cases, a function will be able to do part of its work given just its first argument, producing as its result, a more optimised function of the remainder of the arguments which can then be shared and used many times without repeating that initial set-up.
16:50:25 <monochrom> there is no currying in "[b] map(b(a), [a])"
16:51:07 <noexcept> Cale: good point, is that just the optimizer or is there some language rule for when this is done?
16:51:26 <Cale> It's partly the optimiser, and you can coerce it to happen by hand.
16:51:33 <Cale> noexcept: For example, consider a function for matching a particular regular expression against a string (and producing some result, possibly a Bool just to say whether it matched, or possibly something more complex).
16:52:25 <noexcept> monochrom: seems like that to you, but in C++ you could just: a = std::bind(map, plus_one); c = a({0, 1, 2});
16:52:34 <Cale> You could write that as a function of the regex which compiles a DFA and produces a function which steps through that DFA, which is then shared between uses of that resulting function (say, if you were to write: map (match myRegex) strings)
16:52:54 <monochrom> that is still not currying
16:53:20 <Cale> match r = let dfa = compileDFA r in \s -> ... use the DFA with the string s to see if there's a match ...
16:53:33 <monochrom> we are now at a point analogous to: if I say "your study is not science", you think I am looking down upon it.
16:53:36 <exio4> partial application is not currying
16:53:49 <noexcept> Cale: I see, but you're at the mercy of the optimizer noticing you only pass the string through to the DFA function?
16:53:59 <monochrom> when all I mean is that it is not science. no value judgment. just checking criteria
16:54:02 <Cale> noexcept: Well, if you write it the way I just did, then you're not.
16:54:25 <noexcept> exio4: hm, what is currying, then?
16:54:28 <Cale> noexcept: If you were to write  match r s = let dfa = ... in ...
16:54:37 <Cale> i.e. moving the s parameter outward
16:54:48 <monochrom> the C++ code you have shown does not count as currying. and my meaning is no more than my wording. it doesn't count as currying. nothing wrong with not using currying.
16:55:07 <Cale> Then you're at the mercy of the optimizer (and it may not discover this optimisation -- I think GHC generally won't do this because it can harm space performance if done uncautiously)
16:55:18 <magnap> Hi everyone! I am working through the NICTA course List, and I have a problem with notReverse. I have identified a fitting function (that typechecks), but doesn't seem to pass doctest
16:55:29 <monochrom> you have currying iff you have types like "A -> B -> C"
16:55:30 <Cale> However, both functions have the same type, and you could replace one by the other without any user needing to know
16:55:33 <exio4> noexcept: currying is representing multi-param functions with (a -> b -> c) instead of ((a,b) -> c) 
16:55:39 <noexcept> Cale: ah, so like with the std::regex constructor which takes a pattern and builds an object with overloaded call operator that runs the DFA on the string
16:55:54 <exio4> yes, but without magic behind the scenes
16:55:57 <noexcept> exio4: well, where is the difference, except syntactic sugar?
16:55:59 <Cale> yep, only that object is just a function :)
16:56:39 <exio4> noexcept: if anything, it changes all the types
16:56:41 <noexcept> in C++ objects with overloaded call operator are often passed around like functions (with state bundled into them)
16:56:57 <monochrom> in C the type is possibly "(C (B))(A)"
16:57:04 <exio4> @type (.) 
16:57:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:57:11 <exio4> @type (.) map map 
16:57:11 <noexcept> exio4: I still don't see the difference except that you have to manually use std::bind to do currying in C++
16:57:12 <lambdabot> (a -> b) -> [[a]] -> [[b]]
16:57:26 <exio4> noexcept: you have to manually use std::Bind to do partial application in C++
16:57:31 <exio4> s/B/b/
16:57:41 <noexcept> exio4: so that is the only difference?
16:58:01 <c_wraith> Syntax actually matters a lot.
16:58:20 <c_wraith> The more syntax something requires, the more likely people are to go to a different way of doing things.
16:58:34 <noexcept> I agree, but the arrow syntax is just confusing for me, I always translate it back in my head to multiple arguments and a return type, and then translate the currying to std::bind :P
16:58:59 <c_wraith> noexcept: Why, though?  It's not multiple arguments, and that's part of what makes the syntax so good.
16:59:27 <kadoban> noexcept: That's fine … as you use it more you'll stop doing that so much eventually.
16:59:31 <c_wraith> noexcept: if it was multiple arguments, the syntax for partial application would be something nearly as bad as what you're describing.
17:00:20 <noexcept> c_wraith: well that's just a syntax issue, you could patch a C++ compiler to let you do "currying" without std::bind by just specifying less arguments than the function excepts (it would probably cause problems with overloading, though)
17:00:42 <arkeet> all functions in haskell take exactly one argument.
17:01:25 <monochrom> you know, I agree with kadoban, there is no need to talk you out of what you're doing now. you will evolve for the better.
17:02:03 <monochrom> when I first learned programming, my mental model of "X = X+1" (BASIC) was updating a memory cell, physically.
17:02:06 <tyler569> as someone who did recently, I agree with monochrom
17:02:41 <monochrom> 35 years later, today, I have matured to the point that my mental model is a function such as \(x,y,z) -> (x+1, y, z)
17:03:11 <exio4> I think things like `fmap` should show a mental model based on "multiple arguments then returning a single thing" isn't that obvious :P 
17:03:13 <kadoban> Eventually, if you keep using haskell, you'll think of C++'s way in terms of haskell's instead … since haskell's is more natural in this case. This is part of the benefit of learning multiple languages, you end up having a lot of nice abstractions to use mentally.
17:03:31 <exio4> @type fmap
17:03:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:03:34 <magnap> SPOILERS (sorry): Why does notReverse = id not pass the tests in NICTA Course.List?
17:04:08 <monochrom> magnap: which test does it fail?
17:04:11 <exio4> two arguments, one return value
17:04:18 <noexcept> I think C++ and Haskell actually have a lot of similarities
17:04:24 <noexcept> map is just std::transform
17:04:29 <exio4> @type fmap :: (a -> b) -> (r -> a) -> r -> b  -- magic, three! 
17:04:31 <lambdabot> (a -> b) -> (r -> a) -> r -> b
17:04:31 <noexcept> fold is just std::accumulate
17:04:32 <noexcept> and so on
17:04:37 <magnap> [-3,-1]
17:04:37 <magnap> [-2,-3,3]
17:05:03 <magnap> monochrom: that one. But it varies from test run to test run
17:05:10 <kadoban> noexcept: There's a good reason for that, C++ borrowed those from functional programming (not haskell specifically probably)
17:05:12 <MarcelineVQ> i wonder where c++ got those concepts :>
17:05:40 <noexcept> well, concepts are obviously type classes (or meta types, as I prefer to think of them)
17:05:59 <noexcept> but std::transform, std::accumulate and so on have been in the standard library since the first C++ standard
17:06:07 <monochrom> id [-3,-1] = [-3,-1]. do you want notReverse [-3,-1] = [-3,-1] too?
17:06:48 <noexcept> one big issue I have with haskell is that it makes it extremely hard to write performant stateful algorithms
17:06:54 <magnap> monochrom: Since it gives 2 lists, I'd assume the failing property is "notReverse x ++ notReverse y == notReverse (x ++ y)"
17:07:00 <noexcept> like a simple prime sieve
17:07:28 <noexcept> while C++ makes it easy to write functional code
17:07:45 <monochrom> wait a second. are you sure you have no typo in "notReverse x ++ notReverse y == notReverse (x ++ y)"?
17:07:59 <arkeet> pretty sure it says (y ++ x) there.
17:08:07 <kadoban> (it does)
17:08:32 <magnap> Aaah! Thanks, everyone. Then no other function than reverse is possible!
17:08:46 <noexcept> does haskell have hindley milner type inference?
17:08:49 <Welkin> yes
17:09:10 <noexcept> in what cases would that be more powerful than the simple type inference in C++ (with auto)?
17:09:37 <marchelzo_> magnap: you can write notReverse as a partial function :P
17:09:37 <noexcept> I suppose it's mainly for providing better compile errors?
17:09:46 <noexcept> when the user omits types
17:09:59 <magnap> marchelzo_: Doesn't count! But yeah
17:10:06 <monochrom> at this point I quote a sentence from the Byte magazine, from an article that studied the reliability of various operating systems in the 1990s.
17:10:21 <monochrom> "Windows NT is a reliable OS"
17:10:28 <monochrom> "but only when compared to Windows 3"
17:10:47 <monochrom> C++ makes it easy to write functional code. but only when compared to C.
17:11:16 <monochrom> I mean, really, even C# makes it easier than C++. and don't forget F#
17:11:55 <noexcept> monochrom: really? what makes you think so? about C#
17:12:56 <Denommus> anyone successfully installed GHC in SUSE 12?
17:13:10 <catsup> no GC languages should not even be compared to GC languages
17:13:33 <noexcept> catsup: what does that have to do with anything?
17:13:51 <catsup> Denommus: i didn't, but if you are having difficulties, i recommend stack
17:13:52 <noexcept> catsup: I find the non-GC aspect (deterministic destruction) to be very powerful
17:13:58 <noexcept> catsup: not all resources are memory
17:14:14 <noexcept> catsup: there are locks, file handles, connections, .. just scratching the surface
17:14:18 <sccrstud92__> is corecursion ~ unfold?
17:14:21 <noexcept> catsup: the GC won't take care of those
17:14:30 <monochrom> sccrstud92__: yes
17:14:31 <catsup> noexcept: i am just saying they shouldn't be compared
17:14:51 <noexcept> catsup: and either way, C++ supports GC
17:15:07 <exio4> I think this channel is about Haskell
17:15:43 <catsup> noexcept: you can write a gc in any language of course, but in practice that is different from having a gc'd language
17:15:47 <monochrom> exio4: you should have said it the moment I brought up Windows 3 :)
17:15:48 <noexcept> It is, I'm only mentioning C++ because that's what I'm most familiar with
17:16:26 <Denommus> catsup: my problem is just installing GHC. I don't know what repo to use or anything like that
17:16:28 <exio4> monochrom: that quote was funny though! 
17:16:36 <catsup> Denommus: stack installs ghc
17:16:49 <noexcept> catsup: I meant C++ actually suppotrs being gc'd, see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2310.pdf
17:17:11 <catsup> Denommus: you download a statically linked binary, and that binary includes an installer that will automatically download and install ghc in your home directory
17:17:20 <catsup> statically linked binary of stack, that is
17:17:43 <Denommus> found it
17:21:17 <Welkin> haha
17:21:31 <Welkin> I read that as "includes an interstellar"
17:21:47 <Welkin> that will automatically download and install the universe
17:22:03 <Denommus> ok, I think I'll have to use stack
17:22:12 <Denommus> the GHC I downloaded doesn't come with cabal
17:22:18 <Welkin> none of them do...
17:22:18 <Denommus> and there isn't a cabal package to be found
17:22:23 <Welkin> you download that separately
17:22:35 <Denommus> oh, wait. It's called cabal-install
17:22:39 <kadoban> Denommus: If you feel like doing it manually for whatever reason, this is what I do: https://gist.github.com/ion1/2815423
17:22:47 <Welkin> https://www.haskell.org/cabal/download.html
17:22:49 <catsup> i think stack is the way to go these days
17:22:55 <kadoban> I'm likely going to switch to stack though soon I'd think.
17:23:12 <Welkin> it is very easy to download/install ghc and cabal-install
17:23:47 <Denommus> I think I'll also use stack... GHC is outdated. I need GHC 7.10
17:24:11 <Welkin> if you use osx, 7.10.1 has a bug that breaks it
17:24:24 <Welkin> I went back to 7.8.4 until 7.10.2 comes out
17:24:26 <Denommus> Welkin: it's SUSE 12, as I stated above
17:25:12 <Denommus> going home, bye
17:26:04 <tedkornish> If I have a couple functions of the type `a -> Maybe a`, how can I compose them together into another single function of the type `a -> Maybe a`?
17:26:45 <acowley> :t (>=>)
17:26:46 <bob_twinkles> either do-notation or >>=
17:26:46 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:27:00 <bob_twinkles> or that
17:27:03 <tedkornish> acowley - thanks very much
17:27:45 <tedkornish> bob_twinkles: I was running into problems with the bind operator because it required me to pass in an argument to the first function in order to chain the result along.
17:28:40 <bob_twinkles> yeah, you'd have to do something like (\x -> f x >>= g >>= h)
17:28:44 <tedkornish> The Kleisli arrow should clear it right up
17:29:22 <tedkornish> Yep, that's exactly what I ended up doing - but this should be much cleaner. Cheers, guys!
17:32:41 <augur> edwardk: ping
17:38:03 <funfunctor> Hi,
17:38:33 <funfunctor> Any folks worked with Heist Templates coupled with css styling
17:40:10 <bob_twinkles> is there a clean way to express failure with lazy Data.Binary.Get? binary-strict needs mtl < 2.2.0 and some of my other dependencies want at least mtl-2.2.0, and writing "instance Binary (Either String MyType) where ..." feels like a bad idea
17:42:28 <Clint> bob_twinkles: what do you mean by failure?
17:42:33 <sccrstud92__> bob_twinkles: isnt failure part of the parsing process?
17:43:23 <bob_twinkles> Clint: for example, the protocol I'm parsing has something like a packet type header that can be 0 -> 11. I want to provide some meaningful feedback when I get something outside of that range
17:43:52 <bob_twinkles> instead of just throwing an exception all the way back to IO
17:44:30 <Clint> bob_twinkles: runGetOrFail gets you the Either
17:46:56 <bob_twinkles> oh, that's exactly what I was looking for. For some reason Google links to the documentation for binary-0.4.x
17:47:04 <bob_twinkles> thanks Clint!
18:12:51 <Pamelloes> Is there an established method for creating a repl style thing? Basically, I want something like what happens when you run openssl or a similar utility where it gives you a shell with a special set of commands.
18:19:22 * hackagebot quiver 0.0.0.2 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.2 (patrykz)
18:19:25 <marchelzo_> Pamelloes: There might be a more specialized library out there, but you can't go wrong with readline.
18:20:33 <Pamelloes> Fair enough.
18:25:31 <songzh> anyone interested in the feature? https://ghc.haskell.org/trac/ghc/ticket/10607
18:26:52 <sccrstud92__> seems useful to me
18:27:45 <songzh> I just find that it is dumb to write do many derivings sometime.
18:28:19 <songzh> I just find that it is dumb to write so many derivings sometime.
18:28:36 <orzo_> yeah good idea
18:28:37 <songzh> hope this can draw some attentions.
18:29:05 <orzo_> prototype it
18:29:21 <catsup> yo
18:29:23 * hackagebot byteset 0.1.1.0 - Set of bytes.  http://hackage.haskell.org/package/byteset-0.1.1.0 (DanielDiaz)
18:29:26 <songzh> I got one on github, rather a toy
18:29:28 <sccrstud92__> orzo_: did that ticket say he implemented a prototype?
18:29:42 <pingu> songzh: I would use that at least once a month, probably.
18:30:14 <songzh> haha, hope it helps
18:30:17 <pingu> It'd save a fair bit of time, there is a real difference thouhg.
18:30:30 <pingu> In that if more objects are added to the tree anywhere, you will be adding more instances.
18:30:40 <pingu> Where as if it were manually written, you'd just explode, right?
18:30:50 <pingu> I'm not sure if that's a concern.
18:31:34 <songzh> I will not explode.
18:32:08 <songzh> just write standalone driving and load into GHCi and it will give you the next derive to write
18:32:41 <songzh> very mechanic job
18:33:45 <broma0> Can someone answer a quick question on lens composition?
18:33:58 <shachaf> Not if you don't ask it.
18:34:01 <catsup> only way to know is if you ask
18:35:23 <broma0> Ive generated some lenses with 'makeLenses' - "tabs" and "getL". In GHCI, "let tab = tabs . getL" works fine. Compiling, however results in an error
18:36:06 <broma0> any idea why there's an error? and let me know if you need to see the actual types themselves
18:37:22 <pacak> broma0: an error? +++ out of cheese +++? 
18:37:37 <sccrstud92__> broma0: could be a monomorphism restriction related error
18:37:52 <sccrstud92__> can you paste the code you are compiling?
18:39:08 <broma0> src/Types.hs:49:17:
18:39:08 <broma0>     No instance for (Functor f0) arising from a use of ‘chars’
18:39:08 <broma0>     The type variable ‘f0’ is ambiguous
18:39:08 <broma0>     Relevant bindings include
18:39:08 <broma0>       charL :: (Char -> f0 Char) -> Layout -> f0 Layout
18:39:10 <broma0>         (bound at src/Types.hs:49:1)
18:39:13 <broma0>     Note: there are several potential instances:
18:39:15 <broma0>       instance Functor (Control.Applicative.Const m)
18:39:18 <broma0>         -- Defined in ‘Control.Applicative’
18:39:18 <sccrstud92__> @lpaste
18:39:18 <lambdabot> Haskell pastebin: http://lpaste.net/
18:39:20 <broma0>       instance Control.Arrow.Arrow a =>
18:39:23 <broma0>                Functor (Control.Applicative.WrappedArrow a b)
18:39:25 <broma0>         -- Defined in ‘Control.Applicative’
18:39:28 <broma0>       instance Monad m => Functor (Control.Applicative.WrappedMonad m)
18:39:30 --- mode: ChanServ set +o shachaf
18:39:30 <broma0>         -- Defined in ‘Control.Applicative’
18:39:33 --- kick: broma0 was kicked by shachaf (broma0)
18:40:33 <sccrstud92__> use a pasting site like lpaste.net 
18:40:39 <pacak> type signature (with Lens) is missing, but he will never know it.
18:40:45 <Clint> never
18:40:49 --- mode: shachaf set -o shachaf
18:41:27 <sccrstud92__> how soon til he can get back in the room?
18:41:35 <pingu> no delay
18:41:43 <pingu> you could PM him and let him know
18:41:50 <pingu> he's obviously new to this
18:41:51 <Clint> he might still be pasting
18:42:03 <sccrstud92__> i let him know
18:42:09 <sccrstud92__> and explained why he was kicked
18:42:10 <shachaf> I already did.
18:42:15 <sccrstud92__> oh okay
18:45:41 <sccrstud92__> is there a lens type for a traversal that targets 0 or 1 targets (sometimes called affine traversal in the docs)?
18:46:00 <shachaf> No.
18:46:23 <sccrstud92__> is that something that cant be provided, or simply isnt provided?
18:47:13 <shachaf> Can't be provided nicely.
18:47:44 <sccrstud92__> okay
18:48:53 <sccrstud92__> can I defined a type like .... type MyMonadStack = (MonadError String m, MonadState Int m) => m
18:50:27 <kadoban> I don't think so.
18:57:26 <acowley> sccrstud92__: You can define a class with those superclass constraints if you just want some short hand, or you can use ConstraintKinds and create an alias for the compound constraint.
19:03:48 <sccrstud92__> how do I unset something I defined in lambdabot with @let?
19:04:14 <pavonia> sccrstud92__: @unlet
19:04:59 <sccrstud92__> @let x = 3
19:05:00 <lambdabot>  Defined.
19:05:03 <sccrstud92__> @unlet x
19:05:03 <lambdabot>  Parse failed: TemplateHaskell is not enabled
19:05:11 <sccrstud92__> is that supposed to work like that?
19:05:17 <pavonia> > x
19:05:18 <lambdabot>      Ambiguous occurrence ‘x’
19:05:18 <lambdabot>      It could refer to either ‘L.x’, defined at L.hs:154:1
19:05:18 <lambdabot>                            or ‘Debug.SimpleReflect.x’,
19:05:24 <sccrstud92__> @let x = 4
19:05:25 <pavonia> @unlet
19:05:25 <lambdabot>  .L.hs:155:1:
19:05:25 <lambdabot>      Multiple declarations of ‘x’
19:05:26 <lambdabot>      Declared at: .L.hs:154:1
19:05:26 <lambdabot>  Define what?
19:05:34 <pavonia> >l.x
19:05:36 <pavonia> > L.x
19:05:38 <lambdabot>  3
19:05:46 <pavonia> Huh
19:06:06 <shachaf> There is no @unlet.
19:06:31 <pavonia> I'm sure I saw people using it
19:08:10 <sccrstud92__> shachaf: so is there any way to do it?
19:08:44 <shachaf> @list let
19:08:44 <lambdabot> eval provides: run let define letlpaste undefine
19:08:48 <shachaf> @undefine
19:08:54 <sccrstud92__> @undefine x
19:08:54 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:09:02 <sccrstud92__> ouch
19:09:06 <sccrstud92__> alright better than nothing
19:19:26 * hackagebot monad-logger 0.3.13.2 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.13.2 (MichaelSnoyman)
19:22:42 <greymalkin> Okay, I'm looking for pointers -- still not getting Lenses, but getting better -- thinking this is a case for prisms: http://pastebin.com/38J8Cn2g
19:23:17 <shachaf> Why?
19:24:48 <greymalkin> (forgot the def of noNetworkPassword)
19:24:55 <greymalkin> shachaf: Was that directed at me?
19:26:32 <shachaf> Yes.
19:27:13 <shachaf> You probably shouldn't be using (^.) in those other two cases. It just happens to work because those types are Monoids, so it has a default value for them in case the traversal doesn't find a value.
19:27:39 <shachaf> Also, you probably shouldn't be defining a Getter. Just write a function, it's better than a Getter (and you can always turn it into a Getter with to).
19:27:52 <greymalkin> Yeah, I gathered that after-the-fact.
19:28:11 <ezrios> any vim plugins one would recommend for haskell development?
19:28:26 <greymalkin> I'm hoping to be able to create a function that will take [(Text, Getter ..)] and make those combinations for me
19:28:59 <greymalkin> The NetworkConfig object is about three layers deep in the type reperesenting the current state of an external device.
19:29:34 <greymalkin> So I have a lot of these to write; but am perplexed by this one case.
19:30:03 <roconnor> I think it would be better to make the record type for ConfiguredNetwork into a separate named typed.
19:30:29 <roconnor> and make honest lenses for the fields.
19:31:18 <greymalkin> And then wrap those two into a type that can be pattern matched?
19:31:38 <greymalkin> Hmm.
19:31:49 <roconnor> well then you'd do toJSON (ConfiguredNetwork cn) = ...
19:32:46 <roconnor> You probably won't be using prims for toJSON.  Pattern matching works well here.
19:33:08 <shachaf> Alternatively you can have something like a Prism' NetworkConfig (SSID, Maybe Text, SignalStrength), which is maybe what you were getting at.
19:33:16 <shachaf> But I'm not sure that helps you that much.
19:34:26 * hackagebot wai-extra 3.0.8.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.8.1 (MichaelSnoyman)
19:35:14 <roconnor> The main application of prisms is catching exceptions.  When you have a (usually abstract) type of many kinds of exceptions and you are interesting in catching one kind (or a few kinds) of variants of those exceptions, and don't care about the rest.
19:35:45 <roconnor> This is analgous to lenses for records where you are interested in accessing one field of a (sometimes abstract) record and don't care about the rest.
19:36:04 <roconnor> If someone added more fields to the record type, you wouldn't care.
19:36:22 <roconnor> When catching exceptions, if someone added more variants of exeptions, you wouldn't care.
19:37:00 <roconnor> But here, where you are serializing dato toJSON, if someone adds a new variant ... you probably care.
19:37:07 <shachaf> I'd kind of like it if you could do exhaustiveness checking with prisms.
19:37:13 <roconnor> can will want to serialize that new variant.
19:38:06 <sccrstud92__> I have a function f :: a -> f (g a), and I am using it with my lens l :: Lens' p a. currently I can get getCompose . (l %%~ Compose . f) to typecheck, but I was wondering if there was a nicer way to do this using something from Control.Lens.Wrapped. does anyone have any ideas?
19:38:08 <roconnor> shachaf: well, as you know, can can do that with polymorphic prisms, but that isn't really the case where prisms shine.
19:38:35 <sccrstud92__> @let l = undefined :: Lens' p a
19:38:36 <lambdabot>  Defined.
19:38:41 <greymalkin> So. On that note (and after furious coding of the above) is there any way to make non-exhaustiveness an error?
19:38:50 <sccrstud92__> @let f = undefined :: a -> f (g a)
19:38:51 <lambdabot>  Defined.
19:39:03 <sccrstud92__> :t getCompose . (l %%~ Compose . f)
19:39:04 <lambdabot> Not in scope: ‘getCompose’
19:39:04 <lambdabot>     Ambiguous occurrence ‘l’
19:39:04 <lambdabot>     It could refer to either ‘L.l’,
19:39:18 <sccrstud92__> @let myLens = undefined :: Lens' p a
19:39:19 <roconnor> sccrstud92__: that is the obvious way to do it ... 
19:39:19 <lambdabot>  Defined.
19:39:24 <sccrstud92__> :t getCompose . (myLens %%~ Compose . f)
19:39:25 <lambdabot> Not in scope: ‘getCompose’
19:39:25 <lambdabot>     Not in scope: data constructor ‘Compose’
19:39:25 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
19:39:37 <greymalkin> Thank you roconnor and shachaf -- that was *extremely* helpful!
19:39:53 <sccrstud92__> roconner: right, but I'm wondering if there is a way that is better than the obvious way
19:41:09 <roconnor> greymalkin: There should be some flags to turn on warnings about inexhaustive pattern matches and other flags to turn them into errors.
19:41:17 <roconnor> I forget what they are.
19:42:23 <roconnor> greymalkin: I suppose for yoru toJSON you probably don't want to use lenes either, because if you add a field to your NetworkConfig, you may forget to update your toJSON function.
19:42:56 <roconnor> greymalkin: if you pattern match, you should get an error if you fail to handle all fields.
19:43:09 <roconnor> basically this is the perfect place not to use lenses.
19:44:02 <greymalkin> roconnor: Even though this is about 3 levels deep?
19:45:00 <roconnor> May want to break each level into a separate function, but yeah, pattern matching is the way to help ensure that you cover all cases.
19:45:06 <greymalkin> I chose lenses because I could compose the 'path' arguments in the RPC-like protocol to which I'm conforming; was this not the right choice?
19:46:18 <greymalkin> Or, would it be better to not use lenses during serialization/deserialization, but still use lenses for the path composition?
19:46:35 <roconnor> yeah, I'm specifically talking about serialization here
19:46:36 <greymalkin> Or am I just entirely wrong-headed about lenses :-p
19:46:44 <roconnor> lenses and or prisms may be fine to use elsewhere.
19:47:10 <roconnor> and no one said you can't have both lenses and do pattern matching.
19:47:19 <roconnor> in different places
19:48:02 <shachaf> roconnor: You mean by changing parts of the type to Void?
19:48:08 <roconnor> shachaf: yes
19:48:17 <shachaf> Yes, that's not a great solution.
19:48:48 <roconnor> shachaf: Perhaps one can create a functional language where that is a great solution.
19:49:12 <greymalkin> Oh! lightbulb: Pattern matching the entire structure (rather than field accessor functions) so that the compiler yells at me if I forget to update after a change!
19:49:57 <roconnor> greymalkin: right, if you care about "all" fields, you want to use pattern matching rather than lenses (for that particular use case).
19:50:31 <felixn> > sequence [[1,2], [3,4,5], [6]]
19:50:32 <lambdabot>  [[1,3,6],[1,4,6],[1,5,6],[2,3,6],[2,4,6],[2,5,6]]
19:50:37 <felixn> just proud of that, that is all.
19:54:27 * hackagebot text1 0.0.1 - Non-empty values of `Data.Text`.  http://hackage.haskell.org/package/text1-0.0.1 (TonyMorris)
19:58:38 <Gaara> Hey guys, I am trying to solve e^x series expansion
19:58:40 <Gaara> here is the link
19:58:41 <Gaara> https://www.hackerrank.com/challenges/eval-ex
19:59:06 <Gaara> My attempt using basic constructs is solve x =  sum [ ((x^n)/ (product [1 .. n])) |n <- [0 .. x]]
19:59:22 <Gaara> I dont understand why there is error in this
19:59:28 * hackagebot text-show 2 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-2 (ryanglscott)
20:02:22 <Cale> Gaara: I don't think you want [0..x]
20:02:50 <Cale> :t (^)
20:02:51 <lambdabot> (Integral b, Num a) => a -> b -> a
20:03:10 <Cale> The exponent needs to be Integral (e.g. Int, Integer)
20:03:50 <Gaara> Cale: okay. i understand. let me change the code
20:04:28 <Cale> also, product [1..n] will have the same type as n, which, if you're going to use it as the exponent with (^), will be an Integral type as well. However (/) only works for Fractional types like Double or Rational.
20:04:40 <Cale> You may want to use fromIntegral to convert it.
20:04:42 <timothyh> in pipes, is there a way to detect end of input? so suppose a Pipe Int Bool m (), and i want to finalise the stream with a False
20:04:54 <Gaara> Cale: great. thanks
20:08:58 <sccrstud92__> is there a way to force ghc to expand type aliases when it prints a type?
20:16:35 <thoughtpolice> vvfhrnddbtnbfcfltndufugtcibblrbnrigerjeuhkef
20:16:48 <thoughtpolice> Uhhh, sorry about that, my keyboard got weird?
20:21:15 <dmj`> thoughtpolice: lol :)
20:39:30 * hackagebot text-show-instances 2 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-2 (ryanglscott)
20:44:30 * hackagebot lens-simple 0.1.0.7 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.7 (MichaelThompson)
20:46:48 <ladysparrow> hello
20:47:13 <sccrstud92__> hi
20:47:25 <michaelt> hello ladysparrow 
20:47:26 <pacak> o/
20:47:40 <ladysparrow> thought everybody's asleep
20:47:49 <ladysparrow> hi michaelt
20:47:59 <pacak> ladysparrow: Midday here. Any haskell questions?
20:48:52 <ladysparrow> pacak: i'm new in this chan. am i supposed to ask questions?
20:49:18 <pacak> ladysparrow: Or answer them.
20:49:37 <michaelt> ladysparrow: yes, a principle function of the channel is the help with problems pertaining to our dear programming language and its compiler and  the like.
20:49:44 * ladysparrow studies #haskell
20:50:00 <michaelt> ... and to argue about important matters of principle, I guess. 
20:50:01 <ladysparrow> oh i see
20:50:23 <ladysparrow> am i supposed to leave now?
20:50:30 <ladysparrow> don't like programming :(
20:50:50 <ladysparrow> i'm done with it when i finished college
20:51:13 <AshyIsMe> as a career it's not all it's cracked up to be that is true
20:51:21 <AshyIsMe> as a hobby though, programming is great fun
20:51:41 <pacak> ladysparrow: You won't find anything interesting here then.
20:52:08 <michaelt> Writing Haskell isn't programming, ladysparrow; it's defining your terms. It just happens that then the compiler understands you. 
20:52:10 <L8D> AshyIsMe: what do you mean it's not all it's cracked up to be?
20:52:10 <ladysparrow> pacak: hmm ok
20:52:20 <michaelt> That's today's strange exaggeration
20:53:05 <ladysparrow> they made the compiler understand you
20:53:57 <AshyIsMe> L8D: at least in my experience it's turned out that clients tend to want the worst possible solution
20:54:51 <AshyIsMe> i may be overexaggerating but that's what it feels like a lot of the time
20:54:57 <L8D> AshyIsMe: maybe you're not paying close enough attention, or you've had bad experiencs
20:57:09 <AshyIsMe> maybe im just bad at finding the fun work
21:04:23 * ladysparrow hugs everyone
21:04:30 <ladysparrow> i'm going. thank you
21:04:31 * hackagebot data-cell 1.0.0.2 - Generic cellular data representation library  http://hackage.haskell.org/package/data-cell-1.0.0.2 (patrykz)
21:04:54 <dmj`> AshyIsMe: greenfield dev. is fun, maintaining someone else's code is not that muchu fun.
21:05:06 <sccrstud92__> I wonder how she got here without an interest in talking about haskell...
21:05:51 <sccrstud92__> :t alaf Compose
21:05:52 <lambdabot>     Not in scope: data constructor ‘Compose’
21:05:53 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
21:06:07 <dmj`> s/muchu/much
21:07:11 <AshyIsMe> dmj`: yeah true, most of my career has been maintaining existing code
21:07:52 <DNoved1> I've not used lens much (or at all...), but I've gotten the impression that it's mainly about convenient record access/modification, is this roughly accurate?
21:08:17 <DNoved1> Wondering because I'm getting to a part of my code where records might become relevant.
21:08:36 <sccrstud92__> not just records, any nested data structures really
21:08:41 <dmj`> AshyIsMe: gotta go work for or/at a startup, or rewrite an existing code base in haskell
21:08:53 <sccrstud92__> but yeah that is one good use of lens
21:09:27 <AshyIsMe> dmj`: yeah that'd be fun
21:09:29 <sccrstud92__> :t getCompose . (myLens %%~ Compose . f)
21:09:30 <lambdabot> Not in scope: ‘getCompose’
21:09:30 <lambdabot>     Not in scope: data constructor ‘Compose’
21:09:30 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
21:09:38 <dmj`> AshyIsMe: web dev is a sweet spot for that
21:09:42 <AshyIsMe> i'll be looking for freelance work or a new full time (remote) job in a couple months
21:09:48 <dmj`> AshyIsMe: and pretty much everyone needs a web-based service
21:09:49 <sccrstud92__> :t alaf Compose myLens %%~ f
21:09:50 <lambdabot>     Not in scope: data constructor ‘Compose’
21:09:50 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
21:09:50 <lambdabot>     Ambiguous occurrence ‘f’
21:10:05 <AshyIsMe> would be nice to work with haskell or at least something like f#
21:10:05 <sccrstud92__> roconnor: ^
21:10:15 <DNoved1> Hmm, alright, I suppose I look into learning them.
21:10:23 <dmj`> AshyIsMe: whenever linkedin recruiters try to talk to me I try to sell them on haskell, see if they have contacts that are tech. stack agnostic
21:10:37 <dmj`> the less technical your clients are the better
21:11:51 <Stratege> dmj` how's that been working out for you so far?
21:15:58 <dmj`> Stratege: fantastic
21:16:22 <dmj`> Stratege: If anyone bad mouths haskell I just point them to facebook's engineering blog
21:18:15 <dmj`> But in terms of speed, conciseness, correctness, releasing new features, it's great. I've migrated to about 3 diff. web frameworks in this project, Haskell is the only language where that's really possible, w/o full rewrites, due to types.
21:18:40 <dmj`> perfect for startups where the problem you're trying to solve is being defined while you're attempting to solve it
21:19:26 <dmj`> the refactorability is fantastic, keeps your codebase from smelling, and from having those awkward "explain the legacy design decisions" conversation with people. 
21:25:38 <dmj`> Static-mum-182: hope that answers :)
21:25:49 <dmj`> Stratege: * :)
21:28:22 <sccrstud92__> is there a way to modify a value with a lens while at the same time returning the old value?
21:29:32 * hackagebot pipe-enumerator 0.3.0.2 - A bidirectional bridge between pipes and iteratees  http://hackage.haskell.org/package/pipe-enumerator-0.3.0.2 (patrykz)
21:34:35 <poincare101> Could someone explain to me why this build is failing: https://hackage.haskell.org/package/DCFL-0.1.4.0/reports/1
21:35:29 <creichert> poincare101: the version of 'base' is too tight (ghc-7.8 has base==4.7)
21:35:34 <pacak> poincare101: It wants strange version of base.
21:50:55 <poincare101> creichert: pacak http://lpaste.net/136073 <- That's my Cabal file but I'm getting a parse error on build-depends
21:50:59 <felixn> can I guard an exception?  I'm really lazy and I just want to do let (Foo bar) = ... and guard if bar fails
21:51:18 <pacak> :t try
21:51:19 <lambdabot> Exception e => IO a -> IO (Either e a)
21:51:48 <pacak> poincare101: You don't need second base
21:51:57 <poincare101> pacak: what do you mean
21:52:02 <michaelt> sccrstud92_: they tend to have a < in front of them
21:52:30 <pacak> poincare101:  base >=4.6 &&  <= 5.0
21:53:01 <poincare101> pacak: Ah. thank you.
21:53:27 <michaelt> > (1,"sccrstud92_") & _1<%~ even
21:53:28 <lambdabot>  (False,(False,"sccrstud92_"))
21:53:37 <michaelt> > (1,"sccrstud92_") & _1 %~ even
21:53:38 <lambdabot>  (False,"sccrstud92_")
21:54:34 * hackagebot DCFL 0.1.5.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.5.0 (dpandya)
21:55:04 <pacak> > first even (1, "foo")
21:55:05 <lambdabot>  (False,"foo")
21:55:14 <sccrstud92_> michaelt: right. I saw those, but couldnt find one that returns the old value
21:55:19 <michaelt> >  (_1 <<%~ even) (1,"hi")
21:55:21 <lambdabot>  (1,(False,"hi"))
21:55:35 <sccrstud92_> :t (<<%~)
21:55:36 <lambdabot> Data.Profunctor.Strong p => Optical p q ((,) a) s t a b -> p a b -> q s (a, t)
21:55:40 <michaelt> sccrstud92_: right, I just notice that. This works right?
21:55:46 <sccrstud92_> looks like it
21:56:13 <sccrstud92_> > (1, "hi") & _1 <<%~ even
21:56:15 <lambdabot>  (1,(False,"hi"))
21:56:16 <michaelt> I was forgetting the system for these operators. It looks like the << ones are the ones to look at
21:56:25 <sccrstud92_> what module is that in?
21:57:06 <michaelt> Defined in ‘Control.Lens.Lens’ my ghci says
21:57:28 <sccrstud92_> alright
21:57:36 <sccrstud92_> i must have blacked out when looking through those
21:57:36 <sccrstud92_> lol
21:58:36 <michaelt> I remember learning about them from reading the docs ... and then never actually using them ... so I think theres discussion in there somewhere
22:00:08 <sccrstud92_> > S.fromList [1,2,3] & at 2 <<.~ Nothing
22:00:10 <lambdabot>  (Just (),fromList [1,3])
22:01:10 <rui> do {save "lala.wav";system "vlc lala.wav"; return()}
22:01:21 <rui> Does that not run anything because of laziness?
22:01:56 <sccrstud92_> > S.fromList [1,2,3] & at 2 <<%@~ const Nothing
22:01:57 <lambdabot>      Couldn't match type ‘Indexed b1 a (a, b0)’
22:01:57 <lambdabot>                     with ‘Maybe (IxValue (S.Set a1))
22:01:57 <lambdabot>                           -> (a, Maybe (IxValue (S.Set a1)))’
22:03:17 <michaelt> strange, fpcomplete.com/hoogle has turned into the stackage homepage ...
22:03:34 <sccrstud92_> > S.fromList [1,2,3] & at 2 %%@~ \i a -> (i, Nothing)
22:03:35 <lambdabot>      Couldn't match type ‘p’ with ‘(->)’
22:03:36 <lambdabot>        ‘p’ is a rigid type variable bound by
22:03:36 <lambdabot>            a type expected by the context:
22:03:38 <michaelt> rui: what is 'save'. 
22:04:22 <sccrstud92_> > S.fromList [1,2,3] & at 2 %%@~ \i a -> ([i], Nothing)
22:04:23 <lambdabot>      Couldn't match type ‘p’ with ‘(->)’
22:04:24 <lambdabot>        ‘p’ is a rigid type variable bound by
22:04:24 <lambdabot>            a type expected by the context:
22:04:25 <rui> michaelt: some function :: String -> IO () that creates a file
22:04:40 <sccrstud92_> :t (%%@~)
22:04:42 <lambdabot> IndexedLensLike i f s t a b -> (i -> a -> f b) -> s -> f t
22:04:58 <sccrstud92_> :t (at 2 %%@~)
22:04:59 <lambdabot>     Couldn't match type ‘p’ with ‘(->)’
22:05:00 <lambdabot>       ‘p’ is a rigid type variable bound by
22:05:00 <lambdabot>           a type expected by the context:
22:05:03 <rui> michaelt: and you need it created for the next step. But nothing that the function returns is used.
22:05:04 <pacak> sccrstud92_: lambldabot listens to private messages.
22:05:09 <sccrstud92_> yeah srry
22:06:01 <pacak> sccrstud92_: Feel free to share if you find something that is both interesting and works though.
22:06:12 <sccrstud92_> k
22:06:20 <poincare101> How would I upload HTML docs to Hackage (and not wait for the hackage build system)?
22:06:33 <michaelt> rui: how is it different from do {putChar 'a'; putChar 'b'; return ()}
22:07:19 <pacak> michaelt: lazy io is evil.
22:07:28 <rui> michaelt: Not different. Just more similar to the problem at hand, and your example didn't come to mind. But it seems equivalent
22:09:36 <rui> michaelt: Do you know it your example is always guaranteed to work?
22:09:45 <rui> (to output "ab")
22:09:52 <michaelt> how could it not print both chars?
22:10:07 <nkaretnikov> pacak: what do you use?  pipes?
22:10:11 <michaelt> rui, you're panicking!
22:10:34 <pacak> nkaretnikov: iteratees, mostly historical reasons.
22:10:34 <poincare101> anyone for my question?
22:10:58 <rui> michaelt: Well, I fear that if a function doesn't need a value it doesn't evaluate it. Since "return ()" doesn't need anything, I wonder
22:11:15 <michaelt> poincare101: there are scripts
22:11:24 <poincare101> michaelt: link please?
22:11:45 <michaelt> poincare101: here's one I stole, I just used it a minute ago https://github.com/michaelt/lens-simple/blob/master/upload.sh
22:12:03 <poincare101> michaelt: I definitely thought I saw a page to upload the HTML
22:12:04 <nkaretnikov> pacak: well, that's at work, right?  I mean, what's your preference?
22:12:35 <michaelt> poincare101: oh, I didn't know that. This works fine though.
22:12:42 <pacak> nkaretnikov: That's at work, yes. Otherwise machines are nice - trying to switch some parts to them.
22:13:16 <michaelt> poincare101: you call it with your hackage user name, sh update.sh poincare then at the end it asks for your password
22:13:38 <pacak> nkaretnikov: Conduits are a bit too Snoyman'ish, never really tried to understand pipes.
22:13:46 <poincare101> michaelt: ok, just did that
22:13:48 <michaelt> pipes are a picnic
22:13:53 <nkaretnikov> pacak: there's a tutorial
22:14:11 <nkaretnikov> pacak: but conduits are much easier to get started with
22:14:12 <poincare101> I'm having some issue with builds - how do I figure out what packages are installed with cabal?
22:14:32 <pacak> nkaretnikov: have you tried machines?
22:14:35 * hackagebot pipes-cellular 0.0.0.1 - Pipes-based combinators for cellular data processing  http://hackage.haskell.org/package/pipes-cellular-0.0.0.1 (patrykz)
22:15:00 <michaelt> nkaretnikov: whats hard to get started with about each [1,2,3] >-> P.map (+1) >-> P.stdoutLn ....
22:15:25 <michaelt> which prints 2 3 and 4 on separate lines
22:15:37 <michaelt> woops, type failure.  P.print, not P.stdoutLn
22:15:57 <nkaretnikov> pacak: I skimmed the haddocks in the past, and that's about it.  I recently heard carter telling something (from vague memory) about how machines are interesting because there are two distinct types, which are one type in pipes, something like that.
22:17:16 <nkaretnikov> michaelt: let's not start the pipes vs. conduit war, okay? :)  I think that pipes has a cleaner api and would use it myself, but conduits are just easier because there's not that much terminology to remember
22:17:17 <pacak> > runT_ $ source  [1..10] ~> autoM print
22:17:18 <lambdabot>  Not in scope: ‘runT_’    Not in scope: ‘source’
22:17:18 <lambdabot>      Perhaps you meant ‘coerce’ (imported from Control.Lens)    Not in scope:...
22:17:18 <lambdabot>      Perhaps you meant one of these:
22:17:36 <poincare101> I'm trying to build a package but I'm getting the following errors: http://pastie.org/10276850 - I do have the deepest package but it is at version 1.4.1.1 - how do I fix this issue
22:17:52 <nkaretnikov> michaelt: also I've heard of non-deterministic issues with conduit, but I don't remember the details
22:17:54 <michaelt> pacak: that's the same in all these libraries
22:18:20 <nkaretnikov> iirc, it was one of the nyc haskell talks by oz.
22:18:34 <michaelt> poincare101: deepseq is a boot library, this is a little scary
22:19:22 <adarqui> hey quick attoparsec question.. so i'm parsing everything fine until it comes to the "last bit of text" in my string.. ie, i've parsed out all of the tokens i want, except for this last one which is basically "remaining", which is the remaining text.. i've tried T.takeText, T.many anyChar, etc.. and I keep getting a Partial _ result. any idea?
22:20:16 <michaelt> poincare101: of course, so is time. does maybe 'ghc-pkg check' tell you anything.  It seems you have deleted important libraries or else cabal (ghc-pkg) is looking at some out of date registry thing
22:22:51 <michaelt> adarqui: what about like skipMany anyChar >> endOfInput
22:23:19 <michaelt> adarqui: but don't listen to me I'm terrible at this ...
22:25:00 <haskell351> hi me new to haskell wanna learn it through working simple projects
22:25:23 <adarqui> michaelt: thanks. though, skipMany results in (), and so does endOfInput: skipMany :: Control.Applicative.Alternative f => f a -> f ()  ...  endOfInput :: AT.Parser ()
22:25:58 <adarqui> i tried it though, void $ skipMany anyChar >> endOfInput
22:25:59 <adarqui> :)
22:26:00 <adarqui> no luck
22:26:07 <michaelt> adarqui: no, it's no good, I'm fiddling. 
22:26:24 <adarqui> i dno i've been reading source trying to figure this out, and i don't get it.. i've parsed out my tokens fine except for this remaining text which is wrecking me
22:26:32 <adarqui> michaelt: that makes two of us
22:27:13 <adarqui> -- | Consume all remaining input and return it as a single string.
22:27:28 <adarqui> that's takeText.. i'd imagine that would just give me the rest of the input
22:29:11 <haskell351> hi me new to haskell wanna learn it through working simple projects
22:30:13 <bob_twinkles> there's stuff like Project Euler and /r/dailyprogrammer on reddit
22:30:47 <poincare101> haskell351: once you do a few project euler problems, write something that actually requires you to do IO, random numbers or anything else stateful
22:31:11 <michaelt> adarqui: try : manyTill anyChar atEnd 
22:31:13 <poincare101> anyone for my question?
22:31:53 <bob_twinkles> poincare101: can you "cabal install deepseq" ?
22:32:08 <bob_twinkles> or stack install, if that's what you're using
22:32:10 <poincare101> bob_twinkles: deepest is already installed
22:32:18 <michaelt> haskell351: check out the tutorial for the turtle library. It will be more fun http://hackage.haskell.org/package/turtle-1.2.0/docs/Turtle-Tutorial.html
22:32:37 <bob_twinkles> poincare101: does the version match? ghc-pkg describe deepseq should tell you
22:33:01 <michaelt> poincare101: does ghc-pkg list show it in the 'global' section, the first one?
22:33:38 <adarqui> michaelt: kind of works.. doesn't give me 'Partial _' anymore, but, it actually doesn't fill my 'remaining' with the remaining text.. close tho
22:33:41 <adarqui> ;f
22:35:29 <poincare101> bob_twinkles: michaelt oops it seems like deepeq isn't installed. but, when I try to install, I get: http://pastie.org/10276874
22:38:02 <adarqui> i don't get it
22:39:49 <bob_twinkles> poincare101: what's the output when you pass -v?
22:40:08 <michaelt_> poincare101: you don't want to reinstall deepseq . It comes with the compiler. Either you accidentally deleted it -- and would need to reinstall ghc. Or else somehow cabal is being directed to an old incompletely removed ghc .. or ...
22:40:37 <poincare101> michaelt_: I may have accidentally deleted it - I guess I should reinstall ghc?
22:40:49 <adarqui> deepseq comes with the haskell platform, not with the compiler itself, no?
22:41:01 <adarqui> https://hackage.haskell.org/package/deepseq
22:41:01 <michaelt_> no, it's really deep in the system
22:42:09 <michaelt_> I dont use the haskell platform, but it's a globally installed package that came with my ghc 
22:43:01 <michaelt_> in general, messing with those packages is an expert user kind of thing. 
22:44:35 <michaelt_> poincare101: but does "ghc-pkg list base" or  "ghc-pkg list bytestring" show anything
22:45:10 <poincare101> michaelt_: yes, bytestring-0.10.4.0
22:45:37 <michaelt_> hm, amazing. 
22:45:52 <michaelt_> you could try installing deepseq, but I think there will be trouble ...
22:47:00 <michaelt_> poincare101: other stuff among the global packages is presumably referring to particular marked deepseq that has gone missing.
22:47:38 <poincare101> michaelt_: I think I may have deregistered deepeq earlier because I was having some issues w/ my cabal file and I thought at the time that it was the right thing to do
22:48:21 <bob_twinkles> I too have taken the roflstomp approach to package management. It rarely works out =P
22:48:47 <adarqui> michaelt_: ok .. i fixed it.. but i really don't know why this works.. I had to use parseOnly instead of parse: Run a parser that cannot be resupplied via a 'Partial' result.
22:48:49 <michaelt_> poincare101: yeah, I think that's a bad plan for stuff that close to the compiler. 
22:49:04 <michaelt_> adarqui: ah
22:56:52 <eds> Line 44. http://lpaste.net/132328. Why is it not a valid tree?
23:00:08 <michaelt_> eds: because (boxc 4 5 "times") isn't an Int?
23:00:21 <adarqui> looks like it's expecting Int's, but, you're passing it Fox's
23:00:27 <adarqui> ya
23:00:58 <michaelt_> right
23:02:46 <michaelt_> eds: but suppose you replaced data Fox = forall a b. Fox a a (a -> a -> b) (b -> String)
23:02:58 <michaelt_> with data Fox x = forall a b. Fox a a (a -> a -> b) (b -> x)
23:05:19 <michaelt_> hm, no. I was trying to reconstruct your expectation ...
23:08:39 <benzrf> [a] ~ Free (a,) ()
23:08:41 <benzrf> right?
23:09:17 <michaelt_> yes
23:09:41 <jle`> hm, inhabited by Pure (), Free (x, Pure ()), Free (x, Free (x, Pure ())) ..
23:09:41 <benzrf> what does Cofree look like
23:09:44 <jle`> looks like it
23:09:50 <benzrf> free comonad, right
23:09:58 <michaelt_> ListT m a ~ FreeT ((,)a) m () , similarly
23:10:35 <michaelt_> pipes Producer a m r = FreeT ((,) a) m r
23:10:43 <michaelt_> similarly
23:10:45 <benzrf> yea
23:10:56 <benzrf> one time i built something isomorphic to a pipe out of frees and composes &c
23:11:04 <benzrf> such that it had the correct instances for fre
23:11:06 <benzrf> e:>
23:11:18 <benzrf> it was painfully awkward to use though
23:11:54 <eds> michaelt_ : Yea it is expecting fox's. which would evaluate to String. I see. thanks.
23:11:58 <michaelt_> but now, with the fancy PatternSynomns ...
23:12:46 <eds> michaelt_: any function to convert a string into an int?
23:13:02 <adarqui> eds, read
23:13:03 <michaelt_> right, Pipe i o m r = FreeT (Compose ((->) i) ((,) o)  m r
23:13:08 <adarqui> > :t read
23:13:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:13:19 <michaelt_> eds: read ... I'm not sure I advise it ...
23:13:36 <michaelt_> @type read
23:13:39 <lambdabot> Read a => String -> a
23:13:41 <adarqui> thnx
23:14:16 <eds> why not use read? I'll try to change the Fox. Just wanted to see if I can create valid trees.
23:14:26 <eds> michaelt_
23:14:45 <hnfmr> what is the difference between the ByteString from Data.ByteString and the one from Data.ByteString.Lazy?
23:14:47 <hnfmr> is the former strict?
23:14:54 <adarqui> hnfmr: ya
23:15:09 <michaelt_> eds it's just very partial. Also, it always needs something to tell the compiler what type it is looking for, so frequently an explicit signature is needed somewhere. 
23:15:35 <benzrf> michaelt_: that looks terribly familiar
23:15:38 <michaelt_> hnfmr: lazy bytestrings are lists of strict bytestrings, not to put too fine a point on it
23:15:41 <benzrf> that may be precisely what i wrote
23:16:10 <eds> ohh ok
23:16:23 <michaelt_> benzrf: wait, but it's wrong, I want the sum one, not compose ...
23:16:27 <hnfmr> michaelt_: thanks.
23:16:54 <benzrf> is it, michaelt_
23:16:59 <benzrf> oh i may have used just Free
23:17:04 <benzrf> not sure mine was a tran
23:18:14 <michaelt_> benzrf: yes, each command is either a function waiting for an input (and returning a new step when it gets one) or else a pair of an output value , and a new step
23:18:58 <benzrf> oh right
23:19:34 <benzrf> ah yeah i think i redid Client (or maybe Server), not Pipe
23:19:42 <benzrf> in which case what you wrote wouldve been correct
23:19:51 <hnfmr> how can i convert ByteString to lazy bytestring?
23:20:09 <michaelt_> benzrf: oh wait I see. I'm just doing the simple pipe type, right. 
23:20:13 <hnfmr> there is toStrict, what's the opposite?
23:20:23 <michaelt_> benzrf: fromStrict
23:21:21 <michaelt_> hnfmr: sorry, I meant to address you: fromStrict
23:21:23 <benzrf> michaelt_: think you meant hnfmr 
23:21:26 <benzrf> guh
23:21:32 <benzrf> @src Cofree
23:21:32 <lambdabot> Source not found. Are you typing with your feet?
23:21:34 <benzrf> hm
23:21:41 <michaelt_> yeah, sorry
23:23:08 <hnfmr> yes,. thanks. that worked :)
23:26:43 <jle`> i was surprised that my code relying on a MonadPlus instance for Either e compiled because there is no such instance in base
23:26:47 <jle`> turns out that it's in transformers
23:26:50 <jle`> instances are weird
23:27:55 <benzrf> orphan instances~
23:34:20 <poincare101> can someone link me to the documentation push to hackage script so I can upload my documentation?
23:36:47 <nkaretnikov> poincare101: there's on in the lens package
23:37:21 <nkaretnikov> poincare101: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
23:37:22 <poincare101> nkaretnikov: how would I use it?
23:37:52 <nkaretnikov> from the command line
23:37:59 <nkaretnikov> read the source, there's a note about usage
23:38:20 <eds> Can I have something like this data SBox = forall a. Eq a Show a => SBox a? I understand why it gives a parse error. But is there a way to write such that 'a' would have attributes of Eq and Show?
23:39:14 <nkaretnikov> eds: that extension was considered a "bad" one and dropped, iirc
23:39:34 <nkaretnikov> eds: put class constraints into the functions instead
23:40:14 <eds> nkaretnikov: an example of how can I do that?
23:40:34 <pacak> eds: You need a comma
23:40:44 <pacak> forall a. (Eq a, Show a) => SBox a
23:41:36 <eds> pacak: that worked. thanks
23:41:52 <pacak> eds: Putting constraints on functions won't work in your case since you won't be able to apply them to contents of your box knowing only "forall a" part
23:42:14 <eds> putting class constraints into function seems interesting. how would I do that?
23:42:32 <eds> ohh ok. 
23:42:41 <poincare101> Could someone take a look at this documentation and tell me if it is any good: https://hackage.haskell.org/package/DCFL-0.1.5.0/docs/Data-DCFL.html
23:43:27 <pacak> poincare101: It's better than no documentation at all :)
23:43:56 <poincare101> pacak: how could I improve it? add examples?
23:44:15 <pacak> poincare101: Examples are nice, there are some typos
23:44:25 <poincare101> pacak: could you point them out?
23:44:46 <pacak> "parallelized./"
23:45:13 <nkaretnikov> eds: oh, sorry, it seems I confused it with something else :\
23:46:07 <pacak> Not sure if printVariables is actually needed
23:46:19 <pacak> and randomNum
23:46:23 <adarqui> poincare101: doctest style examples are good
23:46:29 <eds> np. thanks
23:47:03 <pacak> Not sure about using IO all over the place either.
23:47:11 <pacak> missing type signatures
23:47:48 <poincare101> pacak: I think the functions that use IO are the ones dealing w/ the random numbers
23:47:56 <poincare101> pacak: I'm not sure how I'd prevent that
23:48:28 <pacak> poincare101: You can factor out random number generation - you can pass either seed or random number generator.
23:48:43 <pacak> As a sideeffect this will make your solution reproduceable.
23:49:10 <poincare101> pacak: ah, so the functions receive a random number generator and then based on that they operate?
23:49:22 <pacak> poincare101: Yep. 
23:49:41 <pacak> poincare101: do { foo <-  bar ; return foo } is the same as just foo
23:50:23 <pacak> poincare101: You don't have to export everything.
23:50:54 <pacak> poincare101: type signatures!
23:50:58 <pacak> For everything!
23:51:15 <poincare101> I don't quite understand the "factor out the random number generator". So if I pass in some function that returns a random number "IO Int", then how could I use that in a pure function? 
23:51:24 <adarqui> also poincare101 you have your .cabal-sandbox commited to git
23:51:34 <adarqui> same with the dist folder
23:51:55 <poincare101> adarqui: oops - need to update gitignore
23:51:59 <pacak> poincare101: No, you can pass a generator and use a function that gives a random value and a new generator.
23:52:17 <nkaretnikov> eds: here's what I meant: can't you just do this? newtype SBox a = SBox a; elem :: (Eq a) => a -> SBox a -> Bool; elem x (SBox y) = x == y
23:52:17 <nkaretnikov>  
23:53:33 <adarqui> you can rewrite that history and remove it: 
23:53:33 <adarqui> git filter-branch --force --index-filter "git rm -r --cached --ignore-unmatch .cabal-sandbox" --prune-empty --tag-name-filter cat -- --all
23:53:35 <ronh> randomIO* functions are just a convenience wrappers around non-io random functions
23:53:37 <pacak> nkaretnikov: How is it better than using just a?
23:53:37 <adarqui> git filter-branch --force --index-filter "git rm -r --cached --ignore-unmatch dist" --prune-empty --tag-name-filter cat -- --all
23:53:40 <adarqui> that should work
23:54:09 <adarqui> ya, and add it to .gitignore
23:54:12 <adarqui> word
23:54:40 * hackagebot pipes-cellular-csv 1.0.0.0 - Efficient pipes-based cellular CSV codec  http://hackage.haskell.org/package/pipes-cellular-csv-1.0.0.0 (patrykz)
23:54:47 <nkaretnikov> pacak: well, it depends on the context, no?  you may want to distinguish plain 'a's from sbox ones
23:54:50 <poincare101> pacak: could you provide a simple example?
23:55:15 <pacak> :t random
23:55:16 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
23:55:18 <adarqui> randomR (1,2) (mkStdGen 5) :: [Int]
23:55:25 <adarqui> gr
23:55:28 <adarqui> Int, not [Int]
23:55:54 <adarqui> ya seed it with that 'g'
23:56:05 <pacak> :t random (mkStdGen 1) 
23:56:06 <lambdabot> Random a => (a, StdGen)
23:56:13 <pacak> :t random (mkStdGen 1) :: (Int, StdGen)
23:56:14 <lambdabot> (Int, StdGen)
23:56:17 <pacak> > random (mkStdGen 1) :: (Int, StdGen)
23:56:18 <lambdabot>  (7918028818325808681,545291967 2103410263)
23:56:40 <pacak> poincare101: fst is your random value, snd is your new generator
23:58:10 <pacak> poincare101: You can pass it as it is or put into Reader monad,
23:58:14 <pacak> Hmm.. State
23:59:44 <yayfoxes> ok haskellers, how would you tackle this homework? http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
