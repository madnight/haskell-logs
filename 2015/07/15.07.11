00:01:32 <favetelinguis> is there something similar to sudo apt-get install libghc-hdbc-sqlite3-dev for mac?
00:01:59 <favetelinguis> trying to get hdbc working but im missing this package wich can not be installed from hackage?
00:02:40 <bennofs> In GHC, how are IO actions represented at runtime? I understand that newtype IO a = IO (State# RealWorld -> (State# RealWorld, a)), but what's the runtime representation of this?
00:04:50 <bennofs> in particular, what would the memory overhead of an IO action be? Disregarding optimizations for a moment and assuming that the list is not lazy, is there a difference between join $ foldl' (\x y -> x >> print x) [1..100000] and mapM_ print [1..100000] ? [I know ofc that the first version is not as lazy as the second, and the second starts printing earlier, but let's ignore that for a moment]
00:05:18 <bennofs> or rather, replace the mapM_ print with an explicit loop
00:07:36 * hackagebot splay 0.0.3 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.3 (dramforever)
00:07:36 * hackagebot splay 0.0.4 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.4 (dramforever)
00:08:52 <Saizan> bennofs: you're buikding closures there
00:12:47 <bennofs> Saizan: so is it like a function closure but without any arguments?
00:12:51 <srh> bennofs: if you've got a value of type IO a that's the result of an expression x >>= f or x >> y, imagine the left hand side, "x", getting evaluated, and then "run", and discarded except for its result, and then the right hand side evaluated to produce a value of type IO a, and then it being "run"
00:14:03 <nkaretnikov> does anyone have HBC?
00:17:31 <pavonia> nkaretnikov: What is HBC?
00:18:12 <nkaretnikov> lennert's compiler: https://web.archive.org/web/20060415000000*/http://haskell.org/hbc/hbc-2004-06-29.src.tar.gz
00:18:16 <nkaretnikov> lennart's*
00:19:32 <Saizan> srh: that doesn't help much about how it's represented in memory
00:19:55 <Saizan> bennofs: yah
00:19:59 <srh> Saizan: no?
00:20:47 <Saizan> srh: that's how it is "run", not how it is stored
00:20:51 <srh> the point is the y side isn't built up into a huge thing before you get to it
00:21:13 <Saizan> fair enough
00:22:00 <Saizan> in this case we do build a chain of closures as long as the input list though
00:22:08 <srh> which case
00:22:24 <Saizan> join $ foldl' (\x y -> x >> print x) [1..100000]
00:22:27 <srh> well yes
00:23:05 <Saizan> ?type join $ foldl' (\x y -> x >> print x) [1..100000]
00:23:06 <lambdabot>     Couldn't match type ‘IO ()’ with ‘t a1 -> a’
00:23:06 <lambdabot>     Expected type: t a1 -> t a1 -> a
00:23:06 <lambdabot>       Actual type: t a1 -> IO ()
00:23:10 <bennofs> oh actually made a typo there. you know it should be y, right?
00:23:12 <srh> as opposed to foldr (\x y -> print x >> y) (return ()) [1..100000], which expands to print 1 >> (foldr (...) (return ()) [2..100000])
00:23:38 <Saizan> ?type foldl' (\x y -> x >> print y) (return ()) [1..100000]
00:23:39 <lambdabot> IO ()
00:23:43 <Saizan> more like it
00:26:47 <srh> bennofs: in particular, with foldl' or foldl, you get a value that looks like this:  (((...((return() >> print 1) >> print 2) >> ...) >> print 99999) >> print 100000)
00:27:10 <bennofs> srh: yeah. 
00:27:13 <srh> so your basic naive implementation would have to traverse down into this nested closure
00:27:41 <bennofs> srh: I wonder, how "big" is this closure compared to the original list?
00:28:13 <srh> man i have no clue
00:29:07 <bennofs> so let's just take 'print 0
00:29:14 <bennofs> assuming it is evaluated
00:33:28 <srh> i have no clue how GHC really works with no optimizations (or whatever) but let's say it's a closure that's captured a 0 and will print it.  hell, "print" is of type Show a => a -> IO (), so maybe it's got some "Show a" instance too
00:34:17 <srh> so you've got your Integer, a Show Integer instance, inside this closure, which was only generated when the (w >> print x) was evaluated
00:34:47 <srh> i mean i'm giving you the naivest compiler answer, not the GHC answer which I don't know.  so take it for what it's worth
00:34:51 <bennofs> ok, let's assume full optimizations
00:34:55 <bennofs> ah ok
00:35:01 * bennofs tries reading CMM
00:49:08 <bennofs> does GHC have a flag to dump unoptimized CMM of optimized Core ?
00:50:44 <rjayatilleka> join #haskell
00:50:48 <rjayatilleka> Hello!
00:56:11 <catsup> cabal is not working the way i thought it should, maybe i am doing something wrong...
00:56:49 <catsup> i have a library and an executable in my .cabal file, and the executable just imports the library and provides a main function that runs a function from the library
00:57:12 <catsup> i can't compile the executable without listing all of the build depends from the library in the executable's config
00:58:30 <catsup> i put as a build-depend the name of the package which i thought (based on looking at another cabal file) would make that unnecessary
00:58:59 <catsup> probably nobody is here :/
00:59:19 <Haskellfant> catsup: well if you import those dependencies in your executable you need to list them separately
00:59:34 <catsup> Haskellfant: i'm importing only the library that is built in the package
00:59:39 <bennofs> catsup: do you have your library source code in hs-source-dirs for the executable too
01:00:00 <catsup> no i don't have hs-source-dirs
01:00:02 <bennofs> because if the source directory for library and executable is the same, then cabal won't use the compiled lib
01:00:44 <bennofs> catsup: try putting your executable in a different directory
01:00:47 <rjayatilleka> Quick question, does anyone know if this function exists by a different name? I couldn't find it in Hoogle:
01:01:07 <catsup> bennofs: how do you do that?
01:01:07 <rjayatilleka> diffs :: (a -> a -> b) -> [a] -> [b]
01:01:14 <rjayatilleka> diffs _ [] = []
01:01:33 <rjayatilleka> diffs f xs = zipWith f xs (tail xs)
01:02:04 <bennofs> catsup: create a new directory (for example, "exe"), put your Main.hs in that directory, and add hs-source-dirs: nameofdirectory (for example, hs-source-dirs: exe)
01:02:50 <catsup> that fixed it =D
01:03:08 <catsup> thanks
01:03:19 <catsup> do you happen know why it behaves like that?
01:08:33 <bennofs> catsup: yes
01:08:50 <bennofs> catsup: it's since in the former case, you can also access internal modules of the library
01:09:11 <bennofs> catsup: so cabal cannot use the already-compiled version of the lib, since some of the modules you can use are not exposed
01:09:29 <catsup> bennofs: i see
01:09:32 <catsup> thanks again :)
01:09:41 <Myrl-oneechan> merijn: hai
01:09:51 <Myrl-oneechan> It's been a few months since I last haskelled.
01:09:51 <Myrl-oneechan> :c
01:09:57 <free_beard> hi guys, i'm doing the NICTA course and I got stuck at the State exercises right here https://github.com/NICTA/course/blob/master/src/Course/State.hs#L157 so i figured i'll check the sollution which uses this function here https://github.com/NICTA/course/blob/master/src/Course/State.hs#L157 which for the life of me I can not understand what it does. can you help me with a brief description on what it's supposed to do on its own? thank
01:10:10 <Myrl-oneechan> I mean weeks.
01:10:34 <free_beard> sorry, i meant this https://github.com/tonymorris/course/blob/master/src/Course/State.hs#L177 for the second link
01:11:26 <nadirs> hello, is there any already defined function that converts an Either to Maybe?
01:11:28 <free_beard> normally i follow the types and even if it's a tricky function i could get the gist of it's purpose
01:11:34 <nadirs> Something like `(either (const Nothing) return`
01:12:06 <Myrl-oneechan> :t either
01:12:07 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
01:12:18 <dibblego> free_beard: listWithState is a factored out function; you might read the solution as, firstRepeat = eval (findM (State . lift2 (lift2 (,)) S.member S.insert) x) S.empty
01:13:26 <xandaros> Since every Monad needs to be an Applicative now - does return default to pure?
01:13:32 <free_beard> dibblego: thanks, it might be easier this way
01:13:50 <pavonia> @hoogle Either a b -> Maybe b
01:13:50 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:13:51 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:13:51 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
01:15:18 <ChristianS> nadirs: what you said should work fine
01:15:55 <nadirs> ChristianS: I was wondering if there was a short-hand to hand already available in the "standard" libraries
01:16:31 <merijn> : listToMaybe . rights . pure
01:16:36 <merijn> eh
01:16:40 <merijn> :t listToMaybe . rights . pure
01:16:41 <lambdabot> Either a1 a -> Maybe a
01:16:54 <merijn> Which isn't much shorter :p
01:17:09 <pavonia> :t rights
01:17:10 <lambdabot> [Either a b] -> [b]
01:17:48 <merijn> pavonia: I know, it's very deceptively named ;)
01:18:36 <pavonia> I didn't know such a function exists
01:18:44 <merijn> :t lefts -- too
01:18:45 <lambdabot> [Either a b] -> [a]
01:19:56 <xandaros> no, it doesn't :(
01:20:23 <catsup> know your rights...
01:32:41 <jle`> nadirs: there isn't one in base, yeah; i think one issue is that it's simple enough for people to do their own and any name picked that is simple enough to work might have clashes
01:32:47 <jle`> but it's no big deail
01:33:14 <nadirs> jle`: makes sense :)
01:33:26 <jle`> if you're going to const Nothing then might as well Just though :)
01:35:02 <merijn> xandaros: What doesn't? (whoo, network timeouts!)
01:35:17 <jle`> nadirs: the previously-standard-but-now-considered-obsolete `either` package has leftToMaybe and rightToMaybe
01:35:27 <dibblego> @type (^? _Right)
01:35:28 <lambdabot> Either c a -> Maybe a
01:35:35 <jle`> and yeah, there are those too
01:35:40 <jle`> :t preview _Right
01:35:41 <lambdabot> MonadReader (Either c a) m => m (Maybe a)
01:35:48 <jle`> > preview _Right (Right 10)
01:35:50 <lambdabot>  Just 10
01:35:54 <jle`> > preview _Right (Left 10)
01:35:56 <lambdabot>  Nothing
01:36:04 <nadirs> dibblego: what is that symbol "^?"?
01:36:06 <merijn> jle`: That' just "either Just (const Nothing)" and the the reverse
01:36:15 <nadirs> :t  (^?)
01:36:17 <lambdabot> s -> Getting (First a) s a -> Maybe a
01:36:27 <jle`> merijn: yeah, but nadirs was asking about a pre-packaged synonym
01:36:36 <jle`> which isn't quite worth the hassle imo
01:36:41 <jle`> nadirs: it's `preview` from lens
01:36:47 <jle`> or flip preview
01:37:03 <nadirs> jle`: oh ok, I'm not familiar with lens :P
01:37:04 <merijn> Something, something, Fairbairn threshold
01:38:09 <jle`> yeah heh def.  and also nice possible names would probably collide with people's actual things they define
01:38:48 <jle`> :t either (pure mzero) return
01:38:49 <lambdabot> MonadPlus m => Either a a1 -> m a1
01:39:59 <jle`> :t maybe mzero return
01:40:00 <lambdabot> MonadPlus m => Maybe a -> m a
01:40:12 <merijn> There's no MonadPlus for "instance Monoid m => MonadPlus (Either m)"?
01:40:20 <jle`> there is in transformers
01:40:22 <jle`> but not in base
01:40:25 <jle`> orphan instances are neat
01:41:51 <jle`> or maybe it's in mtl
01:42:09 <jle`> remember the Traversable instance just happened in like 7.8
01:42:35 * hackagebot servant-ede 0.5 - Combinators for rendering EDE templates in servant web applications  http://hackage.haskell.org/package/servant-ede-0.5 (AlpMestanogullari)
01:42:45 <bergmark> really? :-(
01:42:52 <jle`> yea :|
01:43:21 <merijn> bergmark: Lots of things get forgotten at times, just because no one thinks of it
01:43:32 <bergmark> but i was so happy that orphans disappeared in the new transformers :(
01:43:36 <merijn> Look on the bright side...Bifunctor in base now! :D
01:43:42 <jle`> :D
01:43:48 <bergmark> bifunctor yeey
01:44:07 <jle`> biggest benefit is a more sensible first and second
01:44:15 <jle`> but i don't think lambdabot has the right one imported
01:44:16 <bergmark> but for me bifunctor is currently just a less backwards compliant import of first and second :P
01:44:16 <jle`> :t first
01:44:17 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
01:44:44 <free_beard> :t liftA2
01:44:44 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:46:46 <bergmark> i have been trying to fix build errors in older versions of http-conduit, but got stuck at time orphans :( (luckily they are gone on github!!)
01:47:27 <jle`> i think there's a guide for the time orphans issues?
01:48:15 <phaazon> hi
01:48:24 <jle`> hi phaazon 
01:49:50 <bergmark> jle`: import the module if you use the instance? :) anyway, can't do anything about it on an existing release unless i find the magic combo of dependency versions that gets the import transitively :-/
01:50:10 <augur> anyone know how to update packages in a cabal sandbox?
01:51:04 <jle`> if the dependencies are complex then it might be best to just start afresh, but if not then you might be able to get away with unregistering and re-installing
01:52:34 <augur> hmm
01:52:57 <bergmark> jle`: oh it's not locally, it's on http://matrix.hackage.haskell.org
01:59:24 <wyager> Whoa. Compiling with -O2 makes my code over 14 times faster than -O.
01:59:30 <wyager> Never had that before
02:01:54 <wyager> I find it quite impressive how the standard Vector library operations beat the pants off my "hand-tuned" "fast" versions of certain things
02:01:58 <Walpurgisnacht> Bye
02:02:13 <wyager> Whatever Data.Vector is doing, it definitely benefits from maximum GHC optimization
02:03:14 <erikd> wyager: much work has gone into ghc to make the vector stuff fast :-)
02:03:54 <wyager> Clearly. Does this work generalize to other libraries like Array, or does GHC target Vector in particular?
02:05:44 <erikd> wyager: much of ghc's optimisation is based on either stream fusion or inlining. that is pretty widely applicable to things other than vector.
02:06:12 <wyager> Do you know why -O2 might be drastically more effective than -O? 
02:06:44 <erikd> i suspect -O doesn't do inlining while -O2 does :-)
02:06:49 <wyager> Cool
02:06:55 <thoughtpolice> No, -O2 turns on Call-pattern specialization (-fspec-constr, kind of a misnomer), which is totally critical for vector
02:07:31 <erikd> wyager: listen to thoughtpolice and now me :-)
02:07:37 <erikd> s/now/not/
02:07:48 <bergmark> AND NOW ME
02:07:54 <erikd> i heard that thoughtpolice was currently on holidays
02:08:41 <erikd> bergmark: i did correct that :-)
02:08:42 <wyager> thoughtpolice: So, if I understand that correctly, it makes a special version of certain functions where it takes all the arguments of a certain constructor unpacked, so the program doesn't have to build the constructor, match on it, and deconstruct it?
02:08:49 <thoughtpolice> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-optimise.html, ctrl+f '-fspec-constr', there's an example I wrote for the manual a while back.
02:10:30 <thoughtpolice> wyager: Yes, that's the basic idea. And it's very important for vector. You can try -O1 -fspec-constr and probably recover most of the performance.
02:10:49 <kqr> can I inside the Q monad resolve a VarE to its value in the context where the quotation was created?
02:10:52 <thoughtpolice> erikd: I am, but I'm not vanished... I just happened to be here right now :)
02:11:57 <wyager> thoughtpolice: You're right, that seems to be the most important factor.
02:12:48 <eds> Error on line 27. I have pasted the error along with code here: http://lpaste.net/132328
02:13:06 <eds> If somebody can help me out. thanks
02:16:18 <eds> The error is related monad random.
02:16:35 <kqr> eds, it doesn't know how to generate random values between "IntExp 1" and "IntExp 3" because you haven't told it how to generate IntExp values
02:17:07 <wyager> thoughtpolice: What is the purpose of SPEC2?
02:17:23 <pacak> eds: You don't have Random instance for IntExp
02:17:34 <jocoH> can hasktags generate tags for identifiers that were imported ? or only for identifiers that are declared in the same file ?
02:18:00 <eds> kqr, pacak: I see. so should I make IntExp and instance of random first?
02:18:01 <pacak> eds: Either write your own or change it to a newtype and use GeneralizedNewtypeDeriving
02:18:50 <eds> pacak: some start on how would I do that?
02:19:36 <thoughtpolice> vvfhrnddbtnbudklbltbujnutjuijeetnculrelgrflh
02:19:47 <thoughtpolice> Ugh, stupid keyboard
02:19:48 <pacak> eds: Go into System.Random and check how instances for Int are written?
02:20:04 <eds> ahh. roger that.
02:20:05 <thoughtpolice> Oh, I figured it out *ugh*
02:21:03 <thoughtpolice> wyager: IIRC it's some implementation work around, where GHC eliminates the constructor too early with only a single one. It doesn't matter which you use IIRC (since it just matches on the 'SPEC' type itself).
02:21:11 <jocoH> it seems i need codex
02:21:33 <wyager> thoughtpolice: is it possible to make GHC use all the SPEC optimizations on every single loop?
02:21:53 <thoughtpolice> The whole 'forced' spec-constr thing a-la 'data SPEC' is quite a hack. But I don't think anyone knows a better way to get vector to generate code without having the optimizer simply be extremely aggressive.
02:22:27 <thoughtpolice> No, there's no implementation of this. It probably wouldn't help much in most cases, and would likely just make the compiler waste more cycles than it's worth. I'd assume, at least.
02:22:55 <wyager> Interesting. Thanks.
02:24:05 <phaazon> hey, does ghc-mod compile from hackage for you?
02:24:11 <phaazon> it doesn’t for me :/
02:25:07 <nkaretnikov> how can I create a value of type State#, so I could use readInt32OffAddr#?
02:25:21 <nkaretnikov> (both are defined in GHC.Prim)
02:25:21 <dramforever> nkaretnikov: you can't
02:25:46 <nkaretnikov> well, I mean, how is readInt32OffAddr# supposed to be used?
02:26:11 <nkaretnikov> readInt32OffAddr# :: Addr# -> Int# -> State# s -> (#State# s, Int##)
02:26:13 <dramforever> oh wait you have two options
02:26:16 <nkaretnikov> I have an Addr# and an Int#
02:26:23 <nkaretnikov> I only need State# 
02:26:24 <nkaretnikov> s
02:26:28 <dramforever> check the definition of IO
02:27:42 <dramforever> http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Types.html#t:IO
02:29:24 <nkaretnikov> dramforever: I don't get it.  how is it relevant?
02:29:55 <Cale> nkaretnikov: When you write an IO action, you're provided with a "value" of type State# RealWorld
02:30:44 <Cale> (as the parameter to the function you're writing)
02:30:48 <nkaretnikov> Cale: I mean, I see the type signature etc.  I just don't understand how to pass that to my function.
02:30:57 <nkaretnikov> (readInt32OffAddr#)
02:31:03 <Cale> But... how did you get into this mess?
02:31:55 <nkaretnikov> I'm trying to perform some operations without boxing to see whether it'd make a difference
02:32:31 <Cale> So, you'll want to use the IO constructor, I suppose
02:33:06 <Cale> IO (\s -> readInt32OffAddr# a n s)
02:33:30 <Cale> (or even without the lambda, you can eta-reduce that)
02:33:52 <nkaretnikov> I'll try searching through the ghc source, maybe it's used for something
02:34:33 <Cale> Are you looking at core code and trying to optimise from there?
02:36:46 <nkaretnikov> Cale: no, I'm looking at my previous implementation and trying to re-implement it with as little code as possible
02:37:00 <Cale> nkaretnikov: Before you go to much trouble writing a whole bunch of stuff in terms of unboxed primitives, it's probably worth looking at the output of -ddump-simpl and seeing whether the stuff is already being unboxed by GHC
02:37:18 <nkaretnikov> hm, that's a good advice
02:40:39 <Cale> If nothing else, you can often steal a bunch of code from Core and rewrite it back into valid Haskell if you find you want to tweak how things are happening after all -- it's not always entirely straightforward to do that, but it's often easier than writing the low-level code from scratch.
02:47:08 <nkaretnikov> Cale: okay, it seems it's supposed to be used inside ST
02:47:19 <nkaretnikov> ST $ \s -> ...
02:47:39 * hackagebot splay 0.0.5 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.5 (dramforever)
02:47:48 <dramforever> nkaretnikov: it's almost the same for IO
02:48:10 <dramforever> just IO uses RealWorld, where ST lifted that out to a parameter
02:50:37 * dramforever imagines a version of Core that is literally a subset of haskell
02:55:59 <wyager> Another interesting performance thing: for some reason, GHC is totally failing to inline a really trivial function. Just by copy/pasting the function body and putting it in place of the function call, I double my program's performance
02:56:01 <wyager> even with -O2
02:56:29 <wyager> I'm curious how it decides what to inline
02:56:58 <latk> Is it possible to use an Aggregator in opaleye to have a query return [SomeCol] ?
02:58:05 <wyager> Even stranger, repeating the process of manually inlining elsewhere makes it 22 times slower...
02:59:30 <wyager> Optimization is hard
02:59:57 <kqr> what is "join . fmap" a sign of?
03:00:06 <dramforever> :t join . fmap
03:00:07 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
03:00:07 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
03:00:07 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
03:00:11 <kqr> whoops
03:00:13 <kqr> sorry
03:00:14 <dramforever> kqr: type error
03:00:16 <kqr> join . fmap sequence
03:00:48 <dramforever> :t join . fmap sequence
03:00:49 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
03:01:13 <wyager> Or, to put it a bit more concretely, m [m a] -> m [a]
03:01:32 <kqr> I feel like I've been missing an obvious place to use something like >>= when I've ended up with a combination of join and fmap
03:01:54 <dramforever> kqr: you are right :P
03:02:12 <ronh> :t (>>= sequence)
03:02:13 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
03:02:39 <bergmark> kqr: i know i've had to use join fmap but i can't think of why/what
03:02:45 <dramforever> :t (\m f -> join (fmap f m))
03:02:46 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
03:02:58 <kqr> there we go
03:02:59 <kqr> thank you
03:03:06 <dramforever> =) yw
03:03:17 <jle`> join fmap is a thing
03:03:29 <jle`> > join fmap (*2) 5
03:03:30 <lambdabot>  20
03:03:50 <bergmark> i found this nice helper function
03:04:08 <bergmark> @type \c p f g o n -> c <$> join (p <$> f o <*> g n)
03:04:09 <lambdabot> Monad f => (a -> b) -> (a2 -> a1 -> f a) -> (r -> f a2) -> (r1 -> f a1) -> r -> r1 -> f b
03:04:15 <ronh> join (fmap f m) is always the same as f =<< m 
03:04:41 <jle`> bergmark: i feel like that is one of those cases where do notation shines
03:04:43 <jle`> :p
03:06:26 <stannny> hi. is haskell useless?
03:06:28 <dramforever> join (fmap f m)  ---->  fmap f m >>= id  ---->  m >>= return . f >>= id  ---->  m >>= (\x -> return (f x) >>= id)  ---->   m >>= f
03:06:32 <bergmark> stannny: absolutely
03:06:33 <maerwald> stannny: exactly!
03:06:37 <dramforever> horray for equational reasoning
03:06:42 <dramforever> stannny: can you elaborate?
03:07:05 <maerwald> stannny: making haskell useful is very hard, but it pays off
03:07:10 <stannny> dramforever: one of the haskell makers called haskell useless
03:07:23 <maerwald> right, it's mainly because we are very strict with IO
03:07:44 <bergmark> https://www.youtube.com/watch?v=iSmkqocn0oQ
03:07:44 <wyager> stannny: There was probably some nuance to that statement
03:07:46 <stannny> Simon Peyton Jones
03:07:48 <dramforever> that's probably ironically saying haskell is different =P
03:07:49 <maerwald> but it turns out you get a lot of benefits out of that (as in: not having "free" IO)
03:07:51 <JuanDaugherty> stannny, not exactly but sorta
03:07:57 <maerwald> dramforever: not at all
03:08:08 <maerwald> dramforever: he is describing the way to nirvana
03:08:13 <dramforever> hmm...
03:08:23 <JuanDaugherty> let's say it's a lil challenged in making its way into widely used apps
03:08:59 <JuanDaugherty> particularly in contrast to the fervor of its adherents
03:09:08 <dramforever> maerwald: so it's like someone said "when sodium catches fire water is useless" and all the people began saying "he said 'water is useless'"?
03:09:29 <maerwald> I don't know what you are talking about
03:09:32 <alpounet> dramforever: have you done benchmarks on your splay package? just saw it in "what's new" on hackage, so i might have missed comments about that 
03:09:49 <dramforever> alpounet: no =P
03:10:07 <dramforever> I'm just doing it because I got fed up doing it in C++
03:10:20 <dramforever> maerwald: never mind it's a bad example
03:10:42 <dramforever> alpounet: well I think I could compare it with splaytree
03:12:27 <maerwald> stannny: a good example is... if you have some geometrical algorithm and you want visualize it as you go, then you got a problem. Because drawing stuff to the screen will force you to change your types (IO) and will probably break compositionality of the code you already wrote. So you need to think more abstract/indirect to solve that properly. In that sense, you could call haskell useless. But there are benefits to that approach.
03:12:35 <bergmark> purity: you have this black box and you press go and it gets hot
03:13:06 <maerwald> more generally: adding effects to an existing codebase in haskell is always a bit harder, since effects are always represented by the types
03:13:28 <Cale> stannny: He didn't really call the Haskell of today useless.
03:13:48 <maerwald> Cale: we are still not in nirvana though
03:13:51 <maerwald> not even close
03:14:05 <Cale> Well, Haskell is pretty usable nonetheless.
03:14:20 <maerwald> true
03:14:25 <ronh> maerwald I believe he refers to old haskell when he is calling it useless, when it had clumsy IO
03:14:31 <ronh> haskell 1.0
03:14:40 <dramforever> alpounet: Well actually versions 0.0.1 to 0.0.3 are totally wrong, version 0.0.4 won't compile on ghc before 7.10
03:14:51 <dramforever> So I was focused on those stuff
03:15:23 <Cale> Yeah
03:15:43 <maerwald> ronh: it doesn't matter, because it's just to illustrate the approach haskell took
03:16:24 <Cale> Right, it was a bit more of an abstract discussion of how the approach to the construction of the language went.
03:17:13 <Cale> i.e. don't compromise principles just because it will let you write real-world programs sooner -- figure out how to do practical stuff in a more principled way instead.
03:17:39 <stannny> so ihaskell stil useless in some way..or less useful than other languages
03:17:43 <maerwald> sometimes I think... by the time haskell reaches nirvana, it will be _actually_ useless to common folk, because people won't understand it anymore :P
03:17:53 <maerwald> stannny: depends on how you want to program
03:18:15 <maerwald> if you want to quickly add effects to your codebase as you go, then it's pretty useless
03:18:25 <maerwald> if you want to design stuff properly and think ahead, then not
03:19:58 <maerwald> I guess it must be hell for a ruby programmer who are used to all sort of manipulation magic
03:21:24 <|f`-`|f> huh
03:21:44 <|f`-`|f> haskell form what I've seen has been making even more complicated things accessible
03:22:13 <|f`-`|f> post-layering you can more or less throw concurrency, and IO, and whatever in a similar manner
03:22:36 <|f`-`|f> with moves to approach dependent typing, and distributed programming in the same light
03:23:19 <|f`-`|f> It's not so much magic, rather that the magic is explicit
03:24:01 <Cale> stannny: I would generally disagree with that. Haskell is more usable for most things than most of the programming languages which are popular in industry.
03:24:54 <|f`-`|f> (there is a sleeper movement to adopt pretty much everything functional languages that have strong compilers in other languages, and industrial applications)
03:24:57 <Cale> stannny: There are a few areas where it's probably inappropriate to try to use it, like if you're building programs for very small machines, or hard-realtime applications, then using Haskell *directly* is probably a bad plan.
03:26:36 <Cale> But there are some really cool approaches to using Haskell as a meta-language in cases of that sort, like atom, which was used to write hard-realtime control software for hybrid-hydraulic vehicles (like garbage trucks), and is a Haskell library for writing programs that schedule and emit C code.
03:27:41 <maerwald> Cale: If that was the case "more usable for most things" than it would have been adopted by industry on a larger scale. It hasn't. Only in specific areas.
03:28:26 <Cale> maerwald: Well, okay, once you take into consideration the factor of "how easy is it to hire someone cheaply to program in this?", then maybe it's not as usable.
03:28:53 <Cale> Or "how easy is it to pick this up so I can use it myself, given that I already know a bunch of imperative languages?"
03:29:34 <maerwald> Cale: I think the "hiring" point is very important
03:30:00 <maerwald> which also implicitly involves how easy it is to learn
03:30:25 <|f`-`|f> (fast business solutions are not necessarily the best idea)
03:30:47 <|f`-`|f> (it's the basis of the /skilled/ labor market)
03:30:48 <wyager> Do not assume that popularity has a strong positive correlation with usability, quality, or any other desirable factor
03:30:50 <Cale> In absolute terms, I don't think it's hard to learn. But it's not a reskin of a language that everyone already knows.
03:31:06 <Cale> (and so it's more akin to learning to program from the beginning again)
03:31:11 <maerwald> Cale: I think haskell is a very problematic choice for the gaming industry, because most of the time they don't really have a very precise specification and just hack up stuff as they go or as they get input. Such a workflow is really not easy with haskell.
03:31:30 <|f`-`|f> Hmmm
03:31:39 <catsup> i don't think that's true at all
03:31:43 <|f`-`|f> I can see use for it
03:31:53 <maerwald> some dev just wants to add timing to a random function and will have change the types of half of the codebase
03:32:00 <|f`-`|f> efficient/secure netcode
03:32:15 <maerwald> but he will probably give up before that :P
03:32:26 <Cale> Well, I used Haskell at a startup (which unfortunately ran out of money) working on an action RPG in Haskell
03:32:48 <|f`-`|f> well, they will be able to fix all the problems that would've flown under the radar, maerwald 
03:33:16 <Cale> I wish I had more to show for it, but I don't think Haskell itself was in any way a problem for us, and in many ways, enabled us to do lots of cool things with our game engine.
03:33:46 <|f`-`|f> Can you still use the engine, or?
03:33:49 <maerwald> Cale: since frag there has been nothing like that again. I don't think that is coincidence.
03:34:03 <maerwald> ofc there are a lot of factors and reasons
03:34:09 <catsup> maerwald: well, that can happen, but it doesn't require precise specification up-front to avoid
03:34:11 <Cale> |f`-`|f: Well, a lot of the design work that went into the game engine is now Reflex
03:34:27 <maerwald> but one is IMO that haskell doesn't perform well for some workflow patterns that are widely used because of imperative languages that have free IO
03:34:35 <Cale> and reflex/reflex-dom has a bunch of production success stories, but not for games
03:34:36 <maerwald> switching them to haskell would involve a shift of thinking
03:34:45 <maerwald> and that's not going to happen soon
03:34:55 <|f`-`|f> hilariously
03:35:10 <|f`-`|f> the languages are doing it for them in little ways
03:35:18 <Cale> maerwald: I'm not sure I agree with that sentiment. You can do imperative programming just fine in Haskell if you want, it won't get in the way.
03:35:28 <maerwald> Cale: that was not my point
03:35:36 <Cale> maerwald: You just might not want to, because there are nicer ways to get things done in Haskell :)
03:36:04 <|f`-`|f> Like the backtracking you can get with parsers writen with Alternative
03:36:37 <|f`-`|f> So, is Reflex a haskell module?
03:36:44 <Cale> yes
03:36:56 <Cale> http://hackage.haskell.org/package/reflex
03:37:23 <Cale> https://www.youtube.com/watch?v=mYvkcskJbc4 -- really good talk about it :)
03:37:28 <|f`-`|f> thanks
03:38:28 <maerwald> Cale: the difference between toy implementations (of e.g. some gaming AI algorithm) and a serious implementation is greater in haskell than in other languages, because you can't just add effects as you go. Every time you want to make it more useful you have to think of it from "scratch". That surely has advantages, but also disadvantages.
03:38:45 <Cale> I don't think I agree with that statement at all
03:38:58 <Cale> 'have to think of it from "scratch"'
03:39:03 <Cale> -- totally disagree
03:39:22 <catsup> maerwald: you can add effects as you go
03:39:50 <maerwald> catsup: sure, but it's not the same as in other languages, so you end up refactoring it totally
03:39:58 <Cale> Not necessarily
03:40:07 <Cale> It depends on how you wrote the thing in the first place.
03:40:09 <catsup> maerwald: no
03:40:20 <maerwald> Cale: without knowing what it will be
03:40:22 <maerwald> which is the point
03:40:28 <catsup> you don't have to know what it will be
03:40:46 <Cale> and by and large, even if you made no provision for effects, you can still split things up without trouble most of the time such that you use the pure code from the effectful code
03:40:48 <catsup> you just have to know how to do things
03:41:47 <Cale> Perhaps you could show me an example of a program where you're stuck being unable to add effects to it?
03:41:47 <catsup> i mean looking at real haskell applications it is very common to see some MonadIO-based monad that is used everywhere
03:41:54 <Cale> ugh
03:42:03 <maerwald> Cale: I did not say that I am stuck being unable to add effects
03:42:22 <maerwald> I am not sure if you got my point, but I think this isn't ontopic anymore anyway
03:42:30 <catsup> so there is liftIO available all over the place
03:42:38 <|f`-`|f> I was curious how'd you restrict text boxes
03:42:44 <Cale> catsup: Well, sure, in those cases, it's easy to add more I/O :)
03:43:48 <Cale> catsup: But I don't have much love for designs of that sort which apply a bunch of monad transformers to IO -- at least most of the time. There are cases where it's not terrible, but it takes a bunch of work to get it right.
03:44:28 <Cale> |f`-`|f: Are you referring to the reflex presentation? :)
03:44:36 <|f`-`|f> Yeah
03:44:47 <|f`-`|f> Been wondering how much you can strew with things
03:45:19 <Cale> oh, wait, that's the kinda blurry version of the talk
03:45:34 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI slides clearer in this one
03:45:47 <catsup> Cale: do you think it would be a bad idea to do a game that way?
03:47:19 <Cale> catsup: Well, it's not about the end application so much as how well you can capture all the operations you want in your monad. It's a nice pattern to apply in cases where you can easily capture all the actions in your new monad in a single module from which you don't export the newtype constructor, so you can hide the fact you're using monad transformers altogether.
03:47:46 <Cale> (even better if somehow you won't even need liftIO from outside there)
03:48:58 <Cale> In cases like that, monad transformers can get you to a usable implementation of your monad a lot more quickly than writing it by hand a lot of the time.
03:49:39 <|f`-`|f> are there links to the exmaple uses
03:51:26 <Cale> There's a link to the slides in the video description. https://obsidian.systems/reflex-nyhug/#/step-1
03:52:51 <|f`-`|f> I mean the example applications, RedLine, Pravsa
03:54:03 <Cale> hmm...
03:54:42 <Cale> https://prasava.com/
03:54:50 <Cale> I don't know where redline is...
03:55:35 <Cale> |f`-`|f: Ask RyanTrinkle next time you see him online :)
03:55:48 <|f`-`|f> what's their handle
03:55:53 <Cale> RyanTrinkle
03:56:19 <Cale> But yeah, the slides are themselves an example application as well :)
04:00:42 <|f`-`|f> Todo didn't work
04:00:45 <|f`-`|f> tweets did
04:00:54 <|f`-`|f> couldn't do much passthe authorise
04:00:58 <|f`-`|f> the pop up was neat
04:01:24 <|f`-`|f> regardless, real talk
04:01:37 <|f`-`|f> This is the internet, at least hyperlink references
04:03:52 <saulzar> |f`-`|f, Theres a channel #reflex-frp 
04:05:48 <saulzar> |f`-`|f,  I've toyed with using it for games a bit
04:06:03 <|f`-`|f> How'd that blow over
04:06:46 <nkaretnikov> how/when does ghc optimize operations on constants, e.g. 32 + 8 reduced to 40?
04:07:11 <saulzar> |f`-`|f, Quite well for what I was doing. Though I've ended up wanting to improve the tools before I go back to the game, written a websockets lib - writing a higher level html lib etc.. 
04:08:38 <|f`-`|f> making a browser game, and online?
04:09:11 <harrysw2> hello. #yesod is a bit quiet today, so if it is ok I would ask a persistent question in here.. I have data Foo = Bar | Baz in one module, and I want to use derivePersistField "Foo" in another. is this doable? I am getting weird errors that I don't understand (I can paste them)
04:09:40 <catsup> harrysw2: yea i've done that
04:10:28 <catsup> harrysw2: is it something about stage restriction?
04:10:54 <harrysw2> catsup yes!
04:11:05 <harrysw2> (I tried to paste a single line of error and I got disconnected, odd)
04:11:23 <nkaretnikov> harrysw2: well, just do it in a different module
04:11:33 <nkaretnikov> harrysw2: call it .Internal or something
04:11:40 <catsup> yeah you've got to use an extra module because of template haskell
04:11:41 <harrysw2> GHC stage3 restriction, instance for `PersistFieldSql Test' is used in a to-level splice or annotation, and must e imported, not defined locally
04:11:58 <harrysw2> oh
04:12:19 <harrysw2> so just a new module for a bunch of derivePersistField calls?
04:12:57 <catsup> the way that i did it was to have Model.hs do the mkPersist, and then have a Model/Types.hs to put that other stuff in
04:13:21 <nkaretnikov> harrysw2: I can show you an example project if you want
04:14:45 <harrysw2> it would be ideal if I could do the same with regular types, having data Person = Person { personName :: String ...} in one module, that is unaware of persistent, and then have persistent generate all the necessary things for it in another. intead of defining data with share macro
04:14:50 <harrysw2> is that doable too?
04:15:00 <harrysw2> nkaretnikov sure
04:15:04 <catsup> harrysw2: yeah
04:16:38 <catsup> harrysw2: you can have Model/Types.hs (or whatever) consist of just imports and derivePersistField, and have it derive fields for stuff it imports
04:19:37 <harrysw2> what would be stand alone equivalent of share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase| by the way? to call for a data type that was already defined. so that I know what to search for 
04:21:10 <catsup> eh, i don't understand...  you should not have to change that part
04:22:11 <catsup> or else i misunderstood what you were going for
04:30:06 <harrysw2> catsup I am talking about defining data Person = Person { ... } in a person package, which does not depend on persistent, and then using share [mkPersist etc  equivalent on it
04:30:56 <catsup> yeah but what do you mean using it on it.  i thought you meant just using it as a type in a database field
04:32:24 <catsup> s/\./?
04:33:55 <harrysw2> by using it I mean storing it in a persistent database. share macro defines a lot of boilerplate to be able to store objects of that type, and I want to generate that boilerplate for a type that was already defined elsewhere using regular haskell sunx
04:34:36 <harrysw2> regular haskell syntax
04:34:40 <catsup> ok, but you still need to use 'share' to generate the persist key, id, etc. and whatnot types
04:35:41 <catsup> you just make reference to the type of data you want to store, inside the [persistLowerCase| ... |]
04:35:43 <harrysw2> but doesnt share create a new data ty
04:35:52 <catsup> yeah it creates a whole bunch of new types
04:35:54 <harrysw2> type
04:36:06 <catsup> you need those types to use persistent
04:36:37 <harrysw2> I would like to store existing type, if 
04:36:43 <catsup> it creates at least 2 types per field plus more per table
04:37:00 <catsup> yeah that's no problem.  just use the existing type in the field definition!  instead of saying Text or Int or whatever, say Person
04:38:54 <catsup> is what you are going for that you want to define Person somewhere, and then have its individual fields become separate columns in the resulting db table?
04:39:55 <harrysw2> but what if I am storing Person? it is not a field of something I am storing, but the very thing I want to store
04:40:31 <harrysw2> yes I think
04:40:48 <catsup> well, the 'things' that you store in a database, ultimately, have to be rows in tables...
04:41:12 <catsup> persistent fields correspond to columns in those rows
04:42:07 <harrysw2> so Person's fields should be peristent fields, somehow?
04:42:56 <catsup> it goes against the design of persistent to try to define the type that represents an entire row, independently of persistent...  because the row type that persistent generates includes a db key, and it also includes the capability to reference other db tables with foreign keys
04:43:51 <catsup> you can store the entire Person object into a single field.  if you want separate db columns though, you have to have persistent generating the type that represents the row that contains those columns
04:45:55 <catsup> either way is reasonable, really...  the first way does not let you query the internal fields of the object through sql, but often that does not matter
04:46:02 <catsup> so it depends on whether you need to do that
04:47:02 <harrysw2> hmm, so I am not sure how to design this. for testing purposes I rewrote Person datatype with share macro, but in the real program I want to store Person data that is already defgined elsewhere. so I would do something like share ... PersonEntry person Person?  or PersonEntry name String\nage Int\n.. (basically, redefining it again with share)
04:47:27 <harrysw2> and then write Person -> PersonEntry  and PersonEntry -> Person functions?
04:48:44 <catsup> hm, well, actually...
04:50:15 <catsup> i mean really what persistent generates is a PersistEntity instance
04:50:44 <catsup> you can see what it looks like here: http://www.yesodweb.com/book/persistent#persistent_code_generation
04:51:55 <catsup> you can see how it is actually possible to do what you want, but i don't think that persistent has any template haskell that does it
04:52:14 <lpaste> catgocat pasted “foldingFunction parse error” at http://lpaste.net/136329
04:52:18 <catsup> you can see how it would be easy to add that feature
04:53:08 <catsup> you could just have a mkPersist that omitted the 'data ...' part but otherwise worked the same (that would rely on you having imported a type that exactly matches)
04:53:54 <catsup> if you care that much about it, you could just use a patched version of mkPersist
04:55:09 <harrysw2> I am not even sure if that is really what I want, since I am using persistent for the first time. what would be idiomatic way of storing Person that was defined elsewhere?
04:55:10 <catsup> (and maybe that already exists, i duno)
04:55:23 <harrysw2> or, how would you do it?
04:56:24 <catgocat> it's so annoying, I press tabs instead of spaces and the compiler doesn't like it
04:57:48 <barrucadu> Can't you have your editor insert the correct amount of spaces whenever you hit the tab key?
04:58:52 <catgocat> barrucadu: yes, but it sometimes switches back and it fucks up everything. Also, when I'm using online editors (for challenges or something) it's all a big mess
05:00:44 <catsup> harrysw2: it all depends on your needs/preferences...  the way you want to do it seems quite reasonable to me, but the template code doesn't seem to exist to do it.  ideal solution is to fix that.  personally i would probably go the lazy route and either just do what you said with conversion functions, or store the whole object in a single column
05:08:08 <nkaretnikov> til
05:08:12 <nkaretnikov> @let 6 = 2
05:08:13 <lambdabot>  Defined.
05:08:16 <nkaretnikov> > 6
05:08:17 <lambdabot>  6
05:09:15 <catsup> wtf
05:09:38 <catsup> is there any way to get that binding back
05:09:49 <catsup> i mean get to the bound value
05:19:21 <nkaretnikov> how do I create a value of type Char#?
05:19:45 <nkaretnikov> it seems chr# is the only way
05:20:06 <dramforever> nkaretnikov: try 'x'#
05:20:23 <dramforever> :t 'x'#
05:20:26 <lambdabot> GHC.Prim.Char#
05:20:35 <dramforever> ?
05:21:14 <dramforever> is lambdabot down?
05:23:21 <dramforever> nkaretnikov: no lambdabot says otherwise =P
05:23:28 <nkaretnikov> dramforever: tried that, doesn't work for me
05:23:52 <nkaretnikov> oh, nevermind
05:23:58 <nkaretnikov> I guess I did something wrong
05:27:57 <Falkyouall> hellou people, can anybody explain to me what arguments this function takes? i dont understand it at all
05:28:02 <Falkyouall> compose' :: [a -> a] -> a -> a
05:28:02 <Falkyouall> compose' xs y = foldr (\f x -> f x) y xs
05:29:49 <Falkyouall> i actually dont know how to run this function...its pretty confusing to me
05:30:04 <dramforever> @let compose' xs y = foldr (\f x -> f x) y xs
05:30:05 <lambdabot>  Defined.
05:30:21 <dramforever> > compose' [(+1), (*2), (+5)] 4
05:30:23 <lambdabot>  19
05:31:01 <dramforever> Falkyouall: it takes two arguments, first is a list of functions, second is a value
05:31:07 <notdan> Falkyouall: it takes a list of functions and composes them
05:31:19 <dramforever> well that's equivlent
05:31:25 <quchen> \f x -> f x === ($)  is that helps
05:31:26 <notdan> you can read it like [(a -> a)] -> (a -> a)
05:31:26 <dramforever> *equivalent
05:31:58 <quchen> compose' [f,g,h] x = f $ compose' [g,h] x = … = f $ g $ h $ x
05:32:06 <Falkyouall> got it
05:32:41 <Falkyouall> its extremely confusing, especially foldr with lists, somthing like unzip with foldr is hard to understand
05:34:19 <dramforever> well foldr is kinda like a design pattern
05:35:10 <dramforever> if you have f [] = z; f (x : xs) = foo (f xs) you can turn that into f xs = foldr f z xs, or equivalently, f = foldr f z
05:36:55 <Falkyouall> i mean i know that it takes the acc as the last argument to apply a function, but when a function is smthn like 
05:36:56 <Falkyouall> myFilter2 f = foldr (\x y -> if f x then x:y else y) []
05:38:00 <quchen> foldr doesn't have an accumulator.
05:38:04 <notdan> I like to think of foldr as replacing the building blocks of the list datatype
05:38:12 <dramforever> well I agree that the y is a pretty confusing name =P
05:38:27 <Falkyouall> for a list.. yea
05:38:40 <notdan> you can obtain 'foldr f z ls' by replacing the ':' in 'ls' with 'f' and the empty list '[]' with 'z'
05:38:44 <dramforever> :t confusing -- by the way, here's a joke, don't try do understand it
05:38:46 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
05:38:51 <dramforever> s/do/to/
05:39:47 <kuribas> Falkyouall: foldr f fnil (a:(b:(c:d))) === (a `f` (b `f` (c `f` (d `f` fnil))))
05:39:57 <notdan> https://wiki.haskell.org/Fold#List_folds_as_structural_transformations
05:40:41 <kuribas> Falkyouall: See how (:) become `f` and [] becomes fnil?
05:41:23 <kuribas> ehm I missed []: foldr f fnil (a:(b:(c:(d:[])))) === (a `f` (b `f` (c `f` (d `f` fnil))))
05:42:09 <dramforever> to me the "recursion pattern" is the easiest to understand
05:42:42 <Falkyouall> yeah recursion is good, i like the one liners, but i want to really understand whtas going on 
05:43:14 <Falkyouall> i can do the function with recursion no problemo, but foldr / foldl is sometimes hard...
05:43:54 <kuribas> Falkyouall: So replace `f` with $ and you get: (a $ (b $ (c $ (d $ x))))
05:44:15 <Falkyouall> in myFilter?
05:44:49 <kuribas> in the definition of foldr
05:45:36 <notdan> kuribas: in the definition of compose' you mean?
05:45:38 <ronh> not that it matters much, or will help in understanding that foldr use, but (\f x -> f x) is ($) or id
05:46:03 <kuribas> foldr ($) x (a:(b:(c:(d:[])))) === (a $ (b $ (c $ (d $ x))))
05:46:29 <kuribas> notdan: In the application of foldr would be better worded I guess...
05:47:22 <kuribas> in compose' yeah
05:47:26 <dramforever> "in the RHS of the definition of compose'"
05:48:02 <kuribas> dramforever: right
05:48:11 <stannny> why do other languages have just foldl? like python
05:48:30 <dramforever> stannny: because foldr does not make sense in strict languages
05:48:43 <dramforever> > foldr (const 1) undefined undefined
05:48:45 <lambdabot>      Could not deduce (Foldable t0) arising from a use of ‘foldr’
05:48:45 <lambdabot>      from the context (Num (b -> b))
05:48:45 <lambdabot>        bound by the inferred type of it :: Num (b -> b) => b at Top level
05:48:49 <stannny> hmm, why not?
05:48:53 <dramforever> =(
05:49:20 <dramforever> foldr const undefined ("foo" : undefined)
05:49:23 <kuribas> dramforever: scheme has fold-right
05:49:26 <dramforever> > foldr const undefined ("foo" : undefined)
05:49:27 <lambdabot>  "foo"
05:49:40 <dramforever> that doesn't really make sense in strict languages
05:49:50 <kuribas> dramforever: It does when the function isn't associative.
05:50:14 <kuribas> Because then the right fold and left fold will have a different result.
05:50:14 <dramforever> so actually I remember that the only two folds in "real code" are foldl' and foldr
05:50:48 <dramforever> kuribas: well I mean foldr doesn't make sense as a recursion pattern
05:51:10 <dramforever> wait it's not...
05:51:15 * dramforever messed it up again
05:51:37 <kuribas> dramforever: scheme has fold-right, and scheme is strict.
05:51:47 <kuribas> foldl (-) 0 [1, 2, 3]
05:51:50 <kuribas> > foldl (-) 0 [1, 2, 3]
05:51:51 <lambdabot>  -6
05:51:53 <kuribas> > foldr (-) 0 [1, 2, 3]
05:51:55 <lambdabot>  2
05:52:04 <dramforever> kuribas: yeah that's why I said I messed it up
05:52:48 <kuribas> I don't know about python though...
05:53:41 <nkaretnikov> Falkyouall: note that you should try to use folds instead of explicit recursion if possible since folds are optimized in the stdlib
05:55:00 <kuribas> hm I wonder if associative functions are always strict
05:55:02 <statusfailed> ocharles_: not sure if you're bothered, but I think your wiki is down
05:55:45 <kuribas> nkaretnikov: isn't direct recursion optimized in ghc?
05:55:49 <jomg> kuribas, const should be associative
05:56:00 <jomg> and isn't strict in the second argument
05:56:26 <nkaretnikov> kuribas: it depends.  I'm talking about RULEs.
05:56:39 <Falkyouall> nkaretnikov: youre right, i try to adopt myself to folds, which is not that easy
05:57:34 <nkaretnikov> Falkyouall: I have to admit that I, too, find them confusing and have to look at the types whenever I want to use one.
05:57:34 <Falkyouall> unZip is a hard one i find
05:57:51 <Falkyouall> myUnzip :: [(a, b)] -> ([a],[b]) 
05:57:51 <Falkyouall> myUnzip = foldl (\(xs,ys) (z1,z2) -> (xs++[z1],ys++[z2])  ) ([],[])
05:57:53 <kuribas> jomg: right
05:58:51 <Falkyouall> especially i dont understand that (z1,z2) should be the same as [(a,b)]
05:59:02 <rxd> which lang is best for honing algorithm/problem solving skills?
05:59:05 <rxd> i suck at algorithms/solving problems and need a suitable lang to practice in
05:59:45 <dramforever> rxd: IMHO not haskell =P
06:00:13 <Phillemann> I have a structure like "data SomeEnum = A | B deriving(Generic); data Foo = Foo { bar :: SomeEnum } deriving(Generic)" and I'm trying to use aeson with as less "manual" work as possible. Using deriving(Generic) and calling "genericToJson (Foo ...)" I end up with "SomeEnum has no ToJSON instance", so I have to manually add instance ToJSON SomeEnum
06:00:21 <maerwald> rxd: the problem with using haskell for that is that most algorithms are expressed in imperative style, even today. So you either have to do imperative (ugly) haskell or reverse-engineer pseudo code
06:00:23 <Phillemann> Why is that?
06:01:00 <dramforever> Phillemann: because that's how Generics works (well, it used to be)
06:01:10 <maerwald> rxd: or just come up with your own solution, which is even harder
06:01:30 <rxd> schquid: i hear python allows you to focus on algorithms/problem solving but i don't know if that's true or not
06:01:32 <dramforever> you can enable the DeriveAnyClass extension and add ToJSON to your deriving list
06:01:34 <maerwald> but certainly a good learning experience as well
06:01:42 <rxd> and i know python and haskell are compared quite alot
06:01:46 <dramforever> rxd: python is nicer
06:01:52 <Phillemann> dramforever: Hm, ok.
06:01:57 <dramforever> rxd: sadly haskell and python are very different
06:02:12 <kuribas> rxd: IMO algorithms are independend from the language which you use.  But in haskell the preference goes to algorithms that don't do inplace mutation, though that's possible using the ST or IO Monad.
06:02:35 <rxd> is python for practicing my algorithms/problem solving skills than haskell?
06:02:46 <rxd> better i mean
06:02:51 <maerwald> rxd: do you already know python or haskell?
06:03:36 <dramforever> rxd: yes, python is better, but you know it's a bit slow, and that's why we often use C or C++ or Pascal
06:03:50 <Falkyouall> how can [(1, "hi"),(2, "ho")] be a fitting argument for (\(z1, z2) -> ....) ??
06:04:01 <exio4> dramforever: that's a lie
06:04:02 <rxd> maerwald: i know bits of python and c and use them interchangeably in my pursuit of better algorithm design -- which i currently suck at
06:04:14 <rxd> i thought maybe haskell would be a nice alternative
06:04:15 <dramforever> exio4: what do you mean?
06:04:23 <exio4> problem solving skills, if anything
06:04:23 <dramforever> rxd: do you know haskell?
06:04:25 <Falkyouall> its not a tupel, its a list of tuples which i give it to
06:04:36 <exio4> are actually fuzzy in imperative languages, or so, I would argue
06:04:42 <renzhi> cabal and stack don't seem to able to take http_proxy environment variable. Anyone knows how to get this work?
06:04:46 <maerwald> rxd: well, if you have to learn haskell from scratch, but your main goal is just improving your algorithmic skills, then I'd stick to python, because you'd invest most of the time in learning haskell rather than improving what you actually want
06:04:52 <dramforever> exio4: well you don't invent algorithms, you make uses of them
06:05:12 <exio4> dramforever: I am talking about problem solving
06:05:24 <rxd> it seems python is best for algorithm overall
06:05:25 <dramforever> oh I'm talking about algorithms =P
06:05:28 <exio4> something where equational reasoning shines, because you can `use it backwards`
06:05:32 <kuribas> dramforever: but sometimes you can improve algorithms, or change them for your needs.
06:05:43 <maerwald> rxd: I'd not say python is best for algorithm overall, no
06:06:06 * dramforever has been and will be in a number of algorithms/problem solving contests
06:06:08 <maerwald> but if you only care about algorithm stuff, then learning a whole new language might be a bit weird
06:06:44 <dramforever> maerwald: yes I can confirm
06:06:58 <maerwald> rxd: and since most pseudo code for random stuff is written with imperative style languages in mind, you won't have any problem finding actual pseudo code
06:07:18 <maerwald> show me functional pseudo code for the NTRUEncrypt algorithm :P
06:07:20 <maerwald> there is none
06:07:59 <dramforever> show me a purely functional union-merge set implementation =P
06:08:14 <rxd> maerwald: what language is then python is like working psuedo-code amirite?
06:08:29 <exio4> imperative pseudo-code
06:08:36 <exio4> haskell is the functional pseudo-code ;)
06:08:47 <dramforever> haskell is like working with math equations
06:08:58 <maerwald> exio4: not always, no... only toy implementations that are very pure
06:09:12 <exio4> maerwald: wut? 
06:09:21 <kuribas> dramforever: for example, I use the bresenham line intersection algorithm, but I adapted it for bezier curves.  A lot of people claim that algorithm design has no practical use, but that is nonsense.
06:09:35 <maerwald> exio4: if you implement the minimax algorithm in haskell, it will be a few lines only and look very neat
06:09:47 <dramforever> kuribas: what??
06:09:48 <maerwald> but if you actually want it to be useful, robust and performant
06:09:52 <maerwald> you end up with something different
06:10:07 <dramforever> kuribas: which message are you replying to?
06:10:16 <maerwald> and that "something" is not really good pseudo code
06:10:20 <kuribas> <dramforever> exio4: well you don't invent algorithms, you make uses of them
06:10:52 <exio4> maerwald: I'd argue that you can get down to a nice-point performance wise while still being pure
06:11:05 <dramforever> hmm...well 1. I was talking about those contests 2. adaptation is very different from invention
06:11:11 <dramforever> from scratch
06:11:13 <exio4> maerwald: if you _want_ to get down to C-ish performance, you sure end writing pretty much C code 
06:11:21 <kuribas> dramforever: invention from scratch doesn't exist.
06:11:37 <kuribas> dramforever: every algorithm builds on other algorithms and knowledge.  Well most :-)
06:11:47 <dramforever> well I couldn't think of a better word =P
06:12:12 <dramforever> that's why "from scratch" is in another message, because I was thinking for a while =)
06:12:17 <maerwald> and also keep in mind, that some algorithms ARE actually imperative (at least you can argue)
06:12:31 <maerwald> e.g. http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
06:13:03 <dramforever> kuribas: oh wait I think I know the problem: you are supposed to be *implementing* algorithms in those contests
06:13:09 <codergeek> Hi Guys, I'm trying to learn about the types in haskell, but I wrote a function and ghc tells me a different type than a ghc on another pc?
06:13:22 <exio4> codergeek: which code and types?
06:13:37 <dramforever> codergeek: ghc 7.10 changed the types of many "built-in" functions
06:13:49 <dramforever> try ghc -V on both machines
06:13:52 <kuribas> dramforever: I see.  I was thinking about real applications.
06:14:23 <codergeek> f x y = any (==x) (concat y)
06:14:27 <codergeek> thats the function
06:14:29 <exio4> @type any
06:14:30 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:14:33 <maerwald> exio4: I haven't seen a lot of performant code in haskell that looks nice. Last time I looked at high-performance image processing haskell code, it looked worse than any opencv C++ code I have seen.
06:14:33 <exio4> @type concat
06:14:35 <lambdabot> Foldable t => t [a] -> [a]
06:14:40 <rxd> how is python to haskell transition because i plan on using python to improve my algorithm skills with pythons high abstraction level
06:14:41 <exio4> so, yup 
06:15:13 <maerwald> exio4: so I actually also end up writing pseudo code for haskell stuff, because the implementation actually differs quite a lot
06:15:38 <kuribas> maerwald: but haskell can hide the uglyness better than C :)
06:15:41 <codergeek> My class says it should have type f :: (Eq a) => a -> [[a]] -> Bool
06:15:44 <maerwald> yeah, maybe
06:15:51 <codergeek> But Ghc tells me sth. different
06:16:00 <dramforever> codergeek: what class?
06:16:18 <dramforever> your class hasn't updated, obviously
06:16:39 <codergeek>  :: (Eq a, Foldable t) => a -> t [a] -> Bool
06:16:52 <kuribas> :t \x y -> any (==x) (concat y)
06:16:53 <lambdabot> (Eq a, Foldable t) => a -> t [a] -> Bool
06:17:11 <dramforever> codergeek: like class in school/univ or online class?
06:17:34 <kuribas> codergeek: the type ghc gives is more general.
06:17:45 <exio4> codergeek: it's the right type, it's just that the one ghc gives you is more polymorphic / general
06:17:48 * hackagebot BlogLiterately-diagrams 0.2.0.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.2.0.1 (BrentYorgey)
06:17:48 <kuribas> codergeek: because list is a instance of foldable.
06:18:04 <exio4> @type (\x y -> any (==x) (concat y)) :: (Eq a) => a -> [[a]] -> Bool 
06:18:05 <lambdabot> Eq a => a -> [[a]] -> Bool
06:18:35 <exio4> maerwald: I am saying you can get "decent" performance with pure code, as long as you use the right data structures, and give GHC some hints
06:18:49 <maerwald> dramforever: have you experience with algorithms that use cyclic data structures in haskell? I find that pretty hard. You either end up doing very confusing tying-the-knots methods (by relying heavily on laziness) or sort of simulate C pointers.
06:19:12 <benzrf> maerwald: hmm, what kind of cyclic data structures are interesting?
06:19:14 <benzrf> primarily graphs?
06:19:20 <codergeek> I'm learning for university class. 
06:19:33 <dramforever> I think the "deepest" reason is your class did not apply BBP =) some information on relevant parts of it could be found here https://wiki.haskell.org/Foldable_Traversable_In_Prelude
06:19:49 <benzrf> dramforever: bbp?
06:20:00 <exio4> burning bridges proposal
06:20:37 <benzrf> lol
06:20:58 <exio4> codergeek: it's ok, you can specify that type in the type signature, and see it's just more general
06:21:19 <exio4> (specifying the type signature you want the code to have, is also a nice way to get better compiler errors, by the way!)
06:21:33 <maerwald> benzrf: http://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml
06:21:36 <rxd> how is python 2 haskell transition?
06:21:56 <maerwald> rxd: not much in common
06:22:05 <dramforever> rxd: haskell is very different from almost any other PL
06:22:11 <dramforever> *Programming Language
06:22:30 <benzrf> dramforever: not true
06:22:37 <benzrf> very different from almost any other /mainstream/ PL
06:22:47 <maerwald> benzrf: the knots are not known at compile-time, they depend on the input
06:22:53 <dramforever> benzrf: okay
06:22:55 <codergeek> exio4: So lists are a instance of Foldable?
06:22:56 <benzrf> dramforever: it has a lot in common with ML and theres quite a few haskell derivatives
06:22:56 <rxd> i know. i am wondering how hard it would be to go from python to haskell despite difrferences
06:23:04 <exio4> codergeek: yes!
06:23:04 <benzrf> dramforever: eg idris, purescript
06:23:17 <dramforever> rxd: I won't recomment the transition
06:23:26 <CoconutCrab> hard I guess, with haskell you have to think in type
06:23:32 <benzrf> rxd: i would recommend haskell becaues haskell is great
06:23:43 <CoconutCrab> with python I rarely have to think about type
06:23:51 <dramforever> benzrf: but rxd is using it for algorithms/problem solving contests
06:23:55 <benzrf> rxd: knowing python wont help you a ton, but then again few other mainstream languages will
06:24:11 <maerwald> but python has monads :)
06:24:15 <exio4> it doesn't
06:24:21 <benzrf> maerwald: not in any pleasant way
06:24:30 <maerwald> exio4: https://pypi.python.org/pypi/PyMonad/
06:24:30 <benzrf> rxd: its a pretty different paradigm and it'd probably be a long time before youd be comfortable
06:24:36 <benzrf> maerwald: as if
06:24:42 <dramforever> Haskell is really bad at implementing imperative algorithms, and many algorithms are imperative
06:24:47 <stannny> python is a typeless, strict imperative/OOP language. pretty much as far away from haskell as you can get
06:24:48 <benzrf> dramforever: true
06:25:12 <dramforever> even if it's not really imperative, you might find it troublesome trying to convert it to a functional style
06:25:12 <exio4> Python is not typeless either
06:25:13 <cjay> stannny: asm is typeless, python is just dynamically typed
06:25:19 <benzrf> cjay: no difference
06:25:33 <maerwald> dramforever: yeah, have been doing that for a few geometrical algorithms, it was fun though
06:25:39 <benzrf> stannny: all mainstream languages besides haskell are strict afaik, and the majority are OOP
06:25:39 <dramforever> so you don't really gain anything
06:25:51 <codergeek> exio4: so foldable only is on lists on lists, I don't get that
06:26:07 <rxd> what about haskell to python?
06:26:10 <rxd> still to different
06:26:11 <benzrf> rxd: also difficult
06:26:12 <rxd> or easier?
06:26:19 <benzrf> cjay: python doesnt have types, it has fast runtime failure on certain silly operations
06:26:23 <dramforever> (personal experience, remember the above only applys if you are in a algorithm/problem solving contest or doing preparation for such a contest)
06:26:56 <exio4> codergeek: you can ignore Foldable, but it just means you can `foldr` and other things to the data structure
06:26:59 <exio4> @type foldr
06:27:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:27:02 <exio4> @type any
06:27:03 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
06:27:31 <|f`-`|f> List is the archetypical"Foldable"
06:27:45 <|f`-`|f> Anything that could conceivably be folded is a foldable
06:28:10 <|f`-`|f> (there are some listlike things that are not foldable, but that's a complicated issue)
06:28:29 <dramforever> rxd: IMHO python -> haskell can't be called a transition at all
06:29:11 <|f`-`|f> considering what is said above, it's a complete change of pace
06:29:30 <|f`-`|f> (also I will argue the point of imperative in functional being problematic)
06:30:09 <kuribas> You can program imperative in the ST monad.
06:30:09 <harrysw2> cjay it depends on how you define types. this is an interesting article if you ignore author's common provocative tone. https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
06:30:14 <|f`-`|f> (pure functional makes you run a tight ship when you do,though)
06:30:34 <cjay> hmm
06:30:45 <Ven> Hi! I have this piece of code (inside a foldM) `(\a b -> do { id <- newID; return $ CallExpr id a b })`. I was wondering if there was a way to "lift" CallExpr to avoid the do-block? I'm not sure...
06:30:55 <|f`-`|f> the largest distinction I've seen between the two is how strong the typing is, harrysw2
06:31:04 <kuribas> If you need raw speed, then there is nothing wrong with coding it imperatively.
06:31:23 <cjay> I think python has at least primitives types. Not sure about classes, because you can add and remove attributes after object creation.
06:31:42 <rxd> dramforever: well what about haskell as first real language
06:31:59 <|f`-`|f> frontloaded, and lacking good teachers, yet
06:32:02 <pingu> python can have 'real' types, even, now.
06:32:09 <dramforever> rxd: it wouldn't be as easy if you want to implement imperative algorithms
06:32:11 <pingu> as in, static checking.
06:32:16 <|f`-`|f> frontloading is not the problem
06:32:25 <|f`-`|f> the lack of teachers is
06:32:32 <edk> pingu, they don't change the dynamic aspect of it
06:32:39 <Haskellfant> Ven: fmap (\id -> CallExpr id a b) newId is one possiblity. You could also use CallExpr <*> newId <*> return a <*> return b or newId >>= \id -> return $ CallExpr id a b
06:33:01 <rxd> dramforever: so that shit people say about haskell making you a better programmer is bull
06:33:02 <Haskellfant> but honestly, I think the do block is probably the most readable
06:33:06 <pingu> edk: not sure what you mean by that.
06:33:08 <edk> cjay, the only types that you can't modify on the fly are result of cpython being silly, so no, python does not really have type-like types
06:33:16 <dramforever> rxd: well, algorithm contests makes you a bad programmer
06:33:20 <Ven> Haskellfant: thanks :)
06:33:51 <harrysw2> what python calls types are actually mutiple classes (not classes in the OOP sense) of the same type 
06:33:56 <dramforever> because those s*** people are not talking about algorithm/problem solving (letabbreviate to )
06:34:02 <|f`-`|f> (even python offloads all the hardwork onto C through numpy, etc)
06:34:08 <edk> pingu, you can pass the static checker and then proceed to mutate the types at runtime
06:34:15 <dramforever> (let's abbreviate that to APS) contests
06:34:33 <|f`-`|f> a piece of ...
06:34:36 <|f`-`|f> hmmm
06:34:41 <kuribas> dramforever: haskell is perfectly fine for programming imperative algorithms.  The only thing is that they aren't used as often, like for example hashtables.
06:34:54 <kuribas> dramforever: But programming them in haskell isn't harder than in another language.
06:35:01 <maerwald> sure it is
06:35:25 <quchen> I think it's easier.
06:35:34 <|f`-`|f> (there are many ways to go about it)
06:35:41 <quchen> I just spent a day worrying about whether some variable can be null or not. A DAY.
06:35:47 <nkaretnikov> what's the fastest way to parse binary data these days?
06:36:00 <kuribas> quchen: in C?
06:36:08 <quchen> kuribas: Java.
06:36:15 <|f`-`|f> hum, either Binary or Bytestring, but I know nothing
06:36:24 <quchen> Bytestring is not a parser.
06:36:26 <quchen> Binary is.
06:36:29 <quchen> And so is Cereal.
06:36:39 <monochrom> you see, if you don't worry, other languages are easier.
06:37:13 <quchen> The main difference between them is that Binary works with lazy and Cereal with strict BS. But that seldomly matters in my experience.
06:37:22 <monochrom> and indeed, most programmers don't worry. they just fix bugs when bugs show up. they don't preemptively prevent bugs.
06:37:55 <kuribas> monochrom: but they do write unit tests right?
06:38:07 <nshepperd> there's no worrying in enterprise
06:38:15 <monochrom> do you know the quality of their unit tests?
06:38:24 <nkaretnikov> quchen: what about attoparsec?
06:38:38 <nkaretnikov> quchen: I mean, how does it compare to binary?
06:38:55 <dramforever1> kuribas: well many things are easier in haskell
06:38:56 <monochrom> logically, the quality of their unit tests cannot exceed the quality of their programming attitude
06:39:03 <dramforever1> but there are a few things that are hard
06:39:05 <quchen> nkaretnikov: That's a general purpose parser, you can use it to parse your own binary format as well. Binary is nice because it comes with compatible encode/decode functions.
06:39:18 <quchen> If all you need is parsing and that at speed, attoparsec might be worth a look.
06:39:18 <nkaretnikov> quchen: I have some code that uses attoparsec and it's 6 times slower than a different implementation (not in haskell).
06:39:22 <nshepperd> now that's something odd, why does Binary use a strict state monad and yet lazy bytestrings?
06:39:36 <monochrom> and their attitude is that they don't spend a day like quchen did on whether null is possible
06:39:44 <dramforever1> how about this: I got fed up writing a splay-tree in C++, so I wrote one in haskell
06:39:46 <dramforever1> @hackage splay
06:39:46 <lambdabot> http://hackage.haskell.org/package/splay
06:39:58 <quchen> monochrom: "Because it works"
06:40:03 <rxd> how did you all learn all of this techy stuff?
06:40:16 <rxd> i just got to understanding fucking for loops
06:40:19 <rxd> wtf?
06:40:29 <quchen> rxd: By spending days on fixing bugs and then finding out there's a much better way.
06:40:40 <rxd> bugs?
06:40:52 <kuribas> monochrom: But they pay for it later right?  It maintenance?
06:40:56 <nshepperd> every time I use Binary I wish I could I do V.replicateM n blah, but it doesn't work
06:40:56 <quchen> Unintended programming errors.
06:41:03 <monochrom> rxd: the sentence "I just recently learned for loops" was true of me once upon a time, too
06:41:22 <monochrom> kuribas, I am not sure who pays, programmers or customers
06:41:25 <nshepperd> because that dratted strict monad ruins the streaming
06:41:42 <monochrom> I thought programmers were paid, not were paying
06:41:46 <nkaretnikov> quchen: I'm surprised that you're writing java.  you've been active in the community for a while, I thought you're in some haskell shop
06:42:05 <rxd> monochrom: where are you know. i started c and python hardcore a month ago and i can only make a damn 5 line asterisk triangle
06:42:06 <quchen> nkaretnikov: I also work with another language that I shall not mention publically. :-þ
06:42:26 <kuribas> monochrom: well the company pays for it later.  If the product is too buggy, then it looses revenue.
06:42:32 <nkaretnikov> quchen: is that a functional language?
06:42:34 <monochrom> rxd, "recently learned for loops" was 30 years ago
06:42:40 <quchen> nkaretnikov: It's purely dysfunctional.
06:42:47 <nkaretnikov> lol
06:43:01 <kuribas> quchen: php or javascript I guess...
06:43:30 <dramforever> nshepperd: well it doesn't?
06:43:37 <dramforever> :t replicateM
06:43:38 <lambdabot> Monad m => Int -> m a -> m [a]
06:43:42 <rxd> monochrom: damn your probably like a programming god now right?
06:43:44 <dramforever> oh it doesn't =(
06:44:00 <rxd> lucky dude it must feel good to know this stuff and what these people are typing
06:44:03 <dramforever> @poll-result dicator-of-life
06:44:03 <lambdabot> No such poll: "dicator-of-life"
06:44:06 <dramforever> =(
06:44:12 <monochrom> kuribas, it seems to me that programmers are in this equilibrium of no one being in a hurry to out-compete other programmers in reducing bugs. is it a cartel? is it a Nash equilibrium? I don't know yet.
06:44:16 <nkaretnikov> dramforever: typo
06:44:40 <nshepperd> dramforever: I ended up writing a wrapper for Get that lazifies it
06:44:54 <dramforever> never mind =P
06:44:55 <nshepperd> and then writing it again because I need it in a different project ^_^
06:45:07 <dramforever> nshepperd: upload it to hackage =)
06:45:27 <quchen> monochrom: Ultimately, I think it has something to do with the way humans judge effort and success. When you have a hard time doing something and do it sufficiently well, you'll be praised for your success. When you're lazy because your program is bugless and you have nothing to fix nobody admires it.
06:45:51 <dramforever> hmm...interesting
06:46:05 <|f`-`|f> consider the perspective of the end user, and end executive, monochrom 
06:46:05 <quchen> monochrom: There is a more scienfitic version of this, for an unscientific but (disturbingly) entertaining write-up look up "tale of two programmers".
06:46:08 <|f`-`|f> Does it matter?
06:46:24 <dramforever> I used repeated doubling to create a splay-based sequence of length 68719476736
06:46:31 <rxd> what is this haskell good for?
06:46:39 <rxd> what can i do with it that i can't do with python?
06:46:48 <kuribas> quchen: I don't get it, if it is bugless then you can focus on features and user experience, which should be more important...
06:46:50 <rxd> can i program arduino in it like i can in c and c++?
06:46:50 <quchen> It's a programming language. It's good for writing programs.
06:47:05 <monochrom> yes, there is a similar culture of hero-izing firefighters after a fire but not fire preventers
06:47:08 <dramforever> rxd: it's another style of programming
06:47:29 <rxd> why do you all use this language though? why not lisp for example? most be something special about haskell right?
06:47:35 <maerwald> rxd: haskell is very good for creating DSLs and I think that is actually it's main use in the industry
06:47:46 <dramforever> rxd: you can write very declarative code in haskell
06:47:51 <quchen> Well, arguably everything in Haskell is a DSL
06:48:10 <bren> Anyone around who is comfortable using FreeT/CoDensity and wouldn't mind helping me out with some design/usage questions?
06:48:10 <CoconutCrab> rxd: I don't think you can fit haskell runtime in arduino tiny memory
06:48:11 <|f`-`|f> as a result of DSL and Declarative code is that you can very easily do things like abstraction or higher order programming
06:48:11 <dramforever> I think it's the conciseness that attracted me
06:48:12 <kuribas> rxd: I wouldn't program an arduino in haskell.  Use C or assembler.
06:48:52 <CoconutCrab> as for haskell, its type system is fascinating
06:48:58 <|f`-`|f> kuribas  probably a dsl that is compiled down to asm/llvm/C at most, or have haskell churn out something C-ish
06:49:13 <dramforever> hey let's show rxb some lens stuff
06:49:20 <maerwald> to scare him off?
06:49:23 <|f`-`|f> there is research with haskell dsl's for robots
06:49:46 <quchen> monochrom: You're indeed good at analogies.
06:49:49 <|f`-`|f> may as well write an essay, and build an entire intermediate size project infornt of him, dramforever 
06:49:56 <kuribas> rxd: I like haskell because of the advanced type system, which lets me write better structured code, and catches many bugs.
06:50:33 <dramforever> > [1,2,3,4,5] & traversed . indices even %~ (*2) -- double even numbered elements (it's a convention to count from 0) (we don't really do this often, but it shows what we can do)
06:50:36 <lambdabot>      Couldn't match expected type ‘(Integer -> Identity Integer)
06:50:36 <lambdabot>                                    -> p0 Integer (Identity b)’
06:50:36 <lambdabot>                  with actual type ‘[i0]’
06:50:42 <rxd> does haskell actually make you a better programmer in imprative language or is that just bs?
06:50:46 <dramforever> =( brainfart
06:50:46 <harrysw2> rxd lisp is as far as from haskell as python is
06:50:55 <harrysw2> completely different language
06:51:12 <dramforever> rxd: it makes you a better programmer because it kinda forces you to write clean code
06:51:25 * dramforever remembered a post on reddit
06:51:36 <rxd> harrysw2: would it help me in algorithm design better than python and haskell if its so different?
06:51:37 <|f`-`|f> you have to explicitly deal with things like code structure where you don't need to in an imperative language, and will find most of your bugs coming from rxd
06:51:47 <dramforever> https://www.reddit.com/r/haskell/comments/3cmc6l
06:51:55 <dramforever> rxd: ^
06:52:14 <harrysw2> rxd, not sure I understand the question.. but lisp is far more like python than haskell
06:53:01 <harrysw2> dynamically typed, strict, mostly imperative and OOP, with some functional programming sprinkled here and there
06:53:17 <kuribas> rxd: When you code in haskell you must be aware of when you use side-effects, and that is a good attitude for coding in general.
06:53:22 <harrysw2> (when I say lisp I mean common lisp)
06:53:35 <rxd> harrysw2: will lisp improve problem solving skill?
06:53:38 <rxd> common lisp
06:53:38 <dramforever> rxd: again, as someone who has been in those contests, I would *not* recommend haskell for contest programming. it's useful for other many applications, though, IMHO because it's pretty concise
06:53:50 <dramforever> rxd: nothing will improve problem solving skills
06:53:58 <dramforever> except practice
06:54:01 <rxd> so i'm just fucked
06:54:03 <rxd> oh
06:54:04 <chattered> Though one of the early Haskell implementations just sat on top of Common Lisp and was apparently very lispy, providing things like save-lisp-and-die and some other cool stuff.
06:54:17 <harrysw2> rxd learning and using any language probably will. not sure if lisp will more than other languages
06:54:24 <chattered> I think at the time, it was one of the most mature of the implementations as well.
06:54:55 <dramforever> rxd: IMHO haskell looks bs-ish because we don't really know what we can do with it well
06:54:58 <int-e> rxd: to put a spin on what dramforever said: solving problems will improve your problem solving skill
06:55:06 <|f`-`|f> Thought it was between Lisp, and Algol trying to combine Type Theory, and a few other things when laziness, and purity were discovered, chattered 
06:55:10 <|f`-`|f> Deveil in the details
06:56:09 <|f`-`|f> it was more or less "Let's not make 3847943784378943 mini-research languages, let's focus one"
06:56:12 <dramforever> you can write many things in haskell very elegantly, but quite a few others extremely unelegantly
06:56:38 <dramforever> hmm that sentence I just wrote is weird
06:56:55 <|f`-`|f> ^ usually you can find a more elegant way during the first runs
06:57:06 <|f`-`|f> like "sum"
06:57:16 <dramforever> |f`-`|f: for others it's years of research and no result
06:57:44 <|f`-`|f> you start with the recursive definition, then the fold definition, and then the wrapper
06:58:12 <exio4> refactoring to the rescue :p 
06:58:16 <chattered> And then keep going: http://www.willamette.edu/~fruehr/haskell/evolution.html
06:58:19 <dramforever> rxd: I wonder if you get what I was emphasizing again and again: haskell is *not* suitable for A/PS contests
07:00:39 <nshepperd> I use haskell for google code jam
07:01:39 <nshepperd> but I do believe that it's a language that you want to be fully comfortable in before you entrust yourself to come up with the right way to write a solution in those time limits
07:02:41 <nshepperd> you don't want to spend your last 10 minutes debugging a space leak, or something
07:02:53 <dramforever> rxd: also I doubt if any programming contest where you are supposed to upload code not answers
07:03:02 <dramforever> you could use haskell
07:03:18 <rxd> dramforever: im not trying to enter a contest dude
07:03:26 <dramforever> oh hmm...
07:03:28 <rxd> i just suck balls at algorithm design
07:03:36 <dramforever> oh no..
07:03:52 <rxd> like, i can't even make the pascal triangle on my own in c
07:03:52 * dramforever got messed up...someone should have told me earlier
07:03:53 <|f`-`|f> hmmm
07:04:04 <|f`-`|f> algorithms?
07:04:23 <|f`-`|f> don't people google that nowadays?
07:04:32 <dramforever> rxd: well for algorithms that "simple" haskell is just as suitable
07:04:45 <|f`-`|f> anyways, define a polynomial type, and multiplication
07:04:55 <|f`-`|f> and presto you have pascal's triangle
07:04:56 <kuribas> rxd: Algorithms are the same in any language
07:05:08 <rxd> google algorithms? like how to do something line for line? that cheap punk pussy move
07:05:37 <dramforever> |f`-`|f: well I'm talking about more complexed algorithms, where people just assume imperative features and use them so hard that you can't get it to be purely-functional
07:06:14 <freeman42-sp> rxd: compared to python, Haskell is statically typed so it will catch a lot of errors at compile time. And the best time to catch errors is as soon as possible  (definitely not in production) 
07:06:26 <dramforever> rxd: surely you could do something like pascal triangle more easily in haskell
07:06:59 <freeman42-sp> rxd: a lot of errors in addition to the ones you might catch with tests
07:07:20 <rxd> dramforever: cant do crap in c or python with the pascal triangle thats for sure
07:07:55 <dramforever> rxd: well I would say it's easier for you to get messed up in c/py than in haskell
07:08:42 <catsup> algorithms are actually not the same in a lazy language
07:09:09 * dramforever actually thought rxd was talking about complexed algorithms like dijikstra's, dynamic programming ones, push-relabel, etc.
07:09:22 <Serpentine_> pascal n k = if (n==1) || (n==k) then 1 else (pascal (n-1) (k-1)) + (pascal (n-1) k)
07:09:38 <|f`-`|f> ok
07:09:46 <|f`-`|f> I think they actually want to construct a triangle
07:09:55 <Serpentine_> Dijkstra's algorithm would probably be a pain to implement in Haskell
07:10:01 <quchen> Nope
07:10:08 <dramforever> Serpentine_: not as painful as some others
07:10:18 <|f`-`|f> I just do the list-of-coefficients definition of a polynomial
07:10:29 <dramforever> I think the core of dijkstra's is a priority queue that supports decrease-key
07:10:30 <|f`-`|f> and then iterate multiplication
07:11:02 <quchen> If you want something that's a pain to write in Haskell it's Quicksort, because that's as painful as writing it in C.
07:11:11 <|f`-`|f> complete garbage for anything other than making the whole triangle
07:11:28 <|f`-`|f> if you want it to be as good as C
07:11:34 <dramforever> quchen: maybe we should call that classical "quicksort" "filtersort" instead
07:11:36 <|f`-`|f> you can pretty much ham it up
07:11:58 <quchen> dramforever: Why? It doesn't filter
07:11:59 <rxd> quick question: does all of this technical knowledge and programmer vocab come with learning programming on ur own as a hobbyist, because i dont understand much of the stuff you guys are saying
07:12:16 <dramforever> quchen: I mean the "3-liner quick sort in haskell"
07:12:22 <|f`-`|f> hah
07:12:25 <rxd> so technical, much smart, wow
07:12:31 <quchen> dramforever: That's what I specifically did not mean :-þ
07:12:35 <dramforever> rxd: don't worry =P
07:12:49 <dramforever> quchen: I agree with you =)
07:13:06 <dramforever> rxd: "you'll soon learn programming"
07:13:27 <quchen> dramforever: We should call it "algorithm to sort a singly linked list sharing the core idea with Quicksort", because it's an algorithm to sort a singly linked list sharing the core idea with Quicksort".
07:13:29 <|f`-`|f> it's a slow proccess entirely worth forgetting
07:13:55 <|f`-`|f> the content, not so much
07:14:47 <dramforever> quchen: apart from recursion, the two operations that were used are filter and concat. let's call it filter-concat sort =P (Well I think we are in one of the two "really-hard problems in computer science")
07:15:03 <monochrom> rxd: when I first entered primary school, I thought, secondary school is so hard, I'll never manage
07:15:33 <monochrom> six year later, I entered secondary school, no problem. but the I thought, university is so hard, I'll never manage.
07:15:43 <|f`-`|f> We need to get that video by Shia Lebouf
07:15:56 <|f`-`|f> overlaid over a tasteful reel of the SS
07:16:04 <rxd> monochrom: i have a 1.3 gpa
07:16:05 <monochrom> six year later, I entered university, no problem. but then I thought, PhD is so hard, I'll never manage.
07:16:09 <|f`-`|f> to fully inspire nationalism, pride, and dignity
07:16:22 <monochrom> some 10 years later, I got a PhD.
07:16:36 <quchen> You finished your PhD?
07:16:39 <quchen> Congratulations! :-)
07:16:39 <monochrom> yes
07:16:42 <|f`-`|f> Honestly, I'm not sure what GPA is other than "you had some amount of rigor"
07:16:49 <monochrom> 2.5 years ago
07:16:50 <|f`-`|f> "we do't really care"
07:17:10 <rxd> nice to see u guys think gpa doesnt matter
07:17:10 <|f`-`|f> Hell, the education system makes no sense
07:17:19 <|f`-`|f> but that's another topic
07:17:33 <|f`-`|f> a common topic since Haskell is shitting up the generational problem
07:17:47 <|f`-`|f> (lack of teachers)
07:18:33 <quchen> I can't tell whether you're a troll or not. At least half of your messages are utterly out of place.
07:19:02 <|f`-`|f> m-me?
07:19:31 <quchen> After just mentining the SS in a funny way you're talking of Haskell shitting on something. That's not what we're trying to do in here.
07:20:00 <|f`-`|f> Haskell has a problem of not having teachers
07:20:14 <|f`-`|f> it's weird, but not impossible
07:20:23 <quchen> That way of saying it makes it sound much more constructive.
07:20:44 <maerwald> quchen: I think he's just a weird guy, not a troll :)
07:20:56 <|f`-`|f> So in a channel of pretty high-scale programmers-ish
07:23:44 <|f`-`|f> Seems like a hard match with someone that doesn't knwo, and doesn't know what they don't know, especially with the lack of the teachers
07:24:29 <rxd> |f`-`|f: you nazi your not a true american. racist bigot i dont tolerate neo nazis not cool bro
07:24:43 <quchen> ಠ_ಠ 
07:24:49 <monochrom> both of you need to stop
07:24:51 <quchen> Can we pretend that never happened and carry on please
07:24:55 <|f`-`|f> hue
07:25:16 <|f`-`|f> "Just do it" - Shia Lebouf in what is probably the most exploitable video ever
07:25:24 --- mode: ChanServ set +o monochrom
07:25:27 --- mode: monochrom set +b *!*@108-65-78-116.lightspeed.sntcca.sbcglobal.net
07:25:27 --- kick: |f`-`|f was kicked by monochrom (|f`-`|f)
07:26:23 <Phillemann> I'm trying to use Data.Text with optparse-applicative. I thought using "option auto ..." on the value would suffice, but it tells me it cannot parse it.
07:26:38 --- mode: monochrom set -b *!*@200.79.252.182
07:27:01 --- mode: monochrom set -o monochrom
07:30:08 <harrysw2> what did |f`-`|f do?
07:30:40 <harrysw2> besides being weird
07:32:32 <maerwald> I think there is a channel for such questions, #haskell-ops or so?
07:33:37 <monochrom> continued after I said "stop"
07:34:13 <monochrom> or do you mean you're their accomplice
07:35:32 <harrysw2> monochrom, I don't even know them. but your attitude as an OP seems to be more in line with what I've seen with ##c than in #haskell
07:36:24 <maerwald> is this the place to discuss that?
07:39:54 <Epichero> teaching myself haskell, how can i at least get yesod installed ?
07:40:01 <bernalex> lol
07:40:15 <bernalex> Epichero: what system are you on?
07:40:16 <catsup> Epichero: use 'stack'
07:40:46 <bernalex> catsup: stack is not a silver bullett that should be just suggested as a defacto standard way of installing things.
07:40:47 <azsx> epichero what kind of website are you making?
07:40:55 <azsx> using yesod
07:41:00 <catsup> bernalex: sure it should be.  but especially yesod
07:41:36 <bernalex> sigh. nixos and stack users are becoming a problem.
07:41:40 <Th30n> I need quite a bit of help with MonadIO and MonadBaseControl IO. In my first Haskell project I've been using MonadIO m everywhere where there is IO as in some cases I also use MonadState. Currently I've encountered a problem with trying to bracket and catch exceptions that can be thrown within MonadIO. I've turned to MonadBaseControl and lifted-base package. So in order to get that to work as quickly as possible I had to litter my code with
07:41:40 <Th30n> MonadBaseControl IO m and MonadIO m type constraints. Is there any comprehensive guide to understanding the interoperation between the two? What I would like to have is some code that is only MonadIO m and the other to be MonadBaseControl IO m without requiring the code that uses both to have both constraints in its type signature. Is there an instance of MonadBaseControl IO for MonadIO? Or can I lift one to the other?
07:41:45 <bernalex> I'm off.
07:41:48 <catsup> bernalex: how do you mean?
07:42:09 <azsx> th30n use C instead
07:42:41 <azsx> in fact i think  should use C instead
07:42:42 <Th30n> azsx: Nice xD
07:42:57 <azsx> haskell is killing me
07:43:23 <monochrom> you should not use MonadIO everywhere
07:43:27 <catsup> Th30n: without the code that uses both to have both constraints??
07:43:33 <Th30n> catsup: Yep
07:44:02 <catsup> but it has to have constraints for what it uses
07:44:08 <Th30n> monochrom: Well, all functions that perform IO I've put inside MonadIO instead of IO
07:44:30 <Epichero> not sure yet, just want to use yesod as my frontend, but cabal doesn't like this idea.. i'm on OSX
07:44:45 <catsup> you could define a typeclass to have a single constraint if that's what you mean
07:44:59 <nshepperd> isn't stack really new?
07:45:15 <catsup> it's at least a couple weeks old
07:45:28 <catsup> Epichero: get stack, it will solve your problems
07:45:55 <catsup> Epichero: it's made by the same guy who created yesod, incidentally
07:45:59 <Epichero> if it doesn't i'll come back and throw ad hominems at you (not really)
07:46:01 <Th30n> catsup: I was hoping I could have some outer function have MonadBaseControl IO, and that uses a MonadIO function. Then this MonadIO constraint will automatically be inferred to be MonadBaseControl IO
07:46:19 <catsup> Epichero: i don't worry about that, because it will
07:46:21 <Th30n> catsup: So I don't have to write the outer to be MonadIO and MonadBaseControl IO
07:46:32 <favetelinguis> Im trying to get HDBC working on my mac but i dont understand what this is? http://packages.ubuntu.com/precise/libghc-hdbc-sqlite3-dev It is required for setting up hdbc on linux. Why is not the cabal hdbc and hdbc-sqlite3 enogh for hdbc?
07:46:46 <Epichero> is stack on homebrew ?
07:47:24 <catsup> Th30n: well MonadBaseControl simply doesn't imply MonadIO, that's why you need both.  You could define a MonadBaseControlIO typeclass though
07:48:09 <catsup> Epichero: i don't know, but it doesn't make sense to build stack with something like that
07:48:40 <catsup> Epichero: you can download a statically linked binary of stack, then use it to install ghc+libs (and then you can use that to compile the latest stack from github if you want)
07:49:26 <Th30n> catsup: Or I could have everything in MonadBaseControl and don't use MonadIO at all?
07:49:41 <catsup> i mean, i guess if you have working ghc, you can just cabal install stack, but stack will bootstrap everything including installing ghc
07:50:16 <catsup> Th30n: if you don't use liftIO sure...  
07:50:46 <Th30n> catsup: Yeah, because it seems to me like they kinda serve the same purpose here
07:51:39 <catsup> Th30n: well if you can possibly replace a MonadIO constraint you basically always should
07:51:44 <catsup> i mean, remove
07:56:04 <Epichero> okay i installed stack now what? i mean... 
07:59:13 <meditans> hi! anyone here can use the ghc-mod refine command with 7.10?
08:00:51 <harrysw2> Epichero see: http://www.yesodweb.com/page/quickstart
08:02:43 <phaazon> meditans: nope!
08:02:47 <phaazon> it doesn’t even compile
08:02:53 * hackagebot event 0.1 - Monoidal, monadic and first-class events  http://hackage.haskell.org/package/event-0.1 (DimitriSabadie)
08:07:23 <meditans> phaazon: well, the github version does compile against ghc-7.10, and works, except for the refine command
08:07:36 <phaazon> meditans: you mean the HEAD?
08:07:41 <phaazon> latest hackage doesn’t
08:08:17 <meditans> phaazon: yeah, the head. I build it from source, but there is a bug in the refine command, I think
08:08:35 <tsahyt> What's the best way to implement a function f :: [(Int, Word8)] -> ByteString, such that f xs == pack . sortBy (compare `on` fst), but without the sorting overhead, when the all values from 0 to some N occur once as the Int, and I know N in advance (i.e. the length of the resulting ByteString is also known)? In an iterative language I'd just loop over the list and store the Word8 where it needs to be, but 
08:08:41 <tsahyt> I can't figure out a way to do this with ByteString.
08:11:05 <meditans> tsahyt: well, have you looked at Data.Array.Vector.Algorithms.Radix?
08:11:37 <meditans> tsahyt: I think what you have in mind is essentially Radix sort
08:11:52 <sm> Epichero: some things you can do: stack setup (if you need GHC installed), stack install SOMEPACKAGE (installs it in ~/.local/bin using your "global" stack settings), or (in some project with a stack.yaml or *.cabal file) stack DEVCOMMAND (see stack --help)
08:13:52 <tsahyt> meditans: It's possibly related yes. I'll have a look at that. I collect an image from various peers over the network and have to put it back together locally again. I actually think it's more of a special case of bucket sort where every bucket will finally contain exactly one element.
08:14:11 <zipper> What's the GhcMonad about? I'm reading about it here but I don't get it. https://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/GhcMonad.html
08:15:30 <meditans> tsahyt: so you could look also to http://hackage.haskell.org/package/vector-algorithms-0.6.0.1/docs/Data-Vector-Algorithms-AmericanFlag.html
08:15:33 <sm> oh you're installing yesod. Never mind! :)
08:16:20 <t7> if i have a few small, non generic functions in haskell that i want to also use in javascript what is the most painless way to compile?
08:17:14 <t7> oh haste is stable now?
08:17:54 * hackagebot event 0.1.0.1 - Monoidal, monadic and first-class events  http://hackage.haskell.org/package/event-0.1.0.1 (DimitriSabadie)
08:17:56 * hackagebot event 0.1.0.2 - Monoidal, monadic and first-class events  http://hackage.haskell.org/package/event-0.1.0.2 (DimitriSabadie)
08:18:10 <tsahyt> meditans: That sounds pretty good, but when I resort to using MVectors I might as well directly translate the iterative approach instead of trying to untangle the types here. Is there such a thing as mutable ByteString in a PrimMonad or something like that?
08:18:26 <geekosaur> zipper: your best bet for understanding it is something like ghc-mod
08:18:49 <t7> oh no cabal hell
08:19:07 <t7> how do i clear all packages?
08:20:17 <sm> t7: the quick non-destructive way: cabal sandbox init ?
08:20:22 <Taneb> t7, either tedious ghc pkg unregister, or rm -rf .ghc
08:20:52 <t7> i deleted .ghc but haste still cant resolve...
08:21:57 <sm> sometimes it's not your package db that's a problem, but the package itself (and the current state of hackage, and your GHC version)
08:22:18 <t7> disaster 
08:22:28 <t7> no one tests on ubuntu :(
08:23:01 <sm> if the package was released a while ago, installing with a contemporaneous GHC can work better (cabal install --dry -w ghc-X.Y)
08:24:16 <t7> im running haskell platform i guess
08:25:58 <sm> http://hackage.haskell.org/package/haste was released in 2009 and specifies base (==3.*), which means it needs an old version of GHC (7.6 ?)
08:26:21 <t7> oh haha
08:26:24 <t7> wrong package
08:26:31 <sm> Or you can download haste and try relaxing that version bound, which sometimes just works
08:26:45 <t7> haste-compiler i want
08:26:46 <monochrom> 7.6.3 has base 4.6.0.1
08:26:48 <t7> sorry!
08:26:54 <zipper> geekosaur: What about ide-backend? Since it's code I'm already working on?
08:26:59 <sm> 6.12, maybe
08:27:14 <monochrom> haste-compiler sounds more attractive
08:27:15 <geekosaur> zipper, ide-backend is a wrapper around ghc-as-a-library
08:27:37 <zipper> geekosaur: and ghc-mod is?
08:27:59 <zipper> True
08:28:01 <geekosaur> basically the ghc api is painful to use directly, so there are things that wrap around it to make it less painful (ide-backend, hint, etc.)
08:28:22 <zipper> geekosaur: and what's the point of ghc-mod is about?
08:28:23 <geekosaur> ghc-mod is a helper for editors/IDEs that can typecheck expressions and such, using the ghc api
08:28:51 <zipper> I don't see the difference between ghc-mod and ide-backend
08:29:04 <geekosaur> mostly that ide-backend is newer and intended to be more flexible
08:29:55 <meditans> geekosaur: does it exist a ghc-mod equivalent based on ide-backend?
08:30:05 <meditans> geekosaur: maybe work in progress?
08:30:36 <geekosaur> for example ghc-mod was originally designed to hook into emacs and vim, but probably doesn't work so well for hooking into something like fpcomplete's web IDE (which is where ide-backend came from)
08:30:52 <geekosaur> meditans: I don't know
08:30:53 <Denommus> does anyone use gradle for automation?
08:31:26 <Denommus> I have two projects: one I want to compile to JavaScript, and then use the output on the other project, which compiles to native
08:31:48 <Denommus> cabal alone doesn't handle this nicely
08:34:49 <alexa_> ( sum vals ) `mod` 10       OR      sum vals `mod` 10
08:34:55 <alexa_> what's more haskell-land readable?
08:35:04 <alexa_> the former?
08:35:45 <dolio> I think most experienced Haskell users would have no trouble reading the latter.
08:36:20 <dolio> Also why put spaces inside your parentheses?
08:36:57 <quchen> alexa_: The parentheses in the former are redundant, so you should leave them away.
08:37:07 <quchen> I don't know any case in which redundant parentheses are preferred in Haskell.
08:37:31 <quchen> Some people like to parenthesize their constraints, a la  (Show a) => a -> String
08:37:35 <quchen> Maybe that's the exception
08:38:26 <arw> sometimes its friendlier to inexperienced users to use more parentheses. 
08:38:56 <dolio> If there are operators involved that people might not know the exact precedence of, parentheses might be appreciated.
08:39:05 <GLM> How do I find all instances of a typeclass?
08:39:30 <dolio> But application being tighter than anything else isn't such a situation.
08:39:32 <harrysw2> :i Typeclass 
08:39:39 <harrysw2> will list all currently available instances
08:40:29 <alexa_> quchen: hence me asking. I know they are redundant there. I wasn't sure which was more haskel style
08:40:31 <GLM> harrysw2:Thanks. That listed the type sig for the functions and not the instances
08:40:33 <arw> dolio: in this case, yes. but if the functions and operators weren't as well-known as sum and mod, parentheses would make things easier
08:40:52 <alexa_> dolio: as for the spaces inside parens thing, it's a stylistic choice. I've done it for years in every language.
08:40:54 <harrysw2> dolio record fields update syntax binds tighter
08:41:10 <t7> why is everyone not using haste
08:41:16 <t7> it looks amazing now
08:41:25 <quchen> arw: We shoudln't write programs for inexperienced programmers. Instead, we should write readable programs that when read, make inexperienced programmers experienced.
08:41:47 <quchen> Realizing why a parenthesis is not there can be very instructional.
08:41:52 <dolio> arw: Why? You don't need to know anything about the functions involved to know that 'f a b c `g` d' parses as '(f a b c) `g` d'.
08:42:34 <arw> dolio: hm, yes, you are right there.
08:42:52 <dolio> harrysw2: Yeah, I meant any operator.
08:42:53 <arw> dolio: the `g` operator makes it simple to realize
08:44:02 <zipper> meditans: What do you want to know about ide-backend?
08:44:08 <arw> quchen: yes, but if you make it too complex, an inexperienced programmer wil understand nothing and demand a less insane language.
08:44:50 <quchen> We should not write programs that inexperienced programmers cannot work their way through, yes.
08:44:55 <arw> quchen: you can only educate someone if you teach them slightly above their current knowledge.
08:45:11 <bernalex> quchen: I'm not sure I agree
08:45:30 <bernalex> one of the main advantages of haskell, I've found, is you can code up against your best programmer on the team, rather than the worst
08:45:36 <zipper> I wanna do conditional compilation that checks whether I'm on windows.
08:45:43 <zipper> What can I use?
08:45:48 <quchen> CPP
08:46:01 <quchen> bernalex: How so?
08:48:32 <bernalex> quchen: everything is short and sweet, and everything works independently of each other. I find that means you don't need to care so much about everyone needing to understand everything, and also that when someone needs to understand something there's a much higher willingness to figure out how it works, since you can usually easily beta-reduce your way through the small compartmentalised self-sustaining
08:48:34 <bernalex> component.
08:49:28 <bernalex> there are other reasons too, but I'm gaming, so not a lot of time to be articulate here :p
08:50:03 <sm> zipper: GHC provides some platform flags you can check with CPP enabled. Also the cabal file can select different modules/dependencies by platform, which sometimes means you can get away without CPP
08:50:11 <sm> see docs
08:50:16 <quchen> I've seen people code well above my level and I would stand no chance reading their code because of its complexity.
08:50:26 <quchen> I would find it quite hard to code against that.
08:53:01 <exio4> quchen: I think he means that "using" a function is easier in Haskell, than in other languages, because there's no hidden complexity 
08:53:18 <exio4> (well, without counting exceptions...)
08:53:29 <quchen> exio4: That may be true.
08:54:01 <zipper> sm: The GHC docs?
08:54:22 <zipper> I can select to compile different modules based on OS
08:54:23 <sm> yes and the cabal user guide
08:56:22 <maerwald> quchen: I agree with that... and if I may add... I doubt that something that is overly complex that you are not able to understand it is really "above your level"
08:57:06 <cow_2001> how do i denote that i want my source to be AGPL-3 and above?
08:57:24 <cow_2001> in *.cabal files and source headers
08:57:59 <naudiz> is there a way to get rid of "Warning: Couldn't figure out linker information!"?
08:58:33 <mikeyy> how do I catch all exceptions?
08:58:50 <bernalex> cow_2001: the same way that you do with any other licence.
08:59:03 <bernalex> cow_2001: see e.g. the blubber source you are looking at. :)
08:59:05 <monochrom> read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
08:59:47 <bernalex> cow_2001: oh "and above"
09:00:08 <bernalex> cow_2001: oh, right, we do that in the README.
09:00:38 <cow_2001> ooh
09:00:53 <bernalex> cow_2001: hackage should accept things like "A-GPL3+". I don't think it did the last time I checked. =/
09:01:15 <cow_2001> yeah, it didn't
09:01:22 <cow_2001> :/
09:01:29 <cow_2001> where do i bug report?
09:01:33 * cow_2001 googles
09:02:03 <cow_2001> yay
09:02:08 <cow_2001> https://github.com/haskell/cabal/issues
09:02:44 <bernalex> cow_2001: that's a hackage problem not a cabal problem, I think. I'm not sure if that's the correct place to report the issue. try asking in #hackage.
09:03:46 <cow_2001> oh.
09:03:53 <cow_2001> thanks!
09:04:37 <ttt_fff> is there a langauge somewhere which is like haskell, but better ?
09:04:51 <bernalex> ttt_fff: define "like haskell"
09:04:58 <bernalex> ttt_fff: the answer is very likely "no" IMO
09:05:06 <monochrom> also define "better"
09:05:15 <maerwald> ttt_fff: idris is similar to haskell, but not sure what "better" means
09:05:27 <bernalex> it's strict though so ugh.
09:05:36 <maerwald> that's the purpose
09:05:42 <zomg> Better is kinda hard to define I think
09:05:43 <ttt_fff> how is ermine ?
09:05:43 <bernalex> but it has a lot of cool ideas.
09:05:48 <ttt_fff> https://www.youtube.com/watch?v=o3m2NkusI9k
09:05:51 <zomg> I mean before I knew Haskell, I certainly didn't think a language could be like Haskell
09:06:49 <t7> @pl \a b c d -> return $ f a b c d
09:06:49 <lambdabot> (((return .) .) .) . f
09:07:36 <bernalex> ttt_fff: ermine is used in report generation at a finance company. it's not very much worth talking about for general-purpose programming atm afaict.
09:08:53 <zomg> I'm never going to be able to use the word ermine without chuckling at a really really old inside'ish joke :)
09:09:40 <ttt_fff> zomg: what's the joke
09:09:53 <zomg> way back in the days of old counter-strike, there was a player who used ermine as his nick... and somehow the phrase "to do an ermine" became to have the meaning "to do things really poorly"
09:10:10 <monochrom> ah
09:10:10 <zomg> I don't even think he was that bad of a player, but nevertheless :P
09:10:38 <monochrom> next time a poor player should name themself "php"
09:10:42 <zomg> lol
09:10:49 <bernalex> ttt_fff: I guess you should look at idris, agda, elm and purescript. those are similar-ish to haskell.
09:10:58 <ttt_fff> elm doesnt' even have monads
09:11:05 <ttt_fff> purescript I could not get it to work
09:11:13 <ttt_fff> idris is pretty badass
09:11:16 <monochrom> now someone should accuse me of bashing a language
09:11:21 <ttt_fff> agda I have not played with
09:11:25 <cow_2001> bernalex: https://github.com/haskell/hackage-server/issues/385
09:11:45 <zomg> I'm allowed to bash PHP because I worked with it for a very long time, and I'm fairly up to date with its modern developments too :p
09:11:53 <zomg> or that's my excuse to do it anyway
09:11:53 <zomg> hehe
09:12:02 <bernalex> cow_2001: nice. thanks.
09:14:01 <t7> my solver is broken :(
09:14:14 <t7> too much exponentiation i guess
09:14:18 <t7> too high numbers
09:16:07 <lupin> :eval (!!6) $ scanl (*) 1 [1..]
09:16:27 <bernalex> lupin: 720.
09:17:03 <Falkyouall> ok i dont understand this one 
09:17:16 <lupin> bernalex: thanks. :p What's the correct syntax to make lambdabot evaluating this?
09:17:20 <Falkyouall> allCheck :: (a -> Bool) -> [a] -> Bool
09:17:20 <Falkyouall> allCheck f = foldr (\x acc -> f x && acc) True
09:17:27 <bernalex> > (!!6) $ scanl (*) 1 [1..] 
09:17:29 <lambdabot>  720
09:17:50 <Falkyouall> if f is i.e (>3) how can i apply this to True???
09:18:12 <bernalex> Falkyouall: wat
09:18:24 <Falkyouall> do i get it wrong?
09:18:33 <bernalex> Falkyouall: I don't understand the question.
09:18:34 <exio4> bernalex: for a moment I thought you were some kind of bot, duh, :P 
09:18:36 <Falkyouall> the first argument of teh anonymus function is True
09:18:48 <Falkyouall> so f on x = f True
09:18:49 <bernalex> > all (>3) [4..]
09:18:53 <lambdabot>  mueval-core: Time limit exceeded
09:18:54 <lyxia> Falkyouall: True is the second argument of foldr
09:18:58 <bernalex> uh forgot a char lol
09:19:00 <bernalex> > all (>3) [4..6]
09:19:02 <lambdabot>  True
09:19:12 <lyxia> Falkyouall: It's not an argument of the anonymous function
09:19:22 <Falkyouall> not? whuaa
09:19:36 <bernalex> I need to go pack
09:19:37 <maerwald> :t foldr
09:19:38 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:19:44 <bernalex> exio4: if only I were a bot. then I didn't have to pack. :(
09:19:56 <Falkyouall> its so confusing.. ok so True is one argument, and the other argument is the f on the list, is this right?
09:20:02 <maerwald> Falkyouall: you can even see it from the type signature of foldr
09:20:23 <Falkyouall> i get pretty confused by lamda in combination with folds
09:20:27 <maerwald> (a -> b -> b) -> b -> [a] -> b
09:20:41 <bernalex> Falkyouall: True is the value we start out with. the default value.
09:20:55 <Falkyouall> i know and understand the type signature but in combination with lamda ..puhrg
09:21:05 <bernalex> > foldr (+) 0 [0..5]
09:21:06 <lambdabot>  15
09:21:07 <bernalex> > foldr (+) 0 []
09:21:09 <lambdabot>  0
09:21:13 <bernalex> > foldr (+) 20 []
09:21:14 <lambdabot>  20
09:21:15 <bernalex> > foldr (+) 20 [0..5]
09:21:17 <lambdabot>  35
09:21:19 <bernalex> does that make sense?
09:21:20 <Falkyouall> an the other part is the f list ...right?
09:21:24 <maerwald> Falkyouall: (a -> b -> b) you write the lambda exactly like that (\a b -> foo) maybe that makes it clearer for you then?
09:21:29 <Falkyouall> i know foldr..
09:21:58 <Falkyouall> no its not clearer
09:22:12 <Falkyouall> lamda so then do what with the a b?
09:22:24 <Falkyouall> where comes the foo from
09:22:34 <bernalex> it's just "foldr ((&&) . f) True [stuff]"
09:23:06 <bernalex> but anyway really going now to pack. maerwald can probably explain it.
09:23:18 <Falkyouall> thanks anyway have a good one
09:24:50 <Falkyouall> all f = foldr (\x list -> f x && list) True
09:24:55 <Falkyouall> f x && list
09:25:04 <lyxia> Falkyouall: you can unfold the definition of foldr by hand on a short example.
09:25:09 <Falkyouall> so f take one argument.. doennt it?
09:25:26 <Falkyouall> i know the definition.. can write down foldr on my own
09:25:54 <Falkyouall> but especially this case makes me hedache
09:26:05 <lyxia> f is a function, right.
09:26:24 <Falkyouall> which takes one argument... (a-> bool)
09:26:47 <Falkyouall> which then is every element in my list
09:27:03 <Falkyouall> but f x && list i dont get that
09:27:09 <MarcelineVQ> you can infer f returns a bool because it's used against && which takes a bool
09:27:27 <MarcelineVQ> && returns true if both sides of it are true
09:28:00 <Falkyouall> but there is no f list apply section
09:28:34 <Falkyouall> ok because foldr does that, right?
09:28:49 <Falkyouall> its thinking arround corners
09:29:17 <lupin> bernalex: thanks!
09:30:44 <maerwald> Falkyouall: "foldr (\x y -> x - y) 0 [1..3]" is the same as "1 - ( 2 - ( 3 - 0 ) )", can you see what x and y in the lambda expression are here? Start at the innermost expression "3 - 0"
09:32:21 <MarcelineVQ> foldr processes 2 arguments each step, an accumulated value and the next value of a list as it traverses it, 'list' in this case is just the next item in the list being passed to the lambda, you could say y or xs or anything you want
09:32:25 <ronh> I suggest you don't start from the innermost point, because that is not how it works
09:32:35 <ronh> @src foldr
09:32:35 <lambdabot> foldr f z []     = z
09:32:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:33:27 <ronh> the first time foldr call your function (and all subsequent calls until the last one) acc is not True, but the next recursive call to foldr. this is why you foldr can shortciruit (you simply don't mention acc in the result)
09:34:11 <maerwald> ronh: I think starting from the innermost expression makes it easier to figure out what x and y are, regardless of the fact that the list is processed from left to right obviously
09:35:28 <Falkyouall> okay, yeah that is in fact helpful maerwald!
09:35:34 <Falkyouall> thanks!
09:35:48 <Falkyouall> i will inhale this the coming days
09:35:59 <maerwald> Falkyouall: mind however what ronh said, foldr doesn't start at the end of the list
09:36:27 <Falkyouall> yes thats clear to me
09:36:50 <Falkyouall> the acc makes me stumbling a lot in comb with lamda
09:37:54 <maerwald> > foldr (&&) True (repeat False)
09:37:56 <lambdabot>  False
09:38:03 <maerwald> > foldl (&&) True (repeat False)
09:38:08 <lambdabot>  mueval-core: Time limit exceeded
09:38:09 <lambdabot>  mueval: ExitFailure 1
09:38:14 <maerwald> Falkyouall: think about why that doesn't work with foldl
09:39:15 <Falkyouall> because foldl in fact uses the acc as the very first argment
09:40:16 <Falkyouall> so in "foldr (\x y -> x - y) 0 [1..3]" the x is not really the x... its already the list and x (0) is skipped till the very end
09:42:15 <maerwald> Falkyouall: mh, that sounds weird... but it's helpful to know where the recursion happens: foldr f z (x:xs) = f x (foldr f z xs) ...it happens in the second argument to 'f' (which is your lambda thing)
09:43:26 <maerwald> with foldl it's the other way around
09:45:10 <Falkyouall> i will take a deeper look at the foldr definition
09:46:11 <MarcelineVQ> Is it then the case that since haskell is lazy evaluation it can work its way inwards when you seperate the recursion like that, and since && only needs to be false once to be false it stops there?
09:51:39 <MarcelineVQ> oh I ​mean non-strict
09:52:34 <maerwald> MarcelineVQ: well, foldl cannot short-circuit on infinite lists at all since it must expand the whole thing before it can even start with the outermost && call, since that one is at the very end of the infinite recursion
09:53:02 <monochrom> foldr (&&) x [False, ...]  -->  False && foldr (&&) x [...]  -->  False
09:54:06 <monochrom> be sure to separate operator precedence (parsing) from evaluation order
09:54:50 <monochrom> "operator precedenece is about evaluation order" was a white lie, even if you stick to highschool math.
09:55:21 <monochrom> 0 * (3902843293084+293048032)  do you seriously follow their teaching and evaluate 3902843293084+293048032 first?
09:56:03 <monochrom> clearly, the parentheses is just to tell you the parse tree, not to tell you "evaluate me first"
09:56:27 <MarcelineVQ> actually that's a pretty interesting subject
09:56:55 <MarcelineVQ> > repeat 1 == [1,1..]
09:56:59 <lambdabot>  mueval-core: Time limit exceeded
09:57:27 <monochrom> but highschool doesn't want to tell you about parse trees, and eager evaluation doesn't hurt highschool math, so they tell you the little white lie that conflates parsing with evaluation
09:59:05 <maerwald> MarcelineVQ: foldl' is even worse in the && example... although it doesn't go through the whole infinite list before it starts calculating, it's not particularly lazy anymore
09:59:17 <maerwald> so it cannot short circuit either
10:00:01 <MarcelineVQ> I've seen that foldl' is strict though I haven't looked at the definition. as an aside, lamdbabot can @src things but is there similair functionality in ghci?
10:00:22 <quchen> No.
10:00:39 <quchen> Lambdabot has a text file it looks ?src definitions up in.
10:00:39 <maerwald> MarcelineVQ: I think leksah can do that for you
10:01:55 <MarcelineVQ> quite possibly, maybe atom too which is what​ I use, but I do a lot of my prototyping in ghci because it's so fast
10:02:09 <MarcelineVQ> Not that I do a lot of if, but when I do that's where I do it
10:07:27 <Zemyla> Is there a name of the profunctor that's defined by the product of a functor and a contrafunctor?
10:10:15 <phaazon> Zemyla: huh
10:10:24 <phaazon> isn’t that definition of Profunctor?
10:10:46 <bennofs> phaazon: no. profunctor is things that a contravariant in first arg and covariant in second
10:10:49 <phaazon> (Profunctor p) => p a b where it’s covariant in b and contravariant in a
10:10:55 <phaazon> yeah
10:11:25 <Zemyla> Yeah. This is like P f g a b = P (f a) (g b), where f is contravariant and g is covariant.
10:11:28 <bennofs> phaazon: now if you have f :: * -> * covariant and g :: * -> * contravariant, you can use that to build a profunctor data P a b = P (g a, f b)
10:12:21 <phaazon> I wonder why you use (,) though
10:12:43 <Zemyla> The problem is it doesn't admit any of the other classes in Data.Profunctor (Choice, Strong, etc.) but there are other operations it does admit which other profunctors do as well, but aren't in the classes.
10:12:43 <phaazon> oh it’s denotational?
10:13:07 <bennofs> phaazon: was just easier to type, no particular reason :P
10:13:14 <phaazon> ok
10:13:28 <phaazon> off topic, but I’m stuck with an issue I have no idea how to solve
10:13:33 <Zemyla> :t (***)
10:13:34 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:13:36 <phaazon> I’m writing a little GUI library
10:13:41 <Zemyla> :t (+++)
10:13:42 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:13:43 <phaazon> and have the following operator
10:13:44 <phaazon> (<%>) :: (MonadIO m) => (a -> a) -> El a -> m (El a)
10:14:03 <phaazon> I have no idea how I could change my El type to make that a Functor and replace <%> by <$>
10:14:19 <Zemyla> phaazon: What is your E1 type?
10:14:30 <phaazon> l (L)
10:14:32 <bennofs> phaazon: never going to be a functor because of the monad type
10:14:34 <phaazon> for Element
10:14:44 <phaazon> bennofs: I don’t care about the Monad
10:14:56 <bennofs> phaazon: well, do you need to do IO to implement (<%>)?
10:15:05 <phaazon> yeah :/
10:15:21 <phaazon> oh you mean, in my actual implementation
10:15:23 <bennofs> phaazon: also, can you do (a -> b) -> El a -> m (El b) ?
10:15:41 <phaazon> bennofs: nope
10:16:01 <phaazon> the internel implementation forbids that
10:16:11 <phaazon> I have both covariant and contravariant stuff in there
10:16:15 <phaazon> like a and a -> IO ()
10:16:16 <phaazon> :(
10:16:48 <bennofs> phaazon: split covariant and contravariant up, and make El' :: * -> * -> * and then always use type El a = El' a a in the Api
10:17:33 <phaazon> bennofs: https://github.com/phaazon/agui/blob/master/src/Graphics/UI/AGUI/Core/El.hs
10:17:37 <phaazon> El is defined in there
10:18:20 <phaazon> and basically, type Renderer a = a -> IO ()
10:19:25 <bennofs> phaazon: you will not be able to make that Functor or Profunctor, since you want to observe when the 'a' is changed (you trigger an event there)
10:19:35 <phaazon> yes
10:19:51 <phaazon> but my Event is a Functor
10:19:54 <phaazon> it’s even a Monad
10:20:00 <phaazon> so the Event is not the problem here I guess
10:20:16 <bennofs> phaazon: the problem is that f <$> someEl should *fire* and event (= do IO)
10:20:33 <phaazon> hm
10:21:23 <phaazon> I’m just not sure that API is a good one
10:21:33 <phaazon> I see a lot of folks going with pure API
10:21:37 <phaazon> like FRP’s one
10:21:40 <phaazon> I just don’t get it
10:22:40 <EvanR> a -> IO () is a contrafunctor right
10:23:02 <bennofs> EvanR: contravariant functor yes
10:23:13 <bennofs> @hackage contravariant
10:23:13 <lambdabot> http://hackage.haskell.org/package/contravariant
10:23:15 <ttt_fff> how does rust and haskell compare?
10:23:24 <ttt_fff> if I want a system-y haskell, what does rust lack?
10:23:33 <phaazon> not even sure it’s a contravariant
10:23:47 <exio4> ttt_fff: higher-kinded types, IIRC?
10:23:56 <ttt_fff> what are higher-kinded types?
10:24:02 <ttt_fff> I'm not sure I have ever used them in haskell
10:24:10 <kadoban> ttt_fff: They're extremely different languages, so I'm not sure it even makes sense to ask what it lacks. It borrowed a bit about the types from haskell, that's about it?
10:24:11 <phaazon> ttt_fff: :k []
10:24:14 <phaazon> :k []
10:24:15 <lambdabot> * -> *
10:24:22 <phaazon> :k ContT
10:24:23 <lambdabot> * -> (* -> *) -> * -> *
10:24:24 <exio4> no, [] is not higher-kinded
10:24:31 <EvanR> rust doesnt seem to compare at all to haskell
10:24:50 <kadoban> Rust compares more to C or C++
10:25:12 <EvanR> built-in unique smart pointers :(
10:25:22 <EvanR> smart pointers = no pointers
10:25:35 <ttt_fff> gc = smartest pointer ever
10:26:19 <EvanR> how does rust compare with D, is the question
10:27:14 <lyxx> @NickServ identify
10:27:14 <lambdabot> Unknown command, try @list
10:27:21 <phaazon> D’s dead
10:27:28 <EvanR> long live D
10:29:19 <bernalex> maybe in some not too distant future we could see lots of systems programming done in rust and idris.
10:31:03 <kadoban> For some reason I kinda suspect systems programmers are too entreanched in their current languages, they don't seem to be an adventurous group in general.
10:31:09 <EvanR> can i has systems programming in haskell
10:31:40 <bernalex> kadoban: I agree. but the next big thing won't be written by the old dogs. it will very likely be written by a research group.
10:32:17 <monochrom> many next big things have already been written by many research groups.
10:32:21 <kadoban> bernalex: Yeah, probably. It's just a matter of getting people to actually use it. Maybe you just need to wait ~a generation :-/
10:32:35 <monochrom> but coinductively, every year they remain the next big thing
10:33:27 <monochrom> when I was a grad student, I witnessed a next big thing died slowly
10:34:59 <monochrom> it was "we will soon distribute computation over several computers on the same LAN. we need an across-the-LAN RAM-lookalike. we need to explore implementation details"
10:36:52 <monochrom> that generated many, many MSc theses, each trying one implementation strategy (usually just a tweak away from previous ones), benchmarking it, concluding essentially "this flies in cases XYZ but sucks in cases PQR"
10:37:20 <monochrom> (evidently, each thesis has a different XYZ and and different PQR from other theses)
10:37:46 <adarqui> os's written in rust seem interesting
10:37:59 <monochrom> that lasted for 5-10 years. it died because across-the-LAN was subsumed by multi-core
10:38:32 <monochrom> well, first subsumed by SMP. then SMP in turn subsumed by multi-core
10:42:08 <monochrom> we need to learn this lesson: the future is not going to have our today's next big thing. instead, the future will have something with both superior performance and trivial implementation
10:47:07 <EvanR> superscalar!
10:47:43 <bennofs> monochrom: i hope you're right :d
10:48:38 <kadoban> monochrom: I suspect that there wasn't much way to tell in advance that that was a dead-end, even if it is (isn't it still relevent? I don't see how having multicore totally removes the need for clusters?)
10:49:30 <monochrom> ok, clusters are still relevant, but RAM-across-the-LAN is not
10:50:06 <monochrom> cluster users have simply settled with PVM and be done with it
10:51:27 <monochrom> and a programmer who really wants "one single RAM model" simply uses one single motherboard with multiple cores
10:52:05 <kadoban> Ah
10:54:20 <ttt_fff> waht is one single RAM ?
10:54:22 <ttt_fff> as opposed to what
10:55:16 <monochrom> as opposed to being aware that you have 5 boxes and 5 disconnected RAMs
10:55:20 <benzrf> what is PVM, monochrom
10:55:54 <monochrom> PVM is an API for assigning jobs and data to computers on your LAN
10:56:26 <monochrom> http://www.csm.ornl.gov/pvm/ or the wikipedia article
10:57:36 <monochrom> "beowulf clusters" was cool once upon a time. but when I looked at its definition, it's just "LAN, linux, PVM"
10:58:01 <monochrom> I am also known to be a blatant reductionist on scientific matters
10:59:18 <monochrom> anyway PVM is probably sitting at a sweet spot of how-much-to-abstract-away and how-much-not-to. it's cool.
11:03:30 <monochrom> of course, in principle, you do not have to use a LAN. PVM assumes IP, that's it. in practice, of course LAN performs better, and more importantly, less hassle to setup and control
11:04:27 <monochrom> (you be damned if you used PVM across the world and therefore need to phone up someone 12 timezones away to reboot a computer and hope that the someone doesn't give you an attitude)
11:04:57 <exio4> monochrom: RAM-across-the-lan sounds way nicer though
11:08:07 <ttt_fff> at the risk of being kick banned, isn't #erlang better for these problems? :-)
11:08:26 <ttt_fff> unless there's some way to get "cluster as a monad"
11:08:41 <ttt_fff> that'd be badass; if I write one program, and via a monad, it controls an entire aws cluster
11:08:45 <ttt_fff> i'd pay for that shit
11:08:49 <ttt_fff> mesosphere for haskell
11:09:00 <monochrom> I have not learned erlang.
11:09:26 <monochrom> a priori I would not assume it is suitable. despite all the "concurrent" keyword
11:09:31 <pharpend> ttt_fff: you would only get kickbanned if you said #ruby or maybe #javascript
11:09:41 <monochrom> keywords mean nothing to me. because out of context.
11:10:08 <monochrom> even "Haskell is lazy" does not mean what you think
11:10:16 <ttt_fff> pharpend: why is ruby/javascript worse than the other uncultured langauges used by barbarians?
11:10:24 <monochrom> every one-sentence summary contains 0 information.
11:10:45 <ttt_fff> lambdabot quote monochrom "every one-sentence summary contains 0 information"
11:11:11 <pharpend> ttt_fff: because Erlang has *some* of the things that make Haskell nice, namely the lack of mutability.
11:11:28 <adarqui> ttt_fff: this isn't what you asked for but, really interesting AWS library in development worth checking out: https://github.com/brendanhay/amazonka
11:11:30 <ttt_fff> if erlang just ahd types, I'd be sorta happy
11:12:04 <ttt_fff> adarqui: hmm, it's "aws api" as a monad?
11:12:05 <monochrom> if erlang had types, then the hotplug problem would be much harder
11:12:18 <adarqui> ttt_fff: runAWST bro! :)
11:12:38 <ttt_fff> adarqui: I don't get the joke, since I don't know what the library does yet
11:12:40 <ttt_fff> :-(
11:12:44 <ttt_fff> TEACH ME
11:12:55 <monochrom> perhaps s/hotplug/hotswap/
11:12:57 <adarqui> check the readme, it has "runAWST env $ do .."
11:13:00 <pharpend> ttt_fff: OCaml is even okay. It allows for functional programming, more so than most languages. It doesn't have Typeclasses or Monadic IO, though, so Haskell is my favourite
11:13:05 <adarqui> so, i imagine some monads
11:13:06 <ttt_fff> wtf does "amazonka: contains a monad transformer, send/receive, and pagination logic." mean
11:13:11 <ttt_fff> oh, I'm reading the wrong docs
11:13:37 <ttt_fff> e <- getEnv Ireland Discover <-- NO FUCKING WAY. This fires up a server in Ireland?
11:14:23 <monochrom> I now understand why my prof states the Church-Turing thesis as "every logical algorithm can be done by a Turing machine"
11:14:25 <adarqui> supposedly, dope right? and the entire SDK is GENERATED FROM AWS API DOCS!@$ or something..
11:14:31 <monochrom> especially why add "logical" there
11:14:54 <adarqui> so if they (aws) add a new service, you can run a command/script to generate the amazonka code for it..
11:14:55 <monochrom> it is because some people like to say "pagination logic" to mean "pagination algorithm"
11:15:04 <ttt_fff> adarqui: what? SKYNET IS HERE
11:15:08 <adarqui> pharpend: mutability sucks but i'm looking at 173 .c files in this ghc source
11:15:10 <ttt_fff> it starts out with generating AWS APIs
11:15:13 <bernalex> pharpend: ttt_fff: erlang is not a purely functional language.
11:15:28 <ttt_fff> then it integrates with AWS Mechanicla Turk, and before we know it, there's computer programs leveraging humans (via MTURK) to detect / kill other humans
11:15:50 <ttt_fff> bernalex: erlang vars are single assignment; there's 'dictionary' for haskell also has IOVar
11:15:57 <adarqui> ttt_fff: now u can control ur aws from a monad, gogogo
11:15:59 <adarqui> seems fun
11:16:14 <ttt_fff> adarqui: this is scary, a programming error can now bankrupt me
11:16:26 <adarqui> ha
11:21:02 <Zemyla> Hmm. If forall r. (a -> m r) -> m r ~ forall r. Kleisli m (Kleisli m a r) r is a monad, then is forall r. Cokleisli w (Cokleisli w a r) r also a monad?
11:21:37 <Zemyla> Well, if w is a comonad.
11:24:24 <lamefun> is there an alternative let for do that doesn't require over-indentation?
11:24:52 <exio4> lamefun: you can use {} 
11:25:18 <exio4> > do { let { x :: Int; x = 2; }; [x]; }
11:25:19 <lambdabot>  [2]
11:25:43 <lamefun> I know, but I'd rather overindent than that
11:30:43 <Noinia> Is there any way to define a type family where the 'result types' have different kinds? 
11:32:17 <Noinia> i.e. s.t. like: type family F (t :: *) :: ??? ; F Int = (->) ; F Bool = Int 
11:33:14 <Noinia> hmm
11:33:33 <Noinia> apparently that still works if you choose ??? = k 
11:33:52 <Noinia> so then I have to figure out better what the right question is 
11:35:10 <Noinia> hmm, well I guess the problem then is that: the kind of 'F Int' is now (forall (k :: BOX).  k), where I still want it to be * -> * 
11:40:15 <benzrf> Noinia: you could have another type family
11:40:34 <benzrf> that maps types to F's output kind
11:40:38 <benzrf> wait, are kind families a thing
11:42:19 <GLM> Does anyone have guides for crypto in Haskell?
11:44:39 <benzrf> GLM: it's not haskell, but cryptol is a thing
11:45:26 <GLM> benzrf:Thanks but I reallt want the project to be in Haskell
11:45:32 <benzrf> kk
11:46:14 <adarqui> cryptol is really nice. would be cool if maybe you could output haskell/c/ocaml code from it
11:49:31 <Noinia> benzrf: I don't think that works, or at least, s.t. like this does not: http://lpaste.net/136341
11:50:06 <Noinia> and I'm not sure how defining a separate family K (t :: *) :: k would help 
12:10:04 <Welkin> has anyone used hamlet with hakyll?
12:10:12 <Welkin> the hakyll template system is horrible
12:10:43 <Welkin> I'm not sure where to begin, since hakyll is not user friendly, and is very different from yesod/scotty/spock
12:11:01 <Welkin> is there a simple way to use hamlet templates with hakyll?
12:11:05 <bernalex> I have not used hamlet, but found hakyll very simple to work with. ymmv I guess. -_o_-
12:11:18 <Welkin> I am used to working with hamlet
12:11:31 <Welkin> it is much better than what is built in to hakyll
12:12:20 <Welkin> bernalex: simple to work with in what way? the templates?
12:13:16 <benzrf> Noinia: i mean like
12:13:22 <bernalex> Welkin: it just never gave me any trouble. I wrote my website in a few hours and everything was just easy and neat. my website is not very complicated though.
12:13:39 <benzrf> Noinia: make a type family D such that
12:14:29 <benzrf> Noinia: F :: forall (t :: *). D t
12:15:13 <benzrf> Noinia: standard dependent type there
12:16:55 <rpsteve> hi. I have a really odd bug in a haskell gtk2hs program that appears and disappears randomly (it always works fine in ghci) I am doing a couple of tasks done with forkIO that appear to be stalled when certain things fall together. to test this I wrote "asyncTest = print "async test!" >> threadDelay 100000 >> asyncTest", ran it with forkIO asyncTest, and it is printed only once, and then to get it 
12:17:29 <rpsteve> to print again I need to right click a couple of times somewhere on the gui.
12:18:01 <rpsteve> I tried to recompile with "-threaded -rtsopts -with-rtsopts -N" options, it didn't help. then I sprinkled prints everywhere, and after I added the last print it appeared to work, and continued to work even when I removed prints and those compile flags. and now I'm stuck at it not working again
12:18:47 <rpsteve> anyone experienced something like this, or knows what it could be? this is a program that worked fine for over a year
12:21:16 <rpsteve> I did recently (a couple of months ago) switch from ghc 7.6.3 to 7.8.4. not saying this is what is causing it, but who knows
12:25:13 <whiteline> rpsteve: flush stdout?
12:26:16 <rpsteve> no it isnt it, it is flushed on newlinr. and other async tasks are delayed or dont happen at all
12:27:16 <Denommus> hspec seems interesting. Is it really?
12:28:06 <rpsteve> btw I added hFlush stdout just to eliminate that possibility completely, and same thing happens
12:28:31 <maerwald> @hackage hspec
12:28:31 <lambdabot> http://hackage.haskell.org/package/hspec
12:28:37 <whiteline> rpsteve: well, rtsopts only affect parallelism i'm pretty sure
12:29:07 <maerwald> Denommus: ah that, afair that's really just a lot of syntax sugar, not much it provides on top of the existing frameworks
12:32:25 <bernalex> Denommus: hspec is quite useful.
12:32:28 <rpsteve> whiteline: i know. i thought perhaps OS threads (within gtk2hs) were blocking the only thread somehow, since other thread was executing after I right clicked ok GUI
12:32:57 <rpsteve> err, OS api calls within gtk2hs
12:33:04 <bernalex> Denommus: if you have a program that needs spec/unit-based testing, hspec and hunit are rather neat. but if you can do property-based testing with quickcheck that's probably better.
12:33:17 <whiteline> rpsteve: shouldn't be so
12:33:40 <whiteline> have you tried catching the exceptions? there's two "stalled" exceptions that you seem to be able to catch
12:33:49 <whiteline> i've never done this though
12:33:50 <Ibispi> hello
12:33:55 <f-a> hello Ibispi 
12:34:03 <rpsteve> when I type in gtk's textbox "async test" get printed as well..
12:34:05 <bernalex> maerwald: everything is beta-reduceable so everything is "just a lot of syntax sugar" if hspec is.
12:34:08 <Ibispi> bye
12:34:13 <whiteline> the default exception handler doesn't catch them, apparently
12:34:37 <rpsteve> where should I catch them?
12:34:52 <bernalex> hspec is a DSL that integrates with quickcheck, smallcheck, or hunit. it is rather useful. ymmv.
12:34:57 <rpsteve> if they arent caught why is program still running?
12:35:21 <whiteline> rpsteve: because they signal thread stall?
12:35:29 <bernalex> omnom. food. bike.
12:36:28 <rpsteve> I see. still not sure where to catch them? in asyncTest?
12:37:30 <whiteline> https://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:forkIOWithUnmask
12:38:02 <whiteline> *shrug*
12:38:09 <rpsteve> let me try
12:46:32 <rpsteve> I have no clue how to change my asyncTest function to be used with forkIOWithUnmask, but I am still making some progress. I forced recompile of all the files with functions that are used with forkIO with -threaded -rtsoptd -with-rtsopts -N, and now my program works again
12:47:16 <rpsteve> (I thought that is what cabal does automatically when I chamge compile flags but apparently not)
12:48:03 <rpsteve> so why are threads stalled if I dont compiled with those options? again it all worked fine for over a year
12:50:16 <rpsteve> I am happy it is working again, but really odd that I suddenly need those flags
13:01:20 <mdmkolbe> I am teaching a tutorial on Haskell.  Is their a way to "disable" the "Num" class (say they are all Int) do we don't have to discuss that until we get to type classes?
13:02:20 <earthy> mdmkolbe: default (Integer, Double)
13:02:31 <earthy> or something similar
13:03:07 * hackagebot effin 0.3.0.1 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.3.0.1 (AnthonyVandikas)
13:03:46 <mauke> mdmkolbe: no
13:06:42 <c_wraith> mdmkolbe: use Helium instead of haskell.  It's a nearly-haskell language that has no type classes, intended for teaching beginenrs.
13:06:45 <c_wraith> *beginners
13:12:18 <bernalex> mdmkolbe: fund my programming language for teaching which is meant to let you do that? ;)
13:13:15 <bernalex> mdmkolbe: https://secure.plaimi.net/papers/2015-01-16-froskell-programming-language.pdf -- programming teachers thought it was a great idea. so did some other people. nobody's been offering any funding yet though. :p
13:14:54 <c_wraith> bernalex: how does your plan differ from Helium?  (or is that covered in the doc?)
13:15:17 <c_wraith> Ah.  The table of contents suggests it is
13:16:11 <lamefun> Can I prevent nonsense values, eg. "data Expr = ... | Return Expr; nonsense = Return nonsense"?
13:16:39 <c_wraith> lamefun: not of that sort, no.
13:16:39 <mauke> nonsense = undefined :: Expr
13:17:02 <mauke> you could make Return strict, of course
13:17:27 <c_wraith> Alternatively, you could depth-index the type..  So long as you want only finite expression trees
13:17:56 <c_wraith> data Expr n = ... | Return (Expr (n - 1))
13:18:10 <c_wraith> ..  Nevermind how well DataKinds doesn't work for that sort of use, yet. :)
13:18:36 <c_wraith> You'd really need some sort of GADT to make that work completely properly.
13:18:51 <c_wraith> But even that doesn't prevent bottoms like undefined
13:19:00 <c_wraith> It just prevents nesting an expression in itself.
13:19:29 <c_wraith> data Expr n where Return :: Expr n -> Expr (n + 1)
13:20:41 <bernalex> c_wraith: it is. our language would let you toggle features, so you could set up a course where the user unlocks more advanced features as they master the more basic ones. in some respects it is similar to how racket is structured. but its emphasis is use in a teaching environment. 
13:22:11 <sm> Welkin: you could look back in hakyll code history, it used to support hamlet
13:22:59 <c_wraith> @let import GHC.TypeLits
13:23:00 <lambdabot>  Defined.
13:23:23 <c_wraith> @let data E (n :: Nat) where Return :: E n -> E (n + 1)
13:23:24 <lambdabot>  Defined.
13:23:37 <c_wraith> :t let nonsense = Return nonsense in nonsense
13:23:38 <lambdabot> ((n + 1) ~ n) => E n
13:23:57 <c_wraith> lamefun: as you can see, nonsense is only defined when n = n + 1
13:24:55 <c_wraith> lamefun: so there you go.  If you make everything crazier, you can statically forbid that precise error case. :)
13:29:44 <Haskellfant> I was trying to use +RTS -xc to debug the cause for a broken pipe, but when I use this I get a flood of other exceptions http://lpaste.net/136345 . what could be causing this or how do I find out what exactly they are?
13:33:07 <mauke> no idea, but I'd try strace
13:36:35 <Haskellfant> allright, I'll try that
13:42:46 <ely-se> Is it possible to use a monad transformer with ST? I tried this but it fails to compile: http://lpaste.net/136346
13:42:53 <ely-se> Is it because of "forall a."?
13:44:05 <Haskellfant> Ah I think I found the cause: it's sigalarms which are used when the threaded runtime is not enabled
13:44:18 <c_wraith> ely-se: it's actually the use of the . on line 7
13:44:36 <c_wraith> ely-se: try runST (runEither $ return 1)
13:46:07 <ely-se> !! :O
13:46:11 <ely-se> c_wraith: thank you! <3
13:46:21 <c_wraith> ely-se: as a full explanation..  the type of (.) is (b -> c) -> (a -> b) -> (a -> c).  In that use of (.), you're trying to unify `b` with (forall s. ST s a)
13:46:30 <ely-se> nice
13:46:35 <c_wraith> ely-se: and the unification algorithm doesn't keep that forall around
13:46:41 <ely-se> using $ instead of . seems to work too
13:46:50 <c_wraith> ely-se: yeah, there's a hack to make $ work with runST :)
13:46:55 <ely-se> :v
13:47:23 <c_wraith> ely-se: ghc actually handles the type of ($) differently than the type of anything else, just to make runST $ do ...  work
13:47:30 <ely-se> cool
13:50:46 <meditans> zipper: yes, I have a few question on ide-backend, if you are around
13:53:09 * hackagebot find-conduit 0.4.4 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.4.4 (JohnWiegley)
14:03:09 * hackagebot picosat 0.1.3 - Bindings to the PicoSAT solver  http://hackage.haskell.org/package/picosat-0.1.3 (sdiehl)
14:15:48 <phaazon> hey
14:16:01 <phaazon> what do you think of ContT to handle implementation details for an abstract library?
14:16:40 <quchen> ..?
14:16:50 <quchen> If it's abstract, why should I care about the implementation?
14:17:06 <phaazon> quchen: well, it has to be resolved at some point
14:17:18 <phaazon> I’d like to write an abstract library for exposing a GUI
14:17:27 <phaazon> but without having to implement the renderers and input handlers
14:17:53 <phaazon> data Backend = Render Element | …
14:17:59 <phaazon> and use ContT Backend
14:22:27 <Cale> phaazon: I'm not sure I understand, but see also free monads and/or MonadPrompt
14:23:46 <phaazon> Cale: yeah, but free monads are a bit more complex to construct
14:24:09 <phaazon> anyway, what would you use ContT for then?
14:25:04 <johnw> ContT is used to compose computations that need to abort or resume
14:25:13 <johnw> for example, the core type of the "pipes" library can be rewritten as:
14:25:35 <johnw> forall s. (a' -> ContT s m a, b -> ContT s m b') -> ContT s m r
14:25:54 <phaazon> the core type?
14:25:55 <phaazon> you mean
14:25:57 <phaazon> Proxy?
14:25:57 <johnw> Proxy
14:26:00 <phaazon> right
14:26:20 <johnw> because what this type is really doing is interleaving two resumable computations (upstream and downstream)
14:26:31 <johnw> and composing them into an action producing a final result
14:26:47 <phaazon> I don’t really get why people say “resumable”
14:26:51 <phaazon> to me
14:26:55 <phaazon> the ContT is a bit like a reader
14:27:05 <johnw> produce a result and give the caller a way to "call back" into where you were when you gave that result
14:27:13 <phaazon> but it can access a bit further the environment value
14:27:35 <johnw> ContT a m r is (r -> m a) -> m a
14:27:42 <phaazon> yes
14:27:50 <phaazon> hu
14:27:53 <phaazon> it’s not the correct type
14:28:00 <phaazon> ContT r m a = (a -> m r) -> m r
14:28:05 <johnw> ah, right, sorry
14:28:12 <phaazon> so here
14:28:20 <phaazon> it’s like (a -> m r) is in the reader
14:28:30 <phaazon> and we can get it and apply it when we need it
14:28:33 <johnw> but ReaderT r m a is r -> m a
14:29:00 <johnw> in ContT, you must pass an "a" to access the "m r"
14:29:05 <johnw> in ReaderT, you are simply given the "r"
14:29:21 <phaazon> johnw: yeah, but that value is supplied inside the computation itself
14:29:39 <johnw> try writing an isomorphism between ReaderT and ContT, to see how it fails
14:30:09 <phaazon> yeah I understand why it fails
14:30:16 <phaazon> I’m just trying to figure out the true semantics of ContT
14:30:28 <phadej> I think that ContT is just one of free monads out there; callCC is a bonus
14:30:36 <johnw> ContT is a chaining of computations, where each link in the chain is given the rest of the chain
14:30:40 <phaazon> phadej: yeah, I agree on that
14:30:53 <phaazon> it sounds we can use ContT to do the same thing than we do with Free
14:30:54 <johnw> and so it can choose to either ignore the rest of the chain, or store it and call it later and/or repeatedly
14:31:54 <johnw> phaazon: try it :)
14:31:58 <phaazon> I am
14:32:03 <phaazon> btw
14:32:17 <phaazon> callCC is just a shortcut to get k, isn’t it?
14:32:39 <phaazon> runContT (callCC ... $ \k) g
14:32:40 <phaazon> k == g
14:32:44 <phaazon> I guess?
14:34:11 <phaazon> yeah not that close
14:34:15 <phaazon> I’ll just try it.
14:36:20 <tmtwd> is this an illegal list in haskell?:  let y =  [[3, 4], [[1,2],[5,6]]]
14:36:34 <johnw> phaazon: in that example, k should be g
14:36:44 <phaazon> johnw: http://lpaste.net/7652583813876285440
14:36:44 <phaazon> here
14:36:50 <johnw> callCC gives you the continuation that >>= would have called for you
14:37:44 <phaazon> tmtwd: yes
14:37:49 <phaazon> > [[3, 4],  [[1,2],[5,6]]]
14:37:50 <johnw> phaazon: I'd suggest studying the difference between ContT and http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free-Church.html
14:37:51 <lambdabot>      No instance for (Show t0)
14:37:51 <lambdabot>        arising from a use of ‘show_M580683543157022464231149’
14:37:51 <lambdabot>      The type variable ‘t0’ is ambiguous
14:37:59 <phaazon> johnw: and what?
14:38:00 <phaazon> Free?
14:38:02 <johnw> for one, a church encoding of FreeT does not expose the existential
14:38:29 <phaazon> tmtwd: try to give a typo to your list
14:38:36 <phaazon> you’ll understand why it’s illegal
14:38:50 <johnw> I think that ContT () m a is equivalent to m a
14:38:57 <phaazon> well, it *might* hwork with a Num instance + IsList, but hm, ahah.
14:39:02 <tmtwd> phaazon, that list won't even compile
14:39:11 <phaazon> tmtwd: it depends
14:39:24 <phaazon> it actually can
14:39:54 <johnw> so your GUI type is just an 'm (Backend a)' action, effectively, which is not what Free gives you.  Free lets you analyze how Backend constructor were composed, after the fact
14:40:22 <johnw> i.e., Free (Render a (Free (New (Pure ())))), for example
14:40:34 <phaazon> johnw: I see Free used everywhere and it actually scares me a bit
14:40:38 <phaazon> I know how to use it
14:40:50 <phaazon> but I also know it’s a complex type, slow without using optimize, and so on
14:40:59 <johnw> Free is the simplest way to build syntax trees out of algebras encoded as fixed-points of functors
14:41:29 <johnw> the Church encoding of Free that I linked you too does not suffer from the quadratic slowness of regular Free
14:41:51 <dolio> It just suffers from different quadratic slowness.
14:41:51 <phaazon> I’ll check it out
14:42:10 <johnw> dolio: hence "Reflection without Remorse" :)
14:42:15 <phaazon> johnw: so you’re saying that the best option to write abstract code with deferred backend is through Free?
14:42:27 <dolio> Which suffers from moderate slowness in all cases. :)
14:42:33 <phaazon> tmtwd: wait, I’ll paste you something
14:42:33 <johnw> phaazon: I'm saying that's the most general way to do it, giving you a lot of prebuilt machinery
14:42:44 <phaazon> johnw: right, I’ll try to bring it on then
14:42:46 <johnw> I'm not saying it's always the best, as dolio points on
14:42:50 <phadej> Ah, I did remembered wrong. forall r. ContT r m a ~ Codensity m a; and latter is a free monad...
14:43:03 <johnw> there are trade-offs to be made, depending on how you will use the resulting abstract tree
14:43:10 <dolio> The point is you should know what you're doing, and which tradeoffs are right for you. :)
14:43:11 * hackagebot transformers-lift 0.1.0.0 - Ad-hoc type classes for lifting  http://hackage.haskell.org/package/transformers-lift-0.1.0.0 (int_index)
14:43:48 <Cale> Ask your doctor if these tradeoffs are right for you.
14:43:57 <dolio> Codensity is not a free monad.
14:44:52 <phaazon> yeah well
14:44:58 <eds> pacak : I still cant seem to find a solution for this http://lpaste.net/132328. The error is related to MonadRandom.
14:45:00 <phaazon> I’m not fluent with free monads
14:45:46 <platz> Even though this is mixing terms from different contexts somewhat, Would it be correct to say that Event Sourcing is analogous to a Deep Embedding?
14:49:34 <xendo> Hey does anyone use Hasklig with Atom?
14:51:43 <phadej> dolio: depends on what you understand as "free monad", it's 'Monad (Codensity f)' without any restrictions on f. To me it's "more free" than `Free`. I don't see a problem with a fact that you cannot inspect the structure.
14:53:36 <dolio> It doesn't depend on anything but the mathematical definition of "free".
14:54:33 <shachaf> dolio: The mathematical definition of "free" is "left adjoint to forgetful", where "forgetful" means whatever you like.
14:54:35 <phaazon> runFT :: forall r. (a -> m r) -> (forall x. (x -> m r) -> f x -> m r) -> m r
14:54:38 <phaazon> wuhu :D
14:54:44 <shachaf> I guess that definition still constrains it to be a left adjoint, though.
14:55:13 <phaazon> ok, so, I guess the forall r. (a -> m r) is the current continuation
14:55:26 <phaazon> (forall x. (x -> m r) -> f x -> m r) -> m r is the rest of the chain
15:02:56 <Cale> shachaf: It would be weird to call a functor forgetful if it weren't faithful though.
15:04:18 <dolio> Also since there's other structure involved, you are limited to being left adjoint to a functor between two particular categories.
15:05:12 <dolio> If it's 'over a functor' you need to be left adjoint to a functor U : Monad -> Endofunctors.
15:05:45 <dolio> If it's 'over a type constructor with kind * -> *' it needs to be U : Monad -> (* -> *).
15:05:46 <greymalkin> Is there a shorthand for 'action >>= \f case f of....'
15:06:11 <arkeet> you could use LambdaCase
15:06:41 <arkeet> so \f -> case f of ... becomes \case ...
15:07:29 <arkeet> (unless of course you need to refer to f inside ..., but then you could use an as-pattern
15:09:21 <shachaf> dolio: I imagine that there are lots of adjunctions between those categories.
15:11:35 <relrod> Are licensing an acceptable reason to use orphan instances? e.g. If I want to provide instances for a BSD-licensed lib's data types for typeclasses that come from a (L)GPL-licensed lib, can I just create a separate (L)GPL-licensed package with those instances?
15:11:46 <relrod> erm, Is licensing*
15:14:46 <bernalex> ronh: personally I find orphaned instances sometimes necessary, so I don't see a problem with what you are describing. just -fno-warn-orphans it.
15:14:54 <bernalex> uhm relrod ^
15:15:00 <bernalex> preferably with an explanation.
15:17:20 <lamefun> is there a library for multi-threaded tasks with progress report?
15:22:44 <sccrstud92_> I have read articles that say that any monad can be implemented witht he Cont monad. Has anyone seen any articles that do this?
15:23:55 <chrisdotcode> what version of base does ghc 7.10 use?
15:23:58 <chrisdotcode> 4.10?
15:24:00 <arkeet> 4.8
15:24:11 <chrisdotcode> thanks :)
15:26:13 <hsk7> Is there a way to quickly remove element from the back of a list and add a new one to the beginning of a list?
15:26:16 <hsk7> And doing that repeatedly
15:26:23 <hsk7> Is difference lists what I'm after or what?
15:26:55 <sccrstud92_> hsk7: diff lists will work if you dont have to look at the elements of the list in between
15:27:09 <sccrstud92_> but if you have to convert back and forth it will be hard
15:27:17 <sccrstud92_> also i dont think u can remove elements with a dlist
15:27:24 <quchen> hsk7: Removing elements from the back of your list is always expensive.
15:27:29 <dolio> shachaf: Can you find one such that codensity is the left adjoint?
15:27:43 <hsk7> quchen: bummer.
15:27:50 <arkeet> hsk7: so you are looking for a queue
15:28:05 <quchen> hsk7: Data.Sequence might be worth a look.
15:28:35 <jplatte> Hi, is there a way of having a 'sources' list in a project's cabal.config / project.cabal file?
15:28:35 <jplatte> Having everyone who wants to build a program with dependencies outside cabal manually execute "cabal sandbox add-source" for each of those is really not an option.
15:30:39 <hsk7> quchen: ok, thanks
15:32:29 <hsk7> quchen: it's in times like these where i can't help but wonder why i'm bothering with haskell. always have to find some hacks to accomplish stuff. i guess that's the price i pay for purity, etc.
15:32:31 <hsk7> comments?
15:32:40 <hsk7> convince me to stay with haskell
15:32:42 <hsk7> :)
15:32:54 <hsk7> sometimes i get a bit discouraged :(
15:33:13 * hackagebot old-version 1.4.2 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.4.2 (chrisdotcode)
15:33:18 <chrisdotcode> :D
15:33:32 <hiptobecubic> Hey everyone. I'm working on a programming puzzle that involves writing a brainfuck interpreter now. Modeling the memory and operations on it is easy enough using a zipper and State, but I'm wondering about the interpreter itself. For example, I'll bump into tokens like ']' which cause conditional jumps backwards in the source to the matching '['. Is the right thing to do just try to read the string in and
15:33:34 <hiptobecubic> build an AST or something?
15:33:49 <quchen> hsk7: List are singly linked lists. If you want to repeatedly use the last element that's a bad choice of data structure.
15:34:18 <dolio> shachaf: Here's an easier question, even. If Codensity ⊣ U, then U = Lan Codensity Id. So, is Codensity ⊣ Lan Codensity Id?
15:34:35 <quchen> hsk7: This is not a Haskell problem, just like using a std::vector for a key=>value store in C++ is not a C++ problem.
15:34:52 <hsk7> hmok
15:37:08 <hsk7> quchen: is Data.Sequence common to use instead of lists?
15:37:14 <hsk7> if you want more speed
15:38:09 <quchen> hsk7: It's in containers, which is a common library. Whether it's right for your problem depends on your problem. There are plenty of algorithms for which lists are a good choice.
15:38:20 <Welkin> hsk7: if you need a list, use a list
15:38:29 <Welkin> I love using Data.Sequence for simple queues
15:38:30 <quchen> hsk7: Without knowing the problem, we can't tell you what a good data structure might be .
15:38:35 <Welkin> or double-ended lists
15:39:12 <quchen> A list in Haskell is often similar to a loop in imperative languages. Some even say that lists are a form of control structure in Haskell.
15:39:26 <Welkin> yeah, a list is often used as a control structure
15:39:40 <quchen> For example, `iterate f x` builds a list of repeated applications of `f` that you can then walk over.
15:39:43 <quchen> > iterate (+1) 0
15:39:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:41:51 <hsk7> basically, what i'm after is keep loop through the stock market over the past 20 years, keeping only 30 days in the list at the same time (to save memory)
15:41:58 <hsk7> so i loop through the days
15:42:05 <hsk7> add day to the front, remove day from the back
15:42:07 <hsk7> and move on
15:42:17 <hsk7> is that typical Data.Sequence?
15:43:16 <Welkin> why do you want to do this?
15:43:25 <quchen> Moving average?
15:43:31 <quchen> … for example
15:43:37 <hsk7> yeah moving average, among other things.
15:43:37 <Welkin> no, I mean, haskell lists are lazy
15:43:44 <Welkin> so you don't have to load the whole list in at once
15:44:20 <Welkin> in fact, you can stream the data too
15:44:30 <Welkin> have you looked at conduit or pipes?
15:45:08 <hsk7> no..
15:45:11 <quchen> That's not really related to the problem of representing the state of the moving average.
15:45:31 <hsk7> man. i can't believe i'm still at it. i was hoping lyah would be enough to write real programs. i'm not even close...
15:45:43 <hsk7> should i hang in there?
15:45:46 <Welkin> yes
15:45:48 <Welkin> lyah is not enough
15:45:57 <Welkin> you need to actually write an application
15:46:09 <Welkin> the best way is to just get started and learn as you go
15:46:10 <sccrstud92_> "should i hang in there?" I dont think anyone would seriously answer no to that question in this irc
15:46:17 <Welkin> you can get a lot of help in this channel
15:46:21 <quchen> hsk7: If you represent your data as a (Map Time Value) you can remove the maximum in O(log(n)) for example.
15:46:40 <quchen> And then you get other nice properties such as fast lookup.
15:46:46 <quchen> Data.Sequence is another good choice.
15:46:55 <dmj`> hsk7: lyah doesn't cover monad trasformers, which most apps use, I'd check out this paper: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
15:47:21 <quchen> I'm not sure reading papers is good advice for beginners.
15:47:28 <Welkin> haha
15:47:33 <Welkin> the typeclassopedia helps
15:47:34 <maerwald> definitely not
15:47:39 <dmj`> hsk7: how beginner are you?
15:47:43 <bernalex> quchen: depends a lot on their background.
15:47:51 <bernalex> reading papers was great for me when learning haskell
15:47:51 <hsk7> dmj`: i've sort of mastered lyah. took me a year
15:48:09 <bernalex> SPJ's Tackling the Awkward Squad was really important to me.
15:48:56 <dmj`> hsk7: nice
15:49:22 <Welkin> bernalex: but you are a researcher
15:49:28 <Welkin> so your job is reading papers
15:49:29 <dmj`> quchen: I can't think of too many other resources on monad transformers aimed at beginners
15:49:36 <hsk7> Data.Sequence looks really nice, actually. didn't even know about it
15:49:44 <bernalex> Welkin: I was not a researcher when I was learning haskell.
15:49:51 <Welkin> yeah, Sequence is one of my favorite data structures
15:50:04 <bernalex> Welkin: and anyway you are just underlining my point -- it's all about what background they have.
15:50:41 <quchen> djanatyn: RWH has a chapter
15:51:01 <quchen> hsk7: Most undervalued part of containers! :-)
15:51:13 <hsk7> looks more powerful than regular lists...
15:51:20 <quchen> hsk7: The implementation is also quite interesting if that's your cup of tea
15:51:31 <hsk7> it even allows you to get the length of the list in constant time! what a marvelous invention!
15:52:05 <quchen> hsk7: Everything has its price.
15:52:13 <Welkin> finger trees
15:52:28 <quchen> You can't have infinite Seqs, the structure requires more memory, and so on.
15:52:46 <hsk7> ok i see
15:53:26 <Cale> Seq is nice asymptotically, but the constant factors are often worse than you'd like.
15:53:45 <Cale> and yeah, lists are still extremely important because they're effectively loops-as-data
15:54:14 <Cale> If you're not iterating over the elements of your list in order, then it probably shouldn't be a list, but if you are, then lists are ideal.
15:55:02 <quchen> hsk7: In practice, the data structures I use most are List, Map (Key->value store, Set (value store), Vector (like arrays in C++). If you don't know them have a look at those as well.
15:55:45 <hsk7> quchen: you use data.sequence less?
15:56:23 <quchen> Yes, I don't use it very often. I don't have a good reason for it though.
15:56:26 <Welkin> for typical CRUD apps, you only need lists and maps
15:56:31 <Welkin> it depends on what you do
15:57:16 <quchen> I really like Seq, but I don't use it much. Maybe because I'm less aware of it when designing my solutions or something.
15:57:40 <hsk7> hmm Vector seems similar to Sequence
15:57:44 <hsk7> it has some of the same stuff
15:57:51 <Welkin> hsk7: the APIs are similar
15:57:52 <Welkin> yes
15:57:56 <Welkin> that was done on purpose
15:58:08 <Welkin> but they are very different structures
15:58:25 <Welkin> Sequence is a linked structure (a finger tree)
15:58:28 <bernalex> honestly, containers are a nightmare in haskell since we don't have the proper polymorphism for it like idris does.
15:58:30 <Welkin> Vector is an array
15:58:37 <quchen> bernalex: ?
15:58:45 <quchen> I've never had nightmares with containers.
15:58:54 <quchen> I think it's a very good library.
15:59:11 <bernalex> quchen: maybe you value other things than me.
16:00:02 <hsk7> looks good, data.vector vs. data.sequence, https://stackoverflow.com/a/8013848
16:04:41 <eds> I still cant seem to find a solution for this http://lpaste.net/132328. The error is related to MonadRandom.
16:04:44 <eds> bump
16:07:17 <quchen> eds: Your IntExp type does not have a `MonadRandom` instance.
16:07:35 <quchen> Eh wait.
16:07:42 <eds> Yes. And how do I create that instance?
16:07:57 <quchen> "instance MonadRandom IntExp where"
16:08:20 <quchen> Ah wait, you need an Random IntExp instance.
16:08:30 <quchen> so "instance Random IntExp where … 
16:08:52 <quchen> "Could not deduce (Random IntExp)" means that something needs to have an instance, but it hasn't been defined.
16:09:03 <quchen> > "hello" + "world"
16:09:04 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘+’
16:09:04 <lambdabot>      In the expression: "hello" + "world"
16:09:54 <eds> yea system.random. And what do I define in there?
16:10:16 <Welkin> you are using DeriveGeneric
16:10:27 <Welkin> so can't you just use "instance Random IntExp"
16:11:09 <quchen> "Minimal complete definition: randomR and random." -- So you'll have to define a Random instance for your type, and provide definitions for random and randomR in the definition.
16:11:51 <quchen> Your IntExp is just a wrapper around Int, so all you have to do is use the Random instance for Int and wrap the results in your IntExp constructor.
16:12:05 <eds> ahh I see.. got that now
16:12:09 <Welkin> can't Generic do that for you?
16:12:17 <eds> Had to make IntExp an instance of Num too.
16:12:35 <eds> Is there a way that I could make multiple instances of IntExp?
16:12:57 <quchen> Yes, write multiple instances? :-)
16:14:45 <eds> The changes I made. http://lpaste.net/132328
16:14:54 <eds> welkin quchen
16:15:52 <eds> welkin L I used instance Random IntExp and it worked.
16:19:42 <johnw> Cale: "loops as data", I like that
16:24:02 <eds> quchen: I do understand now. Since Random did not know what IntExp meant I had to create an Random instance for IntExp. Just the way '+' did not know what to do with string in your example.
16:28:15 * hackagebot acme-box 0.0.0.0 - A full featured empty project  http://hackage.haskell.org/package/acme-box-0.0.0.0 (twebb)
16:30:55 <kadoban> That sounds far too useful to be acme, heh.
16:34:08 <Welkin> full featured *and* empty?
16:34:10 <Welkin> what a deal
16:34:52 <Cale> Welkin: https://www.youtube.com/watch?v=rkKO4OJxUxM
16:36:28 <Welkin> Cale: wow
16:38:29 <maerwald> does someone know what lead to the current functor instance of tuples? I find it somewhat random
16:39:31 <maerwald> > fmap (+1) (1, 2)
16:39:33 <lambdabot>  (1,3)
16:39:57 <barrucadu> A functor has one free type parameter, and tuples are heterogeneous generally, so all the components but one need to be fixed.
16:40:10 <verement> :t (,)
16:40:12 <lambdabot> a -> b -> (a, b)
16:40:20 <Gurkenglas> "(,) a" has a special standing in the theory, there's something with adjoints and "(->) a"
16:41:14 <Gurkenglas> Besides, what other instance would you propose?
16:41:16 <verement> > fmap (+1) (1, 2, 3)
16:41:18 <lambdabot>      No instance for (Show t0)
16:41:18 <lambdabot>        arising from a use of ‘show_M3810711248986234276466’
16:41:18 <lambdabot>      The type variable ‘t0’ is ambiguous
16:41:48 <maerwald> Gurkenglas: e.g. fmap (+1) (1, 2) == (2, 2)
16:41:58 <kadoban> That's … weird. Why doesn't that one work? ^
16:42:24 <barrucadu> maerwald: Then what about fmap (+1) ("hello", 2) ?
16:42:25 <exio4> maerwald: that doesn't typecheck
16:42:28 <joncol> Question about writing JSON using Aeson: How to flatten nested record types? For instance, suppose I have a Parent type with the two fields "a" and "b". Then I declare a Child record type with both a Parent "p" and a new member "c". How can I output this with Aeson in a flat structure? I.e. I want my final JSON to be: { a: 1, b: 2, c: 3 }. What I have: https://gist.github.com/joncol/797bc8fc53a9d4b8909c
16:42:42 <Gurkenglas> barrucadu, whatever happens with fmap (+1) (2, "hello") currently.
16:42:56 <maerwald> barrucadu: I don't see the problem
16:43:08 <maerwald> exio4: I cannot follow
16:43:13 <exio4> @type fmap 
16:43:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:43:33 <maerwald> yeah, and?
16:43:34 <Welkin> fmap is define on tuples to operate only on the second value
16:43:37 <Gurkenglas> maerwald, practically that's equivalent, and if you are to choose between the two you are choosing between a Functor instance for "Flip (,)" and "(,)", one of which seems more canonical to me.
16:43:37 <barrucadu> maerwald: Well, if you define it to be `fmap f (x, y, z) == (f x, f y, f z)`, then the tuples need to be homogenous
16:43:50 <maerwald> barrucadu: I didn't
16:43:59 <Welkin> > fmap (+1) ("hello", 2)
16:44:00 <lambdabot>  ("hello",3)
16:44:06 <Gurkenglas> Welkin, he's asking why that was done that way.
16:44:07 <exio4> @type fmap :: (a -> b) -> ((,) v) a -> ((,) v) b 
16:44:08 <lambdabot> (a -> b) -> (v, a) -> (v, b)
16:44:10 <Welkin> oh
16:44:23 <exio4> maerwald: you'd need some kind of wrapper for other functor instances, too
16:44:25 <barrucadu> maerwald: So how would `fmap (+1) (1, 2) == (2, 2)` work?
16:44:26 <maerwald> :t (*** id)
16:44:26 <lambdabot> (b -> c) -> (b, c') -> (c, c')
16:44:31 <maerwald> :t (id ***)
16:44:32 <lambdabot> (b' -> c') -> (c, b') -> (c, c')
16:44:35 <maerwald> both work fine
16:44:43 <kristof> What a weird thing to talk about
16:44:43 <maerwald> everything typechecks
16:44:45 <Gurkenglas> exio4, we already have swap as a kind of wrapper for that
16:44:59 <kristof> barrucadu: Use lenses
16:45:10 <maerwald> Gurkenglas: so it is just kind of a random decision to apply it to the second value?
16:45:25 <Cale> maerwald: Not random
16:45:28 <verement> > over _1 (+1) (1, 2)
16:45:30 <lambdabot>  (2,2)
16:45:41 <Welkin> tuples are of limited utility in my opinion
16:45:49 <Welkin> they are only useful as key-value pairs
16:45:59 <Welkin> if you have anything else, make your own custom data type
16:46:05 <Cale> maerwald: fmap :: (a -> b) -> f a -> f b. When f = (,) e, then this becomes (a -> b) -> (,) e a -> (,) e b, which is (a -> b) -> (e,a) -> (e,b)
16:46:09 <kristof> over _1 (+1) $ over _2 (+1) (3,5)
16:46:15 <kristof> > over _1 (+1) $ over _2 (+1) (3,5)
16:46:16 <lambdabot>  (4,6)
16:46:35 <Gurkenglas> Cale, he's asking why the Functor instance was defined for (,), not Flip (,)
16:46:36 <exio4> > over both (+1) (3,5)
16:46:37 <lambdabot>  (4,6)
16:47:01 <Cale> What's Flip? Some newtype?
16:47:10 <Gurkenglas> No, just a word i invented to convey what is meant.
16:47:11 <exio4> if it is a newtype, it's a different type
16:47:12 <kristof> exio4: I was blanking on both :)
16:47:23 <Cale> If you define a Flip newtype, then you have to use it explicitly to get the other instance.
16:47:49 <exio4> if it is a type family, you can't implement a functor instance for it 
16:48:18 <Gurkenglas> (Oh right, I was supposed to say "for (,) a, not Flip (,) a")
16:48:30 <Cale> The only valid instance of Functor which is possible for ordinary pairs is the one which applies to the second part of the pair. If you write other data types, you can get other behaviours though, but whichever type of thing you apply the function to has to be the last type parameter.
16:49:16 <maerwald> so it's a type system limitation basically?
16:49:23 <exio4> if you want a way to traverse a data structure, I'd check at lenses
16:49:35 <kaste>  stupid question, I am reading http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf and I am not so firm with type theory. Does the notation $\oplus \in A \vert B \to B$ imply that $\oplus$ is an infix operator?
16:49:43 <exio4> maerwald: wll, thanks to that `type system limitation`, we _know_ that the instance is unique 
16:50:01 <exio4> well* 
16:53:16 * hackagebot base91 2.1.0 - A Generic Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-2.1.0 (ajg)
16:58:16 * hackagebot hmatrix-gsl-stats 0.4.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1 (VivianMcPhail)
17:30:56 <maerwald> hm, doesn't even work with TupleSections
17:45:38 <jasonkuhrt> Can someone explain why this does not work: (<*>) (Just ('a':)) (Just ["pple"])
17:46:12 <kadoban> jasonkuhrt: Change it to "pple" and it should I believe.
17:46:13 <jasonkuhrt> In a simpler case (functor) we can see that this works: fmap ('a':) ["pple"]
17:46:23 <kadoban> jasonkuhrt: Or alteratively to "a"
17:46:24 <jasonkuhrt> kadoban: Correct, but more deeply, why?
17:46:46 <kadoban> jasonkuhrt: Because the types don't match.    'a' : ["pple"]   <---
17:46:46 <jasonkuhrt> It appears that `fmap` and `<*>` have different semantics
17:47:02 <drdo> jasonkuhrt: It's just that 'a' and "pple" don't have the same type
17:47:04 <kadoban> :t (:)
17:47:05 <lambdabot> a -> [a] -> [a]
17:47:15 <jasonkuhrt> ok let me look a little more at this
17:47:21 <kadoban> :t 'a'
17:47:22 <lambdabot> Char
17:47:23 <kadoban> :t "pple"
17:47:24 <lambdabot> [Char]
17:47:32 <jasonkuhrt> kadoban: Let me rephrase my question
17:47:54 <kadoban> One is a character, one is a String. So you have a /list/ of Strings and you're trying to put a Char in that list (of Strings)
17:48:06 <maerwald> > (<*>) (Just ('a':)) (Just "pple")
17:48:06 <jasonkuhrt> in fmap we see that the given function is executed once for every item in the functor
17:48:07 <lambdabot>  Just "apple"
17:48:45 <marchelzo_> > fmap concat $ (<*>) (Just ("a":)) (Just ["p", "p", "l", "e"])
17:48:46 <lambdabot>  Just "apple"
17:49:37 <kadoban> jasonkuhrt: When they contradict, English explanations of what's happening/supposed-to-happen/not-happening should be left behind and you should look at the actual types involved. The types are /far/ less ambiguous than English.
17:49:39 <jasonkuhrt> maerwald but then the corrolarry in fmap does not work:  fmap ('a':) (Just "pple")
17:50:30 <jasonkuhrt> kadoban: Yeah. I am going to review the types more closely but I basically am surprised that applictaive functors are used by <*> differently than functions are used by fmap
17:50:33 <kadoban> > fmap ('a':) (Just "pple") -- jasonkuhrt   Sure it does
17:50:35 <lambdabot>  Just "apple"
17:50:44 <maerwald> yeah, I don't see the problem
17:51:04 <kadoban> jasonkuhrt: Well, <*> and <$>/fmap have different types of course (and different meaning)
17:51:15 <jasonkuhrt> Oh hold on, I may have realized what was confusing me sorry, sec
17:52:08 <jasonkuhrt> uggggh
17:52:21 <jasonkuhrt> I was doing this
17:52:23 <jasonkuhrt> `fmap ('a':) ["pple"]`
17:52:31 <jasonkuhrt> I confused myself with the syntax
17:52:44 <jasonkuhrt> lists are functors and in haskell "" is just syntax sugar for a list
17:52:50 <kadoban> Ahh, yeah that works in bash, not so much in haskell unfortunately :)
17:52:58 <jasonkuhrt> Oooook sanity restored 
17:53:00 <jasonkuhrt> thanks everyone
17:53:23 <jasonkuhrt> I had a moment of braindead
17:53:35 <kadoban> It happens :) Glad you figured it out.
17:53:46 <jasonkuhrt> : )
17:54:43 <magneticduck> I'm writing a data type that represents a small language that makes terminating programs of type [Int] -> [Int]
17:54:53 <magneticduck> I'm trying to find some good ways to do this
17:54:55 <magneticduck> any ideas?
17:56:17 <marchelzo_> magneticduck: What in particular are you not sure about?
17:56:58 <kadoban> magneticduck: Coq or Agda? IIUC haskell's type system isn't powerful enough to encode that, except maybe extensions.
17:57:23 <magneticduck> need to do it in Haskell
17:57:25 <magneticduck> :<
17:57:30 <magneticduck> marchelzo_: just how to go about it
17:58:43 <edwardk> maerwald: you can write whatever "functor" you want for tuples in scala. the consequence is that you can assume nothing about which instance is intended. you get no inference, and functions like 'map' do one of 20 things that depend entirely on what you call it on with no real way to work over them abstractly. sign me up.
17:59:02 <edwardk> maerwald: Having used both extensively, I prefer Haskell's solution.
18:00:02 <edwardk> ... and not just by a little bit
18:00:34 <maerwald> edwardk: interesting, do we have some crazy ghc extension that lets me do this?
18:00:42 <shachaf> If you want to be explicit, you can always give it a name instead of using type classes.
18:00:45 <shachaf> (Which is what lens does.)
18:00:53 <marchelzo_> magneticduck: And this data type needs to be able to represent every possible terminating program from [Int] to [Int]?
18:01:07 <maerwald> shachaf: well as I said, I use (*** id)
18:01:15 <magneticduck> yes
18:01:17 <maerwald> I was just messing with the type system for fun
18:02:04 <marchelzo_> magneticduck: But it has to be impossible to represent non-terminating programs with this type?
18:02:08 <jasonkuhrt> Does anyone here pay attention to GHCJS?
18:02:12 <magneticduck> yes
18:02:15 <magneticduck> marchelzo_: that's impossible, right?
18:02:23 <magneticduck> so at least give me "most of the interesting terminating programs"
18:02:24 <marchelzo_> I think so
18:03:00 <jasonkuhrt> Alternatively does anyone here follow a Haskell bridge to a client-side platform of any kind?
18:04:23 <kadoban> jasonkuhrt: What a Haskell bridge to a client-side platform might look like: http://norse-mythology.org/cosmology/bifrost/
18:04:45 <marchelzo_> magneticduck: I don't even know if that is possible
18:05:22 <magneticduck> well, first let's see if we can prove to ourselves that representing exactly the set of terminating programs is impossible
18:05:51 <hiptobecubic> maerwald, no. You have newtypes. The just redefining functor would break *everything* because the types of everyone's functions would no longer be appropriate.
18:05:54 <jasonkuhrt> kadoban: Ha
18:06:28 <maerwald> hiptobecubic: the point is not about redefining it, just imagine the type: newtype T a b = T (a, b) instead
18:06:40 <kadoban> jasonkuhrt: But seriously I'm not completely sure what you're looking for specifically, except ghcjs looks really neat and I hope to play with it soon.
18:07:10 <hiptobecubic> maerwald, you can make that if you want, but you can't define a Functor instance that alters 'a' because it's not the last type parameter.
18:07:19 <maerwald> hiptobecubic: exactly
18:07:24 <hiptobecubic> maerwald, you coul ddo newtype T b a = T (a, b) and then define one if you like
18:07:38 <maerwald> hiptobecubic: well I know, but I was hoping to break the typechecker :)
18:07:46 <marchelzo_> magneticduck: if it returns an infinite list, is that terminating or non-terminating?
18:08:00 <maerwald> already got a crapload of ghc extensions activated :D
18:08:00 <magneticduck> non-terminating
18:08:30 <exio4> about the `terminating-functions`, pretty sure you can define a small dependently-language + a typechecker for it, does that count? :p
18:08:34 <magneticduck> all parts of the language are strict
18:08:46 <kadoban> magneticduck: Is it supposed to be able to receive an infinite list, or is that just an artifact of not knowing other syntax to use to describe what you're trying to do?
18:08:51 <exio4> anyway, generating primitive recursive functions should be 'easy', shouldn't it?
18:09:25 <magneticduck> hmmm
18:09:32 <magneticduck> yeah, this question of laziness in the lists is interesting
18:09:35 <OutlawStar> anyone familiar with the Chart package?
18:09:43 <exio4> also, map f , filter p , take n , drop n , takeWhile p, dropWhile p
18:09:44 <jasonkuhrt> kadoban: I'm interested in doing graphical work with Haskell, something visual
18:09:56 <jasonkuhrt> Apps or otherwise
18:10:09 <jasonkuhrt> touch-interfaces
18:10:09 <magneticduck> kadoban: let's just assume everything's strict until it becomes apparent that we need laziness to make things elegant
18:11:42 <magneticduck> hm, maybe I should use something more abstract and elegant that finite lists of numbers
18:12:07 <magneticduck> but this whole question of a SKI-combinator-like terminating language is still a haze to me
18:13:03 <edwardk> maerwald: no. there is no ghc extension for it. it fundamentally means giving up what Haskell calls "type classes"
18:13:58 <magneticduck> it would be a "language retraction"
18:14:01 <edwardk> maerwald: given three different "functors" that want to map over tuples either on the first arg, the second, or both, what one do you get when you just go to call fmap? the inference for that is gone
18:16:24 <edwardk> maerwald: scala is paralyzed by these same non-concerns. Oh no, maybe someone wants flatMap/join/(>>=) to work over the left hand side of the Either! better prevent the standard sum type from being used as a monad then. http://www.scala-lang.org/api/2.9.3/scala/Either.html
18:21:31 <Epichero> whoever told me stackage would somehow make yesod install was off the mark
18:21:57 <Epichero> er stack
18:22:50 <bernalex> well I did try to warn you...
18:24:35 * bernalex >>= sleep
18:26:05 <bergmark> Epichero: i just tried it, it worked
18:28:15 <sm> Epichero: what's your platform, install command, and error ?
18:35:46 <epta> Assume there is `[(a, [b])]', all `b' values are unique and it need to be indexed by them like `Map b a'. So, it can be done via `fromList . concatMap (\(a,bs) -> map (\b -> (b,a)) bs)'. Is there any data structure for stuff like that better than a HashMap? In other words, data structure of a set of a sets with indexes with defined operation 'return index for a given element'?
18:36:49 <maerwald> edwardk: well, one could do something like http://lpaste.net/136368 which is the closest thing I get
18:36:57 <maerwald> wonder if there already is such a class somewhere
18:37:48 * maerwald wonders if the answer will be "lens"
18:38:57 <Cale> maerwald: http://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html
18:39:34 <maerwald> seems like it
18:40:15 <maerwald> oh, and he wrote it ;)
18:40:28 <maerwald> no surprise there
18:43:36 <maerwald> well yeah, so now we have more classes, but our "maps" are still predictable. Guess that is a reasonable trade-off
18:43:56 <Cale> I love the Clown and Joker pun
18:44:27 <Cale> Obviously Conor McBride's doing :D
18:51:22 <bitemyapp> Cale: I like that song
18:51:34 <maerwald> @let joker = runJoker (Joker 5)
18:51:35 <lambdabot>  .L.hs:145:9: Not in scope: ‘runJoker’
18:51:35 <lambdabot>  
18:51:35 <lambdabot>  .L.hs:145:19:
18:51:56 <maerwald> that's some interesting result type
18:52:11 <maerwald> joker :: Num (g b) => g b
18:54:41 <meretrix> When I want my application to use multiple cores, I only need to put "-threaded" in the executable's cabal file, not necessarily every library on which it depends, correct?
18:56:11 <bitemyapp> meretrix: that should be sufficient
18:56:29 <meretrix> Thanks
19:00:19 <epta> Was my question above too vague?
19:02:40 <gcganley> is chrisdone in this channel that much anymore? I havent seen him the last few times I've tried to send him a message
19:03:01 <Welkin> gcganley: you can email him
19:03:07 <Welkin> or leave a message on lambdabot 
19:06:04 <marchelzo_> epta: I think what you've done is acceptable
19:06:55 <marchelzo_> epta: It could do without the lambdas, but the idea seems reasonable if you want perform lookups with the bs as the key.
19:07:07 <gcganley> Welkin: what is his email?
19:07:44 <marchelzo_> gcganley: chrisdone@gmail.com according to his website
19:11:35 <epta> marchelzo_: it doesn't look quite efficient because of a lot of duplicate values for a different keys
19:12:17 <marchelzo_> It's not space efficient, but I think it's the most time efficient way of performing lookups.
19:23:26 <epta> marchelzo_: on the other hand, I'm not sure that there will be duplicates of same value in memory
19:23:30 <epta> > concatMap (uncurry (map . flip (,))) $ [("vowels", ["a", "b", "c"])]
19:23:32 <lambdabot>  [("a","vowels"),("b","vowels"),("c","vowels")]
19:23:54 <hatds> if I have an object and a traversal for it (in the sense of Control.Lens), how should I get the left-to-right list of the targets?
19:24:05 <epta> So "vowels" is predented in the memory only in one instance, right?
19:24:38 <epta> presented*
19:27:00 <marchelzo_> I don't know. I suppose GHC could choose to have only one instance of "vowels" in memory, but I don't know if it actually does.
19:27:39 <lyxx> Hey guys, Is it possible to do something to the effect of instance Num b => PythonAdd Variable b where so that I can safely assume that b is a Num type so i can use show on it safely?
19:28:01 <lyxx> I don't want to write one to catch int and double and flaot
19:28:12 <lyxx> So I'm trying to abstract it to the Num level.
19:28:29 <mzero> "vowels"?
19:29:11 <marchelzo_> mzero: That was in response to epta
19:29:18 <mzero> why not (Show b, Num b) => ...
19:29:23 <mzero> ah
19:29:24 <mzero> k
19:30:09 <lyxx> mzero I get an error thrown at me
19:30:38 <mzero> lyxx - you'll need to pastebin the code & error for us to know more
19:30:48 <lyxx> give me one second
19:31:24 <lyxx> http://pastebin.com/MJ9GNN4Q
19:31:49 <geekosaur> Num doesn't imply Show (any more)
19:32:22 <lyxx> geekosaur didn't know that. I'm really new to haskell.
19:32:29 <lyxx> So thanks for the heads up =)
19:32:58 <mzero> lyxx - you need FlexibleInstances added
19:33:05 <mzero> to the LANGUAGE pragma
19:33:35 <lyxx> Sick thank you so much mzero!!!
19:33:46 <lyxx> I've head so many great things about #haskell and it really is true =)
19:33:49 <marchelzo_> It compiles now?
19:34:23 <lyxx> Yup =) 
19:34:29 <marchelzo_> I am confused
19:34:44 <lyxx> With the pramga you metnioned
19:34:48 <lyxx> I added it and it compiled.
19:35:58 <marchelzo_> Why does "varName val2" type-check if varName :: Variable -> String and val2 :: (Show b, Num b) => b
19:37:16 <pavonia> marchelzo_: It does only if Variable is an instance of Show and Num
19:38:34 <marchelzo_> varName is not polymorphic
19:38:46 <lyxx> That was something I changed when I got the compile errror
19:38:53 <mzero> I suspect that wasn't the code that compiles
19:39:03 <lyxx> It didnt' compile until I changed it my bad.  I didn't realize that I had that mistake in the pastebin
19:39:11 <marchelzo_> How can it work on an arbitrary type just because it has Show and Num?
19:39:28 <marchelzo_> Oh sorry
19:39:29 <mzero> it doesn't - that bit of code in the pastebin is still wrong
19:39:42 <marchelzo_> Alright, phew. Just checking that I'm still sane.
19:39:48 <mzero> cool
19:40:08 <lyxx> yeah you're fine.  I made a mistake 
19:41:04 <pavonia> > (succ :: Int -> Int) (1 :: Num b => b)
19:41:06 <lambdabot>  2
19:42:34 <mzero> looks legit!
19:52:41 <lyxx> I was getting this error http://pastebin.com/4x07DJU8 with the new code and I want to understand why using IncoherentInstances makes it compile and work
19:56:01 <Hafydd> There must be a wild party going on in another channel.
20:00:59 <pavonia> lyxx: If Variable is an instance of Show and Num, there are two different instances for the same type. I think IncoherentInstances chooses the more specifiy one
20:03:30 <mzero> however, I always avoid IncoherentInstances
20:03:37 <mzero> that way lies maddness....
20:06:01 <lyxx> mzero how would I go about fixing it then?
20:06:07 <lyxx> pavonia thanks for the heads up!
20:06:34 <mzero> write the explicit instances for Int and Double!
20:07:04 <lyxx> mzero for sure. I'm being lazy and a newb
20:07:12 <mzero> you can write something like:    pAddVarNum :: (Show b, Num b) => Variable -> b -> String
20:07:25 <mzero> and then use that function once in simple instances   
20:07:35 <mzero> instance PythonAdd Variable Int where pAdd = pAddVarNum
20:07:43 <geekosaur> lyxx, you may be assuming that contexts control instance selection
20:07:58 <geekosaur> instance Foo a => Bar a -- makes *all* types instances of Bar
20:08:11 <geekosaur> the check for Foo comes later
20:08:16 <geekosaur> yes, this is intentional
20:08:30 <mzero> You look like you are trying to use instances with increasingly more general contexts as a substitute for how you'd build a class heirarchy in an OO langauge
20:09:18 <lyxx> yeah It's not working out.
20:09:27 <mzero> In an OO langauge this work because the resolution of which implementation is done at run time
20:09:33 <geekosaur> it won't. typeclasses are not OOP
20:09:43 <mzero> but in a statically type functional language, this resolution is done at compile time
20:09:48 <lyxx> I'm getting things wrapped in quotes that shouldn't be wrapped in quotes so Imgoing to have to take a step back and restructure my approach
20:10:27 <mzero> are you tryping to generate python, or interpret it?
20:10:33 <lyxx> Generate it.
20:10:52 <lyxx> Just for fun.  It's the main langauge I use so I figured it woud be fun to write Haskell to generate Python.
20:11:10 <chrisdotcode> is there a function that is equal to: `f x = [x]`. basically, making x a singleton list.
20:11:25 * mzero works in python for his day job
20:11:26 <chrisdotcode> and not pure, because I don't want to cludge things with applicative contexts when I dont need them.
20:11:33 <verement> :t (: [])
20:11:34 <lambdabot> a -> [a]
20:11:35 <geekosaur> :t []
20:11:36 <lambdabot> [t]
20:11:49 <chrisdotcode> geekosaur: yeah, but you can't apply `[]` pointsfree :)
20:11:54 <chrisdotcode> oh, wait
20:11:57 <Zekka> chrisdotcode: [] isn't a function
20:11:57 <mzero> you might want to consider that the "embedded language" you are writing (pAdd, pSub, etc...)
20:12:00 <chrisdotcode> you said (: [])
20:12:02 <chrisdotcode> missed that
20:12:03 <Zekka> (:[]) is.
20:12:05 <geekosaur> no, I wrote that wrong
20:12:14 <geekosaur> verement dod the rigjt one
20:12:14 <mzero> should resemble Haskell more than Python, and let it generate python as an implementation
20:12:19 * geekosaur kant tipe...
20:12:23 <chrisdotcode> thanks guys :)
20:12:37 <lyxx> I see.
20:12:40 <mzero> in that case, you would have quite the run-time polymorphism that you're trying to replicate with things like PythonAdd
20:12:54 <mzero> since, after all, it takes a fair bit of machinery in Python to do that 
20:13:11 <mzero> though you could get there by
20:13:16 <mzero> something like
20:13:42 <jle`> we call (:[]) the robot monkey operator
20:13:51 <mzero> class PythonValue a where ....   pAdd :: a -> Expr -> Expr
20:14:15 <mzero> then    instance PythonValue Int where ...
20:14:43 <mzero> in this way instances of PythonValue are more like the dicts that python has, with __add__, __eq__, etc...
20:14:46 <lyxx> I'm not sure I entirely understand that.
20:15:10 <mzero> well, consider having values that build up expressions - that you later flatten to code
20:15:22 <mzero> so you're building a parse tree, inessence
20:15:24 <lyxx> Oh okay so don't generate the expression immediately.
20:15:42 <mzero> and have the type of the first argument control how the tree is built
20:15:56 <marchelzo_> Python has RTTI, so you'd be better off doing something like `data PythonValue = PythonInt Int | PythonString String | ... ` I think
20:16:10 <lyxx> What is RTTI?
20:16:13 <mzero> another option
20:16:18 <marchelzo_> runtime type information
20:16:22 <lyxx> Oh okay.
20:16:27 <mzero> then you dispense with type classes altogther
20:16:43 <mzero> pAdd :: PythonValue -> PythonValue -> PythonValue
20:16:46 <lyxx> That's a cool idea.
20:17:00 <lyxx> This is my first attempt at both Haskell and Code Generation
20:17:12 <lyxx> So I'm shooting into the dark and seeing what comes up =P
20:17:26 <mzero> pAdd a b = PythonCall (PythonAttrLookup a "__add__") [b]
20:17:27 <marchelzo_> I don't know Haskell that well, but I think you could use GADTs to get a safer type than PythonValue -> PythonValue -> PythonValue for pAdd.
20:17:41 <mzero> or perhpas    pAdd a b = PythonOperator "+" a b
20:17:51 <mzero> depending on what level of Python you are trying to generate
20:18:05 <lyxx> Right now I'm going for super basic
20:18:10 <lyxx> I build a  simple class generator
20:18:13 <mzero> in that case
20:18:21 <mzero> just build up an expression tree and then pretty print it
20:18:29 <lyxx> https://github.com/rnikoopour/Python-Class-Creator
20:18:37 <mzero> and use a simple ADT  like marchelzo_  suggested
20:18:40 <lyxx> But I took the approach that wasn't the best in that one too
20:19:13 <lyxx> So I'll need a tree type and then that cool PythonValue data type
20:20:10 <felixn> lyxx: once you figured out doing a small subset of python code gen from scratch, you could move to this more complete implementation  https://hackage.haskell.org/package/language-python
20:20:36 <mzero> data PyExpr = PEValue | PEBinOp String PyExpr PyExpr |  ....
20:20:58 <mzero> you can actually just read off the python language definition from the python docs and sort of write as much of this as you need
20:21:10 <lyxx> felixn one of my buddies showed me that the other day
20:21:45 <mzero> lyxx - but I'd start small if this is your first Haskell project - 
20:21:57 <mzero> try just arithmetic operators, numbers and variables
20:22:02 <mzero> for a start
20:22:08 <lyxx> That's what I'm going for.
20:22:15 <mzero> good
20:22:32 <lyxx> But I'm struggling  so it feels good
20:23:55 <lyxx> data PyExpr = PEValue | PEBinOp String PyExpr PyExpr  .... I'm not sure I understand this one.
20:24:27 <lyxx> I was thinking to store the expression as a tree where its value is the operator and then the left value is the left hand side and the right value is the right hand side
20:24:32 <lyxx> Or is that not what you were suggesting.
20:25:39 <mzero> That is exactly what I wrote!
20:25:57 <mzero> perhaps if it were written like this:
20:26:30 <mzero> data PyTree = PyLeaf PyValue | PyNode PyTree String PyString
20:26:34 <mzero> that *is* a tree
20:26:39 <mzero> where 
20:26:56 <mzero> data PyValue = PyInt Int | PyString String | PyVar String
20:27:08 <lyxx> Oh okay I see it in yours a bit more now
20:27:37 <adarqui> i'm noobing it up. in the 'nats' package (https://github.com/ekmett/nats/blob/master/src/Numeric/Natural.hs), why is there no "zero" function exported? I mean all that's exports is 'Natural' and nothing else.. ie, there's no minBound, zero, empty, etc.. i mean I could fromIntegral 0 :: Natural etc but i dno i just feel like i'm missing something.
20:27:39 <mzero> but data types can have many alternatives, so your "tree" can have different kinds of nodes
20:28:31 <mzero> data PyExpr = PyLeaf PyValue | PyBinOp PyExpr String PyExpr | PyPrefixOp String PyExpr | PyListComprhension .....
20:29:34 <mzero> adarqui: 
20:29:37 <mzero> it is a Num instance
20:29:41 <mzero> so you just use... 0!
20:30:00 <lyxx> Okay I kinda get how to handle this PyExpr tree now
20:30:11 <lyxx> Dude seriously you've been really helpful and I appreciate it very much =)
20:30:24 <mzero> adarqui: and there is no minBound because it isn't Bounded
20:30:25 <lyxx> Everyone who has pitched into the topic has been helpful.  Thank you all.
20:30:33 <mzero> lyxx: happy to help
20:31:19 <mzero> adarqui: you don't need fromIntegral... 
20:31:20 <mzero> :t 0
20:31:21 <lambdabot> Num a => a
20:31:56 <adarqui> ya i think my brain is haywire right now, i'm thinking about this somewhat like church numerals
20:31:58 <mzero> in fact you can write any integer constant value for a Natural
20:31:59 <adarqui> heh
20:32:12 <adarqui> ya
20:32:16 <jle`> adarqui: btw, this is the same case for the Int type too...it doesn't really export anything except for its typeclass instances unless you dig really deep
20:32:29 <jle`> the only real way to work with Int is to use its typeclass instances
20:32:36 <jle`> unless you dig into internal stuff
20:33:18 <jle`> so this would be like asking if Data.Int exported a `zero :: Int` :)
20:38:23 <catsup> <quanticle> That should be Haskell's tagline. "Haskell: Bringing category theory to the masses!"
20:39:37 <adarqui> cool thanks jle`, mzero
20:48:28 <jle`> sometimes it would be nice to be able to write an Applicative instance in terms of liftA2 instead of (<*>)
20:48:37 <jle`> it feels more natural to me
20:57:37 <mniip> so, uh, obviously there must be a paper that explains that a Functor instance can only exist when all appearances of the type parameter are covariant
20:57:42 <mniip> does anyone know the title?
21:04:29 <lyxx> Man I never realized how spoiled I was in Python being able to ask shit what its type is during runtime and acting upon that.
21:07:42 <dmj`> :t typeOf
21:07:43 <lambdabot> Typeable a => a -> TypeRep
21:08:41 <mniip> having to do that seems like poor architectural design
21:09:09 <sccrstud92_> i used to do that before I learned how to use sum types
21:10:35 <hiptobecubic> Are the default definitions of Alternative supposed to be such that you only have to define one of `many` or `some` ?
21:12:26 <dmj`> hiptobecubic: minimal complete defintion is only empty and (<|>)
21:12:41 <hiptobecubic> hm
21:13:02 <hiptobecubic> I get <<loop>> :(
21:14:04 <lewis1711> Can a typeclass instance be part of an algebraic data type?
21:15:13 <Big_G> Why would something of type ActionM Int work when applied to elem [1, 2, 3] ?
21:15:58 <Hijiri> hiptobecubic: a lot of Alternative instances have nonterminating many and some
21:17:41 <dmj`> lewis1711: not an instance, but you can constrain variables in an ADT using a class. data Foo = Show a => Foo { bar :: a }
21:17:49 <dmj`> lewis1711: enable ExistentialQuantification
21:20:47 <hiptobecubic> (but you usually don't want to do that)
21:36:07 <lyxx> marchelzo_ http://pastebin.com/YJr2sK7m much better don't you think? 
21:36:24 <Gal3rielol> what is the relation between Text.Parsec and Text.ParserCombinators.Parsec?
21:39:20 <marchelzo_> lyxx: Looks good
21:40:46 <lyxx> =)
21:41:25 <Cale> Gal3rielol: Text.ParserCombinators.Parsec is the deprecated module name for the same thing.
21:41:45 <Cale> Gal3rielol: It's just there for compatibility with old code
21:41:55 <Gal3rielol> I see, thx
21:48:20 <adarqui> this is really cool, https://github.com/GaloisInc/e2eviv/tree/master/src
21:56:10 <lethjakman> adarqui: that is really cool
21:58:02 <adarqui> ya, galois is involved in sick projects
22:01:45 <breadmonster> Is there a package for natural transformations in Haskell?
22:04:03 <pacak> :t listToMaybe
22:04:04 <lambdabot> [a] -> Maybe a
22:04:25 <pacak> breadmonster: There are some in base.
22:05:05 <mniip> :t maybeToList
22:05:06 <lambdabot> Maybe a -> [a]
22:07:20 <breadmonster> pacak: I don't seem to get the definition from Awodey, so I guess I'll try looking at the source.
22:07:41 <breadmonster> > listToMaybe [1,2]
22:07:43 <lambdabot>  Just 1
22:08:38 <pacak> You want something with type (Functor f, Functor g) => forall a. f a -> g a
22:09:19 <pacak> So you change from functor f to functor g without touching a
22:09:31 <pacak> In case of listToMaybe that's [] -> Maybe
22:13:30 * hackagebot arx 0.2.1 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.2.1 (JasonDusek)
22:22:29 <gfixler> is there any notion of <*> distributing functorialness over application?
22:23:02 <Gal3rielol> how can I parse epsilon in Parsec. say I have a grammar like this B := "abstract" | epsilon, S = B Identifier
22:24:51 <Gal3rielol> my AST is like data B = BAbstract | BNonAbstract, data S = S B String
22:25:17 <breadmonster> Gal3rielol: What is epsilon?
22:25:19 <mauke> look for option or optional
22:25:31 <Gal3rielol> empty string
22:25:43 <breadmonster> :t optional
22:25:44 <lambdabot> Alternative f => f a -> f (Maybe a)
22:25:49 <breadmonster> Gal3rielol: ^
22:26:10 <Denommus`> hi
22:26:17 <Denommus`> is hspec as good as it seems?
22:27:40 <mauke> (BAbstract <$ word "abstract") <|> pure BNonAbstract
22:28:08 <mauke> S <$> ((BAbstract <$ word "abstract") <|> pure BNonAbstract) <*> identifier
22:28:31 * hackagebot gtk3 0.13.9 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.9 (HamishMackenzie)
22:28:33 * hackagebot gtk 0.13.9 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.9 (HamishMackenzie)
22:28:36 <Gal3rielol> thx so much
22:29:41 <breadmonster> :t (<$)
22:29:42 <lambdabot> Functor f => a -> f b -> f a
22:30:10 <Gal3rielol> :t (<$)
22:30:11 <lambdabot> Functor f => a -> f b -> f a
22:30:24 <Gal3rielol> wow, there is a bot
22:30:34 <mauke> :t fmap . const
22:30:36 <lambdabot> Functor f => b -> f a -> f b
22:31:19 <breadmonster> Oh that's how it's defined.
22:31:20 <breadmonster> Thanks!
22:32:21 <mauke> @unpl fmap . const
22:32:21 <lambdabot> (\ d -> fmap (\ _ -> d))
22:34:02 <gfixler> this is what I'm thinking about: http://lpaste.net/136379
22:34:16 <gfixler> <$>, <*>, >>= all seem like fancy forms of $
22:34:31 <gfixler> function application in various ways and contexts
22:35:52 <gfixler> and <*> felt like distributing functorialness over (a -> b)
22:43:32 * hackagebot hakyll 4.7.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.7.2.0 (JasperVanDerJeugt)
23:03:33 * hackagebot operational-class 0.1.0.0 - MonadProgram typeclass for the operational package  http://hackage.haskell.org/package/operational-class-0.1.0.0 (srijs)
23:18:41 <dmj`> When would it not make sense to use the church encoded version of a free monad (F) over (Free) the non-encoded version
23:23:34 * hackagebot StrappedTemplates 0.2.0.1 - General purpose templates in haskell  http://hackage.haskell.org/package/StrappedTemplates-0.2.0.1 (hansonkd)
23:23:36 * hackagebot operational-class 0.2.0.0 - MonadProgram typeclass for the operational package  http://hackage.haskell.org/package/operational-class-0.2.0.0 (srijs)
23:44:03 <xpilot> hello
23:44:09 <breadmonster> Hello.
23:44:15 <xpilot> does anyone here have experience with accelerate?
23:44:50 <xpilot> I've so far been unsuccessful to get any reasonable performance from it
23:46:30 <xpilot> to the point that I'm considering giving up and just using hmatrix
23:46:48 <xpilot> which seems to do matrix-vector multiplication 10x faster
