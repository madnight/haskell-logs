00:15:10 <Pamelloes> Is there a way to make the type signature (MonadLogger t m, MonadIO m) => ... -> t m a -> m a work?
00:16:21 <Cale> MonadLogger (t m) ?
00:16:34 <alexa_> Hey guys, how do I get cabal to look recursively within my src/ folders? it can't find my module right now because I have it under src/homework_1 instead of directly under src/
00:16:37 <Cale> What are the kinds of the type parameters to MonadLogger?
00:17:01 <Pamelloes> Monad m => MonadLogger m
00:17:11 <Cale> okay, then yeah, you need those parens
00:18:57 <Pamelloes> Yep, that worked. I didn't know you could put parens in a constraint like that :)
00:23:27 <Pamelloes> I have no idea how I could write a bunch of my programs without RankNTypes, but my god can nested foralls get ugly :/
00:23:32 <alexa_> Does cabal require the .cabal file to be named new-template.cabal? I tried renaming it to something else and changing all the references to new-template accordingly, but it's still yelling about a missing file. I can't find any reference in the project directory to new-template.cabal either
00:23:42 * hackagebot aivika 4.2 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.2 (DavidSorokin)
00:23:59 <Pamelloes> alexa_: Nope, it can be named anything .cabal
00:24:09 <alexa_> then I wonder why cabal hates me so -_-
00:24:15 <alexa_> cabal: ./new-template.cabal: does not exist
00:24:28 <alexa_> Where does it go to look for the required name?
00:24:32 <Pamelloes> What's teh commadn you are executing?
00:25:04 <alexa_> cabal build
00:25:16 <alexa_> in project root
00:25:34 <Pamelloes> Try cabal clean and then run it again.
00:25:47 <alexa_> thanks :D
00:25:55 <alexa_> I assume it caches info in the dist directory or something then?
00:25:58 <alexa_> like a sly devil?
00:26:10 <Pamelloes> Maybe, I'm not exactly sure
00:26:18 <alexa_> now I just need to figure out how to make it recursively include everything in src/(
00:26:27 <Pamelloes> On an aside, I found this library for running a Haskell function as a daemon: https://hackage.haskell.org/package/daemons-0.2.1
00:26:40 <Pamelloes> It can do everything I was talking about yesterday, which is pretty awesome :)
00:27:18 <Pamelloes> "On an aside"? I need to go to sleep before my grammar completely deteriorates :P
00:27:34 <Pamelloes> alexa_: did it work?
00:27:54 <alexa_> the issue with the cabal file is resolved, yep
00:28:07 <Pamelloes> Awesome, glad I could help :D
00:28:13 <alexa_> now I need to learn a few more things about module imports and including src directories
00:28:19 <alexa_> before this thing will actually, you know, build
00:28:42 * hackagebot aivika-experiment-chart 4.2 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-4.2 (DavidSorokin)
00:29:27 <Pamelloes> alexa_: Here's the reference for making a cabal package, incase you haven't found it already: https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/authors.html
00:30:05 <Pamelloes> Wait, wrong link
00:30:51 <Pamelloes> Wait, I'm an idiot, that was the right link
00:30:57 <Pamelloes> Gah, I'm going to get some sleep
00:31:01 <Pamelloes> Good luck with cabal! :)
00:38:45 <haskell250> http://lpaste.net/4930218569968386048
00:39:04 <haskell250> can somebody tell me if this is the correct way to calculate the result using call by value?
00:39:36 <haskell250> haskell says it's 36 too, but haskell is not call-by-value...
00:41:03 <haskell250> is anyone even here?
00:50:19 <quicksilver> well call-by-value and call-by-name won't change the result
00:50:45 <quicksilver> they just change how much work is done - whether you duplicate computations or whether you manage to avoid computing things which you don't need.
00:53:30 <jle`> haskell250: haskell's evaluation is more like substitution
00:53:34 <jle`> substitute expressions for equivalent expressions
00:53:39 <jle`> substitute expressions for their definitions
00:54:22 <jle`> that's the semantics; the actual operational picture (*how* you evaluate it) is up to your compiler, or your evaluator (in this case, you)
00:54:25 <haskell250> I made a newer (better?) application now
00:54:26 <haskell250> http://lpaste.net/4333826381977747456
00:55:00 <jle`> for example, there's more than one way to evaluate x^3 + 2 x^2 + 3 x - 1 when x = 2
00:55:11 <jle`> computers do it one way...a human might do it another way
00:55:20 <haskell250> ok
00:55:21 <jle`> you might do multiplication by hand or you might look it up on a table
00:55:35 <jle`> the operational aspects are up to the evaluator
00:55:36 <haskell250> but call by value in my example is done the right way is it?
00:55:40 <jle`> but theat doesn't change the semantics
00:55:59 <jle`> your evaluations are *a* right way
00:56:04 <jle`> but not the only right way
00:56:11 <jle`> just like there's more than one way to calculate 354 + 843
00:56:14 <haskell250> yes I know there are different ways to do it
00:56:36 <haskell250> I just wanted to know if it is the correct way for call by value
00:56:54 <jle`> hm, i don't really think that you can really describe these as function calls
00:56:57 <jle`> they're more like graph reductions
00:57:14 <jle`> so call-by-value and call-by-name etc. don't really have too much exact meaning here
00:57:27 <haskell250> alright thank you!
00:57:32 <jle`> i don't think the meaning is exact enough to give a definitive yes or no answer
00:58:05 <frerich> haskell250: I think if you consider 'call-by-value' to be equivalent to strict evaluation, then what you showed is plausible - arguments are evaluated before they a function is applied to them.
00:59:14 <jle`> they left ;_;
01:00:22 <frerich> That's what I get for being hesitant to step into this tar pit of nomenclature - by the time I make a decision, the discussion is over!
01:03:38 <alexa_> I smell something deeply wrong with what I've done here.. : main = putStrLn ( show ( toDigits 123412312 ) )
01:06:33 <frerich> alexa_: Whether it's wrong depends on what you intended the program to do. :-) (you could use 'print' instead of 'putStrLn + show' though)
01:07:36 <alexa_> the nesting brackets in order to enforce the desired precedence is what has my suspicious
01:07:49 <alexa_> thanks for that also
01:09:07 <pavonia> Note that f (g ( h x) ) = f $ g $ h x = f . g . h $ x
01:09:50 <alexa_> what is this dollar sign business?
01:10:26 <liste> Haskellers love the $$$
01:10:41 <liste> that's why it's so popular in the financial field
01:10:46 <pavonia> alexa_: It's just function application but with very low precedence
01:11:13 <liste> @src ($)
01:11:13 <lambdabot> f $ x = f x
01:11:18 <alexa_> so f apply g apply h x?
01:11:23 <alexa_> is how it reads?
01:11:29 <Hi-Angel> It is also possible to write ´ let (Ä) = ($) ª
01:11:36 <Hi-Angel> To use Ä instead
01:11:49 <liste> @let (‚Ç¨) = ($)
01:11:51 <lambdabot>  Defined.
01:12:12 <liste> gonna use that from now on :D localized Haskell!
01:12:26 <alexa_> @let (kr) = ($)
01:12:27 <lambdabot>  Defined.
01:12:39 <liste> alexa_ you need `kr` with that, though
01:12:46 <alexa_> :(
01:12:46 <liste> the `` make functions infix
01:12:46 <Maxdamantus> @let (‚ÇØ) = (‚Ç¨)
01:12:47 <lambdabot>  Defined.
01:13:01 <liste> > sin `kr` 5
01:13:03 <lambdabot>  -0.9589242746631385
01:13:18 <pavonia> alexa_: f $ g $ h x is f applied to (g applied to (h applied to x))
01:13:29 <alexa_> pavonia: cheers
01:13:45 <alexa_> I'm slightly confused as to why that isn't the default syntax
01:13:47 <alexa_> but okay :#
01:14:19 <liste> alexa_ you mean (f g h x) would be (f $¬†g $ h $ x) ?
01:14:38 <pavonia> It's actually not syntax but a function defined in the prelude
01:14:44 <pavonia> :t ($)
01:14:45 <lambdabot> (a -> b) -> a -> b
01:14:45 <alexa_> yeah, would seem more natural for most use cases, but maybe there are other reasons that will be resoundingly obvious to me in the coming weeks
01:15:25 <ChristianS> alexa_: how would you pass multiple args to a function in that case?
01:16:08 <alexa_> multiple arguwhat?
01:16:42 <alexa_> but yeah, it would screw the auto-curried syntax
01:16:45 <alexa_> good point
01:17:28 <liste> many haskell higher-order functions take a function as first argument and data as second
01:17:47 <liste> so "map (+1) . filter (>0) $ [1, 2, 3, 4, 5]" is convenient to write
01:17:48 <alexa_> there's another. Like I said, resoundingly obvious shortly after
01:17:54 <alexa_> I'm not used to paren-less languages.
01:17:56 <alexa_> They mess with the brains.
01:18:18 <alexa_> well, not paren-less, but not requiring parens for arguments.
01:19:54 <nkaretnikov> alexa_: that's fine, after a while, you should get comfortable with haskell syntax.  I like it better than, say, python's.
01:20:04 <alexa_> I should hope so
01:20:10 <alexa_> python syntax is a demonchild.
01:22:39 <liste> although python indentation rules are simpler imo
01:24:15 <liste> but less flexible
01:43:11 <grpala> in lisp I even like parens, but everywhere else I hate them
01:43:38 <grpala> it's one of those contradictions...
01:43:53 <grpala> I specially hate them in smalltalk
01:47:03 <augur> @where ops
01:47:03 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:47:05 <augur> Guest33674 is spamming people
01:47:51 --- mode: ChanServ set +o dibblego
01:47:56 --- mode: dibblego set +b *!Guest33674@*.77.20.109.rev.sfr.net
01:48:01 --- kick: Guest33674 was kicked by dibblego (Guest33674)
01:48:14 --- mode: dibblego set -o dibblego
01:48:29 <frerich> I wonder whether I have some ignore filters in place, I rarely notice the people getting kicked.
01:48:51 <frerich> Oh, or maybe it's spam via private messages.
01:49:30 <augur> frerich: PM spam
01:49:56 <augur> it was funny, too. intelligent design by super-smart humans. anti-evolution, anti-theist. lol
01:50:03 <augur> maybe a raelian or something
01:58:09 <kaidelong> well there is that one thought experiment
01:58:18 <kaidelong> that if we ever simulate beings about as complex as we are
01:58:26 <kaidelong> then if those do the same thing
01:58:33 <kaidelong> then it's likely we're simulated
01:58:57 <kaidelong> because logically there's going to be more simulated worlds than real ones if you can show that it can happen recursively
01:59:15 <kaidelong> oh wrong channel again
01:59:17 <kaidelong> I'm so sorry
02:03:35 <toki_2_0> Heya
02:03:52 <toki_2_0> any good ideas for gui programming in haskell ﬂ
02:03:57 <toki_2_0> ?
02:04:36 <liste> toki_2_0 hsqml and threepenny-gui
02:04:50 <toki_2_0> liste, thx !!
02:05:20 <liste> np (:
02:07:48 <liste> would it be hard to use hsqml with netwire/reactive-banana?
02:08:47 * hackagebot align 0.1.1.1 - Sequence alignment algorithms.  http://hackage.haskell.org/package/align-0.1.1.1 (literon)
02:23:48 * hackagebot inline-c 0.5.4.3 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.4.3 (FrancescoMazzoli)
02:51:20 <alexa_> so, writing unit tests in haskell... basically I build a second application that's relatively simple? Should I basically package teste suites into modules with a function returning a list of all tests in the suite, then run the suites using runTestsTT in the main of something like spec.hs?
02:51:25 <alexa_> I wonder if I just made any sense.
02:52:25 <Fuuzetsu> use hspec
02:52:38 <alexa_> as opposed to HUnit?
02:52:48 <alexa_> thanks
02:52:51 <alexa_> I'll take a look
02:58:49 * hackagebot dockercook 0.4.3.0 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.4.3.0 (AlexanderThiemann)
02:58:51 <Haskellfant> liste: bennofs is working on reflex bindings for hsqml, so I suppose netwire & reactive-banana would work as well
03:02:35 <alexa_> Fuuzetsu: http://hspec.github.io/hspec-discover.html THANK YOU
03:47:12 <liste> Haskellfant https://github.com/bennofs/hsqml-react seems so (:
03:47:26 <bennofs> liste: yeah, that was my first try
03:47:38 <bennofs> liste: is too complicated though and misses some features
03:48:19 <bennofs> liste: If I get this reflex thing working (https://github.com/bennofs/reflex-qml), then I'll eventually look into implementing the same approach with reactive-banana
03:48:28 <liste> great \o/
04:39:01 <ttt_fff> time for ghost stories
04:39:14 <ttt_fff> tell me about what happened to the programmer who used haskell for 5 years, but then was forced to use a language without monads
04:50:20 <dramforever> quick question: if a function needs one of its arguments to satisfy some condition, what do you refer to the condition as? law? precondition?
04:51:13 * dramforever doesn't quite know how to google that, and has not found an example
04:52:17 <bennofs> dramforever: I'd call it precondition
04:52:37 * dramforever is waiting for more opinions
04:53:40 <alexa_> dramforever: in some languages they get called a guard
04:53:56 <alexa_> or an assertion
04:54:14 <alexa_> in haskell lingo? not a clue
04:54:26 <frerich_> dramforever: In other cases, that would be a plain dedicated type (i.e. all values of that type satisfy that condition).
04:54:34 <alexa_> ^
04:54:38 <dramforever> how about "requirement"?
04:54:39 <alexa_> that's generally how I'd do it
04:54:43 <liste> I'd call something like "x>0" precondition
04:54:52 <liste> for a function to work
04:54:55 <dramforever> alexa_: sadly not in my case...
04:54:56 <alexa_> precondition conveys the meaning more accurately in haskell context, I would think
04:55:14 <liste> ie. "requires argument to be more than 0"
04:55:27 <dramforever> liste: so how about "requirement"?
04:55:48 <alexa_> all preconditions are requirements but not all requirements are preconditions ;)
04:56:03 <joncol> I have a list of lists representing a table with horizontal and vertical headers. What's a nice way of discarding these headers, and only extracting a list of lists of data values. I.e. a table where the first column and the first row has been discarded. I _could_ do it with the matrix package, but maybe there's a nice Prelude way of doing this?
04:56:15 <liste> preconditions, postconditions and invariants are commonly used in other languages and CS too
04:56:35 <liste> some even have language level support for them (cobra, eiffel)
04:57:05 <dramforever> map tail . tail $ [["h and v", "h1", "h2"], ["v1", "foo", "bar"], ["v2", "bar", "baz"]]
04:57:08 <liste> they're together known as design by contract
04:57:10 <dramforever> > map tail . tail $ [["h and v", "h1", "h2"], ["v1", "foo", "bar"], ["v2", "bar", "baz"]]
04:57:11 <lambdabot>  [["foo","bar"],["bar","baz"]]
04:57:20 <dramforever> joncol: ^ like that?
04:57:52 <liste> dra<mforever https://en.wikipedia.org/wiki/Design_by_contract
04:57:56 <liste> dramforever*
04:58:47 <dramforever> that's not quite suitable for my case. I guess I'll write a description of my case
04:58:55 * hackagebot servant 0.4.3.1 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.4.3.1 (jkarni)
04:58:57 * hackagebot servant-client 0.4.3.1 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.4.3.1 (jkarni)
04:58:59 * hackagebot servant-docs 0.4.3.1 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.4.3.1 (jkarni)
04:59:01 * hackagebot servant-jquery 0.4.3.1 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.4.3.1 (jkarni)
04:59:03 * hackagebot servant-server 0.4.3.1 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.4.3.1 (jkarni)
04:59:28 <dramforever> I'm writing a top-down splay tree implementation. one of the most important functions is "splay", as you might know
05:00:20 <dramforever> I use measures like in finger trees, since I think it's conventional
05:01:34 <joncol> dramforever> Nice
05:02:00 <dramforever> I have findAndSplay :: Measure s a => (s -> Bool) -> Splay s a -> Splay s a which requires this:
05:02:29 <dramforever> when called as findAndSplay f t, 1. f mempty = True 2. f (measureTree t {-the measurement of the whole tree-}) = False
05:03:09 <dramforever> so I think I've got 2 questions: 1. should I swap True and False there?
05:03:11 <ttk> How do I make an instance of 2 classes? What is the syntax?
05:03:37 <dramforever> 2. What should I call the requirements? I don't know if there's something better then "requirements"
05:03:43 <dramforever> ttk: write out both instances
05:04:05 * hackagebot servant-examples 0.4.3.1 - Example programs for servant  http://hackage.haskell.org/package/servant-examples-0.4.3.1 (jkarni)
05:04:06 <maki> hi
05:04:07 * hackagebot servant-blaze 0.4.3.1 - Blaze-html support for servant  http://hackage.haskell.org/package/servant-blaze-0.4.3.1 (jkarni)
05:04:09 * hackagebot servant-lucid 0.4.3.1 - Servant support for lucid  http://hackage.haskell.org/package/servant-lucid-0.4.3.1 (jkarni)
05:04:47 <maki> i'm new to haskell, and i'm trying to compile a simple Hello world program, but it doesn't work. can somebody help me?
05:04:48 <liste> I'd still call them preconditions
05:04:49 <bennofs> dramforever: the function f must satisfy these laws
05:04:49 * dramforever kinda hates how servant packages are updated
05:05:05 <bennofs> so I'd call them laws
05:05:20 <dramforever> bennofs: oh hmm...Although I think it's more commonly used in class docs, I think it's fine
05:05:31 <ttk> thanks
05:05:35 <bennofs> dramforever: and that the function satisfies these laws is a precondition for splay :)
05:05:40 <bennofs> IMO
05:05:44 <dramforever> okay I'll use "laws", thanks for all your opinions
05:06:00 <alpounet> dramforever: because it's all done in batch?
05:06:03 <dramforever> hmm...I would rather call it a precondition of the function
05:06:11 <dramforever> alpounet: ?
05:06:12 <liste> maki paste your code and possible error messages at http://lpaste.net/new/haskell
05:06:20 <alpounet> dramforever: re the servant packages
05:06:21 <joncol> :q
05:06:28 <dramforever> alpounet: yeah
05:06:45 * dramforever spotted vim user =P
05:07:51 <maki> liste, shall i printscreen the error or?
05:07:52 <dramforever> how about the second question: should I swap True and False in the two laws?
05:08:11 <dramforever> maki: are you using cmd?
05:08:19 <liste> maki preferably copy-paste from console (cmd.exe/Terminal.app/...(
05:08:34 <maki> i'm on windows, i'm using ghci
05:08:42 <comprehension> hey all
05:08:55 <lpaste> maki pasted ‚ÄúHello world‚Äù at http://lpaste.net/136284
05:09:02 <dramforever> maki: is it white on black or black on white?
05:09:30 <maki> white on black xD
05:09:35 <dramforever> maki: yes that's the correct message. what about the code?
05:09:44 <liste> maki $ ./helloworld isn't supposed to be pasted on ghci
05:09:53 <dramforever> oh yes that's the problem :P
05:09:59 <liste> the $ is the command prompt (C:\...> on windows)
05:10:01 <maki> ok, than i missunderstood something xD
05:10:04 * dramforever goes back to splay
05:10:18 <maki> ohh, thank you :D
05:10:32 <liste> and ./helloworld is a command to run an executable (helloworld.exe in windowS)
05:11:11 <liste> maki use :main in ghci to run your code
05:11:16 <YellowOnion> he needs to complie it first
05:11:29 <maki> yup, it works now, thank you ^^
05:11:31 <liste> YellowOnion ghci did it already
05:11:33 <maki> it's compiled already
05:11:39 <maki> i loaded it in ghci
05:11:51 <liste> no problem (:
05:11:54 * dramforever is going to swap True and False in the laws, i.e. change to this: f mempty = False, f (measureTree t) = True
05:12:34 <dramforever> because I can (sort of) call that monotonic and:
05:12:39 <dramforever> > False < True
05:12:40 <lambdabot>  True
05:13:26 <YellowOnion> liste, I mean to run an exe, you're gonna need a compiled binary.
05:17:52 <maki> how can i compile it to get an exe file?
05:18:45 <dramforever> run ghc -o any_name_you_want.exe your_haskell_file.hs in cmd (I don't know if you can omit .exe, but I don't) 
05:20:23 <maki> nice, it worked, thank you
05:23:42 <YellowOnion> you can just write ghc blah.hs, it'll add the extention for you.
05:24:29 <phaazon> hey, I'm looking for idea
05:24:36 <phaazon> I posted a link about that on reddit earlier (3-parts design)
05:24:40 <phaazon> I'm wondering
05:25:01 <phaazon> imagine you split your program into two loosely-coupled parts
05:25:08 <phaazon> a logic part
05:25:10 <phaazon> a view part
05:25:26 <phaazon> when you create an object in the logic part, it has to yield something to the view
05:25:49 <phaazon> but, later, you might need to alter that value and inform the view that THAT very object change
05:25:52 <phaazon> how would you do that?
05:26:15 <bennofs> phaazon: have you seen the mvc package?
05:26:52 <phaazon> yep
05:26:58 <phaazon> already discussed about with Gab
05:27:01 <phaazon> he told me not to use it
05:27:04 <phaazon> and write my own
05:27:08 <solirc> adarqui: For testing code hspec is a much better tool than doctest.  I'm the main author of both of them, so please trust me on that.
05:27:11 <phaazon> maybe I should dig in mvc
05:27:17 <phaazon> to understand how he synchronizes
05:27:36 <solirc> adarqui: I see doctest as a tool for testing documentation rather than code
05:28:36 <bennofs> phaazon: well, I think the idea is that you stream your updates to the view
05:28:58 <dramforever> haddock question: do we have inline code in haddocks? it doesn't seem so in the docs
05:29:36 <solirc> dramforever: @...@
05:29:37 <bennofs> phaazon: hmm. or alternatively, could you just always stream the full model to the view and let the view figure out what changed & how to update the view
05:29:40 <bennofs> ?
05:29:59 <dramforever> solirc: oh okay thanks. btw that was a good emoticon @...@
05:31:26 <Fuuzetsu> you can hyperlink stuff in inline comments too which is useful, @'id'@
05:31:39 <phaazon> bennofs: how?
05:31:44 <phaazon> I mean
05:31:51 <phaazon> you should read my post on reddit
05:32:00 <bennofs> phaazon: i did
05:32:00 <phaazon> wait
05:32:02 <phaazon> ah
05:32:25 <phaazon> how could the view know how to update what?
05:32:34 <phaazon> if I¬†pass the model without stating ¬´ which ¬ª object it is
05:37:47 <phaazon> looks like Gab uses the Managed type to handle that situation
05:45:35 <ttt_fff> how do I fix this code? https://gist.github.com/anonymous/5af0abd4f77b9733b314 ... I need some way to say "this is a monad that I can lift a "Want a" to"
05:46:52 <ttt_fff> pls hlp https://gist.github.com/anonymous/5af0abd4f77b9733b314
05:47:28 <Fuuzetsu> ttt_fff: looks like you want some monad stack
05:47:32 <ttt_fff> yeah
05:47:34 <ttt_fff> how do I do that
05:47:59 <Fuuzetsu> by picking the stack you want first instead of writing one thing and trying to come up with a wrong type signature
05:49:04 <Fuuzetsu> maybe you could read the transformers paper for inspiration
05:49:19 <ttt_fff> heres somethign slightly better https://gist.github.com/anonymous/eee64c82385add88dbf6
05:49:20 <ttt_fff> hmm
05:49:21 <ttt_fff> what
05:49:34 <ttt_fff> okay; this must be frustrating trying to help me right now
05:49:37 <ttt_fff> since I clearly do not understand something
05:49:41 <ttt_fff> but I fail to understand what I don't understand
05:49:52 <ttt_fff> can you hand me a list of URLs to read?
05:50:44 <Fuuzetsu> www.cs.virginia.edu/~wh5a/personal/Transformers.pdf easy to read
05:51:00 <Fuuzetsu> once you've read it, you should sit down, stop typing and *think* about what it is you want
05:51:59 <electroStatik> What is the reccomended work on parallel or concurrent Haskell? What is the most widely used library for machine learning or data science? Thanks
05:52:05 <ttt_fff> Simon 's book
05:52:12 <ttt_fff> called "Parallel AND concurrent Haskell"
05:52:32 <ttt_fff> Fuuzetsu: will read standing up and typing and without thinking; thanks!
05:53:24 <electroStatik> What is the opinion of Jeff Epstein's work? Do people know him here?
05:53:53 <electroStatik> Thank you for your responses
05:55:05 <Fuuzetsu> ttt_fff: let's consider sitting down an idempotent operation ;)
05:55:33 <lpaste> maki pasted ‚ÄúNo title‚Äù at http://lpaste.net/136285
05:55:37 <maki> can somebody help me figure out what's wrong with this code please? http://lpaste.net/136285
05:57:55 <ttt_fff> you know what's not an idempotent operation?
05:57:58 <ttt_fff> I need to switch printer toner
05:58:45 <electroStatik> To be sure the text reccommended is "Parallel and Concurrent Haskell" by Simon Marlow, not SPJ right?
05:58:51 <Fuuzetsu> yes
05:59:05 <Fuuzetsu> Parallel and Concurrent programming in Haskell
05:59:13 <Fuuzetsu> I believe, don't have it on hand
06:00:36 <electroStatik> I found his paper v.1.2 published May 11, 2012
06:00:43 <ttt_fff> did SPJ right a parallel/concurent text?
06:00:47 <ttt_fff> I thought there was only one such book
06:01:13 <ttt_fff> http://chimera.labs.oreilly.com/books/1230000000929/index.html <-- book I'm referring to
06:01:59 <electroStatik> ttt_fff, thanks for that. More up to date than the paper
06:07:14 <|f`-`|f> ?
06:20:12 <xnil> Hi, say I import a module Connection.Relay from a Main module. What should my project structure look like, assuming the respective modules are the only files in my project?
06:20:33 <ttt_fff> in haskelll, is there a way to get __FILE__ NOT at location where the macro is defined, but AT THE LOCATION WHERE MACRO IS CALLED
06:20:35 <JagaJaga> @hoogle m (a -> a) -> m a
06:20:36 <lambdabot> Data.Function fix :: (a -> a) -> a
06:20:36 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:20:36 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
06:22:49 <ttt_fff> @hoogle Ord
06:22:49 <lambdabot> Prelude class Eq a => Ord a
06:22:49 <lambdabot> Data.Ord class Eq a => Ord a
06:22:49 <lambdabot> Data.Ord module Data.Ord
06:22:58 <ttt_fff> what are the stuff I need to implement to be a Ord 
06:24:01 <JagaJaga> :info Ord
06:24:11 <JagaJaga> @help
06:24:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:24:18 <JagaJaga> @list
06:24:18 <lambdabot> What module?  Try @listmodules for some ideas.
06:24:22 <JagaJaga> list
06:24:32 <JagaJaga> @help list
06:24:32 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:24:39 <srhb> JagaJaga: lambdabot does not have info
06:24:46 <JagaJaga> srhb: :'(
06:25:20 <quicksilver> fortunately there are quite good docs you can link to :)
06:25:21 <quicksilver> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Ord.html
06:26:39 <xnil> Am I allowed to reask questions after so long if I don't get a response?
06:26:44 <xnil> It's sort of important
06:28:00 <liste> xnil go ahead, maybe people missed it
06:28:07 <xnil> Hi, say I import a module Connection.Relay from a Main module. What should my project structure look like, assuming the respective modules are the only files in my project?
06:28:45 <liste> Connection/Relay.hs and Main.hs
06:29:03 <xnil> thanks!
06:29:06 <liste> np (:
06:29:41 <liste> in hs-source-dirs, if you're using Cabal
06:30:20 <liste> is directory separator, so \ on Windows
06:30:26 <liste>  / is, I mean
06:39:23 <Hi-Angel> >(+) 1 Ä 5
06:39:47 <Hi-Angel> Dat bot.
06:40:35 <ronh> won't / work on windows as well?
06:41:34 <Hi-Angel> It should.
06:48:40 <quchen-mobile> What's rhe difference between HM and System F? Is it a restriction to rank-1 types? 
06:48:59 * hackagebot diagrams-svg 1.3.1.3 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.3.1.3 (jeffreyrosenbluth)
06:51:10 <chattered> quchen-mobile: Yeah. HM is only really as expressive as a monomorphic lambda calculus with type schemes.
06:52:19 <chattered> Not sure when type constructors got introduced, though, and whether they were in the original HM papers. My understanding is that the original ML didn't have them.
06:53:22 <quchen-mobile> Chattered: type constructors are F-omega though, no? 
06:55:23 <chattered> quchen-mobile: Yeah, at least the F-omega as implemented in HOL, which is predicative with explicit existential quantification. At least going by TAPL, System F only needs universal quantification and is impredicative.
07:04:08 <ttt_fff> #define dumpError error (__FILE__ ++ (show __LINE)) // in haskell, how do I write this so that when I use dumpError, the __FILE__ and __LINE__ comes from where dumpError is CALLED, not where it is defined) ?
07:04:23 <ttt_fff> [fixng minor typo] #define dumpError error (__FILE__ ++ (show __LINE__)) // in haskell, how do I write this so that when I use dumpError, the __FILE__ and __LINE__ comes from where dumpError is CALLED, not where it is defined) ?
07:05:02 <mauke> like that
07:05:26 <ttt_fff> no, in the above, the __FILE__ and __LINE__ are expanded where "dumpError" is defined, not where "dumpError" is called
07:05:35 <mauke> no
07:06:17 <ttt_fff> wtf
07:06:18 <ttt_fff> ur right
07:06:32 <ttt_fff> i could ahve sworn this did not work last night
07:08:23 * dramforever just searched "rm -rf ~/.ghc" in ircbrowse. was not disappointed
07:09:00 * hackagebot diagrams-haddock 0.3.0.5 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3.0.5 (jeffreyrosenbluth)
07:10:55 <hodapp> :t (\x y -> (,) x <$> y)
07:10:56 <lambdabot> Functor f => a -> f b -> f (a, b)
07:11:11 <ttt_fff> mauke: how do I export macros from one file to another?
07:11:22 <alexa_> In hspec can one "test" have multiple shouldBe calls?
07:11:22 <quicksilver> #include
07:11:43 <mauke> ttt_fff: I don't think you understand what macros are
07:11:51 <bz> @pl \x y -> [x, y]
07:11:51 <lambdabot> (. return) . (:)
07:11:59 <bz> wtaf
07:12:01 <ttt_fff> macros do blind string expansion
07:12:06 <alexa_> as in.. is this valid? http://pastebin.com/XWYUX06R
07:14:05 <mauke> bz: it goes via \x -> \y -> x : (y : []) and then notices that (: []) = return
07:14:51 <ttt_fff> where is the base directory tha t'include' includds from? http://projects.haskell.org/cpphs/
07:16:13 <liste> ttt_fff it's dictated by -I flag
07:16:24 <liste> option*
07:16:46 <liste> to [hs]cpp
07:18:23 <ttt_fff> liste: nice, thanks! also, *.cabal file option 'include-dirs'
07:19:18 <mauke> btw, you can do __FILE__/__LINE__ with TH, but not #define
07:24:55 <ttt_fff> mauke? what? I'm using #define, not TH
07:25:18 <Vektorweg1> should i use `Either Err a` or another type for error handling? 
07:26:15 <ChristianS> Vektorweg1: depends on your use case, but generally, that's not a bad choice
07:26:58 <Vektorweg1> ChristianS: thanks
07:27:19 <mauke> dammit, internet
07:27:54 * quicksilver apologises to mauke as a representative of the internet.
07:28:03 * quicksilver continues to stick captions on mauke's cats.
07:29:07 <alexa_> Oh gosh I just wrote my first haskell function and it's passing my first unit test. And it's O(n^2) -_-
07:29:43 <alexa_> I'm both proud of myself and ashamed.
07:29:56 <Vektorweg1> alexa_: this just means, you shouldn't feed it too much. ;)
07:30:47 <alexa_> I wonder if there's a better algorithm for generating a list of a number's digits.
07:30:57 <Vektorweg1> alexa_: performance is overrated. i'm sure it works in linear time on a quantum computer. :p
07:31:35 <Iceland_jack> alexa_: Something like
07:31:36 <Iceland_jack> > map digitToInt (show 123456)
07:31:37 <Iceland_jack> ?
07:31:38 <lambdabot>  [1,2,3,4,5,6]
07:32:44 <alexa_> Iceland_jack: yeah, but I'm not sure how fast the parsing runs. that could be essentially O(n^2) as well
07:32:52 <liste> > let f n = case n of 0 -> []; _ -> n : (f (n `div` 10)) in f 125
07:32:53 <lambdabot>  [125,12,1]
07:33:00 <alexa_> https://github.com/AlexaDeWit/haskell-exercises/blob/master/src/Homework1/CreditCards.hs is what I've got
07:33:01 <liste> > let f n = case n of 0 -> []; _ -> n `mod` 10 : (f (n `div` 10)) in f 125
07:33:02 <lambdabot>  [5,2,1]
07:33:26 <alexa_> I need to fix this list concatenation
07:33:52 <liste> alexa_ difference lists (:
07:33:56 <alexa_> liste: wrong order ;)
07:34:00 <benma> liste: note that there is divMod and quotRem, better in cases you need both at once
07:34:49 <liste> > let f n = case n of 0 -> id; _ -> (++ (n `mod` 10)) . (f (n `div` 10)) in f 125
07:34:51 <lambdabot>      No instance for (Typeable a0)
07:34:51 <lambdabot>        arising from a use of ‚Äòshow_M70409789086006573922267‚Äô
07:34:51 <lambdabot>      In the expression:
07:35:00 <liste> > let f n = case n of 0 -> id; _ -> (++ (n `mod` 10)) . (f (n `div` 10)) in (f 125) []
07:35:01 <lambdabot>      No instance for (Show a0)
07:35:01 <lambdabot>        arising from a use of ‚Äòshow_M86651998133671206012277‚Äô
07:35:01 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
07:35:33 <frerich> alexa_: The '< 10' case already handles '0', so I guess you don't need a special case for the latter.
07:35:39 <exio4> (++) there seems a bit useless
07:35:46 <liste> > let f n = case n of 0 -> []; _ -> n `mod` 10 : (f (n `div` 10)) in reverse (f 125) -- nah, f it :D
07:35:47 <lambdabot>  [1,2,5]
07:36:19 <bdesham> I'm having trouble calling hWaitForInput on a Handle that was converted from a Socket
07:36:19 <alexa_> frerich: frerich you're right, the [0] was originally there for if the last digit was a zero.
07:36:31 <bdesham> the code works fine when the Handle refers to a local file
07:36:49 <bdesham> are there any differences in how Handles should work between the two cases?
07:37:13 <exio4> > let f n = case n of 0 -> id; _ -> f (n `div` 10) . ((n `mod` 10):) in f 125 [] 
07:37:14 <lambdabot>  [1,2,5]
07:37:30 <liste> exio4 thx, that's what I was after
07:37:38 <liste> just not enough coffee :(
07:37:51 <alexa_> > f 0
07:37:53 <lambdabot>      No instance for (Show a0)
07:37:53 <lambdabot>        arising from a use of ‚Äòshow_M19724503115117599032360‚Äô
07:37:53 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
07:38:25 <alexa_> oh, you didn't defined it such that I can use it after did you?
07:38:38 <exio4> @let numberToDigits n = case n of 0 -> id; _ -> f (n `div` 10) . ((n `mod` 10):) 
07:38:39 <lambdabot>  Defined.
07:38:42 <exio4> > numberToDigits 0
07:38:44 <lambdabot>      No instance for (Typeable a0)
07:38:44 <lambdabot>        arising from a use of ‚Äòshow_M90052026243041780762391‚Äô
07:38:44 <lambdabot>      In the expression:
07:38:53 <exio4> @undefine
07:38:53 <lambdabot> Undefined.
07:39:07 <exio4> @let numberToDigits n = case n of 0 -> id; _ -> numberToDigits (n `div` 10) . ((n `mod` 10):) 
07:39:08 <lambdabot>  Defined.
07:39:14 <exio4> > numberToDigits 0
07:39:16 <lambdabot>  <[Integer] -> [Integer]>
07:39:19 <exio4> > numberToDigits 0 []
07:39:21 <lambdabot>  []
07:39:30 <alexa_> TEST FAILED
07:39:32 <alexa_> :D
07:39:37 <exio4> I am guessing it's wrong or so :)
07:39:39 <alexa_> I had that problem with my first writeup
07:39:51 <alexa_> yeah, the integer zero has one digit. zero.
07:39:53 <alexa_> :3
07:40:03 <alexa_> I had to change my original algorithm to accomodate that case
07:40:42 <Vektorweg1> > reverse $ map (`mod` 10) $ takeWhile (>0) $ iterate (`quot` 10) $ 1234567
07:40:44 <lambdabot>  [1,2,3,4,5,6,7]
07:41:14 <liste> > reverse $ map (`mod` 10) $ takeWhile (>0) $ iterate (`quot` 10) $ 0
07:41:16 <lambdabot>  []
07:42:08 <alexa_> how would I change this https://github.com/AlexaDeWit/haskell-exercises/blob/master/src/Homework1/CreditCards.hs such that toDigits has an inner function digits that would result in the digits in reverse word, and allow me to simply call reverse once?
07:42:22 <alexa_> like, I'm not really sure how nested functions work in Scala, not well anyway
07:42:57 <bdesham> alexa_: you can define a function within the "where" block, just like how you've defined d and r
07:44:15 <alexa_> yeah, but I'm not sure how to combine it with pattern matching etc properly -_-
07:46:37 <Vektorweg1> > (map (read . (:[])) . show :: Integer -> [Integer]) 1234567
07:46:38 <liste> alexa_ toDigits = reverse . digits where digits x | x < 10 ... 
07:46:38 <lambdabot>  [1,2,3,4,5,6,7]
07:47:07 <Vektorweg1> monkey approves. 
07:47:08 <liste> although that would require nested wheres
07:47:18 <aweinstock> also, it looks like you might want to use divMod, which gives the results of both div and mod in 1 call
07:48:35 <alexa_> and then I hit the brick wall of haskell indentation rules
07:49:59 <liste> alexa_ they're foreign but simple (:
07:50:21 <alexa_> liste: I think I just need to sit and read them later
07:50:29 <liste> the first thing after `where` (or `do` etc) sets the column
07:50:37 <alexa_> https://gist.github.com/AlexaDeWit/c12557a1176037e685a5
07:50:54 <alexa_> as in the first anything, so it should align to the word digits in this case?
07:51:14 <liste> yeah
07:51:14 <Vektorweg1> aweinstock: and don't forget to work on arrays or at least bytestrings. and just in case, you should write it using accelerate.
07:51:38 <alexa_> well, I'm still totally lost on the syntax here. More reading and then return to it maybe
07:51:54 <liste> where digits x
07:52:04 <alexa_> ah, got the . from you :P
07:52:08 <liste>       | x < 10 ...
07:52:24 <liste> . is awesome
07:52:24 <alexa_> no wait was thinking the other line
07:53:17 <alexa_> sadly that doesn't resolve the issue at all, it still complains of incorrect indentation
07:53:25 <liste> alexa_ show the paste (:
07:54:21 <alexa_> https://gist.github.com/AlexaDeWit/bcb22a41cb49303e1661 if I do this  I get "parse error on input 'where'"
07:54:33 <alexa_> if I indent one level I get indent complaints
07:54:41 <aweinstock> alexa_: slightly different approach, but this seems to work: toDigits = reverse . takeWhile (> 0) . unfoldr (\x -> if x < 10 then Just (x, 0) else let (d,r) = divMod x 10 in Just (r, d))
07:54:58 <liste> alexa_ you need one space more
07:55:02 <alexa_> aweinstock: thanks
07:55:09 <liste> before |
07:55:10 <alexa_> I need a single space? where?
07:55:19 <Vektorweg1> indent complains are better than the basic parser errors. 
07:55:24 <alexa_> but d and | are on the exact same column
07:55:59 <alexa_> are they not supposed to be?
07:56:01 <aweinstock> on line 7 of the most recent gist, "where" should be indented
07:56:13 <liste> alexa_ guards must be indented more
07:56:15 <liste> than patterns
07:56:21 <alexa_> parse error (possibly incorrect indentation or mismatched brackets) resutls from indenting it
07:56:23 <alexa_> okay
07:56:44 <liste> and where must be indented more than patterns too
07:56:59 <frerich> aweinstock: That won't work for '0' though.
07:57:07 <alexa_> liste: thanks
07:57:38 <liste> or must it :D I'm not sure
07:57:40 <liste> gotta check
07:57:47 <aweinstock> frerich: it returns the empty list for 0, is that at least arguably correct? ;)
07:57:48 <liste> yeah
07:57:57 <alexa_> so, what is ., liste?
07:58:13 <liste> . is composition
07:58:15 <liste> :t .
07:58:16 <lambdabot> parse error on input ‚Äò.‚Äô
07:58:19 <liste> :t (.)
07:58:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:58:24 <liste> @src (.)
07:58:24 <lambdabot> (f . g) x = f (g x)
07:58:35 <liste> same as the little circle in math
07:58:42 <liste> supposed to approximate it
07:58:47 <frerich> aweinstock: Well alexa_'s original yields [0]
07:58:57 <alexa_> I have no idea what little circle means ;)
07:59:01 <alexa_> aweinstock: it is incorrect :P
07:59:22 <liste> ‚àò this
07:59:28 <liste> is the little circle :D
07:59:41 <alexa_> but yeah, I know what compose in FP means
08:00:33 <alexa_> although somehow nesting this and composing with reverse results in a nonsensical seeming list
08:02:04 <aweinstock> frerich: I think this fixes it? toDigits = reverse . unfoldr f where { f x | x < 0 = Nothing; f x | x < 10 = Just (x, -1); f x = Just (uncurry (flip (,)) (divMod x 10))}
08:08:51 <recurry> Is it recommended that one learn Haskell before C, or the other way around?
08:09:31 <chpatrick> I would do haskell before C
08:09:37 <c_wraith> I don't really recommend that anyone learn C.  The entire language is traps that hide more traps.
08:09:39 <chpatrick> it's easier to go from high to low level than the other way around
08:09:42 <monochrom> toss a coin. it doesn't matter
08:09:54 <monochrom> if the coin lands on its edge, learn both concurrently
08:10:12 <chpatrick> I think thinking about abstract concepts is much more important in the beginning than the kind of stuff you worry about in C
08:11:12 <monochrom> there are cons to both orders
08:11:37 <aweinstock> monochrom: could you elaborate on that?
08:11:49 <c_wraith> Does rust get rid of all of C's traps?  I'd like a low-level language that isn't full of traps.
08:12:16 <c_wraith> "You added two numbers together and thought the result was defined by the spec?  hah.  Fool."
08:12:16 <hodapp> where's Denommus? He knew a bit about Rust.
08:12:25 <quicksilver> C isn't really low-level 
08:12:36 <hodapp> c_wraith: I wouldn't say *all* the traps, but a great many of them (and C++'s)
08:12:47 <quicksilver> at least if you think low-level means 'like a portable assembly language'
08:12:57 <c_wraith> Well, my main point is that C isn't portable.
08:13:05 <recurry> C is pretty low-level. Not assembly low-level, but it's there, in my opinion.
08:13:05 <quicksilver> it's a terrible match for modern CPUs (and a pretty poor match even for the CPUs when it was first popular)
08:13:09 <bergmark> http://archive.adaic.com/intro/ada-vs-c/cada_art.html
08:13:10 <monochrom> high then low: the student assumes all kinds of automagic that no one ever needs to implement
08:13:16 <hodapp> quicksilver: in the words of Alan Perlis, a language is lov-level if it requires attention to the irrelevant.
08:13:23 <monochrom> low then high: the student can't do algebra
08:13:33 <c_wraith> Just about every operation in C has cases that are implementation-dependent.  Every compiler is allowed to treat them differently.
08:14:33 <quicksilver> C fails to provide good data structures 
08:14:48 <monochrom> don't tell me about "portable high-level asm" until you let me read the carry flag
08:14:54 <quicksilver> and this encourages a lot of code which pretends that good data structures are impossible, and tries to implement algorithms without them
08:15:01 <quicksilver> monochrom: yeah, that's pretty much my point.
08:15:13 <hodapp> quicksilver: and it also encourages developers that this is the way code *should* look.
08:15:15 <monochrom> and the carry flag is needed for implementing big integers
08:15:20 <quicksilver> hodapp: yes exactly.
08:15:29 <aweinstock> c_wraith: at least as far as integer overflow in rust, I think it's guarenteed to trap in debug mode, and there are explicit wrap/checked types you can use: https://github.com/rust-lang/rust/issues/22020
08:15:39 <quicksilver> hodapp: it encourages a kind of blindness to the use of data structures
08:15:52 <quicksilver> not universally, of course, there exist plenty of C programs using reasonable ones
08:15:57 <quicksilver> but there exist many many more which do not.
08:16:07 <recurry> So, it's generally recommended that one learn Haskell before C. I assume doing so would result in an easier transition than the inverse?
08:16:32 <quicksilver> I would learn haskell, javascript, python or even java in preference to C
08:16:44 <quicksilver> and learn C later only because you had some specific need for it.
08:17:14 <alexa_> rust is a decent alternative to C
08:17:20 <hodapp> I need to learn it.
08:17:27 <alexa_> all you need out of C is an understanding of malloc and stack frames
08:17:30 <alexa_> learn rust call it a day.
08:17:53 <alexa_> hodapp: for school?
08:18:01 <dmj`> definitely learn C, it runs the world
08:18:02 <recurry> I'd say yes, Rust hides traps from you yet gives you a similar level of control/access to C.
08:18:10 <hodapp> alexa_: No, for hobby/work purposes.
08:18:25 <alexa_> microcontrollers that have C-only APIs?
08:18:28 <alexa_> Not seeing it yet.
08:19:05 <alexa_> I suppose for work if you want to get into EE though, and programming microcontrollers and all that
08:19:06 <hodapp> alexa_: hrm? I'm working on one literally right now that's basically C-only.
08:19:14 <edk> writing C is kind of fun
08:19:15 <bz> microcontrollers have apis wat wat
08:19:20 <hodapp> edk: kind of.
08:19:23 <edk> but yes, microcontrollers are the main place it's necessary
08:19:38 <alexa_> bz: hell if I know, I don't do microcontrollers :D
08:19:59 <alexa_> I assume for some embedded systems stuff there's a basic api that you then interract with using C. Mabye not microcontrollers
08:20:00 <peterson> vast majority of low-level embedded code is written in C (and target asm for the device)
08:20:10 * alexa_ shrugs and goes back to her high level memory bloated world
08:20:18 <alexa_> I HAVE ALL THE GIGABYTES
08:20:24 <hodapp> alexa_: a lot of microcontrollers have SDKs that operate in such a manner, yes.
08:20:32 <bz> maybe you meant application binary interfaces
08:20:32 <edk> alexa_, generally you communicate with hardware using MMIO, manufacturers will provide reference interfaces for communicating with them in C
08:20:34 <recurry> This is what I came up with after dabbling with C for a bit:
08:20:36 <recurry> http://pastebin.com/AdJpeG2E
08:20:42 <edk> but you can fairly easily interface with them in other things, if you want
08:21:16 <alexa_> edk: that's sort of why I was like "not seeing it" I was sure that ultimately you need to make ASM calls to them, no? And you'd be able to do this in rust I would think
08:21:38 <alexa_> I mean rust is FOR systems programming. God I'd hope they make it easy to accomplish.... systems programming ;)
08:21:48 <peterson> bergmark .. ada is a very under-appreciated language .. completely agree
08:21:49 <alexa_> maybe I'm a looney.
08:22:20 <edk> alexa_, generally not - you'd point C somewhere in memory where your mmio registers are
08:22:26 <edk> but it varies between hardware, obviously
08:22:48 <hodapp> alexa_: a language being *for* something has often meant very little >_>
08:22:56 <alexa_> hodapp: true enough
08:23:57 <edk> hodapp, i think i like how constrained it is
08:27:10 <bergmark> peterson: my first year at uni was common lisp, more common lisp, and ada <:)
08:27:28 <peterson> bergmark: heh .. nice combo
08:27:41 <peterson> i spent a couple of years in the mid 90's working in ada 95
08:27:51 <peterson> on fairly low-level stuff
08:28:08 <peterson> quite a pleasure to use .. and i've seen some beautiful ada that i think even haskellers would admire :)
08:28:18 <bergmark> sweet!
08:29:01 <peterson> representation clauses are beautiful for example: http://docs.adacore.com/gnat_rm-docs/html/gnat_rm/gnat_rm/representation_clauses_and_pragmas.html
08:29:54 <peterson> i think there is a surprising syntactic similarity between haskell and modern ada (i.e. 95 and later)
08:31:01 <peterson> i wrote a lot of message bus stuff in ada and we used rep clauses to handle the bit-level marshalling and unmarshalling, whilst keeping the record defintiions themselves clean and pure and untouched by all that crap
08:31:04 <Welkin> why am I hearing so much about ada lately?]
08:31:07 <Welkin> did something happen?
08:31:15 <peterson> not something readily achieved in C for example
08:31:18 <peterson> Welkin: i don't think so .. 
08:31:35 <Welkin> other people have mentioned ada recently around here
08:31:42 <peterson> it's just another one of those slow-burn languages "doomed to succeed" like haskell :)
08:33:35 <peterson> i'm not sure it will ever be a mainstream language for open-source s/w
08:33:48 <peterson> it's really targeted at embedded high integrity sw
08:34:47 <peterson> but i guess there is overlap with the PL / formal methods community .. for example SPARK and ravenscar are cut-down profiles you can use to write provably safe sw
08:34:48 <Welkin> plus it incorporates oop, which is a negative
08:34:59 <peterson> so does ocaml :)
08:35:06 <peterson> but yes i agree
08:35:32 <peterson> ultimately it's an imperative languages with all the issues that go with that 
08:35:51 <hodapp> I looked at SPARK, and then kind of didn't care
08:35:57 <peterson> but it's at least a language designed by people with half a clue who care .. a lot like haskell :)
08:36:19 <peterson> unless you're writing safety-critical systems it's probably not relevant to you :)
08:39:01 <peterson> gtg .. late here .. cya!
08:39:03 <hodapp> peterson: I'm not writing safety-critical ones, but ones that really benefit from not being crashy and stupid.
08:39:21 <peterson> hodapp for that i say FP is a great choice
08:39:31 <peterson> and i really enjoy writing in haskell
08:39:43 <hodapp> peterson: it's what I'm using Ivory for (it's a Haskell EDSL)
08:39:48 <peterson> after 10 years of predominatly ruby and java it's making programming fun again ;)
08:39:58 <peterson> hodapp: yeah saw that .. looked interesting
08:40:03 <peterson> as does Elm for example
08:40:11 <peterson> and Frege for those on the JVM
08:40:12 <hodapp> those are worlds apart
08:40:20 <peterson> yes i know
08:40:45 <peterson> hodapp you mean ruby and java?
08:41:05 <hodapp> peterson: Elm and Ivory
08:41:08 <peterson> or Elm and Iv
08:41:11 <peterson> k
08:41:54 <peterson> yeah i remember now .. ivory is the galois project
08:42:25 <peterson> i only took a quick look .. my first take was that i was surprised how close the ivory rep was to the underlying c rep
08:42:31 <peterson> i was kind of thinking "what's the point"
08:42:56 <peterson> was expecting a much higher-level specification language that would be translated and optimised down to low-level C
08:43:04 <peterson> but maybe it was just the example
08:43:37 <peterson> i happen to think that C and javascript are the new "assembly languages"
08:43:56 <peterson> and we should be building high-level tools in langs like haskell to ultimately emit these langs
08:43:59 <liste> and soon WebAssembly (:
08:44:04 <peterson> yeah saw that too
08:44:09 <Welkin> peterson: c has always been a thin wrapper over asm
08:44:24 <hodapp> peterson: high-level tool in Haskell that emits C is precisely what Ivory is.
08:44:24 <peterson> Welkin: well that's a touch harsh even in my view ;)
08:44:41 <peterson> hodapp lemme see if i can find the example hang on
08:44:55 <hodapp> peterson: the point is that you get the entirety of Haskell as a template/metaprogramming language, you get the ability still to interface with other C, and you get on top of this a lot more protection from Haskell's type system and from a more constrained AST that is more amenable to things like static verification
08:45:28 <peterson> ok this:
08:45:28 <peterson> [ivory|
08:45:29 <peterson> struct PID
08:45:29 <peterson>   { pid_mv  :: Stored IFloat
08:45:31 <peterson>   ; pid_i   :: Stored IFloat
08:45:31 <peterson>   ; pid_err :: Stored IFloat
08:45:33 <peterson>   }
08:45:33 <peterson> |]
08:45:35 <peterson> type SP   = IFloat -- Set point
08:45:35 <peterson> type PV   = IFloat -- Process (measured) value
08:45:37 <peterson> type Time = IFloat
08:45:37 <peterson> from: https://github.com/GaloisInc/ivory/blob/master/ivory-examples/examples/PID.hs
08:45:45 <peterson> i mean .. i hear what you're saying .. but that's just C to me
08:46:02 <hodapp> their examples are all pretty mediocre for showing anything but the building blocks you have
08:46:18 <peterson> i would expect something like (and forgive me .. completely winging it here) .. \
08:46:20 <Welkin> oh
08:46:23 <peterson> I have a PID
08:46:25 <Welkin> Ivory is made by Galois
08:46:32 <peterson> it has these components (p, i, d)
08:46:34 <hodapp> and half of that example is their quasiquoted struct definition, which is made purposely to look closer to C
08:46:46 <peterson> these functions define proportion, integration and differentiation respectivelt
08:46:52 <peterson> the ranges of inputs i expect are : ...
08:46:55 <peterson> and so on
08:46:57 <peterson> invariants
08:47:01 <peterson> assertions
08:47:06 <hodapp> it lets you express invariants and assertions
08:47:18 <peterson> basically a high-level mdoel that I could pump through a simulator, or validator,
08:47:32 <hodapp> you've described what Ivory already is
08:47:32 <peterson> and then finally a machine-model (like a BSP in embedded sw)
08:47:43 <peterson> there should be no IFloat !!! anywhere in the spec
08:48:02 <peterson> the tool should decide on the mappings to machine-level types based on the constraints expressed in the spec
08:48:07 <peterson> that;s my point
08:48:08 <peterson> no struct
08:48:15 <peterson> no iFloat 
08:48:17 <peterson> none of that
08:48:21 <hodapp> you can write it that way if you want
08:48:26 <peterson> anyway . jusy my opinion
08:48:28 <hodapp> you do not *have* to write it that way
08:48:32 <peterson> like i said i'm no expert
08:48:42 <peterson> i just felt surprised how low-level the spec lang was
08:48:48 <peterson> anyway /rant off ;)
08:49:06 <peterson> heres a counterexample
08:49:11 <peterson> again i'm not an expert
08:49:20 <peterson> http://www.clash-lang.org/
08:49:27 <peterson> high level spec in EDSL in haskell
08:49:32 <hodapp> counterexample to what?
08:49:35 <peterson> compiled down to verilog or vhdl (can't recall)
08:49:37 <peterson> to Ivory
08:49:49 <peterson> look at the example
08:49:53 <peterson> fir hs x = dotp hs (window x)
08:49:54 <peterson>   where
08:49:55 <peterson>     dotp as bs = foldr1 (+) (zipWith (*) as bs)
08:49:55 <peterson> and THAT
08:49:59 <peterson> gets turned to verilog
08:50:07 <peterson> _thats_ a spec language
08:50:14 <liste> or vhdl (:
08:50:15 <peterson> anyway dudes/dudettes gtg
08:50:17 <liste> or both
08:50:17 <peterson> or whatever
08:50:24 <peterson> or brainfuck ..
08:50:29 <peterson> i mean that's the point
08:50:30 <hodapp> CLaSH is a completely different package which solves a different problem...
08:50:34 <peterson> there's no IFloat in brainfuck
08:50:38 <peterson> so how does Ivory target it 
08:50:39 <peterson> )
08:50:41 <hodapp> Ivory is meant for safe systems programming
08:50:41 <peterson> silly example :)
08:50:49 <peterson> brainfuck is turing complete
08:50:51 <peterson> it's the same thing
08:50:52 <hodapp> CLaSH is meant for FPGAs
08:50:54 <nshepperd> ivory was designed for writing hard real time systems
08:50:54 <peterson> anyway gtg
08:51:06 <peterson> it's not about FPGA vs embdedded
08:51:10 <hodapp> that's not a "counterexample", that is just "something completely different"
08:51:15 <peterson> it's about how to write a EDSL spec langage
08:51:17 <peterson> disagree
08:51:20 <liste> is ivory good for situations where everything must be statically allocated?
08:51:23 <peterson> sorry .. didn't want a fight .. too tired
08:51:24 <peterson> cyas
08:51:29 <liste> o/
08:51:42 <peterson> almost 2am here in oz .. bye all
08:51:56 <hodapp> nshepperd: well, sorta. Something like Atom or Copilot is better-suited to that
08:52:06 <hodapp> peterson: you disagree with *what*?
08:52:12 <nshepperd> liste: they nominally forbid dynamic allocation, because malloc is difficult to reason about in a realtime env
08:52:25 <peterson> i disagree that it's not a counterexample
08:52:33 <peterson> but i really have to sleep :)
08:52:43 <peterson> cheers hodapp liste 
08:52:47 <hodapp> peterson: you pointed out a library that serves a completely different purpose and is not even an EDSL...
08:53:25 <liste> nshepperd gotta look into it then (:
08:53:59 <hodapp> nshepperd: not only that, but it uses the type system to enforce particular ways you can use things that are global or stack-allocated
08:54:06 <peterson> "CŒªaSH (pronounced ‚Äòclash‚Äô) is a functional hardware description language that borrows both its syntax and semantics from the functional programming language Haskell."
08:54:11 <peterson> call it what you want
08:54:17 <peterson> l8rz
08:54:18 <liste> first I thought Rust would replace C but I'm not sure how useful it is when everything must be statically allocated
08:54:19 <peterson> happy to pick this up another time
08:54:25 <hodapp> peterson: it's not what I want, it's what an EDSL *is*. Go look it up.
08:54:56 <hodapp> peterson: come to #haskell-embedded if you want to discuss it. The author of CLaSH is there and he's sometimes active.
08:55:31 <hodapp> nshepperd: what are you using Ivory for?
08:55:48 <hodapp> liste: I didn't think Rust required that.
08:56:17 <aweinstock> liste: rust definitely has non-static (stack/heap) allocation
08:56:25 <liste> no, I meant the other way
08:56:45 <liste> when the platform disallows or limits non-static allocation
08:56:53 <hodapp> liste: I'm not sure what you're saying then
08:57:25 <aweinstock> that embedded devices don't support non-static allocation, and rust having those features is a liability for that application?
08:57:50 <hodapp> from what I've heard, Rust still can work just fine in environments that lack dynamic allocation
08:58:28 <aweinstock> does stack allocation for function calls count as "dynamic allocation" in this context?
08:58:34 <hodapp> I'm not counting that, no
08:59:08 <nshepperd> hodapp: my brother is using it to program a small hover drone he built. I've dabbled in it but haven't really done anything beyond toy programs with it
08:59:31 <hodapp> nshepperd: Ivory doesn't really handle any of the real-time stuff; I believe that's more what Tower is for
08:59:52 <hodapp> nshepperd: right now I'm trying to convert Atom over to target Ivory (rather than generate C code directly) for this reason
09:00:09 <hodapp> I kind of want to try out their drone stuff
09:01:10 <Welkin> wow
09:01:17 <hodapp> wow what?
09:01:26 <Welkin> I'm learing about all these incredible DSLs in haskell today
09:01:34 <Welkin> I didn't know these existed
09:01:40 <hodapp> :)
09:02:15 <Welkin> I still haven't even used any hs -> js compilers yet
09:02:26 <hodapp> me neither except brief ghcjs dabbling
09:02:46 <hodapp> http://haskellembedded.github.io/pages/links.html is some of the EDSLs I'd found for embedded use or semi-related things
09:02:50 <hodapp> SBV looks interesting
09:03:59 <liste> what's the difference between *Lava and ClaSH ?
09:04:06 * hackagebot hlibsass 0.1.4.0 - Low-level bindings to Libsass  http://hackage.haskell.org/package/hlibsass-0.1.4.0 (jakubfijalkowski)
09:04:18 <Welkin> haha, the standard hakyll template
09:04:20 <schoppenhauer> hi. is there a stack structure that uses an array as backend? that is, an array that can be extended, but not overwritten?
09:04:32 <hodapp> liste: Lava is a family of EDSLs, a good deal older than CLaSH
09:04:34 <Welkin> you know a hakyll site when you see it
09:05:01 <hodapp> liste: CLaSH actually compiles a considerable subset of Haskell to Verilog/VHDL
09:05:44 <hodapp> liste: in other words, with Lava, your Haskell program generates your hardware design; with CLaSH, your Haskell program is actually compiled to run on the hardware
09:05:59 <hodapp> liste: http://hackage.haskell.org/package/clash-prelude-0.9.1/docs/CLaSH-Tutorial.html - see the bottom of that page
09:06:30 <aweinstock> schoppenhauer: are you looking for the theory behind growable arrays, or a specific library/the corresponding datastructure in haskell?
09:06:50 <schoppenhauer> aweinstock: library
09:07:18 <aweinstock> Data.Vector, maybe? what's this for?
09:08:51 <liste> cool (: so clash is HLS
09:09:55 <schoppenhauer> aweinstock: no. cons and snoc take O(n)
09:11:54 <aweinstock> schoppenhauer: so you're looking for something that can be used as a stack with O(1) push and pop, but linked lists aren't sufficient?
09:12:37 <schoppenhauer> aweinstock: which part of my question wasn't clear?
09:15:19 <aweinstock> schoppenhauer: I don't know of a haskell library that fits that directly, and while one could probably be written as a wrapper around Data.Vector, it's not clear (to me) why it has to be array-backed (performance?)
09:15:40 <Welkin> schoppenhauer: Data.Sequence
09:15:45 <nshepperd> array-backed stacks aren't very good in a persistent setting
09:16:22 <nshepperd> unless you're talking about a mutable stack
09:16:40 <aweinstock> Welkin: I thought Data.Sequence was an O(log(n)) datastructure for most operations?
09:17:37 <nshepperd> yeah Data.Sequence is definitely the wrong thing if all you want is a stack
09:17:58 <schoppenhauer> nshepperd: I thought maybe something like DiffArray, just with fewer operations and less overhead ...
09:18:10 <nshepperd> though it is O(1) for push/pop at either end
09:18:41 <schoppenhauer> well, I need push/pop in O(1) and nth in O(1), or at least amortized.
09:20:19 <aweinstock> schoppenhauer: data CppVector a = { data :: Data.Vector.Vectora a, size :: Int } -- capacity is implicit in the data field
09:21:06 <aweinstock> double the capacity on push if size == capacity, get amortized O(1) push
09:21:15 <nshepperd> hmm, well, I don't think DiffArray has resize, but you could probably write something similar that does
09:21:39 <Welkin> aweinstock: not for cons and append
09:21:47 <Welkin> it has constant time access to the ends
09:21:59 <schoppenhauer> aweinstock: how can I push something to a vector?
09:22:10 <schoppenhauer> aweinstock: as far as I see this will result in copying
09:22:20 <nshepperd> and then make damn sure that you use it in a single-threaded way
09:22:25 <Welkin> yes, vectors will copy
09:22:33 <Welkin> unless you use a mutable vector
09:22:54 <Welkin> but you still need to know the size before hand
09:23:09 <Welkin> a vector is not appropriate for a stack
09:23:20 <dolio> Lists are stacks with O(1) push and pop.
09:23:40 <Welkin> an actually stack is exactly a list
09:23:43 <Welkin> actual*
09:23:53 <aweinstock> wait, is Data.Vector.(//) not O(1)?
09:24:23 <nshepperd> aweinstock: immutable vectors copy for every modification
09:24:38 <ttt_fff> in general, it it possible to have (m a -> m a) -> (t m a -> t m a) ? If so, how? If not, is it possible to ahve (m a -> m a) -> (RWST m a -> RWST m a) ?
09:24:55 <ttt_fff> I want to lift something that modifies a "m a" into one that modifies a "t m a"
09:25:06 <nshepperd> schoppenhauer: it looks like the short answer is you'll have to write it yourself
09:25:13 <schoppenhauer> ok
09:25:27 <aweinstock> nshepperd: would STVector be the correct thing to use as the underlying data field?
09:26:49 <nshepperd> if you want an immutable interface, you might as well use an IOVector, like DiffArray does
09:28:00 <nshepperd> since you have to hold on to the vector ref => you'll use unsafePerformIO
09:30:34 <aweinstock> nshepperd: why is that advisable in this instance? won't pop followed by push cause problems if unsafePerformIO is used, and more there's more than one reference to the stack?
09:30:58 <schoppenhauer> aweinstock: pop would not be allowed (or lead to a copy)
09:31:07 <schoppenhauer> aweinstock: that is the same as with diffarrays
09:31:51 <aweinstock> schoppenhauer: so you'll have an immutable interface with O(1) amortized push, O(1) indexing, and O(n) pop?
09:31:55 <mlrutherford> Hey guys! Are there any good resources for Haskell specifically for someone who has a Lisp/Scheme background?
09:32:00 <nshepperd> the problems are the same with any non-single-threaded usage
09:32:19 <schoppenhauer> aweinstock: yes.
09:32:34 <nshepperd> what you do is make any operation mark the old instance as stale
09:32:54 <nshepperd> and then an operation on a stale reference copies the array
09:33:01 <chpatrick> ttt_fff: I don't think it's possible as you would need to be able to do (t m a -> m a) to plug it into the function
09:33:05 <chpatrick> (in general)
09:33:19 <ttt_fff> okay
09:33:24 <ttt_fff> yeah, I was starting to think it was not possible
09:34:30 <nshepperd> or... yeah, I suppose when you pop you'll have to bundle the value popped into the old instance too, so it doesn't get lost when overwritten
09:35:30 <nshepperd> but, you can do that, and end up indeed with an O(1) amortized push, pop and index
09:36:44 <zovt> hey guys, does stack allow you to run your project?
09:36:54 <chpatrick> :t \f rws -> RWST $ \r s -> runRWST rws r s >>= \( x, s, w ) -> f (return x) >>= \x' -> return ( x', s, w )
09:36:55 <lambdabot> (Monad m, Monad m1) => (m1 a1 -> m a) -> RWST r w s m a1 -> RWST r w s m a
09:37:18 <chpatrick> this typechecks but I'm not sure it makes any sense
09:38:08 <chpatrick> @list
09:38:08 <lambdabot> What module?  Try @listmodules for some ideas.
09:38:11 <chpatrick> @listmodules
09:38:12 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:38:23 <Welkin> @ticker
09:38:23 <lambdabot> Empty ticker.
09:38:38 <Welkin> @ticker APPL
09:38:38 <lambdabot> APPL: N/A +0 (+0%) @ N/A N/A
09:38:50 <Welkin> @ticker MSFT
09:38:50 <lambdabot> MSFT: 44.9899 +0.4699 (+1.0555%) @ 7/10/2015 12:23pm
09:38:56 <chpatrick> @ticker GOOG
09:38:57 <lambdabot> GOOG: 531.28 +10.60 (+2.04%) @ 7/10/2015 12:23pm
09:39:04 <zovt> nevermind, I got it
09:39:07 * hackagebot tubes 0.2.2.2 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.2.2 (gatlin)
09:39:10 <Welkin> @fresh
09:39:10 <lambdabot> Haoq
09:39:18 <Welkin> @fresh prince
09:39:19 <lambdabot> Haor
09:39:20 <aweinstock> @pl (\(x, y) -> (y, x))
09:39:20 <lambdabot> uncurry (flip (,))
09:39:42 <dolio> How about we don't spam the channel with lambdabot commands?
09:40:04 <alexa_> Hey guys, quick question... How does one add constraints inline within a where clause? I'm getting a compiler warning for nearly each numeric operation
09:40:09 <Welkin> dolio: there is always a time for everything
09:40:09 <alexa_> https://gist.github.com/AlexaDeWit/7254c87078ecbdafd91b
09:40:12 <glguy> You can get that some great lambdabot command flavor in private query
09:40:21 <chpatrick> @ticker HRL
09:40:21 <lambdabot> HRL: 57.37 +0.15 (+0.26%) @ 7/10/2015 12:24pm
09:40:29 <chpatrick> ok ok
09:40:55 <Welkin> alexa just write the type declaration as you would with a normal top-level functiojn
09:41:03 <nshepperd> ttt_fff: oh right, I think you might want hoist from mmorph
09:41:10 <Welkin> or include inline type annotations (f xs :: [Int])
09:41:15 <alexa_> Welkin: doesn't that precede the :: though?
09:41:16 <ttt_fff> what?
09:41:19 <ttt_fff> wtf are you talking about
09:41:23 <ttt_fff> wrong person?
09:41:29 <ttt_fff> nshepperd: ^^
09:41:57 <aweinstock> alexa_: possibly replace [1..] with [(1 :: Integer)..]
09:41:58 <nshepperd> ttt_fff: the (m a -> m a) -> (t m a -> t m a) thing
09:41:59 <ttt_fff> wtf ... https://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#v:hoist is balck magic
09:42:20 <nshepperd> ttt_fff: but now I realise it might be to restrictive since it has the forall a
09:43:29 <nshepperd> hoist has the right shape, but it will only work for you if you don't need to use the 'a' at all
09:46:01 <ttt_fff> unfortunately, I need the vlaue of the 'a'
09:47:15 <Welkin> alexa_: what is it you are trying to do exactly?
09:48:08 <alexa_> Welkin: going right -> left double the value of even position elements of the list
09:48:27 <alexa_> even in a 1-indexed manner
09:48:37 <Welkin> you can do that easier by building up a pipeline of functions
09:48:43 <Welkin> in a more finctional way
09:48:56 <Welkin> construct a list of functions to be applied over the wntire list
09:49:06 <Welkin> so, apply id to odd-indexed elements
09:49:12 <Welkin> and apply (*2) to even numbered ones
09:49:32 <alexa_> baby steps ;)
09:49:50 <alexa_> I'm learning very basic syntax at the moment, as well as how to understand compiler output etc
09:50:01 <alexa_> mastering FP is step 3 
09:50:02 <Welkin> > zipWith ($) (iterate [id, (*2)]) [1..10]
09:50:04 <lambdabot>      Couldn't match expected type ‚Äò[Integer -> c]‚Äô
09:50:04 <lambdabot>                  with actual type ‚Äòa0 -> [a0]‚Äô
09:50:04 <lambdabot>      Probable cause: ‚Äòiterate‚Äô is applied to too few arguments
09:50:15 <nshepperd> ttt_fff: can you turn your (m a -> m a) into (m (a,w,s) -> m (a,w,s))? the most general type of the hoist definition for RWS accepts that
09:50:39 <Welkin> > zipWith ($) (repeat [id, (*2)]) [1..10]
09:50:40 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> c‚Äô
09:50:40 <lambdabot>                  with actual type ‚Äò[Integer -> Integer]‚Äô
09:50:40 <lambdabot>      In the first argument of ‚Äòrepeat‚Äô, namely ‚Äò[id, (* 2)]‚Äô
09:50:52 <Welkin> oops
09:51:18 <thetallguy> Anyone hear of a bug introduced in 7.10 where GHC fails to recompile certain files that have had their dependencies change?
09:52:23 <Welkin> hm,what was that function to repeat a list infintely
09:52:28 <ttt_fff> nshepperd: I've stopped working on this, and accepted that I need something a bit more complex
09:52:51 <Welkin> :t concat . repeat
09:52:52 <lambdabot> [a] -> [a]
09:53:03 <Welkin> > zipWith ($) (concat . repeat $ [id, (*2)]) [1..10]
09:53:04 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
09:53:21 <Welkin> I was certain there was an existing function
09:53:28 <Welkin> :t replicate
09:53:29 <lambdabot> Int -> a -> [a]
09:53:41 <nshepperd> ah, ok
09:54:13 <nshepperd> :t cycle
09:54:14 <lambdabot> [a] -> [a]
09:54:18 <Welkin> ah
09:54:20 <Welkin> yes, cycle
09:54:22 <Welkin> thank you
09:55:27 <alexa_> Welkin: someone in another channel just showed me that baby, yeah
10:01:33 <aweinstock> alexa_: zipWith ($) (intersperse (*2) (cycle [id]))
10:02:45 <chpatrick> hmm
10:02:54 <chpatrick> do you know if IO computations can jump between OS threads?
10:02:58 <Phillemann> I'm trying to use decodeUtf8 from ClassyPrelude to decode from ByteString to Text. It tells me that he cannot deduce "Utf8 Text Data.ByteString.Lazy.Internal.Bytestring"
10:06:44 <davean> chpatrick: They can
10:06:58 <davean> chpatrick: You can use a bound thread to prevent it
10:13:22 <bergmark> Phillemann: it seems that type class only allows converting lazy text<->lazy bytestring and strict text<->strict bytestring
10:17:01 <thejsj> clear
10:21:56 <Phillemann> bergmark: Yes, thanks. I was able to fix it with a call to toStrict. :)
10:28:14 <GLM> If I have Prelude> let g = (\x -> x > 10)
10:28:14 <GLM> Prelude> let l = (\x -> x < 20), is there an easy way to combine l and g?
10:28:36 <chattered> liftA2 (&&)
10:28:43 <chattered> (or some other boolean operator)
10:29:11 <GLM> chattered: What would the actual code for the resulting function be?
10:29:28 <chattered> If you think of g and l as sets, then liftA2 is set intersection.
10:29:35 <mauke> :t let g = \x -> x > 10; l = \x -> x < 20 in liftA2 (&&) l g
10:29:36 <lambdabot> (Num a, Ord a) => a -> Bool
10:29:37 <chattered> Sorry, liftA2 (&&) is set intersection.
10:29:44 <chattered> liftA2 (||) is set union.
10:31:51 <GLM> I get the following error when I try that
10:32:06 <GLM> Prelude Control.Applicative> f [1..]
10:32:07 <GLM> <interactive>:21:1:
10:32:07 <GLM>     No instance for (Num [t0]) arising from a use of ‚Äòf‚Äô
10:32:07 <GLM>     In the expression: f [1 .. ]
10:32:07 <GLM>     In an equation for ‚Äòit‚Äô: it = f [1 .. ]
10:32:07 <GLM> <interactive>:21:3:
10:32:44 <chattered> > let g = \x -> x > 10; l = \x -> x < 20 in liftA2 (&&) l g 15
10:32:46 <lambdabot>  True
10:32:48 <chattered> > let g = \x -> x > 10; l = \x -> x < 20 in liftA2 (&&) l g 25
10:32:49 <lambdabot>  False
10:33:13 <mauke> GLM: that's because lists aren't numbers
10:33:25 <GLM> mauke:I have it working. I needed a filter
10:33:30 <GLM> Thanks all
10:33:36 <mauke> ah
10:34:06 <mauke> > filter (inRange (11, 19)) [1 .. 50]
10:34:08 <lambdabot>  [11,12,13,14,15,16,17,18,19]
10:34:52 <rrooij> Hello, I have a question. I want to start out a personal project and want to learn Haskell. I thought making the project in Haskell would be a good way of learning the language. It is a web application for managing your book collection
10:35:10 <rrooij> I'm searching a web framework similair to Symfony or Django
10:35:28 <mauke> @where web
10:35:28 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
10:35:55 <rrooij> JHah, I heard of those frameworks
10:36:01 <aszx> @where web
10:36:01 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
10:36:44 <solirc> alexa_: In principle yes, but you won't get source locations on failing expectations, so it may be hard to identify which `shouldBe` failed
10:36:59 <GLM> Are functions functors?
10:37:00 <solirc> alexa_: This will be fixed with the next version of GHC though :)
10:38:04 <chattered> GLM: Functions with a fixed domain form functors. So functions of Int form a functor. It's just the Reader monad.
10:38:27 <chattered> In Haskell, you can write it quite nicely as (->) Int
10:38:35 <GLM> chattered:So in the type sig of liftA2, f can be a regular function?
10:38:51 <mauke> :t liftA2
10:38:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:39:00 <alexa_> solirc: actually, I was getting info on which one failed, albeit only the first failure
10:39:03 <mauke> GLM: f = ((->) e)
10:39:05 <alexa_> solirc: I was pleasantly surprised
10:39:11 * hackagebot slack-api 0.5 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.5 (mpickering)
10:39:14 <mauke> GLM: so f a = ((->) e) a = e -> a
10:39:54 <GLM> mauke:That is really cool. I didn't know regular functions were functors. Are functions with infinite domains like string  functors as well?
10:40:09 <chattered> GLM: It's not a function, but a type. If you're thinking about functions from Int, then it's the type which takes in the codomain type a and gives you back Int -> a.
10:41:03 <mauke> GLM: the type constructor ((->) e) is an instance of Functor. it doesn't matter what e is
10:41:22 <chattered> GLM: Strings are List Char, and List is a functor.
10:41:30 <chattered> Sorry, [Char]
10:41:39 <chattered> (and [] is a functor)
10:42:17 <lamefun> https://wiki.haskell.org/Iteratee_I/O#The_problem_with_lazy_I.2FO - can stuff like this be statically avoided?
10:43:41 <aszx> whats a good way to use liftA2?
10:43:52 <aszx> or applicative
10:44:01 <mauke> that question seems backwards
10:44:12 * hackagebot doctest 0.10.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.10.1 (SimonHengel)
10:44:30 <chattered> aszx: If you find yourself doing a pattern like do { x <- foo; y <- bar; return f x y }, then you could replace it with just liftA2 f foo bar.
10:45:19 <chattered> I like to use them a lot, as well as <$> and <*>.
10:46:05 <aszx> it looks like you could write a whole program with them
10:46:45 <kadoban> You indeed can write many things with Applicative. I love it for parsing, it's super easy to write and understand IMO.
10:49:45 <Hi-Angel> I just noticed a weird thingÖ Why doesn't it work: ´let {foo :: a -> b; foo x = x}ª? The thing to note is that declaration says the argument and the return types to be different, but in implementation they're the same. And this is weird ó e.g. in math "a" and "b" MIGHT be the same; that's like an optionality for the requirement to be the same.
10:50:08 <mauke> because the caller gets to choose the types
10:50:27 <Zemyla> Hmm, I'm wondering if there's a way to package a Read and a Show in the same data type so they can be manipulated using the same tools?
10:50:28 <LeoTal> The definition has to be valid forall a, forall b
10:50:32 <mauke> e.g. I could say I want to use foo at type Int -> String, and the type signature would let me (with a = Int, b = String)
10:50:40 <mauke> but the code wouldn't work
10:53:39 <nadirs> I'm getting the error "could not find module (...) it is a member of the hidden package ..." even though I've added that package in my .cabal file
10:53:49 <nadirs> could the fact I'm using 7.10 be a problem?
10:54:05 <mauke> added where?
10:54:15 <Zemyla> Like, prepending a string, adding parentheses, or concatenating two?
10:54:17 <nadirs> in the build-depends
10:55:33 <nadirs> I'm in a sandbox using ghc 7.10 and cabal 1.22
10:59:58 <greymalkin> nadirs: Did you restart the ghci session?
11:00:34 <nadirs> greymalkin: this is happening outside ghci, e.g. when I "cabal build"
11:01:00 <greymalkin> Just a guess, try a cabal install instead (it won't actually place it outside the sandbox)
11:01:44 <greymalkin> I'm not sure what part of the 'cabal install' does it, but every time I add a new dependency, I run that first (even if my own code won't compile) to update the dependencies.
11:04:30 <Hi-Angel> Here's an error example ´let {foo :: a -> b; foo x = [x]}ª. Why do ghci think that ´[a]ª isn't actually of type ´bª? It is obviously different type of ´aª.
11:05:03 <Hi-Angel> @let {foo :: a -> b; foo x = [x]}
11:05:03 <lambdabot>  .L.hs:146:9:
11:05:04 <lambdabot>      Couldn't match expected type ‚Äòb‚Äô with actual type ‚Äò[a]‚Äô
11:05:04 <lambdabot>        ‚Äòb‚Äô is a rigid type variable bound by
11:05:14 <geekosaur> Hi-Angel, "b" there does not mean you get to choose the b
11:05:16 <shachaf> Hi-Angel: The answer is the same as before.
11:05:20 <geekosaur> it means whatever calls foo gets to choose it
11:05:21 <mauke> Hi-Angel: my original answer still applies
11:05:37 <shachaf> Hi-Angel: The consumer chooses what a and b are. I can choose that foo :: Int -> Bool if I want, and your foo still has to work.
11:05:47 <Cale> Hi-Angel: [x] is clearly a list, b is not.
11:05:59 <nadirs> greymalkin: no luck. The first thing I did was "cabal install --dependencies-only" which completed successfully but the packages cannot be imported nonetheless
11:06:22 <Hi-Angel> Okay, thank youÖ
11:06:36 <greymalkin> nadirs: drop the sandbox and recreate?
11:06:58 <greymalkin> Make sure the version number of the hidden package is the same as the one in the cabal file?
11:07:54 <nadirs> greymalkin: the strange thing is that no package is actually hidden (hc-pkg list should show them inside parentheses if they are hidden, right?)
11:09:06 <bergmark> nadirs: i think that's broken packages, if it's hidden it's colored gray
11:09:45 <nadirs> bergmark: oh ok. And what does blue mean?
11:10:01 <nadirs> ghc-7.10.1 appears blue
11:10:30 <bergmark> maybe gray is blue for you ;-)
11:10:47 <bergmark> you can test by ghc-pkg hide'ing something
11:12:33 <nadirs> bergmark: oh no! You're right
11:12:46 <nadirs> I've no idea why ghc is hidden
11:12:59 <geekosaur> it is by default
11:13:30 <geekosaur> basically you need to explicitly request access to compiler internals
11:14:22 <nadirs> geekosaur: so it's not a strange thing
11:14:24 <nadirs> ?
11:14:35 <geekosaur> not strange, no.
11:15:24 <geekosaur> haskell2010 and haskell98 are also hidden by default (otherwise they'd conflict with base)
11:16:21 <geekosaur> (and fwiw hidden packages show blue here as well. mate-terminal)
11:17:10 <nadirs> I think I found the problem
11:17:36 <nadirs> in my .cabal file I had library's exposed-modules set to just some custom modules
11:17:58 <nadirs> maybe that was hiding everything else
11:19:14 * hackagebot tpdb 1.2.0 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-1.2.0 (JohannesWaldmann)
11:24:38 <Hi-Angel> So, in fact it impossible to declare an instance of such a function ´class Foo a where {foo :: a -> b}ª isn't it?
11:27:10 <glguy> You'd be able to make an instance of Foo for Void
11:27:53 <mauke> foo _ = undefined
11:28:31 <aweinstock> :t Unsafe.Coerce.unsafeCoerce
11:28:32 <lambdabot> a -> b
11:28:43 <aweinstock> (may cause segfaults)
11:29:00 <marchelzo_> :t const undefined
11:29:01 <lambdabot> b -> a
11:29:54 <aweinstock> Hi-Angel: these are the sort of things that (a -> b) looks like (since there isn't a meaningful fully general conversion between arbitrary types)
11:29:55 <mauke> :t flip undefined
11:29:56 <lambdabot> b -> a -> c
11:30:10 <aweinstock> :t uncurry undefined
11:30:11 <lambdabot> (a, b) -> c
11:30:14 <mauke> :t flip undefined const
11:30:15 <lambdabot> a -> c
11:30:43 <aweinstock> :t curry undefined
11:30:45 <lambdabot> a -> b -> c
11:31:11 <aweinstock> :t Unsafe.Coerce.unsafeCoerce undefined
11:31:13 <lambdabot> b
11:31:34 <azsx> is haskell good for smartphone programming
11:31:43 <azsx> stable
11:31:57 <marchelzo_> no
11:32:40 <Hi-Angel> Why not?
11:32:56 <tzaeru> Hi-Angel, AFAIK there aren't really any complete integration solutions for getting haskell to run on say, iphone
11:33:23 <adnausea1> http://keera.co.uk/blog/category/haskell-2/
11:33:32 <Hi-Angel> Wow, 16 seconds o.O It was really fast
11:33:37 <adnausea1> you'll have to build your own dev environemnt, it's not impossible 
11:33:44 <marchelzo_> People have done it, but it really doesn't compare to Obj-C for ios or Java for android.
11:33:55 <marchelzo_> It isn't ideal.
11:34:09 <aweinstock> if it's possible to run C programs on smartphones, it's probably possible to use the Haskell FFI to run Haskell programs on smartphones (with some effort)
11:34:20 <tzaeru> okay. I haven't thus far seen an iphone software written in haskell tho
11:34:28 <adnausea1> if it's a hobby, go for it. if you're in ac company and time is money, then it might be  awaste of time if the know how is not sufficient 
11:34:44 <tzaeru> probably if the practical question is "how to do software fastest for iphone?", the right answer is definitely not "haskell!" though
11:35:04 <aweinstock> marchelzo_: how easy is it to integrate non-Java JVM languages with Android?
11:35:55 <tzaeru> ugh, the "speeding up haskell game on android" blog post thing is one of the weirdest things I've seen as a software and game developer :P
11:36:33 <tzaeru> because well, um.. well. you need.. parallelism to get a straight arkanoid clone to acceptable frame rates? oookaay.
11:36:35 <marchelzo_> aweinstock: I have no idea.
11:36:58 <adnausea1> did haskell-chat disappear ? 
11:37:26 <srhb> tzaeru: Yeah, and furthermore it was low on implementation details. I'm very saddened by the (non-) state of Haskell on Android.
11:37:28 <adnausea1> i've a non haskell question regarding regular grammars.. i'm being a bit obtuse about a tiny detail 
11:38:05 <tzaeru> srhb, yeah.
11:38:08 <tzaeru> guess it's still a start though
11:38:30 <tzaeru> the good thing with slow development of some things for Haskell is that I've more time to catch on learning Haskell before actually needing it for anything ^,^
11:38:39 <Welkin> I think one of the reasons is that ios/android APIs suck to work with
11:38:42 <geekosaur> aweinstock, several years ago I looked into how they were integrating clojure... not difficult but made annoying by large runtimel ibraries needed
11:38:44 <Welkin> the ecosystems are a nightmare
11:38:45 <adnausea1> ah, it's -blah, not chat, my bad ignore the lsat question 
11:38:45 <jacksnipe> adnausea1: what's the question?
11:38:51 <jacksnipe> oh
11:39:07 <adnausea1> jacksnipe: i'm wondering if a regular grammar can have productions of the form S-> 0A | 0B 
11:39:29 <tzaeru> Welkin, they do, iOS is particularly bad. you'll need xcode and os x for iOS development.
11:39:51 <adnausea1> i know the productions resolve nondeterminstically, but are the rules allowed to be? i can't find it anywhere. i doesn't seem to be forbidden 
11:39:52 <jacksnipe> adnausea1: is 0 the empty string here? If so, then no
11:39:56 <Welkin> so no one wants to touch itt
11:39:57 <adnausea1> it's a literal 
11:40:05 <srhb> Welkin: Agreed. Still, plenty of frameworks tend to work around this. JUst not in our ecosystem :)
11:40:10 <Welkin> there is a lot of activity in the haskell -> javascript area though
11:40:11 <srhb> Welkin: And while understandable it's still sad.
11:40:32 <jacksnipe> adnausea1: that's not allowed, for exactly that reason
11:40:44 <jacksnipe> adnausea1: too hard to parse, makes it a CFG
11:40:51 <aweinstock> the regular expression "0[AB]" corresponds to that (unless A and B are arbitrary nonterminals?)
11:40:51 <tzaeru> doesn't really matter what your framework is, iOS is still pain in the bottom @_@ even with likes of Unity you need xcode. there's no going around it
11:40:53 <adnausea1> rgr! 
11:41:10 <tzaeru> while I wouldn't know the exact details, I've been under the impression that there are legal barriers to going around it too.
11:41:11 <jacksnipe> oh I thought A and B were non-terminals
11:41:43 <adnausea1> capital letters  is the rule for non-terminals, everything else is a teminal bar epsilon
11:41:44 <aweinstock> so {S -> 0A | 0B; A -> a; B -> b} works if A and B are non-terminals, but not arbitrary nonterminals
11:41:53 <adnausea1> which is the empty string
11:42:02 <aweinstock> (so, the production doesn't force the grammar to be irregular)
11:42:09 <adnausea1> sweet 
11:42:45 <adnausea1> thanks guys! 
11:50:12 <Vektorweg1> Is memoization still working when the data is shared via MVar?
11:50:30 <mauke> what memoization?
11:50:41 <srhb> Vektorweg1: That's a bit of a weird question. The concepts are orthogonal.
11:51:59 <Vektorweg1> i dont know. maybe ghc does some unmagic in some cases.
11:52:23 <mauke> ghc doesn't memoize
11:52:52 <Vektorweg1> mauke: ghc compiles the code that might memoize ...
11:53:10 <zovt> Can GHC options be set in a stack.yaml file?
11:56:22 <schlicht_> oh god, its so fun to have a good typechecker again :D and I only started 15minutes ago
11:57:48 <GLM> Would Haskell be a good option for crpyto work?
11:59:32 <c_wraith> Vektorweg1: you should assume ghc only memoizes expressions that are named, when the name is shared.  let x = f 10 in (x, x) -- x is memoized, not the call to f 10
12:10:03 <greenskeleton> hello all. hopefully someone here can make a quick edit. I noticed a small typo for https://www.haskell.org/platform/linux.html#binary - the path should contain "x86_64" instead of "x86-64"
12:11:53 <MarcelineVQ> says _ for me
12:12:07 <greymalkin> Is there any precedent for reading from multiple TChan?
12:12:59 <MarcelineVQ> greenskeleton: do you mean here sudo /usr/local/haskell/ghc-7.8.3-x86-64/bin/activate-hs ?
12:13:47 <greenskeleton> MarcelineVQ: yes
12:16:04 <MarcelineVQ> you are corrrect, that is a typo, I wonder who to contact about that
12:18:02 <hexagoxel> nadirs: i find it more likely that you needed a `cabal configure`. `cabal install` does a separate configuration that won't affect `build`
12:21:19 <mlrutherford> Hey guys! Are there any good resources for Haskell specifically for someone who has a Lisp/Scheme background?
12:21:46 <fryguybob> greymalkin: I'm not sure what you are asking.  Just read from each one, one by one?
12:22:55 <greymalkin> I was thinking of using one TChan for messages from a user, and one TChan for messages from a device -- reading the next available message from either and then tagging it as either 'FromDevice a' or 'FromUser UserId a'
12:23:12 <hexagoxel> the interesting case would be blocking until there is new stuff in at least one TChan
12:23:16 <mauke> :t orElse
12:23:18 <lambdabot> Not in scope: ‚ÄòorElse‚Äô
12:23:44 <greymalkin> mauke: That's where I was headed without any input.
12:23:47 <mauke> fmap Left foo `orElse` fmap Right bar
12:24:17 * hackagebot pandoc 1.15.0.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.5 (JohnMacFarlane)
12:38:23 <Hi-Angel> What is the right way to declare a type like ¬´newtype Header = Header [String]¬ª to be an instance of Functor? The problem is that the ¬´Functor¬ª want type kind of ¬´* ‚Üí *¬ª. I can make a workaround by redeclaring it as ¬´newtype Header a = Header [String]¬ª, but then there would be this non-sensical ¬´a¬ª type :/
12:38:25 <mindless_null> Which is preferred: 'zip xs ys', or 'xs `zip` ys'?
12:38:53 <nadirs> hexagoxel: I tried them all. The problem was maybe another: In my .cabal I put both a library block and an executable block, but I filled the build-depends of just the executable block
12:39:44 <jomg> Hi-Angel, why do you want a functor instance for that type?
12:40:56 <greymalkin> mauke: Beautiful; that works exactly the way I was hoping it would.  Thanks for the validation :)
12:42:11 <Hi-Angel> jomg, well, it is a list of String, with every of which I want to work separately. In principle I can use the usual ´mapª with pattern matching, but I think that for that type it would be an usual operation, and would be better to throw away the pattern matching.
12:43:18 <jomg> Hi-Angel, you'd need to define your own map function of type (String -> String) -> Header -> Header
12:44:45 <Hi-Angel> Oh, no, a separate function, I think, would be even worse than just a pattern matching every time :/
12:44:46 <jomg> your workaround wouldn't work here, because you can't apply a function of type (a -> b) to a Header or its contents in any way
12:45:16 <jomg> (for some a and b besides String, that is)
12:47:54 <jomg> if you really want to have a functor instance, you'd need to have either newtype Header a = Header [a] or just operate on the underlying list directly
12:48:30 <mauris> hi, how do i install base-4.8.0.0?
12:48:43 <mauris> "cabal install base" just tells me i already have an old version (base-4.7.0.1)
12:49:01 <hexagoxel> mauris: install ghc-7.10
12:49:23 <kadoban> mauris: 'base' comes with GHC and isn't separately installable.
12:49:29 <mauris> i see
12:49:36 <mauke> your base is under a tack
12:49:56 <kadoban> It'd be kinda useful if base version numbers looked more like GHC version numbers ‚Ä¶
12:50:53 <mauris> i guess a new Haskell Platform is on its way? is ghc 7.10 "experimental"?
12:50:59 <Hi-Angel> Ah, indeed, I am confused, aaaah, how it is hardÖ I feel like I am learning a programming from the very start again :'-(
12:52:30 <kaste> in a way you are
12:53:50 <Welkin> mauris: 7.10 has a major bug on osx
12:53:54 <Welkin> er
12:53:56 <Welkin> 7.10.1
12:54:04 <Welkin> 7.10.2 fixes it
12:54:28 <Welkin> mauris: you don't need the platform though
12:54:36 <mauris> i see
12:54:36 <Welkin> you can just install ghc + cabal-install
12:54:38 <jbalint> I have a build error on sexpr package with cabal. http://pastebin.com/hH2aeXk5 is there somewhere I can edit the source and then cabal install it?
12:54:51 <Welkin> then install everything you need using cabal
12:55:09 <mauris> i was just wondering why the haskell platform is still offering an "old" version of ghc
12:55:45 <Welkin> mauris: it lags behind quite a bit
12:55:50 <mauris> it's not discontinued, or anything, right? just lagging behind?
12:55:51 <mauris> ah :)
12:55:56 <Welkin> it is just an option for newcomers really
12:56:32 <Welkin> although I am still using 7.8.4 because of the previously mentioned problems with 7.10.1
12:56:56 <GLM> Has anyone used Haskell for Crypto before?
12:57:15 <Welkin> GLM: there are several crypto libraries
12:57:30 <geekosaur> the next HP release got delayed because of 7.10.1 bugs. it is being tested concurrently with 7.10.2 RCs and they hope to release within a couple days of 7.10.2 final
12:57:51 <Welkin> https://wiki.haskell.org/Applications_and_libraries/Cryptography
12:58:07 <GLM> Welkin:Much appreciated
12:59:23 <jomg> does anyone know what exactly (<$!>) from Control.Monad does that makes it require a monad constraint (rather than just functor)?
12:59:54 <lpaste> lamefun pasted ‚ÄúWhy does that work and this doesn't?‚Äù at http://lpaste.net/136292
13:01:31 <mauris> can i ask GHCi about the precedence of an operator?
13:01:48 <Clint> mauris: :i
13:02:06 <geekosaur> lamefun, hGetContents uses evil behind the scenes to do lazy I/O. yours is strict.
13:02:49 <kadoban> jomg: The source is pretty short and seems to make some sense. https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Monad.html#%3C%24!%3E
13:02:55 <lamefun> Why isn't my hGetContents lazy?
13:03:06 <geekosaur> because IO is strict
13:03:26 <geekosaur> hGetContents uses a thing called unsafeInterleaveIO to introduce laziness
13:03:46 <mauris> Clint: thanks!
13:03:52 <geekosaur> but that laziness means that withFile has (strictly) closed the file by the time you try to use the data
13:04:31 <jomg> kadoban, i read it, but wouldn't this be equivalent? f <$!> x = fmap (\ y -> y `seq` f y) x
13:05:05 <lamefun> So I'm not supposed to close the file I used hGetContents on? Will it close it automatically when done?
13:05:07 <geekosaur> so the unsafeInterleaveIO finds that the file is closed and produces an empty string. your version does not use unsafeInterleaveIO and therefore reads the whole string at once, while still "inside" withFile, so it works
13:05:15 <geekosaur> it will close automatically, yes
13:05:29 <geekosaur> you should do nothing to or with the filehandle after you hGetContents on it
13:06:01 <geekosaur> you can think of hGetContents as spawning a background thread of sorts that takes control of the handle
13:06:05 <jomg> kadoban, oh, i think i understand now
13:06:15 <geekosaur> and reads from it lazily as you demand data from the returned string
13:06:49 <kadoban> jomg: Heh, I'm not sure I do fully. I'll have to look at it in a bit
13:06:58 <Wizek> Good Morning!
13:07:36 <jomg> kadoban, seq-ing z after the let probably also evaluates the whole application of (>>=)
13:07:45 <tabacof> Hello, I'm day 2 beginner and I'm having some trouble with the speed of a function I wrote: http://pastebin.com/6t3MCRmA It's just unbearably slow, even with optimization, so I believe I must be doing something wrong. Do you guys have any suggestions?
13:08:40 <jomg> kadoban, whereas my version would still create a thunk and will only apply the function strictly once the result of the computation is actually needed
13:09:39 <mauke> tabacof: holy shit, you keep calling length over and over again
13:09:56 <geekosaur> worse, calling contains over and over again
13:10:04 <mauke> tabacof: and contains a b and contains b a
13:10:28 <tabacof> I thought this would be optimized out
13:10:30 <mauke> tabacof: btw, contains should totally use pattern matching
13:11:18 <mauke> also, don't you want to use sets instead?
13:12:15 <Wizek> Is there a template haskell tool or similar that would allow me to print/dump a few local bindings with their names? e.g. `let x = 1 in print [dump|x, x+1|]` would print "x=1, (x+1)=2"
13:12:22 <tabacof> @mauke I'm not sure I can, I'm following some exercises (from exercism.io) and it requires a list as input
13:12:22 <lambdabot> Unknown command, try @list
13:12:38 <mauke> tabacof: you can construct a set from a list
13:13:26 <tabacof> mauke: Ok, I gonna link into that. Also, what is an elegant way to avoid repetition? If it were an imperative language I would just declare comparison variables, but this seems fishy here
13:15:03 <Welkin> can't you do that with ghci?
13:16:53 <Wizek> http://stackoverflow.com/questions/31349556/is-there-a-template-haskell-library-that-would-allow-me-to-print-dump-a-few-lo
13:19:21 * hackagebot smoothie 0.3.3 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.3.3 (DimitriSabadie)
13:47:18 <zipper> What does FPHC mean?
13:55:17 <srhb> zipper: FP Haskell Center?
14:07:56 <Zemyla> I just thought of some weird concept that I'm not sure makes much sense.
14:08:01 <Zemyla> A cofunctor transformer.
14:08:19 <Zemyla> *contrafunctor transformer.
14:10:34 <phaazon> Zemyla: isn‚Äôt that in mmorph yet?
14:14:23 * hackagebot smoothie 0.3.3.1 - Smooth curves via several interpolation modes  http://hackage.haskell.org/package/smoothie-0.3.3.1 (DimitriSabadie)
14:14:25 * hackagebot tubes 0.2.2.3 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.2.3 (gatlin)
14:15:22 <Zemyla> And I just looked up contravariant transformers, and I got results on Google for shipping contravariant transformers to China.
14:15:35 <kadoban> Nice
14:16:40 <phaazon> oh god
14:16:42 <phaazon> The tarball entry 'smoothie-0.3.3.2/' has a file timestamp that is in the
14:16:43 <phaazon> future (2015-07-10 21:15:55 UTC).
14:16:46 <phaazon> not that bug again‚Ä¶
14:16:54 <phaazon> looks like trying again solved it 
14:16:56 <phaazon> weird.
14:17:06 <Zemyla> Also, I've got a profunctor instance that doesn't seem to fall under any of the other typeclasses in the profunctor package.
14:17:27 <glguy> phaazon: Are you cetain that that was in the future?
14:17:44 <phaazon> nope :D
14:17:51 <glguy> Looks like it is "Fri Jul 10 21:17:21 UTC 2015" nowish
14:18:10 <Zemyla> It's basically P a b = P (ShowsPrec a) (ReadPrec b), and it's a law-abiding profunctor, but none of the other typeclasses are useful with it.
14:18:14 <phaazon> my system is synchronized with ntp
14:18:18 <phaazon> to ntp.nasa.gov
14:18:19 <phaazon> :‚Äì‚Äô
14:18:49 <glguy> Oh, the bug was that it reported that it was in the future, not that it was a future date?
14:19:12 <Zemyla> However, I can define (&&&) :: P a b -> P c d -> P (a, c) (b, d) and (|||) :: P a b -> P c d -> P (Either a c) (Either b d).
14:19:19 <phaazon> you have all the error above glguy :/
14:19:23 * hackagebot smoothie 0.3.3.2 - Smooth curves via several interpolation modes  http://hackage.haskell.org/package/smoothie-0.3.3.2 (DimitriSabadie)
14:19:28 <phaazon> I don‚Äôt know any more than you
14:19:31 <phaazon> that‚Äôs just weird
14:19:52 <phaazon> btw, I think we should really find a way to add the haddock building to cabal upload
14:19:52 <Zemyla> And neither of those seem to appear anywhere in the Profunctor package.
14:20:10 <phaazon> Zemyla: (&&&) is for Arrow
14:20:13 <phaazon> not Profunctor
14:20:31 <shachaf> That's a different (&&&).
14:20:42 <Zemyla> Well, yes, and I chose the wrong symbol (it should be ***, not &&&), but there's no way to make an Arrow instance of it either.
14:21:02 <Zemyla> Nor even a category (I mean, what the hell would id be, much less (.)?)
14:21:54 <phaazon> yeah, isn‚Äôt (&&&) a fadein?
14:21:55 <int-e> phaazon: I expect that the timestamps in the tar file are generated by whoever uploads the package.
14:22:01 <phaazon> :t (&&&)
14:22:02 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:22:06 <Zemyla> Yeah, it should be ***.
14:22:07 <phaazon> yeah, fadein
14:22:08 <Zemyla> :t (***)
14:22:10 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:22:23 <Zemyla> :t (|||)
14:22:24 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
14:22:41 <Zemyla> :t (+++)
14:22:43 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
14:22:45 <int-e> (but perhaps the hackage server could check for this.)
14:22:50 <Zemyla> So it should be (+++) and (***).
14:22:53 <phaazon> Zemyla: have you checked Choice?
14:23:28 <phaazon> :t left'
14:23:29 <lambdabot> Choice p => p a b -> p (Either a c) (Either b c)
14:23:42 <phaazon> don‚Äôt remember the functions for (|||) and (+++) though
14:23:44 <Zemyla> Yeah, that's the exact wrong thing.
14:24:15 <Zemyla> This profunctor doesn't pass values through, which makes almost all the functions in the profunctor package pointless.
14:24:19 <phaazon> @hoogle Choice
14:24:19 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
14:24:19 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
14:24:19 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
14:24:45 <phaazon> oh it‚Äôs in Data.Profunctor
14:25:16 <phaazon> my god
14:25:24 <phaazon> Costrong is actually stupid
14:25:37 <phaazon> but I don‚Äôt understand the primitives
14:25:43 <phaazon> oh nevermind, I¬†do
14:27:32 <phaazon> A Profunctor p is Representable if there exists a Functor f such that p d c is isomorphic to d -> f c.
14:27:36 <phaazon> edwardk is an alien.
14:29:29 <shachaf> What? What's wrong with that definition?
14:29:52 <hodapp> those two statements weren't necessarily connected
14:29:56 <Clint> the definition of edwardk
14:30:46 <phaazon> shachaf: well
14:31:22 <phaazon> it might look like a bit overhelming at the first sight :)
14:34:24 * hackagebot git-annex 5.20150710 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150710 (JoeyHess)
14:44:34 <catgocat> Can anyone help me here? I'm getting an error with this code: solution n = 3/2*((n-n`mod`3)+3)
14:46:57 <srhb> :t (/)
14:46:58 <lambdabot> Fractional a => a -> a -> a
14:46:59 <srhb> :t mod
14:47:01 <lambdabot> Integral a => a -> a -> a
14:47:51 <srhb> catgocat: mod works on Integrals, (Int, Integer, ...) while (/) works on Fractionals (Float, Double, ...)
14:48:44 <srhb> catgocat: you could fromIntegral the paranthesized expression to make the types match, for instance.
14:49:20 <srhb> > let solution n = 3 / 2 * fromIntegral ((n - n `mod` 3) + 3) in solution 10
14:49:22 <lambdabot>  18.0
14:55:11 <Wizek> http://stackoverflow.com/questions/31350897/is-it-possible-to-pipe-source-code-to-ghc-through-stdin
15:01:30 <joe9> program: http://codepad.org/qrZ7T4Wb , error:  http://codepad.org/TQUBjVO8 . any suggestions on how to fix it , please?
15:01:31 <catgocat> srhb: how do I return an integer?
15:01:59 <srhb> catgocat: Perhaps you want to use `div` instead of (/) or something similar. Or maybe you want to convert the end result with floor, ceil or something similar.
15:02:00 <felixn> (>>) is to sequence, as (>>=) is to ... ? :)
15:02:22 <catgocat> srhb: the result is an integer, but I need 3/2
15:02:50 <srhb> catgocat: 3/2 is not an Integer, and the result of what I wrote is not an Integer, so I don't understand what you are writing.
15:03:21 <catgocat> srhb: the result from the all operation is suposed to be an integer, without the fractional part 18.0 -> 18, 17.0 -> 17
15:03:37 <srhb> catgocat: Then you can use floor or something
15:03:40 <srhb> :t floor
15:03:41 <lambdabot> (Integral b, RealFrac a) => a -> b
15:03:47 <srhb> Oh, no.
15:03:51 <ronh> catgocat div is integral division
15:04:07 <catgocat> solution n = floor $ 3/2*fromIntegral((n-n`mod`3)+3)
15:04:12 <catgocat> Works fine but isn't there anything smaller?
15:04:20 <ronh> (didn't follow from the beginning so I have no idea if that is what you wanted)
15:04:56 <srhb> catgocat: It really depends on what result you're trying to achieve. You might want to just use div instead of (/) and get rid of the fromIntegral.
15:05:13 <srhb> > let solution n = 3 `div` 2 * ((n - n `mod` 3) + 3) in solution 10
15:05:14 <lambdabot>  12
15:05:32 <srhb> If you need the intermediate result of 3/2, then you need floor or something.
15:05:51 <catgocat> @srhb but that doesn't return the result I want, because I need 3/2 there, 3 `div` 2 * 9 is not the same as 3/2 * 9
15:05:51 <lambdabot> Source not found. I am sorry.
15:06:02 <srhb> catgocat: Yes, I am aware. 
15:06:14 <mauke> catgocat: 3 * 9 `div` 2
15:07:17 <catgocat> solution n = (3*((n-n`mod`3) + 3))`div`2
15:07:19 <catgocat> this worked ^
15:07:28 <catgocat> god been trying for over 1 hour
15:08:09 <mauke> is this a bucketing thing?
15:08:21 <joe9> can anyone please help with this:  program: http://codepad.org/qrZ7T4Wb , error:  http://codepad.org/TQUBjVO8
15:08:55 <mauke> joe9: Just (x : xs)?
15:09:36 <joe9> mauke, thanks . sorry.
15:10:04 <ttt_fff> should I use Foreach or ForEach ?
15:10:12 <ttt_fff> i.e. should the word Each be capitalized ?
15:14:29 <Haskellfant> ttt_fff: imho ForEach is nicer, but it's obviously a matter of preference
15:15:25 <adarqui> what do you guys use to analyze haskell source code? for visual dependency graphs of modules/functions etc?
15:15:28 <maerwald> ttt_fff: for_each xD
15:15:29 <adarqui> stuff like that
15:15:50 <adarqui> ttt_fff: for a function? forEach ..
15:15:59 <ttt_fff> for a datatype
15:16:15 <adarqui> oo, ForEach
15:16:28 <mauke> ‚àÄ
15:16:34 <maerwald> adarqui: I asked that question a few days ago, but seems there is nothing really
15:17:20 <adarqui> maerwald: ah, no responses? there's SourceGraph which fails to compile, but looks promising.. could try and get it to compile I guess.. there's also graphmod which looks good for the module dependencies.
15:17:56 <adarqui> i'm reading this "algebra" library and I think I need to generate some visual dependencies of this code so I can grasp everything faster
15:19:13 <ttt_fff> adarqui: is this symbolic algebra, i.e. computer algebra system?
15:20:52 <adarqui> ttt_fff: type level algebra i guess.. ie groups/rings/additive/multiplicative type classes/instances
15:21:00 <adarqui> check it: https://github.com/ekmett/algebra
15:21:29 <ttt_fff> oh; you're fucked
15:21:42 <ttt_fff> I heard reading ekmett code is like looking at the sistine chapel and trying to learn how to paint
15:21:58 <adarqui> nah, i've learned so much by reading his code :)
15:22:28 <adarqui> obviously i'm not reading some of his alien libs yet but.. for example, algebra & keys are great libs to read for noobs
15:34:30 <Vektorweg1> i use a new package in my cabal-based project. how can i update my dependency list without manually editing the cabal file? 
15:35:58 <michaelt> Vektorweg1: I think you have to edit it. You could delete it and have cabal init write a new one. 
15:36:06 <michaelt> Vektorweg1: or maybe I'm not following ...
15:36:33 <Vektorweg1> michaelt: i think there is a simple command for it. maybe.
15:36:57 <michaelt> Vektorweg1: hm, maybe ... I'm out of date for sure ...
15:41:50 <catgocat> http://chat.stackoverflow.com/rooms/83002/haskell-room
15:42:03 <catgocat> if anyone wanna chat in chat.stackoverflow ^
15:43:53 <Vektorweg1> catgocat: lol. 
15:44:58 <adarqui> irc > *
15:45:03 <adarqui> 8|
15:46:10 <Vektorweg1> adarqui: actually irc lacks several features. maybe not that necessary, but i could be better.
15:46:16 <Vektorweg1> *it
15:46:36 <Vektorweg1> e.g. fix typos later.
15:46:50 <adarqui> relax, immutability!
15:47:00 <glguy> There are limits what the "*" in "irc > *" can quantify over. Surely "irc" itself is out.
15:47:46 <Vektorweg1> adarqui: simulate state!
15:49:24 <Vektorweg1> glguy: an it isn't said whats compared here.
15:56:48 <jle`> Data.Map has an uncons, neat
15:56:58 <jle`> i guess you can use it to use it as a priority queue
15:57:00 <jle`> that or Data.St
15:57:03 <jle`> *Data.Set
15:57:54 <jle`> ah yeah, i guess with Data.Set you get a priority queue w/ ArgMin from Data.Semigroups
15:58:12 <jle`> you get a priority queue where you can pop from both the lowest priority end or the highest priority end
16:16:17 <Zemyla> :t liftA2 (,)
16:16:18 <lambdabot> Applicative f => f a -> f b -> f (a, b)
16:16:21 <Zemyla> :t divide id
16:16:22 <lambdabot> Not in scope: ‚Äòdivide‚Äô
16:16:41 <Zemyla> Hmm, so Contravariants aren't loaded?
16:17:10 <jle`> @let import Data.Functor.Contravariant
16:17:11 <lambdabot>  Defined.
16:17:59 <adarqui> checking out haskell-src-meta, looks nice for parsing haskell source
16:18:08 <Zemyla> @let import Data.Functor.Contravariant.Divisible
16:18:09 <lambdabot>  Defined.
16:18:15 <Zemyla> :t divide id
16:18:16 <lambdabot> Divisible f => f b -> f c -> f (b, c)
16:19:18 <Zemyla> :t \l r -> Left <$> l <|> Right <$> r
16:19:19 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
16:19:26 <Zemyla> :t choose id
16:19:27 <lambdabot>     Ambiguous occurrence ‚Äòchoose‚Äô
16:19:27 <lambdabot>     It could refer to either ‚ÄòData.Functor.Contravariant.Divisible.choose‚Äô,
16:19:27 <lambdabot>                              imported from ‚ÄòData.Functor.Contravariant.Divisible‚Äô at /home/lambda/.lambdabot/State/L.hs:88:1-43
16:19:31 <Zemyla> :t chosen
16:19:32 <lambdabot>     Ambiguous occurrence ‚Äòchosen‚Äô
16:19:32 <lambdabot>     It could refer to either ‚ÄòControl.Lens.chosen‚Äô,
16:19:32 <lambdabot>                              imported from ‚ÄòControl.Lens‚Äô at /home/lambda/.lambdabot/State/L.hs:48:1-43
16:19:47 <glguy> You can experiment with lambdabot in /msg
16:19:51 <adarqui> how many libraries are loaded into lambdabot?
16:20:16 <Zemyla> Yeah. I'm just figuring out how Applicative/Divisible and Alternative/Decidable are linked.
16:21:09 <shachaf> I don't think anyone said you shouldn't figure it out, just that /msg might be more appropriate. :-)
16:32:35 <felixn> is there a function for this?  I can't seem to find it in hoogle, but it feels like it should be common enough to be in there
16:32:37 <felixn> > let maybePred pred = find pred . (: []) in maybePred (>= 0) 123
16:32:39 <lambdabot>  Just 123
16:34:06 <shachaf> [x | p x]?
16:34:12 <shachaf> With MonadComprehensions.
16:34:29 * hackagebot haxr 3000.11.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.11.1 (BrentYorgey)
16:36:18 <Geraldus> hi friends! I have a silly question: is there a way to force rendering unicode glyphs in string literals in GHCi? 
16:36:55 <byorgey> Geraldus: no
16:37:12 <Geraldus> byorgey: thank you
16:39:29 <adarqui> shachaf: didn't know baout that, really cool
16:39:34 <adarqui> [ x | x <- Just 123, x > 0 ]
16:39:35 <adarqui> Just 123
16:40:00 <shachaf> That's another option, I suppose.
16:40:39 <shachaf> I was thinking of [x | x > 0]
17:13:45 <kori> I have a weird problem, it's not really related to haskell. I need to build cabal and discard everything related to the build process. There can't be anything that isn't discarded except for the binary and things that the binary may need.
17:17:56 <michaelt> kori, it should work. Certainly I've kept my cabal-install from one installation to the next.
17:18:14 <kori> michaelt: the thing is, I'm packaging cabal-install for CRUX
17:18:26 <kori> I don't want any untracked files (see, anything in /root/.cabal)
17:23:12 <eikke> is it possible to have unlifted types as associated types?
17:26:48 <osa1_> eikke: I guessing no, because they have a different kind(#)
17:27:04 <osa1_> eikke: unless you try to give that associated type kind #, maybe that would work
17:28:28 <eikke> osa1_: tried that, but something like "class Foo a where type T a :: #" gives a parse error on the #
17:29:28 <osa1_> eikke: you have -XMagicHash?
17:29:42 <eikke> osa1_: yup
17:30:01 <eikke> kindsignatures, typefamilies, magichash, polykinds (and some other unrelated)
17:30:45 <osa1_> no ideas, sorry
17:33:47 <roboguy_> eikke: can you do the trick that they use for unboxed Vectors?
17:33:59 <eikke> hmh, https://ghc.haskell.org/trac/ghc/ticket/9357#comment:2 seems related
17:35:52 <eikke> roboguy_: what would that trick be? afaik Unbox is just an empty type class
17:37:24 <roboguy_> eikke: I was thinking that they were somehow using Unbox along with the boxed type to tell it which unboxed type to use internally, but I might not be remembering it right
17:43:13 <eikke> roboguy_: I dont immediately see how it's done, but the trac ticket I linked above and associatedd patch are fairly clear
17:43:20 <eikke> though I dont like it :P
17:59:33 * hackagebot base91 2.0.0 - A Base91 Encoder & Decoder  http://hackage.haskell.org/package/base91-2.0.0 (ajg)
18:02:59 <Eduard_Munteanu> How do you get unique IDs for the primary key in ixset?
18:31:33 <noexcept> servus
18:35:05 <noexcept> can anyone help me here https://dpaste.de/gfut :(
18:35:26 <noexcept> i don't understand the compile error
18:36:09 <pacak> noexcept: And the error is?
18:36:11 <pacak> :t foldl
18:36:12 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:36:56 <pacak> noexcept: foldl takes a function, initial value and a structure to fold.
18:36:56 <roboguy_> noexcept: it usually helps a lot to write out all the type signatures that you want your functions to have
18:37:45 <roboguy_> like, *a lot*. I always suggest writing type signatures for top-level definitions
18:38:08 <pacak> I'd say *A LOT*...
18:38:24 <noexcept> now it works, thanks a lot for the fast emergency help :-)
18:39:43 <noexcept> i probably should start with the signatures but i'm extremely new to haskell
18:40:25 <hpc> it's a way of thinking you just have to get used to
18:40:39 <hpc> you'll get there
18:41:31 <noexcept> i actually mean i didn't learn the syntax yet
18:41:44 <hpc> ah, that too :P
18:41:51 <pacak> In some cases if you got your type signatures right there's no other way of writing the body.
18:41:51 <pacak> foo :: (a -> b) -> (b -> c) -> (a -> c)
18:41:51 <pacak> Can you write foo?
18:42:22 <dramforever> noexcept: note that haskell is very different from most other languages
18:43:29 <dramforever> it's kinda like learning most of programming from scratch
18:43:43 <dramforever> but it wouldn't be as painful and time-consuming
18:43:52 <noexcept> foo a b = a . b
18:43:53 <noexcept> ?
18:44:20 <pacak> :t (.)
18:44:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:44:32 <pacak> :t (&)
18:44:33 <lambdabot> a -> (a -> b) -> b
18:44:37 <dramforever> hmm...looks like you've learnt quite a bit of haskell...ignore my previous messages
18:44:39 <pacak> How about without using (.)?
18:45:31 <hpc> here's a fun one
18:45:43 <hpc> construct a value of type (Int -> String) -> String
18:45:43 <noexcept> foo f g x = g f x
18:46:05 <Freefood_> is there a stringReplace function in hasell ?
18:46:22 <pacak> Freefood_: for Texts
18:46:26 <pacak> :t T.replace
18:46:26 <dramforever> noexcept: without doing stuff like looping infinitely or throwing an error, that's all you could do
18:46:27 <lambdabot> Not in scope: ‚ÄòT.replace‚Äô
18:46:31 <pacak> o_o
18:46:49 <pacak> :hoogle replace
18:46:56 <pacak> @hoogle replace
18:46:56 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
18:46:56 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
18:46:56 <lambdabot> Data.Text.Encoding.Error replace :: b -> OnError a b
18:48:11 <pacak> :t \f  g x -> f g x
18:48:11 <dramforever> > Data.Text.replace "foo" "bar" "somefoootherfoo"
18:48:12 <lambdabot> (r1 -> r2 -> r) -> r1 -> r2 -> r
18:48:13 <lambdabot>  Not in scope: ‚ÄòData.Text.replace‚Äô
18:48:18 <dramforever> =(
18:48:20 <pacak> noexcept: Not quite.
19:19:36 * hackagebot splay 0.0.1 - (UNTESTED) Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.1 (dramforever)
19:20:06 * dramforever was just too excited and can't wait to upload his package
19:21:51 <byorgey> dramforever: congrats =)
19:22:05 <dramforever> I don't know if it works at all...
19:31:09 <dramforever> hi, does anyone know if I could derive Show for my type if I'm developing but not in the uploaded version?
19:31:26 <dramforever> I think it's going to be something involving CPP
19:33:26 <michaelt> You need something that signals a -devel version hm, this is familiar...
19:33:41 <dramforever> so what?
19:34:17 <dramforever> hmm...cabal check just said hackage would reject my package =(
19:37:47 <dramforever> fixed =)
19:45:31 <michaelt> dramforever: ah, good.
19:45:38 <dramforever> thanks =P
19:49:38 * hackagebot splay 0.0.2 - (UNTESTED) Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.2 (dramforever)
19:49:40 * hackagebot propellor 2.6.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.6.0 (JoeyHess)
19:49:57 <dramforever> oh wait I think I know how to derive Show in development
19:50:26 <dramforever> I can derive a standalone orphan instance in ghci or toy code =P
20:07:09 <svr1123> Can anyone take a look at this question : http://stackoverflow.com/questions/31346467/build-a-graph-structure-in-haskell
20:08:59 <Welkin> svr1123: you can't tie the knot if you actually want to modify the structure
20:09:25 <svr1123> I do not want to modify the structure. Just build and use it.
20:09:25 <tmtwd> is there a way to do this function with list comprehension : evenfibs n = foldr (:) [] (filter even (map fib [0..n])) ?
20:09:51 <Welkin> tmtwd: look here: https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Graph.html
20:09:54 <Welkin> er
20:09:56 <Welkin> svr1123
20:10:08 <Welkin> there is already a graph library
20:10:22 <Welkin> you can look at it to learn how to write a simple graph structure
20:10:35 <tmtwd> ok
20:10:58 <Welkin> I typically use a vector of lists or a vector of vectors
20:11:06 <dramforever> tmtwd: 1. why are you using foldr (:) []
20:11:25 <tmtwd> dramforever, as opposed to foldl?
20:11:28 <Welkin> a "table" that holds the connections
20:11:30 <dramforever> it's basically id for lists that just wastes time and memory
20:11:35 <dramforever> tmtwd: look:
20:11:53 <dramforever> @check (\(x :: [Int]) -> x == foldr (:) [])
20:11:53 <lambdabot>  <unknown>.hs: 1: 16:ScopedTypeVariables is not enabled
20:11:57 <dramforever> =(
20:11:58 <c_wraith> dramforever: well, compiled with optimizations it should be a no-op.
20:12:06 <pordan> Can't you just select the even Fibonacci numbers from the stream of Fibonacci numbers using a list comprehension?
20:12:10 <dramforever> c_wraith: okay, then
20:12:29 <c_wraith> dramforever: I'm not arguing that it should be used.  Just that it won't be too terrible performance-wise.
20:12:48 <dramforever> c_wraith: =)
20:13:59 <dramforever> > [x | i <- [0..10], let x = i * 3,  even x] -- tmtwd, you can write it something like this
20:14:01 <lambdabot>  [0,6,12,18,24,30]
20:14:04 <jle`> svr1123: dramforever's point was that foldr (:) [] is id, heh
20:14:14 <jle`> > foldr (:) [] [1,2,3,4,5]
20:14:15 <lambdabot>  [1,2,3,4,5]
20:14:26 <dramforever> oh yes, it wastes human typing and compiler optimizing time
20:14:33 <jle`> > foldr (:) [] [5,2,8,3,4]
20:14:34 <lambdabot>  [5,2,8,3,4]
20:14:42 <Welkin> > repeat (foldr (:) []) [1..5]
20:14:43 <lambdabot>      Couldn't match expected type ‚Äò[Integer] -> t‚Äô
20:14:43 <lambdabot>                  with actual type ‚Äò[t0 a0 -> [a0]]‚Äô
20:14:43 <lambdabot>      The function ‚Äòrepeat‚Äô is applied to two arguments,
20:14:51 <Welkin> > forever (foldr (:) []) [1..5]
20:14:56 <lambdabot>  mueval: ExitFailure 1
20:15:42 <jle`> > take 1 $ sequence (repeat (foldr (:) [])) [1,2,3,4]
20:15:44 <lambdabot>  [[1,2,3,4]]
20:16:05 <verement> @check \x -> let _ = (x :: [Int]) in x == foldr (:) [] x
20:16:07 <lambdabot>  +++ OK, passed 100 tests.
20:17:00 <roboguy_> hey, how long has lambdabot had quickcheck?
20:17:02 <c_wraith> @check \xs -> xs == reverse xs
20:17:04 <lambdabot>  +++ OK, passed 100 tests.
20:17:16 <c_wraith> Lambdabot has had quickcheck since at least 2008
20:17:19 <c_wraith> Probably longer.
20:17:26 <roboguy_> oh, huh
20:17:43 <jle`> since as long as i've been on #haskell at least, heh
20:17:47 <Welkin> lambdabot had quickcheck before it was cool
20:17:48 <c_wraith> also, all lists are palindromes.
20:18:07 <nitrix> What is it testing? How do you choose which test to use?
20:18:09 <verement> :t reverse
20:18:10 <lambdabot> [a] -> [a]
20:18:12 <Welkin> c_wraith: not infinite lists
20:18:14 <jle`> nitrix: it generates random data
20:18:15 <Welkin> it's not provable!
20:18:33 <jle`> that's the magic of quickcheck :D
20:18:38 <c_wraith> Welkin: quickcheck told me they are.
20:18:48 <dramforever> actually I think smallcheck and quickcheck should be used together
20:19:08 <Welkin> jle`: how long has that been?
20:19:17 <dramforever> if you pass both you are fine
20:19:23 <jle`> beginning of 2013 i think?
20:19:26 <jle`> so not very long admittedly
20:19:33 <Welkin> wow, that late?
20:19:39 * hackagebot BlogLiterately 0.8.1.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.8.1.1 (BrentYorgey)
20:19:40 <dramforever> if you pass s but not q you need better handling of larger data
20:19:41 <Welkin> I would have guessed much longer
20:20:00 <dramforever> if you pass q not s you need to take care of some corner cases better
20:20:09 <dramforever> if you pass neither...well fix your library
20:20:20 <jle`> yeah most people think because i grabbed a short username that i've been on irc for a while
20:20:20 <dramforever> s/library/program/
20:20:34 <Welkin> I still frequent a channel I have been in since 2005, after being absent for several years
20:20:49 <Welkin> I didn't log in to IRC for 3.5 years
20:21:06 <Welkin> I have only been here for over a year
20:23:07 <Welkin> jle`: well, it's more that you are so active in here
20:23:41 <jle`> that's more because i'm very bad at being productive heh
20:24:12 <Welkin> haha
20:24:30 <Welkin> the life of a graduate student
20:24:34 * dramforever is less productive =(
20:25:35 <DylannStormRoof> We at Chimpmania Forum applaud the heroic actions of Dylann Storm Roof and are now in the process of promoting Emanuel AME Church as a tourist destination for niggerhaters to go in and pray and worship at the expense of the feral negroid beast!   That church is NOW our symbol and our landmark.  Join us today! http://www.chimpmania.com/forum
20:26:02 --- mode: ChanServ set +o monochrom
20:26:09 <Welkin> oh boy
20:26:10 --- mode: monochrom set +b *!*@200.79.252.182
20:26:10 --- kick: DylannStormRoof was kicked by monochrom (DylannStormRoof)
20:26:22 <Welkin> monochrom: was that a new record?
20:26:24 <Welkin> you are fast
20:26:49 <monochrom> I am lucky. I just came home from outside
20:27:05 <monochrom> we at #haskell applaud the heroic actions of monochrom!
20:27:34 <monochrom> and are now in the process of electing him as Dictator For Life
20:28:57 <shachaf> @poll-add dictator-for-life
20:28:57 <lambdabot> Added new poll: "dictator-for-life"
20:29:08 <shachaf> @choice-add dictator-for-life monochrom
20:29:08 <lambdabot> New candidate "monochrom", added to poll "dictator-for-life".
20:29:18 <shachaf> @vote dictator-for-life monochrom
20:29:19 <lambdabot> voted on "monochrom"
20:29:19 <Welkin> wow
20:29:27 <Welkin> #haskell was founded by edwardk in 2001
20:29:35 --- mode: monochrom set -o monochrom
20:29:39 <dramforever> @vote dictator-for-life monochrom
20:29:39 <lambdabot> voted on "monochrom"
20:29:48 <dramforever> nothing useful huh
20:30:39 <Welkin> @vote dictator-for-life (=<<)
20:30:39 <lambdabot> "(=<<)" is not currently a candidate in this poll
20:31:28 <monochrom> you probably need choice-add first
20:31:58 <shachaf> I don't think this poll needs any other choices.
20:32:03 <monochrom> :)
20:33:04 <byorgey> Welkin: uh, what?  edwardk didn't even know Haskell in 2001.
20:33:41 <byorgey> #haskell was founded by shapr.
20:33:56 <Welkin> byorgey: chanserv disagrees
20:34:19 <shachaf> edwardk is marked +F for the channel. But +F can be transferred.
20:34:24 <Welkin> I see
20:34:40 * hackagebot splay 0.0.3 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.3 (dramforever)
20:34:47 <dramforever> Question: should I put my splay-based sequence type in Data.Splay.Sequence or Data.Sequence.Splay? the existing bottom-up splaytree package and fingertree package disagree and I can't decide
20:35:08 <jle`> why not Data.Splay ?
20:35:19 <dramforever> jle`: because it's generic
20:35:34 <dramforever> and my sequence should be just like Data.Sequence.Seq
20:35:56 <dramforever> and the splay is like Data.FingerTree.FingerTree
20:36:04 <byorgey> dramforever: that is a question not worth spending much time on.  Just pick one and go with it.
20:36:19 <jle`> i can flip a coin for you if you like :)
20:36:22 * dramforever has quite a bit of free time
20:36:25 <shapr> Welkin: meh, whatever
20:36:30 <dramforever> never mind =P
20:36:31 <shapr> byorgey: I remember the old days...
20:36:35 <jle`> but there really isn't too much point in like categorizing and stuff
20:36:40 * dramforever should try to be more productive
20:36:40 <jle`> we have Data.Map, not Data.Container.Map
20:36:43 <byorgey> @roll 1d2
20:36:43 <lambdabot> byorgey: 2
20:36:45 <total> attoparsec question: Does anyone know why p1 fails but p2 succeeds on the string "abc" where p1 = ("a" <|> "ab") <* "c"; p2 = ("ab" <|> "a") <* "c"
20:36:57 <shapr> Welkin: In the old days we had to compile the new version of ghc BY HAND... 
20:37:39 <Welkin> shapr: ghc would only compile if you played linkin park loudly enough
20:37:41 <jle`> total: attoparsec is non-backtracking, i believe
20:37:59 <dramforever> jle`: no, it's backtracking *by-default*
20:38:02 <shapr> Welkin: we didn't even HAVE linkin park back then!
20:38:05 <jle`> ah
20:38:09 <shapr> Welkin: we banged rocks together to make music
20:38:22 <shapr> Welkin: but seriously, there weren't many Haskell users at first
20:38:37 <dramforever> we run haskell code BY DRAWING ON ROCKS
20:39:16 <c_wraith> I hear shapr tricked people into visiting #haskell by telling them about all the cool people in #haskell..  But it was a self-fulfilling prophecy.
20:39:41 <c_wraith> Because shapr only told the cool people that.
20:39:50 <shapr> c_wraith: that's true
20:40:02 <shapr> c_wraith: well, I told the smart academics that there were smart academics on #haskell
20:40:07 <shapr> and when they joined, it was true
20:40:14 <jle`> was there a "mailing list" or w/e it's called back then?
20:40:23 <shapr> jle`: yup, archives go back a long way
20:40:43 <Welkin> the yesod mailing list is much more active than the channel, sadly
20:41:18 <dramforever> shapr: wow is it like "if you go into this room you will see people there"?
20:41:40 <shapr> dramforever: that's how it started
20:41:46 <shapr> dramforever: totally worked too
20:41:48 <dramforever> okay =P
20:42:08 <Welkin> shapr also ran a file server to lure people in
20:42:14 <Welkin> serving old episodes of Friends
20:42:30 <Welkin> another tactice was allowing one transfer at a time
20:42:34 <Welkin> so they had to wait in the queue
20:42:34 <shapr> Welkin: actually, I hosted darcs repositories
20:42:45 <Welkin> and while they waited, what better to do than talk to the other people waiting in the queue?
20:42:47 <shapr> Welkin: and I hosted lambdabot
20:42:50 <shapr> and I hosted the darcswiki
20:42:56 <shapr> and I admin'd the Haskell Wiki
20:43:03 <shapr> and I organized conferences
20:43:13 <shapr> Welkin: and I started The Monad.Reader
20:43:38 <shapr> Welkin: you can read some of this in the History of Haskell paper at the HoPL conference, I get mentioned by IRC nickname :-)
20:43:54 <shapr> but I haven't done anything lately
20:44:20 <jle`> being recognized/mentioned by your irc name over your real name only comes from important accomplishments
20:44:22 <jle`> :)
20:44:34 <Welkin> HoPL?
20:46:31 <total> Even (choice ["a", "ab"] <* "c") fails on "abc", but reversing the list makes it succeed.
20:46:43 <hodapp> shapr: you started Monad.Reader? didn't know that
20:47:00 <total> The attoparsec documentation says, in reference to "try", "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure."
20:48:18 <jle`> total: i think maybe it's because the <|> doesn't distribute to the right like that
20:48:39 <jle`> x *> (y <|> x) = (x *> y) <|> (x *> z)
20:48:58 <jle`> but (y <|> z) *> x /= (y *> x) <|> (z *> x)
20:49:10 <jle`> that x should be a z on my first case
20:49:27 <jle`> if you walk through the evaluation then i think you can see why it fails
20:49:38 <jle`> it first tries ("a" <|> "ab") and succeeds on "a"
20:49:44 <jle`> then tries "c" and then fails
20:49:57 <total> Interesting point! But wouldn't attoparsec backtrack once it fails on "c"?
20:50:55 <jle`> i think there's no <|> going on, so there isn't really a reason for it to backtrack
20:51:03 <jle`> hm
20:51:32 <total> I wonder if it loses its backtracking memory once it passes over *>
20:55:08 <monochrom> "mplus executes the right-hand parser if the left-hand one fails. When the parser on the right executes, the input is reset to the same state as the parser on the left started with."
20:55:50 <monochrom> this is a much more precise and reliable statement than intuitive descriptions such as "it backtracks"
20:56:52 <monochrom> (most intuitive descriptions satisfy the precise property "open to interpretation")
20:57:10 <monochrom> even then, the "if" should be improved to "iff"
20:57:28 <monochrom> with that improvement, "ab" is never executed.
20:58:27 <monochrom> whereas ("a" *> "c") <|> ("ab" *> "c") will reset the input state and execute "ab" *> "c"
21:00:12 <total> Ah, so (choice ["a", "ab"] <* "c") would instead need to be written (choice (map (<* "c") ["a", "ab"]))?
21:01:05 <total> Thanks for the explanation, monochrom!
21:16:57 <shachaf> @poll-results dictator-for-life
21:16:57 <lambdabot> Poll results for dictator-for-life (Open): monochrom=2
21:16:59 <shachaf> It's decided.
21:19:19 <monochrom> :)
21:20:22 <shachaf> @poll-close dictator-for-life
21:20:22 <lambdabot> Poll "dictator-for-life" closed.
21:25:25 <jle`> i'm okay with this
21:29:13 <|f`-`|f> just who is monochrom 
21:30:55 <jle`> dictator for life
21:37:45 * Welkin imagines monochrom as The Dictator from Sacha Baron Cohen's film of the same name
21:37:58 <shachaf> @poll-result should-lambdabot-be-more-polite
21:37:58 <lambdabot> Poll results for should-lambdabot-be-more-polite (Closed): maybe=6, no=13, yes=8
21:47:24 <Walpurgisnacht> does anyone have a link to a site that teaches lens?
21:47:48 <Walpurgisnacht> or how to implement ir
21:47:51 <Walpurgisnacht> it*
21:49:20 <dramforever> the NYC lens talk video by ekmett: http://youtu.be/cefnmjtAolY?hd=1 and slides: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
21:49:56 <Walpurgisnacht> thank
21:50:12 <MarcelineVQ> oh cool!
21:50:18 <dramforever> =)
21:50:22 <MarcelineVQ> I haven't looked at lenses at all yes so this could be fun
21:50:28 <MarcelineVQ> *at all yet
21:52:32 <pacak> :t confusing
21:52:33 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
21:54:13 <timemage> ahf, so that's the type of confusion.  how perplexing.
21:54:21 * pacak pokes lambdabot
21:56:02 <roboguy_> the most intimidating looking thing in lens is probably Conjoined, but unfortunately lambdabot doesn't do :i
21:59:12 <verement> Walpurgisnacht: I've also found this helpful: http://unbui.lt/#!/post/haskell-another-lens-tutorial/
21:59:28 <Walpurgisnacht> thank you
21:59:39 <dramforever> oh yes
21:59:45 * |f`-`|f burns Walpurgisnacht on the stake
21:59:45 <dramforever> Walpurgisnacht: you're welcome =)
21:59:52 <ricochet1k> bad link
22:00:21 <ricochet1k> Take the last / off
22:00:33 * Walpurgisnacht burns to death before they could learn lens and come back to haunt |f`-`|f
22:00:58 * |f`-`|f is already a bigger spookier ghost
22:01:07 <roboguy_> ricochet1k: it works for me either way
22:01:29 <ricochet1k> Weird. I get 404
22:02:29 <Walpurgisnacht> the page is just black 
22:02:47 <ricochet1k> try http://unbui.lt/#!/post/haskell-another-lens-tutorial
22:03:09 <verement> sorry about that
22:04:39 <roboguy_> Huh, that's really weird. I tried it on three different browsers and all of them open the page fine with the / at the end...
22:05:24 <Walpurgisnacht> what browser do you use 
22:05:24 * verement shrugs.
22:05:31 <ricochet1k> Firefox Nightly
22:05:43 * ricochet1k wonders if that is a bug...
22:05:46 <Walpurgisnacht> try water fox
22:05:56 <Walpurgisnacht> its a verrrrrrrrryyyyy fast browser
22:06:31 <Walpurgisnacht> but you could use chrome if you are having a bug with nightly
22:07:40 <roboguy_> Walpurgisnacht: I thought you were joking. Haven't heard of waterfox 'till now, somehow
22:07:54 <ricochet1k> huh. sounds interesting. Doesn't run on linux though.
22:08:09 <Walpurgisnacht> yeah that's always an issue
22:08:39 <Walpurgisnacht> but its decently faster than most browsers idk how it compares to pale moon though
22:19:24 <Welkin> you mean ice weasel?
22:21:20 <roboguy_> Welkin: man, how many Firefox forks are there?
22:24:07 <Welkin> lthat's what I love about open source
22:28:14 <augur> is there a channel for Warp?
22:29:31 <Welkin> no idea
22:29:37 <Welkin> but there is #yesod
22:38:38 <smunix> > and (False, True)
22:38:39 <lambdabot>  True
22:38:53 <Welkin> :t and
22:38:54 <lambdabot> Foldable t => t Bool -> Bool
22:39:03 <smunix> Why True?
22:39:31 <smunix> I would have expected it to be False
22:39:33 <dramforever> > and (2, True)
22:39:35 <lambdabot>  True
22:39:35 <jle`> smunix: and looks at all the contained items in a Traversable
22:39:45 <jle`> and (x, True) contains just one item: True
22:39:46 <dramforever> because the first element is ignored
22:39:56 <Welkin> yes
22:39:58 <jle`> as a traversable, that is
22:40:02 <Welkin> tuples can be confusing in that way
22:40:06 <jle`> > fmap (*2) (2, True)
22:40:07 <lambdabot>      Could not deduce (Num Bool) arising from a use of ‚Äò*‚Äô
22:40:07 <lambdabot>      from the context (Num t)
22:40:07 <lambdabot>        bound by the inferred type of it :: Num t => (t, Bool) at Top level
22:40:08 <jle`> er
22:40:10 <jle`> > fmap (*2) (2, 10)
22:40:11 <lambdabot>  (2,20)
22:40:14 <jle`> > toList (2, 10)
22:40:15 <lambdabot>      Couldn't match type ‚ÄòItem (t, t2)‚Äô with ‚ÄòItem (t0, t1)‚Äô
22:40:15 <lambdabot>      NB: ‚ÄòItem‚Äô is a type function, and may not be injective
22:40:15 <lambdabot>      The type variables ‚Äòt0‚Äô, ‚Äòt1‚Äô are ambiguous
22:40:18 <Welkin> the first value is skipped
22:40:20 <dramforever> it's kinda like a writer monad
22:40:23 <jle`> > F.toList (2, 10)
22:40:23 <Welkin> in a pair, it is the "key"
22:40:26 <lambdabot>  [10]
22:40:41 <jle`> > and [False, True]
22:40:42 <lambdabot>  False
22:46:10 <adarqui> i don't see people use ImplicitParameters much.
22:46:16 <adarqui> any1 here use them?
22:48:01 <jle`> i don't think they're very commonly used
22:48:25 <jle`> it might be considered to be non idiomatic, i'm not sure
22:48:35 <adarqui> thnx, ya i've never actually run into them when reading source
22:49:03 <jle`> http://h2.jaguarpaw.co.uk/posts/modules-for-lennart/ is a bit of an esoteric usage
22:49:06 <sccrstud92> > andOf both (False, True)
22:49:07 <lambdabot>  False
22:49:07 <Welkin> I never knew that existed
22:49:28 <jle`> i only knew about it from ocharles_'s series on extensions
22:49:35 <Welkin> it doesn't sound very useful
22:49:46 <jle`> it sounds like a good way to make unreadable haskell code heh
22:49:49 <adarqui> thnx reading
22:50:00 <Welkin> so, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters
22:50:15 <jle`> i was talkin bout https://ocharles.org.uk/blog/posts/2014-12-11-implicit-params.html
22:50:29 <dramforever> I don't think it's useful
22:50:43 <Welkin> jle`: yeah, I got that
22:56:29 <adarqui> enjoying reading this https://github.com/haskell-suite/haskell-src-exts/blob/master/src/Language/Haskell/Exts/Syntax.hs
23:00:36 <Welkin> actually, I may curl up with the GHC manual and make it my bedtime story
23:01:13 <Welkin> I would never have imagined reading a manual, or documentation, or a programming guide for entertainment, but I do it often with haskell
23:01:27 <adarqui> sounds like a ton of fun to me
23:04:02 <adarqui> for me, just seeing everything laid out in algebraic data types really helps everything sink in
23:05:58 <dramforever> adarqui: I sometimes get happy imagining those ADTs written with classes, like in other OO languages
23:06:33 <dramforever> because we don't do that :P
23:07:42 <dramforever> okay I just discovered and fixed a serious bug in my splay package that prevented the most important operation from performing correctly
23:07:58 <adarqui> cool
23:08:31 <dramforever> I think I could deprecate all the previous versions, but how?
23:09:47 * hackagebot splay 0.0.4 - Generic splay-based sequence representation  http://hackage.haskell.org/package/splay-0.0.4 (dramforever)
23:09:49 <dramforever> wait I think I figured it out...it's in the "edit package information" link
23:10:10 <dramforever> oh yes that was the update =P. it also includes a example sequence type
23:13:18 <jle`> congrats :)
23:13:30 <adarqui> i guess this is a good time to ask, why hasn't your documentation generated? does it just take time? or is something in your package preventing it from updating?
23:13:36 <ghost_runner> I've always wondered:
23:13:39 <favetelinguis> what am i missing here https://gist.github.com/favetelinguis/23370f37ce55db90263e im getting a parse error but cant see what im doing wrong. this example is from the book Learning data analysis
23:13:40 <ghost_runner> What's even remotely bad about Haskell being an "academic" language (even though that's debatable)?
23:13:50 <ghost_runner> Or a (paraphrasing) "piece of art being sold to engineers"?
23:14:05 <jle`> adarqui: it takes time.  if it's erroring, it'll show up in the build logs :)
23:14:07 <ghost_runner> Like, what's wrong with an artistic execution of an engineering craft? Must everything be bare-bones?
23:14:31 <adarqui> ghost_runner: people's use of "academic" usually implies "not for large scale production use" .. i imagine.. which, obviously isn't the case for haskell
23:14:37 <adarqui> so it's definitely bad in that sense, imho
23:14:52 <jle`> ghost_runner: optimized for academic use instead of for industry use or large scale use, so impractical for industry or large scale use
23:15:05 <jle`> i guess it's not a moral judgment but rather "bad for my expected use case --- industry and large scale"
23:15:13 <jle`> usually the context is implied
23:15:30 <adarqui> donsbot scoffs!
23:15:35 <jle`> favetelinguis: hm, what are you trying to do in your where clause?
23:15:46 <jle`> favetelinguis: do you want to define handleCSVError ?
23:15:53 <jle`> in that case you should use =, not (==)
23:16:18 <jle`> also it might be good to indent your do block past your "where", but i'm not 100% sure it's necessary
23:16:20 <favetelinguis> yes i was wondering there but he uses == in the book
23:16:27 <jle`> it is most likely a typo :)
23:16:45 <jle`> you'd think people would try to compile their code samples, heh
23:16:52 <jle`> or have it automated in some way
23:17:28 <jle`> also i'm pretty sure there's a type error there too
23:17:31 <Haskellfant> I don't get why they don't do it. It's just so annoying when books contain errors in their code samples
23:17:55 <favetelinguis> and thy ALWAYS do
23:17:58 <jle`> yeah, idk it's hard to take any book seriously
23:17:58 <dramforever> maybe check if there's an errata
23:18:09 <jle`> especially considering most programming book cost $40+
23:18:14 <jle`> *books
23:18:33 <adarqui> most code repos i've seen also have typos though.. just us fallable humans
23:18:34 <Welkin> like my circuits book written by my professor that was $150
23:18:34 <jle`> i automate compiling all of the code in my blog posts heh
23:18:47 <Welkin> and had 5 pages of errata online
23:19:05 <jle`> any decent code repo will have CI set up to make sure you can't push anything that doesn't compile
23:19:25 <johnw> jle`: how does it test it if you can't push it?
23:19:26 <jle`> even if someone doesn't have a hook to auto-compile locally, they should still compile their code v.v
23:19:41 <dramforever> jle`: well, maybe you can't push anything that doesn't compile *and* don't know about it
23:19:42 <jle`> i mean, reject or throw a big warning
23:19:50 <favetelinguis> hmm getting type error now instead https://gist.github.com/favetelinguis/23370f37ce55db90263e
23:20:09 <jle`> yeah, that's the type error i expected
23:20:37 <jle`> error's first argument is an (e -> blah), a function from the type in the Left to a value
23:20:51 <jle`> it looks like your handleCSVError wants ti ignore the type in the Left
23:21:00 <jle`> so you can do (\_ -> handleCSVError) instead of handleCSVError there
23:21:21 <jle`> or const handleCSVError
23:21:37 <jle`> i like \_ -> though because it matches the next line :)
23:21:57 <jle`> but why not just a case statement?
23:21:58 <jle`> who knows
23:22:07 * dramforever was happy about sort of happy about his splay package
23:23:43 <favetelinguis> jle`: that did the trick thanks
23:24:11 <favetelinguis> lots of typos in that book, to bad since it is made for sort of noobs
23:24:18 <jle`> favetelinguis: np!  and yeah i'd check to see if the book has an errata page somewhere
23:24:19 <adarqui> how does this work, type role Splay nominal nominal
23:24:22 <adarqui> that's a type family?
23:24:42 <adarqui> dramforever: ^
23:25:01 <jle`> on an unrelated note, "type family" is probably one of the happier warm fuzzy feeling sounding haskell concepts
23:25:10 <jle`> they're a family :3
23:25:23 <adarqui> ya but i don't get this declaration.. it's just sitting there
23:25:29 <adarqui> and i don't know what it's doing
23:25:29 <adarqui> :d
23:27:03 <Haskellfant> adarqui: they're described in the ghc manual https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/roles.html
23:27:42 <Welkin> ‚àë:3
23:28:28 <Haskellfant> I'm not too familiar with roles myself so I'd leave it to someone else to explain them to avoid confusing you unnecessarily because I don't know what I'm talking about
23:29:02 <adarqui> that comes from dramforever's lib, so maybe he can clue me
23:29:20 <dramforever> adarqui: I was offline for a while, what happened?
23:29:24 <adarqui> reading that url tho, somewhat explains it
23:30:00 <adarqui> hey dramforever, just wondering what this does in your splay lib: type role Splay nominal nominal
23:30:14 <dramforever> It prevents users from coercing it
23:30:21 <dramforever> because that could break the invariants
23:30:55 <dramforever> =) thank you for reading my package...that's the first time someone I don't know well has read my code without me asking first
23:31:11 <adarqui> ha np
23:34:31 <benzrf> https://i.imgur.com/Ai0HKR1.jpg :^)
23:34:35 <benzrf> crap, wrong chan
23:35:31 <dramforever> lol that removed all the stress while working on the splay package
23:35:33 <Welkin> haha, you do that a lot
23:35:51 <Welkin> benzrf: what is this other channel you always accidentally post in here instead?
23:36:27 <adarqui> dramforever: i see you have a Traversable instance in Sequence.hs, but not in Splay.hs? curious because you have a traverse function in Splay.hs
23:36:35 <adarqui> will you add more instances there or.. ?
23:36:52 <dramforever> adarqui: check the type, that won't fit into Traversable
23:37:07 <adarqui> oo rereading
23:40:38 <adarqui> btw, I had to add Data.Monoid to Splay.hs and Data.Foldable.foldr / Prelude.foldr are fighting
23:40:42 <adarqui> (to get it to compile
23:40:43 <adarqui> )
