00:00:26 <mjrosenb> Cale: yeah, that is what I'm doing now, it isn't pretty.
00:01:25 <mjrosenb> related question: Is there any trick for the record update syntax for a) updating a field based on a previous value, or b) updating a nested field
00:02:12 <mjrosenb> so inc val = val {x = x val + 1} -- not the prettiest, but it works
00:02:22 <ChristianS> mjrosenb: you could also define two types: CompleteX vs. IncompleteX where the latter has various Maybe fields. Plus a function mkComplete :: IncompleteX -> CompleteX
00:03:38 <mjrosenb> and data Coord = Coord {x :: Int, y :: Int}; data Rect = Rect {pos :: Coord, size :: Coord}
00:04:03 <Xe> so I've installed stack. how can I use it?
00:04:18 <Xe> I want to make a haskell project that depends on some stuff from hackage
00:04:29 <Axman6> mjrosenb: your problem is precisely what lenses are for
00:04:56 <Axman6> Xe: run stack init inside your project, that should create a stack.yaml file for you
00:05:24 <Xe> Axman6: and then what?
00:05:31 <Axman6> then, if i can't find library versions you need in the latest LTS Haskell, you can specify them in the stack.yaml file
00:05:32 <mjrosenb> then makeWider r = r {size = size r {x = (x . size $ r) + 1} } -- hella ugly
00:05:49 <Xe> no i mean how do I add the dependencies
00:06:06 <YellowOnion> I'm trying to I check if theres 6 or more occurances in a list without scaning the entire length of the list.
00:06:09 <Axman6> oh, one sec, I'll grab one I have
00:06:45 <Axman6> Xe: add something like:
00:06:46 <Axman6> extra-deps:
00:06:47 <Axman6> - time-units-1.0.0
00:07:02 <Axman6> for each dep it can't satisfy
00:07:32 <Axman6> (well, add a line like - <package>-<version> for each package you need)
00:07:38 * hackagebot pipes-async 0.1.1 - A higher-level interface to using concurrency with pipes  https://hackage.haskell.org/package/pipes-async-0.1.1 (JohnWiegley)
00:07:38 * hackagebot bet 0.1.2.3 - Betfair API bindings. Bet on sports on betting exchanges.  https://hackage.haskell.org/package/bet-0.1.2.3 (Adeon)
00:07:45 <Axman6> s/need/which can't be found by stack
00:07:51 <Xe> is there a reason it separates out application and library source into their own directories?
00:08:11 <Axman6> no idea, I haven't used it for new projects before
00:08:25 <Axman6> only projects which I was previously using cabal sandbozes for
00:08:45 <Axman6> sandboxes*
00:09:14 <Xe> ah
00:09:24 <Xe> I'm new-ish to haskell and have been trying to figure it out
00:09:37 <b_> Hello, http://learnyouahaskell.com/ is down?
00:09:45 <Xe> I'm used to go and lua where dependency management and the like is much simpler
00:10:17 <Axman6> stack makes dependency management simpler
00:10:49 <mjrosenb> lua has dependency management?
00:11:10 <Xe> mjrosenb: technically :P
00:11:19 <b_> my dns is failing for http://learnyouahaskell.com/ , does anyone know its ip?
00:11:38 <jle`> @where lyah
00:11:39 <lambdabot> http://www.learnyouahaskell.com/
00:11:52 <jle`> huh how weird
00:12:16 <jle`> my dns not working for it either
00:12:24 <jle`> maybe this is the end of an era
00:12:34 <b_> :( oh i was on the second last chapter!
00:12:50 <Flonk> :(
00:12:51 <YellowOnion> Maybe someone forgot to refresh their DNS sub lol
00:13:02 <quchen2> b_: If it helps, the last chapter's topic is pretty isolated
00:13:14 <jle`> yeah, i actualy never finished the last chapter or two
00:13:23 <jle`> go forth and haskell
00:13:27 * mjrosenb bets it is on the wayback machine
00:13:47 * jle` tries to write sentences using only names of programming languages
00:13:52 <b_> mjrosenb, great idea!
00:14:05 <Xe> Axman6: I'm used to "shove files into the right path and the compiler will do the rest"
00:14:10 <quchen2> jle`: Simple! Just put spaces between the letters
00:14:19 <Cale> I wonder where BONUS went anyway
00:14:23 <jle`> f
00:14:29 <Cale> He disappeared shortly after writing the book.
00:14:56 <quchen2> And he's impossible to search online because no matter what you exclude, LYAH still pops up
00:15:14 <Cale> Maybe he really disappeared and the DNS just expired
00:15:27 <b_> theres a pdf at https://hackage.haskell.org/
00:15:42 <Cale> http://hackage.haskell.org/package/manatee-pdfviewer-0.1.1/src/data/welcome/LearnYouAHaskell.pdf
00:15:48 <b_> thank god!
00:15:52 <jle`> :D
00:15:58 <Cale> oh, it's only one chapter though
00:15:59 <b_> things were finally making some sense via this book
00:16:17 <b_> yes :(
00:17:08 <Cale> http://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/09%20learnyouahaskell.pdf seems like it has more
00:17:19 <b_> it has happened before: https://www.reddit.com/r/haskell/comments/1kmxim/learnyouahaskellcom_seems_to_be_down_alternative/
00:18:31 <b_> till chapter 10 and no pictures
00:19:23 <quchen2> b_, jle` Cale: LYAH works again
00:20:08 <quchen2> Maybe we should scrape the page anyway just in case this happens for real.
00:20:54 <Cale> quchen2: hmm, interesting
00:21:26 <Cale> Yeah, it might be worth making a copy to preserve it in case it ever completely goes down
00:21:30 <averell> too bad archive.org doesn't crawl it
00:21:48 <Cale> https://github.com/pvorb/learn-you-a-haskell claims to be able to generate a copy and it includes images
00:22:09 <b_> yes, i am installing pandoc to make it work right now, lets see
00:23:10 <b_> works, built an epub
00:23:23 <b_> with pics
00:29:41 <jle`> someone should probably scrape it just in case, seeing what happened today...but i wonder what the legal ramifications are, considering that it's actually a book that he sells
00:30:12 <rowanblush> jle`: It's Creative Commons licensed.
00:30:21 <jle`> ah i see
00:30:25 <jle`> yay licenses
00:33:49 <b_> heres kindle: https://github.com/igstan/learn-you-a-haskell-kindle :D
00:38:44 <YellowOnion> is there a way to get ghci to output profile info?
00:46:10 <frerich> YellowOnion: You can use ':set +s' to get ghci to print some basic information when profiling expressions.
00:46:46 <YellowOnion> frerich, yeah was hoping for more detail, like time spent in function.
00:47:15 <sanjoyd> heap == 1.0.0 seems to have build errors:  http://pastebin.com/uV5JZb0Z
00:47:34 <sanjoyd> My sandbox has "base >=4.8 && <4.9, containers >=0.5 && <0.6, mtl >=2.2 && <2.3, heap == 1.0.0"
00:48:05 <sanjoyd> ghc -v is "Glasgow Haskell Compiler, Version 7.10.1, stage 2 booted by GHC version 7.6.3"
00:48:24 <sanjoyd> Am I doing something incorrectly, or should I file a bug?
00:48:25 <merijn> sanjoyd: Looks like it wasn't updated for the Foldable/Traversable in Prelude change
00:48:33 <sanjoyd> :(
00:48:51 <sanjoyd> merijn: are there any short-term workarounds?
00:49:08 <sanjoyd> Like using an older "base" or something?
00:49:41 <merijn> You can't change base, it's wired into GHC
00:49:55 <merijn> So you need to downgrade your GHC or patch heap yourself
00:50:08 <merijn> Should be fairly trivial to patch, though
00:51:44 <sanjoyd> Looks like it is already fixed on github.
00:52:08 <sanjoyd> Is there a way I can tell cabal to pull in a library for github?
00:52:11 <sanjoyd> *from
00:52:15 <ely-se> indiagreen: I added Linux support.
00:52:27 <sanjoyd> Or do I have to wait for the package maintainer to upload to hackage?
00:52:34 * hackagebot open-browser 0.1.1.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.1.1.0 (rightfold)
00:53:05 <jle`> sanjoyd: you can git clone and then tell cabal sandbox to use that directory over hackage
00:53:11 <bitonic> man, this new hyperlinked haddock is the best thing ever
00:53:17 <jle`> cabal sandbox add-source path-to-the-library-on-disk
00:53:23 <ely-se> bitonic: what is it?
00:53:38 <bitonic> ely-se: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#intersect
00:53:46 <bob_twinkles> I think "cabal install path/to/library" will work as well
00:53:57 <ely-se> bitonic: oh shiny
00:54:10 <ely-se> a pity that it's solarized though :p
00:54:55 <sanjoyd> Actually, I *was* being stupid.
00:55:04 <sanjoyd> 1.0.2 works fine
00:56:21 <frerich> bitonic: That's really pretty, and it uses the exact same color scheme as my gvim, too! :-)
00:56:34 <YellowOnion> I swore I enabled profiling in cabal :(
00:57:24 <jle`> :(
00:57:34 <jle`> it hurts
00:58:46 <YellowOnion> it is enabled.
00:59:38 <YellowOnion> oh its commented out, how'd I miss that :(
01:00:05 <jle`> ):
01:02:18 <YellowOnion> still yet to figure out how to install llvm on windows as well
01:03:12 <bitonic> frerich: that's solarized isn't it?
01:03:21 <frerich> bitonic: Yeah
01:04:05 <ely-se> Solarized offers too little contrast for my taste.
01:06:27 <bitonic> ely-se: agreed
01:08:24 <YellowOnion> ghc-pkg recache >>= you don't have permission to modify this file
01:10:24 <quchen2> bitonic: Wooooah!
01:10:30 <quchen2> How did I not hear about this?
01:11:59 <jdnavarro> what's the "official" stance on `Alternative` laws?
01:12:33 <jdnavarro> what laws should I stick to when creating a new instance of `Alternative`?
01:12:35 * hackagebot highjson 0.2.0.2 - Very fast JSON serialisation and parsing library  https://hackage.haskell.org/package/highjson-0.2.0.2 (AlexanderThiemann)
01:29:35 <jle`> jdnavarro: Alternative laws are unambiguous
01:29:46 <jle`> it's the MonadPlus laws that people tend to argue about, heh
01:30:48 <jle`> the only laws are that (<|>) is associative and that empty forms an identity with (<|>)
01:30:50 <jdnavarro> jle`, what are the official laws, then? The monoid laws?
01:30:53 <jle`> yes
01:31:02 <jdnavarro> oh, alright
01:31:03 <jle`> for MonadPlus there is some debate about its interaction with (>>=)
01:31:29 <ely-se> if you have two unhidden packages that expose modules with the same name, how can you disambiguate?
01:31:30 <jle`> but Alternative doesn't know about (>>=), so it can't really care
01:32:06 <jdnavarro> jle`, I got confused reading https://hackage.haskell.org/package/semigroupoids-5.0.0.2/docs/Data-Functor-Alt.html
01:32:24 <jle`> ely-se: you can use the PackageImports extension, i think
01:32:35 <supki> ely-se: yes, with -XPackageImports
01:32:36 * hackagebot open-browser 0.1.2.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.1.2.0 (rightfold)
01:32:58 <jdnavarro> thought I had to include the "left distribution" law, too
01:33:10 <ely-se> jle` supki I see :)
01:33:33 <jle`> jdnavarro: hm.  talk of the law is a little awkward there, i think
01:34:32 <jle`> i think it's just talking about situations where the type also happens to be a Monad
01:35:40 <jle`> "left catch law" is meaningless when talking about Alternative, technically
01:35:41 <jdnavarro> yeah, apparently there are 2 left distribution laws, the `f <$> (a <!> b) = (f <$> a) <!> (f <$> b)` and the "left distribution" from MonadPlus
01:35:52 <jdnavarro> anyway
01:36:02 <jdnavarro> I'll just focus on the monoid laws
01:36:08 <jdnavarro> jle`: thanks!
01:36:09 <merijn> Alternative should match MonadPlus if the type is a MonadPlus instance
01:36:21 <merijn> Since Alternative is now a MonadPlus superclass, iirc
01:36:32 <jle`> yeah, so you'll probably have to worry about the MonadPlus laws and stuff if your type is also a Monad and has a MonadPlus instance
01:36:43 <jle`> s/probably//
01:37:18 <jle`> i think that must be what the comments on the semigroupoids package is referring to?  that if mplus = (<!>), it would break this or that MonadPlus law
01:37:22 <jle`> for that specific type
01:37:28 <jle`> *specific instance
01:37:44 <quchen2> jle`: I don't think MonadPlus and Alternative need to be related.
01:37:51 <quchen2> Alternative is pretty law-less anyway.
01:38:02 <YellowOnion> :t xor
01:38:04 <lambdabot> Bits a => a -> a -> a
01:38:07 <quchen2> For example, nothing relates <*> and empty.
01:38:18 <jle`> so you don't think that mplus = (<|>) is as implied of a thing as return = pure?
01:38:34 <quchen2> return = pure isn't implied, it's explicitly mentioned as a law.
01:38:46 <jle`> ah, yeah
01:39:00 <quchen2> mplus = (<|>) is valid and certainly common, but for whatever reason it's not a law.
01:39:00 <jle`> but do you think people expect mplus = (<|>) during usage?
01:39:13 <jle`> i guess it's not a law, so you're free to do what you want
01:39:21 <quchen2> I do expect that, at least.
01:39:30 <merijn> oh, my bad, MonadPlus doesn't have an Alternative superclass, no
01:39:40 <quchen2> Sure it does
01:39:50 <merijn> oh
01:39:53 <merijn> Search results lie...
01:39:59 <jle`> it might be a bit of a wonky API you're exposing, but if you document it, then I guess there aren't much moral qualms
01:40:01 <quchen2> That was part of the AMP
01:40:12 <merijn> Results lists "class Monad m => MonadPlus m", but the docs list Alternative
01:41:53 <jdnavarro> so in the end, the only laws an instance of `Alternative` must obey are the monoid laws? The `MonadPlus` laws are optional then?
01:42:00 <quchen2> jle`: I also expect Monoid to match Alternative
01:42:12 <quchen2> And then along comes Maybe
01:42:15 <jle`> it often doesn't
01:42:18 <jle`> yeah, i was going to say Maybe, heh
01:42:33 <jle`> but having (<>) and (<|>) play redundant roles for Maybe might be less practical
01:42:52 <jle`> than being able to choose a Monoid instance with a choice of typeclass to utilize
01:43:18 <jle`> s/Monoid/monoid
01:43:42 <quchen2> Not being able to specify which class to use is a bit of a weakness of Haskell.
01:43:53 <quchen2> Not sure how to solve it though. Idris suggests one solution.
01:44:08 <jle`> i literally spend nights awake thinking about this
01:44:11 <quchen2> s/which class/which instance/
01:44:49 <jle`> maybe we can use rich text editors, and specify the instance by choice of font color
01:45:02 <merijn> quchen2: Then again I'm not sure the "specify an instance" solution is much better
01:45:13 <merijn> See edward's talk on that vs Scala's approach
01:45:32 <jle`> there are just a lot of messy-ish haskell things that boil down to nothing more than newtype wrapping and unwrapping
01:45:49 <jle`> the entire transformers library, for instance
01:47:09 <jdnavarro> I still don't get the point of optional laws for a type class like MonadPlus
01:47:21 <jdnavarro>  doesn't it defeat the purpose of having a law at all in the first place?
01:47:44 <jle`> it does, and i think it's just because people want to jam multiple types of functionality into the same typeclass
01:48:16 <edk> (which defeats the purpose of having typeclasses)
01:48:24 <jle`> mhm v.v
01:48:31 <quchen2> edk: Edward?
01:48:42 <Cale> Kind of... to be fair, most things which work with one sort of MonadPlus will still be useful with the other
01:48:52 <edk> i'm an edward k who's unrelated to edwardk 
01:49:01 <quchen2> I see.
01:49:03 <Cale> But yeah, it really ought to be two classes
01:49:07 <naudiz> hey, I'm trying to get stack working but it just keeps complaining about cabal :/ https://bpaste.net/show/1cfe537aeae9 any ideas?
01:52:06 <YellowOnion> My programs main bottleneck (75%) seems to be: zipWith xor xs ys, dumb question, what can someone possibly do about this?
01:52:56 <merijn> YellowOnion: Depends on the program, this is not a lot of context to go on
01:53:21 <YellowOnion> merijn, I'll paste my code.
01:53:57 <jle`> if xs and ys are anything other than lazy streams of values, you might want to switch to a type that's actually used for storing data, like array or vector. 
01:53:59 <lpaste_> YellowOnion pasted “No title” at http://lpaste.net/137414
01:54:31 <ttt_fff> why does <$> bind more closely than $ ?
01:54:34 <ttt_fff> this confuses me to no end
01:54:40 <merijn> YellowOnion: Why the parentheses around xor on line 22?
01:55:01 <YellowOnion> jle`, I've been avoiding vector for a while.
01:55:07 <jle`> ttt_fff: the point of ($) is to bind the loosest
01:55:12 <jle`> YellowOnion: any particular reason?
01:55:30 <ttt_fff> jle`; Yyeah, but <$> and $, looking alike, I'd like them to bind at the same level
01:56:20 <frerich> YellowOnion: I suspect a data structure which is more appropriate for holding file contents would help (i.e. more appropriate than a singly-linked list of Unicode characters). I'd try using ByteString.
01:56:28 <YellowOnion> jle`, merijn, for the parens no clue, as for vector because its confusing
01:56:30 <jle`> this looks like a straightforward use case for vector/array
01:56:46 <jle`> ah, it's about as confusing to use as []/list is, i think, though
01:57:00 <jle`> lists aren't really meant to be used for storing texts and things like that
01:57:05 <jle`> or storing containers of ordered data
01:58:49 <jle`> i guess list does have an advantage because you're streaming over an infinite list of [a,b,c]
01:58:56 <jle`> (btw, you can also just use pass <- replicateM 3 cs)
02:01:45 <jle`> you might want to benchmark with V.zipWith xor (V.fromList n (cycle pass)) cypherText, and pass in cipherText as a Vector
02:01:54 <jle`> you can just use V.fromList before you pass it in to get it as a vector
02:02:03 <YellowOnion> ahh sweet
02:02:14 <jle`> sorry, that should have been V.fromListN
02:02:33 <jle`> see, you just need to switch to V.zipWith (zipWith from Vector) and convert things to Vectors :)
02:02:55 <jle`> using V.fromList, V.fromListN
02:03:51 <jle`>  http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html
02:05:31 <YellowOnion> maybe I was looking at Unboxed or something, but I got some other code that could use this kind of optimisation too.
02:09:12 <naudiz> could someone please help me with stack? https://bpaste.net/show/1cfe537aeae9
02:10:27 <YellowOnion> jle`, you know the length function on the cipherText is probably making it slow as well, making it eval the entire list.
02:14:38 <AshyIsMe> naudiz: what happens if you try installing cabal directly with stack?
02:16:51 <naudiz> AshyIsMe: AshyIsMe "stack install cabal-install" gives me the same errors – as well as any other package
02:27:50 <YellowOnion> Wow, 1s -> 3.6ms jle`, this is amazing
02:32:38 * hackagebot network-carbon 1.0.4 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  https://hackage.haskell.org/package/network-carbon-1.0.4 (OliverCharles)
02:32:40 * hackagebot network-carbon 1.0.5 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  https://hackage.haskell.org/package/network-carbon-1.0.5 (OliverCharles)
02:40:42 * mniip realizes Hidney is actually called Hindley
02:41:49 <ely-se> Kidney Miner
02:41:54 <ely-se> Hurry, Coward!
02:43:21 <lamefun> Is there a way to make optparse-applicative feel less cheesy?
02:43:58 <benma> less cheesy?
02:45:02 <ely-se> eat the cheese
02:45:03 <lamefun> I mean, I'm defining an option-structure and then defining function where I have to replicate the exact order of the fields. Just seems a little cheesy to me.
02:46:29 <benma> interesting meaning of cheesy. others would call that redundant
02:47:44 <benma> lamefun: that is the nature of applicatives. 
02:48:10 <benma> lamefun: no one said you had to make an option record ;)
02:48:27 <lamefun> I'd call that redundant if I had to repeat field names in the function for it to compile, eg. options = do quiet <- opt "q,quiet"; fullscreen <- opt "f,fullscreen"; return $ Options { optQuiet = quiet, optFullscreen = fullscreen }.
02:48:29 <benma> lamefun: maybe you can use lenses to do some magic
02:49:20 <benma> lamefun: i guess you either have to repeat the order, or repeat the record names
02:49:47 <benma> what other ways are there to populate a structure / record?
02:50:39 <benma> you could possibly define some typeclass and implement that on the record fields and have optparse figure out the rest; but then you would repeat the record fields in the typeclass defs
02:50:43 <benma> instance defs
02:52:02 <nshepperd> optQuiet <- opt "q,quiet" ; return Options{..}
02:52:21 <nshepperd> pretty sure there's an extension that lets you do that
02:52:38 <naudiz> what are other solvers for stack?
02:53:00 <lamefun> yes, but Options.Applicative.Parser is not a monad.
02:54:11 <nshepperd> RecordWildCards or something
02:55:31 <chpatrick> that's the one
02:55:49 <chpatrick> there's also NamedFieldPuns if you want to write it out yourself: return Options { optQuiet }
02:56:04 <nshepperd> (\optQuiet optFullscreen -> Options{..}) <$> opt "q,quiet" <*> opt "f,fullscreen"
02:56:42 <lamefun> nshepperd, what's the advantage..?
02:57:11 <lamefun> If my option list is long, I'll still have a lot of space between the first lambda and the actual option definition.
02:57:52 <nshepperd> that's true
02:57:55 <lamefun> eg. if I get the option order wrong and the options I got wrong have the same types, the program will compile but behave incorrectly.
02:59:29 <nshepperd> well, you can do a traversal over a list of option setters
03:00:56 <nshepperd> ie. instead of (opt "q,quiet" :: f a), use (_ (opt "q,quiet") :: f (Options -> Options))
03:01:31 <chpatrick> I have a kinda overkill library for this :)
03:01:33 <chpatrick> @hackage codec
03:01:33 <lambdabot> http://hackage.haskell.org/package/codec
03:01:45 <nshepperd> that being a function that returns a new Options object with the optQuiet set
03:02:47 <chpatrick> Options $>> f_optQuiet `having` opt "q,quiet"
03:03:23 <benma> hey, for the people using stack: please enlighten me on how you run your code runhaskell-style, i.e. not compiling it
03:03:35 <benma> and then how you run it with compilation
03:04:08 <benma> both is fine actually, but `stack exec ./.stack-work/a/myriad/of/subdirs/program`
03:04:14 <benma> that is too clumsy
03:06:04 <bitonic> benma: `stack exec program` works
03:06:04 <nshepperd> chpatrick: intriguing! i wondered how to do this typesafely
03:06:13 <bitonic> without specifying the full path
03:07:33 <nshepperd> well, without being partial
03:08:26 <chpatrick> nshepperd: it can do some other tricks too
03:08:40 <chpatrick> like specifying certain record fields and auto-filling the rest with Default
03:18:24 <kuribas> Does anyone understand how passes work when INLINEing or using RULES?
03:19:01 <kuribas> Are these just identical passes that are run a few times, or has each pass a special meaning?
03:27:26 <kuribas> also, why does a NOINLINE pragma make a SPECIALIZE pragma useless?
03:32:41 <piezoid> kuribas: NOINLINE mean no code duplication, allowing toplevel unsafePerformIO to be run once. Specializing duplicate the code.
03:33:31 <kuribas> piezoid: I don't see how specializing duplicates code...
03:33:51 <kuribas> piezoid: you mean for values?
03:34:53 <piezoid> I think it keeps a generic version and a specialized one
03:35:52 <kuribas> How can I specialize code for which I want rewrite rules?
03:36:41 <kuribas> So it uses the specialized version when the rewrite rule doesn't fire?
03:38:48 <kuribas> Oh I think I found it...
03:39:58 <piezoid> kuribas: I believe SPECIALIZE is implemented with rewrite rules
03:40:32 <piezoid> kuribas: have you seen https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Core2CorePipeline ?
03:40:40 <kuribas> I tried {-# SPECIALIZE NOINLINE ... #-}, but I still get the warning that the rules may not fire.
03:41:01 <BartAdv> is there anything special in newtype Foo = Foo { runFoo :: xxxxxx } ? I see this idiom often, wondering what more than what I can read from the signature am I missing
03:41:31 <kuribas> piezoid: thanks, I'll have a look at it.
03:41:40 <merijn> BartAdv: It's just (ab)using record notation to auto-generate an unwrapping function
03:42:19 <merijn> It's equivalent to "newtype Foo = Foo xxxxx" and "runFoo :: Foo -> xxxxx; runFoo (Foo x) = x"
03:42:35 <BartAdv> ah, so it's nothing really more than I can read from signature
03:42:49 <merijn> Right
03:44:22 <kuribas> Are phases run in reverse order?
03:44:33 <kuribas> Like first 2, then 1, then 0?
03:48:47 <piezoid> kuribas: yes, you can observe the rules firings with -ddump-rule-firing https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html#controlling-rules
03:49:37 <kuribas> piezoid: thanks, I'll try that.
04:08:43 <kuribas> piezoid: great, I see they are fire now :)
04:15:47 <piezoid> kuribas: sledgehammer version : -ddump-rule-firings -ddump-simpl-iterations -dsuppress-all -dppr-case-as-let
04:16:22 <piezoid> also -dsuppress-uniques if you are diffing the outputs
04:18:45 <kuribas> neat!
04:18:55 <kuribas> I see that everything gets inlined and specialized :)
04:22:24 <kuribas> Now I can write more efficient specialized versions of more generic functions, while keeping the same API;
04:30:29 <YellowOnion> I think I figured out why Vector scares me, trying to get it to work with Linear :-|
04:36:09 <saulzar> YellowOnion, reifyVector? 
04:38:11 <YellowOnion> saulzar, I have no clue how I would use that function
04:38:54 <kuribas> YellowOnion: Data.Vector?
04:39:51 <YellowOnion> I'm using [Linear.V2] in my program
04:39:58 <mniip> I think they mean they're unfamiliar with reflection/reification
04:40:09 <saulzar> YellowOnion, I think you can just call reifyVector $ \(v::V2 Int) ->  v + (V2 3 3)
04:40:34 <ttt_fff> haskell or sleep
04:40:37 <ttt_fff> taht is my decision right now
04:40:40 <ttt_fff> to write more haskell or to sleep
04:40:45 <ttt_fff> that is the question
04:40:46 <dramforever> sleep
04:40:47 <saulzar> YellowOnion, i.e. it calls your function with the converted V2 
04:41:01 <YellowOnion> I have no education in Linear algebra, most of the stuff I've done was in high school vector addtion
04:41:28 <kuribas> ttt_fff: sleep
04:41:33 <mniip> ttt_fff, as a russian saying goes, the morning is wiser than the evening
04:42:10 <ttt_fff> it's 4:41 am
04:42:13 <ttt_fff> so I should code more?
04:42:13 <maerwald> mniip: because one is sober in the morning?
04:42:50 <YellowOnion> saulzar, I don't think that'll help that much, my main issue is the list of V2s than the V2s itself.
04:42:58 <mniip> maerwald, that too
04:43:36 <saulzar> YellowOnion, Hang on - what are you actually trying to do here?
04:44:00 <saulzar> YellowOnion, I assumed you wanted to convert between Data.Vector and Linear - but maybe not?
04:44:14 <YellowOnion> saulzar, its an nbody sim
04:45:50 <YellowOnion> ahh and parList aint gonna work now either, hmm
04:46:31 <saulzar> YellowOnion, Yeah but what are you having trouble with?
04:47:57 <YellowOnion> nothing in particular, I just wasn't sure about how to even start replacing stuff with vector, Just going through now and replacing all the List stuff.
04:48:16 <saulzar> I see
04:50:34 <latro`a> suppose I have a lattice, some of the sites of which have an object at them; is there a good data structure which provides "two-way lookup", i.e. an object can tell me where it is and a site can tell me what the object located there is?
04:50:37 <Fuuzetsu> OK, so I'm getting ‘/usr/bin/ld: .stack-work/dist/x86_64-linux/Cabal-1.18.1.5/build/Foo/Bar/Baz.dyn_o:
04:50:38 <Fuuzetsu> relocation R_X86_64_PC32 against symbol `ihaskellzminlinezmrzm0zi1zi0zi0_FooziBarziBaz_zdwa1_closure' can not be used when making a shared object; recompile with -fPIC’; building the package providing Foo/Bar/Baz with -fPIC does not help at all – this is on a CI box; it all works fine on my machine without any -fPIC stuff… Do I need a special GHC on the CI? (cross-posted from #ghc)
04:50:56 <YellowOnion> saulzar, especially this stuff that contains infinite lists.
04:51:43 <saulzar> YellowOnion, Yes, it's a little trickier. Though you now get indexing...
04:52:10 <saulzar> and index out of bounds.. :)
04:52:25 <latro`a> (for context, I really need to go through each object and examine its local environment, so ideally I would not actually iterate through the lattice but rather only through the current positions of the objects)
04:55:39 <saulzar> latro`a, So you want some kind of 2D array:  Array a   with functions,   lookup :: (Int, Int) -> Array a -> Maybe a and  index :: a -> (Int, Int)  or something like this?
04:56:14 * ely-se implements 2D arrays as Map (K, K) V :P
04:56:39 <latro`a> saulzar: that's pretty much it (although my current application is simpler as it is a 1D lattice))
04:56:52 <latro`a> (but this will become 2D, so 2D thinking is appreciated)
04:56:59 <dramforever> latro`a: can you store the index in the object?
04:57:10 <dramforever> that's a bit...hard to manage, though
04:57:30 <saulzar> latro`a, Yeah, I'm not sure the best way there. You can store the index but it's ugly because now you've got to make sure to keep them in sync
04:57:35 <latro`a> I could, which is the "ugly" way that I had in mind
04:58:02 <latro`a> perhaps it would be better to give a bit more context, because maybe I'm thinking about this the wrong way
04:58:19 <saulzar> Usually ends in grief, because it's a pain to have the same information in two places
04:59:27 <latro`a> there's a lattice with atoms on it, each atom can move to any of its nearest neighbor sites, with different rate constants depending on the local environment
04:59:28 <dramforever> saulzar: btw are you really sure you need the index -> object array?
05:00:03 <dramforever> sorry I meant object -> index function
05:00:04 <saulzar> dramforever, I was just trying to clarify what he was after..
05:00:11 <dramforever> ouch wrong person
05:00:19 <saulzar> Though you can probably do something like implement a lookup function which stores the index with the result. e.g. lookup :: k -> Map k a -> (k, a)
05:00:22 <dramforever> latro`a: can you just work positions?
05:00:35 <dramforever> saulzar: that function is useless isn't it
05:00:47 <dramforever> I mean, trivial to implement
05:00:50 <saulzar> dramforever, Yes
05:00:53 <j_h> Hi. I just dropped by to tell somebody in charge that I miss the cabal packages ttrie and pcg-random in the haskell overlay.
05:00:58 <dramforever> and you don't really need it
05:01:28 <dramforever> latro`a: can you just work with positions?
05:01:28 <saulzar> dramforever, No - I'm just suggesting you could carry the key around as long as needed in the tuple
05:01:36 <dramforever> okay
05:01:43 <latro`a> the main thing is that there is a privileged location called the step edge, and any motion which changes the position of the step edge has special rules
05:01:51 <saulzar> dramforever, Rather than storing it in the container, at which point it can get out of sync
05:01:58 <dramforever> exactly
05:02:14 <latro`a> in 1D it is a single site, and the only other important site is the one two units to the right of the step edge
05:02:30 <dramforever> so when could an atom move?
05:02:44 <Ulrar> Is there something as simple as simpleHTTP but for HTTPS requests ?
05:02:44 <benma> bitonic: thanks. i wish i wouldn't have to specify the program in `stack exec program`. it is redundant information, i only have one executable in my .cabal. `cabal run` was pretty nice in that regard
05:03:06 <latro`a> in the 1D case most of the atoms can go either left or right at any given time; only a few special moves are actually forbidden
05:03:13 <bitonic> benma: given the multi-package nature of cabal, I think it makes sense that you have to specify it
05:03:27 <bitonic> well, actually a single .cabal file can also produce multiple binaries
05:03:44 <benma> i know it can, but a nice default would make life easier
05:03:48 <benma> as evidenced by `cabal run`
05:04:03 <dramforever> I wonder what cabal exec is for..
05:04:27 <j_h> Can anybody ack the lack of ttrie & pcg-random in the haskell overlay? If not, I enter both in the bugtracker.
05:04:34 <saulzar> latro`a, Make a function which operates on the (key, value) and potentially moves it as needed?
05:05:05 <maerwald> j_h: overlay?
05:05:11 <saulzar> dramforever, I mainly use it for runing ghc --make in a cabal sandbox, e.g.  cabal exec -- ghc --make Foo.hs -o foo
05:05:34 <maerwald> j_h: maybe you should add that you are using gentoo?
05:05:42 <dramforever> saulzar: yes, it was for development
05:05:50 <dramforever> like building stuff or ghci or something
05:06:33 <j_h> maerwald: damn, confused the channel, thought to be in #gentoo-haskell. Please excuse the time wasted.
05:13:07 <djanatyn> 8
05:22:45 * hackagebot binary 0.7.6.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.7.6.0 (LennartKolmodin)
05:25:36 <latro`a_> saulzar: actually, now I see that k -> Map k a -> (k,a) doesn't really serve my purpose, because I want to iterate over a, retrieve the k corresponding to a, and then look up the possible a for a neighboring k
05:25:48 <latro`a_> I want to iterate over a because there are far more sites than atoms
05:28:24 <dramforever> :t Data.Map.values
05:28:25 <lambdabot> Not in scope: ‘Data.Map.values’
05:28:29 <dramforever> =(
05:28:45 <dramforever> latro`a: anyway there's a function that allows you to get all the values stored in a map
05:28:48 <dramforever> in Data.Map
05:30:50 <kuribas> :t Data.Map.toList
05:30:52 <lambdabot> M.Map k a -> [(k, a)]
05:33:07 <latro`a> hmm...yes, that would work, didn't think about that
05:33:15 <xandaros> Trying to use the _head prism from lens on a list, but it complains about the list elements not being monoids. Why do they need to be? (Same problem with _last, _init and _tail work fine, though)
05:33:16 <latro`a> thanks!
05:34:17 <xandaros> And that's why you should proof-read before sending... make that comma after _last a semicolon, lol
05:34:27 <BartAdv> novice question: a library I use is probably doing some wrong call to sqlite and my app is crashing with "sqlite3 returned ErrorError while attempting to perform step". What would be the most efficient way of debugging such thing? I've tracked it to the one function that is internal to this lib. Should I just go to the lib dir, ruh ghci from there and poke
05:34:27 <BartAdv> around?
05:36:34 <Taneb> xandaros, how are you trying to use it?
05:36:41 <Taneb> > "hello" & _head .~ 'j'
05:36:43 <lambdabot>  "jello"
05:37:24 <xandaros> Well, I tried to read it with ^.: ([1,2,3]:[Float])^._head
05:37:35 <mniip> you can't read a prism
05:38:07 <xandaros> :/
05:38:11 <mniip> you can view it, to get a Maybe value
05:39:07 <mniip> er
05:39:12 <mniip> preview is the function I think
05:39:51 <kuribas> BartAdv: I would try to find the simplest code that triggers the bug, and then dig in the source.
05:39:52 <Taneb> xandaros, _head and _tail etc are actually just traversals, and you can't read them directly
05:40:00 <Taneb> What would []^._head be?
05:40:08 <mniip> Taneb, prisms, not traversals
05:40:09 <xandaros> an error
05:40:15 <Taneb> :t _head
05:40:16 <lambdabot> (Applicative f, Cons s s a a) => (a -> f a) -> s -> f s
05:40:20 <Taneb> No, just a traversal
05:40:31 <mniip> pretty sure they qualify for a prism
05:40:37 <Taneb> :t _Just
05:40:38 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
05:40:40 <kuribas> BartAdv: Then maybe put some traceShow functions in the library.
05:40:50 <Taneb> mniip, that's a Prism, note the Choice p
05:40:51 <mniip> ah
05:40:53 <mniip> you are right
05:41:11 <mniip> _head can fail *and* needs context to review
05:41:48 <Taneb> xandaros, lens instead of erroring uses the Monoid instance to provide a default value
05:41:50 <xandaros> I can still compose a prism with a lens and get a new prism, though, can't I?
05:42:02 <Taneb> No, prism.lens gives you a traversal
05:42:23 <xandaros> and I assume preview does not work on a traversal? -_-
05:42:28 <Taneb> :t preview
05:42:30 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
05:42:36 <Taneb> preview does work on a Traversal!
05:42:42 <xandaros> oh, good
05:42:48 <Taneb> > preview traverse "hello"
05:42:50 <lambdabot>  Just 'h'
05:42:55 <mniip> Taneb, do you know all lenslike types by heart :o
05:43:11 <Taneb> mniip, more or less
05:43:26 <mniip> dang
05:43:27 <xandaros> They are black magic to me, lol
05:43:38 <Taneb> xandaros, it takes practise but you get used to it
05:43:44 <dramforever> Taneb: how did you do that?
05:44:04 <mniip> they aren't for me, but I'd have to have 10 Control.Lens sources open to use them
05:44:17 <Taneb> dramforever, practice, mostly, and also helping develop the library, and also trying to help people in situations like this
05:44:41 <Taneb> mniip, I don't know Review very well, I will admit
05:44:46 <maerwald> xandaros: yes, haskell is not able to solve the "complexity" problem consistently... the complexity is rather just moved to the type level instead of being eliminated
05:44:58 <maerwald> which is still better
05:45:06 <dramforever> oh =)
05:45:11 <mniip> I have a basic understanding of the Lens type though
05:45:19 <dramforever> btw the cheat sheet doesn't help at all
05:45:34 <mniip> it is polymorphic in the functor, and there's a functor that lets us read the value, and a functor that lets use set the value
05:45:39 <xandaros> I have a list that can never get empty, I want to get the first element, which is a record and get one of the fields. In a state monad. It can't be that difficult, lol
05:46:54 <Taneb> :t use (singular head . _1)
05:46:56 <lambdabot>     Couldn't match type ‘(->) a0’ with ‘[]’
05:46:56 <lambdabot>     Expected type: Traversing (->) (Const b) s0 s0 a0 a0
05:46:56 <lambdabot>       Actual type: [s0
05:47:09 <Taneb> Dang
05:47:43 <Taneb> :t use (singular _head . _1)
05:47:44 <lambdabot> (Field1 a a b b, Cons s s a a, MonadState s m) => m b
05:47:54 <Taneb> xandaros, something like that is what you want
05:48:06 <xandaros> What does singular even do?
05:48:17 <Taneb> "singular" is a function which lets you say "This Traversal is actually a Lens, trust me on this"
05:48:17 <dramforever> :t singular
05:48:19 <lambdabot> (Functor f, Conjoined p) => Traversing p f s t a a -> Over p f s t a a
05:48:27 <Taneb> singular :: Traversal s t a a          -> Lens s t a a
05:48:30 <YellowOnion> is there a 'forever' that uses >>= instead of >>?
05:48:31 <xandaros> ah, that is good to know
05:48:52 <Taneb> It's kind of magic
05:48:54 <dramforever> :t \a -> fix (a >>=)
05:48:55 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> b
05:48:55 <lambdabot>     Expected type: (a -> a -> b) -> a -> a -> b
05:48:55 <lambdabot>       Actual type: (a -> a -> b) -> a -> b
05:48:57 <dramforever> =(
05:49:06 <dramforever> :t \a -> fix (a >=>)
05:49:07 <lambdabot> Monad m => (b -> m b) -> b -> m c
05:49:08 <mniip> mfix?
05:49:13 <dramforever> YellowOnion: that?
05:49:39 <mniip> :t mfix
05:49:40 <lambdabot> MonadFix m => (a -> m a) -> m a
05:50:30 <YellowOnion> dramforever, just to double check, could I use this as a sort of poor mans state?
05:50:37 <dramforever> yes
05:50:40 <dramforever> :t runStatT
05:50:41 <lambdabot>     Not in scope: ‘runStatT’
05:50:42 <lambdabot>     Perhaps you meant one of these:
05:50:42 <lambdabot>       ‘runState’ (imported from Control.Monad.State),
05:50:44 <dramforever> :t runState
05:50:45 <xandaros> Taneb: Thank you, that worked :)
05:50:46 <lambdabot> State s a -> s -> (a, s)
05:50:57 <Taneb> xandaros, :)
05:51:02 <mniip> YellowOnion, sounds like you might want StateT
05:52:05 <shimmer> Got a question about pattern matching in using let bindings.
05:52:16 <YellowOnion> I just want something like \x -> do getLine; let y = func x; print y; return y
05:52:25 <YellowOnion> to be repeated over and over.
05:52:49 <dramforever> YellowOnion: are you sure?
05:53:20 <dramforever> y doesn't even depend on the monad
05:53:28 <shimmer> I'm reading Learn you a Haskell, and the State Monad instance has binding defined like this: instance Monad (State s) where  
05:53:29 <shimmer>     return x = State $ \s -> (x,s)  
05:53:29 <shimmer>     (State h) >>= f = State $ \s -> let (a, newState) = h s  
05:53:29 <shimmer>                                         (State g) = f a  
05:53:29 <shimmer>                                     in  g newState
05:53:32 <dramforever> oh sorry I misunderstood
05:53:40 <dramforever> YellowOnion: but something like this might help
05:53:44 <dramforever> :t iterate
05:53:45 <lambdabot> (a -> a) -> a -> [a]
05:53:53 <dramforever> > iterate (+1) 0
05:53:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:54:22 <dramforever> shimmer: and the question is...
05:54:28 <YellowOnion> I just want some interactive inspection of the function iterated over itself.
05:54:54 <mniip> YellowOnion, mapM_ (\x -> getLine >> print x) $ iterate func initialvalue
05:54:55 <dramforever> YellowOnion: and you could use something like mapM_ (\x -> print x >> void getLine)
05:55:07 <dramforever> sorry gotta run
05:55:09 <dramforever> bye
05:55:46 <YellowOnion> mipp, ahh thanks that will work I think
05:55:49 <shimmer> I thought that pattern matching was supposed to match the arguments on the left of the equals and apply it to the function on the right side, but in "let (a, newState) = h s" it seems they are applying pattern matching on the return value of the h s function, or am I not reading this right?
05:56:43 <geekosaur> shimmer, you are reading it correctly
05:56:47 <ely-se> The pattern is matched on "h s"
05:56:55 <geekosaur> consider that your hypothesis doesn't work for case either
05:57:33 <geekosaur> (case is actually the pattern matching mechanism; both the other uses get rewritten into expressions involving case)
05:58:12 <shimmer> So, how do you, (or the compiler for that matter) know when the pattern is supposed to be matched on the return value, or the arguments to a function? Is there some reference I can read that might clear this distinction up a bit?
05:58:35 <ely-se> It's not about functions.
05:58:45 <ely-se> Pattern matching and functions are orthogonal.
05:58:48 <geekosaur> you might reread what I just wrote
05:59:17 <ely-se> let p = x matches x against p, whether x is function application or not is irrelevant
05:59:42 <ely-se> > let (a, b) = (1, 2) in a + b
05:59:43 <lambdabot>  3
06:00:05 <kuribas> shimmer: in a let expression, the lhs is matched on the return value, in a function the lhs is matched on the function arguments, and bound inside the rhs.
06:00:34 <kuribas> shimmer: that is, the matched variables are bound inside the rhs.
06:02:36 <kuribas> shimmer: in fact, when matching a value, matched variables are also bound in the rhs.
06:02:53 <kuribas> > let x = 1:x in x
06:02:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:06:00 <kuribas> shimmer: hm, disregard what I said about "let".  A value matches the rhs directly, a function matches the arguments after applying the function.
06:07:47 <kuribas> > let f (a, b) = (b, a) in f (1, 2)
06:07:49 <lambdabot>  (2,1)
06:09:09 <shimmer> So...something like this "let boot x y z = x * y + z in boot 3 4 2 " would be considered a function definition while "let (a, newState) = h s" would be considered and expression?
06:10:50 <obadz> Is ghc-mod support in vim comparable to that of emacs?
06:11:06 <shimmer> or not "function definition", but value...
06:11:11 <obadz> Or is one at a more advanced stage than the other?
06:11:11 <merijn> shimmer: The latter is part of do-notation's syntactic sugar
06:11:20 <merijn> shimmer: And it translates to let/in
06:11:57 <mniip> shimmer, both are called declarations
06:12:14 <mniip> you can write 'f x = y' in the top level as well as '(x, z) = y'
06:12:24 <kuribas> shimmer: functions are values too actually.  Think of that as "let boot = \x y z -> x * y + z in boot 3 4 2"
06:12:37 <mniip> 'f x = y' is a function declaration
06:12:44 <mniip> '(x, z) = y' is a value declaration
06:12:58 <merijn> mniip: That implies functions are not values, which is wrong
06:13:11 <mniip> merijn, that's what it is syntax-wise
06:13:13 <merijn> Functions are values as much as the next thing
06:13:44 <mniip> are we talking about syntax or semantics here
06:13:51 <kuribas> shimmer: the thing that matters is that pattern matching on function arguments occurs when applying the function.
06:16:59 <shimmer> I think I understand, thank you for your help.
06:17:05 <nshepperd> I suppose it does seem a bit odd that the direction of the binding is different for data constructors vs functions
06:18:06 <nshepperd> 'let Foo a b = ... in _' does destructuring bind, vs 'let bar a b = ... in _' which defines a function
06:19:00 <shimmer> Yeah, and I think I just needed a way to get distinction between the two and I supposed my answer is to look for the "f a b c" on the lhs when binding to values on the right. 
06:21:27 <shimmer> Most of the time anyway, unless the function returns another function which is then bound to the lhs
06:21:37 <tylerparker> \j #hypothesis
06:22:05 <shimmer> in which case g a b c would be defined on the rhs
06:22:48 <frerich> mniip: <pedant>I think anything involving a '=' is called a definition. Declarations are things with '::' or keywords like data/newtype/class/instance/default/foreign - or fixity declarations.</pedant>
06:23:47 <merijn> frerich: Odd pendantism since I've NEVER seen that distinction before
06:23:55 <merijn> Why would a type signature be a declaration?
06:24:21 <geekosaur> (2 :: Int)
06:24:22 <frerich> merijn: Because that's what the Haskell report calls them, e.g. https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
06:24:32 <mniip> frerich, quoting Language.Haskell.TH, data Dec = FunD | ValD | DataD | NewtypeD | TySynD | ClassD | InstanceD | SigD | ...
06:25:03 <merijn> frerich: Eh, the report calls function definitions declarations too...
06:25:20 <bergmark> decl -> (funlhs | pat) rhs
06:25:35 <merijn> Yeah, that line
06:25:36 <mniip> bergmark, farm from true
06:25:37 <bergmark> woops n/m  wrote the trong thing :)
06:25:50 <bergmark> or not... i'm double confusing myself
06:25:59 <mniip> a function declaration can span multiple clauses
06:26:06 <bergmark> mniip: how is that far from true? it's in the report
06:26:27 <frerich> merijn, bergmark: I didn't refer to the grammar, I meant the chapter as a whole: If you search for 'function declaration' you get no hits. 'function definition' however does get hits.
06:26:42 <bergmark> frerich: what do you think decl means?
06:27:13 <merijn> frerich: So you're going to argue that the report establishes the meaning of "declaration" from the fact that that term isn't actually used?
06:27:23 <mniip> bergmark, hmm, I don't think that syntax tree is totally valid because it requires more post-processing
06:27:42 <frerich> bergmark: That's an identifier for a production in the grammar.
06:27:59 <frerich> merijn: I argue that contrary to 'function declaration', the term 'function definition' *is* used.
06:28:01 <ttt_fff> omg, my haskell code these days is so beautiful
06:28:05 <bergmark> but it does mention "method declarations"
06:28:06 <ttt_fff> i'm like this arg order is right
06:28:09 <ttt_fff> don't need that arg there
06:28:11 <ttt_fff> dont' need this here
06:28:17 <ttt_fff> BAM, it all fits on one 160 character long line
06:28:20 <ttt_fff> I'm fucking awesome
06:28:29 <frerich> merijn, bergmark: But I guess I already regret trying to nitpick about this kind of stuff.
06:28:30 <maerwald> ttt_fff: and probably no one else will understand it
06:28:45 <ttt_fff> there's only a few <$>, >>=, <<=, flip, fmap, liftA2s involved
06:28:46 <merijn> ttt_fff: ugh
06:28:47 <kuribas> ttt_fff: 160 omg...
06:28:53 <merijn> ttt_fff: Lines over 80 should be banned
06:28:59 <maerwald> why
06:29:00 <AndChat194889> Hi
06:29:29 <merijn> maerwald: Too wide to read comfortably
06:29:30 <ttt_fff> I can probably cut it down to 80 line if I go from 6-10 char long data constructor names down to 3-char long data contructor names
06:29:43 <frerich> bergmark: By the 'decl -> (funlhs | pat) rhs' logic, you could call everything a module. Not a very useful thing, I guess.
06:29:45 <merijn> ttt_fff: Or you just move things into a where clause...
06:29:46 <nshepperd> because some of us still code on 80 column green vt100s, young whippersnapper!
06:29:46 <AndChat194889> Yo 
06:29:52 <maerwald> merijn: why is that? did you cut your monitor in half?
06:30:00 <ttt_fff> maerwald++
06:30:14 <maerwald> and the terminal argument is so old, that no one should care anymore
06:30:14 <mniip> where-clauses for data, ughhh
06:30:25 <merijn> maerwald: Because research shows that reading lines longer than 52-72 characters slows you down due to too much eye movement
06:30:27 <mniip> that belongs in let!
06:30:28 <saep> With 80 columns, I can have 3 editor windows comfortably next to each other without line wraps. :o
06:30:32 <maerwald> merijn: reference?
06:30:41 <merijn> maerwald: It's the reason why newspaper/paper columns use widths like that
06:30:47 <merijn> maerwald: Lemme see if I can find it
06:30:49 <kuribas> maerwald: also for readability.
06:30:56 <ttt_fff> saep: I do the same, a 80-char window on the lhs for shell + ghci, a 160-char wide vim on the right for actual coding
06:31:07 <ttt_fff> merijn: you and ur research 
06:31:36 <merijn> maerwald: tbh, I think it's from my typography book, so I'm not sure I can find an academic paper reference
06:32:08 <mniip> mfw my display is only 190 characters wide
06:32:18 <saep> Also, Reading 160 character long lines on a smartphone sucks. 
06:32:20 <demize> merijn: http://viget.com/inspire/the-line-length-misconception
06:32:27 <maerwald> saep: weird argument
06:32:48 <maerwald> reading code on smartphones isn't the main concern when I write code
06:32:50 <saep> I often read code on the train. :S
06:32:50 <orion> Given a type Resolution = (Int, Int) and a Vector Resolution, what functions should I look at if I want to find the Vector value with the greatest Resolution?
06:33:21 <kuribas> demize: I don't know about research, but I find very long lines very hard to read.
06:33:33 <maerwald> "They found that line length no impact on comprehension on the screen"
06:33:34 <maerwald> aha
06:33:37 <merijn> maerwald: Right, so research shows that for on-screen the optimal length is 95
06:33:42 <merijn> http://psychology.wichita.edu/surl/usabilitynews/72/LineLength.asp
06:33:54 <kuribas> orion: Data.Vector.maximum ?
06:34:12 <maerwald> merijn: they didn't test anything above 95
06:34:18 <maerwald> so that research is pretty poor
06:34:32 <kuribas> orion: how do you compare Resolution?
06:35:01 <ttt_fff> that's right
06:35:16 <ttt_fff> how do we know that reading a 240 char long line is not better than 95, eh?
06:35:45 <frerich> I think this is #haskell-blah material.
06:36:59 <chpatrick> maybe a dumb question
06:37:03 <chpatrick> can you "upgrade" an applicative to a monad the same way you can upgrade an apply to applicative?
06:37:14 <chpatrick> ie by adding a missing operation as data
06:37:19 <ttt_fff> there are no dumb questions, but there are dumb people, for example, ttt_fff
06:37:23 <chpatrick> and if so what is the smallest thing you need to add
06:37:51 <frerich> orion: I think if you define 'maximum' as in 'most pixels', then you could use 'V.maximumBy (comparing (*)) v'
06:37:54 <chpatrick> I know you can "upgrade" any functor with free
06:38:04 <chpatrick> but is there anything that takes advantage of the extra power that applicatives have
06:39:14 <orion> kuribas: Indeed, I compare Resolutions by multiplying them.
06:39:19 <frerich> orion: Sorry, that would be 'comparing (uncurry (*))'
06:39:36 <orion> frerich: Oh cool, I've never heard of uncurry before.
06:39:38 <kuribas> :t comparing (uncurry (*))
06:39:40 <lambdabot> (Num a, Ord a) => (a, a) -> (a, a) -> Ordering
06:40:02 <orion> Thank you.
06:40:29 <ely-se> chpatrick: what do you mean by upgrading?
06:40:56 <chpatrick> ely-se: I mean instance Applicative f => Monad (Upgraded f)
06:41:24 <chpatrick> in the same sense that instance Apply f => Applicative (MaybeApply f)
06:41:30 <chpatrick> or instance Functor f => Monad (Free f)
06:41:51 <chpatrick> or instance Functor (Coyoneda f)
06:42:20 <chpatrick> all of these types "upgrade" f to have some instance
06:42:37 <chpatrick> I'm wondering if there's some way to do Applicative -> Monad that's simpler than Free
06:44:20 <lamefun> Why doesn't Haskell have function-guessing? Is there a fundamental reason?
06:44:31 <mniip> function-guessing?
06:44:51 <hunteriam> Does anyone here have a link to Conan Elliot's (recent?) talk on what frp actually means?
06:45:04 <hunteriam> I googled around and couldn't find anything that fit the bill
06:45:19 <chpatrick> hunteriam: I watched it yesterday and it wasn't too clear to me
06:45:35 <hunteriam> Do you have a link chpatrick
06:45:38 <kuribas> hunteriam: http://begriffs.com/posts/2015-07-22-essence-of-frp.html ?
06:45:39 <geekosaur> "Conal"
06:45:46 <chpatrick> I mean it just looked like a 45 minute talk on the instances of (->) Double
06:45:46 <hunteriam> Autocorrect
06:45:50 <hunteriam> I did type conal
06:46:10 <lamefun> mniip, ie. determining right function based on type, eg. update :: Checksum -> Data -> Checksum, update GameWorld -> Time -> GameWorld, etc.
06:46:35 <chpatrick> lamefun: that's what typeclasses do
06:46:35 <mniip> it does have that
06:47:10 <ely-se> lamefun: Do you mean overloading? It's still vague.
06:47:14 <lamefun> yes, but then I'd have to put every function into type classes
06:47:22 <kuribas> I wonder about how exact time in FRP can work, since time in computers is imprecise (clock drift, not synchronous clocks, etc).
06:48:00 <ely-se> kuribas: it's not about absolute instants. It's about values varying in time.
06:48:03 <nshepperd> chpatrick: I suppose you can do "data Upgrade f a = Upgrade (f a) | Join (f (Upgrade f a))" but that's pretty pathetic in that it (the monad instance) makes use of 'pure' but not '<*>'
06:48:05 <chpatrick> lamefun: then why not give them different names?
06:48:16 <lamefun> I'd much rather have "doStuff :: Qux -> Meep; doStuff = truthinate $ silly $ moo" instead of eg. "doStuff = quxTruthinate $ quxSilly $ quxMoo".
06:48:23 <chpatrick> nshepperd: that's just Free though
06:48:27 <chpatrick> well
06:48:28 <chpatrick> almost
06:48:30 <nshepperd> yeah, pretty much
06:48:39 <chpatrick> I'm looking for something that can use the extra power of applicatives
06:49:07 <kuribas> ely-se: what I understood from the Conal video, is that when you leave out the time argument in the implementation, then it's not real FRP?
06:49:14 <nshepperd> I asked about this sort of thing before, looking for a minimal definition of Monad on top of Applicative, and didn't find any really satisfying one
06:50:00 <chpatrick> lamefun: the thing is though that if these functions' types have nothing in common then maybe they shouldn't be called the same thing
06:50:00 <lamefun> Because Qux is only in one place (type signature) and not before every function name related to Qux
06:50:12 <kuribas> nshepperd: is every Applicative a Monad?
06:50:15 <chpatrick> no
06:50:32 <rom1504> lamefun: what about making truthinate, silly and moo generic ?
06:51:06 <ely-se> kuribas: no; Applicative lacks (>>=)
06:51:21 <ely-se> But every monad is an applicative.
06:51:53 <kuribas> (<*>) = liftM2 ($) right?
06:52:42 <chpatrick> yep
06:52:44 <chpatrick> :t ap
06:52:45 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:52:55 <mniip> f <*> x = f >>= (x >>=)
06:53:11 <kuribas> :t liftM2 ($)
06:53:12 <lambdabot> Monad m => m (a -> r) -> m a -> m r
06:53:25 <chpatrick> mniip: that ain't right
06:53:25 <mniip> mmmno
06:53:27 <nshepperd> I mean minimal in the sense that adding 'pure and () :: f a -> f b -> f (a,b)' to Functor makes Applicative, even while {fmap} and {pure, } are sort of 'disjoint' in that you can't define either in terms of the other
06:53:41 <chpatrick> :t \mf mx -> mf >>= (<$> mx)
06:53:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:53:48 <lamefun> chaptastic, ie. prefix everything?
06:53:58 <nshepperd> hmm, I forgot that * * made things bold on this client
06:53:58 <mniip> missing a return
06:54:22 <mniip> f >>= (x >>=) . (return .)
06:57:49 * hackagebot moesocks 0.1.0.1 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.1 (JinjingWang)
06:58:06 <lamefun> eg. this: https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/Config.hs#L462
07:14:41 <conal> hunteriam: my recent FRP talk: https://github.com/conal/essence-and-origins-of-frp . the denotation is also spelled out in http://conal.net/papers/push-pull-frp and in http://conal.net/papers/icfp97/ .  and, btw, my last name has two "t"s.
07:15:18 <joneshf-laptop> conal, is that available in mp3 format somewhere?
07:16:07 <ttt_fff> does ghci have limitations when working with template haskell ?
07:16:32 <conal> kuribas: the FRP *specification/denotation* requires time. i don't know how an implementation could be correct (faithful to spec) if it doesn't track time as well.
07:17:07 <ttt_fff> conal !!!!
07:17:09 <ttt_fff> the frp guy!!!
07:17:20 <ttt_fff> conal: is there a nice discrete time frp paper / tutorial anywhere?
07:17:24 <ttt_fff> I don't care about conitnuous time
07:17:28 <ttt_fff> I just want to use FRP for discrete state GUI
07:17:51 <shachaf> ttt_fff: Please don't troll.
07:17:55 <merijn> ttt_fff: Discrete time is just a subset of continuous time, so I don't see the problem?
07:18:00 <ttt_fff> shachaf: I'm serious
07:18:15 <ttt_fff> merijn: continuous time , from waht i've read, makes frp complicated to implement
07:18:24 <ttt_fff> with push/pull and various keeping-the-history-around izsues
07:18:41 <ttt_fff> but if one lokst at most gui applications, say vim, emacs, facebook, twitter, there's discrete events
07:18:45 <conal> ttt_fff: i've heard that claim as well, but i have no idea why people believe it.
07:18:51 <ttt_fff> and we don't care about whether a ball is bouncing on the page in a continuous manner or how it's resizing in continuous time
07:19:08 <greymalkin> ttt_fff: I know what you mean, I use sodiumfrp for that purpose.
07:19:26 <conal> ttt_fff: my 1995/1996 FRP implementation was quite simple and handled continuous time correctly.
07:19:56 <ttt_fff> conal: and there's no leaks / issues? there's so many frp papers that I'm not sure which one I should read, especially since they oten state (previous ftp had problem X, which we now solve)
07:20:01 <Zemyla> Hmm, would it be possible at all to have an eval statement in Haskell?
07:20:04 <ttt_fff> so it's not clear to me where a good strating point is
07:20:38 <Zemyla> Like, it'd be of type (Typeable a) => String -> Either ParseError a.
07:20:54 <ttt_fff> Zemyla: there's probably a function in ghci that does that :-)
07:21:00 <ely-se> Zemyla: GHCi exists, so yes.
07:21:35 <Zemyla> Would it be possible to do in a form a normal program could access?
07:21:36 <conal> ttt_fff: there may have been some occasional leaks, as in many haskell programs. i rarely noticed any, iirc.
07:22:26 <ely-se> Zemyla: http://stackoverflow.com/questions/2451354/evaluation-of-haskell-statements-expressions-using-ghc-api
07:24:28 <conal> ttt_fff: it's easy to implement continuous time correctly on top of a correct discrete time system. just push around non-reactive functions of time. explained in my TBAG papers (http://conal.net/tbag) and in http://conal.net/papers/push-pull-frp and in http://conal.net/papers/icfp97/ . most people who implement discrete time systems work without a spec, though, so there isn't likely a correct basis  on which to build.
07:24:49 <y> Zemyla: have you seen `hint`?
07:24:59 <ttt_fff> conal: can you briefly explain what is push vs pull vs push-pull ?
07:25:09 <ttt_fff> conal: there terms pop up alot (for example, sodium frp is push based), but I don't get what's goin on
07:25:18 <AshyIsMe> Zemyla: have a look at lambdabot and mueval too
07:25:28 <y> s/seen/checked/
07:26:02 <Zemyla> y: Looking at that right now.
07:27:13 <kuribas> conal: I am considering FRP for building a GUI using wxHaskell, is there a library that you can recommend?
07:27:27 <conal> kuribas: not at this time. sorry.
07:27:53 <conal> ttt_fff: they're implementation strategies only. with push, work is done only in response to event occurrences. with pull, work is driven by sampling. push-pull is a hybrid strategy. 
07:28:56 <kuribas> reactive banana looked fine, but I don't know if it implements the semantics correctly.
07:29:19 <conal> ttt_fff: push is trickier to get correct (faithful to FRP denotation), and i doubt any system has gotten it right. most don't even try, so they don't notice.
07:30:13 <ttt_fff> conal: dumb question ... wny is frp not just a matter of "do a topological sort on the nodes, then re-evaluate the functions for the ones that needs to be updated, in topologocical order"
07:31:39 <conal> ttt_fff: you'd still have to pass time around explicitly so that all sub-behaviors (including "time") are sampled for the exact same time. also, there's reactivity.
07:32:04 <ttt_fff> conal: in the discrete case, is "push frp" equiv to "topological sort + call evaluation functions" ?
07:32:16 <ttt_fff> I'm willing to sacrifice continuous time for discrete events
07:33:41 <conal> ttt_fff: there's still reactivity. and a close look at the semantics as a sanity check.
07:35:07 <conal> ttt_fff: also, you might be dismissing continuous time too quickly. see https://github.com/conal/talk-2014-bayhac-denotational-design#why-continuous-time-matters . for instance, mouse motion and sliders are more naturally expressed continuously.
07:35:25 <conal> time to go to work. i'll be back online later.
07:35:42 <ttt_fff> conal: thanks for your insights
07:36:26 <conal> ttt_fff: you're welcome. sorry i didn't have more time right now.
07:40:08 <hunteriam> > :t (.)
07:40:09 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:40:23 <hunteriam> :t (.)
07:40:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:44:39 <ttt_fff> damn sodium frp is only 900 lines of code
07:44:44 <ttt_fff> https://www.youtube.com/watch?v=gaG3tIb3Lbk
07:44:47 <ttt_fff> we should form a reading group around it
07:54:42 <Zemyla> Hmm, so if I use hint, I can take a language, translate it into Haskell, and then interpret that probably much faster than a normal interpreter?
07:56:00 <Zemyla> And if the type I interpret to isn't an IO type, there's no chance it can clobber my system?
07:56:38 <kuribas> Zemyla: watch out for unsafePerformIO too.
07:57:36 <Zemyla> Well, I'm not allowing arbitrary input to it. I'm parsing another language to an AST, which I will then interpret.
08:02:52 * hackagebot postgresql-libpq 0.9.1.0 - low-level binding to libpq  https://hackage.haskell.org/package/postgresql-libpq-0.9.1.0 (LeonSmith)
08:02:54 * hackagebot cpsa 2.5.2 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-2.5.2 (JohnRamsdell)
08:04:38 <hunteriam> :t fmap
08:04:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:05:04 <hunteriam> :t fmap (+) (+)
08:05:06 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
08:05:13 <hunteriam> Wow it works
08:05:31 <bernalex> :t (+) . (+)
08:05:32 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
08:05:49 <hunteriam> > (fmap (+) (+)) 1 1 1 1
08:05:51 <lambdabot>      Could not deduce (Num a0)
08:05:52 <lambdabot>      from the context (Num a, Num (a -> t), Num ((a -> t) -> a -> t))
08:05:52 <lambdabot>        bound by the inferred type for ‘e_11111’:
08:06:04 <bernalex> not quite
08:06:12 <hunteriam> Hm
08:06:14 <shachaf> Please use /msg for lambdabot experiments.
08:07:02 <bernalex> hunteriam: fmap for ((->) r) is literally just (.).
08:07:08 <obadz-> they're fun for the rest of us to see :)
08:07:11 <bernalex> :t ((+) . (+))
08:07:12 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
08:07:37 <hunteriam> Yea, but how come (+) . (+) 1 1 1 1 doesn't work
08:08:00 <bernalex> because it's nonsense
08:08:15 <bernalex> > (+1) . (+1) $ 1
08:08:17 <lambdabot>  3
08:13:08 <Zemyla> :t ((((+) .) . (+)) .) . (+) -- hunteriam
08:13:09 <lambdabot> Num a => a -> a -> a -> a -> a
08:13:48 <bernalex> yes that might be what they want
08:14:24 <Denommus> hunteriam: (+) is \x y -> x+y, so (+) . (+) is (\b c -> b+c) . (\x y -> x+y), which is \a -> ((\b c -> b+c) (\y -> a+y)). So... you're passing "b" as a function
08:14:34 <Denommus> hunteriam: *you're passing a function as "b"
08:14:38 <Denommus> hunteriam: that doesn't make sense
08:15:01 <bernalex> they likely want to do
08:15:09 <bernalex> > (+) .: (+) 1 2 3
08:15:11 <lambdabot>      Could not deduce (Num a0)
08:15:11 <lambdabot>      from the context (Num a2, Num a3, Num (a3 -> a -> a1 -> a2))
08:15:11 <lambdabot>        bound by the inferred type for ‘e_1123’:
08:15:20 <bernalex> oh. that should work.
08:15:29 <bernalex> > (+) .: (+) 1 2 3 :: Int
08:15:30 <lambdabot>      Couldn't match expected type ‘Int’
08:15:30 <lambdabot>                  with actual type ‘a0 -> a10 -> a1 -> a1’
08:15:30 <lambdabot>      In the expression: (+) .: (+) 1 2 3 :: Int
08:15:44 <y> > ((+) .: (+)) 1 2 3
08:15:46 <lambdabot>  6
08:15:47 <bernalex> derp
08:15:55 <bernalex> > (+) .: (+) $ 1 2 3 -- hunteriam 
08:15:57 <lambdabot>      Could not deduce (Num a0)
08:15:57 <lambdabot>      from the context (Num a, Num a2, Num r, Num (a -> a2 -> r))
08:15:57 <lambdabot>        bound by the inferred type for ‘e_1123’:
08:15:59 <bernalex> :D
08:16:07 <bernalex> I forgot about that whole thing
08:16:10 <bernalex> so you def need ()s
08:19:02 <hunteriam> The more I think about ->a as a Functor and other things the more confused I get
08:19:12 <Luke> what's the ubuntu zlib c library package called?
08:20:44 <Iceland_jack> hunteriam: Think of (e -> a), not as a function, but something you can get a value out of
08:21:40 <Luke> libz-dev?
08:25:53 <hexagoxel> hunteriam: ((->) r) is (r->), not (->r)
08:28:37 <Iceland_jack> hunteriam: If you create a simple type synonym
08:28:37 <Iceland_jack>     type Env e a = e -> a
08:28:37 <Iceland_jack> then (Env e) is the Functor
08:30:44 <phaazon> hm, do you think it’s best to expose (to end-users) [a], or (Foldable f) => f a?
08:30:55 <phaazon> the latter enables them to provide any kind of « containers » they want
08:31:24 <hunteriam> The latter, unless there are downsides?
08:31:25 <bernalex> in an API? I'd definitely say the latter.
08:32:20 <phaazon> yeah, right
08:32:22 <obadz> is there no runtime cost to these typeclass abstractions? don't you have to pass function pointers which means inlining becomes harder as a result?
08:32:42 <phaazon> obadz: I guess that depends
08:32:48 <phaazon> if the type are known at compile-time
08:32:56 <phaazon> there might not be any dictionary passing stuff
08:32:57 <phaazon> I guess.
08:33:06 <obadz> phaazon: what about cross-module?
08:33:29 <obadz> well, cross-assembly I guess is really what's hard to handle..
08:34:04 <phaazon> obadz: GHC supports that
08:34:21 <obadz> looks like that's addressed here: http://stackoverflow.com/a/12645798
08:35:27 <obadz> phaazon: meaning it can take polymorphic code in a compiled library and optimize that into monomorphic code that gets duplicated in the caller's assembly?
08:35:52 <y> obadz: take a look at SPECIALIZE 
08:37:22 <obadz> does SPECIALIZE have to be put in the library, or can the caller invoke it?
08:41:16 <joobus> Luke: zlibc?  apt-cache search zlib
08:41:46 <y> obadz: I don't know if the caller can invoke it
08:41:53 <hunteriam> Can someone he
08:42:18 <hunteriam> Help me understand the applicatives instance of (z->)
08:42:33 <hunteriam> Specifically, this:
08:42:54 * hackagebot headergen 0.1.0.0 - Creates a header for a haskell source file.  https://hackage.haskell.org/package/headergen-0.1.0.0 (bash0r)
08:43:22 <hunteriam>     Fx <*> fy = \z -> (fx z) (fy z)
08:43:55 <hunteriam> What are the types of fx and fy, mainly?
08:44:06 <johnw> fx and fy are functions z -> ?
08:44:42 <hunteriam> So fx z and fy z would both be constants, so how can you take a constant and apply it to a constant?
08:44:46 <Cale> :t (<*>)
08:44:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:44:53 <dolio> fx :: z -> a -> b, fy :: z -> a
08:44:55 <Cale> So if f t = z -> t
08:45:05 <johnw> i didn't say they would both be constants, or what ? was in both cases
08:45:07 <Cale> then (<*>) :: (t -> a -> b) -> (t -> a) -> (t -> b)
08:45:19 <Cale> So fx :: t -> a -> b
08:45:20 <hunteriam> Ah ok
08:45:23 <Cale> and fy :: t -> a
08:45:32 <dolio> z, not t. :)
08:45:44 <Cale> well, sure
08:45:47 <Cale> :)
08:45:57 <hunteriam> This seems closely tied to currying somehow
08:46:07 <Cale> fx and fy are a bit oddly named there
08:46:18 <hunteriam> Like you're passing an argument into a function to get the next argument for the first function
08:46:23 <hunteriam> It's strange
08:46:37 <Cale> If you're familiar with the SK calculus, this is S.
08:48:39 <Cale> It's also like an abstracted sort of function application, where you're applying a function to an argument, except everything involved is a function taking an argument of type z, so you defer that choice until later.
08:55:12 <Welkin> SKI
08:55:14 <Welkin> it's so cool
08:55:24 <Welkin> but is there anything more beyond that?
08:55:38 <Welkin> I know there is an older system BCKW or something, but SKI supercedes it
09:02:14 <dolio> There's SK. You don't need I.
09:03:00 <dolio> Don't think there's any real 1-combinator calculus.
09:03:12 <glguy> https://en.wikipedia.org/wiki/Iota_and_Jot
09:03:46 <glguy> (It's possible this doesn't qualify as "real")
09:04:02 <dolio> Right.
09:04:24 <dolio> U isn't a valid combinator definition unless S and K are already defined.
09:04:49 <dolio> So it's SKU, and U is unnecessary.
09:05:20 <glguy> valid combinators are ones with only top-level lambdas?
09:06:06 <dolio> Right. They're of the form C x1 x2 ... = e
09:06:14 <shachaf> Unless you use the word "combinator" in the #haskell sense.
09:06:21 <shachaf> Where it just means "value" or something.
09:06:24 <dolio> Where e contains only applications of the variables and previously defined combinators.
09:06:31 <dolio> Right.
09:07:55 * hackagebot Spock 0.7.11.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.7.11.0 (AlexanderThiemann)
09:08:29 <dolio> So, U f = f S K is valid if S and K are previously defined.
09:09:01 <dolio> But U f = f (\g h x -> g x (h x)) (\x y -> x) is not.
09:09:08 <orion> Is it possible to write this in one line?: z <- w >=> x >=> y; return [z]
09:09:53 <glguy> orion: That looks like a type error to me
09:09:54 <y> fmap (:[]) (w >=> x >=> y) 
09:10:14 <glguy> oh, i guess it could be the (->)r Monad instance
09:10:17 <orion> glguy: Indeed, I meant:
09:10:24 <dolio> That already looks like one line to me. :)
09:10:26 <orion> z <- w >=> x >=> y $ o; return [z]
09:10:33 <y> that's different, then
09:10:37 <glguy> dolio: Maybe it's a difference of client :)
09:10:55 <y> @type \w x y -> fmap (:[]) . (w >=> x >=> y)
09:10:56 <lambdabot> Monad f => (a -> f b) -> (b -> f b1) -> (b1 -> f a1) -> a -> f [a1]
09:11:18 <y> orion: I would keep it that way though
09:11:29 <orion> ok
09:17:20 <Andrej_T> :t >=>
09:17:21 <lambdabot> parse error on input ‘>=>’
09:17:29 <Andrej_T> @type >=>
09:17:30 <lambdabot> parse error on input ‘>=>’
09:17:32 <Andrej_T> :(
09:17:41 <circ-user-1UKsY> :t (>=>)
09:17:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:17:46 <Andrej_T> ah thanks :)
09:17:50 <circ-user-1UKsY> np)
09:19:36 <pyon> Is there any way to case-analyze a free-monadic (`MonadFree`) value depending on whether the value is "morally `Pure`" or "morally a functorful layer"?
09:20:20 <pyon> I want to use free monads. I just don't want to build them using `Free f a` because it introduces a lot of syntactic noise. :-(
09:23:25 <johnw> pattern synonyms could help a lot
09:24:27 <dolio> Can you have associated pattern synonyms whose meaning depends on the type class chosen?
09:24:32 <dolio> Er, instance.
09:24:48 <pyon> I guess it could be done if `MonadFree` had a method `unwrap :: m a -> Either a (f m a)`, or something like that.
09:24:50 <dolio> I suspect that'd be very difficult to implement.
09:25:03 <johnw> I was thinking about Free, not MonadFree
09:25:39 <dolio> Anyhow, that's not something you should be doing on all instances of MonadFree.
09:25:44 <pyon> Errr, I meant f (m a), of course.
09:26:22 <pyon> dolio: What do pattern synonyms buy you?
09:26:29 <phaazon> hey, I see in a code
09:26:32 <phaazon> Mat 4 4
09:26:34 <phaazon> as a type
09:26:37 <phaazon> how do they do that?
09:26:39 <phaazon> PolyKinds?
09:26:51 <pyon> phaazon: Probably DataKinds?
09:27:02 <phaazon> oh, DataKinds, yeah
09:27:09 <phaazon> sounds awesome
09:27:42 <dolio> pyon: They'd let you work with data types defined with Free like they were defined directly, instead of having multiple layers of wrapping in between.
09:27:56 * hackagebot varying 0.1.0.1 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.0.1 (SchellScivally)
09:27:57 * hackagebot git-annex 5.20150727 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150727 (JoeyHess)
09:28:22 <dolio> Also you could define something that let you match on church free like it was a normal data type.
09:28:36 <pyon> :-O
09:28:39 <dolio> But you shouldn't do that, because it's an expensive operation.
09:28:51 <johnw> reflection with much remorse
09:28:57 <dolio> If you want to match on church free like a data type, you're better off converting to the normal free.
09:30:46 <dolio> And yeah, they're handy for that, too.
09:31:14 <dolio> You can define a fancy 'reflection without remorse' data type and give it a pattern matching interface that looks like the normal data type.
09:37:03 <pyon> What I really want to do is "peel" a free monad, layer by layer. I've been the 5458493725th person to realize that unification makes sense for arbitrary traversable free monads (plus an equational theory). So, for some `MonadFree m f`, I have two values of type `m a`, and I want to turn them both into `Either (f (m a)) a`, so that, if both values are `Left`s, I'll try to unify them (using the equational
09:37:05 <pyon> theory).
09:38:34 <pyon> And I have yet another language with kinds and (rank-1-only) types, so I wouldn't want to separately implement unification for them separately.
09:52:57 * hackagebot varying 0.1.0.2 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.0.2 (SchellScivally)
10:25:11 <dolio> pyon: MonadFree has a bunch of other stuff in it, though. Like transformers around Free.
10:25:52 <josiah14> I'm looking at Stack for the first time and I'm liking the synopsis/high level description.  What I'm wondering about it is if there was an existing Cabal project, like Yi, for example, how easy would it be to change that over to use Stack for the dependency management and sandboxing?
10:26:17 <Gurkenglas> Why does Set have a Foldable instance? Shouldn't foldMap work only for commutative monoids?
10:28:44 <circ-user-1UKsY> :t zip
10:28:45 <lambdabot> [a] -> [b] -> [(a, b)]
10:29:55 <josiah14> Gurkenglas: I was under the impression that foldMap only required the operation to be associative
10:30:07 <kadoban> josiah14: For small projects I've tried on, it's basically trivial. It'll generate a stack.yaml for you with … one of the commands I've forgotten at the moment 'init' maybe? And that's about it, you can just use stack. (YMMV, I've only done very basic usage so far)
10:30:07 <josiah14> what makes you think it would need to be commutatvie, also?
10:30:12 <circ-user-1UKsY> @josiah14 afaics, you just run `stack init` and `stack build` and that's about it
10:30:13 <lambdabot> Unknown command, try @list
10:30:27 <circ-user-1UKsY> josiah14: afaics, you just run `stack init` and `stack build` and that's about it
10:30:31 <pyon> Gurkenglas: Don't you already have an ordering guaranteed by the fact elements can be traversed in order?
10:30:55 <Gurkenglas> josiah14, hence me saying Set shouldn't have a foldable instance, since ideally the sets fromList [1,2] and fromList [2,1] should be indistinguishable
10:31:15 <josiah14> kadoban: circ-user-1UKsY Does it read the cabal file or something then and just know how to translate that into the Stack config in the YAML file, or will I be entering those deps manually?
10:31:24 <josiah14> I suppose I could just find that out experientially 
10:31:57 <Gurkenglas> pyon, if the monoid was commutative then the order the elements are traversed in wouldn't matter.
10:31:58 <kadoban> josiah14: It reads the cabal file AFAIK, and I never had to specify anything.
10:32:15 <pyon> Gurkenglas: How would `foldMap` let you distinguish between `fromList [1,2]` and `foldMap [2,1]`?
10:33:06 <josiah14> Gurkenglas: well, Commutative is MORE specific, right? (than Associative)  If something satisfies the need for Set, then it would necessarily be Associative and Commutative.  Am I wrong?
10:33:33 <pyon> Gurkenglas: Could you provide an example of a law being broken?
10:34:00 <Gurkenglas> Oh, I mistakenly thought foldMap (:[]) . fromList === id.
10:34:30 <josiah14> Set needs to satisfy everything for Foldable, but Foldable does not need to require all the specifics of Set, is another way of saying it
10:34:53 <josiah14> Gurkenglas: Ah, that would do it. hahaha
10:35:32 <Eduard_Munteanu> FWIW, there are things which are commutative and not associative and vice versa.
10:35:37 <athan> pyon: The induction steps would be in any order, wouldn't it?
10:35:48 <pyon> athan: ?
10:36:09 <athan> if a catamorphism replaces the base case with the initial accumulator, and the successor case with the function you provide
10:36:14 <Gurkenglas> josiah14, I meant that Set should have an instance of a modified Foldable that requires commutative monoids. Any Foldable would be FoldableCommutative, since any foldMap on any monoid is also a foldMap on any commutative monoid, but not the other way round
10:36:32 <athan> ie - `foldr f b` replaces [] with b and (:) with f
10:37:12 <athan> if the fold were commutative, then `f` would be replaced /in any order/, and not the order of the original induction steps
10:37:19 <pyon> athan: Yep, right.
10:37:41 <josiah14> Gurkenglas: ideally I would agree with you, but it's also not necessarily 'wrong' to assert that Set is an instance of the more general Foldable.  But I agree, it's nicer to have the Commutative property built into the type.
10:38:10 <athan> pyon: I've been thinking of making a `commutative` library for purposes similar to this, if you're interested
10:38:28 <pyon> athan: What I *really* want *badly* is commutative monads.
10:38:30 <athan> (but the major drawback is that semigroup would need to be a superclass to Monoid for this to work right :c)
10:38:36 <pyon> :-O
10:39:07 <athan> pyon: This is for a commutative binary operation `<~> :: a -> a -> a`. But, I'm sure there could be something there too :)
10:39:13 <pyon> josiah14: Also, idempotent.
10:39:43 <athan> pyon: Can I ask why you'd want that? The coimmutative monad?
10:40:15 <josiah14> pyon: truly, thou speakest
10:40:21 <Gurkenglas> Even without (foldMap (:[]) . fromList === id), it feels mathematically wrong to allow folds using noncommutative functions. Like, in the place of a big sigma or pi for sum or product, put a big composition symbol a front of a set.
10:40:29 <Gurkenglas> *in
10:41:06 <mayahustle> Anyone here familiar with writing Win32 binding using Haskell's FFI? I'm having a couple issues, and I think it's general n00bishness that's the cause.
10:41:14 <Gurkenglas> It makes explicit use of the Ord instance of the underlying type, and that's only supposed to be there for technical reasons, right?
10:41:17 <pyon> athan: For example, for implementing a SQL-like query language. It doesn't matter in what order subqueries are evaluated.
10:41:39 <athan> pyon: Ahh, perfect :) Okay then
10:42:25 <athan> kinda funny - commutative monads sorta break the idea that monads are sequentially evaluated :x
10:42:28 <josiah14> Gurkenglas: Well, there's definitely limitations to any language.  Consider, the Monad type is supposed to be Associative, but without writing a unit test or integration test of some sort, it's impossible to verify the associativeness of the implemented monadic operations at compile time.
10:42:56 <pyon> athan: I guess the idea is that monads *can* be sequentially evaluated.
10:43:28 <pyon> monadic actions*
10:43:31 <athan> pyon: In the case of the state monad, for instance, the parameter forces sequential evaluation
10:43:46 <pyon> Indeed.
10:43:49 <athan> pyon: That makes sense
10:44:03 <Gurkenglas> Yes, all the verification we do assumes that all instances obey their laws. And thus, it would all be fine if the Foldable instance of Set said something like "Only use with commutative Monoids!", but it doesn't.
10:44:40 <P4Titan> Hello all, If I were to implement my own stack implemetation, how would I store the size variable in the Stack data type without the user having to initialize the stack with an extra '0' as a parameter?
10:44:48 <pyon> Gurkenglas: If you had a HashSet, rather than a Set, I think you would actually need a fold that only works on commutative monoids.
10:45:20 <pyon> Gurkenglas: What makes foldr work with Set is the fact that there's a fixed guaranteed relative ordering between any pair of elements.
10:45:24 <athan> Just to be clear, `concat ~ foldr <> mempty`, correct?
10:45:49 <pyon> athan: What's (~) ?
10:45:50 <Gurkenglas> yep, "<Gurkenglas> It makes explicit use of the Ord instance of the underlying type"
10:45:54 <glguy> P4Titan: You'd provide a definition of "empty" that had the 0 parameter and empty stack implementation
10:45:58 <athan> In my system, `total ~ foldr <~> mempty`, if that makes sense
10:46:09 <athan> pyon: Just equality
10:46:12 <pyon> Oh.
10:46:31 <pyon> athan: In that case, yes, you're right, me thinks.
10:46:43 <josiah14> Gurkenglas: I can agree that maybe this is a documentation deficiency.  I also think, conceptually, it makes sense to have a separate class of Algebraic types which emphasize the commutative property of the operations/actions they encompass
10:46:51 <athan> hmm
10:47:35 <athan> Gurkenglas: Would CommutativeFoldable => Foldable?
10:47:57 <athan> so anything that can fold associative monoids should also be able to fold commutative monoids?
10:47:58 <Gurkenglas> athan, no, the other way round.
10:48:05 <athan> hmm
10:48:08 <P4Titan> glguy: How would I do that. Should I define an internal type that has all of the variables, then would it be possible to do something like "type Stack a = StackInternal 0 a" as a type definition?
10:48:11 <pyon> Gurkenglas: No, athan 's right.
10:48:37 <athan> Gurkenglas: Commutative folds are a restriction on normal folds
10:48:39 <Gurkenglas> I'm certain enough about this to bet money
10:48:45 <pyon> Gurkenglas: Some things can be folded with commutative monoids. A subset of them can also be folded with noncommutative monoids.
10:48:47 <josiah14> no, commutative is more specific
10:48:48 <Gurkenglas> Who's up for a 5$ PayPal bet?
10:49:10 <conal> ttt_fff: a limitation of the top-sort direction is that it only handles acyclic dependencies. lots of interesting & useful FRP examples have cyclic dependencies, i.e., self- and mutually-recursively defined behaviors.
10:49:15 <josiah14> commutative folds must be associative folds, but associative folds must not fold commutatively
10:49:41 <ttt_fff> conal: so I see taht in continuous time environments, but how does that show up in discrete time GUI events?
10:50:01 <athan> prove that a <> b = b <> a => (a <> b) <> c = a <> (b <> c)
10:50:09 <pyon> athan: It doesn't.
10:50:11 <ttt_fff> conal: it seems to me that cycles only make sense when there's almost a 'physics simulation' of some sort (i.e. animal herd dynamics, simulating electrical flow, simulating water, etc ...)
10:50:16 <josiah14> thus, FoldableCommutative would be a subtype of Foldable
10:50:34 <P4Titan> anyone have ideas on my question?
10:50:36 <ttt_fff> conal: but if all I have is a simple GUI (say MS word, a terminal, a facebook / twiter page) ... where do the cyles come from?
10:50:38 <athan> pyon: but, in the context of folding, commutativity subsumes associative folds, right?
10:50:46 <athan> as a, b, c, d, ... infinity?
10:50:51 <ttt_fff> conal: gui seem very much a "the input changes; we recompute the GUI, update the view, and we're done"
10:50:54 <pyon> athan: In the context of folding, I think associativity is taken as a given.
10:51:00 <ttt_fff> conal: since only the user modififes the actual data
10:51:12 <Gurkenglas> Foldable provides foldMap: Monoid m => (a -> m) -> t a -> m. CommutativeFoldable provides foldMap: CommutativeMonoid m => (a -> m) -> t a -> m. Every CommutativeMonoid is a Monoid, so the first foldMap can be specialized to work in place of the second foldMap, so every Foldable is a CommutativeFoldable.
10:51:31 <athan> pyon: Ahh! Okay, that makes sense
10:51:41 <pyon> athan: No, wait, I might be wrong. :-|
10:51:58 <conal> ttt_fff: physics because ODEs are typically recursively defined (if phrased explicitly via integration). reactivity is a discrete counterpart. your use cases might be sufficiently restrictive that cycles don't arise. i don't know. 
10:52:19 <josiah14> athan: the proof is a <> b <> c = b <> a <> c = a <> c <> b = c <> a <> b = c <> b <> a = b <> c <> a => (a <> b) <> c = a <> (b <> c)
10:52:37 <athan> :D
10:52:51 <Gurkenglas> athan, pyon, josiah14, you saw my last line?
10:52:59 <ttt_fff> conal: also, if you don't do a top sort, is it possible, in the worst ase, to have the # of updates be exponential in the actual # of updates necessary? (i.e. being forced to continuously recompute certain values)
10:53:03 <conal> ttt_fff: suggestion: try giving a precise, denotation/specification, and see if you can relate it to your imagined implementation in a fairly rigorous way. then at least you'll know what you're aiming at.
10:53:04 <pyon> Gurkenglas: Yep.
10:53:08 <athan> Gurkenglas: instance CommutativeMonoid => Monoid
10:53:13 <pyon> Gurkenglas: It makes sense.
10:53:17 <Turion> josiah14, how is that a proof if there are no brackets in your first sequence of terms?
10:53:20 <ttt_fff> conal: hmm, I actually don't know how to do that, I must admit
10:53:24 <pyon> athan: What? :-|
10:53:47 <josiah14> Gurkenglas: agreed with that statement
10:54:05 <pyon> athan: Gurkenglas: There should also be a CommutativeTraversable, with works only with CommutativeApplicatives.
10:54:06 <conal> ttt_fff: worth learning! as i've said elsewhere, implementation without specification is a a question without an answer --- not even wrong.
10:54:08 <josiah14> Turion: I meant, the thing to prove is such as I stated
10:54:16 <athan> Gurkenglas: "every commutativefoldable is foldable" - CommutativeFoldable => Foldable
10:54:22 <athan> hmm
10:54:31 <Gurkenglas> athan, no
10:54:38 <Gurkenglas> every foldable is a commutativefoldable, not the other way roud
10:55:16 <josiah14> Turion: athan's claim of what I needed to prove didn't make any sense - it had 2 items on the left side and 3 on the right side of the equality, a logical impossibility of equivalence
10:55:20 <athan> I'm going to write all this down
10:55:52 <athan> josiah14: I really bastardized it , sorry
10:56:32 <josiah14> athan: Gurkenglas A clearer way of saying might be, "Given that the Monoid is Commutative, it's Foldable property must then, of necessity, be Commutative"
10:56:54 <josiah14> athan: no worries.  I'm also at expert at bastardizing things
10:56:57 <conal> ttt_fff: i flubbed my own quote. retrying: implementation without specification is a a answer without an question --- not even wrong.
10:57:08 <ttt_fff> conal: noted
10:57:19 <ttt_fff> conal: yeah, I agree, it's hard for you to debug my thoughts
10:57:22 <conal> *is an answer"
10:57:23 <ttt_fff> conal: because I have no formal spec
10:57:31 <athan> really, I want to state that `forall a b in A. a <> b = b <> a   => sum_<> A => <> is associative`
10:57:44 <athan> if the summation (total) is the same for all permutations of A
10:57:55 <ttt_fff> conal: I agree with you in that "ttt_fff, it's ahrd to debug your thoughts / argue with you, since you have not *FORMALLY* proporsed anything with a mathematical spec" ... so yeah, I agree :-)
10:58:00 <athan> because you could total in any order
10:58:22 <josiah14> athan: but I think the equivalence that I gave should be provable.  If you can order your appended elements in any way, then I would think you would be able to group them however you want, because by re-ordering you essentially re-group since the left side gets evaluated first and accumulates
10:58:24 <Turion> josiah14, oh I see :) an algebra operation that is commutative, but not associative would be "op x y = x * y + 1" (stolen from )
10:58:53 <josiah14> * and + would be 2 different Monoidic instances
10:58:59 <josiah14> I don't see how this follows, you are mixing types
10:59:05 <josiah14> Turion: ^
10:59:11 <athan> josiah14: Hmm, one sec
10:59:20 <Peaker> How is it possible that changing:  fmap Newtype (..expr..)  to:  coerce (..expr..)  will SLOW things down?!
10:59:28 <athan> pyon, Gurkenglas, josiah14: I'm making a github repo to note all this down
10:59:35 <Turion> (from http://math.stackexchange.com/questions/160945/does-commutativity-imply-associativity)
10:59:44 <josiah14> oh, Turion I see what you mean, after looking more closely
10:59:51 <voidzero> athan, share it on the reddit forum if you could
11:00:02 <Turion> josiah14, just wrap any Num in a newtype and implement it using the constructor
11:00:12 <conal> ttt_fff: it's pretty common these days even for haskellers to jump into coding without an implementation-independent spec. a shame, since the denotative/"pure" part of haskell makes rigor simple & practical, unlike other languages.
11:00:13 <dolio> Peaker: Blocks fusion?
11:00:19 <Gurkenglas> voidzero, "subreddit"
11:00:29 <voidzero> yeye
11:00:38 <Gurkenglas> It's pronounced nucular.
11:00:43 <voidzero> /care
11:00:50 <Turion> op (ComButNotAss x) (ComButNotAss y) = ComButNotAss (x*y + 1)
11:01:01 <athan> voidzero: You got it
11:01:13 <voidzero> cheers athan
11:02:05 <josiah14> Gurkenglas: ^ see my convo with Turion.  Commutative does not imply Associative, meaning FoldableCommutative shouldn't inherit from Foldable.  In fact, it's even possible that this type shouldn't even be called a Monoid unless it satisfies the Associative property for sure
11:02:28 <Gurkenglas> Maybe Foldable should have two type arguments, the to be folded data structure and the monoid. Then you could say instance Commutative m => Foldable Set m
11:02:31 <josiah14> If it's Commutative only, the type probably deserves its own unique name
11:03:27 <Gurkenglas> josiah14, I was imagining "Commutative" as a class with superclass Magma, no defintions and only the commutativity law
11:04:07 <Gurkenglas> The Monoid would follow from the class definition of Foldable, I think
11:04:10 <athan> Gurkenglas: That's more correct than what I had in mind :)
11:04:55 <ttt_fff> hey, is the author of opaleye here? I want to see if there is a way to write postgresql _STORED PROCEDURE_ in haskell ... i.e. I want the type checking powers of haskell for writing for SQL code, but then I want it to be a stored procedure
11:05:22 <Gurkenglas> Or maybe drop the Monoid requirement entirely? It would turn into foldMap :: (a -> m) -> t a -> m... this is starting to look like Getters from the Data.Lens package
11:05:46 <arkeet> :t view
11:05:47 <lambdabot> MonadReader s m => Getting a s a -> m a
11:05:52 <arkeet> hm
11:06:16 <arkeet> type Getting r s a = (a -> Const r a) -> (s -> Const r s)
11:06:19 <josiah14> I think we are talking about Abelians and Semilattuces which may also be Monoids, Gurkenglas?
11:06:52 <Gurkenglas> Never heard about the first two classes, though i guess the first is just a commutative group?
11:07:47 <athan> Gurkenglas: foldMapC :: CommutativeIdentityMagma m => (a -> m) -> t a -> m
11:07:49 <athan> it doesn
11:07:53 <athan> 't need monoid
11:08:13 <josiah14> https://en.wikipedia.org/wiki/Magma_(algebra)#Types_of_magmas
11:08:18 <Gurkenglas> What I would like is for the commutativity property to be factorised into a single class that's applied whenever needed. Instead of "Abelian g =>" , you would say "(Commutative g, Group g) =>"
11:08:57 <athan> Gurkenglas: We'll get there :) Have you seen the algebra package?
11:09:02 <Gurkenglas> nope
11:09:08 <athan> :)
11:09:37 <Welkin> athan: algebra is beginning to sound like pokemon
11:09:59 <athan> I think the main issue is that typeclasses are strictly acyclic
11:10:14 <dolio> What does Set have to do with all this?
11:10:15 <athan> And that we can't inform one typeclass to use an operation of another freely
11:10:15 <schell> is there any way to get ghc 7.10.x on linux besides building from source?
11:10:28 <athan> Welkin: Get out your pokedex!
11:10:40 <athan> schell: There's a PPA :)
11:10:59 <athan> Check out bitemyapp's learnhaskell repo, under the install.md file
11:11:09 <josiah14> Well, Sets are just non-duplicating unordered lists
11:11:13 <schell> athan: great - thanks :)
11:11:20 <kadoban> schell: The PPA or just install from the GHC downloads (which isn't source unless you choose that) and then install cabal-install manually.
11:11:31 <Welkin> athan: holy shit!
11:11:36 <josiah14> so Gurkenglas was saying that any operation on a Set, to be viable, would have to be Commutative
11:11:38 <Welkin> we need a pokedex on hackage!
11:11:48 <Welkin> let's make that package
11:11:51 <dolio> Well, that's not true.
11:12:00 <dolio> For Set.
11:12:11 <josiah14> and I am not sure if it would have to be Associative, but if so, it's this SublattuceMonoid sort of thing
11:12:14 <schell> kadoban: it seems haskell.org’s downloads are all for 7.8
11:12:38 <josiah14> dolio, what's not true?
11:12:45 <ReinH> Algebra has a pokedex, written by Lang.
11:12:46 <arkeet> I see lots of 7.10 binaries here. https://www.haskell.org/ghc/download_ghc_7_10_1
11:12:53 <dolio> That you can only fold a Set with a commutative monoid, for instance.
11:13:02 <josiah14> if you have an unordered list and you fold over it, for you to get back the same value every time, that fold would have to be commutative
11:13:05 <kadoban> schell: Are you looking at "haskell platform"? https://gist.github.com/ion1/2815423 and https://www.haskell.org/ghc/download_ghc_7_10_1
11:13:08 <lamefun> Is there a library for digital signatures?
11:13:11 <Peaker> dolio: why would it block fusion?
11:13:18 <hodapp> conal: what are some good resources/examples for the creation of specifications prior to implementation in something that's more FP, and less object-oriented bullshit dream world?
11:13:36 <arkeet> schell: you may also find distribution-specific packages for 7.10
11:13:54 <arkeet> e.g. for ubuntu https://launchpad.net/~hvr/+archive/ubuntu/ghc
11:14:01 <schell> kadoban,arkeet: yes - it looks like i was just not looking at the correct links
11:14:02 <dolio> Peaker: coerce only disappears way after rewrite rules happen. So if there isn't a rule handling coerce, it could make things fail to fuse.
11:14:02 <schell> thanks!
11:14:21 <dolio> Peaker: I don't know what types are involved in your example,though.
11:15:10 <athan> dolio: Can you give a counter example, for how folds over Set aren't necessarilly commutative?
11:15:39 <dolio> Like, 'foo (fmap unNewtype bar)' might fuse, but 'foo (coerce bar)' wouldn't.
11:15:49 <Gurkenglas> josiah14, any folding operation, and yes it would have to be associative. Both requirements come from it not shoulding to be dependent on the Ord instance.
11:16:17 <athan> hmm
11:16:22 <athan> thanks dolio
11:16:53 <dolio> athan: foldMap (\x -> [x])
11:17:05 <dolio> List append isn't commutative.
11:17:26 <josiah14> dolio List is more generic than Set
11:17:35 <athan> dolio: but, the result isn't uniquely determined for any Set (unless you're relying on Ord)
11:17:45 <athan> so any unordered Set, I mean
11:17:53 <dolio> Set uses Ord.
11:18:01 <dolio> It's an ordered tree.
11:18:04 <athan> yeah crap, bit my tongue
11:18:16 <athan> hmm
11:18:18 <josiah14> dolio, what do you mean by Set uses Ord?
11:18:28 <dolio> Go look at the implementation.
11:18:29 <josiah14> ooh
11:18:32 <athan> :i Data.Set.intersection
11:18:51 <athan> :t Data.Set.union
11:18:52 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
11:18:54 <josiah14> dolio, that would differ from the mathematical definition, I think (but correct me if I'm wrong)
11:19:27 <ReinH> dolio: I think the problem is you are talking about Set and josiah14 is talking about sets
11:19:33 <athan> josiah14: It definitely does, but is also more practical for asymptotic stuff
11:19:52 <athan> Okay, so there's another thing to consider - properly commutative, unordered sets
11:20:11 <dolio> Right. But the conversation started with Set.
11:20:11 <josiah14> this has turned into quite a rabbit hole
11:20:24 <dolio> And Set kept coming up.
11:20:44 <dolio> It's definitely different from mathematical sets.
11:20:51 <athan> josephle: just wait until we implement fold via codensity :|
11:20:53 <dolio> Or some quotient type.
11:20:57 <josiah14> Well, and that begs the question, what was meant by Set.  Did Gurkenglas mean the mathematical definition when he was using the Haskell Set implementation?
11:21:23 <conal> hodapp: see papers & books richard bird by folks like richard bird, oege de moor, jeremy gibbons, graham hutton, and myself. my blog contains some examples, as does http://conal.net/papers/type-class-morphisms/ and http://conal.net/papers/push-pull-frp .
11:21:30 <ReinH> Yes, defining terms is useful ;)
11:21:31 <dolio> There's only one Set with a Foldable instance in common use in Haskell.
11:21:53 <ReinH> conal: o/
11:21:53 <dolio> To my knowledge.
11:21:54 <athan> asymptastic!
11:21:59 <Gurkenglas> I meant Data.Sets Foldable instance and said it should only allow commutative monoids/folding operations
11:22:32 <athan> Gurkenglas: I think that Data.Set is not an unordered set
11:22:38 <athan> it's ordered
11:22:39 <conal> ReinH: hey
11:22:52 <josiah14> this sort of raises the question of, even though for lookup and such, it's valuable to keep the implementation ordered, would it make sense to have Ordered and unOrdered Set typeclasses to make a distinction concerning the properties the operations over those sets must support 
11:22:56 <Gurkenglas> Isn't it only ordered because the underlying data structure needs Ord?
11:24:04 <athan> Gurkenglas: And that is part of its purpose, too
11:24:20 <athan> Gurkenglas: Blame faulty naming :P
11:24:26 <conal> hodapp: there are several examples in https://github.com/conal/talk-2014-lambdajam-denotational-design . 2.5-hour workshop, with video expected out next month. that github page links to an older 1-hour version (bayhac 2014) with video.
11:24:38 <athan> if we have a Data.Set.Unordered, then we can base our conclusions off of that Gurkenglas
11:24:49 <athan> (Which I'm also making :P)
11:25:15 <athan> (and also overloading `union`, `intersection`, et. al. because screw qualified imports)
11:28:30 <osa1_> I don't understand how can cabal test fail with a broken package error, while cabal configure --enable-tests && cabal build && ./dist/test/whatever works just fine...
11:29:18 <dolio> If you want foldMap f to only work if the monoid is commutative, why don't you also only want it to work if 'f x <> f x = f x'?
11:29:25 <dolio> Just in case the set stores elements twice?
11:33:35 <hodapp> conal: thanks, I shall check these out
11:34:37 <conal> hodapp: enjoy!
11:36:00 <orion> Given newtype X = X Int, how do I pattern match for a function f :: [X] -> Foo
11:36:37 <orion> I want to pull the Ints out of the newtype in the pattern.
11:38:31 <arkeet> orion: you have a list.
11:38:37 <arkeet> first figure out what you want to do with the list.
11:38:58 <y> also note, that you can just pattern match on X like any other constructor
11:39:12 <orion> y: But how do I pattern match within the list?
11:39:28 <arkeet> you can write patterns like X a : xs
11:39:31 <mayahustle> Anyone mind taking a look at this code for me? Is there something special I need to do to pass ptrs, and make sure that when what they point to changes, the caller sees the results? http://lpaste.net/966367950837645312
11:39:34 <y> you can nest the patterns
11:40:01 <orion> arkeet: I don't want to separate the head from the rest though.
11:40:21 <y> orion: what do you want to do with the list? 
11:40:27 <orion> I want to do something like f [(X xs)] = someFunctionWhichWantsAListOfInts xs
11:40:49 <y> that is a different question, then
11:41:03 <y> you can use coerce for that
11:41:12 <y> @let newtype X = X Int 
11:41:13 <arkeet> coerce, or map with a function X -> Int
11:41:14 <lambdabot>  Defined.
11:41:22 <y> @type coerce :: [X] -> [Int] 
11:41:23 <lambdabot>     No instance for (Contravariant []) arising from a use of ‘coerce’
11:41:23 <lambdabot>     In the expression: coerce :: [X] -> [Int]
11:41:32 <y> well, not _that_ coerce 
11:41:38 <arkeet> :t Data.Coerce.coerce :: [X] -> [Int]
11:41:39 <lambdabot> [X] -> [Int]
11:43:18 <arkeet> :t map (\X a -> a)
11:43:19 <lambdabot>     Constructor ‘X’ should have 1 argument, but has been given none
11:43:19 <lambdabot>     In the pattern: X
11:43:19 <lambdabot>     In the first argument of ‘map’, namely ‘(\ X a -> a)’
11:43:25 <arkeet> oops
11:43:27 <arkeet> :t map (\(X a) -> a)
11:43:29 <lambdabot> [X] -> [Int]
11:43:42 <arkeet> coerce can sometimes be more efficient. 
11:44:09 <orion> So, I have to map over the coerce.
11:44:17 <arkeet> no, they do the same thing.
11:44:21 <arkeet> don't do both things.
11:45:15 <arkeet> probably good to understand coerce before using it./
11:45:32 <arkeet> it's kind of a new thing in ghc 7.8
11:46:04 <athan> Does symmetry imply transitivity? if a ~ b <=> b ~ a, then a ~ b ^ b ~ c => a ~ c? Or is replacement of b and c not included with symmetry?
11:46:43 <arkeet> athan: no.
11:47:05 <arkeet> and it's not a question of replacement.
11:47:52 <arkeet> e.g. the relation on {a,b,c} where a ~ b, b ~ a, b ~ c, c ~ b, and nothing else
11:47:56 <arkeet> is symmetric but not transitive
11:48:09 <athan> ahh I forgot about the relation aspect, sorry
11:48:19 <arkeet> ??
11:48:32 <athan> arkeet: nvm :x thank you!
11:48:37 <arkeet> actually
11:48:45 <arkeet> the relation on {a,b} where just a ~ b and b ~ a
11:48:48 <arkeet> is also symmetric but not transitive
11:53:01 * hackagebot glpk-hs 0.3.5 - Comprehensive GLPK linear programming bindings  https://hackage.haskell.org/package/glpk-hs-0.3.5 (JeanPhilippeBernardy)
11:53:08 <sword_smith> Hi. What is the best Haskell tutorial out there? I am looking for something that only takes like a day or two to complete.
11:56:44 <athan> @learn sword_smith
11:56:44 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
11:56:46 <athan> :)
11:57:36 <zmbmartin> does transformers 4 work ok with ghc 784?
11:58:01 * hackagebot stompl 0.3.0 - Stomp Parser and Utilities  https://hackage.haskell.org/package/stompl-0.3.0 (TobiasSchoofs)
11:58:37 <Zemyla> Hmm, I think I found a simpler permutations function than the one in the Prelude.
11:58:42 <Zemyla> > let { p [] c = c []; p (x:xs) c = let a c ys r = c (x:ys) (case ys of { [] -> r; y:ys' -> a (c . (y:)) ys' r }) in p xs (a c) } in p "abc" (:) []
11:58:44 <lambdabot>  ["abc","bac","bca","acb","cab","cba"]
12:00:07 <Zemyla> It also avoids creating intermediate lists.
12:03:51 <shirt> where can i find the haddock docs for gtk2hs?
12:05:15 <Zemyla> And also a simpler subsequence generator too?
12:05:23 <Zemyla> > let { s [] c = c []; s (x:xs) c = s xs (\ys r -> c ys (c (x:ys) r)) } in s "abcd" (:) []
12:05:24 <lambdabot>  ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","a...
12:07:11 <Gurkenglas> Depending on your definition of simple, take note of filterM (const [True, False]).
12:08:01 * hackagebot open-browser 0.1.3.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.1.3.0 (rightfold)
12:09:03 <ely-se> indiagreen: Linux and Windows support have been added now.
12:09:30 <dolio> > subsequences [1..]
12:09:33 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
12:10:35 <indiagreen> ely-se: y'know, I'm still kinda surprised that you aren't forgetting to ping me when a new version comes. Thanks :)
12:11:00 <ely-se> I'm not used to people using my software. :v
12:11:29 <Zemyla> Gurkenglas: Well, it avoids creating intermediate lists, and doesn't have to have subsequences separate from nonEmptySubsequences.
12:11:42 <ely-se> indiagreen: I have too many projects running. Working on a VM as-we-speak.
12:11:50 <dolio> It doesn't work on infinite lists.
12:12:40 <Zemyla> Do subsequences and permutations?
12:12:58 <dolio> Yes.
12:15:25 <dolio> Also, you're building a lot of continuations in memory, which may not be any better than intermediate lists.
12:24:43 <buff3r> hi all
12:25:08 <buff3r> i was wondering if there's a more eloquent way to write this: map (\row -> map read row :: [Int]) $ map words ["5 5 5", "1 1 1"]
12:25:41 <Zemyla> dolio: How do you judge the impact of continuations vs intermediate lists?
12:26:46 <Zemyla> (Also, would the continuation form being more eligible for fusion make a difference?)
12:26:55 <Zemyla> > let { s [] c n = n; s (x:xs) c n = c [x] (s xs (\ys r -> c ys (c (x:ys) r)) n) } in take 5 $ s ['a'..] (:) []
12:26:56 <lambdabot>  ["a","b","ab","c","ac"]
12:27:06 <bob_twinkles> buff3r: (map . map) (read :: String -> Int) $ map words [...]
12:27:24 <bob_twinkles> well, I think that's more elegant anyway, opinions may differ =P
12:27:34 <buff3r> cool, that's interesting, thank you
12:28:29 <Zemyla> buff3r: Use readMaybe from Text.Read so bad input doesn't crash everything.
12:28:35 <Zemyla> :t readMaybe
12:28:36 <lambdabot> Not in scope: ‘readMaybe’
12:28:48 <Zemyla> @let import Text.Read
12:28:49 <lambdabot>  Defined.
12:28:55 <Zemyla> :t readMaybe
12:28:55 <lambdabot> Read a => String -> Maybe a
12:29:40 <buff3r> Zemyla: thanks
12:31:11 <ptrckbrwn> Hey everyone. Curious if theres an easy way to get from Data.ByteString.Lazy to String.
12:31:33 <ptrckbrwn> I can't seem to hoogle it.
12:32:23 <shachaf> ptrckbrwn: What sort of way?
12:32:56 <Zemyla> > traverse (traverse (readMaybe :: String -> Maybe Int) . words) ["5 5 5", "1 1"] -- for buff3r
12:32:57 <lambdabot>  Just [[5,5,5],[1,1]]
12:33:11 <shachaf> What do you want to do with the ByteString (pack [0xff]), for instance?
12:33:19 <Zemyla> And if one of the lines is wrong, it turns into Nothibg.
12:33:30 <ptrckbrwn> Network.HTTP.Conduit.parseUrl returns a ByteString.Lazy and I want to feed it into a function that takes a string
12:33:53 <ptrckbrwn> shachaf: the function is from lib that I cannot change (feed)
12:34:05 <shachaf> OK.
12:34:10 <bob_twinkles> ptrckbrwn: you probably want Data.ByteString.UTF8.encode/decode
12:34:30 <shachaf> That's probably true, but you should know what you want.
12:35:08 <ptrckbrwn> bob_twinkles: okay cool, I'll look into that
12:35:08 <jle`> YellowOnion: btw, length doesn't force the contents entire list to evaluate, it only forces the spine.  but from the work you were doing, it would have been needed to be evaluated anyways
12:35:22 <bob_twinkles> (assuming you're not looking to encode/decode to another text encoding of course =P)
12:36:32 <bob_twinkles> ptrckbrwn: or actually, Data.Text.Encoding has a friendlier interface
12:36:42 <ptrckbrwn> bob_twinkles: I'm not sure what Feed does, but I'm hoping to god it's all in the realm of UTF8 :)
12:37:19 <bob_twinkles> if it takes a ByteString, it probably just operates on binary data and doesn't care about the structure of that data at all
12:42:20 <ptrckbrwn> \q
12:43:29 <sword_smith> @learn
12:43:29 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
12:44:05 <sword_smith> athan: ^^
12:44:15 <joeHorffa> Someone please correct me here - I feel like I am completely trashing up the use of a Monoid here: http://programmers.stackexchange.com/a/290995/35276
12:44:22 <athan> :D
12:45:44 <joeHorffa> I must be missing something in the behaviour of Alternative or Monoid in that I am not seeing the standard way of getting the desired functionality: `i * i * x * i * y = x = x * y`
12:45:55 <athan> joeHorffa: So you want a consuming element?
12:45:58 <joeHorffa> Is there like a use of const or some such I should be using?
12:47:26 <athan> joeHorffa: Let me get this straight, do you want to define a `e` in your set, such that `forall a. a <> e = e = e <> a`?
12:47:27 <ReinH> joeHorffa: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:First
12:47:53 <ReinH> You want First m
12:48:45 <joeHorffa> ReinH: But that constrains to Maybe, not Monoid
12:48:47 <ReinH> Any monoid can be treated in this way by mapping the id element to Nothing
12:49:12 <ReinH> and every other element via the Just constructor
12:49:55 <ReinH> Basically what you're doing is replacing the monoidal op with one that is absorbtive
12:51:52 <sword_smith> athan: there are too many choices. I have about two years experience from university CS studies. I write C, MatLab, Java, golang, Python, and a bit ML. What would you recommend for a 24-48 hours course?
12:52:22 <joeHorffa> ReinH: so is there a function or type class `:: Monoid a => a -> Maybe b` to generalize `mempty` to `Nothing` ?
12:53:09 <ReinH> Not that I'm aware of
12:53:19 <ReinH> But it looks like the questioner wants a version of traverse
12:53:29 <ReinH> :t \x -> sequence . map ($ x)
12:53:30 <lambdabot> Monad m => a1 -> [a1 -> m a] -> m [a]
12:53:36 <slack1256> @type foldMap
12:53:37 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:54:22 <hodapp> Do many 'rules' exist on the sort of hierarchical organization you should have in your modules?
12:54:22 <slack1256> @type ( \a -> foldMap Just (Identity a))
12:54:23 <athan> sword_smith: Maybe the NICTA course?
12:54:23 <lambdabot> Monoid a => a -> Maybe a
12:54:34 <athan> it's hard to say, I don't know your background :\
12:54:34 <ReinH> Oh, no, sequence will short circuit
12:54:43 <hodapp> I know that hackage likes certain things to be present, but this isn't (yet at least) public code
12:56:08 <sword_smith> athan: I am taking a course called Advanced Programming at my university this September. That will involve Haskell programming
12:56:11 <ReinH> Oh, no, you want to use the (<|>) monoid
12:56:16 <ReinH> > (\x -> foldr (<|>) Nothing . map ($ x)) 1 [const Nothing, Just]
12:56:17 <lambdabot>  Just 1
12:56:23 <sword_smith> I was just thinking about getting a head start
12:56:53 <Peaker> dolio: thanks for the explanation above.. can't coerce be thrown away very early?
12:57:23 <ReinH> Which is basically the same as just using First
12:58:03 <ReinH> > ala First foldMap (map ($ 1) [const Nothing, Just])
12:58:04 * hackagebot fsnotify 0.2.0.2 - Cross platform library for file change notification.  https://hackage.haskell.org/package/fsnotify-0.2.0.2 (GregWeber)
12:58:04 <lambdabot>  Just 1
12:58:09 <Peaker>  newtype TVarName (tag :: ASTTag) = TVarName { _tVarName :: Int }    ; foo & coerce    is slower than foo <&> TVarName
12:58:26 <slack1256> @type ala
12:58:27 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
12:59:45 <Peaker> Would a CPS'd EitherT typically be faster than straight-forward EitherT?
12:59:51 <ski> sword_smith : i'm not quite sure what you're asking about, but i would also suggest taking a look at logic programming (and possibly also constraint logic programming after that). so at least Prolog
13:00:17 <ReinH> and map ($ x) xs = sequence xs x, so
13:00:39 <ski> sword_smith : also, learning logic programming (specifically "logic variables" in there) will help you better understand how type variables work in type inference (in Haskell, the MLs, Mercury, ...)
13:00:49 <ReinH> > ala First foldMap . sequence [const Nothing, Just] $ 1
13:00:51 <lambdabot>  Just 1
13:01:04 <Peaker> newtype EitherT e m a = EitherT (m (Either e a)) vs. newtype EitherT e m a = EitherT ((e -> m r) -> (a -> m r) -> m r)
13:01:20 <indiagreen> when I have a Parsec parser like “try a <|> b” and it fails, it only reports the error from “a”, but it could report errors from both (like, “this would've succeeded if a didn't fail at position 5 or b didn't fail at position 3”). Is it an obvious idea which actually has bad consequences when you implement it?
13:01:22 <ReinH> ah, which is equivalent to the other ansewr
13:01:35 <ski> Peaker : i think they're not isomorphic
13:01:55 <sword_smith> ski: prolog and erlang are also part of that course :))
13:01:56 <ski> Peaker : .. also, i'd prefer an explicit `forall r.' in there :)
13:02:07 <forgottenone> in https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/function-application, it's said that " in some cases you may elide the space if the parse is unique", what they mean by that?
13:02:18 <Peaker> ski: well, the latter is much more powerful, but I mean if you only expose the power of the Either
13:02:36 <Peaker> ski: I do use your suggestion with the GADT AST, btw, thanks :)
13:02:54 <ski> sword_smith : ok. if it's only part of a course, then it'll probably not be enough to make you appreciate enough what logic programming can do for you. but it may give a taste
13:03:19 <Peaker> ski: I have some rough edges (ugly class to reflect back an equality proof from the type level tag so I can do a switch on which tag it is inside tag-generic code)
13:04:36 <kuribas> sword_smith: a nice book about programming concepts is SICP: https://mitpress.mit.edu/sicp/full-text/book/book.html
13:04:59 <ski> sword_smith : .. also beware that the lecturers of some such courses don't know logic programming that well themselves. you might want to hang out on ##prolog, for advice and asking questions (there's also #mercury for Mercury, a statically typed logic programming language that has borrowed some ideas from Haskell. however, most logic prog. literature if for some flavour of Prolog, so it's probably best to learn Prolog first anyway)
13:05:02 <hodapp> I need to read SICP one of these days...
13:05:40 <ski> (sword_smith : also, you'll better appreciate the static mode and determinism system of Mercury, if you've experienced the kind of bugs and problems in Prolog that they catch early)
13:05:40 <sword_smith> ski: awesome. Thanks.
13:06:56 <lamefun> If I have an abstract newtype, and I decide to change it to data, will there be any changes to its behavior visible to the outside modules?
13:07:10 <kuribas> ski: and curry :)
13:07:21 <forgottenone> can anyone explain how spaces between arguments and the functions ellided if the parse is unique?
13:07:33 <ski> sword_smith : all of this is of course just suggestions. apart from SICP which hodapp mentioned, CTM is also a good book talking about several programming language paradigms. it uses the language Oz, which at the core is a logic programming language, but which has extensions for concurrent, functional, constraint, object-oriented, ... programming
13:07:39 <ski> @where SICP
13:07:39 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
13:07:41 <ski> @where CTM
13:07:41 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
13:08:06 <ski> sword_smith : .. if you haven't seen SICP before, at least take a look at the SICP video-recorded lectures
13:08:57 <Peaker> lamefun: yeah, it has an extra "bottom" value
13:08:58 <sword_smith> @where SICP
13:08:58 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
13:09:14 <Peaker> lamefun: pattern-matching it is no longer a runtime no-op
13:09:41 <hodapp> kuribas mentioned SICP, not me :P
13:09:49 <ReinH> forgottenone: I think you missed a word there somewhere?
13:09:57 <ski> sword_smith : if you want to learn about macros, then you should turn to the lisps. Scheme (a lisp) has hygienic macros, which (imho) is the right thing here (at least by default). Scheme is the language used by SICP to talk about various computer programming concepts. Scheme also has continuations, which is a very powerful primitive
13:09:58 <lamefun> Peaker, don't all types include bottom as a value?
13:10:17 <hodapp> ski: Lisp lacks continuations in the same sense?
13:10:21 <ski> sword_smith : .. note that the last link lambdabot gave for SICP there is something else (Haskell-related)
13:10:23 <hodapp> Common Lisp, at least
13:10:42 <Peaker> lamefun: newtype only includes the "same" bottom value of the underlying type
13:10:57 <ReinH> lamefun: in data Foo a = Foo a, undefined and Foo undefined are different values. in newtype Foo a = Foo a, they are the same value since they share the same representation.
13:10:58 <Peaker> lamefun: data Foo = Foo Int   has all the values of "Int" (including bottom), and then it has an extra "bottom"
13:11:14 <ski> hodapp : neither Common Lisp nor Emacs Lisp (nor, i think, Clojure, nor Dylan, nor Logo) has first-class continuations
13:11:22 <ski> (iirc, Ruby had them, but doesn't anylonger)
13:11:24 <rowanblush> forgottenone: Don't elide spaces. It makes your code looked cramped and is unneccesary.
13:11:24 <Peaker> lamefun: https://wiki.haskell.org/Newtype <-- explains it well
13:11:35 <forgottenone> ReinH: i dont think so, it's in here:https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/function-application#dollar-and-dot-notation, and i really didnt understand what he meant
13:11:36 <ski> SML/NJ (implementation of Standard ML) has (first-class) continuations
13:11:51 <y> data Foo = Foo Int ; undefined /= Foo undefined
13:12:01 <ReinH> forgottenone: well, your sentence didn't parse for me
13:12:23 <ski> sword_smith : Racket (#racket) is a Scheme (#scheme) (and more) implementation, which iirc has a compatibility package for the exercises in SICP (which are very recommended)
13:12:25 <forgottenone> rowanblush: i dont want to, but want to learn when can i elide spaces
13:12:34 <rowanblush> forgottenone: What it means is that if there is one single unambiguous interpretation of a string of characters without spaces, then it's safe to leave out the spaces and still achieve function application.
13:12:42 <rowanblush> forgottenone: I'll give you an example.
13:12:44 <ReinH> forgottenone: It doesn't really have anything to do with "unique parses"
13:12:59 <ReinH> foo3 is the identifier "foo3". There is no alternative parse.
13:13:06 <hodapp> ski: good to know, thanks.
13:13:20 <ReinH> foo 3 is the application of foo to the value 3. There is no alternative parse.
13:13:45 <ReinH> Same with foo$3 and (foo)3 and foo(3)
13:13:49 <ReinH> They are all unique parses.
13:13:52 <forgottenone> ReinH: the sentence is from the link,not from me
13:14:06 <ReinH> forgottenone: Yes, I'm just suggesting that it is confusing if not wrong.
13:14:16 <arkeet> you can remove spaces if they're not necessary to separate tokens.
13:14:16 <ReinH> well, in fact it is wrong
13:14:27 <rowanblush> forgottenone: You might write `map (+ 1) [1..3]` normally, but because "(" and "[" aren't possible identifier characters, you could also write `map(+1)[1..3]`.
13:14:30 <ReinH> ambiguous parsing has nothing to do with it
13:14:32 <ski> sword_smith : re macros, meta-programming is related to this. OCaml (a member of the ML family, just like SML) has something like a macro system (you both extend the concrete syntax, and you do AST manipulation). MetaML (now defunct ?) and MetaOCaml has cool meta-programming (aka staged programming) facilities
13:14:40 <Denommus> is there a gitlab client library for Haskell?
13:15:10 <forgottenone> ReinH: it's possibly wrong or ambigious at least, that's why i wanted to ask
13:15:38 <ReinH> Whether or not you need a space has nothing to do with unique or ambiguous parses
13:15:46 <ReinH> it just has to do with the grammar
13:15:56 <forgottenone> rowanblush: i see, thanks
13:15:57 <ski> sword_smith : .. if you ever get interested in parsing and compiling technology, you also at some point ought to check out attribute-grammer systems (there's one that interfaces with Haskell nicely, e.g.)
13:16:14 <ski> sword_smith : you may or may not be interested in some of the topics i mentioned. this is just fyi
13:16:20 <rowanblush> I think what it's referring to is probably the use of "." as composition operator and module separator.
13:16:52 <ReinH> Denommus: did you look on hackage?
13:17:18 <ReinH> Or google?
13:17:19 <rowanblush> `Color.format` could be the format function from the Color module, or it could be the Color constructor composed with a format function.
13:17:31 <Denommus> ReinH: yes, no result
13:17:39 <ReinH> @google haskell gitlab
13:17:40 <lambdabot> https://github.com/maoe/gitlab/blob/master/gitlab.cabal
13:17:45 <ReinH> Might be relevant.
13:17:57 <Zemyla> Hmm. Would GHC accept list-fusion versions of subsets and permutations that worked with list fusion?
13:18:04 <ski> @where UUAG
13:18:04 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
13:18:35 <ReinH> rowanblush: That would be a case of ambiguous parsing indeed, although the source doesn't mention it.
13:18:56 <ReinH> So perhaps they are correct by accident.
13:20:24 <ReinH> Heh. Yes. A template value. :D
13:20:29 <ReinH> Sorry, wrong window.
13:20:36 <Denommus> "Wreq is designed for ease of use"
13:20:48 <Denommus> "You know, we'll wrap everything under IO (Response a) instead of just allowing you to just work directly with Response by using monad transformers"
13:21:03 <Denommus> "Ah, and of course, Response is not a monad. We hate you"
13:21:32 <ReinH> what?
13:21:43 <ReinH> Why would Response be a monad?
13:21:52 <ReinH> And how could you work directly with Response by using monad transformers?
13:22:05 <ski> Peaker : ok, missed your replies here at first
13:22:17 <Denommus> Response itself could be a monad transformer involving IO
13:22:22 <ReinH> To what end?
13:22:25 <Zemyla> Denommus: Is Response even a functor?
13:22:29 <Denommus> and Response could be a monad in a similar way to any "promise" or "future" API
13:22:37 <ReinH> but it's just a response.
13:22:39 <Denommus> ReinH: to make it easier to work with
13:22:50 <sword_smith> ski: seems like what you are talking about at least a year of studying ... :)
13:22:50 <ReinH> I don't agree that this would make it easier to work with, or that it makes sense.
13:22:54 <Denommus> ReinH: yes, a response that I don't know when it will arrive
13:23:04 <ReinH> But... that's not what Response is.
13:23:06 <Denommus> Zemyla: yes, it's a functor
13:23:33 <Denommus> ReinH: ok, Response is just the representation of a HTTP response, right? That makes sense
13:23:36 <ReinH> Right.
13:23:42 <Zemyla> Denommus: Can you turn it into a free monad transformer?
13:23:42 <ReinH> :t (>>=)
13:23:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:23:52 <ReinH> Monad makes sense for things that have a useful bind or join
13:23:57 <Denommus> ReinH: but why using IO instead of, I dunno, a Future?
13:23:57 <ReinH> I don't see that being the case for Response
13:24:09 <Peaker> Funnily, Control.Monad has almost only things that don't need bind/join!
13:24:21 <Denommus> Zemyla: maybe
13:24:23 <Peaker> Almost all the combinators in Control.Monad work for Applicative
13:24:35 <ReinH> Peaker: hysterical raisins
13:24:52 <ReinH> Denommus: I mean, you're performing IO
13:25:10 <ReinH> and Haskell is lazy, so you already have futures everywhere
13:25:20 <Denommus> ReinH: hm
13:25:27 <Denommus> ReinH: I'll accept that
13:25:50 <Zemyla> So it becomes FreeT Response IO a?
13:25:50 <ReinH> and async lets you make IO actions work like futures
13:26:05 <ReinH> in the operational sense
13:27:07 <ReinH> wrapping IO in some sort of future providing type would be premature since you can do so easily via async
13:27:22 <Denommus> ok
13:27:31 <ReinH> in the cases where you need it, and not incur the additional indirection and complexity in those where you don't
13:29:20 <ReinH> The separation between evaluation and execution of IO actions has some benefits :)
13:31:23 <ski> sword_smith : well, you should probably study what you're interested with (and possibly also things that you can understand would be useful), i'm just pointing out some areas that might be of interest to at least have an idea what they're about, to get a better feel for what concepts and alternative approaches are there, for when you need them
13:31:48 <Gurkenglas> It would be nice if we had a word that people could use in "@hoogle"'s place to ask #haskell to take lambdabot's place in answering the query, because like every fourth question I pose here takes that form, it feels like. Let's pretend it's "hoogle".
13:31:53 <Gurkenglas> hoogle ([a] -> a) -> [a]
13:32:47 <quchen> Problem is, we're not Hoogle.
13:33:34 <Gurkenglas> Hm, I like to answer questions of that form when I have the answer. Should we make a separate channel for that?
13:33:44 <arkeet> no
13:33:44 <ski> Gurkenglas : i usually try to do that anyway, when i'm paying attention to the channel
13:34:14 <catgocat> How do I pattern match against a character that was given as an argument to an outer function? I want something like:    myFunc c = doStuff "hi" where doStuff (c:'i':[]) = ..
13:34:24 <catgocat> That is not the real case, I'm just wondering
13:34:49 <quchen> That's how you do that.
13:35:18 <arkeet> no it's not.
13:35:20 <quchen> Well, you can't use the "c" in the pattern directly, but a guard remedies that.
13:35:26 <y> catgocat: unless you meant something like myFunc c = doStuff "hi" where doStuff [c', 'i'] | c' == c = ... 
13:35:33 <arkeet> ^
13:35:48 <catgocat> but inside a pattern match
13:35:51 <Gurkenglas> "Problem is, we're not Hoogle." <- You mean it's demeaning to make the theoretical simplicity of the task so obvious, and this practice would entitle people to ask more of that kind of query?
13:35:52 <catgocat> isnt it possible?
13:35:53 <catgocat> without using guards?
13:36:13 <arkeet> guards are the way to go.
13:36:25 <ski> you could also use transformational/view patterns
13:36:26 <Gurkenglas> (Hm, it's also got some djinn mixed in.)
13:36:41 <arkeet> after all, pattern matching on literals ends up looking like
13:36:42 * ski would use a guard in the shown case
13:36:46 <arkeet> f 'i' = ... 
13:36:47 <arkeet> becomes
13:36:52 <arkeet> f x | x == 'i' = ...
13:37:27 <ski> Gurkenglas : just ask djinn, publicly ?
13:37:36 <Zemyla> Isn't that what it becomes whenever you aren't pattern-matching on a constructor?
13:37:50 <arkeet> it's what happens when you pattern match on a literal.
13:37:57 <arkeet> numeric or character literal
13:38:47 <quchen> Zemyla: Arguably every match is against a constructor, and the rest is convenient sugar.
13:39:07 <quchen> Zemyla: Matching against integers is sometimes called an "n-pattern".
13:39:12 <arkeet> it is?
13:39:26 <quchen> I've heard it called this way and I think it's a fitting name.
13:39:44 <quchen> Matching against characters is far less common so I don't think it has a name.
13:39:46 <Gurkenglas> ski, I usually ask it privately beforehand, so making it repeat the failing answer here would just spam the channel, and an alternate codeword would make it clear that I already asked him in private. Or do you like the gurantee of @djinn being unable to answer?
13:39:53 <latro`a> any idea how to make this have less repetition? http://lpaste.net/137436
13:40:19 <y> https://www.haskell.org/onlinereport/exps.html#pattern-matching ; informal semantics of pattern matching
13:40:27 <y> 7. Matching a numeric, character, or string literal pattern k against a value v succeeds if v == k, where == is overloaded based on the type of the pattern. The match diverges if this test diverges.
13:41:00 <y> (h) case v of { k -> e; _ -> e' } = if (v==k) then e else e'
13:41:02 <y>  where k is a numeric, character, or string literal. 
13:41:04 <Gurkenglas> latro`a, in what other places do you use MoveType?
13:41:14 <hexagoxel> :exf "([a] -> a) -> [a]"
13:41:14 <exferenceBot> \ b -> pure (b mempty)
13:41:34 <hexagoxel> exference has an answer :p
13:41:49 <catgocat> how do I prohibit someone from using my data type, if the string parameter is empty ?
13:41:52 <latro`a> Gurkenglas: pretty much here and in the corresponding function that tells me what to do once I have already chosen a move
13:43:02 <latro`a> I suppose I could write a monad combinator, call it untilM or something, for the recursive pattern
13:43:04 <ski> Gurkenglas : roughly, yes
13:43:06 * hackagebot postgresql-libpq 0.9.1.1 - low-level binding to libpq  https://hackage.haskell.org/package/postgresql-libpq-0.9.1.1 (LeonSmith)
13:43:32 <latro`a> untilM p m = m >>= (\x -> if p x then return x else untilM p m)
13:43:51 <y> latro`a: I would factor out the idx
13:43:56 <Zemyla> :exf [[a] -> a] -> [a]
13:43:56 <exferenceBot> fmap (\ f -> f mempty)
13:44:03 <lpaste_> geekosaur annotated “No title” with “Iatro`a (annotation)” at http://lpaste.net/137436#a137437
13:44:17 <Peaker> Using "perf" on my Haskell program, "annotate" on closure infos shows a hexdump instead of assembler output. Anyone knows how to fix that?
13:44:30 <Zemyla> :t \f -> let go = fmap ($ go) f in go
13:44:31 <lambdabot> Functor f => f (f b -> b) -> f b
13:44:41 <geekosaur> oh, one more parameter, whoops
13:44:58 <shachaf> Peaker: The trouble is that they're not in a text section.
13:45:16 <Peaker> shachaf: oh.. is there some switch one can pass to "perf"?
13:45:19 <shachaf> Peaker: I don't think GHC has an option to use a text section for them. Maybe perf has an option to force disassembly?
13:45:27 <shachaf> With objdump you can use -D instead of -d to do it.
13:45:31 <lpaste_> geekosaur revised “Iatro`a (annotation)”: “Iatro`a (whoops, offset)” at http://lpaste.net/137437
13:45:50 <ReinH> @google haskell smart constructors
13:45:51 <lambdabot> https://wiki.haskell.org/Smart_constructors
13:45:55 <ReinH> catgocat: ^
13:46:14 <geekosaur> with more knowledge of the types involved, one might well do better
13:46:39 <catgocat> am I a bad person not to see list@( .. ), when what's in the parentheses is just y:xs ?
13:46:46 <catgocat> s/see/use
13:47:00 <kadoban> catgocat: You only need to use it when you actually need it, so … no?
13:47:17 <latro`a> geekosaur: there are some differences; there's manyAt in one of the lines, and one of them has neither anyAt nor manyAt
13:47:24 <catgocat> I need the list y:xs
13:47:36 <kadoban> If in the expression you're just rebuilding the list, you probably should be using as-patterns though. It's less error prone if nothing else.
13:47:37 <catgocat> but it's ugly to wrap it in list@
13:47:44 <ReinH> Ok, then don't do it.
13:47:51 <catgocat> am I bad a person ??
13:47:52 <ski> geekosaur : the conditions differ
13:47:55 <ReinH> Yes.
13:47:56 <catgocat> is this bad design
13:47:58 <ReinH> You are a bad person.
13:48:02 <geekosaur> mrr, right
13:48:09 <catgocat> but my mom says that I am nice
13:48:10 <ReinH> I mean, it exists for a reason, but you can choose to ignore it if you want
13:48:15 <quchen> latro`a: Give stuff better names and float blocks out, http://lpaste.net/137439
13:48:18 <kadoban> catgocat: It's slightly bad. I've seen worse stuff. *shrug*
13:48:28 <quchen> latro`a: That paste is full of placeholder names, but you get the idea
13:48:30 <geekosaur> still refactorable since you can pull those out (remember, laziness lets you move stuff around)
13:48:35 <Peaker> shachaf: it's beginning to look like changing "perf" is the easiest way :P
13:48:36 <ski> catgocat : "but it's ugly to wrap it in list@" -- why ?
13:48:38 <geekosaur> but still would like to see more
13:48:42 <Gurkenglas> latro`a, http://lpaste.net/137441
13:49:05 <shachaf> Peaker: I wonder whether you could change the ELF file.
13:49:31 <Peaker> shachaf: it's probably dynamically allocated into a memory region not described in the ELF?
13:49:34 <ski> Gurkenglas : in case you don't know about it, consider annotating the original paste with answers
13:49:44 <arkeet> :t fmap (\ f -> f mempty)
13:49:45 <lambdabot> (Functor f, Monoid a) => f (a -> b) -> f b
13:49:52 <Peaker> The source code for "perf" seems to be the Linux kernel itself, hmm
13:50:08 <latro`a> Gurkenglas: that if-case is clever
13:50:10 <naudiz> stack is killing me... how can people consider this to be a good cabal alternative?
13:50:44 <Peaker> Gurkenglas: use newlines so your code doesn't fall off the right edge of the screen and make a mess on the floor
13:51:08 * ski smiles
13:51:58 <naudiz> is there ANY way to get stack working? it refuses to know about the package binary that is necessary to build EVERYTHING
13:52:06 <Gurkenglas> Peaker, ordinarily I would indent few spaces from the far left of the line, but I wanted to largely preserve the style 
13:52:41 <broma0> Why aren't "non-exhaustive patterns" errors compile-time?
13:52:46 <athan> Do Data.Map.Lazy and Data.Map.Strict share the same data type? Instances seem to be clashing :s
13:52:53 <Peaker> Gurkenglas: IMO alignments are too expensive to be used almost all the time.. just indents is much more maintainable (search/replace works!) and you more easily see structure
13:52:59 <rowanblush> broma0: Are you compiling with -Wall?
13:53:00 <quchen> broma0: But they are! Enable warnings!
13:53:04 <quchen> -W is enough
13:53:07 <broma0> rowanblush: :D
13:53:08 <Peaker> athan: They're the same yeah, likely different package versions?
13:53:16 <broma0> quchen: thank you!
13:53:21 <naudiz> broma0: because they don't need to be. look at head.
13:53:26 <athan> Peaker: Oh no, I'm making my own instances :) thank you
13:53:33 <athan> (overloading all set operations :x)
13:53:44 <quchen> broma0: It's one of the most obvious advantages of Haskell's type system, it would be a shame if we couldn't leverage exhaustiveness checks :-D
13:54:05 <shachaf> Peaker: OK, I was wrong about the exact issue.
13:54:06 <naudiz> Seriously, does noone here use stack and can help me build ANYTHING? ._.
13:54:09 <Peaker> athan: Data.Map is always strict on spine and keys, and Data.Map.Strict is strict on values by having all the APIs force the values at the entries
13:54:13 <broma0> naudiz: I'm not sure what you mean
13:54:18 <Gurkenglas> Peaker, http://lpaste.net/137441 . By alignments you mean the whitespaces I inserted to align the -> and &&?
13:54:36 <Peaker> Gurkenglas: I mean any amount of space which isn't a multiple of INDENT-LEVEL (I recommend 4)
13:54:36 <glguy> naudiz: I don't use stack, but I can't imagine the way you're going about asking for help is the most beneficial for you
13:54:40 <athan> Peaker: Ahh! Awesome, thathelps a lot
13:55:01 <ChristianS> broma0: -Wall makes lots of sense, but they just be just warnings, not errors. still, fixing those warnings is a good idea.
13:55:08 <naudiz> glguy: I'm asking since yesterday, always including a paste, except this time
13:55:17 <Peaker> athan: sure, I had to debug thunk leaks for many horus and I suspected my Maps, so I dived in :)
13:55:33 <athan> :)
13:55:45 <Peaker> Gurkenglas: I think 2 spaces looks a lot like a word soup, and barely see structure..
13:55:46 <ggVGc> is there any haskell library that generates shell scripts?
13:55:52 <broma0> ChristianS: is there a way to make these kinds of issues actually errors? i'd imagine that'd be very useful to some 
13:55:52 <naudiz> but well, here is the paste: https://bpaste.net/show/a510583558f0
13:56:16 <Welkin> ggVGc: you can use haskell to write shell scripts
13:56:19 <ChristianS> broma0: -Werror
13:56:38 <ggVGc> Welkin: yeah I know, but I want to generate sh compatible code instead
13:56:50 <athan> Gurkenglas: I'm starting to make proper sets. Here's the repo where it will be: github.com/athanclark/sets
13:57:13 <naudiz> I installed it from portage and from cabal-install. always the same error. I don't know what's going wrong and I'm really desperate by now :/
13:57:19 <athan> also, the commutativity stuff will come soon after: github.com/athanclark/commutative
13:58:19 <Peaker> Gurkenglas: I annotated something closer to the style I'd use
13:58:49 <naudiz> the same error appears for every package
13:59:08 <buff3r> is there a version of (!!) that uses Maybe?
13:59:15 <Gurkenglas> (Oh yes of course that idx <- randSite belongs on another line)
13:59:39 <Gurkenglas> buff3r, https://hackage.haskell.org/package/safe
13:59:40 <y> latro`a: I added another annotation to the paste, you can check it
13:59:51 <glguy> naudiz: perhaps you force unregistered binary-0.7.1.0 at some point and things that depend on it are now broken
13:59:57 <buff3r> Gurkenglas: thank you
14:00:09 <Zemyla> I wish there were Read and Show equivalents that could do Read from and Show to Text.
14:00:12 <glguy> naudiz: Does "ghc-pkg check" indicate any problems?
14:00:15 <indiagreen> Zemyla++
14:00:19 <Zemyla> Like, natively.
14:00:44 <naudiz> glguy: how would I have done that? I removed all my haskell packages at some point
14:01:29 <latro`a> y, what extension is that?
14:01:32 <Peaker> Gurkenglas: I annotated again
14:01:40 <y> latro`a: Pattern guards are in Haskell 2010 
14:02:11 <latro`a> oh, so it is pattern guards; the _ just caught me off guard
14:02:26 <naudiz> glguy: yet, there are some problems, as it seems https://bpaste.net/show/9234682e33b9
14:02:55 <Peaker> shachaf: how so?
14:03:37 <glguy> naudiz: binary-0.7.1.0 comes globally installed with GHC 7.8.4. At some point you must have force unregistered that which broken everything that depended on it
14:03:44 <glguy> and upwards transitively
14:03:45 <arkeet> :t preview . ix
14:03:46 <lambdabot> (MonadReader s m, Ixed s) => Index s -> m (Maybe (IxValue s))
14:03:51 <fishythefish> Anyone here good with Python as well as Haskell?
14:04:05 <hiptobecubic> fishythefish, probably several. Just ask
14:04:10 <ely-se> indiagreen: Did I say I added Windows support? If so, then I was wrong, since somebody else did it.
14:04:12 <glguy> naudiz: a bunch of dependencies appear to not exist in your output due to force unregistration or force reinstalls
14:04:18 <fishythefish> hiptobecubic: Yeah, figured that was coming. :P Will do.
14:04:27 <glguy> naudiz: You shouldn't be forcing anything virtually ever
14:04:31 <arkeet> :t preview . ix :: Int -> [a] -> Maybe a
14:04:32 <lambdabot> Int -> [a] -> Maybe a
14:04:37 <naudiz> glguy: so, how do I un-unregister it?
14:04:37 <latro`a> Gurkenglas: thoughts on the annotation I just did?
14:05:04 <naudiz> glguy: I'm not aware of having done something like that
14:05:05 <glguy> The easiest way to restore your global packages is probably to reinstall GHC.
14:05:06 <fishythefish> I'm calling a Python script via readProcess, and half the time, Python spits out "close failed in file object destructor" etc.
14:05:24 <fishythefish> Googling, this happens when the pipe Python is writing to is broken before it's emptied.
14:05:32 <glguy> naudiz: "dependency "ghc-7.8.4-9b1524e6908af01d10da9bd636c20312" doesn't exist" is going to be hard to fix on its own. That's reinstall time
14:05:32 <naudiz> glguy: I reinstalled it twice now...
14:05:37 <latro`a> err
14:05:42 <latro`a> y, thoughts on the annotation I just did
14:05:43 <latro`a> ?
14:05:45 <fishythefish> Any clue how to resolve this behavior?
14:05:53 <y> latro`a: where?
14:06:05 <latro`a> http://lpaste.net/137436
14:06:05 <kuribas> glguy: I force reinstalls most of the time, and rarely have a problem.
14:06:26 <glguy> kuribas: doing that breaks the stuff you aren't using right now
14:06:27 <naudiz> glguy: maybe because I updated to 7.8.4-r4?
14:06:39 <hiptobecubic> fishythefish, need to see code, but it sounds like this is probably a lazy IO issue
14:06:42 <latro`a> y, it still has some duplication, but it's not as bad, and I think it's clear
14:06:53 <glguy> kuribas: it's unnecessary and creates problems for you later
14:07:19 <kuribas> glguy: well, I force it when a package will not install otherwise
14:07:46 <glguy> kuribas: if a package won't install otherwise it's better to actually understand what's blocking it and unregister the things that are blocking it
14:07:53 <glguy> rather than breaking them and having to fix it later
14:07:59 <kuribas> glguy: good point
14:08:00 <latro`a> typo, one lat should've been randSite
14:08:18 <fishythefish> hiptobecubic: Oh, that makes a lot of sense.
14:08:21 <kuribas> glguy: I'll try that next time.
14:08:42 <fishythefish> hiptobecubic: I'll post code later if I can't fix this, but let me see if forcing evaluation works.
14:08:55 <ggVGc> Welkin: what library would you recommend for writing shell utils in haskell?
14:09:00 <y> latro`a: oh, I didn't realize the whole thing was recursing, and your version is pretty much ok, pretty sure untilM is in monad-loops, btw!
14:09:09 <hiptobecubic> ggVGc, shelly is popular i think
14:09:15 <naudiz> glguy: I tried haskell-update https://bpaste.net/show/007e36450473 should I do as it says?
14:09:17 <hiptobecubic> fishythefish, make sure you hang on to a reference to the pipe that python is trying to write to
14:09:35 <nkaretnikov> ggVGc: turtle maybe?
14:09:36 <Welkin> ggVGc: https://hackage.haskell.org/package/shelly
14:09:50 <fishythefish> hiptobecubic: Yeah, I need the output from readProcess anyway, so I have that.
14:09:57 <Welkin> ggVGc: https://hackage.haskell.org/package/turtle
14:10:09 <zmbmartin> Is ExceptT available with ghc 7.8 my package was building fine with 7.10 but with 7.8 I get this error 'Could not find module ‘Control.Monad.Except’'
14:10:17 <hiptobecubic> ggVGc, we've talked about this before I think, but why highlight first?
14:10:21 <glguy> naudiz: It can't hurt given the current state of your package repository :)
14:10:37 <glguy> naudiz: I think I'd probably start by unregistering all the broken packages as reported by ghc-pkg check
14:10:45 <glguy> and if something depends on a broken package I'd unregister that, too
14:10:46 <nkaretnikov> Welkin: for the record, I had problems with shelly when I tried it.  it failed to work with sudo properly on my machine while other libs worked fine.
14:11:06 <ggVGc> hiptobecubic: because it was in reference to an earlier conversation?
14:11:06 <naudiz> glguy: good point... 
14:11:16 <glguy> naudiz: It looks like you have a bunch of stuff installed "globally", it's easy to manage this stuff if you don't do that
14:11:18 <naudiz> glguy: how do I unregister something?
14:11:24 <glguy> ghc-pkg unregister PACKAGE
14:11:29 <hiptobecubic> ggVGc, I mean why not ggcG ?
14:11:30 <glguy> easier*
14:11:35 <ggVGc> oh
14:11:42 <ggVGc> hiptobecubic: http://ggvgc.com
14:12:07 <hiptobecubic> :) you've played knifey-spooney before I see
14:12:18 <naudiz> glguy: thanks... it should be mostly yesod, gnuplot, ghc-mod and stack
14:12:23 <Welkin> what is ggVGc and ggcG? 
14:13:02 <ggVGc> vim commands
14:13:24 <Welkin> oh
14:13:29 <cow_2001> :|
14:13:48 <hiptobecubic> ggVGc, ah yes. You were d last time we spoke.
14:15:05 <naudiz> ggVGc: deep sh... stuff
14:15:38 <Gurkenglas> @type \f -> fix (([]:) . map f . zipWith take [1..] . repeat) -- Why isn't this ([t] -> t) -> [t]?
14:15:39 <lambdabot> ([[t]] -> [t]) -> [[t]]
14:16:18 <hiptobecubic> @type ([]:)
14:16:20 <lambdabot> [[t]] -> [[t]]
14:16:30 <hiptobecubic> Gurkenglas, ^
14:16:56 <Peaker> shachaf: I see inside perf's annotate source code a call to objdump -d
14:17:26 <latro`a> y, my untilM is actually iterateUntil in monad-loops, but you're right! I'll use that
14:17:26 <Gurkenglas> Yep I did those two leftmost components the wrong way around.
14:17:30 <Gurkenglas> Thx
14:18:51 <Gurkenglas> @@ @djinn @type \f -> fix (map f . zipWith take [0..] . repeat) -- Now for the actual query - is there a better way to write this?
14:18:51 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:18:54 <Peaker> Gurkenglas: Saw the latest annotation?
14:19:20 <naudiz> glguy: stack finally works! I love you, thank you so much!
14:19:50 <Gurkenglas> Peaker, link and position please? I'm getting lost in all these annotations
14:20:21 <glguy> naudiz: You're welcome
14:20:29 <Peaker> Gurkenglas: http://lpaste.net/137447
14:20:57 <y> latro`a: nice! 
14:21:28 <hiptobecubic> Something about seeing an apostrophe in a variable name just makes me panic
14:22:03 <Gurkenglas> Peaker, I like mine more, because I don't have to write move thrice and I don't even have to invent the name "move"
14:22:38 <Peaker> Gurkenglas: I think the "case" is more versatile to future changes though
14:22:46 <Peaker> Gurkenglas: Less boolean blindness too
14:22:59 <Gurkenglas> "boolean blindness"?
14:23:22 <shachaf> Peaker: I successfully patched an ELF file so that objdump disassembles the info section properly with -d.
14:23:25 <shachaf> Peaker: Still seems to run.
14:23:26 <athan> Gurkenglas: Unlabelled switches
14:23:38 <Gurkenglas> athan, ???
14:23:42 <athan> ie: "okay, this takes a boo, but what is the behaviour associated?"
14:23:44 <y> Peaker: http://lpaste.net/137445
14:23:45 <athan> bool*
14:23:47 <Peaker> Gurkenglas: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/ <-- in this case, "move" and "don'tMove" are better than "True" and "False" as the meaning of the latter is unknown
14:24:18 <Peaker> y: ?
14:24:22 <athan> What's the difference / advantages of using Seq over lists?
14:24:29 <Peaker> shachaf: cool, how?
14:24:33 <Gurkenglas> The meaning should be clear from the implementation of move and don'tmove. The less names the better imo
14:24:44 <Peaker> athan: I think the asymptotic complexity of append on both ends, extract from both ends, etc.
14:25:00 <athan> Peaker: Oh! okay, hmm
14:25:02 <shachaf> Peaker: I changed the type from STT_OBJECT to STT_NOTYPE in the symbol table.
14:25:11 <shachaf> Maybe GHC should generate it that way.
14:25:22 <athan> Peaker: opposed from the asymptotics of lookups and modifications with arrays / vectors, huh
14:25:24 <Peaker> shachaf: of all symbols?
14:25:26 <shachaf> Of course I don't know very much about ELF so who knows what might happen.
14:25:34 <shachaf> Peaker: Of Main_main_info, which I was testing with.
14:25:57 <badabing> hi
14:26:06 <catgocat> do you guys do review of small code (but smart code) ?
14:26:07 <monochrom> Gurkenglas: the issue is this. when I see "True", does it mean "it will move, it's true!"? does it mean "it will stay, it's true!"?
14:26:22 <monochrom> if you are sure that you are free of that issue, then no problem.
14:26:22 <Peaker> shachaf: how do you see the type? objdump -t only says "l" on *_info symbols
14:26:34 <myfreeweb> how do I implement MonadBaseControl IO for a transformer stack (that doesn't take any more monads)? ie. newtype M a = M { runM :: ReaderT Ctx (ExceptT Err IO) a }
14:26:41 <badabing> im trying to install haskell-mode on spacemacs
14:26:45 <badabing> but im facing issues
14:27:03 <badabing> the install went ok
14:27:13 <badabing> and it syntaxx highlights the source
14:27:41 <badabing> but whenver i save it waits for a while and then says ghc process hung or exited with error
14:27:45 <shachaf> Peaker: I think objdump -t shows it.
14:27:53 <badabing> not sure what to do about this
14:28:01 <badabing> has anyone seen this happen before?
14:28:12 <Peaker> shachaf: example line: 0000000000e6c068 l       .text	00000000000000e0              s7zb_info
14:28:32 <shachaf> Peaker: Right. That one should get diassembled correctly by objdump -d, I think?
14:28:36 <rowanblush> catgocat: Maybe codereview.stackexchange.com ?
14:29:10 <catgocat> rowanblush, before I wrote the code I have in haskell, I had written it in javascript, and the code is on codereview for days now and no answers
14:29:11 <catgocat> but 2 upvotes
14:29:33 <Peaker> shachaf: ah, I see, "O" for the bad ones
14:29:45 <shachaf> Yes.
14:29:48 <shachaf> "The symbol is the name of a function (F) or a file (f) or an object (O) or just a normal symbol (a space)."
14:30:43 <rowanblush> catgocat: It seems to be pretty well divided on language lines, Haskell questions without multiple pages of complex code always seem to get fast answers.
14:30:50 <shachaf> Peaker: The format is four bytes for offset, then four bytes for size, then one byte for info.
14:31:19 <shachaf> Peaker: The type is the low nybble of info, so I just changed it to 0.
14:32:58 <lamefun> I'm probably going to have this recurring pattern for text subset types, how to deal with this? http://lpaste.net/5955146230928506880
14:33:29 <Peaker> shachaf: thanks, I think I'll postpone this to get lower hanging perf fruits first :)
14:33:53 <shachaf> Peaker: The question is why GHC generates that type.
14:34:04 <lamefun> I don't want to type all that out all the time...
14:34:10 <Peaker> shachaf: not enough people use perf on GHC yet I guess
14:34:22 <shachaf> Peaker: People have used objdump for a long time, though.
14:34:27 <Xe> how do I add a dependency to a cabal project?
14:34:36 <Xe> is there a tool I can use that will do it automatically?
14:34:41 <shachaf> I'll ask in #ghc.
14:35:56 <lamefun> Is it time to start using Template Haskell?
14:38:08 * hackagebot engine-io-wai 1.0.2 -   https://hackage.haskell.org/package/engine-io-wai-1.0.2 (codedmart)
14:42:59 <fishythefish> hiptobecubic: Still having that problem. :/
14:43:09 <fishythefish> Documentation for readProcess says it does the IO strictly in any case.
14:44:24 <mpickering> Is there any type which has kind "!" ?
14:44:51 <monochrom> I haven't heard of that kind. what does it do?
14:45:40 <ely-se> PureScript has a kind written "!"
14:45:46 <ely-se> Maybe you are confusing PureScript with Haskell?
14:46:33 <mpickering> thanks monochrom
14:46:35 <hiptobecubic> fishythefish, what happens if you don't try to output anything from the python script?
14:46:50 <mpickering> just doing a sanity check whilst reading the haskell-src-exts source code
14:47:14 <Peaker> fishythefish: I think it doesn't read the output strictly, I think it lies (or misleads)
14:47:17 <mpickering> it seems to suggest that "!" is the kind of unboxed types but isn't "#"?
14:47:59 <fishythefish> Peaker: http://haddock.stackage.org/lts-2.20/process-1.2.0.0/System-Process.html#v:readProcess says "reads its standard output strictly"
14:48:00 <fishythefish> wat
14:48:14 <mpickering> hmm is there a reason why you can't use a "#" in a kind signature though? it doesn't appear to be the case looking at ghc's parsing code
14:48:21 <mpickering> that might not even make sense
14:49:06 <Peaker> fishythefish: Look at the source, Luke
14:49:18 <Peaker> fishythefish: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Process.hs#L37 <-- this is what I use. "String" is a dumb type for potentially long results
14:53:08 * hackagebot microlens 0.1.1.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.1.1.0 (Artyom)
14:53:41 <fishythefish> Internet dropped weirdly.
14:53:58 <fishythefish> hiptobecubic: If I don't output anything, there won't be an issue, but I won't get the info I need from the script.
14:54:33 <fishythefish> You can see the errors I'm getting by piping a Python script to any command that doesn't read stdin.
14:54:43 <fishythefish> hiptobecubic: e.g. `./myscript | cd .`
14:55:54 <Peaker> fishythefish: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Process.hs#L37 <-- this is what I use. "String" is a dumb type for potentially long results
14:56:51 <Peaker> CPS'd EitherT seems significantly slower than the straightforward EitherT (good!)
14:57:06 <catgocat> http://codereview.stackexchange.com/questions/98266/string-sequence-in-haskell
14:57:38 <fishythefish> Peaker: The output is very short, so I'm not concerned about that. I still don't understand why this is happening.
14:57:45 <fishythefish> deepseq'ing the result doesn't help.
14:58:03 <Peaker> fishythefish: where's your code?
14:58:35 <fishythefish> Peaker: Let me put up an lpaste. Gotta hide some of the company details.
15:00:05 <ReinH> > flip replicateM "abc" =<< [1..3] -- catgocat
15:00:07 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
15:00:20 <Gurkenglas> latro`a, http://lpaste.net/137441#a137450 this gets rid of the recursion
15:00:37 <catgocat> ReinH what's the difference between [1..3] >>= ...
15:01:01 <catgocat> and yours
15:01:02 <ReinH> None, but =<< lets me treat it like a fancy function application
15:01:08 <ReinH> which it is
15:01:38 <ReinH> as in, f =<< a rather than f $ a
15:02:13 <ReinH> So I tend to prefer it
15:02:18 <catgocat> ReinH, damn didn't know that one
15:02:20 <nullvoid8_> imo, >>= is nice when you're applying to lambdas, =<< is nice when applying to exisiting functions
15:02:23 <ReinH> but >>= and =<< are just flipped versions of each other
15:02:48 <ReinH> nullvoid8_: right, which makes sense: >>= is there to facilitate do notation
15:03:10 <catgocat> can you explain your function to me?
15:03:14 <catgocat> flip repl..
15:03:20 <ReinH> > replicateM 1 "abc "
15:03:22 <lambdabot>  ["a","b","c"," "]
15:03:26 <ReinH> > replicateM 2 "abc"
15:03:28 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
15:03:30 <ReinH> and so on
15:03:32 <latro`a> Gurkenglas: that's cool; do you think that would help performance any?
15:03:43 <ReinH> > map (flip replicateM "abc") [1..3]
15:03:44 <lambdabot>  [["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","aab","...
15:03:54 <voidzero> isn't that permutation actually?
15:04:03 <Gurkenglas> Probably not, but who knows? It's primarily so the function is more obvious
15:04:22 <ReinH> and we need to concat the results, so concatMap (flip replicateM "abc") [1..3]
15:04:31 <ReinH> and concatMap = (>>=) for lists
15:04:47 <latro`a> I don't think I'll use that, though; it forces some editing that I don't really want to do
15:05:03 <ReinH> well, in fact concatMap = (=<<)
15:05:10 <Gurkenglas> It took me too long to realize you just recursively call yourself without changing any arguments, so I made a change that would have made me realize it as soon as I understood the code snippet at all
15:05:35 <latro`a> though...splitting into Diffusion Left, etc. would actually be helpful
15:06:21 <latro`a> err...actually no, it would make the matching annoying, because some of them wouldn't match on (_ Left) or what have you
15:06:29 <voidzero> so am i right and is that called permutation ReinH?
15:06:41 <voidzero> replicateM I mean
15:06:52 <ReinH> voidzero: no
15:07:18 <ReinH> permutation is specifically permute xs = replicateM (length xs) xs
15:07:35 <nullvoid8_> it's more like the power sets of cardinality n
15:07:43 <ReinH> flip replicateM xs =<< [0..] is an enumeration of the elements of the free monoid generated by xs
15:08:03 <ReinH> starting with the identity
15:08:09 * hackagebot hdocs 0.4.4.0 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.4.4.0 (AlexandrRuchkin)
15:08:10 <nullvoid8_> ReinH: does't that also include lists with repeated 
15:08:22 <ReinH> oh, that's true, never mind
15:08:23 <tromp_> > replicateM 2 "ab"
15:08:24 <Peaker> ReinH: I've come to prefer >>=, because along with & and <&>, I can write a pipe-line involving pure/non-pure transformations, and avoid parenthesis :)
15:08:25 <lambdabot>  ["aa","ab","ba","bb"]
15:08:30 <nullvoid8_> *repeated elements, which are not permutations
15:08:31 <tromp_> not very permutation like
15:08:33 <ReinH> wait, it does
15:08:38 <ReinH> it does include repeated elements, duh
15:08:42 <ReinH> ZipList would be the one that doesn't
15:08:55 <cow_2001> refactoring with lenses. wow.
15:09:07 <monochrom> yes
15:09:21 <nullvoid8_> > replicateM 2 $ ZipList "ab"
15:09:21 <lpaste_> fishythefish pasted “readProcess issues” at http://lpaste.net/137451
15:09:22 <tromp_> @let pick [] = [];pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
15:09:22 <lambdabot>      No instance for (Monad ZipList) arising from a use of ‘replicateM’
15:09:22 <lambdabot>      In the expression: replicateM 2
15:09:22 <lambdabot>      In the expression: replicateM 2 $ ZipList "ab"
15:09:24 <lambdabot>  Defined.
15:09:31 <nullvoid8_> whoops
15:09:41 <tromp_> let @permute = join (evalStateT . mapM (const (StateT pick)))
15:09:49 <tromp_> > permute "abc"
15:09:50 <lambdabot>  Not in scope: ‘permute’
15:10:04 <tromp_> @let permute = join (evalStateT . mapM (const (StateT pick)))
15:10:05 <lambdabot>  Defined.
15:10:07 <tromp_> > permute "abc"
15:10:07 <voidzero> ok, well I understand the part related to haskell, the math terms will stick as i progress :)
15:10:09 <lambdabot>  ["abc","acb","bac","bca","cab","cba"]
15:10:09 <fishythefish> Peaker: See http://lpaste.net/137451
15:10:13 <myfreeweb> how do I implement liftBaseWith like this http://stackoverflow.com/q/28137838 but with an ExceptT inside of the ReaderT?
15:10:14 <Peaker> > [1..3] >>= replicateM ?? "abc"
15:10:16 <lambdabot>      Couldn't match type ‘m0 a0 -> m0 [a0]’ with ‘[[Char] -> b]’
15:10:16 <lambdabot>      Expected type: Int -> [[Char] -> b]
15:10:16 <lambdabot>        Actual type: Int -> m0 a0 -> m0 [a0]
15:10:28 <voidzero> i do get the difference now, thanks.
15:10:33 <fishythefish> Peaker: I had to change some stuff from the actual code because it's company code, but the relevant parts are there.
15:10:38 <voidzero> between permuting and replicateM I mean.
15:11:16 <voidzero> I would have guessed 'permutate' rather than 'permute' btw :P
15:11:33 <ReinH> English is weird
15:11:54 <voidzero> permuting, permute, permutation
15:11:58 <voidzero> yeah, weird :)
15:12:11 <monochrom> I agree. it's English and Chinese, not Englese or Chinish
15:12:11 <Peaker> fishythefish: A variant of this works for me
15:12:15 <indiagreen> should I reexport Control.Applicative from my module if I know that in 98% of cases the user will have to import Control.Applicative to use it anyway?
15:12:30 <Gurkenglas> latro`a, http://lpaste.net/137441#a137452 here's one that doesn't need you to change the type declaration
15:12:39 <Peaker> indiagreen: new GHC comes with (most of) Control.Applicative imported
15:12:52 <fishythefish> Peaker: This works for me some of the time.
15:12:58 <indiagreen> Peaker: I don't think it includes <|>, or does it?
15:13:10 <fishythefish> Peaker: Like there's a race condition in reading from/writing to the pipe.
15:13:13 <voidzero> monochrom, I have a Chinish phone, though. ^^
15:13:56 <indiagreen> Peaker: if by “new” you mean 7.10, then it doesn't
15:14:17 <voidzero> or, no, Hongkishong or sth. I digress.
15:14:25 <Peaker> indiagreen: right, that isn't included
15:14:35 <indiagreen> well, then my question stands
15:14:55 <Gurkenglas> latro`a, http://lpaste.net/137452 because I missed a .            Also http://lpaste.net/137441#a137453 to collapse findSite into a line because that do block was getting small
15:15:38 <latro`a> Gurkenglas: nice!
15:15:48 <Gurkenglas> And make that last one http://lpaste.net/137453 because I didn't import fromJust
15:16:02 <Gurkenglas> (You should be able to edit annotations :/)
15:19:21 <latro`a> Gurkenglas: I think that even though that form might not actually save efficiency straight up, it's easier to optimize from there
15:19:36 <latro`a> since now you have a stream feeding into a sink
15:19:46 <latro`a> so it would be straightforward to, say, translate into conduit
15:19:52 <latro`a> whereas my other version would no
15:19:57 <latro`a> *not
15:20:22 <Gurkenglas> All this is not about efficiency, it's about style
15:20:39 <latro`a> I know
15:20:50 <latro`a> I already made the positive style comment
15:23:31 <latro`a> also, you accidentally stumbled into an fmap
15:23:32 <latro`a> :)
15:23:44 <latro`a> return . ... <<= randSites
15:23:49 <latro`a> *=<<
15:24:24 <Gurkenglas> Yep just noticed that. http://lpaste.net/137453
15:33:32 <naudiz> is ghc-mod broken?
15:34:11 <kadoban> naudiz: Unless I've missed an update, it's not been updated for GHC 7.10 yet, so … arguably yes.
15:34:49 <naudiz> kadoban: I'm using 7.8
15:35:10 <kadoban> naudiz: What version of cabal?
15:35:37 <naudiz> there has been a bug report on github a while ago, I wondered if it was still relevant
15:36:02 <naudiz> cabal-install version 1.22.6.0
15:36:04 <naudiz> using version 1.22.4.0 of the Cabal library
15:36:38 <kadoban> naudiz: Sounds too new. I think you need to be on something like 1.19 for GHC 7.8
15:36:54 <kadoban> I'm not sure what version specifically is required, something like that though.
15:37:15 <naudiz> meh... it's uncomfortable to work without ghc-mod...
15:37:42 <naudiz> hope it will be fixed some time soon
15:38:10 * hackagebot uniform-io 0.1.1.0 - Uniform IO over files, network, watever.  https://hackage.haskell.org/package/uniform-io-0.1.1.0 (marcosdumay)
15:39:39 <kadoban> naudiz: hdevtools can do some of what ghc-mod can, and seems easier to get running. Or, depending on what you're using it for you can just ghci in a separate window or whatever.
15:39:57 <Drezil> naudiz: are you using stack? or atleast stackage to avoid cabal-hell?
15:40:20 <naudiz> Drezil: I'm using stack for about an hour now
15:40:22 <MrMeowMeow> How does one use Stackage?
15:40:32 <MrMeowMeow> Maybe I should just Google it
15:40:42 <Drezil> https://www.stackage.org/
15:40:47 <naudiz> MrMeowMeow: cabal install stack
15:40:51 <monochrom> the Stackage home page has instructions.
15:41:02 <Drezil> wget *url* .. and you got a cabal.config with dependencies
15:41:18 <kadoban> MrMeowMeow: I'd just look at the 'stack' tool instead. I haven't been using it long, but so far it's /way/ easier than manually doing cabal stuff.
15:41:24 <naudiz> kadoban: is there by chance a vim plugin for it?
15:41:25 <Drezil> for the stack-tool: cabal install stack or better: the *.deb (or similar) from their page
15:41:46 <Drezil> naudiz: i have used hdevtools with vim
15:41:50 <kadoban> naudiz: hdevtools? Yeah. I think it's just called hdevtools-vim or something. Let me know if you can't find it, I could dig up my config.
15:42:11 <naudiz> thanks, I'll look into it :)
15:43:04 <kadoban> The only thing it doesn't do for me is provide completions to necocomplete, I think. Pretty sure ghc-mod did that, or maybe I'm forgetting how that worked, heh. I ended up just not bothering trying to set it up last time though.
15:43:55 <Drezil> for completions i use another plugin ..
15:43:58 <naudiz> yes, I kind of really miss the completion
15:44:28 <Drezil> i think its vim-autocomplpop
15:44:36 <kadoban> I still get completions from neocomplete, but they're the "You already typed this in this file" kind.
15:44:48 <kadoban> Which isn't amazing, but it's enough.
15:45:08 <Drezil> ye
15:45:45 <zmbmartin> I get a warning with `import Control.Applicative ((<$>), pure)` in 7.10 and not in 7.8. How can I stop the warning in 7.10 (which is says to do Control.Applicative ()) but still have it for 7.8?
15:46:10 <Drezil> zmbmartin: with if-stuff ..
15:46:15 <ReinH> zmbmartin: CPP and ifdef
15:46:18 <Drezil> let me just look for it..
15:46:19 <ReinH> not sure if it's worth it
15:47:01 <ReinH> Er, not ifdef, just if
15:47:12 <ReinH> #if MIN_VERSION_base specifically
15:47:39 <kadoban> I thought there was some trick without CPP, something like noimplicitprelude, then import Applicative and then import Prelude manually? I don't remember if that's real or not though, heh.
15:48:47 <Drezil> https://wiki.haskell.org/GHC/As_a_library << #if __GLASGLOW_HASKELL__ > 708 etc.
15:49:04 <Drezil> https://hackage.haskell.org/package/bytestring-0.9.1.7/docs/src/Data-ByteString-Internal.html - here is an example with a lot of different imports for different versions
15:49:20 <ReinH> Drezil: I think you should check the version of base
15:49:31 <ReinH> even though they are coupled, base is where the actual change was made
15:49:32 <Drezil> oh .. right.
15:50:20 <ReinH> Or maybe people do just check the GHC version.
15:50:21 * ReinH shrugs
15:54:36 <Denommus> I don't know if I'm too stupid, or using Haskell for REST clients is too contrived
15:54:49 <Drezil> what de you want to do?
15:55:34 <indiagreen> kadoban: it was the trick with adding “import Prelude ()” to the end of your import list, probably
15:55:37 <athan> Denommus: Check out my lib - nested-routes
15:55:43 <athan> @hackage nested-routes
15:55:43 <lambdabot> http://hackage.haskell.org/package/nested-routes
15:56:18 <Denommus> I just want to fetch some merge requests in Gitlab. For each of them that have upvotes - downvotes >= 3, I want to merge them and delete the source branch
15:56:18 <athan> I know I should be using a different data type for this, but is there a `deleteAt` for lists?
15:56:40 <Denommus> athan: I want to make a client, not a server :)
15:56:46 <athan> Oh shoot, sorry. Maybe Haxl is a better choice? Web scraping sucks atm
15:56:49 <athan> (for html, anyway)
15:56:56 <kadoban> indiagreen: Sounds right, I can't recall exactly how it works though … or if it's actually a good idea.
15:57:01 <Denommus> everything is JSON
15:57:07 <Denommus> I think I can do it, it's just... boring
15:57:12 <athan> haha
15:57:21 <Drezil> i do something similar for my yesod-app atm ..
15:57:29 <athan> Denommus: Try making it asynchronous :)
15:57:33 <Drezil> nice frontend for an xml-api
15:58:04 <Drezil> https://github.com/Drezil/eve-api/blob/master/Eve/Api/Char/MarketOrders.hs - like this .. it uses conduit, lens and xml-lens..
15:58:11 <Drezil> you would need aeson for the parsing-part
15:58:27 <Denommus> athan: it's not boring because it's "easy", just because it's contrived
15:58:36 <indiagreen> kadoban: I think it's a bad idea – worse than CPP, in fact (because with CPP it's at least clear what it's for, I can grep for it, etc) – but I guess people would disagree
15:59:10 <kadoban> indiagreen: Yeah that's kinda what I was suspecting. It's going to be some weird magical incantation sitting there.
16:01:54 <Peaker> Why is the GHC ($) hack not for all ((a->b)->a->b) functions, or better yet, for all identity-like functions?
16:02:01 <Peaker> Annoying to have to use ($) in my nice (&) pipeline
16:02:22 <Peaker> (Recognize "$" is a much uglier hack than recognize identity function)
16:04:10 <ReinH> Peaker: you want the parser to recognize functions by type?
16:04:14 <ReinH> How would that work?
16:06:13 <Peaker> ReinH: why the parser?
16:06:31 <Peaker> ReinH: can't it be done during the beginning of type checking, after fetching the names' types?
16:08:12 * hackagebot openflow 0.3.0 - OpenFlow  https://hackage.haskell.org/package/openflow-0.3.0 (AndreasVoellmy)
16:08:39 <ReinH> Peaker: desugaring happens before typechecking, right?
16:08:51 <ReinH> desugaring is a purely syntactic transformation, is it not?
16:09:13 <Peaker> why would the $ hack be during desugaring?
16:09:23 <Peaker> I'm talking about the RankNTypes $ hack to allow  runST $ forever   to work
16:09:34 <ReinH> Oh.
16:09:43 <Peaker> (I don't think anything else specifically searches for the name "$")
16:10:09 <ReinH> Hmm, what am I thinking of then? Maybe nothing.
16:10:13 <ReinH> Sorry.
16:10:14 <Peaker> I have something like: foo & bar & runST & ...      but I have to do:  (runST $ foo & bar) & ..
16:10:23 <ReinH> Ah
16:10:30 <Peaker> because "$" works and "&" doesn't! That's ridiculous
16:11:33 <ReinH> The only difference is that $ is in the Prelude
16:11:41 <ReinH> Not saying that's a counterargument.
16:12:00 <Peaker> Should Generic-derived instances be slower than manual boilerplate?
16:12:22 <Peaker> Should I go for "deriving Generic ; instance NFData" or should I manually boilerplate instance NFData when I care about perf?
16:12:31 <Peaker> (or use TH)
16:12:55 <acowley> There's special code for runST and $
16:13:08 <acowley> It's not just in the Prelude, it's in the type checker :(
16:14:05 <Peaker> acowley: could be nice if the hack was less hacky and just wrote away applications of identity-type
16:14:45 <acowley> Yes, it's hideous. You've probably seen this, but it explains the situation: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18923.html
16:14:49 <Peaker> apply of (x : forall a. a->a) to <arg> -> rewrite to <arg>
16:14:53 <geekosaur> I am under the impression it's more complicated than that
16:15:01 <Peaker> apply of (x : forall a b. (a->b)->a->b) to <arg> -> rewrite to <arg>
16:15:15 <Peaker> then the type check will work?
16:17:21 <khanage> hey guys, i'm trying to write an abstraction over a network proxy
16:17:34 <khanage> i've been looking at pipes, and i've found some examples
16:18:03 <khanage> but it looks like there's no bidirectional usage of sockets in pipes-network
16:18:08 <khanage> such that I can write to a socket
16:18:11 <pacak> khanage: For networking stuff you might also want to look at conduits
16:18:11 <khanage> and read from a socket
16:18:33 <khanage> pacak: ok, i'll take a look
16:19:07 <pacak> or iteratees - it's possible to do bidirectional stuff in there.
16:19:51 <khanage> pacak: there's quite a few options!
16:19:59 <khanage> i've been staring at the docs for pipes for a bit
16:20:11 <khanage> and i have to confess i'm not really sure how to proceed
16:21:36 <pacak> First you need to understand how those constructs are working - for me Oleg's paper did the trick a while ago, after that documentation becomes nice and fluffy.
16:22:15 <acowley> I found Oleg's and the original Iteratees stuff really hard to understand
16:22:24 <khanage> http://okmij.org/ftp/Streams.html ?
16:22:41 <acowley> Pipes and conduits started the trend to clarifying everything, and then I hacked on machines quite a bit and it turned out to not be mysterious.
16:22:46 <pacak> khanage: Yep
16:24:07 <acowley> khanage: You should be able to start in on piecing it together with pipes by writing some IO sockets code and then using yield and await to do some basic sockets-in-pipes things
16:24:08 <pacak> acowley: Hard to understand - yes - that's Oleg's papers after all, but code in examples is very compact
16:25:04 <khanage> acowley: i have something working, but it's fairly unsatisfying as it's using runeffect everywhere
16:25:27 <acowley> pacak: I'm not sure that's always a virtue. I really think tekmo's Pipes tutorial is much better from a usage perspective, and machines is pretty clear once you get over the plan/machine separation.
16:25:29 <khanage> i think i'll go back and write some more primitive combinators and see if that's a bit better
16:25:42 <acowley> khanage: When you say "everywhere" what do you mean?
16:27:13 <lpaste_> khanage pasted “A bad proxy” at http://lpaste.net/137462
16:27:23 <khanage> acowley: this is where I'm at
16:27:28 <pacak> khanage: Look at existing projects using whatever library you want.
16:27:37 <MrMeowMeow> Is Stackage just a restricted subset of Cabal packages (Hackage?) that are tested to work together at compilation?
16:28:09 <bob_twinkles> pretty much
16:28:11 <pacak> MrMeowMeow: Something like that
16:29:52 <naudiz> I want a stateful type that provides messages to the terminal. Is WriterT [Text] (State (GameState a)) Identity the correct type for that purpose?
16:30:14 <pacak> :t RWST
16:30:15 <lambdabot> (r -> s -> m (a, s, w)) -> RWST r w s m a
16:30:40 <naudiz> oh, forgot about that one. thanks
16:31:06 <acowley> khanage: That seems like a pretty good start to me, actually! Have you taken a look at pipes-concurrency?
16:31:52 <khanage> acowley: should I not be looking for a way to leave all this in the pipes?
16:32:46 <acowley> khanage: Perhaps! I'm honestly not sure as I've never done anything with pipes and sockets, so you're the expert in this conversation and I'm the rubber duck.
16:33:13 * hackagebot avers 0.0.9 - empty  https://hackage.haskell.org/package/avers-0.0.9 (wereHamster)
16:33:13 <khanage> i'd be almost happy with it if I knew how I could turn a Consumer a m r -> Consumer a m a
16:33:40 <khanage> acowley: oh dear! i've been stuck on this for a bit
16:33:44 <acowley> Why?
16:34:04 <acowley> I mean, r could be the same as a
16:36:09 <acowley> You can always latch the latest 'a' your Consumer's received, then return it when the Consumer wants to finish with its 'r'
16:36:12 <khanage> alright, maybe I'll try to write it, and see if ghc will let me
16:36:27 <khanage> acowley: that's exactly what I want to do!
16:43:13 * hackagebot filestore 0.6.1 - Interface for versioning file stores.  https://hackage.haskell.org/package/filestore-0.6.1 (JohnMacFarlane)
17:03:14 * hackagebot gridland 0.1.0.1 - Grid-based multimedia engine  https://hackage.haskell.org/package/gridland-0.1.0.1 (jxv)
17:12:55 <broma0> In a monad X a, can I forkIO something of type 'X ()'
17:13:52 <broma0> ive been using something like 'liftIO $ forkIO $ runX mx x'
17:14:22 <hpc> write forkX = liftIO . forkIO -- perhaps?
17:15:13 <broma0> i'd still have to use something like 'runX' to go from 'X ()' to IO x though
17:15:40 <hpc> well, something like that anyway
17:15:52 <hpc> a general rule of programming is "if you like it, give it a name"
17:16:05 <hpc> decide what you like and name it something shorter
17:17:12 <broma0> hpc: i think i can go with something like 'forkX :: X () -> X ()' and imbed a 'liftIO . forkIO' in there
17:17:20 <broma0> hpc: thank you
17:19:22 <orca2585> :t ($$)
17:19:24 <lambdabot> Doc -> Doc -> Doc
17:31:01 <broma0> I have a monad 'type UIM a = R.ReaderT U.UI IO a' and i need a function 'forkUI :: UIM () -> UIM ()' that forks a 'UIM ()' computation on another thread. I can't get this to work
17:31:30 <broma0> My current attempt is 'forkUI p = R.ask >>= (\u -> R.liftIO (C.forkIO $ runUIM p u)) >> return ()'
17:33:07 <anas> Hi, tried using snap framework, and one particular snaplet for web based app in haskell. When I tried to run cabal install the build failed due to dependency reasons. 
17:33:29 <anas> The error I got: https://gist.github.com/anonymous/e4962861fb031e2f7f55
17:33:49 <anas> I got the code from -> darcs get http://hub.darcs.net/wlangstroth/snaplet-file-dialog
17:44:39 <lethjakman-l> so...pattern matching against maybe isn't caught by the compiler correct?
17:45:07 <lethjakman> seems like there should be at least some way to check for all patterns that don't match Just and Nothing
17:45:36 <peddie> lethjakman: -Wall
17:45:54 <athan> How are foldMap and foldr defined in terms of each other?
17:46:18 <lispy> lethjakman: that's called a coverage check, GHC can do it in most cases but some advanced features may have limitations or bugs
17:46:30 <Gurkenglas> athan, https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#foldMap
17:46:42 <lethjakman> ahhh sweet!
17:46:45 <athan> Thanks Gurkenglas
17:47:01 <lethjakman> that seems like all I need atm 
17:47:06 <lethjakman> lispy: do you find it's usually good enough?
17:47:22 <lethjakman> peddie: thanks!
17:47:38 <lispy> lethjakman: yeah, it's super helpful
17:47:40 <lispy> lethjakman: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
17:47:46 <Gurkenglas> Ooh, all of base now has the new source hyperlinking. How long has it been that way?
17:48:10 <lispy> lethjakman: I guess they call it incomplete patterns
17:48:47 <lethjakman> ahhh beautiful
17:48:54 <lispy> lethjakman: there is also this checker: http://community.haskell.org/~ndm/catch/
17:49:34 <lethjakman> that seems nice as well
17:49:50 <lethjakman> pattern matching seems useful, but I thought it wouldn't allow a maybe through if it didn't match everything
17:50:06 <lethjakman> seems like it could be a nice feature to be able to block certain types from pattern matching without all types
17:51:37 <cow_2001> where do i read about how to write proper hackage comments?
17:51:49 <athan> Gurkenglas: I think the only way to make a real Commutative class is to define it at the set-level, not pairwise between terms
17:52:00 <peddie> cow_2001: the package that generates hackage docs is called "haddock"
17:52:10 <cow_2001> ah
17:52:12 <cow_2001> thanks!
17:52:18 <ronh> lethjakman -fwarn-incomplete-patterns will give you a compile time warning for missing matches
17:52:32 <pacak> lethjakman: -Wall
17:52:44 <peddie> cow_2001: the fastest way to get started is to follow the "Source" link on a Hackage page that does what you want to do :)
17:53:02 <cow_2001> hmmmm
17:53:05 <lethjakman> is it possible to toss these in a config file somewhere to make them always run?
17:53:31 <athan> Gurkenglas: Either that, or make a `pick1 :: a -> a -> a` function that randomly chooses either :s
17:53:39 <peddie> lethjakman: you can put {-# OPTIONS_GHC -Wall #-} at the top of your source file or add '-Wall' to the 'ghc-options:' field in your cabal file
17:54:31 <ronh> lethjakman https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/ghci-dot-files.html
17:54:31 <Gurkenglas> athan, rephrase "at the set-level, not pairwise between terms" please. By a Commutative class you meant the one with superclass magma, no definitions and one law?
17:54:57 <peddie> ronh++ for giving the most accurate answers
17:55:37 <athan> Gurkenglas: I've made it a bit like monoid, so that Commutative implements `commute`. Here, one sec
17:56:11 <ronh> yours were fine as well :P. -Wall is a good default
17:57:40 <strikker> what do we gain from haskell being purely functional?
17:58:16 <peddie> @google why functional programming matters pdf
17:58:16 <lambdabot> https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
17:59:29 <athan> Gurkenglas: Here's what I mean by `pick1`: https://github.com/athanclark/commutative/blob/master/src/Data/Commutative.hs#L16
18:00:30 <strikker> peddie coo I will read it!
18:00:50 <Gurkenglas> Endomorphisms are in general not commutative.
18:01:02 <strikker> but as a fast summary, what is the greatest advantage of haskell being purely functional?
18:01:13 <Gurkenglas> Just throwing it out there, you sure were aware of that :P
18:01:16 <Gurkenglas> *ly
18:01:21 <peddie> strikker: I would say "composition"
18:03:04 <Gurkenglas> athan, the class is not supposed to enforce it's laws, just as theoretically nobody but theory itself hinder you from declaring Nat with exponentiation a monoid.
18:03:05 <strikker> interesting
18:04:20 <athan> Gurkenglas: I agree, I just wanted to show a use case
18:05:15 <strikker> I love writing little functions in haskell and it is awesome how short and elegant the code often is. but i cant seem to progress to the next level and actually start writing useful programs
18:06:25 <pacak> strikker: lyah?
18:06:43 <Hijiri> strikker: what resources have you done and what useful programs have you tried to write?
18:06:50 <pacak> strikker: and rwh, there are some examples of bigger programs..
18:09:04 <strikker> I am reading LYAH applicatives in chapter 11. tried to skip to chapter 12 as well, but it didnt lead to anything
18:09:31 <strikker> it all made perfect sense until those chapters
18:09:43 <athan> strikker: You just need better tooling, then you'll get the swing of things. Learn how to use cabal or stack, and how to make your own packages then you'll be up and running
18:10:23 <grantwu> Is Learn You A Haskell a good resource for someone who knows a decent amount of SML?
18:10:40 <peddie> grantwu: no
18:10:43 <grantwu> :C
18:10:51 <peddie> @where learnhaskell
18:10:51 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:11:03 <Hijiri> I've heard LYAH is ok for people who are already comfortable with ML-style functional programming
18:11:06 <pacak> grantwu: it's OK, just forget everything you know about SML
18:11:21 <athan> Honestly, that link should be in the bannar
18:11:41 <khanage> grantwu: http://github.com/nicta/course is good as well
18:12:06 <grantwu> Er... so LYAH is not generally recommended by this channel?
18:12:30 <athan> grantwu: Nah :\
18:12:31 <khanage> grantwu: i liked it, but if you are already well versed, it might be a bit too quick
18:12:33 <geekosaur> we've found in general that it leaves people able to read Haskell code, but not so much write it
18:12:49 <khanage> geekosaur: +1
18:12:50 <Hijiri> strikker: You might want to try the learnhaskell resource listed above too
18:12:57 <Hijiri> it has more exercises
18:13:09 <Hijiri> so you'll be more engaged with writing code
18:13:10 <grantwu> I see... I'm a little curious to find that people are linking general FP resources when I said I had been exposed to SML before
18:13:23 <grantwu> Well, not *general* FP resources
18:13:25 <strikker_> sorry I got disconnected. what resources?
18:13:36 <Hijiri> https://github.com/bitemyapp/learnhaskell 
18:13:56 <Hijiri> http://github.com/nicta/course too, but that's linked in bitemyapp's guide
18:13:56 <buff3r> has anyone tried hackerrank using haskell exclusively?
18:14:28 <Hijiri> grantwu: I think NICTA would still be useful for introducing the abstractions common in Haskell
18:14:38 <grantwu> Hijiri: Okay, thanks
18:14:38 <athan> buff3r: I have, it's okay
18:14:46 <athan> actually pretty easy :x
18:14:50 <dibblego> the question is not if you have or have not used SML, but whether you have completed the tic-tac-toe challenge
18:15:08 <dibblego> https://github.com/NICTA/course/blob/master/projects/TicTacToe/TicTacToe.markdown
18:15:32 <orca2585> :t (&&&)
18:15:33 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:15:58 <MarcelineVQ> this is the first I'm hearing of ML
18:16:29 <geekosaur> haskell lifts a decent amount of syntax from SML, although there are certainly differences
18:16:49 <geekosaur> (and the first version of ghc was written in an SML variant with laziness)
18:20:13 <mauke> dibblego: what is "the (possible) player at a given position"?
18:20:49 <dibblego> mauke: a function that works on any type of board play  eseentially Maybe Player where Player ~ Bool
18:21:00 <dibblego> a given position might not have a player
18:21:18 <buff3r> athan: cool
18:21:23 <mauke> wait, a player is a function?
18:21:34 <dibblego> data Player = Naught | Cross
18:21:39 <mauke> that's not a function
18:21:43 <dibblego> it isn't
18:21:47 <mauke> ...
18:21:58 <dibblego> Position -> Board -> Maybe Player
18:22:18 <mauke> this seems unrelated to my question
18:22:59 <dibblego> no, player is not a function, Player is a data type
18:23:08 <Hijiri> you could church encode Player
18:23:11 <dibblego> playerAt :: Position -> Board -> Maybe Player -- returns the (possible) player at a given position.
18:23:12 <Hijiri> then it would be a function
18:23:17 <mauke> dibblego: what is "the (possible) player at a given position"?
18:23:40 <dibblego> either a naught or a cross, if it exists, at a given position
18:24:13 <mauke> oh, so it just indexes into the board
18:24:23 <mauke> it doesn't tell you who could potentially play that position
18:24:32 <dibblego> yes, importantly, it works on any board type (in play, finished)
18:24:39 <dibblego> right
18:24:59 <mauke> takeBack is rather underspecified
18:25:21 <dibblego> yeah agree
18:25:22 <mauke> takeBack = const someBoardInPlay
18:25:37 <dibblego> there is a test for it further down
18:26:27 <mauke> positionIsOccupied is not defined
18:26:36 <mauke> the test is underspecified
18:27:21 <mauke> I guess it's supposed to be isJust .: playerAt
18:29:14 <athan> Is there an example where a Foldable isn't a Functor?
18:30:26 <Hijiri> Set ?
18:30:42 <athan> hiberno: Ahh, thank you
18:30:48 <athan> erp Hijiri
18:31:03 <athan> Hijiri: I just find it counterintuitive with `foldMap`
18:34:03 <nshepperd> GADT things that can only contain restricted types of things can be foldable without being functor
18:34:28 <arkeet> Set is another example.
18:36:37 <nshepperd> and of course MonoFoldable does away with the functoriality altogether, so you can use it with things like Data.Text
18:48:28 <ttt_fff> how can I learn how to write high performance haskell webserver code ?
18:48:37 <ttt_fff> i'm specially afriad of memory leaks (due to laziness)
18:48:42 <ttt_fff> and unevalauted thunks all over the place
18:49:49 <pacak> ttt_fff: wai?
18:50:45 <athan> ttt_fff: Wai has been great for me
18:50:55 <ttt_fff> pacak, athan: noted, thanks!
18:50:59 <athan> 20k+ responses/sec on my laptop (tested with apache, albeit :\)
18:51:31 <athan> Gurkenglas: I want to make a restriction that every Mergeable should be a Functor :\
18:51:43 <athan> (for mergeMap)
18:54:50 <Hijiri> athan: Lost connection so I don't know if someone answered already, But is Set Foldable?
18:55:32 <Axman6> I would hope so
18:55:33 <nitrix> :i Set
18:55:39 <nitrix> :info Set
18:55:49 <Hijiri> > F.fold S.empty
18:55:51 <lambdabot>  ()
18:55:57 <Hijiri> looks like it is
18:56:02 <arkeet> it is.
18:56:04 <arkeet> and it's not Functor.
18:56:22 <nitrix> > import Data.Set
18:56:23 <lambdabot>  <hint>:1:1: parse error on input ‘import’
18:56:33 <nitrix> Is lambdabot documented anywhere?
18:56:48 <arkeet> you can @let import stuff, but Data.Set is already imported qualified as S
18:56:51 <arkeet> :t S.empty
18:56:52 <lambdabot> S.Set a
18:57:21 <nitrix> How does one do :info ?
18:57:36 <Axman6> lambdabot is not ghci
18:57:47 <arkeet> you can't.
18:57:53 <nitrix> I've seen people do it...
18:58:08 <arkeet> they didn't really do it.
18:58:34 <nitrix> A list of instances popped up. Or did I immagine all that.
18:59:04 <athan> :i S.empty
18:59:04 <arkeet> you probably imagined it.
18:59:28 <Sindriava> @info S.empty
18:59:28 <lambdabot> S.empty
18:59:43 <Sindriava> Huh
18:59:55 <athan> so much info
18:59:57 <arkeet> it's not really @info.
19:00:03 <arkeet> it autocorrects it to some other command.
19:00:08 <arkeet> I can't remember exactly what.
19:00:10 <Hijiri> undo
19:00:11 <Sindriava> @info (+)
19:00:11 <lambdabot> (+)
19:00:14 <arkeet> oh right.
19:00:19 <arkeet> @info do { x <- a; f x }
19:00:19 <lambdabot> a >>= \ x -> f x
19:02:05 <nitrix> @info (f x) && (g x)
19:02:05 <lambdabot> (f x) && (g x)
19:02:08 <Sindriava> @let koala = "ʕ  •ᴥ•ʔ"
19:02:09 <lambdabot>  Defined.
19:02:17 <athan> lol
19:02:30 <MarcelineVQ> > id koala
19:02:31 <lambdabot>  "\661  \8226\7461\8226\660"
19:02:33 <arkeet> > text koala
19:02:34 <lambdabot>  ʕ  •ᴥ•ʔ
19:02:39 <Sindriava> > reverse koala
19:02:41 <lambdabot>  "\660\8226\7461\8226  \661"
19:02:45 <nitrix> Is there a way to get from `\f g x -> (f x) && (g x)` to `\f g -> liftA2 (&&) f g` ?
19:02:48 <Sindriava> > text $ reverse koala
19:02:49 <lambdabot>  ʔ•ᴥ•  ʕ
19:02:51 <nitrix> Like a reduction tool ?
19:03:31 <peddie> @pl \x -> (f x) && (g x)
19:03:31 <lambdabot> liftM2 (&&) f g
19:03:41 <nitrix> brilliant :)
19:03:42 <peddie> nitrix: use sparingly
19:04:00 <Sindriava> nitrix: Aim for readability instead of cleverness
19:04:04 <peddie> nitrix: pl is a great way to make your code impossible for you to read the next day
19:04:37 <arkeet> liftA2 (&&) is pretty reasonable I think.
19:11:28 <Sindriava> Hlint is the best thing since sliced bread
19:11:42 <Sindriava> sequence . take n . repeat? Why not replicateM!
19:12:08 <nitrix> Yup !
19:12:36 <nitrix> Now, if only I could get all these tools to work togheter... :P
19:12:59 <Sindriava> nitrix: I'm pretty happy with my Vim config, except for ghc-mod
19:13:42 <nitrix> Mine is like 10 years old and kind of accumulated hacks. I can't even upgrade pathogen.
19:13:52 <kaidelong> "map text $ permutations koala" causes lambdabot to spout a lot of garbage, is that because it doesn't properly separate lines when printing unicode on multiple lines?
19:14:11 <Sindriava> nitrix: Oh man, pathogen is outdated
19:14:29 <nitrix> Sindriava: See what I mean D:
19:14:45 <Sindriava> nitrix: github.com/sindriava/dotvim Here's my config, I'm sure you can find something of use tehre :)
19:14:59 <nitrix> Will check :P
19:15:28 <nitrix> I can't remember if it's Snap or Yesod that I liked better.
19:15:29 <Sindriava> nitrix: I've migrated to NeoBundle last week, it's a lot better. For example, when I save my Vimrc, it asks to install the new plugins I added :)
19:16:28 <kyagrd> 학교에서는 웹프로그래밍을 가르친다는 핑계로 스태틱 타입 교리를 전파하기도 좋은 플랫폼이고
19:16:51 <kyagrd> Ah, mixed up channel sorry.
19:17:02 <nitrix> Snap is the one with combinators and Yesod the one with quasiquoting?
19:17:23 <Sindriava> nitrix: Yeah, I think so
19:17:46 <Sindriava> nitrix: I've found the quasiquoting for routes a bit excessive
19:19:07 <Sindriava> @t text
19:19:07 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
19:19:35 <Sindriava> @type text
19:19:36 <lambdabot> String -> Doc
19:20:04 <L8D> :t text
19:20:05 <lambdabot> String -> Doc
19:20:33 <Sindriava> kaidelong: It works for me in ghci as expected ¯\_(ツ)_/¯
19:21:50 <Sindriava> Not sure if this is too offtopic, but it's helping me stay motivated when I'm learning Haskell: https://www.youtube.com/watch?v=E1oZhEIrer4
19:22:03 <kaidelong> "text $ unlines $ permutations koala" works fine
19:22:17 <kaidelong> so yes, I think that's exactly right, it inserts a line break in the middle of a unicode char
19:22:30 <kaidelong> mm, this would be a bug in lambdabot, I think
19:22:35 <Sindriava> Well, I guess it's a good video to see as a programmer anyways
19:23:04 <Sindriava> kaidelong: Sounds reasonable. Find a couple more cases to reproduce it and file a bug report?
20:01:58 <erikd> alex lexer anyone? is it possible to call runAlex directly with an input string and get back a list of tokens? if so how?
20:08:46 <srhb> erikd: runAlex, no. Perhaps something that runAlex uses, though.
20:10:34 <srhb> erikd: parseScript looks like a likely candidate.
20:10:58 <srhb> erikd: But even it and alex use IO.
20:11:04 <erikd> srhb: parseScript from where?
20:11:18 <srhb> erikd: Look in src/Main.hs
20:11:31 <srhb> erikd: You'll see that it's rather unwieldly for that purpose.
20:11:46 <erikd> sorry, src/Main.hs from where?
20:14:23 <srhb> erikd: alex. :)
20:14:50 <srhb> erikd: That's what we're talking about, isn'it? Or am I confused. :P
20:14:59 <erikd> srhb: yes, i have a working alex lexer and happy parser, but i'd like to test the lexer in isolation.
20:16:02 <srhb> erikd: Right, what I'm saying is that it's coupled very much to the IO that it does. You can see for yourself by looking in src/Main.hs of the alex source tree.
20:16:27 <erikd> srhb: runAlex in src/Main.c of the alex soruces is not the same as the generate runAlex function which has a type of runAlex :: String -> Alex a -> Either String a
20:17:13 <srhb> erikd: I guess I know nothing then. :)
20:17:45 <erikd> ok, thanks anyway
20:19:12 <nkaretnikov> what's the haskell os mentioned in https://www.reddit.com/r/programming/comments/3ejsyq/john_carmack_why_functional_programming_is_the/ctfxpsa ?
20:19:29 <srhb> nkaretnikov: Is it HalVM?
20:19:57 <erikd> nkaretnikov: more likely house : http://programatica.cs.pdx.edu/House/
20:20:14 <srhb> House is rather dead, though.
20:20:19 <erikd> yes
20:20:22 <srhb> But yeah, probably. :)
20:20:23 <nkaretnikov> ah, right, I actually heard about house yesterday but forgot the name
20:33:09 <jle`> did house strive to be more than a poc/experiment?
20:34:21 <nkaretnikov> looking at the links, probably the former
20:35:03 <nkaretnikov> ugh, I misread.  I mean, it looks just like a poc
20:35:40 <gganley> poc?
20:35:48 <nkaretnikov> proof of concept
20:35:54 <gganley> ah
20:38:12 <gganley> edwardk: I konw i ask this everytime I come into this channel but are the meetups still the 3rd wednsday of the month
21:06:16 <ttt_fff> I ❤ haskell.
21:23:50 <conal> Is the Monad instance for (,) o (for Monoid o) somewhere in base?
21:25:25 <mjrosenb> conal: why does o need to be a monoid?
21:25:40 <conal> mjrosenb: for >>=
21:25:51 <conal> mjrosenb: even for <*>
21:27:09 <conal> it's equivalent to the writer monad, but lighter weight notationally.
21:27:47 <mjrosenb> why does ((_, v) >>= f = f v) not work? or does it work, and you want the extra behavior?
21:27:58 <dolio> conal: It is in 7.11.
21:28:03 <dolio> Not in 7.10 apparently.
21:28:14 <conal> dolio: ah. thx. 
21:28:56 <dolio> The Applicative is in 7.10.
21:29:03 <dolio> Not sure how that happened.
21:29:11 <conal> wow. luqui asked this question in 2010: https://stackoverflow.com/questions/4204086/is-the-monad-w-instance-anywhere-standard
21:30:11 <mjrosenb> wow, this code ties itself in so many knots, it could trap houdini.
21:34:17 <mjrosenb> basically every method now takes as an addidional parameter, its own output (in the normal case)
21:34:35 <mjrosenb> and in exceptional cases, its own output, run through some transformation function.
21:38:05 <johnw> mjrosenb: that wouldn't satisfy the right identity law
21:38:26 <johnw> (o, v) >>= return would be the same as return v, discarding the o
21:38:49 <mjrosenb> johnw: ahh
21:39:19 <mjrosenb> actually, I don't think you could implement return without a monoid identity element
21:39:29 <johnw> nope
21:39:50 <mjrosenb> but return isn't <*> (I have no clue what <*> is, I just use it sometimes)
21:40:10 <johnw> (a, f) <*> (b, x) = (a <> b, f x)
21:40:15 <johnw> for the instance conal is thinking of
21:43:51 <mjrosenb> yeah, I figured out what it needed to be, just not /why/ it needed to be.
21:44:21 <johnw> depending on the degree of "why" you want to know about, that could be a brief or a long discussion :)
21:49:52 <mjrosenb> well, the fact that you can't reasonably implement return is a pretty good reason for me.
21:50:38 <athan> mjrosenb: return x = (mempty, x)
21:50:41 <athan> :|
21:50:53 <mjrosenb> athan: yes.
21:51:00 <athan> reasons ftw
21:51:15 <athan> mjrosenb: Why isn't it reasonable?
21:51:29 <mjrosenb> it is
21:51:40 <mjrosenb> just try doing it without a Monoid instance!
21:51:53 <mjrosenb> (which is what I was asking about)
21:52:50 <athan> mjrosenb: Oh no, without the monoid you're beaned for sure
21:59:01 <Axman6> What's the name of a lens which lets you apply a function to the focus? something with :: (a -> b) -> Lens s t a b
21:59:17 <pacak> :t over
21:59:19 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:59:50 <pacak> > over _1 (+1) (0,0)
21:59:52 <lambdabot>  (1,0)
22:00:14 * athan thinks you should have used 9000 somewhere in there
22:00:46 <pacak> athan: my bad.
22:00:51 <athan> :v
22:01:14 <Axman6> is there an infix version of over?
22:01:22 <athan> %=?
22:01:30 <Axman6> :t (%=)
22:01:32 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
22:01:37 <athan> er
22:01:41 <athan> %~
22:01:52 <athan> :t (%~)
22:01:53 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
22:01:56 <Axman6> yeah I was going to say, = is usually the state version
22:02:02 <Axman6> ok excellent
22:02:16 <mjrosenb> so, I know that my code will be like 30 lines cleaner if I use lenses
22:02:18 <athan> I should start using lens...
22:02:37 <mjrosenb> but oh god, those types look absolutely cthulic
22:02:48 <davidfetter> iaaa, iaaa
22:03:09 <athan> mjrosenb: After you make your own type-level scheme interpreter, it's not that bad
22:03:39 <Axman6> mjrosenb: yeah they're pretty impenatrable, but bring with them a huge amount of power
22:11:32 <johnw> over's type is saying: Given a setter, and a function-like thing, transform a value
22:12:13 <Xe> :t ($)
22:12:15 <lambdabot> (a -> b) -> a -> b
22:17:09 <magistr> How to read it data ShowObj = forall a. Show a => ShowObj a
22:31:27 <NeverDie> Anyone here hiring?
22:43:52 <gfixler> :(
22:45:18 <AshyIsMe> damn, i was hoping NeverDie would work for payment in hopes and dreams...
22:59:53 <magistr> How to read it data ShowObj = forall a. Show a => ShowObj a
23:04:49 <Axman6> magistr: you can't really. It might be possible if you had (Show a, Read a)
23:05:19 <Axman6> magistr: oh, do you mean what does that expression mean?
23:06:18 <magistr> Axman6, what that exprassion mean, type constrate?
23:10:19 <Axman6> magistr: yes, it says that a ShowObj can hold any type, as long as the type implements Show. It can be used to do things like: [ShowObj True, ShowObj 3.14, ShowObj "a string"] :: [ShowObj]
23:11:41 <ThomasLocke> Any emacs users here who'd be willing to share their .emacs? I'm fairly new to both emacs and Haskell, and I'm having some trouble getting my dev environment up and running.  :o)
23:11:47 <Axman6> Basically all you can do with something of type ShowObj is call `show` on the value contained within the ShowObj, because you don't know anything more about the type of `a`
23:12:25 <tamasgal> ThomasLocke: if you're new to emacs than let it go and switch to VI the sooner the better ;)
23:13:15 <Haskellfant> ThomasLocke: https://github.com/cocreature/dotfiles/blob/master/emacs/.emacs.d/emacs.org#haskell
23:13:21 <Haskellfant> that's mine
23:16:58 <magistr> Axman6, ok, thanks...
23:29:51 <lewis1711> is there some fancy haskell computer science name for data? I mean plain old data, because of course functions can be data in haskell. and I guess data can be functions with zero arguments, or something
23:31:42 <quchen2> Functions are plain old data.
23:32:22 <lewis1711> yes, but that's being pedantic
23:32:25 <quchen2> Call something "not a function" and you've probably got the best name available. But inside "not a function" data you can have functions of course.
23:33:25 <ThomasLocke> tamasgal, Hehe.. The good old editor wars!
23:33:28 <ThomasLocke> Thanks Haskellfant 
23:33:29 * hackagebot snap-extras 0.11.0.1 - A collection of useful helpers and utilities for Snap web applications.  https://hackage.haskell.org/package/snap-extras-0.11.0.1 (DougBeardsley)
23:33:36 <tamasgal> ;)
23:35:31 <ThomasLocke> Haskellfant, That is a very impressive .emacs setup you have. Thanks a bunch! :o)
23:35:41 <lewis1711> there's an editor war? I thought that stopped after nano won in 2003
23:36:00 <orca2585> :t on
23:36:01 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:36:14 <tamasgal> nano?!
23:36:31 <jle`> lewis1711: you're sort of asking for something like "is there a haskell name for plain old data, that isn't integers?"
23:36:44 <jle`> and not-integers is probably the best thing you're going to get
23:36:48 <chuckrock> 15,3"   8,1e   7,3`   8,11)   15,16   15,13G   7,11`   10,14?    5,7y   4,2=   3,5?   11,7%   2,10c   11,2l   2,1<   4,0V    8,1h   2,15=   7,64   11,8Q   15,14n   10,5p   13,15T   8,1B    10,3[   153   7,11{   5,135   10,5<   8,0V   15,7)   10,12J    7,11    15,12?   9,15z   8,3+   0,14(   5,12:   15,1S   7(    61   13,11.   11,2Z   13,1-   10,3
23:37:02 <chuckrock> 4,10^   0,2e   12,1W   1,6@   6,9H   7,6<   15,1*   11,6M    9,7Q   14,15"   7,3_   0,4'   11,00   9,2b   11,8u   12,0P    14,155   2,10"   3,4q   3,2a   5,9_   2.   1,5"   1,14:    8,10    7,6K   13,5P   4,7/   1,10@   5,13'   8,3|   15,5c    9,7"   4,8H   1,0:   7,8}   12,5r   1,10x   1,11f   4,1f    10,9x   8~   2,0}   6,8F   8,9a   15,1_   
23:37:10 <chuckrock> 15,111,6O   13,0H    14,12-   2,13p   12,6i   5,15i   5,1c   3,7b   12,15D   10,14J    
23:37:13 <chuckrock> 10,3#   3,6&   3,4+   8,0B    7,1v   15,3~   5,4-   2,15;   13,1r   10,2    5,12    1,15z    
23:37:15 <chuckrock> 0,77   4,5Z   11,77   3,4|   14,96   2,14f   6,1$   2,13)    8,2l   13,12\   13,3s   2,8L   13,0c   0,4^   14,13t   0,11X    6,13Y   9,10b   1,2O   15,6r   13,10<   15,2e   12I   13,6%    11,3v   12,15O   2,12)   11,6l   12,99   12,8,   7,5c   11,4'    1,14,   6,9w   14,5j   4,8R   14,3}   0,5K   12,14S   3,97    8,15y   9,0H   0,7V   11,5|   5,9
23:37:19 <chuckrock> 5,9]   11,8M   8,1Z   3,13[    1,0u   10,14*   2l   115   12,5h   7,10b   13,4=   8,12j    
23:37:20 <chuckrock> 14,7.   9,8W   8,3M   15,5;   15,1x   6,13<   14,4=   11,1:    7,10X   4H   2,8:   14,2Y   11,10\   6c   15,91   6,0Z    3,14L   11,9v   6,0g   14,4^   9,7k   12,5i   8,0P   6,11!    5,15/   5,1]   3,88   12,0(   13,2T   1,14F   8,3O   14,100    14,12M   5,7K   10,12[   6,1B   6,4V   0,1a   1,14Q   0,15#    9,8=   14,6B   11,4s   14,9G   12,4(   
23:37:22 <Xe> @where ops
23:37:22 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:37:26 <chuckrock> 12,410,7k   0,111   1,12o    2,10>   3>   12,2[   10,8z   5,12o   3,67   0,10<   10,4&    
23:37:30 <chuckrock> 3,6Q   10,8p   10,11v   1,7v   4,1w   12,6H   5,10+   8     0,4E   15,79   9,10p   0,4B   2,14Y   13,15l   11,3S   0,15Z    2,57   10,13*   12K   3,12r   14,5T   0,6:   10,8B   15,5.    12,03   11,1K   0,3j   15,14>   8,10H   5,13&   9,12D   7r    9,6A   9,5a   8,2j   11,13Y   14R   5,12]   10,4{   11,9r    9,2W   12,9    5,2H   6,11G   12,3m   
23:37:31 <chuckrock> 12,33,15+   11,13t   7,2B    0,12]   4,8/   6,1i   3,13~   13,2)   12,8J   1,4.   8D    
23:37:31 <jle`> as far as types go haskell doesn't really treat (->) Int Bool any differently than, say, Maybe Bool, or Int
23:37:32 --- mode: ChanServ set +o shachaf
23:37:32 --- mode: ChanServ set +o Cale
23:37:33 <chuckrock> 10U   11,03   15,8B   5,9,   9,6(   6,81   2,0[   4,5i    12,13/   9,0h   6,11E   1,6&   12,56   2,11I   3,4W   10,0F    12,1d   0,6L   13,3X   6A   12,14c   13,4f   10,7}   5,8d    9,0[   3,1g   15,2J   0,8v   13,11O   3,14m   15,13R   13,16    7,114   3,0X   2,9R   12t   12,113   12,3'   9,14S   12,13A    11,10p   8,11(   15,79   2o   5,1?   
23:37:35 <chuckrock> 5,11,131   14,9F   3,5!    12,148   14,10V   11,6H   1,14=   15t   13,0A   3,57   2,6~    
23:37:37 --- mode: Cale set +b *!*@tgn.188.23.73.dts.mg
23:37:37 --- kick: chuckrock was kicked by Cale (chuckrock)
23:37:37 --- mode: ChanServ set +o dolio
23:37:51 --- mode: dolio set -o dolio
23:37:52 --- mode: shachaf set -o shachaf
23:37:59 --- mode: Cale set -o Cale
23:38:32 <peterson> Cale: thx
23:38:43 <lewis1711> jle`, never thought of it that way I guess. I am comfortable with the whole higher order functions thing but I still view "normal" data as different
23:39:40 <jle`> yeah, non-function is probably the best you can get.  like non-Maybe, non-IO, non-Integer, etc.
23:39:55 <jle`> as far as haskell is concerned
23:40:10 <Cale> Maybe you're looking for "value of an algebraic data type"?
23:40:47 <magistr> what a nice, good project with exhibit haskell code to learn it?
23:40:53 <jle`> newtype NotAFunction = NAF (Int -> Bool) ?
23:40:59 <jle`> s/newtype/data
23:41:35 <Cale> Maybe I should say polynomial data type :)
23:41:49 <Cale> i.e. sum of products only
23:41:51 <nshepperd> one property shared by most things people consider "normal" data is that they can be serialized
23:43:22 <nshepperd> or at least printed
23:44:14 <AshyIsMe> magistr: this was a fun one: https://wiki.haskell.org/Roll_your_own_IRC_bot
23:44:58 <magistr> AshyIsMe, ok, a lot of thanks
23:49:30 <quchen2> Cale: Isn't a->b "algebraic" as well?
23:50:39 <Cale> quchen2: I've often heard "algebraic" specifically used to mean possibly recursive sum of product types
23:51:05 <Cale> There are a lot of things which don't work out quite so well once you put in exponentials.
23:53:21 <magistr> has haskell actors model library, like erlang?
23:58:02 <Saizan> Cale, quchen2: you need a regular ordinal to build the fixpoint! in Set at least
23:58:30 * hackagebot moesocks 0.1.0.2 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.2 (JinjingWang)
23:59:10 <pharaun> that was a new one, never saw spam that used rainbow colors :p
23:59:43 <jle`> 05w04h07o08a
23:59:44 <Axman6> magistr: Haskell has very good support for concurrency
