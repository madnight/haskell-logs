00:00:04 <johnw> I've been using ACL2 a lot recently though
00:00:09 <lispy> This time with an emphasis on 'diadactic' proofs aka Isar mode
00:00:15 <johnw> and others at work are using Isabelle, although not directly with Haskell
00:01:13 <lispy> I've been focusing on the default logic, which is HOL, and that's nice for traditional mathematics. I bet Coq is good for program verificatin, like VST.
00:01:39 <johnw> i'm using it to construct a verified Haskell library
00:01:40 <lispy> johnw: you're in California now?
00:01:43 <johnw> yes!
00:01:49 <lispy> nice
00:02:14 <lispy> verified Haskell? So how do you translate your Haskell?
00:02:21 <johnw> Coq extraction
00:02:39 <lispy> Okay, so you have to write the Haskell in Coq and then extract it?
00:02:44 <johnw> for Haskell -> Coq, I do it manually, but using a library I'm working on called "coq-haskell", that bridges some of the gap
00:02:52 <sccrstud92> johnw: is that a library of verified haskell code, or a library to allow you to verify haskell code?
00:02:56 <lispy> Wouldn't it be nicer to translate Haskell to Coq and then prove theorems there about the Haskell?
00:03:17 <johnw> it's about producing a verified Haskell library for use by Haskell programmers, although the code is maintained in Coq
00:03:29 <johnw> lispy: I do that too
00:03:36 <lispy> johnw: have you thought about using the ghc api to generate Core and then formalize core in Coq?
00:03:50 <johnw> I have thought about it a tiny bit, but would like to more
00:03:59 <johnw> System F is likely much more amenable to automated translation
00:04:07 <johnw> and I could build a System F in Coq easily enough perhpas
00:04:23 <lispy> johnw: I'll just leave this here: https://github.com/atomb/core-to-isabelle
00:04:30 <johnw> nice!
00:04:50 <johnw> i'll mention this to work folks
00:04:58 <lispy> Well, it's horribly incomplete
00:05:13 <lispy> It was an evenings/weekends project that never got of the ground
00:05:19 <johnw> i like the concept
00:06:16 <lispy> Something that is often overlooked in giving a semantics to Haskell is _|_
00:06:25 <lispy> HOLCF can model _|_ just fine
00:06:35 <lispy> So that's a leg up that Isabelle has over Coq
00:07:00 <johnw> i probably won't be able to transport it directly to Gallina, but will need to use an abstract model of System F + ⊥
00:07:17 <julianleviston> Is bottom bottom because (_|_) looks that way?
00:07:18 <lispy> Do you have scott domains?
00:07:28 <johnw> what are scott domains?
00:07:37 * hackagebot wai-extra 3.0.8.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.8.0 (MichaelSnoyman)
00:07:37 * hackagebot wai-handler-launch 3.0.0.4 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0.4 (MichaelSnoyman)
00:07:41 <lispy> julianleviston: heh, it's because of latices. there is top and bottom.
00:07:56 <julianleviston> lispy: yeah, I was just being stoopid ;-)
00:08:13 <lispy> johnw: I can point you at the wikipedia page, but I'm not qualified to explain what you find there: https://en.wikipedia.org/wiki/Scott_domain
00:08:37 <johnw> ah, I do not know, then
00:09:09 <lispy> cpos are a nice way to give semantics, and they use a lot of topology, but I don't understand much else about them
00:11:19 <lispy> johnw: anyway, please let me know if you have anything to share on the topic of verified Haskell. That's something I (and Galois) would be very interested in having.
00:11:44 <julianleviston> lispy: hey, have you seen this http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
00:11:56 <julianleviston> lispy: I’m sure you probably have.
00:12:30 <johnw> lispy: and have you seen http://www.megacz.com/berkeley/coq-in-ghc/
00:13:01 <lispy> julianleviston: yeah, that's one of my favorite papers. I give that URL to beginners a lot :)
00:13:29 <lispy> johnw: oh, yeah I saw that a long time ago. Never really looked into it properly.
00:21:06 <johnw> i've recreated enough of Lens in Coq that working with StateT is now quite convenient: _lens %= IntMap_insert key value
00:21:25 <johnw> I need to build out the Map combinators next
00:23:10 <lispy> interesting
00:27:00 <lispy> johnw: tangentially related: http://ecaustin.github.io/haskhol/
00:27:32 <johnw> thank you
00:27:59 <lispy> It's quite different than your goals. It embeds a DSL for HOL in Haskell
00:28:08 <lispy> But still useful and still interesting
00:28:11 <johnw> that's still within range of my goals
00:29:26 <lispy> Well, as I understand it HaskHOL doesn't let you prove anything about your program.
00:29:35 <lispy> It's just HOL inside Haskell syntax
00:29:40 <johnw> i'll read the PDFs
00:29:44 <mniip> so am I correct in understanding that monads are just polymorphic coalgebras, and comonads are polymoprphic algebras?
00:29:47 <johnw> hopefully see the presentation at ICFP
00:31:14 <mniip> chirp chirp chirp
00:31:40 <johnw> mniip: it sounds wrong
00:31:41 <lispy> mniip: I don't know the answer. Hopefully someone will come by that does.
00:32:12 <mniip> hmm
00:32:23 <mniip> forgot about join/duplicate
00:32:39 <johnw> what leads you to reach this idea?
00:32:55 <mniip> well, Coalgebra f a = a -> f a
00:33:00 <mniip> return :: a -> m a
00:34:41 <johnw> asking if return is a colagebra is very different from says that monads are polymoprphic coalgebras
00:35:31 <julianleviston> god reading haskell sucks if you don’t know the libraries that are being imported.
00:36:06 <lispy> sometimes it's enough to know the types and the intention
00:36:21 <julianleviston> Have to go hunting thru 30 libraries to find the definition of </>
00:36:27 <lispy> But in general, (and in every language I've learned) yes you're rigt
00:36:30 <julianleviston> Oh… I found it.
00:36:34 <julianleviston> System.Filepath
00:36:49 <johnw> julianleviston: loading the module into ghci, and asking :i (</>), should have told you
00:36:54 <julianleviston> lol. they’ve imported it twice. lol
00:37:03 <julianleviston> johnw: I’m reading it on github.
00:37:06 <johnw> ah
00:37:15 <julianleviston> johnw: thanks, tho! :)
00:37:21 <verement> @hoogle (</>)
00:37:21 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
00:37:21 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
00:37:22 <johnw> the "worlds of pain" approach, got it
00:37:30 <lispy> x </> y = x ++ "/" ++ y, roughly
00:37:54 <julianleviston> johnw: not sure which is more painful, to be honest ;-)
00:38:17 <mniip> johnw, a monad is a combination of a polymorphic coalgebra (return) and a coalgebra composition operation (>=>)
00:38:41 <lispy> the convention for angle brackets is that it uses the argument on that side. So < uses the left argument and > uses the right argument. So </> is meant to put slash between the left and right argument.
00:39:09 <julianleviston> lispy: no offense, but that’s kind of like teaching the rules of english.
00:39:12 <mniip> lispy, TIL
00:39:21 <lispy> julianleviston: fair point!@
00:39:25 <lispy> s/@//
00:39:54 <mniip> but how do you explain <=< >=> >>= =<< >>> <<<  then
00:39:57 <julianleviston> lol
00:40:23 <johnw> mniip: in Haskell the shape of return is always a -> m a, but generally it's id ~> m, or a natural transformation from the identity functor to m.  If you're making the point that such natural transformations are also coalgebras, you could well have a point there
00:40:38 <lispy> mniip: heh
00:41:51 <lispy> functors in haskell are from Hask to (enriched) Hask, is an important but oft implicit
00:42:00 <lispy> er, is important*
00:42:22 <julianleviston> lispy:  implicit what?
00:42:32 <mniip> enriched?
00:42:41 <lispy> julianleviston: sorry, the 'an' was a typo
00:42:52 <julianleviston> oh
00:43:09 <julianleviston> that still doesn’t make sense
00:43:14 <lispy> mniip: roughly meaning, you map onto a more structured version of Hask
00:43:34 <julianleviston> do you mean “The fact that functors in Haskell are from Hask to (enriched) Hask is important, but often implicit” ?
00:43:39 <mniip> oh you mean that there's no identity functor?
00:43:41 <julianleviston> I still don’t get it.
00:43:45 <lispy> julianleviston: You're right. I fail english.
00:44:00 <julianleviston> lispy:  I don’t care about that, I just want to know what you mean! LOL
00:44:13 <julianleviston> lispy:  your English-fu is excellent!
00:44:14 <lispy> mniip: there is an identity functor, but we just don't write it. We omit it.
00:44:36 <julianleviston> ah ok.
00:44:54 <mniip> the closest we have to an identity functor is a newtype synonym like Identity
00:45:01 <lispy> Instead of return :: Id a -> m a we write return :: a -> m a
00:45:25 <johnw> mniip: which isn't identity, because ! (a ~ Identity a)
00:45:28 <julianleviston> isn’t that unit? or is that only monads?
00:46:16 <johnw> the Identity functor is isomorphic to the (unwritten) identity functor
00:46:38 <julianleviston> god I love Haskell.
00:46:45 <mniip> okay then
00:47:07 <johnw> julianleviston: to which "unit" do you refer?
00:47:09 <mniip> what is a 'comonad coalgebra' then?
00:47:38 <julianleviston> johnw: fair point! LOL
00:47:53 <mniip> any unit because they're all isomorphic
00:48:11 <johnw> https://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
00:48:17 <johnw> see the section "Coalgebras of a comonad"
00:48:39 <johnw> it's a coalgebra, a -> f a, with some extra structure relating to the comonadic nature of f
00:48:45 <nshepperd> type family Id a where { Id a = a } -- you can't give this a Functor instance
00:49:19 <lispy> yeah, you can't define the meta identity functor in Haskell and still have it mean identity
00:49:58 <lispy> (when I invoke "can't" like that, it's really an invitation for Oleg to find a way)
00:50:04 <johnw> lol
00:50:10 <julianleviston> The thing that always bothered me about fmap vs map was that they’re the same function, even though they’re not.
00:50:12 <nshepperd> and, it would be useless, even if you could, because afaik you really need the wrappers like Identity so that we know what instance to use
00:50:42 <johnw> nshepperd: right, because absolutely everything would have the identity instances
00:50:44 <mniip> julianleviston, map is a specialization of fmap
00:51:09 <julianleviston> mmm but why use map?
00:51:28 <johnw> it makes it clear you mean to work on a list
00:51:44 <julianleviston> johnw: doesn’t the list make that clear?
00:51:50 <johnw> should do, yes
00:51:51 <mniip> the version I've heard is that map is separate from fmap so that newbies don't get lenslike error messages from simple list operations
00:52:01 <julianleviston> ah ok.
00:52:07 <johnw> that's just the only reason to use map
00:52:19 <johnw> if you want an error, should someone switch the type to something other than a list...
00:52:29 <lispy> it's true. That's the same justification given for removing monad comprehensions in favor of list comps
00:52:37 <johnw> and i wonder if 'map' can optimize better
00:52:38 <julianleviston> belongs in the “here’s another thing to remember” box, and Haskell is kind of full of those.
00:52:46 <lispy> (which we have again as an extension, which is perfect)
00:52:51 <mniip> johnw, they're identical
00:53:04 <mniip> they both fuse with other list operations
00:53:15 <johnw> nice
00:53:31 <lispy> wouldn't fmap only fuse if GHC can specialize it to lists?
00:53:56 <julianleviston> We need specificity inference. ;-)
00:54:15 <julianleviston> But I’m probably missing large chunks of understanding :)
00:54:17 <lispy> no joke, GHC does amazing things when everything is specalized and inlined
00:54:39 <nshepperd> presumably the only time it can't specialize it is when 'map' would be a type error
00:54:56 <nshepperd> because the type is not known to be lists
00:55:46 <julianleviston> I just which map was renamed to lmap and fmap was renamed to map.
00:55:59 <julianleviston> but I guess I could do some of that renaming on my own :)
00:56:17 <johnw> I'd be fine with map vs. Data.List.map
00:56:19 <julianleviston> wish*
00:58:54 <lispy> julianleviston: just start using <$> everywhere and it won't matter :)
01:01:15 <julianleviston> lispy:  LOL sorry.
01:02:16 <mniip> julianleviston, lmap is occuppied by Bifunctor
01:02:21 <mniip> (Profunctor?)
01:02:32 <johnw> (the latter)
01:03:07 <julianleviston> not in prelude
01:03:09 <mniip> ah, Bifunctor uses first, last
01:03:16 <mniip> er
01:03:16 <julianleviston> but hey I don’t want to get into *that* discussion ;-)
01:03:16 <johnw> and bimap
01:03:18 <mniip> first, second
01:04:08 <mniip> okay so a monad algebra is a transoformation that is "inverse" to the monad's return?
01:04:56 <johnw> there can be many algebras for a mona
01:04:58 <johnw> d
01:05:03 <johnw> but there will be only one return
01:05:06 <lispy> g'night all
01:05:07 <mniip> yeah yeah
01:05:08 <johnw> (for a given instance)
01:06:03 <mniip> so for example ($ ()) is an algebra of the ((->) ()) monad
01:09:05 <gamegoblin> is newtype Foo = Foo (x,y,z) any more efficient than Data Foo = Foo x y z ? (I doubt it, just curious)
01:09:30 <johnw> I'm pretty sure they're the same
01:10:13 <johnw> you could check the GHC Core
01:12:17 <gamegoblin> last time I looked at GHC Core my eyes started bleeding and I had to be admitted to a hospital for three weeks
01:12:46 <johnw> sometimes bloody eyes are the price of progress
01:19:01 <poincare101> Hi. I have quick question about some parallel haskell facilities. I have the following code: http://pastie.org/10273774 This is giving a compiler error saying that "Variable" is not an instance of NFData
01:19:15 <poincare101> What exactly does NFData accomplish
01:19:38 <poincare101> and how should I implement rnf for the Variable type
01:22:33 <mniip> poincare101, rnf should ensure normal form of the data
01:22:48 <poincare101> mniip: the problem is I haven't the slightest idea what that means
01:22:51 <mniip> i.e evaluate all the fields (recursively if needed)
01:23:05 <mniip> poincare101, what's the definition of Variable
01:23:05 <poincare101> mniip: so if it is just a bunch of "[Double]" elements
01:23:35 <poincare101> http://pastie.org/10273780
01:24:25 <mniip> poincare101, see something like https://hackage.haskell.org/package/deepseq-1.1.0.0/docs/src/Control-DeepSeq.html#line-130
01:25:53 <poincare101> mniip: so I think nothing has to be evaluated so is it just an identity operation?
01:26:05 <mniip> no
01:26:10 <mniip> see the (a, b, c, d) instance
01:26:51 <mniip> you have to evaluate each of your fields: possible, valueIndex, dist
01:26:53 <poincare101> ah I can use seq to force evaluation
01:37:34 * hackagebot sjsp 0.1.0 - Simple JavaScript Profiler  http://hackage.haskell.org/package/sjsp-0.1.0 (itchyny)
01:52:36 * hackagebot sync-mht 0.2.0.0 - Fast incremental file transfer using Merke-Hash-Trees  http://hackage.haskell.org/package/sync-mht-0.2.0.0 (emink)
01:53:56 <joco42> when should one use cabal freeze? could one give a simple example?
01:57:06 <ttt_fff> is there a way to tell haskell: don't fucking worry about Control.Lens.makeLenses generating stuff taht is "defined but not used" ?
01:58:32 <johnw> disable the warning
01:58:49 <johnw> {-# OPTIONS_GHC -fno-warn-unused-binds #-}
01:59:02 <ttt_fff> well; I want it to warn me
01:59:07 <ttt_fff> but just not as a reulst of Control.Lens
01:59:21 <johnw> make your lenses in another module, where the warning is disabled
01:59:21 <ttt_fff> I like the warnig of unused bindings in general, just not the ones Control.Lens.makeLenses generates ... 
01:59:36 <ttt_fff> damn, that actually works
02:00:30 <ttt_fff> did you come up with that on the fly
02:00:35 <ttt_fff> or did you face this problem before?
02:00:40 <johnw> on the fly this time
02:00:40 <ttt_fff> i.e. why did I not think of it
02:00:43 <ttt_fff> well done
02:24:53 <poincare101> Hi. I am trying to work with NFData and I'm hitting some roadblocks. I have the following code: http://pastie.org/10273857 But, I'm getting a compiler error saying that `rnf' is not a (visible) method of class `NFData'
02:28:55 <mniip> poincare101, did you import Control.DeepSeq
02:29:32 <poincare101> mniip: nope, that solved the problem.
02:29:44 <shourya> Hi
02:52:39 * hackagebot emacs-keys 0.0.1.0 - library to parse emacs style keybinding into the modifiers and the chars  http://hackage.haskell.org/package/emacs-keys-0.0.1.0 (cocreature)
03:03:16 <latk> how do people tend to store sum-types in sql databases? Just use unique strings, define a table of the allowed types, something else? 
03:03:45 <hunteriam> Did you just see the slides on r/Haskell too latk?
03:04:10 <latk> Oh, nope. I'm just trying to work out how to set up the schema for something I'm working on!
03:04:39 <hunteriam> Also does anyone know where I could learn about professional web back ends, topics like connection pooling, and whatever else, rather than general programming?
03:04:58 <hunteriam> latk: check out persist, ill get a link for you if you want
03:05:15 <hunteriam> That is, if you're willing to use a library for database access
03:05:37 <latk> hunteriam: I'm actually just reading them. I've used persistent in the past, but currently am much in favour of opaleye.
03:06:11 <latk> However, I'm not sure of the best way to store sum types - I can think of a few ways, but don't know if there is some hidden problem with them.
03:06:15 <hunteriam> Just reading the slides you mean? Never heard of opaleye, why do you like it?
03:06:54 <latk> hunteriam: Querying in opaleye is a joy. 
03:07:00 <latk> Yep, just reading these slides.
03:07:22 <latk> I found persistent a bit awkward for putting things into normal form etc.
03:07:27 <hunteriam> Well couldn't you just store a sum type as though you were storing an enumeration? Am I misremembering sum types?
03:07:40 <hunteriam> Persistent does seem a little opaque to get started with to me anyways
03:08:08 <hunteriam> Although I'm sure you'd prefer something prettier?
03:08:44 <latk> I liked a lot about persistent, but I think for a larger project it seems nice to have more control over querying. 
03:08:54 <latk> There is esqueleto which extends persistent queries
03:09:08 <latk> I found opaleye to be much nicer in terms of this, though.
03:09:18 <latk> Although it requires much more boilerplate to set tables up.
03:09:38 <hunteriam> What do you need control over querying for? Performance?
03:10:08 <latk> I think sum types and enumerated types are the same as sum types btw, though I could be wrong.
03:11:23 <latk> Partly, but I found when you are storing more complicated stuff with relations across a few tables, it just got a bit awkward in persistent.
03:11:38 <latk> This could be my deficiency at using persistent, of course.
03:11:55 <hunteriam> Haven't used it myself so can't comment
03:12:04 <hunteriam> Yea I think they are essentially the same
03:12:10 <hunteriam> So couldn't you just store a number?
03:12:27 <hunteriam> And hook up particular numbers to particular types out of your sum type?
03:12:30 <latk> Well, this is one of the things I was thinking of doing. Just wanted to check what people tend to do!
03:13:17 <hunteriam> Ah, ok. What other options have you thought of?
03:14:00 <latk> That seemed like the best option tbh, but you could also just store a unique string or something.
03:14:18 <hunteriam> Strings are poorer performance afaik
03:14:34 <latk> Yeah. I guess changing the names might be more of a pain etc as well.
03:14:37 <hunteriam> I think there's no elegant solution because you're using a db not written in Haskell
03:14:57 <hunteriam> The best answer would be to abstract out the linking of values to options in the enum
03:15:17 <hunteriam> Which I guess is what persistent does as well as all the querying stuff
03:15:27 <hunteriam> Well that's probably the best answer anyways
03:15:38 <latk> Yeah, I figured.
03:15:54 <hunteriam> I mean I'm just figuring too
03:16:20 <latk> I guess I can just have a  go. Hopefully it will become obvious soon if there is a flaw with this approach..
03:18:37 <hunteriam> Hm I can't imagine there being anything wrong with it. What sort of flaws are you expecting?
03:20:34 <latk> No clue, but then again I'
03:20:43 <latk> ve not really dealt with big db projects before
03:21:16 <hunteriam> Neither. I need a good excuse to make a large web app
03:21:44 <hassa> hi
03:21:45 <hassa> hi
03:21:45 <hassa> hi
03:21:47 <hassa> hi
03:21:47 <hassa> hi
03:21:48 <hassa> hi
03:22:08 <maerwald> hi
03:22:20 <Adeon> excessive greeting is not tolerated
03:22:39 <breadmonster> Indeed.
03:22:42 <maerwald> Adeon: maybe he tried to greet everyone here separately
03:23:25 <hunteriam> Greeting is to be restricted to the allowed single greeting per 7 hour period.
03:23:53 <hunteriam> All infractions will be treated as an assault on SPJ himself.
03:23:59 <maerwald> hunteriam: does that include a re-greeting?
03:24:20 <hunteriam> Re-greetings are not a legally defined notion.
03:44:39 <forgottenone> is there a function in standart library or prelude something does this: func l f = map fst $ dropWhile (\(x,y) -> f x y) (zip l $ tail l)
03:46:23 <merijn> forgottenone: fyi, your lambda is just uncurry
03:46:25 <merijn> :t uncurry
03:46:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
03:46:30 <maerwald> @let func l f = map fst $ dropWhile (\(x,y) -> f x y) (zip l $ tail l)
03:46:31 <lambdabot>  Defined.
03:46:45 <maerwald> > func [1,2,3] (>)
03:46:47 <lambdabot>  [1,2]
03:47:57 <forgottenone> merjin: you're right
03:49:51 <forgottenone> but what i wonder is there something like in standart library. more specifically drop until next element equal to previous
03:50:54 <ronh> merijn you mean curry
03:50:57 <ronh> :t curry
03:50:59 <lambdabot> ((a, b) -> c) -> a -> b -> c
03:51:42 <maerwald> @hoogle [b]  ->  (b -> b -> Bool)  ->  [b]
03:51:43 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
03:51:43 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:51:43 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:51:49 <maerwald> hm, doesn't look useful
03:52:01 <pacak> > concat . dropWhile ((== 1) . length) . group $ > [1,2,3,3,4]
03:52:03 <lambdabot>  <hint>:1:48: parse error on input ‘>’
03:52:09 <pacak> > concat . dropWhile ((== 1) . length) . group $ [1,2,3,3,4]
03:52:11 <lambdabot>  [3,3,4]
03:52:31 <maerwald> forgottenone: I don't think there is something, except golfing your version
03:52:33 <pacak> Not terribly efficient...
03:53:01 <forgottenone> maerwald: i see, thanks.
03:54:49 <ronh> no it is uncurry, nm
03:55:16 <Haskellfant> I always get curry and uncurry the wrong way around
03:55:30 <maerwald> Haskellfant: that's why I avoid them and just use explicit lambda ;)
03:55:58 <Haskellfant> hehe
03:56:45 <maerwald> 2 flips, 1 curry and 1 uncurry in one line and you are screwed
03:57:20 <maerwald> back to the perl roots of obfuscation
04:10:25 <isovector> greetings; i'm trying to install helm and have been fighting with cabal/stack for a few hours now
04:11:20 <isovector> cabal can't seem to figure out a dependency tree, which is weird because i managed to do it in the past
04:12:42 * hackagebot DCFL 0.1.2.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.2.0 (dpandya)
04:14:54 <Haskellfant> isovector: what error are you getting?
04:17:35 <isovector> most recently, next goal: sdl2 (dependency of helm-0.7.1) rejecting: sdl2-1.3.1, 1.3.0 (conflict: base==4.6.0.1/installed-8aa..., sdl2 => base>=4.7 && <5) rejecting: sdl2-1.2.0, 1.1.3, 1.1.2, 1.1.1, 1.1.0, 1.0.2, 1.0.1, 1.0.0 (conflict: helm => sdl2>=1.3 && <1.4) Dependency tree exhaustively searched.
04:18:35 <Haskellfant> base is tied to your ghc version
04:19:56 <hunteriam> What should I do to make myself a good candidate for employment in Haskell? Seems like a phd is required given how few jobs there are and how many haskellers want them
04:20:10 <isovector> Haskellfant: cool! ghc is 7.6.3 right now, but stack installed something more recent; any suggestions on how to proceed?
04:20:33 <Haskellfant> not quite sure where the sdl2>=1.3 && <1.4 is coming from. on hackage it require sonly >= 1.1 && < 1.3
04:20:48 <hunteriam> Sounds like an old version of sdl2
04:20:54 <hunteriam> That's what I would assume anyways
04:21:00 <isovector> oh yeah, i just grabbed a pull request from GH, was seeing if i could get *that* to build
04:22:26 <Haskellfant> anyway, it looks like you're not using the version that stack has provided for you. afaik the oldest version that stack downloads is 7.8.4 and that provides base 4.7
04:22:43 * hackagebot DCFL 0.1.3.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.3.0 (dpandya)
04:23:13 <isovector> made an explicit install plan for stack with ackage version; got it as far as trying to install glib-0.12.*, which would complain with
04:23:15 <isovector> SetupWrapper.hs:94:45:         Ambiguous occurrence ‘moreRecentFile’
04:23:18 <maerwald> hunteriam: yeah, the situation is unfortunate. Industry has still not really adopted haskell with a few exception, but those are usually very specialized fields and because of that they usually require a very high skillset.
04:23:19 <Haskellfant> which command are you trying to run and what's the content of your stack.yaml?
04:23:54 <isovector> honestly i've been fighting with it for so long that i just keep nuking things and starting over.
04:24:05 <isovector> i'll start again and get back to you
04:24:07 <hunteriam> Maerward: I love programming, but I'm not sure any particular aspect of it has phd levels of interest to me. What do I do?
04:24:27 <hunteriam> The idea of having the skill set of a phd sounds phenomenal though, from what I've heard about a PhDs skill set
04:25:01 <maerwald> hunteriam: I think an opensource footprint is the best way to catch attention. I can't think of anything else (except you are phd or write interesting papers of whatnot)
04:25:30 <hunteriam> No I mean, how do you discover a topic that motivates you to get a phd!
04:27:46 <maerwald> I have no answer to that
04:29:34 <isovector> Haskellfant: cabal deps:   build-depends:       base >=4.6 && <4.7, helm >= 0.7.1
04:29:52 <isovector> ghc 7.6.3, $ cabal install
04:29:57 <Taneb> hunteriam, by reading about as wide as you can, then reading as deep as you can
04:30:03 <isovector> Gtk2HsSetup.hs:161:28:     Couldn't match expected type `IO                                     (Distribution.InstalledPackageInfo.InstalledPackageInfo_                                        ModuleName)'                 with actual type `FilePath                                   -> PackageDB                                   -> IO Distribution.InstalledPackageInfo.InstalledPackageInfo'
04:30:39 <isovector> i got around this somehow before, i think with explicit versioning on which packages i picked up
04:35:35 <hunteriam> Taneb: I'm working on the assumption reading deep is only relevant  with the stuff you're interested in, unless you think reading deep will unearth new and interesting things that weren't visible from the surface
04:37:30 <Haskellfant> I highly doubt that most subjects can be judged as interesting or not (for oneself) without reading deep about them
04:37:49 <Haskellfant> isovector: try that stack.yaml file http://lpaste.net/135911
04:39:02 <Taneb> hunteriam, read wide to find something you might be interested in, then read deep in that topic to find out what in particular
04:45:59 <isovector> Haskellfant: that did the trick. you're a genius! thank you so much
04:46:09 <Haskellfant> yw
04:46:28 <isovector> Haskellfant: do you mind if I submit a PR to helm with this stack.yaml so nobody else needs to fight with it for 3 hours?
04:47:39 <Haskellfant> isovector: feel free to do whatever you want with it :)
04:48:03 <isovector> cheers! :D
05:27:03 <poincare101> Hi. I'm having some issues w/ cabal + ghc-pkg. I just unregistered a package called "deepseq" and I installed it again with cabal. But it doesn't seem like it has registered with ghc-pkg. Is there a way to solve this?
05:27:45 <meditans> I'm working on a library which involves source code processing; Is there a way to obtain, starting from the hackage package, "clean" source files, in the sense that they contain no cpp preprocessing and no #if_def, no cabal choice over the package installed (ie. actual haskell files that I can compile?)
05:36:03 <MarcelineVQ> there's a way to regen the ghc-pkg db, I can't recall it, there's two ways I think, one refreshes but the other rebuilds. if you haven't tried those google them
05:39:16 <phale> I just want to know if im making the right choice.
05:40:02 <phale> I've heard good and bad things about Haskell and I'm not sure if I want to switch.
05:40:20 <MarcelineVQ> you don't need to 'switch' use everything at once :>
05:43:57 <phale> my friend will laugh at me
05:45:46 <Haskellfant> you are free to laugh at your friend :)
05:45:59 <phale> really?
05:45:59 <quchen> phale: You're not making a wrong choice. Whether it's the right choice depends on a lot of factors that we cannot judge.
05:46:11 <phale> he programs in C and so do I
05:47:48 <usr> As a C programmer, Haskell is the right choice
05:47:58 <usr> for the next language to specialize in
05:48:15 <phale> oh okay
05:48:30 <phale> I just want a language that does things quickly and nicely
05:48:51 <phale> something that I can write around ~5 lines in and it does exactly what I want
05:48:51 <maerwald> phale: well, haskell still cannot beat C code performance (and writing performant haskell code can be REALLY tough... this is where it stops being a proper "high-level" language). But with C you get tons and tons of more bugs. In haskell there is no such thing as "debug driven development".
05:49:10 <phale> you mean undefined behaviour?
05:49:25 <maerwald> not only that
05:50:01 <maerwald> haskell has a GC
05:50:16 <maerwald> although memory leaks are possible (sometimes due to laziness), they are still rare
05:50:53 <maerwald> and the type system is so strict that it disallows writing some kind of bugs... ofc it cannot prohibit logical bugs
05:50:58 <phale> "From: zyxwvuts <daniel@inventati.org> HAHAHAHHAHAHAHAHAHAHAHAHAHAHAHAHAHA"
05:51:06 <phale> oh well
05:51:23 <maerwald> phale: like implicit type casting or other nasty things
05:51:41 <maerwald> you can't give a char when it expects an int, or even a double
05:52:12 <maerwald> so a lot of errors are now compile-time errors, rather than undefined runtime behavior
05:52:43 <phale> wait so, haskell doesn't have any errors?
05:52:49 <maerwald> sure 
05:52:58 <phale> what if I write something wrong
05:53:26 <maerwald> it may also break during runtime (e.g. if your pattern matching is incomplete), but that is way more easy to detect and the compiler can even warn you about it
05:54:32 <maerwald> phale: what do you mean with "wrong"?
05:54:38 <phale> for instance
05:54:50 <phale> i write "Teur" when I mean "True"
05:54:55 <maerwald> type error
05:55:04 <maerwald> or do you mean a String?
05:55:09 <phale> type error
05:55:17 <maerwald> if you mean True as a Bool
05:55:25 <maerwald> then Teur will obv trigger a type error
05:56:05 <maerwald> :t True
05:56:06 <lambdabot> Bool
05:56:08 <maerwald> :t Teur
05:56:10 <lambdabot> Not in scope: data constructor ‘Teur’
05:56:23 <quchen> C would do the same thing if you wrote "teur" somewhere.
05:56:33 <phale> well ok
05:56:34 <quchen> It's not a type error, it's a "this thing doesn't exist" error.
05:56:34 <maerwald> yeah, so I don't really get the example
05:56:36 <phale> thanks for the information guys
05:56:43 <phale> can you recommend me a book to read
05:56:46 <phale> preferably with exercises
05:56:58 <quchen> > (1 :: Int) + (2 :: Double) -- That's a type error.
05:56:59 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Double’
05:56:59 <lambdabot>      In the second argument of ‘(+)’, namely ‘(2 :: Double)’
05:56:59 <lambdabot>      In the expression: (1 :: Int) + (2 :: Double)
05:57:05 <maerwald> phale: https://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
05:57:59 <maerwald> quchen: it's a type error if a Bool is expected
05:58:49 <MarcelineVQ> > "Butt" == False
05:58:51 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
05:58:51 <lambdabot>      In the second argument of ‘(==)’, namely ‘False’
05:58:51 <lambdabot>      In the expression: "Butt" == False
05:59:47 <quchen> If a Bool is expected and you give it a `Teur` value then it's still not a type error, unless you have a type with a `Teur` constructor.
06:29:15 <ttt_fff> is there a way, in a *.hs file, to get LINE NUMBER / FILE NAME / MODULE NAME ?
06:29:24 <ttt_fff> i.e. things like __FILE__ and __LINE__ from C land
06:29:42 <quchen> ttt_fff: You can use the C preprocessor in GHC
06:29:59 <ttt_fff> haha funny
06:30:06 <quchen> {-# LANGUAGE CPP #-} at the top of the file and you're good to go
06:30:11 <ttt_fff> what?
06:30:22 <ttt_fff> https://downloads.haskell.org/~ghc/7.2.2/docs/html/users_guide/pragmas.html
06:30:43 <ttt_fff> okay
06:30:45 <ttt_fff> where is this documented?
06:30:48 <ttt_fff> the CPP pragma in particular?
06:31:17 <quchen> ttt_fff: Run this http://lpaste.net/135914
06:31:30 <quchen> It's documented … somewhere.
06:31:42 <quchen> Your manual entry is for 7.2, which is very old. But it should still have a section on CPP.
06:31:51 <ttt_fff> https://mail.haskell.org/pipermail/haskell-cafe/2009-July/064165.html wtf
06:31:54 <ttt_fff> I don't believe this
06:32:17 <ttt_fff> http://projects.haskell.org/cpphs/
06:32:21 <ttt_fff> thia has full docs, I thnk
06:35:20 <statusfailed> Can writing to a Chan cause an exception? 
06:37:48 <quchen> statusfailed: Chans cannot be full, if that's what you're asking.
06:37:54 <quchen> Unless your RAM is full.
06:38:29 <statusfailed> quchen: I am asking: I have a worker thread periodically running a task, and writing results to a Chan. I expect the task to sometimes fail, should I ever expect the writeChan to fail?
06:39:00 <statusfailed> "only when out of RAM" answers my question I think :-)
06:39:07 <statusfailed> thanks
06:39:13 <quchen> statusfailed: writeChan is a very small function, consisting only of newEmptyMVar, takeMVar, putMVar.
06:39:27 <quchen> None of them throws under normal conditions.
06:39:50 <statusfailed> quchen: OK, thanks !
06:40:33 <quchen> Asynchronous exceptions are something you cannot expect in general, but that's a whole other topic.
06:41:05 <statusfailed> quchen: Yeah, I'm using withAsync to wrap the "worker" for that
06:42:09 <quchen> withAsync is a pretty good choice for doing that, because it re-throws any exceptions not caught by its worker.
06:44:34 <BPro97> ciao
06:44:41 <BPro97> !list
06:44:41 <monochrom> BPro97: http://hackage.haskell.org/packages/
06:45:14 <phale> is "Learn you a Haskell" good
06:46:34 <quchen> I think it's excellent.
06:46:49 <statusfailed> It was a bit out of date when I read it (~3 years ago)
06:46:50 <mniip> needs more excercises
06:46:54 <statusfailed> dunno if its been updated?
06:47:07 <quchen> statusfailed: I don't remember anything being outdated 3 years ago
06:47:08 <MarcelineVQ> it lacks exercises but is otherwise good
06:47:15 <statusfailed> quchen: specifically the state monad bit
06:47:16 <MarcelineVQ> iirc
06:47:32 <statusfailed> State was changed to be an alias of StateT Identity which confused the heck out of me for a long time :-)
06:47:33 <quchen> statusfailed: Doesn't it implement its own State?
06:47:51 <statusfailed> quchen: Possibly- I just remember being tripped up because I tried to use the standard library and it didn't work
06:48:06 <statusfailed> but I did think it was very good
06:48:56 <quchen> Now with 7.10 we have Applicative => Monad, which LYAH mentions as "is conceptually true, but not implemented like this". The folding functions in Prelude were also recently generalized.
06:49:11 <quchen> So it's a bit outdated as of 7.10, but not by muhc.
06:49:11 <MarcelineVQ> phale: someone linked you https://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html earlier which is also a good start point, it has homework exercises and such
06:49:30 <phale> okay
06:52:47 <phale> var :: type
06:52:53 <phale> does this need to be in every declaration
06:54:14 <geekosaur> no, but it can save you from surprises due to the monomorphism restriction and/or defaulting
06:55:20 <phale> ok
07:01:15 <meditans> does anyone know when the zurihack 2015 videos will be put online?
07:11:05 <oytun> hello everybody! I just started learning Haskell (and already amaaaaaaaaaaazed). I have a quick question:
07:11:11 <oytun> head' (x:_) = x
07:11:26 <oytun> in this definition, why did we specify the left side with regular paranthesis?
07:12:22 <oytun> oh, I think it's because it's a pattern, which is kind of a "type" matching
07:12:45 <oytun> and we specify the types or typeclasses with (), so...correct?
07:13:42 <geekosaur> no
07:13:45 <mauke> we need parens here because precedence
07:13:55 <mauke> the parens themselves have no special meaning
07:13:56 <geekosaur> [x,y,z] is syntactic sugar for (x:y:z:[])
07:14:14 <geekosaur> which is the actual constructor, and what you must use to deconstruct a list unless you want a fixed size
07:14:15 <oytun> yes, but why do we need () here
07:14:17 <mauke> a b : c parses as (a b) : c
07:14:27 <mauke> because function application binds tighter than operators
07:14:29 <geekosaur> that is [x,y] in a pattern is exacty a 2-element list
07:14:41 <geekosaur> (x:y) is the head of a list and its tail which may be of arbitrary length
07:14:48 <oytun> oh okay
07:15:05 <oytun> so it's actually a tuple?
07:15:09 <geekosaur> no
07:15:12 <mauke> kind of
07:15:13 <oytun> :(
07:15:13 <geekosaur> : is not ,
07:15:24 <mauke> if by "tuple" you mean "product type"
07:15:33 <geekosaur> it is a cons cell like in Lisp, except Lisp doesn't require types to be the same
07:15:35 <oytun> normally, I would try to write it like this:     head' x:_ = x
07:15:46 <mauke> oytun: that would parse as (head' x) : _ = x
07:15:50 <geekosaur> right, that's just so patterns and expressions use the same precedence rules
07:15:53 <oytun> ohhhhhh
07:16:02 <oytun> right, missed that
07:16:03 <mauke> which would probably give you an error because application isn't allowed in patterns
07:16:05 <geekosaur> instead of having to remember a different set of rules for patterns
07:16:12 <oytun> so () here is solely for grouping?
07:16:17 <geekosaur> yes
07:16:18 <mauke> yes
07:16:20 <oytun> OH FINALLY
07:16:29 <oytun> I was making it more complicated than it is
07:16:41 <oytun> thank you!
07:16:47 <mauke> you're welcome :-)
07:17:06 <oytun> And this is soooooo joyful... I am amazed! I feel like I have been wasting my time for years
07:17:39 <mauke> it will only get worse. soon you'll be unable to stand any other programming language
07:18:06 <oytun> hehehe, hopefully. this is such a mental orgasm I'm having right now
07:18:19 <oytun> thank you again! won't keep you here.
07:29:48 <ij> Has someone written sets and set theory functions in haskell? 
07:34:41 <stulli> makeReq :: MonadWidget t m => XhrRequest -> Event t () -> m (Event t (XhrResponse))
07:34:44 <stulli> makeReq defaultReq event = 
07:36:05 <Haskellfant> ij: I haven't, but there was a recent talk at the nyc haskell user group about that exact topic (which I haven't watched :)) https://www.youtube.com/watch?v=beaBqjLhBJU
07:37:11 <maerwald> edwardk probably knows I guess
08:23:43 <tuwx> hello
08:27:45 <benzrf> monadwidget
08:28:15 <tuwx> when I run cabal install cabal-install, I get this error : http://lpaste.net/135919 Does anyone know how i can solve it ?
08:28:56 <bennofs> tuwx: what system is this? (windows, linux [what distribution], ...)
08:29:22 <tuwx> os x 10.10
08:30:32 <bennofs> tuwx: hmm, can you paste the output of ghc-pkg check?
08:30:52 <bennofs> tuwx: also, ghc-pkg list parsec
08:37:04 <tuwx> http://lpaste.net/135920
08:37:55 <tuwx> this is the first time I try to use cabal :)
08:39:06 <bennofs> tuwx: hmm… ghc-pkg list -v parsec    ?
08:40:54 <tuwx> http://lpaste.net/135920
08:42:49 <bennofs> tuwx: ok, does ghci -package parsec work? If not, what does ghci -v2 -package parsec print?
08:44:11 <tuwx> ghci -package parsec works and loads parsec
08:46:53 <portnov> @pl \x y -> ask >>= \f -> f x y
08:46:53 <lambdabot> ((ask >>=) .) . flip . flip id
08:47:19 <portnov> "oh flip flip".
08:54:01 <Welkin> portnov: the point-free version is much harder to read
08:54:58 <portnov> yes, as usual :)
09:03:06 <c_wraith> portnov: ask >>= ($ x) . ($ y)
09:03:12 <maerwald> Welkin: but you are cool and fancy if you do everything point-free
09:04:13 <c_wraith> You can often write cleaner code than the point-free plugin generates...  with or without points. :)
09:05:50 <bennofs> tuwx: hmm, no idea then, sorry. not a mac user myself
09:05:58 <c_wraith> Of course, that still requires some of the points.
09:07:59 <tuwx> bennofs: thank you anyway !
09:14:35 <cow_2001> how do i stick a bunch of state into the Courses monad?
09:15:01 <c_wraith> I recommend getting a funnel and maybe a cartoon mallet.
09:15:10 <c_wraith> More usefully, where is Courses defined?
09:15:20 <meditans> hi, using `indentation` option for haskell-mode, is it possible to reset the indentation after a newline?
09:15:34 <cow_2001> https://hackage.haskell.org/package/ncurses-0.2.11
09:16:04 <cow_2001> stick IO in it as well
09:16:11 <c_wraith> cow_2001: it's an instance of MonadIO.  You can get as much state as you want in it.
09:16:20 <cow_2001> woah!
09:16:21 <c_wraith> cow_2001: (don't ignore instance lists)
09:16:35 <cow_2001> huh
09:16:37 <cow_2001> but how?
09:16:57 <cow_2001> what's a MonadIO, anyways?
09:17:07 <c_wraith> cow_2001: click on "MonadIO" in the instance list.
09:17:09 <cow_2001> liftIO . stateStuff
09:17:18 * cow_2001 reads
09:17:29 <cow_2001> thanks c_wraith!
09:17:37 <monochrom> you can use IORef
09:19:56 <bezirg> hello, I am using System.Process to create a new unix process. In the newly created process, I want to pass an environment variable. The API says the value of the env-variable must be a String. I use "show $ Data.Binary.encode value" for the env-variable, but there are decoding issues by the created process.
09:20:20 <bezirg> Does anybody know how can I serialize and store a value in an environment variable so it can be correctly decoded? (Data.Binary.decode)
09:21:05 <cow_2001> thanks monochrom!
09:24:49 <geekosaur> bezirg, you'll need to do something to convert it to printable characters and back, say encoding as base64 (but replace = by something else for safety)
09:25:57 <bezirg> geekosaur: thx! i think you mean the base64-string package. I am going to try it out!
09:36:31 <cow_2001> zomg it's working
09:37:41 <ttt_fff> let Foo = a Monad, BarT = a Monad transfomer. Then, how do I go from "Foo a" to "BarT Foo a" ?
09:38:26 <Gurkenglas> http://pastebin.com/QbFGpmsn <- How do I get these curl libraries? I'm on windows.
09:42:42 <supki> @hoogle Foo a -> BarT Foo a
09:42:43 <lambdabot> Warning: Unknown type Foo
09:42:43 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
09:42:43 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
09:44:16 <c_wraith> Huh.  Playing with NCurses a bit...  Update appears to be yet another monad that exists merely to abuse do notation on something that's morally a monoid.
09:44:54 <Taneb> c_wraith, that happens a lot :(
09:45:01 <Taneb> Too much, even
09:45:45 <c_wraith> Yep.  Everything that produces (rather than consumes) an Update value produces an Update ()
09:45:54 <c_wraith> Definitely a monoid abusing do notation
09:46:18 <Taneb> Huh, it's implemented as a ReaderT
09:47:11 <c_wraith> I think that's just to simplify the implementation of updateWindow
09:47:35 <c_wraith> It makes updateWindow more or less flip runReaderT
09:48:04 <cow_2001> O_O
09:48:21 <cow_2001> what does it all mean?
09:48:52 <c_wraith> cow_2001: it means that the interface is a bit richer than it gets any value out of being.  That's all.
09:49:08 <c_wraith> unless you count the value of being able to abuse do notation.
09:49:38 <cow_2001> why is it considered abuse?
09:50:05 <c_wraith> http://lpaste.net/135924
09:50:58 <c_wraith> cow_2001: because it's logically representing a list of instructions without return values.
09:51:51 <c_wraith> cow_2001: do notation includes lots of ways to handle return values, which don't really make sense in this case..  There's no information to return.
09:52:03 <cow_2001> yeah
09:52:09 <c_wraith> cow_2001: but the data type was shoehorned into the Monad class anyway, just so you can use do notation like that.
09:52:09 <cow_2001> i see now
09:52:40 <cow_2001> what is the do notation equivalent of monoids?
09:53:11 <c_wraith> All monads are monoids, in several senses.
09:53:16 <geekosaur> how long before ApplicativeDo is followed by MonoidDo? :p
09:53:18 <cow_2001> oh
09:53:20 <cow_2001> uhm
09:55:25 <c_wraith> cow_2001: the monad laws imply that the pair of (return ()) and (>>) function the same as mempty and mappend for monoids
09:55:48 <maerwald> c_wraith: but that doesn't answer the question if there is a do-notation equivalent for monoids
09:55:50 <c_wraith> cow_2001: though there's some vague hand-waving there due to the classes having different kinds, and such.
09:56:29 <cow_2001> so monoids have (return ()) and (>>) but no (>>=)
09:56:59 <c_wraith> cow_2001: well, it's not quite that straight-forward.  But that's the right idea.
09:57:58 <monochrom> when we finally have MonoidDo, the Scheme people will laugh at us.
09:58:00 <c_wraith> cow_2001: It's much easier to go the other direction.  (return ()) and (>>) provide a monoidal (of sorts) interface.  (>>=) adds things that mean it's no longer monoidal in the same way.
09:58:14 <monochrom> "they finally re-invent (+ 3 1 4 1 5 9 2 60"
09:58:20 <monochrom> s/0/)/
09:58:38 <c_wraith> monochrom: except we renamed + to getSum
10:00:13 <c_wraith> It *would* be nice to have a cleaner syntax for repeated mappends than mconcat [foo, bar, baz]
10:01:30 <cow_2001> what's the cleanest way to use monoids, other than pretending they're also monads and using a do notation?
10:02:30 <bennofs> cow_2001: mconcat?
10:02:40 <bennofs> > mconcat [a, b, c, d]
10:02:43 <lambdabot>  mconcat [a,b,c,d]
10:02:54 <bennofs> oops
10:05:47 <c_wraith> I didn't realize Expr had a monoid instance
10:06:01 <cow_2001> so i wouldn't be able to use mconcat with Update?
10:06:13 <c_wraith> cow_2001: no, Update isn't an instance of Monoid
10:06:35 <cow_2001> could i submit a patch?
10:06:44 <c_wraith> cow_2001: types can't be instances of Monoid and Monad - they have different kinds
10:07:00 <cow_2001> oh
10:07:01 <c_wraith> cow_2001: that's why I was careful to say it was "morally" a monoid
10:07:02 <cow_2001> ding
10:08:51 <phale> zyxwvuts said that im stupid for switching to haskell
10:09:02 <phale> i didnt switch, though
10:09:23 <cow_2001> could you show me that a type that is an instance of Monoid has a different kind than a type that is an instance of Monad?
10:09:34 <phale> sorry I cant
10:09:38 <phale> I dont know haskell that well
10:09:50 <c_wraith> cow_2001: a simple example is lists
10:10:05 <c_wraith> cow_2001: [a] is an instance of Monoid.  [] is an instance of Monad
10:10:46 <c_wraith> cow_2001: the difference is the type variable appearing there
10:10:48 <cow_2001> ([] a) versus ([])
10:11:07 <cow_2001> so the first is * -> *?
10:11:08 <phale> Oh cool!
10:11:09 <cow_2001> or not?
10:11:35 <c_wraith> cow_2001: [a] :: *, [] :: * -> *
10:12:00 <cow_2001> :k [1]
10:12:02 <lambdabot>     Expected kind ‘*’, but ‘1’ has kind ‘GHC.TypeLits.Nat’
10:12:02 <lambdabot>     In a type in a GHCi command: [1]
10:12:08 <cow_2001> :k [a]
10:12:10 <lambdabot> Not in scope: type variable ‘a’
10:12:13 <cow_2001> err
10:12:18 <cow_2001> :k []
10:12:20 <lambdabot> * -> *
10:12:22 <c_wraith> :k [Int]
10:12:25 <lambdabot> *
10:12:27 <cow_2001> ah
10:12:32 <maerwald> :k Monoid
10:12:34 <lambdabot> * -> Constraint
10:12:36 <cow_2001> O_O
10:12:37 <maerwald> :k Monad
10:12:39 <lambdabot> (* -> *) -> Constraint
10:13:11 <cow_2001> perplexing
10:15:20 <cow_2001> AH!
10:15:31 <cow_2001> [] is the box
10:15:41 <cow_2001> List, not List Int
10:16:49 <maerwald> it's similar with Maybe
10:16:53 <maerwald> :k Maybe
10:16:53 <cow_2001> what is the kind of the type [a]?
10:16:55 <lambdabot> * -> *
10:16:57 <maerwald> :k Maybe Int
10:16:59 <lambdabot> *
10:17:07 <cow_2001> it's *, right?
10:17:13 <cow_2001> or.. mu?
10:34:48 <ReinH> :k forall a. [a]
10:34:50 <lambdabot> *
10:42:23 <Haskellfant> :k '[1]
10:42:25 <lambdabot> [GHC.TypeLits.Nat]
10:49:18 <zutobg> hey guys, I'm here cause I want to learn haskell and I find learnyouahaskell book, but I don't have anytime for the next 2 months, can you suggest me some technique for me to only give haskell 15min per day for the next 2 months and is this good to do or to go ahaead and do my abs workout instead of this :)
10:53:14 <cow_2001> okay, so there's a Monoid [a] instance and a Monad [] instance
10:55:28 <Welkin> @where learnhaskell
10:55:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:55:31 <Welkin> zutobg: there
10:57:07 <zutobg> thanks
10:57:39 <maerwald> zutobg: 15min is barely enough to get into context, IMO
10:57:56 <maerwald> at least when you are new to FP
10:58:51 <Welkin> 15 minutes per day for 60 days is only 15 hours
10:59:01 <Welkin> that is equivalent to one weekend of studying
10:59:14 <zutobg> I have some pythons and uni stuff to help me get through FP, so thank you, I just wanna get the general idea behind haskell what kinf of problems it solved and what is used for, but to rly realize it with my own mind flow
10:59:19 <Welkin> you cannot go from zero to writing useful applications in any language in a weekend
11:00:25 <maerwald> zutobg: that's still not enough, I think you will get stuck very soon, because a lot of things in haskell are not obvious and can be hard to understand for the first time
11:00:44 <Welkin> previous programming experience is mostly useless for haskell
11:00:51 <zutobg> good, at least I will try :)
11:00:53 <maerwald> so it may take a few hours to understand a seemingly simple concept for the first time
11:00:56 <Welkin> it's not that haskell is difficult (it is not)
11:01:50 <maerwald> Welkin: it is more difficult to learn than a lot of languages, because of the abstract concepts
11:03:01 <Welkin> maerwald: that depends on if you are coming from a background in another language already
11:03:09 <Welkin> if you have no previous experience, it is easier
11:03:09 <maerwald> Welkin: I don't think so
11:03:20 <Welkin> or if you can ignore what you know
11:03:36 <maerwald> Welkin: well yes, it can be easier if you have no previous experience, but it's still more difficult than other languages even without any experience whatsoever
11:08:49 <maerwald> Welkin: I see it this way: if the language doesn't provide a lot of abstraction technology, then learning it is often easier, but writing complex stuff is harder. If there is technology for abstraction, then learning will be harder, but writing complex stuff is easier.
11:09:10 <deyn> Hey, I'm also new to haskell. Is http://learnyouahaskell.com a good start?
11:11:56 <Welkin> @where learnhaskell
11:11:56 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:11:58 <Welkin> deyn: there
11:18:02 * hackagebot snaplet-purescript 0.3.0.0 - Automatic (re)compilation of purescript projects  http://hackage.haskell.org/package/snaplet-purescript-0.3.0.0 (AlfredoDiNapoli)
11:25:54 <absence> is there a monoid instance for IO in some lib?
11:27:21 <sccrstud92_> there isnt one in base?
11:27:56 <sccrstud92_> there should be an instance for Monoid a, Applicative f => Monoid (f a)
11:31:33 <indiagreen> sccrstud92_: see Edward's response here: http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/24835 (in particular, that instance would contradict the already existing instance for Maybe)
11:33:24 <DNoved1> Is there a standard function that checks if any elements of one list appear in another? I'm using (not (null (a `intersect b))) at the moment, but it's a bit heavy on the parenthesis.
11:35:37 <indiagreen> DNoved1: you can use “any (`elem` b) a”
11:36:15 <portnov> DNoved1: not $ null $ a `intersect` b
11:36:17 <Geraldus_> hi folks!
11:36:18 <portnov> et voila
11:36:25 <portnov> no parenthesis at all :)
11:37:19 <DNoved1> I'm not terribly much a fan of $, except to allow application to a lambda.
11:37:34 <DNoved1> However, any sounds like it'll work nicely, thanks!
11:37:39 <indiagreen> DNoved1: that version would work in O(n²), but so does intersect (and if you look at the source, it's written in the same way)
11:38:03 <Geraldus_> In the past there was no `toStrict` function in Data.ByteString.Lazy module (for example in version 0.9.2.0).  What should be used instead of it?  
11:38:20 <DNoved1> Ya, I'm not terribly concerned about that, this is for pretty printing tuples, so the lengths shouldn't be too long.
11:39:35 <Geraldus_> I've submitted a pull request to haskell-src-exts, and it have configure Travis build for GHC version 7.4.2, it uses old bytestring package, and some tests are failing because missed toStrict function
11:39:55 <Geraldus_> I want to try fix this issue
11:52:29 <creichert> Geraldus_: initially, I would try something like toStrict = BS.concat . BSL.toChunks
11:53:12 <creichert> That is the naive and simple version. There was a discussion on haskell-libraries about at one point, looking
11:53:14 <Geraldus_> creichert: hi, yeah, I've already figured that out, now I try to find the place where is that `toStrict` used
11:53:24 <creichert> ah
11:53:39 <Geraldus_> hope, some CPP will do the trick
11:54:14 <Geraldus_> creichert: anyway, thank you! (:
11:54:29 <creichert> no problem, good luck
11:55:41 <creichert> Geraldus_: quick question, is there a function built into haskell-mode to simply send a string to my current haskell-process? I just don't want to keep switching to the repl just to type a function. I found a few helper functions but nothing that was exported
11:56:44 <Geraldus_> creichert: hmm.. there was some function to send request string and print results back some how, let me see…
11:59:25 <Geraldus_> creichert: https://github.com/haskell/haskell-mode/blob/eaa3f371a61e93a38ce3609bbd05a9af1281bdca/haskell-interactive-mode.el#L1097
11:59:57 <creichert> Geraldus_: perfect, thanks a lot
12:00:10 <Geraldus_> but it is not interactive, and you can use it running M-: (haskell-process-show-repl-response <whatever>)
12:00:33 <Geraldus_> glad to be helpful (: 
12:01:09 <Geraldus_> btw, my the issue with toStrict comes from tasty-golden package
12:01:28 <Geraldus_> so CPP will not do the trick :(
12:07:52 <Zemyla> I know Either doesn't commute with Writer and State, but is there a canonical order for them?
12:08:03 * hackagebot yesod-sass 0.1.0.0 - A simple quasiquoter to include sass code in yesod  http://hackage.haskell.org/package/yesod-sass-0.1.0.0 (fgaray)
12:08:18 <Zemyla> Like, would you have s -> (Either e a, s) or s -> Either e (a, s)?
12:09:43 <Gurkenglas> Zemyla, give an example of a citizen of the left one where the Either is a Left
12:11:07 <Zemyla> throwError e = \s -> (Left e, s)
12:12:10 <Zemyla> The left is ExceptT e (State s), and the right is StateT s (Either e).
12:18:44 <hmrm> Fairly newbie question: what does a double colon in a data declaration do? I'm looking at https://github.com/haskell-servant/servant/blob/master/servant/src/Servant/API/Sub.hs and trying to figure out how it works.
12:19:47 <Zemyla> hmrm: How familiar are you with the concept of kinds?
12:19:52 <hmrm> Fairly
12:20:16 <hmrm> I'm new to Haskell, I've been doing functional programming in Scala before
12:20:17 <Zemyla> Well, it's basically just saying that the kind of path can be anything.
12:20:22 <hmrm> ah, ok
12:20:42 <mauke> well, it's a type annotation but I have no idea what it's doing there
12:20:49 <Zemyla> It's using the PolyKinds extension.
12:21:04 <shachaf> mauke: It's a kind annotation.
12:21:13 <hmrm> makes sense. So, would (path :: *) mean e.g. that it has to have kind *?
12:21:14 <shachaf> I'm not sure there's any point to it, though.
12:21:43 <mauke> oh, does it mean all kinds are allowed (as opposed to just *)?
12:21:48 <Zemyla> Yes, it does.
12:22:00 <shachaf> But that's what would get inferred with PolyKinds anyway.
12:22:12 <Zemyla> Well, sometimes it's made explicit.
12:22:33 <shachaf> In particular, a is also polykinded.
12:24:30 <shachaf> I'm a bit surprised KindSignatures isn't required for that file.
12:25:19 <alisia> Why doesn't a return function infront of a 'case ' does not work as expected. It works when I individually put the return function infront of every cases spearatly....
12:26:07 <shachaf> Most likely it doesn't work as expected because your expectations are wrong.
12:26:30 <shachaf> Without more information (code, error message, your expectations) it's hard to say more.
12:26:37 <mauke> "doesn't work" is not a problem description
12:26:44 <alisia> shachaf: one sec
12:26:48 <kadoban_> alisia: lpaste it? I would guess the precedence is wrong.
12:26:55 <geekosaur> you'd need to show actual code and actual full error (if any)
12:27:06 <marchelzo_> > return $ case 4 of { 4 -> 8 ; _ -> 3 }
12:27:08 <lambdabot>      No instance for (Show (m0 r0))
12:27:08 <lambdabot>        arising from a use of ‘show_M246020759619184185523278’
12:27:08 <lambdabot>      The type variables ‘m0’, ‘r0’ are ambiguous
12:29:08 <TheKing444> > repeat repeat
12:29:10 <lambdabot>      No instance for (Typeable a0)
12:29:10 <lambdabot>        arising from a use of ‘show_M269791127899923936823325’
12:29:10 <lambdabot>      In the expression:
12:29:29 <TheKing444> > repeat 'a'
12:29:31 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
12:30:00 <maerwald> :t repeat repeat
12:30:01 <lambdabot> [a -> [a]]
12:30:15 <alisia> shachaf: kadoban, this works http://lpaste.net/135930 . this doesn't http://lpaste.net/135931. I have included the error
12:31:04 <maerwald> > fmap (const 'a') $ repeat repeat
12:31:08 <lambdabot>  mueval-core: Time limit exceeded
12:31:13 <maerwald> weird, works on ghci
12:31:27 <athan> So, if I see a hackage lib, and an example haskell file that uses tabs instead of spaces, should I throw tomatoes or rocks?
12:31:56 <kadoban> athan: Both?
12:32:04 <TheKing444> Throw bottoms
12:32:10 <kadoban> hah
12:32:12 <athan> :D
12:32:25 <TheKing444> alisia Do you ahve context for that code?
12:32:27 <mauke> alisia: z <- y is the problem
12:32:45 <mauke> the second case is in a nested do block
12:33:01 <kadoban> alisia: Can line 4 in the erroring one be indented that far to the left? I'm not sure. I would think the error would be more obvious if it couldn't, but …
12:33:40 <AlecTaylor> hi
12:33:41 <shachaf> It's not an indentation issue, it's a trying to do something impossible issue.
12:33:44 <mauke> > do x <- [()]; return 42
12:33:47 <lambdabot>  [42]
12:33:51 <mauke> > return (do x <- [()]; 42)
12:33:54 <lambdabot>      No instance for (Show (m0 [b0]))
12:33:54 <lambdabot>        arising from a use of ‘show_M45446922005119401723439’
12:33:54 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
12:33:58 <mauke> you can't just pull returns out of a do block
12:34:50 <alisia> mauke: Why?
12:35:09 <mauke> @undo do x <- y; return z
12:35:09 <lambdabot> y >>= \ x -> return z
12:35:17 <mauke> <- is syntactic sugar for >>=
12:35:20 <mauke> :t (>>=)
12:35:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:35:23 <TheKing444> do x <- [(),()]; return 42
12:35:47 <alisia> mauke: yes  I know..but it does return a value..right?
12:35:54 <mauke> the type says: the result type of the function (the second argument) has to use the same monad as the first argument
12:36:01 <mauke> alisia: what?
12:36:09 <TheKing444> > do x <- [(),()]; return 42
12:36:11 <lambdabot>  [42,42]
12:36:28 <mauke> the issue is that it has to return a value of the right type
12:37:33 <alisia> mauke:  it is the value of correct type.
12:37:57 <mauke> no, it's not
12:38:36 <TheKing444> join $ return (do <- [()]; return 42)
12:38:44 <TheKing444> > join $ return (do <- [()]; return 42)
12:38:49 <lambdabot>  mueval-core: Time limit exceeded
12:38:55 <TheKing444> Huh, that's weird
12:38:56 <mniip> > do x <- [()]; _
12:38:58 <lambdabot>      Found hole ‘_’ with type: [b]
12:38:59 <lambdabot>      Where: ‘b’ is a rigid type variable bound by
12:38:59 <lambdabot>                 the inferred type of it :: [b] at Top level
12:39:12 <mniip> see you have to plug a list in place of _
12:39:13 <alisia> mauke:  it works when I put return at the other end of casees.
12:39:15 <TheKing444> Oh, lambdabot got typed holes, cool!
12:39:17 <shachaf> Please use lambdabot in /msg unless you have something useful to demonstrate.
12:39:28 <mauke> alisia: yes, because then it has the right type
12:39:31 <kadoban> Does anyone use ide-backend? I was going to investigate possibly making some kind of tie-in to vim, but … I don't seem to even be able to build it, so I'm kind of rethinking if that's actually going to be useful at this point.
12:39:34 <shachaf> An error message is almost never useful.
12:39:40 <shachaf> alisia: If you have "case x of { A -> return B; C -> return D }", you can turn it into "return $ case x of { A -> B; C -> D }". But that's not what you have.
12:39:48 <TheKing444> kadoban There is one already.
12:39:59 <kadoban> TheKing444: There is?
12:40:01 <mniip> shachaf, except when it's a hole
12:40:27 <shachaf> mniip: If it's more than one line of output, it probably doesn't belong in the channel. Use hpaste.org instead.
12:41:00 <shachaf> alisia: You have something like "case x of { A -> return B; C -> g (\x -> return (f x))"
12:41:05 <mniip> well it is only the first line that is important
12:41:06 <shachaf> You can't just move that return out.
12:41:15 <shachaf> Yes, but all three lines get printed to the channel.
12:41:40 <shachaf> Anyway this is more general than this particular line.
12:41:42 <theking> kadoban http://projects.haskell.org/haskellmode-vim/
12:41:49 <alisia> shachaf: mauke ..ok now I feel stuid. I don't know how I missed that!
12:42:04 <asjo> I would like to insert this PostGIS value in PostgreSQL using persistent: ST_GeomFromText('POINT(12.55385 55.49157 11582.400000000001)', 4326) - any hints on how? Using a Text field (un)fortunately does not cut it.
12:42:20 <mniip> shachaf, I don't see a problem because it was related to the topic of the conversation
12:43:12 <kadoban> theking: That's using ide-backend? I thought that was some old thing that I tried to use quite a while ago which seemed broken.
12:43:19 <mauke> mniip: imagine I wrote two lines of crap after everything I said
12:43:35 <mauke> I like turtles
12:43:37 <mauke> ayy lmao
12:44:30 <creichert> asjo: try this https://hackage.haskell.org/package/persistent-2.2/docs/Database-Persist-Types.html#v:PersistDbSpecific
12:44:58 <mniip> mauke, I approve :)
12:45:02 <asjo> creichert: Thanks, I will - I am a newbie, so I was looking for an example of usage :-)
12:46:12 <kadoban> theking: I'm talking about https://www.fpcomplete.com/blog/2015/03/announce-ide-backend if it wasn't clear.
12:46:45 <TheKing444> kadoban oh
12:50:23 <kadoban> AFAIU there seems to be some deficiencies in all of the available vim tie-in stuff. ghc-mod isn't even released for GHC 7.10.x yet, hdevtools is a bit sparse in features … and that's about it? So I've been trying to figure out how ide-backend would do, but … yeah I can't even get the thing to build so far.
12:50:35 <kadoban> Maybe I'll try again and see if I can figure out what exactly the error is at least …
12:57:03 <creichert> asjo: in that case, it might be better to look at using 'rawSql' for a quick fix. You can try posting to the mailing list as well
12:58:31 <asjo> creichert: Yeah, I kind of wanted to do it "the right way" :-) I am trying to use the example from the documentation, but got an error saying it needed to be imported, and thus be in a file by itself, so I did that, and now I am getting ByteString vs [Char] errors...
13:05:39 <asjo> Ahh, pragmas must be first.
13:06:02 <maia> hello folks
13:06:12 <maia> I began learning haskell these days
13:06:21 <maia> and a big problem of mine has been with types
13:06:37 <Cale> maia: hello
13:06:38 <maia> I'm trying to run lines with a string from a file
13:06:38 <lispy> maia: that's normal :)
13:07:26 <Cale> maia: Okay, so something like  main = do str <- readFile "foo"; let { ls = lines str }; ... do stuff with ls here ...
13:08:10 <maia> I'm inside ghci
13:08:41 <Cale> ah, then you should be able to write  str <- readFile "foo"  at the ghci prompt
13:08:55 <Cale> and then str :: String will be the contents of the file "foo"
13:09:16 <Cale> and you'll be able to write  lines str  at that point
13:10:34 <Cale> The key point to absorb here is that you can't apply lines to readFile "foo" itself because it's not a String, it's a description of some things which could be done to produce a String result. In order to actually execute it, you'll want to use that  v <- x  notation (inside a do-block, or at the ghci prompt), which means "execute the action x, and call its result v"
13:11:31 <Cale> So if x :: IO t, then v :: t
13:12:05 <Cale> and if you use that inside a do-block, then the whole do-block has type IO s (whatever the type of the last action in the block is)
13:12:36 <Cale> (do-blocks serve to glue together simpler actions into more complex ones)
13:13:12 <asjo> creichert: I'm down to this last line being the only problem: "where ps = Data.Text.pack . show" - ghc says that it can't match ByteString with Text...
13:13:49 <maia> Cale, yeap, I tried something like that but I'm getting this error: Couldn't match type `[]' with `IO'
13:14:21 <Cale> Right, that's because you're treating an IO action as if it were a list, when it is not.
13:15:06 <Cale> maia: If you're still confused, perhaps you could put your code on lpaste.net and we could have a look at what's wrong
13:15:16 <maia> ok, minute, please
13:16:15 <lispy> asjo: how are you using ps? There is nothing in that line that should be of type ByteString
13:16:54 <asjo> lispy: I copied the example code from https://hackage.haskell.org/package/persistent-2.2/docs/Database-Persist-Types.html#v:PersistDbSpecific - I guess it overloads the strings?
13:17:12 <maia> here http://dpaste.com/34XFNFT
13:17:47 <Cale> ah!
13:17:47 <asjo> Anyway, I tacked an encodeUtf8 . on and that "helped" on that part. On to the next error (No instance for (Show Geo))
13:17:49 <maia> edges.txt looks like this: \d \d(\n\d \d)+
13:17:56 <haskell731> @pl \f g x y -> f (x ++ g x) (g y)
13:17:56 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
13:17:57 <Cale> It's the opposite of the problem I thought you were having
13:18:07 <Cale> farness graph Map.empty 0 [currentLevel] is itself just a list
13:18:13 <Cale> Did you want to print this list?
13:18:17 <lispy> asjo: that's an odd example and I wouldn't exit it to work. The Data.ByteString.concat should probably be from Data.Text
13:18:22 <maia> yeap
13:18:27 <haskell731> @pl \x y -> x y
13:18:28 <lambdabot> id
13:18:29 <Cale> Try:  print (farness graph Map.empty 0 [currentLevel])
13:18:38 <maia> Cale, it is not complete yet
13:18:46 <haskell731> @pl \x -> Just (eval x)
13:18:47 <lambdabot> Just . eval
13:18:49 <asjo> lispy: Sad to hear that, it's all I've got to go on.
13:19:02 <maia> I can't believe that was my problem @.@
13:19:13 <lispy> asjo: So notice that Geo is defined to take ByteString
13:19:35 <magneticDuck> haskell731: you don't have to do that here on the channel you know ^^
13:19:37 <lispy> asjo: but the "where ps ..." line uses Data.Text. So you could also fix this by using Data.ByteString.pack there
13:19:43 <maia> Thanks Cale! Error message was kind of mean
13:19:46 <lispy> (or you might need a Char8 in that module name)
13:19:53 <Cale> maia: no problem :)
13:19:59 <asjo> lispy: That was my first guess, but that gave an error.
13:20:43 <asjo> lispy: Specifically "Couldn't match type ‘Char’ with ‘GHC.Word.Word8’"
13:21:07 <lispy> asjo: yeah, because the full name is Data.ByteString.Char8.pack
13:21:37 <haskell731> @magneticDuck what is the correct place to do it? 
13:21:38 <lambdabot> Unknown command, try @list
13:21:42 <merijn> ARgh
13:21:51 <merijn> Don't use Char8! >.<
13:22:09 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
13:22:27 <asjo> merijn: How do I resolve the problem without doing that?
13:22:36 <merijn> That depends on what the problem is
13:23:13 <asjo> merijn: Making  the example code from https://hackage.haskell.org/package/persistent-2.2/docs/Database-Persist-Types.html#v:PersistDbSpecific work.
13:23:17 <lispy> asjo: Do you know how the database stores text? Is it ascii, utf8, etc?
13:23:51 <asjo> lispy: utf8 - it isn't important for this field, as the input is a PostGIS function that takes numbers (i.e. ascii only).
13:23:52 <merijn> asjo: That example code is hacky as fuck if it's using char8 >.<
13:23:58 <maia> Oh, another question, what is the closest haskell has to a null value?
13:24:07 <maia> or there is no such thing
13:24:18 <merijn> maia: undefined, maybe?
13:24:18 <lispy> maia: Nothing from the Maybe type
13:24:35 <lispy> (I can't just answer "Nothing" because it would be ambiguous!)
13:24:38 <maia> hummm
13:24:47 <asjo> merijn: Perhaps so, but it's the best starting point I've found :-)
13:24:56 <maia> I'm using a Map here and when I lookup values from keys
13:25:07 <maia> I have to use findWithDefault
13:25:15 <lispy> asjo: if it's utf8 then one route is to encode/decode to utf8 whenever you put things in or take them out. Better yet is to use Data.Text. It 
13:25:32 <lispy> asjo: it might be as simple as using Data.Text in place of ByteString in that example
13:25:35 <maia> Otherwise, lookup returns a Maybe and Maybe doesn't seem easy to work with
13:25:49 <mauke> maia: Maybe is easy to work with
13:26:14 <geekosaur> o.O
13:26:28 <geekosaur> someone kline web.freenode.net again?
13:26:30 <lispy> asjo: I'm really unfamiliar with the nuts and bolts of these libraries and the datastore you're using so I would have to play with it.
13:26:32 <asjo> lispy: I'm not that well versed in reading library code, but it looks to me like persistent has made the choice for me? If you look at what PersistDbSpecific is defined as?
13:26:32 <haskell731> @pl \s -> maybe Nothing (Just . eval) (parseExp Lit Add Mul s)
13:26:32 <lambdabot> maybe Nothing (Just . eval) . parseExp Lit Add Mul
13:26:34 <maia> mauke, see this (Map.lookup 0 (Map.fromList [(0, 10)])) == 10
13:26:46 <mauke> maia: ok?
13:26:49 <maia> no juice there
13:26:53 <mauke> what?
13:26:57 <asjo> lispy: I appreciate the pointers I've gotten so far a lot!
13:27:06 <maia> mauke, doesn't work
13:27:13 <mauke> maia: "doesn't work" is not a problem description
13:27:24 <maia> I get an error = ]
13:27:30 <mauke> ok?
13:27:31 <maia> No instance for (Num (Maybe a0)) arising from the literal `10'
13:27:35 <maia> but
13:27:37 <mauke> so why are you showing me broken code?
13:27:44 <mauke> what are you trying to do?
13:27:48 <lispy> asjo: There must be a way to convert Data.Text to/from bytestring and get the encoding/decoding as you go?
13:28:17 <mauke> oh shit, more bots
13:28:30 <asjo> lispy: Data.Text.Encoding has encodeUtf8, which I plugged in before Data.Text.pack - that compiled.
13:28:31 <porglezomp> What's with these floods?
13:28:36 <maia> mauke, I'm showing broken code because I don't think Maybe is easy to work with. I'm probably missing something
13:29:10 <mauke> maia: again, what are you trying to do?
13:29:15 <asjo> lispy: Now I just need to figure out how do make " No instance for (Show Geo)" go away :-)
13:29:20 <maia> mauke, get values from a map with a key
13:29:24 <maia> this works Map.findWithDefault 0 0 (Map.fromList [(0, 10)])
13:29:43 <maia> mauke, this doesnt (Map.lookup 0 (Map.fromList [(0, 10)])) == 10
13:29:48 <mauke> maia: ok, but what for?
13:29:54 <mauke> maia: what is the == 10 supposed to do?
13:30:14 <maia> test the result from the lookup
13:30:31 <lispy> asjo: you could add 'deriving (Show)' to your Geo definition, but it's likely not the correct answer :)
13:30:35 <maia> normally I would use the result for something; I'm just showing it is not easy to compare a maybe return
13:30:37 <mauke> well, you could write Map.lookup 0 m == Just 10
13:30:42 <mauke> but that's weird
13:30:49 <mauke> normally you'd use a 'case' expression
13:30:57 <asjo> lispy: doing so gets me to another error, though... ;-)
13:31:07 <mauke> like case M.lookup 0 m of Just x -> ...; Nothing -> ...
13:31:10 <lispy> asjo: Normally it would be, because you want Read/Show to match each other. So it's best to let the compiler provide them. I don't know that this code is meant to be literally followed.
13:31:10 <maia> mauke, woa! That was what I was missing
13:31:22 <maia> mauke, what if I want the value?
13:31:38 <mauke> see above
13:31:42 <mauke> it's in x
13:31:59 <maia> hummm
13:33:01 <asjo> lispy: This is my first non-trivial program (parsing stuff and putting it into a database), so I am basically doing trial and error by copy/paste, guessing, looking stuff up, and now asking here. I don't know that I need Read/Show for this thing, but...
13:33:07 <maia> mauke, how would I return x?
13:33:08 * hackagebot hsb2hs 0.3.1 - Preprocesses a file, adding blobs from files as string literals.  http://hackage.haskell.org/package/hsb2hs-0.3.1 (JohnMacFarlane)
13:33:21 <mauke> maia: ???
13:33:39 <maia> someFn( M.lookup 0 m of Just x) <--
13:33:39 <maia> ?
13:33:41 <lispy> asjo: Ah. Well, I'd be happy to take a look if you can share the code.
13:34:17 <mauke> maia: that makes no sense
13:34:22 <mauke> explain what you're trying to do
13:34:31 <maia> I'll explain in python?
13:34:37 <maia> may I explain in python?
13:34:40 --- mode: ChanServ set +o mauke
13:34:40 --- mode: mauke set +b *!*@62.109.31.*
13:35:00 <mauke> you can try
13:35:03 <maia> fn = lambda x: x + 1; d = {1:2}; fn(d[1])
13:35:25 <maia> that!
13:35:29 <mauke> that doesn't help
13:35:32 <mauke> try english
13:35:49 <maia> Ok, I have a function and I have a map instance
13:36:12 <maia> I want to throw a value from my map instance as my function parameter given I have a valid key for the map
13:36:31 <mauke> what if the key doesn't exist in the map?
13:36:40 --- mode: mauke set -o mauke
13:36:43 <maia> it always exists
13:36:55 <maia> because I fetch the key from the map
13:37:04 <mauke> fn (d ! 1)
13:37:09 <mauke> that is, Map.!
13:37:45 <maia> hummmm
13:37:53 <asjo> lispy: http://koldfront.dk/misc/haskell/flyby.hs and http://koldfront.dk/misc/haskell/Geo.hs
13:38:15 <lispy> asjo: thanks, looking
13:38:33 <mauke> > M.empty M.! ()
13:38:34 <maia> mauke, is it possible to import ! from Data.Map?
13:38:35 <lambdabot>  *Exception: Map.!: given key is not an element in the map
13:38:41 <mauke> maia: sure
13:38:52 <maia> without poluting namespace
13:38:59 <mauke> maia: what does your import line look like?
13:39:01 <maia> here is how I import Map
13:39:02 <maia> import Data.Map (Map)
13:39:02 <maia> import qualified Data.Map as Map
13:39:16 <mauke> change first line to: import Data.Map (Map, (!))
13:39:19 <mauke> that should do it
13:39:33 <asjo> lispy: The position stuff is the thing I am trying to make work.
13:39:41 <maia> woah, it works!
13:39:46 <maia> happy me!
13:40:09 <maia> thanks mauke, merijn, lispy 
13:40:20 <asjo> lispy: Ah, my problem is probably that I need to convert the Geo.hs to take the altitude again (I started over once).
13:41:19 <lispy> asjo: which file/line says you're missing a Show?
13:41:24 <lispy> maia: yw!
13:41:59 <asjo> lispy: I added it to Geo.hs after your suggestion, so the compiler doesn't complain about that any more.
13:42:10 <lispy> ah
13:44:05 <asjo> lispy: So now I am trying to figure out the correct way to invoke toPoint
13:45:57 <lispy> asjo: well, the definition in Geo.hs takes just a lat/long pair and the use in flyby.hs provides an altitude. So I guess you have to decide if you're in 2d or 3d?
13:46:45 <cow_2001> hey guys
13:47:04 <cow_2001> so i have a [String]
13:47:22 <asjo> lispy: Yes, I have modified Geo.hs to take three arguments (files updated on the two URLs).
13:47:42 <cow_2001> i want to edit this as if it were a text file
13:47:48 <cow_2001> as an editor
13:47:59 <cow_2001> i don't know how such things are usually done
13:48:07 <athan> zippers?
13:48:07 <kqr> hi awesome people. if I want to run an attoparsec on one line at a time from a file, which is lazily loaded (so approximately one line at a time is in memory – never the whole file), which IO library would be good for that?
13:48:09 * hackagebot load-env 0.1.1 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.1.1 (PatrickBrisbin)
13:48:20 <lispy> asjo: missing a call to textMaybe?
13:48:27 <cow_2001> like, interactively
13:48:28 <kqr> an attoparsec = an attoparsec parser
13:48:47 <quchen> cow_2001: [String] is a *terrible* format for representing a text file. It's a singly linked list of singly linked lists of individual characters. 
13:49:36 <asjo> lispy: compiler says "The function ‘longitude’ is applied to two arguments" so I am missing something fundamental, it seems.
13:49:41 <cow_2001> quchen: what's a better way to do it?
13:49:54 <quchen> cow_2001: Use Text instead of String, for starters.
13:50:10 <quchen> Text is made for text, String is made for fitting into Haskell easily and not much else.
13:50:14 <lispy> asjo: get rid of the parens around longitude
13:50:22 <cow_2001> it's a very very small bit of text, not a real file
13:50:32 <lispy> toPoint longitude latitude (altitudeMeters altitude)
13:50:35 <asjo> lispy: Ah, thanks!
13:51:43 <lispy> asjo: yw, does it actualy work now?
13:52:07 <cow_2001> so where do i start reading about interactive file editing using Text?
13:52:08 <asjo> lispy: Ok, now I just need to actually provide Doubles to toPoint, I think that's the last puzzle piece. Thanks for looking!
13:52:23 <lispy> asjo: cool, good luck!
13:54:39 <magneticDuck> cow_2001: uh. so you're writing a text editor?
13:54:43 * cow_2001 reads https://hackage.haskell.org/package/text-1.2.1.1/docs/Data-Text.html
13:54:48 <cow_2001> magneticDuck: not quite
13:55:06 <cow_2001> magneticDuck: it's a passphrase input prompt
13:55:48 <magneticDuck> if I were you, I'd just define a set of user 'actions' and a function to evaluate them on a state, in this case probably something like a bit of text and a cursor position
13:56:25 <magneticDuck> the fact that you want to do this interactively doesn't really add anything to the fact that what you need are a set of simple methods for dealing with an array of characters
13:56:40 <magneticDuck> if it's just a passphase input prompt, you can get away using 'String'
13:56:47 <magneticDuck> maybe I'm missing something though ^^
13:57:22 <asjo> lispy: compiles now (URLs updated), then I just need to adjust the SQL and problem solved :-)
13:57:22 <cow_2001> my state is currently [string] and a cursor position (Int, Int), more or less
13:57:40 <magneticDuck> a multiline password prompt?
13:57:43 <cow_2001> yes
13:57:44 <magneticDuck> pretty hardcore passwords here
13:58:04 <kadoban> multiline is fairly strange. Even passphrases are generally one line
13:58:22 <cow_2001> i want to make it easier to input passphrases
13:59:00 <magneticDuck> anyway, while making a text editor is a rather complex ordeal with a bunch of optimization considerations, a password prompt shouldn't better more than polynomial-order operations, I imagine 
13:59:06 <kadoban> I've never had a problem with passphrases, except in contexts that needlessly limit maximum password length (or require ridiculous characters)
13:59:29 <magneticDuck> unless you're talking about huge encryption keys, or one-time pads being used as 'passwords' x)
13:59:56 <kqr> Data.Attoparsec.ByteString has a function word8 :: Word8 -> Parser Word8. how do I provide it with a Word8? I gather taht is different from a Char?
14:00:08 <merijn> kqr: A Word8 is a byte
14:00:13 <merijn> > 1 :: Word8
14:00:14 <kqr> Word8 is a Num, so I could just type the ascii code for the character I'm interested in
14:00:16 <lambdabot>  1
14:00:16 <kqr> wait
14:00:18 <kqr> ord perhaps
14:00:31 <magneticDuck> Enum ^^
14:00:36 <magneticDuck> third try is the charm
14:01:06 <merijn> kqr: Why are you using Attoparsec.ByteString if you care about characters?
14:01:14 <merijn> Why not .Text?
14:01:37 <kqr> merijn, because I'm dealing with a stream of ascii characters, not a text
14:01:40 <freeman42> is there some special gotcha when using .ghci config with cabal repl related to importing modules? tried :m ModuleName or import ModuleName in .ghci and neither of them are working
14:02:00 <merijn> kqr: How is a stream of ascii characters not a text?
14:02:26 <kqr> merijn, e.g. when it is a base64 coded image
14:02:34 <kqr> maybe that's considered to be a text though
14:02:35 <eds> I am implementing GADT and I am getting this type error. What am I doing wrong? The code and the error -> http://lpaste.net/132328. Source for the code: https://en.wikibooks.org/wiki/Haskell/GADT
14:03:49 <indiagreen> eds: you have Plus twice
14:03:51 <indiagreen> that's a typo
14:03:58 <indiagreen> the 2nd one should be Eq
14:05:20 <eds> Ahh my bad. Thanks.
14:05:34 <eds> indiagreen
14:18:51 <asjo> lispy: Ok, I'm down to the problem being that persistent quotes the Geo value, which is exactly what I was trying to avoid by making it a DbSpecific custom type.
14:21:21 <maia> Folks, question, how could I have multiple definitions for the same function?
14:21:33 <maia> I want to have default arguments for a function
14:21:57 <maia> fn a = ... / fn a b = ... /
14:22:25 <maia> something like this would do the trick for me  fn a b = ... / fn a = fn a 0 ...
14:22:40 <kadoban> maia: You can't do that in haskell. It sometimes could make sense, but it's not syntactically allowed.
14:23:08 <maia> understoon, thanks kadoban 
14:23:10 * hackagebot google-oauth2 0.2.0 - Google OAuth2 token negotiation  http://hackage.haskell.org/package/google-oauth2-0.2.0 (PatrickBrisbin)
14:23:27 <lispy> implicit parameters is sort of that idea
14:23:33 <maia> I'll make some syntactic sugar to help me
14:23:42 <lispy> asjo: Hmm...Yeah, I don't know that library enough to help with taht
14:24:12 <asjo> lispy: Ok, I will dig some more before giving up for tonight :-)
14:24:37 <lispy> maia: look at the implicit paremeters here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html
14:25:57 <lispy> maia: it's slighty different, in that it looks it up in the scope
14:34:54 <eds> indiagreen: Is there a way for me to make Data Expr derive attributes like (Typeable,Data,Eq,Show) ?
14:40:27 <monochrom> eds: use the extensions {-# LANGUAGE DeriveDataTypeable, DeriveDataData #-}
14:41:14 <indiagreen> monochrom: what's DeriveDataData?
14:41:39 <indiagreen> also, I'm trying to do just this right now and the derived instances don't typecheck
14:42:00 <kqr> what might cause this error? "No instance for (Show UTCTime)"
14:42:08 <kqr> as far as I can see, UTCTime should have a show instance
14:42:11 <indiagreen> (the Data one, at least – the rest typecheck just fine)
14:42:27 <indiagreen> kqr: the instance is in Data.Time, I think, and you might've imported something else
14:42:34 <kqr> ah, yes, that is correct
14:42:36 <kqr> thank
14:42:38 <kqr> s
14:42:44 <c_wraith> kqr: I've seen that before.  For wahtever reason, the instance isn't defined in the place the data type is
14:43:08 <eds> monochrom: I have DeriveDataTypeable. I'll add DeriveDataData but the issue seems to be -
14:43:11 <eds>     Can't make a derived instance of `Data (Expr a)':       Constructor `I' has existentials or constraints in its type       Constructor `B' has existentials or constraints in its type       Constructor `Plus' has existentials or constraints in its type       Constructor `Times' has existentials or constraints in its type       Constructor `Eq' has existentials or constraints in its type       Possible fix: use a standalone deriving de
14:43:11 * hackagebot zoom-refs 0.0.0.0 - Zoom (~ Functor) and pairing (~ Applicative) for mutable references.  http://hackage.haskell.org/package/zoom-refs-0.0.0.0 (mjmrotek)
14:43:52 <eds> In the data declaration for Expr*
14:43:59 <indiagreen> eds: here's code that almost works: http://lpaste.net/135937
14:45:03 <indiagreen> I don't know how to get Data to be autoderived as well
14:45:07 <eds> ahh so that is what it means by standalone declaration?
14:46:04 <Welkin> standalone deriving orphan instances
14:48:51 <c_wraith> heh.  That zoom-refs package is more or less the coyoneda trick, except with an existentially-quantified lens instead of function
14:52:35 <jorr> does anyone know what became of Chris Done's ide-backend-mode?
14:53:11 <jorr> the gihub repo mentioned in this video https://www.youtube.com/watch?v=Cwi1p2CLW54#t=63 doesn't seem to exist anymore.
14:54:30 <kadoban> jorr: Is it stack-mode in https://github.com/commercialhaskell/stack-ide ?
14:55:03 <jorr> ooh I'll bet it is! Thakns.
14:55:04 <geekosaur> looks like it, yes
15:01:28 <maia> question: why would this arise from a (Map.size graph) / 184
15:01:29 <maia>  Could not deduce (Fractional Int) arising from a use of `/' <= this
15:02:14 <kadoban> maia: Perhaps you mean div, for integer division?
15:02:34 <geekosaur> because Map.size returns an Int, which is not a member of Fractional
15:02:48 <maia> shouldn't / also work? (div worked!)
15:02:53 <geekosaur> use fromIntegral on it, or use `div`
15:02:55 <geekosaur> no
15:02:55 <maia> oh
15:03:57 <Gurkenglas> Made a folder, put my .hs in it, did cabal sandbox init in there, then cabal install scalpel, then ghci'd my .hs, then it said it couldnt find the module from scalpel. Do I have to do something different if I installed a package in a sandbox?
15:04:01 <geekosaur> basically you have to either specify that you don't care about a remainder, or convert to something that supports a remainder. Haskell doesn't automatically "upcast" for you like many other languages
15:04:12 <geekosaur> Gurkenglas, cabal repl
15:05:12 <maia> I'll have to use fromIntegral
15:05:17 <maia> as div only returns integers
15:05:26 <kadoban> Gurkenglas: GHC (and ghci) don't really understand cabal sandboxes, unless you tell them to.
15:05:48 <Gurkenglas> Using cabal repl on my .hs launches a ghci that doesnt seem to have any of the names in my .hs in its scope.
15:05:54 <kadoban> And by "tell them to" I mean, manually point them to the right package directories or whatever it is. Or cabal provides the easy wrapper thing of course.
15:06:35 <Gurkenglas> Easy wrapper thing?
15:08:12 * hackagebot metrics 0.3.0.2 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.3.0.2 (IanDuncan)
15:09:15 <kadoban> Gurkenglas: aka 'cabal repl' and 'cabal exec'
15:10:28 <eds> monochrom: How do derive Data attribute for Expr? Updated lpaste with the error: Cannot create an instance of Expr. http://lpaste.net/132328.
15:10:32 <eds> indiagreen ^
15:13:41 <kqr> what would be the recommended data structure for a collection of log entries? (preferably which can be sorted on something like timestamp)
15:14:31 <jfeltz> is there a way to dump the full tree of imports declared in a particular module? ala VC++ header /showIncludes ? I'm writing a test-runner that needs this info
15:14:35 <Gurkenglas> kadoban, using cabal exec on my .hs says "cabal: The program <my program> is required but could not be found."
15:15:02 <maia> folks, I would like to tell you I just made my first algorithm with haskell
15:15:06 <maia> a closeness algorithm
15:15:15 <maia> thanks to you ; )
15:16:53 <yayfoxes> hi guys
15:17:10 <jfeltz> well, ok, ghci has ":show imports", though that's not exactly what I'm looking for
15:17:12 <Gurkenglas> Oh, I assumed that as cabal repl launches a ghci, exec would do ghcs job. Still, see the above on cabal repl.
15:17:21 <yayfoxes> whoops, wrong channel. But hi Haskell guys!
15:17:32 <yayfoxes> how are things/
15:18:16 <maia> another question: how should I handle namespaces with haskell?
15:18:36 <L8D> maia: elaborate
15:18:52 <L8D> yayfoxes: hi. things are going well
15:18:56 <maia> L8D, let's see, I plan to have two hs files in my project
15:19:08 <maia> and I need to import one into another
15:19:16 <maia> but I want to avoid naming clash
15:19:35 <maia> in python, if I have code.py and I import code, code will act as the namespace
15:19:39 <L8D> maia: there are many qays you can import things
15:19:54 <L8D> maia: import qualified Something.Foo as Foo
15:20:09 <L8D> maia: will work like: import something.foo as foo (in python)
15:20:17 <maia> L8D, so I heard : ( How do I declare a Foo for myself and attach all my functions to it?
15:20:18 <kadoban> maia: That's essentially how modules work in haskell as well, except the importing syntax is slightly different (though not much)
15:20:29 <L8D> maia: import Something.Foo = from something.foo import *
15:20:40 <L8D> maia: import Something.Foo (bar, baz) = from something.foo import bar, baz
15:20:41 <maia> hummm
15:21:07 <L8D> maia: the module references work very similarly to Java (and coincidentally Python)
15:21:21 <L8D> maia: import Foo will look at the file named Foo.hs
15:21:55 <L8D> maia: import Something.Foo will look for Something/Foo.hs
15:22:12 <maia> hummm
15:22:14 <maia> interesting
15:22:28 <L8D> maia: and in Something/Foo.hs you'll have the line "module Something.Foo where" at the top
15:22:58 <L8D> maia: by default everything you declare is public/exported (like in Python or Java)
15:23:10 <maia> I only need Something.Foo if I have it inside another directory?
15:23:13 <L8D> maia: but you can explicitly export things by writing the module header as:
15:23:21 <L8D> module Something.Foo (bar, baz) where
15:23:36 <L8D> and it will only export bar and baz, similar to doing __all__ = ['bar', 'baz'] in python
15:24:09 <L8D> maia: All module references are fully qualified
15:24:38 <L8D> maia: So if you have Something.Foo and Something.Bar you can't say "import Foo" in Something.Bar, you have to say "import Something.Foo"
15:25:36 <L8D> maia: even though the individual files are named Foo.hs and Bar.hs, you need to declare them as "module Something.Foo where" and "module Something.Bar where" if they are in the Something/ folder
15:25:47 <indiagreen> eds: sorry, I don't know much about Data
15:25:50 <L8D> maia: are you using cabal?
15:25:59 <L8D> maia: am I answering your question?
15:26:13 <eds> indiagreen: oh ok. Thank you.
15:26:25 <maia> L8D, not using cabal here
15:26:40 <maia> sorry for the delay, I was coding what you were writing
15:26:48 <L8D> maia: if you have two files, one named "Foo" and the other named "Bar"
15:27:09 <L8D> er... "Foo.hs" and "Bar.hs"
15:27:33 <L8D> maia: and you want Bar.hs to import functions from Foo.hs, then you can write "import Foo" in Bar.hs
15:27:56 <L8D> maia: as long as you have "module Foo where" written in Foo.hs, and "module Bar where" written in Bar.hs
15:27:59 <L8D> I hope that helps
15:28:43 <Hafydd> Why is this file not present? https://downloads.haskell.org/~ghc/latest/docs/html/libraries/src/Data-Foldable.html
15:28:44 <kqr> does haskell have some sort of in-memory database/search engine? I have a bunch of data which I'm likely to query in various ways (filter and sort mostly) and I've realised what I basically need is a database, except I don't actually need the persistence a regular database provides
15:29:04 <ij> Haskellfant, funny guy in that talk
15:29:30 <ij> Haskellfant, Also, much more consumable at 1.5x
15:29:37 <maia> so, my module file should be capitalized?
15:29:37 <jorr> kqr: Maybe https://hackage.haskell.org/package/tables ?
15:29:42 <maia> is that a rule, L8D 
15:29:42 <kqr> Hafydd, https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Foldable.html
15:29:44 <kqr> Hafydd, if that helps
15:30:07 <jorr> kqr: It's one of the possibly confusing ekmett packages.  But sounds like what you're looking for possibly.
15:30:07 <orion> Hi. Could someone please explain to me what the function signature for scottyAppT means?
15:30:09 <L8D> maia: actually I'm not sure but I've never seen any that weren't
15:30:10 <orion> http://hackage.haskell.org/package/scotty-0.10.1/docs/Web-Scotty-Trans.html#g:1
15:30:19 <L8D> maia: actually yes that is a rule
15:30:43 <Hafydd> kqr: thank you, that is helpful; but I'd still be interested to know why it isn't there.
15:31:05 <maia> this is not working: module Centrality (readGraph, closeness, closenessGraph, farness, farnessGraph) where
15:31:12 <maia> my file is named Centrality.hs
15:31:43 <L8D> maia: what kind of error are you getting?
15:33:01 <maia> parse error on input `module'
15:33:31 <L8D> maia: is it at the top of the file?
15:33:32 <kqr> jorr, that looks pretty badass actually
15:33:36 <kqr> jorr, lemme see if I can figure out how to use it
15:34:03 <L8D> maia: the "module Foo (...) where" belongs at the very top of the file
15:34:05 <maia> L8D, it wasn't, now it is
15:34:08 <maia> new error module Centrality (readGraph, closeness, closenessGraph, farness, farnessGraph) where
15:34:16 <maia>     Not in scope: `main'
15:34:21 <maia>     Not in scope: `main' <= error
15:34:34 <L8D> maia: are you importing or trying to compile it or something?
15:34:55 <maia> ooooooooooh
15:34:57 <L8D> maia: by default GHC will look for a "main" function to compile a binary
15:35:00 <maia> Now I get it
15:35:07 <maia> I was trying to run it
15:35:27 <L8D> maia: if you run into anything else let us know
15:35:45 <maia> haskell has many commands to work with code; As I'm from python background, it did not think it could be the problem
15:35:50 <maia> thanks ; )
15:35:57 <maia> things are going smoothly here
15:36:29 <L8D> maia: you might want to try using GHCi
15:36:47 <L8D> maia: ghci <filename> will load up a REPL with the file imported
15:36:58 <L8D> and you can use the :e command to open the editor
15:37:16 <L8D> so when you leave the editor it does a type check and such
15:37:20 <maia> I am using runghc
15:37:26 <maia> hummm
15:37:59 <Welkin> rundmc
15:38:09 <L8D> maia: my usual workflow involves "cabal repl" (ghci for cabal projects) where I edit code, then when I leave the editor cabal displays any type errors
15:38:24 <L8D> maia: and when I run :e again it will jump to the line of the first error
15:38:38 <L8D> maia: so I go back and forth between the editor and the repl
15:38:43 <maia> using sublime for editor, or something else?
15:38:59 <L8D> maia: when you're in the repl, you can use :main to run the program as a binary
15:39:05 <L8D> like runghc
15:40:47 <maia> If I may, L8D, do you write haskell code for work, teaching?
15:41:17 <maia> I was challenged to write an algorithm with haskell and, so far, It has been quite hard
15:41:27 <maia> this channel is really saving my ass here
15:42:35 <eds> How do we derive Data attribute for Expr? Updated lpaste with the error: Cannot create an instance of Expr. http://lpaste.net/132328. *bump*
15:42:47 <bitemyapp> maia: shifting into Haskell is less like learning a new language-syntax and more like learning a new way of programming (for most people)
15:42:52 <L8D> maia: at one point I tried to teach some high school students
15:43:04 <maia> bitemyapp, agree, TOTALLY!!
15:43:07 <bitemyapp> maia: the difficulty is common and typical, and you get over it eventually. Eventually, you don't want to use anything else to solve problems :)
15:43:15 <bitemyapp> maia: I use Haskell at work and teach it / write about it.
15:43:16 <L8D> maia: but I use Haskell for writing REST APIs for contract work
15:43:37 <maia> REST APIs? Hummm, that's interesting
15:43:38 <bitemyapp> maia: they don't necessarily pipe up a lot, but more people are in here that use Haskell for work than you might guess.
15:43:53 <maia> L8D, do you use a framework or something?
15:43:55 <bitemyapp> maia: REST APIs I think is a common application. Any sort of backend work is going to be popular in Haskell.
15:44:11 <L8D> maia: yeah, http://hackage.haskell.org/package/rest-core is a really nice library
15:44:17 <bitemyapp> at work we use Snap, I've happily used Yesod. I know some happy Servant and Scotty users for REST APIs.
15:44:48 <bitemyapp> maia: I've got a little URL shortener example here: http://bitemyapp.com/posts/2014-08-22-url-shortener-in-haskell.html with a more literate explanation here: http://bitemyapp.com/posts/2014-11-22-literate-url-shortener.html
15:46:19 <L8D> eds: I don't think the `Data' type class is derivable
15:47:55 <eds> L8D: Uhm, It works in this case: http://lpaste.net/135944
15:48:40 <L8D> eds: you aren't using any parameterization in that case
15:48:54 <L8D> eds: whereas the other code wanted to do Data a => Data (Expr a)
15:49:13 <L8D> eds: I'm sure writing the instance by hand isn't that hard
15:49:25 <maia> Thanks guys, I'll read about them. 
15:50:55 <eds> Yeah. Could you give me some direction on how I would do it?
15:51:58 <L8D> eds: start here http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Data.html#t:Data
15:52:26 <L8D> oh wait
15:52:36 <eds> Thanks. I'll do that
15:53:10 <eds> ok, what is it?
15:54:01 <L8D> eds: I think you should be able to derive
15:54:14 <indiagreen> eds: I'm not even sure an instance can actually be written for Expr a, only for Expr Int and Expr Bool separately (and I don't know how to combine them)
15:54:23 <L8D> eds: the issue is that the 'a' is not typeable
15:54:35 <eds> yea 'a' is a phantom type
15:54:43 <L8D> I believe there is a language extension where you can require 'a' to be typeable
15:54:47 <L8D> or something
15:55:02 <L8D> eds: try adding 'Typeable a => Typeable (Expr a)` first
15:55:08 <L8D> see if that fixes anything
15:55:26 <indiagreen> L8D: you can write “deriving instance Data a = Data (Expr a)”
15:55:30 <indiagreen> Typeable is fine here
15:55:46 <L8D> indiagreen: what?
15:56:08 <indiagreen> I mean, okay, wait
15:56:13 <L8D> indiagreen: it can't derive "Data a => Data (Expr a)" because a is not Typeable
15:56:19 <L8D> or Expr a is not typeable I mean
15:56:45 <L8D> indiagreen: Expr a cannot dirived because a may not be Typeable, so he needs "Typeable a => Typeable (Expr a)"
15:57:23 <indiagreen> L8D: here's the error I'm getting: http://lpaste.net/135945
15:57:34 <indiagreen> it doesn't seem to mention Typeable
15:58:04 <L8D> indiagreen: is that the only error you are encountering?
15:58:10 <indiagreen> yep
15:58:49 <indiagreen> I also have hand-written instances for Expr Int and Expr Bool, and I'm getting the same error when I try to combine them
15:59:29 <L8D> indiagreen: have you tried add the typeable thing though?
15:59:44 <eds> It doesnt work the way you suggested. Gives me an error. L8D.
15:59:46 <L8D> indiagreen: I know the error doesn't mention anything, but that seems like a good idea
15:59:52 <indiagreen> yep, I tried
15:59:57 <indiagreen> also, well
16:00:07 <L8D> indiagreen: did that simply do nothing? or did it give you more errors?
16:00:15 <indiagreen> it did nothing
16:01:16 <eds> Yea the same error that indiagreen gets.
16:01:43 <indiagreen> I think the problem here is that gunfold is expected to produce “c (Expr a)” for any Constr, but we must actually give different types depending on what Constr we're given, so... I don't know
16:02:07 <L8D> indiagreen: can you use the code with the hand-written instances for Expr Int and Expr Bool?
16:02:15 <L8D> indiagreen: and show the error you get from that?
16:03:26 <indiagreen> the hand-written instances – which, by the way, I'm not sure are even valid (I wrote them mechanically by looking at Data.Data) – are here: http://lpaste.net/135946
16:03:46 <indiagreen> a sec, I'll write the combined version
16:04:03 <maia> folks, how do I add sortBy to scope?
16:04:16 <maia> I need to sort a list of tuples
16:04:16 <mpickering> import Data.List (sortBy)
16:06:23 <kadoban> You actually don't need sortBy to do that, unless you need to modify how it sorts automatically. (There's an Ord instance for (a, b), where a and b are Ord)
16:06:39 <L8D> indiagreen: can you show the error you get with that code?
16:06:47 <L8D> with all the line numbers and stuff
16:08:08 <indiagreen> L8D: http://lpaste.net/135947
16:08:11 <eds> It run fine. Does not give an error. I think the problem occurs when he writes a combined version.
16:10:18 <maia> Folks, does this look broken, to you? http://dpaste.com/1BD4FAA
16:11:41 <c_wraith> maia: doesn't look especially wrong.  But it could just be rankAsc = sortBy (comparing snd)
16:11:59 <c_wraith> maia: oh.  There *is* a problem
16:12:04 <c_wraith> maia: the type signature is wrong
16:12:12 <c_wraith> maia: it needs to specify that t1 is an instance of Ord
16:13:15 * hackagebot stack 0.1.2.0 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.1.2.0 (borsboom)
16:14:30 <maia> rankAsc :: [(String, Ord)] -> [(String, Ord)] ??
16:16:58 <c_wraith> no
16:17:33 <c_wraith> maia: rankAsc :: Ord a => [(String, a)] -> [(String, a)]
16:18:15 * hackagebot sync-mht 0.2.1.0 - Fast incremental file transfer using Merke-Hash-Trees  http://hackage.haskell.org/package/sync-mht-0.2.1.0 (emink)
16:19:00 <maia> c_wraith, do you know why rankAsc :: Ord a => [(String, a)] -> [(String, a)] doesn't work?
16:19:04 <maia> whoops
16:19:11 <maia> rankAsc :: [(String, Ord)] -> [(String, Ord)]
16:19:19 <c_wraith> maia: because Ord isn't a type
16:19:24 <c_wraith> maia: Ord is a class
16:19:28 <maia> Ooooooooh!
16:19:34 <c_wraith> maia: classes are properties a type can have, not types themselves
16:22:30 <maia> one more question: I tried to create a alias with little success
16:22:33 <maia> this is the code http://dpaste.com/2N6RX1G
16:22:44 <maia> why the first example doesn't work but the second does?
16:22:49 <eds> indiagreen LD8: If you weed/comment out the Bool and Eq i.e line 33/34. It points at line 30 with a similar error that it is expecting Int -> Expr a. http://lpaste.net/135947
16:22:57 <c_wraith> maia: is that in ghci?
16:23:02 <maia> yes
16:23:10 <c_wraith> maia: and an older version of ghcc?
16:23:13 <c_wraith> *ghc
16:23:28 <maia> I think it is not old
16:23:33 <c_wraith> 7.6 or older?
16:23:37 <maia> I downloaded it from ubuntu repo
16:23:39 <maia> let me see
16:23:47 <kqr> is anyone able to read this type signature: https://hackage.haskell.org/package/tables-0.4.1.1/docs/Data-Table.html#v:with
16:23:49 <maia> 7.6.3
16:23:52 <indiagreen> eds: yep, because I/Plus/Times aren't producing “Expr a” either
16:23:53 <kqr> not sure how to use that function...
16:24:29 <c_wraith> maia: before ghc 7.8, the monomorphism restriction was on by default in ghci.  It makes certain things have more restricted types than they otherwise would.
16:24:37 <c_wraith> maia: that's what you're running into.
16:24:46 <eds> indiagreen: Yea. But when you do them separately it works, right?
16:24:50 <c_wraith> maia: you can disable it by entering   :set -XNoMonomorphismRestriction
16:25:19 <indiagreen> eds: yes, because those instances are for Expr Int/Bool, not fully generic Expr a
16:25:21 <maia> c_wraith, that will be set globally or for this session only?
16:25:28 <c_wraith> maia: session only
16:25:53 <maia> is it possible to set globally?
16:26:19 <c_wraith> maia: I think so.
16:26:30 <earldouglas> Cabal question: I'm getting a failure during `cabal install`, that says base-4.6 conflicts with base>=4.7, as required by my project.  But I'm working in a clean sandbox, so why doesn't cabal just install base-4.7?
16:26:38 <earldouglas> Where is the 4.6 conflict coming from?
16:26:54 <indiagreen> earldouglas: base is coming with GHC and can't be installed/updated
16:26:58 <geekosaur> earldouglas, a constraint on base really means a constraint on your ghc version
16:27:06 <earldouglas> Ah, that makes sense
16:27:26 <earldouglas> So I either need to upgrade ghc or relax my project's base restriction?
16:27:36 <c_wraith> maia: yeah.  you can create a .ghci file in your home directory
16:28:03 <kadoban> earldouglas: Yes. Which may entail code changes, usually fairly minor.
16:30:57 <earldouglas> Bingo, that did the trick.  Thanks.
16:31:19 <earldouglas> It would be nice if I could configure the ghc version on a per-project basis.
16:31:29 <earldouglas> I guess I can with Nix, but not plain cabal.
16:31:58 <geekosaur> kqr, it's not really readable by itself, I think. but I see something that takes a combination of a table and a key specification, a comparison function, and a value, and returns a lens on a subset of the table selected by using the comparison function to compare the selected key to the value
16:32:54 <maia> c_wraith, it worked! Had to chmod o-w ~/.ghci though
16:33:23 <c_wraith> maia: huh.  I didn't know that.  glad you figured it out. :)
16:33:47 <kqr> geekosaur, I actually just managed to understand it. did not think i'd be able to do that
16:33:53 <kqr> my haskell-fu is growing stronger by every day
16:34:12 * geekosaur would have been faster but is being distracted by game :)
16:34:53 <ReinH> geekosaur: which game?
16:34:53 <kqr> geekosaur, it takes 1. the column to filter on, 3. the value to filter against, and 2. a function that does the filtering. maybe this was what you're saying but with different words
16:35:49 <geekosaur> Women's World Cup final
16:35:59 <ReinH> geekosaur: yeah, crazy
16:38:20 <maia> this now works: rank = sortBy (comparing snd)
16:38:21 <kqr> geekosaur, though.. if you understand it on a deeper level than I do: the filter function is "forall x. Ord x => x -> x -> Bool" which prevents me from using Data.Text.isPrefixOf as a filter function because it's specialised for Text... am I understanding that right?
16:38:39 <maia> now, shouldn't this also work: rrank = reverse rank
16:38:43 <maia> ?
16:38:48 <geekosaur> it's not a filter, it's a comparison function. think sortBy
16:39:12 <geekosaur> if you want a filter function, you want the first listed instance of With
16:39:32 <kqr> oh
16:39:51 <kqr> what would be useful examples of comparison functions in that case?
16:40:39 <geekosaur> in this case, I think you just want compare, and then do the isPrefixOf in the function instance?
16:40:54 <kqr> yeah
16:41:06 <kqr> I was just curious about the reason you can specify a comparison function
16:41:12 <geekosaur> things you might do with the comparison function are anything you might do with sortBy, where compare gives you sort or you can use sortBy (comparing ...) or etc.
16:41:46 <geekosaur> I suspect comparing is the main reason they provide it, but you'd have to ask the author
16:42:02 <kqr> (comparison function in this case returns Bool, not Ordering)
16:43:02 <geekosaur> oh, right, sorry
16:43:31 <geekosaur> but it's a similar concept
16:43:37 <geekosaur> also I think you can use isPrefixOf there
16:43:56 <geekosaur> the reason it is forall-ed is that the key specification ends up selecting the type
16:44:41 <kqr> being able to use isPrefixOf there would be much more convenient than trying to stick that logic into the first selection function
16:44:59 <kqr> but GHC complained about not being able to match bound type `x` against `Text` or something
16:45:12 <geekosaur> hm
16:46:53 <geekosaur> I think I'm out of my depth then, sorry
16:48:20 <kqr> my current hack is `with (\r -> isPrefixOf "/static" (page r)) (/=) True`
16:48:25 <kqr> but I'd love to be able to do something like
16:48:38 <kqr> with Page isPrefixOf "/static"
16:48:40 <kqr> instead
16:49:10 <kqr> uh except the opposite, but you probably get my point
16:49:27 <eds> L8D^
16:54:39 <sunnymilk> why is the unit type/constructor named ()
16:54:49 <sunnymilk> why not just "Unit"
16:55:13 <bitemyapp> sunnymilk: empty tuple
16:55:42 <sunnymilk> its not a tuple though
16:55:43 <bitemyapp> sunnymilk: shorter by two characters
16:56:25 <kqr> sunnymilk, how is it not a tuple?
16:56:52 <sunnymilk> tuples are constructed with the , constructor
16:56:56 <sunnymilk> theres no singleton tuple
16:57:01 <sunnymilk> so why would there be an empty tuple?
16:57:17 <exio4> we could argue that zero could be it, too
16:57:24 <exio4> or 1
16:57:27 <sunnymilk> it just doesnt make sense, () should be for grouping/precedence/expressions
16:57:40 <exio4> ah, yes, 1, 0 would be Void
16:57:50 <noah>  the unit type is the identity element for products of types (tuples), so its the empty product of types
16:58:02 <sunnymilk> i like to call 0 False
16:58:05 <sunnymilk> but Void works too
16:58:23 <exio4> 1 * x = x * 1 = x 
16:58:40 <kqr> sunnymilk, not the value 0, the type which represents 0 in an algebraic type system
16:58:46 <exio4> replace 1 with () , (*) with (,) and bam 
16:59:49 <sunnymilk> kqr i know what you meant
17:00:12 <sunnymilk> it just seems silly to me to have an "empty tuple" witohut a singleton tuple
17:00:48 <kqr> but an "empty tuple" is useful, a singleton tuple is not
17:00:50 <kqr> well
17:01:01 <kqr> I guess it might serve as an Identity functor
17:01:18 <kqr> why don't we have a singleton tuple? we totally should!
17:01:25 <sunnymilk> i would argue that an empty tuple is exactly as useful as a singleton tuple
17:01:26 <sunnymilk> that is, not at all
17:01:31 <exio4> kqr: we have Identity
17:01:32 <noah> yea, the indentity funtor is the singleton tuple
17:01:44 <noah> *identity functor
17:02:50 <sunnymilk> maybe () would make sense if there were singleton tuples
17:02:55 <sunnymilk> but that would make parsing a nightmare
17:03:08 <kqr> sunnymilk, but th esingleton tuple IS useful as an Identity functor!
17:03:12 <kqr> but I see your point
17:03:25 <sunnymilk> (C X) could mean either C X or a singleton tuple of C X
17:03:42 <kqr> it would be more logical to have either a 1-tuple and a 0-tuple or an Identity functor and a Unit value
17:03:55 <kqr> not an Identity functor and a 0-tuple
17:07:22 <orion> :t foldl (flip ($))
17:07:23 <lambdabot> Foldable t => a -> t (a -> a) -> a
17:12:35 <ReinH> kqr: (x) is an ambiguous parse: is it the singleton tuple containing x or is it it brackets around the expression x?
17:12:47 <ReinH> oh, sunnymilk said that
17:13:18 <ReinH> The lack of 1-tuples is purely out of syntactic necessity
17:16:26 <kadoban> That seems like an unsatisfying answer though. If they were wanted, it would have easily been possible to just use separate brackets for tuples and precedence-overriding.
17:18:07 <solrize> tuples are a product types, there's not a tuple functor
17:18:19 <solrize> s/a //
17:19:00 <hpc> the other lack of 1-tuples is that they'd be pretty much useless
17:19:23 <hpc> or at least, inferior to Identity which has a more self-documenting name
17:20:22 <bitemyapp> `(a)` would be syntactically confusing to humans where `Identity a` is not.
17:20:41 <hpc> and that's not even to mention partial application
17:20:44 <bitemyapp> even if it didn't overlap with tuple syntax.
17:20:49 <hpc> \a -> (a) = ()
17:20:55 * bitemyapp cringe
17:21:39 <hpc> oh man, imagine the newbies
17:21:48 <wgn> sb goto -5
17:21:51 <hpc> instance Monad() where -- WHY IS MONAD NOT HAVING PARAMETERS
17:22:38 <nolrai66> Wouldn't it be "(())"?
17:22:51 <hexagoxel> () :: () and () :: a -> (a) ?
17:22:57 <hpc> nolrai66: no, that's a kind error
17:23:17 <nolrai66> "..oh, yeah."
17:24:31 <hpc> what we really need is something like (in pseudo-agda)
17:24:38 <marchelzo_> Can you have a type and a type constructor with the same name?
17:24:38 <hpc> (_)_ x f = f x
17:24:54 <hpc> it would be literally the most confusing thing in any programming language
17:24:57 <nolrai66> marchelzo: yes.
17:25:03 <kadoban> hpc: Haha
17:25:15 <marchelzo_> nolrai66: So then (()) could be valid, couldn't it?
17:25:35 <LordBrain> syntax matters a lot
17:25:41 <nolrai66> >.<
17:25:44 <LordBrain> its more important than compiler makers think
17:25:46 <hpc> marchelzo_: that feature is used extensively
17:25:52 <LordBrain> well
17:25:52 <nolrai66> My brain hurts.
17:26:03 <LordBrain> maybe not, more important than language critics think
17:26:04 <hpc> and one of the things that's pretty easy to get tripped up on for people new to the language
17:26:27 <hpc> it took me a whole day to decipher the definition of Maybe when i was a young warthog
17:27:08 <MarcelineVQ> when he ws a young warthogggg
17:27:10 <orion> :t (>->)
17:27:11 <lambdabot>     Not in scope: ‘>->’
17:27:11 <lambdabot>     Perhaps you meant one of these:
17:27:11 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
17:27:18 <hpc> marchelzo_: :D
17:27:25 <orion> What does >-> do?
17:28:11 <c_wraith> Looks like a pipes operator to me
17:28:19 <hpc> it's an operator in many things
17:28:20 <hpc> http://hayoo.fh-wedel.de/?query=%28%3E-%3E%29
17:28:35 <hpc> but yeah, mainly pipes
17:29:54 <marchelzo_> Doesn't seem to work for me.
17:30:05 <marchelzo_> > type T = Int; type T a = [a]
17:30:06 <lambdabot>  <hint>:1:1: parse error on input ‘type’
17:30:55 <hexagoxel> marchelzo_: those are two types, not type/constructor
17:31:24 <marchelzo_> "type T a = [a]" T is a type constructor, is it not?
17:31:48 <hpc> type constructors and data constructors can be of the same name if there's one of each
17:32:05 <hpc> but two things at the same level with the same name is a conflict
17:32:26 <marchelzo_> So you can't have a type and a type constructor with the same name.
17:32:27 <LordBrain> i appreciate that myself
17:32:27 <hexagoxel> marchelzo_: that is a type declaration
17:32:35 <hpc> data Identity a = Identity a -- an example that works
17:32:38 <hpc> :t Identity
17:32:39 <lambdabot> a -> Identity a
17:32:42 <hpc> :k Identity
17:32:44 <lambdabot> * -> *
17:32:49 <LordBrain> i enjoy the different name spaces in haskell
17:32:50 <hpc> :t Identity 5
17:32:51 <lambdabot> Num a => Identity a
17:33:02 <marchelzo_> But in that case the Identity on the right is a value constructor.
17:33:07 <LordBrain> howevr
17:33:12 <LordBrain> if you use datakinds...
17:33:22 <hpc> marchelzo_: must have misread your original question
17:33:43 <hpc> the original answer should have been "no, but (stuff we just mentioned)"
17:34:04 <hexagoxel> same, i misread the initial question :D
17:34:15 <marchelzo_> hpc: I see. Yeah I guess it would not make much sense if it were possible.
17:34:28 <marchelzo_> It would be very difficult to parse.
17:34:37 <LordBrain> it has the funny effect of merging the kind name space with the data name space while leaving the type name space separate.
17:35:07 <LordBrain> i'm not really complaining tho. its just a bit odd.
17:53:43 <pdxleif> I'm getting a "Not in scope: type constructor or class ‘Map'; Perhaps you meant ‘Map.Map’ (imported from Data.Map.Strict" from my call to Map.fromList
17:53:57 <pdxleif> Which I have as import qualified Data.Map.Strict as Map
17:54:20 <bitemyapp> pdxleif: Map is the module, Map.Map is the type constructor
17:54:26 <bitemyapp> pdxleif: check your type sigs.
17:54:30 <geekosaur> I think you need to show more code
17:54:46 <pdxleif> Oh, n/m, it was complaining about my type sig, not my call to Map.fromList, sorry
17:54:51 <bitemyapp> pdxleif: you could show more code, but I think I was right :P
17:55:23 <pdxleif> Map.Map just looks funny in the sig. :/
17:55:33 <geekosaur> common trick: import qualified Data.Map.Strict as Map; import Data.Map.Strict (Map)
17:56:08 <bitemyapp> pdxleif: ^^ when geekosaur says "common", they mean, "seen bloody everywhere"
17:56:34 <bitemyapp> I think acowley tried to introduce some syntax to make it one line but it got submarined by the Bikeshed Brigade
17:57:29 <pdxleif> I was looking at the wrong line and the error message just threw me "Of course it's not a 'type constructor or class' - it's a frikken module!"
17:59:01 <bitemyapp> pdxleif: happens to the best of us.
18:00:24 <dhbdhb> Hey guys,
18:00:59 <dhbdhb> I had a quick question about Wreq if anyone is familiar with it and has a minute.
18:01:20 <bitemyapp> dhbdhb: best to just toss it out there
18:01:26 <dhbdhb> For sure.
18:01:31 <bitemyapp> dhbdhb: if you ask permission to ask, cranky IRC users like me will tell you there's no point in asking to ask
18:01:37 <bitemyapp> dhbdhb: and you don't want replies from terrible people like me.
18:01:46 <dhbdhb> =P
18:02:07 <dhbdhb> Main.hs:15:42-43: No instance for (FormValue v0) arising from a use of ‘:=’ …  I'mg etting that error when trying to setup post data for a S.post request in Wreq
18:04:57 <dhbdhb> The line of code is
18:05:01 <dhbdhb>   r <- S.post sess soitgoesLogin ["user" := "deadheartsbeat", "pass" := "Deadbeat1990!"]
18:05:10 <dhbdhb> lol jk
18:05:11 <dhbdhb> go killmyself
18:05:42 <Axman6> :|
18:07:18 <pdxleif> Don't worry, it was just displayed as "*************"
18:07:38 <pdxleif> :J
18:08:13 <benzrf> i did that once by accident
18:08:16 <benzrf> it sucked
18:08:32 <benzrf> i hope you dont use that password everywhere :}
18:08:53 <pdxleif> @type (:=)
18:08:54 <lambdabot>     Not in scope: data constructor ‘:=’
18:08:54 <lambdabot>     Perhaps you meant one of these:
18:08:54 <lambdabot>       ‘:+’ (imported from Data.Complex),
18:09:27 <kadoban> I hope you don't use that password everywhere either … mostly because it's a really bad password.
18:09:33 <benzrf> ive seen worse
18:09:40 <benzrf> i've USED worse :}
18:09:47 <kadoban> True, heh.
18:09:48 <benzrf> @let data KV k v = (:=) k v
18:09:48 <lambdabot>  .L.hs:146:15: parse error on input ‘:=’
18:09:52 <benzrf> D:
18:10:07 <marchelzo_> I think most people have used worse. That's probably way above average password strength.
18:10:07 <benzrf> @let data KV k v = (:=) k v deriving (Show, Eq)
18:10:08 <lambdabot>  .L.hs:146:15: parse error on input ‘:=’
18:10:18 <benzrf> :{
18:10:24 <pdxleif> These are the instances for FormValue it lists... String is one of them, so it sounds like that should work? https://hackage.haskell.org/package/wreq-0.3.0.1/docs/Network-Wreq.html#t:FormValue
18:10:38 <pdxleif> What is the type that it doesn't think has a FormValue instance?
18:10:39 <marchelzo_> I actually use hunter2 on some websites.
18:10:48 <benzrf> marchelzo_: that's the dumbest thing i've heard of
18:10:50 <benzrf> like
18:10:52 <benzrf> ever
18:11:24 <MarcelineVQ> yeah, what if someone gets into your account and gets the address of your burner email you registrated with? what then huh
18:11:42 <benzrf> rip in peace
18:11:53 <marchelzo_> benzrf: Only on sites that I don't actually use on a regular basis, but which force you to register.
18:12:06 <benzrf> cute
18:15:38 <pdxleif> So *that's* why people ask to see code snippets in here. They just want to harvest accidently leaked passwords. heh heh heh.
18:17:11 <hexagoxel> pdxleif: bank account programs are nice exercises!
18:18:06 <indiagreen> pdxleif: and we also insist on showing us full and unabridged error messages because GHC is using steganography to hide passwords from browsers' password stores in them
18:19:01 <pdxleif> :)
18:19:54 <indiagreen> it's also the REAL reason we don't have completely reproducible builds yet – otherwise it would've been impossible for devs to hide the fact that available-for-download GHC isn't quite built from its publicly available source
18:21:05 <hexagoxel> the devs must be careful not to publish their passwords when bootstrapping..
18:22:30 <indiagreen> the leaked info is encrypted using asymmetric crypto, and only devs have the private key, so they don't have to worry
18:57:22 <Hafydd> It has occurred to me to write versions of some classes like Functor, Foldable and Traversable that are further parameterised by the data type they contain, to allow some general algorithms to be used with specialised types like IntMap. For example, I imagined a class Functor_ f a | f -> a, which can be an instance of the usual Functor for each type a.
18:57:58 <Hafydd> Some more examples are at <http://lpaste.net/135952> - but like most ideas, this is probably unoriginal. Has this been done before? If not, why not?
19:11:54 <Hafydd> I suppose that the functionality in Lens may supersede the need for those classes.
19:17:28 <sccrstud92_> doesnt lens rely on those classes?
19:17:58 <sccrstud92_> it sounds like you are talking about MonoTraversable, etc.
19:20:03 <c_wraith> Lens uses Functor and Applicative heavily
19:20:16 <c_wraith> it generalizes Foldable/Traversable/etc
19:20:53 <Hafydd> ...yes, that's what I'm talking about. I didn't know it was called MonoTraversable until now, though.
19:20:56 <c_wraith> It doesn't exactly *replace* things like MonoTraversable, since you need to name the traversals
19:21:19 <c_wraith> But I think naming the Traversals is a better approach than MonoTraversable's, anyway
19:28:23 * hackagebot json-rpc-server 0.2.0.0 - JSON-RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.2.0.0 (grayjay)
19:52:27 <phdp> I have two Maybe, say x and y, I want to return x unless it is Nothing, in which case I want to return y. I can do "case x of Just v -> Just v; Nothing -> y", I just wondered if there was a more elegant way of doing it :P
19:53:25 <Cale> phdp: x <|> y
19:53:38 <Cale> phdp: Or using MonadPlus, mplus x y
19:53:40 <pacak> :t mplus
19:53:41 <lambdabot> MonadPlus m => m a -> m a -> m a
19:53:49 <pacak> :t (<|>)
19:53:50 <lambdabot> Alternative f => f a -> f a -> f a
19:53:52 <dramforever> :t (<|>) -- IMHO better
19:53:54 <lambdabot> Alternative f => f a -> f a -> f a
19:54:27 <phdp> Ah! 
19:54:42 <phdp> Thanks all!
19:58:23 * hackagebot fast-logger 2.4.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.4.0 (KazuYamamoto)
20:19:44 <sccrstud92_> :t (^?)
20:19:45 <lambdabot> s -> Getting (First a) s a -> Maybe a
20:28:24 * hackagebot iproute 1.5.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.5.0 (KazuYamamoto)
20:53:50 <bb010g> How do I make Stack work with Hackage? I can't figure it out.
21:00:24 <sccrstud92_> its meant to work with stackage
21:00:28 <sccrstud92_> why do you want hackage?
21:00:32 <dramforever> IIUC stack is hard coded to use stackage
21:08:10 <bb010g> dramforever: There's a reference to hS3 [here](https://github.com/commercialhaskell/stack/issues/343), but I'm not sure how that should be used.
21:08:30 <sccrstud92_> how do I get a traversal of all elements of a Set?
21:08:47 <sccrstud92_> do I have to use a Fold instead of a Traversal?
21:09:26 <dramforever> sccrstud92_: I think a traversal breaks laws
21:10:58 <bb010g> sccrstud92_: You can traverse_, but not traverse (with collection)
21:11:52 <sccrstud92_> > S.fromList [1..5] ^.. F.traverse_
21:11:54 <lambdabot>      Couldn't match type ‘()’ with ‘S.Set b’
21:11:54 <lambdabot>      Expected type: Getting (Endo [b]) (S.Set b) b
21:11:54 <lambdabot>        Actual type: (b -> Const (Endo [b]) b)
21:12:55 <bb010g> :t ^..
21:12:56 <lambdabot> parse error on input ‘^..’
21:13:04 <bb010g> :t (^..)
21:13:06 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
21:13:30 <johnw> > S.fromList [1..5] ^.. folded
21:13:32 <lambdabot>  [1,2,3,4,5]
21:13:37 <bb010g> :t (S.fromList [1..5] ^..)
21:13:38 <lambdabot> (Enum a1, Num a1, Ord a1) => Getting (Endo [a]) (S.Set a1) a -> [a]
21:14:07 <sccrstud92_> I figured it out. thanks guys
21:15:06 <bb010g> sccrstud92_: What did you use? traverseOf_?
21:15:16 <sccrstud92_> folded
21:15:36 <pdxleif> Isn't there like some Control.Arrow thing for stuff like [(f x, g x) | x <- xs]?
21:15:49 <johnw> f &&& g
21:15:49 <dramforever> :t (&&&)
21:15:51 <sccrstud92_> :t \f g -> f &&& g
21:15:51 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:15:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:16:16 <sccrstud92_> > S.fromList [1..5] ^? folded . filtered p
21:16:18 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘Expr’
21:16:18 <lambdabot>      In the first argument of ‘filtered’, namely ‘p’
21:16:18 <lambdabot>      In the second argument of ‘(.)’, namely ‘filtered p’
21:16:34 <sccrstud92_> i wanted first element of the set that satisfies p
21:17:11 <pdxleif> Cool, thx
21:17:13 <pdxleif> > ((+1) &&& (*2)) 5
21:17:14 <lambdabot>  (6,10)
21:17:47 <dramforever> sccrstud92_: yes your one is right
21:18:21 <dramforever> > S.fromList [1..5] ^? folded . filtered (> 3)
21:18:23 <lambdabot>  Just 4
21:18:27 <dramforever> sccrstud92_: ^
21:18:40 <sccrstud92_> yup
21:18:44 <sccrstud92_> thats what I did
21:18:57 <dramforever> :t p -- note this
21:18:58 <lambdabot> Expr
21:19:01 <dramforever> it can get confusing...
21:19:06 <dramforever> :t f x y (g z)
21:19:07 <lambdabot>     Could not deduce (Show t0) arising from a use of ‘f’
21:19:07 <lambdabot>     from the context (FromExpr t)
21:19:07 <lambdabot>       bound by the inferred type of it :: FromExpr t => t at Top level
21:19:12 <dramforever> aww
21:19:20 <dramforever> never mind
21:19:39 <pdxleif> Kinda reminds me of how J has all these "trains of verbs" - http://www.jsoftware.com/help/dictionary/dictf.htm
21:20:43 <pdxleif> e.g. three functions in a row there, e.g. f g h, applied to x, means g (f x) (h x)
21:21:03 <dramforever> @hackage infix-applicative
21:21:03 <lambdabot> http://hackage.haskell.org/package/infix-applicative
21:21:14 <dramforever> uh oh
21:21:17 <sccrstud92_> :t length
21:21:18 <lambdabot> Foldable t => t a -> Int
21:21:23 <sccrstud92_> :t S.length
21:21:24 <dramforever> @hackage infixApplicative
21:21:24 <lambdabot> http://hackage.haskell.org/package/infixApplicative
21:21:24 <lambdabot>     Not in scope: ‘S.length’
21:21:25 <lambdabot>     Perhaps you meant one of these:
21:21:25 <lambdabot>       ‘F.length’ (imported from Data.Foldable),
21:21:30 <sccrstud92_> :t S.size
21:21:31 <lambdabot> S.Set a -> Int
21:22:00 <dramforever> @check (\s -> F.length s = S.size s) :: Set Int
21:22:00 <lambdabot>  <unknown>.hs: 1: 19:Parse error: =
21:22:07 <dramforever> @check (\s -> F.length s == S.size s) :: Set Int
21:22:09 <lambdabot>  Not in scope: type constructor or class ‘Set’
21:22:09 <lambdabot>  Perhaps you meant one of these: ‘S.Set’ (imported from Data.Set), ‘Seq.Seq’ ...
21:22:16 <dramforever> @check (\s -> F.length s == S.size s) :: S.Set Int
21:22:17 <lambdabot>  Couldn't match expected type ‘S.Set a0 -> Bool’
21:22:18 <lambdabot>  with actual type ‘S.Set Int’ The lambda expression ‘\ s -> length s == S.siz...
21:22:24 <dramforever> aww forget about it
21:22:42 <johnw> you can work with lambdabot in a /query session, until you get the answer that works
21:23:00 <dramforever> johnw: I thought I could get it easily
21:23:06 <johnw> we all think that :)
21:23:13 <dramforever> :)
21:23:15 <johnw> that's why I talk to lambdabot a lot before I ever paste anything here anymore
21:23:25 <dramforever> johnw: okay til that
21:51:44 <sccrstud92_> > S.fromList [1,2,3] & at 2 .~ Nothing
21:51:46 <lambdabot>  fromList [1,3]
21:54:21 <jrslepak> (anyone else getting spam from Jimmybee?)
21:56:23 <sccrstud92_> how would you delete all the elements from an At m?
22:00:29 <SrPx> What is the right way to translate a mutually recursive function with side effects in arbitrary places, to a pure function in Haskell? http://lpaste.net/135964 The parser needs to call "get_char" which removes an element from a "global" variable (the string to be parsed). I'm having some trouble figuring that out.
22:01:02 <SrPx> I know how to write that with parsec easily, yes, but I'm trying to implement it by itself
22:01:35 <dramforever> maybe the State monad
22:02:58 <johnw> SrPx: if the side-effect is just manipulating some kind of pure state, then State, otherwise there is always the Free monad and an ADT to describe your "effects"
22:03:46 <dramforever> btw you probably shouldn't use parsec if it's that simple :)
22:04:10 <SrPx> johnw: yep, but I'm trying to implement it from scratch, and it looks like state's source code isn't available. Forget this, I think I just have to figure out how to implement the state monad.
22:04:17 <SrPx> dramforever: why not? 
22:04:24 <johnw> state's source code is definitely available
22:04:29 <dramforever> SrPx: it's a bit slow
22:04:59 <dramforever> SrPx: the state monad is really simple
22:05:18 <johnw> but implementing it yourself is a good exercise
22:05:40 <SrPx> woops. I made a confusion here, my bad johnw (I was thinking about when I tried looking how IO works and found a few primitives there). Okay, give me a few minutes I think I got that. Thanks
22:05:54 <dramforever> johnw: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:StateT
22:06:10 <dramforever> many "Source" links are missing here, any idea why?
22:06:40 <johnw> it's usually because it's a re-export
22:06:45 <dramforever> SrPx: the IO monad is one of the most confusing monads
22:06:46 <johnw> from transformers
22:06:52 <dramforever> johnw: okay
22:07:14 <dramforever> SrPx: the state monad is very simple once you get the idea of it, IMHO it's very intuitive
22:22:56 <jill__> Hi All, 
22:23:59 <jill__> I am a beginner in Haskell and I am trying a code for "Given a list and a number "n", print every element in list n times" as part of my practice
22:24:30 <pacak> :t replicateM
22:24:31 <lambdabot> Monad m => Int -> m a -> m [a]
22:24:44 <pacak> :t print
22:24:45 <lambdabot> Show a => a -> IO ()
22:24:47 <pacak> :t mapM_
22:24:48 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
22:24:57 <sccrstud92_> :t for_
22:24:58 <lambdabot>     Not in scope: ‘for_’
22:24:58 <lambdabot>     Perhaps you meant one of these:
22:24:58 <lambdabot>       ‘F.for_’ (imported from Data.Foldable),
22:25:01 <sccrstud92_> :t F.for_
22:25:02 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
22:25:12 <jill__> I wrote the below basic code
22:25:40 <jill__> replicate' n x = take n (repeat x) 
22:25:48 <jill__> fn n (x:xs) = case x of [] -> []
22:25:57 <jill__>                         (_) ->  do
22:26:04 <pacak> jill__: lpaste.net
22:26:05 <jill__>                       take n (repeat x):fn n xs
22:26:13 <jill__> wondering why this does not work.
22:26:30 <jill__> I am not familiar with monads yet and hence trying to solve it using basic functionalities
22:27:44 <pacak> You need monads to print stuff. Please paste your code at lpaste to make it reable.
22:29:02 <jill__> @pacak . Yeah sure I pasted the code here http://pastebin.com/a5Jqy0BE
22:29:02 <lambdabot> Unknown command, try @list
22:29:42 <dramforever> jill__: address people like this
22:29:48 <dramforever> don't use at :P
22:30:14 <jill__> dramforever: yep sure . Thanks for the tip
22:30:15 <pacak> jill__: You are calling fn with the same n as you got in - this recursion will never finish.
22:30:38 <dramforever> jill__: you can try typing a prefix of the nick and press tab
22:30:43 <pacak> and you don't really need do if you are not using monads.
22:30:57 <mniip> pacak, it will finish when xs becomes [] and the pattern match fails
22:31:25 <jill__> pacak: "n" is the number of times element in list needs to be printed. I don't think n needs to be decremented. please correct me if I am wrong
22:31:40 <mniip> "printed"
22:31:44 <jill__> so I am iterating through the array xs one element at a time
22:31:47 <mniip> you mean like to stdout?
22:31:49 <mniip> with IO?
22:32:00 <pacak> jill__: Right.
22:32:35 <jill__> mniip: yeah it is just print. I have not handled that yet. I just wanted to prepare a list according to the instructions so that I can iterate over the loop using map and print later
22:32:40 <pacak> jill__: Add type signatures to replicate' and fn
22:33:20 <mniip> why do you have replicate' when you never use it?
22:33:37 <mniip> (supposedly you should use it in the last line)
22:35:28 <jill__> pacak:  This would be the signature. "fn :: Int -> [[t]] -> [[[t]]]" let me try it once 
22:35:59 <pacak> jill__: I'm not sure if it's double nested list that you want...
22:36:01 <jill__> mniip: Yeah you are correct. I am still editing it so I did not notice it. let me change that as well
22:36:23 <jill__> pacak: yeah. I guess this is due to the edge case 
22:36:47 <pacak> jill__: Start writing your code from type signatures. They are your friends.
22:37:06 <jill__> pacak: okay. I will do that
22:38:57 <mniip> jill__, from the description of the task I figured out you actually want Int -> [a] -> [a]
22:39:40 <jill__> mniip: Yeah correct. 
22:39:53 <jill__> When I try to give that signature, ghci throws error.
22:40:02 <jill__> so I am checking the code
22:40:27 * mniip mumbles something about >>= replicate n
22:40:42 <dramforever> s/throws/reports, I'm pretty sure it's a "compiler" error
22:41:07 * dramforever has OCD, ignore these two messages
22:44:23 <mniip> Bounded should include something like enumeration :: Bounded a => [a]; enumeration = [minBound, maxBound]
22:44:34 <mniip> er, [minBound .. maxBound]
22:44:43 <jill__> pacak: mniip: In case you guys are wondering, this is the problem I am trying out https://www.hackerrank.com/challenges/fp-list-replication
22:45:51 <liste> jill__ you don't want to print anything, the page says that "The input and output portions will be handled automatically by the grader."
22:46:04 <mniip> jill__, wait, it should return a list of lists?
22:46:25 <mniip> hmm no
22:46:33 <sccrstud92_> @hoogle ASetter s t a b -> b -> s -> (b, t)
22:46:34 <lambdabot> Warning: Unknown type ASetter
22:46:34 <lambdabot> No results found
22:46:35 <mniip> ah, nevermind
22:46:47 <mniip> it's a single list
22:47:25 <jill__> mniip: Yeah. so I am not worried about printing as of now.
22:47:38 <mniip> well then
22:48:15 <mniip> :t concatMap . replicate
22:48:16 <lambdabot> Foldable t => Int -> t b -> [b]
22:48:18 <sccrstud92_> is there a version of (<.~) that gives the old value instead of the new value?
22:50:03 <sccrstud92_> mniip: just checked, that was my solution for this problem
22:53:53 <Bashmetim> What is the idiomatic way to iterate with a monadic function?
22:53:53 <jill__> sccrstud92: This was my implementation with basic constructs as I am new to haskell. Could you please tell me where might be the issue in this http://pastebin.com/a5Jqy0BE
22:54:31 <Axman6> foldM?
22:54:34 <Axman6> :t foldM
22:54:35 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
22:54:46 <Axman6> depends by what you mean by iterate
22:54:48 <sccrstud92_> Bashmetim: what type of iteration do you want?
22:55:09 <SrPx> I can write a monad that implements the kind of parsing I need, but I still don't understand how it works :( http://lpaste.net/135970 I have no idea why this works.
22:55:17 <sccrstud92_> :t \f a -> iterate (>>= f) $ pure a
22:55:18 <lambdabot> Monad m => (a -> m a) -> a -> [m a]
22:55:22 <Bashmetim> I have a function - nextGen :: String -> IO String
22:55:44 <Bashmetim> And I basically want the result of nextGen s >>= nextGen >>= nextGen >>= ...
22:55:47 <SrPx> I just read a tutorial that did something similar and based it on those ideas, but seems like GHC is doing some wizardry with the functor deriving for (Char → next)
22:55:47 <Bashmetim> N times
22:55:56 <sccrstud92_> :t replicateM
22:55:57 <lambdabot> Monad m => Int -> m a -> m [a]
22:55:58 <sccrstud92_> :t replicateM_
22:55:59 <lambdabot> Monad m => Int -> m a -> m ()
22:56:05 <adarqui> gabriel gonzalez's tutorials are sooo good.. he really knows how to explain things.
22:56:40 <Bashmetim> Well, replicateM repeats the same function over and over again, I want to chain the outputs to the inputs
22:57:09 <sccrstud92_> Bashmetim: I just did something like this. I used > sequenceA . take n . iterate (>>= f) . pure $ seed
22:57:23 <liste> Bashmetim there's iterateM in monad-loops and monad-extras
22:57:33 <Bashmetim> sequenceA, is that in control.applicative?
22:57:37 <sccrstud92_> liste: that one runs it forever
22:58:00 <sccrstud92_> Bashmetim: think so. you can just use sequence too if u want
22:58:09 <jle`> i used to use iterateM or some variants but these days i use foldM_ f s [0..100]
22:58:26 <jle`> and so f :: a -> Int -> m a
22:58:34 <sccrstud92_> jle`: dont u need (const f)
22:58:45 <sccrstud92_> ah nvrm
22:58:46 <jle`> then you get the index for free :3
22:59:01 <liste> jill__ you define replicate' but don't use it anywhere
22:59:04 <liste> is that intentional?
22:59:26 <Bashmetim> Hm, it feels a little hacky to me to build a list for some reason
22:59:53 <liste> the list is lazy so really it's more akin to an iterator (or generator)
22:59:58 <sccrstud92_> yeah
23:00:12 <jle`> yeah, you don't actually ever build a list
23:00:18 <jle`> the list never exists in memory
23:00:22 <liste> you build an element, use it, throw it away, build the next one...
23:00:45 <liste> and even that can be (theoretically?) optimized away
23:01:22 <jill__> liste: It was still in edit stage so I did not include it . that's all. no reasons as such
23:01:34 <mniip> [08:53:29] <Bashmetim> And I basically want the result of nextGen s >>= nextGen >>= nextGen >>= ...
23:01:35 <jill__> I have included it now . Still the same issues persists
23:01:38 <mniip> how do you know where to end
23:02:45 <Bashmetim> mniip Actually, in this case I don't need to do it N number of times, but continue until it returns a string that meets some condition
23:02:57 <mniip> :t untilM
23:02:58 <liste> jill__: seems ++ is a better fit here than :, because you need a flat list
23:02:59 <lambdabot>     Not in scope: ‘untilM’
23:02:59 <lambdabot>     Perhaps you meant ‘until’ (imported from Prelude)
23:03:01 <mniip> sad
23:03:31 * hackagebot quiver 0.0.0.1 - Quiver finite stream processing library  http://hackage.haskell.org/package/quiver-0.0.0.1 (patrykz)
23:04:01 <mniip> Bashmetim, I'm afraid there isn't a function for that, but if you were to make one it should be called untilM
23:04:09 <mniip> :t until
23:04:11 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
23:04:29 <liste> there's untilM in monad-loops too (:
23:04:51 <Bashmetim> So in theory - untilM :: (a -> Bool) -> (a -> m a) -> a -> m a
23:05:00 <mniip> yes
23:05:32 <Bashmetim> What I like about haskell, just the type signatures make it really easy to see what a function needs to do!
23:05:35 <mniip> liste, Control.Monad.Loops.iterateUntilM to be precise
23:05:46 <jill__> liste: yeah that makes sense
23:06:30 <liste> jill__ also, the `do` does nothing there
23:06:53 <liste> you can just leave it out
23:07:46 <ttt_fff> is there anyway to script vim in haskell?
23:07:50 <mniip> Bashmetim, it's called parametric polymorphism
23:10:39 <liste> ttt_fff you could compile a CLI program and run it thru vimscript but that's painful
23:10:56 <ttt_fff> yeah
23:10:59 <ttt_fff> it does sound [ainful
23:11:22 <Bashmetim> untilM test f x = do { r <- f x ; if test r then return r else untilM test f r }
23:11:25 <liste> they are working on a co-process based plugin system at neovim
23:11:31 <ttt_fff> all these years, and no good way to combine vim / haskell
23:11:31 <liste> for neovim, ofc :D
23:11:32 <Bashmetim> How does that look?
23:11:40 <ttt_fff> oh, neovim, the new vim, hmm, nice
23:11:55 <ttt_fff> all I want is vim as a MOnad
23:12:13 <ttt_fff> so Vim should be a Stateful Monad, which has things like a Mpa of buffers, a state containing cursors, ...
23:12:18 <Bashmetim> "The Vim Monad" sounds like the name of a mathrock band :)
23:12:20 <mniip> Bashmetim, wrong
23:12:34 <mniip> what if x initially satisfies the condition
23:12:52 <SrPx> Ah, nevermind. I figured how it works. And managed to do it without ghc wizardry. Pretty obvious, now that I think about it: http://lpaste.net/135973 thanks guys <3
23:12:57 <Bashmetim> Ah, good point, didn't consider that!
23:13:20 <mniip> untilM test f x | test x = return x; | otherwise = f x >>= untilM test f
23:16:11 <liste> would you consider Haskell a good replacement for APL ?
23:17:54 <liste> my friend works in an insurance company where APL is used and they're looking for something that would eventually replace it
23:17:57 <SrPx> adarqui: I agree, he has some of the best haskell resources you can find. 
23:18:00 <liste> (not sure why, though)
23:19:19 <mniip> liste, you can implement any APL combinator with 1 to 5 lines of haskell
23:20:28 <adarqui> SrPx: definitely
23:27:47 <liste> mniip cool (: maybe the APL developers won't hate it right away then
23:28:34 <nshepperd> iuuuuuu89
23:29:48 * nshepperd removes cat from keyboard
23:30:09 <liste> not sure how much faster numerical processing APL has compared to Haskell, but I'd think the really heavy lifting would be fortran/C anyway
23:31:31 <Bashmetim> Am I alone in thinking that lapack is terrifying?
23:31:33 <mniip> liste, haskell can do heavy lifting if done right too
23:31:58 <mniip> but usually it ends up being a mess of unbox and ghc specifics that no one can understand
23:32:48 <Bashmetim> Though, Fortran programmers seem to enjoy messes that no one can understand...
23:33:14 <liste> Bashmetim I'd call that "historical baggage"
23:34:09 <Bashmetim> "You see children, your computers were invented by savages who lived in dark times and didn't even know what a monad transformer was..."
23:34:45 <mniip> historical baggage http://lpaste.net/135622
23:35:11 <liste> mniip looks like a smallpox of some kind
23:35:57 <Bashmetim> yikes!
23:36:05 <mniip> hmm it misses a few things
23:37:30 <Bashmetim> I hope to one day understand the deep magic surrounding the RealWorld type
23:37:45 <wizek> Good Morning!
23:37:52 <lpaste> mniip revised “efficient sieve (just kidding)”: “efficient sieve” at http://lpaste.net/135622
23:40:10 <liste> mniip the type signature is nice (: I don't mind hairy stuff if it's encapsulated in a nice abstract interface
23:42:24 <mniip> hmm
23:42:28 <mniip> needs more strictness
23:42:38 <mniip> so that the mutablebytearray can be freed
23:43:58 <Bashmetim> So... I# is a type constructor that encapsulates a plain old ones-and-zeroes-to-the-metal integer? It looks really strange to pattern match with an Int like that
23:45:49 <liste> @src Int
23:45:49 <lambdabot> data Int = I# Int#
23:46:33 <gamegoblin> Anyone just get spammed?
23:46:44 <liste> but that's GHC specific, the standard doesn't talk about it
23:47:52 <wizek> Anyone knows what this means and/or how to resolve it? "No instance for (RandomGen random-1.0.1.1:System.Random.StdGen)" Is it a problem with cabal that some versions mismatch?
23:50:53 <mniip> huh
23:51:15 <mniip> liste, very much so
23:51:49 <liste> wizek seems like that. sandboxing is one solution
23:52:29 <liste> where did it show up?
23:52:38 <wizek> liste: I already use a local sandbox
23:54:56 <liste> what does ghc-pkg check (or cabal sandbox hc-pkg check) say?
23:56:15 <mniip> oh look
23:56:21 <mniip> ByteCodeLink.lookupCE(primop) During interactive linking, GHCi couldn't find the following symbol:  ghczmprim_GHCziPrimopWrappers_seqzh_closure
23:56:34 <wizek> liste: the latter says this: "ghc-pkg: Prelude.chr: bad argument: 3220925"
23:58:09 <mniip> good old https://ghc.haskell.org/trac/ghc/ticket/10191
23:58:34 * hackagebot GLFW 0.5.2.3 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.2.3 (PaulLiu)
23:58:44 <wizek> liste: The first one is warning me about a few missing *.haddoc files and missing html/ folders
