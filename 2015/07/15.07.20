00:37:09 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
00:37:09 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
00:37:09 --- names: list (clog kofzyb lritter latk nominolo|work laar jfeltz j4cknewt xahry raichoo pt1 danvet_ albertid pacak frangor fumieval mlen caumeslasal tinyblak_ M32 petersr benma onthestairs rgoulter bgamari- frerich_ bgamari Bhavya simplyianm teclo- CurryWurst Sgeo_ timbod7 vin-ivar u___ denimuser jedws mada thalleralexander zxq9 forgottenone free_beard CyberLard ens_ tv fresheyeball enaqx_ tnks aaaaaaaaaaaaa turtil thimoteus sinkensabe chaosmasttter nkhodyunya moonlily)
00:37:09 --- names: list (geekosaur Wizek__ pgokeeffe mmalecki1 vlatkoB pfoetchen huza ronh razvanc87 jack_rabbit zrl grizwako agjacome ast054 atomi anttih sephiap MMuse_______ dkua jroesch nilg eslammostafa zipper aloiscochard jonathanj_ mno2 reem ttt_fff thetallguy ThomasLocke Elephanter bitonic beckyconning_ andreypopp_ tazjin lambdahands reqq456 zero7 R0b0t1 PlasmaStar a3f cojy stultus repc codyopel sp0on flounders martinvlk dramforever frodwith nrw erwinm4 emanuelz netj tsani)
00:37:09 --- names: list (icosa gem clynamen KarolisK sveit` slack1256 michaelavila ggole albel727 obadz isenmann dolio killerswan MP2E kvey darkf robogoat miscyb michaelneale fuzzyhorns demize otto_s verement saulzar echo-area Jellydog themk michaelpj C4Cypher bramgg xeno_ sccrstud92 rotaerk Stratege ohpesky lkba_ mcbonz_ _slade_ jinblack__ tsou caconym fizbin Tristan-Speccy tvh tismith oldboot creichert whiteline amiri dot_Laptop eigensheep Zanzare adam_hardkey_shi predator117)
00:37:09 --- names: list (tripped reduceleft lspitzner exferenceBot hexagoxel subleq__ CindyLinz _flow_ nrk- cross brezel tamasgal dan_f c-rog CMCDragonkai conal ValicekB Eldrad heyj ubitux jbhatta marek_varro gothicsouth MrWoohoo whaletechno xinming lvh sujeet tuv armyriad skeet70_ Goplat` petermw Spinfuzor aib martinbjeldbak FireFly bergey bitwiggler s00pcan MoALTz orbitalo rcyr rmlhhd yfeldblum yrdz nekomune dustinm Ulrar paf31_away _sjs vili davidfetter alexa_ Swizec pavonia)
00:37:09 --- names: list (rstone aidanh fengshaun dhrosa licensed Lokathor skyres _ashbreeze_ sleblanc tiler Tesseraction triliyn joneshf-laptop tg joshc jud solrize catsup Oxyd mjo johtso dxld Rastus_Vernon nshepperd mountaingoat entity abra0 ropav jrslepak lyxia poga plutoniix byaruhaf ClaudiusMaximus nkartashov xintron u-ou mauke sprang Guest67851 SoupE dibblego hackagebot Ralith DenSchub nisstyre phaskell Qfwfq quaestor xacktm kyren rcsgns orcus xificurC zaquest ryantrinkle)
00:37:09 --- names: list (chishiki mach grohne ion cscorley mattp_ wagle icicled torpig sivoais noteness adlan chrisdotcode prophile Deadhand louispan_ rabbidrabbit psy_ vmeson tromp FreeFull ninegrid kawaii-imouto nakal_ wat pavlicek stelleg mpereira thunderrd Pamelloes flori dcoutts augur petercommand brixen kini lokulin kaste Quashie_ fikusz emlun benonsoftware shesek _deepfire boj cyborg-one ThreeOfEight Saimeidae michaf hiberno thorkilnaur_ eazar001 DrCode isocliff_ gnusosa)
00:37:09 --- names: list (skulls otjura telser h4nnibal seangrove Sonderblade citizen11 gfixler gws comboy code_crimes eamelink dgorbik_ Encapsulation jordanl pikhq Jonno_FTW sys9mm micro_ dgonyeo- dgonyeo ph88 boris`` uber Jesin ybian SegFaultAX drewdavis Cr8 wizzo Hugglesworth acfoltzer jrib balaji vikraman Xnuk ruukasu gmaslov mceier CLaxware jkarni1 bitemyapp lyonsb Or1 jang1 loor rossberg cdidd leino newsham vemek nuttycom wedens elementalest_ sweater juri_ arahael rootnode oish)
00:37:09 --- names: list (zinfandel Elsi ij burp emik senseibaka ring0` noexcept mitchty andyo noteventime joco besenwesen d-snp dalmahal ghorn ljhms fr33domlover Internet13 jamiis noplamodo dju kalz Polarina drdo Cale fling lahwran rul peddie dicioccio1 aaron7 chelfi fnordbert coeus_ mietek GHCI hc Drezil tomphreek hx_ KaneTW Taneb quicksilver eyck Walther xiphos_ Dodek whoops Boreeas Atlanis ParahSailin_ iyzsong brotknust znutar ilmig_ ww_ freusque_ mankyKitty cnf dsantiago)
00:37:09 --- names: list (hamishmack abh tomboy65 earldouglas qnikst peterbat pdxleif dgorbik ousado staffehn esssing Natch Noinia grol etabot maerwald abbe yac Haskellfant helgar kaol flx_ flux cyphase platz srcerer wtw nwf theDon fiddlerwoaroof ChongLi ryankarason heath xelxebar shachaf carc sbauer322 usr kongo2002 mtbottle Artpicre dabradley mkollar farn lattenwald Enigmagic gargawel thelastinuit k1i fryguybob frontendloader jmct mimi_vx dschoepe mirsal Moggle vodkaInferno spindas)
00:37:09 --- names: list (tswett therealklanni thomas optocoupler yarou tgeeky relrod eddsteel ahungry Klumben serutsubi ayberk stasku wizonesolutions NemesisD recycle`` jfokkan alekst_ nkpart posco AlainODea perrier Orwell84 pygospa aupiff_ aupiff jakutis klarrt arkeet canta davean janne phadej_ flaiw AntiSpamMeta cheater lf94 sh1ken __main__ l3france mmaruseacph2 DT-sama julm chirpsalot Chobbes crough atn34 zymurgy AlexStraunoff themagician martingale bananagram dario` hodapp)
00:37:09 --- names: list (malllle jokester keko_ lieven sbrg djanatyn martinhath max-m qz gbarboza dami0 dmiles_afk akurilin gienah CoconutCrab dogetime keix anoe melter Soft jcurbo hbar Th0mas_ amiller Sornaenst PHO_ eagleflo Mandus zyoung_ marens_ joehh1 bcoppens TimWolla sunnavy_ haroldwu_ Biohazard_ wrengr_a1ay brotknus- Tehnix Flonk StoneToad Kharn hsyl20 rola defanor PpPyg fl3 edk nopf asjo milli MarcelineVQ davesilva jle` otterdam mt integral Nik05 greymalkin jameseb Guest20390)
00:37:09 --- names: list (falafel ixian dropdrive voidzero maw ricardo82 solarus ahihi nullvoid8 Entroacceptor cow_2001 tumdedum thomassgn Fuuzetsu mrmyers dh myfreeweb RGamma brennie raid SuperTux88 xxpor lpaste_ sunfun paperManu_ mjrosenb derekv2 Diabolik condy lamilami dpn` drone- KorriX dwoos geekingfrog julienXX ThePhoeron _ikke_ froztbyte absence zerokarmaleft jaspervdj maurer larsen__ Adios_ AshyIsMe `0660_ runde_ module000 marko__ dgvncsz0` Khisanth benzrf japesinator sw1nn)
00:37:09 --- names: list (avn MitchW jasu0 haBuu^ timothyh Sigyn bernalex jtobin tilpner Thra11 hiratara hpd sLite spanner supki saurik MasseR yusukesuzuki Yaiyan nille Iceland_jack ortmage josephle andrewalker jaffachief so erhandsome niko tinchos Bane^ arnihermann XMunkki nitrix gpampara ivan\ neanias Vq deavid stvc sku1d somenick tych0 Cathy kipras`away Athas Belgarion0 karls schlumpi sdx23 hanDerPeder iDavid xaimus horlicks_ obiwahn SaidinWoT corso gseitz unknownloner Factionwars)
00:37:09 --- names: list (nathanic uwap natte MindlessDrone rossimo xandaros epta ajf bartavelle porglezomp capisce akuhlens sebastard rseymour Dtgr jackhill Spockz hator derekbrown Draconx ephess adimit karshan BlakeRain joeytwiddle buttproblem tero- Jaak cynick mads- ernst luite andreass_ solirc Ankhers ByronJohnson cjay mami stomp soija friden sajith apo_ cpa stass swistak35 ggreg koala_man zso kriwil fall` Clint Hafydd obcode tlevine AustinMatherne eyem kragniz mrd tedkornish)
00:37:09 --- names: list (SwashBuckla zq orzo mephx ctag troydm huonw nesqi eevar_ paul01_ Razz elben taruti kakos Zekka loz-- DustyDin1o dmwit Geir fyolnish spion steinar_ Igloo endojelly felixn liste dixie TDJACR asm89 elgot cryon int-e pgorla geal RevJohnnyHealey rdema nicola hattusili_III joehillen Lutin` infinity0 saep tessier Voldenet banjiewen padre_angolano fractalcat inr felixsch ipuustin nyuszika7h nurupo rofer DrAwesomeClaws z16 mgomezch Liskni_si Guest39551 ]OLI[ Nickeeh)
00:37:09 --- names: list (Jaxan zxtx_ irclogger_com cschneid jorj otulp s_e mathu Willis cbaines statusbot rowanblush Lemmih andjjj23 jlewis lokydor Chousuke dzack hongminhee bjorkintosh hpc technomad RageD pm5 keemyb jvd _rgn lambdabot przembot bob_twinkles Plastefuchs jacksnipe hausdorff deni ma82 tomasos__ keaml lstrano ajp greenskeleton chattered schoppenhauer adamse Xe spacebug bsmt taksuyu killtheliterate alanz lachenmayer alem0lars brisbin crixer conehead blue_feint)
00:37:09 --- names: list (Myrl-oneechan milesc22 dfranke ps-auxw Proteumus certainty reynir low-profile TRManderson lyddonb gsingh93 frawgie_ adnap zacts notdan jmcarthur WelpAnon earthy Wamanuz yeltzooo orion cpup cmn dp_wiz fugyk niklasb Boney gratimax erethon valdyn agjohnst klugez sinopeus_ pranz Axman6 cbm80 gcollins subleq royadav darthdeus Kruppe luzie kess monochrom Draggor PigDude rom1504 pleiosaur seagreen moop gothos noddy zimbatm kgadek kaictl JZTech101 sea-gull sohum)
00:37:09 --- names: list (Reiser cursork jnoah rj-code @ChanServ Ke Rembane cYmen_ niluje jayne sgronblo init vladan lenstr oconnore Reyu jstolarek Eliel arianvp myme ndeine ibid dexterph linduxed Fylwind KitC kandinski davl_ greeny mrshoe dilinger magicman OutlawStar dmilith mortberg kosmikus jpiche d3lxa ahf machineslearn alynn hyPiRion dreamdust jlouis oherrala iteratee e4x_ tumdum Eagle_Erwin SHODAN agrif orbekk thebnq aristid tomaw monsieurp erg eivuokko xxx monty thorsten` Adeon)
00:37:09 --- names: list (zenzike Fubar^ bjornars diginet LeaChim_ dredozubov DigitalKiwi lispy eikke sys carter sellout annulus Uritomi2 noctux zeroskillor edran Tene BillyIII_ TallerGhostWalt malglim Watcher7_ vpm mero igniting Guest90609 hrnz Deewiant Profpatsch pmade amontez_ Ezku_ RlyDontKnow mikeplus32 numberten koomi tolt brent80_plow Guest83834 statusfailed bergmark bshelden ice799 wayne eyenx brolin_empey saiam Kneiva ackthet radens yukonjack surtn JamesJRH cjh` ziman)
00:37:09 --- names: list (mechairo` thoughtpolice mikedanese caasihuang kmicu Phillemann gabiruh_ Dykam_ wenzowski sleepynate jrp6 Cerise brackets krgn jix_ adarqui gdsx_ rs0 sunnymilk osnr callumacrae Gothmog_ Pucilowski_ sdboyer cjwelborn wolf_mozart skarn_ Tiktalik Guest70208 _di BrianHV mitu liyang s4msung bydo sokoll bbee fold alpounet Sagi mpickering ephemeron cameronfr electrogeek seliopou pingu hegge rudi_s Bigcheese PinealGlandOptic rhaps0dy honza killerpty Forkk kriztw)
00:37:09 --- names: list (pyrtsa ido s1n4 scpike pharpend tridactyla kaw_ marienz zyla pieter ski itsmonktastic funrep WSergio henryhere averell SLi sm Hijiri nemesit|znc Brando753 arch_ CosmicRay jb55 wto drmegahertz Laney _fritz_ DanZimm Desoxy kloeri naudiz lykkin nathan7 demolithion djh benbangert Vbitz sevcsik shiona pfeyz mgaare chandankumar Ornedan Pennth Rutger` ashleyis opqdonut aweinstock tdammers robbert kwantam darkowlzz|afk stiell ft constantinexvi Ptival spwhitt)
00:37:09 --- names: list (narendraj9 hemite lpsmith SparkySparkyBoom Jorgon thomie avocado owa zeiris RayNbow`TU shirt MK_FG buoto spaceships ollef Nimatek gridaphobe jbalint aaronm04 Schrostfutz_ simon _klm lassulus JPohlmann jlind_ zomg Baughn_ Maxdamantus Saizan scopedTV_ dlundy_ phaazon liff ec\_ xnyhps OliPicard alevy- fall__ aatxe kirjs________ anachron shwouchk zz_rabisg DANtheBEASTman mak` Twey ircbrowse cin_ pharaun benwf haasn da-x kvalle fergusnoble ChristianS kqr lsep)
00:37:09 --- names: list (ezrios chuy gbiv flebron GGMethos psacrifice LnL themasterchef [swift] wjm mikeizbicki hiredman ReinH andrewsw betawaffle dqd tristero Freundlich harski unsymbol LordDeath abrar kjanosz cow-orker stbuehler sagelywizard kvieta fmapE dunj3 notOnIRC joeyh mokus tomku ScRaMbLe zhulikas_ rbocquet xplat eL_Bart0 hvr srhb boxfire levi neki fionnan doctorin1 knyppeldynan shapr Guest34843 RazorX Tazca AWhetter tzaeru tekacs yorick rphillips EnergyCoffee mendez)
00:37:09 --- names: list (slasktask bonobo_ Blkt_ codehero Intensity alang roo iross tomjaguarpaw Jello_Raptor petantik jaseemabid_ dino- kidnapped_robot Starfire meretrix chaptastic irishsultan barrucadu osfameron ttuegel samgd viitap Phlogistique bjobjo chris2 happy0 majoh Zemyla Philonous hive-mind M-ou-se mrowe_away bolmar dan64 David cods mniip Erebe lusory ElderFain oberstein)
00:37:44 <srhb> ttt_fff: I don't recall what the actual differences are. The types are isomorphic at least.
00:37:48 <jfeltz> two years of Haskell, and I finally ran into a case where I needed to make a Functor! In this case, I have a data with records which have to be named, but share the same type (Log File Handles in this case, which undergo possible transforms of FIlePath -> LoggerSet -> Log Function), it seems like any collection of named homogeneous members would fit the use-case for functors
00:38:14 <mrmyers> ttt_fff: Why is that mind blowing? This is CS: almost everything is just almost everything else.
00:38:29 <dramforever> jfeltz: cheers!
00:38:32 * hackagebot dump 0.2.2 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.2 (Wizek)
00:38:43 <ttt_fff> mrmyers: I'm sorry that my intellectual excitement is boring to you and that you no longer exprience the wonder of learning new ideas.
00:38:57 <dramforever> btw did you know you could actually make ghc derive functor instance for you?
00:39:26 <ttt_fff> mrmyers: what ideas in CS excite you?
00:39:29 <jfeltz> yes, doing that now XD
00:41:32 <dramforever> jfeltz: ?
00:42:06 <mniip> mrmyers, s/almost//g
00:43:56 <mrmyers> ttt_fff: Er, hygenic macros, cps, and some misc fixed-point related stuff, mostly. Why?
00:44:00 <mniip> how come is Data.List.isInfixOf O(MN) and not O(M+N)
00:44:17 <ttt_fff> mrmyers: are these features of the Oz langauge, or just features in general ?
00:45:55 <mrmyers> Never heard of Oz.
00:46:24 <srhb> mniip: Why would it be m+n ?
00:46:46 <mniip> because that's a better asymptotic?
00:46:50 <srhb> mniip: infiainfibinficinfid
00:46:56 <srhb> mniip: Yes, but how would you do that? :P
00:47:04 <dramforever> mniip: I doubt if that's possible...but It seems possible
00:47:06 <mniip> KMP? Z-algo?
00:47:19 * dramforever is also thinking about kmp
00:47:46 <mniip> both of these seem especially natural to haskel as you don't have to come up with a null element
00:47:52 <srhb> Hmm.
00:47:55 <mniip> you can just use Maybe
00:48:08 <dramforever> mniip: kmp looks good enough, and I don't know about Z-algo
00:49:09 <srhb> I'm too stupid to realize that n+m is possible without further cues. :-)
00:50:11 <mniip> srhb, it's very non-obvious with z-algorithm, and even less obvious with KMP
00:50:31 <mniip> in both the idea is that you concatenate the needle and the haystack
00:50:42 <mniip> and walk over the result forming a dynamic
00:51:09 <mniip> the upper bound for lookups for any given item is logarithmic, however the upper bound for total lookups is linear
00:51:17 <srhb> Does KMP admit lazily transforming the list to a usable data structure? Otherwise there's a problem.
00:51:28 <srhb> as in, usable for the table lookup
00:51:48 * dramforever knows a little about KMP
00:52:06 <mniip> hmm
00:52:42 <dramforever> mniip: from my limited knowledge, the answer to srhb's question is yes
00:53:00 <srhb> Well, then I guess I'll have to echo the  "why isn't it..." :P
00:53:04 <mniip> you can iterate the list one by one
00:53:20 <mniip> the thing is that you need a dynamic with random access
00:53:59 <dramforever> mniip: I wonder if a self-pointing list will do
00:54:07 <mniip> a self-pointing array
00:54:10 <mniip> list wouldn't do
00:54:19 <mniip> such a dynamic would require the ahead of time knowledge of O(M+N) though
00:54:38 <dramforever> what about a list that contains tails of itself?
00:54:57 <mniip> that doesn't typecheck
00:55:01 <dramforever> looks good, but I guess it would be complicated
00:55:13 <dramforever> mniip: use some recursion helper type
00:55:19 <srhb> http://www.chaoxuprime.com/posts/2014-04-11-the-kmp-algorithm-in-haskell.html -- interesting.
00:56:25 <mniip> dramforever, you mean 'ana tails' ?
00:56:33 <mniip> that doesn't make much sense
00:56:37 <dramforever> mniip: no
00:56:54 <dramforever> let me see...
00:57:31 <dramforever> wait dammit...it won't work...
00:57:58 <dramforever> mniip: I mean instead of indices the whole list could be stored
00:58:06 <dramforever> since it's a pointer anyway
00:58:13 <mniip> ?
00:58:16 <dramforever> but it turns out to be much more complicated...
00:58:25 <mniip> you need random access
00:58:35 <dramforever> mniip: lemme see
00:59:23 <dramforever> mniip: so the key of KMP is "backtracking the Right Way", right?
00:59:35 <mniip> yes
01:00:16 <dramforever> so in each node of the list, store a pointer to the list to go back to
01:00:43 <ttt_fff> after studying haskell, whenever I read any programming job, my reaction is:
01:00:54 <ttt_fff> dumbass, this can be much better solved via purity + monads + type checking
01:01:52 <dramforever> ttt_fff: MRW writing operations on a fairly-complicated data structure: dammit why I'm not writing it in haskell...
01:02:14 <ttt_fff> dramforever: what is "MRW" ?
01:02:22 <dramforever> my reaction when
01:12:08 <mniip> dramforever, Zalgo seems more doable
01:12:18 <dramforever> ok
01:12:19 <mniip> you only need a cache of brackets
01:12:48 <mniip> hm
01:12:59 <mniip> a linked list of z-array references
01:13:09 <dramforever> mniip: interestingly, the KMP code is really simple in imperative languages
01:13:23 <mniip> z-function is analogous
01:13:39 <dramforever> but it doesn't seem simple in haskell
01:14:07 <mniip> it would be pretty effin nice to have a lazy enough z-algorithm to be able to indexOf infinite strings with it
01:14:59 <srhb> dramforever, mniip: did you read Twans blog post?
01:15:05 <dramforever> no...
01:15:11 <srhb> http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
01:15:15 <srhb> It might have some insights?
01:15:15 <dramforever> thanks
01:15:17 <srhb> I guess. :-)
01:15:33 <dramforever> btw for most uses I believe MP is enough
01:17:07 <ttt_fff> https://hackage.haskell.org/packages/search?terms=bitcask <-- this is amazing, there's not bitcask bindings for haskell?
01:17:41 <peddie> ttt_fff: guess you'd better get started on some bitcask bindings
01:28:34 * hackagebot eigen 2.1.4 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  https://hackage.haskell.org/package/eigen-2.1.4 (OlegSidorkin)
01:29:21 <mniip> if there are monad transformers
01:29:26 <mniip> are there comonad cotransformers
01:32:34 <Cale> Why cotransformer? You want colift :: t w a -> w a ?
01:32:53 <dramforever> Cale: that actually makes sense to me
01:37:20 <quchen2> mniip: There is ComonadTrans and it has a "lower" function. (Cale called it "colift" above.)
01:37:51 <mniip> damn
01:37:52 <dibblego> http://hackage.haskell.org/package/comonad-transformers-4.0/docs/Control-Comonad-Trans-Class.html#t:ComonadTrans
01:37:57 <mniip> everyhing was invented before me
01:38:27 <ttt_fff> mniip: you can still invent a polynomial time algo to 3sat
01:38:36 <mniip> nah those are hard
01:39:05 <mniip> also sat in P means P=NP
01:39:31 <mniip> knowing how many people worked on that I won't even bother :O
01:39:33 <mniip> :P*
01:42:20 <Cale> mniip: Well, that's the nice thing about category theory, is it makes a lot of the good ideas into the obvious ideas.
01:42:55 <mniip> I might actually have a non-obvious idea!
01:46:38 <srhb> mniip: Well? :P
01:46:50 <mniip> hmm
01:46:54 <mniip> it doesn't seem to work
01:54:09 <mniip> hmm
01:54:12 <mniip> yeah no good
01:56:55 <mniip> Comaybe
01:56:59 <mniip> a 'subtract 1' type
01:57:15 <mniip> I don't think one can express it in the haskell typesystem
01:57:41 <dramforever> yes, and I remember seeing a paper on negative and fraction types
01:58:24 <dramforever> mniip: http://www.cs.indiana.edu/~sabry/papers/rational.pdf
02:02:32 <mniip> dramforever, hmm what about coexponentiation
02:02:40 <mniip> root types? logarithm types?
02:02:58 <dramforever> dunno about root types
02:08:35 * hackagebot dump 0.2.3 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.3 (Wizek)
02:11:00 <mniip> oh it is
02:13:35 * hackagebot dump 0.2.4 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.4 (Wizek)
02:20:38 <mniip> hmm
02:25:23 <lpaste_> mniip pasted “Comaybe” at http://lpaste.net/136968
02:27:20 <dramforever> mniip: can you explain it further?
02:28:05 <mniip> dramforever, the type is tagged with a value which is wrong
02:28:13 <mniip> that is, the value that is guaranteed to not be inside
02:28:32 <dramforever> wow
02:28:46 <Taneb> Yay smart constructors
02:30:22 <dramforever> mniip: yeah now I get it =)
02:30:37 <mniip> there are a few cardinal issues though
02:30:49 <mniip> reification is not universal
02:31:40 <mniip> either you drag comaybes around and reify the "wrong" at the very end
02:31:53 <mniip> or use one of the provided demoting mechanisms
02:32:00 <mniip> which includes Int, Integer and String
02:32:07 <mniip> that's it
02:33:05 <mniip> hmm
02:33:36 * hackagebot dump 0.2.5 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.5 (Wizek)
02:37:22 <mniip> data Empty a; instance Reifies (Empty a) [a] where reflect _ = []
02:37:26 <mniip> type NonEmpty a = Comaybe (Empty a) [a]
02:39:32 <mniip> ideally
02:39:40 <mniip> I should be reifying (a -> Bool)
02:39:46 <mniip> to avoid the Eq constraint
02:39:56 <mniip> but then we lose the Integer stuffs which are really handy
02:42:18 <mniip> instance Reifies () () where reflect _ = ()
02:42:23 <mniip> type Void = Comaybe () ()
02:44:24 <mniip> @tell edwardk why are there so few Reifies instances in the package?
02:44:24 <lambdabot> Consider it noted.
03:08:52 <zipper> Hey
03:09:02 <zipper> optparse-applicative issue here.
03:09:45 <zipper> My subcommand `configure` isn't printing to screen in L29 http://lpaste.net/6438862215356350464
03:10:12 <zipper> I assume the issue is with `configFlags'` ?
03:16:00 <predator117> zipper: what do you mean by "printing to screen"? when used with '-h', '--help' or on wrong args?
03:18:38 * hackagebot dump 0.2.6 - Dumps the names and values of expressions to ease debugging.  https://hackage.haskell.org/package/dump-0.2.6 (Wizek)
03:19:14 <predator117> I think by convention, metavar is not a text with spaces but rather a uppercase word like `strArgument (metavar "FLAGS" <>)`
03:19:17 <predator117> help "Use TOKEN for authentication"
03:19:19 <predator117> ups
03:19:44 <predator117> strArgument (metavar "FLAGS" <> help "Flags to cabal.")
03:33:39 * hackagebot eigen 2.1.5 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  https://hackage.haskell.org/package/eigen-2.1.5 (OlegSidorkin)
03:35:17 <predator117> zipper: still there?
03:38:12 <zipper> predator117: I am
03:38:28 <predator117> I think your issue is that strOption is mandatory as you wrote it
03:38:40 <predator117> so without a --show-iface <file> the parse will fail
03:39:10 <predator117> you can make it optional by using `option (strOption ...)` and change CmdArgs to have a Maybe FilePath instead
03:39:16 <zipper> predator117: I want it to print the flags/arguments that I pass to configure
03:40:15 <zipper> Oh
03:40:37 <predator117> *optional not option
03:40:44 <zipper> Oh yeah it's because --show-iface is manadtory
03:48:30 <Falkyouall> hey guys
03:48:55 <Falkyouall> can someone explain why [[z,y]| x<-[1..4], y<-[1,3..7], let z = x-1, x==y] leads to [[0,1],[2,3]] ??
03:49:59 <Falkyouall> 1 and 1 okay, so the first result of both lists z ,y are obviously clear
03:49:59 <dramforever> Falkyouall: do you know list comprehesion is just syntax sugar?
03:50:05 <Falkyouall> yea
03:50:31 <Falkyouall> no wait nothing is obvious
03:50:39 <dramforever> Falkyouall: wait so why can't you understand the x=y=8
03:50:53 <dramforever> oh nothing is obvious...hmm...
03:51:02 <zipper> Falkyouall: `You understand that 1-4 are equal in both lists, right?
03:51:17 <Falkyouall> but list y is 1,3,5,7
03:51:20 <zipper> So it shall stop creating a new list at 4
03:51:27 <Falkyouall> and z is 1,2,3,4
03:51:34 <zipper> but everything is -1 because you told it to
03:51:37 <zipper> 0-3
03:51:48 <dramforever> Falkyouall: so the x == y picked 1 and 3
03:51:51 <Maxdamantus> x is 1,2,3,4
03:51:53 <dramforever> do you get it?
03:51:55 <Falkyouall> ok so the x-1 happens before the filter of x == y ?
03:51:59 <Maxdamantus> z is 0,1,2,3
03:52:18 <Falkyouall> ok
03:52:49 <Maxdamantus> it wouldn't matter, there's no before/after.
03:53:00 <Falkyouall> ah okay i think i get whats happening
03:53:11 <Maxdamantus> you could put the condition before the `let` and you'd get the same result.
03:53:13 <zipper> So if z starts from zero why is the zero printing yet there is no zero to match it against in y?
03:53:20 <Falkyouall> its a example for referential tranparency, isnt it?
03:53:50 <zipper> I don't really get list comprehensions so I just confused myself.
03:53:52 <dramforever> Falkyouall: I can't understand that
03:54:10 <dramforever> x - 1 doesn't change x, is that clear?
03:54:17 <Maxdamantus> zipper: it's a cartesian product.
03:54:46 <zipper> Oh yeah x -1 doesn't change x
03:54:50 <Falkyouall> its theory that a variable cant be changed until its something like let z = x -1 doesnt change the initial x at all
03:55:12 <Maxdamantus> so the filter is run against x=1, y=1; x=1, y=3; ..
03:55:24 <dramforever> Falkyouall: why should it? there's no referential transparency going on
03:55:37 <Maxdamantus> Falkyouall: variables can't be changed.
03:55:51 <Falkyouall> maybe i meant another thing with the transparency
03:56:02 <Falkyouall> and mixed it up
03:56:04 <zipper> LAWL his list is 1,3...7 not 1..7
03:56:08 <zipper> Oh man
03:56:10 <zipper> So simple
03:56:14 <zipper> I thought it was 1..7
03:56:25 <zipper> Okay at least I learned two things today.
03:56:45 <zipper> Falkyouall: Maxdamantus Thanks
03:58:08 <srhb> It's simple to see what's going on if you remove the condition.
04:07:05 <obadz> is there a way to convert an arbitrary value of some typeclass (Typeable?) to an ADT that enables explorations of record keys as strings, etc. ?
04:07:45 <obadz> kind of like Dynamic, but with some ability to explore the underlying value
04:08:14 <obadz> Looked at Data.Data but it's over my head
04:08:46 <mniip> you could probably use some generics
04:08:53 <dramforever> obadz: 1. so what are you trying to do?
04:08:58 <dramforever> s/1.//
04:16:25 <ttt_fff> this is dumbass, but is there a functino (with a name) taht does (a -> b) -> a -> b ?
04:16:46 <dramforever> :t id -- this?
04:16:47 <lambdabot> a -> a
04:17:01 <mpickering> :t ($)
04:17:02 <lambdabot> (a -> b) -> a -> b
04:17:04 <dramforever> :t ($) -- this might be better, depending on your use case
04:17:05 <lambdabot> (a -> b) -> a -> b
04:17:43 <ttt_fff> dramforever++
04:19:52 <obadz> dramforever: trying to see record keys as strings, and record values as some dynamic type
04:20:10 <obadz> dramforever: but I assume there's something that would do that, and more general things along with it
04:20:17 <dramforever> obadz: what are you trying to do with it?
04:20:28 <obadz> dramforever: absolutely nothing, just playing in ghci
04:20:33 <dramforever> huh
04:21:15 <dramforever> okay I guess you could do some generics/TH/Data.Data stuff to do it
04:21:21 <dramforever> it's nowhere easy, iiuc
04:22:30 <obadz> I guess I'm wondering how one would write a serializer
04:22:47 <obadz> without creating its own typeclass and having to go and reimplement it for every type
04:23:07 <obadz> surely there's a way to leverage existing, widely implemented type classes
04:23:11 <obadz> like Typeable
04:23:27 <dramforever> obadz: Data and Generic are widely implemented aren't they
04:23:33 <mpickering> yes, using Data/Generic
04:23:54 <mpickering> there are lots of generics libraries which will allow you to write a generic serialiser
04:23:54 <obadz> dramforever: yes they are, I just couldn't figure out how to use Data
04:23:57 <obadz> looking at Generic now
04:24:27 <mpickering> You probably want to use an abstraction built on them such as generics-sop 
04:28:41 * hackagebot hsdev 0.1.4.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.4.0 (AlexandrRuchkin)
04:33:38 <obadz> the SOP slides lost me relatively quickly
04:41:53 <obadz> anyway I'm going to give up on this particular endeavor
04:42:00 <obadz> Aeson seems very cool though
04:42:15 <obadz> What does the ! mean in blah :: !Text ?
04:42:20 <obadz> strictness?
04:42:25 <mniip> yes
04:42:34 <mpickering> maybe it would be best to start with something smaller? maybe write a function f :: Data a => a -> [String] which takes any datatype and returns a list of all the constructors used?
04:42:41 <mpickering> you should be able to use gmapQ from Data.Data
04:42:55 <obadz> does that mean the record can either be a thunk, or has to contain values, but it cannot contain thunks?
04:43:20 <mniip> obadz, it means that the record can't contain a thunk in that particular field
04:43:42 <mniip> upon being demanded the record will demand the WHNF of the field
04:44:32 <obadz> ok. Why do they mark all Text fields as strict in this tutorial? https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
04:44:47 <obadz> Is there a kind of convention/pattern there ?
04:51:39 <lpaste_> dramforever pasted “something like MP” at http://lpaste.net/136973
04:52:02 <dramforever> mniip: I just wrote the "pointer to a suffix of the list" thing
04:52:24 <dramforever> you still remember talking about KMP stuff, right?
04:52:50 <mniip> yes
04:53:12 <dramforever> mniip: I'm having weird trouble inspecting the output, but it seems right
04:53:39 <mniip> wow
04:53:50 <mniip> that's dense
04:53:53 <dramforever> mniip: well it could be completely wrong
05:07:28 <zipper> I have two versions of a package according to the cabal file. The executable and the library. However when I run cabal install I want to install the executable.
05:07:35 <zipper> Is there a way to ensure this happens?
05:08:05 <dcoutts> zipper: when you install a package, all the components within it are built and installed
05:08:15 <dcoutts> so in your example, both the exe and the lib
05:08:43 <dramforever> mniip: sadly it's wrong...
05:09:03 * dramforever goes to learn more about KMP, hoping to understand it better
05:09:23 <mniip> dramforever, I need to get a sleep before I can even start trying to do anything with it
05:09:41 <dramforever> mniip: don't do anything with it
05:09:52 <dramforever> It's just an idea...
05:10:05 <mniip> ideas aree to be implemented
05:11:16 <nkaretnikov> dramforever: what's kmp?
05:11:28 <dramforever> nkaretnikov: it's a string matching algorithm
05:11:35 <nkaretnikov> ah
05:11:43 <nkaretnikov> didn't recognize it for some reason :)
05:12:00 <dramforever> oh obviously you know kmp =)
05:12:24 <mniip> interestingly zalgo doesn't seem to have a wikipedia page
05:12:33 <dramforever> yeah
05:13:31 <Nux_> I'm having difficulty building curl
05:13:51 <Nux_> is this the right place to ask for help on cabal installation?
05:14:01 <silver> sure
05:14:11 <Nux_> I'm on windows 8.1
05:14:25 <silver> what's the error
05:15:14 <Nux_> http://pastebin.com/FhFEirKk
05:15:41 <silver> have you installed curl the C library somewhere?
05:18:39 <Nux_> depends
05:18:49 <Nux_> http://curl.haxx.se/download.html
05:18:53 <Nux_> the first link
05:19:00 <Nux_> I've downloaded this
05:19:44 <Nux_> I'm not sure what would be involved in 'installing curl the C library'
05:19:57 <Nux_> downloading it and pointing an environment var to it?
05:20:13 <Nux_> using mingw /VStudio to build it?
05:20:33 <Nux_> This is to silver
05:20:50 <silver> no, you don't need t build it
05:20:57 <silver> one sec
05:21:52 <silver> oh they provide only source
05:22:05 <silver> do you use cygwin?
05:23:31 <Nux_> yes
05:23:58 <Nux_> I found I had to use cygwin to get hxt to install
05:24:07 <silver> you can use it's package manager/installer to get libcurl, let me check the details
05:30:36 <Nux_> silver I'm currently reinstalling cygwin in the hope it will then offer packages
05:31:16 <silver> I use this https://cygwin.com/install.html
05:31:21 <silver> 64-bit one
05:31:25 <Nux_> yup
05:31:33 <Nux_> I'm at the package selection dialog now
05:31:38 <Nux_> I've search for curl
05:31:44 <Nux_> I have a few options:
05:31:58 <Nux_> Debug, Doc, Libs, Net, Perl, PHP
05:32:04 <Nux_> not sure which I need
05:32:43 <Nux_> the tutorial I'm following uses hxt-curl
05:32:46 <Nux_> that's all I know
05:33:02 <Nux_> silver any idea which I need?
05:33:26 <silver> I'm checking this now
05:34:34 <Nux_> I see libcurl-devel discussed in other peoples issue threads when it comes to installing hxt-curl
05:34:46 <Nux_> that's under libs
05:34:51 <Nux_> I could try that
05:35:26 <Nux_> nvm I'll just take them all, they're not big
05:36:21 <Nux_> I hope the dependencies don't change that...
05:42:56 <Nux_> that didn't work
05:43:11 <Nux_> should I have downloaded the source files?
05:43:14 <Nux_> silver:
05:43:32 <silver> I don't think so
05:43:45 <zipper> dcoutts: Can I install the exe only?
05:44:01 <silver> you need to tell cabal where the lib is located and also make sure it named right
05:44:20 <silver> there's --extra-lib-dirs="" cabal option
05:47:26 <Javran> does ghc-mode have support for stack so far?
05:49:32 <Nux_> silver yes so the error message tells me, should I specify the bin directory in cygwin?
05:50:04 <silver> you could try, but it doesn't work for me
05:50:11 <Nux_> silver me neither
05:50:19 <silver> trying to figure out what curl wants
05:52:28 <Nux_> I tried C:\cygwin64\usr\src\debug\curl-7.43.0-1\lib and C:\cygwin64\usr\src\debug\curl-7.43.0-1\include
05:52:39 <Nux_> silver didn't work
05:56:27 <zipper> I want to recieve arguments that I want to pass to cabal configure. So the issue is that I can't find a way to make optparse-applicative recieve command line arguments starting with -- as arguments.
05:58:14 <zipper> nvm
05:58:21 <zipper> I found a solution.
05:58:29 <sopvop> is there a pacakge for generating url printing/parsing with path templates? like  genUrlPP [(''ConName, "foo/bar/:capture/blah"), (''OtherCon, "/some/:cap/path")]?
06:00:02 <folsen> how does one parse from JSON into a Persistent model? I want to do something like `runSQL $ insert (<parser here> jsonBody)`
06:01:46 <Athas> If I do 'cabal build' and then 'cabal install', why does 'cabal install' seemingly recompile everything (and not even in parallel)?
06:01:54 <Nux_> silver, does this have anything to do with my problem?
06:01:56 <Nux_> https://mail.haskell.org/pipermail/haskell-cafe/2009-February/055130.html
06:02:11 <Nux_> #define CURL_EXTERN __declspec(dllimport)
06:02:12 <Nux_> to
06:02:14 <Nux_> #define CURL_EXTERN.
06:02:31 <Nux_> does that mean I'd need the source and to recompile it?
06:04:12 <silver> I don't know, he might refer to haskell curl package sources here
06:04:59 <pavonia> Ah, building the curl package on Windows is fun :)
06:05:15 <Nux_> pavonia, any help? :)
06:06:02 <silver> but it looks from configure logs you need sources somehow
06:06:17 <pavonia> Unfortunately, no. I managed to get the package installed some time ago, but then it failed with linker errors when using it
06:06:35 <Nux_> ok
06:06:41 <Nux_> I'm following this: https://wiki.haskell.org/HXT#Installation
06:06:56 <Nux_> it then goes on to use an example with curl in it
06:07:16 <Nux_> what am I likely to need curl for?
06:07:37 <Nux_> can I get away with not using it?
06:07:44 <pavonia> I can only tell that you need the dev version of the C library (curl-7.39.0-devel-mingw32 for me)
06:09:06 <pavonia> and then compile with -ID:/dev/curl-7.39.0-devel-mingw32/include
06:09:40 <pavonia> s/compile/cabal build/
06:09:47 <Nux_> -ID?
06:10:07 <Nux_> is that a cabal switch/option/flag?
06:10:23 <pavonia> -I is extra includes, D is the letter of my drive :)
06:10:36 <silver> --extra-include-dir="" I guess, cabal install option
06:10:44 <silver> dirs*
06:11:02 <Nux_> ok
06:11:11 <silver> but for me it doesn't work
06:11:23 <Nux_> well I'm going to try not using curl
06:11:51 <Nux_> it seems to be to do with http somehow which is not needed for my purposes
06:12:13 <Nux_> I'm parsing a non-web xml document
06:13:17 <Nux_> non-network too
06:13:46 <Nux_> it would be nice to be able to work on those things, but it looks like I'm gonna have to wait for the authors of this to get it together
06:17:50 <orion> bitemyapp: Hey there, you around?
06:25:07 <Nux_> I can't get the copy example to work with a really simple xml document
06:26:26 <Nux_> fatal error: unsupported protocol in URI "C:\\Haskell\\test.xml"
06:26:47 <Nux_> is it complaining about my backslashes?
06:27:27 <geekosaur> no, it wants a URI
06:27:31 <geekosaur> file:///...
06:28:10 <predator117> file:///C:/Haskell/test.xml -- probably
06:28:49 <mrsan1> Why would any one want to learn haskell?
06:28:50 <zipper> nooooo windows
06:29:01 <zipper> but doesn't windows use C:\
06:29:23 <zipper> predator117: ^
06:29:27 <geekosaur> (probably it would handle filenames but C:/ looks too much like a URI?)
06:29:58 <predator117> zipper: for URI's / should work
06:30:28 <predator117> https://en.wikipedia.org/wiki/File_URI_scheme#Windows
06:30:40 <geekosaur> and / works on windows anywhere that cmd.exe isn't parsing /switches
06:31:02 <geekosaur> (well, it's not cmd.exe really, just the windows equivalent of getopt)
06:36:35 <Nux_> I'm just getting ->  fatal error: file:///C:/Haskell/test1.xml: openBinaryFile: invalid argument (Invalid argument)
06:38:06 <Nux_> damnit
06:38:10 <Nux_> I got it to work
06:38:53 <Nux_> so the first argument (source) was expecting the file:/// and the second argument (destination) was not
06:41:32 <Nux_> I wonder how I was supposed to discover that without spraying it with tests like I just did
06:41:40 <Nux_> is there documentation I'm missing?
06:42:29 <Nux_> (I meant that the second argument expected no file:/// as opposed to just not requiring it)
06:42:30 <zipper> How do I check whether an MVar is empty or not?
06:44:20 <joneshf-laptop> why are the versions different colors: https://hackage.haskell.org/package/ghc-mod ?
06:46:20 <orion> Hey, does anyone know how to incorporate a (Maybe IndexSettings) into an IndexTemplate, as described here?: http://lpaste.net/174356207425814528
06:47:03 <orion> Normally I'd say, "settings" .= indexsettings, but I can't do that because the resulting JSON would look like "settings":{"settings":{...
06:47:30 <Nux_> 	joneshf-laptop, click (info)
06:47:42 <Nux_> it's after the last in the list
06:47:52 <Nux_> "Blue versions are normal versions. Green are those out of any preferred version ranges. Gray are deprecated."
06:48:19 <Nux_> though it's funny because I see no blue and many orange
06:48:33 <joneshf-laptop> Nux_, oh cool
06:48:37 <Nux_> I'm guessing orange is the new blue
06:48:40 <joneshf-laptop> Nux_, yeah, looks like a bug
06:48:44 <joneshf-laptop> :)
06:49:18 <indiagreen> orion: can't you just “merge” indexsettings and “object ["template" .= ..., ...]”?
06:51:49 <orion> indiagreen: It's not straightforward because my IndexTemplate has a Maybe IndexSettings, not IndexSettings.
06:53:48 * hackagebot yaml 0.8.12 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.12 (MichaelSnoyman)
06:56:29 <orion> indiagreen: Nevermind, I think I've worked it out.
07:02:40 <AshyIsMe> regex-posix doesnt seem to be so great
07:02:47 <AshyIsMe> is there a better regex library?
07:03:42 <demize> AshyIsMe: https://wiki.haskell.org/Regular_expressions
07:05:16 <chpatrick> AshyIsMe: regex-pcre or better yet a parser combinator library?
07:05:28 <AshyIsMe> oh wow, i think i just dont like how posix regexes work
07:05:49 <AshyIsMe> regex-parsec: This backend can either find the left-biased match like Perl or the longest match like Posix. It uses Parsec as a backtracking matching engine and is quite slow.
07:05:56 <AshyIsMe> i guess im used to perl style regexes
07:06:01 <chpatrick> why not regex-pcre then?
07:06:09 <chpatrick> pcre: perl-compatible reg ex :)
07:06:31 <chpatrick> people usually use attoparsec or something in haskell though
07:06:47 <chpatrick> then it's typesafe and it's much nicer to extract information
07:06:58 <AshyIsMe> yeap sounds good :)
07:07:21 <AshyIsMe> yeah this is a pretty simple thing though
07:07:27 <AshyIsMe> regex makes sense for now
07:11:24 <htebalaka> is there a standard datatype c with "instance Applicative m, Monoid a => Monoid (c (m a)) where { mempty = pure mempty ; mappend = liftA2 mappend }"
07:14:42 <chpatrick> so a monoid for applicatives that return monoids?
07:17:15 <chpatrick> htebalaka: not that I know of
07:17:27 <entity> are haskell lists doubly linked?
07:17:34 <chpatrick> entity: no
07:18:14 <entity> interesting - thanks
07:18:30 <chpatrick> entity: you can use Zippers if you want to walk in both directions :)
07:19:11 <chpatrick> http://hackage.haskell.org/package/ListZipper-1.2.0.2/docs/Data-List-Zipper.html
07:19:16 <chpatrick> it's basically two lists glued together
07:19:46 <entity> I was just wondering about the underlying implementation - introducing the init and last functions seemed like something you'd do when you have O(1) access to the last element
07:20:19 <c_wraith> entity: doubly-linked lists and immutability generally are not a good combination
07:20:21 <chpatrick> entity: it's data [ a ] = [] | a : [ a ]
07:21:56 <entity> c_wraith: even more interesting :) can you link to some explanaition of why not?
07:22:45 <c_wraith> entity: Not really.  It's just something that follows immediately from immutability.  If you can't change a link, you can't add elements to either side of a double-linked list without allocating an entirely new set of nodes
07:23:17 <c_wraith> entity: and at that point, it's just worse than an array in all use cases.
07:24:02 <entity> I see - thanks
07:24:05 <mniip> @tell dramforever looks like z-algo can be implemented by joggling with about 5 basic [] list references, that simple
07:24:05 <lambdabot> Consider it noted.
07:25:15 <c_wraith> entity: with a singly-linked list, you can share the tail of the list between uses with immutable data, so adding an element to the front can be O(1).
07:26:54 <c_wraith> entity: alternatively, going the other direction, removing an element from the front of a list is just advancing the pointer and forgetting about the previous head.  So it's also O(1).
07:27:15 <c_wraith> entity: init and last are just provided for symmetry.  You should always be suspicious of code that uses them. :)
07:27:42 <entity> hehe, I'll keep that in mind
07:27:57 <entity> thanks for the thorough explanation!
07:28:17 <quicksilver> the cost for init is paid gradually, at least, so if it is what you need it's not terrible.
07:28:36 <c_wraith> Yeah, a single use of init isn't a problem.  The problem is repeated use.
07:37:56 <ajf> hey, what's the shortcut for using the result of an IO monad function as the parameter of another?
07:37:58 <ajf> I forgot it
07:38:10 <ajf> like, x <- foo, bar baz foo qux
07:38:15 <ajf> er
07:38:23 <c_wraith> :t (=<<)
07:38:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:39:02 <ajf> c_wraith: usage?
07:39:33 <c_wraith> do x <- foo ; bar baz x    --->   bar baz =<< foo
07:39:40 <init> ajf: `putStrLn =<< getLine`
07:39:41 <ajf> aha
07:39:44 <ajf> thanks
07:40:18 <c_wraith> ajf: It's important to remember it's just another library-defined operator.  Nothing special about it.
07:40:43 <ajf> my actual use-case:
07:40:44 <ajf> addChild hpLabel =<< newTextElem "happiness"
07:40:53 <ajf> c_wraith: oh, yeah, I know that
07:41:31 <ajf> I could define it in terms of sequencing things if I wanted to
07:41:54 <c_wraith> It's even easier than that.
07:41:58 <c_wraith> :t flip (>>=)
07:41:59 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:42:17 <c_wraith> So it's really the exact same operation as bind
07:42:22 <c_wraith> Just with the args flipped
07:42:23 <ajf> ah
07:42:52 <ajf> jesus what's going on, was there just a netsplit?
07:45:01 <ajf> oh, I got the argument order wrong
07:45:56 <c_wraith> ajf: yes, that was a netsplit
07:46:12 <ajf> c_wraith: a seemingly clean one though, "moving host"?
07:46:36 <c_wraith> It happens.  freenode is a huge network.  And this is a decently large channel
07:47:30 <c_wraith> (currently the 5th-largest channel on the network, it seems)
07:47:58 <ajf> huh!
07:55:43 <fizbin> Okay, I'm trying and failing to write code that uses STUArrays that's type-agnostic. Is anyone able to untangle the proper way to use forall in http://lpaste.net/136977 ?
07:57:02 <Gurkenglas> Could you try leaving out the type signature and asking ghci to deduce it?
07:57:23 <fizbin> Then I get a compilation error on the "return ret" statement:
07:57:52 <c_wraith> I'm pretty sure ghc can't infer that
07:57:56 <c_wraith> since it needs a rank-2 type
07:58:25 <chpatrick> fizbin: as an aside have you considered using vectors?
07:58:33 <chpatrick> arrays are kinda janky
07:58:35 <kuribas> Isn't Data.Vector a better alternative for Arrays?
07:58:51 <fizbin> Okay, but... I'm still working in ST, right?
07:58:54 <c_wraith> fizbin: remove everything that mentions s from the top-level signature
07:59:05 <kuribas> fizbin: You can use the ST with Data.Vector
07:59:42 <fizbin> kuribas: Right, but my point is, in Vector I'm still then going to have the same sort of issue, right?
07:59:55 <chpatrick> fizbin: it looks like each element of the array only depends on the last right
07:59:57 <chpatrick> ?
08:00:25 <fizbin> I mean, my types will still need some sort of (forall s. stuff) => restriction, won't they?
08:00:33 <chpatrick> fizbin: https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html#v:unfoldrN
08:00:33 <chpatrick> if so
08:00:38 <chpatrick> you might not need ST at all
08:01:06 <fizbin> chpatrick: Maybe not in this method, but I suspect I will in other.
08:01:09 <fizbin> others.
08:01:15 <fizbin> This is just the first.
08:01:27 <c_wraith> fizbin: So you have multiple issues.  The first is that s is defined in the wrong scope.
08:01:30 <chpatrick> fizbin: there's also constructN if you want to access all of the array before i
08:01:35 <c_wraith> fizbin: the compiler isn't even reporting that one.
08:01:54 <kuribas> fizbin: you can use asTypeOf
08:02:14 <c_wraith> Why is everyone talking about everything except the actual errors?
08:02:32 <chpatrick> c_wraith: maybe there's a nicer solution :)
08:02:38 <fizbin> c_wraith: Removing s from the top level scope just gives me new errors:
08:02:52 <c_wraith> fizbin: well yes, it's not the whole solution, but it's a necessary step.
08:03:03 <c_wraith> fizbin: s can't be visible at that point, so it *has* to be absent.
08:03:36 <Wizek> Goof Morning!
08:03:44 <kuribas> fizbin: from what I can see you have a scan right?
08:04:10 <kuribas> fizbin: https://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector.html#g:34
08:04:35 <c_wraith> Ok, vector is nice and all, but the point is "how do I solve this kind of type error?", which can happen any time you want to use ST...
08:04:48 <fizbin> Okay, c_wraith updated paste with the error I get now
08:04:48 <chpatrick> kuribas: I think it's an unfoldrN
08:05:20 <kuribas> chpatrick: oh, I see...
08:06:08 <fizbin> c_wraith: Also, replacing s with s0 in the top-level config didn't help.
08:06:08 <Gurkenglas> Why does https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:unzip say O(Min(m,n)) when there's only one input vector?
08:06:29 <c_wraith> fizbin: s cannot be present at the top level in *any* form?
08:06:39 <c_wraith> Gurkenglas: probably a c/p error
08:07:01 <kuribas> chpatrick, fizbin: with enumFromN + scan you don't need a maybe data type...
08:07:23 <kuribas> fizbin: It is maybe a bit more efficient, if it gets fused.
08:07:30 <chpatrick> that's true
08:08:24 <kuribas> Gurkenglas: yeah, then n == m
08:08:34 <fizbin> c_wraith: Updated http://lpaste.net/136977 with latest attempt/error
08:08:41 <c_wraith> fizbin: This can't work because of the way MArray is defined
08:09:46 <c_wraith> fizbin: The way MArray is defined doesn't work with the way runST works.
08:10:10 <c_wraith> fizbin: You can only write something that's polymorphic over different MArray types in ST if its result is still in ST
08:11:02 <Wizek> I am wondering if this parser is (and the few sub-parsers it relies on are) correct: https://github.com/Wizek/dump/blob/v0.2.6/src/Internal/Parse.hs#L5 I do have some specifications on the different cases it handles: https://github.com/Wizek/dump/blob/v0.2.6/spec/Spec.hs#L63 but am I wondering what other ways might be out there to ensure correctness. Any ideas?
08:11:08 <silver> Nux_, I managed to build curl, the problem is https://github.com/haskell/cabal/issues/451
08:11:53 <silver> so you need to specify CPPFLASG=-I<path_to_include_dir> and probably LDFLAGS=... too so stuff will link
08:12:04 <c_wraith> fizbin: You can work around this by inverting control flow in a few ways, I suppose.
08:12:20 <silver> CPPFLAGS*
08:15:37 <kuribas> If you use an UArray with type i, then i be unboxable right?
08:15:42 <c_wraith> fizbin: but at this point, I'd say that the bigger issue is the way MArray is defined.  vector will work better here because its classes are designed to support this.  You could just put an Unbox constraint on i and call it done.
08:16:22 <Wizek> Or maybe more generally: How do you guys check/ensure correctness of your parsers?
08:16:44 <chpatrick> fizbin: six lines, pure code: http://lpaste.net/136980
08:17:02 <chpatrick> trying it is an exercise for the reader :)
08:17:27 <ajf> oh wow
08:17:33 <ajf> I was SO confused by this type error
08:17:43 <ajf> how could I possibly be applying 5 arguments to modifyIORef'?
08:17:50 <ajf> then I noticed I'd missed the `do`. d'oh
08:18:36 <chpatrick> ajf: I thought you were my old haskell prof :D http://wp.doc.ic.ac.uk/ajf/
08:18:52 <ajf> hah
08:19:39 <kuribas> And probably very efficient due to stream fusion.
08:19:49 <ajf> I was going to say '"ajf"? wouldn't they be "t?f"?' but then I remembered Tony was short for Anthony
08:20:14 <Gurkenglas> Wizek, your only use of pUntil's i seems to be to pass it to other calls of pUntil. Why have it at all?
08:21:22 <Wizek> Gurkenglas, it is used in pExp as well
08:21:41 <Wizek> that is kind of the 'top level entry point' of the parser
08:22:53 <Gurkenglas> Wizek, pExp supplies it, not uses it :P. What would break if you removed all mentions of it?
08:23:05 <Gurkenglas> *Wizek
08:23:12 <Nux_> silver, thanks for looking into this.
08:23:20 <Gurkenglas> Oh wait I already said your name there. I'm too used to forgetting to ._.
08:23:52 <Nux_> silver, am I pointing it at the directory in my cygwin installation holding curl?
08:24:12 <Nux_> silver, also what exact LDFLAGS do I need?
08:24:30 <Wizek> Gurkenglas, ahh, sorry, you mean the Int named i. That is used for debugging only, I might as well remove it, you are right. 
08:24:44 <Wizek> I used it do see recursion depth while writing pUntil
08:24:44 <Nux_> silver, is LDFLAGS for the lib files?
08:25:22 <Nux_> silver, and am I specifying this on the commandline or within a file?
08:25:40 <silver> it should be like this
08:25:41 <Wizek> Gurkenglas, like this: https://github.com/Wizek/dump/blob/7b938615c6d95eaa24d2c9dd392fe3c07ef8d974/src/Internal/Parse.hs#L28
08:25:58 <silver> CPPFLAGS=... LDFLAGS=... cabal install curl
08:26:29 <Gurkenglas> Wizek, Debug.Trace provides a way to output the call stack iirc
08:26:52 <srhb> Gurkenglas: What call stack? :-)
08:27:01 <silver> as for LDFLAGS: it should be equal to something like -L<path_to_libs_directory>
08:27:04 <Wizek> could be. I never could make that work when I tried to.
08:27:37 <Gurkenglas> srhb, the one that is available if the program was compiled with -prof
08:28:49 <srhb> Gurkenglas: I don't think the call stack simulator ever got very good. I may be wrong though.
08:29:13 <Nux_> silver, I tried the following:
08:29:15 <Nux_> CPPFLAGS=-I"C:\cygwin64\usr\src\debug\curl-7.43.0-1\include" LDFLAGS=-L"C:\cygwin64\usr\src\debug\curl-7.43.0-1\lib" cabal install curl
08:29:20 <Nux_> and it still failed
08:29:51 <srhb> Anyway it's in GHC.Stack
08:30:24 <silver> Nux_, try to use "/" in cygwin as delimiter
08:30:29 <Gurkenglas> srhb, I just read the hackage page on Debug.Trace a while ago, found W tweaking his type signatures for debug purposes and remembered "a peculiar ring you saw on the finger of a man you met only once", if you get the reference :D
08:31:03 <srhb> Gurkenglas: I've yet to read HPMR. :P
08:31:14 <Nux_> silver still failed
08:31:30 <Nux_> CPPFLAGS=-I"C:/cygwin64/usr/src/debug/curl-7.43.0-1/include" LDFLAGS=-L"C:/cygwin64/usr/src/debug/curl-7.43.0-1/lib" cabal install curl
08:31:42 <Nux_> * Missing C library: curl
08:31:56 <Jello_Raptor> Does someone have a code example, or more detailed documentation for Control.Lens 's makeClassy'' ? I think I know how it works, but there's very little to go on. 
08:32:19 <Jello_Raptor> (I'm trying to use that to approximate a proper generic records solution)
08:34:35 <Nux_> silver, what files are you pointing it at?
08:35:18 <Nux_> my include directory has 'curl' directory in it with a single 'typecheck-gcc.h' file
08:36:07 <Nux_> as you can see it's 7.43.0-1 (64-bit cygwin)
08:36:20 <Nux_> my haskell platform is 32 bit
08:36:35 <Nux_> my operating system is 64 bit
08:36:43 <Intolerable> Jello_Raptor: are you sure you need makeClassy and not makeFields?
08:37:04 <Nux_> my cabal is up-to-date
08:37:17 <Intolerable> Jello_Raptor: take a look at https://github.com/intolerable/dota2/blob/master/src/WebAPI/Dota/Types/Match.hs and https://github.com/intolerable/dota2/blob/master/src/WebAPI/Dota/Internal/SharedFields.hs
08:37:21 <Jello_Raptor> Intolerable: nope
08:37:23 <silver> Nux_, for CPPFLAGS I used downloaded source of curl lib
08:37:40 <Intolerable> i'll try and find a better example but i have that available
08:37:42 <Nux_> downloaded with cygwin?
08:38:25 <silver> no, got it by manually downloading from curl's site
08:38:54 <Jello_Raptor> Intolerable: make fields does look more like what I want :), though is there a records library that works with Control.Lens and isn't broken? (record and record-preprocessor are at the moment) 
08:39:00 <bitemyapp> orion: I am now.
08:40:06 <bitemyapp> orion: sending me email is better than pinging on IRC if it's about work though. asynchrony is gud.
08:40:07 <fizbin> chpatrick: I think you misread my code.
08:40:22 <chpatrick> fizbin: what's wrong?
08:40:40 <fizbin> Namely, the limits of the array are (0, _tcN cfg - 1)
08:40:55 <chpatrick> oh yeah, whoops
08:41:10 <Nux_> silver, still failing, have I got to delete a config file somewhere?
08:41:14 <fizbin> And the first element is the seed. After that, the function takes over.
08:42:13 <Jello_Raptor> Intolerable: also do you know how "makeFields" works when multiple structs with the same fields are declared in multiple modules? 
08:42:32 <fizbin> So I'm still trying to figure out why I can't say what I wanted to with ST.
08:42:39 <Intolerable1> Jello_Raptor: you have two options
08:42:40 <Jello_Raptor> do identical typeclass defintions in multiple modules unify in general? 
08:42:46 <Intolerable1> nope
08:42:58 <Intolerable1> you have to import the other module
08:43:03 <fizbin> I mean, why can't I have a restriction with a forall in it?
08:43:17 <Intolerable1> or if that would involve circular imports or huge amounts of imports, you'll have to use shared-fields
08:43:25 <Jello_Raptor> shared fields? 
08:43:46 <Jello_Raptor> https://hackage.haskell.org/package/shared-fields?
08:44:08 <Intolerable1> probably better using the git version tbh https://github.com/intolerable/shared-fields
08:44:21 <Intolerable1> but i can throw that on hackage if you want
08:44:31 <Jello_Raptor> Intolerable1: I would appreciate it :) 
08:44:34 <Intolerable1> you basically just create one module with all your HasX typeclasses in
08:44:52 <Intolerable1> and then import that, then do makeFields on all the records and the instances should unify
08:45:12 <Intolerable1> i'll put an example in the readme and then upload it
08:45:17 <Intolerable1> give me 15m
08:45:20 <Jello_Raptor> cool, thank you
08:47:08 <Nux_> silver, you there?
08:47:12 <silver> Nux_, yes
08:47:26 <Nux_> silver, did you have to delete a config file?
08:47:43 <silver> no
08:48:00 <silver> CPPFLAGS=-ID:/curl-7.43.0/include LDFLAGS=-LD:/Programs/cygwin64/lib cabal install curl
08:48:04 <silver> works for me
08:48:55 <latk> Is there any way to see all of the exceptions a function can throw?
08:49:10 <quicksilver> sadly not
08:49:15 <latk> I'm using wreq, which is awesome, but it raises exceptions for loads of stuff like 500s, which seems like madness
08:49:23 <quicksilver> that's one of the disadvantages of exceptions
08:49:28 <quicksilver> they're invisible to the type system
08:49:33 <latk> yeah exactly
08:49:39 <latk> I can see that it makes sense for stuff that should really break everything
08:49:44 <latk> like an interupt or whatever
08:49:47 <quicksilver> some people use that as a argument that they're not really the right tool for 'business as usual exceptional flow control'
08:49:55 <latk> but if the server times out why not either :s
08:50:04 <Intolerable1> what are you wreqing?
08:50:07 <quicksilver> but to be honest this debate is pretty widespread in all progarmming languages
08:50:09 <latk> just an api
08:50:13 <quicksilver> it's not like there is an obvious answer :P
08:50:13 <Nux_> silver, do you use 64 bit haskell platform?
08:50:20 <latk> specifically dropbox
08:50:41 <latk> Yeah, but in other languages you dont have either/maybe/etc
08:50:46 <silver> Nux_, yeah
08:50:48 <Intolerable1> have you seen https://hackage.haskell.org/package/api-builder? (shameless plug)
08:51:18 <Nux_> silver, I switched to using 32 bit when another package I wanted to use seemed to require it
08:51:21 <latk> So now I guess I have to find all the http exceptions, and wrap wreq :?
08:51:27 <latk> Intolerable1: I have not
08:51:28 <Nux_> silver, could that be the problem?
08:51:54 <silver> don't know, I'll check lib name now, it might be the problem
08:52:03 <Intolerable1> if you're just doing http rest-similar stuff it might be worth having a look
08:52:29 <Intolerable1> and if you find something it can't do i'd like to hear so i can fix it :)
08:52:29 <Nux_> silver, I also still have environment vars set from previous attempts to get this to work
08:52:33 <latk> Will take a look :)
08:52:51 <Nux_> silver, if I'm right, they won't cause any problems because they can only add to the locations searched... is that right?
08:53:21 <silver> oh it depends
08:55:46 <Nux_> well I tried removing the ones I'm sure about being particular to this installation attempt and it didn't help
08:56:41 <silver> default lib names seems to work, so sadly I don't know what's causing the problem for you
08:56:57 <Nux_> silver, did you use cygwin?
08:57:01 <silver> yes
08:57:07 <Nux_> silver, so did I...
08:58:09 <Nux_> silver, is there somewhere I can put the curl libs and include files where cabal searches by default?
08:58:48 <Nux_> silver, or will this issue still cause problems there?
08:59:24 <silver> Nux_, try mingw directory inside haskell platform installation
08:59:44 <silver> there's include directory and lib directory
09:00:40 <Intolerable1> Jello_Raptor: should be up and ready now
09:00:45 <Intolerable1> let me know if you have any problems
09:01:17 <latk> Oh, my mistake about wreq btw. You can set checkStatus in options to stop exceptions being raised.
09:02:20 <Nux_> silver, didn't work
09:02:31 <Nux_> silver, I tried with and without the CCFLAGS business
09:02:42 <Nux_> now I've got to clean that all up :(
09:02:44 <silver> CCPFLAGS
09:03:04 <Nux_> *CPP?
09:03:04 <silver> CPPFLAGS
09:03:08 <Nux_> yes
09:03:10 <Nux_> that
09:03:17 <Nux_> I didn type it correctly in the command
09:03:23 <Nux_> I just forgot it just then
09:03:28 <silver> oh ok
09:03:54 * hackagebot shared-fields 0.2.0.0 - a tiny library for using shared lens fields  https://hackage.haskell.org/package/shared-fields-0.2.0.0 (Intolerable)
09:04:43 <silver> how did you copy headers? there should be path like this: ...\include\curl\curl.h (configuration looks for <curl/curl.h>)
09:05:40 <Nux_> silver I have that path
09:05:56 <silver> I see
09:05:59 <Nux_> silver I copied it all of the files into the equivalent place
09:06:15 <Jello_Raptor> Intolerable1: brilliant, thank you :) 
09:06:20 <Nux_> meaning I now have a bunch of non-functioning files littering my mingw include and lib folders :(
09:06:39 <Nux_> *-it
09:07:08 <Nux_> I have a copy of which files they were, but I'm going to have to do some work identifying and deleting them
09:07:18 <silver> did you copy much? it shouldn't be hard to delete all of it
09:07:19 <Nux_> or just reinstall the whole blasted thing
09:07:23 <silver> :)
09:07:39 <Nux_> silver, the lib folder is packed with files
09:07:47 <Nux_> 245 in total
09:07:56 <silver> yeah, but libcurl is like 1 file?
09:08:23 <Nux_> erm
09:08:54 <Nux_> I'm not sure what you mean
09:08:54 * hackagebot api-builder 0.9.1.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.9.1.0 (Intolerable)
09:09:19 <Nux_> where is this single libcurl file?
09:10:04 <silver> well, you copied curl library binary right?
09:10:12 <silver> from cygwin
09:10:50 <Nux_> nope
09:12:36 <Nux_> I'll be switching to phone irc as I've got a bus to catch
09:12:50 <Nux_> I'll also be away from the computer I'm doing this all on
09:12:59 <silver> oh ok
09:13:04 <Nux_> could you let me know exactly what files you copied from where to get it to work?
09:13:25 <Nux_> both the files from the curl site and the cygwin package files
09:13:54 * hackagebot elm-init 1.0.0.2 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.0.2 (justus)
09:17:38 <silver> I didn't copy anything, I just installed: 1. dev version of curl lib and already had non-dev version; 2. downloaded source code of curl from site you linked, and then used CPPFLAGS/LDFLAGS to point to source and lib binary
09:18:54 * hackagebot data-lens 2.10.7 - Used to be Haskell 98 Lenses  https://hackage.haskell.org/package/data-lens-2.10.7 (RussellOConnor)
09:21:19 <zmbmartin> What is the best way to convert a epoch_time with timezone eg (1436810792.966, +00:00) to UTCTime?
09:22:16 <Nuxular> Hi silver
09:22:25 <silver> hey
09:22:34 <silver> I didn't copy anything, I just installed: 1. dev version of curl lib and already had non-dev version; 2. downloaded source code of curl from site you linked, and then used CPPFLAGS/LDFLAGS to point to source and lib binary
09:22:54 <glguy> zmbmartin: You'd probably convert the epoch time to a UTCTime first, and then fit that into a ZonedTime
09:22:59 <Nuxular> cheers for resending that
09:23:03 <glguy> Data.Time.Clock.POSIX.posixSecondsToUTCTime
09:23:27 <zmbmartin> glguy: Thanks!
09:24:16 <glguy> zmbmartin: utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime -- might be the other one
09:24:32 <glguy> But I'm just going on the types. You should check the docs that it does what you wanted.
09:26:15 <solrize> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html  wow!
09:26:31 <Nuxular> did you specify in cygwin package manager to install source for the curl dev version?
09:28:10 <Nuxular> thanks for putting up with my questions silver
09:28:18 <silver> Nuxular, I did, but they don't seems to work
09:28:29 <silver> also simple program segfalts
09:28:45 <silver> so probably it was a bad idea to mix header and lib from different version
09:28:55 * hackagebot conduit-combinators 1.0.1.1 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.1.1 (MichaelSnoyman)
09:29:14 <silver> I guess I need to build the lib or use cygwin sources
09:29:30 <silver> oh, I didn't try cygwin sources actually
09:30:49 <Nuxular> silver I'll try getting this to work on my home computer. If you're not around then thanks for the help you've given.
09:31:43 <silver> no problem
09:34:54 <nitrix> operationCreate :: Ledger -> Block -> IO (Maybe BlockId)
09:35:09 <nitrix> If I want to keep the same signature and mutate Ledger, it'd need to be an IORef?
09:38:48 <roboguy_> nitrix: probably, but I wouldn't suggest it (unless there's a really good reason)
09:39:11 <nitrix> I should use the state monad, I suppose?
09:39:39 <roboguy_> that's what I would suggest
09:39:50 <nitrix> Actually, I think it'll be a MVar, because that'll become multithreaded and the ledger needs mutual exclusivity.
09:40:39 <roboguy_> if you use the State type, you shouldn't need to worry about multithreading issues
09:40:54 <nitrix> Except, concurrent operations are also dispatched on multiple servers and so, the Ledger will need a merge anyway... gosh...
09:41:30 <nitrix> That's actually a harder problemt than I thought. I think I'll make it pure, and have a dedicated operation that'll just merge the former ledger with the new ledger, and that'll be an MVar.
09:41:35 <nitrix> roboguy_: Oh sweet.
09:41:50 <roboguy_> State is just a pure function, internally
09:42:45 <nitrix> Myeah you can escape the monad with runST, I think.
09:43:08 <lpaste_> catgocat pasted “Exericise_Logs” at http://lpaste.net/136982
09:43:26 <catgocat> Hey guys might checking how I'm dealing with the first part of the exercise 1 from http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf?
09:43:29 <catgocat> http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
09:43:32 <nitrix> That could work, if the process involved wasn't also an IO. I'm doing a file system.
09:43:55 * hackagebot cgrep 6.4.17 - Command line tool  https://hackage.haskell.org/package/cgrep-6.4.17 (NicolaBonelli)
09:43:58 <nitrix> I'll probably be stuck with an IORef or MVar for that specific case.
09:43:58 <roboguy_> nitrix: that's ST not State
09:44:03 <nitrix> Oh?
09:44:18 <catgocat> I think it could be improved. I am only allowed to use prelude functions
09:44:42 <tommd> catgocat: Can you select the prelude?
09:44:51 <catgocat> I don't really know what that means
09:44:52 <tommd> The nice thing about Preludes is there are plenty to choose from.
09:44:56 <roboguy_> nitrix: yeah. "State s a" is internally a newtype around s -> (a, s), while ST internally mutates things and provides a function for creating new variables
09:45:17 <catgocat> tommd: what do you mean select?
09:45:56 <tommd> catgocat: I'm more kidding than helping, sorry.  There is more than one module called "Prelude" is all.  Your instructor almost certainly means whatever GHC prelude is in 7.8 or 7.10.
09:46:04 <roboguy_> State has a much nicer interface than using s -> (a, s) directly to represent state though
09:46:08 <catgocat> I don't have an instructor
09:46:47 <catgocat> I hope somebody can help me
09:46:48 <tommd> So you are only allowing yourself to use Prelude functions then?
09:47:17 <catgocat> tommd: Well according to the exercise page (http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf), it suggests that I should use prelude functions.
09:47:24 <jTT_> hey, is there a simple function that allows a Text manipulation that drops Text in brackets, like so “hello you (un-) useful fxn” —> “hello you useful fxn”?
09:47:25 <catgocat> It doesn't really mention the version or anything.
09:53:56 * hackagebot data-lens-template 2.1.9 - Utilities for Data.Lens  https://hackage.haskell.org/package/data-lens-template-2.1.9 (RussellOConnor)
09:58:56 * hackagebot stitch 0.3.2.0 - lightweight CSS DSL  https://hackage.haskell.org/package/stitch-0.3.2.0 (Intolerable)
10:01:21 <chpatrick> :t T.concat . map (\p -> let suf = T.dropWhile (/=')') p in if T.null suf then p else T.tail suf) . T.splitOn "("
10:01:22 <lambdabot>     Not in scope: ‘T.concat’
10:01:23 <lambdabot>     Perhaps you meant one of these:
10:01:23 <lambdabot>       ‘F.concat’ (imported from Data.Foldable),
10:01:29 <chpatrick> :t Text.concat
10:01:30 <lambdabot> Not in scope: ‘Text.concat’
10:02:03 <chpatrick> jTT_: it's not pretty but there you go
10:02:28 <chpatrick> doesn't handle nesting at all
10:02:47 <jTT_> thanks chpatrick, i shall take it from there!
10:06:11 <hiptobecubic> TypeError: 'float' object has no attribute '__getitem__'
10:06:31 <hiptobecubic> For some reason, seeing these over and over again does not convince anyone :(
10:11:51 <lpaste_> catgocat annotated “Exericise_Logs” with “Exericise_Logs (annotation)” at http://lpaste.net/136982#a136985
10:12:01 <mitochon> newbie question .. how does http://lpaste.net/136983 typechecks? 'id' and '(,)' are not monadic
10:13:44 <nitrix> :t (,)
10:13:45 <lambdabot> a -> b -> (a, b)
10:13:47 <nitrix> :t id
10:13:48 <lambdabot> a -> a
10:13:52 <nitrix> :t (=<<)
10:13:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:13:59 <Gurkenglas> mitochon, sure they are! (->) has a monad instance, it's also called the reader monad
10:14:25 <Gurkenglas> mitochon, https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#line-614
10:14:39 <nitrix> Ahah, wow. There you go. That's haskell for you.
10:14:48 <nitrix> Functions are monads!
10:15:29 <Gurkenglas> It's roughly used for pluggin an argument into multiple holes. join turns (a -> a -> b) into (a -> b)
10:17:28 <mitochon> wow, that's great .. thanks all
10:21:24 <voidnoid> does anyone have experience with JS variants of haskell? e.g. ghcjs vs fay
10:21:34 <voidnoid> mostly I'm curious if anyone has a strong recommendation of one over the other
10:24:39 <luite> hmm
10:25:39 <dcoutts> voidnoid: these days I'd recommend ghcjs
10:26:04 <voidnoid> dcoutts: k, thx
10:26:10 <dcoutts> the major advantage is you can use full Haskell, and can share code (types, utils) between client and server
10:26:40 <dcoutts> voidnoid: the only significant drawback is that .js code size is bigger
10:26:54 <dcoutts> which may or may not be an issue, depending on what you're doing
10:27:55 <luite> voidnoid: the improved-base branch is the interesting one, that should get released on hackage soon, but you need ghc 7.10.2 for it
10:28:09 <dcoutts> voidnoid: e.g. there's full-on FRP libs for the HTML DOM which you can use with ghcjs (but not fay because it doesn't support the necessary language features)
10:29:13 <voidnoid> cool all good to know, thanks, I'll go with ghcjs :)
10:29:17 <dcoutts> luite: fyi, was recently consulting for a client helping them use ghcjs in production (+ FRP). Fun stuff :-)
10:29:48 <luite> dcoutts: oh cool
10:31:20 <luite> dcoutts: i'm going to prepare some release notes soon, and detail some of the progress and plans for ES2015 (ES6) support, the new code generator and ghcjsi
10:31:26 <luite> dcoutts: have you tried ghcjsi yet?
10:31:28 <dcoutts> nice
10:31:30 <dcoutts> no
10:31:36 <dcoutts> we were feeling the lack of that
10:32:17 <luite> it's rather experimental and easy to break currently
10:33:12 <luite> dcoutts: if you hadn't seen it yet, when you start ghcjsi, the code runs on node.js, but you can connect a browser and then everything is sent to there, giving you access to window.document etc. http://hdiff.luite.com/tmp/ghcjsi1.png
10:33:16 <dcoutts> luite: one issue that springs to mind from that work, an FFI grumble: the JSObject type and friends. The JSArray is not a "sub-type" of JSObject so one is sometimes forced to castPtr between JSObject and JSArray, and similar issues for some of those other basic types.
10:33:44 <dcoutts> luite: cool
10:33:49 <lpaste_> catgocat annotated “Exericise_Logs” with “Exericise_Logs (annotation)” at http://lpaste.net/136982#a136988
10:34:58 <dcoutts> luite: we ran into these issues of having to use castPtr when binding some extra JS libs
10:35:13 <luite> dcoutts: ah everything of that kind is going to change in improved-base, but i haven't quite finalized the API yet.
10:36:40 <dcoutts> luite: ok, great
10:36:57 <luite> dcoutts: see here, https://github.com/ghcjs/ghcjs-base/tree/improved-base/JavaScript
10:37:56 <dcoutts> luite: great
10:38:49 <luite> dcoutts: but actually the change only makes conversion harder, many things are newtypes now, rather than JSRef SomePhantom.
10:40:51 <luite> dcoutts: but on the other hand, there are much more complete bindings for the JS data structures now, plus additional type safety, mutable and immutable typed arrays for example
10:48:58 * hackagebot lentil 0.1.2.7 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.2.7 (fffaaa)
10:55:14 <tac> Is there a good way to figure out what line I am getting an exception on?
10:55:32 <tac> My bot crashes about every week/every other week due to a fromJust Nothing exception... but no idea what line it's on
10:55:39 <tac> or if it's in my code or a library
10:55:47 <geekosaur> not currently :(
10:58:14 <tac> then in that case, what was the command to grab the source of a hackage repo with cabal?
10:58:21 <tac> I thought it was cabal source.. but I apparently just made that up
10:58:28 <tac> nvm
10:58:56 <ronh> tac you have so many fromJusts that you can't tell?
10:59:49 <tac> ronh: I have a handful, but none look as if they could be caused by an IRC loss of connection
11:00:08 <geekosaur> cabal get
11:00:12 <ronh> this is why I never use fromJust but alternatives from safe package (even if it is fromJustNote, which accepts error string)
11:00:21 <tac> right
11:00:34 <tac> I would ban fromJusts from my repositories if I had a company
11:01:02 <tac> I have exactly two modules which use it, and they should not be related at all to the issue
11:01:10 <roboguy_> I usually do "let Just x = fn y in ..." so that the errors tell you what line it's one
11:01:12 <roboguy_> *on
11:02:38 <tac> I might as well get rid of them to remove all doubt
11:02:51 <tac> The one requires I convert a tuple of Maybes into a tuple of regular dudes
11:03:14 <tac> I guess these are all strings...
11:15:25 <tac> all right. all fromJust's removed.
11:15:36 <tac> I guess I'll be back in 2 weeks if I'm still having issues :X
11:16:41 <johnw> fromJust removal is like a young Jedi, purging themselves of the Dark Side
11:17:17 <Gurkenglas> Is there a way to search through "all" the haskell projects for "example" uses of something?
11:17:19 <MP2E> fear leads to anger, anger leads to hate, hate leads to non-total functions
11:17:45 <johnw> MP2E: so true
11:17:56 <tac> johnw: It's more like lying to myself, because I'm still using partial pattern-matching :P
11:18:53 <nuttycom> tac: see, this is why I like folds. No cheating.
11:20:29 <tac> mostly it happens because I don't know a nicer way to handle failure with JSON and lens
11:26:08 <catgocat> JoshuaPassosBR: olá
11:29:15 <Haskellfant> Gurkenglas: not directly but I abuse the github search for that
11:33:24 <dmj`> what's the best way to go from Integer -> POSIXTime
11:34:46 <glguy> dmj`: fromIntegral, assuming your Integer is seconds
11:34:55 <glguy> (or I suppose fromInteger)
11:36:06 <monochrom> so-called POSIXTime is Data.Time.Clock.NominalTime. It is a Num instance.
11:36:19 <monochrom> err, NominalDiffTime
11:39:18 <Gurkenglas> Would (\x y -> (if x then 2 else 0) + (if y then 1 else 0)) be parallelized automatically?
11:39:47 <indiagreen> Gurkenglas: no
11:42:09 <monochrom> add some "par"s by hand to parallelize them
11:49:00 * hackagebot shared-fields 0.1.1.0 - a tiny library for using shared lens fields  https://hackage.haskell.org/package/shared-fields-0.1.1.0 (Intolerable)
12:23:28 <fr33domlover> Q: is there a class that captures all monads which have StateT in their stack?
12:23:33 <fr33domlover> like MonadIO but for state
12:23:54 <fr33domlover> (I saw MonadState in mtl  - but RWST isn't an instance of it?)
12:24:16 <bergmark> fr33domlover: it is...
12:24:40 <fr33domlover> I just didn't see the instance in the docs :P
12:24:55 <fr33domlover> (I checked the RWST from transformers)
12:25:24 <BIG_FAIL> hi, is there a bluespec system verilog channel on this irc server?
12:25:41 <monochrom> transformers doesn't have those instances. find in mtl.
12:25:42 <fr33domlover> bergmark, oh I see, it's in mtl too 
12:26:02 <monochrom> the whole point of transformers is to stick to basic concrete definitions and avoid classes
12:26:32 <monochrom> and the whole point of mtl is embracing classes
12:27:14 <monochrom> transformers and mtl were once rivals.
12:27:28 <fr33domlover> I read in the wiki about their history :)
12:27:53 <fr33domlover> I'm new to Haskell so when came they just live alongside each other, it seems
12:27:59 <fr33domlover> *when I came
12:28:31 <monochrom> then one day, there was a peace conference. the treaty of Versaille was signed. they agreed to merge. mtl becomes a class layer on top of transformers.
12:28:59 <monochrom> (I made up "peace conference" and "treaty of Versaille")
12:30:18 <monochrom> yeah, the war ended a long time ago
12:31:04 <monochrom> like how you have always known Britain and the US and Canada to be allies
12:31:17 <monochrom> but 200 years ago they were at war
12:31:29 <monochrom> ok, 300
12:31:43 <monochrom> actually, 200. Year 1812.
12:35:46 <kynan_> can i use lenses as "keys" to use a traversable data structure as a "map"? i'd like to modify entries in a sequence based on pairwise comparisons.
12:36:44 <kynan_> i'm thinking that when i find a pair of interest, i can use the two lenses to perform the update
12:37:42 <L8D> kynan_: what is stopping you?
12:38:10 <kynan_> L8D lack of knowledge.
12:39:07 <kynan_> i get how to traverse the contents of a structure. but i don't really get how to traverse its lenses
12:39:15 <L8D> kynan_: by "a map" do you mean to provide the instances for Ix and such?
12:39:55 <kynan_> i basically mean i want to transform <some structure> into [(lens, target)]
12:40:23 <kynan_> where i can then use lens_i to updated target_i inside <some structure>
12:40:50 <kynan_> so the garbage version would be to assign an int to each target and put it in an actual map
12:41:04 <Hijiri> If keys might not have a value, it would have to be a traversal and not a lens
12:41:39 <Hijiri> You might want to take a look at Control.Lens.Indexed (https://hackage.haskell.org/package/lens-4.12.1/docs/Control-Lens-Indexed.html) though
12:41:47 <kynan_> ok
12:41:57 <kynan_> i imagined the "transform" i described to be a traversal
12:42:15 <voidnoid> hmm, does anyone happen to know if ghcjs provides a javascript api I can use from e.g. nodejs or am I only able to use the CLI?
12:43:40 <friden> is there a way to sort content in a file that does not fit in ram at the same time?
12:43:55 <Hijiri> kynan_: also look at https://hackage.haskell.org/package/lens-4.12.1/docs/Control-Lens-At.html
12:44:11 <kynan_> thanks
12:44:18 <rowanblush> friden: Are you looking for a library function or just a general method?
12:44:36 <friden> i have a function that will return a list of these items from the i want sorted, and a function to compare two items
12:44:43 <friden> rowanblush: any of these two would suffice
12:44:49 <friden> *those
12:45:40 <htebalaka> is there a reason to prefer a filterM implemented with either the applicative or monadic interface (re operational behaviour)?
12:46:19 <htebalaka> i'm vaguely under the impression that applicative vs monad can have different stack behaviour, but haven't found anything explaining the difference in detail
12:46:58 <Hijiri> which stack?
12:47:29 <rowanblush> friden: Looks like there's an external-sort package, but it was last updated in 2008 so might not build. You could look there for strategies.
12:48:16 <htebalaka> Hijiri: the runtime call stack i guess? like i said, i haven't found anything explaining the concern in detail, i just occasionally see offhand comments referring to the issue
12:48:17 <friden> rowanblush: huh, didnt see that one, i will see if it still works, thanks^^
12:48:50 <htebalaka> i think it depends on the particular monads bind operator whether it's an issue
12:49:27 <nitrix> htebalaka: Ideally, it'd be a subclass of Traversable called Filterable. filterM :: (Applicative f, Filterable t) => (a -> f Bool) -> t a -> f (t a).
12:49:59 <Hijiri> nitrix: there is fumieval's Witherable
12:50:28 <Hijiri> htebalaka: haskell doesn't use the RTS for allocating things on, except when it's an optimization
12:50:38 <Hijiri> RTS meaning runtime stack in this case (not runtime system)
12:50:40 <nitrix> Hijiri: I just googled it. There you go, that seems good to me.
12:50:56 <Hijiri> the runtime system itself does use the runtime stack (I think it's done in C)
12:51:15 <Hijiri> but in general, variables in haskell are allocated on the heap
12:51:50 <Hijiri> There is a stack (allocated on the heap) for keeping track of pattern matches
12:52:17 <Hijiri> but it isn't a frame where you put local variables or anything
12:53:03 <htebalaka> nitrix: i'm less concerned about polymorphism over the traversable than the monad. i've heard of issues in reference to the Writer monad (that the bind operator can make "apparent" tail recursion not actually tail recursive, and it's better to use a State monad as a result), but like i said i've never heard the issue explained in any depth
12:54:03 <Peaker> htebalaka: Writer monad's  a >>= b    has to keep a's result for the entire time "b" is running around, and remember to mappend it to "b" when "b" is done
12:56:25 <htebalaka> Peaker: is the issue affected if you can manage to write things with only the applicative interface?
12:58:30 <Peaker> for WriterT w Identity  applicative, you get (w1, f) <*> (w2, x) = (w1<>w2, f x)   and if nothing demands the mappend result, maybe it won't get computed/kept
12:59:48 <Peaker> For WriterT w (m/=Identity), you get  actF <*> actX, you need to "execute" actF and "actX" using their Applicative interface. If their Applicative is serial (e.g: IO), then while actX is executing, the actF result must be kept around to mappen, just like >>=
13:00:09 <Peaker> IOW, for IO, I think it'll still leak, for non-IO monads I am less sure what would happen :)
13:00:40 <forgottenone> i cannot find Data.List.Ordered,isn't it in standart library?
13:03:39 <int-e> @hoogle Data.List.Ordered
13:03:39 <lambdabot> package ordered
13:03:40 <lambdabot> package aws-sdk-xml-unordered
13:03:40 <lambdabot> package unordered-containers
13:03:57 <nomeata> how ironic
13:04:03 <nomeata>  Data.List.Ordered is in unordered-containers
13:04:03 <int-e> indeed
13:04:04 * hackagebot elm-init 1.0.1.0 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.1.0 (justus)
13:04:36 <nomeata> maybe unordered-containers is just an unordered container of modules for orderd data structures
13:05:46 <htebalaka> Peaker: thanks. i'm just using State, so i guess i'm okay for my use case. just a little curious in general
13:08:41 <lautrec> how can i use (>>=) with binary ops? i'm trying to turn this into a one-liner: https://gist.github.com/yarbroughw/87c4363a1876c1bb434a
13:09:23 <c_wraith> Peaker, htebalaka: yeah, WriterT is basically useless for monoids with strict mappend.  It will always leak.  Even the strict version.
13:09:49 <Eduard_Munteanu> lautrec, liftM2 op left right
13:10:26 <c_wraith> Eduard_Munteanu: not quite.  That type signature needs a join, too
13:10:46 <c_wraith> :t \f x y -> join (liftM2 f x y)
13:10:47 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:11:04 <Eduard_Munteanu> Oh, duh.
13:11:12 <lautrec> c_wraith: excellent, ty
13:11:24 <Peaker> c_wraith: WriterT over IO will always leak, I think, I don't think GHC is smart enough to forget the left monoid-val since the mappend will eventually not need it
13:11:46 <c_wraith> Peaker: I'm pretty sure WriterT leaks over every monad.
13:12:14 <Peaker> c_wraith: I think WriterT over Identity with a lazy Monoid might not leak
13:12:39 <c_wraith> Peaker: oh, right.  With a lazy monoid it can be productive.
13:13:13 <Peaker> A monad that's lazy on the left arg of bind and a monoid with a mappend lazy on its left arg :)
13:13:30 <Peaker> (I think, it's not trivial for me to compute exactly which laziness will cause what)
13:13:41 <c_wraith> > execWriter . forever . tell $ [()]
13:13:42 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
13:14:07 <c_wraith> I hope it's not leaking in that example. :)
13:16:12 <Peaker> c_wraith: :)
13:24:39 <anks> why do imported Data.ByteString.Lazy.pack is of type [GHC.Word.Word8] instead of [Char]
13:24:40 <anks> ?
13:24:52 <dmj`> Data.ByteString.Lazy.Char8
13:25:23 <anks> BS.pack :: [GHC.Word.Word8] -> BS.ByteString
13:25:47 <anks> but when i check on hoogle its [Char] -> ByteString
13:25:50 <shachaf> anks: Because a ByteString is a sequence of bytes, not of characters.
13:26:04 <shachaf> Hoogle is showing you a function for advanced users.
13:26:04 <silver> anks, different pack?
13:26:32 <anks> right, thx dmj
13:27:06 <dmj`> fosh
13:27:19 <shachaf> anks: You probably shouldn't be using Data.ByteString.Lazy.Char8
13:27:30 <shachaf> It's a good way to write broken code.
13:27:36 <anks> Why is that?
13:27:49 <shachaf> Instead you should encode and decode your strings appropriately.
13:28:14 <hiptobecubic> Doesn't () have a monoid instance?
13:28:24 <hiptobecubic> > execWriter . forever . tell $ ()
13:28:26 <lambdabot>  ()
13:28:28 <anks> well i need bytestring -> [char] constructor
13:28:31 <hiptobecubic> Thought so
13:28:34 <shachaf> Char is a Unicode code point, and ByteString is a sequence of bytes.
13:28:49 <shachaf> There's an encoding step to go between them.
13:29:29 <anks> isnt the encoding step pack?
13:29:38 <hiptobecubic> no
13:31:17 <hiptobecubic> Pack is more like doing this: "10101010" -> 10101010. Encode would be like "10101010" -> 0xAA
13:31:50 <ChristianS> anks: usually Data.Text or Data.Text.Lazy is the best way to go. encoding functions for the former are in Data.Text.Encoding.
13:32:06 <hiptobecubic> both represent the data as an integer, but one of them maintains the right meaning (assuming the string was a binary number)
13:32:09 <ChristianS> anks: e.g. Data.Text.Encoding.decodeUtf8 :: ByteString -> Text
13:32:33 <ChristianS> anks: or encodeUtf8 in the other direction
13:35:30 <xelxebar> Is there a standard way to have `transpose` insert some appropriate "zero" element when columns aren't long enough?
13:35:54 <xelxebar> Or should I just roll my own?
13:37:43 <xelxebar> I'd like [[1,2],[5],[6,9,3]] to become [[1,5,6],[2,0,9],[0,0,3]]
13:37:52 <htebalaka> xelxebar: none i know of
13:38:30 <Welkin> > transpose [[1,2],[5],[6,9,3]]
13:38:31 <lambdabot>  [[1,5,6],[2,9],[3]]
13:38:55 <xelxebar> htebalaka: thanks. One straightforward way is to just padd all the columns/rows with the appropriate number of zeros before transposing
13:38:58 <c_wraith> You should really pad it before calling transpose - but even that padding isn't totally obvious.
13:39:21 <Welkin> > transpose [[1,2,0],[5,0,0],[6,9,3]]
13:39:22 <xelxebar> > transpose [[1,2,0],[5,0,0],[6,9,3]]
13:39:23 <lambdabot>  [[1,5,6],[2,0,9],[0,0,3]]
13:39:24 <lambdabot>  [[1,5,6],[2,0,9],[0,0,3]]
13:40:29 <xelxebar> c_wraith: Yeah. Is there a standard way to pad other than manually finding the longest row and then appending the appropriate number of zeroes to each row?
13:40:33 <hiptobecubic> transpose is one of those things I just never manage to golf correctly
13:40:57 <c_wraith> xelxebar: I can't think of anything offhand, but I feel like there must be a clever lazy one-pass solution.
13:42:02 <hiptobecubic> xelxebar, zip using 0 for missing elements, then transpose, no?
13:42:08 <hiptobecubic> isn't there a zipLongest kind of guy?
13:46:54 <xelxebar> hiptobecubic: hmmm... can't seem to find a function along those lines. My hoogle skills are pretty unpolished though
13:47:05 <Gurkenglas> :t (map . map) snd . filter (any fst) . transpose . map (++ repeat (False, 0)) . (map . map) (True ,)
13:47:07 <lambdabot> Num b => [[b]] -> [[b]]
13:47:09 <subleq> I have a string "aToB | bToC", function aToB :: a -> b, bToC :: b -> c, and I need to parse the string and get back bToC . aToB :: a -> c
13:48:24 <Gurkenglas> No wait, that diverges.
13:48:35 <Wizek> G
13:49:08 <Gurkenglas> :t (map . map) snd . takeWhile (any fst) . transpose . map (++ repeat (False, 0)) . (map . map) (True ,)
13:49:09 <lambdabot> Num b => [[b]] -> [[b]]
13:52:16 <Gurkenglas> subleq, need bracket handling too?
13:52:33 <subleq> Gurkenglas: what is that?
13:52:59 <Gurkenglas> Can an input string be (btoB | btoB | (btoB | btoB) | btoB"?
13:53:16 <Gurkenglas> replace the first ( with a "
13:53:55 <subleq> Gurkenglas: composition is associative isn't it?
13:54:26 <Gurkenglas> subleq it is, but the handler probably doesn't know that. My question was another.
13:54:57 <subleq> so no brackets
13:55:02 <Gurkenglas> (I just used btoB so I can reuse it)
13:55:26 <Gurkenglas> Oh wait right composition is also associative in the general case ._.
13:56:08 <subleq> It's really a type system question not a parsing question
13:59:04 <pavonia> subleq: I had a similar problem and used Data.Dynamic to store the functions
13:59:05 <Nux_> silver, are you there?
14:01:27 <subleq> pavonia: yeah, I should have asked if it's possible without Data.Dynamic
14:03:35 <ChristianS> subleq: you'll either need Data.Dynamic or something similar
14:03:51 <subleq> :(
14:04:09 <Gurkenglas> Hah, I just got done with unintersperse and then got as far as parse's type signature before noticing whats wrong :D
14:06:50 <subleq> http://stackoverflow.com/questions/6846027/compose-functions-at-runtime-based-on-user-input-in-haskell
14:07:33 <Peaker> Do Generic-based instances have a performance penalty over manually-written ones?
14:07:36 <Peaker> (e.g: Binary instances)
14:07:45 <subleq> I think the GADT bullet point is the closest to what i want
14:08:44 <htebalaka> subleq: i've had a similar problem in the back of my head for a while, and i think some of the functions in Data.Reflection might help, though i haven't really worked through it far enough to be sure. the various reify_ combinators
14:10:25 <eacameron1> I'm just now getting into monad transformers. What's the current state of affairs? MTL or transformers preferred?
14:10:41 <Jello_Raptor> Is there a preffered model for programming on theoretically infinite streams, like pipes or TCP connections, where that's the only form of input and output? 
14:11:23 <xelxebar> > take <$> maximum . map length <*> transpose . map (++ repeat 0) $ [[1,2],[3],[4,5,6]]
14:11:24 <lambdabot>  [[1,3,4],[2,0,5],[0,0,6]]
14:11:53 <xelxebar> c_wraith, hiptobecubic: There's a cruddy way to do it.
14:12:06 <hiptobecubic> xelxebar, why?
14:12:15 <hiptobecubic> xelxebar, it does no extra work
14:12:48 <xelxebar> Well, it looks like we're mapping over the original list 3 times?
14:13:06 <Jello_Raptor> The specific case would be something that gets an XML document from a pipe (well, something with stateful parsing) manipulates it, and spits data out as fast as possible. 
14:13:08 <xelxebar> I don't really know what I'm talking about when it comes to Haskell performance though
14:13:26 <ReinH> eacameron1: mtl and transformers are mostly the same. mtl builds on transformers by adding, e.g., typeclasses
14:13:47 <ReinH> which can be useful because they prevent you from having to worry about how things are lifted for the most part
14:14:14 <eacameron1> ReinH: wow...a lot has changed since the SO questions and articles I was reading from '11
14:14:48 <Gurkenglas> xelxebar, seen mine?
14:15:05 <hiptobecubic> xelxebar, i didn't actually see your implementation there. Yes I'm not sure that's the best way to do it, but conceptually it seems fine.
14:15:25 <S11001001> someone gave a presentation recently on the intended style of mtl classes
14:15:26 <ReinH> actually, adding the typeclasses is basically mtl's raison d'être
14:15:30 <S11001001> anyone have that link?
14:15:40 <S11001001> like, the usage patterns
14:16:13 <xelxebar> Gurkenglas: Oh. Nice. Thanks!
14:17:14 <S11001001> ReinH eacameron1: found it https://www.youtube.com/watch?v=GZPup5Iuaqw
14:17:15 <Gurkenglas> Of course I don't know whether that's any faster than yours, but it feels like it should be theoretically possible through laziness to make this single-pass
14:17:50 <eacameron1> ReinH: S11001001: thanks!
14:18:03 <Gurkenglas> What also would evoke that feeling would be using http://hackage.haskell.org/package/nat-0.2/docs/Data-Number-Nat.html 's length function.
14:18:54 <ReinH> Gurkenglas: iirc Conor has a thing similar to this on SO somewhere...
14:18:57 <ReinH> I probably can't find it, but one sec
14:19:51 <Cale> S11001001: Just flipping around and looking at the slides toward the end, I'm not sure I agree with that usage pattern being ideal... For the most part I think I prefer uses of monad transformers where nobody can tell that you're using them.
14:20:15 <glguy> +1
14:20:25 <Gurkenglas> http://hackage.haskell.org/package/nat-0.3/docs/src/Data-Number-Nat.html#Nat <- "Pos m + Pos n = Pos (m+n)" <- uhhh wtf
14:22:02 <S11001001> Cale: can you tell? I believe the classes are generally amenable to implementation with coproducts or whatever else you like
14:22:15 <ReinH> Gurkenglas: 3 + 3 = 1 + 2 + 2, what's the problem ;)
14:22:40 <Gurkenglas> Oh. This is not a Zero | Succ Nat thing. Let me find one.
14:22:44 <glguy> S11001001: You can tell when someone exposes the mtl typeclasses as more than an internal implementation detail
14:22:44 <geekosaur> maybe just surprised by syntax for declaring an operator
14:23:01 <ReinH> oh
14:23:30 <S11001001> glguy: right, I'm saying the appearance of the classes in function sig doesn't require the use of transformers to supply types meeting those constraints
14:24:08 * hackagebot hnix 0.2.1 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.2.1 (JohnWiegley)
14:24:08 <Cale> Yeah, but those are also usually the wrong constraints.
14:24:34 <Cale> In that MonadState/MonadReader/etc. are not usually very fine-tuned to the API you want to provide.
14:25:02 <Pamelloes> Is there a recommended way to bundle resource with a program?
14:25:31 <Cale> There are a lot of instances where you'd be better off not allowing users get and put directly, for example, but instead some operations which made more sense with respect to the particular state that your library is managing.
14:25:54 <Gurkenglas> (Ehh https://hackage.haskell.org/package/data-nat-0.1.2/docs/Data-Nat.html is close enough i guess)
14:26:14 <Cale> and once it's more specialised than that, you can ask yourself whether it's really a good idea to have a type class at all, if there's mainly going to be a single instance
14:27:05 <ReinH> xelxebar, Gurkenglas: regarding the zipping with padding, http://stackoverflow.com/questions/21349408/zip-with-default-value-instead-of-dropping-values/21350096#21350096
14:27:07 <Peaker> Sometimes a class with a single instance can be useful to restrict the uses of that type to do only what the class allows
14:27:07 <ReinH> found it
14:27:13 <zcs> hi all 
14:27:47 <Cale> Peaker: yeah, sometimes, if you're being very cautious, that can be a good thing.
14:27:58 <zcs> I have a quick cabal question . I can't seem to update my version of cabal
14:28:11 <zcs> it says cabal-install version 1.22.6.0
14:28:22 <zcs> using version 1.22.2.0 of the Cabal library
14:28:47 <Peaker> Cale: I had a  Monad m => MonadParse m  class that was used in parsing and allowed access to the file system, and allowed me to make sure I memoize all access to all files
14:28:52 <Cale> Peaker: More often than not, I feel like it's something that people jump into doing just because "yay, typeclasses!", and maybe it isn't helping so much. So I usually caution in the other direction :)
14:28:55 <geekosaur> after installing it, make sure the directory it installed to (~/.cabal/bin on most unix, possibly ~/Library/Haskell/bin on OS X, no idea for windows) is at the front of $PATH, then "hash -r" on unixlikes to make the shell look again
14:28:55 <zcs> Is there some weird dependency that's limiting my version of cabal ?
14:29:25 <Cale> But you're right, there are use cases for single-instance type classes which can be quite effective at controlling allowed behaviour.
14:29:32 <geekosaur> if you're confused by the version difference there, the cabal-install tool does not have the same version number as the Cabal library
14:29:42 <Nux_> did anyone here manage to get curl to install with cabal on windows?
14:31:12 <geekosaur> they are nto the same thing although they are related. but the Cabal library is also used by the compiler itself and predates the cabal-install tool by many years
14:31:40 <geekosaur> (the similar naming is admittedly unfortunate)
14:31:48 <Gurkenglas> @karma+ ReinH
14:31:48 <lambdabot> ReinH's karma raised to 23.
14:33:07 <zcs> cool thanks @geekosaur I thought perhaps I was not using the latest version of cabal
14:33:36 <zcs> but instead what you're saying is that the Cabal package is only somewhat related to cabal-install
14:34:13 <zcs> do you know of a good resource that lays out how ghc-pkg , cabal, and cabal-install relate ?
14:34:24 <ReinH> zcs: Cabal is the library that the cabal-install package uses
14:34:31 <geekosaur> well. Cabal is the underlying package infrastructure and used by anything that manipulates Haskell libraries
14:34:38 <ReinH> cabal-install provides the cabal executable
14:34:52 <geekosaur> cabal-install manipulates Haskell libraries so it uses the Cabal library. but it does not *own* the Cabal library
14:35:02 <geekosaur> and so the versions often do not match
14:35:44 <ReinH> e.g. right now, cabal-install has the following Cabal dependency: Cabal (>=1.22.2 && <1.23)
14:36:10 <geekosaur> (in fact if anything owns the Cabal library, it is ghc)
14:37:13 <zcs> ic that makes more sense now
14:37:40 <zcs> thanks all 
14:41:36 <eacameron1> Is there a typeclass somewhere that defines a sensible "toBool" for things like Maybe, Either, etc.
14:42:33 <Hijiri> I'm not sure a class like that would make too much sense, since you would just be arbitrarily choosing which of the two constructors is "True" and which is "False"
14:42:37 <shachaf> lens has "has _Just", "has _Right", etc.
14:42:38 <Peaker> eacameron1: I don't think there is a sensible "toBool" for those :)
14:42:55 <eacameron1> I suppose "isFailure" would be better
14:43:00 <shachaf> :t Data.Foldable.null
14:43:01 <lambdabot> Foldable t => t a -> Bool
14:43:04 <Pamelloes> Pro tip: don't embed a file without checking how big it is first.
14:43:24 <eacameron1> shachaf: that's what I was looking for
14:50:24 <Twey> eacameron1: Bool satisfies a universal property, so a function  foo ∷ ToBool a ⇒ a → B  could always be written  foo ∷ Bool → B  using  foo . toBool  instead… which implies that you know the concrete type at the point where you call toBool, so you can use isJust, isRight, &c. without loss of generality
14:53:11 <eacameron1> Twey: That was a bit over my head, but I think you're just saying, write "Bool -> B" and use "isJust", isRight, etc.
14:53:52 <Twey> eacameron1: And more specifically that you lose no functionality by doing so over using the typeclass
14:54:20 <eacameron1> Twey: right, I see.
15:00:03 <GlenK> hi there.  learning myself some haskell for great good currently.  I'm on list comprehensions.  trying to understand what it means, when you draw from several lists, that comprehensions produce all combinations of the given lists.
15:01:08 <GlenK> say my lists are [1, 2, 3] and [4, 5, 6].  would that mean?  [], [1], [1, 2]...[1, 2, 3, 4, 5, 6]?
15:01:08 <xelxebar> ReinH: Thank you. That's very nice.
15:01:41 <GlenK> or could it be something like [[], [4, 5]]?
15:02:00 <ReinH> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
15:02:02 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:04:45 <archmonk> join #node.js
15:04:51 <GlenK> well, I'm trying to understand this I guess.  [x | x <- [1, 2, 3], x <- [4, 5, 6]]
15:04:52 <Iceland_jack> GlenK: If you want that behaviour use 'inits :: [a] -> [[a]]'
15:04:53 <Iceland_jack> > inits [1..6]
15:04:54 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6]]
15:04:55 <rhaps0dy> forgot a /
15:05:18 <Iceland_jack> GlenK: Ah, try changing one of the 'x' to a 'y' and see what happens
15:05:31 <Iceland_jack> > [x | x <- [1, 2, 3], y <- [4, 5, 6]]
15:05:33 <lambdabot>  [1,1,1,2,2,2,3,3,3]
15:05:38 <GlenK> seems like it's intermediately coming up with something like: [[4, 5, 6], [4, 5, 6], [4, 5 ,6]
15:05:38 <Iceland_jack> > [x | y <- [1, 2, 3], x <- [4, 5, 6]]
15:05:40 <lambdabot>  [4,5,6,4,5,6,4,5,6]
15:05:51 <Iceland_jack> Do you see the pattern?
15:06:06 <GlenK> I'll probably digest it in a second.  thanks.
15:06:47 <Iceland_jack> Look at the ReinH's example and see the order in which it draws the values
15:07:10 <Iceland_jack> > [ (x, y) | x <- "abc", y <- "ABCD" ]
15:07:11 <lambdabot>  [('a','A'),('a','B'),('a','C'),('a','D'),('b','A'),('b','B'),('b','C'),('b',...
15:07:15 <Iceland_jack> > [ (x, y) | x <- "abc", y <- "ABC" ]
15:07:16 <lambdabot>  [('a','A'),('a','B'),('a','C'),('b','A'),('b','B'),('b','C'),('c','A'),('c',...
15:10:58 <kuribas> > concatMap (\x -> concatMap (\y -> (x, y)) [4, 5, 6]) [1, 2, 3]
15:11:00 <lambdabot>      Couldn't match expected type ‘[b]’
15:11:00 <lambdabot>                  with actual type ‘(Integer, Integer)’
15:11:00 <lambdabot>      In the expression: (x, y)
15:11:46 <Iceland_jack> > concatMap (\x -> concatMap (\y -> [(x, y)]) [4, 5, 6]) [1, 2, 3]
15:11:48 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:11:49 <mniip> :o
15:12:39 <mniip> edwardk, right, but there is also reify-less reflection
15:12:47 <mniip> like that of KnownNat -> Integer
15:13:06 <kuribas> > flip concatMap [1, 2, 3] $ \x -> flip concatMap [4, 5, 6] $ \y -> [(x, y)]
15:13:07 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:13:33 <mniip> and the s->a fundep permits multiple s per a
15:13:33 <edwardk> mniip: sure. those are occasionally useful for folks at the top level, but we don't supply too many of them out of the box
15:13:50 <mniip> so I don't see a problem with instance Reifies () () or things like that
15:14:10 * hackagebot ms 0.1 - metric spaces  https://hackage.haskell.org/package/ms-0.1 (RickyElrod)
15:17:42 <Gurkenglas> edwardk, should Control.Comonad.Cofree contain (instance ComonadCofree [] Tree) or (levels :: (Monad m, ComonadCofree m w) => w r -> [m r])?
15:18:07 <Gurkenglas> *and/or
15:18:15 <edwardk> Gurkenglas: the former makes a ton of sense
15:18:53 <edwardk> the latter is .. interesting
15:18:58 <Gurkenglas> http://lpaste.net/136807
15:19:12 <Gurkenglas> (Might be better golfable.)
15:19:52 <greymalkin> So, is this a good design? I collect various events into a single container, interleave that into a state/writer[Output] monad, and then apply the Output events to the IO...
15:20:12 <edwardk> feel free to toss up pull requests with each if you'd like
15:20:19 <subleq> anyone who was around before, it's quite easy to do the "aToB | bToC" thing with GADTs and ExistentialTypes. http://lpaste.net/137001
15:20:30 <subleq> no dynamic typing needed!
15:20:57 <edwardk> you may get 'levels' bikeshedded on you namewise, due to the lens conflict
15:21:56 <Gurkenglas> I took the name from https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html#v:levels
15:22:03 <Gurkenglas> Suggest another?
15:22:58 <Fuuzetsu> subleq: surely the typeEq return would be better if it was Either (a :~: b) (a :~: b -> Void) 
15:23:09 <subleq> pavlicek, ChristianS, Gurkenglas, htebalaka, if youre interested http://lpaste.net/137001
15:23:30 <subleq> Fuuzetsu: yeah, otherwise the implementation of typeEq could be incorrect?
15:24:06 <Fuuzetsu> subleq: well, you're just throwing away the proof of inequality when you could make use of it elsewhere instead
15:24:10 * hackagebot datetime 0.3.0 - Utilities to make Data.Time.* easier to use (deprecated)  https://hackage.haskell.org/package/datetime-0.3.0 (jpvillaisaza)
15:24:11 <Fuuzetsu> Nothing tells you, well, nothing
15:24:29 <subleq> Fuuzetsu: but if i don't care about a proof of inequality, what does it matter?
15:24:45 <Fuuzetsu> just out of principle
15:24:48 <subleq> you have to use EmptyCase to implement it right?
15:25:17 <Fuuzetsu> don't know actually
15:28:28 <htebalaka> subleq: do lpaste posts stick around, or should i save a copy if i want to keep that for later?
15:29:10 * hackagebot datetime 0.3.1 - Utilities to make Data.Time.* easier to use  https://hackage.haskell.org/package/datetime-0.3.1 (jpvillaisaza)
15:29:51 <subleq> htebalaka: not sure, but I want to save it too, so I created https://gist.github.com/gavinwahl/8fc0f84bfdd990aac42d
15:30:13 <Twey> htebalaka: They don't vanish in general, but nobody's guaranteeing they'll be around forever
15:30:15 <htebalaka> ooh thanks
15:31:47 <Fuuzetsu> hpaste stuff disappeared off the web some time ago which left quite a few dead links
15:32:56 <Gurkenglas> Could we mirror it? lpaste's 74093 sounds like about 74 mb
15:33:03 <Twey> subleq, Fuuzetsu: I think if you want to implement (a :~: b → Void) here — and have the compiler like you — you'll actually need to case on all the possible n² combinations
15:33:19 <Gurkenglas> The public ones that is
15:34:02 <Fuuzetsu> probably
15:34:28 <forgottenone> i have problem with this code : http://pastebin.com/45xdtRsS. when i uncomment result line the value lychrelSeq !! 195 changes, can someone help me
15:34:44 <Gurkenglas> We recommend lpaste.net
15:35:58 <Twey> typeEq TInt TBool = Left $ \case of { }
15:36:03 <Twey> &c.
15:36:10 <forgottenone> Gurkenglas: ok, i'll keep in my mind
15:36:30 <rcosta_> Hi, Haskell beginner here trying to fiddle with stack but I'm getting a linking error "Undefined symbols for architecture x86_64" when doing stack build. Am I missing any step here?
15:36:33 <forgottenone> Gurkenglas: should i repaste
15:36:38 <rcosta_> I'm on OS X btw
15:36:40 <Gurkenglas> Nah I already did :P
15:36:41 <Gurkenglas> @letlpaste 6913681505743011840
15:36:41 <lambdabot>  Parse failed: Parse error: =
15:38:10 <Cale> Gurkenglas: you copied from the mangled "highlighted" output rather than the raw on pastebin
15:38:24 <Cale> Gurkenglas: pastebin mangles the indentation
15:38:38 <Gurkenglas> ah. let me retry
15:38:58 <Gurkenglas> @letlpaste 465626789062901760
15:38:59 <lambdabot>  .L.hs:144:12:
15:38:59 <lambdabot>      Ambiguous occurrence ‘unionBy’
15:38:59 <lambdabot>      It could refer to either ‘L.unionBy’, defined at .L.hs:158:1
15:41:17 <Gurkenglas> Argh. benzrf, can you make letlpaste assume one meant the L. version in ambigious situations?
15:41:37 <Cale> forgottenone: check the type of lychrelSeq in each case
15:41:49 <benzrf> Gurkenglas: sounds difficult
15:42:27 <Cale> forgottenone: The problem is that take requires an Int, but you really really want that to be an Integer
15:42:33 <Cale> So you'll want to use fromIntegral there
15:42:50 <Cale> (also, specifying the desired types of top-level definitions is generally a good idea)
15:43:21 <greymalkin> Does anyone know how to send a stdin end-of-file on the emacs Interactive-Haskell mode?
15:43:34 <Cale> forgottenone: The type of upperBound is ambiguous. Without the application of take, it gets defaulted to Integer, which is an arbitrary precision integer type.
15:43:57 <Cale> forgottenone: But with the take, it ends up being inferred to be Int, which is only machine precision, and results in an incorrect program.
15:44:08 <Cale> (because the type of upperBound affects the type of many other things)
15:45:00 <Cale> I really hate that Int is in the Prelude tbh. take/etc. should just use Integer, they wouldn't be all that much slower.
15:46:52 <forgottenone> Cale: thanks for pointing out, i would never see it on my own
15:48:57 <GlenK> h99 looks nice.  anyone know of any other haskell specific practice exercises?  Or should I just go with something generic after that?  excercism.io looks promising.
15:52:20 <pjimmy> JOIN #haskellbeginners
15:54:12 * hackagebot ms 0.2 - metric spaces  https://hackage.haskell.org/package/ms-0.2 (RickyElrod)
15:54:34 <Gurkenglas> No need to shout at the command interpreter, he should accept lower case.
15:56:12 <Gurkenglas> Is Alternative the least assumptious Pointed1 we got?
15:58:34 <pjimmy_> :)
16:04:12 * hackagebot wai-app-static 3.1.1 - WAI application for static serving  https://hackage.haskell.org/package/wai-app-static-3.1.1 (MichaelSnoyman)
16:09:52 <Gurkenglas> edwardk, should Control.Comonad.Cofree contain a modification of (hoistCofree :: Functor f => (forall x. f x -> g x) -> Cofree f a -> Cofree g a) whose callback would also have access to the node's ancestry? (Functor f => ([a] -> (forall x. f x -> g x)) -> Cofree f a -> Cofree g a)) (Tell me when these get annoying.)
16:10:15 <Gurkenglas> (The application I deduced the want for that from was take :: Alternative f => Int -> Cofree f a -> Cofree f a)
16:10:36 <Denommus> anyone here using groundhog?
16:12:12 <Gurkenglas> (Shoot, one ')' too many in my second-last line. The first from the left that violates bracket syntax.)
16:14:10 <zcs> hey all I have somehow screwed up my installation of ghc. Does anyone know the cleanest way to blast everything and reinstall ?
16:15:56 <zcs> My installation is mac osx based, and installed using a dmg
16:17:29 <Welkin> zcs: yes
16:17:37 <Welkin> remove ~/.cabal ~/.ghc
16:17:55 <Welkin> also, anything in ~/Library/Haskell
16:18:10 <Welkin> actually
16:18:20 <Welkin> if you installed using haskell platform, you can run hs-uninstall
16:18:28 <Welkin> it will remove everything
16:18:35 <Welkin> perhaps except for ~/.cabal and ~/.ghc
16:19:20 <Welkin> zcs: then download the binary for ghc here https://www.haskell.org/ghc/download_ghc_7_8_4
16:19:45 <Welkin> and cabal-install here: https://www.haskell.org/cabal/download.html
16:25:08 <sgronblo> ok what is the right way to update a package with cabal? its just not possible?
16:29:13 * hackagebot not-gloss 0.7.5.0 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.5.0 (GregHorn)
16:29:28 <Gurkenglas> (Another really obvious one that should be in there: unfold (extract &&& unwrap) :: ComonadCofree f w => w a -> Cofree f a)
16:38:06 <Denommus> wait
16:38:41 <Welkin> sgronblo: cabal install <package-name>
16:38:57 <Denommus> groundhog doesn't do its things with IO?
16:39:06 <greymalkin> Is there a safe version of unsafeInterleaveIO ?
16:39:08 <Welkin> you can unregister the old package using: ghc-pkg unregister <package-name-and-version>
16:39:13 * hackagebot wai-extra 3.0.9 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.9 (MichaelSnoyman)
16:39:15 * hackagebot http-client 0.4.17 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.17 (MichaelSnoyman)
16:39:16 <mniip> greymalkin, define safe
16:39:17 * hackagebot conduit 1.2.4.3 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.4.3 (MichaelSnoyman)
16:39:19 * hackagebot conduit-extra 1.1.9.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.9.1 (MichaelSnoyman)
16:40:11 <greymalkin> mniip: I want to take events from IO and push them through an array to my logic; I don't know why 'unsafeInterleaveIO' is called "unsafe"
16:40:53 <mniip> because it violates assumptions provided by the IO monad
16:43:06 <mniip> greymalkin, can you describe your problem in more detail
16:45:00 <greymalkin> I have a big chunk of logic wrapped in a [Input] -> StateT <PrivateADT> (Writer [OutputEvent]) (); I'm struggling to find a way to integrate that with the event loop which should do a single STM transaction, which returns an input event, and feed that through the logic.
16:45:32 <greymalkin> I could always allow the outside to see and explicitly pass the state, but that feels less elegant.
16:46:23 <greymalkin> The initial state is always the same, and the result state is unimportant, it's just the OutputEvent's that come through that I'm interested from the perspective of IO.
16:47:27 <greymalkin> So, I can use a tail-call to unsafeInterleaveIO $ atomically $ getNextEvent to construct a list of all Input events, pass that into the runLogic part... but I'm just uncomfortable with the 'unsafe' part of it.
16:47:36 <anks> is this a good way to go with parsing Data.Text with Parsec https://gist.github.com/e3ee332f59e22d1a9bba ?
16:50:01 <htebalaka> greymalkin: not sure the best way to solve your actual problem, but the order of when IO occurs is not clearly defined when using unsafeInterleaveIO, which is why it's unsafe. see http://okmij.org/ftp/Haskell/#unsafeInterleaveST for a consequence of bad things you can do with it
16:50:38 <htebalaka> tldr; you can make a function which returns a different answer if you pass it (\x y -> x == y) vs (\x y -> y == x)
16:51:44 <broma0> can any ghci expert answer a quick question?
16:53:31 <conehead> you'd have to ask that question first
16:54:20 <mniip> ^
16:54:30 <htebalaka> anks: i think its fine, though stylistically i'd prefer to refactor some of the sub-expressions into where/let clauses to make it a little more readable
16:54:37 <greymalkin> htebalaka: Okay, I think I get it; so I guess I have a different question then. How would a program written to work with e.g. `interact` maintain state without exposing that state?
16:54:56 <mniip> it can't
16:54:58 <broma0> conehead: true. is there a way to ignore errors like "The type signature for ‘test’ lacks an accompanying binding"?
16:55:02 <anks> htebalaka: thanks!
16:55:04 <mniip> also interact is lazy
16:55:11 <broma0> its sometimes nice to be able to design a program using only type signatures at first
16:55:13 <mniip> broma0, no
16:55:21 <mniip> accompany them with 'test = undefined'
16:55:42 <broma0> mniip: that gets tedious quick
16:55:48 <broma0> darn
16:57:12 <init> greymalkin: interact (f s) where f s (x:xs) = {something with x} ++ f s' xs ? 
16:57:58 <anks> :t either
16:57:59 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:59:00 <htebalaka> i think i'd need to see code to have a better idea. if you want to have a state monad where the state is encapsulated (so it's hard for callers to mess with it), you could do something like "StateT (Scan m a b) m" where "data Scan m a b = forall s. Scan (a -> s -> m (b,s)) s", and then accessing your state requires you to access the Scan (which has the actual state existentally quantified... but i'm not really sure if that's what y
16:59:09 <htebalaka> ^-- greymalkin:
16:59:54 <greymalkin> htebalaka: Yeah, that's what I was afraid of.
16:59:56 <mniip> your message was cut off
17:00:00 <mniip> "that's what y"
17:00:46 <htebalaka> weird. i see the full thing. "if that's what your asking"
17:00:48 <greymalkin> Okay, well, since I have really well defined senders and receivers (in different forkIO threads) I will probably continue with unsafeInterleaveIO... sorry to the purists
17:01:05 <greymalkin> mniip: You using irssi?
17:01:12 <mniip> no
17:01:22 <greymalkin> Huh... I got the same cutoff.
17:01:40 <mniip> the cutoff is introduced by the IRC protocol limitation
17:01:45 <mniip> between htebalaka and the irc server
17:01:53 <htebalaka> ah, that makes sense
17:02:22 <lispy> Some IRC clients will detect it and continue your message into a second message
17:02:30 <Cale> greymalkin: interact is not really intended for use in nontrivial programs
17:02:35 <greymalkin> Oh.. I didn't notice that htebalaka was the one commenting that he saw the whole message.
17:03:07 <dolio> unsafeInterleaveIO is safer than most functions with 'unsafe' in the name.
17:04:06 <mniip> unsafeInterleaveIO breaks referential transparency though
17:04:09 <dolio> No.
17:04:21 <init> unsafeInterleaveIO doesn't
17:06:00 <init> everything is still tagged with `IO`, so you know dirty stuff might happen there :P 
17:06:35 <mniip> sec
17:06:58 <dolio> Well, it would be possible for it to break it, in rare cases. But it doesn't. It has safeguards to prevent those cases.
17:08:48 <lpaste_> mniip pasted “referential transparency” at http://lpaste.net/137007
17:09:11 <htebalaka> init: i guess it depends on how much dirty stuff you want to allow. you can still end up with the case where "foo :: (a -> a -> Bool) -> IO Bool" returns a different bool for "\x y -> x == y" vs "\x y -> y =\= x", which seems above-average sinful even for IO
17:09:20 <mniip> 'ref >>= print' gives (False, True)
17:09:33 <mniip> 'fmap swap ref >>= print' gives... (False, True)
17:10:10 <dolio> So?
17:10:13 <htebalaka> i suppose in general you can always do stuff like run timeout style functions on supposedly identical pure functions to distinguish them, so maybe it's not a huge issue...
17:10:46 <mniip> dolio, if you bind the result of ref, the value of fst depends on whether snd has been evaluated or not
17:13:04 <dolio> How do you know that's what's happening, and that you're not getting nondeterministic results back from the IO actions you run?
17:14:21 <htebalaka> by looking at the code itself rather than the type. in practice you want a much stronger guarantee out of IO than "IO a is any non-deterministic value of type a"
17:14:42 <dolio> I didn't say all IO is like that.
17:14:43 <broma0> is there a way to use Control.Concurrent.Chan to model http-like request/response communication between two processes?
17:14:53 <dolio> But unsafeInterleaveIO is concurrency.
17:15:02 <mniip> dolio, when a value is bound to a variable, it cannot change
17:15:25 <dolio> So you folks should be on a campaign to rename things unsafeFork and whatnot.
17:15:40 <mniip> it's nothing to do with concurrency
17:15:48 <dolio> Wrong.
17:16:02 <dolio> The only difference is that unsafeInterleaveIO's concurrency is driven by evaluation.
17:16:03 <mniip> it's deferred execution
17:16:12 <dolio> In practice.
17:16:16 <dolio> Instead of being random.
17:16:36 <mniip> unsafeFork is even more misleading
17:17:00 <dolio> Why? It gives nondeterministic results.
17:17:04 <hpc> specifically, with unsafeInterlaveIO, the IO could be never performed at all
17:17:44 <hpc> the contract of fork is that what you tell it to do is going to happen, to the best of the runtime's ability
17:18:22 <hpc> unsafeInterleaveIO's contract is "i'll wait for you to tell me when to run, via pattern matching"
17:18:29 <hpc> which ties IO to evaluation
17:18:31 <hpc> which is unsafe
17:18:44 <dolio> Why is that unsafe?
17:18:56 <mniip> I just explained how it breaks referential transparency
17:19:08 <hpc> evaluation happens in non-IO code
17:19:19 <dolio> I don't accept that your example shows a break of referential transparency, for reasons I explained.
17:19:37 <mniip> [03:12:07] <dolio> How do you know that's what's happening, and that you're not getting nondeterministic results back from the IO actions you run?
17:19:55 <mniip> nondeterministic results after variable binding is *exactly* breaking referential transparency
17:20:42 <dolio> Okay, so 'r <- randomIO' is a break of referential transparency because the value of r is nondeterministic?
17:20:53 <hpc> i remember there being an implementation of unsafePerformIO that used only unsafeInterleaveIO
17:20:53 <mniip> it is deterministic
17:20:58 <hpc> but can't find it at the moment
17:21:08 <lispy> hpc: Yeah, was thinking I had seen one as well
17:21:17 <dolio> No, you haven't seen that.
17:21:23 <dolio> Unless it was an old bug.
17:22:39 <hpc> here's the answer: http://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe/13316620#13316620
17:22:53 <hpc> a <- unsafeInterleaveIO whatever
17:23:01 <hpc> b <- unsafeInterleaveIO differentWhatever
17:23:04 <hpc> -- now
17:23:13 <hpc> a `seq` b `seq` c -- this is different from...
17:23:18 <hpc> b `seq` a `seq` c -- this
17:23:24 <hpc> which is VERY MUCH NOT THE SEMANTICS OF SEQ
17:23:47 <dolio> You don't know that those are different.
17:24:05 <dolio> GHC can evaluate uses of seq in any order it pleases.
17:24:15 <dolio> In examples like that.
17:24:23 <johnw> that's even pointed out in the SO post
17:24:27 <dolio> Even with unsafeInterleaveIO involved.
17:24:32 <hpc> er, pseq
17:25:36 <hpc> or if you make a, b :: Bool
17:25:52 <hpc> case a of False -> case b of False -> 5
17:25:54 <hpc> is different from
17:26:00 <hpc> case b of False -> case a of False -> 5
17:26:13 <dolio> You don't know that, either. GHC is allowed to reorder those.
17:27:43 <nshepperd> it is?
17:27:46 <mniip> it is allowed from the assumption that they are the same
17:28:06 <hpc> hmm, one more try
17:28:07 <dolio> But all that doesn't really matter to my point, which is that when you say 'x <- unsafeInterleaveIO ...', the result that goes in x is determined by concurrency whose execution is ultimately driven by evaluation.
17:28:11 <bufferloss> are the 64 bit packages stable on windows 8?
17:28:21 <hpc> a <- unsafeInterleaveIO whatever
17:28:36 <hpc> (a `seq` b) has different semantics from just b
17:28:40 <bufferloss> from my experience with linux for example, at least historically, I've encountered lots of issues with 64 bit distros (though admittedly things are better now)
17:28:42 <dolio> But, you folks haven't demonstrated that you can really tell it apart from other sorts of concurrency, except that you know how it's supposed to work.
17:28:44 <hpc> even when a is not bottom
17:28:46 <nshepperd> but it does indeed matter semantically whether you evaluate a or b first
17:28:54 <bufferloss> difficulty with e.g. incompatible libraries and or incompatible 3rd party software etc
17:28:57 <hpc> (in which event a `seq` b = b, which it isn't here)
17:29:11 <nshepperd> which is what I'd call breaking ref. tramsparency
17:29:17 <hpc> dolio: would you agree i just broke the semantics of seq?
17:29:36 <dolio> No.
17:29:57 <lispy> bufferloss: I haven't had issues with 64bit ghc on windows for several releases
17:30:03 <hpc> dolio: why?
17:30:07 <lispy> bufferloss: not that I use it extensively, but I do use it
17:30:18 <bufferloss> k
17:30:23 <bufferloss> thx I'll give it a go
17:30:33 <lispy> bufferloss: the bigger issue with Haskell on windows has to do with libraries that use C code.
17:30:55 <bufferloss> lispy, indeed, as it is with most other stuff, ruby, node, python, etc
17:30:57 <lispy> bufferloss: In that case, they might expect you to install the C library before installing the Haskell code. That can be ... unpleasant.
17:31:14 <bufferloss> agreed
17:31:17 <nshepperd> dolio: wouldn't we like referential transparency to mean that we can evaluate things in whatever order we like without affecting the meaning of the program?
17:31:37 <nshepperd> unsafeInterleaveIO can break that
17:31:44 <dolio> No, that's what "purity" means.
17:32:04 <mniip> "Referential transparency and referential opacity are properties of parts of computer programs. An expression is said to be referentially transparent if it can be replaced with its value without changing the behavior of a program (in other words, yielding a program that has the same effects and output on the same input)."
17:32:07 <nshepperd> hah
17:32:09 <dolio> But also it's not breaking that, depending on what "meaning" you choose for everything.
17:32:19 <nshepperd> well, no-one agrees what purity means
17:32:33 <hpc> referential transparency has a pretty rigid meaning
17:32:35 <greymalkin> dolio: seq is pure, the variables passed in should not semantically change -- if the unsafeInterleaveIO operation behind a affects the unsafe input part of b, then whether a or b execute first is highly important.
17:33:03 * lispy gets some popcorn
17:33:30 <htebalaka> fwiw i've always thought of referential transparency and purity as being synonyms
17:34:11 <lispy> I'm a little fuzzy about RT wrt IO
17:34:13 <dolio> I think I'm done. This isn't going to go anywhere.
17:34:27 <hpc> no, it's finally going somewhere
17:35:13 <hpc> unsafeInterleaveIO exposes the runtime's evaluation strategy
17:35:49 <dolio> Prove it.
17:35:51 <bufferloss> aren't monads basically the way to handle the order sensitive stuff?
17:36:05 <nshepperd> you could write a program that implements tetris or breakout depending on which compiler you build it with
17:36:06 <dolio> And prove that forkIO doesn't.
17:36:12 <mniip> bufferloss, no, that's IO
17:36:14 <lispy> seq allows you to break RT, right?
17:36:19 <hpc> forkIO exposes an execution strategy
17:36:49 <bufferloss> mniip, what does the >>= belong to again? is that monads or functors?
17:36:53 <bufferloss> isn't a monad a functor?
17:36:55 <bitemyapp> htebalaka: they're not.
17:36:56 <mniip> monads
17:37:07 <mniip> under AMP, all monads are required to be functors
17:37:10 <bitemyapp> htebalaka: pure means "lambda calculus and nothing more", not purity ring.
17:37:28 <hpc> dolio: crash <- unsafeInterleaveIO undefined
17:37:39 <bitemyapp> purity is a property of what's in the language, not an act of performative asceticism.
17:37:42 <mniip> that shouldn't crash
17:37:42 <jle`> bufferloss: not all Functors are monads, so (>>=) can't belong to Functors, becuase not all functors can implement them
17:37:53 <hpc> dolio: in ghc, adding that line anywhere in your code won't make it crash ever
17:37:59 <hpc> until you use crash
17:38:13 <mniip> ooh
17:38:17 <mniip> nifty
17:38:21 <mniip> it's an Any
17:38:28 <hpc> dolio: i suppose you could imagine a forkIO implementation that never executes its parameter
17:38:43 <hpc> or waits until it's requested
17:38:46 <mniip> hpc, doesn't crash though
17:38:48 <hpc> but then /it's not concurrency/
17:38:58 <hpc> and it's not what users expect
17:39:16 <hpc> or how every other concurrency library has ever worked ever
17:39:25 <hpc> (exaggeration)
17:39:40 <lispy> hpc: not sure where you're going with that line of thought
17:39:50 <hpc> dolio: but more importantly
17:39:58 <dolio> hpc: forked threads can't be interrupted when no allocation occurs.
17:40:12 <dolio> Or at least, that used to be the case. So pure sections affect scheduling.
17:40:23 <hpc> dolio: that was never a specified requirement of forkIO :P
17:40:31 <hpc> more importantly
17:40:33 <dolio> Okay. We're done.
17:40:36 <hpc> crash `seq` return ()
17:40:42 <hpc> tell me that does nothing
17:41:10 <bitemyapp> dolio: that's still true re: allocation
17:41:12 <hpc> a forkIO implementation might not schedule the forked thread until after this line
17:41:37 <bufferloss> what is the purpose of the () in putStrLn :: String -> IO ()
17:41:51 <bufferloss> most function signatures (definintions?) I've seen so far don't include the ()
17:41:53 <hpc> dolio: http://lpaste.net/695692789651865600
17:41:55 <mniip> bufferloss, because IO is a monad
17:41:59 <mniip> it should return a value
17:42:01 <bufferloss> they would have written just putStrLn :: String -> Int
17:42:04 <hpc> dolio: that program never prints anything
17:42:11 <hpc> dolio: an implementation with forkIO might print something
17:42:18 <hpc> depending on the scheduler
17:42:28 <mniip> bufferloss, String -> Int is a pure function, it can't print anything
17:42:30 <bufferloss> mniip, hmm, ok, I guess I don't quite understand that, but I'll accept it for now :)
17:42:39 <jle`> bufferloss: `putStrLn "hello"` gives you an IO action that prints to the screen
17:42:44 <jle`> when executed
17:42:45 <hpc> dolio: and you can change the semantics of that program by removing "crash `seq`"
17:42:59 <lispy> bufferloss: the IO type takes a parameter. "IO ()" means the IO type takes "()", aka unit, as a type parameter
17:43:03 <hpc> dolio: http://lpaste.net/695692789651865600
17:43:10 <hpc> dolio: this program behaves like a forkIO version
17:43:14 <bufferloss> lispy, ahh, ok
17:43:15 <lispy> bufferloss: More concretely, it means putStrLn doesn't "return anything"
17:43:15 <dot_Laptop> isn't () an empty tuple?
17:43:23 <mniip> hpc, your argument is pretty moot because crash is bottom
17:43:25 <hpc> dolio: depending on the evaluation strategy ("evaluation scheduler" if you will), it may or may not print
17:43:33 <mniip> dot_Laptop, pretty much yes
17:43:34 <greymalkin> dolio: paste.net/137009
17:43:35 <jle`> dot_Laptop: () is the type that has only one value, ()
17:43:39 <bufferloss> would it be the same for any given function (i'm not sure if function is the right word?) that has a param
17:44:06 <bufferloss> like foo :: Int -> Int "takes one parameter" right?
17:44:10 <hpc> that seq changed the set of valid behaviors that program can take
17:44:11 <bufferloss> one param, one return val
17:44:13 <greymalkin> I broke out `dumbplus` to emphasize the fact that it is pure.
17:44:21 <jle`> yeah, we're mixing some terms here a bit
17:44:38 <bufferloss> I guess foo would be a data Thing = Foo x y
17:44:45 <jle`> bufferloss: an "IO a" is the type of an IO computation that would return an `a` when executed by a computer
17:44:57 <jle`> or, when executed, the *result* is an `a`
17:45:05 <nshepperd> I do see that you can create some sort of dependency on evaluation order by using forkIO and exploiting things like the garbage collecter
17:45:12 <jle`> so an `IO String` is a computation that, when executed by a computer w/ IO and stuff, produces a String
17:45:14 <hpc> mniip: damn
17:45:25 <jle`> an IO () is a computation that when executed by a computer w/ IO capabilities produces a value of type ()
17:45:35 <jle`> there's only one value of type () though, so it's just as if it returns nothing of value
17:45:45 <nshepperd> but that still seems less evil than values that can actually change underneath you *after* being bound to a variable
17:46:00 <nolrai66> Okay so I am trying to make a data type that I will be using at the type level.
17:46:04 <hpc> mniip: http://lpaste.net/695692789651865600 -- that should be a complete no-mistakes example, i hope
17:46:14 <lispy> bufferloss: putStrLn :: String -> IO (), is similar to the C type "void putStrLn(char *)"
17:46:41 <mniip> hpc, crash is still bottom though
17:47:01 <mniip> you need to do without bottoms
17:47:04 <bufferloss> in http://www.seas.upenn.edu/~cis194/spring13/lectures/08-IO.html they say I'm supposed to be able to use this http://pastebin.com/pK33Z8dQ as a minimal working example program, but mine gives me the error:
17:47:39 <glguy> bufferloss: only the second line is the example
17:47:39 <bufferloss> "The type signature for `putStrLn' lacks an accompanying binding"
17:47:41 <bufferloss> what does that mean?
17:47:45 <lispy> bufferloss: are you using that in ghci or did write it to a file and run it?
17:47:57 <glguy> bufferloss: the first line "putStrLn :: ..." wasn't part of the minimal working examle
17:47:57 <lispy> ah, you shouldn't type in putStrLn, that's provided
17:48:00 <bufferloss> lispy, I wrote it to a file and tried runhaskell hello.hs
17:48:23 <hpc> mniip: oh, i see
17:48:25 <bufferloss> ah ok
17:48:30 <kadoban> bufferloss: You wrote a type signature for putStrLn, that's not code you were meant to input. That's just showing you the type of the function.
17:48:31 <bufferloss> yeah it works if I just use print and remove the signature
17:48:43 <bufferloss> kadoban, cool yeah I get it now
17:48:51 <bufferloss> that doc is seriously pretty bad
17:49:09 <bufferloss> lots of gaps and things left unexplained that are not obvious to beginners and it's supposed to be for people who are new to haskell at least
17:49:35 <bufferloss> anyway </gripe> and thx
17:49:37 <lispy> bufferloss: you're not the first person I've seen this week in here asking for help with that guide
17:49:45 <lispy> bufferloss: but that's what we're here for :)
17:49:50 <bufferloss> lispy, cool
17:49:51 <lispy> We like helping people
17:50:26 <bitemyapp> bufferloss: it's not ideal in how it's written - it needs updated and patched up among other things.
17:50:45 <bitemyapp> bufferloss: I started an open-cis194 repository (with Yorgey's permission) to try to remedy some of this but I haven't had time.
17:51:01 <bufferloss> bitemyapp, ahh, cool, well that's cool that you've got a repo and his permission
17:51:07 <bufferloss> it's relatively good, just, yeah, lots of gaps
17:51:12 <bitemyapp> lispy: I'd recommend something else if I could find something more effective. The messiness is unfortunate but the gap between resources is large.
17:51:21 <lispy> (You can guage how much we like helping by asking basic questions about the language and getting mobbed by 10 explanations instead of "lol, go read a tutorial noob!")
17:51:22 <bufferloss> maybe not even "lots" but enough that it would make things difficult if this channel didn't exist
17:51:32 <bitemyapp> bufferloss: you're doing Spring '13 because of my guide right?
17:51:43 <bufferloss> bitemyapp, er, why yes, hello there bitemyapp :)
17:51:49 <bitemyapp> just checking.
17:51:51 <dot_Laptop> this channel is very friendly. I asked the same question a couple months back.
17:51:53 <bufferloss> I assume this is you https://github.com/bitemyapp/learnhaskell
17:51:57 <bitemyapp> bufferloss: yer.
17:52:20 <apo_> lispy: This channel's so weird =P
17:52:21 <lpaste_> greymalkin revised “Referential opacity”: “Referential opacity” at http://lpaste.net/137009
17:52:51 <bitemyapp> bufferloss: anyway, piped up to say that I know about the problems (I don't necessarily have all of them written down)
17:53:16 <bitemyapp> bufferloss: and that I am trying to find time to work on open-cis194.
17:53:41 <hpc> mniip: this is going to bug me now
17:53:46 <bufferloss> bitemyapp, yeah I feel ya
17:54:02 <hpc> coming up with a construction of unsafeInterleaveIO that breaks the rules even when you take an "evaluation can happen at any time ever" mentality
17:54:04 <bufferloss> life is what happens when I'm not programming
17:54:16 <bufferloss> actually, come to think of it, given my day job, it's also what happens when I'm programming
17:54:17 * hackagebot text-zipper 0.2 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.2 (JonathanDaugherty)
17:54:19 * hackagebot text-zipper 0.2.1 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.2.1 (JonathanDaugherty)
17:54:30 <bufferloss> I seriously need to get have less of a life so I can program more
17:56:29 <greymalkin> hpc: What's wrong with my paste for showing rulebreaking?
17:56:59 <bitemyapp> bufferloss: I've been working a lot more since two years ago. I had a lot of leisure time before. Now I barely get any reading done unless it's on audiobook for during my commute.
17:56:59 <hpc> greymalkin: oh, must have missed it
17:57:27 <hpc> ah, it didn't have http://
17:57:38 <greymalkin> Pass True and it gives me 3 in ghci, False gives me 44
17:57:55 <hpc> paste.net is down
17:57:57 <hpc> hpaste?
17:58:18 <dot_Laptop> Is there an IDE to help me with the library?
17:58:37 <dot_Laptop> maybe a plugin for a text editor?
17:58:59 <bitemyapp> @where paste
17:58:59 <lambdabot> Haskell pastebin: http://lpaste.net/
17:59:39 <greymalkin> hpc: The second update was here http://lpaste.net/137009
18:01:21 <hpc> ah, the problem is a magic compiler could decide to evaluate a and b whenever it wants in whatever order it wants
18:01:31 <hpc> and still be within the haskell spec
18:01:34 <greymalkin> Right.
18:02:06 <hpc> which still exposes the evaluation order anyway
18:02:59 <greymalkin> But more importantly, once you put that a + b bomb down three pure Monads deep in a bundle of application logic, you're going to get inconsistencies, even though the pure function `+` shouldn't cause them.
18:18:23 <Cale> greymalkin: Also, if you're relying on arithmetic operations to force evaluation so that unsafeInterleaveIO effects will occur, note that in recent GHCs:
18:18:28 <Cale> > undefined * 0
18:18:30 <lambdabot>  0
18:18:42 <Cale> ^^ multiplication sometimes won't evaluate its left argument
18:18:51 <c_wraith> how is that not a performance pessimization?
18:18:56 <bitemyapp> Cale: O_O
18:19:12 <Cale> This could be considered a bug
18:19:15 <Cale> I'm not sure
18:19:18 * hackagebot yesod-bin 1.4.12 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.12 (MichaelSnoyman)
18:19:49 <Cale> It was introduced with the changes to GMP Integer which now uses big naturals and explicit constructors for large positive and negative values
18:20:15 <Cale> (in order to sidestep stupidities regarding how GMP's actual integer library manages memory)
18:20:39 <Cale> It's possible that it was just an oversight
18:21:24 <Cale> c_wraith: It's obviously a huge win for time
18:21:36 <Cale> c_wraith: In the cases that it applies.
18:21:53 <Cale> It may cause space leaks of course.
18:22:28 <c_wraith> I just mean..  How does the extra branch to enable that not slow down the standard cases?
18:22:29 <nolrai66> > 0 * undefined
18:22:30 <lambdabot>  *Exception: Prelude.undefined
18:22:37 <nolrai66> ..
18:22:43 <Cale> c_wraith: There's going to be branching there anyway
18:23:07 <Cale> The choice has to do with whether to force both arguments immediately in the first match
18:24:35 <Cale> https://github.com/ghc/ghc/blob/ghc-7.10/libraries/integer-gmp2/src/GHC/Integer/Type.hs#L428
18:25:49 <Cale> hmm, maybe it's specifically to help with constant folding?
18:26:34 <Cale> (the 0, 1, and -1 cases being split off like that)
18:29:18 * hackagebot http-conduit 2.1.6 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.6 (MichaelSnoyman)
18:29:20 * hackagebot yesod-websockets 0.2.2 - WebSockets support for Yesod  https://hackage.haskell.org/package/yesod-websockets-0.2.2 (MichaelSnoyman)
18:30:00 <nshepperd> the compiler must be awfully smart for that to not introduce an extra branch
18:32:15 <c_wraith> I also wonder if that means strictness analysis no longer marks Integer (*) as strict
19:00:45 <jizz> Is haskell better for learning algorithm and program design than c++? Also, how does haskell compare to scheme/lisp? thanks :)
19:01:41 <hodapp> (1) probably, because C++ teaches atrocious habits, (2) Haskell is purely functional and statically-typed, Lisp and Scheme aren't.
19:02:46 <Pamelloes> Does anyone know of reliable methods for searching an Aeson Value?
19:03:18 <htebalaka> haskell has felt to me like i spend less time worrying about the peculiarities of the language and more time on the algorithms themself, but #haskell is going to be pretty biased
19:04:11 <hodapp> also, Lisp/Scheme come from a pretty different section of computer science and bring a different culture with them
19:05:00 <athan> Pamelloes: How do you mean an Aeson Value?
19:05:56 <carter> athan: probably Pamelloes  means a recursive tree of hashmaps :) 
19:05:59 <athan> Pamelloes: If you've already decoded your value, you should be able to sort/search/filter just like any other container supporting it
19:06:08 <Pamelloes> carter: Basically.
19:06:18 <carter> Pamelloes: turn it into a trie :)
19:06:27 <carter> or write a trie like interface on top
19:06:42 <Pamelloes> I have a not-decoded Value that contains a structure that won't really decode easily.
19:06:50 <Pamelloes> carter: what's a trie?
19:06:56 <carter> @google trie
19:06:56 <lambdabot> https://en.wikipedia.org/wiki/Trie
19:07:01 <athan> Pamelloes: a rose tree
19:07:11 <carter> athan: not necessarily
19:07:20 <athan> carter: Okay, a tagged rose tree
19:07:23 <athan> :P
19:07:24 <carter> sure
19:07:25 <Pamelloes> Hm, actually my problem is much simpler than that I think.
19:07:28 <carter> :)
19:07:29 <carter> cool
19:07:33 <carter> then you can solve it
19:07:47 <athan> carter: I made a predicative trie...! ._.
19:07:50 <athan> @hackage pred-trie
19:07:50 <lambdabot> http://hackage.haskell.org/package/pred-trie
19:07:55 <Pamelloes> But basicaly, there isn't a built in method for searching?
19:08:16 <athan> Pamelloes: There's got to be some kind of generic function for it
19:08:19 <carter> Pamelloes: json sin't meant for that
19:08:21 <athan> either a fold or something
19:08:26 <Pamelloes> Yeah....
19:08:29 <carter> its meant for sadness
19:08:38 <carter> and poor encodings of date and time and integers
19:08:45 <athan> carter++
19:08:49 <carter> at work an internal data rep was using aeson for a while
19:09:01 <carter> we're moving it away from that finalllyyy
19:09:04 <carter> so we can do things like dates
19:09:06 <carter> and integers
19:09:07 <carter> and stuff
19:09:09 <carter> sanely
19:09:19 <carter> theres no native notion of those in json
19:09:24 <carter> which ... gets frustrating
19:09:32 <carter> also fun bugs
19:09:46 <Pamelloes> I'm actually working with a yaml file.
19:10:00 <Pamelloes> But the yaml file gets turned into an aeson Value...
19:10:11 <Pamelloes> I think I should just turn the yaml thing into an sql database.
19:10:35 <athan> Pamelloes: Why not acid-state?
19:11:09 <Pamelloes> Hm, never heard of acid-state. It looks kind of interesting.
19:11:18 <athan> :)
19:11:56 <Pamelloes> Is there a paper somewhere on how acid state works?
19:12:01 <athan> :x
19:12:18 <zomg> I'm always a bit wary of acid-state because I have never used it in a production environment and if something went wrong with it I would have no idea what to do with it... 
19:12:24 <athan> Pamelloes: https://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html ?
19:12:32 <athan> zomg: Same here
19:12:57 <Pamelloes> zomg: Well technically my project is in production. But also not. It's a sort of quasii-hobby project.
19:13:01 * Pamelloes shrugs.
19:13:11 <zomg> Yeah
19:13:12 <Pamelloes> I'll see how it stacks up to MySQL and go from there :)
19:13:12 <Axman6> it just stores a log of all the changes to be made, and gives you access to a shared value which has had the values performed on it
19:13:17 <zomg> Hobby projects I've fiddled with it a bit
19:13:41 <carter> downside of acid state: no sql :)
19:13:46 <zomg> It's quite nice and an interesting system for sure, but a comprehensive guide would be really nice to have
19:15:48 <Pamelloes> Will acid-state work if I need two (or more) processes to access data simultaneously?
19:16:21 <athan> Pamelloes: I think a sqlite file might be better for that :\
19:16:30 <athan> if they're separate system processes, that is
19:16:35 <athan> (but then again I have no idea)
19:16:59 <Pamelloes> I currently have a MySQL database because SQlite was having performance issues with multiple processes.
19:17:02 <athan> If they're on the same executable with multiple threads, you might look in to vcache, but again I'm not sure
19:17:11 <Axman6> Pamelloes: I'd be very surprised if it works at all with multiple processes, but there are ways to use it between two processes in a client/server model
19:17:12 <athan> Well, then yeah do that :P
19:17:25 <Pamelloes> Alright :)
19:17:34 <athan> (persistent ftw >:D)
19:17:42 <athan> & esqueleto
19:17:44 <Pamelloes> persistent is pretty great.
19:18:05 <Pamelloes> It's been the best experience I've had with databases in a LOooong time.
19:18:15 * Pamelloes enjoys not having to write SQL
19:19:35 <athan> Pamelloes: ditto :). I really want to get into relational algebra semantics sometime
19:19:44 <athan> I think there's some libs that abstract that stuff away, too
19:20:31 <Pamelloes> Does anyone have a good paper explaining what the "relational" part of a relational database is?
19:21:35 <athan> Pamelloes: http://www.amazon.com/Foundations-Databases-The-Logical-Level/dp/0201537710
19:21:41 <athan> ^ which I need to read :D
19:22:16 <Pamelloes> Hm. That cover is not what I expected.
19:22:25 <Pamelloes> Looks like a children's book. hehe
19:23:03 <geekosaur> pre-relational databases did not have the concept of primary or secondary keys and relatively arbitrary joins; there were things like hierarchical databases (hardcoded master/detail) and network databases (you could point arbitrary records to each other... good luck keeping track)
19:23:34 <athan> geekosaur: So the relation prevents cycles?
19:23:39 <Pamelloes> Hm.... I don't think I use databases anywhere close to their full power.
19:23:43 <athan> s/relation/relational part
19:24:01 <geekosaur> no?
19:24:08 <athan> nvm :)
19:24:12 <johnw> "A relational database is a digital database whose organization is based on the relational model of data, as proposed by E.F. Codd in 1970. This model organizes data into one or more tables (or "relations") of rows and columns, with a unique key for each row."
19:24:35 <Pamelloes> Hm, that sounds right.
19:24:45 <athan> something something: http://thinkaurelius.github.io/titan/
19:24:45 <monochrom> recall your set theory class in which a relation is a set of tuples
19:24:56 <geekosaur> relational model imposed a rational structure and provided a way to connect that structure. pre-relational was kinda WIld West
19:25:16 <Pamelloes> monochrom: I've never taken anything on Set Theory....
19:25:43 <athan> Pamelloes: a relation is a tuple, basically (right?)
19:25:48 <monochrom> object-oriented databases are network databases again
19:25:52 <Dodek> a set of tuples
19:25:56 <Pamelloes> Right....
19:25:59 <athan> thanks :)
19:25:59 <monochrom> no, a relation is a set of tuples, not a tuple
19:26:08 <Pamelloes> Wait, a tuple as in (row,column)?
19:26:19 <Pamelloes> Or (key,value)
19:26:30 <Pamelloes> Wait. Tuple. Not 2-tuple.
19:26:32 <monochrom> no, a tuple is a row. (key, value) comes close
19:26:36 <athan> or {(a,b) | a <- A, b <- B}
19:27:05 <Pamelloes> So a relation basically means a row?
19:27:16 <monochrom> because in reality it's going to be (student number, student name, student email address, student login name, ...)
19:27:16 <athan> and an injective relation ~ function? Or something? :s
19:27:35 <monochrom> no, a relation is a set of tuples, i.e., a set of rows.
19:27:47 <Pamelloes> So like a table?
19:27:58 <monochrom> why do people keep "simplifying" "a set of items" to "an item"?
19:29:07 <athan> monochrom: I usually blame Obama
19:29:31 <Pamelloes> athan: You should blame Trump instead.
19:29:58 <monochrom> no, I think of it as an irrational urge to be imprecise
19:30:43 <geekosaur> Pamelloes, "table" is the modern term used, "relation" is the term Date used in defining relational theory
19:31:03 <Pamelloes> geekosaur: Oooooooh
19:31:05 <geekosaur> Codd and Date
19:31:20 <Pamelloes> Alright. I feel much better about the whole database thing now :)
19:32:01 <Pamelloes> Knowing relation=table means that there's no longer a whole dimension to relational databases I don't know about :D
19:32:17 <geekosaur> you also see field vs. column, same story
19:32:36 <geekosaur> although field is also from older databases
19:32:41 <athan> Pamelloes: "You're fired!"
19:32:44 <geekosaur> and row vs. record
19:32:51 <Pamelloes> athan: --Abaraham Lincoln
19:32:57 <athan> haha
19:33:56 <monochrom> some relations are functions. when you see one such relation, you say that one column "has a functional dependency" on another column.
19:34:20 <monochrom> this is exactly where multiple parameter type class's "functional dependency" comes from
19:34:25 <Pamelloes> Ok. I understand that.
19:35:32 <monochrom> multiple parameter type class basically borrows from relational databases
19:36:10 <monochrom> a type class is a table. each instance declaration is a row.
19:36:28 <Pamelloes> huh
19:36:41 <monochrom> unfortunately they haven't thought of joining two type classes yet
19:36:44 <dot_Laptop> Hello. I'd like to try multithreading in Haskell. http://lpaste.net/137021 . Now both thread tries to write to stdout at the same time, resulting interleaved string. Is there a way to prevent this?
19:37:07 <Pamelloes> monochrom: What would that mean?
19:37:19 <Pamelloes> (also how does one join a table?)
19:37:34 <monochrom> join two tables. not one.
19:37:46 <Pamelloes> That's what I meant ;)
19:38:06 <monochrom> I am too lazy to define it. read up on relational database explanations.
19:38:50 <Pamelloes> yep, just looked it up.
19:39:25 <Pamelloes> So if two relations have a field in common, they can sort of be merged around that field.
19:39:45 <the_modulator> Would I be better off learning Haskell or a Lisp (more than likely Scheme)? I only have enough time to start and work with one of them, so, I'd like to hear the opinions of others on this matter. :)
19:40:45 <monochrom> I have two answers. one you like to hear, but a lie. one you hate to hear, but the truth.
19:41:14 <Pamelloes> Say both, but don't say which is which.
19:41:31 <monochrom> learning haskell is better. this is a lie. since I don't even know your goals or your personality.
19:42:02 <Pamelloes> 'tis a good lie. Haskell is great.
19:42:10 <monochrom> you need to tell us everything about yourself before a meaningful answer can be given. this is the painful truth.
19:43:13 <monochrom> actually, the even more painful truth: if you do that, you're looking for counselling, which means you should pay.
19:43:23 <geekosaur> heh
19:44:21 * hackagebot foldl 1.1.1 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.1 (GabrielGonzalez)
19:44:47 <geekosaur> practical answer: asking whether haskell is worth the time in a chat room dedicated to haskell is questionable; you kinda know what the answer will be :)
19:46:40 <ttt_fff> in haskell, what happens with a pattern match succeeds but the guard condition fails?
19:47:19 <monochrom> then try the next guard. if no next guard, try the next pattern.
19:47:46 <monochrom> shouldn't you simply set up an experiment to find out?
19:47:56 <monochrom> the scientific method is the best learning method.
19:48:11 <the_modulator> monochrom: I'm looking for a functional language that will help me improve my algorithm design, due to having experience in the functional paradigm. I'm also looking for a functional language that will be useful in the long-run as well.
19:49:38 <monochrom> if no one allows you to use mutable state variables, do you feel insecure?
19:49:45 <Welkin> the_modulator: you can do everything with haskell
19:49:47 <Welkin> it is general purpose
19:50:09 <Welkin> it has plenty of DSLs for anything from javascript, to embedded systems, and even FPGA and hardware design
19:52:33 <redcoat> How many of you are aware that for about a year, Philip Wadler and Simon Peyton Jones took a year sabbatical to add a type system to Erlang?
19:52:33 <ttt_fff> monochrom: yean, but I'm looking at that's ahppening in reality
19:52:40 <ttt_fff> and it doesn't fucking match my mental model of how patterns/guards work
19:52:51 <the_modulator> Welkin: Will it help with my mental picturing of programming ideas and creation of better algorithms?
19:52:52 <ttt_fff> i.e. I'm staring at my code, and wondering why the fuck does this pattern match / gaurd fail? why does it fall through to the final catch all
19:52:59 <Welkin> the_modulator: absolutely
19:53:01 <ttt_fff> and I'm like it has to be because I am misunderstandin how guards / pattern matches work
19:53:09 <Welkin> it wil make you love math even more than you do now
19:53:15 <Welkin> or if you don't lik math, it will make you love it
19:53:19 <Axman6> the_modulator: Haskell would be a good choice then. It forces you to work functionally and is used by many people in many industries these days.
19:53:40 <monochrom> this is why the scientific method is the best learning method. you change your mental model to comply with reality, not ask IRC to change reality to comply your mental model
19:54:22 <Welkin> the_modulator: the way you solve problems in functional programming is quite different than how you would do it in an imperative language
19:54:38 <geekosaur> ttt_fff, maybe pastebin the code in question?
19:54:42 <Welkin> you think in terms of solution spaces, and then appluy constraints to narrow the solution space until you arrive at an answer
19:54:55 <monochrom> also, it says: use a simpler example such that only one factor is at work. as opposed to 20 lines of code which clearly contains 10 moving parts and 15 factors so you never know what causes what.
19:56:09 <the_modulator> I'm not asking IRC to change reality. I'm asking for your opinions on which language you feel would be more preferable for my end goals, so *I* can attempt to change my mental model on my own. :)
19:56:29 <monochrom> no, I don't mean you
19:57:09 <the_modulator> Welkin: I hear that the functional paradigm will improve my algorithm design in imperative languages.
20:02:04 <ttt_fff> OMG
20:02:07 <ttt_fff> I figured out what is wrong
20:02:17 <ttt_fff> this has to be the most completely regarded error ever
20:02:49 <Welkin> the_modulator: yes, perhaps in that it will force you to consider mutable vs immutable data
20:03:20 <the_modulator> Do any of you have some side-by-side Haskell and, say, C++/C code, so I can kind of get an idea of how different the executions of and solutions for Haskell are in comparison to popular imperative languages?
20:04:18 <monochrom> you know what, I don't, since I'm too lazy to write the C++/C code
20:04:31 <Welkin> well, you can write the same algorithms in an imperative style in haskell
20:04:56 <Welkin> it requires extra work (and more code) than doing it in a purely functional way
20:05:23 <Welkin> however, there are different algorithms (and data structures) that work well with functional programming
20:05:43 <Welkin> most classical algorithms are imperative (i.e. quicksort)
20:06:22 <monochrom> for example just recently I write a few lines of code for this: you know how Scrabble comes with 100 tiles, each marked with a letter or blank. what are the possibilities (and how many) if I draw 7 tiles from the 100?
20:07:01 <monochrom> I completely don't want to write it in C or even Modula. regardless of paradigm.
20:09:10 <monochrom> (a "possibility" means: if I get 7 A's, that's 1 possibility. if I get 5 A's 2 B's, that's 1 possibility. if I get 3 A's 2 C's 2 E's, that's 1 possibility)
20:09:23 * hackagebot hailgun 0.4.0.2 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.0.2 (RobertMassaioli)
20:11:06 <monochrom> later on I'm going to add this on: for each possibility, what is its probability? (that's just hypergeometric distribution, simple formula.) and also, what is the highest score word I can form from the 7 tiles, and the score?
20:11:28 <monochrom> (the latter requires deciding on a dictionary to use first, yes)
20:12:25 <monochrom> then I can sum up all these and compute: the expected value of the score (before those doubling and tripling bonuses) the first player can get in the first turn.
20:12:56 <the_modulator> Can I see some relatively basic Haskell code to get an idea of how succinct the language is in comparison to C++ or C?
20:13:04 <monochrom> I completely don't want to do this in mainstream languages
20:13:44 <monochrom> you know what, www.haskell.org has one on the front page
20:14:23 * hackagebot range 0.1.2.0 - This has a bunch of code for specifying and managing ranges in your code.  https://hackage.haskell.org/package/range-0.1.2.0 (RobertMassaioli)
20:14:30 <peterson> the_modulator: Haskell .. (1) you will get significant benefit from the _types_ which you won't get in scheme / lisp / clojure etc .. (2) i believe you will come to find the syntax of Haskell more appealing than the nested s-expr nature of lisps
20:14:34 <the_modulator> monochrom: The difference is that substantial? You make it sound like learning Haskell will make me HATE C++ and C. :P
20:14:37 <peterson> the_modulator: just my opinion of course .. but i have played with lisp / scheme / clojure over many years, and more recently focused again on haskell, in part for the reasons above. HTH.
20:14:42 <the_modulator> THanks for the links, btw.
20:15:17 <peterson> redcoat: i was aware of Wadler but didn't realise SPLJ did too
20:15:24 <peterson> Axman6 it's forcing me right now :)
20:16:06 <peterson> the_modulator: agree with the earlier observation re selection bias .. coming to channel #blub and asking 'is blub worth learning' is likely to elicit a predictable response .. :) .. i would suggest the only way you can truly evaluate X vs. Y is to try X and Y yourself and see how you get on. HTH.
20:16:31 <peterson> the_modulator: that said, having touched (over many years) the following: scheme, lisp (SBCL), erlang, haskell (1st try) .. then off into Java and Ruby land for n years .. now back recently to haskell (and having looked at OCaml and Scala too), I find Haskell a good fit for what I'm trying to achieve, and for how my mind works. Again just a single data-point of course. Best of luck.
20:17:16 <peterson> the_modulator: a few examples here
20:17:17 <peterson> https://wiki.haskell.org/Introduction
20:17:18 <peterson> (of course qsort is a bit of a "canonical" haskell / FP example, but FWIW anyway)
20:17:30 <redcoat> peterson: The author of Learn You Some Erlang mentioned it and both names surprised me. But the fact that functional language designers have their hands in so many cookie jars is not surprising.
20:17:57 <peterson> the_modulator again FWIW here are some sorting examples in different languges: https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort
20:18:07 <peterson> the_modulator: and you might want to read this recent paper that re-caps a famous paper in the FP/Haskell community, 25 years on:
20:18:08 <peterson> http://nsr.oxfordjournals.org/content/early/2015/07/13/nsr.nwv042.full.pdf#page=1&view=FitH
20:18:09 <peterson> HTH 
20:18:13 <peterson> the_modulator some good stuff there on concepts such as parametricity, equational reasoning, and monadic contexts
20:18:14 <peterson> gtg ..
20:18:23 <redcoat> And I think that's a good fact to cite if someone who uses Haskell decides to stomp all over dynamically programmed languages; Philip Wadler and SPJ are great fans of Lisp and Erlang.
20:18:50 <the_modulator> peterson: Thanks for all of the information.
20:18:58 <monochrom> well, I really prefer static typing.
20:19:32 <redcoat> So do I, but preference is far more mild than zealotry.
20:19:43 <peterson> redcoat agree .. Wadler and SPLJ are amazing PL researchers who have made contributions across all kinds of languages
20:19:43 <monochrom> so I decide to stomp all over dynamically typed languages. and if Wadler and SPJ are fans of them, I'll decide to stomp over Wadler and SPJ, too
20:19:44 <peterson> redcoat: Wadler's work on generics for Java is another great exmple
20:19:45 <peterson> the_modulator: you're welcome. best of luck.
20:20:13 <monochrom> and if Buddha is a fan of Lisp, I'll stomp over Buddha
20:20:17 <redcoat> peterson: Don Syme like to talk about how he works literally down the hall from SPJ. Or used to, I don't know if that's changed since.
20:20:53 <redcoat> (Don Syme is the principal developer of F# for .NET. It's a nice language, with monads.)
20:21:14 <peterson> monochrom: i agree typed languages have their advantages but i don't know i'd go that far ;)
20:21:25 <init> what's the point of "having monads" if you can't write generic code over them?
20:21:44 <redcoat> A monad is a higher kinded type. It is by definition generic.
20:22:07 <redcoat> oh
20:22:08 <monochrom> I think F# is generic enough for that, no?
20:22:15 <redcoat> No, init's right, F# is not
20:22:30 <redcoat> (I'm sorry, I misread your comment)
20:22:34 <monochrom> ok, one more thing to stomp over :)
20:22:54 <redcoat> monochrom: It is .NET's fault. They get by okay.
20:23:09 <geekosaur> F# still has to fit into the CLR's type system, which isn't quite generic enough
20:23:31 <the_modulator> It seems like Haskell has recently had an upsurge in popularity? How so? Why has its community, over recent years, increased tenfold? I'm just wondering what has drawn in this newfound appeal is all.
20:24:22 <ttt_fff> it's due to a recent ghc feature
20:24:27 <ttt_fff> ghc --wash-dishes
20:24:30 <ttt_fff> ghc --clean-room
20:24:34 <ttt_fff> ghc --sudo-make-me-a-sandwich
20:25:07 <geekosaur> heh
20:25:13 <redcoat> the_modulator: Two big things, which can be divided into smaller things. The first is a feedback system. PL researchers like how expressive Haskell is and port features (monads, typeclasses) to other languages (F#, Scala, Rust). Those users of those languages here about where the features came from and come runing over here to see what all the fuss is about.
20:25:17 <monochrom> good optimizing compiler and the Streisand effect
20:26:20 <redcoat> the_modulator: Two, people really like the language and tell their friends about it.
20:26:34 <geekosaur> Haskell has been creeping slowly into mainstream awareness, in part because places like Facebook started using it and Amazon has been using Haskell programming questions as prescreens for the past several years
20:26:52 <geekosaur> at some point that reached critical mass
20:27:11 <redcoat> the_modulator: Anyway, I don't think programming in Haskell will make you better at using imperative languages. It will just make you want to use Haskell.
20:27:15 <init> functional programming has been becoming a more "mainstream" thing as time goes on
20:27:34 <init> and if you pretty much try to "see what it is about", you'll find Haskell quite fast 
20:27:50 <redcoat> init: But they will never accept monads into the mainstream, for some reason.
20:28:15 <init> their languages aren't powerful enough for that ;)
20:28:25 <init> anyway, monads aren't that much of a thing either
20:28:45 <init> what about lenses?
20:28:58 <redcoat> Comonads. :)
20:30:20 <nitrix> Are there videos of people writing projects in Haskell that I could just watch?
20:30:22 <nitrix> I know it sounds strange, but seeing something being built from the ground up with explanations sounds appealing to me.
20:36:46 <shergill-web> edwardk: ping
20:40:08 <shergill-web> could someone ( edwardk included), help shed light on what "all the lazy state and lazy writer examples" allude to in the following reddit comment: http://www.reddit.com/r/haskell/comments/39wpi8/fusion_for_free_efficient_algebraic_effect/cs7np9z ?
20:42:00 <nshepperd> the most exciting new feature in ghc, -XDWIM
20:43:20 <nshepperd> though, maybe you really could bake the djinn into some TemplateHaskell and be able to write foo :: Foo -> Bar; foo = $(dwim)
20:44:21 <nshepperd> that would be pretty good
20:44:24 * hackagebot total 1.0.4 - Exhaustive pattern matching using lenses, traversals, and prisms  https://hackage.haskell.org/package/total-1.0.4 (GabrielGonzalez)
20:50:42 <EvanR> in the category Hask of types and functions between types, how is a type constructor like Maybe represented. Maybe is an endofunctor? what about Either?
20:51:14 <funfunctor> Hi EvanR how are you?
20:51:17 <EvanR> a functor in some sort of composition category
20:51:43 <EvanR> funfunctor: good
20:52:31 <funfunctor> :)
20:52:56 <funfunctor> @hoogle (a, a) -> f a -> (f a, f a)
20:52:57 <lambdabot> No results found
20:52:58 <EvanR> basically im wondering where polymorphic types fit in
20:57:16 <arkeet> EvanR: Either is a functor from Hask x Hask to Hask.
20:57:27 <arkeet> (internally, a Bifunctor)
20:58:03 <EvanR> how would you classify type classes
20:59:25 * hackagebot silently 1.2.5 - Prevent or capture writing to stdout and other handles.  https://hackage.haskell.org/package/silently-1.2.5 (SoenkeHahn)
21:12:21 <funfunctor> @hoogle round
21:12:21 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
21:12:22 <lambdabot> package rounding
21:12:22 <lambdabot> Data.Text.Internal.Builder.RealFloat.Functions roundTo :: Int -> [Int] -> (Int, [Int])
21:15:03 <funfunctor> How do you round a Float to one decimal place?
21:16:54 <mniip> funfunctor, multiply by 10, round, divide by 10
21:21:27 <lispy> I wonder if that has corner cases due to precision limitations
21:22:02 <funfunctor> and what about all the trailing zeros, I don't think that is a good way to do it..
21:22:24 <lispy> You mean when you show the rounded number?
21:23:11 <lispy> funfunctor: if your trying to display the number rounded (and not use the rounded number) you could use printf https://hackage.haskell.org/package/base-4.8.0.0/docs/Text-Printf.html
21:26:12 <funfunctor> oh I thought printf was IO monadic
21:27:49 <Cale> funfunctor: It's polymorphic in such a way that it can result in either an IO action or a String, depending on what you ask for.
21:30:06 <lispy> > printf "%.4f" pi :: String
21:30:08 <lambdabot>  "3.1416"
21:30:09 <funfunctor> Cale really!?
21:30:41 <funfunctor> > printf "%.2f" 123.456 :: String
21:30:42 <lambdabot>  "123.46"
21:30:48 <mniip> welcome to evil typesystem hacks
21:32:54 <subleq__> Is there a tutorial anywhere on writing showsPrec?
21:33:45 <lispy> subleq__: I found an example once, and it might have been in the haskell report?
21:34:26 * hackagebot limp 0.3.2.1 - representation of Integer Linear Programs  https://hackage.haskell.org/package/limp-0.3.2.1 (amosrobinson)
21:34:28 <lispy> subleq__: section 10.4 https://www.haskell.org/onlinereport/derived.html
21:35:07 <subleq__> lispy: thanks
21:54:35 <aupiff_> I'm trying to do a word count as efficiently as possible on a document. I am tyring to get a result like [(Text, Int)], a list of tuples of (word, number of occurences). I am currently using `Data.Text.words` to initially break up the text file. is there something more efficient that I should consider? 
21:55:59 <EvanR> Data.Text.words should be already optimized
21:56:27 <EvanR> how you count the words is another story
21:58:36 <EvanR> fold over the words keeping the count updated in a Map
21:58:49 <aupiff_> yeah, is there any sense in doing `Data.Vector.fromList` so that I can use `vector-algorithms` to sort, then recurse on the sorted list doing `Data.Vector.span` until I've consumed all groups of identical words?
21:59:11 <aupiff_> I wasn't even using a map, I thought it'd be faster to sort the list of words
21:59:19 <aupiff_> then do Map.fromList
21:59:32 <EvanR> it would be simpler to sort, group, and count each groups length
21:59:45 <EvanR> but I don't know if that will be more efficient
21:59:58 <aupiff_> map insertion is expensive
22:00:02 <aupiff_> O(log n)
22:00:19 <EvanR> alternatively, map insertion is cheap, O(log n)
22:00:32 <EvanR> and counting a list is expensive
22:00:35 <EvanR> O(n)
22:01:21 <EvanR> and sorting the whole document in the first place, O(n log n)
22:01:22 <aupiff_> right, but that insertion happens n times for the list.
22:01:51 <aupiff_> so we do sum i = 0 to n { (log i) }
22:02:18 <aupiff_> well, you expect some repeated words, so not exactly
22:02:55 <EvanR> I think its a toss up, close enough that O doesn't indicate real world performance
22:03:01 <EvanR> so I'd go with the simpler one
22:05:24 <aupiff_> do you have a rule of thumb of when to use data.vector for sorting, folding, mapping purposes? when it's worthwhile to convert from data.list?
22:06:43 <Pamelloes> Is there an easy way to delete everything in a persistent database?
22:07:38 <Pamelloes> Sorry, I meant table--not the whole database.
22:07:59 <EvanR> aupiff_: my rule of thumb is vector has no practical benefit for sorting folding or mapping
22:08:14 <EvanR> only !!
22:08:59 <EvanR> which is why list is so much more popular in functional programming than vectors/arrays
22:08:59 <aupiff_> mmm. good to know!
22:10:06 <EvanR> i mean, you usually dont want to get caught doing !! most of the time
22:33:32 <athan> Would anyone object to me making a matroid lib?
22:33:40 <athan> it's probably going to be useless anyway!
22:44:58 <iheartmonadsnot> hi gang
22:45:09 <iheartmonadsnot> anyone online?
22:45:30 <iheartmonadsnot> anyone!?
22:46:00 <archaephyrryx> greetings everyone
22:46:03 <iheartmonadsnot> :type id
22:46:17 <iheartmonadsnot> > :type id
22:46:18 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:46:20 <peddie> :t id
22:46:21 <lambdabot> a -> a
22:46:24 <iheartmonadsnot> thanks
22:46:57 <iheartmonadsnot> :t mapM readFile ["namesOfFiles.files"]
22:46:58 <lambdabot> IO [String]
22:46:59 <archaephyrryx> i stumbled upon a mostly deprecated GUI library called Fudgets
22:47:12 <iheartmonadsnot> lol Fudgets
22:47:15 <archaephyrryx> has anyoen ever heard of or used it before?
22:47:25 <iheartmonadsnot> nope
22:47:27 <archaephyrryx> its mostly deprecated
22:47:37 <iheartmonadsnot> what u want it for?
22:47:46 <iheartmonadsnot> i tend to avid depriciated things...
22:48:07 <archaephyrryx> it's only deprecated because it hasn't been maintained all that much in recent years
22:48:17 <archaephyrryx> it might be salvagable
22:48:29 <iheartmonadsnot> :t mapM readFile ["namesOfFiles.files"]>>=concat
22:48:31 <EvanR> that was an early FRP gui experiment right
22:48:31 <lambdabot>     Couldn't match type ‘[]’ with ‘IO’
22:48:31 <lambdabot>     Expected type: [String] -> IO Char
22:48:31 <lambdabot>       Actual type: [[Char]] -> [Char]
22:48:35 <archaephyrryx> yea
22:48:48 <EvanR> try maybe Reactive Banana
22:48:51 <iheartmonadsnot> cooool
22:49:25 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= concat
22:49:26 <lambdabot>     Couldn't match type ‘[]’ with ‘IO’
22:49:26 <lambdabot>     Expected type: [String] -> IO Char
22:49:26 <lambdabot>       Actual type: [[Char]] -> [Char]
22:50:18 <peddie> :t concat
22:50:19 <lambdabot> Foldable t => t [a] -> [a]
22:50:36 <peddie> :t (>>=)
22:50:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:51:01 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= return.concat
22:51:02 <lambdabot> IO [Char]
22:51:38 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= concat >>= putStrLn
22:51:39 <lambdabot>     Couldn't match type ‘[]’ with ‘IO’
22:51:40 <lambdabot>     Expected type: [String] -> IO Char
22:51:40 <lambdabot>       Actual type: [[Char]] -> [Char]
22:51:53 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= return.concat >>= putStrLn
22:51:54 <lambdabot> IO ()
22:52:01 <iheartmonadsnot> this throws an error
22:52:03 <iheartmonadsnot> at compilation
22:52:39 <iheartmonadsnot> > putStrLn "hello"
22:52:40 <lambdabot>  <IO ()>
22:52:51 <iheartmonadsnot> putStrLn "hello"
22:52:55 <peddie> iheartmonadsnot: do you know what return and (>>=) mean?  concat is not a monadic action, there's no need to use >>= to be able to apply it
22:53:15 <iheartmonadsnot> i read a file...
22:53:17 <EvanR> to get the types to match up you can replace concat with fmap concat
22:53:32 <iheartmonadsnot> mmm fmap...
22:53:39 <EvanR> concat :: [[a]] -> [a]
22:53:40 <peddie> or just use 'putStrLn . concat'
22:53:48 <EvanR> fmap concat :: IO [[a]] -> IO [a]
22:54:06 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= putStr.concat
22:54:06 <lambdabot> IO ()
22:54:16 <peddie> iheartmonadsnot: if you want help with an error, can you put your code on lpaste along with the error?
22:54:25 <peddie> @where paste
22:54:26 <lambdabot> Haskell pastebin: http://lpaste.net/
22:54:30 * hackagebot hailgun 0.4.0.3 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.0.3 (RobertMassaioli)
22:54:33 <iheartmonadsnot> thanks
22:55:41 <iheartmonadsnot> i was just trying to reproduce the error in minimum code...
22:55:46 <iheartmonadsnot> the full file is here
22:55:46 <iheartmonadsnot> http://lpaste.net/137026
22:56:09 <iheartmonadsnot> i get resource is locked file is busy
22:56:19 <certainty> moin
22:56:24 <iheartmonadsnot> when trying to write references.lhs
22:56:30 <peddie> that's not really a compiler error, is it?
22:56:38 <iheartmonadsnot> ill continue trying to reproduce the error in less code
22:56:57 <peddie> please do, could you also put the exact error text in a comment in the file?
22:57:11 <iheartmonadsnot> um, i think its because when it evaluates it is reading the files one after the other and trying to write them to an already open file
22:57:25 <peddie> "resource is locked file is busy" sounds like an exception you'd get from a file that's locked or something like that
22:57:31 <EvanR> dont read and write the same file at the same time
22:57:46 <EvanR> bad for your mental health
22:57:49 <peddie> oh, are you writing to and reading from the same filehandle?
22:57:50 <peddie> youch
22:58:50 <iheartmonadsnot> um im trying to concatinate seperate files into one
22:58:52 <iheartmonadsnot> -- running main results in error *** Exception: references.lhs: openFile: resource busy (file is locked)
22:59:23 <iheartmonadsnot> :t (mapM readFile ["namesOfFiles.files"])  >>= (appendFile "out.txt").concat
22:59:24 <lambdabot> IO ()
22:59:30 * hackagebot limp-cbc 0.3.2.1 - bindings for integer linear programming solver Coin/CBC  https://hackage.haskell.org/package/limp-cbc-0.3.2.1 (amosrobinson)
22:59:32 <iheartmonadsnot> i think that should have the same error
23:00:09 <peddie> is "out.txt" in your list of filenames?
23:01:04 <peddie> also, if you google the error (without even saying "haskell"), you get https://stackoverflow.com/questions/5053135/resource-busy-file-is-locked-error-in-haskell
23:02:21 <iheartmonadsnot> you think i need to flush something, that guys error looks like he should flush stdin
23:02:43 <EvanR> er, flush stdin?
23:03:00 <peddie> he's not using stdin
23:03:47 <EvanR> dont try to flush stdin
23:03:49 <iheartmonadsnot> o sorry, i thought it was jammed by getLine, its jammed by readFile
23:03:52 <iheartmonadsnot> kk
23:04:23 <iheartmonadsnot> so im using _<-getLine to ensure my IO opperations complete before others start
23:04:36 <iheartmonadsnot> but then if i press enter too rapidly my program breaks, this is bad
23:04:46 <EvanR> you dont have to do _ <- getLine, just getLine will have the same effect
23:05:13 <peddie> don't try to use getLine for that.  that's not what it's for, _and_ it doesn't actually fix the problem
23:05:29 <iheartmonadsnot> well, so how to do this without manually jamming the opperation, cant haskell pause until an operation is complete??
23:05:37 <peddie> I think the second answer to the question I linked will explain what's going on here
23:05:38 <iheartmonadsnot> yes peddie: you are right
23:06:18 <iheartmonadsnot> i know whats going on, in such situations i use getLine and just wait for the opperation to complete
23:06:45 <iheartmonadsnot> ohhhhh i should use the strict package?
23:07:04 <peddie> I suggest a different solution than dons: write to a different file and then rename the new file atop the old one once you've closed the filehandle to which you're writing
23:07:13 <peddie> but you could use the strict package
23:07:41 <iheartmonadsnot> im not reading and writing from the same file
23:08:09 <iheartmonadsnot> the error i guess is cos it asyncronously reads many files and tries to write them all at the same time to one file
23:08:21 <iheartmonadsnot> i thought concat would solve this by collecting them into one string
23:08:48 <EvanR> why do you think its asynchronously reading many files
23:08:57 <peddie> are you sure you aren't accidentally reading and writing from the same file?  I don't think your guess is right (I think if you call writeFile once, you're going to get a single write)
23:09:03 <ttt_fff> is there a simpler way to write https://gist.github.com/anonymous/2696b101a689857e0939 ? something more condensed
23:09:22 <EvanR> :t readFile
23:09:23 <lambdabot> FilePath -> IO String
23:09:30 <EvanR> oh lazy IO
23:09:58 <EvanR> gross
23:11:29 <nshepperd> 'readFile :: FilePath -> IO Text' is strict \o/
23:12:00 <jle`> ttt_fff: you can do al <* shiftDown id
23:12:08 <ttt_fff> actually, I defined a function
23:12:10 <ttt_fff> bracket
23:12:14 <ttt_fff> bracket :: m () -> m a -> m () -> m a
23:12:18 <jle`> if you want to do it totes applicative style, this would be
23:12:18 <peddie> iheartmonadsnot: it looks from your code like you might be accidentally reading your output file if it already exists, just because you're using getCurrentDirectory >>= getDirectoryContents
23:12:19 <ttt_fff> its' a pattern that shows up all the time
23:12:25 <jle`> shiftUp id *> al <* shiftDown id
23:12:29 <EvanR> bracket is already taken as a standard name, in Control.Exception
23:12:36 <iheartmonadsnot> im here, just trying to write a short version of the error...
23:12:45 <jle`> :t \x y z -> x *> y <* z
23:12:46 <lambdabot> Applicative f => f a1 -> f a -> f b -> f a
23:13:02 <iheartmonadsnot> BOOM you got it
23:13:05 <iheartmonadsnot> damn
23:13:12 <jle`> also it might be a little confusing to use `id` as a parameter name, heh
23:13:13 <iheartmonadsnot> i was debugging for hours
23:13:14 <iheartmonadsnot> thanks
23:13:32 <jle`> ttt_fff: shiftWith f al = shiftDown f *> al <* shiftUp f
23:13:34 <peddie> no problem -- I might suggest you dig a little more into lazy IO just to understand why the problem occurs :)
23:13:42 <jle`> er, switch up and down
23:13:57 <ttt_fff> :t (*>)
23:13:58 <lambdabot> Applicative f => f a -> f b -> f b
23:13:58 <EvanR> irl you should use an alternative to lazy IO
23:14:04 <ttt_fff> :t (*<)
23:14:05 <jle`> ttt_fff: (*>) is (>>)
23:14:05 <lambdabot>     Not in scope: ‘*<’
23:14:06 <lambdabot>     Perhaps you meant one of these:
23:14:06 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
23:14:10 <ttt_fff> :t (<*)
23:14:11 <lambdabot> Applicative f => f a -> f b -> f a
23:14:20 <EvanR> like pipes
23:14:32 <jle`> (<*) is (>>), but the result of the first is returned, not the second
23:14:35 <iheartmonadsnot> yar, ill use strict stuff soon im sure, right after i learn what is a lens. and after everything is implicity passed through realToFrac and fromIntegral...
23:14:43 <ttt_fff> this looks like witchery we should put jle` in trail
23:14:50 <jle`> (>>) sequences two actions and returns the result of the second; (<*) sequences two actions and returns the result of the first
23:14:55 <jle`> this is normal applicative style heh
23:14:58 <jle`> it's used often in parsers
23:14:59 <EvanR> iheartmonadsnot: o_O
23:15:03 <iheartmonadsnot> burn him!!
23:15:08 <ttt_fff> jle`, yea, I think this makes sense now
23:15:18 <ttt_fff> *> ignores the shiftUp, and <* returns the inner, ignoring the shiftDown
23:15:24 <jle`> yeah, it's something that you see often when writing parsers
23:15:25 <ttt_fff> so it amkes sense :-)
23:15:42 <jle`> payload <* spaces will parse the payload, then whitespaces, and then return the payload's result
23:15:53 <ttt_fff> yeah, but I like my word 'bracket'
23:15:59 <EvanR> :t bracket
23:16:00 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:16:03 <ttt_fff> even if it's not asn ascii art pretty as *> and <*
23:16:16 <ttt_fff> yeah, I generalized it to m () -> m a -> m () -> m a
23:16:27 <jle`> yeah, but you're trading an idiom that everyone knows and recognizes immediately for a word that's already used in base and will confuse everybody/nobody knows :)
23:16:37 <jle`> but!
23:16:45 <jle`> i think parsec and the parsers library actually calls it bracket
23:16:47 <EvanR> i dont think Control.Exception.bracket generalizes to an arbitrary monad
23:16:59 <ttt_fff> hmm
23:17:07 <EvanR> parsers maybe
23:17:12 <jle`> oh no
23:17:14 <jle`> they call it "between"
23:17:47 <EvanR> and your type is totally different
23:18:02 <jle`> yeah, parsec calls it "between", but it's literally implemented as `between open close p = open *> p <* close
23:18:09 <jle`> it's probably provided for cute point free stuff
23:18:14 <jle`> and partially applied versions
23:18:52 <jle`> the generalized polymorphic abstract-over-all-parser-libraries-with-typeclasses library `parsers` also calls it `between`
23:19:05 <ttt_fff> jle`: fine you win. I will use *> and <*
23:19:21 <ttt_fff> jle` is like the human version of "hlint" ... instead of XYZ, use ABC .... :-)
23:19:26 <jle`> nah i'm saying if you like using `between`, at least some people will understand it :)
23:19:30 <jle`> people who are used to combinators
23:19:31 <iheartmonadsnot> peddie: thanks so much for your help, i have almost run out of tobacco and i should have gone to sleep about 7 hours ago...
23:19:31 * hackagebot ms 0.2.1 - metric spaces  https://hackage.haskell.org/package/ms-0.2.1 (RickyElrod)
23:19:37 <ttt_fff>  [ /end sarcasm ] -- I apprecaite you sharing you rknowedge
23:19:38 <jle`> but if you use *> and <* then everybody will understand it
23:19:48 <jle`> :)
23:19:53 <Iceland_jack> iheartmonadsnot: I should go to bed too, thanks for reminding me
23:19:56 <EvanR> * everybody that knows applicative shorthands
23:20:02 <ttt_fff> I thinik *> and <* is better, as it slowly forces me to learn more about applicative and weird haskell syntax
23:20:07 <ttt_fff> jle`++
23:20:10 <EvanR> between I bet is more readable to the uninitiated
23:20:12 <iheartmonadsnot> lol jle - everybody understands ur crazy symbols, sure
23:20:25 <jle`> not quite syntax, they're just normal user-defined operators, heh
23:20:34 <peddie> iheartmonadsnot: you're very welcome, good luck with the references and remember to paste the code and the error first next time!
23:20:51 <iheartmonadsnot> sure! tanks c i a o
23:21:23 <jle`> heh, (*>) and (<*) are introduced pretty early in any haskell course and used in many libraries.  there are few things as "canonical" as (*>) in this sense
23:21:42 <jle`> maybe (>>=) and (+)/(-)/(==) etc.
23:21:54 <peddie> jle`: do those have English names like >>= does?
23:22:14 <jle`> i call (*>)/(>>) "and then"
23:22:26 <peddie> how about <*
23:22:29 <ttt_fff> they're called star-greater and less-than-star
23:22:32 <jle`> hm
23:22:40 <jle`> it's like and-then-but-return-the-result-of-the-first
23:22:42 <jle`> hehe
23:22:47 <peddie> "before you"
23:22:50 <jle`> i think i heard a nice name for it at some point but i can't remember
23:22:57 <ttt_fff> shit, haskell has a compression ratio of like 10x
23:23:08 <jle`> x >> y is "do x and then do y"
23:23:17 <jle`> x <* y is... "do x and then do y.  but i care about x."
23:23:24 <jle`> oh maybe "andThenAndThrowAway"
23:23:37 <peddie> oh, I like that
23:23:48 <jle`> x <* y is do x and y and then throw away y's result
23:23:50 <peddie> "and then ignore the result of"
23:23:50 <jle`> idk
23:23:54 <jle`> yea
23:23:57 <peddie> thanks, good idea
23:24:13 <jle`> maybe someone has a better idea somewhere :)
23:24:50 <jle`> honestly in real code (<*) and (*>) blend together to all be sort of the same thing as (>>) except with arrows pointing to the values that matter
23:25:00 <jle`> like semicolons
23:25:12 <peddie> yeah, I've used them plenty, I'm just curious whether there is a canonical way to pronounce them out loud
23:25:16 <jle`> when i see `x *> y <* z` i see "x; y; z", but with clues pointing to `y`
23:25:26 <ttt_fff> I want to know that too,
23:25:35 <ttt_fff> but I want to know their canonical pronuication in chinese and korean rather than English
23:25:36 <jle`> so maybe they're like semicolons-with-arrows
23:25:40 <EvanR> a *> x <* b ... i dont even know how that associates
23:25:58 <EvanR> thats gimmicky
23:26:04 <peddie> :i (*>)
23:26:08 <peddie> oh right
23:26:29 <jle`> "a *> x <* b" just acts like "a; x; b" or "a >> x >> b", but selecting x
23:26:34 <jle`> it actually doesn't really matter how it associates
23:26:41 <jle`> either association will give the same result
23:26:53 <jle`> i promise it's a common thing when writing parsers v.v
23:27:06 <jle`> i use (<*) a lot less outside of parsers, though
23:27:11 <peddie> I guess the reason I care is "what other infix operators can use use it with?"
23:28:15 <peddie> I'm not sure it always does what I want when I write parsers with it
23:28:44 <peddie> ah, right, it's the same precedence as (<*>)
23:31:36 <EvanR> ttt_fff: dont try to pronounce haskell
23:32:01 <ttt_fff> EvanR: I heard "haskell" is pronounced I-Q-Test
23:33:18 <EvanR> haskell without the type system would be a better IQ test
23:33:46 <EvanR> good luck getting your functions right
23:42:33 <dhruvio> hi there, would someone be able to help me understand why foldr works with infinite lists and foldl doesn't?
23:43:32 <EvanR> the result of foldl depends on the last element of the list
23:43:44 <EvanR> the result of foldr doesnt have to
23:43:57 <ttt_fff> yeah,
23:44:04 <ttt_fff> Dante described this as the 4th layer of hell in Inferno
23:44:28 <ttt_fff> the 5th layer is reserved for Emacs users who emulate Vim in Emacs
23:45:47 <jle`> dhruvio: the easiest way for me was just to manually expand the definitions of foldr and foldl
23:46:17 <dhruvio> okay cool, so i'll give writing them a shot
23:46:24 <jle`> dhruvio: for example, foldr (||) True [x,y,z] is like x || y || y || True, right?
23:46:33 <jle`> it's supposed to be True of *anything* is True
23:46:42 <jle`> er sorry, that should be foldr (||) False xs
23:46:50 <jle`> it's True if at least one item is True
23:46:53 <EvanR> you have to expand them using lazy evaluation though
23:47:00 <EvanR> which is the kicker
23:47:07 <jle`> now try evaluating foldr (||) False (repeat True)
23:47:14 <jle`> i don't think laziness or non-laziness is an issue here
23:47:19 <jle`> there's only one way to really expand it
23:47:27 <jle`> the natural way ^^
23:47:31 <EvanR> theres not one way
23:47:39 <ahihi> foldr will also diverge on infinite lists if the accumulator function is strict in its second argument
23:47:47 <jle`> there might be more than one way, but there's only one obvious/easy way
23:47:57 <jle`> foldr (||) False (True : repeat True)
23:48:02 <jle`> @src foldr
23:48:02 <lambdabot> foldr f z []     = z
23:48:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:48:03 <EvanR> theres the obvious easy way, and the usual way in other languages
23:48:31 <jle`> this is just a question of expanding definitions
23:48:46 <jle`> if other languages expanded definitions, it'd be the same too
23:48:55 <dhruvio> so in the definition above ^^
23:49:10 <dhruvio> when is the first pattern matched in an infinite list?
23:49:10 <EvanR> it would be the same and then the answer to his question would be different, which is about divergent evaluation
23:49:16 <dhruvio> where xs is empty
23:49:34 <jle`> dhruvio: the pattern doesn't really know about inifinite or not infinite lists
23:49:54 <dhruvio> i see
23:50:09 <jle`> EvanR: hm, i still really think that if you just expand it out normally as intuitively, it's clear to see why foldr lets you short circuit
23:50:25 <dhruvio> okay, let me try that out
23:50:25 <EvanR> jle`: in haskell yes
23:50:27 <jle`> does having to keep track of lazy/non-lazy add much?
23:50:35 <jle`> to this quest for insight?
23:50:52 <EvanR> the question is about evaluation, not expansion
23:51:01 <dhruvio> i'm not really sure yet how to track lazy / non-lazy, not there yet :S
23:51:06 <cgag> join #snowdrift
23:51:09 <cgag> oops
23:51:19 <jle`> dhruvio: foldr (||) False (True : repeat True)
23:51:22 <jle`> expands to
23:51:28 <EvanR> in f x (foldr f z xs), f expands first, not foldr
23:51:33 <jle`> True || foldr (||) False (repeat True)
23:51:43 <jle`> which expands to
23:51:46 <jle`> @src (||)
23:51:46 <lambdabot> True  || _ =  True
23:51:46 <lambdabot> False || x =  x
23:51:47 <jle`> True
23:51:51 <jle`> ta da! it's done :)
23:51:53 <EvanR> f evaluates, it doesnt even expand if this is an abstract situation
23:51:56 <dhruvio> ohhhhh
23:52:00 <dhruvio> haha, eureka!
23:52:12 <dhruvio> thank you both for helping me!
23:52:17 <jle`> np :)
23:52:26 <dhruvio> i appreciate it a lot :)
23:52:31 <dhruvio> it makes sense now
23:52:37 <jle`> now try the same thing for `foldl`
23:52:50 <dhruvio> @src foldl
23:52:50 <lambdabot> foldl f z []     = z
23:52:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:52:54 <jle`> and see how you can never get an answer out of foldl (||) True (repeat True)
23:52:58 <ahihi> > foldr (\x xs -> if even x then x:xs else xs) [] [0..] -- laziness makes the difference between getting a list out of this vs diverging
23:52:59 <jle`> @src repeat
23:52:59 <lambdabot> repeat x = xs where xs = x : xs
23:52:59 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
23:53:11 <EvanR> jle`: notice that in a eagerly evaluated situation foldr would diverge no matter what f was
23:53:35 <jle`> yeah, but we're not talking about evaluation strategies here 
23:53:41 <jle`> at least, that wasn't what the original question was about
23:53:54 <EvanR> "what doesnt evaluation of a foldr diverge (sometimes)"
23:54:08 <EvanR> if you thought it worked like js, then youd be understandably confused
23:54:26 <EvanR> s/what/why/
23:54:58 <jle`> yeah, but i'm not suggesting simulating actual evaluation...just working it out on pencil and paper what's equivalent to what
23:55:01 <EvanR> and expansions by hand are helpful ways of understanding haskell, as long as you remember to not do it eagerly
23:55:08 <EvanR> me too
23:55:29 <jle`> i just don't think bringing in strictness/laziness to this sort of discussion contributes much
23:55:36 <jle`> to a new person
23:55:48 <EvanR> by laziness, i meant evaluation order
23:55:50 <dhruvio> i'm going to stick with this approach while i'm learning, thanks (Y)
23:55:56 <EvanR> not strictness or not
23:57:05 <EvanR> you chose not to expand the foldr's in the definition infinitely, why not? because evaluation order. but you would expand foldl's indefinitely demonstrating an issue
