00:02:08 <jle`> > liftIO (pure 10) :: Proxy Int
00:02:09 <lambdabot>  Proxy
00:02:15 <jle`> > pure 10 :: Proxy Int
00:02:16 <lambdabot>  Proxy
00:02:28 <arkeet> what did you expect :-)
00:02:36 <jle`> this is my proof
00:02:38 <jle`> :3
00:02:42 <arkeet> the proof is
00:02:47 <arkeet> "any two values of type Proxy a are equal"
00:03:12 <jle`> > liftA2 (,) (liftIO getLine) (liftIO (putStrLn "hello"))
00:03:13 <lambdabot>      No instance for (Show (f0 (String, ())))
00:03:13 <lambdabot>        arising from a use of ‘show_M219919576488940468922205’
00:03:13 <lambdabot>      The type variable ‘f0’ is ambiguous
00:03:26 <jle`> > liftA2 (,) (liftIO getLine) (liftIO (putStrLn "hello")) :: Proxy (String,())
00:03:27 <arkeet> Proxy is a Monad.
00:03:27 <lambdabot>  Proxy
00:03:50 <jle`> > liftIO $ liftA2 (,) getLine (putStrLn "hello") :: Proxy (String,())
00:03:50 <arkeet> it's also Reader Void
00:03:51 <lambdabot>  Proxy
00:03:57 <arkeet> and also ReaderT Void m, for any m
00:04:45 <jle`> > liftIO . putStrLn =<< liftIO getLine :: Proxy ()
00:04:46 <lambdabot>  Proxy
00:04:54 <jle`> > liftIO (putStrLn =<< getLine) :: Proxy ()
00:04:55 <lambdabot>  Proxy
00:04:58 <jle`> i am satisfied
00:07:38 * hackagebot getopt-generics 0.7.1.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.7.1.1 (SoenkeHahn)
00:07:38 * hackagebot pipe-enumerator 0.3.0.1 - A bidirectional bridge between pipes and iteratees  http://hackage.haskell.org/package/pipe-enumerator-0.3.0.1 (patrykz)
00:08:27 <dramforever> > Proxy :: Proxy Monad Functor MonadIO 2 "test"
00:08:28 <lambdabot>      ‘Proxy’ is applied to too many type arguments
00:08:29 <lambdabot>      In an expression type signature:
00:08:29 <lambdabot>        Proxy Monad Functor MonadIO 2 "test"
00:08:37 <dramforever> ?
00:08:59 <jle`> dramforever: Proxy is * -> *
00:09:08 <jle`> so it only takes one *-kinded type
00:09:13 <dramforever> okay
00:09:19 <jle`> like Proxy (), Proxy Int, etc.
00:09:39 <dramforever> no way, that one works here
00:10:27 <dramforever> oh wait it doesn't...
00:10:36 <mniip> :k Proxy
00:10:37 <lambdabot> k -> *
00:10:42 <mniip> jle`, ^
00:10:43 <dramforever> > Proxy :: Proxy Monad
00:10:44 <lambdabot>  Proxy
00:10:54 <jle`> oh polykinds
00:11:00 <jle`> i forgot that that happened
00:12:09 <mniip> > Proxy :: Proxy (Monad Proxy)
00:12:10 <lambdabot>  Proxy
00:27:06 <kqr> is there a stack equivalent of cabal repl?
00:45:54 <LordBrain> What do { } mean in the types of parameters of functions/data constructors ?  as in foo :: { Bar } -> { Foo } ?
00:46:20 <mniip> LordBrain, more context?
00:46:22 <LordBrain> i'm looking at the example at the bottom of this page: of a Gadt 
00:46:37 <LordBrain> http://www.reddit.com/r/haskell/comments/2toadf/existentials_typeclasses_variants_and_openworld/
00:46:49 <LordBrain> scroll down to the bottom, it has a Gadt Object a
00:47:15 <LordBrain> the data constructor for object has  { }  around each parameter
00:48:06 <adamse> LordBrain: could it be gadt record syntax?
00:48:42 <LordBrain> yes it could be anything
00:48:45 <LordBrain> heh
00:48:54 <LordBrain> i'll google that
00:49:13 <adamse> LordBrain: seems like the mext to last line uses objJoin like you would use a record selector
00:49:55 <LordBrain>    Just Refl -> SomeObject (objJoin a b)
00:49:57 <LordBrain> that line?
00:50:00 <adamse> yep
00:50:57 <LordBrain> i'm trying to learn the syntax here
00:51:26 <LordBrain> so forgive me if i don't understand. if { } is records, then are they anonymous records? 
00:51:30 <pavonia> I've never seen this kind of syntax, looks like ad hoc record types
00:53:05 <frerich> LordBrain: I think that's just a GADT using record syntax to assign names to the individual fields.
00:53:17 <adamse> LordBrain: see the user guide: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#gadt
00:53:21 <adamse> mentions record syntax
00:54:32 <LordBrain> thanks adamse i found it
00:57:38 <Charval> hello everyone, i work on Wolfram Mathematica, about 10 years, is there any reason for turning to Haskell? (i do general mathematics, plotting, statistics et.c.)
00:57:42 <LordBrain> so to see the type of one of these accessors do i just read the arrows backwards?
00:58:36 <LordBrain> mathematica is slower isnt it?
00:58:45 <adamse> LordBrain: objJoin :: Object a -> Object a -> Object a
00:58:46 <LordBrain> even for its specialized purposes
00:58:50 <Hafydd> Charval: yes: Haskell's strong static type system allows you to see errors in your code at compile-time rather than runtime.
00:58:58 <adamse> just tack on a Object a before the first arrow
00:59:08 <adamse> like you would do with regular record accerssors
00:59:11 <Hafydd> That will save anyone time.
00:59:41 <Hafydd> Charval: but, of course, the libraries available aren't as well-integrated or extensive as for Mathematica.
00:59:54 <LordBrain> a general purpose language offers flexibility to branch out too
01:01:44 <Charval> Hafydd, LordBrain: thank you for answers. :) Please, another question: do you suggest any _good_ IDE for Windows?
01:02:35 * hackagebot Spock 0.7.10.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.10.0 (AlexanderThiemann)
01:02:46 <Hafydd> Charval: ah, another advantage of Haskell: the compilers and libraries tend to be free and open source, unlike Mathematica!
01:02:59 <Hijiri> does emacs count as an IDE
01:03:16 <LordBrain> i do my haskell mostly in vim
01:03:19 <LordBrain> with syntastic
01:03:25 <LordBrain> its not an ide...
01:03:30 <Hafydd> Charval: I agree with the philosophy put forth in here: http://www.symbo1ics.com/files/jordi.pdf
01:04:17 <LordBrain> i have tried lexah, it seemed fine to me, but ultimately my vim habit is hard to kick
01:05:26 <LordBrain> i have heard of people actually using microsoft's ide on windows
01:05:44 <LordBrain> i think if i were you i would check out lexah
01:06:28 <LordBrain> sorry its spelled leksah
01:06:41 <LordBrain> http://leksah.org/
01:10:28 <LordBrain> it would be nice if leksah branched out and became a language neutral ide.
01:12:07 <LordBrain> sometimes i do android stuff in eclipse, and it gets buggy and sluggish. leksah for android would be awesome.
01:24:39 <Charval> Thank you all, i installed Leksah 
01:25:35 <Charval> reverse "Haskel" :-P
01:30:09 <Charval> hm.. when i click for a 'new module', it needs .cabal
01:30:25 <Charval> whats that
01:30:37 <z16> Charval: No, it's reverse "haskeL"
01:30:46 <z16> Which is neither "Haskel" nor "Haskell"
01:31:01 <Charval> z16 lol, yeap :P
01:32:18 <drewbert> Leksah took like an hour reading packages last time (the first time) I tried to use it.  It said it would only happen once, but I was so darn ticked I've never given it another chance.
01:32:25 <drewbert> Not that I'm happy with emacs.
01:37:37 <nshepperd_> it tries to index all of hackage?
01:38:17 <nshepperd_> that would be impressive
01:39:12 <nshepperd_> oh, just the ones installed
02:01:02 <drewbert> Can you build for windows from a unix system?
02:01:08 <drewbert> *using GHC
02:12:39 * hackagebot subhask 0.1.0.0 - Type safe interface for programming in subcategories of Hask  http://hackage.haskell.org/package/subhask-0.1.0.0 (MikeIzbicki)
02:12:41 * hackagebot subhask 0.1.0.1 - Type safe interface for programming in subcategories of Hask  http://hackage.haskell.org/package/subhask-0.1.0.1 (MikeIzbicki)
02:17:39 * hackagebot inline-c 0.5.4.0 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.4.0 (FrancescoMazzoli)
02:27:39 * hackagebot testing-type-modifiers 0.1.0.1 - Data type modifiers for property based testing  http://hackage.haskell.org/package/testing-type-modifiers-0.1.0.1 (JonasDuregard)
02:28:47 <ReinH> @google cross compiling ghc
02:28:49 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
04:05:01 <gfixler> is there a way to go more point-free with applicative's <|> ?
04:05:18 <gfixler> e.g. foo xs = bar xs <|> baz xs <|> quux xs
04:05:24 <gfixler> I'm repeating xs a lot
04:07:15 <merijn> gfixler: ReaderT?
04:07:43 <merijn> And/or ((->) r)
04:08:03 <merijn> You could use Compose since the compose of two applicatives is automatically an Applicative too
04:10:31 <gfixler> merijn: ah, that's a bit ahead of me yet
04:21:39 <ReinH> I think what you have is probably more readable than any pointfree version
04:22:57 <ReinH> banana brackets might be an exception
04:25:46 <gfixler> ReinH: probably true
04:43:36 <hamid> :t fmap . fmap
04:43:37 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:44:41 <chpatrick> :t lift
04:44:42 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
04:44:52 <chpatrick> why is there a Monad constraint on the lift function?
04:47:37 <kqr> is there a stack equivalent of cabal repl to open up ghci with the installed dependencies available?
05:04:26 <mauke{> chpatrick: what would it do without the monad constraint?
05:19:55 <Aruro> @src Monad
05:19:55 <lambdabot> class  Monad m  where
05:19:55 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
05:19:55 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
05:19:55 <lambdabot>     return :: a -> m a
05:19:55 <lambdabot>     fail   :: String -> m a
05:20:47 <Aruro> @src lift
05:20:47 <lambdabot> Source not found. My brain just exploded
05:22:33 <Aruro> @hoogle lift
05:22:33 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
05:22:33 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
05:22:33 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
05:22:36 <mauke{> lift is a method of MonadTrans
05:23:07 <pacak> :t lift
05:23:08 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
05:23:11 <Aruro> chpatrick: question boils down to definitions
05:23:22 <pacak> Monads are your friends.
05:23:50 <Aruro> pacak: lambda bot has only Monad Transformers library
05:27:27 <sbrg> how do I tell ghc to use my cabal sandbox pkg db? I tried package-db but I'm unsure where to point it.
05:27:52 <Aruro> it will use it
05:27:58 <Aruro> or try cabal exec
05:28:15 <Aruro> cabal exec ghc
05:28:21 <Aruro> in directory of sandbox
05:29:08 <sbrg> that seems to work, yes. thanks!
05:29:10 <Aruro> you can check with : ghc-pkg list 
05:29:28 <Aruro> sandbox is best :)
05:35:51 <cnf> how do I look up what (.) does?
05:36:02 <cnf> googeling it isn't very helpful
05:36:26 <rkaippully> In GHCI :i (.)
05:36:54 <rkaippully> Or use hoogle: https://www.haskell.org/hoogle/?hoogle=%28.%29
05:37:08 <cnf> i did that, I don't really understand what it tells me
05:37:18 <Aruro> @src (.)
05:37:18 <lambdabot> (f . g) x = f (g x)
05:37:24 <Aruro> look ^
05:37:52 <Aruro> use @src command of lambdabot for "fundamental" functions
05:38:16 <cnf> I don't really get what that does, and what are "fundamental" functions?
05:38:31 <Aruro> cnf:  it is a function composition
05:38:39 <Aruro> what complicates you?
05:39:21 <kqr> Aruro, thanks for the tip about cabal exec. I had just asked a similar question about stack. turns out stack exec works the same way!
05:40:00 <Aruro> kqr: uwc
05:40:35 <Aruro> > (+1) . (*100) $ 5
05:40:37 <lambdabot>  501
05:40:44 <Aruro> cnf: does it help?
05:40:46 <cnf> what is a function composition?
05:41:14 <Aruro> composition is applying one fucntion to the argument of another
05:41:19 <Aruro> and then calculating it
05:41:19 <cnf> oh
05:41:38 <Aruro> @dic composition
05:41:38 <lambdabot> Maybe you meant: dice dict-help
05:41:39 <exio4> (f . g) x = f (g x)
05:41:48 <Aruro> @dict composition
05:41:48 <lambdabot> There is no dictionary database 'composition'.
05:41:48 <exio4> that already says a lot
05:42:02 <cnf> exio4: sadly, not to me :(
05:42:14 <Aruro> look (+1) is a function
05:42:23 <Aruro> > (+1) 5
05:42:24 <lambdabot>  6
05:42:33 <Aruro> same is (*6)
05:42:45 <Aruro> do u get the syntax?
05:43:37 <Aruro> we can compose two functions like this  ((x*6)+1)
05:43:42 <Aruro> here x is argument
05:44:03 <exio4> (f . g) = \x -> f (g x) -- maybe this made it clear, it basically takes two functions `f` and `g`, and returns a new function that'd be f (g x), we like it because it also has nice properties (like associativity!), maybe a small example..
05:44:08 <Aruro> in haskell language it will be written like this : (+1) . (*6) $ x
05:44:28 <exio4> > (filter even . map (^2)) [1..10]
05:44:29 <lambdabot>  [4,16,36,64,100]
05:44:38 <cnf> ok, first time i see $ in haskell
05:44:59 <Aruro> @src ($)
05:44:59 <lambdabot> f $ x = f x
05:45:11 <exio4> cnf, ($) is just function application, a way to "remove" parenthesis
05:45:13 <Aruro> cnf: did you try some very basic syntax course?
05:45:16 <merijn> I think there's two separate issues that people are trying to cover at the same time confusing things
05:45:24 <exio4> probably
05:45:29 <Aruro> merijn: i think he does not know syntax yet :)
05:45:38 <cnf> Aruro: am on it, i think
05:45:39 <merijn> There's two things 1) function composition and 2) "(+1)" being equal to "\x -> x + 1"
05:45:40 <Aruro> or she
05:45:59 <Aruro> cnf: google haskell cheatsheet
05:46:09 <cnf> but the homeworks expect you to use things that are not in the course
05:46:13 <cnf> which is doing my head in
05:46:15 <Aruro> cnf: it will give you brief slightly outdated info
05:46:35 <haskell720> hey guys can you tell me a good web framework to use in haskell?
05:47:01 <kqr> yesod
05:47:23 <cnf> hmm
05:47:36 <merijn> snap, scotty, etc.
05:47:54 <Aruro> $ is function application helps to get rid of brakets
05:48:02 <tdammers> haskell720: depends on the use case
05:48:41 <tdammers> haskell720: apart from what others have suggested, coding directly against WAI is also a valid approach - minimalistic, but gives you a lot of control
05:49:09 <rkaippully> @src (<>)
05:49:09 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
05:49:44 <lpaste_> chpatrick pasted “Lazy parsing for any parser” at http://lpaste.net/135650
05:50:07 <Aruro> rkaippully: it knows only basic stuff mainly from base
05:50:08 <merijn> rkaippully: <> is just mappend
05:50:24 <merijn> rkaippully: Also, I recommend hoogle over lambdabot for finding operators
05:50:28 <rkaippully> Yeah, I know. I was testing @src :)
05:50:31 <Aruro> @hoogle (<>)
05:50:31 <lambdabot> Data.Text.Internal.Builder.Functions (<>) :: Builder -> Builder -> Builder
05:50:31 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
05:50:31 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
05:50:43 <Aruro> @src id
05:50:43 <lambdabot> id x = x
05:50:48 <rkaippully> I have hoogle in my ghci
05:50:56 <merijn> The @src commands just reads from a text file with keywords -> text
05:51:03 <merijn> It doesn't show the actual source used
05:51:14 <Aruro> indeed
05:51:25 <cnf> right, lets try this exercise again...
05:52:42 <haskell720> reverse "hello"
05:53:23 <haskell720> @hoogle (reverse)
05:53:23 <lambdabot> Did you mean: :: Reverse a a
05:53:24 <lambdabot> Prelude undefined :: a
05:53:24 <lambdabot> Test.QuickCheck.Exception discard :: a
05:54:11 <Taneb> > reverse "hello"
05:54:13 <lambdabot>  "olleh"
05:55:11 <haskell720> > reverse "hello"
05:55:13 <lambdabot>  "olleh"
05:56:26 <thimoteus> > reverse "leksah"
05:56:28 <lambdabot>  "haskel"
05:57:01 <pacak> > iterate reverse "hello"
05:57:02 <lambdabot>  ["hello","olleh","hello","olleh","hello","olleh","hello","olleh","hello","ol...
05:57:08 <tdammers> haskell720: lambdabot also listens to private messages
05:57:21 <mauke{> @hoogle reverse
05:57:21 <lambdabot> Prelude reverse :: [a] -> [a]
05:57:21 <lambdabot> Data.List reverse :: [a] -> [a]
05:57:21 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
05:58:37 <chpatrick> @list msg
05:58:37 <lambdabot> system provides: listchans listmodules listservers list echo uptime
05:58:49 <chpatrick> @msg
05:58:49 <lambdabot> Not enough privileges
06:04:29 <ttt_fff> is it retarded to create a typeclass which only has ONE instance ?
06:04:48 <Taneb> ttt_fff, usually
06:04:54 <ttt_fff> yeah
06:04:57 <ttt_fff> my code looks bad
06:05:16 <rkaippully> ttt_fff: Do you expect some other instance in future?
06:05:25 <ttt_fff> no
06:05:30 <ttt_fff> I think I'm just over using typeclasses
06:05:34 <ttt_fff> now that I finally get how cool they are
06:05:44 <ttt_fff> when all you have is typeclasses, everything looks like instances
06:05:45 <chpatrick> typeclasses considered harmful :)
06:06:07 <haskell720> A typeclass is a sort of interface that defines some behavior..since behavior requires multiple instances
06:06:15 <haskell720> id say yes
06:06:21 <rkaippully> ttt_fff: wait till you discover monads :)
06:06:35 <ttt_fff> I have writen my own monads.
06:06:40 <haskell720> lol
06:06:45 <ttt_fff> Monad abuse is not nearly as bad looking as typeclass abuse.
06:07:34 <cow_2001> :|
06:07:42 <chpatrick> |:
06:07:47 <cow_2001> halo!
06:08:01 <cow_2001> i'm just wonderin' if the author is here
06:08:27 <tdammers> ttt_fff: it's not a bad idea if you can foresee that other instances will be useful
06:12:51 * hackagebot classy-prelude 0.12.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.12.1 (GregWeber)
06:14:21 <zipper> Hey guys.
06:14:32 <haskell720> > reverse reverse "hello"
06:14:34 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘[a0]’
06:14:34 <lambdabot>      The function ‘reverse’ is applied to two arguments,
06:14:34 <lambdabot>      but its type ‘[a0] -> [a0]’ has only one
06:14:43 <zipper> So I started a process that runs forever warp in my haskell program.
06:14:56 <zipper> I want to kill it. How can I do that?
06:15:05 <zipper> Stull within the code.
06:15:09 <zipper> *still
06:15:34 <zipper> a warp process and it runs forever since it's a server. Kill or interrupt it.
06:16:11 <tdammers> there's System.Exit, I think
06:16:16 <Aruro> > (reverse . reverse ) "Hello"
06:16:18 <lambdabot>  "Hello"
06:16:40 <Aruro> :t (reverse . reverse)
06:16:41 <lambdabot> [a] -> [a]
06:16:46 <Aruro> :t reverse
06:16:47 <lambdabot> [a] -> [a]
06:16:49 <tdammers> http://hackage.haskell.org/package/base-4.8.0.0/docs/System-Exit.html
06:16:55 <tdammers> zipper: ^
06:18:03 <zipper> hmmmm I want to do something closer to pkill
06:18:13 <Darwin226> Hey, I wrote radix sort and would like to see if there's anything I can do to make it faster. Anyone up for some optimizing?
06:18:16 <Darwin226> Here's my code http://lpaste.net/135651
06:18:20 <zipper> I am starting the process in a different function
06:18:26 <zipper> Maybe even in a different thread.
06:20:02 <mauke{> zipper: how did you start it?
06:20:10 <zipper> mauke{: I did
06:21:05 <zipper> In a different function.
06:21:40 <zipper> I want to stop it in a case statement in case something happens in a different function.
06:22:19 <tdammers> clean solution would be to have some proper thread communication and have the thread in question end itself
06:22:30 <tdammers> (or s/thread/process/, as the case may be)
06:23:11 <zipper> This: http://lpaste.net/3410914596708417536
06:23:31 <zipper> I want the runServer invoked in the last line to be stoppable in L6
06:23:36 <zipper> Am I making sense?
06:25:05 <geekosaur> that's not a separate thread. line 7 is how you run it in a separate thread (and get a handle you can use to kill it)
06:25:21 <geekosaur> it's also not a separate process
06:26:13 <geekosaur> unless there is more that you are not showing that somehow ensures that that will be a separate thread or process
06:26:58 <zipper> geekosaur: No, there's more but it's irrelevant.
06:27:13 <zipper> geekosaur: So how can I stop what was started in the last line there?
06:27:30 <geekosaur> ok, what I said wasn't enough
06:27:36 <geekosaur> do you see what the code does on line 7?
06:27:51 <zipper> geekosaur: Yes 
06:28:44 <zipper> geekosaur: I have updated the paste. Please reload.
06:28:46 <geekosaur> ...on second thought maybe someone else should be helping you, I've been having coughing fitsd and am clearly a bit stroppy today :/
06:28:55 <zipper> So that thread is doing nothing.
06:29:05 <zipper> It's just printing that it can't do it.
06:29:10 <zipper> geekosaur: Sorry
06:29:13 <zipper> Get well soon.
06:29:31 <geekosaur> anyway the point is it's not a separate thread that you can do anything with unless you use forkIO.
06:30:42 <geekosaur> and then you capture the thread ID from it, like line 7 does, and either pass it back up so you have it later or stow it in an IORef (presumably of type Maybe ThreadId)
06:31:23 <geekosaur> so you can look it up to see if a server is already running and killThread it, in the same way the code is handling the server that shows the errors
06:33:09 <zipper> Is there a function to check whether a port is already bound to something and if it is bound to something kill whatever it holding it?
06:33:46 <merijn> zipper: What if you don't have permission to kill it?
06:33:46 <geekosaur> no
06:33:55 <merijn> zipper: Or don't have permission to find out what's holding it
06:35:12 <geekosaur> if all you care about is linux, you can parse a program name and pid out of netstat output... this CANNOT be done at the level of a thread! only a process 
06:35:25 <zipper> :(
06:35:34 <zipper> I guess I have to totally rethink this :(
06:35:49 <merijn> zipper: What's the problem you're trying to solve?
06:35:53 <zipper> geekosaur: If I may ask, how did you know that I'm on linux?
06:36:03 <geekosaur> I didn't.
06:36:22 <geekosaur> Linux is the only OS that gives you what you asked about without reading kernel structures as uid 0
06:36:40 <zipper> merijn: The problem is. I want to stop warp or update warp if possible so that it can print an error in the browser.
06:36:42 <merijn> geekosaur: Pretty sure OSX and BSD let you find out using sockstat
06:36:45 <slaterr> is it possible to export just constructors, or just deconstructors, or does one necessarily comes with the other?
06:36:52 <geekosaur> (well, you might be able to pull it from lsof alsop. and I have no idea how if at all you could do it on Windows)
06:37:00 <zipper> merijn: Since warp has already been started I can't stop it.
06:37:06 <zipper> idk if I'm making sense.
06:37:48 <geekosaur> pyanfar:26564 Z$ type sockstat
06:37:48 <geekosaur> sockstat not found
06:38:07 <geekosaur> ...not on OS X
06:38:18 <merijn> geekosaur: I dunno what OSX version is, tbh
06:38:32 <merijn> geekosaur: You can almost certainly do it via DTrace
06:38:42 <geekosaur> ...which requires root on os x
06:38:51 <merijn> oh, true
06:39:33 <zipper> geekosaur: Know how I can block a process until say a certain charachter is entered?
06:39:41 <geekosaur> lsof can do it if you can be certain it is installed, and that it hasn't been configured to restrict output fopr non-root etc.
06:39:43 <zipper> I'm currently using getLine but that's bad.
06:39:53 <zipper> pause the running of
06:39:57 <mauke{> zipper: from within? or from a separate process
06:40:02 <zipper> From within
06:40:08 <mauke{> what's wrong with getLine?
06:40:17 <zipper> mauke{: Feels hacky idk
06:40:30 <merijn> geekosaur: lsof ships on OSX
06:40:34 <merijn> Apparently
06:40:36 <mauke{> I'd say that's because what you're trying to do is hacky
06:40:51 <slaterr> data Foo = Foo { fooBar :: String, fooBaz :: String };  <- can I hide Foo constructor, and force the user to use mkFoo instead, while still giving him the ability to pattern match on Foo?
06:41:12 * geekosaur realizes the point he tried to make vanished long ago, gives up
06:41:19 <quicksilver> no, slaterr 
06:41:25 <merijn> slaterr: Look up PatternSynonyms in the GHC manual
06:41:29 <merijn> quicksilver: *bzzt* ;)
06:41:35 <quicksilver> ah well
06:41:36 <mauke{> slaterr: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-synonyms
06:41:38 <merijn> quicksilver: Gotta keep up with all the extensions, man! :p
06:41:47 <quicksilver> I can't just give up haskell for 2 years and then get answers right
06:41:50 <quicksilver> did you miss me?
06:42:21 <geekosaur> I am beginning to suspect I am the only person around any more who cares in any way about general portability; everyone else knows there's only one or maybe two OSes to care about, ever.
06:42:25 <merijn> quicksilver: State of the world is immutable, so you can't leave haskell :p
06:42:54 <tdammers> time is an illusion
06:42:59 <merijn> geekosaur: I care about portability until the portable interface sucks :p
06:43:17 <merijn> Frankly I've given up on caring about windows
06:43:25 <zipper> geekosaur: mauke{ merijn Okay so I can do it in a different thread (L 16). How do you think I can pass the thread id around so that I can kill it up there in L6
06:43:44 <geekosaur> I support Solaris in my day job (and HP/UX may be creeping back in soon)
06:43:47 <merijn> So as long as it runs on OSX and FreeBSD I'm happy, and hopefully linux isn't so broken it's not portable there and then I give up :p
06:44:06 <merijn> geekosaur: Did you commit genocide in a past live or something?
06:44:07 <zipper> I feel as if I have too many MVars and TVars
06:44:11 <zipper> I'm losing grip
06:44:16 <merijn> geekosaur: Is it at least a recent Solaris?
06:45:33 <geekosaur> one customer still has a fair amount of sol10, the other is mostly sol11 and looking at sol12
06:45:47 <zipper> geekosaur: You're unique
06:45:53 <merijn> I mean, at least recent Solaris is pretty nice, zones, jails, DTrace, etc.
06:46:21 <merijn> geekosaur: And C11/C++11 support is coming to Solaris Real Soon™
06:46:47 <geekosaur> not unique, actually, except insofar as most people have no idea how F50 and up companies work
06:47:28 <zipper> geekosaur: They don't use linux?
06:47:37 <merijn> They don't ONLY use linux
06:47:58 <merijn> Whereas every open source coder thinks linux and it's quirks is the only thing around
06:48:10 <zipper> I'll be finishing school and hopefully looking for a haskell job by the end of the year (not afraid to move countries). Any ideas?
06:48:14 <frerich> ...and everybody always uses the latest version of everything...
06:48:20 <zipper> merijn: I'm guilty
06:48:48 * frerich looks at his Jenkins built pointing out a failure with Visual Studio 6 from 1998 (i.e. 5 years before C++03 was released) 8-[
06:49:02 <merijn> Which might be less annoying if linux didn't have such a half-assed design
06:49:05 <zipper> I think I'll have to use an IORef after all.
06:49:06 <geekosaur> exactly. when you are that big, you do not run the latest and greatest everything, you don't run whatever's cool right now, you don't touch stuff that works until you absolutely have to move it
06:49:10 <stelleg> is ImpredicativeTypes still considered broken?
06:49:16 <hodapp> I heard that the Solaris installer finally got rid of the page where it asked how much your computer cost, and if your number had less than 5 digits, laughed at you and stopped the install.
06:49:17 <zipper> I run archlinux
06:49:19 <zipper> :)
06:49:19 <merijn> So everyone is coding to half-assed quirks of linux
06:49:23 <merijn> stelleg: Yes, don't use
06:49:26 <zipper> frerich: Latest of many
06:49:36 <stelleg> merijn:thanks
06:49:45 <zipper> geekosaur: Isn't such work very hard.
06:49:47 <geekosaur> (and you're not much worried about security holes because you have so many security barriers that your left hand can't see what your right is doing without getting a sign off from 3 leevels of management up)
06:49:55 <zipper> geekosaur: I hope they compensate you accordingly.
06:50:07 <mauke{> "security" "barriers"
06:50:29 <zipper> hodapp: Where is that joke from?
06:50:33 <zipper> hodapp: haha
06:50:42 <hodapp> mauke{: hey, paperwork is a security barrier. Sort of.
06:51:21 <merijn> mauke{: To be fair, he didn't say there weren't security holes
06:51:29 <merijn> mauke{: Just that he's not very worried about them :p
06:51:45 <merijn> Which I would be too if there were 15 layers of bureaucracy isolating me from security issues :p
06:52:01 <geekosaur> sigh, had a feeling that was going to be misread. my point is you have access to a tiny part of the infrastructure and you cannot escape it in any way unless security sees an authorization from $highup to give you temporary limited access
06:52:12 <hodapp> I'll have you know that I use OS X too for my open source stuff.
06:52:14 <geekosaur> and these folks are very serious about their internal security
06:52:30 <lpaste_> lwm revised “weird cabal test error”: “No title” at http://lpaste.net/135652
06:52:42 <geekosaur> (way more serious than the bank I consulted for in the late 80s...)
06:52:58 <lwm> hey, anyone see an error like this http://lpaste.net/135652 whilst using tasty?
06:53:15 * frerich remembers visiting a big EDA vendor in the silicon valley area whose name starts with 'C' and how he even got accompanied to the bath room because visitors weren't able to just walk. :-}
06:53:30 <geekosaur> yep, that kind of thing
06:53:38 <merijn> frerich: Oh, that happened at my Google interviews too
06:54:18 <frerich> merijn: Did you also get t ouse the crappy badge printer and watch those big screens where they show 'live' (ha-right!) search queries being done?
06:54:20 <mauke{> "you cannot escape it in any way" <- challenge accepted
06:55:03 <frerich> merijn: In my experience Google is a lot more relaxed if you have some Googler with you. I even got into the Google store and then got laughed at because I wanted to pay with bills...
06:55:05 <merijn> frerich: No live search queries, no, but this was in London
06:55:21 <frerich> merijn: Ah, right - Google has an office in London now. I heard it's really fancy, too! :-)
06:56:00 <ryantm> Is there a way to tell Hackage your package only works with a particular version of GHC? I want to say my package only works with 7.10 or later.
06:56:13 <merijn> ryantm: Lower bound on base
06:56:22 <merijn> ryantm: base is tied into GHC and can't be upgraded/downgraded
06:56:46 <ryantm> merijn: is there some place that show the correspondence between base versions and GHC versions?
06:56:58 <merijn> ryantm: Release notes should have version details
06:57:06 <mauke{> I remember providing such a link in the channel but not when :-)
06:57:19 <mauke{> ask someone to grep the logs?
06:57:25 <mauke{> probably a few days ago
06:57:59 <ryantm> https://hackage.haskell.org/package/base-4.8.0.0/changelog
06:58:30 <merijn> I meant GHC release notes, but that works, yeah
06:58:36 <ryantm> thanks!
07:02:53 * hackagebot heyefi 0.1.0.2 - A server for Eye-Fi SD cards.  http://hackage.haskell.org/package/heyefi-0.1.0.2 (ryantm)
07:12:54 * hackagebot machinecell 2.0.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-2.0.0 (HidenoriAzuma)
07:15:23 <ryantm> Changing my base constraint doesn't seem to have caused Hackage to use GHC 7.10: http://hackage.haskell.org/package/heyefi-0.1.0.2/reports/1
07:15:55 <merijn> ryantm: Hackage has only one GHC, you can't tell it what to use, you can just have it fail
07:17:52 <ryantm> merijn: okay, I'll let it fail
07:27:54 * hackagebot ClustalParser 1.1.0 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.1.0 (FlorianEggenhofer)
07:31:55 <zipper> Hey I have an IORef here that gets modified in L 28 but when I later come to check for it's mutated value in L 10 it doesn't reflect the mutation. What could I be doing wrong? http://lpaste.net/3410914596708417536
07:32:01 <zipper> merijn: ^
07:32:57 <mauke{> what do you mean, later
07:33:02 <mauke{> L 10 comes before L 28
07:34:24 <zipper> Oh wait
07:34:30 <zipper> I get what you mean
07:35:07 <zipper> Every time I enter the function it resets the IORef to Nothing
07:35:24 <zipper> mauke{: How I do make it such that it doesn't get mutated everytime?
07:35:29 <mauke{> well, every call to doCompile creates a new IORef in line 4
07:35:56 <mauke{> I reject your question
08:07:37 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
08:07:37 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
08:08:31 <merijn> The haskell gtk bindings are just calling C functions (well, maybe they abstract over that, but in the end that happens)
08:08:48 <merijn> Calling C functions from haskell is pretty trivial
08:09:03 <merijn> (as long as you don't want to modify structs)
08:11:59 <d-snp> is it easy to call haskell functions from C?
08:13:05 <orzo_> i've done it before
08:13:24 <orzo_> in fact i linked haskell into a program where main was not haskell
08:13:46 <merijn> d-snp: Yes
08:13:50 <orzo_> doing that was a hassel as i had to do a lot of work ghc would normally take care of
08:14:12 <orzo_> it might be easier today
08:14:24 <merijn> d-snp: Basically, if all you need is basic types (ints, chars, etc.) and pointers and you don't have to mutate structs on the haskell side it's easy
08:14:56 <merijn> orzo_: tbh, I thought it was kinda easy when I'd figured out how to do it. But admittedly that took a day
08:15:22 <merijn> I have a minimal example for a non-haskell main here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
08:15:36 <lpaste> chpatrick revised “Lazy parsing for any parser”: “No title” at http://lpaste.net/135650
08:16:13 <d-snp> I was thinking of maybe smuggling some Haskell into the companies codebase
08:16:38 <merijn> d-snp: Basically just "foreign export ccall my_function" and GHC will produce a binary symbol with the C calling convention
08:17:05 <c_wraith> You do have to be sure to initialize the RTS first, though
08:17:21 <merijn> d-snp: I'd recommend reading the Haskell Report chapter on the FFI to learn all the details. But if your comfortable with linking/binaries in C, then haskell's part is pretty straightforward and understandable
08:17:22 <d-snp> right
08:17:29 <d-snp> and it has to be compiled I presume
08:17:33 <merijn> c_wraith: Yeah, the non-haskell main example I linked initialised it
08:18:16 <d-snp> oh you compile it with cabal?
08:18:17 <merijn> d-snp: GHC just produces .so object files when asked, the only thing you need to do is make sure the calling convention used is something C compilers understand (which is what the foreign export asks GHC to do)
08:18:26 <merijn> d-snp: You can, you don't have to
08:18:43 <d-snp> alright looks easy enough
08:18:52 <merijn> (actually, you can just create .a libraries to using GHC)
08:19:28 <merijn> d-snp: If you wanna mutate C values from haskell you need to implement a Storable instance which can be a bit of a hassle, but just passing pointers/ints back-and-forth is pretty straightforward
08:19:54 <d-snp> mutating is for the plebs
08:20:26 <chpatrick> if you want to be l33t
08:20:29 <chpatrick> @hackage inline-c
08:20:29 <lambdabot> http://hackage.haskell.org/package/inline-c
08:20:34 <chpatrick> it's the bees knees
08:22:29 <vfhjgdvjkjgc> Part
08:22:32 <hiptobecubic> it is pretty sweet, actually
08:32:02 <orzo_> can cabal be told to search c files in a certain directory instead of having to specify the complete path for each file in c-sources ?
08:35:45 <mathu> how could one define, in haskell, the set of all lists of length 10 that contain real numbers
08:36:16 <FreeFull> Real numbers aren't countable
08:36:27 <Jello_Raptor> does anyone here know how overlapping instances works with type constraints? I.e. an instance of "instance Foo a => Bar a" and another of "instance Bar int" will choose the latter and otherwise only complain even if there is no instance of 'Foo int', right? 
08:36:31 <mathu> (i'm given some values and i'm given what their weighted average is, but i'm not given the weights this average was calculated with :P)
08:36:38 <mathu> FreeFull: see that's where i struggled too
08:36:43 <Jello_Raptor> err,"will not complain even if there there is no" 
08:37:30 <mathu> i guess for curiosity's sake let's do this exercise with integers instead
08:37:50 <mathu> i guess this could be done with a very lengthy list comprehension
08:37:52 <Jello_Raptor> also, is there a pragma that lets me say "no you are not allowed to override the default implementation of method x in class y"? 
08:38:20 <S11001001> Jello_Raptor: why not move it out of the class then
08:38:34 <Jello_Raptor> S11001001: *facepalm* 
08:38:39 <Jello_Raptor> S11001001: thank you :P 
08:38:50 <Hijiri> mathu: You could define it as a type, with some GHC extensions
08:39:42 <mathu> i just did the list comprehension way
08:52:59 * hackagebot dockerfile 0.1.0.0 - Type-safe composable Dockerfile generator and parsers.  http://hackage.haskell.org/package/dockerfile-0.1.0.0 (ChristopherReichert)
08:53:01 * hackagebot rlglue 0.2.2.0 - A Haskell codec for RL-Glue.  http://hackage.haskell.org/package/rlglue-0.2.2.0 (rofer)
08:53:15 <rofer> \o/ My first package on hackage!
08:53:28 <vyorkin_> does anybody know good examples of rest api built with persistent and scooty?
08:53:53 <vyorkin_> + yesod
08:56:03 <vyorkin_> i meant aeson
08:57:59 * hackagebot jukebox 0.1.4 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.1.4 (NickSmallbone)
08:58:01 * hackagebot dockerfile 0.1.0.1 - A simple DSL for describing and generating Dockerfile containers in Haskell.  http://hackage.haskell.org/package/dockerfile-0.1.0.1 (ChristopherReichert)
09:03:02 <nabokovian> how is one supposed to troubleshoot technical issues with a newborn keeping them up at night? what is the trick? </nonhaskellquestion>
09:03:14 <magneticDuck> technical issues with the newborn?
09:03:28 <nabokovian> hehe, ambiguous grammar
09:03:29 <magneticDuck> or some sort of other now-irrelevant thing that used to be part of your life?
09:05:02 <Aruro> magneticDuck: i suppose its about work :)
09:05:11 <magneticDuck> well then it's impossible
09:06:34 <monochrom> go to med school for fixing technical issues with newborns :)
09:07:00 <monochrom> P. S. their 36-hour shift also keeps you up at night
09:08:00 * hackagebot smoothie 0.3.1 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.3.1 (DimitriSabadie)
09:08:08 <magneticDuck> fun fact: newborns have a 27 hour circadian rythm
09:08:35 * geekosaur has been known to switch to 30.5-hour
09:08:46 <suppi> I would like to build my cabal project with stack, but I have transformers>=0.4 as a dependency, is there are workaround for that?
09:09:01 <monochrom> if we know that, we can perhaps sync ourselves with the baby to minimize frustration
09:09:09 <Clint> suppi: why do you have transformers>=0.4 as a dependency?
09:10:05 <suppi> Clint, because of ExceptT
09:10:14 <Clint> suppi: use transformers-compat
09:11:57 <suppi> Clint, does all I need to do is replace transformers>=0.4 with trasformers-compat in the cabal file?
09:15:38 <cnf> anyone want to sanity check my CIS194 exercise ? http://lpaste.net/135663
09:16:08 <cnf> that's re: http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf exercise 2
09:17:37 <Clint> suppi: no, see the description
09:18:00 * hackagebot classy-prelude-yesod 0.12.0.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.12.0.1 (GregWeber)
09:18:02 * hackagebot classy-prelude-conduit 0.12.0.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.12.0.1 (GregWeber)
09:18:42 <adamse> rofer: how come you have created RL_glue bindings?
09:19:08 <suppi> Clint, thank you, I will check.
09:20:32 <rofer> adamse: Because I want to write Haskell programs that talk to RL_Glue things
09:24:29 <RyanGlScott> Is there a GHC flag that removes .o/.hi files after compilation?
09:52:01 <kaste> or do you mean sectionsep?
09:55:07 <maerwald> RyanGlScott: I'd say that's something the buildsystem or even VCS has to take care of, not the compiler
09:59:24 <bennofs> RyanGlScott: you can place .hi / .o files in a different directory with -hidir and -odir flags i believe
09:59:44 <bennofs> then you only need to rm that directory after compilation
10:00:15 <zoug> hello guys, I have a f'n defined as "whereIsMyNumber :: (Num a) => a -> String" and "whereIsMyNumber myNumber (newline,indented) | myNumber >= 100 = "Higher than 100"" (then some other guards). But ghci complains that it cannont deduce (Ord a) arising from the use of ">=" from context (Num a). Even when I change Num a to Ord a (which wouldn't matter here) still same error, this time it cannot deduce (Num a)
10:00:17 <zoug> from context (Ord a). Could you explain to me what's wrong? Thank you!!
10:00:43 <mauke{> I don't understand what you mean by "which wouldn't matter here"
10:00:53 <mauke{> you need Num for 100 and Ord for >=
10:01:02 <zoug> so both?
10:01:04 <chpatrick> yep
10:01:09 <mauke{> yeah: (Num a, Ord a) =>
10:01:12 <zoug> how could a do that
10:01:15 <zoug> ooookey
10:01:19 <zoug> wasn't aware of that..
10:01:29 <zoug> thank you
10:01:52 <zoug> but why isn't Ord "implicit" from the use of Num
10:02:01 <mauke{> because not all numbers are ordered
10:02:09 <mauke{> for example complex numbers
10:02:50 <zoug> hm so Haskell uses complex numbers natively? Not like a tuple (a,a) or something of the sort?
10:03:04 <zoug> (sorry if my questions are noobish I'm very new to the language)
10:03:09 <chpatrick> what do you mean natively?
10:03:21 <zoug> well complex numbers as part of Num
10:03:30 <bennofs> zoug: there is a type for Complex numbers which is an instance of the class Num but not an instance of the type class Ord
10:03:41 <zoug> got it
10:03:45 <zoug> thank you guys
10:04:20 <mauke{> well, it kind of depends what you mean by "native"
10:04:27 <mauke{> it is a pair of reals internally
10:04:37 <mauke{> but you can do things like:
10:04:42 <mauke{> > sqrt (-42) :: Complex Double
10:04:44 <lambdabot>  0.0 :+ 6.48074069840786
10:05:17 <zoug> okey then!
10:05:17 <mauke{> > (1 :: Complex Double) >= 0
10:05:18 <lambdabot>      No instance for (Ord (Complex Double)) arising from a use of ‘>=’
10:05:18 <lambdabot>      In the expression: (1 :: Complex Double) >= 0
10:05:32 <mauke{> and here's the non-existent instance
10:18:03 * hackagebot Earley 0.8.2 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.8.2 (OlleFredriksson)
10:19:38 <zoug> sorry if this is dumb again but I don't understand why "function :: (Ord a, Ordering b) => a -> a -> b" doesn't cut it while "function :: (Ord a) => a -> a -> Ordering" works?
10:20:20 <geekosaur> Ordering is a type
10:20:49 <geekosaur> Ord is a typeclass, so you need to qualify an unspecified type a with the typeclass to say what types a may be
10:21:18 <geekosaur> Ordering is a type; some old versions of ghc would actually accept that definition since it reduces to b ~ Ordering
10:21:43 <shachaf> geekosaur: ?!
10:21:43 <geekosaur> but technically it's wrong, b must always be Ordering so the constraint makes no sense
10:21:44 <shachaf> Is that true?
10:21:49 <shachaf> Which versions of GHC?
10:22:05 <geekosaur> I think some 7.8 releases did that?
10:22:40 <zoug> okey! thanks!
10:23:17 <shachaf> Do you have a link or something? I'd be surprised.
10:23:45 <geekosaur> oh, hm, maybe it doesn't manifest in that specific way. I just got an error testing it that indicates the bug I was thinking of in 7.8.3 but it does nto actually accept it
10:24:17 <geekosaur> (the fundamental bug was confusion between types and typeclasses; in this case it gets caught because Ordering is not kind * -> *)
10:25:06 <geekosaur> although I feel like some version did get the kind-ing wrong as well at one point,,,
10:25:41 <geekosaur> basically early versions of support for DataKinds led to ghc accepting some rather dubious constraints
10:30:06 <dolio> Are you thinking of the 'Int => Int' bug?
10:36:13 <geekosaur> yes but my impression was it was a deeper issue than just that?
10:36:32 <geekosaur> I was just trying to find the discussion in #ghc but don't know the right keywords...
11:23:06 * hackagebot yesod-auth-basic 0.1.0.2 - Yesod Middleware for HTTP Basic Authentication  http://hackage.haskell.org/package/yesod-auth-basic-0.1.0.2 (ChristopherReichert)
11:28:06 * hackagebot file-location 0.4.9 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.9 (GregWeber)
11:51:19 <Tuplanolla> Is there a way to get offline documentation for every package without having to build them?
11:52:59 <davean> Tuplanolla: you can download the docs from hackage. they won't match your system and they are incomplete
11:53:20 <Tuplanolla> Matching is not a problem, but completeness is.
11:53:22 <davean> your system will be incomplete also, but differently so and match it's self
11:53:47 <davean> no system can be completed
11:57:29 <zipper> How can I stop the currently a running warp server? I tried killing the threadId of the thread that spawned it but that didn't seem to work.
11:57:46 <zipper> or how can I free a port on an IP address.
12:01:33 <sccrstud92_> zipper: i think you have to close the socket
12:02:27 <zipper> sccrstud92_: Thanks, let me see how it goes.
12:08:02 <zipper> Okay I don't see how I can close the port that warp is holding.
12:08:29 <zipper> Because closing sockets is provided by Network.Socket
12:09:07 <sccrstud92_> zipper: if you ctrl-C the server thread
12:09:10 <sccrstud92_> does that free the port?
12:09:23 <sccrstud92_> maybe you can throwTo tid KillThread
12:09:32 <sccrstud92_> unless thats what ur already doing
12:11:16 <zipper> Yes Ctrl-C works
12:11:19 <zipper> sccrstud92_: ^
12:11:33 <zipper> throwTo?
12:11:38 <zipper> :t throwTo
12:11:40 <lambdabot> Exception e => GHC.Conc.Sync.ThreadId -> e -> IO ()
12:12:42 <zipper> sccrstud92_: I want if the socket is in use. I want it released.
12:13:40 <sccrstud92_> im not well knowledgable in this area
12:13:51 <sccrstud92_> wat i said it pretty much all ive got =(
12:14:05 <zipper> sccrstud92_: What does throwTo do?
12:14:12 <zipper> That killThread doesn't do?
12:15:27 <zipper> Checked it. It might worl
12:15:30 <zipper> *work
12:16:08 <sccrstud92_> when you use killThread
12:16:23 <sccrstud92_> does the thread actually die? and the port is just not freed? or does the thread live still?
12:16:54 <Tuplanolla> When managing sockets, you have to close them properly, create them with the reuse flags or wait for the operating system to purge them.
12:16:55 <zipper> No it doesn't seem to actually die
12:17:25 <zipper> The problem is that I'm not creating the socket in my code.
12:17:37 <zipper> So I can't manage how it's closed or opened.
12:18:06 <sccrstud92_> warp is opening and using the socket
12:18:24 <Tuplanolla> Then you'll have to throw an exception or send a signal in hopes of the library handling it properly.
12:18:37 <sccrstud92_> zipper is
12:18:44 <sccrstud92_> using killThread
12:23:08 * hackagebot hybrid-vectors 0.2 - Hybrid vectors e.g. Mixed Boxed/Unboxed vectors  http://hackage.haskell.org/package/hybrid-vectors-0.2 (EdwardKmett)
12:26:31 <orzo_> is there any example code for a c library written in haskell?
12:27:12 <orzo_> How do hs_init()..hs_exit() blocks interract with multiple threads?
12:27:32 <mizu_no_oto> You mean of interacting with the FFI to C in Haskell?
12:28:21 <orzo_> i mean i have code that uses a C library and i want to replace that C library with haskell and I'd rather leave the C interface
12:29:06 <orzo_> it's a library used by webkit and i don't want to have to do a significant fork of webkit
12:30:37 <Tuplanolla> I have a template for linking Haskell code with C code here: https://github.com/Tuplanolla/ld-prehaskell
12:30:41 <edwardk> orzo_: it is admittedly a rather large pain to invoke haskell from c. getting all the right objects linked in, etc. is non-trivial.
12:30:45 <Tuplanolla> It might be of some use, orzo_.
12:33:14 <tmtwd> given this data Graph a = Graph [a] [(a, a)] deriving (Show, Eq), how do I declare a variable (say) a, that is a graph?
12:33:24 <tmtwd> I tried a = [1] [( 32,2)]
12:33:31 <tmtwd> but it was not correnct
12:34:12 <verement> tmtwd: a = Graph [1] [(32,2)]
12:34:19 <tmtwd> ah
12:36:50 <orzo_> thanks Tuplanolla.  But your start/stop_the_haskell functions seem to contradict this stack overflow answer http://stackoverflow.com/questions/11137443/is-it-possible-to-embed-haskell-in-a-c-library-opaquely#
12:37:38 <orzo_> "nested layers of calls to hs_init and hs_exit should be OK"
12:38:29 <Tuplanolla> I think that's false.
12:43:07 <orzo_> Tuplanolla: really nifty, thanks.  This should be on a wiki somewhere
12:43:25 <Tuplanolla> Someone would have to write it first.
12:46:47 <scutigera> attoparsec rule to break a line into words ?
12:46:56 <scutigera> many1 (notChar ' ') `sepBy` (char ' ')
12:47:01 <scutigera> gives me only the first word
12:50:13 <asmyers> scutigera, Can't test this right now but do you want many1 ((notChar ' ') `sepBy` (char ' '))
12:50:14 <asmyers> ?
12:52:32 <asmyers> scutigera, Actually that works for me
12:52:52 <asmyers> parseOnly (many1 (notChar ' ') `sepBy` (char ' ')) "foo bar baz" => Right ["foo","bar","baz"]
12:52:58 <Cale> scutigera: I think it's just that many1 isn't greedy. If you give it something to look for following the many1, such as endOfInput, it should match the whole thing
12:53:34 <arkeet> uh
12:53:47 <arkeet> shouldn't it just be notChar ' ' `sepBy1` char ' '
12:54:21 <arkeet> wait nm
12:55:07 <Cale> er, sorry, it's that sepBy isn't greedy, rather
12:55:30 <Cale> (but is that true?)
12:56:00 <Cale> Based on the source of the most current version of attoparsec, sepBy looks like it ought to prefer longer matches
12:56:12 <Cale> But I don't know if that's different in other versions
12:58:10 * hackagebot product-profunctors 0.6.3 - product-profunctors  http://hackage.haskell.org/package/product-profunctors-0.6.3 (tomjaguarpaw)
13:00:32 <scutigera> asmyers: interesting. i seem to get an inifinite loop.
13:02:25 <dropfreeze> dunb
13:04:14 <scutigera> ah- i think the problem is that my test string has multiple spaces between words.
13:04:31 <scutigera> yep- that's the problem.
13:04:49 <scutigera> also a leading space screws things up too
13:11:20 <bobajett> stupid noobie question: Could someone explain the precedence problem here: putStrl $ "Lucky Number " ++ show $ 3 + 3
13:12:02 <bobajett> my confusion is Im thinking: show $ 3 + 3 -- should evaluate to 6 and then "6" but ghci doesn't think so.
13:12:45 <Tuplanolla> Each operator splits the expression into two.
13:13:03 <lyxia> putStrl (("Lucky Number " ++ show) (3 + 3))
13:13:12 <verement> bobajett: ($) has lower precedence than (++)
13:13:33 <bobajett> ah! Thanks guys!
13:15:45 <aupiff> what function has type Int -> Word? hoogle isn't being helpful
13:15:56 <c_wraith> :t fromIntegral
13:15:57 <lambdabot> (Integral a, Num b) => a -> b
13:16:15 <aupiff> mmmm
13:16:17 <aupiff> thanks!
13:17:30 <mizu_no_oto> What would it take to get hoogle to search typeclasses?
13:17:47 <c_wraith> It would take classes being closed. :)
13:18:17 <aupiff> c_wraith: closed? under some operation? or what do you mean?
13:18:47 <c_wraith> aupiff: closed universe.  The current situation is open universe - new instances can always be added somewhere else.
13:19:24 <mizu_no_oto> c_wraith: why does that matter?  You can search all the instances in the set of libraries you're currently indexing
13:19:39 <c_wraith> mizu_no_oto: technically, fromIntegral's type unifies with *all* other function types.
13:19:55 <c_wraith> mizu_no_oto: It just introduces some (potentially weird) constraints when it does
13:19:55 <Haskellfant> c_wraith: well the universe that hoogle considers is closed at a fixed point in time
13:21:08 <c_wraith> :t (>>=) `asTypeOf` fromIntegral
13:21:09 <lambdabot> (Integral (m a), Monad m, Num ((a -> m b) -> m b)) => m a -> (a -> m b) -> m b
13:21:28 <c_wraith> See?  fromIntegral unifies with every function!
13:22:16 <mizu_no_oto> c_wraith: in this case, you have concrete types available - Int and Word
13:22:39 <c_wraith> mizu_no_oto: sure, but then you have thousands of matching functions, and it comes down to sorting.
13:23:11 * hackagebot yst 0.5.0.4 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.5.0.4 (JohnMacFarlane)
13:23:15 <c_wraith> mizu_no_oto: and while unsafeCoerce is an easy last resort, it's less easy to order the other "wierdly matching" functions
13:29:37 <scutigera> oh yay. i can break a bunch of space separate stuff into words with attoparsec... lol
13:30:17 <c_wraith> scutigera: it's an important step along the way. :)
13:30:39 <scutigera> well i'm finding that these "easy" parsers are teaching me quite a bit.
13:30:48 <scutigera> just to get me used to looking at them
13:30:53 <c_wraith> That's what I meant.  You learn a ton getting the easist things working.
13:31:00 <c_wraith> I totally agree with you. :)
13:31:20 <scutigera> sepBy p s = liftA2 (:) p ((s *> sepBy1 p s) <|> pure []) <|> pure []
13:31:36 <scutigera> holy cray- that's totally non-obvious !
13:32:07 <scutigera> at least now i know as soon as i see pure - applicative !
13:32:15 <scutigera> holy crap*
13:32:33 <scutigera> or i suppose holy crayfish
13:32:56 <monochrom> the monadic version is more obvious
13:32:57 <c_wraith> Or even Cray supercomputers!  Remember when we didn't all have portable phones more powerful than a Cray? :)
13:33:03 <scutigera> lol
13:33:12 <scutigera> i do! i'm that f'ing old
13:33:12 * hackagebot gitit 0.11 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.11 (JohnMacFarlane)
13:33:17 <Tuplanolla> It's also common to see liftA2 written in infix, scutigera.
13:33:42 <scutigera> unfortunately the whole "lift" thing is not something i've internalized yet.
13:33:59 <scutigera> so i see it and sort of get a happy bovine look in my eyes
13:34:46 <scutigera> @hoogle liftA2
13:34:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:35:01 <scutigera> oh- that's no so bad.
13:35:05 <Tuplanolla> Specifically liftA2 f x y == f <$> x <*> y.
13:35:15 <Tuplanolla> That pattern appears in many places.
13:35:52 <scutigera> yeah- part of my problem is that everytime i see <$> and  <*> i have to look them up, i.e. not internalized.
13:36:14 <scutigera> i just now sort of "got" the whole monad chaining thing the other day.
13:37:08 <c_wraith> scutigera: did it feel like a letdown, because there was all that hype for what turned out to be a pretty simple concept?
13:37:11 <verement> scutigera: you may know (<$>) as `fmap`
13:37:33 <scutigera> verement: oh- that helps...
13:38:12 <scutigera> c_wraith: not at all. it's always a good feeling to "get" something.
13:38:29 <scutigera> in the old days we used to say "grok".
13:38:39 <verement> some of us still do!
13:38:41 <Peaker> c_wraith, I remember when I first started understanding monads they seemed really cool and not that trivial.. only much later did it start to feel like "all that fuss for that little thing?" :)
13:38:48 <scutigera> but i think that's fallen out of style. not enough people reading stranger in a strange land ;-/)
13:39:11 <scutigera> Peaker: i look forward for that day to come !!
13:39:15 <c_wraith> scutigera: the further we get from the 60s, the more Stranger seems like Heinlein's incoherent rambling. :)
13:40:21 <scutigera> *sigh* the yute of today ;-)
13:41:02 <scutigera> however - back on topic- the structure of sepBy is really quite interesting
13:41:26 <scutigera> you can see how powerful it is since it's separating a parser and a parser
13:42:05 <scutigera> i mean each of those parsers could be quite complex and you can just say p `sepBy` s and you are good to go.
13:42:07 <scutigera> pretty cool.
13:42:20 <c_wraith> don't underestimate how much of the work <|> is doing
13:42:44 <c_wraith> It's what takes care of going "oh, that didn't match? try this instead"
13:43:59 <scutigera> the funny thing is that i'm having the most trouble with "skipping" things.
13:44:17 <c_wraith> Ah.  the *> operator is responsible for the skipping
13:44:19 <scutigera> the many and many1 distinction. i keep getting into trouble with infinite loops
13:44:31 <c_wraith> :t (*>)
13:44:32 <lambdabot> Applicative f => f a -> f b -> f b
13:44:37 <Tuplanolla> There's also <$.
13:44:53 <scutigera> ok <* and *> i'm using.
13:44:57 <scutigera> <$ is a new one
13:45:05 <scutigera> :t <$
13:45:05 <c_wraith> Note that it turns out *> is identical to >>
13:45:06 <lambdabot> parse error on input ‘<$’
13:45:12 <scutigera> :t (<$)
13:45:13 <lambdabot> Functor f => a -> f b -> f a
13:45:34 <c_wraith> :t ($<)
13:45:36 <lambdabot>     Not in scope: ‘$<’
13:45:36 <lambdabot>     Perhaps you meant one of these:
13:45:36 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
13:45:44 <c_wraith> Doesn't have contravariant imported, I guess. :)
13:45:47 <scutigera> c_wraith: but then why is it defined ?
13:46:02 <scutigera> oh wait- *> is applicative and >> is monadic ?
13:46:02 <c_wraith> scutigera: because not all instances of Applicative are also instances of Monad
13:46:04 <c_wraith> yep
13:46:17 <scutigera> hey - wait a minute
13:46:22 <c_wraith> This is a fair time to wonder why >> exists at all, then.
13:46:27 <scutigera> i thought that applicative was a strict subset of monadic ??
13:46:42 <crough> c_wraith: Not all monads were applicatives until 7.10
13:46:45 <c_wraith> That means all instances of Monad can be instances of Applicative
13:46:46 <nullvoid8> scutigera: until recently, that was just on the honor code
13:47:15 <crough> c_wraith: 7.8 threw a warning, 7.6 and before was just convention
13:47:16 <c_wraith> But not all instances of Applicative can be instances of Monad.  Applicative does fewer things, so it places fewer constraints on types that work with it.
13:47:18 <nullvoid8> and it's still the case that the default applicative is not always that which given by the monad
13:47:30 <scutigera> c_wraith: oh i'm really confused then.
13:47:39 <Peaker> scutigera, Monad used to be indepdendent from Applicative. While the "correct" thing to do was to use Applicative when you don't need Monad, that could easily cause your code to look like:  foo :: (Monad m, Applicative m) => ...   now that Monad subclasses Applicative, it shouldn't be a problem
13:47:49 <crough> nullvoid8: for instance, Asynchronously is a big difference between the applicative and monad definitions.
13:47:54 <c_wraith> scutigera: Applicative's *operations* are a subset of Monad's
13:48:07 <c_wraith> scutigera: but that means more types can be Applicative than Monad.
13:48:13 * hackagebot pandoc 1.15 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15 (JohnMacFarlane)
13:48:17 <scutigera> ah- ok. i see.
13:48:18 <crough> nullvoid8: And for good reason. The (<*>) is always 'ap' rule is useless...
13:48:21 <Tuplanolla> Historical baggage is great.
13:48:33 <Peaker> scutigera, so if you were using something as a Monad, you'd use (>>) and `ap` and `liftM2`.  And if you were using it as Applicative, you'd use (*>) and `<*>` and `liftA2`
13:48:48 <crough> Peaker: Yup.
13:49:08 <crough> Peaker: 99/100 times, it won't matter in those cases, but there are a few important cases where it absolutely does
13:49:53 <Peaker> crough, well, at the very least it matters because it used to duplicate code.. You couldn't write code to be as generic as possible
13:50:23 <Peaker> (It matters if you can use the more generic version, I mean)
13:50:23 <crough> Peaker: Yes, but you really shouldn't be using the monadic variants at all unless you need the behavior
13:50:35 <bitemyapp> crough: Ed convinced me to not make a differentiated Monad and make the users newtype over so that "consent" to a Monad with different semantics than the Applicative was explicit.
13:50:36 <Peaker> crough, *now* that's true :)
13:50:54 <crough> For instance, with `a >> b`, a always happens _first_. `a *> b` can execute at the same time
13:50:55 <bitemyapp> http://hackage.haskell.org/package/either-4.4.1/docs/Data-Either-Validation.html no monad.
13:51:12 <Peaker> crough, (>>) is a class method, isn't it? :)
13:51:24 <crough> Peaker: No. It's derived from >>=
13:51:30 <Peaker> crough, :i says otherwise :)
13:51:43 <crough> Peaker: a >> b = a >>= const b
13:51:48 <Peaker> crough, only by default
13:51:51 <geekosaur> it's a class method for optimization reasons
13:52:00 <Peaker> well, you *can* implement it to equal (*>) :)
13:52:05 <c_wraith> The ApplicativeDo extension from Simon Marlowe/Facebook is all about making do notation generate uses of Applicative operators rather than Monad operators where it detects it to be possible.
13:52:24 <crough> ApplicativeDo is so good for highly parallel code.
13:52:32 <crough> (And keeping your stuff readable)
13:52:35 <c_wraith> Facebook seems pretty happy with it in practice.  Hopefully it makes it into GHC mainline by next year.
14:02:15 <sccrstud92_> anyone here going to sc15?
14:14:20 <phaazon_> hey
14:14:32 <phaazon_> how do you encode a wildcard with MultiWayIf?
14:14:35 <phaazon_> if | …
14:14:38 <phaazon_>    | _ -> ?
14:14:44 <phaazon_> or otherwise ->_?
14:14:45 <phaazon_> -_
14:14:50 <hiptobecubic> otherwise is just true
14:14:58 <phaazon_> yeah, I know
14:15:09 <phaazon_> I guess it’s better to use otherwise then
14:15:20 <phaazon_> because there’s no pattern matching involved
14:15:22 <hiptobecubic> if expects a bool doesn't it?
14:15:28 <hiptobecubic> so you have no choice really
14:15:28 <phaazon_> if, yes
14:15:36 <phaazon_> but the multiwayif, I don’t know
14:15:55 <phaazon_> yeah
14:16:01 <phaazon_> that sounds logical actually
14:16:03 <phaazon_> thanks \o
14:31:33 <Guest34819> So, for compiler rewrite rules, do they just not work on class functions?
14:31:57 <Guest34819> All I could hunt down is a stack overflow question from 2012 : http://stackoverflow.com/questions/9811294/rewrite-rules-not-firing-for-rules-matching-multiple-instance-methods
14:33:03 <Lokathor> i had to write my own average :: (Real a, Fractional b) => [a] -> b
14:33:29 <Lokathor> it was short and all, but i'd just figured that it would already be in some lib
14:55:24 <zoug> okey I'm struggling with some basic concepts if you guys could clear that up: can a f'n defined as f'n :: (Num a) => [(a,a)] -> [a] accept input like [(10,20),(25,58)] (a list of tuples)??
14:55:55 <zoug> or is the only valid input here something like [(10,20)] (so a list of one and only one tuple)
14:56:05 <Guest34819> Multiple work
14:56:41 <zoug> because ghc complains when I try the input [(10,20),(25,58)] and it works with [(10,20)]
14:56:57 <tabemann> zoug: what is your function?
14:57:47 <zoug> calcBmis xs = [bmi w h | (w, h) <- xs]  
14:57:49 <zoug>     where bmi weight height = weight / height ^ 2
14:58:16 * hackagebot cql-io 0.14.3 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.14.3 (ToralfWittner)
14:58:18 * hackagebot redis-io 0.5.1 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.5.1 (ToralfWittner)
14:58:19 <zoug> with the above type definition tabemann 
14:59:16 <slack1256> @let calcBmis xs = let bmi weight height = weight / height ^ 2 in [bmi w h | (w, h) <- xs]
14:59:17 <lambdabot>  Defined.
14:59:26 <Guest34819> Ahh, Num is too general, you need Fractional
14:59:40 <slack1256> > calcBmis [(10,20), (28, 10)]
14:59:41 <Guest34819> calcBmis :: (Fractional a) => [(a, a)] -> a
14:59:42 <lambdabot>  [2.5e-2,0.28]
14:59:50 <Guest34819> calcBmis :: (Fractional a) => [(a, a)] -> [a]
14:59:51 <slack1256> @type calcBmis
14:59:52 <lambdabot> Fractional t => [(t, t)] -> [t]
15:00:23 <slack1256> You got a (/) on the definition and thus Fractional is implied. Thus the type signature
15:00:26 <slack1256> @info Fractional
15:00:26 <lambdabot> Fractional
15:00:38 <slack1256> >:info Fractional
15:00:44 <slack1256> > :info Fractional
15:00:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:01:21 <slack1256> welp. (/) is for Floating point number (the ones fitting on the Fractional type class). `div` is for integer like
15:01:36 <jle`> slack1256: there's no @info in lambdabot :)
15:01:40 <zoug> :t div
15:01:41 <lambdabot> Integral a => a -> a -> a
15:01:59 <zoug> okey thank you I think I got it
15:02:18 <slack1256> jle`: I could swear it had it!
15:02:34 <jle`> never :O
15:02:45 <jle`> i'm not sure what it would output, too
15:03:02 <slack1256> Class methods?
15:03:14 <slack1256> it doesn't has to list the instances as in ghci
15:03:56 <slaterr> I am scraping a web site and I want to speed things up by downloading the pages in parallel. what would be the best way to accomplish that?  I have something like this:  urls :: [Url]  downloadHtml :: Url -> IO String
15:04:18 <slaterr> and I want parallel [Url] -> IO [String]
15:04:19 <jle`> slaterr: you can use the `async` library
15:04:57 <jle`> slaterr: it's mapConcurrently from the async library, i think
15:05:25 <slaterr> cool thanks.. they even used the same example in their document
15:05:27 <jle`> mapConcurrently :: (a -> IO b) -> [a] -> IO [b]
15:05:36 <slaterr> +ation
15:05:45 <jle`> but it works on any Traversable container too, like Map, Maybe, Either, etc.
15:05:50 <jle`> particularly useful for maps :)
15:05:57 <slaterr> nice
15:06:03 <jle`> mapConcurrently :: (a -> IO b) -> Map k a -> IO (Map k b)
15:06:17 <jle`> execute the action on every item in the Map in parallel :o
15:06:37 <slaterr> :P
15:06:47 <jle`> Map is probably my favorite Traversable instance, heh
15:06:59 <c_wraith> Huh.  I find lacking the keys to often be painful
15:07:10 <slaterr> how many threads does mapConcurrently  launch?
15:07:21 <c_wraith> On the other hand, including the keys would break the Traversable laws...
15:07:32 <c_wraith> I think mapConcurrently does a forkIO for each element.
15:07:36 <c_wraith> forkIO is not a native thread
15:07:41 <jle`> yeah, so it depends on GHC's runtime to handle it
15:07:51 <c_wraith> GHC's RTS does m:n thread mapping
15:07:59 <c_wraith> .. with work-stealing
15:08:08 <jle`> if you want the keys then you can drop into lens i guess which is almost the same thing
15:08:18 <jle`> i just think Map embodies the idea of a "structure-preserving traversal" pretty well
15:08:27 <jle`> in a practical day-to-day sense
15:08:29 <Tuplanolla> This might be of interest, slaterr: http://chimera.labs.oreilly.com/books/1230000000929/index.html
15:09:06 <slaterr> how many do I even want to launch? as far as optimal speed (and perhaps etiquette) goes? does it depend on a web site?
15:09:18 <slack1256> Mmm why was implementing m:n at kernel level difficult but on the GHC's runtime possible?
15:09:25 <slack1256> or is the runtime pretty complex?
15:09:29 <c_wraith> slack1256: GHC uses cooperative threading
15:09:58 <jle`> slack1256: ghc is supposed to manage it so that it's "optimal"
15:10:07 <|f`-`|f> and some divine magic with sparkpools
15:10:08 <jle`> it doesn't really think about request etiquette though
15:10:25 <jle`> for fine-grained things you can use the Strategies library
15:10:39 <|f`-`|f> the diagrams imply it's heavy duty
15:10:53 <slaterr> I wish mapConcurrently took a number of threads. for a task that is IO bound it may be beneficial to run more threads than CPUs/cores
15:11:29 <sccrstud92_> slaterr: how would that help?
15:11:41 <|f`-`|f> I thought the runtime did the thing where it interleaved dozens of green threads between Cors
15:11:56 <|f`-`|f> since late '13, mid '14
15:12:04 <jle`> yeah, you can still use forkIO on single-cor ecomputers
15:12:08 <jle`> it interleaves
15:12:38 <|f`-`|f> (it gets more intense when you do sparking, but I think that's just a fancy term for interleaving)
15:12:42 <jle`> actually i think if you don't compile -threaded then that's what it does by default
15:12:50 <slaterr> sccrstud92 a web site can limit bandwidth per request
15:12:57 <|f`-`|f> (it seems to be mostly about how they fragment function calls)
15:13:10 <jle`> but it's been ove r ayear since i've read the marlow text so
15:13:39 <|f`-`|f> You can limit the amount of cores you use
15:13:47 <|f`-`|f> (from Parallel Haskell, the book)
15:17:14 <sccrstud92_> slaterr: doesnt mapConcurrently run 1 thread per element of the Traversable?
15:17:59 <|f`-`|f> and the runtime interleaves the threads
15:19:33 <sccrstud92_> c_wraith: with regards to traversing a Map with the keys
15:19:38 <thoughtpolice> |f`-`|f: forkIO has interleaved threads on multiple CPUs since ~2006 actually. :)
15:19:40 <sccrstud92_> do you get around the restriction
15:19:43 <sccrstud92_> by applying
15:19:53 <sccrstud92_> Map k v -> Map k (k, v)
15:19:56 <sccrstud92_> then traversing on that?
15:20:04 <sccrstud92_> or have you found a better way?
15:20:11 <|f`-`|f> neat, but there was a reworking of the manager system around ~14-14
15:20:13 <|f`-`|f> 13*
15:20:38 <|f`-`|f> One proccess across cores, one manager per core, as many threads as you could ever want
15:20:47 <thoughtpolice> The last major overhaul was more around 2010ish if I remember correctly. But it's been rewritten several times and seen a lot of changes.
15:21:05 <thoughtpolice> Yes, it's followed that scheme roughly since 2006. Unless I'm missing something.
15:21:08 <|f`-`|f> It was a result of mighty wanting to run even faster
15:21:11 <thoughtpolice> Well, maybe 2009.
15:21:26 <thoughtpolice> |f`-`|f: Ah, that's not quite the same thing, that's the I/O manager.
15:21:26 <|f`-`|f> 2009 was the time of Parallel Haskell, the book
15:22:20 <thoughtpolice> Which is what's responsible for submitting I/O requests to the underlying OS in an efficient manner (and it's actually written in Haskell, and exists in `base`). forkIO is purely CPU-bound and implemented by the runtime system, so it has scaled like you described for a much longer time.
15:24:36 <NicX> can anyone spot why my rule is not firing? http://lpaste.net/5642548027110457344
15:25:52 <slaterr> sccrstud92 it looks like it.
15:34:28 <c_wraith> NicX: I think it's because your RULES pragma doesn't have types listed
15:34:54 <c_wraith> NicX: I didn't even think they were valid without types
15:35:35 <c_wraith> NicX: nevermind, I'm very confused.
15:37:24 <NicX> c_wraith: might my problem be that LHS and RHS aren't fully applied?
15:37:36 <c_wraith> NicX: I was just going to suggest eta-expansion
15:37:41 <c_wraith> NicX: maybe it'll help
15:37:57 <nak> is it possible to have two expressions in a lambda ?
15:38:13 <nak> \x -> a x; b x;
15:38:15 <nak> something like that
15:38:20 <jle`> nak: what would that return?
15:38:24 <thoughtpolice> NicX: Hah, I think I know why
15:38:29 <Lokathor> what's the constant for the IEEE NAN value?
15:38:29 <thoughtpolice> It's because that RULE only works by default
15:38:31 <jle`> (\x -> f x; g x) 5 = ?
15:38:38 <nak> hmm
15:38:40 <nak> yeah i dunno
15:38:45 <jle`> (f 5; g 5) ?
15:38:50 <jle`> you can use a tuple
15:38:56 <jle`> > (\x -> (f x, g x)) 5
15:38:57 <nak> oo
15:38:57 <lambdabot>      No instance for (Show t0)
15:38:58 <lambdabot>        arising from a use of ‘show_M57303348980762961023619’
15:38:58 <lambdabot>      The type variable ‘t0’ is ambiguous
15:39:05 <thoughtpolice> I'm pretty sure you want 'forall e. d e = e', *not* 'd exp = exp', because GHC otherwise interprets 'exp' as the actual in-scope base version of exp, which is probably overloaded at Floating or whatever.
15:39:07 <jle`> > (\x -> (f x, g x)) 5 :: (Expr, Expr)
15:39:09 <lambdabot>  (f 5,g 5)
15:39:20 <slack1256> @let (;) a b = const a b
15:39:20 <lambdabot>  Parse failed: Parse error: ;
15:39:30 <jle`> ; is reserved, i think
15:39:31 <c_wraith> thoughtpolice: well, for the purposes of the test, that's not what is wanted
15:39:32 <jle`> for syntax
15:39:36 <slack1256> @let (:;:) a b = const a b
15:39:36 <lambdabot>  Parse failed: Parse error: ;
15:39:39 <nak> jle` thanks :)
15:39:42 <slack1256> yeah, as it ought to be
15:39:47 <c_wraith> thoughtpolice: but RULES matching exp earlier is likely the cause
15:39:49 <jle`> np!
15:40:01 <jle`> if you want to sequence two actions you can use (>>) or do notation
15:40:12 <jle`> (\x -> do f x; g x) or (\x -> f x >> g x)
15:40:56 <nak> @pl \x -> (f x, g x)
15:40:57 <lambdabot> liftM2 (,) f g
15:41:10 <nak> ok so what exactly is liftM2 doing there
15:41:16 <nak> @src liftM2
15:41:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:41:16 <jle`> i don't know why @pl still uses liftM2 instead of liftA2 haha
15:41:22 <jle`> but it's the (->) r instance
15:41:24 <nak> what is M2 vs A2 ?
15:41:25 <c_wraith> jle`: because it's old
15:41:36 <jle`> nak: it's the same for (->)
15:41:49 <jle`> it's the Applicative instance for (->) r, which is kidn of like the "fork and recombine" instance
15:41:54 <slack1256> nak: shorthand for Applicative and Monad
15:42:06 <jle`> liftA2 (,) f g = \x -> (,) (f x) (g x)
15:42:16 <slack1256> on the old days they were no related, so there was lots of duplication
15:42:23 <jle`> it returns a function that applies both f and g to the arguments, and then recombines with (,)
15:42:33 <jle`> > liftA2 (+) length read "9"
15:42:35 <lambdabot>  10
15:42:43 <jle`> here it applies length and read to "9", and recombines with (+)
15:42:57 <jle`> > liftA2 (++) reverse (take 3) "hello"
15:42:59 <lambdabot>  "ollehhel"
15:43:08 <jle`> it apples both reverse and take 3 to "hello", and combines with (++)
15:43:16 <jle`> this is the Applicative instance for functions
15:43:17 <NicX> c_wraith: I rewrote the rule with a new function that wraps around the exp function and now the rule fires
15:43:32 <NicX> myExp = exp
15:43:38 <nak> jle` but in my example, liftM2 works the same ?
15:43:46 <jle`> yeah, liftM2 = liftA2, where it exists
15:43:46 <thoughtpolice> NicX: which compiler? I tried this too but didn't see a difference
15:43:52 <nak> ah ok
15:43:59 <jle`> sometimes things can only have liftA2 and not liftM2
15:44:01 <thoughtpolice> I also tried to specialize 'exp' in the RULE itself to Double -> Double, but it didn't care for that either
15:44:06 <nak> should i generally use liftA2 then ?
15:44:10 <NicX> thoughtpolice: The Glorious Glasgow Haskell Compilation System, version 7.10.1
15:44:11 <jle`> but everything that has liftM2 also has liftA2 that is the same
15:44:14 <Guest34819> NicX: Try exp' :: Double -> Double
15:44:18 <Guest34819> and use that instead
15:44:19 <jle`> yeah, i think it makes more sense
15:44:23 <nak> ok
15:44:41 <Guest34819> I don't think RULES likes class functions
15:44:43 <jle`> liftM2 is a historical accident
15:45:05 <Guest34819> (exp' = exp)
15:46:19 <nak> jle` thank you again
15:46:43 <jle`> np!
15:46:43 <thoughtpolice> NicX: Strange, I cannot reproduce this! I had 'h = exp :: Double -> Double' at the top level and I still get 'exp 21.0' as the result for the first test
15:47:00 <Guest34819> NicX: http://lpaste.net/135674 works for me
15:47:14 <Guest34819> NicX's code does not work
15:47:17 <thoughtpolice> Oh, I fudged the RULE, I see.
15:47:38 <nak> @src liftA2
15:47:39 <lambdabot> liftA2 f a b = f <$> a <*> b
15:47:44 <nak> ok so <$> is fmap
15:47:47 <nak> but what is <*>
15:48:31 <NicX> Guest34819: that worked for me too
15:48:36 <slack1256> @type (<*>)
15:48:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:48:41 <Guest34819> I think it is a compiler
15:48:43 <Guest34819> bug
15:49:02 <Guest34819> ... Class op's occur before some rewrite rules
15:49:29 <slack1256> > Just (+ 1) <*> (Just (5 :: Int))
15:49:31 <lambdabot>  Just 6
15:49:37 <slack1256> > Just (+ 1) <*> Nothing
15:49:38 <lambdabot>  Nothing
15:50:52 <Guest34819> Try compiling with -ddump-simpl-stats? I have been trying to hunt this down all day actually... 
15:51:14 <Guest34819> Closest I found was http://stackoverflow.com/questions/9811294/rewrite-rules-not-firing-for-rules-matching-multiple-instance-methods
15:51:14 <nak> > Just (+1) <*> (Just 5)
15:51:16 <lambdabot>  Just 6
15:51:54 <Guest34819> Which suggests another work around
15:52:29 <nak> slack1256 that's an interesting one
15:52:41 <slack1256> yeah, lambdabot is a good kid
15:52:49 <random_nick> > Nothing <*> Just 1
15:52:51 <lambdabot>  Nothing
15:53:41 <dgpratt> ah, irony
15:53:57 <dgpratt> I tried to do a sandbox build of ghc-mod a couple days ago
15:54:10 <NicX> Guest34819: thanks for the link
15:54:20 <dgpratt> wasn't sure it would work, but I was hoping I could just move the relevant bits into the right location
15:55:05 <dgpratt> it failed because this was on Windows and there is/was a problem with sandboxed builds on Windows involving long file paths
15:55:17 <dgpratt> I was happy to learn it had been fixed!
15:55:51 <dgpratt> I was unhappy to later learn that the new version of cabal, et al is not compatible with ghc-mod!
15:56:07 <random_nick> NicX: np, all I found -- I think it is still a bug, if you want to file a report for it go ahead.
15:56:26 <dgpratt> if I had just installed it non-sandbox, it probably would've been ok
15:56:31 <dgpratt> now I have a mess
15:56:55 <blair> Hey, I don't suppose someone can help me with some code? I'm trying to learn how to do basic IO stuff
15:56:58 <nak> ok gotta make dinner. thx all
15:58:03 <Moggle> blair, still need help? i can go over some basics
15:59:44 <blair> Yeah, I'm having a hard time wrapping my head around what's happening in do blocks
15:59:54 <Moggle> alright, do you have a code example we can look over?
16:00:03 <lpaste> Blair pasted “Print lines” at http://lpaste.net/135675
16:00:45 <dgpratt> @undo do { x <- mx; return (f x); }
16:00:46 <lambdabot> mx >>= \ x -> return (f x)
16:01:02 <Moggle> alright, and you're not sure on what 'do' is doing here?
16:01:10 <Moggle> have you learned about monads in any detail?
16:01:42 <blair> A little yeah, I think that the sugar happening in the do blocks is what's confusing me
16:01:45 <Moggle> they arent really relevant for IO - the IO monad is super straightforward, but i'm not sure how advanced you are
16:01:48 <Moggle> okay
16:01:58 <Moggle> so
16:02:06 <Moggle> in a monad, you have the >>= function
16:02:11 <Moggle> do syntax is sugar for this
16:02:17 <Moggle> i'll write your code, sec.
16:02:31 <blair> Right, >>= is implicitly at the end of each line right?
16:03:42 <Peaker> blair, if you have: x <- stmt ; ... more lines ,  then it desugars to:  stmt >>= \x -> ... more lines
16:03:59 <Peaker> blair, if you have:  stmt ; ... more lines ,   then it desugars to:  stmt >> ... more lines
16:04:19 <Peaker> @undo do { a ; b ; x <- c ; d }
16:04:19 <lambdabot> a >> b >> c >>= \ x -> d
16:04:28 <Moggle> http://lpaste.net/135676
16:04:30 <Peaker> blair, ^^ this is how the desugaring looks like
16:04:33 <Moggle> something like this - brackets may be off.
16:04:34 <SwashBuckla> anyone here used Z notation? What for?
16:05:06 <Moggle> you're right that >>= is at the end of each line
16:05:09 <SwashBuckla> I'm using it for specification modelling for safety critical systems
16:05:18 <Moggle> though it uses >> (which ignores the lambda variable) if you don't do a var <- action thing.
16:05:53 <SwashBuckla> it's pretty elegant stuff but I've seen a lot of overly clever specs with it that could be written simpler
16:06:33 <slack1256> blair: I learned from here https://en.wikibooks.org/wiki/Haskell/Understanding_monads
16:07:00 <ElMoloko> What is the point of >>, other than just stringing together monads for the purpose of side effects?  If you're not passing data between monads...
16:07:01 <slack1256> it really pay off learning by (>>, >>=, return) and then using do notation
16:07:33 <hpc> @src (>>)
16:07:33 <lambdabot> m >> k = m >>= \_ -> k
16:07:49 <hpc> it's exactly the purpose
16:08:22 <hpc> ElMoloko: and a bit of terminology, "monad" only refers to the type
16:08:23 <slaterr> > print 10 >> print 20
16:08:25 <lambdabot>  <IO ()>
16:08:27 <hpc> ie, Maybe or IO
16:08:42 <Moggle> ElMoloko, look at this:
16:08:50 <Moggle> > Just 5 >> Nothing >> Just 10
16:08:51 <lambdabot>  Nothing
16:09:10 <Moggle> >> can be used in the Maybe monad to act as a "fail if any of these actions fail" sort of thing.
16:09:34 <Moggle> in an imperative language, you might do if (action fails) return; if (action 2 fails) return; if (action 3 fails); return
16:09:49 <Moggle> the maybe monad can encapsulate that kind of thing.
16:10:12 <slaterr> ElMoloko generally you would just use do x; y. but since >> is a function it can be passed to higher order functions
16:10:20 <Moggle> it's really really really really annoying to have to write code where you do case whatever of Just a -> something; Nothing -> whatever else.
16:10:34 <ElMoloko> Oh
16:10:37 <Moggle> you get a lot of indents.
16:11:18 <blair> Right. The Maybe monad makes a lot of sense, the IO monad I find a little bit more confusing
16:11:55 <ElMoloko> Ok...I'm going through some code I've written.  I'
16:11:59 <slaterr> here's one way to implement sequence_:
16:12:01 <ElMoloko> ve used >> a lot
16:12:33 <ElMoloko> trying to work out what I've meant, or if it was unneccesary
16:12:35 <hpc> blair: for IO, (mx >>= \x -> f x) is defined as
16:12:42 <slaterr> > let mysequence = foldr (>>) (return ())  in mysequence [print 10, print 20, print 30]
16:12:43 <lambdabot>  <IO ()>
16:12:54 <slaterr> should have named it mysequence_
16:12:56 <hpc> "perform mx, then pass the value returned to f, and execute the result of that next"
16:13:56 <hpc> so, getLine >>= \s -> putStrLn s -- read a line, then execute (putStrLn thatLineYouJustGot)
16:14:38 <random_nick> NicX: https://ghc.haskell.org/trac/ghc/ticket/10595
16:15:02 <ElMoloko> is it normal to use forM_ to act as a haskelly for loop?
16:15:08 <hpc> blair: in the case of IO, the "execute this thing" operation is a compiler miracle that you can just assume exists on trust
16:15:19 <ElMoloko> It seems a bit Rube-Goldbergy
16:15:30 <slaterr> ElMoloko sure. by the way it is just a flipped mapM_
16:15:45 <hpc> blair: which gives IO a bit of a magical quality that throws off newbies quite easily
16:15:48 <ElMoloko> oh whoa >.>
16:15:54 <hpc> because you don't often get forced to think about what makes a program run
16:16:14 <NicX> random_nick: wicked.
16:17:04 <ElMoloko> is it safe to assume though that if you're trying to implement a for loop in haskell, that you should take a step back and re-evaluate your life?
16:17:08 <ElMoloko> i mean algorithm
16:17:17 <hpc> ElMoloko: usually, but not always
16:17:33 <hpc> some things are genuinely easier to read in imperative style
16:17:44 <hpc> and it turns out that haskell is very good at writing nice imperative programs
16:17:56 <ElMoloko> huh
16:18:03 <hpc> my not-quite-a-joke saying is that haskell is my favorite imperative language and perl is my favorite functional language
16:18:40 <ElMoloko> Thank you for your wisdom :)
16:19:24 <slaterr> I usually prefer splitting the work into one or more functions and then passing it to forM_/mapM_ instead of doing: forM_ xs $ do <giant do block>
16:19:27 <hpc> that said, the cases where for-loops make sense are pretty few and far between and usually end up being restricted to forM
16:20:13 <hpc> slaterr: the way i usually organize things is "if you like it, put a name on it"
16:20:23 <hpc> and i end up not liking enough of my loop bodies to name them
16:20:31 <hpc> but i might like the loop itself enough!
16:20:41 <hpc> foo = forM_ ...
16:20:44 <ElMoloko> I'm trying to figure out how to implement the Viterbi algorithm in Haskell, and I'm having good time, but tearing my hair out
16:21:13 <hpc> ElMoloko: that's how you know the learning is working
16:24:19 <drewbert> I'm getting a cabal error for "cabal: can't find source for I502Tool/Api in src, dist/build/autogen", but src/I502Tool/API.hs definitely exists
16:25:04 <drewbert> Ohhh, haha, I'm a derp.
16:25:09 <drewbert> API and Api
16:28:21 * hackagebot nationstates 0.1.0 - NationStates API client  http://hackage.haskell.org/package/nationstates-0.1.0 (ChrisWong)
16:33:46 <lpaste> ElMoloko revised “viterbi.hs”: “viterbi.hs” at http://lpaste.net/135678
16:34:22 <ElMoloko> This is the problem, I stay up till 4 am writing something and "understanding" it, then the next evening I come back and can't understand my revelations
16:34:33 <kadoban> Anyone know if it's even vaguely possible to write vim plugins in haskell? I know you can do python and ruby and lua and … dunno?
16:35:38 <Moggle> vim exposes a C interface, doesn't it? worst case you'd have to write some bindings yourself
16:35:41 <Moggle> not sure
16:35:56 <kadoban> Does it? I can't find it. It's a pain to google for …
16:36:22 <slaterr> just swapping mapM with mapConcurrently increased the speed of downloading and parsing 20 pages from 2 seconds to 0.35 :P
16:36:47 <blair> if you aren't super-duper attached to vim.. https://github.com/knupfer/haskell-emacs      +     http://www.emacswiki.org/emacs/Evil
16:37:24 <kadoban> Naw, not really interested in emacs. Thanks though.
16:37:43 <blair> Even with all vim commands?
16:38:34 <kadoban> Probably not … all the vi compatibality stuff I've tried before has been spotty at best.
16:38:50 <ElMoloko> what about https://github.com/nh2/call-haskell-from-anything
16:39:25 <kadoban> That sounds interesting
16:40:03 <ElMoloko> because I know vim is easily extensible from python
16:40:37 <kadoban> Yeah I know you can use mostly-python
16:40:40 <ElMoloko> i remember ruby plugins being annoying though
16:40:51 <kadoban> I don't really know ruby so that's okay :)
16:41:33 <ElMoloko> it'd be interesting to see how well a python vim plugin, that actually relies solely on haskell would work
16:41:52 <kadoban> I suspect not well, but … worth a look at least.
16:42:12 <kadoban> I really hope to avoid learning/using vimscript. I remember it sucking quite a bit.
16:42:52 <ElMoloko> The original vi api is still exposed in vim right?
16:43:31 <kadoban> I have no godly idea, haha. I browsed through the help files a bit, but I don't see much except vimscript and some stuff about python in other places, and one presentation about ruby I didn't look at much.
16:43:36 <Cale> I didn't know that vi *had* any kind of API
16:45:05 <ElMoloko> Yeah, I must be thinking of a derivative
16:53:28 <randypr_>  hi. what is haskell's wget equivalent? I could just launch wget but that sees lame
16:54:25 <ElMoloko> what are you trying to do? (what flags are you running wget with)
16:55:02 <randypr_> I just want to download whatever it is on the link (image, gzip) and store it to a file
16:55:41 <ElMoloko> Try using conduit
16:56:13 <ElMoloko> i mean http-conduit
16:56:27 <randypr> ok thanks
16:59:34 <randypr> should I use lazy or strict bytestring?
16:59:48 <pharaun> whichever fits your needs?
16:59:58 <dmj`> lazy, but ideally and iteratee, which processes strict bytestrings incrementally in I/O
17:00:00 <randypr> I dont know what dies
17:00:02 <dmj`> an*
17:00:05 <randypr> does
17:00:08 <hpc> use both inconsistently and constantly convert between them ;)
17:00:21 <sccrstud92_> randypr_: this is simple http://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html
17:00:31 <dmj`> sccrstud92_: not really
17:00:34 <randypr> lazyness still seems like black magic
17:00:46 <dmj`> randypr: HTTP is probably simpler
17:00:51 <sccrstud92_> dmj`: what about it is not simple?
17:00:59 <dmj`> randypr: there's http-streams, http-client, http-client-streams, pipes-http
17:01:18 <dmj`> http-conduit
17:01:23 <randypr> I hate choices
17:01:38 <hpc> dmj`: you'd be amazed the complexity hidden in HTTP and MIME in general
17:01:47 <dmj`> sccrstud92_: lens
17:02:03 <randypr> for downloading images is lazy or strict bytestring prefered?
17:02:49 <joehillen> strict
17:02:58 <sccrstud92_> dmj`: eh
17:03:26 <randypr> can you explain why? maybe it will help in understanding lazyness
17:03:29 <hpc> Wreq actually looks like a pretty good 1:1 module for HTTP
17:04:22 <joehillen> hpc: yes, it's a very good module, I use it on my servers
17:05:01 <joehillen> randypr: my understand (and I haven't pinned this down definitively) is that any lazy readFile will blow up with memory
17:05:05 <sccrstud92_> randypr: have you used conduit, pipes, or lens before?
17:05:11 <hpc> there's only one thing i can see that it doesn't do, and that's tomfoolery with the HTTP 1.1 domain
17:05:21 <randypr> sccrstud92_: only lens casually
17:05:26 <hpc> because a request goes something like HTTP/1.1 GET foo.com
17:05:48 <hpc> and you can make such a request to an ip address (for say a dev server that's virtualhosting a ton of sites)
17:06:04 <dmj`> randypr: strict will read everything into memory, lazy won't, but lazy doesn't guarantee resource cleanup. 
17:06:09 <dmj`> randypr: https://wiki.haskell.org/Iteratee_I/O
17:06:30 <dmj`> http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
17:07:02 <randypr> so if I am downloading a huge file (say 40 GB iso) lazy ByteString would not load it all in memory?
17:07:25 <joehillen> I've always had problems with lazy reads that keep handles open unexpectedly
17:08:09 <dolio> Why are you rewriting wget in Haskell?
17:08:13 <sccrstud92_> dmj`: what would you recommend between iteratees pipes and conduit for his situation
17:08:17 <dolio> wget already works.
17:08:32 <sccrstud92_> dolio: hes not rewriting. he needs wget as a library
17:08:59 <dolio> That hasn't actually been said.
17:09:04 <hpc> nobody ever needs wget
17:09:07 <randypr> I just need to download a file from http. I am not rewritinf wget nor do I need all of its functionality
17:09:13 <slack1256> Lazy bytestrings seems more fitting for producing data than consuming
17:09:15 <hpc> if you think you need wget, all you need is to make an http request
17:09:23 <dolio> All that's been said is that a file needs to be downloaded and saved.
17:09:27 <slack1256> you don't really want laziness on the boundary of your programs
17:09:28 <hpc> which wget can satisfy that need
17:09:32 <sccrstud92_> dolio: "hi. what is haskell's wget equivalent? I could just launch wget but that sees lame"
17:09:48 <hpc> but so can curl, firefox, a bit of programming
17:10:13 <idetuxs> I have a doubt: having two finite lists, can I made them run indefinitely? I am using recursion with pattern matching for this function. I don't think I can achieve this with pattern matching, right?
17:10:31 <sccrstud92_> how do you run a list?
17:10:32 <joehillen> sccrstud92_: conduit is the best for things that talk to the real world, it was specifically designed for http-conduit, where as pipes and interatee were designed just for data munging 
17:10:35 <hpc> idetuxs: what do you mean by "run indefinitely"?
17:10:53 <sccrstud92_> joehillen: data munging?
17:10:56 <kadoban> idetuxs: Define "run" ? Can you make an infinite list out of them? Yes.
17:10:58 <randypr> sccrstud92_: I thought my last message cleared any confusion
17:10:59 <idetuxs> like taking all over the list again and process it to the function
17:11:40 <idetuxs> run, as in pass it to the function to process it
17:11:42 <slaterr> > map (\(x,y) -> (x*2,y*3)) [1..] [1..]
17:11:43 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
17:11:44 <lambdabot>                  with actual type ‘[(t0, t1)]’
17:11:44 <lambdabot>      The function ‘map’ is applied to three arguments,
17:11:46 <idetuxs> may be I am to vague?
17:11:49 <slaterr> > map (\(x,y) -> (x*2,y*3)) (zip [1..] [1..])
17:11:49 <sccrstud92_> randypr: im not confused. i was just pointing out to dolio that you did actually say you wanted wget, even if you misphrased what you wanted
17:11:51 <lambdabot>  [(2,3),(4,6),(6,9),(8,12),(10,15),(12,18),(14,21),(16,24),(18,27),(20,30),(2...
17:11:53 <joehillen> sccrstud92_: https://en.wikipedia.org/wiki/Mung_%28computer_term%29 " data parsing, filtering, and transformation"
17:12:06 <kadoban> idetuxs: I still don't really understand what you mean. Maybe you're looking for ```cycle``` ?
17:12:12 <slaterr> > map ((*2) *** (*3)) (zip [1..] [1..])
17:12:13 <lambdabot>  [(2,3),(4,6),(6,9),(8,12),(10,15),(12,18),(14,21),(16,24),(18,27),(20,30),(2...
17:12:30 <hpc> randypr: if 40 gigs of data is kept in memory all at the same time depends on how you use it, more than what type of blob you store the data in memory with
17:12:32 <exio4> I wonder if there are any rewrite rules like `map f (zip xs ys) = zipWith (uncurry f) xs ys` in GHC
17:12:32 <idetuxs> I'll look into it
17:12:40 <dmj`> sccrstud92_: I like io-streams
17:12:52 <kadoban> > take 20 . cycle $ [1,2,3]
17:12:54 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2]
17:13:15 <randypr> sccrstud92_: so you keep dwelling on it just to defend him? I dont think there is anything to defend him from
17:13:26 <hpc> randypr: my advice is if you really care about it staying out of memory, make it explicit
17:13:46 <randypr> explicit?
17:13:49 <hpc> read the data in chunks, write to file, then forget the chunks and repeat until the download is done
17:13:52 <sccrstud92_> randypr: im only defending myself
17:14:14 <hpc> that's how you would handle a large file download in any language
17:14:21 <randypr> huh. double confusion
17:14:38 <randypr> hpc that sounds very imperative
17:14:43 <hpc> it is
17:15:06 <hpc> but for this problem it's a style of programming that prevents mishaps
17:15:07 <randypr> is there a more functional approach
17:15:09 <idetuxs> function1 (x:xs) (y:ys) = [(x,y)] ++ function1 xs ys, something like that, now if the two list are finite, I like them to repeate it from the beggining. This function has the definiton for the empty list in order to finish the recursion, if not it runs "for ever"
17:16:13 <randypr>  cant i just use lazy bytestrings?
17:16:18 <idetuxs> I need to rethink the problem, don't know if I'm being clear
17:16:43 <kadoban> idetuxs: Sounds like a combination of ```cycle``` and ```zip``` to me.
17:16:58 <hpc> randypr: likely yes, but then that piece of code becomes {- DO NOT TOUCH OR MEMORY EXPLOSION -} until you write it a different way
17:17:16 <dolio> Like all lazy code?
17:17:24 <hpc> per the stack overflow link that was posted above
17:17:50 <hpc> like all lazy code that tries to hold onto too many things at once
17:18:03 <hpc> or like a garbage-collected language where you try to hold onto too many things at once
17:18:07 <randypr> downloadHttp link >>= writeToFile path. is guaranteed not to load it all into memory?
17:18:24 * hackagebot SciFlow 0.2.0 - Scientific workflow management system  http://hackage.haskell.org/package/SciFlow-0.2.0 (kaizhang)
17:18:26 * hackagebot data-cell 1.0.0.1 - Generic cellular data representation library  http://hackage.haskell.org/package/data-cell-1.0.0.1 (patrykz)
17:19:36 <hpc> like, i would generally avoid relying on a garbage collector to close things that get out of scope
17:20:04 <hpc> unless it's made explicit with some sort of RAII
17:20:19 <randypr> sccrstud92_: anyway I didnt mean to make it sound like I am accusing you being confused, I was just trying to explain myself better
17:20:27 <hpc> like a with-block or something
17:20:52 <idetuxs> kadoban: if the list at a moment, comply with a predicate, it ends, if the recursion matchs function1 [] [] I need it to start again. You say I can accomplish this with cycle and zip?
17:21:01 <randypr> hpc is there anything wrong with the above code regarding memory use or noy closing handles?
17:21:52 <randypr> downloadHttp link >>= writeToFile path
17:21:58 <hpc> randypr: just using another example of the point i am trying to make
17:22:19 <dolio> randypr: It depends a lot on what downloadHttp does, and what types it uses.
17:22:20 <hpc> about the fine line that makes code ugly and what situations change how code is perceived
17:22:25 <dolio> That would probably be fine, though.
17:22:38 <idetuxs> kadoban: It's beacuse I lose the original list that I don't know if I can do it
17:22:47 <randypr> it returns a lazy ByteString
17:24:01 <randypr> are you saying whether this is correct depends on downloadHttp's implementation?
17:24:21 <dolio> Sure. It could return a lazy byte string but read it all into memory at once anyway.
17:24:35 <dolio> But I assume it wouldn't. That's pointless.
17:24:45 <randypr> yeah heh
17:25:32 <hpc> or is it pointfree? ;)
17:25:42 <idetuxs> kadoban: I'll check those functions, thanks. :)
17:26:07 <dolio> For code that simple, none of the things people are trying to scare you with will happen.
17:27:47 <randypr> yeah. seems like dragging pipes or conduit into this is a huge overkill
17:36:27 <pharaun> very simple sure, but you'll probably eventually want to learn about pipe/conduit :)
17:36:38 <pharaun> but go with something simple get it to work, understand it then go from there
17:37:08 <randypr> I have been avoiding it for a while. they seem like huge complex beasts
17:37:54 <slack1256> They are
17:37:57 <sccrstud92_> the core is pretty small though
17:38:03 <slack1256> but they are also huge useful beast too
17:38:07 <sccrstud92_> for conduits at least (havent used pipes as much)
17:43:58 <dfeuer_> Ping edwardk
17:47:55 <DNoved1> random-thought: polyfills for certain pragmas might make new compiler implementations easier
17:48:06 <DNoved1> with respect to the discussion on haskell prime on reddit
17:52:35 <ttt_fff> what are haskell rules for inlining "::" (assume I'm willing to use any syntax extension)
17:52:46 <benzrf> is it possible, with some sort of crazy ghc extension witchcraft, to get an arbitrarily heterogeneous comparison operator that gives True iff same type and instance for that type says so
17:52:53 <benzrf> ttt_fff: do you mean ":"?
17:53:03 <benzrf> wait,inlining in what sense
17:53:06 <ttt_fff> no .... "::" is used for typesigs
17:53:10 <ttt_fff> when is ":" useful for typesigs ?
17:55:22 <ttt_fff> well, most of the time "::" is used at the global level, either when defining a new function
17:55:25 <ttt_fff> or at the top of a let/where block
17:55:33 <ttt_fff> I want to use "::" in th emiddle of an expression, i.e. ...
17:55:43 <ttt_fff> foo (map bar lst :: [Benzrf])
17:55:46 <DNoved1> ttt_fff: types are erased during compilation, for GHC atleast, so I'm pretty sure :: has no affect on performance.
17:55:55 <ttt_fff> it's not performance, it's readaibility
17:55:57 <benzrf> ttt_fff: oh
17:55:59 <slaterr> ttt_fff that should work
17:56:04 <benzrf> DNoved1: they mean "syntactically inline
17:56:07 <benzrf> "
17:56:11 <benzrf> DNoved1: not as in inlining the optimization
17:56:18 <DNoved1> Ah, nevermind then
17:56:38 <ttt_fff> my window is 200 chars wide, so sometimes lines get long and I wnat to inline the type sig
17:56:42 <ttt_fff> to help me understand what is going on
17:56:48 <Eiam> Hmm, why would I be seeing Configuring Cabal-1.22.2.0...
17:56:48 <Eiam> setup: /usr/bin/ar: permission denied
17:56:57 <Eiam> I see https://github.com/haskell/cabal/issues/2653 but, ar can be run directly no problem
17:57:13 <Eiam> how can I figure out how cabal is calling `ar` ? like what its doing 
17:59:22 <ttt_fff> strace / dtrace
17:59:24 <ttt_fff> system call interposition
17:59:30 <ttt_fff> can get all args called by compilation process
17:59:34 <ttt_fff> then you visualize it and see what's going on
18:00:34 <Eiam> oh man. i lost my big book of dtrace too
18:00:39 <Eiam> hmm
18:03:49 <Eiam> execsnoop decent start
18:05:23 <slaterr> why does HXT prefer to use IO for parsing? it offers interface that doesn't use IO, but apparently you have to give up control over the configuration of the parser. http://stackoverflow.com/questions/3901492/running-haskell-hxt-outside-of-io
18:25:27 <small-wolf> does anyone have a good example of logging in haskell? 
18:26:02 <small-wolf> for like a web server/framework or something of that general flavor.
18:28:00 <kristof> small-wolf: a writer monad
18:30:44 <sccrstud92_> or Logging monad
18:30:50 <sccrstud92_> thats a monad, right?
18:31:01 <small-wolf> kristof: thanks
18:31:36 <kristof> sccrstud92_: I could imagine a logging monad be a transformer that protects a writer monad under concurrent access from multiple threads
18:33:08 <small-wolf> I'm okay with the logging being nondeterministic
18:38:44 <edwardk> dfeuer_: pong
18:45:21 <alleco> Is there a stack channel?
18:48:30 <LordBrain> stack?
18:48:59 <slaterr> stackage tool I guess
18:49:10 <creichert> Most of their discussion is currently happening over slack iirc
18:51:55 <slaterr> @pl \x y -> headMay <$> f (g x) y
18:51:56 <lambdabot> ((headMay <$>) .) . f . g
19:11:53 <randypr> is there a built in function that strips leading and trailing white space?
19:13:01 <dfeuer_> edwardk, I got tired of waiting and filled a github issue.
19:13:06 <edwardk> ?
19:13:21 <edwardk> dfeuer_: was grabbing dinner, missed it
19:15:01 <dfeuer_> Edwardk, no problem.
19:15:50 <Cale> randypr: For Text, there's strip, which is equivalent to dropAround isSpace. For String = [Char], that's a more awful kind of operation to have to perform, so the best thing you can do is just apply (dropWhile isSpace . reverse) twice.
19:16:22 <edwardk> dfeuer_: is this re the bidirectional machines thing?
19:16:40 <edwardk> i'm still of the mindset that that belongs in another package. it uses none of the machines code.
19:17:15 <edwardk> if there was _any_ overlap with what is already there i could see the case for including it
19:17:23 <edwardk> but as it is? it probably belongs in an add on package
19:17:52 <dfeuer_> No, it wasn't about that, edwardk 
19:18:00 <Cale> Though, it might be a good idea to put a lot of the "comfort" things from Data.Text into Data.String even if they're not always the most efficient things to do -- sometimes you just have a short String value anyway.
19:18:10 <dfeuer_> It was about example code
19:18:31 * hackagebot pandoc 1.15.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.15.0.1 (JohnMacFarlane)
19:18:51 <edwardk> dfeuer_: which thread? i can't find it
19:19:11 <edwardk> dfeuer_: i think your issue got filed in the same circular file that half my github issues go into
19:19:28 <dfeuer_> Edwardk, why do you say no overlap? It uses construct, awaits
19:19:52 <dfeuer_> Edwardk, issue 48
19:21:31 <edwardk> ah
19:21:42 <edwardk> the pipe code is less bad than i remember it being
19:22:33 <dfeuer_> If you could help me figure out how to implement the example fix more idiomatically, I'd appreciate it, edwardk.
19:22:46 <edwardk> i'd have to remember how to use machines first ;)
19:23:14 <dfeuer_> !!!
19:23:23 <broma0> :r
19:32:10 <ttt_fff> OMG, anyone else find their haskell code becoming terser and teser and ahrder to read?
19:32:15 <ttt_fff> it's starting to look like APL these days
19:37:39 <dmj`> ttt_fff: yes
19:37:55 <ttt_fff> dmj`: does it get better, or does it get worse?
19:37:59 <dramforever> ttt_fff: haskell is a better apl
19:38:58 <ttt_fff> not sure about that
19:39:00 <ttt_fff> I think APL is still terser
19:39:16 <dramforever> sure
19:39:45 <dmj`> ttt_fff: probably better
19:42:13 <ttt_fff> how should reader and either be combined?
19:42:43 <dramforever> @unmtl ReaderT r (Either e) a
19:42:43 <lambdabot> r -> (Either e) a
19:42:46 <dmj`> (a -> Either l r)
19:42:55 <dramforever> @unmtl EitherT e (Reader e) a
19:42:55 <lambdabot> EitherT e (Reader e) a
19:43:01 <dramforever> heh?
19:43:08 <dramforever> @unmtl ExceptT e (Reader e) a
19:43:08 <lambdabot> ExceptT e (Reader e) a
19:58:57 <jle`> @unmtl ErrorT e (Reader e) a
19:58:57 <lambdabot> (Reader e) (Either e a)
19:59:06 <jle`> ExceptT is in a fairly new version of mtl/transformers
20:01:33 <eacameron> where does one report a bug with hachage documentation generator? text-1.2.11 is shown as using integer-simple by default, but that's not the case
20:07:16 <Cale> eacameron: I think here: https://github.com/haskell/hackage-server/issues
20:07:39 <Cale> eacameron: https://github.com/haskell/hackage-server/issues/357 might be the bug you're referring to
20:09:39 <Cale> ah, or https://github.com/haskell/hackage-server/issues/306 is closer to it
20:10:37 <Cale> (the problem is that it appears to have taken the assumption that a flag you'd have to give explicitly would be set, rather than unset)
20:13:02 <eacameron> Cale: I just submitted a new one, if it's a dup they'll know better than me: https://github.com/haskell/hackage-server/issues/381
20:21:19 <slaterr> is HXT a go-to haskell html/xml parsing library? what others are recommended?
20:27:52 <sccrstud92_> slaterr: there are some lens-based solutions, if ur feeling naughty
20:28:06 <slaterr> sure why not :)
20:28:29 <sccrstud92_> post on /r/haskell today that used taggy-lens
20:28:45 <sccrstud92_> might just be html
20:28:46 <sccrstud92_> not sure
20:28:53 <Cale> slaterr: HXT is a bit on the heavy end of the spectrum for those. If you're just doing some hacky scraping thing, you might want tagsoup.
20:29:19 <slaterr> just a hacky scraping yes
20:29:22 <slaterr> I'll check it out
20:29:58 <Cale> http://hackage.haskell.org/package/tagsoup-0.13.3/docs/Text-HTML-TagSoup.html
20:31:04 <slaterr> hanks.. but what is up with "Page not found" when I click on Contents?
20:31:19 <Cale> oh, that's weird
20:31:21 <Cale> hah
20:31:28 <slaterr> :P
20:31:29 <Cale> http://hackage.haskell.org/package/tagsoup
20:31:38 <Cale> that's what it's supposed to link to
20:31:51 <Cale> Not sure why the link is broken, some haddock bug, presumably
20:31:52 <slaterr> yeah
20:32:28 <Cale> There's an extra ' at the start of the href
20:32:48 <Cale> <a href="'http://hackage.haskell.org/package/tagsoup">Contents</a>
20:34:31 <sccrstud92_> >@let f x = x^2
20:34:36 <sccrstud92_> >let f x = x^2
20:34:43 <sccrstud92_> @let f x = x^2
20:34:44 <lambdabot>  Defined.
20:34:50 <sccrstud92_> >f 10
20:35:02 <Cale> The space after > is not optional
20:35:04 <Cale> > f 10
20:35:05 <lambdabot>      Ambiguous occurrence ‘f’
20:35:06 <lambdabot>      It could refer to either ‘L.f’, defined at L.hs:150:1
20:35:06 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
20:35:13 <sccrstud92_> alright
20:35:22 <Cale> > let f x = x^2 in f 10
20:35:23 <lambdabot>  100
20:35:34 <sccrstud92_> > cycle $ map (^2) [1,2,3]
20:35:35 <lambdabot>  [1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4...
20:35:47 <sccrstud92_> > map (^2) $ cycle [1,2,3]
20:35:48 <lambdabot>  [1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4,9,1,4...
20:36:01 <sccrstud92_> > traceShow "test" ()
20:36:02 <lambdabot>  Not in scope: ‘traceShow’
20:36:07 <sccrstud92_> > trace "test" ()
20:36:08 <lambdabot>  Not in scope: ‘trace’
20:36:21 <sccrstud92_> those two versions
20:36:31 <sccrstud92_> with map and cycle
20:36:44 <sccrstud92_> do they run (^2) the same number of times?
20:36:56 <Cale> No
20:37:01 <sccrstud92_> k
20:37:05 <sccrstud92_> it makes sense that they dont
20:37:06 <slaterr> > cycle $ map (^2) [a,b,c]
20:37:07 <lambdabot>  [a * a,b * b,c * c,a * a,b * b,c * c,a * a,b * b,c * c,a * a,b * b,c * c,a *...
20:37:23 <Cale> The first is more efficient
20:37:32 <sccrstud92_> figures
20:37:44 <slaterr> > map (^2) $ cycle [a,b,b]
20:37:46 <lambdabot>  [a * a,b * b,b * b,a * a,b * b,b * b,a * a,b * b,b * b,a * a,b * b,b * b,a *...
20:37:52 <slaterr> fail
20:37:55 <sccrstud92_> lol
20:38:43 <Cale> There's no way to see this fact without something like Debug.Trace which breaks the usual rules of Haskell evaluation.
20:38:50 <sccrstud92_> right
20:38:55 <sccrstud92_> i was gonna try it with that
20:38:59 <sccrstud92_> but not in scope
20:39:06 <sccrstud92_> =(
20:39:09 <Cale> Yeah, just use ghci if you want to try that :)
20:39:13 <sccrstud92_> yup
20:39:32 <sccrstud92_> but now everyone learns, not just me =)
20:42:58 <slaterr> is there a safe version of !! somewhere?
20:43:36 * hackagebot text-show 1 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-1 (ryanglscott)
20:43:39 <sccrstud92_> maybe check hoogle for [a] -> Int -> Maybe a
20:43:42 <slaterr> at* in safe package
20:44:03 <slaterr> @hoogle [a] -> Int -> Maybe a
20:44:03 <lambdabot> Prelude (!!) :: [a] -> Int -> a
20:44:03 <lambdabot> Data.List (!!) :: [a] -> Int -> a
20:44:03 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
20:44:06 <dmwit> drop in Prelude
20:44:26 <slaterr> dmwit which one? ideally it would be the same expect with trivially partial functions removed or redefined
20:44:52 <dmwit> :t drop
20:44:53 <lambdabot> Int -> [a] -> [a]
20:45:02 <slaterr> oh heh
20:45:54 <slaterr> I thought you meant a drop-in prelude, as in you can just replace standard prelude with it
20:46:27 * dmwit nods
20:49:55 <Fay> hey guys 
20:50:06 <dmwit> hey
20:50:54 <Fay> im working my way through learnyouahaskell and have a really simple question; '/=' means not equal, correct?
20:51:05 <pikhq> Correct.
20:51:09 <Fay> thankyou
20:52:54 <iaz> I'm kinda new to IRC. I'm looking for some help with some problems I'm having running tests (with Haskell code, of course). Is this an inappropriate place to seek help?
20:53:27 <shachaf> It's an appropriate place to ask for help, but just ask your question.
20:53:46 <shachaf> If it's too big to fit in a line of IRC you can use hpaste.org.
20:54:06 <Fay> or dpaste or lpaste
20:55:31 <iaz> Gotcha. Running tests through `cabal test` or `stack test` (with stackage lts versions) just doesn't halt. I think it may be related to https://github.com/haskell/cabal/issues/2405 but don't know how to be sure.
20:55:41 <sccrstud92_> :t (^.)
20:55:42 <lambdabot> s -> Getting a s a -> a
20:57:28 <slaterr> > do (x:_) <- Just []; return x
20:57:29 <lambdabot>  Nothing
21:00:28 <dmwit> iaz: well... does the workaround suggested on that issue work?
21:01:20 <sccrstud92_> if ive got f :: Monad m => a -> m a
21:01:35 <sccrstud92_> whats the nicest way to run f a certain number of times
21:01:40 <slaterr> replicateM
21:02:01 <dramforever> slaterr: no
21:02:01 <sccrstud92_> sorry i was unclear
21:02:08 <sccrstud92_> composed with itself n times
21:02:18 <dmwit> :t foldr (>=>) return
21:02:19 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
21:02:34 <dmwit> BUT
21:02:45 <dramforever> :t \i m -> foldr (>=>) return (replicate i m)
21:02:46 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
21:02:55 <dramforever> doesn't look nice enough
21:03:26 <dmwit> if you ACTUALLY have something of that type, then just "f" will do
21:04:08 <dramforever> I wonder how efficient is that foldr thing
21:04:18 <dramforever> even though it looks good enough to me
21:05:22 <slaterr> :t splitOn
21:05:23 <lambdabot> Eq a => [a] -> [a] -> [[a]]
21:05:27 <slaterr> is there a splitFirstOn?
21:05:46 <sccrstud92_> what type would it have?
21:05:59 <dramforever> :t splitAt
21:06:00 <lambdabot> Int -> [a] -> ([a], [a])
21:06:01 <iaz> (I don't know how to mark up replys)  When I compile Setup.hs with -threaded it says installed packages (Hunit, etc.) are missing.
21:06:10 <slaterr> [[a]] is fine, or ([a], [a])
21:06:52 <dramforever> :t index
21:06:53 <lambdabot> Ix a => (a, a) -> a -> Int
21:06:58 <dramforever> no...
21:07:17 <dmwit> iaz: hpaste the complete output, please; possibly also the output of ghc-pkg list
21:07:20 <dmwit> ?hpaste
21:07:20 <lambdabot> Haskell pastebin: http://lpaste.net/
21:08:09 <sccrstud92_> @hoogle s -> Getting a s a -> a
21:08:10 <lambdabot> Warning: Unknown type Getting
21:08:10 <lambdabot> No results found
21:08:24 <sccrstud92_> what is english form of (^.)
21:08:28 <dramforever> :t view
21:08:29 <lambdabot> MonadReader s m => Getting a s a -> m a
21:08:42 <dramforever> sccrstud92_: why?
21:09:03 <sccrstud92_> so I can decide whether or not i want to use it =)
21:09:05 <dmwit> slaterr: Perhaps you are looking for break or span?
21:09:13 <dmwit> slaterr: Not entirely sure what you want splitFirstOn to do.
21:09:18 <dramforever> sccrstud92_: do you want to use it?
21:09:29 <sccrstud92_> dramforever: havent decided yet
21:09:56 <sccrstud92_> also if i know the english name
21:10:08 <slaterr> dmwit yes I wanted break.. I thought it existed somewhere, but I was looking in Data.List.Split instead of Data.List
21:10:08 <sccrstud92_> i have an internal way of saying (^.)
21:10:18 <dramforever> sccrstud92_: "caret dot"
21:10:21 <dramforever> :)
21:10:30 <dramforever> that's what I read this as
21:10:44 <dmwit> I pronounce it as a little hiccough internally.
21:11:25 <sccrstud92_> :t %~
21:11:27 <lambdabot> parse error on input ‘%~’
21:11:27 <dramforever> dmwit: I'm a Chinese, and caret dot is (infomally) only two syllables in Chinese
21:11:31 <sccrstud92_> :t (%~)
21:11:32 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:11:33 <dramforever> :t (%~)
21:11:34 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:11:49 <dmwit> "hat dot" is a fine English two-syllable pronunciation
21:12:06 <dramforever> dmwit: oh sure
21:12:33 <dmwit> but hiccoughs are zero syllables ;-)
21:13:40 <sccrstud92_> I have Lens' g p and a function p -> m p, how do I get g m?
21:13:53 <sccrstud92_> m is a monad of course
21:14:33 <sccrstud92_> err
21:14:38 <sccrstud92_> i need g -> m g
21:15:59 <Gal3rielol> is there any sequence requirement when combining different monad transformers?
21:16:19 <dramforever> :t (x :: Lens' g p) :: Monad m => (p -> m p) -> (g -> m g)
21:16:21 <lambdabot>     Couldn't match expected type ‘(p2 -> f p2) -> g2 -> f g2’
21:16:21 <lambdabot>                 with actual type ‘Expr’
21:16:21 <lambdabot>     In the expression:
21:16:31 <dramforever> oh
21:16:32 <nshepperd> sccrstud92_: a Lens' g p is secretly of type forall m. (Functor m) => (p -> m p) -> g -> m g
21:16:44 <dmwit> Not really, though different sequences may give different monads. Also, there are certain "transformers" (ListT comes to mind) that require certain things of the monad they transform.
21:16:46 <dramforever> sccrstud92_: anyway just apply that lens to the function
21:16:52 <dmwit> But the latter are pretty out-of-favor.
21:17:00 <dramforever> :t (?x :: Lens' g p) :: Monad m => (p -> m p) -> (g -> m g)
21:17:01 <lambdabot>     Could not deduce (?x::(p2 -> f p2) -> g2 -> f g2)
21:17:01 <lambdabot>       arising from a use of implicit parameter ‘?x’
21:17:01 <lambdabot>     from the context (Monad m)
21:17:02 <dmwit> So you won't see many of them. (Perhaps ListT is the only one, in fact.)
21:17:05 <dramforever> arrgh
21:17:13 <dramforever> :t (undefined :: Lens' g p) :: Monad m => (p -> m p) -> (g -> m g)
21:17:14 <lambdabot> Monad m => (p -> m p) -> g -> m g
21:17:24 <dramforever> sccrstud92_: ^
21:17:33 <Gal3rielol> dmwit thx!
21:18:04 <sccrstud92_> dramforever: even simpler than I had imagined
21:18:07 <dramforever> sccrstud92_: congrats! you (almost) invented lens yourself
21:18:11 <sccrstud92_> im surprised I havent see this before
21:18:16 <dramforever> sccrstud92_: that can't be simpler
21:18:38 * hackagebot egison 3.5.9 - Programming language with non-linear pattern-matching against non-free data  http://hackage.haskell.org/package/egison-3.5.9 (SatoshiEgi)
21:18:40 <sccrstud92_> im almost with there was a combinator for it
21:18:42 <sccrstud92_> oh wait
21:18:45 <sccrstud92_> ($)
21:18:50 <dramforever> lol
21:18:54 <sccrstud92_> or (#) if i want to be lensy
21:19:08 <dramforever> but warning: You might confuse people with that
21:19:20 <sccrstud92_> yeah
21:19:27 <sccrstud92_> i havent seen lenses used like that before
21:19:30 <lpaste> iaz pasted “setup.hs test issues” at http://lpaste.net/135687
21:19:41 <sccrstud92_> so idk how many people have
21:19:52 <nshepperd> a lens is really like a cleverer 'traverse'
21:20:17 <iaz> I didn't realize they would't be there if I use `stack install ...`. I'm guessing that's the issue. How would I fix this?
21:20:28 <nshepperd> or mapM
21:20:33 <dramforever> nshepperd: the most general form is Over p f s t a b, of course
21:20:42 <nshepperd> in that it can do more dances for you thanks to the functor constraint instead of the Applicative constraint
21:21:01 <dramforever> actually we have Traversal
21:21:58 <dmwit> iaz: cabal install --enable-tests --only-dependencies
21:22:13 <dmwit> iaz: optionally `cabal sandbox init` first
21:22:31 <Axman6> he's using stack afaict
21:22:50 <dmwit> Don't know enough about stack to know how it interacts with manually-built Setup.hs.
21:22:53 <dmwit> Do you?
21:22:59 <Axman6> nope :\
21:23:05 <dmwit> Hence my advice.
21:23:48 <iaz> Yeah, I tried stack after not being able to figure out the issue with cabal either. Whichever works, right?
21:24:18 <slaterr> > join $ Just Nothing
21:24:19 <lambdabot>  Nothing
21:24:21 <nshepperd> hey, are there any plausible data structures for which we can write mapM but not traverse?
21:25:02 <Axman6> isn't mapM one of the functions defined in Data.Traversable and built on traverse?
21:25:11 <Axman6> (or at elast has a default implementation)
21:25:35 <dramforever> :t (mapM, traverse)
21:25:37 <lambdabot> (Monad m, Applicative f, Traversable t, Traversable t1) => ((a -> m b) -> t a -> m (t b), (a1 -> f b1) -> t1 a1 -> f (t1 b1))
21:25:46 <slaterr> I have a parsing library that returns (Foo, Maybe Bar). it is common that snd is Nothing. so how would you express a failure to parse (without caring about error message)? (Maybe (Foo, Maybe Bar))?
21:25:50 <slaterr> parsing function*
21:26:03 <dramforever> slaterr: looks good enough
21:26:04 <sccrstud92_> im pretty sure traverse is mapM for applicatives
21:26:20 <sccrstud92_> so no
21:26:29 <slaterr> it looks a bit weird, but I think it conveys the intention better than (Maybe Foo, Maybe Bar)
21:26:33 <sccrstud92_> you can write traverse = mapM
21:26:36 <nshepperd> mapM is traverse, but mapM demands monad power instead of merely applicative power
21:27:03 <dramforever> slaterr: no it doesn't look weirdd
21:27:05 <dramforever> *weird
21:27:10 <Axman6> well, it is restricted to need Monad, but could probably always be used with Applicative only?
21:27:19 <lamefun> Has Haskell been used in finance (and by whom and for how long)?
21:27:38 <nshepperd> sccrstud92_: you can't, since traverse is more polymorphic than mapM
21:28:02 <nshepperd> you can write mapM = traverse
21:28:14 <Axman6> lamefun: yes, for several years (see Standard Chartered and McGraw Hill Financial)
21:28:54 <Axman6> nshepperd: why not? I think you can now, since Applicative is a superclass of Monad
21:29:38 <nshepperd> :t mapM :: (Applicative m) => (a -> m b) -> [a] -> m [b]
21:29:39 <lambdabot>     Could not deduce (Monad m1) arising from a use of ‘mapM’
21:29:39 <lambdabot>     from the context (Applicative m)
21:29:39 <lambdabot>       bound by the inferred type of
21:30:38 <lamefun> How many years?
21:30:50 <dfeuer_> Axman6, you've got it backwards.
21:31:13 <iaz> Using `cabal test` after installing dependencies still don't halt, and manually compiling Setup still says the packages are missing (any ghc-pkg confirms)
21:31:21 <sccrstud92_> does haskell care about the order you declare types?
21:31:53 <sccrstud92_> i.e can I do data Foo = Foo Bar \n data Bar = Bar Int
21:32:17 <Axman6> dfeuer_: do I? I'm pretty sure that mapM :: Monad m => (a -> m b) -> t a -> m (t b); mapM = traverse works fine
21:32:24 <Axman6> sccrstud92_: no
21:32:24 <dfeuer_> Sccrstud92_, not usually. The only exceptions I know of relate to weird template haskell stuff.
21:32:39 <iaz> How does cabal use Setup.hs, and is there an easier way to tell it to use -threaded?
21:32:48 <nshepperd> Axman6: yes. traverse = mapM doesn't
21:32:56 <sccrstud92_> Axman6: no to which thing? no it doesnt care or no I cant do it?
21:33:05 <dfeuer_> Axman6, yes, that is fine. You said the opposite before.
21:33:31 <iaz> I might just have to take another stab at this tomorrow night. It's getting kind of late for me. :)
21:33:35 <Axman6> Did I?
21:33:38 * hackagebot egison-tutorial 3.5.9 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.5.9 (SatoshiEgi)
21:33:54 <Axman6> oh, I read nshepperd's "can" as "can't". ignore me
21:34:22 <begriffs> Is there a regex library that operates on Text and compiles under GHC 7.10?
21:35:01 <dfeuer_> Sccrstud92_, it doesn't matter unless you're invoking certain sorts of template haskell macros.
21:35:25 <sccrstud92_> dfeuer_: that was the case. i was using makeLenses
21:35:31 <nshepperd> but, I suspect Monad really does not give you anything, since pulling the value of unknown type b out of m b would never serve any purpose in deciding how to continue traversing
21:36:06 <sccrstud92_> begriffs: which ones have you tried?
21:36:57 <nshepperd> assuming the traversal was passed an 'a -> m b' and has just applied it to the first 'a'
21:37:19 <dfeuer_> Nshepperd, thus many would like to generalize that type.
21:37:19 <dfeuer_> Good night, people.
21:38:01 <sccrstud92_> where is the applicative version of forM_?
21:38:13 <sccrstud92_> or what is it called
21:38:26 <begriffs> sccrstud92_: regex-tdfa-text, but it is now unmaintained and requires FlexibleContexts to work in 7.10
21:38:34 <nshepperd> i think it's just called 'for'
21:38:40 <sccrstud92_> :t for
21:38:41 <lambdabot>     Not in scope: ‘for’
21:38:41 <lambdabot>     Perhaps you meant one of these:
21:38:41 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
21:38:47 <sccrstud92_> :t T.for
21:38:48 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
21:38:55 <nshepperd> oh, for_
21:38:57 <sccrstud92_> not quite
21:39:02 <sccrstud92_> :t T.for_
21:39:03 <lambdabot>     Not in scope: ‘T.for_’
21:39:04 <lambdabot>     Perhaps you meant one of these:
21:39:04 <lambdabot>       ‘T.forM’ (imported from Data.Traversable),
21:39:08 <sccrstud92_> =(
21:39:16 <nshepperd> for_ is in foldable
21:39:20 <nshepperd> :t for_
21:39:21 <lambdabot>     Not in scope: ‘for_’
21:39:22 <lambdabot>     Perhaps you meant one of these:
21:39:22 <lambdabot>       ‘F.for_’ (imported from Data.Foldable),
21:39:25 <sccrstud92_> :t F.for_
21:39:26 <nshepperd> bah
21:39:26 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
21:39:49 <sccrstud92_> I guess for traverses but for_ folds?
21:40:32 <nshepperd> maybe a monotraversable sort of type could benefit from having a mapM, since you know the type of the result and can therefore case match on it
21:42:58 <nshepperd> sccrstud92_: they really do the same thing, but for_ throws away the 'results'
21:43:16 <nshepperd> which i suppose is the difference between traversing and folding
21:43:40 <sccrstud92_> nshepperd: which it why i initially thought it strange that it was not in Data.Traversable and doesnt have the Traversable constraint
21:43:59 <sccrstud92_> but, yeah, i guess thats an important difference
21:44:12 <sccrstud92_> i was doing void $ for $ .... before
21:44:34 <sccrstud92_> i bet they could have drastically different memory characteristics
21:44:51 <nshepperd> well, turns out traversing is a lot harder, because you require some way to build a new structure
21:45:51 <nshepperd> (figuratively 'harder')
21:46:36 <slaterr> > over both (+1) (1,2)
21:46:37 <lambdabot>  (2,3)
21:47:08 <slaterr> what's the equivalent for triples, quadruples?
21:47:26 <nshepperd> traversing a tree builds a new tree with all the results as you go along, so yeah you have to keep that in memory
21:47:48 <nshepperd> slaterr: 'each' isn't it?
21:48:02 <slaterr> > over each (+1) (1,2,3)
21:48:07 <lambdabot>  (2,3,4)
21:48:09 <slaterr> > over each (+1) (1,2,3,4)
21:48:11 <lambdabot>  (2,3,4,5)
21:48:40 * hackagebot text-show-instances 1 - Additional instances for text-show  http://hackage.haskell.org/package/text-show-instances-1 (ryanglscott)
21:50:10 <slaterr> nshepperds thanks. interesting that it works for different sized tuples
21:55:07 <sccrstud92_> think its a typeclass instance?
21:55:08 <sccrstud92_> :t each
21:55:09 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
21:55:14 <sccrstud92_> :i Each
21:55:23 <sccrstud92_> @info Each
21:55:23 <lambdabot> Each
21:55:29 <sccrstud92_> thanks lambdabot
21:56:03 <shachaf> /msg is a good way to find out about lambdabot's capabilities.
21:56:27 <slaterr> it was related to my comment
21:56:51 <shachaf> Yes. But :i and @info have never existed.
21:57:21 <Guest94060> Just upgraded from 7.6.4 to 7.8.4 (I know I am behind xd). Now I source doesn't compile anymore because for all my _CONSTANT_ ghc finds holes!
21:57:29 <Guest94060> how can i disable this?
21:57:51 <shachaf> GHC only turns things that would otherwise have been not-in-scope errors into holes.
22:00:18 <Guest94060> ahh, thanks :) Then it must be some other problem :)
22:13:57 <AfC> "state" is a word that people usually use to imply mutability. Sure, we have immutable variables, but e.g. the State monad is about a value that can be updated (cyclically). What's a word for something that can be set once, and only once? [ie is observable as empty until filled, and then stays that way immutably]
22:14:54 <maerwald> AfC: immutable
22:15:15 <Cale> maerwald: That doesn't fulfil the "observable as empty" bit
22:15:39 <kadoban> AfC: Sounds like something that some substructural type system (I think that's the right term?) would have a word for. Not sure what it would be.
22:16:27 <maerwald> Cale: in the sense of State monad, that's simply immutability
22:17:18 <Cale> I think AfC is looking for IVars perhaps
22:17:39 <Cale> (With nonblocking reads)
22:17:48 <AfC> Ooooo
22:18:48 <Cale> https://hackage.haskell.org/package/ivar-simple-0.3/docs/Data-IVar-Simple.html
22:18:58 <AfC> Does seem a touch dated :)
22:19:13 <Cale> Dated how?
22:19:25 <AfC> Oh. Heh. I found https://hackage.haskell.org/package/data-ivar
22:19:28 <AfC> 2008
22:19:28 <maerwald> Cale: and the documentation still says immutable ;)
22:20:01 <Cale> Yeah, the I does stand for immutable, but just saying "immutable" on its own isn't enough to describe this data structure
22:20:21 <maerwald> that's true
22:20:28 <dmj`> fast-logger or wai-logger ?
22:20:42 <dmj`> that is the question
22:21:13 <slaterr> how do I check if -with-rtsopts  is having effect?
22:21:46 <slaterr> is there a way to print the value that my program is using or something
22:23:07 <AfC> slaterr: you could do `numCapabilities` which is set to n by `+RTS -Nn -RTS`
22:23:25 <slaterr> that's it.. thanks
22:23:25 <AfC> (that's a bit of a kludge, but it might do as a test)
22:23:26 <Cale> Yeah, or +RTS -threaded or something
22:23:33 <slaterr> I just need to test it
22:24:40 <AfC> slaterr: it's `import GHC.Conc` for that one, if you didn't know...
22:25:47 <Cale> Oh, derp, I was thinking he just wanted to know if -rtsopts was set at compile time
22:27:09 <slaterr> I do. I am not sure how it works if  I compile a library without it and then link it to a program that uses that compilation flag.. my guess is that the code in the library is not affected sine it is just linked
22:38:41 <AfC> Cale: So ivar-simple doesn't build. You wouldn't happen to know where it's source code lives, would you?
22:40:18 <AfC> (only asking in case you have reason to know. It's not turning up in the usual places)
22:43:14 <AfC> Hm. data-ivar doens't build either. Both libraries depend on `block`, which was deprecated out of Control.Exception a long while ago
22:43:43 * hackagebot executable-hash 0.2.0.1 - Provides the SHA1 hash of the program executable  http://hackage.haskell.org/package/executable-hash-0.2.0.1 (MichaelSloan)
22:43:45 * hackagebot executable-hash 0.2.0.2 - Provides the SHA1 hash of the program executable  http://hackage.haskell.org/package/executable-hash-0.2.0.2 (MichaelSloan)
22:44:23 <jle`> is there a standard type-level list library out there?
22:47:13 <jle`> oh i guess i can just use [] lifted with datakinds
22:49:54 <jle`> how do i do (:)
22:49:59 <jle`> ghc doesn't like it ;_;
22:50:25 <sccrstud92_> ': ?
22:50:50 <sccrstud92_> they usually have an apostrophe in typified data constructors, right?
22:50:52 <AfC> Cale: (and, there's an IVar in monad-par, but _that's_ not where I'm going. Bother)
22:51:20 <jle`> sccrstud92_: thanks :D
22:51:28 <jle`> it works :)
22:53:23 <jle`> is there a way i can specify that all things of an hs :: [*] satisfy a constraint
22:53:36 <jle`> a short way of doing (Eq a, Eq b, Eq c) => [a,b,c]
22:53:51 <jle`> i can't believe i'm asking this question
22:53:59 <jle`> types are weird
22:54:18 <saulzar> jle`, I was wondering the same thing the other day and noticed this .. https://hackage.haskell.org/package/type-list-0.1.0.0/docs/Data-Type-List.html
22:55:06 <jle`> thank you saulzar 
22:55:19 <jle`> what a weird world
22:55:54 <jle`> also i feel like haddock documentation is a bit insufficient to really make documentation for data declarations for things used as kinds
22:56:49 <jle`> neuralNetwork :: Network 10 [6,4,2] 1 Double
22:57:10 <jle`> a type for a neural network with 10 nodes in the input layer, 1 node in the output layer, and three hidden layers of size 6, 4, and 2 :o
22:59:42 <saulzar> Interesting
23:00:11 <saulzar> What's the use in the very precise type there?
23:00:42 <Haskellfant> usually you have to check that all your weight matrices match up
23:01:02 <Haskellfant> so the columns of the first need to be the rows of the second and so on (or the other way around if I'm stupid)
23:01:30 <Haskellfant> by putting those dimensions at the typelevel you can ensure that incorrect dimensions wouldn't even typecheck
23:01:33 <jle`> Haskellfant is correct
23:01:46 <saulzar> Yeah.. you could do a lot of optimizations by having static sizes
23:01:47 <jle`> in guessing my motivation
23:02:38 <Haskellfant> for me personally it's less about optimizations than it is about statically figuring out where my code is broken when I am trying to multiply matrices with incorrect dimensions
23:02:47 <saulzar> True
23:02:48 <jle`> if the last hidden layer has 5 nodes then all of the output layer's nodes have to have 5 (or 6, if for a bias term) weights
23:03:02 <jle`> yeah, it's more of the being able to multiply matrices thing
23:03:17 <jle`> but maybe optimizations come up later idk
23:04:41 <saulzar> Yeah, would be nice to have. I run into this quite often
23:05:18 <saulzar> Using torch (lua)
23:05:26 <jle`> at this point i just feel really weird when i zip/dot things where the types aren't enforcing they're the right sizes, heh
23:05:38 <jle`> i'm sure most normal people don't worry about this
23:05:40 <saulzar> Would be cool to be able to compose a bunch of layers and have it figure out the sizes for a given image size
23:06:32 <saulzar> At the moment I do silly hacks like push an image through some convolutional layers, check the size, then add fully connected layers according the the size of the output from the convolutional layers
23:08:46 <jle`> yeah, sizes in types is a nice little concept for a lot of situations
23:08:49 <saulzar> But it what would make it a killer for a machine learning toolkit is to somehow utilize static sizes to perform better.
23:09:14 <saulzar> Better than the C++/python/lua options available now
23:09:32 <Haskellfant> could you really do that much optimizations by having static sizes?
23:10:06 <saulzar> Hm. Well at the moment they already do, they just break it down and compile all the common cases and switch on them
23:10:41 <saulzar> I'm not really sure. Having it type safe by size is fairly cool though
23:11:07 <saulzar> jle`, I definitely feel icky doing zip/dot when I can't know the size is the same!
23:11:25 <Haskellfant> definitely, I'm just having trouble right now (which could be related to it being early and way too hot) how it helps with optimizations except for getting rid of some size checks
23:13:11 <saulzar> I guess if you knew static sizes for everything you could compile a function to evaluate a whole network at once
23:13:28 <saulzar> Rather than transferring control back to the program at each stage
23:15:53 <saulzar> Just need some optimized batch-evaluated 2D convolution operators in Data.Accelerate :)
23:16:13 <Haskellfant> :)
23:20:19 <ttt_fff> is there any use in compiling haskell to go-lang, or would that just be a dumbass idea?
23:20:52 <pacak> ttt_fff: Why would you want that?
23:21:03 <ttt_fff> I like go.
23:21:05 <ttt_fff> Go is portable.
23:21:25 <Xe> I can see a case for haskell -> Go FFI
23:22:01 <pacak> ttt_fff: So is haskell.
23:33:36 <bergmark> ttt_fff: you like it so much you don't want to write it? ;-)
23:39:08 <unb3k44n7> Evening.
23:40:46 <funfunctor> Hi
23:41:07 <funfunctor> Is there any other folks around that is interested in cluster management software?
23:45:34 <pingu> funfunctor: I think it's safe to assume yes.
23:45:48 <pingu> funfunctor: In relation to haskell though, what did you mean?
23:49:22 <funfunctor> pingu: well I was browsing though corosync source [http://corosync.github.io/corosync/] and thinking about a Haskell implementation
23:49:42 <funfunctor> what it would look like, what else it would provide and so on..
23:51:55 <pingu> funfunctor: so, corosync is horribly complex.
23:52:03 <pingu> And I think anything of the sort is inately horribly complex.
23:52:22 <funfunctor> pingu: well that is some of the motivation
23:52:24 <pingu> Though I wonder how much of the networking/reliability/etc could be offloaded to libraries.
23:53:00 <pingu> I really don't like corosync, so I think it's a great project idea.
23:53:13 <funfunctor> pingu: some things in their are entire files that could collapse down into well thoughtout types
23:53:25 <pingu> funfunctor: certainly.
23:53:35 <pingu> I wonder how much could be subsumed by cloud haskell too, if that were a good fix.
23:53:48 <pingu> *a good fit
23:54:06 <funfunctor> pingu: ok so there is 'some' interest and I would not be ignored for attempting such a project even if its possible I would fail
23:54:33 <pingu> funfunctor: certainly not, enlisting help is a whole different thing though.
23:54:57 <funfunctor> pingu: not new to oss ;) help only comes once its working^tm
23:55:07 <funfunctor> *if you are luckly
23:55:30 <pingu> funfunctor: well then yes, I think it'd be quite an interesting project.
23:55:49 <funfunctor> alright, what to start on first on how to break this down into milestones
23:56:00 <pingu> and as a community we tend to covet real-world, haskell in the wild things.
23:56:17 <pingu> Projects like this really help the community, I think, especially if they work :)
23:56:28 <funfunctor> haha :)
23:57:27 <funfunctor> alright I am motivated enough to get my hands dirty, but in order to sustain effort (the hard part) I need to break this down into milestones so I can profit with cookies
23:57:39 <funfunctor> if you know what I mean ;)
23:59:30 <funfunctor> pingu: name to call the repo?
23:59:41 <funfunctor> haccm perhaps?
23:59:49 <pingu> You don't want to ask me ;)
23:59:58 <pingu> I'll call it "synchroniser_of_things"
