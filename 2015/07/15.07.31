00:00:44 <Silpheed> I've actually heard about the #haskell irc in numerous places
00:01:08 <Silpheed> mainly because people praise the community ofr the fact that almost all of the participants have a strong grasp on the language
00:01:41 <Silpheed> so I'm not surprised if there's professors, professionals, and other people who deal with haskell on a daily basis
00:01:55 <augur> i think we all code in haskell daily here
00:07:39 * hackagebot http2 1.0.3 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.0.3 (KazuYamamoto)
00:07:39 * hackagebot MonadCompose 0.8.3.1 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.3.1 (JamesCandy)
00:13:58 <Gurkenglas> How should I name a branch that is to be merged via pull request and will contain a single commit that adds a single instance? (damn baggage for making such simple changes.)
00:14:14 <Gurkenglas> Or do I use one branch for all my pull requests?
00:14:38 <johnw> does the name even matter?
00:14:58 <johnw> it doesn't become part of the history, just what you write in the commit message
00:15:02 <Gurkenglas> Probably not, but is there a convention? If I use one branch for all requests, it should probably be something with my name.
00:15:18 <johnw> I call it "new_instance" or something like that, it's ephemeral
00:40:52 <frerich> I really wonder how effective these 'You can verify the authenticity of this file by checking its SHA-256 hash," notes are, given that an attacker who managers to modify the served file may just as well alter the web page to show an updated hashsum...
00:41:07 * frerich is looking at the new https://www.haskell.org/platform/
00:42:05 <Hijiri> you could monitor the page for changes in hashsum or something
00:42:35 * hackagebot cpphs 1.19.2 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.19.2 (MalcolmWallace)
00:42:58 <liste> I suppose the hash is more useful if there's mirrors
00:55:19 <ely-se> I'm gonna write my first web app in Haskell today. :v
00:58:13 <liste> ely-se cool (: what tech stack are you gonna use?
01:09:09 <ely-se> PureScript and Happstack.
01:18:12 <ely-se> GitHub had an intern touch Gist or something. It's broken beyond repair now, so I need a new pastebin. And I need something to do this weekend, hence. :P
01:19:51 <mrkkrp> \list
01:20:23 <mrkkrp> Oh, I forgot how to print list of participants…
01:21:36 <zomg> mrkkrp: it's list but with a forward slash
01:21:48 <zomg> (all irc commands are with / )
01:21:59 <mrkkrp> zomg: thanks!
01:22:31 <zomg> I'm not entirely sure what standardized / as the prefix since on the protocol level it's not used =)
01:22:37 * hackagebot hruby 0.3.1.5 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.1.5 (SimonMarechal)
01:23:50 <Gurkenglas> Suggest a name for Data.Tree's levels generalized to (Monad m, ComonadCofree m w) => w a -> [m a].
01:23:52 <liste> is it just me or is there a weird saturation of Simons in the Haskell community?
01:24:45 <unsymbol> liste: i was just thinking that. ;)
01:25:59 <mrkkrp> zomg: although now I know that I was after ‘users’ :-D
01:27:25 <zomg> oh, my client doesn't even know that one :)
01:28:52 <mrkkrp> minad: hello. you wanted to discuss something about megaparsec?
01:38:30 <pharaun> what about nanoparsec?
01:39:08 <Gurkenglas> What's that failing check mean? https://github.com/ekmett/free/pull/101
01:40:02 <liste> Gurkenglas https://travis-ci.org/ekmett/free/jobs/73511669 "Could not find module Data.Tree"
01:42:35 <merijn> Gurkenglas: That is can't build, which is logical, because Data.Tree is in containers and free doesn't have containers as a dependency
01:42:39 <merijn> s/is/it
01:42:40 <Gurkenglas> Oh, that dependency thing I probably have to write somewhere. Damn bureaucracy
01:42:51 <Gurkenglas> Something should be handling that automatically
01:43:30 <Gurkenglas> I have to close the pull request, make a second commit that changes those dependencies, and reopen the pull request now, right?
01:43:44 <merijn> Gurkenglas: Finding a compatible dependency set given explicit constraints is already NP-complete. Making it *infer* constraints would be a disaster
01:43:46 <Gurkenglas> Or delete my fork, reopen it, make a single commit with both changes, and pullrequest that?
01:43:53 <liste> Gurkenglas I don't suppose you need to close anything
01:43:58 <indiagreen> Gurkenglas: you should be able to just push another commit
01:45:02 <mrkkrp> pharaun: parsec is such a flexible thing nowadays you can choose from ‘nano’ to ‘mega’ :-D
01:45:09 <Gurkenglas> merijn, where's the problem? Just set the constraint to those versions that provide the used names?
01:45:33 <merijn> Gurkenglas: Except that there's no guarantee that the names are enough to decide compatibility
01:45:43 <merijn> Gurkenglas: What if a datatype/module changed between versions?
01:45:47 <liste> is it usually fine for PR's to add dependencies for such libraries?
01:46:00 <merijn> liste: Depends on the authors intention
01:47:38 * hackagebot language-thrift 0.3.0.0 - Parser for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.3.0.0 (abhinav)
01:49:36 <liste> which library would be more "fundamental", free or containers?
01:50:12 <Gurkenglas> merijn, isn't it expected that all versions of a package have the same name be equationally equal across versions, barring bugs? I suppose the package would mark which names were bugged in which versions, so the inferer would skip those.
01:50:18 <Gurkenglas> (If the bugged name was used.)
01:51:37 <merijn> Gurkenglas: Eh, no?
01:51:40 <liste> Gurkenglas wouldn't it be only across minor version as per PVP?
01:51:46 <merijn> Then you could never change/update a package...
01:51:54 <merijn> liste: containers for sure
01:51:57 <Gurkenglas> (So people could put a lower bound on a dependency version without an upper bound, without worrying about the name doing something else in future versions?)
01:52:04 <merijn> liste: containers is a boot dependency for GHC
01:52:21 <merijn> Gurkenglas: No, that's not true at all
01:55:20 <Gurkenglas> So I should put an upper bound on the version of containers I'm using? Do I have a gurantee on how many future versions I can count on having the name subForest do the same thing?
01:55:29 <osense> :t or
01:55:30 <lambdabot> Foldable t => t Bool -> Bool
01:56:02 <Gurkenglas> Doesn't this mean that packages keep changing their dependency bounds each time one of their dependencies updates?
01:57:07 <merijn> Gurkenglas: Yes, or they don't put a bound, cross their fingers nothing breaks and then when cabal fails people complain "ugh...cabal hell again..."
01:57:39 * hackagebot open-browser 0.2.0.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.2.0.0 (rightfold)
01:59:47 <liste> Gurkenglas https://wiki.haskell.org/Package_versioning_policy#Version_numbers
02:00:10 <Gurkenglas> Oh, hey, packages could say which version changes break equational equality so the bound inferer could use those.
02:00:23 <liste> so the three first versions specify the API
02:00:24 <Gurkenglas> *break equational equality on which names
02:01:30 <liste> and increasing the third version number just adds new things, doesn't break the API
02:02:00 <liste> so you SHOULD be safe using pkg >= 2.1.5 && < 2.2
02:02:46 <Gurkenglas> So the system that is in place already does that, only that any breaking of any name makes the inferer think that all names of the package are broken.
02:04:03 <liste> IF people follow the policy
02:04:43 <Gurkenglas> If we start questioning that we'll start questioning whether people's monad instances follow the laws, and that way lay madness.
02:09:06 <Gurkenglas> So I guess inserting the line "    containers           < 0.6" into the cabal file should be enough.
02:09:55 <liste> Gurkenglas why < 0.6?
02:10:33 <Gurkenglas> Because the current version is 0.5.something and I can count on containers continuing to contain the name subForest until 0.6
02:11:00 <liste> I'd put a lower bound too, unless subForest is there from the start
02:11:01 <Gurkenglas> And it has contained it since the first version so I need no lower bound
02:11:08 <liste> then it's ok (:
02:11:32 <liste> as long as it's updated once 0.6 comes out
02:12:16 <Gurkenglas> Do unformal justifications go in a commit description?
02:12:57 <liste> yes, if they're valuable
02:14:05 <Gurkenglas> https://github.com/ekmett/free/pull/101 so that check is gonna take 15-60 minutes if the past correlates with the future
02:16:09 <liste> yeah
02:16:13 <liste> god bless travis
02:17:18 <Gurkenglas> (So cabal hell is when A needs B < 2 and C, and C needs B > 3?
02:17:21 <Gurkenglas> *)
02:17:23 <shirt> I'm uploading a new package to hackage. I see that some packages have their markdown "README.md" shown at the bottom of their hackage page. How do I achieve this for my package?
02:17:40 <pharaun> oh i noticed that, that's a new feature right?
02:17:42 <indiagreen> shirt: it'll happen automatically if you include README.md in extra-source-files
02:17:46 <pharaun> i like
02:17:57 <liste> Gurkenglas you can follow it in real time https://travis-ci.org/ekmett/free/jobs/73522282
02:18:15 <shirt> indiagreen: thanks
02:18:19 <liste> click the small circle under the download log button
02:18:38 <indiagreen> shirt: see here for an example: http://hackage.haskell.org/package/shortcut-links-0.4.0.0/shortcut-links.cabal
02:18:49 <liste> seems done though
02:18:56 <indiagreen> shirt: it's nice to include changelog too (in Markdown)
02:19:19 <shirt> indiagreen: cool, it works! no markdown table support though :'(
02:19:55 <liste> tables aren't standard afaik, except with html(?)
02:20:55 <ely-se> Does it have to be markdown? I always use plain text for my readmes.
02:22:29 <merijn> Gurkenglas: Not really, cabal hell had a specific meaning, but since the surge in haskell popularity it's changed meaning into "cabal didn't magically do what I wanted"
02:22:40 * hackagebot microformats2-parser 0.1.1 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-0.1.1 (myfreeweb)
02:27:41 * hackagebot purescript-bundle-fast 0.1.0.1 - A fast alternative to Purescript's `psc-bundle` to be used during development  https://hackage.haskell.org/package/purescript-bundle-fast-0.1.0.1 (BitConnor)
02:31:12 <ttt_fff> does ghc have limits on how  many items a tuple can have? (I'm considering abusing the tuple as a data structure for a typed-forth stack)
02:31:21 <indiagreen> ttt_fff: 62 or 63
02:31:40 <indiagreen> ttt_fff: https://www.reddit.com/r/haskelltil/comments/2u3ees/tuples_are_limited_to_size_62_in_ghc/
02:31:47 <ttt_fff> indiagreen: I ♥ u
02:31:55 <chpatrick> why would you do that D:
02:32:18 <chpatrick> why not het lists at that rate?
02:32:26 <ely-se> that error message reminds me of GCC
02:32:54 <ttt_fff> https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs <-- hmm, why does including more give segmentation fault?
02:33:02 <ely-se> http://coliru.stacked-crooked.com/a/ab408f87044c03e8 :P
02:33:19 <chpatrick> data TypedStack (ts :: [*]) where End :: TypedStack '[]; Cons :: t -> TypedStack ts -> TypedStack (t ': ts)
02:33:33 <chpatrick> needs datakinds
02:33:57 <pharaun> <- once had something that would have ended up with over 200 record entries
02:34:02 <pharaun> so it does happen :p
02:34:14 <ttt_fff> chpatrick: whoa, taht looks like Coq code
02:34:17 <pharaun> (and yes i took a different approach)
02:34:24 <chpatrick> just GADTs mate
02:34:56 <ttt_fff> chpatrick: what does the (ts :: [*]) mean? this is a _List_ where the elements are _TYPES_ 
02:34:58 <ttt_fff> ?
02:35:08 <chpatrick> yes indeed
02:35:30 <chpatrick> ts's kind is a list promoted to the type level consisting of *
02:35:51 <chpatrick> you can actually promote any simple enough ADT to the type level
02:36:03 <chpatrick> I think someone's working on some code that'll let you promote ANYTHING
02:36:34 <SriPree> is it possible to perform IO operations from a type-family definition?
02:36:44 <chpatrick> that doesn't make sense
02:36:46 <chpatrick> type families are about types
02:36:56 <chpatrick> IO operations are values
02:37:08 <chpatrick> do you want a typeclass instead?
02:37:18 <Axman6> you can't perform anything but construction of values in a type family definition
02:37:48 <solarus> chpatrick: you can perform io operations during compile time with th :) (although I'm not recommending it...)
02:38:00 <chpatrick> that's not really in the definition though
02:38:06 <chpatrick> it's code that'll produce the definition
02:38:18 <SriPree> i dont want to use th .. :| but, thanks.. 
02:38:23 <chpatrick> what are you trying to do?
02:38:27 <solarus> SriPree: just an aside
02:39:11 <SriPree> i have a type family constraint.. applied to a function.. 
02:39:23 <SriPree> i want to enhance the constraint.. 
02:40:06 <chpatrick> can you show some code?
02:40:42 <SriPree> 1 sec
02:42:21 <merijn> Axman6: You can't construct values in a type family definition either...
02:42:27 <merijn> Axman6: You can only construct types
02:42:40 <Axman6> oh right, I was thinking about GADTs
02:42:42 * hackagebot react-haskell 2.0.1 - Haskell React bindings  https://hackage.haskell.org/package/react-haskell-2.0.1 (joelb)
02:43:51 <SriPree> http://pastebin.com/8DtxAFFp
02:44:58 <SriPree> chpatrick: here is the code.. http://pastebin.com/8DtxAFFp
02:45:01 <chpatrick> sripree: can't you use a typeclass for this?
02:45:20 <chpatrick> class AllowedSymbol (s :: Symbol)
02:45:27 <chpatrick> instance AllowedSymbol "foo"
02:45:36 <chpatrick> and then in your function AllowedSymbol s => ...
02:46:18 <chpatrick> or does every function have a different list
02:46:18 <SriPree> yes.. i could. 
02:46:38 <chpatrick> I mean it just seems weird to restrict a type but then not use any information about it
02:46:55 <SriPree> correct.. every function could have a different list. 
02:47:13 <chpatrick> but these functions don't use anything related to the type?
02:47:18 <merijn> chpatrick: Really? It's useful if you use DataKinds to tag GADTs
02:47:37 <chpatrick> hmm
02:47:40 <chpatrick> so the idea is
02:47:45 <merijn> chpatrick: That's from my example gist here: https://gist.github.com/merijn/6130082
02:47:59 <chpatrick> Restrict s [ "foo", "bar" ] => Tagged s Int
02:48:17 <merijn> chpatrick: Then 's' can be anything *except* "foo" and "bar", yes
02:48:24 <chpatrick> yeah I ge tit
02:48:29 <chpatrick> but why not make foo polymorphic in this case
02:48:35 <chpatrick> if it doesn't actually care what the type is
02:48:52 <chpatrick> yeah actually I can think of some reasons
02:48:59 <chpatrick> but I think I'd still do it with a typeclass
02:49:02 <SriPree> merijn: thanks for the help yesterday..
02:49:10 <chpatrick> unless there are n different type lists
02:49:25 <merijn> chpatrick: foo in this case is just a silly example to show it works :)
02:49:41 <chpatrick> for example I made a binding library once where you can do different operations depending on the mode
02:49:41 <merijn> chpatrick: Without tagged types it's not a very sensible thing to want, imo
02:49:51 <chpatrick> so the context had a phantom parameter that said what type it was
02:50:05 <chpatrick> MPSSE SPI, MPSSE I2C
02:50:19 <chpatrick> and then if a mode supported reading I did
02:50:36 <chpatrick> class Readable m where read :: MPSSE m -> IO ByteString
02:50:37 <chpatrick> or whatever
02:51:40 <chpatrick> I think it's simpler
02:51:50 <chpatrick> again unless you have a lot of wildly different type sets
02:51:57 <merijn> chpatrick: I use GADTs and type families to do something similar
02:52:27 <chpatrick> I usually prefer typeclasses to type families in general if possible too
02:52:37 <chpatrick> type inference just works better
02:52:42 * hackagebot getopt-generics 0.10 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.10 (SoenkeHahn)
02:53:06 <chpatrick> not to mention error messages
02:54:09 <SriPree> in my case, i cant use GADTs as the symbol list isnt fixed.. 
02:55:05 <chpatrick> SriPree: can you give a bit more context about what you're doing?
02:57:55 <SriPree> chpatrick: its company confidential.. my manager isnt too happy.. sorry.. 
02:59:06 <chpatrick> okay
02:59:22 <chpatrick> well I still suspect that you could group the symbols into typeclasses
03:00:08 <chpatrick> so instead of Restrict s [ "livestock", "mortgage" ] you could do instance Commodity "livestock", instance Loan "mortgage"
03:00:09 <chpatrick> or something
03:00:30 <Axman6> SriPree: can you get away with having things like smart constructors which return Maybe's if a string associated with a value isn't in a specified list?
03:00:40 <chpatrick> and then reposessHouse :: Loan s => Asset s -> IO ()
03:00:42 <chpatrick> or whatever
03:02:30 <SriPree> Axman6: i need a constraint to get the type system not accept functions that use invalid symbols.. 
03:03:18 <SriPree> chpartick: since there are potentially large number of symbols, instance creation for each symbol isnt ideal too. 
03:07:39 <chpatrick> now I'm really curious what you're doing :)
03:10:19 <SriPree> whois SriPree
03:10:43 <dramforever> SriPree: you
03:10:45 <dramforever> =)
03:11:19 <SriPree> :|
03:24:03 <vektor> Anyone here who wants to review my code? http://redd.it/3f9olp/
03:27:51 <cow_2001> https://github.com/cobbpg/elerea-examples/blob/master/src/Chase.lhs
03:27:59 <cow_2001> i don't get line 46
03:28:46 <cow_2001> how can you define clk in a let when you use it inside the case that defines it?
03:28:59 <rbocquet> cow_2001: this is a recursivedo block
03:29:12 <rbocquet> https://wiki.haskell.org/MonadFix
03:29:40 <dramforever> vektor: I have a minor suggestion: maybe you should reorganize your modules so that they fit into the hierachical module tree
03:29:49 <dramforever> and maybe use cabal
03:30:04 <dramforever> but that isn't really comments on the code...
03:30:12 <dramforever> *a comment
03:30:40 <cow_2001> rbocquet: i don't understand it. what is going on?
03:30:55 <cow_2001> who is calling who? who defines who?
03:30:56 <vektor> " Anyone here who wants to review my code? http://redd.it/3f9olp/ " - me a few minutes ago
03:31:06 <vektor> (nevermind)
03:31:16 <dramforever> =)
03:31:55 <vektor> dramforever: Alright, let's see. You mean organizing modules to align with the structure on haskell, so something like GP.Core ?
03:32:03 <dramforever> yeah
03:32:29 <dramforever> and cabal could probably eliminate build.sh and cleanup.sh
03:32:35 <dramforever> probably
03:33:07 <vektor> dramforever: I can see that. Though, well... I haven't had much experience with cabal yet, and it has a worse reputation than cmake, so I'm hesitant
03:33:28 <dramforever> cabal doesn't deal with packages well
03:33:37 <dramforever> but for building, I guess it's fine
03:33:53 <dramforever> it's up to you
03:37:44 * hackagebot OrchestrateDB 1.0.0.2 - Unofficial Haskell Client Library for the Orchestrate.io API  https://hackage.haskell.org/package/OrchestrateDB-1.0.0.2 (dwd31415)
03:42:16 <vektor> apparently, my connection just went down. Did I miss anything?
03:42:35 <dramforever> 1. no
03:42:39 <dramforever> 2. you can check the log
03:42:43 <dramforever> see channel topic
03:44:42 <vektor> Alright, thanks. Got any thoughts on the general concept of what I'm trying to do?
04:00:12 <merijn> vektor: Why do you "need to look at the history and ancestry to determine local maxima"?
04:01:27 <merijn> I've never seen evolutionary computing approaches that account for historical candidates
04:02:06 <merijn> vektor: Minor note, why have 6 lets here 
04:02:11 <merijn> https://github.com/vektordev/GP/blob/master/src/GRPCore.hs#L149-L159
04:02:20 <merijn> Instead of a single let? Or better yet, where
04:03:06 <merijn> also, "compare `on` snd" is the same as "comparing snd"
04:03:08 <merijn> :t comparing
04:03:09 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
04:03:38 <vektor> Well, this one has a fitness component that is not immediately measurable: Since the code gen is subject to genetic modification too, and it's very hard to tell how good that implementation is, I deal with that by generating offspring and see if they improve. If a Genome forms a improved offspring, it should be extremely likely to not be part of a local maximum.
04:03:50 <merijn> "sequence (map ...)" is just mapM
04:03:52 <merijn> :t sequence
04:03:53 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:03:57 <merijn> :t sequence . map
04:03:58 <lambdabot> Traversable ((->) [a1]) => (a1 -> a) -> [[a1] -> a]
04:04:04 <merijn> :t mapM
04:04:05 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
04:04:10 <merijn> eh
04:04:16 <merijn> :t \f -> sequence . map f
04:04:17 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
04:04:41 <vektor> I've run into local maxima before where you only really realize in the 2nd generation and onwards that you're not making progress. Thus, if you look at the offspring you generated, you can see that you're not getting anywhere from the genome you're looking at.
04:05:18 <merijn> "sum $ snd $ unzip parentFit" -> "sum $ map snd parentFit"?
04:06:55 <vektor> compare on - fixed
04:08:07 <sbrg> Anyone familiar with conduit that knows if there is a way to tranform something like stm's TQueue into a producer(or sink for that matter)?
04:08:33 <sbrg> hmm I guess it wouldn't be very difficult
04:09:26 <vektor> merijn: That comment about snd unzip = map snd sounds about right, yeah.
04:09:37 <vektor> Shouldn't really matter I guess, but I like your version more
04:09:56 <merijn> sbrg: Just repeatedly "atomically $ readTQueue queue"? :)
04:10:20 <sbrg> merijn: yeah, exactly. Didn't quite think things through before asking that question
04:10:26 <merijn> vektor: I'm just pointing out my, highly subjective, opinion on readability :)
04:10:30 <sbrg> (and I already had that, I just forgot, heh)
04:10:31 <dramforever> vektor: I'm thinking about something like data Gen = Gen LivingSet (Seed -> Gen)
04:11:37 <vektor> dramforever: To represent a generation?
04:11:40 <dramforever> yes
04:11:47 <dramforever> and how to get the next generation
04:11:52 <vektor> merijn: And I have to say I tend to agree.
04:13:23 <dramforever> and there are quite a few functions that could help , although I don't know if that's too advanced for you https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html
04:13:29 <dramforever> if you define your Gen as a cofree comonad, of course
04:14:35 <vektor> That indeed sounds mostly unfamiliar to me. I have heard of Cofree and Comonads, but I've no idea what they're about.
04:14:48 <dramforever> it's just a structure
04:15:31 <dramforever> say...what collection data structure are you currently using for the current generation?
04:15:55 <dramforever> do you understand my question?
04:17:03 <vektor> currently, I'm using just a plain old data structure.
04:17:19 <vektor> https://github.com/vektordev/GP/blob/master/src/GRPCore.hs#L50-L56
04:17:32 <vektor> All the active genomes in a list, all the historical genomes in another.
04:17:49 <dramforever> oh so you call a living genome an "agent"
04:17:57 <vektor> Which is problematic, because finding the offspring of a Genome is a O(n) operation.
04:18:27 <dramforever> let's put that away for a bit
04:18:34 <vektor> I'd rather it be a tree structure that actually represents father-child relations, while at the same time allowing by-index access.
04:18:35 * dramforever is focusing on Cofree
04:19:00 <vektor> I'm all ears ... eyes actually.
04:19:32 <dramforever> vektor: so for each agent, you can produce a list of children?
04:19:43 <dramforever> or just one
04:20:18 <vektor> I can produce as many children of each agent as I like, yes.
04:20:29 <vektor> That is, if the agent did compile.
04:20:58 <dramforever> okay so it's like Agent -> Seed -> Agent
04:21:02 <dramforever> so let's do this:
04:21:04 <vektor> indeed.
04:21:42 <vektor> After weeding out the rubbish and picking the best agents, I pick some agents that are supposed to reproduce, give them seeds and then merge the old and new generation, filter again, ...
04:22:07 <dramforever> so let's have newtype Pool k = Pool (Seed -> k)
04:22:34 <dramforever> well let's rename that to PoolF
04:23:03 <dramforever> so Cofree PoolF a = a :< (Seed -> Cofree PoolF a)
04:24:22 <dramforever> and we can build up a structure of that type with coiter, which has type Functor f => (a -> f a) -> a -> Cofree f a
04:24:56 <dramforever> which specializes to (a -> PoolF a) -> a -> Cofree f a
04:24:56 <dramforever> i.e. all generations from the first
04:25:20 <mniip> looks like a coalgebra anamorphism
04:25:32 <dramforever> yep
04:28:05 <vektor> This seems to go over my head..
04:28:32 <ely-se> how should I decide between giving a function the type "T -> IO U" vs "MonadIO m => T -> m U"?
04:29:40 <ttt_fff> how can haskell be more lovely?
04:30:20 <mniip> ely-se, go for the first
04:30:26 <ely-se> ttt_fff: by adding (`ily`) and (♥) operators
04:30:29 <ely-se> mniip: ok!
04:30:32 <mniip> you can always use liftIO
04:30:43 <Denommus> ttt_fff: if it had ML modules + implicits modules instead of typeclasses I would like it more
04:30:50 <ttt_fff> i like typeclasses
04:31:19 <Denommus> but ML modules are more powerful and subtyping isn't a problem
04:31:27 <ely-se> I like doughnuts, so we should add those to Haskell.
04:31:33 <ttt_fff> let ♥ = (const "more haskell") in ♥ "ily"
04:31:39 <ttt_fff> > let ♥ = (const "more haskell") in ♥ "ily"
04:31:40 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
04:31:54 <ttt_fff> let ♥ = 3 in ♥
04:32:00 <ttt_fff> > let ♥ = 3 in ♥
04:32:01 <sgronblo> I'm trying to use ghc-mod but am getting some cabal errors. "cabal configure failed".
04:32:02 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
04:32:09 <merijn> > let (♥) = (+) in 2 ♥ 3
04:32:10 <lambdabot>  5
04:32:12 <ttt_fff> > let x = 3 in x
04:32:13 <lambdabot>  3
04:32:17 <ely-se> > let a ♥ b = "more haskell" in "i" ♥ "you"
04:32:18 <lambdabot>  "more haskell"
04:32:21 <merijn> > generalCategory '♥'
04:32:23 <lambdabot>  OtherSymbol
04:32:28 <ttt_fff> ely-se++
04:32:34 <merijn> It's a symbol so it's an operator
04:32:36 <Denommus> I don't expect it to ever have ML modules, though
04:32:47 * hackagebot sync-mht 0.3.3.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.3.0 (emink)
04:32:48 <merijn> Denommus: ezyang is working on it
04:32:49 <ttt_fff> what's so great about ML modules?
04:33:01 <ttt_fff> I like haskell modules (I undderstand them0 and typeclassses (I understand them)
04:33:11 <merijn> Denommus: See http://blog.ezyang.com/category/haskell/backpack/
04:33:27 <vektor> dramforever: That seems to go over my head. I'm not so sure I can follow how that gives me the data structure I need.
04:33:30 <merijn> ttt_fff: Read those blogposts for why you might care
04:33:38 <demize> @let a ❤ b = a ++ " loves " ++ b
04:33:39 <dramforever> vektor: never mind...
04:33:40 <lambdabot>  Defined.
04:33:40 <dramforever> =(
04:33:42 <demize> :D
04:33:50 <dramforever> forget about it...
04:33:56 <demize> > "lambdabot" ❤ "everyone"
04:33:58 <lambdabot>  "lambdabot loves everyone"
04:34:32 <ely-se> I like "let a ❤ b = (.)(.)"
04:34:44 <Denommus> merijn: I thought backpack wasn't based on ML modules, but it was something else
04:35:09 <Denommus> ttt_fff: ML modules subsume typeclasses
04:35:28 <ttt_fff> yeah, I thought "backpack" was menat to solve "cabal hell"
04:35:40 <Denommus> ttt_fff: because you can have abstract types in them, and you can produce modules out of other modules
04:36:04 <Denommus> ttt_fff: quick example on them subsuming typeclasses: https://gist.github.com/Denommus/dc6a027ec1760abfc8e6
04:37:17 <ttt_fff> hmm, I don't understand ocaml
04:37:25 <ttt_fff> maybe I shouuld learn the language
04:37:46 <vektor> dramforever: Maybe I can do the tree structure based on unique ID (just a tree of the IDs) and then add a lookup of ID -> Agent in a different data structure?
04:37:47 * hackagebot som 8.1.1 - Self-Organising Maps.  https://hackage.haskell.org/package/som-8.1.1 (AmyDeBuitleir)
04:37:56 <Denommus> ttt_fff: 'a is a type variable. Type parameters go the other way around (so instead of typing Foo a you type 'a foo)
04:38:02 <dramforever> vektor: I'm not sure...
04:38:12 <dramforever> do you store all agents ever seen in the structure?
04:38:15 <vektor> reeks of inconsistant state, right?
04:38:19 <vektor> Currently, yes.
04:38:23 <Denommus> ttt_fff: sig defines a module signature, struct a module
04:38:32 <dramforever> vektor: why don't you just store the new ones?
04:38:36 <vektor> Maybe at some point I wanna remove the ones that have no close living relatives.
04:39:10 <merijn> Denommus: Depends on how you define "based on", it's certainly strongly inspired by ML modules
04:39:10 <dramforever> I'm asking for a reason, so that I could help you with it
04:39:18 <Denommus> ttt_fff: pay attention how DefaultBind and DefaultJoin take another module as a parameter
04:39:23 <vektor> Well, because as I pointed out to merijn, I need to look at historical candidates too
04:39:33 <Denommus> ttt_fff: like they are functions of modules
04:39:42 <dramforever> vektor: hmm okay
04:39:50 <Denommus> ttt_fff: so I produce the ListMonad module by passing a module to DefaultBind :-)
04:40:00 <dramforever> oh yeah they could be better
04:40:01 <vektor> To recognize local maxima when I see them.
04:40:03 <dramforever> =)
04:41:10 <dramforever> wait that's still unclear to me
04:41:42 <dramforever> can't you just look at the scores of the two generations, and see if there's an improvement?
04:42:23 <Denommus> ttt_fff: also, pay attention on how I don't specify what the type "t" is in the signature. That makes it an abstract type. A module that implements that signature may replace it for any type that can implement the provided functions :-)
04:43:06 <vektor> That is a vague measurement. I can not measure the fitness of the code generator (which is subject to genetic change) directly, so I look at a genome's offspring to determine whether it's code gen is any good.
04:43:30 <dramforever> hmm...interesting
04:43:44 <vektor> It's quite a big step removed from genetic programming.
04:43:47 <dramforever> so you could check that during the generation don't you
04:44:27 <dramforever> I mean, like 1. make offsprings 2. check if they are better
04:44:56 <dramforever> or maybe you could just throw the worse ones
04:45:05 <vektor> Keep in mind that it's hard enough to achieve any improvement in the source code, I don't want to enforce that a detectable improvement in act needs to be made, as that would require the genomes I want to breed to improve both act and evolve, which is barely even possible.
04:45:15 <dramforever> okay
04:45:22 <rudi_s> Hi. I'm looking for a parser for log files generated by syslog. I didn't find any working packages. Any pointers? Thanks.
04:45:24 <dramforever> that's fine
04:46:00 <dramforever> vektor: can we compare two agents to see if one is better than the other?
04:46:00 <vektor> Thus, I just generate offspring of the previous generations best candidates and merge them with the previous generation.
04:47:23 <vektor> dramforever: The answer is "kinda" - we can compare fitness values, but that's not the whole truth. if we add context to them, such as their position in the ancestral tree, we can heuristically tell which one's better.
04:48:21 <vektor> So by looking at who has made the bigger step in fitness from their parent, by looking at their offspring or even their siblings, we can tell which one is more likely to have a better code generator.
04:50:42 <dramforever> okay I'm back
04:51:30 <dramforever> so currently you are storing every agent's parent and offsprings in the agent itself?
04:51:45 <vektor> Only the parent.
04:52:01 <dramforever> fine
04:52:07 <vektor> https://github.com/vektordev/GP/blob/master/src/GRPStats.hs#L27-L41
04:53:09 <dramforever> so sorry what's the problem again?
04:54:22 <dramforever> oh wait now I know it
04:54:42 <dramforever> you are worried about storing the ancestry of an agent
04:55:26 <vektor> Among others. I'd rather have a clean tree structure. At the same time, I also need to perform lookups by ID
04:55:41 <dramforever> well why?
04:56:28 <dramforever> so hmm...what's the problem of the current tree structure?
04:56:35 <dramforever> I mean, the ancestry-based
04:56:36 <vektor> There's no tree structure
04:56:58 <dramforever> oh I mean what's the problem with the ancestry
04:57:07 <vektor> Well, I store parents in the Agent, but I have to look up those IDs in a messy list.
04:57:39 <dramforever> I wonder if it's feasible to store all the agents and their code in memory
04:57:46 <dramforever> that way you also have a pure interface
04:57:47 <vektor> Not really.
04:58:16 <dramforever> vektor: okay so why is the list messy?
04:58:18 <vektor> Well, a pure interface is not a concern in Core. In the Genome, yes, but that's feasible.
04:58:50 <dramforever> wait by feasible I mean if the memory is sufficient
04:58:58 <vektor> well, it's usually sorted by fitness value, not by genome ID or by parent ID, so finding your children is hard.
04:59:55 <dramforever> actually it's possible to have a data structure to have both O(log N) lookup by ID and O(log N) extract-min
05:00:15 <vektor> extract-min?
05:00:32 <dramforever> get ID and value of minimum
05:00:46 <dramforever> well I mean get the ID of the minimum value
05:00:52 <dramforever> screw it..
05:00:57 <vektor> that sounds like a binary tree
05:01:00 <dramforever> yes
05:01:07 <dramforever> isn't hard at all
05:01:28 <vektor> But that binary tree won't let me iterate over ancestry relations.
05:01:29 <dramforever> vektor: so why is the list "messy"?
05:02:30 <vektor> (I could just lookup the parent by ID, but that won't work on children, unless I keep their IDs where I store their parent...
05:02:33 <Cale> http://hackage.haskell.org/package/PSQueue
05:03:00 <dramforever> Cale: yes exactly what I mean
05:03:45 <vektor> Well, the list doesn't support lookup by ID nor by ancestral relations very well. so findChildren:: Genome -> Pool -> [Genome] and findGenome :: Pool -> GenomeID -> Genome are hard.
05:03:45 <dramforever> I sorta invented that again myself when developing the splay package, but I'm really sure that already exists =P
05:04:30 <vektor> Cale: Looking into it
05:05:12 <vektor> How does that support ancestry relations? i.e. lookup by "isParentOf" or "isChildOf"?
05:05:39 <dramforever> vektor: no that's the O(log N) find by id + O(log N) find minimum value
05:05:50 <kritzcreek> are there more nice katas for haskell in the style of gilded-rose? https://github.com/emilybache/GildedRose-Refactoring-Kata/tree/master/haskell
05:06:07 <vektor> I see.
05:06:38 <vektor> At this point, knowing I could trivially implement it if I was using c++ and pointers, I'm not sure whether my design sucks or whether the language is keeping me back. :D
05:06:46 <dramforever> vektor: oh?
05:06:55 <vektor> I'm suspecting it's the design :D
05:07:00 <dramforever> how? can you describe it?
05:07:03 <catgocat> @pl splitHalf l = splitAt ((length l + 1) `div` 2) l
05:07:03 <lambdabot> splitHalf = splitAt =<< (`div` 2) . (1 +) . length
05:08:24 <vektor> Well, in c++ you would just have the Nodes of the ancestry tree dumped into a binary tree. pointer-iteration over the ancestry tree, binary tree takes care of index lookups.
05:08:55 <dramforever> can you elaborate on "pointer-iteration"?
05:09:40 <catgocat> can anyone explain how this works? > splitAt =<< (`div` 2) . (1 +) . length
05:10:09 <vektor> class genome{genome* parent; std::vector<genome*> children; int id; moredata;}
05:10:27 <dramforever> :t (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)
05:10:28 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
05:10:35 <catgocat> I know what >>= is
05:10:41 <catgocat> but I don't understand that piece of code
05:10:42 <vektor> binarytree<int, genome*> pool
05:10:56 <mauke> catgocat: (=<<) c g = \x -> c (g x) x
05:10:59 <Denommus> catgocat: the length of the list + 1, divided by 2
05:11:04 <vektor> so you can look up by ID and iterate over the binary tree as you like.
05:11:13 <catgocat> yeah I know but what is fed to splitAt?
05:11:26 <vektor> And if you wanna iterate over ancestral relations, you got the pointers to do so.
05:11:34 <liste> catgocat it's the Monad instance of (->)
05:11:56 <liste> it takes a certain brain twist
05:12:02 <Denommus> catgocat: a function
05:12:07 <catgocat> from what I'm seeing, a number is being binded to splitAt, how is that possible
05:12:11 <Denommus> catgocat: functions are monads
05:12:17 <mauke> ((->) e) is a monad
05:12:20 <mauke> :t (=<<)
05:12:22 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:12:27 <liste> @src Monad (->)
05:12:27 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:12:29 <mauke> let m = ((->) e) and substitute
05:12:35 <Denommus> catgocat: no, (`div` 2) . (1+) . length is a function, not a number
05:12:54 <Denommus> :t (`div` 2) . (1+) . length
05:12:55 <mauke> (=<<) :: (a -> ((->) e) b) -> ((->) e) a -> ((->) e) b
05:12:55 <lambdabot> Foldable t => t a -> Int
05:12:58 <catgocat> but the main function takes a list as a paremeter
05:13:00 * dramforever needs a threaded chatting platform </sarcasm>
05:13:06 <mauke> normalize
05:13:19 <mauke> (=<<) :: (a -> e -> b) -> (e -> a) -> e -> b
05:13:27 <Denommus> catgocat: yes, that's because the function is fed to splitAt, producing a function of list
05:13:37 <catgocat> my mind is confused
05:13:46 <Denommus> catgocat: functions are monads!
05:13:48 <dramforever> vektor: yeah that's a problem
05:13:50 <mauke> now let a = [a'], e = Int, b = ([a'], [a'])
05:13:54 <catgocat> yeah I know
05:14:02 <dramforever> because you cannot easily keep hold of parents
05:14:03 <catgocat> isn't it the same as (.)
05:14:05 <mauke> hmm, no
05:14:15 <Denommus> catgocat: pay attention to how the first parameter of the function is a Foldable t => t a
05:14:15 <mauke> a = Int, e = [a'], b = ([a'], [a'])
05:14:28 <Denommus> catgocat: no, (.) is fmap
05:14:46 <dramforever> because if you change one node, all the rest have to be updated
05:14:48 <catgocat> :/
05:14:51 <dramforever> vektor: ^
05:14:55 <mauke> (=<<) :: (Int -> [a'] -> ([a'], [a'])) -> ([a'] -> Int) -> [a'] -> ([a'], [a'])
05:15:05 <catgocat> what does it mean a function is a monad
05:15:22 <dramforever> catgocat: what about this:
05:15:23 <mauke> catgocat: functions aren't monads. ((->) e) is an instance of Monad
05:15:33 <dramforever> f (g x) x = (f . g) x x
05:15:36 <ely-se> catgocat: When something is a monad then it obeys the laws of monads.
05:15:43 <catgocat> I "know" what is a monad
05:15:45 <dramforever> join :: (a -> a -> b) -> (a -> b)
05:15:47 <mauke> also, the type of functions a -> b can also be written (->) a b, which is the same as ((->) a) b
05:15:48 <catgocat> don't know how a function is an instance of monad
05:15:53 <Denommus> mauke: ... that makes every function a monad
05:15:53 <catgocat> or at least didn't understand from the LYAH book
05:16:00 <mauke> Denommus: wrong
05:16:03 <Denommus> mauke: just like [] being a monad makes every list a monad
05:16:09 <mauke> yeah, wrong
05:16:13 <vektor> dramforever: Well, yeah, you'll have to keep that structure up to date every so often, but in c++ I'd have a idea of where to start. (I'd probably hunt pointer-related bugs for weeks)
05:16:14 <Denommus> mauke: ok, tell me ONE function that isn't a monad
05:16:22 <mauke> Denommus: id
05:16:29 <Denommus> :t (id>>=)
05:16:30 <lambdabot> (a -> a -> b) -> a -> b
05:16:33 <dramforever> vektor: and in haskell you are stuck immediately =)
05:16:33 <Denommus> ^
05:16:36 <mauke> Denommus: ?
05:16:45 <dramforever> =(
05:17:17 <Denommus> > id >>= return $ 1
05:17:18 <lambdabot>  1
05:17:25 <Denommus> mauke: ^
05:17:29 <mauke> Denommus: irrelevant
05:17:39 <Denommus> mauke: ... how is that NOT relevant?
05:17:41 <mauke> a monad is a type constructor
05:17:49 <mauke> functions are values, not types
05:17:52 <mauke> let alone type constructors
05:17:54 <dramforever> vektor: so why are you going to lookup by id?
05:18:11 <catgocat> can anyone explain me
05:18:15 <catgocat> How functions are instance of monads
05:18:23 <Denommus> catgocat: why don't you see the source?
05:18:26 <mauke> catgocat: what's unclear?
05:18:29 <catgocat> because I am a newbie?
05:18:36 <mauke> catgocat: do you want to see the definition of return and >>=?
05:18:43 <Denommus> catgocat: but the instance is very easy to read
05:18:55 <catgocat> where is the srouce
05:18:58 <catgocat> source
05:19:36 <catgocat> instance Monad ((->) r) where     return = const     f >>= k = \ r -> k (f r) r
05:19:39 <catgocat> is it this?
05:19:43 <Denommus> catgocat: for a function, f >>= k = \ r -> k (f r) r
05:19:51 <Denommus> catgocat: yup
05:19:52 <liste> catgocat exactly
05:19:58 <vektor> dramforever: TBH, I'm not quite sure right now. Might be that it's a requirement in some weird special case, or maybe that requirement was cast into my mind due to me messing around with a mix of a list and ancestry tree...
05:20:23 <dramforever> yeah that happens often =P
05:20:34 <vektor> dramforever: guess that means I'll see if I can get the whole thing to work by just using an ancestry tree?
05:20:39 <dramforever> yep
05:20:47 <catgocat> oh ok
05:20:49 <catgocat> I understand now
05:21:06 <Denommus> mauke: you got a point that made me confused. If ((->) a) is a monad, why can't I join a "unary" function?
05:21:11 <catgocat> it applies the argument to both the length function and the splitAt
05:21:19 <liste> yep
05:21:25 <dramforever> that's a bit I like about haskell: those restrictions force you to get a better design
05:21:32 <dramforever> or you go really deep
05:21:43 <dramforever> I mean, your code goes really bad, but you know it
05:21:54 <Denommus> mauke: ah, because I'm dumb
05:21:55 <mauke> Denommus: join takes m (m a), which corresponds to ((->) e) ((->) e a), or e -> (e -> a)
05:22:03 <Denommus> mauke: yeah, noticed it now
05:22:05 <dramforever> so that's also why sometimes writing in haskell is painful
05:23:43 <vektor> The good kind of painful, in my opinion.
05:24:03 <vektor> If you know pointers can do something you can't, you know you got a hell of a problem or a terrible design.
05:24:51 <dramforever> =)
05:25:33 <ely-se> Memory is just a map from addresses to values, so you can simulate pointers by unique IDs and memory by a map of IDs from values.
05:25:48 <vektor> Usually that's ugly
05:25:58 <vektor> Unless your problem is so bad it calls for that solution
05:26:03 <ely-se> :p
05:26:06 <Intolerable> nice and fast
05:26:27 <vektor> I mean, I could've stored parent-child relations as IDs in the Genome and looked them up by ID in a ID-based binary tree, but that isn't quite pretty.
05:26:58 <vektor> Though quite frankly, that structure sounds like a nightmare in the first place, so that might just be a adequate solution. :D
05:27:22 <ely-se> Implement it in C++ and use the FFI :D
05:28:06 <vektor> for sure, I'll do that. It's not like I moved to haskell for a reason :D
05:29:05 <kuribas> Does anyone use implicit parameters?  Should I use it as a replacement for a reader monad?
05:29:14 <srhb> kuribas: Probably not.
05:29:19 <vektor> wait.... haskell-trees that are iterable in both up and down directions.... how do I...?
05:29:22 <Intolerable> use reader
05:29:48 <srhb> vektor: Start by considering a zipper perhaps :)
05:30:10 <ely-se> trees are graphs, so use a graph library
05:30:10 <kuribas> srhb: what if I have a value that I need to thread, for example a tolerance parameter for numeric algorithms?
05:30:24 <srhb> kuribas: I'd still use reader, personally. It's clearer.
05:30:44 <vektor> That was my thought too. There was a section on lyah about it :D
05:30:51 <c_wraith> If you're storing a map of IDs to values and nodes have a list of child IDs, you should really use fgl
05:30:59 <srhb> vektor: Something like data Zip a = Zip [a] a [a] -- notice how you can walk left and right
05:31:19 <srhb> vektor: Now you can try and make a treelike zipper :)
05:31:27 <vektor> Yeah :D
05:38:12 <vektor> hackage's got me covered
05:38:14 <vektor> https://hackage.haskell.org/package/rosezipper-0.1/docs/Data-Tree-Zipper.html
05:38:46 <dramforever> vektor: actually I'm aware of it
05:38:54 <dramforever> but you don't get lookup by id
05:39:22 <dramforever> oh wait do you?
05:39:50 <vektor> well, as we discussed, might just be that I can get by without - or use the location-style equivalent if I really need to.
05:40:01 <dramforever> =)
05:40:23 <dramforever> vektor: that location thing allows modification of the whole tree
05:40:31 <dramforever> by that I mean you can efficiently modify the things around a location
05:40:36 <dramforever> and you can also move around
05:40:42 <dramforever> as well as getting the tree back
05:40:57 <srhb> vektor: Are we doing bioinformatics?
05:41:09 <dramforever> srhb: genetic programming
05:41:13 <srhb> Ah.
05:41:43 <vektor> with a twist
05:41:46 <vektor> https://www.reddit.com/r/haskell/comments/3f9olp/genetic_programming_project_feedback_wanted/?ref=share&ref_source=link
05:41:50 <srhb> There's always a twist. :-)
05:41:52 <ely-se> TIL about genetic programming
05:42:21 <vektor> I'm the crazy nut who thinks it's a good idea to have the GP's code gen be part of the genome.
05:42:59 <dramforever> well is that bioinformatics?
05:43:05 <merijn> No
05:43:06 <srhb> vektor: Not really.
05:43:08 <srhb> er
05:43:11 <srhb> dramforever: ^
05:43:20 <merijn> dramforever: It's a subcategory of evolutionary computing
05:43:59 <vektor> bioinformatics would be to deal with proper biology. Which I'm not. I'm just using bio terminology.
05:43:59 <merijn> dramforever: Which in turn is just a generalised version of simulated annealing for multi-dimensional problem spaces
05:44:36 <dramforever> =)
05:44:42 <merijn> I rank evolutionary computing up there with compiler construction as most useful/generic tool I learned in a CS class
05:45:05 <vektor> Hehe :)
05:45:18 <dramforever> =)
05:46:06 <srhb> There's probably an overlap. Bioinformatics can be used to describe some aspects of GP.
05:46:13 <dramforever> actually there's a data structure that is very useful in many occasions
05:46:13 <dramforever> binary tree
05:46:13 <dramforever> =P
05:46:16 <vektor> Most generic thing I've learned would be hardware design. One class that was about a third of my workload that semester covered everything hardware. how transistors work, how to represent data in binary, boolean algebra, chip design, all the way up to a entire processor. Mindblowing for a first year student.
05:46:45 <zmbmartin> I wanted to take a stab at porting this over to haskell. But seems from what I have read encryption in haskell is tricky. https://github.com/hueniverse/iron
05:47:06 <zmbmartin> Any suggestions on best packages to use or directions?
05:47:40 <merijn> zmbmartin: For encryption? libsodium (i.e. NaCl), but I dunno if the haskell wrappers for that are finally finished?
05:48:28 <vektor> Link: https://hackage.haskell.org/package/saltine ?
05:48:51 <merijn> Not the wrapper I was thinking off, but yeah
05:48:56 <vektor> Doesn't quite seem finished :D
05:49:14 <zmbmartin> Haven't seen that one.
05:49:22 <merijn> I was thinking of https://github.com/thoughtpolice/salt
05:50:31 <zmbmartin> merijn: Any worries that hasn't been updated in a while?
05:52:22 <merijn> zmbmartin: I think austin is having trouble finding the time to finish it, a familiar I know all to well from my own stuff :p
05:52:52 <zmbmartin> merijn: Me too :)
05:52:54 <vektor> https://codelympics.io/blog/why-do-side-projects-die
05:53:36 <zmbmartin> Thanks guys
05:53:54 <ely-se> no problem
05:53:58 <merijn> My side projects don't die because I lose interest/get stuck, they die because after a day of work I don't want to program
05:54:16 <merijn> I'd rather go out or play video games
05:55:03 <wei2912> lol
05:55:09 <vektor> Hehe yeah. And the few days where you don't have to work, you wanna relax.
05:55:30 <Sindriava> Is there a way to have a "root file" for a module?
05:55:37 <Myrl> wei2912: HAI HAIAIAIAIA
05:56:03 <Sindriava> e.g. if I have two files, Module/A.hs and Module/B.hs, how would I specify what happens if I "import Module" ?
05:56:13 <wei2912> hi Myrl 
05:56:15 <wei2912> Myrl: how's it going?
05:56:19 <Myrl> wei2912: nothing.
05:56:48 <vektor> Sindriava: if I'm informed correctly, you'd create a Module called Module.hs and reimport what you need.
05:56:52 <vektor> *reexport
05:56:55 <merijn> Sindriava: You can re-export
05:56:57 <srhb> That's correct.
05:57:12 <Sindriava> vektor: And I'd just put it next to the Module folder? That's what I'm doing now
05:57:24 <Sindriava> I was wondering if there was some convention for Module/Init.hs or something
05:57:40 <merijn> Module.hs with "module Module (module Module.A, module Module.B) where import Module.A; import Module.B"
05:57:57 <merijn> Sindriava: What would Init.hs do?
05:58:30 <Sindriava> merijn: Instead of "Module.hs, Module/A.hs" you'd have "Module/Init.hs, Module/A.hs"
05:58:50 <Sindriava> merijn: E.g. a way to not repeat yourself with the name of the module and keep all the relevant files in one place
05:59:36 <wei2912> how would i solve this problem: http://pastebin.com/KMzTHKE4 in a clean way? i can easily do it with a long if statement, but i'd rather write cleaner code
06:00:24 <Sindriava> wei2912: chunksOf and transpose
06:00:45 <vektor> pattern matching I would use
06:01:08 <Sindriava> vektor: If it's only for 2-by-2 matrices then I guess that'd work better
06:01:09 <vektor> matches [a,b,c,_] [a,b,c,_] = True
06:01:24 <vektor> that thing 4 times with different positions of the underscores and a default false case
06:01:26 <Sindriava> @let m = [1, 2, 3, 4]
06:01:27 <lambdabot>  Defined.
06:01:37 <Sindriava> > chunksOf 2 m
06:01:39 <lambdabot>      Ambiguous occurrence ‘m’
06:01:39 <lambdabot>      It could refer to either ‘L.m’, defined at L.hs:147:1
06:01:39 <lambdabot>                            or ‘Debug.SimpleReflect.m’,
06:01:51 <Sindriava> > chunksOf 2 [1, 2, 3, 4]
06:01:52 <lambdabot>  [[1,2],[3,4]]
06:01:55 <vektor> > m
06:01:56 <lambdabot>      Ambiguous occurrence ‘m’
06:01:56 <lambdabot>      It could refer to either ‘L.m’, defined at L.hs:147:1
06:01:56 <lambdabot>                            or ‘Debug.SimpleReflect.m’,
06:02:00 <Sindriava> > transpose . chunksOf 2 [1, 2, 3, 4]
06:02:01 <vektor> really? :D
06:02:01 <lambdabot>      Couldn't match expected type ‘a -> [[a1]]’
06:02:01 <lambdabot>                  with actual type ‘[[Integer]]’
06:02:01 <lambdabot>      Possible cause: ‘chunksOf’ is applied to too many arguments
06:02:16 <Sindriava> > transpose . chunksOf 2 $ [1, 2, 3, 4]
06:02:17 <lambdabot>  [[1,3],[2,4]]
06:02:56 <Sindriava> then you zipWith (/=) and you get which of the lists are different
06:03:03 <Sindriava> *which of the elements
06:03:20 <wei2912> whoops, i posted this in #haskell
06:03:34 <wei2912> wanted to ask a python question :P
06:03:53 <wei2912> Sindriava: thanks anyways
06:04:40 <Intolerable> why does ExceptT have a functor, monad constraint on its applicative instance?
06:04:46 <Intolerable> backwards compatibility?
06:04:48 <vektor> Sindriava: Heh, I just noticed I misread the question
06:05:05 <wei2912> vektor: thanks as well
06:05:19 <Sindriava> wei2912: In Python, you might want to have a function that compares elements in stride of 2
06:06:00 <Rembane> wei2912: I think you can do some really sweet stuff with slicing in Python. 
06:06:18 <merijn> Intolerable: The Functor constraint is now redundant, yeah
06:06:33 <Intolerable> surely the Monad could be reduced to Applicative?
06:06:49 <Phillemann> With GeneralizedNewtypeDeriving and StandloneDeriving, isn't it possible to derive Num? Strange...
06:07:04 <Sindriava> Is there a neater way to recursively call an anonymous function than using fix ?
06:07:25 <merijn> Sindriava: Fix doesn't call an anonymous function...
06:07:30 <Intolerable> depending on your definition of "neater", there's Cont / ContT
06:07:30 <merijn> Intolerable: No
06:07:40 <Sindriava> merijn: I never said it did, but it can accomplish the same task
06:07:59 <merijn> Intolerable: You need to get the "Either e a" out of the 'm' to decide whether to abort or continue the applicative evaluation
06:08:01 <Sindriava> merijn: That's why I'm asking, if there's a way to do it, without having to use fix.
06:08:09 <Intolerable> ah of course
06:08:15 <merijn> Intolerable: The only way you can pull something out of 'm' is if it's a Monad
06:08:20 <wei2912> Rembane: hmm
06:08:23 <Intolerable> i ask because i'm using a modified ExceptT that doesn't need it
06:08:32 <merijn> Sindriava: "to do it" -> to do what?
06:08:42 <Intolerable> but yeah the difference is that ExceptT needs to check between
06:08:49 <Sindriava> merijn: "recurse an anonymous function" -.-
06:09:02 <merijn> Sindriava: Then no, fix is the primitive way to do that
06:09:20 <Sindriava> Oh well.
06:09:43 <merijn> You need to have a name to call and the only way to do that anonymously is using fix to get the function passed in as argument
06:09:57 <Intolerable> put it into Cont
06:10:20 <merijn> Intolerable: That doesn't allow you to recurse
06:10:20 <Intolerable> goto is so handy :^)
06:10:24 <merijn> I think?
06:10:30 <merijn> I'm not sure, Cont is confusing
06:11:34 <Sindriava> why can't I match ` IO a ` with ` IO () ` ?
06:11:35 <Intolerable> fix $ \loop -> getLine >>= \case { "" -> return (); x -> putStrLn x >> loop }
06:11:43 <Intolerable> that kind of thing can definitely be shifted to cont
06:11:50 <Intolerable> but yeah cont is very confusing
06:11:54 <Intolerable> and probably overkill here
06:12:05 <Sindriava> Intolerable: Cont is a bit overkill for that, yeah
06:12:11 <vektor> So are tree zippers usually implemented by means of a path through the tree and a usual representation of the tree, or do they do the funky stuff where they represent the part that isn't below the currently-selected node in terms of the selected node?
06:12:23 <Intolerable> if i was nesting fixes i'd switch to to cont
06:12:34 <Sindriava> vektor: http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/
06:13:06 <Sindriava> Intolerable: I just named the function, so that's solved :D
06:13:30 <Intolerable> that is of course the other solution
06:15:34 <vektor> Sindriava: Am I reading this right? You could do that circular pointer thing in haskell, somehow? I mean it's horrible, but I thought you couldn't have a reference b which reference a?
06:15:53 <vektor> (last references misses an s)
06:16:20 <Sindriava> vektor: I don't see why not, thanks to lazy evaluation that should be a problem
06:17:04 <Sindriava> > let { foo = 1 : bar; bar = 0 : foo } in { take 10 foo }
06:17:05 <lambdabot>  <hint>:1:1:
06:17:05 <lambdabot>      parse error in let binding: missing expression after 'in'
06:18:09 <vektor> > let { foo = 1 : bar; bar = 0 : foo } in take 10 foo
06:18:10 <lambdabot>  [1,0,1,0,1,0,1,0,1,0]
06:18:18 <Sindriava> vektor: Thanks
06:18:18 <Myrl> Err....
06:18:29 <vektor> sure, that works.... but... I mean... that's not recursing references.
06:18:29 <Myrl> How do I know what version my Prelude is?
06:18:34 <Myrl> `bool` doesn't seem to exist.
06:18:39 <Sindriava> vektor: This will also only allocate 2 ints, so there's not problem afaik
06:18:44 <Myrl> Tried to import Data.Bool too, doesn't work.
06:18:49 <Myrl> >bool 1 2 True
06:18:57 <Myrl> > bool 1 2 True
06:18:58 <lambdabot>  2
06:19:21 <Sindriava> Myrl: Check the version of the base package and/or ghc?
06:19:38 <Myrl> Sindriava: How do I check the base package version?
06:19:47 <Myrl> "GHCi, version 7.6.3:"
06:19:50 <Sindriava> Myrl: Look into you project.cabal file?
06:19:59 <Myrl> Sindriava: Ah.
06:20:21 <Sindriava> Myrl: Yeah, then you're probably using GHC 7.6.3, the current version is 7.10.1
06:20:31 <srhb> Myrl: ghc-pkg list | grep base
06:20:38 <tashjash> Sindriava, nope 7.10.2 ;)
06:20:54 <Sindriava> tashjash: HOW HAVE I BEEN LIVING TILL NOW
06:20:59 * Sindriava goes off to update his GHC
06:21:16 <tashjash> Sindriava, I just discover it )
06:21:21 <tashjash> I'm compiling right now
06:21:35 <Sindriava> I'll check if there's a repo version already
06:22:28 <Sindriava> yay, 7.10.2 here I come!
06:22:50 <tashjash> Sindriava, a repo version? which distrib?
06:22:57 <Sindriava> tashjash: OSX :D
06:23:07 <tashjash> Sindriava, ha ok
06:23:47 <Sindriava> tashjash: Actually, I think there's a version of homebrew for linux called LinuxBrew, which might be of interest
06:23:59 <Sindriava> tashjash: But I'm not sure it uses the same package sources
06:24:04 <tashjash> Sindriava, I'm compiling it from source, it's more simple
06:24:21 <srhb> tashjash: All of GHC? yeesh, takes forever.
06:24:38 <Sindriava> srhb + 1, I never had the paitence
06:24:41 <tashjash> srhb, just few hours (one or two)
06:24:43 <Myrl> I guess I have to update my local shit too.
06:24:48 <srhb> I did once. Never again.
06:24:55 <tashjash> I do something else, when compiling
06:25:00 <tashjash> I have four cores
06:25:24 <Myrl> @world updates on a P4 is fun.
06:25:24 <lambdabot> Sorry, look up one word at a time please.
06:25:59 <Myrl> By that, I mean "I'm wasting half my life again" fun.
06:29:44 <htebalaka> can anyone tell me why the helper functions are necessary for this to typecheck. i cant for the life of me figure it out: http://lpaste.net/137586
06:32:29 <chpatrick> htebalak: I think for the second one it's defaulting the a to Integer
06:32:45 <chpatrick> and with the helper it isn't
06:32:55 <chpatrick> I don't know AD but I guess grad is polymorphic right?
06:33:06 <chpatrick> so I think there's some ambiguity
06:33:28 <chpatrick> the P works for any a and grad also works for any a so it doesn't know what it is
06:34:08 <htebalaka> chpatrick: the weird thing is that in my actual code (this is a minimal example), i could use f in a context that requires Ints or Doubles, just not with grad (which requires Num a => Reverse s a)
06:34:50 <chpatrick> are you sure you should be taking a polymorphic value?
06:35:06 <chpatrick> can't it be P n?
06:35:24 <htebalaka> grad is polymorphic: ((forall s. Reifies s Tape) => t (Reverse s a) -> Reverse s a) -> t a -> t a
06:35:52 <htebalaka> my first attempt was works2, which i think makes more sense. you're right that it being polymorphic over all Num is more than necessary
06:36:19 <htebalaka> but when it didn't work i tried the more polymorphic version, and got the defaulting issue
06:36:49 <htebalaka> it's just weird the helper functions make a difference in either case
06:37:46 <chpatrick> I think it's some kind of monomorphism thing
06:38:04 <chpatrick> MonoLocalBinds or something
06:38:36 <chpatrick> maybe turn off GADTs and turn P into a regular ADT?
06:38:41 <chpatrick> see if it works then
06:38:42 <phao> Hi. Is the book Real World Haskell still relevant?
06:38:48 <chpatrick> phao: some of it is
06:38:50 <chpatrick> it's a bit dated
06:38:54 <htebalaka> i tried NoMonomorphismRestriction hadn't heard of that one
06:38:55 <srhb> phao: Relevant yes, outdated, yes.
06:39:10 <srhb> phao: (ie. the concepts are fine, the code will not all work)
06:39:31 <catgocat> @pl sendBytes sock bytes = (send sock $ toStrict $ encode $ length bytes) >> send sock bytes
06:39:31 <lambdabot> sendBytes = ap (ap . ((>>) .) . (. (toStrict . encode . length)) . send) send
06:39:36 <phao> I see.
06:40:20 <chpatrick> catgocat: what's wrong with the original?
06:40:29 <catgocat> what?
06:40:39 <chpatrick> not sure it needs pointlessing :)
06:40:42 <srhb> phao: What are you looking for? Perhaps we can give alternative recommendations, depending on your needs.
06:41:33 <phao> srhb, I don't really know. hehe
06:41:39 <mazur> is there somewhere i can see all the language pragmas that imply other language pragmas? i have a list from what i've found in documentation but i don't know how complete it is
06:41:41 <srhb> phao: Okay. :-)
06:42:48 <phao> srhb, There are tons of cs/programming related things I want to look at, and I'm not so sure which to choose, but I don't really think this is a problem others can really help me solve =)
06:43:02 <catgocat> @pl getFull read = (fmap $ fmap $ append read) $ recvFull sock (count - length read)
06:43:02 <lambdabot> getFull = ap (fmap . fmap . append) (recvFull sock . (-) count . length)
06:43:08 <catgocat> nice
06:43:10 <srhb> phao: Fair enough. :-)
06:43:33 <merijn> catgocat: That's completely unreadable...
06:50:13 <Myrl> Guys.
06:50:30 <htebalaka> chpatrick: regular ADTs still have the problem. maybe the fact that pattern matching on the datatype happens syntactically outside the scope of grad's argument prevents the type from being polymorphic within its argument?
06:51:16 <chpatrick> htebalaka: I mean GADTs turn on some type-inference related extensions
06:51:20 <chpatrick> or off, can't remember
06:51:35 <chpatrick> so maybe turning it off would fix it
06:51:58 <chpatrick> or possibly they're making the helper work
06:52:58 <htebalaka> yeah. i didn't realize the example didn't require it, but the issue still pops up with a regular ADT
06:54:00 <chpatrick> hmm
06:58:42 <aweinstock> @hoogle m () -> m a -> m a
06:58:42 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
06:58:42 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
06:58:42 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
07:00:34 <aweinstock> if I'm understanding the "lazy functional state threads" paper correctly, ST should have a MonadFix instance?
07:02:08 <mauke> :t mfix (\_ -> newSTRef () >> return 42)
07:02:09 <lambdabot> Num a => ST s a
07:02:16 <mauke> :t runST (mfix (\_ -> newSTRef () >> return 42))
07:02:17 <lambdabot> Num a => a
07:02:19 <mauke> > runST (mfix (\_ -> newSTRef () >> return 42))
07:02:21 <lambdabot>  42
07:02:38 <aweinstock> @src fixST
07:02:38 <lambdabot> Source not found. stty: unknown mode: doofus
07:03:42 <aweinstock> mauke: do you have an example of doing something fancy/nontrivial with ST's mfix?
07:04:24 <htebalaka> aweinstock: i've used it once before
07:05:10 <aweinstock> found this: https://mail.haskell.org/pipermail/haskell/2002-February/008943.html
07:05:23 <aweinstock> htebalaka: do you have a link to the code?
07:05:30 <htebalaka> in a union-find algorithm, you've got a vector of integers, which you need to follow (each index points to another index, or itself). as you traverse the vector you replace each value with the last value, which you haven't computed yet
07:06:03 <htebalaka> lemme see if i still have it
07:07:45 <htebalaka> aweinstock: sorry, don't seem to have it. might be on my other computer, which is disassembled atm
07:07:50 <JagaJaga> I have a list. [(1,1),(2,2),(3,3),(4,4),(5,5)]. How can I do this: check each item, and if snd is > 4 then delete this item from a list, when snd == 4 stop and return that trimed list.
07:08:30 <Intolerable> :t filter (not . (> 4) . snd)
07:08:31 <aweinstock> > filter ((<= 4) . snd)  [(1,1),(2,2),(3,3),(4,4),(5,5)]
07:08:32 <lambdabot> (Num b, Ord b) => [(a, b)] -> [(a, b)]
07:08:33 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
07:08:50 <Intolerable> :t takeWhile ((/=4) . snd) . filter (not . (> 4) . snd)
07:08:51 <lambdabot> (Num b, Ord b) => [(a, b)] -> [(a, b)]
07:08:51 <JagaJaga> Intolerable: but filter will iterate over all elements :)
07:09:00 <ReinH> JagaJaga: will it?
07:09:00 <kqr> JagaJaga, no it won't
07:09:04 <kqr> JagaJaga, only as many as it needs to
07:09:11 <kqr> JagaJaga, laziness to save the day!
07:09:15 <tromp_> laziness rocks
07:09:20 <ReinH> > take 5 . filter even $ [1..]
07:09:21 <lambdabot>  [2,4,6,8,10]
07:09:31 <aweinstock> > filter (<5) [1..]
07:09:35 <lambdabot>  mueval-core: Time limit exceeded
07:09:40 <JagaJaga> ReinH: without takeWhile it will, won't it?
07:09:48 <Intolerable> yeah, before the takeWhile
07:10:03 <JagaJaga> Intolerable: takeWhile is what I need. Thank you!
07:10:07 <Intolerable> but if you stop once you have a 4, nothing after that will have the filter function applied
07:10:14 <ReinH> JagaJaga: yes, if you filter forever then you filter forever
07:10:20 <merijn> :t takeWhile ((/=4) . snd) . filter ((>4) . snd)
07:10:21 <lambdabot> (Num b, Ord b) => [(a, b)] -> [(a, b)]
07:10:30 <JagaJaga> Intolerable: I know that. But I didn't know this function :)
07:10:53 <Intolerable> :t takeWhile (/= 4) [1..
07:10:54 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:10:59 <Intolerable> > takeWhile (/= 4) [1..]
07:11:00 <lambdabot>  [1,2,3]
07:11:13 <Intolerable> careful, because that'll drop the (4, x) in your list
07:11:32 <Intolerable> (idk if u wanna keep it or not)
07:12:40 <JagaJaga> Intolerable: I need to keep it.
07:12:51 <kqr> takeWhile (> 4) then
07:12:54 * hackagebot ekg-json 0.1.0.0 - JSON encoding of ekg metrics  https://hackage.haskell.org/package/ekg-json-0.1.0.0 (JohanTibell)
07:12:56 <kqr> uh
07:12:57 <kqr> < 4
07:12:59 <kqr> probably
07:13:03 <kqr> <= 4
07:13:04 <Intolerable> no, it needs to stop exactly on the 4
07:13:06 <kqr> is even better
07:13:10 <Intolerable> (i assume, that's what he said)
07:13:21 <kqr> oh
07:13:37 <Intolerable> anything (> 4) is dropped, and then take so the last elem is the first 4
07:13:55 <Intolerable> idk if theres anything in Data.List for that
07:13:59 <Intolerable> but its trivial to implement
07:14:28 <vektor> Why is it that google always gets me deprecated documentation of hackage modules? And why doesn't hackage notify me of the fact that a package is deprecated?
07:14:40 <Intolerable> deprecated or older versions?
07:14:48 <merijn> vektor: Do you use Chrome?
07:14:53 <JagaJaga> Intolerable: indeed I have a list of type [(a,[b])], and I need to find and element where snd contains some element. And when I find it I need to left only elements before this one (and itself too).
07:14:54 <vektor> Nope, FF
07:15:11 <vektor> Was looking at this: https://hackage.haskell.org/package/rosezipper-0.1/docs/Data-Tree-Zipper.html
07:15:18 <merijn> vektor: Chrome has a "Hackage-Fu" extension which warns whether you're on the latest version of the docs
07:15:23 <vektor> Cabal got me version 0.2 without me noticing.
07:15:26 <merijn> Maybe FF has something similar
07:15:35 <vektor> a
07:15:41 <merijn> oh, looks like there is
07:15:44 <merijn> https://github.com/statusfailed/hackage-fu
07:16:47 <vektor> Alright, that helps a bit. Would be too much to ask to put that on the hackage page, right?
07:17:22 <JagaJaga> Intolerable: or I can just get the index of element in the list and then do drop..
07:17:32 <Intolerable> that might be two traversals
07:18:56 <JagaJaga> Intolerable: no good way to do?
07:19:22 <Intolerable> define your own takeWhilePlusOne
07:19:23 <Intolerable> or similar
07:19:32 <aweinstock> :t takeWhile (not . (42 `elem`) . snd)
07:19:33 <lambdabot> (Eq a, Num a, Foldable t) => [(a1, t a)] -> [(a1, t a)]
07:19:38 <Intolerable> that does a takeWhile, but then keeps the element it find
07:19:41 <Intolerable> *finds
07:19:51 <JagaJaga> Intolerable: got your idea.
07:19:56 <JagaJaga> @src takeWhile
07:19:56 <lambdabot> takeWhile _ []                 = []
07:19:56 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
07:19:56 <lambdabot>                    | otherwise = []
07:20:01 <Intolerable> it shouldn't be too complicated
07:20:15 <aweinstock> replace otherwise = [] with otherwise = [x]?
07:20:16 <JagaJaga> Intolerable: yeah, thank you :)
07:20:20 <kqr> you could also zip the list with its tail
07:20:27 <kqr> and take from the list based on the tail
07:20:29 <kqr> or something like that
07:20:57 <Intolerable> will a find / take index traverse the list twice?
07:20:59 <kqr> there's probably an off-by-one error in that description but you get the idea
07:21:22 <Gurkenglas> :t \b -> either Just (const Nothing) . F.foldlM (\xs x -> (if elem b $ snd x then Left else Right) (x:xs)) [] -- JagaJaga
07:21:23 <lambdabot> (Eq a, Foldable t, Foldable t1) => a -> t (a1, t1 a) -> Maybe [(a1, t1 a)]
07:21:45 <Gurkenglas> The list will be reversed, though. hmm
07:21:51 <Intolerable> that's terrifying
07:22:14 <Gurkenglas> Nothing stands for no snd contains your b, btw.
07:23:44 <chpatrick> :t \m -> foldr (\x xs -> x : if m `elem` snd x then [] else xs) []
07:23:46 <lambdabot> (Eq a, Foldable t, Foldable t1) => a -> t (a1, t1 a) -> [(a1, t1 a)]
07:24:12 <chpatrick> let takeUntil m = foldr (\x xs -> x : if m `elem` snd x then [] else xs) []
07:24:21 <chpatrick> @let takeUntil m = foldr (\x xs -> x : if m `elem` snd x then [] else xs) []
07:24:23 <lambdabot>  Defined.
07:24:51 <chpatrick> > takeUntil 2 [ ( "foo", [ 1 ] ), ( "bar", [ 2, 3 ] ), ( "baz", [ 2, 5 ] ) ]
07:24:57 <lambdabot>  [("foo",[1]),("bar",[2,3])]
07:25:00 <chpatrick> there you go
07:25:06 <Intolerable> takeUntil is a little confusing because it seems like the inverse of takeWhile
07:25:07 <chpatrick> it's a good consumer too
07:25:19 <Gurkenglas> Neat! "good consumer"?
07:25:39 <chpatrick> Gurkenglas: it means that it supports list fusion
07:25:57 <chpatrick> if the list that's passed in is from a good producer then there won't be an intermediate list
07:25:58 <Sindriava> Is there an case function? I'd like to do something like: "doSomething >>= case of …"
07:26:03 <Intolerable> LambdaCase
07:26:13 <Intolerable> definitely my favorite extension
07:26:16 <broma0> I have a few questions about the language in general if anyone has any comments:
07:26:17 <chpatrick> likewise
07:26:35 <Intolerable> return (Right x) >>= \case …
07:26:45 <Intolerable> broma0: go ahead
07:27:43 <broma0> Why are packages like 'mtl' 'base' and 'containers' not baked in to haskell by default? Does the community & ghc really just prefer a tiny core? I can't imaging writing a single useful program without those three packages at least
07:28:10 <Intolerable> base essentially is
07:28:18 <Intolerable> the other two i use infrequently
07:28:24 <Intolerable> (speaking for myself)
07:28:26 <broma0> Mtl?
07:28:32 <Intolerable> yup, i don't use it at all
07:28:44 <broma0> Do you use transformers?
07:28:47 <Intolerable> yes
07:28:52 <broma0> Ah I see
07:28:54 <Intolerable> https://github.com/intolerable/reddit/blob/master/reddit.cabal#L92
07:29:15 <broma0> Intolerable, why not myl?
07:29:23 <broma0> I see your depends (ha)
07:29:36 <Intolerable> i don't like the package
07:29:53 <Intolerable> its a personal thing, if you find it helps you should definitely use it
07:29:59 <Gurkenglas> How big a problem is it when A depends on B and C<2, and B depends on C>3?
07:30:01 <broma0> Maybe it's just a lack of standardization?
07:30:09 <Intolerable> how do you mean?
07:30:28 <broma0> Like why do we gave both mtl and transformers?
07:30:41 <broma0> Have* sorry I'm typing on a phone
07:30:53 <Intolerable> well i mean mtl depends on transformers
07:30:59 <Cale> Gurkenglas: Sounds like it would make the build fail.
07:31:16 <Intolerable> mtl is a bunch of classes on top of transformers
07:31:27 <Intolerable> but i rarely work outside a concrete transformer stack
07:31:36 <chpatrick> I think mtl is pretty sweet
07:31:37 <Intolerable> so i don't ever need mtl
07:31:42 <Gurkenglas> If B also depends on D, is A automatically able to import D's modules?
07:31:48 <chpatrick> ekmett's point is that the typeclass-based coding is essentially an effect system that works
07:32:07 <chpatrick> ie where you're polymorphic in the monad and just say what special powers you want for each function
07:32:12 <Intolerable> i also don't really like the typeclasses thing
07:32:14 <chpatrick> then you can choose your monad at the end
07:32:20 <chpatrick> it makes it very flexible
07:32:29 <Cale> Gurkenglas: not automatically, no, but there might be types and definitions from D which get re-exposed by B
07:32:35 <broma0> I should probably be using transformers then... I rarely have anything other than "ThisT (ThatT (EtcT ...) ...)
07:32:40 <Intolerable> my main problem with mtl is how it deals with ReaderT x (ReaderT x) stacks
07:32:56 <Intolerable> if you have a concrete stack, transformers will probably do
07:33:00 <broma0> Why not just use a tuple or some wrapping structure?
07:33:13 <broma0> And one reader
07:33:23 <Cale> broma0: Indeed.
07:33:25 <Gurkenglas> Then couldn't you have B use a new version of C and A an old one? The namespaces dont collide after all
07:33:50 <Intolerable> if i was going to wrap types to put them into a reader, i'd just use ether
07:33:51 <broma0> chpatrick, what's this class based coding you mention?
07:34:04 <nitrix> Hi, I'm having an annoying problem with Snap strings:
07:34:17 <chpatrick> broma0: where your functions have types like MonadState SomeState m => m ()
07:34:17 <broma0> Well I have one more question
07:34:22 <nitrix> https://hackage.haskell.org/package/snap-core-0.9.7.2/docs/Snap-Core.html, the function dir apparently takes a ByteString
07:34:28 <Intolerable> rather than having a concrete stack, you use (MonadState x m, MonadReader y m, MonadCont z m) => m () 
07:34:32 <chpatrick> so rather than having a concrete monad you just say what effects monad should have
07:34:46 <Intolerable> and as long as m supports all those things, it'll work
07:34:47 <chpatrick> it's sweet because it makes it very easy to reuse functions in other monads
07:34:51 <Cale> chpatrick: I'm somewhat opposed to the mtl classes specifically though -- it's usually better to have something with more meaning than e.g. get and put.
07:34:52 <nitrix> oh hold on, actually I think I know what's going on.
07:34:56 <chpatrick> and to change the monad you're using
07:34:59 <broma0> That's interesting. And that's what mtl helps with?
07:35:03 <chpatrick> yeah
07:35:04 <Intolerable> yes
07:35:08 <Intolerable> @hackage ether
07:35:08 <lambdabot> http://hackage.haskell.org/package/ether
07:35:09 <chpatrick> it defines MonadState, MonadReader etc
07:35:11 <Intolerable> has a similar thing
07:35:15 <broma0> *learned*
07:35:17 <Intolerable> except it's tagged
07:35:33 <Intolerable> it's a little more complicated, but i'd rather use that than mtl
07:35:33 <Cale> chpatrick: The general approach to having type classes like that isn't bad, but I think MonadState etc. aren't really a good example of how to do it.
07:35:48 <Gurkenglas> How does one ordinarily deal with the problem of wanting your monad stack to have multiple MonadReader instances?
07:35:56 <Cale> It would be better to define your own class with operations that are more application-specific.
07:35:58 <Intolerable> newtypes
07:36:20 <Cale> I also incidentally hate the term "monad stack"
07:36:28 <Gurkenglas> monad transformer stack?
07:36:29 <broma0> Cale, and why is that?
07:36:34 <Cale> You would never call f (g (h x)) a "value stack"
07:36:36 <broma0> Just the term, or the actual act?
07:36:43 <chpatrick> you could though
07:36:43 <broma0> Fair enough
07:37:00 <Intolerable> i'd call that a transformer stack if f g h were applicative
07:37:05 <Cale> I just don't like the "stack" part
07:37:14 <frerich> I always read 'stack' as 'composition' in my mind.
07:37:21 <frerich> Like with function composition.
07:37:27 <Intolerable> i use applicative transformer stacks somewhere
07:37:35 <broma0> Where is this class based coding talk?
07:37:47 <chpatrick> I just heard it in person at zurihac
07:37:55 * hackagebot ekg 0.4.0.8 - Remote monitoring of processes  https://hackage.haskell.org/package/ekg-0.4.0.8 (JohanTibell)
07:37:57 <chpatrick> at least the effect system perspective
07:38:04 <broma0> Is there a video or documentatio. somewhere?
07:38:16 <Sindriava> Are the zurihac talks going to be online?
07:38:19 * frerich suspects an OOP'esque name would be "monad decorator"
07:38:31 <Cale> I usually just call it a monad.
07:38:45 <Gurkenglas> (Damn, I would have guessed you'd replace your "(MonadReader a m, MonadReader b m) =>" with "MonadReader s m => Getter s a -> Getter s b ->")
07:38:45 <Cale> The fact that it was constructed with a monad transformer shouldn't be all that important.
07:38:50 <chpatrick> broma0: https://www.reddit.com/r/haskell/comments/387ex0/are_extensible_effects_a_complete_replacement_for/
07:38:51 <chpatrick> maybe
07:39:14 <chpatrick> it wasn't a talk, he spent the whole conference braindumping and this was one of them :)
07:39:20 <broma0> Alright one more question: Class-based prelude. Will it ever happen? Like no more map, just fmap. No more 3 ways to lift, just <$>. Etc.
07:39:31 <Intolerable> well i mean
07:39:33 <Intolerable> :t mapM
07:39:33 <broma0> Maybe those aren't great examples
07:39:34 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:39:44 <chpatrick> broma0: you mean a classy prelude? :)
07:39:48 <chpatrick> @hackage classy-prelude
07:39:48 <lambdabot> http://hackage.haskell.org/package/classy-prelude
07:39:56 <Cale> broma0: fmap and (<$>) are the same btw.
07:40:04 <chpatrick> I just got that pun
07:40:10 <Sindriava> Is it weird that I'm irrationally offended that fmap for [a] is map, not the other way?
07:40:24 <Cale> Sindriava: not that weird
07:40:25 <broma0> Yeah wow I just listed 5 of the same thing actually... that's the problem!!
07:40:29 <Intolerable> what, that map isn't the main one?
07:40:35 <Sindriava> Cale: Whew
07:40:41 <Cale> In Haskell 1.4, map :: (Functor f) => (a -> b) -> f a -> f b
07:40:44 <broma0> I'd like classy prelude to be the default
07:40:48 <chpatrick> <$> is the main name for me anyway :)
07:40:48 <Sindriava> Intolerable: That the definition is "fmap = map" not "map = fmap"
07:40:59 <Intolerable> yeah, that bothers a lot of people i think
07:41:10 <Cale> Weirdly enough, I only use <$> in conjuction with <*>
07:41:22 <Cale> conjunction*
07:41:43 <Sindriava> I think it's okay that there's two versions, since `fmap` is a function where `(<$>)` is an infix operator
07:41:45 <chpatrick> I use it if it doesn't introduce more parentheses
07:41:54 <broma0> Gah there is so much depth to this damn language
07:42:03 <Gurkenglas> I use <$> whenever I'd use fmap (...) $ (...) and it doesn't break the infix precedences
07:42:07 <broma0> It's like vim
07:42:13 <chpatrick> it never ends
07:42:15 <Intolerable> i use <$> for everything but f <$> g X
07:42:20 <Intolerable> *f <$> g $ x
07:42:38 <Intolerable> since fmap f $ is less hassle
07:42:42 <Intolerable> than extra parents
07:42:48 <Intolerable> extra parents.
07:42:52 <Cale> However, at the same time as I'd like to see map be the functorial map, I kind of hate the way that recent changes to the Prelude have de-emphasised the importance of lists.
07:43:09 <chpatrick> why is that?
07:43:14 <broma0> :t (<$>) . (<$>) . (<$>) . (<$>)
07:43:15 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
07:43:17 <Cale> Lists are our loops.
07:43:22 <broma0> Ha
07:43:29 <chpatrick> hmm
07:43:32 <chpatrick> lists are often wrong too
07:43:34 <Cale> They're more important and universal than we often give them credit for.
07:43:41 <Intolerable> i use that function somewhere
07:43:42 <Cale> Yes, they're not for everything.
07:43:47 <chpatrick> and making all the good names work on lists kinda misleads people to use them when they shouldn't
07:43:54 <Intolerable> might just be <$> . <$> . <$> though
07:43:57 <Cale> But they are a great way to express linear iteration over a sequence of things.
07:44:11 <chpatrick> sure but I don't think they should get all the unqualified names
07:44:20 <Sindriava> Cale: They still can be used for linear iteration?
07:44:21 <chpatrick> especially when the ideas behind them are more general
07:44:34 <chpatrick> the functions I mean
07:44:43 <Cale> Well, really it's just Foldable that I don't care for all that much.
07:44:54 <chpatrick> what's wrong with it?
07:45:05 <tashjash> 1h15 to build GHC :)
07:45:14 <Cale> Well, it's sort of nebulous and hard to precisely specify laws for.
07:45:37 <chpatrick> there's a proposal to define them in terms of traversable right?
07:45:38 <Cale> It's kind of like "has a mapping  f a -> [a]", but not quite that
07:45:43 <chpatrick> where f is traversable too
07:47:18 <Cale> and I dunno, if you're going to be iterating over the elements of a structure, I think mapping to a list and then performing a list operation is a usually appropriate way to express what's going on. Maybe not always? Maybe you sometimes want some sort of tree structure, but then we should say what those tree structures are...
07:48:07 <chpatrick> hmm
07:48:09 <Cale> By sort of eliminating the lists from the picture, maybe we sometimes get better efficiency, but I feel like we're also losing something in terms of understanding.
07:48:20 <chpatrick> I mean it's true that foldable is just operating over a flat stream
07:48:28 <Cale> Well, it's not quite true
07:48:30 <chpatrick> but then again internally lists are expressed as folds
07:48:35 <chpatrick> for list fusion
07:48:42 <chpatrick> (when possible)
07:48:42 <Cale> Because some instances of Foldable do tree-like things
07:48:46 <chpatrick> so maybe folding is the right primitive
07:48:48 <chpatrick> instead of concrete lists
07:49:23 <chpatrick> since even if foldable was just toList then internally the list would likely be a fold
07:49:36 <chpatrick> so it's nice to get rid of that complication
07:51:25 <drmacak> Hi, somebody experienced with ZMQ?
07:53:48 <Cale> chpatrick: toMonoid :: forall m. (Monoid m) => f a -> (a -> m) -> m is perhaps a better approximation of what Foldable specifies for you, but it's unclear how to say what laws this thing ought to have.
07:55:01 <Cale> I guess that's foldMap
07:55:03 <Cale> yeah
07:55:10 <chpatrick> yeah
07:55:33 <chpatrick> it's just nice that there's no ambiguity with good consumers/producers with Foldable
07:55:46 <chpatrick> with lists you're not quite sure if there's a list or not
07:56:44 <Cale> Yeah, there's a valid concern about predictable efficiency
07:57:47 <kqr> 'tis
07:58:15 <kqr> i've always assumed that's one of the primary reasons the foldable class has so many methods in it
07:58:25 <Cale> I just wish we didn't have to sell out one of the advantages of working in a non-strict programming language with respect to being able to decompose things.
07:59:17 <chpatrick> what do you mean?
08:00:14 <chattered> Cale: I'd be happy enough just doing "toList" when I want to iterate over structures. I suspect my attraction to Foldable is just about being able to omit this one function.
08:00:19 <Cale> The fact that we can factor any iteration whatsoever through (possibly infinite) lists, and understand our programs through that decomposition.
08:00:25 <chpatrick> :t toList
08:00:27 <lambdabot> IsList l => l -> [Item l]
08:00:30 <chpatrick> wat
08:00:31 <chpatrick> :t F.toList
08:00:33 <lambdabot> Foldable t => t a -> [a]
08:00:45 <Cale> Yeah, toList on its own is fine
08:00:57 <Cale> (apart from my reservations regarding what laws it satisfies)
08:01:02 <chpatrick> but again if you're dealing with lists as your primitive then you have to rely on list fusion for it to be efficient
08:01:11 <chpatrick> which is a lot more wibbly wobbly
08:01:14 <Cale> I guess
08:01:16 <chpatrick> than do a fold dammit
08:01:39 <Cale> I kind of wish that it wasn't wibbly wobbly and we could just feel comfortable relying on it.
08:01:44 <Cale> But maybe that's asking too much :)
08:02:08 <kuribas> isn't using a type family in a class the same as using functional dependencies, but with one less type parameter?
08:02:23 <chpatrick> kuribas: it's not as good for type inference
08:02:36 <kuribas> chpatrick: which one?
08:02:37 <chpatrick> because type families are one way (for now)
08:02:42 <chpatrick> type families aren't as good
08:03:07 <kuribas> What's their use case?
08:03:35 <chpatrick> well one nice thing is that you can have SomeClass a => ... as a constraint
08:03:42 <chpatrick> where a has some type family instance you don't care about
08:03:46 <Cale> You can specify inverse type families and put the relationship between them in the class context for the class declaration though.
08:03:57 <chpatrick> but you can't do instance SomeClass b a => <b doesn't appear here> where
08:04:13 <chpatrick> so they're useful for that
08:05:09 <Cale> kuribas: Associated type families and functional dependencies cover a lot of the same ground in a technical sense, but tend to be good at expressing different things.
08:05:22 <Cale> So I suspect they'll both stick around for quite a while
08:05:47 <kuribas> Are there cases where a functional dependency wouldn't work?
08:06:01 <ttt_fff> for developing with ghci, I see all these hacks about getting ghci to include data declarations ... but I'm perfectly happy with vim just sending ghci ":r" whenever I write new code
08:06:07 <ttt_fff> what am I missing (as opposed to coding direclty in the repl)
08:06:19 <ttt_fff> current appraocy = have ghci running, code in vim, then have vim send :r to ghci to reload code
08:06:28 <chpatrick> that's what I do
08:06:34 <ttt_fff> chpatrick++
08:06:35 <chpatrick> with sublime :)
08:06:40 <ttt_fff> chpatrick--
08:06:43 <chpatrick> hehe
08:06:48 <chpatrick> at least it's not emacs
08:06:51 <kuribas> ttt_fff: I do that with emacs :)
08:06:55 <ttt_fff> kuribas--
08:06:56 <chpatrick> kuribas--
08:07:00 <kuribas> nooooooooooo
08:07:15 <ttt_fff> chpatrick: yeah, I love the fast :r, but I don't get why people want to go throuhg all types of hacks to code directly in ghci
08:07:18 <kuribas> ttt_fff--
08:07:22 <kuribas> chpatrick--
08:07:26 <chpatrick> in before "I do that with ed"
08:07:36 <ttt_fff> also, if you code in ghci ... don't you want your code to be permenant ? well, if so, then you have to ... you know, .... STORE IT IN A FILE .... so why not code in an editor off the start? :-)
08:07:39 <chpatrick> "I do that by holding a battery to the serial port"
08:07:44 <Intolerable> ghci is magical
08:07:45 <kuribas> ttt_fff: what do you have against emacs?
08:08:01 <chattered> ttt_fff: It'd be nice to be able to use Haskell as an old-school LCF theorem prover, the way I can use HOL4 and HOL Light.
08:08:07 <ttt_fff> kuribas: oh I don't have anything against emacs, I use eshell as my shell when I'm on my surface pro
08:08:27 <chattered> For that, I need my interpreter sessions to stay live for days on end, ideally to snapshot, and for the environment to grow as needed.
08:08:30 <ttt_fff> chattered: tell me more ... I'm actually writing a theorem prover in haskell
08:08:58 <ttt_fff> kuribas: I have nothing against emacs, I just had to downvote you for bigoted religious vim/emacs war reasons
08:09:28 <ttt_fff> @karma ttt_fff
08:09:28 <lambdabot> You have a karma of 0
08:09:30 <ttt_fff> @karma kuribas
08:09:30 <lambdabot> kuribas has a karma of 1
08:09:43 <chpatrick> @karma chpatrick
08:09:43 <lambdabot> You have a karma of 1
08:09:45 <chpatrick> eyy
08:09:58 <ttt_fff> kuribas++
08:10:01 <ttt_fff> chpatrick++
08:10:08 <chattered> ttt_fff: The original LCF theorem provers (for which ML was first invented) were interactive. You sit at the interpreter, defin automation as you go, and prove theorems by defining new globals into your environment. I think Haskell would be awesome for that, if GHCi wasn't so crappy.
08:10:18 <kuribas> ttt_fff++
08:10:19 <ttt_fff> chattered: hmm, COq is like that
08:10:31 <ttt_fff> chattered: and after a while, I really hate it
08:10:37 <Intolerable> Either has a valid <|> but no empty, right?
08:10:41 <kuribas> ttt_fff: emacs lisp sucks though
08:10:50 <chattered> ttt_fff: They have their own top-level. You're not programming directly in the implementation language (which is Ocaml).
08:10:54 <ttt_fff> kuribas: yeah, if 'yi' relaly took off, I'd probably switch from vim
08:11:07 <chattered> HOL4 and HOL Light are much more empowering.
08:11:21 <ttt_fff> chattered: yeah, but (1) LTAC is not very fun (2) the Coq-ide sucks; it's like notepad, (3) and the emacs "proof general" interface is a hack
08:12:04 <ttt_fff> come to thikn of it; we need to get the xmoand guys to get yi to work
08:12:25 <ttt_fff> i'd pay for an editor written in haskell with haskell as the scripting langauge
08:12:31 <chattered> Right. But again, that's their own top-level for a dependently typed language. In HOL and HOL Light, you're metalanguage is just ML or Ocaml, and you're completely divorced from your logic.
08:13:08 <ttt_fff> what does 'divorced from your logic' mean, and why is it a good thing?
08:14:37 <chattered> ttt_fff: I mean that the metalanguage is just used to define the encapsulated datatype of theorems. All your tools are free to use completely arbitrary ML or Ocaml, and can happily be non-terminating. So long as you produce the theorem you want, you're good. You're not coding in the logic itself.
08:32:58 * hackagebot ekg-core 0.1.1.0 - Tracking of system metrics  https://hackage.haskell.org/package/ekg-core-0.1.1.0 (JohanTibell)
08:34:28 <augur> how do i install profiling libs for particular packages???
08:42:51 <broma0> What are some of the styles of programming found in the haskell community? (CPS, class-based, monad-based, reactive, etc.) Is there a common source of documentation on the various styles?
08:42:54 <peddie> augur: cabal install --enable-library-profiling ?
08:43:42 <augur> peddie: ahh lemme try that. thank you :)
08:48:59 <zoug> hello, I'm trying to find the number of times an element in [0..9] is in a list. The solution I came up with is "map (length (elemIndices xs)) [0..9]" but it doesn't work
08:49:26 <Intolerable> :t filter (`elem` [0..9])
08:49:27 <lambdabot> (Enum a, Eq a, Num a) => [a] -> [a]
08:49:37 <Intolerable> :t length . filter (`elem` [0..9])
08:49:38 <lambdabot> (Enum a, Eq a, Num a) => [a] -> Int
08:49:53 <hodapp> broma0: I don't know that anyone follows a dominant style closely enough to give it a term.
08:50:15 <zoug> Intolerable: could you explain what you mean? sorry I don't get it
08:50:52 <hodapp> Usually if it's called a "style" or a "pattern", and not a "library" or something, it's indicative of an abstraction that can be easily seen, yet not expressed as an abstraction in the language.
08:50:56 <chpatrick> zoug: that's a function that does what you want
08:50:59 <michaelt> augur: note that you have to install all the dependencies with profiling.
08:51:09 <Intolerable> ok so that does two things
08:51:27 <chpatrick> > 1000000000 `elem` [1..]
08:51:29 <Intolerable> filter (`elem` [0..9]) says "only keep elements that are in [0-9]
08:51:31 <lambdabot>  mueval-core: Time limit exceeded
08:51:43 <Intolerable> :t elem
08:51:45 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
08:51:47 <chpatrick> > 1000000000 `elem` [1..100000000000000000000]
08:51:50 <lambdabot>  mueval-core: Time limit exceeded
08:51:57 <Intolerable> :t elem :: a -> [a] -> Bool
08:51:58 <lambdabot>     No instance for (Eq a1) arising from a use of ‘elem’
08:51:58 <lambdabot>     Possible fix:
08:51:58 <lambdabot>       add (Eq a1) to the context of
08:52:05 <Intolerable> :t elem :: Eq a => a -> [a] -> Bool
08:52:06 <lambdabot> Eq a => a -> [a] -> Bool
08:52:18 <Intolerable> and then you take the length of the list that it returns
08:53:08 <augur> michaelt: how do you mean?
08:53:16 <zoug> so basically your filter f'n returns a list containing only the elements between 0 and 9 right?
08:53:27 <zoug> I already know for sure that it does
08:53:33 <joeyh> anyone have a Setup.hs that uses defaultMainWithHooks and postInst?
08:53:49 <joeyh> the ones I have, that used to work, seems cabal no longer runs my code
08:54:10 <michaelt> augur: I just mean if you already have X installed without profiling, then when you build Y, which depends on X, the profiling build will go wrong. 
08:54:30 <joeyh> oh, a known bug, NM :/
08:54:35 <zoug> I have something like [1,1,1,2,3,6,4] and I need something like [0,3,1,1,1,0,1]
08:54:52 <augur> michaelt: oh, well, i tried compiling with profiling and i got a bunch of errors about packages not having profiling, hence my previous question
08:54:52 <michaelt> augur: so unless you can keep track, it's best to just put "library-profiling: True" in your .cabal/config or in the cabal.config file in a sandbox
08:54:55 <zoug> so counting the number of elements (turn by turn 0 1 etc)
08:55:14 <augur> michaelt: ah! thats good to know!
08:55:18 <michaelt> augur: right, the simplest think is to do it with a fresh sandbox or .cabal
08:55:24 <zoug> that's why I tried "map (length (elemIndices xs)) [0..9]"
08:55:27 <michaelt> the simplest thing , rather
08:56:11 <michaelt> augur: of course, then everything gets built with -prof, which makes things slower, but it's worth it if you do profiling much 
08:56:32 <broma0> hodapp, fair enough. I'm still trying to find my own haskell style and although it's beginning to form, it's not clear to me yet.
08:56:33 <chpatrick> @let counts xs = let cs = M.fromListWith (+) $ zip xs (repeat 1) in map (\n -> maybe 0 (M.lookup n cs)) [0..]
08:56:34 <lambdabot>  .L.hs:153:28:
08:56:34 <lambdabot>      Couldn't match expected type ‘a -> b’
08:56:34 <lambdabot>                  with actual type ‘Maybe Integer’
08:57:07 <augur> michaelt: blegh, start with a new sandbox/.cabal? :(
08:57:14 <chpatrick> @let counts xs = let cs = M.fromListWith (+) $ zip xs (repeat 1) in map (\n -> fromMaybe 0 (M.lookup n cs)) [0..]
08:57:16 <lambdabot>  Defined.
08:57:26 <chpatrick> >counts [1,1,1,2,3,6,4] 
08:57:40 <hodapp> broma0: I wouldn't worry much about finding your own style there.
08:58:26 <michaelt> augur: right, that's what I"m recommending. Else you can uninstall each single library (that's not a ghc boot library) and reinstall all of them. But then you have to think about them... 
08:58:58 <augur> michaelt: is there a reasonable way of going about doing that?
08:59:09 <augur> i mean, making a new sandbox/.cabal
08:59:33 <michaelt> augur: ghc will have come with profiling libraries for the libraries it comes with; likewise the Haskell platform
08:59:51 <augur> ?
09:00:00 <chpatrick> @let counts xs = let cs = M.fromListWith (+) $ zip xs (repeat 1) in map (\n -> fromMaybe 0 (M.lookup n cs)) [0..fst (findMax cs)]
09:00:01 <lambdabot>  .L.hs:156:59:
09:00:01 <lambdabot>      Not in scope: ‘findMax’
09:00:01 <lambdabot>      Perhaps you meant one of these:
09:00:13 <chpatrick> @let counts xs = let cs = M.fromListWith (+) $ zip xs (repeat 1) in map (\n -> fromMaybe 0 (M.lookup n cs)) [0..fst (M.findMax cs)]
09:00:14 <lambdabot>  .L.hs:151:1: Warning:
09:00:14 <lambdabot>      Pattern match(es) are overlapped
09:00:14 <lambdabot>      In an equation for ‘counts’: counts xs = ...
09:00:25 <chpatrick> @unlet counts
09:00:26 <lambdabot>  Parse failed: TemplateHaskell is not enabled
09:00:29 <broma0> hodapp, by style I mean "known solutions to various problems"
09:00:29 <chpatrick> wat
09:00:32 <chpatrick> @let
09:00:33 <lambdabot>  Define what?
09:00:34 <broma0> Like a design pattern
09:00:58 <michaelt> augur: with a sandbox, you just do cabal sandbox delete and start over. After doing cabal sandbox init, you would put library-profiling: True in a "cabal.config" file in the same directory. I can't remember if one is written at the outset. 
09:01:10 <chpatrick> @undefine counts
09:01:10 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
09:01:15 <chpatrick> @undefine
09:01:15 <lambdabot> Undefined.
09:01:19 <chpatrick> @let counts xs = let cs = M.fromListWith (+) $ zip xs (repeat 1) in map (\n -> fromMaybe 0 (M.lookup n cs)) [0..fst (M.findMax cs)]
09:01:20 <lambdabot>  Defined.
09:01:28 <augur> michaelt: ah! thats easy enough then
09:01:29 <chpatrick> > counts [1,1,1,2,3,6,4] 
09:01:31 <lambdabot>  [0,3,1,1,1,0,1]
09:01:33 <chpatrick> finally
09:01:35 <chpatrick> zoug: ^
09:02:59 * hackagebot pgdl 8.3 - simply download a video (or a file) from a webpage and xdg-open it.  https://hackage.haskell.org/package/pgdl-8.3 (sifmelcara)
09:05:35 <broma0> "Is there a common set of design patterns for haskell?" - I always see this question being asked, but the answer is never adequate. The answer I'm calling inadequate is usually some form of "design patterns are an abstraction for monads, and we have monads, so use monads". Can anyone expand on this?
09:06:00 <chpatrick> design patterns are when your language isn't strong enough to express something
09:06:08 <hodapp> broma0: it sounds like you're looking for some sense of what is idiomatic in the language.
09:06:20 <chpatrick> and you need to have it in english instead of code
09:06:24 <broma0> hodapp, I think you may have nailed it
09:06:32 <hodapp> chpatrick: ...I was debating on saying that or not
09:06:35 <broma0> Idiomatic solutions to common architectures?
09:06:36 <tashjash> design pattern is a keyword to say avoid copy/paste
09:06:50 <broma0> Architecture is the wrong word
09:06:59 <chpatrick> design patterns are copy paste though
09:07:05 <chpatrick> if they were code they wouldn't be patterns
09:07:23 <broma0> Idiomatic solutions to common designs?
09:07:38 <augur> michaelt: ahh hmm but, if i just do that _after_ doing cabal sandbox init, how will cabal know to install the profiling parts
09:07:42 <josephle> broma0, that's a good way of putting it
09:08:00 <delcici> it's probably best to think of design patterns as ways to structure a particular solutions
09:08:11 <bergmark> broma0: monad transformers, i'd say
09:08:13 <delcici> copy/pasta avoidance is a side benefit :)
09:09:28 <michaelt> augur: cabal sandbox init just sets things up, it doesn't install anything yet. So then you can put it in a "cabal.config" file in that directory with "library-profiling: True", then do cabal install ... and the installation of whatever will be with profiling
09:09:30 <broma0> bergmark, that's interesting
09:09:41 <augur> aha ok
09:09:58 <michaelt> augur: in fact I have "library-profiling: True" in my main ~/.cabal/config file, so it defaults to that
09:10:12 <nshepperd> I don't know if I'd call it a design pattern, but in haskell it seems like we often use combinators instead of monolithic functions
09:10:28 <broma0> Where is the line drawn between functions of the type b -> A -> A and  b -> AM () though?
09:10:44 <broma0> Monad vs some transform func
09:10:52 <michaelt> augur maybe it will happen if you pass the right options to 'cabal sandbox init'; it would stand to reason 
09:11:20 <broma0> nshepperd, Combinators.. can you elaborate a bit?
09:11:31 <broma0> Different ways of combining arbitrary monads?
09:11:56 <nshepperd> like for parsing we don't usually write a big BNF expression and feed it into a parser generator, instead we build parsers from smaller parsers
09:12:05 <bergmark> broma0: i usually go for a transformer when it becomes too noisy and cumbersome to be without it, which doesn't take long
09:12:54 <nshepperd> 'many' takes a parser that parses one thing, and turns it into a parser that parses as many of that same thing as it can, returning a list of all of them
09:12:59 * hackagebot git-annex 5.20150731 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150731 (JoeyHess)
09:15:33 <catgocat> what error is this:
09:15:34 <catgocat> ghc.exe: panic! (the 'impossible' happened)   (GHC version 7.8.3 for x86_64-unknown-mingw32):         thread blocked indefinitely in an MVar operation  Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
09:15:40 <broma0> bergmark, for example when you're just passing configuration-like arguments? Simply put the configuration in reader?
09:16:05 <chpatrick> catgocat: how did that happen?
09:16:10 <catgocat> don't know
09:16:13 <broma0> bergmark, same for state and infinite recursion with the state as an arg?
09:17:08 <catgocat> chpatrick: I did :load file
09:17:25 <Intolerable> can you lpaste the contents of the file?
09:17:30 <Intolerable> does it happen every time?
09:17:51 <Cale> It would be nice to know if that happens on a newer version of GHC
09:18:31 <catgocat> no
09:18:34 <catgocat> I was in ghci
09:18:57 <catgocat> dunno what happened
09:19:00 <catgocat> now it's fine
09:19:04 <nshepperd> broma0: by 'combinators' I guess I simply mean 'functions that do one small thing'
09:19:19 <zoug> chpatrick: awesome!!
09:19:32 <bergmark> broma0: yes a config reader is probably the most common thing i do, i probably wouldn't use State for just one argument
09:19:32 <chpatrick> zoug: you can make it more efficient but it's more than one line :)
09:19:51 <zoug> chpatrick: this is extra :p thanks
09:19:55 <chpatrick> with toAscList
09:19:56 <broma0> nshepperd, I may have had an epiphany.
09:21:19 <subleq> I can't think of a useful Functor that's not Applicative or Monad
09:23:02 <Intolerable> Map
09:23:34 <mniip> is it
09:23:37 <nshepperd> Const without the monoid constraint
09:23:45 <mniip> is it a functor I mean
09:23:49 <Intolerable> yes
09:24:00 * nshepperd had to try hard to think of that
09:24:23 <Intolerable> fmap show $ Data.Map.fromList [(1,2),(3,4)]
09:24:25 <Intolerable> > fmap show $ Data.Map.fromList [(1,2),(3,4)]
09:24:27 <lambdabot>  Not in scope: ‘Data.Map.fromList’
09:24:37 <Intolerable> > fmap show $ Data.Map.Strict.fromList [(1,2),(3,4)]
09:24:38 <lambdabot>  Not in scope: ‘Data.Map.Strict.fromList’
09:24:42 <geekosaur> just M.fromList I think
09:24:50 <broma0> So, a good style may be to use tiny combinators whenever possible, and when something more is needed, use a transformer stack
09:24:51 <Intolerable> > fmap show $ M.Strict.fromList [(1,2),(3,4)]
09:24:53 <lambdabot>  Not in scope: ‘M.Strict.fromList’
09:24:56 <Intolerable> derp
09:25:01 <Intolerable> > fmap show $ M.fromList [(1,2),(3,4)]
09:25:02 <lambdabot>  fromList [(1,"2"),(3,"4")]
09:25:04 <Intolerable> we did it
09:26:03 <Intolerable> there are a lot more i'm sure
09:26:18 <aweinstock> :t M.fromList [(1,2),(3,4)]
09:26:19 <lambdabot> (Num k, Num a, Ord k) => M.Map k a
09:26:30 <nshepperd> > fmap error (Const 5)
09:26:31 <lambdabot>  Const 5
09:30:23 <humanoyd> I have a program that just hangs and starts using a lot of memory...is there an easy way to tell which function it is currently executing?
09:31:22 <nshepperd> broma0: another example would be the neural network library I am attempting to build right now. Where a library in another language might have a monolithic create_network function with tens of parameters about all the various properties, I felt the idiomatic haskell way would be to define a 'Network a b' type to have inputs a and outputs b, and provide simple small networks together with some combining
09:31:24 <nshepperd> functions
09:31:52 <mniip> ah
09:32:11 <mniip> it's the Set that isn't a functor
09:32:39 <nshepperd> '>>> :: Network a b -> Network b c -> Network a c' for chaining them
09:34:03 <nshepperd> so eg. 'linear >>> sigmoid' is one that first applies a linear function, and then compresses the output. or whatever
09:35:38 <chpatrick> @let type FSet = Coyoneda Set
09:35:39 <lambdabot>  .L.hs:142:13: Not in scope: type constructor or class ‘Coyoneda’
09:35:39 <lambdabot>  
09:35:39 <lambdabot>  .L.hs:142:22:
09:35:42 <chpatrick> aww
09:36:09 <shachaf> That type is scow as a set anyway.
09:36:41 <chpatrick> toSet (Coyoneda f s) = S.map f s
09:37:03 <chpatrick> you could temporarily make a set into a functor
09:37:11 <chpatrick> and then turn it back into a set when you're done
09:37:32 <Intolerable> kan-extensions terrifies me
09:38:15 <shachaf> (fmap expensive . fmap (const x)) bigSet will do a lot more work than necessary.
09:39:24 <mniip> [18:35:47] <Intolerable> kan-extensions terrifies me
09:39:46 <mniip> Maintainer:	Edward Kmett
09:39:46 <mniip> no wonder
09:39:53 <Intolerable> heh
09:40:02 <Intolerable> nah, i can usually manage lens
09:40:13 <glguy> And what's the deal with magnets?
09:40:19 <Intolerable> free i understand
09:40:49 <Intolerable> comonad as well is manageable
09:40:52 <Intolerable> just kan-extensiosn
09:40:54 <Intolerable> *ns
09:43:55 <nshepperd> I want to say "you kan do it"
09:44:27 <nshepperd> ...but the only thing in that package I get so far is codensity
09:45:11 <shachaf> If you get Codensity then surely you can get Yoneda (and Coyoneda).
09:45:17 <shachaf> And Ran.
09:45:31 <Zemyla> Hmm. edwardk, if you are gere, I remember you were going to talk about why supporting (***) :: (??? p) => p a c -> p b d -> p (a, b) (c, d) and (+++) :: (??? p) => p a c -> p b d -> p (Either a b) (Either c d) in profunctors would be problematic?
09:46:01 <shachaf> And if you get all these things as well as convolution, then surely you can get Day convolution.
09:47:12 <broma0> Is there a way to get close to the nirvana of not having any redundancies or inconsistencies caused by haskells history? I think prelude is really the main place where redundancies exist
09:47:30 <broma0> For example having 5 ways to <$>
09:47:36 <Silpheed> I hate to interrupt, but I'm just learning Haskll. In GHCi I go to declare a new function say "factorial :: Integer -> Integer" but I am told factorial is not in the scope. Is there some other way to define it that I should be doing beforehand?
09:48:01 <Intolerable> either
09:48:02 <shachaf> let factorial :: Integer -> Integer; factorial = ...
09:48:04 <Silpheed> I can successfully define it using "let factorial n = ...." followed by the logic but
09:48:05 <broma0> That's a type signature. Have you definite the actual function?
09:48:05 <shachaf> All on one line.
09:48:13 <Intolerable> put it into a file and then :load it into ghci
09:48:24 <Intolerable> or enable multiline with :{ :}
09:48:38 <Intolerable> :{ at the start, :} when you're done
09:50:08 <kadoban> broma0: Stuff like having multiple names for <$> doesn't really hurt anything, just use <$> or occasionally fmap if you want.
09:50:19 <Silpheed> Using shachaf's method, how do I reference the input Integer?
09:50:20 <broma0> Silpheed, I think your issue is you haven't loaded the file
09:50:36 <shachaf> Silpheed: let factorial :: Integer -> Integer; factorial x = ...
09:50:41 <Silpheed> I didn't create a file, I'm trying to define it solely within the interactive mode.
09:51:41 <broma0> kadoban, I know it doesn't hurt, but I'd imagine that if haskell was re-created today, we wouldn't have such redundancies. Would disabling implicit prelude accomplish some of this?
09:51:51 <Silpheed> shachaf, I used that method. So I want to define fac as "if <some incoming number> == 0 then 1 else <some incoming number> + factorial(<some num> - 1)
09:52:20 <Silpheed> so do I jsut establish an arbitrary variable, or am I supposed to reference the incoming integer from the Integer -> Integer definition
09:52:43 <shachaf> The first line is the type, the second line is the value.
09:52:47 <shachaf> No relation..
09:52:50 <shachaf> s/.$//
09:52:57 <shachaf> Same as what you'd write in a file.
09:53:02 <broma0> let f a = if a == 0 then 1 else a * fac (a - 1)
09:53:23 <hodapp> oh dear, a >> (b >> c) != (a >> b) >> c in the monad I made. That's the source of my confusion.
09:53:36 <shachaf> let factorial :: Integer -> Integer; factorial x = if x == 0 then 1 else x + factorial (x - 1) -- but note that this doesn't define the actual factorial function. :-)
09:54:01 <Silpheed> right it's multiplicative
09:54:31 <Silpheed> but typign that out also it tells me that x is out of scope
09:54:45 <Silpheed> oh wait, I forgot the factorial <x> = if... part
09:56:18 <Silpheed> I thought that a type definition is required beforehand? Why can I just say "let fac n = if n == 0 then 1 else n * fac (n-1)
09:56:23 <Zemyla> > fix (\fact n -> if n <= (1::Integer) then 1 else n * fact (n - 1)) 20
09:56:24 <lambdabot>  2432902008176640000
09:56:31 <Zemyla> :t fix (\fact n -> if n <= (1::Integer) then 1 else n * fact (n - 1))
09:56:32 <lambdabot> Integer -> Integer
09:57:19 <isocliff> > let factorial n = product [1..n]
09:57:20 <lambdabot>  <no location info>:
09:57:20 <lambdabot>      not an expression: ‘let factorial n = product [1..n]’
09:58:01 * hackagebot yesod-markdown 0.10.0 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.10.0 (PatrickBrisbin)
09:58:34 <isocliff> @let factorial n = product [1..n]
09:58:35 <lambdabot>  Defined.
09:58:42 <isocliff> > factorial 3
09:58:44 <lambdabot>  6
09:58:55 <Silpheed> even more concise
09:59:05 <kadoban> broma0: If it doesn't hurt anything, what's the point in fixing it? There are problems with Prelude, but … that's not really an important one so …
09:59:07 <Silpheed> but is that one borrowing from a type definition defined by product?
09:59:29 <isocliff> ^ an especially nice definition I think :)
09:59:32 <broma0> kadoban, some of us think we have ocd
09:59:56 <isocliff> :t product
09:59:57 <lambdabot> (Num a, Foldable t) => t a -> a
10:00:12 <broma0> I'd like to get a better understanding of these issues.. do you know of any documentation on them?
10:00:13 <isocliff> Not sure if that helps?
10:00:21 <Silpheed> I'm just confused because my reference material says I should be establishing what types I'm using beforehand, but I've jsut seen multiple different ways to define factorial and the majority of them lacked a verbose type definition
10:00:35 <Intolerable> it's in irc
10:00:48 <Intolerable> noone defines types when it's a one-liner we're feeding to lambdabot
10:01:06 <Intolerable> in source files, everything will have a signature
10:01:06 <Silpheed> I'm using your code in prelude and it works just the same
10:01:16 <isocliff> I also (almost) always make my types explicit too in my source files, its good practice, but yeah no need in irc
10:01:23 <Intolerable> you don't *need* signatures
10:01:29 <Intolerable> but it's a very good habit to get into
10:01:52 <Silpheed> can you have a function that takes a Integer and returns multiple types?
10:02:00 <Intolerable> depends
10:02:02 <Silpheed> like a Double and a char 
10:02:02 <Intolerable> what types?
10:02:22 <Intolerable> i.e. :: Integer -> (Double, Char)?
10:02:29 <Silpheed> something like that, yeah
10:02:30 <kadoban> It can result in (Double, Char), or Either Double Char
10:02:34 <Intolerable> yup
10:02:48 <Silpheed> oh so it's a pair
10:02:49 <Intolerable> put them in a tuple if you want multiple return values
10:02:52 <Intolerable> yes
10:03:10 <Silpheed> ah okay
10:03:31 <mmachenry> In a cabal-managed project, is there a way to get all of the warnings associated with a particular file without building the whole project? I see a ton of warnings flying by. I want to just focus on one file at a time.
10:03:58 <Intolerable> cabal build | grep filename
10:04:20 <kadoban> mmachenry: Point ghc-mod or hdevtools and/or hlint at it?
10:07:44 <mmachenry> hlint won't find warnings
10:07:51 <mmachenry> I tried that.
10:08:09 <broma0> Think classy prelude will ever be the defautl?
10:08:46 <Intolerable> it wont
10:10:57 <broma0> Intolerable, for backwards compatibility sake?
10:11:48 <kqr> also because there's no very compelling reason to
10:12:05 <kqr> well, to some people maybe there is, but not to everyone
10:16:20 <tommd> Certainly no ground-swell of support, which would be necessary for such a change.
10:16:53 <Zemyla> Hmm, if f is an Applicative containing just a fixed number of a (like Pair a = Pair a a), and the instance for <*> is pointwise, then are <* and *> equivalent to const and const id respectively?
10:18:05 <Javran> @hoogle Monoid m => Int -> m -> m
10:18:05 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
10:18:06 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
10:18:06 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
10:18:14 <Zemyla> And a <$ f is equivalent to pure a;
10:18:19 <Javran> @hoogle Semigroup m => Int -> m -> m
10:18:19 <lambdabot> Warning: Unknown class Semigroup
10:18:19 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
10:18:19 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
10:19:18 <Zemyla> Javran: times1p
10:19:49 <trubar1> I don't understand this: a function of type  f :: ∀a. a -> a can only be the identity function: since it must return something of type a, for any type a, the only thing it can do is return the argument of type a that it was given.
10:19:51 <Javran> Zemyla: I see, thanks!
10:19:55 <trubar1> at http://www.well-typed.com/blog/2015/05/parametricity/
10:20:22 <geekosaur> what do you not understand about it?
10:20:37 <trubar1> Are there no operators over any a other than id ?
10:20:47 <Zemyla> trubar1: I give you an argument of type a. You need to give me an argument of that same type a. What can you give me?
10:20:57 <Zemyla> *give me a resilt
10:21:02 <broma0> kqr, from my naive perspective, classy prelude is more "correct" in the sense that it follows best practices and sticks to the most modern class hierarchy
10:21:04 <Zemyla> *result
10:21:11 <geekosaur> what would such an operator do? remember tat we are talking about Haskell; there is no typecase
10:21:12 <aweinstock> :t const undefined
10:21:13 <lambdabot> b -> a
10:21:29 <ttt_fff> in ghci, is there a way to say "clear" ?
10:21:34 <broma0> Ctrl l
10:21:38 <geekosaur> you do not get to introspect the a to see if there is something you can do with it. all you know about it is "a"
10:21:39 <broma0> That's L
10:21:42 <ttt_fff> broma0 ++
10:21:46 <Zemyla> Also, parametricity disregards bottoms.
10:22:03 <broma0> found that out accidentally , then realized it works for psql also
10:22:15 <ttt_fff> when I do ":i blah", it shows data constructors (good) and also instances (bad) ... is there a way to tell ":i" to not show instances ?
10:22:21 <ttt_fff> by instances, I'm referring to typeclasses
10:22:57 <Hafydd> I'd also be interested in a way to do that.
10:23:31 <trubar1> Zemyla: Are there no operators over any a other than id that have a signature a -> a ?
10:24:04 <trubar1> You couldn't say the same for the output of f :: Int -> Int .
10:24:13 <trubar1> f might just be... f = 4
10:24:27 <geekosaur> again, what would such an operator do?
10:24:57 <Hafydd> f :: a -> a; f _ = error "lol"
10:25:06 <Chousuke> :P
10:25:21 <Chousuke> trubar1: you are given a value. you don't know anything about it, and you must return a value of the same type. What can you do?
10:25:25 <Hafydd> Or indeed: f = error "lol"
10:25:41 <trubar1> Chousuke: got it, thanks.
10:27:36 <_cball> I'm pretty new to haskell and FP and I'm liking it a lot! Do places actually hoie haskell sw engineers though? or is this just something i'll only really end up applying in other languages and in personal projects?
10:27:38 <Zemyla> trubar1: So question for you. How many values of type a -> a -> a are there?
10:27:57 <trubar1> 2 :-)
10:28:03 * hackagebot postgresql-config 0.1.0 - Types for easy adding postgresql configuration to your program  https://hackage.haskell.org/package/postgresql-config-0.1.0 (AlekseyUymanov)
10:28:06 <tommd> _cball: Common question.  Yes, there are places that use Haskell in practice.
10:28:08 <trubar1> return either the first or the second argument.
10:28:08 <Zemyla> Excellent.
10:28:28 <tommd> Bluespec, Galois, a few investment firms.  Those are probably the better known places.
10:30:17 <Cale> tommd: Facebook
10:30:47 <_cball> tommd: nice, that's good to know :)
10:31:01 <uruk> I'm getting the following error when attempting to compile darcs: Not in scope: type constructor or class `Int64'
10:31:04 <tommd> Cale: I'm mad at Facebook because I (preceive I hear) less from Marlow now.
10:31:23 <uruk> What may be causing it to appear?
10:31:27 <_cball> maybe after my current position I can find a haskell swe position if I wind up maintaining this much enthusiasm for it c:
10:31:30 <luite> _cball: places typically tell you that they're interested in haskellers and then after a bit more inquiry tell you that they just want to let you do java
10:31:35 <Cale> uruk: import Data.Int
10:31:35 <tommd> uruk: import Data.Int
10:31:40 <Cale> haha
10:31:47 <tommd> At least we said the same thing.
10:31:53 <_cball> luite: oh. that's depressing :c
10:31:54 <uruk> where should that appear ?
10:31:55 <kqr> _cball, i believe most haskell users "just" apply the things they learn to other languages they use professionally, but if you're set on using haskell professionally there are a lot of opportunities
10:32:12 <Cale> uruk: Near the top of whatever file is causing that error
10:32:17 <tommd> uruk: With your imports, top of the module after `Module Foo  where` comes `import Bar`
10:32:41 <Cale> I'm not sure why you'd get it while compiling darcs... presumably it would compile out of the box...
10:32:46 <_cball> kqr: good to know, ty ;)
10:33:02 <Cale> I'll give it a shot right now and see whether I get the same.
10:33:04 <luite> _cball: hehe i was half joking, but haskell has become a bit of a quality label, like the python effect of earlier days, so it does happen
10:33:04 <uruk> yes ; i'm doing it on netbsd, so maybe something is not getting imported by default
10:33:07 <chpatrick> luite: or scala
10:33:41 <tommd> uruk: My guess would be you have an old version of darcs
10:34:15 <luite> chpatrick: if they're one of the more progressive ones i guess, and not google :)
10:35:05 <chpatrick> writing java at google as we speak :)
10:35:39 <uruk> tommd: no, it's 2.10.1; i'm building my own package
10:35:43 <uruk> b
10:35:52 <ely-se> What a wonderful day.
10:36:42 <_cball> chpatrick: really? I'm actually at goog as well! I was going through the grow site and was a little sad to see there wasn't much FP stuff :(  There is a cool lecture series over GVC on purely functional data structures every tuesday now though!
10:37:52 <uruk> ok, seems to compile, but now i'm curious why this pops up : Darcs/Util/Encoding/IConv.hsc:35:1: Warning:     The import of `Int32' from module `Foreign' is redundant
10:38:34 <Cale> uruk: Because now you're getting Int32 from Data.Int as well
10:39:14 <uruk> Is there a way to squash this warning, or it should be assumed to be harmless?
10:39:57 <Cale> It's harmless
10:40:08 <uruk> ok ; thank you very much
10:40:17 <Cale> If there's an explicit import of Int32 from Foreign, you can just remove that
10:40:42 <Cale> Like, if it says something along the lines of   import Foreign (..., Int32, ...), you can just remove it from that list.
10:40:52 <Cale> But it doesn't really matter
10:42:06 <mniip> so typeclasses in haskell are like extensible non-disjoint union types?
10:42:16 <mniip> does that sound right?
10:42:27 <uruk> Cale: there's an explicit import of Int32 from Foreign
10:43:12 <uruk> makes sense now
10:43:34 <roboguy_> mniip: hmm, that doesn't quite sound right to me but what do you mean by non-disjoint union types? (incidentally, I don't generally like thinking of type classes as types. They are classes of types)
10:46:59 <chpatrick> _cball: google is really conservative
10:47:14 <chpatrick> java or c++ from two standards ago
10:47:23 <chpatrick> there's a small haskell conspiracy
10:47:32 <chpatrick> and one team actually using it
10:47:45 <tommd> Are they on the run from management?
10:47:54 <chpatrick> management are engineers
10:47:54 <_cball> chpatrick: small haskell conspiracy? lol :P
10:47:58 <_cball> what team uses it?
10:48:04 * hackagebot lens 4.12.3 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.12.3 (EricMertens)
10:48:12 <chpatrick> https://code.google.com/p/ganeti/
10:48:29 <mniip> roboguy_, like sum types, but untagged
10:48:46 <_cball> woah, I didn't know ganeti was built on haskell!
10:48:52 <chpatrick> partly
10:48:59 <chpatrick> the other half is python :D
10:49:04 <chpatrick> my friend worked on it for a bit
10:49:31 <_cball> that's pretty cool! I'll have to browse through the source a lil 
10:49:50 <mniip> like C unions but without the unsafe ability to access either field. you are only allowed to do operations that make sense for both fields
10:49:57 <_cball> and haha, go figure the other half is pyton ;)
10:50:21 <mniip> s/both/all/
10:50:35 <chpatrick> I'm not sure that's right
10:50:40 <roboguy_> mniip: so there would be a (conceptual) union for a type and the fields would be the type classes?
10:50:44 <chpatrick> typeclasses don't have to have anything to do with values
10:50:56 <chpatrick> they're types such that there are some values that involve the given type
10:51:05 <chpatrick> well there don't even have to be values
10:51:29 <roboguy_> chpatrick: well, they take a type and give you back (a collection of) values
10:52:00 <chpatrick> that doesn't really sound like a union to me
10:52:16 <mniip> roboguy_, no, a typeclass is a union, ad instances are the fields
10:52:30 <chpatrick> you mean a typeclass dictionary?
10:52:33 <roboguy_> I usually think of them more as "properties" of a type. Int has the property of being a Num (that is, you can apply (+) to them, etc)
10:53:04 <roboguy_> mniip: looking at a type class as a dictionary record would probably be easier to think about (it's also how they work internally in GHC)
10:53:34 <mniip> I'm not takling about what typeclasses mean, rather what untagged unions mean
10:54:46 <roboguy_> I'm not sure I understand. You're looking to use type classes to understand untagged unions (rather than visa-versa)?
10:55:08 <ely-se> mniip: in C you can only perform operations on the last-assigned field.
10:55:23 <mniip> a value of type Num a => a is simultaneously an Int and a Float and whatever else might be instantiated as Num
10:55:23 <ely-se> Not operations which are allowed on both fields. Getting it wrong results in undefined behaviour
10:55:52 <ely-se> E.g. "union T { int a; int b; }; T x; x.a = 1; printf("%d", x.b);" has undefined behaviour
10:56:06 <mniip> with it, you can only do things that you can do with any Num's
10:56:20 <roboguy_> here's how I think about it: you have a class like "class Num a where (+) :: a -> a -> a; (*) :: a -> a -> a; ...". You can think of this as a data type: "data Num a = MkNum { (+) :: a -> a -> a; (*) :: a -> a -> a }"
10:56:24 <mniip> ely-se,  that is not the point
10:56:25 <chpatrick> that doesn't make a it a union to me
10:57:03 <chpatrick> it's not polymorphic when it's compiled
10:57:06 <mniip> roboguy_, gosh I know what typeclasses are
10:57:07 <dolio> ∀ is intersection.
10:57:13 <chpatrick> when you put them together it has a concrete type
10:57:24 <chpatrick> so it's a function that can work on any type, not a union of those types
10:57:28 <roboguy_> mniip: then I'm confused... what is the question?
10:58:07 <mniip> whether typeclasses are similar to extensible untagged union types
10:58:35 <mniip> union types in the sense of dual of intersection types
10:58:41 <roboguy_> But you mean that to be a question more about the nature of extensible untagged union types than the nature of type classes?
10:58:49 <mniip> i.e in type theory sense
10:59:52 <roboguy_> (meaning that untagged union types are the thing that you're looking to learn more about rather than type classes)
10:59:53 <dolio> But forall is intersection, not union.
11:00:08 <mniip> roboguy_,  more about the nature of the similarity, I seem to understand both of them correctly, just not sure whether such a comparison is valid
11:00:24 <roboguy_> ah
11:01:02 <roboguy_> dolio: forall is intersection?
11:01:07 <dolio> Yes.
11:01:20 <glguy> and it's not union?
11:01:30 <mniip> dolio, http://i.imgur.com/CODIsnD.png
11:01:31 <dolio> Right. Exists is union.
11:01:32 <roboguy_> hmm, I'm not familiar with the interpretation of quantifiers as union/intersection
11:02:03 <shachaf> I would think of exists as a sum and forall as a product.
11:02:25 <shachaf> But maybe I missed the beginning of the conversation.
11:03:15 <dolio> shachaf: Intersections are products and unions are sums.
11:03:18 <roboguy_> shachaf: the question of the discussion is, what is the relationship (if any) between type classes and (extensible/open) untagged union types
11:03:48 <shachaf> Intersections are pullbacks, but why are they products?
11:05:02 <dolio> They are all part of very similar adjunctions.
11:05:19 <dolio> ∃ ⊣ something ⊣ ∀
11:06:09 <dolio> Σ ⊣ something ⊣ Π, + ⊣ something ⊣ ×, union ⊣ something ⊣ intersection
11:07:05 <dolio> And ∃ and ∀ are infinitary versions of union and intersection in the right semantics, like Σ and Π are infinitary versions of + and ×.
11:07:51 <dolio> ∀a. a is the type whose expressions are the intersection of expressions in all other types.
11:08:18 <phaazon> hi
11:09:15 <shachaf> Makes sense.
11:09:33 <dolio> Int ∩ Float types expressions that are well typed as Int and Float.
11:10:05 <dolio> forall a. Num a => a types expressions that are well typed as all instances of Num.
11:10:32 <roboguy_> so a type class would be something like an "intersection type", in this perspective?
11:10:41 <dolio> forall is the intersection.
11:10:55 <dolio> Type classes cause the intersection to be over fewer types.
11:11:03 <roboguy_> The type class is a predicate on types?
11:11:08 <dolio> Yes.
11:11:13 <roboguy_> ah, that makes sense
11:16:07 <muesli4> Hi, am I correct by assuming that (<|>) for pasec parsers is based on order (therefore not commutative)?
11:17:00 <td123> I'm trying to understand how haskell (ghc specifically) implements Int
11:17:11 <td123> any tips on where to go?
11:17:13 <mniip> [20:06:06] <dolio> ∀a. a is the type whose expressions are the intersection of expressions in all other types.
11:17:20 <mniip> surely that's a union
11:17:26 <td123> I've been able to get this far https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L169
11:17:33 <shachaf> Surely it's not.
11:17:47 <mniip> only operations valid for all types are valid for 'a'
11:17:50 <td123> which defines Int as data Int = I# Int#
11:17:52 <shachaf> td123: What information are you hoping to get?
11:17:58 <kqr> td123, Int is implemented as a machine int in GHC
11:18:02 <shachaf> Int# is a primitive, built into GHC.
11:18:50 <td123> shachaf: I guess I'm trying to figure out how haskell is able to handle the constructors 1,2,3,... in code and interpret them as an Int
11:19:05 <shachaf> :t 1
11:19:06 <lambdabot> Num a => a
11:19:28 <td123> right, so how does it know 1 is a Num a => a?
11:19:37 <roboguy_> td123: it's more to do with Num than Int
11:19:45 <chpatrick> just saw johan tibbell walking around
11:19:50 <dolio> mniip: I can choose to use a ∀a. a as any type I wish, if I have one.
11:19:52 <Zemyla> td123: 1 is defined as fromInteger <some primitive representing 1 as an integer>.
11:19:54 <shachaf> 1 is defined to mean (fromInteger x), where x is the Integer 1.
11:20:11 <dolio> To construct one I may only use constructions that are valid for all types
11:20:15 <catgocat> @pl showBoard xs = concatMap ((:) '|' . show) xs ++ "|"
11:20:15 <lambdabot> showBoard = (++ "|") . (('|' :) . show =<<)
11:20:45 <roboguy_> mniip: there are no values of type ∀a. a. That would be the opposite if it was a union
11:20:46 <Mon_Ouie> muesli4: Yes, ambiguities in the grammar are resolved by taking the first alternative that parses correctly
11:21:09 <td123> so that primitive is built into haskell itself?
11:21:49 <kqr> yes
11:21:53 <shachaf> Yes, it's part of the language.
11:22:04 <dolio> mniip: The thing you linked talked about using T ∨ U, in which case you may only use operations that are valid for both T and U. But that is the same as ∃a. a, where, since I don't know what a is, I may only use operations that are valid for all a.
11:22:06 <roboguy_> mniip: on the other hand, any value can have type ∃a. a
11:22:44 <Zemyla> Hmm, Void could be defined as newtype Void = Void { absurd :: forall a. a }, right?
11:22:52 <shachaf> Yes.
11:23:00 <dolio> This is like: (T ∨ U) -> Z = (T -> Z) ∧ (U -> Z), and (∃ a. a) -> Z = ∀ a. (a -> Z)
11:23:04 <shachaf> dolio: I think when I said forall before I was thinking of Pi.
11:23:17 <td123> ok thanks for your feedback!
11:23:30 <lamefun> Does laziness by default actually improve anything, I mean, eg. https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/Config.hs#L458 - so many strict annotations!
11:23:31 <lamefun> Or https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/Config.hs#L56
11:23:51 <lamefun> Should I just add ! before every type whenever possible?
11:23:57 <dolio> shachaf: Well, sometimes Π is used as an alternate name for ∀. And sometimes it means something that is less like intersection.
11:23:59 <YellowOnion> "∨" looks like a box with 4 zeros in it for me.
11:24:03 <Denommus> lamefun: that's debatable
11:24:49 <hiptobecubic> lamefun, no, sometimes it hurts performance rather than helps.
11:25:07 <hiptobecubic> For me it has been profiling + trial and error. I'm still building intuition about it
11:25:37 <YellowOnion> Whats worse is GHC crashing because it can't print your types to console as cmd.exe still doesn't support unicode!
11:25:39 <roboguy_> YellowOnion: you're probably using a font that doesn't support that symbol
11:25:54 <hiptobecubic> unicode in source code is an abomination
11:26:03 <dolio> shachaf: For polymorphic type theory, you often have semantics where you start with the untyped lambda calculus. Then types denote collections of untyped expressions, so they are subcollections of the collection of all untyped expressions. And that is why ∀ and intersection act like pullbacks.
11:26:39 <shachaf> Well, intersection in set theory is certainly a pullback.
11:26:48 <YellowOnion> roboguy_, its more compicated that than, GTK apps have never fully worked with Unicode on windows.
11:27:14 <dolio> Because they are 'products' on subsets of a canonical set.
11:27:18 <dolio> Not just arbitrary products.
11:27:30 <shachaf> Right.
11:28:05 <shachaf> I'd be surprised if intersection anywhere else wasn't a pullback.
11:28:06 * hackagebot publicsuffix 0.20150731 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150731 (wereHamster)
11:28:49 <roboguy_> YellowOnion: that's frustrating
11:28:51 <lamefun> hiptobecubic, yes, but so does calculating thing needlessly / over and over. I mean, it looks like types are declared lazy by default so that the compiler can then decide where it's OK to not use laziness. Is the compiler so bad at this to warrant putting (!) everywhere as done by stack?
11:29:26 <YellowOnion> roboguy_, infact copy-paste that in to mintty (local putty) and it prints fine (hexchat is using same font).
11:31:16 <mniip> [21:21:43] <dolio> mniip: The thing you linked talked about using T ∨ U, in which case you may only use operations that are valid for both T and U. But that is the same as ∃a. a, where, since I don't know what a is, I may only use operations that are valid for all a.
11:31:26 <mniip> why is that suddenly an "exists"
11:31:36 <mniip> that's a forall
11:31:54 <dolio> No.
11:33:26 <mniip> ooh
11:33:31 <mniip> I think I see
11:33:49 <muesli4> My parsec parser is not terminating, but my language is in LL(1), can someone see what I am doing wrong? http://codepad.org/GqOZSH1z
11:33:54 <mniip> I got confused in co/contravariance
11:34:57 <minad> hi, can someone explain me please how I can transform a tree with syb if I have to transforms a->a, b->b, I can combine them with extT I guess?
11:35:06 <hiptobecubic> lamefun, putting ! can change the semantics, so it can't just decide it's going to do it whenever it wants unless it can prove that that's not the case
11:35:21 <shachaf> minad: Are a and b concrete types?
11:35:24 <hiptobecubic> lamefun, by that I mean you can make programs suddenly not terminate by added strictness
11:35:30 <minad> shachaf: yes
11:35:40 <minad> for example Expr and Stmt
11:36:23 <shachaf> E.g. everywhere (mkT (succ :: Char -> Char) . mkT (pred :: Integer -> Integer)) ('a',20)
11:36:31 <shachaf> Maybe.
11:37:46 <ely-se> @pl \e x -> (e :) <$> x
11:37:46 <lambdabot> (<$>) . (:)
11:38:01 <ely-se> meh, too incomprehensible
11:38:49 <hiptobecubic> i'd rather see  \e -> fmap (e:)
11:39:02 <minad> shachaf: no I want the transforms to be nested
11:39:23 <minad> when i descend a tree structure
11:39:37 <minad> this works also with descendM or descendBiM from uniplate. there it works
11:39:43 <ely-se> hiptobecubic: oh nice!
11:39:45 <minad> but syb - i totally don't get this
11:40:08 <minad> I have to admit that I have real problems with all those extensions that do some automatic derivation and generation of whatever
11:40:18 <minad> this is out of scope of haskell and hard to grasp
11:40:35 <minad> (i mean out of scope of newbie-haskell ;)
11:41:40 * geekosaur tempted to say that if you're working with generics, you're already out of newbie-scope for any language...
11:42:08 <minad> well, if I write it by hand it works. I want it to be generated :)
11:47:24 <augur> hrmph
11:49:32 <catgocat> Can anyone give me some tips on improving this code: http://lpaste.net/137670 ?
11:52:53 <minad> geekosaur: but what if you already used generics in another language. then the bar is a bit higher, isn't it?
11:53:07 <minad> for example java generics :DDD
11:53:51 <geekosaur> I would not say so, that just means you know enouigh Java to do it, not that you know enough to do generics in any language
11:54:18 <catgocat> someone help me improve  http://lpaste.net/137670
11:54:28 <catgocat> how can I make the showBoard function better
11:54:38 <geekosaur> possibly other sufficiently Java-like languages (although IIRC Java generics are kinda different...)
11:54:57 <minad> well they don't have much to do with haskell ;)
11:55:21 <minad> it just seems that one has to read the paper to write syb code
11:55:42 <minad> this I find a bit unusual for a programming language
11:55:58 <chattered> catgocat: In row, I'd use map and intercalate for putting the pipe in between each letter, and then explicitly surround it with "|"s. 
11:58:41 <lpaste_> glguy annotated “boardToStr” with “boardToStr: capture the intersperse pattern” at http://lpaste.net/137670#a137671
12:01:30 <catgocat> chattered: thanks man
12:03:15 <cuddlybacon> I'm getting the following error when trying to compile my program: Could not find module 'Data.Map.Strict' It is a member of the hidden package 'containers-0.5.6.2'. I'm using stack if that matters.
12:03:58 <roboguy_> cuddlybacon: are you using a .cabal file and, if so, do you have containers in the dependency list?
12:05:04 <roboguy_> oh, stack
12:05:59 <cuddlybacon> roboguy_: thanks. I had added it to stack.yaml. foo.cabal slipped right past me.
12:23:28 <subleq> what's the difference between Foldable and Traversable?
12:24:09 <kqr> subleq, traversable means you can store effects in it and execute them in some order
12:24:19 <geekosaur> very roughly, the difference between fold and map
12:24:20 <kqr> subleq, foldable means you can combine all elements to a single value
12:25:00 <shachaf> geekosaur: More like the difference between fold and mapM.
12:25:20 <subleq> but Traversable requires a Functor. Can't you store effects in that?
12:25:29 <subleq> and them fold to combine them?
12:26:01 <shachaf> Foldable is (almost) toListable. toList :: Foldable f => f a -> [a] gives you a list of values.
12:26:22 <shachaf> That's (almost) all you can do with Foldable.
12:27:06 <subleq> so, list is Traversable, and you can get a list from a Foldable, doesn't that mean they're equivalent?
12:27:26 <kqr> sure, but there are things that are traversable but not foldable
12:27:38 <subleq> oh, what?
12:27:42 <kqr> (well I assume that's the idea anyway)
12:28:22 <kqr> things where you can put in effects and execute them, but you can't "take out" the values you've put in again
12:28:32 <chattered> kqr: I think all traversables are foldable.
12:28:47 <chattered> You just use the Constant functor.
12:29:41 <chattered> @type getConstant . traverse Constant
12:29:42 <lambdabot>     Not in scope: ‘getConstant’
12:29:42 <lambdabot>     Perhaps you meant one of these:
12:29:42 <lambdabot>       ‘getContents’ (imported from Prelude),
12:30:22 <Gurkenglas> @type getConst . traverse Const
12:30:25 <lambdabot> (Traversable t, Monoid c) => t c -> c
12:30:35 <chattered> And you want to show an fmap in there.
12:31:08 <chattered> @type \f -> getConst . traverse Const . fmap f
12:31:09 <lambdabot> (Traversable t, Monoid c) => (a -> c) -> t a -> c
12:31:35 <kqr> hm weird
12:32:43 <kqr> then why are they separate things?
12:32:50 <kqr> (warning: might not be thinking very clearly hah)
12:33:05 <Gurkenglas> I'm looking at the https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html laws and they only seem to say that any nonminimal definitions should agree with the defaults. Are there any real laws?
12:33:22 <kqr> not for foldable, no
12:33:24 <chattered> Oh, because it's the other way around. Not every foldable is traversable.
12:33:28 <kqr> that's one of the reasons people dislike it
12:33:44 <subleq> chattered: but you can get a traversable (list) from any foldable
12:33:47 <subleq> so what's the point?
12:33:47 <kqr> chattered, how can they not be, when they implement toList and list is traversable?
12:34:21 <chattered> You can use toList, but now you have a list. How do you get back your original type?
12:34:28 <chattered> @type traverse
12:34:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:34:40 <chattered> On the right hand side, you still have a t. You don't want that to become [].
12:34:43 <kqr> ah
12:34:51 <kqr> yeah that makes sense
12:36:59 <subleq> I guess I just don't see what that's useful
12:37:43 <tommd> > traverse print (Just 45)
12:37:45 <lambdabot>  <IO (Maybe ())>
12:38:09 * hackagebot moesocks 0.1.0.6 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.6 (JinjingWang)
12:38:25 <chattered> subleq: Suppose I want to traverse a tree with side effects. At the end, if all goes well, I still want my tree.
12:38:46 <kqr> subleq, as a more concrete example, a tree of readLine:s
12:38:48 <subleq> chattered: why not convert it to a list, do your effects, and just fmap to get the new tree?
12:38:59 <kqr> subleq, when you're done, you want the strings that was read in from the users in the same tree where you left the readLine:s
12:39:02 <chattered> Because conversion to a list will flatten the tree. I've lost my structure.
12:39:41 <subleq> oh
12:39:49 <subleq> traverse is like fmap with effects?
12:40:11 <chattered> Yeah. It's mapM from Control.Monad.
12:40:36 <chattered> But generalised away from lists.
12:40:50 <subleq> i see
12:41:53 <kqr> and generalised away from monad to applicative
12:41:56 <kqr> I guess
12:42:35 <kqr> isn't mapM and sequence rendered redundant with AMP
12:42:47 <kqr> given that we have sequenceA and traverse that are roughly the same thing
12:57:48 <catsup> is there a name for (maybe (return ())) in a library somewhere?
12:58:21 <aupiff_> is anybody using stack with ghc 7.10.2? is this possible?
12:58:28 <opqdonut> catsup: void?
12:58:36 <opqdonut> :t Control.Monad.void
12:58:37 <lambdabot> Functor f => f a -> f ()
12:59:10 <catsup> no...
12:59:13 <shachaf> opqdonut: The first step should be :t (maybe (return ()) :-)
12:59:18 <catsup> :t (maybe (return ()))
12:59:20 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
12:59:37 <shachaf> :t mapM_
12:59:38 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
12:59:47 <opqdonut> shachaf: ah, right, thought wrong
13:02:49 <catsup> huh!
13:03:51 <catsup> 7.10 ftw
13:04:08 <shachaf> Data.Foldable.mapM_ works before 7.10
13:04:35 <rudi_s> Hi. I'm using attoparsec. Is it possible to get the bytestring of some matched part? I want to extract some data via usual attoparsec rules and also store the original bytestring parts which were used. Thanks.
13:18:11 * hackagebot yesod-bootstrap 0.1.0.0 - Bootstrap widgets for yesod  https://hackage.haskell.org/package/yesod-bootstrap-0.1.0.0 (andrewthad)
13:20:46 <ely-se> Data.ByteString.Lazy.hPut does not attempt to do any encoding or newline conversion, right? It just writes the byte in the bytestring to the file.
13:22:01 <catgocat> I have multiple values that can be either Just .. OR nOTHING
13:22:07 <glguy> rudi_s: Yeah, attoparsec can do that
13:22:11 <catgocat> WHAT'S A COOL WAY TO RETURN THE FIRST OF THOSE VALUES WHOSE VALUE IS NOT nOTHING
13:22:23 <catgocat> sorry for caps ops
13:22:31 <athan> Do monads form monoids over `<> : m () -> m () -> m () ~ (>>)`, `mempty : m () ~ return ()` ?
13:22:37 <johnw> headMay . catMaybes
13:22:42 <rudi_s> glguy: How?
13:22:52 <glguy> It's in the haddock, there's a function for it
13:23:02 <ely-se> catgocat: head . catMaybes
13:23:03 <indiagreen> catgocat: asum (or “fromJust . asum” if you're pretty sure)
13:23:19 <glguy> http://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html
13:23:21 <catgocat> cool catMaybes
13:23:28 <YellowOnion> ely-se, That libary works with bytes so I would hope so.
13:23:29 <johnw> I forgot about asum in this case
13:23:42 <indiagreen> and I forgot about catMaybes
13:23:57 <raichoo> Anyone has some thought on this? https://stackoverflow.com/questions/31754591/are-the-natural-transformations-we-apply-on-coyoneda-to-get-a-functor-actually
13:23:57 <johnw> we will both hide our shame
13:24:11 <indiagreen> by ddosing ircbrowse.net
13:24:25 <indiagreen> there's no other way
13:24:38 <rudi_s> glguy: I checked the docs and didn't find anything. Could you tell me the function name?
13:24:53 <YellowOnion> ely-se, Data.ByteString.Lazy.Char would be more inclined to do Char stuff.
13:24:59 <rudi_s> Ah, match.
13:25:08 <ely-se> YellowOnion: ok, nice.
13:25:31 <hodapp> If I have something like foo { field = value }, is the only way to turn the { field = value } part to a function to wrap it in a function, e.g. (\r -> r { field = value }) ?
13:25:34 <johnw> raichoo: what is the question exactly?
13:25:36 <glguy> rudi_s: Yeah, match looks like it :)
13:25:36 <rudi_s> glguy: I was using an older version (Debian ..) and it seems to be new. Nice, thank you.
13:25:51 <johnw> f a -> Coyoneda f a  is a natural transformation f :-> Coyoneda f
13:25:51 <YellowOnion> ely-se, setting the handle to binary though just in case the OS starts to mess with it :P
13:26:37 <YellowOnion> using par/pseq in IO causes a crash :(
13:26:38 <geekosaur> hodapp, that or one of the lens packages (that was in fact the original inspiration for lenses)
13:26:55 <raichoo> johnw: It's basically the one asked on SO, I wondered if anyone in here had a thought on that.
13:27:06 <johnw> raichoo: I don't really understand the SO question
13:27:14 <raichoo> Ah ok :)
13:27:15 <hodapp> geekosaur: ahh, I see!
13:27:17 <hodapp> geekosaur: thank.s
13:27:19 <hodapp> er. thanks.
13:27:32 <johnw> raichoo: are you asking if f :-> Coyoneda f is a natural transformation?
13:27:42 <ely-se> YellowOnion: I see there's actually writeFile :: FilePath -> ByteString -> IO ()
13:27:43 <raichoo> johnw: So the problem is that Set.toList is used here as something of type NatT.
13:27:44 <ely-se> it opens a binary file
13:28:12 <raichoo> johnw: NatT is supposed to represent a natural transformation which is a mapping between functors f and g.
13:28:29 <johnw> only if it fulfills the laws of a natural transformation
13:28:48 <raichoo> johnw: in this case we have something of type forall a. Set a -> [a] where f is Set and g is [].
13:29:07 <johnw> try: type NatT f g = forall a. (Functor f, Functor g) => f a -> g a
13:29:17 <raichoo> johnw: A natural transformation however is supposed to be a mapping between to functors. Set however is not a functor.
13:29:31 <johnw> is your question "why does GHC let me write this?"
13:29:36 <raichoo> no
13:29:39 <johnw> your type is not restrictive enough to ensure that this is a natural transformation
13:29:57 <raichoo> my question is: what is this thing. It does not really seem to be a natural transformation from what I know.
13:30:06 <johnw> what is "this thing"?
13:30:15 <johnw> Set.toList?
13:30:23 <raichoo> In this case it would be Set.toList yes.
13:30:39 <johnw> so, just to be clear, you're asking what kind of morphism Set.toList represents, categorically?
13:31:11 <raichoo> I suppose that is the question yes.
13:31:26 <YellowOnion> :t pseq
13:31:27 <lambdabot>     Not in scope: ‘pseq’
13:31:27 <lambdabot>     Perhaps you meant ‘seq’ (imported from Prelude)
13:33:19 <johnw> raichoo: I think "unnatural transformation"?
13:33:26 <raichoo> johnw: lol ^^
13:35:18 <raichoo> I'm perfectly fine with GHC letting me write this since it makes sense. However "natural transformation" does not really seem to be the correct term here…
13:35:22 <johnw> i'm not kidding, actually
13:35:37 <johnw> if you search for "unnatural transformation category theory", you'll see it mentioned
13:36:41 <johnw> Set :=> [] is natural for a subset of possible morphisms
13:36:44 <catgocat> I want to take some values which can be Nothing or Just .. and return either Nothing or the first Just ..
13:36:55 <johnw> i.e., if you only talk about bijections on sets, then it's a natural transformation
13:37:12 <johnw> since then fmap f . fmap g = fmap (f . g)
13:37:49 <johnw> I'd have to sit down and work this out though, to figure out when and why it's not natural
13:38:11 * hackagebot th-typegraph 0.23 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.23 (DavidFox)
13:42:45 <catgocat> can anyone help me??
13:43:03 <catgocat> I have multiple maybe values, I want to return the first Just .., or if there aren't any, Nothing
13:43:03 <johnw> catgocat: what's the type of the function you want?
13:43:15 <geekosaur> didn't someone already answer that?
13:43:18 <johnw> i mean, write the Haskell type
13:43:29 <catgocat> johnw: I don't know.. anything useful would work
13:43:36 <catgocat> maybe something like
13:43:46 <catgocat> func :: [Maybe a] -> Maybe a
13:43:53 <frerich> catgocat: I'd try "listToMaybe .  catMaybes'
13:43:58 <johnw> asum
13:44:02 <johnw> :t asum
13:44:03 <lambdabot>     Not in scope: ‘asum’
13:44:03 <lambdabot>     Perhaps you meant one of these:
13:44:03 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
13:44:06 <johnw> :t F.asum
13:44:07 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:44:07 <catgocat> frerich, but what if there are no Just .. values
13:44:17 <frerich> catgocat: Then you'll get Nothing.
13:44:23 <johnw> > F.asum [Nothing, Just 4, Just 5]
13:44:24 <lambdabot>  Just 4
13:44:30 <johnw> > F.asum [Nothing, Nothing, Nothing]
13:44:31 <lambdabot>  Nothing
13:45:10 <johnw> mconcat will do the same thing in this case
13:45:24 <johnw> oh, no it won't
13:45:37 <catgocat> so listToMaybe . catMaybes or asum?
13:45:42 <johnw> asum
13:45:49 <indiagreen> woohoo, asum won
13:45:54 <catgocat> how does asum work though?
13:46:08 <Eduard_Munteanu> asum (x:xs) = x <|> asum xs
13:46:09 <johnw> it's foldr (<|>) empty
13:46:10 <frerich> catgocat: I'd use whatever you're most comfortable with when reading the code.
13:46:27 <catgocat> what is <|> :p
13:46:40 <johnw> choose between Alternative values
13:46:43 <catgocat> don't really know how that works xD
13:46:47 <johnw> it's like Python's "or"
13:47:02 <johnw> > Just 4 <|> Just 5
13:47:07 <lambdabot>  Just 4
13:47:07 <johnw> > Nothing <|> Just 5
13:47:09 <lambdabot>  Just 5
13:47:12 <Eduard_Munteanu> Nothing <|> x = x     Just a <|> _ = Just a
13:47:18 <catgocat> I don't have <|> here
13:47:24 <johnw> import Control.Applicative
13:47:25 <catgocat>  Not in scope: `<|>'
13:56:36 <frerich> I suppose things like product were made part of Foldable for performance reasons? Are there types which actually take advantage of this?
14:00:18 <muyfine> hey, I'm trying to clean up a conduit thing that writes out chunks:
14:00:19 <muyfine> http://lpaste.net/1256692806445957120
14:01:12 <muyfine> I had initially used "=$= CL.map (Chunk . byteString)"
14:01:26 <muyfine> but then I needed to also yield a Flush
14:01:49 <muyfine> is there a more elegant way to compose that?
14:01:57 <muyfine> then what I did in my routine
14:02:58 <catgocat> @pl diag = zipWith (!!) x [0..]
14:02:58 <lambdabot> diag = zipWith (!!) x [0..]
14:03:03 <catgocat> @pl diag x = zipWith (!!) x [0..]
14:03:03 <lambdabot> diag = flip (zipWith (!!)) [0..]
14:04:04 <Gurkenglas> @pl awaitforever $ \chunk -> (yield $ Chunk $ byteString chunk) >> yield Flush -- muyfine
14:04:04 <lambdabot> awaitforever ((>> yield Flush) . yield . Chunk . byteString)
14:04:37 <Gurkenglas> You can replace that big set of brackets with a $ to the right of awaitforever. @pl didn't think of that?
14:05:11 <Cale> Gurkenglas: It doesn't make the expression any more points-free
14:05:39 <Cale> Also, I think that @pl output is worse than the original :P
14:06:08 <Cale> I don't really see what's wrong with the original to be honest
14:06:56 <muyfine> Cale ha, thanks! but is there something like I could alternate the conduit with stuff sent to the (Chunk . byteString) and then yield Flush
14:07:28 <muyfine> like intercalate the chunks with flush's
14:07:32 <indiagreen> Cale: maybe catgocat actually wants to use it in a lambda (and wondered whether it's possible to avoid using a lambda, because lambdas look ugly)
14:08:25 <catgocat> can you guys review this: http://lpaste.net/137679
14:10:13 <Gurkenglas> I wrote a tictactoe-thing recently on lpaste. How can I search it for things I wrote, or generally fulltext-search it?
14:10:33 <Cale> muyfine: Apparently there's this: https://hackage.haskell.org/package/conduit-combinators-1.0.1/docs/Data-Conduit-Combinators.html#v:intersperse
14:11:17 <muyfine> Cale oh nice! I forgot to look in conduit-combinators... let me try that out
14:11:48 <Gurkenglas> catgocat, I'd use find winner instead of asum . map winner
14:11:55 <indiagreen> Gurkenglas: http://lpaste.net/browse?author=Gurkenglas&pastes_page=0
14:12:04 <catgocat> :t find
14:12:04 <Gurkenglas> umm nvm thats wrong lemme think again
14:12:05 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
14:12:12 <catgocat> how does find work
14:12:16 <Gurkenglas> @src find
14:12:16 <lambdabot> find p = listToMaybe . filter p
14:12:53 <catgocat> but winner is not a "filter"
14:13:26 <Gurkenglas> Yes that's why I nvm'd out of that
14:13:38 <catgocat> what is nvm'd ?
14:13:46 <Gurkenglas> nvm = nevermind
14:13:49 <catgocat> 'd ?
14:13:56 <catgocat> please speak english 
14:14:08 <indiagreen> 'd is English
14:14:10 <arkeet> have you never verbed a noun before.
14:14:18 <catgocat> no
14:14:33 <catgocat> so.. find doesn't work for my case
14:14:36 <catgocat> is that what you're saying?
14:14:41 <arkeet> ok, now let's look at the question.
14:14:50 <Gurkenglas> not sure, still thinking, as said above
14:16:06 <catgocat> Gurkenglas: Oh I didn't see your message "umm nvm thats wro.."..
14:16:18 <arkeet> catgocat: I dunno, it looks fine to me.
14:16:19 <catgocat> this is really hard to see messages with everything in black
14:17:06 <Gurkenglas> What client are you using?
14:17:12 <catgocat> webchat.freenode.net
14:18:51 * monochrom talks the talk, walks the walk, crowns the crown, nouns the noun, verbs the verb, and works the work.
14:19:04 <catgocat> so my function is alright? 
14:19:09 <catgocat> that's weird
14:19:29 <Gurkenglas> There's a button in the upper left corner that should have color settings
14:22:47 <ely-se> I just wrote "take 99 filename". I've got 99 problems but the maximum filename length of files in tar archives ain't one.
14:23:42 <Clint> uh-huh
14:28:14 * hackagebot dependent-sum-template 0.0.0.4 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.0.0.4 (JamesCook)
14:32:04 <faobazbar> where are the character classes commen to the `Text.Regex.*` backends documented?
14:32:15 <uruk> the darcs builds successfully on netbsd, but ends with warnings like that /usr/pkgsrc/wip/darcs/work/.buildlink/lib/network-2.5.0.0/ghc-7.6.3/libHSnetwork-2.5.0.0.a(Socket.o): In function `sQhA_info': (.text+0x15933): warning: warning: reference to compatibility socket(); include <sys/socket.h> for correct reference
14:32:31 <uruk> i'd like to get rid of those warnings ; could you please help me to undrestand why those warnings are issued ?
14:44:08 <catgocat> @pl overMsg (Just x) = "Winner: " ++ (showTile x)
14:44:08 <lambdabot> (line 1, column 19):
14:44:08 <lambdabot> unexpected " "
14:44:08 <lambdabot> expecting operator
14:44:18 <catgocat> @pl let overMsg (Just x) = "Winner: " ++ (showTile x)
14:44:18 <lambdabot> (line 1, column 19):
14:44:18 <lambdabot> unexpected "x"
14:44:18 <lambdabot> expecting operator or ")"
14:44:31 <catgocat> what
14:44:51 <catgocat> @pl let overMsg (Just x) = "Winner: " ++ (show x)
14:44:51 <lambdabot> (line 1, column 19):
14:44:51 <lambdabot> unexpected "x"
14:44:51 <lambdabot> expecting operator or ")"
14:46:12 <arkeet> @pl f (Just x) = x
14:46:13 <lambdabot> (line 1, column 13):
14:46:13 <lambdabot> unexpected " "
14:46:14 <lambdabot> expecting operator
14:46:18 <arkeet> it doesn't like patterns in arguments.
14:46:31 <Gurkenglas> overMsg = ("Winner: " ++) . show . fromJust
14:46:51 <arkeet> no don't do that.
14:47:05 <catgocat> @pl isFull xs = and . map (all (/= Empty)) $ xs
14:47:06 <lambdabot> isFull = all (all (Empty /=))
14:47:41 <arkeet> :t all
14:47:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:47:44 <arkeet> :t all . all
14:47:45 <lambdabot> (Foldable t, Foldable t1) => (a -> Bool) -> t (t1 a) -> Bool
14:47:53 <arkeet> :t allOf (folded . folded)
14:47:54 <lambdabot> (Foldable f, Foldable f1, Indexable Int p) => p a Bool -> f (f1 a) -> Bool
14:48:15 <benzrf> :t is
14:48:16 <lambdabot>     Not in scope: ‘is’
14:48:16 <lambdabot>     Perhaps you meant one of these:
14:48:16 <lambdabot>       ‘id’ (imported from Data.Function),
14:48:23 <benzrf> oh wait
14:48:29 <indiagreen> isn't it in Extras?
14:48:30 <indiagreen> :t has
14:48:31 <lambdabot> Getting Any s a -> s -> Bool
14:48:33 <benzrf> isnt there some sort of prismor something that tests equality
14:48:48 <arkeet> yes
14:48:49 <benzrf> needless usage of lens woo
14:49:24 <frerich> catgocat: I think 'isFull xs = Empty `notElem` (concat xs)' would work.
14:49:53 <indiagreen> > 5 ^? only 4
14:49:55 <lambdabot>  Nothing
14:49:55 <benzrf> oh nice
14:50:12 <catgocat> I have a matrix.. and in my game the player gives a row and a col to fill
14:50:18 <catgocat> how can I change the specific element ?
14:50:29 <arkeet> hasn't (folded . folded . only Empty)
14:50:30 <catgocat> since everything is immutable
14:50:46 <benzrf> :t has (fold.fold.below _Just)
14:50:47 <lambdabot>     Couldn't match type ‘Maybe a0’ with ‘Const Any s’
14:50:47 <lambdabot>     Expected type: ((s -> a0) -> Const Any (s -> a0))
14:50:47 <lambdabot>                    -> (s -> Maybe a0) -> Const Any (s -> Const Any s)
14:50:48 <arkeet> catgocat: change the row using a function that changes a column
14:50:57 <benzrf> o.O
14:51:04 <benzrf> oh, folded
14:51:07 <catgocat> can't really do that
14:51:47 <arkeet> @let change _ _ [] = []; change 0 f (x:xs) = f x : xs; change n f (x:xs) = change (n-1) f xs
14:51:49 <lambdabot>  Defined.
14:51:52 <arkeet> > change 2 succ "abcde"
14:51:53 <lambdabot>  <no location info>: can't find file: L.hs
14:51:57 <arkeet> ??
14:51:58 <arkeet> > change 2 succ "abcde"
14:52:00 <lambdabot>  "dde"
14:52:02 <arkeet> oh.
14:52:04 <arkeet> @undefine
14:52:04 <lambdabot> Undefined.
14:52:06 <benzrf> well i suppose below needs traversal
14:52:10 <arkeet> @let change _ _ [] = []; change 0 f (x:xs) = f x : xs; change n f (x:xs) = x : change (n-1) f xs
14:52:11 <lambdabot>  Defined.
14:52:15 <arkeet> > change 2 succ "abcde"
14:52:16 <lambdabot>  "abdde"
14:52:22 <catgocat> arkeet: I was about to implement something like that
14:52:24 <arkeet> > change 2 (const 'z') "abcde"
14:52:25 <lambdabot>  "abzde"
14:52:42 <arkeet> > change 1 (change 2 (const 'z')) ["abcde","fghij"]
14:52:44 <lambdabot>  ["abcde","fgzij"]
14:54:54 <arkeet> > :t index
14:54:56 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:54:57 <catgocat> I need to change from a matrix
14:54:59 <arkeet> :t index
14:55:00 <lambdabot> Ix a => (a, a) -> a -> Int
14:55:01 <catgocat> ..
14:55:06 <arkeet> :t Control.Lens.index
14:55:07 <lambdabot> (Eq i, Applicative f, Indexable i p) => i -> Optical' p (Indexed i) f a a
14:55:09 <arkeet> ok.
14:55:19 <augur> hmm
14:55:57 <augur> mysterious function taking a billion years, strict on all args, all it does is call another function and then apply (++), and the other function has almost no time or alloc cost.. :(
14:56:52 <augur> that (++) must be a pain
14:57:33 <arkeet> > set ((traversed <.> traversed) . Control.Lens.index (1,2)) 'z' ["abc","defg"]
14:57:35 <lambdabot>  ["abc","dezg"]
14:57:36 <aupiff_> is it true that each stackage lts version is bound to a particular version of ghc?
14:57:48 <arkeet> I think so
14:57:53 <catgocat> Why would I use Array instead of list ?
14:58:02 <arkeet> constant time indexing
14:58:05 <mniip> O(1) access
14:58:21 <frerich> The performance doesn't matter at all here.
14:58:24 <frerich> It's the convenient API.
14:58:30 <frerich> He has lists of three elements...
14:58:48 <arkeet> maybe you should use some type of "lists of 3 elements" then
14:59:09 <arkeet> V3 from linear does it
14:59:17 <uruk> never mind on the warning ; it's not a haskell issue
15:08:15 * hackagebot cgrep 6.5.0 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.0 (NicolaBonelli)
15:08:43 <slack1256> If I have two different monad stacks A and B, and I want to use the result of one inside the other. What alternatives do I have instead of using `runA` inside the B stack or using `lift` to generate a combined moand stack?
15:09:19 <slack1256> oh and also avoid using mtl typeclasses to abstract the concrete stack
15:10:27 <ghorn> what order does cabal build modules in?
15:11:47 <Peaker_> slack1256: you could use IO threads if that's applicable. You could use a transformation function from one stack to the other (variant of the `runA` approach)
15:12:48 <nolraiU> Peaker_: IO threads?
15:13:16 * hackagebot cgrep 6.5.1 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.1 (NicolaBonelli)
15:13:36 <lpaste_> Neil pasted “digestive-functors and hpaste” at http://lpaste.net/137684
15:15:01 <Peaker_> nolraiU: perhaps one IO thread can run monad stack A, and communicate with another thread running monad stack B
15:15:10 <slack1256> Mmm I guess running a nice looking transformation function between the stacks (making it explicit) can work well
15:16:56 <catgocat> given a number I want to return a list where the nth element is that number, something like func 1 ==> [0, 1, 0] (the length has to be 3)
15:17:03 <rhovland> any way to get profiling data on a program I kill/interrupt? I keep getting zero-length .prof files
15:17:21 <mgree> What is the preferred way to use literate haskell with markdown (in particular, # characters)? I'm running 7.8.3. I can get it to work with markdown-unlit, but I'd like to be able give this lhs files to other people. Am I hosed?
15:17:44 <Peaker_> catgocat: so only  func 0, func 1, func 2   are valid?
15:17:51 <catgocat> yeah
15:18:00 <Peaker_> catgocat: you can pattern match 3 cases? :)
15:18:08 <catgocat> isn't there a better way?
15:18:36 <Peaker_> catgocat: with lens, you can:  foo x = [0..2] & ix x .~ x
15:18:44 <catgocat> is that chinese
15:18:58 <catgocat> oO
15:19:02 <moop> what's a nice package whose package structure i can cory?
15:19:04 <moop> copy
15:19:16 <Peaker_> catgocat: (&) is just reverse func apply.. feed the list to the function on the right, which is "ix x .~ x"
15:19:24 <Peaker_> catgocat: "ix x" means "at index x"
15:19:38 <Peaker_> catgocat: ".~" is "set the value"
15:19:40 <lpaste_> Neil revised “digestive-functors and hpaste”: “No title” at http://lpaste.net/137684
15:19:48 <catgocat> what is &
15:19:52 <catgocat> and what is "lens"
15:20:03 <moop> lens is a library for object traversal
15:20:07 <Peaker_> catgocat: & is flipped $, apply function where the arg comes first, and then the function
15:20:22 <Peaker_> catgocat: and "lens" is a library with extremely useful but mind-bending ideas :)
15:20:25 <catgocat> can you make it more readable for me?
15:20:36 <moop> catgocat: like, imagine your classic objects in java or c#
15:20:42 <Peaker_> catgocat: foo x = (set (ix x) x) [0..2]  
15:20:54 <mgree> catgocat: f x = [if i == x then 1 else 0 | i <- [0..2]] works fine, too
15:21:06 <mgree> catgocat: and doesn't need any fancy libraries
15:21:06 <Peaker_> > let foo x = (set (ix x) x) [0..2] in foo 1
15:21:08 <lambdabot>  [0,1,2]
15:21:16 <catgocat> mgree nice
15:21:18 <Peaker_> oh sorry, you wanted 0's
15:21:29 <Peaker_> > let foo x = (set (ix x) x) (replicate 3 0) in foo 1
15:21:30 <lambdabot>  [0,1,0]
15:21:54 <moop> catgocat: lens just allows us to look into data structures in a more convenient way
15:22:06 <catgocat> I am a beginner though
15:22:19 <Peaker_> catgocat: the list comprehension is easier then I guess :)
15:22:33 <johnw> moop: the actual use of a data structure is not necessary
15:22:34 <Peaker_> catgocat: I've transformed to think in lens now :)
15:22:47 <Peaker> Some say "lens" is a different language to Haskell, and I agree, it's a better one :)
15:22:51 <moop> johnw: yeah i'm just trying to explain lenses in classic oop  style
15:22:53 <johnw> moop: you could have a "seconds" lens onto a UNIX time-since-the-epoch value
15:23:09 <Peaker> (and it has great inter-op to Haskell!)
15:23:16 * hackagebot kademlia 1.1.0.0 - An implementation of the Kademlia DHT Protocol  https://hackage.haskell.org/package/kademlia-1.1.0.0 (fro_ozen)
15:24:37 <moop> catgocat: so imagine a huge class that has things like Obj.SomeProp.SomeOtherProp.SomeVal[index].Bleh
15:25:18 <moop> lenses allow us to do all the traversal through haskell 'objects' in a more concise way
15:25:31 <moop> tho weirder way because it has weird syntax
15:29:04 <nolraiU> I don't find the syntax at core weird.
15:29:19 <nolraiU> Just has a lot of opperators.
15:30:45 <Lokathor> ghci exists!
15:30:46 <Lokathor> on arm!
15:30:50 <djbeau> Peaker, moop: do you find any advantages to lens outside of using them for nested structures?
15:30:51 * Lokathor dances
15:31:43 <johnw> djbeau: are you familiar with Traversal?
15:31:52 <djbeau> johnw: yes
15:31:52 <moop> djbeau: can't say, not a real haskell master yet
15:32:01 <catgocat> How can I make this better: http://lpaste.net/137688
15:32:17 <johnw> djbeau: and you know how Traversal only lets you traverse over the last type parameter?  I.e., if you have a Foo a b, you can traverse over the 'b'
15:32:27 <djbeau> I really ask because I find myself using lens for a lot of things and am wondering when it is "too much" :P
15:32:27 <o`connor> Is there a reason that some function "liftIOE :: (MonadIO m) => IO a -> ExceptT SomeException m a" isn't included in ExceptT?
15:32:49 <catgocat> @pl fillTile xs = zipWith (zipWith ($)) zipFns xs
15:32:49 <lambdabot> fillTile = zipWith (zipWith id) zipFns
15:32:53 <johnw> so, another use of lens that has nothing to do with nested structures is that you can traverse over any type variable that you have a Traversal for
15:33:20 <johnw> this way you can build a tool box for working with complex types
15:33:34 <johnw> for example, I wrote a few traversals for manipulating Hoopl nodes and graphs
15:33:35 <catgocat> Can anyone make an edit? http://lpaste.net/137688
15:34:44 * djbeau still trying to make sense of the phrase "you can traverse over any type variable that you have a Traversal for"
15:34:51 <johnw> Foo a b
15:34:57 <johnw> I want to 'traverse' over the 'a'
15:34:58 <johnw> how?
15:35:05 <johnw> with Traversable, you can't do it
15:35:12 <johnw> but with a Traversal (Foo a b) a, you can
15:35:14 <Peaker> djbeau: I use lens for everything :)  Almost every type can be viewed as a "nested structure", so I'm not sure about your question
15:35:20 <djbeau> oh I see - you used 'b' in your first example :)
15:35:26 <johnw> yeah
15:35:40 <johnw> or if I have a type where some of the constructor don't have 'a' at all
15:35:43 <djbeau> or rather, said "Traversal" when you really meant "Traversable"
15:36:12 <johnw> then I could use a Prism to manipulate values that do have one
15:36:19 <Peaker> You can also traverse over some of the type which isn't associated with any type variable (or perhaps associated with multiple type variables)
15:36:41 <johnw> yes, true!
15:36:50 <johnw> the 'a' could be entirely synthetic
15:36:51 <djbeau> makes sense to me - I find myself using lens for standard types anyway and I almost feel guilty
15:36:55 <johnw> like Traversal ByteString Word8
15:37:05 <catgocat> Peaker: http://lpaste.net/137688
15:37:09 <Peaker> djbeau: I have projects where I avoid lens ("beginner-friendly")
15:37:13 <djbeau> heh
15:37:19 <Peaker> djbeau: but for my "real" projects, I use them with no remorse :)
15:37:20 <johnw> or a utf8 traversal Traversal ByteString Char
15:38:23 <djbeau> johnw: to your point, I find 'each' useful
15:38:52 <djbeau> as well as Cons/Snoc
15:39:22 <Peaker> catgocat: with lenses, you can do: fillTile row col tile = set (ix row . ix col) tile
15:39:37 <catgocat> but I want to do it on my own
15:40:10 <Peaker> catgocat: then you can also write a function:  nth :: Int -> (a -> a) -> [a] -> [a]   (to change the nth element of a list)
15:40:22 <catgocat> but I just use it once
15:40:29 <Peaker> catgocat: then:  nth row (nth col (const tile))
15:40:39 <Peaker> catgocat: or: (nth row . nth col) (const tile)
15:40:47 <catgocat> what
15:41:01 <Peaker> catgocat: which part are you asking about?
15:41:26 <catgocat> I want to improve my solution while maintaining readability without using other libraries
15:41:28 <Peaker> catgocat: I'm offering a simpler alternative to the zipWith/zipWith/list-comprehension thing
15:41:43 <catgocat> can you make an edit to the lpaste?
15:41:46 <Peaker> sure
15:43:04 <Peaker> catgocat: http://lpaste.net/137688#a137690
15:43:43 <y> I would actually just use lens, I mean, nth :: Int -> (a -> a) -> [a] -> [a] ; nth n f xs = xs & ix n %~ f (I think?)
15:43:46 <catgocat> wish I was as good as you xDDD
15:43:49 <catgocat> that's excellent
15:43:58 <y> > [1,2,3,4] & ix 3 %~ (*3)
15:43:59 <lambdabot>  [1,2,3,12]
15:44:22 <Peaker> y: he doesn't want lens
15:44:36 <catgocat> Peaker: that's a reallyyy smart solution
15:44:44 <y> yes, I said I would actually use it
15:45:15 <Peaker> catgocat: it's pretty much the same thing as using "ix" from lens but "ix" is much more generalized/powerful than "nth"
15:46:01 <Peaker> catgocat: Kind of obsoleted by lens, but if you read this: http://conal.net/blog/posts/semantic-editor-combinators <-- it can enlighten about this kind of approach.  Encourages using (nth row . nth col) (const tile) instead of what I wrote
15:46:03 <y> it'd be even look a bit nicer because you could hide the `const tile` with %= :P 
15:47:25 <faobazbar> getAllTextMatches ("#$2h}" =~ "[0-9a-zA-Z]+") :: [String]
15:47:27 <Peaker> Understanding: http://conal.net/blog/posts/semantic-editor-combinators  really helps with understanding lens, IMO
15:47:33 <Lokathor> haskell platform on windows now includes msys2 as well. Today is just my day in haskell-land it seems
15:47:36 <faobazbar> getAllTextMatches ("#$2h}" =~ "[:alnum:]+") :: [String]
15:47:42 <faobazbar> shouldn't these two return the same thing?
15:48:04 <faobazbar> one uses the class [:alnum:] and the other spells it out with [0-9a-zA-Z]
15:48:39 <faobazbar> per docs at https://hackage.haskell.org/package/regex-tdfa-1.2.0/docs/Text-Regex-TDFA.html
15:48:49 <catgocat> Peaker: I made an edit but doesnt work http://lpaste.net/137688
15:49:29 <Clint> faobazbar: you need to put a collation class in brackets
15:49:31 <catgocat> ops nevermind
15:49:34 <catgocat> it needs to be a function
15:50:41 <faobazbar> Clint: collation class?
15:51:03 <Clint> faobazbar: when restricted to ASCII, [[:alnum:]] is the equivalent of [0-9a-zA-Z]
15:51:17 <faobazbar> ah..
15:51:26 <Clint> and [:alnum:] is the equivalent of [:almnu]
15:52:08 <faobazbar> Clint: `getAllTextMatches ("#$2h}" =~ "[[:alnum:]]+") :: [String]` it worked!
15:52:09 <faobazbar> thank you
15:52:16 * Clint nods.
15:52:34 <faobazbar> Clint: is there somewhere it's documented that these pre-built character classes require an extra set of brackets?
15:53:56 <catgocat> @pl fillTile row col tile = insertAt row (insertAt col (const tile))
15:53:56 <lambdabot> fillTile = (. ((. const) . insertAt)) . (.) . insertAt
15:53:58 <Clint> faobazbar: probably in any comprehensive regex documentation
15:54:17 <y> catgocat: fillTile row col = insertAt row . insertAt col . const 
15:54:40 <catgocat> it's already curried
15:55:07 <Peaker> @hoogle insertAt
15:55:07 <lambdabot> No results found
15:55:08 <catgocat> but works great
15:55:08 <faobazbar> huh, my bad.
15:55:11 <faobazbar> thanks
15:55:13 <faobazbar> :)
15:55:14 <catgocat> y: thanks
15:55:15 <Peaker> catgocat: what's insertAt?
15:55:20 <catgocat> it's nth
15:55:37 <y> I wouldn't call it `insertAt`, it's not inserting anything
15:55:46 <Peaker> catgocat: confusing name!
15:55:52 <catgocat> why confusing ?
15:55:58 <catgocat> it's seams clearer to me
15:56:04 <Gurkenglas> I might have found a bug in lambdabot's @check? I'm pretty sure it isn't supposed to expose internals
15:56:04 <Gurkenglas> @check \f w@(x :< y) -> (x :< f (hoistCofree f <$> y)) == (unfold (extract &&& (f . unwrap))) w
15:56:06 <lambdabot>  No instance for (Typeable f0)
15:56:06 <lambdabot>  (maybe you haven't applied enough arguments to a function?) arising from a u...
15:56:10 <Peaker> catgocat: but it applies a given function to the nth element. How is that related to "insert at" ?
15:56:27 <Gurkenglas> http://lpaste.net/137692
15:56:39 <catgocat> Peaker: it inserts the function at the index
15:56:59 <Peaker> catgocat: it *applies* the function, it does not insert it
15:57:10 <catgocat> and how is nth clearer?
15:57:14 <catgocat> nth doesn't tell anything to me
15:57:35 <Peaker> catgocat: there's a convention (of semantic editor combinators) to name SECs according to the "position" they lift a function to edit
15:58:01 <catgocat> what convention
15:58:12 <Peaker> catgocat: it makes a composition read like a path:  nth x . nth y . result . argument ...   means: inside xth element, inside yth element, inside the func result, inside the func arg, do this and that
15:58:21 <catgocat> ok then
15:58:25 <Peaker> catgocat: read http://conal.net/blog/posts/semantic-editor-combinators
15:58:37 <catgocat> also, where do I put my helper functions? putting them inside the game files seems bad
15:58:45 <Peaker> (though know that lens is a newer better way of doing the same)
15:59:08 <Peaker> catgocat: That kind of function would go into a module like: Data.List.Utils or such
15:59:25 <Peaker> catgocat: Data.List.modifyNth <-- would you prefer that name?
15:59:35 <Peaker> (Data.List.Utils.modifyNth that would be)
15:59:55 <catgocat> I am still not aware of modules like that
15:59:59 <shachaf> Verbs aren't good names for pure functions.
16:00:03 <catgocat> so how do I create a module inside Data.List.Utils
16:00:19 <Peaker> shachaf: "Data.List.sort" ?
16:00:43 <shachaf> Not ideal, I think, but you can forgive them because it's short.
16:00:45 <shachaf> You write length xs, not getLength xs.
16:00:48 <Peaker> catgocat: you make a file path: Data/List/Utils.hs with a module header "module Data.List.Utils (exports...) where ... "
16:00:55 <shachaf> (length xs) is a value which is the length of xs.
16:01:02 <Peaker> shachaf: What about Control.Lens.set? 
16:01:19 <shachaf> (set l x s) is s, with l set to x. :-)
16:01:35 <Peaker> so, modifiedNth? :)
16:01:44 <shachaf> I don't think "don't use verbs" is a universal rule.
16:02:22 <catgocat> Peaker: but you said Data.List.modifNth
16:02:34 <catgocat> so Data.List.Util or ModifyNth ?
16:02:35 <shachaf> But people usually err on the other side.
16:02:37 <Peaker> catgocat: that was a mistake, it would collide with already existing Data.List
16:02:54 <Peaker> catgocat: the module name has to not collide, so Data.List.Utils would be the module name, inside it you'd ahve "nth" or what not
16:03:05 <Gurkenglas> https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Comonad-Cofree.html#hoistCofree <- Does some free theorem say that, if g is a Functor, then it doesn't matter whether one hoists bottom-up or top-down?
16:03:20 <catgocat> Peaker: so every function that would have something to deal with lists, I would put there?
16:03:25 <catgocat> and then import as Data.List.Utils (..)
16:03:33 <Peaker> shachaf: btw, maybe you know a good lens-y equivalent to conal's inO2/etc?  something that lets you apply a binary function under an iso?
16:03:42 <Peaker> catgocat: yeah
16:03:44 <shachaf> inO2?
16:03:51 <shachaf> There is under.
16:04:00 <catgocat> Peaker: but can't I make directly into .List? Something like Data.List.MyFunc
16:04:01 <Peaker> shachaf: inO2 :: (a -> b -> c) -> O a -> O b -> O c
16:04:06 <shachaf> Oh.
16:04:14 <shachaf> No, I wish I knew a good solution.
16:04:24 <shachaf> I spent some time trying to figure it out and not getting anywhere.
16:04:47 <Peaker> catgocat: Data.List is taken, you can't add functions to an already existing module (except for editing it)
16:04:55 <catgocat> oh I see
16:05:13 <Peaker> shachaf: maybe <$>/<*>-like operators for Isos ?
16:05:20 <Peaker> (though those depend on the ability to type-change)
16:05:40 <shachaf> A good solution should work for more than just Iso.
16:05:56 <catgocat> Peaker: and if I create a path Data/List/Utils.hs why do I need to add the module header "module Data.List.Utils" and not just "module Utils2
16:06:07 <Peaker> shachaf: not sure what it would mean for e.g: lenses
16:06:08 <catgocat> s/2/""
16:06:12 <catgocat> "*
16:06:40 <Peaker> shachaf: you can extract to the binary function easily, but how do you construct the final value as the "t" type (and not the "b" type)?
16:06:57 <shachaf> There are some other types that it would be meaningful for, if I remember correctly.
16:07:10 <Peaker> catgocat: so the module name is always full/absolute, I guess for simplicity/greppability/locality-of-readability
16:07:31 <catgocat> and do I make it .Util
16:07:32 <catgocat> or .Utils
16:07:42 <Peaker> catgocat: you can make it .CatGoCat :)
16:08:18 * hackagebot tidal 0.5.3 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.5.3 (AlexMcLean)
16:09:33 <catgocat> how can I write this better: all (all (Empty /=)) ?
16:09:40 <catgocat> too much parentheses
16:10:01 <catgocat> @pl isOver xs = all (all (Empty /=))
16:10:01 <lambdabot> isOver = const (all (all (Empty /=)))
16:10:07 <catgocat> wt
16:10:23 <catgocat> @pl isOver xs = all (all (Empty /=)) xs
16:10:23 <lambdabot> isOver = all (all (Empty /=))
16:12:37 <catgocat> Peaker: if I am defining a module do I need to import dependecies, still if the main file imports it ?
16:12:45 <catgocat> s/it/them
16:18:06 <mgree> catgocat: yes. each file/module needs to import everything it needs
16:25:47 <catgocat> damn I hate if expressions
16:25:51 <catgocat> so ugly
16:28:27 <Cale> catgocat: You always have the option to use guards instead
16:28:34 <catgocat> not inside do blocks
16:28:44 <Cale> catgocat: Sure, just use case
16:28:56 <catgocat> same thing :p
16:29:00 <Cale> hm?
16:29:02 <catgocat> as ugly as if
16:29:04 <catgocat> xD
16:29:18 <Cale> Well, the nice thing about guards is that you don't have the nesting.
16:29:25 <catgocat> if the function arguments are too long, how can I break them ?
16:29:28 <Cale> If there are a lot of conditions
16:30:24 <Cale> Oh, also see the MultiWayIf extension
16:30:45 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if
16:30:50 <catgocat> Cale: if I have a function call stuff (......) (.......) and the parameters are too long, how can I break them?
16:30:54 <catgocat> line break doesnt compile
16:31:07 <Cale> Just make sure the subsequent line starts in a deeper column
16:31:21 <Cale> So that it's a continuation of the previous line and not a new statement in the do-block
16:32:23 <catgocat> Cale: how can I read the getLine in a "val <- getLine" statement?
16:32:32 <catgocat> do I need to make a let expression?
16:32:39 <catgocat> or can I do it there
16:33:00 <Gurkenglas> Why does https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html#v:hoistCofree need a (forall x. f x -> g x)? Wouldn't a (f (Cofree g x) -> g (Cofree g x)) suffice?
16:33:21 <Cale> catgocat: You can use fmap
16:33:26 <Cale> fmap read getLine
16:33:32 <catgocat> <- fmap read getLine ? 
16:33:38 <Cale> yeah
16:33:43 <catgocat> nice
16:36:15 <Cale> Gurkenglas: Sure, that would work.
16:37:15 <Cale> Gurkenglas: As in, that's what the inferred type for that code would be.
16:37:52 <Gurkenglas> Does strictly generalizing a type signature like that make the second or only the third version number go up? (Because removing them increments the second, and adding new ones the third)
16:38:01 <Cale> I suppose the point of hoistCofree is that you can lift a natural transformation from f to g to being a natural transformation from Cofree f to Cofree g though.
16:39:14 <Gurkenglas> That sounds like it should require Functor g too
16:40:02 <catgocat> @pl inRange x = x >= 0 && x <= 2
16:40:02 <lambdabot> inRange = liftM2 (&&) (>= 0) (<= 2)
16:40:02 <nolraiU> I thought free and cofree were the same thing..
16:40:25 <catgocat> Cale: if I read as an integer, if the user enters a double or some other incorrect value how can I handle that?
16:40:55 <nolraiU> dont use "read".
16:41:14 <Cale> nolraiU: A cofree functor is one which is *right* adjoint to a forgetful one.
16:41:40 <Cale> catgocat: Use reads instead
16:41:44 <catgocat> reads ? 
16:41:54 <catgocat> :t reads
16:41:55 <lambdabot> Read a => ReadS a
16:42:06 <Cale> > reads "3.45" :: [(Integer, String)]
16:42:08 <lambdabot>  []
16:42:15 <Cale> > reads "3" :: [(Integer, String)]
16:42:16 <lambdabot>  [(3,"")]
16:42:24 <catgocat> so how can I check if the input is valid?
16:42:30 <catgocat> if the list is empty, it's invalid? 
16:42:34 <Cale> right
16:42:39 <catgocat> are you sure?
16:42:41 <catgocat> 100% sure
16:42:55 <Cale> and the second part of the pair should be empty, given that the parser should have consumed all the input
16:42:58 <Gurkenglas> nolraiU, a free node carries either its underlying type or its functor of more nodes, while a cofree node always carries both
16:43:20 <Cale> I believe all the Prelude instances of Read will only ever give you at most a single element list, and the second part of the pair there will be empty.
16:44:40 <Cale> catgocat: You should probably pattern match against (x,""):_ for the successful case, and then treat everything else as a parse failure.
16:44:44 <nullvoid8> > reads "1 1 1" :: [(Integer, String)]
16:44:46 <lambdabot>  [(1," 1 1")]
16:44:53 <catgocat> Cale yeah
16:45:00 <nullvoid8> so maybe not quite ?
16:46:08 <Cale> nullvoid8: That's right...
16:46:56 <nullvoid8> Cale: ... I may need to improve my reading skills, just ignore me
16:47:08 <Cale> No, you're right, I was unclear there :)
16:50:30 <Gurkenglas> Is there some way to apply full text search to all public lpastes?
16:52:00 <catgocat> Cale: I have finished my game, can you review it
16:55:35 <geekosaur> Gurkenglas, lpaste is indexed by google
16:55:45 <geekosaur> I do site:lpaste.net searches on it all the time
16:56:06 <Gurkenglas> Oh, okay, thanks.
16:56:06 <Gurkenglas> Why is there unfold :: Functor f => (b -> (a, f b)) -> b -> Cofree f a, but not fold :: Functor f => (a -> b) -> (f b -> b) -> Free f a -> b?
16:56:48 <Zemyla> Gurkenglas: runF . toF.
16:57:01 <Zemyla> From Control.Monad.Free.Church.
16:57:38 <johnw> Gurkenglas: there's iter, when a ~ b, but maybe a PR is in order
16:59:32 <benzrf> :q
16:59:37 <benzrf> fuck why did i expect that to work
17:00:07 <bitemyapp> benzrf: vim causes dementia
17:00:13 <Xe> benzrf: if you type in /quit nickhere it will make that person quit from IRC fwiw
17:00:55 * glguy wonders if that works for /part also. Any guess, Xe?
17:01:04 <Xe> yep
17:01:11 --- mode: ChanServ set +o glguy
17:01:15 <glguy> neat!
17:01:21 <Xe> lol
17:01:27 <benzrf>  /quit Xe
17:01:29 <benzrf> oops
17:01:38 --- mode: glguy set -o glguy
17:01:45 <demize> glguy: remove is nice, yes. ;)
17:02:35 <voidzero> +++ATH0
17:05:48 <AjaxCrixum> Is it possible to learn Haskell as a first language with LYAH? Or is that something that isn't recommended, with Haskell being so insanely difficult (or so I've heard)?
17:06:37 <MarcelineVQ> it's not reccomendedc, not because haskell is difficult but because LYAH doesn't have exercises
17:06:55 <geekosaur> LYAH is not really the best Haskell learning resource. no exercises and people tend to come away able to read Haskell but not write it
17:07:04 <MarcelineVQ> check out https://github.com/bitemyapp/learnhaskell  for good starting spots
17:07:05 <geekosaur> @where learnhaskell
17:07:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:07:08 <geekosaur> heh
17:07:17 <geekosaur> @quote antiphony
17:07:17 <lambdabot> No quotes match. Sorry.
17:07:18 <geekosaur> bah
17:08:12 <catgocat> @pl isOver xs = all (all (/= Empty)) xs && whoWon xs /= Nothing
17:08:12 <lambdabot> isOver = ap ((&&) . all (all (Empty /=))) ((Nothing /=) . whoWon)
17:13:27 <pavonia> AjaxCrixum: I think Haskell is only difficult for people who started learning programming with an imperative language. If you start with Haskell and learn other languages afterwards, you'll probably use better coding techniques in these languages, too
17:17:39 <catgocat> geekosaur: can you review my tictactoe game?
17:17:47 <catgocat> I just finished the LYAH book and decided to make a game
17:18:00 <Hafydd> That's what LYAH does to you.
17:18:21 * hackagebot sync-mht 0.3.4.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.4.0 (emink)
17:19:46 <AjaxCrixum> Cool! So, like most programmers on StackOverflow say learning Haskell made them better programmers, by learning Haskell first, which is easier for beginners, I would develop good coding techniques and habits that I could take with me to other languages? Seems like Haskell is one of the best first languages. :)
17:28:41 <Gurkenglas> catgocat, (Nothing /=) === isJust
17:28:56 <catgocat> not in scope
17:29:04 <Gurkenglas> Gotta import it from Data.Maybe
17:29:11 <benzrf> AjaxCrixum: i dont think id put it that way
17:29:20 <catgocat> I won't import it just for using it once
17:30:42 <Gurkenglas> ap also has to be imported. (I'd use liftA2 in this case, though.)
17:32:17 <AjaxCrixum> Programmers say that they pick up great habits and stuff from Haskell. If I start from Haskell, I'll already pick up all of the perks and will be able to take them to other languages, right?
17:33:00 <Zemyla> If you start from Haskell, all other languages will be like dust and ashes in your mouth.
17:33:39 <benzrf> i mean
17:33:41 <benzrf> arguably
17:33:47 <AjaxCrixum> Zemyla: What? :P
17:33:47 <mzero> But, yes, AjaxCrixum, you will have a much clearer view of the meaning of programming
17:33:55 <benzrf> AjaxCrixum: propaganda, it is
17:34:25 <Zemyla> Yep. :P
17:35:13 <AjaxCrixum> Is Haskell a good langauge to help with program design and problem solving skills?
17:35:25 <mzero> yes
17:35:27 <Zemyla> It is.
17:36:07 <cita> AjaxCrixum: It's a good language to have. It's quite different than procedural languages.
17:36:38 <lamefun> Why is monomorphism restriction error message the worst error message ever? Is it going to be fixed in next GHC?
17:36:57 <catgocat> Gurkenglas: can you review my game?
17:37:08 <Gurkenglas> catgocat, sure!
17:37:17 <pavonia> lamefun: What error message?
17:37:19 <catgocat> I'll make a lpaste
17:37:49 <lpaste_> catgocat pasted “TicTacToe” at http://lpaste.net/137694
17:37:52 <lpaste_> lamefun pasted “Worst error message ever” at http://lpaste.net/137695
17:37:52 <catgocat> http://lpaste.net/137694
17:37:58 <catgocat> Gurkenglas: there ^
17:38:04 <lamefun> pavonia, ^
17:38:05 <AjaxCrixum> And the program design/problem solving skills picked up from the language *are* tranferable? (I ask because I know that Haskell is completely different than other languages, being 'purely functional' and all.)
17:38:15 <lpaste_> catgocat pasted “Utils” at http://lpaste.net/137696
17:38:32 <mphelan> names #haskell
17:38:40 <catgocat> Gurkenglas: Utils > http://lpaste.net/137696 TicTacToe > http://lpaste.net/137694
17:38:42 <Zemyla> lamefun: There's a reason it's called the Dread Monomorphism Restriction (caps necessary).
17:39:26 <lamefun> Zemyla, it doesn't seem to dreadful, but the error message is the worst error message ever. Is there a fundamental reason why it can't be better?
17:39:27 <Zemyla> AjaxCrixum: Some of them are. You can't use nifty things like hole-driven development though.
17:39:55 <lamefun> Ie. it seems like something coming from a bugged compiler, instead of a genuine error message.
17:41:47 <MarcelineVQ> interesting https://www.youtube.com/watch?v=52VsgyexS8Q
17:41:50 <catgocat> Gurkenglas: what do you think ?
17:42:39 <Gurkenglas> catgocat, I'm gonna play HLint and show a lot of little details I would have done differently
17:42:47 <catgocat> sure
17:43:03 <Gurkenglas> Though the bottom of that lpaste already has HLint itself give you a few hints, the second and third of which I already approve of, though the first only gets rid of one all, hmm.
17:43:22 * hackagebot breve 0.4.0.0 - a url shortener  https://hackage.haskell.org/package/breve-0.4.0.0 (rnhmjoj)
17:44:30 <catgocat> I didn't see the hints though
17:44:32 <Gurkenglas> type Board = Compose [] [] Tile (importing Data.Functor.Compose ( https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html )) will give you a foldable instance for the whole board, allowing you to just do all (/= Empty) or even notElem Empty
17:44:32 <catgocat> cool
17:46:26 <Gurkenglas> I don't like that you have a gameLoop function that calls itself. I would handle the looping behavior in the main loop (which then could probably be reduced to a few words) and have gameLoop become gameStep or something
17:47:08 <osa1> does anyone know why cabal is failng with "rejecting: blah-1.2/installed-0c9 (package is broken)" even if I use --force-reinstalls?
17:47:11 <catgocat> I have never done a game before
17:47:18 <catgocat> feel free to make the annotation
17:47:28 <Gurkenglas> Neither have I! :D
17:47:41 <glguy> osa1: force reinstalls are a good way to get broken packages in the first place
17:47:57 <Gurkenglas> Well except that very hacky "command line"-NIM implementation I put into lambdabot once. Can probably be found via ircbrowse.
17:48:46 <Gurkenglas> I don't approve of your notion of "Don't import stuff if you only use it once" notion and will ignore it in my annotation :P
17:50:07 <osa1> glguy: sometimes you have to use it, like in my case. we have a number of packages that we don't upload to hackage yet. the way I develop is I register all the packages in a sandbox. in our dependency tree I'm updating the package in the root, I have to do --force-reinstalls and that's exactly what I want to do.
17:50:19 <catgocat> sure
17:50:30 <glguy> osa1: You can always unregister the stuff that causes a force reinstall
17:51:00 <osa1> glguy: I'm doing that right now. the question is I can't see why cabal is failing.
17:51:18 <osa1> glguy: ghc-pkg unregister is also annoying in that it doesn't allow multiple package arguments :)
17:51:48 <glguy> osa1: You can use https://github.com/glguy/GhcPkgUtils , it does, and it will recursively unregister packages for you , too
17:51:56 <glguy> gotta run!
17:53:44 <osa1> that package looks useful. I was about to open a feature request for ghc-pkg for 1) recursively unregistering packages 2) allowing multiple packages as arguments
17:56:33 <ReinH> osa1: btw it's trivial to set up an internal hackage server
17:57:28 <osa1> ReinH: does that solve our problems? I think cabal would still fail with weird errors as long as we keep using sandboxes.
17:58:32 <catgocat> Gurkenglas: I need to go, is there any how you can show me the code later, or send it to my email?
17:59:56 <ReinH> osa1: I just got here so I'm not sure what your problem is. :) I thought it might help.
18:00:05 <Gurkenglas> @tell catgocat He will tell me to tell you.
18:00:05 <lambdabot> Consider it noted.
18:00:19 <catgocat> what did you just do
18:00:31 <Gurkenglas> I told him to tell you "He will tell me to tell you."
18:00:43 <ReinH> Well, if you're using a sandbox you can always nuke it from space and start over.
18:00:47 <catgocat> ok see you tomorrow
18:00:48 <AjaxCrixum> How can you do something as big as game development in Haskell?
18:00:55 <AjaxCrixum> I thought it was an academic language?
18:01:19 <Gurkenglas> By making the game take <100 lines of code :D
18:01:20 <ReinH> Well, it isn't.
18:01:35 <osa1> ReinH: that's what we do all the time, unfortunately :)
18:01:42 <bitemyapp> if Haskell is an academic language, where's my post-doc?
18:01:51 <bitemyapp> I've been ripped off, I'm writing normal business code in Haskell.
18:01:58 <ReinH> The game dev story isn't very good, but people do use languages for things other than game dev.
18:02:22 <AjaxCrixum> You can make a game in Haskell <100 lines long? No way.
18:02:32 <bitemyapp> Pretty much no game dev story that isn't C++ or C# by way of Unity is good, but you can make Haskell work for game dev if you're not making a AAA.
18:02:43 <ReinH> bitemyapp: Yeah, I guess all that time I spent building systems to ship and run haskell code in production was some sort of fever dream?
18:02:49 <bitemyapp> and the latter (C# by way of Unity) is p dubious with something complicated anyway.
18:02:59 <bitemyapp> ReinH: we must've shared the same fever dream.
18:03:04 <bitemyapp> ReinH: maybe it's mass hysteria.
18:03:08 <bitemyapp> well typed hysteria.
18:03:50 <AjaxCrixum> Can someone help me with Haskell's indentation system?
18:04:09 <AjaxCrixum> I keep running into errors when I indent.
18:04:23 <ReinH> @google haskell layout
18:04:24 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
18:04:39 <mzero> AjaxCrixum: every single facebook page view goes through code written in Haskell - I wouldn't call that academic
18:05:03 <mzero> As for indent - never use tabs - that is, set your editor to turns tabs into spaces
18:05:23 <bitemyapp> for my part, I just had to remember the offside rule and I was okay.
18:05:30 <bitemyapp> but I never mixed spaces & tabs anyway.
18:06:15 <AjaxCrixum> Any config command for Vim to turn tabs into spaces?
18:06:31 <mzero> use  :expandtab to turn on the mode
18:06:39 <mzero> and  :retab   to fixup a file
18:06:43 <mzero> (I think)
18:06:53 <mzero> also   :set sw=4 ts=4   is useful
18:07:04 <mzero> (sets the shift width and the tab stops to 4
18:07:13 <ReinH> :set expandtab
18:07:17 <ReinH> is what youw ant
18:07:22 <ReinH> oh mzero said that
18:07:36 <mzero> no, I forgot the :set on that one
18:07:38 <mzero> :-)
18:07:43 <ReinH> AjaxCrixum: for vim you might like https://github.com/begriffs/haskell-vim-now
18:07:49 <ReinH> mzero: oh right
18:15:04 <AjaxCrixum> Can I just use gedit, instead of vim, or is vim better for Haskell coding?
18:15:23 <bitemyapp> AjaxCrixum: use whatever is comfortable. gedit can be configured not to use tabs.
18:15:39 <MarcelineVQ> i use atom, anything is fine
18:15:50 <MarcelineVQ> there's even a haskell ide if you want one
18:16:09 <MarcelineVQ> http://www.leksah.org/download.html
18:19:27 <AjaxCrixum> I just went on ahead and started with the cis194 course
18:23:24 * hackagebot reflex 0.3 - Higher-order Functional Reactive Programming  https://hackage.haskell.org/package/reflex-0.3 (RyanTrinkle)
18:23:26 * hackagebot reflex-dom 0.2 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.2 (RyanTrinkle)
18:29:23 <AjaxCrixum> Is reading really faster with your finger?
18:30:00 * AjaxCrixum is reading the cis194 course
18:30:34 <nolraiU> Only if you are bad at reading.
18:30:42 <hpc> or if your book is braille
18:31:20 <nolraiU> Your eye's focus can move a lot faster and more acurately then your finger can, though really thats the point.
18:31:28 <nolraiU> Of using your finger I mean.
18:31:36 <hpc> yeah
18:31:45 <hpc> it's the same thing with "voice reading"
18:31:58 <hpc> it takes more time to sound it out in your head than it does to just get the meaning of the words
18:32:08 <nolraiU> Well..yes.
18:32:31 <nolraiU> But most fluent readers have the sound there too...sort of.
18:32:36 <hpc> and then you get into skipping over "the", "he", "she", etc
18:33:12 <nolraiU> Bad idea in math papers.
18:33:20 <hpc> heh
18:33:26 <nolraiU> They write those super dense.
18:33:40 <hpc> there's still bits you can skip, but it's a totally different rhythm
18:34:01 <hpc> and it's mostly going to be just preamble and stuff from other papers
18:35:02 <AjaxCrixum> I'm pretty bad at reading (vocalizing words in my head, losing track), so, using my finger *will* help me?
18:35:20 <hpc> and when the bottleneck is comprehension anyway, you might as well use reading the whole thing to pace yourself
18:36:17 <hpc> AjaxCrixum: probably, but you should try and get out of that habit
18:36:54 <AjaxCrixum> hpc: Vocalizing words or using my finger?
18:37:10 <hpc> both, but one at a time
18:38:20 <hpc> you'll find that a lot of your time is spent reading in programming, and getting a function definition into your head faster makes it easier to keep a train of thought
18:38:41 <hpc> (not to mention irc)
18:39:05 <hpc> though apparently a lot of people never learn to stop vocalizing, so maybe it's not that important?
18:39:41 <AjaxCrixum> I've seen 'skim-vocalizing' before.
18:39:46 <nolraiU> Oddly I don't vocalize code.
18:39:48 <nolraiU> Like even hear it at all.
18:40:01 <nolraiU> Even though I do math.
18:40:04 <hpc> i can't remember ever vocalizing written words
18:40:36 <hpc> i can if i want to, but it always comes after i have read it
18:40:45 <nolraiU> Intersting.
18:40:56 <hpc> i also read very fast
18:41:24 <nolraiU> I have dislexia but also I high IQ, and they exactly cancel out.
18:41:28 <hpc> comes in handy with looking at production server maillog
18:41:47 <nolraiU> And reading speed is not the isue for me in programing.
18:42:01 <nolraiU> Or at least not like text reading speed, if that makes sense.
18:42:29 <hpc> you can read it, but not put it together
18:44:13 <hpc> do you ever read code by shape?
18:44:28 <broma0> What is the deal with mtl vs transformers? Is mtl a necessary layer on top of transformers if all we need is a concrete transformer stack? What's beneficial about mtl over just transformers?
18:44:38 <hpc> like, this function gets really indented all at once so it's doing something in a grid
18:44:58 <hpc> broma0: they're different implementations of the same concept
18:45:05 <hpc> transformers was first, then mtl
18:45:24 <shachaf> hpc: That's not true.
18:45:34 <hpc> oh, huh
18:45:34 <broma0> shachaf: do explain
18:45:47 <Gurkenglas> If I have a monad transformer stack with MaybeT in it, is there a quick way to construct a value corresponding to Nothing without knowing the exact structure of the stack?
18:45:53 <shachaf> I think the descriptions on Hackage explain.
18:45:58 <shachaf> https://hackage.haskell.org/package/transformers and https://hackage.haskell.org/package/mtl
18:46:11 <shachaf> transformers gives you the transformers. mtl gives you classes.
18:46:19 <hpc> ah, right
18:46:20 <shachaf> mtl depends on transformers, so they're hardly competitors.
18:46:56 <hpc> i might be mixing that up with the zillion pipe libraries
18:47:00 <broma0> shachaf: i see.. so mtl tries to tackle this idea of extensible effects using transformers as a foudation?
18:47:32 <Gurkenglas> Like, what do I use in place of a MonadMaybe class?
18:49:41 <yashinbasement> oh wow, 1418 people 
18:50:00 <yashinbasement> just started haskell
18:50:19 <yashinbasement> anyone from melbourne Uni here ,just asking 
18:50:37 <MarcelineVQ> eh? how do you know who's starting?
18:51:17 <yashinbasement> oh no because there is a link to freenode in the lec notes who wants to ask questions
18:51:56 <MarcelineVQ> oh you're saying you just started, not 1418 people just started haha
18:52:06 <yashinbasement> yeah
18:52:10 <yashinbasement> sorry about that
18:52:51 <yashinbasement> so guys do we use haskell professionally ?
18:53:38 <yashinbasement> I am learning it because it's quite useful to learn , to have more understanding about programming
19:00:25 <broma0> yashinbasement: I certainly dont (at least yet), but I know facebook does
19:00:40 <broma0> yashinbasement: there's a wiki page about haskell in the industry
19:00:59 <broma0> https://wiki.haskell.org/Haskell_in_industry
19:01:28 <yashinbasement> thanks dude
19:02:22 <broma0> np. coolest thing ive used professionally is Clojure
19:04:16 <Adeon> yashinbasement: I use haskell professionally at an internet advertisement company
19:04:42 <Adeon> I control heavy data processing jobs and threads with it and have some web UIs in it
19:04:51 <yashinbasement> oh wow
19:05:25 <yashinbasement> well after all this is most efficient language
19:05:53 <broma0> Adeon: how well does it withstand constant hacking & work by different devs (idk how large the team is)?
19:06:16 <broma0> Adeon: the clojure codebase i work on doesn't do so well in that department
19:06:48 <broma0> im talking aesthetics and idiomacy 
19:07:15 <Adeon> I'm the only one working on the haskell code
19:07:19 <Adeon> the individual projects are small
19:07:24 <broma0> Adeon: well then im sure it does well
19:07:47 <Adeon> things are oriented around files that are fetched and pushed by different things
19:07:54 <Adeon> so there are like 10000 languages being used around the company
19:08:26 <broma0> Adeon: That's cool. It must be nice owning the entirety of your projects 
19:10:41 <Zemyla> Adeon: How well does it handle sitting for long periods of tine without leaking memory?
19:11:07 <Adeon> well aside from one project that very slowly seems to leak memory I haven't had problems
19:11:14 <broma0> What do you (anyone) think about a list Zipper defined as 'Zip [a] [a]
19:11:23 <broma0> vs 'Zip [a] a [a]'
19:11:25 <Adeon> very slowly as in it takes one month to leak 100 megabytes
19:12:00 <Adeon> the memory heavy things are in C and C++, haskell coordinates them
19:14:04 <Zemyla> Yeah. I sometimes have problems because I've got a lazy reference to something or other.
19:14:27 <nolraiU> broma0: It can handle the empty case.
19:15:26 <broma0> nolraiU: I guess they both can if i extend the latter to 'Zip [a] a [a] | Empty'... i remember reading somewhere that 'Zip [a] a [a]' is technically more "correct" due to it being a comonad or something
19:15:33 <broma0> haven't gone into those just yet
19:17:42 <broma0> What's so useful about comonad anyway?
19:21:21 <bitemyapp> Adeon: hello fellow Haskell-advertisement-persom
19:21:38 <Adeon> -away
19:21:40 <Adeon> er
19:21:54 <Adeon> bitemyapp: nice to meet you fellow advertisement lord
19:22:10 <Adeon> I wonder if we are competitors
19:22:36 <bitemyapp> Adeon: maybe. Are you multiplexing demand sources so publishers don't have to integrate with them directly?
19:22:57 <Adeon> someone might be but that would be outside the work my team does
19:23:23 <Adeon> I think we are
19:23:38 <Adeon> I'm so far in the backend I don't always know what exactly our users see
19:23:51 <Zemyla> Or you could be in the same company.
19:24:07 <c_wraith> broma0: It's not *as* useful as monad.  But I've still written code where I've looked at a type signature and gone "hey, wait.  That's Comonad extend"
19:24:25 <Adeon> no I'm pretty sure I would know if someone used haskell somewhere else in the company
19:24:28 <bitemyapp> Zemyla: that seems unlikely.
19:24:40 <bitemyapp> Zemyla: my company is a small startup. I know everybody in our company.
19:25:04 <Adeon> my company is a few hundred people
19:25:27 <bitemyapp> Adeon: what libraries & infra do you use?
19:25:36 <Adeon> for haskell or in general
19:26:03 <Adeon> we use s3, git and erlang quite a bit
19:26:48 <bitemyapp> Adeon: what databases?
19:27:01 <Adeon> postgres and a custom one tailored for our data
19:54:22 <hackrilege> hi
19:56:54 <hackrilege> suppose i have [a], [(b,i)] and i wish to apply (snd(filter f::(b->Bool)).fst) to get the index and then do [[a]!!i for all such i]
19:58:17 <hackrilege> is there a faster way to do this than zipping the [a] with [(maybe b,i)] where Nothing if i was not present in the original list, and then filtering?
19:58:30 <Zemyla> :t first
19:58:31 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:58:36 <hackrilege> i.e. is !! faster than zipping and filtering?
19:59:00 <Zemyla> hackrilege: !! is slow, and non-total.
19:59:10 <Zemyla> Avoid it whenever possible.
19:59:44 <hackrilege> if i use a lens i will get better idea of the access time i guess...
20:00:01 <Zemyla> If you use !!, you'll have to traverse the list every time.
20:00:16 <hackrilege> so how do i get fast lookup?
20:00:37 <Clint> don't use a list
20:00:57 <hackrilege> im making a structure more like a tree anyway...
20:01:05 <Zemyla> Use an array, vector, or sequence.
20:01:09 <hackrilege> thanks
20:01:33 <hackrilege> any preference?
20:01:47 <geekosaur> or if you're using a tree-like structure, consider Data.Map or Data.HashTable
20:01:54 <geekosaur> (or variants such as Data.IntMap if appropriate)
20:02:00 <Zemyla> Vector, because indexing is less bullshit, and access is O(1).
20:02:49 <hackrilege> thanks
20:03:45 <hackrilege> its kind of a multiply linked list. i have a collection of objects, i wish to be able to concatiate several of these collections into one with a specified rule. which class it this?
20:04:00 <geekosaur> HashMap not HashTable. HashTable's the old one that went away because it was annoying and slow
20:04:29 <hackrilege> is a list a hashtable?
20:04:55 <hackrilege> hashmap*
20:05:52 <hackrilege> maybe im asking if it is traversable? im not sure what properties of the list im really after...
20:06:50 <hackrilege> concatinnation  as links to identified elements
20:07:29 <Zemyla> I wonder if there's anything interesting to say about functors where a <$ b = pure a.
20:08:18 <hackrilege> "place one point of each f 4 traingles at the corners of a square, draw a line from each exposed corner of this new shape to a point"
20:08:31 <hackrilege> of*
20:09:27 <hackrilege> so my objects are squares triangles and lines or collections of these...
20:10:07 <hackrilege> i have a list of shapes, and concatination rules such as "join to each corner"
20:10:30 <hackrilege> its a tree right?
20:10:33 <Hijiri> Zemyla: that they don't have structure?
20:10:59 <Hijiri> actually maybe that's not true
20:11:34 <Hijiri> well maybe it is, I can't think of anything other than Identity where that holds for all b
20:11:51 <hackrilege> i want to be able to identify a point as "the corner of a square" so i maybe have a string label indicating such joinable poinnts
20:12:09 <Zemyla> Hijiri: data Pair a = Pair a a.
20:12:27 <hackrilege> does this make any sense? i can stop if this is going nowhere...
20:12:42 <Hijiri> that works, guess I was wrong
20:12:44 <Zemyla> Or any structire that holds a fixed number of elenents and nothing else.
20:12:54 <Zemyla> (Also, Proxy :P)
20:13:16 <Hijiri> functions would work too, then
20:13:37 <Hijiri> fixed number of elements = size of the input type
20:13:39 <hackrilege> ok sorry
20:13:57 <hackrilege> thanks for hashmap
20:14:16 <Zemyla> Hijiri: So anything that's isomorphic to r -> a?
20:14:46 <Hijiri> looks like it
20:14:50 <hackrilege> i was wondering about which properties a list had. is the operator (:) overridable to make an instance of some class
20:15:12 <geekosaur> no
20:15:26 <Zemyla> hackrilege: Nope, it's a constructor. It can't ne overridden.
20:15:28 <hackrilege> is there something else that is like that?
20:15:43 <hackrilege> i want to construct things
20:15:44 <geekosaur> the closes you get to that is there's an overloaded lists extension that can be used to turn a list into something else
20:15:54 <hackrilege> but they are not lists i dont think
20:15:58 <Hijiri> if you want an infix constructor you can have a contructor starting with :
20:16:11 <Zemyla> :t (<|)
20:16:11 <Hijiri> @let data B = Char :- B
20:16:12 <hackrilege> though they can be inconviniently stored as lists, but probably are cyclic trees
20:16:12 <lambdabot> Cons s s a a => a -> s -> s
20:16:12 <lambdabot>  Defined.
20:16:14 <geekosaur> but there are limits to that as well since you can't change the basic behavior of a list (for example that all elements must be the same type)
20:17:11 <hackrilege> i can make lists of datatypes storing more than one type e.g. Either
20:17:22 <Hijiri> isn't a tree acyclic by definition? unless you mean the underlying representation has cycles
20:17:52 <hackrilege> i thought recursive data definitions in haskell permited cyclic trees?
20:18:19 <geekosaur> I think there's mathematics going onere. "tree" vs. "graph"
20:18:24 <geekosaur> *going on here
20:18:26 <Zemyla> Haskell does, but then it's not a tree.
20:18:34 <hackrilege> its a graph actually
20:18:40 <sgronblo> whats the most likely way i installed ghc-mod on osx if its in /Users/sam/Library/Haskell/bin/ghc-mod
20:18:43 <hackrilege> my thing
20:19:05 <geekosaur> sgronblo, cabal as configured by a haskell platform install
20:19:29 <Zemyla> hackrilege: Have you looked at the Data.Graph library?
20:19:33 <sgronblo> geekosaur: ah yeah now it makes sense, i must have checked cabal info yesterday in a directory with a sandbox without realising it. thanks.
20:19:42 <hackrilege> its not a tree its a cyclic tree
20:20:13 <hackrilege> data.graph, thanks
20:20:29 <geekosaur> if it has cycles, it's not a tree, it's likely a directed graph
20:20:40 <geekosaur> speaking mathematically
20:20:45 <hackrilege> not directed
20:21:03 <geekosaur> then how is it a tree?
20:21:05 <hackrilege> but yeh, anyway i cant see how a graph cannot be represented as a cyclic tree...
20:21:14 <Hijiri> I never knew containers had a Graph module
20:21:26 <hackrilege> um, it is a linked collection of objects.
20:21:38 <Zemyla> Because trees don't have cycles. That's part of the definition of a tree.
20:22:28 <hackrilege> its not a tree, its a cyclic tree
20:22:32 <geekosaur> ...
20:22:53 <Hijiri> why call it a tree if it's not a tree
20:23:06 <geekosaur> hackrilege, you are in a channel devoted to a language that draws much of its inspiration from mathematical structures. mathematically, "cyclic tree" is an oxymoron
20:23:15 <hackrilege> http://link.springer.com/chapter/10.1007%2F3-540-16492-8_108
20:23:35 <hackrilege> be sure
20:24:20 <hackrilege> Hijiri: perhaps that is the question
20:24:24 <Hijiri> is there a definition of "cyclic tree" not behind a paywall
20:24:39 <hackrilege> sorry...
20:25:00 <Hijiri> if it's only mentioned by that one article, it might not be a widely-used term
20:25:06 <hackrilege> https://wiki.haskell.org/Tying_the_Knot
20:25:21 <pjakobsen> Hi folks, I wonder if this is the right channel to ask questions about cabal problems on OS X? 
20:25:41 <geekosaur> you can ask, no guarantee that someone is around that can help
20:25:44 <benzrf> :allears:
20:25:46 <Hijiri> hackrilege: if you define a tree recursively it's still a tree
20:25:52 <geekosaur> #hackage might be another place to ask, but also not guaranteed
20:25:59 <Hijiri> you can't observe that underneath it's implemented by pointing to itself
20:26:23 <hackrilege> still a tree. now has cycles
20:26:36 <pjakobsen> I'm new to Haskell, and after day 2, I'm already hearing about "cabal-hell"  - does it still exist, or is it old news?
20:26:52 <hackrilege> no cabal is fine
20:27:04 <Hijiri> the cycles are an implementation detail, for semantic purposes it's a tree (and acyclic)
20:27:10 <geekosaur> to some extent it will always exist because of how ghc optimizes its packages/libraries
20:27:11 <Hijiri> and actually I have to go now
20:27:11 <hackrilege> infact its super awesome, better than pip
20:27:13 <pjakobsen> hackrilege: Ah, maybe I'm reading old blog posts
20:27:34 <benzrf> it exists, pjakobsen 
20:27:37 <benzrf> and it is h e l l
20:27:43 <geekosaur> there are a couple of tools exploring the space of working around ghc's oddnesses
20:28:16 <hackrilege> pjakobsen, if there is a bug we spot it and fix it pretty fast, so just pop back if there are any problems, there should not be. but you can link the article to get a seccond oppinion
20:28:17 <pjakobsen> benzrf: So maybe I should come back to haskell in, say, 2017? ;)
20:28:23 <geekosaur> cabal and stack both seem to have things that confuse them, although stack seems to have fewer (but also has additional requirements around its stack.yaml file)
20:28:55 <pjakobsen> geekosaur: stack, never heard of it... see, I told you I wuz a newbie 
20:29:04 <geekosaur> pjakobsen, maybe you can invent an optimization technique that works, isn't whole-program compilation, and isn't cross-module inlining
20:29:11 <hackrilege> Hijiri: thanks for your help. im sorry the tying the knot article had confused me, i get what you are saying, its just a very repetative infinite tree representing a cyclic graph...
20:30:04 <hackrilege> pjakobsen, they oly told me about stack the other day iv been using cabal for years, and as stack is distributed via cabal, i think cabal is still the parent tool
20:30:08 <pjakobsen> geekosaur: well, given that my degree is in art history, I don't think I'm the right person for that task. 
20:30:08 <geekosaur> cabal's still trying not to take the only reliable workaround for ghc, which is build every conceivable combination of packages/versions so that something can be found that will work in all cases
20:30:31 <geekosaur> (stack effectively took that route, in a lazy fashion)
20:31:02 <hackrilege> wow, crazy approach...
20:31:21 <pjakobsen> Thanks for your help, much appreciated :)
20:31:39 <geekosaur> well, stack builds stuff and remembers it so it can import already built stuff into a sandbox it's managing, as I understand it. (oversimplifying a bit)
20:32:41 <geekosaur> cross-module inlining kinda limits what you can do sanely :/ unfortunately not doing cross-module inlining (either via whole-program compilation or ghc's exporting of internals for inlining) has rather severe performance costs
20:33:39 <geekosaur> (jhc does the whole-program compilation route. it is however less complete than ghc)
20:34:08 <broma0> I just cabal install'd hlint on Arch Linux and im having trouble finding the program.. has anyone ran into this issue?
20:34:44 <broma0> ha
20:34:49 <broma0> i installed it to a sandbox accidentally
20:35:45 <Zemyla> geekosaur: Is JHC compiling to the JVM?
20:36:10 <geekosaur> not last I heard
20:36:13 <hackrilege> i dont like how compilers are complicated. it seems like they should be the thing we learn to implement first...
20:36:57 <broma0> hackrilege: agreed. we probably don't because their a fraction of the industry.. and 99 percent of devs wont ever need to write one
20:36:57 <Zemyla> hackrilege: You implement them late because they are legitimately complicated.
20:37:08 <geekosaur> hah. compilers sit at the interface between clean comprehensible programming languages and hardware that is often designed to be easily implemented rather than easily programmed
20:37:26 <broma0> although i have a compilers class coming up where we write one for some BS lang
20:38:03 <hackrilege> geekoshar: far from it, most of the time we compile to run on a virtual machine with a convinient api
20:38:05 <Zemyla> broma0: I advise you to look up Parsec and Attoparsec now rather than later.
20:38:35 <geekosaur> if you think the jvm is convenient, you haven't done anything other than java on it :)
20:39:08 <hackrilege> i mean like jtag or something
20:39:17 <dolio> geekosaur: And probably haven't done Java either?
20:39:31 <geekosaur> jvm has some rather oddball instructions that make sense in the context of java, less so for other languages --- and many of java's limitations stem from a desire to not extend the jvm instruction set
20:40:02 <broma0> Zemyla: advice related to my impending class?
20:40:16 <hackrilege>  mean we have a simple set of read and write memory opperations
20:40:30 <geekosaur> certainly you could switch virtual machines, but clr has similar restrictions and attempts to make more general virtual machines tend to not go well (see for example Parrot)
20:40:49 <adino> geekosaur: "if you think the jvm is convenient, you haven't done anything other than java on it" Haha! :D
20:40:57 <hackrilege> its not like we have to move the electrons, they give us an api
20:41:09 <broma0> Uncurry is a cool function.
20:41:15 <geekosaur> sigh, if only read-memory and write-memory were sufficient.
20:41:17 <Zemyla> broma0: What language would you be writing it in?
20:41:20 <geekosaur> they were once upon a time.
20:41:31 <geekosaur> then people wanted machines that were fast, instead of machines that were simple
20:41:51 <hackrilege> lol, and some logic. finito
20:42:12 <hackrilege> so we have accelerate cuda...
20:42:14 <broma0> Zemyla: well the CS program is all Java except for our operating system course, but professors generally allow us to do whatever we want within reason. you better believe im going to be pushing for haskell
20:42:20 <geekosaur> (this also applies to virtual machines such as jvm and clr, perhaps more so because getting decent performance means accepting limitations)
20:42:49 <Zemyla> geekosaur: Actually, you don't actually need separate read and write instructions.
20:42:55 <hackrilege> anyway i shuld think about traversing my paradoxical data structure
20:43:09 * geekosaur is however approaching the limit of what he knows about the virtual ones. know a bit more about actual hardware, from talking to h/w designers...
20:43:16 <pjakobsen> quit 
20:43:19 <pjakobsen> opps
20:44:06 <geekosaur> but the general situation remains: once you reach the level of hardware (real or virtual), it's all tradeoffs for performance reasons and the result is ... messy
20:44:37 <geekosaur> and the various attempts to clean things up (risk, vliw, ...) havegenerally ended up making things worse
20:44:43 <geekosaur> *risc
20:44:43 <hackrilege> i really dont like using modules such as Vec, id rather write a minimal set of instances and understand the classes i am relying on
20:44:51 <Zemyla> You can have a CPU with only one instruction.
20:45:16 <hackrilege> compile everything to turing machine
20:46:34 <hackrilege> geekosaur: this Data.Grph package sucks, its not what i need at all.
20:47:16 <hackrilege> its all depth first searches n stuff, i just need fast lookup and the appropriate datastructure, i thought my cyclic tree was pretty good...
20:48:42 <hackrilege> im finding it really hard to get my hed round though. i cant understand how to enforce efficient lookup.. i dont get lazy or strict evaluation or threading in haskell...
20:50:42 <hackrilege> maybe i could have data CTree a = Branch (Ctree a) | Leaf a | CloseLoop...
20:50:48 <broma0> For those that are lazy.. is there a way to generate type sigs and actually put them in a file?
20:51:49 <hackrilege> i think you can invoke compiler calls to :t and :browse from within literal haskell scripts compiled with lhs2hs
20:52:01 <hackrilege> nope
20:52:08 <hackrilege> lhs2tex
20:52:21 <hackrilege> or you could just use writeFile....
20:52:53 <hackrilege> and probably some other thing that does exactly what you want but that i dont know about.
20:52:58 <hackrilege> maybe even try haddock
20:53:14 <peddie> broma0: C-u C-c C-t
20:53:39 <hackrilege> ok night guys, sorry for writing unclear and pointless messages.
20:54:58 <hackrilege> its really best to write your types yourself
20:57:01 <broma0> peddie: one of those times i wish i wasnt a vimmer
20:57:28 <peddie> broma0: I'm sure there is an equivalent, but I'm sorry, I don't know what it is
20:57:37 <broma0> thats alright, no worries
21:03:35 <mayahustle> Hi, if you have a data type with two constructors, and two values that both use the same constructor, is there a generic way to say, "Does thing a have the same constructor as thing b?"
21:03:54 <mayahustle> without pattern matching...
21:03:59 <benzrf> maybe something in Data.Generic mayahustle
21:04:04 <benzrf> or Data.Data
21:04:15 <mayahustle> hmm I've never looked at those too closely
21:04:15 <benzrf> er, *Generics
21:04:21 <mayahustle> I'll take a look see
21:04:35 <benzrf> kinda overkill tho
21:04:46 <dmj`> @typ typeOf
21:04:47 <lambdabot> Typeable a => a -> TypeRep
21:05:51 <dmj`> @def data FooBarz = FooBarz { fb :: Int, fbb :: Int }
21:05:52 <lambdabot>  .L.hs:148:24:
21:05:52 <lambdabot>      Multiple declarations of ‘fb’
21:05:52 <lambdabot>      Declared at: .L.hs:146:22
21:06:08 <dmj`> @def data FooBarz = FooBarz { abcd :: Int, abcd' :: Int }
21:06:09 <bitemyapp> dmj`: #rekt
21:06:09 <lambdabot>  Defined.
21:06:14 <Zemyla> @src fb
21:06:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:06:15 <dmj`> > typeOf fb == typeOf fbb
21:06:17 <lambdabot>  True
21:06:21 <Zemyla> :t fb
21:06:22 <lambdabot> FooBar -> Int
21:06:26 <dmj`> > typeOf abcd == typeOf abcd'
21:06:27 <lambdabot>  True
21:06:43 <dmj`> bitemyapp: :)
21:06:55 <dmj`> #lambdabotted
21:07:01 <mayahustle> lol
21:07:31 <mayahustle> that's not quite what I'm looking or though
21:07:34 <mayahustle> for*
21:07:53 <mayahustle> in this case if I had "fb 1" and "fb 2".. I want to check that both values use the fb constructor
21:08:03 <mayahustle> not that they're both type FooBarz
21:08:21 <peddie> mayahustle: if they're nullary constructors, you could do it with a derived Enum instance
21:08:43 <mayahustle> unfortunately not
21:09:14 <mayahustle> they're a bunch of constructors that mostly of the form: Foo { a:: Bool, b:: bool} that represents a config file that I'm digesting
21:09:23 <mayahustle> but I want to make sure I have no duplicate constructor types
21:09:31 <peddie> hm, too bad, you might have to just write it out then . . .
21:09:47 <mayahustle> I was afraid of that ...
21:09:58 <dmj`> mayahustle: I'd check Data.Dynamic
21:10:27 <pharpend> I'm having the weirdest issue with cabal/stack: https://github.com/commercialhaskell/stack/issues/702
21:10:50 <mayahustle> looks like theres a toConstr function in Data.Data
21:11:20 <mayahustle> I'll give that a shot
21:11:27 <mayahustle> and Data.Dynamic
21:15:05 <mayahustle> yeah.. toConstr actually works
21:15:56 <broma0> How the heck do you quit irssi?
21:16:04 <pharpend> broma0: /quit
21:16:10 <mayahustle> provided you make it an instance of Typeable and Data.. or just let it auto derive it using the language pragma DeriveDataTypeable.  looks like the auto drerive works great for simple types.. I'm sure it's more complicated with other types
21:16:14 <broma0> pharpend: that'll do. thanks
21:16:40 <mayahustle> Thanks for your help, guys!  I'm under a deadline.. back to my code cave
21:16:43 <pharpend> irssi, much like vim, gains most of its usership from people being unable to exit
21:16:57 <mayahustle> ^ second that opinion.. Emacs4Life!
21:17:28 <pharpend> Does anyone have any thoughts about my issue?
21:35:48 <Big_G> |+
21:35:54 <Big_G> 96++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
21:36:43 <creichert> pharpend: I left a comment, basically the hspec-discover preprocessor only includes modules with a *Spec.hs file name
21:36:56 <creichert> I would make the examples their own test-suite or put a Spec.hs at the end
21:37:12 <creichert> {-# OPTIONS_GHC -F -pgmF hspec-discover #-}
21:37:43 <creichert> That line is the preprocessor which sets up the Main module (Spec.hs)
21:38:11 <creichert> You could rename it to IOExamplesSpec.hs 
21:38:32 <pharpend> creichert: oh shit I forgot about that
21:38:34 <pharpend> thank you
21:38:38 <pharpend> I knew it was something simple
21:38:48 <creichert> yea, it's easy to miss
21:38:48 <pharpend> it doesn't explain why stack won't compile it, though
21:39:24 <creichert> well, it's not included from any other modules and therefore there is no reason to compile it. I believe that is a feature
21:40:08 <pharpend> "It's not a bug, it's a feature!"™
21:40:09 <creichert> but that's debatable, of course :)
21:40:11 <creichert> haha
21:40:24 <creichert> I think it's a ghc --make "feature"
21:41:52 <creichert> I suppose since you explicitly add it as a module you are saying you want it to compile.
21:43:39 <pharpend> creichert: exactly
21:44:42 <Big_G> 96666666666666666666666669******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
21:44:42 <Big_G> ********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
21:44:43 <Big_G> **********//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:44:46 <bitemyapp> @ops
21:44:46 <lambdabot> Maybe you meant: pl oeis docs
21:44:48 <Big_G> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:44:49 <bitemyapp> @op
21:44:49 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
21:44:53 <Big_G> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:44:56 <bitemyapp> @where ops
21:44:56 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:44:57 <pharpend> @where ops
21:44:57 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:44:58 <Big_G> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:45:03 <Big_G> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:45:05 --- mode: ChanServ set +o shachaf
21:45:08 <Big_G> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
21:45:15 <creichert> hehe
21:45:16 <pharpend> bitemyapp: What's with all the spambots around here nowadays?
21:45:17 --- mode: shachaf set -o shachaf
21:45:17 <ackthet> nice
21:45:24 --- mode: ChanServ set +o dibblego
21:45:24 <bitemyapp> pharpend: we are mega popular
21:45:26 <pharpend> idiot didn't even bother using a VPN
21:45:27 <creichert> does seem often
21:45:28 <Xe> pharpend: maybe they can't figure out monads
21:45:29 <dmj`> haha
21:45:39 <ackthet> pharpend: i think they join channels with large user counts
21:45:41 <bitemyapp> I don't think that was even a bot
21:45:47 <dmj`> :t (//)
21:45:48 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
21:45:49 <bitemyapp> I think that was a dude pressing ctrl-v
21:45:54 <dmj`> too much indexing
21:45:56 --- mode: dibblego set -o dibblego
21:45:58 <bitemyapp> dmj`: lmao
21:45:59 <pharpend> bitemyapp: heh
21:46:14 <dmj`> should've used lens
21:46:16 <pharpend> bitemyapp: It could be a brainfuck-eval bot
21:46:32 <creichert> infixr 5 (////////....
21:46:38 <pharpend> + is
21:46:55 <pharpend> creichert: heh
21:47:26 <nshepperd> the cat on keyboard operator
21:47:31 <pharpend> heh
21:48:48 <pharpend> creichert: Okay, fixed it: https://github.com/pharpend/comarkdown/commit/14392c3cc76968b4ed4cafb3ad21b2eaf15da100
21:50:04 <creichert> nice
21:50:09 <bitemyapp> pharpend: why did that need renaming?
21:50:21 <creichert> hspec-discover
21:50:30 <bitemyapp> well that's hardly Cabal's fault, isn't it?
21:51:05 <creichert> Since hspec-discover didn't process it into the Main, it wasn't included anywhere and not compiled/run automatically
21:51:08 <pharpend> bitemyapp: see channel convo pre-spam; Because cabal has a "feature" where it doesn't compile files in other-modules if they aren't used elsewhere. hspec-discover didn't see it because it didn't end in *Spec
21:51:22 <bitemyapp> pharpend: jfc
21:51:39 <bitemyapp> you end up using other-modules in the opposite way with Stack.
21:51:46 <bitemyapp> as a way to make it detect changes and fire off a build.
21:51:47 * pharpend looks "jfc" up in his acronyms HashMap
21:52:00 <pharpend> the lookup returned Nothing
21:52:02 <pharpend> what is jfc?
21:52:15 <Zemyla> pharpend: Jesus Fucking Christ.
21:52:50 <bitemyapp> translate :: Bitemyapp -> Pharpend
21:53:45 <pharpend> bitemyapp: Hmm. I still think it's a bug. It wasn't even *type-checking* the module
21:54:11 <bitemyapp> pharpend: report it please :)
21:54:13 * pharpend goes back to angry GNU user land
21:54:39 <pharpend> bitemyapp: I did, I posted the bug report as my question here =p
21:54:58 <bitemyapp> pharpend: I have the memory of a goldfish. I blame projects.
21:55:09 <pharpend> bitemyapp: I blame channel spam
21:55:54 <pharpend> bitemyapp: Isn't it the middle of the night in TX?
21:56:01 <bitemyapp> pharpend: the book knows no hours.
21:56:06 <pharpend> ah
21:56:13 <pharpend> I suppose the same can be said of mine
21:56:14 <bitemyapp> thing chases me around like a relentless zombie, depriving me of sleep
21:56:33 <bitemyapp> pharpend: isn't it the middle of the night in UT?
21:56:38 <pharpend> except I always seem to find a distraction that tangentially relates to the content of the book
21:56:39 <Zemyla> < dmj`> should've used lens <- He is, that multiple-page mess is one of the only operators lens hasn't taken yet.
21:56:43 <pharpend> bitemyapp: less so, but yes =p
21:56:54 <pharpend> 11 is like the beginning of the night
21:56:56 <pharpend> not the middle
21:57:00 <bitemyapp> pharpend: distraction that relates to the content of the book?
21:57:05 <pharpend> the end of the beginning
21:57:09 <dmj`> Zemyla: hahah
21:57:24 <pharpend> bitemyapp: I started writing a new markup language because LaTeX's Unicode support is terrible
21:57:34 <pharpend> [cue relevant xkcd]
21:57:35 <bitemyapp> oh boy
21:57:39 <bitemyapp> let me talk to you about unicode and latex.
21:57:43 <bitemyapp> 1. it sucks
21:57:44 <bitemyapp> 2. see #1
21:57:57 <dmj`> 3. see #2
21:58:01 <bitemyapp> the lengths I had to go to, to get a *LAMBDA* character to print were absurd.
21:58:15 <bitemyapp> this is partly why the book is rendered with xetex atm.
21:58:17 <pharpend> bitemyapp: well you can't blame Lamport, he wrote LaTeX ten years before Unicode. The support is better than you would expect
21:58:34 <bitemyapp> yeah but :(
21:58:35 <pharpend> but still absolute shit
21:58:51 <bitemyapp> LaTeX takes up less of my time with the book than you'd think, but still more than is ideal.
21:59:11 <Zemyla> How many years before Unicode was TeX written?
21:59:13 <bitemyapp> if I hadn't used LaTeX for years prior to the book (much lighter usage, CVs and brief reports), I'd have been fucked.
21:59:29 <CoconutCrab> <off-topic> my experience with xelatex for unicode was pretty good, everything just works </off-topic>
21:59:39 <CoconutCrab> worked*
21:59:43 <bitemyapp> CoconutCrab: yeah I use xelatex to compile the book
21:59:50 <bitemyapp> CoconutCrab: I don't know that I would say it just worked though.
21:59:51 <pharpend> with LYSA, I want it to render on a website, because nobody is printing out the PDF, and a PDF isn't ideal for computer reading
21:59:55 <bitemyapp> I had to fuss with fonts and other things.
22:00:18 <pharpend> there's a Russian translation of LYSA, and they had a hell of a time with Cyrillic character support
22:00:19 <bitemyapp> CoconutCrab: that said, xelatex at least eventually worked unlike the others.
22:00:29 <bitemyapp> pharpend: doesn't surprise me.
22:00:42 <CoconutCrab> bitemyapp: my use case was much simple, so for me everything just worked :) I only need the utf-8 support
22:01:05 <pharpend> bitemyapp: they eventually figured it out on their own machines, but they can't write a script to reliably nightly-build it
22:01:27 <pharpend> so about half the bug reports are "why are there no russian nightly builds?"
22:01:36 <bitemyapp> pharpend: this is partly why I vendor a lot of stuff in the book build.
22:02:26 <pharpend> bitemyapp: I'm glad to see that you are taking your time to do a thorough job with your book.
22:02:56 <bitemyapp> pharpend: well, I have a coauthor and stuff needs to build on her machine too
22:03:10 <pharpend> bitemyapp: RWH is out of date, and LYAH is incomplete, so once you get past the beginner's stuff, you're pretty much on your own with Haskell
22:03:18 <bitemyapp> pharpend: and I'm just generally more willing to do violence to "clean" engineering for the sake of making something that works.
22:03:22 <bitemyapp> oh you mean the content
22:03:27 <bitemyapp> not the latex build, lmao.
22:03:35 <bitemyapp> pharpend: yeah, the current sitch isn't great.
22:03:47 <pharpend> well the LaTeX build I suppose takes just as long
22:03:54 <bitemyapp> the book is as much about scratching an itch so I'm not so bothered by the current situation
22:03:59 <bitemyapp> as it is anything else.
22:04:11 <bitemyapp> Just want to know a book I am happy with is out there.
22:04:13 <pharpend> Who is publishing it?
22:04:18 <bitemyapp> me
22:04:22 <bitemyapp> I fired our publisher
22:04:26 <pharpend> heh
22:04:30 <dmj`> bitemyapp press
22:04:30 <bitemyapp> well, we fired our publisher.
22:04:39 <bitemyapp> it was a mutually agreed to decision.
22:04:44 <bitemyapp> but yeah, totes indie.
22:04:47 <pharpend> My father wrote a number of non-fiction books, and his #1 complaint was dealing with publishers
22:05:06 <pharpend> (most of his books were before the internet, so self-publishing wasn't an option)
22:05:10 <bitemyapp> my experience was limited and brief - I hadn't worked with a publisher before - and I was not impressed.
22:05:17 <pharpend> bitemyapp: Is it CC-licensed then?
22:05:23 <bitemyapp> Not for now, no.
22:05:44 <bitemyapp> Self-publishing isn't a panacea though. I have more of an appetite for tackling problems like marketing than most authors/programmers would.
22:06:00 <pharpend> I figured that I wouldn't actually work on mine unless it was CC-licensed, and the extra help is nice
22:06:20 <bitemyapp> I have open community resources in the pipe: https://github.com/bitemyapp/open-cis194
22:06:21 <pharpend> my idea of "marketing" is a reddit post from a year ago that got 50 upvotes
22:06:45 * pharpend should get off IRC and back to work
22:07:02 <bitemyapp> pharpend: me too. Cheers, looking forward to more LYSA content :)
22:07:18 <pharpend> bitemyapp: thanks =p
22:10:23 <haasn> “/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.3/../../../../x86_64-pc-linux-gnu/bin/ld: dist/build/xmonad/xmonad-tmp/Main.o: relocation R_X86_64_32S against `stg_bh_upd_frame_info' can not be used when making a shared object; recompile with -fPIC” How do I fix this error?
22:10:50 <haasn> I only get it when trying to compile xmonad, all other Haskell packages (that I've tested) work fine
22:21:07 <haasn> Ah, no, it affects other packages as well
22:21:24 <haasn> For example ‘cabal’
22:22:37 <haasn> I can't even build ‘ghc’ itself
22:23:29 <haasn> However curiously, building *some* binaries with ghc works, just not others
22:30:17 <haasn> Ah, I've just set GCC to use a “nopie” profile. That works
22:33:42 <Zemyla> haasn: You can't eat pie while compiling?
22:33:55 <haasn> Zemyla: Haskell does not like pie
22:34:18 <haasn> Or, well, GHC does not. It works fine with C and C++ programs!
22:34:50 <shachaf> It's "nopie" mode as contrasted with "yuppie" mode.
22:52:20 <BartAdv> bah, got bitten by the fact functor for 2-tuples maps over second element. How could one map the whole tuple in some concise way?
22:53:44 <Gurkenglas> data Pair a = Pair a a deriving Functor, then use that
22:54:04 <Gurkenglas> Because Functor always only maps over the last type argument.
22:55:15 <Gurkenglas> If you need to use tuples, you can get a specialized function to do it. For example, you could define your own via \f (x, y) -> (f x, f y), or equivalently, import Control.Arrow and use join (***), or equivalently use the lens that does that.
22:55:19 <Gurkenglas> :t join (***)
22:55:20 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
22:55:51 <BartAdv> oh, indeed I was looking for arrows. Not that I terribly needs to do this this way, but maybe I'll learn something new
22:55:52 <BartAdv> thanks
22:55:56 <Gurkenglas> :t join (***) (*2)
22:55:57 <lambdabot> Num a => (a, a) -> (a, a)
22:56:05 <BartAdv> pretty cool
22:56:53 <shachaf> BartAdv: You probably want Bifunctor
22:57:04 <shachaf> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Bifunctor.html
22:57:11 <shachaf> Arrow is the wrong answer to most questions.
22:57:26 <BartAdv> oh great, another name I've heard of, yet never really looked into
22:58:05 <shachaf> Bifunctor is simple.
22:58:13 <shachaf> It's like Functor but for something with two arguments.
22:58:32 <Gurkenglas> :t join bimap (*2)
22:58:33 <lambdabot> (Num a, Bifunctor p) => p a a -> p a a
22:58:44 <chattered>  :t over
22:59:26 <chattered>  > over both (+1) (1,2)
22:59:31 <chattered> > over both (+1) (1,2)
22:59:32 <lambdabot>  (2,3)
22:59:57 <BartAdv> :i over
23:00:14 <BartAdv> is this with lens?
23:00:22 <chattered> Yeah.
23:00:56 <chattered> I'm not sure I'd use it for just this one thing, unless I had other lens code about.
23:01:32 <shachaf> Yep. That's why I didn't bring it up.
23:01:44 <shachaf> Also, both is a bit less general than Bifunctor. It only works for Bitraversable.
23:01:46 <BartAdv> yeah, not going to add lens to my cabal right now:)
23:02:04 <Gurkenglas> Does hackage provide a big table between each name and the packages that define it?
23:02:08 <BartAdv> bifunctor is a bit unwieldy, cause I need: bimap f f <- I need to write f twice
23:03:00 <Gurkenglas> bimap f f = join bimap f. This works for anything that you would write in bimap's place.
23:03:11 <shachaf> Well, same with what Arrow gives you.
23:03:22 <shachaf> Except Arrow abstracts the wrong thing, and does it badly.
23:03:39 * lispy wonders about non-raversable bits
23:03:48 <BartAdv> ohh, I guess I need to grok join
23:04:10 <Gurkenglas> :t join
23:04:11 <lambdabot> Monad m => m (m a) -> m a
23:04:13 <shachaf> join f = \x -> f x x
23:04:28 <shachaf> I say it's usually more confusing than it's worth.
23:04:54 <Gurkenglas> ((->) r) has a monad instance. It is also called the reader monad and its general function is "plug arguments into multiple holes"
23:06:16 <BartAdv> oh wow:)
23:06:50 <BartAdv> this is great, thanks
23:10:06 <Gurkenglas> What replaces the functionality of a hypothetical MonadMaybe class to do for MaybeT what MonadReader does for ReaderT?
23:11:32 <chattered> Gurkenglas: With MonadReader, I want to be able to "ask." With Maybe, I'm not sure exactly what I want. Sometimes, I want failure, in which case, I'd be thinking of MonadError e.
23:11:42 <dmj`> Gurkenglas: that's like wanting a MonadEither
23:12:41 <Gurkenglas> Let me rephrase. How do I get the value of a monad stack containing MaybeT that represents Nothing without knowing the stack's exact structure?
23:13:15 <slack1256> MonadMaybe sounds like MonadPlus
23:13:40 <slack1256> @type mzero
23:13:41 <lambdabot> MonadPlus m => m a
23:14:04 <Gurkenglas> slack1256, https://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html says it doesn't have a MonadPlus instance because there are two possible implementations and nobody wanted to pick.
23:15:15 <slack1256> Monad m => MonadPlus (MaybeT m)
23:16:34 <Gurkenglas> Oh, um, nevermind then. Why does that Limitations part say it's not provided, then?
23:16:46 <slack1256> Mmm it says it isn't provided but it is actually provided?
23:17:40 <slack1256> weird right?
23:20:06 <slack1256> Oh the distinction seems to be this. The `instance (Monad m) => MonadPlus MaybeT where` always prefer the outmost MaybeT it can. This can be not what you want if you have multiple modes of failure (stacked MaybeT) failing.
23:21:53 <slack1256> To account for that you could instead use a `instance (MonadPlus m) => MonadPlus MaybeT where` yet how would you gracefully handle the previous case (where you don't need m to be a MonadPlus) is missing
23:21:54 <Gurkenglas> What the conventional word/construct for (\b x -> if b then x else return ())?
23:22:06 <lispy> when
23:22:11 <lispy> :t when
23:22:12 <lambdabot> Applicative f => Bool -> f () -> f ()
23:22:15 <Gurkenglas> Thanks.
23:22:40 <lispy> the negation is unless
23:25:35 <Gurkenglas> Hmm, what do I do when I have to put liftIO on most lines?
23:26:25 <lispy> define those lines separately as foo and then liftIO foo
23:27:15 <Gurkenglas> They define names used later in the do block, plumbing them through additional return tuples doesn't sound good
23:27:22 <slack1256> bar < liftIO $ do ...
23:27:54 <lispy> Gurkenglas: if it's a 'small' set of things you keep using you could define liftIO'd versions of them
23:31:22 <lispy> I guess the question, is what is liftIO really buying you in that case if everything you're invoking is doing something in the underlying monad
23:31:34 <lispy> It sounds like more of your program could be in that monad
23:32:02 <lispy> more IO a, less m a
23:33:38 * hackagebot cgrep 6.5.2 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.2 (NicolaBonelli)
23:36:00 <Gurkenglas> Can I ask to unwrap all newtypes of a type signature for me?
23:36:06 <Gurkenglas> *lambdabot
23:39:39 <slack1256> @unmtl StateT Int (Reader String Identity) a
23:39:39 <lambdabot> Int -> (Reader String Identity) (a, Int)
23:42:06 <Gurkenglas> @unmtl MaybeT (StateT () IO) ()
23:42:06 <lambdabot> (StateT () IO) (Maybe ())
23:42:13 <Gurkenglas> Why doesn't it unroll the StateT?
23:42:55 <slack1256> @unmtl MaybeT (StateT () IO) a
23:42:55 <lambdabot> (StateT () IO) (Maybe a)
23:43:02 <slack1256> layer by layer?
23:43:25 <slack1256> @unmtl State () IO (Maybe a)
23:43:25 <lambdabot> Plugin `unmtl' failed with: `() -> (IO, ())' is not a type function.
23:43:37 <slack1256> @unmtl StateT () IO (Maybe a)
23:43:37 <lambdabot> () -> IO ((Maybe a), ())
