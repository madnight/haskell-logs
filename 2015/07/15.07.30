00:30:17 <frerich> So the Java updater tells me that updating is a good idea. If it's such a good idea - why doesn't it happen automatically? I bet it's a trick to lure customers into taking the liability.
00:30:47 <frerich> I.e. updating is not a good idea - clearly there is a non-neglectible risk associated with it.
00:32:06 <demize> Update automatically? People whine. Don't update automatically? People whine.
00:32:30 <frerich> I'm just paraphrasing what monochrom wrote yesterday (but in a different context), but yeah.
00:33:23 <frerich> I'm fine with automatic updates, I have no idea on which grounds I'd refuse some specific update.
00:37:09 <AshyIsMe> in a prod environment you quite often don't want to risk updates breaking things for no good reason
00:37:36 <AshyIsMe> which has to balance off against "fixed 0day MASSIVE SECURITY issue number 79087" aswell though...
00:38:34 <edk> fundamentally updates can't fix something with a security record like java's
00:39:33 <adino> "fundamentally updates can't fix something with a security record like java's"... erm... I don't get what you mean
00:40:50 <edk> well, for one thing they don't seem to do much good, but also for any non-trivial update it seems quite likely it'd open as many holes as it closed
00:45:42 <ggole> Running untrusted code in something as huge and gnarly as the JVM does seem like a doomed enterprise
00:46:10 <BenBals> Hey, I am new to Haskell and I struggle with the Indentation of let, in and where blocks. I always get the error "parse error on input ‘=’". It seems like the compiler (or ghci for that matter) thinks im contiuing the last expression. I can only fix this using a semicolon.
00:52:04 <jle`> BenBals: can you post an example? :)
00:53:36 <adino> I'm learning haskell too (like 3 days old) and I find that the syntax is rather weird, compared to what I'm used to. The way I deal with let-statements is to indent more.
00:54:33 <adino> Yeah, post an example
00:56:39 <jle`> honestly the syntax weirdness sort of goes away pretty fast and you don't worry about it again ever, normally :)
00:56:49 <jle`> usually hwat happens is someone figures out what works for them and doesn't ever change, heh
00:57:34 <jle`> lets and wheres started seeming pretty mechanical pretty fast
00:57:36 <jle`> let x = 1
00:57:38 <jle`>     y = 2
00:57:41 <jle`> in  x + y
00:57:43 <jle`> ya dah
00:57:50 <jle`> *ta dah
00:59:29 <adino> jle`: yeah. I'm figuring that out. I can attest that it's becoming more mechanical :)
00:59:39 <ely-se> I indent "in" by one space.
01:03:23 <ely-se> Syntax is the least interesting aspect of every language.
01:03:38 <nshepperd> emacs seems usually pretty good at guiding your indentation, too
01:06:04 <BenBals> where reserve = 100 		  newBalance = balance - amount
01:06:33 <BenBals> So like where reserve = 100\n		  newBalance = balance - amount
01:07:08 <nomeata> BenBals: do you accidentially use tabs?
01:07:34 <nomeata> BenBals: if not, are there 6 spaces before newBalance, so that it aligns with reserve?
01:08:15 <BenBals> Do I need to use spaces or are tabs okay?
01:08:34 <nomeata> BenBals: they are ok if you display them at a width of 8
01:08:40 <pacak> BenBals: spaces. Tabs are evil.
01:08:40 <nomeata> but heavily discouraged in the community
01:08:53 <ely-se> https://ghc.haskell.org/trac/haskell-prime/wiki/Tabs
01:08:54 <nomeata> In fact,  I beleve recent versions of GHC will warn about them, at least with -Wall
01:09:07 <BenBals> I'll try spaces
01:09:24 <ely-se> Use a decent editor and backspace will cause multiple spaces to be removed.
01:10:37 <lpsmith> Hmm, I'm playing around with cabal sandboxes, and when I add a bunch of packages with add-source,  and try recompiling something,  it seems to be incrementally recompiling all my add-source'd packages,  which is faster than a full recompilation but still slow,   and then regenerating the haddocks,  which is also very slow.
01:11:12 <lpsmith> How does add-source determine whether or not to try to recompile a package or not?
01:12:24 <BenBals> I use Sublime and will enforce {     "tab_size": 4,     "translate_tabs_to_spaces": true } on haskell files
01:14:25 <lpsmith> hmm, the first two lines are:
01:14:26 <lpsmith> Warning: Could not list sources of the add-source dependency 'snap'. Skipping the timestamp check.
01:14:27 <lpsmith> Some add-source dependencies have been modified. They will be reinstalled...
01:14:29 <lpsmith> and then *everything* gets reinstalled,  which is highly annoying
01:23:39 * hackagebot hspec-expectations 0.7.1 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-0.7.1 (SoenkeHahn)
01:23:41 * hackagebot headergen 0.2.0.0 - Creates a header for a haskell source file.  https://hackage.haskell.org/package/headergen-0.2.0.0 (bash0r)
01:27:29 <guillaum1> Hello. This piece of code is slow "main = let l = [1..10000000] in print (length l, sum l)". There is space leaks involved because both operation (length and sum) can operate lazyly, but one needs to keep the list for the other. Is there a different way ? (Please note that in my real use case, I need the length of the list and I'm doing something else on the list, such as accumArray after a transformati
01:27:35 <guillaum1> on using map)
01:29:13 <nomeata> guillaum1: There is no easy solution. If you do not want to keep the list in memory, you have to write one traversal that collections _all_ information you need
01:29:55 <nomeata> Check out the foldl package for a combinator library that allows you to combine several such consuming functions.
01:30:19 <guillaum1> (I already tried to do something Inside a ListT (State Int) (roughly: do i <- [1..100000]; lift modify (+1); return i), but I'm loosing myself in the hoist and morph ;)
01:30:38 <guillaum1> nomeata: ok, I'll have a look if I can build a custom traversal function
01:30:42 <tsahyt> I finally found the time to play around with stack now, but I'm actually not quite sure what the advantage is over having everything in sandboxes?
01:31:10 <nomeata> guillaum1: note that by design, such an abstraction will not be a Monad, but can be an Applicative
01:32:18 <guillaum1> nomeata: ha, interesting. Thank you.
01:36:04 <voidzero> I want to play around with Turtle, try to re-create a few of my shell scripts using Haskell
01:36:27 <voidzero> What can I use to print out coloured output to the screen?
01:36:36 <voidzero> 256 colors preferably
01:37:06 <voidzero> maybe I'll use Shelly, or both, not sure yet. I'll also use optparse-applicative.
01:43:40 * hackagebot hspec-core 2.1.9 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.1.9 (SoenkeHahn)
01:43:42 * hackagebot hspec-discover 2.1.9 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.1.9 (SoenkeHahn)
01:43:44 * hackagebot hspec 2.1.9 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.1.9 (SoenkeHahn)
01:50:06 <ColorFuzzy> If I have a variable(eg. 7), how can I get all the type class the variable belongs to in ghci ?  :type 7 only get the Num, but 7 belongs to Num Eq …, how to get all? Thanks.
01:51:17 <merijn> ColorFuzzy: You can't get all typeclasses 7 belongs to, because that question does not make sense
01:51:26 <merijn> ColorFuzzy: 7 is a polymorphic value that is an instance of Num
01:51:40 <merijn> ColorFuzzy: What other classes it is an instance of depends on *which* num instance
01:51:54 <voidzero> :t 7 :: (Num a, Eq a) => a
01:51:55 <lambdabot> (Eq a, Num a) => a
01:52:08 <merijn> ColorFuzzy: I could define a Num instance for [()] which does not have the same instance as, say, Float
01:52:08 <voidzero> I thought he asked for that
01:52:23 <voidzero> but probably the other way around
01:52:31 <voidzero> so it needs context
01:53:56 <merijn> :t 7
01:53:58 <lambdabot> Num a => a
01:54:12 <voidzero> :info 7
01:54:15 <voidzero> :i
01:54:18 <merijn> There is no :info
01:54:33 <voidzero> and it wouldn't work anyway :)
01:54:51 <ColorFuzzy> Thanks for all your replies, I am new to haskell. Let me carefully think about the answers. Thanks.
01:55:07 <demize> Well, :info is :i in GHCi, so one could argue that there should be an :info ;p
01:55:32 <voidzero> yes but I mean
01:55:34 <voidzero> :i 7
01:55:36 <merijn> demize: :info is :info in GHCi, it's just that GHCi accepts abbreviations
01:55:43 <demize> (Though lambdabot seems to do neither)
01:55:44 <jdznd> Is there any kind person who can send me the solutions manual of Haskell the Craft 3/e? Thanks. jdzndj4a@gmail.com 
01:55:47 <voidzero> :i doesn't work.
01:55:48 <voidzero> eh
01:55:51 <voidzero> :i 7 doesn't work.
01:55:53 <demize> merijn: Fair enough.
01:56:15 <merijn> demize: But :i doesn't solve ColorFuzzy's problem, because his problem is that the question (at least as I interpreted it) is unanswerable
01:56:29 <demize> I'm not talking about their problem, and I haven't even read it.
01:56:44 <arkeet> values have types.
01:56:53 <liste> for Integral it would make sense, because :i Integral says (Real a, Enum a) => Integral a
01:57:01 <arkeet> 7 is a value, and its type is Num a => a
01:57:16 <arkeet> which can be specialized to any type that is an instance of Num, such as Integer or Word32 or whatever.
01:57:21 <arkeet> Num is not a type.
01:57:23 <tsahyt> ColorFuzzy: Depending on the concrete type that your 7 becomes, you can ask ghci for a list of type classes that it belongs to. So if you have 7 :: Int, you can use :i Int in ghci and it gives you a list.
01:57:24 <arkeet> nor is Eq.
01:57:26 <liste> so any value that has an Integral instance must have Real and Enum instances too
01:57:58 <ColorFuzzy> :type 7 got Num; then :info Num got all the others
01:58:08 <arkeet> Num is a type class. types can be instances of type classes. Integer is an instance of a number of type classes.
01:58:09 <merijn> arkeet: Well, technically 7 would be an instance of Eq if GHC obeyed the report :)
01:58:30 <arkeet> merijn: you mean the type of 7.
01:58:45 <merijn> arkeet: You get what I mean :)
01:59:08 <arkeet> I get it, but that's part of what I'm trying to clarify, so I want to be extra careful about it.
02:00:38 <bartavelle> what is "stack clean" supposed to do ? I thought it would rm -rf the sandboxes
02:01:07 <liste> sandboxes?
02:01:24 <bartavelle> it has a sandbox like directory for each "resolver"
02:01:39 <bartavelle> instead it uses up all my cpu and is now eating 5.3g of ram
02:02:36 <sinelaw> hi, GC reports 500MB max residency, but memory usage is > 1GB. Is this due to copying GC?
02:03:07 <jdznd> Is there any kind person who can send me the solutions manual of Haskell the Craft 3/e? Thanks. jdzndj4a@gmail.com
02:03:39 <bartavelle> sinelaw, there might also be non-managed memory used (or it might be virtual memory allocation)
02:03:41 * hackagebot microformats2-types 0.4.1 - Microformats 2 types (with Aeson instances)  https://hackage.haskell.org/package/microformats2-types-0.4.1 (myfreeweb)
02:03:55 <bartavelle> (sinelaw, just to add theories, I don't really know)
02:04:02 <sinelaw> bartavelle, when is memory not managed?
02:04:11 <sinelaw> it's mostly bytestrings
02:04:46 <bartavelle> I suppose some libraries with a C ffi interface might use memory that is not tracked by the runtime (even though finalizers might be)
02:09:27 <merijn> Also, note that in general processes never return memory after sbrk'ing more, so you might have temporarily caused it to allocate up to 1 GB which is then where it stays at
02:10:10 <sinelaw> merijn, wouldn't I see it in the max gc residency then?
02:11:00 <ely-se> merijn: are you Dutch?
02:11:35 <merijn> sinelaw: GHC uses a copyover GC, so I think memory usage could be 2x max residency
02:11:38 <merijn> ely-se: Yeah
02:11:43 <ely-se> nice, me too
02:12:09 <sinelaw> that was my thought. However, now with +RTS -S   I see  that the max residency number is also wrong!
02:13:24 <sinelaw> what exactyl does the "live bytes" column of -S show?
02:13:52 <sinelaw> I assume it should correspond to the residency of "avg/max residency"
02:15:02 <sinelaw> docs says "How many bytes are currently live."
02:16:27 <merijn> Live = not ready for GC, but there may be a lot of dead data around at times
02:18:41 * hackagebot servant 0.4.4 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4 (jkarni)
02:18:43 * hackagebot servant-client 0.4.4 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4 (jkarni)
02:18:45 * hackagebot servant-docs 0.4.4 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4 (jkarni)
02:18:47 * hackagebot servant-jquery 0.4.4 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4 (jkarni)
02:18:49 * hackagebot servant-server 0.4.4 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4 (jkarni)
02:18:59 <ely-se> lol
02:23:51 * hackagebot servant-examples 0.4.4 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4 (jkarni)
02:23:53 * hackagebot servant-blaze 0.4.4 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4 (jkarni)
02:23:55 * hackagebot servant-lucid 0.4.4 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4 (jkarni)
02:33:14 <merijn> Do we have, like, the opposite of #haskell-beginners for advanced questions? >.> I seem to only ask them at time where they get lost by the time anyone able to answer them is around...
02:34:09 <edwardk> merijn: for the most part that is what #haskell-lens acts as =)
02:35:10 <merijn> edwardk: But I don't use lenses :p Although I have been trying to hunt you down :p
02:35:25 * edwardk hides
02:36:06 <merijn> edwardk: I've been messing around with bound and free to implement an AST without having to deal with the mess of implementing substitution, but there's two things I get stuck with
02:36:07 <ely-se> merijn: maybe try a place that's less volatile than IRC
02:36:28 <merijn> ely-se: I already tried haskell-cafe :)
02:36:32 <benma> merijn: /r/haskell
02:36:38 <ely-se> Stack Overflow perhaps.
02:36:38 <edwardk> bound isn't quite 'free'
02:37:09 <merijn> edwardk: The first is that https://github.com/ekmett/bound/blob/master/examples/Deriving.hs is a neat example, but I'm confused how I'd actually use the Alt/P stuff when writing an interpreter
02:37:56 <edwardk> we compile down from something much like that example in the haskell ermine codebase
02:38:19 <lpaste_> merijn pasted “Free AST” at http://lpaste.net/137596
02:38:42 * hackagebot open-browser 0.1.4.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.1.4.0 (rightfold)
02:39:36 <edwardk> merijn: the open recursion pattern there is pretty noisy. i understand why you may want to do it, but it makes me cringe
02:41:21 <merijn> edwardk: The other thing is annotating ASTs. So right now I have something like the above example, but I can't find a nice way to deal with annotating source locations/type checking info. Intuitively annotations like that seem to map nicely to Cofree, but that wants the annotation type in the functor position, whereas Bound expects the type of variables to be in the functor position, and I can't see a way 
02:41:27 <merijn> out of that
02:42:20 <edwardk> i used to think cofree was useful for annotating ASTs, then i found that i could almost never make good use out of the annotations i built in that way, so i stopped.
02:42:31 <edwardk> and switched to generating them while i recurse
02:42:46 <merijn> edwardk: Yeah, I'm reaching the point where I'm considering just giving up trying to figure out the "nice/generic" way of doing things and just hardcoding an AST directly. But I'm planning to implement a bunch of variations of the same theme, so I had hoped to avoid duplicating all the code for defining traversals, etc. :\
02:43:21 <merijn> edwardk: Where do you store the annotations during the recursion? Just adding an extra annotation field on every AST node?
02:43:23 <edwardk> merijn: i haven't found a way to that pays its own way
02:43:50 <edwardk> i synthesize and inherit by using an actual function as i recurse with what i need
02:43:54 <lwm> anyone used stack to run ghc 7.10?
02:43:58 <edwardk> rather than doing attribute grammar tricks
02:44:34 <edwardk> i store the annotations during recursion in the environment of the function doing the recursion
02:45:07 <merijn> edwardk: That doesn't seem like it'd work well for storing computed types, no?
02:45:19 <edwardk> types are pretty terrible annotations anyways
02:45:34 <edwardk> i've never seen it work well
02:45:41 <merijn> edwardk: Well, I need to store them somewhere to avoid recomputing all the time...
02:45:47 <edwardk> i generate types by you know, type checking
02:46:03 <edwardk> i store types for top level definitions after i infer them
02:46:07 <edwardk> thats all i wind up needing
02:46:16 <edwardk> (local definitions as well)
02:46:29 <edwardk> that isn't a term-by-term annotation concern
02:46:33 <edwardk> its part of the binding group
02:46:56 <edwardk> annotating every term because you happen to need the types of top level binders seems a bit of overkill =P
02:47:21 <edwardk> and in the process of type checking i have to produce a witness of some sort for things like typeclasses anyways
02:47:34 <edwardk> so i have a whole core generation process tied to typechecking
02:47:42 <edwardk> its not just some decorations that don't affect your meaning
02:47:59 <edwardk> once you admit typeclasses, typechecking introduces code that has actually got computational content
02:48:42 <edwardk> so it seems to me that that is a good time to translate from a surface language to a (typed) core
02:49:47 <merijn> hmmm, I wonder if I can get a way with using "Compose ((,) SourceLoc) ExprF" as functor for free to annotate source locations and then forget all about the storing computed types
02:50:55 <edwardk> lets consider the 'avoid recomputing them all the time' concern. when do you recompute them? you need the types in a cyclic set of inferred definitions (an implicit binding group)... only while you are computing the types of the cycle (binding group), then you need to generalize those types
02:51:04 <Murtaugh_> Man, cpp isn't the best acronym for "C pre-processor"
02:51:13 <edwardk> this isn't "annotatable" its got a messy generalization step mixed in, etc.
02:51:26 <edwardk> its part of the process of figuring out what bindings refer to other bindings, and then typechecking off that
02:51:35 <edwardk> its a statement level thing, not a term level thing
02:52:24 <merijn> edwardk: btw, you said the "open recursion pattern is pretty noisy", you mean the fact that it splices in Free/Pure while pattern matching?
02:52:51 <edwardk> mostly that you wind up needing to deal with 3 levels of constructors to get at any one thing
02:53:01 <edwardk> kinda hard to see the forest through all those trees
02:54:03 <merijn> edwardk: Yeah, I was thinking I could (ab)use pattern synonyms to avoid that issue :)
02:54:54 <edwardk> i figure you make the definition for the type once, then you use it over and over. anything that saves you on the (small) original definition, but costs you everywhere you use it seems a bad economy =)
02:55:28 <edwardk> i can understand why you might want to do it, for things where you want to compile feature by feature or something, deal with lots of little sub-languages, etc.
02:56:14 <merijn> ugh, I see we still can't use TH to produce pattern synonyms :\
02:56:52 <edwardk> er.. anyways
02:57:18 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Inference/Type.hs#L147 shows one (rather messy and uncleaned) way to deal with inferring the types for binding groups
02:58:23 <merijn> edwardk: And Ermine also has an example of how you use the Alt stuff? I'll dive into the code a bit more, then
02:58:30 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Inference/Type.hs#L201 uses it on 'all the binding groups'
02:58:48 <edwardk> we use a slightly different notion of Alt in there, but the idea is largely the same
02:59:45 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Syntax/Pattern.hs#L211
03:00:23 <tsahyt> Does stack interfere in any way with the packages I installed globally using cabal?
03:01:00 <edwardk> ok, sleepy time
03:01:08 <voidzero> gnite
03:01:19 <voidzero> funny thing, timezones
03:01:23 <voidzero> anyway
03:01:58 <edwardk> voidzero: i'm always in the wrong timezone
03:02:14 <voidzero> so am i :D
03:02:43 <voidzero> my biological timezone is synched with the US, but I'm in the Netherlands :)
03:03:17 <voidzero> it's been a battle to resync it for most of my adult life
03:04:24 <edwardk> I'm pretty sure I'm biologically sync'd to Australia or something at the moment, despite being in the US.
03:04:27 <nkaretnikov> merijn: there's #haskell-in-depth and the other one (I forget what it's called), but both are dead anyway, so cafe is your best bet for such questions, imo
03:09:02 <nkaretnikov> merijn: I remember you asking the same question more than a week ago, maybe two, were you trying to make it work the whole time?  or is it something you attempt occasionally? 
03:26:51 <Benzi-Junior> hey is there a config file that can be edited to set default flags for ghc ?
03:28:38 <liste> Benzi-Junior for what use?
03:29:35 <Benzi-Junior> liste: to set -fno-warn-tabs to be the default
03:30:43 <voidzero> i'm hoping someone can suggest options for colored output on the linux shell
03:31:08 <liste> voidzero your own program output?
03:31:20 <liste> are you using vty?
03:32:10 <voidzero> right now i'm not using anything yet, but i'm looking at Turtle
03:32:24 <voidzero> I want to re-create some of my shell scripts to Haskell
03:32:29 <jerrrry> writeFile getLine getLine <- this obviously doesn't work.. but is there a way to lift writeFile to make it work?
03:32:33 <tennix> Benzi-Junior: http://stackoverflow.com/questions/23224876/global-configuration-for-ghc-build-flags
03:32:39 <jerrrry> :t writeFile
03:32:40 <lambdabot> FilePath -> String -> IO ()
03:32:45 <jerrrry> :t getLine
03:32:46 <lambdabot> IO String
03:33:08 <arkeet> :t join (liftM2 writeFile getLine getLine)
03:33:09 <lambdabot> IO ()
03:33:27 <jerrrry> nothing prettier?
03:33:39 <arkeet> not really
03:33:42 <voidzero> do you want pretty or functional? :)
03:33:43 <arkeet> alternatively
03:33:47 <liste> voidzero http://wiki.bash-hackers.org/scripting/terminalcodes
03:33:50 <arkeet> :t join (writeFile <$> getLine <*> getLine)
03:33:51 <lambdabot> IO ()
03:33:52 <arkeet> same thing
03:35:02 <liste> @hackage ansi-terminal -- voidzero there's also this
03:35:02 <lambdabot> http://hackage.haskell.org/package/ansi-terminal -- voidzero there's also this
03:35:08 <jerrrry> voidzero both
03:35:40 <voidzero> liste, that's exactly what I was looking for, thanks!
03:35:46 <arkeet> :t writeFile <$> getLine <*> getLine
03:35:47 <lambdabot> IO (IO ())
03:35:49 <arkeet> yeah.
03:36:20 <liste> yw (:
03:36:20 <jerrrry> I tried that by the way (actually I used liftA2). and I was confused why it compiled but didn't work. still not sure why I am getting nested IOs in here
03:36:38 <arkeet> writeFile :: FilePath -> String -> IO ()
03:36:47 <arkeet> liftA2 writeFile :: Applicative f => f FilePath -> f String -> f (IO ())
03:36:50 <liste> Benzi-Junior are you using cabal or stack?
03:36:52 <arkeet> now here we use f = IO.
03:37:02 <arkeet> liftA2 writeFile :: IO FilePath -> IO String -> IO (IO ())
03:37:12 <arkeet> then join is needed to deal with IO (IO ())
03:38:00 <Benzi-Junior> liste: stack? I'm just compiling from sourche
03:38:46 <liste> stack and cabal are build tools
03:39:56 <jerrrry> @hoogle :: (a -> b -> IO c) -> IO a -> IO b -> IO c
03:39:57 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
03:39:57 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
03:40:00 <Benzi-Junior> I use cabal but this is not for a cabal source just "ghc <sourcefile>"
03:40:06 <liste> i'd recommend learning them, but in the meantime you can use your shell's alias feature (on OSX and Linux)
03:40:16 <jerrrry> @hoogle :: (a -> b -> IO c) -> IO a -> IO b -> IO (IO c)
03:40:16 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
03:40:17 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
03:41:02 <liste> maybe there's aliasing on Windows too recently? I don't know
03:43:20 <liste> but in general, having global ghc flags is usually a bad idea if other programs (like package managers etc) use ghc and don't expect it to have those flags
03:44:10 <jerrrry> hoogle isn't smart enough to compose functions? :|
03:45:20 <ChristianS> jerrrry: considering how many functions hoogle has indexed, that would be pretty much impossible
03:45:36 <phaazon> big data ftw
03:45:40 <jerrrry> nothing's impossible
03:45:54 <phaazon> Nothing’s Impossible – jerrrry , a new song
03:45:56 <jerrrry> @djinn (a -> b -> IO c) -> IO a -> IO b -> IO c
03:45:56 <lambdabot> Error: Undefined type IO
03:46:07 <phaazon> oh
03:46:12 <phaazon> :t liftA3
03:46:13 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
03:46:24 <phaazon> well, not really liftA3
03:46:56 <ChristianS> Impossible Is Nothing: https://www.youtube.com/watch?v=R7Kboormk3Y
03:48:52 <merijn> nkaretnikov: I've been away to summer school and on vacation in between, so it was on hold for a long time :)
04:03:46 * hackagebot basex-client 0.1.0.0 - A BaseX client for Haskell  https://hackage.haskell.org/package/basex-client-0.1.0.0 (MatthijsSteen)
04:14:15 <sea-gull> merijn: which one? the one on dsls?
04:24:25 <merijn> sea-gull: No, HiPEAC summer school
04:28:47 * hackagebot text 1.2.1.3 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.1.3 (BenGamari)
04:36:32 <guillaum1> I'm still trying to do two thing on a list (such as (length l, otheroperation l) without space leaking... otheroperation is roughly a filter on the list.
04:36:55 <merijn> guillaum1: Compute both in a single traversal
04:37:27 <guillaum1> merijn: I tried, but perhaps I did it wrongly. If you may have a look at my code, I'll be really happy
04:52:05 <lpaste_> guibou pasted “FilterAndAccumulate” at http://lpaste.net/137597
04:53:03 <guillaum1> merijn: Please keep in mind that the resulting list is passed to length, but in real life I'd like to pass it to something else (such as accumArray), so I cannot compute its length in the reduction
04:53:08 <merijn> guillaum1: Those Predicate/Reductor type aliases make it rather hard to read :\
04:53:48 <guillaum1> merijn: ok, I tried this to be explicit ;)
04:55:03 <merijn> > foldl f z [a,b,c]
04:55:05 <lambdabot>      Ambiguous occurrence ‘a’
04:55:05 <lambdabot>      It could refer to either ‘L.a’, defined at L.hs:142:16
04:55:05 <lambdabot>                            or ‘Debug.SimpleReflect.a’,
04:55:09 <merijn> @undefine
04:55:10 <lambdabot> Undefined.
04:55:11 <merijn> > foldl f z [a,b,c]
04:55:12 <lambdabot>  f (f (f z a) b) c
04:55:21 <merijn> Won't this accumlate in the wrong order?
04:55:39 <merijn> i.e., your filtered list reversed?
04:56:14 <guillaum1> merijn: you are right.
04:56:37 <guillaum1> merijn: for this exercice I don't really care, so I thought that x:xs may me less expensive than xs ++ x
04:57:05 <guillaum1> but now you tell me, perhaps the whole list is build because it tries to compute its length starting by the end.
04:58:03 <ttt_Fff> I'm trying to embed a DSL in haskell. Is there anyway to convert >> \x -> x + 1 into     Lambda (Var "x")) (Expr [Var "x", Var"+", Var "1"]) ?
04:58:09 <kqr> would it be possible to have Data.Default without type classes?
04:58:15 <ttt_Fff> if not, how does deep embeding DSLs in haskell work?
04:58:20 <kqr> (in a sensible way)
04:58:20 <ttt_Fff> does it have to involve Template Haskell ?
04:58:48 <guillaum1> merijn: changing (x:xs) to (xs ++ [x]) takes abysmally more time ;)
04:59:47 <kqr> ttt_Fff, :set -XTemplateHaskell; import Language.Haskell.TH; runQ [| \x -> x + 1 |]
04:59:51 <kqr> ttt_Fff, that what you looking for?
05:00:11 <ttt_Fff> kqr: I don't know what I'm loking for yet, the XY problem is that I want to build a mini-DSL inside of haskell taht can generate javascript
05:00:32 <ttt_Fff> kqr: I can define jsFilter, jsMap, js... to emit "Javascript AST -> JavaScrip AST"
05:00:38 <ttt_Fff> but i'm not sure on who to define anonymous functions on the fly
05:01:04 <kqr> ttt_Fff, there are (primarily) two ways of making a DSL: monad-based like blaze-html or TH-based like persistent
05:01:24 <kqr> ttt_Fff, TH-based like hamlet* might be a better example
05:01:28 <ttt_Fff> kqr: in the blaze-html like appraoch, can you define *functions* ?
05:01:29 <kqr> ttt_Fff, not sure which approach is good for whta
05:01:38 <ttt_Fff> a dsl for descriitng a HTML document seems much easier than one which supports anonymousf cuntions
05:01:46 <ttt_Fff> *functions*
05:02:10 <kqr> ttt_Fff, well, you won't be able to convert "\x -> x + 1" to JS in that case, you'd have to do something else
05:02:30 <ttt_Fff> kqr: let me rephrase the question, if I'm writing aDSL which outputs javascript
05:02:44 <ttt_Fff> what is the best way (in Haskell) to express a javascript functino func(x) { return x + 1} ?
05:03:41 <Benzi-Junior> hmmm is there a parsec combinator that operates like string except it ignores capitalization ?
05:04:38 <liste> ttt_Fff express that in (E)DSL?
05:05:01 <ttt_Fff> liste: yeah, so I want a DSL (embedded in hasklel) which outputs javascript
05:05:13 <ttt_Fff> how should I design the DSL, so that it's easy to express something like func(x, y) { return x + y + 2; } ?
05:05:51 <Fernandos> hi
05:06:12 <Fernandos> Can someone run  https://github.com/dschoepe/rmv-query ?
05:07:39 <catgocat> Can anyone help me?
05:07:48 <Fernandos> I tried cloning it into fpcomplete and also localy with and without a cabal sandbox, but I run into problems with missing packages or dependency problems. Seriously there is nothing that I hate more than the package system sabotaging me..
05:07:54 <catgocat> In the LYAH book, it says that "Right 3 >>= \x -> return (x + 100)  " should trigger an error (ambiguous error)
05:07:57 <catgocat> but it works fine here
05:08:04 <ttt_Fff> liste kqr: either of you know of good tutorials on haskell dsl embedding techniques?
05:08:17 <Intolerable> catgocat: are you doing this in GHCi?
05:08:22 <catgocat> yes
05:08:32 <ttt_Fff> >> Right 3 >>= return . (+ 100)
05:08:38 <ttt_Fff> > Right 3 >>= return . (+ 100)
05:08:40 <lambdabot>  Right 103
05:08:45 <liste> ttt_Fff have you read https://wiki.haskell.org/Embedded_domain_specific_language
05:08:49 <Intolerable> it's most likely defaulting to a type
05:08:57 <Intolerable> which means it won't error
05:09:03 <ttt_Fff> liste: i've looked at it, it's a list of links to blog posts / research papers
05:09:07 <ttt_Fff> but seems to lack concrete examples
05:09:13 <Intolerable> if you put that into a file and compile it, it will probably complain
05:09:49 <Intolerable> :t Right 3 
05:09:50 <lambdabot> Num b => Either a b
05:09:56 <kqr> ttt_Fff, no, sorry, all I know is what I've learned by using a couple of DSLs
05:10:25 <catgocat> it doesn't complain when I compile either
05:10:45 <kqr> catgocat, could you link to where in LYAH it says that?
05:10:51 <catgocat> http://learnyouahaskell.com/for-a-few-monads-more#reader
05:11:02 <catgocat> scroll to "When we try to feed a Right value to a function that also succeeds"
05:11:51 <Intolerable> ah, that's old
05:12:03 <merijn> The Error constraint on e was dropped, afaik
05:12:07 <Intolerable> there's no Error constraint on Either any more
05:12:17 <liste> ttt_Fff is your language un(i)typed, like JavaScript ?
05:12:17 <kqr> catgocat, looks like it's referring to an old version of the standard library
05:12:20 <merijn> As a result 'e' probably gets defaulted to () which is a show instance
05:12:27 <merijn> :t Right 'c'
05:12:28 <lambdabot> Either a Char
05:12:32 <merijn> > Right 'c'
05:12:33 <lambdabot>  Right 'c'
05:12:42 <merijn> oh, hmm of course that won't work.. :D
05:12:45 <kqr> haha
05:13:50 <ThomasLocke> What can I do if I have an IO Int but I need an Int for a !! call? (complete Haskell noob here)
05:14:05 <catgocat> ok I'm confused
05:14:09 <catgocat> so what does actually happen?
05:14:20 <Intolerable> when you write "Right 3"
05:14:39 <Intolerable> GHC assumed that's :: Num b => Either a b
05:14:49 <Intolerable> which says that "a" can be anything
05:14:53 <Intolerable> but "b" has to be a number
05:14:59 <catgocat> so why did old versions of this trigger an error?
05:15:00 <Intolerable> (because you've said it's 3)
05:15:05 <Intolerable> because in old versions
05:15:06 <notdan> ThomasLocke: assuming (x :: IO Int) (l :: [a]), then x >>= \i -> l !! i
05:15:15 <Intolerable> the "a" had to be an Error instance
05:15:27 <catgocat> what about now?
05:15:31 <Intolerable> it can be anything
05:15:31 <notdan> erm sorry x >>= \i -> return (l !! i)
05:15:40 <notdan> or fmap (\i -> l !! i) x
05:15:43 <ThomasLocke> notdan, Is it really that simple? Amazing! I'll give it a whirl. Thanks. :o)
05:15:44 <kqr> ThomasLocke, http://lpaste.net/137598
05:15:45 <kqr> ThomasLocke, like that
05:15:47 <catgocat> why did they change?
05:15:50 <Intolerable> so ghc can just say "it's anything"
05:16:11 <Intolerable> rather than "it's anything that's an error"
05:16:17 <Intolerable> which could change the behavious
05:16:19 <Intolerable> *r
05:16:19 <liste> ttt_Fff how about something like lambda :: [Var] -> FunctionBody -> Function
05:16:22 <merijn> notdan: Why not "fmap (l!!)"? :)
05:16:28 <liste> and make Var instance of IsString
05:16:29 <nkaretnikov> ttt_Fff: lennart augustsson gave a very accessible talk on dsls: "makind dsls fly" or something like that
05:16:32 <catgocat> ok
05:16:33 <notdan> ThomasLocke: you can "extact" the value from the IO monad (or any monad for that matter) using the >>= function. But here's the catch: you still have to be stuck in IO
05:16:35 <catgocat> thanks
05:16:51 <notdan> merijn: I don't like eta-reducing operators 
05:16:56 <liste> so you can have lambda ["x", "y"] $ "x" + "y" + 1
05:17:14 <merijn> notdan: Why not? :)
05:17:18 <ttt_Fff> liste: so the code then becoems >> lambda [Var "x", Var "y"] (Var "x" + Var "y") .... hmm, I like that
05:17:35 <ttt_Fff> liste: hmm, how did you strip off the "Var" s ?
05:17:38 <liste> you don't even need the Var with OverloadedStrings
05:17:40 <ThomasLocke> notdan, So the thing that is returned from the !! call ends up in an IO monad?
05:17:48 <liste> if Var is instance of IsString
05:17:54 <ttt_Fff> liste: I like, thanks!
05:17:57 <sbrg> I have a question regarding determining features of monad stacks via the type signature. I'm not sure if doing it similarly to MonadIO and friends is the way to go. https://gist.github.com/be714855417051c2190a question is here + types and stuff.
05:18:08 <ttt_Fff> nkaretnikov: https://www.youtube.com/watch?v=7gF7iFB4mFY ?
05:18:12 <JagaJaga> I can't write smth like `data A = A $ Maybe String`?
05:18:29 <ttt_Fff> data A = A (Maybe String)
05:18:31 <notdan> ThomasLocke: yep! You cannot escape the IO monad
05:18:33 <Intolerable> nope, $ is a value-level operator
05:18:44 <JagaJaga> Intolerable: thank you.
05:18:49 <nkaretnikov> ttt_Fff: the one from codemesh, can't look up right now
05:19:03 <notdan> ThomasLocke: which makes sense: if you have a computation which input depends on I/O, then the whole computation together with the input depends on I/O
05:19:07 <Intolerable> you could probably define a :$ type level operator
05:19:10 <nkaretnikov> I don't think there are many similarly-named talks 
05:19:13 <Intolerable> but it's really not a good idea
05:19:29 <Intolerable> since you don't really gain much
05:19:38 <Intolerable> and it's just confusing for other people
05:19:51 <notdan> sbrg: replace 'forall s' with 'forall s m'?
05:20:10 <liste> ttt_Fff if you want to be type safe you could also have something like lambda1 :: (Var -> FunctionBody) -> Function
05:20:12 <JagaJaga> Intolerable: how to do it? Just curious :)
05:20:22 <liste> and lambda2 :: (Var -> Var -> FunctionBody) -> Function etc...
05:20:23 <Intolerable> type a :$ b = a b
05:20:27 <Intolerable> (don't do that though)
05:20:35 <Intolerable> you'll probably need to turn on an extension or two
05:20:45 <Intolerable> i don't recall which
05:21:02 <ttt_Fff> liste: not sure that works, as the type checking needs to understand which Var inside the FUnctinoBody is the lambdavar
05:21:08 <ttt_Fff> unless I use debruijin indices
05:21:10 <liste> and then have lambda1 (\x -> x + 1) and lambda2 (\x y -> x + y + 1)
05:21:15 <JagaJaga> Intolerable: thanx.
05:21:22 <ttt_Fff> however, not a big deal, I can roll my own polymorphic type checking (already did taht this past week)
05:21:39 <ThomasLocke> That makes good sense notdan - thanks again.
05:22:02 <ttt_Fff> liste: the problem is "x" "y" -> "x" ++ (show "y")    vs "x" "y" -> "y ++ (show "x")
05:22:13 <ttt_Fff> I can't get haskell to realize that the "x" and the "y" and their order
05:22:50 <catgocat> @pl liftM f m = m >>= (\x -> return (f x))  
05:22:50 <lambdabot> liftM = fmap
05:23:20 <SriPree> hi. I want to know if its possible to enforce type-level list membership as a constraint to a typeclass instance.. thanks
05:23:33 <sbrg> notdan: That doesn't model it appropriately, does it? I mean, I can't send a command where the state is any type. I can only do it if it's PluginEnvironment or ServerEnvironment. 
05:23:38 <Intolerable> "liftM = fmap"
05:23:53 <Intolerable> as a 7.8 user this is very offensive to me
05:23:58 <Intolerable> :^)
05:24:29 <liste> @let Expr = Const Int | Var String | Plus Expr Expr deriving (Show)
05:24:30 <lambdabot>  Parse failed: Parse error: |
05:24:36 <liste> @let data Expr = Const Int | Var String | Plus Expr Expr deriving (Show)
05:24:37 <lambdabot>  .L.hs:144:18:
05:24:37 <lambdabot>      Ambiguous occurrence ‘Expr’
05:24:37 <lambdabot>      It could refer to either ‘L.Expr’, defined at .L.hs:142:1
05:24:47 <liste> @let data MyExpr = Const Int | Var String | Plus Expr Expr deriving (Show)
05:24:48 <lambdabot>  Defined.
05:25:17 <liste> @let lambda1 f = (f (Var "x"))
05:25:18 <lambdabot>  Defined.
05:25:31 <liste> @let lambda2 f = f (Var "x") (Var "y")
05:25:33 <lambdabot>  Defined.
05:25:50 <liste> lambda1 (\x -> x `Plus` x `Plus` (Const 4))
05:26:07 <liste> > lambda1 (\x -> x `Plus` x `Plus` (Const 4))
05:26:09 <lambdabot>      Ambiguous occurrence ‘Const’
05:26:09 <lambdabot>      It could refer to either ‘L.Const’, defined at L.hs:142:15
05:26:09 <lambdabot>                            or ‘Control.Lens.Const’,
05:26:16 <liste> > lambda1 (\x -> x `Plus` x `Plus` (L.Const 4))
05:26:17 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘MyExpr’
05:26:18 <lambdabot>      In the first argument of ‘Plus’, namely ‘x’
05:26:18 <lambdabot>      In the first argument of ‘Plus’, namely ‘x `Plus` x’    Couldn't match e...
05:26:27 <liste> > lambda1 (\x -> x `L.Plus` x `L.Plus` (L.Const 4))
05:26:28 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘MyExpr’
05:26:29 <lambdabot>      In the first argument of ‘Plus’, namely ‘x’
05:26:29 <lambdabot>      In the first argument of ‘Plus’, namely ‘x `Plus` x’    Couldn't match e...
05:26:46 <liste> @let lambda1 f = (f (L.Var "x"))
05:26:47 <lambdabot>  .L.hs:149:1: Warning:
05:26:47 <lambdabot>      Pattern match(es) are overlapped
05:26:47 <lambdabot>      In an equation for ‘lambda1’: lambda1 f = ...
05:26:48 <notdan> sbrg: if you had the signature without the quantifiers, the forall stuff would be implicit anyway
05:26:52 <merijn> SriPree: Sure, I've even got an example of that
05:26:56 <catgocat> @pl liftA2 f x y = f <$> x <*> y  
05:26:56 <lambdabot> liftA2 = (. (<*>)) . (.) . (<$>)
05:27:00 <merijn> liste: Please don't spam the channel, use private message
05:27:11 <liste> merijn will do (:
05:27:27 <notdan> sbrg: i.e. "(MonadIO m) => Text -> [Text] -> IrcT s m ()" = "forall m s. (MonadIO m) => Text -> [Text] -> IrcT s m ()"
05:27:37 <SriPree> merijn: thanks. can I take a look at it pls?
05:27:39 <merijn> SriPree: This does the inverse of what you want, but should be easy enough to adapt: https://gist.github.com/merijn/6130082
05:27:53 <frerich> Somehow, seeing 'Productivity' > 95% in the profiling output gives me a real warm fuzzy feeling. ;-)
05:28:05 <notdan> sbrg: what exactly did you want to say with that type signature?
05:28:21 <SriPree> merijn: thanks for that.. 
05:28:46 <notdan> sbrg: oh wait nvm, I didn't read the question properly
05:29:01 <sbrg> notdan: The reason I'm getting these errors is because I recently refactored and changed the monad/state stack a whole deal.
05:29:03 <sbrg> Ah
05:29:20 <liste> > lambda2 (\x y -> x `L.Plus` y `L.Plus` (L.Const 1)) -- ttt_Fff
05:29:21 <lambdabot>  Plus (Plus (Var "x") (Var "y")) (Const 1)
05:29:26 <catgocat> Why does liftA2 (* 3) (Just 3) (Just 4) trigger an error?
05:29:42 <notdan> sbrg: so the type error that you get is definitely because you didn't include 'm' in your quantification. and the equality of signatures that i've mentioned still stands
05:29:44 <Intolerable> :t liftA2
05:29:45 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:29:48 <Intolerable> :t (*3)
05:29:49 <lambdabot> Num a => a -> a
05:30:03 <catgocat> oh of course
05:30:08 <catgocat> im dumb
05:30:10 <Intolerable> :)
05:30:15 <catgocat> >> liftA2 (*) (Just 3) (Just 4)
05:30:16 <notdan> sbrg: however, perhaps you want something like `(s ~ ServerEnvironment, MonadIO m) -> Text -> [Text] -> IrcT s m ()'?
05:31:13 <sbrg> aaaah yes, that might be it, yeah. 
05:31:36 <notdan> sbrg: altho in that case it wouldn't work if s ~ PluginEnvironment. 
05:31:39 <sbrg> However -- it is possible to do this either from PluginEnvironment or ServerEnvironment. To model this in the type signature, do I have to resort .. yeah
05:31:42 <sbrg> so, type classes?
05:31:57 <sbrg> class CanWrite .. something?
05:32:08 <notdan> sbrg: in order to resolve this you have two choices. 1) typeclass HasServerEnv 2) lifting functions IrcT ServerEnvironment m () -> IrcT PluginEnvironment m ()
05:33:16 <sbrg> the latter does not make sense in 90% of cases unfortunately(unless I'd put undefined in the message/handler records which I'd rather not), so I guess it's the typeclass approach
05:33:39 <sbrg> notdan: thanks for your help.
05:33:51 <Guest94112> hello!
05:34:03 <notdan> sbrg: why? You don't have to put undefined in the message/handler records
05:34:38 <sbrg> notdan: I'm not sure I follow, then.
05:34:42 <notdan> sbrg: IrcT ServerEnvironment m () is basically (ServerEnvironment -> m ()) and IrcT PluginEnvironment m () is (PluginEnvironment  -> m ())
05:35:19 <notdan> sbrg: so something like `lift i = \p -> i (serverEnv p)' should work
05:35:22 <srhb> Guest94112: Hello. :)
05:35:23 <notdan> module wrapping/unwrapping
05:36:05 <Guest94112> is this technology channel?
05:36:23 <Guest94112> i mean related with techs?
05:36:32 <rom1504> yes
05:36:45 <merijn> There's no DerivingMonad, is there? >.>
05:36:56 <Intolerable> gnd?
05:37:09 <Intolerable> it sorta counts :^)
05:37:13 <merijn> Intolerable: That only works for newtypes
05:38:06 <Intolerable> surely there can't be a DeriveMonad because there isn't a guaranteed unique instance
05:38:09 <merijn> Right now I have my monad instance for Free :)
05:38:09 <zoug> I have a hard time figuring out how to take out every nth element of a list. For example for every second element of a list, the input "Hello!" should be "el!". Could you guys help me?
05:38:21 <merijn> But using Free means pattern matching is a pain :\
05:38:48 <merijn> And I just learned TH doesn't support pattern synonyms yet, so I can't autogenerate convenient synonyms to hide the Free/Pure mess
05:38:50 <notdan> Ok, Ig2g
05:39:54 <merijn> > let everyOther [] = []; everyOther [x] = []; everyOther (x:y:xs) = x : everyOther xs in everyOther "Hello!"
05:39:55 <lambdabot>  "Hlo"
05:40:11 <merijn> Hmm, I guess that's not entirely right :p
05:40:22 <merijn> > let everyOther [] = []; everyOther [x] = []; everyOther (_:x:xs) = x : everyOther xs in everyOther "Hello!"
05:40:24 <lambdabot>  "el!"
05:40:38 <Intolerable> :t drop 1 . take 4
05:40:39 <lambdabot> [a] -> [a]
05:40:49 <zoug> thanks merijn !!
05:41:04 <zoug> but the problem
05:41:13 <zoug> is that this only works with every second element
05:41:17 <merijn> zoug: Oh, you wanted to generalise it
05:41:19 <zoug> that's not what I want
05:41:21 <zoug> yes
05:41:25 <zoug> that's the hard part
05:42:01 <zoug> If I want every tenth element then it's _:_:_:_......
05:42:44 <zoug> the best would be a f'n that takes an n as parameter and returns the string taking out every nth element, but I really have no idea how to achieve that in Haskell
05:43:14 <kqr> Fernandos, that is really, really old
05:43:23 <merijn> > let everyN n [] = []; everyN xs = case drop n xs of [] -> []; (y:ys) -> y : everyN n ys in everyN 2 "Hello!"
05:43:24 <lambdabot>      Equations for ‘everyN’ have different numbers of arguments
05:43:24 <lambdabot>        <interactive>:1:5-20
05:43:24 <lambdabot>        <interactive>:1:23-87
05:43:30 <merijn> oh, whoops
05:43:36 <merijn> > let everyN n [] = []; everyN n xs = case drop n xs of [] -> []; (y:ys) -> y : everyN n ys in everyN 2 "Hello!"
05:43:37 <Fernandos> kqr: what is odd?
05:43:38 <lambdabot>  "l!"
05:43:56 <merijn> hmmm, I guess you'd need "drop (n-1)"
05:44:07 <merijn> > let everyN n [] = []; everyN n xs = case drop (n-1) xs of [] -> []; (y:ys) -> y : everyN n ys in everyN 2 "Hello!"
05:44:09 <lambdabot>  "el!"
05:44:13 <merijn> > let everyN n [] = []; everyN n xs = case drop (n-1) xs of [] -> []; (y:ys) -> y : everyN n ys in everyN 3 "Hello!"
05:44:14 <lambdabot>  "l!"
05:46:18 <zoug> thank you merijn thats perfect..
05:46:25 <kqr> Fernandos, old, not odd! but I might have gotten it to compile. sec
05:47:30 <Intolerable> :t \n x -> concat $ takeWhile (/= "") $ unfoldr (Just . second (drop 1). splitAt (n-1)) x
05:47:31 <lambdabot> Int -> [Char] -> [Char]
05:49:20 <kqr> Fernandos, http://lpaste.net/508697227913330688
05:49:28 <kqr> Fernandos, with those changes, stack build builds it successfully
05:50:09 <kqr> Fernandos, it might be possible to compile it with more recent tagsoup versions though, which would probably help long-term stability
05:51:29 <JagaJaga> Can you help me with Options.Applicative? If I have an option like `keyword (Maybe String)`, how to parse it properly? I mean if there is no string after keyword, then return A Nothing, else A (Just String)?
05:51:39 <kuribas> Why is it Data.Functor, but Control.Monad?
05:53:01 <Intolerable> JagaJaga: use a flag for the Nothing, an option for the Just, and combine them with <|>
05:53:04 <Intolerable> that make sense?
05:53:27 <kuribas> @hoogle Bool -> a -> Maybe a
05:53:27 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
05:53:27 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:53:27 <lambdabot> Control.OldException assert :: Bool -> a -> a
05:53:51 * hackagebot getopt-generics 0.9 - Simple command line argument parsing  https://hackage.haskell.org/package/getopt-generics-0.9 (SoenkeHahn)
05:54:08 <kuribas> :t assert
05:54:09 <lambdabot> Bool -> a -> a
05:54:56 <JagaJaga> Intolerable: I don't need it like a `-k Maybe String`, I just need a parser like `parse keyword, try to parse word after it and if fails return Nothing`
05:55:17 <kuribas> :t (>>) . guard
05:55:18 <lambdabot> (Monad m, Alternative m) => Bool -> m b -> m b
05:55:39 <JagaJaga> Intolerable: so no `-` in option :)
05:55:45 <Intolerable> can you give an example of the calling it would look like?
05:55:53 <Intolerable> *what
05:56:20 <Intolerable> you might need subparsers
05:56:33 <merijn> kuribas: For no sensible reason
05:56:39 <JagaJaga> Intolerable: myProg keyword OR myProg keyword foo
05:56:54 <Intolerable> yeah, use a subparser
05:56:57 <merijn> kuribas: Control/Data is a completely arbitrary, nonsensical distinction kept for backwards compaibility
05:57:17 <kuribas> merijn: I would say Control for a typeclass, but Functor is a typeclass too...
05:57:44 <merijn> kuribas: The idea was "Data" for datatypes and Control for control-flow (i.e., monads)
05:57:59 <merijn> But then people realised functions, reader, etc. where functors too and everything became muddled
05:58:05 <JagaJaga> Intolerable: thank you.
05:59:50 <ggole> merijn: you mean, a rigid hierarchy didn't turn out to describe something well?!
05:59:53 * ggole shocked
06:00:10 <Intolerable> *cough* Num *cough*
06:02:52 <geekosaur> Num was always a compromise
06:07:39 <JagaJaga> Intolerable: that's what helped me `Keyword <$> (argument (Just <$> str) (metavar "foobar" <> value Nothing))`
06:09:58 <rtpg> Hey, what's that article about not using typeclasses?
06:12:22 <ggole> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
06:12:33 <Walther> Oliko kellään havaintoa onko jossaki muutaki ku madcroccia
06:12:36 <Walther> kolaa tms
06:12:50 <Walther> augh, wrong window, sorry guys :/
06:14:00 <rtpg> that's the one ggole, thanks
06:14:21 <catgocat> Can anyone explain me how `reads` work?
06:14:29 <catgocat> Every argument I pass to it, it returns an empty list
06:15:37 <demize> catgocat: How exactly are you trying to use it?
06:15:43 <demize> > read "42" :: Int
06:15:45 <lambdabot>  42
06:16:08 <Intolerable> reads, not read
06:16:10 <Intolerable> :t reads
06:16:11 <lambdabot> Read a => ReadS a
06:16:19 <Intolerable> :i ReadS
06:16:26 <Intolerable> @src ReadS
06:16:26 <lambdabot> Source not found. Whoa.
06:16:35 <catgocat> I just want to understand what it does
06:17:20 <Intolerable> reads "42" :: ReadS Int
06:17:24 <Intolerable> > reads "42" :: ReadS Int
06:17:26 <lambdabot>      Couldn't match type ‘[(a0, String)]’
06:17:27 <lambdabot>                     with ‘String -> [(Int, String)]’
06:17:27 <lambdabot>      Expected type: ReadS Int
06:17:40 <Intolerable> > reads "42" :: [(Int, String)]
06:17:42 <lambdabot>  [(42,"")]
06:17:45 <Intolerable> ?
06:18:08 <ronh> > reads "42hello" :: [(Int, String)]
06:18:09 <Intolerable> it parses everything it can
06:18:11 <lambdabot>  [(42,"hello")]
06:18:15 <Intolerable> and returns a pair for each of them
06:18:28 <Intolerable> where the first elem is the Read type
06:18:32 <Intolerable> and the second is the leftover
06:19:34 <catgocat> >> reads "\"hello\"321321" :: [(String, String)]
06:19:43 <catgocat> > reads "\"hello\"321321" :: [(String, String)]~
06:19:45 <lambdabot>  <hint>:1:47:
06:19:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:19:50 <catgocat> > reads "\"hello\"321321" :: [(String, String)]
06:19:52 <lambdabot>  [("hello","321321")]
06:25:10 <srhb> catgocat: And [] signifies failure to parse anything (which we'd probably use Maybe for instead of list nowadays.)
06:26:11 <jerrrry> reads can supposedly return more than one match (never seen that happen, though). that is why it returns a list.
06:27:24 <srhb> jerrrry: If there are multiple possible parses. :)
06:30:45 <fr33domlover> Q: I'd like to do "deriving Generic" on a datatype - can do this on an existing type, or does the "deriving" have to be done in the type declaration?
06:30:58 <fr33domlover> (i.e. modify the library VS modify just my code that uses it)
06:31:35 <quchen2> fr33domlover: When you have -XStandaloneDeriving you can do it elsewhere as well. In normal Haskell you can't.
06:32:12 <fr33domlover> quchen2, thanks. Would it be reasonable practice to use the extension? :P
06:32:50 <fr33domlover> the library is written by me too, but putting the deriving there means depending on -XDeriveGeneric etc.
06:33:01 <fr33domlover> while in the other case, only the program depends on it
06:34:24 <srhb> fr33domlover: It's fine. It's a very standard extension.
06:36:18 <quchen2> DeriveGeneric and StandaloneDeriving are both pretty harmless.
06:39:57 <fr33domlover> srhb, quchen2, thanks!
06:40:04 <ThomasLocke> If a :: IO Char and b :: IO [Char] how can I do a:b?
06:40:17 <quchen2> liftA2 (:)
06:40:35 <quchen2> :t liftA2 (:) (undefined :: IO Char) (undefined :: IO [Char])
06:40:36 <lambdabot> IO [Char]
06:41:10 <quchen2> Or the long version:   do { a' <- a; b' <- b; pure (a':b') }
06:41:21 <Crockeo> :t (:) <$> (undefined :: IO Char) <*> (undefined :: IO [Char])
06:41:22 <lambdabot> IO [Char]
06:41:39 <Crockeo> You can also just use applicative more directly if you want - it all depends on style
06:42:08 <ThomasLocke> Crockeo, I'm a bumbling newbie - I have no style! :D
06:42:30 <Crockeo> Hahaha then your lack of style is your style.
06:42:40 <Crockeo> Just don't look at my project euler solutions from when I started learning Haskell'
06:42:41 <ThomasLocke> quchen2, I'll give liftA1 a whirl and see if I can make it work. Thanks. :o)
06:42:56 <quchen2> liftA2, not A1.
06:43:06 <quchen2> liftA1 is called liftA and that's equivalent to fmap.
06:43:18 <ThomasLocke> Of course.. Bad typing skills on my end.
06:43:28 <quchen2> Bonus question: what's liftA0?
06:44:52 <kuribas> id?
06:45:06 <quchen2> No
06:45:12 <kuribas> ehm, flip const?
06:45:25 <kuribas> :t liftA
06:45:25 <Crockeo> :t flip const
06:45:26 <quchen2> no
06:45:27 <lambdabot> b -> c -> c
06:45:27 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:45:33 <kuribas> :t liftA2
06:45:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:46:05 <lamefun> Is normal Parsec dead/in maintenance-only mode?
06:46:23 <kuribas> hm, so "Applicative f => a -> f a ->"
06:46:37 <kuribas> pure?
06:46:41 <kuribas> :t pure
06:46:42 <lambdabot> Applicative f => a -> f a
06:46:42 <quchen2> Yes! :-)
06:46:49 <kuribas> did I wine a price?
06:46:53 <Crockeo> Hahaha
06:46:54 <kuribas> win
06:47:05 <Crockeo> no, but you wined and dined a prize
06:47:05 <quchen2> ヽ (＾▽＾) ﾉ 
06:47:10 <quchen2> Here is your prize picture 
06:47:47 <kuribas> lol
06:49:33 <ttt_fff> Is the limit of the point-free programming style concatenative languages, i.e. like forth ?
06:50:11 <quchen2> The limit of point-free programming style is readability.
06:51:51 <kuribas> there is factor http://factorcode.org/
06:52:34 <kuribas> I've never understood the appeal of concatenative languages.
06:53:31 <kqr> they're very declarative, aren't they
06:54:11 <aweinstock> my understanding is that they force you to write point-free, even when adding points would help readability
06:56:29 <kqr> i don't think it's that simple
06:56:46 <kqr> but i'm not qualified to say for sure either!
07:04:06 <lamefun> Can I have a "class MyClass a where" function with no parameters of type "a" (eg. "class MyClass a where every :: Set a)?
07:04:35 <kqr> the idea is called having a phantom type
07:04:54 <kqr> well, maybe not in this case
07:05:02 <kqr> but what errors are you getting?
07:05:50 <kadoban> lamefun: I don't personally see why not.
07:06:20 <lamefun> nevermind
07:06:50 <michaelt> lamefun: http://hackage.haskell.org/package/universe-1.0/docs/Data-Universe.html
07:07:34 <lamefun> I meant to ask, can I have a class where a function has no arguments of the "a" type eg. "class MyClass a where everyName :: Set String", how'd I call that?
07:08:39 <geekosaur> you can define it but indeed there is no way to pick an instance for it
07:09:32 <lamefun> I think I can add a fake argument and pass (undefined :: MyType) to it, but that seems like a cheat, or hack.
07:10:20 <kuribas> lamefun: that's how it is normally done.
07:10:35 <kqr> wouldn't Data.Data or something be helpful here?
07:10:44 <kqr> a typeclass doesn't feel like the correct solution
07:10:48 <chpatrick> lamefun: take a parameter of type (p a)
07:11:06 <chpatrick> so you can pass in anything that has a as a parameter
07:11:11 <chpatrick> the canonical one to pass in is Data.Proxy
07:11:13 <michaelt> isn't there an extension or proposed extension that permits no parameters for a class?
07:11:14 <chpatrick> or
07:11:17 <chpatrick> use Data.Tagged
07:11:32 <chpatrick> and then it's everyName :: Tagged a (Set String)
07:12:21 <chpatrick> michaelt I think there's a parameter here but the value of everyName only depends on the type
07:13:02 <chpatrick> you still need to pass a type in and the nice way is with a proxy or with Tagged
07:13:18 <michaelt> oh, it's that MultiParamTypeClasses now permits class MyClass where everyName :: [String]
07:13:19 <chpatrick> then you don't need to undefined
07:13:57 <ttt_fff> I have a slightly off topic question. In a software engineering team, how do I show fellow developers respect?
07:14:08 <michaelt> then you can do goo :: MyClass => Int; goo = length everyName
07:14:28 <ely-se> ttt_fff: by not being an asshole.
07:15:01 <chpatrick> :D
07:15:03 <ttt_fff> this is like saying "how to you write correct code"? "by not writing bugs"
07:15:05 <chpatrick> this
07:15:09 <chpatrick> it's true though
07:15:14 <chpatrick> listen to what they say
07:15:23 <chpatrick> admit if you don't know something
07:16:19 <kuribas> what if you know you are right, and they don't want to admit it?
07:16:41 <ely-se> it depends on the culture
07:16:45 <ttt_fff> you mean dealing with people who claiming that un-typed langauges are better?
07:16:57 <kqr> kuribas, first step is judging how important it is to be right
07:17:00 <ttt_fff> like clojurists who claim that unit tests > type checking
07:17:07 <kqr> kuribas, when that is done it will depend
07:17:29 <ely-se> people who claim that untyped languages are better than typed languages are equally misinformed as those who claim the opposite
07:17:46 <merijn> ely-se: I disagree
07:17:57 <kuribas> ttt_fff: that's still kind of debatable...
07:18:08 <merijn> There are no untyped languages, just unittyped ones
07:18:36 <ely-se> for any definition of "untyped"
07:19:25 <ely-se> and "typed", too. You can't tell one tool is better than the other without knowing what they're going to be used for.
07:19:25 <ttt_fff> what? you guys are not seriously claiming that lack of types = good thing
07:19:28 <merijn> And unittyped languages are obviously inferior to those with more complex types, as their type system is a strict subset of more complex typed languages, so it's trivial to embed programs written in those into other languages
07:19:44 <Intolerable> no, but lack of types = not necessarily a bad thing
07:19:47 <merijn> Writing python by using Dynamic for everything in Haskell is easy
07:20:02 <kuribas> ttt_fff: some people may be more comfortable with it.
07:20:20 <kuribas> ttt_fff: and it takes time to learn a complicated type system like in haskell.
07:21:38 <ely-se> I consider any person who considers one language inherently better than another one a fool.
07:21:50 <kqr> but we were talking type systems, not languages
07:22:24 <ttt_fff> ely-se: I conider haskell to be superior to brainfuck
07:22:28 <ttt_fff> ely-se: please argue otherwise
07:22:31 <ely-se> The same principle applies. Different type systems have different use cases.
07:22:39 <kqr> ttt_fff, brainfuck is easier to port to new platforms
07:22:41 <kqr> ttt_fff, ;)
07:23:00 <ely-se> ely-se: brainfuck is obviously superior over Haskell for demonstrating a compiler for a Turing-complete language can be implemented in 1024 bytes of machine code
07:23:04 <ttt_fff> kqr: porting brainfuck is useless since there's no apps written in it
07:23:54 * hackagebot moesocks 0.1.0.5 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.5 (JinjingWang)
07:24:36 <Zemyla> It's also superior for showing another language is Turing-complete.
07:24:53 <kuribas> ttt_fff: consider that you are the only haskell programmer, and the other 5 are javascript programmers.  Then it would be hard to convince them to use haskell.
07:25:35 <aweinstock> kuribas: but that only shows javascript to be better politically, not technically
07:26:06 <kqr> "technically" was not a qualifier
07:26:19 <kqr> that was used in this case
07:26:38 <Zemyla> I mean, imagine if you had to implement Haskell in a language to show it was Turing-complete.
07:27:30 <merijn> Zemyla: If you throw out the syntactic sugar and typeclasses, that's surprisingly easy
07:27:38 <davean> Zemyla: ... we'd have a lot more haskell interpriters?
07:27:42 <kuribas> Zemyla: you would only have to implement a turing complete subset.
07:27:46 <merijn> Implementing Core/STG is pretty simple
07:28:06 <davean> Zemyla: We'd probably have longer on CS exams?
07:28:17 <Zemyla> davean: We'd have a lot more useless tiny Haskell compilers.
07:43:25 <ely-se> On a scale from no to yes, did anybody try Frege?
07:43:35 <hodapp> I haven't.
07:44:00 <Crockeo> No
07:44:27 <Crockeo> Just looked it up - interesting idea.
07:45:22 <Crockeo> Java interop looks like it works similarly to FFI in Haskell (just smoother)
07:45:42 <jackhill> ely-se: I've played around in a repl. We have a Java application at work, so it's attractive to me.
07:45:57 <jackhill> ely-se: there is also #frege
07:46:04 <hodapp> Scala certainly has more support and popularity... but the problem is that it's Scala.
07:46:32 <ely-se> I'm a Scala expert.
07:46:42 <Crockeo> ely-se, I'm so sorry
07:46:45 <ely-se> XD
07:46:48 <Crockeo> you have my condolences
07:47:01 <Crockeo> no, but I really like Scala too. it's really useful
07:47:16 <hodapp> if I were stuck on the JVM it's where I'd be looking.
07:47:44 <Crockeo> hodapp, same. unluckily for me I'm not stuck on the JVM, I'm stuck on Microsoft's ecosystem
07:47:53 <hodapp> F#?
07:47:53 <Crockeo> well, specifically SSIS
07:47:55 <merijn> hodapp: I think I'd prefer Clojure over Scala
07:48:12 <hodapp> merijn: yeah, it may depend on what I'm doing
07:48:14 <Crockeo> hodapp, my options are VB2008 or MSVC2008
07:48:16 <hodapp> I do like Clojure
07:48:19 <merijn> F# is ok :)
07:48:29 <hodapp> I'm told it's very OCaml-like.
07:48:31 <Crockeo> I tried Clojure, but a lot of the tooling just kind of got on my nerves
07:49:07 <hodapp> I am a fan of some of Dr. Hickey's lectures and philosophy.
07:49:09 <ely-se> Clojure tools are slow which raises the shall-I-use-it bar significantly.
07:49:16 <dot_Laptop> Hello. Is there a snippet to convert String to Data.Text.Internal.Text ?
07:49:26 <hodapp> this is probably a little off-topic though.
07:49:41 <hodapp> #haskell-blah perhaps!
07:50:23 <ely-se> dot_Laptop: http://hayoo.fh-wedel.de/?query=String%20-%3E%20Text
07:50:24 <Crockeo> Signing off - time to go shop for guitars
07:50:45 <ely-se> dot_Laptop: second result on that page, i.e. Data.Text.pack myString
07:52:03 <michaelt> dot_Laptop: T.pack , you should have 'import qualified Data.Text as T' or something
07:52:31 <michaelt> dot_Laptop: if it is a string literal that is causing trouble, use {-#LANGUAGE OverloadedStrings #-}
07:52:37 <ely-se> Don't refer to Data.Text.Internal.Text directly, though. Use Data.Text.Text.
07:52:58 <ely-se> It's the same type.
07:53:00 <michaelt> dot_Laptop is quoting an error message, clearly
07:53:17 <dot_Laptop> But https://hackage.haskell.org/package/smtp-mail-0.1.4.5/docs/Network-Mail-SMTP.html this requires Data.Text.Internal.Text 
07:53:35 <dot_Laptop> For constructing Address
07:53:39 <michaelt> right, that's just the Text type exported by Data.Text 
07:54:36 <dot_Laptop> Oh
07:55:04 <ely-se> typically when a module's name has "Internal" in it, it's not what you're looking for, unless you are.
07:55:08 <dot_Laptop> Why does the library loads a deprecated library
07:55:27 <michaelt> what's deprecated?
07:55:27 <merijn> hodapp: F# is basically ocaml with a slightly different syntax, yes
07:55:51 <hodapp> and Microsoft-flavored?
07:55:51 <ThomasLocke> As a complete Haskell noob I've tried to write a small program that creates a sorta-kinda random password. It appears to work, but I've no idea how many beginner mistakes I've made. WIthin the confines of how the problem works, does this seem OK to you guys: https://gist.github.com/ThomasLocke/d69cf6253e6342a61418
07:56:22 <ely-se> ThomasLocke: the first obvious mistake is that your random number generator isn't cryptographically secure
07:56:47 <ThomasLocke> ely-se, Yea I know. The goal was not to do an actually secure password, but merely to learn a bit about IO
07:56:53 <dot_Laptop> not deprecated maybe, but this lib https://hackage.haskell.org/package/smtp-mail-0.1.4.5/docs/Network-Mail-SMTP.html loads an older version of Network.Mail.Mime
07:57:34 <ThomasLocke> As stated I'm a beginner, so the whole functional paradigm is pretty hard on my brain as it is.  :D
07:58:33 <y> merijn: and more OOP and less ML
07:58:45 <ely-se> ThomasLocke: you can shorten "randNum >>= (\i -> return (validChars !! i))" to "fmap (validChars !!) randNum"
07:58:56 * hackagebot http-conduit 2.1.7.2 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.7.2 (MichaelSnoyman)
07:59:19 <ThomasLocke> ely-se, That is sweet advice. Thanks!
07:59:37 <ThomasLocke> Exactly the kinda advice I'm looking for. Soooooo much to learn!
07:59:47 <ely-se> ThomasLocke: generatePassword could be a pure function which takes a random number generator instead.
07:59:57 <merijn> Another approach that is not exactly cryptographically sound would be:
08:00:01 <ely-se> instead of doing I/O*. This makes it more reusable.
08:00:17 <michaelt> dot_Laptop: hm, I have the current mime-mail installed with it. You presumably have two versions installed?
08:00:26 <dot_Laptop> So I'm really trying to construct Data.Text.Internal.Text so that I can use Network.Mail.SMTP lib
08:00:33 <merijn> ThomasLocke: "take 10 . filter notValidChar . randoms $ mkStdGen 1"
08:00:39 <aweinstock> ThomasLocke: you could put "parseArgs _ = putStrLn help >> exit" as the last clause, and remove the other ones that print the help message
08:00:40 <michaelt> dot_Laptop: from a literal string?
08:00:45 <dot_Laptop> Yes
08:00:49 <dot_Laptop> Uh no
08:01:00 <merijn> ThomasLocke: That's not entirely secure since filtering invalid characters might introduce some weird bias in the generated passwords
08:01:06 <dot_Laptop> Literal String worked fine, 
08:01:07 <michaelt> just put the pragma I mentioned at the top of the file, or :set -XOverloadedStrings inside ghci
08:01:18 <dot_Laptop> I already used the pragma
08:01:27 <dot_Laptop> Let me paste the code
08:01:30 <ely-se> ThomasLocke: assuming >>= and fmap are implemented correctly (which they are for IO), "x >>= \y -> return (f y)" can always be reduced to "fmap f x"
08:01:31 <ThomasLocke> So much win here.. I'm furiously taking notes.  :o)
08:01:35 <michaelt> oh, the literal works. The function is T.pack if you import qualified Data.Text as T
08:01:54 <merijn> ThomasLocke: FYI, optparse-applicative is a good library for option parsing, but maybe a bit complex as beginner
08:02:02 <aweinstock> merijn: it's already using a non cryptographically-secure PRNG as a base
08:02:08 <merijn> aweinstock: Sure
08:02:19 <aweinstock> (so additional bias doesn't matter, it's not secure anyway)
08:02:36 <ThomasLocke> merijn, Yea I looked at it and decided it was a bit above my paygrade. :D
08:02:44 <aweinstock> :t state random
08:02:45 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
08:02:56 <merijn> aweinstock: Why use "state random" instead of randoms?
08:02:58 <merijn> :t randoms
08:02:59 <lambdabot> (RandomGen g, Random a) => g -> [a]
08:03:08 <merijn> randoms just produces an infinite list
08:03:11 <aweinstock> :t \size -> replicateM size (state random)
08:03:13 <lambdabot> (MonadState s m, RandomGen s, Random a) => Int -> m [a]
08:03:27 <aweinstock> :t randoms
08:03:28 <lambdabot> (RandomGen g, Random a) => g -> [a]
08:03:30 <merijn> :t randoms (mkStdGen 1) :: String
08:03:31 <lambdabot> String
08:03:31 <dot_Laptop> http://lpaste.net/137604
08:03:34 <merijn> > randoms (mkStdGen 1) :: String
08:03:36 <lambdabot>  "\39335\14070\DC1\959535\514122\923211\263434\59659\367628\671400\744213\298...
08:03:59 <aweinstock> > filter isAlpha $ randoms (mkStdGen 1)
08:04:01 <lambdabot>  "\39335\14070\70334\138983\37111\27202\139598\25181\165723\29657\11327\31112...
08:04:04 <merijn> dot_Laptop: Don't use read :\
08:04:16 <dot_Laptop> Yeah I'm trying to
08:04:19 <merijn> > text . filter isAlpha $ randoms (mkStdGen 1)
08:04:23 <lambdabot>  mueval-core: Time limit exceeded
08:04:27 <merijn> oh, eh...
08:04:33 <merijn> > text . take 100 . filter isAlpha $ randoms (mkStdGen 1)
08:04:34 <lambdabot>  馧㛶𑊾𡻧郷橂𢅎扝𨝛珙ⰿ禈璯𫘂𤲾𣂗ࠤ𫟮ꔚ𦓸𥋟박춫I윳켌낍𫂮𢕏𠿝婵𖩑𩢝ꖺ𣠔𩕺𧫽ﭴ𥼊럖𨯊𨦲ꑿ㚥賸𖮎継𨲖赸𢒜턀櫜䙉赝潹𡑰𢼠𥦽𦍣顪ভ䊇ꚸ擽𥓭謘㦥𥌭𪔀Ⴃ쨀봱ꇻ𧥷𧰏鏃...
08:04:59 <dot_Laptop> That's the part that I need to fix
08:05:04 <ely-se> you likely want ASCII passwords
08:05:06 <merijn> aweinstock: Printed strings don't display unicode in lambdabot :)
08:05:12 <merijn> ely-se: Pffft, lame :p
08:05:30 <aweinstock> I kinda assumed that only ascii satisfied isAlpha
08:05:34 <ely-se> otherwise you'll break systems written by bad programmers that can't deal with anything not ASCII
08:05:38 <michaelt> dkua: 
08:05:42 <merijn> > filter isAscii $ randoms (mkStdGen 1)
08:05:46 <lambdabot>  mueval-core: Time limit exceeded
08:05:51 <ely-se> XD
08:05:53 <dkua> ??
08:05:55 <merijn> aweinstock: That'd be stupid in the presence of proper unicode strings
08:06:08 <aweinstock> > take 100 . filter isAscii $ randoms (mkStdGen 1)
08:06:08 <demize> aweinstock: Nope, Unicode Alphabetic category
08:06:10 <lambdabot>  "\DC1I.9\DC2`y}I|#j\SOHtvjU2!UE.17}QGV\SI:\SYNy+9[\DC1I\n^!b\GSd3Z\bsD>]HT Y...
08:06:10 <demize> :)
08:06:17 <ely-se> hey
08:06:24 <aweinstock> > take 100 . filter isAlpha . filter isAscii $ randoms (mkStdGen 1)
08:06:27 <lambdabot>  "IyIjtvjUUEQGVyIbdZsDHTYEUVZSyrdJgKpdkxgfXnUvjGveiOPYjFBAYegjvCmSxxxEeooPniS...
08:06:46 <ely-se> > let generatePassword = const "hunter2" in generatePassword (mkStdGen 1)
08:06:48 <lambdabot>  "hunter2"
08:06:57 <goodalice> can anyone tell me why neither of these functions infer types correctly? http://lpaste.net/137586
08:06:58 <michaelt> dot_Laptop: http://lpaste.net/137604
08:07:59 <dot_Laptop> pack isn't in Data.Internal.Text
08:08:10 <michaelt> dot_Laptop: OverloadedStrings can take care of the literal "Self" but since addr is a variable for a string, you need the function T.pack . This is not exported by Data.Text.Internal, which shouldn't generally be imported
08:08:16 <merijn> goodalice: The type in the comment shows a RankN types and RankN types are not inferrable
08:08:20 <goodalice> type checks correctly would be more accurate i guess... i've been banging my head against this for a few days :/
08:08:34 <merijn> goodalice: Oh
08:08:37 <goodalice> merijn: yeah, i mispoke
08:08:44 <dot_Laptop> oh
08:08:46 <dot_Laptop> sec
08:09:29 <merijn> goodalice: Well line 14 makes no sense
08:09:52 <merijn> goodalice: as far as I can see superficially
08:10:25 <merijn> goodalice: You're claiming you can take a "P t a" where 'a' is some Num instances and then "grad f" will return any other arbitrary Num instance? That doesn't seem right
08:11:45 <nitrix> Hi, does anyone know why I'm getting those errors? http://whiteboard.debian.net/57de2d.wb
08:13:04 <dot_Laptop> Ihttps://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Internal.html there's no pack in here, will the code still import somehow? I tried compiling with T.pack and still no luck
08:13:26 <goodalice> merijn: so is the integer coming from defaulting? i'm trying to say the function is polymorphic over all Num instances, not some particular unknown one
08:13:37 <dot_Laptop> https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Internal.html
08:14:03 <goodalice> ... so that i'm free to later use it with a 'Reverse s a', or any other type
08:14:17 <michaelt> dot_Laptop: right, just do 'import qualified Data.Text as T'. forget 'Data.Text.Internal' . The error pointed it to you because that is where it is defined; the user only looks at Data.Text which reexports it.
08:15:11 <dot_Laptop> The problem is Network.SMTP.Mail requires Data.Text.Internal. I'll try to circumvent that somehow. 
08:15:48 <michaelt> dot_Laptop: no, they are the same. 
08:16:03 <michaelt> Data.Text.Text is the same type as Data.Text.Internal.Text
08:16:36 <sunnymilk> has anyone here used cairo's Render monad with state
08:16:44 <sunnymilk> ie StateT s Render ()
08:17:10 <michaelt> dot_Laptop: does this compile? http://lpaste.net/raw/179743827286818816
08:18:42 <sunnymilk> http://lpaste.net/137606 this is my code
08:19:01 <sunnymilk> the commented out bits in testdraw, thats what interpret_d should do, but it doesnt for some reason
08:20:14 <sunnymilk> i think it might be because Render isnt commutative or something?
08:20:32 <sunnymilk> but Render is just ReaderT
08:20:35 <sunnymilk> im really confused
08:21:25 <dot_Laptop> michaelt: Oh it compiles!
08:21:27 <sunnymilk> maybe the internal Cairo monad isnt commutative?
08:22:35 <dot_Laptop> Thanks everyone.
08:24:29 <dot_Laptop> I was following links from the SMTP library and assumed Data.Text.Text isn't the same with Data.Text.Internal.Text.
08:25:45 <kadoban> nitrix: It's because of the .ghci in that directory it creates.
08:26:18 <kadoban> nitrix: I'd just ignore them? Or change the .ghci I guess if it really bothers you
08:27:00 <nitrix> kadoban: But why does it creates an erroneous .ghci? Is snap init to blame? Should I report the issue?
08:27:38 <kadoban> nitrix: Well, snap init does create it. I have no idea if it's erroneous or not, I guess you could report it.
08:27:39 <sgronblo> I'm experimenting a bit with ghc-mod. Tried running it on a module for which there should be a file in the cwd but it returns nothing.
08:27:50 <sgronblo> It works for some files but not all
08:27:53 <nitrix> kadoban: I'll see with them. Thanks for figuring it out though :)
08:28:08 <kadoban> nitrix: 'welcome
08:29:23 <sunnymilk> hooray i fixed it, i was in the wrong monad is all
08:29:24 <catgocat> How and where do I do the NICTA haskell course? I've "seen" it on github, but don't know what or where to start??
08:29:26 <sgronblo> oh whoops maybe its because the files have errors?
08:29:45 <catgocat> are there lecture notes or its just the exercises?
08:29:57 <Welkin> wow
08:30:04 <catgocat> How and where do I do the NICTA haskell course? I've "seen" it on github, but don't know what or where to start??
08:30:06 <Welkin> what happened here?
08:30:17 <Welkin> catgocat: oh, you git clone the repo
08:30:24 <dot_Laptop> If a documentation says Text as a type, how can I distinguish them between Lazy Text and Text? Should I just import the Data.Text ?
08:30:27 <Welkin> then open the .hs files and type away
08:30:28 <catgocat> Welkin: and then what
08:30:35 <catgocat> what hs files?
08:30:36 <Welkin> all the information is in the comments
08:30:37 <catgocat> where?
08:30:58 <Welkin> https://github.com/NICTA/course/tree/master/src/Course
08:31:23 <Welkin> implement the missing function definitions
08:31:30 <catgocat> Welkin: so the "course" is basically exercise files?
08:31:35 <Welkin> yes
08:31:55 <Welkin> it provides tests for youto run though
08:31:57 <Welkin> which is great
08:31:58 <Welkin> doctests
08:32:04 <michaelt> dot_Laptop: that haddock documentation doesn't distinguish them, but the only difference is Data.Text and Data.Text.Lazy (each is defined in an *.Internal module) 
08:32:14 <catgocat> Welkin what?
08:32:16 <kadoban> catgocat: See the readme here: https://github.com/NICTA/course
08:32:32 <catgocat> kadoban: I have read it.. doesn't explain how to start
08:32:57 <Welkin> catgocat: https://github.com/NICTA/course#getting-started
08:33:05 <catgocat> Welkin: I said I have read it
08:33:06 <kadoban> catgocat: "Getting Started" … "Tips after having started" … "Progression" …
08:33:09 <Welkin> catgocat: https://github.com/NICTA/course#progression
08:33:23 <Welkin> start by opening Course/Id.hs
08:33:27 <catgocat> but it just seems non-sense. so a course that only offers exercises?
08:33:33 <Welkin> then Course/Optional.hs
08:33:34 <Welkin> and so one
08:33:39 <Welkin> down that list provided in the README
08:33:50 <catgocat> is there anything besides exercises?
08:33:53 <Welkin> catgocat: it is a live course
08:34:00 <Welkin> these are just the exercises
08:34:01 <kadoban> catgocat: Yes it's only exercises. If they're not at the right level, there's other more guided haskell courses, like cis194 spring `13
08:34:03 <catgocat> Welkin: what does that even eman
08:34:07 <catgocat> mean*
08:34:22 <catgocat> kadoban: I have already completed cis194
08:34:23 <Welkin> catgocat: the "course" is taught live, by an instructor, in person, at some kind of event
08:34:33 <Welkin> these are just the course materials
08:34:39 <dot_Laptop> michaelt: How about the performance impact from choosing Lazy or not?
08:34:40 <Welkin> the exercises are stil useful
08:34:49 <kadoban> catgocat: It means they do workshops using that material and work people through it, but it's possible and very benefitial to do it on your own too.
08:34:53 <catgocat> Welkin: by who? I am a self learner
08:35:06 <Welkin> catgocat: and?
08:35:14 <Welkin> do the exercises
08:35:35 <Welkin> if you have completed cis194, it should be straight forward
08:35:59 <kadoban> Well … it's not an easy course, but it is rewarding.
08:36:04 <Welkin> like I said, test cases are provided
08:36:19 <Welkin> you can check your work easily by running the tests
08:36:29 <michaelt> dot_Laptop: they have different tradeoffs. for example "cons 'a' old_text" has to rewrite the whole 'strict' text, but is trivial with lazy text
08:36:33 <Welkin> if you have trouble, ask in #haskell-beginners 
08:37:03 <kadoban> There's also #nicta-course , though it's pretty tiny.
08:37:06 <Welkin> bitemyapp also provides answers, which I don't recommend looking at until you finish the assignment
08:37:11 <catgocat> Welkin: what? test cases where??
08:37:17 <catgocat> here? https://github.com/NICTA/course/tree/master/test
08:37:18 <Welkin> catgocat: inside each file
08:37:22 <Welkin> it's all self contained
08:37:25 <kadoban> catgocat: Are you sure you read the readme? …
08:37:28 <Welkin> doctests
08:37:34 <catgocat> I'm confused, the Id file doens't have anything to do
08:37:56 <Welkin> catgocat: yes... if you read the README you could know that the Id, Optional and Validation files are for reference
08:38:03 <Welkin> read and understand them
08:38:18 <Welkin> the first exercise file is List.hs
08:38:18 <catgocat> reference for what? they don't explain anything (although I understand it)
08:38:30 <Welkin> reference for use in the exercises
08:38:52 <Welkin> later exercises rely on earlier ones
08:39:08 <dot_Laptop> michaelt: Alright, thank you once more for your assistance and time (and patience :) ).
08:39:17 <michaelt> dot_Laptop: oh, sure
08:41:16 <catgocat> Welkin: So I walk through the exercises and if I don't understand something I ask or go search for it?
08:41:26 <catgocat> Is that how this course is supposed to work without instructor
08:41:57 <kadoban> catgocat: Essentially, yeah.
08:42:41 <Welkin> catgocat: this is why #haskell-beginners exists
08:43:47 <kadoban> catgocat: typeclassopedia could also be quite helpful
08:44:04 <catgocat> How do I check my solutions ?
08:44:42 <Welkin> catgocat: read the README under "running the tests"
08:45:02 <kadoban> catgocat: Run the tests, ask, check the provided answers (though sometimes there's multiple ways and I didn't really like the provided answer)
08:45:33 <aznashwan> :t liftM
08:45:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:46:28 <bitemyapp> @pl f p' vs = p' & .~ vs
08:46:29 <lambdabot> (line 1, column 10):
08:46:29 <lambdabot> unexpected " "
08:46:29 <lambdabot> expecting operator
08:46:45 <bitemyapp> lens breaks lambdabot, news at 11
08:47:02 <quchen> Two infix operator right after each other break Haskell.
08:47:26 <bitemyapp> oh dang, I'm forgetting my lens
08:47:29 <bitemyapp> fack
08:47:29 <quchen> :-)
08:47:32 <bitemyapp> @pl f p' vs = p' & f .~ vs
08:47:32 <lambdabot> (line 1, column 19):
08:47:32 <lambdabot> unexpected "~"
08:47:32 <lambdabot> expecting white space
08:47:32 <lambdabot> ambiguous use of a right associative operator
08:47:34 <bitemyapp> @pl f p' vs = p' & f' .~ vs
08:47:35 <lambdabot> (line 1, column 20):
08:47:35 <lambdabot> unexpected "~"
08:47:36 <lambdabot> expecting white space
08:47:38 <lambdabot> ambiguous use of a right associative operator
08:47:44 <bitemyapp> srsly
08:47:53 <Welkin> bitemyapp: your website is gone
08:47:56 <quchen> üq lambdabot 
08:48:35 <bitemyapp> Welkin: what?
08:48:42 <geekosaur> not like @pl is very smrt
08:48:47 <geekosaur> [sic]
08:49:04 <Welkin> oh
08:49:12 <bitemyapp> Welkin: ???
08:49:18 <Welkin> bitemyapp: your www. subdomain is just a blank nginx start page
08:49:43 <Welkin> I see
08:49:51 <Welkin> I went to www. instead of the root
08:49:58 <bitemyapp> Welkin: oh, I should fix that though. Thank you.
09:09:59 <davean> Welkin: people do that?
09:14:00 * hackagebot hsqml-datamodel-vinyl 0.1.0.0 - HsQML DataModel instances for Vinyl Rec.  https://hackage.haskell.org/package/hsqml-datamodel-vinyl-0.1.0.0 (mjmrotek)
09:15:30 <meditans> Hi all, I have a question: I'm writing a tool to analyze source code of a package, which uses haskell-src-extra.
09:15:51 <meditans> now, the libraries actually contain some extra stuff (for example, cpp directives)
09:16:31 <meditans> what is the modern way to preprocess the package (configuring for the environment, running the cpp ecc) to obtain code which
09:16:40 <meditans> is guaranteed to be parsed by haskell-src-extra?
09:17:05 <meditans> Could you point me towards some examples?
09:19:00 * hackagebot propellor 2.7.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.7.0 (JoeyHess)
09:22:48 <humanoyd> What does "In-place registering <package>..." mean when I "cabal build"...I think I've never seen this message before
09:22:54 <ttt_fff> why can't I defined this type? stateModWith :: Lens' s b -> b -> RWS r w s a -> RWS r w s a
09:23:03 <ttt_fff> what is it about "Lens' a b" that does not allow me to specify it as a type?
09:23:54 <Saizan> ttt_fff: error message?
09:24:00 * hackagebot shelly 1.6.3.3 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.3.3 (GregWeber)
09:24:05 <ttt_fff>  Illegal polymorphic or qualified type: Lens' s b Perhaps you intended to use RankNTypes or Rank2Types In the type s                                                                                  │ignature for ‘stateModWith’: stateModWith :: Lens' s b -> b -> RWS r w s a -> RWS r w s a  
09:24:16 <ttt_fff> Saizan: ^ sorry, for not posting it earlier
09:24:32 <Saizan> ttt_fff: yeah, you need RankNTypes
09:24:35 <geekosaur> looks to me like it told you what it was about the type
09:24:51 <ttt_fff> I've never used RankNTypes
09:24:56 <ttt_fff> wtf are they, why do I need them, and how do I get them?
09:25:13 <johnw> you need them because Lens' is a polymorphic function
09:25:13 <geekosaur> {-# LANGUAGE RankNTypes #-}
09:25:18 <johnw> but instead of using RankNTypes, use LensLike
09:25:20 <johnw> that's what it's for
09:25:53 <johnw> you'll need to clone the lens to actually use it, but you won't need to deal with the hidden polymorphism
09:26:10 <ttt_fff> LensLike takes 4 args
09:26:14 <johnw> LensLike'
09:26:24 <ttt_fff> I have no idea what any of this means yet.
09:26:44 <johnw> so, in Haskell we have functions as first-class values
09:26:48 <johnw> so you can pass functions to functions
09:27:00 <johnw> what Haskell 2010 doesn't have is polymorphic functions as first-class values
09:27:10 <johnw> but RankNTypes enables that
09:27:36 <johnw> that way, you can have a function 'foo' accept a polymorphic function that it can use for whatever types it wants; further, the function *must* be polymorphic
09:27:42 <johnw> this restricts what the caller can pass in
09:28:40 <ttt_fff> https://gist.github.com/anonymous/4b96afd1c183d2653bb9 <-- is it possible you can help me get this code to compile?
09:28:54 <ttt_fff> I think a working example would help me understand what the parts that I don't understand yet fits together
09:29:04 <johnw> you need to clone the lens to use it
09:29:19 <johnw> this should be mentioned somewhere near the documentation for LensLike'
09:29:47 <ttt_fff> what does it mean to "clone the lens"
09:29:54 <ttt_fff> I understand the individual words, but the phrase makes no sense
09:30:55 <johnw> there is a function, cloneLens
09:31:02 <johnw> a LensLike' goes in, a Lens' comes out
09:33:41 <ttt_fff> alright, I am stuck
09:33:46 <ttt_fff> where is Lens' and LensLike' even documented?
09:33:49 <ttt_fff> I can't find documentation for either
09:34:32 <johnw> the type is at http://hackage.haskell.org/package/lens-4.12.2/docs/Control-Lens-Type.html
09:35:21 <johnw> and http://hackage.haskell.org/package/lens-4.12.2/docs/Control-Lens-Lens.html#t:ALens for cloneLens
09:35:38 <johnw> you should use ALens, which is a specialized LensLike
09:36:26 <ttt_fff> johnw: I thikn I almost have it. I have one more dumbass question. Lens' is "Lens' s a". "LensLike' f s a" . What am I supposed to pass for the "f" ?
09:36:35 <johnw> use ALens'
09:36:41 <johnw> sorry, I forgot that LensLike is the more general version
09:39:03 <shachaf> The right type to use is probably whatever GHC infers.
09:39:17 <ttt_fff> johnw: okay, I'm almost there
09:39:30 <ttt_fff> johnw: and how do I convert an "ALens'" into a "Lens'" is this the "cloning" you speak of?
09:39:35 <johnw> yes
09:39:58 <shachaf> If you can get away with using something more specific than ALens, you should.
09:40:22 <ttt_fff> ah, cloneLens; okay
09:40:23 <johnw> you can either clone, or use the special combinators like ^#, or what shachaf is saying
09:40:46 <shachaf> What shachaf is saying is to use whatever type ghci tells you your function has.
09:41:04 <shachaf> If that doesn't work, probably ALens.
09:41:28 <ttt_fff> https://gist.github.com/anonymous/35d70f2fffa381421a5e still does not compile yet
09:43:01 <arkeet> well, you can't just substitute Lens' with LensLike'.
09:43:30 <ttt_fff> ah
09:43:31 <ttt_fff> got it working
09:43:45 * arkeet reposting the original question for convenience: <ttt_fff> why can't I defined this type? stateModWith :: Lens' s b -> b -> RWS r w s a -> RWS r w s a
09:44:06 <arkeet> pretty sure you don't actually need a Lens to do this, any Setter would do.
09:44:29 <ttt_fff> arkeet , shachaf , johnw: okay, got function to type check!
09:44:31 <ttt_fff> thanks for all the help!
09:44:32 <arkeet> so if you just want to ask for a setter, take ASetter' s b as an argument.
09:44:37 <ttt_fff> even though I still have no idea why the fuck ghc is now happy
09:45:12 <arkeet> (or perhaps ASetter s s b' b)
09:47:34 <wingrime> stupid question why let fib a = fib (a -1 ) + fib (a - 2) have a type fib :: (Num a, Num a1) => a1 -> a
09:47:48 <wingrime> not just Num a -> Num a
09:48:14 <arkeet> there's no reason the input and output types must be the same.
09:48:40 <johnw> note that the type of 'a' never "passes through" fib in any way
09:48:51 <ttt_fff> :t f a = f (a-1) + f(a-2)
09:48:52 <lambdabot> parse error on input ‘=’
09:49:02 <ttt_fff> :t let f a = f(a-1) + f(a-2) inf
09:49:03 <lambdabot> <no location info>:
09:49:03 <lambdabot>     not an expression: ‘let f a = f(a-1) + f(a-2) inf’
09:49:04 <ttt_fff> :t let f a = f(a-1) + f(a-2) in f
09:49:05 <lambdabot> (Num a, Num a1) => a1 -> a
09:49:05 <geekosaur> isn't it really saying there that it detected nonterminating recursion?
09:49:22 <arkeet> geekosaur: there is no such ability for detection.
09:49:35 <geekosaur> yes, I phrased that wrong
09:49:42 <int-e> :t let f a = f(a-1) + f(a-2); f 0 = 0; f 1 = 1 in f
09:49:43 <lambdabot> (Eq a1, Num a, Num a1) => a1 -> a
09:49:47 <int-e> geekosaur: no :)
09:49:47 <arkeet> and it's also unrelated.
09:49:59 <arkeet> int-e: f (-1)  ;-)
09:50:04 * geekosaur thinking of the type of fix
09:50:04 <wingrime> geekosaur: you can define specilazed version for 0 and 1
09:50:06 <int-e> arkeet: not the point
09:50:08 <arkeet> I know :)
09:50:31 <geekosaur> never mind, I sent everyone off on a tangent and the point I wanted to make is now lost
09:51:09 <wingrime> anyway who can say what (Eq a1, Num a, Num a1) => a1 -> a
09:51:15 <wingrime> means ?
09:51:22 <geekosaur> (a is like in fix, because effectively bottom has any type.. .,but the result of fix is used so it gets a Num constraint, because it's not actually handled specially)
09:51:45 <geekosaur> s/of fix/of fib/
09:52:02 <arkeet> wingrime: it means it's a function from any type "a1" to any other type "a", provided that "a1" is an instance of Eq and Num, and "a" is an instance of Num
09:52:03 <kadoban> wingrime: It's a function that takes a1, which is an instance of both Eq and Num, and gives you an 'a', which is an instance of Num
09:52:10 <arkeet> Eq and Num are type classes
09:52:24 <arkeet> so those are the thing to read about here
09:53:13 <wingrime> kadoban: good
09:53:51 <wingrime> kadoban: so that means, type a1 should have instance of Eq and Num defined?
09:54:54 <kadoban> Yes, it has to be an instance of those typeclasses. So yeah there's an instance defined.
09:54:57 <wingrime> kadoban: thats because I have used comparsion and '+'
09:55:20 <wingrime> kadoban: and seems comparsion used indirectly
09:55:34 <wingrime> by constructor matching
09:55:36 <kadoban> wingrime: (==) or (/=) will get you Eq, yeah. Directly or indirectly.
09:57:51 <wingrime> kadoban: and if I define specilazed version, for example fib 0 = 0 , I use it indirectly
09:58:04 <wingrime> kadoban: not look so oblivious
09:58:59 <kadoban> wingrime: Yeah, that pattern requires checking if they're (==) I suppose.
09:59:20 <Fylwind> wish there was a way to "show" things that may or may not have a Show instance just for debugging purposes
09:59:35 <nitrix> How does haskell enforces linearity with implicit duplication? Anyone could duplicate a resource received as an argument, making the language non-functional. Does Haskell have anything at the type level to allow or disallow copying?
09:59:44 <nitrix> Also, I assume those types are somewhat magical?
09:59:49 <lpaste_> voidnoid pasted “Is there a better or non-recursive way to do this?” at http://lpaste.net/2653469772297011200
09:59:52 <ttt_fff> in the context of StateMOnad, is there a variant of modify which does the modify, _and returns the old value_ 
10:00:04 <Fylwind> nitrix: Haskell doesn't have linear types
10:00:40 <voidnoid> so, after reading through most of http://www.seas.upenn.edu/~cis194/spring13/lectures.html
10:00:45 <nitrix> Fylwind: Then would you mind providing an answer? I'm curious how it works.
10:00:53 <voidnoid> it says that one can often do things without recursion
10:01:07 <voidnoid> is there a way to do that above without recursion?
10:01:12 <Fylwind> nitrix: how what works?
10:01:23 <nitrix> Fylwind: Preventing implicit duplication.
10:01:56 <Fylwind> nitrix: I'm not entirely sure what that is … can you give an example?
10:02:05 <wingrime> kadoban: looks like sugar , Can I use matching with custom operator not just (==) ?
10:02:15 <wingrime> kadoban: or ":"
10:02:23 <nitrix> Fylwind: dup x = (x, x)
10:02:45 <Fylwind> that is perfectly legal
10:02:54 <nitrix> Fylwind: If x is a resource like a file handle or a socket or anything sensible (mostly IO), then you'd have two copies of the same resource.
10:02:57 <kadoban> wingrime: Pattern matching usually operates on constructors. (:) is a constructor … so you can use any constructor, though they're not operators.
10:03:20 <Zemyla> Okay, question. Your standard random monad is a StateT g, where g is a RandomGen, right?
10:03:27 <Fylwind> nitrix: yes you can duplicate file handles (and other resources)
10:04:02 <nitrix> Fylwind: But then, if one function uses the resource, the other becomes invalidated...
10:04:12 <Fylwind> nitrix: Haskell's purity only prevents you from altering the handle itself, not the actual resource
10:04:51 <voidnoid> or really, can anyone think of a generally "more haskell" way of doing this?
10:04:57 <kadoban> wingrime: It's a little confusing because (:) is sugary itself … you usually can't have constructors that look like that. They look like  SomeConstructor.   Like: 'Just' and 'Nothing' are the constructors for the 'Maybe a' type
10:05:01 <voidnoid> like is that way pretty "idiomatic" for haskell or are there better options?
10:05:09 <Fylwind> nitrix: yes, it does; Haskell does not prevent use-after-close errors
10:05:18 <Fylwind> because it does not have a linear type system
10:05:33 <nitrix> I see.
10:06:03 <Zemyla> kadoban: Constructors in Haskell can look like one of two things: Either a word starting with a capital letter, or an operator starting with a colon.
10:06:35 <wingrime> Zemyla: example of second please
10:06:49 <Zemyla> So : is a constructor, as are :<, :*, and :$#!+.
10:07:28 <kadoban> Zemyla: Thanks, I actually didn't know that. I've only seen (:)
10:07:32 <Zemyla> Look in Data.Sequence, in containers. ViewL and ViewR are examples of the latter.
10:07:33 <ttt_fff> is there anything I should be aware of when using ghci + template haskell (i.e. makeLenses ... ) ?
10:08:01 <Fylwind> nitrix: There are some hacks you can use to do resource management in Haskell (regions) that does avoid the use-after-close problem, but I personally find them too heavyweight
10:09:03 <Fylwind> nitrix: AFAIK there aren't many languages with linear(-ish) type systems out there … Rust, Cyclone, Clean
10:10:07 <wingrime> kadoban: It's hard to understand what thigs are harcoded in lang 
10:10:25 <wingrime> kadoban: and things thats just defined
10:10:25 <nitrix> Fylwind: Well, I found Control.Linear that's trying, but yeah, they are fairly rare.
10:10:39 <nitrix> Fylwind: I'm asking because I'm working on a toy language.
10:11:21 <nitrix> Fylwind: Joy / Cat / XY inspired. It's more or less a RPN version of linear lambda-calculus, but usuable.
10:12:09 <nitrix> Not sure yet where it'll get, but I was curious. So linearity is apparently not _that_ critical.
10:12:15 <Fylwind> nitrix: without proper support at the language level linear types in Haskell is going to be very awkward
10:12:45 <Fylwind> nitrix: it depends … for low level stuff it is kind of critical, hence Rust
10:13:18 <Fylwind> since use-after-free can lead to memory corruption, security vulnerabilities etc
10:14:23 <Fylwind> but if you are in a high level language you can "avoid" the severe problems by doing runtime checks (having a GC helps too), so you pay a performance penalty but get more expressiveness (because linear types can be very constraining)
10:15:57 <wingrime> any one can explain how side effects added to IO Monad ? (it's maybe not correctly saying that way...))
10:16:08 <voidnoid> I don't really see how I can do various things non-recursively
10:16:18 <voidnoid> seems like recursion is the only real option in several cases
10:17:13 <kadoban> wingrime: What kind of material are you using to learn haskell? It's probably not easy to really explain IO in isolation … at first you can just use it, and learn the basic do notation or combinators (>>, >>=, <$>, etc.)
10:17:28 <Miniflop> can anybody help me on this issue? http://stackoverflow.com/questions/31730021/combine-unknown-number-of-formresults
10:17:36 <kadoban> wingrime: As you understand more how everything ties together, it's kind of naturally explained.
10:20:50 <wingrime> kadoban: it seems I just not  suggest correct after reading
10:21:08 <wingrime> kadoban: not every time
10:21:48 <wingrime> kadoban: for my point of view, >>= and >> just combine actions to single pipeline
10:23:08 <wingrime> kadoban:  do notations just sugar makes it looks like old classic langs
10:23:12 <kadoban> wingrime: That's close enough for basic usage. I'm not sure what level of haskell you're at or what course/guide/whatever you're reading.
10:23:44 <ElMoloko> Hey, do any of you know anything about Frege? "the haskell for the JVM"?
10:24:33 <wingrime> kadoban: learn haskell for great good , nothing much ezoteric
10:25:31 <kadoban> wingrime: LYAH is not the best really, the problem is that it doesn't have any exercises. Have you looked at https://github.com/bitemyapp/learnhaskell ?
10:25:47 <levi> ElMoloko: It's interesting, but just enough different from Haskell that most Haskellers wouldn't use it, and IIRC it doesn't have great performance due to the very different execution model than Java.
10:26:16 <kadoban> It'd be more interesting if it was ghcjvm
10:27:05 <ElMoloko> Interesting
10:27:24 <ElMoloko> Yeah, I'm working on a project in Haskell
10:27:47 <ElMoloko> and now I learn that the person who needs it wants it to run on the JVM
10:27:52 <wingrime> kadoban: thanks, I will take a look
10:28:24 <ElMoloko> ghcjvm was what I hoped Frege was
10:30:05 <kadoban> Why do they want it to run on the JVM specifically? You can do pretty decent cross-platform just in haskell.
10:36:10 <mizu_no_oto> ElMoloko: there's also Ermine, though edwardk could say more about how that's coming along.
10:37:37 <wingrime> kadoban: http://www.seas.upenn.edu/~cis194/spring13/lectures.html looks nice
10:40:39 <kadoban> wingrime: Yeah I like that course quite a bit. It goes quite quickly through some stuff though, so feel free to ask questions and read other materials to flesh it out.
10:47:11 <wingrime> kadoban: big parts of Prelude mostly have no examples of usage, parameters description, thats normal to use type as full description of usage? 
10:48:14 <aweinstock> voidnoid: invest amount contribution years rate = iterate (\x -> x * rate + contribution) amount !! years
10:48:35 <aweinstock> (if I understand it correctly)
10:48:48 <kadoban> wingrime: You can get /quite/ far just based on the types, yeah. I'm sure there's some plain old-fashioned lacking documentation though … so a little of both. Anything you were looking at in particular?
10:49:07 <kadoban> wingrime: (Being able to tell how things behave based on the type comes with practice, it'll be obvious with time)
10:49:40 <aweinstock> the recursion is still there, but it's encapsulated inside iterate (a standard higher-order function)
10:49:43 <aweinstock> @src iterate
10:49:43 <lambdabot> iterate f x = x : iterate f (f x)
10:55:32 <wingrime> kadoban: no realy particular, Just last time I wanted to try some data type, It was painfull to understand how it use correctly
10:56:52 <wingrime> kadoban: and when some web parsing lib has used Arrows, thats not so usual
10:57:31 <kadoban> wingrime: Yes, that can make it tough for a beginner. In not too long you'll find that much clearer though.
11:02:55 <gaze__> Hey folks, what's the closest to metal I can get within a haskell program? Is there a way to inline Cmm or make my own primops or something?
11:03:28 <dolio> You can write things in cmm and foreign import them.
11:03:41 <johnw> you can also write your function in assembly, embed it in a C function, and use the FFI to call it
11:03:59 <johnw> i've done that to make use of specific Intel instructions
11:04:02 <ww> ReinH: ok, left factoring... does make the parser a bit uglier though... but it works...
11:04:04 <hodapp> dolio: you can write directly in Cmm? I didn't know that
11:04:31 <ww> i would have thought that attoparsec was supposed to keep enough of the input tape to do backtracking itself though, so i'm not sure why i had to do this...
11:04:33 <gaze__> well... I'd like to ensure that my low level stuff is inlined.
11:04:40 <dolio> There are also libraries that will allow you to dynamically compile assembly into Haskell functions.
11:05:01 <dolio> As I recall.
11:05:04 <gaze__> I've seen some template haskell stuff that generates a c file and then generates the linkages
11:05:06 <gaze__> but I don't want that
11:05:40 <gaze__> I want to control the code the compiler shoots into the place where my new op is utilized
11:05:42 <gaze__> is that possible?
11:05:49 <gaze__> something as close as possible to a gcc asm directive
11:06:51 <aweinstock> :t GHC.Magic.inline
11:06:52 <lambdabot> a -> a
11:07:20 <aweinstock> (I don't know if that does anything to imported C functions, but it might be worth trying and inspecting the assembly?)
11:10:52 <dolio> inline works at the Haskell/core level.
11:11:19 <gaze__> hmm looks like primops are totally internal
11:12:33 <gaze__> oH!
11:12:38 <gaze__> foreign import prim
11:12:40 <gaze__> naice.
11:13:17 <Zemyla> Can you pass a ByteArray# directly to a foreign import prim, or do you have to pass it as an Addr#?
11:22:13 <voidnoid> aweinstock: ooh, interesting thanks
11:23:24 <voidnoid> aweinstock: what does th !! do?
11:23:28 <voidnoid> the*
11:23:30 <aweinstock> :t (!!)
11:23:31 <lambdabot> [a] -> Int -> a
11:23:43 <aweinstock> indexed lookup into a list
11:23:55 <aweinstock> > [1..]  !! 5
11:23:56 <lambdabot>  6
11:24:07 <Welkin> it's not a total function though
11:24:16 <aweinstock> > [] !! 0
11:24:17 <lambdabot>  *Exception: Prelude.!!: index too large
11:24:18 <Welkin> > [] !! 1
11:24:19 <lambdabot>  *Exception: Prelude.!!: index too large
11:24:28 <aweinstock> > [1..] !! (-1)
11:24:29 <lambdabot>  *Exception: Prelude.!!: negative index
11:24:38 <Welkin> also, list indexing is a bad idea generally
11:24:49 <Welkin> you're probably using the wrong data structure if you want to index the list
11:25:12 <aweinstock> Welkin: the context was this: invest amount contribution years rate = iterate (\x -> x * rate + contribution) amount !! years
11:25:44 <aweinstock> is that an appropriate use of (!!)?
11:26:28 <Welkin> I don't see anything horribly wrong with it
11:28:59 <voidnoid> aweinstock: hmm, would you mind explaining what that means :)
11:29:46 <voidnoid> Welkin: this was the original question about which aweinstock and I were speaking http://lpaste.net/2653469772297011200
11:29:55 <aweinstock> :t iterate
11:30:13 <voidnoid> mostly I'm just starting to learn haskell and I understand that, as with many things, the old ways I'm used to doing things aren't always the best
11:30:18 <aweinstock> lambdabot's taking a while to respond...
11:30:27 <voidnoid> I was just wondering if there was a "more idiomatic" way to do something like that in haskell
11:30:50 <aweinstock> iterate takes a function and an initial value, and builds up a list of successive applications
11:30:54 <voidnoid> e.g. I've read in the bitemyapp course that it's often possible to do things not using recursion
11:30:59 <voidnoid> and that avoiding recursion is better
11:31:10 <aweinstock> iterate (*2) 1 = [1,2,4,8,16,...]
11:31:15 <voidnoid> aweinstock: ahh ok, that generally makes sense
11:31:26 <voidnoid> that's cool
11:31:43 <Welkin> voidnoid: these functions are recursive underneath
11:32:00 <Welkin> but using these higher-level abstractions is easier to reason about
11:32:01 <voidnoid> Welkin: er, which functions do you mean by "these functions?"
11:32:09 <Welkin> voidnoid: iterate, folds, etc.
11:32:14 <voidnoid> Welkin: ah, right ok
11:32:16 <aweinstock> so that builds the list of the interest at each year, then (!!) dereferences to get the final amount in the specified year
11:32:23 <voidnoid> so recursion is still pretty common and fundamental?
11:32:46 <Welkin> voidnoid: yes, it is fundamental
11:32:55 <voidnoid> cuz I was a bit confused as to how and when it's actually possible to achieve various functionality not using recursion when the course says don't use recursion
11:32:59 <aweinstock> it's fundamental in the sense that you can literally express any computable function with it
11:33:08 <Welkin> even though the recursive calls are optimized into loops during compilation
11:33:16 <Welkin> tail call optimization
11:33:16 <aweinstock> (e.g. lambda calculus, the Y combinator)
11:33:30 <voidnoid> hmm, I guess maybe I misunderstood
11:33:39 <voidnoid> http://www.seas.upenn.edu/~cis194/spring13/lectures/03-rec-poly.html states "In fact, experienced Haskell programmers hardly ever write recursive functions!"
11:33:40 <Welkin> voidnoid: well, they probably mean "don't use explicit recursion"
11:33:46 <Welkin> then you will probably use a fold of some kind
11:33:49 <voidnoid> is that simply because they use the already existing methods like fold/iterate?
11:34:08 <voidnoid> i.e. basically meaning they don't "write their own" but rather use the already existing high level recursive things
11:34:09 <voidnoid> ?
11:34:17 <aweinstock> voidnoid: exactly
11:34:27 <voidnoid> ok, cool that makes much more sense now :)
11:35:10 <lambdabot> (a -> a) -> a -> [a]
11:35:30 <Yuu-chan> Who is going to take part in ICFPC?
11:36:24 <aweinstock> voidnoid: consider how much clearer "iterate (*2) 1" is compared to "let x = 1:map (*2) x in x"
11:36:51 <voidnoid> aweinstock: yeah for sure
11:37:07 <aweinstock> (and the latter is still using map)
11:37:10 <aweinstock> @src map
11:37:16 <lambdabot> map _ []     = []
11:37:22 <lambdabot> map f (x:xs) = f x : map f xs
11:37:36 <aweinstock> :t fix
11:37:44 <lambdabot> (a -> a) -> a
11:39:36 <voidnoid> > let x = 1:map (*2) x in x
11:39:44 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:39:51 <arkeet> > fix ((1:) . map (*2))
11:39:58 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:43:52 <voidnoid> lol, wow, let x = 1:map (*2) x in x is warping my brain right now :)
11:44:17 <voidnoid> how exactly does that evaluation chain, uhh... "work" for lack of a better term?
11:44:32 <Gurkenglas> Now where's that picture arkeet drew up once
11:44:33 <voidnoid> like the first evaluation, it sees 1:map (*2) ?
11:44:43 <voidnoid> what is the question mark?
11:45:02 <voidnoid> 1:map (*2) 1:map (*2) 1:map (*2)
11:45:08 <voidnoid> doesn't quite make sense in my brain
11:45:29 <voidnoid> does that get evaluated right to left? left to right?
11:45:38 <voidnoid> seems like it actually has to get evaluated left to right, correct?
11:46:13 <Gurkenglas> Aha, I can't find the log where arkeet posted it, but I can find where I posted the link last time I found it!
11:46:27 <Gurkenglas> voidnoid, http://puu.sh/isDAc/a70bc263c5.jpg
11:48:14 <voidnoid> hmm, that kinda helps for me, but still, my next question amounts to:
11:48:16 <voidnoid> > let x = 1:(*2) in x
11:48:17 <lambdabot>      Couldn't match expected type ‘[a1]’
11:48:17 <lambdabot>                  with actual type ‘Integer -> Integer’
11:48:17 <lambdabot>      Relevant bindings include x :: [a1] (bound at <interactive>:1:5)
11:48:49 <Welkin> a list must contain all the same type
11:48:52 <voidnoid> i.e. the first time through the evaluation, is the arrow maybe supposed to point in the other direction?
11:49:04 <voidnoid> what does the "dot" in that picture represent?
11:49:07 <aweinstock> > let x = 1:x in x
11:49:08 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:49:33 <voidnoid> hahah, cool
11:49:52 <voidnoid> ok, so IMO I think the arrow should be pointing the other direction, but I think I get it
11:50:05 <Gurkenglas> voidnoid, when arkeet first posted that he said this explains the notation: http://www.vex.net/~trebla/haskell/lazy.xhtml
11:50:33 <voidnoid> > let x = 1:(*2) x in x
11:50:34 <lambdabot>      No instance for (Show a0)
11:50:34 <lambdabot>        arising from a use of ‘show_M30545394436837719649155’
11:50:34 <lambdabot>      The type variable ‘a0’ is ambiguous
11:51:00 <voidnoid> > let x = 1:((*2) x) in x
11:51:01 <lambdabot>      No instance for (Show a0)
11:51:01 <lambdabot>        arising from a use of ‘show_M22144356642485355609168’
11:51:01 <lambdabot>      The type variable ‘a0’ is ambiguous
11:51:09 <Iceland_jack> voidnoid: Do you know what (* 2) is?
11:51:14 <voidnoid> Gurkenglas: holy cow, ok I've put that on my reading list
11:51:29 <Iceland_jack> '(* 2) x' is 'x * 2'
11:51:33 <voidnoid> Iceland_jack: I sort of think I do
11:51:38 <voidnoid> yeah thats what I thought it was
11:51:47 <voidnoid> let x = (*2) 3 in x
11:51:51 <voidnoid> > let x = (*2) 3 in x
11:51:53 <lambdabot>  6
11:52:03 <Iceland_jack> but '1 : (x * 2)' isn't sright
11:52:04 <Gurkenglas> What he said was "first read http://www.vex.net/~trebla/haskell/lazy.xhtml (at least understand the notation)", so it's probably enough to skim it for the explanation of the notation if that makes you understand it
11:52:05 <Iceland_jack> *right
11:52:33 <Zemyla> > let x = 1:(map (*2) x) in x
11:52:34 <voidnoid> let x = 1:[(*2) 3] in x
11:52:34 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:52:40 <voidnoid> > let x = 1:[(*2) 3] in x
11:52:42 <lambdabot>  [1,6]
11:52:51 <Iceland_jack> > 1:[(* 2) 3]
11:52:52 <lambdabot>  [1,6]
11:53:46 <Gurkenglas> :t (* 2)
11:53:47 <lambdabot> Num a => a -> a
11:54:12 <Gurkenglas> (* 2) takes a thing that can be multiplied by 2 (that and a few other things is what "Num a" says) and multiplies it by 2
11:54:18 <Gurkenglas> @instances Num
11:54:20 <lambdabot> (Data.Fixed.Fixed a), (Shrink2 a), Blind a, CReal, Complex a, Double, Expr, Float, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Natural, Product a, Ratio a, Small a, Sum a, Sym a, Word, Word16, Word32, Word64, Word8
11:54:42 <Gurkenglas> Int, for example is in there. [Int], the list of ints, is not
11:54:45 <Gurkenglas> :t map
11:54:46 <lambdabot> (a -> b) -> [a] -> [b]
11:54:57 <Iceland_jack>     (* 2) :: Int   -> Int
11:54:57 <Iceland_jack>     (* 2) :: Float -> Float
11:55:27 <Gurkenglas> map takes a function, and applies it to each element in a list. That's how we can get (* 2) to operate on a list of numbers.
11:56:26 <juri_> how do i write a pair of functions with the same name that do something different based on the datatype they're operating on?
11:56:57 <Zemyla> juri_: Like overloadin
11:57:06 <Zemyla> *overloading?
11:57:10 <juri_> yepyep.
11:57:10 <Iceland_jack> juri_: Can you give detail
11:57:35 <Cale> juri_: This is what type classes are for
11:57:41 <juri_> i need to store a float to a file, and if i have a double instead, i need to convert it.
11:58:02 * Iceland_jack . o O ( XY? )
11:58:55 <juri_> right now i have "float32LE :: Float -> Write\nfloat32LE = writeStorable . LE"
11:59:07 * hackagebot nested-routes 3.2.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-3.2.0 (athanclark)
12:00:44 <juri_> but i am upgrading the internals of this program to use Double..
12:01:41 <juri_> and i'd like to handle it by just changing the one definition, and supporting double or float in float32LE..
12:02:25 <Cale> :t realToFrac
12:02:27 <lambdabot> (Fractional b, Real a) => a -> b
12:02:49 <Iceland_jack> :t realToFrac :: Float -> Double
12:02:50 <lambdabot> Float -> Double
12:02:56 <Iceland_jack> :t realToFrac :: Double -> Double
12:02:58 <lambdabot> Double -> Double
12:03:03 <Iceland_jack> juri_: That's one way
12:04:01 <juri_> but i need the other way. float or double to float.
12:04:07 * hackagebot kmeans-vector 0.3.2 - An implementation of the kmeans clustering algorithm based on the vector package  https://hackage.haskell.org/package/kmeans-vector-0.3.2 (AlpMestanogullari)
12:04:17 <Cale> :t realToFrac :: Double -> Float
12:04:18 <lambdabot> Double -> Float
12:04:23 <Cale> :t realToFrac :: Float -> Float
12:04:24 <lambdabot> Float -> Float
12:04:26 <Peaker> Why does the monad-statevar package not have "new"? :(
12:04:26 <Iceland_jack> juri_: Going from Double to Float loses information, is that what you want?
12:04:35 <Peaker> Also missing fundep from ref-type to its monad type
12:04:40 <juri_> yes. it's a file format thing.
12:06:41 <arkeet> just use realToFrac then. 
12:06:45 <arkeet> to convert any Real type to Float
12:06:55 <arkeet> (including Float and Double)
12:07:15 <juri_> ok. thanks. :)
12:07:48 <arkeet> but
12:08:10 <arkeet> oh, your finished program is only going to be using Double.
12:08:22 <arkeet> oh, then you know you just need to convert Double to Float.
12:08:44 <arkeet> (and don't need to support float.) 
12:08:51 <arkeet> realToFrac anyways.
12:09:41 <juri_> hmm.
12:10:09 <juri_> pardon me if i'm new to this, but..
12:10:18 <juri_> right now i have "float32LE :: Float -> Write\nfloat32LE = writeStorable . LE"
12:10:35 <jle`> is there a drop-in parallel version of `fold` or `mconcat` somewhere in a library?
12:10:47 <juri_> how do i realToFrac a value that i'm not handling in the function?
12:11:47 <shachaf> hi jfischoff
12:12:01 <arkeet> juri_: huh?
12:12:21 <sw17ch> Do any stack users here know when binaries are placed in .local/bin?
12:12:23 <arkeet> juri_: just compose with realToFrac
12:12:31 <arkeet> (and change the type annotation to use Double)
12:12:43 <arkeet> or something.
12:13:11 <jfischoff> shachaf: hey!
12:13:34 <juri_> ... compose?
12:14:08 <jle`> writeStorable . LE . realToFrac
12:14:21 <juri_> that blows up.
12:14:38 <jle`> composition = (.)
12:14:43 <jle`> what's the error?
12:14:50 <juri_> No instance for (HasLittleEndian b0)
12:15:00 <jle`> what was the error before?
12:15:34 <arkeet> what's the full error? lpaste?
12:15:34 <juri_> really, that's the first line (other than the line indicating the line the error is on.
12:16:01 <jle`> usually the error gives you suggestions on how to fix it :)
12:16:06 <jle`> so posting the full error is useful
12:16:13 <Zemyla> juri_: Write a function toFloat = realToFrac :: (Real a) => a -> Float.
12:16:19 <Zemyla> And use that.
12:16:49 <arkeet> also the full error can give more details. (I'm guessing it said something about ambiguous types.)
12:16:52 <arkeet> I have no idea what LE is, though.
12:19:31 <juri_> Zemyla: worked. thanks. :)
12:28:04 <Zemyla> juri_: You know why it worked, though, right?
12:37:12 <juri_> yes, i do. :)
12:42:26 * hasket  
12:49:30 <tear> For all who are homosexuals or ADDICTED TO PORN or alcohol (so called drunkards) or are FULL OF LUST (e.g. furry-fetish) or hatred - hell is awaiting you!! - Repent and turn from your sins! - Get delivered by Jesus today! He can set you free! You can only find forgiveness of your sins through Jesus! - http://goo.gl/fJcyNy / http://goo.gl/ynvsVu / http://goo.gl/i2W3v3 / http://goo.gl/uHnOGP / 
12:49:30 <tear> http://goo.gl/hJHNmo - There is no forgiveness if you don't stop with your sin / turn/repent from your sins! Btw. Sex outside of marriage [between 1 man and 1 woman (I don't speak of divorce&remarriage because divorce&remarriage = adultery)] is called fornication and is a sin as well.
12:49:30 <tear> For all who are homosexuals or ADDICTED TO PORN or alcohol (so called drunkards) or are FULL OF LUST (e.g. furry-fetish) or hatred - hell is awaiting you!! - Repent and turn from your sins! - Get delivered by Jesus today! He can set you free! You can only find forgiveness of your sins through Jesus! - http://goo.gl/fJcyNy / http://goo.gl/ynvsVu / http://goo.gl/i2W3v3 / http://goo.gl/uHnOGP / 
12:49:31 <tear> http://goo.gl/hJHNmo - There is no forgiveness if you don't stop with your sin / turn/repent from your sins! Btw. Sex outside of marriage [between 1 man and 1 woman (I don't speak of divorce&remarriage because divorce&remarriage = adultery)] is called fornication and is a sin as well.
12:49:38 <dfeuer> Anyone know why Data.Constraint.Forall has two skolem variables for each kind?
12:49:46 <Clint> @where ops
12:49:46 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:49:58 --- mode: ChanServ set +o geekosaur
12:50:00 --- mode: ChanServ set +o shachaf
12:50:02 --- mode: geekosaur set +b *!*@84-72-192-208.dclient.hispeed.ch
12:50:03 --- kick: tear was kicked by geekosaur (tear)
12:50:06 --- mode: shachaf set -o shachaf
12:50:24 --- mode: geekosaur set -o geekosaur
12:55:32 <minad> hi
12:56:53 <minad> I have a question about how projects on hackage are handled if the maintainer somehow disappeared?
12:57:25 <minad> is it better to create a fork or try to somehow help out maintaining?
12:57:56 <arkeet> there is a process.
12:58:04 <arkeet> https://wiki.haskell.org/Taking_over_a_package
12:59:14 <bitemyapp> jmcarthur_: hey
12:59:22 <bitemyapp> jmcarthur_: do you have an archive of http://creativelad.wordpress.com/2013/11/28/final-encodings-part-1-a-quick-demonstration/ - I can't find it via Google.
12:59:44 <minad> arkeet: I am not asking for myself, it seems mrkkrp seems to be eager to help to contribute to parsec
13:00:02 <minad> he has his own project megaparsec, but I wondered if it wouldn't be better to try to unify it somehow
13:00:18 <nikki93> are people able to get "cabal build" to work in /projects/NetworkServer/haskell in the NICTA course? or is it not supposed to work initially?
13:00:29 <nikki93> like is it also not supposed to build, or just not supposed to be runnable, initially?
13:00:34 <arkeet> and you can't get in contact with the maintainer?
13:00:35 <minad> I am new to the haskell community, so I don't know what you prefer. However I usually have the feelin that if you have multiple projects which are basically forks of each other don't really help
13:00:43 <Cale> bitemyapp: http://web.archive.org/web/20140209090407/http://creativelad.wordpress.com/2013/11/28/final-encodings-part-1-a-quick-demonstration/
13:01:28 <minad> arkeet: could you take a look at the comments at https://github.com/aslatter/parsec/pull/41
13:01:35 <bitemyapp> Cale: ah good call, thank you.
13:01:36 <minad> I am just trying to mediate ;)
13:03:45 <nikki93> bitemyapp: hi -- following your recommended outline to do cis194 then NICTA... I finished cis194 and I did NICTA till starting the projects
13:04:02 <nikki93> bitemyapp: do you know if the projects should build initially? just asking -- it's chill if you don't know the specifics!
13:04:03 <arkeet> minad: I feel like this would be a better topic for a mailing list.
13:04:10 * hackagebot cpphs 1.19.1 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.19.1 (MalcolmWallace)
13:04:43 <minad> maybe I could ask him to come to the irc and talk to you or someone experienced tomorrow?
13:05:04 <arkeet> probably not me
13:05:17 <minad> ok, but you seem to be around :)
13:05:26 <arkeet> the thing about irc is that the number of people who will see any particular message is small.
13:05:51 <minad> thats true, I am thinking more about how to handle the issue in a nice way
13:06:09 <glguy> It's a shame that that pull request mixes up whitespace fixes with the actuall test case
13:06:32 <kqr> can't you correct that?
13:06:41 <minad> glguy: I don't understand?
13:06:41 <kqr> (as in the general you, not specifically you)
13:06:57 <kqr> "isn't it quite easy to correct that" might be a better way to put it
13:07:03 <glguy> kqr: Sure, he could fix the pull request to not include the whitespace changes
13:07:16 <minad> my point is, I don't think this pr is necessary anymore. it is solved by using the indentparser
13:07:29 <glguy> minad: Parsec is unlikely to be declared abandoned and taken over due to slow integration of a test case
13:08:34 <glguy> and if someone wants to make a fork that they can more actively control, that's perfectly fine
13:08:38 <minad> glguy: I don't understand your criticism of my pr, but doesn't matter. This is not what I care about. I just want to see how these processes are handled in the haskell community
13:08:56 <arkeet> I think he's referring to mrkkrp's PR
13:09:08 <glguy> minad: I'm just saying that this isn't a case where a project would be considered abandoned
13:09:22 <minad> yes, I also don't think so
13:09:30 <minad> therefore I asked him if he tried to contact the maintainer
13:09:36 <minad> maybe they could work together
13:09:40 <minad> this is what I would like :)
13:09:45 <glguy> and it's perfectly OK for someone to fork a project and take it in their own direction
13:09:53 <glguy> no mediation is needed
13:11:22 <voidnoid> > let x = take 3 (iterate (\x -> 1.15 * (40000 + x * 1.15)) 40000) in x
13:11:24 <lambdabot>  [40000.0,98899.99999999999,176795.24999999994]
13:11:46 <bitemyapp> nikki93: build yes, work no.
13:11:47 <voidnoid> it's close, the first 2 numbers are effectively "correct" based on what I thought was going on
13:11:51 <voidnoid> but that last number isn't quite right
13:12:03 <nikki93> bitemyapp: I see... it doesn't build for me :( I'll look at it
13:12:05 <arkeet> voidnoid: welcome to IEEE arithmetic.
13:12:05 <tommd> voidnoid: Yes, floating point confuses people.  It's a FAQ.
13:12:08 <bitemyapp> nikki93: are you using 7.10?
13:12:10 <voidnoid> http://lpaste.net/2653469772297011200 shows the manual/longhand form
13:12:27 <nikki93> bitemyapp: yup -- 7.10.1
13:12:36 <voidnoid> tommd: uhh, wait, I don't think I'm being confused by floating point numbers
13:12:52 <bitemyapp> nikki93: yeah I think it has problems with 7.10, https://github.com/NICTA/course/issues/ - could report your problem, paste the error.
13:12:59 <tommd> OK, I quite possibley misunderstand the point.
13:13:05 <voidnoid> I could take out the decimals entirely and I still don't think that last number would be what I would want
13:13:20 <nikki93> bitemyapp: thanks! I'll check it out
13:13:32 <voidnoid> or floating point arithemetic, I understand the general gist of problems with floating point math inside of a fixed sized binary word size
13:13:35 <nikki93> bitemyapp: so after nicta, what resources do you suggest? I'm mainly interested in applying FRP to games and stuff
13:13:46 <nikki93> bitemyapp: I see you pointed toward cs240h
13:13:49 <arkeet> voidnoid: ok, your math is wrong.
13:14:00 <arkeet> > let x = take 3 (iterate (\x -> 1.15 * (40000 + x * 1.15)) 40000) in x :: [Expr]
13:14:00 <minad> glguy: but wouldn't it be nice to motivate Mark to play an active role in a project if he wants to?
13:14:01 <lambdabot>  [40000,1.15 * (40000 + 40000 * 1.15),1.15 * (40000 + 1.15 * (40000 + 40000 *...
13:14:02 <voidnoid> arkeet: ok, which math? the longhand writeout in the lpaste?
13:14:26 <voidnoid> I'm sure something is wrong, just not sure which
13:14:26 <arkeet> > (iterate (\x -> 1.15 * (40000 + x * 1.15)) 40000) !! 2 :: Expr
13:14:28 <lambdabot>  1.15 * (40000 + 1.15 * (40000 + 40000 * 1.15) * 1.15)
13:14:39 <arkeet> this is the 3rd element of the list.
13:15:01 <arkeet> you are missing a multiplication by 1.15 in your paste.
13:15:07 <voidnoid> > let x =  1.15 * (40000 + 1.15 * (40000 + 40000 * 1.15) * 1.15) in x
13:15:09 <lambdabot>  176795.24999999994
13:15:47 <voidnoid> arkeet: hmm, where am I missing a multiplication in my paste? at least, in reference to the end of the paste
13:16:05 <arkeet> there are 4 1.15s in the above expression.
13:16:06 <arkeet> and 3 in your paste.
13:16:20 <voidnoid> yes, and I'm pretty sure my paste is correct
13:16:25 <voidnoid> or at least, my paste is what I want
13:16:25 <arkeet> ok, then your code is wrong.
13:16:29 <voidnoid> sure
13:16:33 <voidnoid> so then question is how to make my code right
13:16:47 <arkeet> what do you want the output to be?
13:17:09 <tommd> voidnoid: Remove the outer 1.15 is my guess about what you want, but mind reading is hard.
13:17:12 <voidnoid> arkeet: basically I just want to get the last number you see in the paste with the same/similar inputs, namely 159733
13:17:19 <voidnoid> arkeet: the function in that paste does yeild 159733
13:17:31 <bitemyapp> nikki93: cs240h is worth a perusal, you'll want to link up with the #haskell-game community.
13:17:35 <arkeet> is the first one also supposed to be 40000, not 46000?
13:17:40 <voidnoid> well, basically, it has decimal places, but it yields what I expect
13:17:54 <bitemyapp> nikki93: I don't have many suggestions for making games other than to look at examples like Nikki and the Robots, but other than something really old like Frag, I don't know of any proper FRP games.
13:18:11 <voidnoid> arkeet: yes the idea is an investment calclulator, just a real simple one: you have a starting amount, an amount you contribute each year and a percentage that the account grows each year
13:18:15 <bitemyapp> nikki93: you're probably going to end up reading a lot of papers to learn FRP and I don't have a recommended course for FRP yet because I don't really understand it myself.
13:18:33 <bitemyapp> nikki93: most games are going to have a world state they're iterating over and re-rendering on each frame.
13:18:41 <voidnoid> so if I start with 40000, by the end of the year it grows to 46000, then I add another 40000 bringing the account to 86000 which then grows over a year which becomes 98899
13:18:42 <arkeet> voidnoid: ok, well in your code you are counting the 15% growth twice per iteration.
13:18:43 <voidnoid> and onwards
13:18:53 <nikki93> bitemyapp: yeah that's fine, was mostly wanting to try a bunch of haskell stuff and get into the monad/applicative-ey thinking and have some sort of "subconscious mind epiphany" regarding that and games haha
13:18:55 <voidnoid> arkeet: you mean in my iterate example?
13:18:56 <arkeet> yes
13:19:04 <aweinstock> the iterate example was my fault
13:19:15 <voidnoid> arkeet: ok, so how can I use iterate to get the same results as the function I wrote in my paste?
13:19:18 <aweinstock> (I claim responsiblity for any bugs in it)
13:19:27 <voidnoid> I'm just trying to see if I can see how to figure out how to use iterate instead
13:19:27 <nikki93> bitemyapp: sort of like using metaphors, you know what I mean? like you read some poetry or look at art and it 'clicks' somehow
13:19:42 <voidnoid> or, well, as the paste indicates I was just looking to see if there are "more idiomatic" haskell ways of doing something like that
13:20:41 <joco42> https://www.irccloud.com/pastebin/nY3ldQsG/
13:21:37 <joco42> hamishmack: I've installed Leksah into docker but I got the above error messages when I was loading metadata. I've installed it into a Sandbox. Any idea how to fix this?
13:22:19 <joco42> hamishmack: it's the packageInfo not found for Cabal-1.23.0.0 type error message that is troubling
13:22:31 <arkeet> voidnoid: the reason I'm confused is that, if you want the list of amounts at the end of each year, the first one probably should be 46000, not 40000.
13:23:15 <voidnoid> arkeet: sure, that's probably a better idea I guess
13:23:21 <voidnoid> I suppose that should be doable
13:23:24 <bitemyapp> nikki93: sure, I think.
13:23:35 <voidnoid> arkeet: so, with that in mind, how would you write that using iterate?
13:23:55 <arkeet> well, write the function that takes you from one value to the next.
13:24:00 <arkeet> and then write the first value.
13:24:03 <arkeet> and then pass them to iterate.
13:24:09 <joco42> bitemyapp: This talk helped me to get the basics of FRP https://www.youtube.com/watch?v=CjEDmJMLEGE :)
13:24:27 <arkeet> the first value would be 40000 * 1.15, not 40000
13:24:32 <joco42> I really had to learn it to give it.
13:24:45 <voidnoid> arkeet: can you show me a working example of what you mean?
13:24:54 <arkeet> ok, I'll spoil it I guess.
13:25:09 <arkeet> > iterate (\x -> 1.15 * (40000 + x)) (1.15 * 40000)
13:25:11 <lambdabot>  [46000.0,98899.99999999999,159735.0,229695.24999999997,310149.5375,402671.96...
13:25:31 <voidnoid> ok, yeah I see
13:25:32 <voidnoid> thanks
13:25:43 <conal> oh. i didn't realize that jozsef and i used the same title. http://begriffs.com/posts/2015-07-22-essence-of-frp.html . Jozsef has written me a few times. I think he's still figuring things out.
13:25:46 <arkeet> alternative:
13:25:54 <Sindriava> Does anyone have experience with sdl2 and the gl library?
13:26:05 <arkeet> > map (1.15 *) (iterate (\x -> 40000 + 1.15 * x) 40000)
13:26:06 <lambdabot>  [46000.0,98899.99999999999,159735.0,229695.24999999997,310149.5375,402671.96...
13:26:08 <jle`> Sindriava: try checking out #haskell-game :)
13:26:16 <arkeet> depending on how you want to think abou tit.
13:26:27 <Sindriava> jle`: I'm there, but nobody's responding :( So I tried my luck here
13:26:47 <voidnoid> arkeet: ahh, yes nice I kind of like that map version a bit better because I can directly input the "starting" number
13:26:48 <jle`> ah, well good luck :)
13:27:06 <voidnoid> cool, that's pretty sweet
13:27:08 <voidnoid> very concise
13:27:21 <arkeet> voidnoid: well, you can sort of do that with both.
13:27:46 <bitemyapp> joco42: thank you!
13:28:10 <arkeet> I guess you want to allow the starting amount to differ from the contribution amount, otherwise I might go with some "you have nothing at the end of year -1" idea and:
13:28:15 <Sindriava> jle`: I just figured it out, it was the stupidest mistake imaginable x_x Thanks, though!
13:28:15 <arkeet> > iterate (\x -> 1.15 * (40000 + x)) 0
13:28:17 <lambdabot>  [0.0,46000.0,98899.99999999999,159735.0,229695.24999999997,310149.5375,40267...
13:28:35 <voidnoid> ah, right, start from zero
13:28:39 <voidnoid> I had tried that at first actually
13:28:53 <arkeet> but that won't work if you want to allow the two 40000s to be different.
13:29:01 <voidnoid> right I was just gonna mention that :)
13:30:50 <eacameron> what's the most common way to build unit tests around non-public functions? Is it to export Internal modules?
13:31:09 * arkeet . o O ( map f (iterate (g . f) z) = iterate (f . g) (f z) )
13:31:51 <jle`> > map f (iterate (g . f) z) :: [Expr]
13:31:52 <lambdabot>      No instance for (Show b0) arising from a use of ‘g’
13:31:52 <lambdabot>      The type variable ‘b0’ is ambiguous
13:31:52 <lambdabot>      Note: there are several potential instances:
13:32:04 <jle`> boo
13:32:52 <joco42> bitemyapp: welcome
13:32:57 <arkeet> > map (f :: Expr -> Expr) (iterate (g . f) z) :: [Expr]
13:32:58 <lambdabot>      No instance for (Show b0) arising from a use of ‘g’
13:32:58 <lambdabot>      The type variable ‘b0’ is ambiguous
13:32:58 <lambdabot>      Note: there are several potential instances:
13:33:01 <arkeet> :-(
13:33:14 <arkeet> > map f (iterate ((g  :: Expr -> Expr) . f) z) :: [Expr]
13:33:18 <lambdabot>  <no location info>: can't find file: L.hs
13:33:22 <arkeet> oh fun.
13:33:46 <arkeet> > map f (iterate ((g :: Expr -> Expr) . f) z) :: [Expr]
13:33:47 <lambdabot>  [f z,f (g (f z)),f (g (f (g (f z)))),f (g (f (g (f (g (f z)))))),f (g (f (g ...
13:34:20 <catgocat> @pl products = [x*y | x <- [100..999], y <- [x..999]]
13:34:24 <lambdabot> products = [x * y | x <- [100..999], y <- [x..999]]
13:34:31 <arkeet> there are no points there.
13:34:52 <quchen> > let f' :: Expr -> Expr; f' = f in map f' (iterate (g . f') z) -- jle` 
13:34:52 <michaelt> > take 4 $ map f (iterate (\i -> g ( f i :: Expr) ) z) :: [Expr]
13:34:54 <lambdabot>  <no location info>: can't find file: L.hs
13:34:54 <lambdabot>  [f z,f (g (f z)),f (g (f (g (f z)))),f (g (f (g (f (g (f z)))))),f (g (f (g ...
13:35:14 <voidnoid> haskell makes me happy :)
13:35:37 <jle`> > let f' :: Expr -> Expr; f' = f in iterate (f . g) (f z)
13:35:38 <lambdabot>      Could not deduce (Show b0) arising from a use of ‘f’
13:35:39 <lambdabot>      from the context (Show a, FromExpr a)
13:35:39 <lambdabot>        bound by the inferred type of it :: (Show a, FromExpr a) => [a]
13:35:41 <quchen> Welcome to the rabbit hole here's your ticket
13:35:45 <jle`> > let f' :: Expr -> Expr; f' = f in iterate (f' . g) (f' z)
13:35:46 <lambdabot>  [f z,f (g (f z)),f (g (f (g (f z)))),f (g (f (g (f (g (f z)))))),f (g (f (g ...
13:35:47 <jle`> heh
13:35:56 <jle`> arkeet theorem provem
13:36:10 <arkeet> I already had written down a proof.
13:36:10 <jle`> this is how proofs work right
13:36:16 <jle`> check the first five terms?
13:36:20 <jle`> ==> the entire thing is correct
13:36:29 <quchen> jle`: Yes! It's called physicist's induction.
13:36:31 <arkeet> no, an actual proof. :P
13:38:59 <michaelt> > zipWith (==) (map f (iterate (\i -> g ( f i :: Expr) ) z) :: [Expr]) (iterate (f . (g :: Expr -> Expr)) (f z :: Expr))
13:39:00 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
13:39:11 * hackagebot posix-paths 0.2.1.0 - POSIX filepath/directory functionality  https://hackage.haskell.org/package/posix-paths-0.2.1.0 (JohnLato)
13:39:13 * hackagebot located-base 0.1.0.0 - Location-aware variants of partial functions  https://hackage.haskell.org/package/located-base-0.1.0.0 (EricSeidel)
13:41:05 <jle`> omg when did GHC.Err.Located happen
13:41:13 <jle`> oh it's a part of the package
13:41:52 <gridaphobe> jle`: yes, 7.12 ought to have the smarter `error` and `undefined` in base, but until then, you can use my package
13:42:58 <bitemyapp> gridaphobe: and that works without a profiling build?
13:43:18 <gridaphobe> bitemyapp: yep, it uses the new implicit call-stacks in 7.10.2
13:43:21 <jle`> oh i see
13:43:27 <jle`> it uses ImplicitParams
13:43:32 <bitemyapp> gridaphobe: right, I knew that, but didn't know if the implicit call-stacks needed profiling build or not.
13:43:33 <jle`> and something called `callStack` is always in scope
13:43:35 <jle`> how did this what
13:43:39 <bitemyapp> jle`: 7.10.2
13:44:02 <gridaphobe> bitemyapp: ah i see, yep implicit call-stacks don't need profiling (that was the basic motivation for adding them :)
13:44:11 * hackagebot varying 0.1.0.3 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.0.3 (SchellScivally)
13:44:19 <aruro> folks, anyone uses haskell-emacs?
13:44:20 <yac> how to find list of package names bundled with ghc?
13:44:32 <bitemyapp> gridaphobe: thank you :)
13:44:53 <aruro> ghc-pkg list ?
13:44:56 <michaelt> yac: ghc-pkg list
13:45:23 <gridaphobe> jle`: 7.10.2 automatically resolves implicit parameters of type `GHC.Stack.CallStack` to the current source location
13:45:26 <michaelt> yac, unless you have installed other packages globally 
13:45:58 <gridaphobe> so if you call a function with type `(?callStack :: CallStack) => ...` you get the call-site
13:46:03 <jle`> yeah, i see now
13:46:05 <jle`> that's neat
13:46:12 <yac> wouldn't system packages installing haskell libs appear there as well?
13:46:25 <gridaphobe> bitemyapp: hope it will be useful!
13:46:40 <jle`> is lambdabot on 7.10.2 yet
13:47:13 <jle`> > let x :: (?cs :: CallStack) => CallStack; x = cs in x
13:47:14 <lambdabot>      Not in scope: type constructor or class ‘CallStack’    Not in scope: typ...
13:47:14 <lambdabot>      Perhaps you meant one of these:
13:47:14 <lambdabot>        ‘cos’ (imported from Prelude),
13:47:22 <michaelt> yac: if you have something like the haskell platform installed yes, also if you use your package manager to install hackage packages; otherwise not.
13:47:43 <jle`> > let x :: (?cs :: CallStack) => CallStack; x = cs in x
13:47:44 <lambdabot>      Not in scope: type constructor or class ‘CallStack’    Not in scope: typ...
13:47:45 <lambdabot>      Perhaps you meant one of these:
13:47:45 <lambdabot>        ‘cos’ (imported from Prelude),
13:47:55 <jle`> oh well
13:48:05 <arkeet> I'm willing to bet lambdabot has been running longer than 7.10.2 has been out.
13:48:17 <gridaphobe> let x :: (?cs :: GHC.Stack.CallStack) => GHC.Stack.CallStack; x = cs in x
13:48:18 <jle`> @uptime
13:48:18 <lambdabot> uptime: 2h 13m 30s, longest uptime: 1m 10d 23h 44m 29s
13:48:29 <gridaphobe> > let x :: (?cs :: GHC.Stack.CallStack) => GHC.Stack.CallStack; x = cs in x
13:48:30 <lambdabot>      Not in scope: type constructor or class ‘GHC.Stack.CallStack’    Not in ...
13:48:30 <lambdabot>      Perhaps you meant one of these:
13:48:30 <lambdabot>        ‘cos’ (imported from Prelude),
13:48:40 <arkeet> please stop
13:48:50 <michaelt> yak, I have Cabal, array, base, bin-package-db, binary, bytestring, containers, deepseq, directory, filepath, ghc, ghc-prim, haskeline, hoopl, hpc, integer-gmp, pretty, process, rts, template-haskell, terminfo, time, transformers, unix, xhtml
13:48:51 <jle`> 2h, 7.10.2 has been up for almost a day now right?
13:49:18 <michaelt> yac: yac, rather ^^
13:49:36 <arkeet> jle`: I guess not.
13:49:44 <mzero> HP 7.10.2 came out today, too
13:49:46 <arkeet> yeah it was announced released yesterday.
13:49:55 <mzero> https://www.haskell.org/platform/contents.html - will show you what is from GHC, and what is from HP
13:50:03 <mzero> (though I just noticed that we seem to have a small css error)
13:50:17 <arkeet> @let import GHC.Stack
13:50:18 <lambdabot>  Defined.
13:50:26 <arkeet> > let x :: (?cs :: CallStack) => CallStack; x = cs in x
13:50:27 <lambdabot>      Not in scope: type constructor or class ‘CallStack’    Not in scope: typ...
13:50:27 <lambdabot>      Perhaps you meant one of these:
13:50:27 <lambdabot>        ‘cos’ (imported from Prelude),
13:50:29 <michaelt> yac: ah, see mzero 's link
13:50:32 <arkeet> I should stop.
13:51:21 <arkeet> :t showCallStack
13:51:22 <lambdabot> Not in scope: ‘showCallStack’
13:51:25 <arkeet> nope.
13:52:33 <jle`> welp gives me a reason to go ahead and download 7.10.2 and play with it
13:52:44 <jle`> also the library improvements seem very nice too
13:55:13 <johnw> Nix should update to 7.10.2 any moment now...
13:55:40 <Denommus> I should learn nix
14:05:36 <zmbmartin> Anyone that can shed some light on what I am trying to do. My code compile but now I need to modify the tests to account for the changes. Here is the error I am getting http://lpaste.net/137618. here is the code https://github.com/codedmart/servant/commit/04a8a14cd53db39b93770c66f4c721bb97201f9a
14:05:45 <zmbmartin> I appreciate and help.
14:33:19 <catgocat> Why does this doesn't evaluate lazily? http://lpaste.net/137623
14:33:24 <catgocat> s/does/doesn't
14:33:40 <catgocat> if I add "1000" after [1.. it works.. otherwise it doesn't end
14:37:26 <ReinH> johnw: are you going to Hac Boston?
14:37:38 <johnw> no, I was just in Boston
14:39:11 <mauke> catgocat: that will never leave a = 1
14:39:18 <kadoban> catgocat: It kinda does, except it's still trying every possible b, with a == 1
14:39:26 <catgocat> ah you're right
14:39:30 <catgocat> it will never stop in b
14:48:59 <aruro> it is possible to hack ghci to make is an editor? :)
14:49:08 <aruro> with haskell support
14:52:07 <Denommus> aruro: I think this wouldn't be a very good approach, personally. You'd have to reinvent lots of things, when you could just use ncurses and use ghci as, for instance, a completion backend
14:52:47 <geekosaur> there is a separated-out ghci on hackage (ghci-ng) but it hasn't been updated since ghc 7.6.3
14:53:01 <geekosaur> you *might* be interested in yi
14:53:15 <aruro> geekosaur: didnt people complain about it being slow?
14:53:19 <aruro> i got scared
14:53:31 <aruro> maybe i should try it at the end
14:53:50 <geekosaur> I don't think anyone claims yi is ready to go just yet
14:53:58 <aruro> Denommus: sounds interesting
14:54:11 <aruro> geekosaur: when? :)
14:54:18 <geekosaur> but if you're hot to hack something up like that, yi might be a better starting point than ghci
14:54:36 <geekosaur> or if your "is it possible to..." means "will someone else do it for me" then I think you just have to wait
14:54:42 <geekosaur> but I couldn't say how long
14:55:01 <aruro> geekosaur: ty, looking into yi would be productive i think
14:55:51 * geekosaur also wonders if iHaskell might be worth looking into (a ghc backend for iPython notebooks)
14:55:51 <kuribas> aruro: there is a ghc-mod backend for emacs :)
14:56:07 <ttt_fff> what are rank2types ?
14:58:12 <kuribas> ttt_fff: isn't that something like (forall s. ST s a) -> a?
14:58:24 <ttt_fff> kuribas: I don't know. https://ghc.haskell.org/trac/haskell-prime/wiki/Rank2Types makes no sense.
14:59:10 <kuribas> ttt_fff: it's when a forall appears on the left of an arrow.
15:00:46 <Cale> ttt_fff: Basically, the ability for functions to insist that their arguments be polymorphic
15:00:52 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#universal-quantification
15:01:31 <Cale> ttt_fff: Consider something like  foo f = (f [1,2,3], f "Hello")
15:02:00 <Cale> ttt_fff: Normally, that wouldn't typecheck -- type inference won't be able to find an appropriate type
15:02:34 <ttt_fff> if 'f' was an instance of a typecheck, it would work, right?
15:02:37 <ttt_fff> i.e. f == show
15:02:40 <Cale> But you can have for example   foo :: (forall a. [a] -> [a]) -> ([Integer], [Char])
15:03:03 <Cale> and then  foo reverse  will work
15:03:22 <ttt_fff> > let foo f = (f [1, 2, 3], f "Hello") in f
15:03:22 <Cale> Or indeed, you could also have  foo :: (forall a. Show a => a -> String) -> (String, String)
15:03:23 <lambdabot>      Could not deduce (Num Char) arising from the literal ‘1’
15:03:23 <lambdabot>      from the context (FromExpr a)
15:03:23 <lambdabot>        bound by the inferred type of it :: FromExpr a => a at Top level
15:03:24 <ttt_fff> > let foo f = (f [1, 2, 3], f "Hello") in foo
15:03:26 <lambdabot>      No instance for (Num Char) arising from the literal ‘1’
15:03:26 <lambdabot>      In the expression: 1
15:03:26 <lambdabot>      In the first argument of ‘f’, namely ‘[1, 2, 3]’
15:03:41 <Cale> You'll need to give an explicit type signature for the definition to work
15:04:05 <kuribas> Cale: does this usage of forall clash with scoped typevariables?
15:04:15 * hackagebot microformats2-parser 0.1.0 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-0.1.0 (myfreeweb)
15:04:20 <Cale> > let foo :: (forall a. [a] -> [a]) -> ([Integer], String); foo f = (f [1, 2, 3], f "Hello") in foo reverse
15:04:21 <lambdabot>  ([3,2,1],"olleH")
15:04:29 <Cale> kuribas: no
15:04:32 <texvery> I'm trying to develop a application that reads financial data and does statistical analysis on this data. But I'm not sure where I should focus, either on the data itself or on the statistical appplication?
15:04:54 <ttt_fff> wtf, this is pretty crazy
15:04:57 <cow_2001> how do i string a bunch of Either error success? i want a Left to throw an error and a Right to be passed along through the (>>=)
15:05:10 <Cale> > let foo :: (forall a. (Show a) => a -> String) -> (String, String); foo f = (f [1, 2, 3], f "Hello") in foo show
15:05:12 <lambdabot>  ("[1,2,3]","\"Hello\"")
15:05:13 <kuribas> ttt_fff: you asked for it :)
15:05:20 <ttt_fff> Cale: why does f have to be (forall a. [a] -> [a]), it seems like [Integer] -> [Integer] and [Char] -> [Char] should suffice
15:05:40 <Cale> ttt_fff: Well, what type would you like?
15:05:57 <Cale> ttt_fff: There are other options.
15:06:07 <kuribas> ttt_fff: yes, but those are two functions.
15:06:14 <Cale> ttt_fff: But you can't list a bunch of specific types.
15:06:16 <ttt_fff> I don't know; but suppose I had: "class Bar a where bar :: [a] -> [a]", and then I defined "instance Bar Integer" and "instance Bar Char", then I should be able to pass "bar" to foo
15:06:34 <Cale> Yeah, you could define a type class
15:06:39 <Cale> look at what I did with Show there
15:06:53 <Cale> It's a different type though.
15:07:18 <Cale> cow_2001: That's what the usual monad instance for Either e does already?
15:07:38 <cow_2001> oh
15:07:54 <cow_2001> what if it's Either String Foo?
15:08:01 <cow_2001> how do i make the lefties Error?
15:08:04 <cow_2001> turn
15:08:06 <ttt_fff> Cale: thanks for the explaination. This provides some intuition.
15:08:16 <myfreeweb> nah that doesn't work
15:08:18 <myfreeweb> > (return $ Right 1) >>= (\_ -> return $ Right 2) >>= (\_ -> return $ Left "Error!") >>= (\_ -> return $ Right 3)
15:08:19 <lambdabot>      No instance for (Show (m0 (Either a0 b0)))
15:08:19 <lambdabot>        arising from a use of ‘show_M297507098962593115112651’
15:08:19 <lambdabot>      The type variables ‘m0’, ‘a0’, ‘b0’ are ambiguous
15:08:24 <Cale> > do x <- Right 5; return (10 * x)
15:08:25 <lambdabot>  Right 50
15:08:32 <Cale> > do x <- Left "hello"; return (10 * x)
15:08:33 <lambdabot>  Left "hello"
15:08:34 <cow_2001> do i mapLeft some String -> Error?
15:08:42 <y> `Left`
15:08:54 <cow_2001> :|
15:08:54 <y> you just do Left 
15:09:08 <myfreeweb> anyway, look at the ExceptT/ErrorT/EitherT things
15:09:15 * hackagebot cassandra-cql 0.5.0.2 - Haskell client for Cassandra's CQL protocol  https://hackage.haskell.org/package/cassandra-cql-0.5.0.2 (StephenBlackheath)
15:09:24 <Cale> > do x <- Right 5; y <- Left "hi there"; z <- Right 7; return (x + y + z)
15:09:25 <lambdabot>  Left "hi there"
15:09:34 <Cale> > do x <- Right 5; y <- Right 3; z <- Right 7; return (x + y + z)
15:09:35 <lambdabot>  Right 15
15:10:01 <Cale> cow_2001: ^^ does that look like what you want?
15:10:36 <cow_2001> will it throw an error?
15:10:41 <cow_2001> i'll try
15:10:42 <Cale> Not really.
15:11:06 <Cale> It just results in a Left or Right depending on whether the computation hit some Left, or was all Right
15:11:11 <myfreeweb> not throwing errors is kinda the whole point
15:11:19 <kuribas> Cale: so the forall keyword is never ambiguous?
15:11:33 <myfreeweb> it will *stop computation* after a Left which is what you probably really want
15:11:35 <Cale> kuribas: It always means the same thing.
15:11:56 <kuribas> ok
15:12:02 <Cale> kuribas: Different extensions enable its use in various contexts, but it's always the universal quantifier for types.
15:13:30 <Paulius> How can see TemplateHaskell generated code?.. For example if I have makeLenses in my module and load the module with ghci, can I preview the generated lenses code?
15:14:34 <Cale> -ddump-splices
15:15:51 <Paulius> Awesome. Thank you.
15:20:43 <kuribas> Cale: it's a bit strange that it sometimes means existential quantification.
15:23:45 <Cale> kuribas: Well, it doesn't *mean* existential quantification, it's just that the type as written is equivalent to another one which would involve an existential quantifier
15:23:58 <Cale> (but that quantifier would be located in a different place)
15:25:46 <Cale> If you have something like  data Counter where MkCounter :: forall a. (a -> a) -> (a -> String) -> a -> Counter
15:26:09 <lpaste_> voidnoid pasted “how can I combine computations like this? I'm getting errors right now” at http://lpaste.net/8726440966338117632
15:26:33 <Cale> this is equivalent to something like exists a. (a -> a, a -> String, a)
15:27:06 <Cale> (If we had exists)
15:28:11 <geekosaur> voidnoid, you should always include the full errors with such a paste
15:28:13 <Cale> voidnoid: (- monthly yearly) means the negation of  monthly yearly, so monthly would have to be a function
15:28:32 <voidnoid> hmm, is monthly not a function there?
15:28:34 <Cale> Did you mean to write monthly - yearly ?
15:28:41 <voidnoid> I tried monthly - yearly first
15:28:42 <kuribas> Cale: because forall is on the inside of the type?
15:28:48 <voidnoid> which is why I went with (- foo bar)
15:28:51 <geekosaur> the type of monthly does not involve an arrowe
15:29:02 <geekosaur> *arrow
15:29:08 <arkeet> because of the equivalence of forall a. (f a -> b) and (exists a. f a) -> b
15:29:14 <arkeet> (in logic)
15:29:45 <Cale> kuribas: Well, a forall in the type of a data constructor which binds a variable that doesn't occur in the type of its result
15:30:52 <Cale> voidnoid: However, yearly and monthly are also not numbers -- they're quite plainly lists. What did you want to do with them?
15:31:01 <lpaste_> voidnoid pasted “including err msg” at http://lpaste.net/125682601485664256
15:31:27 <voidnoid> ohhh, right yes they are
15:31:34 <Cale> Did you want to subtract corresponding elements of them?
15:31:36 <voidnoid> ok nm, I think I know how to fix it in that case, lol, nm
15:31:38 <Cale> zipWith (-)
15:31:41 <voidnoid> Cale: yeah just the last elements
15:31:55 <Cale> oh, or just subtract the last elements, I see
15:32:42 <voidnoid> yay! lol, duh, brain fart
15:32:45 <voidnoid> thx
15:34:40 <kuribas> arkeet: should I read that arrow as "implies"?
15:34:45 <arkeet> yes
15:36:04 <kuribas> It's starting to make sense...
15:54:10 <ecognium> hi everyone, I have a question regarding install hlint, ghc-mod. I am using stack with my projects and I thought I will try IntelliJ IDEA with Haskforce plugin. The plugin uses ghc-mod, etc. and the install instructions for those are cabal install ghc-mod. Is there an equivalent way for me to install via `stack` or do I need to install Haskell Platform too? 
15:55:05 <voidnoid> is there a way to alias or name some of the computations in functions for readability
15:55:14 <Intolerable> where and let
15:55:23 <Intolerable> let x = y in z
15:55:31 <Intolerable> or z where x = y
15:55:46 <voidnoid> Intolerable: ok yeah I generally understand how to use let, I guess I'm wondering how to incorporate that in to a function, let me give an example
15:55:54 <voidnoid> invest seed contrib years rate = take years (iterate (\x -> (rate/100+1) * (contrib + x)) ((rate/100+1) * seed))
15:55:55 <arkeet> (let and where aren't quite the same thing. let-in is an expression, while where attaches to definitions)
15:56:03 <Welkin> I prefer `where` typically
15:56:09 <voidnoid> instead of saying (contrib + x) I'd like to call taht for example "newSeed" or something similar
15:56:11 <Welkin> inside of a do-block I use `let`
15:56:40 <arkeet> they have different uses.
15:56:40 <y> voidnoid: let newSeed = contrib * x in ... newSeed ..., or using where
15:57:03 <voidnoid> y: ok I still don't quite get how to incorporate that in to the context of the function definition
15:57:18 <voidnoid> y: can you give a more complete example using the function above?
15:57:32 <y> invest seed contrib years rate = take years (iterate (\x -> (rate/100+1) * (contrib + x)) ((rate/100+1) * seed))
15:57:53 <y> invest seed contrib years rate = let newSeed = contrib * x in take years (iterate (\x -> (rate/100+1) * newSeed) ((rate/100+1) * seed))
15:58:13 <voidnoid> y: great thanks, thats what I needed I think
15:58:20 <voidnoid> I'll try it out
15:58:21 <y> err, wait, sorry
15:58:30 <voidnoid> k
15:58:34 <y> that x is inside the lambda, so what I posted won't work 
15:58:43 <voidnoid> ok
15:59:16 <y> I like the code as it is right now, giving it a better sounds like useless boilerplate 
16:00:08 <voidnoid> k, well, while I understand where you're coming from, I'm still interested in how to do this if it's possible
16:00:34 <voidnoid> identifiers tend to increase readability
16:03:30 <lpaste_> arkeet pasted “let vs where” at http://lpaste.net/137626
16:03:33 <arkeet> ^^
16:03:40 <arkeet> also https://wiki.haskell.org/Let_vs._Where
16:21:15 <Adeon> haskell seems good at being a controller for jobs
16:21:24 <Adeon> I have a bunch of C and C++ code doing heavy calculations
16:21:34 <Adeon> I can use haskell as a controller to spread these out to different threads
16:21:48 <Adeon> it's nice when you can call back to haskell from whatever thread
16:21:51 <Adeon> why didn't I think this before
16:22:19 <arkeet> you may be interested in cloud haskell 
16:22:31 <Welkin> THERE IS A MESSAGE ENCODED IN THE WHITESPACE OF YOUR TEXT, ADEON
16:22:36 <Adeon> wat
16:22:39 <arkeet> wat
16:22:50 <Welkin> I see giant letters
16:22:52 <Adeon> did they add StaticPointers support to cloud haskell yet
16:22:58 <Adeon> or is it still template haskell
16:22:58 <hpc> lol
16:24:04 <Adeon> well there used to be a complex unreliable C++ thing that run a big data processing job over many threads
16:24:08 <Adeon> I'm refactoring it and stuff
16:29:18 * hackagebot aig 0.2.3 - And-inverter graphs in Haskell.  https://hackage.haskell.org/package/aig-0.2.3 (RobertDockins)
16:29:20 * hackagebot abcBridge 0.14 - Bindings for ABC, A System for Sequential  Synthesis and Verification  https://hackage.haskell.org/package/abcBridge-0.14 (RobertDockins)
16:32:32 <kalloc> hi, can we help me to build cpphs 
16:32:35 <kalloc> http://pastebin.com/PKwVUxQ6 
16:34:33 <kalloc> hm, cpphs has bug 
16:34:39 <Welkin> kalloc: maybe your ghc is too old
16:34:49 <kalloc> I'm not found 'import Data.List (isPrefixOf)'
16:35:07 <kalloc> Welkin: Glasgow Haskell Compiler, Version 7.10.1
16:35:13 <kalloc> 7.10 is old?
16:35:32 <pacak> Well, 7.10.2 was released a few days ago
16:35:41 <SriPree> hi.. apart from using TH, is there any way I can generate instance signatures with specific string symbols (type-level strings) ?
16:35:42 <Welkin> 7.10.1 has issues
16:36:02 <kalloc> Welkin: 7.10.1 has bug? lol
16:36:19 <Welkin> lots of bugs
16:36:19 <glguy> all the ghcs do
16:36:25 <Welkin> not sure if this is one of them
16:36:25 <ReinH> multiple bugs
16:36:34 <kalloc> maybe another compiler?
16:36:45 <Welkin> kalloc: try 7.8.4 or 7.10.2
16:36:59 <kalloc> ok
16:37:01 <kalloc> i'l try
16:37:10 <arkeet> Welkin: do you know 7.10.1 has some particular issue that could cause this?
16:37:22 <arkeet> know whether
16:37:30 <Welkin> nope, I just know that I got ghc panics on 7.10.1
16:37:31 <geekosaur> 7.10.1's bugs were mostly in the linker
16:37:34 <Welkin> so I moved to 7.8.4
16:37:38 <arkeet> ok, that is unrelated.
16:40:12 <arkeet> I don't see any thing importing isPrefixOf here. https://hackage.haskell.org/package/cpphs-1.19.1/src/Language/Preprocessor/Cpphs/CppIfdef.hs
16:40:24 <kalloc> guyz, Do you believe, that Haskell is better language than another? 
16:40:37 <glguy> cpphs-1.19.1 just came out very recently and seems to have a bug in it
16:40:38 <kalloc> arkeet: me too
16:40:40 <glguy> use cpphs-1.19
16:40:44 <Welkin> lol
16:40:50 <Welkin> yeah, that's a common problem too
16:40:53 <pacak> kalloc: We don't belive. We know it.
16:40:54 <Welkin> broken packages
16:41:13 <arkeet> ah yes, 1.19 doesn't use isPrefixOf in that module.
16:41:14 <Welkin> it's easy to fix though
16:41:18 <kalloc> pacak: I didn't found Haskell as popular language in mainstream 
16:41:41 <arkeet> 1.19.1 was released less than 4 hours ago.
16:41:43 <Welkin> kalloc: it's is not mainstream, but being mainstream means nothing other than it has good marketing
16:41:47 <kalloc> but, it's because so much old code already wrote on C or Java 
16:42:30 <Welkin> I believe that what happens in haskell is where programming is headed in the near future
16:42:43 <Welkin> I already see evidence of it in existing imperative/oop languages
16:43:17 <Welkin> haskell does spoil you though
16:43:32 <Welkin> once you start using it, you are repulsed by imperative/oop languages
16:44:36 <Zemyla> I'm hoping we get concepts in C++.
16:44:40 <pacak> Had to write a few lines of coffeescript two days ago. That was horrible!
16:44:51 <kalloc> I'd like to stop figthing with compiler 
16:45:09 <creicher`> kalloc: that's part of the fun!
16:45:13 <maerwald> Welkin: mh, not really. You just miss the abstraction
16:45:15 <kalloc> and find silver bullet :)
16:45:29 <creicher`> not you're bug, though
16:49:39 <kalloc> do you use sublime?
16:49:46 <kalloc> or only emacs :D
16:51:45 <Welkin> emacs
16:52:08 <coppro> hey all
16:52:09 <Welkin> I don't like proprietary software
16:52:18 <Welkin> I got open source when possible
16:52:20 <Welkin> go*
16:52:20 <arkeet> I don't like software
16:52:24 <kalloc> :)
16:52:25 <coppro> anyone know of a quasiquoter to turn a long string into a list of strings, one per line?
16:52:39 <coppro> maybe I'm too lazy but , " " is too many characters :P
16:52:53 <kalloc> oh, i don't line oneliner oriented developing 
16:53:11 <Welkin> coppro: what? Just use `lines`
16:53:15 <Welkin> :t lines
16:53:16 <lambdabot> String -> [String]
16:54:07 <Welkin> > lines "portraits of zoo animals\n wearing fancy historical clothing\n and a giraffe with a monocle"
16:54:08 <lambdabot>  ["portraits of zoo animals"," wearing fancy historical clothing"," and a gir...
16:54:13 <coppro> good point
16:54:29 <coppro> wait, no, that doens't work
16:54:33 <coppro> no multiline string literals
16:54:54 <arkeet> there are.
16:55:15 <Welkin> it's just \n
16:55:35 <Welkin> oh, you mean as source
16:55:43 <arkeet> oh, but you still have to write \n.
16:55:47 <arkeet> there is a quasiquoter for that too though.
16:55:53 <Welkin> either use a list and concat/unlines
16:56:03 <coppro> arkeet: what quoter?
16:56:12 <Welkin> > unlines $ lines "portraits of zoo animals\n wearing fancy historical clothing\n and a giraffe with a monocle"
16:56:13 <lambdabot>  "portraits of zoo animals\n wearing fancy historical clothing\n and a giraff...
16:56:13 <arkeet> http://stackoverflow.com/questions/22918837/how-can-i-write-a-multiline-strings-in-haskell
16:56:33 <arkeet> for example http://hackage.haskell.org/package/interpolatedstring-perl6-1.0.0/docs/Text-InterpolatedString-Perl6.html
16:56:33 <coppro> eh, too much effort
16:56:35 <coppro> regular strings it is
16:58:14 <gwaszczuk1> Does anybody here use Attribute Grammars in Haskell? Stuff like the AspectAG library, etc?
16:58:45 <Denommus> coppro: you could write such a quasi-quoter
16:58:55 <coppro> I could
16:59:16 <coppro> but then I'd be at the point where I'm a) putting in more effort than not and b) decresing readability
16:59:45 <arkeet> and c) using quasiquoters
17:01:16 <lpaste_> glguy pasted “multiline string quasiquoter” at http://lpaste.net/137630
17:01:30 <lpaste_> glguy annotated “multiline string quasiquoter” with “multiline string quasiquoter (example use)” at http://lpaste.net/137630#a137631
17:01:49 <glguy> coppro: You don't have to use it, but that's how you can do it
17:13:18 <iteratee> From the boston haskell lightning talks, dec 2014: Kmett's law:
17:13:25 <iteratee> "Eventually I will use your library."
17:19:20 * hackagebot hspec-contrib 0.3.0 - Contributed functionality for Hspec  https://hackage.haskell.org/package/hspec-contrib-0.3.0 (SimonHengel)
17:39:21 * hackagebot hspec-core 2.1.10 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.1.10 (SimonHengel)
17:39:24 * hackagebot hspec-discover 2.1.10 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.1.10 (SimonHengel)
17:39:25 * hackagebot hspec 2.1.10 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.1.10 (SimonHengel)
17:42:31 <user__> hi
17:53:36 <user__> [user__(+i)] [3:freenode/#haskell(+CLnptz)] [Act: 2]                        
17:53:58 <Xe> that is irssi
17:55:51 <user__> hi
17:58:38 <user__> hi
18:02:28 <mmaruseacph2> @remember iteratee From the boston haskell lightning talks, dec 2014: Kmett's law: "Eventually I will use your library."
18:02:28 <lambdabot> Done.
18:03:11 <mmaruseacph2> @quote iteratee From the boston haskell lightning talks, dec 2014: Kmett's law: "Eventually I will use your library."
18:03:11 <lambdabot> iteratee says: From the boston haskell lightning talks, dec 2014: Kmett's law: "Eventually I will use your library."
18:03:26 <geekosaur> you had it right
18:03:34 <Welkin> @quote iteratee
18:03:34 <lambdabot> iteratee says: From the boston haskell lightning talks, dec 2014: Kmett's law: "Eventually I will use your library."
18:03:45 <mmaruseacph2> (blush)
18:04:13 <mmaruseacph2> I recall the message being something like "It will be etched on my memory" but it might be another bot on another channel
18:04:31 <geekosaur> the message varies
18:04:48 <geekosaur> it picks one randomly each time
18:05:07 <mmaruseacph2> ah, ok
18:05:08 <mmaruseacph2> thanks :D
18:05:17 <Welkin> lambdabot is secretly a super-intelligent being that will one day destroy us all
18:09:12 <Gurkenglas_> Then it wouldn't have said something that'd make you think that
18:13:48 <augur> is there a tool, or tutorial/guide at least, that can suggest places to insert strictness to avoid memory issues?
18:14:23 * hackagebot sync-mht 0.3.0.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.0.0 (emink)
18:14:25 * hackagebot xss-sanitize 0.3.5.6 - sanitize untrusted HTML to prevent XSS attacks  https://hackage.haskell.org/package/xss-sanitize-0.3.5.6 (GregWeber)
18:14:43 <ttt_fff> correct me if I'm wrong; the brilliance of MTL is to use "typeclasses' for "Monad Transformers"
18:14:58 <ttt_fff> then, anything that supports get/put/modify is a "MonadState"
18:15:00 <ttt_fff> and we're all happy
18:15:02 <ttt_fff> is that correct?
18:16:23 <augur> ttt_fff: yes
18:16:31 <Sindriava> ttt_fff: Sounds about right, yeah
18:16:53 <Sindriava> I kinda don't get the concept of MonadIO though
18:17:07 <augur> Sindriava: ?
18:17:14 <ttt_fff> that's fucking brilliant
18:17:20 <ttt_fff> so this is how we get rid of lift everywheres?
18:17:26 <ttt_fff> Monadic Type Classes
18:17:27 <ttt_fff> brilliant
18:17:28 <augur> ttt_fff: no
18:17:37 <augur> but its a piece of it
18:17:46 <ttt_fff> augur: what are the other pieces of this?
18:18:42 <augur> well if you're working on something that doesnt have the MonadX stuff defined (which is common enough) but uses transformers nonetheless, you still need to use lift, right
18:22:48 <Gurkenglas_> Why doesn't this work? http://lpaste.net/137633
18:22:52 <Gurkenglas_> @letlpaste 137633
18:22:53 <lambdabot>  .L.hs:150:13:
18:22:53 <lambdabot>      Couldn't match type ‘Int’ with ‘[Char]’
18:22:53 <lambdabot>      arising from a functional dependency between constraints:
18:24:54 <pavonia> Gurkenglas_: Your Reader cannot hide a value of Int and String at the same time
18:27:05 <Gurkenglas_> Is this true for any C : (* -> * -> Constraint), that you can't have instances of both C a c and C b c?
18:28:06 <pavonia> Not if there are functional dependencies involved
18:31:05 <Gurkenglas> Oh, so the m -> r means exactly that
18:35:51 <Gurkenglas> But why introduce that functional dependency to stop ambiguity for ask, but not for read?
18:37:05 <Ankhers> I have an Enum type that needs to go from 1 .. n instead of 0 .. n. Is there a quick way to do this?
18:38:27 <Gurkenglas> Ankhers, if people implementing Enum types that need to go from 0 to n can ignore the (-1) case, why shouldn't you ignore 0?
18:40:35 <Iceland_jack> Ankhers: Why not do away with Enum and define a bespoke function 'EnumType -> Int'
18:40:45 <Ankhers> Gurkenglas: I know I can define my own instance, but I didn't really want to have to define the `enumFrom' function by hand. I was hoping there was some template haskell thing that did it.
18:41:20 <Ankhers> Iceland_jack: Unfortunately, I'm using `[Zero ..]' in my code.
18:41:26 <slack1256> @type lookup
18:41:28 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:41:35 <slack1256> that and some zipping
18:41:52 <Iceland_jack> "The nullary constructors are assumed to be numbered left-to-right by fromEnum from 0 through n-1. See Chapter 10 of the Haskell Report for more details."
18:44:08 <Ankhers> I'm going to explain what I'm doing, and maybe someone can suggest a better way. Let me write a quick paste.
18:44:23 <Gurkenglas> Oh, nevermind my suggestion then. Why may instances of Enum not be also derived for enumeration types whose constructors only have fields with Enum instances?
18:44:26 <Iceland_jack> Ankhers: If you're feeling rebelious you can add a dummy constructor :) 
18:44:29 <slack1256> > data Zahle = Eins | Zwei | Drei 
18:44:30 <lambdabot>  <hint>:1:1: parse error on input ‘data’
18:44:34 <slack1256> @data Zahle = Eins | Zwei | Drei 
18:44:35 <lambdabot> Unknown command, try @list
18:44:41 <Ankhers> Iceland_jack: That felt gross when I thought about it.
18:45:21 <Gurkenglas> Your use case better not be defining the natural numbers to start with 1.
18:45:28 <Iceland_jack> Enum isn't very elegant to begin with
18:46:26 <Ankhers> Gurkenglas: Not exactly.
18:46:56 <slack1256> @let data Zahle = Eins | Zwei | Drei;
18:46:57 <lambdabot>  .L.hs:153:1:
18:46:58 <lambdabot>      Multiple declarations of ‘Zahle’
18:46:58 <lambdabot>      Declared at: .L.hs:149:1
18:47:04 <slack1256> @type Zwei
18:47:05 <lambdabot> Zahle
18:48:16 <slack1256> > lookup 2 $ zip [1..3] [Eins, Zwei, Drei]
18:48:17 <lambdabot>  Not in scope: data constructor ‘Eins’Not in scope: data constructor ‘Zwei’No...
18:50:01 <slack1256> > lookup 2 $ zip [1..3] [Eins, Zwei, Drei]
18:50:02 <lambdabot>      No instance for (Show Zahle)
18:50:02 <lambdabot>        arising from a use of ‘show_M712081241256112623115963’
18:50:02 <lambdabot>      In the expression:
18:52:16 <Ankhers> http://lpaste.net/137635
18:52:58 <Zemyla> @let deriving instance Show Zahle
18:52:59 <lambdabot>  Defined.
18:53:00 <Ankhers> Essentially, I want to write the ToJSON and FromJSON instances for my enum type to prevent needing to use toEnum and fromEnum in the JSON instances.
18:53:39 <Ankhers> In the JSON instances of the type encapsulating my enum type rather.
18:54:25 * hackagebot sync-mht 0.3.1.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.1.0 (emink)
18:54:51 <Ankhers> The paste is what I'm currently using, but I feel it wouldn't really be performant.
18:55:46 <Ankhers> (I have no proof of this, but I don't think that getting the length of the enums every time you need to convert would be very good for performance)
19:16:22 <shirt_> For a Data.Vector how do i find the last index that satisfies a predicate?
19:17:39 <Welkin> :t Data.Vector.fold
19:17:40 <lambdabot> Not in scope: ‘Data.Vector.fold’
19:18:18 <Welkin> you can use fold/r
19:18:24 <Welkin> foldl/foldr
19:19:07 <Welkin> you could also filter it and then take the last element
19:19:37 <Welkin> last . filter pred $ vec
19:20:38 <shirt_> i need to search from the back. if i'm not mistaken, that will search forwards
19:21:40 <Welkin> ?
19:21:43 <Welkin> it's not searching
19:21:49 <Welkin> it is filtering
19:21:53 <Welkin> then you take the last element
19:22:19 <Welkin> another option is to reverse the vector and filter, then take the first element
19:22:24 <Welkin> but that is an extra step for no gain
19:22:41 <shirt_> it'll apply the predicate to all the elements in the vector. if the vector has 10,000,000 elements it'll check them all, instead of searching from the back
19:23:08 <Welkin> why would a vector have 10 million elements?
19:24:20 <shirt_> why not?
19:27:21 <Welkin> > Data.Vector.reverse Data.Vector.fromList [1..100]
19:27:22 <lambdabot>      Not in scope: ‘Data.Vector.reverse’
19:27:22 <lambdabot>      Perhaps you meant ‘Data.List.reverse’ (imported from Data.List)Not in sc...
19:29:52 <Welkin> shirt_: here is a solution
19:30:01 <Welkin> Data.Vector.reverse is lazy
19:30:06 <Welkin> so, you can use this
19:31:11 <shirt_> i don't think Data.Vector.reverse is lazy. vectors have a strict structure
19:31:50 <Welkin> V.take 1 $ V.dropWhile (notPred) $ V.reverse vec
19:32:03 <Welkin> V.reverse is lazy
19:33:28 <Welkin> you should get an empty vector if there is no matching result
19:35:09 <shirt_> V.reverse is lazy with the values it contains, but it still needs to O(n) copy operations of all the thunks
19:35:28 <shirt_> at least if i understand correctly how vector works. maybe it can do some crazy fusion stuff and optimize this away
19:35:30 <Welkin> you are not running reverse on the whole vector
19:35:44 <Welkin> only up until the first element that matches your predicate
19:36:00 <Welkin> because you are using take . dropWhile
19:37:31 <shirt_> a vector is backed by an array. so reverse must create a copy of the array, unless it is fusion it away
19:38:50 <Welkin> https://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector-Generic.html#reverse
19:39:02 <Welkin> https://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector-Generic.html#streamR
19:40:07 <shirt_> hm... maybe you are right and it will all fuse away :)
19:40:28 <Welkin> I don't know for sure
19:43:06 <Welkin> hm, it seems to take a long time on a 10 billion element vector
19:43:13 <Welkin> 10 million took a couple seconds
19:43:35 <Welkin> just in ghci
19:44:12 <coppro> hey all, some template haskell questions
19:44:15 <Welkin> you could also take the length (O(1))
19:44:29 <Welkin> then start at the last index and work your way to the front
19:44:29 <coppro> let's suppose I have a parameter ty :: Type
19:44:37 <Welkin> totally imperative, but that works too
19:45:00 <coppro> now, I want to build the type "ty -> String"
19:45:11 <coppro> I have to do this as AppT (AppT ArrowT ty) (ConT ''STring)
19:45:17 <coppro> s/ST/St/
19:45:38 <coppro> I can try [q|$(return ty) -> String], but that hits the staging restriction
19:45:54 <coppro> is there any similar way I can get GCC to realize I have a Type-shaped hole in my quasi-quotation and a Type value?
19:46:35 <coppro> or am I stuck writing ou thte AST the long and nasty way?
19:51:17 <Gurkenglas> Looking at the definition "sum = getSum #. foldMap Sum" makes me think that some foldMap implementations would be strict, and others lazy, but shouldn't that be decided by the monoid that is mapped to?
19:54:27 * hackagebot sync-mht 0.3.2.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.2.0 (emink)
19:59:27 * hackagebot MonadCompose 0.8.3.0 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.3.0 (JamesCandy)
20:08:15 <nshepperd> I'm not sure that you can rely on having any particular evaluation order with foldMap
20:09:28 * hackagebot timestamper 1.0.1 - Read standard input and prepend each line with a timestamp  https://hackage.haskell.org/package/timestamper-1.0.1 (kisom)
20:09:30 * hackagebot timestamper 1.0.2 - Read standard input and prepend each line with a timestamp  https://hackage.haskell.org/package/timestamper-1.0.2 (kisom)
20:10:00 <nshepperd> I mean, the foldMap for [] uses a foldr under the hood, so you could write a monoid that would evaluate as a strict left fold in the same way as you can write foldl using foldr
20:10:24 <nshepperd> but that "wouldn't work" if you then foldMapped over a tree or something
20:10:35 <nshepperd> I think
20:12:22 <nshepperd> or a snoc list
20:34:49 <bitemyapp> @pl (\k a m -> M.insert a k m)
20:34:49 <lambdabot> flip M.insert
20:47:16 <coppro> frak, I did it again
20:47:31 <coppro> I wrote code that assumes dependent types in a terrible way
20:50:40 <coppro> must... resist... urge... to... resolve... using... template... haskel...
20:50:43 <coppro> *haskell
20:51:30 <nshepperd> just implement dependent types in template haskell, easy :p
20:53:17 <monochrom> oh w00t, new Haskell Platform
20:58:43 <meretrix> -XStrictData is my new favorite extension :)
21:00:41 <meretrix> I don't think I've ever written code that wouldn't have been better off with strict data constructors.
21:04:16 <jle`> i've written some that needed laziness for fixed point resolutions
21:04:23 <jle`> and also for infinite data structures
21:04:30 * hackagebot Dist 0.3.0.0 - A Haskell library for probability distributions  https://hackage.haskell.org/package/Dist-0.3.0.0 (wyager)
21:04:30 <jle`> but yeah for the most part, strict fields yay
21:04:40 <jle`> honestly i get surprising results when i actually benchmark sometimes, though
21:05:08 <jle`> i've seen many performance hits from unnecessarily strict fields
21:05:08 <monochrom> when you write a free monad, you will not want strictness.
21:05:53 <jle`> most of my tuned code is this weird mix of strict and non-strict fields that i do not understand at all
21:06:13 <jle`> and will probably all break by the time the next GHC comes along v.v
21:08:21 <jle`> can i use ~ to explicitly label lazy fields with StrictData on?
21:09:30 * hackagebot Neks 0.5.0.0 - Simple networked key/value store  https://hackage.haskell.org/package/Neks-0.5.0.0 (wyager)
21:19:30 * hackagebot resourcet 1.1.6 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.6 (MichaelSnoyman)
21:22:06 <mazur> is there any use for phanton types in a type synonym? it seems like it should produce a compiler warning or something
21:22:18 <mazur> *phantom :)
21:23:56 <slack1256> mazur: on default I think isn't. But with type families I think they can be useful
21:24:15 <slack1256> for example as an extra parameter to where to branch off
21:25:45 <bz> hello
21:26:43 <mjrosenb> bz: hello.
21:28:25 <mazur> slack1256: ok i have yet to understand type families- the wiki says they are the data type analogue to type classes. i tend to think of type classes as predicates on types, are type families then predicates on terms?
21:28:42 <johnw> type families are like functions of types
21:28:49 <johnw> i.e., given an input type, you get an output type
21:29:20 <mazur> isn't that what any type constructor does with 1 or more type parameters?
21:29:30 <johnw> type families are not injective
21:29:41 <johnw> so multiple input types could map to the same output type
21:30:01 <johnw> for example, I could make Family a that for a ~ Int gives Double, but for everything else gives Float
21:31:00 <johnw> and a type synonym cannot vary in the result type
21:31:21 <johnw> it's more like a function a polymorphic type function constrained to a single definition
21:32:02 <johnw> data families, on the other hand, are types indexed by a type, which are a lot more like type constructors
21:32:14 <johnw> but you can build multiple indices for different relations
21:33:19 <johnw> i.e., you get to chose what the data family maps to for a given type
21:33:27 <johnw> instead of it being pre-determined as with a type constructor
21:33:38 <slack1256> the example on the wiki for the list data type is a good one for that
21:33:52 <johnw> thus, Key m :: * can be the key type for 'm', even for 'm's you know nothing about yet
21:34:01 <slack1256> for pure type families I think the example of composition of bijective functions is bijective is also good (also on the haskellwiki)
21:34:31 * hackagebot timestamper 1.0.3 - Read standard input and prepend each line with a timestamp  https://hackage.haskell.org/package/timestamper-1.0.3 (kisom)
21:39:01 <mazur> whew, ok i have a ways to go i think. thanks :D
21:45:31 <caconym> anyone know of a nice library for computing primitive geometry intersections? e.g. segment-triangle
21:48:00 <cwl> I am building cpphs-1.19.1, and encounter compiler error: Language/Preprocessor/Cpphs/CppIfdef.hs:199:25:     Not in scope: ‘isPrefixOf’
21:48:33 <cwl> `import Data.List        (intercalate, isPrefixOf)` can fix
21:48:47 <cwl> Where can I report this.
21:48:54 <cwl> It's not hosted on github
21:50:45 <cwl> https://hackage.haskell.org/package/cpphs-1.19.1/reports/1
22:00:33 <root____2> :q
22:00:34 <root____2> q
22:02:05 <gaze__> Hey folks. Say I want to represent an AST which is built up by some external library via a visitor
22:03:15 <gaze__> someone calls us with node information and the node's parent
22:04:03 <gaze__> how should I store my AST so I can quickly jump to some node to update it?
22:04:55 <slack1256> If you are on a Abstract Syntax Tree and you want to move withing the tree, that sounds like a Zipper
22:05:52 <gaze__> sure
22:06:08 <gaze__> but that doesn't let me quickly index to an arbitrary node by key
22:07:37 <Iceland_jack> gaze__: Could something like Data.IntMap be what you want
22:07:42 <Iceland_jack> or are you just looking for a graph library
22:07:51 <gaze__> I mean I can't tell...
22:08:01 <gaze__> So, there's this one trick whose name I can't remember where you store an ast as data AST a = Add a a | Neg a
22:08:02 <acewonder6743> c
22:08:14 <acewonder6743> Can this language do whatever Python can?
22:08:23 <acewonder6743> And why does the syntax look so advanced?
22:08:29 <gaze__> and for something like that you can just flip to a graph repr whenever you want
22:08:31 <Iceland_jack> It's from the future
22:08:32 <slack1256> acewonder6743:  by turing completeness it can
22:08:33 <codebje> it's turing complete
22:08:46 <slack1256> But whether you can do it easily and vice versa is another theme
22:09:01 <gaze__> or just take the fixed point of that data type
22:09:06 <gaze__> decorate it
22:09:09 <gaze__> yada yada
22:09:13 <gaze__> but you only have an Expr type
22:09:30 <slack1256> I mean you can dig a pool with a shovel or a machine. Yet if you do the first you're a fool
22:09:35 <codebje> c++ templates are turing complete, so it doesn't mean that much :-)
22:09:44 <acewonder6743> Why does the syntax look so advanced?
22:09:50 <acewonder6743> For Haskell I mean?
22:09:50 <slack1256> it isn't
22:09:52 <pacak> acewonder6743: No, there's no GIL in haskell.
22:09:53 <codebje> what do you mean by advanced?
22:09:56 <gaze__> I can't tell if there's some generalization where I can have different expression types
22:09:56 <slack1256> is just not C based
22:10:18 <acewonder6743> It looks like it's for very smart people/mathematicians/geniuses
22:10:36 <Iceland_jack> gaze__: Functional Programming with Structured Graphs, is one solution but maybe harder to use at first
22:10:43 <codebje> nah, I can use it, so it's not that advanced
22:10:55 <codebje> it's just different
22:11:19 <gaze__> Iceland_jack: what's a structured graph?
22:11:25 <gaze__> I want a sort of typed graph
22:11:27 <codebje> if you're coming from python, you're hitting an impedance barrier going from imperative with a smattering of OO to functional
22:11:32 <codebje> that'll take time to adjust to
22:12:05 <codebje> after a while haskell syntax feels fairly natural, though I still get lost in operator line noise looking at more experienced developers' code
22:13:41 <acewonder6743> Does knowing and practicin gin Haskell make you a better programmer?
22:13:53 <codebje> I think 'yes'
22:14:09 <codebje> at least knowing it does, in the sense that certain features of other languages have become clearer to me
22:14:21 <codebje> I can produce more understandable, testable, and robust Java as a consequence of having learned Haskell
22:14:25 <gaze__> acewonder6743: Just go learn it. It's worth your time I promise.
22:14:35 <gaze__> you're smart enough I assure you
22:14:48 <codebje> the downside is I felt the need to make a blog with the lambda character somewhere in it and talk about categories, so watch out for that
22:14:53 <yarou> no, understanding the fundamentals of CS will make you a better programmer.
22:14:57 <Iceland_jack> haha
22:15:09 <acewonder6743> is it a good language for someone hoping to improve their algorithm design/problem solving skills in programming?
22:15:47 <johnw> I would say that Haskell is language as much about engineering as it is about computer science, which is a wonderful sweet spot
22:15:57 <johnw> too many languages have extremely little to do with actual CS
22:15:59 <codebje> that's a tricky question - I think it's orthogonal; you can learn algorithm design without learning haskell, though as yarou suggests haskell might expose you to some more fundamental truths about programming
22:16:42 <elton> learning haskell for a couple months makes you a better programmer and opens a different way of thinking 
22:16:47 <Iceland_jack> My experience, there are certain 'barriers' in Haskell such that once you cross them you gain a deeper understanding of languages other than Haskell
22:17:06 <Silpheed> Hello.
22:17:16 <acewonder6743> so I should probably learn Haskell as my first language then?
22:17:21 <yarou> definitely.
22:17:25 <Iceland_jack> If you want
22:18:01 <elton> idk about that, i think most ppl pick up imperative language first?
22:18:42 <peddie> acewonder6743: if you are this curious, just try it :)
22:19:25 <Silpheed> I'm new to the channel. I'm curious about Haskell after hearing about it for sometime. It looks like I just joined in right after someone else expressed their curiousity. I'm looking for some good resources to being learning. 
22:19:33 * hackagebot http2 1.0.3 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.0.3 (KazuYamamoto)
22:19:39 <Silpheed> begin*
22:19:55 <peddie> @where learnhaskell
22:19:55 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:20:48 <gaze__> Iceland_jack: This just looks like the trick of representing the AST as the cofree comonad over your base AST functor
22:21:34 <Iceland_jack> gaze__: In reference to "Functional Programming with Structured Graphs"? No that's different
22:21:38 <gaze__> yeah
22:22:15 <gaze__> Iceland_jack: Hmmm...
22:25:30 <codebje> right, so, "hello world" with ghcjs -> ~76k, purescript -> ~14k, fay -> 5k
22:25:46 <codebje> I kind of expected purescript to produce something smaller given its nature
22:25:52 <hyy> Hi guys, can you teach me Haskell>
22:26:06 <slack1256> @where lyah
22:26:06 <lambdabot> http://www.learnyouahaskell.com/
22:26:09 <peddie> @where learnhaskell hyy
22:26:09 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:26:13 <gaze__> uhhy... okay... another way to say this. I have a set of mutually recursive data structures and I want to easily jump to any node by some key
22:26:13 <peddie> lol
22:26:32 <gaze__> so is that a structured graph?
22:27:13 <slack1256> What is a structured graph? I know about adirected and acyclics ones
22:27:17 <Iceland_jack> Yes but it would be a pain, it sounds like something like a bidirectional map would do
22:27:46 <Iceland_jack> There are some papers that show how to do mutually recursive structured graphs I think
22:27:48 <gaze__> I want to represent a tree... which is a graph, but it's a tree. Functorizing my AST only works with standard recursive datastructures
22:27:59 <gaze__> yeah...
22:28:08 <hyy> how can Haskell do Qt 5?
22:28:10 <hyy> can it?
22:28:35 <slack1256> Qml yes, Qt is difficult to bind because name mangling
22:28:40 <slack1256> @where hsqml
22:28:40 <lambdabot> I know nothing about hsqml.
22:28:58 <slack1256> http://www.gekkou.co.uk/software/hsqml/
22:29:33 <gaze__> man this blows. This is the exact same problem I always run into in haskell. It's very to store my data structure in an impossible to work with way.
22:29:49 <gaze__> hell I could tie knots
22:30:06 <gaze__> sorry. venting.
22:30:23 <slack1256> gaze__: if you showed some code, you could give us more context
22:30:43 <slack1256> I mean you can only say so much on single line of 500 character on IRC
22:32:14 <gaze__> slack1256: It's not complicated. say I have a data A = W B B | X C; data B = Y A B;... etc. etc.
22:32:31 <gaze__> on and on. A complex series of mutually recursive datastructures
22:33:41 <gaze__> I wish to build this based on a stream of instructions, each of which may attach a child to any node.
22:33:52 <gaze__> this requires that at any point my fold has to mantain a partial tree.
22:33:58 <gaze__> I think...
22:34:07 <gaze__> it has to leave some leaf and focus on some other point
22:34:18 <johnw> code says so much more than words
22:34:20 <acewonder6743> Will Haskell allow me to touch on low-level stuff like memory management, pointers, binary and hex?
22:34:26 <gaze__> so then you have data A = W (Maybe B) (Maybe B)....
22:34:32 <gaze__> yada yada
22:34:54 <codebje> acewonder6743, you'll have to go out of your way to deal with tht stuff
22:34:58 <slack1256> gaze__: At that point of mutually recursive that you want to update only some level (or that evaluate true to some hashes) I would start looking at generic programming like syb
22:34:58 <codebje> well, binary and hex you'll find
22:35:21 <codebje> but memory management and pointers aren't very common in haskell
22:37:14 <gaze__> slack1256: SYB? Really?
22:37:21 <acewonder6743> WHich is better as a first lang: Lisp or Haskell?
22:37:24 <gaze__> there's no alternative encoding for my mutually recursive datastructure?
22:37:32 <slack1256> uniplate? 
22:37:56 <gaze__> i'm not at all attached to those types
22:38:05 <gaze__> I just want to represent the tree in a well-typed way
22:38:27 <gaze__> like I love the functorized AST trick... data ExpF a = Add a a | Neg a for instance
22:38:37 <gaze__> there's no mutually-recursive generalization of that?
22:38:42 <johnw> sure there is
22:38:45 <slack1256> @type Compose
22:38:46 <johnw> multiple type indices
22:38:47 <lambdabot>     Not in scope: data constructor ‘Compose’
22:38:47 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
22:38:56 <codebje> acewonder6743, if lisp appeals, try Scheme, which is a deliberately smaller set of Lisp ideal for learning with
22:39:15 <slack1256> if you can represent your data types (the mutually recursive ones) as a composition of functors you can still use the "trick"
22:39:26 <gaze__> johnw: Oh yeah I guesssss I could do something like data ExpF a b c d e f g...
22:40:04 <johnw> you have 7 mutually recursive structures?
22:40:32 <gaze__> johnw: yep! C++ AST.
22:40:41 <codebje> or racket, which is scheme plus lots of other dialects but some nice pedagogic tools
22:40:53 <gaze__> or more? who knows.
22:41:11 <johnw> why do you need them to all be separate?
22:41:22 <johnw> you have Decls, Exprs, Types, Stmts
22:41:25 <johnw> but how many others?
22:42:14 <johnw> I'm not sure even clang has more than 7 major AST structures
22:42:33 <Silpheed> am I the sore thumb here using Windows
22:45:55 <porges> is it necessary to use pipes-safe if you want 'prompt' resource diposal?
22:46:16 <slack1256> I thought resourcet also worked
22:46:36 <johnw> porges: that doesn't guarantee prompt disposal
22:47:08 <porges> "Notable features include: Promptness"
22:47:19 <benzrf> yes Silpheed 
22:47:23 <benzrf> get on a better OS :>
22:47:35 <benzrf> (there are some other windows users i think)
22:47:37 <slack1256> you mean win10 right?
22:47:40 <johnw> porges: link?
22:47:47 <porges> from https://hackage.haskell.org/package/pipes-safe
22:47:53 <johnw> ah
22:47:54 <gaze__> Silpheed: You're in the minority but it's not that small of a minority
22:47:56 <Silpheed> i'm just a bit confused with the GHC + Cabal thing
22:48:02 <johnw> so, there could be two meanings for promptness here
22:48:11 <johnw> you *are* guarantee that all resources are freed when runSafeT is done
22:48:24 <johnw> you are *not* guaranteed that all resources are freed immediately
22:48:29 <benzrf> install gnu/linux, Silpheed
22:48:31 <benzrf> :>
22:48:41 <gaze__> benzrf: Don't be a jerk.
22:48:48 <slack1256> ?
22:48:51 <Silpheed> I'd rather have a dedicated linux machine
22:48:59 <porges> but will it happen faster than with just plain pipes? the documentation/blog posts seem to indicate something along those lines
22:49:24 <gaze__> johnw: Maybe I'm too stuck thinking in terms of classes
22:49:34 <porges> BTW I figured out my issues with pipes-http in the end and dumped it, it wasn't solving what I wanted. writing a replacement with pipes-safe is near trivial
22:49:57 <gaze__> johnw: the C++ way of representing this is that you have a class for a statement, a class for a declarator, a class for a function definition, a class for a translation unit
22:50:00 <johnw> porges: yeah, it'll bound the resource acquisition by runSafeT
22:50:31 <johnw> gaze__: I could see having an ADT for the different kinds of Exprs, Decls, etc.
22:50:38 <johnw> but they don't each need to be recursive grammars
22:50:51 <johnw> you only need one recursor if all the sub-ADTs do is aggregate within the parent
22:51:13 <johnw> i.e., CppAST a r = CPPDecl (Decl a r) | CPPExpr (Expr a r), etc.
22:51:31 <johnw> you do need separate recursors if you want to bound where the tree can be recursive
22:51:31 <gaze__> johnw: Sure! That's what I was thinking, too. Surely addition, subtraction, yada yada should all be summed together in an ADT
22:51:48 <johnw> for example, Exprs can't recurse to contain Stmts
22:51:53 <johnw> but a Stmt can recurse into Exprs
22:52:10 <johnw> so that's two type variables, in this kind of design
22:52:30 <johnw> but it's really all about whether you want to use the functoral AST trick or not
22:52:31 <gaze__> johnw: Yeah. That works. I buy that... the issue is now if you wanna extend this
22:52:35 <johnw> life does not end by not doing that
22:52:53 <gaze__> johnw: Yeah... it's true...
22:52:53 <johnw> there's also another way
22:52:59 <gaze__> what would you recommend?
22:53:22 <johnw> Stmt a r = StmtExpr (Free (Expr a)) r
22:53:30 <johnw> you just explicitly curtail the recursion
22:53:48 <johnw> that there makes StmtExpr a chain of Expr grammars
22:54:13 <johnw> this moves the complexity to the evaluator
22:54:32 <johnw> since now you'll need to explicitly have 7 separate evaluators, one for each use of Free
22:54:46 <johnw> which isn't necessarily a bad thing
22:55:02 <johnw> but it does let us move the complexity out of the set of type variables
22:55:11 <johnw> now each ADT has its own recursor
22:55:23 <johnw> and the other ADTs don't know about it
22:55:34 <gaze__> johnw: "now each ADT has its own recursor" that seems like a good thing.
22:55:44 <johnw> at first blush I tend to agree
22:55:52 <johnw> but I'd have to code up a prototype and see how I felt about it
22:56:13 <gaze__> I'm afraid you lost me with the type, though
22:56:16 <johnw> it does mean you can modularize evaluation, pretty printing, etc.
22:56:23 <benzrf> gaze__: do you know about Free?
22:56:34 <johnw> Free turns functoral ASTs into grammars
22:57:40 <gaze__> hrmm.... this relates to that Mu thing.
22:57:45 <johnw> yes
22:57:49 <johnw> Free can be defined in terms of Mu
22:57:53 <johnw> it just gives you a free Monad instance
22:58:44 <johnw> using Mu directly will be cumbersome, unless you didn't want a monad (which makes the whole DSL angle much less useful)
22:59:16 <johnw> properly done, with pattern synonyms and such, youl'l be able to construct ASTs using do-notation in a pretty sexy way
22:59:29 <johnw> this is one of the things Haskell is superb at doing
23:00:46 <benzrf> gaze__: Free is like Mu but with the potential for the repeated application to eventually terminate
23:01:13 <benzrf> Free f a ~ a + f a + f (f a) + f (f (f a)) ...
23:01:44 <gaze__> Is this Control.Monad.Free?
23:01:47 <johnw> Free f a = Mu (Compose  (Either a) f)
23:01:48 <johnw> yes
23:02:24 <benzrf> gaze__: in general, if f is a functor, Free f is a monad
23:02:37 <benzrf> even if f isnt
23:02:44 <benzrf> you get a monad 'for free'
23:03:00 <johnw> even though that's not why it's called free
23:03:09 <benzrf> johnw: no?
23:03:26 <johnw> it's free of any semantics other than given by the laws
23:03:36 <benzrf> holy shit
23:03:38 <johnw> not that you didn't have to pay for it :)
23:03:40 <benzrf> is that the origin of the term in general
23:03:55 <johnw> yeah, free objects naturally arise from their corresponding algebra
23:04:03 <benzrf> ive been living a lie
23:04:06 <benzrf> this whole time
23:04:06 <johnw> it's the object implied by that algebra
23:04:08 <benzrf> ;-;
23:04:15 <johnw> well, I mean it is free in that you don't have to do anything to get it
23:04:22 <johnw> simply by defining the algebra, you get it "for free", as you said
23:04:24 <benzrf> like
23:04:27 <johnw> so I guess it has both meanings
23:04:33 <benzrf> hm
23:04:48 <benzrf> well i thought free in general, like free group or free monad, was bc 'for free'
23:04:57 <johnw> ok, I can buy that
23:05:10 <johnw> either "free of interpretation", or "arising for free from the algebra"
23:05:38 <johnw> the latter is the same free as in "theorems for free"
23:05:44 <johnw> things that just pop into existence once you have something else
23:06:09 <johnw> I wonder if that makes duality a kind of freeness too...
23:06:51 <johnw> oh, and there's another sense of "free" here
23:07:36 <Silpheed> sorry to interrupt with an insanely basic question, but what executable am I supposed to use to start GHC?
23:07:40 <johnw> the free monad is the initial algebra, so it is truly free in the sense that every other algebra for Monad is forgetful of that initial structure
23:07:51 <benzrf> Silpheed: ghc
23:08:02 <johnw> ghc or ghci
23:08:07 <benzrf> it should be in your PATH if you installed it from your system package manager oh wait
23:08:11 <benzrf> (sorry)
23:08:45 <Silpheed> don't worry, buddy I got both of those here on windows
23:08:58 <Silpheed> but the only one yielding any results is the interactive mode
23:12:07 <liste> Silpheed how are you calling ghc?
23:12:29 <Silpheed> I'm not sure what you mean
23:12:36 <gaze__> johnw: I'm still pretty confused. So okay StmtExpr (Free (Expr a)) r... what's r for?
23:13:02 <liste> Silpheed something like C:\myproject\> ghc MyFile.hs ?
23:13:22 <Silpheed> oh wait a minute
23:13:30 <Silpheed> i'm being pampered here, aren't I
23:13:57 <Silpheed> here I am expecting something like Netbeans to pop up but really it's just a compiler, right?
23:14:15 <liste> Silpheed yep
23:14:23 <johnw> gaze__: Stmt a r = StmtExpr (Free (Expr a)) r
23:14:28 <Silpheed> liste, thanks
23:14:31 <johnw> is just one kind of statement, a statement expression
23:14:40 <johnw> which is naturally an expression, followed by another statement
23:14:48 <johnw> Expr a r = .... r
23:14:51 <johnw> is the AST of expressions
23:15:03 <johnw> a StmtExpr contains an expression tree, followed by another statement
23:15:11 <johnw> those are two different r's
23:15:19 <johnw> one for the Expr recursion, making an expression tree
23:15:28 <johnw> and one for the Stmt recursion, allowing a sequence of statements
23:15:47 <Silpheed> as a side question, does "lazy" used to describe haskell mean that things like caching are nonexistant
23:16:59 <benzrf> what kind of caching Silpheed 
23:17:15 <johnw> lazy means that non-strictness is implemented using "thunks" that evaluate only when required
23:17:27 <johnw> like promises in other languages
23:17:32 <johnw> but totally implicit, and everywhere
23:17:51 <johnw> it's a great thing for function composition
23:18:18 <Silpheed> that's way over my head. I don't really even understand what being a functional language means. I'm only experienced in Java and C#
23:19:30 <johnw> a "functional language" is based on the lambda calculus, where functions and functions that take and return functions are used to build up structures
23:20:19 <Silpheed> but from this cis194 class from the git, it is written: "In Haskell, expressions are not evaluated until their results are actually needed" which leads me to think things such as caching (storing a value into a variable and reusing the variable, as opposed to simply calculating the data everytime you need it) are redudant/obsolete
23:20:29 <johnw> many lambda calculii include fundamental types for convenience, like booleans, integers, lists, etc., but you could represent these purely by functions
23:20:44 <benzrf> jjjj
23:20:46 <benzrf> oops
23:20:53 <johnw> oh, you mean memoization by caching
23:21:23 <Silpheed> i suppose so?
23:21:24 <johnw> there are several dimensions to this
23:21:30 <johnw> some of them are what you're saying, and some aren't
23:21:44 <johnw> a thunk, once evaluated, is replaced by its value, that is true
23:22:02 <johnw> but two calls to "foo 10" will not necessarily realize that they evaluate to the same value and thus share the evaluation
23:22:09 <johnw> it depends on the optimizer, and the conteuxt
23:22:33 <johnw> you can force memoization, so that "foo 10" is only evaluated once, but it comes at a memory cost
23:22:40 <Silpheed> but just earlier I read that every form of data is immutable
23:22:47 <Silpheed> so how would tow calls to the same program not be fungible
23:23:00 <johnw> the semantics only say that they have to yield the same result
23:23:12 <johnw> not that the two results must be represented by the same exact bits in memory
23:23:30 <Silpheed> oh, I see
23:23:33 <johnw> i.e., if "foo 10 = 20", then it's 20 every and can't be changed
23:23:45 <johnw> but five calls may result in 5 20s appearing in your heap, it depends
23:24:18 <johnw> the 20ness of the answer is the semantics you should care about most
23:24:26 <benzrf> Silpheed: i think 'fungible' is a property of a type of thing, rather than of a pair of instance of it
23:24:32 <benzrf> youd just say interchangible there
23:24:34 <johnw> the sharing of the answer is an operational concern, which we prefer to leave to the compiler
23:24:40 <benzrf> ^
23:24:44 <johnw> unless you choose to force it to happen, which you can do
23:25:25 <johnw> but definitely if you are just learning Haskell, try to ignore and forget everything you know about how computers operate
23:25:28 <johnw> think mathematically
23:25:34 <johnw> and come back to the operation later, gradually
23:25:40 <johnw> trust me, it'll pay off :)
23:25:49 <Silpheed> okay
23:25:57 <johnw> my biggest mistake learning Haskell was to think like a C++ programmer
23:26:17 <johnw> always "what register will this be in, where is it in memory, when is this function called"
23:26:23 <johnw> instead of "what does this definition mean?"
23:26:53 <Silpheed> but you mentioned that a functional language structures itself through multiple iterations of functions?
23:27:00 <johnw> if the answer is right and delivered in a timely enough fashion, then how you get it doesn't matter at all; it only pays to think at that level if you have a very specific need to
23:27:04 <Silpheed> so wat is that in contrast to with an imperative language
23:27:09 <johnw> Silpheed: it can
23:27:14 <johnw> so, going back to the 1930s
23:27:37 <johnw> there was Turning, and Church
23:27:47 <johnw> Turing believed in a machine that iterated through a series of states
23:27:56 <benzrf> Turning the new clone of Turing
23:27:57 <johnw> Church wanted to base mathematics on the definition of functions
23:28:12 <Silpheed> lambda
23:28:14 <johnw> Church failed at revolutionizing mathematics
23:28:17 <benzrf> r i p
23:28:22 <benzrf> johnw: welllll
23:28:32 <johnw> but he created a way of looking at computing that could be *implemented* on a Turing machine
23:28:35 <benzrf> type theory is around! the revolution will bE ANY DAY NOW
23:28:41 <augur> any tools / suggestions for when to use strictness?
23:28:48 <johnw> yeah, Church's original intent may win in the end :)
23:29:03 <johnw> augur: if you are building up thunks needlessly
23:29:13 <augur> johnw: how to tell? :x
23:29:19 <johnw> augur: profiler output
23:29:35 <johnw> both resident size, and GC activity
23:29:46 <augur> hmm. anything i can read on this?
23:29:49 <johnw> you want as little strictness as possible, until you need it
23:29:56 <Silpheed> so these types generalize more minute functions of math?
23:29:56 <johnw> yeah, there's lot of info
23:30:03 <augur> ive not used a profiler for memory stuff so i dunno whats up
23:30:07 <johnw> Silpheed: take booleans for example
23:30:39 <johnw> we can define booleans as two functions: one that returns its first argument (true), and one that returns its second argument (false)
23:30:58 <johnw> using that definition, we can construct all the usual logic operations on the booleans
23:31:19 <johnw> and they have same *semantics* as the booleans we know and love
23:31:33 <johnw> nowadays we'd call them Church-encoded booleans
23:31:46 <augur> i wrote a blog post on church encodings a loooong time ago
23:31:52 <johnw> it's actually a fun exercise to define them and build out that logic yourself as an exercise
23:31:53 <augur> and scott encodings
23:32:04 <johnw> then progress to the natural numbers
23:32:05 <augur> trying to help explain them and why they are what they are
23:32:08 <johnw> and then to lists
23:32:13 <johnw> and soon you realize, everything's a function!
23:32:21 <johnw> (at least, in the lambda calculus)
23:32:30 <augur> johnw: well, the encodings are functions :)
23:32:48 <Silpheed> so what is a logical AND using a boolean function
23:32:52 <johnw> i mean, given a simple, untyped lambda calculus, functions and names of functions are the only things you have
23:33:16 <benzrf> Silpheed: the key is to think structurally
23:33:22 <benzrf> Silpheed: it doesnt matter 'what' something is, just how it behaves
23:33:28 <augur> i dare say the key is to not think at all
23:33:51 <benzrf> Silpheed: in particular: the nature of booleans is that you have 2 values and several operations whose tables take a particular shape
23:33:51 <johnw> and: \f g -> f g f
23:34:00 <augur> the beautiful thing about scott encodings is that you dont HAVE to think
23:34:02 <benzrf> Silpheed: you can accomplish this in the lambda calculus, even if they arent "really" booleans
23:34:07 <augur> you can define them, and then forget about them
23:34:27 <liste> Silpheed if true is "\x y -> x" and false is "\x y -> y" then and is "\x y -> x y x", as johnw said
23:34:32 <augur> define   if b x y = b x y
23:34:36 * hackagebot MonadCompose 0.8.3.1 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.3.1 (JamesCandy)
23:34:41 <augur> ie  if = \b x y -> b x y
23:34:45 <augur> then forget that you did so
23:35:02 <augur> and x y = if x then y else false
23:35:19 <augur> well,   and x y = if x y false
23:35:20 <johnw> i.e.: if f is true, it returns the truth of g, otherwise it returns its own result which we know is false
23:35:44 <Silpheed> why is it xyx and not xx
23:36:04 <johnw> f is a function of two arguments
23:36:09 <johnw> and and is a function of two arguments
23:36:17 <johnw> booleans are not values here, they are functions of two arguments
23:36:29 <johnw> where each argument represent the "constructor" for true or false, in a way
23:36:41 <liste> > let {true' = \x y -> x; false' = \x y -> y; and' = \x y -> x y x} in (and' true' false') 't' 'f'
23:36:42 <lambdabot>      Occurs check: cannot construct the infinite type:
23:36:43 <lambdabot>        t2 ~ t1 -> t2 -> t
23:36:43 <lambdabot>      Relevant bindings include
23:36:49 <augur> i think using the  \f g -> f g f   encoding is confusing
23:37:06 <augur> and = \f g -> f g (\x y -> y)
23:37:16 <johnw> Church-encoding are in general confusing until you think about them a lot :)
23:37:23 <Silpheed> this is mindboggling but I'm intruiged
23:37:32 <Silpheed> i'll read more from the lesson and come back with more questions
23:37:33 <johnw> this is why we call Haskell a functional language :)
23:37:35 <Silpheed> thanks for the explanations
23:37:37 <johnw> it's lambda underneath
23:37:42 <augur> johnw: no its not
23:37:52 <augur> Haskell does not implement anything via church encodings
23:37:55 <johnw> System FC is not an extension of the simply-typed lambda calculus?
23:38:12 <augur> System FC has first order data
23:38:19 <johnw> I mentioned earlier that some extension of the lambda calculus offer additional functionality for convenience
23:38:31 <augur> at least afaik it does
23:38:49 <augur> at any rate, no implementation of Haskell uses church encodings
23:38:56 <johnw> that's not what I'm talking about
23:39:17 <augur> Silpheed: if you want to truly understand church encodings, i can provide a helpful perspective
23:39:43 <Silpheed> augur: I'm interested
23:39:59 <johnw> I never suggested that lambda calculus == church encodings
23:41:02 <johnw> I'm explaining how Church created the lambda calculus to express mathematical structures using his encoding-functions; but that's not where the concept ended
23:41:15 <johnw> just where it all began
23:41:28 <augur> Silpheed: ok, so lets just consider booleans like normal -- data Bool = True | False
23:41:42 <augur> Silpheed: how do you _use_ a boolean value?
23:41:50 <Gurkenglas> Suggest a name for Data.Tree's levels generalized to Cofree and any monad.
23:42:16 <johnw> branches?
23:42:32 <Silpheed> I guess you'd have to pick which valeu you want
23:42:50 <hyy> is there a way I can get beginner programming knowledge with haskell as lyah is just too complex?
23:42:55 <augur> Silpheed: right. you inspect it and see if its True or False and do something for each choice
23:43:00 <johnw> yes, the usefulness of a boolean is to decide between alternatives
23:43:08 <augur> Silpheed: ie you use it with "if"
23:43:30 <johnw> hyy: hmm, LYAH is the simplest I know of
23:43:50 <augur> Silpheed: the essence of a boolean is precisely that it choses between two things   if True then x else y  =  x   ;   if False then x else y  =  y
23:43:57 <augur> Silpheed: and nothing else!
23:44:03 * nshepperd thinks of church encoding as turning case matching into a function
23:44:07 <augur> lets define if as a patterh-matching function
23:44:14 <augur> if' :: Bool -> a -> a
23:44:18 <augur> if' True x y = x
23:44:19 <shachaf> nshepperd: That sounds more like Scott encoding.
23:44:22 <johnw> nshepperd: isn't that just what scott encondings do?
23:44:24 <augur> if' False x y = y
23:44:46 <augur> Silpheed: now, lets push some of the lambdas to the right of =
23:44:49 <Gurkenglas> johnw, that doesn't fit, I think. Its type signature is (Monad m, ComonadCofree m w) => w a -> [m a].
23:44:57 <augur> if' True = \x y -> x   ;   if' False = \x y -> y
23:44:58 <Silpheed> wait wait wait
23:45:02 <augur> Silpheed: waiting!
23:45:03 <Gurkenglas> (Should those constraints be the other way round?)
23:45:08 <nshepperd> maybe?
23:45:16 <Silpheed> what does if' :: Bool -> a -> a mean
23:45:20 <nshepperd> not sure what scott encoding is
23:45:33 <hyy> then johnw , what if you helped me by showing what beginner projects I can do?
23:45:39 <shachaf> nshepperd: The issue is what happens with recursive types.
23:45:49 <johnw> hyy: what would you like to use Haskell for?
23:46:04 <shachaf> E.g. the Church encoding of a list doesn't just match one level, it replaces (:)s with a function all the way through.
23:46:05 <augur> Silpheed: oh sorry there's a typo there btw: should be Bool -> a -> a -> a
23:46:14 <augur> Silpheed: oh its just the type of if' -- if' is a function (->) that takes a Bool and gives you an (a -> a -> a)
23:46:20 <hyy> johnw: alarm clocks, Wayland (Linux), and device drivers for GNU Hurd. Also, a music player
23:46:31 <augur> Silpheed: in general, "S -> T" means "a function from S's to T's""
23:46:32 <Silpheed> what is an a -> a -> a
23:46:39 <johnw> hyy: interesting collection!
23:46:58 <augur> so "a -> a -> a" is a function from a's to (a -> a)'s  (for any choice of a's
23:47:00 <Silpheed> ah. Sorry, yeah I've yet to see a written line of haskell so i'm a bit new to the syntax
23:47:06 <augur> oh ok
23:47:15 <nshepperd> oh yeah, church encoding of a list is foldr
23:47:19 <augur> well, pretend i didnt write that :)
23:47:20 <nshepperd> that makes sense
23:47:29 <augur> nshepperd: bingo bango bongo :)
23:47:42 <hyy> if I wanted a command that made a audio file play to completion with no rewind, fast forward or stop button to speak of...
23:47:50 <augur> nshepperd: the scott encoding is case on lists (scott encodings = case, church = fold)
23:47:58 <hyy> if I wanted an alarm clock what do I do?
23:48:17 <johnw> hyy: I'd start with alarm clocks, but define time as a function from an earlier time value to the next time step, that way you can learn using pure functions and leave IO until later.  So, I'd start by writing a function that iterates through time until it reaches the desired time or later, and prints out "ALARM!".  After, we can use a real time source, and sleep until the desired time
23:48:21 <augur> Silpheed: uh hm ok so.. did the subsequent lines make sense at least?
23:48:46 <Silpheed> for the msot part, yes
23:48:54 <augur> Silpheed: actually if i may make a suggestion, forget church encodings for now
23:49:01 <Silpheed> defining what true and false are
23:49:02 <Gurkenglas> When I make a pull request for a single commit (adding an instance to a library), does anything go in the pull request description?
23:49:14 <Silpheed> or I guess how they're used, rather
23:49:19 <hyy> johnw: but how do I do all that?
23:49:20 <augur> dont pay any attention to them until you understand normal non-church encodings
23:49:22 <hyy> I'm not a genius.
23:49:39 <augur> Silpheed: they're a cute historical trick but they will confuse the fuck out of you if you try to understand them right now
23:49:45 <hyy> a function that takes a ton of time to count up?
23:49:56 <johnw> yeah, basically
23:50:01 <johnw> the dumbest way to solve the problem possible
23:50:15 <hyy> johnw: are you talking to me?
23:50:19 <johnw> yes
23:50:23 <augur> Silpheed: if you learn some basic FP w/ proper data types, and then return to church stuff, you'll be fine, it'll be easy to understand, but if you start with them youll be bashing your head against a wall because they're so confusing
23:50:41 <johnw> alarm :: String -> TimeFunction -> String
23:50:58 <Silpheed> I think I'll do a hello world and some basic programs then come back to the chat
23:51:15 <Silpheed> I need at least a rudimentary understanding first then I'll have a ton more questions
23:51:20 <Silpheed> thanks for all the help so far
23:51:29 <augur> Silpheed: good idea. you should learn about defining data types, and about pattern matching (either with case or with pattern matching functions)
23:51:31 <johnw> oh, and you'll need a starting time and a desired time
23:51:36 <johnw> anyway, you need to start with basic functions
23:51:51 <johnw> which is where I would have thought LYAH would help
23:52:11 <augur> Silpheed: ill be awake again in like 10 hours so feel free to poke me
23:52:31 <Silpheed> sure thing, thanks again
23:52:53 <augur> Silpheed: why did you come to church encodings anyhow?
23:53:19 <Silpheed> i didn't? I just asked what a functional programming language is like
23:53:25 <johnw> he wanted to know why Haskell is called a functional language
23:53:28 <johnw> but he asked in #haskell
23:53:38 <Silpheed> and johnw mentioned Church vs Turing and the different ideologies
23:53:43 <augur> Silpheed: oh
23:53:44 <johnw> I only introduced Church encodings to talk about the lambda calculus
23:53:45 <augur> oh oh
23:53:50 <johnw> then others ran with the whole church thing
23:53:51 <augur> Silpheed: dont pay any mind to that then
23:54:10 <augur> Silpheed: its a distraction and johnw should know better than to answer like that
23:54:19 <Silpheed> it's alright, i'm all for learning history anyways
23:54:26 <hyy> johnw: um if I wanted a counter based on int's that every time it overflowed it incremented x by one
23:54:27 <augur> Silpheed: haskell is a functional language because it gives functions pride of place to functions
23:54:28 <johnw> augur: ?  He seemed interested in more than just a quick answer
23:55:17 <augur> Silpheed: functions are first class values like numbers and strings are in other languages, and it promotes use of functions over use of iteration and state and mutation and so forth
23:55:56 <johnw> hyy: I didn't quite understand
23:56:14 <liste> lambda calculus is one way to learn FP, but imo maybe it would be easier to start with untyped lambda calculus
23:56:21 <hyy> johnw: um it counts to INT_MAX and simply records how many times it overflowed
23:56:48 <johnw> hyy: sure, I guess that's a function you could write
23:57:06 <augur> Silpheed: if you want to learn Haskell, I'd suggest reading Learn You a Haskell, tho I think there are some other resources that are out there as well that might be better
23:57:07 <liste> is there something akin to "the little schemer" for Haskell?
23:57:26 <Silpheed> i'm using this resource for now
23:57:27 <Silpheed> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
23:57:30 <hyy> I'm trying to make it so that there's a timer function, but I don't quite grasp how
23:57:37 <Silpheed> but yeah I might supplement it with the book
23:58:53 <augur> Silpheed: ah, that's probably ok :)
23:59:04 <johnw> hyy: I warned you it was dumb, but: https://gist.github.com/4fa0f2d06a596bc22cf0
23:59:28 <johnw> there are all kinds of ways to improve that function, so I'll leave you with that to start
23:59:33 <augur> Silpheed: the person teaching that class is none other than byorgey!
23:59:39 <augur> who isnt here right now unfortunately but
