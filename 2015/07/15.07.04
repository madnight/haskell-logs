00:00:05 <wei2912> wait a moment, you said "intelligently"
00:00:39 <wei2912> well, that involves folds -- have you covered them? otherwise i suggest you just use the function `reverse` as some sort of magic code
00:00:48 <wei2912> oh wait, he went to sleep
00:15:18 <gamegoblin> LOL I have a type signature that looks like IO (IO (IO (Maybe Bytestring)))
00:16:20 <gamegoblin> It binds a server socket, that’s the 1st IO, then it return an IO action (second IO) that, when bound, produces a wrapped hGet call on a handle (third IO)
00:16:33 <sccrstud92> :t join
00:16:35 <lambdabot> Monad m => m (m a) -> m a
00:17:47 <gamegoblin> sccrstud92: not what I need
00:18:02 <sccrstud92> huh?
00:18:43 <gamegoblin> Were you pointing out `join` at my comment?
00:20:04 <mniip> gamegoblin, you're doing it wrong
00:20:16 <gamegoblin> mniip: how should I be doing it?
00:20:17 <mniip> you never need more than one IO
00:20:33 <mniip> you could fix it with some 'join', or actually go back to where the issue is and use some >>=
00:20:40 <mniip> (or do-notation)
00:21:45 <mauke> what
00:21:55 <mauke> that's nonsense
00:22:00 <mniip> what is :o
00:22:09 <mauke> <mniip> you never need more than one IO
00:22:24 <mauke> join wouldn't "fix" it because there's no problem
00:22:27 <mniip> oh?
00:23:08 <gamegoblin> mniip: How would you accomplish this without nested IO? http://lpaste.net/4764303253179465728
00:23:08 <mniip> are you saying that laziness in executing the second and third action is the desired effect?
00:23:27 <gamegoblin> mniip: yes
00:23:28 <mauke> how is this laziness?
00:23:35 <mniip> interleavedness?
00:24:26 <mniip> okay then my apologies for assuming the wrong thing
00:25:03 <mauke> do unregister <- registerHandler foo; doStuff; unregister
00:25:12 <mauke> is the pattern that once cropped up in my code
00:25:23 <mauke> registerHandler :: Handler -> IO (IO ())
00:26:04 <mniip> sounds like a use for bracket?
00:26:49 <gamegoblin> mniip: You only want to bind the server socket once, so that unwraps your first IO. Now you have an action that wraps the "accept" call on the server socket to produce IO Handles. Now you want to read from the Handle, which is in IO. Hence 3 nested IOs. It’s an action (binding server socket) that yields an action (accepting handle) that yields an action (reading from handle) to produce bytestrings.
00:26:51 <mauke> this use of registerHandler, yes
00:27:07 <mauke> bracket foo id ... :-)
00:27:44 <mniip> gamegoblin, I get it, I get it
00:27:49 <L8D> mauke: why not withHandler
00:28:06 <L8D> mauke: withHandler :: Handler -> (IO () -> IO ())
00:28:25 <mauke> that type makes no sense
00:28:33 <L8D> oh wait
00:28:37 <L8D> mauke: withHandler :: Handler -> (IO () -> IO ()) -> IO ()
00:28:40 <L8D> there
00:28:51 <L8D> instead of do unregister <- registerHandler foo; doStuff; unregister
00:28:53 <mauke> hmm, no
00:29:11 <mauke> I misparsed your first version as the second, but the first is actually right :-)
00:29:22 <mniip> withHandler :: (Handler -> IO a) -> IO a
00:29:31 <gamegoblin> I also find myself using IO (IO a) for MVar craziness.
00:29:38 <mniip> oh wait, handler is given
00:29:39 <L8D> mauke: what does the "registerHandler" thing supposed to do?
00:30:10 <mauke> L8D: registers an event handler :-)
00:30:20 <L8D> mauke: with something else?
00:30:23 <mauke> yes
00:30:32 <mauke> this code is a bit simplified
00:30:49 <L8D> Ideally you don't want to have setup/teardown logic
00:31:05 <L8D> those are usually abstracted away with withX-like functions
00:31:11 <mauke> it's more like: registerHandler :: (Event a) => Reactor -> (a -> IO ()) -> IO (IO ())
00:31:27 <mauke> L8D: that only works if you call unregister right away
00:31:38 <mauke> which is not the common case
00:32:46 <L8D> mauke: also avoid suffixing function names with the types of their parameters
00:33:01 <mauke> the whole thing was really a PoC to see whether I could do something like irssi's signal system in Haskell
00:33:06 <L8D> mauke: you could probably just use 'register' and everything will be fine
00:33:25 <L8D> mauke: you might want to look into FRP instead
00:33:30 <mauke> register is too ambiguous
00:33:37 <mauke> for one, it's a noun
00:58:43 * hackagebot machinecell 2.0.1 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-2.0.1 (HidenoriAzuma)
01:36:40 <solrize> @hoogle Int -> Int#
01:36:40 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
01:36:40 <lambdabot> Prelude (!!) :: [a] -> Int -> a
01:36:40 <lambdabot> Data.List (!!) :: [a] -> Int -> a
01:40:52 <rtpg> Hey, I'm writing this pretty gnarly function that's traversing a complex data structure
01:41:32 <rtpg> for the most part, I want the function to be pure, but there's just one tiny branch where I want to have some IO
01:41:50 <rtpg> is there some sort of design pattern/tool in the toolbox to avoid having to make everything monadic?
01:42:33 <rtpg> putting 'return' everywhere isn't too great, and I also want to ensure the rest of the application stays pure 
01:44:30 <Haskellfant> I would probably write everything pure except the one function and then put it together using fmap/do notation
01:49:59 <L8D> rtpg: what kind of IO are you performing?
01:50:07 <L8D> because you can probably eliminate that instead
02:06:27 <jle`> rtpg is gone ;_;
02:13:47 * hackagebot ghc-core-html 0.1.3 - Core to HTML display  http://hackage.haskell.org/package/ghc-core-html-0.1.3 (VincentHanquez)
02:34:41 <latk> Is there any guide to using stack with multiple local projects?
02:37:56 <Haskellfant> look at the documentation for packages here https://github.com/commercialhaskell/stack/wiki/stack.yaml
02:38:11 <Haskellfant> basically it's as simple as putting multiple directories in the packages section
02:54:35 <latk> Haskellfant: Huh, that was really easy. Awesome.
02:55:42 <latk> Do you know if there is an equivalent to cabal run for stack?
02:56:05 <Haskellfant> cabal build && cabal exec executablename
03:02:58 <latk> Haskellfant: Isn't that using cabal rather than stack, though?
03:03:07 <Haskellfant> s/cabal/stack/
03:03:19 <Haskellfant> it's too hot to not do stupid mistakes :)
03:05:02 <latk> Haskellfant: :)
03:23:48 <maerwald> what's the best thing to "visualize" your project (similar to a class diagram in OOP languages)
03:30:52 <saep> git clone? :D
03:37:46 <maerwald> saep: was that a response to my question?
03:39:30 <osfameron> maerwald: I suspect so... I don't think there are really any good ways tbh
03:39:51 <osfameron> there is a tool called Autodia that might be able to output dia, if you wrote a Haskell handler for it
03:40:17 <osfameron> but I've never found the output especially illuminating (maybe you could hand-edit the dia output to give it rendering hints)
04:28:30 <appl12> > let alg (x:xs) = x + xs in alg (3,4)
04:28:32 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
04:28:32 <lambdabot>      Relevant bindings include
04:28:32 <lambdabot>        xs :: [a1] (bound at <interactive>:1:12)
04:29:42 <appl12> > let alg (x,y) = x + y in alg (3,4)
04:29:43 <lambdabot>  7
04:31:46 <appl12> > let alg (x,y) = x + y in alg [3,4]
04:31:48 <lambdabot>      Couldn't match expected type ‘(a, a)’ with actual type ‘[Integer]’
04:31:48 <lambdabot>      In the first argument of ‘alg’, namely ‘[3, 4]’
04:31:48 <lambdabot>      In the expression: alg [3, 4]
04:37:17 <mniip> appl12, in haskell tuples aren't related to lists
04:38:41 <latk> Is there an overview of text encoding that someone could suggest? I am finding it very confusing. I suspect this is due to the terminal doing some encoding of it's own..
04:42:12 <mniip> latk, text encoding?
04:42:37 <mniip> well internally Char (and thus String) stores unicode codepoints
04:42:56 <latk> mniip: In general, so things like how does a Text utf8 relate to a bytestring.
04:43:09 <Tuplanolla> There was a really good article about this, but I can't find it anymore.
04:43:16 <mniip> well Text is utf-16
04:43:19 <latk> What happens if I write a file as Text utf8, then read it as bytestring and print it in the terminal
04:43:23 <mniip> bytestring is a string of bytes
04:43:27 <latk> ok, utf16
04:43:43 <latk> I would have expected gibberish if I print a bytestring without any encoding info, but it looks fine
04:43:55 <latk> and I have no idea why
04:43:58 <mniip> because your terminal skips NUL characters probably
04:44:42 <saep> latk: Bytestring encodes ASCII without a difference. And ASCII is compatible with UTF-8. So if you only use the ASCII characters, you get the same bit-sequence.
04:45:02 <latk> saep: Ah, okay. That makes sense then.
04:45:41 <latk> How about, what is the difference between directly printing Text to a file, vs converting it to ByteString and printing that to a file ?
04:46:03 <latk> or should they be identical?
04:46:49 <mauke> depends on your definition of "directly"
04:46:52 <mauke> files store bytes
04:47:02 <mauke> everything has to be serialized somehow
04:47:27 <Tuplanolla> Here it is: http://blog.gatunka.com/2014/04/25/character-encodings-for-modern-programmers/
04:48:44 <Tuplanolla> Character encoding is a horrible mess.
04:50:13 <mauke> AΑÄÄΑ̈
04:51:01 <latk> Every time I think I understand what is going on, I end up getting confused by some new thing..
04:51:08 <latk> Will read the article, thanks Tuplanolla.
04:51:14 <Tuplanolla> The ride never ends.
04:51:24 <mauke> I don't understand what's so hard about it
04:52:05 <latk> mauke: Nothing, but I didn't appreciate that the terminal does some encoding for you. Which is kinda obvious now that I think about it.
04:52:24 <mauke> oh, you mean for input?
04:52:37 <latk> Actually output
04:52:44 <mauke> then no, it does decoding
04:52:53 <latk> Right, sure
04:53:17 <latk> could you not say it encodes the bytes into some language?
04:53:22 <mauke> no
04:53:36 <latk> so encoding is strictly language -> bytes ?
04:53:42 <mauke> encode :: Text -> Bytes
04:53:49 <mauke> not necessarily from a language
04:54:05 <latk> Right.
04:54:08 <mauke> ☃
04:54:41 <latk> Well in that case I didn't appreciate that the terminal decodes for you :p
04:55:04 <mauke> :-)
04:55:13 <mauke> ツ
04:58:22 <statusfailed> Are there any nice libraries for scheduling lots of IO tasks to happen at certain times?
04:59:02 <statusfailed> oh just found "jobqueue"
04:59:18 <statusfailed> seems broken though
04:59:28 <Haskellfant> async?
04:59:46 <Haskellfant> oh at certain times, I read at the same time
04:59:54 <statusfailed> Haskellfant: Yeah, want to keep scheduling new tasks too
05:13:37 <toad_> hey I've got a really really simple question about IO can someone help me with this? 
05:13:54 * hackagebot regex-applicative 0.3.2.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.2.1 (RomanCheplyaka)
05:14:02 <toad_> http://lpaste.net/7554964339724124160
05:14:30 <toad_> I want to be able to give the function a String and then it will output that String for me
05:14:38 <dramforever> toad_: remove thatreturn
05:14:41 <dramforever> *that return
05:14:50 <dramforever> what are you trying to do with it?
05:15:18 <toad_> Tried that but then the compiler says that my type for xs is a Char but it has to be a String
05:15:38 <mniip> toad_, what are you trying to do
05:16:02 <mniip> take a string and print it?
05:16:09 <dramforever> mniip: and return it
05:16:15 <dramforever> wait wtf
05:16:17 <toad_> I want to give the program a question. then it will output that string and the user will enter the answer
05:16:42 <toad_> then it will print the answer of the user
05:16:51 <mniip> toad_, do putStrLn frage; getLine
05:16:52 <dramforever> you have messed the code up...the correct one is: \
05:17:02 <dramforever> oh yes mniip just said it
05:17:32 <mniip> er
05:17:35 <mniip> that would be xs
05:17:38 <dramforever> s/frage/xs
05:17:41 <dramforever> exactly
05:17:53 <toad_> it works but why?
05:17:57 <toad_> what does that semicolon do?
05:18:08 <mniip> you can replace the semicolon with a newline
05:18:10 <dramforever> toad_: just put a newline there
05:18:12 <dramforever> ...
05:18:15 <mniip> (and sufficient tabulation)
05:18:22 <dramforever> mniip: you go ahead I'll do something else
05:18:55 <toad_> sorry new to haskell and still learning!
05:18:56 <mniip> woohoo I win
05:19:14 <mniip> toad_, xs is a pure value, you don't need to bind it
05:19:22 <dramforever> toad_: well haskell isn't quite the same as any other language
05:19:39 <dramforever> good for you that you are doing trail-and-error, though
05:19:52 <toad_> when would I have to bind it?
05:20:07 <toad_> when I type getline for example or what?
05:20:11 <mniip> you have to bind monadic values
05:20:14 <mniip> like 'getLine'
05:20:36 <mniip> because 'getLine' is an action, and you're looking for a String that is the result of the action
05:21:24 <toad_> aaah and with the arrows I'm taking only the pure value and put it in my new variable is that so
05:21:31 <toad_> and the action is dismissed?
05:21:58 <dramforever> toad_: no, the compiler is trying really hard to see xs as an action
05:22:12 <mniip> yeah
05:22:19 <mniip> xs has type String, which means [Char]
05:22:42 <mniip> which can be interpreted as a Char with a nondeterminism context
05:22:45 <toad_> yes I know that a String is a list of chars
05:23:08 <toad_> on another note because I'm still confused about that too
05:23:12 <mniip> > do a <- "hello"; return (ord a)
05:23:13 <lambdabot>  [104,101,108,108,111]
05:23:17 <toad_> what can i do with "return"?
05:23:36 <mniip> return turns a pure value into a monadic one
05:23:40 <mniip> by adding dummy context
05:24:02 <toad_> which is usefull in which context?
05:24:15 <mniip> when you're binding
05:24:45 <mniip> the last expression in a do-block has to be a monadic value
05:24:51 <mniip> otherwise <- binding doesn't make sense
05:25:22 <toad_> ok thank you!
05:25:56 <mniip> toad_, how familiar are you with higher order functions?
05:26:37 <toad_> I've read some things and know that for example types have to be paranthesed to the right
05:26:46 <toad_> but I would not say that I'm an expert
05:26:57 <mniip> well then I guess the >>= explanation will have to wait
05:27:28 <toad_> basically I've read the chapter from the learn your haskell for great good book
05:29:07 <maerwald> > return 3 :: [Int]
05:29:08 <lambdabot>  [3]
05:29:12 <maerwald> > return 3 :: Maybe Int
05:29:14 <lambdabot>  Just 3
05:29:58 <maerwald> > return 3 :: Either String Int
05:29:59 <lambdabot>  Right 3
05:32:27 <mniip> > return 3 ()
05:32:29 <lambdabot>  3
05:32:49 <maerwald> > return 3
05:32:51 <lambdabot>      No instance for (Show (m0 a0))
05:32:51 <lambdabot>        arising from a use of ‘show_M739834588816437303327637’
05:32:51 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
05:32:57 <maerwald> weird, works in ghci
05:33:17 <mniip> ghci has weird defaulting rules
05:33:24 <statusfailed> wait, "return 3 ()" what?
05:33:30 <statusfailed> what's going on there
05:33:55 <statusfailed> function instance?
05:34:10 <maerwald> :t return 3 ()
05:34:11 <lambdabot> Num a => a
05:34:12 <maerwald> :t return 3
05:34:13 <lambdabot> (Monad m, Num a) => m a
05:34:34 <statusfailed> > return 1 undefined
05:34:36 <lambdabot>  1
05:34:37 <mniip> statusfailed, precisely
05:34:37 <statusfailed> heheh
05:34:40 <statusfailed> sneaky
05:34:42 <Tuplanolla> > return 3 :: a -> Int
05:34:43 <lambdabot>      No instance for (Typeable a0)
05:34:44 <lambdabot>        arising from a use of ‘show_M119433069251128404627693’
05:34:44 <lambdabot>      In the expression:
05:34:57 <mniip> :t let x = return 3 in x () `const` x
05:34:58 <lambdabot>     Could not deduce (Monad m0) arising from a use of ‘x’
05:34:58 <lambdabot>     from the context (Num a)
05:34:58 <lambdabot>       bound by the inferred type of it :: Num a => a at Top level
05:35:25 <mniip> hmm wrong
05:35:46 <statusfailed> what's liftM2 in GHC 7.10 ?
05:35:52 <statusfailed> does it have a new prelude-exported name?
05:35:56 <mniip> :t let x = return 3 `const` x () in x
05:35:57 <lambdabot> Num b => () -> b
05:35:58 <mniip> there
05:35:59 <statusfailed> or should I still import Control.Monad
05:44:54 <maerwald> > return 3 . return 5 $ 7
05:44:56 <lambdabot>  3
05:44:57 <maerwald> lol
05:45:31 <dramforever> :t (return 3 . return 5) `asAppliedTo` ($ 7)
05:45:33 <lambdabot> (Num b, Num a) => ((a -> b1) -> b1) -> b
05:45:39 <dramforever> ?
05:46:00 <dramforever> oh :)
05:47:01 <maerwald> great obfuscation technique
05:48:27 <Tuplanolla> Is there a reason applications and libraries have to be different? It's starting to look like a silly distinction to me.
05:48:46 <Tuplanolla> Not just in terms of Haskell.
05:49:24 <appl12> tupla: because of web frameworks
05:51:03 <toad_> ok I'm again lost
05:51:14 <toad_> I have to rewrite (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c) 
05:51:18 <toad_> with the do notation
05:51:24 <toad_> which should be fairly simple
05:51:34 <toad_> but so far i only have this...
05:51:41 <toad_> http://lpaste.net/5725338838910369792
05:52:30 <maerwald> toad_: it might help if you think of the "last" a as an additional argument
05:52:36 <mauke> bad start
05:52:48 <maerwald> as in: (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:53:10 <maerwald> you have to feed that a into the second function, otherwise you don't get a b
05:53:39 <toad_> why do i want to get the b?
05:53:46 <mniip> so that you can get the c
05:53:53 <maerwald> "m c"
05:53:56 <mniip> because 'm c' is what you're asked for
05:54:00 <latk> How can I turn IO into MonadIO  ?
05:54:27 <mniip> latk, one is a type constructor and another is a typeclass, what do you mean
05:54:59 <toad_> ok and how do I feed that a into the second function?
05:55:05 <latk> I have a conduit that requires a MonadIO, and I am yielding a function that is in IO.
05:55:06 <maerwald> apply it? :o
05:55:20 <latk> mniip: ^
05:55:22 <mniip> latk, you mean MonadIO m => m a
05:55:28 <latk> mniip: yes
05:55:31 <mniip> liftIO
05:55:51 <toad_> what do you mean with apply it? 
05:56:02 <maerwald> toad_: call the function with that "a" as an argument?
05:56:10 <maerwald> just like regular function application
05:56:13 <latk> mniip: That did it. Thanks.
05:56:48 <toad_> so I just add at the end of my code f <=< a?
05:57:17 <toad_> no...
05:57:19 <maerwald> toad_: no, you want to call "g" with that additional argument that you have yet to add to your function
05:57:19 <mniip> toad_, what
05:57:31 <adas> if m = [[a1,a2], [b1, b2]] is there a function that gives me [[a1, b1], [a1, b2], [a2, b1], [a2, b2]] for any length of `m`?
05:57:47 <toad_> I realised that i've made a mistake before you wrote
05:57:49 <maerwald> toad_: so you have e.g. "(<=<) f g a" ... what does "g a" result into?
05:58:00 <mniip> > sequence [[a, b], [c, d]]
05:58:01 <lambdabot>  [[a,c],[a,d],[b,c],[b,d]]
05:58:38 <toad_> to b?
05:58:46 <maerwald> toad_: almost, "m b"
05:59:01 <toad_> oh god of course
05:59:11 <adas> mniip: much thanks. that might work. ill try it out on a repl
05:59:14 <maerwald> and in order to get the b, you can use the do-notation
06:00:29 <mniip> I wonder
06:00:52 <maerwald> toad_: mind that you don't really need a return in that do notation
06:01:10 <maerwald> the types already align for you 
06:02:08 <mniip> sequence is just foldr (liftM2 (:)) (return [])
06:02:10 <mniip> right
06:02:19 <mauke> @src sequence
06:02:19 <lambdabot> sequence []     = return []
06:02:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:02:19 <lambdabot> --OR
06:02:19 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:24:46 <adas> is there a combinations function .. ability to pick all combinations of n elements from a list of size m where m > n?
06:28:11 <breadmonster> adas: can you be a little more specific?
06:29:09 <mniip> sounds specific enough to me
06:29:39 <adas> breadmonster: so if m = [1,2,3] and n = 2 then i want [[1,2], [1,3], [2,3]].
06:30:11 <breadmonster> Sorry, I misread.
06:30:14 <Maxdamantus> Can you be more .. specific? Yes, I understand. My time .. is yours.
06:31:33 <breadmonster> adas: Oh right, nope, I don't recall anything like that in the standard library at least.
06:32:39 <lyxia> > let c 0 xs = [[]] ; c n xs = do { y : ys <- tails xs ; (y :) <$> c (n-1) ys } in c 2 [1,2,3,4]
06:32:40 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
06:39:47 <appl12> is haskell popular in japan
06:40:26 <tmtwd> take' :: (Num i, Ord i) => i -> [a] -> [a]   why does i need to be ordered in this function?
06:40:29 <rvxi> i doubt haskell is popular anywhere ...
06:41:32 <Haskellfant> tmtwd: where is this function from?
06:42:15 <tmtwd> learn you a haskell
06:42:28 <tmtwd> is it a typo?
06:42:59 <Haskellfant> well look at the code
06:43:06 <Haskellfant> it checks if the number is smaller than 0
06:43:22 <Haskellfant> that comparison requires Ord
06:43:47 <tmtwd> oh
06:43:50 <tmtwd> good point
06:44:13 <marchelzo_> tmtwd: I think Integral i would be a more sensible constraint
06:44:34 <Haskellfant> yep, using take' 3.5 [1,2,3] and having it return an empty list doesn't seem very useful
06:45:06 <appl12> :t a -> a
06:45:07 <lambdabot> parse error on input ‘->’
06:45:34 <Haskellfant> :t \a -> a
06:45:35 <lambdabot> r -> r
06:46:08 <mauke> :t let take' n _ | n <= 0 = []; take' _ [] = []; take' n (x : xs) = x : take' (n - 1) xs in take'
06:46:09 <lambdabot> (Num a, Ord a) => a -> [t] -> [t]
06:46:13 <tmtwd> I don't think it would return an empty list
06:46:23 <mauke> > let take' n _ | n <= 0 = []; take' _ [] = []; take' n (x : xs) = x : take' (n - 1) xs in take' 3.5 [1,2,3]
06:46:25 <lambdabot>  [1,2,3]
06:46:38 <Haskellfant> eh yeah stupid mistake
06:46:53 <Haskellfant> I still think it's a bad idea to accept that number
06:47:22 <mauke> > let take' n _ | n <= 0 = []; take' _ [] = []; take' n (x : xs) = x : take' (n - 1) xs in take' (0 / 0) [0 ..]
06:47:24 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:48:40 <toad_> Sorry I had to go but now I'm back
06:48:57 <toad_> I'm still on my old code but I know that i have to applay a to the function
06:49:34 <toad_> http://lpaste.net/5725338838910369792
06:49:50 <toad_> so how do i get the b out of g?
06:49:56 <toad_> by applying an arugment?
06:50:33 <lyxia> toad_: (f <=< g) should be a function, so it expects yet another argument.
06:50:42 <lyxia> (<=<) f g x = ...
06:50:57 <mauke> alternatively, f <=< g = \x -> ...
06:52:39 <adas> could there be any functions that can sort Text or can I use existing sort functions, although it is not obvious if there is an `Ordering Text` instance.
06:52:55 <geekosaur> did you mean Ord Text?
06:53:22 <toad_> ok so with the "<-" function I'll get the b out of the funciton a -> m b 
06:53:26 <geekosaur> instance Ord Text -- Defined in `Data.Text'
06:53:34 <adas> geekosaur: yes. Ord Text. sorry
06:53:39 <toad_> but how do I write that syntactilly correct
06:53:40 <toad_> ?
06:53:55 <mauke> toad_: no
06:53:59 <geekosaur> toad_, <- is not a function, it's a syntactic construct of `do` syntax
06:54:03 <toad_> now I have this: (<=<)f g x = do 	erstes <- f 	zweites <- g x 
06:54:06 <mauke> toad_: "<-" lets you get the b out of m b
06:54:16 <mauke> toad_: if you have X -> Y, it's a function
06:54:19 <toad_> ok
06:54:20 <toad_> yes
06:54:21 <mauke> and you need to give it an argument
06:54:21 <geekosaur> and the corresponding fucntion is
06:54:24 <geekosaur> :t (>>=)
06:54:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:54:31 <adas> geekosaur: all is see is `type Item Text = Char`. there is no instance for Ord Text
06:54:36 <toad_> I did
06:54:40 <adas> ill try it out none the less
06:54:58 <Haskellfant> adas: https://hackage.haskell.org/package/text-1.2.1.1/docs/Data-Text.html take a look here
06:55:04 <maerwald> toad_: you don't need a return
06:55:06 <Haskellfant> the instances of Text are listed
06:55:09 <geekosaur> adas, that does not sound like a standard Text (Data.Text)?
06:55:11 <toad_> I don't even have one
06:55:30 <maerwald> toad_: why do you want to execute the first function first?
06:55:47 <geekosaur> adas, perhaps you need to provide more information
06:55:51 <appl12> :t \r -> r
06:55:52 <lambdabot> r -> r
06:56:13 <toad_> aaah I see it makes no sense to have erstes <- f
06:56:22 <maerwald> maerwald: first get your "b" then use that "b" for the first function... and then you are already done
06:56:25 <toad_> because f doesn't even have b yet
06:56:28 <appl12> i cant go lower than a resource?
06:56:40 <appl12> ima curous about whats lower than a resource
06:56:42 <appl12> see
06:56:50 <appl12> :t \r -> r
06:56:51 <lambdabot> r -> r
06:56:56 <geekosaur> also `type Item Text = ...` sounds wrong
06:57:03 <mniip> appl12, what do you mean
06:57:20 <toad_> but how do I get that b?
06:57:33 <toad_> with <- g x?
06:57:40 <maerwald> toad_: yes
06:57:50 <maerwald> <- unwraps
06:58:01 <geekosaur> adas, unless that is a type instance in which case there are some different things going on
06:58:02 <appl12> Does type R have a type
06:58:12 <mniip> appl12, what?
06:58:16 <appl12> or does it stop at r
06:58:18 <toad_> ok good 
06:58:26 <Tuplanolla> R-Type...
06:58:31 <appl12> :t /r -> r
06:58:32 <lambdabot> parse error on input ‘/’
06:58:41 <appl12> :t \r -> r
06:58:42 <lambdabot> r -> r
06:58:42 <Haskellfant> appl12: a type has a kind
06:58:51 <toad_> and how can I output the last function then?
06:58:54 <maerwald> toad_: now you are just missing one line of code
06:58:54 <Haskellfant> :k Int
06:58:56 <lambdabot> *
06:58:56 <adas> geekosaur: I have text 1.2.11 installed. and the documentation installed has this - http://i.imgur.com/Cnqd2cj.png
06:58:57 <Haskellfant> :k Maybe
06:58:58 <lambdabot> * -> *
06:59:05 <maerwald> toad_: you just call "f" with the right argument it expects
06:59:05 <Haskellfant> :k \r -> r
06:59:06 <lambdabot> parse error on input ‘\’
06:59:11 <toad_> (<=<)f g x = do 	 	zweites <- g x  	erstes <- f zweites
06:59:13 <Haskellfant> that's not a type
06:59:17 <toad_> thats my code right now
06:59:18 <Haskellfant> it's just a function
06:59:20 <maerwald> toad_: why do you unwrap f?
06:59:32 <maerwald> toad_: check the type of "f zweites"
06:59:34 <toad_> ...because I'm dumb
06:59:35 <maerwald> what's the type?
06:59:49 <maerwald> the type of "f" is "(b -> m c)"
06:59:59 <maerwald> the type of "zweites" is "b"
07:00:06 <maerwald> the type of "f zweites" is?
07:00:06 <geekosaur> adas, that's an associated type instance and I don't think it's relevant for most uses
07:00:27 <adas> geekosaur: yes..but what I'm trying to say is that, no other instances seem to be defined for it
07:00:29 <toad_> alright thank you very much! :)
07:00:55 <maerwald> @let mybind f g a = do { b <- g a; f b }
07:00:56 <lambdabot>  .L.hs:145:1: Warning:
07:00:57 <lambdabot>      Pattern match(es) are overlapped
07:00:57 <lambdabot>      In an equation for ‘mybind’: mybind f g a = ...
07:01:00 <maerwald> oops
07:01:02 <maerwald> :t mybind
07:01:04 <lambdabot> Monad m => (t -> m b) -> (t1 -> m t) -> t1 -> m b
07:01:41 <maerwald> toad_: is that what you have?
07:01:52 <geekosaur> adas, I think you need to give a higher level overview of what you are trying to do
07:02:19 <toad_> yes this is what I have
07:02:51 <toad_> but I have this given:
07:02:52 <toad_> infixr 1 <=< _ <=< _ = undefined -- TODO
07:03:04 <toad_> oh what 
07:03:09 <toad_> infixr 1 <=< 
07:03:16 <toad_> _ <=< _ = undefined -- TODO
07:03:20 <toad_> given as a template
07:03:36 <toad_> I don't see an a here 
07:03:39 <geekosaur> Item is IIRC used for iteration when it's necessary for something to look at individual elements of a Text --- which is very slow and should be avoided. there are usually higher level ways to do it that can be fused so that they can operate on a Text without having to explode it
07:04:06 <adas> geekosaur: im trying to sort the characters in a Text type
07:04:10 <geekosaur> (and the associated type Item is part of the machinery that fuses what it can and explodes the Text when it can't)
07:04:45 <geekosaur> in any case, a `type` never has instances of its own --- it is an alias, the instances of the aliased thing are visible and usable
07:04:46 <mauke> toad_: <mauke> alternatively, f <=< g = \x -> ...
07:04:51 <geekosaur> and both Text and Char have Ord instances
07:05:03 <toad_> yes this is the way it is used in the module control.monad
07:05:10 <toad_> but I have to rewrite it in do notation
07:05:20 <adas> geekosaur: so im looking for something like `sortText :: Text -> Text`
07:05:21 <mauke> dude, what
07:05:35 <mauke> toad_: you're supposed to fill in the ... part (using do notation if you like)
07:05:51 <geekosaur> adas, had you simply tried sort?
07:05:53 <geekosaur> :t sort
07:05:54 <lambdabot> Ord a => [a] -> [a]
07:06:00 <geekosaur> Text has an Ord instance
07:06:09 <toad_> but I already have an answer
07:06:15 <maerwald> toad_: I think "(f <=< g) a = do { b <- g a; f b }" should also work
07:07:13 <maerwald> but defining it in terms of "this will return a function (a -> m c)" it might make more sense to do "f <=< g = \x -> ..." indeed
07:07:14 <likecolacola> hello
07:07:25 <adas> but i don't have a [Text]. only Text
07:07:26 <toad_> yeah but isn't that again in conflict with my template?
07:10:06 <geekosaur> bleh, right, still working on forst coffee
07:10:18 <ion> adas: Do you want to sort the characters? Or the codepoints?
07:11:10 <adas> ion: is there a difference?
07:11:52 <ion> adas: Characters can consist of multiple code points, such as ä (U+0061 U+0308).
07:11:54 <geekosaur> hm, no Text,sort, I don't think they intended this usage. I think you have to explode it manually or use http://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU.html#v:compare
07:11:59 <ion> > text (sort "äb")
07:12:01 <lambdabot>  ab̈
07:12:21 <mauke> adas: http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
07:12:29 <geekosaur> and yes, Unicode is getting into all sorts of "fun"
07:13:07 <mauke> join '', sort /\X/g  # how I'd do it
07:13:54 <geekosaur> adas, so, two kinds of problems you run into with the notion of "sorting a Text": "é" can be written in two ways in Unicode (one a single codepoint, one a combination of "e" and an accent modifier)
07:13:59 * hackagebot hscrtmpl 1.4 - Haskell shell script template  http://hackage.haskell.org/package/hscrtmpl-1.4 (DinoMorelli)
07:14:35 <geekosaur> the other is that sorting by codepoints would put "n" and normalized "ñ" away from each other, but standard SPanish collation wants them next to each other
07:15:08 <mauke> ah, that one can't be fixed in general
07:15:18 <mauke> different languages have different collation rules
07:15:40 <adas> geekosaur: now i get why there might not be a `sort` function in Data.Text
07:15:48 <geekosaur> exactly :)
07:16:01 <geekosaur> but see "vollate" that I pointed to earlier, from the text-icu package
07:16:22 <geekosaur> you need to give it a localization to collate for (to solve the n vs. ñ issue)
07:16:31 <geekosaur> *collate
07:16:43 <mauke> čompromise
07:16:44 <geekosaur> er compare, sorry
07:16:50 <geekosaur> http://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU.html#v:compare
07:17:15 <geekosaur> and welcome to the annoying, frustrating world of Unicode :)
07:17:35 <mauke> s/Unicode/human languages/ :-(
07:17:38 <monochrom> isn't it exciting!
07:17:44 <ion> s/ language//
07:17:47 <geekosaur> indeed (to both)
07:18:31 <toad_> ok nevermind I was an idiot
07:18:34 <mauke> I wonder if there's a collation rule for where chinese characters with umlauts go
07:18:43 <toad_> But how could I test it now?
07:18:51 <toad_> I know its correct but I'm curious
07:20:33 <maerwald> toad_: rename the function and check if it does the same as (<=<) defined in Control.Monad
07:20:53 <maerwald> property testing seems to hard to recommend right now
07:21:08 <toad_> yes but what would be my arguments?
07:22:07 <maerwald> > (\x -> Just (1 + x)) <=< (\y -> Just (y + 2)) $ 5
07:22:09 <lambdabot>  Just 8
07:22:10 <maerwald> something like that?
07:22:33 <joe9> need some advice, please? I want to convert a list of integer indices [0,2,4,5] to ['-','','-','','-','-']. all indices in the original array to have '-', else just an empty character. The list of characters is always 10.
07:22:44 <maerwald> (\_ -> Nothing) <=< (\y -> Just (y + 2)) $ 5
07:22:50 <maerwald> > (\_ -> Nothing) <=< (\y -> Just (y + 2)) $ 5
07:22:52 <lambdabot>  Nothing
07:22:57 <maerwald> simple stuff like that
07:24:03 <tmtwd> how could I double every other  element in a list?
07:24:27 <mauke> joe9: there are no empty characters
07:24:57 <mauke> tmtwd: zipWith (*) (cycle [2, 1])
07:25:36 <adas> thanks for the clarifications
07:27:34 <tmtwd> mauke, thanks
07:28:07 <toad_> ok maerwald I've tried writing it with \x -> now but I'm unsure about the >>= operator
07:28:34 <toad_> what does it exactly do?
07:29:09 <maerwald> toad_: wait, what?
07:29:29 <maerwald> someone told you to implement (<=<) in do-notation without knowing about  (>>=)?
07:31:32 <toad_> ...jup
07:31:52 <maerwald> that sounds like a terribly wrong introduction into monads
07:32:01 <toad_> last time I just had to print words on the screen
07:32:12 <toad_> and now this and I'm a bit confused 
07:33:12 <maerwald> toad_: do you know about Functors and fmap?
07:33:14 <monochrom> I'm sure there is simply a lot of misunderstanding
07:33:35 <toad_> fmap maps a function over a list and the gives out a new list
07:33:48 <toad_> and a functor is for example maybe or Tree
07:33:53 <toad_> is that right?
07:34:15 <maerwald> toad_: the first sentence not really... you defined "map" there, not fmap
07:34:33 <maerwald> :t map
07:34:34 <lambdabot> (a -> b) -> [a] -> [b]
07:34:35 <maerwald> :t fmap
07:34:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:35:17 <maerwald> > fmap (+1) (Just 3)
07:35:18 <lambdabot>  Just 4
07:35:27 <maerwald> > fmap (+1) [1, 2, 3, 4]
07:35:28 <lambdabot>  [2,3,4,5]
07:35:41 <maerwald> fmap works on any data type that has a functor instance
07:35:42 <toad_> so if i aply fmap to a functor with a function it produces something new
07:36:48 <maerwald> toad_: I suggest you read the Monad stuff (and functor, monoid and applicative functor beforehand) from the lyah book
07:36:50 <sgillis> I have a sum type that defines some possible methods. I want to write a function where the method is an input, and the output type is dependent on the value of the method.
07:36:59 <sgillis> What would be a good way to do this?
07:37:01 <maerwald> otherwise it's hard to understand how you get to the (>>=) function
07:38:40 <toad_> alright I'll look into it
07:39:18 <maerwald> :t fmap
07:39:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:39:25 <maerwald> :t (<*>)
07:39:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:39:30 <maerwald> :t (=<<)
07:39:31 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:39:37 <maerwald> these all look very  similar
07:39:47 <maerwald> and because of that it's best to understand them all
07:39:54 <maerwald> starting with functor
07:39:57 <toad_> ok
07:40:04 <toad_> I'm reading right now
07:40:16 <toad_> thank you for being so patient!
07:43:58 <appl12> toad you should try to build a website out of haskell
07:45:56 <mniip> website eh
07:46:01 <rvxi> why a website?
07:46:34 <maerwald> to make lots of money
07:47:16 <rvxi> probably better to learn some basics first
07:47:27 <rvxi> otherwise it'll be hard to wrestle with compiler errors
07:48:31 <mniip> but making websites is the "cool" thing nowadays
07:53:35 <dfeuer> Ping edwardk 
07:54:06 <tmtwd> how can I fix the syntax of this function? validate xs = if sumDigits . doubleEveryOther  . toDigitsRev x `mod` = 0 then True else False
07:54:32 <mauke> 'if X then True else False' better written as 'X'
07:54:37 <tmtwd> rather, `mod` 10 = 0
07:54:42 <mauke> x is undeclared
07:54:45 <mauke> xs is unused
07:54:53 <mauke> == is the equality operator, not =
07:54:53 <mniip> = is a syntax element
07:55:14 <mauke> parens needed
07:57:58 <dfeuer> I'm trying to understand why scan in Data.Machine.Process forces evaluation of the argument to the recursive call.
07:58:05 <ion> That’s a fun error message.
07:58:15 <dfeuer> I understand why that's done for fold and fold1, but not for scan.
07:58:18 <dfeuer> Can someone explain?
07:59:00 * hackagebot ghc-core-html 0.1.4 - Core to HTML display  http://hackage.haskell.org/package/ghc-core-html-0.1.4 (VincentHanquez)
07:59:10 <dfeuer> In particular, that's actually yielded on the next step, so the next machine can force it... I guess maybe it's too easy to forget to do that if it's not used?
08:09:03 <toad_> ok so I've been reading a bit but still don't get why this is not another way to write it:
08:09:04 <toad_> (komp2):: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c) f komp2 g  = (g x) >>= \z -> f z
08:11:05 <maerwald> toad_: where does that "x" come from?
08:11:49 <dfeuer> Why is f eta-expanded?   >>= \z -> f z   is the same as   >>= f
08:12:10 <dfeuer> And it's often easier to read that as     f =<< ....
08:13:34 <toad_> f komp2 g  = \x -> g x >>= \z -> f z
08:13:41 <maerwald> looks ok
08:13:46 <toad_> but doesn't compile
08:14:05 <maerwald> did you declare it infix?
08:14:15 <dfeuer> ?
08:14:23 <dfeuer> You probably mean    
08:14:28 <dfeuer> f `komp2` g = ...
08:14:32 <maerwald> right
08:14:38 <dfeuer> You can't declare things infix.
08:15:16 <dfeuer> Well, you can give a fixity declaration, but that doesn't change whether it's prefix or infix. It needs to already be inherently infix.
08:15:50 <dfeuer> infixl 5 `foo`, infixr 2 `bar`, infix 7 `baz`, infix 4 <==
08:15:53 <dfeuer> Yadda yadd.
08:16:03 <Tuplanolla> I have a related question. Why can't you infix arbitrary expressions? Like this: x `if p then f else g` y
08:16:40 <dfeuer> Tuplanolla, because that would be too cool and/or too confusing when you make a mistake.
08:16:56 <dfeuer> I'm going with too cool for now.
08:17:19 <Tuplanolla> When I first learned the language it was surprise `(+)` didn't work like +.
08:18:48 <maerwald> @let komp2 f g  = \x -> g x >>= \z -> f z
08:18:49 <lambdabot>  Defined.
08:18:52 <maerwald> :t komp2
08:18:53 <lambdabot> Monad m => (a -> m b) -> (t -> m a) -> t -> m b
08:18:59 <maerwald> toad_: looks ok
08:20:10 <toad_> but it says to me invalid type signature
08:21:08 <maerwald> toad_: type signature sahould be "komp2 :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)"
08:22:11 <toad_> 	 (komp2) :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c) f komp2 g  = \x -> g x >>= \z -> f z
08:22:15 <toad_> this is what I have
08:22:20 <dfeuer> The last parentheses there aren't needed, maerwald.
08:22:22 <toad_> it should not be different should it?
08:22:26 <maerwald> dfeuer: I know.
08:22:28 <dfeuer> But they might help understanding.
08:22:44 <dfeuer> toad_, get rid of the parens around komp2.
08:22:51 <dfeuer> Those don't belong.
08:23:00 <toad_> but I want to use it as an infix function
08:23:06 <dfeuer> Doesn't matter.
08:23:09 <maerwald> toad_: then do `komp2`
08:23:20 <maerwald> when you use it
08:23:21 <dfeuer> Things made of letters are "inherently prefix"
08:23:29 <dfeuer> Things made of symbols are "inherently infix".
08:23:37 <toad_> but I did it like that in my other function with the do outline and it worked
08:23:45 <dfeuer> You can use the ones of symbols as infix using parens.
08:23:53 <dfeuer> er...
08:24:00 <dfeuer> You can use the ones of symbols as *prefix* using parens,
08:24:08 <dfeuer> and the ones of letters as infix using ``.
08:24:19 <dfeuer> But there's no way to specify that at the declaration site.
08:24:22 <dfeuer> It's at the use site.
08:24:33 <toad_> I really didn't understand what you just said
08:24:37 <dfeuer> OK.
08:24:38 <toad_> could you parathrase it?
08:24:39 <dfeuer> So
08:24:49 <dfeuer> A type signature is written
08:24:50 <maerwald> toad_: if you want infix, it has to be a symbolic name
08:24:52 <dfeuer> name :: ...
08:24:56 <dfeuer> or is written
08:25:06 <dfeuer> (<>+) :: ...
08:25:13 <maerwald> toad_: if you write alphanumeric name, it is a prefix function and you can use it infix by doing `komp2`
08:25:22 <dfeuer> If it's a name, it must not be in parens ther.
08:25:24 <maerwald> but it still has to be declared as a prefix function
08:25:29 <dfeuer> If it's a symbol, it must be in parens there.
08:25:54 <dfeuer> maerwald, you can also use backticks on the LHS; just not before the :: ....
08:26:05 <maerwald> I know
08:26:05 <dfeuer> x `f` y = ....    is fine
08:26:07 <dfeuer> OK.
08:26:13 <dfeuer> Just clarifying for toad_.
08:26:21 <maerwald> I think you are confusing him with your walls of text though
08:26:26 <dfeuer> Could be.
08:26:52 <toad_> I think I've got it i can only use the paranthese with symbols am I right?
08:27:02 <dfeuer> toad_, remember this: the way you declare something has no effect on whether it will ultimately be used infix or prefix.
08:27:14 <toad_> ok that makes sense
08:27:35 <monochrom> "(name) :: type" is a syntax error.
08:27:48 <toad_> but now it should work shouldn't it?
08:27:49 <toad_> komp2 :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c) f `komp2` g  = \x -> g x >>= \z -> f z
08:27:57 <maerwald> yes
08:28:44 <toad_> but it doesn't..
08:28:57 <monochrom> then something else breaks
08:29:24 <maerwald> toad_: wait, you have an error in your type sig
08:29:33 <maerwald> toad_: you swapped f and g in the type signature
08:29:54 <maerwald> komp2 :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c) f `komp2` g  = \x -> g x >>= \z -> f z
08:29:58 <toad_> aaaah yess
08:30:03 <toad_> oh god I'm so stupid
08:30:06 <monochrom> the cause of a problem is never the cause you choose
08:31:10 <maerwald> it would have "compiled" in ruby though :P
08:31:48 <toad_> thank you very much guys!
08:35:58 <toad_> ah and btw where do i have to define the priority of the function with infixr?
08:36:07 <toad_> right aber the type signature or at the end?
08:36:12 <toad_> or somewhere complety else
08:36:55 <mauke> infixr 6 +, *, <  -- IIRC
08:37:05 <mauke> that is: first a number, then a comma-separated list of operators
08:37:21 <mauke> oh, you mean that
08:37:32 <mauke> I think you can put it anywhere you want
08:39:26 <toad_> :D yeah I knew how to use it but I was wondering where to put it
08:41:07 <monochrom> put in on line 1039
08:41:52 <mauke> I usually put it before the type signature
08:45:14 <joe9> is there a haskell library function to do :  5 < x <= 10
08:45:30 <athan> joe9: As a syntax? I could probably make something
08:45:32 <monochrom> no
08:45:41 <joe9> ok, thanks.
08:45:53 <athan> with `.<` and `.>=` etc
08:46:02 <mauke> inRange (6, 10) x
08:46:11 <joe9> mauke, thanks.
08:46:31 <hpc> :t inRange
08:46:32 <lambdabot> Ix a => (a, a) -> a -> Bool
08:46:37 <athan> What would be a good data type for a map with contents that expire?
08:46:58 <athan> I have a hashmap for my cache right now
08:47:31 <geekosaur> priority search queue with the timeout as the priority?
08:47:34 <athan> I'm just wondering if I should periodically delete contents, or check their respective date upon lookup
08:47:35 <Cale> Using Ix for that is a bit hacky, given that the implied ordering due to Ix needn't correspond in any way with the ordering from Ord
08:47:45 <athan> geekosaur: Oooh!! okay!!
08:47:49 <athan> thank you!
08:47:51 <Cale> (but it will work if you stick to integers)
08:47:51 <hpc> athan: how many elements in the map, how rapidly do they expire?
08:48:03 <monochrom> I do what geekosaur says. plus a background thread to wake up every minute to expire.
08:49:02 <athan> hpc: potentially tens of thousands, maybe hundreds at the same time, and they /could/ expire in as fast as 5 seconds (for stronger security), or could last a few hours
08:49:11 <monochrom> therefore my scheme is full of IO and atomicModifyIORef
08:49:16 <athan> This is for a web server's session cache
08:49:30 <athan> Ahh :) thank you monochrom
08:49:32 <hpc> athan: perhaps ixset?
08:49:45 <athan> hmm
08:50:26 <hpc> bonus: IxSet plays nicely with acid-state
08:50:34 <monochrom> you can also postpone expiration until you actually use the data structure
08:50:55 <joe9> hpc, thanks.
08:51:35 <athan> monochrom: That's what I initially thought
08:52:14 <athan> hpc: Hmm!! Okay!
08:53:00 <hpc> this is reminding me that i need to do something with IxSet
08:53:55 <hpc> just to say i have
08:55:36 <phylene> I have a question. When you pass a polymorphic function like 'show' to a funnction that applies it to two Elements and combines them somehow, why does 'show' require the two elements to be the same type?
08:55:53 <haskell457> Hello, when trying to build a Hakyll static site, the function `hGetContents` complains "invalid byte sequence" when trying to parse the character 'λ'. What can be done to fix this? 
08:56:02 <phylene> something like 'foo f (x, y) = (f x, f y)'
08:56:36 <leino> anyone interacting with GHCi trough emacs 24.4 successfully? (I just installed haskell-mode after a long Haskell hiatus, and now I can't tab-complete anymore)
08:56:53 * mniip tries to figure out a way to explain implicit foralls
08:57:31 <hackteck> Juni Jonn Joans don't just people are. Nothing but football the Rams, see thing. you keep in the New Orlean out immigrant population is a vegetable sprayers ram against each other, the butthole. your left hand, pour it, damn. You'd better the bubbles form more rapidly...would go brucest boyer football player. not believe in most doot doo doo doo doot doo.
08:57:33 <hackteck> you take with you keep you known on television. yeah! Freeze you programs to the Lost of brucesht boyer coyer! Boyer registressed by recent remarks about thing paint dry. Lynx game! The world cares at your friends alive-eh, friends alive a soccer game in L.A. Circle college football player. The Rams thing? it in L.A. The one of brucesh
08:57:45 --- mode: ChanServ set +o shachaf
08:57:50 --- mode: shachaf set +b *!*hackteck@84.232.57.*
08:57:50 --- kick: hackteck was kicked by shachaf (hackteck)
08:57:53 --- mode: shachaf set -o shachaf
08:58:26 <haskell457> @leino You can find the instructions in the following site https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
08:58:26 <lambdabot> Unknown command, try @list
08:58:44 <mniip> phylene, how would you annotate the type of the function that does otherwise
09:01:45 <mniip> hint: you can't
09:02:05 <leino> haskell457: thanks, I'll check... but I think if tab-complete doesn't work the instructions won't help me. (I should mention that I get an error message: "Wrong type argument: stringp, nil"
09:02:08 <monochrom> implicit forall is best explained by explicit forall
09:03:07 <mniip> well yeah
09:03:15 <hvr> leino: maybe try #haskell-emacs
09:03:37 <monochrom> @type \f (x,y) -> (f x, f y)
09:03:39 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
09:03:59 <mniip> 'foo :: (a -> String) -> (b, c) -> (String, String)' actually means 'forall a b c. (a -> String) -> (b, c) -> (String, String)'
09:04:14 <mniip> which means we can substitute any type for a, b, c and it would remain valid
09:04:18 <dfeuer> Why did edwardk decide that Stop for machines should not be capable of carrying a payload?
09:04:23 <leino> hvr: thanks, I'll try it out
09:04:48 <monochrom> mniip: be careful of "we". who? user? implementer? user vs implementer is more important than "can"
09:05:13 <mniip> yeah, user of the function can substitute
09:05:26 <monochrom> in other words "any" is unimportant. the important part is "but who has the arbitrartion right?"
09:05:44 <mniip> that is however not the desired behavior, because if a is substituted with (), we get 'forall b c. (() -> String) -> (b, c) -> (String, String)' which is pretty useless
09:05:55 <monochrom> since the user chooses, therefore, the implementer cannot choose.
09:06:33 <monochrom> therefore, a does not have anything to do with b,c because the implementer cannot choose a=b, a=c.
09:06:35 <mniip> instead you should move the forall into the function, so that the implementation of foo gets to decide what 'a' is, and user of the function has to pass something that works for all 'a'
09:06:58 <mniip> forall b c. (forall a. a -> String) -> (b, c) -> (String, String)
09:09:03 <mniip> now, we can remove the outer forall, but the inner forall doesn't fit into implicit foralls, so we have to enable the RankNTypes extension
09:09:34 <mniip> and to make the type signature totally correct, we should add the typeclass we're after
09:09:47 <mniip> (Show b, Show c) => (forall a. Show a => a -> String) -> (b, c) -> (String, String)
09:10:15 <monochrom> I'm wondering if that's necessary
09:10:39 <mniip> it is not immediately obvious how forall syntax combines with constraints
09:12:10 <dfeuer> mniip, what's non-obvious about that?
09:12:31 <dfeuer> What's never obvious to me is non-GADT existential syntax. Ugh.
09:12:58 <monochrom> I see. if you leave b,c type variables, you need Show
09:12:58 <mniip> dfeuer, the fact that Show a => goes after forall and not in beginning of the signature
09:13:21 <dfeuer> mniip, the  a   does not exist at the beginning of the signature.
09:13:32 <mniip> hence the non-obviousness
09:13:52 <monochrom> oh wait, show is not "forall a. a -> String"
09:15:34 <monochrom> dfeuer: I use rote memorization
09:15:48 <dfeuer> It's just saying that argument is a function that must take an arbitrary  a   and produce a String, and that is allowed to assume  Show a.
09:16:38 <athan> monochrom, geekosaur: Would you use an IntPSQ? I'm just wondering if the Int should be a unique id for each logged-in user. Any thoughts?
09:16:44 <monochrom> I use a lot of rote memorization
09:17:01 <edwardk> dfeuer: because it isn't interesting to me to try to make something with 50 parameters nobody can remember like pipes/conduit, so machines is basically about trying to find something simple that is capable of doing all the things. it also gets us instances, like MonadPlus for plan that go away if there is a payload.
09:18:21 <geekosaur> athan, I don't know enough about what you're doing to be able to answer that, you're the one who knows if a unique integer id is sufficient
09:18:25 <monochrom> athan: that sounds like depending on a million factors not said
09:19:00 <geekosaur> (that said, as an ex-database geek I'd tend in that direction for the same reason that I would use a unique ID as the primary key of a table and map it to something human understandable in another table)
09:19:10 <monochrom> and the beauty is that by the time you have said the 10th factor I would be a paid consultant
09:19:55 <geekosaur> (namely, because otherwise you're screwed when someone e.g. changes their name....)
09:20:01 <athan> monochrom, geekosaur: :x sorry guys. Thank you!!
09:20:26 <geekosaur> (but note that many auth systems *already* suffer from that problem, so there's no real point in trying to abstract around it for them)
09:20:47 <athan> Wait! OrdPSQ could just use Integer, that way all ids are unique
09:20:52 <athan> maybe that might be a better model
09:21:11 <dfeuer> edwardk, so you prefer to have multiple notions of machine, MachineT, Moore, Mealy, (...?), rather than making one overly general thing?
09:21:35 <edwardk> Mealy and Moore are often more expressive and have more instances, they are a sort of building block to build a machine.
09:21:47 <edwardk> you just don't get all their instances on a Machine
09:21:58 <statusfailed> edwardk: Machine is the more general concept, right?
09:22:01 <dfeuer> No.
09:22:19 <edwardk> statusfailed: machine can do more than either Mealy/Moore
09:22:25 <edwardk> but because of that it loses instances they offer
09:22:33 <statusfailed> right
09:22:38 <dfeuer> And loses guarantees.
09:22:54 <dfeuer> There's no way to talk about a MachineT that must yield before it awaits.
09:23:05 <edwardk> eventually i want to figure out a nice, compositional model of 'input languages' for machines
09:23:33 <dfeuer> There's also no way to talk about a machine that must eventually yield.
09:23:43 <edwardk> e.g. a wye where the left side can push back or must commit, etc.
09:24:11 <edwardk> if we had indexed monads then i could talk about this via a state machine like singularity
09:24:21 <dfeuer> edwardk, you've now gone well past my limited understanding of these machenes.
09:24:22 <dfeuer> machines.
09:24:29 <dfeuer> Push back? Commit?
09:24:52 <edwardk> think about 'how to deal with leftovers'
09:25:10 <edwardk> https://www.fpcomplete.com/user/edwardk/heap-of-successes talks about a way that doesn't compromise variance
09:25:27 <edwardk> (in the context of taking from a known string, parser style)
09:25:30 <statusfailed> edwardk: Can you explain what's meant by leftovers? I do simple stuff with machines, so I haven't run into exactly what the problem is
09:25:33 <dfeuer> How do leftovers related to machines? I don't yet see any sorts of parsing thingies.
09:25:42 <edwardk> statusfailed: that is the point =)
09:25:57 <statusfailed> haha :-)
09:26:06 <edwardk> statusfailed: pipes (and to a much lesser extent conduit) are complicated by trying to deal with it by ad hoc means
09:26:27 <edwardk> dfeuer: there is a 'Stack' input language IIRC in there that can be used to write machines that push back some input
09:26:55 <edwardk> a better way would be to use something like the monoid action stuff in that heap-of-successes article
09:27:00 <mniip> meele and moore machines seem like fancy reorderings of the RWST monad
09:27:09 <mniip> RWS monad*
09:27:12 <edwardk> mniip: there is a deep reason for this
09:27:59 <dfeuer> What is "contravariance" in this context?
09:28:03 <mniip> lol
09:28:04 <mniip> mealy*
09:28:33 <edwardk> Mealy a b = Mealy (a -> (b, Moore a b)) = Mu (Compose ((->) a) ((,) b))) -- is a fixed point of something much like state
09:30:12 <athan> I think I need a priority queue where you can alter the key, but it's still ordered by the priority
09:30:16 <athan> :s
09:30:26 <edwardk> OTOH Moore a b = Moore b (a -> Moore a b) = Mu (Compose ((,) b) ((->) a)) so when we expand Mu as Nu instead we get data Moore a b = Moore :: (x -> b) -> (x -> a -> x) -> x -> Moore a b -- when we group up the first and third arguments we get a Store comonad with an extra 'environment' (x -> a -> x)  -- and then we existentially hide 'x' by taking a coend.
09:30:47 <edwardk> now i want a melee machine
09:31:21 <dfeuer> edwardk, did you make scan strict to prevent mistakes? Or was there some deeper reason?
09:31:23 <edwardk> anyways, there are connections from Moore to both the store comonad and cofree comonad, it acts like both
09:31:28 <mniip> edwardk, looking at the wikipedia page I only see (s, e) -> (s, r)
09:31:54 <mniip> which is e -> s -> (s, ((), r))
09:31:56 <mniip> aka RWS ()
09:32:07 <dfeuer> Y'all are going way off into confusing land.
09:32:16 <mniip> er
09:32:21 <edwardk> mniip: uncurry and flip, now you get e -> s -> (r, s)   -- which is a state transition action... for some state 's' you don't get to know.
09:32:34 <mniip> RWS e r s ()
09:32:57 <mniip> right
09:33:09 <mniip> but r is an output
09:33:15 <cwraith> athan: I don't think any psqueue implementation is going to offer you a way to do that better than just removing from one key and adding with the new one.
09:33:16 <mniip> writer-style
09:33:47 <edwardk> so we can view this as a comonad coalgebra for the functor for 'indexed state' or as a Kleisli arrow in state.
09:33:47 <edwardk> mniip: with no monoid, etc.
09:33:47 <cwraith> athan: Because things need to be searchable by key, when you change the key it can't stay in the same place anyway
09:33:49 <mniip> hmm
09:34:52 <athan> c_wraith: That makes a lot of sense. Thank you
09:34:57 * mniip recursively reads about each word
09:35:13 <edwardk> the state transition function for a mealy machine (s, a) -> (s, b)  -- can be viewed as a -> State s b -- a kleisli arrow in State.  or a coalgebra for the functor (s -> IState a b s)  for the IState a b = a -> (b, s) functor that underlies the 2-parameter indexed state monad
09:35:23 <edwardk> er
09:35:30 <edwardk> rather
09:35:46 <edwardk> 'or a coalgebra (s -> IState a b s) for the IState a b = a -> (b, s) functor'
09:36:11 <edwardk> this gives you two ways to look at these transitions. one way they work like kleisli arrows. the other way they work like coalgebras
09:36:51 <edwardk> now there is a terminal coalgebra, which has a unique morphism from any other coalgebra ana :: Functor f => (a -> f a) -> a -> Nu f
09:37:13 <edwardk> so since we can view this as a coalgebra, we can look at what 'ana' will do to it.
09:37:33 <edwardk> this yields a form of Mealy machine with explicit state.
09:37:46 <edwardk> or the usual definition
09:37:51 <c_wraith> Did GHC 7.10 change PatternSynonyms?  I think I remember there being some changes to it.
09:37:57 <edwardk> if you just use the 'Fix' approach.
09:40:58 <mniip> does not compute
09:42:02 <joco42> cabal sandbox question: if i install reflex into a sandbox in directory a and then i create a cabal package in directory b that uses reflex, then i create a sandbox in directory b, now the question: how can i install the package in directory b in such a way that it uses reflex installed into the sandbox located in directory a ?
09:42:41 <dfeuer> edwardk has left the programming world and ascended to the realm of abstract nonsense, from which it may be difficult to retrieve him.
09:43:51 <mniip> edwardk, so
09:44:02 <mniip> what's a coagebra and how is it different from a comonad
09:44:05 * hackagebot postgresql-typed 0.4.0 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/postgresql-typed-0.4.0 (DylanSimon)
09:44:29 <edwardk> do you know what 'folds' and 'unfolds' or 'catamorphisms' and 'anamorphisms' are?
09:45:00 <dfeuer> I have some sense of such, but only from a programming standpoint; not a categorical one.
09:45:23 <mniip> folds like projection functions?
09:45:52 <dfeuer> I think he's talking about "replace each constructor with a function".
09:46:03 <edwardk> ok, so here's the idea, let's look at algebras real quick.
09:46:08 <mniip> which is what projections are about
09:46:10 <mniip> no?
09:46:12 <edwardk> an f-algebra is a function (f a -> a)
09:46:13 <dfeuer> Don't ask me.
09:46:19 <edwardk> any such function
09:46:23 <mniip> okay
09:46:24 <dfeuer> OK.
09:46:46 <edwardk> they arise when we start talking about fixed points at the type level
09:46:54 <edwardk> these are useful for 'tearing down a structure'
09:47:06 <c_wraith> isn't that kind of close to a catamorphism?
09:47:08 <dfeuer> How do they start relating to fixed points?
09:47:09 <edwardk> cata- means downward or destruction as in catastrophe
09:47:33 <edwardk> c_wraith: cata uses an f-algebra, but i want to introduce an f-algebra homomorphism first
09:47:52 <edwardk> well, given any two f-algebras we can talk about an 'f-algebra homomorphism between them'
09:47:59 <edwardk> so lets talk about that
09:48:14 <mniip> what would that homomorhism imply/entail
09:48:36 <edwardk> an f-algebra is a function (f a -> a)     -- so we'll think of it logically as the pair of the type a, and a function (phi :: f a -> a)
09:48:45 <dfeuer> mniip, probably some commutative diagram? Probably not too complicated?
09:50:02 <dfeuer> Given   f a -> a   and  f b -> b, an f-algebra homomorphism must be a function  (f a -> a) -> (f b -> b)  where ..... there must be some structure on a and b... Maybe they're semigroups?
09:50:18 <edwardk> a homomorphism between two f algebras (A, phi) and (B, psi) -- keep in mind here a is just the type, not the value     is a function f :: A -> B   such that psi . fmap f = f . phi
09:50:39 <dfeuer> Oh wait...
09:50:56 <mniip> "-- keep in mind here a is just the type"
09:50:58 <edwardk> the homomorphism is just a simple function f :: A -> B
09:51:00 <mniip> what's that comment for
09:51:01 <dfeuer> Huh.
09:51:06 <edwardk> er keep in mind here A is just a type
09:51:13 <edwardk> i changed notation half-way through that line =)
09:51:40 <mniip> ok so
09:52:04 <edwardk> normally we talk about the category of f-algebras with our objects as pairs (A,phi)   where A is a type and (phi :: f A -> A) a function
09:52:15 <edwardk> and our arrows are f-algebra homomorphisms
09:52:32 <edwardk> they are just functions A -> B  that 'respect' the f-algebras
09:53:05 <dfeuer> OK, I think I understand that, formally if not intuitively.
09:53:23 <mniip> so algebras are first polymorphic over the f, and then over a?
09:53:39 <mniip> if that makes any sense
09:53:42 <edwardk> yes, though we typically think just of 'f-algebras' fixing f.
09:53:43 <dfeuer> I don't think they're polymorphic over f?
09:53:47 <mniip> yeah
09:53:58 <edwardk> ok, so now given that we have a category we can look around for an initial or terminal object. here we find an initial object.
09:54:07 <mniip> it's not common to head 'm-monad' though
09:54:23 <edwardk> which is to say there is an f-algebra for which there is a unique f-algebra homomorphism to _every_ other f-algebra
09:54:44 <edwardk> mniip: the 'f' here matters a fair bit, and it helps distinguish between the other notions of algebra
09:54:51 <edwardk> as algebra is one of the most overloaded words in all of mathematics
09:55:17 <edwardk> so what would such an initial f-algebra have to look like?
09:55:47 * mniip reinterprets everything said so fatr
09:55:58 <dfeuer> I think it has to be over Void?
09:56:05 <dfeuer> Or something?
09:57:08 <edwardk> we can build a type Mu f    -- with In :: f (Mu f) -> Mu f        such that given any other f-algebra (A, phi :: f A -> A)        there'd be a uniquely determined function from Mu f -> A  that respects the structure we want
09:57:25 <edwardk> newtype Mu f = In (f (Mu f))
09:57:47 <edwardk> now we just need to write a function:: cata :: Functor f => (f a -> a) -> Mu f -> a
09:58:14 <Tuplanolla> If I learn one new word each time this comes up, I'll soon understand what's being discussed.
09:58:17 <edwardk> which is to say you tell me the f-algebra (A, phi) you want to 'go to' and i'll give you an f-algebra homomorphism from Mu f to A
09:59:17 <dfeuer> edwardk, so it's initial for things targeting   a?
09:59:20 <dfeuer> Or something?
09:59:33 <edwardk> and it being an f algebra homomorphism we know the one law that matters from the definition of an f-algebra homomorphism
09:59:53 <edwardk> phi . fmap (cata phi) = cata phi . In
09:59:58 <edwardk> so we can re-arrange that into a definition
10:00:13 <fr33domlover> hello. how do I select() in haskell? e.g. listening to multiple network connections. Is there a way other than hGetLine-ing in separate threads? (I suppose there is :P)
10:00:17 <edwardk> newtype Mu f = In { out :: f (Mu f)) }
10:00:22 <dfeuer> fr33domlover, you use threads.
10:00:23 <mniip> edwardk, this needs more example :(
10:00:26 <mniip> examples
10:00:26 <edwardk> so flipping that law we get
10:00:33 <edwardk> cata phi . In = phi . fmap (cata phi)
10:00:48 <edwardk> cata phi = cata phi . In . out = phi . fmap (cata phi) . out
10:00:52 <fr33domlover> dfeuer, really? no smarter way? :/
10:00:55 <edwardk> gives the definition of cata
10:00:59 <dfeuer> fr33domlover, that's the smarter way.
10:01:02 <edwardk> mniip: sure.
10:01:03 <edwardk> :t foldr
10:01:05 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:01:12 <edwardk> ^- that is a catamorphism in disguise
10:01:15 <dfeuer> fr33domlover, GHC threads are very cheap.
10:01:19 <mniip> edwardk, an example of an algebra would help
10:01:24 <edwardk> we can see that by grouping things up
10:01:24 <mniip> also an example of a homomorphism
10:01:31 <edwardk> mniip: working through foldr =)
10:01:41 <fr33domlover> dfeuer, oh I see. Are there less smart ways to be aware of and avoid?
10:01:42 <edwardk> then we can see sum, length, all sorts of stuff as f-algebras
10:02:18 <mniip> you mean []-algebras
10:02:21 <edwardk> lets make a data type data L x b = Nil | Cons x b
10:02:22 <edwardk> no
10:02:27 <dfeuer> fr33domlover, digging into weird low-level system libraries? Don't do that.
10:02:27 <edwardk> i mean L x - algebras
10:02:31 <edwardk> Mu (L x) = [x]
10:02:50 <edwardk> [] is the fixed point here, not the base functor
10:02:54 <fr33domlover> dfeuer, thanks. Wasn't going to. I'll use threads then :)
10:03:24 <edwardk> (a -> r -> r) -> r -> [a] -> b
10:03:25 <edwardk> becomes
10:03:32 <edwardk> ((a, r) -> r) -> r -> [a] -> b
10:03:50 <edwardk> becomes (Either (a, r) () -> r) -> [a] -> b
10:04:05 <edwardk> er
10:04:06 * hackagebot texmath 0.8.2.1 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.2.1 (JohnMacFarlane)
10:04:09 <edwardk> the 'b's there should be rs
10:04:30 <edwardk> so (a -> r -> r) -> r -> [a] -> r   becomes ((Either (a, r) () -> r) -> [a] -> r   if we shuffle it
10:04:45 <edwardk> you have Either a "cons cell or a nil cell"
10:05:04 <edwardk> where the recursive part has been replaced with the result of folding up to that point
10:05:32 <edwardk> anyways (Either (a, r) ()   = L a r  -- data type data L x b = Nil | Cons x b
10:05:44 <mniip> uh
10:05:50 <dfeuer> edwardk, why did you want somethnig with the type of cata? Is that some sort of f-algebra functor or something?
10:05:50 <mniip> might be drifting too far
10:05:52 <edwardk> er for the data type
10:06:09 <dfeuer> Er ... that's probably wrong.
10:06:13 <dfeuer> What is it?
10:06:58 <edwardk> dfeuer: given an f-algebra (A, phi :: f A -> A),  cata phi is the unique f-algebra homomorphism from the initial f-algebra (Mu f, In) to (A, phi)
10:07:31 <edwardk> mniip: sum = cata $ \case Nil -> 0; Cons a b -> a + b
10:07:31 <dfeuer> edwardk, okay, so now let me read over that again....
10:07:42 <edwardk> mniip: length = cata $ \case Nil -> 0; Cons _ b -> 1 + b
10:08:05 <edwardk> product = cata $ \case Nil -> 1; Cons a b -> a * b
10:08:47 <edwardk> data N a = Z | S a -- is basically Maybe.
10:09:26 <edwardk> Mu N = In Z | In (S (In Z))  | In (S (In (S (In Z)))) | ...
10:09:32 <edwardk> are peano numerals
10:09:54 <mniip> edwardk, aand I still don't understand what an "algebra" is
10:10:45 <edwardk> (+) :: Mu N -> Mu N -> Mu N;   (+) x = cata $ \case Z -> x; S y -> S y
10:11:30 <edwardk> (*) :: Mu N -> Mu N -> Mu N; (*) x = cata $ \case Z -> Z; S y -> x + y
10:12:16 <edwardk> so with the above we can see (+) and (*) on peano numerals, and sum, length, product on lists are all catamorphisms
10:12:44 <edwardk> mniip: ok, so rewind me to where you need me
10:12:47 <mniip> [19:44:04] <edwardk> an f-algebra is a function (f a -> a)
10:12:52 <edwardk> you wanted example so i had to digress to give some =)
10:13:01 <edwardk> mniip: ok, so now you know what an f-algebra is
10:13:03 <edwardk> its just a function
10:13:12 <mniip> can I get an example of such a function
10:13:23 <emmanuel_erc> hello there
10:13:44 <emmanuel_erc> So, I recently just read https://twdkz.wordpress.com/2013/05/31/data-analysis-with-monoids/
10:14:07 <edwardk> phi Nil = 0; phi (Cons a b) = a + b
10:14:13 <edwardk> sum = cata phi
10:14:29 <emmanuel_erc> For those that decide to read this, I just want to ask if the author is saying that using monoids is faster for doing certain operations?
10:15:03 <edwardk> in each one of those cata whatever examples i just write, the 'whatever' is the f-algebra
10:15:08 <dfeuer> emmanuel_erc, no idea what the author is saying, but associativity is very useful for parallelizing things.
10:16:03 <mniip> edwardk, and why is 'sum' not an algebra
10:16:59 <emmanuel_erc> dfeuer: Ok, thanks. I hope wasn't too "beginnery"
10:17:26 <dfeuer> emmanuel_erc, no, but my brain is too busy trying to understand what edwardk is saying to focus on anything else.
10:17:36 <edwardk> sum :: Num x => [x] -> x  -- sum :: Num x => Mu (L x)  -> x   is an f-algebra homomorphism from Mu (L x)  to x
10:18:12 <emmanuel_erc> dfeuer: Ok, thanks. I will ask later then.
10:18:12 <mniip> but why it isn't an []-algebra
10:18:17 <edwardk> sum is an f-algebra homomorphism, not an f-algebra per se
10:18:21 <edwardk> well, lets see
10:18:23 <edwardk> [x] -> x
10:18:26 <edwardk> it is an f-algebra
10:18:36 <mniip> [] x -> x
10:18:39 <mniip> f ~ [], x ~ a
10:18:40 <edwardk> yes
10:18:47 <mniip> []-algebra
10:18:51 <edwardk> yep
10:18:56 <Tuplanolla> Associativity is the nice part there, emmanuel_erc.
10:19:26 <edwardk> you could use it to tear down Mu [] -- which would be something like a rose tree with no data at the leaves.. the answers would be boring.
10:19:56 <edwardk> the fact that sum itself is an f-algebra is coincidental though and not very useful
10:20:00 <dfeuer> emmanuel_erc, if you have associativity, you can break up the work into chunks, calculate with those, and put the results together again. mapreduce sort of stuff.
10:20:25 <emmanuel_erc> I understand the point much better now dfeuer. Thanks.
10:20:38 <edwardk> emmanuel_erc: monoids let you work in parallel, they also let you work incrementally, and they also let you reuse intermediate results that come up several times
10:20:44 <Tuplanolla> It's enough to compare ((w + x) + y) + z with (w + x) + (y + z).
10:20:59 <dfeuer> edwardk, you say it's an f-algebra homomorphism to x, but how is x an f-algebra?
10:21:01 <emmanuel_erc> So memoization is now a trivial task.
10:21:10 <edwardk> e.g. you can define 'repeating :: Monoid m => Int -> m -> m'   and have it glue together m's using "peasant multiplication" so that it only uses mappend  log n times.
10:21:31 <edwardk> dfeuer: i was sloppy, let me restart
10:21:34 <edwardk> er restate
10:22:14 <dfeuer> edwardk, remember that I (at least) am sufficiently unfamiliar with the subject that any slop will be completely misunderstood.
10:22:18 <edwardk> phi Nil = 0; phi (Cons a b) = a + b;   sum = cata phi    is an f-algebra homomorphism from (Mu (L x), In)  to (x, phi)
10:22:48 <edwardk> :t cata
10:22:49 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
10:22:52 <edwardk> :t In
10:22:54 <lambdabot> f (Mu f) -> Mu f
10:23:11 <edwardk> @let data L x a = Nil | Cons x a
10:23:12 <lambdabot>  Defined.
10:23:43 <edwardk> > let phi Nil = 0; phi (Cons a b) = a + b in cata phi (In Nil)
10:23:45 <lambdabot>      No instance for (Show a0)
10:23:45 <lambdabot>        arising from a use of ‘show_M48862174783190234532252’
10:23:45 <lambdabot>      The type variable ‘a0’ is ambiguous
10:23:52 <edwardk> @undefine
10:23:53 <lambdabot> Undefined.
10:24:01 <edwardk> @let data L x a = Nil | Cons x a deriving Show
10:24:02 <lambdabot>  Defined.
10:24:04 <edwardk> :t cata
10:24:05 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
10:24:09 <edwardk> > let phi Nil = 0; phi (Cons a b) = a + b in cata phi (In Nil)
10:24:11 <lambdabot>      No instance for (Show a0)
10:24:11 <lambdabot>        arising from a use of ‘show_M843558737258771372732287’
10:24:11 <lambdabot>      The type variable ‘a0’ is ambiguous
10:24:25 <edwardk> bah
10:24:29 <edwardk> whats going on lambdabot
10:25:21 <edwardk> ah forgot the functor
10:25:23 <edwardk> @undefine
10:25:23 <lambdabot> Undefined.
10:25:23 <dfeuer> Brain overflow.
10:25:31 <edwardk> @let data L x a = Nil | Cons x a deriving (Show, Functor)
10:25:32 <mniip> edwardk, hold on hold on hold on
10:25:33 <lambdabot>  Defined.
10:25:45 <mniip> phi :: L Int Int -> Int?
10:25:49 <edwardk> > let phi Nil = 0; phi (Cons a b) = a + b in cata phi (In (Cons 1 (In Nil)))
10:25:51 <lambdabot>  1
10:25:56 <edwardk> mniip: yes
10:26:04 <edwardk> > let phi Nil = 0; phi (Cons a b) = a + b in cata phi (In (Cons 1 (In (Cons 2 ((In Nil)))))
10:26:06 <lambdabot>  <hint>:1:90:
10:26:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:26:08 <edwardk> > let phi Nil = 0; phi (Cons a b) = a + b in cata phi (In (Cons 1 (In (Cons 2 ((In Nil))))))
10:26:10 <lambdabot>  3
10:26:21 <mniip> oh it almost makes sense
10:26:40 <mniip> okay now what about homomorphisms
10:27:55 <dfeuer> Practical question, edwardk. For my proposed runTS  ( https://github.com/ekmett/machines/issues/50 ), should things be glommed on to the left or to the right?
10:29:18 <edwardk> ok, an f-algebra homomorphism from (A, phi :: f A -> A)    and (B, psi :: f B -> B)  is a function from A -> B    such that it 'respects the functions phi and psi' nicely
10:29:24 <edwardk> dfeuer: let me switch topics later please
10:29:54 <dfeuer> Sorry.
10:31:59 <edwardk> given a f-algebra homomorphism f :: (A, phi) -> (B, psi)   f is represented by a function from A -> B , now we can look at some types:
10:32:13 <edwardk> fmap f :: f A -> F B        psi . fmap f :: f A -> B              phi :: f A -> A           f . phi :: f A -> B         and we want psi . fmap f = f . phi
10:32:43 <mniip> I'm not entirely sure how can a 'wrong' f be constructed
10:33:02 <edwardk> write a function where that doesn't hold.
10:33:10 <edwardk> then it isn't an 'f-algebra homomorphism'
10:33:16 <edwardk> its just a function f :: A -> B
10:33:25 <mniip> yeah the question is how
10:33:48 <edwardk> well, remember our values carry meaning.
10:34:19 <monochrom> you know, you have many different f's. at one point, f is a functor. at another point, same line, f is an A->B arrow.
10:34:29 <edwardk> so lets consider phi Nil = 0; phi (Cons a b) = a + b        and psi Nil = 1; psi (Cons a b) = a * b
10:35:13 <edwardk> monochrom: yeah, i'm evil, expecting at the same time folks to distinguish at the type level from the value level, and then conflating them by talking about the objects in a category of f-algebras. oh well.
10:35:41 <edwardk> so we could look for an f-algebra homomorphism from (Int, phi)   -> (Int, psi) 
10:36:16 <edwardk> er (Double, phi) to (Double, psi)
10:36:23 <mniip> edwardk, I have no issues with the value-type thing
10:36:28 <edwardk> maybe 'exp'?
10:36:31 <mniip> but rather understanding what is variable
10:36:33 <monochrom> . o O ( the solution is to use more Greek letters )
10:36:55 <edwardk> most other functions would fail to be an f-algebra homomorphism.
10:37:22 <mniip> why do you keep calling it an f-algebra
10:37:42 <edwardk> f here is L x
10:37:44 <Cale> I think in order to understand what F-algebra homomorphisms are in a specific instance, it helps just to write out exactly what the laws mean when you specialise them to the constructors of your given F.
10:37:45 <joco42> is  there some introductory video about stack?
10:37:47 <edwardk> see the Nil and the Cons here?
10:37:56 <edwardk> phi Nil = 0; phi (Cons a b) = a + b        and psi Nil = 1; psi (Cons a b) = a * b
10:38:07 <edwardk> they came from (L x)
10:38:13 <mniip> why not call it (L x)-algebra
10:38:17 <edwardk> so when i say 'f' there i really should be saying L x -algebra
10:38:19 <edwardk> yes
10:38:25 <edwardk> mniip: habit =)
10:39:02 <Brunoo> Hi, I'm trying to install GTK2HS for windows and I'm having problem on the "cabal install gtk" step. The problem is that I have thhe message "* Missing C libraries: z, cairo". My "pkg-config --cflags gtk+-2.0" line work, and "gtk-demo" too. I can access gtk2hsC2hs. Did anyone had that problem?
10:39:53 <edwardk> so for exp to be a homomorphism between these two (L x)-algebras, we'd need to show psi . fmap exp = exp . phi
10:40:48 <timemage> Brunoo, haven'd messed with it in a long time.  but i would look to see if you dev packages
10:41:05 <timemage> Brunoo, -dev packages... for z and cairo
10:41:10 <mniip> so
10:41:25 <mniip> f(x + y) = x * f(y)
10:41:32 <Brunoo> What do you mean by -dev packages timemage ?
10:41:34 <mniip> where f is the homomorphism we're looking for?
10:42:02 <timemage> Brunoo, if you want message me.  it's almost more of a linux question than a haskell question.
10:42:19 <Hijiri> he's using windows
10:42:42 <mniip> oh and f(0) = 1
10:42:44 <timemage> Hijiri, ah, so he is.
10:43:22 <jamie_h> I'm trying to start exercise 1 on http://www.seas.upenn.edu/~cis194/hw/03-ADTs.pdf. A state is `type State = String -> Int`, and I need to write a fn that "extends" a state, like so: `extend :: State -> String -> Int -> State`. I can't get my fn to propagate back to the parent fn if the criteria is not met. 
10:44:00 <edwardk> mniip: sounds like you've got it
10:44:15 <jamie_h> this is what I have so far: `extend pre x v = \y -> if x == y then v else pre x` <- but it doesn't work. when you run `let st = extend empty "A" 10`, `let st' = extend st "B" 11`, you SHOULD expect `st' "A"` to equal 10, but it equals 0
10:47:28 <jamie_h> here's a pastebin of some of the code: http://lpaste.net/135863
10:48:21 <Hijiri> jamie_h: I think there is a problem in the else part of your expression
10:48:43 <Hijiri> Is State a synonym for String -> Int ?
10:49:01 <Hijiri> oh, sorry, just looked at your paste
10:49:15 <edwardk> mniip: cata phi is interesting precisely because it passes the laws for an f-algebra homomorphism for every function phi
10:49:26 <Hijiri> jamie_h: you're passing the wrong value into pre in your else
10:50:20 <edwardk> mniip: and given (A, phi) is an f-algebra, cata phi : (Mu f, In) -> (A, phi)  is the only such homomorphism from (Mu f, In)
10:51:00 <jamie_h> Hijiri: hmm. but if x is "A", shouldn't that be the same? if fed into pre it should return 10 right?
10:51:40 <Hijiri> think of what the variables are in this case
10:51:42 <Hijiri> What is x?
10:52:46 <Hijiri> st' is defined as extend st "B" 11
10:53:12 <Hijiri> If we expand that out, it's \y -> if "B" == y then 11 else st "B"
10:53:45 <Hijiri> do you see what happens when you try to apply it to "A"
10:55:04 <jamie_h> it will always fail in `st` right? because B will never equal A
10:55:44 <jamie_h> is there a way to let st do its thing (with "A") if the initial st' condition has not been met?
10:56:22 <mniip> edwardk, wait what
10:56:31 <edwardk> ?
10:56:32 <mniip> what are Mu and In again
10:56:48 <edwardk> newtype Mu f = In { out :: f (Mu f) }
10:56:55 <edwardk> In is the constructor for that
10:57:07 <Hijiri> jamie_h: this is what happens if you apply it to "A"
10:57:21 <Hijiri> (\y -> if "B" == y then 11 else st "B") "A"
10:57:27 <mniip> ooh
10:57:32 <Hijiri> if "B" == "A" then 11 else st "B"
10:57:33 <mniip> so In is kinda backwards
10:57:36 <Hijiri> st "B"
10:57:42 <edwardk> In :: f (Mu f) -> Mu f
10:57:51 <edwardk> is an f-algebra
10:58:02 <mniip> it is "in" wrt mu, but out wrt f
10:58:12 <Hijiri> you don't want to be getting st "B", you want to be getting st "A"
10:58:29 <Hijiri> because that is the variable you are looking up
10:58:30 <edwardk> its best to think about this as In, because the vocabulary will mess with you otherwise =)
10:59:02 <Hijiri> jamie_h: there is a way
10:59:08 * hackagebot hsexif 0.6.0.2 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.6.0.2 (EmmanuelTouzery)
10:59:15 <Hijiri> here's a hint: there is a variable in scope that will hold "A"
10:59:21 <mniip> ok, so Mu is the fixpoint combinator on types
10:59:29 <Hijiri> (in scope in the else expression)
10:59:47 <edwardk> it is the least fixed point combinator. we distinguish Mu and Nu in some type theories
10:59:57 <edwardk> here in haskell they happen to coincide
11:00:12 <jamie_h> "pre" will already hold "A". so I just need to return pre 
11:00:21 <edwardk> and cata is basically the defining property of such a fixed point combinator on types
11:00:49 <jamie_h> but I can't return pre (which is partially applied) in a function that returns Int
11:01:22 <Hijiri> jamie_h: We aren't trying to add "A" here
11:01:23 <edwardk> we can define Mu in a couple of different ways
11:01:27 <Hijiri> we're trying to look itup
11:01:27 <edwardk> one is the data type we just built
11:01:32 <edwardk> another is to re-arrange the definition of cata
11:01:48 <monochrom> jamie_h: do you already know that pre's type is, verbosely, (String->Int) -> (String -> (Int -> (String -> Int))) ?
11:01:53 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a  -- flipped becomes Mu f -> (f a -> a) -> a  
11:01:55 <edwardk> so we could define
11:02:17 <edwardk> newtype Mu f = Mu { runMu :: forall a. (f a -> a) -> a }
11:02:17 <mniip> so by saying that it is the intial object, you say that for any phi, there exists an f, such that 'phi . fmap f = f . In'
11:02:24 <monochrom> err, that's extend's type, not pre's type
11:02:40 <jamie_h> can I pattern match pre in the extend definition?
11:02:48 <edwardk> yep
11:02:50 <Hijiri> you can't pattern match functions
11:03:00 <edwardk> and we call that f    "cata phi"
11:03:06 <monochrom> no, apart from using the trivial "pattern" i.e. variable name
11:03:13 <edwardk> phi . fmap (cata phi) = cata phi . In
11:03:18 <mniip> phi . fmap f . out = f . In . out
11:03:20 <mniip> phi . fmap f . out = f
11:03:34 <edwardk> yep
11:03:41 <edwardk> cata phi = phi . fmap (cata phi) . out
11:03:43 <monochrom> or multiple variable names. f@(g@(h@pre))
11:04:08 <edwardk> cata phi = f where f = phi . fmap f . out
11:04:21 <edwardk> that is precisely how we define cata normally
11:04:33 <edwardk> just by rearranging the law that must hold
11:04:48 <mniip> now I need to figure out what cata does
11:04:52 <edwardk> another way is to write down the modified Mu i just gave
11:04:58 <edwardk> newtype Mu f = Mu { runMu :: forall a. (f a -> a) -> a }
11:05:07 <edwardk> and defining cata phi (Mu k) = k phi
11:05:44 <edwardk> cata basically tear down your structure level by level, assuming all deeper levels have been torn down already
11:05:51 <jamie_h> I'm not sure how I can blend the new fn of st' with the existing fn of pre
11:06:02 <Hijiri> jamie_h: What are you trying to do in the else expression
11:06:30 <jamie_h> in the else, I want to return pre so that it can accept any arguments and handle its own logic
11:06:40 <edwardk> mniip: https://wiki.haskell.org/Catamorphisms
11:06:43 <jamie_h> pre should not be given x
11:06:47 <noah>  edwardk: what place does Nu hold, if Mu is the initial object? is it initial in a differnt category or something?
11:06:47 <edwardk> ^- that is based on an old article i wrote up
11:06:49 <Hijiri> I mean, what is the purpose of the else expression
11:07:02 <Hijiri> In what case would you enter it
11:07:06 <edwardk> noah: Nu is the final _co_algebra.
11:07:29 <jamie_h> when a future argument does not match either "A" or "B"
11:07:39 <edwardk> (Mu f, In) is the an initial algebra.   (Nu f, out) is the final coalgebra.
11:07:40 <Hijiri> why when it doesn't match "A" ?
11:07:43 <noah> ah, thanks, that makes sense. I'll reea the article
11:07:57 <jamie_h> in the case of st', it is invoked when the future arg does not match "B"
11:08:08 <jamie_h> in the case of st, it is invoked with the future arg does not match "A"
11:08:08 <edwardk> an f-coalgebra is just a function (a -> f a)  
11:08:09 <Hijiri> oh, that's what you meant
11:08:11 <Hijiri> sorry
11:08:16 <monochrom> oh, I see. given function pre::String->Int, (extend pre "xxx" 5) is also a function String->Int, such that: (extend pre "xxx" 5) "xxx" = 5, (extend pre "xxx" 5) s = pre s  for other strings s
11:08:23 <edwardk> and we can define coalgebra homomorphisms just like before
11:08:43 <Hijiri> So if the thing you are looking up isn't the most recently assigned variable, where can you look to get its value?
11:08:50 <edwardk> and if we look around we can fine a final coalgebra, such that there is a unique f-coalgebra homomorphism _to_ it for every other coalgebra
11:08:55 <edwardk> er every coalgebra
11:09:13 <edwardk> ana :: Functor f => (a -> f a) -> a -> Nu f
11:09:24 <edwardk> mniip: as an exercise i encourage you to implement 'ana' =)
11:09:35 <mniip> does ana come from anastrophe
11:09:40 <jamie_h> can you explain "thing you are looking up" in terms of st'?
11:09:52 <Hijiri> The argument to st'
11:09:55 <edwardk> ana is the greek root meaning 'upwards'
11:10:00 <edwardk> cata comes from 'downwards'
11:10:10 <Hijiri> For example, if I did st' "C", the "thing I'm looking up" would be "C"
11:10:13 <edwardk> ἀνά
11:10:38 <edwardk> ἀνάμορφή  = 'upward shape'
11:10:48 <jamie_h> well it would not return the value (in this case 11, since that's reserved for "B"). AFAIK, the look-up should stop, and invoke the pre fn
11:11:01 <edwardk> honestly it was that lambert meertens liked greek and latin
11:11:08 <jamie_h> since I didn't know you could glimpse into functions and grab its arguments out
11:11:12 <shachaf> edwardk: Isn't ana = Nu or so?
11:11:16 <edwardk> calling them anamorphisms and catamorphisms basically just ensured that people were afraid of them
11:11:19 <shachaf> I guess I didn't see which definition of Nu you're using.
11:11:19 <Hijiri> jamie_h: what do you mean by that
11:11:24 <Hijiri> you can't introspect on functions
11:11:31 <edwardk> shachaf:  you can rearrange ana into a definition for Nu, yes
11:11:48 <edwardk> data Nu f where Nu :: (a -> f a) -> a -> Nu f
11:11:50 <mniip> edwardk, wait what
11:11:50 <Tuplanolla> What names would be more approachable?
11:11:50 <edwardk> then ana = Nu
11:11:55 <Hijiri> In the body of your state function (\y -> ...) you have access to the argument
11:12:02 <Hijiri> since y is the argument
11:12:08 <mniip> edwardk, what's Nu
11:12:12 <edwardk> er with a Functor
11:12:17 <jamie_h> crap so it's pre y?
11:12:20 <Hijiri> yep
11:12:30 <jamie_h> that's so easy, can't believe I didn't see that!
11:12:51 <jamie_h> thanks Hijiri
11:12:52 <edwardk> mniip: we can define 'Mu' in terms of the existence of 'In :: f (Mu f) -> Mu f' and cata phi :: Functor f => (f a -> a) -> Mu f -> a
11:12:54 <monochrom> yeah, I just realized that too
11:13:18 <edwardk> mniip: we can define Nu in terms of the existence of 'out :: Nu f -> f (Nu f)' and ana :: Functor f => (a -> f a) -> a -> Nu f
11:13:36 <edwardk> in haskell Mu = Nu
11:13:57 <edwardk> in other type systems with more restrictive forms of recursion Mu may only be able to recurse a finite number of times on itself
11:14:18 <edwardk> while Nu may be bigger. nothing ensures that the 'seeds' you generate will stop
11:14:40 <Hijiri> jamie_h: also note that the recommended version of CIS194 is the spring 13 one
11:14:50 <edwardk> you can always embed Mu f -> Nu f  -- but going the other way requires more than other type systems (e.g. agda's) will give you
11:15:07 <Hijiri> I don't know if it applies to the newest iteration, but it covered some things that weren't covered by the fall 14 one
11:15:17 <Hijiri> that were important, like folds
11:15:30 <jamie_h> I did one of them a while back, but I like this course since it's a refresher and has tests
11:15:52 <edwardk> we can also generate 'out' from 'In'
11:15:56 <edwardk> :t cata (fmap In)
11:15:57 <lambdabot> Functor f => Mu f -> f (Mu f)
11:16:08 <Hijiri> oh, alright then
11:16:09 <edwardk> this is called "Lambek's lemma"
11:16:09 <ReinH> edwardk: o/
11:16:19 <edwardk> and its quite a powerful tool
11:16:37 <edwardk> heya ReinH 
11:16:38 <mniip> edwardk, I fail to see the analogy
11:16:48 <edwardk> which analogy?
11:16:55 <edwardk> the seed thing?
11:16:57 <mniip> I mean I can infer an implementation for 'Functor f => (a -> f a) -> a -> Nu f' from its type
11:17:06 <mniip> but largely I don't see how it's related to cata
11:17:35 <edwardk> ana says you have a 'seed' "a" and a coalgebra (a -> f a)   that can generate a new layer. you can build up a tower of f's by recursively filling it in
11:17:58 <mniip> so no homomorphisms involved this time?
11:18:02 <edwardk> ana psi = f where f = out . fmap f . psi
11:18:05 <mniip> er
11:18:05 <edwardk> oh there are
11:18:18 <edwardk> this is the final f-coalgebra
11:19:02 <mniip> ok and
11:19:11 <edwardk> given an f-coalgebra (A, psi :: A -> f A)       there exists a unique f-coalgebra homomorphism from (A, psi) -> (Nu f, out)
11:19:15 <adarqui> i can't get this doctest-discover driver working.. makes no sense. it's going to drive me insane.
11:19:17 <edwardk> ana psi
11:19:44 <edwardk> f-coalgebra homomorphisms work a lot like the f-algebra homomorphisms, draw the only diagram that makes sense
11:20:04 <mniip> diagram?
11:20:42 <edwardk> https://wiki.haskell.org/Catamorphisms#Derivation
11:20:49 <edwardk> ^- see the picture there?
11:21:09 <edwardk> there is a similar picture for ana
11:21:24 <edwardk> but its flipped around.
11:21:55 <statusfailed> How are you supposed to implement "fromException" in Control.Exception ?
11:21:57 <edwardk> psi :: X -> F X   on the top.  and out :: Nu F -> F (Nu F) on the bottom
11:22:53 <monochrom> statusfailed: I believe you're supposed to just write "instance Exception Mine;" and use the default implementations
11:23:19 <monochrom> I believe I read that from the doc
11:23:31 <osa1> does anyone know a package that defines Arbitrary for vectors?
11:23:42 <edwardk> the fact that those can be supplied in the class is 'weird'
11:23:47 <statusfailed> monochrom: Is there some built-in magic going on there?
11:24:10 <edwardk> given that it uses the typeable instance anyways behind your back some times
11:24:12 <monochrom> no, it's standard Haskell 2010 to use default implementations
11:24:25 <edwardk> monochrom: no i mean that overriding them doesn't quite work
11:24:50 <monochrom> my "no" means "not magic"
11:25:10 <edwardk> mine is just that them being in the class adds no usable power
11:25:29 <edwardk> if we ditched the Typeable superclass? then it'd add power
11:27:11 <edwardk> i have to jump through some serious hoops in lens involving Typeable forms of reflection to make temporary types that can instantiate that class to let you 'catch' any fold
11:27:12 <statusfailed> I don't really understand how "catch" can work without magic :\
11:27:28 <dfeuer> edwardk, do you know why In and out were chosen? What's the mnemonic?
11:27:44 <monochrom> oh, "catch" is of course a built-in. it's IO.
11:27:56 <eds> I am trying to learn existential. Can somebody explain me line 5 and line 8. http://lpaste.net/135867
11:27:57 <edwardk> In :: f (Mu f) -> Mu f  -- it injects a layer of 'f' into Mu f
11:28:06 <statusfailed> monochrom: ah, right!
11:28:11 <edwardk> out :: Nu f -> f (Nu f) -- peels one layer off
11:28:22 <statusfailed> OK that makes more sense
11:28:31 <edwardk> besides Out and 'in' runs into a problem with in being a keyword =)
11:28:42 <monochrom> edwardk: class Exception is a subclass of Typeable (and Show). a default method implementation in Exception is entitled to use any Typeable method.
11:28:48 <c_wraith> eds: sure.  Line 5 includes a type variable on the right side, a, that isn't on the left side
11:29:08 <c_wraith> eds: Usually the compiler would reject that.
11:29:11 <edwardk> monochrom: yes. it is. my point is this. having those as methods adds zero usable expressive power. they might as well be top level definitions
11:29:32 <c_wraith> eds: but the ExistentialQuantification extension allows the special syntax with the forall on the right side.
11:30:02 <edwardk> because combinators in Control.Exception go and use Typeable behind your back anyways
11:30:08 <eds> confused
11:30:12 <edwardk> so you can't do anything but what the defaults do there
11:30:18 <edwardk> if you do, your instance is just broken
11:30:32 <c_wraith> eds: what that data definition is saying, then, is that the constructor (Box, not to be confused with the type Box) works for all choices of a
11:30:53 <edwardk> the only usecase i've ever had for them is http://hackage.haskell.org/package/lens-4.11/docs/src/Control-Lens-Internal-Exception.html
11:31:12 <edwardk> but all the pain in that comes from the fact that we have Exception leading this weird double life
11:31:21 <c_wraith> eds: Ok, where are you confused?
11:31:22 <edwardk> where sometimes it'll use your toException/fromException stuff
11:31:29 <edwardk> and sometimes it'll use Typeable to get its own crap out
11:31:45 <statusfailed> geez, I don't even know what Typeable is :\
11:31:56 <mauke_> :t typeOf
11:31:57 <lambdabot> Typeable a => a -> TypeRep
11:32:00 <monochrom> Typeable is run-time type information
11:32:04 <edwardk> :t cast
11:32:05 <c_wraith> statusfailed: you don't actually need to know what Typeable is to use Exception, though.
11:32:05 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
11:32:10 <edwardk> ^- it lets you do that
11:32:13 <edwardk> :t gcast
11:32:15 <lambdabot> forall (k :: BOX) (a :: k) (b :: k) (c :: k -> *). (Typeable a, Typeable b) => c a -> Maybe (c b)
11:32:17 <edwardk> or more generally that
11:32:38 <c_wraith> edwardk: what version of GHC switched Data.Dynamic to use the GADT representation?
11:32:39 <statusfailed> c_wraith: good :p
11:32:40 <rs0> BOX?
11:32:54 <c_wraith> rs0: it's the sort for all kinds in GHC.  >_>
11:32:54 <mniip> rs0, the sort of kinds
11:32:54 <edwardk> c_wraith: it was fairly recently that i proposed it
11:33:03 <eds> c_wraith: oh ok you mean the type variable, a ,on the right side would be rejected. But because of forall the comiler understands it is a special syntax
11:33:07 <c_wraith> edwardk: so 7.12 probably?
11:33:10 <c_wraith> eds: yes
11:33:15 <monochrom> "k :: BOX" means that k is a kind, IIRC
11:33:23 <rs0> okay, so it's an ExplicitKind
11:33:28 <rs0> i'm familiar with kinds but not... sorts
11:33:31 <edwardk> yeah its still using a TypeRep in 7.10
11:33:46 <mniip> there's only one sort to be familiar with
11:33:48 <c_wraith> eds: the special syntax lets you say that the constructor, Box, works for *all* choices of a
11:33:49 <edwardk> monochrom: yes
11:34:07 <edwardk> rs0: the syntax written by lambdabot there can't actually be typed in by you
11:34:10 <c_wraith> eds: you still have to *choose* a type for a.  You can't put polymorphic stuff in it.
11:34:26 <eds> c_wraith: But how does the compiler know that the Box in there is a constructor and not type?
11:34:30 <c_wraith> eds: But so long as the three things you put in agree on the type of a, you can construct a Box value
11:34:30 <monochrom> "one BOX to hold them all"?
11:34:50 <c_wraith> eds: syntactically.  It's just like in data Foo = Foo String
11:35:01 <c_wraith> eds: Foo is the constructor, it takes a String argument
11:35:15 <mauke_> what's this Dynamic GADT thing?
11:35:16 <edwardk> eds: BOX is internal GHC lingo for 'the sort that holds all the kinds', just like types have kinds, kinds inhabit 'BOX'
11:35:31 <eds> Ahh ok. that would make sense.
11:35:32 <edwardk> it never shows up in the surface syntax except when ghc decides to print stuff like this
11:35:45 <c_wraith> mauke_: change Dynamic to be Data Dynamic where Dyn :: Typeable a => a -> Dynamic
11:35:59 <c_wraith> mauke_: functionally the same, but a bit cleaner to use
11:36:06 <eds> ohh so say like box for me can hold int, string, bool. All the type that has show as an attribute
11:36:06 <edwardk> c_wraith: there is a difference
11:36:15 <mauke> oh, just an existential type?
11:36:16 <edwardk> well, its fairly minor, but nonetheless
11:36:17 <shachaf> I would call that a Dynamic existential thing.
11:36:21 <edwardk> monochrom: yeah
11:36:37 <c_wraith> eds: it doesn't even need to be in Show
11:36:44 <c_wraith> eds: There's no restriction on that existential
11:36:46 <edwardk> gotta run
11:37:30 <shachaf> GADT is just a syntax.
11:37:41 <eds> c_wraith: oh ok. so the box here has three types right?
11:38:03 <eds> a, a -> a, a -> String
11:38:05 <c_wraith> eds: The Box type is just one type.  The constructor takes 3 arguments, though
11:38:13 <Peaker> shachaf: btw: I didn't solve your exercise from the other day -- what is the practical problem of using your Equality a b = forall f. f a -> f b   thing in place of GADTs?
11:38:14 <c_wraith> eds: those are the types of the three arguments to the constructor
11:38:27 <shachaf> What was my exercise?
11:38:43 <Peaker> shachaf: figuring out what issues it has in practice :)
11:38:48 <shachaf> Oh.
11:38:49 <eds> oh ok. Could I have defined it like Box a
11:38:52 <Peaker> shachaf: that would require trying it out in practice, but I didn't get around to it :)
11:38:58 <eds> | Box a -> a
11:39:02 <shachaf> Try to write (forall p. p Char -> p Bool) -> Void
11:39:07 <eds> | Box a -> String
11:39:07 <eds> ?
11:39:23 <shachaf> Easy with GADT/TypeFamilies equality (because GHC cheats a little bit).
11:39:39 <eds> c_wraith
11:39:42 <c_wraith> eds: you could, but then the expression (Box "foo" (++ " bar") id) and (Box 5 negate show) would have different types
11:40:05 <c_wraith> eds: Half of what the existential thing does is makes those two expression the exact same type
11:40:12 <c_wraith> eds: so you can collect a bunch of them together.
11:40:42 <alphonse23__> does anyone know, when I use `cabal update` which port cabal is downloading the package list on. Or does anyone know how I could find that out.
11:40:47 <nolrai66> I've still never actually needed an existential data type.
11:40:53 <c_wraith> eds: the other half is going in the other direction.  When you pattern match on a Box value, you don't know what the type was.
11:40:56 <monochrom> alphonse23__: I think it's simply 80
11:41:02 <Eduard_Munteanu> alphonse23__, plain HTTP
11:41:11 <c_wraith> eds: so all you can do is use the components together.
11:41:25 <alphonse23__> it's just 80 huh
11:41:27 <alphonse23__> okay. thanks
11:41:35 <monochrom> yeah, 80, just tried
11:41:55 <c_wraith> nolrai66: they aren't useful all that often..  the type being considered here is approximately the same thing as an infinite stream of String. :)
11:42:06 <rs0> how do existential types codegen? my understanding is that ordinary haskell functions are monomorphized, but it seems like existential types would require dictionary passing at runtime
11:42:22 <c_wraith> rs0: they do
11:42:42 <c_wraith> rs0: require dictionary passing at runtimme, that is.  But they're not the only case that happens.  Consider polymorphic recursion, for instance.
11:42:42 <Eduard_Munteanu> rs0, well, an existential type without a class constraint on it is kinda useless
11:42:49 <monochrom> if your existential type uses a type class
11:42:54 <c_wraith> Eduard_Munteanu: not always.  consider Coyoneda
11:43:05 <Peaker> shachaf: so *inequality* proofs cause the trouble?
11:43:25 <monochrom> if not, it's just whatever fields you specified, but with type erasure
11:43:25 <shachaf> Peaker: Yes, but people use them all the time.
11:43:29 <eds> oh ok. let me explain what I understood. So, those two arguments would have the same type as Box. And not as ,a -> a, or ,a -> String. That is what the compiler would read, right?
11:43:35 <eds> c_wrath
11:43:52 <shachaf> Peaker: Note that what's going on here is that GHC doesn't warn you that you have an incomplete pattern match if that pattern match would lead to a unification error.
11:43:57 <nolrai66> Why is the show example used.
11:44:06 <nolrai66> It's a dumb example.
11:44:10 <monochrom> it's an easy target
11:44:11 <c_wraith> eds: I think you're on the right track, but I didn't quite catch all your meaning.
11:44:19 <Peaker> shachaf: ah, I see, so the feature with GADTs where you only write the cases that actually happen
11:44:20 <monochrom> have you seen my riddle?
11:44:25 <monochrom> @quote monochrom river
11:44:25 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
11:44:25 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
11:44:25 <Peaker> shachaf: (according to the type)
11:44:29 <shachaf> Right.
11:44:35 <c_wraith> rs0: f :: (Show a) => Int -> a -> String ; f 0 x = show x ; f n x = f (n - 1) [x]
11:44:50 <c_wraith> rs0: that can't be monomorphised at runtime.  dictionary passing will always be required
11:45:02 <c_wraith> rs0: it's a dumb example, but polymorphic recursion does happen in the real world.
11:45:50 <eds> c_wrath: what did you mean  when the other half of existential goes in the other direction?
11:46:22 <Peaker> shachaf: we can write: (Equals a b -> Void) -> (f a -> f b) -> Void   and the missing piece would be: (Equals a b -> Void) for a and b that differ, right?
11:46:27 <nolrai66> All recursion on things like dependant vectors is recursive isn't it? Or can the compiler tell that that type is just a tag? 
11:46:40 <c_wraith> eds: Well, there are exactly two things you can do with an existential - pack values into an existential constructor, and remove them later.
11:46:45 <eds> We do not know the type, yes. So all we can do is bunch them together. Got that. That is what one half of existential would do. 
11:46:48 <monochrom> to a large extent, difference between existential type and non-existential type is just at type checking, not at code-gen
11:46:56 <rs0> c_wraith: does that require NoMonomorphismRestriction to compile?
11:47:12 <c_wraith> rs0: it shouldn't.  I might have typo'd something.
11:47:20 <c_wraith> eds: existentials affect both parts.  When packing, you can put in any type.  When unpacking, you don't know what the type was
11:47:27 <c_wraith> eds: that's all I meant by "both directions"
11:47:38 <shachaf> Peaker: I'm not sure I follow.
11:48:00 <Peaker> shachaf: I think I need to play with it to make sure what I say makes sense :)
11:48:08 <eds> Ahh ok. And how would we know what the type is when we are unpacking?
11:48:15 <eds> c_wraith
11:48:20 <ion> We don't.
11:48:23 <Peaker> shachaf: but I'm wondering what help we're missing from the type system to make it possible
11:48:28 <shachaf> Peaker: Also note that this GADT feature is (I think) incompatible with things like HoTT.
11:48:47 <nolrai66> shachaf: why?
11:48:53 <shachaf> Since there you *do* have (Equal Bool Bit) or something like that for different types.
11:49:09 <nolrai66> Ah.
11:49:26 <shachaf> Peaker: Anyway I've written a few emails to -cafe or glasgow-haskell-users or something about this before.
11:49:28 <c_wraith> eds: No way to know.  That's the restriction with existentials - you have to be able to make sense of the unpacked values without knowing their exact types
11:49:34 <c_wraith> > let f :: (Show a) => Int -> a -> String ; f 0 x = show x ; f n x = f (n - 1) [x] in [ f i () | i <- [0..3] ] -- rs0
11:49:36 <lambdabot>  ["()","[()]","[[()]]","[[[()]]]"]
11:49:42 <nolrai66> Yeah, I am really not convinced you want that axiom in a computational context.
11:50:15 <Peaker> shachaf: So HoTT makes all types with identical sets of values equal/interchangable?
11:50:26 <eds> ok.
11:50:54 <c_wraith> eds: and that's why most of the time, existentials aren't all that useful.  You have to get into some more exotic cases for them to become a big win. :)
11:51:12 <eds> cwraith: How do I run boxa in ghci. boxa has type Box.
11:51:20 <nolrai66> Peaker: Its a way of describing the way mathematicians talk about things, by failing to distiquish isomorphic things.
11:51:28 <Peaker> c_wraith: I think it might be a self-fulfilling prophecy -- it's not in the toolbox so we learn to use other tools instead
11:51:37 <monochrom> eds: suppose "data X = forall a. X a (a -> Int)". when unpacking "X v f", we don't know what type v is, but we know, and only know, "f v" makes sense
11:51:51 <Peaker> (it is in the toolbox, but it's quite a shitty implementation of that tool..)
11:52:04 <nolrai66> Peaker: every time I have tried to use it it was a mistake.
11:52:14 <c_wraith> eds: you would use functions like apply to work with them
11:52:28 <ion> “we knoww f v makes sense”
11:52:28 <monochrom> eds: your "apply" function is an example of doing something useful
11:52:57 <Peaker> For me it is easier to think about covariant type vars vs. contravariant type vars than existentials/universals  (e.g: a universal TV in the type of your current definition may as well be an existential when implementing that function)
11:53:05 <eds> c_wraith: Oh ok. I am working with genprog library. What I am supposed to do is to be able to accept arith nodes, bool nodes, comparable nodes into the tree as one type while I am constructing one. Would existential work for me? Or GADTS?
11:53:22 <Peaker> nolrai66: the typical use to capture a type class dictionary on its own is often a mistake
11:53:29 <shachaf> The right perspective is always producer/consumer, or two people playing a game.
11:53:37 <c_wraith> eds: usually you'd want to find some other approach.  More like putting the type variable in the left side of the data definition
11:53:38 <shachaf> One person's existential is the other person's the universal.
11:53:46 <c_wraith> nolrai66: an example of a more useful existential would be something like...   data Message = forall a. Message (IO a) (MVar a)
11:53:52 <Peaker> shachaf: yeah, it is a bit weird for me that we have "existential" and "skolem" for 2 things that to me seem almost identical
11:54:00 <c_wraith> nolrai66: that's handy for passing IO operations to a worker thread
11:54:02 <Peaker> (or was skolem the opposite of that, I can't remember!)
11:54:10 * hackagebot hspec-expectations 0.7.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.7.0 (SimonHengel)
11:54:13 <shachaf> "skolem" is more of an implementation detail.
11:54:43 <c_wraith> nolrai66: The worker thread can process IO actions that result in any type, and it knows it can put that result into the MVar when it's complete.
11:54:54 <c_wraith> nolrai66: and the sender will read the MVar whenever it gets around to it
11:54:56 <eds> monochrom: yea that it can take two arguments " f v" ,right?
11:55:25 <nolrai66> c_wraith: That does make sense.
11:55:27 <Peaker> shachaf: I mean nobody ever calls the "a" in:  id x = (x :: a)     an existential,  but in this context, I would
11:55:53 <shachaf> I don't think I'd call it that exactly.
11:55:56 <shachaf> But I guess you could.
11:55:58 <eds> c_wraith: could you give an example of that? Putting type variable on the left side of the data definition?
11:56:00 <shachaf> Well, no, not really.
11:56:15 <shachaf> f :: (exists a. a) -> r and g :: forall a. a -> r are the same thing.
11:56:27 <c_wraith> eds: sorry, have to run right now.  Other folks can help you out, though.
11:56:48 <eds> monochrom: ahh so I used apply. That made sense.
11:57:15 <eds> c_wraith: no problem. thank you for your help. :)
11:58:34 <Peaker> shachaf: but that just speaks of how it is quantified to the outside world, so I'd say it makes sense to assign the reverse quantification to the inside
11:58:46 <Peaker> shachaf: but I can see why it might get a bit confusing :)
11:58:50 <shachaf> Peaker: But id :: a -> a doesn't work with exists.
11:59:09 <nolrai66> shachaf: Do you /need/ univalence to do HoTT?
11:59:11 * hackagebot composition-extra 1.0.1 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.0.1 (athanclark)
11:59:25 <shachaf> Well, you can sort of say that from the implementor's perspective, it's like an existential.
11:59:27 <Peaker> shachaf: I know -- to the outside world it is universal/forall, to the implementation inside, though, there exists some unknown "a" type it must work with. "rigid" tv (or in my (confusing?) terminology, existential)
11:59:30 <shachaf> Anyway vocabulary is silly.
11:59:38 <shachaf> nolrai66: I don't know.
11:59:57 <nolrai66> shachaf: fair enough.
12:02:15 <rs0> what is HoTT?
12:03:21 <zomg> Hero of Time: Tarzan
12:04:11 * hackagebot composition-extra 1.0.1.1 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.0.1.1 (athanclark)
12:04:17 <nolrai66> rs0: "Homotopy Type Theory refers to a new interpretation of Martin-Löf’s system of intensional, constructive type theory into abstract homotopy theory. " is what the website says.
12:04:38 <nolrai66> Which does not explain why we would care about it..
12:05:13 <nolrai66> (we meaning CS as opposed to Homotopy mathematicians..)
12:06:40 <athan> nolrai66: HoTT basically allows us to prove proofs are equal, let alone expressions
12:07:01 <ski> Peaker : yes, "existential","universal" can map to "skolem","meta- / logic (dataflow) variable" in one order or the other, depending on whether the existential/universal is to be used or constructed
12:07:47 <Peaker> ski: cool, just explaining it though made me realize why it might just add to the confusion :)
12:08:20 <nolrai66> Just a lot of work seems to be spent on geting "funtional extentionality" which from a CS point of view seems unwanted.
12:08:34 <nolrai66> Or maybe I am crazy.
12:08:45 <nolrai66> I've never even been to grad school so..
12:09:36 <ski> Peaker : "skolem" is always something that is fixed (by someone else), something opaque you can't inspect (except to the extent you're granted assumptions regarding it). the meta- / logic variable is a place-holder you use to delay having to choose what to put in its place
12:10:28 <Peaker> nolrai66: I am just guessing (since I've not used DT..) if you care about the algorithm, you don't want funext, but I am guessing that if you want to show some value-equalities where the algorithm is irrelevant, funext could help?
12:10:57 <nolrai66> Peaker: I think so?
12:11:21 <ski> Peaker : one can use the terms "skolem" vs. "meta- / logic variable" to refer to specific implementation techniques. one could also use it just to keep track of whose (proponent's or opponent's) responsibility it is to choose a value for it
12:11:58 <Peaker> ski: "skolem" vs "metavariable" sounds nice/unconfusing :)
12:12:20 <shachaf> i,i "skolem variables, do not export!"
12:12:42 <nolrai66> OC, do not steal?
12:13:15 <ski> Peaker : btw, i would not say "existential" for `a' in `id x = (x :: a)'. "existential" is the type that is of shape `exists x. ..x..' (and "universal" (not "polymorphic") is the type that is of shape `forall a. ..a..' (the *values* of such a type are the polymorphic ones))
12:14:49 <ski> Peaker : in the logic programming context, "logic variable" is the established term (well, in concurrent logic programming, especially if you don't have much in the way of angelic nondeterminism, "dataflow variable" is more common)
12:15:52 <ski> Peaker : i think in the context of manipulating formal systems (type checkers, type inferencers, expression/proof translations, analyses, &c.) "metavariable" is the usual term
12:22:30 <alphonse23_> anyone have any luck getting yesod to work on openbsd
12:22:42 <alphonse23_> anyone know if I'm better off trying it on freebsd?
12:23:22 <nolrai66> ski: What's angelic nondeterminism?
12:26:18 <ski> nolrai66 : when the system tries to compute as many possible solutions to a problem as it can, until you're satisfied (demonic nondeterminism is when the system arbitrarily selects some solution, and you have to be satisfied with (iow prepared to handle) any one it might generate)
12:28:48 <nolrai66> Ah.
12:29:12 * hackagebot composition-extra 1.0.2 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.0.2 (athanclark)
12:29:20 <nolrai66> Intersting, so Angelic is sort of like the best posible, but not really.
12:33:59 <ski> nolrai66 : angelic means that as time progresses, the set of known solutions may only be enlarged. (so, generated solutions are "safe/lasting")
12:34:26 <Welkin> what is demonic then?
12:34:32 <breadmonster> Guys what on earth is a Tardis?
12:34:39 <Welkin> god damn it breadmonster 
12:34:42 <Welkin> are you trolling?
12:34:48 <breadmonster> Welkin: http://hackage.haskell.org/package/tardis
12:34:51 <Welkin> I just told you in the other channel
12:34:56 <breadmonster> I'm not, I thought this was a joke.
12:35:11 <ski> nolrai66 : demonic means that as time progresses, the set of known solutions may only shrink. (so generated solutions are provisional. you're ensured that all the true solutions (if there are any at all) are among the currently presented ones. at any time, some of those might be discovered to be false ones, and so retracted from the set)
12:37:00 <mniip> breadmonster, the package is a joke
12:37:16 <mniip> the name comes from a machine from the doctor who series
12:37:43 * mniip randomly mentions acme-timemachine
12:37:47 <breadmonster> mniip: Yeah, I know the series, I was wondering if you could use the package for any serious work.
12:38:13 <mniip> unlikely
12:38:47 <breadmonster> mniip: And your package is a joke too?
12:38:51 <mniip> yes
12:39:05 <breadmonster> Damn, I thought something productive could be done with them.
12:39:08 <Welkin> I sometimes think that benzrf just writes acem packages all day
12:39:14 <Welkin> acme*
12:39:19 <breadmonster> What exactly are acme packages?
12:39:23 <Welkin> joke packages
12:40:03 <cow_2001> what's a nice haskellian TUI library?
12:40:25 <cow_2001> Welkin: those are the best packages
12:41:17 <breadmonster> This being Haskell, I'm sure I can find *some* application for Tardis.
12:43:04 <Tuplanolla> "Acme is a Greek word denoting the best of something."
12:43:14 <Peaker> Tardis: Bottoms, bottoms everywhere!
12:43:29 <mniip> breadmonster, the sickest thing is that the STM timemachine works
12:43:37 <mniip> it just does, somehow
12:43:39 <breadmonster> STM time machine?
12:43:44 <dfeuer> edwardk, here are some thinkings for you: https://github.com/ekmett/machines/issues/50
12:43:44 <mniip> http://hackage.haskell.org/package/acme-timemachine-0.0.1.0/docs/Acme-TimeMachine-STM.html
12:47:48 <benzrf> Welkin: nah
12:47:53 <benzrf> Welkin: i'd never bee that productive
12:48:08 <benzrf> i've only written like 1 acme package and its a shitty one
12:49:13 * hackagebot coinbase-exchange 0.2.0.1 - Connector library for the coinbase exchange.  http://hackage.haskell.org/package/coinbase-exchange-0.2.0.1 (andrewrademacher)
12:51:13 <gamegoblin> Is there an IORef equivalent for StateT?
12:51:29 <breadmonster> How do you convert Int# to Int?
12:51:47 <adamse> breadmonster: I think the constructor is I#
12:52:03 <exio4> breadmonster: I# .. but
12:52:06 <breadmonster> ...but?
12:52:14 <breadmonster> gamegoblin: I don't think so.
12:52:49 <kadoban> gamegoblin: I think that'd be ST instead.
12:53:49 <benzrf> gamegoblin: youd have to use some kind of dictionary
12:54:06 <adamse> gamegoblin: State just hides the explicit threading of state, there are no actual mutable references in there
12:54:07 <benzrf> it would probably not be as efficient as ST
12:55:13 <breadmonster> kadoban: Except you can't get the state parameter out of ST.
12:55:42 <Twey> nolrai666: Re funext (and other notions of equality): lack of it damages compositionality, because you have to know in advance what notion of equality you're using.  You can think of it as analogous to parametric polymorphism in that sense: where parametric polymorphism lets you write code that works for any type, HoTT lets you write code that works for any notion of equality
12:55:47 <gamegoblin> benzrf: that’s what I was thinking. I could wrap some sort of dictionary and counter (where the refs just wrapped an int from the counter and a value).
12:56:14 <benzrf> yeah
12:56:27 <kadoban> breadmonster: I'm not sure what you mean.
12:56:28 <benzrf> i dont know /why/ you'd do that though :>
12:56:42 <gamegoblin> benzrf: stretching the limits of State ;D
12:57:07 <benzrf> that's unconstitutional
12:57:24 <gamegoblin> I’ll take it to the supreme court
12:57:37 <johnw> gamegoblin: the state could itself be an IO action, too
12:57:55 <johnw> StateT (IO a) m b
12:58:09 <gamegoblin> Good point. I guess I meant in non-IO land
13:04:13 * hackagebot hspec-core 2.1.8 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.8 (SimonHengel)
13:04:15 * hackagebot coinbase-exchange 0.2.0.2 - Connector library for the coinbase exchange.  http://hackage.haskell.org/package/coinbase-exchange-0.2.0.2 (andrewrademacher)
13:09:13 * hackagebot hspec-discover 2.1.8 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.8 (SimonHengel)
13:09:15 * hackagebot hspec 2.1.8 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.8 (SimonHengel)
13:17:12 <cow_2001> i'll go with vty-ui
13:26:57 * mniip pokes edwardk
13:28:27 <benzrf> satirical comic depicting a haskell bemoaning the fact that one of the libraries they are using wasn't created by edwardk
13:28:33 <benzrf> *a haskeller
13:29:25 <mniip> I wonder
13:29:32 <mniip> why are there no string parsing lenses
13:29:54 <benzrf> but mniip, there are
13:29:58 <benzrf> well, there are prisms, i mean
13:30:05 <mniip> lenslikes yes
13:30:25 <mniip> benzrf, I'd like to see please
13:30:34 <benzrf> @hackage lens-aeson
13:30:34 <lambdabot> http://hackage.haskell.org/package/lens-aeson
13:30:44 <mniip> that's not it
13:30:47 <benzrf> wait... maybe it was aeson-lens
13:30:48 <benzrf> one of those is the one u want, the other isnt
13:31:25 <benzrf> no yeah thats the one
13:34:18 <supki> mniip: what kind of string parsing optics?
13:34:52 <mniip> let's start by iso-ing span for a start
13:35:06 <mniip> then prisming isPrefixOf
13:36:56 <timemage> Hijiri, took a while, but we may have it sorted now.
13:38:11 <mniip> benzrf, here's the simplest example of why it's not what I'm talking about
13:38:16 <mniip> >>> set _Number 2 " 1"
13:38:18 <mniip> "2"
13:38:39 <benzrf> mniip: yes , so
13:38:43 <mniip> the whitespace is gone
13:38:58 <benzrf> im pretty sure that preserving whitespace violates prism laws
13:38:59 <mniip> it's a bad lens (traversal?) because it loses context
13:39:51 <supki> mniip: what's iso-ing span?
13:40:00 <benzrf> you cant have the parser and serializer separately accessible in one optic without that problem, mniip
13:40:10 <supki> mniip: Data.List.{prefixed,suffixed} are the prisms you are looking for, I think
13:40:33 <benzrf> mniip: certainly you could have a traversal or something that preserves whitespace, but then the instant you pull the parsed structure out of the lens context, you lose the ability to serialize it using the same device
13:43:15 <mniip> of course
13:44:25 <mniip> supki, 'span f' and 'uncurry (++)' form an isomorphism
13:45:16 <sccrstud92> can you construct a lens that pulls the relevant potion of the string out of the context, and composes that with the _Number prism?
13:45:17 <Peaker> one can run in the client, and one in the server! :)
13:45:26 <sccrstud92> would that preserve the whitespace?
13:45:45 <mniip> benzrf, hold on, I think I know why lens-aeson, in fact, is one violating lens laws
13:46:14 <benzrf> uh
13:46:19 <benzrf> mniip: aeson-lens was a violator
13:46:26 <benzrf> so lens-aeson was created
13:48:18 <Hijiri> I don't think span f . uncurry (++) is id
13:49:28 <Hijiri> for example, if f x = x == 5, (span f . uncurry (++)) ([1],[2])
13:49:38 <Hijiri> becomes ([],[1,2])
13:50:06 <mniip> benzrf, hmm
13:50:27 <mauke> (x, x++y)
13:50:39 <mniip> there's no set-get law
13:50:50 <benzrf> mniip: yes, prisms are not lenses
13:51:13 <Welkin> prism is an illegal data collection program run by the NSA
13:51:26 <mniip> Hijiri, hmm you're right
13:51:26 <ReinH> Cale: hey, remember that thing about L-systems? I found a generalization for non-deterministic L-systems.
13:51:27 <shachaf> There's a dual law.
13:51:51 <mniip> Hijiri, it's a lens then I guess
13:52:22 <Cale> ReinH: cool :)
13:53:16 <ReinH> Cale: https://gist.github.com/reinh/d95559824032542304bc non-deterministic L-systems are fixed points of f-coalgebras with non-determinism "effects" given by f.
13:54:29 <ReinH> Identity for deterministic, ZipList for non-deterministic
13:54:47 <Peaker> how expensive is "atomically $ readTMVar .." vs. "readIORef .." (for an almost-never-written variable)?
13:55:30 <ReinH> Well, not exactly ZipList, but it's a close approximation.
13:55:40 <Peaker> (I'm wondering if caching the result of Async.wait in an IORef would speed it up or not)
13:55:57 <Peaker> (for an Async that I wait upon many times)
13:56:48 <monochrom> readIORef is cheaper.
13:57:38 <monochrom> but I don't know the quantitative difference
13:58:04 <c_wraith> Peaker: why are you comparing readTMVar to read IORef?
13:58:30 <c_wraith> Peaker: TVar is the equivalent to IORef, not TMVar
13:58:54 <Peaker> c_wraith: there's no blocking anymore.. it'd be IORef (Maybe result)
13:59:04 <Peaker> (the cache exists only once the async is done)
13:59:15 * hackagebot wai-session 0.3.2 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.3.2 (StephenWeber)
13:59:17 * hackagebot DCFL 0.1.0.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.0.0 (dpandya)
13:59:21 <c_wraith> wouldn't an MVar with tryReadMVar be a better match?
13:59:46 <mniip> damn
13:59:55 <mniip> span-lens doesn't satisfy laws
14:01:17 <poincare101> Hi. This is my first time doing anything more than Project Euler problems with Haskell and I've built a small library ( http://hackage.haskell.org/package/DCFL-0.1.0.0). It's a constraint solver based on http://arxiv.org/pdf/1103.3240.pdf 
14:01:25 <poincare101> Could someone take a look at the code and give me some feedback?
14:01:28 <poincare101> it's only about 200 lines
14:04:26 <bergmark> poincare101: for the .cabal file, add ghc-options: -Wall under library, and add a source-repository section (that way `cabal get -s DCFL` clones the repo)
14:05:31 <bergmark> poincare101: having a changelog is nice too, name it CHANGELOG.md and att it under extra-source-files in .cabal
14:06:10 <johnw> mniip: what's a span-lens?
14:06:45 <bergmark> poincare101: you can add a test-suite section in .cabal to run tests with `cabal test' 
14:06:54 <mniip> johnw, trying to adapt the span function to a lenslike
14:07:02 <poincare101> bergmark: I don't have many of those yet
14:07:05 <mniip> and it won't satisfy any laws
14:07:11 <poincare101> bergmark: I have mostly only tested the pure functions
14:07:38 <nolrai66> bergmark: I could never get that to work. Got really bizzar errors in the code cabal generates.
14:07:40 <johnw> mniip: you mean, of type Lens' [a] ([a], [a])?
14:07:57 <bergmark> poincare101: one test is better than zero tests :) and if you have a test suite it's much easier to just add a new test case when something changes
14:07:58 <mniip> Lens [a] [b] ([a], [a]) ([b], [b])
14:08:02 <mniip> but yeah
14:08:04 <bergmark> nolrai66: get what to work?
14:08:15 <poincare101> bergmark: true, I'll add it
14:08:37 <johnw> mniip: it's hard to make something like that, because you'd have to guarantee that the lists being set have the same length
14:08:44 <poincare101> bergmark: could you take a glance at the code as well? I'm certain it works correctly but I'm not certain if it follows conventions
14:08:46 <mniip> it's not about length
14:08:54 <mniip> it's abut satisfying span's predicate
14:09:00 <johnw> ah
14:09:34 <mniip> set (_Span isSpace) ("x", "") -> "x"
14:09:37 <johnw> mniip: I ran into length problems trying to make a splice lens: https://github.com/jwiegley/notes/blob/master/gists/7716493/RangeLens.hs
14:09:50 <mniip> view (_Span isSpace) "x" -> ("", "x")
14:09:56 <bergmark> poincare101: was just looking
14:10:36 <mniip> johnw, the interesting part is that you can totally build proper law-conforming lenses on top of this ill-formed one
14:10:36 <bergmark> poincare101: if you prefix comments abover functions with a |, as in -- | Description it will show up on hackage as haddock documentation
14:10:54 <poincare101> bergmark: I think I've done that for most of the functions
14:11:14 <bergmark> i don't see it anywhere :o
14:11:30 <bergmark> only see normal comments
14:12:17 <poincare101> bergmark: oh I think I must not have checked in the code
14:12:21 <bergmark> poincare101: (\x -> x == 0.0 || x == 1.0) are you sure about the precision here? comparing floats without taking precision into account is usually bad
14:12:41 <poincare101> bergmark: I guess I could do some epsilon thing there
14:15:42 <poincare101> bergmark: how do I upload another tarball?
14:16:21 <bergmark> poincare101: you need to raise the version number and then do cabal sdist; cabal upload dist/the.tar.gz again
14:20:25 <bergmark> poincare101: foldr (&&) True = and
14:20:28 <bergmark> @type and
14:20:29 <lambdabot> Foldable t => t Bool -> Bool
14:20:59 <bergmark> poincare101: if you install and run hlint it will probably pick that up, and maybe other things as well
14:21:05 <poincare101> bergmark: so should I use "and" instead?
14:21:12 <flutterer> Anyone have time to answer a question from someone working through Real World Haskell?
14:21:29 <poincare101> flutterer: post the question - someone might answer
14:21:44 <bergmark> poincare101: it's clearer i think, you *usually* don't have to write explicit folds
14:22:08 <flutterer> I get this error:    No instance for (Eq (Eq a)) arising from a use of `=='     Possible fix: add an instance declaration for (Eq (Eq a))     In the expression: xs == []     In a stmt of a pattern guard for                    an equation for `list_len':       xs == []
14:22:26 <flutterer> for this code:   1 list_len :: [Eq a] -> Int   2 list_len xs   3         | xs == []      = 0   4         | otherwise     = list_len (tail xs) + 1
14:22:32 <flutterer> Sorry about the formatting.
14:22:39 <bergmark> flutterer: please use a pastebin, www.lpaste.net
14:23:37 <bergmark> poincare101: i also think it would be clearer to use (\(a,b) -> ... a ... b) rather than (\x -> ... fst x ... snd x)
14:23:53 <poincare101> bergmark: oh I didn't know you could do that
14:24:05 <poincare101> bergmark: I guess I did I just didn't realize it in context
14:24:20 <flutterer> http://lpaste.net/135872
14:24:59 <Tuplanolla> Use => instead of ->, flutterer.
14:25:07 <bergmark> flutterer: you are using Eq as a type here, but it's a type class
14:25:57 <bergmark> flutterer: you can't have a list containing Eq a, but you can have a list Eq a => [a] "a list of `a' where `a' has equality"
14:26:00 <flutterer> The distinction between -> and => is needed to distinguish between types and type classes?
14:26:05 <Tuplanolla> :t compare
14:26:06 <lambdabot> Ord a => a -> a -> Ordering
14:26:16 <Tuplanolla> Like that.
14:26:32 <bergmark> flutterer: the left hand side of => has type class constraints, the right hand side contains types
14:27:34 <bergmark> You could e.g. read the signature of compare as "If `a' implements `Ord`, then this function will take two `a's and give an Ordering"
14:27:42 <flutterer> Hmm, okay. Thanks. I missed that in my reading so far.
14:27:53 <flutterer> Is this the best channel to ask these kinds of question?
14:28:05 <Tuplanolla> There's also a beginner channel.
14:28:51 <bergmark> i don't know if it's the best but it's certainly allowed
14:32:13 <bergmark> poincare101: this function: getConstraintFromEl (ConstraintEl _ constraint) = constraint, you get that one for free, a record selector is also a function
14:32:47 <bergmark> poincare101: same for some other types...
14:33:22 <poincare101> bergmark: yes, I have removed all of those on the next commit
14:33:27 <Tuplanolla> Is there an abstraction of Socket already available somewhere?
14:34:22 <bergmark> poincare101: you should also not check *.hi files into the repo, they are build artifacts
14:52:47 <Tuplanolla> ReaderT and WriterT of course.
14:53:25 <uwap> is there a library for parsing wave fifo streams? all wave libraries I have seen don't parse them, because they are not complete or anything like this
14:54:01 <alphonse23_> how long should cabal update last on average?
14:56:08 <Tuplanolla> Some minutes.
14:57:08 <alphonse23_> it takes so long...
14:57:49 <programo> #compiler
14:58:33 <alphonse23_> it does print any messages/logs while it downloads the latest
14:58:48 <alphonse23_> at what point do you give up an assume it's not working?
15:04:04 <Fuuzetsu> @hoogle [(a, b)] -> ([a], [b])
15:04:04 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:04:04 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:04:08 <Fuuzetsu> oh
15:09:18 * hackagebot composition-extra 1.1.0 - Combinators for unorthodox structure composition  http://hackage.haskell.org/package/composition-extra-1.1.0 (athanclark)
15:10:05 <arkeet> what a curious package.
15:10:49 <cow_2001> when OverloadedStrings is activated, shouldn't [Char] unpack by itself when plugged into a function that demands Text?
15:10:59 <arkeet> no.
15:11:05 <arkeet> OverloadedStrings only changes string literals.
15:11:11 <arkeet> replacing "foo" with fromString "foo"
15:11:12 <cow_2001> ahhh!!! :D
15:11:14 <cow_2001> thanks!
15:11:16 <hpc> it's like Num
15:11:27 <hpc> if you write "5" it might be an Int or a Double
15:11:36 <hpc> but your Doubles are never going to just round themselves up or down
15:11:50 <arkeet> you have to use fromString (or perhaps something more specific like Data.Text.pack) if you want to do that.
15:14:18 * hackagebot texmath 0.8.2.2 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.2.2 (JohnMacFarlane)
15:14:34 <jle`> good ol john macfarlane
15:14:56 <jle`> john macreliable we call him
15:17:10 <nart> hi
15:17:52 <nart> is it possibile to run an action after the user has downloaded a file from the server, using scotty/wai ?
15:21:19 <athan> Is there a time-compat library, binding thyme and time? :s
15:28:41 <cow_2001> wooooo https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html
15:43:16 <breadmonster> Hello.
15:44:15 <marchelzo_> hi breadmonster
15:49:10 <Fuuzetsu> in filemanip, I spy matchTerms :: [MatchTerm] -> String -> Maybe (), what could be a reason for not using Bool there? It's a private function and its users use isJust
15:50:38 <Fuuzetsu> I notice it uses ‘fail’ a bunch with a message, is there an easy way to recover the message for debug?
15:51:05 <Fuuzetsu> oh, I suppose it makes it easy to change to Either String () and get the messages back
15:51:40 <alphonse23_> last stupid question of the day: Does anyone have any experience running yesod? How much ram should I have on the host computer?
15:52:08 <c_wraith> alphonse23_: I haven't used yesod, but unless your application needs a ton of memory, you'll probably need more to compile it than run it.
15:52:13 <kadoban> Does 'fail' in Either String () really result in Left "the string" ?
15:52:22 <alphonse23_> yes, that's the problem I've been running into I think
15:52:29 <Eduard_Munteanu> alphonse23_, depends on your load, of course
15:52:34 <alphonse23_> I was trying to set it up on a host computer with 250mb of ram
15:52:41 <Eduard_Munteanu> Oh.
15:52:43 <alphonse23_> but it wasn't working out well, when trying to run cabal update
15:52:55 <alphonse23_> and I think it's cause the host can't handle memory wise
15:53:01 <alphonse23_> how much memory should I have?
15:53:21 <Fuuzetsu> kadoban: sure
15:53:32 <Fuuzetsu> > fail "hello" :: Either String a
15:53:34 <lambdabot>  *Exception: hello
15:53:51 <Eduard_Munteanu> alphonse23_, well, don't compile it on that machine
15:54:00 <Fuuzetsu> well, in exception I suppose
15:54:07 <Fuuzetsu> good enough for me
15:54:40 <kadoban> Fuuzetsu: ? That isn't a Left "hello" though?
15:54:44 <alphonse23_> oh, maybe I can just compile it on another machine and move it on over.. sounds complicated.
15:54:47 <Fuuzetsu> kadoban: yes, you're right
15:54:54 <Fuuzetsu> it's just abuse of Either's fail, the types don't matter, my bad
15:55:14 <Fuuzetsu> I guess that should have been obvious from type of fail
15:55:29 <Eduard_Munteanu> alphonse23_, by default, you get a static executable so you don't even need Haskell dependencies
15:56:21 <kadoban> I think there is a specialized type like Either String, but specialized of course, where fail is like Left
15:56:34 <Eduard_Munteanu> alphonse23_, but you can try packaging it for your distro, if you like
15:56:52 <cdettmering> Hello everyone! I wrote my first Haskell program a while back and since have been trying to debug a space leak. I've used the profiling tools and all that, but can't make heads or tails as to what the problem is. Any advice?
15:57:02 <Fuuzetsu> kadoban: Error or something
15:57:19 <kadoban> Sounds right
15:57:22 <Fuuzetsu> cdettmering: well, you having profiling numbers and us having nothing, I don't think we can help you much
15:57:23 <Eduard_Munteanu> cdettmering, hi. What does the program do?
15:57:31 <alphonse23_> I'm trying to install it on openbsd 5.7
15:58:09 <cdettmering> It uses Markov chaining, to generate statistically similar text to a given input
15:58:17 <cdettmering> It's on GitHub if that helps?
15:58:18 <cdettmering> I don
15:58:32 <cdettmering> I don't have the profiling graphs anymore, not sure where I put them
15:59:20 * hackagebot deterministic-game-engine 0.2.0 - Simple deterministic game engine  http://hackage.haskell.org/package/deterministic-game-engine-0.2.0 (tgolson)
16:01:34 <Eduard_Munteanu> cdettmering, post a link to it
16:03:39 <cdettmering> https://github.com/cdettmering/artgen
16:05:29 <dzack> if you have a function which takes a filepath, is there an easy way to substitute stdout for a file?
16:05:43 <dzack> *FilePath
16:07:57 <Eduard_Munteanu> cdettmering, your Chainer.Histogram.fromList looks like a possible culprit
16:09:59 <Eduard_Munteanu> cdettmering, I'd use   fromList lst = Map.fromListWith (+) (zip lst [1..])   and replace Data.Map with Data.Map.Strict
16:09:59 <cdettmering> hmm
16:10:49 <cdettmering> that makes it non lazy i suppose?
16:11:16 <Eduard_Munteanu> cdettmering, it cannot be lazy, since number arithmetic is strict
16:11:39 <eds> http://lpaste.net/135867. I am trying to learning existential types. Can somebody explain me line 18.
16:11:47 <cdettmering> what's the benefit between data.map and data.map.lazy in this case then?
16:12:03 <Eduard_Munteanu> cdettmering, they're the same
16:12:17 <eds> my bad. line 29
16:12:54 <Eduard_Munteanu> eds, that's an empty ilne :)
16:13:21 <eds> data SBox = forall a. Show a => SBox a
16:13:26 <Eduard_Munteanu> cdettmering, Data.Map exports Data.Map.Lazy
16:13:36 <eds> probably 28 then. ^
16:13:38 <cdettmering> ah ok
16:14:51 <eds> Edward_Munteanu:
16:16:22 <Eduard_Munteanu> eds, it's the same as in the previous definitions, except there's a class constraint on the type variable
16:16:31 <Eduard_Munteanu> eds, anything in particular you find confusing?
16:17:08 <eds> Show a => SBox a
16:17:35 <eds> Does that mean that Sbox is a constructor and has one argument 'a'?
16:17:43 <eds> Edward_Munteanu
16:17:47 <Eduard_Munteanu> eds, sure
16:18:48 <eds> All the a's in the Sbox have an attribute show, that is what it means.
16:18:49 <Eduard_Munteanu> eds, also, it's 'forall a. Show a   =>    SBox a' indented for clarity
16:19:02 <Eduard_Munteanu> eds, yes
16:19:05 <eds> Oh yeah.
16:20:00 <Eduard_Munteanu> eds, whereas   data Box = forall a. ()    =>    Box a (a -> a) (a -> String)     (with a null class constraint)
16:20:56 <eds> Oh alright. That is what I was thinking about! and was confusing me.
16:22:13 <eds> Thanks
16:27:23 <Eduard_Munteanu> cdettmering, by the way, all Map are strict in the keys. Lazy vs. strict only matter for values.
16:27:39 <cdettmering> i see :)
16:27:57 <cdettmering> thanks :)
16:28:32 <c_wraith> and in either case, only strict to WHNF (or in the case of the keys, enough to fully order them)
16:34:21 * hackagebot deterministic-game-engine 0.2.1 - Simple deterministic game engine  http://hackage.haskell.org/package/deterministic-game-engine-0.2.1 (tgolson)
16:34:40 <c_wraith> > M.size $ M.fromList [('a', ()), ('b', ())]
16:34:42 <lambdabot>  2
16:34:45 <c_wraith> err
16:34:52 <c_wraith> > M.size $ M.fromList [(repeat 'a', ()), (repeat 'b', ())]
16:34:54 <lambdabot>  2
16:34:57 <c_wraith> there.  infinite keys!
16:35:31 <c_wraith> ..  Lookups don't work too well in that map, though
16:36:05 <c_wraith> I mean, failing ones do...
16:36:47 <c_wraith> > M.lookup "foo" $ M.fromList [(repeat 'a', ()), (repeat 'b', ())]
16:36:48 <lambdabot>  Nothing
16:37:00 <c_wraith> But it has the issue that successful matches take infinite time to verify
16:38:06 <nolrai66> So like real numbers!
16:38:25 <c_wraith> those too, yes. :)
16:50:21 <sebastianrkg> How would I derive ToJSON/FromJSON  instances for an existentially qualified heterogeneous list?
16:50:31 <sebastianrkg> eg. data ElementContainer = forall e. (Element e) => ElementContainer e
16:51:02 <sebastianrkg> I tried requiring that e is also an instance of ToJSON and FromJSON
16:51:25 <sebastianrkg> eg. data ElementContainer = forall e. (Element e, ToJSON e, FromJSON e) => ElementContainer e
16:53:03 <ski> sebastianrkg : what are the methods (with signatures) of `ToJSON' and `FromJSON' ?
16:54:09 <alphonse23_> haha, it worked. If anyone was following my questions earlier. 2048mb of ram runs cabal smoothly on an openbsd system. Where as 256mb of ram would freeze up.
16:54:16 <alphonse23_> nobody cares ofcourse, but I'm happy.
16:54:31 <c_wraith> sebastianrkg: I don't see how that's better than just using a [Value]
16:56:03 <sebastianrkg> c_wraith: Because if I say that elements contained in ElementContainers are instances of ToJSON/FromJSON, I can turn them into JSON, and then Elements in and of themselves can have other properties
16:56:28 <michaelt> sebastianrkg: it does look like you are reproducing the Value concept
16:56:46 <c_wraith> sebastianrkg: It just looks a lot like you're falling into the trap of thinking classes are like OO interfaces
16:57:05 <c_wraith> sebastianrkg: things always end up needing more code to do less, while more brittle, if you go that direction.
16:57:26 <michaelt> sebastianrkg: you can turn values into Json, and the have other properties ...
16:57:44 <michaelt> they have other properties, rather.
16:59:19 <sebastianrkg> c_wraith, the fundamental problem I would like to solve is that I want to maintain the state of a game world consisting of arbitrary elements that all have common methods, eg they can move, attack and be hurt
17:00:07 <ski> sebastianrkg : are you intending to add more constraints on `e' inside the definition of `ElementContainer' ?
17:00:18 <c_wraith> sebastianrkg: there are lots of ways to do that without involving any classes at all
17:00:36 <sebastianrkg> c_wraith: I don't see how I could have a highly general world-update function without using a heterogeneous list, because then I have to say too much about what the members of the world are
17:01:41 <sebastianrkg> ski, I really just want them to be JSONable for rendering and saving, unJSONable for reading in save files, and then to have the properties of an "element", which are the hp, attack and take damage functionalities
17:01:46 <nolrai66> I was never able to make the heterogeneous list technique work for that.
17:01:49 <jhaberku> sebastianrkg: Consider a record of fucntions. 
17:01:57 <ski> sebastianrkg : is `Element' your own type class ?
17:02:01 <nolrai66> Like you would think it would..and it just gets more an more complicated.
17:02:07 <c_wraith> sebastianrkg: you can't read save files like that, you know...
17:02:17 <c_wraith> sebastianrkg: You need a better design.
17:02:40 <sebastianrkg> c_wraith yes, Element is my own type class.
17:02:50 <sebastianrkg> or sorry, that was to ski
17:03:07 <c_wraith> sebastianrkg: No, I mean..  using FromJSON just plain won't work.  It never knows what type to unserialize something as.
17:03:10 <ski> perhaps you could show how it is defined ?
17:03:24 <c_wraith> sebastianrkg: It's much better if you use only a single type
17:03:32 <c_wraith> sebastianrkg: then you don't have that issue
17:03:45 <sebastianrkg> ah, I see c_wraith
17:04:40 * ski agrees that it would probably be better to not involve existentials into the mix
17:04:49 <michaelt> sebastianrkg: what really is wrong with having state be, say, a set of elements of one single type - with various constructors?
17:05:11 <ski> michaelt : .. or a record of functions, perhaps
17:05:23 <sebastianrkg> ski: http://lpaste.net/135875
17:05:34 <c_wraith> Records of functions are a bit more annoying to serialize - you need the serialization logic to be one of the functions
17:05:37 <michaelt> right, I'm just wondering where the pressure is coming from
17:06:11 <ski> c_wraith : *nod*
17:06:32 <sebastianrkg> michaelt, I envision this being a library where others may define the initial world state and any new Elements they wish to involve
17:06:43 <sebastianrkg> as such they wouldn't be able to edit my record
17:07:05 <c_wraith> sebastianrkg: in general, you should prefer data to classes.  It just cooperates with everything better.
17:07:58 <ski> sebastianrkg : i suppose you mean s/wouldn't be able to edit my record/wouldn't be able to edit my data type with various constructors/ ?
17:07:59 <michaelt> sebastianrkg: introducing a class is a fairly momentous action, really. 
17:08:24 <sebastianrkg> hmm, fair enough, I can see why from our conversation now. Is there any rule of thumb to when to involve classes?
17:08:27 <sebastianrkg> ski: yes
17:08:41 <ski> (i'm not sure why they would need to edit the record of operations .. that would be somewhat similar to needing to edit the type class)
17:10:40 <sebastianrkg> ski: Because then their new structure could implement the type class, and they can have all-new logic about how that Element functions with regards to how it takes damage, and what it targets in the world to effectuate damage
17:11:40 <sebastianrkg> whereas if it is a datatype, I would need the user to be able to pass in the logic as parameters upon construction... which I suppose isn't the end of the world either
17:12:49 <ski> sebastianrkg : anyway, you *could* perhaps use something like `data Element = MkElement { elKinematics :: Kinematics,elHitPoints :: HitPoints,elBounds :: WorldShape,elTraits :: Traits,elReact :: (Kinematics -> Kinematics,HitPoints -> HitPoints,WorldShape -> WorldShape,Traits -> Traits) -> Element,elAct :: World -> (ElementContainer,[EffectContainer]),elDead :: Bool}'
17:14:08 <ski> sebastianrkg : so, to make a new kind of element, you would just make a new operation which computes a new value of `Element', no need for them to change any datatype
17:14:39 <sebastianrkg> ski: right, okay. That makes sense. Thank you so much
17:14:54 <alphonse23_> what does cabal mean when it says this: Warning: The following packages are likely to be broken by the reinstalls:
17:15:13 <alphonse23_> does it mean the version numbers for the dependency installs don't match?
17:15:20 <michaelt> alphonse23_: well, first of all, what it says.
17:15:21 <ski> sebastianrkg : note that the serializing may complicate this (as c_wraith said). i'm not sure to what effect
17:15:42 <c_wraith> alphonse23_: it means that it will be replacing things those packages depend on - which will probably break them (changed binary interfaces, etc)
17:15:46 <alphonse23_> michaelt: ok fine, but why will they be broken.
17:15:50 <michaelt> alphonse23_: you should probably unregister those packages before installing. ...
17:16:38 <michaelt> alphonse23_: one possibility is that the new thing you want requires a new version of something, but the broken things depend on the one you're replacing. That sort of thing.
17:16:50 <alphonse23_> cabal build system comes with a lot of extra baggage that a lot of other build system don't come with... :/
17:16:54 <ski> sebastianrkg : btw, note that, if you look closely, `Element' is a recursive data type, so that every element will have to be infinite. however, you can just think of it as the `elReact' field containing a function that will compute the new version of the element, under the indicated change
17:17:57 <michaelt> alphonse23_: it's not so hard once you get the hang of it. Maybe it's a little manual, so to speak. There are new schemes abroad anyway, like stack.
17:18:28 <c_wraith> alphonse23_: like warning you when you're about to break things you've already installed?  I mean, I know some people enjoy discovering that at runtime, but I'm not one of them.
17:18:29 <ski> sebastianrkg : also, you could make a "smart" constructor which takes all the fields except `elDead', and constructs a new `Element' record with the fields filled in, and where `el_dead = elHitPoints <= 0', to mimic the default definition
17:18:33 <alphonse23_> I've been looking at stack
17:18:35 <michaelt> haha
17:19:26 <c_wraith> alphonse23_: stack's solution is to sandbox everything.  It's a good approach.  cabal supports it too.
17:19:30 <ski> (sebastianrkg : an alternative would be to move `elDead' out of the whole thing, making it a standalone function defined by `elDead = (<= 0) . elHitPoints')
17:19:36 <sebastianrkg> ski: Okay, right, that would mimic the way el_dead functions
17:19:37 <michaelt> alphonse23_: have you started to use sandboxes?
17:19:41 <sebastianrkg> that would make sense too
17:19:50 <alphonse23_> yes. cabal sandbox init
17:20:52 <sebastianrkg> ski: okay so looking around a bit, it seems like serializing functions is not just difficult but actually impossible and even the CloudHaskell package has to hack around this problem with a datatype that points to stored procedures
17:20:54 <ski> sebastianrkg : anyway, as i said, i'm not sure one could get working (extensible) serialization with this scheme. at least it's something to experiment with
17:20:59 <sebastianrkg> is there some other solution to doing so?
17:21:14 <sebastianrkg> okay, yeah ski that seems to match up with what I found
17:21:22 <michaelt> alphonse23_: well, one path with a sandbox is the obvious 'cabal sandbox delete' and starting over.  It is really the builds times that are a problem in Haskell, not cabal install and that stuff
17:21:53 <ski> sebastianrkg : you would have to make a field for serializing (as c_wraith said). this *might* work
17:22:33 <michaelt> alphonse23_: but, when it says 'these will be broken ...' you can also unregister them and then install whatever you like of what went, together with your new things
17:22:34 <sccrstud92> is it possible for data Choose a = One a | Two a to have a lawful applicative instance?
17:22:37 <alphonse23_> yes, the build times in haskell are pretty horrendous compared to other languages. 
17:22:45 <alphonse23_> also the memory requirements.
17:23:16 <michaelt> alphonse23_: you unregister from the sandbox with 'cabal sandbox hc-pkg unregister bad-version-0.1'
17:24:03 <michaelt> alphonse23_: you mean the memory requirements for building? 
17:24:13 <alphonse23_> yes
17:24:26 <michaelt> alphonse23_: oh yeah, I see from above,you must
17:24:27 <alphonse23_> I couldn't get cabal to do anything on a vm with 256 mb of ram
17:24:33 <alphonse23_> had to bump it up to 2 gb
17:25:12 <sccrstud92> alphonse23_: how much swap space did u have?
17:25:19 <alphonse23_> I don't know
17:25:24 <OutlawStar> anyone know which package the operator ".~" is defined in? currently seeing it in haskell charts package.
17:25:24 <alphonse23_> I don't even really know how to set swap
17:25:25 <sccrstud92> were u running the tests?
17:25:27 <michaelt> alphonse23_: yeah I think people complain about that more than when I was first using Haskell; the builds are increasingly amazingly complicated. 
17:25:30 <ski> sccrstud92 : `instance Applicative Choose where pure = One; One f <*> One x = One (f x); One f <*> Two x = Two (f x); Two f <*> One x = Two (f x); Two f <*> Two x = Two (f x)' ?
17:25:31 <sebastianrkg> ski: Even if I had a field to describe how to serialize, it would be very difficult to explain how the logic of any arbitrary function should work knowing only its parameters
17:25:44 <michaelt> OutlawStar: that's a standard lens operator, "set"
17:26:03 <OutlawStar> michaelt:  "Ah ok thx"
17:26:08 <sccrstud92> ski: how many instances are possible?
17:26:08 <Fuuzetsu> @hoogle (m a, m b) -> m (a, b)
17:26:08 <lambdabot> No results found
17:26:12 <michaelt> @type _1 .~ 'a'
17:26:13 <lambdabot> Field1 s t a Char => s -> t
17:26:37 <edwardk> :t both id
17:26:38 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => r (f b) (f b) -> f (r b b)
17:26:40 <michaelt> > ('b',17) & _1 .~ 'a'
17:26:42 <lambdabot>  ('a',17)
17:26:43 <ski> sccrstud92 : is this homework ?
17:26:49 <edwardk> Fuuzetsu: ^- using lens
17:26:50 <michaelt> OutlawStar: like so ^^^
17:26:51 <sccrstud92> ski: i wish
17:26:58 <ski> sccrstud92 : changing the last one to `Two f <*> Two x = One (f x)' also seems to be possible
17:27:00 <edwardk> :t bimap id id -- using bifunctors
17:27:02 <lambdabot> Bifunctor p => p b d -> p b d
17:27:05 <Fuuzetsu> edwardk: no lens allowed on this project (yet!)
17:27:06 <edwardk> er
17:27:10 <ski> sccrstud92 : and obviously you can swap the roles of `One' and `Two'
17:27:11 <edwardk> :t bitraverse id id -- using bifunctors
17:27:12 <lambdabot>     Not in scope: ‘bitraverse’
17:27:12 <lambdabot>     Perhaps you meant one of these:
17:27:12 <lambdabot>       ‘itraverse’ (imported from Control.Lens),
17:27:17 <sccrstud92> ski: i was curious about that as well, but i would have to work it out with the laws
17:27:17 <edwardk> :t Data.Bitraversable.bitraverse id id -- using bifunctors
17:27:19 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable t) => t (f c) (f d) -> f (t c d)
17:27:24 <ski> sccrstud92 : here's some homework for you : prove the laws
17:27:41 <ski> (btw, the `Functor' instance is obvious)
17:27:45 <edwardk> :t Data.Bitraversable.bisequence
17:27:46 <lambdabot> (Monad m, Data.Bitraversable.Bitraversable t) => t (m a) (m b) -> m (t a b)
17:27:51 <edwardk> ok, its in there directly
17:27:54 <sccrstud92> ski: hence I didnt ask =)
17:29:08 <jle`> sccrstud92: you might notice that Choose a ~ (Bool, a)
17:29:13 <sccrstud92> i did
17:29:17 <jle`> so that's just Writer
17:29:32 <jle`> instance Monoid w => Monad (w,)
17:29:45 <jle`> instance Monoid w => Monad (Writer w)
17:29:52 <sccrstud92> so it depends on how many monoid instances there are for bools
17:29:52 <jle`> so you have an instance for every possible monoid in w
17:29:56 <jle`> yea
17:30:02 <ski> sccrstud92 : `Choose a' is (modulo bottoms) iso to `(Bool,a)'. `(m,)' is applicative given `Monoid m'. there's different possible monoids on `Bool'
17:30:50 <jle`> there are four that i know of
17:30:56 <jle`> but there might be more
17:31:05 <sccrstud92> four instance of monoid for Bools?
17:31:18 <sccrstud92> i only know of and-ing and or-ing
17:31:19 * ski thinks there's more than four
17:31:24 <ski> er
17:31:28 <jle`> there's also xoring
17:31:28 <ski> *no* more
17:32:29 <jle`> so you can choose mempty = True, and True <> _ and _ <> True are determined, so you have two choices for the True <> True case --- True or False
17:32:50 <jle`> and then you can choose mempty = False, and False <> _ and _ <> False are determined, so you have two choices for the False <> False case --- True or False
17:33:14 <sccrstud92> doesnt True <> True have to be True because mempty is True?
17:33:16 <ski> jle` : the `False <> False' case for the former, and the `True <> True' case for the latter
17:33:26 <jle`> ski: ah yeah, you're right :)
17:33:30 <jle`> yes sccrstud92 heh
17:33:38 <sccrstud92> okay u just typoed
17:33:41 <michaelt> OutlawStar:  if you find .~ too alarming, before you get used to it, you can just use set
17:33:42 <michaelt> > set (_1 . _2) True ((12,False), "hello")
17:33:44 <lambdabot>  ((12,True),"hello")
17:34:32 <jle`> sccrstud92: so applied to your type, you can chose pure = One and then you have two options for Two f <*> Two x
17:34:44 <jle`> sccrstud92: or you can chose pure = Two and you have two options for One f <*> One x
17:35:17 <ski> jle` : so i suppose `True' is a neutral element of `xnor'
17:35:51 <alphonse23_> alrighty! got yesod working on openbsd 5.7
17:35:56 <alphonse23_> if anyone cares to see it: http://82.221.49.2:3000/
17:36:06 <alphonse23_> now I shall build something in yesod
17:36:49 <sccrstud92> alright that all makes sense. my type actually has three constructors with the type var, but i wanted a better understanding of the two constructor case.
17:36:50 <ski> (all three comparands in `xor (not b0) b1 = not (xor b0 b1) = xor b0 (not b1)' being `xnor b0 b1')
17:37:09 <michaelt> alphonse23_: good work!
17:37:12 <jle`> sccrstud92: btw you asked for Applicative but i gave the answer in terms of Monad (w,) heh.  but i'm sure you get the picture that i meant Applicative (w,)
17:37:27 <sccrstud92> jle`: of course
17:37:27 <ski> sccrstud92 : `Choose a = a + a + a' ?
17:37:36 <jle`> but this means that you now know that Choose has at least four Monad instances too :)
17:37:46 <sccrstud92> jle`: right
17:38:20 <arkeet> jle`: https://oeis.org/A058153
17:38:33 <sccrstud92> ski: actually its iso to Choose a = a + Int + (a, Int) + a
17:38:39 <jle`> thank you arkeet :)
17:38:41 <sccrstud92> so there will be tons of instances
17:38:52 <sccrstud92> not convinced of there usefullness though
17:39:35 <sccrstud92> i might not even need the instance, but thinking about it led me to thinking about the a + a case, which i hadnt seen before
17:39:53 <sccrstud92> their*
17:43:02 <michaelt> alphonse23_: your website doesn't work, I tried to upload a document like the form says I can. The styling is kinda lame too of course ....
17:45:55 <jle`> heh that's page that comes included with yesod framework
17:46:09 <jle`> like a hello world
17:46:14 <michaelt> jle`: yeah, i know... 
17:46:40 <sccrstud92> i took the "...." to indicate sarcasm, which is why i didnt say anything
17:46:46 <michaelt> jle`: I was just seeing what it could do...
17:47:15 <michaelt> sccrstud92: oh, sorry all, it was terribly formulated. 
17:54:29 <meretrix> Hi, how can I write a type instance that works for an empty list in the following example?
17:55:18 <meretrix> http://lpaste.net/135877
17:55:48 <c_wraith> meretrix: what do you want it to even do?
17:55:49 <jle`> meretrix: maybe "This is an empty list" ?
17:56:28 <c_wraith> meretrix: oh, I think I see..
17:56:31 <solrize> @seen tekmo
17:56:31 <lambdabot> TEx/\/\O
17:56:53 <solrize> @tell tekmo i like the typography  http://plg.uwaterloo.ca/~cforall/
17:56:53 <lambdabot> Consider it noted.
17:57:02 <meretrix> I want it to print "This is an Int" if the type is [Int]
17:57:26 <c_wraith> meretrix: does http://lpaste.net/135878 do what you want?
17:57:27 <meretrix> I'd like to write "foo [] = foo (undefined :: a)"
17:57:49 <jle`> ah
17:57:50 <meretrix> Ah, yes!
17:57:53 <jle`> you need ScopedTypeVariables
17:57:59 <jle`> or, does it work without scoped type variables too?
17:58:23 <c_wraith> You *can* write it without scoped type variables, but it requires an ugly helper function to convert types for you
17:58:30 <c_wraith> It's way easier with it.
17:58:45 <c_wraith> Especially since you don't need the quantifier to use ScopedTypeVariables in instance definitions.
17:58:50 <c_wraith> (which I always thought was odd)
17:58:53 <jle`> if you {-# LANGUAGE ScopedTypeVariables #-}, your thing should work out of the box, meretrix 
17:59:08 <meretrix> jle`: Yes, ScopedTypeVariables is needed.
17:59:09 <jle`> c_wraith: i think it's because there's no meaningful place to put it?
17:59:19 <c_wraith> jle`: probably.
17:59:24 <jle`> er, no not-awkward place
17:59:28 <c_wraith> anyway, you could write it without scoped type variables.
17:59:31 <jle`> so yeah, it's a little weird
17:59:40 <Gurkenglas> Why does https://hackage.haskell.org/package/JuicyPixels-3.2.5.2/docs/Codec-Picture.html define pixelMap with its (Pixel a, Pixel b) restriction instead of defining a functor instance? I would have liked to transform the pixel values into the information contained within.
18:00:18 <jle`> Gurkenglas: because there's no concrete representation of a pixel in an Image
18:00:28 <jle`> you can't store arbitrary types
18:00:38 <c_wraith> jle`: http://lpaste.net/135879
18:00:39 <jle`> you can't have an Image Bool, for example
18:00:55 <jle`> the pixel doesn't actually exist in-memory literally, it's abstracted away
18:01:05 <nolrai66> What is Image then?
18:01:18 <jle`> so if there's no way for juicypixels to know how to "store" or "present" the a in Image a, then it can't really map or store it
18:01:43 <jle`> nolrai66: it's an abstracted representation of an image, parameterized by an abstract "type of pixel"
18:03:02 <jle`> it stores its data in a Data.Vector.Storable vector internally, but the storage scheme is unique for every type of pixel
18:03:16 <nolrai66> Ah.
18:03:50 <Gurkenglas> I'm about to write (convolute :: (Pixel a, Num a) => [((Int, Int), Double)] -> Image a -> Image a). Do you recommend something better than pixelAt in the implementation?
18:03:53 <jle`> for example for PixelRGB8, it stores rgb channel data in chunks of 3 elements in the vector per pixel
18:04:21 <jle`> with Word8's
18:04:49 <jle`> pixelAt might be the best way
18:05:05 <jle`> because the data of a single pixel is distributed over several elements in the internal vector
18:05:31 <jle`> for example, pixelMap with a (PixelRGB8 -> Pixel8) will actually change the size of the internal vector
18:06:01 <jle`> i only know this because i'm working with juicy pixels right now, heh
18:06:16 <michaelt> meretrix: hm, the obvious way of completing c_wraith's version gives "This is a Double" for f ([] ;; [Double]) which is what you asked for, but it seems a little odd...
18:06:37 <michaelt> ... for f ([] :: Double) rather. 
18:06:54 <c_wraith> michaelt: I just assume it was sample code that makes little sense standing in for a more complicated case where it makes more sense. :)
18:06:57 <nolrai66> ..that won't type check will it?
18:07:09 <hpc> > [] :: Double
18:07:11 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘[t0]’
18:07:11 <lambdabot>      In the expression: [] :: Double
18:07:27 <michaelt> c_wraith: yeah, of course, I was just trying to imagine more complicated cases. 
18:07:54 <michaelt> nolrai66: no, I went from one mistake to another. 
18:08:19 <c_wraith> michaelt: there are lots of times you want to know what the leaf type of something is, in some sense.  That's what it looks like to me.
18:11:42 <michaelt> c_wraith: yes, I was just thinking about the cases where something like an appeal to 'undefined :: T' is essential
18:12:13 <michaelt> c_wraith: like sizeOf (undefined :: Int) 
18:12:26 <c_wraith> michaelt: well, we know how to do those better now. :)
18:12:53 <michaelt> c_wraith: do we? I was going to ask about an extension I heard mentioned in the past
18:13:01 <michaelt> or what are you thinking 
18:13:07 <c_wraith> michaelt: too bad Foreign can't adopt the saner interfaces. :)
18:13:40 <c_wraith> michaelt: instead of having something like this -   class Storable a where sizeOf :: a -> Int
18:13:57 <c_wraith> michaelt: use something like...   class Storable a where sizeOf :: proxy a -> Int
18:14:12 <c_wraith> michaelt: (note the lower case p in proxy)
18:14:24 <michaelt> yes
18:15:02 <c_wraith> It's a data type you unconditionally can't use in any other way than using the type 'a'.  So no chance of pattern-matching on undefined, for instance.
18:15:31 <c_wraith> ...  except for seq.  But hopefully no one seqs a value with a type like that. :)
18:15:34 <michaelt> the extension I was thinking of was different, now that I think of it, it was to treat (:: Int) as id :: Int -> Int or the like.
18:16:01 <c_wraith> michaelt: oh, were you thinking of explicit type application?  That's useful in some related situations
18:17:42 <michaelt> c_wraith: this would just be a function, but maybe that's what it's called. let me see if can find it. lennart a. was proposing to implement it....
18:24:36 <solrize> http://lpaste.net/135880  anyone see how to optimise this w/o changing the algorithm?  it's a lang benchmark and is about 3.5x slower than straightforward c++.
18:26:46 <michaelt> import Math.NumberTheory.Primes
18:27:36 <michaelt> solrize: is it really faster with that explicit unboxing and so on? 
18:27:49 <solrize> yeah not by a huge amount but it helps
18:28:33 <solrize> also i unboxed everything with the idea that it should generate about the same code as a c compiler, but nope
18:35:16 <michaelt> solrize: is this the way the benchmark is defined? so you cant use the fact that some numbers are already known to be prime? Or anyway, is that what the c++ is doing?
18:35:41 <solrize> michaelt the c++ code is the same as the haskell code except it's c++, more or less
18:36:02 <solrize> i coded a better algorithm in c++ as well, and it was about 30x faster :)
18:37:13 <solrize> see: https://bjpelc.wordpress.com/2015/01/10/yet-another-language-speed-test-counting-primes-c-c-java-javascript-php-python-and-ruby-2/
18:38:24 <solrize> he also did a haskell version
18:38:25 <solrize> https://bjpelc.wordpress.com/2015/01/12/haskell-yet-another-language-speed-test/
18:38:45 <y> solrize: the code probably would have got a better improvement by rewriting the (allocating, guessing, I haven't checked Core) print . length . filter isPrime $ [2..limit] into a loop
18:38:52 <y> (it should go away though)
18:39:06 <solrize> hmm
18:39:12 <solrize> interesting
18:39:32 <solrize> but, i think it wouldn't make much difference.  i changed isPrime to "const True" so it would generate and count that list, and it was very quick
18:39:38 <solrize> i think all the time is being spent in isPrime
18:39:55 <y> solrize: did you try -fllvm -O2 ? 
18:40:14 <solrize> trying now
18:41:04 <solrize>     Warning: Couldn't figure out LLVM version!
18:41:04 <solrize>              Make sure you have installed LLVM
18:41:05 <solrize> hmm
18:41:33 <solrize> on the commandline: Warning:
18:41:34 <solrize>     The -fvia-c flag does nothing; it will be removed in a future GHC release
18:41:34 <solrize> heh
18:42:27 <solrize> installed llvm, running
18:44:43 <solrize> speed basically unchanged
18:46:59 <y> hm
18:47:46 <michaelt> yeah the obvious loop isn't helping 
18:47:55 <michaelt> llvm isn't helping here
18:48:07 <y> the core looks pretty tight
18:48:09 <alphonse23_> michaelt: I didn't even know you could submit files
18:48:17 <alphonse23_> what do I have to do to get it to accept files?
18:48:54 <michaelt> alphonse23_: Oh, I don't know. I just thought I'd try it for your amusement if it worked. 
18:49:04 <alphonse23_> oh, didn't work
18:49:08 <alphonse23_> didn't even see it there
18:49:23 <michaelt> yeah, it sent me to a non-page.
18:49:47 <wrengr> is there a reference anywhere on the actual memory layout/cost of GADTs vs ADTs?
18:49:48 <alphonse23_> and it crashed too, after about 10 minutes
18:50:05 <athan> Anyone here use cryptonite productively?
18:50:08 <alphonse23_> or it didn't crash, but the page wouldn't come up
18:50:29 <athan> I'm trying to create an empty `Digest` result / pattern match on the newtype over ByteArrays
18:50:40 <athan> but can't because module ain't exposed :c
18:50:56 <solrize> wrengr, i'd expect same layout?  gadt's are different types than adt's but the data constructors work out about the same way, i'd have thought
18:51:00 <Eduard_Munteanu> wrengr, I don't think there's a difference
18:51:35 <wrengr> even with typeclass-constrained existentials?
18:51:41 <michaelt> alphonse23_: oh, it's obvious for starters, it's sending me to localhost http://localhost:3000/#form
18:52:02 <athan> wrengr: erasure, maybe? :s
18:52:40 <Eduard_Munteanu> wrengr, not any different from other uses of existentials or typeclasses
18:52:53 <alphonse23_> yea, the address should point else where.
18:53:35 <Eduard_Munteanu> wrengr, just plain dictionary passing
18:54:11 <michaelt> alphonse23_: do you see the bit about attaching a file? it looks like you at least might be able to see what happens next
18:54:33 <wrengr> Eduard_Munteanu: sure, but a lot of times the dictonaries can be inlined or inferred on location, so they don't need to be passed
18:54:56 <wrengr> Eduard_Munteanu: basically, I'm wondering how smart GADTs are about erasing the dictionary-passing stuff
18:55:40 <c_wraith> wrengr: existentials with classes more or less store a pointer to the class dictionary inside them.  So call it an extra word of use.  That doesn't matter whether it's a GADT existential or not.
18:56:13 <wrengr> c_wraith: for the existentials, sure; but I'm wondering about both existential and non-existential cases
18:56:17 <erisco> what is the simple regex library?
18:56:22 <erisco> regex-tdfa is super complicated
18:57:40 <c_wraith> wrengr: If class constraints appear in the constructor signature in a GADT, it will store a pointer to the instance it was provided.  Otherwise, space use will be the same as a normal ADT with the number of fields in that constructor.
18:58:32 <solrize> wrengr, hmm, yeah i guess there's something like a typeclass dictionary, but that's as usual?
18:58:38 <michaelt> erisco: I think they all have similar api's, which for me at least are extremely confusing because of the types...
18:58:45 <Eduard_Munteanu> GADT existentials and ADT existentials should be equivalent.
18:59:21 <c_wraith> wrengr: it's more or less a pointer for each argument, and class constraints count as arguments in a GADT
18:59:46 <shachaf> GHC calls types that have constraints "existentials" even if there are no variables that are existentially quantified.
18:59:59 <shachaf> By constraints I mean the dual of constraints. "endowments" or whatever you like to call them.
19:00:01 <c_wraith> shachaf: I didn't realize that.  Good to know.
19:00:27 <c_wraith> shachaf: many people call them "proofs", I think.
19:00:38 <c_wraith> or maybe "evidence"?
19:00:46 <shachaf> "witnesses", maybe?
19:00:50 <shachaf> But that's the value-level things.
19:00:50 <c_wraith> there we go.
19:01:05 <shachaf> In show :: Show a => a -> String, "Show a" is a constraint.
19:01:17 <wrengr> shachaf: in mathematics at least, "endowments" are often called equipment
19:01:21 <shachaf> In data T = forall a. Show a => T a, "Show a" is the dual of a constraint.
19:01:32 <shachaf> Hmm, I guess.
19:01:34 <Eduard_Munteanu> shachaf, like   data Foo f a where Foo :: forall f a. Show (f a) => f a -> Foo f a  ?
19:01:48 <wrengr> shachaf: e.g., a Such-and-Such equipped with a blah-blah
19:01:52 <shachaf> Right.
19:02:02 <shachaf> Anyway, GADTs are just syntax for things that GHC can do with its ordinary syntax.
19:02:26 <shachaf> The extensions you need are ExistentialQuantification and something that gives you equality constraints (e.g. TypeFamilies).
19:02:43 <wrengr> notably, the extra stuff isn't called equipment if it's "part of the object" (e.g., any given measureable space can give rise to multiple measure spaces, so the measure isn't equipment)
19:02:56 <erisco> wow and then you get (MatchOffset, MatchLength)
19:03:02 <erisco> so you have to go back into the string you're matching on
19:03:04 <erisco> to actually get the match out
19:03:08 <erisco> this is bloody painful
19:05:19 <Eduard_Munteanu> Even GHC's internal representation of GADTs involves type equality constraints.
19:05:29 <ttt_fff> does haskell provide anything nice for CRDTs ?
19:05:48 <Eduard_Munteanu> ttt_fff, CRDTs?
19:06:00 <ttt_fff> https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type
19:06:38 <alphonse23_> should I run yesod behind nginx. anyone know. I thought warp was like a nginx replacement ...
19:07:13 <pavonia> erisco: I use regex-compat which is quite easy to use
19:07:50 <erisco> pavonia, I'll hash it out with this I guess :P
19:08:03 <erisco> doing regex on String doesn't work well with their API idea I guess
19:08:11 <erisco> if you had something indexable it'd make much more sense
19:08:23 <Eduard_Munteanu> alphonse23_, nginx/Apache proxying to Warp is a common setup.
19:09:41 <Eduard_Munteanu> http://www.yesodweb.com/book/deploying-your-webapp
19:09:56 <alphonse23_> yeah, I was just reading that.
19:12:59 <Eduard_Munteanu> alphonse23_, anyway, if you're already hosting a HTTP server (possibly doing caching), it makes sense to integrate Warp with it.
19:13:57 <Eduard_Munteanu> Not sure Warp is anything near nginx/Apache feature-wise.
19:15:24 <ClaudiusMaximus> solrize: on my system, your haskell lpaste takes 3m41s with ghc -O2, the C on the blog post takes 3m44s with gcc -std=c11 -O2 -lm
19:15:59 <solrize> ??????  
19:16:06 <y> pretty much the same as ClaudiusMaximus here
19:16:56 <solrize> ClaudiusMaximus, y, try this  http://lpaste.net/135882  
19:17:09 <solrize> did i screw up and do a better algorithm by accident?
19:17:13 <ClaudiusMaximus> solrize: ghc 7.10.1 , gcc 4.9.2
19:17:14 <solrize> lemme try his code
19:17:47 <solrize> hmm, i have ghc 7.8.3, gcc 4.7.2
19:18:03 <solrize> do you think 7.10 is radically better than 7.8?  anyway i'll try his c code
19:18:05 <y> I have ghc 7.8.3 and 4.9.2 
19:18:10 <perebor> what is more efficient with hmatrix: 4x4 Real matrix multiplication or 2x2 Complex matrix multiplication
19:18:14 <julianleviston> Is a list an instance of the sequence monad?
19:18:48 <c_wraith> where did you see the term "sequence monad"?
19:18:57 <julianleviston> if so, can I apply sequenceless operations on instances of the sequence monad?
19:19:07 <julianleviston> c_wraith:  good question. one sec
19:19:31 <julianleviston> c_wraith: in numerous places… most recently https://www.haskell.org/onlinereport/prelude-index.html
19:19:41 <solrize> running
19:19:59 <c_wraith> julianleviston: do you just mean the sequence function?
19:20:18 <solrize> 30 seconds on this fairly fast box, vs. about 1min 45sec for the haskell code
19:20:26 <c_wraith> julianleviston: the sequence function works with all types that are instances of Monad.  List is among them.
19:20:43 <solrize> also his c code is about the same speed as my c++
19:20:57 <dramforever> julianleviston: didn't see that :(
19:20:59 <julianleviston> c_wraith: I’m wondering what form function arguments are.
19:21:16 <dramforever> julianleviston: what are you refering to?
19:21:27 <Eduard_Munteanu> :t sequence
19:21:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:21:31 <c_wraith> > sequence [[1,2],[3,4],[5,6]]
19:21:32 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
19:21:51 <Eduard_Munteanu> :t Control.Monad.sequence
19:21:51 <dramforever> julianleviston: ^ that?
19:21:52 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:22:02 <dramforever> lol bbp
19:22:39 <y> solrize: which box? this is a FX 6100 and the C code is faster by just 2s (and I just ran the test once, I wouldn't be surprised if running it a few times and averaging would end in the same number? (2:05 for the haskell code, 2:03 for the C version in that page, yours is 2:03) 
19:23:05 <solrize> i7-3770, i've run all these versions lots of times with very little variation
19:23:07 <c_wraith> > sequence [(*2), (+3), negate] 5
19:23:08 <lambdabot>  [10,8,-5]
19:23:26 <solrize> oops i have to go afk for a few minutes but will bbl
19:23:29 <solrize> cya in a few
19:23:47 <julianleviston> ah I’m not sure. What I’m wondering is… say you have this: (+) 1 2 why do I need to use a different function sum to sum a list of two items sum [1,2] and is there a relationship between them? Can I change one to the other and vice-versa? One uses monads (the list) but the other doesn’t, right? One has sequence, the other doesn’t?
19:24:08 <dramforever> list is a type that happens to be a monad
19:24:15 <dramforever> *happens*
19:24:19 <julianleviston> sorry for my imprecision.
19:24:35 <zachk> > foldr (+) 0 [1,2] 
19:24:36 <lambdabot>  3
19:24:39 <dramforever> don't put monads onto everything, there isn't one here
19:24:56 <julianleviston> dramforever: sorry I thought there had to be one to specify the order of the list.
19:24:59 <zachk> like that julianleviston 
19:25:06 <dramforever> no way
19:25:08 <julianleviston> zachk: a different reliationship.
19:25:11 <zachk> oh yes there is the List monad 
19:25:17 <zachk> what did you have in mind?
19:25:42 <julianleviston> zachk: as in… pulling the sequenced list into a set of two arguments somehow? So I take them out of sequence, and put them into choiceless execution
19:25:46 <dramforever> zachk: (s)he is asking why sum uses the list monad
19:25:49 <julianleviston> he.
19:25:55 <julianleviston> dramforever: am I?
19:26:01 <dramforever> oh?
19:26:09 <julianleviston> dramforever: I don’t know if I am.
19:26:18 <dramforever> "One uses monads (the list) but the other doesn’t, right?"
19:26:28 <zachk> are you just arithmetically summing the list, or looking for something fancier? 
19:26:43 <julianleviston> zachk: it’s a general question framed with this specific example. 
19:27:16 <julianleviston> zachk: I’ve often wanted to pull two arguments out of a list and into a function that takes two arguments. It feels a bit monadic to me, but I don’t know at all.
19:28:00 <dramforever> it's not monadic at all
19:28:04 <julianleviston> zachk: a pipe between the choiceless world of arguments, and the choiced world of a list.
19:28:09 <julianleviston> dramforever: ok, apologies.
19:28:15 <dramforever> :)
19:28:22 <julianleviston> zachk: is there such a “pipe”?
19:29:16 <zachk> so you want: function :: (a -> a -> a) -> [a] -> a ? 
19:29:38 <julianleviston> I wonder, is there a list-like thing that doesn’t have order/sequence built in? Like a bag, or an unordered set or something? Often I don’t care about order, but I’d like to do some ooperation on things in a collection - just like when I have arguments to a function.
19:29:51 <zachk> how do you specify which two items you want out of the list to pass to a binary operator? 
19:29:53 <julianleviston> I guess the problem is there’s no variable-argument-list in Haskell because of types, hm? I’m not sure.
19:30:02 <zachk> import Data.Set :D 
19:30:02 <julianleviston> zachk: you specify it.
19:30:14 <zachk> not sure for what you are asking for exactly 
19:30:18 <dramforever> julianleviston: function arguments have sequence
19:30:36 <dramforever> julianleviston: can you give a concrete example?
19:30:36 <julianleviston> dramforever: they do, but not of execution.
19:30:54 <dramforever> list monad has no execution order either
19:31:16 <zachk> the execution order shoudln't matter too much in haskell, with immutability and laziness
19:31:37 <julianleviston> dramforever: ooh, really? in which case, why isn’t there a function to lift a list of two elements to args in a binary op?
19:31:39 <zachk> at least as far as function arguments go, and with purity 
19:32:06 <zachk> julianleviston: you can easily write that
19:32:10 <julianleviston> hope I’m using the word “lift” correctly
19:32:39 <c_wraith> julianleviston: the problem is that it's not very type-safe.  Lists don't include their size, and what do you do if the list is short?
19:32:48 <julianleviston> zachk: but in a general case? as in… lift a list of n elements to args of an n-arity?
19:32:59 <dramforever> type problem
19:33:00 <c_wraith> julianleviston: for that matter, what if the list is 5000 elements and you were expecting 2?
19:33:06 <julianleviston> c_wraith:  exactly.
19:33:09 <julianleviston> c_wraith: and I agree.
19:33:22 <c_wraith> julianleviston: so in general, we don't stick function args in lists. :)
19:33:23 <dramforever> julianleviston: also in what case would you need it?
19:34:12 <julianleviston> c_wraith: what structure are function args in?
19:34:19 <julianleviston> c_wraith:  they’re not, are they?
19:34:30 <zachk> > let f g (a:b:+) = g a b in f (+) [3,4] 
19:34:32 <lambdabot>  <hint>:1:10: Parse error in pattern: a : b :+
19:34:35 <julianleviston> c_wraith: Haskell doesn’t express its syntax through its data types?
19:34:42 <zachk> > let f g (a:b:_) = g a b in f (+) [3,4] 
19:34:43 <lambdabot>  7
19:34:53 <julianleviston> zachk: nice.
19:34:56 <c_wraith> julianleviston: in terms of Haskell, all functions are single argument.  No need to have a structure to hold one value. :)
19:35:07 <zachk> though f is partial and not total and could crash if you passed something with other then two arguments to it 
19:35:23 <julianleviston> c_wraith: the structure is lambda, thought, right? everything is a thunk? (for laziness)
19:35:34 <julianleviston> though*
19:35:43 <zachk> you could deconstruct over a data definition with different types being passed into the function 
19:35:56 <c_wraith> julianleviston: eh, that's not even important.  MLs curry functions, and they are strict.
19:36:28 <julianleviston> c_wraith:  but everything is a thunk, right? that’s the “data type” of an argument, no?
19:36:33 <julianleviston> if it were to have one.
19:36:43 <julianleviston> I guess I should probably look more into Parsec
19:37:06 <julianleviston> and also possibly read the online report, then this: http://hackage.haskell.org/package/haskell-src-exts-1.9.0/docs/Language-Haskell-Exts-Syntax.html#v:importSrc
19:37:08 <c_wraith> julianleviston: nah, functions *can* take non-thunk arguments.  At least in GHC.  With enough extensions enabled. :)
19:37:44 <zachk> julianleviston: what are you trying to do/code exactly?
19:37:50 <julianleviston> zachk: excellent question.
19:38:10 <TimeTime> DO YOU KNOW WHAT YOUR DOMAIN NAME IS WORTH??? -> VALUE YOUR DOMAIN @ >>> WWW.VALBOT.COM <<< OR GOOGLE >>> VALBOT.COM <<<
19:38:11 <julianleviston> zachk: I’d like to write something that wraps code as I write it so I can first-class my editing activity.
19:38:56 <julianleviston> zachk: so I can do code transformations via an editor, structural editing, graphical representation of my code, etc.
19:40:07 <julianleviston> zachk: so that the editor can “understand” that ((+) 3 4) == (3 + 4)
19:40:11 <julianleviston> for example.
19:41:11 <julianleviston> and also that, therefore, the type (3 + 4) has identical semantic intention to (foldr (+) 0 [3 4])
19:42:04 <julianleviston> sorry [3,4]
19:43:50 <zachk> the parser understands that
19:44:00 <julianleviston> zachk: or, put another way, I want to write an editor that understands the semantics of the code I write enough that I don’t have to write the same stuff again and again. I’m so utterly sick of writing the same code over and over.
19:44:11 <zachk> you can wrap any binary operator in ( ) and use it like this (+) a b
19:44:11 <c_wraith> julianleviston: if you're working at the syntax of a language, you should store lexical tokens as your data structure.
19:44:18 <julianleviston> zachk: yes, it does. :) but the parser doesn’t let me perform edits.
19:44:30 <julianleviston> zachk: of course. I know that.
19:44:36 <julianleviston> c_wraith: yes
19:44:38 <c_wraith> julianleviston: and in particular, trees of lexical tokens
19:44:42 <julianleviston> c_wraith:  yes.
19:44:43 <zachk> which parser? most use vim or emacs 
19:44:59 <julianleviston> zachk: huh?
19:45:11 <julianleviston> zachk: I thought we were talking about Haskell’s parser, the one I linked to above.
19:45:19 <zachk> you could use curry and uncurry to wrap your arguments in parentheses
19:45:24 <zachk> @type curry 
19:45:26 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:45:31 <zachk> @type uncurry 
19:45:32 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:45:41 <julianleviston> zachk:  you mean tuples, not parenthesis.
19:46:15 <julianleviston> c_wraith: but the thing I’m interested in here is, is how to translate between lists and arguments.
19:46:49 <julianleviston> zachk: (I think). Parenthesis are just the way we represent tuples (or pairs, if you prefer the synonym for n-tuples where n = 2)
19:47:00 <zachk> well your arguments might not all be of the same type, though the normal lists in haskell always are of the same type 
19:47:07 <c_wraith> julianleviston: why store lists anywhere?
19:47:29 <julianleviston> zachk: yeah, unless you turn on that extension, whatever it’s called.
19:47:53 <julianleviston> c_wraith: if one wants to keep a non b-tree, doesn’t it involve lists?
19:47:58 <zachk> there are a bunch of different libraries to do that, I used to think I needed them, but once I got into haskell homogenous lists are fine
19:48:13 <julianleviston> zachk: yeah, they are.
19:48:41 <julianleviston> zachk: besides, you can always create a data type that indirects your other data types if you like… that way you’re all good.
19:48:53 <julianleviston> zachk: it’s a little more complicated, but it works.
19:49:03 <julianleviston> c_wraith: to keep the list of children?
19:49:31 <c_wraith> julianleviston: Nah, all you need is a tree, like..  data Exp = Var | Let Decls Exp | BinOp Name Exp Exp | App Exp Exp
19:49:40 <dramforever> julianleviston: why you need hetergenerous lists of children?
19:49:41 <c_wraith> julianleviston: obviously, that's really incomplete.
19:49:52 <c_wraith> julianleviston: But that's the basic idea
19:49:54 <julianleviston> c_wraith: ah… ok… sweet!
19:50:24 <julianleviston> c_wraith: I’m not sure how that deals with multiple-arg expressions tho?
19:50:35 <c_wraith> julianleviston: Haskell doesn't have multi-arg expressions
19:50:43 <julianleviston> c_wraith: at parse time it does
19:50:57 <c_wraith> julianleviston: foo x y parses as (foo x) y
19:51:00 <julianleviston> c_wraith: I can write a 15-arg function can’t I?
19:51:11 <dramforever> no you can't
19:51:14 <julianleviston> c_wraith: ah of course! so clever!
19:51:18 <dramforever> at parse time it's desugared
19:51:25 <dramforever> well, sort of
19:51:27 <julianleviston> desu what?
19:51:31 <julianleviston> oh de-sugared
19:51:42 <zachk> function :: a -> b -> c is really a -> (b -> c) 
19:51:51 <julianleviston> zachk:  yes, I know :)
19:51:54 <c_wraith> julianleviston: that's what I meant by "all haskell functions are single-argument"
19:52:01 <julianleviston> c_wraith: yeah, I know.
19:52:12 <c_wraith> julianleviston: you can treat it as a tree of function applications.
19:52:13 <zachk> c_wraith: but what of f : a ? :D 
19:52:13 <julianleviston> c_wraith: just translating it into this context is where I’m learning.
19:52:35 <julianleviston> zachk: that’s just the same thing. : is just a function.
19:52:37 <c_wraith> zachk: that's why I had a seperate binop constructor
19:52:45 <zachk> julianleviston: so you are coding a language with variable length argument lists? 
19:52:46 <c_wraith> zachk: though it isn't really necessary.
19:53:22 <julianleviston> zachk: I’m trying to have a way to store any code.
19:53:43 <julianleviston> zachk: irrespective of language.
19:53:53 <julianleviston> zachk: really most non-haskell code can be represented with do notation anyway, though, right?
19:54:03 <julianleviston> where sequence is important.
19:54:11 <julianleviston> (here I mean execution order)
19:54:40 <julianleviston> the thing is, for most programmers, sequence order is often not as important as one would think.
19:54:49 <dramforever> exactly
19:54:52 <julianleviston> :)
19:55:07 <julianleviston> it’s just their stupid languages don’t let them encode their actual intention properly. 
19:55:27 <julianleviston> js callback hell is a great and hilarious example of this.
19:55:31 <Hafydd> To run your n-line program more quickly: split it into n programs and run them concurrently.
19:55:49 <julianleviston> Hafydd:  err… hm...
19:56:08 <dramforever> Hafydd: it's not *that* unimportant
19:56:27 <zachk> if your code is pure, evaluation oder of arguments shouldn't matter at all 
19:56:39 <zachk> order
19:56:49 <zachk> sorry for the : meant :: been using agda a bit too much recently
19:57:08 <erisco> is there an easier way to get  (Read a) => String -> Maybe a   without going through reads?
19:57:29 <y> erisco: readMaybe
19:57:34 <y> in Text.Read
19:57:58 <erisco> @hoogle readMaybe
19:57:58 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
19:57:58 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
19:58:07 <y> @type Text.Read.readMaybe
19:58:09 <lambdabot> Read a => String -> Maybe a
19:58:18 <erisco> wonder why it is not listed
19:58:21 <erisco> that is why I did not find it
19:58:22 <Hafydd> There is a small probability that the instructions will be interleaved in the correct order.
19:58:28 <Hafydd> This is what we mean by "probabilistic correctness."
19:58:30 <julianleviston> I pretty much want structural editing and live coding while also having type checking and the ability to leverage Haskell’s semantic analysis while WRITING my code as well as compiling it. Unfortunately I haven’t found an editor that does this.
19:58:51 <julianleviston> hence, my questions. Thanks everyone you’ve been awesome!
19:59:06 <zachk> I have  vim mod suite I got off of github that has tab completion and supposedly online type checking 
19:59:14 <zachk> forget what its called though
19:59:44 <julianleviston> zachk: tab completion is a massively far cry away from structural editing. One is thinking in text, the other is thinking in types.
20:00:17 <zachk> whats structural editing? 
20:00:36 <julianleviston> zachk: editing where your editor understands syntax
20:00:50 <julianleviston> zachk: but also (in haskell’s case, because data is code) types.
20:01:36 <julianleviston> zachk: the term comes from the lisp world, where all code is data.
20:01:49 <julianleviston> zachk: hence, everything is structure (ie = data).
20:01:52 <zachk> haskell-mode for emacs might have something like that 
20:02:21 <zachk> I used to use scheme, and afterawhile I think the whole code is data and data is code breaks down for most normal programming activities
20:02:25 <julianleviston> zachk: emacs is a text editor. I don’t want a text editor. I don’t want to repeat myself.
20:03:16 <julianleviston> zachk: I’m not sure what you mean, but in lisp, code is definitely data. You write a function as a lisp which contains a symbol, and represents its arguments as a list, and its body as another list of lists. 
20:03:21 <zachk> there is agda-mode for emacs (for the language agda) and it can figure out types in emacs using hotkeys, agda is similar to haskell in syntax 
20:03:25 <julianleviston> as a list*
20:05:30 <zachk> vim or emacs with the correct extensions is probably what youa re looking for julianleviston, also try leksah it compiles on the fly as you code 
20:05:56 <julianleviston> zachk: No, I dont want a text editor.
20:06:20 <erisco> how do I detect overflow when I read an integral?
20:06:59 <zachk> erisco: catch ? 
20:07:06 <erisco> catch what?
20:07:27 <erisco> > (read "4294967296") :: Word16
20:07:29 <lambdabot>  0
20:07:33 <zachk> catch can catch the read's exception, I would imagine overflow from the read function would trigger some sort of an exception 
20:07:36 <zachk> oh
20:08:02 <zachk> is it always 0 on overflow? 
20:08:03 <erisco> I guess I can check string length
20:08:11 <erisco> zachk, no
20:08:15 <erisco> > (read "4294967297") :: Word16
20:08:17 <lambdabot>  1
20:08:26 <erisco> not to mention Word16 overflowed twice to get there already
20:08:52 <zachk> show the string then compare to the original string? 
20:09:04 <zachk> if they are not  the same then you overflowed or errored
20:09:08 <julianleviston> Use Integer
20:09:11 <meretrix> erisco: You can read as Integer, do a bounds check, and then convert to your desired type if within bounds.
20:09:30 * hackagebot turtle 1.2.0 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.2.0 (GabrielGonzalez)
20:09:42 <osa1> where can I find documentation of cabal sandbox init's --sandbox argument?
20:09:44 <erisco> meretrix, I don't know if the original integer overflowed
20:10:22 <meretrix> erisco: What do you mean? If the string is the result of an overflowed integer value?
20:10:27 <meretrix> No one way to tell that.
20:10:35 <meretrix> *No way
20:10:36 <erisco> when I go from String to some Integral type
20:10:43 <erisco> I don't know if it overflowed on the conversion from String
20:10:48 <julianleviston> erisco: go to Integer, then check the bounds
20:11:02 <julianleviston> erisco:  as meretrix said.
20:11:04 <erisco> oh is Integer unbounded?
20:11:12 <julianleviston> erisco: afaik
20:11:24 <julianleviston> erisco:  https://hackage.haskell.org/package/text-0.11.1.5/docs/Data-Text-Read.html
20:11:26 <erisco> > (read "89854925890262462469348141") :: Integer
20:11:29 <lambdabot>  89854925890262462469348141
20:11:39 <erisco> > (read "8985492589026246246934890562489068490683903489015701376876893463689458938141") :: Integer
20:11:41 <lambdabot>  8985492589026246246934890562489068490683903489015701376876893463689458938141
20:11:43 <julianleviston>  If you are worried about overflow, use Integer for your result type.
20:11:44 <erisco> mkay
20:11:48 <julianleviston> (from that page)
20:11:49 <erisco> well
20:11:51 <erisco> my other idea
20:11:57 <erisco> I parse into Word32 and Word16
20:12:04 <erisco> and I also check the string length is < 6
20:12:14 <julianleviston> sounds pretty hacky.
20:12:19 <erisco> it works though
20:12:22 <erisco> nothing hacky about it
20:12:23 <zachk> something like: safeRead string = let value = read string in if show value == string then Just value else Nothing, though its not that safe 
20:19:46 <zachk> night
20:22:16 <ttt_fff> is there a way, in haskell, to autogenerate class declsarations when the class only has one member function?
20:22:20 <osa1> cabal is rejecting to install my package, claiming that a dependency(which is installed just in previous command) is broken. any ideas why this is happening?
20:23:17 <osa1> ttt_fff: you can use TemplateHaskell for your code generation needs. I don't know what you mean by autogenerate?
20:23:32 <c_wraith> ttt_fff: there are a bunch of ways, especially as of GHC 7.10
20:24:23 <c_wraith> ttt_fff: it doesn't actually matter how many members the class has.  It matters if you can write code to generate them automatically.
20:24:59 <ttt_fff> yeah; I just find it flow breaking to have to constantly write "class ToBlah a where \n toBlah :: a -> Blah" all the time
20:25:11 <erisco> :t (**)
20:25:13 <lambdabot> Floating a => a -> a -> a
20:25:15 <erisco> what is used for integrals then?
20:25:24 <erisco> or Integer particularly
20:25:39 <ttt_fff> maybe I'm solving the wrong problem, I have all these stupid classes called "ToRSexp, ToTSexp, ToDataDecl, ToTypeSig" ... which basically converts other shit to RSexp / TSexp / DataDecl / TypeSig
20:27:53 <erisco> ah
20:27:55 <erisco> :t (^)
20:27:56 <sccrstud92> :t (^)
20:27:56 <lambdabot> (Integral b, Num a) => a -> b -> a
20:27:57 <lambdabot> (Integral b, Num a) => a -> b -> a
20:28:08 <sccrstud92> :t (^^)
20:28:10 <lambdabot> (Fractional a, Integral b) => a -> b -> a
20:28:40 <bananagram> :t (:^)
20:28:41 <lambdabot>     Not in scope: data constructor ‘:^’
20:28:41 <lambdabot>     Perhaps you meant one of these:
20:28:41 <lambdabot>       ‘:+’ (imported from Data.Complex),
20:28:45 <bananagram> sorry
20:46:00 <erisco> isn't there something like partition but which returns all partitions?
20:46:09 <erisco> (a -> Bool) -> [a] -> [[a]]  like?
20:48:48 <pacak> erisco: a -> Bool can give you just two partitions
20:49:11 <julianleviston> erisco can’t you reverse search in hoogle? like search on a type sig? I was sure you could do that.
20:49:27 <pacak> :t \f -> groupBy (compare `on` f) . sortBy (compare `on` f)
20:49:28 <lambdabot>     Couldn't match type ‘Ordering’ with ‘Bool’
20:49:29 <lambdabot>     Expected type: a1 -> a1 -> Bool
20:49:29 <erisco> yeah but nothing came up
20:49:29 <lambdabot>       Actual type: a1 -> a1 -> Ordering
20:49:32 <erisco> so I just wrote the definition
20:49:50 <julianleviston> https://www.haskell.org/hoogle/?hoogle=%28a+-%3E+Bool%29+-%3E+%5Ba%5D+-%3E+%5B%5Ba%5D%5D
20:49:59 <pacak> :t \f g -> groupBy ((==) `on` g) . sortBy (compare `on` f)
20:50:00 <lambdabot> (Eq a1, Ord a2) => (a -> a2) -> (a -> a1) -> [a] -> [[a]]
20:57:07 <erisco> :t guard
20:57:08 <lambdabot> Alternative f => Bool -> f ()
20:57:14 <erisco> would be nice for a version that worked well with Either
20:57:18 <erisco> so that you can give an error message
21:00:26 <Bryan> I'm new to Haskell. How do you print "Hello World"?
21:01:30 <maia> folks, what should I use to create a rest api with haskell?
21:01:40 <maia> and don't get mad in the process
21:04:10 <erisco> derp I wanted takeWhile not partition
21:04:23 <erisco> the takeWhile and dropWhile combination is... ?
21:04:50 <erisco> :t break -- this sort of
21:04:51 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
21:04:54 <erisco> it keeps the separator in there
21:05:00 <erisco> > break (=='.') "123.123"
21:05:02 <lambdabot>  ("123",".123")
21:06:22 <julianleviston> maia: maybe scotty or something like that.
21:07:08 <julianleviston> maia: http://lmgtfy.com/?q=building+a+REST+api+with+haskell
21:07:34 <erisco> what is like break
21:08:19 <erisco> span
21:08:24 <erisco> just negated predicate, meh
21:08:31 <Yuken> So, what can haskell be used for, o.o?
21:08:35 <julianleviston> Bryan: are you just trolling?
21:08:57 <lamefun> Why is monomorphism restriction handling so broken? http://lpaste.net/135820
21:10:06 <shachaf> 2 is also polymorphic
21:10:21 <shachaf> That's a perfectly reasonable thing to write if [Char] is an instance of Num.
21:11:29 <Yuken> No answers. I sad.
21:13:31 <julianleviston> Yuken: oh sorry. It can be used to add two numbers together.
21:13:55 <lamefun> shachaf: http://lpaste.net/135890
21:21:55 <erisco> how do you detect endianness?
21:22:43 <sccrstud92> :t at
21:22:45 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
21:23:02 <erisco> I am trying to convert an IP address (dot format) to a Word32
21:23:25 <sccrstud92> > [1,2,3] ^. at 1
21:23:27 <lambdabot>      No instance for (Show t0)
21:23:27 <lambdabot>        arising from a use of ‘show_M60885694481462849189873’
21:23:27 <lambdabot>      The type variable ‘t0’ is ambiguous
21:23:31 <sccrstud92> :i At
21:23:39 <arkeet> erisco: what does that have to do with endianness?
21:23:40 <sccrstud92> @info At
21:23:40 <lambdabot> At
21:24:01 <arkeet> sccrstud92: it's from lens
21:24:22 <erisco> arkeet, well, in 1.2.3.4 is it 1+2*2^8+3*2^16+4*2^24 or the other way around?
21:24:32 <arkeet> is what?
21:24:35 <sccrstud92> arkeet: lambdabot has been working with lens
21:24:36 <arkeet> for what purpose are you converting it?
21:24:39 <erisco> the Word32 equivalent
21:24:39 <shachaf> sccrstud92: This is at least the third time you've done @info in lambdabot.
21:24:47 <erisco> arkeet, because that is what the network lib accepts
21:24:54 <shachaf> You've already been told it doesn't work. No point in doing it again.
21:25:19 <sccrstud92> shachaf: why does it return something?
21:25:20 <arkeet> erisco: so your question is "how do I convert an ip address string to something network accepts"?
21:25:29 <erisco> no that was not my question
21:25:35 <erisco> my question is how to detect endianness
21:25:47 <arkeet> :(
21:25:49 <mauke> erisco: that sounds like an XY problem
21:26:02 <erisco> well nevermind then
21:26:12 <arkeet> look in the docs
21:26:19 <arkeet> it says HostAddress is in "Network byte order."
21:26:46 <erisco> yeah, I am trying to get a HostAddress
21:26:46 <arkeet> that is big-endian.
21:26:48 <erisco> which is a Word32
21:26:48 <arkeet> regardless of the platform.
21:26:58 <mauke> erisco: why?
21:27:00 <erisco> it is big endian on the network
21:27:07 <erisco> that doesn't mean the host is big endian
21:27:21 <arkeet> the endianness of the host doesn't matter.
21:27:28 <arkeet> also, why not just use inet_addr or something?
21:27:32 <erisco> how does it not matter?
21:27:41 <arkeet> why would it matter?
21:28:02 <erisco> when you take some 32bit integer out of memory and transmit it over the network
21:28:03 <lispy> erisco: it doesn't matter in the sense that there is standard conversion function you use. On a big endian system it's just id. On a little endian system it swaps the byte order.
21:28:09 <erisco> if the host is small endian then it will reverse the byte order
21:28:22 <erisco> so if you stored the integer assuming the host was big endian your integer will come out backwards
21:28:29 <lispy> right
21:28:31 <mauke> erisco: ???
21:28:33 <arkeet> ???
21:28:35 <lispy> So you use the conversion function
21:29:09 <erisco> the problem is that inet_addr comes out in IO
21:29:13 <arkeet> the most significant byte (bits 24-31) contains the first octet of the IP address.
21:29:16 <arkeet> and so on.
21:29:17 <lispy> erisco: http://www.retran.com/beej/htonsman.html
21:29:20 <arkeet> regardless of the host.
21:29:23 <erisco> and I can't use IO with optparse-applicative for an argument parser
21:29:36 <erisco> arkeet, yeah, but that is on the network
21:29:49 <arkeet> the network library specifies this.
21:30:05 <erisco> if the host is little endian then in main memory it is stored in little endian
21:30:54 <arkeet> ok never mind.
21:31:05 <julianleviston> lol
21:31:26 <sccrstud92> is there a way to delete an element of a list with lens?
21:31:26 <arkeet> just poke your bytes into an array of 4 Word8s and peek the same pointer as a Word32.
21:31:28 <arkeet> you're done.
21:31:31 <arkeet> sccrstud92: no
21:31:36 <edwardk> not really
21:31:52 <sccrstud92> is there some theoretical reason why?
21:31:56 <sccrstud92> err
21:31:58 <sccrstud92> mathematical
21:32:37 <mauke> arkeet: SIGBUS
21:33:03 <arkeet> mauke: ?
21:33:41 <julianleviston> couldn’t you use a lens to copy out a part of a data structure tho?
21:33:55 <julianleviston> ie create a new thing by using the lens? isn’t that effectively what deleting is anyway?
21:34:23 <mauke> arkeet: char a[4]; *(uint32_t *)a = 42;  //  might crash because unaligned pointer
21:34:40 <sccrstud92> julianleviston: like a traversal that accesses every element except one at a certain index
21:34:50 <sccrstud92> then using to list of
21:34:55 <shachaf> Indexing on lists is pretty fishy in the first place.
21:34:55 <sccrstud92> yeah i think I can do that
21:35:10 <arkeet> mauke: might it crash on any platform supported by ghc?
21:35:13 <edwardk> that works, it just isn't a 'lens' per se.
21:35:15 <shachaf> What do you do for an index past the end of the list?
21:35:37 <sccrstud92> shachaf: nothing
21:35:46 <sccrstud92> because the traversal gets everything
21:35:46 <julianleviston> sccrstud92: I guess, like all things, it depends what you’re trying to do… and therefore why you need a lens that would do this?
21:35:52 <edwardk> :t "hello"^.traversed. Lens.indices (/= 2)
21:35:54 <lambdabot>     No instance for (Monoid Char) arising from a use of ‘traversed’
21:35:54 <lambdabot>     In the first argument of ‘(.)’, namely ‘traversed’
21:35:54 <lambdabot>     In the second argument of ‘(^.)’, namely
21:35:54 <shachaf> Making that sort of thing law-abiding and useful is tricky.
21:35:59 <edwardk> :t "hello"^..traversed. Lens.indices (/= 2)
21:36:00 <lambdabot> [Char]
21:36:02 <arkeet> mauke: besides, this is not exactly that.
21:36:03 <edwardk> > "hello"^..traversed. Lens.indices (/= 2)
21:36:05 <lambdabot>  "helo"
21:36:14 <edwardk> kinda silly but it works
21:36:19 <shachaf> Well, you can have a traversal/fold that looks at everything other than your element, sure.
21:36:20 <sccrstud92> :t Lens.indices
21:36:21 <arkeet> we can make the pointer aligned to 32 bits.
21:36:21 <lambdabot> (Applicative f, Indexable i p) => (i -> Bool) -> Optical' p (Indexed i) f a a
21:36:24 <shachaf> But that collapses your thing to a list.
21:36:25 <julianleviston> edwardk: yeah. 
21:36:33 <shachaf> So there's no point in using a traversal at that point.
21:36:36 <mauke> arkeet: what platforms does ghc support?
21:36:51 <julianleviston> shachaf: exactly - why use a Lens!
21:36:59 <julianleviston> sccrstud92: what are you trying to do?
21:37:06 <erisco> maybe I can just unsafePerformIO
21:37:10 <erisco> that fixes problems right
21:37:13 <arkeet> mauke: uint32_t a; *(char*)a+1 = 42
21:37:16 <arkeet> can this crash?
21:37:23 <arkeet> er
21:37:30 <arkeet> *((char*)a+1)
21:37:45 <sccrstud92> I delete an element of a list that is a value of a Map
21:37:47 <arkeet> &a
21:37:55 <sccrstud92> the Map is in a record
21:38:04 <sccrstud92> and that record is in another record
21:38:05 <mauke> arkeet: I think that's ok
21:38:11 <arkeet> mauke: then what I said can work.
21:38:11 <shachaf> A Map can be much better-behaved in this regard than a list.
21:38:19 <sccrstud92> yes
21:38:20 <mauke> arkeet: non sequitur
21:38:24 <sccrstud92> because it has an At instance
21:38:31 <arkeet> mauke: allocate a pointer to a Word32.
21:38:42 <mauke> yes, that's the reverse of what you said
21:38:49 <arkeet> I never said anything about allocation.
21:39:26 <sccrstud92> julianleviston: shachaf: still think its a bad idea to use lens here?
21:39:28 <gamegoblin> I wish there was OverloadedChars so I could use char literals for word8s -___-
21:39:40 <sccrstud92> given the nested-ness of my data structure
21:40:29 <julianleviston> sccrstud92: seems they’re best for looking at stuff, to me.
21:40:34 <julianleviston> but what do I know!
21:40:59 <sccrstud92> well im doing that too
21:43:08 <arkeet> mauke: alloca $ \(p :: Ptr Word32) -> pokeElemOff (castPtr p :: Ptr Word8) 1 42 >> peek p
21:43:18 <julianleviston> sccrstud92: have you thought about Traversals?
21:43:54 <sccrstud92> julianleviston: I just suggested them above
21:44:00 <julianleviston> sccrstud92: oh sorry!
21:44:00 <erisco> can anyone comment on why inet_addr needs to return in IO?
21:44:01 <sccrstud92> and ek used them
21:44:05 <sccrstud92> np
21:44:07 <erisco> I know someone said something a couple days ago but I can't remember
21:44:11 <julianleviston> sccrstud92: I should shut up :)
21:44:25 <erisco> or more directly, whether unsafePerformIO is alright
21:44:36 <erisco> if it was then I suspect it wouldn't be returning in IO
21:44:38 <sccrstud92> the fact that you think you should is a pretty good indication that you dont have to
21:44:46 <sccrstud92> =)
21:45:14 <erisco> I do because of how optparse-applicative works
21:45:21 <julianleviston> sccrstud92: nice :)
21:45:23 <erisco> it doesn't accept argument parsers that return in IO
21:45:36 <cow_2001> what're the alternatives to monad transformers?
21:45:49 <sccrstud92> erisco: someone said ffi to C
21:45:49 <cow_2001> like, execStateT
21:45:52 <lispy> erisco: the short answer (I just looked it up) is because it calls the C function inet_addr.
21:45:52 <erisco> cow_2001, increased happiness
21:45:59 <cow_2001> erisco: eh?
21:46:05 <lispy> erisco: http://hackage.haskell.org/package/network-2.4.2.3/docs/src/Network-Socket.html#inet_addr
21:46:14 <erisco> ffi to C does not have to be IO though
21:46:18 <erisco> why did they make theirs IO
21:46:19 <mauke> arkeet: wanna see something disgusting? isBE = PortNum 1 == 1
21:46:20 <sccrstud92> cow_2001: extensible effects?
21:46:48 <arkeet> mauke: more curious than disgusting.
21:46:53 <lispy> erisco: Well, is the C function referentially transparent in this case? (I have no idea, but it might not be reentrant?)
21:47:27 <erisco> do you know what referentially transparent means? I don't see how it applies
21:47:33 <arkeet> interestingly, inet_addr "255.255.255.255" fails
21:48:10 <mauke> yeah, the man page says you can't distinguish errors and a successful -1
21:48:16 <lispy> erisco: if you make the function pure, then the compiler might call it however it wants instead of calling it in the sort of lock step way that it would with the IO type
21:48:17 <sccrstud92> erisco: if its not referentially transparent, then the assumption is it does effects, and that oculd be one reason its an IO action and not a pure function, because pure functions should be referentially transparent
21:48:23 <mauke> and recommends the use of inet_aton instead
21:48:30 <arkeet> right.
21:48:39 <erisco> what does referential transparency got to do with effects?
21:48:52 <julianleviston> it gots lots
21:49:23 <julianleviston> erisco: not referential integrity, mind.
21:49:29 <sccrstud92> referentially transparent means no visible effects to anything else
21:49:32 <sccrstud92> right?
21:49:36 <julianleviston> == purity.
21:49:48 <erisco> that isn't what I understand as referential transparency sccrstud92
21:50:05 <julianleviston> https://en.wikipedia.org/wiki/Referential_transparency_(computer_science)
21:50:25 <lispy> roughly it means that the denotation is independent of the calling context
21:50:44 <erisco> if a term is referentially transparent then it can be replaced with its definition without altering meaning
21:50:54 <sccrstud92> exactly
21:51:04 <erisco> in other words, the name of the term is not significant
21:51:15 <erisco> or the name of the definition rather
21:51:20 <sccrstud92> if you replace a function call with side effects with the result of the call
21:51:27 <sccrstud92> then you dont have the side effects
21:51:31 <sccrstud92> anymore
21:51:35 <sccrstud92> so its not the same
21:52:02 <julianleviston> yeah… if it’s memoizable, it’s referentially transparent.
21:52:23 <erisco> not everything has a definition though
21:52:24 <julianleviston> side-effecting functions aren’t.
21:52:44 <erisco> I see what you are saying but it doesn't work for me
21:52:50 <erisco> but anyways, this is pedantic
21:52:54 <julianleviston> lol
21:53:09 <julianleviston> erisco:  is it possible you’ve not got the right definition?
21:53:19 <sccrstud92> pendantry is a long-term investment in understanding
21:53:25 <erisco> julianleviston, no
21:53:30 <julianleviston> erisco: ah. my bad.
21:54:03 <julianleviston> “If the substitution of an expression with its value is valid only at a certain point in the execution of the program, then the expression is not referentially transparent. “
21:54:42 <sccrstud92> i wonder how that works with out of memory errors...
21:54:50 <julianleviston> I guess you’re arguing that side-effects aside, a function is still a function if evaluates to the same value?
21:55:18 <julianleviston> sorry, a function is still referentially transparent if… *
21:55:27 <erisco> that definition is different than the one I use
21:55:37 <erisco> but whatever, not important :P
21:55:43 <julianleviston> it kind of is, isn’t it?
21:55:52 <lispy> erisco: I'm pretty sure this is the reason it's not bound as a pure function: http://code.woboq.org/userspace/glibc/resolv/inet_addr.c.html#215
21:55:53 <erisco> no it isn't
21:56:25 <lispy> line 215 is updating global state (errno)
21:56:29 <erisco> julianleviston, if you expect terminology to be divinely explained on stone tablets then you're in for a surprise ;)
21:56:47 <julianleviston> erisco: that’s not quite what I was expecting ;-)
21:57:02 <julianleviston> erisco: there may perhaps be a middle ground. :)
21:57:25 <erisco> the definition you gave is more relevant to a language with mutable variables
21:57:29 <julianleviston> erisco: and I’m interested in what you have to say, but if you’re over talking about it, that’s cool.
21:57:51 <lispy> http://stackoverflow.com/questions/210835/what-is-referential-transparency
21:59:05 <lpaste> arkeet pasted “erisco” at http://lpaste.net/135892
21:59:07 <lispy> equational reasoning is a consequence of referential transparency in Haskell, but I wouldn't say it's the definition.
21:59:08 <julianleviston> I guess it depends on what “behaviour” is defined as.
21:59:49 <erisco> arkeet, oh thanks :)
22:00:10 <arkeet> doesn't ask about endianness, just puts the first octet in the first byte, etc.
22:00:26 <erisco> okay, but endianness is important
22:00:45 <lispy> Then use bit shifts and masks
22:00:53 <arkeet> and it matches the output of inet_addr
22:01:02 <erisco> maybe on your machine
22:01:05 <arkeet> (I imagine it does on a big-endian system too, but I don't have one to test with.)
22:01:36 <lispy> regardless of a machine endianess, the shift and mask operations can give you acess to the bytes in whatever order you need (low to high or high to low)
22:02:07 <erisco> but I have to know what order I want :P
22:02:14 <arkeet> lispy: I would expect inet_addr "0.0.0.1" would return 2^24 on a little-endian system and 1 on a big-endian system.
22:02:21 <arkeet> so you need to know the endianness to know how to bit shift/mask.
22:03:09 <lispy> ah, I thought you were going the other direction. To put it on the network.
22:03:18 <erisco> lispy, hm
22:03:42 <erisco> lispy, but the errno cannot be observed outside of IO
22:03:49 <arkeet> you can handle it inside IO.
22:03:56 <erisco> so I don't think there is a purity problem there
22:04:08 <arkeet> you can handle any errors inside the action you pass to unsafePerformIO
22:04:13 <arkeet> I think.
22:04:38 <erisco> I don't expect errors at that point
22:04:45 <erisco> I can catch IOException or whatever and print a message
22:04:55 <erisco> it isn't ideal in the first place because optparse-applicative
22:05:04 <julianleviston> haha great. I have to go back to reading whitehead :)
22:05:23 <lispy> the order that you call libc functions determins how errno is set and if you make inet_addr pure, that order may become hard to predict.
22:05:24 <arkeet> why are you parsing IP addresses inside your argument parser anyway?
22:05:34 <erisco> julianleviston, I'll explain my stance more if you wish
22:06:08 <erisco> arkeet, I was going to do away with inet_addr to do away with IO
22:06:58 <julianleviston> erisco: sure, if you’d like. I *think* I get it… it seems you’re just saying a term can be replaced by its definition, and that’s referential transparency.
22:07:17 <erisco> if it does not change meaning, then yes
22:07:24 <julianleviston> erisco: to me, that’s the case ubiuquitously.
22:07:26 <erisco> but also how that contrasts to purity
22:07:39 <erisco> well it isn't the case in natural languages
22:07:47 <erisco> or in languages which have reflection
22:08:01 <julianleviston> erisco: by that definition, everything everywhere is referentially transparent, isn’t it?
22:08:20 <julianleviston> erisco: it says nothing of purity.
22:08:21 <erisco> by what definition?
22:08:42 <julianleviston> “if a term can be replaced by its def, it’s referentially transparent"
22:09:10 <erisco> it doesn't have any connection to purity for me
22:09:32 <julianleviston> I feel like I must be missing something, because by that definition, there’s nothing that cannot be referentially transparent.
22:09:34 <erisco> in languages with mutability things are murkier
22:09:35 * hackagebot auto-update 0.1.2.2 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.2.2 (MichaelSnoyman)
22:09:37 * hackagebot wai-websockets 3.0.0.6 - Provide a bridge between WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.6 (MichaelSnoyman)
22:09:39 * hackagebot wai 3.0.3.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.3.0 (MichaelSnoyman)
22:09:53 <erisco> julianleviston, languages with reflection may not be referentially transparent
22:09:59 <julianleviston> erisco: ie… what would referential opacity be?
22:10:05 <julianleviston> erisco: how so?
22:10:11 <lispy> from the SO article I linked: "At its core, "referential transparency" is a very simple and clear idea. The term "reference" is used in analytical philosophy to talk about the thing that an expression refers to. It is roughly the same as what we mean by "meaning" or "denotation" in programming language semantics"
22:10:16 <erisco> because say you pass me a function by name
22:10:33 <lispy> So, I wouldn't say definition. You replace it by the denotation.
22:10:39 <erisco> I might reflect on that function and change behaviour based on whether the name includes the phrase 'get'
22:10:40 <julianleviston> Liskni_si: yeah, I read it.
22:10:47 <julianleviston> lispy: yeah, I read it *
22:11:07 <julianleviston> lispy: I’m trying to work out what erisco means, not someone else.
22:12:01 <julianleviston> lispy:  sorry - that sounded narky. I’m not being narky. :)
22:12:11 <lispy> I didn't think you were
22:12:15 <julianleviston> great :)
22:12:29 <julianleviston> lispy: that *was* a good article.
22:12:41 <erisco> in natural language you can give a definition to a word, and sometimes replacing the word with the definition does not change meaning
22:12:42 <lispy> was? what happened to it? :)
22:12:51 <julianleviston> lispy: I really agree with the fact that programmers had different contexts of understanding in the past.
22:13:00 <erisco> but often there is additional meaning to the sentence because of the word chosen, so replacing with the definition changes the meaning
22:13:09 <julianleviston> lispy: http://www.genericoverlords.com/good_coding
22:13:16 <julianleviston> lispy:  lol
22:13:24 <sccrstud92> because of connotation
22:13:52 <sccrstud92> something is pure if it has no connotation =P lol
22:13:54 <julianleviston> erisco: I don’t understand how it changes the meaning.
22:14:03 <erisco> julianleviston, how what does?
22:14:23 <julianleviston> erisco: the last thing you said… replacing the definition changes the meaning.
22:14:31 <erisco> in natural language?
22:14:35 * hackagebot wai-app-static 3.1.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.1.0.1 (MichaelSnoyman)
22:14:36 <julianleviston> erisco: yes.
22:14:37 <lispy> erisco: so a change from natural language to programming language, is that we switch from definition to denotation (or really, whatever you use to define the sematics of the PL)
22:14:41 <julianleviston> erisco: in any language.
22:15:21 <sccrstud92> :t elem
22:15:22 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
22:15:26 <julianleviston> erisco: if I replace “dog” with “canine animal” in my sentence “the dog sits on the mat”, the semantics are identical. Perhaps this is straw-man
22:15:29 <lispy> julianleviston: oh, I just realized you wrote that article :)
22:15:37 <julianleviston> lispy: yeah, sorry!
22:16:03 <julianleviston> lispy: it reminded me of that… to do with the context of what a programmer *used* to be compared to what one is today.
22:17:17 <julianleviston> lispy: or even what one will be tomorrow.
22:18:34 <julianleviston> erisco: to me this is one of the massive wins of haskell … that we can check for functional identity based on definitions rather than the fuzzier world of names.
22:19:18 * lispy wants to make an 'intensional' pun
22:19:37 <julianleviston> erisco: it’s tricky to do this without that a function can only rely on its inputs and only provide its outputs through a standard production point.
22:19:38 <erisco> julianleviston, I recommend you follow the example here http://stackoverflow.com/questions/210835/what-is-referential-transparency
22:19:44 <erisco> with regards to natural language examples
22:19:57 <julianleviston> erisco: I read that. 
22:20:02 <julianleviston> erisco: perhaps I should read it again.
22:21:02 <erisco> purity is a different matter altogether to me
22:21:29 <julianleviston> erisco: how can you replace something in a functional sense if you don’t control all of the inputs or outputs?
22:21:49 <julianleviston> erisco: aren’t those uncontrolled inputs and/or outputs part of the computing context in which the function under replacement sits?
22:22:16 <erisco> are you asking if referentially transparent terms are necessarily pure?
22:22:24 <julianleviston> in other words… “that to which I refer, when I refer” - is it a complett entity? or does it rely on other things?
22:22:27 <erisco> or the other way around?
22:22:31 <julianleviston> erisco: neither.
22:22:47 <julianleviston> erisco: if I say 1 + 2, then 1, + and 2 are referred to. 
22:23:23 <julianleviston> erisco: if I replace all 3 (and the context that they are evaluated with) by their definitions, I have a full explanation of their references… - this is referential transparency, by any definition that you care to muster.
22:23:41 <julianleviston> disagree?
22:24:23 <erisco> I am not quite sure what you mean by "a full explanation of their references"
22:24:40 <julianleviston> of course, you run into the problem of “what is a definition” quite quickly… but assuming one has an assumed identical platform to communicate - for example, identical computer, identical execution platform.
22:25:02 <julianleviston> erisco:  I mean, define 1 to whatever limit you want to, and the same with 2, and the same with +
22:25:44 <julianleviston> erisco: now, I can uproot this in its entiretly, and put it in someone else’s context, and it will have the same output as on mine assuming the function is self-contained, or pure.
22:26:11 <julianleviston> if it’s NOT, though, then the output cannot be replaced by the computation… ergo, not referentially transparent, in any sense.
22:27:32 <julianleviston> … which is why I’m at a bit of a confused point in trying to understand your definition…
22:30:04 <julianleviston> if a function replies on, or yields anything that is not in its controlled inputs (arguments) or outputs (value), then I can’t see how its references can be known. If it prints out the number 5 to “the world”, then the output is uncontrolled (the world mixed with the string, here). Your function prints it out in red text, mine in blue text. Our references are not identical.
22:30:31 <erisco> I don't really know what to say
22:30:46 <sccrstud92> im surprised this conversation is still going on
22:31:59 <julianleviston> yes, I should do some work.
22:32:58 <erisco> I don't know if you consider purity and referential transparency to be the same thing
22:33:01 <erisco> or if one implies the other
22:35:53 <lispy> regardless of where you come down on RT and purity definitionally, setting errno is the reason inet_addr has an IO type and if you care about checking errno it matters.
22:35:55 <erisco> if I understand correctly, you are saying that if you have a term T and you run the program and it evaluates to U then if T is referentially transparent you should be able to substitute it for U and the program will still work the same
22:36:04 <erisco> which is different than how I understand it
22:36:06 <sccrstud92> @hoogle [x] -> ([x], x)
22:36:07 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
22:36:37 <erisco> lispy, well, you read errno into IO. Does it matter if it is set outside of IO? I don't see why it would
22:36:38 <lispy> According to what Uday wrote on SO, involving evaluation is a mistake in understanding RT
22:37:03 <lispy> RT is about the context and denotation
22:37:06 <julianleviston> Purity implies nothing outside the input and output of a function are used. Referential transparency inplies all inputs and outputs values can replace their references and the functionality remains identical. I think they’re different.
22:37:17 <erisco> independently from that I don't think evaluation should be involved either
22:38:32 <erisco> purity to me is very simply that if a term T evaluated to U once then it ought to evaluate to U every other time
22:38:49 <erisco> maybe some nuance in there for non-termination
22:39:08 <lispy> erisco: the thing about pure functions in Haskell is that they can basically be called (or not), moved around, results cached, AND laziness means the exact order of evaluation is hard to pin down. For these reasons, if you have something that sets global state that is pure, then how will you know when the global state is written to?
22:39:57 <lispy> and I say lazy, but technically it's just non-strict.
22:39:57 <julianleviston> erisco: interesting, but printLn is pure by that definition.
22:40:44 <sccrstud92> lispy: are you sure you dont actually mean laziness?
22:40:57 <erisco> julianleviston, perhaps yes
22:41:05 <sccrstud92> lispy: are you sure than non-strictness prevents you from knowing eval order?
22:41:07 <erisco> it gets fuzzy around what RealWorld is supposed to be
22:41:20 <lispy> sccrstud92: it doesn't prevent you, no
22:41:35 <sccrstud92> i meant
22:41:40 <lispy> sccrstud92: it's just "hard to pin down" :) The inputs could change the order, for example
22:42:07 <julianleviston> erisco: what’s interesting to me is that often programmers don’t see a function or the execution context as being part of the inputs, but they are.
22:42:30 <erisco> the concept of RealWorld is that it is the state of everything, and if you accept that then printLn being pure is nothing shocking
22:43:04 <erisco> the whole point of the IO monad thingie was to keep the purity of the language in check
22:43:19 <erisco> yes, we say IO is for impure stuff
22:43:29 <erisco> but really IO is a way to model the impure in a pure way
22:44:29 <julianleviston> erisco: of course. One way to model time is as a series of transformations on a state world.
22:44:36 * hackagebot DCFL 0.1.1.0 - Communication Free Learning-based constraint solver  http://hackage.haskell.org/package/DCFL-0.1.1.0 (dpandya)
22:45:35 <julianleviston> erisco: I don’t find you seeing println as referentially transparent shocking, but I don’t find that definition accurate, because all the references *aren’t* transparent if they’re not explicitly shown.
22:45:38 <erisco> what you're saying is that printLn does IO because it mutates a memory buffer, and that's fine, and it happens to be that stuff that does IO goes into the IO monad
22:45:41 <erisco> that doesn't make it impure
22:46:04 <erisco> I did not say printLn was referentially transparent
22:46:16 <erisco> printLn does not have a definition in Haskell
22:46:33 <erisco> (okay, there are a few functions under the hood but it stops and then GHC magic begins)
22:50:39 <julianleviston> erisco: at this point I think I’m going to have to end my part in this discussion and say that I respectfully disagree… to me, purity is when there are no side-effects, or side-inputs. That is, all inputs and outputs to the function are explicitly connected to the standard inputs and outputs of the function. Referential transparency is simply a matter of whether references can be replaced with values and the 
22:50:40 <julianleviston> functionality remains identical. 
22:52:31 <lispy> julianleviston: I think you should read Uday's second reply in that SO thread. Where you say values you should instead think about denotations and where you talk about functionality you should talk about meaning. The point I'm trying to make is that for RT we *should* be separating evaluation from meaning.
22:52:46 <erisco> it was a fun discussion
22:52:56 <julianleviston> erisco: indeed!
22:53:10 <julianleviston> erisco: we can keep talking, I wasn’t meaning to end it… I just don’t think we agree. :) which is fine.
22:53:17 <julianleviston> lispy: I will do.
22:53:44 <erisco> yeah well you can argue about what a word ought to mean until the cows come home
22:53:51 <erisco> that isn't the interesting part of the discussion I don't think
22:54:07 <lispy> in this case, I believe it leads to the interesting part
22:54:22 <lispy> We also don't have a complete semantics for haskell :/
22:55:48 <julianleviston> erm humans don’t for anything! :)
22:58:49 <erisco> g'night
22:59:01 <lispy> g'night
22:59:08 <lispy> good luck with your endiansess
22:59:16 <icicled> Has anyone successfully stacked ReaderT on top of ScottyT with scotty v0.10.1 ?
22:59:44 <lispy> I've never tried so I'm not sure how to answer that ;)
22:59:52 <icicled> I'm attempting to do so but I've run into this: http://lpaste.net/364672367294676992#line22
22:59:53 <julianleviston> lispy: I think perhaps Uday has missed something there. To me, the philosophers’ definition of referential transparency isn’t at variance with the evaluation one. Collapsed by evaluation / execution isn’t important, particularly.
22:59:55 <lispy> "No" might imply something other than what I mean :)
23:00:24 <julianleviston> lispy: NICE!
23:00:45 <lispy> julianleviston: I understood that part to say, how you define the meaning of your programs matters (for instance, operationally vs. denotationally)
23:01:09 <julianleviston> lispy: lol but they exist in the same universe!
23:02:24 <julianleviston> lispy:  in other words, “5” has a meaning in a context. So does “3 + 2”. In that same context, if they are identical, neither of these are true values. They’re only references.
23:03:16 <julianleviston> lispy: ergo you can replace one with the other. That is why haskell’s base implementation is superior to other languages… it’s more true - code can represent data, but the other way around requires an executor as well - one of the inputs lisp-ers usually “don’t see”.
23:08:51 * lispy wonders how many 'mutually recursive' SO articles exist
23:10:45 <sccrstud92> icicled: is there any reason that you put ReaderT inside of ScottyT inside of vice versa?
23:11:50 <icicled> sccrstud92: the only reason was the SO examples that I've seen thus far
23:12:37 <lispy> icicled: what does GHC say for the type of runner?
23:12:57 <icicled> runner :: ReaderT (Text -> Foo) m a -> m a
23:12:57 <lispy> https://hackage.haskell.org/package/scotty-0.10.1/docs/Web-Scotty-Trans.html#v:scottyT
23:13:02 <lispy> that's the type of scottyT
23:14:08 <sccrstud92> let runner = flip runReaderT foo'
23:14:18 <sccrstud92> does chaning it to that work icicled?
23:14:57 <sccrstud92> i think it needs to be changed, but i think you will have another problem
23:15:15 <lispy> I think the type of the second runner is wrong
23:15:23 <lispy> Just based on the last bit of the error message
23:15:27 <icicled> I am not smort >_>
23:15:31 <icicled> can't believe I missed that
23:15:35 <icicled> also, no it doesn't work
23:15:43 <lispy> paste the new error?
23:15:59 <icicled> http://lpaste.net/8710234435527639040
23:16:03 <sccrstud92> also what version of scotty are you using?
23:16:36 <icicled> scotty-0.10.1
23:19:01 <lispy> icicled: so, the newer error says there is a disagreement between () and and IO a
23:19:19 <lispy> icicled: I think it's referring to webapp
23:19:39 * hackagebot wai-extra 3.0.8.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.8.0 (MichaelSnoyman)
23:20:03 <icicled> oh, what would that need to be then?
23:20:05 <sccrstud92> what happens if u only pass runner one time
23:20:13 <sccrstud92> instead of twice
23:20:25 <lispy> scottyT 4000 runner runner webapp  -> scottyT 4000 runner undefined webapp
23:20:32 <icicled> sccrstud92: ... it works
23:20:37 <icicled> >_>
23:20:42 <sccrstud92> yay
23:20:48 <icicled> I don't get it
23:20:57 <icicled> the line now reads: scottyT 4000 runner webapp
23:21:01 <lispy> ah
23:21:14 <sccrstud92> :t Web.Scotty.Trans.scottyT
23:21:15 <lambdabot> Not in scope: ‘Web.Scotty.Trans.scottyT’
23:21:18 <lispy> oh right, yeah too many arguments
23:21:55 <sccrstud92> icicled: Port 
23:21:55 <sccrstud92> -> (m Response -> IO Response) -> ScottyT e m () 
23:21:55 <sccrstud92> -> n ()
23:22:06 <icicled> I was thinking it might be extra but I wasn't sure
23:22:18 <sccrstud92> scottyT used to take 4 params
23:22:19 <icicled> since in 0.9.1 there are 4 args - http://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty-Trans.html
23:22:24 <sccrstud92> but they combined two together
23:22:30 <sccrstud92> so its one now
23:23:12 <icicled> sccrstud92: so why does ghc not just tell me "hey, you passed too many params" before trying to match the types?
23:23:24 <lispy> Usually it does
23:23:30 <lispy> so, that's a good question
23:24:07 <sccrstud92> icicled: i think it started to tell you
23:24:18 <sccrstud92> "The function scottyT is applied to four arguments," ...
23:24:22 <sccrstud92> thats how it starts
23:24:28 <sccrstud92> i would expect
23:24:40 <sccrstud92> "but it only expects 3" later on
23:24:43 <sccrstud92> but its not there
23:24:49 <sccrstud92> what version of ghc are you using?
23:25:01 <icicled> 7.10.1
23:25:19 <icicled> yea, the latter half of that text is missing
23:25:19 <lispy> yeah, it's weird and both signatures have 3 arguments :/
23:25:39 <lispy> (which is why I thought the argument number was right)
23:25:48 <icicled> welp, now I know what to pay attention to ^_^
23:26:10 <icicled> for this type of error that is
23:26:14 <sccrstud92> my guess is it cant tell how many because youve got pretty complex types and type defs in there
23:26:41 <icicled> gotcha
23:27:23 <sccrstud92> and in general, applying less args than expected is valid, and if your return type specializes to a function, then you can actually apply "more" args and have it be correct
23:27:28 <sccrstud92> so it can be hard
23:27:47 <sccrstud92> :t pure
23:27:48 <lambdabot> Applicative f => a -> f a
23:27:55 <sccrstud92> :t pure 1 "cow"
23:27:56 <lambdabot> Num a => a
23:28:02 <sccrstud92> > pure 1 "cow"
23:28:03 <lambdabot>  1
23:28:07 <sccrstud92> see? magic
23:28:13 <sccrstud92> =P
23:28:14 <icicled> jeez
23:28:29 <icicled> that's rough
23:28:40 <sccrstud92> yeah
23:28:41 <sccrstud92> can be
23:28:58 <lispy> functional programming, amirite?
23:29:02 <icicled> I can see how it's hard to infer the end of the currying?
23:29:11 <lispy> Basically yeah
23:29:23 <icicled> that makes sense now
23:29:39 * hackagebot wai-handler-launch 3.0.0.4 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0.4 (MichaelSnoyman)
23:29:47 <icicled> I found a reader example on scotty's github - https://github.com/scotty-web/scotty/blob/master/examples/reader.hs
23:30:02 <icicled> however there's a lot of "magic" going on in there
23:30:43 <lispy> oh cool, Erlend worked on that example. I met him once.
23:31:50 <lispy> icicled: it's a lot of magic, but the 'magic' is reusable. So once you get fluent in it you can translate it to other contexts.
23:32:14 <lispy> eg., not beginner friendly but it is good for maintenance
23:32:22 <sccrstud92> lispy: by that you mean, magic is good once you learn to be a wizard
23:32:41 <lispy> That's right, and a wizard arrives precisely when he means to
23:32:56 <icicled> any particular resource y'all could point to about GeneralizedNewtypeDeriving ?
23:33:17 <lispy> icicled: hmm...another good question.
23:33:55 <sccrstud92> icicled: https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/deriving.html section 7.5.4.1
23:34:02 <lispy> icicled: I don't know one off the top of my head. It sort of does what you would expect nearly always. It creates an instance that matches the underlying type.
23:34:34 <lispy> icicled: There are some weird corner cases that are unsound, and people have worked at fixing those in recent GHC releases.
23:35:28 <sccrstud92> he might just need something that explains what it is
23:35:30 <icicled> gotcha
23:35:38 <icicled> a little bit :)
23:36:09 <icicled> an example would be nice - e.g. here's how it was before & here's how to use it to same time/money/etc
23:36:19 <icicled> s/same/save/
23:36:44 <icicled> I see a few small examples in the ghc doc
23:36:50 <lispy> do you know what this means? newtype NewT = NewT OldT
23:37:15 <icicled> it's not a type alias
23:37:30 <icicled> but a new type that can "hold" OldT ?
23:37:30 <lispy> it's a brand new type that borrows the representation of the old type
23:37:35 <lispy> yeah
23:38:03 <lispy> generalized newtype deriving, lets you also automatically reuse (some) type class instances
23:38:24 <lispy> It basically just applies the NewT constructor (or removes it) as needed and builds the instance
23:39:01 <icicled> I see, so it literally copies/derives the instance definition based on an existing type?
23:39:25 <lispy> newtype MyInt = MyInt Int deriving (Eq), would use the (==) for Int but for MyInt
23:39:26 <icicled> by stripping the old constructors and using the new ones?
23:39:31 <lispy> yeah
23:39:52 <icicled> gotcha
23:39:54 <lispy> Eq is one of the normally derivable type classes, so my example is a little confusing
23:40:01 <icicled> that makes sense
23:40:08 <icicled> that would get rid of a lot of boilerplate
23:40:15 <lispy> Monad and Functor are better for examples, but require the student to know more haskell
23:41:29 <icicled> if someone has some SO karma, they should edit those 2 SO answers about scotty + readerT
23:42:03 <gamegoblin> Does haskell have type constraint synonyms? I realize I could make a new typeclass that extends the ones I need, but then I would have to define all these types to be instances of it.
23:42:16 <lispy> gamegoblin: yes, via an extension
23:42:20 <gamegoblin> lispy: which?
23:42:32 <lispy> ConstrainKinds, maybe?
23:42:40 <lispy> I forget which
23:42:52 <gamegoblin> Cool, thanks
23:43:19 <sccrstud92> lispy: what about using Num as the example?
23:43:44 <lispy> sccrstud92: that might work, but I've not tested it :)
23:44:05 <icicled> sccrstud92 & lispy, thanks for helping me solve my issue
23:44:06 <sccrstud92> lispy: well I saw it in that link I posted, so I hope it works lol
23:44:11 <sccrstud92> though i havent tested it either
23:44:15 <sccrstud92> no problemo
23:44:23 <lispy> hah, it probably works then
23:44:29 <icicled> much appreciated =]
23:44:37 <lispy> icicled: np. I'm glad I could help.
23:46:54 <sccrstud92> :t (<=<)
23:46:55 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
23:47:33 <nitrix> Annnnd, back!
23:47:40 <nitrix> New condo, but can't get internet installed until the 14th. That's fine though, the neighbours have a decent one http://www.speedtest.net/result/4481819759.png.
23:47:49 <nitrix> Now I can keep learning Haskell :]
23:49:51 <sccrstud92> im trying to train myself to use all the applicative versions of functions since AMP
23:50:17 <nitrix> Eventually, I'll have to ditch the whole fpcomplete ide and setup a proper vim locally :/
23:52:50 <lispy> nitrix: I bet people here would like to help you set that up. I don't think I have anything haskell specific in my .vimrc
23:53:10 <lispy> nitrix: for reference: https://github.com/dagit/dotfiles/blob/master/.vimrc
23:53:41 <lispy> that assumes you have a solarized theme in your terminal
23:53:58 <nitrix> lispy: https://github.com/nitrix/dotfiles/blob/master/link/vimrc
23:53:59 <lispy> (remove line 22 if you don't)
23:54:31 <lispy> ah, you use ctrlp, I've been meaning to set that up forever
23:54:41 <nitrix> lispy: Yeah, I just need to try the different extensions or roll something of my own. I'm not sure yet. The hlint tool and ghc-mod seems the most promising.
23:54:57 <lispy> I've been meaning to try ghc-mod
23:55:02 <lispy> Looks promising
23:55:20 <nitrix> lispy: Yeah, my Ctrl-P also ignore anything in .gitignore. Very very handy.
23:55:40 <sccrstud92> ive heard good things about hdevtools as well
23:56:25 <julianleviston> *cough* leksah
23:56:25 <lispy> nitrix: you might try zsh. It supports all the parts of bash you probably care about, plus some nice stuff on top.
23:57:00 <sccrstud92> whats the best feature that zch has that bash doesnt?
23:57:06 <sccrstud92> oh wait
23:57:09 <sccrstud92> thats probably off topic
23:57:15 <lispy> good point
23:57:56 <lispy> sccrstud92: well, briefly I would say that zsh improves on bash but I don't know if either has more features. globs like **/*.foo are nice in zsh
23:58:04 <lispy> sccrstud92: and ssh tab completion is nice too
23:58:20 <johnw> hi lispy 
23:58:25 <lispy> johnw: Hi!
23:58:31 <johnw> ltns
23:58:33 <lispy> johnw: how have you been?
23:58:42 <johnw> pretty much, just Haskelling as always :)
23:59:02 <johnw> actually, far more Coq'ing than Haskelling, but I'm using the two together
23:59:11 <lispy> nice! I haven't had an excuse to haskell in...well far too long.
23:59:24 <johnw> did you attend OPLSS again?
23:59:28 <lispy> I've been doing a lot of C/assembly
23:59:37 <lispy> No, but that would have been awesome
23:59:50 <lispy> I recently started playing with Isabelle again.
23:59:58 <johnw> that's one I haven't tried
