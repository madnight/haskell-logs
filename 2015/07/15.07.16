00:00:03 <jle`> yayfoxes_: good programmers get stuck all the time
00:00:05 <jle`> like literally every day
00:00:11 <jle`> at least several times
00:00:24 <dramforever> yayfoxes_: when a programmer is not typing he/she is stuck
00:00:25 <exio4> I must be a really good programmer :p 
00:00:49 <solrize> hunteriam, try the wikibook
00:01:10 <hunteriam> Solrize which wiki book?
00:01:14 <yayfoxes_> safetail xs = if length xs > 1 then return \y (x:xs) = xs else error "Blew me up ay?"
00:01:27 <dramforever> yayfoxes_: don't use length
00:01:29 <hunteriam> yayfoxes_: it's hard for most everyone at first dwai
00:01:34 <solrize> hunteriam, https://en.wikibooks.org/wiki/Haskell/Category_theory
00:02:02 <dramforever> because it traverses the whole list just to see if it's longer than 1 element
00:02:14 <dramforever> where it = your safeTail function
00:02:14 <yayfoxes_> LOL I can fix that
00:02:21 <dramforever> btw that's hardly safe =P
00:02:24 <yayfoxes_> let's write a counter function
00:02:54 <dramforever> btw safeTail [x] = error "Blew me up ay?"
00:02:56 <dramforever> are you sure?
00:03:30 <exio4> dramforever: who knows.. maybe he is using lazy peano numbers... and his `length` is genericLength .. :p 
00:03:31 <yayfoxes_> how do you write counters in Haskell?
00:03:40 <dramforever> yayfoxes_: what do you mean?
00:03:43 <exio4> yayfoxes_: what's a counter in this context?
00:03:54 <yayfoxes_> it should say if a list is greater than length 1 and that's all
00:04:06 <yayfoxes_> it'll stop as soon as it figures out it's at the second element
00:04:24 <yayfoxes_> if I could do that I'd be so happy
00:04:33 <jle`> btw you probably mean greater than length 0
00:04:43 <jle`> but isn't that what pattern matching is for?
00:04:44 <dramforever> yayfoxes_: there's another way
00:04:46 <exio4> we use pattern matching for avoiding those kind of problems
00:04:57 <jle`> if your pattern matches on (x:xs), then that means already that the length is at least 1
00:05:00 <jle`> :)
00:05:06 <jle`> no list of length 0 will match on (x:xs)
00:05:10 <jle`> ta dah
00:05:15 <yayfoxes_> jle`: Wow
00:05:38 <yayfoxes_> well, I figure I want to write device drivers in userspace with Haskell running on top of GNU Hurd
00:05:47 <yayfoxes_> then I want to make my own microkernel in C
00:06:14 <yayfoxes_> if only there was a dialect of Haskell for systems programming...
00:06:28 <MarcelineVQ> isn't x:xs automatically length 2, or can xs be empty?
00:06:37 <MarcelineVQ> er I mean at least length 2
00:06:37 <yayfoxes_> LOL there is a null function see?
00:06:42 <jle`> xs can be any list, so it can be []
00:06:44 <yayfoxes_> I forgot to read that bit
00:06:53 <jle`> > let (x:xs) = (1:[]) in x
00:06:54 <MarcelineVQ> ok
00:06:55 <lambdabot>  1
00:07:20 <mniip> yayfoxes_, the problem with ring0 haskell is the GC
00:07:48 <yayfoxes_> safetail xs = if not (null xs) then return \y (x:xs) = xs else error "error"
00:07:50 <mniip> or actually any low-level application where C is usd
00:08:03 <dramforever> mniip: so? can't we gc at level 0?
00:08:11 <dramforever> *ring
00:08:26 <mniip> dramforever, we can but at what cost
00:08:34 <yayfoxes_> dramforever: no it'd gc in an interrupt handler and the system will blow up
00:08:51 <yayfoxes_> you'd have to say "turn off gc here"
00:09:06 <yayfoxes_> or get a CPU that's a hardware virtual machine
00:09:24 <dramforever> hmm why can't we gc in interrupt handlers?
00:09:38 <yayfoxes_> dramforever: because interrupts turn something off...forgot what
00:10:08 <mniip> because an interrupt can happen during the GC cycle
00:10:18 <yayfoxes_> ah! there we go!
00:11:02 <yayfoxes_> if there are two interrupts in an interrupt handler the system'll blow up
00:11:45 <yayfoxes_> if you garbage collect in an interrupt handler there will be a page in or page out and another interrupt will come and destroy the system
00:13:12 <dramforever> so...block interrupts inside gc?
00:13:23 <dramforever> no way that's too bad
00:13:46 <dramforever> never mind
00:13:51 <yayfoxes_> no cause the system will need to access some resource during gc and the system will blow
00:14:02 <dramforever> okay I get it
00:14:06 <mniip> well GC has to be an atomic block
00:14:24 <dramforever> mniip: too big isn't it?
00:14:29 <mniip> exactly
00:14:41 <dramforever> now I think we need hardware transactional memory =P
00:14:49 <hunteriam> Can we imagine some sort of thing for which an ID function couldn't be written?
00:14:59 <mniip> linux kernel's gc is primarily refcounting which consists of instruction-level locks
00:15:09 <zipper> Only in this channel with someone say that we need hardware transactional memory.
00:15:12 <mniip> atomic increment/decrement
00:15:15 <dramforever> hunteriam: no
00:15:19 <yayfoxes_> how can the curried function definition mult x y z = x * y * z can be understood in terms of lambda expressions?
00:15:29 <hunteriam> dramforever: what if we go outside Haskell
00:15:57 <mniip> hunteriam, by the definition of a category, every object has an identity morphism
00:16:10 <hunteriam> I ask because a category requires all its objects to have Id functions, so what kind of object would fail that requirement?
00:16:24 <hunteriam> Like, are there any
00:16:28 <dramforever> hunteriam: morphism, not functions
00:16:35 <MarcelineVQ> >id undefined
00:16:35 <yayfoxes_> mniip: are there paradoxes or anything else exciting in computer science?
00:16:40 <dramforever> they are different, because morphisms are more general
00:16:57 <mniip> hunteriam, imagine a set of comparable objects
00:17:17 <mniip> with a morphism between a and b if a > b
00:17:32 <zipper> Everyone step back. I'm writing an important blog post.
00:17:34 <mniip> you have morphism transitivity, but no identity morphisms
00:17:45 <mniip> as such it's not a category
00:17:50 <yayfoxes_> zipper: what's it about?
00:18:00 <hunteriam> How could a Morphism exist on,y if a > b
00:18:15 <exio4> that's part of the definition of the structure
00:18:29 <zipper> yayfoxes_: a devel server that is supposed to work for all WAI compliant haskell web applications.
00:18:41 <yayfoxes_> oooh
00:18:56 <Perlkonig> what's WAI?
00:19:08 <zipper> Web Application Interface.
00:19:31 <mniip> hunteriam, we define the collection of morphisms as one including a -> b for all a and b in the category, such that a > b
00:19:37 <zipper> Basically a conventional API that haskell web apps should expose
00:20:08 <zipper> Perlkonig: yayfoxes_ https://github.com/urbanslug/yesod-devel
00:20:13 <Perlkonig> is there a package called kaWAIi yet?
00:20:49 <yayfoxes_> how can the curried function definition mult x y z = x * y * z can be understood in terms of lambda expressions?
00:21:04 <zipper> Perlkonig: What does that mean?
00:21:10 <mniip> yayfoxes_, "be understood in terms of lambda expressions"?
00:22:07 <yayfoxes_> mniip: yes
00:22:13 <adarqui> i'm a math noob but this HoTT stuff is cool.
00:22:14 <mniip> what is that supposed to mean
00:22:51 <yayfoxes_> there's a lambda function which will return a function x which will return another * y which will return another * z
00:22:57 <Perlkonig> https://en.wikipedia.org/wiki/Kawaii
00:23:42 <Hijiri> translation note: kawaii means cute
00:23:52 <Perlkonig> mult = \x -> \y -> \z -> ((*) (((*) x) y)) z
00:23:53 <yayfoxes_> a function that takes a parameter x which is passed to another function which takes parameter y and another that takes a parameter z
00:23:55 <dramforever> @hackage loli
00:23:56 <lambdabot> http://hackage.haskell.org/package/loli
00:24:00 <dramforever> @hackage miku
00:24:00 <lambdabot> http://hackage.haskell.org/package/miku
00:24:16 <dramforever> interestingly these are also web frameworks
00:24:31 <yayfoxes_> Perlkonig: I might never understand this
00:24:43 <Perlkonig> yayfoxes_: what's the problem?
00:24:43 <yayfoxes_> can you guys work with me so I understand everything?
00:24:57 <Perlkonig> or rather: what's the first bit that's unclear?
00:25:24 <yayfoxes_> I see how z is passed to the function * which is passed to the function that takes y
00:25:36 <yayfoxes_> I think it's unclear because it's new to me
00:25:49 <yayfoxes_> maybe if I was given a quiz...
00:26:46 <Perlkonig> 'foo x y z = ...' is syntactic sugar for 'foo = \x y z -> ...' is syntactic sugar for 'foo = \x -> \y -> \z -> ...'
00:27:09 <yayfoxes_> holy cow
00:27:11 <hunteriam>     Mniip so is this imaginary collection contain only objects from the same category as >?
00:27:18 <yayfoxes_> well then how do you understand all this?
00:27:19 <hunteriam> Does*
00:27:33 <Perlkonig> yayfoxes_: what's there to understand? it's purely mechanical
00:27:55 <yayfoxes_> Perlkonig: *sigh* I guess I just read it over and it becomes clear
00:28:15 <mniip> hunteriam, > is not from the category
00:28:23 <mniip> > is the relation on the category's objects
00:28:24 <lambdabot>      Not in scope: ‘is’
00:28:24 <lambdabot>      Perhaps you meant one of these:
00:28:24 <lambdabot>        ‘id’ (imported from Data.Function),
00:28:33 <hunteriam> Lel
00:29:44 <hunteriam> Ok, so I understand how we could define a collection without the ID Morphism (could i call this the isomorphism?) but are there any real world examples of a similar collection?
00:30:01 <mniip> isomorphism has nothing to do with this
00:30:17 <mniip> the > relation is a real world example
00:30:34 <mniip> seeing that its brother >= makes a very well recognized total order category
00:30:37 <yayfoxes_> mniip: ok can you give me a project as a quiz?
00:32:40 <hunteriam> I mean, what sort of objects would fill this collection?
00:32:53 <hunteriam> Like are there any objects that would actually fit in this collection?
00:33:04 <hunteriam> mniip:
00:33:31 <mniip> any comparable objects?
00:33:38 <mniip> booleans for example
00:33:59 <mniip> the morphism collection would then include 'True -> False' and nothing else
00:34:26 <mniip> while a total order category would also feature 'True -> True' and 'False -> False'
00:36:42 <verement> > let halve = go (id,id) where { go (af,zf) (x:y:rs) = let zf' = zf . (x:) . (y:); (z:_) = zf' [] in go (af . (z:), tail . zf') rs; go (af,zf) [] = (af [], zf []) } in halve [1..10]
00:36:43 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
00:37:17 <yayfoxes_> verement: WOW
00:40:40 <hunteriam>  Oh I see, so even though appropriate morphisms exist to create a category for booleans, this collection isn't one because we haven't allowed those morphisms in our collection?
00:40:46 <mniip> > let halve = join go where go (_:_:xs) (z:zs) = fmap (z:) $ go xs zs; go xs zs = (zs, []) in halve [1..10]
00:40:48 <lambdabot>  ([6,7,8,9,10],[1,2,3,4,5])
00:41:21 <yayfoxes_> I want an alarm clock app to wake me up in the morning
00:41:34 <hunteriam> For what device?
00:41:50 <yayfoxes_> but how do I test my programming knowledge? I want to write this program for Linux using Qt 5
00:41:57 <yayfoxes_> ...in Haskell
00:42:03 <hunteriam> There is a qt library
00:42:37 <hunteriam> I don't know what library you'd use for playing sounds, but I'd bet one exists
00:42:40 <mniip> yayfoxes_, https://www.google.com/search?q=7+am+timer
00:43:03 <hunteriam> mniip: he wants to write an app for that
00:43:11 <mniip> ahwell
00:43:57 <mniip> yayfoxes_, writing a gui program in haskell is less of haskell knowledge and more of working with libraries knowledge
00:44:22 <yayfoxes_> mniip: well then erm...what do I write to test my knowledge of haskell and programming in general?
00:44:27 <mniip> still a useful experience but it's something completely different
00:45:14 <mniip> yayfoxes_, idk, some problem sets?
00:45:28 <yayfoxes_> ok
00:45:33 <mniip> like euler problems, or 99 haskell problems
00:45:44 <hunteriam> Honestly I'd bet you could test your knowledge writing any full fledged app, although using at etc. is not going to get you a lot of Haskell experience except in making all the libraries work together
00:46:00 <hunteriam> I learn Haskell writing a simple 3d renderer for a graphics class
00:46:14 <hunteriam> It was a good experience IMO
00:46:25 <mniip> hunteriam, you mean the mathy part?
00:46:52 <hunteriam> The mathy part was fun to translate to Haskell, but I also learnt a bit about structuring Haskell programs
00:47:06 <mniip> transforming, projecting, z-ordering, texturing
00:47:13 <hunteriam> Although I don't really think there is uniform structure to Haskell programs that I'm aware of
00:47:27 <hunteriam> Didn't get up to texturing, but those other things yes
00:47:48 <hunteriam> Had to write a matrix implementation, which was hard to maintain at first
00:48:01 <mniip> I never got past z-ordering :P
00:48:08 <hunteriam> Had like 50 tranposes just scattered to make matrix multiplication work
00:48:17 <hunteriam> Well I have my teacher to thank for all of that
00:48:30 <yayfoxes_> hell I need maths training first, so Khan Academy
00:48:31 <hunteriam> I don't remember how to do z ordering any more, sadly
00:49:08 <yayfoxes_> z ordering is finding the set of z coordinates less than anothe set of z coordinates I think
00:49:09 <hunteriam> It's honestly optional, it was purely coincidence that I choose a vaguely mathy project to learn Haskell with
00:49:40 <hunteriam> Yea and its trying to not draw shapes that are behind other shapes
00:49:41 <mniip> yayfoxes_, z-ordering is drawing closer objects over further ones and not the other way around
00:51:21 <yayfoxes_> oh, so greater than then..I see
00:52:22 <mniip> I wonder why does everyone use inverse square roots though
00:52:33 <mniip> instead of the more mathematically correct arctangents
00:53:04 <mniip> I mean obviously performance considerations, but it does distort the picture a bit
00:53:06 <hunteriam>  Probably faster?
00:53:22 <hunteriam> How significant is the distortion?
00:53:32 <hunteriam> Also, are you sure of which one they use in modern engines?
00:55:07 <mniip> hunteriam, have you seen a rendering engine where straight lines near the end of the FOV get distorted into curves?
00:55:32 <hunteriam> Very possibly, I haven't thought to look for it before though
00:55:36 <mniip> that's how real projection behaves
00:57:09 <mniip> (think about fish-eye lenses)
00:57:58 <hunteriam> I guess if you map the world onto your eyes it would curve
00:58:03 <hunteriam> Is that the reason?
00:59:12 <Perlkonig> https://dalecooper57.files.wordpress.com/2014/04/wpid-print-gallery.jpg
01:05:33 <yayfoxes_> I have this code, there's a problem: non-exhaustive pattern matches. How do I fix it?
01:05:40 <yayfoxes_> elementAt (x:xs) 1 = x
01:05:42 <yayfoxes_> elementAt (x:xs) n = elementAt xs (n-1)
01:06:29 <yayfoxes_> elementAt [] n = error "Bad idea!?"
01:06:33 <yayfoxes_> will that fix it?
01:06:45 <hunteriam> Yes
01:07:06 <hunteriam> Also non exhaustive pattern matches are allowed, it's just a warning
01:07:18 <yayfoxes_> elementAt [] 0 = []
01:07:28 <hunteriam> Also, I don't think you can pattern match to 1, maybe?
01:07:31 <yayfoxes_> there's another.
01:07:49 <verement> that may not type check
01:07:53 <yayfoxes_> hunteriam: actually, yes you can pattern match to 1, and it does work!
01:08:21 <yayfoxes_> why won't that type check?
01:08:30 <hunteriam> Holy crap, I don't know if that's a good idea, but that will totally save me some code
01:08:31 <verement> what is the type of your function?
01:08:48 <yayfoxes_> no idea, can you help me study types?
01:09:02 <yayfoxes_> I guess it's...
01:09:21 <yayfoxes_> elementAt :: [a] -> Int -> a
01:09:28 <verement> OK, sounds good
01:09:34 <yayfoxes_> and [] is not an a but an [a]
01:09:43 <verement> exactly
01:11:53 <mniip> [11:08] (hunteriam) [08:07:06] Also, I don't think you can pattern match to 1, maybe?
01:12:03 <mniip> it is tricky, yes
01:12:26 <mniip> pattern matching on polymorphic literals adds an Eq constraint
01:13:26 <mniip> :t \(x@1) -> x
01:13:27 <lambdabot> (Eq a, Num a) => a -> a
01:16:16 <hunteriam> Is @ pattern matching in lambd as?
01:16:48 <dramforever> no, it's bind to var and pattern matching
01:16:51 <dramforever> it's an as pattern
01:16:54 <AjaxCrixum> As of now, I'm learning C, but I haven't gotten too far into it to be "corrupted by imperative thinking" yet, and was wondering if learning a purely functional language like Haskell before C would make learning C easier and make me a better C programmer in the long run. Also, would you say going from Haskell to C is easier than going from C to Haskell? Thanks in advance for any answers I receive. :)
01:17:33 <mniip> interesting question
01:17:35 <slack1256> AjaxCrixum: you can't get corrupted from learning C
01:17:35 <dramforever> AjaxCrixum: I would say going from C to haskell is easier because many tutorials assume experiences in imperative languages
01:17:35 <hunteriam> I learnt imperative programming through and through and then learnt Haskell. It was totally hard. I'll tell you this, most schools teach functional programming first
01:17:52 <hunteriam> It's better supported for sure
01:18:02 <Perlkonig> slack1256: [citation needed]
01:18:03 <hunteriam> But lyah doesn't
01:18:07 <hunteriam> And that's all I needed
01:18:07 <mniip> C is a great first language though
01:18:11 <dramforever> because there are just too many imperative programmers
01:18:20 <slack1256> my first lang was haskell (LYAH is a national treasury)
01:18:58 <mniip> my first language was pascal and look where I am now!
01:18:59 <dramforever> slack1256: *global
01:19:06 <slack1256> Perlkonig: nah, that is just us being smug in a joke sense, some take seriously though
01:19:09 <hunteriam> AjaxCrixum: I'd bet money haskell to c is easier than the reverse, despite being not as supported, thanks to lyah.
01:19:18 <dramforever> my first language is (gasp...) windows batch
01:19:20 <Perlkonig> slack1256: I disagree
01:19:38 <hunteriam> I still don't know windows batch
01:19:39 <slack1256> @slap Perlkonig
01:19:39 <lambdabot> I'd rather not; Perlkonig looks rather dangerous.
01:19:40 <yayfoxes_> here's my problem solutions up to problem 4 of 99 haskell problems: http://fpaste.org/244894/
01:19:46 <slack1256> indeed lambdabot
01:19:59 <mniip> hold on batch is a language?
01:20:12 <mniip> as in, it has rules?
01:20:22 <dramforever> mniip: it has conditions and goto
01:20:34 <slack1256> Actually a better first language is VHDL (I am not joking)
01:20:46 <hunteriam> yayfoxes_: just a totally optional note, you can replace variables unused with _ for efficiency's sake
01:20:51 <yayfoxes_> mniip: no type NO LAZAH PRINT MAH into a Windows batch file and your printer will catch fire then print out a wormhole and a black hole
01:20:59 <slack1256> it has signatures, async programming (FRP like) and separation of state like variables (latchs)
01:21:08 <hunteriam> yayfoxes_: myLastButOne (y:_:[]) = y for example
01:21:18 <dramforever> hunteriam: efficiency? as in coding efficiency or runtime efficiency?
01:21:24 <mniip> slack1256, you can't ascend from vhdl as wella s you can descend from assembly
01:21:32 <dramforever> for the latter I don't think there's any improvement
01:21:45 <yayfoxes_> then the computer will explode and it will reinstall your Windows into an operating system from the 1950's
01:22:19 <hunteriam> dramforever: doesn't it save memory usage or something? It doesn't create any bindings? Probably not now that I think about it... But I heard it did something
01:22:38 <yayfoxes_> the monitor will become possessed by a ghost and no computer will be driving it but it will run IBM's MVS
01:22:41 <dramforever> hunteriam: there's a thing called optimization
01:23:09 <hunteriam> Go on
01:23:10 <dramforever> there's almost always some optimization going on, because otherwise the code would have been really bloated
01:23:20 <hunteriam> You mean by the compiler?
01:23:23 <dramforever> yes
01:23:30 <hunteriam> So is the use of _ purely visual?
01:23:34 <Perlkonig> even without optimization, bindings don't consume memory. you're just pointing into an existing structure
01:23:54 <mniip> also verilog is objectively better than vhdl
01:24:09 <hunteriam> I feel that to understand why that's true would require a very in depth conversation and I'm already trying to understand other things
01:24:27 <bennofs> hunteriam: yes, and the compiler can also warn you when you forgot to use a named variable (for example, if you wrote f x = 3, then the compiler would warn you about the unused x variable)
01:25:00 <slack1256> mniip: only if you are in america
01:25:05 <hunteriam> Perlkonig: what do you mean you're pointing into an existing sructure
01:25:18 <mniip> slack1256, huh
01:25:39 <dramforever> hunteriam: oh and you can use _ multiple times
01:26:09 <Perlkonig> hunteriam: when you're pattern matching, you're examining an existing structure. you're not allocating anything new
01:26:38 <slack1256> unless the thunk was cheaper than the structure right?
01:27:01 <Perlkonig> that's orthogonal to binding
01:27:17 <AjaxCrixum> So, I should stick with C and then come to Haskell?
01:27:38 <mniip> slack1256, how is that possible
01:28:10 <bennofs> slack1256, Perlkonig: I think there are a few optimizations that GHC makes here so this topic is quite complicated
01:28:33 <mniip> pattern matching doesn't create thunks (besides ~)
01:28:48 <bennofs> slack1256, Perlkonig: for example, consider let z = (a_very_big_structure, a_very_small_structure) in case z of (_, x) -> x
01:29:28 * Perlkonig considers
01:29:33 <bennofs> the 'case z of ...' will be a thunk in GHC, and as long as it is not evaluated, it will contain a reference to 'z', which again references a_very_big_structure
01:29:56 <mniip> bennofs, but dmdanal
01:29:58 <yayfoxes_> Cale: how do you reverse a list efficiently again? Guys?
01:30:11 <Perlkonig> foldl
01:30:12 <mniip> yayfoxes_, literally reverse
01:30:20 <dramforever> yayfoxes_: reverse is efficient enough, no?
01:30:34 <bennofs> Perlkonig, slack1256: so this will use more memory than neccessary. But GHC can spot this case and evaluated the case eagerly
01:30:59 <Perlkonig> bennofs: ok, but what does that have to do with _ ?
01:31:27 <slack1256> right
01:31:40 <yayfoxes_> mniip: there's a technique to reverse it efficiently if you implement reverse' yourself
01:31:54 <bennofs> hmmm, I guess I don't know what I thought anymore... :p
01:32:12 <mniip> _ is really a synonym for a unique variable name, with the clear hint to the compiler that it's unused
01:32:43 <hunteriam> Does the compiler ever need this hint?
01:32:45 <Perlkonig> seems like it'd apply case-of-constructor ... if that is a real optimization rule
01:32:53 <mniip> yayfoxes_, I don't think you can come up with a more efficient implementation than reverse
01:32:58 <crocket> hi
01:33:01 <yayfoxes_> @src reverse
01:33:01 <lambdabot> reverse = foldl (flip (:)) []
01:33:05 <crocket> Haskell is largely functional.
01:33:22 <bennofs> Perlkonig: yes, GHC sometimes also evaluates cases at compile time (in this case, it would perhaps inline z and discard the case)
01:33:24 <slack1256> that seems efficient
01:33:28 <mniip> for the record, that's not the ghc's implementation
01:33:28 <Perlkonig> Haskell is functionally large.
01:33:44 <mniip> and ghc also includes a load of optimization rules for it
01:33:47 <dramforever> functional is largely haskell =P (is it?)
01:33:50 <hunteriam> Someone once told me "Haskell is automatically slower than c, because you can't give compiler hints", is this completely false, or partly true?
01:34:08 <Perlkonig> hunteriam: C is automatically slower than Haskell because you can't give compiler hints
01:34:09 <slack1256> RULES are hints right?
01:34:16 <Perlkonig> yes
01:34:16 <dramforever> hunteriam: I don't know, because I don't give compiler hints
01:34:17 <AjaxCrixum> Largely functional Haskell is
01:34:26 <Perlkonig> slack1256: rules and specialize pragmas
01:34:27 <bennofs> Perlkonig: that is probably wrong. I have yet to see where that is true in practice :D
01:34:27 <slack1256> pipes uses them to good results
01:34:33 <crocket> How does haskell deal with the log level of a logging library?
01:34:34 <hunteriam> Large Haskell functions
01:34:42 <dramforever> hunteriam: what are "compiler hints"?
01:34:47 <slack1256> @where hslogger
01:34:47 <lambdabot> I know nothing about hslogger.
01:34:50 <crocket> The log level makes log functions impure!!!
01:34:59 <hunteriam> Honestly, I'm probably misquoting and I don't know what they are
01:35:03 <Perlkonig> crocket: easy, don't have log functions. have log actions!
01:35:09 <crocket> Is log treated as log I/O?
01:35:09 <bennofs> hunteriam: you probably have to work really hard if you want exactly as good performance as C
01:35:18 <bennofs> hunteriam: but it will not be *much* worse
01:35:25 <slack1256> @where hslogger
01:35:25 <lambdabot> I know nothing about hslogger.
01:35:29 <Perlkonig> crocket: also, what about log levels causes impurity?
01:35:32 <bennofs> @hackage hslogger -- slack1256 
01:35:32 <lambdabot> http://hackage.haskell.org/package/hslogger -- slack1256
01:35:42 <slack1256> thanks
01:35:44 <dramforever> can anyone see my message?
01:35:51 <Perlkonig> dramforever: no
01:36:00 <pacak> dramforever: Nope
01:36:05 <dramforever> okay thanks I'll fix my connection
01:36:16 <Perlkonig> you're not even online
01:36:26 <slack1256> crocket: that package implements a syslog handler, you can see how it is structured
01:36:32 <crocket> Perlkonig, If you configure your log library to curtail log below :info level, instances of log functions won't know this.
01:36:45 <Perlkonig> crocket: why not?
01:36:46 <pacak> dramforever: Try switching it off and back on again, usually works for me.
01:37:12 <crocket> Perlkonig, If the log level is set as a dynamic variable, then log functions will not know.
01:37:20 <Perlkonig> what's a dynamic variable?
01:37:24 <crocket> Oh sorry
01:37:27 <crocket> It's a clojure term.
01:37:45 <Perlkonig> is clojure a lisp?
01:37:47 <crocket> yes
01:37:51 <Perlkonig> thought so
01:38:16 <crocket> Clojure is largely functional although it doesn't force you to segregate IO
01:38:19 <Perlkonig> (attaching "dynamicness" to variables instead of bindings is a lisp meme/antipattern/brain damage)
01:38:52 <slack1256> Perlkonig: you go to /g/ right?
01:38:56 <Perlkonig> no
01:39:07 <slack1256> thank god
01:39:09 <Perlkonig> (install gentoo)
01:39:28 * dramforever feels like opening a magic scroll every time he types import Control.Lens
01:39:29 <crocket> Perlkonig, Ok, you called (set-log-level :info) and then (log/debug "ohai"). Then, debug logs are curtailed.
01:39:59 <Perlkonig> I can do that in C with a global variable
01:40:08 <crocket> Perlkonig, How do you do that in haskell?
01:40:09 <Perlkonig> anything I can do in C, I can do in Haskell
01:40:13 <crocket> I agree that dynamic variables are a brain fuck.
01:40:20 <Perlkonig> but I probably wouldn't design the library that way
01:40:33 <crocket> How would you design it?
01:40:49 <dramforever> a writer maybe?
01:40:56 <Perlkonig> I haven't thought about it yet. I'd first read how hslogger or similar packages do it
01:41:27 <crocket> I have a feeling that in haskell, a log configuration object will be carried along.
01:42:38 <dramforever> crocket: well how about this:
01:42:38 <crocket> Clojurists usually avoid dynamic vars.
01:42:48 <Perlkonig> ah, looks like hslogger does use global variables
01:42:55 <Perlkonig> well, then
01:43:01 <dramforever> class MonadLogger w m | m -> w where log :: w -> m ()
01:43:09 <crocket> Perlkonig, Haskell guys also make that compromise.
01:43:20 <dramforever> wait wait never mind I got messed up
01:43:49 <AjaxCrixum> Any C programmers in here who can help me with a small problem?
01:44:00 <dramforever> AjaxCrixum: /j ##c
01:44:09 <Perlkonig> AjaxCrixum: /j #haskell-blah
01:44:20 <dramforever> that could also work
01:55:47 <Gurkenglas> Why do so many hackage doc sites contain the same instance line twice?
01:55:55 <hunteriam> Example?
01:56:14 <mniip> [11:41] (crocket) I have a feeling that in haskell, a log configuration object will be carried along.
01:56:27 <xificurC> a painless, cross-platform GUI library one can recommend? One that can be packaged as a stand-alone app (i.e. no need for users to install anything, just have everything statically)
01:56:27 <mniip> unsafePerformIO newIORef
01:58:29 <Gurkenglas> (So I went to the newest version of the package where I saw my latest example, saw source links, and found that the source uses a lazy version for one and a strict for the other. hunteriam, https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html )
02:08:58 <Gurkenglas> I'm reading https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-IORef.html and wondering why there isn't something like a lens for this in there, meaning a function Functor f => (a -> f b) -> IORef a -> f (IORef b).
02:10:17 <Perlkonig> that would give me (a -> b) -> IORef a -> IORef b
02:10:19 <Perlkonig> seems wrong
02:10:34 <dramforever> that would also give me IORef a -> a
02:10:37 <dramforever> horribly wrong
02:10:46 <slack1256> IORef seem older than Functor *goes to check*
02:10:50 <dramforever> so maybe something like in this package
02:10:56 <dramforever> @hackage lens-actions
02:10:56 <lambdabot> http://hackage.haskell.org/package/lens-actions
02:11:17 <dramforever> no, lens-action is the right one
02:13:55 <Gurkenglas> Right, it should be Functor f => (a -> f b) -> IORef a -> IO( f (IORef b)), of course.
02:14:39 <Gurkenglas> Why is IORef a -> IORef b wrong?
02:14:58 <Gurkenglas> *IORef a -> IO (IORef b), which you probably don't think to be wrong <.<
02:15:26 <dramforever> Gurkenglas: what about MonadIO m => (a -> m b) -> IORef a -> IO (IORef b)
02:15:44 <dramforever> well it should be MonadIO m => (a -> m b) -> IORef a -> m (IORef b)
02:16:48 <Gurkenglas> (And I guess the general problem is that the returned IORef won't be updated by modifying the original IORef a)
02:17:19 <dramforever> yeah
02:17:35 <Gurkenglas> (...or maybe it should be? It certainly wouldn't go the other way)
02:18:11 <dramforever> Gurkenglas: btw it would be cleaner if it were in a state monad rather than an IO Ref
02:18:14 <dramforever> *IORef
02:18:42 <Gurkenglas> Where are IORefs better than the State monad?
02:19:00 <dramforever> concurrency?
02:19:46 <magnars> noob question :-) what do you call functions like map and filter - ie, functions that take a list and apply a function to each item in that list?
02:19:46 <slack1256> for doing a unsafePerformIO on a top-level function
02:20:02 <slack1256> magnars: higher order functions
02:20:13 <slack1256> sometimes also combinators
02:20:21 <dramforever> slack1256: not really I guess
02:20:37 <dramforever> magnars: that "higher order functions" is for functions that take other functions
02:20:50 <dramforever> but indeed map and filter are higher order functions
02:21:23 <dramforever> magnars: why do you need a name? isn't that one of the truly hard problems in compsci? =P
02:21:49 <magnars> hah, point-free programming for the win :)
02:21:49 <bennofs> magnars: map and filter a special forms of list "folds"
02:22:02 <magnars> nice, "list folds"
02:22:25 <dramforever> magnars: =P
02:25:11 <Gurkenglas> The definition is having the form foldr f [] for some f?
02:26:20 <cow_2001> any stackage people here?
02:26:49 <frerich> magnars: I'd refer to such functions as 'list processing functions'. :-)
02:27:15 <magnars> thanks :)
02:27:18 <dramforever> I'd refer such functions as "functions that take a list and apply a function to each item in that list" =P
02:27:39 <dramforever> most precise one =P
02:27:44 <slack1256> but that is only map
02:27:56 <dramforever> not really, see original question =P
02:28:03 * dramforever is probably joking
02:28:08 <slack1256> ohh
02:28:14 <slack1256> right!
02:29:30 <magnars> I guess my question example wasn't entirely accurate, but thanks for anyway, dramforever ^^
02:29:39 <dramforever> =P
02:30:07 <dramforever> magnars: don't worry just give it the best name you can think of and explain it when the name is used
02:30:19 <dramforever> and don't spend too long thinking
02:30:26 <magnars> good advice
02:30:58 * slack1256 presents lambda calculus as an effort to avoid naming things
02:31:25 <wordsarewind> -.-
02:32:19 <Gurkenglas> Hmm. Would (a -> Int) -> [a] -> [a]; \f -> foldr ((++) . replicate . f) [] fall into your category of functions, magnars?
02:33:22 <slack1256> > let wat f = foldr ((++) . replicate . f) []
02:33:24 <lambdabot>  <no location info>:
02:33:24 <lambdabot>      not an expression: ‘let wat f = foldr ((++) . replicate . f) []’
02:33:31 <slack1256> @let wat f = foldr ((++) . replicate . f) []
02:33:33 <lambdabot>  .L.hs:150:23:
02:33:33 <lambdabot>      Couldn't match type ‘a0 -> [a0]’ with ‘[a1]’
02:33:33 <lambdabot>      Expected type: Int -> [a1]
02:35:32 <slack1256> What libraries do cool tricks tying the knot? Things with lazy maps or graphs
02:35:36 <Gurkenglas> oops.
02:35:54 <slack1256> post usually show how to do it with lists. But is always the same example
02:36:05 <dramforever> slack1256: AFAIK Data.Map.Map can do tying-the-know
02:36:20 <Gurkenglas> Why's this not work? http://lpaste.net/136697
02:36:26 <Gurkenglas> @letlpaste 136997
02:36:26 <lambdabot>  I couldn't find any paste under that ID.
02:36:30 <Gurkenglas> @letlpaste 136697
02:36:30 <lambdabot>  Parse failed: Parse error: ..
02:36:59 <bennofs> slack1256: FRP has a lot of tying-the-knot-like stuff
02:37:01 <dramforever> Gurkenglas: it doesn't??
02:37:05 <frerich> Gurkenglas: I think '..' is syntax reserved for [1..n]
02:37:19 <dramforever> oh yes!
02:37:24 <slack1256> all the implementations or some in specific?
02:37:25 <Gurkenglas> @letlpaste 136697
02:37:25 <lambdabot>  Parse failed: Left-hand side of type signature is not a variable: (,,)
02:37:40 <Gurkenglas> Oh right, (,,) is reserved too
02:37:50 <bennofs> :t (,,)
02:37:51 <lambdabot> a -> b -> c -> (a, b, c)
02:38:04 <Gurkenglas> @letlpaste 136697
02:38:04 <lambdabot>  Parse failed: Parse error: )
02:38:06 <Gurkenglas> ???
02:38:16 <frerich> Gurkenglas: See the 'reservedop' production in https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010
02:38:19 <bennofs> :o, letlpaste, I'll have to remember that
02:38:47 <dramforever> yeah +1
02:38:51 <Gurkenglas> (._.) isn't in there, why doesn't it work?
02:39:04 <Gurkenglas> You guys should read the command list. Seen this one?
02:39:05 <dramforever> Gurkenglas: _ isn't allowed
02:39:15 <Perlkonig> _ is a letter
02:39:15 <Gurkenglas> @@ @unpl @pl f x = x
02:39:15 <lambdabot>  f a = a;
02:39:25 <frerich> Gurkenglas: '..' is in there.
02:39:26 <dramforever> yes I know this
02:39:39 <bennofs> Gurkenglas: I know that one. There is also @. or something
02:39:48 <dramforever> @@ @pl @djinn @type maybe
02:39:49 <lambdabot>  (line 1, column 39):
02:39:50 <lambdabot> unexpected '>'
02:39:50 <lambdabot> expecting operator
02:39:54 <dramforever> =(
02:40:08 <Gurkenglas> Yea pl and djinn dont compose. Someone make them, they should!
02:40:22 <dramforever> @@ @pl @djinn a -> b -> a
02:40:23 <lambdabot>  f = const
02:40:30 <dramforever> Gurkenglas: they do
02:40:31 <Perlkonig> @eval 2 + 2
02:40:42 <Perlkonig> (perversely)
02:40:43 <Gurkenglas> dramforever: Only when there aren't pattern matches
02:40:49 <dramforever> yeah
02:42:14 <bennofs> @. pl . djinn type id
02:42:15 <lambdabot> f = id
02:45:33 <kuribas> functional programming has nothing to do with HOFs, right?  Otherwise ruby, smalltalk, c# etc would functional programming languages...
02:46:08 <dramforever> kuribas: well I guess it's a matter of style
02:46:51 <koomi> HOFs are a requisite for functional programing
02:47:09 <kuribas> But mutating state with HOFs isn't functional programming right?
02:47:28 <dramforever> well it isn't *purely*-functional
02:47:40 <koomi> the primary mechanism of abstraction in the languages you mentioned is not functions, so I would not consider them functional
02:48:43 <kuribas> https://en.wikipedia.org/wiki/Functional_programming
02:48:54 <kuribas> "In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data"
02:49:05 <Gurkenglas> (Anyway what I meant earlier was \f -> foldr (\x -> (replicate (f x) x ++)) [])
02:49:37 <dramforever> kuribas: well I mean the language isn't purely-functional
02:49:55 <kuribas> yes
02:50:00 <dramforever> and I guess you could do functional programming in those languages
02:50:09 <dramforever> it's just not as nice as functional languages
02:50:26 <dramforever> because these languages are designed to support a functional style
02:51:20 <kuribas> common lisp isn't functional right?
02:51:50 <keko_> it's not purely functional
02:51:58 <dibblego> crikey
02:52:03 <keko_> but it has features that make writing functional code very easy
02:52:03 <Phillemann> When trying to install reactive-banana I get the error "user error: (The package 'reactive-banana' requires Cabal library version 1.22.4.0 but no suitable version is installed.)
02:52:08 <Phillemann> I see no such dependency in the cabal file.
02:52:21 <Phillemann> Also, _building_ the library works.
02:52:21 <keko_> when compared with something like C
02:52:33 <Gurkenglas> @pl \f -> concatMap (\x -> replicate (f x) x) -- Neat!
02:52:33 <lambdabot> (=<<) . (replicate =<<)
02:52:45 <bennofs> Phillemann: what OS?
02:52:53 <Phillemann> Ubuntu Linux
02:53:05 <bennofs> Phillemann: also, output of cabal --version
02:53:31 <Phillemann> http://lpaste.net/136704
02:53:48 <bennofs> Phillemann: are you installing from source?
02:54:04 <Phillemann> Yes.
02:54:11 <bennofs> Phillemann: ok, try rm -r dist
02:54:30 <bennofs> Phillemann: or alternatively, cabal clean
02:54:41 <Phillemann> Oh, that worked. Thanks
02:55:28 <wordsarewind> Gurken, this function of yours is nice
02:55:55 <bennofs> Phillemann: reason: cabal stores some version-specific data in dist (like executables compiled against a particular Cabal library version, or configuration data only readable by a particular Cabal version). Not sure how you ended up with Cabal 1.22 data there though :)
02:56:22 <wordsarewind> a sort of dynamically applied replicate
02:56:24 <wordsarewind> very nice
02:56:29 <Phillemann> bennofs: Ah ok. It's explainable, I temporarily switched to stackage-nightly, then switched back. :)
03:18:54 * hackagebot Unique 0.4.1 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.4.1 (kapral)
03:49:10 <Node_> Join our forum ! http://syntaxcore.com
03:49:17 <hvr> Node_: why?!
03:49:33 <Node_> I'm trying to create a small community to help eachother :)
03:49:53 <hvr> fair enough :)
03:50:55 <Node_> :D
03:51:15 <Node_> So if you want, you can join. Sorry for spam
03:52:07 <frerich> I think 'Discuss general programming languages, such as: C, C++, C#, Basic, Java etc. here. Includes machine languages, and Python. ' is funny. The 'and Python' part. :-)
03:52:24 <hvr> heh
03:52:37 <dramforever> lol
03:52:56 <hvr> I'd consider even funnier if 'Java' was that singled out language =
03:52:57 <hvr> )
03:53:18 <wordsarewind> poor Java
03:53:44 <hvr> yeah... it's only one the major used mainstream languages =)
03:54:03 <wordsarewind> it's only used... never loved
03:54:18 <wordsarewind> :/
03:55:15 <hvr> I'll start caring about Java once it becomes an endangered language =)
03:55:29 <wordsarewind> Java on an iceberg
03:55:55 <wordsarewind> slow sinking into the depths of the artic waters
03:56:03 <wordsarewind> oh dear D:
03:56:34 <tdammers> oh, Java gets lots of love
03:56:44 <tdammers> just not from the kind of people who know what IRC is
03:57:07 <tdammers> super conservative programmers, project managers, IT managers, etc., love it to pieces
03:57:27 <hvr> tdammers: IOW, those that don't know any better? But does ignorance-is-bliss apply here?
03:58:21 <tdammers> hvr: no, that's not even what I meant
03:58:36 <tdammers> they know "better", but their priorities aren't the same
03:58:47 <tdammers> by their priorities, Java *is* better
03:58:53 <hvr> maybe one just needs to let java evolve into a much more complex language, so that managers stop loving it?
03:58:56 * hackagebot consumers 0.1 - Concurrent PostgreSQL data consumers  http://hackage.haskell.org/package/consumers-0.1 (arybczak)
03:59:06 <tdammers> haha
03:59:11 <tdammers> they tried that, but it didn't work
03:59:24 <tdammers> (IMO, Java is quite a complex beast, really)
04:01:25 <bennofs> Isn't OCaml as simple as Java? [at least that was my impression when I used it for a quick script]
04:01:51 <tdammers> my impression is that it's simpler, but I haven't gotten my feet wet yet
04:02:01 <chattered> What's the measure of simplicity?
04:02:11 <silver> Java's libraries complex, but the language? dunno
04:04:20 <bennofs> Haskell sometimes feels too complex to me. where/let? multiple function clauses or one clause with a match? 
04:04:20 * hackagebot rainbox 0.18.0.2 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.18.0.2 (OmariNorman)
04:04:22 <_d0t> ohai
04:04:34 <tdammers> Haskell gives more choice, somehow
04:04:39 <_d0t> can anyone build this with ghc 7.10?
04:04:41 <_d0t> https://github.com/greydot/intern/tree/amp
04:05:01 <_d0t> I dont have it installed and just wanna be sure everything's ok before I send a pull request
04:05:26 <tdammers> I'd say that if you don't know how to solve problems writing simple code, then Haskell would probably make for more complicated code than Java, but if you do, Haskell gives you more tools for simplifying things more easily
04:05:44 <tdammers> as far as the languages themselves go, I'd rather implement a Haskell compiler than a Java one
04:06:16 <bennofs> _d0t: ok, i'll try
04:06:23 <_d0t> bennofs: thank you
04:08:35 <bennofs> _d0t: built fine
04:08:43 <_d0t> bennofs: great! Thanks again!
04:08:45 <bennofs> _d0t: but it gernated some warning
04:08:47 <bennofs> s
04:09:05 <_d0t> bennofs: could you paste in somewhere please?
04:09:05 <bennofs> _d0t: you can fix AMP warnings (redundant imports) by adding import Prelude as the last import statement
04:09:56 <lpaste_> bennofs pasted “intern build log” at http://lpaste.net/136705
04:10:03 <bennofs> _d0t: ^^^
04:10:28 <_d0t> bennofs: auch.. ok
04:10:58 <bennofs> it contains some junk which you can ignore, only lines 76-100 are important
04:11:08 <_d0t> yeah, I see
04:11:24 <bennofs> _d0t: ah, and 110-123
04:11:45 <_d0t> I think I'd better install 7.10 on my machine. This transition is more complicated than I thought.
04:13:42 * dramforever just discovered something interesting: you could use error for debugging =P
04:14:09 <bernalex> dramforever: yep sure.
04:14:21 <dramforever> pretty useful huh =)
04:14:49 <_d0t> btw, is it generally a good idea to use ghc-7.10 for building production code? We still use 7.8.4, and I've been thinking about an upgrade lately.
04:15:30 <dramforever> _d0t: if you have time you should do it
04:15:49 <dramforever> well that's only my advice
04:16:18 <_d0t> dramforever: time is not an issue here really
04:18:33 <bergmark> _d0t: some people recommend always waiting for the second release when a new major version comes out
04:18:48 <bergmark> we are doing that too
04:18:50 <bennofs> _d0t: yeah, and GHC 7.10.2 is about to be released
04:19:14 <bergmark> but i've made our code 7.10 compatible already :)
04:20:17 <_d0t> ok :)
04:20:22 <_d0t> I'll wait then
04:22:17 <bergmark> we also use stackage to decide when to upgrade GHC/packages, as long as there are tickets open there it's probably not worth the effort
04:44:48 <Gurkenglas> tdammers: Super-conservative programmers don't know IRC? Wasn't IRC like usenet generation stuff?
04:47:09 <lieven> blah newfangled IRC toy. BITNET RELAY was way superior
04:48:36 <tdammers> Gurkenglas: today's conservative programmers were born after 1990
04:48:59 <tdammers> also, "conservative" in the sense of "no experiments"
05:02:43 <fabian__> Im getting a wierd error when installing distributive-0.4.4 in a cross-compilation build: distributive-0.4.4/dist/setup/setup: Syntax error: word unexpected (expecting ")") 
05:06:21 <lpaste_> dramforever pasted “Kanren” at http://lpaste.net/136706
05:06:36 <dramforever> I just implemented a miniKanren-style logical language
05:07:19 <dramforever> it has uninterpreted functions and equality constraints 
05:07:54 <dramforever> example at the bottom
05:18:56 <saulzar_> Gr, always get very confused with the errors when I accidentally use a non monadic function inside a do block. 
05:19:58 <Gurkenglas> Where does one use Logic that one wouldn't use Cont?
05:20:03 <dramforever> saulzar_: I once got extremely confused with this: https://ghc.haskell.org/trac/ghc/ticket/10498
05:20:44 <dramforever> Gurkenglas: I don't know, but it seems to be nicer than just lists
05:22:06 <saulzar_> dramforever, It's tough when you make some kind of strong assumption which turns out to be wrong..
05:22:10 <Gurkenglas> What do lists have to do with this? We are talking about replacing the rs in (a -> r) -> r with (r' -> r')
05:22:51 <dramforever> saulzar_: also it's because I think it's more natural because I'm working on a *logical* language
05:23:10 <dramforever> doesn't really look useful for now
05:26:08 <lpaste_> dramforever annotated “Kanren” with “Kanren (annotation)” at http://lpaste.net/136706#a136707
05:26:38 <dramforever> Gurkenglas: wait a sec, what do you mean?
05:27:44 <Gurkenglas> runLogic :: Logic a -> (a -> r -> r) -> r -> r looks like runCont :: Cont r a -> (a -> r) -> r ... oh, Logic works for all r.
05:28:07 <dramforever> anyway I replaced Logic with plain lists in the annotation
05:28:08 <Gurkenglas> I was trying to read your code, saw Logic for the first time (I think) and looked it up on hackage
05:28:23 <Gurkenglas> hmk
05:28:25 <dramforever> oh it's a church-encoded list type
05:30:42 <m-erger> is haskell a good first language?
05:30:46 <earthy> yes.
05:30:51 <dramforever> yes
05:31:30 <dramforever> but you have to use the correct tutorials, because many tutorials assume previous programming experience
05:33:11 <m-erger> what tutorials are those?
05:33:30 <dramforever> sorry I don't really know...
05:33:59 * dramforever wonders if someone else here knows
05:34:06 * apo_ doesn't
05:34:17 <thelarry> m-erger: it is. but it is not an OO language. so if you want to do the "default" OO stuff, then there's probably a faster way to do that. :)
05:36:16 <jvans> Is it common to upload blank packages to deprecate them?(https://hackage.haskell.org/package/snap-app-0.7.0) This threw me off a bit
05:39:33 <thelarry> m-erger: if you want to learn how to code, you should learn (beside the 'default OO language') at least one functional language and at least one language with a clearly defined type system, that's my opinoin. Haskell has both.
05:40:38 <thelarry> but in the industry most companies work with OO language (at least until now :) )
05:41:42 <tdammers> it doesn't matter a lot which language you learn first, as long as you plan on learning others as well once you're comfortable with the first one
05:41:52 <tdammers> my first programming language was Pascal
05:42:10 <tdammers> I learned a lot of Pascalisms, and a lot of general programming concepts
05:42:33 <tdammers> then I learned C, and I learned a lot of C-isms, and a lot of other general programming concepts, and also a bit more about telling the difference
05:42:52 <silver> functional first would be awesome experiment, since most people in the industry start from imperative languages
05:43:23 <RlyDontKnow> thelarry: "the industry" is quite broad and non-OO languages have quite some share in general (think of C for example)
05:43:30 <thelarry> functional first was the way at my university
05:43:40 <tdammers> RlyDontKnow: try s/OO/imperative/
05:44:05 <RlyDontKnow> tdammers: that'd certainly be more true, but OO === imperative is quite off
05:44:09 <thelarry> but it's not common, i know
05:44:23 <lpaste_> dramforever annotated “Kanren” with “fix occurs check, now allows a var to unify with itself instead of failing” at http://lpaste.net/136706#a136708
05:44:52 <tdammers> RlyDontKnow: I know, but the common denominator (reasoning in terms of mutable state) is the interesting part here
05:46:18 <tdammers> IMO, OOP kind of wraps imperative bits into a larger model consisting of smaller programs that talk to each other through messages (or "method calls" if you prefer)
05:46:31 <tdammers> but the nitty-gritty is still usually imperative
05:47:00 <tdammers> OTOH, I use OOP in Haskell all the time, and there it's not necessarily any more imperative than any other Haskell code I write
05:47:43 <RlyDontKnow> just like I use functional programming in C++ and it isn't really less pure than in haskell ;)
05:48:41 <tdammers> the OOP parts in my code, I would argue, are more pure than what I'd come up with in, say, Python
05:48:55 <tdammers> that's because Haskell's type system makes it so that I can actively enforce the OOP semantics through types
05:49:05 <tdammers> I can't abuse dynamic types to take shortcuts
05:49:15 <dramforever> haskell is really nicer to write some programs in
05:49:48 <tdammers> it's kind of ironic IMO that I can do OOP more easily and more safely in Haskell than I can do it in a "proper OOP language"
05:50:13 <dramforever> define oop
05:50:27 <tdammers> heh
05:50:31 <tdammers> touché
05:50:31 <RlyDontKnow> m-erger: to answer your question from my pov: it's a very good choice if you're somewhat masochistic - you'll have a harder time "getting just something", but things will probably be easier in the long run
05:52:13 <tdammers> don't think I can come up with a rigid definition
05:52:52 <tdammers> but I believe you'd have to have objects, proprties, and methods
05:53:12 <tdammers> and a way to define contracts ("interfaces") between objects
05:55:21 <tzaeru> mmh, type hints in Python.. can now do "def serialize_full(self, datagram:Datagram = None) -> Datagram:". what a quaint step to accepting some goodies of static typing.. 
05:55:33 <RlyDontKnow> on what is oop: I liked that way to look at it: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
05:57:14 <Flonk> tzaeru: the __future__ is now
05:57:43 <dramforever> RlyDontKnow: you could have invented haskell!
05:58:42 <tdammers> IMO, the benefits of static typing are marginal at best, until you embrace it fully
05:59:02 * hackagebot Unique 0.4.2 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.4.2 (kapral)
05:59:06 <tdammers> blacklist vs. whitelist and all that
05:59:53 <m-erger> tdammers: embrace it fully?
06:00:07 <dramforever> m-erger: work with it, not against it
06:00:24 <tdammers> when type checks are optional and tacked on, there's not a lot you're winning that you couldn't have had with unit tests or sth
06:01:15 <tdammers> the real benefit only kicks in when "it doesn't type check" is the default, and you have to punch holes to make it work, instead of defaulting to "it looks OK" and having to put in work to catch potential errors
06:01:38 <tdammers> best default for a firewall is "drop everything", then you punch holes for the stuff you want to allow
06:02:10 <tdammers> likewise, best default for a type checker is "it's invalid", and then you add declarations to tell the type checker what is allowed
06:02:46 <dramforever> tdammers: well I would call it "catches the most errors"
06:02:47 <tdammers> but in order for that to be viable, the type system must be expressive enough to make it worthwhile
06:03:14 <tdammers> IMO type checking is not just about catching errors
06:03:25 <tdammers> typecheck-driven development and all that, you knwo
06:04:06 <azsx> do you guys like to use Memory pool management or do you ignore it for your programs
06:04:24 <azsx> in haskell it says that its foreign
06:04:35 <tdammers> azsx: for most haskell programs, leaving memory management to the runtime is the sanest choice
06:04:38 <dramforever> azsx: the ghc runtime does it for you
06:05:37 <tdammers> you could probably use some sort of C FFI library to use custom memory allocations in performance-critical sections, if you really really want to, but I think it'd be quite the hassle
06:06:13 <tdammers> and if your program is one of those cases where you'd really need a custom memory pool, then chances are Haskell isn't the best tool for the job, at least not directly
06:06:28 <c_wraith> Honestly, you have pretty good options for controlling allocation even without crazy FFI stuff.
06:06:46 <c_wraith> I mean, bytestring was written without the FFI, for instance.
06:06:56 <c_wraith> GHC lets you get pretty low-level if you really need to.
06:10:13 <tdammers> fair point, yes
06:10:49 <tdammers> memory pools would require some effect management, but I guess that could also be dealt with
06:13:06 <c_wraith> But you usually can get good performance without needing to go *that* low-level.  Just making sure you don't have any space leaks is often enough for GHC to generate really good code.
06:16:36 <tdammers> yep
06:16:45 <tdammers> strategic strictness
06:18:13 <lpaste_> freinn pasted “error in instance declaration” at http://lpaste.net/136709
06:18:14 <Gurkenglas> dramforever, at the risk of spouting nonsense, I have the feeling Con String [] should absorb the Var String case.
06:18:31 <freinn> hi, I have an error making an instance declaration
06:18:32 <freinn> http://lpaste.net/136709
06:20:07 <Perlkonig> freinn: what's the real code?
06:20:25 <freinn> the first part
06:20:36 <freinn> the copied fragment has 2 parts: code and error
06:20:48 <freinn> if you need the whole file just tell me
06:20:54 <barrucadu> freinn: You need a Num instance for Poly a, as the error is telling you
06:21:17 <Perlkonig> freinn: ghc says the error is in line 103. that code doesn't have 103 lines
06:22:04 <freinn> Perlkonig yes sorry, it's not the whole file
06:22:23 <freinn> @barrucadu thanks
06:22:23 <lambdabot> Unknown command, try @list
06:23:26 <freinn> thanks to both, Perlkonig and barrucadu
06:39:03 * hackagebot align 0.1.1.2 - Sequence alignment algorithms.  http://hackage.haskell.org/package/align-0.1.1.2 (literon)
06:58:48 <ocramz> hey there; inline-c question: how do I represent a C enum? The C interface I'm using requires passing it around as `Ptr a` but I'd like to reason about it as a data E = E1 | E2 | ..
07:00:25 <timothyh> Storable?
07:00:36 <mitochon> hi, i'm trying to do 'import Control.Monad.Cont' from ghci. Getting >> "Could not find module ‘Control.Monad.Cont’     Perhaps you haven't installed the "dyn" libraries for package ‘mtl-2.2.1’?     Use -v to see a list of the files searched for. " <<
07:00:58 <mitochon> any idea? I'm on ghc 7.8.4
07:01:18 <dredozubov> mitochon: it looks like it can't find mtl
07:01:22 <dredozubov> how do you compile it?
07:01:29 <kgadek> questions about stackage: here, #haskell-infrastructure, or other?
07:02:00 <mitochon> dredozubov: I'm just trying out examples from a blog post on ghci .. copy paste
07:02:07 <c_wraith> mitochon: that's utterly bizarre... the kind of brokenness I'd expect if you're using debian packages instead of installing them properly, I suppose.
07:02:34 <mitochon> so i have to install mtl first from cabal?
07:02:41 <dredozubov> mitochon: can you show the command which you use to compile it?
07:03:19 <mitochon> GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude> import Control.Monad.Cont  <no location info>:     Could not find module ‘Control.Monad.Cont’     Perhaps you haven't installed the "dyn" libraries for package ‘mtl-2.2.1’?     Use -v to see a list of the file
07:03:43 <c_wraith> mitochon: you don't have to use cabal.  Just don't use debian packages for anything ghc-related.  They're broken in general.
07:03:46 <dredozubov> oh, you're using ghci
07:03:53 <phaazon> @hoogle plus
07:03:54 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
07:03:54 <lambdabot> Control.Arrow class ArrowZero a => ArrowPlus a
07:03:54 <lambdabot> Control.Monad class Monad m => MonadPlus m
07:03:58 <dredozubov> try :set -package=mtl
07:04:05 <dredozubov> oh no
07:04:15 <phaazon> @hoogle plus :: a -> a -> a
07:04:16 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
07:04:16 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
07:04:18 <dredozubov> or yes
07:04:20 <phaazon> dammit
07:04:21 <dredozubov> just try it
07:04:34 <phaazon> isn't there a zero-class version of MonadZero?
07:04:42 <dredozubov> then import it again
07:04:43 <phaazon> like Monoid is the zero-class version of Alternative
07:05:00 <mitochon> Prelude> :set -package=mtl package flags have changed, resetting and loading new packages... Loading package transformers-0.4.3.0 ... can't load .so/.DLL for: libHStransformers-0.4.3.0.dylib (dlopen(libHStransformers-0.4.3.0.dylib, 9): image not found) > :m Control.Monad.Cont  <no location info>:     Could not find module ‘Control.Monad.Cont’     Perhaps you haven't installed the "dyn" libraries for package ‘mtl-2.2.1
07:05:13 <c_wraith> dredozubov: the problem is that the dyn version isn't available, which means "broken install", which generally means debian packages were used.
07:05:33 <dredozubov> c_wraith: ok, i'm clueless then
07:05:38 <kgadek> is there a stackage nightly for GHC 7.8? 
07:07:12 <dredozubov> mitochon: maybe you should try the haskell platform as a quick solution
07:08:19 <dredozubov> https://gist.github.com/yantonov/10083524 or this, you'll be able to install newer ghc
07:08:36 <mitochon> dredozubov: I'm on mac osx. I used http://ghcformacosx.github.io
07:09:05 <dredozubov> you can delete the current installation and use the one from homebrew
07:09:17 <dredozubov> 'brew install ghc' will install 7.10.1, i believe
07:09:19 <phaazon> *aw aw
07:09:39 <c_wraith> mitochon: huh.  That installer is actually the correct one to use.  (Don't use brew)
07:09:52 <dredozubov> c_wraith: why don't?
07:10:10 <dredozubov> it's super easy to use to give yourself a quick taste of ghc
07:10:10 <c_wraith> dredozubov: it breaks when you try to install things like text-icu
07:10:19 <c_wraith> dredozubov: because it *also* uses a broken install
07:10:30 <c_wraith> and the ghcformacosx installer is easier to use
07:10:54 <c_wraith> mitochon: if you run ghc-pkg check, does it produce output?
07:11:00 <dredozubov> it's actually hard to imagine something easier than CLI command
07:11:15 <c_wraith> imagine you don't already have brew installed.
07:11:19 <c_wraith> then many things are easier.
07:11:23 <c_wraith> (and less broken!)
07:12:42 <dredozubov> it's the most tolerable thing right now
07:12:42 <mitochon> c_wraith: running ghc-pkg check it shows a bunch of error / warning
07:12:46 <mitochon> The following packages are broken, either because they have a problem listed above, or because they depend on a broken package.
07:12:52 <dredozubov> (maybe i should check out the Nix updates on OS X)
07:13:04 <mitochon> ... a few dozens ... among them ... mtl-2.2.1
07:13:12 <sveri> Hi, I have [Char] like this "345556" and now my assumption was that this is a List of Chars which I could iterate over with map and convert it into an Int like this: map read "2344" and get [2, 3, 4, 5] which doesn't work. Is there a way to do something similar?
07:13:59 <dredozubov> c_wraith: why is ghc installation broken everywhere right now? It seems weird and unlikely.
07:14:19 <Perlkonig> sveri: the problem is that read takes a string, not a char
07:14:36 <Perlkonig> > map digitToInt "2344"
07:14:37 <lambdabot>  [2,3,4,4]
07:16:09 <sveri> Perlkonig: ah, that makes sense, where does digitToInt come from? Is it in prelude?
07:16:33 <Perlkonig> @index digitToInt
07:16:33 <lambdabot> Data.Char
07:17:29 <mitochon> dredozubov , c_wraith: I can remove ~/.cabal if that helps? Or how to fix? I feel this should be straightforward
07:17:34 <sveri> Perlkonig: awesome, that works, thank you very much
07:18:32 <joncol> It's probably easy, but how do I change the optimization level to -O2 via my cabal config?
07:19:49 <dredozubov> mitochon: i believe it's impossible to reinstall base with cabal
07:20:00 <dredozubov> so, i'd go with another installation method
07:20:30 <dredozubov> i personally installed bottled ghc from brew and everything was ok, dunno why c_wraith states that it's broken
07:21:06 <dredozubov> (conceptually i can understand, but ghc 7.10.1 works totally fine)
07:21:16 <mitochon> is this a problem with 'ghcformacosx.github.io
07:21:27 <dredozubov> looks like it
07:22:19 <mitochon> maybe i can try the ubuntu install from a docker
07:22:49 <zmbmartin> How can I use a local package in another project?
07:26:09 <bergmark> zmbmartin: with cabal sandboxes you can add-source it, with stack you can point it to the dir
07:26:36 <zmbmartin> bergmark: I use nix(nix-shell) any idea on that?
07:26:43 <bergmark> no idea, sorry
07:26:51 <zmbmartin> bergmark: No worries, thanks!
07:33:50 <epta> zmbmartin: http://hydra.nixos.org/build/23656633/download/1/nixpkgs/manual.html#how-to-build-projects-that-depend-on-each-other
07:36:56 <zmbmartin> epta: Thanks!
07:38:19 <htebalaka> are there any parser libraries that take advantage of not having a monad instance?
07:41:34 <indiagreen> uu-parsinglib, I think
07:42:14 <indiagreen> hm, no, apparently they have a monad instance
07:42:51 <htebalaka> :( i dunno why but this has been bugging me
07:43:02 <johnw> htebalaka: why is this important?
07:43:58 <htebalaka> it isn't terribly...just weird that when people describe the difference between applicative and monadic parsers they generally say that applicative parsers are easier to statically analyze, which is kind of vacuous if there aren't any examples
07:44:31 <johnw> one aspect is that an applicative parser has no branching, so it can only have one "shape"
07:44:35 <indiagreen> well, I guess optparse-applicative wouldn't be able to generate precise docs for accepted command-line options if it had a monadic interface
07:44:43 <htebalaka> sort of wondering if the issue of infinite descent in left leaning parsers (i think that's the term?) can be avoided in applicative parsers
07:44:46 <indiagreen> but it's not a general parsing library
07:44:46 <johnw> a monadic parser can vary how it parses basedo n earlier results
07:45:14 <johnw> the inability to vary is what allows static analysis
07:46:11 <johnw> so you could, for example, have an applicative parser that can tell you the minimum number of tokens it might need, before parsing begins
07:47:35 <htebalaka> can you still do static analysis with applicative given recursive let? things like: "s = char 'a' *> s <* char b" could be difficult without a way to reify the recursion
07:48:13 <fabian__> I found a bug in cabal (version 1.23) related to cross compiling cabal packages with Custom build type
07:48:33 <johnw> htebalaka: it depends on what you want to ask about that parser
07:48:42 <dcoutts> fabian__: reported it in the bug tracker? feel like fixing it for us? :-)
07:48:43 <fabian__> it builds Setup.hs with the cross-compiler, so setup can't be executed by the host.
07:49:02 <johnw> laziness defers the recursion, if you aren't asking something that requires evaluating the recursion to completion
07:49:28 <johnw> but counting the number of times 'a' might be parsed will give the correct answer of "undefined' :)
07:49:47 <fabian__> dcoutts: maybe :) stuff like this requires so much work to setup
07:49:49 <johnw> (by way of non-termination)
07:49:53 <dcoutts> fabian__: do make sure you report it in the bug tracker.
07:49:53 <htebalaka> i kind of want to try writing a compiler for a language, so things like "is the grammar ambiguous" or "will it get stuck in an infinite loop" are the main ones
07:49:57 <htebalaka> yeah, that's a bad example
07:50:06 <dcoutts> fabian__: the cross-compile support is certainly a bit shaky
07:50:19 <johnw> htebalaka: will your language be context-free?  then applicative should do it
07:50:28 <johnw> htebalaka: if it's context dependent, you'll almost certainly need Monad
07:51:40 <fabian__> dcoutts: for now it works if I just enter dist/setup and execute ghc --make Setup.hs
07:51:45 <fabian__> and then cabal install again
07:52:02 <dcoutts> fabian__: note that workaround in the issue you file
07:52:37 <htebalaka> probably a haskell compiler, but i think splitting things up into multiple parser passes can make things less context dependent to a point? i've never done much parsing in a programming language context. i believe ghc doesn't use a recursive descent parser, so i've been thinking about their limitations
07:52:46 <htebalaka> *subset of haskell
07:52:55 <fabian__> dcoutts: ok!
07:53:26 <fabian__> dcoutts: its onl ekmetts packages that dont work :p
07:53:41 <fabian__> dcoutts: so far 3 packages has failed, all his
07:54:03 <dcoutts> fabian__: I'm honestly surprised cross-compiling works at all :-)
07:54:07 * hackagebot repa-linear-algebra 0.0.0.0 - HMatrix operations for Repa.  http://hackage.haskell.org/package/repa-linear-algebra-0.0.0.0 (mjmrotek)
07:54:58 <fabian__> dcoutts: and profunctor makes GHC segfault...
07:56:26 <fabian__> dcoutts: im cross compiling for android
07:56:33 <dcoutts> fabian__: nice
07:56:48 <dcoutts> let us know how you get on
07:57:04 <fabian__> dcoutts: good until GHC segfaulted on profunctors
07:57:09 <dcoutts> :-)
08:14:12 <dEPy> What's the difference between partially applied and curried
08:14:12 <dEPy> ?
08:14:34 <johnw> partial application provides a to a -> b -> c to get b -> c
08:14:43 <johnw> currying takes (a, b) -> c and yields a -> b -> c
08:15:05 <htebalaka> i.e. currying a function makes it partially applyable
08:15:28 <martinvlk> Hi, syntactic differences aside, what is the difference between if-then-else and Data.Bool.bool? How would I choose one or the other?
08:16:33 <htebalaka> bool can be sometimes useful because of partial application, but honestly i prefer to use a lambda and if-then-else
08:16:40 <htebalaka> like: \b -> if b then 1 else 2
08:16:53 <arw> martinvlk: i would decide by readability.
08:17:13 <martinvlk> right, yeah
08:18:27 <htebalaka> bool takes its false argument first, which has resulted in bugs for me a few times
08:18:47 <htebalaka> which is why i use the lambda
08:18:49 <martinvlk> yeah, it's not too intuitive allright
08:19:16 <exio4> I prefer to avoid normal if(s) and use MultiWayIf(s), even though they end a bit more verbose 
08:19:40 <kadoban> I guess that order was chosen to have it work kinda like 'maybe' ?
08:19:55 <dEPy> johnw & htebalaka tnx! :)
08:20:09 <htebalaka> yeah, but i still think it should have been: \t f b -> if b then t else f
08:23:05 <htebalaka> kadoban: i guess foldr follows a similar pattern too
08:23:51 <htebalaka> take some church-style continuations to convert type X to some other type
08:23:52 <Denommus> is there a database migration library in which I can use existing types?
08:24:08 <Denommus> e.g., something like SafeCopy, but for relational databases
08:39:09 * hackagebot hat 2.9.0.0 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.9.0.0 (OlafChitil)
08:39:18 <johnw> htebalaka: also maybe and either follow the "false first" pattern
08:40:11 <Peaker> in Lamdu we're gonna scrap "if" for "case of bool" (lighter notation for "case" to make that non-painful) and we put False first at first and it made me write buggy things! :)
08:42:13 <martinvlk> Peaker: thanks
08:42:33 <martinvlk> exio4: what is multiway if? I have to look it up...
08:42:59 <Peaker> MultiWayIf: if | cond1 -> ...   | cond2 -> .... | cond3 -> ... | otherwise -> ...
08:43:39 <kaidelong> so if is to guards what lambdacase is to pattern matching?
08:43:45 <kaidelong> (with that extension)
08:43:48 <Fuuzetsu> case () of _ | cond1 -> ... | cond2 -> ...
08:44:26 <martinvlk> I see, cheers!
08:44:29 <Fuuzetsu> lambdacase lets you write cute stuff without binding spurious variables 
08:44:36 <Fuuzetsu> it's a great extension
08:44:43 <Fuuzetsu> foo <- …
08:44:45 <Fuuzetsu> case foo of …
08:44:58 <Fuuzetsu> justs becomes … >>= \case …
08:45:29 <Fuuzetsu> instead of >>= \x -> case x of …
08:45:49 <ChristianS> has anyone studied which language extensions are used most frequently in the existing haskell codebase (on hackage, stackage, or whatever)?
08:46:08 <martinvlk> there is so many of them, for a beginner it is ovewhelming
08:46:12 <Fuuzetsu> ChristianS: yes
08:46:12 <jackhill> @hoogle [a] -> [[a]]
08:46:13 <lambdabot> Data.List inits :: [a] -> [[a]]
08:46:13 <lambdabot> Data.List permutations :: [a] -> [[a]]
08:46:13 <lambdabot> Data.List subsequences :: [a] -> [[a]]
08:46:25 <ChristianS> Fuuzetsu: url?
08:46:27 <Fuuzetsu> ChristianS: the HaRE folk have some numbers
08:46:31 <Fuuzetsu> forgot a link but you could ask them
08:46:57 <ChristianS> Fuuzetsu: ok, thanks
08:51:34 <exio4> multiwayif means you can have pattern guards, too
08:51:51 <exio4> > if | Just x <- Just 3 -> x | otherwise -> 2 
08:51:52 <lambdabot>  <hint>:1:1: Multi-way if-expressions need MultiWayIf turned on
08:57:17 <rowanblush> ChristianS: http://www.reddit.com/r/haskell/comments/31t2y9/distribution_of_ghc_extensions_on_hackage/
08:58:00 <ChristianS> rowanblush: ah, great
08:58:35 <stelleg_> @djinn a -> b -> a
08:58:35 <lambdabot> f a _ = a
08:58:42 <stelleg_> @djinn a -> a -> a
08:58:42 <lambdabot> f _ a = a
08:59:28 <rowanblush> stelleg_: const?
09:00:47 <stelleg_> rowanblush: just showing a friend djinn :)
09:01:57 <Fuuzetsu> @. @pl @djinn a -> b -> a
09:01:57 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
09:02:02 <Fuuzetsu> @. pl djinn a -> b -> a
09:02:02 <lambdabot> f = const
09:05:36 <aweinstock> @. pl djinn a -> b -> b
09:05:36 <lambdabot> f = const id
09:05:49 <aweinstock> :t flip const
09:05:50 <lambdabot> b -> c -> c
09:06:22 <aweinstock> :t const id
09:06:24 <lambdabot> b -> a -> a
09:07:03 <aweinstock> is flip const == const id, or am I missing something?
09:08:09 <fmapE> tolt: I'm going to go ahead on that re-org if that's OK with you?
09:09:31 <athan> Anyone here do much matroid work in haskell?
09:11:21 <Welkin> did you say metroid?
09:11:46 <aweinstock> does that have anything to do with linear algebra?
09:11:55 <athan> Welkin: metroid'
09:12:09 <athan> aweinstock: I /think/ so, also combinatorics :s
09:12:09 <Welkin> https://en.wikipedia.org/wiki/Matroid
09:12:20 <Welkin> hm, never heard of that before
09:12:29 <oconnore> > round (0/0)
09:12:31 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
09:12:35 <oconnore> :o
09:13:04 <Welkin> > round (0/0) :: Integer
09:13:05 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
09:13:09 <athan> Welkin: I guess it makes graph reduction for linear constraint solving more clear
09:13:21 <Welkin> athan: how is everything going for you
09:13:22 <Welkin> ?
09:13:48 <athan> Welkin: Good :) still struggling to find gigs (and complete the one I'm working on :x), but good
09:13:51 <athan> how about you?
09:14:13 <Welkin> I would say it's good. I don't have any work at the moment
09:14:30 <catsup> how can i get rid of unused variable warnings (for bindings generated by TH)?
09:14:46 <athan> :(
09:14:54 <Welkin> catsup: why would you want to?
09:14:55 <athan> catsup: Use _ :D
09:15:00 <Welkin> just remove the unused variables
09:15:09 <catsup> i can't because the bindings are generated by TH
09:15:25 <Welkin> hm, there should be a compiler flag
09:15:35 <catsup> i don't want to disable all unused variable warnings though
09:15:42 <catsup> just specific ones
09:16:03 <catsup> (or, really, disabling any such warnings for TH-generated bindings would be ideal)
09:16:29 <Welkin> -fno-warn-unused-binds
09:16:48 <Welkin> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
09:17:23 <catsup> Welkin: i'm aware of that, but i don't want to disable all unused variable warnings
09:18:05 <Falkyouall> hey guys
09:18:59 <Falkyouall> i really going to cry soon if i dont get a dafeinition and why
09:19:09 <Falkyouall> myMapm :: Monad m => (a -> m b) -> [a] -> m b
09:19:09 <Falkyouall> myMapm f (x:xs) = do ???
09:19:52 <athan> Falkyouall: You could get away with it if `a ~ b`
09:19:53 <Fuuzetsu> Falkyouall: are you expecting someone to write it for you? Why not just look up the one from the standard library?
09:20:00 <Falkyouall> sorry wair
09:20:02 <Falkyouall> wait
09:20:10 <Falkyouall> no i want to understand it
09:20:13 <athan> look for a monadic `fix`
09:20:16 <Falkyouall> and im trying since hours
09:20:31 <Falkyouall> myMapm :: Monad m => (a -> m b) -> [a] -> m [b]
09:20:40 <athan> :|
09:20:42 <athan> = id
09:20:48 <athan> er
09:20:48 <Falkyouall> i want the monadic list b
09:20:54 <aweinstock> @src mapM
09:20:54 <lambdabot> mapM f as = sequence (map f as)
09:21:07 <Falkyouall> without higher order functions 
09:21:15 <athan> @djinn (a -> m b) -> [a] -> m [b]
09:21:15 <lambdabot> Error: Undefined type []
09:21:17 <bitemyapp> without higher order functions?
09:21:18 <kadoban> @src sequence
09:21:18 <lambdabot> sequence []     = return []
09:21:18 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:21:18 <lambdabot> --OR
09:21:18 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:21:18 <athan> dang
09:21:19 <htebalaka> do { x' <- f x ; xs' <- myMapm f xs ; return (x' : xs') }
09:21:19 <Fuuzetsu> Falkyouall: run the action on first element then append it to the rest of elements…
09:21:23 <Falkyouall> yeah by foot
09:21:34 <bitemyapp> programming by foot.
09:21:47 <bitemyapp> hum.
09:21:48 <bergmark> mapM is a good exercise to write
09:22:05 <Falkyouall> ok htebalaka if it works that way, i was really close then
09:22:08 <htebalaka> you don't need a monad constraint though. if you understand Applicative syntax, it's: (:) <$> f x <*> myMapm f xs
09:22:30 <kadoban> Falkyouall: Have you done the NICTA course? It has a lot of stuff like that, and ramps you up in a fairly natural way.
09:22:55 <aweinstock> :t sequence
09:22:56 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:23:00 <Fuuzetsu> htebalaka: what's the point of telling him that when he clearly said he wants to understand it rather than the definition
09:23:04 <Falkyouall> i found the best explenations on this blog http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
09:23:30 <htebalaka> Fuuzetsu: well other people were giving definitions, otherwise i wouldn't have
09:23:53 <Falkyouall> htebalaka your solution dont work out yet..
09:24:25 <htebalaka> no...? lemme think
09:24:32 <Falkyouall> wait
09:24:41 <Falkyouall> most likely my fault
09:24:51 <Falkyouall> wow
09:24:54 <aweinstock> :t let {myMapM f [] = return []; myMapM f (x:xs) = do { y <- f x; ys <- myMapM f xs; return y:ys}} in myMapM
09:24:55 <lambdabot>     Occurs check: cannot construct the infinite type: t3 ~ [t3]
09:24:55 <lambdabot>     Expected type: [[t3]]
09:24:55 <lambdabot>       Actual type: [t3]
09:24:57 <Falkyouall> i had wxactly this
09:25:13 <Falkyouall> i took me so long to work it ot
09:25:16 <aweinstock> :t let {myMapM f [] = return []; myMapM f (x:xs) = do { y <- f x; ys <- myMapM f xs; return (y:ys)}} in myMapM
09:25:17 <lambdabot> Monad m => (t -> m t1) -> [t] -> m [t1]
09:25:22 <aweinstock> :t mapM
09:25:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:25:29 <Falkyouall> thanks a lot! htebalaka
09:26:05 <htebalaka> for things like mapM if you think of regular map, but in an imperative language (with <- as your assignment operator, and return as the imperative return statement, a lot of monadic code follows pretty naturally from the pure definitions
09:27:35 <Falkyouall> yes, and its actually clear to me, i read all the signatures and understand whats happening...but yea sometimes im getting stuck writing it down that way
09:28:51 <htebalaka> you can also do things like: let mapM f [] = return [] ; mapM f (x:xs) = do { x' <- f x ; xs' <- mapM f xs ; return _ }, and ghci will tell you the type of the _
09:30:43 <Falkyouall> just the type and no output? crazy!
09:30:43 <fr33domlover> q: How do I choose a precedence level (0-9) for an operator? I just know it has to be higher than that of <> i.e. the options are 7,8,9
09:31:08 <Fuuzetsu> how can it know the output of the generic function you're not applying anything to?
09:31:24 <Fuuzetsu> it's a compile-time info
09:32:11 <aweinstock> Fuuzetsu: type inference
09:32:17 <htebalaka> Fuuzetsu: it will infer the most generic types as possible
09:32:59 <Fuuzetsu> I'm very well aware, I was replying to <Falkyouall> just the type and no output? crazy!
09:33:26 * Fuuzetsu has been using TypedHoles since like day 1 and manually causing type errors even before
09:37:52 <athan> This is pretty cool, I think
09:37:54 <athan> https://en.wikipedia.org/wiki/Matroid#Closure_operators
09:38:34 <athan> Mac Lane's all up in that piece
09:45:09 <Falkyouall> hey when i define a applicative instance for a data type which is not defined yet (Schnaps a = Nothing | Vodka a)
09:45:28 <Falkyouall> applicative want to know what kind Vodka is, right?
09:47:18 <aweinstock> in your example, Vodka doesn't have a kind, it has a type (Schnaps has a kind, * -> *)
09:47:30 <glguy> You can't define instances for types that aren't defined. Do you just mean that it's defined after the instance?
09:47:46 <kadoban> Falkyouall: Applicative doesn't like being anthromophized. Not sure what you're asking there exactly …
09:48:25 <Fuuzetsu> interesting analogy
09:48:55 <benzrf> 'Applicative doesn't like being anthromophized.'
09:48:57 <benzrf> :>
09:49:00 <Falkyouall> im trying to get the essence of applicative
09:49:16 <kadoban> benzrf: ;)
09:49:16 <aweinstock> Falkyouall: are you asking how to define an Applicative instance for your type (which is essentially Maybe)?
09:49:49 <Falkyouall> what does it need to declare all important instances, Functor is easy i get also that i need first an applicative to get the functor work
09:50:01 <Falkyouall> yeah
09:50:08 <Falkyouall> im trying to get exatly that
09:50:16 <kadoban> Falkyouall: You should really do this course if you're interested in this stuff: https://github.com/NICTA/course
09:50:26 <aweinstock> other way around, i think (every Applicative is also a Functor, but not vice-versa)
09:50:32 <kadoban> Falkyouall: Also … you seem to be implying that you need an Applicative instance for it to be a Functor, that's not ture.
09:50:59 <Falkyouall> hahaha ok i mixed that up, im sittign here for the last 6 hourse doing nothing else
09:51:04 <aweinstock> Functors have just fmap, Applicatives are Functors that also have pure and (<*>)
09:51:22 <asthasr> Falkyouall: one thing I have found surprisingly useful is to go and read the instances for existing types
09:51:35 <Falkyouall> okay
09:51:42 <bergmark> and/or implement them yourself
09:51:44 <asthasr> for example, given Applicative, go to the Control.Applicative docs https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Applicative.html
09:52:05 <asthasr> then find "Instances" and look at types you understand
09:52:17 <asthasr> i.e. Applicative [], Applicative Maybe
09:52:25 <asthasr> click "view source" to the right
09:52:50 <Falkyouall> ok so applicative has a lot more to offer than functor
09:52:54 <Falkyouall> ok
09:53:37 <kadoban> It's quite a bit more powerful, yeah.
09:53:41 <Falkyouall> ah okay ots the functor with the applicative constraint
09:54:30 <Falkyouall> okay makes all sense, and monad need the applicative constraint
09:54:39 <Falkyouall> mond = blown
09:54:44 <Falkyouall> mind = blown
09:54:44 <bergmark> lucky you're on ghc 7.10 ;-)
09:54:46 <asthasr> my mond is blown every day
09:54:52 <Falkyouall> hahaha
09:54:59 <frerich> There's some serious mond-blowing going on here.
09:55:02 <Falkyouall> monad = blown
09:55:03 <kadoban> Yes, because everything that can be a Monad can also be an Applicative, so it's kinda evil not to make one in case people want to use it.
09:55:32 <indiagreen> Falkyouall: it's easier to get the essence of Applicative if instead of considering <*> you consider a function like “f a -> f b -> f (a,b)” or “(a -> b -> c) -> f a -> f b -> f c”
09:56:00 <indiagreen> then it becomes clear that Applicative just combines 2 things together and nothing else
09:56:28 <asthasr> lambdabot: @eval [(* 2), (+ 5)] <*> [1, 2, 3, 4, 5]
09:56:39 <asthasr> okay, that failed
09:56:42 <chpatrick> > [(* 2), (+ 5)] <*> [1, 2, 3, 4, 5]
09:56:44 <lambdabot>  [2,4,6,8,10,6,7,8,9,10]
09:56:58 <asthasr> chpatrick: thanks, I'm a newbie.
09:58:17 <Falkyouall> and i can implement an individual function (f) in the applicative? indiagreen
09:58:49 <Falkyouall> like (\x y -> (x, y))
09:59:38 <kadoban> Falkyouall: What would it mean to implement an individual function in the applicative? :-/
10:00:22 <aweinstock> liftA == fmap == (<$>)
10:00:22 <bergmark> Falkyouall: a function is not a type so it can't be made an instance of any typeclass
10:00:24 <Falkyouall> makes no sense at all
10:00:35 <Falkyouall> okay so its more meta
10:00:51 <aweinstock> bergmark: (->) is a type
10:01:06 <bergmark> aweinstock: yes, but it's not *a* function
10:01:11 <bergmark> there is an Applicative instance for ((->) a)
10:01:30 <aweinstock> :t (<*>)
10:01:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:01:34 <Falkyouall> ok so its in fact a more meta level of haskell
10:02:21 <aweinstock> :t (<*>) :: ((->) a) (b -> c) -> ((->) a) b -> ((->) a) c
10:02:22 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
10:02:35 <Falkyouall> i gonna read what asthasr showed me instead of annoying you guys
10:02:42 <aweinstock> :t (.) . (.)
10:02:43 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:02:53 <aweinstock> :t flip ((.) . (.))
10:02:54 <lambdabot> (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
10:06:57 <ReinH> @. djinn type (<*>) :: ((->) a) (b -> c) -> ((->) a) b -> ((->) a) c
10:06:58 <lambdabot> f a b c = a c (b c)
10:07:55 <benzrf> ReinH: why not just plain @djinn, if youre writing out the whole type anyway?
10:08:03 <ReinH> because someone else did that and I copied it
10:08:10 <athan> DJ Djinn!
10:08:27 <fosterite> ins't that the S combinator
10:08:33 <ReinH> Yes.
10:08:38 <ReinH> and pure is the K combinator
10:08:50 <ReinH> so <*> for ((->) a) implements the SKI calculus
10:09:02 <ReinH> well
10:09:08 <athan> ReinH: Wow!! I had no idea
10:09:08 <ReinH> Applicative for same plus id
10:09:22 <ReinH> (in a typed context, though)
10:10:42 <maerwald> FAscinating
10:10:48 <fosterite> interesting. k : a -> ((->) b) a then 
10:11:02 <NeverDie> Anyone here running a Haskell startup?
10:11:09 <ReinH> So actually you get a typed SKI calculus (http://www.emis.de/journals/NSJOM/Papers/23_1/NSJOM_23_1_319_329.pdf)
10:11:58 <ReinH> pure = const
10:13:24 <tromp_> SKI = const`ap`id
10:14:13 <tromp_> :t const`ap`id
10:14:14 <lambdabot> b -> b
10:15:01 <fosterite> are there any other surprising results like that? I didn't expect SKI to be exactly Applicative
10:15:51 <tromp_> the power of SKI comes from being untyped
10:16:03 <chpatrick> ContT of a parser is a lazy parser in the regex sense
10:16:06 <tromp_> eg. to be able to define a Y combinator
10:16:19 <jesyspa> Isn't typed SKI equivalent to typed lambda calculus, just like untyped SKI is equivalent to untyped lambda calculus?
10:17:07 <asthasr> Does anyone know of any Haskell/functional language groups in the Charlotte, NC area?
10:17:39 <Falkyouall> do i get this wrong? in applicative i define type signatures with my own Data ? (<*>) :: f (Schnaps a -> Schnaps b) -> f Schnaps a -> f Schnaps b
10:17:44 <fosterite> jesyspa: yeah, that's what the paper ReinH ust posted is about
10:18:10 <chpatrick> Falkyouall: f is what you substitute
10:18:21 <chpatrick> Maybe (a -> b) -> Maybe a -> Maybe b
10:18:41 <ReinH> fosterite: There are lots of serendipities in functional programming. Many of them turn out to have reasons as well.
10:18:44 <Falkyouall> okaaay
10:19:13 <fosterite> ReinH: my question was pretty ill-posed
10:19:14 * hackagebot ADPfusion 0.4.1.1 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.4.1.1 (ChristianHoener)
10:19:44 <chpatrick> Falkyouall: Applicative is a typeclass on type f
10:20:13 <chpatrick> that means that for the given type f there are exist certain functions that involve f
10:20:31 <chpatrick> where f is Maybe, [], MyApplicative, whatever you define an instance for
10:21:55 <Falkyouall> and would i write now Schnaps (a -> b) -> Schnaps a -> Schnaps b ?
10:22:33 <maerwald> Schnaps? errr
10:22:36 <Falkyouall> haha
10:22:38 <maerwald> what data type is that?
10:22:40 <Falkyouall> jea maybe okay
10:22:51 <maerwald> data Schnaps a = Schnaps a
10:22:54 <maerwald> then ok
10:23:22 <Falkyouall> data Schnaps a = Zero | Vodka a - would that be ok?
10:23:29 <maerwald> too unhealthy
10:23:35 <Falkyouall> or just recursive data types?
10:23:48 <maerwald> Schnaps in that case is basically the same as Maybe, yeah
10:24:04 <maerwald> so you have to define the instance
10:26:30 <Falkyouall> how would a function like this would be defined?  foo :: Maybe (a -> b) -> Maybe a -> Maybe b
10:26:52 <nitrix> Someone really needs to learn metasyntactic variables, lol.
10:26:56 <nitrix> "Schnaps"
10:27:03 <nitrix> Foo, Bar, Baz, "Schnaps".
10:27:13 <chpatrick> Falkyouall: try it, there's only one sensible way
10:27:18 <goovie_> foo = fmap
10:27:34 <Falkyouall> foo f g x fmap f.g x
10:27:41 <chpatrick> goovie_: nope
10:27:46 <goovie_> ya i just saw
10:27:51 <nitrix> Falkyouall: That seems like fmap to me.
10:27:56 <nitrix> :t fmap
10:27:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:28:08 <chpatrick> nope
10:28:13 <goovie_> no its not, notice that first argument is boxed into maybe
10:28:16 <nitrix> Oh no.
10:28:19 <nitrix> My bad.
10:28:33 <nitrix> Applicatives then?
10:28:39 <chpatrick> Falkyouall: try writing it out
10:28:48 <goovie_> more like foo f x = f <*> x
10:28:52 <Falkyouall> foo f g x = f <*> g fmap x
10:29:04 <nitrix> :t (<*>)
10:29:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:29:15 <azsx_> > + 1 2
10:29:17 <lambdabot>  <hint>:1:1: parse error on input ‘+’
10:29:24 <azsx_> (+ 1 2)
10:29:30 <maerwald> ?
10:29:31 <azsx_> > (+ 1 2)
10:29:32 <lambdabot>      Could not deduce (Num a0)
10:29:32 <lambdabot>      from the context (Num a, Num a1, Num (a1 -> a))
10:29:32 <lambdabot>        bound by the inferred type for ‘e_112’:
10:29:39 <maerwald> what are you doing?
10:29:39 <nitrix> azsx_: it's > (+) 1 2
10:29:42 <azsx_> how do you use lambda
10:29:58 <fosterite> > \x -> x $ 5
10:29:59 <nitrix> azsx_: You're using `+` as a prefix operator, you need to place it in parenthesis.
10:30:00 <lambdabot>      No instance for (Typeable t0)
10:30:00 <lambdabot>        arising from a use of ‘show_M122260016241916126113540’
10:30:00 <lambdabot>      In the expression:
10:30:10 <fosterite> > (\x -> x) $ 5
10:30:11 <lambdabot>  5
10:30:11 <chpatrick> Falkyouall: g isn't a function
10:30:17 <goovie_> by the way guys i got a question
10:30:21 <Falkyouall> (*3) <*> (+1) 4
10:30:24 <chpatrick> and it doesn't even take x :)
10:30:27 <goovie_> i recently started to learn applicative functors
10:30:35 <goovie_> and i guess i understand the idea in general
10:30:39 <goovie_> however i need to practice a bit
10:30:43 <Falkyouall> me 2
10:31:01 <goovie_> do you have any ideas about a small project, nice paper or excercises to practice them a bit?
10:31:25 <chpatrick> the basic idea is that with applicatives you can compose two "computations" in f with a pure function
10:31:25 <nitrix> goovie_: Are you okay if I give you a resource to learn them, that isn't exactly accurate, but the lies outweights the cons?
10:31:31 <ReinH> goovie_: have you read Conor's original paper?
10:31:33 <chpatrick> :t (+) <$> Just 3 <*> Nothing
10:31:34 <lambdabot> Num b => Maybe b
10:31:43 <kadoban> goovie_: I like using them for parsing, like with Parsec. The NICTA course has a bunch on them as well, but most of it isn't … practice from the outside exactly.
10:31:57 <goovie_> i already know how the monad parsing works
10:32:05 <asthasr> ReinH: is that http://strictlypositive.org/IdiomLite.pdf ?
10:32:26 <goovie_> well i actually read the 'learn you a haskell for a great good'
10:32:26 <ReinH> yep
10:32:56 <goovie_> the chapter with the functors, applicative functors and monoids
10:33:06 <chpatrick> goovie_: applicatives are like weaker monads
10:33:16 <chpatrick> you can compose f a and f b but f b can't depend on f a
10:33:27 <chpatrick> you can just compose independent computations
10:33:27 <maerwald> goovie_: implementing a Parser is pretty good for understanding applicative IMO https://www.seas.upenn.edu/~cis194/fall14/spring13/hw/10-applicative.pdf
10:34:16 <goovie_> well when it comes to monads
10:34:21 <goovie_> its more like 'sequential'
10:34:26 <nitrix> Technically, isn't it like...
10:34:35 <nitrix> Monads > Applicatives > Functors?
10:34:42 <ReinH> Technically and literally
10:35:12 <maerwald> chpatrick: I don't think that's accurate... you can have conditions in applicative as well and do decisions, but the _effect_ flow is predefined
10:35:16 <goovie_> yeah but can anyone tell me what are actual differences between monad and applicative parsing?
10:35:39 <ReinH> :t (<*>)
10:35:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:35:40 <nitrix> I think it isn't exactly true, there was quirk, monads not being applicatives in prelude yet or something.
10:35:50 <ReinH> :t (=<<)
10:35:51 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:35:57 <aweinstock> that's been fixed in the most recent GHC, i thought?
10:36:06 <nitrix> That's what I'm not sure.
10:36:07 <aweinstock> @src Monad
10:36:07 <lambdabot> class  Monad m  where
10:36:07 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
10:36:07 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
10:36:07 <lambdabot>     return :: a -> m a
10:36:07 <lambdabot>     fail   :: String -> m a
10:36:09 <ReinH> The difference between applicative and monad is precisely the difference between ap and bind
10:36:13 <nitrix> Did that went through?
10:36:31 <nitrix> I have version 7.10.1
10:36:34 <maerwald> goovie_: in a monadic parser context you can change the parser depending on what you are currently parsing... you can't do that with applicative
10:36:57 <ReinH> ap can't change the f-structure, bind can
10:37:04 <kadoban> nitrix: Yes, all Applicatives are Functors and all Monads are Applicatives in GHC 7.10
10:37:10 <ReinH> sorry, that's not quite truye
10:37:15 <ReinH> applicative can't change it *based on the a*
10:37:26 <goovie> can you give an example?
10:37:28 <chpatrick> maerwald: what I mean to say is that you can't have some side effect and then decide the "next" computation
10:37:45 <maerwald> chpatrick: sorry, I don't understand the term side effect in the context of haskell
10:37:51 <goovie> :D
10:38:06 <ReinH> > Just True >>= \x -> if x then Nothing else Just ()
10:38:07 <lambdabot>  Nothing
10:38:12 <maerwald> but I guess we mean something similar
10:38:16 <ReinH> changes the f-structure based on the a
10:38:19 <ReinH> you can't write that with ap
10:38:29 <aweinstock> :t ap
10:38:30 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:39:09 <asthasr> Monad ϵ Applicative ϵ Functor
10:39:19 <ReinH> No.
10:39:25 <benzrf> ⊂
10:39:28 <kadoban> Those should probably be subset symbols instead, yeah.
10:39:31 <benzrf> ⊆, even
10:39:34 <asthasr> blah
10:39:53 <chpatrick> maerwald: ok, so you have this notion of composing two computations in f, but one can't depend on the outcome of the other
10:39:55 <asthasr> symbols!
10:40:28 <chpatrick> "computation" and "outcome" in quotes :)
10:40:28 <maerwald> chpatrick: yeah, I like to say "the effect flow is static, but the result flow dynamic"
10:40:45 <maerwald> but ReinH already showed a quite good example
10:41:18 <ReinH>  /me prefers to think of monad as a rewriting system anyway
10:41:20 <ReinH> er.
10:41:42 <benzrf> monads??? do you mean monoids in categories of endofunctors??
10:41:53 <Medeos> Hi
10:41:55 <Medeos> Check this blog out PLEASE:  https://syrianlouie.wordpress.com/
10:41:57 <maerwald> although some people just use the monad because of the do notation... we need Ado ;)
10:42:02 <benzrf> why, Medeos
10:42:06 <Medeos> Because
10:42:07 <Medeos> It's about
10:42:13 <Medeos> a guy escaping Russia, I hate spamming
10:42:16 <ReinH> Medeos: stop
10:42:18 <Medeos> I hate spammers, I despise bots
10:42:19 <Medeos> ok
10:42:20 <Medeos> -stops-
10:42:47 <Medeos> ReinH can I speak?
10:42:55 <ReinH> Can you not hit enter every other word?
10:43:00 <maerwald> try #haskell-blah
10:43:04 <Medeos> Yes, I apologise.
10:43:52 <ReinH> Yes, #haskell-blah is our off-topic channel
10:44:00 <Medeos> It's about a guy escaping Russia, and while I hate spamming and I hate bots and link sharers who do what I just did, all I can think about right now is how I can help this guy get his voice out and his story heard. I apologise for the inconvinience and for the intrusion. I will go there.
10:44:11 <Medeos> -bows-
10:44:12 <Medeos> -exits-
10:44:13 <Medeos> bye
10:44:13 <voidzero> I don't think he really cares about Haskell
10:44:20 <asthasr> voidzero: Safe bet.
10:44:28 <asthasr> IRC is a fickle mistress.
10:44:35 <voidzero> sure is
10:45:01 <maerwald> not sure IRC is the right place to raise awareness about human rights (or somesuch), but whatever...
10:45:59 <aweinstock> benzrf: return wraps burrito fillings into a tortilla, and join puts the fillings of a nested burrito-inside-a-burrito into a single tortilla
10:46:38 <fosterite> Const is a burrito with a tiny man inside, eating all your fillings
10:47:02 <maerwald> aweinstock: argh, plz no :(
10:47:02 <ReinH> ha
10:47:11 <kadoban> Const is now really gross …
10:47:29 <asthasr> const is a fish that prevents the value that it eats from being eaten by other fish!
10:47:30 <aweinstock> maerwald: sorry (i figured it was on topic due to the "monoid in the catagory of endofunctors" remark)
10:48:22 <ReinH> "mooned in the category of endofunctors" is at least true, if unhelpful
10:48:54 <ReinH> or monoid
10:48:59 <benzrf> was being facetious :>
10:49:09 <benzrf> aweinstock: well, that's the burrito monad
10:49:17 <ReinH> benzrf: Yes, we know :p
10:49:20 <benzrf> one example of a perfectly fine monad
10:49:36 <benzrf> burritos are monads, but not all monads are burritos
10:49:38 <benzrf> sadly
10:49:40 <benzrf> i like burritos
10:50:00 <maerwald> I can understand that people use the burrito analogy lazily to express some type synonym hiding a terrible monad stack... but I cannot understand if someone uses that analogy seriously to explain monads in any way
10:50:29 <nitrix> I use boxes.
10:50:37 <dolio> I can't understand why anyone likes any reference to it, having heard it hundreds of times now.
10:50:41 <kadoban> I only ever see the burrito analogy as a joke, heh. Do people use it seriously anymore?
10:50:44 <dolio> It's a bad joke.
10:50:54 <kadoban> It's kinda amusing, as far as lame jokes go.
10:50:56 <maerwald> kadoban: sometimes
10:51:25 <rowanblush> Monads are like fluid dynamics in a rocket engine.
10:51:27 <ReinH> I still prefer space suits for my awful monad dad joke needs
10:51:30 <maerwald> I have never eaten a burrito, maybe that's why I don't like it?
10:51:37 <dolio> It's the most tired joke in this channel.
10:51:51 <kadoban> maerwald: You're missing out. Burritos rule, when done right.
10:52:01 <fosterite> of all the monad analogies, burritos are not the worst
10:52:03 <maerwald> even the "Box" analogy is better, although very unpresice
10:52:25 <nitrix> I like the box analogy, it helped me "get going".
10:52:28 <fosterite> the box analogy is the same as the burrito analogy
10:52:37 <maerwald> yeah, it works well for stuff like Maybe and probably lists
10:52:46 <nitrix> Especially lists imo.
10:52:46 <asthasr> to be honest, I have used at least a half dozen metaphors trying to explain monads to my colleagues
10:52:50 <kadoban> The box analogy seems just as bad except less jokey so more likely to be taken seriously :-/
10:52:59 <maerwald> fosterite: no, it's not food, lol
10:53:00 <asthasr> it is really, really depressing
10:53:25 <kadoban> asthasr: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
10:53:42 <asthasr> kadoban: I have read it.
10:54:08 <hodapp> dildo factory.
10:54:09 <kadoban> Then if you are still expecting the metaphors to do something useful for your colleagues, you didn't take it to heart.
10:54:15 * hackagebot GenussFold 0.0.0.2 - MCFGs for Genus-1 RNA Pseudoknots  http://hackage.haskell.org/package/GenussFold-0.0.0.2 (ChristianHoener)
10:54:16 <fosterite> the railway analogy seems to have taken off
10:54:18 <hodapp> best monad tutorial.
10:55:15 <asthasr> kadoban: I guess the problem is, I am trying to use monads (specifically Maybe/Either) in an impure language, for practical purpose. Every time one of my non-monad-understanding colleagues does a code review, they pop up with the 'EVERYTHING IS SO CONFUSING WHY NOT JUST IF NULL,' so I have tried multiple approaches to help them
10:55:43 <chpatrick> which language?
10:55:46 <asthasr> Ruby.
10:56:33 <nitrix> Sometimes it's fine to have an analogy being unprecise to abstract the complexity until you really have to talk about it. It helps builds up an understanding from the bottom-up, by temporarily giving you a higher level perspective.
10:56:45 <nitrix> Sorry for carrying the discussion, was interrupted by a phone call.
10:56:51 <nitrix> Anyway.
10:56:59 <magthe> I can't seem to find the thingie that tells ghc to run my source through a pre-processor, any pointer?
10:57:01 <benzrf> nitrix: yeah, but things like the box analogy dont explain monads at /all/
10:57:03 <edk> nitrix, that depends. if all you need to know about monads is vaguely that they exist and you can use them for io, yes
10:57:05 <benzrf> they explain one specific monad
10:57:12 <dolio> I don't think you need to explain monads to explain why null is a bad idea.
10:57:17 <Gurkenglas__> If you're only using Either and Either (), you can just explain it as a language construct that allows you to exit a computation prematurely, like with return in a function. Right?
10:57:38 <dolio> And why Maybe/Either are better than using null.
10:57:40 <maerwald> asthasr: I usually start with things like how a type as "Maybe" makes function composition more complicated (because you may need to pattern match a lot), then how fmap can solve this problem in some way, how applicative enhances it and then how Monad gives you even more decision power. And all that by looking at the types (which are very very similar for all three concepts)
10:57:42 <nitrix> I'll admit I had to really commit learning them further when I wanted to use the Maybe monad. It's fine for IO, harder to understand for the other ones.
10:58:34 <dolio> Although in Ruby it's a harder sell.
10:59:11 <asthasr> maerwald: most of my Rubyist colleagues would lose it at the term "function composition"
10:59:30 <maerwald> then it's the wrong audience
10:59:34 <asthasr> perhaps
10:59:40 <maerwald> in the sense that they need to learn the basics about FP first
10:59:45 <asthasr> but Maybe(foo).bar.baz.quux.or_else { 0 } is a lot nicer than nested nil checks
11:01:45 <fosterite> Gurkenglas__: they're also really useful for things that genuinely might not work, like divison
11:01:45 <maerwald> I never know what ruby code does before I execute it
11:02:48 <magthe> is there a way to get `cabal` to set all the relevant paths for a sandbox such the I can call `ghc` directly?
11:02:49 <wordsarewind> maerwald: you've summed up the entire language with one line
11:02:55 <maerwald> :P
11:02:56 <Gurkenglas__> fosterite, that is also an instance of a computation exiting prematurely (just with an exception instead of return)
11:03:17 <asthasr> maerwald: Believe me, I concur.
11:03:19 <magthe> something like eval $(cabal shell-setting) or the like?
11:03:32 <asthasr> Nothing has made me more a fan of functional, strongly typed languages than working in Ruby
11:03:35 <asthasr> it is a madhouse.
11:06:51 <Gurkenglas> Is there a language extension that allows floating-point infix precedence? (And hopefully also reserves a few symbols to mean "this, used as an infix operator suffix, maps the infix precedence space into the space between these two numbers)
11:06:57 <Gurkenglas> *"
11:08:34 <Gurkenglas> Because I way too often find myself using brackets because I'm within a sequence of compositions.
11:09:31 <kadoban> Gurkenglas: Maybe it should be obvious, but I'm not following what you're talking about at all …
11:10:53 <Gurkenglas> Give me something that makes "map (foo . bar) . asd" and "map $' foo .' bar . asd" equivalent
11:11:46 <Gurkenglas> *kadoban
11:12:52 <kadoban> Hmmmm. I dunno.
11:13:49 <nomeata> Hi. Am I right to assume that stackage-lts-3.0 will just be stackage-nightly from the date lts-3.0 is released?
11:14:07 <benzrf> isnt 'stackage nightly' kinda an oxymoron :>
11:14:16 * hackagebot th-typegraph 0.21 - Graph of the subtype relation  http://hackage.haskell.org/package/th-typegraph-0.21 (DavidFox)
11:14:42 <nomeata> benzrf: no, why? LTS nightly would be
11:14:56 <nomeata> benzrf: see http://www.stackage.org/nightly-2015-07-15
11:16:03 <goovie> how do you understand a kind?
11:16:30 <kadoban> Kinds are the type of types.
11:16:45 <maerwald> :k Maybe
11:16:47 <lambdabot> * -> *
11:16:47 <maerwald> :k Either
11:16:49 <lambdabot> * -> * -> *
11:16:58 <goovie> ye i got the idea
11:17:07 <goovie> i was asked about this at the job interview
11:17:16 <goovie> why are they so important
11:17:52 <kadoban> They're important because without them there's no way to do higher-level stuff like Functor, Applicative, etc. I believe?
11:17:56 <htebalaka> most languages don't have an expressive enough language for kinds to easily implement things like Monad and stuff
11:17:57 <maerwald> :k Functor
11:17:58 <lambdabot> (* -> *) -> Constraint
11:18:00 <maerwald> :k Bifunctor
11:18:01 <lambdabot> (* -> * -> *) -> Constraint
11:18:34 <htebalaka> as far as i know, but that kadoban said the same makes me a little more confident about that
11:18:54 <goovie> wait
11:18:59 <goovie> whats that nasty Constraint thing
11:19:16 * hackagebot zero 0.1 - Semigroups with absorption  http://hackage.haskell.org/package/zero-0.1 (DimitriSabadie)
11:19:21 <kadoban> It's some extension, HigherKindedSomethingOrOther I think?
11:19:34 <exio4> you mean ConstraintKinds
11:19:42 <kadoban> Sounds possible :)
11:19:47 <hodapp> :t (\x y -> x <*> pure y)
11:19:48 <lambdabot> Applicative f => f (a -> b) -> a -> f b
11:20:02 <maerwald> goovie: if you have a functor instance of a tuple, you can only manipulate the second value... because of the kind of the Functor
11:20:05 <asthasr> are there any "Kinds of Kinds?"
11:20:07 <maerwald> I hope that's precise enough
11:20:11 <Gurkenglas> Are there constraint transformers? :D
11:20:12 <asthasr> I may not have enough math to understand
11:20:17 <rbocquet> asthasr: not yet
11:20:17 <goovie> yeah i know this
11:20:23 <hodapp> is there some more idiomatic form of what I just passed to :t?
11:20:30 <htebalaka> the type of kinds are called sorts, but the language of sorts is not very expressive
11:20:33 <goovie> its kinda like (->) a
11:20:38 <phaazon> @tell athan finally released it ;)
11:20:38 <lambdabot> Consider it noted.
11:20:43 <goovie> >k (->) Int
11:20:44 <exio4> hodapp: fmap ($ a)? 
11:20:53 <hodapp> :t (fmap ($ a))
11:20:54 <lambdabot> Functor f => f (Expr -> b) -> f b
11:21:18 <exio4> @type fmap . flip ($) 
11:21:19 <lambdabot> Functor f => a -> f (a -> b) -> f b
11:21:28 <htebalaka> richard eisenburg is working on making * :: * hold true, which would apparently cause issues in languages like idris and agda, but apparently won't in haskell?
11:21:31 <rbocquet> asthasr: but it is being worked on (https://github.com/goldfirere/ghc)
11:21:46 <exio4> htebalaka: we can already do silly things like bottoms
11:22:10 <goovie> by the way
11:22:24 <exio4> @let import Data.Type.Equality
11:22:25 <lambdabot>  .L.hs:116:1:
11:22:25 <goovie> while we had discussion about applicative functors i went to get some coffee
11:22:25 <lambdabot>      Data.Type.Equality: Can't be safely imported!
11:22:25 <lambdabot>      The module itself isn't safe.
11:22:36 <goovie> and someone mentioned a good paper about applicative functors
11:23:12 <benzrf> @let newtype Leib a b = Leib {getLeib :: forall f. f a -> f b}
11:23:13 <lambdabot>  Defined.
11:23:14 <htebalaka> is there something like bottom at the type level?
11:23:25 <rbocquet> htebalaka: Any
11:23:37 <benzrf> challenge: write leibSym :: Leib a b -> Leib b a
11:24:05 <exio4> benzrf: leibSym = undefined 
11:24:13 <htebalaka> ah
11:24:48 <rbocquet> htebalaka: or you can define "type family U :: k"
11:24:55 <benzrf> exio4: boo
11:25:11 <exio4> benzrf: :p you didn't specify much
11:25:21 <rbocquet> not sure Any does that actually, it had this name in some papers
11:25:41 <htebalaka> ooh, that's weird
11:25:46 <benzrf> how is Any at all analogous to bottom?
11:26:01 <exio4> there's no such thing as bottom at the type-level, as far as I know? 
11:27:19 <maerwald> the only thing I can think of remotely is ()
11:27:31 <maerwald> but that's probably not really similar
11:27:37 <rbocquet> maerwald: thats the opposite
11:27:49 <monochrom> depends on what aspect you want out of "bottom"
11:28:02 <Gurkenglas> Am I being stupid or can (forall f . f a -> f b) -> (forall g . g b -> g a) not be realized?
11:28:20 <benzrf> Gurkenglas: id
11:28:25 <benzrf> oh, wait
11:28:26 <Welkin> @src ()
11:28:26 <lambdabot> data () = ()
11:28:29 <benzrf> Gurkenglas: it can be realized
11:28:40 <benzrf> Gurkenglas: it may help to think about types propositionally
11:28:57 <benzrf> actually edwardk gave me this particular puzzle once
11:28:58 <rbocquet> :k GHC.Prim.Any
11:28:59 <lambdabot> k
11:29:04 <benzrf> rbocquet: ah
11:29:09 <rbocquet> Any inhabits every kind
11:29:48 <Gurkenglas> Hmm. absurd?
11:30:11 <benzrf> Gurkenglas: this is leibniz equality, hence the name :u
11:30:34 <benzrf> Gurkenglas: think about what Leib a b means
11:31:09 <Gurkenglas> We don't necessarily have fmap, right? This just goes over all of (* -> *)
11:31:20 <benzrf> ye
11:31:32 <joco_from_ubuntu> luite, is there a virtual box image around in which it is easy to compile this : https://github.com/ghcjs/ghcjs-examples ? I've tried the Leksah vagrant image but ghcjs is not there yet.
11:32:22 <monochrom> benzrf: when I first learned this, it was not immediately obviously Leibniz equality. there were a few steps.
11:32:35 <benzrf> monochrom: oh?
11:33:00 <benzrf> i mean, leibniz equality is ∀P.P a → P b
11:33:05 <Gurkenglas> Ahh. we can choose f such that it maps a to g b and b to g a and then return that
11:33:10 <luite> joco_from_ubuntu: that whole repo has probably fallen behind lately, since i've been working on a major library update and have been neglecting too many things
11:33:15 <benzrf> Gurkenglas: :O
11:33:30 <monochrom> right, I'm exactly saying that "∀P.P a → P b" is not immediately obviously Leibniz equality.
11:33:41 <benzrf> monochrom: er, isnt that the /definition/ of leibniz equality?
11:33:43 <Gurkenglas> benzrf, ?
11:33:45 <monochrom> hell, it is not immediately obviously any equality at all. where is the equality sign?
11:33:49 <monochrom> no
11:33:50 <benzrf> Gurkenglas: implement it!
11:34:10 <Gurkenglas> Oh, * -> * isn't the mathematical space of all functions from * to *?
11:34:15 <Gurkenglas> What's its definition?
11:34:17 * hackagebot instant-generics 0.5 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.5 (JosePedroMagalhaes)
11:34:21 <rbocquet> Gurkenglas: actually not
11:34:22 <benzrf> Gurkenglas: i mean, probably it is
11:34:28 <benzrf> in some theoretical thing
11:34:39 <benzrf> in actual haskell its a bit complicated
11:34:48 <rbocquet> * -> * only contains "type constructors"
11:34:48 <monochrom> I would accept "∀P.P a ↔ P b" as a definition of Leibniz equality, since it actually has an equality sign
11:34:54 <bitemyapp> actual Haskell? Where's fantasy-land Haskell?
11:35:01 <rbocquet> all inhabitants of *->* are injective for instance
11:35:03 <bitemyapp> I want to use fantasy-land Haskell where exceptions don't happen.
11:35:10 <monochrom> it takes one or two steps of logic to see why one direction suffices
11:35:18 <benzrf> rbocquet: what about type families
11:35:21 <Gurkenglas> And type constructors are made from sum, prod, exp and some fourth thing?
11:35:40 <benzrf> we have GADTs too, even
11:35:58 <luite> joco_from_ubuntu: sorry about that. was there any specific example you were interested in?
11:36:09 <joco_from_ubuntu> luite, ok, good to know , just curious
11:36:11 <Denommus> so, is there a data migration library that works with sqlite and can work with existing types?
11:36:59 <luite> joco_from_ubuntu: the improved-base branch should get released soon, and will require ghc 7.10.2, all code should eventually be updated to work with that
11:37:56 <dolio> monochrom: It even requires a particular property of your quantifiers, which might not even be true, depending on the system you're working in.
11:38:28 <monochrom> you can say, "∀P.P a → P b" is the definition. but that is true only in the niche context of die-hard know-nothing-else type theory
11:38:51 <rbocquet> benzrf: actually type families don't inhabit (->) kinds :(
11:39:15 <rbocquet> there is some detail in http://www.cis.upenn.edu/~eir/papers/2014/promotion/promotion.pdf
11:39:19 <benzrf> rbocquet: huh, really?
11:39:33 <rbocquet> type families must always appear fully saturated
11:39:37 <monochrom> outside that ivory tower, the rest of us use "a=b ⇒ for all domains X,Y, for all function f::X->Y, f a = f b"
11:39:48 <benzrf> aw dang
11:40:10 <Iceland_jack> benzrf: Singleton's gets around that in a clever way, effectively using defunctionalisation 
11:40:18 <benzrf> i dont know anything abt singleton
11:40:31 <benzrf> :>
11:41:15 <Gurkenglas> Can f be Either String, or do we not have access to primitive types?
11:41:20 <Iceland_jack> There are papers and blog posts by Eisenberg that explain it in further detail
11:42:14 <eds> How do I define a FoldL function for my GADT? I tried but I think my approach is wrong. Line 41 - function definition, line 62 - eval of FoldL and line 95: error on lpaste. Code and error: http://lpaste.net/136444. 
11:42:31 <Gurkenglas> (Is * -> * exactly everything that'll return * -> * if I ask lambdabot for its kind?)
11:43:01 <benzrf> Gurkenglas: well
11:43:06 <benzrf> im asking for an implementation
11:43:07 <benzrf> so yes
11:43:37 <monochrom> I think that's a tautology
11:44:28 <rbocquet> benzrf: it is possible without using a GADT ?
11:44:44 <Gurkenglas> I'm just trying to list all the tautologies that look suspicious to my brain so I don't spend 10 minutes thinking about the wrong thing
11:45:37 <rowanblush> I'm having a brain failure. What's it called when you have a parameter to a datatype, but you don't actually use the value with any constructor? A ghost... something?
11:45:54 <exio4> phantom type
11:46:11 <rowanblush> exio4: Thanks! I was close. :-P
11:46:21 <kyclark> I would like to have [Handle] but I have [IO Handle] -- any way to extract the Handles from the IO monad?
11:46:27 <benzrf> yes rowanblush
11:46:30 <benzrf> er, rbocquet
11:46:41 <exio4> kyclark: sequence? 
11:46:47 <geekosaur> kyclark, >>=
11:46:51 <rbocquet> benzrf: ah of course
11:46:53 <kadoban> kyclark: You can get a IO [Handle], is that enough?
11:46:53 <rbocquet> got it
11:46:58 <exio4> @type sequence :: [IO Handle] -> IO [Handle] 
11:46:59 <lambdabot>     Not in scope: type constructor or class ‘Handle’
11:46:59 <lambdabot>     Perhaps you meant one of these:
11:46:59 <lambdabot>       ‘Handler’ (imported from Control.Exception),
11:47:00 <benzrf> =)
11:47:09 <monochrom> it has to be enough
11:47:30 <geekosaur> oh I read the [] as separators... derr
11:47:31 <kyclark> let fhs = map (\file -> openFile file ReadMode) ["time.hs", "greet.hs"]
11:47:40 <benzrf> kyclark: 
11:47:41 <aweinstock> (unserious) there's always unsafePerformIO
11:47:41 <benzrf> :t mapM
11:47:43 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:47:44 --- mode: ChanServ set +o sclv
11:47:55 --- mode: sclv set -q *!*@unaffiliated/sdegutis
11:48:09 <benzrf> sclv: ?
11:48:11 --- mode: ChanServ set -o sclv
11:48:15 <hunteriam> Where can I see the source for List?
11:48:22 <hunteriam> Like the data declaration
11:48:26 <sclv> just removing an old quiet
11:48:28 <Gurkenglas> Setting f = Identity gives us the information that either b is something like Either (a, ()) c or our argument has some hardcoded elements of b mixed in... this is gonna be complicated isn't it
11:48:33 <kyclark> mapM FTW.  Thanks benzrf
11:48:33 <Welkin> @src List
11:48:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:48:37 <Welkin> @src []
11:48:37 <lambdabot> data [] a = [] | a : [a]
11:48:52 <Gurkenglas> Can I assume that our argument Leib has a finite implementation?
11:49:19 <chreekat> kyclark: fhs <- mapM (\file -> openFile file ReadMode) ["time.hs", ..]
11:49:24 <benzrf> Gurkenglas: er
11:49:33 <benzrf> Gurkenglas: why is that relevant
11:49:39 <chpatrick> @src is this the sudoers insult list
11:49:39 <lambdabot> Source not found. Sorry.
11:49:44 <chpatrick> @src again
11:49:44 <lambdabot> Source not found. Sorry.
11:50:00 <benzrf> @src something else
11:50:00 <lambdabot> Source not found. Wrong!  You cheating scum!
11:50:04 <chpatrick> yes it is
11:50:13 <Gurkenglas> benzrf, because I might be able to deduce something about the relative nature of a and b from the argument Leib not being an omnipotent Omega
11:50:14 <kyclark> even better, chreekat!  thanks!
11:50:46 <hunteriam> Does anyone have the patience to explain the RULES pragma?
11:50:53 <monochrom> no
11:51:04 <dolio> Gurkenglas: It doesn't require recursion.
11:52:35 <Gurkenglas> dolio, that's the wrong kind of hint I think. The correct way to approach this puzzle feels to be something like something like Socratic Reasoning - I'm supposed to ask relevant questions until the answer is obvious
11:53:31 <Gurkenglas> [sic on that doubling]
11:53:43 <monochrom> Socrates got paid. dolio doesn't. remember that.
11:54:01 <rowanblush> Socrates got poisoned.
11:54:28 <benzrf> Gurkenglas: no, u got it backwards
11:54:32 <benzrf> the person teaching asks YOU questions
11:54:35 <rbocquet> Gurkenglas: socratic reasoning works the reverse way : people with the solution would ask you easy questions until you get to the answer
11:54:50 <Gurkenglas> That's why I said something like :P
11:55:00 <johnw> the socratic method is to be annoying enough until people do actually poison you
11:55:54 <eds> How do I define a FoldL function for my GADT? I tried but I think my approach is wrong. Line 41 - function definition, line 62 - eval of FoldL and line 95: error on lpaste. Code and error: http://lpaste.net/136444. bump
11:56:42 <dolio> Gurkenglas: So, you have Leib a b, and want Leib b a. And Leib a b = forall p. p a -> p b. So you can get a 'p b' as a result from using Leib a b. So what p would be good to use to get what you want?
11:57:07 <dolio> You get to choose p.
11:57:23 <mniip> eds, the definition is good
11:57:23 <Gurkenglas> dolio, wouldn't I need a p a to get a p b?
11:57:38 <dolio> Yes, but don't worry about that yet.
11:57:52 <kongo2002> Hi, what do you use to generate ctags (to be used in vim) ?
11:58:00 <benzrf> kongo2002: hasktags
11:58:02 <mniip> eds, thing is there is no instance Rando (Expr (Int -> Int -> Int))
11:58:07 <rbocquet> edk: you don't have any constructor in Expr to define a value of type Expr (a -> b)
11:58:10 <rbocquet> eds
11:58:11 <dolio> Until you figure out what p you want to use, you won't know whether or not you have a 'p a'.
11:58:18 <eds> mniip: but rando does not identify anything of type Expr (Int -> Int -> Int)
11:58:18 <edk> rbocquet, i'm not edwardk
11:58:31 <eds> yea
11:58:39 <sdegutis> What's the Haskellish way to translate this basic JavaScript task? I have an array of objects which each have a key "id" pointing to a number. I want to find the highest one and then return one higher than it.
11:58:44 <edk> oh, you missed someone else this time :)
11:58:47 <kongo2002> benzrf: the haskell wiki mentions a lot of alternatives - ever tried something else?
11:58:51 <edk> i should have been named something else :(
11:58:56 <benzrf> kongo2002: not personally. no
11:59:06 <mniip> edk,         7 -> FoldL   <$> rando (d-1) <*> rando (d-1) <*> rando (d-1)
11:59:07 <Gurkenglas> dolio, well, what we want is a forall g. g b -> g a, but since we get to choose p after we're told the g, we would like p b to be g b -> g a, ignoring that we have no p a.
11:59:09 <kongo2002> benzrf: but it works alright I assume :)
11:59:13 <benzrf> it has for me
11:59:17 <benzrf> afaik
11:59:18 <eds> mniip: essentially I want to use Plus, Minus, Times that I have defined in Expr.
11:59:18 <mniip> you ask rando to generate you an Expr (Int -> Int -> Int)
11:59:19 <chpatrick> sdegutis: (maximum $ map id stuff) + 1
11:59:20 <benzrf> havent used it a /ton/ :)
11:59:28 <exio4> sdegutis: (+1) . max . map getId 
11:59:40 <benzrf> exio4: *maximum
11:59:46 <sdegutis> Why not use succ?
11:59:51 <exio4> ah, right
11:59:54 <benzrf> sdegutis: bc nobody remembers succ
11:59:55 <eds> mniip: Which are of type Expr Int -> Expr Int -> Expr Int
12:00:09 <Welkin> edk: you are also one levenshtein distance away from eds 
12:00:10 <exio4> sdegutis: you can also use it if you want to
12:00:11 <sdegutis> So, succ . max . map getIdField ?
12:00:15 <mniip> eds, ...?
12:00:22 <exio4> sdegutis: maximum 
12:00:39 <dolio> Gurkenglas: So p b = g b -> g a. What is p a?
12:00:45 <Gurkenglas> (), ideally
12:00:52 <kongo2002> benzrf: don't you use vim for haskell code anymore - or is there a better way to quickly navigate haskell proejcts?
12:01:09 <orion> I have a data type named Group with two record fields: gid and gname. I have a JSON string that looks like this: { "data": [ { "name":"...","id":"..." }, ... ] } and I'd like to use Aeson to parse it in to a [Group], but I don't want to create any additional datatypes. What's the best way to accomplish this?
12:01:16 <benzrf> kongo2002: no, i just dont write very much haskell :>
12:01:18 <edk> Welkin, yes... life as a trigraph is hard!
12:01:30 <Gurkenglas> Or, following the pattern, maybe g a -> g a, which is curiously inhabited by id
12:01:31 <benzrf> in fact i havent worked on any kind of programming project in months, i think
12:01:36 <benzrf> ^3^
12:01:39 <dolio> Gurkenglas: p x = g x -> g a. What is p a?
12:01:45 <sdegutis> Thanks all.
12:01:46 <dolio> Gurkenglas: Ah hah.
12:01:55 <benzrf> dolio you spoiled it
12:02:00 <benzrf> :{
12:02:04 <benzrf> oh wait
12:02:05 <geekingfrog> I'm having trouble finding a library to read audio format (mp3 and m4a mainly). Any idea?
12:02:12 <kongo2002> benzrf: I see, thanks anyway :) at least a reason to give it shot
12:02:14 <Gurkenglas> I feel unsatisfied and spoiler. I like my reverse socratic method better :P
12:02:21 <Gurkenglas> *spoilered
12:02:41 <benzrf> @let newtype Flip f a b = Flip {getFlip :: f b a}
12:02:42 <lambdabot>  Defined.
12:02:45 <benzrf> @let leibSym (Leib f) = getFlip (f (Flip (Leib id)))
12:02:46 <lambdabot>  Defined.
12:02:48 <benzrf> :>
12:02:50 <benzrf> :t leibSym
12:02:51 <lambdabot> forall (k :: BOX) (a :: k) (b :: k). Leib a b -> Leib b a
12:02:51 <eds> mniip: Expr (Int -> Int -> Int) will be an operation in foldl right? Like foldl (+) (1) (2), so (+) here is Expr (Int -> Int -> Int). My FoldL will have : FoldL (Plus) (I 1) (I 2) which will be Expr Int -> Expr Int -> Expr Int
12:03:39 <Gurkenglas> benzrf, @letlpaste spams less and gives a better overview to the reader
12:03:44 <benzrf> i should know
12:03:46 <benzrf> i invented it
12:03:54 <Gurkenglas> :D
12:04:04 <benzrf> its just 2 lines, dude
12:04:29 <Gurkenglas> I didn't remember the implementation of Leib so I thought it's somewhere in the last 30 lines
12:04:45 <benzrf> h
12:05:14 <indiagreen> orion: decode it as a Value, then use .: to get the array corresponding to "data", then use fromJSON (or parseMaybe parseJSON)
12:05:23 <monochrom> could you merge those two lines?
12:05:50 <sdegutis> bbl
12:05:53 <mniip> monochrom, the first line is a line comment xD
12:06:11 <monochrom> no, the two @let lines
12:06:17 <benzrf> not really monochrom
12:06:45 <Gurkenglas> That might have come across the wrong way; I didn't see it in the few lines before that and I was distracted by lambdabot saying things about BOX that I didn't remember seein defined either, so I guessed that that too must have been defined somewhere before, and then thought of an lpaste woulding have been more convenient
12:06:54 <benzrf> ah
12:07:57 <monochrom> I just tried "@let { data MonoType = MonoType (); monotype x = MonoType x }" and it was successful
12:08:13 <benzrf> huh
12:08:24 <benzrf> didnt kno u can use braces at the top level
12:08:36 <benzrf> i guess that makes sense
12:09:39 <monochrom> I just tried omitting {}. also successful.
12:09:49 <benzrf> wait, what?
12:09:50 <greymalkin> is mzero useful for an TChan identity: readTChan x :=: readTChan x `orElse` mzero
12:09:54 <benzrf> oh damn
12:10:05 <benzrf> ghci complains about that and i confused it with lambdabot
12:10:29 <benzrf> wait, wtf... ghci allows it too
12:10:32 <benzrf> :|
12:10:35 <monochrom> haha
12:11:00 <benzrf> augh
12:11:01 <benzrf> be back later
12:11:24 <Gurkenglas> You made lambdabot!? Can you make @pl and @djinn compose in the general case?
12:11:41 <benzrf> no i didnt
12:11:48 <benzrf> i just implemented letlpaste and pull requested
12:11:53 <benzrf> l8r
12:12:29 <notdan> Is there a benefit in using (filter =<< mapM) vs foldM?
12:12:40 <Gurkenglas> Oh right, there was something about it being implemented over several years by the IRC channel.
12:12:54 <monochrom> do they have the same type?
12:13:13 <greymalkin> (Answering my question) yes
12:14:42 <Gurkenglas> The first doesn't seem to typecheck
12:15:47 <notdan> I remember hearing somewhere that it's better to compose functions like map, filter, etc instead of rolling your own foldr; I don't remeber the exact reason tho.
12:16:22 <monochrom> yes, but it is said after saying: it is better to get the types right first.
12:16:39 <chpatrick> https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/rewrite-rules.html#id670639
12:17:17 <hodapp> http://hackage.haskell.org/package/shake-0.15.4/docs/Development-Shake-Classes.html#t:NFData errrm, can anyone explain to me what the possible purpose is of this typeclass?
12:17:56 <hodapp> if it always returns (), I have a hard time grokking the purpose
12:18:06 <aweinstock> Data.Binary?
12:18:16 <chpatrick> hodapp: it forces the whole thing to be evaluated
12:18:17 <aweinstock> oops, scrollback was off
12:18:30 <notdan> monochrom: well, duh, of course. but do you recall why is one method prefered over another one?
12:19:08 <notdan> I just was curious if the same holds for monadic functions
12:19:09 <monochrom> it is easier for the reader to guess. that is all.
12:19:25 <notdan> I see, thanks.
12:19:30 <hodapp> chpatrick: I still don't get the significance of that.
12:19:33 <monochrom> therefore, I am not religious about it, unlike other people
12:19:57 <notdan> I thought it was something to do with gluing/rewrite rules
12:20:05 <monochrom> programming is not a religion. rules of thumbs and style guides are not sacred.
12:20:28 <htebalaka> if you do something like "rnf someList `seq` someOtherValue" then you're guaranteed that once someOtherValue is forced that someList will also have been forced
12:20:50 <htebalaka> and every value inside of someList
12:21:18 <chpatrick> hodapp: seq and co only evaluate to the top constructor
12:21:34 <chpatrick> rnf evaluates deeply
12:30:35 <magneticduck> so I want to use box2d in a haskell game server
12:31:07 <magneticduck> er, I'm struggling reading stuff on using haskell FFI
12:31:27 <chpatrick> magneticduck: if you want to be cutting-edge
12:31:29 <chpatrick> @hackage inline-c
12:31:29 <lambdabot> http://hackage.haskell.org/package/inline-c
12:32:01 <magneticduck> aargh
12:32:15 <magneticduck> I just want a simple way to deal with a complied .so library
12:32:21 <magneticduck> when the library is specified on runtime
12:35:45 <chpatrick> as in dlopened?
12:37:00 <magneticduck> yeah I think
12:37:51 <aweinstock> isn't it possible to specify a .so along with a .hs when compiling with ghc, and ghc will link them?
12:37:53 <chpatrick> how come?
12:38:05 <indiagreen> orion: have you written it, or do you need more help?
12:38:17 <magneticduck> er
12:38:52 <magneticduck> I'd be really happy if I could just get a nice way of calling C functions from C libraries in IO
12:39:05 <catsup> magneticduck: have you seen the inline c module
12:39:14 <chpatrick> I just linked it :)
12:39:24 <catsup> oh
12:39:33 <htebalaka> if you've got a list with a statically known length is there any way to UNPACK the constructors so they are zero cost? the data type i'm using is: data Tensor :: [Nat] -> * -> * where { Pure :: a -> Tensor '[] a ; Tensor :: Tensor ns (V n a) -> Tensor (n ': ns) a }
12:39:34 <magneticduck> I'll look at it more closely
12:39:53 <htebalaka> or just a way to get that to work with newtypes. dunno if that can be done with GADT-style constraints
12:40:14 <chpatrick> htebalaka: so it's n-dimensional with statically known sizes?
12:40:17 <magneticduck> well
12:40:20 <magneticduck> it's not a library that I'm writing
12:40:23 <magneticduck> it's box2d
12:40:28 <chpatrick> can you make the sizes phantom and make it a vector internally?
12:40:29 <magneticduck> I want to call box2d methods from the IO monad
12:40:43 <chpatrick> ok, so inline-c? :)
12:40:50 <magneticduck> oh okay
12:40:54 <magneticduck> alright this looks nice I think
12:41:03 <chpatrick> you write C and it gives you an IO something
12:41:11 <orion> indiagreen: Hey, I am in the process of figuring it out.
12:41:24 <lpaste_> relrod pasted “Typeclass instance constraint not being applied?” at http://lpaste.net/136728
12:41:24 <orion> I'll post a code sample if I get stuck.
12:41:27 <htebalaka> chpatrick: hmm...phantom types might work
12:41:44 <chpatrick> I mean
12:41:47 <chpatrick> hmm
12:41:52 * relrod feels like he is missing something obvious, re: that lpaste.
12:42:00 <chpatrick> what is V?
12:42:16 <htebalaka> though the library i'm using uses nested vectors, so i would want to be able to convert from the flattened vector to nested vectors in O(1) still
12:42:20 <chpatrick> an n-vector?
12:42:22 <htebalaka> it's a vector
12:42:31 <htebalaka> from the linear library
12:42:57 <chpatrick> hmm so it's like an array of different sized vectors?
12:43:09 <chpatrick> I thought a tensor was like an n-dimensional matrix
12:43:18 <htebalaka> an array of arrays of arrays. the list of nats are the length of each dimension
12:43:34 <orion> indiagreen: Ok, I'm stuck. :) Here's what I have so far: http://lpaste.net/6442951415064166400
12:43:38 <chpatrick> but currently it's just an array of arrays no?
12:43:56 <htebalaka> so Tensor [3,4,5] a would be a length 3 array of length 4  arrays of length 5 arrays of type a
12:44:04 <htebalaka> yeah
12:44:21 <orion> indiagreen: I can't figure out how to loop over the array and accumulate a list of Groups.
12:45:33 <indiagreen> orion: it's easier than that, hang on a sec
12:46:06 <htebalaka> at least, it has to be to use the functions in linear. so the newtype thing will work if i can convert from a "V n (V m a)" to "V (n * m) a" in constant time if the
12:46:12 <htebalaka> *in constant time.
12:47:24 <indiagreen> orion: http://artyom.me/aeson#parsing-without-creating-extra-types
12:47:46 <htebalaka> couse, i could just have "newtype Matrix m n a = V n (V m a)". i'm hoping there's a no-op solution to make an arbitrarily nested vector functorial in its last parameter
12:48:01 <hodapp> okay, it's rather annoying that in Shake every call to 'addOracle' must be with a different type, but the value of that type has to derive from a whole laundry-list of typeclasses like Show, Eq, Typeable, Hashable, NFData, Binary, Generic
12:48:07 <orion> indiagreen: The section you linked to "parsing-without-creating-extra-types" doesn't exist.
12:48:07 <htebalaka> but i'm really just working with vectors and matrices, so trying to be to general might not really matter
12:48:43 <indiagreen> orion: it might be due to your browser's cache, I wrote it like 1m ago
12:48:59 <indiagreen> refresh the page
12:48:59 <hodapp> I am trying to use basically SomeSymbol, and it's complaining that there is no instance of Generic (Proxy "foo")... though I thought that Generic (Proxy a) was already defined automatically
12:49:04 <chpatrick> htebalaka: yeah I'm not sure it's worth it
12:49:15 <chpatrick> usually this dependent typed stuff turns out to be way more trouble than it's worth
12:49:35 <chpatrick> a good type system is meant to save you time on bugfixing in the end :)
12:54:06 <indiagreen> orion: the point of .: is that in addition to lookup it also automatically converts the returned thing to whatever you're expecting from it
12:54:19 <orion> indiagreen: Hmm, it's not type checking.
12:55:03 <orion> Couldn't match expected type ‘Parser [Group]’ with actual type ‘Value -> Parser a0’
12:55:48 <indiagreen> it does for me – paste the code again
12:57:36 <orion> indiagreen: http://lpaste.net/2099802054951174144
12:58:17 <solidus-river> whats the communities stance on stack vs cabal
12:58:24 <indiagreen> orion: in “groups r”, “r” is not needed
12:58:36 <catsup> hodapp: it shouldn't annoy you, those can all be automatically derived
12:58:49 <orion> indiagreen: !!! Indeed.
12:58:50 <solidus-river> actually, does stack probably wraps cabal using sandbox's, i haven't looked at it
12:58:51 <hodapp> catsup: I'm trying to figure out how and it's getting very convoluted.
12:58:58 <catsup> hodapp: it's not convoluted, do this:
12:59:00 <orion> indiagreen: Type checks now, thank you.
12:59:13 <burp> I use cabal sandbox with stackage for "stable" stuff
12:59:31 <catsup> newtype SomeOracle   = SomeOracle   String     deriving (Show,Typeable,Eq,Hashable,Binary,NFData)
12:59:48 <martinvlk> :t sum
12:59:49 <lambdabot> (Num a, Foldable t) => t a -> a
12:59:51 <Denommus> I just explicitly define my dependency versions
12:59:52 <solidus-river> burp: is there any advantage to it over just a cabal file?
12:59:56 <Denommus> don't see why using stackage
13:00:00 <hodapp> catsup: that's just one type.
13:00:08 <Denommus> solidus-river: you should always use sandboxes
13:00:13 <catsup> hodapp: yeah, so?
13:00:49 <hodapp> catsup: I'm calling addOracle multiple times, thus I require multiple different types, and I'm trying to avoid N instances of manual boilerplate.
13:02:00 <athan> Why hasn't there been much work with matroids in haskell?
13:02:02 <burp> solidus-river: I'm not familiar with the new "stack" concept, I just use a sandbox with the stable snapshot of packages from stackage instead of latest from hackage
13:02:19 <athan> This class looks pretty interesting: http://stackoverflow.com/questions/31187229/matroid-type-class-error-in-haskell
13:02:29 <catsup> hodapp: in the end you do need an identifier for each oracle though
13:02:33 <orion> indiagreen: Thank you for writing that tutorial. I reference it all the time.
13:02:44 * indiagreen chuckles
13:03:04 <burp> solidus-river: by using stackage you can be sure that all packages with all dependencies from it build
13:03:22 <hodapp> catsup: This doesn't mean that I require N instances of manual boilerplate.
13:03:26 <burp> solidus-river: but I'm not sure what benefits the "stack" tool offers, over cabal sandbox
13:03:47 <solidus-river> burp: Denommus: yeah, i already have a test / doc flow aroudn just cabal with sandbox's debating whether i'll get anything out of stack
13:03:49 <catsup> hodapp: yeah, you could use a cpp macro or something so that you only need to specify the identifier and the return type
13:04:06 <hodapp> catsup: that sounds like an atrocious hack.
13:04:14 <catsup> well it's not really a hack at all
13:04:37 <hodapp> catsup: yeah, I consider resorting to CPP to achieve some level of generics to be a hack.
13:04:41 <catsup> hodapp: you could use template haskell.  internally though haskell doesn't provide any way to define things that can be looped over or anything like that
13:04:46 <catsup> it's not generics
13:04:52 <catsup> it's just saving typing
13:05:04 <hodapp> catsup: It's trying to write code once that works, generically.
13:05:20 <catsup> uh
13:05:49 <hodapp> catsup: and yes, Haskell does: they're called existentials, and that's why I was looking at SomeSymbol.
13:05:50 <catsup> to define what an identifier means, you have to specify how it will behave
13:06:37 <hodapp> catsup: I can have a list of SomeSymbol, a distinct Symbol type in each value, and loop over it.
13:07:25 <catsup> ah, well, that's cool stuff.  seems pointless in this case though
13:07:54 <hodapp> catsup: If it's pointless then why did you single it out as a case that Haskell does *not* provide?
13:08:37 <chpatrick> what's the point of having a list of somesymbol?
13:08:39 <catsup> i think the context makes it pretty clear why i brought it up tbh
13:09:05 <chpatrick> all you can do is turn it into a string
13:09:25 <catsup> nothing you do with any ghc extension is going to be fundamentally different or better than what you could do with cpp, in this instance
13:09:26 <hodapp> chpatrick: It's a list that's in effect full of unique types, provided your strings are unique.
13:09:42 <chpatrick> so what is it good for?
13:10:00 <hodapp> chpatrick: addOracle, which I just mentioned, which requires a unique type for each call.
13:10:29 <hodapp> chpatrick: indirectly, I am calling addOracle on something that I have a list of, and so each element in that list requires a unique type.
13:11:23 <hodapp> catsup: I consider existentials and typeclasses to be fundamentally different from CPP, or I wouldn't have bothered with Haskell in the first place, I would have just solved crap by slinging macros.
13:12:12 <catsup> what is it a list of?
13:12:25 <hodapp> catsup: It's a list of build configurations for Shake.
13:13:00 <eitanChatav> Hi, does anyone know of a resolution to this issue <https://github.com/bos/hdbc-mysql/issues/15>? I'm having trouble installing `HDBC-mysql` using Cabal & cabal-install 1.22.0 & ghc 7.8.4.
13:13:30 <hodapp> catsup: I use an oracle to track some details of the build that may change from one run to the next as I update parameters in the build, but which are not part of the C source code or headers (so file dates/hashes do not tell me anything).
13:13:36 <kuznero> Hi All!
13:13:54 <catsup> it's a fixed list of configurations?
13:14:12 <hodapp> catsup: Fixed relative to what? It changes periodically.
13:14:21 * hackagebot zero 0.1.1 - Semigroups with absorption  http://hackage.haskell.org/package/zero-0.1.1 (DimitriSabadie)
13:14:28 <catsup> what kind of action causes it to change
13:14:36 <hodapp> catsup: for instance, if I change a C flag, this should trigger a rebuild of all configurations.
13:15:07 <kuznero> How to achieve prefix-independence when building with cabal on Linux? The documentation mentions Windows only [https://www.haskell.org/cabal/users-guide/installing-packages.html#prefix-independence]...
13:15:19 <hodapp> catsup: this is one purpose of an oracle - it tracks information that isn't reflected in any file data or file timestamps for anything in the build.
13:15:37 <catsup> it seems you should have an oracle for the c flag in that case
13:15:51 <hodapp> catsup: the C flags depend on the build configuration.
13:15:58 <hodapp> except for when they don't.
13:16:56 <catsup> well what i was trying to ask is whether you would have to manually add a configuration, or whether it's generated
13:17:43 <eitanChatav> Hi, does anyone know of a resolution to this issue <https://github.com/bos/hdbc-mysql/issues/15>? I'm having trouble installing `HDBC-mysql` using Cabal & cabal-install 1.22.0 & ghc 7.8.4. I do not have the same issue with `HDBC-postgresql`
13:17:51 <kuznero> I would just like to be able to move my executable around (or distribute it by simply copying it) without depending on prefix/bindir/datadir/libdir supplied at build time...
13:18:16 <sx> is there a reason why this doesn't type check http://codepad.org/2uRfun2g ? Is SystemF mightier than the Haskell type system?
13:18:38 <eitanChatav> Hi, does anyone know of a resolution to this issue https://github.com/bos/hdbc-mysql/issues/15 ? I'm having trouble installing `HDBC-mysql` using Cabal & cabal-install 1.22.0 & ghc 7.8.4. I do not have the same issue with `HDBC-postgresql`
13:18:46 <hodapp> catsup: at the moment they're manually-added.
13:18:58 <eitanChatav> ^fixed link
13:19:10 <hodapp> as-is they all have a unique string that's used for something else
13:19:22 <hodapp> but I was looking at just making that String a Symbol and using it as the oracle
13:22:34 <htebalaka> sx: the type of foo should allow x to unify with Int (or any other type), but the type of x in the function body requires it to be a function type
13:22:40 <adamse> sx: are you sure you have written what you want to do?
13:24:17 <hodapp> what I am still trying to figure out is why it is complaining of a lack of an instance for Generic (Proxy n).
13:24:52 <sx> adamse: yes, actually my real question is, whether Haskell is weaker than System F, because I succesfully typed this term in System F.
13:26:21 <glguy> sx: your type for foo doesn't look right, maybe you meant something closer to: foo :: (forall x. x -> x) -> _
13:27:04 <phaazon> hey, need you guys
13:27:44 <phaazon> currently, I have a newtype for Maybe called Success ; I need the same thing for Either
13:27:48 <sx> glguy: ah yes, argument type is missing, thanks
13:27:50 <phaazon> how would you call that?
13:27:59 <phaazon> I can use Success for Either instead if it makes sense
13:28:17 <benzrf> why are you makin newtypes?
13:28:26 <phaazon> for a library I’m writing
13:28:40 <phaazon> this one, benzrf :
13:28:47 <phaazon> https://hackage.haskell.org/package/zero
13:29:18 <benzrf> why not just use Maybe, i mean?
13:29:40 <phaazon> well
13:29:57 <phaazon> because Maybe already have a Semigroup instance, which is wrong, btw
13:30:05 <phaazon> > Just 3 <> Nothing
13:30:06 <lambdabot>      No instance for (Show a0)
13:30:06 <lambdabot>        arising from a use of ‘show_M812450671096304089616506’
13:30:06 <lambdabot>      The type variable ‘a0’ is ambiguous
13:30:09 <phaazon> oos
13:30:10 <catsup> phaazon: i think that what you are working on might exist already
13:30:12 <phaazon> > Just "" <> Nothing
13:30:13 <lambdabot>  Just ""
13:30:22 <phaazon> catsup: ah?
13:30:28 <phaazon> I haven’t found it yet
13:30:28 <t7> @hoogle (a -> b) -> (a -> IO b)
13:30:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:30:29 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:30:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:30:41 <benzrf> :t (. return) -- t7
13:30:42 <lambdabot> Monad m => (m a -> c) -> a -> c
13:30:50 <benzrf> wait, what the heck
13:30:51 <t7> :t (return .)
13:30:52 <lambdabot> Monad m => (a -> a1) -> a -> m a1
13:30:54 <catsup> phaazon: well, it also might not.  i don't know that it _does_, i just suspect it.  did you look very hard?
13:30:57 <benzrf> oh derp :(
13:31:04 <phaazon> yeah
13:31:11 <phaazon> the closest thing to my zero package
13:31:12 <t7> but i need variadic arguments :P 
13:31:12 <phaazon> is…
13:31:19 <phaazon> MonadPlus
13:31:25 <phaazon> and Plus
13:31:33 <phaazon> (from semigroupoids)
13:31:39 <phaazon> but they’re first-class abstractions
13:31:45 <phaazon> while mine is zero-class
13:31:50 <phaazon> i.e. f a vs. a
13:31:55 <benzrf> oh
13:31:57 <phaazon> a bit like hm
13:31:57 <benzrf> i thught that was a pun
13:32:05 <phaazon> Monoid vs. Alternative
13:32:23 <phaazon> I know introduce Zero vs. whatever you like to use
13:32:44 <phaazon> the problem is that a lot of common type have Semigroup instances while they shouldn’t have one :)
13:32:48 <phaazon> types*
13:33:05 <phaazon> they’re two ways to implement Semigroup for Maybe
13:33:13 <phaazon> either you want a Monoid or a Zero later on
13:33:26 <phaazon> but if we look at the Monad instance
13:33:32 <phaazon> Maybe should only have a Zero instance 
13:33:56 <phaazon> well actually, it shouldn’t have any.
13:34:07 <t7> can i import from parent directory?
13:34:11 <t7> somehow
13:34:22 * hackagebot diagrams-builder 0.7.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.1 (BrentYorgey)
13:36:26 <athan> phaazon: I swear I've seen some stuff like this in arrows...
13:36:30 <athan> @hoogle ArrowZero
13:36:31 <lambdabot> Control.Arrow class Arrow a => ArrowZero a
13:36:34 <athan> :i ArrowZero
13:36:47 <phaazon> a b c
13:36:55 <athan> @info ArrowZero
13:36:55 <lambdabot> ArrowZero
13:36:59 <athan> :|
13:37:17 <phaazon> not a semigroup + absorbing element :)
13:37:38 <byorgey> phaazon: I'm not aware of anything like this that exists already.
13:37:49 <phaazon> neither am I
13:37:53 <phaazon> that’s why I wrote mine
13:37:54 <benzrf> actually Maybe can be semigroupoidal in more than 2 ways
13:37:55 <byorgey> phaazon: in what sorts of situations does the Zero abstraction show up?
13:37:56 <phaazon> and it’s on hackage now
13:38:03 <benzrf> consider the Alternative/MonadPlus instance
13:39:16 <phaazon> byorgey: in any situation that require an absorbing element
13:39:24 <phaazon> requires*
13:39:29 <byorgey> phaazon: can you give an example?
13:39:37 <phaazon> like « if that value occurs, discard anything else »
13:40:04 <phaazon> it’s a way to implement the same behavior than Maybe as a Monad
13:40:08 <phaazon> without the Monad part
13:40:11 <byorgey> right, I see
13:40:20 <phaazon> I wrote the laws
13:40:27 <phaazon> a <> zero = zero <> a = zero
13:40:33 <aweinstock> @src ArrowZero
13:40:33 <lambdabot> Source not found. stty: unknown mode: doofus
13:40:34 <phaazon> give a good idea :)
13:40:43 <phaazon> if you know how to use a Monoid
13:40:49 <phaazon> a Zero is exactly the same thing
13:41:00 <phaazon> but replace the neutral element (mempty) by an absorbing one (zero)
13:41:02 <phaazon> and here you go
13:41:07 <phaazon> I might need to renamed the Bool instances
13:41:17 <phaazon> which are the same than the Monoid’s one (All and Any)
13:41:21 <phaazon> -d
13:41:36 <phaazon> for instance
13:41:42 <phaazon> Any as a Zero
13:42:10 <phaazon> Any False <> Any True = Any True
13:42:19 <phaazon> Any False <> zero = Any True
13:42:29 <phaazon> and All:
13:42:41 <byorgey> what I am really interested in is examples of situations where *having a Zero abstraction* is useful
13:42:55 <byorgey> e.g. are there algorithms you can write which are polymorphic in any Zero instance? etc.
13:43:05 <phaazon> ah
13:43:09 <phaazon> well
13:43:12 <phaazon> I guess so 
13:43:17 <phaazon> like
13:43:51 <phaazon> some kind of Writer with a Semigroup
13:44:03 <phaazon> you could erase the whole “history” by sending a zero
13:44:13 <phaazon> you could use that to, hm, for instance, reset things
13:44:49 <byorgey> it seems to me you can't use it to reset, you can only use it to fail
13:44:53 <htebalaka> you wouldn't be able to continue writing at that point though
13:44:59 <byorgey> because once you send a zero you can never accumualte anything other than zero
13:45:05 <phaazon> htebalaka: yeah, that’s true
13:45:11 <phaazon> byorgey: well
13:45:18 <phaazon> that could be used to close a stream of values then :)
13:45:32 <phaazon> a bit like EOF
13:45:50 <phaazon> I’m sure there’re situations in which Zero would be a good match :)
13:45:56 <byorgey> it doesn't seem like EOF to me either.  It would be like an EOF that erased all the preceding data.
13:46:21 <phaazon> byorgey: not if you have already consumed them
13:46:54 <phaazon> but yeah
13:47:10 <phaazon> it can be used to glue values that need each other to be « true »
13:47:16 <phaazon> otherwise the whole thing is false
13:48:16 <jfeltz> does anyone know what would cause hGetContents proc_stdout to be incredibly slow (on the order of seconds) following a hPutStr proc_in .. for the command  "xargs ls -l" ?
13:48:33 <mniip> jfeltz, buffering?
13:48:35 <jfeltz> I'm essentially trying to reproduce the string for this: echo "/home/jpf/local" | xargs ls -l
13:48:50 <mniip> also are you using ls to programmatically list files in a directory
13:52:41 <hunteriam> How can types be a category when there can be multiple non equal morphisms from A to B
13:53:37 <geekosaur> jfeltz, do you know that that is where the delay is, as opposed to being in ls's sorting or all the stat() calls it needs to make to get information for -l?
13:53:44 <lpaste_> jfeltz pasted “proc pipes and 1-2s delay when running ghci” at http://lpaste.net/136737
13:54:23 * hackagebot monad-peel 0.2 - Lift control operations like exception catching through monad transformers  http://hackage.haskell.org/package/monad-peel-0.2 (SergeyAlirzaev)
13:54:37 <jfeltz> i've not tried this outside of ghci
13:54:42 <glguy> jfeltz: Does it help if you add hFlush proc_in ?
13:55:02 <glguy> or if you add a trailing newline?
13:55:19 <glguy> otherwise what might be happening is that xargs doesn't know if you're done sending
13:55:30 <glguy> until the GC finally notices that the proc_in can be closed
13:55:36 <glguy> because it's no longer in scope
13:55:43 <glguy> (err, not scope, but no longer used)
13:57:07 <jfeltz> glguy: no for \n and/or hFlush
13:57:28 <glguy> jfeltz: What about hClose proc_in?
13:57:37 <glguy> xargs might be waiting to see if there are more filenames to bundle
13:57:44 <greymalkin> Is there a guard-like thing for monads (that doesn't cause IO to throw)
13:58:07 <glguy> I don't know, just guessing some things in absense of other ideas
13:58:20 <magneticduck> I'm trying to use inline-c
13:58:22 <magneticduck> https://github.com/solemnsky/solemnsky-server
13:58:22 <tommd> greymalkin: I'm still unclear what you want besides the `guard` function
13:58:30 <magneticduck> but I get a strange error
13:58:46 <tommd> Ah, so exactly `guard` but in IO does... something else?
13:58:46 <magneticduck> dist/build/solemnsky-server/solemnsky-server-tmp/Main.dyn_o: In function `sccz_info':
13:58:49 <magneticduck> (.text+0xec): undefined reference to `inline_c_0_2f88ee80765ab54834856cc58acd770f9760d5e4'
13:58:57 <magneticduck> ^ that coming from trying to build the haskell project
13:59:02 <magneticduck> during linkin
13:59:03 <greymalkin> tommd: guard will kill IO with the 'mzero
13:59:18 <greymalkin> I'm trying to create an event loop, but the exit condition is in the state
14:00:15 <glguy> jfeltz: Also you can do what you've got there more directly with something like: putStrLn =<< readProcess "xargs" ["ls","-l"] "/home/whateveritwas"
14:01:19 <aweinstock> magneticduck: add a "c-sources:" section to your project.cabal file
14:01:31 <magneticduck> what should I add there?
14:01:33 <magneticduck> using default libraries
14:01:47 <magneticduck> <math.c>?
14:02:21 <aweinstock> https://github.com/fpco/inline-c/blob/master/README.md#how-to-build
14:02:42 <aweinstock> what's the name of the .hs file that's using C.exp?
14:02:44 <magneticduck> I have to have the actual sources to the C sources?
14:03:08 <magneticduck> s/sources/filepaths in the first 'sources'
14:03:09 <aweinstock> the C sources get generated automatically at compile-time
14:03:13 <magneticduck> okay!
14:03:46 <aweinstock> but the names of the files that are going to be generated need to be in the .cabal file so that cabal knows to link them
14:03:52 <jfeltz> glguy: with readProcess or hClose over previous, a different problem occurs: faster output, but only partial
14:03:58 <aweinstock> (hence the linker error "undefined reference to")
14:04:15 <jfeltz> glguy: and it only appears briefly, then disappears 0_o
14:05:15 <aweinstock> if you put the output of "find . -type f" onto lpaste.net, I'd be able to tell what the name of the C files generated would be
14:05:17 <magneticduck> aweinstock: thanks, that works awesome
14:05:27 <aweinstock> (or did you already figure it out?)
14:05:35 <magneticduck> yeah I got it =P
14:05:39 <aweinstock> :)
14:05:43 <magneticduck> I grok my directory strucuture
14:05:47 <magneticduck> structure*
14:07:28 <magneticduck> aweinstock: how would I use a C library from a random point on the filesystem?
14:07:37 <magneticduck> imagine, say, that it's loaded at runtime?
14:07:48 <magneticduck> is that possible, or do I have to link at compile time?
14:07:59 <lpaste_> jfeltz revised “proc pipes and 1-2s delay when running ghci”: “No title” at http://lpaste.net/136737
14:08:28 <aweinstock> magneticduck: a C library as in a .so? a .a and a .h?
14:08:34 <magneticduck> yes
14:08:51 <aweinstock> which? {so} vs {a,h}?
14:09:25 <magneticduck> have everything
14:09:33 <magneticduck> .a, .h's, .so
14:09:37 <aweinstock> if you have just a .so, you can definitely use dlopen/dlsym, but I'm not sure if that's the best way to go
14:10:09 <magneticduck> why not?
14:10:15 <nitrix> Haskell is rotting my brain. I used to be good at C and I'm doing trivial mistakes now.
14:10:40 <aweinstock> because dlopen works at runtime, it's more dynamic, and you catch less errors at compile-time
14:10:48 <nitrix> Funny how it has impacted my methodology when I write code now.
14:10:52 <zmbmartin> Anyone that can help me with this error https://gist.github.com/codedmart/c965ca9cbd158802bfc8#file-error?
14:10:56 <magneticduck> aweinstock: okay
14:11:13 <aweinstock> does Language.C.Inline.include not find the .h?
14:11:21 <magneticduck> er, also, how do I pass bound values in the haskell scope to a C expr?
14:11:27 <magneticduck> I'll check
14:11:32 <magneticduck> uh
14:11:53 <magneticduck> can I, say, somehow parameterize the input to C.include?
14:11:59 <magneticduck> C = Language.C.Inline
14:12:46 <aweinstock> what do you mean parameterise? it's a template haskell function, it runs at compile time
14:13:07 <aweinstock> C.include "/absolute/path/to/header.h"     -- does this work?
14:13:32 <magneticduck> yeah okay
14:13:44 <magneticduck> well, er, I'll figure out a way to get that to work
14:13:49 <magneticduck> using a .. strange setup
14:14:24 <aweinstock> strange in what way?
14:14:31 <magneticduck> nix
14:14:51 <aweinstock> yeah, I don't have experiance with that (am using debian)
14:15:06 <maerwald> magneticduck: I don't even know what this is about, but you can create FHS compatible chroots with nix
14:15:17 <magneticduck> yeah I'm aware
14:15:26 <magneticduck> I can also just put the library I want in the project path
14:16:46 <nitrix> How common is it that people create new functors/applicatives/monad instances designed for specific needs of their application?
14:17:23 <bennofs> nitrix: idk about other people, but for Applicative, I often just use Const/Writer/Product/Compose and make a newtype and derive the Applicative for free :)
14:17:48 <exio4> nitrix: do you count wrappers there?
14:17:51 <nitrix> My understanding is the prelude and the libraries extends the language with new language constructs/semantics, and that you'd normally work with algebraic datastructures of newtypes if that works for you.
14:18:11 <nitrix> exio4: They all seem like wrappers to me already :/
14:18:11 <exio4> nitrix: also, where do you put things like free monads?
14:18:19 <nitrix> I have no idea what free monads are.
14:18:45 <bennofs> nitrix: for example, recently I used WriterT (Ap SomeCustomMonoid) (Reader Env) () 
14:19:36 <nitrix> It doesn't really answer the question though.
14:19:46 <jle`> nitrix: i make new ones sometimes
14:19:58 <jle`> but typically you can construct one that fits your needs using monad transformers
14:20:02 <jle`> or Free
14:20:12 <jle`> and get the instances pre-written, basically
14:20:26 <exio4> but with Free, you're not writing the instances yourself, that's why I asked :P 
14:20:44 <exio4> but in the other hand, the whole point of free is _not_ writing them by yourself...
14:20:45 <nitrix> I basically see Functor/Applicative/etc like design patterns.
14:21:05 <jle`> oh, i write my own functors all the time
14:21:06 <nitrix> In my head, you don't need to introduce new design patterns, only you have a design problem that's very repetitive in your code.
14:21:15 <nitrix> unless*
14:21:24 <nitrix> Is that more or less accurate?
14:22:07 <jle`> i'm not sure what you mean exactly
14:22:17 <nitrix> (Not that I'm advocate of design patterns as they are used mainstream in say, Java, just doing a neutral comparison)
14:22:24 <exio4> "introducing a new design pattern" = a new typeclass, or a new instance?
14:22:45 <nitrix> Let's see if I can rephrase then.
14:22:52 <maerwald> nitrix: I avoid to write them on my own... because when I do, I have to think whether my data type should rather fit in some library (and then, maybe there already is something similar)
14:23:24 <exio4> nitrix: also, http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html 
14:24:18 <nitrix> As a user of the language, it should have already I need already, either in the prelude or on hackage as a library. There's already very powerful idioms that has been imortalized, like pipes or arrows or whatever. Even monads I think came in later, right?
14:24:23 <hunteriam> For two objects A B in category C can there be more than one Morphism A -> B?
14:24:31 <quchen> hunteriam: Sure
14:24:42 <quchen> :t (*2)
14:24:43 <lambdabot> Num a => a -> a
14:24:44 <quchen> :t (*3)
14:24:45 <lambdabot> Num a => a -> a
14:24:49 <bennofs> two morphisms!
14:24:55 <bennofs> :t id
14:24:56 <lambdabot> a -> a
14:24:57 <maerwald> right, only two :P
14:25:13 <lpaste_> jfeltz revised “proc pipes and 1-2s delay when running ghci”: “solution to proc pipes and 1-2s delay when running ghci” at http://lpaste.net/136737
14:25:14 <quchen> :t \n -> (*n) -- parameterized morphism ;-)
14:25:15 <lambdabot> Num a => a -> a -> a
14:25:47 <nitrix> So, I'm wondering, in practice, I shouldn't need to create more of those type to encapsulate a design pattern. Right?
14:25:54 <jfeltz> geekosaur, glguy: see paste if curious
14:25:55 <bennofs> oh, reading reddit, I noticed that I never considered Free (->) ...
14:25:58 <numberten> liquidhaskell seems to have no problem compiling this http://lpaste.net/136739 anyone know why? I would expect it to error on double_bad
14:26:22 <bennofs> and Free (->) is ~ Bazaar from lens? nice..
14:26:34 <bennofs> ah, not really
14:26:36 <glguy> jfeltz: Ah, yes, it's very important to wait for the process :)
14:26:51 <magneticduck> okay, so I want to load a library (.so, .a, and .h files available) and use it with inline-c
14:26:57 <magneticduck> it's not in a place in a FHS filesystem
14:26:57 <quchen> bennofs: What's it for?
14:27:11 <quchen> bennofs: Sounds like some sort of abstract machine
14:27:25 <glguy> jfeltz: but I don't think the readProccess version should have truncated
14:27:33 <magneticduck> ugh
14:27:36 <jfeltz> glguy: i actually figured this out from looking at bits of the readProcess source :P, I keep forgetting that is actually an option to solve problems with Haskell
14:27:44 <magneticduck> the inline-c docs doesn't seem to talk about this?
14:27:49 <bennofs> quchen: yeah. don't know of a usage case, but it's like a consumer of a variadic number of arguments
14:27:59 <glguy> jfeltz: The other thing to be careful of when using runInteractiveProcess is to not allow the stderr to fill up and block
14:28:09 <bennofs> or rather, it requests a variadic number of arguments
14:28:10 <aweinstock> magneticduck: what's FHS in this context?
14:28:12 <quchen> bennofs: Ah, and argument termination is Pure?
14:28:14 <indiagreen> data Empty a = Empty deriving Functor  -- does this already exist?
14:28:17 <bennofs> quchen: yes
14:28:29 <quchen> bennofs: Hm, interesting. The arguments are homogeneous though.
14:28:35 <bennofs> yeah
14:28:36 <magneticduck> aweinstock: standard unix filesystem hierarchy
14:28:40 <mniip> indiagreen, Const ()
14:28:52 <exio4> nitrix: I still ask what what "creating of those types" means, creating a new typeclass, or giving an implementation to one of your types? 
14:28:53 <indiagreen> mniip: well yeah, apart from that
14:28:55 <exio4> indiagreen: proxy 
14:28:57 <quchen> mniip: indiagreen: Proxy.
14:29:00 <exio4> @type Proxy 
14:29:01 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
14:29:06 <quchen> :t Proxy
14:29:07 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
14:29:10 <mniip> oh yeah
14:29:11 <mniip> that
14:29:13 <indiagreen> exio4, quchen: thanks
14:29:52 <aweinstock> magneticduck: so the files that make up the library are on the filesystem, just not in standard places like /usr/lib /usr/include and so on?
14:30:19 <magneticduck> yes
14:30:32 <magneticduck> I can deal with where they are from a 'nix expression', with which I'm building the haskell project
14:30:39 <magneticduck> it's.. complicated
14:31:06 <magneticduck> but if there was a single place in the haskell project (a line in the cabal file say) that I could have the location of the library, I could do it
14:31:07 <aweinstock> how are you building the project? "cabal build"?
14:31:18 <magneticduck> er
14:31:26 <magneticduck> .. yeah, under a few layers
14:32:06 <aweinstock> it looks like there's a "cc-options:" field, you could do something like -L and -I to include library and include directories (respectively)
14:32:46 <magneticduck> so if I have 'include/' and 'lib/', how do I configure the cc-options field?
14:33:57 <aweinstock> cc-options: -L'lib/' -I'include/'
14:34:03 <magneticduck> cool
14:34:41 <aweinstock> (i'm not sure whether the quotes will be passed through a shell or not though, so there might still be some fiddling to do)
14:36:01 <lamefun> Stack = secure package download?
14:37:11 <lpaste_> kyclark pasted “State IO Maybe” at http://lpaste.net/136742
14:37:41 <solidus-river> i have an intersting bucketing problem
14:37:57 <solidus-river> given an ordered list, say [1..10]
14:38:08 <kyclark> I'm struggling to combine State with IO and the possibility of failure.  In this case, I'm just trying to detect the end of the file.  Any pointers?  I believe something about Transformers is the answer, but I can't piece it together.
14:39:49 <hunteriam> What's the problem with the category on the right: http://yogsototh.github.io/Category-Theory-Presentation/#slide-23
14:39:52 <hunteriam> ?
14:40:05 <lpaste_> glguy annotated “State IO Maybe” with “State IO Maybe (annotation)” at http://lpaste.net/136742#a136745
14:41:18 <magneticduck> aweinstock: thanks, I think that worked
14:41:24 <kyclark> @glguy Thanks!
14:41:25 <lambdabot> Unknown command, try @list
14:41:41 <glguy> kyclark: @ is for bot commands
14:41:46 <glguy> You're welcome.
14:41:59 <aweinstock> magneticduck: glad to hear it
14:44:48 <magneticduck> aweinstock: do you know if inline C supports writing stuff in C++?
14:44:52 * magneticduck super confused
14:55:53 <kyclark> given "lines :: [Maybe String]" how do I determine if they are all "Nothing"?
14:56:10 <kyclark> "sequence" just tells me if one is Nothing.
14:56:23 <benzrf> kyclark: all (==Nothing)
14:56:26 <glguy> msum would give you the first Nothing
14:56:29 <glguy> err, Just
14:56:42 <benzrf> or,
14:56:44 <glguy> all isNothing is nice, too
14:56:45 <benzrf> any isJust
14:56:52 <benzrf> if you want short circuiting
14:56:59 <benzrf> oh wait
14:57:02 <kyclark> wow, so simple!
14:57:06 <benzrf> i guess all would probably short circuit too
14:57:13 <benzrf> kyclark: what are you doing exactly
14:57:55 <kyclark> I'm opening many files and reading them all line-by-line.  When they are all exhausted, I should stop.
14:58:20 <benzrf> dont suppose youre reimplementing paste?
14:58:49 <kyclark> You, sir, are very insightful.  I'm racing to beat my boss on this who is using paste.
14:59:25 * hackagebot bloodhound 0.7.0.1 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.7.0.1 (bitemyapp)
14:59:26 <benzrf> ha
14:59:56 <kyclark> The files don't all have the same number of lines.  She's using Perl to create a temp file that has the missing lines filled in.  I've written a solution in Perl that handles this, and now I'm trying to write it in Haskell.
15:00:10 <benzrf> huh
15:00:16 <kyclark> https://github.com/hurwitzlab/readabundance_fastbit/blob/master/scripts/workers/mk-csv.pl
15:00:31 <benzrf> sorry occupied with other stuff atm but
15:00:58 <benzrf> absent thought:
15:01:10 <benzrf> :t foldr (++) . Compose
15:01:11 <lambdabot>     Not in scope: data constructor ‘Compose’
15:01:11 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
15:01:14 <benzrf> er
15:01:19 <benzrf> @let import Data.Functor.Compose
15:01:21 <lambdabot>  Defined.
15:01:23 <benzrf> :t foldr (++) . Compose
15:01:24 <lambdabot>     Couldn't match type ‘Compose f g a1’ with ‘[a]’
15:01:24 <lambdabot>     Expected type: f (g a1) -> [a]
15:01:24 <lambdabot>       Actual type: f (g a1) -> Compose f g a1
15:01:48 <benzrf> oh wait i want a monoid fold
15:01:53 <benzrf> what's the Foldable monoid fold method again?
15:03:09 <Welkin> benzrf: ?
15:03:12 <Welkin> you mean <> ?
15:03:16 <Welkin> mappend
15:04:00 <benzrf> like foldMap id
15:04:19 <benzrf> :t fold
15:04:20 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:04:22 <benzrf> oh :|
15:04:26 * hackagebot th-orphans 0.12.2 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.12.2 (MichaelSloan)
15:04:26 <benzrf> :t fold . Compose
15:04:27 <lambdabot> (Foldable f, Foldable g, Monoid c) => f (g c) -> c
15:04:28 <benzrf> woo
15:04:58 <benzrf> > (fold . Compose) [Just "hello", Nothing, Nothing, Just " world!", Nothing]
15:04:59 <lambdabot>  "hello world!"
15:05:31 <kyclark> oh, neat!
15:06:31 <Welkin> :t Compose
15:06:32 <lambdabot> f (g a) -> Compose f g a
15:06:37 <hunteriam> http://yogsototh.github.io/Category-Theory-Presentation/#slide-23
15:06:43 <hunteriam> What's wrong with the category on the right here
15:08:14 <benzrf> Foldable instances compose!
15:08:17 <benzrf> :D
15:09:00 <benzrf> kyclark: do you know about Foldable and Compose
15:09:31 <kyclark> I'm vaguely aware of Foldable things, have encountered function composition
15:09:47 <fosterite> hunteriam: associative law doesn't hold for composition
15:12:31 <circ-user-P4wsi> I am interested in using types for program verification. Are there some inspiring examples of the same, in haskell or otherwise.
15:14:12 <benzrf> kyclark: Compose is like so:
15:14:26 <benzrf> newtype Compose f g a = Compose {getCompose :: f (g a)}
15:14:26 * hackagebot esqueleto 2.2.10 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.10 (FelipeLessa)
15:14:53 <benzrf> kyclark: so 'Compose f g' is a partially-applied type constructor that acts as the composition of type constructors f and g
15:15:30 <benzrf> kyclark: in particular, Compose [] Maybe is a type constructor such that Compose [] Maybe a is a newtype for [Maybe a]
15:16:36 <jle`> in this case though Compose Maybe [] is more relevant, no? :)
15:16:45 <benzrf> jle`: well, thats not what i used
15:17:07 <jle`> oh
15:17:09 <jle`> i misread
15:17:10 <jle`> sorry ^^
15:17:21 <fosterite> circ-user-P4wsi: that's an entire field
15:17:51 <circ-user-P4wsi> fosterite: Well then I am interested :). Any resources ?
15:18:31 <fosterite> circ-user-P4wsi: liquid haskell is a popular tool for verifying haskell progrmas
15:19:19 <benzrf> i prefer gaseous haskell
15:19:27 * hackagebot potato-tool 0.1.0 - A Portable command line toolset written in Haskell for interacting with the Dreamcast Virtual Memory Unit filesystem.  Named after the 8-bit Sanyo LC8670 Potato CPU contained in the VMU.  http://hackage.haskell.org/package/potato-tool-0.1.0 (RossMeikleham)
15:19:42 <mniip> if I have a type family Foo, how can I make haskell "understand" that Show a => Show (Foo a)
15:19:49 <mniip> closed type family even
15:20:29 <circ-user-P4wsi> benzrf: Haha, caught me on that one
15:20:41 <circ-user-P4wsi> fosterite: Thanks. I am checking it
15:21:00 <benzrf> mniip: u cant write an instance? 
15:21:07 <benzrf> oic i think
15:21:08 <monochrom> plasma haskell throws flames at you every time you make a type error. including dependent type error.
15:21:16 <mniip> you can't write an instance for a type family
15:21:23 <benzrf> mniip: that may be out of reach of haskell's wimpy type system
15:21:29 <benzrf> maybe try idris?
15:21:43 <mniip> huh
15:21:49 * monochrom thinks outside the 3 states!
15:24:27 * hackagebot potato-tool 0.1.0.1 - Command line Dreamcast VMU filesystem toolset.  http://hackage.haskell.org/package/potato-tool-0.1.0.1 (RossMeikleham)
15:24:52 <Peaker> mniip: why not require a (Show (Foo a)) where you require a (Show a) and have a (Foo a)?
15:25:09 <lpaste_> elbiot pasted “Problem with building a module with cabal” at http://lpaste.net/136749
15:27:48 <benzrf> tfw no dependent types
15:29:26 <mniip> lol
15:29:44 <mniip> I already encountered like 5 different GHC crashes while writing this stuff o.o
15:30:14 <elbiot> Any ideas on how to point cabal to a library it isn't finding?
15:35:59 <Peaker> mniip: When I find I need to enable tons of extensions I usually revert the change
15:36:06 <Peaker> mniip: this happens frequently with type families
15:36:11 <Peaker> so I tend to avoid type families most of the time
15:37:13 <nkaretnikov> elbiot: I guess you need to provide more info
15:37:17 <nkaretnikov> what library?
15:37:23 <nkaretnikov> what does cabal-install say?
15:37:27 <nkaretnikov> etc
15:38:51 <elbiot> is "cabal-install" different from "cabal install"?
15:39:11 <elbiot> I'm very new here
15:39:47 <lpaste_> elbiot pasted “cabal install output” at http://lpaste.net/136752
15:40:36 <hpc> elbiot: Cabal is a package that contains general library stuff for the whole cabal family of utilities
15:40:44 <hpc> cabal-install is the package that contains the cabal utility itself
15:40:51 <hpc> "cabal install" is a subcommand of cabal
15:41:18 <jle`> cabal is an execuable, like ls, rm, ghc, etc
15:41:23 <elbiot> The module is the example module in HaPy-ffi
15:41:25 <elbiot> https://github.com/sakana/HaPy/tree/master/example/haskell
15:41:38 <jle`> so cabal install is running the cabal execuable with the command line argument "install"
15:42:19 <jle`> cabal-install is the haskell package that builds `cabal`, so it's like the source of cabal
15:42:59 <elbiot> Yeah, I got that cabal-install was the package.  But I posted the relevant error from "cabal install" and nkaretnikov asked to see "what does cabal-install say?"
15:43:01 <jle`> so if you run ghc on cabal-install to compile it, you get the cabal executable
15:43:19 <jle`> oh i didn't see that part
15:43:26 <jle`> they probably meant cabal install
15:44:17 <elbiot> Sorry, I posted an lpaste with the details of my question.  I don't know if it got seen.  Here it is again: http://lpaste.net/136749
15:49:28 * hackagebot zero 0.1.2 - Semigroups with absorption  http://hackage.haskell.org/package/zero-0.1.2 (DimitriSabadie)
15:55:37 <lpaste_> mniip pasted “welp” at http://lpaste.net/136753
15:55:45 <mniip> any idea why that happens
16:00:59 <NeverDie> Do the drop/take functions use any pattern matching? Or does it just work by mapping a new list before/after the n'th element?
16:01:16 <hpc> @src drop
16:01:16 <lambdabot> drop n xs     | n <= 0 = xs
16:01:16 <lambdabot> drop _ []              = []
16:01:16 <lambdabot> drop n (_:xs)          = drop (n-1) xs
16:01:18 <hpc> @src take
16:01:18 <lambdabot> take n _      | n <= 0 = []
16:01:18 <lambdabot> take _ []              = []
16:01:18 <lambdabot> take n (x:xs)          = x : take (n-1) xs
16:02:16 <NeverDie> hpc: I don't get it.
16:02:32 <hpc> that's the definition of drop and take
16:03:07 <maerwald> fascinating
16:03:42 <monochrom> it means that drop and take use pattern matching.
16:04:01 <NeverDie> How does it use pattern matching?
16:04:10 <monochrom> OTOH, that doesn't conflict with "map a new list", really
16:04:15 <mniip> NeverDie, you just saw their definition...
16:04:27 <NeverDie> It's my 4th day doing Haskell, I'm blind.
16:04:34 <monochrom> "take n (x:xs) = ..." uses pattern matching. the "(x:xs)" there is a pattern.
16:05:03 <htebalaka> "n" is also a pattern, though one that always matches
16:05:14 <monochrom> yes
16:05:25 <athan> NeverDie: Blind from seeing the light, right? :v
16:05:29 <mniip> is there a way to make an invertible type family
16:05:33 <NeverDie> athan: It's too bright.
16:05:39 <htebalaka> welcome to haskell btw :)
16:05:44 <mniip> fundeps seem to malfunction terribly
16:06:06 <athan> mniip: With polymorphic instances, you mean?
16:06:11 <mniip> yes
16:06:17 <athan> hmm
16:06:23 <mniip> invertible with polymoprhic cases/instanecs
16:06:28 <athan> mniip: Do you need terms inhabiting your family?
16:06:38 <mniip> hm?
16:06:42 <athan> s/family/applied family
16:06:53 <hpc> NeverDie: basically, read a function definition from the top down
16:06:55 <athan> mniip: type families are easy when only working with, say, DataKinds
16:07:10 <NeverDie> htebalaka: Thanks!
16:07:10 <mniip> athan, not sure I understand the question
16:07:14 <NeverDie> hpc: Will do.
16:07:15 <hpc> NeverDie: look at each pattern and say "does the input look like the pattern" (for a technical definition of "looks like")
16:07:39 <athan> mniip: Why not use Either?
16:07:40 <hpc> NeverDie: when a pattern matches, the result is what's on the other side of the equals sign
16:07:46 <NeverDie> I mean, drop is essentially starting at the x'th element and stopping at the y'th element minus one right?
16:07:59 <mniip> athan, how would I use either
16:08:01 <NeverDie> Or not element, index I mean.
16:08:49 <hpc> well, let's step through an example
16:08:49 <athan> mniip: say you have two types A and B, in your original idea, you would have families F :: * -> *, and G :: * -> *
16:08:49 <hpc> drop 3 "abcdefg"
16:08:49 <athan> s.t. F A = B and G B = A, correct?
16:08:49 <hpc> er
16:08:49 <hpc> drop 3 [1,2,3,4,5] -- a bit more explicit
16:09:10 <hpc> that hits the third pattern but not the first two
16:09:16 <athan> hmm
16:09:50 <mniip> athan, I have a typeclass with 'F a -> a' and 'a -> F a'
16:10:00 <mniip> (where a is in instance head0
16:10:01 <mniip> )
16:10:07 <NeverDie> hpc: So it drops the patterns before the third?
16:10:28 <hpc> so the result is
16:10:28 <hpc> drop 2 [2,3,4,5]
16:10:28 <athan> mniip: Are you aware of /closed/ type families?
16:10:33 <mniip> athan, yes
16:10:39 <mniip> initially F was a closed type family
16:10:56 <mniip> but then it couldn't figure 'a' from 'F a'
16:11:01 <htebalaka> including the third
16:11:10 <htebalaka> well, indexing from 1 :/
16:11:52 <hpc> repeat until drop stops recursing, and you get
16:11:52 <hpc> > drop 3 [1,2,3,4,5]
16:11:53 <lambdabot>  [4,5]
16:12:05 <NeverDie> hpc: 
16:12:06 <NeverDie> drop == return new list with the elements after index x dropped
16:12:06 <NeverDie> take == return new list with only the first elements before index x
16:12:11 <mniip> athan, in full, I need some type inference construct that acts as a bijection between (a, b) and c, such that (a, b) can be inferred from c, and c can be inferred from (a, b)
16:12:12 <NeverDie> Would that be correct?
16:12:16 <eds> jle`: Hey! GADTs worked :D How do I define a FoldL function for my GADT? I tried but I think my approach is wrong. Line 41 - function definition, line 62 - eval of FoldL and line 95: error on lpaste. Code and error: http://lpaste.net/136444.
16:12:35 <hpc> NeverDie: pretty much
16:13:13 <htebalaka> those two definitions sound similar.. i think you mean "drop == return new list with the elements *before* index x dropped"
16:13:20 <athan> mniip: Fundeps can do this, but everything will have to be monomorphic :\
16:13:34 <mniip> that's a problem
16:13:34 <athan> I'm struggling with this right now, for heterogeneous numeric operators :\
16:13:41 <hpc> htebalaka: er, yeah
16:13:52 <athan> it makes the type inference solid, though
16:14:02 <mniip> athan, http://lpaste.net/2497135015716978688
16:14:02 <athan> when you can do `a b -> result`
16:14:14 <athan> wow lpaste has had some activity :x
16:14:29 * hackagebot yesod-table 1.0.1 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-1.0.1 (andrewthad)
16:14:40 <athan> mniip: Why not use templatehaskell for the generation?
16:14:42 <ttt_fff> has anyone else reached the point, where it's like; when in douct, create extra types (thus making types more finegrained), and make it the compiler's problem to sort things out
16:14:50 <mniip> athan, I only need these 6 instances
16:14:57 <athan> oh
16:14:59 <htebalaka> operationally, one big difference is take has to construct a new list from scratch, while drop returns some tail portion which is shared with the original list
16:15:11 <mniip> those are the only valid numbers in my context
16:15:12 <fosterite> ttt_fff: absolutely
16:15:16 <athan> mniip: You could make it a recursive tuple
16:15:31 <mniip> and that would help how
16:15:31 <fosterite> "not sure if this is safe, add another bookkeeping type parameter"
16:15:38 <ttt_fff> so instead of having "Text" all over the place, we have things like data Name = Name Text, data AnimalName = AnimalName Text; etc ...
16:15:43 <hpc> and suddenly you have lens
16:15:48 <hpc> ;)
16:16:11 <hpc> ttt_fff: well, newtype hopefully
16:16:14 <athan> so `type family ReplicateN (n :: Nat) (e :: *) :: * where; ReplicateN 2 e = (e,e); ReplicateN n e = (e, ReplicateN (n-1) e)
16:16:17 <athan> `
16:16:21 <ttt_fff> hpc : how do you suddenly get lens ?
16:16:45 <hpc> ttt_fff: < fosterite> "not sure if this is safe, add another bookkeeping type parameter"
16:16:56 <athan> mniip: cause types, yo
16:17:01 <hpc> data Foo a b c d e f g = ...
16:17:15 <hpc> just being silly
16:17:24 <fosterite> GothicCathedral a g n u s d e i = ...
16:18:35 <mniip> athan, would it be able to infer e ~ x from (Replicate n e r, r ~ (x, x)) 
16:19:13 <maerwald> ttt_fff: no, I haven't reached the point, because I find it terrible to extract values out of meaningless type constructors
16:19:41 <ttt_fff> maerwald: I find I rarely need to extract the values
16:19:51 <ttt_fff> becuase I just build data structures 'over' the constructors
16:20:05 <maerwald> complexity for the sake of complexity
16:20:07 <greymalkin> How should I lift an `orElse` statement into a (StateT Private STM a) monad?
16:20:25 <greymalkin> Or any a -> b -> m c, for that matter.
16:20:32 <greymalkin> er..
16:20:52 <greymalkin> m a -> m b -> StateT Private m a -> StateT Private m b
16:21:10 <greymalkin> oh... that actually helped.
16:21:54 <NeverDie> hpc: What's the type signature for both of the functions?
16:22:07 <ttt_fff> compelxity for the sake so that I don't use data Meter = Meter Float as a data Foot = Foot Float
16:23:03 <athan> mniip: Wait, why `r`?
16:23:13 <mniip> oh
16:23:15 <mniip> I misread your code
16:23:19 <athan> ReplicateN :: * -> * -> *
16:23:27 <athan> er
16:23:30 <mniip> athan, would it be able to infer e ~ x from (Replicate n e ~ (x, x)) 
16:23:33 <athan> ReplicateN :: Nat -> * -> *
16:24:09 <athan> mniip: And that n ~ 2, pretty sure
16:24:10 <hexagoxel> mniip: type families? associated types?
16:24:22 <athan> I remember injective type families being worked on
16:24:27 <athan> hexagoxel: type families
16:25:02 <athan> https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies
16:25:21 <mniip>     Nested type family application      in the type family application: Replicate (n - 1) e    (Use UndecidableInstances to permit this)
16:25:49 <mniip> undecidable is what I'd rather avoid because intuitively this is rather decidable
16:26:22 <athan> mniip: UndecidableInstances isn't that bad
16:26:26 <mniip> yes it is
16:26:30 <athan> worst case is that it won't compile, pretty sure
16:26:34 <athan> :x
16:26:36 <mniip> it is bad when it's actually decidable
16:26:46 <mniip> means you're doing something wrong
16:26:52 * athan shrugs
16:27:22 * mniip unrolls the stack
16:27:29 <athan> -XFireMissles
16:27:37 <mniip> I think it's easier to explain that Show e => Show (Replicate n e) to ghc than this
16:28:05 <athan> I dig this: https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies#Real-lifeusecases
16:28:23 * athan metashrugs
16:35:26 <orion> > f
16:35:27 <lambdabot>      No instance for (Show a0)
16:35:27 <lambdabot>        arising from a use of ‘show_M191249170668633801919490’
16:35:27 <lambdabot>      The type variable ‘a0’ is ambiguous
16:36:47 <lamefun> Can I write C in Haskell?
16:37:32 <athan_> lamefun: o_o
16:37:32 <Cale> lamefun: What does that mean?
16:37:34 <athan_> whyyyyyyyy
16:37:36 <lamefun> Or C++.
16:37:58 <athan_> lamefun: You could write a compiler, yes
16:37:58 <Cale> What do you mean by "write C" (or C++)
16:38:03 <athan_> and make a C / C++ dsl
16:38:29 <Cale> You could indeed write a compiler, sure. In fact, it's probably easier than writing a self-hosting C compiler :D
16:39:00 <Cale> Writing a C++ compiler sounds like a horrible journey to embark on, but yeah, that's theoretically possible too.
16:39:10 <mniip> wat
16:39:11 <lamefun> Cale: mix Haskell and C/C++ code in a .hs file so that ai don't need two (.cpp and .hs) files when binding C/C++ libraries.
16:39:36 <maerwald> after hearing "c++ compiler" I start to feel dizzy
16:39:37 <maerwald> uhm
16:39:38 <mniip> this question probably sounds weird,
16:39:43 <mniip> but why is there no Show for 16-tuples
16:39:59 <Cale> mniip: Because each of the instances has to be written out separately.
16:40:13 <athan> mniip: recursion ftw
16:40:14 <athan> :P
16:40:15 <Cale> and so only tuples up to a certain size actually have instances
16:40:18 <t7> because haskell can't into templates
16:40:42 <t7> c++ is better yet again
16:40:48 <Cale> Well, it's not so much about templates or anything, but the fact that the tuple types are completely separate and unrelated from one another
16:41:04 <maerwald> which is a good thing
16:41:05 <Cale> Also, you can write the instances using Template Haskell
16:41:11 <mniip> athan, I think I'll go for halving recutsion
16:41:29 <athan> mniip: Halving? like a binary tree?
16:41:34 <mniip> yes
16:41:36 <Cale> But wasting code space on instances of Show for tuple types which nobody is ever going to use seems senseless.
16:41:45 <athan> :)
16:41:45 <t7> in agda you could do cool tuples 
16:41:56 <athan> t7: show me!! :D
16:42:00 <t7> Tuple : [Set] -> Set
16:42:05 <athan> :O
16:42:08 <Cale> If you're using anything larger than a triple, you should usually define a proper separate data type.
16:43:15 <maerwald> Cale: better go for nested tuples :P
16:43:23 <hexagoxel> mniip: but you can just use two type families to get both direction, right?
16:43:33 <maerwald> they all have a show instance, so...
16:43:44 <mniip> hexagoxel, then I'll have two functions
16:43:54 <mniip> F a -> a, and r -> ReverseF r
16:44:01 <mniip> depending on what kind of inference I want
16:44:09 <mniip> which is a solution but a poor one
16:44:51 <athan> This sounds like a job for... procrastination!
16:44:51 <Cale> maerwald: You can do that too, if you must :)
16:45:13 <lpaste_> hexagoxel annotated “welp” with “welp (annotation)” at http://lpaste.net/136753#a136755
16:45:35 <hexagoxel> mniip: not sufficient?
16:45:40 <mniip> hexagoxel, yeah
16:45:43 <mniip> I'd like real inference
16:46:04 <maerwald> Cale: I think I did when dealing with ranges of coordinates in diagrams. Was still easier to handle then some obscure newtype you have to unwrap, write instances for and whatnot
16:46:48 <benzrf> Fixpoint tuple (ts : list Type) : Type :=
16:46:50 <benzrf> match ts with
16:46:52 <benzrf> | nil => unit
16:46:52 <maerwald> but that was the only use case of nested tuples ever for me
16:46:54 <benzrf> | cons t ts' => (t * tuple ts')%type
16:46:56 <benzrf> end.
16:48:28 <mniip> athan, and it worked!
16:48:39 <athan> benzrf: Man I really want to learn Coq :(
16:48:43 <athan> mniip: :D
16:49:16 <athan> friggin cool ._.
16:49:22 <mniip> athan, basically lisp: ((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1))))
16:49:49 <athan> Ha!
16:49:50 <athan> nice
16:50:17 <mniip> I wonder if I can combine Acme.Cadre with this to obtain a nice [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] when needed
16:50:48 <orion> What's the lambdabot command for refactoring code?
16:50:56 <mniip> orion, refactoring?
16:50:58 <benzrf> what kind of refactoring, orion
16:50:59 <benzrf> do you mean @pl?
16:51:01 <orion> As in, automatic currying, etc.
16:51:03 <mniip> lambdabot has multiple
16:51:04 <orion> Point free?
16:51:10 <orion> I think that's what it's called.
16:51:12 <mniip> pl is pointless
16:51:16 <benzrf> @pl f x = g x
16:51:16 <lambdabot> f = g
16:51:19 <orion> @pl getDatestamp p = parseTime defaultTimeLocale "%Y%m%dT%H%M%S%z" =<< pcreated p
16:51:19 <lambdabot> getDatestamp = (parseTime defaultTimeLocale "%Y%m%dT%H%M%S%z" =<<) . pcreated
16:51:26 <orion> Thanks.
16:51:31 <benzrf> that looks fine to me orion
16:51:38 <mniip> not so much to me
16:51:47 <benzrf> i mean your current code
16:51:51 <orion> benzrf: You have no idea.
16:51:52 <mniip> consider: pcreated >=> parseTime...
16:52:02 <benzrf> oh, derp
16:52:06 <benzrf> shouldve thought of that
16:52:34 <mniip> automatic pointlessing is rarely useful
16:52:40 <orion> What is >=> called, and from where can I import it?
16:52:47 <mniip> Control.Monad
16:53:00 <mniip> >=> is kleisli arrow composition
16:53:08 <orion> Awesome, thank you for the tip. :)
16:53:17 <mniip> :t (>=>)
16:53:18 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:53:30 <mniip> you can probably see what it does
16:53:42 <benzrf> :t (<=<)
16:53:43 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:54:48 <orion> Indeed.
16:55:11 <mniip> under right conditions, >=> == >>> from Control.Category
16:55:18 <phaazon> (>=>) and (<=<) are fun to use
16:56:03 <mniip> should've named >.> and <.<
16:56:10 <mniip> because they're compositions, right?
16:56:23 <phaazon> meh, no
16:56:29 <phaazon> composition is also >>>
16:56:43 <phaazon> >=> is good to me
16:56:45 <mniip> kleisli compositions I mean
16:57:00 <phaazon> pipes also follow that rule
16:57:47 <mniip> hmm
16:57:53 <mniip> I should learn TH
16:58:00 <mniip> where do I start
16:58:07 <phaazon> > Just >=> Just
16:58:09 <lambdabot>      No instance for (Typeable c0)
16:58:09 <lambdabot>        arising from a use of ‘show_M803852858880164658919856’
16:58:09 <lambdabot>      In the expression:
16:58:15 <phaazon> :t Just >=> Just
16:58:16 <lambdabot> c -> Maybe c
16:58:34 <phaazon> > (Just >=> Just $ 3) == Just 3
16:58:36 <lambdabot>  True
16:59:10 <mniip> phaazon, that's just monadic laws
16:59:21 <mniip> Just ~~ return, and return >=> f = f
17:00:17 <athan> > replicate 4 >=> const [] "boo"
17:00:19 <lambdabot>      Couldn't match expected type ‘b -> [c]’ with actual type ‘[t0]’
17:00:19 <lambdabot>      In the first argument of ‘const’, namely ‘[]’
17:00:19 <lambdabot>      In the second argument of ‘(>=>)’, namely ‘const [] "boo"’
17:00:24 <athan> oop
17:00:27 <athan> > replicate 4 >=> const [] $ "boo"
17:00:29 <lambdabot>  []
17:02:48 <phaazon> > replicate 4 >=> take 3 $ "foobar"
17:02:50 <lambdabot>  "foofoofoofoo"
17:03:25 <phaazon> well, good night.
17:03:33 <athan> :P
17:03:34 <athan> night!
17:03:39 <phaazon> :)
17:13:40 <mniip> ooh
17:14:17 <mniip> so internally, 'data Foo x where Foo :: Foo ()' turns into 'data Foo x = forall x. x ~ () => Foo'
17:14:29 <mniip> er no
17:14:40 <mniip> 'data Foo x = forall. x ~ () => Foo'
17:15:04 <codehero> i'm currently going through real world haskell to refresh my knowledge, and in one exercise i was asked to implement safe alternatives for head, tail, init, and last. now for init, i have this:
17:15:06 <codehero> safeInit x = fmap reverse (safeTail (reverse x))
17:15:13 <codehero> i was wondering if i could make it a bit.... nicer
17:15:31 <codehero> a double reverse seems a bit redundant
17:15:40 <arkeet> what's the type?
17:15:46 <Cale> codehero: You could define it recursively, or using foldr1
17:15:46 <arkeet> [a] -> Maybe [a]?
17:15:53 <codehero> yeah
17:15:54 <arkeet> Cale: foldr1 is pretty unsafe imo
17:16:03 <Cale> Er, foldr rather :)
17:16:29 <Cale> Well, you could do it safely with foldr1 probably
17:16:33 <arkeet> consider 
17:16:37 <arkeet> what is safeInit []
17:16:40 <Cale> (just have to ensure the list you give isn't empty)
17:16:44 <arkeet> what is safeInit (x:xs) in terms of safeInit xs
17:17:13 <codehero> well. safeInit [] is Nothing
17:17:29 <arkeet> mhm
17:17:58 <codehero> i could do it recursively and check until i get (x:[])
17:18:07 <codehero> but i'm not sure if that's nicer
17:18:12 <hiptobecubic> codehero, it is.
17:18:16 <codehero> okay
17:19:44 <arkeet> bonus points if you can make safeInit work on infinite lists.
17:20:15 <arkeet> (the version with reverse does not.)
17:20:16 <codehero> wouldn't that just be infinite?
17:20:30 <codehero> hm
17:20:33 <codehero> i see
17:20:38 <arkeet> when given an infinite list, it should result in Just the same list.
17:20:51 <codehero> oh. okay
17:20:52 <arkeet> instead of running forever unproductively.
17:22:27 <nitrix> Ah!
17:22:29 <arkeet> > (safeInit [], safeInit [1], safeInit [1,2], safeInit [1..])
17:22:29 <nitrix> https://youtu.be/4tXna2Al3Ps?t=2m38s
17:22:31 <lambdabot>  (Nothing,Just [],Just [1],Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18...
17:22:44 <nitrix> 2:53, he said `Nothing` and `Just a` were types.
17:22:50 <nitrix> That sounds wrong to me,
17:23:02 <arkeet> that is indeed wrong.
17:23:13 <arkeet> but then he corrects himself immediately after.
17:23:40 <nitrix> Oh okay, I paused to validate immediatly with the channel. I'll give him a chance then.
17:23:43 * nitrix keeps watching
17:24:20 <mauke> :k Nothing
17:24:21 <lambdabot> Maybe k
17:24:25 <nitrix> Ah yeah, you're right. He does correct himself.
17:25:01 <codehero> of course, it won't work if you switch around <$> and <*>. damn you brain
17:26:08 <codehero> http://lpaste.net/136757
17:26:10 <codehero> there we go
17:26:34 <codehero> "works" with infinite lists
17:26:44 <arkeet> okay, looks like that works.
17:26:54 <arkeet> a couple things though:
17:27:11 <arkeet> you can pattern match on [x] instead of (x:[])
17:27:22 <arkeet> and then
17:27:57 <arkeet> (++) <$> Just [x] <*> y = Just ([x] ++) <*> y = fmap ([x] ++) y
17:28:02 <arkeet> and ([x] ++) = (x :)
17:28:37 <arkeet> so the last line could just be
17:28:43 <arkeet> safeInit (x:xs) = fmap (x:) (safeInit xs)
17:29:08 <codehero> oh
17:29:10 <codehero> that's nicer
17:29:44 <codehero> oh lol
17:29:49 <codehero> damn
17:29:54 <codehero> i forgot to throw the last x away
17:30:01 <arkeet> aha.
17:30:03 <codehero> the bracket should be empty
17:30:05 <arkeet> I didn't notice :-)
17:30:05 <codehero> lol
17:30:10 <codehero> no
17:30:12 <codehero> wait
17:30:16 <arkeet> you're right.
17:30:17 <codehero> now it produces an empty list
17:30:24 <codehero> weird
17:30:26 <arkeet> no no.
17:30:30 <arkeet> line 4 was fine.
17:30:37 <arkeet> line 3 should be safeInit [x] = Just []
17:30:47 <codehero> yeah. that's what i did
17:30:54 <arkeet> then it should work.
17:30:55 <nitrix> Does lambdabot supports stdin?
17:31:01 <arkeet> lambdabot does not do IO.
17:31:10 <codehero> it *should* work
17:31:12 <nitrix> > putStrLn "Boo"
17:31:13 <codehero> but it doesn't
17:31:14 <lambdabot>  <IO ()>
17:31:28 <nitrix> arkeet: Any reason for this?
17:31:36 <arkeet> security.
17:31:41 <nitrix> Makes sense.
17:32:01 <nitrix> I guess that's not necessary since as a repl, you can have itermediate values anyway.
17:32:06 <codehero> okay
17:32:08 <codehero> my fault
17:32:15 <codehero> i did safeInit ["hello"]
17:32:17 <codehero> ...
17:32:57 <bjornars> arkeet: little know fact, lambdabot is actually hosted on the US nuclear defence mainframe
17:33:17 <codehero> lol
17:33:43 <arkeet> codehero: this is what I had written btw:
17:33:45 <lpaste_> arkeet annotated “No title” with “No title (annotation)” at http://lpaste.net/136757#a136758
17:34:27 <codehero> hmm
17:34:27 <nitrix> bjornars: When they mean garbage collect, they mean they just send a network reboot signal to the machine because they lost it somewhere in a closet.
17:34:40 <codehero> i think "fmap (x:) (safeInit xs)"
17:34:44 <codehero> is much more readable
17:35:10 <codehero> so why would you do something like "Just (case safeInit xs of Nothing -> []; Just ys -> x:ys)"?
17:35:11 <arkeet> more readable than what?
17:35:22 <arkeet> well I did something slightly different.
17:35:29 <arkeet> I only have two cases, not a separate one for a 1-element list.
17:35:33 <codehero> oh
17:35:35 <codehero> right
17:35:43 <codehero> i see
17:36:51 <arkeet> I dunno. I'm fine with either.
17:37:45 <arkeet> exercise: why didn't I write this instead? safeInit (x:xs) = case safeInit xs of Nothing -> Just []; Just ys -> Just (x:ys)
17:39:09 <slack1256> A time ago someone said that Arrows were equivalent to Category + Applicative. Is this explained somewhere? code examples?
17:39:28 <arkeet> you can write all the Arrow methods with Category and Applicative methods.
17:39:28 <codehero> arkeet: well. this is just wrong "Nothing -> Just [];"
17:39:31 <arkeet> and vice versa.
17:39:32 * hackagebot xml-conduit 1.3.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.3.1 (MichaelSnoyman)
17:39:46 <arkeet> codehero: why is that wrong?
17:40:12 <codehero> well. you're turning a Nothing into a Just. oh wait
17:40:14 <codehero> nah
17:40:16 <codehero> lol
17:40:26 <codehero> umm
17:40:36 <nolrai66> It certianly werid.
17:40:47 <nolrai66> Why not "Nothing -> []"
17:40:53 <arkeet> that has the wrong type.
17:41:06 <nolrai66> What is this fuction doing?
17:41:22 <arkeet> > safeInit []
17:41:23 <slack1256> but is it practical? Can you do the same things as before on Category + Applicative with the same size of the Arrow version?
17:41:24 <lambdabot>  Nothing
17:41:25 <arkeet> > safeInit [1,2,3]
17:41:26 <lambdabot>  Just [1,2]
17:41:48 <codehero> well. i guess then there's nothing really wrong with the function
17:41:52 <arkeet> slack1256: I think the main reason to use Arrow is to let you use arrow syntax.
17:42:01 <arkeet> codehero: there is an important difference though.
17:42:04 <arkeet> consider what happens on an infinite list.
17:43:14 <arkeet> well, what happens is that you end up with a stack overflow.
17:43:28 <codehero> really?
17:43:31 <codehero> why?
17:44:02 <codehero> > safeInit [1..]
17:44:03 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
17:44:05 <arkeet> because it must traverse the entire list before it can return Just anything.
17:44:06 <roboguy_> slack1256: you might be interested in this thing I wrote up a while back: http://lpaste.net/100875
17:44:14 <nolrai66> Nope.
17:44:23 <nolrai66> To arkeet.
17:44:25 <arkeet> @let badSafeInit [] = Nothing; badSafeInit (x:xs) = case badSafeInit xs of Nothing -> Just []; Just ys -> Just (x:ys)
17:44:26 <lambdabot>  Defined.
17:44:32 <codehero> hm
17:44:34 <arkeet> > badSafeInit [1..]
17:44:35 <lambdabot>  *Exception: stack overflow
17:44:38 <codehero> oh
17:44:49 <arkeet> > badSafeInit [1..5]
17:44:50 <lambdabot>  Just [1,2,3,4]
17:44:53 <arkeet> works just fine on finite lists.
17:45:20 <slack1256> roboguy_: That's is part of what I was looking for. Thanks
17:45:47 <arkeet> > safeInit (1:2:3:undefined)
17:45:48 <lambdabot>  Just [1,2*Exception: Prelude.undefined
17:45:50 <codehero> in that case "safeInit (x:xs) = fmap (x:) (safeInit xs)" doesn't work on infinite lists either
17:45:51 <arkeet> > badSafeInit (1:2:3:undefined)
17:45:52 <lambdabot>  *Exception: Prelude.undefined
17:45:59 <arkeet> no, it works.
17:46:02 <roboguy_> slack1256: I didn't prove the laws, but I have a feeling they hold (maybe best to prove them anyway, ha). Also, I'm not totally sure where ArrowFix fits
17:46:12 <arkeet> I think.
17:46:15 <codehero> nope
17:46:18 <arkeet> you tried?
17:46:21 <roboguy_> I mean, ArrowLoop
17:46:22 <codehero> yeah
17:46:24 <arkeet> hm.
17:46:26 <codehero> doesn't print any numbers
17:46:35 <nitrix> Is it possible to have a language with the weak termination property while still allowing I/O for user inputs?
17:46:46 <arkeet> hm you're right.
17:47:19 <arkeet> basically the same reason I guess.
17:48:07 <nolrai66> @ty init
17:48:08 <lambdabot> [a] -> [a]
17:48:17 <nolrai66> > init [1,2,3]
17:48:19 <lambdabot>  [1,2]
17:48:54 <arkeet> because in order to evaluate safeInit (x:xs), it must know whether safeInit xs is Nothing or Just something, before fmap can do any work.
17:49:04 <arkeet> so again it has to traverse the entire list before producing anything.
17:49:17 <nolrai66> > init [3]
17:49:19 <lambdabot>  []
17:49:23 <nolrai66> > init []
17:49:25 <lambdabot>  *Exception: Prelude.init: empty list
17:49:28 <nolrai66> Hmm.
17:50:14 <arkeet> ah well.
17:51:59 <gratimax> what is it called when you pass in a function that has a more restrictive constraint into a higher-order function, and the constraint then applies to the entire expression?
17:52:08 <roboguy_> how about
17:52:25 <roboguy_> > let saferInit list = case list of [] -> Nothing; [_] -> Nothing; (x:xs) -> Just . maybe [x] (x:) $ saferInit xs in saferInit [1,2,3,undefined]
17:52:26 <lambdabot>  Just [1,2,3]
17:52:35 <kadoban> gratimax: I don't know that that actually has a name.
17:52:45 <slack1256> roboguy_: I read it. Now is clear, still Strong (from profuctors) was neccesary but is really nice.
17:52:50 <arkeet> roboguy_: that's not the same thing.
17:52:54 <gratimax> like if I have fnA :: Eq a => (a -> a) -> a and fnB :: Ord a => a -> a then fnA fnB :: Ord a => a
17:52:58 <roboguy_> arkeet: no?
17:53:06 <arkeet> I mean the thing you applied it to.
17:53:13 <roboguy_> oh, right
17:53:15 <roboguy_> oops
17:53:28 <slack1256> But I guess arrow syntax is really convenient to really ditch it :-)
17:53:37 <gratimax> kadoban: oh, that doesn't have a name? ok...
17:53:41 <gratimax> it seems rather counterintuitive
17:53:43 <roboguy_> slack1256: I wonder if RebindableSyntax applies to arrow syntax...
17:53:50 <gratimax> almost like contravariance if haskell had subtyping
17:53:52 <arkeet> roboguy_: aside from the [_] case it works though.
17:54:01 <roboguy_> slack1256: if it does, then you could probably just use the profunctor version
17:54:03 <nolrai66> It is contravariance.
17:54:05 <gratimax> like I thought fnA fnB wouldn't compile
17:54:10 <mniip> gratimax, that's just a consequence of unification
17:54:29 <arkeet> roboguy_: but the Nothing case of maybe will never occur.
17:54:45 <arkeet> you could have (x:xs) -> Just . maybe (unicorns) (x:) $ saferInit xs
17:54:48 <arkeet> and it would be all the same.
17:55:02 <roboguy_> arkeet: I don't think that's true
17:55:02 <gratimax> hmmm... ok thanks guys, I'll have to look into unification more
17:55:13 <gratimax> I'm used to languages where stuff like that would flat-out not compile
17:55:30 <arkeet> never mind.
17:56:00 <arkeet> roboguy_: anyway this thing strikes me as weird. :p
17:56:31 <roboguy_> ha, yeah I wasn't fully understanding when I first looked at what you were doing
17:57:00 <arkeet> I guess my point is that there's some redundancy between the last 2 cases.
17:57:17 <nolrai66> gratimax: what are fnA fnB?
17:57:28 <gratimax> " fnA :: Eq a => (a -> a) -> a and fnB :: Ord a => a -> a then fnA fnB :: Ord a => a"
17:57:36 <gratimax> it's a contrived example
17:57:45 <nolrai66> Ah.
17:57:54 <nolrai66> Yeah, that is contravariance.
17:58:04 <gratimax> I don't actually know of anything that has the signature (a -> a) -> a
17:58:27 <nolrai66> fix is the only one, without contexts.
17:58:50 <gratimax> oh yes, d'oh
17:59:04 <gratimax> II don't actually know of anything that has the signature Eq a => (a -> a) -> a
17:59:44 <nolrai66> No, that is a pretty weird signature.
18:00:15 <mniip> gratimax, fix
18:01:26 <mniip> does anyone have a recent enough GHC for a quick check
18:01:30 <gratimax> Where should I go for a more clarifying, rigorous view of unification?
18:02:43 <nolrai66> gratimax: what feels unclear?
18:02:51 <gratimax> fnA fnB
18:03:05 <gratimax> for me that feels like it should be a compile error
18:04:11 <kadoban> gratimax: That'd be … limiting.
18:04:42 <gratimax> in my mind, fnA is a function that takes a function that operates on Eq a. Giving it a function that operates on Ord a is giving it a function that is more specific, which it cannot possibly fulfill
18:05:58 <gratimax> this is contravariance in languages I'm more used to with subtyping, so it "feels right". I'm sure if I read something that fleshes out type unification more fully this particular consequence will make more sense
18:06:13 <exio4> gratimax: the caller gets to the pick the types
18:06:29 <funfunctor> @hoogle readMaybe
18:06:29 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
18:06:29 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
18:06:55 <exio4> funfunctor: Text.Read
18:07:02 <exio4> @type Text.Read.readMaybe
18:07:05 <funfunctor> exio4: ta!
18:07:05 <lambdabot> Read a => String -> Maybe a
18:08:09 <roboguy_> Why doesn't Kleisli have Monad, etc, instances? It is an instance of ArrowApply, which implies to me that it can
18:08:34 <arkeet> wrong kind.
18:08:51 <jle`> eds: your problem is that you don't really have a way to generate an Expr (Int -> Int -> Int) or an Expr Int -> Expr Int -> Expr Int yet
18:10:32 <roboguy_> arkeet: this doesn't have the wrong kind: instance Functor m => Functor (Kleisli m a)
18:11:12 <jle`> roboguy_: someone has suggested it and i think they were saying they'd put in a PR
18:11:22 <jle`> but i think the real reason is that if you're using the monad istance, you're probably using it wrong
18:11:24 <jle`> heh
18:11:32 <roboguy_> hm
18:11:51 <jle`> it's sort of an abuse of the type maybe.  but i guess that's not a *real* reason for not having an instance
18:11:55 <arkeet> well, Kleisli m a is basically the same as ReaderT a m
18:11:59 <jle`> unless it's to specifically discourage a certain usage pattern
18:12:01 <arkeet> but they have different purposes.
18:12:13 <jle`> sometimes people admit instances to discourage a usage pattern
18:12:19 <jle`> s/admit/ommit
18:12:21 <jle`> omit?
18:12:31 <arkeet> omit.
18:12:32 <jle`> omitt
18:12:40 <arkeet> oomit.
18:13:10 <arkeet> roboguy_: I agree that it ought to at least have Functor/Applicative instances though.
18:13:31 <arkeet> as any arrow ought to.
18:13:39 <jle`> i'm surprised it doesn't have an Applicative or Functor instance
18:14:07 <arkeet> fmap f x = arr f . x
18:14:14 <roboguy_> arkeet: I'm trying to see if my Arrow replacement thing would work with rebindable syntax (assuming rebindable syntax applies to arrow syntax)
18:14:14 <jle`> you can get one using a newtype wrapper
18:14:15 <arkeet> pure b = arr (const b)
18:14:21 <jle`> there's WrappedArrow in Control.Applicative
18:14:24 <jle`> but that's just kinda silly
18:14:26 <arkeet> (<*>) = exercise
18:15:05 <roboguy_> and I (think) I need Functor for that
18:16:26 <z3r0c00l> register zerocool
18:16:36 <jle`> there should be a Functor instance, i don't see any good reason why there shouldn't be
18:16:39 <jle`> oh well
18:16:48 <arkeet> jle`: as should any arrow.
18:16:53 <jle`> yeah
18:17:01 <jle`> as should.
18:17:18 <arkeet> :t uncurry id <<< (&&&)
18:17:19 <lambdabot>     Couldn't match type ‘a b c'0 -> a b (c1, c'0)’ with ‘(b0 -> c, b0)’
18:17:19 <lambdabot>     Expected type: a b c1 -> (b0 -> c, b0)
18:17:19 <lambdabot>       Actual type: a b c1 -> a b c'0 -> a b (c1, c'0)
18:17:29 <jle`> you prob want (^<<)
18:17:31 <arkeet> :t \f g -> uncurry id <<< f &&& g
18:17:32 <lambdabot> (a -> c' -> c) -> (a -> c') -> a -> c
18:17:40 <jle`> aka fmap
18:17:44 <arkeet> :t (^<<)
18:17:44 <jle`> if it's a Functor
18:17:45 <lambdabot> Arrow a => (c -> d) -> a b c -> a b d
18:18:00 <jle`> :t [fmap, (^<<)]
18:18:02 <lambdabot> (Functor (a1 b1), Arrow a1) => [(a -> b) -> a1 b1 a -> a1 b1 b]
18:18:03 <arkeet> :t \f x -> arr f . x
18:18:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:18:07 <arkeet> :t \f x -> arr f <<< x
18:18:08 <lambdabot> Arrow cat => (b -> c) -> cat a b -> cat a c
18:18:12 <slack1256> gratimax: is fnA fnB :: (Eq a) => a ?
18:18:22 <gratimax> no
18:18:27 <jle`> :t [fmap, (^<<), rmap]
18:18:28 <lambdabot> (Functor (a1 b1), Arrow a1, Profunctor a1) => [(a -> b) -> a1 b1 a -> a1 b1 b]
18:18:29 <gratimax> fnA fnB :: (Ord a) => a
18:18:40 <jle`> :t [fmap, (^<<), rmap, (.), (<<^)]
18:18:41 <roboguy_> I went the other way: arr f = fmap f id
18:18:41 <lambdabot> [(a -> b) -> (b1 -> a) -> b1 -> b]
18:18:48 <arkeet> roboguy_: yes.
18:19:07 <arkeet> and (&&&) = liftA2 (,)
18:19:39 <roboguy_> arkeet: I think that can be generalized (assuming I'm thinking of this class structure right)
18:20:53 <jle`> :t [fmap, (^<<), rmap, liftM, liftA, (<$>), (<<<), (.), (<<^), (Control.Category..)]
18:20:54 <lambdabot> [(a -> b) -> (b1 -> a) -> b1 -> b]
18:21:00 <roboguy_> Well maybe, hmm. Where first and second are from profunctors: f &&& g = first f . second g . arr (join (,))
18:21:20 <roboguy_> actually, that's probably less general
18:22:17 <funfunctor> @hoogle (a, a) -> a a
18:22:17 <lambdabot> Test.QuickCheck.Gen choose :: Random a => (a, a) -> Gen a
18:22:17 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
18:22:17 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
18:22:29 <funfunctor> @hoogle (a, a) -> a -> a
18:22:30 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
18:22:30 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
18:22:30 <lambdabot> Text.Regex.Base.RegexLike extract :: Extract source => (Int, Int) -> source -> source
18:24:07 <slack1256> gratimax: oh, I was wrong, is class (Eq a) => Ord a the declaration, not backwards. Now is clear
18:25:02 <roboguy_> funfunctor: what're you looking for?
18:25:12 <funfunctor> perhaps uncurry?
18:25:32 <roboguy_> the type you gave has only three possible implementations, and all of them ignore two of the values given to it
18:25:34 <jle`> funfunctor: what do you want the function to do?
18:25:46 <funfunctor> roboguy_: looking to wrap Foo Double Double from a (Double, Double)
18:25:48 <jle`> :t \(x, y) z -> x
18:25:49 <lambdabot> (t, t1) -> r -> t
18:26:21 <jle`> funfunctor: you want (a -> b -> c) -> (a, b) -> c
18:26:27 <funfunctor> I think uncurry would be equiv to Foo (fst x) (snd x) right?
18:26:30 <jle`> or (Double -> Double -> Foo) -> (Double, Double) -> Foo
18:26:38 <funfunctor> @hoogle uncurry
18:26:38 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
18:26:38 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
18:26:40 <jle`> :t uncurry
18:26:41 <roboguy_> yeah, uncurry would be the one
18:26:41 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:26:58 <jle`> funfunctor: you want to turn a (Double -> Double -> Foo) into a (Double, Double) -> Foo
18:26:59 <jle`> so, uncurry :)
18:27:09 <roboguy_> interesting that hoogle kept those parentheses in the types...
18:28:10 <pacak> I have two functions - one generated with generics one - written by hands. They both  doing basically the same thing - case foo of Foo a b c -> a <> b <> c, but in manual case it's inserted as is directly and in generics - it's doing something like case foo of Foo a b c -> blah a b c where blah a b c = a <> b <> c. Any ideas why is it doing that in case of generics and how to convince ghc to use first approach in generics as well?
18:28:53 <funfunctor> thx guys, just making sure..
18:29:06 <benzrf> pacak: generics most likely has some kind of general form for that sort of thing
18:29:13 <benzrf> and id imagine that ghc will inline that
18:29:18 <benzrf> it's a fairly obvious change
18:29:36 <pacak> benzrf: It's already inlined - except for that one extra function.
18:37:37 <lamefun> Why do I have to indent so much in let?
18:38:00 <pacak> lamefun: To make code nice and readable?
18:39:01 <lamefun> How does it make code more readable?
18:39:03 <roboguy_> lamefun: is this another very minor, yet very long Haskell nitpick discussion?
18:40:27 <lamefun> Are there some fundamental reasons why can't let tolerate less indentation when only a single constant is defined?
18:40:43 <slack1256> > let {a = 3; b = 5;} in a + b
18:40:44 <lambdabot>  8
18:41:04 <slack1256> I think curly braces relax it a little bit
18:42:31 <Cale> lamefun: The first non-whitespace character after 'let' is what sets the indentation level.
18:43:07 <Cale> lamefun: In order to continue the block, things have to line up with that character
18:43:10 <orion> Anyone know how to get this code to compile?: http://lpaste.net/382913295264251904 The error occurs on line 35: No instance for (ToJSON a0) arising from a use of ‘.=’ The type variable ‘a0’ is ambiguous
18:43:26 <orion> Since I am using an existentially qualified type, I am not sure how to proceed.
18:43:31 <jle`> lamefun: can you give an example of what sort of indentation you're talking about?
18:43:32 <Cale> things which start in a shallower column will end the block, and things which start in a deeper column will continue the previous line
18:44:12 <roboguy_> lamefun: here is one demonstration of let indentation rules http://stackoverflow.com/questions/24900587/let-indentation-inside-proc-notation/24900659#24900659
18:45:07 <roboguy_> (full disclosure: that's my answer)
18:46:14 <lamefun> jle`: http://lpaste.net/1495491158447489024
18:46:35 <jle`> ah, in a do block?
18:47:03 <jle`> a let block in do can have more than one declaration
18:47:28 <jle`> so if you want a do block in a let bock the next line has to be clear that it's not another declaration, and is in fact a command
18:47:33 <arkeet> lamefun: The first non-whitespace character after 'let' is what sets the indentation level.
18:47:36 <jle`> er, a do block
18:47:39 <jle`> line
18:47:40 <arkeet> in particular, that's the 'f' in func
18:47:49 <arkeet> everything inside the let block must be indented at least as far.
18:48:19 <arkeet> what you have parses as
18:48:27 <arkeet> well I don't know what it parses as.
18:48:39 <arkeet> besides nothing.
18:48:59 <arkeet> but it looks like "let { func x y = do } print x print y"
18:49:26 <arkeet> maybe.
18:49:59 <arkeet> because print x and print y are outside of the let block, but still considered to be part of the same statement in the outer do block.
18:50:06 <arkeet> but that makes no sense, hence the error.
18:50:30 <arkeet> so lines 3 and 4 must be indented at least 3 spaces further.
18:50:41 <lamefun> Cale: I know the rules, but what prevents Haskell from eg. seeing if a block declares a sub-block with lower indentation than itself but greater indentation than its parent block and handle that?
18:51:23 <Cale> lamefun: huh?
18:51:26 <Cale> lamefun: Example?
18:51:51 <Cale> lamefun: In fact, the rules regarding indentation are way too loose in my opinion. I wish they were a little stricter in places.
18:51:53 <geekosaur> I presume the preceding paste is the example
18:52:01 <Cale> oh, I missed that
18:52:05 <lamefun> do declares a block of its own, right?
18:52:09 <Cale> yes
18:52:43 <lamefun> Stricter how, for example?
18:52:46 <Cale> and since the first non-whitespace character on line 3 is shallower than the first non-whitespace character following the 'let', the 'let' block closes
18:53:01 <jle`> i think the way it is leads to less visual ambiguity
18:53:14 <jle`> if you're suggesting that an opening do "overrides all other indentation/layouting", things would get pretty confusing
18:53:24 <jle`> let foo = do
18:53:26 <jle`>     print 1
18:53:54 <jle`> if an opening do overrode all other layouting rules, then it's not super clear if the print 1 is another declaration in the let block or the next line in the do block
18:54:03 <geekosaur> lamefun, for one thing, it's on you to prove that your suggestion never introduces ambiguity. haskell2010 changed the rules because an ambiguity was found in haskell98's layout rules, for example
18:55:06 <Cale> Even if it never introduces ambiguity, I would prefer that the rules prevent stupid-looking things which are hard to read :)
18:55:21 <mniip> anyone here specializing in TH?
18:55:25 <lamefun> jle`: yes, that would break down with 4 space indentation.
18:55:47 <jle`> even with 2 space indentation it's not really clear
18:55:57 <lamefun> Cale: how are the current rules too loose?
18:56:05 <mniip> is this the way it should be done, or is it the opposite of what should be done http://lpaste.net/1218726919046955008
18:56:15 <jle`> are you trying to state something in the overall do block, or have another declaration in the let block, or be another statement in the newly opened do block?
18:56:19 <Cale> Well, Haskell2010 did this foolish thing with do and if/then/else
18:56:33 <Cale> allowing people to get away with not indenting properly
18:56:45 <Cale> Beginners will sometimes write things like
18:56:51 <Cale> do foo
18:56:57 <Cale>    if bar then
18:56:58 <lamefun> for example?
18:57:04 <Cale>      baz
18:57:07 <Cale>    else quux
18:57:17 <Cale> which is now legal in H2010
18:57:25 <arkeet> that's weird.
18:57:30 <Cale> because you're allowed to have a spurious ; in the middle of an if/then/else
18:57:33 * bitemyapp squints
18:57:38 <lamefun> oh, I didn't know that was allowed
18:57:42 <bitemyapp> I didn't either.
18:57:48 <arkeet> > do { if True then 1; else 2 }
18:57:49 <lambdabot>  1
18:57:49 <Cale> But it really shouldn't be legal imo
18:57:56 <bitemyapp> I actually just changed code that was like this preemptively without even checking to see if it compiled.
18:58:14 <Cale> and I think we should make it stricter: if the 'then' and 'else' occur on separate lines, they should have to start in the same column
18:58:32 <bitemyapp> I guess chucking stuff into the grammar is easier than formalizing an extension :P
18:58:34 <arkeet> I think that's too strict.
18:58:46 <arkeet> why should if/then/else have anything to do with layout.
18:58:51 <athan> Cale: seconded
18:58:58 <bitemyapp> I'm with arkeet.
18:59:01 <Cale> arkeet: Just to prevent things which are obnoxious to read
18:59:08 <arkeet> why can't I write
18:59:14 <arkeet> if bar then baz
18:59:16 <arkeet>   else quux
18:59:22 <arkeet> if baz is really long or something.
18:59:26 <athan> actually I may bite my tongue - I think `then` and `else` should follow the rules of `let`
18:59:27 <Cale> Well, you can, but I don't care for it :)
18:59:28 <bitemyapp> arkeet: why can't Johnny read?
18:59:49 <arkeet> or worse, if bar and quux were really long
18:59:51 <arkeet> and baz wasn't.
19:00:06 <Cale> It's nice to have the branches line up so that the logic is easy to follow
19:00:11 <teurastaja> whats the channel for #not-haskell?
19:00:21 <roboguy_> teurastaja: #nothaskell
19:00:25 <jle`> is there a typical type variable people use for a type that doesn't matter/is ignored in the function if a b s t are taken
19:00:27 <Cale> If you were writing a case expression, then the pattern matches on True and False would have to line up :)
19:00:43 <teurastaja> haha you guys should put it in the topic
19:00:53 <jle`> teurastaja: there's #nothaskell which is haskell discussion but not the #haskell channel, and there's #haskell-blah for off-topic discussion that isn't related to haskell
19:01:01 <Cale> teurastaja: No, it's #haskell-blah
19:01:07 <Cale> roboguy_: what?
19:01:12 <Cale> Does that channel exist?
19:01:16 <roboguy_> Cale: wait... which not haskell?
19:01:17 <roboguy_> yeah
19:01:23 <arkeet> if it doesn't, it will whenever someone joins it.
19:01:25 <jle`> yeah it's existed for quite a while now heh
19:01:35 <Cale> :(
19:01:36 <jle`> it's not supposed to be "not haskell", it's supposed to be "not #haskell"
19:01:39 <roboguy_> it depends on what you mean by the "not haskell" channel I guess
19:01:47 <teurastaja> so which one is right?
19:01:48 <arkeet> surely they could have called it #not-#haskell
19:01:53 <teurastaja> are they alike?
19:01:54 <jle`> they could have, but they did not
19:01:57 <arkeet> :(
19:02:02 <roboguy_> teurastaja: well, what are you looking for?
19:02:03 <jle`> teurastaja: #haskell-blah is off-topic discussion for this channel's community
19:02:04 <Cale> Why not #haskell-blah?
19:02:18 <jle`> teurastaja: #nothaskell is another channel for discussing haskell that is a separate community than this one
19:02:21 <roboguy_> Cale: #nothaskell is still mostly focused on haskell discussion
19:02:23 <Cale> oh, what?
19:02:25 <arkeet> because haskell is off topic in #haskell-blah.
19:02:29 <bitemyapp> Cale: started by someone angry that a conversation on the mailing list didn't go well.
19:02:33 <Cale> lol, okay
19:02:42 <Cale> That's bizarre
19:02:44 <bitemyapp> Cale: FSR, this was translated to leaving the IRC channel as well. There's quite a few people in the channel now.
19:02:48 <teurastaja> aha now i get it
19:02:56 <jle`> yeah it's a splinter haskell community on freenode
19:02:59 <Cale> (and annoying)
19:03:23 <bitemyapp> Cale: I'm not in any place to judge, people have grumbled at me about my having started #haskell-beginners.
19:03:26 <Cale> I don't want to have to keep tabs on yet another Haskell channel
19:03:30 <bitemyapp> even though I articulated the reasons for it.
19:03:44 <Cale> bitemyapp: I don't mind that channel, I only strongly disagree with its choice of name
19:04:02 <roboguy_> I personally think it's a bit divisive to have it setup like that, but the people have always been really nice in my experience
19:04:03 <bitemyapp> the name does seem a bit of a misfit now, but it's still focused on helping people learn/teach.
19:04:05 <orion> bitemyapp: Hi. Are you the creator of bloodhound?
19:04:25 <Cale> The problem is that people who see that in a channel list might think that #haskell is *not* for beginner discussion, by contrast.
19:04:29 <bitemyapp> orion: Apologies, yes.
19:04:42 <Cale> Which I think is very unfortunate when it occurs
19:04:46 <bitemyapp> Cale: I considered that but decided not to fuss over the name too much.
19:05:06 <bitemyapp> #haskell-learning-only-kthxbai requires too much typing :P
19:05:26 <orion> bitemyapp: I am attempting to implement a "createTemplate" API call, and this is how I am doing it: http://lpaste.net/382913295264251904 -- However, GHC craps out on line 35, Am I going about this the wrong way>?
19:05:26 <Cale> #haskell-cis194 might have been good
19:05:29 <roboguy_> actually, #haskell-learning or #learning-haskell...
19:05:33 <bitemyapp> #haskell-be-nice-no-interrupting-seriously also too long.
19:05:39 <bitemyapp> Cale: it's not just cis194 and cis194 has its own channel.
19:05:55 <Cale> #haskell-study-group
19:06:24 <bitemyapp> Getting warmer
19:07:56 <orion> bitemyapp: I'm trying to do this pursuant to https://github.com/bitemyapp/bloodhound/issues/47
19:10:09 <bitemyapp> orion: GHC error?
19:11:50 <sccrstud92> can the linear package be used to solve linear systems?
19:12:59 <arkeet> not really.
19:13:25 <peddie> sccrstud92: only in special cases
19:13:37 <orion> bitemyapp: Line 35: No instance for (ToJSON a0) arising from a use of ‘.=’ The type variable ‘a0’ is ambiguous
19:13:41 <jle`> yeah, it's not really meant to solve things
19:13:44 <orion> In the expression: "mappings" .= m
19:13:46 <sccrstud92> peddie: how special?
19:13:56 <jle`> kind of like in the way a Num instance isn't meant to solve systems of equations involving (+) and (*)
19:14:06 <jle`> and (/)
19:14:31 <peddie> sccrstud92: what's your case?  you can do it if it's square, numerically well-conditioned and not larger than 4x4
19:14:33 <arkeet> the closest it has is inverting matrices up to 4x4.
19:14:33 <roboguy_> sccrstud92: there are quite a lot of different kinds of linear systems
19:14:36 <sccrstud92> jle`: is there a package that is used to solve linear systems set up with stuff from linear?
19:14:37 <jle`> linear basically provides the (*), (+), (/), etc. analogies
19:14:42 <arkeet> but it's not really efficient for that.
19:14:53 <arkeet> jle`: what's the analogue of (/)?
19:15:02 <funfunctor> Use accelerate
19:15:07 <bitemyapp> orion: well I don't think it's specific to Bloodhound
19:15:09 <Axman6> orion: what type is m?
19:15:17 <jle`> i meant an analogy for those set of operations, not an analogy for each operation heh
19:15:17 <peddie> sccrstud92: if you want something fairly generic, use linearSolveSVD from Numeric.LinearAlgebra.HMatrix
19:15:34 <peddie> sccrstud92: but it won't work out of the box with Linear types
19:15:50 <funfunctor> GPU's are good at matrix arithmetic of type primitive
19:15:55 <sccrstud92> alright
19:16:05 <sccrstud92> so linear is basically a prelude for linear algebra?
19:16:17 <sccrstud92> s/prelude/base
19:16:44 <peddie> sccrstud92: as far as I can tell, it really focuses on providing principled operations for things you encounter incomputer graphics
19:16:46 <jle`> yeah, it defines things like matrix multiplication, vector addition, scalar multiplaction, vector-matrix multiplication, identity matrices, quaternion manipulation
19:16:55 <jle`> but not actually solving anything
19:17:07 <peddie> not linear algebra in general
19:17:38 <sccrstud92> alright
19:17:46 <roboguy_> sccrstud92: is it just a dense matrix? Or does it have a special structure like tridiagonal or anything like that?
19:18:07 <jle`> kind of like how the Num typeclass provides (+) and (*) but doesn't provide a way to solve, say, x*3+4 = 5.  you have to do it yourself
19:18:12 <funfunctor> you are probably looking to do gaussian elimination
19:18:25 <sccrstud92> roboguy_: no not really
19:19:10 <roboguy_> sccrstud92: that's a shame. you might need to use gaussian elimination then, which is O(n^3) compared to, say, a tridiagonal solver's O(n). If it's a small matrix that likely wouldn't be too bad though
19:19:38 <funfunctor> roboguy_: but that is not so bad with a GPU
19:20:00 <orion> Axman6: http://lpaste.net/382913295264251904
19:20:28 <peddie> sccrstud92: just use linearSolve or linearSolveSVD unless your problem is huge or this solve is super performance-critical
19:21:29 <roboguy_> funfunctor: I thought I remembered G.E. not parallelizing well, but I could be mistaken on that
19:21:33 <sccrstud92> got it
19:22:31 <orion> Axman6: forall a. ToJSON a => [a]
19:24:37 <peddie> sccrstud92: if you want numerical linear algebra advice about special kinds or scales of problem, that's a whole big rabbit hole that it sounds like lots of people, me included, would be happy to help you navigate ;)  but don't go down it unless you really care!
19:29:36 <orion> bitemyapp: DO you think I'
19:29:59 <orion> bitemyapp: Do you think I'm approaching this problem properly?
19:32:46 <bitemyapp> I'm inapt to make a value judgment here when I don't totally know where you're going with it
19:32:56 <bitemyapp> but I will say that the forall is probably gratuitous.
19:33:40 <bitemyapp> Existential packing of typeclasses with a single method that produces a single type are usually unnecessary/nonsensical since you can just apply the method ahead-of-time.
19:34:14 <bitemyapp> You're not really losing type information in the process since all you know about:   exists a . ToJSON a => a    is that you can convert it to a Value.
19:34:37 <bitemyapp> so since that's the only bit of information you've got, why not skip the middleman and go straight to the "you have a list of Values" part?
19:35:00 <bitemyapp> it would be different if you were using more typeclasses or bigger algebras where they're not all converging on the same thing necessarily or in the same way.
19:36:47 <orion> bitemyapp: If I use a [Value] instead, then when someone wants to create a template they'll have to write IndexTemplate "mypattern* (IndexSettings ...) [encode TwitterMapping, encode FooMapping]
19:37:11 <orion> Ideally, I'd want the user to be able to write IndexTemplate "mypattern* (IndexSettings ...) [TwitterMapping, FooMapping]
19:37:57 <bitemyapp> what I just said is about the most explicit explanation I've seen or given regarding existential encodings of things like this.
19:38:06 <bitemyapp> and why it doesn't make sense. I think Done wrote something about it not long ago.
19:38:45 <orion> bitemyapp: Honestly, I didn't understand your explanation fully due to my lack of knowledge/experience.
19:38:59 <bitemyapp> orion: you don't have to know too much, but I can try to pare it down a bit.
19:39:27 <bitemyapp> orion: the point is that the *only* thing you know about   forall a . ToJSON a => a    is that they can be converted into a Value.
19:39:56 <bitemyapp> orion: if that's the only thing you can possibly do or know about it, why not skip the bit that'll confuse people?
19:40:43 <bitemyapp> I'm not saying it's impossible such an encoding could be useful, but avoiding apply toJSON/encode to values isn't that compelling to my mind. I could be convinced otherwise if there's a good example.
19:41:51 <orion> The only reason I am doing it this way is because I think that being able to write: IndexTemplate "mypattern* (IndexSettings ...) [TwitterMapping, FooMapping] *seems* elegant to me.
19:42:33 <bitemyapp> orion: that's not going to work
19:42:46 <bitemyapp> orion: you still have to pack them into the existentially encoded data constructor
19:43:04 <bitemyapp> orion: you're still going to have to apply something to the values. It's just a question of whether you're engaging in the indirection or not.
19:43:24 <bitemyapp> orion: and you've made the code slower to boot because it has to bolt the vtable onto the objects.
19:43:34 <bitemyapp> (not that speed likely matters here, but worth mentioning)
19:44:06 <bitemyapp> orion: I'm not trying to put you down or dampen your desire to add stuff to Bloodhound, I just don't know if there's something I might be missing here WRT your   forall a . ToJSON a => a
19:44:45 <orion> bitemyapp: I don't mind your critique, I am still very much a beginner.
19:44:54 <bitemyapp> orion: do you see my point now?
19:45:06 <bitemyapp> you'd be writing the same amount of code.
19:45:37 <orion> Sort of. What does "existentially encoded data constructor" and "pack" mean, as you've used them?
19:46:19 <bitemyapp> so IndexTemplate is a product right?
19:46:31 <bitemyapp> it has a type constructor and a data constructor by the same name.
19:46:45 <bitemyapp> The data constructor is the term-level/value-level constructor you use in the code that "runs" so to speak
19:46:52 <bitemyapp> you use the type constructor in your type signatures.
19:47:08 <bitemyapp> your "forall a" in the type of templateMappings is an existential encoding
19:47:16 <bitemyapp> it's like saying, "there exists an a which has a ToJSON instance"
19:47:20 <bitemyapp> but that mostly doesn't matter
19:47:33 <orion> Right, I follow so far.
19:47:42 <bitemyapp> the point is that your forall is there to allow objects of varying type which have something in common to be in the same list.
19:47:56 <bitemyapp> however, the "something in common" is all one typeclass method which converges on one type.
19:48:27 <orion> That one type being Value?
19:48:31 <bitemyapp> Yes
19:48:34 <bitemyapp> you don't want encode, probably toJSON instead, but there's really no reason to bother with that representation since it's just acting as an intermediary for Value.
19:48:41 <bitemyapp> the canonical example here is Show.
19:49:11 <bitemyapp> http://chrisdone.com/posts/existentials
19:50:37 <orion> bitemyapp: In your README you have a type called TweetMapping. Elasticsearch index templates allow multiple mappings to be specified. I want to capture that logic.
19:51:22 <bitemyapp> orion: that's not part of the library though.
19:51:27 <orion> Let's say I want my index template to contain a mapping for Tweets and Foos. They're different types, but I want a way to have my "IndexTemplate" type hold both of them.
19:51:33 <bitemyapp> orion: the library has basically nothing to say about mappings.
19:52:03 <bitemyapp> in fact I was considering dropping the `ToJSON a => a` representation in lieu of Value.
19:52:22 <bitemyapp> but left it in to avoid unnecessary breakage and because I think it's more common in Haskell libraries.
19:53:06 <bitemyapp> I'm open to suggestions, I just don't think it's buying you a lot.
19:53:18 <bitemyapp> orion: another consideration here is that this `forall` is blocking your work
19:53:31 <bitemyapp> orion: I'm suggesting simplifying it in part so you can get on with figuring out how to make the thing you want work.
19:53:37 <bitemyapp> orion: focus on refinement last, ya know? :)
19:53:47 <orion> bitemyapp: Sure.
19:54:16 <orion> How do you think I could best capture the idea that an IndexTemplate can hold 0 or more mappings?
19:55:07 <bitemyapp> orion: genuinely - [Value]
19:55:15 <redcoat> Beat me to it.
19:55:34 <bitemyapp> redcoat: well. that time. I said it earlier too :P
19:55:42 <redcoat> It would actually be [(Property, Value)]
19:55:57 <bitemyapp> what's Property?
19:56:20 <bitemyapp> oh the name of the mapping?
19:56:38 <redcoat> I dunno. If a mapping is f:: a -> b, then a is what is being mapped
19:56:54 <redcoat> bitemyapp: I read nothing above the question
19:57:02 <bitemyapp> redcoat: mapping is a Value.
19:57:17 <redcoat> Hold on, let me read everything
19:57:21 <bitemyapp> it's a schema overlaid JSON documents for a search engine.
19:57:26 <redcoat> Okay
19:57:36 <redcoat> A Value is a sum type then
19:58:15 <orion> bitemyapp: So, if I want to create an IndexTemplate and I represent the mappings as [Value], I have to do IndexTemplate "mypattern* (IndexSettings ...) [encode TwitterMapping, encode FooMapping] -- correct?
19:58:51 <orion> (Forgot a close quote)
19:58:53 <lf94> How is pattern matching and ADT implemented?
19:58:58 <lf94> Are they really complex internally?
19:59:16 <lf94> (Because isn't pattern matching sort of reflexive?)
19:59:26 <ImGone> I have a string say ("C:/Users/blah/blahblah/" ++ position ++ ".bmp") and position is of type Int, shouldn't the compiler take the position value and add it into the string?
19:59:31 <bitemyapp> orion: toJSON, otherwise yes.
19:59:55 <orion> bitemyapp: Does that "feel" like a clean API? Something you'd want to expose to users?
20:00:40 <dustmote> does casava (Data.Csv) support decoding of quoted CSV files? .. i see in its docs that it seems to support *encoding* with quoting options, but there's nothing about decoding
20:01:09 <roboguy_> I've actually been working on a package to make it easier to do some manipulations of existential-based heterogenous lists
20:03:11 <bitemyapp> orion: it's not ideal, but neither is anything else in Bloodhound.
20:03:22 <bitemyapp> orion: don't get hung up on API refinement until you have something that works.
20:03:32 <bitemyapp> orion: we can kick around the design when it works and there are a couple tests.
20:04:01 <orion> Ok.
20:04:16 <bitemyapp> just uh, worry less :)
20:04:45 <roboguy_> I'm not sure if it would be super useful, but it might be nice for some use cases. It lets you write stuff like "test :: ConstrList Show; test = 1 :> 'a' :> () :> CNil" and then do things like map over it
20:05:53 <roboguy_> one thing that is weird to me is that I can implement constrMapM just fine, but I can't get constrMapM_ to typecheck...
20:06:06 <roboguy_> a bit confusing to me
20:06:47 <bitemyapp> roboguy_: check HList and see if _ version exists?
20:07:44 <roboguy_> bitemyapp: HList is different. It's more like a tuple. This is dynamically sized and the types don't need to be specified at compile time
20:07:50 <roboguy_> I mean, HList is more like a tuple
20:08:28 <roboguy_> data ConstrList c = forall a. c a => a :> ConstrList c | CNil
20:08:29 <bitemyapp> roboguy_: ah fair enough.
20:08:57 <orion> bitemyapp: Out of curiosity, what protocol version are you intending to target?
20:08:59 <bitemyapp> you really can't get mapM_ to check for that?
20:09:04 <orion> Of Elasticsearch.
20:09:06 <roboguy_> it's really weird because even if I just leave the definition as "constrMapM_ = undefined", ghc doesn't like the type signature itself 
20:09:07 <bitemyapp> orion: whatever's in travis.yml
20:09:17 <bitemyapp> roboguy_: dafuq
20:09:27 <roboguy_> bitemyapp: I know, right! Let me find it...
20:10:21 <bitemyapp> roboguy_: yeah can you post your whole buffer to lpaste for this?
20:10:26 <bitemyapp> I'd love to poke at it with a stick.
20:10:32 <roboguy_> bitemyapp: sure!
20:10:42 <codehero> okay. bitemyapp is an emacs guy
20:10:47 <codehero> or girl
20:11:05 <bitemyapp> codehero: https://github.com/bitemyapp/dotfiles
20:11:11 <bitemyapp> I think they're called buffers in vim too.
20:11:18 <codehero> reeally?
20:11:21 <codehero> huh
20:11:22 <bitemyapp> Pretty sure.
20:11:24 <joneshf-laptop> Are there any libs for w3c push api?
20:11:25 <codehero> didn't know that
20:11:31 <joneshf-laptop> kind of hard to find on hackage
20:11:33 <codehero> i thought buffer was a very emacs specific name
20:11:47 <bitemyapp> TIL w3c was working on a push API
20:11:52 <joneshf-laptop> :)
20:11:59 <joneshf-laptop> http://www.w3.org/TR/push-api/
20:12:04 <codehero> at least in the manual, one of the first things i saw was something like "they're called buffers, not windows"
20:12:16 <codehero> bitemyapp: oh. nixos. nice
20:12:24 <bitemyapp> codehero: I don't use NixOS anymore.
20:12:28 <codehero> me neither :D
20:12:32 <codehero> security is a mess
20:12:35 <bitemyapp> joneshf-laptop: diff between this and websockets?
20:12:38 <redcoat> orion: I'm confused.
20:12:49 <codehero> we can be ex-nixos buddies
20:13:00 <redcoat> I'm not familiar with bloodhoud. I'm not going to lookup its api.
20:13:11 <bitemyapp> redcoat: I love you too
20:13:30 <bitemyapp> codehero: good. I need the emotional support for not being Hackerly Enough to put up with a broken Linux distro.
20:14:12 <redcoat> orion: But if you're writing [encode TwitterWhatever, encode Foo], doesn't that mean both Foo and TwitterWhatever have encode defined on them?
20:14:14 <codehero> heh. it is pretty broken at the moment.
20:14:23 <orion> redcoat: Correct.
20:14:41 <redcoat> orion: So why can't you just write map encode [TwitterWhatever, Foo]
20:14:49 <bitemyapp> redcoat: diff types.
20:14:56 <redcoat> existentially quantify them
20:15:03 <bitemyapp> okay we've come full circle now.
20:15:07 <roboguy_> bitemyapp: here's a minimal version: http://lpaste.net/136764
20:15:15 <rowanblush> Deja vu...
20:15:18 <bitemyapp> orion: figure out the existential encoding later, we'll consider both options.
20:15:20 <redcoat> Okay well what's the problem with a forall, again? ._.
20:15:35 <roboguy_> bitemyapp: if you comment out the mapM_ stuff, it compiles and works fine
20:15:52 <bitemyapp> redcoat: not strictly necessary. I try to avoid ornament that isn't buying me type-safety.
20:15:58 <roboguy_> I think GHC doesn't like that b isn't used outside of that one parenthesized part
20:16:09 <bitemyapp> roboguy_: danke
20:16:26 <redcoat> bitemyapp: I meant with his code
20:16:34 <joneshf-laptop> bitemyapp, I'm not entirely sure. That's mostly why I was asking.
20:16:41 <roboguy_> bitemyapp: sure. I would definitely appreciate any insights that you would like to share!
20:16:52 <bitemyapp> roboguy_: doubt I'll have any, but I'll enjoy seeing it blow up.
20:17:01 <joneshf-laptop> bitemyapp, hoping somene had already looked into it and whittled the api down to reasonable terms
20:17:12 <roboguy_> it is interesting
20:17:40 <wyager> I need some optimization help. I've uncovered a case where a function being inlined makes my program 22x slower. The behavior is highly repeatable. More precise description at https://github.com/wyager/HNet/blob/master/Operations.hs
20:17:56 <bitemyapp> roboguy_: compiles for me.
20:18:00 <bitemyapp> roboguy_: check your ~/.ghci
20:18:07 <roboguy_> bitemyapp: what! really?
20:18:09 <roboguy_> let's see
20:18:54 <bitemyapp> wyager: I take it you already know about NOINLINE, you want to know why it's slow?
20:18:57 <roboguy_> bitemyapp: still no good. Are you on 7.10?
20:19:05 <roboguy_> I'm on 7.10.1
20:19:08 <bitemyapp> roboguy_: 7.8.4
20:19:13 <wyager> bitemyapp: Correct. Actually, just exporting the function causes it to be INLINABLE, so it's fine
20:19:24 <bitemyapp> wyager: if nobody here pipes up, you might try #numerical-haskell as well.
20:19:26 <wyager> I'm just curious why it performs so atrociously when inlined
20:19:28 <wyager> cool, thanks
20:20:03 <lispy> wyager: Just based on the operations, I'd say something with fusion is going on
20:20:22 <bitemyapp> roboguy_: cutting over to GHC 7.10.1
20:20:23 <lispy> wyager: the next step in diagnosing this is to look at the core in both cases
20:20:30 <wyager> lispy: From looking at core output, I couldn't figure out what the significant difference was
20:20:30 <roboguy_> I think it's some kind of 7.10 thing. I added the error I get: http://lpaste.net/136764
20:20:44 <wyager> They seemed to be roughly equivalent
20:20:47 <bitemyapp> roboguy_: oh yeah that made it mad.
20:21:07 <roboguy_> bitemyapp: I almost wonder if it's a ghc bug, but I don't feel like I understand the new ambiguity check to say that with any kind of certainty
20:21:13 <bitemyapp> {-# LANGUAGE AllowAmbiguousTypes #-} fixed it.
20:21:20 <bitemyapp> FSVO "fixed"
20:21:28 <lispy> wyager: did the slow down still happen with profiling on? Could you use that to "see" where the slow down happens? gc maybe?
20:21:30 <ImGone> How do you take an int and make it a char?
20:21:54 <wyager> lispy: IIRC, it wasn't very revealing
20:21:59 <bitemyapp> roboguy_: https://mail.haskell.org/pipermail/glasgow-haskell-users/2015-June/025926.html
20:22:00 <mniip> ImGone, there are multiple ways to turn an int into a char, which one do yuo want
20:22:08 <wyager> (•) just took a ton of time all of a sudden
20:22:12 <wyager> No clear reason why
20:22:22 <lispy> > toEnum 96 :: Char
20:22:24 <lambdabot>  '`'
20:22:40 <roboguy_> bitemyapp: that looks more like it's related to the type family injectivity thing
20:22:42 <lispy> ImGone: ^^
20:22:50 <mniip> > chr 65
20:22:51 <lambdabot>  'A'
20:22:54 <mniip> > digitToInt 3
20:22:56 <lambdabot>      No instance for (Num Char) arising from the literal ‘3’
20:22:56 <lambdabot>      In the first argument of ‘digitToInt’, namely ‘3’
20:22:56 <lambdabot>      In the expression: digitToInt 3
20:22:57 <bitemyapp> roboguy_: it does, but it was the only thing I could find at all about ambiguity.
20:23:03 <mniip> > intToDigit 3 -- oops
20:23:04 <lambdabot>  '3'
20:23:04 <roboguy_> hmmmm
20:23:24 <arkeet> > map intToDigit [0..]
20:23:26 <lambdabot>  "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
20:23:47 <bitemyapp> roboguy_: relevant docs I think: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#ambiguity
20:24:06 <roboguy_> bitemyapp: if I add the real definition, it rejects it even with AllowAmbiguousTypes
20:24:15 <bitemyapp> ah well, toss me that one too.
20:24:23 <bitemyapp> roboguy_: may want to turn these into GHC Trac tickets.
20:24:40 * hackagebot ib-api 0.1.0.0 - An API for the Interactive Brokers Trading Workstation written in pure Haskell  http://hackage.haskell.org/package/ib-api-0.1.0.0 (rbermani)
20:24:42 <lispy> wyager: if you use the local "where" version of (•) but add a type signature to it, does it still slow down?
20:24:49 <wyager> lispy: Let me check
20:24:57 <roboguy_> bitemyapp: I'll do that tomorrow. My coworker has experience with GHC Trac so I'll ask him about that
20:25:21 <wyager> lispy: yes
20:25:32 <bitemyapp> roboguy_: yeah sure, not trying to give you marching orders. Just want it to reach the GHC team.
20:25:52 <bitemyapp> roboguy_: I'll ping you next week to see what became of it and toss it over their fence if you didn't find time.
20:25:55 <lispy> wyager: okay. I think I'd have to study the difference in core so that I can see the operational difference.s
20:25:59 <roboguy_> bitemyapp: oh no problem at all. I added the definition that I think would be correct: http://lpaste.net/136764
20:26:02 <bitemyapp> going to chuckle if this forces a GHC 7.10.3 :)
20:27:13 <roboguy_> bitemyapp: haha, yeah. That would easily be the most influence I've ever had on ghc if it does, ha
20:28:00 <roboguy_> I think I'll see what the people over in #ghc think of it tonight and then see about submitting a Trac ticket tomorrow
20:28:16 <bitemyapp> roboguy_: coolio :)
20:31:19 <dustmote> i answered my question from above: (can cassava decode csv files with quotes?) answer: Yes! It does so automatically. So what was my problem? It cannot handle spaces after the commas! eg. "Foo", "Bar"\n
20:31:41 <bitemyapp> dustmote: CSV ist krieg
20:32:23 <dolio> roboguy_: The problem is that the polymorphic function with the weird 'c a' context triggers some goofy restrictions in GHC's type checking algorithm.
20:32:27 <dustmote> bitemyapp: lol.. i'm only using it because it's what sqliteman output :p
20:32:40 <lispy> CSV is a seductive format because it seems so easy at first glance. The devil finds a nice home in those details :(
20:32:50 <dolio> roboguy_: Where a type inside the context has to be unified with a type quantified outside the context, and that's not allowed.
20:33:17 <lispy> dolio++
20:33:35 <dolio> roboguy_: If you add a dummy 'b' argument, does it work?
20:33:46 <dolio> To the overall function, that is.
20:34:43 <dolio> (Or a Proxy b argument)
20:34:43 <roboguy_> dolio: it does if the definition is undefined. If I change it to the actual definition, it rejects it
20:35:20 <lispy> wyager: things to look for: (a) is one version more specialized than the other (meaning, more concrete types) and (b) are both versions fused? Is there a difference in the fusion?
20:35:22 <roboguy_> dolio: the type error doesn't mention the ambiguity check this time though
20:35:42 <wyager> Yeah, I'm gonna see if I can get a better idea from core
20:35:50 <lispy> wyager: I'd also be curious about differences in boxing (which would probably show up as GC pressure)
20:36:00 <elben> Using Parsec, I want to parse a string identifier, except for certain reserved keywords. The best I have right now is to parse the identifier (Parser String), then check if that parsed string is in the set of reserved keywords. Is there a better way of doing this in the Parser combinator?
20:36:05 <roboguy_> dolio: it's something like "Cannot match b0 with b... b0 is untouchable inside the constraints (c a)..."
20:36:21 <wyager> lispy: Actually, that was another question I wanted to ask: Is there a way to map an unboxed function over a Data.Vector.Unboxed.Vector?
20:36:35 <wyager> e.g. map expDouble# or whatever over a (Vec Double)
20:36:41 <roboguy_> (but with no mention of the ambiguity check)
20:37:09 <wyager> I'm not sure if GHC knows how to auto-unboxify functions like exp
20:37:14 <lispy> wyager: I don't know the answer actually, but (speculating) that wouldn't work
20:39:59 <bitemyapp> roboguy_: dolio nonsense 'b' argument makes it work.
20:40:08 <roboguy_> bitemyapp: really?
20:40:15 <bitemyapp> roboguy_: you can "undefined" the 'b' out and you don't need the ambiguous pragma anymore.
20:40:45 <bitemyapp> roboguy_: http://i.imgur.com/Snc07sr.png
20:40:49 <roboguy_> bitemyapp: it only works for me with the b argument if I leave the definition as undeifned
20:40:51 <roboguy_> *undefined
20:41:07 <roboguy_> ... huh
20:41:08 <bitemyapp> that's the screenshot. GHC 7.10.1
20:41:36 <bitemyapp> i'm going to try removing it from constrMapM but I think that'll break it. uno momento.
20:41:41 <lispy> elben: in traditional parsing you would use a lexer and it could convert keywords to special tokens for you.
20:41:51 <lispy> elben: Do you have any sort of lexer going on in your parsec parser?
20:42:16 <bitemyapp> roboguy_: yeah, as I suspected. Have to thread it through _ and non-_ versions so they unify together.
20:42:34 <roboguy_> bitemyapp: oh, I missed that
20:42:41 <bitemyapp> roboguy_: I thought you might've, that's why I tested it.
20:42:47 <roboguy_> thanks!
20:43:00 <elben> lispy: no, everything is “by hand" via parsec
20:43:01 <bitemyapp> np
20:43:01 <roboguy_> the question now is: is this expected behavior for ghc
20:43:09 <bitemyapp> roboguy_: based on what dolio was saying - probably?
20:43:18 <bitemyapp> mite inconvenient tho
20:43:22 <roboguy_> yeah. hmm
20:43:24 <lispy> elben: you can still do the lexing/parsing separation in parsec.
20:43:39 <dolio> roboguy_: I don't understand OutsideIn well enough to know if this is really correct. But it has a rule that is a lot like this.
20:43:58 <AshyIsMe> so does ghc-mod work with stack yet?
20:44:05 <lispy> elben: One parser would be from a Char stream to a Token stream and the other would be from Token steam to whatever
20:44:10 <roboguy_> dolio: is OutsideIn something in the GHC type checker?
20:44:15 <lispy> elben: That's how I would solve this.
20:44:27 <lispy> elben: well, actually I wouldn't use parsec too :)
20:44:29 <bitemyapp> roboguy_: https://wiki.haskell.org/Simonpj/Talk:OutsideIn
20:44:32 <dolio> roboguy_: This rule only gets triggered when you have higher order functions with contexts involving equality constraints and stuff like that. And a variable 'c' may well be instantiated to an equality constraint.
20:44:42 <dolio> roboguy_: OutsideIn is the name of the checking algorithm.
20:44:56 <roboguy_> ah
20:45:36 <roboguy_> pretty big paper
20:45:42 <dolio> Yes.
20:46:02 <roboguy_> can't say I'm too surprised by that, though
20:46:18 <bitemyapp> roboguy_: it'll get worse if they start bringing in the stuff to make GADTs infer more nicely.
20:46:53 <roboguy_> bitemyapp: sounds like a case where "worse" is a matter of perspective
20:47:50 <bitemyapp> roboguy_: I mean worse WRT time required to bootstrap deeper understanding.
20:48:05 <bitemyapp> roboguy_: if dolio isn't an expert of it already, it can't be very easy right? :)
20:48:17 <roboguy_> well, I send in a ticket for this tomorrow just in case. They can always mark it "wontfix" if it's expected
20:48:21 <roboguy_> bitemyapp: ha, true
20:48:43 <elben> lispy: I see what you are saying. Hmm, I’ve set up my parser to not have an intermediate type (e.g. Token). For example, in “(foo [x] x)”, foo is not reserved so this becomes a FunctionCall. But for “(fn [x] x)”, fn is reserved and should be turned into a Function. I need my `parseVariable` parser to fail on “fn”. 
20:48:58 <julianleviston> Has anyone ever actually used (.).(.) ?
20:49:19 <elben> lispy: May not be cleanest, but I can just do the check against set of reserved words, and fail using `unexpected`. But now I need to make sure the input was not consumed on failure.
20:49:35 <lispy> elben: yes
20:49:47 <roboguy_> julianleviston: yeah. Sometimes it's called (.:)
20:49:55 <roboguy_> or "fmap fmap fmap"
20:49:58 <lispy> elben: This is actually why I don't like writing parsers with parsec. Figuring out all the places you need to 'try' can be hard.
20:50:04 <julianleviston> roboguy_: ah.
20:50:13 <dolio> roboguy_: Anyhow, whenever you see 'untouchable,' what is happening is that a unification variable got made up (here for 'b'), then an equality constraint got added to the context ('c' here, which we don't know what it is), and then something tried to unify with that variable.
20:50:25 <wyager> Question: If there are "zero-overhead" abstractions like newtype constructors still present in the Core output, are they going to be present in the compile program?
20:50:38 <elben> lispy: yeah, it’s tempting to just try adding it everywhere “hoping” it’s the right place
20:50:41 <pacak> Which parameter do I tweak to force ghc to inline $w$foo in case foo of Foo a b c -> $w$foo a b c? It inlines it fine in most of the cases, but when Foo gets big - it stops doing so, which results in code an order of magnitude slower since spilling parameters in memory is more expensive than the actual processing it's doing
20:50:53 <dolio> roboguy_: Or something along those lines.
20:50:53 <lispy> wyager: newtypes are not present at run-time, but they can interfer with rewrite rules.
20:51:15 <wyager> lispy: Even if they show up in Core?
20:51:21 <roboguy_> dolio: hmm, I see
20:51:21 <julianleviston> roboguy_: makes more sense as fmap fmap fmap actually, doesn’t it.
20:51:38 <julianleviston> :: (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b) actually explains it well
20:51:50 <lispy> wyager: that's my understanding, but I'm looking at the 2010 standard right now
20:52:10 <roboguy_> julianleviston: from a certain perspective, that's a nice way to look at it. "fmap . fmap" is the same thing and it's a bit easier to read though
20:52:21 <roboguy_> (that first fmap can only be (.))
20:52:53 <roboguy_> julianleviston: you might be interested in looking up semantic editor combinators
20:53:06 <julianleviston> roboguy_: hehe… :) ok. Thanks! 
20:53:09 <roboguy_> julianleviston: which, incidentally, paves the road to lens!
20:53:40 <lispy> wyager: according to Section 4.2.3 Datatype Renamings (https://www.haskell.org/onlinereport/haskell2010/haskellch4.html) newtypes are unlifted.
20:53:45 <lispy> wyager: meaning, not boxed
20:53:47 <julianleviston> roboguy_: I just had an amusing time when some of the Clojure code I was writing wasn’t working, then I realised I was expecting it to do lazy partial evaluation like Haskell does. 
20:54:00 <lispy> wyager: so they should not be any different at runtime
20:54:03 <roboguy_> julianleviston: in fact, you might like this Edward Kmett on lens (which also talks about semantic editor combinators): https://www.youtube.com/watch?v=cefnmjtAolY
20:54:11 <roboguy_> (he even specifically mentions "fmap fmap fmap")
20:54:24 <julianleviston> roboguy_: Oh I think I tried to watch that before I really knew what a functor was once.
20:54:48 <roboguy_> julianleviston: I think you're ready =)
20:54:51 <julianleviston> roboguy_: yeah, I did.
20:56:04 <azsx> does anyone now about type unification in haskell
20:56:15 <roboguy_> speaking of talks, I hope someone recorded Brent Yorgey's talk on constraining polynomial functors with regular expressions. I saw him give it in person earlier today and it was pretty mindblowing stuff
20:56:38 <julianleviston> roboguy_: are lenses similar to the ST monad?
20:56:50 <julianleviston> roboguy_: I haven’t quite done the ST monad yet
20:57:06 <lispy> azsx: many people here do, yes
20:57:14 <jle`> they aren't quite related, i think
20:57:16 <roboguy_> julianleviston: not really. They allow you to focus on a specific part of a data structure (which is where they get the name lens)
20:57:37 <lispy> azsx: have you read the paper typing haskell in haskell? http://web.cecs.pdx.edu/~mpj/thih/thih.pdf
20:57:41 <lispy> azsx: it's a great start
20:57:43 <roboguy_> they both use rank-2 types, but for *very* different reasons
20:57:49 <julianleviston> roboguy_: yeah, that’s what I thought. The setter/getter thing threw me. I’ll go watch.
20:58:11 <julianleviston> roboguy_: what’s a rank 2 type? is this about the kind?
20:58:19 <julianleviston> roboguy_as in * -> * ?
20:58:33 <julianleviston> roboguy_: lol shall I just ask MORE random questions? (fail)
20:58:36 <lispy> rank-2 basically means you can pass a forall'd type around
20:58:39 <roboguy_> julianleviston: no. It's when you have a type like (forall a. [a] -> [a]) -> [Int]
20:58:58 <roboguy_> You don't need to fully understand it to be able to mostly figure out lens (I would say)
20:59:06 <roboguy_> lens uses it internally
20:59:08 <lispy> (what I said is too informal to actually literally be the definition, mind you)
20:59:21 <nolraiU> So if I am only going to use an MVar once is there a better tool to use?
20:59:24 <julianleviston> roboguy_: well I’ve used cursors in clojure before, and lenses seemed pretty similar
20:59:35 <mniip> a rank-N (N>1) type is a type that has a forall in a contravariant
20:59:43 <mniip> in a contravariant location*
21:00:03 <julianleviston> mniip: the trouble with that definition is it relies on other definitions! :) what’s a contravariant?
21:00:04 <roboguy_> > let example :: (forall a. [a] -> [a]) -> [Int]; example f = f [1,2,3] in example reverse
21:00:06 <lambdabot>  [3,2,1]
21:00:16 <roboguy_> that wouldn't type check without the rank-n type
21:00:39 <roboguy_> because we use f with a specific type in the definition of example
21:01:26 <mniip> julianleviston, contravariant means inverting the subtyping relation
21:01:27 <roboguy_> (I mean, you could say example :: ([Int] -> [Int]) -> [Int], but that doesn't have the same parametricity properties)
21:01:46 <julianleviston> mniip: what’s a subtyping relation?
21:02:01 <julianleviston> mniip: you can stop if you’re bored or don’t want to keep going.
21:03:52 <mniip> julianleviston, type S is a subtype of type T, if a value of type S can be used where a value of type T is expected
21:04:17 <julianleviston> mniip: sure, but what’s a subtyping relation?
21:04:49 <julianleviston> mniip: or do you just mean “inverting the relationship of two types where one is a subtye of the other"?
21:05:45 <nolraiU> Int -> Int is a subtype of a -> a. In this context.
21:05:51 <mniip> nolraiU, no
21:06:02 <roboguy_> iff S is a subtype of T then there is a subtype relation between S and T
21:06:03 <mniip> wait yes
21:06:30 <mniip> julianleviston, it's a binary relation consisting of pairs where fst is a subtype of snd
21:06:52 <julianleviston> Oftentimes the trouble with concision of language is that it often sacrifices precision at the expense of clarity in an ironically obfuscatory manner. Information hiding is more concise, but provides less opportunity for clarity at a single level.
21:07:17 <julianleviston> mniip: what’s a relation?
21:08:03 <rowanblush> Somebody you see at Thanksgiving.
21:08:04 <roboguy_> julianleviston: technically, it's a subset of a cartesian product of two sets
21:08:08 <roboguy_> julianleviston: https://en.wikipedia.org/wiki/Binary_relation
21:08:28 <mniip> a relation between elements of sets S_1, S_2, ... S_n, is a set of n-tuples (x_1, x_2, ... x_n) where x_1 \in S_1, x_2 \in S_2 ... x_n \in S_n
21:08:36 <julianleviston> roboguy_: ah ok, I thought it had a special meaning here. Ok..
21:08:47 <roboguy_> an example would be the <= operation on numbers
21:08:49 <julianleviston> mniip: what is a set?
21:09:03 <julianleviston> roboguy_: I don’t know that operation, sadly.
21:09:13 <roboguy_> julianleviston: I just mean less than or equal to
21:09:20 <lispy> > 1 <= 2
21:09:22 <mniip> julianleviston, well that depends
21:09:22 <lambdabot>  True
21:09:24 <julianleviston> mniip: I mean in haskell terms. Is it an instance of Data.Set ?
21:09:32 <mniip> no
21:09:42 * hackagebot angel 0.6.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.6.2 (MichaelXavier)
21:09:48 <julianleviston> Oh you mean the Haskell operator <= haha ok.
21:09:54 <mniip> the closest haskell has to sets is predicates
21:10:04 <roboguy_> (Incidentally, subtyping is more specifically a preorder on types)
21:10:05 <mniip> but those operate on a closed universe
21:10:19 <mniip> haskell has relations in the typesystem though
21:10:27 <mniip> MultiParamTypeClasses
21:10:28 <julianleviston> mniip: I assumed when I was asking questions you realised I was asking in a Haskell context. 
21:11:07 <mniip> julianleviston, just because sets don't exist in haskell it doesn't mean that haskell-related theory can't use sets
21:11:31 <julianleviston> mniip: that isn’t out of accord with what I was saying.
21:12:12 <julianleviston> mniip: If your intent was to inform me of anything, unfortunately we’ve failed together.
21:12:24 <mniip> huh
21:12:27 <julianleviston> mniip: however if you wanted to confuse me, job well done! :)
21:12:59 <julianleviston> mniip: suffice to say I don’t think I’m ready to understand whatever it is you’re trying to explain to me yet. Thanks, though.
21:13:17 <mniip> julianleviston, I can spice it up with examples
21:13:35 <julianleviston> mniip: unless you have a clear way to explain it :) haha… but I’m a bit dubious about that capacity, sadly.
21:13:49 <mniip> [07:03:15] <mniip> julianleviston, type S is a subtype of type T, if a value of type S can be used where a value of type T
21:14:18 <mniip> 'Int' is a subtype of 'a' because everything that expects an 'a' can be given an 'Int'
21:14:25 <julianleviston> mniip: I think explaining the law of associativity to a 6 year old would be an exercise in futility if you used the word associativity, for example.
21:14:45 <julianleviston> mniip: oh I got that bit… I think I understand subtypes just fine.
21:15:02 <mniip> likewise, 'a -> Int' is a subtype of 'a -> b'
21:15:13 <mniip> and 'a -> b' is a subtype of 'Int -> b'
21:15:24 <julianleviston> mniip: I don’t follow that at all
21:15:34 <julianleviston> what is ‘a -> Int’ ?
21:15:42 <julianleviston> or are the quotes not part of that expression?
21:15:58 <julianleviston> ok so they’re not. Then I get it.
21:16:03 <roboguy_> julianleviston: it is a type
21:16:11 <julianleviston> roboguy_: ‘Int is not a type.
21:16:13 <mniip> it's a function taking 'a' and returning 'Int'
21:16:15 <julianleviston> roboguy_: Int is a type.
21:16:17 <roboguy_> > let f :: a -> Int ; f _ = 3 in f 'a'
21:16:19 <lambdabot>  3
21:16:25 <roboguy_> julianleviston: right
21:16:27 <julianleviston> mniip: using quotes on things is confusing 
21:16:33 <julianleviston> what on earth?
21:16:37 <mniip> julianleviston, not using them is often ambiguous
21:16:45 <julianleviston> sigh
21:16:48 <mniip> because things like 'a' are valid english words
21:17:00 <roboguy_> > let f :: a -> Int ; f _ = 3 in f 'z' -- To make sure there isn't confusion here
21:17:01 <lambdabot>  3
21:17:09 <julianleviston> mniip: it’s ambiguous because people often write expressions such as a’ = a + 5
21:17:25 <roboguy_> I like double quotes
21:17:28 <mniip> okay I will use quasiquoters from now on
21:17:32 <julianleviston> roboguy_: what on earth is f ‘z’ ?
21:17:44 <mniip> [t|a -> Int|] is a subtype of [t|a -> b|]
21:17:47 <lispy> > let f :: a -> Int ; f _ = 3 in f f
21:17:49 <lambdabot>  3
21:17:50 <roboguy_> julianleviston: it's a function call. f is the function name, 'z' is a character literal (a Char)
21:17:52 <julianleviston> roboguy_: ‘z’ there is a Char right?
21:17:53 <roboguy_> > 'z'
21:17:54 <lambdabot>  'z'
21:17:56 <roboguy_> julianleviston: yeah
21:18:00 <roboguy_> > let f :: a -> Int ; f _ = 3 in f True
21:18:02 <lambdabot>  3
21:18:22 <julianleviston> roboguy_: yeah ok. I got thrown because he was using quotes around his Haskell expressions, and you were using Char s lol.
21:18:31 <roboguy_> ahh, oops ha
21:18:47 <julianleviston> roboguy_: it’s funny because I actually knew everything both of you said just now
21:19:06 <mniip> including quasiquoters?
21:19:12 <roboguy_> okay, so does this type and everything make sense:
21:19:29 <julianleviston> mniip: yeah
21:19:43 * hackagebot text1 0.0.3 - Non-empty values of `Data.Text`.  http://hackage.haskell.org/package/text1-0.0.3 (TonyMorris)
21:19:53 <julianleviston> mn my problem is the language used around this stuff, not the stuff itself.
21:20:05 <mniip> [06:57:35] <julianleviston> roboguy_: what’s a rank 2 type? is this about the kind?
21:20:05 <julianleviston> mniip: the metalanguage for things is often so much more complex than it needs to be.
21:20:10 <roboguy_> > let example :: ([a] -> [a]) -> [a] ; example f = f [] in example (\_ -> [1,2,3])
21:20:12 <lambdabot>  [1,2,3]
21:20:14 <azsx> > let f :: a -> Int ; f _ = 3 in f a
21:20:16 <lambdabot>  3
21:20:25 <julianleviston> mniip: <sigh> not EVERYTHING you’ve ever said. god.
21:20:34 <roboguy_> azsx: okay, now that's confusing ha. a is an Expr I believe
21:20:38 <roboguy_> which is a lambdabot thing
21:20:41 <roboguy_> :t a
21:20:42 <lambdabot> Expr
21:20:44 <roboguy_> yep
21:20:58 <roboguy_> it's totally unrelated. It's there so you can do things like:
21:21:04 <roboguy_> > a + b
21:21:05 <lambdabot>  a + b
21:21:23 <mniip> julianleviston, do you actually have a question or are you just messing with us
21:21:23 <roboguy_> > foldr (+) z [a,b,c]
21:21:25 <lambdabot>  a + (b + (c + z))
21:21:26 <julianleviston> roboguy_: yeah, it makes sense.
21:21:58 <julianleviston> mniip: um… I was asking questions because I didn’t understand some of what you were saying. 
21:22:05 <roboguy_> julianleviston: so, in that example the caller of the function "example" gets to pick the type "a"
21:22:08 <roboguy_> yeah?
21:22:26 <mniip> julianleviston, so you want to know what rank-2 types are?
21:23:15 <julianleviston> mniip: I *do*, but I’m dubious as to whether you can explain it to me in language I understand, or put another way, I don’t think I can understand your explanation of them to me.
21:23:28 <mniip> julianleviston, how good are you at haskell
21:23:32 <julianleviston> roboguy_: ok maybe I don’t understand your let example sutff
21:23:39 <julianleviston> mniip: how do I quantify that?
21:23:44 <julianleviston> mniip: not very, I would say.
21:24:01 <mniip> (I'm dubious beacause you were confused about what <= is)
21:24:15 <mniip> julianleviston, do you understand polymorphism?
21:24:18 <julianleviston> mniip: mniip fair enough.
21:24:43 <roboguy_> julianleviston: well, the idea is that the body of example doesn't get to pick the type used for "a", but the person calling it can pick that type. We aren't allowed by Haskell to write "example :: ([a] -> [a]) -> [a] ; example f = f [True, False]"
21:24:55 <julianleviston> mniip: every operator has a context, and in that context I was thinking of do blocks, which confused me, for some reason.
21:25:19 <mniip> do blocks use <-
21:25:35 <mniip> the only arrow in haskell that has "context" is ->
21:25:37 <julianleviston> roboguy_: I don’t really understand what let example :: does there? I thought :: meant type of, but that expression emits a value… 
21:25:46 <lispy> julianleviston: rank-2 types permit the use of 'forall' on the left side of an arrow
21:25:51 <julianleviston> mniip: you’re very difficult to talk to for me.
21:25:56 <roboguy_> julianleviston: it does mean type of. The expression is after the "in"
21:26:06 <mniip> julianleviston, (x :: T) is a type restriction
21:26:07 <roboguy_> > let x :: Int ; x = 3          in x
21:26:11 <arkeet> > let { x :: Int; x = 3 } in x+x
21:26:11 <lambdabot>  3
21:26:13 <lambdabot>  6
21:26:16 <lispy> julianleviston: (a -> b) is a rank 1 type whereas ((forall a. a) -> b) is a rank-2 type
21:26:23 <julianleviston> mniip: I meant a context for us. If you redefine <=, then it has a different context (env) for that duration.
21:26:24 <arkeet> inside the let block there are 2 statements.
21:26:28 <arkeet> one gives the type of x.
21:26:30 <arkeet> the other gives the value of x.
21:26:31 <catsup> mniip: you seem to be using nonstandard terminology
21:26:46 <mniip> catsup, what specifically
21:26:54 <funfunctor> @hoogle Text -> String
21:26:54 <lispy> ((forall a. a -> r) -> r) would be different rank-2 type
21:26:55 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
21:26:55 <lambdabot> Data.Text.Internal showText :: Text -> String
21:26:55 <lambdabot> Data.Text unpack :: Text -> String
21:26:58 <hunteriam> What is the # in this slide?
21:27:00 <hunteriam> http://yogsototh.github.io/Category-Theory-Presentation/#slide-35
21:27:09 <arkeet> hunteriam: cardinality
21:27:18 <hunteriam> Meaning?
21:27:21 <arkeet> number of elements
21:27:27 <catsup> mniip: talking about type variables as supertypes earlier (or rather the converse, with 'subtype'), also 'type restriction'
21:27:32 <arkeet> it's saying hom(Z,Y) has exactly one element.
21:27:40 <hunteriam> Ah thanks
21:27:51 <julianleviston> doesn’t :: mean “is type of” ?
21:28:02 <julianleviston> 5 :: Int for example
21:28:02 <arkeet> "x :: t" means "x has type t"
21:28:20 <julianleviston> arkeet: it can have more than one type??
21:28:36 <mniip> catsup, I always forget the word for the :: thing
21:28:37 <arkeet> ??
21:28:41 <arkeet> it's just specifying the type of x.
21:28:44 <mniip> not entirely sure what do you mean by the other thing
21:28:46 <catsup> mniip: type annotation
21:28:50 <mniip> it's not an annotation
21:28:54 <catsup> well ok
21:28:58 <mniip> it's an annotation in a declaration
21:29:01 <mniip> but not in an expression
21:29:05 <lispy> some people call it a type assertion.
21:29:27 <mniip> hold on TH probably has a name for this
21:29:33 <lispy> and that emphasizes that you might want it have a particular type, but the formalism gets to decide :)
21:29:41 <arkeet> julianleviston: if you have an expression with a polymorphic type, you can use :: to pin down the type to something more specific.
21:29:44 <arkeet> :t 5
21:29:45 <lambdabot> Num a => a
21:29:46 <arkeet> :t 5 :: Int
21:29:47 <lambdabot> Int
21:29:53 <mniip> SigE...
21:29:53 <julianleviston> arkeet: yeah, I know.
21:30:06 <julianleviston> arkeet: isn’t that what “is type of” means?
21:30:15 <julianleviston> sorry is of type GUH.
21:30:23 <julianleviston> 5 :: Int (5 is of type Int)
21:30:24 <julianleviston> right?
21:30:27 <arkeet> sure
21:30:29 <julianleviston> phew.
21:30:42 <mniip> well
21:30:48 <julianleviston> mniip no.
21:30:51 <catsup> you can be restricting the type even in a declaration
21:30:54 <lispy> julianleviston: did my example of rank-2 types make sense?
21:31:00 <julianleviston> lispy: nup.
21:31:01 <mniip> 1 + (5 is of type Int) doesn't make sense in english
21:31:04 <julianleviston> lispy: but it’s me, not you.
21:31:15 <catsup> 1 + (5, _which_ is of type Int)
21:31:17 <roboguy_> > let x :: Int; x = 5          in x         -- julianleviston: does this make more sense?
21:31:18 <mniip> but you probably get the idea of what it means
21:31:18 <lambdabot>  5
21:31:27 <julianleviston> mniip: but it’s not english.
21:31:42 <lispy> julianleviston: I'd be happy to provide more explanation, examples, or answers if you'd like figure it out right now.
21:31:52 <julianleviston> roboguy_: what is x = 5 in x ?
21:32:03 <mniip> mhm
21:32:06 <arkeet> 'in' doesn't make sense without 'let'.
21:32:13 <arkeet> > let { x :: Int; x = 5 } in x
21:32:15 <lambdabot>  5
21:32:15 <roboguy_> julianleviston: that is not how it is grouped. The "x :: Int" goes with the "x = 5"
21:32:41 <roboguy_> julianleviston: It is like writing "x :: Int" on one line of a .hs file "x = 5" on the next and then loading into GHCi and typing x
21:32:43 <mniip> julianleviston, awkward how we've been speaking particularly syntactically complex haskell all this time and you don't even understand that
21:33:07 <hunteriam> So, formally functors need a function like F: (a->b) -> (Fa -> Fb) but we just don't do that in Haskell. Am I right, or misunderstanding?
21:33:11 <julianleviston> mniip: I’m not sure I understand what you mean.
21:33:19 <julianleviston> mniip: but I apologise if I’m annoying.
21:33:28 <mniip> nonono, it's okay
21:33:31 <arkeet> hunteriam: huh? that very thing exists, as fmap
21:34:00 <julianleviston> ah let { x :: Int; x = 5 } in x makes more sense.
21:34:01 <hunteriam> Isn't fmap just for a->Fa arkeet , ie object not Morphism
21:34:08 <hunteriam> :t fmap
21:34:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:34:17 <hunteriam> Uh whoops
21:34:23 <julianleviston> I’d just never encountered let x :: Int; x = 5 in x syntax before.
21:34:37 <julianleviston> could you also say let x = 5 :: Int in x?
21:34:41 <roboguy_> no
21:34:44 <roboguy_> oh, yeah
21:34:45 <lispy> :t fmap :: Functor f => (a -> b) -> (f a -> f b) -- demonstrates the associativity
21:34:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:34:47 <roboguy_> misread that, sorry
21:34:48 <julianleviston> ok thanks.oh
21:35:09 <julianleviston> roboguy_: oh sweet… coz that’s how I would have written the sematics.
21:35:09 <mniip> julianleviston, okay so, do you know what polymorphism is
21:35:10 <arkeet> julianleviston: but that's something slightly different.
21:35:13 <hunteriam> And does that mean the object version a -> Fa is just the type constructor arkeet ?
21:35:15 <arkeet> it's parsed as x = (5 :: Int)
21:35:16 <julianleviston> mniip: I think I do.
21:35:25 <julianleviston> mniip: polymorphic types, you mean, right?
21:35:27 <lispy> hunteriam: something that can be confusing about category theory in Haskell is that we use the function arrow (->) for two different categorical things
21:35:28 <mniip> yes
21:35:28 <arkeet> hunteriam: what is -> 
21:35:51 <hunteriam> Lispy what are they?
21:36:11 <lispy> hunteriam: in the type (a -> b) -> (f a -> f b), you can think of it this way (a ~> b) -> (f a ~> f b), where ~> is the arrow in the category and -> is the normal function arrow
21:36:12 <mniip> hunteriam, lispy, note that haskell functors are endofunctors on Hask, so -> means the same as ->
21:36:18 <julianleviston> mniip: yeah, i’m pretty sure I do. 
21:36:26 <redcoat> President Clinton, what IS the meaning of ->
21:36:36 <julianleviston> mniip: Maybe a => (a -> a) for example?
21:36:37 <hunteriam> Mniip and Hask is the category of objects in the Haskell language?
21:36:50 <mniip> hunteriam, category of types
21:36:54 <mniip> with functions as morphisms
21:37:17 <mniip> julianleviston, yeah that's a polymorphic type
21:37:22 <julianleviston> mniip: yep.
21:37:24 <mniip> julianleviston, do you know what id is
21:37:34 <julianleviston> mniip: yeah, the identity function
21:37:37 <lispy> yeah, so a Functor instance f is from Hask to f Hask
21:37:41 <julianleviston> mniip: \x -> x
21:38:04 <julianleviston> lispy: huh?
21:38:10 <hunteriam> So, what's the distinction between -> and ~>, if -> is a Morphism in Hask? Lispy
21:38:26 <julianleviston> lispy: oh you weren’t talking to me, soz.
21:38:34 <lispy> hunteriam: we don't make a distinction in Haskell. You could basically say type (~>) = (->)
21:38:44 <mniip> julianleviston, now, if I said, idInt :: Int -> Int; id x = x
21:38:45 <mniip> er
21:38:47 <mniip> julianleviston, now, if I said, idInt :: Int -> Int; idInt x = x
21:39:15 <hunteriam> Lispy ah but outside of Haskell -> is function not Morphism?
21:39:21 <julianleviston> mniip: id Int:: Int -> Int; id Int x = x ? you mean?
21:39:25 <lispy> hunteriam: but in the general case of functors they don't have to be the same. So when you look at these definitions in a textbook it can be confusing "where did the arrows go?"
21:39:34 <mniip> julianleviston, no, idInt is a single name
21:39:44 <julianleviston> mniip: ohhhh one sec, I’ll parse that
21:40:06 <hunteriam> Sorry, is the center arrow not a Morphism as well? Lispy
21:40:15 <julianleviston> mniip: erm… yeah, what about that?
21:40:26 <julianleviston> mniip: isn’t that just id constrained to ints?
21:40:30 <mniip> it is
21:40:32 <lispy> hunteriam: the center arrow is a morphism in Hask
21:40:34 <julianleviston> mniip: yeah
21:40:43 <lispy> hunteriam: meaning, it's a Haskell function arrow
21:41:00 <julianleviston> mniip: but isn’t id polymorphic? why bother constraining its type?
21:41:10 <mniip> julianleviston, now if I were to say (id :: Int -> Int), it would mean the same thing as idInt
21:41:21 <hunteriam> But it could be anything, is what you're saying, as long as it produces the corresponding morphisms in F
21:41:22 <hunteriam> ?
21:41:39 <ttt_fff> are there builtins for seleecint the first, second, and third elements of a 3-eleme tuple?
21:41:41 <julianleviston> mniip: um… I guess so.
21:41:57 <Axman6> ttt_fff: no, only 2-tuples
21:42:01 <mniip> I've put the parentheses as a disambiguation here, so that it's an expression
21:42:12 <julianleviston> mniip: yeah, I got that.
21:42:14 <lispy> hunteriam: hmm...I seem to have confused you and I'm trying to think of a way to explain this.
21:42:21 <Axman6> but lens has Field1, Field2..Field9 classes giving you _1 .. _9
21:42:24 <julianleviston> mniip: I’m not sure where you’re going with this, but yep.
21:42:38 <Axman6> > ("hello",True) ^. _1
21:42:39 <lambdabot>  "hello"
21:42:41 <mniip> [07:40:24] <julianleviston> mniip: but isn’t id polymorphic? why bother constraining its type?
21:42:42 <Axman6> > ("hello",True) ^. _2
21:42:44 <lambdabot>  True
21:42:49 <ttt_fff> only fst and 2nd ?
21:42:51 <mniip> consider read, it has type Read a => String -> a
21:42:56 <ttt_fff> (1, 2, 3) ^. _3
21:43:01 <hunteriam> Lispy just trying to understand the significance of distinguishing between -> and ~>
21:43:06 <Axman6> > ("hello",True,()) ^. _3
21:43:07 <ttt_fff> > (1, 2, 3) ^. _3
21:43:08 <lambdabot>  ()
21:43:09 <lambdabot>  3
21:43:09 <ttt_fff> OMG
21:43:11 <ttt_fff> I love lenss
21:43:19 <Axman6> lenses love you
21:43:19 <lispy> hunteriam: Are you familiar with the CT definition of functor?
21:43:20 <julianleviston> mniip: what are you trying to teach me? I’m pretty lost right now
21:43:22 <ttt_fff> Axman6++
21:43:31 <Axman6> @karma Axman6
21:43:31 <lambdabot> You have a karma of 10
21:43:35 <ShadySound> Does anyone know where I can find the code for sql slammer
21:43:37 <mniip> julianleviston, you asked why type constraining is useful
21:43:37 <Axman6> \o/
21:43:37 <ShadySound> ?
21:43:47 <julianleviston> mniip: I did?
21:43:56 <mniip> "why bother constraining its type?"
21:43:57 <lispy> hunteriam: a functor f from C to D maps objects of C to objects of D AND it maps arrows in C to arrows in D
21:44:04 <Axman6> ShadySound: is that a haskell thing?
21:44:18 <julianleviston> mniip: I’m very frustrated.
21:44:19 <hunteriam> Lispy yes I don't know what CT is but I know that def
21:44:22 <lispy> hunteriam: in the case of Hask, the objects are types and the arrows are functions
21:44:30 <lispy> CT = category theory
21:44:39 <hunteriam> Ah ya
21:44:42 <julianleviston> mniip: I understand sometimes you might need to constrain a type, but I’m not sure why you’re telling me this.
21:44:46 <ttt_fff> @karma ttt_fff
21:44:46 <lambdabot> You have a karma of 1
21:44:51 <ttt_fff> @karma lambdabot
21:44:52 <lambdabot> lambdabot has a karma of 29
21:44:52 <lispy> our Functor type class maps from Hask back to itself.
21:44:58 <ttt_fff> @karma dons
21:44:58 <lambdabot> dons has a karma of 2
21:44:58 <hunteriam> But the functors mapping from C to Disnt necessarily a function, right? Lisps
21:45:03 <ttt_fff> @karma Cale
21:45:03 <lambdabot> Cale has a karma of 64
21:45:03 <mniip> argh
21:45:07 <hunteriam> *lispy
21:45:17 <hunteriam> @karma
21:45:17 <lambdabot> You have a karma of 0
21:45:27 <lispy> hunteriam: that's right, arrows don't have to be functions
21:45:46 <Axman6> lambdabot is broken if she thinks dons has a karma of 2. it's at least two orders of magnitude off
21:45:47 <hunteriam> Lispy where would I learn what else an arrow might be?
21:45:49 <ttt_fff> m (a, s, w) -> m a <-- is there a way to get this via lens?
21:46:00 <hunteriam> Since I'm assuming it's somewhat in depth
21:46:10 <lispy> hunteriam: a list of examples of categories? :)
21:46:13 <mniip> hunteriam, are you familiar with preorders, total order, etc
21:46:21 <Axman6> ttt_fff: fmap (view (_1))
21:46:22 <hunteriam> Just preorders
21:46:33 <julianleviston> mniip: are you still saying stuff to me?
21:46:35 <ttt_fff> Axman6++
21:46:45 <ttt_fff> Axman6: do you use haskell for your real job, or just very good with your hobby?
21:46:50 <julianleviston> mniip: because you have my attention right now
21:47:01 <mniip> hunteriam, in a preorder, an arrow is an element of the >= relation
21:47:13 <mniip> okay that was misworded
21:47:14 <julianleviston> mniip: or can I go do something else?
21:47:15 <Axman6> ttt_fff: for my job, yes
21:47:21 <hunteriam> Mniip ah and in string an arrow is a string
21:47:34 <mniip> julianleviston, I'm confused about what do you actually know and what do you want to know
21:47:35 <hunteriam> Mini that's a good example right?
21:47:38 <ttt_fff> Axman6: can I ask where, and how big the haskell group at your work is?
21:47:43 <Axman6> ttt_fff: there's probably a more concise way to do m (a ,b, c) -> m a but I think that solution is clear enough
21:48:06 <Axman6> (obviously you can use view (+1) <$> mabc which is the same thing, and maybe a little nicer)
21:48:09 <mniip> hunteriam, string?
21:48:13 <ttt_fff> actually, I ended up doing " (_a, _s, w) <- runRWST .... \n return w " .... seemed clearer
21:48:51 <julianleviston> mniip: ah ok… nevermind then. Thanks. I know a fair bit of the basics of Haksell… but I have no clue what a rank 2 type is. I’m going to go look it up now, though.
21:48:54 <Axman6> ttt_fff: NICTA (the one the course is from) - in my team there's 1.75 Haskell programmers (one is still learning and doesn't copnsider himself one yet :P)
21:49:12 <hunteriam> Mniip I don't know how legitimate this is, but in this presentation obj(String) had a single object and each Morphism was a different string
21:49:15 <mniip> julianleviston, https://wiki.haskell.org/Rank-N_types
21:49:21 <mniip> should explain it pretty well
21:49:30 <julianleviston> mniip: errr yes, thank, that’s what I’m reading
21:49:30 <Axman6> but there's quite a few others around the place. there used to be more but most of them left with the Ambiata spinout afaiui
21:49:52 <mniip> hunteriam, and what did morphisms connect?
21:50:05 <mniip> or I see
21:50:05 <hunteriam> Mniip the node to itself
21:50:14 <julianleviston> mniip yeah, this is really confusing. But it’s ok, I figure I’ll learn about them later. Like I said, it’s above my level right now.
21:50:47 <hunteriam> Concatenation was the same as composition
21:50:50 <mniip> yeah
21:51:01 <ttt_fff> Axman6: https://github.com/NICTA/course <-- this NICTA ? I have no idea what NICTA is
21:51:02 <lispy> julianleviston: people here are always eager to explain things :)
21:51:03 <mniip> you can view a monoid as a category
21:51:05 <julianleviston> mniip: it *is* annoying that so much of this stuff is obscured by the metalanguage, though. For example, Functors are really frigging simple, but the shrowd of mystery isn’t.
21:51:16 <julianleviston> lispy: awww :)
21:51:32 <dibblego> ttt_fff: National ICT Australia.
21:51:46 <mniip> hunteriam, that's a monoidal category right
21:51:50 <dibblego> ttt_fff: yes, that course is the same NICTA
21:51:52 <Axman6> ttt_fff: yep. We're Australia's largest ICT research organisation - we're also responsible for more PhD students than any other organisation in Aus (~300)
21:52:00 <Axman6> we're pretty badass
21:52:02 <Axman6> >_>
21:52:05 <roboguy_> julianleviston: I always look at rank-n types as changing who gets to pick the type that a type variable represents
21:52:12 <hunteriam> Mniip ya
21:52:16 <roboguy_> (the definition of a function or the caller of that function)
21:52:20 <julianleviston> roboguy_: oh that makes sense!
21:52:31 <julianleviston> roboguy_: thanks! :) perfectly succinct.
21:52:33 <mniip> hunteriam, the category closest to Hask is Set, where objects are sets, and arrows are functions
21:52:47 <roboguy_> normally, the caller of the function gets to pick. A rank-2 type lets the definition of a function pick
21:53:39 <hunteriam> So, does the category of categories contain itself?
21:53:46 <julianleviston> roboguy_: hey - question, what is forall?
21:53:46 <hunteriam> And doesn't that break something
21:53:58 <mniip> hunteriam, what are morphisms
21:54:25 <julianleviston> roboguy_: nevermind, I’ll read this: http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
21:54:49 <ttt_fff> Axman6: 300 haskellers is like 3K ocaml-ers, and is like 30K C-programmers, and about as productive as 300K javscripters
21:55:04 <codehero> lol
21:55:27 <dibblego> ttt_fff: it's superpolynomial, not polynomial
21:56:15 <ttt_fff> I'm pretty sure 3e2, 3e3, 3e4, 3e5 is an exponential seuqence .... not a polynomial .... you must be a php-er!
21:56:48 <hunteriam> Minor functors
21:56:53 <julianleviston> I wish I had seuquence on my gown.
21:56:57 <hunteriam> *mniip: ^
21:57:15 <mniip> hunteriam, why would there be problems with it containing itself
21:57:38 <hunteriam> Mniip it's just conceptually weird, since it'd be recursive
21:58:01 <mniip> and?
21:58:26 <hunteriam> Well, there is t a set of all sets for that reason
21:58:29 <hunteriam> Afaik
21:58:51 <mniip> are you misciting the russell's paradox
21:59:11 <mniip> ttt_fff, 
21:59:11 <mniip> [07:55:38] <ttt_fff> I'm pretty sure 3e2, 3e3, 3e4, 3e5 is an exponential seuqence .... not a polynomial .... you must be a php-er!
21:59:12 <mniip> what
21:59:18 <mniip> 36450*x^3-206550*x^2+367200*x-196800
21:59:50 <mniip> > map (\x->36450*x^3-206550*x^2+367200*x-196800) [1..3]
21:59:51 <lambdabot>  [300,3000,30000]
21:59:53 <ttt_fff> mniip: lol, is this the whole any n-points can be fitted to a deg n-1 polynomial ?
21:59:53 <mniip> > map (\x->36450*x^3-206550*x^2+367200*x-196800) [1..4]
21:59:55 <lambdabot>  [300,3000,30000,300000]
22:00:22 <ttt_fff> mniip++
22:00:23 <mniip> ttt_fff, pretty much, which is why all "continute the sequence" are by definition flawed
22:00:36 <hunteriam> Mniip well apparently it can't include itself, although I don't know entirely why
22:00:43 <hunteriam> According to someone else I asked
22:00:54 <mniip> hunteriam, russell's paradox is about all sets not including themselves
22:00:55 <hunteriam> So the category of categories is actually the category of small categories
22:01:40 <ttt_fff> #haskell where pedantic discussions, instead of resulting in flamewars, ends up discussing classical results in matheamtics
22:01:54 <roboguy_> mniip: russell's paradox would also apply to a category of *all* categories. But sometimes the category of small categories is referred to as the "category of categories", even though that's not technically accurate
22:02:00 <mniip> hm
22:02:16 <roboguy_> the category of small categories is itself a large category
22:02:28 <ttt_fff> [(a, b)] -> [(a, [b])] -- ie.. group all elemes taht ahve the same 'a' -- is there a builtin for this?
22:02:28 <mniip> I think I'm going to retreat on this front because I'm not particularly well versed in the mess that ZFC is
22:02:38 <ttt_fff> @hoogle [(a, b)] -> [(a, [b])]
22:02:38 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
22:03:00 <ttt_fff> all I know about ZFC is that there's this badass proof technique, badass because it's name is 'forcing'
22:03:10 <AshyIsMe> so when using stack do you still use the cabal file to manage library dependencies?
22:03:25 <mniip> :t map (head *** map snd) . groupBy snd
22:03:26 <lambdabot>     Couldn't match type ‘([c], [(a0, b)])’ with ‘[a]’
22:03:26 <lambdabot>     Expected type: [a] -> (c, [b])
22:03:26 <lambdabot>       Actual type: ([c], [(a0, b)]) -> (c, [b])
22:03:34 <roboguy_> mniip: well, this isn't really zfc related actually
22:03:38 <dibblego> Eq a => [(a, b)] -> [(a, NonEmpty b)]
22:04:01 <julianleviston> ttt_fff: I think it’s because we all understand that a problem is an opportunity in disguise.
22:04:45 <mniip> :t map ((fst . head) &&& (map snd)) . groupBy ((==) `on` snd)
22:04:46 <lambdabot> Eq a => [(a1, a)] -> [(a1, [a])]
22:04:47 <ttt_fff> >t (***)
22:04:51 <mniip> ttt_fff, ^
22:04:53 <ttt_fff> :t (***)
22:04:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:05:01 <ttt_fff> :t (&&&)
22:05:02 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:05:16 <julianleviston> ttt_fff: this is about the only place where I feel that people can separate their like or dislike from the structure of a problem. That’s pretty darn special, right?
22:05:21 <ttt_fff> mniip: ELI5: what is *** and &&& ? are they like airplanes, boats, or yellow trucks?
22:05:43 <mniip> (***) f g (a, b) = (f a, g b)
22:05:49 <ttt_fff> julianleviston: because, unlike politics, there is absolute truth?
22:05:50 <mniip> (&&&) f g x = (f x, g x)
22:06:00 <ttt_fff> mniip: al, thanks!
22:06:01 <mniip> but that's only the -> arrow
22:06:07 <mniip> there are other arrows too
22:06:35 <ttt_fff> don't tell me about arrows
22:06:42 <ttt_fff> I'm still in the 'feel smart beause I understand monads" phase
22:06:43 <ttt_fff> don't run it
22:06:57 <dibblego> arrows are different to monads, in that they are not useful as an abstraction
22:07:48 <lispy> mniip: you can also see that the set of all sets is a problem using cantor's result that says a power set is strictly larger than the original set
22:07:58 <julianleviston> ttt_fff: well, if I understand you, I have no quarrel with you… no matter how in disagreement we are.
22:08:46 <mniip> julianleviston, haskell community is pretty good at separating things that are usually fused together
22:08:56 <julianleviston> mniip: funny that :) hehe.
22:09:20 <ttt_fff> yeah, tthose lispers can't separate "compile" from "run"
22:09:33 <julianleviston> mniip: it always amuses me that LISP gets touted as the most amazing language, while Haskell silently keeps providing LISP with its substrate.
22:09:40 <mniip> those Cers can't separate "calculate" from "execute"
22:10:40 <jle`> ttt_fff: these days the trendy alternative to (***) is bimap from Data.Bifunctor
22:10:55 <mniip> jle`, what about &&& though
22:11:00 <julianleviston> I spent a while bashing my head against macros in LISP goign “this is wrong! all code should have macro-level excecution ability”… until someone finally said to me “have you tried Haskell?” ;-)
22:11:11 <jle`> no trendy alternative at the moment
22:11:38 <jle`> but you can bimap after a join (,)
22:11:47 <ttt_fff> yeah; I'v efound, with laziness, I don't need macros
22:11:55 <julianleviston> ttt_fff: exactly.
22:14:00 <julianleviston> I do think the syntax of haskell is pretty god-awful, though. It’d be nice if it was regular.
22:14:10 <julianleviston> but maybe I just don’t know what I’m talking about, yet.
22:15:24 <jle`> haskell has a pretty nice and elegant core syntax that fits the language and what it tries to express well.  but admittedly the design committee decided explicitly against spending too much time on syntax and focusing on the language instead
22:16:15 <jle`> there's admittedly a *lot* of sugar, and GHC adds even more sugar with extensions
22:16:26 <jle`> a lot of people are a bit turned off by the sugar
22:16:50 <jle`> but you can stick to the core syntax or a small subset of what you deem is essential if you want too
22:17:14 <lispy> I really like Haskell syntax, but maybe I've had too much koolaid. (My next favorite is agda syntax)
22:17:44 <jle`> the core syntax is great in embodying visually the semantics that they represent
22:18:06 <YamiGucci> How is Haskell as a first language in comparison to C, C++ or Java?
22:18:09 <jle`> i gradually get used to each new sugar thing i see, although there's still some that i sort of can't stomach adopting myself, heh
22:18:15 <jle`> YamiGucci: people say that it's better
22:18:35 <jle`> but there isn't much actual non-anecdotal evidence either way
22:19:05 <jle`> i'd imagine less implicit state to keep track of makes things a lot simpler
22:19:46 <jle`> s/less/no
22:20:39 <julianleviston> The thing I like about Haksell is it’s explicit about its evaluation - it says “this won’t be evaluated in any particular order, but this other stuff will be” - all other programming languages kind of skip this fact… it’s assumed you’ll understand that it’s sequenced. Javascript for example, provokes a kind of confusing nightmare in beginners that most non-beginners arn’t aware of.
22:20:41 <jle`> i think from an ecosystem standpoint you'll have a lot more options for help and assistance starting with a more established language though
22:21:15 <YamiGucci> Do you have to worry about data type compiler erorrs, pointers, and crap like that in Haskell?
22:21:52 <jle`> haskell doesn't really have pointers and references int he same sense that java or c has them
22:22:06 <jle`> you'll have type errors in haskell but usually they're because your program doesn't make sense
22:22:17 <jle`> so type error or not, it won't work anyway, heh
22:22:37 <julianleviston> YamiGucci: the type errors are going to be a problem in every language, though.
22:22:58 <jle`> type errors are actually preferable to logic errors that are only caught in runtime actually
22:23:13 <julianleviston> jle`: maybe.
22:23:23 <jle`> every runtime error that will only manifest after 3 months running in production that you can move to a compile time error is a win for everyone
22:23:37 <julianleviston> jle`: definitely from a consistency point of view.
22:24:12 <jle`> every runtime error i can turn into a compile time/type error is a trade i'd always take
22:24:54 <YamiGucci> Will learning Haskell first make me better at C, C++ and Java than if I didn't learn it first or will it make me worse?
22:25:04 <jle`> for critical systems it could mean the difference that could cause a nuclear meltdown or a billion dollar loss
22:25:32 <ttt_fff> jle`: your nightmares must involved Rice's lemma
22:25:41 <julianleviston> YamiGucci: You’ll understand more of what’s going on if you learn Haskell.
22:25:43 <jle`> for non-critical systems it could mean the difference between a headache hunting for specific causes for a bug at runtime vs just seeing the bug immediately manifested at compile time
22:26:16 <jle`> sometimes a bug just happens if this certain scenario happens in this rare way that is sometimes reproducable but sometimes not and ... >_>
22:26:31 <aidanh> I'd really like it if Haskell had some sort of value inference as well; the compiler being able to prove that an index can exceed a list's length in some circumstances could be useful
22:26:41 <jle`> i'm never going back to runtime errors if i have the chance to move on forever
22:26:48 <jle`> aidanh: there are some libraries/plugins for that, actually :3
22:26:50 <julianleviston> value constraints?
22:26:55 <jle`> oh
22:26:58 <jle`> i didn't read the entire sentence
22:27:20 <jle`> well if your list type has the length encoded in the type, then haskell can do that
22:27:38 <jle`> the compiler only knows what the type has
22:27:47 <jle`> for anything more you need to go into dependent typing with agda, idris, etc. :)
22:28:11 <aidanh> jle`, as in a ([], Int) type?
22:28:45 <jle`> aidanh: as in a `Vector 4 a` vs. `Vector 5 a` type
22:28:54 <jle`> or more precisely like
22:28:56 <jle`> data V2 = V2 a a
22:29:02 <jle`> data V3 a = V3 a a a
22:29:02 <roboguy_> aidanh: that's a standard thing in dependently typed languages like agda, idris and coq and you can convince Haskell to do it to a degree
22:29:06 <jle`> different types for different lengths
22:29:14 <jle`> different length lists would literally have different types
22:29:41 <aidanh> jle`, ahh, yeah, a little ugly though
22:29:42 <jle`> there are a couple ways to do this in a nice way for arbitrary sizes in haskell
22:29:54 <jle`> yeah, that was a sort of clear example using standard haskell
22:30:01 <aidanh> roboguy_, I'll have to check those out then
22:30:03 <jle`> but you can have a type like `Vector 4 a` where you know it only has 4 a's
22:30:10 <YamiGucci> So, I'll have a better idea of low-level stuff and type stuff if I learn Haskell first, rather than go straight to C?
22:30:11 <jle`> `Vector 10 a` has exactly 10 a's
22:30:17 <roboguy_> aidanh: idris is probably the most similar to Haskell
22:30:27 <aidanh> Makes sense
22:30:32 <julianleviston> YamiGucci: what do you mean by low level?
22:30:45 <jle`> YamiGucci: types are sort of the opposite of low-level
22:31:24 <YamiGucci> Like memory, buffer overflow, and stuff like that
22:31:42 <Axman6> YamiGucci: C will give you a better idea of how hardware works - it's much lower level than Haskell and as such as limited abstraction abaility. Haskell will allow you to get to the essence of programming without having to worry about hardware
22:31:53 <julianleviston> YamiGucci: that’s the problem, unless you’re going to do systems programming, you won’t be actually doing low level stuff anymore anyway...
22:32:29 <jle`> you can also work with low level things in haskell too, but C is going to sort of force you to have to worry about it in-your-face without any way out
22:32:45 <jle`> if that's what you want, i guess
22:32:52 <jle`> if you want to learn how to program then that's a different story :)
22:33:05 <lispy> aidanh: liquid haskell can do that
22:33:26 <lispy> aidanh: It's basically model checking + Haskell http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
22:33:40 <roboguy_> some day I need to look at liquid haskell. It's the refinement type thing, right?
22:33:46 <lispy> yeah
22:33:51 <lispy> It's pretty magical when it works
22:33:57 <td123> does anyone know if there is a haskell library that will allow me to write a foreign data wrapper in postgresql?
22:34:03 <YamiGucci> So, all of this time while I've been dabbling with the BASICS of C and running into type errors and other complicated low-level matters, I could have been using Haskell and improving my algorithm/problem solving skills and churning out cool stuff by now?
22:34:12 <roboguy_> I've never understood the relationship between dependent types and refinement types
22:34:47 <julianleviston> YamiGucci: you still have to deal with types.
22:34:56 <jle`> YamiGucci: it's difficult to make blanket statements that apply in every situation here
22:35:12 <lispy> roboguy_: refinement types let you add predicates on the types. dependent types are foundationally different
22:35:20 <julianleviston> YamiGucci: in fact, in Haskell you have to deal with types all the time. 
22:35:35 <redcoat> Is all this refinement stuff type erased?
22:35:45 <roboguy_> lispy: does one subsume the other, are they orthogonal or is there some overlap?
22:35:59 <YamiGucci> So, I should just stick with compiler error-filled C?
22:36:09 <jle`> if you want to do cool stuff immediately and jump on with lots of resources for help and get instant gratification then python or ruby might be a good choice if you're just getting started
22:36:19 <lispy> roboguy_: I'm sure there is overlap but I don't know if dependent types totally subsumes refinement types (and I'm not even sure about the other direction)
22:36:21 <athan> roboguy_: Dependent types are integrated into the syntax / grammar of the system
22:36:30 <athan> like the calculus of constructions, for instance
22:36:31 <roboguy_> YamiGucci: I would personally suggest Haskell. The error messages can be more useful, among other reasons
22:36:31 <jle`> YamiGucci: type errors in haskell aren't really bad because they're type errors; they're usually a sign that your program doesn't really make sense at all
22:36:36 <jle`> like you're trying to weigh how much a mile is
22:36:39 <jle`> like, why?
22:36:41 <athan> wait derp
22:36:43 <fosterite> roboguy_: you can do almost anything with dependent types but I think refinement types can be thrown into solvers more easily
22:36:51 <athan> my bad, I read refinement types as liquid types x_x
22:36:52 <roboguy_> athan: refinement types are not?
22:37:04 <julianleviston> YamiGucci: yeah, it all comes down to what you want to do.
22:37:05 <athan> roboguy_: liquid types aren't, I'm not sure about refinement
22:37:09 <jle`> type errors in haskell are a sign that you need to step back and make sure that what you are talking about even makes sense
22:37:11 <roboguy_> fosterite: hmm, interesting
22:37:22 <roboguy_> that would make sense, from the bits and pieces I know
22:37:23 <athan> From what I know, liquid types are a boolean wrapper around normal system Fw
22:37:33 <athan> and uses a constraint solver to "prove" the lemmas
22:37:34 <YamiGucci> I feel like all of this correcting compiler errors, weird mid-level syntax and memory management stuff is preventing me from making useful programs and improving my programming algorithm skills
22:37:36 <jle`> do you want to double a number, and you're using &&, length, etc. to double it?
22:37:45 <roboguy_> I saw a talk today that reminded me of refinement types a bit
22:37:59 <roboguy_> It was on constraining polynomial functors with regular expressions
22:37:59 <lispy> YamiGucci: you're probably right
22:38:02 <jle`> saying "why doesn't [1,2,3] * 5 give me 5 doubled?" is a type error is a bit of a red herring
22:38:08 <athan> dependent types are harder to write proofs in, though
22:38:08 <Axman6> YamiGucci: you might enjoy: https://www.google.com.au/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CB4QFjAAahUKEwjZtpuvueHGAhXDGKYKHUk1CCk&url=https%3A%2F%2Fwww.cs.kent.ac.uk%2Fpeople%2Fstaff%2Fdat%2Fmiranda%2Fwhyfp90.pdf&ei=oZSoVZniBMOxmAXJ6qDIAg&usg=AFQjCNHb88MH2uDvwjCn94-VGVe6GjAM5Q&sig2=KuO-viFhnsNhymro91fDBQ&bvm=bv.98197061,d.dGY
22:38:11 <roboguy_> (polynomial functors = adts I think)
22:38:13 <Axman6> argh
22:38:14 <athan> (from my experience)
22:38:16 <Axman6> screw you google
22:38:20 <Axman6> https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
22:38:30 <jle`> i think realistically, both haskell and C take a discipline to get off the ground
22:38:53 <julianleviston> yeah
22:38:58 <julianleviston> ruby takes nothing to get off the ground
22:39:00 <jle`> but maybe haskell is more natural for someone coming new to programming, and the things you gain are more generally applicable to thinking about programming than with C
22:39:08 <athan> julianleviston: Ruby digs
22:39:09 <julianleviston> on the other hand… you end up in the tarpit real quick
22:39:10 <roboguy_> YamiGucci: the thing is, a lot of Haskell programming is correcting compile errors. That's a good thing though. It works in a very different way from C compile errors, due to the type system being significantly stronger
22:39:13 <jle`> python, ruby, etc. take pretty much no discpline to get off the ground, but you're limited to how much real programming you can do
22:39:32 <roboguy_> YamiGucci: a compiler error is a runtime error that you don't have to track down
22:39:43 <athan> precision is awesome
22:39:44 <roboguy_> that's something a lot of people beginning programming don't realize for a while
22:39:54 <julianleviston> I personally think Clojure is a pretty good compromise
22:40:02 <YamiGucci> I just feel C isn't making me a better programmer, and is just forcing me to understand low-level stuff that's taking way too long to grasp
22:40:02 <fosterite> roboguy_: link to that talk? I've read the blog post about it
22:40:11 <jle`> YamiGucci: fair :)
22:40:14 <roboguy_> fosterite: I don't know if it was recorded
22:40:18 <julianleviston> If you pick java or C you get lots of programming gigs. 
22:40:19 <athan> YamiGucci: I've heard D is nice :)
22:40:20 <jle`> you'll get a lot of different opinions on this
22:40:22 <bz> how to write a string literal containing two characters: '\xbd' : '5' : []
22:40:27 <bz> this is non-trivial
22:40:39 <bz> > length "\xbd5"
22:40:41 <lambdabot>  1
22:40:42 <bz> gg
22:40:45 <roboguy_> fosterite: I think I know where the paper and slides are though, let's see
22:41:09 <athan> > "\xbd" ++ "5"
22:41:10 <lambdabot>  "\189\&5"
22:41:11 <athan> :D
22:41:21 <roboguy_> fosterite: oh, maybe just the paper: http://dept.cs.williams.edu/~byorgey/pub/type-matrices.pdf
22:41:24 <jle`> > length "\189\&5"
22:41:26 <lambdabot>  2
22:41:33 <jle`> > '\xbd':'5':[]
22:41:34 <lambdabot>  "\189\&5"
22:41:39 <jle`> neat
22:41:43 <bz> how to report a string literal bug
22:41:45 <athan> ahh, \& is the delimiter?
22:41:57 <jle`> it's not quite a string literal bug, becuase '\xbd5' is actually a character
22:42:03 <roboguy_> fosterite: it was very cool. Connected algebraic datatypes, linear algebra, ring theory, language/automata theory and calculus
22:42:06 <jle`> > ord '\xbd5'
22:42:07 <lambdabot>  3029
22:42:12 <athan> > "\189"
22:42:13 <lambdabot>  "\189"
22:42:19 <athan> > "\189\&"
22:42:20 <lambdabot>  "\189"
22:42:29 <greymalkin> How? (STM a -> STM a -> STM a) -> StateT s STM a -> StateT s STM a -> StateT s STM a
22:42:30 <bz> of course i know that, but why are we required to give \& to signify the end of a hex escape
22:42:33 <roboguy_> *It connected
22:42:36 <julianleviston> YamiGucci:  the trouble with picking Haskell is that you probably won’t get a good appreciation of how terrible other langs are, so if you have to use one in the future, it’ll be so painful you might cry.
22:42:38 <bz> when every other language doesn't require it
22:42:38 <lispy> roboguy_: whoa, neat paper. I haven't seen this before. Many thanks!
22:42:40 <lispy> roboguy_++
22:42:44 <jle`> bz: what alternative is there?
22:43:01 <jle`> what is your ideal behavior here
22:43:10 <roboguy_> lispy: hopefully someone recorded one of the times he gave the talk. We'll have to see if it pops up on youtube sometime
22:43:18 <julianleviston> YamiGucci: on the other hand, some things that are very very easily done in other programming languages are not possible in Haksell…
22:43:26 <bz> jle`: python does pretty well with \unnnn
22:43:30 <fosterite> roboguy_: cool, didn't know byorgey did this too, I was thinking of sigfpe's blog post from forever ago
22:43:40 <fosterite> I reread it recently
22:43:59 <julianleviston> YamiGucci: but when it comes down to the real world, you probably shouldn’t be doing that stuff anyway, even though everyone does… because it makes things harder to reason about. (Things like redefining variable values)
22:44:04 <roboguy_> fosterite: he worked with Dan Piponi on it and coauthored the paper with him actually, so that fits
22:44:08 <jle`> julianleviston: like what?
22:44:32 <julianleviston> jle`: mutating variables, in particular.
22:44:43 <jle`> haskell can state algorithms involving changing variables
22:44:44 <greymalkin> Ugh... nevermind.
22:44:50 <jle`> a lot of algorithms are actually more elegantly stated in such a way
22:44:53 <wyager> greenskeleton: Are you asking how to do it?
22:45:00 <wyager> Sorry, greymalkin 
22:45:08 <wyager> not greenskeleton 
22:45:18 <roboguy_> the part where he talks about how you can interpret the state transition matrix in the context of different rings to get different (and interesting/useful) results... that was pretty incredible to me
22:45:21 <fosterite> roboguy_: cool. thanks for the link, looking forward to it
22:45:29 <julianleviston> jle`: I’m not bashing haskell - I prefer Haskell. But you can’t say let x = x + 1 for example, right?
22:45:39 <greymalkin> I was, but I just got it (after fighting for 2+ hours with it)
22:45:41 <roboguy_> julianleviston: well, you can *say* it
22:45:46 <jle`> julianleviston: you can sequence events that increment a variable named "x"
22:45:48 <bz> ugh, broken aes impl
22:45:57 <wyager> greymalkin:  Does `liftM2` work?
22:46:03 <roboguy_> julianleviston: and if you use lazy numbers, you can even use it for stuff
22:46:03 <julianleviston> jle`: You’re missing my point, aren’t you...
22:46:22 <eds> jle`: Expr (Int -> Int -> Int)? Should I wrap Expr Int -> Expr Int -> Expr Int as Expr (Int -> Int -> Int) under data Expr? And then create a rando Instance of it? Could there be a other way to implement foldl?
22:46:22 <YamiGucci> Like, I want to make something that will give me fulfillment but also want to learn about low-level stuff eventually; that's why I was wondering if Haskell would better prepare me for this difficult low-level stuff I'm *trying* to grasp in C/C++
22:46:36 <jle`> when you're talking about mutating variables in other languages, you usually are talking about specifying algorithms that involve mutating variables
22:46:39 <Axman6> julianleviston: but x = x + 1 is clearly false, why would you want to say it?
22:46:40 <jle`> haskell does have the same thing
22:46:56 <jle`> but "let x = x + 1" is not really a variable, so it's not really the same thing
22:46:57 <rcyr> YamiGucci: You'll become a king at template metaprogramming (C++)
22:46:58 <greymalkin> No.  It's (StateT $ \state -> funcFromAbove (runStateT left state) (runStateT right state))
22:47:08 <greymalkin> :t StateT $ \state -> funcFromAbove (runStateT left state) (runStateT right state)
22:47:09 <lambdabot> Not in scope: ‘funcFromAbove’
22:47:21 <jle`> eds: you have to find a way to represent functions using your ADT
22:47:23 <julianleviston> Axman6  Oh, I just thought it was infinite? ;-)
22:47:29 <wyager> :t liftM2
22:47:30 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:47:34 <jle`> eds: usually people do it using a lambda construct
22:47:36 <greymalkin> :t \f -> StateT $ \state -> f (runStateT left state) (runStateT right state)
22:47:37 <lambdabot>     Couldn't match expected type ‘StateT s m1 a2’
22:47:37 <lambdabot>                 with actual type ‘a0 b0 c0 -> a0 (Either b0 d0) (Either c0 d0)’
22:47:37 <lambdabot>     Relevant bindings include
22:47:47 <Axman6> julianleviston: right, it has no value, in our case it will run forever
22:47:48 <fosterite> YamiGucci: if you want enlightenment about the "foundations of computation" haskell will help you read papers
22:48:09 <Cale> x is really a variable in x = x + 1, it's just not a variable which is the name of a mutable cell
22:48:12 <fosterite> if you want enlightenment about the foundations of *computers* it will not be as helpful
22:48:23 <jle`> julianleviston: haskell can easily express mutating "variables", but let x = x + 1, the word "variable" there is nothing like the word "variable" in other languages
22:48:37 <jle`> so it's really a bit of an unfortunate accident of language
22:48:37 <julianleviston> YamiGucci: the trouble with you “low level” question is it’s hypothetical
22:48:38 <Axman6> but mathematically x = x + 1 makes no sense, and in Haskell, = means "is", not "assign" - things on the left are equal to things on the right
22:48:46 <julianleviston> jle`: you’ve missed my point.
22:49:03 <eds> lamda construct, like this eval (FoldL op n ls) = foldl (\ x y -> eval op x y) (eval n) (eval ls)
22:49:05 <jle`> other languages can express algorithms with mutating "boxes"...and so can haskell, just as easily
22:49:07 <julianleviston> Axman6:  yes, obviously.
22:49:11 <jle`> what would you say your point is?
22:49:15 <greymalkin> wyager: liftM2 makes :: StateT s STM (STM a) -> StateT s STM (STM a) -- etc.
22:49:33 <julianleviston> Axman6:  but “let x = 5” in maths means x now stands for 5. and “let x = x + 1” has a meaning in math, but it can’t be done in Haskell
22:49:44 <julianleviston> jle`: that ^
22:49:49 <Axman6> what is its meaning in maths?
22:49:55 <Cale> It's just that there are not very many numbers for which that equation is true. The only x :: Integer for which x = x + 1 is _|_, and so that's what you get.
22:49:55 <julianleviston> Axman6:  really?
22:50:04 <Axman6> other than x ~= infinity
22:50:11 <jle`> x = x + 1 is an inconsistent system in most frameworks of math
22:50:16 <jle`> if 1 is R
22:50:19 <Cale> _|_ is a solution to the equation
22:50:22 <julianleviston> Axman6:  it’s variable reassignment… it says “let the new value of x be equalt  to the old value plus one”
22:50:35 <Cale> because indeed, _|_ = _|_ + 1
22:50:39 <julianleviston> it’s not an equation. it’s assignment. x <- x + 1
22:50:46 <jle`> julianleviston: ah.  haskell does have that literally.
22:51:00 <zipper> jle`: Hey man. How's it?
22:51:00 <julianleviston> jle`: yes, but you can’t do that. You have to say x’ <- x + 1
22:51:01 <jle`> it can express such an algorithm
22:51:06 <julianleviston> jle`: don’t you?
22:51:12 <jle`> well, the syntax is different
22:51:25 <jle`> but syntax is different for every language
22:51:37 <Axman6> julianleviston: maths has no idea of variable assignment, particularly how you're using it
22:51:40 <Cale> You can say  do v <- readIORef x; writeIORef x (v + 1)
22:51:40 <jle`> you can have a mutable box called "x", and then increment it
22:51:46 <julianleviston> jle`: I’m not sure if you’re just being difficult for the sake of it. You can’t reassign variables in Haskell.
22:51:52 <Axman6> "variables" are just names for expressions
22:52:01 <Cale> You can reassign the values of IORefs
22:52:03 <jle`> julianleviston: there's a confusion here.  "variables" in haskell are very different than "variables" in other languages
22:52:05 <roboguy_> julianleviston: ... yes you can. IORefs and STRefs (and more)
22:52:18 <jle`> if you're talking about variables as "boxes where you can reassign values and sequence reassignments", then yes
22:52:20 <jle`> you can
22:52:23 <julianleviston> jle`: mathematical labels for values. You can’t redefine them once they’re defined. 
22:52:33 <jle`> just as easily as you can do them with other languages
22:52:35 <aidanh> jle`, I was under the impression that variables in Haskell are in fact constants
22:52:47 <redcoat> Oh good, a fight.
22:52:47 <aidanh> I.e. not variable at all
22:52:54 <Cale> But yeah, even if x happened to be an IORef, you wouldn't be able to change which IORef it happened to be
22:53:06 <Axman6> you can do horribles things like shadowing names in Haskell to give values new names
22:53:09 <julianleviston> jle`: I don’t think you can do this. In math you can say let x = 5, then do some stuff, then you can say “let x = 10” and that provides you with a new context where x has a new value.
22:53:17 <jle`> julianleviston: you can do that in haskell
22:53:19 <Cale> There's no implicit layer of mutable cells going on with variables, they're directly names for values.
22:53:22 <jle`> just as easily as you can in other languages
22:53:31 <julianleviston> jle`: I can’t. Maybe you can.
22:53:36 <Axman6> do x <- foo; x <- x + 1 (x on left and right are different x's)
22:53:38 <jle`> but the syntax is different, because you're not dealing with "definitions", you're dealing with "mtuable references"
22:53:41 <Cale> So if you want a mutable cell, you have to actually make one.
22:53:45 <jle`> which is what you are really talking about
22:53:50 <jle`> Cale just showed an example
22:54:04 <aidanh> julianleviston, that sounds more like the state monad in Haskell
22:54:16 <jle`> the syntax is different than "let" syntax, because let syntax is for *definitions*, and your "do some stuff and edit some stuff" is for "mutable boxes"
22:54:16 <Cale> In GHCi, you can :m + Data.IORef
22:54:25 <Cale> and then try something like  x <- newIORef 0
22:54:27 <jle`> but both are supported in haskell
22:54:41 <Cale> and  v <- readIORef  should get you v = 0
22:54:47 <jle`> with mutable boxes/references, you really can do thigns like "set x to 10...then do some stuff...increment x...do some stuff...here's x at the end"
22:54:51 <Cale> but if you do something like writeIORef x 5
22:54:56 <julianleviston> jle`: creating a file with redefinitions doesn’t work for me. Maybe you’ve got a different version of haskell than me
22:54:58 <Cale> and then v <- readIORef will get you v = 5
22:55:04 <jle`> julianleviston: the syntax is different
22:55:24 <Cale> julianleviston: You can't redefine things which have been defined, but there exist mutable cells
22:55:24 <jle`> let syntax is *definitions*.  there is different syntax for sequencing mutations of mutable references
22:55:34 <julianleviston> jle`: mine complains about Multiple declarations of ‘x’
22:55:38 <Cale> julianleviston: and you can update them
22:55:46 <jle`> like i said, let syntax is for *definitions*
22:55:48 <Cale> julianleviston: Try what I asked you to try :)
22:55:49 <Axman6> julianleviston: perhaps yopu could try listening when people tell you how to do the things you claiming can't be done
22:55:51 <julianleviston> jle`: I’m not sequencing mutations. I’m reusing the same name.
22:56:05 <julianleviston> Cale: um… no.
22:56:08 <jle`> when you program in imperative languages, you're sequencing mutations
22:56:16 <jle`> that's what the entire language *is*, denotatively
22:56:26 <Cale> julianleviston: Why not? :)
22:56:33 <jle`> "set x to 10, do stuff, increment x, do some more stuff...what is x at the end?"
22:56:36 <jle`> you're stating a sequence of mutations
22:56:42 <julianleviston> Cale: because there’s no point - I know it’ll do what it’ll do.
22:56:54 <Cale> julianleviston: All right then :)
22:57:02 <julianleviston> jle`: yeah, but that’s not how people tend to reason about them, is it?
22:57:06 <roboguy_> > runST $ do { a <- newSTRef 3 ; modifySTRef a (+5) ; readSTRef a } -- julianleviston
22:57:08 <lambdabot>  8
22:57:09 <Cale> julianleviston: The point is, if you want x to be a name for a cell whose value can be updated, you can have that
22:57:19 <jle`> julianleviston: a subroutine is a sequence of mutations
22:57:26 <Cale> It's just not going to happen automatically for every variable.
22:57:29 <jle`> int main() { ... } is a sequence of mutations
22:57:31 <julianleviston> jle`: do you really not understand what I’m trying to say?
22:57:50 <ttt_fff> I really like #haskell
22:57:59 <jle`> you're saying that you can't rename definitions in haskell
22:58:01 <ttt_fff> I wish I could have a brain implant with lte that I can use it to query #haskell on demand
22:58:05 <jle`> but you don't rename definitions in imperative languages
22:58:08 <julianleviston> jle`: yes, because of the concept of time
22:58:16 <jle`> you mutate things
22:58:19 <jle`> in a sequence of actions
22:58:19 <Axman6> julianleviston: there is no time when executing pure functions, so definitions of things can be in any order. it's only when you explicitly sequence things that an order can be derived, by using say IO
22:58:22 <julianleviston> jle`: becuase without using a module, there is no ability to define a new context.
22:58:36 <julianleviston> Axman6: I understand :) lol
22:58:48 <aidanh> There are plenty of ways to define a new context
22:58:53 <jle`> what you stated about letting x be 10, doing stuff with x, etc. etc., what is x at the end?
22:58:57 <jle`> it can be done in haskell
22:59:02 <jle`> but just not with "let" syntax
22:59:12 <jle`> but of course let syntax can't do everything...
22:59:20 <jle`> it's just one syntactical construct...
22:59:24 <jle`> with a specific purpose
22:59:33 <aidanh> This makes about as much sense as complaining that you can't multiply numbers in C with the + operator
22:59:42 <jle`> "set this number to 10, then do stuff with it, then what's it at the end?" is another construct that is equally easy to use
22:59:44 <jle`> equally valid
22:59:49 <jle`> and exactly the same in meaning
22:59:58 <redcoat> julianleviston: Haskell is referentially transparent. That is not to be sacrificed. If you know what a monad is, you know then that imperative languages and monadic expressions are equivalent.
23:00:01 <jle`> but you just aren't going to use the letters "l" "e" "t"
23:00:17 <YamiGucci> So, if I learn Haskell first, will learning a mid-level/low-level language like C, C++ and Java be easier?
23:00:21 <julianleviston> aidanh:  oh come on… I was attempting to explain to a new guy how certain things are more difficult in haskell if not impossible than others compared to imperative languages. 
23:00:38 <jle`> YamiGucci: probably not...C and C++ and Java would most likely make learning haskell harder, heh.  most people say so
23:00:39 <julianleviston> redcoat: yes, obviously.
23:00:42 <roboguy_> julianleviston: modification isn't impossible
23:01:06 <Axman6> julianleviston: so you werte trying to lie to a friend? =)
23:01:15 <Axman6> because what you're saying is simply untrue
23:01:19 <jle`> julianleviston: the thing you said about changing variables, etc., is doable in haskell in the same way it's doable in any imperative language... you just don't use the keyword "let" to define your variable
23:01:33 <julianleviston> roboguy_: the nature of the standard execution context in haskell makes modificaton not make sense, though… which is why GHC will complain if you try to compile a redeff’d var name
23:01:40 <aidanh> julianleviston, and he/she apparently disagrees; I'd disagree too because these things are not hard, just different
23:01:43 <fosterite> YamiGucci: it will make it more frustrating. Hard to say if it will be easier
23:02:15 <julianleviston> aidanh: that is completely subjective.
23:02:30 <jle`> you can state the same deal with "let x = 10, then do this with x, increase it, etc.." in haskell too, without nothing more special than in an imperative language
23:02:37 <jle`> but you just don't use the keyword "let"
23:02:43 <roboguy_> julianleviston: but it is completely possible
23:02:51 <julianleviston> aidanh: to the average person who has algebra, explaining variables, definitions and assignment is not particularly tricky.
23:02:54 <jle`> if your compiler is erroring, then it's probably because you're using the wrong keyword and type do to do what you want to do
23:02:59 <Kryzhovnik> MMMOOO!
23:03:01 <aidanh> julianleviston, then why are you arguing over something subjective?
23:03:16 <Axman6> "I can't do <something> with the exact syntax I expect" is completely different from "I can't do <something>" but you seem to think they're equivalent
23:03:22 <julianleviston> aidanh: because variable assignment and definition isn’t subjective - it’s easy for everyone.
23:03:23 <redcoat> I agree with Kryzhovnik 
23:03:30 <jle`> it's like saying "you can't add in haskell", and then trying to compile "2 &^*#&$ 4" and getting an error
23:03:35 <Kryzhovnik> =)))
23:03:41 <jle`> > 2 &^*$#&$ 5
23:03:42 <lambdabot>  Not in scope: ‘&^*$#&$’
23:03:54 <quchen2> > let x = 1 in (let x = 2 in x)
23:03:55 <lambdabot>  2
23:03:57 <aidanh> julianleviston, but in algebra, variables are constants and assignment is actually definition; pretty much identical to the Haskell paradigm
23:04:15 <julianleviston> aidanh:  exactly.
23:04:17 <ttt_fff> checks to see if in #APL / #Perl
23:04:18 <jle`> haskell can define mutable references and assign them and change them over a series of actions
23:04:26 <julianleviston> jle`: yes, I know.
23:04:30 <jle`> which is what you're doing in an imperative language anyway...
23:04:35 <julianleviston> jle`: that doesn’t make that easy, though, does it?
23:04:35 <jle`> there's no functional difference
23:04:39 <jle`> it does make it easy
23:04:50 <jle`> people have just entered a few different ways to do it already
23:04:54 <julianleviston> I respectfully disagree.
23:05:03 <certainty> moin
23:05:06 <jle`> okay, then that's the end :)
23:05:14 <quchen2> x <- readSTRef foo -- not very complicated.
23:05:15 <redcoat> julianleviston: not being able to do assignment is a very minor thing.
23:05:18 <julianleviston> perhaps. 
23:05:39 <julianleviston> redcoat: nevertheless it seems to be a sticking point with imperative folk.
23:05:42 <jle`> if you are going to insist that it's not easy after people showing several simple examples then there isn't really anything more we can say
23:06:05 <Axman6> julianleviston: not ones who put a teensy bit of thought into it
23:06:25 <julianleviston> Axman6:  popularity would tend to disagree with you, I’m thinking.
23:06:33 <Axman6> but sometimes that's too difficult and we might as well all use ruby because you can become an expert in 24h
23:06:37 * ttt_fff gets popcorn and watches #haskell-trolling
23:06:43 <julianleviston> jle`: the execution model is different. I’m not against you here, I love Haskell. 
23:06:46 <roboguy_> julianleviston: where is the popularity?
23:06:46 <redcoat> julianleviston: Having taught programming, even assignment can be hard. People are taught very early on that a useful pattern of doing things is 1) do some work 2) put it aside in a known location 3) go back to 1, with the new context
23:06:47 <julianleviston> hey! I’m not trolling!
23:07:03 <jle`> julianleviston: haskell can give you an environment with the same execution model
23:07:08 <ttt_fff> dude, it tok me 12 months to learn haskell; this is after learning algorithms, c, c++, scheme, clojure
23:07:08 <redcoat> julianleviston: But you can turn any stateful computation into a purely functional one by passing state along in a recursive function call.
23:07:12 <ttt_fff> 24 hours to learn ahskell is ridicilous
23:07:26 <julianleviston> ttt_fff: thank you.
23:07:31 <ttt_fff> the only way to learn haskell in 24 hours .... is to start from a blank state
23:07:35 <ttt_fff> all others langauges set you backwards
23:07:36 <julianleviston> ttt_fff: glad to know i’m not entirely insane.
23:07:42 <jle`> i think it's not controversial that many algorithms and programs are more elegantly stated using mutable references in an environment where things change over time
23:07:42 <ttt_fff> with the possible exception of an erlang/ocaml hybrid
23:07:48 <jle`> haskell gives you exactly that...
23:07:52 <quchen2> If you want to argue C++ against Haskell, mutable variables are not a very good choice. You should instead talk about GC, how you don't write your own allocators, how the operational semantics isn't obvious.
23:07:52 <julianleviston> jle`: I agree with you
23:07:55 <jle`> without much syntactic overhead
23:07:55 <aidanh> ttt_fff, depends on the person; i got the hang of it after a day or two myself
23:08:02 <jle`> and the result looks almost exactly the same
23:08:03 <julianleviston> I’m not arguing anything over haskell
23:08:09 <julianleviston> I prefer haskell
23:08:10 <ttt_fff> aidanh: I'm referring to people with 2-3 digit IQs
23:08:13 <lispy> I'll just leave this here http://norvig.com/21-days.html
23:08:16 <aidanh> Took a while to become reasonably efficient though
23:08:17 <trolling> stop highlighting me
23:08:23 <jle`> what the imperative language does in its default context, haskell can also do exactly in the same context
23:08:36 <redcoat> julianleviston: And I would make the argument that it is only a very short jump from doing stateful computation to doing recursive algorithms. Because both involve something along the lines of "Okay, I have done some of the task, now to do the same task on a simpler-case/accumulation"
23:08:41 <ttt_fff> trolling: lol, when did you pick this nick?
23:08:50 <aidanh> ttt_fff, I'd guess that's pretty much everyone
23:09:04 <lispy> ttt_fff: "monad" would also get you highligted a lot
23:09:07 <trolling> clearly when I had more faith in #haskell
23:09:23 <aidanh> lispy, not as much as 'e'
23:09:36 <quchen2> There's a guy named "so" in here, I think he wins
23:09:38 <jle`> julianleviston: haskell can do exactly the imperative evaluation and execution environment that is *default* for imperative languages.  it's just offered as a lightweight possibility/option in haskell.  so haskell *can* give you mutable variables etc., in the environment that imperative languages offer
23:09:40 <ttt_fff> monad is also already registered
23:09:49 <julianleviston> jle`: Look. I don’t disagree with you.
23:10:07 <jle`> so, those mutatie things in imperative languages are exactly possible in haskell
23:10:11 <jle`> and directly portable
23:10:17 <Axman6> trolling: how long has it been since you were last highlighted? if this is the first time it's come up I'd be pretty happy =)
23:10:21 <jle`> sometimes even as a copy+paste and a find/replace
23:10:34 <ttt_fff> Axman6: stop trolling trolling
23:11:17 <ttt_fff> you konw, I could just take a log of past $haskell logs
23:11:19 <quchen2> jle`: The syntax is slightly more verbose though, and you can't simply write to your variables that were not made mutable from the start.
23:11:21 <ttt_fff> and do some basica statistical analysis
23:11:25 <ttt_fff> to get the most commonly used words
23:11:25 <julianleviston> jle`: there’s no reason to get so pent up. All I was trying to say was that there is a large difference between them, so to a new person it seem difficult. If you can’t see that large difference, then perhaps you’re not the sort of person who finds it difficult. That’s ok! :)
23:11:31 <jle`> +
23:11:34 <aidanh> Does anybody know of any good Haskell CRUD frameworks?
23:11:38 <jle`> oops
23:11:40 <jle`> :)
23:11:58 <julianleviston> adamse: I think Scotty is pretty good, isn’t it?
23:12:00 <ttt_fff> aidanh: not aware of any leranble in 24 hours
23:12:10 <ttt_fff> aidanh: though I like opaleye for db access
23:12:11 <julianleviston> aidanh:  sorry ^
23:12:21 <jle`> julianleviston: yeah :)  but saying "haskell doesn't let you mutate and update variables like imperative languages do" is a bit disingenuous, i'd think?
23:12:28 <Axman6> I wouldn't call Scotty a CRUD framework
23:12:33 <Axman6> it's actually pretty good! :P
23:12:47 <ttt_fff> jle`: why is it disingenuous, it's like saying "oranges does not have the texture of meat that steak does"
23:12:49 <julianleviston> Axman6:  sigh. Ok. Sorry.
23:12:53 <aidanh> ttt_fff, thanks, I'll look those up and give them a whirl
23:12:56 <dolio> I don't see why assignment would be easy if you know algebra. Mutable references are unlike anything in algebra.
23:12:57 <ttt_fff> jle`: or "planes can not float like ships do"
23:13:14 <jle`> ttt_fff: because haskell does let you mutate and update variables like imperative languages do
23:13:19 <ttt_fff> aidanh: opaleye's postgresql only though, so if you hate postgresql, don't use opaleye -- however, in terms of type safety, I thikn opaleye has maximal type safety
23:13:22 <jle`> so it'd be more like saying "ships can not float like boats do"
23:13:46 <ttt_fff> jle`: well, it's more like "a plane that can transform into a ship does not float like boats do"
23:13:54 <Axman6> aidanh: for a web frontend Servant is awesome (takes a bit of learning but it's very awesome once you get it [like all good things])
23:14:03 <jle`> or maybe "those planes that can land on water can't float like boats do" :)
23:14:03 <ttt_fff> "a fighter jet transformer taht can pretend to be a ship does not float like boats do"
23:14:14 <jle`> haskell doesn't pretend to do it, though...
23:14:18 <jle`> it *actually* does it
23:14:35 <jle`> so it's like saying "humans don't eat vegetables like giraffes do".
23:14:39 <julianleviston> jle`: maybe… one of the simplest things you can do in a language is to declare that there’s a value… after that, the next simples tthing is to declare something that can stand in for something else… 
23:14:59 <ttt_fff> "an interglattatic battle cruiser transformer that can sldo double as a ship generally speaking, does not float like a boat does when travelling"
23:15:01 <ttt_fff> happy now
23:15:09 <julianleviston> jle`: in Haskell, one can’t then redefine the value of that declaration. You can do this in various other langauges. This can trip people up. That’s it. The end :) 
23:15:11 <ttt_fff> I should get back to coding
23:15:21 <julianleviston> ttt_fff: same.
23:15:23 <ttt_fff> julianleviston: look into IORef
23:15:33 <ttt_fff> you can define mutable storage apces
23:15:34 <julianleviston> ttt_fff: no! :) haha
23:15:37 <julianleviston> ttt_fff: I’m good. :)
23:15:37 <jle`> julianleviston: you can do that in haskell though
23:15:38 <ttt_fff> that's what IOREf lets you do
23:15:43 <julianleviston> ttt_fff: I don’t want to redefine things :)
23:15:56 <Axman6> julianleviston: why is being able to do that important? It's very easy to argue that doing that is the cause of billions of dollars of lost productivity ;)
23:15:57 <jle`> just with declarations made with a syntax other than "let"
23:15:58 <ttt_fff> you don't ahve toe define; you just define an IORef once, then you do put/get
23:16:05 <julianleviston> Axman6:  I didn’t say it was important.
23:16:14 <julianleviston> Axman6:  I’m just telling you what trips up some people. That’s it.
23:16:19 <ttt_fff> read https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-IORef.html
23:16:25 <ttt_fff> you have readIORef, writeIORef
23:16:27 <ttt_fff> what else do you want?
23:16:30 * ttt_fff teams up with jle`
23:16:36 <julianleviston> ttt_fff: this is n’t something I want lol
23:16:48 <julianleviston> I don’t know why this is such a big things
23:16:50 <julianleviston> thing*
23:16:53 <jle`> maybe the thing that trips up people is "what haskell calls variables are different than what other languages call variables.  haskell has definitions and mutable boxes.  other languages just have mutable boxes.  you can work with mutable boxes in haskell the same way you work with mutable boxes in other languages"
23:17:18 <julianleviston> jle`: of course. That’s just a redefinition of what I said :)
23:17:26 <julianleviston> jle`: we actually agree. 
23:17:29 <aidanh> Axmam6, thanks, yeah ill probably need a web frontend
23:17:44 <benzrf> languages that arent C tend not to have 'boxes' for variables
23:17:50 <benzrf> more like mutable references
23:18:09 <quchen2> What's a box?
23:18:14 <quchen2> In C, especially
23:18:14 <benzrf> or... something
23:18:24 <benzrf> well i mean boxlike behavior
23:18:28 <ttt_fff> jle`: other languages also have define-one-never-change mutable boxes; they're called functions
23:18:46 <benzrf> in C, a variable actually corresponds to a memory location and has 'contents'
23:18:50 <ttt_fff> jle`: I'm pretty sure, without non-portable black magic, you can't refined "int main()" on the fly
23:18:56 <jle`> true :)
23:18:58 <benzrf> so like if you say x = 3; y = x; that second line is a copy
23:19:14 <benzrf> but in, say, python, a variable acts like a pointer
23:19:17 <ttt_fff> in haskell ... on shit, haskell is lazy, and we don't want to talk baout thunks
23:19:55 <quchen2> Haskell is non-strict, not necessarily lazy.
23:19:58 <quchen2> GHC is lazy.
23:20:06 <ttt_fff> damn it, nick lazy is taken tto
23:20:11 <benzrf> things are allocated on the heap, and are not 'contained' in variables, nor does assignment copy the supposed contents of the source var
23:20:31 <ttt_fff> as are nicks "ghc" and "to"
23:40:22 <hunteriam> Am I wrong that functors take any type as an argument?
23:40:27 <hunteriam> It seems like a limitation
23:41:02 <hunteriam> Also it's strange that functors cannot be overloaded, although it certainly makes life easier
23:41:10 <aidanh> Depends on the functor
23:41:11 <Axman6> huh?
23:41:29 <hunteriam> You can only have one Functor for each type
23:41:42 <Axman6> oh right, yes to be a functor it must work for any function a -> b, not a restricted subset
23:42:22 <pavonia> hunteriam: Why would you want several functor instances for the same type?
23:42:43 <Axman6> yeah in most cases the instance is opbvious (and often there's only one law abiding one)
23:42:46 <hunteriam> Well, I like that you can't have them, but it seems like something you should be able to do
23:43:15 <hunteriam> The Functor laws are just composition and Id right?
23:43:18 <fosterite> some new languages behave like DeriveFunctor is always on and always enabled
23:43:21 <Axman6> I can't actually think of any types which there is more than one functor instance that makes any sense
23:43:27 <fosterite> for that very reason
23:43:27 <Axman6> yes
23:43:58 <Axman6> though IIRC, I think that the fmap id = id law gets you everything that fmap f . fmap g = fmap (f . g) does
23:44:12 <Axman6> fosterite: which languages?
23:44:14 <hunteriam> I can't think of anything you'd want to do but technically it seems like something you ought to be able to do
23:44:27 <Axman6> why? =)
23:44:39 <hunteriam> Just cause who knows maybe there's something out there
23:44:55 <Axman6> for Applicative and Monad there are sometimes multiple implementations that make sense
23:45:34 <Axman6> (like the ZipList applicative)
23:45:54 <hunteriam> which kind of cheapens the value of all these structures
23:46:06 <Axman6> I don't see how
23:46:07 <fosterite> Bob Atkey's language for one
23:46:09 <hunteriam> I always thought these things were really boiled down
23:46:15 <hunteriam> But you can't trust them as much as you'd think
23:46:53 <mniip> [09:42:45] <Axman6> I can't actually think of any types which there is more than one functor instance that makes any sense
23:47:03 <fosterite> I believe there's exactly one functor instance for the regular tree types
23:47:06 <mniip> the only law-conforming thing I can think of is varying amounts of strictness
23:47:22 <mniip> fosterite, 1 or 0
23:47:41 <hunteriam> Well you could write more functors they're just not as logical as the ones we use
23:47:50 <fosterite> mniip: which ones have 0?
23:47:55 <rbocquet> fosterite:  (a -> a)
23:48:13 <fosterite> rbocquet: that's not a regular tree type
23:48:56 <Axman6> hmrm: do you have any examples? I would guess that isn't actually the case
23:49:06 <mniip> fosterite, ah you mean without ->
23:49:13 <mniip> yeah there's no source for contravariance then
23:49:18 <hunteriam> So then we want F: ((a->a) -> (a->a)) -> (F (a->a) -> F (a->a))
23:49:20 <hunteriam> Right?
23:50:08 <Axman6> that looks a lot like fmap to me, where a = (a -> a)  and b = (a -> a)
23:50:11 <hunteriam> Or were you thinking the F: a -> (a -> a)
23:50:38 <hunteriam> I think id is a Functor for every type, including ->
23:50:54 <BartAdv> hi, trying to install stack on nixos as described here: https://github.com/commercialhaskell/stack/wiki/Downloads#nixos, got: variable $src or $srcs should point to the source
23:50:55 <hunteriam> Ya that is fmap axman
23:53:34 <quchen2> `id` is a value so it can't be a Functor, and (->) is not a (simple) type so it does not have any values.
23:54:22 <hunteriam> I think you could have an ID Functor
23:54:54 <hunteriam> Although that's probably not saying much
23:55:29 <pavonia> What do you mean by that?
