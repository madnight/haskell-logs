00:00:28 <dramforever> oh you can search for > on ircbrowse
00:00:39 <ski> sum_ : try <http://tunes.org/~nef/logs/haskell/> ?
00:00:40 <dramforever> http://ircbrowse.net/browse/haskell
00:00:47 <dramforever> the obvious search box
00:01:01 <dramforever> except it doesn't work =(
00:01:11 <dramforever> sum_: try grep '>'
00:01:27 <ski> sum_ : also, cut off near ".. It can speed up your learning by a factor of"
00:02:01 <sum_> hmm http://ircbrowse.net/browse/haskell?q=%3E isn‚Äôt working
00:02:09 <dramforever> sum_: so you are trying to learn haskell
00:02:14 <dramforever> right?
00:02:53 <sum_> For simplicity, yes. I‚Äôm trying to learn how to search for people‚Äôs code in the evaluator here so I can read them
00:03:07 <sum_> so I can do it for other languages in other channels as well
00:03:22 <dramforever> sum_: I doubt if you could actually learn haskell by reading them
00:03:37 <sum_> grep ‚Äò>'
00:03:56 <sum_> I just want to be able to search for transcriptions and see
00:07:38 * hackagebot language-javascript 0.5.13.4 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.13.4 (ErikDeCastroLopo)
00:07:38 * hackagebot hjsmin 0.1.4.8 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.4.8 (ErikDeCastroLopo)
00:10:34 <hunteriam> Between the various dependantly typed languages, could anyone say which one seems to have the most momentum/be the most likely to succeed
00:10:47 <hunteriam> I want to learn one, but not if I learn the one that's dying
00:12:47 <erikd> hunteriam: coq is likely to stay around because its used for theorem proving, but is not a good program language. agda is likely to stay around because it is so good for language research. idris is likely to saty around because currently it is the most practical DT language.
00:14:39 <hunteriam> Why is Agda good for language research?
00:15:21 * ski thinks Twelf is interesting
00:17:53 <hunteriam> What is twelf? I'll google it later if you'd rather
00:18:41 <ski> hunteriam : <https://en.wikipedia.org/wiki/Twelf>
00:19:07 <ski> it can be seen as a dependent typed logic programming language
00:21:16 <hunteriam> Man this stuff is so cool
00:21:40 <hunteriam> I don't really know how to help develop it though
00:21:45 <hunteriam> Which I'd love to do
00:26:46 <hunteriam> I don't like the universe pattern in idris
00:27:04 <hunteriam> It feels like a shortcut from solving the problem of actual pattern matching on types
00:27:40 <Ralith> that's not a "problem," it's a thing that's very deliberately disallowed
00:28:54 <Ralith> types don't exist at runtime, so pattern matching on them is nonsensical
00:29:08 <Ralith> and that is as it should be
00:29:17 <ski> (also, distinguishing between isomorphic types is evil)
00:29:45 <Ralith> yes, it's important to maintain parametricity
00:31:00 * ski . o O ( <http://ncatlab.org/nlab/show/evil> )
00:32:51 <hunteriam> I find it strange that types don't exist at runtime but other values do
00:32:54 <hunteriam> I understand why
00:33:11 <hunteriam> But it doesn't seem as consistent as I want it to be
00:33:24 <ski> one could have a type-passing implementation
00:34:14 <hunteriam> Why would that be necessary?
00:34:33 <hunteriam> I don't really understand why pattern matching on types requires types at run time
00:35:34 <ski> how would you implement
00:35:52 <ski>   magic :: (a ::) * -> a -> a
00:35:59 <dramforever> hunteriam: why pattern matching on values requires values at run time?
00:36:00 <ski>   magic Bool b = not b
00:36:07 <ski>   magic _    x = x
00:36:12 <ski> ?
00:37:32 <nomeata> I feel stupid, but wasn‚Äôt there operators that would allow me to write f <?> a <??> b <??> c where f :: a -> b -> c -> m d, a :: m a, b :: m b, c :: m c, and m a Monad
00:37:48 <dramforever> :t <$>
00:37:49 <lambdabot> parse error on input ‚Äò<$>‚Äô
00:37:50 <dramforever> :t <*>
00:37:51 <lambdabot> parse error on input ‚Äò<*>‚Äô
00:38:00 <nomeata> Similar to <$> and <*>, but where the function is a -> b -> c -> m d, not m (a -> b -> c -> d)
00:38:20 <nomeata> And similar to =<<, but set up to consume multiple arguments
00:38:21 <dramforever> what about f =<< a <*> b <*> c
00:38:23 <ski> (one possible implementation of polymorphism is to pass types at run-time. the actual information passed for the type could e.g. be the size of values of that type .. and perhaps more info about the layout chosen for the representation of values of the type .. the Mercury implementation does type-passing, e.g.)
00:39:01 <dramforever> :t (\a b -> Just (a ++ b)) =<< Just "x" <*> Just "y"
00:39:02 <lambdabot>     Couldn't match expected type ‚Äò[a0] -> Maybe [a0]‚Äô
00:39:02 <lambdabot>                 with actual type ‚ÄòMaybe b‚Äô
00:39:02 <lambdabot>     The lambda expression ‚Äò\ a b -> Just (a ++ b)‚Äô has two arguments,
00:39:05 <dramforever> =(
00:39:06 <nomeata> :t (\f a b c -> f =<< a <*> b <*> c)
00:39:07 <Hijiri> join (f <$> a <*> b <*> c) ?
00:39:07 <lambdabot> Monad m => (a -> m b) -> m (a2 -> a1 -> a) -> m a2 -> m a1 -> m b
00:39:27 <dramforever> :t \f a b -> f =<< (a <*> b)
00:39:28 <lambdabot> Monad m => (a -> m b) -> m (a1 -> a) -> m a1 -> m b
00:39:29 <Hijiri> :t \f a b c join (f <$> a <*> b <*> c)
00:39:30 <lambdabot> Parse error in pattern: f <$> a
00:39:34 <Hijiri> :t \f a b c -> join (f <$> a <*> b <*> c)
00:39:35 <lambdabot> Monad m => (a3 -> a2 -> a1 -> m a) -> m a3 -> m a2 -> m a1 -> m a
00:39:40 <dramforever> nomeata: precedence problem
00:39:40 <nomeata> Hijiri: great, thanks!
00:40:50 <ski> nomeata : use `<$>',`<*>' and define e.g. `mamb <*>> ma = join (mamb <*> ma)'. and then say `f <$> a <*> b <*>> c'
00:41:48 <nomeata> ski: hmm, I think Hijiri‚Äôs solution is nicer
00:42:10 <Hijiri> ski's generalizes to more arguments
00:42:14 <Hijiri> if you use it a lot
00:42:29 <Hijiri> well, I guess adding join at the beginning is just an extra symbol
00:42:46 <nomeata> Hijiri: yours as well, doesn‚Äôt it? 
00:42:59 <nomeata> :t \f a b c d e f -> join (f <$> a <*> b <*> c <*> d <*> e <*> f)
00:43:00 <lambdabot>     Conflicting definitions for ‚Äòf‚Äô
00:43:00 <lambdabot>     Bound at: <interactive>:1:2
00:43:00 <lambdabot>               <interactive>:1:14
00:43:02 <Hijiri> I guess the main difference is you need parens
00:43:04 <nomeata> eh :-)
00:43:19 <Hijiri> and my version is 6 or 7 or so more characters
00:43:25 <nomeata> or a $ in my case, which now reads "case join $ incredibleLogic <$> context <*> task <*> proof of"
00:43:29 <Hijiri> (if you already have <*>> defined)
00:43:46 <hunteriam> Apologies if this is too much Haskell blah, but what do you guys use Haskell for mostly lately? Work? Personal? Research (what research is there still to be done with Haskell)?
00:43:47 <nomeata> And I disklike defining operators that others then have to look up
00:44:52 <Hijiri> hunteriam: personal projects
00:45:15 <Hijiri> but I don't have a job and I'm only a sophomore, so I don't have too many options
00:45:16 <hunteriam> Hijiri: just random software or something big?
00:45:30 <Hijiri> just random stuff
00:45:30 <hunteriam> Ah I'm about to be a sophomore
00:45:42 <Hijiri> I wrote a genetic algorithm library most recently
00:45:52 <Hijiri> and I wrote a chat bot for some site
00:46:03 <hunteriam> Was it to help learn genetic algorithms? Cause I was considering doing the same thing
00:46:20 <Hijiri> I just wanted to mess around with NEAT
00:46:27 <Hijiri> but there were no libraries implemented
00:46:32 <hunteriam> What is NEAT?
00:46:45 <Hijiri> it's a genetic algorithm for neural networks
00:47:04 <Hijiri> http://www.cs.ucf.edu/~kstanley/neat.html
00:47:20 <hunteriam> Ah, ok. Were you inspired by the sethbling stuff kind of like I was
00:47:24 <Hijiri> yeah
00:47:25 <hunteriam> Just shooting in the dark.
00:47:41 <Hijiri> @hackage neet
00:47:41 <lambdabot> http://hackage.haskell.org/package/neet
00:47:47 <Hijiri> my library's there if you want to look at it
00:48:05 <hunteriam> Well, I never got to completion studying neural networks or started net
00:48:10 <hunteriam> I've basically given up on it
00:48:50 <Hijiri> I still don't know very much about neural networks that are trained with gradients and things
00:49:03 <hunteriam> Have you seen the coursers course?
00:49:21 <hunteriam> I got part ways into it, it seems like that would be on its menu
00:49:46 <Hijiri> I got partway into it too, but then I got busy with school
00:57:35 * hackagebot cryptonite 0.6 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.6 (VincentHanquez)
00:57:37 * hackagebot sync-mht 0.2.1.1 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.2.1.1 (emink)
01:07:28 <R__> guys, is there any website to train haskell skills beside 99 haskell problem, projecteuler, hacker rank, online judge?? 
01:09:04 <Rizy> guys, is there any website to train haskell skills beside 99 haskell problem, projecteuler, hacker rank, online judge?? 
01:09:09 <Hafydd> GitHub
01:09:41 <dramforever> Rizy: train?
01:09:48 <Taneb> Rizy, I quite like http://rosalind.info/
01:10:02 <Rizy> i mean improving
01:10:35 <ZettaBlade> Have you done the bitemyapp stuff?
01:10:48 <indiagreen> Rizy: codewars.com
01:11:02 <ZettaBlade> Or do you know the language well and just want more challenges?
01:11:36 <Rizy> just know a little bit haskell and want to improve coding in haskell
01:11:42 <Rizy> thanks indiagreen 
01:12:20 <ZettaBlade> https://github.com/bitemyapp/learnhaskell
01:12:35 <ZettaBlade> Good guide on getting proficient with the language
01:12:39 <dramforever> indiagreen: wow that's pretty interesting
01:12:49 <Rizy> thanks ZettaBlade 
01:13:04 <ZettaBlade> Didn't know codewars had haskell
01:15:55 <adarqui> i love haskell so much
01:16:29 <ZettaBlade> Yea, it's a fun language
01:22:36 * hackagebot kraken 0.0.1 - Kraken.io API client  https://hackage.haskell.org/package/kraken-0.0.1 (wereHamster)
01:25:55 <ttt_ff> contrary to what I thought, having a fewer # of *.hs files (that are each lager) reduces the "cabal build" time
01:25:59 <ttt_ff> I suspect this is due to less linking
01:27:07 <dcoutts> ttt_ff: you know to minimise that time while hacking, use cabal configure -O0
01:27:11 <dcoutts> or just use cabal repl
01:27:16 <ttt_ff> al, I already have "-O0"
01:27:18 <indiagreen> ttt_ff: you're... you're not even using that evil regex
01:27:20 <ttt_ff> and I'm using "runghc" 
01:27:22 <dcoutts> ok
01:27:25 <indiagreen> you promised 3 letters on each side
01:27:32 <indiagreen> c'mon
01:27:51 <ttt_ff> indiagreen: paying this much attention, you must have a crush on me
01:28:02 <dcoutts> ttt_ff: cabal repl / ghci is even quicker than runghc for rebuilds as it only has to recompile the ones that changed
01:28:20 <ttt_fff> I_love_ttt_fff ++
01:28:32 <ttt_fff> dcoutts: hmm, how should I use cabal repl / ghci ? I don't know how ot use this
01:28:42 <ttt_fff> dcoutts: is there a decent tutorial I can use?
01:28:51 <ttt_fff> the nice thing about "runghc" is that from within vim, I Just hit ":make"
01:29:02 <ttt_fff> if compile fals, I get to the failing line, ir it suceeds, I see the output
01:29:36 <dcoutts> ttt_fff: you can use cabal repl much like you would use cabal build, but instead of building + linking it launches you into a ghci session (with all the right env for your project)
01:29:45 <adarqui> cabal repl is a huge time saver
01:30:08 <ttt_fff> dcoutts , adarqui: how does recompile work inside of cabal repl ?
01:30:14 <dcoutts> :r
01:30:22 <dcoutts> it's just ghci
01:30:29 <ttt_fff> shit, that worked
01:30:30 <ttt_fff> very fast
01:30:46 <ttt_fff> yeah, it's faster than runghc
01:31:17 <ttt_fff> I_love_ttt_fff: if you really loved me, you would have told me about cabal repl much earlier
01:31:20 <adarqui> also helps you to focus on smaller functions, in my experience
01:31:33 <ttt_fff> hmm, is there anyway to have an existing cabal repl session, then have ":make" from vim send ":r" to the cabal repl ?
01:31:50 <ttt_fff> adarqui: what editor do you use?
01:32:02 <adarqui> dno but checkout haskell-vim-now .. haskell vim ide
01:32:03 <adarqui> i use vim
01:32:05 <adarqui> ;f
01:32:22 <ttt_fff> I also use vim
01:32:24 <adarqui> nice
01:32:54 <ttt_fff> adarqui: haskell-vim-now looks amazing
01:33:03 <adarqui> really checkout haskell-vim-now, it's another huge time saver.. already has some shorthands for sending build/make/rel into a tmux pane or something
01:33:06 <adarqui> but i never use it
01:33:07 <adarqui> ya it's really solid
01:33:51 <Alas> Hello, #haskell. What is your recommended way of installing Haskell on OS X and Linux? Is installing just the ghc enough?
01:33:57 <adarqui> i just use tmux and have my panes and :r real fast.. or if i'm compiling stuff i'll just fire up a quick inotify-watch script to rebuild things when i make a source modification
01:34:29 <dramforever> Alas: also install cabal
01:34:45 <adarqui> alas, for osx i built it using the haskell-platform package on haskell.org: https://www.haskell.org/platform/mac.html
01:35:04 <adarqui> seems to be the preferred method, not sure though
01:35:21 <dramforever> download the cabal-install tool here https://www.haskell.org/cabal/download.html
01:35:30 <Alas> adarqui: What difference does it make as opposed to installing ghc + cabal?
01:35:31 <dramforever> and use the bootstrap.hs
01:35:43 <dramforever> you don't need to get cabal separately
01:36:13 <Alas> alright thanks
01:36:29 <I_love_ttt_fff> ttt_fff: I understand if you feel hurt and betrayed now, but please believe me that I would've absolutely told you about cabal repl if it had occurred to me (and it hadn't because I don't use cabal repl manually ‚Äì Emacs's haskell-mode handles stuff for me)
01:36:49 <ttt_fff> adarqui: I also use tmux; I have two panes, C-a l and C-a h to go right/left pane; how do you use inotify to rebuild on source modication?
01:36:50 <adarqui> lol
01:37:36 <adarqui> something like this ttt_fff: while true; do (inotifywait -r ./src ./test --exclude "swp" -e modify; cabal test); done
01:38:28 <enetsee> Alas: for OS X, https://ghcformacosx.github.io/
01:39:53 <ttt_fff> is there a way to (inside of "cabal repl") to define a macro "xxx" = ":r \n T.Main.main \n execute-shell-command 'open output.html'" ?
01:40:40 <adarqui> ya i think so, ~/.ghci and stuff.. i've seen people hookup :h for hoogle etc
01:40:44 <adarqui> but don't know off hand
01:41:05 <dcoutts> ttt_fff: yeah, see the ghc user guide's section on ghci
01:41:07 <adarqui> ok im out, peace!
01:41:41 <dramforever> ghc has :def
01:41:53 <dramforever> :def cmd expr
01:42:35 <ski> ttt_fff : perhaps also see `:main'
01:43:20 <ttt_fff> alright, I need to hook up https://github.com/jpalardy/vim-slime and ghci and then I'm going to take over the world
01:54:30 <ttt_fff> ghci is life changing
01:54:47 <ttt_fff> is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html available as a printable pdf?
01:54:51 <ttt_fff> I just want the ghci section of the ghc manual
01:56:50 <dramforever> ttt_fff: https://downloads.haskell.org/~ghc/latest/docs/users_guide.pdf
01:56:59 <dramforever> and pick out the pages to print
01:57:05 <ttt_fff> dramforever; nice, just found that, the SQL extensions are amazing
01:57:08 <ttt_fff> I want to read the whole manual
01:59:38 <BartAdv> can I add directory as extra-dep in stack.yaml?
02:02:18 <BartAdv> or should I stack install path-to-dep-on-disk in the dependant directory?
02:05:45 <BartAdv> I'm trying to build https://github.com/agrafix/funblog using stack, and it's missing blaze-bootstrap-0.1.0.0 dependency (among few others), so stack is suggesting me to add it to extra-deps. However, simply adding it doesn't work, as blaze-bootstrap has its own dependency problems (upper bound on blaze-html). I cloned the repo, removed upper bound and it
02:05:45 <BartAdv> builds fine, but I don't know how to use this local build with stack now
02:06:46 <dramforever> BartAdv: I'm not an expert on this, but can you stack install a directory?
02:07:06 <dramforever> oh wait we don't need to do that
02:07:14 <BartAdv> I thought so, but such install doesn't give any output
02:07:19 <dramforever> maybe use sandboxes
02:07:55 <dramforever> that should solve the blaze-html upper bound problem
02:08:12 <sydneyhacker> Hello I have some newbie questions about stack (the package management tool)
02:08:22 <sydneyhacker> stack creates a yaml and a cabal file
02:08:28 <sydneyhacker> the yaml file has packages
02:08:43 <sydneyhacker> do I need to specify anything here, or can I just use the cabal file like before
02:08:58 <BartAdv> dramforever: you mean just creating a sandbox and add source there? I tried it, and I finally built the whole thing. However, I now have problems adding another dependency, so I thought I should maybe fallback to stack :)
02:09:08 <BartAdv> (with cabal sandbox --add-source that is)
02:09:18 <dramforever> dunno then
02:09:27 <ttt_fff> for anyone else in my previous shoes: the command youw ant, with tmux, is: tmux send-keys -t "0.0" ":r" Enter ":main" Enter
02:09:40 <ttt_fff> you put this in a makefile, then ":make" causes the ghci in the tmux window to execute :r :main
02:09:47 <ttt_fff> and bam ... it's fucking interactive; it's awesome fast
02:10:21 <dramforever> actually the check-on-save of ghc-mod is pretty good
02:10:29 <ttt_fff> oh, I have that already
02:10:34 <ttt_fff> but hdevtools is faster than ghc-mod, I think
02:10:39 <sydneyhacker> also does anyone know the meaning of the - '.' package in stack?
02:10:48 * dramforever will check hdevtools
02:11:21 <ttt_fff> dramforever: http://www.stephendiehl.com/posts/vim_haskell.html ... installation is pretty nairy though, you have to do "cabal install hdevtools"
02:11:27 <BartAdv> damn, my haskell evening hacking consist almost only of building and stuff, even with stack, which is damn awesome:(
02:11:36 * dramforever uses emacs
02:12:06 <ttt_fff> dramforever: I heard, with non-zero probability, you can install hdevtools with "sudo dd if=/dev/random of=/dev/hda1"
02:12:39 * hackagebot informative 0.1.0.11 - A yesod subsite serving a wiki.  https://hackage.haskell.org/package/informative-0.1.0.11 (implementation)
02:14:26 <dramforever> ttt_fff: sadly 1. for some reason I have /dev/sda1 but not /dev/hda1 and 2. my /dev/sda1 is the boot partition so it wouldn't be that awesome to have hdevtools installed there
02:15:13 <I_love_ttt_fff> dramforever: ‚Äúhda‚Äù has been unused for quite some time, I think, and anyway you can only see it if you have an IDE hard drive
02:15:24 <dramforever> maybe
02:18:39 <ely-se> How do I package haddock documentation with my package if I publish it to Hackage?
02:18:43 <ely-se> or does Hackage automatically run Haddock?
02:19:43 <dramforever> yes it's automatic
02:19:57 <I_love_ttt_fff> ely-se: Hackage does automatically run Haddock, but if you want your docs to be available sooner, you can upload them by yourself
02:19:59 <dramforever> but you have to wait a few days
02:20:01 <ely-se> Ok, nice. :)
02:22:39 * hackagebot open-browser 0.1.0.0 - Open a web browser from Haskell.  https://hackage.haskell.org/package/open-browser-0.1.0.0 (rightfold)
02:25:13 <BartAdv> hmm, RTFM I guess. it's described in stack wiki: I just added the blaze-bootstrap as local package with extra-dep: true
02:25:46 <BartAdv> however, I'm not sure why stack seemed to force it to be inside main directory
02:33:41 <dramforever> hello, Is -XOverlappingInstances bad? If so why?
02:37:20 <pavonia> It can lead to unexpected behaviour if overlapping instances are coming from libraries
02:38:16 <dramforever> pavonia: so what's it like?
02:39:04 <pavonia> What do you mean?
02:39:13 <dramforever> pavonia: what do *you* mean? =P
02:39:34 * dramforever 's English isn't really good =P
02:39:49 <pavonia> 's isn't either
02:39:59 <pavonia> +/me
02:40:24 <dramforever> pavonia: so what problems can it cause?
02:40:42 <ely-se> errors :p
02:41:50 <ttt_fff> i think we should rename Haskell to be Kolomogrov
02:41:57 <ttt_fff> because haskell code tends to achieve minimal Kolomogrov complexity
02:42:36 <I_love_ttt_fff> ‚ÄúKolmogorov‚Äù, not ‚ÄúKolomogorov‚Äù
02:42:44 <I_love_ttt_fff> not ‚ÄúKolomogrov‚Äù either
02:43:02 <I_love_ttt_fff> also, we already have J for that
02:43:03 <pavonia> dramforever: Imagine you define an instance Foo Int, where Foo comes from some library. Another module may define instances of Foo for all other types, where a third module expects that behaviour to work properly. Now you're using overlapping instances with both of these modules and suddenly the other modules changes it's behaviour
02:45:03 <mniip> [11:41:45] <I_love_ttt_fff> also, we already have J for that
02:45:07 <mniip> implying J can do anything
02:45:09 <mniip> APL is the tool
02:45:44 <mniip> at rare times it is defeated by golfscript though
02:45:57 <dramforever> pavonia: so what about instance Applicative f => Functor f
02:46:11 <dramforever> does it cause problems?
02:46:20 <I_love_ttt_fff> I have a sweet spot for J, I remember endless hours I spent toying with it on an old PDA when I was a kid
02:47:03 <mniip> dramforever, that one specifically doesn't
02:47:12 <mniip> but again as long as laws are held
02:47:20 <dramforever> so why don't we have it?
02:47:33 <mniip> because it isn't allowed by report
02:47:39 <mniip> OverlappingInstances is an extension
02:47:48 <dramforever> but is AMP in the report?
02:48:13 <pavonia> Aren'T cyclical dependencies a problem for the type checker?
02:49:00 <pavonia> Because there's already an instance Functor f => Applicative f
02:49:15 <mniip> dramforever, I don't see anything in the report forbidding AMP
02:50:02 <dramforever> mniip: a monad instance without an applicative instance is an error in ghc 7.10+
02:50:13 <dramforever> IIUC it's allowed by the report
02:50:14 <mniip> so?
02:50:28 <dramforever> so GHC rejects conforming code
02:53:54 <hunteriam> I think the fact that Haskell appears so magical is a design flaw
02:54:30 <hunteriam> I think there's something inconvenient about the syntax of monads and do notation
02:55:09 <mniip> do notation is perfect
02:55:35 <mniip> well
02:55:45 <ronh> do isn't magical at all. it is trivial to translate it to a chain of >>= function calls
02:55:54 <dramforever> "appears"
02:55:57 <mniip> do-let and do-if are unnecessary, but <- turning into >>= is pretty useful
02:57:08 <hunteriam> It's useful, I don't deny that. But I guess I don't like the way monads add a barely annotated context to a block of code
02:57:27 <hunteriam> That changes its meaning based off only a type change
02:58:23 <I_love_ttt_fff> hunteriam: in most cases you won't actually be able to change the type, because you're surely using some functions specific to your monad
02:58:32 <hunteriam> Yea I know that
02:58:41 <I_love_ttt_fff> but if you're not, then you're probably writing some combinator like whileM or forever
02:58:45 <I_love_ttt_fff> in which case it's fine
02:59:02 <hunteriam> I feel like probably is inappropriate in Haskell
02:59:07 <hunteriam> But I might be wrong
02:59:32 <dramforever> hunteriam: yeah but it's useful isn't it
02:59:40 <hunteriam> It is
03:00:00 <dramforever> that's probably why it's there
03:00:08 <dramforever> 1. useful 2. easy to implement
03:00:14 <hunteriam> There's gotta be a useful but clear solution
03:00:15 <dramforever> or rather, to describ
03:00:42 <dramforever> hunteriam: I agree that do notation is confusing
03:01:21 <hunteriam> The confusing bit is how the code is being transformed without any function visibly transforming the code
03:01:35 <hunteriam> And then you de sugar it, and it's a function from a typeclass that could mean anything
03:01:58 <hunteriam> So the only way to know the exact operation of a specific monad is to read it's source code
03:02:10 <hunteriam> Documentation for the bind function is non existent in most modules afaik
03:02:52 <dramforever> hunteriam: a monad is subject to monad laws
03:03:03 <hunteriam> Yea
03:03:13 <hunteriam> But when you're trying to understand what a specific monad does
03:03:22 <hunteriam> Monad laws aren't sufficient an explanation
03:03:54 <ely-se> I wish instances could have documentation
03:04:06 <dramforever> ely-se: yes they could
03:05:15 <hunteriam> That's a good chunk of the solution
03:05:35 <hunteriam> The other part of the solution would be making it clear that something is happening to the code in the do block
03:05:49 <hunteriam> But the documentation is probably more important
03:06:01 <hunteriam> Although how hard is it to document bind for most monads?
03:06:19 <hunteriam> Like it seems hard to explain what bind is doing versus other functions
03:06:25 <I_love_ttt_fff> okay, hunteriam is right about bind
03:06:29 <I_love_ttt_fff> hunteriam++
03:06:33 <dramforever> hunteriam++
03:06:41 <hunteriam> !karma
03:06:46 <dramforever> ?karma
03:06:46 <lambdabot> You have a karma of 2
03:06:52 <hunteriam> ?karma
03:06:52 <lambdabot> You have a karma of 2
03:06:55 <hunteriam> Yaaaaa
03:07:03 <I_love_ttt_fff> currently the only explanation for Maybe is for its Monoid instance, and it says ‚ÄúLift a semigroup into Maybe forming a Monoid according to http://en.wikipedia.org/wiki/Monoid: "Any semigroup S may be turned into a monoid simply by adjoining an element e not in S and defining e*e = e and e*s = s = s*e for all s ‚àà S."‚Äù, and that's a pretty awful explanation
03:07:08 <dramforever> dramforever++
03:07:15 <dramforever> ?karma
03:07:15 <lambdabot> You have a karma of 2
03:07:25 <I_love_ttt_fff> @karma
03:07:25 <lambdabot> You have a karma of 0
03:07:31 <I_love_ttt_fff> I_love_ttt_fff++
03:07:32 <I_love_ttt_fff> @karma
03:07:32 <lambdabot> You have a karma of 0
03:07:39 * I_love_ttt_fff raises a finger
03:07:40 <arjanb> is it just me or is hackage really slow today?
03:07:42 <I_love_ttt_fff> but watch this
03:07:48 <indiagreen> @karma
03:07:48 <lambdabot> You have a karma of 7
03:07:50 <indiagreen> ha
03:07:57 <dramforever> "The Maybe type is also a monad.  It is a simple kind of error  monad, where all errors are represented by Nothing.  A richer  error monad can be built using the Either type."
03:08:00 <ely-se> I_love_ttt_fff: I like the documentation for absurd which assumes you know Latin: ¬´values logically don't exist, this witnesses the logical reasoning tool of "ex falso quodlibet".¬ª
03:08:07 <Hijiri> ?karma
03:08:07 <lambdabot> You have a karma of 2
03:08:39 <dramforever> ely-se: most documentations assume you know English =P
03:09:00 <ely-se> if you're a programmer and you don't know English then you're pretty much doomed
03:09:28 <dramforever> there are a lot of doomed programmers, aren't it?
03:09:35 <hunteriam> Thank god it's English
03:09:46 <dramforever> oh wait that sentence looks crappy
03:09:46 <indiagreen> ely-se: nah, you're underestimating how many people learn by reading books and nagging other people for answers
03:09:56 <hunteriam> Although if it wasn't English I'd probably be pretty good at some other language at,
03:10:01 <hunteriam> Atm
03:15:27 <b_> Hello, I am reading book: Learn u a haskell, It just introduced the function: (<*>) in Applicative typeclass
03:15:42 <b_> is there a name for this <*> function?
03:15:51 <kritzcreek> ap
03:15:53 <mniip> ap
03:15:59 <dramforever> ap ++
03:16:26 <b_> thanks, in my mind I should say? ap = short form for 'apply'?
03:17:03 <mniip> if you want to pronounce it, "applicative apply" is probably the best
03:17:23 <b_> ok, thank you
03:17:30 <kritzcreek> It's kind of like function application with a context
03:17:55 <kritzcreek> im currently reading It's kind of like function application with a context
03:17:55 <kritzcreek> im currently reading It's kind of like function application with a context
03:17:55 <kritzcreek> im currently reading It's kind of like function application with a context
03:18:04 <mniip> ‡≤†_‡≤†
03:18:16 <mniip> what was that
03:18:26 <dramforever> > ‡≤†_‡≤† "im currently reading It's kind of like function application with a context"
03:18:27 <lambdabot>  Not in scope: ‚Äò‡≤†_‡≤†‚Äô
03:18:32 <kritzcreek>  i'll stop trying out this emacs client... and instead hop onto a webclient :D
03:19:11 <kritzcreek> sry for that :D
03:19:23 <mniip> > let ‡≤†_‡≤† = error . ("‡≤†_‡≤† "++)
03:19:23 <ely-se> lambdabot: maybe you should import http://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
03:19:25 <lambdabot>  <no location info>:
03:19:25 <lambdabot>      not an expression: ‚Äòlet ‡≤†_‡≤† = error . ("‡≤†_‡≤† "++)‚Äô
03:19:28 <demize> dramforever: ‡≤†_‡≤† as an alias for error should be in the prelude. ;)
03:19:42 <dramforever> yeah
03:19:56 <dramforever> @let ‡≤†_‡≤† = error . ("‡≤†_‡≤† "++)
03:19:56 <lambdabot>  Parse failed: Illegal character ''\3232''
03:19:57 <mniip> what do you mean illegal character ''\3232'
03:20:09 <kritzcreek> I'm currently reading http://artyom.me/lens-over-tea-1. But I struggle with implementing the choosing function.
03:20:26 <demize> lambdabot: You are a sillybot
03:20:45 <demize> Something in really wonky with its en and decoding..
03:21:22 <kritzcreek> How should I approach it? I was thinking about pattern matching against the Either and applying the corresponding lens.
03:21:30 <mniip> interesting
03:21:37 <mniip> ‡≤†_‡≤† works in @run but not in @let
03:21:47 <indiagreen> kritzcreek: yep, you're on the right track
03:22:38 <demize> mniip: Lol, the unicode codepoint it complained about...
03:23:09 <indiagreen> kritzcreek: what have you got so far?
03:23:10 <demize> It is some chinese character.
03:23:24 <mniip> > "\3232"
03:23:26 <lambdabot>  "\3232"
03:23:29 <mniip> > text "\3232"
03:23:31 <lambdabot>  ‡≤
03:23:40 <mniip> :/
03:24:04 <mniip> nope, 3232 is ‡≤†
03:24:08 <demize> oh, it's actually 3232 in utf-32
03:24:17 <mniip> are you confusing with \x3232
03:24:53 <lpaste_> kritzcreek pasted ‚Äúchoosing‚Äù at http://lpaste.net/137308
03:24:56 <demize> Well, I always think in UTF-8 ;p
03:25:21 <mniip> how is UTF-8 related
03:25:27 <mniip> it's an encoding
03:25:32 <mniip> we're talking about codepoints
03:26:20 <demize> mniip: Well yes, but I always look up Unicode escapes as UTF-8, because they mostly are.
03:26:48 <demize> Anyway
03:27:06 <demize> lambdabot is silly indeed.
03:27:12 <indiagreen> kritzcreek: okay, now, what type does f have?
03:27:18 <mniip> demize, I don't follow
03:27:35 <demize> Some day ago when we were doing something else with ‡≤†_‡≤† it would give that √†¬≤-kind of output, but it would half-work in a PM.
03:27:50 <lpaste_> kritzcreek revised ‚Äúchoosing‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/137308
03:27:52 <demize> mniip: I'm tired and not entirely sure what I'm thinking about, so not surprising.
03:27:53 <mniip> you mean you look up 0xe0 0xb2 0xa0  ?
03:28:34 <kritzcreek> f would be (a -> f b)
03:28:46 <indiagreen> kritzcreek: and r, l?
03:28:55 <demize> mniip: I actually have no idea what I was talking about, so lets just leave it at "I fucked my logic up". ;p
03:28:59 <Rizy> is there some one who has "[Wadler98] Philip Wadler. ìA prettier printerî. March 1998." in pdf or else?
03:29:11 <kritzcreek> r :: s1, l :: s2
03:29:21 <kritzcreek> th other way around
03:29:41 <krok> Can anyone come up with a function of type  a -> b -> c -> b  with only const, flip and . ?
03:30:06 <saep> @pl \a b c -> b
03:30:06 <lambdabot> const const
03:30:56 <krok> saep: oh, cool, didn't know lambdabot knows that, Djinn doesn't come up with const solutions
03:31:17 <indiagreen> kritzcreek: okay, good. Therefore, you can't directly apply f to either l or r
03:31:31 <ely-se> > let f = const const :: a -> b -> c -> b in f 1 2 3
03:31:33 <lambdabot>  2
03:31:34 <saep> I just know that @pl creates a lot of unreadable stuff with flip, (.) and const. :D
03:32:18 <ski> > let f :: a -> b -> c -> b; f = const const in f 0 1 2
03:32:18 <kritzcreek> indiagreen:that makes sense. So I need to use the given lenses to apply f to the values
03:32:19 <lambdabot>  1
03:32:21 <demize> Rizy: Google returns http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf though I haven't actually looked at the PDF.
03:32:27 <indiagreen> kritzcreek: right
03:32:28 <ely-se> ski: oh cool
03:32:37 <kritzcreek> but I only know "over"
03:32:42 <kritzcreek> and that removes the functor
03:32:47 <mniip> @pl adds some more useless optimizations that make it unreadable
03:32:47 <lambdabot> adds some more useless optimizations that make it unreadable
03:32:53 <mniip> see
03:32:56 <kritzcreek> or only accepts functions without a functor
03:32:58 <indiagreen> kritzcreek: yep, but you're forgetting that lenses are functions too
03:33:03 <ski> @help pl
03:33:03 <lambdabot> pointless <expr>. Play with pointfree code.
03:33:12 <indiagreen> kritzcreek: can you expand the type of l1?
03:34:01 <kritzcreek> indiagreen:I got it ! Thanks a bunch :D
03:34:15 <lpaste_> kritzcreek revised ‚Äúchoosing‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/137308
03:34:26 <indiagreen> kritzcreek: yep
03:34:47 <indiagreen> kritzcreek: that's pretty close to the ‚Äúofficial‚Äù solution: http://lpaste.net/137311
03:35:51 <kritzcreek> indiagreen: I read about Bifunctor and thought it could make for an elegant solution
03:36:29 <Rizy> thank you demize , when i search the other day it landed me on paid version journal provider. but i think i am not look harder
03:36:50 <ely-se> is it possible to put the contents of a file in a string literal at build time?
03:39:57 <kritzcreek> indiagreen: But I can't figure out how to lift the functor outside of the Either
03:45:54 <krok> Ok, can anyone come up with a function of type  f :: a -> b -> c -> d -> a  WITHOUT using (.) ?
03:46:09 <krok> E.g.   flip (const const) const :: a -> b -> c -> d -> c
03:46:15 <krok>      flip (const const) (flip const) :: a -> b -> c -> d -> d
03:47:27 <mniip> I doubt that's possible
03:48:53 <ely-se> krok: (<<<) from Category :P
03:49:10 <krok> ely-se: that's too advanced for me at this stage
03:49:28 * mniip fires up inference engine
03:49:45 <pavonia> @djinn a -> b -> c -> d -> a
03:49:45 <lambdabot> f a _ _ _ = a
03:50:08 <pavonia> @@  @pl @djinn a -> b -> c -> d -> a
03:50:08 <lambdabot>  f = const . const . const
03:50:09 <krok> pavonia: Djinn doesn't come up with const, and @pl uses (.)
03:50:37 <pavonia> Do you want a pointfree version?
03:51:31 <krok> pavonia: yeah, and that only uses flip and const (and maybe id)
03:51:34 <indiagreen> kritzcreek: that's a good idea, but I have just spent 10m searching for an already existing function to do ‚ÄúEither (f a) (f b) -> f (Either a b)‚Äù and there's nothing apart from ‚ÄúuncozipL‚Äù in the adjunctions package
03:52:36 <Intolerable> bitraverse?
03:52:48 <indiagreen> Intolerable: bitraverse requires f to be Applicative
03:52:52 <Intolerable> ah of course
03:53:11 <kritzcreek> indiagreen: :D thank you so much for your help.
03:53:34 <maerwald> @hoogle bisequenceA
03:53:35 <lambdabot> No results found
03:53:48 <indiagreen> kritzcreek: if you have more questions, you should probably ping me directly because I doubt there's a lot of people here who are familiar with lens over tea
03:54:01 <maerwald> https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bitraversable.html#v:bisequenceA
03:55:04 <mniip> krok, my inference engine can't find anything
03:55:19 <krok> mniip: tell me more about you inference engine
03:56:13 <mniip> it is a Rank-1 typechecker that bruteforces all combinations of 'flip' and 'const' that make sense, until one with a required type occurs
03:56:40 <Intolerable> if i have a functor F i'm using in a free transformer T m a = FreeT F m a, how can i represent a function f :: T m a -> T m (T m a) in the functor?
03:57:47 <Intolerable> i don't want a comonad because i have no extract
03:58:09 <Intolerable> (i presume)
03:59:15 <mniip> krok, for example,
03:59:21 <mniip>  > findVal [] (Var "a" ~> Var "b" ~> Var "c" ~> Var "a")
03:59:22 <mniip> ["(flip (const const))","((flip (flip flip)) (const const))","(flip ((flip (const flip)) (flip const)))","(flip ((flip (flip const)) const))","(flip (const (flip (flip const))))","(flip (flip (flip (const const))))","(flip ((flip (flip const)) (flip (flip const))))"...
04:00:15 <krok> mniip: THAT'S SO COOL
04:00:23 <mniip> oh wait
04:00:30 <mniip> you say a -> b -> c -> d -> a?
04:00:33 <krok> yep
04:00:36 <mniip> (flip ((flip (const flip)) (const const)))
04:00:46 <krok> or   a -> b -> c -> d -> b   too
04:00:56 <mniip> ((flip (const flip)) (const const))
04:01:22 <krok> mniip: it bruteforces, all right, but is there any sensible algorithm for that?
04:01:44 <mniip> there is an algorithm for transforming lambda calculus into SK-combinator calculus
04:01:47 <krok> something that makes sense algebraically
04:01:52 <mniip> where S=<*> for functions, and K=const
04:02:06 <krok> mniip: meh, here am I with my little knowledge of computer science :(
04:02:24 <mniip> given flip-const isn't isomorphic to LC I'm nto sure there is al algorithm for this particular pair of functions
04:02:43 <krok> mniip: is it possible to look at your engine?
04:02:45 <mniip> not* an*
04:05:05 <lpaste_> mniip pasted ‚Äúinference‚Äù at http://lpaste.net/137314
04:05:44 <FPtje> I'm having huge trouble installing gtk2hs on Windows. It can't install glib and cairo. When I try to install glib manually, it says this: "Missing C libraries: gobject-2.0, gthread-2.0, glib-2.0, intl". How am I supposed to install these on Windows?
04:06:02 <mniip> hmm
04:06:06 <mniip> there's some junk in that file
04:06:14 <FPtje> I'm running this guide: https://wiki.haskell.org/Gtk2Hs/Installation and the pkg-config command gives a good looking result
04:06:50 <mniip> ah, Text is for messing with the show instance
04:09:05 <mniip> krok, findVal extraGiven type, find a term that has type if it can use extraGiven besides given
04:09:37 <mniip> abstract extraGiven type, finds a term if it can use given, extraGiven, and if it can represent the top level expression as an abstraction
04:10:35 <mniip> for example, 'findVal [] tId' gives stuff like "((flip const) const)"
04:10:51 <mniip> and 'abstract [] tId' like "\x1 -> x1"
04:11:32 <mniip> I should turn 'abstract' into a proper curry-howard logic proving thingy someday
04:15:40 <lpaste_> FPtje pasted ‚ÄúCannot install gtk2hs‚Äù at http://lpaste.net/137315
04:16:09 <FPtje> I literally give it the exact locations where glib etc. is, but it still plays stupid, being unable to find glib
04:16:27 <mniip> [13:00:50] <krok> mniip: meh, here am I with my little knowledge of computer science :(
04:16:53 <mniip> it is widely known in constructive logic that any natural deduction proof can be rewritten using only two axioms
04:17:18 <kuribas> Does anyone have a good css file for generating html with pandoc?
04:17:37 <mniip> and thanks to curry-howard correspondence, natural deduction ~ lambda calculus, and SK axioms ~ SK-combinator calculus
04:17:52 <ely-se> U > SK
04:18:23 <indiagreen> kuribas: I use http://artyom.me/pandoc.css to generate artyom.me
04:18:38 <indiagreen> look at it to determine whether you like it or not
04:18:40 <kuribas> indiagreen: can I us it?
04:18:46 <indiagreen> sure, why not
04:18:59 <kuribas> thanks!
04:19:24 <mniip> ely-se, you mean
04:19:32 <mniip> barker's iota?
04:19:37 <ely-se> :)
04:19:47 <kuribas> indiagreen: I want to document my library algorithm, hopefully as cleary as yours :)
04:20:25 <mniip> ely-se, I'm afraid it isn't as popular in math and compsci as SK
04:20:35 <ely-se> :(
04:21:10 <indiagreen> kuribas: library algorithm?
04:21:13 <ely-se> I like systems with a single instruction/combinator.
04:21:32 <kuribas> indiagreen: I mean the algorithm I implemented in my library.
04:21:41 <kuribas> indiagreen: for removing overlap from bezier paths.
04:21:59 <kuribas> indiagreen: well, that I am currently implementing.
04:22:05 <ely-se> "subtract and branch if less than or equal to zero" is also one of my favourites
04:22:08 <dramforever> ely-se: it doesn't typecheck does it?
04:22:21 <ely-se> dramforever: never treied to write it in Haskell
04:22:27 <ely-se> tried*
04:22:31 <mniip> ely-se, oh and
04:22:39 <dramforever> wait it might typecheck
04:22:39 <mniip> it doesn't typecheck in rank-1 iirc
04:22:41 <indiagreen> kuribas: okay, but then the question is ‚Äúwhat have I ever managed to document clearly‚Äù
04:22:42 <kuribas> FPtje: maybe you have to put pkg-config in the path?
04:22:49 <kuribas> indiagreen: lenses?
04:23:28 <lpaste_> FPtje pasted ‚Äú@kuribas pkg-config‚Äù at http://lpaste.net/137316
04:23:42 <FPtje> kuribas: pkg-config works fine
04:24:08 <ParisManyTourist> anyone tryied to compile haskell-emacs?
04:24:17 <ParisManyTourist> does not work even in sandbox
04:24:35 <ely-se> mniip: hahaha http://lpaste.net/137317
04:25:00 <kuribas> FPtje: it's not clear to me that it is in the path, it might be just in the directory C:\Users\falco
04:25:13 <mniip> ely-se, gimme a sec
04:25:40 <FPtje> kuribas: it is in the path.
04:25:48 <dramforever> wow why is it *that* long
04:26:26 <ParisManyTourist> ely-se: you can try it here in lamda bot?
04:26:56 <kuribas> FPtje: what about intl?
04:27:00 <ely-se> > let s x y z = x z (y z) in let k x y = x in let u f = f s k in u (u (u u)) 42
04:27:01 <lambdabot>      Occurs check: cannot construct the infinite type:
04:27:01 <lambdabot>        t0
04:27:01 <lambdabot>        ~
04:27:26 <ParisManyTourist> u is recursive
04:27:28 <mniip> ely-se, you're doing it wrong
04:27:38 <FPtje> kuribas: I don't know what intl is, the installation guide doesn't mention it. I've only seen it in the error of installing glib
04:27:51 <ParisManyTourist> you apply u to u
04:28:45 <kuribas> FPtje: native language support I guess
04:29:01 <kuribas> FPtje: http://gnuwin32.sourceforge.net/packages/libintl.htm
04:29:02 <ParisManyTourist> > let s x y z = x z ( y z )
04:29:03 <lambdabot>  <no location info>: not an expression: ‚Äòlet s x y z = x z ( y z )‚Äô
04:29:11 <FPtje> kuribas: There is an intl.lib in C:\Users\falco\Programs\gtkbundle2\lib
04:29:25 <kuribas> FPtje: strange
04:29:31 <ParisManyTourist> @let s x y z = x z ( y z)
04:29:32 <lambdabot>  Defined.
04:29:38 <ParisManyTourist> :t s
04:29:39 <lambdabot>     Ambiguous occurrence ‚Äòs‚Äô
04:29:39 <lambdabot>     It could refer to either ‚ÄòL.s‚Äô,
04:29:39 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:168:1
04:29:47 <ParisManyTourist> :t L.s
04:29:49 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
04:29:52 <mniip> all of you are doing Rank-1 typechecking
04:29:53 <kuribas> FPtje: I remember someone had the same problem, and he just needed to log out and log back in.
04:29:56 <mniip> that's what is wrong
04:30:11 <FPtje> kuribas: I've tried manually putting all those folders output by pkg-config in --extra-include-dirs and --extra-lib-dirs. All the libs are there, but it absolutely refuses to see them
04:30:21 <FPtje> Alright, I'll try that. Thanks
04:30:29 <ely-se> wait, lemme try something else
04:31:21 <ParisManyTourist> ely-se: are you even sure you applied function correctly at the end? i mean u u u u 42 part
04:32:19 <ParisManyTourist> @let k x y = x
04:32:20 <lambdabot>  Defined.
04:32:43 <ParisManyTourist> @let u f = f s k
04:32:44 <lambdabot>  .L.hs:170:9:
04:32:45 <lambdabot>      Ambiguous occurrence ‚Äòs‚Äô
04:32:45 <lambdabot>      It could refer to either ‚ÄòL.s‚Äô, defined at .L.hs:169:1
04:32:58 <ParisManyTourist> @let u f = f L.s k
04:32:59 <lambdabot>  .L.hs:170:13:
04:32:59 <lambdabot>      Ambiguous occurrence ‚Äòk‚Äô
04:32:59 <lambdabot>      It could refer to either ‚ÄòL.k‚Äô, defined at .L.hs:168:1
04:33:19 <ParisManyTourist> @let u f = f L.s L.k
04:33:21 <lambdabot>  Defined.
04:33:33 <ParisManyTourist> :t L.u
04:33:34 <lambdabot> (((t3 -> t2 -> t1) -> (t3 -> t2) -> t3 -> t1) -> (t5 -> t4 -> t5) -> t) -> t
04:33:52 <ParisManyTourist> :t (u u)
04:33:53 <lambdabot>     Ambiguous occurrence ‚Äòu‚Äô
04:33:53 <lambdabot>     It could refer to either ‚ÄòL.u‚Äô,
04:33:53 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:170:1
04:34:04 <mniip> I see
04:34:09 <ParisManyTourist> :t (L.u L.u)
04:34:10 <lambdabot>     Occurs check: cannot construct the infinite type:
04:34:10 <lambdabot>       t40 ~ t1 -> t40 -> t1
04:34:10 <lambdabot>     Expected type: (((t1 -> t40 -> t1)
04:34:15 <mniip> U cannot be expressed in a simply-typed lambda calculus
04:34:16 <ParisManyTourist> here you go
04:34:28 <ParisManyTourist> u u is already invalid
04:34:41 <mniip> S S K can only function in untyped lambda calculus
04:34:41 <FPtje> kamatsu: no dice
04:34:42 <ParisManyTourist> no need to bother with wierdness like u u u u 42
04:34:44 <ely-se> it works in a dynamically typed language
04:34:49 <mniip> yes
04:34:55 <mniip> but not in simply typed LC
04:35:08 <kuribas> FPtje: also what does pkg-config --libs gtk+-2.0 give?
04:35:25 <mniip> S S K is akin to omega though
04:35:39 <ParisManyTourist> ely-se:so what did we learn from this?
04:35:47 <lpaste_> FPtje pasted ‚Äúpkg-config‚Äù at http://lpaste.net/7397028840242937856
04:35:54 <ely-se> ParisManyTourist: that Haskell is inferior to dynamically typed languages! :P
04:35:59 <FPtje> kuribas: that ^
04:36:01 <ParisManyTourist> haah
04:36:02 <ParisManyTourist> lol
04:36:03 <mniip> it's not dynamic typing
04:36:08 <ParisManyTourist> not really
04:36:13 <mniip> it's untyped LC
04:36:18 <mniip> versus simply typed LC
04:37:05 <ParisManyTourist> ely-se:how do with come to problem like this, what is logic?
04:37:15 <mniip> and untyped LC is inconsistent :P
04:37:17 <ParisManyTourist> is it even any practical algorithm?
04:37:19 <mniip> because Y combinator
04:37:23 <mniip> and omega combinator
04:37:50 <mniip> ParisManyTourist, are you familiar with SK combinator calculus?
04:37:58 <ParisManyTourist> a bit
04:38:10 <ParisManyTourist> but you seem to help me understand it better :)
04:38:29 <mniip> any untyped lambda calculus expression can be rewritten using only S and K combinators
04:38:38 <mniip> i.e we can get rid of lambdas
04:38:44 <ParisManyTourist> so its like basis?
04:38:49 <mniip> yeah
04:38:53 <ParisManyTourist> ok
04:38:56 <ely-se> and S and K can be derived from U
04:39:02 <mniip> U combinator brings it to the extreme
04:39:19 <mniip> any untyped LC expression can be represented using only U
04:39:38 <mniip> but at the cost of incompatibility with simply typed LC
04:40:33 <ParisManyTourist> so does it mean that dynamicly typed means untyped LC?
04:41:42 <FPtje> kuribas: This is the full -v3 build log. http://lpaste.net/137319 It DOES find pkg-config
04:41:44 <mniip> no
04:41:54 <mniip> dynamic typing has nothing to do with lambda calculus
04:41:57 <ParisManyTourist> so u combinator is not possible in simply typed LC?
04:42:12 <mniip> it is possible by itself but it is useless
04:42:13 <kuribas> FPtje: I see a missing space: libpng14--extra-lib-dirs
04:42:17 <mniip> because 'u u' is a type error
04:42:25 <mniip> also one can use u in haskell
04:42:27 <mniip> u f = unsafeCoerce (unsafeCoerce f) (unsafeCoerce s) (unsafeCoerce k)
04:42:28 <ParisManyTourist> i see, ok seems interesting
04:42:42 <mniip> but very carefully
04:42:46 <mniip>  > ((u u) :: a -> a) 123
04:42:46 <mniip> 123
04:42:47 <FPtje> kuribas: where?
04:43:23 <ParisManyTourist> i just realized i dont know what dynamically typed language is lol :D
04:43:46 <kuribas> FPtje: http://lpaste.net/137315 could be copy past error though
04:43:48 <FPtje> kuribas: also, look from 1043 onwards. It looks like it does find all the libraries, but considers them all incompatible. 
04:43:49 <dramforever> hey so where's lambdabot?
04:44:27 <mniip> > text "I'm here"
04:44:29 <lambdabot>  I'm here
04:45:44 <kuribas> FPtje: maybe mismatch between 32/64bit?
04:45:54 <FPtje> kuribas: That space doesn't matter. Installing glib manually also shows these "skipping ..." lines
04:46:00 <FPtje> kuribas: Might be. Let me look
04:46:01 <ParisManyTourist> dramforever: you can pm with him too
04:46:35 <dramforever> okay I was just wondering why lambdabot didn't respond to > ((u u) :: a -> a) 123
04:46:48 <indiagreen> dramforever: because of the space before >
04:46:55 <dramforever> okay
04:47:14 <FPtje> kuribas: Yup, I had downloaded the 32 bit version. Thanks for the help. I'll try this bundle now
04:47:23 <FPtje> the 64 bits 2.22.1 that is
04:47:37 <kuribas> FPtje: good!
04:48:23 <ParisManyTourist> actually does typechecking has any analogues in LC?
04:48:33 <ParisManyTourist> like what is mathematical equivalent of typechecking?
04:48:44 <ParisManyTourist> its just algorithm right?
04:49:12 <dramforever> a partial function from expressions to types?
04:49:36 <ParisManyTourist> yea seems close
04:49:53 <ParisManyTourist> partial means that is fails time to time?
04:50:02 <FPtje> kuribas: Oh man, thank you so much! Times like these make me wish Windows had a package manager
04:50:13 <kuribas> FPtje: great!
04:50:40 <kuribas> FPtje: you can get the same problems on linux though.
04:51:15 <ParisManyTourist> actually did someone checked typechecker for bugs?
04:51:19 <FPtje> kuribas: Nah man, that was just a yaourt -S gtk-something 
04:52:28 <FPtje> On Windows I had to install ghc and cabal manually because the Haskell Platform For Windows ships with ghc 7.8.3
04:52:52 <BenCHammer> Hey guys, is the => operator basically just implementing an interface
04:53:01 <BenCHammer> This tutorial I'm reading says they're better
04:53:07 <BenCHammer> But I can't yet see why
04:53:15 <dramforever> BenCHammer: better than what?
04:53:24 <kuribas> BenCHammer: => is not an operator, it's syntax
04:53:32 <BenCHammer> Interfaces in java is the example they made 
04:53:37 <BenCHammer> Sorry not =>
04:53:43 <BenCHammer> Type classes I think they're called
04:53:54 <dramforever> yes because it's more flexible
04:53:58 <ski>   # let s x y z = x z (y z) in let k x y = x in let u f = f s k in u (u (u u)) 42 ();;
04:54:00 <ParisManyTourist> type class is a collection of types :)
04:54:01 <ski>   - : int = 42
04:54:04 <ParisManyTourist> that what it is
04:54:04 <dramforever> and yes they are called typeclasses
04:54:24 <ely-se> what language is that ski?
04:54:24 <FPtje> and we all know that any version of ghc without holes is inferior, haha
04:54:28 <BenCHammer> Oh so you can make it allow for multiple types?
04:54:29 <ski> ely-se : OCaml
04:54:33 <BenCHammer> that's really damn cool
04:54:49 <ski> ely-se : it allows cyclic types (if you turn the correct knob)
04:54:53 <kuribas> > let (-) = 3 in (-)
04:54:54 <lambdabot>  3
04:54:57 <dramforever> they are, however, like interfaces in java
04:54:58 <ely-se> amazing
04:55:09 <ParisManyTourist> ely-se:this construction is useless noot?
04:55:12 <ParisManyTourist> not?
04:55:25 <BenCHammer> Woah fantastic stuff, thanks dramforever 
04:55:41 <ski> ely-se : by default, cyclic types are turned off (except if the cycle is going through at least one object type, which is the reason they're present for the first place in OCaml)
04:55:45 <ely-se> ParisManyTourist: dunno
04:56:18 <ely-se> Let's see if I can write it in C++.
04:56:22 <ParisManyTourist> ski: what was motivation for stuff like that?
04:56:30 <ParisManyTourist> in ocaml?
04:56:33 <ski> ely-se : .. it turns out that allowing cyclic types always is a good way to mask type errors, for usually not that more power ior convenience
04:58:26 <ski> ParisManyTourist : object types. structural, not nominal typing -- so if a function wants an object that can respond to some particular messages, there's no need to have to pass it an object that's been instantiated from a class derived from some particular base class. as long as the object you pass supports the required messages, with matching argument and result types, the type system will pass you
04:58:49 <ely-se> ski: works in C++ as well: http://coliru.stacked-crooked.com/a/4537adb80a3c5e9d
04:58:57 <ely-se> but that's because it uses duck typing
04:59:30 <ski> ParisManyTourist : .. and the cycles are needed for when you want an object that can accept another object of the same type as an argument (comparators, say), or when you want an object that can return another object of the same type (cloning, perhaps with some fields changed)
04:59:31 <maerwald> ely-se: which is so horrible... the type of a function argument can randomly change during a recursion
05:01:15 <ski> ely-se : will that catch all type errors ? or does it give UB at run-time ?
05:01:28 <ttt_fff> consider the following block of code
05:01:38 <ttt_fff> if (M halts) then x = 2 else x = 2 + "hehehaha"
05:01:41 <ely-se> ski It's all static. C++ does duck typing at compile-time, not at runtime.
05:01:54 <ski> maerwald : well, if i understand what you mean correctly, so it can in Haskell, with polymorphic recursion
05:02:14 <ely-se> You can write all sorts of nonsense like "template<typename T> int f(T x) { return x; }" and it will compile if you don't call it
05:02:32 <dramforever> I wonder if you could do polymorphic recursion in c++
05:02:37 <ely-se> If you call it, it'll only compile if you call it with something implicitly convertible to int
05:02:54 <ski> ely-se : oh, right. expansion
05:03:17 <ski> dramforever : probably not. it would require an infinite expansion, no ?
05:03:23 <dramforever> dunno
05:03:25 <ely-se> It's called "template instantiation". C++ doesn't guarantee parametricity.
05:03:45 <ely-se> dramforever: what do you mean by that?
05:03:52 <maerwald> ski: except that duck typing isn't really polymorphism and that people query the type of the function argument inside the function body to decide what to do
05:04:02 <maerwald> because you can never know what you get
05:04:26 <ski> maerwald : statically query, i suppose ?
05:04:39 <BenCHammer> heck
05:04:42 <maerwald> ski: I don't know what you mean
05:04:46 <BenCHammer> This read function seems dangerous 
05:05:15 <indiagreen> BenCHammer: you can use readMaybe from Text.Read instead to avoid the danger
05:06:07 <dramforever> IIUC read and show are really for debugging
05:06:11 <ski> maerwald : iow, the querying all happens at compile-time (as opposed to inspecting some representation of types at run-time)
05:06:14 <ely-se> dramforever: You can do polymorphic recursion in C++ using polymorphic classes instead of templates.
05:06:19 <maerwald> ski: no, I don't mean that
05:06:25 <dramforever> okay then
05:06:55 <ski> ely-se : interesting
05:07:01 <ely-se> Or using pointers in general.
05:08:44 <ski> <ski> ParisManyTourist : .. and the cycles are needed for when you want an object that can accept another object of the same type as an argument (comparators, say), or when you want an object that can return another object of the same type (cloning, perhaps with some fields changed)
05:08:49 <ely-se> lemme make an example
05:22:35 <ely-se> dramforever: a list which contains itself as head: http://coliru.stacked-crooked.com/a/9cec337850b96505
05:23:41 <dramforever> ely-se: okay good
05:24:06 <ely-se> There is a language feature proposal for incredibly reducing the boilerplate needed for things like any_list.
05:24:18 <ely-se> I hope it'll make it to C++17.
05:26:46 <mauke> that contains a pointer to a pointer to itself, doesn't it?
05:27:19 <ely-se> Yes, through any_list::derived<T>
05:27:49 <ttt_fff> is this C++ or #haskell? :-)
05:28:24 <mauke> hmm. why do you need the double pointer?
05:28:57 <ely-se> Because you can't instantiate the template "typedef list<recursive_list> recursive_list;"
05:29:17 <ely-se> so you need to resort to runtime polymorphism instead, using a base class (here any_list::base)
05:29:31 <ely-se> extra indirection solves all problems :)
05:29:57 <mauke> I don't get it
05:31:41 <ttt_fff> ely-se: except the problem of too many layers of indirection -- dijkstra
05:33:26 <ely-se> mauke: here is a simpler equivalent: http://coliru.stacked-crooked.com/a/a937602c5f7170d2
05:33:43 <ely-se> this however requires lists to have a print method, which is problematic as it violates SRP
05:35:36 <ely-se> the any_list class in my previous example would also be better named "any_printable", actually
05:45:29 <Intolerable> if i have a type "data X m a where ‚Ä¶ deriving (Functor)" and "newtype XT m a = XT (FreeT (X m) m a)"
05:45:36 <Intolerable> am i going to run into any problems
05:46:16 <dramforever> Intolerable: what kinds of problems?
05:46:43 <Intolerable> the two m's concern me
05:47:06 <Intolerable> i need the functor to know about the monad that the free transformer will be on
05:47:17 <Intolerable> but i'm worried that later on that will limit me
05:47:54 <dramforever> I found something related https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free.html#v:retractT
05:48:07 <dramforever> that's enough to show that you are not limited, I think
05:48:37 <dramforever> on the other hand, are you sure you need the functor to know the monad?
05:48:51 <dramforever> oh you must have already asked yourself that =)
05:48:59 <Intolerable> yup, 100% sure
05:49:24 <Intolerable> i need a function XT m a -> XT m (XT m a)
05:49:38 <Intolerable> i don't think theres any other way around it
05:49:57 <dramforever> :t duplicate -- are you a comonad?
05:49:58 <lambdabot> Comonad w => w a -> w (w a)
05:50:19 <Intolerable> it's not a comonad
05:50:33 <dramforever> never mind
05:50:48 <Intolerable> it has no sensible extract
05:51:15 <Intolerable> i'm pretty sure this will work
05:51:26 <Intolerable> just wanted to make sure i wasn't going to run into any awfulness
05:51:58 <ely-se> I don't understand comonads.
05:52:40 <mniip> Intolerable, fmap return?
05:52:50 <dramforever> I'm not an expert on that
05:53:41 <Intolerable> mniip: that wouldn't work
05:54:15 <Intolerable> it's essentially ExceptT a IO b and i want to be able to inspect the resulting Either from inside it
05:54:40 <ely-se> "While it's easy to publish papers on monads, it's coeasy to publish papers on comonads."
05:54:40 <dramforever> like try?
05:55:11 <dramforever> *it's coeasy to copublish copapers under comonads
05:55:52 <dramforever> "under" was just a random preposition
05:56:06 <Intolerable> like try, but a little more awkward
05:56:19 <dramforever> so?
06:49:25 <ely-se> cotry
06:52:51 * hackagebot fwgl 0.1.2.1 - FRP 2D/3D game engine  https://hackage.haskell.org/package/fwgl-0.1.2.1 (ZioCrocifisso)
06:57:51 * hackagebot fwgl-javascript 0.1.0.5 - FWGL GHCJS backend  https://hackage.haskell.org/package/fwgl-javascript-0.1.0.5 (ZioCrocifisso)
06:57:53 * hackagebot fwgl-glfw 0.1.0.5 - FWGL GLFW backend  https://hackage.haskell.org/package/fwgl-glfw-0.1.0.5 (ZioCrocifisso)
07:27:53 * hackagebot fgl 5.5.2.1 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.2.1 (IvanMiljenovic)
07:52:42 * ely-se is gonna watch Haskell videos
07:52:54 * hackagebot hledger-diff 0.2.0.4 - Compares the transactions in two ledger files.  https://hackage.haskell.org/package/hledger-diff-0.2.0.4 (gebner)
08:02:35 <rodlogic> Trying to understand why was Language.Haskell.Syntax (haskell-src) and Language.Haskell.TH.Syntax were created as different libraries. Do they address different use cases? Why not have a single one?
08:02:51 <rodlogic> s/were//
08:04:02 <hpc> the TH module uses definitions specific to making TH work
08:04:04 <hpc> such as defining Q
08:04:29 <hpc> the other appears to simply be an ADT for haskell syntax
08:04:40 <hpc> like the output of a parser
08:05:23 <geekosaur> also haskell-src is generic (granted, this mattered more when there were viable alternatives to ghc) while TH is specific to ghc
08:10:53 <freeman42> sorry, this is a little offtopic... started a haskell group on meetups and I was thinking what might be a good communication medium to help us agree on where/how to meet at the beginning. Something on the lines of irc channel, https://slack.com or maybe even hangouts chat group. any suggestions?
08:18:06 <caulagi> what is the most common framework/library I should use for developing REST api?
08:18:26 <caulagi> I have already seen https://wiki.haskell.org/Web/Frameworks
08:18:44 <caulagi> But all the choices are confusing :)
08:19:15 <Intolerable> what framework would you choose in another language?
08:19:23 <freeman42> caulagi, an easy and slightly wrong way to get a base idea would be to check github stars for those projects
08:19:38 <freeman42> it is possible that most of them are on github
08:19:43 <caulagi> Intolerable: Node would a good choice
08:20:36 <Intolerable> just raw node.js?
08:20:52 <caulagi> freeman42: Yes, I was wondering what is the community advice
08:20:56 <Intolerable> or do you want something a little higher-level?
08:20:57 <caulagi> node.js with express
08:21:16 <caulagi> and maybe a library for postgresql
08:21:41 <caulagi> I just want to expost APIs that will return json
08:21:52 <Intolerable> a full-on ORM or do you want to hand-write queries?
08:22:25 <caulagi> Either are fine - whichever is simpler
08:22:32 <caulagi> so maybe hand-write queries?
08:22:35 <Intolerable> try spock
08:22:55 <ely-se> caulagi: take a look at PostgREST
08:22:55 * hackagebot heyefi 0.1.1.1 - A server for Eye-Fi SD cards.  https://hackage.haskell.org/package/heyefi-0.1.1.1 (ryantm)
08:23:19 <y> caulagi: servant + postgresql-simple? 
08:25:56 <caulagi> ok - thanks, I am going to look servant and spock.
08:27:55 * hackagebot lambda-options 0.8.0.0 - A modern command-line parser for Haskell.  https://hackage.haskell.org/package/lambda-options-0.8.0.0 (ThomasEding)
08:31:12 <Phillemann> This may be a stupid question, but I just wrote this function http://lpaste.net/4531952226909814784 and I'm not sure if this already exists.
08:31:40 <Phillemann> It's in the context of events in reactive-banana (<> is "union") where I need to "merge" two events.
08:33:22 <catgocat> @pl f (x, y) = grid !! x !! y
08:33:22 <lambdabot> f = uncurry ((!!) . (grid !!))
08:42:50 <ttt_fff> i have a humble request
08:43:05 <ttt_fff> can someone please turn https://hackage.haskell.org/package/tables into an actual database?
09:12:04 <meretrix> I have an event driven application and am trying to determine whether FRP could be useful.
09:12:08 <meretrix> Which FRP is most appropriate for doing things like "detect when 4 events have fired in the last 500ms and start throttling"?
09:13:15 <meretrix> Basically a lot of processing of streaming data, sometimes looking at sliding window of events.
09:13:50 <meretrix> s/Which FRP/Which FRP framework/
09:22:31 <roboguy_> Is there a way in template haskell to make a fake data structure? By that I mean, a data structure that can't be seen outside of the template haskell code which exists only to use the code generated by a "deriving" statement?
09:25:44 <mpickering> is there a package which takes a haskell source file, renders it to html with spans around all located AST elements?
09:27:29 <roboguy_> mpickering: what do you mean by spans around all located AST elements?
09:28:21 <mpickering> I mean that if the source file contains an expression then there is a span with a suitably unique id around that expression in the output
09:29:10 <mpickering> So if I have a file that contains.. "foo = x" then there is a span around the whole thing, a span around foo and a span around x
09:29:18 <mpickering> so I can choose to highlight certain expressions
09:30:29 <mpickering> declarations.. stmts.. whatever I want
09:31:13 <mpickering> I guess most syntax highlighting only works with the lexer so it's unlikely this exists
09:32:12 <roboguy_> mpickering: haddock gives a name to every line and every top-level definition. is that enough?
09:34:26 <mgccl> How to convert Integer to ByteString? the encode in Data.Binary seems to generate some more bits in the beginning.
09:34:51 <monochrom> mpickering: I think hscolour helps. you can replace its default css.
09:35:53 <ChristianS> mgccl: convert how?
09:37:04 <mgccl> ChristianS: the Integer represented in binary written as ByteString in big endian
09:37:52 <monochrom> why not small endian? would be so much easier
09:38:36 <jmcarthur_> mgccl: if you can get away with not caring about the specific encoding, you could use http://hackage.haskell.org/package/binary
09:39:00 <roboguy_> mgccl: more bits in the beginning?
09:39:01 <monochrom> heh
09:39:27 <int-e> roboguy_: a tag, a length, and the sign
09:39:35 <roboguy_> ah
09:40:06 <jmcarthur_> mgccl: i'm sorry i didn't read back far enough. you are already looking at binary
09:40:26 <jmcarthur_> actually i just have selective reading
09:41:44 <jmcarthur_> mgccl: the source code of binary has fold and unfold functions to convert integers back and forth between lists of bytes. they are pretty simple. you could just copy them.
09:42:06 <jmcarthur_> s/fold/roll/g
09:42:59 <mgccl> jmcarthur_: seems so, I will try that
09:57:59 <mpickering> monochrom, roboguy_ : I rolled my own solution with ghc-exactprint, hscolour and haddock only use the lexer
10:12:29 <ttt_fff> is it possible to write haskell source, one line at a time
10:12:38 <ttt_fff> in such a way that after every additional line, the code always compiles (type checks)
10:14:06 <roboguy_> ttt_fff: mostly. Why wouldn't it be?
10:14:18 <ttt_fff> because I haven't achieved that yet
10:14:24 <ttt_fff> I can to "one funciton at a time, and it walsyas type checks"
10:14:28 <ttt_fff> but one line at a time, nope
10:14:53 <kuribas> Doesn't anyone want to support my pull request for pandoc?  https://github.com/jgm/pandoc/pull/1689
10:15:06 <roboguy_> ttt_fff: why restrict it to lines? Sometimes it looks better to spread something over multiple lines
10:15:27 <ttt_fff> was curious
10:15:31 <ttt_fff> not hard constraint
10:16:02 <kuribas> ttt_fff: sure
10:16:14 <roboguy_> ttt_fff: the only thing I can think of that would prevent that would be mutually recursive functions or mutually recursive data types
10:16:36 <ttt_fff> for mutually recursive functions you can fill one with "error "blah""
10:16:39 <kuribas> You could write a whole module on one line, but maybe there is a line length limit.
10:16:40 <ttt_fff> then write the other one, then write the other one
10:17:00 <roboguy_> true
10:17:21 <kuribas> ttt_fff: I always write undefined to fill any holes.
10:17:31 <ttt_fff> does undefined compile?
10:17:33 <ttt_fff> _ does not
10:17:43 <kuribas> ttt_fff: undefined is a valid value.
10:17:54 <kuribas> it would give a runtime error though.
10:18:01 <ely-se> indiagreen: I replied to your email.
10:18:02 <ttt_fff> maybe I should use undefined
10:18:04 <kuribas> But if the point is type checking, then that's fine.
10:18:34 <kuribas> ttt_fff: It was recommended in real world haskell, and I used it since.
10:18:50 <indiagreen> ely-se: yep, I got it just now, thanks. Good to know that it's insecure (even tho it doesn't matter in the place I'm using it).
10:19:06 <roboguy_> ttt_fff: undefined is just defined as undefined :: a; undefined = error "Prelude.undefined"
10:19:24 <indiagreen> ely-se: but I'll switch to your package anyway because it's nice to have a package for that
10:19:30 <ely-se> indiagreen: I didn't think of the open command in OS X. I'll refactor out the AppleScript.
10:19:51 <ttt_fff> roboguy_: ah, that clears thigns up, thanks!
10:19:52 <ely-se> indiagreen: note that my package currently only works on OS X as I don't have access to other machines right now and CBA to install a VM :p
10:20:44 <mpickering> kuribas: I don't suggest the right way to get a pr accepted is to send the mob
10:20:51 <jmcarthur_> ttt_fff: _ compiles if you use -fdefer-type-errors
10:21:35 <kuribas> mpickering: well, I mean only if you also want the feature of course.
10:21:44 <jmcarthur_> ttt_fff: for purposes of compilation, it basically just becomes something like (error "<text of type error>")
10:22:17 <kuribas> mpickering: but it is rather annoying that there is no (portable) way to have 3rd or higher level headers in markdown+lhs
10:22:26 <jmcarthur_> ttt_fff: in fact, -fdefer-type-errors may just be what you are looking for
10:22:40 <ttt_fff> jmcarthur_: noted, thanks!
10:22:48 <jmcarthur_> ttt_fff: basically it just means type errors don't prevent the rest of the build from happening
10:27:46 <edwardk> clojure transients turn out to be a bit.. interesting to emulate in haskell
10:28:26 <jmcarthur_> edwardk: yeah. pretty annoying
10:28:50 <edwardk> jmcarthur_: i've managed to come up with a technique with equivalent asymptotics, its just a lot of boilerplate
10:29:58 <KorriX> Hello!
10:30:23 <KorriX> What is the most comprehensive / widely used FRP library?
10:30:57 <KorriX> I'm writing a simple 2D graphics engine and thinking about integrating one, but I'm not sure which one to choose
10:31:27 <Phillemann> KorriX: I'm doing the same, and I chose reactive-banana.
10:31:50 <ely-se> what does "Safe Haskell" mean in Haddock?
10:31:55 <Phillemann> It's been around pretty long and it's still maintained.
10:32:18 <mniip> ely-se, it means, quite frankly, that the haskell is safe
10:32:19 <Phillemann> And it pretty closely follows Conal's API from way back, apparently.
10:32:20 <jmcarthur_> KorriX: there are a lot of decent ones these days. in my mind, the new hotness is FRPNow, just because it has the promise of avoiding space leaks, offering a model that allows reasoning about memory usage, and has a really good story for actually interfacing with the real world.
10:32:21 <KorriX> Phillemann: Have you compared it in any way with netwire 5?
10:32:34 <jmcarthur_> KorriX: but note that it's *really* new
10:32:35 <Phillemann> KorriX: I have absolutely no comparison right now, sorry.
10:32:52 <ely-se> mniip: "safe" is vague. Does it mean no FFI and other unsafe modules are used?
10:33:07 <KorriX> I'll look at FRPNow then
10:33:10 <jmcarthur_> KorriX: oh, and for me, a hard requirement is a precise semantic model, which FRPNow actually has, whereas many "FRP" libraries don't...
10:33:28 <mniip> ely-se, not really
10:33:31 <mniip> ely-se, a good example is Data.Bytestring
10:33:45 <KorriX> jmcarthur_: I also like well structured libraries
10:33:48 <mniip> it uses System.IO.Unsafe, which is unsafe, for its internal operations
10:33:49 <ely-se> Right
10:33:56 <mniip> yet those internal operations are really well hidden
10:34:02 <mniip> and the module overall is safe
10:34:05 <jmcarthur_> KorriX: i would say that FRPNow still feels a little like a (successful) academic project
10:34:18 <ely-se> It's about whether it exposes APIs that may have side-effects or undefined behaviour if you don't use them correctly.
10:34:21 <jmcarthur_> KorriX: so in terms of module structure it's not amazing
10:34:42 <KorriX> I'll investigate then
10:34:56 <mniip> ely-se, more like if it can catch fire from a technically valid but semantically incorrect usage
10:35:04 <ely-se> Excellent.
10:35:09 <mniip> imagine if [] !! -1 would coredump
10:35:10 <jmcarthur_> KorriX: also, feel free to join #haskell-game :)
10:35:19 <mniip> that would make !! unsafe haskell
10:35:38 <KorriX> <jmcarthur_>, <Phillemann>: Thanks for your help
10:35:41 <jmcarthur_> KorriX: it's a good lurking channel with the occasional interesting conversation
10:35:57 <KorriX> let's switch. I just joined
10:37:42 <athan> jmcarthur_: Where can I find semantics on FRPNow? :S
10:37:59 <athan> thanks also, btw, I've been trying to learn frp for some time
10:38:09 <athan> I feel like a correct implementation would really help me out
10:38:21 <jmcarthur_> athan: the paper has a good description
10:38:34 <jmcarthur_> http://www.cse.chalmers.se/~atze/papers/prprfrp.pdf
10:38:45 <athan> jmcarthur_: Ahh there it is, sorry
10:38:50 <athan> thanks :)
10:40:30 <jmcarthur_> athan: note that the denotation is not as simple as i would like, but i've chosen to accept it as a fundamental complexity for keeping the cost model simpler.
10:42:36 <athan> jmcarthur_: That's okay I think, like System-FC_pro is for GHC
10:53:22 <luntain> how can one have cabal install packages that pley nicely with the platform packages already on the system. If dependency does not have a constraints it naively goes for the most recent one and sooner or later trips itself when some packages depend on platform versions, and some other require cutting edge ones. It seems to never go back far enough and maybe try older versions. I have a project that used to compile and now cabal can't 
10:54:52 <kadoban> luntain: Use cabal sandboxes, don't install any packages "globall" (i.e. none shared for your user) ‚Ä¶ and IMO don't use platform. If you like you can use stackage. Also you could try just using 'stack' instead of raw cabal: https://github.com/commercialhaskell/stack
11:03:02 * hackagebot equal-files 0.0.5.2 - Shell command for finding equal files  https://hackage.haskell.org/package/equal-files-0.0.5.2 (HenningThielemann)
11:04:32 <John[Lisbeth]> where can I find some of the sourcecode for the early haskell compilers?
11:04:47 <John[Lisbeth]> the really old ocde
11:04:49 <John[Lisbeth]> *code
11:09:05 <John[Lisbeth]> This answers my question from the other day of what -> means, I believe: https://hackage.haskell.org/package/haskell-src-1.0/src/
11:14:47 <bitemyapp> John[Lisbeth]: yeah (->) is the type constructor of functions.
11:15:08 <bitemyapp> John[Lisbeth]: I sent an email to Hammond and SPJ about old versions of GHC, I'll ping you if I get a response.
11:16:45 <John[Lisbeth]> From what I understand these are the basic logical primitives that make up the syntax. -> just means that one thing wants to enter a function and come out as something else. Parentheses () redirect where -> goes.
11:17:21 <John[Lisbeth]> Finally, what goes inbetween -> and parentheses are all functions
11:20:31 <monochrom> parentheses don't redirect where -> goes.
11:20:42 <monochrom> parentheses tell you how to parse. THE END.
11:21:27 <Peaker> Hey, when I have a corecursive type, and I want to use a fixpoint-parameter (for all the usual goodies), suddenly I have to pass 3 fixpoint-params (I have 3 types involved in the corecursion)
11:21:43 <Peaker> Does anyone have any recommendations on how to deal with that?  A type-level tuple of 3 fixpoints?
11:22:31 <johnw> Peaker: can you show some code?
11:22:43 <Peaker> I'll whip a minimized example up, sure
11:23:04 <monochrom> I respect going open recursion for all the usual goodies of open recursion. provided that those goodies actually exist.
11:23:25 <monochrom> those goodies actually exist for 1 parameter. but not for 3 parameters.
11:24:43 <monochrom> I think I have trouble even doing just 2.
11:25:02 <lpaste_> Peaker pasted ‚ÄúType AST example‚Äù at http://lpaste.net/137341
11:25:24 <Peaker> monochrom: well, one of the goodies I need is a different fixpoint in different contexts
11:25:30 <johnw> oh, by corecursion you mean mutual recursion
11:25:36 <Peaker> oh sorry, yeah :)
11:26:03 <Peaker> monochrom: one possible set of fixpoints is just like Fix. Another is Annotate. Another is a Database-reference (when I serialize into a key/value store)
11:26:25 <sunfish> my noob question number 1, how to build leksah?  I'm using cabal 1.22+.   cabal install leksah fails, because glib fails.  cabal install glib fails because it can't find gtk2hsC2hs, supposedly because gtk2hs-buildtools insn't installed, but cabal install gtk2hs-buildtools succeeds.
11:26:56 <johnw> I think it would start like: data Record rt rr = REmpty | RExtend Name rt rr | RVar (RecordVar rt rr) ... data Type rt rr = TFun rt rt | TRecord rr | TVar (TypeVar rt rr)
11:26:56 <lpaste_> Peaker revised ‚ÄúType AST example‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/137341
11:27:09 <johnw> you have to plum the fixed-point parameters everywhere they need to end up
11:27:30 <johnw> i do this in hnix, since it uses mutually recursive fixed-points too
11:27:39 <Peaker> johnw: That's a bummer :(
11:27:49 <johnw> well, the types are varying at each point
11:27:51 <Peaker> 2 extra type params for "Type", everywhere
11:27:58 <johnw> so without passing them, how could the types line up?
11:28:08 <Peaker> johnw: well, I could pass a "type-level tuple" of the fixpoints?
11:28:18 <johnw> you're saying that a recursive structure can embed recursive structures that can embed recursive structures of the first kind, etc.
11:28:20 <sunfish> also, I can see gtk2hsC2hs in my .cabal/bin, and that is in my path ...   hmmm
11:28:21 <Peaker> (I tried some type family projections but that sucked)
11:28:43 <johnw> the type-level tuple will need the same arguments everywhere it is used
11:28:45 <johnw> so you'll gain zero
11:29:23 <Peaker> johnw: Can't I have a type-level tuple like:  data Record r = REmpty | RExtend Name (?fst r) .. 
11:29:30 <Peaker> (Not sure how to "fst" on a type-level tuple)
11:29:48 <johnw> data Tuple a b c = Tuple a b c
11:29:50 <johnw> you see the problem?
11:30:04 <johnw> you can't smush a b and c together into a synthetic type, with projections to break it apart again
11:30:48 <monochrom> "data Tuple a b c = Tuple a b c" is a value-level tuple, not a type-level tuple. it is really tempting. I have to keep reminding myself "wrong level", too.
11:30:56 <geekosaur> sunfish, you need to find where gtk2hsc2hs got installed and add it to $PATH (unix) or %PATH% (windows)
11:31:02 <johnw> I meant the left-side of it, but you're right
11:31:09 <johnw> so, I guess he's talking about closed type families the
11:31:11 <johnw> n
11:31:46 <johnw> but even then, how would you ever do it generally, without repeating a, b and c?
11:31:52 <Peaker> johnw: I thought you could just have type-level data structures now :)
11:32:07 <Peaker> (I saw type-level lists, via '[] and ':)
11:32:09 <monochrom> that will be "kind structures"
11:32:16 <Peaker> sure :)
11:32:29 <monochrom> I am teaching a data structure course. undergrad 2nd year
11:32:46 <monochrom> maybe next year I'll teach a grad course "kind structures and type-level algorithms"
11:32:59 <Peaker> johnw: the idea is that you can mention and pass around "r" only, and then use something like 'fst r, 'snd r, to get the components (but I don't know if this idea works)
11:33:27 <Peaker> (so the use sites are cumbersome, but those that just index the types are simpler, and I have like 2 orders of magnitude more of the latter, at least)
11:33:39 <sunfish> hi geekosaur, gtk2hsC2hs is in ~/.cabal/bin, and ~/.cabal/bin is at the beginning of my path ... strange the installer can't see it
11:33:58 <geekosaur> is that literal ~ showing in $PATH?
11:34:16 <Peaker> Is 'fst a thing?
11:34:24 <sunfish> no, it's home/myid/.cabal/bin
11:34:24 <johnw> Peaker: for specific r, I can do that, with a closed family.  Just relate r to some other types.  But how would you do it generally?
11:34:43 <geekosaur> (shells understand ~, other programs do not, ~ does not work in $PATH reliably (bash will translate it *sometimes* when searching $PATH, other shells and other programs do not)
11:35:01 <sunfish> I'm using bash, perhaps the installer uses a different shell and it isnt in that shell's path?
11:35:54 <Peaker> johnw: I don't need generality, I just have 2-3 specific fixpoint-tuples
11:44:20 <luntain> kadoban: stack rocks!
11:44:39 <eitanChatav> when ought one use the INLINE pragma?
11:45:36 <johnw> when you don't mind code bloat, and you've proven that it actually helps
11:46:44 <John[Lisbeth]> Could anybody recommend a good docker image for development in haskell?
11:47:00 <Peaker> The entire lens library is INLINE'd no? :)
11:47:30 <johnw> edwardk can explain to you why that's a good idea for his use case
11:47:36 <eitanChatav> johnw: what is the intuition for when it will actually help?
11:47:38 <johnw> i find that lots of INLINE just slows my code down
11:47:55 <Peaker> I INLINE lens/traversals/prisms by default, I think GHC doesn't tend to inline it even though it is often beneficial (I guess because the ordinary way they are used is expensive/unspecialized)
11:48:02 <Peaker> I wish SPECIALIZE was easier to use
11:48:12 <johnw> eitanChatav: if you read the Core and you've got a largish function in a tight loop that is only ever used in that tight loop, then GHC probably might not inline it on its own
11:48:28 <Peaker> {-# SPECIALIZE foo m=Maybe a=String #-}  instead of replicating the entire type
11:48:29 <johnw> but I'm not wise in the ways of the GHC inliner quite yet
11:49:24 <eitanChatav> thanks
11:49:25 <athan> edwardk needs his own bot, like in iRobot or something
11:52:09 <Peaker> My main use of INLINE is to easily SPECIALIZE all use sites (with the somewhat unintended consequence of also.. inlining)
11:52:35 <indiagreen> John[Lisbeth]: 0.29 is here: https://downloads.haskell.org/~ghc/0.29/ghc-0.29-src.tar.gz
11:54:38 <athan> indiagreen: "this day in Haskell" ...?
11:54:50 <John[Lisbeth]> indiagreen thanks
11:54:50 <indiagreen> athan: ?
11:54:55 <athan> nvm :P
11:55:04 <Peaker> So GHC accepts '(Int, String) as a type-level tuple, but how do you project back out of it?
11:55:09 <Peaker> 'fst isn't a thing apparently
11:55:25 <athan> Peaker: singletons
11:55:25 <Peaker> Oh, fst T is!
11:55:30 <athan> or you could make a closed type family
11:56:07 <Peaker> but GHC doesn't seem to resolve it to a specific type, even when T is defined/in-scope
11:56:11 <athan> -XPolyKinds  `type family Fst (xs :: '(a, b)) :: a where Fst (x,y) = x`
11:56:46 <athan> -XKindSignautres -XTypeFamilies :)
11:56:49 <Peaker> ah, thanks
11:57:04 <Peaker> Annoying that type-level tuples exist without projections!
11:57:19 <athan> Peaker: Closed type families are really useful for doing recursion and pattern matching and stuff, but you might run into some funky errors
11:57:41 <athan> Peaker: singletons implements a lot of the prelude for type-level stuff :)
11:58:05 <Peaker> I guess johnw will win and I'll have to plumb 2 extra TV's everywhere
11:58:09 <athan> funky-errors induced by overlapping instances, I mean
11:58:19 <johnw> athan: so, does that work for you?
11:58:22 <athan> :x
11:58:36 <Peaker> Why can't I give a name to 2 things, so I can have 1 compound thing, easily??
11:58:37 <athan> johnw: The code I wrote? It might, didn't check it yet
11:58:40 <johnw> I get "parse error on '"
11:58:47 <athan> oh um
11:58:54 <johnw> and if I delete the ', then Fst expects Fst
11:59:23 <johnw> no, that (x, y) has kind *, not kind '(*, *)
11:59:25 <athan> > type family Fst (xs :: (a, b)) :: a where; Fst '(x,y) = x
11:59:26 <lambdabot>  <hint>:1:1: parse error on input ‚Äòtype‚Äô
11:59:29 <athan> I think that's right
11:59:31 <athan> hrm
11:59:36 <johnw> ah, Fst '(x, y) is needed
12:00:02 <johnw> now, can you write a function: foo :: r -> Fst r?
12:00:11 <Peaker> "r" isn't *
12:00:21 <Peaker> Fst r -> Snd r, probably (if you also have Snd)
12:00:39 <johnw> still doesn't work
12:00:43 <athan> derp haha
12:00:43 <johnw> type families are not injective
12:00:44 <athan> one sec
12:01:19 <Peaker> johnw: works for me like: type T = '(Int, String) ; foo :: Fst t -> Snd t ; foo = show
12:01:31 <johnw> ah, ok
12:01:37 <Peaker> oops
12:01:41 <Peaker> Fst T, Snd T
12:01:44 <Peaker> (not lower-case t there)
12:01:46 <johnw> yes, that works
12:01:59 <johnw> ok, so now you have a shorthand for a known type
12:02:10 <johnw> but fixed-point recursors are not known types
12:02:21 <Peaker> let me try it..
12:02:26 <johnw> although, maybe the structure of the recursor "set" can be known
12:02:50 <athan> type family Fst (xs :: (a,b)) :: a where Fst '(x,y) = x
12:03:07 <athan> :kind! Fst '(Bool, Int)
12:03:08 <athan> :)
12:03:11 --- mode: ChanServ set +o mauke
12:03:11 --- mode: mauke set -b $a:magistr
12:03:26 <athan> johnw: ^
12:04:38 <minad> Hi!
12:04:51 <lpaste_> Peaker annotated ‚ÄúType AST example‚Äù with ‚ÄúType AST example (annotation)‚Äù at http://lpaste.net/137341#a137343
12:05:07 <Peaker> johnw: this seems to compile (not sure it'll work later..)
12:05:11 --- mode: mauke set -o mauke
12:05:13 <Peaker> (when more stuff is needed)
12:05:38 <johnw> you're not properly recursing yet though
12:05:46 <johnw> RecordVar refers to the recursiv etype
12:05:59 <johnw> it nedes to be RVar (RecordVar r), so that RecordVar can continue the recursion
12:06:05 <johnw> and likewise with TVar
12:06:08 <minad> this is my first time here, but I will probably stay here for longer as I I have a question about uniplate
12:06:12 <minad> sry
12:06:29 <minad> I've heard this channel is quite friendly to newbies ;)
12:06:39 <johnw> Peaker: references to 'Fst r' work for me, but I can't pass around 'r'
12:07:21 <zomg> minad: this channel is friendly to friendly people regardless of their skill level =)
12:07:22 <minad> I have a question concerning uniplate - I want to descendM some datastructure consisting of multiple types. I would like to use a separate function for each type
12:07:31 <minad> zomg: even better!
12:08:00 <minad> there is descendM and descendBiM
12:08:34 <minad> but is it somehow possible to descend with multiple functions A->A B->B C->C which are then nested into each other
12:08:35 <jmcarthur_> minad: feel free to just hang out here
12:08:55 <minad> jmcarthur: I will definitely do so
12:09:15 <johnw> Peaker: for example, this fails: https://gist.github.com/28261acbcab6ca4a504f
12:09:32 <minad> I can write such a nested transformer function by hand, but can this be generated also like for descendM and descendBiM?
12:09:36 <johnw> because we're mixing kind/type levels
12:10:08 <jmcarthur_> minad: you mean you want to perform multiple descends in one pass?
12:10:26 <minad> jmcarthur
12:10:29 <minad> jmcarthur: yes
12:11:08 <minad> jmcarthur: do I have to combine multiple descends somehow to achieve the same?
12:12:23 <jmcarthur_> i'm trying to understand the uniplate docs. i've used it once a long time ago and then forgot everything
12:12:31 <minad> my problem with haskell currently is that I have problems finding the "right" solution. I find it quite hard to navigate hoogle/hackage etc. Also I find it a bit hard to know which project's source is worth reading to get a better grasp of concepts
12:13:05 * hackagebot varying 0.1.0.0 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.0.0 (SchellScivally)
12:13:25 <jmcarthur_> minad: from the type of descend, it looks like the following property is likely to hold true:    descend f . descend g  =  descend (f . g)
12:13:32 <jmcarthur_> minad: but i'm just guessing
12:13:58 <minad> jmcarthur_: yes, something like this holds
12:14:04 <minad> also descendM (a <=< b)
12:14:10 <Jeena> Hi, I'm a haskel n00b and I have big trouble to understand something. I'm using Network.HTTP.Conduit and there I get the website I request a lazy ByteString. But In the function I want to use it I would need it as String. I can not for the love of god understand how I can bring those two together
12:14:41 <jmcarthur_> minad: i think i may be missing the core of your question, if what i just said already makes sense to you
12:14:43 <minad> jmcarthur_: but this is not what I want. I have different functions, which transform different types
12:15:03 <jmcarthur_> you mean you want to operate on different types of children than the root?
12:15:13 <minad> like (descendBiM transformA) <=< (descendM transformB), but this in one pass
12:15:18 <chreekat> Jeena: decodeUTF8
12:15:21 <minad> jmcarthur_: yes
12:15:32 <chreekat> well, that gets you a Text
12:15:45 <minad> descendBi does that for one type, but I want to do it for all types in the same pass
12:15:59 <chreekat> Jeena: unpack
12:16:32 <Jeena> chreekat but that gives me a Word8 list
12:17:38 <chreekat> :t Data.ByteString.Char8.unpack
12:17:39 <lambdabot> BSC.ByteString -> [Char]
12:17:56 <johnw> do not use Char8.unpack
12:18:08 <jmcarthur_> minad: i cannot think of a way with the given interface
12:18:13 <minad> jmcarthur_: I will be gone for a while. Thx for your help. Maybe I have to approach this differently. The question is about metaprogramming, I mean uniplate generates these things for me. But maybe there is some nice pattern to do something like this. Maybe talk to you later?
12:18:16 <jmcarthur_> minad: i think it just needs to be multiple passes
12:18:32 <chreekat> johnw: I was gonna say, I thought that might be a bad idea
12:18:35 <jmcarthur_> minad: you can try to catch me later, but starting soon i will be away for a while today
12:19:11 <indiagreen> Jeena: Data.ByteString.UTF8.toString (from the utf8-string package), or perhaps Data.Text.Lazy.Encoding.decodeUtf8 if you're fine with Text instead of String
12:19:56 <minad> jmcarthur_: multiple passes won't work nicely if I have some state monad etc, but maybe this is not a good approach either
12:20:20 <minad> jmcarthur_: ok, cu!
12:20:20 <jmcarthur_> oh i see
12:20:26 <jmcarthur_> see you later maybe!
12:23:16 <chreekat> Jeena: howdy, by the way :)
12:23:25 <Jeena> indiagreen here is what I have right now and the compile error https://gist.github.com/rpannek/52c857ea81fa9e84c00a the types are still mixed up
12:23:44 <Jeena> ah hehe chreekat now I know where I remember the name from, howdy :D
12:24:03 <Pamelloes> Is there a function to remove all duplicates in a list i.e. so the list has only unique values?
12:25:38 <Eduard_Munteanu> Pamelloes, nub, but it sucks
12:25:53 <Eduard_Munteanu> Pamelloes, if you can sort it, you can do better
12:25:58 <Eduard_Munteanu> :t nub
12:25:59 <lambdabot> Eq a => [a] -> [a]
12:26:24 <Eduard_Munteanu> :t map head . group . sort
12:26:26 <lambdabot> Ord b => [b] -> [b]
12:26:27 <jmcarthur_> nub is nicely lazy, at least
12:26:40 <jmcarthur_> though there are still more efficient lazy implementations if you have Ord
12:27:17 <jmcarthur_> and the lazy implementations also preserve the element ordering of the original list
12:27:38 <jmcarthur_> that can of course be recovered even with a strict implementation like  map head . group . sort
12:27:57 <Pamelloes> Eh, the order doesn't really matter and I'll be iterating through the whole list anyways so laziness doesn't really matter.
12:28:37 <Eduard_Munteanu> If it's a finite, small list, then strict is fine.
12:29:03 <Pamelloes> Yep, finite and (unless someone screws something up) under 10 items
12:29:31 <Eduard_Munteanu> Also...
12:29:41 <Eduard_Munteanu> :t S.toList . S.fromList
12:29:42 <lambdabot> Ord a => [a] -> [a]
12:29:58 <jmcarthur_> :t map snd . sort . map head . groupBy ((==) `on` snd) . sortOn snd . zip [0..]   -- why do we have sortOn but not groupOn?
12:29:59 <lambdabot> Ord b => [b] -> [b]
12:30:10 <Eduard_Munteanu> :t groupBy
12:30:11 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:30:25 <Eduard_Munteanu> Perhaps trademark infringement. :P
12:30:31 <jmcarthur_> :t sortBy
12:30:33 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:30:33 <jmcarthur_> :t sortOn
12:30:35 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
12:30:50 <Iceland_jack> :t \f -> sortBy f . comparing
12:30:51 <lambdabot>     Couldn't match type ‚Äòb -> b -> Ordering‚Äô with ‚Äò[a]‚Äô
12:30:51 <lambdabot>     Expected type: (b -> a1) -> [a]
12:30:51 <lambdabot>       Actual type: (b -> a1) -> b -> b -> Ordering
12:31:16 <Iceland_jack> nvm
12:31:16 <jmcarthur_> :t sortBy . comparing
12:31:18 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
12:32:10 <jmcarthur_> Pamelloes: if order and strictness doesn't matter, maybe you should just be using a set instead of a list
12:33:23 <Pamelloes> jmcarthur_: I've never really worked with sets... How do you write a literal Set?
12:33:36 <Pamelloes> And can you parse sets along the line of (a:as)?
12:34:04 <jmcarthur_> Pamelloes: there are no set literals. it's just an interface (Data.Set)
12:34:22 <Eduard_Munteanu> > S.fromList [1,2,3]
12:34:23 <lambdabot>  fromList [1,2,3]
12:34:33 <Pamelloes> Ah, so like that :)
12:34:35 <Eduard_Munteanu> > S.fromList [1,2,2,4,3]
12:34:36 <lambdabot>  fromList [1,2,3,4]
12:34:52 <Pamelloes> What kind of iteration support is there?
12:34:53 <jmcarthur_> Pamelloes: they are not as syntactically convenient as lists, but that's not the only important factor, of course
12:35:07 <jmcarthur_> Pamelloes: there are tons of ways to iterate over them
12:35:08 <roboguy_> Pamelloes: map, foldr, foldl, etc
12:35:17 <Eduard_Munteanu> Pamelloes, a lot of list-like combinators are available for Set as well
12:35:27 <Pamelloes> Hm....
12:35:41 <Pamelloes> Foldr should work :)
12:36:06 <Eduard_Munteanu> S.foldl' (+) 0 . S.fromList $ [1,2,2,2,3]
12:36:09 <Eduard_Munteanu> > S.foldl' (+) 0 . S.fromList $ [1,2,2,2,3]
12:36:11 <lambdabot>  6
12:37:32 <Eduard_Munteanu> Of course, you can also S.toList and then apply ordinary list functions.
12:37:42 <Eduard_Munteanu> (for folds)
12:39:10 <roboguy_> it's also an instance of Foldable
12:39:27 <roboguy_> > foldMap Sum (S.fromList [1,2,3,4,5])   -- So you can do things like this
12:39:28 <Eduard_Munteanu> Not sure if we have RULES like  S.fromList . something . S.toList == S.something    though.
12:39:28 <lambdabot>  Sum {getSum = 15}
12:41:50 <Pamelloes> How does alternative work?
12:42:37 <jmcarthur_> Pamelloes: not much to say other than that it's kind of like Monoid, but for a different kind
12:42:53 <jmcarthur_> Pamelloes: it's abstract enough that we can't really be concrete without talking about a specific instance
12:43:48 <Pamelloes> Yeah.... That's what I've gathered. I can't really make heads or tails of the definition...
12:44:27 <roboguy_> Pamelloes: the definition about some and many? You can generally ignore that
12:44:34 <roboguy_> the real laws are just the monoid laws
12:45:05 <BartAdv> eh, stack made me think haskell on windows is seamless, but now I hit 'duplicate definition for symbol _rgb' (seemingly out of a sudden, the build worked couple of hours ago, I didn't even know exactly what I've changed)
12:45:35 <Pamelloes> roboguy_: So then what's the difference between Alternative and Monad?
12:45:38 <Pamelloes> *Monoid
12:45:39 <Pamelloes> :/
12:47:10 <roboguy_> Pamelloes: Alternative is for types of a different kind than Monoid
12:47:51 <Pamelloes> Oh, that makes sense. So Monoid (a :: *) whereas Alternative (f :: * -> *)?
12:47:55 <roboguy_> For example, the Alternative instance cannot be the same as the Monoid instance for Maybe in base, because you can't express a constraint on the type variable inside the Alternative class
12:47:56 <roboguy_> yeah
12:48:28 <roboguy_> > Just "ab" <|> Just "cd"
12:48:30 <lambdabot>  Just "ab"
12:48:33 <roboguy_> > Just "ab" <> Just "cd"
12:48:35 <lambdabot>  Just "abcd"
12:48:52 <Pamelloes> > Just "ab" <|> Nothing
12:48:54 <lambdabot>  Just "ab"
12:49:04 <Pamelloes> > Nothing <|> Just "cd"
12:49:06 <lambdabot>  Just "cd"
12:49:08 <Pamelloes> o.O
12:49:12 <pantsman-> > "ab" <|> "cd"
12:49:13 <lambdabot>  "abcd"
12:49:55 <Pamelloes> "ab" <> "cd"
12:50:03 <Pamelloes> Whelp.
12:50:11 <roboguy_> > "ab" <> "cd"
12:50:13 <lambdabot>  "abcd"
12:50:15 <Pamelloes> Anyways, so for [a], <> = <|>? Or am I missing something?
12:50:22 <roboguy_> yeah
12:50:28 <roboguy_> not for Maybe though
12:50:49 <Pamelloes> Right, in maybe Just a <|> _ = Just a while Nothing <|> a = a
12:51:38 <Pamelloes> I think.
12:52:03 <Eduard_Munteanu> Yes.
12:52:05 <roboguy_> yeah. (Maybe a)'s Monoid instance is different because it uses the underlying Monoid of a (a must be an instance of Monoid)
12:52:38 <Pamelloes> > Just "ab" <> Nothing
12:52:39 <lambdabot>  Just "ab"
12:52:59 <Eduard_Munteanu> > Just "ab" <> Just "cd"
12:53:01 <lambdabot>  Just "abcd"
12:53:13 <Eduard_Munteanu> > Just "ab" <|> Just "cd"
12:53:14 <lambdabot>  Just "ab"
12:53:19 <roboguy_> > Just 'a' <> Nothing  -- This won't type check
12:53:21 <lambdabot>      No instance for (Monoid Char) arising from a use of ‚Äò<>‚Äô
12:53:21 <lambdabot>      In the expression: Just 'a' <> Nothing
12:53:34 <roboguy_> > Just 'a' <|> Nothing   -- But this will
12:53:36 <lambdabot>  Just 'a'
12:55:14 <Pamelloes> Alright, I think I get it now :)
12:55:34 <Pamelloes> I just found the instance for the type I'm using and it all sort of makes sense now.
13:01:07 <joncol> I'm struggling with the first project of the NICTA course (NetworkServer). The first problem is to finish the perClient function (line 85 of https://github.com/NICTA/course/blob/master/projects/NetworkServer/haskell/src/Network/Server/Chat/Loop.hs). I've made some attempts, but mostly I feel like I'm fumbling and just trying things out without really knowing what I'm doing. For instance, I don't understand
13:01:13 <joncol>  the meaning of the arguments to the function. Has anyone looked at this problem?
13:08:05 <tamasgal> joncol: btw. you can try to find help in #scalaz or #nicta-course
13:08:40 <Jeena> ok I simplified the whole thing but there is still a thing I can't figure out https://gist.github.com/rpannek/8df588411ba6662728f4 why is the Expected Type Char if U.toString returns a String and the type of the function is also String?
13:10:04 <Hijiri> Jeena: your function is supposed to return a String, so it thinks your do block is a string
13:10:14 <Hijiri> A string is a list of Chars like [Char]
13:10:24 <Hijiri> literally, String is just a synonym for [Char]
13:10:26 <joncol> tamasgal> Thanks, posting there as well.
13:10:33 <tamasgal> Jeena: the expected type is not Char, but IO Char
13:10:38 <Hijiri> For [a], return :: [a]
13:10:39 <Jeena> so I'm misunderstanding the whole do thing? I thought I am returning String
13:11:06 <Hijiri> Jeena: return doesn't do what you think it does
13:11:14 <tamasgal> maybe you try the CIS194 (spring 2013) course first‚Ä¶
13:11:46 <Jeena> yeah I suspected that but I have no idea how to tackle it
13:12:05 <Hijiri> Jeena: have you done any structured guides for learning haskell
13:12:27 <Jeena> yeah I did at the university but it was a long time ago
13:12:56 <Jeena> and I also wrote this thing https://github.com/jeena/cnb/blob/master/cnb.hs which works
13:13:04 <Jeena> and even uses monades and stuff
13:13:45 <Hijiri> Jeena: what do you think the type of "return (U.toString body)" should be
13:14:33 <Jeena> something with IO meybe because it does IO stuff in simpleHttp?
13:14:39 <Hijiri> nope
13:14:46 <Jeena> damn
13:14:53 <Hijiri> the last expression in your do block is the type of your do block
13:15:01 <roboguy_> Jeena: that's not what the type signature says
13:15:16 <Hijiri> and the type of your do block is String, because that's what your function returns
13:15:17 <roboguy_> getTweet doesn't have IO in its result type
13:15:25 <Hijiri> so "return (U.toString body" *should* be String
13:15:48 <Jeena> but it isn't
13:15:49 <Hijiri> but it doesn't match up
13:16:18 <Hijiri> return (U.toString body), without specializing to a specific Monad, is type Monad m => m String
13:16:22 <Jeena> so I should remove the return?
13:16:35 <Hijiri> sure, you'll still have the other type error though
13:16:45 <Hijiri> and you probably don't want to use the do block for returning the string value
13:16:55 <Hijiri> (unless you change the type to something like IO String)
13:17:03 <Jeena> I would rather not
13:17:14 <Jeena> so I shouldn't do it with a do block at all?
13:17:17 <roboguy_> why not?
13:17:23 <Hijiri> you might want to do it with a do-block
13:17:25 <Hijiri> because you will need IO
13:17:49 <Jeena> so my type should be IO String?
13:17:55 <Hijiri> the return type should be
13:17:56 <Jeena> (return type)
13:18:24 <paul0> I've installed HTTP and HaXml using cabal, but I can't import any of them using ghci
13:18:37 <paul0> Perhaps you haven't installed the "dyn" libraries for package ëHTTP-4000.2.20í?
13:18:56 <Hijiri> Jeena: if you want a refresher, I recommend checking out
13:18:59 <Hijiri> @where learnhaskell
13:18:59 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:19:19 <Jeena> good tip
13:19:22 <Hijiri> If you're confident enough you can skip CIS194 and just do the NICTA course/exercises
13:19:57 <kadoban> Jeena: 'return' in haskell is unfortunately poorly named. It doesn't mean what it means in C-family languages. It means ‚Ä¶ "take this thing of type 'a' and make it of type (Monad m => m a)". You should probably do that refresher, and quite possible NICTA because NICTA is great, you'll get through cis194 quickly if you have previous decent haskell experience.
13:20:00 <Hijiri> and maybe some of the other resources if you're interested in them
13:20:33 <Jeena> kadoban I thought I need to do return because in the main I do tweet <- getTweet ...
13:21:30 <Hijiri> you don't absolutely have to do return, it could be rewritten as getTweet <url> >>= print
13:21:37 <Jeena> but yeah I should really refresh first before I keep on try/erroring
13:21:41 <Hijiri> (without a do block also)
13:22:07 <kadoban> Refresher first sounds like a good plan. It should be /much/ clearer after that.
13:22:13 <Hijiri> return is one way to get the result you want, but there are other ways
13:22:25 <Jeena> ok
13:24:05 <Sagi> I'm trying to write a function with the following type (a1 -> a2) -> (((a1 -> b) -> b -> c) -> (((a2 -> b) -> b -> c), but I can't wrap my head around how to implement it.
13:24:46 <Sagi> err, I'm wrong on the braces (a1 -> a2) -> (((a1 -> b) -> b) -> c) -> (((a2 -> b) -> b) -> c)
13:27:03 <Eduard_Munteanu> @djinn  (a1 -> a2) -> (((a1 -> b) -> b) -> c) -> (((a2 -> b) -> b) -> c)
13:27:03 <lambdabot> -- f cannot be realized.
13:28:27 <Eduard_Munteanu> Sagi, ^
13:28:36 <Sagi> err
13:29:28 <Eduard_Munteanu> @djinn (a -> b -> c) -> (b -> a) -> b -> c
13:29:28 <lambdabot> f a b c = a (b c) c
13:31:15 <quchen> Sagi: What's it for?
13:32:06 <Sagi> I'm working with a with-style function (e.g. withFile) and I want to modify the 'file' before I pass it to the function it's wrapping.
13:32:53 <Sagi> it feels as if that shouldn't be so hard, but 30+ minutes of screenstaring hasn't gotten me anywhere.
13:33:13 <johnw> \file modify g -> withFile file $ g . modify
13:33:34 <quchen> withFile file $ \handle -> g (modify handle)?
13:33:52 <quchen> What's so bad about this?
13:33:58 <Sagi> hmm
13:34:17 <johnw> even: flip (withFile file) modify $ \h -> ... use modified h ...
13:34:36 <johnw> that might need >>= instead of $, though
13:34:45 <johnw> depending on the type of modify
13:34:53 <Sagi> let me try that
13:35:06 <Sagi> thanks for thinking along, will report back
13:37:30 <johnw> that's really not right (what I last wrote), but maybe you get the idea
13:42:14 <Gurkenglas> @djinn  (a2 -> a1) -> (((a1 -> b) -> b) -> c) -> (((a2 -> b) -> b) -> c)
13:42:14 <lambdabot> f a b c = b (\ d -> c (\ e -> d (a e)))
13:42:27 <Gurkenglas> As you see, you need a function from a2 to a1 to get what you want
13:43:09 * hackagebot fsnotify 0.2 - Cross platform library for file change notification.  https://hackage.haskell.org/package/fsnotify-0.2 (GregWeber)
13:43:32 <slowbait> Hi, why isn't it possible to pattern-match (n+1) where n is an Int?
13:43:45 <slowbait> or maybe I'm doing it wrong
13:43:56 <Gurkenglas> Because + is not a constructor
13:44:28 <Gurkenglas> The data doesn't look like "n + 1", and so the pattern match can't just look at whether there's a +
13:45:35 <indiagreen> slowbait: it used to be possible (so maybe you're asking because you've read an old tutorial), but not anymore
13:46:19 <slowbait> indiagreen: Yeah, I remember reading it somewhere, do you know why is it not possible anymore?
13:46:29 <johnw> n+k patterns
13:46:34 <johnw> is what they were called
13:46:34 <indiagreen> slowbait: because it was removed in Haskell 2010 standard
13:46:52 <marchelzo_> http://haskell.spreadshirt.com/n-k-forever-A6499609/customize/color/1
13:47:26 <indiagreen> slowbait: https://ghc.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
13:48:24 <slowbait> indiagreen: ok thanks
13:48:24 <indiagreen> basically they were too darn special but not useful nearly enough to justify that
13:48:56 <johnw> plus, they are never necessary, just cute
13:49:31 <johnw> you could always match foo ((-1) -> n) | n >= 0 = n
13:50:24 <kritzcreek> indiagreen:that reminds me of http://www.willamette.edu/~fruehr/haskell/evolution.html
13:51:26 <kritzcreek> btw I found this implementation for (<%~) l f = l (f &&& f)
13:54:05 <indiagreen> kritzcreek: awesome
13:54:16 <indiagreen> you get double bonus points
13:55:01 <kritzcreek> woohoo :D
13:55:20 <kritzcreek> is it cheating if hlint found the solution for me? :(
13:56:18 <indiagreen> yes
13:57:09 <indiagreen> but, well
13:57:20 <indiagreen> you still get a different kind of bonus points
13:57:56 <kritzcreek> I actually think hlint made me understand the Control.Arrow functions. Because it shows me whenever I repeat a pattern they solve
14:00:07 <quchen> Arrow is usually abused to be a tuple library, and not about using an abstraction over functions.
14:00:37 <quchen> I think Bifunctor, now that it's in Base, should replace it in this context.
14:01:02 <indiagreen> quchen: does Bifunctor have a replacement for &&&?
14:01:14 <indiagreen> I think it only has first, second, and *** (i.e. bimap)
14:02:33 <quchen> indiagreen: There's no built-in equivalent to (&&&), no.
14:03:08 <Guest45> total newbie here playing with haskell and ffi to try to write a library called from C. Why can't I export a foreign function with a type constraint rather than a real type? i.e. why doesn't ghc like line 31 here http://pastebin.com/U9yHKpks ?
14:03:29 <Guest45> is this just not possible with ffi?
14:04:12 <quchen> indiagreen: You can build it using the diagonal function of course,
14:04:14 <quchen> :t let diag x = (x,x) in \f g -> bimap f g . diag
14:04:15 <lambdabot> (c -> b) -> (c -> d) -> c -> (b, d)
14:05:09 <indiagreen> or ‚ÄúliftA2 (,) f f‚Äù
14:07:23 <Guest45> oh, there's #haskell-beginners, I'll head over there
14:08:56 <quchen> Guest45: The FFI is limited to a small subset of types that C understands. Typeclasses are not among that subset.
14:09:08 <BenCHammer> I love this language 
14:09:12 <BenCHammer> My god
14:09:20 <BenCHammer> Why can't c# have guards
14:09:40 <BenCHammer> I'm learning haskell now and there are so many things I want imperitive languages to have
14:10:04 <Guest45> quchen: but C just needs to know void * - right? All the typing is only relevant on the haskell side
14:10:05 <kritzcreek> indiagreen: The types for the "united" function are very confusing. You used a for the "s"ource type...
14:10:27 <Guest45> quchen: the type is completely opaque 
14:10:45 <indiagreen> kritzcreek: that's how it is in lens (but okay, I'll rename it from a to s)
14:11:24 <roboguy_> Guest45: type classes in Haskell don't just constrain types in that way, they also provide a set of methods you can use on those types
14:11:38 <quchen> Guest45: I'm not familiar enough with C to answer that, but it sounds right.
14:11:58 <quchen> Guest45: The "Foreign types" section of the Report talks about what types the FFI can use.
14:12:00 <roboguy_> Num provides (*), (+), negate, abs, etc. C has no concept of that kind of abstraction
14:12:52 <Guest45> roboguy_: but all C is seeing is a void * - the only functions it calls with that void * are the haskell exported ones. 
14:13:07 <Guest45> sorry, I'm probably not understanding what you're saying
14:13:29 <Guest45> quchen: the type is the same - stablePtr - no?
14:14:09 <Guest45> quechen: haskell must know its real type when I deref it?
14:14:47 <Guest45> anyway, looks like I can't do it
14:14:57 <Guest45> thanks quchen, roboguy_
14:15:23 <quchen> "StablePtr a" is the type, not just "StablePtr". Anyway, I'm not very familiar with the FFI so I'm afraid I can't go into much detail here.
14:15:43 <kritzcreek> Guest45: I think FPComplete released a library to ease FFI https://www.fpcomplete.com/blog/2015/05/inline-c
14:16:29 <Guest45> kritzcreek: interesting but the opposite of what I'm trying to do :)
14:17:08 <zoug> I'm working with a binary search tree type of structure, MessageTree, defined as either "Leaf" or "Node MessageTree Msg MessageTree" (msg being another structure). When I use a f'n and pattern-match against "tree1 msg tree2", where is my msg? which one is chosen by Haskell, the middle one? A random one?
14:17:17 <kritzcreek> oh yeah of course... dumb me! sry
14:17:20 <sergezu> I'm a FP noob. What should I read/watch to get into haskell?
14:17:41 <ely-se> sergezu: http://learnyouahaskell.com/
14:18:06 <vixlur> sergezu: https://github.com/bitemyapp/learnhaskell
14:18:12 <zoug> sergezu: join #haskell-beginners and look at the title, learnyouahaskell isn't actually recommanded
14:18:12 <KaneTW> @where learnhaskell
14:18:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:18:22 <KaneTW> i don't recommend lyah either
14:18:24 <zoug> yeah what vixlur and KaneTW said
14:18:27 <quchen> zoug: You cannot pattern match against partial constructors. When you have "Node Tree Msg Tree", you have to match against "Node a b c", "Node a b" is not an option.
14:18:43 <sergezu> learnyouahaskell was really bad if I started to read it
14:18:44 <sergezu> dunno
14:18:56 * quchen likes LYAH a lot.
14:19:01 <zoug> quchen: sorry, I meant pattern match against Node tree1 msg tree2
14:19:05 <sergezu> Thanks for the tips everybody
14:19:30 <zoug> I'm not sure where the msg would be in this binary search tree
14:19:38 <quchen> zoug: Pattern matching has the same order as the constructor in the data declaration.
14:19:52 <quchen> > let (a,b,c) = ("hello", 2, 3.14) in (a,b,c)
14:19:54 <lambdabot>  ("hello",2,3.14)
14:20:01 <kritzcreek> sergezu: I got loads of haskell intuition from reading https://leanpub.com/purescript
14:20:17 <quchen> zoug: I'm not sure what you mean with the question :-|
14:20:30 <sergezu> Is purescript the same as haskell?
14:20:33 <sergezu> or just related?
14:20:42 <zoug> quchen: yeah it's not clear in my head, not even enough to formulate it correctly
14:20:50 <quchen> sergezu: Purescript is heavily inspired by Haskell.
14:21:17 <slowbait> Why is learnyouahaskell not recommended?
14:21:23 <quchen> sergezu: It has different design goals though, such as a straight-forward translation to JS (relatively speaking), and not having the overhead of the full GHC runtime, etc.
14:21:38 <quchen> zoug: What's the overall problem you're trying to solve? Implement a binary tree?
14:22:11 <kritzcreek> sergezu: and it is a lot easier to get started with. In terms of setting up your environment
14:22:39 <zoug> quchen: I'm given a tree and it's of the form Leaf a b c d e ... z Leaf, for example. [a,b..z] being some messages of some sort of importance, and I need f'ns to work on those messages. So I'll just use something like test treeBelow msg treeAbove, and do whatever on the msg
14:23:18 <zoug> but I'm not sure where the msg is, in this example. Is it the middle of the tree, treeAbove being above and treeBelow being what's below?
14:23:30 <quchen> "Leaf a b c d e ‚Ä¶ z Leaf" isn't a tree format I recognize. Where's the tree there?
14:23:38 <quchen> It looks like a consecutive list of sorts.
14:24:34 <zoug> each of a b c .. are "Node what'sBelow msgX what'sAbove"
14:24:49 <zoug> at least that's what I understood
14:24:56 <zoug> then again I could be completely wrong
14:26:08 <quchen> Well the standard binary tree type in Haskell is "data Tree a = Empty | Node a (Tree a) (Tree a)".
14:26:17 <quchen> That's a node with up to two children.
14:26:49 <zoug> quchen: it's exactly that, but the Node is of the form Node (Tree a) a (Tree a) in cis194
14:27:09 <quchen> That's equivalent.
14:27:12 <zoug> so okey
14:27:35 <zoug> here, a, where is it when accessed through the f'n above?
14:27:53 <quchen> f (Node leftSubtree msg rightSubtree) = ‚Ä¶
14:27:54 <zoug> I mean, if you had to work with this, how would you use such a tree with a f'n?
14:27:59 <quchen> That's how you'd access your tree type.
14:28:05 <zoug> okey great
14:28:11 <zoug> where is msg here
14:28:13 <quchen> And then one case for "f Empty" as well of course.
14:28:14 <zoug> in your tree?
14:28:23 <zoug> the middle?
14:28:26 <quchen> Yes.
14:28:34 <zoug> okey, so the exact middle is taken?
14:29:03 <zoug> I don't know why but I just can't find this natural hahaha
14:29:08 <zoug> it's weirding me out
14:29:10 <quchen> Yes, because the "Node" constructor was defined to have the "a" value in the middle.
14:29:23 <quchen> It's the only sensible way to do this really, I wouldn't know any more natural way.
14:29:44 <zoug> thank you quchen you've been really helpful
14:29:53 <quchen> When you match on (a,b) then "a" will be the first element of the tuple.
14:29:54 <zoug> it's really nice of you
14:29:56 <quchen> Same thing here.
14:30:04 <zoug> yeah that part I got
14:30:59 <quchen> zoug: The inverse is constructing a node, which you would do with "Node leftSubtree msg rightSubtree" as well.
14:31:03 <kritzcreek> Is there a tool that can expand type synonyms automagically? It would help a lot to understand some of the Frameworks out there
14:31:23 <kritzcreek> I always find myself doing it manually...
14:33:11 * hackagebot invariant 0.2 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.2 (ryanglscott)
14:43:33 <Scorchin> Hello. I've just installed ghci and cabal-install on OS X. I'd like to use Network.Socket.ByteString. Do I need to install it using cabal or is it included in the stdlib?
14:43:48 <Scorchin> s/ghci/ghc
14:49:49 <indiagreen> kritzcreek: :kind!
14:50:01 <quchen> Scorchin: What happens when you use it?
14:50:04 <indiagreen>  > :kind! Lens String String Char Char
14:50:10 <indiagreen> Lens String String Char Char :: *
14:50:11 <indiagreen> = Functor f => (Char -> f Char) -> String -> f String
14:50:34 <MarcelineVQ> Scorchin, try in ghci: import Network.Socket.Bytestring
14:51:06 <Scorchin> I got the following output:
14:51:07 <MarcelineVQ> Or "import Network." and use tab completion for a list.
14:51:12 <Scorchin>     Could not find module ‚ÄòNetwork.Socket‚Äô
14:51:13 <Scorchin>     It is not a module in the current program, or in any known package.
14:51:26 <Scorchin> I just ran `cabal install network` and that fixed it
14:56:19 <geekosaur> Scorchin, you have to install it. ghc by itself comes with very little, you'll have to install pretty much anything you want to use
14:56:46 <Scorchin> Thanks. I previously got used to installing haskell-platform which was a bit more batteries-included
14:57:02 <kritzcreek> indiagreen: I'm looking for something that for example expands the type ScottyM from the Scotty Webframework
14:57:16 <indiagreen> kritzcreek: there's also :i
14:57:27 <indiagreen> sometimes :kind! is better, sometimes :i
14:57:38 <indiagreen> for instance, :i doesn't do substitution
14:57:49 <indiagreen> but :kind! doesn't expand stuff like String
14:57:51 <Scorchin> Okay, now for my actual question. I'm using Network.Socket.ByteString to recvFrom a socket. What's the easiest way to convert the received packet into a type that I have defined?
14:59:27 <kritzcreek> indiagreen: It would be nice to be able to do that on hackage. So you don't have to download the library to look at it
14:59:52 <indiagreen> it would be nice indeed, but you can always go and look at the definition of the synonym
15:01:18 <kritzcreek> that's the "manual" process I meant. Just expanding the definitions to a point where they become trivial.
15:08:04 <AaronFriel_> Anyone familiar with Network.HTTP.Client.Conduit?
15:12:01 <johnw> AaronFriel_: you may have more success if you just ask the question
15:12:32 <ReinH> Scorchin: Depends on how the value is encoded.
15:12:55 <Scorchin> ReinH: I'm trying to create a simple NTP client
15:12:57 <AaronFriel_> johnw: Thanks, didn't have one specific question.
15:13:08 <Scorchin> (as a learning exercise)
15:13:27 <ReinH> So probably you want a parser?
15:17:56 <Scorchin> That sounds about right
15:18:01 <Scorchin> but that might be jumping too far
15:18:09 <Scorchin> I'm still very much a beginner
15:18:27 <Scorchin> one of the components of the response is a leap indicator
15:18:31 <ely-se> In a lecture SPJ said that having both subtyping and higher-kinded types is difficult. Why is that so?
15:18:42 <Scorchin> it looks like this: data LeapIndicator = NoWarning | LastMinuteHas61Seconds | LastMinuteHas59Seconds | ClockUnsynchronised
15:19:06 <Scorchin> each of those values is assigned to an integer value, so 1, 2, 3, 4, respectively
15:19:21 <Scorchin> is there a simple way to do convert an int to LeapIndicator?
15:19:45 <Scorchin> or is that something I need to do using a where/case function?
15:21:10 <Scorchin> and is there, similarly, an easy way to encode LeapIndicator into an integer?
15:21:28 <roboguy_> Scorchin: you can add a deriving Enum
15:21:37 <roboguy_> :t fromEnum
15:21:38 <lambdabot> Enum a => a -> Int
15:21:52 <Scorchin> oooh
15:22:07 <Scorchin> does that expect increasing integers?
15:22:16 <nolraiU> So if I try "stack upgrade" it tries to look for a base <0. This seems wrong.
15:22:21 <roboguy_> Scorchin: what do you mean?
15:23:14 <Scorchin> there will be a point where for one of the fields in the packet I'll need to jump integers (according to the RFC spec) where the named types will be 1, 2, 3, 4, 5, 7, 31, 34
15:23:51 <ReinH> Enum is probably not what you want.
15:24:46 <ReinH> For binary encodings, look at the binary package. Otherwise, parsing is a very common strategy in Haskell because the tooling is strong.
15:26:35 <Scorchin> Okay, thanks ReinH. I'll look into that.
15:26:55 <Peaker> johnw: you still there?
15:27:44 <johnw> Peaker: yes
15:28:28 <Peaker> johnw: https://gist.github.com/Peaker/e1afbbcaf71b9c0cdb40 <-- you were just missing a "Foo" in the "Foo" constructor of "data Foo a r"
15:28:56 <Peaker> johnw: you wrote "Foo a r", pretty sure you meant to recurse on the type "Foo" but you made a data constructor Foo and tried to have a field of type "r" (but "r" is not a *)
15:29:04 <johnw> you can't recurse with Foo a r
15:29:07 <Peaker> johnw: you can! :)
15:29:13 <johnw> I don't you can't syntactically
15:29:22 <johnw> i mean that that's not the point of a fixed-point
15:29:40 <Peaker> well, you recurse on Fst and Snd of r, not on r
15:29:40 <johnw> the whole point of "r" is that it substitutes for your recursor
15:30:01 <Peaker> (and you can pass "r" itself too)
15:30:08 <johnw> I couldn't pass r itself
15:30:43 <Peaker> to whom?
15:30:47 <johnw> Foo r
15:30:52 <Peaker> you put "r" itself as a *data* field of a "Foo" constructor
15:30:53 <johnw> I don't know what you mean by "pass" then
15:31:03 <Peaker> (but of course no value of type "r" can exist)
15:31:12 <johnw> that's true enough
15:31:17 <johnw> how then do you plumb r throughout the tree?
15:31:53 <johnw> well, you can always give it a try, that will be the surest answer
15:31:57 <Peaker> sec I'll write&paste
15:33:38 <mpickering> Is it possible to compile libraries with ghcjs which depend on the ghc api?
15:34:06 <minad> jmcarthur_: hi! still there?
15:34:46 <Peaker> johnw: I think this is the core: type FixPair = '(Fix Type, Fix Record) ; newtype Fix f = Fix (f FixPair)
15:35:19 <Peaker> johnw: So "Fix Type" is equivalent to the old-style type, and ditto for "Fix Record"
15:35:40 <Peaker> johnw: a bit crazy :)
15:36:03 <johnw> when you have more code, I'd be happy to take a look
15:36:32 <Peaker> Sure, I'll try this out.. I wrote AlgoW from scratch today, I think it's my 6th attempt at a type system or so, and now it went really quickly :)
15:36:48 <Peaker> Like a few hours for an ST mutation based one (for basic Lam|Var|App -> TFun|TVar)
15:36:57 <Peaker> Practice makes perfect!
15:37:57 <ski> Peaker : what is `Type' and `Record' there ?
15:38:27 <Peaker> ski: Type AST which has a Record AST in it under a TRecord constructor, which has a Type AST in its field types
15:39:06 <Peaker> for a language that has type arrows (a -> b)  and "row polymorphism"  { x : a, y : b | r1 }  (r1 represents more fields)
15:39:26 <EvilMachine> > let wait s = or $ (replicate (1.5625e7*s) False ++ [True])
15:39:27 <lambdabot>  <no location info>:
15:39:27 <lambdabot>      not an expression: ‚Äòlet wait s = or $ (replicate (1.5625e7*s) False ++ [...
15:39:40 <EvilMachine> > let wait s = or $ (replicate (1.5625e7*s) False ++ [True]) in wait 5
15:39:41 <lambdabot>      No instance for (Fractional Int)
15:39:41 <lambdabot>        arising from the literal ‚Äò1.5625e7‚Äô
15:39:41 <lambdabot>      In the first argument of ‚Äò(*)‚Äô, namely ‚Äò1.5625e7‚Äô
15:40:00 <EvilMachine> > let wait s = or $ (replicate (15625000*s) False ++ [True]) in wait 5
15:40:02 <Peaker> ski: so a record is either Empty, or a "Var" (rest-of-fields record-var), or a "RecExtend" with a single field of the former two
15:40:03 <lambdabot>  mueval-core: Time limit exceeded
15:40:10 <EvilMachine> > let wait s = or $ (replicate (15625000*s) False ++ [True]) in wait 4
15:40:14 <lambdabot>  mueval-core: Time limit exceeded
15:40:17 <EvilMachine> > let wait s = or $ (replicate (15625000*s) False ++ [True]) in wait 3
15:40:21 <lambdabot>  mueval-core: Time limit exceeded
15:40:21 <Peaker> (where a field is just a name and a Type)
15:40:23 <EvilMachine> > let wait s = or $ (replicate (15625000*s) False ++ [True]) in wait 2
15:40:27 <lambdabot>  mueval-core: Time limit exceeded
15:40:29 <EvilMachine> > let wait s = or $ (replicate (15625000*s) False ++ [True]) in wait 1
15:40:31 <ReinH> EvilMachine: Please msg lambdabot
15:40:32 <lambdabot>  True
15:40:56 <EvilMachine> ReinH: Oh‚Ä¶ right‚Ä¶ sorry‚Ä¶ didn‚Äôt intend to spam
15:41:38 <EvilMachine> ReinH: Intentionally I intended it to be just one try, and maybe be funny. :)
15:42:28 <ski> Peaker : i don't follow :/
15:42:59 <roboguy_> does template haskell have access to the "deriving" mechanism? Can you send it a data type and get access to the code it would generate in a deriving clause?
15:43:07 <ski> (and i didn't understand why you had two different kind of non-empty records)
15:44:19 <Peaker> ski: A non-empty record is RecExtend (Name, Type) {-smaller record being extended-}Record
15:44:27 <Peaker> ski: An empty record is a RecEmpty
15:45:06 <Peaker> ski: But there is also a "record-variable" for an unknown record: RecVar Name  -- representing some set of unknown fields (i.e: the "r1" in: "{ x : Int, y : Int | r1 }")
15:45:32 <Peaker> ski: thus: data Record = RecEmpty | RecExtend (Name, Type) Record | RecVar Name
15:45:48 <Xnuk> I just removed .hi and .hs file, but .o file and compiled binary file still remains. Can I recover the .hs file?
15:46:21 <Peaker> Xnuk: oy vey, did you close your editor? No source control?
15:46:38 <Xnuk> Peaker: Yes...
15:46:55 <mauke> Xnuk: no
15:47:27 <Peaker> Xnuk: it would most likely be less effort to re-do the work than reverse engineer it from the .o, unfortunately
15:49:10 <jle`> is there any way to check of a package uses template haskell, or depends on a package that does
15:49:12 <jle`> ?
15:49:18 <jle`> maybe ghc compilation with TH disabled?
15:49:19 <ski> Peaker : oh, this is an abstract syntax tree. for some strange reason i was reading algebraic (or abstract) data type
15:50:00 <ski> Peaker : mhm .. and you wanted to untie the recursion ?
15:50:14 <Peaker> ski: Yeah, though I have multiple "fixpoints"
15:50:21 <ReinH> your periodic reminder: source control.
15:50:21 <Peaker> (mutual recursion)
15:50:23 <ski> Peaker : mutual recursion ?
15:50:26 <ski> heh
15:50:32 <Peaker> (Record, Type)
15:50:44 <roboguy_> jle`: you could look in the .cabal file and then grep the source files for LANGUAGE TemplateHaskell
15:51:02 <ski> so you'd like `((*,*) -> (*,*)) -> (*,*)' ?
15:51:03 <roboguy_> not sure about depending on a package that uses it
15:51:19 <ReinH> roboguy_: And then so so for the transitive closure of dependencies ;)
15:51:26 <ReinH> *do so
15:51:55 <ski> or perhaps you're using `((Tag -> *) -> (Tag -> *)) -> (Tag -> *)', where `Tag' would be a datakind, in your case with two constructors
15:52:59 <Peaker> ski: ((*, *) -> *) -> * I think
15:54:29 <ski> Peaker : hm, not sure how that'd work
15:54:43 <Peaker> I had to enable StandaloneDeriving, UndecidableInstances, FlexibleContexts, so far
15:55:06 <Peaker> (of course with more than 1 fixpoint I auto-lose my auto-Functor, Foldable, Traversable :-( )
15:57:38 <Peaker> GHC kind errors are terrible! "Expected type: Map String (TS s Type), Actual type: Map String (TS s Type)"
15:57:46 <Peaker> "Couldn't match kind ‚Äòk‚Äô with ‚ÄòAnyK‚Äô ‚Ä¶"
15:57:47 <ski> Peaker : so how does the definition of `Type' look like ? (possibly omitting some cases that doesn't involve `Record', if you prefer)
15:58:08 * ski thinks `AnyK' is silly
15:58:14 * hackagebot inilist 0.2.0.0 - Processing for .ini files with duplicate sections and options  https://hackage.haskell.org/package/inilist-0.2.0.0 (MikeMeyer)
15:58:17 <Peaker> What is AnyK?
15:59:11 <Scorchin> In Haskell, is there an easy way to convert an integer to a defined type that holds that integer? The equivalent in OCaml would look something like this:
15:59:27 <Scorchin> https://www.irccloud.com/pastebin/IlVQ43e3/stratum.ml
15:59:32 <ski> Peaker : i'm not sure if it comes from internal type checking here, or from some library being used. but to my eyes, it looks like a (failed) attempt to have a skolem
16:00:02 <Scorchin> the important thing is to select the correct type based on the defined integer ranges in the `int_to_stratum` function
16:00:18 <ski> either it's just a strange-looking error, or it might perhaps hint at such a failed attempt
16:00:22 <Peaker> Scorchin: the correct constructor, you mean?
16:00:37 <Peaker> ski: the continuation of the error suggests it is a kind skolem
16:00:38 <Scorchin> Peaker: what do you mean?
16:01:37 <koomi> Scorchin: you can more or less directly translate that code to haskell
16:02:16 <Scorchin> I'd like to remove the need for the two functions. I'd like to know if there's a way to use Haskell's type system to do that work for me
16:02:23 <Drezil> what do you guys think about "watch me code my stuff"-haskell-streams?
16:02:31 <Scorchin> so I can do something like `1 :: Stratum` in my code
16:02:54 <Drezil> not much explanation .. just doing some work that needs to be done anyway while others can watch & ask questions?
16:02:59 <koomi> Scorchin: you'd have to define a Num instance for Stratum
16:03:04 <roboguy_> Scorchin: you could make it a Num instance. I wouldn't suggest it though
16:03:10 <roboguy_> you lose compile time checking
16:03:17 <Scorchin> roboguy_: what would you suggest?
16:03:38 <lpaste_> Peaker pasted ‚ÄúHaskell conversion of OCmal code‚Äù at http://lpaste.net/137352
16:03:39 <roboguy_> Scorchin: using the constructors directly, so that your code can be verified a bit further at compile time
16:03:46 <nolraiU> Make a num instance.
16:03:48 <johnw> Peaker: I'd submit a bug to the GHC Trac (if it's not already), that if two types would print to the same string in an output, but have different kinds, that kind signatures be displayed to help clarify
16:03:50 <roboguy_> you can't have an out of range number that way
16:03:52 <Peaker> Scorchin: ^^ http://lpaste.net/137352
16:04:45 <nolraiU> Whats a skolem?
16:04:46 <ski> Scorchin : `SecondaryReference(x)',`Reserved(x)' can be replaced by `SecondaryReference x',`Reserved x'. `raise(Malformed_packet(sprintf "no such stratum exists: %i" x))' would in my eyes read better as `raise (Malformed_packet (sprintf "no such stratum exists: %i" x))'
16:06:23 <Scorchin> So what I'd like to be able to do is create a Stratum using `Stratum 1`, but behind the scenes it would assign that to PrimaryReference. Is there a way to use the type system to do that?
16:07:24 <ski> nolraiU : an unknown type, a type someone else chooses for you
16:07:56 <Peaker> Scorchin: The upper case "s" there means it's a "data constructor", not a function, so it cannot do any sort of verification or much on its input
16:08:04 <Peaker> Scorchin: but "stratum 1" can do it :)
16:08:30 <Scorchin> Oh. So it's not possible to get data constructors to do that?
16:08:51 <nolraiU> No, but you can fake it in a couple of ways.
16:09:41 <Scorchin> The main reason I want to do this is because I'll have a bunch of functions that Stratums share. Then there will be subset of specialisations for each of the sub-kinds like KissOfDeath, PrimaryReference et al
16:10:37 <Scorchin> and I want to be able to parse the stratum field from a byte string, and to make it easier I just want to tell the parser that it's a stratum without having to inline the case/where code in the parser
16:10:43 <johnw> nolraiU: further, skolems don't exist as actual types in your code; they are generated types used to satisfy a type unification, which is why we call them skolems rather than ordinary types
16:11:02 <Scorchin> that feels like something a type should be able to do, otherwise I may as well use a dynamic prog lang
16:11:17 <johnw> the "s" in "ST s a" is satisified by a skolem when you use runST :: (forall s. ST s a) -> a
16:11:18 <roboguy_> Scorchin: I believe it's possible, but if it is it would be a bit tricky
16:12:06 <ski> nolraiU : "skolems" vs. "meta/logic/dataflow variables" are (or can be seen as) names for roles that type variables can have in your code
16:12:16 <hyyper> @lyah
16:12:16 <lambdabot> Unknown command, try @list
16:12:18 <roboguy_> Scorchin: oh, do you want it to read in a number like "1" from somewhere external and then give you back PrimaryReference (as opposed to using the numeric literal 1 in your code)
16:12:21 <johnw> which works because runST doesn't ever use the 's', it simply gets carried around as a phantom types, so that no skolem from a subsequent runST will ever match against the one used in that execution
16:12:33 <ski> nolraiU : if you may choose the type for the tyvar, then it's a metavar. if the opponent chooses, then it's a skolem
16:12:34 <hyyper> guys, where's that cis194 or cis193 or whatever course?
16:12:59 <Scorchin> roboguy_: Yup. And in special cases like SecondaryReference I'd like it to hold the integer value (because it's a range)
16:13:07 <peddie> @where cis194
16:13:07 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:13:08 <rcyr> hyyper: https://github.com/bitemyapp/learnhaskell
16:13:22 <roboguy_> Scorchin: if it comes in externally, how can the type system check it statically?
16:13:45 <Scorchin> hmmm, true
16:14:06 <Scorchin> I think I'm expecting Haskell to do some magic that it clearly doesn't do
16:14:09 <Scorchin> :/
16:14:15 <Scorchin> Best go back to the drawing board
16:14:31 <johnw> sometimes, Haskell expects magic from you, in the form of finding a better solution :)
16:14:57 <ski> nolraiU : if you have `foo :: forall a. T a -> (exists b. U a b))', then (from the POV of `foo' itself) `a' is a skolem, and `b' is a metavar. (from the POV of someone calling `foo', it's the other way around). in `bar :: (forall a. T a) -> (exists b. U b) -> V', from the POV of `bar', `a' is a metavar, and `b' a skolem (And vice versa again for callers)
16:15:06 <nolraiU> Yes.
16:15:06 <roboguy_> Scorchin: If you were talking about statically checking numeric literals in the code itself, I can imagine that being possible. But not statically checking something that you only know at run time
16:15:51 <nolraiU> Yeah..I think you need time travel for that..>.<
16:17:49 <Peaker> Hah: "Could not deduce (RRecord b ~ RRecord a) from the context (RRecord a ~ RRecord b, Applicative f)..."
16:17:59 <Peaker> johnw: I think this is fertile ground for GHC issues :)
16:18:52 <Peaker> Type equality is not commutative?
16:18:53 <ski> nolraiU : in the MLs, sometimes an operation with inferred type variables in the type can't be generalized (due to value restriction, due to otherwise unsafe interaction between polymorphism and side-effects). in the OCaml interactor, it'll show you the inferred type as involving metavariables (which start with an `_', iirc). as soon as you use such an operation so that the metavar gets instantiated, that gets stuck (so it's like you had used an explicity t
16:19:01 <hyyper> rcyr, I need this book, how much does it cost?: http://www.haskellcraft.com/craft3e/Home.html
16:19:13 <ski> nolraiU : er, cut off near ".. as soon as you use such an operation so that the metavar gets instantiated, that gets stuck (so it's like you had used an explicity type ascription with that concrete type at the outset)"
16:19:19 <Peaker> Oh, I guess it's a case of "a" and "b" referring to different things in the same error line
16:20:01 <roboguy_> Peaker: that sounds confusing enough to be a bug
16:20:14 <ski> nolraiU : in SML/NJ, it immediatelly instantiates the (ungeneeralizable) metavar with a (fresh) skolem (named like `?.X1',`?.X2',...) .. so you can't actually use a real concrete type there, so it's less useful, but of course still safe
16:21:20 <ski> nolraiU : istr encountering some kind of skolem or skolem simulation in GHC, but where instead of generating fresh skolems, they had one (or a few ?) or built-in ones. no idea if that's still present somewhere
16:21:53 <ski> nolraiU : oh, and yet another name for metavar is placeholder (maybe also hole ?)
16:23:15 * hackagebot pipes-safe 2.2.3 - Safety for the pipes ecosystem  https://hackage.haskell.org/package/pipes-safe-2.2.3 (GabrielGonzalez)
16:23:44 <ski> nolraiU : the "logic variable" name is probably mostly used in logic programming contexts (and "dataflow variable" is used at least in Oz, which is more or less logic programming, but with disjunction not as built-in, while the dataflow variable is enabled for concurrency (*declarative* concurrency, see CTM) (there's also a "read-only" variant of it you can sent to other threads, iirc))
16:23:51 <hyyper> ok will somebody attempt to teach me the basics of programming like this book would?: http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957
16:26:35 <Peaker> johnw: making slow progress, but I fear the result is quite incomprehensible, heh
16:28:30 <johnw> passing multiple type variables isn't the worst thing in the world
16:28:59 <nolraiU> ski: I've never done any logic programing.
16:30:00 <roboguy_> hyyper: it's better to ask specific questions
16:30:58 <roboguy_> usually you pay a college professor to fully teach you something like the basics of programming, so here it is better to ask about specific things
16:31:47 <Peaker> johnw: as I'm learning...
16:31:54 <ski> nolraiU : CTM talks about three conceptually different stages in making a variable refer to a value : (a) bringing the variable into scope; (b) instantiating the variable with a computation (/expression) that will eventually yield a value; (c) actually forcing the computation
16:33:19 <ski> nolraiU : the most common is to do (a-c) at the same time. Haskell separates (a-b) from (c). Prolog separates (a) from (b-c) (though the notion of "expression" there is more degenerate). Oz (language of CTM) allows separating all three
16:35:17 <Nik05> how do you read lhs files?
16:40:02 <johnw> Nik05: you can use pandoc to turn them into HTML
16:43:16 * hackagebot pipes-async 0.1.0 - A higher-level interface to using concurrency with pipes  https://hackage.haskell.org/package/pipes-async-0.1.0 (JohnWiegley)
16:45:09 <Peaker> GHC infers a type successfully, but copying the inferred type from the -Wall warning doesn't work
16:45:50 <lpaste_> Peaker pasted ‚ÄúSome craziness‚Äù at http://lpaste.net/137358
16:45:59 <Peaker> johnw: Here's my intermediate craziness 
16:48:38 <johnw> Peaker: well, if it makes you happy... :)
16:48:50 <Peaker> johnw: it makes me fight GHC, mostly :)
16:49:17 <Peaker> johnw: I can't give an explicit type to typeTypes and the other 3 traversals!!
16:49:32 <Peaker> (infer works, but can't figure out what the explicit type that GHC would accept)
16:49:42 <johnw> doesn't -Wall tell you?
16:49:51 <Peaker> What it says doesn't work
16:49:57 <johnw> report it!
16:50:17 <johnw> I'm pretty sure the GHC devs would want to know this
16:50:41 <lpaste_> Peaker pasted ‚Äú-Wall and other lies‚Äù at http://lpaste.net/137359
16:50:57 <johnw> use the forall's
16:51:23 <Peaker> With the "BOX"?
16:52:52 <Peaker> johnw: doesn't work with the BOX (missing name, and complaint about use as both type and kind var). Without the BOX, syntax error for (,) k k1,  converted to infix (k, k1) and then I get the original error (without foralls)
16:53:00 <johnw> i remember seeing it in the presentation on higher-kinded types
16:53:59 <johnw> yep, I'd report this
16:54:18 <johnw> you're adventuring in territory not many people are working in, I'd imagine
16:54:26 <Peaker> yeah, apparently :)
16:56:00 <IuseNoName> Someone post some cryptic haskell
16:57:05 <johnw> > "00:00:00" & upon (tail.tail).partsOf (biplate.filtered (== '0')) .~ "1234"
16:57:07 <lambdabot>  "00:12:34"
16:58:14 <Peaker> upon is that super-magical reader becomes writer thing? 
16:58:15 <barrucadu>  That is pretty cryptic
16:58:40 <IuseNoName> more cryptic?
16:58:50 <Peaker> @index upon
16:58:50 <lambdabot> bzzt
16:59:01 <Peaker> where's upon from? My Control.Lens doesn't have it
16:59:06 <johnw> IuseNoName: what's the reason for asking?
16:59:10 <nolraiU> I can understand what its doing on second read through, thats not that crypic.
16:59:41 <IuseNoName> johnw: I am amazed how cryptic the language can get.
17:06:13 <khanage> how insane is pipes for a relative noob?
17:06:35 <khanage> i *think* i need a network proxy
17:06:50 <khanage> and i found something built on pipes that seems to do the trick
17:06:53 <roboguy_> khanage: try and find out!
17:06:55 <c_wraith> pipes is pretty simple, conceptually.
17:06:58 <khanage> roboguy_: haha
17:07:03 <roboguy_> really
17:07:12 <khanage> ok
17:07:45 <khanage> let's see how i go
17:14:32 <sloppyjoes> I thought ghci was supposed to be super strict
17:14:45 <sloppyjoes> how come `reverse [1..]` gets by
17:15:15 <roboguy_> sloppyjoes: strict in what sense?
17:15:57 <sloppyjoes> like if you try to do something that is impossible it'll figue that out and slap you on the wrist
17:16:08 <c_wraith> if it's a *type* error, sure
17:16:13 <c_wraith> But that's not a type error
17:16:19 <roboguy_> nope. It's impossible to know what's impossible in general
17:16:36 <kadoban> sloppyjoes: Only to a certain extent. Fun fact, but you actually can't have a turing complete language that will always tell you when what you're trying will never complete.
17:16:52 <c_wraith> This is why turing complete is not a worthy goal. :)
17:16:55 <kadoban> lambdabot: GHC doesn't even try, and the Haskell type system doesn't really capture that.
17:17:41 <sloppyjoes> Interesting. I suppose it is not the responsibility of the compiler to look at your code philosophically 
17:17:44 <sloppyjoes> thanks all
17:18:59 <roboguy_> sloppyjoes: well, it is impossible for *any* computer program to be able to tell you if some arbitrary code (written in a Turing complete language like Haskell) will go into an infinite loop
17:19:30 <minad> hi, how is this usually written: you have a state monad and in the do block, a get of the current state, followed by a modify some operation and then a modify back to the old state?
17:20:17 <Iceland_jack> minad: Can you be more clear about what follows the get
17:20:29 <roboguy_> Maybe something like do { originalState <- get; modify someOperation; put originalState }
17:20:45 <kadoban> sloppyjoes: Well, it's not necessarily not the responsibility of the compiler. It's just that haskell's type system isn't powerful enough to do that very well. There's other languages where you can do that, but it's currently more work for the programmer (and compiler).
17:20:58 <Iceland_jack> minad: roboguy_ ‚Üë
17:21:12 <minad> roboguy_: yes something like that. I thought there is maybe something like saveState?
17:21:35 <Iceland_jack> minad: There is 'local' for Reader, where you can locally change the environment
17:21:57 <Iceland_jack> :t local (+ 1) :: Reader Int a -> Reader Int a 
17:21:58 <lambdabot> Reader Int a -> Reader Int a
17:22:19 <sloppyjoes> I see. Ah, I haven't been up on my csci,  but I do remember that checking for infinite loops is one of the more famous undoable things in programming
17:23:00 <minad> Icelan_jack, roboguy_: seems to be what I was looking for. thx. I take a look at the docs :)
17:23:19 <arkeet> what's the point of modifying the state if you're just going to undo it?
17:24:07 <arkeet> do you have some other state action you want to run with the new state?
17:24:10 <roboguy_> ^ that's what I was wondering to
17:24:12 <roboguy_> *too
17:24:40 <minad> arkeet: I want to do some tree traversal, and the state should only be changed for a subtree
17:25:15 <minad> maybe thats stupid and I am thinking to imperative?
17:26:00 <roboguy_> minad: sometimes things are better expressed with state, it depends
17:27:01 <khanage> minad: maybe try running a sub computation with that state?
17:27:15 <khanage> as in
17:27:55 <roboguy_> minad: I feel like Reader and local is most likely what you're looking for
17:28:05 <khanage> runState (someOperation *current state*)
17:33:45 <minad> khanage, roboguy_: I think both solutions would work. currently I have one ugly state record which is passed around. probably it would be better to create such a substate which will then be used only for the sub computation
17:34:10 <khanage> minad: but if you aren't using the modified results, you may not need state?
17:34:18 <johnw> khanage: pipes is very simple
17:34:43 <khanage> johnw: yeah, i'm just reading through the Pipe.Prelude - it seems ok thus far
17:34:48 <arkeet> Reader is just functions
17:34:52 <arkeet> maybe you can just use functions
17:35:03 <arkeet> :t local
17:35:04 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
17:35:07 <khanage> johnw: plus there's a 24 days of hackage article on it, which always helps me :)
17:35:35 <arkeet> :t [local, (.)]
17:35:38 <lambdabot> [(a -> a) -> (a -> a) -> a -> a]
17:35:40 <Iceland_jack> > local succ ask 'a'
17:35:41 <lambdabot>  'b'
17:35:43 <arkeet> oh.
17:35:46 <arkeet> :t [local, flip (.)]
17:35:47 <lambdabot> [(b -> b) -> (b -> a) -> b -> a]
17:35:55 <Iceland_jack> > local succ (local succ ask) 'a'
17:35:56 <lambdabot>  'c'
17:36:02 <Iceland_jack> just functions
17:36:53 <arkeet> using local makes the most sense with ReaderT or some other monad transformer stack imo
17:36:59 <arkeet> otherwise it's just function composition
17:37:10 <johnw> conceptually, you take a simple get/put term algebra: data T a b r = Get (a -> r) | Put b r.  Then upgrade it to be bidirectional: data T a' a b' b r = Get a' (a -> r) | Put b (b' -> r).  Now apply FreeT: type Proxy a' a b' b m r = FreeT (T a' a b' b) m r...  and you have pipes.  The real Proxy differs only because it fuses these elements together, but it's isomorphic.
17:38:17 <minad> the problem is the monad stack that I am dealing with. I have these functions Node -> m Node which traverse the tree and while traversing I remember some data
17:38:48 <khanage> johnw: what's FreeT?
17:39:22 <minad> khanage, arkeet: thx for now. I have to play a bit around :)
17:39:56 <khanage> johnw: or, is it ok to not know and just accept the types for now?
17:40:14 <arkeet> actually, local can be used with State too. heh
17:40:20 <arkeet> since State has a MonadReader instance
17:40:44 <johnw> khanage: yeah, it's fine not to know
17:41:10 <khanage> johnw: i just had a look on hackage and it looks like it might be a bit of rabbit hole :)
17:41:39 <johnw> what, FreeT?
17:42:36 <khanage> yeah, unFreeT :: m (Either a (f (FreeT f m a)))
17:54:36 <johnw> I'd leave that rabbit hole for another day :)
17:54:40 <johnw> but it's a fun one
18:32:23 <benzrf> unfree?
18:32:33 <benzrf> rms would be disappointed in you
18:32:35 <benzrf> smh
18:39:17 <voidzero> FreeT Phone Home
18:40:53 <jmcarthur_> oh! i just now noticed that the bundles implementation of vector was released to hackage
18:52:43 <dramforever> wow now haddocks have links in highlighted source code!
19:10:21 <Zemyla> Why do modify functions (like modifySTRef) return () instead of the new value inserted into the argument?
19:10:53 <dramforever> Zemyla: I think because 1. it's cleaner
19:11:07 <dramforever> 2. it wouldn't be very much easier to use even if it did
19:11:21 <nolraiU> dramforever: How so?
19:11:22 <y> the current usages wouldn't change 
19:11:33 <dramforever> hmm wait wait
19:11:33 <Zemyla> Like modifySTRef would become STRef s a -> (a -> a) -> ST s a.
19:11:44 <dramforever> you got a point there
19:12:13 <dramforever> that's interesting
19:12:30 <Zemyla> Like, almost no one depends on the fact that it returns ().
19:13:05 <Zemyla> Though actually, there's people who do if b then modifySTRef r f else return ().
19:13:19 <dramforever> Zemyla: wait that would trigger a warning
19:13:43 <Hafydd> when b (modifySTRef r f)
19:13:49 <Zemyla> I thought it would be an error.
19:14:41 <dramforever> oh I meant something like this:
19:14:56 <dramforever> do ... modifySTRef r f ...
19:15:14 <dramforever> without a _ <-, ghc will complain about that a silently ignored
19:15:20 <y> that's an useless warning, though
19:15:53 <nolraiU> And adding _ <- is easy.
19:16:07 <y> I would disable the useless warning
19:16:15 <Intolerable1> there's also void
19:16:17 <nolraiU> I find it sort of useful.
19:16:28 <nolraiU> I like "_ <-" better my self..
19:18:56 <ski> imho, that name `void' only ought to be used for FFI stuff (if at all)
19:19:38 <y> it feels a bit nasty, though
19:19:49 <y> the name seems misleading
19:20:06 <ski> (renamed to something like `ignore' (the ML name for the corresponding thing), i think it would be fine)
19:20:26 <Intolerable1> i like the name
19:20:42 <Intolerable1> i just wish void and Void didn't both exist
19:20:43 <nolraiU> It makes sense as verb, not so much as a noun.
19:20:51 <ski> `void' here suggests the sense of `void' in languages like C,C++,Java,C#
19:21:20 <ski> (ignoring `void *'), that `void' is `()' in Haskell, pronounced "unit"
19:21:20 <nolraiU> Which is out () type.
19:21:51 <nolraiU> toUnit would be a fine name.
19:22:28 <ski> (while `Void' and `void' are common names for a data type with zero terminating values (zero data constructors, i think is the appropriate thing))
19:22:30 <Zemyla> So what is the equivalent of our Void type in something like C++?
19:23:06 <nolraiU> There isn't one?
19:24:29 <Zemyla> True, languages where the type system isn't as important don't need a Void type.
19:24:41 <Zemyla> :t fix absurd
19:24:42 <lambdabot> Not in scope: ‚Äòabsurd‚Äô
19:24:53 <nolraiU> Haskell doesn't really need it.
19:24:58 <Zemyla> @let import Data.Void
19:24:59 <lambdabot>  Defined.
19:25:03 <nolraiU> I mean its useful..
19:25:23 <Zemyla> > fix absurd
19:25:27 <lambdabot>  mueval-core: Time limit exceeded
19:25:41 <y> @type absurd
19:25:42 <lambdabot> Void -> a
19:25:56 <ski> Zemyla : hm. at least in GCC C, a return type of `void', together with `__attribute__ ((noreturn))'
19:25:57 <y> we always have undefined too
19:26:50 <Zemyla> I should learn Agda.
19:26:54 <ski> @djinn Void -> a
19:26:54 <lambdabot> f = void
19:27:18 <Zemyla> @djinn a -> Void
19:27:18 <lambdabot> -- f cannot be realized.
19:28:52 <y> Zemyla: "a -> Void" ~ "Not a", so it'd mean you could derive any negation out of thin air :p 
19:31:37 <Zemyla> Also, Void = forall r. r, but forall r. (a -> r) -> r ‚â† (a -> Void) -> Void.
19:34:52 <bob_twinkles> is there a way to get stack to install libraries from a location on disk?
19:35:16 <y> Zemyla: (a -> Void) -> Void is (a -> (forall r. r) -> (forall r. r) 
19:35:38 <bob_twinkles> i.e. if I have some library in liba/ (with liba/stack.yaml, liba/liba.cabal) is there a way to install it in a place that stack can find it when building exeb, in some other directory?
19:35:39 <y> which would be forall r.2 (forall r1. a -> r1) -> r2
19:35:55 <y> forall r2. (forall r1. a -> r1) -> r2     **
19:36:10 <Zemyla> Ahh, okay.
19:36:20 <ski> yes, ‚åú‚àÄ œâ. (Œ± ‚Üí œâ) ‚Üí œâ‚åù is not ‚åú(Œ± ‚Üí ‚àÄ œâ. œâ) ‚Üí ‚àÄ œâ. œâ‚åù
19:36:43 <Zemyla> And it also means that Not (Not a) ‚â† a.
19:37:19 <ski> yes
19:37:47 <ski> (probably this argument relies on parametricity)
19:39:29 <Zemyla> Though having a value of type (a -> Void) -> Void means you have a value of type a, just not in any form anyone can get to.
19:40:21 <nolraiU> <bob_twinkles>: I think so yes.
19:40:50 <bob_twinkles> so do I, but I've spent the last hour or so trying to find it and gotten a whole lot of nothing =P
19:41:13 <bob_twinkles> the closest I've come up with is creating my own package index and that seems like overkill...
19:42:14 <bob_twinkles> I thought "stack install path/to/liba" might work, but no joy =(
19:43:14 <Zemyla> I just realized what Twenty Questions is.
19:43:38 <Zemyla> It's calculating a from (a -> Bool) -> Bool.
19:45:57 <ski> @djinn (Either a (a -> Void) -> Void) -> Void
19:45:57 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
19:46:13 <ski> Zemyla : where is the value of type `Either a (a -> Void)' hiding in there ^ ?
19:46:24 <murphxyz> If you were just starting out with haskell, and you were writing a small app to run on a small server, and you wanted a file-based database (like sqlite, for example) what db / library would you choose?
19:46:49 <murphxyz> (sorry to drop in that question without any ceremony ^)
19:46:59 <Welkin> murphxyz: I think persistent supports sqlite
19:47:03 <Welkin> I use it with postgres
19:47:12 <murphxyz> great! I'll look into it. Thanks!
19:47:13 <freeman42> is there a way to make haskell stack always append --arch=x86_64 to commands to which it applies? was getting "GHC version mismatched, found 7.8.4 (x86_64), but expected version 7.8.4 (i386) (based on resolver setting in D:\Forks\snowdrift\stack.yaml). Try running stack setup"
19:47:34 <freeman42> and it only built after adding --arch=x86_64, I had setup stack with that arch beforehand
19:47:39 <Welkin> murphxyz: https://hackage.haskell.org/package/persistent-sqlite
19:48:11 <lethjakman> murphxyz: persistent is awesome, but it does have a lot of magic. there's a good chapter in real world haskell about DB stuff too. 
19:48:18 <lethjakman> and by magic I mean template haskell
19:48:19 <ski> (btw, the call to `void' there is `id :: Void -> Void')
19:48:26 <lethjakman> which I call magic because I haven't written any yet because I'm new as well
19:48:27 <murphxyz> that does sound like magic
19:48:43 <murphxyz> Especially to Mr. baby steps here
19:48:57 <lethjakman> murphxyz: it's still compile time checked, but it seems to write out haskell code for you based off of some simpler code you've writte
19:48:59 <lethjakman> n
19:49:09 <murphxyz> oh, that's interesting!
19:49:12 <lethjakman> that way you have a ton of boiler plate code written for you. 
19:49:13 <Zemyla> @pl \a -> void (a (Right (\b -> a (Left b))))
19:49:13 <lambdabot> void . ap id (Right . (. Left))
19:49:45 <khanage> i'm trying to debug an issue with pipes i have
19:49:49 <lpaste_> khanage pasted ‚ÄúProxy‚Äù at http://lpaste.net/137371
19:49:54 <lethjakman> it's SUPER cool, but I don't think template haskell is type checked when they write it, but it has a ton of tests.
19:49:58 <lethjakman> anyways, I have to get going. 
19:50:14 <khanage> i'm trying to write a proxy for a network service
19:50:43 <Zemyla> @djinn (Either a (a -> r) -> r) -> r
19:50:43 <lambdabot> f a = a (Right (\ b -> a (Left b)))
19:51:05 <khanage> i've glued together toSocket and fromSocket with >->, which typechecks at Pipe ByteString ByteString
19:51:28 <khanage> but i don't know how to check that that pipeline is "running"
19:51:38 <khanage> is there someway to put something in between?
19:51:44 <khanage> (if that makes sense)
19:52:12 <lpaste_> khanage pasted ‚Äúdump‚Äù at http://lpaste.net/137372
19:52:19 <khanage> i've tried this
19:52:30 <Zemyla> ski: It doesn't work, because it can't be rewritten as a value of type forall r. (a -> r) -> r.
19:52:31 <khanage> but toSocket is unconstrained
19:54:29 <bob_twinkles> lethjakman: the code output from TH is typechecked after it's generated. The "TH isn't typechecked" issue is at the compile-time of the TH generators themselves, the compiler can't make sure the generator you've written can only output valid ASTs, which makes TH code slightly less safe and more difficult to write than normal haskell
20:05:50 <Pamelloes> I just spent 10 minutes trying to come up with a default value in a fold. For an alternative. Which provides "empty."
20:05:56 * Pamelloes is not very smart today
20:23:28 <bros> https://github.com/begriffs/postgrest Would it be wise to write an entire production startup/web app on that?
20:30:28 <ski> Zemyla : yes. since `a' may not depend on `r' there
20:33:47 <benzrf> khanage: hey
20:34:24 <khanage> benzrf: ?
20:34:27 <benzrf> Zemyla: do note that that is not ~~LEM
20:34:35 <ddellacosta> folks, fumbling through understanding newtype.  Can someone fix my language/understanding here?  newtype is necessary because it allows you to create an exact isomorphism with another type without lifting bottom into a distinct subtype (<- this is not quite right, I know)
20:34:40 <benzrf> khanage: sry was checking that you were still here
20:34:45 <benzrf> gonna look at your pipe thing, 1 sec
20:35:11 <khanage> benzrf: i think i know what i'm doing wrong - really I'm trying to wire a `consumer >-> producer`
20:35:20 <benzrf> khanage: have you considered using Client and Server
20:35:43 <khanage> no - i'm trying something from an examples project on github
20:35:54 <khanage> i'll take a look at that
20:35:55 <benzrf> i mean from pipes
20:36:15 <khanage> i'm just reimplementing https://github.com/michaelt/pipes-network-tcp-examples/blob/master/Examples/ClientPipeline.hs
20:36:24 <benzrf> well
20:36:29 <benzrf> im just looking at what youre doing here
20:36:30 <khanage> but no, I haven't come across that just yet 
20:37:00 <benzrf> and basically Client/Server are for components that alternate between receiving and responding
20:37:08 <benzrf> on one of their interfaces
20:37:24 <Zemyla> ddellacosta: That, and it improves efficiency.
20:37:25 <benzrf> generators, basically
20:38:32 <ddellacosta> Zemyla: thanks, and that has to do with the fact that all isomorphically identical newtypes are all turned into the same thing at compile-time, right?
20:38:42 <Zemyla> Exactly.
20:38:52 <ddellacosta> not sure if "isomorphically identical" is an appropriate way to put it
20:38:58 <ddellacosta> okay, thanks for your help Zemyla
20:39:40 <khanage> benzrf: ok, i'll take a look :)
20:39:41 <khanage> thanks
20:40:05 <y> \forall x \in values, N \in newtype-constructors. N x is isomorphic to x? :P 
20:40:27 <y> (I think it's defined somewhat like that in the haskell report? 
20:41:25 <khanage> benzrf: do you have a link? client server pipes isn't a great google term
20:41:31 <benzrf> khanage: so for example, you could write a Server URL Page IO () which is a component that awaits URLs, consumes them, then responds with the contents of the page
20:41:41 <benzrf> khanage: they are type synonyms in Pipes.Core
20:41:47 <khanage> ahh
20:44:00 <benzrf> fundamentally, pipes' 'Proxy' is a monad transformer that equips a monad with the instructions 'pause & pass control flow downstream, sending this value' and same for upstream
20:45:41 <benzrf> a Producer is something that only ever pushes flow downstream, and doesnt expect anything interesting as input when reactivated
20:46:17 <khanage> thus type Producer b = Proxy X () () b
20:46:19 <khanage> ?
20:46:21 <benzrf> yeah
20:46:36 <benzrf> a Consumer only ever pushes control flow back upstream, but doesnt send anything interesting along, but expects some specific type of value to be sent along when control is transferred to it
20:46:41 <coward> At least I know what bothers me from the chart on the lens package. In fact what bothers me from a lot of ed's libraries. Most documentation made for it or by him is usually reference documentation, it's little on getting using the library more than documenting behaviour for someone who roughtly know what is up
20:46:53 <benzrf> coward: yep :I
20:47:17 <coward> Am I a bad persons from demanding better documentation from ed's free work? 
20:47:47 <johnw> benzrf: it doesn't equip the monad with those instructions
20:47:56 <benzrf> johnw: well, im being very vague and intuitive
20:47:58 <benzrf> :>
20:48:00 <kadoban> coward: "demanding"? Yes. Wishing for, asking for, possibly creating yourself? No.
20:48:05 <johnw> in fact, a pipline needn't use the M constructor at all, in which case effects are absent, despite there being a chosen 'm'
20:48:07 <coward> throw away account because I am a coward for the repercutions of speaking bad from ed 
20:48:25 <khanage> coward: i thought it was a synonym for parent CoWard
20:48:41 <khanage> maybe i need to go outside or something
20:48:54 <benzrf> coward: if you simply demand that it must have better docu the end, thats not great?
20:49:01 <benzrf> coward: but being critical is fine
20:49:06 <johnw> ed gives what is needful
20:49:11 <benzrf> as long as you dont assert that your criticism is a moral imperative
20:49:20 <coward> kadoban: for that I need to actually know lens. At that point the reference will actually make sense and I will not remember what is *not* to know lens
20:49:29 <benzrf> coward: tru
20:49:47 <johnw> to expect anyone to deliver everything (good ideas, good code, good docs, customer service), is ridiculous without paying them handsomely
20:50:15 <dramforever> I wonder if edwardk gets paid for lens
20:50:18 <kadoban> coward: I don't understand. So you're saying it's impossible to document things once you know them?
20:50:23 <dramforever> looks like know
20:50:38 <dramforever> *no
20:51:03 <coward> kadoban: it's difficult to put yourself on the shoes of a beginner when you have past too much time as a teacher
20:51:12 <benzrf> ^
20:51:14 <coward> I call it the college teacher syndrome
20:51:34 <coward> I know I used to struggle with boolean algebra
20:51:35 <johnw> a lens is a "functoral arrow through the heart of a data structure"
20:51:52 <coward> I can't think now how to teach somebody who doesn't know boolean algebra
20:52:01 <coward> In fact I can't think like the beginner I used to be
20:52:19 <benzrf> ok johnw for the lightning round:
20:52:21 <benzrf> what is an optic?
20:52:43 <Welkin> haha
20:52:46 <Welkin> that is true
20:52:47 <johnw> doesn't that simply refer to all the various kinds of f in for choices of (a -> f b) -> s -> f t?
20:52:54 <benzrf> johnw: that's unhelpful
20:53:00 <Welkin> I often found that grad students (or the course TAs) were much better teachers than the professor
20:53:01 <johnw> are you asking for you?
20:53:03 <benzrf> i mean, what is an optic in the sense of
20:53:06 <benzrf> johnw: no, i have a solid intuition
20:53:09 <johnw> i'm not trying to be generally helpful
20:53:15 <Welkin> although there are always some amazing professors that just get it and can explain anything with ease
20:53:18 <benzrf> im saying, can you summarize what an optic isocliff 
20:53:21 <benzrf> *is
20:53:21 <johnw> so give me some context as to what you want the answer to be
20:53:28 <benzrf> for someone who doesnt know lens
20:54:51 <johnw> i'm not sure I'd start talking about "optics" at all then
20:54:59 <johnw> that's too abstract a notion for a beginner
20:55:01 <benzrf> fair!
20:55:32 <johnw> I like SPJ's talk the most
20:55:38 <johnw> http://ftp.newartisans.com/pub/Lenses.mp4
20:55:51 <benzrf> on a less point-driving note
20:56:11 <ttt_fff> benzrf: how's spreadsheet in haskell coming along?
20:56:14 <benzrf> ttt_fff: shhhh
20:56:28 <johnw> ttt_fff: you asked before about making tables into a database
20:56:40 <ttt_fff> johnw: I did, referring to ekemmet's lens/tables library
20:56:47 <johnw> but that's missing the point of what tables is
20:56:48 <ttt_fff> johnw: and desiring for that to be a persistent db of some form
20:56:56 <ttt_fff> johnw: expalin what I got wrong then please
20:56:57 <slack1256> spreadsheet? is there a loeb somewhere in it?
20:56:58 <johnw> edwardk *is* working on a database
20:57:09 <johnw> tables is an abstract UI for tabular form relations
20:57:10 <benzrf> i think it might be helpful for newbs to clarify that there is some broad class of types that qualify as 'optics', and that by restricting to certain more specific types you can specify optics with particular properties, and hence the strange apparent overloading of view, preview, etc
20:57:10 <ttt_fff> johnw: what is edwardk not working on?
20:57:13 <Welkin> ttt_fff: Lotus 1-2-3!
20:57:23 <Welkin> ttt_fff: call it Monadus 1-2-3!
20:57:25 <benzrf> i dont think i put that very well
20:57:32 <ttt_fff> johnw: where is this db that edwardk is working on? and what is the point of edwardk/tables ?
20:57:53 <benzrf> johnw: ttt_fff means something like a spreadsheet app but with haskell as the expression language
20:58:05 <johnw> ttt_fff: tables, lens, etc., are edwardk's way of building a vocabulary that works for a huge number of concepts, such that you can reason, compose, and connect tons of different ideas
20:58:20 <johnw> about his db, you'll have to ask him someday, he'd be glad to talk to you about it
20:58:22 <benzrf> johnw: sounds like something a koolaid drinker would say... hmmmmm
20:58:33 <johnw> well, edwardk is doing a very nice job of fulfilling his vision
20:58:35 <ttt_fff> johnw: so edwardk's db is not on github yet?
20:58:38 <joobus> in ghci, if I've defined a function (but it was wrong), how do I overwrite that definition?
20:58:39 <johnw> I didn't say it was everyone's vision, though
20:58:53 <benzrf> joobus: just define again
20:59:15 <coward> it's a good vision, infact I think is great that he is also able to share his work with the greater community
20:59:20 <benzrf> joobus: the two definitions will not combine the way they would in a source file
20:59:25 <coward> is just that sometimes I feel at lost on the docs
20:59:27 <ttt_fff> I feel taht SQL is awfully expressive, ceratinly not less expressive thatn lens/tables
20:59:27 <benzrf> the second one will just overwrite the first
20:59:32 <ttt_fff> in fact, if I had a typed SQL, I'd be very ver happy
20:59:52 <ttt_fff> coward: read the source with courage
20:59:54 <johnw> yes, I think edwardk's vision is helping drive Haskell in general toward good places; he's showing us how far some very important concepts can be taken
20:59:54 <ecognium> hi al, could someone help me with some difficulties I am having calling monadic code. I thought I should be able to figure this out but could not make much progress. I posted it on Reddit but I feel like my question may be self-sufficient. https://www.reddit.com/r/haskellquestions/comments/3emif0/how_to_invoke_a_persistent_db_action_within_a_db/
21:00:08 <johnw> who would have though that *so* much functionality would have come out of lens, just by grokking Functor so well
21:00:24 <benzrf> coward: fwiw, lens is based around some extremely abstract ideas that kind of need a document of their own rather than just explanation of each visible part
21:00:24 <johnw> granted, it wasn't originally an edwardk idea, but he knew how to make Haskell sing with it
21:00:29 <benzrf> coward: like monads
21:00:37 <joobus> benzrf: well i'm trying that but getting a parse error...
21:00:40 <MP2E> lens is truly amazing
21:00:42 <benzrf> joobus: oh?
21:00:51 <MP2E> I'm still trying to understand how far the rabbit hole goes
21:00:52 <benzrf> johnw: care to clarify how lens is all about functor?
21:00:54 <benzrf> :}
21:01:04 <ttt_fff> what's so amazing about lens?
21:01:05 <joobus> i'll search around some more
21:01:07 <ttt_fff> I'm sure I use List more than Lens
21:01:09 <benzrf> MP2E: oh, you wanna see down the rabbit hole?
21:01:13 <MP2E> sure :P
21:01:17 * MP2E is scared now
21:01:18 <johnw> benzrf: it uses the idea of two basic functors, Const and Identity, to turn a getter+setter approach to lenses into something that's a composable arrow
21:01:21 <benzrf> MP2E: here, look at this...
21:01:39 <johnw> I just said he grokked Functor well, not that lenses are Functors
21:01:41 <benzrf> > set (upon tail) [1, 2, 3] [8, 9, 10, 11]
21:01:43 <lambdabot>  [8,1,2,3]
21:01:49 <benzrf> johnw: kk
21:01:57 <MP2E> :o o.O
21:02:04 <coward> wtf
21:02:10 <johnw> I think the composability of lens is its killer feature
21:02:13 <MP2E> :t upon
21:02:14 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
21:02:14 <coward> @type upon
21:02:16 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
21:02:21 <benzrf> @let access (_, x:xs) = xs
21:02:22 <lambdabot>  Defined.
21:02:31 <benzrf> > set (upon access) [1, 2, 3] ("hello", [8, 9, 10, 11])
21:02:33 <lambdabot>  ("hello",[8,1,2,3])
21:02:39 <benzrf> ~magic
21:02:48 <benzrf> i hope this scares you as much as it scares me
21:03:01 <ttt_fff> @let id = error "hehehaha"
21:03:02 <lambdabot>  .L.hs:174:21:
21:03:03 <lambdabot>      Ambiguous occurrence ‚Äòid‚Äô
21:03:03 <lambdabot>      It could refer to either ‚ÄòL.id‚Äô, defined at .L.hs:177:1
21:03:11 <ecognium> If i have some code that inside a moand. While being inside the monad, can I call a function that will also run inside the same monad? I am running some `persistent` actions and in between I would like to call a function that will also run some persistent actions and come back with a result. 
21:03:27 <coward> @type join
21:03:28 <ecognium> If I line the whole function call, it works but i cannot figure our how to separate the calls so I can reuse it
21:03:29 <lambdabot> Monad m => m (m a) -> m a
21:03:35 <MP2E> that is frightening :o
21:03:45 <benzrf> it is evil and no one should use it
21:03:50 <marchelzo_> @type access
21:03:51 <lambdabot> (t, [t1]) -> [t1]
21:04:02 <ttt_fff> benzrf : join is not evil
21:04:09 <benzrf> ttt_fff: upon, not join
21:04:11 <benzrf> sheesh
21:04:17 <ttt_fff> @type upon
21:04:17 <marchelzo_> what is access? tail . snd?
21:04:18 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
21:04:23 <benzrf> marchelzo_: yeah
21:04:32 <benzrf> marchelzo_: the point was to note that i could define a function from scratch
21:04:34 <benzrf> using pattern matching
21:04:41 <benzrf> and then use it with upon
21:04:50 <johnw> ecognium: I think >>= is what you want
21:05:13 <marchelzo_> benzrf: Oh, I didn't see that you just defined access.
21:05:36 <coward> Thanks #haskell to listening to my ramblings. I thought I was in some haskelian version of the "emperor clothes" and that my concerns where unjustified
21:05:43 <johnw> ecognium: also, while I understand what you mean by "inside a monad", those words don't belong together
21:05:46 <coward> I hope I won't bother you again in the future
21:06:05 <johnw> coward: think of what the other alternative would be
21:06:07 <benzrf> its fine coward
21:06:13 <y> > set (upon tail) [1,2,3] [] 
21:06:14 <lambdabot>  []
21:06:16 <benzrf> the kmettoverse is Controverssial
21:06:24 <johnw> coward: there are plenty of geniuses with amazing ideas who don't share them at all
21:06:26 <y> wait, what? 
21:06:35 <benzrf> y: [] has no tail
21:06:38 <benzrf> so setting it does nothing
21:07:07 <benzrf> but really i would expect that to explode
21:07:09 <benzrf> o____o
21:07:11 <johnw> upon is making a lens out of a function that sort of "describes" the part of the structure you want to focus on
21:07:21 <ecognium> johnw thanks. I am a newb so I may be using incorrect terminology . I am doing something like runDb $ do { a <- selectList [][] ... ; b <- selectList[][]; c <- selectList[][]  ... return x }. I would like to move say the `c <- selectList`  to a different function which will run inside `runDb` and return a value.  
21:07:25 <y> I haven't looked at upon, but I thought it'd crash there
21:07:28 <johnw> upon tail -> gives you a lens onto the tail of a list
21:07:32 <y> I mean, tail [] is bottom 
21:07:42 <benzrf> it doesnt directly apply it afaik y
21:07:50 <johnw> ecognium: yes, you can do that
21:07:55 <Hijiri> set (upon (*2)) 24 2
21:07:57 <Hijiri> > set (upon (*2)) 24 2
21:07:58 <benzrf> it uses the Data class to accomplish its disgusting evil
21:07:59 <lambdabot>  2
21:08:15 <y> oh well, that explains a few things
21:08:21 <benzrf> Hijiri: it's not /that/ smart
21:08:23 <y> I now see the type signature 
21:08:28 * hackagebot deriving-compat 0.1 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.1 (ryanglscott)
21:08:32 <johnw> ecognium: selectList itself is a function with the properties you are describing
21:08:35 <dramforever> :t upon
21:08:36 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
21:08:48 <benzrf> Hijiri: there are some guidelines about how the function is supposed to behave to get anything sane out of upon
21:08:50 <benzrf> not that you should use upon
21:08:57 <benzrf> its a toy only
21:09:04 <dramforever> [1,2,3,4,5] & upon (!! 2) %~ (+ 2)
21:09:11 <dramforever> > [1,2,3,4,5] & upon (!! 2) %~ (+ 2)
21:09:13 <lambdabot>  [1,2,5,4,5]
21:09:18 <dramforever> wow
21:09:31 <ecognium> johnw I get a type error. I will explain my setup a bit more. I am using `servant` and `persistent`. The servant handler runs inside ` type AppM = ReaderT Config (EitherT ServantErr IO)`. My guess about `runDb`'s signature is `runDb :: (MonadReader Config m, MonadIO m) => SqlPersistT IO b -> m b`
21:09:36 <marchelzo_> Is that Haskell, or APL?
21:09:46 <johnw> ecognium: can you paste your code with the type error at lpaste.net?
21:10:00 <y> > [1,2,3,4,5] & ix 2 %~ (+2) 
21:10:01 <lambdabot>  [1,2,5,4,5]
21:10:05 <johnw> reading monad transformer code is something that becomes second nature, but only after a while
21:10:25 <johnw> y: thank you!
21:10:43 <johnw> y: you just clarified something for me
21:10:49 <y> what did I do? 
21:10:59 <johnw> that ix 2 is basically upon (!! 2)
21:11:08 <johnw> I was always fuzzy on the real difference between at and ix
21:11:21 <ecognium> johnw: http://lpaste.net/137381 
21:11:26 <benzrf> > view (upon (!! 2)) [1, 2]
21:11:28 <lambdabot>      No instance for (Show a0)
21:11:28 <lambdabot>        arising from a use of ‚Äòshow_M67831499184516598711121‚Äô
21:11:28 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
21:11:31 <benzrf> ??
21:11:33 <Zemyla> :t (&)
21:11:35 <lambdabot> a -> (a -> b) -> b
21:11:35 <benzrf> > view (upon (!! 2)) [1, 2] :: Int
21:11:36 <lambdabot>      No instance for (Monoid Int) arising from a use of ‚Äòupon‚Äô
21:11:37 <lambdabot>      In the first argument of ‚Äòview‚Äô, namely ‚Äò(upon (!! 2))‚Äô
21:11:37 <lambdabot>      In the expression: view (upon (!! 2)) [1, 2] :: Int
21:11:40 <benzrf> whoa
21:11:43 <benzrf> s m aaaaaart
21:11:59 <johnw> benzrf: use lambdabot in /query before asking here :)
21:12:00 <benzrf> johnw: the difference is that they have different types
21:12:03 <johnw> makes you look 1000x smarter
21:12:11 <johnw> ha ha ha
21:12:25 <y> johnw: I didn't even know `at` until now
21:12:40 <johnw> ecognium: try without a signature; if it works, using -Wall and GHC will tell you what the signature should be
21:12:56 <benzrf> johnw: at is a lens to a maybe; ix is a traversal to the thing
21:13:00 <johnw> but I'm almost certain you'll need SqlPersistT m Double
21:13:08 <johnw> benzrf: I know all of that
21:13:11 <benzrf> well then
21:13:13 <benzrf> what was unclear
21:13:22 <y> @type at
21:13:23 <johnw> benzrf: something subtle, which y just clarified
21:13:23 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
21:13:24 <y> @type ix
21:13:25 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
21:13:30 <benzrf> johnw: oh,?
21:13:33 <Hijiri> @let headPlus xs = head xs + 1
21:13:35 <lambdabot>  Defined.
21:13:36 <johnw> i mean, subtle to me
21:13:40 <johnw> not smart, I say
21:13:50 <Hijiri> > set (upon headPlus) [1,2,3] 3
21:13:51 <lambdabot>      No instance for (Show t0)
21:13:51 <lambdabot>        arising from a use of ‚Äòshow_M60298315724303248051208‚Äô
21:13:51 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
21:13:53 <MarcelineVQ> >headPlus []
21:14:00 <Hijiri> > set (upon headPlus) [1,2,3] 3 :: [Int]
21:14:01 <lambdabot>      Couldn't match type ‚Äò[Integer]‚Äô with ‚ÄòInt‚Äô
21:14:01 <lambdabot>      Expected type: ASetter [Int] [Int] Int [Integer]
21:14:01 <lambdabot>        Actual type: (Int -> Identity Int) -> [Int] -> Identity [Int]
21:14:04 <MarcelineVQ> > headPlus []
21:14:05 <lambdabot>  *Exception: Prelude.head: empty list
21:14:05 <johnw> is at a prism then?
21:14:09 <Hijiri> > set (upon headPlus) [1,2,3] 3 :: [Integer]
21:14:10 <lambdabot>      Couldn't match type ‚Äò[Integer]‚Äô with ‚ÄòInteger‚Äô
21:14:10 <lambdabot>      Expected type: ASetter [Integer] [Integer] Integer [Integer]
21:14:10 <lambdabot>        Actual type: (Integer -> Identity Integer)
21:14:12 <Hijiri> sorry
21:14:13 <Zemyla> So why can't I import Comtrol.Monad.Free in Lambdabot?
21:14:14 <Hijiri> I'll stop
21:14:17 <benzrf> johnw: no, at is a lens
21:14:20 <johnw> Hijiri: just /query lambdabot
21:14:30 <benzrf> johnw: the key point is that at always succeeds /as an optic/
21:14:42 <johnw> benzrf: i see
21:14:43 <Zemyla> @let import Control.Monad.Free
21:14:44 <lambdabot>  .L.hs:146:26:
21:14:45 <lambdabot>      Ambiguous occurrence ‚ÄòFree‚Äô
21:14:45 <lambdabot>      It could refer to either ‚ÄòL.Free‚Äô, defined at .L.hs:145:1
21:14:48 <johnw> you like this word optic :)
21:14:55 <benzrf> > preview (at 3) [1, 2]
21:14:58 <lambdabot>      No instance for (Show t0)
21:14:58 <lambdabot>        arising from a use of ‚Äòshow_M82264647321781482341302‚Äô
21:14:58 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
21:15:00 <benzrf> er
21:15:06 <y> > [1,2,3] & upon (\x -> head x + 1) .~ 20
21:15:08 <benzrf> > toListOf (ix 3) [1, 2]
21:15:11 <lambdabot>  [20,2,3]
21:15:12 <benzrf> > toListOf (at 3) [1, 2]
21:15:15 <lambdabot>  []
21:15:21 <lambdabot>      No instance for (Show t0)
21:15:22 <benzrf> >.<
21:15:25 <lambdabot>        arising from a use of ‚Äòshow_M45442777670112185411362‚Äô
21:15:26 <benzrf> spam
21:15:27 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
21:15:39 <Welkin> benzrf: your emote could be an operator
21:15:43 <MarcelineVQ> poor robut
21:15:45 <benzrf> i think i did that
21:15:49 <benzrf> @ping
21:15:51 <lambdabot> pong
21:15:57 <benzrf> > (toListOf (ix 3) [1, 2], toListOf (at 3) [1, 2]) -- johnw
21:15:58 <lambdabot>      No instance for (Show t0)
21:15:58 <lambdabot>        arising from a use of ‚Äòshow_M54967852076693542691408‚Äô
21:15:58 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
21:16:04 <benzrf> are you fricken kidding me
21:16:11 * benzrf checks in ghci
21:16:14 <Zemyla> :t (>.<)
21:16:14 <lambdabot>     Not in scope: ‚Äò>.<‚Äô
21:16:15 <lambdabot>     Perhaps you meant one of these:
21:16:15 <lambdabot>       ‚ÄòSeq.><‚Äô (imported from Data.Sequence),
21:16:15 <johnw> i'm telling you, use lambdabot in /query until you have an answer that works
21:16:18 <Welkin> > id "benzrf"
21:16:18 <ecognium> johnw: I removed the type signature for `runDb` and my `calcMoreValues` and I get this error:    Could not deduce (MonadIO m0) arising from a use of ‚ÄòcalcMoreValues‚Äô 
21:16:19 <lambdabot>  "benzrf"
21:16:21 <johnw> it's what I'm doing right now
21:16:23 <benzrf> i know, im impulsive >.>
21:16:35 <Hijiri> > set (upon headPlus) 42 [1,2,3] :: [Integer]
21:16:36 <lambdabot>  [42,2,3]
21:16:46 <johnw> ecognium: remove it just for the one giving you the type error
21:16:46 <Zemyla> So ekmett hasn't clained that operator yet.
21:17:15 <benzrf> gdi
21:17:16 <Welkin> :t (><)
21:17:17 <lambdabot> (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
21:17:21 <Welkin> eh?
21:17:30 <Welkin> that is from Data.Sequence
21:17:36 <benzrf> johnw: the point is, it SHOULD say that toListOf (ix 3) [1, 2] is [], while toListOf (at 3) [1, 2] is [Nothing]
21:17:39 <Zemyla> @reset
21:17:44 <lambdabot> Say again?
21:17:57 <benzrf> johnw: the latter succeeded in retrieving the value, it's just that at itself chose to return Nothing as its result
21:18:12 <Zemyla> Hmm, how do you wipe everything stored in lambdabot?
21:18:23 <y> @undefine
21:18:23 <lambdabot> Undefined.
21:18:23 <Welkin> @undefine
21:18:23 <lambdabot> Undefined.
21:18:24 <benzrf> like a shell program printing an error message vs. having return code 1
21:18:33 <johnw> looks like there is no At instance for lists, benzrf
21:18:40 <benzrf> johnw: oh wait
21:18:42 <ecognium> johnw: it is suggesting the same signature I had before. Also gives me the same type error. 
21:18:43 <benzrf> fuck, im an idiot
21:18:44 <johnw> > ([1,2] :: [Int]) ^? ix 1
21:18:45 <lambdabot>  Just 2
21:18:48 <benzrf> :S
21:18:54 <johnw> but "at 1" does not work in any configuration
21:19:02 <benzrf> > toListOf (at "foo") M.empty
21:19:03 <Zemyla> @let import Control.Monad.Free
21:19:03 <lambdabot>  [Nothing]
21:19:04 <lambdabot>  <no location info>:
21:19:04 <lambdabot>      The package (profunctors-4.4.1) is required to be trusted but it isn't!
21:19:06 <ecognium> I wonder if I don't understand how to include integrate different monadic calls.
21:19:06 <benzrf> there we go
21:19:17 <benzrf> johnw: since it's a lens, you can set it to 'Just whatever'
21:19:23 <benzrf> which doesnt work lawfully with arbitrary indices in a list
21:19:23 <johnw> ecognium: oh, wait
21:19:24 <Zemyla> So why isn't an ekmett package trusted?
21:19:25 <Welkin> √ü:‚àë>
21:19:43 <johnw> ecognium: runDb needs to take an SqlPersistT m b, not IO b
21:20:19 <y> benzrf: well, maybe for Monoid a => [a] ... :D 
21:20:21 <johnw> which means I don't think you can liftIO $ runSqlPool
21:20:40 <Hijiri> Zemyla: because it discriminates?
21:21:00 <Welkin> ecognium: if you need to do more complex operations with SQL, use Esqueleto
21:21:07 <Welkin> it can be used in conjuntion with Persistent
21:21:25 <Welkin> but import one of them as qualified since they conflict
21:21:25 <johnw> yes, esqueleto is nice enough to use that I just skip persistent usually
21:21:58 <Zemyla> Is there any way to use Esqueleto without having to use Template Haskell?
21:22:12 <Welkin> Zemyla: anything by snoyberg uses template haskell :P
21:22:28 <Welkin> well, esqueleto isn't bu snoyberg though
21:22:30 <MP2E> haha
21:22:38 <ecognium> johnw: my runDb code works fine generally (with the IO and liftIO). I am just having trouble when I am trying to call a function inside runDb which also happens to be using runDb.  When I changed it to m from IO, i am getting way too many errors. 
21:23:47 <ecognium> Welkin: I am using esqueleto for some parts of my code but this one is more business logic than DB.. It will be too much to write all that in DB so I thought I will just extract the values I want and call a function which returns a value. That value is used inside the next query. 
21:24:25 <ecognium> To be sure: If I just inline my other function into this runDb do $ ... it works just fine. 
21:24:34 <Pamelloes> So I'm planning on processing a list with around 15000 items in it. Are there any special performance considerations I should take, or will the standard sort and filter methods scale up reasonable well?
21:25:08 <ecognium> I just cannot figure out how to extract some of the statements and move it to a function. It is possible such a thing is not acceptable. I just don't know how to determine that. johnw and Welkin
21:25:22 <agibiansky> Does anyone have experience using the bloomfilter package?
21:25:28 <Welkin> Pamelloes: sort is a bottom up merge sort
21:25:44 <Pamelloes> Right..... What does that mean?
21:25:48 <Welkin> filter is linear no matter what
21:25:58 <Welkin> it means it a guaranteed O(nlogn)
21:26:12 <Pamelloes> That doesn't seem too bad.
21:26:16 <Pamelloes> I think.
21:26:23 <Welkin> it's the best you can get for sorting
21:26:27 <slack1256> but the space usage will be great?
21:26:29 <dramforever> Pamelloes: 15000 isn't a lot
21:26:33 <Welkin> an in-place quicksort is slightly faster in practice
21:26:39 <slack1256> you have to process the whole list to get the first element
21:26:56 <bob_twinkles> do remember that [a] is a linked list though, so if you care about nanoseconds it probably won't be fast enough
21:27:19 <Zemyla> slack1256: You have to do that anyways, because the smallest element might be the very last one.
21:27:28 <Pamelloes> dramforever: It's more than I usually work with. And my database is accumulating entries at a terrifying rate. If I relax my filter I can easily wind up with around 1 mil entries...
21:27:44 <y> Pamelloes: what are operations are you going to be doing with it? I wouldn't recommend a lazy linked list if you want it to actually live in the heap 
21:27:59 <bob_twinkles> if you need to sort/filter and you have a database, do that in the database =P
21:28:17 <slack1256> Zemyla: we can't escape our destinies then...
21:28:21 <y> if you have 1M+ entries, I would go with a database, yeah
21:28:41 <Pamelloes> bob_twinkles: Hm, that's a pretty good idea, actually.
21:29:09 <Pamelloes> Actually, that's a really good idea :)
21:29:11 <bob_twinkles> I mean, ORDER BY and WHERE exist for a reason, and a lot of people have put a lot of effort in to making those fast... so why not just leverage that work
21:30:34 <Pamelloes> bob_twinkles: You've got me thinking about this problem in a very different way. Thanks :)
21:30:38 <Pamelloes> This shouldn't be too hard, now.
21:30:51 <Zemyla> I wish you could make subsets of IO easily.
21:31:02 <bob_twinkles> heh, glad to help
21:32:12 <slack1256> "easily" for me is using a little of Operational
21:34:46 <dramforever> Zemyla: newtype?
21:35:38 <lpaste_> joobus pasted ‚Äúflip a string in 2s‚Äù at http://lpaste.net/137382
21:36:03 <joobus> can someone take a look at this and tell me what is wrong? http://lpaste.net/137382
21:36:25 <dramforever> lol that happened to me before
21:37:03 <dramforever> but it was a bytestring
21:38:08 <dramforever> oh wait wait different problem
21:38:35 <dramforever> you should remove the let on line #3
21:38:38 <dramforever> joobus: ^
21:38:48 <dramforever> otherwise this flip shadows the one on line 2
21:38:57 <dramforever> rather than being the same function
21:39:21 <timbod7> Hi - what's the stack equivalent of "cabal sdist"?
21:40:17 <bob_twinkles> should be safe to just use cabal I think... stack can't quite do everything cabal can (yet?)
21:40:20 <joobus> dramforever: but then ghci bitches about a parse error on "="
21:40:39 <dramforever> joobus: oh you need to wrap the two let's in :{ and :}
21:40:43 <dramforever> like this
21:40:44 <dramforever> :{
21:40:46 <dramforever> let blah blah
21:40:49 <dramforever>     blah blah
21:40:50 <dramforever> :}
21:40:57 <joobus> dramforever: ok, trying...
21:41:08 <dramforever> or put a semicolon between the lines
21:41:17 <dramforever> let blah blah; blah blah
21:41:31 <bob_twinkles> or desugar it yourself to a case expression =P
21:41:54 <timbod7> bob_twinkles: Ok. I thought stack was meant to be the new build "swiss army knife"
21:43:03 <dramforever> joobus: btw what are you doing exactly?
21:43:19 <joobus> dramforever: cool thanks.
21:44:06 <dramforever> I once wrote a wave file reverser, and for a pcm16 stereo wave file each sample is 4 bytes
21:44:38 <joobus> dramforever: at work we get lists of rfid tags that are whatever-endian, and the devices we read with are the opposite so we have to flip the tag strings to match what our readers see.  I was using this as a simple practice for learning haskell.
21:44:47 <bob_twinkles> timbod7: it's a much younger tool than cabal, and stuff like sdist isn't really at the core of their (FPComplete's) workflow I guess
21:44:59 <dramforever> hmm interesting
21:45:48 <bob_twinkles> earlier today I was trying to figure out how to get Stack to use a local version of a package and as near as I can tell it's just not possible..
21:45:48 <timbod7> bob_twinkles: I understand that. Though isn't creating a tarball fundamental to uploading and publishing a new package?
21:46:08 <joobus> dramforever: i've written this same logic in python, javascript, and clojure, but I've been wanting to learn haskell.
21:46:09 <bob_twinkles> there's "stack upload"
21:46:21 <dramforever> joobus: =)
21:46:51 <dramforever> however I doubt if haskell is efficient enough for this
21:47:00 <timbod7> stack upload says it needs a tarball as an argument?
21:47:02 <Welkin> joobus: if you want to write more than one line, I recommend putting it in a .hs file and using runhaskell on it
21:47:12 <Welkin> or importing the file into ghci
21:47:27 <Welkin> in ghci use :load MyFile.hs
21:47:50 <Welkin> then you can test your functions individually
21:47:56 <dramforever> If you want to write something you want to keep or is non-trivial, do that
21:48:00 <joobus> dramforever: lately i've been just running a vim macro on the tag lists, but last week we got a 60,000 entry tag list and the vim macro took a while to run... :P
21:48:07 <bob_twinkles> timbod7: so stack might have a way to do it internally, but as near as I can tell it's not exposed in the CLI
21:48:25 <dramforever> joobus: btw is it just bytes?
21:48:30 * hackagebot Chart 1.5.1 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.5.1 (TimDocker)
21:48:32 * hackagebot Chart-cairo 1.5.1 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.5.1 (TimDocker)
21:48:34 * hackagebot Chart-gtk 1.5.1 - Utility functions for using the chart library with GTK  https://hackage.haskell.org/package/Chart-gtk-1.5.1 (TimDocker)
21:48:35 <joobus> dramforever: why do you say haskell isn't efficient enough?
21:48:36 * hackagebot Chart-diagrams 1.5.1 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.5.1 (TimDocker)
21:48:42 <joobus> dramforever: basically yes.
21:48:49 <dramforever> joobus: a string is a list of chars
21:48:59 <joobus> i know
21:48:59 <Welkin> so?
21:49:00 <dramforever> and a list in haskell is singly-linked
21:49:05 <timbod7> bob_twinkles: what does stack upload actually do? Upload to hackage? Any link for documentation?
21:49:08 <Welkin> you can use Text which is an array of characters
21:49:17 <dramforever> and it isn't as efficient as some other faster containers
21:49:18 <Welkin> or bytestring
21:49:25 <timbod7> Hey - that's cool. lambdabot just announced my uploads!
21:49:37 <Welkin> timbod7: spammer!
21:49:51 <timbod7> hackagebot I meant.
21:50:00 <joobus> dramforever: containers such as?
21:50:09 <y> dramforever: Text/ByteString are really optimized 
21:50:11 <Welkin> joobus: Text, ByteString
21:50:17 <dramforever> joobus: you just started learning haskell right?
21:50:20 <dramforever> don't worry then
21:50:31 <dramforever> btw 60,000 isn't a lot
21:51:01 <bob_twinkles> timbod7: not ATM sorry. Though actually looking at the source for the Git version of the stack command, it looks like sdist support is implemented upstream
21:51:05 <joobus> dramforever: I've been studying haskell for about 5 months, watching videos etc., but not really coding yet
21:51:19 <joobus> dramforever: 60,000 lines is a lot for a vim macro!
21:51:31 <dramforever> you don't have to worry about efficiency too much
21:51:41 <joobus> dramforever: i know
21:51:41 <bob_twinkles> as of literally 4 days ago =P
21:52:05 <dramforever> my wave reverser could process an 690M file in 10s
21:52:16 <dramforever> *a
21:53:53 <joobus> does anyone here also use golang?  There isn't much on comparisons between haskell and golang on the web.
21:54:10 <joobus> wondering if anyone has opinions on the matter
21:54:12 <Pamelloes> How big can a Double go?
21:54:19 <Welkin> there isn't any comparison
21:54:31 <dramforever> > maxBound Double
21:54:32 <lambdabot>      Not in scope: data constructor ‚ÄòDouble‚Äô
21:54:32 <lambdabot>      Perhaps you meant variable ‚Äòdouble‚Äô (imported from Text.PrettyPrint.Hugh...
21:54:42 <dramforever> huh
21:54:46 <Pamelloes> yeah...
21:54:47 <joobus> Welkin: there is.  they are both languages for accomplishing tasks.
21:54:47 <dramforever> > maxBound :: Double
21:54:49 <lambdabot>      No instance for (Bounded Double) arising from a use of ‚ÄòmaxBound‚Äô
21:54:49 <lambdabot>      In the expression: maxBound :: Double
21:54:55 <dramforever> =(
21:55:04 <Pamelloes> That was my first thought...
21:55:58 <Pamelloes> Basically, I need to make sure any Int64 can be losslessly turned into a Double.
21:56:18 <joobus> golang is google's child, and relatively new.  Haskell has the wisdom of years, but few people use it.  Both have models for concurrency, and both can accomplish the same kinds of things.  I'd think that haskell would be more mature than golang.
21:56:28 <joobus> but i'm not an expert on either at the moment
21:57:11 <Hafydd> "Both can accomplish the same kinds of things." - Indeed, both are Turing-complete languages.
21:57:19 <Pamelloes> joobus: I think what Welkin meant was that they are designed with very different philosophies. So while there is a comparison, it might not be a very meaningful one.
21:57:20 <bob_twinkles> Pamelloes: not safely in all cases, Double is only guaranteed to have IEEE754 double precision which can't accurately represent the full Int64 range
21:57:36 <Pamelloes> Hm.... Well, it's probably good enough.
21:57:51 <Welkin> > maxBound Int
21:57:53 <lambdabot>      Not in scope: data constructor ‚ÄòInt‚Äô
21:57:53 <lambdabot>      Perhaps you meant one of these:
21:57:53 <lambdabot>        ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
21:57:59 <Welkin> > maxBound :: Int
21:58:01 <lambdabot>  9223372036854775807
21:58:02 <Welkin> > maxBound :: Float
21:58:03 <lambdabot>      No instance for (Bounded Float) arising from a use of ‚ÄòmaxBound‚Äô
21:58:04 <lambdabot>      In the expression: maxBound :: Float
21:58:04 <dramforever> Hafydd: what about concurrency stuff?
21:58:13 <dramforever> oh that's similar isn't it
21:58:30 <Hafydd> I was being facetious, talking about just pure computation.
21:59:28 <joobus> Pamelloes: I understand one is functional and the other is not.  However, in terms of writing concurrent programs, both are capable, i think.  golang has made some noobish oversights/design decisions.
22:00:07 <Welkin> joobus: go is a pet project backed by the google marketing machine
22:00:12 <joobus> in terms of concurrency, i think object oriented programming is not necessarily the way to go
22:00:35 <y> golang makes pretty easy to have a few silly race conditions which are simply impossible in Haskell, you can share data structures that you can mutate later on in Go (AFAIK?)
22:00:48 <y> golang's type system is also really primitive, it doesn't even supports generics!
22:00:51 <joobus> Welkin: i agree, and I personally don't like google.  however, go is popping up in more and more job descriptions lately
22:01:07 <Welkin> joobus: that is not a good reason to learn it
22:01:09 <dramforever> also 5 years of swift experience =)
22:01:14 <Welkin> I try to spread haskell wherever I go
22:01:18 <dramforever> Welkin: it is
22:01:30 <ttt_fff> what is it about OTP that is so hard to do in cloud haskell?
22:01:41 <ttt_fff> what is it about OTP that is so hard to do in cloud haskell? is there something fundamentaly hard, or are the cloudhaskell guys a bunch of slackers?
22:01:42 <dramforever> for example people know php is bad, but companies want php programmers
22:01:52 <Welkin> dramforever: you have to break the cycle
22:02:04 <ttt_fff> breaking the cycle is easy
22:02:06 <Welkin> companies are always behind, running on legacy software
22:02:07 <ttt_fff> break the fingers of php programmers
22:02:13 <joobus> Welkin: well a guy at work started implementing go for his task/pet project and now it's being pushed on everyone.   i mention haskell and get nasty looks.  also, the guys at my office are pretty wedded to OO programming.
22:02:30 <johnw> ttt_fff: OTP has the backing of a huge commercial company
22:02:32 <dramforever> to break the cycle, start a company and make those using php die
22:02:50 <Welkin> dramforever: I use haskell in all my products/projects
22:03:15 <dramforever> joobus: yes it's amazing how many people think they're language/framework/... is the best
22:03:40 <dramforever> I once saw someone ask "Can haskell offer these advantages of node.js?"
22:03:52 <Welkin> oh god
22:03:55 <dramforever> and #4 "Callbacks instead of thread management"
22:03:58 <dramforever> wtf
22:03:58 <Welkin> "node is async, man"
22:04:08 <ttt_fff> johnw: but the codebase is not large right? I mean, wtf otp has been around for 20 years, th eprinciples are well established, how hard is it to clone
22:04:09 <dramforever> looks as if callbacks are easier than threads
22:04:21 <y> dramforever: I would answer "Node.JS advantages are workarounds to problems created by itself" :D 
22:04:31 <johnw> ttt_fff: when stuff is free, it develops at its own pace
22:04:38 <johnw> if you want it to move faster, you know what to do
22:04:38 <dramforever> joobus: btw you can show them some code to make them "wow"
22:04:59 <ttt_fff> johnw: kidnap + hold hostage family of most productive ahskell programmers, and release them only after cloud haskell matches OTP ?
22:04:59 <dramforever> johnw: throw money at it?
22:05:24 <johnw> money and effort
22:06:02 <dramforever> y: actually I would say that it's yet another way to do IO
22:06:11 <bob_twinkles> https://en.wikipedia.org/wiki/Open_Telecom_Platform OTP?
22:06:12 <dramforever> good? bad? I don't know
22:06:15 <ttt_fff> y: how did you reigster that nick
22:07:04 <Pamelloes> ttt_fff: He's probably been around a while :P
22:07:04 <y> ttt_fff: a friend gave it to me :P 
22:07:14 <Pamelloes> Or he knew a guy.
22:07:30 <q`> btw you can also pick short nicks with unusual symbols
22:07:31 <q`> like me
22:07:31 <johnw> or maybe he's the actual combinator himself
22:07:45 <q`> I learnt it from jle`
22:07:48 * y f = f (y f)
22:07:57 <Welkin> lol
22:07:57 <Pamelloes> How to get cool stuff: 1) be in the right place at the right time or 2) know a guy
22:07:58 * q` is registered last month, iirc
22:08:16 <Pamelloes> I think I registered four or five years ago :D
22:08:23 <y> Pamelloes: well, my friend got it by (1) :p 
22:08:24 <joobus> dramforever: eventually I may be able to wow them, but right now the codebase at work is one monster ball of code.  All the state if contained in massive objects, and it's a mess
22:08:27 * Pamelloes has been using his nick a loooooon time
22:08:40 <Welkin> joobus: is it rails
22:08:40 <Welkin> ?
22:08:47 <joobus> python twisted
22:08:55 <johnw> Pamelloes: I registered in Oct 2000
22:08:59 <dramforever> joobus: one thing I really dislike about haskell though
22:09:08 <dramforever> is lazy evaluation
22:09:17 <Welkin> johnw: we'll get off your lawn
22:09:20 <dramforever> because 1. It's not easy to use well
22:09:31 <dramforever> 2. well...there isn't much else to dislike, really
22:09:38 <Welkin> dramforever: lazy evaluation is a benefit
22:10:04 <bob_twinkles> it's really hard to reason about performance-wise coming from a strict, imperative background though
22:10:06 <dramforever> Welkin: it's the primary source of wtf for experienced haskellers
22:10:09 <johnw> Welkin: back then everyone was like, "What is freenode?"
22:10:34 * Pamelloes is sad -- he reformatted his database and is down to less than 5k entries meeting his criteria
22:10:34 <y> johnw: I didn't even my own computer in the 2000s! 
22:10:46 <y> uh, I can't english
22:10:59 <Welkin> dramforever: https://izbicki.me/blog/fast-nearest-neighbor-queries-in-haskell.html
22:11:11 <Pamelloes> johnw: Damn. I'm not even sure if I was alive back then...
22:11:19 <johnw> Pamelloes: hah!
22:11:25 <johnw> Pamelloes: I've been "johnw" in online communities since 1988
22:11:29 <bob_twinkles> that's probably the #1 thing I dislike about haskell... the amount of magic the RTS does. I love the convenience it provides, but it takes more digging to figure out exactly what your code is doing
22:11:30 <dramforever> Welkin: yes I agree that lazy evaluation has benifits
22:11:34 <dramforever> *benefits
22:11:37 <Pamelloes> johnw: I definitely wasn't alive back then :D
22:11:52 <dramforever> bob_twinkles: one of my friends complain about haskell's magicness
22:12:23 <dramforever> he said (translated) "In C++ I know what a line of code will be compiled into"
22:12:41 <johnw> dramforever: well, if that's what you want, it's a legitimate complaint
22:12:44 <Welkin> well, that is what a high level language is for
22:12:45 <dramforever> in haskell it's full of wtf trying to do so
22:12:50 <y> well, I consider it a feature
22:12:58 <Pamelloes> johnw: It's pretty awesome that over a quarter-century later you're not only using the same nick but still up to date with technology :)
22:12:59 <dramforever> johnw: he is very picky isn't he
22:13:13 <johnw> some people think behavior is more important than meaning
22:13:20 <joobus> dramforever: i doubt your friend knows assembly...
22:13:31 <dramforever> joobus: he knows a great deal of assembly
22:13:42 <joobus> dramforever: oh.
22:13:43 <johnw> actually, that debate has been raging since like 3000 BC
22:13:56 <funfunctor> Hi
22:14:05 <dramforever> joobus: he is very low-level, in terms of usage of programming languages
22:14:11 <funfunctor> hey johnw ; dramforever !
22:14:16 <johnw> hi funfunctor
22:14:23 <funfunctor> how are you guys?
22:14:24 <dramforever> funfunctor: hi =)
22:14:24 <Pamelloes> *GUR this stick better function GUR* *GUR this stick better look GUR* *fight*
22:14:37 <dramforever> funfunctor: I'm fine, thank you. And you?
22:14:40 <dramforever> =)
22:14:47 <bob_twinkles> yep, that's definitely the feeling I have writing haskell... I have no idea what actually gets run.
22:14:54 <funfunctor> pretty good, weather is good currently!
22:14:58 <bob_twinkles> and I acknowledge that most of the time I shouldn't have to care, but it bothers me =P
22:15:05 * dramforever looks outside
22:15:21 <dramforever> yes good weather here, too
22:15:45 <Zemyla> dramforever: He must not use templates very much, if he knows what every line will compile to.
22:15:54 <Zemyla> Or else he's a template god.
22:15:56 <dramforever> Zemyla: I guess so
22:16:00 <bob_twinkles> even with templates you can make some good guesses
22:16:09 <dramforever> I mean, I guess he doesn't like templates
22:16:16 <bob_twinkles> and worse comes to worse you can just dump an annotated object file =P
22:16:34 <Pamelloes> I think it's less about knowing exactly what it will compile to and more about what it roughly will compile to.
22:16:35 <dramforever> he once wrote a flow-diagram based programming language
22:16:40 <Zemyla> If he doesn't like templates, why does he use C++?
22:16:53 <dramforever> and after some basics, he added *dll calls*
22:16:58 <bob_twinkles> though I guess with 7.10.(something) you can do that in haskell as well, given the addition of DWARF support
22:16:59 <funfunctor> bob_twinkles: asm and haskell from a abstract level are the same thing; representation of state transitions. Why would knowing the instructions being run give you the impression that you understand the great volume of state transitions of todays software better than a haskell program. One could argue the Haskell program actually gives you a better idea
22:17:02 <dramforever> wait is that off topic?
22:17:12 <Welkin> Pamelloes: that sounds more like 2,000,000 BC
22:17:21 <dramforever> funfunctor: who knows
22:17:30 <dramforever> btw he isn't saying haskell is bad
22:17:32 <johnw> we're starting to argue C++ vs. Haskell, which is a bit fruitless
22:17:36 <Pamelloes> Welkin: hm....... true.
22:17:38 <Zemyla> I mean, the only reason to use C++ nowadays is to run half your program at compile time with ridiculous template magic.
22:17:43 <dramforever> maybe I shouldn't have used "complained"
22:17:47 <Welkin> 3000 BC is almost yesterday
22:18:02 <Zemyla> That's all I want from Haskell, too. :P
22:18:16 <bob_twinkles> funfunctor: because I can apply my understanding of what the CPU is doing to ASM, and I can't do that to haskell code (yet? I feel like as I read/write more code I'll get a better sense of that)
22:18:35 <funfunctor> dramforever: I know, its just interesting peoples views on representation in that folks pick one representation over another and claim it is more fundamental to reality in some way. Just a interesting human thing really :)
22:18:46 <johnw> I doubt anyone knows exactly what a modern CPU is doing
22:18:57 <funfunctor> bob_twinkles: yep probably, its good to know both
22:19:00 <joobus> johnw: +1
22:19:17 <Pamelloes> johnw: What about the dude that designed it?
22:19:23 <bob_twinkles> nope =P
22:19:23 <Pamelloes> Probably just a hack...
22:19:30 <Welkin> Pamelloes: computers design chips these days
22:19:33 <johnw> the guy who designed binary probably didn't envision YouTube
22:19:34 <Zemyla> I want to write a Brainfuck program as t
22:19:35 <bob_twinkles> modern superscalars are _really_ complicated
22:19:38 <funfunctor> bob_twinkles: like knowing VHDL helps a lot in understanding asm more fundamentally and you could draw similar views
22:19:40 <joobus> Pamelloes: No "one" dude designs anything anymore
22:19:43 <ski> dramforever : .. reminds me of <http://strlen.com/language-design-overview>
22:19:44 <Welkin> well, large teams of engineers use computers to design them
22:19:45 <dramforever> funfunctor: you mean those register renaming, pipelines, branch prediction, etc. ?
22:20:06 <Zemyla> *in the type of an object, and compile it when I compile the program.
22:20:17 <dramforever> whow
22:20:20 <dramforever> whoa'
22:20:40 <bob_twinkles> funfunctor: eh, not really. I don't care about the gates, I care about what things cost in terms of cycles and cache efficiency, and the ASM level is the right level of abstraction for looking at that sort of thing 
22:21:49 <Pamelloes> Can you use multiple where clauses in esqueleto?
22:21:58 <funfunctor> bob_twinkles: not really, because some ISA's can do things in one clock that others need much more
22:22:11 <Welkin> Pamelloes: I think you provide a list?
22:22:33 <bob_twinkles> yeah. Any time you start (micro)optimizing at the assembly level your tying yourself to a specific architecture
22:22:40 <bob_twinkles> *you're
22:22:42 <funfunctor> bob_twinkles: Just knowing _an_ asm dialect does not make you all-knowing in cost complexity
22:22:43 <dramforever> ski: so what do you mean?
22:22:47 <Pamelloes> Welkin: Hm? I mean a where clause as in "where_ (....)"
22:22:53 <funfunctor> bob_twinkles: sure
22:23:12 <ski> dramforever : just an association on "flow-diagram based programming language"
22:23:14 <Pamelloes> You can have multiple conditions within the where clause, but I'm not sure if you can have multiple clauses alltogether.
22:23:37 <funfunctor> bob_twinkles: speed should remain as a maths problem and representation should remain as a language problem.. folks mix the two up
22:24:04 * ski isn't sure what Pamelloes means
22:24:17 <dramforever> ski: interesting
22:24:25 <Pamelloes> ski: In Esqueleto.
22:24:27 <johnw> select $ from $ \p -> where_ () >> where_ () >> where_ ()
22:24:38 <johnw> that may or may not mean something
22:24:52 <Pamelloes> johnw: Right. That's my question. Is that valid?
22:24:56 <johnw> try it out
22:25:10 <bob_twinkles> in an ideal world, but compilers aren't always sufficiently intellegent... I'm definitely not saying we should write everything in C/asm for PERFORMANCE!!11eleven1, but there are times when you need to drop to a lower level of abstraction (for which haskell has the FFI I guess)
22:25:40 <ski> Pamelloes : not sure what that is
22:26:23 <Welkin> yeah, in a sql query you combine multiple tests with AND
22:26:34 <Pamelloes> johnw: It does work :D
22:26:40 <Welkin> but in esqueleto it looks like you can only provide one test
22:27:02 <johnw> bob_twinkles: as with any optimization, people over-emphasize the need to explicitly tell the machine exactly how it should go about providing an answer.  And as with optimization, sometimes it's needed and extremely useful.  But here in #haskell we like for the compiler to figure out the details as often as possible -- and it does a suprisingly good job at it much of the time
22:27:09 <Welkin> actually, you may be able to combine them into one
22:27:14 <Welkin> using logical connectives
22:27:16 <Welkin> &&
22:27:19 <Welkin> ||
22:27:29 <Welkin> try that too Pamelloes 
22:27:40 <johnw> I have a feeling that multiple where_ blocks is implicitly &&
22:27:45 <bob_twinkles> for sure, that's one of the main reasons I like haskell: the language is well defined and the compilers are quite smart =D
22:27:52 <Pamelloes> johnw: It is. That's what I just checked.
22:28:27 <y> johnw: and optimization within Haskell is basically a matter of giving the compiler more information, not bypassing it
22:28:48 <bob_twinkles> stuff like Accelerate is basically just Haskell laughing in the face of all the C/C++ guys who have to hand-write SIMD/vectorized code =P
22:28:55 <Pamelloes> Welkin: Yep, that works.
22:29:25 <dramforever> bob_twinkles: ICC laughs
22:29:30 <dramforever> (Intel C Compiler)
22:29:40 <bob_twinkles> true, ICC is _very_ clever
22:30:14 <dramforever> so one day someone wrote a timing loop
22:30:24 <dramforever> and ICC managed to optimize it away
22:30:28 <Welkin> but C is 43 years old and the most widely used language in the world
22:30:45 <dramforever> I mean, repeating an operation many times to time it
22:30:47 <Pamelloes> For now. Haskell is on teh rise :D
22:30:59 <bob_twinkles> optimizing away timing loops is a pretty common stunt for compilers to pull I think
22:30:59 * dramforever checks github
22:31:02 <johnw> Haskell also has volunteers and researchers behind it, not massive corporations
22:31:03 <funfunctor> bob_twinkles: giving compilers more information about your program allows the compiler to make better decisions. Further, I would argue that modern compilers tend to be a lot smarter than developers today having worked on a number of modern compilers myself. Developers always think themselves as Gods (pointers, un-safe memory access, etc..) but they are not!
22:31:04 <Pamelloes> But yeah, C will be the most widely used language for at least another 50 years...
22:31:08 <Welkin> plus, it is a thin wrapper over assembly
22:31:11 <johnw> when you compare apples to apples, it's damn impressive
22:34:32 <dramforever> to me C is just assembly with a nice marco system
22:34:45 <Zemyla> There needs to be a version of Const that's just on Nums, and is an Alternative, with <*> = * and <|> = +.
22:34:58 <dramforever> although that's enough for many stuff
22:35:14 <Zemyla> dramforever: Does it have a nice polo system too?
22:35:19 <dramforever> Zemyla: how are you expected to use it?
22:35:48 <johnw> Zemyla: you can certainly define that instance if you like
22:35:53 <johnw> Zemyla: not sure how popular that would be
22:36:15 <Zemyla> Well, less just Nums and more any semiring.
22:36:22 <dramforever> funfunctor: I would say that well-optimized C is much faster than naively coded assembly
22:36:37 <dramforever> Zemyla: why not just (+) and (*)?
22:36:38 <ronh> Pamelloes I hope not
22:36:42 <ttt_fff> i agree
22:36:57 <johnw> dramforever: there may be some algorithm he's using that works over Applicative or Alternative, rather than taking a number
22:37:18 <dramforever> johnw: that's weird
22:37:28 <dramforever> isn't it
22:37:38 <johnw> sometimes you work with what you've got
22:37:53 <johnw> i'm not suggesting that he lift numbers into Applicative just to do math with them
22:37:53 <Welkin> shake what your mama gave you!
