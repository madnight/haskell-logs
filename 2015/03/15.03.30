00:15:32 * hackagebot focus 0.1.4 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-0.1.4 (NikitaVolkov)
00:17:09 <L8D> how can I use CPP pragma to handle two versions of a library?
00:17:33 <L8D> something like: #if somepackage == 1.4.*
00:17:39 <L8D> codehere
00:17:45 <L8D> #elsif somepackage == 1.5.*
00:17:47 <L8D> othercodehere
00:17:54 <L8D> what can I do?
00:18:27 <L8D> I guess it's the MagicHash pragma
00:19:31 <mauke^> that's not how any of this works
00:19:45 <L8D> well then I need to update the code here:
00:19:46 <L8D> https://github.com/Happstack/happstack-server/blob/master/src/Happstack/Server/Internal/LogFormat.hs
00:20:01 <L8D> to handle time 1.4 and 1.5 seperately
00:20:19 <absence> if i define a function "f = (Vector.generate n g Vector.!)", what are the conditions that must hold if i want to avoid generating the vector each time f is called?
00:20:22 <L8D> time 1.5 puts locales into Data.Time.Format
00:20:37 <L8D> time 1.4 uses old-locale which is in System.Locale
00:20:48 <L8D> is there any way to do that?
00:20:49 <mauke^> https://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
00:21:33 <L8D> mauke^: thanks, that's exactly what I'm looking for
00:24:58 <frerich> I'm running the Haskell platform and now people are filing bugs for my packages because the builds fail with GHC 7.10.1 (because of the 'base < 4.8' bound). I wonder: 1.) Is it good practice to have an upper bound on 'base' and 2.) Is there an easy way to test patches without looking into how to install a new GHC version in addition to what I already have?
00:25:20 <frerich> I'm pretty sure the upper-bound is all that needs to be adjusted, but I'd like to try it anyway - just in case.
00:28:05 * frerich notices there's no native Mac binary on https://www.haskell.org/ghc/download_ghc_7_10_1
00:33:42 <glguy> Native Mac binary is coming shortly. You should definitely have a base upper bound if you haven't tested with it yet 
00:43:42 <frerich> Hm, would anybody who's running GHC 7.10.1 already mind doing a 'git clone -b support_ghc_7_10_1 https://github.com/frerich/catamorphism' and then see whether 'cabal build' works?
00:45:34 * hackagebot hasql 0.7.3 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.7.3 (NikitaVolkov)
00:48:33 <supki> frerich: yep, http://lpaste.net/6836140883440566272
00:49:23 <frerich> supki: Ah, thanks! Interesting warning, too.
00:50:34 * hackagebot getopt-generics 0.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.1 (SoenkeHahn)
00:50:36 * hackagebot effect-handlers 0.1.0.6 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.6 (edofic)
00:52:25 <supki> frerich: oh, and the upper bound on template-haskell is too restrictive, had to bump it to < 2.11
00:54:22 <frerich> supki: Alright, thanks!
01:00:35 * hackagebot catamorphism 0.4.0.0 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.4.0.0 (frerich)
01:00:37 * hackagebot smartconstructor 0.2.0.0 - A package exposing a helper function for generating smart constructors.  http://hackage.haskell.org/package/smartconstructor-0.2.0.0 (frerich)
01:05:35 * hackagebot getopt-generics 0.1.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.1.1 (SoenkeHahn)
01:17:46 <Guest16593> noob question, last $ take 2 [1,2,3,4,5]    can be written as    ((last.). take) 2 [1,2,3,4,5]    i am a bit fuzzy about (last.).take  part, why not just last.take?  Thank you
01:18:45 <shachaf> You generally shouldn't write it that way because it's confusing.
01:18:56 <shachaf> But let's expand it: (f . g) x = f (g x)
01:19:36 <shachaf> So (last . take) 2 [1,2,3,4,5] = last (take 2) [1,2,3,4,5]
01:21:42 <Guest16593> @shachaf  that helps, thank you (i was trying a solution for the k-th element in a list :) )
01:21:42 <lambdabot> Unknown command, try @list
01:25:36 * hackagebot postgresql-binary 0.5.2 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.5.2 (NikitaVolkov)
01:39:51 <m00nlight> How can I parse negative integer using Parsec correctly? 
01:40:23 <m00nlight> The minus can be either binary or unary operator
01:48:32 <m0rphism> m00nlight: Is the problem a theoretical one, the you don't know how to make your grammar unambiguous, or is it a technical one, that parsec can't work with particular grammars even if they are unambiguous?
01:49:05 <m0rphism> in the former case I could help, in the latter I'm probably not experienced enough with parsec to know the technical details
01:50:38 * hackagebot stm-containers 0.2.9 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.9 (NikitaVolkov)
01:50:47 <m00nlight> m0rphism: In fact, it is a very simple practical problem
01:50:49 <m00nlight> http://pastebin.com/7T7iXFsa
01:51:03 <m00nlight> I want to write an evluator which can do arithemtic calculation
01:51:18 <m00nlight> It only have +, -, *, / 
01:51:30 <m00nlight> but the minus (-) operator can be either an binary operator or an unary one
01:52:09 <m00nlight> So for the code, it can evaluate "-4/2" correct, but can not evaluate "-4/-2", it will show parse error
01:55:49 <absence> if i define a function "f = (Vector.generate n g Vector.!)", what are the conditions that must hold if i want to avoid generating the vector each time f is called?
02:00:38 * hackagebot hasql-postgres 0.10.3 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.3 (NikitaVolkov)
02:02:49 <caconym> absence: i don't know the answer to your question, but it's an interesting one
02:03:12 <caconym> absence: have you observed that there are conditions under which the vector is generated each time f is called?
02:04:13 <caconym> absence: that is, a new vector is allocated etc
02:04:35 <m0rphism> m00nlight: it seems to be a preceedence problem.
02:05:06 <m0rphism> m00nlight: if you make the negation - the first item of table it works
02:05:45 <herzult> Hello :)
02:05:56 <solirc> hmm, I'm puzzled right now what the most straight forward way to dump the interface (function signatures, data types, etc.) of a module of an installed package would be?
02:07:20 <solirc> ghc-pkg does not provide that functionality, AFAICT
02:07:32 <m00nlight> m0rphism: Thanks, Yes, it works, so the table's order is actually reflect the preceedence?
02:07:44 <absence> caconym: yes. i rearranged stuff around until it stopped doing that, but i would love to understand why rather than experiment :)
02:07:44 <m0rphism> it seems so
02:08:11 <m0rphism> m00nlight: the documentation is talking about precedence, but there is no explicit value specifying it anywhere else :)
02:08:52 <absence> caconym: at one point it even happened when the generated vector was bound to a name using let, so the function was just (v !)
02:09:35 <m00nlight> m0rphism: Thanks for your help :)
02:09:44 <m0rphism> m00nlight: Your welcome :)
02:10:10 <m0rphism> m00nlight: Now I know about buildExpressionParser ;)
02:10:32 <caconym> absence: whoa, that's really interesting/scary; i'd have (naively) expected it not to reallocate
02:10:57 <caconym> absence: i'm going to be checking the logs tomorrow to see if anyone answered your question :)
02:13:19 <absence> caconym: it surprised me as well, especially since i use the vector as a lookup table for performance. turns out recalculating the table on every lookup isn't so fast ;)
02:13:38 <caconym> heh
02:14:08 <aloiscochard> how can I get 7.10 RC3 on archlinux "easily"?
02:15:14 <herzult> does anybody has experience with the mongoDB package?
02:16:11 <Cale> aloiscochard: get a binary package from here? http://downloads.haskell.org/~ghc/7.10.1-rc3/
02:16:36 <aloiscochard> Cale: sounds like a plan, cheers
02:19:52 <caconym> solirc: maybe this looks promising? https://hackage.haskell.org/package/docidx
02:21:30 <solirc> caconym: Hm, I think not exactly what I'm looking for
02:22:02 <solirc> right now I'm interested in the type of all prelude functions
02:22:18 <solirc> ideally I want to turn that into a test suite for base-compat somehow
02:23:14 <caconym> solirc: ah, gotcha; that package didn't build for me anyway
02:23:49 <solirc> caconym: Where is the bug report?
02:27:07 <caconym> solirc: coming soon, after i get some sleep ;)
02:28:00 <solirc> caconym: But just quickly, how did it fail?
02:28:48 <caconym> src/Distribution/GhcPkgList.hs:64:29: Expecting one more argument to ‘PackageIndex’
02:29:01 <caconym> src/Distribution/GhcPkgList.hs:74:18: Expecting one more argument to ‘PackageIndex’
02:30:30 <caconym> more verbosity
02:30:39 <caconym> src/Distribution/GhcPkgList.hs:64:29:
02:30:39 <caconym>     Expecting one more argument to ‘PackageIndex’
02:30:39 <caconym>     The first argument of ‘IO’ should have kind ‘*’,
02:30:39 <caconym>       but ‘PackageIndex’ has kind ‘* -> *’
02:30:39 <caconym>     In the type signature for ‘listInstalledPackages’:
02:30:42 <caconym>       listInstalledPackages :: IO PackageIndex
02:31:14 <caconym> ghc 7.8.4
02:35:41 * hackagebot random-hypergeometric 0.1.0.0 - Random variate generation from hypergeometric distributions  http://hackage.haskell.org/package/random-hypergeometric-0.1.0.0 (srijs)
02:38:41 <ion> aloiscochard: Why not 7.10.1?
02:39:09 <aloiscochard> ion: because I was shamefully not aware the final was out ;)
02:39:14 <aloiscochard> so I took the final binary
02:39:23 <aloiscochard> was hoping for a package though :-( I have to be a bit more patient
02:41:36 <ion> aloiscochard: FWIW, this is what i do: https://gist.github.com/ion1/2815423
02:42:41 <aloiscochard> ion: that looks like a nice way to install until the official package release, ta
02:42:58 <aloiscochard> okay I'll try that, great
02:57:44 <dawik> edwtjo: hej
03:15:43 * hackagebot extensible 0.3.2 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.2 (FumiakiKinoshita)
03:17:30 <hseg> Hi. I have the cached memory that SKI calculus is equivalent to intuitionistic logic, but I can't seem to find a way to mechanically translate proofs from SKI to intuitionistic logic. (The other direction is trivial)
03:35:44 * hackagebot Cabal-ide-backend 1.23.0.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-ide-backend-1.23.0.0 (MichaelSnoyman)
03:55:45 * hackagebot ide-backend-rts 0.1.3 - RTS for the IDE backend  http://hackage.haskell.org/package/ide-backend-rts-0.1.3 (MichaelSnoyman)
04:10:06 <merijn> Any of the CT and maths people around to answer a question for me (well, I guess not so much answer a question as restate something so maybe I'll understand it...)
04:11:05 <merijn> I don't understand the notion of a Cayley representation. In Awodey it's mentioned that "Every group G is isomorphic to a group of permutations", but I don't understand what's going on
04:11:33 <Athas> How can I ask cabal to build/install using a specific version of GHC?
04:11:43 <Athas> This seems like a common thing to do, but I cannot find any easy way.
04:13:44 <merijn> Athas: Cabal uses whichever version is first in your path
04:13:55 <merijn> Athas: So I just change my path when I wanna change ghc versions
04:14:05 <merijn> Is that easy enough? ;)
04:15:04 <Athas> Actually, that's very inconvenient, since that means I need to install every GHC in its own tree (which I have not done, so I will need to reinstall them all).
04:15:14 <Athas> But I suppose if that's the only way...
04:15:48 * hackagebot repa-convert 4.0.1.0 - Packing and unpacking binary data.  http://hackage.haskell.org/package/repa-convert-4.0.1.0 (BenLippmeier)
04:15:50 * hackagebot repa-convert 4.1.0.1 - Packing and unpacking binary data.  http://hackage.haskell.org/package/repa-convert-4.1.0.1 (BenLippmeier)
04:15:54 <merijn> I'm not sure it's the only way, but it's the way I've always used
04:16:10 <mpickering> Athas: You can use the -w flag i.e. cabal configure -w ghc-7.8.4
04:16:21 <mpickering> or specify the with-compiler: option in the cabal.config file
04:17:07 <Athas> mpickering: will that also pick up the right versions of ghc-pkg and such?
04:19:55 <mniip> is there a prefix variant for (.)
04:20:00 <mniip> oh right, fmap
04:20:48 * hackagebot ide-backend 0.9.0 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0 (MichaelSnoyman)
04:20:50 * hackagebot repa-stream 4.1.0.1 - Stream functions not present in the vector library.  http://hackage.haskell.org/package/repa-stream-4.1.0.1 (BenLippmeier)
04:20:52 * hackagebot repa-array 4.1.0.1 - Bulk array representations and operators.  http://hackage.haskell.org/package/repa-array-4.1.0.1 (BenLippmeier)
04:21:35 <mpickering> Athas: yep, should do
04:22:08 <Lis> hello everyone. i have a list of a csv file content. how do i iterate over elements within the row. ["el1","el2","el3","el4"] should loop over ["el1","el2"] then ["el3","el4"]
04:22:31 <Athas> mpickering: okay, thanks, I will try.
04:22:42 <Athas> Lis: try using 'transpose' first.
04:22:50 <Athas> Oh, wait, I misread.
04:23:17 <Athas> So the list is flat, but conceptually it should be [["el1","el2"],["el3","el4"]]?
04:23:38 <Lis> i want to keep it flat if possible
04:24:06 <Athas> Well, you'll need to convert it to a list-of-lists (or list-of-tuples) and then map across that.
04:24:26 <Athas> Note that this will not actually be as slow as it sounds, due to lazy evaluation.
04:24:29 <Lis> so it's not possible? i cant believe that
04:24:55 <Athas> You can write your own specialised ad-hoc map function, but there is no point in it.
04:25:20 <absence> if i define a function "f = (Vector.generate n g Vector.!)", what are the conditions that must hold if i want to avoid generating the vector each time f is called?
04:25:49 * hackagebot repa-flow 4.1.0.1 - Data-parallel data flows.  http://hackage.haskell.org/package/repa-flow-4.1.0.1 (BenLippmeier)
04:28:18 <khanzor> Lis: have you tried searching on hoogle for the type that you want? e.g. [a] -> [(a,a)]
04:30:29 <Lis> khanzor, no but interresting to know about that search
04:30:49 * hackagebot ide-backend 0.9.0.1 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.1 (MichaelSnoyman)
04:31:28 <khanzor> Lis: what type do you want? if it is something like [a] -> [(a,a)], then simple recursion might be your best bet
04:31:37 <khanzor> unless you have something more sophisticated in mind?
04:32:12 <Lis> khanzor, for the starting point [a] -> [(a,a)] would be enough
04:32:59 <Lis> i also found this http://stackoverflow.com/questions/16422781/haskell-make-a-2d-list-out-of-a-1d-list
04:35:50 * hackagebot nero 0.1 - Lens-based HTTP toolkit  http://hackage.haskell.org/package/nero-0.1 (jdnavarro)
04:37:00 <frerich> Lis: You could use 'chunksOf' from Data.List.split
04:37:28 <nshepperd> merijn: any element of a group g ∈ G is equivalent to a function (\x -> gx) :: G -> G. This function is necessarily a permutation of G, because it has an inverse. So if you consider the set {(\x -> gx) : g ∈ G} this is a set of permutations (over G), and it turns out, a group itself (under function composition)
04:41:52 <mniip> damn contravariance always reminding about itself
04:42:44 <nshepperd> um, to demonstrate the equivalence, reflect :: G -> (G -> G); reflect g = (\x -> g·x);   reify  :: (G -> G) -> G; reify f = f e
04:43:59 <nshepperd> you can prove a bunch of laws about reify and reflect that make sure that it's actually an isomorphism, and that the set {(\x -> gx) : g ∈ G} is really a group
04:44:53 <mauke^> ooh, and it maps e to id
04:44:59 <mauke^> I feel right at home
04:46:48 <marekw2143> hello
04:50:50 * hackagebot ghc-typelits-natnormalise 0.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.1 (ChristiaanBaaij)
04:53:57 <haskell070> hi
04:54:10 <mauke^> lo
04:54:16 <nymacro> hi
04:55:50 <haskell070> I am trying to figure out how to use an IRC channel. It's my first time. It seems kind of strange 
04:56:32 <tzaeru> well, it's just a bunch of people who all get the same messages! :P
04:56:59 <haskell070> so pretty much like a public chatroom, right?
04:57:06 <tzaeru> a bit like that, yes.
04:57:21 <merijn> nshepperd: Right, so the Cayley representation of a group lifts every element g ∈ G into a function that uses the group operation together with g
04:57:33 <merijn> haskell070: It *is* a public chatroom
04:57:34 <haskell070> Nice. 
04:58:06 <merijn> nshepperd: And permutations are a group because they have inverses, identity and associativity
04:58:26 <mauke^> haskell070: what website are you on?
04:59:42 <haskell070> Oh, why? 
04:59:59 <merijn> nshepperd: That brings me to the next one: the Cayley representation of a category C has as objects "for every object O in C, the set of morphisms from O"?
05:00:12 <haskell070> #haskell on freenode? Should I be logged on from some place else? 
05:00:59 <mauke^> assuming http://webchat.freenode.net
05:01:10 <merijn> nshepperd: And the arrows are functions from "set of morphisms to sets of morphisms" via composition of the morphisms in C. It makes sense now! :)
05:01:23 <haskell070> yes, exactly from there 
05:01:25 <merijn> ish :p
05:01:34 <haskell070> but haven't signed up yet. 
05:02:10 <tzaeru> the actual IRC server we're on has no dependencies with any website tho; you can connect to this very same channel from multitude of sources, including non-browser ones.
05:02:28 <haskell070> Oh, I see. 
05:02:31 <nshepperd> merijn: that seems likely! but i'm not as familiar with categories
05:02:35 <tzaeru> or well, network rather than server.
05:02:36 <tzaeru> but still.
05:02:51 <haskell070> Thanks, I didn't have a clue.
05:03:45 <tzaeru> and ha.. I've one-week vacation coming up. should take a day or two in learning haskell with more time than 1.5 hours.
05:04:06 <tzaeru> I imagine that's one of the reasons established programmers would change slowly when it's about larger changes.. no time to.
05:04:22 <haskell070> Anyways, I started teaching myself Haskell yesterday from Learn You A Haskell For Great Good. I have read two chapters now. I have already fallen in love 
05:04:40 <fractalsea> Does anyone know how to convert Real/Fractional to a Double? Pulling my hair out over this.
05:04:47 <merijn> fractalsea: realToFrac
05:04:52 <merijn> :t realToFrac
05:04:53 <lambdabot> (Fractional b, Real a) => a -> b
05:05:06 <merijn> :t realToFrac :: Real a => a -> Double
05:05:07 <lambdabot> Real a => a -> Double
05:05:39 <merijn> tzaeru: There's a nice apt presentation on that by edwardk :)
05:05:41 <fractalsea> Oh, thank you! Don;t know why I couldn’t find that
05:06:36 <merijn> tzaeru: https://yow.eventer.com/yow-2014-1222/stop-treading-water-learning-to-learn-by-edward-kmett-1750
05:07:00 <tzaeru> 40 minutes?! too much..
05:07:05 <tzaeru> give me text :(
05:07:59 <merijn> The slides give an ok idea of the talk too
05:08:08 <makalu> I'm trying to create a library with cabal. There's one exposed module that uses other modules. When these other modules are not included in exposed modules, a program using this library will fail to link. The missing symbols are from those non-exposed modules. What's the correct way to have non-exposed utility modules in a cabal library?
05:08:16 <merijn> oh, the slides aren't linked there >.>
05:08:24 <tzaeru> mmmhm.
05:08:48 <merijn> tzaeru: http://yowconference.com.au/slides/yow2014/Kmett-StopTreadingWater.pdf
05:08:53 <mauke^> makalu: other-modules
05:09:09 <merijn> makalu: Put the non-exposed modules in "Other-Modules:"
05:10:04 <makalu> thank you. I can't believe how much time I wasted because of a small mistake like this.
05:10:11 <makalu> linking errors are not very helpful
05:10:21 <merijn> makalu: Word.
05:10:52 * hackagebot yesod-auth-hashdb 1.4.2.1 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.2.1 (paulrouse)
05:10:56 <tzaeru> mmh, the slides aren't very.. in-depth about anything.
05:11:04 <tzaeru> it's just contextless quotes after quotes :P
05:12:35 <merijn> tzaeru: Well, then you have to download the talk and listen to it :p
05:13:10 <tzaeru> and alas, the ideal solution -- applied, in this case, to productivity and learning -- is rarely the realistic solution. that's the exact problem, in-fact.
05:14:04 <tzaeru> if you *have to* be done with a thing in 4 weeks, are you going to spend 3.5 of that in learning something new or just applying pre-existing, even if suboptimal, know-how?
05:14:07 <merijn> That's why he talks about iterative deepening, spaced repetition and other ways to avoid "wasting" what you've learned
05:15:07 <tzaeru> mmhm. well, no time to listen to the full talk atm, mayhaps later.
05:15:50 <merijn> Listen to it during your commute ;)
05:16:20 <tzaeru> no device to let me do that, I'm afraid
05:17:33 <oherrala> w
05:17:36 <oherrala> oops, sorry
05:29:20 <benzrf> does tail recursing in a Reader with `local' optimize well
05:29:33 <benzrf> like
05:30:20 <benzrf> m = ask >>= tell >> local (subtract 1) m
05:30:25 <benzrf> imagine there's some sort of guard there
05:30:29 <benzrf> would that scale linearly?
05:58:02 <dredozubov> stumbled upon new a new problem with cabal-install http://lpaste.net/3888105795669196800
05:58:11 <dredozubov> can someone give it a look?
05:58:23 <dredozubov> happenned after updating cabal + cabal-install to 1.22
05:59:28 <dredozubov> build logs are empty
05:59:31 <dredozubov> this is confusing
06:00:56 <raptor_prime> Hey all
06:02:28 <mpickering> dredozubov: Try "cabal clean"
06:02:35 <dredozubov> tried it
06:02:55 <dredozubov> and i removed my whole sandbox
06:03:04 <mpickering> I had the same thing but can't remember how I sorted it
06:03:54 <dredozubov> btw it works fine with ghc 7.10.1
06:04:25 <dredozubov> i switch to 7.8.3 and it all goes to hell
06:05:16 <mniip> is there a generalized flip somewhere
06:05:30 <mniip> I thought of sequenceA, but ((->) e) doesn't fit into Traversable
06:08:18 <nkar`> dredozubov: just a guess: move ~/.cabal and ~/.ghc somewhere and try again
06:08:45 <nkar`> dredozubov: though, I'm not sure why it works with a different ghc version.  the db is version-specific, iirc
06:08:47 <mniip> hmm
06:08:51 <dredozubov> nkar`: i deleted them
06:08:53 <mniip> :t return . ap
06:08:54 <lambdabot> (Monad m, Monad m1) => m1 (a -> b) -> m (m1 a -> m1 b)
06:08:54 <dredozubov> it's not it
06:09:02 <mniip> nope
06:09:20 <nkar`> dredozubov: guessing again: tried verbose?
06:09:30 <dredozubov> nkar`: yep, that's why i'm totally frustrated at the moment
06:10:57 <mniip> :t (. return) . ap
06:10:58 <lambdabot> Monad m => m (a -> b) -> a -> m b
06:11:13 <nkar`> dredozubov: okay, I'm puzzled too.  does cabal get work?  do you use a proxy?
06:12:04 <dredozubov> nkar`: cabal get works and i'm not using a proxy
06:12:34 <nkar`> dredozubov: okay, I'm out of ideas.  maybe strace it
06:13:34 <dredozubov> maybe i should, i haven't though of it
06:16:07 <tdammers> hum, looks like responseLBS in older versions of WAI cuts off the response body... weird...
06:17:31 <tdammers> actually, no, it's not an older version
06:18:49 <tdammers> apparently the difference is either ghc 7.4 vs. 7.6, or 32-bit vs. 64-bit OS
06:19:03 <tdammers> anyone got any ideas why this would be happening?
06:19:18 <tdammers> I'm assuming lazy I/O is biting me somewhere, but I can't figure out how and where
06:26:46 <benzrf> ok
06:26:53 <benzrf> if i have this: let m = ask >>= \case [] -> return (); _:_ -> tell () >> local tail m
06:27:17 <benzrf> runReader (runWriterT m) (replicate n ()) does NOT use constant space and im not sure it runs in O(n)
06:27:20 <benzrf> how can i make that happen?
06:27:34 <benzrf> use strict writer?
06:29:02 <mniip> hmm
06:30:16 <benzrf> could i write a plain function instead of using MonadReader and then strictly tail recurse.
06:30:30 <benzrf> the actual use case is not a writer, it's tail-recursing with a new environment
06:30:35 <benzrf> er
06:30:38 <benzrf> i mean, IO or something
06:30:48 <mniip> I came up with a pair of fancy combinators
06:30:50 <benzrf> it's indefinite depending on use input so i want something with constant space
06:31:25 <lpaste> mniip pasted “fancy” at http://lpaste.net/129861
06:31:42 <benzrf> to be precise i have a readert for a player's turn that reads the current player, and list of players; i'm upgrading it to a readert for the whole game that updates the read state to cycle thru peoples turns
06:32:08 <mniip> one is essentially generalized flip, named so because it turns applicative "style" functions into monad "style"
06:32:21 <mniip> another is a thing that lets you enlarge the gap in that flip
06:32:57 <benzrf> oh wait i can just run it
06:32:59 <benzrf> frick
06:35:26 <benzrf> er, no i cant. here's the function in question http://lpaste.net/129862
06:36:12 <ocramz> hi all
06:38:33 <mniip> anyway, with this thingy you can define functions iteratively
06:38:40 <mniip> (<*>) = (fmap $ fmap join) $ (fmap fmap) $ (fmap appM) $ id
06:39:50 <mniip> it has an extra Monad constraint because I was originally aiming for the S combinator which is a specialization of <*> for ((->) e)
06:40:57 * hackagebot srcloc 0.5.0 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.5.0 (GeoffreyMainland)
06:41:09 <mniip> hmm
06:41:18 <mniip> one can now make pointfrees by hand!
06:45:03 <sagittarian|2> is deb.haskell.org gone?
06:45:36 <geekosaur> for the moment. ask in #haskell-infrastructure
06:45:58 * hackagebot mainland-pretty 0.2.7.2 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.7.2 (GeoffreyMainland)
06:46:00 * hackagebot Dung 1.1 - An implementation of the Dung argumentation frameworks.  http://hackage.haskell.org/package/Dung-1.1 (BasVanGijzel)
07:09:57 <bezirg> Can anybody explain to me why this simple concurrent does not print anything (note: GHC 7.8.4)? http://lpaste.net/129865
07:10:09 <bezirg> simple concurrent program*
07:11:00 * hackagebot Yampa 0.9.6.1 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.9.6.1 (IvanPerez)
07:11:01 * hackagebot cpphs 1.19 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.19 (MalcolmWallace)
07:13:06 <geekosaur> I think because the main thread is exiting before the children, so the finally never gets a chance to execute. (POSIX threads work the same way; the main thread is "special')
07:13:17 <merijn> Right
07:13:44 <merijn> bezirg: use an MVar/Chan to ensure your main thread doesn't terminate early
07:14:41 <kaidelong> mniip: I wound up with "flip (>>=) . flip (fmap . flip id)"
07:14:43 <bezirg> geekosaur: merijn: thank you
07:15:24 <mniip> :t flip (>>=) . flip (fmap . flip id)
07:15:25 <lambdabot> Monad m => m (b1 -> b) -> m b1 -> m b
07:15:30 <mniip> ah
07:15:59 <bezirg> another problem that I am facing: I use a similar program and I do sync on an MVar so the main thread does not exit too early. The strange thing is that the program runs faster with -threaded & +RTS -N1 than without -threaded. Is that possible?
07:16:18 <ion> kaidelong: In an obfuscation contest?
07:16:30 <kaidelong> pointfree golfing, I guess
07:16:39 <mniip> golfing?
07:16:45 <mniip> I can do better:
07:16:47 <mniip> (<*>)
07:16:53 <kaidelong> @src ap
07:16:53 <lambdabot> ap = liftM2 id
07:17:02 <kaidelong> @src liftM2
07:17:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:17:02 <f-a> I am writing a small command line program. Syntax will be: program folder -x folder-a -x folder-b (i.e. some options will be repeated). Is there anything in hackage which will allow me to do that? I usually use optparse applicative, but it doesn't support 'repeated' options
07:17:17 <kaidelong> @@ pl src liftM2
07:17:18 <lambdabot>  pl src liftM2
07:17:41 <ion> @@ @pl @undo @src liftM2
07:17:41 <lambdabot>  (line 1, column 64):
07:17:41 <lambdabot> unexpected ';'
07:17:41 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
07:17:50 <f-a> (to give you an example, like when you exclude multiple patterns with tar)
07:17:51 <merijn> bezirg: Is it possible? Sure. Why? Hard to say
07:17:59 <kaidelong> oh I guess we can't pl it without dropping the left side
07:18:10 <merijn> f-a: It does allow repeated
07:18:24 <geekosaur> if it's happening, it's possible :) depending on how things are interacting, it's entirely possible that the threaded interface is faster than the non-threaded one despite more expensive GC (especially if you're not allocating much so GC cost is minimal). would have to see the actual code, and even then might need someone more expert in ghc internals than I
07:18:31 <merijn> f-a: optparse-applicative's type is an instance of alternative, which means you have access to many/some
07:18:34 <merijn> :t many
07:18:36 <lambdabot> Alternative f => f a -> f [a]
07:18:36 <merijn> :t some
07:18:37 <lambdabot> Alternative f => f a -> f [a]
07:18:43 <jdnavarro> is there any tool or straightforward workflow for running  cabal tests with different GHC versions *locally*?
07:19:13 <merijn> jdnavarro: cabal just uses whichever GHC is first in path, so a simple shell script changing paths and rerunning cabal tests should be enough
07:19:31 <geekosaur> hsenv might be slightly easier to script for that workflow though
07:19:53 <merijn> I've mostly found hsenv a bit cumbersome without much value, but YMMV
07:19:57 <jdnavarro> I had in mind something like Python tox
07:20:55 <bezirg> geekosaur: merijn: thanks again
07:21:25 <jdnavarro> alright, I'll try first to compile different versions of GHC and try changing the paths, that might be enough
07:21:43 <jdnavarro> merijn, geekosaur: thanks!
07:22:39 <merijn> jdnavarro: Basically, my workflow is that I have several different GHC versions installed under ~/ghc/version and I just prepend whichever I want to my PATH, since GHC uses a per-version database there's no collisions/environment problems as long as you don't have multiple GHCs of the same version (and then it might still work, I guess?)
07:23:46 <merijn> f-a: btw, let me know if many/some work, I haven't tried and I'm curious whether I'm right
07:24:04 <mpickering> jdnavarro: You can use the -w flag to tell cabal which ghc to use.. ie cabal configure -w ghc-7.8.4 --enable-tests 
07:24:35 <jdnavarro> mpickering: oh, that makes things easier
07:25:10 <mpickering> or you can use with-compiler: ghc-7.8.4 in your cabal.config if it's more permanent
07:27:11 <f-a> merijn: I just tested it now. Not only you have been extremely helpful, not only your responde time was, like, 15 seconds, but you also made me discover something new (never cared much about alternative apart from parsec)
07:27:13 <jdnavarro> mpickering: I guess it can be configured per cabal sandbox, right?
07:27:16 <f-a> hance, thank you merijn !
07:27:35 <mpickering> yes
07:28:33 <merijn> f-a: \o/
07:31:00 * hackagebot shelltestrunner 1.3.5 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.3.5 (SimonMichael)
07:31:02 * hackagebot acid-state 0.12.4 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.12.4 (DavidJohnson)
07:34:56 <_d0t> ohai. The prelude docs say that 'The calls succ maxBound and pred minBound should result in a runtime error.' So, how do I throw this error in my code?
07:35:18 <_d0t> thats regarding enum instances
07:36:52 <merijn> _d0t: 'maxBound MyMax = error "you done goofed!"'
07:36:55 <merijn> Or
07:37:20 <merijn> Just leave it undefined and GHC will produce an error "incomplete pattern" when you call succ maxBound
07:37:32 <merijn> (also, I guess that should've been succ instead of maxBound)
07:38:55 <_d0t> merijn: ghc produces the very specific error in case of standard types
07:39:02 <_d0t> succ (maxBound :: Word32)
07:39:02 <_d0t> *** Exception: Enum.succ{Word32}: tried to take `succ' of maxBound
07:39:04 <_d0t> like this
07:39:17 <_d0t> i'm not sure thats done with a error call
07:42:09 <merijn> Oh sweet jesus, yes! Haddock has source links for instances now!
07:42:22 <merijn> _d0t: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Word.html#line-407
07:42:36 <ion> merijn: Ooh
07:43:23 <_d0t> merijn: yeah, i've found it already myself
07:43:29 <_d0t> succError/predError functions
07:43:47 <_d0t> but thanks
07:51:59 <tromp> :t (^)
07:52:01 <lambdabot> (Integral b, Num a) => a -> b -> a
07:59:27 <montage> :t lookAt
07:59:28 <lambdabot>     Not in scope: ‘lookAt’
07:59:28 <lambdabot>     Perhaps you meant one of these:
07:59:28 <lambdabot>       ‘lookup’ (imported from Data.List),
08:16:29 <sm> merijn: oh nice
08:16:54 <sm> hey does anyone know of a haddock-like for makefiles ?
08:17:14 <sm> aside from converting it all to shake ?
08:18:11 <_d0t> why does enumFromTo call fromEnum?
08:18:17 <_d0t> is there a way to avoid this?
08:21:31 <quchen> Sure, you can implement all of the functions of a typeclass yourself if you want to.
08:21:40 <quchen> The definitions in terms of each other are purely for convenience.
08:23:24 <_d0t> quchen: so, there's no other way, right?
08:23:40 <_d0t> the problem in my case is that the type in question is larger than Int
08:24:31 <quchen> That shouldn't be a problem for enumFrom*.
08:24:42 <_d0t> it is
08:24:48 <quchen> toEnum/fromEnum won't be mutually inverse in that case, but those functions are ugly warts anyway ;-(
08:26:10 <quchen> Why do you think the "larger than int" constraint matters for enumFrom*?
08:26:32 <quchen> Integer is larger than Int, but you can define all those functions for it
08:27:34 <_d0t> quchen: cuz I just found out that the default implementations of enumFrom/enumFromTo/etc actually call fromEnum
08:28:00 <_d0t> I hoped I could avoid implementing all of the methods
08:29:44 <quchen> You can overwrite fromEnum and the others will use your overwritten version.
08:30:40 <_d0t> yeah, thats what I'm doing now :)
08:31:03 <quchen> It's just a very simple implementation for Enum to say "well just take [1..] and map fromEnum over it"
08:31:07 <tromp> i just followed cabal's suggestion to upgrade with cabal install cabal-install, and when i rerun  it still suggests it.  can i clear up this mess by removing ~/.cabal ?
08:31:37 <quchen> The rest of the functions are part of the class (as opposed to being shipped as convenience alongside it) precisely to allow this kind of overwriting
08:31:38 <joshc> tromp: are you running 'cabal' from ~/.cabal/bin?
08:31:39 <merijn> tromp: The problem is that the cabal in your system path is being found instead of the one it just installed
08:32:20 <tromp> which cabal gives ~/Library/Haskell/bin/cabal
08:32:42 <geekosaur> which can lie. try type
08:32:54 <geekosaur> or, hash -r to make the current shell forget what it remembers the path to be
08:33:32 <tromp> oh, that's a symlink to an older version i see
08:33:47 <tromp> let me rm that and point to the newer version
08:33:48 <geekosaur> ...it still does that? :(
08:34:25 * sm finds http://www.cmcrossroads.com/print/article/self-documenting-makefiles , ideal
08:35:02 <tromp> cool; works now!
08:36:04 <_d0t> quchen: as I said, the type in question is much larger than Int
08:36:04 * hackagebot arion 0.1.0.6 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.6 (karun012)
08:36:37 <_d0t> quchen: I'm writing a enum instance for the ipv6 address type, which is 128-bit large
08:36:57 <_d0t> so fromEnum/toEnum methods are virtually useless
08:38:27 <yac> cabal install double-conversion gives me gcc: error trying to exec 'cc1plus': execvp: No such file or directory
08:38:33 <yac> any idea what is that about?
08:40:19 <quchen> _d0t: You could write  IPv6 <-> Integer  functions and then use Integer's Enum, which is probably the simplest solution. Those functions are probably useful for other instances as well, such as serialization.
08:40:52 <_d0t> quchen: yeah, that might work. I'm concerned about the performance though.
08:41:23 <jdnavarro> _d0t: did you have a look at https://hackage.haskell.org/package/largeword
08:41:38 <_d0t> jdnavarro: nope. Thx.
08:41:45 <merijn> _d0t: I'm not convinced an Enum instance for IP addresses is such a great idea >.>
08:42:04 <_d0t> merijn: it is when you work with ip ranges/subnets
08:42:06 <quchen> merijn: traverse portscan [::1 ..]
08:42:07 <quchen>  :-)
08:42:11 <ion> :-)
08:43:00 <quchen> The problem with an Enum for IPs is that "IP ranges" are rarely what the Enum implementation gives you
08:43:20 <quchen> 192.168.*.1 wouldn't be expressible in your scheme, for example.
08:43:26 <merijn> I'd prefer an IP range/subnet ADT
08:43:30 <S11001001> yac: what do you get when you 'which g++'
08:43:37 <_d0t> quchen: 192.168.*.1 is not a valid ip subnet
08:43:47 <quchen> But it's a valid IP range.
08:43:53 <merijn> That seems more useful than Enum
08:44:35 <quchen> I don't know much about networking, but if you have ffff00ff as a subnet mask that IP range might even work.
08:44:50 <_d0t> quchen: thats not a valid mask :)
08:45:01 <quchen> Okay.
08:48:13 <aidecoe> what's wrong with this? fmap (mapM_ putStrLn) (Just ["abc", "def"])
08:48:44 <quchen> Nothing.
08:48:44 <aidecoe> ah, right
08:48:52 <quchen> It's well-typed.
08:49:10 <capisce> maybe it's not the type you want
08:49:27 <aidecoe> indeed, it ends up being Maybe IO ()
08:49:37 <ion> Perhaps you want (traverse . traverse) putStrLn (Just ["abc", "def"])
08:49:57 <ion> (traverse_ . traverse_)
08:50:07 <joe9> anyone ugraded to 7.10.1. Did it break a lot of packages?
08:50:33 <merijn> :t traverse (mapM_ putStrLn) (Just ["abc", "def"])
08:50:34 <Fuuzetsu> it made some packages not compile while others are fine
08:50:35 <lambdabot> IO (Maybe ())
08:50:45 <merijn> Well, that's not a very useful type, I guess :p
08:50:52 <quchen> joeI installed alongside 7.8, but I didn't have many problems with the new version so far.
08:51:13 <merijn> aidecoe: Probably you want
08:51:25 <merijn> :t maybe (return ()) (mapM_ putStrLn)
08:51:26 <lambdabot> Foldable t => Maybe (t String) -> IO ()
08:51:42 <merijn> :t maybe (return ()) (mapM_ putStrLn) $ Just ["abc", "def"]
08:51:44 <lambdabot> IO ()
08:52:02 <ion> :t (traverse_ . traverse_) putStrLn (Just ["abc", "def"])
08:52:03 <lambdabot>     Not in scope: ‘traverse_’
08:52:03 <lambdabot>     Perhaps you meant one of these:
08:52:03 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
08:52:10 <ion> :t (F.traverse_ . F.traverse_) putStrLn (Just ["abc", "def"])
08:52:11 <lambdabot> IO ()
08:52:28 <aidecoe> cool, thanks :-)
08:52:32 <benzrf> how do i make this use constant space please http://lpaste.net/129862
08:54:05 <geekosaur> yac: your system's package manager doesn't install the C++ driver when it installs gcc. check your package manager
08:54:25 <benzrf> ach nvm :?
08:55:27 <athan> Hi everybodys, is there a good rose-tree library amongst the fog?
08:56:05 <johnw> Data.Tree isn't good for you?
08:56:48 <athan> johnw: No :\ there's a lot of stuff missing from it
08:57:12 <athan> I could really use tagged rose-trees, for instance
08:57:16 <athan> something like a trie
08:57:28 <athan> where I could merge two trees together, respecting the tags
08:57:49 * athan gets the elbow grease
08:59:00 <athan> I have a feeling I will need to make a lot of this code generic :\
09:04:56 <athan> I'm going to make the rose-tree's `cons` operator `:@->`. Any objections?
09:08:39 <athan> Is there a reccomended way to organize typeclass instances vs. typeclass declarations in Haskell's module system?
09:08:57 <athan> I've heard the word "orphan" a few times
09:10:10 <merijn> athan: An orphan is an instance that is not either 1) in the same module as the datatype or 2) the same module as the class
09:10:27 <tdammers> the recommendation is to write the instance in either the module where the typeclass is defined, or the module where the type is defined
09:10:44 <merijn> athan: The language does not allow multiple instances for the same class if an instance is not an orphan it's guaranteed to not collide
09:10:53 <athan> ahh okay :)
09:11:20 <athan> So basically, I've got to pollute my namespace :\
09:11:52 <merijn> athan: Because either the data depends on the class library or the class library on the data. Whereas if you define them in separate modules people could conceivably make their own instances thinking it doesn't exist and then when you use two libraries doing that together, hell breaks loose
09:11:52 <phadej> you can always import qualified
09:12:03 <merijn> athan: Why do you have to pollute it?
09:13:55 <athan> phadej: Yeah, that's my plan
09:14:02 <Luke> guys did 7.10 include the FTP stuff?
09:14:10 <Luke> and AMP
09:14:19 <Luke> i never heard what the final decision was
09:14:21 <ion> yes
09:14:24 <Luke> on both?
09:14:37 <ion> yes
09:14:46 <Luke> so when I upgrade to 7.10 the types of prelude list functions change?
09:14:49 <Luke> cool thanks ion 
09:14:52 <athan> merijn: Well, my other idea was something like module A re-exports A.Instances and A.Class or something, then hide those two from hackage
09:15:06 <athan> s/hackage/global exports
09:15:21 <joneshf-laptop> is there a known relationship between `Extend` and `Applicative`? http://hackage.haskell.org/package/semigroupoids-4.3/docs/Data-Functor-Extend.html
09:15:31 <joneshf-laptop> is `Applicative` a superclass of `Extend`?
09:15:54 <joneshf-laptop> because it seems like you can derive `Extend` from `Applicative`
09:16:30 <joneshf-laptop> e.g.: `extended f x = pure (f x)`
09:17:01 <ion> That’s not the same type.
09:17:28 <athan> joneshf-laptop: That feels more like a sub-comonad to me
09:17:47 <joneshf-laptop> ion, it's not?
09:17:59 <yac> S11001001: nothing
09:18:00 <joneshf-laptop> athan, sub-comonad?
09:18:14 <ion> extended :: (w a -> b) -> w a -> w b
09:18:16 <athan> :i Control.Comonad
09:18:18 <ion> @type \f x -> pure (f x)
09:18:19 <lambdabot> Applicative f => (r -> a) -> r -> f a
09:18:33 <joneshf-laptop> ion, what's different?
09:18:38 <yac> ok, I needed gcc-c++
09:18:40 <yac> thanks
09:18:43 <athan> I honestly am shooting in the dark here, but it feels more monadic than applicative
09:19:02 <athan> joneshf-laptop: I'm definitely going to look into this though
09:19:41 <S11001001> yac: :)
09:19:53 <athan> I saw a proposal on reddit for making semigroup a superclass for monoid... this might be an outlandish request, but what about "Empty" being a superclass as well?
09:20:34 <athan> I know that `mempty` is basically defined by it's identity property over (<>), but it would sure be useful to have an explicit empty element, without regard to the operation
09:20:37 <athan> (I think)
09:20:43 <merijn> athan: It's called Pointed and people hate it because there's no laws for it
09:20:45 <athan> (until we can overload typeclasses :|)
09:20:56 <merijn> athan: So you can usefully reason about Pointed instances
09:21:08 <merijn> Whereas Semigroup at least has associativity...
09:21:09 <athan> merijn: I shall share the spite :D thanks merijn
09:21:13 <merijn> Anyway time to go home
09:21:25 <athan> I'm guessing there are a ton of newtypes?
09:21:29 <athan> sorry :(
09:22:09 <mpickering> well they say the same about Foldable
09:22:12 <mpickering> and now that's in base 
09:26:54 <athan> mpickering: Shoot, do you know of a *-kinded Pointed class?
09:27:15 <athan> the one in categories-extra is for Functors :(
09:27:49 <quchen> Data.Default?
09:28:03 <quchen> :t def
09:28:04 <lambdabot> Default a => a
09:28:20 <johnw>  if aynone is interesting in joining an ML discussion on the future of the GHC linker, please let me know
09:28:21 <athan> !
09:28:35 <quchen> > (def :: Int, def :: (), def :: (Integer, Product Int))
09:28:37 <lambdabot>  (0,(),(0,Product {getProduct = 1}))
09:29:16 <seanhess> I'm trying to install the "scalpel" package, and getting a compile error. It depends on "download-curl", which depends on "tag-soup < 0.13". The error is fixed in tag-soup 0.13.3. Is there a way to force cabal to use tag-soup 0.13.3 anyway? 
09:29:18 <athan> quchen: That's a great idea :) I don't know if you were following, but the instance is for a tagged rose-tree
09:29:37 <athan> Do you think Default would be suitable for the "root" node?
09:30:00 <quchen> athan: I did not follow the discussion, no.
09:30:05 <athan> seanhess: Sometimes you have to edit the .cabal file and cross your fingers :\
09:30:22 <athan> quchen: Okay, I'll paste some stuff one sec
09:30:36 <davean> seanhess: you can --allow-newer and add a constraint
09:30:41 <quchen> athan: But "tagged" sounds like you want Data.Tagged and not some default helpers.
09:30:48 <athan> :O!
09:31:07 * hackagebot persistent-redis 0.3.2 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.3.2 (PavelRyzhov)
09:31:24 <athan> quchen: Oh, no not quite
09:31:29 <quchen> Tagged tag a = (Proxy tag, a)
09:31:32 <athan> The tags will be used in runtime queries
09:31:42 <athan> well...
09:31:45 <athan> :S
09:31:53 <athan> I don't want too much type-level tomfoolary haha
09:31:54 <seanhess> athan: edit download-curl's cabal file? How would I do that? 
09:32:12 <davean> seanhess: You should be able to just do it with --allow-newer and --constraint
09:32:18 <davean> seanhess: on the cabal install line
09:32:28 <athan> ^ do that instead haha
09:32:31 <davean> --allow-newer[=DEPS]            Ignore upper bounds in all dependencies or DEPS
09:32:44 <seanhess> davean: yes that worked!
09:32:57 <seanhess> Ok, so now how would I go about fixing download-curl? It's not on github
09:32:59 <davean> seanhess: https://github.com/haskell-infra/hackage-trustees/issues
09:33:04 <davean> seanhess: file a bug
09:33:22 <seanhess> ty!
09:33:29 <davean> The trustees can adjust it, after a waiting period (full disclosure, I'm a Trustee)
09:34:28 <davean> base (>=3 && <6), <--- WTF?
09:34:29 <ion> joneshf-laptop: Sorry, never mind. That does typecheck and even satisfy the laws, but the instances wouldn’t be as useful in general. Think of the difference in behavior in [] and Either l, for instance.
09:35:01 <quchen> athan: If you need types that you can convert to values you might want to have a look at GHC.TypeLits as well
09:36:33 <quchen> :k Proxy "hello athan"
09:36:35 <lambdabot> *
09:36:42 <quchen> :k "hello world"
09:36:43 <lambdabot> GHC.TypeLits.Symbol
09:38:18 <quchen> symbolVal (Proxy :: Proxy "hello athan") = "hello athan" -- needs DataKinds
09:38:50 <athan> ^ do that instead haha
09:38:51 <athan> whoop
09:39:14 <athan> quchen: One second, let me give you a feel for what I'm trying to accomplish
09:39:22 <athan> I think I should stick to runtime values for now
09:42:43 <athan> Is there a way to make associated types reference type variables on the RHS?
09:44:40 <athan> Or make polymorphic typeclass instances?
09:45:30 <joneshf-laptop> ion, Ah, yes, that is interesting
09:46:08 * hackagebot Win32-errors 0.2.2.1 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2.2.1 (MichaelSteele)
09:46:10 * hackagebot data-fix-cse 0.0.2 - Common subexpression elimination for the fixploint types.  http://hackage.haskell.org/package/data-fix-cse-0.0.2 (AntonKholomiov)
09:46:12 * hackagebot csound-expression-dynamic 0.1.1 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.1 (AntonKholomiov)
09:46:42 <ion> >fixploint types
09:47:08 <Fuuzetsu> maybe they explode if you fix them
09:47:09 <Luke> Can anyone see how to implement this function: http://lpaste.net/129877
09:47:21 <quchen>  :k Fix Error
09:48:32 <quchen> Type error. Expected Type error. Expected Type error. …
09:49:45 <athan> lol
09:50:39 <Fuuzetsu> next berserk fucking never
09:50:44 <Fuuzetsu> oops, wrong buffer :)
09:50:47 <athan> Is there any way I can bind the `a` inferred by the instance declaration, and the (same) `a` in my class function?
09:50:48 <athan> http://lpaste.net/129878
09:51:08 * hackagebot csound-expression-typed 0.0.7.0 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.0 (AntonKholomiov)
09:51:44 <athan> Or would I have to make normal rose trees a list of Identities? :S
09:53:09 <mpickering> which bit doesn't compile?
09:53:42 <athan> mpickering: Both instances :(
09:55:46 <mpickering> I think you've got things set up a big wrong
09:56:26 <athan> mpickering: Here's something that works, but is definitely not the end-goal I'd want: http://lpaste.net/129879
09:56:48 <athan> Basically, now every node in the tree would need a newtype wrapper ><
09:56:57 <athan> (when constructing them with my syntax)
09:57:19 <Luke> Can anyone see how to implement this function?: http://lpaste.net/129877 -- bump
09:57:52 <mpickering> I don't really understand what you're trying to do so it might help to explain that
09:58:34 <athan> :P
09:59:06 <athan> Luke: stateToReaderT (stateToReaderT x)?
09:59:40 <athan> actually
09:59:44 <Luke> i thought i tried that =)
10:00:02 <athan> Luke: stateToReaderT . lift stateToReaderT
10:05:48 <Luke> athan: trying - thanks
10:06:09 <athan> Luke: No problem :)
10:06:12 <athan> :t lift
10:06:13 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:07:34 <Luke> athan: the real code is actually more complex than this and I'd tried the equivalent of what you suggested before so I'm trying to reconcile what's going on
10:08:02 <Luke> athan: yeah it doesn't work even with the test code
10:08:06 * athan shrugs
10:08:09 <athan> :(
10:09:06 <Luke> athan: weird right?
10:09:25 <athan> Luke: Can you paste some code for me? :\
10:09:35 <Luke> yeah
10:10:11 <Luke> athan: http://lpaste.net/129882 this is what you're suggesting right?
10:10:31 <Luke> athan: this is in fact exactly what I thought it'd be too
10:10:39 <Luke> maybe I'm doing something else wrong to get the compilation errors
10:10:59 <athan> What are the errors?
10:11:04 <athan> type varaible matching?
10:11:13 <Luke> i updated the paste with the errors
10:16:10 * hackagebot csound-expression 4.4 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.4 (AntonKholomiov)
10:17:56 <Luke> athan: any other ideas?
10:18:38 <athan> oop, sorry 10 things at once, one sec
10:19:09 <hexagoxel> Luke: is it important to use stateToReaderT for runMyReaderTStack?
10:19:27 <Luke> hexagoxel: no but i'm trying to kinda come up with some abstractions here
10:19:32 <Luke> but it's not necessary
10:20:03 <Luke> I was even trying some do notation stuff to see if I could get it working and couldn't figure it out
10:20:47 <hexagoxel> Luke: annotated
10:21:10 * hackagebot csound-sampler 0.0.4.0 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.4.0 (AntonKholomiov)
10:21:12 <athan> oh woah, stateToReaderT's type changed
10:21:13 <Luke> hexagoxel: yeah I think that might be the only way right?
10:22:29 <athan> Luke: Also, have you thought about using RWS?
10:22:48 <Luke> athan: I don't have separate state for the read only part
10:22:59 <athan> :S
10:23:03 <Luke> it's the same state I just have some code that I want to statically enforce is read-only and other code that's doing the state update
10:23:23 <athan> Luke: I think `stateToReaderT` actually just pulls the readerT's monad to the front
10:23:33 <athan> basically a co-lift or something
10:23:47 <Luke> not sure I follow
10:24:00 <athan> Look at it's type
10:24:17 <athan> You're just pulling the inner monad out
10:24:33 <hexagoxel> @pl get >>= (\x -> lift $ get >>= lift . runReaderT (runReaderT k x))
10:24:33 <lambdabot> lift . (get >>=) . (lift .) . runReaderT . runReaderT k =<< get
10:24:53 <athan> Now, with `runMyReaderStack`, you're just taking the outer reader index as the first state to your new StateT
10:25:34 <athan> So, I suggest you pull your inner monad with `stateToReaderT`, then make a _new_ StateT with the outer ReaderT's index as the initial state
10:26:19 <benzrf> tfw i write a 19-line monstrosity of a function
10:26:40 <Fuuzetsu> use a where, now it's two monsters!
10:26:59 <benzrf> Fuuzetsu: it's a do-block and at least half the lines are in a let
10:27:02 <benzrf> a single let
10:27:07 <benzrf> rip
10:27:07 <Luke> athan: hmm
10:27:18 <benzrf> this is your code on monad stacks
10:27:23 <Luke> hexagoxel: haha I like your `do` version better. easier to see what's going on
10:27:25 <Fuuzetsu> not even once
10:29:04 <hexagoxel> Luke: now additionally pointfree the \k -> ... :D
10:29:16 <Luke> ha yeah... crazy
10:36:56 <hexagoxel> Luke: but there are shorter solutions if `stateToReaderT` had the type that the name suggests
10:37:17 <Luke> what do you mean?
10:37:22 <hexagoxel> (athan mentioned the same thing)
10:37:38 <Luke> do you have a code example?
10:37:53 <athan> Luke: I really think you should reduce the stack
10:38:07 <athan> transformers can litter `lift` everywhere, unobviously :\
10:38:33 <Luke> athan: these StateTs are coming from 2 separate pieces of code. it would not make sense to merge them
10:38:53 <Luke> or you mean putting them into one ReaderT instead of 2?
10:40:39 <NemesisD> stm retries aren't busy loops right? like if i do atomically $ check =<< readTVar someBoolTVar, it will suspend until something touches someBoolTVar right?
10:41:00 <hexagoxel> Luke: let me say it this way: `ReaderT s (StateT s m) a -> StateT s m a` looks like stateToReaderState
10:41:04 <EvanR> NemesisD: yes
10:41:33 <Luke> hexagoxel: i still don't follow
10:41:42 <EvanR> NemesisD: or an error occurs because ghc determines nothing will ever touch the var
10:41:49 <Luke> hexagoxel: the way you put that it's just lift
10:41:53 <NemesisD> EvanR: gotcha. thanks
10:42:36 <hexagoxel> Luke: but that _is_ the signature of your stateToReaderT
10:43:03 <Luke> hexagoxel: yes but it doesn't capture the fact that the state is the same in both the reader and stateT
10:43:40 <hexagoxel> Luke: `stateToReaderT :: Monad m => ReaderT s m a -> StateT s m a`
10:44:35 <Luke> yeah... and?
10:45:18 <hexagoxel> using that, the rhs of runMyReaderTStack is just four identifiers/operators
10:46:03 <Luke> there was a reason I did that
10:46:05 <Luke> i was getting type errors the other way
10:46:11 * hackagebot MonadRandom 0.3.0.2 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.3.0.2 (BrentYorgey)
10:46:13 * hackagebot snap-cors 1.2.7 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.7 (OliverCharles)
10:46:41 <hexagoxel> Luke: you need mapReaderT or mapStateT in runMyReaderTStack
10:47:05 <Luke> hexagoxel: are you giving me hints on how to write it that way?
10:47:13 <hexagoxel> yes
10:47:14 <Luke> ah
10:48:01 <Luke> the problem is I'm not actually writing it like this. I want opaque types for the StateTs and ReaderTs so you don't know that's what they are and then still write this code
10:48:13 <Luke> but then I was getting concrete type errors on the m (which is why I expanded it out)
10:48:22 <Luke> maybe I should write it more generically like this though... not sure
10:49:08 <Luke> hexagoxel: actually even in this simple case I get concrete type errors when I do as you suggest
10:49:43 <Luke> the ReaderT m needs to be bound to the StateT type to enforce it's threaded through the readerT run
10:50:21 <Luke> hexagoxel: try what you're suggesting. you get something like this: "Could not deduce (m ~ StateT s m)"
10:50:52 <EvanR> could not deduce (m ~ StateT s m) (same m) means you got something mixed up
10:51:44 <Luke> EvanR: errors mean something is mixed up ;-)
10:51:50 <EvanR> youre trying to use an m as the stateT and the thing stateT is wrapping as the same thing somewhere
10:52:00 <EvanR> and they cant be
10:52:04 <athan> Is there something like a `findMaybe :: (a -> Bool) -> [a] -> Maybe a`, which (possibly) returns the first element in the list satisfying the predicate?
10:52:05 <EvanR> it would be an infinite type
10:52:08 <athan> it's like the element-wise analogue of takeWhile
10:52:21 <EvanR> :t find
10:52:22 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
10:52:30 <EvanR> :t Data.List.find
10:52:32 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
10:52:35 <EvanR> whoa
10:52:38 <Luke> haha
10:52:40 <Luke> FTP
10:52:51 <Luke> welcome to the future
10:53:21 * EvanR puts on google glasses
10:53:42 <Luke> EvanR: lambdabot is upgraded to 7.10
10:53:55 <athan> EvanR: :O!
10:53:56 <ion> yay
10:53:59 <athan> thank you!
10:54:03 <quchen> Why would Data.List.find work on Foldable?
10:54:20 <EvanR> List operations were generalized as part of some proposal
10:54:21 <Luke> quchen: good point
10:54:30 <ion> quchen: To avoid breakin gcode that imports Data.List and Prelude simultaneously.
10:54:37 <quchen> Ah.
10:55:03 <EvanR> i love the smell of burning bridges in the morning
10:55:37 <Luke> i want to upgrade my code to 7.10 but its' totally not worth my time right now
10:57:40 <quchen> You should make it compatible at least.
10:59:43 <arkeet> we should (Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
11:00:17 <arkeet> and call it filter
11:00:42 <EvanR> hows that filter
11:01:01 <arkeet> :t foldr (<|>) empty
11:01:02 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
11:01:05 <arkeet> er
11:01:12 * hackagebot memoize 0.7 - A memoization library  http://hackage.haskell.org/package/memoize-0.7 (JesseTov)
11:01:19 <EvanR> filter seems to imply you get back the same type you put in
11:02:07 <arkeet> :t \p -> foldr (\x -> if p x then (<|>) x else id) empty
11:02:08 <lambdabot> (Foldable t, Alternative f) => (f a -> Bool) -> t (f a) -> f a
11:02:14 <arkeet> still wrong haha. I'll stop.
11:02:26 <joneshf-laptop> arkeet, you need `MonadPlus`
11:02:32 <arkeet> Alternative is enough.
11:02:37 <joneshf-laptop> oh?
11:02:41 <arkeet> it's MonadPlus without Monad.
11:03:03 <arkeet> EvanR: it generalizes filter for lists.
11:03:13 <ion> :t \p -> foldr (\x -> if p x then (<|>) pure x else id) empty
11:03:14 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f a
11:03:14 <lambdabot>     Expected type: f a -> f a
11:03:14 <lambdabot>       Actual type: a -> f a
11:03:20 <EvanR> arkeet: but, how does it specialize to filter for lists in any way
11:03:29 <EvanR> if you wanted it to
11:03:29 <ion> :t \p -> foldr (\x -> if p x then (<|>) (pure x) else id) empty
11:03:30 <lambdabot> (Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
11:03:40 <arkeet> > (\p -> foldr (\x -> if p x then (<|>) (pure x) else id) empty) even [1..5]
11:03:41 <lambdabot>      No instance for (Show (f0 a0))
11:03:41 <lambdabot>        arising from a use of ‘show_M15769280436890992374857’
11:03:41 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
11:03:46 <arkeet> > (\p -> foldr (\x -> if p x then (<|>) (pure x) else id) empty) even [1..5] :: [Int]
11:03:47 <lambdabot>  [2,4]
11:03:56 <arkeet> EvanR: put t and f = []
11:04:05 <Zemyla> :t \f -> (>>= (\a -> guard (f a) >> return a))
11:04:06 <lambdabot> (Monad m, Alternative m) => (b -> Bool) -> m b -> m b
11:04:16 <arkeet> ooh.
11:04:18 <arkeet> :t guard
11:04:18 <lambdabot> Alternative f => Bool -> f ()
11:04:20 <arkeet> nice.
11:04:31 <joneshf-laptop> which is basically `MonadPlus`
11:04:39 <Zemyla> Wait, shouldb't it be MonadPlus?
11:04:47 <arkeet> (I mean nice that it only needs Alternative now, instead of MonadPlus.)
11:04:56 <EvanR> arkeet: alright, so how does this work for anything /but/ lists
11:05:03 <arkeet> > (\p -> foldr (\x -> if p x then (<|>) (pure x) else id) empty) even [1..5] :: Maybe Int
11:05:05 <lambdabot>  Just 2
11:05:07 <ion> :t \f -> (>>= (\a -> a <$ guard (f a)) :: MonadPlus m => (a -> Bool) -> m a -> m a
11:05:08 <lambdabot> parse error on input ‘::’
11:05:13 <arkeet> it simultaneously generalizes filter and find.
11:05:15 <quchen> ?src Monad
11:05:15 <lambdabot> class  Monad m  where
11:05:15 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
11:05:15 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
11:05:15 <lambdabot>     return :: a -> m a
11:05:15 <lambdabot>     fail   :: String -> m a
11:05:18 <ion> :t \f -> (>>= (\a -> a <$ guard (f a))) :: MonadPlus m => (a -> Bool) -> m a -> m a
11:05:20 <lambdabot>     Couldn't match type ‘Bool’ with ‘m1 a1’
11:05:20 <lambdabot>     Expected type: (a1 -> Bool) -> m1 a1 -> m1 a1
11:05:21 <lambdabot>       Actual type: (a1 -> Bool) -> a1 -> Bool
11:05:30 <quchen> ^ int-e, we need Applicative => in there :-D
11:05:53 <EvanR> arkeet: i see you can do a find with it, but as far as filtering goes seems to only make sense for lists
11:06:08 <tulcod> iross_: are you ian ross of c2hs?
11:06:09 <ion> Whoops, :: went inside the lambda
11:06:19 <arkeet> EvanR: you can filter any foldable into a list.
11:06:24 <EvanR> right
11:06:34 <ij> Is lambdabot allowed to write more msgs/s by freenode? It seems so.
11:06:37 <EvanR> back to lists with ye ;)
11:06:46 <Zemyla> Well, are there any MonadPlusses that are neither some form of list nor some form of Maybe?
11:06:46 <arkeet> :)
11:06:47 <ion> :t (\f -> (>>= (\a -> a <$ guard (f a)))) :: MonadPlus m => (a -> Bool) -> m a -> m a
11:06:49 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
11:06:53 <arkeet> Zemyla: lots!
11:06:59 <arkeet> Parsec for example
11:07:11 <Zemyla> Oh, right.
11:07:56 <joneshf-laptop>  > (\p m -> m >>= (\x -> if p x then return x else empty)) even (Just 3) -- EvanR 
11:07:59 <joneshf-laptop> > (\p m -> m >>= (\x -> if p x then return x else empty)) even (Just 3) -- EvanR 
11:08:00 <lambdabot>  Nothing
11:08:03 <joneshf-laptop> > (\p m -> m >>= (\x -> if p x then return x else empty)) even (Just 4) -- EvanR 
11:08:04 <lambdabot>  Just 4
11:08:18 <EvanR> joneshf-laptop: nice. find. ;)
11:08:25 <joneshf-laptop> EvanR, yeah :)
11:08:31 <arkeet> find for Maybe.
11:08:47 <EvanR> still waiting to be impressed
11:08:56 <arkeet> if I wanted find for Maybe I'd use id.
11:09:06 <arkeet> well, guard.
11:09:24 <ion> > mfilter even (Just 4)
11:09:26 <lambdabot>  Just 4
11:09:31 <arkeet> :t mfilter
11:09:32 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
11:09:33 <arkeet> oh.
11:09:57 <athan> is there a concatFmap, something like join . fmap?
11:10:07 <arkeet> (=<<)?
11:10:24 * athan 's brain fizzes
11:10:27 <athan> thanks arkeet :)
11:10:32 <EvanR> thats a monad law
11:11:13 * hackagebot vector-buffer 0.4.1 - A buffer compatible with Data.Vector.*  http://hackage.haskell.org/package/vector-buffer-0.4.1 (VivianMcPhail)
11:11:16 <athan> I'm ashamed
11:11:35 <arkeet> well, (>>=) I guess.
11:11:42 <arkeet> or not.
11:12:18 <EvanR> :t join . fmap
11:12:19 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
11:12:19 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
11:12:19 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
11:12:21 <EvanR> heh
11:12:32 <arkeet> :t (join .) . fmap
11:12:34 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
11:12:44 <iross_> tulcod: I am.
11:12:49 <EvanR> :t join . fmap f
11:12:50 <c_wraith> Hmm.  I'm using fix to create labeled jump points...  Yay spaghetti code!
11:12:50 <lambdabot> (Monad m, Show a1, FromExpr (m a)) => m a1 -> m a
11:13:03 <arkeet> :t (.)(.)(.)(.)(.)(.)
11:13:04 <lambdabot> (b -> b1 -> c) -> (a -> b) -> a -> (a1 -> b1) -> a1 -> c
11:13:08 <arkeet> :t (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
11:13:09 <lambdabot> (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
11:13:13 <tulcod> iross_: thanks a LOT for your work. just saw your blog post. i'm doing quite a bit of C library binding work, so this is much appreciated!
11:13:46 <arkeet> c_wraith: I love spaghetti!
11:13:48 <iross_> tulcod: No sweat.  I'm interested to hear from people using C2HS to have some idea of what to do next with it...
11:14:32 <tulcod> iross_: well one major thing i would very much like is if you could use c2hs with template haskell. but that's a crazy.
11:15:11 <iross_> tulcod: Urgh.  That's horrible!
11:15:14 <arkeet> using TH to generate c2hs code
11:15:15 <arkeet> ?
11:15:23 <tulcod> yeah, something like that
11:15:53 <iross_> Anyway, that's probably more a Cabal thing than something I could do within C2HS.  (That's my excuse anyway...)
11:15:54 <tulcod> iross_: well my use case is actually quite sensible. but it would probably be the only usecase :P
11:16:25 <tulcod> iross_: okay, let's ask for something less horrible. can you expose some more c2hs internals (whenever that makes sense)?
11:16:43 <iross_> Might be possible to expose the C2HS AST to build C2HS code programatically.
11:18:06 <tulcod> (also, you have to realize that haskell bindings to C libraries are at least as ugly as the C bindings themselves. so from that perspective, a c2hs TH interface is not such a weird idea)
11:18:12 <tulcod> iross_: yeah, that could be useful
11:18:27 <iross_> Agreed.  I usually write low-level bindings and a Haskelly layer on top.
11:19:36 <tulcod> iross_: well in my case it's kinda cumbersome because i'm interfacing with low-level GUI stuff, where a lot of APIs are actually generated. so right now i'm doing part of the bindings with c2hs, and the remainder with TH generating bare FFI statements and binding code
11:20:12 <tulcod> (it's sufficiently complicated now that it makes me go "hmm, okay, this works, but surely generating haskell code would at least be more readable")
11:20:40 <iross_> So you'd like something that gives you access to the C AST representation of your header files and gives you some sort of API to pull definitions out and generate bindings from that?
11:21:14 * hackagebot Win32-junction-point 0.2.1.1 - Support for manipulating NTFS junction points.  http://hackage.haskell.org/package/Win32-junction-point-0.2.1.1 (MichaelSteele)
11:21:38 <tulcod> iross_: well in my particular use case, i'm getting the actual API from an XML file (believe me, this is not the worst part). and also, reading C headers is a solved problem in some sense (ie you can do it in different ways as well)
11:22:06 <tulcod> iross_: it's the "generating reasonable binding code" part that's a bit ugly right now
11:22:15 <tulcod> ie generating the higher level bindings
11:22:41 <iross_> Back in a mo...
11:31:14 * hackagebot filtrable 0.1.0.2 - Class of filtrable containers  http://hackage.haskell.org/package/filtrable-0.1.0.2 (MatthewFarkasDyck)
11:31:29 <timothyh> hmm. I know about C finalizers for ForeignPtr, but what is meant by a "Haskell finalizer"? (in the context of WeakPtr)
11:32:46 <timothyh> i suppose if we had a weak reference to an MVar or something we could putMVar or throw an exception or somesuch in the finalizer
11:33:33 <timothyh> ... but is (\_ -> return ()) an acceptable finalizer?
11:38:59 <quchen> timothyh: A finalizer for Weak is simply an IO action.
11:39:10 <quchen> But yes, `return ()` is the NOOP finalizer.
11:39:31 <timothyh> yeah. what kind of work might be done in such a finalizer?
11:40:27 <quchen> It allows you to react on garbage collection (or at least not run a finalizer before something is GC'd). In the spirit of ForeignPtr, one finalizer might be something that frees memory when GHC has no need for it anymore.
11:41:01 <quchen> Pipes.Concurrent used to use (and maybe still does use?) a finalizer to seal a concurrent channel when some other thing is GC'd
11:41:50 <timothyh> ah, that helps.
11:42:05 <meoblast001> in haskell is there a way to store [Bool] as a series of bits?
11:42:09 <quchen> The System.Mem.Weak introduction mentions another use case, namely caches
11:42:20 <augur_> if anyone's looking for a job hacking haskell in the bay area >> http://www.wagonhq.com/jobs/backend-engineer
11:42:30 <EvanR> meoblast001: group by 8 and encode each group as a Word8
11:42:33 <timothyh> for an ordinary pure value we won't need to do any work, but if it contains references to foreign memory we might need to hand off to another finalizer, and there might also be some desired reaction on GC
11:42:42 <timothyh> that sound ok?
11:42:42 <benzrf> is there a way to derive Read and Show instances for a GADT that's non ADT but only because it tags types
11:42:50 <benzrf> no existentials
11:42:55 <benzrf> no matches
11:42:57 <benzrf> just phantoms
11:43:28 <meoblast001> EvanR: hm.. that could do it.. if i have a function [Word8] -> [Bool], laziness should keep my memory usage pretty low, right?
11:43:36 <quchen> timothyh: Something along those lines, yes. I haven't used it much so this is pretty much all I have to say.
11:43:48 <timothyh> :) thanks for your time quchen 
11:44:22 <iross_> tulcod: Do you have a repo somewhere I could look at with this GUI + C2HS stuff?  Just to get some idea of what exactly it is you're doing?
11:44:35 <JordiGH> We don't have source code for RWH, do we?
11:45:56 <Welkin> JordiGH: it is in the book
11:46:02 <tulcod> iross_: https://github.com/tulcod/haskell-wayland https://github.com/tulcod/haskell-xkbcommon
11:46:25 <iross_> Oh lordy.  Wayland?  All of it?  That's going to be fun!
11:46:28 <tulcod> iross_: (the xkbcommon curretnly uses hsc2hs though, so not really a great examlpe)
11:46:58 <tulcod> iross_: it's been out for a while; haven't had a lot of response yet. everyone i mention it to says "hmm yeah cool!" and then nothing happens
11:47:12 <benzrf> ah nvm i dont need Read
11:47:19 <JordiGH> Welkin: No, no the docbook XML source. We don't have it, do we?
11:47:33 <EvanR> meoblast001: when doing what
11:48:04 <meoblast001> EvanR: when i start looking at these bits as Bool, i don't want the entire bitmap to be converted into Bool
11:48:12 <meoblast001> only the bits i'm interested in
11:48:21 <EvanR> well, what does looking at mean?
11:48:30 <meoblast001> using
11:48:37 <nitrix> Hi, do you guys prefer `a . b $ c`, `a (b c)` or `a $ b c` ?
11:48:49 <nitrix> What if I'm already inside parenthesis?
11:48:50 <tulcod> nitrix: yes.
11:48:58 <EvanR> meoblast001: if you consume a list and only operate on one element at a time, then it will work
11:49:00 <meoblast001> like if i (excuse my use of !! for example), do (bitmapToBool mybitmap) !! 15. i want it to at most consider one byte
11:49:27 <EvanR> exactly one use of !! 15 would be fine
11:49:38 <nitrix> tulcod: It's not a Yes/No question.
11:49:40 <EvanR> but im guessing you are not doing that
11:49:50 <tulcod> nitrix: there is no yes/no answer
11:50:00 <tulcod> nitrix: like, there is no "you should use this one, always"
11:50:24 <tulcod> different people prefer different styles. use what makes sense, but preferably be consistent.
11:50:41 <EvanR> meoblast001: ... hold on phonw
11:50:43 <nitrix> tulcod: I think I'm well aware of that; I was more expecting arguments in favor of one or the other style given some context.
11:51:47 <nitrix> Hlint seems to suggest replacements for `a $ b c` into `a (b c)`
11:52:07 <meoblast001> EvanR: hm?
11:52:22 <tulcod> nitrix: the ones you're expecting: in `a . b $ c`, a and b are sort of at equal footing. in `a $ b c`, it's sort of like you're applying the a operator to the `b c` argument, but it saves a few characters.
11:52:50 <tulcod> nitrix: `a (b c)` is the mathematical notation, which may or may not be relevant
11:53:02 <quchen> My advice is to not avoid parentheses at all cost. Parentheses are fairly common, reading `a . b $ c` takes more practice to read.
11:53:14 <quchen> () pair fairly well, there's good editor support.
11:53:18 <nitrix> tulcod: So it should be based on wether or not it makes sense to apply a composed function to a value?
11:53:22 <quchen> . and $ rarely work well if you ask me.
11:53:48 <nitrix> tulcod: Makes sense.
11:53:49 <quchen> (And when you're going lisp-wild you should consider splitting up your definitions.))))))))))))
11:53:50 <tulcod> nitrix: well i don't dare to say "yes" here, but this is definitely something you should take into consideration
11:54:09 * nitrix nods
11:54:12 <nitrix> Appreciated.
11:54:46 <tulcod> nitrix: and if hlint tells you to do it, and you don't want to create a "color of the bikeshed" debate, and you don't really care, you might as well follow its advice
11:55:14 <iross_> tulcod: OK, that Wayland XML->FFI code is a thing of awesome and terrible beauty.  At first sight, it looks like an absolutely horrible way to do things, but it's actually kind of brilliant.
11:55:28 <HeladoDeBrownie> nitrix, my rule is that if the application spans only one line, i use just parens; otherwise i apply everything else with ($) to the subexpression that spans lines, e.g., a do expression. it's also possible to extract a composed chain into a new name, that's also an option.
11:55:34 <tulcod> iross_: i'll take that as a compliment. i'm impressed you could work it out so quickly.
11:55:41 <nitrix> http://lpaste.net/129890
11:55:47 <nitrix> Look what I did today :D
11:55:56 <nitrix> Modified a older function when I was still a beginner into Parsec !
11:56:06 <tulcod> iross_: i guess there's an analogue you can draw here with modernist art :)
11:56:06 <nitrix> Doesn't it looks much better :) ?
11:56:21 <nitrix> EvanR: ping
11:56:25 <iross_> tulcod: Just off down the rabbit hole, going "What?"  "WHAT?"  "WHAAATTT???!!!"
11:56:41 <iross_> tulcod: Now you've got me thinking about a metaprogramming API for C2HS...
11:56:44 <HeladoDeBrownie> nitrix, which one's the new one?
11:56:47 <nitrix> EvanR: I'm the guy that was whining about Parsec and giving up one day ago. Look http://lpaste.net/129890 :)
11:56:53 <nitrix> HeladoDeBrownie: Prime is the now
11:56:57 <nitrix> HeladoDeBrownie: *new
11:57:01 <tulcod> iross_: so you agree that that would not be the most terrible solution?
11:58:11 <iross_> tulcod: I think it could be pretty awesome.  I know there are quite a few data formats defined via XML files, but this is the first API I've seen that does that.  Do you know of any others?  If Wayland's the only use case, it might not be worth the effort (well, worth MY effort!), but if this is going to become "a thing", it might be cool to support it.
11:58:18 <HeladoDeBrownie> nitrix, a couple suggestions: put a blank line between adjacent definitions; and delete all "_ <-", since it's equivalent without.
11:58:42 <Denommus> hi
11:58:54 <nitrix> HeladoDeBrownie: I get warnings for _ <- though, let me check. And blank lines inbetween where clauses?
11:59:09 <HeladoDeBrownie> nitrix, what's the warning say? in between the definitions in the where clause.
11:59:12 <ReinH> You get warnings, but you can still do it.
11:59:31 <ReinH> The warnings are just to let you know you might have wanted to do something with it
11:59:34 <nitrix> A do-notation statement discarded a result of type Char
11:59:36 <nitrix> Suppress this warning by saying ‘_ <- char '='’
11:59:38 <nitrix> or by using the flag -fno-warn-unused-do-bind
11:59:43 <nitrix> Ouch, my client didn't line wrap
11:59:46 <ReinH> if you want to avoid the warnings, you can use void
11:59:48 <HeladoDeBrownie> ah, then it's what ReinH said
11:59:54 <HeladoDeBrownie> if you actually don't need to use it, just delete it
12:00:36 <nitrix> I cannot simply remove it, Parsec will get mad at me for a stray character.
12:00:40 <HeladoDeBrownie> do { a ; b } = a >> b = a >>= \_ -> b = do { _ <- a ; b }
12:00:42 <HeladoDeBrownie> erm
12:00:53 <HeladoDeBrownie> i doubt that's the case for what i'm saying
12:01:00 <__ryan> hi are they anyone knows about keter, here?
12:01:05 <HeladoDeBrownie> i mean replace "_ <- char '='" with "char '='"
12:01:16 * hackagebot nero 0.1.1 - Lens-based HTTP toolkit  http://hackage.haskell.org/package/nero-0.1.1 (jdnavarro)
12:01:22 <hexagoxel> a riddle: i made my code more complex, now the compilation is faster.
12:01:24 <hexagoxel> (am being rather certain of the answer)
12:01:50 <nitrix> ReinH: I void'ed it from Control.Monad. Thanks.
12:02:55 <HeladoDeBrownie> ReinH, why would void do anything there?
12:03:13 <ReinH> :t void
12:03:14 <lambdabot> Functor f => f a -> f ()
12:03:18 <HeladoDeBrownie> i know what void does
12:03:25 <ReinH> Then why don't you know why it does anything?
12:03:40 <ReinH> It takes an m a, the thing being warned about, and turns it into a m (), which does not generate warnings
12:03:43 <HeladoDeBrownie> because the result was ignored anyway
12:03:56 <geekosaur> afaik void is one of the reocmmended ways to get aroubnd that warning
12:04:00 <ReinH> The warning is for ignored m a where a is not ()
12:04:12 <ReinH> turning it into m () prevents the warning
12:04:26 <HeladoDeBrownie> so, are you saying that whenever you have an expression as a do statement whose result is not (), it warns you that you're discarding it?
12:04:36 <ReinH> If you don't bind it, yes.
12:04:38 <ReinH> That's what that warning is.
12:04:41 <geekosaur> if yoiu're not capturing it, yes
12:04:42 <HeladoDeBrownie> that's a bit silly.
12:04:46 <ReinH> Yes.
12:04:51 <ReinH> that's why I suggested to just ignore the warning
12:05:13 <nitrix> Except I never ignore warnings and I think that's a legitimate use of void.
12:05:27 <nitrix> The function does yield a value.
12:05:30 <ReinH> It's a legitimate use.
12:05:35 <ReinH> It's also legitimate to not use it.
12:05:40 <quchen> Interesting, since when did `runST (return ())` work? Is this new in GHC 7.10 or am I overlooking something?
12:05:47 <ReinH> Humans get to look at warnings and decide whether they're relevant
12:05:54 <quchen> ($) runST (return ()) still fails though
12:05:59 <nitrix> It's better to keep the warnings at 0 ahah.
12:05:59 <ReinH> And if they're not, they get to ignore them
12:06:29 <tulcod> iross_: i'm pretty sure it used to happen in the X ecosystem as well (xcb comes to mind). at the moment i don't know of any others, will let you know if i think of any.
12:06:30 <HeladoDeBrownie> quchen, presumably runST $ return () is special syntax overloading ($)?
12:06:35 <ReinH> That assumes that GHC warnings are smarter than you are
12:06:44 <ReinH> They aren't.
12:06:57 <quchen> HeladoDeBrownie: Infix ($) has special rules, yes. But I didn't use it in the first piece of code.
12:07:05 <quchen> > runST (return ())
12:07:07 <lambdabot>  ()
12:07:08 <quchen> > runST $ return ()
12:07:10 <lambdabot>  ()
12:07:10 <HeladoDeBrownie> quchen, right, i was just thinking about the second one
12:07:13 <iross_> tulcod: OK.  Just put "think about metaprogramming" on my C2HS todo list...
12:07:14 <quchen> > ($) runST (return ())
12:07:16 <lambdabot>      Couldn't match type ‘m0 ()’ with ‘∀ s. ST s a’
12:07:16 <lambdabot>      Expected type: m0 () → a
12:07:16 <lambdabot>        Actual type: (∀ s. ST s a) → a
12:07:25 <tulcod> iross_: :D
12:07:47 <HeladoDeBrownie> quchen, i'm not sure why runST (return ()) wouldn't type?
12:08:08 <quchen> HeladoDeBrownie: Oh, it's the inference of ($)'s type that fails the typechecker there?
12:08:23 <HeladoDeBrownie> quchen, yeah cause it can't be instantiated at a polymorphic type
12:08:53 <Denommus> where can I get good papers on how to implement an AFRP library?
12:08:57 <quchen> Ah right, because the b in (a->b) -> a -> b would have to reference ST's "s" parameter
12:10:25 <platz> do I need a pragma now whether to import <*> depending on which version of ghc is building?
12:10:38 <platz> i.e. to avoid warnings
12:10:52 <tulcod> iross_: it looks like SWIG originally planned to use XML as an internal representation of APIs. this is not quite the case now, but there are tools that generate bindings from XML. very minor use case though.
12:12:48 <newsham> ?hoogle (Monad m) -> m Bool -> m a -> [a]
12:12:51 <lambdabot> Warning: Unknown type Monad
12:12:51 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
12:12:51 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:13:00 <iross_> tulcod: OK.  Thanks for looking.
12:13:55 <tulcod> iross_: (and yes, xcb uses XML-like API definitions, http://en.wikipedia.org/wiki/XCB#Protocol_description )
12:14:15 <newsham> is there a "while" that does m Bool -> m a -> m [a] ?
12:14:31 <ReinH> newsham: there's a whileM in monad-loops iirc
12:14:53 <newsham> yup, thats what i want, ty.
12:15:30 <tulcod> (implemented in xhb here https://github.com/aslatter/xhb/blob/master/shared.sh )
12:16:09 <tulcod> (ie here https://github.com/aslatter/xhb/blob/master/build-utils/Parse.hs and onwards )
12:16:16 * hackagebot trace 0.1.0.5 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.5 (JonSterling)
12:16:46 <newsham> why would I get "Could not deduce (n ~ Int64) from the context (Integral n, Binary a)" when Int64 is declared as being Integral?
12:17:10 <ReinH> newsham: what's the context?
12:18:02 <shachaf> (n ~ Int64) means that n is equal to Int64. (Integral n) means that n is an instance of Integral.
12:18:06 <lpaste> newsham pasted “context for deduce type error” at http://lpaste.net/129891
12:18:09 <shachaf> You can only go in one direction there.
12:19:12 <shachaf> You didn't paste your code, but it sounds like you have a function that promises it'll work for any n which is an instance of Integral and Binary. But then it assumes that n is Int64.
12:19:43 <newsham> ahh, yup.. i see.
12:21:00 <newsham> silly of me :)
12:21:16 * hackagebot yet-another-logger 0.1.1.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.1.1.1 (larsk)
12:22:57 <newsham> whileM (not <$> isEmpty) get     <- much cleaner than what I had earlier :) woot
12:23:48 <bitemyapp> https://www.fpcomplete.com/blog/2015/03/announce-ide-backend
12:26:00 <ion> bitemyapp: nice
12:31:17 * hackagebot stripe-haskell 0.1.3.1 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.3.1 (DavidJohnson)
12:38:55 <phadej> Does anyone know why 7.10.1 is almost 2x slower than 7.8.4: http://i.imgur.com/A0K2B5a.png
12:39:04 <phadej> https://travis-ci.org/haskell/containers
12:39:15 <newsham> is there any way to "maybe" decode something with Data.Binary.Get?  sort of like "try" in parsec?
12:39:29 <phadej> or https://travis-ci.org/haskell/containers/builds/54581175 to be precise
12:39:33 <newsham> i ran a test with "runGetState" hoping it would fail gracefully, but it still does an "error". :(
12:40:14 <newsham> if Binary doesnt support it, does Serialize?
12:40:30 <sinelaw> phadej, try another run? may be first time bootstrap cost?
12:40:34 <newsham> it looks like Serialize does.. hrm
12:41:18 * hackagebot ttrie 0.1.0.0 - Contention-free STM hash map  http://hackage.haskell.org/package/ttrie-0.1.0.0 (MichaelSchroeder)
12:41:27 <phadej> sinelaw: the previous passing build: https://travis-ci.org/haskell/containers/builds/53404891 has the same 2x
12:41:28 <Cale> newsham: attoparsec has try
12:41:37 <bitemyapp> ion: I'm pretty excited.
12:41:41 <sinelaw> phadej, then try asking in #ghc
12:41:51 <phadej> sinelaw: ah thanks
12:42:04 <bitemyapp> ion: there's a lot, relatively speaking, information that can be statically gleaned from Haskell code so editors/IDEs that leverage that more fully would be really nice :)
12:42:21 <ion> verily
12:42:40 <newsham> cale: right, i'm asking if there's a way to avoid "error" in Data.Binary. 
12:42:51 <newsham> it looks like my simple solution would be to use Data.Serialize instead
12:45:58 <Cale> newsham: Yeah, if cereal works for you, it's definitely more similar to binary than attoparsec is.
12:46:26 <Cale> I thought it was set up for deterministic parsing as well though.
12:47:13 <newsham> I just need this one case where I read as many records out of a buffer as I can
12:47:31 <newsham> which I can do by catching the failure 
12:51:03 <Aruro> in Data.Ratio, Ratio is defined like this: data  Ratio a = !a :% !a
12:51:11 <Aruro> what "!" stands for?
12:51:31 <Fuuzetsu> strictness annotation
12:51:42 <Aruro> ty
12:51:52 <Aruro> how is it called ? that i can google it for?
12:52:02 <Aruro> strictness operator?
12:52:05 <Aruro> keyword?
12:52:08 <Fuuzetsu> haskell strictness annotation
12:52:12 <Aruro> k
12:52:13 <Aruro> ty!
12:52:28 <ReinH> @google haskell strictness annotation
12:52:29 <lambdabot> https://wiki.haskell.org/Performance/Strictness
12:52:40 <Aruro> thanks
12:53:05 <Aruro> actually why is it needed in this case?
12:53:08 <Aruro> data  Ratio a = !a :% !a
12:54:07 <ReinH> To guarantee that any time a Ratio is evaluated, its members are also evaluated (to WHNF).
12:54:31 <Aruro> ok
12:54:44 <Aruro> do other number types has same thing?
12:54:49 <ReinH> Otherwise the Ratio would "leak" space by storing thunks rather than evaluating its members.
12:55:53 <Trioxin> it's strange that haskell has so many users and I never hear about it.. ever
12:55:57 <ReinH> Essentially, yes. Most number types in GHC are unboxed, which means they are also strict.
12:56:04 <ReinH> Int and Double, for example
12:56:19 * hackagebot ide-backend-rts 0.1.3.1 - RTS for the IDE backend  http://hackage.haskell.org/package/ide-backend-rts-0.1.3.1 (MichaelSnoyman)
12:56:20 * hackagebot ide-backend-common 0.9.0 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.0 (MichaelSnoyman)
12:56:23 * hackagebot ide-backend 0.9.0.2 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.2 (MichaelSnoyman)
12:56:58 <Trioxin> i never even heard the word haskell until today and i've been coding for 15 years
12:57:32 <verement> what brought it to your attention?
12:57:39 <earthy> wow. 15 years. ;)
12:57:56 <Trioxin> comparison between it, lisp, and prolog (google)
12:58:02 <Aruro> ty ReinH
12:58:16 <dgorbik> But you've heard of lisp before :)
12:58:23 <Trioxin> yeah
12:58:24 <dgorbik> (I hope)
12:58:26 <dgorbik> hehe
12:58:37 <Marquis> Prolog too?
12:58:41 <Trioxin> yeah
12:58:46 <Aruro> ML?
12:58:49 <Trioxin> no
12:58:59 <earthy> APL?
12:59:07 <bigs> lol
12:59:10 <dolio> Lisp and Prolog are much older, so more people have heard of them.
12:59:47 <Trioxin> APL sounds familiar. I think it was used to test me during my air force test
12:59:53 <earthy> Prolog isn't that much older than ML
12:59:56 <dolio> 40 - 50 years instead of just 20 - 30.
13:00:20 <randir> What's the most efficient way in "IntMap" to move something from 5 -> a to 6 -> a, i.e, to move a value to a different key
13:00:22 <Trioxin> it was some archaic language starting with an A
13:00:39 <moghedrin> Trioxin: Probably thinking of Ada. Was big in the Air Force for some time.
13:00:46 <geekosaur> my guess for that is algol 60, actually
13:00:57 <bigs> Trioxin: probably Ada
13:00:58 <bigs> ya
13:01:08 <geekosaur> ada's not really archaic
13:01:27 <dolio> Also Prolog is the prototypical logic language that people get taught in some kind of survey course.
13:01:32 <randir> "Real programers don't use Pascal"
13:01:45 <Trioxin> well, heh. as a teenager at the time and not ever hearing of it I assumed at the moment of the test it was archaic
13:01:56 <randir> Does anyone else keep having people mishear them as saying "Pascal" when you say "Haskell"?
13:02:04 <ij> YES!
13:02:08 <dolio> And Lisp is the choice for 'functional' languages. So you don't get to hear about ML.
13:02:17 <caconym> randir: yes, and it's terrible
13:03:04 <caconym> apparently the F-22 avionics etc were written mostly in ada
13:03:16 <caconym> but the F-35 is more C and C++
13:03:38 <caconym> interesting if true; seems to imply that ada is on the way out for those applications
13:03:57 <randir> How can I change the key for a given value, for an IntMap?
13:04:07 <Trioxin> when the ada part of the test came I skipped it
13:04:23 <randir> or, to put it better, move a key, so that 4 -> a will become 7 -> a
13:04:25 <Trioxin> because had I known I would have studied ada
13:04:56 <Trioxin> i didn't wind up joining the air force anyway
13:05:04 <randir> We need a more dynamic military. Program in python! :P
13:05:22 <Yaniel> great idea, snake
13:05:35 <Trioxin> i hear the mexican air force codes in Autoit
13:05:55 <randir> Google's robot army is programmed in Go.
13:06:09 <caconym> maybe that's what's been keeping the F-35 down... "undefined method "foo" for None"
13:06:09 <randir> Microsoft uses .NET
13:06:11 <bigs> randir: `update`
13:06:14 <randir> It's like skynet, but less impressive.
13:06:27 <mniip> SKY.NET
13:06:54 <josephle> bigs, 'update' changes the value it seems
13:06:59 <bigs> yeah
13:07:09 <bigs> there are many different ways to do what he's described
13:07:09 <josephle> randir, the worse case scenario is you have to delete the element and re-insert it :/
13:07:14 <bigs> yeah
13:07:26 <bigs> that's hardly too much of a pain tho
13:07:30 <randir> Does it look like I have to use that?
13:07:32 <earthy> dolio: that's mostly true in the US though. Lisp isn't quite so big in europe
13:07:36 <randir> Not much of a pain, but I want to be efficent
13:10:38 <sdgdfgfdsg> you hack my server ok samp.bmhp.net:7777 hack me hehhe
13:11:02 <josephle> randir, doesn't seem to be a single function that will do what you want
13:11:20 * hackagebot ide-backend 0.9.0.3 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.3 (MichaelSnoyman)
13:11:55 <randir> Okay, thanks anyhow.
13:13:17 <randir> how do I use a qualified operator?
13:13:43 <randir> just X.!   ?
13:13:43 <Hijiri> Module.Name.*
13:13:53 <Hijiri> yes
13:14:05 <randir> does it still keep the same infix status?
13:14:09 <Hijiri> yes
13:14:12 <randir> k, thanks
13:17:02 <randir> How much more efficent is IntMap than map?
13:17:20 <randir> I'm using a tuple to key a given piece in a chess board
13:17:23 <shachaf> They are uncomparable.
13:17:44 <randir> so much more efficient? 
13:17:57 <randir> I mean Data.IntMap vs Data.Map 
13:18:17 <shachaf> Neither is more efficient.
13:18:28 <`^_^v> you should probably use bitboards if you want to be efficient
13:18:44 <randir> I know, but I'm trying to do it without bitboards for now
13:19:01 <randir> I want to be efficent, but that's not the top goal right now
13:19:59 <randir> When creating a new record, how much of actual memory is preserved?
13:20:37 <randir> if I only change part of the record. Or if an element in a record is something like IntMap which preserves an underlying data-structure instead of doing a full copy. 
13:22:57 <quchen> randir: You can assume things like these are shared, so if you update one value in a 10-tuple, all the other 9 will not be touched
13:23:00 <erisco> @pl \f g a -> f a <|> g a
13:23:00 <lambdabot> liftM2 (<|>)
13:23:12 <quchen> randir: In general that's up to the compiler though
13:23:27 <erisco> would be nice if liftM2 (<|>) had a name
13:23:39 <randir> quchen: okay, thanks
13:23:40 <erisco> it is a nice complement to <=<
13:23:41 <quchen> It has!  liftA2 (<|>)  ;-)
13:24:23 <erisco> I will name it >|<
13:24:30 <znst> Surrounding haskell web packages, e.g. yesod, warp, what kind of info is there about http2 support?
13:24:35 <randir> I have import qualified Data.IntMap as IM, and then use IM.!
13:24:39 <randir> but it's giving me a parse error
13:25:22 <randir> I guess just surround in parentheses?
13:25:52 <shachaf> 13:12 <randir> just X.!   ?
13:25:56 <shachaf> 13:23 <randir> I guess just surround in parentheses?
13:26:04 <shachaf> You tend to guess correctly.
13:26:14 <shachaf> Try these things first, and then, if it doesn't work, ask on IRC.
13:26:21 * hackagebot ide-backend 0.9.0.4 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.4 (MichaelSnoyman)
13:26:28 <shachaf> (And include your complete code and complete error message.)
13:26:30 <randir> I came up with the idea after I asked
13:26:46 <randir> but yeah
13:29:04 <erisco> and then you can have another nice definition
13:29:21 <erisco> attempt :: (Alternative f) => (a -> f a) -> a -> f a; attempt = flip (>|<) pure
13:30:33 <Denommus> every paper I read tells me to see signal functions as Signal a -> Signal b, and data Signal a = Time -> a
13:30:39 <Denommus> but I know it's not like that internally
13:30:51 <Denommus> is there a paper that actually describes how a signal function is internally?
13:30:58 <Denommus> I'm going to guess it's some sort of crazy graph
13:31:38 <znst> Alternatively, does anyone know if https://github.com/yesodweb/wai has plans to support HTTP/2 ?
13:33:03 <benzrf> znst: people USE that?
13:33:14 <benzrf> :t (>|<)
13:33:15 <lambdabot>     Not in scope: ‘>|<’
13:33:15 <lambdabot>     Perhaps you meant one of these:
13:33:15 <lambdabot>       ‘Seq.><’ (imported from Data.Sequence),
13:33:21 <benzrf> huh, wat?
13:33:36 <benzrf> Denommus: why do you care about the operational semantics
13:33:44 <benzrf> the denotational semantics are the important part, generally
13:33:46 <erisco> and then finally   (<?<) :: (Alternative m, Monad m) => (a -> m a) -> (a -> m a) -> a -> m a; (<?<) g f = attempt g <=< attempt f
13:33:56 <benzrf> unless you wanna write your own implementation or are worried abt perf
13:34:11 <znst> benzrf: I've been toying with a haskell webstack in my free time, so yes, unless you know of a better web application interface
13:34:40 <erisco> @define (>|<) = liftA2 (<|>) -- benzrf
13:34:42 <lambdabot>  Defined.
13:35:44 <benzrf> o:
13:35:55 <erisco> @define attempt = flip (>|<) pure
13:35:56 <lambdabot>  Defined.
13:35:58 <benzrf> znst: o=
13:36:16 <erisco> @define (<?<) g f = attempt g <=< attempt f
13:36:17 <lambdabot>  Defined.
13:36:21 * hackagebot xml-to-json 2.0.0 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-2.0.0 (NoamLewis)
13:36:22 <benzrf> good lord
13:36:37 <znst> benzrf: idk what o= means
13:36:54 <benzrf> idk just a general reaction of sort of "oh huh alright"
13:37:05 <zomg> znst: I think benzrf may have been talking about nobody using HTTP/2, afaik wai is fairly common in Haskell web stacks
13:37:15 <benzrf> er, yeah
13:37:35 <erisco> > (return . (+1) <?< const Nothing <?< return . (*2)) 10
13:37:37 <lambdabot>      Precedence parsing error
13:37:37 <lambdabot>          cannot mix ‘.’ [infixr 9] and ‘<?<’ [infixl 9] in the same infix exp...
13:37:37 <lambdabot>          cannot mix ‘<?<’ [infixl 9] and ‘.’ [infixr 9] in the same infix exp...
13:37:48 <erisco> > ((return . (+1)) <?< const Nothing <?< (return . (*2))) 10
13:37:50 <lambdabot>  Just 21
13:38:12 <znst> benzrf: zomg: oh :) Not quite yet, but there are planned releases for http servers to support http2 by end of year. Got to stay on top of things, you know?
13:38:35 <erisco> the idea is that you attempt many transformations in sequence (it is okay if one doesn't work)
13:39:16 <benzrf> znst: huh
13:41:13 <znst> benzrf: zomg: A resource around it if anyone is the slight bit interested http://www.heavybit.com/library/video/2013-08-27-ilya-grigorik
13:41:21 * hackagebot cassava 0.4.2.3 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.2.3 (JohanTibell)
13:46:03 <tempname11_> by any chance, is anyone else here doing the "General Game Playing" course on Coursera?
13:46:21 * hackagebot hashable-time 0.1.0.1 - Hashable instances for Data.Time  http://hackage.haskell.org/package/hashable-time-0.1.0.1 (alkar)
13:46:23 * hackagebot HDBC-postgresql 2.3.2.3 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.3.2.3 (ErikHesselink)
13:47:03 <Hijiri> in what way is it general?
13:48:56 <znst> Hijiri: Looks interesting https://www.coursera.org/course/ggp
13:50:18 <Hijiri> It seems interesting so I will join
13:50:32 <Hijiri> until I decide I can't keep up, or that I don't have enough time
13:51:12 <Hijiri> I wish I had brought some headphones so I could listen to this in the library
13:53:57 <Welkin> Hijiri: subtitles
13:55:45 <Hijiri> oh, right
13:55:51 <Hijiri> I guess I'll start watching then
13:57:06 <franky> hi guys, I was wondering you could help me with a little problem
13:57:22 <franky> I'm trying to do breath first on a Rose Tree of in
13:57:41 <franky> integers and print the values on the screen
13:58:20 <athan> franky: I think the foldable instance for Data.Tree is depth first
13:58:30 <athan> you should be able to do this pretty simply through a recursive function
13:58:52 <glguy> franky: What's your question?
13:59:07 <athan> Think about it - if you only pattern match on the element _before_ progressing to the children, you should be able to accomplish this pretty simply
14:00:44 <franky> Imaging I have a rosetree like thistree2 = Node 5 [Node 3 [Node 1 [], Node 2 []], Node 4 []]-- e.g. breathFst tree2 ===> [5, 3, 4, 1, 2]
14:01:36 <Denommus> benzrf: I want to implement a library for OCaml
14:02:26 <Welkin> I never finish any coursera courses
14:02:49 <Welkin> they are still helpful though -- I typically just watch the videos or read the notes
14:03:32 <athan> franky: Have you looked at `flatten`?
14:03:38 <athan> I did this a while ago: https://github.com/haskell/containers/pull/140/files
14:03:56 <jellie> Denommus: Hmmm why do people do OCaml instead of haskell? What draws people to it? Also if you know about idris, what draws people to it?
14:04:18 <Denommus> jellie: the module system, mostly
14:04:56 <jellie> Denommus: but the haskell module system is awesome as far as I can tell. What do you mean?
14:05:35 <HeladoDeBrownie> ml modules can have parameters
14:06:19 <randir> What's the best way to parse "a2->a4" into the tuples (1,2) (1,4)?
14:06:47 <randir> obviously I could just step through it char by char and manually parse, but I'm wondering what the most haskelly way would be?
14:06:54 <HeladoDeBrownie> randir, by what rule?
14:06:59 <Denommus> jellie: OCaml's module system is much, much, MUCH more powerful than Haskell's
14:07:35 <randir> "a" represents 1, "b" -> 2 ... "h"->8
14:07:57 <Denommus> jellie: OCaml has functions from module to module, which it calls "functors". This kind of function can be used to encode abstract data types, or even encode RankNPolymorphism easily (even replacing the need for typeclasses - though in a more verbose fashion)
14:07:59 <randir> I can definitely manually parse it, just wondering if there's some way to overload "read" to do this naturally
14:08:15 <randir> probably would have to write a custom parser
14:08:25 <arkeet> you shouldn't overload read for that.
14:08:41 <HeladoDeBrownie> randir, well there's always parsec
14:09:04 <jellie> Denommus: Then I hope all the haskell controlling people are listening and are ready to make breaking changes to the haskell module system.
14:09:15 <randir> yeah. I'll just write a little parse function, since it's a simply case
14:09:24 <randir> was mainly just curious to see what the recomended method was
14:10:01 <gfixler> does structural sharing mean that equality checks on deeper structures in Haskell are often/always cheap?
14:10:24 <Denommus> jellie: I doubt Haskell will do such a change, or needs it
14:10:33 <Denommus> jellie: but OCaml is interesting because of that, nevertheless
14:10:41 <Denommus> jellie: also, strict evaluation is a good default
14:11:01 <HeladoDeBrownie> gfixler, not necessarily
14:11:09 <jellie> Uh no I like laziness also I don't understand what you meant by functions from module to module.
14:11:12 <jellie> Denommus: ^
14:11:23 * hackagebot xml-to-json-fast 2.0.0 - Fast, light converter of xml to json capable of handling huge xml files  http://hackage.haskell.org/package/xml-to-json-fast-2.0.0 (NoamLewis)
14:12:12 <HeladoDeBrownie> gfixler, i'm actually not sure it gets you that at all, although feasibly it could i suppose. one problem is that Eq is not enforced to respect same equals same
14:12:23 <gfixler> HeladoDeBrownie: I didn't think so
14:12:35 <gfixler> I wonder if there's a same-thing check
14:12:42 <gfixler> or if there even could be
14:13:01 <Denommus> jellie: lazyness can be a good default in some contexts, strictness in others
14:13:20 <Denommus> jellie: a function from module to module is a function that takes some modules by parameter and produce another module
14:14:38 <Denommus> jellie: OCaml call those "functors" (not to be confused with Haskell's functors)
14:15:52 <franky> athan I'm trying but I don't manage to get it to work as I'd like..
14:16:12 <arkeet> I don't know much about ocaml but I think haskell's type classes cover at least some cases you'd use ML modules for.
14:16:23 * hackagebot xml-to-json 2.0.1 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-2.0.1 (NoamLewis)
14:16:25 * hackagebot ttrie 0.1 - Contention-free STM hash map  http://hackage.haskell.org/package/ttrie-0.1 (MichaelSchroeder)
14:16:49 <Denommus> arkeet: definitely, but I want to create such a library for OCaml because there is already an equivalent library in Haskell, called Netwire
14:16:59 <Welkin> franky: there is already a package for rose trees
14:17:05 <Welkin> take a look at the source
14:17:09 <Denommus> maybe I should just read Netwire's source, indeed
14:17:26 <arkeet> I haven't been following the context of the conversation.
14:17:29 <franky> I have to do it without external packages// :)
14:17:38 <Denommus> though the monadic magic to force evaluation at each step is probably too much for my use-case
14:17:46 <Welkin> franky: yes, that is why you read the source to learn how to do it
14:19:56 <gfixler> Denommus: just looking through this: https://realworldocaml.org/v1/en/html/files-modules-and-programs.html
14:20:04 <jellie> Denommus: Interesting
14:20:07 <gfixler> Modules feel a bit like Clojure's namespaces
14:20:34 <gfixler> with maybe a touch of Ruby's classes
14:27:52 <Denommus> gfixler: they... are vaguely like Ruby's modules, except you actually have a type system for it
14:39:35 <lpaste> glguy pasted “Breadth first rose-tree traversal with iterative-deepening depth-first search ^_^” at http://lpaste.net/129892
14:54:10 <lpaste> amf pasted “phantom type compile error” at http://lpaste.net/129894
14:54:54 <amf> if anyone has an idea why my program doesn't type check, im all ears (and out of ideas how to fix it)
14:57:45 <koala_man> amf: what did you mean by the 'a' in 'Location a' on line 34? 
14:57:56 <ttt_fff> https://gist.github.com/anonymous/7113feb008e58e5ff43b <-- why is this unacceptable in ffi ?
14:58:10 <amf> koala_man: its a phantom type
14:58:21 <platz> with 7.10 while building there are lots of warnings like "The import of ‘<*>, <$>’ from module ‘Control.Applicative’ is redundant".  How do I remove those warnings and both users of 7.8 and 7.10 compile?  Do I need pragmas?
14:58:37 <mniip> 'rd = read :: (Read a => String -> a)'
14:58:40 <mniip> isn't that
14:58:43 <mniip> like, redunant?
14:59:32 <amf> mniip: it is, an artifact from my previous refactoring
14:59:46 <arkeet> platz: put "import Prelude" at the end of your import list.
15:02:49 <hexagoxel> amf: there is a type `GeoRegion` and a constructor (for type `Location` (!)) `GeoRegion`
15:03:01 <hexagoxel> they are not the same
15:04:16 <hexagoxel> you may want `data Location = .. | .. | GeoRegionLocation GeoRegion`
15:06:02 <hexagoxel> amf: in other words: creating a sum-type creates a bit more (syntactical) effort than you current put in there
15:06:29 <amf> ah ha! 
15:06:37 <amf> hexagoxel: so Location is called a sum type?
15:07:26 <hexagoxel> if my interpretation of what you actually want it to be is correct, yes :)
15:07:31 <erisco> is there an extension to add a common sum types just as (,) (,,) (,,,) ... are common product types?
15:07:51 <Fuuzetsu> erisco: add in what way?
15:07:57 <hexagoxel> (classic sum type example is Either; product type is any Tuple)
15:08:28 <amf> well that just cleared up a lot of misconceptions in my head! thanks hexagoxel!!
15:08:29 <erisco> Fuuzetsu convenient syntax
15:08:32 <mniip> there are some issues with that
15:08:56 <mniip> you need N constructors for the Nth type for example
15:09:18 <mniip> all different
15:10:10 <oa_> In declarative programming you are not supposed to change stored values, but then say, how do you perform a string rewrite? Do you temporarily access the value of a string, modify it, delete the old value and dereference it, and assign it to a new variable?
15:10:17 <erisco> mniip possibly not
15:10:39 <Fuuzetsu> oa_: you create a new string that's what you want already
15:10:43 <Fuuzetsu> you don't change anything
15:10:46 <erisco> something to generalize a type A to the type A|B would suffice
15:11:18 <mniip> Either
15:11:32 <erisco> then the nth sum type needs only one constructor
15:11:45 <oa_> Fuuzetsu: But what if you do this many times, won't you have hundreds of new string variables, how does cleanup work there?
15:11:46 <mniip> just like (a, b, c, d) can be (((((), a), b), c), d)
15:12:02 <erisco> sure but that is not convenient to unpack
15:12:18 <Fuuzetsu> oa_: no you won't because no one writes functions which bind hundreds of variables
15:12:28 <Fuuzetsu> also the compiler is free to spirit it all away 
15:12:34 <hexagoxel> data Either4 a b c d = TotallyLeft a | MoreLeft b | MoreRight c | TotallyRight d
15:12:57 <mniip> erisco, you can use PearShaper RePairs
15:13:01 <mniip> PearShaped*
15:13:04 <rola> @djinn (a,b,c,d) -> (((a,b),c),d)
15:13:04 <lambdabot> f (a, b, c, d) = (((a, b), c), d)
15:13:06 <Fuuzetsu> hexagoxel: generalise further with Middlel
15:13:29 <oa_> ok
15:13:31 <oa_> thank you
15:13:44 <shapr> mniip: I am not Pear shaped!
15:14:32 <hexagoxel> Fuuzetsu: we just need more qualifiers: slightly, moderately, largely, completely
15:16:27 * hackagebot aws-general 0.2.2 - Bindings for Amazon Web Services (AWS) General Reference  http://hackage.haskell.org/package/aws-general-0.2.2 (larsk)
15:18:11 <jellie> I'm having trouble compiling an executable. cabal claims there is no main module yet I have specified the main module in my cabal file. Here is a gist: https://gist.github.com/urbanslug/c9565d80199f38c53492
15:18:47 <Fuuzetsu> jellie: your main module has to be called Main
15:18:54 <Fuuzetsu> ‘module Bot where’ is your problem
15:19:07 <jellie> Fuuzetsu: Are you serious?
15:19:24 <jellie> Fuuzetsu: This only aaplies to executables I assume
15:19:34 <erisco> what you want is something like   A => A|B   A|B => B|A   so then you get   Int ~ Int|Char ~ Char|Int ~ String|Char|Int ~ (Maybe Int)|Char|Int    and so on
15:19:49 <mgsloan> Alternatively, you can omit the module declaration for your Main module
15:19:50 <jellie> Fuuzetsu: Because I've called my main module other things other than Main in libraries and that worked.
15:19:52 <erisco> whoops
15:19:55 <erisco> I do not mean ~
15:20:06 <jellie> Fuuzetsu: Yes I knew you were serious. It was more of a rhetorical question.
15:20:10 <jellie> Fuuzetsu: Thanks
15:20:11 <erisco> I mean   Int -> Int|Char, Int|Char -> Char|Int, and so on
15:20:20 <Fuuzetsu> there is no concept of main module in libraries
15:21:54 <erisco> not sure what that does to inference, but it would be nice
15:21:55 <jellie> Fuuzetsu: hmmm I see
15:21:58 <jellie> Fuuzetsu: Thanks
15:22:19 <jellie> Fuuzetsu: btw if you have noticed it uses simpleirc which you have contributed to
15:22:41 <jellie> Fuuzetsu: I want to add a few type signtures to the example bot and play with it
15:22:58 <jellie> Fuuzetsu: It's zipper, you helped me with haddock. 
15:23:21 <mniip> data Either12 a b c d e f g h i j k = AbsolutelyNot a | TotallyNot b | CompletelyNot c | PracticallyNot d | Unlikely e | Hypothetically f | Likely g | Practically h | Completely i | Totally j | Absolutely k
15:23:28 <jellie> Fuuzetsu: It's coincidental that you are a contributor to both haddock and simpleirc
15:23:33 <jellie> Fuuzetsu: Okay I'm done now.
15:23:37 <Fuuzetsu> I'm a contributor to simpleirc?
15:23:42 <erisco> mniip that is far from what I am asking for :P
15:23:53 <mniip> nah I'm just messing around with adverbs
15:23:54 <geekosaur> mniip, Magic12Ball? :p
15:23:54 <mniip> er
15:23:56 <mniip> adjectives
15:24:16 <mniip> ConcentrateAndAskAgain l
15:24:38 <jellie> Fuuzetsu: Yes :) See this https://github.com/dom96/SimpleIRC/blob/master/example/example.hs
15:25:01 <jellie> Fuuzetsu: You're pic is there
15:25:04 <jellie> *your
15:25:38 <jellie> Better yet https://github.com/dom96/SimpleIRC/commit/a1d3deba61aef34164aa5a4159247701f7a10d17
15:26:14 <arkeet> why not use GADTs for your sum types.
15:26:20 <Fuuzetsu> jan 30, 2014, long forgotten
15:26:33 <arkeet> data Sum :: [*] -> * where I :: a -> Sum (a ': as); S :: Sum as -> Sum (a ': as)
15:26:36 <arkeet> or something.
15:26:55 <erisco> f x = case x of Is_Int x -> x + 1; Is_String y -> "hello " ++ y;  f :: (Num a) => a|String -> a|String
15:27:16 <erisco> not sure what the convention would be for the data constructor names, but something of that sort
15:29:12 <tdammers> ok, so apparently somewhere something goes wrong when I feed the contents of a file to WAI's responseLBS using file-embed, and the file contains multibyte UTF-8 entities
15:29:24 * mniip searches for his first github commit
15:29:33 <shapr> mniip: ooh, I want to know!
15:29:45 <tdammers> when that happens, the reported length of the bytestring ends up too short, and the response gets truncated
15:29:54 <shapr> tdammers: sounds like a bug
15:30:00 <tdammers> that's what I thought
15:30:12 <tdammers> just can't pinpoint which of the libraries is to blame
15:30:50 <mniip> heh
15:30:50 <erisco> also, generalization is allowed on return types and only specialization on parameter types
15:30:53 <mniip> an irc client for a game
15:31:17 <mjrosenb> is there any module that can decode ISO-8859 from a ByteStream?
15:31:18 <tdammers> also, it happens on 32-bit GHC 7.4, but not 64-bit 7.6, for some reason
15:31:21 <erisco> f is also  (Num a) => a -> a|String|Char   for instance
15:31:27 <Fuuzetsu> mniip: how does one execute such a search?
15:31:52 <mniip> Fuuzetsu, I had to abuse the 'from=' query-string parameter of the profile page
15:34:08 <mniip> ah, the long-time-ago september of 2012
15:34:12 <mniip> https://github.com/mniip/xsTPTIRC/commit/1959d09b64d5f3478312248848ffcf03e566bf4f
15:34:26 <erisco> *shrug* pm me once you make this extension
15:37:47 <erisco> heh, amusingly this would make closed function overloading possible
15:38:18 <erisco> well, the return type is too general actually
15:38:52 <erisco> or may be too general, depends on what's up
15:39:29 <platz> arkeet: thanks, I also had to remove any explicit imports from the base libs, but after that the explicit import Prelude worked
15:39:56 <arkeet> platz: the reason that works is
15:40:03 <arkeet> if you explicitly import stuff that's already in Prelude
15:40:15 <arkeet> putting that at the end makes it not import Prelude first by default.
15:40:22 <tdammers> looks like LBS.length gets string length, not the byte count
15:40:28 <arkeet> and chances are it's not redundant because you're probably using something else from Prelude anyway.
15:41:18 <platz> arkeet: ah, i see, well thanks for your help
15:41:28 * hackagebot aws-kinesis 0.1.5 - Bindings for Amazon Kinesis  http://hackage.haskell.org/package/aws-kinesis-0.1.5 (larsk)
15:50:04 <ericson> new to haskell, but about to have a short unemployment break so figured this is a good change to learn :)
15:50:25 <Axman6> excellent choice
15:50:32 <mjrosenb> does filter on a Maybe have a name?
15:50:49 <Fuuzetsu> ‘filter on Maybe’
15:51:06 <Fuuzetsu> :t maybes
15:51:07 <lambdabot>     Not in scope: ‘maybes’
15:51:07 <lambdabot>     Perhaps you meant ‘maybe’ (imported from Data.Maybe)
15:51:18 <Fuuzetsu> :t catMaybes
15:51:19 <lambdabot> [Maybe a] -> [a]
15:51:23 <Axman6> mjrosenb: what type are you looking for?
15:51:44 <mmachenry> ericson: Witha name like yours, you should try Erlang :-P
15:52:16 <mjrosenb> (a -> Bool) -> a -> Maybe a
15:52:20 <mmachenry> ericson: But no really, welcome to #haskell. Have you found Learn You A Haskell for Great Good yet?
15:52:48 <ericson> thanks
15:52:57 <ericson> no I haven't, what's that?
15:52:57 <Fuuzetsu> that doesn't seem like a very useful function mjrosenb
15:53:15 <Yaniel> @where lyah
15:53:16 <lambdabot> http://www.learnyouahaskell.com/
15:53:18 <Fuuzetsu> :t Just . filter
15:53:19 <Axman6> t guard
15:53:19 <lambdabot> (a -> Bool) -> Maybe ([a] -> [a])
15:53:23 <mmachenry> ericson: It's the most popular book to recommend to new Haskell programmers. It's freely available on line and it's pretty good.
15:53:26 <Axman6> :t guard
15:53:27 <lambdabot> Alternative f => Bool -> f ()
15:53:35 <mmachenry> There's the link for you.
15:53:39 <Fuuzetsu> :t \p -> Just . filter p
15:53:41 <lambdabot> (a -> Bool) -> [a] -> Maybe [a]
15:53:43 <Axman6> :t \x -> x >>= guard
15:53:44 <Fuuzetsu> bah
15:53:44 <lambdabot> (Monad m, Alternative m) => m Bool -> m ()
15:53:58 <Axman6> :t \f x -> x >>= guard . f
15:53:59 <lambdabot> (Monad m, Alternative m) => (a -> Bool) -> m a -> m ()
15:54:35 <Fuuzetsu> unless it's meant to be just a map of Nothing/Just based on False/True
15:56:29 * hackagebot pinboard 0.6.1 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.1 (jonschoning)
15:57:06 <ericson> learn you sounds like an icelandic accent for some reason when I read it out loud
15:57:48 <erisco> :t sequence :: [Maybe a] -> Maybe [a]
15:57:49 <lambdabot> [Maybe a] -> Maybe [a]
15:57:58 <erisco> :t catMaybes
15:57:59 <lambdabot> [Maybe a] -> [a]
15:58:12 <erisco> yeah okay :)
16:01:50 <m0rphism> mjrosenb: the closest thing I can think of is find
16:01:55 <m0rphism> :t Data.Foldable.find
16:01:56 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
16:02:00 <m0rphism> with t = Identity
16:02:02 <m0rphism> ;)
16:02:41 <shachaf> :t findOf id
16:02:42 <m0rphism> but this requires an annoying newtype wrapper so I'd rather implement it by hand
16:02:43 <lambdabot> (s -> Bool) -> s -> Maybe s
16:02:44 <arkeet> :t (F.find .) . Identity
16:02:45 <lambdabot>     Couldn't match type ‘Identity a2’ with ‘a -> a1 -> Bool’
16:02:45 <lambdabot>     Expected type: a2 -> a -> a1 -> Bool
16:02:45 <lambdabot>       Actual type: a2 -> Identity a2
16:02:49 <arkeet> oh.
16:02:51 <arkeet> thanks shachaf 
16:02:55 <m0rphism> lovely :)
16:03:20 <arkeet> :t (F.find .) . (Identity .)
16:03:20 <lambdabot>     Couldn't match type ‘Identity a2’ with ‘a1 -> Bool’
16:03:21 <lambdabot>     Expected type: a2 -> a1 -> Bool
16:03:21 <lambdabot>       Actual type: a2 -> Identity a2
16:03:23 <arkeet> no I'll stop.
16:03:36 <m0rphism> :3
16:04:04 <erisco> how can I have ghc look for modules in the local dir? can I supply a config file of sorts?
16:04:11 <m0rphism> shachaf: from which module/package is that? default hoogle search is empty
16:04:16 <shachaf> lens
16:04:20 <m0rphism> ahh, thanks :)
16:04:28 <Fuuzetsu> erisco: -i whateverdiryouwant?
16:04:33 <shachaf> :t (. Identity) . F.find -- arkeet: hth
16:04:34 <lambdabot> (a -> Bool) -> a -> Maybe a
16:04:37 <arkeet> :t (. Identity) . F.find
16:04:38 <lambdabot> (a -> Bool) -> a -> Maybe a
16:04:40 <arkeet> yeah.
16:04:45 <m0rphism> success :D
16:04:46 <shachaf> Not recommended.
16:05:03 <erisco> Fuuzetsu is there an option other than a flag?
16:05:20 <erisco> will ghc recognize a cabal package? maybe I can configure it that way?
16:05:34 <Fuuzetsu> what do you actually want to achieve
16:05:44 <erisco> just what I said
16:05:53 <Fuuzetsu> where does cabal come in then?
16:05:58 <arkeet> I'd rather use findOf id yeah.
16:06:09 <erisco> it comes in as an option
16:06:11 <jellie> Fuuzetsu: Can I make two different commits as two different pull requests?
16:06:28 <shachaf> I'd rather use neither.
16:06:33 <Fuuzetsu> jellie: uh, yes, put them on two different branches but why are you asking me?
16:06:39 <arkeet> :t neither
16:06:40 <lambdabot>     Not in scope: ‘neither’
16:06:40 <lambdabot>     Perhaps you meant ‘either’ (imported from Data.Either)
16:07:03 <jellie> Fuuzetsu: I hadn't realised that I'd hit send on that.
16:07:11 <shachaf> How about [x | f x]
16:07:16 <shachaf> With MonadComprehensions
16:07:24 <jellie> I didn't mean to ask you personally. I didn't even mean to ask in this channel.
16:07:32 <Fuuzetsu> well now you know
16:07:33 <shachaf> Or guard (f x) >> return x
16:08:03 <shachaf> i,i [ap (|) f]
16:08:14 <shachaf> I mean [ap (|) f x]
16:08:35 <arkeet> [] . ap (|) f
16:08:47 <erisco> okay, it wants the file name to match the module name
16:09:24 <arkeet> shachaf: why is the Foldable1 instance for NonEmpty so slow?
16:09:56 <shachaf> arkeet: Is it?
16:09:59 <arkeet> yes.
16:10:34 <arkeet> it builds up and destroys a bunch of NonEmptys as it goes.
16:10:55 <shachaf> NonEmpty is a bit of a scow. Consing onto NonEmpty requires two allocations. :-(
16:11:20 <arkeet> and unconsing requires one.
16:11:29 * hackagebot pinboard 0.6.2 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.2 (jonschoning)
16:11:30 <shachaf> Yes.
16:11:53 <arkeet> it would be better if it was defined as data NonEmpty a = One a | a :| Nonempty a
16:12:12 <arkeet> or as Cofree Maybe
16:12:31 <shachaf> The other day we were talking about defining it as a newtype around [] with a smart constructor.
16:12:35 <arkeet> or that.
16:12:38 <shachaf> Just so you don't get overhead going back and forth.
16:12:57 <shachaf> But you break compatibility with all these things.
16:13:05 <arkeet> such as?
16:13:08 <Fuuzetsu> version numbers exist
16:13:32 <shachaf> such as?
16:13:42 <arkeet> what does it break compatibility with?
16:13:43 <shachaf> I mean, all these proposals for a new NonEmpty.
16:13:50 <shachaf> Anything that uses (:|) to pattern-match.
16:13:54 <arkeet> pattern synonyms.
16:14:00 <shachaf> Non-exhaustive patterns.
16:14:12 <karshan> why does > Data.Attoparsec.ByteString.parse takeByteString "asd" == Partial _ ? but Data.Attoparsec.ByteString.Lazy.parse takeByteString "asd" == Done "" "asd"
16:14:18 <shachaf> I started porting NonEmpty to a newtype around [] with a pattern synonym.
16:14:19 <arkeet> surely there's a way aruond it.
16:14:22 <shachaf> Then I remembered -Wall.
16:14:23 <arkeet> around.
16:14:28 <shachaf> If there is, you should tell me about it.
16:15:20 <arkeet> explicitly bidirectional pattern synonyms.
16:15:52 <arkeet> corner off that pattern into its own module with -fno-warn-incomplete-patterns or whatever it was.
16:16:06 <shachaf> That works/
16:16:10 <shachaf> s/.$/?/
16:16:11 <arkeet> I don't know.
16:16:28 <amf> how do i get the version of ghc programatically?
16:16:29 <shachaf> You can have my half-converted NonEmpty.hs if you want to try it.
16:16:34 <arkeet> sure.
16:16:38 <mgsloan> I don't think explicitly bidirectional pattern synonyms are implemeneted yet :(
16:16:42 <arkeet> correct.
16:16:46 <amf> oh its in System.Info
16:16:46 <arkeet> #8581 is still open.
16:16:54 <shachaf> amf: System.Info
16:17:14 <Gurkenglas> I have a want for (class Wrapped a b where  :: b -> a) (where  be bijective) and all the instance declarations so you don't have to write unwrapSomething or getSomething or runSomething everywhere.
16:17:30 <arkeet> Gurkenglas: lens has that.
16:17:39 <arkeet> well,
16:17:41 <arkeet> not quite.
16:17:45 <arkeet> but it has a class called Wrapped.
16:18:00 <arkeet> but it doesn't do the same thing.
16:18:12 <mgsloan> arkeet: Yeah.  Any idea if they'll be in 7.12?  I was literally just looking into this, and then saw this IRC conversation.  Strangely coincidence!f
16:18:27 <arkeet> mgsloan: https://ghc.haskell.org/trac/ghc/ticket/8581
16:18:36 <shachaf> mgshelloan
16:18:40 <mpickering> I'm pretty sure they are in..? they were in HEAD for ages before 7.10 was cut
16:18:44 <arkeet> a comment from 
16:18:47 <mgsloan> hichaf!
16:18:48 <arkeet> ust a few minutes ago.
16:18:51 <arkeet> oops, I hit ctrl-j somehow.
16:19:06 <arkeet> well, we can try it now.
16:19:10 <arkeet> I don't have 7.10 installed though.
16:19:24 <arkeet> but 7.8 compatibility is probably desirable anyways.
16:19:26 <mpickering> yes, they work just fine
16:19:32 <arkeet> cool.
16:19:42 <mpickering> there's pattern synonym signatures as well
16:20:03 <mgsloan> Very cool!
16:20:22 <mpickering> Not the only thing missing from the release notes
16:20:26 <shachaf> I think if I seriously wanted to use NonEmpty I'd define my own type that breaks compatibility.
16:20:36 <mpickering> I wonder what other goodies slipped their way in
16:20:38 <shachaf> The existing approach has too much overhead.
16:20:56 <arkeet> shachaf: I mean disabling the warning for compatibility.
16:21:30 * hackagebot pinboard 0.6.2.1 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.2.1 (jonschoning)
16:24:37 <ttt_fff> is there any haskell library which comes close to sha256sum (the native linux binary) in terms of speed for computing sha256 sums?
16:25:03 <shachaf> I'd just use a C implementation.
16:25:06 <newsham> ?hoogle ifM
16:25:08 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
16:25:08 <lambdabot> Foreign.C.Error throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
16:25:08 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
16:25:21 <newsham> ?hoogle Monad m => m Bool -> m a -> m a -> m a
16:25:21 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:25:21 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
16:25:21 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:25:28 <newsham> :(
16:25:32 <ttt_fff> shachaf: as in System.IO.execute ("sha256sum <filename>") ?
16:25:57 <shachaf> As in foreign import
16:26:10 <shachaf> It probably exists somewhere on Hackage.
16:26:40 <ttt_fff> shachaf: http://hackage.haskell.org/package/cryptohash-0.7.6/docs/src/Crypto-Hash-SHA256.html looks like a foreign C impl ?
16:26:47 <shachaf> So does https://hackage.haskell.org/package/SHA2
16:30:05 <mgsloan> Hrmm hsenv doesn't seem to work with GHC 7.10.  Has anyone tried that?  https://gist.github.com/mgsloan/6eb77382be523ad04137
16:31:30 * hackagebot simple-smt 0.5.5 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.5 (IavorDiatchki)
16:32:18 <dgorbik> hm
16:32:28 <mpickering> I think I've heard people use it with 7.10
16:32:33 <mpickering> that's not a great data point, I admit
16:33:20 <mgsloan> Yeah, seems like people would notice hsenv not working quite rapidly, so must be some local issue..
16:33:32 <arkeet> shachaf: oh I see the problem now.
16:33:59 <arkeet> the warning would happen at the use site of (:|)
16:34:04 <shachaf> Yes.
16:34:24 <shachaf> I thought you knew some clever trick that involved hiding the warning at the definition of the synonym.
16:34:31 <arkeet> oh, no.
16:34:50 <arkeet> I think we need explicit bidirectional for that.
16:35:01 <arkeet> wait maybe not even that does it.
16:35:15 <arkeet> okay, I give up.
16:35:20 <shachaf> I ran into some other issues with pattern synonyms and exhaustivity.
16:35:42 <shachaf> You might think that defining a one-way pattern synonym that expands to a view pattern that can't fail wouldn't warn.
16:35:46 <shachaf> But it can.
16:36:09 <arkeet> is the warning correct?
16:36:23 <shachaf> I don't think so.
16:36:31 <arkeet> is there a ghc bug for it?
16:36:37 <shachaf> I don't know.
16:36:50 <arkeet> you should change the answer to "yes", then.
16:36:59 <arkeet> one way or another.
16:37:16 <shachaf> arkeet: you should file the bug so the answer will be yes twh
16:37:25 <arkeet> twh?
16:38:09 <lightandlight> What consideration should be made before publishing a library?
16:38:20 <lightandlight> Obviously you need to test and document the code
16:38:47 <lightandlight> Are there any performance considerations or benchmarks that should be run?
16:38:52 <Maxdamantus> compilation is a form of testing.
16:42:05 <godel> how can I put a typeclass when I define a data that takes arguments?   For example          data (Eq a) => Set a = ...
16:42:44 <shachaf> You can't.
16:42:49 <geekosaur> that doesn't do what you'd hope, so it doesn't allow that
16:43:01 <geekosaur> if you use GADTs instead then you can make it work
16:43:03 <godel> geekosaur: what do you mean?
16:43:06 <Maxdamantus> godel: the class doesn't know about the argument in that case.
16:43:23 <godel> I can simply put   f :: Eq a => ....
16:43:31 <godel> if a funcion f uses == or /=
16:43:37 <godel> but that seems unconvenient
16:43:45 <Maxdamantus> er, nvm, thinking of s/data/instance/
16:43:54 <geekosaur> yes, you want that to come into scope automatically. that is what does *not* happen
16:44:00 <geekosaur> unless you use GADTs
16:44:10 <godel> geekosaur: I do not follow
16:44:24 <shachaf> The feature geekosaur is talking about comes with ExistentialQuantification, no GADTs required.
16:44:58 <godel> ok
16:45:03 <benzrf> is there a diagonalize function in data list
16:45:11 <hyPiRion> Is there any easy way in Attoparsec to match on end of chunk (not endOfInput)?
16:45:11 <shachaf> You can define data Foo a = K a => T a | K a => S a
16:45:18 <shachaf> Or something like that
16:45:24 <shachaf> But you shouldn't use it for this.
16:45:52 <mgsloan> For readers of the archive: I figured out how to fix my hsenv.  "rm .hsenv/ghc_pkg_db/package.cache; cp .hsenv/ghc/lib/ghc-7.10.1/package.conf.d/package.cache .hsenv/ghc_pkg_db/package.cache"
16:46:07 <mgsloan> I have no idea why I needed to do that, but it works now
16:55:10 <nitrix> Hi, I have a conflict with Parsec's <|> and Prelude Functor's <
16:55:21 <nitrix> I mean, Applicative's <|>
16:55:26 <glguy> hide one of them
16:55:32 <glguy> hiding ((<|>))
16:55:45 <nitrix> It's still slightly retarded, isn't it ?
16:55:57 <nitrix> Why would Parsec introduce its own ?
16:59:00 <glguy> Because it was their idea back around 1999/2000 when they defined it
16:59:42 <nitrix> Really? So Applicatives came after?
16:59:53 <nitrix> Or at least, that combinator?
17:00:29 <glguy> Applicative appear in base around late 2005
17:00:38 <nitrix> Oh ;o
17:00:44 <nitrix> glguy: Thanks man.
17:01:20 <nitrix> glguy: I've seen you before, I think on ##c. Funny the roles are inverted (:
17:01:49 <glguy> Might have been someone else. I don't think I've been on ##c before (though it's possible that I've forgotten)
17:02:09 <reem> Why hasn't Parsec just removed their version?
17:02:25 <nitrix> reem: Backwards compatibility I assume?
17:02:46 <reem> they haven't had a breaking release in 10 years?
17:02:57 <nitrix> Though, in Haskell's interest, I'd say it's worth breaking compatibility.
17:03:02 <shachaf> Why doesn't Parsec reëxport Alternative's (<|>)?
17:03:21 <solinent> hi there, I was marshalling data to a PixelData OpenGL struct, and found that pokeArray was way slower than just using a Data.Vector.Storable with unsafeWith.
17:03:30 <solinent> however,
17:03:53 <glguy> shachaf: Maybe its not very coöperative?
17:03:54 <solinent> after converting the code to Repa for parallelism, and then converting from an unboxed vector to a storable one,
17:04:18 <solinent> the data disappears slowly, seemingly being freed
17:04:33 <shachaf> glg̈uy: Maybe.
17:04:37 <solinent> is there any way I can tell OpenGL to not free it?
17:04:44 <solinent> or Data.Vector
17:05:08 <solinent> using unsafeWith to get at the contents
17:05:37 <solinent> the pointer, that is, which is passed directly to GL
17:06:01 <solinent> seemed to work before I converted to Repa, but might have been coincidence
17:06:30 <solinent> if no one has any idea, maybe just tell me what guarantees unsafeWith removes and how to tell OpenGL not to GC some data
17:06:45 <solinent> s/opengl/haskell
17:07:40 <nshepperd> parsecs (<|>) has different fixity
17:08:19 <nshepperd> so it could break code
17:08:38 <shachaf> Oh, right.
17:09:43 <Javran> I usually just use the one from Control.Applicative and hide stuff in parsec :)
17:10:58 <solinent> yeah, attoparsec doesn't define <|>, so it took me forever to figure out the exact semantics (noob alert)
17:16:34 <k-u> yay for the new 7.10 prelude including a bunch of common stuff!
17:26:23 <Big_G> Does anyone know of how to get in contact with the Seattle Haskell community?
17:26:35 <Denommus> I wish there was a Manaus Haskell community
17:30:34 <k-u> Big_G: It looks like they have a meetup page http://www.meetup.com/SEAHUG/
17:31:14 <Big_G> k-u, I joined that a while back but it still seems relatively small 
17:33:30 <caconym> Big_G: did you go to any of those meetups?
17:34:03 <caconym> Big_G: i'm also in seattle
17:34:11 <Big_G> caconym, I just got to Seattle so I haven't had a chance. I was mainly looking at the RSVP list. I figured that a tech city like Seattle might be a bit bigger
17:34:23 <shachaf> I've gone to those meetings. They were large enough.
17:34:33 <caconym> cool
17:34:35 <shachaf> There's also SeaFunc and other things.
17:35:00 <caconym> i need to get into the local scene more in general
17:35:06 <shachaf> I live pretty far from Seattle so I rarely make it.
17:35:31 <arkeet> I've been to seattle a couple times. haven't really done anything there though.
17:35:33 <Big_G> caconym, Anything I should check out?
17:35:41 <arkeet> there was a seminar or something at UW
17:35:54 <caconym> Big_G: nothing that I know of :(
17:36:09 <caconym> i'm a loner/loser compared to some of the super social coders around here
17:36:19 <caconym> would love to find a Haskell job in town though... :)
17:36:37 <Ryanar> hey all, can you guys direct me to what I am doing wrong here? I dont see why I cant concatenate these tuples together
17:36:46 <lpaste> ryanar revised “not sure what I am doing wrong”: “No title” at http://lpaste.net/129897
17:36:58 <Big_G> caconym, I'm a Java coder so I know the pain
17:37:16 <arkeet> Ryanar: missing ) ?
17:37:22 <caconym> Ryanar: ou seem to be missing a )
17:37:23 <Ryanar> arkeet, no that was there
17:37:27 <shachaf> Ryanar: I don't think "I cannot cons these elements together" is an error that GHC can print.
17:37:29 <Ryanar> arkeet, fail paste
17:37:33 <arkeet> ok, what's the error?
17:38:04 <caconym> Big_G: ha yeah i'm just writing ruby and python and getting more and more sick of it every day
17:38:25 <arkeet> ok, I can guess the error(s).
17:38:27 <Big_G> caconym, Never touched Ruby but I'd trade for Python because that at least has first order functions
17:38:40 <shachaf> I can guess the errors too, but I refuse to.
17:38:51 <caconym> Big_G: heh, yeah ruby actually does not, it's a bit of a mess
17:39:16 <caconym> Big_G: ruby has pretensions to functional design but python seems to me to be more legit
17:39:26 <Big_G> caconym, I remember hearing something about the syntax (something about telling return types from input) that scared me off for life
17:39:40 <Big_G> caconym, Yeah, decorators and generators are always nice
17:40:13 <Ryanar> error message: https://imgur.com/n8BrcvH
17:41:44 <caconym> Big_G: i gotta take off but good luck finding seattle haskellers; maybe i'll see you at a meetup sometime
17:41:56 <arkeet> Ryanar: that doesn't look anything like the errors I get.
17:41:58 <Big_G> caconym, For sure. See you then
17:42:37 * mgsloan goes to the seattle haskell meetup
17:42:45 <Javran> after getting used to Haskell, I can hardly figure out what's wrong with "a = [[0] * 10] * 10]" in python :(
17:42:46 <Big_G> shachaf, Where are you seeing SeaFunc? I can't seem to find it with the meetup search tool
17:42:57 <Big_G> mgsloan, Nice to meet you. Anything you can tell me about the Seattle scene
17:43:09 <shachaf> SeaFunc is at https://groups.yahoo.com/neo/groups/SeaFunc/info
17:43:20 <shachaf> Well. It might be dead.
17:43:33 <mgsloan> Yeah, SeaFunc is dead, Jeff got busy and Bartosz is in Italy :)
17:43:45 <Ryanar> arkeet, my bad, https://imgur.com/9a2zh62 here they are
17:43:52 <Big_G> Last updated last year
17:43:53 <eacameron> Is anyone interested in nailing this SO question down? http://stackoverflow.com/questions/28465113/when-does-the-garbage-collector-run-when-calling-haskell-exports-from-c
17:44:12 <arkeet> ok, let's read the error.
17:44:25 <arkeet> I guess line 33 in your file is line 7 in the paste.
17:44:27 <mgsloan> Big_G: Uh, dunno!  The seattle scene is good!  Our meetup group has small-ish attendance (10 to 20) but it's enthusiastic 
17:44:36 <arkeet> now it's telling you it's expecting a thing of type [Move].
17:44:43 <arkeet> but you're giving it a thing of type Move.
17:45:08 <Big_G> mgsloan, Is the scene that meetup group as far as you know? I just got a job as a Java programmer but want to learn and meet all those cool tech/people\
17:45:12 <Cale> eacameron: It already seems to be answered there?
17:45:27 <arkeet> Ryanar: in other words, you need a list of moves, not a move.
17:45:31 <Ryanar> arkeet, ack let me fix that quick, but there is still the another issue I am having
17:45:33 <eacameron> Cale: inconclusively it seems
17:45:54 <Ryanar> which is line 35/9
17:46:00 <arkeet> yes, clealry.
17:46:03 <arkeet> clearly.
17:46:06 <arkeet> one thing at a time, though.
17:46:06 <eacameron> Cale: I don't see any references to docs or anything for conformation
17:46:22 <Ryanar> arkeet, I just forgot to add hanoi 1 a b c = makeMove a b : []
17:46:24 <mgsloan> Big_G: Yeah, I dunno!  I'm not really involved in the largescale "tech scene".  I've certainly got lots of friends in industry around here, though
17:46:27 <Ryanar> arkeet, the empty list
17:46:31 <arkeet> or you could just [makeMove a b].
17:46:38 <Ryanar> arkeet, that too :P
17:46:41 <Cale> eacameron: I think chi is correct
17:46:43 <arkeet> ok, as for the next error.
17:46:50 <arkeet> I think you have also forgotten the type of (:)
17:46:51 <arkeet> :t (:)
17:46:52 <lambdabot> a -> [a] -> [a]
17:46:54 <Big_G> mgsloan, Are you not a dev then?
17:47:00 <Big_G> professionally that is
17:47:00 <Cale> eacameron: I couldn't tell you where to look for confirmation apart from the GHC source code though
17:47:19 <mgsloan> When you start looking at the larger tech scene, you're going to start getting groupthink that isn't always the most interesting ("javascript on the server! woo!")
17:47:25 <arkeet> in particular, (:) is not a thing that you can use to smash two lists together
17:47:30 <Ryanar> hm
17:47:33 <Ryanar> yeah ++
17:47:37 <Ryanar> for list concatentation
17:47:40 <arkeet> correct.
17:47:41 <Ryanar> concatenation*
17:47:48 <mgsloan> Big_G: I am, I work from home, for FP Complete
17:47:59 <arkeet> the reason it's giving that error is that
17:48:04 <arkeet> the thing on the right of : is a [Move]
17:48:08 <arkeet> so it's expecting a single Move on the left.
17:48:18 <Big_G> mgsloan, That would explain a lot. Congrats on getting a Haskell job though
17:48:36 <arkeet> but you gave it a [Move].
17:48:42 <arkeet> the error message tells all of this.
17:49:00 <Ryanar> so doing hanoi (x-1) pegA pegB pegC ++ makeMove pegA pegB : hanoi (x-1) pegA pegB pegC is what I want, [Move] ++ Move : [Move]
17:49:11 <arkeet> I guess so.
17:49:29 <Ryanar> arkeet, I swear I tried the ++ before but I must have messed something up
17:49:40 <arkeet> ++ wouldn't work in the second position.
17:49:45 <arkeet> because the thing in the middle is not a list.
17:49:52 <Ryanar> arkeet, right so I just left that as :
17:49:53 <arkeet> (you can make it a list by putting [ ] around it.)
17:50:03 <arkeet> (that would make it look more symmetric, but : is fine.)
17:50:14 <Ryanar> arkeet, would there be any efficiency difference?
17:50:36 <arkeet> I would guess that ghc is smart enough to optimize it.
17:50:45 <shachaf> arkeet: GHC doesn't even optimize reverse [] to []
17:50:47 <eacameron> Cale: well 2 votes is better than 1; I'll have to consult the source
17:50:57 <eacameron> Cale, thanks
17:51:08 <Cale> eacameron: Are you having trouble getting collections to occur?
17:51:17 <arkeet> my guesses are frequently wrong.
17:51:22 <arkeet> so don't count on me.
17:51:23 <arkeet> or ghc.
17:51:37 <Ryanar> hahahaha
17:52:27 <Cale> eacameron: There's some stuff in System.Mem (performGC especially) that you can use to force a garbage collection.
17:52:32 <eacameron> Cale: I haven't written enough of the app to know yet, but I'm trying to sell the approach to my team and that question raised doubts in my mind
17:54:54 <arkeet> Ryanar: also you should get rid of tab characters.
17:55:00 <arkeet> as Cale said in the other channel.
17:55:31 <arkeet> it's nice that -fwarn-tabs is the default now.
17:59:10 <XDodongoXLoverX> hello
18:01:23 <XDodongoXLoverX> anyone awake?
18:01:41 <Hijiri> I'm awake
18:01:45 <XDodongoXLoverX> hi
18:01:53 <Hijiri> are you here for haskell
18:02:08 <XDodongoXLoverX> Yup I have some questions, I'm new to Haskell and trying to leanr
18:02:17 <Hijiri> alright, this is the place to ask
18:02:17 <XDodongoXLoverX> can you help me?
18:02:22 <Hijiri> along with some other haskell channels that exist
18:02:29 <XDodongoXLoverX> cool thanks
18:02:32 <Axman6> XDodongoXLoverX: not if you don't ask questions! =)
18:02:47 <Hijiri> I might be able to help, and if I can't, someone else in the channel may be able to help
18:02:53 <arkeet> @where justask
18:02:53 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
18:03:03 <XDodongoXLoverX> so the IO operator
18:03:05 <XDodongoXLoverX> <-
18:03:10 <Hijiri> it's not an operator
18:03:12 <Hijiri> it's just syntax
18:03:20 <XDodongoXLoverX> ok
18:03:26 <XDodongoXLoverX> it loads an IO string into a string
18:03:27 <XDodongoXLoverX> right?
18:03:27 <k-u> mgsloan: Congrats on working at fp co! I think I've seen Aaron around here in san diego at a meetup
18:03:28 <geekosaur> andf it's also not specific to IO
18:03:28 <Hijiri> do notation desugars into uses of >>= and >>
18:03:33 <XDodongoXLoverX> like a <- IO a
18:03:36 <Hijiri> it works with any monad
18:03:44 <geekosaur> and it doesn't "load" so much as give you something that looks like it
18:03:46 <Hijiri> but specific to IO, the usage is something like that
18:04:01 <geekosaur> you're actually registering callbacks; you can't force an IO action ti produce something
18:04:06 <Hijiri> If you have do a <- ioa; morestuff
18:04:20 <Hijiri> it is exactly the same as ioa >>= \a -> morestuff
18:04:24 <geekosaur> @quote /bin/ls
18:04:25 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:04:28 <Hijiri> the compiler converts it to this when you are compiling
18:04:40 <XDodongoXLoverX> My question is, why can't I create a function like: loadCharacters :: [Character] -> [Character] loadCharacters buffer = do     character <- load "Character.txt"     character:buffer
18:04:50 <XDodongoXLoverX> sorry formatting
18:04:53 <geekosaur> because that is not in IO
18:04:57 <arkeet> that is not what <- does.
18:05:06 <arkeet> <- lets you feed the results of an IO action into another IO action.
18:05:15 <Hijiri> XDodongoXLoverX: Think of what this desugars to
18:05:17 <XDodongoXLoverX> so here
18:05:23 <geekosaur> @paste
18:05:23 <lambdabot> Haskell pastebin: http://lpaste.net/
18:05:24 <XDodongoXLoverX> character is of type IO character?
18:05:28 <arkeet> you cannot feed the results of an IO action into something that is not IO.
18:05:30 <XDodongoXLoverX> not character?
18:05:30 <Hijiri> it desugars to load "Character.txt" >>= \character -> character:buffer
18:05:33 <EvanR> <- lets you create a new IO action from an old IO action using a function
18:05:45 <Hijiri> Which is a problem, because the right of >>= must be of form a -> IO b
18:05:49 <Hijiri> (the type)
18:05:57 <Hijiri> \character -> character:buffer is not that
18:06:07 <Hijiri> at best, it is of type Char -> [Char]
18:06:22 <Hijiri> which is not IO anything
18:06:43 <Hijiri> Even if it was IO something, your entire do block would be type IO something
18:06:53 <Hijiri> and then your type signature [Character] -> [Character] would be wrong
18:07:16 <XDodongoXLoverX> so why is it in code examples like: main = do       contents <- getContents       putStr (map toUpper contents)  
18:07:20 <XDodongoXLoverX> content is used like a string
18:07:26 <arkeet> contents *is* a string.
18:07:29 <Hijiri> contents is a String
18:07:33 <arkeet> but it cannot be used for anything outside an IO action.
18:07:35 <geekosaur> note that main's type is IO a
18:07:36 <EvanR> List Char is a box of zero or more Chars. IO Char is a box with a button that, when pressed, causes who-knows-what effects, and some times later may output a Char ;)
18:07:45 <Hijiri> the problem is the type of main, and what comes after the contents <- getContents
18:07:48 <arkeet> putStr (map toUpper contents) has type IO ()
18:07:49 <geekosaur> the IO there is important; it's what lets you use IO actiobns
18:08:01 <XDodongoXLoverX> ah ok so it's main that allows them to do that?
18:08:04 <XDodongoXLoverX> because main is IO
18:08:08 <XDodongoXLoverX> but a pure function is not
18:08:23 <arkeet> main is an IO action. you can define other IO actions just fine.
18:08:24 <Hijiri> main isn't a function at all
18:08:29 <arkeet> but all execution of IO actions happens via mainl.
18:08:31 <arkeet> main.*
18:08:34 <EvanR> main isn't a function, and all functions are pure
18:08:36 <XDodongoXLoverX> I see
18:08:51 <randir> try in Control.Excepiton takes an IO a, is there any way to try a function that isn't of type IO, but might throw exceptions?
18:09:03 <nshepperd> that thing is the same as 'main = getContents >>= (\contents -> putStr (map toUpper contents))'
18:09:04 <EvanR> randir: error "oh no"
18:09:24 <EvanR> oh misread
18:09:29 <EvanR> randir: evaluate
18:09:33 <Hijiri> you can "try" it up to WHNF in evaluate
18:09:41 <arkeet> XDodongoXLoverX: I recommend reading this if you haven't already. https://wiki.haskell.org/Introduction_to_IO
18:09:49 <arkeet> (and perhaps reading it again if you have.)
18:10:05 <XDodongoXLoverX> thanks =)
18:10:24 <randir> EvanR: So evaluate, and wrap that inside of try?
18:10:43 <EvanR> randir: thatll work if evaluating to WHNF will trigger the error
18:11:31 <EvanR> randir: usually you want to avoid pure computations that throw exceptions that you want to catch
18:11:43 <randir> What does WHNF stand for?
18:11:48 <EvanR> weak head normal form
18:12:12 <shachaf> @google WHNF
18:12:13 <lambdabot> http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
18:12:13 <lambdabot> Title: definition - Haskell: What is Weak Head Normal Form? - Stack Overflow
18:13:15 <EvanR> let ones = 1:ones in ones would evaluate to 1:ones, not 1:1:ones or 1:1:1:1...
18:13:52 <Hijiri> does ghc literally transform do notation into lambdas, >>=, and >>, or does it transform the AST representation of do notation into the AST representation some applications of bind and lambdas
18:13:57 <randir> Cool 
18:14:14 <EvanR> randir: so an error after the 4th one would go unnoticed by evaluate
18:14:14 <randir> EvanR: Okay, well, I'll just make my function IO then, to be a bit cleaner
18:14:28 <EvanR> randir: if its throwing IO errors, good idea
18:15:34 <Cale> Hijiri: The latter -- do expressions are part of the abstract syntax exposed by Template Haskell for instance.
18:15:41 <geekosaur> there's a compiler flag that shows the result of the rewrites; I was under the impression the AST doesn't have a way to represent e.g. do notation
18:16:04 <Cale> err
18:16:05 <Cale> hm
18:16:31 <Cale> do-expressions don't exist in Core
18:16:38 <Cale> So by that point, they're all gone.
18:17:32 <geekosaur> yes, but I think there's an internal representation before Core? at the very least, the intermediate after things like do desugaring and converting multiple equations to case, etc.
18:17:36 <shachaf> do expressions aren't translated into lambdas in the first place.
18:17:41 <geekosaur> but I don;'t know if that is text or an AST
18:17:58 <Cale> That isn't text
18:22:45 <randir> Is there a simpler way to write this? 
18:22:48 <Cale> The parser spits out an HsModule RdrName
18:22:51 <randir> x <- foo 
18:22:58 <randir> case x of ...
18:23:02 <randir> where foo :: IO ()
18:23:10 <Hijiri> maybe >>= plus lambda cases
18:23:25 <Hijiri> wait, if foo is IO (), isn't x always ()?
18:23:38 <randir> ah, IO a
18:23:46 <randir> was just doing for illustration 
18:24:06 <Hijiri> then >>= plus lambda cases, or if your a has a destructor function you can use that
18:24:13 <Hijiri> I don't know if they're called destructors
18:24:27 <Hijiri> scott representations
18:24:28 <randir> It's not any issue in my code, I'm just curious
18:24:33 <Cale> and that in turn ends up using the HsExpr type which has an explicit constructor HsDo for representing do-syntax
18:24:36 <geekosaur> so LambdaCase extension
18:24:55 <geekosaur> foo >>= \case ...
18:24:56 <_ryan> hi  everyone does anyone here knows about the keter.
18:24:59 <_ryan> hi  everyone does anyone here knows about the keter?
18:25:37 <geekosaur> hm. is there a yesod channel?
18:25:39 <shachaf> @where yesod probably does.
18:25:40 <lambdabot> Web Framework - #yesod - <http://yesodweb.com/>,<http://www.yesodweb.com/page/quickstart>,<http://www.yesodweb.com/book>
18:26:24 <_ryan> yes but. not very active like this
18:27:02 <randir> geekosaur: Thanks, that's cool.
18:27:11 <Cale> _ryan: Do you have a specific question about it?
18:27:12 <glguy> _Ryan: unless you're actually interested in surveying if people know about a topic, it's best to just ask your actual question
18:27:17 <shachaf> Yes, but the people who know about your thing will be there, not here.
18:27:36 <_ryan> yes
18:27:40 <shachaf> i,i https://en.wikipedia.org/wiki/Streetlight_effect
18:28:26 <_ryan> I encounter this error: Error occured when launching bundle Main: Codec.Compression.Zlib: incorrect header   - when i put my keter bundle file on /opt/keter/incoming dir
18:29:07 <randir> what's the easiest way to wrap a "read" statement in a maybe?
18:29:15 <arkeet> use readMaybe.
18:29:19 <randir> ah, just found that
18:29:19 <_ryan> i also post my error on yesod channel.. :-) i just to get the possible feedback on my error
18:31:25 <_ryan> Cale: I encounter this error: Error occured when launching bundle Main: Codec.Compression.Zlib: incorrect header   - when i put my keter bundle file on /opt/keter/incoming dir
18:32:21 <_ryan> shachaf: yes i also post my problem there i just want to know is someone would help me i this channel
18:33:16 <Cale> _ryan: Yeah, I dunno. I would start by checking that the zlib package was properly installed
18:33:43 <_ryan> Cale how do i do that? :-)
18:33:49 <Cale> It's a binding to the corresponding C library, so perhaps the error is referring to the C header
18:34:15 <Cale> Do you have your distribution's development package for zlib installed?
18:34:24 <fresheyeball_> hello out there
18:34:33 <fresheyeball_> Anyone know how to use FPcomplete?
18:34:41 <glguy> I interpreted that as meaning that the library tried to decompress a file that didn't have the right zlib format
18:34:53 <glguy> Rather than the c header file
18:34:54 <c_wraith> fresheyeball_: I find web browsers work well.
18:35:07 <fresheyeball_> haha, me too
18:35:27 <fresheyeball_> c_wraith: I'm having troubling getting any dependencies to install
18:35:45 <fresheyeball_> I just want Wreq
18:36:00 <fresheyeball_> but it been days I've failed to get it to install
18:36:05 <fresheyeball_> its on Stackage
18:36:24 <fresheyeball_> do I need to abandon FPComplete just because of a dependency?
18:36:33 <fresheyeball_> or do you think there is a way to make it work?
18:36:36 <c_wraith> fresheyeball_: Oh.  I never dealt with that.  I only used the tutorial writing tools, which don't allow installing dependencies.
18:37:00 <_ryan> Cale: i don't know still new to this keter, but i use the FP Complete IDE so I jsut Download it there. the IDE give me the the tar.gz file
18:37:35 <_ryan> glguy: what do you mean?
18:37:37 <Cale> _ryan: I've never used keter or the FP Complete IDE
18:38:18 <arkeet> _ryan: he means it's some file that zlib doesn't know how to decompress or something.
18:38:20 <_ryan> Cale: i mean my yesod project, i made it using FP Completer IDE.
18:38:35 <arkeet> have you checked if your .tar.gz file works?
18:39:14 <_ryan> yes i decompress it using this code tar xf Main.tar.gz
18:39:16 <fresheyeball_> _ryan: you use FPcomplete IDE locally?
18:39:39 <_ryan> nope.. its an online IDE for Yesod Haskel Developer.
18:39:47 <fresheyeball_> right
18:39:55 <fresheyeball_> it has yesod pre-installed
18:40:02 <fresheyeball_> but apparently no http clients
18:40:04 <fresheyeball_> of any kind
18:40:07 <fresheyeball_> other than http-client 
18:40:17 <fresheyeball_> which is intended as a base for higher level libs
18:40:21 <fresheyeball_> not used directly
18:40:31 <arkeet> no http-conduit?
18:40:40 <fresheyeball_> http-conduit is there
18:40:47 <fresheyeball_> but it seems over complicated to just make a get request
18:40:52 <arkeet> it is?
18:40:57 <fresheyeball_> perhaps I am wrong about that?
18:41:06 <arkeet> it has simpleHttp :: MonadIO m => String -> m ByteString
18:41:25 <arkeet> that's about as simple as you can get.
18:41:53 <fresheyeball_> they documentation
18:42:02 <fresheyeball_> says do not use simple http in production
18:42:39 <_ryan> what does it mean?
18:42:48 <arkeet> well, it has another example.
18:42:51 <arkeet> which seems fairly simple to me.
18:42:53 <fresheyeball_> Network.Wreq or Network.Http.Client (not HTTP.Client) are ideal for my needs
18:43:08 <fresheyeball_> ok
18:43:15 <arkeet> well, up to you.
18:44:37 <platz> i used http-streams without too many issues; it's not done in a flexible monad transformer style, but i gather that was the point
18:44:51 <platz> I'd probably choose http-client going forward though
18:45:00 <fresheyeball_> ok, well if I have to learn http conduits now just to use fpcomplete
18:45:41 <fresheyeball_> isn't http-client too low level?
18:46:24 <platz> idk, i certainly see it being used in the libs i've taken a peek at, such as network api's
18:46:38 <_ryan> arkeet: if i decompress it uing the - tar xf Main.tar.gz then that means my *.tar.gz file is correct?
18:46:55 <fresheyeball_> hu, lame
18:47:01 <fresheyeball_> just lame
18:47:09 <platz> why?
18:47:17 <arkeet> _ryan: I don't actually know whether that file is the problem, or really anything about keter.
18:48:36 <_ryan> Cale: how do i check if my development package for zlib installed?
18:50:16 <Cale> _ryan: Which distribution are you using?
18:50:32 <arkeet> I'm going to side with glguy on this one.
18:51:16 <Cale> Oh, well, glguy may very well be correct, that's actually very likely
18:51:22 <Cale> I hadn't seen his response before
18:51:54 <_ryan> glguy also has a point. but i don't know how to resolve it. hahahaha
18:52:33 <_ryan> Cale: can you give me example of distribution you're talking about?
18:52:48 <Cale> Ubuntu?
18:53:19 <Cale> _ryan: Or are you on Windows?
18:53:24 <Cale> Or Mac OS X?
18:53:32 <_ryan> yes Ubuntu
18:54:27 <Cale> Then you'd probably  apt-get install zlib1g-dev  but I agree with glguy now.
18:54:47 <Cale> That this probably isn't the issue, and that message looks more like a complaint from the decompressor
18:55:15 <Cale> that it was asked to decompress something which wasn't a valid zlib compressed file
18:55:25 <jmcarthur> does anybody know of any writings on how gc does or does not affect asymptotic complexity?
18:55:36 <akishi> Morning Haskellers
18:55:39 <glguy> Shesh, you send a message to chat and go to eat dinner and leave your phone at your desk on vibrate on the thing just goes off over and over
18:55:40 <jmcarthur> (i think does)
18:56:49 <shachaf> jmcarthur: I guess you mean time complexity? :-)
18:57:02 <Cale> glguy: heh, do you have your phone set to ring when someone highlights you in chat?
18:57:26 <glguy> Cale: it vibrates if I forget and leave the client running, yes
18:59:38 <jmcarthur> shachaf: err, yes, that i do :)
18:59:53 <enthropy> Athas: you can configure with --with-ghc=ghc-7.4.1 -- or whatever one you want to use
19:00:11 <shachaf> jmcarthur: Do you mean other than the time GC itself takes, or including that?
19:00:20 <_ryan> Cale: i'll already installed it.
19:00:22 <shachaf> I think the answer can depend a lot on your GC.
19:00:23 <enthropy> nevermind I was scrolled up
19:01:20 <Cale> _ryan: Yeah, okay, I'm pretty sure glguy was right anyway
19:01:55 <Cale> _ryan: It's just that somehow keter tried to decompress something which wasn't properly compressed
19:02:19 <_ryan> Cale How do i properly compress in Ubuntu?
19:02:53 <Cale> _ryan: Well, I'm not sure knowing that is going to help
19:02:54 <_ryan> Cale: i used this for compressing - tar cvf Main.keter ./Main config/ static/
19:03:08 <glguy> -z compresses
19:03:08 <Cale> Oh, you actually compressed something?
19:03:09 <Cale> hmm
19:03:16 <arkeet> there's no compression happening there.
19:03:36 <Cale> Uh, yeah, that just creates a tar, not a gzipped tar
19:03:46 <arkeet> maybe you want tar czvf
19:03:49 <shachaf> jmcarthur: I guess I should ask what you're comparing.
19:04:30 <arkeet> and then complain at keter's author that it should give a better error message.
19:04:40 <jmcarthur> shachaf: i mean, for example, the slowdown you end up with due to gc as a data structure grows, etc. i think there are some obvious intuitions about it, of course, but a data structure i'm implementing with amortized constant time operations is scaling a bit worse than another data structure that also has amortized constant time operations as they get bigger, and i'm wondering if something about it is making
19:04:42 <jmcarthur> the gc a bit worse (i haven't yet actually just compared gc times, but was just hoping somebody knew of some reading material)
19:05:20 <jmcarthur> shachaf: by "slightly worse" i mean i see a very very slight curve
19:05:57 <shachaf> jmcarthur: Is this public code?
19:07:57 <jmcarthur> shachaf: it's not a secret or anything, but it's not something i think is worth explaining in detail for this question anyway. it's a catenable steque i've constructed, benchmarking against some of the operations it shares with Data.Sequence.
19:08:18 <randir> how can I make my own data type be able to be incremented, in a cycle? I seem to remember there being some sort of ordering I could derive that did it automatically 
19:08:21 <jmcarthur> shachaf: this one is very similar to a banker's queue
19:08:38 <randir> like data foo = A | B | C | D (deriving ----)
19:08:56 <jmcarthur> shachaf: but also involves implicit recursive slowdown
19:08:59 <randir> and then increment A would be B, and increment D would be A
19:09:16 <tromp> deriving (Eq,Ord,Enum,Bounded)
19:09:31 <tromp> might as well throw in (Read,Show)
19:09:47 <shachaf> Everyone's doing these steque things these days.
19:10:11 <jmcarthur> well i had an idea i had to try!
19:10:24 <randir> tromp: thanks. 
19:10:44 <jmcarthur> and it's overall working out great, except that it gets slower than i would like for large numbers of elements
19:10:55 <jmcarthur> just a little...
19:11:31 <randir> tromp: where is the increment function located? I thought it was in prelude, but can't find it
19:12:06 <tromp> @hoogle succ
19:12:08 <lambdabot> Prelude succ :: Enum a => a -> a
19:12:08 <lambdabot> Test.QuickCheck.Property succeeded :: Result
19:12:08 <lambdabot> Test.QuickCheck.Test success :: State -> IO ()
19:12:26 <newsham> blah, using records in ADTs creates partial-functions for record accessors
19:12:36 <newsham> not super safe
19:12:49 <jmcarthur> newsham: yeah it's gross
19:12:49 <shachaf> newsham: Not great.
19:12:59 <randir> ahh, ty, Thought it was "inc" or something
19:12:59 <shachaf> lens's TH will derive safe traversals for you.
19:13:45 <newsham> seems the "best" way to encode alternative record structures is to separate out the records from the alternations... which is.. tedious
19:15:09 <erisco> data X s = X { ..., otherXStuff :: s }    is this a good time to make a class instead?
19:15:54 <shachaf> jmcarthur: It sounded like you were talking about comparing similar algorithms implemented with or without GC, but maybe that's not your question.
19:18:04 <HeladoDeBrownie> erisco, not enough information
19:18:14 <HeladoDeBrownie> erisco, guess: probably not
19:18:31 <HeladoDeBrownie> (usually "probably not" is a good guess for that question)
19:18:49 <jmcarthur> shachaf: sort of. i guess it's just how to reason about the gc, asymptotically speaking, when thinking about persistent data structures.
19:19:47 <erisco> like, I will run into the diamond problem this way
19:19:52 <shachaf> I wonder how well persistent data structures work without GC.
19:19:55 <erisco> it is emulating single inheritance
19:20:29 <jmcarthur> you mean ignoring that you run out of memory really quickly?
19:21:04 <shachaf> I mean in a language without GC.
19:21:38 <Hijiri> Rust has no GC for some things
19:21:53 <Hijiri> but I know Box and the other managed memory has reference counting
19:22:42 <newsham> I wish I could put annotation on record fields and use TH to auto-generate instances based on those record attributes
19:22:46 <newsham> annotations
19:22:58 <shachaf> If you use reference counting you need to mutate memory to copy.
19:23:45 <jmcarthur> ah, yes
19:25:11 <shachaf> Anyway, the big thing about GC is that you pay for live objects, rather than for dead objects.
19:25:52 <randir> tromp: How can I make succ loop around?
19:26:03 <randir> right now I get "tried to take `succ' of last tag in enumeration
19:26:03 <randir> "
19:26:21 <EvanR> but but that would break the Enum laws
19:26:22 <arkeet> don't use succ.
19:26:25 <EvanR> if there were any
19:26:51 <arkeet> you can write your own thing that checks whether something is equal to maxBound.
19:26:58 <arkeet> :t \x -> if x == maxBound then minBound else succ x
19:26:59 <lambdabot> (Bounded a, Enum a, Eq a) => a -> a
19:27:11 <arkeet> > iterate (\x -> if x == maxBound then minBound else succ x) LT
19:27:12 <lambdabot>  [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,...
19:27:20 <EvanR> then it only works for Bounded
19:27:24 <arkeet> of course.
19:27:50 <tromp> > cycle [minBound..maxBound] :: [Ord]
19:27:52 <lambdabot>      Expecting one more argument to ‘Ord’
19:27:52 <lambdabot>      Expected kind ‘*’, but ‘Ord’ has kind ‘* → Constraint’
19:27:52 <lambdabot>      In an expression type signature: [Ord]
19:27:54 <arkeet> > iterate (\x -> if x == maxBound then minBound else succ x) (2147483645 :: Int32)
19:27:56 <tromp> :t LT
19:27:56 <lambdabot>  [2147483645,2147483646,2147483647,-2147483648,-2147483647,-2147483646,-21474...
19:27:57 <lambdabot> Ordering
19:28:01 <randir> okay, thanks
19:28:02 <tromp> > cycle [minBound..maxBound] :: [Ordering]
19:28:03 <lambdabot>  [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,...
19:28:20 <arkeet> you can do that as well, depending on what exactly you want to do with it.
19:28:26 <HeladoDeBrownie> that's a poorly worded error message for that. even if Ord had another argument it'd be the wrong kind.
19:29:07 <arkeet> > (id :: Int -> Int) :: Bool
19:29:08 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Int → Int’
19:29:09 <lambdabot>      In the expression: (id ∷ Int -> Int) ∷ Bool
19:29:32 <arkeet> > not (id :: Int -> Int)
19:29:33 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Int → Int’
19:29:33 <lambdabot>      In the first argument of ‘not’, namely ‘(id ∷ Int -> Int)’
19:29:33 <lambdabot>      In the expression: not (id ∷ Int -> Int)
19:29:36 <arkeet> ok.
19:30:37 <HeladoDeBrownie> arkeet, wrong level of abstraction; Int -> Int :: *, and so does the argument to not.
19:30:42 <HeladoDeBrownie> so, different problem.
19:30:55 <arkeet> HeladoDeBrownie: yes, I was comparing type error messages to kind error messages.
19:31:02 <HeladoDeBrownie> i see.
19:31:40 * hackagebot pinboard 0.6.2.2 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.2.2 (jonschoning)
19:31:42 * hackagebot arion 0.1.0.7 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.7 (karun012)
19:36:15 <EvanR> is haskell-db alive and working? and useful?
19:36:28 <jmcarthur> shachaf: i think my data structure should be a little more memory efficient that Data.Sequence. however, it occurs to me that more of my allocations might be promoted from the nursery.
19:37:15 <jmcarthur> *than
19:37:37 <jmcarthur> i'm also not *totally* sure of my claim about memory efficiency
19:38:30 <ttt_fff> two questions: (1) can I send BINARY data in a HTTP POST request? and (2) if so, how can I do this with Scotty on the backend ?
19:39:07 <jmcarthur> shachaf: btw, a simple banker's queue vs. Data.Sequence seems to exhibit the same pattern
19:39:26 <jmcarthur> shachaf: banker's queue is faster at small sizes, but Data.Sequence wins for larger ones
19:39:31 <EvanR> ttt_fff: BINARY?
19:39:40 <ttt_fff> EvanR: yeah, like 0 and 1
19:39:42 <EvanR> you can send any data via a post
19:39:49 <ttt_fff> whoa
19:39:51 <EvanR> even infinite!
19:39:53 <ttt_fff> it doesn't ahve to be text/ascii ?
19:39:55 <jmcarthur> shachaf: the benchmark is to perform a large number of rotations (pop from one end and push to the other)
19:40:12 <EvanR> ttt_fff: no
19:40:28 <ttt_fff> EvanR: great, 2nd part: how od I do it via https://hackage.haskell.org/package/scotty-0.4.6/docs/Web-Scotty.html ?
19:40:29 <pleiosaur> Hijiri: rust's `Box` type is like C++'s uniq_ptr, it doesn't need any reference counting to work
19:40:39 <ttt_fff> err, https://hackage.haskell.org/package/scotty
19:40:41 <ttt_fff> I'm using latest scotty
19:40:45 <EvanR> i havent used scotty
19:43:19 <shachaf> jmcarthur: I need to go for a bit, but it could be interesting to see your benchmark, if you can @paste it or something.
19:44:00 <jmcarthur> shachaf: right now i suspect that i'm just doing operations that are too big all at once. i'm gonna try breaking them into smaller pieces
19:44:20 <jmcarthur> shachaf: that is, i think i might be allocating too much at a time
19:46:54 <nshepperd> jmcarthur: thing that might or not be relevant - the simplest banker's queue is not necessarily O(1) if used persistently, due to laziness
19:47:21 <nshepperd> iirc
19:47:36 <fozworth> i'd like to gauge interest in a package i'm working on. it tries to provide better operators for function application and composition. would anyone use it? https://hackage.haskell.org/package/overture-0.0.2/docs/Overture.html
19:48:31 <nshepperd> er, it's not due to laziness. but yes, persistence
19:48:33 <jmcarthur> nshepperd: the kind i'm talking about it. it starts a suspended rotation when the front is shorter than the back and then only forces it after everything in the former front has been consumed
19:48:42 <nshepperd> ah, right
19:49:20 <EvanR> fozworth: so a prelude skin
19:49:29 <fozworth> yes, a very thin one
19:49:46 <EvanR> i didnt really like the names they used in clojure
19:49:51 <EvanR> like identity, compose
19:49:56 <EvanR> too long
19:50:08 <fozworth> i agree that "compose" is too long
19:50:18 <fozworth> i wouldn't ever really use it over ".>" or "<."
19:50:29 <fozworth> but i prefer having function versions of operators
19:50:42 <EvanR> . corresponds with the one in math
19:50:49 <`szx> EvanR: isn't it "comp"?
19:50:54 <jmcarthur> i take back my claims about memory efficiency. i'm using more bytes with this than Data.Sequence. maybe i can get some speedup by working on memory
19:50:54 <EvanR> .>
19:51:00 <`szx> in clojure, I mean
19:51:02 <EvanR> `szx: oh right
19:51:05 <EvanR> still
19:51:18 <fozworth> . is like math, yes. but even so i usually get confused about which way it's supposed to go
19:52:07 <fozworth> and you end up reading things backwards. "f . g" means "do g, then do f", which is the opposite of how you normally read
19:52:23 <EvanR> well, not when youre reading composition of functions
19:52:45 <ski> "`f' after `g'"
19:52:45 <fozworth> sure, you have to switch your brain into function composition reading mode
19:52:45 <EvanR> f(g(x))
19:53:01 <EvanR> fozworth: from what?
19:53:10 <fozworth> from reading normal expressions mode
19:53:15 <fozworth> "f x y z" goes left-to-right
19:53:21 <fozworth> "f . g . h" goes right-to-left
19:53:29 <EvanR> does f x y z goes left to right? in what sense
19:53:38 <ski> fozworth : how about `f (g x) (h y z)' ?
19:53:59 <fozworth> ski: still left to right, with parens for sub-expressions
19:54:30 <ski> i'm not sure i see why it wouldn't be "inside-to-outside"
19:54:30 <fozworth> "f x y z" means "apply x, y, and z to f", so i guess you could argue that it's not completely left-to-right
19:54:34 <EvanR> (((f x) y) z) is a tree
19:54:41 <EvanR> im not sure what direction it goes
19:55:05 * ski applies functions to arguments ..
19:55:06 <jmcarthur> fozworth: at least as ghc compiles it, in "f . g . h", f goes first
19:55:29 <jmcarthur> well, actually, (.) does, but i'm ignoring that
19:55:43 <fozworth> i understand how haskell parses, in general
19:55:49 <jmcarthur> this isn't about parsing
19:55:56 <fozworth> and i know that composition and pointfree and typically idiomatic
19:55:57 <jmcarthur> i'm talking about evaluation
19:56:06 <fozworth> i am interested in changing the idioms
19:56:22 <fozworth> because i think that "f .> g .> h" is easier to grok than "h . g . f"
19:56:25 <EvanR> i think youre confused about order of operations
19:56:50 <jmcarthur> fozworth: i'm just saying that there is a very meaningful sense in which  f . g . h  is actually best understood left-to-right
19:56:55 <fozworth> EvanR: how so?
19:57:23 <EvanR> in haskell foo.x.y.z is not like ruby or java
19:57:26 <ski> (anyway, the order in `f . g' comes from `\x -> f (g x)' .. and the reason why the function/operator expression comes before the argument/operand expression is probably partly because the latter is more commonly a large expression than the former. and it can be nicer to read a definition if the first identifier in it is the one that is being defined)
19:57:36 <fozworth> EvanR: i know
19:57:44 <jmcarthur> fozworth: f possibly demands a result from g, g possibly demands a result from h, h possibly demands its argument
19:58:13 <EvanR> actually jmcarthur's description is making it sound more like ruby/java ;)
19:58:22 <jmcarthur> EvanR: wha-?
19:58:24 <EvanR> in which case you want to keep it the way it is
19:58:40 <fozworth> ok, i know why "f . g" is the way that it is. i know what it does. i use it and understand it
19:58:56 <fozworth> that being said, i think that "g .> f" make more sense. does anyone agree?
19:59:02 <EvanR> no
19:59:08 <fozworth> (where ".>" is read as "and then")
19:59:21 <EvanR> (g .> f) x ?
19:59:22 <jmcarthur> fozworth: i disagree. (by the way, Control.Arrow.>>> already exists)
19:59:43 <EvanR> in the spirit of making it all backwards wouldnt you also want reverse application
19:59:56 <EvanR> x $> (g .> f)
19:59:57 <fozworth> jmcarthur: i'm aware of that. it's from Control.Category too. they always feel too visually heavyweight 
20:00:00 <jmcarthur> fozworth: this notion of "and then" is what i'm arguing against
20:00:09 <fozworth> EvanR: that's exactly it
20:00:13 <fozworth> although i have |> instead of $>
20:00:14 <EvanR> >_>
20:00:29 <EvanR> well theres already operators for reversing things
20:00:36 <fozworth> h x = x |> g .> f === h = f . g
20:00:36 <k-u> There is (&) in lens which is flipped (.)
20:00:45 <fozworth> k-u: yes, and that's in the prelude now
20:00:46 <jmcarthur> fozworth: "f . g" can be read "f, and then perhaps g (and then back to f, and then perhaps back to g, etc.)"
20:00:50 <EvanR> :t (4)
20:00:51 <fozworth> it's actually flipped ($)
20:00:51 <lambdabot> Num a => a
20:00:52 <EvanR> :t (&)
20:00:53 <lambdabot> a -> (a -> b) -> b
20:01:00 <k-u> ah 
20:01:01 * ski . o O ( s/===/<=>/ )
20:01:21 <fozworth> jmcarthur: i'm not sure i understand
20:01:41 <jmcarthur> fozworth: ghc's evaluation strategy gives f control first, not g
20:01:44 <EvanR> @src (.)
20:01:44 <lambdabot> (f . g) x = f (g x)
20:01:45 <fozworth> "f = succ . recip" means "f x = 1 + (1 / x)"
20:01:49 <EvanR> f, then g
20:01:53 <EvanR> maybe
20:02:13 <jmcarthur> > (const "foo" . error "nope") ()   -- fozworth 
20:02:15 <lambdabot>  "foo"
20:02:28 <jmcarthur> fozworth: if g had gotten control first, that would have failed
20:03:02 <jmcarthur> > () & error "nope" >>> const "foo"
20:03:04 <lambdabot>      Precedence parsing error
20:03:04 <lambdabot>          cannot mix ‘&’ [infixl 1] and ‘>>>’ [infixr 1] in the same infix exp...
20:03:08 <jmcarthur> > () & (error "nope" >>> const "foo")
20:03:09 <lambdabot>  "foo"
20:03:13 <fozworth> jmcarthur: ok, i think i get that
20:03:19 <jmcarthur> fozworth: ^^^ does that really read well?
20:03:28 <fozworth> in my parlance i'd have this: "error "nope" .> const "foo" <| ()"
20:03:37 <fozworth> although i wouldn't really write it as such
20:03:48 <fozworth> () |> error "nope" .> const "foo"
20:03:53 <EvanR> the left to right reading doesnt help much when the left stuff might not even matter
20:03:57 <jmcarthur> > error "nope" & const "foo"
20:03:59 <lambdabot>  "foo"
20:04:07 <Hijiri> :t flip id
20:04:08 <lambdabot> b -> (b -> c) -> c
20:04:09 <fozworth> it might not matter, but it usually does
20:04:15 <EvanR> does it?
20:04:15 <jmcarthur> why
20:04:27 <fozworth> most of the time you're not composing with const
20:04:39 <EvanR> i use lazy evaluation
20:04:46 <jmcarthur> const is just an example. there are tons of functions not strict in every argument
20:05:13 <EvanR> even if you eventually need something doesnt mean you should get it or think of it being gotten right now
20:05:22 <EvanR> since it might cause an infinite loop
20:05:36 <fozworth> ok, i wasn't counting on getting into strictness here
20:05:51 <jmcarthur> i think a stronger argument could be made for   flip ($!)   than for   flip ($)
20:06:06 <fozworth> i have flip ($!) as (!>)
20:06:18 <jmcarthur> that i think actually seems reasonable
20:06:28 <fozworth> undefined |> const True -- True
20:06:37 <fozworth> undefined !> const True -- *** Exception: Prelude.undefined
20:06:48 <EvanR> im confused by both, just because its out of the ordinary
20:07:01 <fozworth> would you be confused by "undefined & const True" ?
20:07:02 <jmcarthur> yeah, i also agree with EvanR. i just don't think it's as crazy
20:07:13 <jmcarthur> fozworth: i would!
20:07:24 <fozworth> i would too, that's why i wanted to make this
20:07:24 <EvanR> fozworth: yeah, i dont like &
20:07:39 <fozworth> do you think "$" is a better sigil for function application?
20:07:48 <EvanR> yeah
20:07:50 <fozworth> "$>" instead of "|>" (both meaning the same as "&")
20:07:53 <jmcarthur> undefined |> const True  seems just as bad as  undefined & const True  to mee
20:08:14 <fozworth> to me the arrow shows the direction and the sigil before it shows the action
20:08:24 <jmcarthur> but the directionality is a lie
20:08:26 <fozworth> ".>" = compose forward, "|>" = pipe (apply) forward
20:08:27 <EvanR> but im still not clear about what direction were talking about
20:08:42 <fozworth> ok, let's see if i can explain it
20:09:00 <fozworth> "(+ 1) .> (* 2)" means (to me) "add one, and then multiply by two"
20:09:10 <fozworth> same as "(* 2) . (+ 1)"
20:09:11 <jmcarthur> to be clear, i understand why you see directionality there. i'm just trying to show why it's not such a useful notion.
20:09:34 <jmcarthur> you see some sort of dataflow-ish directionality
20:09:39 <EvanR> fozworth: but in general the right hand function will be applied first
20:09:44 <fozworth> i get that haskell's non-strictness makes it less useful than in other languages
20:09:59 <fozworth> but yes, i'm looking at it more as the direction the data is going in
20:10:00 <jmcarthur> not only less useful. misleading.
20:10:28 <EvanR> in eager mode all this might make sense
20:10:34 <EvanR> -XStrict
20:11:03 <fozworth> y'all have certainly given me some food for thought
20:12:08 <fozworth> i had always thought that functions composed backwards, and it drove me nuts with stuff like this https://github.com/bmillwood/pointfree/pull/9/files#diff-c8290f1597d6ea55d0e892cc7a4d1ac2R31
20:12:25 <L8D> is there a type for representing and/or?
20:12:36 <L8D> and if not, what's a good name for one?
20:12:57 <EvanR> fozworth: the notation f o g for composition followed directly from f(g(...))
20:13:03 <jmcarthur> L8D: what do you mean? in what way would it represent and/or?
20:13:14 <jmcarthur> L8D: do you mean something like the Any and All monoids?
20:13:25 <EvanR> so if f(g(h(... is backwards, then f(x) is backwards, which it i guess is in dataflow style
20:13:27 <L8D> jmcarthur: Something a b = One a | Other b | Both a b
20:13:33 <jmcarthur> ah
20:13:53 <jmcarthur> L8D: i don't know of a standard one, but do occasionally want that type
20:14:05 <L8D> jmcarthur: what's a good name for one?
20:14:11 <fozworth> amusingly i don't see f(g(h(...))) as backwards
20:14:16 <EvanR> me neither
20:14:20 <fozworth> the parens make all the difference for me
20:14:29 <EvanR> they are composed
20:14:36 <fozworth> i get that
20:14:41 <EvanR> forwards ;)
20:15:09 <fozworth> it's just that i often find myself with some value that i want to apply a series of transformations to
20:15:13 <arkeet> it would all be forwards if we agreed to write function application like (x)f
20:15:24 <fozworth> the idiomatic haskell way to do that is a pointfree expression using function composition
20:15:32 <arkeet> fozworth: well, you can define some operator, x & f = f x
20:15:33 <EvanR> thats appropriate called reverse polish notation ;)
20:15:38 <fozworth> but i think of it as "take this value, do thing X, then thing Y, etc."
20:15:50 <fozworth> arkeet: yeah, it's in the prelude now and from lens before that
20:15:55 <arkeet> oh, it's in prelude now?
20:15:57 <arkeet> neat.
20:15:59 <fozworth> i don't think & is easy to grok
20:16:05 <EvanR> me neither
20:16:07 <arkeet> take x, and do f, and then do g, etc.
20:16:09 <fozworth> i like |> (or $>) instead
20:16:10 <arkeet> x & f & g etc.
20:16:24 <jmcarthur> i am sad that it's in the prelude. i do not look forward to it becoming more pervasive.
20:16:41 <arkeet> (&) is a pretty reasonable thing to pass to higher order functions.
20:16:57 <EvanR> fozworth: in f(g(h(...))) you should think of it as "doing something f" to "doing something g" to "doing something h" to ...
20:17:02 <arkeet> :t liftA2 (&)
20:17:03 <lambdabot> Applicative f => f a -> f (a -> c) -> f c
20:17:26 <arkeet> :t map . (&)
20:17:27 <lambdabot> a -> [a -> b] -> [b]
20:17:52 <dolio> What? Is that a 7.12 change?
20:18:10 <jmcarthur> i wonder if there is anything interesting here:   newtype Foo f r a = Foo (f (a -> r) -> f r)
20:20:50 <ski> EvanR : `A -> B' is backwards :)
20:21:09 <fozworth> so we had a vote for ($>) over (|>)... what about for the strict version (!>)? ($!>)?
20:21:15 <jmcarthur> ski is channeling richard bird right now
20:22:02 <fozworth> ($!>) probably makes the most sense because ($!) is in the prelude
20:22:19 * ski has sometimes defined `($>)' ..
20:23:02 <shachaf> jmcarthur: https://hackage.haskell.org/package/kan-extensions-4.2/docs/Data-Functor-Kan-Rift.html
20:23:03 <jmcarthur> ski: but i'm guessing that was   ($>) :: Functor f => f a -> b -> f b   ?
20:23:35 <shachaf> jmcarthur: Wait, you don't have a forall.
20:23:46 <jmcarthur> right
20:23:50 <fozworth> oh, right. i knew there was a reason why i didn't go with (<$) and ($>)
20:23:51 <dolio> shachaf: That just means he did it wrong. :)
20:23:54 <shachaf> Maybe it's related but that makes it a very different type.
20:24:03 <jmcarthur> dolio: :(
20:24:11 <shachaf> dolio: Wrong like ContT?
20:24:17 <dolio> Yep.
20:24:42 <jmcarthur> what's wrong with ContT?
20:24:45 <ski> jmcarthur : no. `flip ($)'
20:24:58 <jmcarthur> ski: ew :P
20:25:14 <shachaf> Presumably the fact that it's not Codensity.
20:25:20 <ski> (mostly this was years ago. way before that other `($>)' was invented)
20:25:31 <jmcarthur> ah
20:25:40 <fozworth> ski: i like that, but it conflicts with Data.Functor and/or Control.Applicative
20:25:56 <dolio> ContT is just some ad-hoc stuff for doing call/cc and whatnot, not a nice pure mathematical thing.
20:26:04 <dolio> Obviously.
20:26:06 <fozworth> i'm doing my best not to clobber other operators
20:26:07 * ski also conflicts with some of the name choices in `Control.Applicative'
20:27:24 <dolio> I wonder if the rift versions of (co)density have names, or if the categorists didn't bother.
20:27:39 <dolio> Lift versions, even.
20:29:34 <HeladoDeBrownie> does @djinn not understand forall?
20:29:55 <dolio> Not in any useful way.
20:30:09 <HeladoDeBrownie> kay, thanks.
20:30:32 <dolio> It's based on a solver for propositional logic, which doesn't involve quantifiers.
20:31:00 <dolio> And predicate logic (with quantifiers) isn't similarly decidable, so it'd be a lot harder to write.
20:31:42 <Hijiri> just have djinn simulate a human brain
20:31:57 <Fuuzetsu> those never make mistakes or take long to do stuff
20:32:00 <Fuuzetsu> wait…
20:32:35 <Xe> it's times like this that make me believe that a channel I'm in about spirituality / magick / metaphysics makes more sense than #haskell 
20:34:22 <shachaf> Which channel?
20:34:40 <Fuuzetsu> that description can only fit #haskell-blah
20:34:51 <Xe> shachaf: on another network
20:34:59 <Cale> Hijiri: It would actually be really interesting to see how well HTM/CLA would do at writing lambda calculus terms.
20:35:55 <donnior> close
20:36:43 * hackagebot scalpel 0.1.2 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.1.2 (fimad)
20:41:19 <xplat> dolio: you could always go with opdensity and coopdensity (bane of chickens)
20:45:26 <Cale> Sounds like an item from Dungeons of Dredmor
20:47:46 <jle`> I think you don't gain too much by just trying to fit haskell style to fit the intuition you've acquired from other languages just-because, not not because they were actually more expressive or helpful
20:48:34 * EvanR attempts to double negate that message
20:49:07 <arkeet> L8D: sorry for being late.
20:49:17 <arkeet> the "these" package provides such a type, called These.
20:49:45 <xplat> jle`: not that i can't understand your message, but what weren't you trying not to say?
20:49:49 <jle`> oops I'm on my phone. autocorrect abounds
20:49:53 <jle`> v.v
20:49:54 <arkeet> and it also comes with the observation that Maybe (These a b) ~ (Maybe a, Maybe b)
20:50:12 <jle`> s/not not/and not
21:08:49 <kyfho> does haskell have anything like hypertable?
21:08:58 <kyfho> or hadoop hbase?
21:09:12 <kyfho> I see happstack has acidstate, but forget if that works accross nodes
21:09:21 <Xe> if that is a turing complete operation, then you can do it in haskell
21:09:25 <kyfho> it seems in memory user space networked cluster databases are the future
21:09:49 <kyfho> hyptertable is a free version of googles bigtable
21:09:54 <EvanR> acid state works across the network but the entire database value must fit in memory of whatever its running on
21:10:01 <EvanR> its not "sharded"
21:10:09 <kyfho> ok, I meant accross say 100 nodes
21:10:16 <kyfho> and keep global state
21:10:22 <EvanR> good luck with that
21:10:28 <kyfho> cassandra in shudderr   java kinda does it
21:10:40 <kyfho> www.hypertable.org too
21:11:02 <kyfho> I always wonder why no one ever seemed to apply a bewulf cluster to fast website serving
21:11:10 <kyfho> beowulf
21:11:18 <kyfho> there was some library called openMPI
21:11:27 <EvanR> for serving websites, there are content distribution networks
21:11:28 <kyfho> open message passing interface..
21:11:40 <kyfho> cdn are just big cache
21:11:44 <EvanR> indeed
21:11:51 <EvanR> websites are just static files
21:12:06 <Big_G> Do monoids have to be commutative or just associative?
21:12:13 <EvanR> just associative
21:12:25 <kyfho> is haskell really more fun? than smalltalk or lisp or prolog?
21:12:37 <EvanR> more functional?
21:12:39 <kyfho> it seems nice from a distance
21:12:49 <kyfho> more fun to program in
21:12:54 <KaneTW> i find it more fun
21:12:59 <kyfho> why
21:13:13 <KaneTW> errors are compile-time, so getting working code is faster
21:13:34 <EvanR> Big_G: example monoid which is not commutative, the list concat monoid with empty list as mempty
21:13:37 <KaneTW> code seems prettier (really subjective measure, but still makes it more fun for me)
21:13:54 <kyfho> could you write something like the world of warcraft or eve online in haskell?
21:13:58 <Big_G> EvanR, That was what I thought. Just wanted to make sure
21:14:07 <kyfho> eve is stackless pythonand  wow is I dunno plus lua
21:14:21 <KaneTW> sure you could
21:14:25 <solirc> I'm puzzled if haskell-src-exts provides equality under alpha-conversion for type signatures?
21:14:28 <EvanR> kyfho: theres #haskell-game for questions like that
21:14:54 <EvanR> kyfho: on the scale of fun, lua is very low imo
21:15:05 <KaneTW> yeah i find lua very unfun
21:18:11 <caconym> lua seems a lot like javascript in the grand scheme of things
21:18:15 <caconym> and javascript is also very unfun
21:18:36 <EvanR> at least javascript has map
21:18:45 <EvanR> lua has iterators
21:18:55 <StoneCypher> javascript doesn't actually have map yet
21:19:02 <EvanR> ive used map in js for years
21:19:02 <StoneCypher> it will as of es6 and a lot of people get it early from shims
21:19:05 <EvanR> screw ie6
21:19:12 <StoneCypher> ok.
21:19:20 <scott> Big_G: a good example of a non-commutative Monoid is [a]
21:19:29 <k-u> haha
21:19:57 <StoneCypher> EvanR: unless you mean .map?
21:20:03 <EvanR> yeah .map on arrays
21:20:05 <StoneCypher> oh.
21:20:14 <StoneCypher> i thought you meant actual map.
21:20:19 <EvanR> no
21:20:23 <StoneCypher> ok, tat's es5
21:20:28 <scott> Big_G: oh, I missed that someone already mentioned that, sorry
21:21:46 * hackagebot base-prelude 0.1.18 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.18 (NikitaVolkov)
21:21:47 <caconym> well it's not like you can't have map in lua if you really want it :)
21:21:59 <caconym> but yeah it's not in the base package or whatever iirc
21:22:07 <scott> Lua gives you a really small base to build on
21:22:15 <Xe> ^
21:22:25 <EvanR> i got the idea that anything but iterators would be bad performance, but maybe i should have ignored that
21:22:26 <scott> everyone develops their own incompatible implementation of classes/objects and so on...
21:22:47 <EvanR> i found composition of iterators impossible
21:30:46 <carter> EvanR: iterators are just a lack of decent reified "handles" for locations
21:35:09 <yuung> could someone help me understand this relatively simple haskell snippet? http://pastebin.com/aFbjqdTP
21:35:49 <yuung> I don't understand how it returns a pair, when in the else statement it seems to return a single value
21:36:48 <caconym> yuung: don't both clauses of the top-level if statement contain a 2-tuple?
21:36:49 <KaneTW> the else statement is a tuple
21:36:58 <yuung> oh wow
21:37:05 <caconym> yuung: the second one, it's on multiple lines
21:37:05 <yuung> lolz.  true
21:37:10 <k-u> yeah, see that comma
21:37:37 <yuung> caconym, KaneTW, i see now XD  thanks.  i'll probably be back with a different question about the same piece, but that's a little clearer now
21:37:57 <caconym> yuung: glad to help!
21:40:39 <srid> does `let` have different semantics in the REPL (ghci)?
21:40:55 <srid> i mean you could `let a = 3`, and continue to refer to a in subsequent expressions.
21:41:12 <yuung> ^ that's another question i had - in the book i'm reading, it says let must end with 'in'.  but in the repl, i can say let a = 3 and it's fine
21:41:17 <scott> ghci acts a bit like it's all in a `do`
21:41:36 <caconym> yeah, more or less "in the IO monad" if I understand it correctly
21:41:46 <scott> `s <- getLine` will work, too
21:41:47 * hackagebot overture 0.0.3 - An alternative to some of the Prelude.  http://hackage.haskell.org/package/overture-0.0.3 (fozworth)
21:41:48 <caconym> and in do-notation, you can use let in that way without a corresponding `in`
21:41:57 * srid is still working through https://wiki.haskell.org/A_brief_introduction_to_Haskell#Functions
21:42:29 <scott> `let a = 3` isn't an expression, but it's valid syntax in a `do`
21:42:30 <mniip> ghci will also print the result of execution of IO (expcept for IO ())
21:42:57 <scott> `let a = 3 in a + 1` is an expression
21:43:13 <arkeet> mniip: and for IO a when a doesn't have a Show instance.
22:18:51 <lpaste> echo-area pasted “case semantic” at http://lpaste.net/129906
22:19:08 <echo-area> The above is semantically equivalent to the below, right?
22:20:01 <arkeet> sure, although it will never reach the _ patterns.
22:20:34 <echo-area> Thank you.
22:21:24 <arkeet> but of course it's all equivalent to 2.
22:22:20 <echo-area> Yes.  I am learning the evaluation model, so the intermediate form is important :)
22:23:18 <echo-area> That result is constructed by applying formal semantics of pattern matching
22:26:11 <arkeet> I can't imagine where the lambdas would come from. idk
22:27:05 <mniip> 'T a b c -> (\...) a b c' seems like a rather sane transformation
22:27:12 <mniip> probably compiles into something nic
22:27:13 <mniip> e
22:27:41 <mniip> ah
22:27:50 <mniip> echo-area is probably trying to avoid bindings
22:28:02 <mniip> unfortunately that's barely possible in haskell
22:28:19 <arkeet> gotta do the same for binding the argument of T then.
22:28:50 <echo-area> arkeet: It's from rule (j): case v of { x -> e } = (\ x -> e) v
22:29:01 <arkeet> I don't know what rule (j) is.
22:29:13 <mniip> doesn't work very well if there are multiple things in the case
22:29:17 <arkeet> and yeah.
22:29:26 <mniip> or
22:29:30 <mniip> if there are where-bindings
22:29:55 <echo-area> arkeet: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17  It's in Fiture 3.2
22:30:13 <echo-area> *Figure
22:30:24 <mniip> case Identity 1 of Identity a -> b where b = a 
22:31:13 <arkeet> presumably x is a variable.
22:31:23 <echo-area> Yes, x is a variable
22:31:28 <arkeet> as opposed to a pattern.
22:31:32 <arkeet> that is not a variable.
22:32:32 <echo-area> mniip: What do you mean by avoiding bindings?
22:33:39 <mniip> echo-area, why are you performing such a transformation
22:36:50 <echo-area> I was trying to understand how to evaluate case expressions in the call-by-need style.  I had trouble explaining a value constructed by `data`, so I ended up consulting the report and constructed such a transformation
22:36:57 <Heffalump> in a cabal package with a test suite, is there a way of having data files that are just for the test suite? data-files appears to only live at the top-level of a cabal file.
22:38:34 <srid> `data Height = Tall | Medium | Short deriving Show` <-- the "deriving Show" part automatically generates some magic Show function?
22:39:13 <Axman6> yes
22:39:45 <caconym> srid: it automatically generates a `Show` instance for Height
22:40:01 <pacak> :info Show
22:40:04 <pacak> >info Show
22:40:07 <echo-area> mniip: `T a b c -> (\...) a b c`  <--  Is (\...) here the function T :: a -> b -> c -> T a b c ?
22:40:14 <srid> k. just reading through https://wiki.haskell.org/A_brief_introduction_to_Haskell so i can start writing haskell programs fast. will look into details later.
22:40:20 <pacak> Hmmm... Lazy lambdabot.
22:40:26 <mniip> echo-area, no
22:40:36 <echo-area> What is it?
22:40:38 <ski> @src Show
22:40:39 <lambdabot> class  Show a  where
22:40:41 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:40:43 <lambdabot>     show      :: a   -> String
22:40:47 <lambdabot>     showList  :: [a] -> ShowS
22:41:11 <mniip> you turned 'case ... of (a, b) -> ...' into 'case ... of (,) a b -> (\...) a b'
22:41:29 <caconym> srid: do you have experience in other functional languages? if not, it may be worth taking your time learning Haskell :)
22:41:30 <srid> btw, any programming theory book recommended to understand the concepts used in Haskell? (i have scheme/clojure background)
22:41:43 <srid> caconym: i do :) which is why i found books boring
22:42:11 <srid> my style of learning = study through 'quick' tutorials, hack hack hack, study in detail using books, etc.
22:42:29 <ski> srid : perhaps TaPL ? PFDS could also be interesting
22:42:39 <srid> @google TaPL
22:42:43 <ski> @where TaPL
22:42:46 <lambdabot> http://www.tapl.org/
22:42:46 <lambdabot> Title: Tulsa Association of Professional Landmen, | Tulsa, Oklahoma
22:42:46 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
22:42:50 <srid> heh
22:43:28 <srid> got it
22:44:13 <srid> i wonder when the 2nd edition of "Practical Foundations for Programming Languages" will be out
22:44:41 <srid> here's a draft: http://www.cs.cmu.edu/~rwh/plbook/2nded.pdf
22:45:43 <ski> ("Purely Functional Data Structures" by Chris Okasaki was the other book)
22:45:47 <caconym> srid: perhaps this might be a good resource: http://dev.stephendiehl.com/hask/
22:46:01 <caconym> oh yeah, okasaki is great
22:47:31 <srid> where do the 'little schemer' (and reasoned/seasoned sequels) book stand in relation to the above books?
22:48:31 <caconym> srid: the texts that cover the basic theory underlying Haskell tend to not be Haskell-specific, from my observation
22:48:39 <echo-area> mniip: So the (\...) function can be only used in a case expression?
22:48:42 <caconym> srid: so that may be a difference
22:49:05 <srid> echo-area: everything, including anonymous functions, are expressions.
22:49:29 <srid> 1 + (\x -> x+x) 3
22:50:58 <echo-area> Hmm, I must be missing some points, I'll come back to this later on
22:51:14 <ski> > 1 + (\x -> x+x) 3
22:51:15 <lambdabot>  7
22:52:35 <ski> srid : if you're looking for a more basic Haskell textbook, you could try "Haskell: The Craft of Functional Programming"
22:52:50 <srid> 'more basic' as in?
22:52:57 <ski> (TaPL is about types and type systems. PFDS is about immutable data structures)
22:53:16 <ski> as in basic programming concepts in Haskell
22:53:54 <echo-area> ski: What's PFDS?
22:53:57 <ski> (like "Little Schemer" is a basic book .. not that the style of it is very similar to the Craft, though ..)
22:53:59 <srid> k
22:54:04 <ski> <ski> ("Purely Functional Data Structures" by Chris Okasaki was the other book)
22:54:08 <caconym> echo-area: Okasaki? Purely Functional Data Structures
22:54:14 <caconym> it's a really great book
22:54:59 <ski> PFDS uses SML (Standard ML, one of the MLs. the other main one is O'Caml). has corresponding Haskell code in the appendix, though
22:56:23 <caconym> srid: Real World Haskell is nice, as it gets into practical applications while providing examples and it's available online
22:56:37 <srid> yea i plan to use that as reference when writing real world apps
22:57:01 <caconym> srid: i consider it to be useful also for learning the core techniques that you'll need to get basically anything done
22:57:14 <caconym> srid: particularly the use and implementation of monads and monad transformer stacks
22:57:21 <srid> hmm ok
22:57:25 <caconym> srid: I got a lot out of the corresponding sections when I was learning
22:57:25 <ski> if you haven't seen it yet, you might also try <http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html>
22:58:12 <caconym> srid: the ubiquity of monads and "do-notation" may be one of the biggest differences between writing lisp and writing Haskell
22:58:35 <caconym> srid: not that I know much about lisps :(
22:59:04 <ski> `do'-notation is just syntactic sugar. you can think of it as a macro that provides somewhat more convenient notation for some cases, which gets translated back to more basic/primitive code
22:59:18 <srid> don't think Haskellers miss anything from lisp (except maybe macros)
22:59:39 <ski> first-class continuations in Scheme is interesting
22:59:54 <ski> (one can do continuations via a monad, though)
23:00:43 * srid gets to the section on monads
23:00:55 <mniip> monads are like burritos
23:01:40 <shachaf> mniip: Stop it.
23:01:51 <mniip> okay :(
23:01:52 <caconym> no no i fiiiiinally get it now!
23:02:10 * srid doesn't eat carbs.
23:12:18 <ttt_fff> i ran Crypto.Hash.Sha256.Hash and got a bytestring
23:12:24 <ttt_fff> how do I convert it to something ascii-like
23:13:24 <srid> damn, https://wiki.haskell.org/A_brief_introduction_to_Haskell#Mutable_variables_2 is not complete
23:14:32 <caconym> srid: who needs mutable variables? you should probably ignore those things for now
23:14:47 <srid> k, thumbing through RWH
23:16:22 <caconym> srid: incidentally, the Okasaki book is a great look at how to implement efficient data structures without mutable variables
23:17:33 <jle`> who needs mutable variables
23:20:23 <Cale> Well, those package names are a good start
23:20:50 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html -- you can find the documentation for them here
23:20:59 <Cale> Data.IORef is pretty simple, especially
23:24:38 <srid> "A Gentle Introduction To Haskell" -- is this tutorial outdated? is there a list of 'features' in Haskell2010 that is not discussed in this tutorial?
23:26:53 * hackagebot base-prelude 0.1.19 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.19 (NikitaVolkov)
23:27:42 <srid> those completed, what do you think of this wikibook? it is hardly mentioned: http://en.wikibooks.org/wiki/Haskell
23:32:06 <ski> the "Gentle" introduction is usually not recommended
23:32:45 <ttt_fff> does haskell have a "write file if it does not already exist" function?
23:32:49 <Cale> The Gentle intro is good, but it's not gentle, and it's probably not enough on its own.
23:33:31 <ski> (if you're already familiar with functional programming concepts (possibly also including static types, and algebraic data types ?), it might be nice)
23:33:47 <muyfine> having some trouble figuring out how to make a conveince wrapper with printf around an existing trace function
23:33:52 <muyfine> http://lpaste.net/129907
23:34:21 <muyfine> have trace, can use printf, and now want a "tracef"
23:34:24 <Cale> ttt_fff: I don't think so. You could check for existence using doesFileExist first, but of course, you have the problem of what happens to the filesystem in between the test and the write.
23:34:38 <ttt_fff> Cale: there is no way around that?
23:34:45 <ttt_fff> Cale: I can't get rid of this race condition?
23:35:00 <Cale> I honestly don't know
23:35:27 <ttt_fff> what if I write to a temporary file
23:35:37 <ttt_fff> is there some "mv if file does not already exist" ?
23:35:50 <ttt_fff> mv -n
23:35:54 <Cale> That's probably a good idea in any case if you're worried about it.
23:36:20 <ttt_fff> so I think the solution is (1) write to a temporary + unique location, (2) mv -n
23:36:54 * hackagebot yesod-bin 1.4.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.6 (MichaelSnoyman)
23:37:21 <Cale> muyfine: You'd have to make another class similar to PrintfType but for tracef
23:38:58 <muyfine> Cale: oh, that's what I was afraid of
23:39:40 <arkeet> someone should make a class that simultaneously generalizes both.
23:40:18 <arkeet> with whatever tricks you like, typefamilies, reflection, whatever.
23:40:34 <decentdog> Hi, how can I generate haddock documentation for all installed packages in a cabal sandbox? 
23:40:59 <arkeet> reinstall them with documentation.
23:41:54 * hackagebot monad-skeleton 0 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0 (FumiakiKinoshita)
23:42:05 <decentdog> arkeet: yoou mean cabal install --enable-documentation ?
23:42:13 <arkeet> yeah, or set it up in your .cabal/config
23:42:14 <decentdog> s/yoou/you
23:42:25 <decentdog> it doesn't seem to work
23:42:37 <Cale> Yeah, it's rather unfortunate that documentation: True is not the default.
23:42:46 <decentdog> should it be in $CABAL-SANDOX/share/doc/*/
23:42:46 <decentdog> ?
23:44:36 <arkeet> the docs will be inside the sandbox.
23:44:37 <arkeet> I hope.
23:45:00 <arkeet> so that sounds right.
23:45:16 <decentdog> I mostly see just LICENSE files there
23:45:27 <cYmen__> hello #haskell
23:47:59 <cYmen__> What is the preferred way to run a haskell script via http?
23:49:04 <cYmen__> Basically I want to be able to go to a website and then have my script called and get some output back. Is there a modhs? :)
23:49:46 <Cale> cYmen__: You could use CGI, or you could use one of the web frameworks for Haskell
23:50:14 <Cale> (the latter of which would result in a complete HTTP server)
23:50:56 <Cale> http://hackage.haskell.org/package/cgi
23:51:35 <cYmen__> Hm...I would prefer the web frameworks approach if it is reasonably comprehensible. :D
23:51:37 <Cale> http://hackage.haskell.org/package/scotty
23:52:32 <cYmen__> Cale: thanks
23:52:53 <Cale> There's also Snap, Happstack, and Yesod, all of which are quite featureful. Scotty is pretty lightweight and simple by comparison, but your use case sounded like you wanted something reasonably simple.
23:53:59 <cYmen__> absolutely!
23:54:10 <cYmen__> I don't even have a use case I just want to play around...
23:54:17 <cYmen__> and I hate learning three template languages for that ;)
