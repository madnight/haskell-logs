00:08:12 * hackagebot euler 0.8.2 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.8.2 (decomputed)
00:08:12 * hackagebot jmacro 0.6.11 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.11 (GershomBazerman)
00:09:49 <ROOM1> hi
00:16:48 <Darwin226> Hey guys. Yesterday I asked if infinite recursion is possible in a language with higher order functions, but with a limitation that a function can only reference those defined before it. The answer way the Y combinator
00:17:30 <Darwin226> So now I've studied it a bit to see how the thing works and I think I have a rough idea. So what can I do to prevent someone from writing it?
00:21:18 <Axman6> it's not that hard to make a language which isn't turing complete
00:21:49 <Axman6> making a useful language that isn't turing complete can be a pain though
00:22:52 <ion> The definition of fix uses recursion.
00:23:13 <Darwin226> Axman6: That's what I'm going for. I want to see what's the least I can take out to make this impossible
00:23:34 <Darwin226> ion: There's a non recursive version of the y combinator
00:23:54 <Axman6> I'm not sure if there is in Haskell
00:24:03 <Axman6> the Y combinator doesn't type check in haskell
00:24:09 <shachaf> Darwin226: You can't write the Y combinator in Haskell without, at least without type trickery (type recursion in negative position).
00:24:59 <Darwin226> shachaf: Yeah, I know. But disallowing recursive data types seems like an overkill
00:25:15 <shachaf> Fortunately you don't have to disallow recursive types.
00:25:32 <Darwin226> shachaf: Really? How come?
00:25:52 <Darwin226> What's special about "data Rec a = In { out :: Rec a -> a }"
00:26:19 <shachaf> As above: "type trickery (type recursion in negative position)"
00:26:59 <shachaf> For instance a language like Agda won't allow a type like that.
00:27:00 <Darwin226> shachaf: "negative position" means I have a reference to itself as a type of a function parameter, right?
00:27:11 <shachaf> More or less.
00:27:59 <Darwin226> shachaf: Interesting. Will that seal up all the holes, or do I have to look for other possible hacks?
00:28:06 <alokbeniwal> does anyone have any recommendations for a good first project in haskell?
00:28:13 <shachaf> The type Rec is an encoding of Curry's paradox, more or less.
00:28:14 <alokbeniwal> i’ve done LYAH
00:28:27 <shachaf> I'm not one to tell you that you've sealed up all the holes.
00:28:53 <shachaf> Look at some total language like Agda and see  what it does.
00:29:29 <Darwin226> shachaf: Ok. Agda was mentioned a couple of times yesterday too. I guess it's a good idea. Thanks
00:39:45 <hunteriam> So when is the FTP, BBP coming into effect?
00:40:15 <MP2E> it is in effect in GHC 7.10.1-RC3
00:40:26 <MP2E> 7.10.1 release should be soon
00:40:35 <MP2E> next few days, soon
00:43:03 <hunteriam> What's the difference between BBP and FTC
00:43:09 <hunteriam> Are they the same thing?
00:43:41 <hvr> If anyone's interested, here's the latest core-lib haddocks for GHC 7.10: https://hackage.haskell.org/package/template-haskell-2.10.0.0/candidate https://hackage.haskell.org/package/base-4.8.0.0/candidate https://hackage.haskell.org/package/integer-gmp-1.0.0.0/candidate  https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate
00:44:00 <ion> hvr: thanks
00:44:31 <ion> What’s new in TH?
00:44:36 <hvr> ion: see changelog
00:44:47 <ion> Ah, i forgot it exists these days.
00:44:48 * hvr tried to summarise the changes
01:28:39 <_ryan> hi everyone.
01:29:33 <_ryan> can i ask for a help i would like to convert my Html to string. cause i want it to save on DB is it possible?
01:30:12 <tdammers> _ryan: what's the big picture? use case? why do you need HTML in a database? and in what format do you have it currently?
01:30:40 <_ryan> actually it is converted already from markdown to html..
01:30:46 <_ryan> tdammers: actually it is converted already from markdown to html..
01:31:19 <tdammers> and why do you need to store it? wouldn't it be better to store the markdown instead
01:31:23 <_ryan> tdammers: i want it save in my db so that when i get it. i don't need to convert it anymore
01:31:55 <_ryan> tdammers: it will takes a time to convert it again on HTML..
01:34:58 <_ryan> tdammers: is it even possible? or not?
01:35:20 <tdammers> possible, sure
01:35:35 <tdammers> you can technically just store HTML source in TEXT columns
01:35:44 <tdammers> but
01:36:05 <tdammers> it's generally considered bad practice, because typically, you'll send that HTML to the client browser
01:36:19 <tdammers> and without further validation, all sorts of security problems will arise
01:36:37 <tdammers> also, bad data in your database can break the functionality of your client-side code
01:36:41 <tdammers> or produce malformed HTML
01:37:17 <tdammers> and there really isn't much you can do about that, other than parsing the HTML into a DOM, cleaning things up and catching errors, and then converting that back to HTML
01:37:33 <tdammers> but if you're parsing anyway, why not parse a more convenient format in the first place
01:38:25 <tdammers> besides, pandoc performs quite well, are you sure you have a performance problem there?
01:38:38 <_ryan> what is pandoc?
01:38:42 <simg> tdammers: I don't think it's bad practice if you "validate" your html THEN save it in the database as a cached "safe" version
01:38:53 <tdammers> simg: you have to validate again when you get it out
01:38:57 <tdammers> database is an untrusted input
01:40:00 <simg> tdammers: no, I don't think so. user input is untrusted. if you sanitise it, convert it to html then save that in the database, that's safe
01:40:17 <tdammers> it's not
01:40:30 <tdammers> you cannot tell, from within your application, whether other things can connect to your database
01:40:30 <_ryan> now i'm getting confuse :)
01:40:43 <tdammers> besides, in-depth security
01:40:44 <simg> tdammers: it is :) it's exactly how content management caching systems work
01:40:51 <tdammers> yes
01:40:56 <ion> hvr: https://hackage.haskell.org/package/base-4.8.0.0/candidate/docs/src/Data-Foldable.html “As of base 4.8.0.0, 'sequence_' is just 'sequenceA_', specialized to 'Monad'.” but it uses (>>)
01:40:58 <tdammers> and they're all broken, basically
01:41:06 <tdammers> they sacrifice in-depth security for convenience
01:41:08 <frerich> simg: What if your database gets corrupted, or some malicious user tinkers with your database?
01:41:45 <ion> What about if your RAM gets corrupted or some maliciour user tinkers with your in-process memory? You can’t trust x :: String either.
01:42:03 <tdammers> ion: true, but a database connection is much easier to compromise than RAM
01:42:16 <_ryan> tdammers: so the best solution is save my markdown on the DB then once i get it convert it?
01:42:20 <haskellnoob> does anyone have experience with a wireworld?
01:42:22 <frerich> ion: If you take it to absured extremes, right.
01:42:40 <tdammers> _ryan: it really depends on your use case, but most likely, yes, save markdown, convert to HTML when needed
01:43:14 <_ryan> thank you then :)
01:43:19 <_ryan> i will try it.
01:43:34 <ion> Why do you want to cache in the database instead of on disk?
01:43:48 <tdammers> why not cache in RAM?
01:44:00 <tdammers> avoid the whole I/O thing altogether
01:44:55 <simg> frerich: that's an interesting point, but without caching most web (content) applications won't scale. and caching (generally) involves caching complete html pages or fragments - not some html "precursor" that requires further processing
01:45:56 <frerich> simg: Of course. FWIW, this is no black and white thing. Many applications do have 'persistent caches', but you'll still need some sort of mechanism for validating that th cache is valid. Which at least means, being able to tell when the cach is outdated.
01:47:56 <simg> frerich: yep, I'm just making the point that it *isn't* a bad practice to store html in a cache 
01:48:44 <frerich> simg: Nobody questioned that. The questionable part is: trusting your cached HTML blindly :)
01:49:51 <simg> <tdammers> you can technically just store HTML source in TEXT columns ... it's generally considered bad practice, because typically, you'll send that HTML to the client browser
01:50:14 <simg> no offence to tdammers :)
01:50:27 <frerich> simg: Yep, see? The 'you'll send that HTML to the client browser'. part.
01:51:02 <simg> fretich. yes, what am I missing?
01:51:32 <frerich> simg: If you cache HTML and then just send it out without having any idea of what it is you're serving, you may just as well serve random HTML pages. You should have 'some' confidence in that what you believe is 'cachd Markdown HTML otuput' is actually just that.
01:51:42 <frerich> And not some hideous JavaScript monstrosity.
01:52:30 <frerich> simg: I believe this is commonly called "cache validation" and I think it's a pretty hard nut to crack. So many frameworks just tip-toe around it and don't validate - so they get speed at the expense of security.
01:52:35 <solatis> are there any yesod / shakespearean template gurus here?
01:53:36 <simg> frerich: quite, but *every* content management caching system that I've seen (which is a few) works as I suggest. the validation of the html takes place before it goes in the cache. being paranoid and trading security for speed is fine I guess but it isn't bad practice to cache html (IMO)
01:53:49 <_ryan> everyone - my next question " is it possible to render the markdown in my hamlet?"
01:54:13 <frerich> simg: I guess we're getting offtopic in a channel with 1460 people. Oops. :-}
01:56:27 <_ryan> the last question i post for yesod.. but theres no one response on my question.. sorry :-)
02:01:30 <hvr> edwardk: ping?
02:01:57 <simg> _ryan: are you aware of http://hackage.haskell.org/package/yesod-markdown-0.3.3 ?
02:02:39 <hvr> ion: thx
02:02:50 <Haskellfant> I'm writing a wayland window manager and I want the keyboard shortcuts to be specified by simple strings because that is easy, however it's not safe as not every string can be mapped to a key. Is that a usecase for template haskell to write a compile time check?
02:04:06 <mpickering> Haskellfant: No, that's the use case for a datatype :)
02:04:24 <_ryan> simg: yes i use it to convert my markdown to html.
02:04:33 <Haskellfant> mpickering: sorry I don't quite get how that solves the problem
02:05:18 <mpickering> I'm saying, don't represent them as plain strings
02:05:56 <simg> _ryan: the README has an example of rendering markdown using hamlet 
02:05:57 <Haskellfant> well I don't internally, but specifiying keysym_X seems annoying as a user
02:06:09 <m0rphism> Haskellfant: I think you should be able to convert "ab" to [A,B] using template haskell where `data Keys = A | B | ...` if you really don't want to use [A,B] directly.
02:06:35 <Haskellfant> ok thx
02:06:46 <mpickering> Does a user specify these bindings at compile time?
02:06:53 <Haskellfant> yes
02:07:02 <frerich> Haskellfant: Yiou might like https://github.com/frerich/smartconstructor
02:07:07 <_ryan> simg: thank you i forgot to read it :-)
02:07:29 <simg> _ryan: ;) - you're welcome 
02:07:32 <frerich> Haskellfant: Using that, you could do 'newtype Shortcut = Shortcut String' and then 'makeSmartCtor defaultOptions ''Shortcut [|(`elem` validShortcuts)|]
02:07:52 <Haskellfant> ah that seems perfect, thanks frerich 
02:08:05 <frerich> Haskellfant: That'll define a function 'makeShortcut :: String -> Maybe Shortcut' which yields 'Nothing' in case the given string is not a member of 'validShortcuts'.
02:09:21 <simg> sorry to keep asking this (in various formats) but are there any digestive-functors experts here that could help me with using "listOf" and file input  (been bashing my head against this for weeks :/)
02:09:46 <Haskellfant> well I already have a function that turns a string into a maybe shortcut. The problem is that I don't see any good reason to do that at runtime
02:10:18 <m0rphism> frerich: seems interesting. Is the check conducted at compile time using template haskell or does it generate an ordinary smart constructor?
02:10:46 <merijn> Is there, like, a haskell library with some nice monoidal design I can replace matplotlib with?
02:11:59 <Haskellfant> merijn: last time I checked chart seemed to be the best option https://hackage.haskell.org/package/Chart
02:12:59 <mpickering> Haskellfant: https://ghc.haskell.org/trac/ghc/wiki/ValidateMonoLiterals
02:13:02 <frerich> m0rphism : No, it's just "ordinary smart"
02:13:22 <mpickering> https://mail.haskell.org/pipermail/ghc-devs/2015-February/008239.html
02:13:29 <merijn> mpickering: That doesn't exist (yet!)
02:13:47 <mpickering> I know! but it's exactly what he's asking for
02:13:54 <frerich> m0rphism : It's just a little helper, but I often *don't* go for newtype wrappers because I'm too lazy to write the constructor functions. So now I have no excuse anymore. :-)
02:13:57 <merijn> mpickering: I just got back from wintersport vacation, so once I'm caught up with work I'm gonna continue lobbying/hacking for that :)
02:14:18 <Haskellfant> mpickering: ah thanks, I'll keep an eye on that
02:14:25 <merijn> Haskellfant: FYI, you can kinda do it in an ugly way already, I should have a TH example lying around
02:14:44 <m0rphism> frerich: I see ;) Seems also usefull, but probably a different problem case
02:14:46 <Haskellfant> merijn: there is one in the proposal
02:15:06 <merijn> Haskellfant: Oh, right, I copy-pasted it in there >.>
02:15:19 <mpickering> merijn: I guess my main thought was why bake it into GHC when you can use a quasiquoter?
02:15:56 <merijn> mpickering: Because 1) you can't use a quasiquoter right now, as there are no Typed TH quoters and 2) they are VERY verbose for things that you want all over your code
02:16:43 <merijn> Haskellfant: If you want to be more efficient (the example there uses fromJust to coerce the result at runtime) you might want to implement a Lift instance for your type that way you can directly splice the result at compile time instead of at runtime
02:17:03 <merijn> Unfortunately, there's no good way to get Lift instances atm, so I'm lobbying for better support for that too
02:17:22 <Haskellfant> k
02:17:46 <merijn> There is a package that generates lift instances using TH, though
02:18:48 <merijn> The Lift instance one requires a "Lift a" constraint and should replace the last line with "Just x -> [|| x ||]"
02:42:31 <ion> Is there a reason for map not being defined as fmap in base-4.8.0.0?
02:43:04 <ion> /FTP
02:43:04 <merijn> ion: Yes, the same reason it hasn't been defined as fmap ever since like Haskell 1.4
02:43:13 * hackagebot blaze-html 0.8.0.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.8.0.2 (JasperVanDerJeugt)
02:43:27 <merijn> ion: map could've been fmap without AMP/FTP no problem
02:44:04 <merijn> Somewhere around 1.4 it was changed to list only to be "beginner-friendly" and have less complicated type errors. Whether that's a useful reason is up for debate
02:44:15 <ion> Yeah, but since a bunch of other list functions were generalized, it would seem as an appropriate time.
02:44:33 <merijn> ion: They were only generalized to avoid breaking everything
02:44:39 <merijn> And there was a huge argument about it >.>
02:44:51 <ion> I know, and generalization won. :-P
02:50:44 <m0rphism> merijn: Really? I thought generalizing them would cause breakage. Do you mean inside ghc?
02:51:13 <merijn> m0rphism: Less breakage than not-generalizing
02:51:40 <merijn> Generalizing only breaks them when they're used in a context where they are needed to fix a type for type-inference and there is no signature to fix the result
02:52:41 <merijn> Not generalizing would mean name conflicts in any module that imports Data.List unqualified (i.e. everyone importing Data.List)
02:53:34 <m0rphism> oh I see. So the problems with not generalizing are due to some other library changes in ghc 7.10?
02:54:06 <merijn> Due to Foldable/Traversable moving into Prelude and having names that overlap with Data.List
02:58:57 <m0rphism> Ah I see, thanks. I've missed that you guys were talking about generalizing Data.List functions instead of Prelude.fold* due to AMP. Makes sense now ;)
02:59:05 <ion> I was talking about Prelude.
03:01:38 <m0rphism> ion: I also don't like that fmap/map thing. I think map/lmap would have been a better choice.
03:03:14 * hackagebot blaze-markup 0.7.0.2 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.7.0.2 (JasperVanDerJeugt)
03:03:42 <fugyk> I think that only map is a better choice
03:04:10 <bitonic> it would be very useful to have a way to do defaulting for arbitrary type-classes
03:04:20 <bitonic> or very convenient anyway
03:04:30 <m0rphism> I also never use the specialized version, but that way it would be a good compromise, with both sides getting what they want ;)
03:07:17 <m0rphism> bitonic: or maybe a type ascription to fix typeclass instances with low syntactic overhead
03:07:28 <m0rphism> A while ago I had the idea: : `fmap^[] f xs` for `(fmap :: (a -> b) -> [a] -> [b]) f xs`
03:07:53 <bitonic> m0rphism: well, it requires more effort on the user
03:08:34 <m0rphism> but this also had problems as edward kmett pointed out to me: http://www.reddit.com/r/haskell/comments/2vmzaw/ftp_dangers/cojimsh
03:09:08 <m0rphism> (Not that it doesn't work in this specific instance, but rather with the general case)
03:11:46 <m0rphism> bitonic: oh you were thinking about changing fmap to map without any refactoring for ambiguity because it simply defaults to list?
03:12:28 <bitonic> m0rphism: I'm just wishing there was a way to do Num/IsString like defaulting for arbitrary typeclasses
03:27:01 <immi11> hi guys a  here  , a small doubt
03:27:10 <immi11> haskell beginner
03:27:36 <immi11> skips xs = map (\n -> skip n xs) [1..(length xs)]
03:27:36 <immi11> [15:54] <immi123> skip n xs = map snd $ filter (\x -> (fst x) `mod` n == 0) (zip [1..] xs)
03:27:36 <immi11>  what is the difference between this two functions doing the work and a imperative version of one ...
03:27:36 <immi11>  i mean under the hood ... it looks like a nested for loop ? please explain
03:31:06 <sagittarian> you could also write it as a nested for loop (in a different language)
03:31:20 <sagittarian> what's the question?
03:32:21 <merijn> length xs has to traverse the entire list xs twice
03:32:35 <merijn> well, once, but then you still have to do the rest of the computation
03:33:18 <immi11> question being .. that the complexity of the snippet is same as n^2  , just like the imperative version .Apart from the consise way of writing , is there any other advantage that i am failing to see. Pardon im just going through introductory haskell course
03:34:16 <sagittarian> does there exist an algorithm to do it in faster than O(n**2)?
03:34:40 <sagittarian> haskell won't let you accomplish things faster than is logically possible
03:34:53 <merijn> immi11: Let me reverse the phrasing "what is the advantage of the imperative way of writing that algorithm?"
03:35:20 <sagittarian> merijn is right, the items of the list won't be evaluated until necessary, which is nice
03:35:22 <opqdonut> sagittarian: it's possible in O(n) time, you traverse the list and keep adding to the different skip lists
03:35:31 <opqdonut> (given suitable datastructures)
03:35:43 <sagittarian> but calculating the skip list is O(n) itself
03:35:52 <opqdonut> yes, but you can do all of them at once
03:36:20 <opqdonut> hmm, not quite O(n) actually, but something subquadratic
03:36:33 <immi11> point noted , but it is posibble less than n2 , given suitable data strucutres as said here
03:37:16 <sagittarian> the given algorithm is O(n)
03:37:59 <sagittarian> if you can do it in linear time in haskell you can do it in linear time in an imperative language, it might just not be quite as elegant
03:39:34 <immi11> thanks , about less than n2 time , suitable data structures ? like ?
03:41:48 <tongcx> hi guys, what's the correct way to indent http://lpaste.net/128342?
03:42:38 <tongcx> I was study Monad through category theory yesterday, it was an beautiful journey, however I didn't sleep well last night because of it
03:46:43 <sagittarian> with haskell's lists you have to traverse the list to find a given index, so i don't see how you could build up the list of skips in less than O(n^2) time
03:47:06 <sagittarian> with an array and constant time access you could probably do it
03:48:36 <m0rphism> tongcx: What exactly do you mean by correct? For me your code compiles. Do you mean aesthetically?
03:48:46 <tongcx> m0rphism: yes
03:48:54 <sagittarian> tongcx: i know the feeling :-)
03:49:01 <tongcx> m0rphism: sorry, I should be more clear
03:49:09 <opqdonut> sagittarian: the simple pure solutions are O(nlogn) due to using maps, but the logn factor is what often happens with pure algorithms
03:49:13 <opqdonut> sagittarian: let me write it out for you
03:52:23 <opqdonut> sagittarian: hmm, it's more involved than I thought at first, but one idea is to keep a map of the skiplists, iterate over the list while keeping an index counter, producing all divisors of the index, and adding the current element to all those skiplists
03:52:46 <opqdonut> sagittarian: if the skiplists are built in reverse order each addition is O(log n) (due to the map update)
03:53:11 <m0rphism> tongcx: I would indent it like this: http://lpaste.net/719886963200491520
03:53:26 <opqdonut> however it might be that there are two many additions to keep it under O(n^2), it depends on the total count of divisors of [1..n], which I don't know
03:53:27 <sagittarian> opqdonut: that's what i was trying to do, but you need constant access for your map, otherwise it doesn't improve the run time
03:53:31 <m0rphism> tongcx: I also took the liberty to abstract it for any state ^^
03:53:42 <opqdonut> *too many
03:53:46 <sagittarian> ah or O(log n), sure
03:53:54 <tongcx> m0rphism: looks much better, thanks, what's $?
03:54:19 <m0rphism> tongcx: ($) is defined as   f $ x = f x
03:54:44 <m0rphism> tongcx: but it is right-associative and has a very low precedence
03:55:09 <tongcx> m0rphism: i see, very cool!
03:55:39 <m0rphism> assocaitivity means: while  f x y  is  ((f x) y)  it holds that  f $ x $ y  is (f (x y))
03:55:45 <m0rphism> ok :)
03:56:25 <m0rphism> also because of low precedence  f $ x $ y  is simply  f $ x y
03:57:04 <tongcx> m0rphism: very nice
03:57:52 <nkar`> does ghc try to report all type errors at once, or does it stop after a certain point?
03:58:03 <merijn> nkar`: It tries to report as many as possible
03:58:37 <nkar`> merijn: how does it determine that?
03:59:05 <merijn> How does it determine what?
03:59:26 <nkar`> how does it determine when to give up?
03:59:44 <merijn> I don't think it ever really does, except for syntax errors
03:59:52 <merijn> And maybe even then it retries?
04:00:24 <jle`> that's sort of like asking how does map (*2) [1,2,3] knows when to give up
04:00:26 <nkar`> merijn: I guess, my question can be rephrased as "could you explain how typechecking works in 2 minutes?"
04:00:35 <jle`> it just does the job...until it's done
04:00:47 <merijn> nkar`: Yes: "read this book"
04:00:49 <merijn> @where tapl
04:00:49 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:01:08 <nkar`> it's on my list already, but I don't have time for it right now
04:01:19 <nkar`> so you can't provide a high-level answer, can you?
04:01:44 <merijn> nkar`: "take type of individual expressions, try to fit them like a jigsaw, if it doesn't fit, complain"
04:02:28 <merijn> "True :: Bool" and "even :: Int -> Bool" (well, simplified)
04:02:50 <merijn> So when you see "even True" you see if you can fit "Bool" into "Int" (you can't, so you complain)
04:03:50 <nkar`> I guess I need to describe the type errors it's dealing with right now.  maybe you could answer why it behaves the way it does.
04:03:52 <merijn> "[1] :: [Int]" and "length :: [a] -> Int", so when you see "length [1]" you try to fit "[Int]" into "[a]", which you can, IFF "a ~ Int" (i.e. iff you can fit "Int" into "a")
04:03:52 <sagittarian> only someone who's never programmed in Java would say that you can't fit Bool into Int
04:04:09 <merijn> sagittarian: Java was my first language, so... :p
04:04:14 <mniip> even . unsafeCoerce -- java programmer, probably
04:04:18 <sagittarian> i'm kidding :-)
04:05:00 <quchen2> nkar`: Any value has a type. Some values combine values of other types. The typechecker figures out whether the pieces match, and how they have to be modified to do so. If such modification isn't possible, you get a type error. For example, in order to typecheck "id ()", you have to check whether and how "id :: a -> a" and "() :: ()" fit together. Since "a" unifies with "()" the typecheck works under that constraint.
04:05:11 <merijn> mniip: You haven't achieved "pro" status as a haskeller until you've segfaulted a haskell program :)
04:05:26 <mniip> oh trust me I have
04:05:29 <nkar`> merijn: oh, it's easy with unsafeCoerce
04:05:37 <quchen2> merijn: I haven't. Do GHC panics count too?
04:05:41 <ion> merijn: ITYM segfaulted GHC
04:05:47 <mniip> it's even easier with nullAddr# and writeCharOffset#
04:05:48 <merijn> quchen2: No, panicing GHC is easy :)
04:05:54 <mniip> or whatever it's called
04:06:01 <quchen2> merijn: So is segfaulting!
04:06:09 <quchen2> We need a higher standard of bad behaviour.
04:06:18 <merijn> quchen2: Not if you do embedded development ;)
04:06:19 <tongcx> Hi guys, should I view 'data' as providing the new category and `Functor` help us map function in first category to the second?
04:06:40 <quchen2> GHC panic: the imposSegfault   <---  Maybe that?
04:06:45 <merijn> tongcx: No, data creates new objects in the category Hask
04:06:57 <merijn> tongcx: Functor is an endofunctor mapping Hask objects to Hask objects
04:07:18 <merijn> (and Hask morphisms to Hask morphisms)
04:07:32 <tongcx> merijn: in Hask, Functor is a class with fmap, so I guess it more focus on the arrows instead of objects?
04:08:12 <merijn> tongcx: Well, the Functor is (for example) Maybe
04:08:27 <merijn> Since "Maybe" maps the object Int to "Maybe Int", both of which are objects in Hask
04:09:43 <tongcx> merijn: yea, but in Hask, there is a Functor typeclass with fmap as the only required method, right?
04:10:00 <nkar`> merijn: so, re: errors: I added a new argument to a few value constructors of a sum type and didn't change any functions, but ghc doesn't seem to report all errors at once.  instead, it seems to process one value constructor at a time.
04:11:13 <nkar`> and because of that I have to re-run cabal build multiple times
04:12:21 <nkar`> ah, no.  it process multiple value constructors, just not all
04:12:25 <nkar`> es*
04:13:17 * hackagebot bytestring 0.10.6.0 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.6.0 (DuncanCoutts)
04:13:34 <jameseb> tongcx: a functor (in category theory) maps the objects and arrows of a category to the objects and arrows of another category in a consistent way, in Haskell a type constructor of kind *->* handles the object mapping and fmap handles the arrow mapping
04:14:35 <tongcx> jameseb: right, i agree
04:15:23 <jameseb> tongcx: so, what was your question?
04:16:43 <tongcx> jameseb: resolved, I was thinking in category theory functor contains both map from object to object and arrow to arrow. In Hask, syntaxly speaking, the Functor typeclass only focus on the second part
04:19:14 <quchen2> No, Functor does both the object and arrow parts.
04:19:38 <quchen2> (Categorically ans haskelly.)
04:19:41 <tongcx> quchen2: right
04:23:57 <tongcx> what's `:t`?
04:24:42 <phadej> tongcx: the object mapping is handled by type, e.g. with [] -functor, [] is a object map, and `map` (or `fmap`) is the arrow map
04:24:52 <phadej> tongcx: "show type of the expression"
04:25:14 <phadej> tongcx:    :type <expr>                show the type of <expr>
04:25:22 <phadej> tongcx: use :? for ghci built-in help
04:25:38 <tongcx> phadej: thanks, ? will be very helpful
04:36:18 <Twey> quchen2: Hm, if I have some type constructor f ∷ ★ → ★ and a type a ∷ ★, then I can get f a ∷ ★ without f necessarily being a Functor.  In what sense does Functor give objects?
04:38:41 <Cale> Twey: Well, the type constructor f itself is the mapping on objects
04:38:55 <Cale> Twey: and the corresponding fmap is the mapping on arrows
04:39:00 <quchen2> Twey: The action of "f" on "a" is the object part of the functor. This is sometimes called the "F_0 part of a functor F".
04:40:54 <jle`> functors just don't map objects
04:41:02 <jle`> they map morphisms too
04:41:30 <Twey> Cale: Right
04:42:22 <Twey> Yeah.  Little-f functors map both objects and morphisms, but you can have things (‘type constructors’ in Haskell) that map objects but don't necessarily map morphisms
04:42:52 <Twey> And all being a Functor says is that they do map morphisms as well: making something a Functor doesn't get you an object mapping, because you need to already have the object mapping before you can make it a Functor
04:43:41 <jle`> type constructors without an appropriate morphism mapping aren't Functors or functors
04:43:47 <Twey> jle`: Right
04:43:54 <Twey> But they do map objects
04:44:05 <Big_G> If I have an ADT, how do I pattern match against each of the possible values?
04:44:27 <jle`> oh I see. you are saying that you get th object mapping for free before you even define the morphism mapping
04:44:44 <Twey> Yes.  quchen2 seemed to claim that Functor gives you an object mapping
04:44:57 <jle`> Big_G: you caj up  `case` syntax
04:45:09 <jle`> *can use
04:45:10 <frerich> Big_G: You mean, you want to enumerate them programmatically as opposed to explicitely using 'case' (or a sugared form of 'case')?
04:45:26 <Big_G> frerich, I don't know what case is 
04:45:41 <Big_G> but it sounds like it 
04:46:03 <jle`> case myVal of  ...
04:46:21 <jle`> Just x -> 5, etc.
04:46:22 <Big_G> Like, if it is Just, do this but if Nothing, do this
04:46:27 <jle`> yes
04:46:41 <jle`> GHC will do completeness checking for you if you ask
04:46:56 <jle`> so if you miss a pattern, you'll know
04:47:46 <Big_G> Thanks. It just seems a bit ugly to me
04:48:21 <jle`> Twey: you can say that Functor f =>  ....  gives you both an object mapper f and a corresponding morphism mapper too
04:48:54 <jle`> perhaps
04:48:57 <frerich> Big_G: There is some syntactic sugar for 'case' which lets you do
04:48:58 <frerich> f (Just i) = ...
04:48:58 <frerich> f Nothing  = ...
04:48:58 <frerich> instead of
04:48:58 <frerich> f x = case x of { Just i -> ...; Nothing -> ...}
04:49:26 <Big_G> frerich, That is what I'm used to.
04:51:00 <quchen2> Twey: Functor gives you the abstraction. The mapping "something -> Maybe something" exists without Functor, but then so does "map" outside of functor.
04:51:07 <merijn> nkar`: Incomplete patterns are only warned with -Wall, I think?
04:51:19 <quchen2> Functor just gives you the convenience to refer to all functorial things under a unified name.
04:51:26 <merijn> nkar`: Anyway, you should *always* be using -Wall anyway and only selectively disable warnings
04:52:00 * frerich wonders about the heuristics employed by the auto-completion engine in merijn's IRC client.
04:52:11 <frerich> "Ends in backtick, that must be it!" :-)
04:52:37 <merijn> frerich: I was answering a question from before I went for lunch
04:53:14 <merijn> frerich: That makes more sense, no? ;)
04:53:19 <frerich> merijn: Ah - and I thought you were commenting on what jle` just wrote: "<jle`>so if you miss a pattern, you'll know"
04:54:13 <merijn> frerich: Just coincidence that the topics were related :p
04:54:49 <Twey> quchen2: But *Maybe* itself is an object mapping, from ★ to ★
04:55:32 <simg> would it be considered rude to email the author of a package to ask a (very specific) question about how to use it? 
04:55:55 <merijn> simg: No, provided you don't hassle/harass them about it if they don't respond/respond slowly
04:56:12 <merijn> simg: I've done so plenty of times with reasonable success rate
04:56:41 <simg> merijn: ok, thx. I'll give it a go :)
04:58:01 <mrkkrp> Hello. For Quick Check testing I need to generate some recursive data structure (syntax tree). But when I try to run some tests, generated data structures get too deep sooner or later and testing can take hours. Is there some way to limit nesting of such data structures? At the beginning, I thought I could select recursive and non-recursive constructors and use `frequency` to decrease probability of recursive constructors. But it
04:58:01 <mrkkrp> doesn't seem to help.
04:58:02 <quchen2> Twey: and mapMaybe itself is an arrow mapping, from (a->b) to (Maybe a -> Maybe b). I don't understand
05:00:32 <Twey> quchen2: Yes, but the Functor abstraction includes mapMaybe, but it doesn't include Maybe
05:01:13 <Twey> quchen2: If you have an arbitrary type constructor f ∷ ★ → ★, you already have an object mapping, f a, by the very nature of f.  You don't get that by f being a Functor
05:02:39 <Twey> But you *don't* have an arrow mapping — in order to have an arrow mapping you need to have a Functor instance (or equivalent information, like actually knowing what f is and that type being something for which you can define an arrow mapping)
05:03:02 <nkar`> merijn: I'm using -Wall, but that's not incomplete patterns: "Constructor ‘Foo’ should have 4 arguments, but has been given 3"
05:06:09 <frerich> mrkkrp : Not sure I whether you use this already when you say 'frequency', but you can instantiate the 'Arbitrary' typclass to control the test data generation.
05:06:23 <merijn> nkar`: hmmm, dunno why that would be
05:08:41 <quchen2> Twey: You mean that you get the object part of a functor for free? That sounds right, yes.
05:09:16 <quchen2> Twey: In particular, you can't make any mistakes implementing that part, whereas fmap has to obey laws such as that it should terminate and things.
05:09:18 <mrkkrp> frerich: this `frequency': http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck.html#v:frequency
05:09:40 <mrkkrp> frerich: I also have found this http://stackoverflow.com/questions/15959357/quickcheck-arbitrary-instances-of-nested-data-structures-that-generate-balanced
05:10:50 <merijn> quchen2, Twey: The confusion here seems to be the dinstinction between Functor (the class) and functor the concept. The latter is just a pair of object and arrow mappings, in the former the object mapping is already implicit, so it only includes the arrow mapping
05:12:04 <Big_G> This code seems really hackish but I can't tell why
05:12:06 <Big_G> data NestedList a = Elem a | List [NestedList a]
05:12:07 <Big_G> flatten :: NestedList a -> [a]
05:12:07 <Big_G> flatten (List []) = []
05:12:07 <Big_G> flatten (Elem x) = [x]
05:12:07 <Big_G> flatten (List (x:xs)) = ((flatten x) ++ (flatten (List xs)))
05:13:07 <Twey> quchen2: Yes.  I was replying to your claim that 111819 <quchen2> No, Functor does both the object and arrow parts.  <quchen2> (Categorically ans haskelly.)
05:13:37 <quchen2> Oh. I guess that depends on what you mean with "does" in that context.
05:13:51 <Twey> Little-f functors are both object and arrow maps, but unless I'm missing something being a Functor only gives you arrow maps on top of what you already have by f being a type constructor
05:15:03 <quchen2> I agree that in writing Haskell, a Functor means you already have an object mapping and then add a well-behaved arrow mapping to it.
05:15:26 <merijn> Big_G: Doesn't seem so bad to me?
05:15:46 <Big_G> merijn, So that is the perfect way to do it in Haskell?
05:15:52 <merijn> Big_G: You could speed it up using DList, but that's not a big difference, you should remove some unneeded parentheses, though
05:16:10 <Big_G> merijn, Which are uneeded?
05:16:16 <Twey> Big_G: All of them.  :þ
05:16:25 <Twey> On the RHS, that is.
05:16:26 <merijn> "flatten (List (x:xs)) = flatten x ++ flatten (List xs)"
05:16:28 <Big_G> I was getting errors without them
05:16:44 <Twey> Oh, yes, missed that one.
05:16:45 <merijn> Infix always has lower precedence than prefix
05:16:45 <Big_G> Twey, RHS?
05:16:51 <Twey> Right-Hand Side
05:16:51 <merijn> Big_G: Right Hand Side
05:17:12 <Big_G> Oh, I thought you meant taking away from the pattern match
05:17:44 <Twey> No, you need all of those.
05:17:51 <merijn> Big_G: Precedence rules are as follows: infix has precedence 0 through 9 (with optional left/right associativity), function application has precedence 10, record syntax 11
05:18:01 <merijn> Higher binding more tightly
05:18:20 * hackagebot casadi-bindings-internal 0.1.3.0 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-internal-0.1.3.0 (GregHorn)
05:18:22 * hackagebot casadi-bindings-core 2.3.0.0 - autogenerated low level bindings to casadi  http://hackage.haskell.org/package/casadi-bindings-core-2.3.0.0 (GregHorn)
05:18:24 * hackagebot casadi-bindings 2.3.0.0 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.3.0.0 (GregHorn)
05:18:28 <merijn> You can query the precedence using ":i (++)", no info == default == infixl 9 (infix left associative)
05:22:40 <Twey> Big_G: You can make it a bit more straightforward by using a fold for the List case, if you're comfortable with folds: flatten (Elem x) = [x]; flatten (List xs) = foldr ((++) . flatten) [] xs.  But your existing code is pretty much fine.
05:24:12 <merijn> Twey: That seems needlesly complex. Anyway, the DList implementation would be substantially faster, although that's probably not an issue here
05:24:33 <merijn> Big_G: Unrelatedly, this NestedList is more commonly called a "Rose Tree"
05:25:01 <Big_G> merijn, Good to know. I'm just doing these from a code kata site
05:25:48 <Twey> merijn: You consider the fold to be more complex?
05:26:13 <merijn> Twey: I find the foldr definition much less readable than the naive recursion, yes
05:26:24 <merijn> Complex is relative, of course
05:26:30 <Twey> I generally think that direct recursion should be avoided in favour of existing recursion patterns when they're already helpfully encapsulated
05:42:36 <frerich> I think having a fold-style function for 'NestedList' (I think that's called a "catamorphism"?) would allow you to define 'flatten = fold (:[]) (concatMap flatten)'
05:43:21 <tongcx> What's a fixed point for functor?
05:43:22 <frerich> If you write that as 'fold (\elem -> [elem]) (\list -> concatMap flatten list)' then it's actually not so unreadable even though it's a fold.
05:45:45 <merijn> tongcx: As you thinking of Mu/Fix?
05:46:12 <tongcx> merijn: probably, I am not sure what's fixed pointer in Haskell
05:46:22 <tongcx> For example, does functor Maybe has a fixed point?
05:46:52 <ziman> yes, it's the type of natural numbers
05:47:27 <merijn> Mu isn't defined in base?
05:48:41 <elvinz> hi, is it possible to declare signature and body of an expression in a single line ? For example, combining nbClass::Int and nbClass = 2 in a single statement, something like nbClass::Int = 2 ?
05:49:14 <tongcx> ziman: Maybe will map type Num to Maybe Num, why that's a fixed point?
05:49:28 <frerich> elvinz : You could use 'nbClass = 2 :: Int', which is not quite a signature but it'll make GHC deduce what you wrote.
05:49:28 <alpounet> elvinz: nbClass = 2 :: Int
05:49:29 <tongcx> should it be mapping type t to type t?
05:49:40 <merijn> elvinz: Not really, but "nbClass = 2 :: Int" would work, sorta
05:50:08 <merijn> elvinz: Is there a reason you don't want to have them separate?
05:50:47 <elvinz> frerich alpounet merijn, thank you. I want to do that to have a more compact syntax for the declaration of various numerical values in my program
05:50:53 <tongcx> another question `putc 'a' >> getc >>= \a -> putc 'b' >>= \b -> putc a`, how could I am able to refer to `a` in the last bind?
05:51:01 <ziman> tongcx, you're right, the fixpoint of Maybe is just isomorphic to the type of natural numbers
05:51:15 <merijn> elvinz: If the reason is "I'm defining lots of variables of the same type and don't want to declare the types separately all the time", you can do bulk annotations
05:51:15 <frerich> elvinz: If you have multiple values, you can do 'a, b, c :: Int' and then 'a = 3', 'b = 4', 'c = 5'
05:51:45 <merijn> Yeah, that
05:51:51 <tongcx> ziman: still i feel there is no fixed point for Maybe because no type t is mapped to t itself
05:52:22 <tongcx> ziman: but i think i am wrong, just don't know how, because otherwise, there is no fixed point for any functor
05:52:28 <ziman> tongcx, consider the type "Maybe (Maybe (Maybe (Maybe ...)))"
05:52:33 <merijn> tongcx: The fixpoint of maybe would be: "newtype Mu f = Mu (f (Mu f)); type MaybeFix = Mu Maybe"
05:52:33 <elvinz> frerich merijn: yes I will use the syntax your propose
05:53:03 <merijn> :k Mu
05:53:04 <lambdabot> (* -> *) -> *
05:53:21 <tongcx> merijn: can you elaborate on `newtype Mu f = Mu (f (Mu f))`, i cannot understand it
05:53:30 <merijn> :t Mu (Just (Mu (Just (Mu Nothing))))
05:53:31 <lambdabot> Not in scope: data constructor ‘Mu’
05:53:31 <lambdabot> Not in scope: data constructor ‘Mu’
05:53:31 <lambdabot> Not in scope: data constructor ‘Mu’
05:53:31 <m0rphism> tongcx: It's values can be enumerated as Nothing, Just Nothing, Just (Just Nothing), and so on
05:53:34 <merijn> Aww
05:53:49 <m0rphism> tongcx: modulo the newtype Mu wrappers
05:53:52 <ziman> in haskell, there's the "Mu" which gets in the way but in fact it's just an infinitely nested Maybe
05:54:19 <merijn> Mu Maybe -> "Mu (Maybe (Mu Maybe))" -> "Mu (Maybe (Mu (Maybe (Mu Maybe))))" -> etc.
05:54:25 <tongcx> so infinitely nested Maybe is the fixed point of Maybe functor, right?
05:54:33 <ziman> so if you add one Maybe layer, you get the same thing
05:54:35 <merijn> It's *a* fixpoint
05:54:50 <tongcx> How could this even be possible to represent this kind of infinite in computer????
05:55:05 <tongcx> My mind is out of the window now
05:55:30 <m0rphism> tongcx: same happend to me when I first saw this :3
05:55:46 <tongcx> m0rphism: how could that be stored and represented in computer?
05:55:53 <tongcx> m0rphism: is it because of lazy?
05:56:19 <merijn> m0rphism: Have you run into "time-travel due to laziness" yet? :p
05:56:29 <m0rphism> tongcx: the values can be stored like nodes of a linked list
05:56:30 <tongcx> merijn: no, could you show me?
05:56:42 <m0rphism> tongcx: terminating with Nothing
05:57:00 <tongcx> m0rphism: but unlike List, there is no Nothing here
05:58:02 <m0rphism> tongcx: regarding types I'm not sure yet, maybe someone else can answer that better than me, how to represent type fixpoints, I'm not at that chapter of Pierce's Types and Programming Languages book, yet ;)
05:58:40 <merijn> The newtype breaks the recursion
05:59:28 <tongcx> merijn: i feel it must be lazy
06:00:26 <m0rphism> merijn: no, I don't think so. But I'm not sure if I get the quoted term ^.^
06:00:48 <m0rphism> (regarding time-travel)
06:01:23 <tongcx> fold :: Functor f => Alg f a -> Fix f -> a
06:01:25 <tongcx> fold (Alg phi) (Fix f) = phi (fmap (fold (Alg phi)) f)
06:01:35 <tongcx> I still don't understand these two lines
06:01:57 <tongcx> At least now I understand what's a fixed point now
06:01:59 * tongcx feeling good
06:02:01 <merijn> m0rphism: Passing the result of a function as argument to the function, but I don't seem to have an example lying around
06:02:42 <tongcx> data Alg f a = Alg (f a -> a)
06:02:52 <tongcx> sorry I forget to post definition of Alg
06:03:22 <m0rphism> merijn: Ahh, I remember vaguely. In the fp lecture I took 3 semesters ago, we looked at ArrowFix.
06:03:57 <tongcx> merijn: is it even valid? I mean `fold (Alg phi)`, why function Alg appear here, isn't it a syntax error?
06:04:01 <m0rphism> merijn: if the argument is only forced conditionally this can work
06:04:19 <merijn> m0rphism: Right
06:04:51 <fizruk> tongcx: fmap (fold (Alg phi)) f   is just fancy recursive call of fold for "inner layers"/"subtrees" of f. applying phi to the result is folding the outer layer
06:05:36 <tongcx> http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful
06:05:51 <tongcx> here is the example, see the last example in the answer
06:06:15 <tongcx> I think maybe it provides enough context on ExpF and Exp to understand what's going on with this fold and Alg thing
06:06:18 <fizruk> tongcx: fold expects Alg as a first argument, so (fold (Alg phi)) is perfectly valid
06:07:32 <tongcx> fizruk: phi have type f a -> a?
06:08:05 <fizruk> yes, you have pattern matched it earlier in that line: fold (Alg phi) (Fix f) = ...
06:08:24 <fizruk> now you pack it back to call fold recursively
06:08:45 <tongcx> fizruk: aha, right!!!
06:09:55 <tongcx> fizruk: what's type of f here?
06:10:14 <fizruk> f comes from (Fix f) pattern
06:10:33 <tongcx> fizruk: so is f of type functor?
06:10:40 <fizruk> so it's type should be f (Fix f)
06:11:35 <tongcx> fizruk: i see, thanks
06:15:19 <benzrf> im beginning to think i made a stupid mistake in the design process
06:15:21 <benzrf> -_-
06:15:48 <benzrf> currently have Functor/Applicative/Monad/MonadRandom standalone generalizednewtypederivations for a type
06:15:56 <benzrf> gonna need to add like 3 more if i continue down this road ;-;
06:27:39 <benzrf> why does 'instance Foo a b c => Foo a b (f c)' not satisfy fundep 'c -> a b'
06:28:35 <tongcx> http://lpaste.net/128347, hi guys, how can i make this work, have error "No instance for (Functor ExpF) arising from a use of ‘fold’"
06:30:22 <fizruk> tongcx: write an instance :)
06:30:37 <fizruk> tongcx: or make GHC derive it for you
06:33:28 <tongcx> fizruk: write an instance for Functor? can you show me how?
06:33:45 <fizruk> tongcx: instance Functor ExprF where ...
06:33:58 <tongcx> fizruk: aha, i see, i need instance for that
06:38:59 <tongcx> http://lpaste.net/128347 here is updated version, in order to make it work, I have to do `Lit x -> Lit x` instead of `Lit x -> Lit (f x)`, which I feel is ugly.
06:39:05 <tongcx> Any way to fix that?
06:51:56 <kaiyin> could anyone give me some mind-bending functor examples?
06:52:45 <JordiGH> kaiyin: I've always been impressed with the first nontrivial functor I ever encountered: there is a contravariant functor between Galois groups and field extensions.
06:52:49 <merijn> kaiyin: Mind-bending in which sense?
06:53:14 <JordiGH> kaiyin: This is essentially the content of the fundamental theorem of Galois theory.
06:54:32 <c_wraith> kaiyin: I've always been a fan of Coyoneda.  data Coyoneda f a where Coyoneda (b -> a) (f b)
06:54:34 <kaiyin> merijn: different from the intuitive boxing analogy
06:54:40 <JordiGH> kaiyin: But like MacLane said, he invented category theory to talk about natural transformations, not functors. The easiest natural transformation I know of is the one between a vector space and its double dual. For finite-dimensional spaces, this is a natural isomorphism, due to a simple dimension argument.
06:54:40 <tongcx> JordiGH: that's mind-bending
06:55:03 <c_wraith> err, I screwed up my gadt syntax.  nice
06:55:07 <JordiGH> Otherwise it's just a natural injection.
06:55:08 <tongcx> this channel is amazing, do most people have math background here
06:55:13 <tongcx> ?
06:55:19 <benzrf> tongcx: it varies i think
06:55:24 <kaiyin> JordiGH: that sounds like quite advanced math.
06:55:30 <c_wraith> kaiyin: make that.. data Coyoneda f a where Coyoneda :: (b -> a) -> (f b) -> Coyoneda f a
06:55:32 <benzrf> tongcx: but tbh i think haskell as a gateway to math is more common than vice versa
06:55:43 <JordiGH> kaiyin: You wanted an interesting functor. I find the category theory that interests Haskellers to be weird and foreign and not very interesting.
06:55:56 <c_wraith> kaiyin: then fmap is just composing with the function.
06:56:10 <merijn> kaiyin: Try writing a Functor for this one: "data Const a b = Const a" :)
06:56:10 <JordiGH> Also, I think it was Steenrod who quipped that about natural transformations, not Maclane.
06:56:20 <merijn> kaiyin: "instance Functor (Const a) where"
06:56:30 <c_wraith> kaiyin: the fun thing is that Coyoneda f is a Functor for any f.  Even things like Coyoneda IORef
06:56:40 <merijn> kaiyin: I like that as the most obvious "non-box" functor :)
06:56:56 <merijn> tongcx: I don't :p
06:57:01 <tongcx> benzrf: i come from math background and i'm amazed so many people talking about very math intensive concepts
06:57:06 <merijn> I'm not a category theorists, I just pretend to be one on IRC!
06:57:23 <kaiyin> JordiGH: :-)  your are right. it's an very interesting example, it's just I am not strong enough for hard food like that, hopefully one day i will be. 
06:57:29 <JordiGH> There's an interesting post in the n-category cafe about how "third time's a charm", with how the third object in a procession is the interesting one. The two processions I could think of as examples are position -> speed -> acceleration and morphism -> functor -> natural transformation.
06:57:38 <benzrf> tongcx: its cause haskellers beliefve in learning from theory
06:57:44 <merijn> tongcx: To be fair, most discussion here is limited to specific parts of math (i.e. CT, logics, lambda calculi and algebras)
06:57:58 <merijn> kaiyin: My example should be simple enough :)
06:58:07 <benzrf> tongcx: whereas (at least recently) most mainstream programming communities tend to shun "impractical academic nonsense"
06:58:12 <JordiGH> kaiyin: I don't think the Galois functor has much to do with Haskell, to be honest. I'm not even sure if Haskell has contravariant functors built-in. I believe the Functor typeclass only allows covariant functors.
06:58:14 <opqdonut> c_wraith: why bother with the f at all? Why not just "data ThingAndAccessor thing a where ThingAndAccessor :: (thing -> a) -> thing -> ThingAndAccessor thing a"
06:58:44 <c_wraith> opqdonut: because it lets you attack a Functor instance to things of kind * -> *, instead of kind *
06:58:48 <c_wraith> err.  attach
06:58:56 <quchen2> Yoneda and CoYoneda are pretty interesting. They allow you to make any (*->*)-kinded type constructor a Functor.
06:59:26 <opqdonut> c_wraith: I don't see how my thing doesn't do that, you just have to give a param to the * -> *
06:59:42 <tongcx> kaiyin: Maybe and Tree are easier Functor, IO.Monad is quite interesting Monad, you can take a look
06:59:53 <opqdonut> c_wraith: maybe the functor instance is useful in combination with some other stuff, but standalone it seems weird
06:59:58 <c_wraith> opqdonut: It just turns out to be really helpful in practice.
07:00:10 <c_wraith> opqdonut: and yes, it's entirely because of the Functor instance
07:00:36 <opqdonut> hmmh, I guess the upside is you don't have to track the original contained type, b
07:00:48 <benzrf> why does 'instance Foo a b c => Foo a b (f c)' not satisfy fundep 'c -> a b'
07:00:59 <c_wraith> opqdonut: like, you can use it with Free to make anything of kind * -> * a monad.  That's equivalent to what the operation library does.
07:01:00 <JordiGH> And now, I want a simple (not mind-bending) example: I have a flat list of numbers xx, which represents a list of of lists of numbers yy. The first number in xx says how big the first element of yy is, and the elements of yy follow the first element of xx. Then the next element of xx is the the size of the second element of yy, and is followed by the elements of the second element of yy. For example, [2, 42, 69, 5, 24, 24, 24, 24, 7] -> [[42, 69
07:01:00 <JordiGH> ], [24, 24, 24, 24, 7]].
07:01:10 <JordiGH> Let me repeat that last part.
07:01:11 <tongcx> benzrf: yep, i like this environment a lot
07:01:13 <c_wraith> operational.  I'm bad at typing this morning
07:01:19 <JordiGH> [2, 42, 69, 5, 24, 24, 24, 24, 7] -> [[42, 69], [24, 24, 24, 24, 7]].
07:01:36 <JordiGH> I'm trying to learn how to parse an ad-hoc file format.
07:01:40 <JordiGH> How do I do this in Haskell?
07:02:00 <c_wraith> JordiGH: using something like Parsec is usually your best bet
07:02:01 <sleepomeno> I'd like to communicate with a local nodejs server, what haskell library can you recommend for interprocess communication?
07:02:35 <frerich> sleepomeno: I'd look at http://www.serpentine.com/wreq/
07:02:35 <JordiGH> c_wraith: I'm trying to learn. I don't want to give everything to a parsing library. I want to know how to do this from first principles. It's such a simple format, that I think this should be easy to do without Parsec.
07:02:44 <kaiyin> merijn: Const receives two type vars, while it's constructor receives only one param, what does that mean? I am confused.
07:03:24 * hackagebot blunt 0.0.10 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.10 (fozworth)
07:03:26 <c_wraith> JordiGH: The thing is, parsing is *not* simple in the real world.  There are all kinds of special cases.  Parser combinator libs give you a clean way to express all the special cases.
07:03:40 <JordiGH> c_wraith: I shouldn't have said "parse", please forget that part.
07:03:52 <zinfandel> JordiGH: If the purpose is to learn you can build your own parsing combinators.
07:03:53 <JordiGH> c_wraith: I'm trying to learn how to do a for loop in Haskell.
07:04:19 <zinfandel> JordiGH: You don't do a for loop in haskell :)
07:04:22 <exio4> JordiGH: for loops don't make sense in haskell, though, a for loop can be pretty much anything
07:04:30 <c_wraith> loops in haskell tend to just be lazy lists
07:04:31 <JordiGH> So, you're looking at a list of numbers, the first number says, "read the next n numbers into the first list", you read the next n numbers into list 1, then you read another number, and it says "read the next m numbers into list 2".
07:04:40 <JordiGH> zinfandel: whatever I'm supposed to do instead of a for loop.
07:04:42 <JordiGH> How do I do it?
07:05:00 <lieven> JordiGH: for your problem, something like foo (x:xs) = (take x xs):foo (drop x xs) with foo [] = []
07:05:38 <merijn> kaiyin: The second is a "phantom type" (i.e. it "doesn't have a body")
07:05:47 <zinfandel> Yeah, often it's just a recursion
07:06:06 <merijn> kaiyin: Consider "data Either a b = Left a | Right b", the type of Left has two type parameters, despite only having one argument, right?
07:06:30 <kaiyin> merijn, ah, yes.
07:06:33 <JordiGH> > foo (x:xs) = (take x xs):foo (drop x xs) with foo [] = []
07:06:33 <merijn> You can think of the Const type as a "type-level" const function
07:06:34 <lambdabot>  <hint>:1:12: parse error on input ‘=’
07:06:37 <merijn> > const 2 'a'
07:06:38 <lambdabot>  2
07:06:39 <JordiGH> lieven?
07:06:49 <merijn> kaiyin: Like "const" it just disregards it's second argument
07:07:14 <kaiyin> ok
07:07:17 <JordiGH> lieven: I don't understand, assuming I can fix it so it parses, how is your proposed example counting?
07:07:17 <lieven> JordiGH: it was meant as a hint or pseudocode
07:07:22 <merijn> kaiyin: But, since Functor is defined on the last parameter (i.e., it's "Functor (Const a)", not "Functor Const") that's what makes the instance funny/weird
07:07:36 <JordiGH> How do I translate "read the next n numbers from this list"?
07:07:44 <merijn> "fmap :: (a -> b) -> Const c a -> Const c b"
07:07:48 <kadoban> JordiGH: That was intended to be a piecewise defined function, the end part is separate.
07:07:57 <zinfandel> > take 2 [1,2,3,5]
07:07:59 <lambdabot>  [1,2]
07:08:02 <JordiGH> Could someone build me a complete example?
07:08:25 <JordiGH> In whatever seems most natural and readable to you.
07:08:40 <frerich> JordiGH: Do you know some other programming language, say - Java, or C?
07:08:43 <JordiGH> *Readable* being what I really am looking for.
07:08:58 <lpaste> ProofTechnique pasted “JordiGH” at http://lpaste.net/2253629671616806912
07:08:58 <JordiGH> frerich: I know Python, Java, C, javascript, LaTeX, Matlab, R.
07:09:24 <benzrf> pleeeeassse help: why does 'instance Foo a b c => Foo a b (f c)' not satisfy fundep 'c -> a b'
07:09:27 <frerich> JordiGH : If it's the "How do I do this without for loops?" part which is giving you a headache, then you could first try to implement it without for loops in some language you're familiar with. Say, Python.
07:09:37 <JordiGH> frerich: Done. Next what?
07:09:46 <frerich> JordiGH: How did you do it?
07:09:47 <benzrf> frerich: sounds like a bad way of doing it to me
07:09:52 <kaiyin> merijn: So, basically, in this case, fmap f = id, correct?
07:09:55 <benzrf> frerich: i dont think that that would help much
07:10:05 <merijn> kaiyin: Well, that won't typecheck (try it!)
07:10:06 <benzrf> JordiGH: it's possible that you're breaking down the problem wrong at a higher level
07:10:19 <benzrf> JordiGH: have you tried backing up even further and trying to think about it functionally?
07:10:20 <frerich> benzrf: It helps with separating the "How can I do things without mutation" part from the "How do I write it in Haskell" part.
07:10:21 <merijn> id :: Const c a -> Const c a
07:10:26 <ProofTechnique> JordiGH: foo [1..10] = [[2],[4,5,6],[8,9,10]]
07:10:44 <JordiGH> benzrf: I don't care. I want to solve the exact problem I  asked for. Let me see if I can understand the proposed solution.... the "drop" there seems a bit weird.
07:11:23 <merijn> kaiyin: "fmap f (Const x) = Const x" <- the pattern + new constructor are needed to change the phantom type
07:11:55 <merijn> kaiyin: Now, check that it obeys the functor laws (i.e. "fmap id x == x" and "fmap (f.g) == fmap f . fmap g"
07:12:05 <kadoban> JordiGH: Seems weird why?
07:12:34 <JordiGH> ProofTechnique: Okay, so what's the efficiency of this? If I read a few gigabytes of numbers in this format, is this the most efficient way?
07:12:35 <merijn> kaiyin: Then consider the following question, can you make "Const a" an instance of Applicative? Why/why not? Which laws would it violate if it's not possible?
07:12:47 <JordiGH> ProofTechnique: I have a hard time understanding what is getting allocated when.
07:13:25 <ProofTechnique> How big are your numbers getting?
07:13:48 <ProofTechnique> I think laziness should keep the footprint fairly small
07:14:01 <ProofTechnique> Why not try it and profile?
07:14:21 <JordiGH> ProofTechnique: Is it really so impossible to understand what this is going to compile into?
07:14:29 <JordiGH> I have to profile? There's no way to know in advance/
07:14:30 <JordiGH> ?
07:14:35 <ProofTechnique> JordiGH: No, I just don't personally know.
07:14:54 <JordiGH> How can you use a programming language without having an idea of what is efficient and what isn't? :-(
07:14:58 <kadoban> JordiGH: One problem with analyzing the efficiency of this is…you're not specifying how you're creating the [Int] list or how you're using it, so it's not very easy to analyze.
07:15:00 <merijn> It is possible to know in advance
07:15:19 <merijn> But not from half-specified data
07:15:24 <ProofTechnique> JordiGH: I have ideas about what's efficient and what's not. I just don't know about your use case.
07:15:38 <frerich> JordiGH: That doesn't compile into anything actually, since 'foo' isn't used. And even *if* foo is used - it might be that it doesn't even process the entire input list.
07:15:40 <JordiGH> merijn: what's the O(n) of this function? You don't need more data than this.
07:15:59 <JordiGH> ProofTechnique: What is the O(n) of this function in running time and memory?
07:16:06 <JordiGH> Er, the big-Oh.
07:16:11 <JordiGH> Is it O(n)?
07:16:33 <zinfandel> JordiGH: We don't know if the list passed to foo is evaluated
07:16:48 <merijn> I didn't pay attention to which function is being discussed
07:17:00 <JordiGH> So you're trying to weasel into saying the running time is zero because the function might never get executed?
07:17:23 <ProofTechnique> merijn: http://lpaste.net/2253629671616806912
07:17:28 <merijn> No, it depends on the function
07:17:48 <zinfandel> JordiGH: Look. If you use foo in a certain way then your file would be parsed during the execution of foo
07:17:53 <merijn> N^2
07:18:10 <merijn> Not quite sure about that
07:18:27 <m0rphism> really?
07:18:34 <frerich> I'd say it's O(n).
07:19:03 <zinfandel> O(n) seems more likely
07:19:11 <merijn> Actually, not N^2, it depends on the values of 'x'
07:19:33 <merijn> So probably O(n) with an awful constant factor
07:19:50 <m0rphism> If you force evaluating all items of the resulting list, i.e. by printing it to the terminal, it should be O(n), having a slightly higher constant factor because of lazy evaluation.
07:19:54 <exio4> you traverse the list twice, though, once for "taking" and another one for "dropping"
07:19:56 <frerich> You're looking at each element of the input list twice (once in 'take' and once in 'drop'). That doesn't seem too awful to me.
07:20:04 <merijn> m0rphism: Constant factor isn't due to lazy eval
07:20:23 <merijn> m0rphism: Well, maybe indirectly
07:20:24 <lieven> JordiGH: in a lazy language, that isn't weaseling out. As a famous example, fibs = (1:2:zipWith (+) fibs (tail fibs)) defines the infinite list of fibonacci numbers. How many it allocates really depends on how many you use and how you use them.
07:20:29 <m0rphism> merijn: not completely, but also
07:20:30 <merijn> Repeated take + drop is costly
07:21:28 <merijn> I can't really find a good intro for reasoning about Haskell performance, though. The main trick is to understand how laziness evaluates
07:21:38 <m0rphism> merijn: true, the true traversals are probably more important
07:21:40 <merijn> But I don't know of any good resources for that
07:21:48 <JordiGH> lieven: I still think you're trying to not answer the question. Of course that fibs function is O(n) if you take n elements of that list.
07:21:48 <m0rphism> merijn: s/true/two/
07:22:09 <merijn> This is a starting point: http://www.vex.net/~trebla/haskell/lazy.xhtml
07:22:13 <JordiGH> lieven: But people are being like "uhhhhh, well technically" and being deliberately obtuse.
07:22:23 <zinfandel> I quite liked this article as a way to understand lazy evaluation https://hackhands.com/lazy-evaluation-works-haskell/
07:22:34 <JordiGH> lieven: https://xkcd.com/1475/
07:22:45 <merijn> JordiGH: The answer was already given: it's O(N), but probably with a pretty poor constant factor
07:23:01 <JordiGH> merijn: Yeah, thanks. I'm just frustrated with the initial "well technicallY" answer.
07:23:09 <exio4> you could use splitAt
07:23:12 <exio4> @type splitAt 
07:23:13 <lambdabot> Int -> [a] -> ([a], [a])
07:23:20 <m0rphism> I'm frustrated, too...
07:23:20 <zinfandel> @src splitAt
07:23:21 <lambdabot> splitAt n xs = (take n xs, drop n xs)
07:23:21 <exio4> > splitAt 5 [1..20]
07:23:23 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
07:23:30 <zinfandel> exio4: See the source
07:23:38 <exio4> zinfandel: it's a bit more efficient, actually
07:23:38 <merijn> JordiGH: The problem is that due to laziness the complexity of a function can't always (can't usually) be computed "stand-alone"
07:24:06 <kadoban> zinfandel: @src isn't definitive, it's just a manually written file that has sourcecode that's rarely what's actually used.
07:24:12 <exio4> zinfandel: @src is not posting the real source code for what it is worth
07:24:35 <m0rphism> JordiGH: you have to add the assumption that each element of the list is actually used in the end for some IO, or nothing is evaluated at all
07:24:39 <kadoban> zinfandel: It should be taken only as "this is one way it might have been written…maybe"
07:24:56 <JordiGH> m0rphism: This is still a "well technically" response.
07:25:01 <igniting> Chapter 2 of "Parallel and Concurrent Programming in Haskell" also gives good intro to laziness in Haskell
07:25:15 <merijn> JordiGH: In a strict language you can always look at the internals and know exactly how costly it is, but in haskell applying a VERY expensive function a billion times is cheap if you only look at one of them. To get a good understanding of what actually works I recommend reading up on *exactly* how expressions are forced
07:25:31 <m0rphism> JordiGH: No it's not. It's the only correct response. If you add that assumption you get O(n). But that's the answer to a different question.
07:25:33 <igniting> specially the "sprint"
07:25:38 <JordiGH> Argh, people, I know the function might never get evaluated.
07:25:41 <merijn> JordiGH: This gives a good intuition for "cost"
07:25:41 <JordiGH> That wasn't the point at all.
07:25:53 <JordiGH> Man, this is why it's so hard to talk to Haskellers.
07:25:54 <JordiGH> ttyl
07:25:56 <merijn> JordiGH: I'm not talking about whether a function gets evaluated
07:25:58 <ProofTechnique> What was the point?
07:26:21 <zinfandel> kadoban, exio4: Good to know, I now took a look at actual source and it seems to be much more optimized.
07:26:25 <ProofTechnique> http://c2.com/cgi/wiki?HostileStudent
07:26:40 <m0rphism> that's appreciation of my time, wow
07:31:18 <m0rphism> ProofTechnique: "A hostile student is someone who will say PleaseDoMyHomeworkForMe ... OR ELSE!! " ;)
07:31:40 <frerich> Well, I guess people here (me included) didn't handle it in the most effective manner possible either.
07:33:39 <m0rphism> frerich: yep, because we had to establish a consense first. No idea why people would expect to get textbook answers for free from an IRC channel even if they show themselves unappreciating.
07:37:01 <cfoch> Hi. When I want to use the functions in a module I use <<<setContext [IIModule $ mkModuleName "AModule"]>>> What would you do If you don't know the names of the modules, but you know the file path of the Haskell file?
07:40:42 <Javran> when I compile (foo+bar) it end up with (GHC.Num.+ @ GHC.Types.Int GHC.Num.$fNumInt foo bar) in core, I can understand this except for "GHC.Num.$fNumInt", what exactly is it?
07:40:45 <dncr> If you add strictness annotations to your data types, isn't -funbox-strict-fields always then a good idea?
07:42:09 <ProofTechnique> Javran: My understanding is that it's the dictionary for the Num instance of Int
07:42:16 <ProofTechnique> Roughly
07:42:21 <geekosaur> Javran, I think that's a typeclass dictionary?
07:42:25 <geekosaur> yeh
07:42:27 <dncr> It seems like it's always inefficient to have an extra level of indirection in the memory layout when there isn't one in the way it'll be used. Right?
07:43:42 <geekosaur> basically GHC.Num.(+) is a function which takes a typeclass dictionary as one of its parameters, so it can dispatch to the appropriate implementation. in theory this should get optimized away since the appropriate dictionary entry is known at compile time, but I don't know details
07:44:33 <geekosaur> (there's a reason that in "(+) :: Num a => a -> a -> a", the "Num a =>" looks vaguely like a parameter on first look. it actually *is* one)
07:45:07 <Javran> I see
07:45:33 <kaiyin> merijn: http://fs2.directupload.net/images/150323/rtvxvjjx.jpg I think it's a valid functor.
07:46:29 <Javran> so it's like (forall a.Num a => a -> a -> a), with the "a" being Int, and $fNumInt somehow corresponds to "Num a"?
07:48:05 <dncr> But dons says here that boxed strict types "are often useful": http://stackoverflow.com/questions/3131554/what-is-the-relationship-between-unboxed-types-and-strictness
07:48:14 <dncr> I'm trying to imagine how..
07:48:14 <geekosaur> specifically $fNumInt is a dictionary containing pointers to the Num methods instantiated for Int
07:48:50 <merijn> kaiyin: Right (incidentally, in haskell parametricity means that you only need the "fmap id == id" law to prove both functor laws)
07:49:07 <geekosaur> you can think of it as a map fromList [((+),intAdd#),(-),intSub#),..]
07:49:11 <merijn> kaiyin: Like I said, the next challenge is to see if it can be Applicative and why/why not :)
07:49:17 <Javran> yeah
07:49:23 <zinfandel> Javran: Take a look at this: https://youtu.be/6COvD8oynmI?t=18m
07:49:26 <kaiyin> merijn: yes, I am working on that.
07:49:48 <dncr> Maybe this is somehow related to optimizations that can be done only on boxed types. Perhaps ghc is smart enough to make the best boxing decisions if you just put in the strictness annotations..
07:50:33 <Javran> zinfandel: thanks for the link!
07:50:34 <merijn> dncr: There is a strictness analysis that tries to unbox things like Int, yes
07:51:13 <zinfandel> Javran: I was quite surprised with the timing of your question. Just 20 minutes after I watched this video, which answers your exact question :)
07:51:14 <merijn> dncr: unboxed types can't be polymorphic, as dons' answer points out
07:52:18 <Javran> zinfandel: now I get surprised about this coincidence as well :)
07:53:07 <dncr> merijn: Right. I guess I'm mostly wondering if I should be explicitly unboxing my nonpolymorphic types for performance in places where I already know I want strictness. Or just leave it up to ghc to decide. But it seems to me like unboxed is always better in these cases.
07:53:27 * hackagebot scroll 1.20150323 - scroll(6), a roguelike game  http://hackage.haskell.org/package/scroll-1.20150323 (JoeyHess)
07:54:12 <merijn> dncr: Profile and see? ;)
07:54:46 <dncr> merijn: If I ever find a case where boxed is faster, that will be very informative. If I never do, I'll still wonder.. :)
07:57:28 <dncr> Perhaps with a boxed strict type T, you can sometimes have t1 :: T and t2 :: T that are equal and reuse the same pointer.
08:00:46 <kaiyin> merijn: I think it's also a valid applicative.
08:01:11 <kaiyin> vacuously so.
08:03:04 <merijn> Oh?
08:03:18 <merijn> kaiyin: What is the implementation of pure? :)
08:03:27 <kaiyin>   pure a = Const1 x
08:03:32 <kaiyin>   Const1 x <*> Const1 x = Const1 x
08:04:00 <merijn> kaiyin: Where does 'x' come from in pure? And which of the two x's are you using in <*>?
08:04:14 <merijn> Does that obey the Applicative laws? :)
08:05:11 <merijn> "f <$> pure x <*> pure y" should be the same as "pure (f x y)", for example
08:06:23 <kaiyin> instance Applicative (Const1 x) where;   pure a = Const1 x;   Const1 x <*> Const1 x = Const1 x
08:06:44 <chpatrick> kaiyin: where is the x from?
08:06:48 <merijn> kaiyin: How do you create values of type 'x'?
08:06:50 <fizruk> dependent types :)
08:07:00 <chpatrick> or you say Monoid x => Applicative (Const1 x)
08:07:04 <merijn> fizruk: Then it'd still be wrong
08:07:05 <chpatrick> and then it's mzero
08:07:07 <merijn> chpatrick: Spoilers!
08:07:11 <chpatrick> sorry
08:07:15 <merijn> chpatrick: I was leading up to that >.>
08:07:17 <chpatrick> *mempty
08:07:21 <chpatrick> sorry mate
08:07:57 <kaiyin> x can be anything.
08:08:12 <merijn> kaiyin: That's not valid haskell though, and certainly doesn't obey the laws :)
08:08:28 <merijn> kaiyin: Consider my "f <$> pure x <*> pure y == pure (f x y)" law :)
08:08:29 <fizruk> merijn: yeah, but we could fix definition for <*> and it'd be ok, I guess
08:08:59 <merijn> kaiyin: Because if 'x' is *any* value, then those two are not necessarily the same, while the Applicative laws demand that they are
08:09:28 <kaiyin> what about this: instance Functor (Const1 a) where;   fmap f (Const1 a) = Const1 a
08:09:39 <kaiyin> is this valid haskell?
08:09:40 <merijn> kaiyin: So we need to 1) create values out of thin air and 2) somehow combine them without violating Applicative laws
08:09:51 <merijn> kaiyin: Yes, because you're getting an 'a' as input argument to fmap
08:10:06 <merijn> kaiyin: You're not creating one out of thin air
08:10:22 <kaiyin> Oh, I see what you mean. 
08:10:47 <kaiyin> then this means pure cannot be properly defined in this case.
08:10:53 <merijn> kaiyin: As chpatrick just spoiled, the two properties I just mentioned should sound similar to Monoid
08:11:25 <merijn> kaiyin: Correct, but now consider: "instance Monoid c => Applicative (Const c)", can you implement that one without violating the laws? :)
08:11:28 <kaiyin> ok, I have not reached the monoid moment yet.
08:18:00 <kaiyin> merijn: so a monoid is a bunch of elements closed under an operator, obeying associativity, with a unit element.
08:18:21 <kaiyin> how does that change anything here?
08:19:16 <kaiyin> when you define pure a, you need to call the constructor, and you don't know what the constructor is exactly anyways.
08:19:31 <merijn> "pure _ = Const1 mempty"?
08:21:04 <merijn> Note, that with "Const1 x <*> Const1 y = Const1 (x <> y)" we can easily see that "f <$> pure x <*> pure y" -> "f <$> Const mempty <*> Const mempty" -> "Const mempty <*> Const mempty" -> "Const (mempty <> mempty)" -> "Const mempty"
08:21:21 <merijn> Whereas "pure (f x y)" -> "Const mempty", therefore, those two are now the same
08:21:44 <merijn> Proving that all Applicative laws hold is a bit too much work for this channel (exercise for the reader ;)), but they do hold :)
08:23:25 <kaiyin> merijn: interesting.
08:25:08 <merijn> kaiyin: The additional further step past proving the Applicative laws (which would be an excellent exercise to do!) would be consider the following: Const is a functor, Const + Monoid is an Applicative, is there a way to make Const a monad?
08:26:02 <dashed> anyone know of a good monad tutorial for someone with a background in c/javascript?
08:26:46 <hodapp> dashed: why are you trying to explain monads to the poor soul?
08:27:06 <kadoban> dashed: As-in you're trying to learn haskell and think learning monads is a good way to do that, or you know haskell and are having some kind of trouble with monads, or something else?
08:27:47 <merijn> dashed: My advice: Forget "learning monads"/worrying about them, they're not something you learn directly. My N step advice is:
08:27:47 <dashed> learning haskell
08:27:49 <kaiyin> merijn: mempty is polymorphic?
08:28:00 <dashed> I'm sorta confused on monad chapters in http://learnyouahaskell.com/
08:28:25 <Iceland_jack> dashed: Do you understand Functor fully?
08:28:46 <merijn> dashed: 1) Learn types/type signatures, 2) learn typeclasses, 3) learn specific monad instances and what they do (Maybe, [], State, etc.), 4) learn more of them, 5) stare at the laws and go back to 3, 6) repeat until you start to see a pattern when you squint
08:28:47 <dashed> sorta. "Mapping" functions over something of a type
08:29:14 <dashed> Mainly, I'm trying to use maybe monads for a course assignment.
08:30:06 <merijn> dashed: The real solution there is the grab a piece of paper and perform substitution on type signatures
08:30:12 <tdammers> dashed: what's the assignment? what have you tried so far? why do you think you need to use Maybe? why do you think you need to use Maybe's monad instance?
08:30:21 <dagnabbit> Are monads useful outside of functional/declerative programming? If I never plan on programming in Haskell or F# should I just ignore monads and go about my day?
08:30:28 <merijn> dashed: Let's say we have "(>>=) :: Monad m => m a -> (a -> m b) -> m b", how do we make this more tractable?
08:30:48 <dashed> are functors something i need to fully understand before tackling monads?
08:30:55 <tdammers> dagnabbit: like many concepts, I would say they can be useful in giving you some insights that will make you a better programmer eventually...
08:31:07 <merijn> dashed: Simple, we realise we are talking about Maybe, grab our paper and start substituting 'm' with 'Maybe': "(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b" <- look more tractable?
08:31:21 <merijn> dashed: Now consider what the specialised type signature means
08:31:22 <dashed> tdammers: the assignment is parsing subset of Racket language in haskell
08:31:40 <dashed> tdammers: I'm thinking of using maybe monads to do something like SyntaxError
08:31:40 <merijn> dagnabbit: Monads are everywhere in haskell because they're a nicely general pattern that occurs a lot in programming
08:31:48 <tdammers> dashed: that's quite a big one, enough to cover almost all of Haskell :x
08:32:07 <merijn> dagnabbit: I think a lot of people 1) overthink how complex they are and 2) how nice it is to have formal properties for datatypes/function
08:32:33 <tdammers> dashed: but anyway, forget about the "monad" part for now; just think about how you would use Maybe to encode syntax errors
08:33:14 <tdammers> e.g.: parseExpression :: String -> Maybe Expression -- yes?
08:33:19 <dashed> tdammers: to me maybe monads reminds me of "promises" in javscript
08:33:29 <dagnabbit> merign: But it seems like they are just a way to program imperatively in a functional language. I don't understand why I would want that in an imperative language.
08:33:46 <Iceland_jack> dagnabbit: They're not
08:33:54 <chpatrick> promises are monads though
08:33:59 <merijn> dagnabbit: I mean, really a Monad consists of the following things: 1) a parameterised type, 2) a way to lift values into the parameterised type ("return :: a -> m a") and 3) a way to compose functions that return that type "(a -> m b) -> (b -> m c) -> a -> m c" that obets several laws
08:34:22 <dashed> chpatrick: ah really?
08:34:41 <dagnabbit> Does anyone know of any monad tutorials that doesn't require learning a new language?
08:34:42 <merijn> dagnabbit: The laws being that "return >=> f == f == f >=> return" (i.e. associativity and return being the identity)
08:34:44 <tdammers> dashed: yes. read what merijn just wrote
08:34:59 <chpatrick> dashed: a type is a monad if it has certain properties
08:35:11 <merijn> dashed: http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html
08:35:12 <dashed> tdammers: yeah. "parseExpression :: String -> Maybe Expression" seems what I may need
08:35:13 <chpatrick> dashed: and promises fit because you can transform them to make a new promise
08:35:15 <merijn> dashed: Basically promises
08:35:16 <chpatrick> same with maybe
08:35:27 <tdammers> dashed: OK, so you can do that while completely ignoring Maybe's Monad instance
08:35:30 <kaiyin> merijn: I have just checked that the Const1 functor does obey all Applicative laws.
08:35:38 <chpatrick> merijn: Async isn't a monad though
08:35:40 <chpatrick> not sure why
08:35:44 <dashed> tdammers: I don't follow.
08:36:05 <tdammers> dashed: you can write functions with that signature while completely ignoring the fact that Maybe is a monad
08:36:06 <chpatrick> you don't need to know anything about monads to use maybe
08:36:07 <merijn> chpatrick: Because Async + bind would be basically IO
08:36:29 <merijn> chpatrick: Probably a bad example, though
08:36:37 <chpatrick> I suppose
08:36:41 <sammex> Hello! How can I tell cabal to install packages that would be reinstalled separateley, so that other packages are not hurt?
08:36:50 <tdammers> dashed: List is also a monad, but most of the list stuff you typically do doesn't necessarily make use of this
08:37:11 <dashed> i see.
08:38:14 <kadoban> dashed: You only need the Monad instance of Maybe if you want to chain stuff together. Like if you start having a bunch of functions that are   :: a -> Maybe b   and you want to compose them together nicely. Which isn't out of the realm of posibility for sure, but…is not necessarily going to be true.
08:38:58 <uggwar> i'm having a hard time building a cross compiler for my rpi. anyone done it successfully?
08:39:02 <chpatrick> dashed: the use case for maybe is that you can write code assuming every maybe is a Just, and the Monad instance automatically takes care of the cases where it isn't
08:39:22 <merijn> dagnabbit: The point of monads is not so much that it lets you do imperative programming as it is that "imperative programming happens to nicely be described by monads", there are non-imperative uses of monads. The main idea is that having laws to reason about
08:39:27 <dashed> What I'm sorta confused on is how to combine >>= with pattern matching
08:39:38 <chpatrick> dashed: it pattern matches for you
08:39:41 <chpatrick> at least for maybe
08:39:43 <merijn> Not really
08:39:45 <merijn> Right
08:40:08 <tdammers> you don't really combine them - (>>=) is just another operator, and it doesn't introduce a pattern-matching context by itself
08:40:39 <sammex> Is there a channel about cabal?
08:41:27 <forgottenone> what is the complexity of concat in prelude O(n) or O(n^2)?
08:41:31 <tdammers> for Maybe, (>>=) does different things based on whether the left operand is Nothing or not, but that's not really pattern matching
08:41:56 <dashed> so if i have something like "parseExpr :: BaseExpr -> Maybe Expr", and in the body of one pattern match I do: "(parseExpr b)"
08:42:05 <dashed> would pattern match take care of >>=?
08:42:36 <tdammers> dashed: I don't understand what that would look like
08:42:44 <merijn> sammex: #hackage, but the answer is: create a sandbox in your project directory to install there
08:42:47 <merijn> forgottenone: O(n)
08:43:04 <forgottenone> merjin ok thanks
08:43:11 <sammex> Thanks, merjin
08:43:27 <merijn> sammex: "cabal sandbox init" in the directory with the cabal file should be sufficient
08:43:27 <frerich> @src concat
08:43:27 <lambdabot> concat = foldr (++) []
08:43:31 <tdammers> dashed: again, >>= is just another operator
08:44:57 <dashed> tdammers: generally I understand this: "Just something >>= parseExpr >>= parseExpr >>= blowupExpr >>= parseExpr "
08:45:18 <dashed> trying to figure out how to convert this into a recursive form
08:45:36 <tdammers> recursive?
08:45:55 <dashed> hmm...
08:46:20 <dashed> tdammers: to shed light. this is the starter code, and parseExpr is recursive: http://www.cs.toronto.edu/~liudavid/csc324/assignments/a2/Interpreter.hs
08:47:49 <dashed> I'm thinking if I should be doing (>>= parseExpr a)
08:49:01 <merijn> @undo do { cond <- parseExpr b; ifBranch <- parseExpr x; elseBranch <- parseExpr y; return (If b x y) }
08:49:01 <lambdabot> parseExpr b >>= \ cond -> parseExpr x >>= \ ifBranch -> parseExpr y >>= \ elseBranch -> return (If b x y)
08:52:48 <merijn> dashed: Does that make sense?
08:53:26 <Gothmog_> merijn: I think you meant
08:53:37 <Gothmog_> @undo do { cond <- parseExpr b; ifBranch <- parseExpr x; elseBranch <- parseExpr y; return (If cond ifBranch elseBranch) }
08:53:37 <lambdabot> parseExpr b >>= \ cond -> parseExpr x >>= \ ifBranch -> parseExpr y >>= \ elseBranch -> return (If cond ifBranch elseBranch)
08:54:38 <dashed> should I be reading right to left?
08:54:47 <chpatrick> nope
08:55:23 <chpatrick> but the things that look like assignments in do notation like foo <- bar  are actually bar >>= \foo ->
08:55:35 <chpatrick> so foo is really the parameter of the function you're binding to
08:57:20 <rasen> Hey guys! Does GHC support jvm FFI?
08:57:35 <dashed> I'm unsure if I'm interpreting this right
08:57:53 <dashed> are Compound and Atom somehow skipped?
08:58:36 <merijn> Gothmog_: oh, right
08:58:42 <merijn> Gothmog_: Typing is hard!
08:58:48 <dashed> I'm not familiar with what "return" does
08:58:55 <merijn> rasen: No, but you can probably fake it
08:58:55 <geekosaur> rasen, afaik ghc does not support the JVM at all. you may be thinking of ghcjs which is JavaScript?
08:58:57 <merijn> :t return
08:58:58 <lambdabot> Monad m => a -> m a
08:59:04 <Gothmog_> dashed: (>>=) on Maybe is really a simple function. It takes some value x :: Maybe a, and a function f :: a -> Maybe b. If x is Nothing, it returns Nothing. If it's Just v, it returns f v.
08:59:22 <merijn> rasen: JVM supports C FFI, Haskell has a C FFI, the usual approach is to combine these two facts
08:59:26 <chpatrick> dashed: you could call it applyIfJust
08:59:30 <Gothmog_> You can chain those to get some kind of fall-through.
08:59:38 <merijn> > return 'c' :: Maybe Char
08:59:39 <lambdabot>  Just 'c'
08:59:51 <merijn> dashed: Does that type + example make sense?
09:00:03 <chpatrick> applyIfJust :: Maybe a -> (a -> Maybe b) -> Maybe b
09:00:06 <rasen> thanks all
09:00:07 <EvanR> rasen: theres a package called java-bridge and it seems to work
09:00:19 <EvanR> it uses the C ffi and jni
09:00:20 <chpatrick> it's just that lots of different m's fit that pattern so you can generalize over all of them
09:00:31 <chpatrick> not just Maybe :)
09:00:56 <dashed> I think I'm getting it
09:01:04 <dashed> diagram from following helps: http://www.idryman.org/blog/2014/01/23/yet-another-monad-tutorial/
09:01:43 <merijn> dashed: See also
09:01:45 <merijn> @google you could have invented monads
09:01:46 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:01:46 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
09:02:27 <tdammers> the most important monad epiphany is that there is not a lot to them after all
09:02:41 <dashed> chpatrick: are you suggesting "applyIfJust" as a helper function? I can't find it on hoogle.
09:02:52 <dashed> merijn: thanks. I'll check it out.
09:03:07 <merijn> Also, Wadler's original paper is pretty readable...
09:03:22 <dashed> one thing I tripped on while reading learnyouahaskell was that the "do" notation came out of nowhere in input/output chapter.
09:03:33 <tswett> dashed: you're aware that you don't need to understand monads in order to use Haskell, right?
09:03:43 <tdammers> dashed: applyIfJust is a hypothetical function
09:03:44 <chpatrick> dashed: (>>=) == applyIfJust for Maybe
09:03:51 <merijn> http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
09:04:01 <tdammers> dashed: it doesn't exist as such, but you could write it as an exercise
09:04:05 <merijn> dashed: Yes, I'm kind of unhappy about that intro
09:04:23 <tdammers> dashed: you don't need to, though, because using (>>=) on Maybe ends up being exactly the same thing
09:04:26 <merijn> dashed: I prefer making people use >>= and return explicitly until they figure that out and THEN move to do-notation
09:04:50 <chpatrick> dashed: so for Maybe (>>=) is applyIfJust and return is Just
09:04:53 <merijn> dashed: This explains how do and >>= relate to eachother pretty well: https://en.wikibooks.org/wiki/Haskell/do_notation
09:05:03 <chpatrick> for promises >>= is transform and return is immediatePromise or whatever :)
09:05:19 <chpatrick> for lists >>= is concatMap and return x = [ x ]
09:05:48 <dashed> tswett: yeah I'm aware. I'm trying to understand some applications of monads.
09:05:51 <chpatrick> so you have a bunch of types where there is a return function and a >>= function that only differs in the specific m they operate on
09:07:33 <dashed> merijn: was this the example you mean? "parseExpr (Compound [Atom "if", b, x, y]) = parseExpr b >>= \ cond -> parseExpr x >>= \ ifBranch -> parseExpr y >>= \ elseBranch -> return (If cond ifBranch elseBranch)"
09:07:44 <merijn> dashed: Yeah
09:08:02 <dashed> hmm.. how do you wrap your head around the nested lambdas?
09:08:26 <merijn> dashed: Once you know how to write them, you simply stop writing them and use do-notation like I initially did ;)
09:08:50 <merijn> dashed: Lambda's scope as far right as possible, but in practice do-notation makes this look nicer. See the wikibook I linked a few lines back
09:09:10 <dashed> so do notation is just a nice way of yielding stuff?
09:09:20 <chpatrick> it's a nice way of binding stuff
09:09:26 <merijn> dashed: Do notation is just syntactic sugar for >>= and lambda's
09:09:33 <dashed> ah.
09:09:56 <merijn> Because, as you point out, with a big number of lambda's it becomes pretty ugly
09:10:32 <EvanR> basically more than 1 ;)
09:11:26 <lpaste> merijn pasted “various notations” at http://lpaste.net/128358
09:11:36 <merijn> dashed: Those 3 are identical
09:12:04 <dashed> ah http://pastie.org/private/woy5pdgtze75fiuvbzjdq
09:12:05 <merijn> The 2nd is just the first with more linebreaks and the 3rd is the 2nd but using do-notation to hide the lambda's
09:12:11 <dashed> i was about to ask if this was valid lol
09:12:20 <dashed> do notation is way nicer
09:13:04 <merijn> dashed: Agreed, but I tend to recommend not using it until you understand >>= sufficient to know how to write the same thing using >>= directly, because that gives a clearer picture to see what's going on (the implicit >>= everywhere in do notation)
09:13:17 <dashed> ah...
09:13:28 <merijn> Because else it's not obvious why that code short-circuits when "parseExpr b" return Nothing, for example
09:13:47 <merijn> While that is obvious if you look at "parseExpr b >>= \foo -> ..."
09:14:23 <dashed> ah i see
09:14:37 <dashed> so if Nothing is returned... everything below "cond <- parseExpr b" isn't "evaluated"?
09:14:56 <chpatrick> yep
09:15:37 <chpatrick> Just x >>= f = f x
09:15:37 <chpatrick> Nothing >>= _ = Nothing
09:15:47 <chpatrick> if you >>= from Nothing you can just return Nothing
09:16:09 <kaiyin> c_wraith: did you mean data Coyoneda f a = Coyoneda (b -> a) (f b)       rather than         data Coyoneda f a where Coyoneda (b -> a) (f b)
09:16:41 <dashed> merijn, chpatrick, tdammers: thanks so much! I think I'm understanding a lot.
09:18:30 * hackagebot concurrent-supply 0.1.7.1 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.7.1 (EdwardKmett)
09:18:48 <chpatrick> no worries
09:19:05 <dashed> also.. I noticed the "fail" in the monad type definition
09:19:08 <dashed> how does one use this?
09:19:22 <kadoban> dashed: As rarely as possible.
09:19:24 <meiji11> is it possible for ghc to bypass effectful computations if it decides their values aren't needed? I ask because my program is incorrect if I compile it with -O2 but works fine otherwise.
09:20:18 <chpatrick> dashed: it's there to handle pattern match failures in do notation
09:20:27 <chpatrick> but it doesn't really belong in Monad so it's considered harmful :)
09:20:35 <zinfandel> > fail "description" :: Either String a
09:20:37 <lambdabot>  *Exception: description
09:20:41 <dashed> so it would placed after the return?
09:20:49 <dashed> *would be placed
09:20:49 <zinfandel> > fail "description" :: Maybe a
09:20:50 <lambdabot>  Nothing
09:20:59 <chpatrick> what do you mean after the return?
09:21:01 <merijn> dashed: We prefer not too talk about fail >.>
09:21:09 <dashed> oh.. ok
09:21:09 <tdammers> dashed: "return" in Haskell has absolutely nothing to do with "return" in an imperative language
09:21:20 <merijn> dashed: It's the awful black sheep that should be excorcised post-haste
09:21:27 <tdammers> it means "return into the Monad", not "return from the function"
09:21:37 <chpatrick> do  { 5 <- return (2 + 2); return "all hail big brother" } :: Maybe String
09:21:38 <dashed> merijn: so I shouldn't bother looking more into it?
09:21:45 <chpatrick> > do  { 5 <- return (2 + 2); return "all hail big brother" } :: Maybe String
09:21:46 <lambdabot>  Nothing
09:22:18 <chpatrick> don't do that though :)
09:22:29 <EvanR> dashed: its a weird feature of the type class which doesnt really belong there
09:22:49 <kazagistar> (I still think the best name for it would be "const", but that is the name for return specialized for the reader monad)
09:23:06 <chpatrick> pure is fine I think
09:23:06 <merijn> dashed: I'm on a crusade to eliminate it from the Monad typeclass! :p
09:23:18 <dashed> ah.
09:23:27 <merijn> dashed: Basically, it's not really related to monads in general and mainly there for historical reasons and pragmatism
09:23:47 <dashed> is it possible for "return ..." to appear multiple times in a do block?
09:23:54 <merijn> dashed: Sure
09:24:03 <merijn> > return 5 ++ return 6
09:24:03 <kadoban> :t return
09:24:04 <lambdabot> Monad m => a -> m a
09:24:05 <lambdabot>  [5,6]
09:24:16 <chpatrick> there's nothing special about return, it's just a function
09:24:20 <merijn> Well, that wasn't a do block, but I'm lazy :p
09:24:22 <chpatrick> for Maybe it's the same as writing Just
09:24:38 <chpatrick> do { foo <- Just "foo"; Nothing; Just "bar" }
09:24:42 <kadoban> That's /all/ return means. If you give it an 'a' it'll give you an 'm a', that's it. So if you have a String and want a Maybe String, it's your friend. Otherwise…it doesn't do much.
09:25:05 <zinfandel> merijn: Ohhh. What about for example Parser Combinators, I use fail quite often to indicate a failure.
09:25:05 <mrkkrp> In optparse-applicative, how to make it take arbitrary number of free arguments? I've found only `argument' and `strArgument', but they parse only one argument.
09:25:07 <dashed> so return just wraps it in Just type
09:25:20 <merijn> zinfandel: Parsers are usually MonadPlus
09:25:32 <zinfandel> merijn: Oh, yeah. That's right.
09:25:32 <merijn> zinfandel: I'm okay with "fail = mzero" 
09:25:47 <chpatrick> the Just constructor yeah
09:25:48 <kadoban> dashed: In Maybe's instance of Monad, yep. Guess what it does in the list instance? Hint: a -> [a]
09:25:48 <merijn> I'm just not okay with fail in Monad :)
09:25:53 <chpatrick> but that's only for maybe
09:26:16 <dashed> is there a reason why "return" is named as such?
09:26:33 <merijn> dashed: Confusingly because it made "do notation read like imperative code!"
09:26:33 <c_wraith> kaiyin: no, it needs to be an existential..  in which case the GADT form is easier
09:26:38 <tdammers> dashed: "return a value into the monad"
09:26:45 <kadoban> dashed: It makes vague sense if you never knew about 'return' from procedural programming languages.
09:27:00 <chpatrick> it's completely different from return in imperative though
09:27:02 <merijn> dashed: In practice it seems to have actually resulted in making the confusion bigger :)
09:27:05 <chpatrick> except it's at the end of a do block a lot
09:27:14 <kadoban> merijn: Oh was that the actual goal? Ouch.
09:27:21 <tdammers> it is vaguely related to "setting the return value of a monadic function", but that's not exactly what it does
09:27:23 <dashed> chpatrick: does it ever appear between a <- b?
09:27:38 <kaiyin> c_wraith: indeed, this is valid haskell.
09:27:38 <chpatrick> yeah
09:27:48 <hiptobecubic> what would you call it? inject? lift?
09:27:48 <tdammers> do { a <- return 1; Just (a + 2) } :: Maybe Int
09:27:52 <tdammers> > do { a <- return 1; Just (a + 2) } :: Maybe Int
09:27:53 <lambdabot>  Just 3
09:28:08 <chpatrick> again it's just a function
09:28:14 <kadoban> hiptobecubic: 'pure' seems nice. And I think you'll be able to call it that once the applicative-monad-proposal happens I think?
09:28:19 <zinfandel> merijn: But MonadPlus's mzero doesn't let me specify a reason for failure :(. I guess that I should just use (mzero <?> "description")
09:28:25 <chpatrick> you can put anything to the right of <- as long as it's the given monad
09:28:34 <kaiyin> c_wraith: data Coyoneda f a where Coyoneda (b -> a) (f b) what does this mean exactly?
09:28:35 <zinfandel> But wait, wouldn't it result in 'fail'
09:28:38 <chpatrick> and return <whatever> will put the value in the current monad
09:28:44 <c_wraith> kaiyin: that was a typo
09:29:15 <kaiyin> c_wraith: what is the correct version?
09:29:17 <chpatrick> remember foo <- bar is the same as bar >>= \foo ->
09:29:21 <c_wraith> kaiyin: the one with the where
09:29:25 <chpatrick> and bar has to be m a
09:29:49 <c_wraith> kaiyin: err, rather...  data Coyoneda f a where Coyoneda :: (b -> a) -> f b -> Coyoneda f a 
09:29:59 <dashed> chpatrick: thanks. I understand now.
09:30:05 <m0rphism> kadoban: correct.
09:30:20 <c_wraith> kaiyin: that's a GADT
09:30:23 <dashed> would fully understanding functors be at all useful for using monads?
09:30:40 <tdammers> there is even less to functors than there is to monads
09:30:42 <kadoban> dashed: Functors ? I'd say…required almost.
09:30:51 <c_wraith> kaiyin: it needs some way to express that the b type is existential.  GADTs are the easier syntax for that
09:30:54 <zinfandel> dashed: Sure, it's useful to understand functors before going int monads.
09:31:03 <tdammers> but with monads being functors-and-then-some, I would say very much yes
09:31:23 <zinfandel> dashed: However, I am not sure if 'fully' is required.
09:31:52 <kaiyin> c_wraith: ok, looks like unfamiliar territory at the moment. will come back to it later.
09:31:54 <chpatrick> dashed: they'd help a little but they're super simple
09:31:57 <dashed> I ask because I was almost lost on how the instance definitions were defined in http://learnyouahaskell.com/functors-applicative-functors-and-monoids
09:31:59 <chpatrick> :t fmap
09:32:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:32:02 <chpatrick> that's it
09:32:09 <m0rphism> dashed: yes, since any monad is a functor. But it should suffice to know what they do for Haskell. The category theory is a bit more harder since it is more abstract.
09:32:26 <dashed> for something like "instance Functor Maybe where fmap f (Just x) = Just (f x) ..."
09:32:30 <dashed> is f a function?
09:32:45 <barrucadu> Yes
09:32:46 <barrucadu> :t fmap
09:32:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:33:27 <Iceland_jack> dashed: If we write down the signature of 'fmap', will that help
09:33:27 <Iceland_jack>     instance Functor Maybe where
09:33:27 <Iceland_jack>       fmap :: (a -> b) -> Maybe a -> Maybe b
09:33:27 <Iceland_jack>       fmap f (Just x) = Just (f x)
09:35:03 <dashed> heh. I think I got confused on what "f" is when reading "class Functor f where"
09:35:25 <chpatrick> if some f a is a Functor then you can turn it into an f b with a function a -> b
09:35:40 <chpatrick> or alternatively you can turn a function (a -> b) into a function (f a -> f b)
09:35:49 <chpatrick> depending on how you look at fmap :)
09:36:43 <dashed> Iceland_jack: thanks. that makes sense.
09:37:46 <kadoban> dashed: I think it was mentioned above, but remember not to spend too much time trying to learn this stuff in the abstract. Figure out the types, and use them in specific instances and soon it'll be hard to figure out which part was difficult to understand in the first place.
09:38:23 <kaiyin> is <*> right or left associative?
09:38:31 * hackagebot happstack-server 7.4.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.4.2 (JeremyShaw)
09:38:58 <dashed> kadoban: Yeah. I figured as much. It seems I shouldn't be looking too much into it to understand the application usage of monads.
09:39:07 <Iceland_jack> dashed: You can use that in code but you need to enable the InstanceSigs language extension by adding {-# LANGUAGE InstanceSigs #-} to the top of your file
09:39:22 <Iceland_jack> kaiyin: Left associative, like function application
09:39:25 <EvanR> kaiyin: left
09:39:31 <kaiyin> ok
09:39:34 <EvanR> you can see in ghci with :info (<*>)
09:39:39 <dashed> Iceland_jack: sorry. What code?
09:39:41 <Iceland_jack> kaiyin: You can check in GHCi
09:39:41 <Iceland_jack>     ghci> :i (<*>)
09:39:41 <Iceland_jack>     infixl 4 <*>
09:39:46 <Iceland_jack> dashed: Your source file
09:39:55 <kaiyin> Iceland_jack: cool.
09:39:56 <zinfandel> dashed: I agree with kadoban. Do not try learning the Monad concept in a shell. It's better to try to use different instances of Monad (Maybe/Either/List/Reader/Writer/State) and see how their Monadic behaviour is related to each other.
09:40:39 <Iceland_jack> dashed: It often helps me to see the type signature for class declarations
09:40:39 <Iceland_jack>     instance Functor [] where
09:40:39 <Iceland_jack>       fmap :: (a -> b) -> [a] -> [b]
09:40:39 <Iceland_jack>       fmap = ... oh this is just 'map' ...
09:40:55 <Iceland_jack> *for class methods
09:42:22 <kadoban> dashed: Oh also, typeclassopedia and the NICTA course are really great once you have kind of a basic understanding and want to enrich it.
09:42:52 <zinfandel> dashed: Also do not forget, that if something is a Monad it's also a Functor and Applicative
09:43:18 <dashed> kadoban: this? https://github.com/NICTA/course
09:43:41 <kadoban> dashed: Yep. I found it /quite/ difficult, but also rewarding.
09:43:49 <dashed> thanks will check it out
09:44:01 <kaiyin> > :t ($)
09:44:02 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:44:08 <Iceland_jack> :t ($)
09:44:08 <lambdabot> (a -> b) -> a -> b
09:44:26 <dashed> zinfandel: Ah. I'll keep that in mind.
09:44:46 <kaiyin> how does this thing ($) change the associativity direction?
09:45:06 <dashed> Iceland_jack: yeah it helps. I found out about :info
09:45:12 <kaiyin> Can't see any of that in its type sig
09:45:26 <dashed> thanks everyone. A lot of my confusion with regards to application of monad seems to be cleared up.
09:45:42 <zinfandel> dashed: So that instead of `return . f =<< a` you can write `fmap f a`
09:45:44 <kadoban> kaiyin: It's not in the type sig.  :info ($) in ghci will tell you.
09:46:34 <zinfandel> dashed: It's just that I previously had this mistake when I always thought only in terms of one of this typeclasses and didn't use them alltogether.
09:46:48 <dashed> zinfandel: I haven't encountered what =<< operation does yet.
09:47:00 <kadoban> :t =<<
09:47:00 <lambdabot> parse error on input ‘=<<’
09:47:06 <kadoban> Gah, I suck.
09:47:09 <geekosaur> ()
09:47:18 <geekosaur> :t (=<<)
09:47:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:47:26 <kadoban> :t (>>=)
09:47:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:47:41 <kadoban> dashed: Look similar? (it's just flipped)
09:47:46 <kaiyin> :i ($)
09:47:56 <geekosaur> no :i in lambdabot
09:48:12 <kaiyin> $) :: (a -> b) -> a -> b 	-- Defined in ‘GHC.Base’
09:48:25 <dashed> kadoban: oh interesting.
09:48:29 <kaiyin> from ghci, not very revealing.
09:48:43 <zinfandel> dashed: Ok. Keep going. Sorry for confusing you with scary symbols :)
09:48:48 <dashed> I thought it was a typo b/c I couldn't find that operator in learnyouahaskell
09:50:01 <kaiyin> oh, i see. the key is in infixr 0.
09:50:06 <Iceland_jack> kaiyin: Yes
09:58:06 <athan> Why isn't Data.List.NonEmpty something like `data NonEmpty a = Cons a (Maybe (NonEmpty a))`?
09:59:01 <EvanR> not necessary to bring in another data type (Maybe) for this
09:59:21 <EvanR> like we dont define Bool as Just () or Nothing
09:59:31 <Iceland_jack> That's basically Cofree Maybe
09:59:35 <tommd> athan: I suspect the plethora of functions operating over lists is compelling.
10:00:02 <tommd> How would one foldl over your definition of NonEmpty?  For the current definition folding is obvious.
10:00:09 <tommd> For yours its a custom recursive function.
10:00:13 <athan> EvanR: But, there isn't the list datatype, too. It's also more uniform
10:00:24 <EvanR> huh?
10:00:26 <athan> Iceland_jack: Oh okay, I'll ponder on that
10:00:37 <Iceland_jack>     data Cofree f a = a :< f (Cofree f a)
10:00:48 <athan> EvanR: The normal NonEmpty type is just a newtype with a manditory head over lists
10:00:55 <EvanR> which NonEmpty is that
10:01:24 <dashed> how does one use something like ":info" to look up instance definition for types?
10:01:36 <athan> tommd: Yeah I have a feeling that a lot would need reimplementation,, but the namespace is already repopilated in Data.List.NonEmpty
10:01:54 <athan> EvanR: `newtype NonEmpty a = a :| [a]`
10:02:09 <EvanR> thats not a newtype because it has two fields
10:02:23 <athan> erm... `data` :v
10:02:44 <Iceland_jack> I'm not sure if this helps but
10:02:44 <Iceland_jack>     pattern Sing :: a -> Cofree Maybe a
10:02:44 <Iceland_jack>     pattern Sing a = a :< Nothing
10:02:46 <athan> Iceland_jack: That's really cool :)
10:02:49 <EvanR> yeah i was thinking of data NonEmpty = One a | More a (NonEmpty a)
10:03:01 <tommd> athan True, I wasn't concerned with name space just re-implementation of functions that are already made to fuse well.  `foldl (a :| as) = foldl a as` vs `foldl (Cons a mbNE) = ???`
10:03:32 * hackagebot stylish-haskell 0.5.11.2 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.11.2 (JasperVanDerJeugt)
10:03:40 <EvanR> yeah a non empty list is a list too, the fact that its not empty might be more conveniently described as a property than a type
10:03:50 <EvanR> like "non zero integer"
10:03:53 <athan> tommd: Yeah, there would just need more case statements
10:04:09 <Iceland_jack>     pattern Cons :: a -> Cofree Maybe a -> Cofree Maybe a
10:04:09 <Iceland_jack>     pattern Cons x xs = x :< Just xs   -- for completeness
10:04:22 <EvanR> athan: well, unless you use a property to make sure the list isnt empty
10:04:31 <athan> EvanR: That's true, but type-level propositions aren't easy in haskell :\
10:04:38 <tommd> athan: Again, I understand that but am proposing a reason.  OTOH, we should probably not guess and just ask the author if curiosity warrants.
10:04:45 <EvanR> athan: well, NonEmpty isnt easy in haskell :)
10:04:51 <athan> Iceland_jack: That's what I was thinking
10:05:02 <athan> EvanR: It is with the maybe-sense! :P
10:05:10 <EvanR> uh ... talk about case statements
10:07:04 <Welkin> the maybe-sensei
10:07:57 <Iceland_jack> fromMaybe autodidacticism (maybeSensei :: Maybe Sensei)
10:08:22 <Iceland_jack> Forced jokes
10:09:31 <kaiyin> It looks awesome that a parameter can becomes function just like this: ($ x)
10:09:35 <kaiyin> :t ($ 5)
10:09:36 <lambdabot> Num a => (a -> b) -> b
10:18:14 <Elite6809> > (- 3) 5
10:18:15 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
10:18:15 <lambdabot>    arising from the ambiguity check for ‘e_135’
10:18:15 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
10:18:27 <Elite6809> > (3 -) 5
10:18:29 <lambdabot>  -2
10:18:39 <Elite6809> ((-) 3) 5
10:18:49 <Elite6809> > ((-) 3) 5
10:18:50 <lambdabot>  -2
10:22:23 <c_wraith> > (-3+) 5
10:22:25 <lambdabot>  2
10:23:31 <kadoban> Any good repa learning resources? I have the section of the parallel and concurrent book, and the 'numeric haskell: a repa tutorial' from the wiki, and not much else.
10:25:00 <athan> kadoban: cabal repl? :D
10:25:05 <breadmonster> Is there a good resource on continuation passing style?
10:25:11 <breadmonster> I don't get how it's an optimization.
10:25:29 <kadoban> athan: http://hackage.haskell.org/package/repa :)
10:25:58 <athan> kadoban: So you read that chapter on RePa, right?
10:26:33 <athan> From what I see, RePa is mainly used for uniform parallelism, like maps moreso than folds
10:27:00 <athan> but, with accelerate-repa, you can actually run accelerate-style gpu programming with repa
10:27:00 <kadoban> athan: Yeah, which seemed pretty good. I feel like I could maybe muddle through trying to actually use it, but I figured maybe there's more out there that would help
10:27:45 <athan> kadoban: https://hackage.haskell.org/package/repa-examples ?:D
10:27:58 <kadoban> athan: Mostly I just need pretty fast vector-ish stuff. I'm doing image processing, like canny and hough transform. I see a canny example in the repa-examples, so I figure this is somewhat on the right track.
10:28:20 <athan> http://repa.ouroborus.net/ :\
10:28:42 <athan> kadoban: Yeah sorry haha, I wish I was more help. I'm just giving you scraps :\
10:29:14 <kadoban> Naw, no worries. Thanks for trying. It's probably just time for me to get to it and try coding and see what happens.
10:29:38 <athan> :p
10:31:04 <akegalj> I cant figure out what is Data.Set used for in HashSet, data HashSet e = Data.IntMap.IntMap (Data.Set.Set e)   . So this data is tree of tries?
10:33:19 <quchen> akegalj: I don't see a trie there.
10:33:27 <shachaf> akegalj: It looks like a radix tree of balanced binary trees.
10:33:46 <shachaf> Assuming you also have a constructor.
10:33:49 <shachaf> But where does that definition come from?
10:34:55 <akegalj> quaestor: i said it wrong, i meant tree of binary trees as shachaf said
10:35:13 <akegalj> shachaf: definition is from hadock https://hackage.haskell.org/package/hashmap-1.0.0.2/docs/Data-HashSet.html
10:35:31 <shachaf> IntMap *is* a sort of prefix tree.
10:36:42 <akegalj> But what is Set used for?
10:37:20 <shachaf> Oh, it's their documentation which is wrong.
10:38:08 <akegalj> no
10:38:13 <akegalj> the source says newtype HashSet a = HashSet (I.IntMap (S.Set a)) deriving (Eq, Ord)
10:38:44 <shachaf> Yes. The source isn't wrong, but the documentation is a syntax error.
10:38:48 <kadoban> akegalj: Presumably it's the "bucket" that items go in. Otherwise, what happens if you add two items with the same hash that aren't equal?
10:38:57 <shachaf> Anyway, it's presumably used for grouping things that hash to the same thing.
10:39:30 <shachaf> Note that this package is deprecated.
10:39:30 <akegalj> shachaf, kadoban : yes that was my thought too, I just need confirmation
10:39:38 <akegalj> shachaf: just noticed that
10:40:20 <shachaf> Confirmation you can get from reading the code.
10:41:18 <akegalj> shachaf: i know, but i was not sure did I understed the code well
10:43:18 <Luke> seliopou: hey man great elm+d3 talk
10:43:30 <EvanR> wow. quickcheck is the shit. it found a legitmate mistake in my code
10:43:55 <Luke> EvanR: I never really find a case to use it. I use HUnit a lot
10:44:27 <EvanR> does HUint do Arbitrary-like stuff, and check instances of equational laws?
10:45:13 <nitrix> Hi, what is the operator am I looking for:   Nothing <?> Just 5 yields Nothing?
10:45:26 <EvanR> >>
10:45:31 <ReinH> nitrix: what do you want Just 3 <?> Just 5 to yield?
10:45:33 <Luke> EvanR: no but I never really know where I should use that
10:45:43 <EvanR> Luke: me neither, im figuring it out
10:45:48 <Welkin> > Nothing >> Just 5
10:45:49 <lambdabot>  Nothing
10:45:54 <Welkin> > Nothing <> Just 5
10:45:55 <lambdabot>  No instance for (GHC.Show.Show a0)
10:45:55 <lambdabot>    arising from a use of ‘M270361824267272407612645.show_M2703618242672724076...
10:45:55 <lambdabot>  The type variable ‘a0’ is ambiguous
10:46:04 <Luke> EvanR: my code is pretty StateT-heavy
10:46:09 <ReinH> <> won't work
10:46:10 <EvanR> > getFirst (First Nothing <> First (Just 5))
10:46:12 <lambdabot>  Just 5
10:46:24 <nitrix> > Just 5 >> Nothing
10:46:25 <lambdabot>  Nothing
10:46:28 <Welkin> what is the mappend definition for Maybe?
10:46:34 <nitrix> Is there an opposite version of >> ?
10:46:34 <arkeet> nitrix: what do you want Just 3 <?> Just 5 to yield?
10:46:43 <ReinH> Welkin: instance Monoid a => Monoid (Maybe a)
10:46:47 <arkeet> Welkin: it mappends Justs together.
10:46:56 <nitrix> :t flip . (>>)
10:46:57 <lambdabot> (b -> a) -> b -> (b -> b1) -> b1
10:46:59 <ReinH> <*
10:47:00 <EvanR> Luke: yurg
10:47:13 <ReinH> nitrix: We don't know what operator you want until you answer the question
10:47:16 <Luke> EvanR: sometimes you have to =)
10:48:31 <Welkin> > Just [5] <> Just [3]
10:48:33 <lambdabot>  Just [5,3]
10:48:38 <Welkin> > Just 5 <> Just 3
10:48:39 <lambdabot>  No instance for (GHC.Show.Show a0)
10:48:39 <lambdabot>    arising from a use of ‘M228198265612564670312734.show_M2281982656125646703...
10:48:39 <lambdabot>  The type variable ‘a0’ is ambiguous
10:48:50 <Welkin> > Just (Sum 5) <> Just (Sum 3)
10:48:51 <lambdabot>  Just (Sum {getSum = 8})
10:48:58 <Welkin> > Just (Sum 5) <> Just (Sum 3) <> Nothing
10:49:00 <lambdabot>  Just (Sum {getSum = 8})
10:49:01 <ReinH> Welkin: please experiment with lambdabot with /msg
10:49:22 <nitrix> I'm looking for ehhm....  (a -> f b) -> f a -> f b
10:49:23 <athan> ReinH: Sometimes the exposure helps newbs! ._.
10:49:28 <nitrix> I think.
10:49:38 <athan> :t (<*>)
10:49:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:49:48 <ReinH> nitrix: well, that's (=<<)
10:49:50 <athan> :t (>>=)
10:49:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:50:00 <ReinH> as long as f is Monad
10:50:17 <ReinH> athan: Yes, it's good to use lambdabot to demonstrate things
10:51:03 <athan> ReinH: Maybe there should be a #haskell-lambdabot channel, where people can just spam strange haskell patterns exemplified in lambdabot?
10:51:21 <athan> or #haskell-examples ?
10:51:37 <ReinH> athan: examples are fine, repeated slightly different uses of lambdabot are noisy
10:52:32 <athan> that's a good point, idk. When I was a newbie, lambdabot was gold for me
10:52:48 <athan> (really watching people use it)
10:53:40 * athan shrugs
10:53:49 <EvanR> nice, this law would be true if it wasnt for floats and an example float being 5.0e-324 ;)
10:54:19 <ReinH> EvanR: Just claim that it's morally true for floats and move on. Almost nothing is true for floats.
10:54:25 <EvanR> how?
10:54:39 <nitrix> Ah shit.
10:54:42 <nitrix> I found my problem.
10:54:53 <nitrix> <$> has higher precedence than =<<
10:54:59 <ReinH> "This law is no less valid for floats than any other result obtained by using floats" :p
10:55:25 <nitrix> a <$> (b =<< c)   works.
10:55:31 <nitrix> Quite ugly though.
10:56:30 <rola> the aforementioned elm-d3 talk: https://www.youtube.com/watch?v=pTlOLO7Qhls
11:01:43 <jle`> nitrix: how about fmap a . b =<< c
11:03:36 * hackagebot hedis-monadic 0.0.1 - A la MonadReader for Redis connection  http://hackage.haskell.org/package/hedis-monadic-0.0.1 (AlekseyUymanov)
11:03:55 <ReinH> jle`: er, I think that would be fmap a (b =<< c)
11:04:18 <jle`> :t \a b c -> fmap a . b =<< c
11:04:19 <lambdabot> (Functor m, Monad m) => (a1 -> b) -> (a -> m a1) -> m a -> m b
11:04:26 <jle`> :t \a b c -> fmap a (b =<< c)
11:04:27 <lambdabot> (Functor f, Monad f) => (a -> b) -> (a1 -> f a) -> f a1 -> f b
11:04:34 <jle`> it's the same
11:04:43 <jle`> oh
11:04:55 <jle`> maybe not. this is weird ><
11:06:10 <ReinH> Fixity makes it (fmap a . b) =<< c, which seems unnecessarily complex relative to fmap a (b =<< c)
11:06:30 <ReinH> and yes, they are the same, but not equal ;)
11:07:23 <jle`> i don't know, fmap a . b =<< c seems more easy to read for me
11:08:00 <jle`> it's like taking c through transformations.  take it through b, then take it through a
11:08:06 <ReinH> Well, the fixity makes it not obvious
11:08:41 <jle`> or take it through (fmap a . b), which is b, then a on the result of b
11:08:44 <ReinH> You have to know that =<< has low fixity to understand that expression
11:08:57 <ReinH> Which is what threw me for a second
11:09:26 <dolio> I don't think you need to know anything about =<< if you know something about .
11:09:33 <jle`> i guess i use (=<<) with (.) all the time
11:09:47 <jle`> i'll do `f . g =<< x` instead of `f =<< fmap g x
11:10:10 <Javran> a ghc question: can I get a list of current available instances out of ModGuts when compiling a Haskell module?
11:10:17 <jle`> f . g . h =<< x   etc.,  g and h are (a -> b)'s, and f takes it to a `m c` all at the end
11:10:39 <ReinH> Well, it's analogous to f . g . h $ x
11:10:50 <dolio> Oh, actually, I guess you do need to know a little about =<<.
11:10:53 <jle`> not if x :: m a
11:10:56 <nitrix> I'll stick with my parentheses. When I'll be more comfortable around Haskell, I predict this code will get a huge refactoring:P
11:11:00 <jle`> oh, analogous, yeah
11:11:16 <jle`> yeah, that's analogous. so the other eexample would be anlogous to fmap a . b $ c
11:11:42 <jle`> so it's a choice between f . g $ x vs. f $ g x, really
11:11:44 <ReinH> dolio: Oh, yeah, (.) is very high fixity
11:13:01 <kazagistar> I still find parens nicer anyways, unless there is a larger chain
11:14:10 <jle`> i guess it also depends on what's the more meaningful unit... (fmap f . g), or (g =<< x).  if (fmap f . g) is useful than the associativity of (.) becomes nice for refactoring and pulling things out and stuff
11:14:21 <ReinH> jle`: well, it's a choice between f . g $ x and f (g x), except that you can't use eta reduction, so one of the reasons you might choose composition isn't there.
11:15:00 <jle`> you can reduce (fmap f . g) =<< x to (fmap f . g)
11:15:07 <jle`> you just need to remember to (=<<) whatever you apply it to
11:15:14 <dolio> ReinH: Yeah. But it's infixr, so it would be possible for that to parse another way, with another infixr 9 operator.
11:15:23 <ReinH> dolio: right
11:15:28 <jle`> which isn't an unreasonable thing
11:15:29 <dolio> I thought it was l for a moment.
11:15:33 <jle`> you get a new (a -> m b)
11:15:49 <jle`> and you can use that (a -> m b) however you normally use (a -> m b)'s
11:16:04 <ReinH> Well, fmap f . g is a kleisli arrow, sure. Like you said, the meaning matters.
11:16:46 <jle`> yeah...i think the difference really is just the same as between f . g $ x and f (g $ x).
11:17:19 <jle`> but i can't really start a one man style revolution
11:20:47 <verement> does ($) ever incur an additional runtime cost over direct application?
11:22:09 <RyanGlScott> Not at runtime, since it's inlined: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#%24
11:22:32 <RyanGlScott> It might take slightly longer to compile, though.
11:24:30 <RyanGlScott> But it would probably not be noticeable.
11:28:10 <RyanGlScott> Hm, I just noticed something strange about the transformers library.
11:28:18 <RyanGlScott> Why does the Foldable instance for Backwards define foldr in terms of foldr, but foldr1 in terms of foldl1?
11:28:23 <RyanGlScott> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Applicative-Backwards.html
11:28:37 * hackagebot aws 0.11.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.11.3 (AristidBreitkreuz)
11:28:39 <osa1> "Template Haskell can be used to subvert module boundaries" <- how is this possible?
11:31:01 <shachaf> RyanGlScott: That's indeed odd. Looks like a bug to me.
11:31:19 <shachaf> Well, maybe not.
11:31:31 <shachaf> No, it's a bug.
11:31:42 <RyanGlScott> shachaf: I hope so, because that doesn't make any sense to me :)
11:32:31 <RyanGlScott> shachaf: What's the best way to report a bug in transformers? I don't think it's part of the core libraries, and I'm not sure if hub.darcs.net accepts pull requests.
11:33:05 <shachaf> Maybe contact Ross.
11:33:21 <RyanGlScott> Good idea.
11:33:51 <RyanGlScott> osa1: For example, you can call reify on an abstract ADT name and use its constructors, even though they aren't exported.
11:33:51 <geekosaur> osa1: not sure, but things that are not formally exported may still be exposed for inlining via the .hi file?
11:34:02 <ahammel> So, I'm tied into compiling on a build server with 4Gb RAM and no swap.
11:34:16 <ahammel> Is there a way to cap GHC's memory usage?
11:34:42 <osa1> hm so GHC has to put definitions of every inlinable function to .hi, right?
11:34:52 <geekosaur> ahammel: GHCRTS=-M1G ?
11:35:04 <geekosaur> osa1: doesn't have to, but often does
11:35:25 <osa1> geekosaur: but how else can it inline a function from a compiled library?
11:35:28 <geekosaur> cross-module inlining is pretty much the only reason ghc produces code that isn't glacial
11:35:34 <ahammel> geekosaur: thanks,
11:35:54 <geekosaur> osa1, there's no guarantee that something will be exposed for inlining
11:36:23 <osa1> well there's INLINE and INLINEABLE pragmas
11:36:48 <osa1> RyanGlScott: but wouldn't generated code fail in compile time?
11:37:06 <osa1> RyanGlScott: do you mean I can use the constructor in TemplateHaskell-execution time?
11:38:03 <RyanGlScott> osa1: For example, I exploit this in my text-show library.
11:38:25 <RyanGlScott> Even if an ADT doesn't export it's constructors (e.g., Permissions from the directory library), I can still use TH to derive a Show instance that pattern matches on its constructors.
11:38:38 * hackagebot hedis-monadic 0.0.2 - A la MonadReader for Redis connection  http://hackage.haskell.org/package/hedis-monadic-0.0.2 (AlekseyUymanov)
11:39:33 <RyanGlScott> reify gives you access to all of an ADTs' constructors for splicing purposes, and GHC doesn't require you to explicitly import the modules used in spliced code.
11:39:55 <osa1> RyanGlScott: whoa, amazing. can you point me the code that does this?
11:40:56 <RyanGlScott> osa1: It's not very interesting to look at, but you can see this in practice in text-show-instances: http://hackage.haskell.org/package/text-show-instances-0.3/docs/src/Text-Show-Text-System-Directory.html
11:41:08 <taktoa_laptop> anyone have any idea what's going on in here: http://lpaste.net/128364
11:41:10 <RyanGlScott> osa1: Let me see what $(deriveShow ''Permissions) splices real quick...
11:43:04 <RyanGlScott> osa1: Here is the splice in full, gory detail: http://lpaste.net/128365
11:43:52 <RyanGlScott> The import part is case value_a4qw of { System.Directory.Permissions arg1_a4q4 ... }, which requires using the Permission constructor, even though it's not imported.
11:44:37 <osa1> RyanGlScott: but why is generated code not failing with a compilation error?
11:44:52 <osa1> generated code has a pattern match on non-exported constructor
11:47:28 <osa1> RyanGlScott: am I misunderstanding it?
11:47:56 <geekosaur> because it's spliced directly in and TH has access to things that ordinary Haskell code doesn't
11:48:23 <geekosaur> you could say that this is taking advantage of an abstraction leak built into TH
11:48:39 <RyanGlScott> osa1: I believe TH looks up spliced functions from .hi files, not modules.  
11:49:25 <RyanGlScott> Allowing you to access anything that was compiled.
11:49:33 <osa1> and is this not a bug? let's assume I'm printing generated code to a file instead of passing it directly to GHC, and then running GHC on that file.
11:49:36 <osa1> it'd fail, right?
11:49:49 <RyanGlScott> Yes.
11:49:50 <osa1> this sounds horrible
11:49:53 <osa1> this sounds broken
11:50:14 <osa1> you can basically break all the abstraction barriers using TH.
11:50:24 <RyanGlScott> I'd use the term "unsafe". "Broken" is a bit too equivocal, since I use it to great success in certain scenarios.
11:50:52 <RyanGlScott> Er, I mean "unequivocal"
11:51:07 <RyanGlScott> For this reason, you can't use TH at all with the Safe extension enabled.
11:51:48 <osa1> right. interesting.
11:52:13 <osa1> I'd say broken if this is not the intended behavior. for example, was this planned for TH from the beginning?
11:52:39 <geekosaur> I dont think it was, but I also don't think it's easy to fix without making cross-module inlining unusable or pointless
11:52:54 <geekosaur> cross-module inlining pretty much is an abstraction leak by definition
11:53:22 <geekosaur> that it's visible to TH just proves that it's visible to Core --- which is necessary for it to work at all
11:54:32 <osa1> wait... so let's say I'm using a library and it doesn't have Core for some functions. that means I can't import those function using TH?
11:54:52 <osa1> (by doesn't have Core I mean it doesn't keep generated Core around)
11:54:59 <osa1> (like in a .hi file)
11:55:46 <geekosaur> osa1, the external interface for any Haskell module includes a .hi file
11:56:11 <geekosaur> if you're using something like plugins to dynamically load, it still looks for a .hi file so it can determine Haskell types
11:56:20 <osa1> OK but does that .hi file contain Core for every single function in the source module?
11:56:33 <geekosaur> not every single function. as I already said multiple times
11:56:54 <geekosaur> [23 18:34] <geekosaur> osa1: doesn't have to, but often does
11:56:59 <osa1> OK and I'm asking what happens if I try to reach that function in TH :)
11:57:01 <geekosaur> [23 18:34] <geekosaur> osa1, there's no guarantee that something will be exposed for inlining
11:57:30 <geekosaur> probably it fails. I think I mentioned the true-names package already, it mentions some caveats in its documentation
11:57:46 <geekosaur> (true-names exploits this TH behavior)
11:58:16 <geekosaur> I think most names are visible but not all definitions?
11:58:25 <RyanGlScott> osa1: You might also find this wiki entry ( https://wiki.haskell.org/Template_Haskell#What_can_reify_see.3F ) interesting, where it describes when reify might not get information.
11:58:32 <geekosaur> you can try the option to dump a .hi file to see what's in it
11:58:39 * hackagebot hedis-monadic 0.0.3 - A la MonadReader for Redis connection  http://hackage.haskell.org/package/hedis-monadic-0.0.3 (AlekseyUymanov)
11:59:23 <osa1> yeah.. from the wiki page it seems like it sometimes fails
12:00:02 <geekosaur> ghc --show-iface foo.hi
12:00:05 <osa1> I'm in shock right now. this sounds like a horrible design.
12:10:59 <NemesisD> hey folks. i tend to write packages with a -Wall -Werror flag for development. for some reason hackage is rejecting my packages for having a -Werror even though its under a flag. what gives?
12:11:18 <shachaf> Maybe the flag is turned on?
12:11:55 <bergmark> NemesisD: i don't know how hackage checks for this, but does your flag have `manual: True` ?
12:12:31 <NemesisD> bergmark: yep. 
12:12:45 <bergmark> ok :(
12:12:47 <EvanR> with quickcheck can you auto generate functions Double -> Double that have inverses
12:12:54 <lpaste> NemesisD pasted “lib-Werror” at http://lpaste.net/128368
12:12:57 <EvanR> like cube and cube root
12:13:16 <NemesisD> i  took the idea from lens. it uses the same flag name
12:13:18 <EvanR> ... ignoring NaN
12:13:39 * hackagebot atomic-write 0.2.0.1 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.2.0.1 (jsl)
12:16:05 <Welkin> > 0/0
12:16:07 <lambdabot>  NaN
12:17:02 <osa1> > 0/0 == 0/0
12:17:03 <lambdabot>  False
12:18:40 * hackagebot dotenv 0.1.0.6 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.6 (jsl)
12:18:42 * hackagebot pointful 1.0.6 - Pointful refactoring tool  http://hackage.haskell.org/package/pointful-1.0.6 (MikhailGlushenkov)
12:19:26 <Javran> > 0/0 /= 0/0
12:19:27 <lambdabot>  True
12:21:11 <Javran> > round (0/0)
12:21:13 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
12:21:22 <Javran> wat
12:22:00 <kadoban> Haha
12:22:06 <mmachenry> Woa
12:22:54 <Javran> hmm, I guess the behavior of rounding NaN is undefined
12:23:32 <EvanR> :(
12:23:36 <kadoban> Probably. It seems more like it should be an error of some kind instead of … that, but ehhh.
12:23:40 * hackagebot uri-bytestring 0.0.1 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.0.1 (MichaelXavier)
12:23:48 <EvanR> floats dont throw exceptions by default
12:23:59 <EvanR> but they can
12:24:11 <Javran> just tried in my local ghci, quite a big number actually
12:24:12 <rasen> really?
12:24:24 <EvanR> you can mess with your floating point environment using IO
12:24:30 <EvanR> globals
12:24:40 <hexagoxel> > round $ negate $ 0/0
12:24:42 <lambdabot>  2696539702293473861593957786183537100426965468413459859101451217365990137082...
12:25:03 <hexagoxel> undefined is fun :D
12:25:19 <kadoban> > length . show . round . negate $ 0/0
12:25:20 <lambdabot>  309
12:25:29 <kaidelong> > floor(0/0) == ceiling(0/0)
12:25:31 <lambdabot>  True
12:25:32 <nh2> @djinn Monad m => m (a -> b) -> m a -> m b
12:25:32 <lambdabot> -- f cannot be realized.
12:25:36 <kaidelong> I guess
12:25:42 <chpatrick> > decodeFloat (0/0)
12:25:43 <rasen> you know there are different NaNs?
12:25:43 <lambdabot>  (-6755399441055744,972)
12:25:45 <nh2> @djinn m (a -> b) -> m a -> m b
12:25:45 <lambdabot> -- f cannot be realized.
12:25:50 <kaidelong> that's another way to check for NaN although it will work on any integer too
12:25:58 <alynn> nh2: djinn isn't very good with constraints
12:26:02 <Javran> :t isNaN
12:26:03 <lambdabot> RealFloat a => a -> Bool
12:26:08 <alynn> or higher-kinded types anyway
12:26:10 <hexagoxel> :exf "Monad m => m (a -> b) -> m a -> m b"
12:26:10 <exferenceBot> \ b c -> b >>= (\ g -> fmap g c)
12:26:11 <exferenceBot> \ b c -> c >>= (\ g -> fmap (\ k -> k g) b)
12:26:13 <alynn> :t ap
12:26:14 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:26:23 <nh2> alynn: I want to get point-free `ap`
12:26:24 <Javran> we have primitives for checking NaN anyway
12:26:28 <hiptobecubic> "exferenceBot" ?
12:26:29 <kaidelong> Javran: I don't think Javascript has isNaN though
12:26:31 <alynn> @src ap
12:26:31 <lambdabot> ap = liftM2 id
12:26:36 <alynn> @src liftM2
12:26:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:26:40 <kaidelong> which is the main language where I remember this being a problem
12:26:53 <alynn> ^ undo + pl :)
12:27:00 <Javran> kaidelong: underscore.js has a isNaN IIRC
12:27:09 <chpatrick> @undo do { f <- mf; x <- mx; return (f x) }
12:27:09 <lambdabot> mf >>= \ f -> mx >>= \ x -> return (f x)
12:27:14 <hiptobecubic> kaidelong, i think isNaN is standard
12:27:21 <alynn> you can check for NaN in most cases by x == x
12:27:24 <alynn> as horrendous as that is
12:27:25 <EvanR> javascript has isNaN
12:27:26 <nh2> alynn: only in terms of bind and return and . if possible
12:27:43 <alynn> nh2: undo will convert do-notation to binds
12:27:55 <alynn> @undo do { f <- mf ; x <- mx ; return (f x) }
12:27:55 <lambdabot> mf >>= \ f -> mx >>= \ x -> return (f x)
12:28:07 <chpatrick> @pl (>>=) mf (\f -> (>>=) mx (\x -> return (f x)))
12:28:07 <lambdabot> (mx >>=) . (return .) =<< mf
12:28:12 <monochrom>  @undo converts do-notation to binds. @info is spelling-corrected to @undo.
12:28:14 <chpatrick> beautiful
12:28:20 <chpatrick> :t 
12:28:21 <lambdabot> <no location info>: not an expression: ‘’
12:28:23 <nh2> ah also convenient!
12:28:25 <chpatrick> :t \mf mx -> (mx >>=) . (return .) =<< mf
12:28:26 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:28:26 <monochrom> @info do { x <- m; return (x+1) }
12:28:27 <lambdabot> m >>= \ x -> return (x + 1)
12:28:39 <nh2> alynn, chpatrick: thanks!
12:28:46 <alynn> np
12:29:05 <Javran> :t (<*>)
12:29:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:29:23 <chpatrick> yeah I'm not sure why you want this niklas :)
12:29:29 <Javran> @src ap
12:29:29 <lambdabot> ap = liftM2 id
12:30:12 <Javran> I think it's more readable to implement it as "ap = liftM2 ($)" though
12:30:20 <monochrom> yes, it is $ there
12:31:34 <monochrom> > ($) ()
12:31:35 <lambdabot>  Couldn't match expected type ‘a -> b’ with actual type ‘()’
12:32:12 <monochrom> perhaps I should email to libraries@haskell.org and also the haskell committee, to propose change to: ($) :: a -> a; ($) = id
12:32:21 <timothyh> I keep finding myself using the pattern "maybe (return ()) doStuff mX" - is there a less awkward way to express this?
12:32:52 <monochrom> > map (`id` 1) [sin, cos, tan]
12:32:53 <lambdabot>  [0.8414709848078965,0.5403023058681398,1.5574077246549023]
12:33:06 <timothyh> also the converse, maybe doStuff (\_ -> return ()) mX
12:33:42 <monochrom> I simply use "case" :)
12:33:58 <dolio> maybe (return ()) doStuff = traverse_ doStuff, I believe.
12:33:59 <ij> monochrom, Why not ($ 1)?
12:34:25 <ij> oh, nvm
12:34:28 <monochrom> I'm testing whether "($) :: a -> a" suffices
12:35:26 <bergmark> timothyh: maybe (return ()) = Data.Foldable.forM_
12:35:40 <timothyh> oooo thanks
12:38:54 <timothyh> bergmark, i'm not seeing it
12:39:02 <dolio> > let woot = traverseOf_ _Nothing . const in (woot [(),()] Nothing, woot [(),()] (Just 7))
12:39:04 <lambdabot>  ([(),()],[()])
12:39:27 <hiptobecubic> Huh. I thought for sure there were haskell implementations for all of the shoutout programs. 
12:39:27 <bergmark> @type Data.Foldable.forM_
12:39:28 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
12:39:37 <hiptobecubic> http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=fastaredux&lang=all&data=u64q
12:40:01 <timothyh> actually i take that back, figured it out :)
12:40:30 <timothyh> was getting confused by the monad constraint, my ghci attempt was accidentally in the List monad
12:40:34 <monochrom> sometimes you can view Maybe as "like list, but length can only be 0 or 1"
12:46:28 <benzrf> affine list
12:46:30 <benzrf> :-3
12:47:51 <dashed> are monads generally just functors?
12:48:35 <EvanR> and more
12:48:49 <dmj`> dashed: all monads are functors and applicatives
12:49:35 <dashed> ok
12:49:50 <sinelaw> (TM)
12:51:23 <ski> edwardk : not really my variant on `flip'. i think i saw the idea in one of the papers mentioned at <http://www.funmath.be/>
12:56:28 <benzrf> dashed: a monad is a kind of monoid where the thing the monoid is built around is a functor instead of a set or concrete type
12:56:47 <benzrf> an endofunctor to be precise
12:57:02 * ReinH sighs
12:57:08 <EvanR> whats the problem?
12:57:09 <benzrf> :D
12:57:13 <benzrf> EvanR: im being an ass
12:57:14 <dashed> ah i see
12:57:15 <dashed> :P
12:58:03 <benzrf> dashed: but yes in haskell any type with a law-abiding instance of the Monad typeclass also has a law-abiding instance of the Functor typeclass
12:59:09 <breadmonster> benzrf: Is that the convention, or does GHC automatically infer that typeclass?
12:59:34 <benzrf> breadmonster: it's not a convention, it's a theorem
12:59:43 <ReinH> breadmonster: It's a convention
12:59:47 <breadmonster> benzrf: In the abstract sense yes.
12:59:56 <breadmonster> It would be a really cool idea for GHC to be able to infer weaker type class instances from stronger type class instances.
13:01:44 <breadmonster> ReinH: It doesn't already do that, yeah?
13:02:43 <ReinH> breadmonster: No, but in GHC 7.10 this happened https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
13:03:55 <breadmonster> ReinH: Yeah I heard about that.
13:04:45 <breadmonster> But is it possible to augment GHC to automatically derive superclass instances from subclass instances?
13:05:20 <porglezomp> I'm having setup nightmares right now
13:05:28 <porglezomp> Anybody know how to tame the linker on cabal
13:05:28 <porglezomp> ?
13:05:34 <breadmonster> ReinH: I'm trying to search for GSoC projects.
13:05:53 <dcoutts> porglezomp: tame?
13:06:46 <dmj`> breadmonster: since fmap = liftM, (<*>) = ap, and pure = return it's pretty straightforward
13:06:50 <porglezomp> Everything is failing with errors like `/usr/bin/ld: cannot find -lHStext-1.2.0.4-ghc7.8.4`
13:07:01 <breadmonster> dmj`: No, a little more specific.
13:07:08 <breadmonster> *not specific.
13:07:26 <dmj`> breadmonster: what do you mean
13:07:29 <porglezomp> So clearly my linker can't find files
13:07:45 <porglezomp> But I'm not sure how I fix that through cabal, it should be handling that
13:07:48 <breadmonster> dmj`: Like what if you can get GHC to do this for all typeclasses?
13:09:24 <porglezomp> How do I get cabal to tell the linker where the packages are?
13:09:32 <porglezomp> It's just derping
13:12:21 <porglezomp> Anyone know how cabal works with the linker?
13:13:35 <porglezomp> Verbose mode doesn't display the call to the linker it seems, so I can't see what's going on to try to fix it.
13:13:42 * hackagebot idris 0.9.17.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.17.1 (EdwinBrady)
13:13:49 <sm> porglezomp: -v3 will
13:14:20 <porglezomp> sm: thanks
13:14:34 <porglezomp> I think I just figured it out because of a seperate debug message though
13:14:35 <sm> you may want to paste your errors somewhere
13:15:26 <JordiGH> Can I get a style check? http://codepad.org/wg0TkS5M
13:15:39 <JordiGH> I'm not happy with my one-letter variable names on line 19.
13:15:58 <JordiGH> But the natural expansions conflicted with the record functions.
13:16:23 <JordiGH> I also don't like that lines 25-30 look like lisp. How do I cut down on "sexps"?
13:17:12 <raek> JordiGH: as for the Lispy part, do you know about $ ?
13:17:21 <sm> JordiGH: some people prefix the initial letters of the type to record fields, eg mDay mBuy...
13:17:23 <JordiGH> raek: I actually find that harder to read.
13:17:41 <JordiGH> sm: Ah, that's a good habit. I'll take that up.
13:18:03 <dolio> You have at least one unnecessary set of parens on 25 - 30.
13:19:13 <JordiGH> dolio: Which pair?
13:19:17 <dolio> Outermost.
13:19:29 <JordiGH> dolio: Oh. Yeah, but I actually like that pair.
13:19:32 <ski> `(map (\x -> read x)).words' could be `map (\x -> read x) . words'
13:19:44 <JordiGH> ski: Thanks, I had a hard time figuring that one out.
13:19:46 <ski> which could be `map read . words'
13:20:19 <dolio> JordiGH: You could use (<$>) instead of map.
13:20:32 <dolio> makeMachine capital <$> take n rest
13:20:34 <ski> `d:b:s:p:_ = line' could be `[d,b,s,p] = line', with a change in semantics (unclear whether it matters) .. same for `n:capital:days:_ = header'
13:20:44 <JordiGH> dolio: I can never keep the precedence of non-alphanumeric functions straight.
13:21:06 <ski> in both places, you could alternatively use pattern-matching in the head of the defining equation
13:21:08 <JordiGH> ski: What's the change in semantics? I was just trying to unpack values.
13:21:08 <merijn> JordiGH: You can ask ghci using ":info"
13:21:31 <merijn> JordiGH: operator precedence goes from 0 to 9, the default (i.e. when :info prints nothing) is infixl 9
13:21:38 <JordiGH> merijn: I don't want to be relying on that kind of thing. I want my code to be readable without resorting to a compiler. I want humans to understand this.
13:21:44 <ski> JordiGH : `d:b:s:p:_ = line' will discard any trailing elements after the first four. `[d,b,s,p] = line' will abort computation if there isn't exactly four elements
13:21:58 <merijn> JordiGH: Then memorise and/or parenthesise
13:21:59 <JordiGH> ski: Ah, yeah, I want the latter. Thanks.
13:22:09 <dolio> Well, in this case (and the other one), all you really need to know is that symbolic operators are always lower than all prefix applications of alphanumeric functions.
13:22:17 <dolio> But whatever floats your boat.
13:22:20 <kadoban> JordiGH: Humans are familiar with very common operators like <$>, and their precedence.
13:22:33 <JordiGH> kadoban: Do + and * have the same precedence?
13:22:35 <merijn> Also, the precedence is obvious due to them not typechecking otherwise
13:22:39 <merijn> JordiGH: No
13:22:45 <JordiGH> Do all non-alphanumeric functions of more than one character have the same precedence?
13:22:50 <ski> JordiGH : anyway, as i hinted at, you could drop `[d,b,s,p] = line', and instead replace `makeMachine days line = ...' with `makeMachine days [d,b,s,p] = ...' .. and similarly in `groupCases'
13:23:11 <merijn> JordiGH: All prefix applications have precedence 10 (i.e., higher than all infix functions)
13:23:18 <merijn> JordiGH: Record syntax has precedence 11
13:23:38 <JordiGH> merijn: Maybe some day this will seem natural, but remembering too many parsing rules reminds of Haskell.
13:23:43 <JordiGH> Er, of Perl.
13:23:47 <JordiGH> Reminds me of Perl.
13:23:56 <breadmonster> Hahaha
13:23:59 <JordiGH> At one time I thought I was being productive remembering what $_, $*, $# meant.
13:24:00 <ski> `*' has higher precedence (binds tighter) than `+', just as the math convention
13:24:21 <breadmonster> JordiGH: Haskell's precedence is obvious because of the type system.
13:24:26 <EvanR> JordiGH: i only knew a few of these rules, like application binds tighter than operators, thats basically it. and * and + from elementary school
13:24:34 <ski> breadmonster : what do you mean by that ?
13:24:38 <EvanR> good enough
13:24:48 <breadmonster> :t <$>
13:24:49 <lambdabot> parse error on input ‘<$>’
13:24:55 <breadmonster> ;t (<$>)
13:24:59 <breadmonster> Argh.
13:25:01 <ski> @type (<$>)
13:25:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:25:02 <breadmonster> :t (<$>)
13:25:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:25:19 <kadoban> breadmonster: Note that that doesn't tell you the precedence, so I'm not understanding your point…
13:25:43 <ski> JordiGH : also note that `read' will abort computation if parsing fails
13:25:54 <JordiGH> breadmonster: Well, then you have to juggle types in your head. I'm getting a bit better at that, though.
13:26:02 <JordiGH> ski: Yeah, that's fine for now.
13:26:05 <ski> JordiGH : i would consider using a proper parser in your case. like perhaps Parsec
13:26:11 <breadmonster> kadoban: eg. f . g <$> x 
13:26:14 <JordiGH> ski: No, this is a toy problem.
13:26:18 <JordiGH> ski: I don't want a real parser.
13:26:25 <ski> ok
13:26:26 <EvanR> parsec works for toy problems
13:26:38 <porglezomp> So, I can't cabal at all
13:26:38 <breadmonster> kadoban: clearly (.) has to have higher precedence for that expression to typecheck.
13:26:49 <ski> JordiGH : you could also use a list comprehension in `numSplit' .. not sure which reads most clearly to you
13:26:51 <JordiGH> EvanR: That's great. I still don't want to think about parsing errors.
13:27:05 <EvanR> i dont know what youre trying to do so yeah
13:27:05 <JordiGH> ski: How would you write it?
13:27:08 <kadoban> breadmonster: Ah.
13:27:39 <breadmonster> JordiGH: Use parsec, you can translate BNF grammars into Haskell code directly.
13:27:45 <JordiGH> ski: I got the impression somewhere that list comprehensions should be avoided.
13:27:50 <JordiGH> breadmonster: I don't want to write a grammar.
13:28:05 <sm> readMay or readDef from the safe package would be another option
13:28:22 <JordiGH> ski: Or that they were unidiomatic and I should use more explicit monads instead of list comprehensions.
13:28:23 <indiagreen> sm: there's already readMaybe in base
13:28:31 <sm> aha
13:28:31 <porglezomp> cabal with -v3 isn't showing the actual linker invocation
13:28:32 <ski> JordiGH : one alternative is `[[read word | word <- words line] | line <- lines str]'
13:28:41 <sm> depending what GHC versions you're targetting, I imagine
13:28:44 <JordiGH> ski: Oh, I *do* find that more readable.
13:29:06 <JordiGH> ski: Thanks! I like that.
13:29:06 <indiagreen> sm: well, once 7.10 is out it'll pass the “last 3 versions” check
13:29:07 <ski> JordiGH : sometimes list comprehensions reads more nicely. it's to a large extent a matter of style and taste, though
13:30:02 <JordiGH> ski: I think I read too many angry blog posts against list comprehensions.
13:30:06 <JordiGH> Or perhaps a wiki page.
13:30:15 <JordiGH> At any rate, I thought they were not supposed to be used.
13:30:22 <ski> JordiGH : anyway, a function like `\x -> read x' will behave just like `read' itself when applied to an input. simplifying the former to the latter is known as "eta reduction"
13:30:23 <kadoban> Why not just [read word | word <- words st] ? Does splitting into lines first do something that I'm missing?
13:30:25 <EvanR> your own experience trumps angry blog posts 
13:30:41 <sm> ski: does that list comprehension not fail on read errors ?
13:30:54 <JordiGH> ski: I just tried a bunch of things until it compiled, during my bumbling around I used a lambda.
13:31:15 <kadoban> Oh sorry, nevermind.
13:31:18 <indiagreen> kadoban: ski's version gives a list of lists
13:31:32 <JordiGH> EvanR: Not at all. I want my code to be read other people. The compiler is incidental. I want to write code other people will enjoy reading.
13:31:45 <EvanR> good luck pleasing everyone
13:31:51 <sm> s/fail/raise an error/
13:31:53 <JordiGH> EvanR: As long as I can please the majority, that's ok.
13:31:58 <EvanR> personally i want to make sure i can read it ;)
13:32:04 <JordiGH> That too.
13:32:07 <EvanR> majority rules? why are you using haskell lol
13:32:09 <JordiGH> lol
13:32:25 <JordiGH> EvanR: 1500 users here, pretty majoritary.
13:32:28 <ski> JordiGH : in Matlab/Octave terms, `@(x,y) f(x,y)' is basically the same as `@f'
13:32:31 <JordiGH> Closer to 1600.
13:32:33 <hexagoxel> porglezomp: for which cabal command? there is a "*** Linker:" plus a gcc invocation as part of my `build -v3` output
13:32:45 <JordiGH> ski: Yeah, I knew about eta reduction, I feel stupid I didn't see it.
13:33:00 <mmachenry> EvanR: Haskell is, in some ways, the most "majority rules" language.
13:33:03 <ski> sm : yes, as does the original `map ((map (\x -> read x)).words) (lines str)', and the revised `map (map read . words) (lines str)'
13:33:36 <porglezomp> hexagoxel: here's my log: http://paste.debian.net/162813
13:33:55 <porglezomp> hexagoxel can you tell me how to read the part that's going to the linker?
13:34:40 <sm> ok
13:34:43 <kaiyin> Could anyone help me continue with these equations? https://gist.github.com/kindlychung/c7a5f512bf61148da375  I am stuck here.
13:35:43 <ski> @src (->) (<*>)
13:35:44 <lambdabot> (<*>) f g x = f x (g x)
13:35:46 <ski> kaiyin : use that ^
13:35:59 <ski> (and eta expansion)
13:36:19 <porglezomp> <*> = S
13:36:26 <porglezomp> (right?)
13:36:29 <kaiyin> @src (->) (<$>) 
13:36:29 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
13:36:29 <ski> yes
13:36:33 <ski> porglezomp : also `ap'
13:36:37 <JordiGH> ski: Also, let us not speak of Octave functions, for they are an abomination.
13:36:52 <porglezomp> ski: oh I just got your name
13:36:58 <ski> JordiGH : i'm not sure how much Octave differs from Matlab here ..
13:37:12 <JordiGH> ski: Octave must be as abominable as Matlab in this regard.
13:37:15 * ski shines a light over porglezomp
13:37:32 <porglezomp> Can anyone help me read that cabal log?
13:37:39 <porglezomp> The linker death is near the end
13:37:47 <JordiGH> ski: Huh, you're uninvisible.
13:37:50 <JordiGH> And in tons of channels.
13:38:06 <kaiyin> ski: what would ((+) . (+3)) 4 be? Is it even a valid expression?
13:38:07 <ttt_fff> anyone managed to get ghcjs to install with stackage ?
13:38:08 <ski> JordiGH : at least there's sortof real lambda expressions now. istr hearing one used to much around with strings and some variant of `eval' :(
13:38:25 <porglezomp> I'm trying to figure out where the -lHStransformers-0.4.3.0-ghc7.8.4 flag comes from
13:38:26 <JordiGH> ski: Yeah, used to be feval("sin", 5).
13:38:28 <ski> JordiGH : "uninvisible" ?
13:38:48 <ski> @src (.)
13:38:48 <lambdabot> (f . g) x = f (g x)
13:38:51 <porglezomp> and how the linker is supposed to understand that because I can't find any files with that name.
13:38:58 <ski> kaiyin : simplify using that ^ and see where you get ?
13:38:59 <JordiGH> ski: I can see what channels you're in when I do /whois ski. I can't do this for most users. The Freenode default is for this to not happen, mode +i. Your client undid that mode.
13:39:18 <geekosaur> porglezomp, from the package registration db for the transformers library
13:39:22 <kaiyin> ski: ((+) . 7)
13:39:36 <kaiyin> which looks strange.
13:39:38 <geekosaur> which should also provide that library
13:39:47 <kaiyin> ski: ((+)7)
13:39:56 <kaiyin> ah, I see. 
13:40:08 <porglezomp> geekosaur so standard ld understands -lHS flags?
13:40:17 <geekosaur> what?
13:40:26 <ski> JordiGH : oh, that. yeah, i decided to do that because it used to be that the other way around was the default, and i sometimes thought it was nice to be able to see some new channel names when stalking others, so i figured i'd enable it for myself
13:40:48 <geekosaur> the flag is -l which is a macro meaning "find this library which is either static (.a/.LIB) or dynamic (.so/.dylib/.DLL)"
13:40:54 <ski> kaiyin : yep (the latter)
13:40:58 <porglezomp> geekosaur I can find the libraries themselves, but they don't have the stuff tacked on the end/front.
13:41:20 <geekosaur> it should
13:41:38 <geekosaur> unless you have a very old ghc but even the very old ones prefix HS
13:42:07 <ski> kaiyin : any luck with the previous rewrite ?
13:42:29 <porglezomp> There's .cabal/lib/transformers-0.4.3.0/ghc-7.8.4/libHStransformers-0.4.3.0.a
13:42:30 <porglezomp> So it'
13:42:39 <geekosaur> yes, that's normal for a static library
13:42:55 <kaiyin> ski: yes: https://gist.github.com/kindlychung/c7a5f512bf61148da375
13:42:58 <porglezomp> The issue then is the -ghc7.8.4 on the end
13:43:18 <geekosaur> I'm not sure where the compiler version went there. what's in the corresponding package db file?
13:43:55 <geekosaur> ought to be under ~/.ghc/<platform name>/package.conf.d
13:44:15 <geekosaur> this might be a cabal bug of some kind
13:45:04 <porglezomp> It looks pretty normal
13:45:14 <porglezomp> I haven't looked at them before
13:45:15 <porglezomp> but
13:45:17 <geekosaur> (if it's wrong in the package database, you can edit the package database file --- run "ghc-pkg recache --user" afterward)
13:45:24 <porglezomp> The import dirs are the right folder
13:45:27 <osa1> does it make sense to build a shared library without PIC? why -shared doesn't imply -fPIC?
13:45:37 <porglezomp> and the hs-libraries has the right name
13:46:00 <geekosaur> oh, I see
13:46:07 <geekosaur> static lib doesn't include compiler name
13:46:15 <geekosaur> you may have told it to try to link dynamic, which does
13:46:22 <porglezomp> Hm
13:46:35 <porglezomp> I'm not passing any specific flags, just doing cabal install
13:47:00 <JordiGH> Is my second version more readable? I think it is: http://codepad.org/Hqcs8iqM
13:47:15 <ski> kaiyin : `100 * x' should pedantically be `x * 100'
13:47:18 <JordiGH> Better than this: http://codepad.org/wg0TkS5M
13:47:31 <kaiyin> ski: ah, yes.
13:47:36 <ski> kaiyin : similarly `3 + x' should be `x + 3'
13:47:46 <kaiyin> ski: yeah. 
13:48:31 <hexagoxel> porglezomp: have you reset your package repository? does the same happen in a sandbox?
13:48:34 <geekosaur> porglezomp, can you pastebin your ~/.cabal/config?
13:48:37 <geekosaur> @paste
13:48:37 <lambdabot> Haskell pastebin: http://lpaste.net/
13:48:52 <JordiGH> Is the choice between a where clause or a let clause purely stylistic? Just whether you want your variable definitions at the top or the bottom?
13:49:06 <porglezomp> geekosaur: There are indeed -shared -dynamic flags in the cabal-install log
13:49:09 <porglezomp> so it wants to do it
13:49:10 <merijn> JordiGH: Yeah
13:49:11 <ski> JordiGH : i'd write `(Case machines capital days):(groupCases $ drop n rest)' as `Case machines capital days : groupCases (drop n rest)'
13:49:22 <porglezomp> I wonder why it's not trying to install them as dependencies
13:49:24 <geekosaur> JordiGH, it matters in one specific case: multiple equations for a definition. where scopes over all of them and over guards
13:49:27 <geekosaur> let cannot
13:49:28 <merijn> JordiGH: Well, you can only use where for top level definitions and let for any expression
13:49:34 <ski> JordiGH : bindings from `where' is in scope in guards. `let' bindings aren't. otherwise, yes
13:49:42 <geekosaur> (note that this can always be rewritten using case into a form you can use let with)
13:49:56 <JordiGH> ski: You really don't like my outermost parens, huh...
13:50:01 <kadoban> JordiGH: I think it's much better, yeah. I think I prefer line 14 to be…the other possibility, with maps, but it's not that bad.
13:50:06 <JordiGH> Should I also remove them on line 24?
13:50:39 <ski> JordiGH : no, since `groupCases header:rest' would be interpreted the same as `(groupCases header):rest', which isn't what you want
13:51:25 <ski> (function application binds tighter than any infix operator)
13:51:46 <porglezomp> geekosaur
13:51:50 <JordiGH> ski: I still like the visual separation with the parens...
13:51:58 <rasen> osa1: because there are other options available (PIE)
13:52:08 <JordiGH> Hmmmm...
13:52:38 <porglezomp> *sorry, link: http://paste.debian.net/162817
13:52:43 <ski> JordiGH : in `groupCases', i'd consider using `(front,back) = splitAt n rest' instead of using `take n rest' and `drop n rest' (rename `front' and `back' to something more appropriate in your case)
13:52:52 <porglezomp> It's the default
13:53:09 <JordiGH> ski: Okay, someone else said that earlier today...
13:53:25 <ski> JordiGH : if `n' is large, then this is more efficient
13:53:42 <ski> (traversing `rest' once instead of twice)
13:53:44 <JordiGH> n can be around 1e5.
13:53:49 <porglezomp> hexagoxel how do I reset the package repository
13:53:52 <geekosaur> hm, all the dynamic options are False there
13:53:59 <kaiyin> Anyone can think of a well known math equation that can make use of this pattern? https://gist.github.com/kindlychung/0e0cd169bfe52e7fbcbb
13:55:54 <ski> JordiGH : in case you're reading large files (or streams, pipes, sockets) lazily, it can make a difference whether your functions are properly incremental or not. using `splitAt' could be a step nearer this
13:56:36 <JordiGH> Yeah, the splitAt even makes it look better: http://codepad.org/X17lwukr
13:56:38 <hexagoxel> porglezomp: delete `~/.ghc`. that is a brute-force approach that sometimes might help, not in any way specific to your problem; downside is that you have to reinstall all the libraries in the user package repository.
13:56:48 <porglezomp> geekosaur: to be fair, it looks like most of the lines are commented out
13:56:56 <porglezomp> hexagoxel: worth it if it ends up helping
13:57:26 <geekosaur> yes, and showing defaults (but for the version that created the config originally; they do change sometimes)
13:58:03 <hexagoxel> porglezomp: it depends on how old the stuff in the packagedb is; e.g. when you changed any of your .cabal config or updated cabal it might help
13:58:20 <geekosaur> since it's using -dynamic options, your defaults may actually be different now --- or maybe different depending on cabal version, so check you don't somehow have two versions of cabal-install (cabal program) or the Cabal library around
13:59:54 <porglezomp> I didn't have very much stuff installed
13:59:58 <porglezomp> We'll see if this helps
14:00:08 <ski> JordiGH : another thing. i'm not sure what the point of your `type Number = Int' is ..
14:00:17 <JordiGH> ski: I wasn't sure if I wanted Int or Integer.
14:00:39 <JordiGH> Or an unsigned type, if it exists.
14:01:33 <zinfandel> JordiGH: Int would give you a machine size integer
14:01:36 <ski> JordiGH : ok. but you're sure you wanted the same type for all the fields ?
14:01:47 <JordiGH> ski: yes, that I know.
14:01:49 <porglezomp> If hoogle installs properly this is fixed
14:01:51 <ski> ok
14:01:55 <porglezomp> So it's just a waiting game now
14:02:05 <zinfandel> JordiGH: Integer would give you infinitely large integer with a little overhead comparing to Int
14:02:07 <ski> JordiGH : then it's just fine
14:02:12 <JordiGH> So, what about the type annotations I'm putting? Is that the equivalent of using stress marks in Russian or vowel marks in Arabic/Hebrew or those things in Japanese that you put above Kanji to say how they're pronounced?
14:02:13 <porglezomp> I'll report back when it succeeds/fails.
14:02:21 <JordiGH> zinfandel: Yeah, I wasn't sure which one I wanted yet.
14:02:33 <EvanR> zinfandel: im not sure Integer supports infinitely large integers
14:02:38 <ski> (`Integer' uses GMP in GHC, iirc)
14:02:54 <Lokathor> i'm looking at a presentation
14:03:02 <ski> s/infinitely large/unboundedly large/, perhaps
14:03:05 <Lokathor> and it says several "math terma" and "programmer terms"
14:03:14 <Lokathor> and monoid gets "string-like" as the programmer version
14:03:19 <zinfandel> ski: Well, as long as you have enough memory :)
14:03:37 <EvanR> Lokathor: gross
14:03:39 <JordiGH> Thanks for the help people.
14:03:39 <ski> Lokathor : "list-like" or "sequence-like" would be better .. but still not good
14:03:44 * hackagebot async-pool 0.9.0 - A modified version of async that supports worker groups and many-to-many task dependencies  http://hackage.haskell.org/package/async-pool-0.9.0 (JohnWiegley)
14:03:51 <porglezomp> Some of these somewhat standard libraries have an awful lot of warnings while compiling.
14:04:02 <liyang> JordiGH: furigana / 振り仮名[ふりがな]
14:04:16 <ski> too late
14:04:37 <Lokathor> it also says a morphism is like an "arrow", which i don't really think is a normal programmer word outside of functional programming
14:04:53 <liyang> D:
14:05:12 <ski> Lokathor : "arrow" is a category theoretic synonym for "morphism" and "map"
14:05:30 <Lokathor> yes but "arrow" was in the "programmer terms" column
14:05:30 <ski> (there's also in Haskell, the `Arrow' class, which is a different thing ..)
14:05:38 <shachaf> I don't think "map" is used for "morphism" much, is it?
14:05:45 <ski> depends on the book
14:06:03 <Lokathor> if they're going to bother to have a "math name" / "programmer name" chart, they might as well do it properly
14:06:05 <shachaf> It certainly suggests something which is more function-like than you'd expect in a category.
14:06:05 <ski> (but i agree, it's not as common)
14:06:27 <Lokathor> oh i forgot to give the link: http://yogsototh.github.io/Category-Theory-Presentation
14:06:27 <ski> (iirc, "Conceptual Mathematics" used it)
14:06:39 <porglezomp> Oh, one last question
14:07:01 <porglezomp> How do you make cabal download all dependencies before it starts the build
14:07:24 <hexagoxel> porglezomp: `cabal fetch`
14:07:26 <Lokathor> cabal --help explains the options... i think "fetch"?
14:07:26 <zinfandel> porglezomp: cabal fetch
14:07:42 <benzrf> aw yiss lambdajam chicago for 2015 announced
14:07:47 <porglezomp> Thanks
14:07:48 <benzrf> who's coming 8D
14:08:01 <porglezomp> I haven't looked at cabal --help enough for the most recent version
14:08:10 <porglezomp> It's a lot better than whatever I had installed a few days ago
14:08:29 <hexagoxel> porglezomp: ty ty :)
14:10:31 <glguy> How does one mark up  @x `f` y@     in haddock so that `f` is properly hyperlinked?
14:10:39 <ttt_fff> is there anyway to use ghci :: haskell as productively as one can use ipython :: python ?
14:10:47 <ttt_fff> haskell seems to lack in terms of 'interactive development'
14:10:49 <benzrf> ttt_fff: what features would one need for this
14:10:55 <benzrf> i havent really used ipy
14:11:03 <ttt_fff> REPL seems to be "compile, wait, get type check error, eval, print"
14:11:06 <EvanR> ttt_fff: colors im sure
14:11:31 <EvanR> :reload based workflow is pretty fast, faster than rebuilding the entire project
14:11:31 <exio4> I think ipython can be used from writing code relatively easy compared to ghci, but that's the only thing I can think of 
14:11:34 <ttt_fff> benzrf: I'm not sure what 'interative haskell develoment' would actually be like, tbh, but coding in ipython feels different fromwriting a big chunk code in vim, then compiling, then running
14:12:06 <ttt_fff> EvanR: how does the haskell ":reload" workflow work?
14:12:18 <ttt_fff> is it better than using vim + hdevtools + syntastic + "cabal run" all the time ?
14:12:22 <EvanR> ttt_fff: you have ghci open and your editor open, when you a ready to test a change do :reload
14:12:22 <benzrf> ttt_fff: i tend to write a lil haskell, :w, see if it typechecks thanks to syntastic's haskell stuff, if it doesnt fix that, etc
14:12:42 <benzrf> ttt_fff: i suppose it's basically iterative development where the iterations are typechecks instead of repl-checks
14:12:46 <benzrf> i still repl check sometimes but its less frequent
14:13:17 <benzrf> tbh type errors tend to catch the bulk of fuckups
14:13:22 <benzrf> like
14:13:24 <benzrf> the significant bulk
14:13:35 <EvanR> ttt_fff: i find having a lot of stuff stored in a repl session is pretty annoying since you lose it all. i prefer having most code in the source file
14:13:44 <ttt_fff> hmm
14:13:54 <EvanR> including test code
14:14:16 <ttt_fff> I guess using ipyton makes "vim + syntastic + hdevtools" seem 'slow' somehow, which is annoying
14:14:32 <exio4> ttt_fff: ghci is pretty much a fast-way to typecheck code in my workflow
14:15:02 <exio4> cabal repl in background, and :r after every change that should typecheck, fix type errors, continue
14:15:38 <exio4> ^ the same while refactoring 
14:16:01 <KaneTW> :t fmap
14:16:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:16:23 <EvanR> i find myself spending a lot of time in dynamic language repl X fixing the problems caused by dynamic typing, so maybe it feels faster like it feels faster to take the long way around a traffic jam insteading of waiting 5 minutes bumper to bumper
14:17:10 <EvanR> dynamic language workflow is like crusin (nowhere fast)
14:18:46 <ttt_fff> if this is true, why is so much of machine learning / big data done in python/matlab rather than ocaml/haskell ?
14:19:01 <Welkin> what EvanR means to say, is that it is like a blood ritual with lots of dancing and hallucinogenic drugs
14:19:05 <ttt_fff> i feel like real world data suggests there's something about the repl that works well with big-data/numeric math-ish stuff
14:19:22 <EvanR> kind of sounds like "lisp is for AI" in new garb
14:19:46 <cjh`> ttt_fff: I think it is the ease of entry for those dynamic languages
14:19:53 <Welkin> would you like to see a map that shows a connection between women and acid rain?
14:20:02 <EvanR> what people use for what probably isnt about technical merits as much as personal preference
14:20:10 <Welkin> from this I must conclude that women cause acid rain
14:20:25 <hodapp> Welkin: that's ridiculous...
14:20:35 <hodapp> Welkin: acid rain causes women, obviously
14:20:38 <Welkin> hodapp: there are lots of map overlays like this (for the US)
14:21:08 <monochrom> data agree that cellular tower density is proportional to baby birth rate
14:21:09 <athan> Welkin: I think you've just solved the mystery of life
14:23:09 <monochrom> but more seriously, my idea is that very smart people (such as Norvig, the AI book author, the guy who joined Google and promote python) can make great use of unrestrictive languages, so they do it, and other people look upon them as role models
14:23:48 <monochrom> the catch is that unrestrictive languages suitable for smart people do not work for other people (e.g. in terms of bug rate)
14:24:45 <monochrom> fortunately, other people make do with insisting that bug rate is supposed to be high
14:25:10 <EvanR> "there will always be bugs" 
14:25:16 <EvanR> "you cant totally eliminate bugs"
14:26:15 <monochrom> whereas here within Haskell, I can keep bug rate really low without being as smart as Norvig. this is because the restrictive type system helps me.
14:26:44 <merijn> Some people tell me "I'm not smart enough for Haskell", I tell them, "I'm not smart enough for not-Haskell"
14:27:02 <monochrom> the problem with looking upon opinion leaders is that what works for leaders are bound to be unsuitable for followers.
14:27:48 <hodapp> monochrom: how does one establish, though, that they were working *with* less restricted languages and not in spite of them?
14:27:57 <cjh`> :D
14:27:58 <johnw> merijn: in Haskell, I need to know how to read the types; in Ruby, I need to comprehend the entire state machine that represents the whole programs, the implications of all monkey patches, and the dynamic behavior possible at every point in the execution
14:28:05 <shachaf> "restrictive", like a lot of things, can be looked at from the perspective of the producer and the consumer.
14:28:33 <raek> does attoparsec support user state like parsec does?
14:28:35 <Welkin> johnw: which seems to be where the need for "test-driven development" came from
14:28:36 <Lokathor> merijn, I had that exact same problem recently
14:28:41 <johnw> so a Haskell program might be easier to understand, but my argument is that Ruby seems eeasier because you give up on trying to
14:28:45 <merijn> raek: No, but you can wrap StateT around it
14:28:45 <Welkin> a solution to the wrong problem
14:28:57 <monochrom> hodapp: I don't know. but probably Norvig and von Rossum do.
14:29:03 <shachaf> A restriction on one has the opposite effect on the other. So if a function is harder to write, that probably means that the person using it will have an easier time.
14:29:04 <Lokathor> I've written a communication server based around MVar and websockets; he said "just write it in not-haskell", I said, "do you want to mess with all that locking nonsense?"
14:29:16 <johnw> Welkin: types are a very nice companion to tests, I agree, and the better your types, the fewer and more valuable your remaining tests
14:29:31 <shachaf> Since you're both the consumer and the producer, when you're writing a program, you need to consider both perspectives.
14:29:31 <glguy> shachaf: If I'm both people does that mean it doesn't matter?
14:29:41 <monochrom> but just in case: if they are also wrong about it, then all the better for me! :)
14:29:51 <shachaf> glguy: I don't think it cancels out.
14:30:02 <glguy> damn
14:30:25 <monochrom> if you're both, it means you're doomed :)
14:31:08 <raek> merijn: hrm. interesting approach
14:31:36 <EvanR> im not sure "im too dumb to use python" is a great argument for anything
14:32:02 <EvanR> just based on the way people are going to react to this, not even considering whether its right
14:33:05 <peddie> EvanR: it works fine if you're discussing it with people who are convinced you are a stronger programmer than they are ;)
14:34:06 <monochrom> yes. people are ad hominen. there is no great argument (if your definition is "can sway people"), only great arguer.
14:34:40 <monochrom> but I do not hope to sway people. I think that people have already made up their minds. I only hope to explain my choice and people respect it.
14:35:23 <dgorbik> /join #irc
14:35:25 <dgorbik> ops
14:35:41 <glguy> no no, that's * #haskell-irc *
14:36:11 <dgorbik> glguy, awesome, exactly waht I am looking for
14:44:09 <ttt_fff> bruce lee once said "I do not fear the man who has practieced 10K kicks 1 time; but the man who has practiced 1 kick 10k times." Some other asian dude probably said "use bow+arrow for shooting, not club for shooting" -- now, I'm trying to figure out, as I need to write this big-data syste, whether to do pure haskell (and use hblas / repa), or to go haskell + python, with all the wonders of numpy and scipy and all that
14:44:59 <johnw> ttt_fff: great question setup :)
14:45:17 <EvanR> -- some other asian dude
14:45:35 <johnw> the master swordsman doesn't fear the second best swordsman; he fears the beginner who doesn't know what he's doing -- yet another saying
14:46:51 <monochrom> you would be thrilled to know that Kingsmen (Kingsmans?) use umbrellas for shooting and shielding
14:47:07 <ttt_fff> haskell has this package 'repa'
14:47:08 <merijn> ttt_fff: Also, checkout #numerical-haskell
14:47:17 <ttt_fff> reading the stackoverflow answers on repa freakes me out
14:47:17 <monochrom> hell, in fact, for shooting, shielding, and clubbing.
14:47:28 <ttt_fff> the answers are of the form "well, for repa to be fast, you need to amke sure fusion worked"
14:47:50 <ttt_fff> the way to do this is to compile your *.hs file with theese CRAZY FLAGS, then read the assmeembly, and see if there's boxinn-unboxing action going on ....
14:47:58 <ttt_fff> if there's no boxing-unboxking, it'll be as fast as C code
14:48:06 <ttt_fff> if the is boxing/unboxing, it'll be 10x slower than plain lists
14:48:13 <ttt_fff> I'm reading this and I'm like WTF
14:48:19 <hunteriam> guys whats the best way to install haskell on ubunt?
14:48:25 <EvanR> yet with numerical dynamic language * you have to know a bunch of stuff that no one can even name, because its all invisible
14:48:28 <hunteriam> also
14:48:43 <hunteriam> whats teh best libraryfor writing a custom webserver
14:48:46 * hackagebot cabal-debian 4.24.6 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.24.6 (DavidFox)
14:48:48 <hunteriam> its not serving any html
14:48:50 <EvanR> so its better because you dont know how bad its doing
14:48:52 <peddie> ttt_fff: is it a production system where you're implementing known math, or a development system where you're trying to test out a bunch of existing techniques, or for research or . . . ?
14:48:55 <ttt_fff> hunteriam: apt-hunt find ghc
14:49:07 <hunteriam> ttt_fff: thats painufll outdated though isnt it
14:49:07 <ttt_fff> peddie: research
14:49:35 <ttt_fff> yeah, I think , since I don't want a PhD in "GHC Fusion Internals" I should probably go with python for now
14:49:44 <peddie> ttt_fff: if you use numpy/scipy/pandas/theano/etc., there will probably be a lot more resources to help you do the math side
14:49:45 <ttt_fff> okay, it is resolved; thanks for listening ot me rant
14:49:45 <EvanR> julia looks cool for dynamic and numerical
14:50:23 <peddie> ttt_fff: I don't think you need to be an expert at Repa's fusion to write very fast Haskell code for numerics
14:50:51 <peddie> ttt_fff: but if you are trying to do a bunch of machine learning or stats or whatnot, you will probably end up building a lot more of the stuff yourself if you do it in Haskell
14:51:08 <EvanR> if i was responsible for genuinely fast numeric code i would want to know as much as i can about what im doing
14:51:27 <EvanR> rather than assume package foo has done that for me
14:51:43 <hunteriam> guys i dont know if anyone will respondbut coul someone reccomend me the best wayto go about writing my own haskell webserver?
14:51:52 <hunteriam> my own backend, that is
14:52:04 <peddie> EvanR: there are plenty of ways to write fast numeric code without repa :)
14:52:10 <hunteriam> or actually
14:52:17 <hunteriam> whats the fastest way to write some test server code
14:52:21 <hunteriam> to prototype a server idea
14:52:24 <athan> hunteriam: Try Snap, Scotty, and Yesod :)
14:52:31 <athan> probably scotty
14:52:35 <hunteriam> ok
14:52:45 <hunteriam> i want to get up and running asap for dev
14:52:55 <hunteriam> is the default netwroking library good for that, maybe?
14:53:01 <hunteriam> last time itried scotty i didnt have a great time
14:53:02 <athan> Definitely
14:53:07 <hunteriam> awesmoe
14:53:08 <athan> well, it depends
14:53:17 <athan> hunteriam: What are your needs?
14:53:20 <hunteriam> i just need to receive haskell objects
14:53:23 <athan> (in terms of networking)
14:53:24 <hunteriam> run ahaskell program
14:53:30 <hunteriam> and reply wtih haskell objects
14:53:35 <athan> ohhhhh
14:53:38 <hunteriam> and obviously have a memoy for the server
14:53:45 <monochrom> see, this is why I believe that people have already made up their minds.
14:53:54 <hunteriam> monochrom: whatdo you mean
14:54:09 <hunteriam> athan: is Networking (or whatever its called) good for that?
14:54:12 <athan> hunteriam: Look into cereal and binary, probably. Scotty is http only
14:54:34 <hunteriam> athan: default network doesnt allow this?
14:54:34 <monochrom> if we started giving out PhD degrees in python internals, most pythoners would qualify.
14:54:37 <peddie> @hackage network-simple
14:54:37 <lambdabot> http://hackage.haskell.org/package/network-simple
14:54:46 <peddie> hunteriam: will this ^ help?
14:54:58 <monochrom> yet people treat "PhD in GHC internals" different from "PhD in python internals"
14:55:02 <hunteriam> peddie: probably, but do you know if the default solution works?
14:55:03 <athan> hunteriam: I'm not sure :\ I'm a web guy
14:55:16 <hunteriam> athan: you mean youre not a web guy?
14:55:17 <peddie> hunteriam: what do you mean by "default solution"?
14:55:21 <hunteriam> thanks anyway ill check it out
14:55:26 <hunteriam> peddie: the one that comes in prelude
14:55:29 <hunteriam> peddie: or the platform at least
14:55:37 <peddie> hunteriam: oh, network-simple is built on top of network
14:55:59 <hunteriam> peddie: thats probably what im looking for
14:56:03 <hunteriam> thanks dude!
14:56:06 <peddie> hunteriam: I suspect if your needs are simple, then network-simple will let you achieve the same goal with less work, but you could write the same thing in 'network'
14:56:10 <peddie> s/in/using/
14:56:15 <arkeet> "web server" seems to imply http to me
14:56:53 <ttt_fff> monochrom: why would most pythoners qualify?
14:57:02 <hunteriam> arkeet: yea imispoke i think
14:57:08 <hunteriam> arkeet: scokets are perfect
14:57:09 <monochrom> because they know python internals
14:57:14 <peddie> hunteriam: as athan mentioned, you can use either of the 'cereal' or 'binary' packages to serialize your Haskell objects so they can be transmitted over the sockets you get from network-simple
14:57:21 <hunteriam> man my keyboard fails half the time
14:57:29 <merijn> binary, cereal is mostly obsolete, now
14:57:33 <hunteriam> peddie: is cereal built in or just binary?
14:57:38 <hunteriam> merijn: thanks dude
14:57:43 <hunteriam> the haskell community is amazing
14:57:49 <glguy> cereal exists because binary used to be missing some stuff
14:57:55 <athan> hunteriam: You're amazing :)
14:58:02 <peddie> merijn: ok, but I get faster and smaller serialized objects with cereal often . . .
14:58:31 <peddie> merijn: I saw some interesting slides about converting binary to use CBOR, I wonder when that's coming out
14:58:36 <EvanR> faster objects!
14:58:50 <ttt_fff> monochrom: are you implying I asked this question while subconscioutly already having decided to pik python over haskell? :-)
14:58:59 <monochrom> yes.
15:01:46 <peddie> EvanR: sorry, I meant faster serialization and (consequently) smaller objects :)
15:02:02 <peddie> argh
15:02:04 <peddie> no
15:02:12 <peddie> I meant the other way around
15:02:26 <randir> what are data declarations stored as, on an underlying level?
15:02:30 <randir> like data Color = White | Black
15:02:35 <hpc> nothing
15:02:39 <peddie> smaller objects and consequently faster serialization
15:02:49 <hpc> (in ghc)
15:03:10 <randir> If I have an array of Color data, what size will each element fill?
15:03:20 <merijn> hpc: Actually, multuple possible representations
15:03:20 <athan> hpc: Are you thunking what I'm thunking?
15:03:27 <Welkin> it depends on if it is boxed or unboxed
15:03:33 <Welkin> by default, everything is boxed
15:03:33 <merijn> randir: Hard to say
15:03:35 <ttt_fff> monochrom: I can't find a way to refute that, as I think, you may actually be right
15:04:00 <randir> I'm trying to make my own Chess engine in Haskell, and want to decide the underlying board representation
15:04:19 <hpc> randir: a close-enough non-answer is that Color has similar characteristics to Boolean in terms of resident memory
15:04:21 <EvanR> how about a 2D array of Maybe Piece
15:04:22 <glguy> peddie: cereal and binary are basically identical in how the default serialization instances work
15:04:39 <randir> EvanR: I really like that idea
15:04:45 <EvanR> really?
15:04:48 <johnw> randir: isn't it typical to use a 128-bit integer?
15:04:51 <KaneTW> how important is performance for you
15:04:59 <peddie> glguy: ok
15:05:05 <randir> Performance is moderately important
15:05:29 <randir> I'm doing this for my senior thesis, and more interested in making an engine with clear semantics then a super-efficent bitshifting engine
15:05:35 <johnw> ah
15:05:44 <EvanR> randir: bless you
15:05:45 <johnw> then write it in a formal language like Agda to be fancy :)
15:05:52 <randir> heh
15:05:58 <randir> I like Haskell though
15:06:00 <Hafydd> I read: "I'm doing this for my senior thesis, and more interested in making an engine with clear semantics then a super-efficent bullshitting engine"
15:06:07 <KaneTW> lol
15:06:08 <randir> haha
15:06:29 <johnw> yeah, but you'd learn a lot doing it in Agda that would boost your Haskell
15:06:32 <randir> My engine won't take any bullshit. It'll send a notification to the OS saying "Hey! That's a BS move."
15:06:38 <johnw> and being in school is the exact time to make that kind of effort
15:06:44 <peddie> glguy: I haven't investigated, just noticed that with the latest version of each, I could import one package and get smaller serialized objects
15:06:45 <randir> I frankly don't have time for that, this semester
15:06:56 <randir> trying to finish up my degree, starting a job right after the semester
15:07:22 <KaneTW> well try to think of how many states you need to represent in chess
15:07:50 <KaneTW> and how many possiblities there are for each state
15:07:54 <randir> KaneTW: Informally: A lot. 
15:08:30 <KaneTW> what's "a lot"? 2^64? 2^1024? 2^1024^1024?
15:08:40 <randir> I think a functional language would work pretty well for an engine, at least semantically. It's hard to get a truly efficent engine in anyhting besides C or C++
15:09:06 <EvanR> ghc breaks the C barrier on a regular basis
15:09:08 <randir> KaneTW: Many states are unreachable, and I'm obviously not doing an exhaustive search, as I'm not God.
15:09:11 <johnw> I'd be careful with making a statement like that
15:09:25 <randir> EvanR: But garbage collecting is an issue for a chess engine
15:09:28 <KaneTW> you're going in the completely wrong direction
15:09:29 <johnw> a good thesis would be "Making an efficient chess engine in a purely functional language" :)
15:09:41 <porglezomp> If you want to be formal about the semantics but like haskell, maybe look at Idris
15:09:45 <randir> KaneTW: What do you mean?
15:09:50 <KaneTW> for the purpose of storing chess state, how many values do you need to represent
15:09:58 <johnw> then show the world how you can match or beat C by taking advantage of parallelism in a semantically clear way
15:10:04 <randir> ah, I misunderstood what you were talking about.
15:10:49 <randir> johnw: that does sound like fun, honestly, but I sadly need to sort of rush this project. I'm going to keep working on it as a personal project after the semester, and host it on a website.
15:11:57 <porglezomp> You do need to store a bit more state than just the board itself, castling and en-passant make things messier.
15:11:59 <randir> I think composition can work to make a clean engine in haskell. Once I get a really clean function that maps from Board State -> Position rating, I can have a generalized alpha-beta search run over it
15:12:59 <randir> porglezomp: yeah, although I'd probably generalize some of those into a game-state as opposed to board-state
15:13:13 <RustyShackleford> anyone up for a code review? I'm not sure if I'm doing FP correctly http://lpaste.net/128371
15:13:16 <EvanR> i like making a recursive infinite game tree
15:13:18 <EvanR> not for any practical purpose ;)
15:13:37 <RustyShackleford> in particular, i'm worried about the prettyShow function at the bottom. How would you clean it up?
15:13:45 <johnw> I'd love to see the denotational design approach applied to the chess problem
15:13:57 <RustyShackleford> but i'm looking for any critique/advice you have
15:14:23 <monochrom> why is everyone implementing Chess?!
15:14:35 <RustyShackleford> oh are people copying my idea?
15:14:47 <monochrom> although, I grant you that only one of you is doing bitshifting
15:15:05 <athan> monochrom: so we can play with ourselves duhhh
15:15:07 <shachaf> All those functions look like a lot of work to write out.
15:15:07 <RustyShackleford> yeah i'm not sure if thats worth the extra complexity or not
15:15:08 <randir> RustyShackleford: I'm working on a chess engine too. 
15:15:16 <RustyShackleford> bit shifting is fun
15:15:23 * EvanR stops what hes doing and starts working on chess too
15:15:27 <shachaf> Why not define (&) such that blackPawns = (black & pawns), and so on?
15:15:59 <RustyShackleford> shachaf: isn't that how I did it basically?
15:16:00 <athan> Looks like I have a new project also :D
15:16:22 <shachaf> Yes, except you wrote out 12 definitions by hand, and you have to remember 12 names.
15:16:30 <porglezomp> Hey guys, I'm going to try to make some chess
15:16:35 <shachaf> Or maybe I should say "no" instead.
15:16:37 <benzrf> porglezomp: cool
15:16:39 <porglezomp> Nobody's doing that, right
15:17:08 <RustyShackleford> shachaf: er, i'm confused then
15:17:17 <tempname11_> curiously, I'm making a chess-like game as well
15:17:23 <tempname11_> but it's not really chess
15:17:27 <tempname11_> so i'm clean
15:17:41 * EvanR busts tempname11_ for chinese checkers
15:17:50 <RustyShackleford> shachaf: so you're saying I should have more "members" in my Position datatype?
15:17:58 <shachaf> No.
15:17:58 <randir> How about let's all switch over to Go?
15:18:02 <RustyShackleford> sorry i'm not great at the FP terminology yet
15:18:16 <shachaf> I'm suggesting you don't need to write out all those functions.
15:18:51 <shachaf> Instead you can e.g. define f & g = \pos -> f pos .&. g pos
15:19:08 <shachaf> Now you can write (black & pawns) instead of defining a function called blackPawns.
15:19:40 <johnw> RustyShackleford: in FP we like to build functions out of smaller functions whenever we can, and to write functions that take functions as arguments and combine them somehow, etc.
15:19:47 <monochrom> If someone writes an algorithm for playing the game of Go, and the algorithm is written in the programming language Go, and this is taken to a competition of algorithms playing against algorithms...
15:19:56 <Lokathor> Golang is totally weird and i hate their slice/array mixup
15:20:03 <RustyShackleford> but the expression (black & pawns) is a function that takes a Position as a parameter?
15:20:17 <randir> monochrom: Google Go Go 
15:20:23 <RustyShackleford> i'm sorry if i'm being retarded. I'm new to all this
15:20:26 <shachaf> Yes. It's equal to your function blackPawns.
15:20:27 <monochrom> the cheer team is right to say the slogan "Go Go Go!". in fact "Go Go Go Go!" too.
15:20:54 <monochrom> this is inspired by "buffalo buffalo ... buffalo"
15:21:13 <randir> What should I use for an array, if I have a board of Maybe Pieces?
15:21:29 <randir> I know it's not as efficent as a bitboard, but think I'm gonna go with this for now.
15:21:29 <monochrom> http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
15:22:29 <monochrom> I think Vector will do fine
15:22:43 <randir> monochrom: makes me glad I'm not doing natural language programming right now
15:22:58 <monochrom> no, I think a Data.Map from position to piece will be better.
15:23:23 <randir> hmm
15:23:28 <porglezomp> The capitalization in that URL strikes me as really funny
15:23:31 <randir> n log n update time, right?
15:23:44 <RustyShackleford> shachaf: could you tell me what I need to look up so I can implement that?
15:23:45 <arkeet> any reason to use that over an Array?
15:23:56 <randir> data.map is immutable, isn't it?
15:23:57 <monochrom> this is because I assume these: (A) board is sparse  (B) board modification is like you only move one piece  (C) you still want to use an immutable data structure.
15:24:03 <RustyShackleford> i have no idea how to write an infix function or override an operator
15:24:14 <monochrom> if you want mutable, a mutable array is best, and "vector" has one too
15:24:18 <shachaf> RustyShackleford: Nothing. I gave you the whole definition.
15:24:24 <johnw> randir: you could even just start out with a function Position -> Piece, and leave the representation for later
15:24:32 <athan> Does something like this already exist? It's a weak trie: https://github.com/athanclark/semi-trie/blob/master/src/Data/Trie/Semi.hs
15:24:37 <shachaf> Put "f & g = \pos -> f pos .&. g pos" in your file and it'll work.
15:24:37 <johnw> (or Maybe Piece)
15:24:39 <randir> it's definitely interesting-- wouldn't immutable actually work here?
15:24:58 <shachaf> I don't know that this is the best approach, but it's the first thing that comes to mind seeing all that repetition.
15:25:01 <randir> eh
15:25:01 <shachaf> interesting++
15:25:20 <monochrom> immutable array is bad because you are only moving one piece (change 2 cells out of 64) and for that you're already duplicating the whole array
15:25:31 <RustyShackleford> shachaf: how is the prettyShow function? Theres a lot of stuff going on
15:25:38 <RustyShackleford> i don't think it's very readable...
15:25:48 <RustyShackleford> thats as neat as I could get it
15:26:00 <randir> monochrom: Yeah. I'm just trying to think how I can minimize copying data when I'm creating a tree of positions.
15:26:05 <RustyShackleford> and is there a better name for that function maybe?
15:26:07 <shachaf> It looks like a mess. :-)
15:26:28 <EvanR> randir: use a IntMap or Map instead
15:26:28 <porglezomp> There are some fun extremes
15:26:32 <monochrom> Data.Map is a binary search tree, so it minimizes copying data when you "change"
15:26:36 <porglezomp> Your tree could be a tree of diffs
15:26:57 <porglezomp> But then to get the actual position of pieces you have to search back up the tree.
15:27:02 <EvanR> haskell already takes care of the diff part for you by sharing common subtrees
15:27:03 <porglezomp> But that's probably not terrible?
15:27:11 <monochrom> Data.IntMap is also worth considering if you don't mind doing your own 8x8 <-> 64 conversion of coordinates
15:27:19 <randir> porglezomp: Ooh, I like that idea.
15:27:30 <randir> EvanR: For immutable data-structures?
15:28:05 <randir> EvanR: How exactly does Haskell use diffs?
15:28:13 <EvanR> yes when you update a Map it doesnt copy the whole tree
15:28:47 <randir> monochrom: Yeah, it looks good. I could write a tiny wrapper around it for the 8x* <-> 64 conversion
15:28:59 <arkeet> start with Data.Map and optimize later if necessary.
15:28:59 <randir> EvanR: That's really useful
15:30:43 <randir> inset for IntMap is of O(min(n,W))
15:30:54 <randir> do you guys know what W is? I'm assuming n is keys?
15:31:04 <merijn> width in bits
15:31:28 <monochrom> 32 for 32-bit GHC, 64 for 64-bit GHC
15:31:39 <behelit> using overloadedstrings extension; i try to concatenate two strings ("abc" ++ textInVariable) and get "Couldn't match expected type ‘[a]’ with actual type ‘Text’"
15:31:55 <behelit> is there a gotcha?
15:32:03 <EvanR> :t (++)
15:32:03 <lambdabot> [a] -> [a] -> [a]
15:32:14 <EvanR> try (<>)
15:32:16 <merijn> behelit: Yes
15:32:19 <RustyShackleford> define f & g = \pos -> f pos .&. g pos
15:32:26 <RustyShackleford> i'm sorry, i messed up haha
15:32:28 <merijn> behelit: OverloadedString only overloads *literals*
15:32:29 <EvanR> behelit: ++ works on lists, not on Text
15:32:32 <merijn> behelit: Not anything else
15:33:07 <merijn> behelit: That or the ++ doesn't work on Text answer
15:33:28 <randir> behelit: if you have a function foo that takes 2 texts, overloaded strings will allow you to write foo(someText, "literal text"), it doesn't automatically convert text data-types to strings
15:33:50 <hunter> do you guys puh your cabal files to git?
15:34:03 <merijn> hunter: yes
15:34:05 <indiagreen> you mean .cabal files? sure
15:34:08 <monochrom> yes
15:34:16 <monochrom> err, probably not
15:34:48 <hunter> monochrom: no?
15:34:50 <arkeet> package.cabal files sure, together with the rest of the package.
15:34:52 <arkeet> ~/.cabal no.
15:35:04 <monochrom> what arkeet says
15:35:15 <RustyShackleford> any advice for cleaning up the prettyShow function at the bottom?
15:35:20 <monochrom> this is why I say that every sentence is unambiguous to its author.
15:35:20 <igniting> hunter: https://github.com/github/gitignore/blob/master/Haskell.gitignore
15:35:22 <hunter> yea thats what i meant
15:35:29 <RustyShackleford> oh, forgot my link: http://lpaste.net/128371
15:35:37 <RustyShackleford> should I work on cleaning that up, or just move on?
15:35:53 <arkeet> reverse [0..7] = [7,6..0]
15:35:55 <hunter> igniting: how do include that in my github repos?
15:36:09 <hunter> igniting: is it available in the create a repo screen?
15:36:13 <arkeet> copy it.
15:36:17 <RustyShackleford> ah, forgot about specifying a step
15:37:28 <randir> RustyShakleford: besides the step for [8,7..1], it honestly looks pretty good
15:37:30 <arkeet> maybe the zipWith thing can be cleaned up with some ParallelListComp
15:37:50 <randir> yeah, that's the only part that looks a little hackish, I think
15:37:55 <arkeet> and map f [blah | ...] = [f blah | ...]
15:38:18 <arkeet> in line 117
15:38:48 <RustyShackleford> randir: anyway i'm just getting the hand of this. I just wanted someone to confirm/deny that i'm doing FP right
15:38:48 <randir> overall, generating multiple unique lines like fileLables and dividers isn't something that can be done easier than the way you're doing it, I think
15:39:03 <RustyShackleford> also this sorta reminds me of python
15:39:13 <RustyShackleford> where you can severely abuse list comprehensions
15:39:17 <arkeet> yeah I can't think of a nice straightforward way to tidy up prettyShow.
15:39:20 <arkeet> just little things.
15:39:22 <randir> RustyShakleford: It's not the most FP-like function, but I think it's the particular nature of the problem 
15:39:40 <RustyShackleford> it's kinda hard to tell if you're trying to do too much in one line
15:40:20 <tempname11_> RustyShackleford: I would move the lambda out of line 122, it's too damn long :)
15:40:42 <igniting> hunter: yes it's available (on github)
15:40:45 <randir> In general, I tend to like when things are separated into different let bindings and composed.
15:40:45 <EvanR> if youre worried about doing too much in one line, use this to get ideas: http://www.willamette.edu/~fruehr/haskell/evolution.html
15:40:51 <RustyShackleford> tempname11_: what would you do with it then? I agree that its pretty long
15:40:58 <arkeet> intercalate divider [concat ["\t", x, " |", y, "| ", x, "\n"] | x <- rankLabels | y <- ranks]
15:41:00 <randir> the core of what makes it a good FP function is that it's pure, prettyShow :: Position -> String
15:41:07 <shachaf> RustyShackleford: I think a way of improving it might be to make your board representation more abstract.
15:41:14 <randir> so even if the function isn't the neatest, it's fully encapsulated. 
15:41:20 <randir> and can be easily composed with other stuff
15:41:49 <RustyShackleford> shachaf: well i'm going to abstract away things like making moves and such
15:41:54 <behelit> merijn: so i use <> instead
15:41:55 <shachaf> The bit representation is fine but it's probably useful to think about what operations you need on the board and define them as separate functions, so most of the code doesn't care about it.
15:42:18 <shachaf> And if you want you can change the definition or something.
15:42:21 <tempname11_> arkeet: that doesn't work
15:42:24 <tempname11_> I think
15:42:24 <shachaf> I don't know, it depends on how you'll be using it.
15:42:26 <behelit> merijn: but now i get another error "Couldn't match type ‘Text’ with ‘[Char]’" a bit further up (code that works just fine if i just write the string literal)
15:42:27 <arkeet> you need ParallelListComp
15:42:32 <RustyShackleford> so i can say move from e5 to d5, instead of moving from index x to y for example
15:42:43 <kaiyin> From learn you a haskell: Instead of the data keyword, the newtype keyword is used. Now why is that? Well for one, newtype is faster. If you use the datakeyword to wrap a type, there's some overhead to all that wrapping and unwrapping when your program is running.
15:42:50 <kaiyin> Is this still true?
15:42:57 <arkeet> behelit: where is this code?
15:43:13 <monochrom> kaiyin: yes
15:43:16 <arkeet> kaiyin: it is no less true now than when it was written.
15:43:20 <behelit> arkeet: one sec
15:43:26 <merijn> kaiyin: Yes, the difference between data and newtype is that at runtime a newtype is identical to whatever it wraps
15:43:45 <tempname11_> arkeet: oh, is the second | the extension syntax?
15:43:45 <merijn> kaiyin: i.e. "newtype Even = Even Int" will at runtime have the exact same representation as Int
15:43:55 <arkeet> tempname11_: yes, the ParallelListComp extension.
15:44:00 <tempname11_> cool
15:44:02 <merijn> kaiyin: As a result there are some strictness differences, though
15:44:04 <lpaste> behelit pasted “No title” at http://lpaste.net/128372
15:44:10 <hpc> technically, all that's guaranteed is that in "newtype Foo = Foo Bar", Foo undefined = undefined
15:44:23 <behelit> arkeet: there
15:44:34 <arkeet> mind putting the error message together with that?
15:44:44 <arkeet> the full message
15:45:00 <shachaf> If you feel the need to put "technically" in front of your message, make sure you're entirely correct.
15:45:03 <behelit> arkeet: sure, one sec :)
15:45:21 <randir> monochrom: Do you think I should have castle-data, en pessant, repetion and such be part of a Position, or move it higher?
15:45:22 <hpc> shachaf: eh? i could have sworn that's all the report says
15:45:29 <shachaf> "newtype Foo = Foo Bar" and "data Foo = Foo !Bar" are different, so this isn't the only difference.
15:45:39 <lpaste> behelit annotated “No title” with “No title (annotation)” at http://lpaste.net/128372#a128373
15:45:46 <hpc> doh
15:45:55 <lpaste> behelit revised “No title (annotation)”: “No title” at http://lpaste.net/128373
15:46:04 <indiagreen> hpc: it says “introduces a new type whose representation is the same as an existing type.”
15:46:12 <arkeet> ok, well getWith expects a String in its second argument.
15:46:13 <randir> monochrom: Position should be able to map to a position evaluation, so I'm thinking it should know of en-pessant and such 
15:46:20 <arkeet> but url is a Text, because threadId is a Text.
15:46:21 <merijn> hpc: "A declaration of the form newtype cx => T u1 … uk = N t introduces a new type whose representation is the same as an existing type"
15:46:22 <monochrom> randir: I do not know.
15:46:23 <hpc> indiagreen: yeah, just looked it up
15:46:42 <hpc> "A type created by newtype differs from an algebraic datatype in that the representation of an algebraic datatype has an extra level of indirection. This difference may make access to the representation less efficient"
15:46:57 <behelit> arkeet: well, that's really hairy. do i need to "unpack" the string somehow then?
15:47:16 <hpc> it's been too long :(
15:47:19 <arkeet> text has a function unpack :: Text -> String
15:47:35 <shachaf> Of course, the Report doesn't *really* say what "representation" means.
15:47:57 <tempname11_> btw, is there any point at all in using a "data" instead of a "newtype" when you only have one constructor?
15:48:19 <shachaf> There's a point when you want the extra box.
15:48:21 <hpc> shachaf: there's not many things it can mean
15:48:22 <behelit> arkeet: you rock. thanks a lot
15:48:26 <EvanR> you get an extra bottom
15:48:41 <behelit> this whole [char], string, text business is confusing ... at-least for an idiot
15:48:46 <monochrom> but I know what I would do. like you agreed, I would set up an abstraction layer (wrapper). in the internals, in the first version, I don't store the extra useful information (it can always be re-computed when you want). later, I will use benchmarks to help me decide "should I re-compute? or pre-compute and store?" changing from one to the other means changing the internals only.
15:48:49 * hackagebot mono-traversable 0.9.0.2 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.0.2 (MichaelSnoyman)
15:48:56 <tempname11_> how would you use an extra bottom?
15:49:04 <shachaf> When I evaluate Haskell code in my head, a newtype doesn't have the same representation as the underlying data type.
15:49:13 <shachaf> And my head is fairly compliant with the Report.
15:50:36 <merijn> behelit: String and [Char] are identical
15:50:52 <merijn> i.e. 
15:50:58 <merijn> "type String = [Char]"
15:50:59 <monochrom> behelit: if you're prototype without worrying speed, use String aka [Char] for now. if you worry about speed, you can use Text, plus explicit conversions Text <-> String at necessary points. in no case do you use OverloadedString unless you're a type expert.
15:51:54 <EvanR> type Expert = ?
15:52:16 <randir> if I have a mutable vector as my board type
15:52:26 <monochrom> type expert means you fully understand the meaning of "IsString a => a" and its implications
15:53:11 <tempname11_> EvanR: would you mind expanding on the "extra bottom" comment? I understand what it means, but I can't think of a practical application of it.
15:53:16 <monochrom> a program that uses only String requires you to learn just one thing, String.
15:53:19 <randir> when I make a move (i.e., go down a branch on the tree), would I have to copy the array?
15:53:36 <monochrom> a program that uses only String and Text requires you to learn just two things, String and Text.
15:53:39 <porglezomp> So far it looks like removing ~/.ghc fixed everything!
15:53:43 <randir> I guess it depends on my algorithm and if I try to parallelism 
15:53:44 <porglezomp> So yay!
15:53:49 * hackagebot atomic-write 0.2.0.2 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.2.0.2 (jsl)
15:54:06 <monochrom> a program that uses String, Text, and OverloadedString requires you to learn 4 things: String, Text, IsString a => a, and OverloadedString
15:54:28 <Lokathor> i use OverloadedString so that I can put in Text literals
15:54:29 <monochrom> therefore, that last one has the highest barrier, steepest learning curve, whatever you call it
15:54:45 <Lokathor> I suppose I could use String literals and make constants with pack
15:54:47 <monochrom> this is so obviously tautologically true that people refuse to accept it
15:55:12 <shachaf> Was there talk about defining "instance a ~ Char => IsString [a]" instead of "instance IsString [Char]"?
15:55:19 <shachaf> I vaguely remember something like that.
15:55:32 <shachaf> It would improve the OverloadedStrings experience in ghci.
15:56:17 <shachaf> I don't want to turn on OverloadedStrings because it makes «length "hello"» an error.
15:56:21 <porglezomp> Can two things of different type ever be (==)?
15:56:38 <arkeet> that question is a type error.
15:56:38 <kaiyin> :t ==
15:56:38 <lambdabot> parse error on input ‘==’
15:56:45 <arkeet> :t (==)
15:56:46 <lambdabot> Eq a => a -> a -> Bool
15:56:58 <roboguy_> tempname11_: I think there's a difference between defining Void with newtype and defining it with data, but I don't remember how it works and I can't seem to get GHCi to show a difference so far
15:56:59 <porglezomp> That answers that then
15:57:03 <monochrom> I don't mean to say that beginners are expected to know what I said and make the right choice.
15:57:31 <monochrom> I mean to say that teachers who show off OverloadedStrings prematurely are a disservice.
15:57:41 <roboguy_> tempname11_: a newtype has a strict field and a data doesn't though
15:58:09 <porglezomp> I am basically in my first hour using Haskell (not just getting GHC 7.8 to compile) again after a year
15:58:15 <porglezomp> I've forgotten a lot
15:58:20 <tempname11_> roboguy_: err, doesn't Void have 0 constructors? how can it even be a newtype?
15:58:29 <roboguy_> tempname11_: newtype Void = Void Void
15:58:36 <tempname11_> damn
15:58:41 <roboguy_> But you don't want to export that
15:59:17 <roboguy_> ohh, I remember now
15:59:21 <arkeet> if you define data Void = Void Void
15:59:22 <roboguy_> > Just undefined `seq` 3
15:59:24 <lambdabot>  3
15:59:31 <shachaf> No problem with exporting newtype Void = Void Void
15:59:36 <roboguy_> > Sum undefined `seq` 3
15:59:37 <lambdabot>  *Exception: Prelude.undefined
15:59:38 <arkeet> that has one fully defined value (namely, fix Void)
15:59:51 <roboguy_> Sum is a newtype
16:00:18 <arkeet> otoh you could data Void = Void !Void, and then you couldn't construct a non-bottom value.
16:00:25 <behelit> merijn: i know they are identical, but the parser seems to distringuish between the two when presenting type information.
16:00:59 <behelit> merijn: or s/i know they are/i supposed they were/
16:01:49 <porglezomp> Compiling Math.NumberTheory.Logarithms
16:01:52 <arkeet> type Void = <some unexported data type>
16:02:03 <monochrom> behelit: do you mean that you have "type X = YYY", and subsequently compiler error messages sometimes say "X" and some other time says "YYY"?
16:02:15 <roboguy_> shachaf: Hmm, I guess you're right. I was thinking you could make two different kinds of bottom, but maybe not
16:02:55 <tempname11_> ehh, why do we need such convoluted definitions of Void? what's wrong with "data Void" without constructors?
16:03:04 <arkeet> what is the runtime representation of newtype Void = Void Void?
16:03:06 <behelit> monochrom: i mean like when i get a compiler error like "    Couldn't match type ‘Text’ with ‘[Char]’ Expected type: String"
16:03:35 <shachaf> "data Void" is not valid in Haskell 98.
16:03:40 <arkeet> tempname11_: that's not valid haskell 98
16:03:41 <monochrom> yeah, in this example "type String = [Char]"
16:03:49 * hackagebot marquise 4.0.0 - Client library for Vaultaire  http://hackage.haskell.org/package/marquise-4.0.0 (fractalcat)
16:03:51 * hackagebot dotenv 0.1.0.7 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.7 (jsl)
16:03:57 <monochrom> this is a known problem that no one assigns a high priority to solve
16:04:19 <monochrom> to make it higher priority, start a Kickstarter project to solicit funding for solving it
16:04:29 <behelit> monochrom: and i think i've got the hang of it now, it was just confusing as a total newbie
16:05:10 <tempname11_> OK, thanks. But it still doesn't answer my question of a _practical_ use of a single-constructor "data" declaration
16:05:19 <tempname11_> I don't consider Void practical :)
16:05:22 <monochrom> I would write "[Char]" throughout in tutorials and not bother with "String"
16:05:23 <merijn> behelit: GHC tries to (best effort) use type synonyms when you use them in the signatures, but not for inferred types, hence the behaviour
16:05:41 <behelit> monochrom: many tutorials i read use overloadedstrings
16:06:32 <behelit> merijn: got it. and i assumed they were considered the same, i just wrote the three to show just how confused i was
16:06:40 <porglezomp> Is there any reason that it couldn't check if the inferred type is equal to any explicitly typed things and use that synonym? What kinds of conditions would fail there?
16:07:26 <behelit> so why Text? (yes, i could probably google that).. performance?
16:07:42 <porglezomp> I get that anythng would have to be implemented, but would a solution that simple work?
16:07:44 <ski> tempname11_ : "is there any point at all in using a \"data\" instead of a \"newtype\" when you only have one constructor?" -- is there any point in adding the additional complication / special case of not allowing `data' with one data constructor with one argument ?
16:07:47 <behelit> or consistency with the other types?
16:07:52 <arkeet> pretty much performance.
16:08:02 <merijn> behelit: Text is MUCH faster
16:08:03 <behelit> otherwise [Char] is pretty nice ....
16:08:13 <ski> tempname11_ : .. also, why isn't `Void' practical ? :)
16:08:14 <arkeet> for instance, Text has constant time indexing.
16:08:16 <merijn> behelit: String can take up to 20 bytes per character
16:08:17 <porglezomp> Is text a contiguous array of characters?
16:08:21 <merijn> arkeet: Does not
16:08:24 <arkeet> except when it doesn't.
16:08:33 <arkeet> so.
16:08:44 <quchen> [Char] is a singly linked immutable list of individual characters, with all the performance implications. It is by no stretch of the imagination a good format to represent text.
16:08:46 <merijn> behelit: Text should average 1-4 bytes per character (plus like a few more for every 4kb (or whatever it is) block)
16:08:50 * hackagebot atomic-write 0.2.0.3 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.2.0.3 (jsl)
16:08:58 <alynn> ski: there are cases when one can't use newtype
16:09:04 <merijn> Well, 2-4 bytes, I guess since it's utf-16 internally
16:09:06 <arkeet> doesn't Text use utf-16
16:09:06 <alynn> existential quantification for instance
16:09:07 <arkeet> yeah
16:09:09 <tempname11_> ski: I like how you escaped my quotes inside your quotes
16:09:09 <shachaf> merijn: 40, isn't it?
16:09:18 <merijn> shachaf: Depends on pointer size, etc.
16:09:27 <alynn> oh
16:09:29 <alynn> sorry
16:09:33 <alynn> s/ski/tempname1_/
16:09:43 <arkeet> well it has constant time something then.
16:09:50 <alynn> s/tempname1_/tempname11_/ I'm bad at nicks
16:10:02 <ski> tempname11_ : oh .. so i did
16:10:12 * ski barely noticed
16:10:12 <merijn> arkeet: length? :p
16:10:17 <merijn> For strict Text, that is
16:10:19 <arkeet> nope.
16:10:19 <arkeet> :p
16:10:24 <roboguy_> tempname11_: void is used in packages like pipes and warp. Although, it is defined using a newtype not a single field data
16:10:27 <arkeet> for the same reason as indexing.
16:10:27 <dmj`> can Elm programs share types w/ haskell programs?
16:10:44 <arkeet> it has O(1) last.
16:10:48 <arkeet> because that's totally useful.
16:10:55 <merijn> porglezomp: Basically, although it depends between strict and lazy Text. The latter is a string of contiguous character arrays, iirc
16:11:04 * ski argues that `absurd :: Void -> a' should be renamed to `void :: Void -> a'
16:11:16 <merijn> porglezomp: So a list of 4k dense blocks
16:11:16 <arkeet> :t void
16:11:17 <lambdabot> Functor f => f a -> f ()
16:11:18 <roboguy_> ski: wouldn't that conflict?
16:11:25 <ski> roboguy_ : exactly, that's the point
16:11:36 <ski> that other `void' should be relegated to FFI uses
16:11:51 <arkeet> writing () <$ everywhere isn't so bad.
16:11:54 <arkeet> only one more character than void.
16:12:02 <arkeet> and one fewer than void $
16:12:09 <roboguy_> arkeet: not if you get rid of the space!
16:12:12 <ski> (you could also export it in non-FFI contexts under a more appropriate name. perhaps `ignore')
16:12:30 <quchen> "discard" is taken by pipes. Sneaky Tekmo
16:13:23 <porglezomp> :t absurd
16:13:24 <lambdabot> Not in scope: ‘absurd’
16:13:40 <ski> @type Data.Void.absurd
16:13:41 <lambdabot> Data.Void.Void -> a
16:13:51 <porglezomp> That
16:13:55 <porglezomp> 's pretty absurd
16:13:59 <behelit> anyways, second day with haskell and i'm enjoying myself immensely. what do people use it for (over other languages) in "the real world"? :-)
16:14:25 <porglezomp> What does absurd use for the value?
16:14:33 <arkeet> it doesn't.
16:14:47 <arkeet> there is no value you can pass it.
16:14:51 <tempname11_> absurd undefined ~ undefined ?
16:15:08 <merijn> behelit: Shell scripting >.>
16:15:13 <shachaf> absurd _|_ = _|_
16:15:22 <merijn> behelit: I'm only partially joking too...
16:16:16 <tempname11_> merijn: partial jokes are unsafe, don't you know?
16:16:27 <ski> case in point for calling it `ignore' : basically the same idea (for side-effects, not generalized to any functor) is called that in SML and O'Caml
16:16:38 <Choups> www.vulnapps.com what is this?
16:17:05 <tempname11_> Choups: let me guess, a spam link?
16:17:20 <ski> porglezomp : `absurd v = case v of {}' -- there are no possible constructor cases
16:17:45 <tempname11_> is absurd a total function?
16:17:45 <Choups> tempname11_: i honestly dont know
16:17:52 <arkeet> yes it is.
16:17:55 <ski> yes
16:18:06 <arkeet> vacuously so.
16:18:18 <porglezomp> It's impossible to write a function `f :: a -> b`, right?
16:18:18 <ski> it is totally defined on every total input
16:18:32 <ski> @type undefined :: a -> b
16:18:33 <roboguy_> porglezomp: well it's "impossible"
16:18:35 <lambdabot> a -> b
16:18:39 <EvanR> :t const id
16:18:40 <lambdabot> b -> a -> a
16:18:52 <arkeet> it's impossible to write a total f :: forall a b. a -> b
16:18:53 <EvanR> nvm
16:18:56 <ski> @type const undefined
16:18:57 <lambdabot> b -> a
16:19:04 <behelit> anyway, time for bed. thanks for the help everyone!
16:19:08 <shachaf> ski: Foiled again.
16:19:16 <tempname11_> @type unsafeCoerce
16:19:16 <lambdabot> Not in scope: ‘unsafeCoerce’
16:19:21 <ski> shachaf ?
16:19:41 <arkeet> @type undefined :: ski -> shachaf
16:19:42 <shachaf> You were trying to get a function :: a -> b, but you got a function :: b -> a
16:19:42 <lambdabot> ski -> shachaf
16:20:46 <porglezomp> > 1 + (absurd (undefined 1))
16:20:52 <lambdabot>  Not in scope: ‘absurd’
16:21:01 <arkeet> @let import Data.Void
16:21:03 <lambdabot>  .L.hs:118:1:
16:21:03 <lambdabot>      Data.Void: Can't be safely imported!
16:21:04 <lambdabot>      The package (void-0.6.1) the module resides in isn't trusted.
16:21:04 <arkeet> oh.
16:21:20 <ski> shachaf : ah :)
16:21:22 <shachaf> All you'll get from any of this is undefined errors anyway. You don't need lambdabot for that.
16:22:33 <ski> porglezomp : should be bottom, since `+' is strict on `Integer'
16:22:55 <arkeet> oh, Data.Void actually does define newtype Void = Void Void
16:23:42 <porglezomp> Can any type infer to Void?
16:23:45 <roboguy_> arkeet: for when you need Void, but you also need Haskell98 compatibility!
16:23:50 <porglezomp> There's no way to construct it
16:23:53 <porglezomp> But
16:23:53 <roboguy_> porglezomp: what do you mean?
16:24:00 <ski> arkeet : i suppose operationally `absurd (error "foo")' will possibly loop forever, then ?
16:24:06 <roboguy_> It's just a normal type
16:24:24 <porglezomp> Okay
16:24:30 <porglezomp> Normal type with no constructors
16:24:36 <roboguy_> yep
16:24:42 <arkeet> :t let foo = Data.Void.absurd foo in foo
16:24:44 <lambdabot> Data.Void.Void
16:25:03 <arkeet> there, I inferred it.
16:25:08 <shachaf> ski: That depends on how you define absurd.i
16:25:28 <zipper> Anyone know a function like "Data.List.words" but can split a list at whichever charachter I tell it to split it at and not just spaces?
16:25:49 <ski> shachaf : yes .. however, a recursive `newtype Void = Void Void' would immediately suggest a recursive `absurd (Void v) = absurd v' (compare with `foldr')
16:25:58 <indiagreen> zipper: there's a bunch in the split package
16:26:00 <arkeet> zipper: the split package has some stuff for that.
16:26:30 <zipper> Oh my I didn't know there was a split package. I hope it works for Text
16:26:30 <ski> (or perhaps a `cata' using `Mu' is a better comparision)
16:26:40 <arkeet> unfortunately it's just for lists.
16:26:48 <zipper> arkeet: arrgghhhhh
16:27:09 <arkeet> maybe you should have asked fro something like Data.Text.words
16:27:24 <arkeet> but you know, text has splitOn
16:27:34 <arkeet> or split
16:27:41 <RustyShackleford> [x+y | x <- [1, 2, 3], y <- [1, 2, 3]] will have 9 elements, its like a nested loop. What if i want a list that only has 3 elements?
16:27:44 <zipper> arkeet: I didn't
16:27:55 <roboguy_> RustyShackleford: which three?
16:27:56 <RustyShackleford> [1+1, 2+2, 3+3]
16:28:00 <porglezomp> Well, I'm going to go now
16:28:01 <zipper> arkeet: Let me look for Data.Text.splitOn
16:28:02 <RustyShackleford> roboguy_: see the pattern?
16:28:02 <arkeet> RustyShackleford: turn on ParallelListComp and replace the , with |
16:28:02 <porglezomp> Bye guys!
16:28:04 <roboguy_> RustyShackleford: zip3
16:28:10 <arkeet> RustyShackleford: or use zipWith
16:28:11 <roboguy_> :t zipWith3
16:28:12 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:28:21 <roboguy_> or just zipWith I mean
16:28:34 <arkeet> > zipWith (+) [1,2,3] [10,20,30]
16:28:35 <shachaf> ski: Data.Void defines it with seq
16:28:35 <lambdabot>  [11,22,33]
16:28:42 <ski> RustyShackleford : `zipWith (+) [1, 2, 3] [1, 2, 3]', or, using the `ParallelListComp' language extension, `[x+y | x <- [1, 2, 3] | y <- [1, 2, 3]]'
16:28:43 <shachaf> ski: Presumably because an error is more useful than a loop.
16:28:53 <ski> shachaf : ok, good
16:29:11 <arkeet> > [x+y | x <- [1,2,3] | y <- [10,20,30]]
16:29:12 <lambdabot>  [11,22,33]
16:29:17 <RustyShackleford> arkeet: is enabling that option common?
16:29:24 <RustyShackleford> any pitfalls?
16:29:41 <arkeet> nothing bad will happen.
16:29:46 <ski> RustyShackleford : i don't think you can nest the parallel thing construction ?
16:29:50 <shachaf> I wish the type Void1 had a better name.
16:30:06 <arkeet> list comprehensions seem to not be used terribly often though.
16:30:16 <arkeet> what is Void1?
16:30:18 <ski> > [x+y+z | (x <- [1,2,3] | y <- [40,50,60]) , z <- [700,800]]
16:30:19 <lambdabot>  <hint>:1:13: parse error on input ‘<-’
16:30:50 <arkeet> > [x+y+z | x <- [1,2,3] | y <- [40,50,60], z <- [700,800]]
16:30:52 <lambdabot>  [741,842,753]
16:31:15 <ski> > [x+y+z | (x,y) <- [(x,y) | x <- [1,2,3] | y <- [40,50,60]],z <- [700,800]]  -- workaround
16:31:17 <lambdabot>  [741,841,752,852,763,863]
16:31:30 <ski> (eta expansion, if you will)
16:31:41 * ski ponders that
16:31:54 <roboguy_> shachaf: that's a new one for me. It's not Proxy?
16:32:05 <roboguy_> or, Proxy with no values I guess
16:32:17 <arkeet> Void1 is Const Void?
16:33:47 <RustyShackleford> it just seems strange that you need a compile option for that to work
16:34:03 <RustyShackleford> what's the reasoning behind that?
16:34:10 <arkeet> it's not standard haskell 2010.
16:34:12 <roboguy_> RustyShackleford: it's not part of the standard
16:35:15 <hunteriam> Why Void Void
16:35:18 <hunteriam> And not just Void
16:35:23 <hunteriam> Is Void a container
16:35:33 <ski> RustyShackleford : you could say `{-# LANGUAGE ParallelListComp #-}' at the top of your source file
16:35:47 <roboguy_> hunteriam: then you would be able to construct a value of type Void
16:36:00 <roboguy_> which defeats the purpose
16:36:17 <hunteriam> Data Void = Void?
16:36:19 * ski would prefer `newtype Void = MkVoid Void'
16:36:21 <hunteriam> Why have Void Void
16:36:23 <tempname11_> > [x+y+z | x <- [0,0,0,0] | y<-[0,0,0,0], z <- [1,2]] -- why does this loop around on z?
16:36:24 <roboguy_> hunteriam: that would be the same as ()
16:36:24 <lambdabot>  [1,2,1,2]
16:36:39 <hunteriam> roboguy_: would they literally ~?
16:36:44 <roboguy_> hunteriam: no
16:36:45 <arkeet> > [(y,z) | y<-[0,0,0,0], z <- [1,2]]
16:36:46 <lambdabot>  [(0,1),(0,2),(0,1),(0,2),(0,1),(0,2),(0,1),(0,2)]
16:36:49 <roboguy_> hunteriam: they are not the same type
16:36:54 <hunteriam> Robo roboguy_ why do we want them to be different
16:37:06 <arkeet> zipping with x <- [0,0,0,0] just cuts it off to 4 elements.
16:37:11 <ski> tempname11_ : that runs the "loop on `x'" in "parallel" with the "loop on `y', and (nestedly) `z'"
16:37:23 <hunteriam> Is void not construct Able?
16:37:28 <hunteriam> Constructable
16:37:39 <arkeet> you can't construct a value of type Void.
16:37:41 <arkeet> that is the point.
16:37:46 <ski> hunteriam : you can't construct a total value in `Void'
16:37:53 <shachaf> arkeet: I thought Void had no points?
16:38:03 <arkeet> :(
16:38:14 <tempname11_> oh, right
16:38:19 <monochrom> :)
16:38:27 <benzrf> auggghhh
16:38:30 <benzrf> options:
16:38:37 <ski> shachaf : clearly arkeet's point "can't construct a value of type Void" was a point in `Not Void', iow `Void -> Void' :)
16:38:40 <benzrf> 1. use a typeclass and force my argument to be forall instances
16:38:47 <arkeet> :)
16:38:54 <benzrf> 2. use a free monad, but it has to be a crazy GADT and tbh i dont even know if its a functor
16:39:03 <RustyShackleford> i think i'll just use a lamda for now
16:39:17 <RustyShackleford> instead of a parallel list comprehension
16:39:25 <arkeet> benzrf: what is the goal?
16:39:27 <shachaf> You and the Unicode consortium both.
16:39:31 <ski> benzrf : perhaps use `CoYoneda' to force it to be a functor ..
16:39:37 <benzrf> ;-;
16:39:55 <benzrf> arkeet: non-implementation-specific monad that library consumer uses
16:39:58 <benzrf> er, fuck wait
16:40:09 <shachaf> Using Coyoneda to force a type constructor to be a functor for use in a free monad is "operational"'s trick.
16:40:23 <arkeet> well, free-operational
16:40:32 <benzrf> arkeet: want to force the library user to be generic over the operations they can use
16:40:33 <arkeet> operational does it directly.
16:40:45 <benzrf> this is a typical use case for free monads, i hear
16:40:49 <c_wraith> arkeet: well, the type operational uses is just what you get if you inline Coyoneda into free
16:40:53 <shachaf> I never heard of free-operational.
16:41:03 <shachaf> But, sure, it's inlined.
16:41:29 <arkeet> free-operational makes it explicitly Free of CoYoneda.
16:42:17 <shachaf> arkeet: But in the end it's still a newtype? What's the point?
16:42:22 <arkeet> then there is also minioperational.
16:42:28 <arkeet> which makes it all CPS'd.
16:42:47 <benzrf> blargh
16:43:08 <bazqux> I've just made my own simple data type, converting from a tuple, I want to serialise it with Data.Binary is there some simple way of achieving this?
16:43:13 <benzrf> should i go the dumb route and just use a type without exporting the data constructors and then provide functions for building elements
16:43:17 <benzrf> that seems a little gross
16:43:31 <ski> shachaf : hm, i don't see the coyoneda thing at <https://hackage.haskell.org/package/operational>
16:43:34 <arkeet> write/derive a Binary instance for it?
16:43:46 <arkeet> ski: it's inlined. ;)
16:43:47 <shachaf> ski: It doesn't talk about it, the types are just isomorphic.
16:43:48 <benzrf> i explicitly do NOT want the users doing arbitrary things in the implementation monad
16:43:55 <bazqux> (Maybe with TemplateHaskell?)
16:43:58 <arkeet> ski: free-operational makes it explicit.
16:44:05 * benzrf has a headache
16:44:07 <monochrom> benzrf: that is not a dumb thing to do.
16:44:24 <benzrf> maybe ive just convinced myself that anything that works in haskell 2010 is dumb
16:44:25 <benzrf> :D
16:44:36 <benzrf> oh wait i dont have a headache
16:44:41 <benzrf> i meant a metaphorical headache
16:44:53 <ski> shachaf : must be some non-obvious iso, then
16:45:08 <benzrf> augh i should just wipe this crap and start over u_u
16:45:28 <bazqux> arkeet: Binary doesn't seem to support deriving, and writing one seems over the top for such a simple thing. - The tuple I was using before just worked.
16:45:32 <monochrom> that is not a dumb thing to do either :)
16:45:37 <arkeet> bazqux: newtype deriving
16:45:44 <arkeet> assumign it's a newtype.
16:45:52 <arkeet> if it's not a newtype, then you can't.
16:46:07 <Enigmagic> binary has Generic deriving support iirc
16:46:15 <arkeet> writing Binary instances isn't so bad.
16:46:26 <shachaf> ski: It's pretty straightforward. data Free f a = Pure a | Free (f (Free f a)); data Program f a = Return a | forall x. Bind (Program f x) (x -> Program f a)
16:46:26 <arkeet> it's like writing Traversable instances.
16:46:27 <bazqux> arkeet: I'll look into that, thanks.
16:46:46 <bazqux> arkeet: Yeah, it just seems overly verbose that's all.
16:46:48 <benzrf> fuck it im pushing git back ;-;
16:46:59 <arkeet> except Traversable can be derived, heh.
16:47:40 <ski> shachaf : i don't see how that compares to `data CoYoneda f b = forall a. MkCoYoneda (f a) (a -> b)'
16:48:04 <tempname11_> benzrf: experiencing the dark side of Crazy Type Laboratory? :)
16:48:05 <arkeet> it looks pretty comparable to me.
16:48:15 <benzrf> probably -_-
16:48:17 <shachaf> I got it wrong.
16:48:43 <shachaf> ski: It's pretty straightforward. data Free f a = Pure a | Free (f (Free f a)); data Program f a = Return a | forall x. Bind (f x) (x -> Program f a)
16:48:49 <bazqux> arkeet: At the moment it isn't a newtype because I gave my fields labels. So it seems I have to make a choice between trivial Binary derivation and labels right?
16:48:49 <ski> arkeet : looks more `CoDensity'-like, to me ..
16:49:47 <shachaf> Free (Coyoneda f) a = Pure a | Free (exists x. (f x, x -> Free (Coyoneda f) a))
16:50:39 <shachaf> It's very frustrating to type with a ~1s delay between pressing a key and seeing it appear on the screen.
16:50:46 <ski> oh, `Coyoneda' inside `Free' -- for some reason i was looking for the other way around
16:51:03 <meditans> hi, a question on Reactive banana. There is no explicit dealing with time, so in one of the examples it's used Timer from Graphics.UI.WX. What should I use to obtain that behaviour without Graphics.UI.WX (eg, in a console)?
16:51:20 <ski> shachaf,arkeet : ty
16:51:22 <arkeet> it would seem weird to me to start with a Functor, then get a Free monad from it, then turn it back into a functor with Coyoneda.
16:51:36 <benzrf> meditans: truly a mystery of the ages
16:51:40 <shachaf> ski: Oh, no, that's some strange thing.
16:51:52 <arkeet> Coyoneda, Free, and Program are all free constructions.
16:52:01 <shachaf> Although Coyoneda (Free f) is a monad if f is a functor.
16:52:16 <arkeet> so Free . Coyoneda = Program, just by that fact.
16:52:28 <ski> i suppose a point is that `Free' preserves being a functor
16:54:12 <ski> (i suppose i didn't really notice "for use in a free monad" much)
16:55:31 <shachaf> You brought up Coyoneda for this use, I thought.
16:56:39 <sebastianrkg> I'm getting the error "*** Failed! Exception: 'Prelude.undefined' (after 1 test): " when running a QuickCheck within Test Framework
16:56:41 <meditans> benzrf: it may not be, do you know a solution? :)
16:56:51 <benzrf> lol no
16:56:55 <benzrf> u_u
16:56:57 <sebastianrkg> is this a common thing? It doesn't even seem to get down to my test logic
16:57:05 <sebastianrkg> from what I've seen from tracing out some info
16:57:12 <benzrf> where are you using undefined, sebastianrkg
16:57:43 <sebastianrkg> benzrf: I didn't think I was using undefined at all
16:57:49 <benzrf> how strange
16:58:14 <ski> (shachaf : yes, for making the result a functor. so i was thinking of `CoYoneda (...)' rather than `..(CoYoneda (...))..', not considering that `Free' would preserve it)
17:00:54 <shachaf> Ah.
17:01:16 <shachaf> You were thinking of Coyoneda (Free f) for non-functor f?
17:03:19 <ski> shachaf : yes, or `CoYoneda (...)' for any non-functor `...', really
17:03:50 <shachaf> Free is a bad name for a free monad, anyway.
17:03:52 * hackagebot har 0.1.0.0 - HAR spec in Haskell  http://hackage.haskell.org/package/har-0.1.0.0 (HaishengWu)
17:03:58 <shachaf> So many things are free.
17:04:01 <ski> yes
17:04:49 <benzrf> wait omg
17:04:53 <benzrf> i just realized...
17:05:17 <benzrf> is there some kind of analogue to the theorem about monoid morphisms from lists
17:05:34 <benzrf> well i guess first off you need Free to be an MFunctor
17:05:45 <benzrf> it /is/, right?
17:06:45 <ski> benzrf : by `MFunctor, what do you mean ?
17:06:53 <benzrf> as in the mmorph pkg
17:07:59 <arkeet> Free can lift natural transformations, yes.
17:08:18 <benzrf> cool
17:08:19 <arkeet> hoistFree :: Functor g => (forall a. f a -> g a) -> Free f b -> Free g b
17:08:20 <benzrf> so then
17:08:47 <arkeet> or rather, it takes natural transformations to monad morphisms.
17:09:01 <benzrf> er, yes
17:09:25 <benzrf> any ntrf Free m ~> n will be equivalent to someSortOfFreeFold . hoistFree f where f :: m ~> n
17:10:09 <arkeet> well, the universal property is that for any monad m, natural transformations f ~> m are in bijective correspondence with monad morphisms Free f ~> m
17:12:01 <arkeet> and we have foldFree :: (Functor m, Monad m) => (forall x. f x -> m x) -> Free f a -> m a
17:12:08 <arkeet> witnessing one direction of that
17:13:07 <shachaf> arkeet: In what sense is Coyoneda a free construction?
17:13:39 <arkeet> shachaf: it freely gives you a functor from an object mapping.
17:13:52 * hackagebot har 0.1.1.0 - HAR spec in Haskell  http://hackage.haskell.org/package/har-0.1.1.0 (HaishengWu)
17:14:16 <mac10688> bitemyapp: I just listened to your podcast on functional geekery. Cool stuff sir
17:14:21 <arkeet> I should probably prove that.
17:14:29 <Guest42210> whenever I try something like: tell :: (Show a) => [a] -> String  I get an error that it's out of scope. 
17:14:32 <Guest42210> is that not right?
17:14:47 <Guest42210> what podcast?
17:14:55 <mac10688> functionalgeekery
17:15:06 <shachaf> arkeet: What's the category of object mappings?
17:15:14 <ski> Guest42210 : `tell' imported from which module ?
17:15:26 <arkeet> shachaf: I don't know.
17:15:46 <arkeet> that's the first step, I suppose.
17:15:51 <shachaf> Then I'm not sure what it means for it to be free.
17:16:09 <arkeet> perhaps it's a discrete category.
17:16:11 <shachaf> I assume the forgetful functor is pretty straightforward once you have an answer to that.
17:16:39 <arkeet> clearly the objects are just object mappings.
17:17:13 <Guest42210> ski: https://gist.github.com/anonymous/c0637f8841c8978541fa
17:17:36 <ski> could not be discrete, if it's supposed to be underlying to the functor category
17:17:39 <shachaf> OK, so what does the forgetful functor do with a natural transformation?
17:17:48 <kadoban> Guest42210: Well, what's head' ?
17:17:58 <Guest42210> kadoban: I'm trying to declare it
17:18:07 <Guest42210> following learn you a haskell
17:18:21 <shachaf> Guest42210: You gave a type but not a definition.
17:18:27 <ski> Guest42210 : i don't understand what that has to do with the `tell' you mentioned before
17:18:43 <Guest42210> ski: it's anything I try to do like that. 
17:18:46 <arkeet> ski: good point.
17:19:15 <Guest42210> shachaf: can you give me an example?
17:19:18 <kadoban> Guest42210: you probably need 'let' or something if you're doing this in ghci. I dunno, I don't use ghci much, especially as a beginner I found it confusing. I think my experience there doesn't match other people's, but *shrug*
17:19:34 <Guest42210> hmmm
17:19:35 <shachaf> "head' :: [a] -> a", and then, on the next line, "head' = ..."
17:19:49 <ski> Guest42210 : perhaps you should tell the channel how far you've currently got into LYAH ..
17:19:51 <Guest42210> shachaf: oh, I'm trying to get to the next line but it's giving me an error
17:19:57 <arkeet> ok, perhaps the arrows are just bunches of morphisms.
17:20:04 <shachaf> Trying to get to the next line?
17:20:09 <ski> Guest42210 : perhaps you could also tell the channel which error you're getting ?
17:20:10 <arkeet> like natural transformations. except there's no naturality law.
17:20:13 <shachaf> You need to put both lines in the file without loading it.
17:20:16 <shachaf> Also what ski said.
17:20:23 <Guest42210> ski: it's in the error log. 
17:20:39 * ski sees no error log at that GitHub Gist
17:20:48 <Guest42210> http://learnyouahaskell.com/syntax-in-functions
17:20:58 <Guest42210> I'm on that page about 1/3 of the way down
17:21:01 <shachaf> Guest42210: Are you running "ghci head.hs"?
17:21:04 <Guest42210> I am in ghci
17:21:06 <shachaf> It doesn't look like you are.
17:21:08 <Guest42210> however I wasn't doing it from a file
17:21:11 <Guest42210> so I'm guessing that's it
17:21:17 <kadoban> ski: Look up.
17:21:18 <shachaf> What does head.hs have to do with what you're doing?
17:22:05 <Guest42210> yep that's it
17:22:08 <shachaf> arkeet: That's a kind of strange category.
17:22:20 <ski> kadoban : where ? in the channel ? in LYAH ?
17:22:23 <Guest42210> shachaf: it's the command I'm trying to execute
17:22:26 <kadoban> Guest42210: https://gist.github.com/kadoban/34d417dd074620e49bd7 works, but is lame as hell. You're better off using a file and loading it.
17:22:30 <Guest42210> the rest of the command was on this page. 
17:22:40 <Guest42210> why is it that I have to use a file? I'm kindof confused about that. 
17:22:43 <kadoban> ski: In this gist he pasted: https://gist.github.com/anonymous/c0637f8841c8978541fa
17:22:45 <Guest42210> it makes sense now that I know that
17:22:55 <shachaf> You don't have to use a file. But if you're not using a file, you should tell people.
17:23:02 <shachaf> They have no hope of helping you if you don't say what you're doing.
17:23:03 <Guest42210> hmmm interesting
17:23:22 <ski> kadoban : i've already seen that. i don't see how that has to do with the current question about  head'
17:23:26 <geekosaur> ghci is not an ide, ghci is a desk calculator. typing stuff into ghci is different from putting them in a file and compiling it
17:23:33 <mac10688> sounds like a join.me is in order ;)
17:23:36 <Guest42210> sorry, I'm used to irb where it works almost exactly the same
17:23:38 <Guest42210> thank you
17:23:38 <kadoban> ski: You said you didn't see the error…the error is in there. *shrug*
17:23:53 <chris233> I have the book “Haskell Data Analysis Cookbook” that I’m willing to ship to whoever wants it for free (in North America). I suppose the only catch is that when I bought this book I received the eBook as well, which I plan to continue using. So if your conscience is ok with that let me know if you’re interested.
17:24:05 <shachaf> arkeet: But I guess an object mapping is kind of a strange thing.
17:24:29 <arkeet> shachaf: doesn't seem terribly strange to me.
17:25:06 <Guest42210> thank you all for your help!
17:25:22 <ski> kadoban : oh, you're right. clearly i'm too tired to do this atm. good night
17:25:23 <Guest42210> I'm surprised how active this channel is
17:25:28 <kadoban> chris233: That sounds like an interesting book I don't have a copy of yet, I'd be interested in it if you don't have a taker yet.
17:25:50 <kadoban> ski: No worries, it's easy to miss (I've done exactly the same thing several times :-/)
17:38:14 <bazqux> I'm still fairly new to haskell. Do "gch: panic!"s happen often? :-/
17:38:24 <arkeet> they shouldn't.
17:38:31 <hpc> what version of ghc?
17:38:41 <arkeet> what is the error?
17:38:49 <hpc> who is spain? why is hitler?
17:38:53 * hackagebot hopenpgp-tools 0.14.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.14.1 (ClintAdams)
17:40:02 <kadoban> bazqux: I've never seen one and I've been doing haskell for quite a while.
17:40:26 <sebastianrkg> how can I trace out whether something is undefined or not?
17:40:28 <kadoban> (I suspect they happen more often with interesting extensions to the language that I don't tend to play with)
17:40:49 <bazqux> hpc: 7.4.2
17:40:51 <sebastianrkg> I'm hunting down the bug I was experiencing, I think it has to do with the result of a file read being undefined
17:41:15 <roboguy_> sebastianrkg: did you search your sources for undefined?
17:41:21 <roboguy_> that's probably the easiest way
17:41:37 <hpc> sebastianrkg: what error are you getting?
17:41:48 <sebastianrkg> I think it's coming from Aeson, which uses undefined about a million times
17:41:57 <sebastianrkg> *** Failed! Exception: 'Prelude.undefined' (after 1 test): 
17:41:57 <sebastianrkg> (used seed -9128107776005051308)
17:42:17 <bazqux> arkeet: It just says the impossible happened. And mentions "nameModule makeBinary{tv a13C}". - makeBinary is what I had just added and presumably caused the error. It comes from the deriving package.
17:42:33 <sebastianrkg> I can't get past "print $ show decodedFile" though
17:42:39 <bazqux> kadoban: That's reassuring. :-)
17:42:45 <roboguy_> sebastianrkg: that's possibly a bug in Aeson, but definitely search your code for undefined first to rule that out
17:42:59 <roboguy_> sometimes I forget to take one out
17:43:00 <sebastianrkg> decodedFile = decode' fileLBS :: Maybe QueryResultMap
17:43:59 <sebastianrkg> I mean, I have this isolated down to that one line, I know that fileLBS is successfully read in (I can print out its contents), and I know that decode' is an aeson function
17:49:24 <roboguy_> sebastianrkg: do you have a handwritten instance of Constructor from GHC.Generics or a handwritten Typeable instance?
17:49:59 <sebastianrkg> I'm using this: $(deriveJSON defaultOptions ''QueryResultMap)
17:50:07 <sebastianrkg> so no, Template Haskell.
17:50:09 <roboguy_> In the Aeson github repository, I only see undefined in four files: two of them are tests and two use Generics and Typeable (but they should be safe, I believe, unless there's an instance that doesn't work the way it should)
17:51:49 <roboguy_> sebastianrkg: this is all I see https://github.com/bos/aeson/search?utf8=%E2%9C%93&q=undefined
17:51:49 <sebastianrkg> My data type does derive Generic: data QueryResultMap = QueryResultMap (Map QueryID FetchWindowResults) deriving (Eq, Show, Generic)
17:52:05 <mpickering> can you share your code sebastianrkg ?
17:52:15 <arkeet> any reason you're not using a type synonym or newtype?
17:52:30 <roboguy_> the builtin automatic deriving *shouldn't* cause that kind of problem
17:52:36 <roboguy_> hmm
17:52:47 <roboguy_> deriveJSON could be the culprit
17:53:07 <sebastianrkg> arkeet: I have a notion that this definition will need to be augmented. It's highly in-production
17:53:25 <enthropy> @where stacktrace
17:53:25 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
17:53:26 <sebastianrkg> mpickering: No, I can't share my code. Sorry, it would make things way easier, I know.
17:53:36 <roboguy_> sebastianrkg: is defaultOptions builtin?
17:53:43 <sebastianrkg> yeah
17:53:55 <sebastianrkg> or I think so?
17:54:02 <mpickering> because I highly doubt that it's in aeson
17:54:18 <sebastianrkg> ah maybe not actually
17:54:55 <sebastianrkg> yeah no, it's some template haskell that a coworker used
17:56:08 <RustyShackleford> i'm looking for a good guide to cabal
17:56:18 <arkeet> have you read the user's guide?
17:56:26 <roboguy_> oh, it looks like deriveJSON just derives the ToJSON and FromJSON classes
17:56:43 <RustyShackleford> no. I guess that would be the place to start
17:56:58 <RustyShackleford> sometimes the official documentation is more difficult than some 3rd party guide
17:56:59 <sebastianrkg> yes, it does. I think it was recommended code from the developers of Aeson, somewhere?
17:57:06 <roboguy_> sebastianrkg: you can print out fileLBS successfully?
17:57:21 <sebastianrkg> roboguy_: yes.
17:57:45 <roboguy_> sebastianrkg: does it have a custom Show instance? Maybe there's an undefined lurking in something that isn't shown
17:57:48 <ackthet> is there a way to generate RPMs from cabal?
17:58:06 <ackthet> ah cabal-rpm maybe
17:58:10 <ProofTechnique> Yup
17:58:13 <ProofTechnique> Was just about to link
17:58:17 <ackthet> amazing
17:59:05 <sebastianrkg> fileLBS? FileLBS is just a lazy bytestring, it shouldn't have anything custom to it
18:00:37 <roboguy_> sebastianrkg: hmm, you're using QuickCheck? What sort of test space are you using?
18:01:18 <sebastianrkg> that is where I would assume the problem comes in, because with QuickCheck I have no idea what I'm doing yet
18:01:41 <sebastianrkg> essentially I'm using monadicIO to test an IO action (actually two IO actions against each other)
18:02:22 <sebastianrkg> but this undefined actually occurs if I repl into the specific test file and just try to run this specific function without any QuickCheck or Test Framework stuff coming into it
18:03:03 <sebastianrkg> I'll probably need to ask the expert on this Template Haskell utility about it tomorrow. I'm not seeing an easy way out at the moment.
18:03:37 <roboguy_> sebastianrkg: and replacing that one line of code with the error with "print fileLBS" definitely works?
18:04:39 <sebastianrkg> well the function as a whole returns IO QueryTestMap, so the function doesn't work
18:04:56 <sebastianrkg> but printing fileLBS right before the error line prints out the file contents successfully.
18:06:26 <roboguy_> sebastianrkg: it prints the complete contents? what if you replace the erroring line with something that gives a different error like 'error "Something else"' and then put print fileLBS before that, so you can see if there's an undefined in /part/ of the fileLBS output
18:06:47 <sebastianrkg> Very good idea. Okay one sec
18:07:54 <sebastianrkg> *** Exception: Other nonsense!
18:08:00 <sebastianrkg> So the problem isn't with the file
18:10:18 <sebastianrkg> roboguy_: maybe a useful observation, I don't get the error until I try to access the decoded JSON
18:10:22 <sebastianrkg> even when using decode'
18:11:03 <sebastianrkg> so whatever error exists is hidden by laziness
18:12:42 <roboguy_> sebastianrkg: hmm...
18:12:49 <roboguy_> It looks like you can get a stack trace for undefined
18:13:07 <roboguy_> if you compile with profiling enabled and then pass your program the argument +RTS -xc
18:13:24 <roboguy_> https://wiki.haskell.org/Debugging
18:14:06 <ronbrz>  hello! I'm trying to install ihaskell from source, and I'm having trouble installing the correct version of ipython kernel. when I look at the ipython-kernel.cabal file, it looks like version is 0.4.0.0 . however, I am only able to install version 0.3.0.0 for some reason.
18:14:24 <ronbrz> here are the relevant commands I'm using in a pastebin http://pastebin.com/PcLpfYrb
18:16:18 <roboguy_> ronbrz: it looks like 0.4.0.0 doesn't exist on Hackage
18:16:33 <sebastianrkg> roboguy_: well, this takes quite a while to compile. I think I'm going to leave it for tomorrow. Thanks so much for your help, it's much appreciated.
18:16:45 <roboguy_> sebastianrkg: No problem! Hope you can figure it out!
18:16:58 <geekosaur> I see it?
18:17:05 <geekosaur> I even see an 0.5.0.0
18:17:07 <geekosaur> try cabal update
18:17:29 <ProofTechnique> ronbrz: I recommend Kronos Haskell
18:17:37 <ProofTechnique> http://www.kronosnotebook.com/haskell
18:17:40 <roboguy_> geekosaur: I'm looking at hackage.haskell.org...
18:17:42 <ProofTechnique> If you're on Mac, that is :|
18:17:46 <geekosaur> so am I
18:18:00 <arkeet> http://hackage.haskell.org/package/ihaskell
18:18:02 <geekosaur> http://hackage.haskell.org/package/ihaskell shows me 0.5.0.0
18:18:33 <roboguy_> geekosaur: oh, I meant ipython-kernel
18:18:45 <geekosaur> oh, sorry, lemme look
18:18:45 <roboguy_> "cabal install ipython-kernel-0.4.0.0"
18:19:16 <arkeet> https://github.com/gibiansky/IHaskell/blob/master/ipython-kernel/ipython-kernel.cabal
18:19:17 <geekosaur> right, 0.3.0.0
18:19:19 <arkeet> looks like hackage is behind git.
18:19:39 <geekosaur> yes, there's been no release apparently
18:20:09 <ronbrz> roboguy_: well, i cloned that repo. Is there some way to use the package in the git repo?
18:20:23 <roboguy_> ronbrz: cd to the directory and just run "cabal install"
18:20:47 <geekosaur> add-source like for ipython-display?
18:20:57 <roboguy_> oh, in a sandbox
18:23:30 <ronbrz> geekosaur: ohhh, haha, thanks. that should work. 
18:23:53 <ronbrz> still getting used to all this cabal stuff
18:25:54 <tongcx> is there some intuitive tutorial for adjoint functor?
18:28:26 <johnw> tongcx: imagine two categories, where some notion of a subset of the former maps isomorphically to the whole of the other.  And by subset I don't mean a subset of objects or morphism, but in the sense that something is forgotten in the mapping from C to D, and arbitrarily gained in the mapping from D to C.  So there is this "core" that is isomorphic between them, but then another part which you might call an enrichment to C that D does
18:28:27 <johnw> not possess.
18:28:32 <johnw> as a trivial example, think of floating point numbers and integers
18:28:47 <johnw> you can map all of the integers into the set of floating point and back; but not vice versa
18:29:31 <johnw> let's say we pick two functions, "toFloat" and "floor".  These two functions together will stand in the place of our functors, and provide a mapping between the two domains
18:29:41 <johnw> toFloat gains something arbitrarily, and floor forgets something
18:30:32 <johnw> but now we have an isomorphism in the relationship between these functions which preserves an order over the two sets.  This, at the level of functions and values and preserved orders, is called a Galois connection.
18:30:37 <tongcx> johnw: very clear
18:30:43 <johnw> if we think in terms of categories and functors, it generalizes to an adjunction
18:31:05 <tongcx> johnw: thanks a lot!
18:31:26 <johnw> this is a *very* common mathematical structure, it recurs everywhere
18:31:38 <johnw> it provides a way to think in a simpler domain, and convey your findings over to another, richer domain
18:31:57 <johnw> anyway, I have to run to dinner, perhaps someone else who knows better can continue
18:32:09 <arkeet> (the original galois connection is order-reversing btw)
18:32:26 <tongcx> johnw: thanks
18:33:12 <tongcx> i was trying to read some category theory, but all documents there are too abstract
18:33:29 <roboguy_> tongcx: have you tried catsters yet?
18:33:56 <tongcx> roboguy_: no
18:34:00 <tongcx> roboguy_: i will read it
18:34:03 <tongcx> roboguy_: thanks
18:34:07 <roboguy_> tongcx: they're videos actually
18:34:36 <roboguy_> tongcx: the first adjunction one is here https://www.youtube.com/watch?v=loOJxIOmShE
18:35:03 <tongcx> roboguy_: cool, i actually like videos better
18:35:13 <roboguy_> me too, ha
18:36:49 <pingu> Does anyone know this human? https://github.com/tekul
18:37:09 <johnw> arkeet: thanks for clarifying that
18:37:16 <pingu> Or if there are any other haskelleres from his/her assumed workplace "cloudfoundry"?
18:37:44 <pingu> A few of us are wanting to build an OpenID connect server in haskell.
18:38:13 <pingu> And I wonder if there's been any progress or if it looks like we're implementing this from scratch.
18:54:36 <ReinH> tongcx: and try Conceptual Mathematics by Lawvere as well
18:54:59 <SrPx> Hello, I want to compare the difference of 2 pixels using JuicyPixels. What is the most elegant way to do it? I've been thinking in: pixelToV4 :: Pixel a → V4 ... using Linear's vectors... and then just compute the distance between them.
18:55:36 <SrPx> I guess this approach might be good since I could use other functions from linear if I want to perform different things on pixels... but I'm not sure if pixelToV4 is the right way. 
18:58:56 * hackagebot iproute 1.3.2 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.3.2 (KazuYamamoto)
19:00:58 <benzrf> @ask denommus hey why are you on the FAQ for the WTFPL
19:00:58 <lambdabot> Consider it noted.
19:03:22 <_ryan> hi is there anyone can help me about yesod?
19:06:46 <erikd> _ryan: you should direct people over there ---> to the yesod channel, where you have already asked your question :-)
19:07:23 <_ryan> erikd: thank you but i think there no one there..
19:08:03 <_ryan> erikd: so i was hoping that ther should a person/yesoder master that can help me.. :) thank you again
19:08:35 <roboguy_> SrPx: What Pixel type are you using?
19:09:02 <roboguy_> SrPx: the Pixel types I've looked at so far all have Ord instances, so maybe you could just use that
19:09:35 <SrPx> how does Ord help...? roboguy_ I'm using juicypixel's PixelRGBA8
19:09:47 <roboguy_> SrPx: oh, I think I misread the problem
19:10:05 <SrPx> heh okay :)
19:11:04 <erikd> _ryan: we still do not know what your question is, because you haven't asked it. asking for help without any specifics is much less likely to get a response than a direct concise question.
19:13:27 <_ryan> erikd: thank you. i already ask the question.. :-)
19:17:08 <dropp> hey hey
19:22:06 <dropp> if i have a function, f = findIndex (==';'), how would i pass the Maybe output directly to splitAt ?
19:22:29 <dropp> not sure if i should use (<*>) or (<$>) and how to structure it
19:22:53 <erikd> :t (<$>)
19:22:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:23:10 <erikd> :t splitAt
19:23:11 <lambdabot> Int -> [a] -> ([a], [a])
19:23:51 <dmj`> dropp: how would you handle the maybe case?
19:23:57 <dmj`> er the 'Nothing' case
19:24:27 <dropp> i'm not sure. currently i am doing so with a case and i have it as 4 lines of code
19:24:45 <dropp> but i was hoping there was a more compact approach with applicatives/functors
19:24:53 <dmj`> :t splitAt 4 <$> Just "happybirthday"
19:24:54 <lambdabot> Maybe ([Char], [Char])
19:25:02 <exio4> dropp: what's the type of "findIndex"?
19:25:06 <exio4> @type findIndex
19:25:06 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
19:25:15 <exio4> oh, never heard of it :P
19:25:28 <dropp> exio4: its from Data.List
19:25:44 <exio4> dmj`: you can use fmap/<$>, splitAt n <$> findIndex (==';') xs 
19:26:09 <exio4> this will give you "Just result-of-split-at" or "Nothing"
19:26:21 <dropp> the n is what i was trying to get from the findIndex function though
19:26:50 <exio4> ah, yes, sorry (`splitAt` xs) :P 
19:27:02 <exio4> I'd use an explicit lambda there (\n -> splitAt n xs)
19:27:29 <dropp> exio4: why an explicit lam? self-documenting purposes?
19:27:57 <dropp> or just less code ?
19:28:42 <exio4> pretty much, I like it more for this case, it's even a bit more of code :P
19:28:50 <dropp> cool beans
19:29:16 <exio4> (tried to help before going to sleep, doesn't work that well)
19:29:53 <dropp> it's okay, it's moving me in the right direction
19:29:56 <dropp> i appreciate it
19:42:03 <dropp> how can i make this code better? https://gist.github.com/drippdropp/e4e90d6fdfb4d467297b
19:42:46 <adu_> dropp: write it in perl?
19:43:21 <dropp> it'll be a cold day in hell before that happens, buddy :-)
19:43:32 <HeladoDeBrownie> dropp, this is subjective, but the let isn't strictly necessary, you could replace semiIndex in the case expression with its value. you can also de-indent the cases so they're only an indent past splitBySemicolon.
19:44:14 <HeladoDeBrownie> in fact there are some other names there that aren't terribly descriptive, like clearSemi
19:44:47 <HeladoDeBrownie> oh and since you're using where anyway you can put a pair pattern on the left side of the = and that way you don't need fst
19:45:12 <dropp> oh, good point!
19:45:14 <HeladoDeBrownie> (fstNewxs, _) = … -- but with whatever name you want
19:45:26 <adu_> dropp: http://hackage.haskell.org/package/text-0.11.3.0/docs/Data-Text.html#v:splitOn
19:46:00 <dropp> adu_: this is mostly for education purposes, i'd likely use a package if i had a specific project in action
19:46:52 <timothyh> hm. I am trying to put an if-else block around the build-type field in a cabal file (for OS reasons)
19:47:17 <timothyh> but the if-else syntax doesn't work at the top level, or something? who would know about this kind of thing
19:47:18 <adu_> timothyh: conditional compilation?
19:48:17 <dropp> i find that i use ghci as a really really underworked calculator and often to work out ideas for other code, but when it comes to actually using haskell for actual projects, my comfort level with passing data around to solve actual problems is pretty minimal, so i'm trying to get better with some fundamentals
19:48:18 <timothyh> when build-type is set to Custom, an implicit dependency on 'cabal -any' appears, and I have an OS target that makes that invalid
19:48:59 <timothyh> so i basically want if (os(xen)) build-type Simple; else build-type Custom
19:50:41 <timothyh> "If-blocks are not allowed in between stanzas" joy
19:53:59 * hackagebot blunt 0.0.11 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.11 (fozworth)
19:55:21 <Rotaerk> wat
20:04:10 <lethjakman> so, would my research be correct in telling me that TDD isn't as big of a practice in haskell as it is in other languages because of the type checking? 
20:08:47 <Rotaerk> lethjakman, I'm not really sure about the culture around TDD in haskell, but there's:  https://wiki.haskell.org/Introduction_to_QuickCheck1
20:09:09 <Rotaerk> testing is still good, because haskell types don't check everything..
20:09:20 <lethjakman> that's my thinking...
20:09:27 <lethjakman> I feel like it's possible to still mess things up. 
20:09:28 <heatsink> Static checking eliminates some of the use cases for tests.
20:09:31 <lethjakman> I'm still really new though
20:09:39 <lethjakman> I can definitely see some of them being eliminated
20:09:44 <RustyShackleford> I'm trying to figure out Cabal. I'd like to have a build file, run tests, and etc
20:09:46 <lethjakman> there's no duck typing that cna go wrong. 
20:09:47 <heatsink> For example, we generally don't need tests to verify that a function doesn't segfault.
20:10:06 <RustyShackleford> could I get a link to something that will explain cabal, the project directory layout, etc?
20:11:00 <jmcarthur> lethjakman: i practice TDD, except it stands for Type Driven Development
20:11:16 <lethjakman> lol
20:11:20 <heatsink> RustyShackleford: https://www.haskell.org/cabal/users-guide/ is long and detailed
20:11:27 <lethjakman> jmcarthur: very funny...
20:11:37 <jmcarthur> lethjakman: and not a joke!
20:11:42 <lethjakman> no?
20:11:46 <lethjakman> do you still test?
20:12:03 <lethjakman> how do you make sure your function returns what you're expecting? 
20:12:06 <jmcarthur> i do, sure, but my tests don't drive my code the way my types do
20:12:21 <heatsink> RustyShackleford: that's not the most convenient source if you're trying to create a new project though
20:12:34 <lethjakman> maybe I'm not far enough to understand exactly how you mean that. 
20:12:37 <Rotaerk> testing is important, but I don't think test *driven* is
20:12:38 <jmcarthur> also, tests don't prove anything, while types do
20:12:56 <lethjakman> tests prove small isolated cases. 
20:13:00 <RustyShackleford> heatsink: yeah i'd like a guide or example or something
20:13:04 <shachaf> @quote kmc Ints
20:13:04 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
20:13:07 <lethjakman> types enforce. 
20:13:08 <arkeet> TDD = type driven development
20:13:21 <arkeet> oh someone already did that.
20:13:31 <lethjakman> is that a common question around these parts?
20:13:32 <jmcarthur> lethjakman: tests only prove that your function is correct in certain ways for certain inputs. types prove your functions is correct in certain ways for all inputs.
20:13:43 <jmcarthur> *function is
20:13:44 <shachaf> Sometimes we get students here asking questions the day before the final. That's a sort of test-driven development.
20:13:53 <lethjakman> lol
20:13:55 <heatsink> RustyShackleford: You can run 'cabal init' in a new directory to create a new empty project
20:13:57 <lethjakman> is this a common language in college?
20:14:00 <arkeet> shachaf: lol
20:14:50 <lethjakman> are there any good vim plugins I need for haskell?
20:14:56 <jmcarthur> lethjakman: i wouldn't say it's common, but there are definitely a lot of people who would never touch haskell if not for some course they are taking
20:15:11 <Owen> http://www.cs.utexas.edu/users/EWD/OtherDocs/To%20the%20Budget%20Council%20concerning%20Haskell.pdf
20:15:15 <heatsink> It seems like some people like to develop by writing examples and then programming to handle those examples.  That practice is not common in Haskell, as far as I've seen.
20:15:22 <lethjakman> yeah...I think there are a lot of people that would never touch anything but Java because that's what they learned in college
20:15:28 <lethjakman> polyglot programming is important
20:15:30 <heatsink> That is, people may still start with examples, but they'll generalize before writing code.
20:16:04 <jmcarthur> @check \xs -> xs == reverse (reverse xs :: String)
20:16:05 <lambdabot>  +++ OK, passed 100 tests.
20:16:10 <jmcarthur> tests!
20:16:27 <lethjakman> jmcarthur: what was that?
20:16:36 <jmcarthur> lethjakman: a little demonstration of QuickCheck
20:16:46 <lethjakman> would you mind explaining it?
20:16:49 <lethjakman> it looks cool
20:17:06 <jmcarthur> lethjakman: in this case, it generated 100 random strings and checked that the property held true for all of them
20:17:06 <lethjakman> I can live with less tests...it seems nice. 
20:17:37 <lethjakman> interesting
20:17:53 <jmcarthur> @check \a b c -> (a*b)*c == (a*(b*c) :: Int)  -- holds for ints
20:17:54 <lambdabot>  <hint>:1:85:
20:17:54 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
20:17:55 <lethjakman> would you want to test for edge cases as well?
20:18:11 <jmcarthur> not sure what i did wrong
20:18:16 <jmcarthur> @check \a b c -> (a*b)*c == (a*(b*c) :: Int) 
20:18:17 <lambdabot>  +++ OK, passed 100 tests.
20:18:19 <lethjakman> @check, I don't know what the @ does. 
20:18:19 <lambdabot>  <unknown>.hs: 1: 31:Parse error in expression: I don't know what the@does .
20:18:21 <jmcarthur> no comments allowed apparently
20:18:23 <lethjakman> oh
20:18:25 <lethjakman> lamdabot
20:18:25 <jmcarthur> @check \a b c -> (a*b)*c == (a*(b*c) :: Double) 
20:18:27 <lambdabot>  *** Failed! Falsifiable (after 10 tests and 1097 shrinks):
20:18:27 <lambdabot>  5.0e-324 1.8867671476829256e-2 26.500395785505237
20:18:28 <lethjakman> lambda
20:18:42 <lethjakman> is the \ for the bot as well?
20:18:53 <heatsink> The "@check" is a command, the rest is a Haskell expression
20:19:07 <jmcarthur> lethjakman: QuickCheck uses a type class for generating the inputs, so you can just code into the instance for whatever type a bias toward edge cases if you want
20:19:12 <jmcarthur> lethjakman: \ is just a lambda
20:19:21 <lethjakman> so the left is the input, and the right is...I'm not sure
20:19:27 <lethjakman> :: Double doesn't make sense to me
20:19:30 <lethjakman> oh
20:19:32 <lethjakman> thank you!
20:19:34 <lethjakman> that's fantastic to know
20:19:42 <jmcarthur> lethjakman: :: Double was just a type annotation
20:19:47 <kadoban> lethjakman: If there's edge cases that wouldn't commonly come up, but you can foresee, yeah you should probably test those specially. Usually quickcheck does pretty good though.
20:20:13 <jmcarthur> lethjakman: there's also SmallCheck, which exhaustively checks all inputs up to some size
20:20:38 <lethjakman> interesting
20:20:39 <jmcarthur> lethjakman: and LazySmallCheck which is like SmallCheck, but uses some tricks to try to completely prove the function.
20:20:49 <jmcarthur> lethjakman: only works under certain circumstances though
20:21:02 <jmcarthur> lethjakman: and there's SmartCheck which does something fancy i can never remember
20:21:09 <jmcarthur> it's the new kid on the block
20:21:24 <lethjakman> that sounds like a fancy kind of testing I heard of that clojure has...
20:21:27 <lethjakman> I can't remember the name
20:21:36 <kadoban> QuickCheck is the most commonly used I think, I don't see the rest used all that often.
20:22:09 <jmcarthur> lethjakman: oh i remember now. smartcheck tries to reduce the inputs to the most abstract form possible, to give you a very general picture of when your property fails
20:22:26 <jmcarthur> https://github.com/leepike/SmartCheck
20:22:56 <EvanR> dang cube root isnt a total function for doubles
20:23:02 <lethjakman> nifty
20:23:02 <EvanR> ignoring nan
20:23:27 <EvanR> is there a serious numeric type lying around
20:23:28 <jmcarthur> lethjakman: there are also various test drivers, HUnit for traditional unit tests, etc.
20:23:41 <lethjakman> jmcarthur: what do you use?
20:23:49 <heatsink> Where is cube root undefined?
20:24:00 <bananagram> never I think
20:24:01 <EvanR> cubeRoot = x**(1/3)
20:24:12 <arkeet> I think he was asking why it isn't total.
20:24:21 <heatsink> yes
20:24:23 <jmcarthur> lethjakman: mostly the type system, seriously. i use quickcheck often. i use smallcheck less often. i have never used smartcheck, but want to.
20:24:43 <lethjakman> do you code in other languages as well?
20:24:49 <arkeet> I guess I would expect x**(1/3) to not work for negative x.
20:24:54 <jmcarthur> my main other language is ocaml
20:25:02 <jmcarthur> i prefer haskell though
20:25:04 <arkeet> but you could just signum x * (abs x)**(1/3)
20:25:07 <lethjakman> do you code professionally? 
20:25:10 <jmcarthur> yup
20:25:20 <lethjakman> that's really cool. do you mind if I ask what you do?
20:25:31 <lethjakman> the reason I ask is I haven't heard of many haskell jobs. 
20:25:33 <EvanR> > signum (-8) * (abs (-8))**(1/3)
20:25:34 <lambdabot>  -2.0
20:25:43 <jmcarthur> https://www.janestreet.com/   (it's an ocaml job, not a haskell job)
20:25:43 <lethjakman> you don't have to be specific
20:25:45 <arkeet> although that's only valid for real numbers.
20:26:16 <lethjakman> ahhh, that makes sense. 
20:26:32 <lethjakman> I've heard good things about ocaml too
20:29:30 <heatsink> I see.
20:34:22 <pavonia> When you have a data declaration like "data BinTree a = Empty | Branch (BinTree a) a (BinTree a)", how do you transform an empty tree into a zipper? Does that even make sense? Because there's no value associated with an empty tree
20:35:35 <arkeet> there is no zipper for that.
20:37:35 <pavonia> So a function Tree a -> Zipper a is undefined if the tree is empty?
20:39:49 <arkeet> what exactly is Zipper?
20:41:09 <arkeet> if you have a Branch you have the opposite problem, because generally there are many choices of holes.
20:41:11 <pavonia> These are my definitions so far: http://lpaste.net/4724189508470308864
20:41:51 <pavonia> I'm working on the exercises here http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
20:42:06 <arkeet> the way you've defined it, there is no function Tree a -> Zipper a.
20:43:02 <pavonia> But that's the definition given in that article
20:43:23 <arkeet> I don't see any definition of Zipper for trees.
20:43:25 <jle`> does the article say that there is a Tree a -> Zipper a ?
20:43:36 <jle`> not every type has a zipper
20:43:53 <jle`> consider data Void
20:44:02 <carter> jle`: nah, the zipper for that is void
20:44:23 <arkeet> d(0) = 0 indeed
20:44:23 <carter> derivative of any constant is void
20:44:27 <jle`> oh yeah
20:44:28 <pavonia> arkeet: It's given in mathematical notation right above the tree picture
20:44:35 <jle`> what am i thinking....
20:44:42 <arkeet> pavonia: no, that's a context.
20:44:51 <jle`> ty
20:45:19 <pavonia> arkeet: Yes, but is says "Code up the zipper for binary trees, remembering that a zipper is a one-hole context paired with data."
20:45:46 <arkeet> yes.
20:45:46 <pavonia> Is my Zipper definition wrong then?
20:45:52 <arkeet> it doesn't say you can write a Tree a -> Zipper a
20:46:08 <arkeet> (the reverse direction is possible.)
20:46:36 <pavonia> But how do I write left, right and up if I can't convert my tree into a zipper?
20:47:04 <pavonia> I mean I can write them, but won't be able to use them
20:47:54 <arkeet> there are exactly as many ways to convert a tree to a zipper as there are elements in the tree.
20:48:04 <arkeet> that number may be 0, or it may be very large, or ...
20:48:16 <arkeet> you are probably supposed to write some Zipper a -> Tree a instead.
20:49:00 <arkeet> it's not very clear.
20:49:30 <pavonia> Okay, there's no zipper for an empty tree but exactly one zipper for "Branch Empty someValue Empty"?
20:49:38 <arkeet> yes.
20:49:44 <arkeet> and that is the only tree for which there is exactly one.
20:49:58 <pavonia> I see
20:50:47 <pavonia> So I could write such a function for non-empty tree pointing to the root element
20:51:00 <arkeet> yes, but that will only give you one of in general many possible zippers.
20:51:07 <arkeet> because there's one for each node in the tree.
20:52:14 <pavonia> Well, for playing around with some examples that one should be fine
20:52:27 <pavonia> Thanks!
20:52:51 <arkeet> I think it would be a good idea to write Zipper a -> Tree a, though.
20:53:13 <pavonia> Yes, I need that one too
20:53:22 <arkeet> what you could perhaps do is write some
20:53:34 <arkeet> Tree a -> [Bool] -> Zipper a
20:53:40 <arkeet> where the list is the path down from the root of the tree.
20:54:06 <arkeet> it won't be defined when the given path down the tree exists, though.
20:54:16 <arkeet> in particular, there are no paths in the empty tree.
20:55:11 <pavonia> Good idea
20:55:20 <arkeet> er sorry
20:55:26 <arkeet> it won't be defined when the given path down the tree *doesn't* exist, though.
21:01:45 <arkeet> I am slightly disappointed that this article does not mention free monads. http://chris-taylor.github.io/blog/2013/03/02/readers-and-binary-trees/
21:01:51 <arkeet> for Tree r = Free ((->) r)
21:13:05 <L8D> Is there a lens operator for updating a lens by running a monadic action over it?
21:13:41 <jle`> L8D: can you say what you mean in types?
21:13:50 <L8D> I'm not sure
21:14:01 <L8D> I'm looking for something like (<<~)
21:14:03 <jle`> what would you do with a Lens s t a b or Lens' s a ?
21:14:27 <L8D> MonadState s m => ALens s s a b -> (a -> m b) -> m b
21:14:37 <L8D> ^ is what I'm looking for
21:15:20 <jle`> hm. where are you getting the `a` from?
21:15:29 <jle`> oh, MonadState
21:16:20 <arkeet> :t mapMOf
21:16:21 <lambdabot> Profunctor p => Over p (WrappedMonad m) s t a b -> p a (m b) -> s -> m t
21:16:39 <L8D> is there mapMOf in operator form?
21:17:14 <arkeet> I'm not sure if this helps you do what you want, given the state stuff.
21:17:19 <arkeet> but mapMOf = traverseOf = id
21:17:41 <L8D> what
21:17:49 <EvanR> raw haw haw
21:18:02 <arkeet> (%%~) is the operator for traverseOf, but again it's id.
21:18:42 <L8D> I see
21:18:46 <lethjakman> are there any differences between a function declared as func :: stuff vs func xs = stuff ?
21:18:51 <L8D> %%= seems to be what I'm looking for
21:18:57 <lethjakman> not sure how to word that for google.
21:18:57 <arkeet> lethjakman: the monomorphism restriction
21:19:02 <arkeet> er
21:19:08 <arkeet> I may have misread.
21:19:21 <lethjakman> defining a function with :: vs =
21:19:29 <lethjakman> if I understand right = is higher order?
21:19:29 <arkeet> oh, those are entirely different things.
21:19:31 <jle`> you can only declare a function with =
21:19:33 <arkeet> :: gives you a type annotation.
21:19:36 <jle`> :: gives a type signature
21:19:38 <jle`> yeah
21:19:39 <arkeet> it only tells the type of the function.
21:19:41 <lethjakman> ohhh
21:19:43 <lethjakman> right
21:19:49 <lethjakman> gah, this syntax is gonna take me a second
21:19:51 <lethjakman> thank you
21:20:01 <arkeet> never mind what I said earlier about the monomorphism restriction.
21:20:06 <EvanR> :: is "has the type"
21:20:12 <lethjakman> should I look those up anyways?
21:20:18 <arkeet> eventually.
21:20:21 <arkeet> don't worry about it now.
21:20:32 <lethjakman> thanks :)'
21:20:48 <L8D> :t id %%= (\x -> Nothing >> pure x)
21:20:49 <lambdabot>     Couldn't match type ‘Maybe b0’ with ‘(r, b0)’
21:20:50 <lambdabot>     Expected type: b0 -> Maybe b0
21:20:50 <lambdabot>       Actual type: b0 -> (r, b0)
21:22:10 <L8D> :t id <<%= (\x -> Nothing >> pure x)
21:22:11 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ Maybe b
21:22:11 <lambdabot>     Expected type: b -> Maybe b
21:22:11 <lambdabot>       Actual type: b -> b
21:22:23 <pavonia> For the last exercise here http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/ is the correct context ([Rose a], [(a, [Rose a], [Rose a])])?
21:22:39 <L8D> :t (<<%=) 
21:22:40 <lambdabot> (Data.Profunctor.Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
21:23:34 <lethjakman> I really like list comprehensions, I wish ruby had them in a similar syntax. 
21:23:50 <EvanR> i wish ruby had a lot of things
21:23:55 <jle`> python has a variation :)
21:24:00 <lethjakman> does it?
21:24:02 <lethjakman> that's cool
21:24:04 <jle`> yes
21:24:08 <arkeet> python has list comprehensions yes
21:24:09 <jle`> well, idiomatic ruby is just to use maps and filters
21:24:20 <jle`> and in most situations in haskell, maps and filters are preferred over list comprehensions
21:24:33 <lethjakman> why's that?
21:24:37 <jle`> s/most/many
21:24:42 <jle`> it's just a little more expressive
21:24:48 <arkeet> list comprehensions don't compose that well.
21:24:55 <jle`> map (*2) xs  vs. [ x*2 | x <- xs ]
21:25:09 <lethjakman> fair
21:25:14 <jle`> filter even xs vs. [ x | x <- xs, even x ]
21:25:19 <arkeet> map (*2) vs. \xs -> [x*2 | x <- xs]
21:26:37 <pavonia> At least it makes sense if the frst list is the list of sub-trees of the focus and the other lists holds the path with each parent's value and the siblings before and after the focus
21:34:13 <pavonia> Unfortunately, there doesn't seem to be the promised fourth part of that article series
21:34:38 <dmj`> > [ 3 | True ]
21:34:40 <lambdabot>  [3]
21:35:45 <dmj`> > [3|True,False,True]
21:35:47 <lambdabot>  []
21:35:51 <johnw> dmj`: I think you've seen me use that trick before
21:36:10 <dmj`> johnw: indeed :) 
21:36:20 <johnw> with monad comprehensions, the same syntax will work for any monad... :)
21:36:34 <arkeet> nah, only for MonadPlus.
21:36:45 <johnw> ah, right
21:37:20 <monochrom> before monad comprehension got implemented, I used do-notation for [].
21:37:56 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
21:37:59 <arkeet> > do { guard True; 3 }
21:38:00 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
21:38:00 <lambdabot>    arising from a use of ‘M632445271319426401123122.show_M6324452713194264011...
21:38:00 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
21:38:03 <arkeet> > do { guard True; 3 } :: [Int]
21:38:04 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
21:38:04 <lambdabot>    arising from the literal ‘3’
21:38:06 <jle`> retourn
21:38:08 <arkeet> oh duh.
21:38:11 <arkeet> > do { guard True; return 3 } :: [Int]
21:38:13 <lambdabot>  [3]
21:38:13 <arkeet> > do { guard True; return 3 } :: Maybe Int
21:38:15 <lambdabot>  Just 3
21:38:18 <jle`> list comprehensions have the implicit return which is nice
21:38:25 <KaneTW> :t guard
21:38:26 <lambdabot> MonadPlus m => Bool -> m ()
21:38:32 <arkeet> > 3 <$ guard True
21:38:33 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
21:38:33 <lambdabot>    arising from a use of ‘M841136019024057047723180.show_M8411360190240570477...
21:38:33 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
21:38:39 <arkeet> I'll stop.
21:38:51 <monochrom> it is not nice because it has unnatural order
21:39:00 <jle`> i use `3 <$ guard thing` often
21:39:14 <arkeet> > 3 <$ guard True :: Maybe Int
21:39:16 <lambdabot>  Just 3
21:39:33 <monochrom> I'll let you in on a secret. whenever I write list comprehension, I have to write the part after | first, in left-to-right order.
21:39:50 <monochrom> only until I finish that, can I know what to write before |
21:40:25 <jle`> if i have a lot of things after the | i usually just use do notation
21:40:26 <monochrom> I don't care that "return" is longer. it's only 6 letters. do-notation is the correct order of writing.
21:40:48 <jle`> if there is only one line i usually list comprehend
21:41:14 <jle`> > [ x | Right x <- [Left True, Right 10, Left False, Right 3] ]
21:41:15 <lambdabot>  [10,3]
21:41:36 <arkeet> > [Left True, Right 10, Left False, Right 3] ^.. _Right
21:41:37 <lambdabot>  Couldn't match type ‘[Data.Either.Either GHC.Types.Bool b0]’
21:41:38 <lambdabot>                with ‘Data.Either.Either c0 b’
21:41:40 <lambdabot>  Expected type: Control.Lens.Getter.Getting
21:41:47 <arkeet> hmm.
21:41:53 <arkeet> > [Left True, Right 10, Left False, Right 3] ^.. traverse . _Right
21:41:55 <lambdabot>  [10,3]
21:41:55 <jle`> anything more complex than one binding/condition i'll drop to do notation
21:42:27 <monochrom> a similar reason for why I don't like eager functional languages such as SML.
21:42:54 <jle`> strict languages are so weird :|
21:42:58 <monochrom> it is not even that I reject side effects. let's say I embrace side effects for the next few minutes.
21:43:25 <jle`> wait, eagerness doesn't imply side effects
21:43:38 <jle`> it opens the door to them
21:43:50 <monochrom> in "f (g x) (h y)", the order of the side effects is neither <f then g then h> nor <h then g then f>
21:44:28 <monochrom> instead, it is "go to the 2nd subexpression for g, then h, now go back to the beginning for f"
21:45:09 <arkeet> it's just a depth-first traversal of a tree.
21:45:31 <dmj`> pre-order
21:45:36 <arkeet> sure.
21:46:42 <monochrom> those are after-the-fact rationalizations, not design principles.
21:47:16 <monochrom> I am sure you can rationalize any order by inventing a contrived new order
21:49:41 <arkeet> I'm not suggesting it's good.
21:59:04 * hackagebot logfloat 0.13.2 - Log-domain floating point numbers  http://hackage.haskell.org/package/logfloat-0.13.2 (WrenThornton)
22:39:06 * hackagebot http-conduit-browser 2.0.0.0 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-2.0.0.0 (MikhailKuddah)
23:13:16 <haskell370> Hello
23:13:58 <jle`> hello haskell370 !
23:16:34 <haskell370> jle` thanks sorry I am not sure of the etiquette here - is this somewhere I can ask beginner Haskell questions?
23:16:41 <jle`> mhm
23:16:42 <glguy> Yes
23:17:51 <sgronblo> yes, but there is also #haskell-beginners
23:18:08 <shachaf> There is, but it's unrelated to this channel.
23:18:08 <sgronblo> but its not like people get angry if you write beginner questions here
23:18:14 <shachaf> Beginners are welcome in #haskell.
23:18:16 <jle`> s/but/and :)
23:18:54 <jle`> beginner questions are very very on-topic and expected and well-received
23:20:37 <haskell370> thanks all you sound like kind people. I am going to work though the online tutorials, and if I get stuck and cannot find the answer online, I will be back.
23:20:54 <TRManderson> Is there a function that will partition a list, returning a list of length-n sublists of the original list?
23:21:02 <TRManderson> i.e. Int -> [a] -> [[a]]
23:21:16 <glguy> Split package has chunksOf
23:22:36 <TRManderson> so "import Split (chunksOf)" ?
23:23:29 <glguy> The module is Data.List.Split
23:23:42 <glguy> ?hackage split
23:23:42 <lambdabot> http://hackage.haskell.org/package/split
23:23:43 <KaneTW> f n = filter ((==n) . length) . subsequences
23:23:56 <TRManderson> Thanks
23:28:36 <sgronblo> TRManderson: note that chunksOf starts chunking from the left so the last chunk might be smaller than the others
23:29:17 <rreno17> On a 64 bit system, can I expect arithmetic to be accurate to about 16 quintillion digits? I ask because I'm playing around and I created a function that takes three arguments a b c and raises them to a^b^c. I input 2 6 8 and got quite a few digits. Just curious to know if they are accurate and if the number of digits of accuracy has anything to do with the amount of memory a 64 bit processor can address.
23:30:20 <Axman6> why not use Integer which is arbitrary precision?
23:30:28 <peddie> rreno17: if you're using Int, it should be 64 bits; if you use Integer, it will handle any number of digits (within your computer's ability to compute them and print them out, if that's what you're doing)
23:30:35 <Axman6> > product [1..100] :: Integer
23:30:36 <shachaf> Integer is supposed to represent arbitrary-size integers.
23:30:36 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
23:30:52 <rreno17> well that's awesome
23:31:02 <shachaf> Which means however much will fit in memory (but in practice I think there are smaller limits).
23:31:35 <rreno17> when I query the type I get num and integral. Int and integer are...subtypes of num? (I'm still working through Learn You A Haskell)
23:32:08 <shachaf> They are both instances of the type class Num.
23:32:14 <shachaf> Haskell has no subtyping.
23:32:33 <peddie> if you do :i Integer or :i Int, you'll see that they're both instances of Num and Integral
23:32:50 <shachaf> Num isn't a type at all (not types in the sense that you can't have a value of type Num).
23:33:43 <rreno17> well that's interesting. I'm going to reread the types chapter to make sure I nail this stuff down. Thanks!
23:33:46 <shachaf> I switched plurality in the middle there.
23:42:19 <aupiff> Hi all, I'm going through the Pierce Software Foundations book now, and I have a conceptual question about the correctness of theorem provers. How can we be sure the theorem-prover is itself correct?
23:47:38 <Freundlich> aupiff: You write a theorem prover to prove that the theorem prover is correct. Oh, wait... - That's a fundamental issue in mathematics.
23:48:31 <TRManderson> :t sequence
23:48:32 <lambdabot> Monad m => [m a] -> m [a]
23:48:32 <aupiff> Freundlich: ok, I was just checking that that was the case.
23:52:17 <Cale> aupiff: We can't really be sure, but we can reduce the problem of its correctness to the correctness of a very small kernel program (which is of the size that you could be reasonably convinced of its correctness without too much work), and build everything else out around that.
23:53:55 <Cale> aupiff: Of course, there's also the problem of defining what it means for the thing to *be* correct.
23:54:08 * hackagebot mono-traversable 0.9.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.1 (MichaelSnoyman)
23:54:10 * hackagebot enclosed-exceptions 1.0.1.1 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.1.1 (MichaelSnoyman)
23:55:32 <RustyShackleford> how do you override an operater properly?
23:55:44 <Cale> RustyShackleford: Which operator?
23:56:07 <RustyShackleford> can i override & and |?
23:56:19 <Cale> | is syntax
23:56:27 <Cale> You can't use it as an infix operator
23:56:42 <Cale> & isn't defined in the Prelude, so you can just define it however you like
23:57:11 <Cale> However, it is defined in some libraries, so if you're importing one of those which defines it, you may have to import Foo hiding ((&))
23:57:31 <aupiff> Cale: that makes sense. I'm interested to see how small the coq, agda and idris kernels are.
23:57:40 <Cale> > let x & y = x^2 + y^2 in 4 & 8
23:57:41 <lambdabot>  80
23:58:42 <Cale> (You can also redefine stuff that's in the Prelude, but it's usually kind of an annoying thing to do to your users, since they'll have to import Prelude hiding a bunch of stuff)
23:59:08 * hackagebot yesod-auth 1.4.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.4 (MichaelSnoyman)
23:59:28 <RustyShackleford> so maybe i'll just avoid it
