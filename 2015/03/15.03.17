00:01:26 <funfunctor> I need some serious help with how one gets a string parsed with parsec where the first part of the string is a command specified by a type data MyCommand = Command1 | Command2 | ..
00:01:30 <erikd> Axman6: back!
00:01:48 <funfunctor> how does that even work?
00:02:33 <erikd> funfunctor: if the string is just generated by a Show instance, you should probably just use a Read instance to parse it.
00:02:59 <funfunctor> erikd: well I know that much but that wont work for me
00:03:05 <funfunctor> let me paste some code..
00:04:02 <erikd> > read (show (Just 12)) :: Maybe Int
00:04:03 <lambdabot>  Just 12
00:04:24 <lpaste> funfunctor pasted “No title” at http://lpaste.net/126966
00:04:41 <funfunctor> erikd: relevant parts pasted
00:05:32 <funfunctor> erikd: the shape of things should be of the form   command value1 value2 ..
00:06:46 <erikd> funfunctor: so what are you parsing?
00:07:20 <funfunctor> erikd: basically I am making something like a REPL behind a UDP socket that calls functions on commands with arguments
00:07:26 <funfunctor> usually floats
00:07:31 <funfunctor> not that it matters
00:07:51 <funfunctor> so on the UDP socket we would see things like
00:07:51 <funfunctor> SetRxGain 0.01
00:08:02 <funfunctor> or
00:08:05 <funfunctor> PowerOn
00:10:21 * hackagebot llvm-pretty 0.3.1.0 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.3.1.0 (TrevorElliott)
00:10:21 * hackagebot xml-extractors 0.4.0.0 - Wrapper over xml to extract data from parsed xml  http://hackage.haskell.org/package/xml-extractors-0.4.0.0 (holmisen)
00:12:01 <funfunctor> erikd: does that make sense?
00:13:38 <funfunctor> erikd: I guess a big head start would be, how to obtain parseCmd :: Parser ARFCNCommandRequest
00:13:49 <erikd> funfunctor: sorry, distracted by something else
00:14:19 <erikd> funfunctor: yes, that's pretty easy
00:14:21 <funfunctor> preferably without needing to write out the entire data structure again in string form
00:14:34 <funfunctor> ok?
00:14:36 <erikd> funfunctor: ah, that makes is difficult :-)
00:15:10 <funfunctor> :t max
00:15:11 <lambdabot> Ord a => a -> a -> a
00:15:24 <erikd> you and either have the compiler do everything with Read/Show instances of be prepared for some boilerplate
00:15:34 <funfunctor> can [min..max] be used or something?
00:16:00 <erikd> funfunctor: only if you're willing to dip into template-haskell
00:16:10 <funfunctor> well I am using read at the moment as you can see in a really shitty way
00:16:29 <quchen2> > [minBound ..] :: [Ordering] -- funfunctor 
00:16:30 <lambdabot>  [LT,EQ,GT]
00:17:05 <funfunctor> quchen2: ta! yea something like this..
00:18:00 <erikd> sorry, gotta go
00:20:47 <funfunctor> quchen2: so how do I get that to range over ARFCNCommandRequest to give me an enumerated list of commands?
00:21:17 <funfunctor> f :: [String]
00:23:37 <Heather> bump process please : https://github.com/haskell/process/issues/27
00:25:03 <bitemyapp> hvr: https://github.com/haskell/process/issues/27
00:27:11 <Heather> bitemyapp hey!
00:31:20 <Heather> bitemyapp can I specify /= (not equal) dep in cabal file
00:33:07 <bergmark> Heather: < x || > x
00:34:59 <Heather> bernalex ye, I used it
00:37:04 <quchen2> funfunctor: You'll have to write enumFrom yourself if you have a new type
00:38:17 <funfunctor> quchen2: well I mean, see this example http://lpaste.net/126967 how can you write the parse so you are not essentially just rewriting the type in string form?
00:38:55 <Heather> conduit-extra-1.1.7.1-fb0f6cbc12798df2950bd8d9407709dd is unusable due to missing or recursive dependencies
00:39:20 <Heather> I really want package manager for haskell on windows
00:40:09 <quchen2> funfunctor: Maybe something like this, http://lpaste.net/126968
00:40:15 * hackagebot sbv 4.2 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-4.2 (LeventErkok)
00:40:44 <quchen2> where asum [a,b,c] = a <|> b <|> c <|> empty
00:41:51 <funfunctor> quchen2: ok thats pretty helpful however where did the data type go
00:42:02 <funfunctor> hard coded as a list in the function
00:42:09 <funfunctor> well action technically
00:43:23 <quchen2> You'll still have to define the data type somewhere of course.
00:44:13 <funfunctor> quchen2: I mean you hard coded the data type as a list so it didn't really solve the problem
00:44:29 <orion> Hi. Is there a standard function which will take something like this: [("a", "1"), ("b", "2"), ...] and return "a=1b=2..." ?
00:45:15 * hackagebot llvm-pretty 0.3.1.1 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.3.1.1 (TrevorElliott)
00:45:19 <Axman6> that seems like a very specialised function. it can be easily made from generic parts though
00:46:17 <quchen2> orion: concatMap does that
00:46:24 <Axman6> > foldr (\(k,v) xs -> k++"="++v++xs) "" [("a", "1"), ("b", "2")]
00:46:25 <lambdabot>  "a=1b=2"
00:46:46 <indiagreen> or you could use concatMap
00:46:55 <Axman6> uh, yes
00:47:08 <funfunctor> quchen2: I guess what I need is a way (function) that takes data Source = Internet | Friend | NoAnswer deriving ... and gives me ["Internet", "Friend", "NoAnswer"]
00:47:14 <indiagreen> > concatMap (\(k,v) -> k ++ "=" ++ v) [("a", "1"), ("b", "2")]
00:47:15 <lambdabot>  "a=1b=2"
00:47:57 <funfunctor> some kind of mixture between show and max min?
00:48:32 <Axman6> funfunctor: look at the Bounded class
00:48:47 <Axman6> > [minBound .. maxBound :: Word8]
00:48:48 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:48:52 <funfunctor> Axman6: yea I looked but I didn't know how to use it on the type
00:48:55 <funfunctor> ah
00:48:55 <Axman6> > [minBound .. maxBound :: Char]
00:48:57 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
00:49:15 <funfunctor> putting the signature inside the [] notation I missed
00:50:16 <Axman6> well, it doesn't have to go there, as long as the compiler can figure out which min/maxBound you mean (which is probably going to mean you do need to write the signature if you're immediately going to use map show over the list
00:50:31 <quchen2> funfunctor: There's no simple generic way to do that. Data.Data might be worth a look if you *really* want it.
00:51:49 <Axman6> seems overkill when asum . map (string . show) $ [minBound .. maxBound :: ARFCNCommandRequest] is all you need
00:52:10 <Axman6> (assuming string:: String -> Parser String)
00:52:35 <Axman6> you can do more interesting things like have it return the original value too:
00:53:08 <Axman6> asum . map (\v -> string (show v) *> pure v) $ [minBound .. maxBound :: ARFCNCommandRequest]
00:53:21 * Axman6 -> home
01:11:25 <lpaste> funfunctor pasted “No title” at http://lpaste.net/126969
01:15:42 <funfunctor> Axman6: I have the issue of Expected type: Data.ByteString.Internal.ByteString Actual type: String
01:16:08 <funfunctor> :t string
01:16:09 <lambdabot>     Not in scope: ‘string’
01:16:09 <lambdabot>     Perhaps you meant one of these:
01:16:09 <lambdabot>       ‘storing’ (imported from Control.Lens),
01:17:42 <HEGX64> :t String
01:17:43 <lambdabot> Not in scope: data constructor ‘String’
01:18:24 <funfunctor> :k String
01:18:25 <lambdabot> *
01:18:29 <arkeet> maybe you shouldn't use Data.Attoparsec.Char8
01:18:43 <funfunctor> arkeet: yea I know, I just realised that
01:18:48 <funfunctor> but any way string :: ByteString -> Parser ByteString
01:19:01 <arkeet> but show x :: String
01:19:07 <funfunctor> exactly
01:19:24 <funfunctor> how can I write this for Parsec instead maybe?
01:19:39 <funfunctor> attoparsec is really for parsing binary data
01:20:15 <quchen2> attoparsec is also for parsing text.
01:20:45 <funfunctor> ok well the API is easier for my incredibly small brain to get around
01:21:05 <funfunctor> but how do I solve my type issue here?
01:21:07 <arkeet> you could use Data.ByteString.Char8.pack :: String -> ByteString
01:21:42 <gfixler> I've been using ADTs for awhile now, but I still always feel like I fumble my way into them
01:21:43 <arkeet> also, no need to redefine asum
01:21:54 <breadmonster> Can anyone help me with a cabal error?
01:21:56 <rola> Data.ByteString.Carrot!
01:22:02 <arkeet> @where justask -- breadmonster 
01:22:02 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
01:22:10 <funfunctor> arkeet: I didn't know asum was already a thing?
01:22:11 <breadmonster> hse is refusing to install because it can't find happy.
01:22:13 <gfixler> are there things to keep in mind about ADTs, like "they're useful in 3 main situations... etc"?
01:22:20 <breadmonster> Though I just installed happy 1.19.5
01:22:22 <arkeet> they're useful everywhere.
01:22:26 <gfixler> I haven't noticed the pattern on my own yet
01:22:34 <rola> is happy in your path?
01:22:36 <funfunctor> @hoogle asum
01:22:38 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
01:22:44 <breadmonster> rola: How do I check?
01:22:47 <arkeet> oh maybe it's from Data.Foldable.
01:23:16 <rola> if you are on *nix-like: which happy
01:23:52 <arkeet> breadmonster: if you installed happy with cabal, it would be in .cabal/bin/
01:24:04 <arkeet> ~/.cabal/bin/
01:24:10 <arkeet> so you should add that to your PATH.
01:24:33 <breadmonster> Yup, there's happy there, along with alex and shake and cpphs
01:25:19 <funfunctor> @hoogle ByteString -> String
01:25:19 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
01:25:19 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
01:25:19 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
01:25:30 <HEGX64> if I have a data type like `data T = T {a::Int, b::Int, c::Int, d::Int}`. Given an instance of T what is the best way to change a single field
01:25:51 <funfunctor> @hoogle String -> ByteString
01:25:52 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:25:52 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:25:52 <lambdabot> Prelude error :: [Char] -> a
01:26:02 <arkeet> HEGX64: you could use record syntax
01:26:15 <arkeet> @let data T = T { aa :: Int, bb :: Int } deriving Show
01:26:16 <lambdabot>  .L.hs:165:1:
01:26:16 <lambdabot>      Multiple declarations of ‘T’
01:26:16 <lambdabot>      Declared at: .L.hs:153:1
01:26:18 <arkeet> hm.
01:26:22 <arkeet> @let data TT = TT { aa :: Int, bb :: Int } deriving Show
01:26:24 <lambdabot>  Defined.
01:26:30 <arkeet> > TT 1 2
01:26:31 <lambdabot>  TT {aa = 1, bb = 2}
01:26:36 <arkeet> > let x = TT 1 2 in x{aa = 5}
01:26:38 <lambdabot>  TT {aa = 5, bb = 2}
01:26:51 <breadmonster> arkeet: That worked!
01:26:55 <arkeet> breadmonster: :)
01:26:56 <breadmonster> Thanks a ton (:
01:27:07 <arkeet> HEGX64: this works, but it's not the prettiest
01:27:26 <arkeet> you could try exploring lenses for something prettier ;)
01:27:40 <grohne> there is the "ShowS" trick that turns String into String -> String to speed up concatenation. is there any reason to apply the same idea to a size function and have "sizes :: a -> Int -> Int" instead of "size :: a -> Int"? 
01:28:09 <arkeet> grohne: no, since Int addition performance does not depend on the size of the arguments.
01:28:46 <grohne> arkeet: thanks for confirming. I was seriosly wondering why this codebase is doing that and why sizes ends up being a cost center.
01:28:59 <arkeet> perhaps you need more strictness?
01:29:06 <arkeet> I dunno.
01:29:44 <grohne> I do need strictness, but I think also want to replace sizes by the simpler size.
01:30:02 <arkeet> oh yeah, sure.
01:30:48 <HEGX64> arkeet: Thanks you've saved me from my uglier solution
01:31:26 <grohne> arkeet: this codebase makes fixing space leaks easy (i.e. it has very many opportunities ;)
01:31:33 <arkeet> hehe
01:33:11 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/126969
01:33:34 <funfunctor> arkeet: ok pretty dam close now, how to make this work on String's rather than ByteStrings
01:33:59 <funfunctor> another pack needs to be put somewhere there?
01:34:05 <arkeet> well, attoparsec is for parsing ByteStrings.
01:35:08 <indiagreen> funfunctor: you can pack/unpack Text (attoparsec can parse Text too), or you can switch to parsec
01:35:28 <arkeet> or Text.
01:36:12 <arkeet> instead of x >> return, consider void x
01:36:14 <arkeet> :t void
01:36:15 <lambdabot> Functor f => f a -> f ()
01:36:37 <arkeet> wait.
01:36:40 <arkeet> :t ?f >> return
01:36:41 <lambdabot> (?f::a1 -> a, Monad m) => a1 -> m a1
01:36:53 <arkeet> oh.
01:37:21 <arkeet> my mind made up a () there for some reason.
01:37:50 <funfunctor> arkeet: far more action going on in your mind than mine
01:38:04 <funfunctor> my mind is pure, just gets hot
01:38:40 <funfunctor> Alright, so I have somewhat of a solution now
01:39:18 <arkeet> well now that's just silly then.
01:39:22 <arkeet> because x >> return = return
01:39:23 <arkeet> :p
01:39:49 <arkeet> so I think that's not what you want.
01:40:15 * hackagebot http-client 0.4.9 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.9 (MichaelSnoyman)
01:40:19 <quchen2> arkeet: void x = x >> return (). x >> return gets you a special case of a monad, namely (r ->).
01:40:26 <arkeet> yes I noticed that already.
01:41:00 <quchen2> But x >> return isn't return.
01:41:05 <arkeet> sure it is.
01:41:21 <arkeet> for that special case of a monad, f >> g = g.
01:41:51 <arkeet> > (f >> g) x
01:41:52 <lambdabot>  Ambiguous occurrence ‘f’
01:41:52 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:155:9
01:41:52 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
01:41:57 <arkeet> @undefine
01:41:57 <lambdabot> Undefined.
01:41:57 <arkeet> > (f >> g) x
01:41:58 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr a0)
01:41:58 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
01:41:58 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr b)
01:42:01 <arkeet> aw.
01:42:12 <quchen2> > (f >> g) x :: Expr
01:42:13 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:42:13 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
01:42:13 <lambdabot>  The type variable ‘a0’ is ambiguous
01:42:17 <quchen2> Dammit.
01:42:27 <arkeet> > (f >> (g :: Expr -> Expr)) x
01:42:28 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
01:42:28 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
01:42:28 <lambdabot>  The type variable ‘a0’ is ambiguous
01:42:33 <arkeet> > ((f :: Expr -> Expr) >> (g :: Expr -> Expr)) x
01:42:34 <lambdabot>  g x
01:42:36 <arkeet> :)
01:42:58 <arkeet> > ((f :: Expr -> Expr) >>= (g :: Expr -> Expr -> Expr)) x
01:42:59 <lambdabot>  g (f x) x
01:44:05 <funfunctor> arkeet: if I comment out the >> return part it wont type check
01:44:18 <quchen2> Oh, I misunderstood your >> statement to hold in general. Sorry.
01:44:55 <arkeet> funfunctor: well it won't do what you want it to do.
01:45:00 <arkeet> whatever it is that you want it to do.
01:45:28 <funfunctor> arkeet: /seems/ to work
01:45:40 <funfunctor> can you explain
01:45:49 <funfunctor> :t (>>)
01:45:49 <lambdabot> Monad m => m a -> m b -> m b
01:46:04 <arkeet> the m in that code is not the m you probably expected.
01:46:20 <arkeet> it is in fact the (ARFCNCommandRequest ->) monad.
01:46:30 <arkeet> for which f >> g = g.
01:47:13 <funfunctor> arkeet: ok and what is it that I am "fixing" here?
01:47:18 <arkeet> who knows.
01:47:39 <arkeet> I'm just telling you what your code is doing.
01:49:46 <funfunctor> hmm I thought this was working..
01:51:17 <arkeet> I probably ought to be in bed.
01:51:41 <funfunctor> arkeet: what about touch x = (string . pack . show) x >> return x
01:52:04 <funfunctor> I think I messed it up when I went around eta-reducing
01:52:41 <funfunctor> not sure how I can write that better?
01:53:17 <arkeet> I guess that would do something.
01:53:24 <arkeet> I'd use *> and pure instead of >> and return, though.
01:53:36 <arkeet> or even uh.
01:53:47 <arkeet> x <$ (string . pack . show) x
01:53:58 <arkeet> :t (<$)
01:53:59 <lambdabot> Functor f => a -> f b -> f a
01:58:56 <funfunctor> great! my parser works
02:00:28 <funfunctor> @hoogle (<$)
02:00:29 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
02:00:29 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
02:00:29 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
02:05:16 * hackagebot comonad 4.2.5 - Comonads  http://hackage.haskell.org/package/comonad-4.2.5 (EdwardKmett)
02:27:13 <Neu3> 1488 people on channel o/
02:27:25 <Neu3> nooo
02:45:16 * hackagebot derive 2.5.22 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.22 (NeilMitchell)
03:05:16 * hackagebot hplayground 0.1.2.6 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.6 (AlbertoCorona)
03:25:17 * hackagebot process 1.2.3.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.3.0 (HerbertValerioRiedel)
03:28:33 <Sh4rK> hi
03:28:52 <jle`> hi
03:31:31 <Sh4rK> I was wondering if it's possible to have some kind of "subtyping" in haskell
03:31:36 <Sh4rK> like
03:31:50 <Sh4rK> there would be a sorted list type
03:32:05 <Sh4rK> which acts like a list by default
03:32:32 <Sh4rK> but it knows it's sorted
03:32:44 <aawe> Sh4rK: You can create a sorted list and make it be instance of Traversable and Foldable
03:32:47 <hpc> there's a lot of conveniences that get you pretty close, but no
03:33:34 <Sh4rK> :(
03:34:10 <tjger> i seem to misunderstand applicatives. can anyone tell me whats's wrong with this: fromPolar' r theta = (,) <$> (\x -> r * (f theta)) <*> cos <*> sin
03:34:36 <bitonic> is there a reliable way to parse and print C doubles from C in a way that it's compatible with how they are printed and parsed in Haskell?
03:34:38 <KaneTW> generally subtyping introduces a lot of complexity that complicates everything a lot
03:35:51 <Sh4rK> i was thinking about something like attaching predicates to types
03:36:07 <aawe> :t ((,) <$>)
03:36:08 <lambdabot> Functor f => f a -> f (b -> (a, b))
03:37:04 <mauke^> tjger: what is that supposed to do?
03:37:25 <tjger> mauke^: im trying to convert polar coordinates to cartesian coordinates
03:38:23 <tjger> mauke^: but i guess it could be generalized to something like this: meh f g h x = (h . f $ x, h . g $ x). im just trying to do it in applicative style to get familiar with that
03:39:33 <kaidelong> @instances Functor
03:39:34 <lambdabot> ((,) a), ((->) r), ArrowMonad a, ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
03:39:35 <mauke^> ok, so you have a combiner, (,), a left function, h . f, a right function, h . g, and a single arg
03:39:40 <arkeet> tjger: applicative isn't really going to help you with that, I'm afraid.
03:39:57 <tjger> arkeet: so i need to use arrows?
03:39:58 <arkeet> at least, not without some other type.
03:40:00 <mauke^> meh f g h = liftA2 (,) (h . f) (h . g)
03:40:17 * hackagebot nsis 0.2.5 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2.5 (NeilMitchell)
03:40:30 <tjger> mauke^: can i pull out the application of h so i only need to write it once?
03:40:35 <arkeet> if you want to abstract out the cos and sin.
03:40:42 <mauke^> @pl \h -> liftA2 (,) (h . f) (h . g)
03:40:42 <lambdabot> ap (liftA2 (,) . (. f)) (. g)
03:40:45 <mauke^> terrible
03:41:02 <kaidelong> hmm pulling out applications is what traversable is for
03:41:08 <kaidelong> @instances Traversable
03:41:08 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
03:41:19 <tjger> arkeet: not necessarily.
03:41:28 <kaidelong> @type traverse
03:41:29 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:41:36 <arkeet> @type both
03:41:37 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
03:42:22 <kaidelong> so you'd trade writing h twice for having to write "Identity" and "runIdentity"
03:42:28 <nshepperd> tjger: you need to make cos and sin available as data for the (\f -> r * (f theta)), rather than lifting them directly
03:42:53 <arkeet> :t (both.both) (\r t f -> r * f t) (cos,sin)
03:42:54 <lambdabot>     Could not deduce (Data.Bitraversable.Bitraversable (->))
03:42:54 <lambdabot>       arising from a use of ‘both’
03:42:54 <lambdabot>     from the context (Floating a)
03:42:56 <arkeet> oh.
03:43:14 <nshepperd> > ((,) <$> ($cos) <*> ($sin)) (\f -> 1 * (f 1)) -- something like this
03:43:16 <lambdabot>  (0.5403023058681398,0.8414709848078965)
03:43:38 <nshepperd> :t ((,) <$> ($cos) <*> ($sin))
03:43:39 <lambdabot> Floating a1 => ((a1 -> a1) -> a) -> (a, a)
03:44:47 <arkeet> :t \r theta -> over both (\f -> r * f theta)
03:44:48 <lambdabot> (Data.Bitraversable.Bitraversable r, Num b) => b -> t -> r (t -> b) (t -> b) -> r b b
03:45:17 * hackagebot citeproc-hs 0.3.10 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.10 (AndreaRossato)
03:45:17 <arkeet> > (\r theta -> over both (\f -> r * f theta)) (cos, sin) 1 (pi/6)
03:45:18 <lambdabot>  Could not deduce (GHC.Num.Num a0)
03:45:18 <lambdabot>    arising from the ambiguity check for ‘e_116’
03:45:18 <lambdabot>  from the context (Data.Bitraversable.Bitraversable r,
03:45:19 * hackagebot citeproc-hs-pandoc-filter 0.1 - A Pandoc filter for processing bibliographic references with citeproc-hs  http://hackage.haskell.org/package/citeproc-hs-pandoc-filter-0.1 (AndreaRossato)
03:45:21 * hackagebot hlint 1.9.18 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.18 (NeilMitchell)
03:45:22 <arkeet> oh.
03:45:25 <arkeet> > (\r theta -> over both (\f -> r * f theta)) (cos, sin) 1 (pi/6) :: (Float,Float)
03:45:26 <lambdabot>  Couldn't match type ‘(a0 -> a0, a1 -> a1)’ with ‘GHC.Types.Float’
03:45:26 <lambdabot>  Expected type: (a2 -> (a0 -> a0, a1 -> a1)) -> (a0 -> a0, a1 -> a1)
03:45:26 <lambdabot>    Actual type: (a2 -> (a0 -> a0, a1 -> a1)) -> GHC.Types.Float
03:45:32 <arkeet> duh.
03:45:43 <arkeet> > (\r theta -> over both (\f -> r * f theta)) 1 (pi/6) (cos,sin)
03:45:44 <lambdabot>  (0.8660254037844387,0.49999999999999994)
03:47:17 <arkeet> > (getCompose . both (\f -> Compose $ \r t -> r * f t)) (cos,sin) 1 (pi/6)
03:47:18 <lambdabot>  Not in scope: ‘getCompose’Not in scope: data constructor ‘Compose’
03:47:21 <arkeet> oh.
03:47:26 <arkeet> @let import Data.Functor.Compose
03:47:28 <lambdabot>  Defined.
03:47:28 <arkeet> > (getCompose . both (\f -> Compose $ \r t -> r * f t)) (cos,sin) 1 (pi/6)
03:47:30 <lambdabot>  (0.8660254037844387,0.49999999999999994)
03:48:04 <arkeet> anyway, those are two ways I can think of doing it.
03:48:40 <arkeet> oh nshepperd did something, cool.
03:50:14 <nshepperd> all this lens stuff is black magic to me
03:50:19 <nshepperd> even though it's cool
03:50:32 <arkeet> you don't really need to know much about lens.
03:50:41 <arkeet> both :: Applicative f => (a -> f b) -> (a,a) -> f (b,b)
03:50:46 <shachaf> The only lensy bit is this function both, where both f (x,y) = (,) <$> f x <*> f y
03:50:46 <arkeet> over both :: (a -> b) -> (a,a) -> (b,b)
03:50:59 <nshepperd> hmm
03:51:25 <arkeet> (the actual `both` in lens has a more general type.)
04:05:17 * hackagebot auto 0.2.0.4 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.2.0.4 (jle)
04:06:19 <KaneTW> anyone here messed around with helm?
04:06:29 <KaneTW> any way to render text and graphics at the same time?
04:10:38 <ilpianista> hi, is there some way to remove old stuff from ~/.cabal/{lib,share}?
04:10:52 <arkeet> rm 
04:10:53 <arkeet> ;-)
04:10:58 <ilpianista> e.g. I've foo-x and foo-y
04:11:12 <ilpianista> eh, but I'd like to know if someone uses foo-x libs
04:11:27 <arkeet> you should ghc-pkg unregister things before deleting them.
04:11:39 <arkeet> I believe that will warn you if removal will break something.
04:11:43 <ilpianista> I did, this means it's "safe" to rm them?
04:11:49 <arkeet> yes
04:12:07 <ilpianista> no script to automize this? :-P
04:12:16 <arkeet> maybe there is, but I'm not aware of one.
04:12:20 <ilpianista> ok
04:14:02 <ilpianista> https://github.com/plancalculus/cabal-uninstall
04:15:04 <ilpianista> also, is "OK" that 'cabal info foo' does not show the version when the package installs a binary only? (e.g. xmobar)
04:15:08 <maximilian> How do I get c2hs to run from cabal? I have "src/METIS/Interface.chs" with "module METIS.Interface where", and "import METIS.Interface" in Main.hs
04:15:45 <maximilian> along with "#include <metis.h>" and "{#enum rstatus_et {underscoreToCase} deriving (Eq)#}" in Interface.chs
04:16:10 <maximilian> when I "cabal build" it says it can't find the module METIS.Interface
04:16:10 <dcoutts> ilpianista: yes
04:16:30 <ilpianista> dcoutts, it's a pity :-(
04:16:46 <dcoutts> maximilian: are all modules listed in the exposed or other modules? they're supposed to be
04:17:45 <dcoutts> ilpianista: cabal currently does not track executables, it just relies on ghc-pkg for the registration of libs.
04:17:58 <ilpianista> ah, and ghc doesn't track them, I saw
04:19:18 <maximilian> dcoutts: This worked, thanks. I didn't know that I should add it to 'Other-Modules'. Of course, now I get the error: "src/METIS/Interface.chs:5:6: Malformed head of type or class declaration: rstatus_et"
04:19:35 <chpatrick> am I missing something?
04:19:36 <chpatrick> https://hackage.haskell.org/package/lens-4.8/docs/Control-Lens-Fold.html
04:19:40 <chpatrick> this has both
04:19:49 <chpatrick> type Fold s a = forall m. Monoid m => Getting m s a
04:19:55 <chpatrick> and
04:19:55 <chpatrick> type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s
04:20:15 <chpatrick> I don't see how Contravariant f, Applicative f generalizes Const
04:20:17 * hackagebot deepseq 1.4.1.0 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.4.1.0 (HerbertValerioRiedel)
04:20:43 <dcoutts> maximilian: in principle all modules must be listed, but it's not enforced (things go wrong for libs, or for sources that need pre-processing)
04:20:44 <edwardk> chpatrick: if you have Contravariant and Applicative you can't use the argument, but you do have a monoidal structure
04:21:00 <edwardk> chpatrick: let's just look at Contravariant and Functor
04:21:02 <edwardk> if you have
04:21:21 <shachaf> (Contravariant f,Applicative f) means that f is (Const e) for some monoid e.
04:21:29 <shachaf> Oh, someone said that already.
04:21:38 <edwardk> or at least that f is isomorphic to Const e for some monoid e
04:21:59 <shachaf> Right, these things are always up to isomorphism.
04:22:40 <edwardk> Contravariant and Functor for f in    (a -> f b) -> s -> f t   means the argument is irrelevant. you can write 'phantom :: (Functor f, Contravariant f) => f a -> f b' in such a way that it loses no information
04:22:46 <edwardk> just using the laws of both
04:22:52 <chpatrick> ok, but let's say I have a function (a -> m) -> s -> m that I would like to expose as a Fold
04:23:00 <edwardk> e.g. fmapping to () and then contramapping from () to anything you want using const ().
04:23:09 <chpatrick> I can do that easily if I wrap it in Consts, if fold uses the first definition
04:23:14 <chpatrick> but I don't see how I can do that for the second one
04:24:14 <dcoutts> edwardk: oh in case you're interested, I've found a use case where I have a type that supports >>, pure/return and fail, but not fmap,<*>,>>=  (technically it can support the latter but only very inefficiently)
04:24:20 <edwardk> folding :: Foldable f => (s -> f a) -> Fold s a; folding sfa agb = phantom . traverse_ agb . sfa
04:24:44 <shachaf> A type without fmap? Is it some sort of GADT?
04:25:16 <edwardk> dcoutts: there are lots of those, you have an indexed monoid w/ a cancellative zero basically
04:25:22 <dcoutts> it can support those other operators, but it's so inefficient that you'd be doing it wrong
04:25:44 <edwardk> dcoutts: what is your usecase?
04:25:45 <shachaf> What's the type?
04:25:54 <dcoutts> one is supposed to handle those other things a bit differently (some sub-structure that is applicative)
04:26:15 <dcoutts> edwardk, shachaf: a kind of stack-based parser (for binary deserialisation)
04:26:21 <edwardk> ah
04:26:48 <edwardk> this reminds me i need to finish my lazy succinct Data.Binary-style encoder/decoder.
04:27:00 <dcoutts> each fmap costs an extra constructor in the deep embedding
04:27:02 <edwardk> i have all the pieces laid out, just never wired them up
04:27:18 <kaidelong> can anyone recommend a good plotting library?
04:27:32 <kaidelong> I need to generate some economics-related graphs from a huge lot of CSV data
04:27:44 <edwardk> can you Yoneda/Coyoneda the constructors to make it so you avoid the "functor only up to quotient" encoding that that sounds like you have?
04:27:53 <dcoutts> edwardk: a succinct structure would be great for the new binary serialisation I'm working on, for random indexing
04:28:30 <shachaf> Coyoneda "solves" every problem.
04:28:32 <dcoutts> edwardk: since it's possible to find the ()'s without a schema (the Haskell types), whereas that's impossible for the Data.Binary format
04:28:39 <KaneTW> gnuplot?
04:28:50 <dcoutts> edwardk: I've no idea, reference? :-)
04:29:18 <edwardk> what i have is (most of) a Binary-compatible serializer that serializes the main output the original way, and then serializes two extra succinct structures. one which provides the interleaving of "shape" and "data" and the other which provides a succinct tree encoding.
04:29:28 <dcoutts> edwardk: it's not a big deal, I can do the things I need efficiently, it's just that I cannot reuse pure/return/fail in some places where it'd be convenient
04:29:54 <edwardk> This then would let me build a lazy deserializer. mmap in the contents, and then you can walk the resulting AST and it'll lazily construct the structure in memory based on the parts you look at, with O(1) access per thunk and vanishingly small overhead for the index.
04:30:44 <edwardk> dcoutts: an example of a coyoneda'd constructor: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L72.
04:31:11 <dcoutts> edwardk: so with the new format, one could construct that index from the data alone, rather than having to extend the serializer
04:31:11 <edwardk> instead of the obvious: Await (k (t -> r)) r
04:31:23 <edwardk> this has the benefit of being functorial even when k is not.
04:32:49 <edwardk> dcoutts: in theory you could write such a pass yeah. i even have two variants on the index i can build one of which ensures O(1) memory accesses per thunk in the AST, the other is trickier and does a 'heavy path decomposition' to make it so you pay far less in practice for the deeper parts of the structure, making things much more coherent.
04:33:01 <dcoutts> edwardk: I'm being rather careful with my deep embedding to only include closed function terms, so that constructing the deep embedding does not allocate.
04:33:04 <edwardk> both of which could be written in a way that they ran 'after the fact' on the index.
04:33:41 <edwardk> but the general idea of writing a lazy deserializer has been stuck in my head for a couple years now
04:33:56 <dcoutts> edwardk: yes, you were telling me last zurihac
04:33:58 <edwardk> so that you can just say, mmap in the .hi files or whatever you have, and only pay for the parts you look at
04:34:15 <dcoutts> edwardk: I'll be talking about this stuff again at zurihac this year, hopefully more finished :-)
04:34:20 <edwardk> k =)
04:34:46 <edwardk> my zurihac talk will probably be on the contravariant-applicative Divisible/Decidable classes and discrimination.
04:34:52 <dcoutts> lazy deserialisation would be a very nice addition, especially if it can be added on, rather than a whole different system & format
04:35:11 <edwardk> so a more complete version of the stuff i was rambling about at Compose
04:35:16 <dcoutts> ah
04:35:36 <kaidelong> mmm, I was hoping for something simpler, but i think I'll go ahead and try gnuplot
04:35:46 <kaidelong> I guess I could always use gloss, too
04:35:55 <edwardk> the main thing i want is to not appreciably increase the file sizes
04:36:07 <edwardk> the main concern i have is the need to serialize 3 streams of data out
04:36:34 <nshepperd> kaidelong: http://hackage.haskell.org/package/plot seems alright for simple things, i've been using it
04:36:40 <edwardk> because i have the original Binary stuff and then a couple extra streams, one describing the interleaving, and the other just the shape. each is smallish
04:36:52 <edwardk> but you probably want to produce them online while generating the binary data
04:36:52 <dcoutts> edwardk: 3? I thought it was just the succinct index
04:38:00 <edwardk> 2 succinct data structures, one provides the interleaving, do I have a bit of shape data? or is this a (byte?) of actual data.  -- such that, say every byte of the original binary data corresponds to a 1 in that index, and every paren in the balanced parenthesis representation corresponds to a 0.
04:38:16 <dcoutts> edwardk: so one improvement in the new binary stuff I'm working on, is the deep embedding of the serialisation means you can write one set of instances and write multiple encoder interpreters
04:38:17 <edwardk> then you have a succinct tree encoded as 2n + o(n) bits of shape.
04:38:41 <edwardk> so its just 0's for ('s and 1's for )'s with a range min structure tacked on to give me O(1) tree traversal.
04:38:59 <edwardk> then you can use the top level to move back and forth from a position in the tree to where the data for it starts.
04:39:04 <edwardk> in O(1) time
04:39:22 <dcoutts> ok
04:39:49 <edwardk> basically take the position you are at in the tree of balanced parens, use select to get the position of that 0 in the top structure, then that tells you how many 1s are to the left of you, that is your byte offset in the binary stream
04:40:53 <edwardk> so to walk to the second child of a node you use the succinct tree tricks to walk down from (()()) into the second child (), and then look up the byte offset using the top level interleaving index.
04:41:18 <edwardk> this is like a wavelet tree encoding, but with just one discriminating layer
04:41:36 <edwardk> and with rangemin rather than rank/select on the second index
04:41:58 <edwardk> (you can use LOUDS or DFUDS encoding to get away with rank/select on the second index, but it can't be constructed in parallel that way)
04:42:05 <dcoutts> edwardk: I think I understood when you explained it last year, but we had had quite a bit to drink :-)
04:42:10 <edwardk> hah
04:42:15 <edwardk> oh yeah that was in the middle of the night
04:42:20 <dcoutts> :-)
04:42:50 <edwardk> I'd forgotten i had given you that spiel before by the time we got to compose and went through it all again =)
04:43:03 <dcoutts> edwardk: but we do need a separate set of decoders though right, to do the lazy deserialisation
04:43:17 <dcoutts> we cannot reuse the ones that just slurp data linearly
04:43:26 <dcoutts> not if we want to put thunks in
04:43:35 <edwardk> well. in theory i can get away with writing an instance for this using the machinery in my bytes packgae
04:43:37 <edwardk> er package
04:43:40 <kaidelong> nshepperd: mmm, I'm trying to gather from the docs how I could draw a Lorenz curve with this
04:43:46 <edwardk> so i should be able to reuse a Serial instance for an existing data type
04:44:00 <dcoutts> edwardk: but only for "leaf" types right?
04:44:00 <kaidelong> it's like a bar graph but with trapezoids rather than rectangles
04:44:12 <kaidelong> to suggest the curvature
04:44:26 <kaidelong> doesn't look like it lets you customize how it plots the data
04:45:03 <edwardk> the trick is to treat a chain of (<*>)'s as a flat (()()()()()()) with the right number of children to remove associativity concerns. then basically the nodes that have data in them will be the things that you discriminate on tag wise
04:45:17 * hackagebot mdcat 0.1.0.1 - Markdown viewer in your terminal  http://hackage.haskell.org/package/mdcat-0.1.0.1 (bobfang1992)
04:45:24 <edwardk> interleaved you'd be looking at data like:      (tag(foo)(bar)(baz))
04:45:30 <nshepperd> kaidelong: oh, yeah, I'm not sure it supports that
04:45:31 <kaidelong> it looks like a cool library, I really like the idea of being able to work with it live in ghci
04:45:42 <kaidelong> I would love if I could use it honestly
04:46:09 <edwardk> so to figure out the constructor is to walk to the node itself, binary deserialize the tag as the data structure was doing previously, then you build 3 thunks each of which deserializes their parts of the structure
04:46:09 <dcoutts> edwardk: but you mean reinterpret a Serial instance right, not directly reuse?
04:46:16 <edwardk> yeah
04:46:20 <edwardk> its a new instance of the class
04:46:25 <dcoutts> ok
04:46:25 <edwardk> but the code is shared
04:46:28 <edwardk> in theory any ways
04:46:36 <edwardk> haven't gone through all the details yet
04:47:29 <edwardk> i've been using the classes in bytes for a lot of things lately. e.g. hyperloglog uses them to get a robust hashing function by serializing into an hmac
04:47:43 <edwardk> that way i avoid the terrible problems with the Hashable class breaking hyperloglog
04:47:58 <edwardk> and i don't need to make up a new class.
04:48:46 <edwardk> and i can provide a transformer for such hashing. that way you can check CRCs when serializing/deserializing by computing it in the transformer
04:49:20 <edwardk> (it works out nicely symmetrical, with one transformer that can transform either Get or Put)
04:50:32 <dcoutts> edwardk: I should add bytes to my benchmark set :-)
04:50:46 <edwardk> i have no idea how slow it is in practice
04:50:55 <edwardk> i use it for convenience, because i'm sick of repeating myself in code ;)
04:50:59 * dcoutts is obsessed with speed
04:51:11 <edwardk> and because binary/cereal don't offer the higher order versions of the combinators
04:51:34 <edwardk> and i need higher order serialization for a lot of things when i have polymorphic recursion, etc.
04:52:02 <dcoutts> edwardk: higher order?
04:52:22 <edwardk> https://github.com/ekmett/bytes/blob/master/src/Data/Bytes/Serial.hs#L636
04:52:37 <edwardk> class Serial1 f where serializeWith :: MonadPut m => (a -> m ()) -> f a -> m ()    -- etc
04:53:00 <edwardk> you tell me how to serialize a's and i'll serialize an 'f a'
04:53:19 <dcoutts> ah
04:54:05 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Syntax/Type.hs#L383 <- is an example of where it uses it
04:54:52 <edwardk> Type is polymorphically recursive. Scope b f a = f (Either b (f a)) -- basically
04:54:55 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Syntax/Type.hs#L229
04:55:07 <HEGX64> Can I make a list of a particular typeclass (eg. [Eq] or [Show] or [my own typeclass]) where members can be different types but share a typeclass?
04:55:17 * hackagebot mdcat 0.1.0.2 - Markdown viewer in your terminal  http://hackage.haskell.org/package/mdcat-0.1.0.2 (bobfang1992)
04:59:36 <chpatrick> HEGX64: yes but it might be an anti-pattern
05:00:18 * hackagebot hscolour 1.22 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.22 (MalcolmWallace)
05:00:20 * hackagebot mdcat 0.1.0.3 - Markdown viewer in your terminal  http://hackage.haskell.org/package/mdcat-0.1.0.3 (bobfang1992)
05:02:17 <frerich> I sometimes wish for an easy way to define types which impose additional constraint on existing types. For instance, something like 'newtype Positive = Positive Int' with a 'makePositive :: Int -> Maybe Positive' function which enforces that the given number is greater than zero. I think it would be possible to devise a template haskell helper for doing this, such that I can write something like '$(constraint
05:02:17 <frerich>  Positive ''Int (>0))' such that it defines the newtype sa well as a function 'makePositive :: Int -> Maybe Positive'.
05:02:17 <frerich> Does anybody know whether something like this exists already?
05:04:48 <dropp> hey hey
05:05:18 * hackagebot tasty-hunit 0.9.2 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.9.2 (RomanCheplyaka)
05:05:40 <divVerent> frerich: if only it were that wasy... what would (-) do on pos1 - pos2?
05:05:57 <divVerent> in most cases such a thing requires lots of special cases
05:06:45 <divVerent> in fact, your case can't possibly be Num
05:35:19 * hackagebot mdcat 0.1.0.4 - Markdown viewer in your terminal  http://hackage.haskell.org/package/mdcat-0.1.0.4 (bobfang1992)
05:43:01 <forgottenone> is defining a new function in the where clause with given parameters slower than taking parameters as arguments?
05:43:06 <frerich> divVerent : There would be no '(-)' since 'Positive' does not instantiate Num.
05:46:05 <frerich> divVerent : My idea is to just scrap the boilerplate. Something like in http://lpaste.net/126987
05:46:54 <frerich> A bit of TH magic to define the type and the (smart) constructor.
06:20:51 <frerich> Hm, is there any type which has plausible instances for both `Integral` as well as `Float`? I just realized that 'f x = sqrt (x `mod` 10)' happily typechecks, yielding a function of type 'f :: (Floating a, Integral a) => a -> a' -- but I don't know of any value I could pass to 'f' which would fit (other than 'undefined' or such).
06:21:38 <opqdonut> no, I don't think there is such a type
06:21:38 <tdammers> @hoogle Data.Scientific
06:21:40 <lambdabot> package scientific
06:22:25 <clrnd> much helpful
06:22:31 <tdammers> hmm no
06:22:47 <tdammers> not Integral
06:24:11 <crisacem> !list
06:25:14 <tdammers> Prelude.PHP probably has both Floating and Integral instances for String
06:25:51 <frerich> :-))
06:26:41 <pavonia> :t mod
06:26:42 <lambdabot> Integral a => a -> a -> a
06:26:51 <Axman6> was it PHP ot javascript where "5" + 2 = "52", "5" - 2 = "3"?
06:26:55 <Axman6> or*
06:27:03 <pavonia> Wouldn't that be useful for non-integral types too?
06:27:16 <nulpunkt> Axman6: I'm guessing js
06:27:21 <clrnd> Acme.JavaScript would be funny
06:27:49 <clrnd> then GHCJS that and, omg
06:29:27 <Axman6> yo dawg
06:31:37 <aleator__> Hi! How do you deploy programs that include libraries that use 'data-files' field in cabal? I'd rather not compile them at the target server.
06:32:35 <mauke^> Axman6: javascript, but "5" - 2 == 3
06:32:39 <adamse`> aleator__: the paths are hard coded in the Paths_packagename module I believe, the simplest option might be to make sure all files end up in the same locations on server as on the computer you're compiling on
06:33:16 <indiagreen> > sqrt (109 `mod'` 10)
06:33:17 <lambdabot>  3.0
06:33:38 <adamse`> aleator__: ie make a sandbox in /deploy and deploy and compile in that folder
06:36:15 <aleator__> adamse`: Thanks. Doesn't seem like a really optimal solution however
06:37:40 <adamse`> aleator__: nopes, would be nice if cabal supported making bindists
06:39:14 <dcoutts> adamse`, aleator__: cabal copy --destdir=$image  makes an installable image
06:39:20 <dcoutts> for an individual package
06:40:41 <adamse`> dcoutts: that's nice! single package -- ie does not include data files for deps?
06:41:17 <dcoutts> adamse`: includes data files, everything that's part of the package. But no, it's for that single package.
06:42:05 <dcoutts> adamse`: so for a collection you'd need to make multiple images (and maybe merge them)
06:43:45 <aleator__> dcoutts: Thanks. Seems to be what I'm looking for. 
06:44:54 <aleator__> dcoutts: Quick further question, what is the recommended workflow for interactive development with the data-files field? Do I still need to manually set up a version for ghci or does cabal do this for me?
06:46:40 <aleator__> Hmm.. cabal copy is telling me "the given installed package instance does not exist." for all local packages.
06:50:11 <dcoutts> aleator__: not sure what you mean with the data files
06:50:19 * hackagebot snowflake 0.1.1.1 - A loose port of Twitter Snowflake to Haskell. Generates arbitrary precision, unique, time-sortable identifiers.  http://hackage.haskell.org/package/snowflake-0.1.1.1 (edofic)
06:50:21 * hackagebot koofr-client 1.0.0.2 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-1.0.0.2 (edofic)
06:51:44 <aleator__> dcoutts: I mean the files that are listed in package.cabal under data-files field.
06:52:24 <dcoutts> aleator__: sure sure, but I'm not sure what you mean with what you're trying to do. What's the issue with ghci?
06:53:40 <dcoutts> aleator__: and I'm not sure where that error message is coming from. I'm surprised, since cabal copy --destdir doesn't really do anything except copy files
06:53:57 <aleator__> dcoutts: I'm reading through how to access the data-files and there are lot of stuff online about how ghci does not know about the Paths_?.hs module and was wondering if that was historical or actual.
06:54:50 <dcoutts> aleator__: oh, when you're hacking on the package in the build tree you can run cabal repl
06:54:58 <dcoutts> and that runs ghci in the right context
06:55:15 <aleator__> dcoutts: I thought so. Thanks again.
06:55:19 * hackagebot effect-handlers 0.1.0.3 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.3 (edofic)
06:55:55 <aleator__> dcoutts: The full error message of the cabal copy is here: https://gist.github.com/aleator/a8108c915722ff7f5420. All the packages it complains about are local.
06:57:06 <dcoutts> aleator__: oh, make sure you've configured and built first
06:57:32 <dcoutts> it just copies the already-built installable files
06:58:14 <aleator__> Ah. My bad, I thought install implies a build.
07:01:12 <hexagoxel> it does, but at least when using sandboxes, the build happens in different directories. welcome to the wonders of cabal.
07:01:59 <dcoutts> sandboxes have been rather stapled on, and have a few quirks like this
07:02:49 <aleator__> I see. Would it be remotely possible to hit the sandbox with the copy command? Since copy doesn't include deps, but they are installed in the same sandbox it could make things easier.
07:15:19 * hackagebot cless 0.2.0.0 - Colorized LESS  http://hackage.haskell.org/package/cless-0.2.0.0 (HideyukiTanaka)
07:16:30 <orion> Is it possible to get aeson to ignore/not parse certain components of a JSON object?
07:16:48 <orion> I am querying an API and the response includes a bunch of crap I don't need. I am only interested in two fields.
07:17:24 <indiagreen> orion: sure, a sec
07:18:06 <indiagreen> http://lpaste.net/244033483343659008
07:18:22 <indiagreen> sorry, slightly messy code from a real script
07:18:59 <indiagreen> in this example, it doesn't even matter what fields the object has, as long as it has 3 fields that are listed in the parser
07:20:10 <orion> indiagreen: Interesting, thanks!
07:20:19 * hackagebot fluent-logger 0.2.2.0 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.2.2.0 (NoriyukiOhkawa)
07:20:34 <indiagreen> the thing to keep in mind is that aeson isn't magic
07:20:42 <indiagreen> “.:” is just a lookup operator
07:21:13 <indiagreen> “v .: field” looks for a field in the object and returns it, nothing more
07:22:35 <orion> indiagreen: return Datapoint{..} -- is that wildcard data construction!?
07:22:41 <indiagreen> yep
07:22:49 <orion> I didn't even know you could do that.
07:22:58 <indiagreen> enabled by {-# LANGUAGE RecordWildCards #-}
07:23:15 <indiagreen> constructs a record from variables with matching names which are in scope
07:23:20 <orion> Hot.
07:23:31 <indiagreen> you can also use it in patterns
07:23:36 <indiagreen> i.e.
07:23:48 <indiagreen> f Datapoint{..} = ...
07:23:49 <kaidelong> that was the use I actually knew about
07:24:08 <kaidelong> does this other use have any static checking for if you forget to define something?
07:24:19 <kaidelong> or will you end up with "undefined" fed in implicitly?
07:24:26 <kaidelong> to construct the record
07:24:53 <indiagreen> it gives you a warning
07:25:10 <indiagreen> the same warning that it gives when you construct a record explicitly and forget about a field
07:25:31 <indiagreen> http://lpaste.net/4377752545817264128
07:42:28 <hesiod> Is there an easier way to write (\x -> ioaction1 x >> ioaction2) :: a -> IO (), i.e. ioaction1 `fancyoperator` ioaction2
07:43:59 <indiagreen> hesiod: there are a few fancy ways, all of which look worse than your version
07:44:02 <tdammers> :t finally
07:44:03 <lambdabot> IO a -> IO b -> IO a
07:44:08 <tdammers> could abuse that
07:44:15 <indiagreen> ...that's cheating
07:44:20 <tdammers> :D
07:44:23 <tdammers> it's also wrong
07:44:32 <c_wraith> err
07:44:34 <tdammers> because it will run the second action even if the first one fails
07:44:44 <tdammers> (kind of the point)
07:44:47 <jtanguy> io2 =<< io1  -- ?
07:44:50 <indiagreen> oh, but it'll turn out now that hesiod wanted that all along
07:44:53 <c_wraith> Isn't that just io1 >=> io2
07:44:53 <indiagreen> or something
07:45:01 <c_wraith> the fish operators are clean
07:45:04 <tdammers> :t (>=>)
07:45:05 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:45:20 * hackagebot amqp 0.12.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.12.2 (HolgerReinhardt)
07:45:22 <indiagreen> “io1 >=> const io2”, then?
07:45:53 <c_wraith> Oh, I missed that it was (>>).  Yeah, nothing hugely better than the original
07:46:11 <Iceland_jack> c_wraith: “Stick with the original” says I
07:46:18 <hesiod> I tried >=>, but it didn't work out
07:46:37 <hesiod> Iceland_jack: but it's boilerplatey...
07:46:38 <tdammers> I'd go with a named function instead of the lambda, but that's just personal taste
07:47:01 <tdammers> and if that pattern crops up more often, I'd consider writing that operator myself
07:50:50 <keko-2> @hoogle Monad m => (a -> m x) -> m y -> a -> m y
07:50:52 <lambdabot> No results found
07:50:59 <hesiod> indiagreen: Actually, your "io1 >=> const io2" worked out (and looks fancier imo)
07:51:22 <hesiod> keko-2: \i1 i2 -> i1 >=> const i2 :: Monad m => (a -> m b) -> m c -> a -> m c
07:51:24 <keko-2> @hoogle Monad m => (a -> m ()) -> m y -> a -> m y
07:51:24 <lambdabot> No results found
07:52:19 <hesiod> :t \i1 i2 -> i1 >=> const i2
07:52:20 <lambdabot> Monad m => (a -> m b) -> m c -> a -> m c
07:52:36 <Iceland_jack>     foo x = do
07:52:36 <Iceland_jack>       ioaction1 x
07:52:36 <Iceland_jack>       ioaction2
07:53:09 <keko-2> hesiod: hm?
07:53:45 <Iceland_jack> When there isn't an obviously good way of writing it with combinators.. :)
07:54:07 <hesiod> keko-2: hm? i1 >=> const i2 works!
07:54:17 <hesiod> Iceland_jack: but there is!
07:54:26 <mauke^> (>> ioaction2) . ioaction1
07:54:32 <tdammers> tee hee
07:54:41 <mauke^> ioaction1 >>> (>> ioaction2)
07:54:42 <Iceland_jack> Depends on your definition of obviously good
07:54:49 <mauke^> needs more >
07:55:21 <hesiod> :t \i1 i2 -> i1 >>> (>> i2)
07:55:22 <lambdabot> Monad m => (a -> m a1) -> m b -> a -> m b
07:55:27 <keko-2> hesiod: I was trying to figure out if there's an operator or function for that already
07:55:50 <keko-2> so I was confused why you directed that to me
07:56:49 <hesiod> keko-2: Just wanted to point out that we already found something working (I'm ok without an operator for that)
07:56:55 <hesiod> keko-2: nevermind
07:56:58 <keko-2> ok
07:57:11 <jtanguy> i'm sure there is something in the plumbers package for that
07:57:39 <indiagreen> maybe we should hold daily golfing tournaments on #haskell
07:58:16 <indiagreen> ...now only to get someone write a bot for that and a problemset
08:04:21 <hesiod> I now managed to turn a 15-line do/case/if-then-else function into this: a >>= bool b (c >> d >>= maybe (e >> f) (triM_ (h . g) i j >=> const (k >> l)))
08:04:32 <hesiod> imo, it looks much better now :D
08:06:16 <frerich> It's shorter, but quite frankly, I find it hard to figure out what's going on.
08:07:42 <hesiod> frerich: depends on personal preference, I guess
08:09:37 <frerich> hesiod : To some degree, probably. However, using more generic functions also means that you always have to keep track of the type of things to be able to tell what's going on, e.g. 'a >>= bool b ...' doesn't tell you mutch without knowing the type of 'a'.
08:09:56 <frerich> hesiod: For the same reason, you probably write 'h . g' instead of 'fmap h g'
08:10:20 * hackagebot wai-session 0.3.1 - Flexible session middleware for WAI  http://hackage.haskell.org/package/wai-session-0.3.1 (StephenWeber)
08:12:35 <athan> Is there a general purpose `get` / `post` library for WAI, similar to Scotty?
08:13:00 <tdammers> WAI already does get and post
08:13:10 <tdammers> not sure what you'd want out of such a library
08:13:22 <tdammers> there's also some extra parsing stuff and such in wai-extra
08:13:24 <frerich> athan: Not sure whether it fits your bill, but I think http://www.serpentine.com/wreq/ looks reallynice.
08:13:32 <athan> tdammers: That's just with the response-type string, right?
08:13:46 <athan> frerich: Oh! Thank you!
08:13:59 <athan> tdammers: I'll check it out, sorry x_x
08:14:02 <tdammers> :
08:14:30 <paolino> hello, I've had half an hour  puzzling about this g x0 x1 =  tail $ scanl (+) x0 (replicate 1 $ (x1 - x0)/fromIntegral 1) 
08:15:14 <paolino> if I use g x0 x1 = [x1] I have a result, which I don't have with the function above
08:18:25 <athan> tdammers: So by using the `addHeaders`, I should be set for setting `methodGet`?
08:18:32 <athan> bad wording ><
08:18:37 <athan> I should be okay*?
08:18:47 <tdammers> ?
08:19:13 <eacameron> Is there a GUI framework in Haskell that can *statically* link against my binary? wxHaskell requires a DLL to be installed on the system that runs the app...
08:19:57 <eacameron> gtk2hs looks somewhat hopeful since GTK is written in C and not C++ (which *might* mean static linking is possible with Haskell?)
08:20:03 <frerich> paolino: Both 'x0' and 'x1' are apparently of some type which implements Num, i.e. of type 'Num a'. So in 'g x0 x1 = [x1]', g yields a value of type 'Num a => [a]'. Now, if you replicate the quotient (as given by a/b) one time, you get a list with one element of type 'Fractional a => [a]'
08:20:33 <dcoutts> eacameron: I don't think gtk+ really supports static linking. It relies on loading themes and stuff as shared libs at runtime.
08:21:31 <dcoutts> eacameron: but it's totally possible to deploy such apps, even on windows, just a matter of shipping the right set of files
08:21:52 <dcoutts> eacameron: the dlls do not need to be pre-installed or on the system, can be with the app.
08:22:03 <eacameron> dcoutts: bummer. Yes I know it can be done. But my goal is to write the installer, not be installed! ;)
08:22:59 <eacameron> dcoutts: I suppose I would likely need to rely on OS APIs directly to get away with it.
08:23:02 <paolino> frerich, I signed it, no differences
08:23:12 <dcoutts> eacameron: that's not a problem. Can run from any location, no installation necessary.
08:23:17 <athan> tdammers: Is routing accomplished by inspecing the first parameter of the application (the request), then case matching or something similar?
08:23:22 <frerich> paolino: What do you mean by 'signed'?
08:23:37 <paolino> g :: Float -> Float -> [Float]
08:23:46 <dcoutts> eacameron: I had a customer that distributed a Haskell Gtk+ app on CD and ran it straight off the CD.
08:23:47 <athan> the application function*
08:23:51 <tdammers> oh, routing... well, wai doesn't do that out of the box
08:24:03 <athan> yeah that's what I thought
08:24:04 <tdammers> you have to parse the request path yourself
08:24:05 <dcoutts> eacameron: see e.g. http://projects.haskell.org/ThreadScope/threadscope-0.2.2.zip
08:24:11 <athan> tdammers: Cool beans
08:24:14 <athan> thanks :)
08:24:14 <dcoutts> eacameron: just unpack and run
08:25:17 <tdammers> I like the flexibility that gives me though
08:25:25 <tdammers> especially how I can nest routes that way
08:26:21 <eacameron> dcoutts: ah! that's pretty neat. Still in my very niche context, I don't think I could convince my colleagues to go with a haskell implementation of this very simple tool if it needed to expose multiple files to our customers. We are hoping for a single-exe download from our website that can be run to install our app. I had already done a portion of the work in hs so thought I'd give a whack at the GUI portion.
08:27:23 <mauke^> you could have the single exe unpack multiple files to a temp dir and run stuff there
08:27:43 <SrPx> What is our answer when someone asks: "okay, what about inheritance"? 
08:27:49 <eacameron> mauke^: presumably without a GUI? ;)
08:27:54 <mauke^> yes
08:28:03 <mauke^> why does unpacking and running another exe need a GUI?
08:28:04 <eacameron> mauke^: that's fair
08:28:14 <tdammers> SrPx: "what about it?"
08:28:19 <mauke^> SrPx: "no, thanks"
08:28:29 <dcoutts> eacameron, mauke^: yes we actually had a non-gui AutoRun exe in the CD root that chained to the real program
08:28:36 <SrPx> mauke^: :P
08:28:56 <frerich> paolino: QuickCheck gave me a case where the tw functions differ: if you call the original function like 'g 8.0 1.2214115' the result is '[1.2214117]', probably due to imprecisions in the floating point arithmetic.
08:29:01 <tdammers> foo x = if x == 0 then "nope" else show x -- there, I just used inheritance to make a "better" show
08:29:23 <eacameron> dcoutts: mauke: That's a fair stab at it. Certainly more complex, but not a bad idea in the slightest.
08:29:48 <SrPx> So that person insists: "I have a "creature" record type with 10 fields. There is a slightly different type, "player", which is the same as creature plus 3 fields. Do you just write 2 nearly identical types?
08:29:54 <SrPx> "
08:30:03 <dcoutts> eacameron: most gui libs (even the MS ones) are rather complex and use multiple dlls
08:30:12 <tdammers> SrPx: I dislike arguing with people who insist a lot
08:30:20 * hackagebot network-builder 0.1.0 - Linux NetworkNameSpace Builder  http://hackage.haskell.org/package/network-builder-0.1.0 (junjihashimoto)
08:30:25 <SrPx> yes someone asked me that yesterday and it is one of the things I'm not sure how to answer because I actually struggle with it myself
08:30:26 <mauke^> SrPx: I'd use Moose::Role
08:30:27 <eacameron> dcoutts: true true...they're just bundled with the system already
08:30:33 <dcoutts> eacameron: for an installer, the other option is to go with a standard thing, and call out to custom functionality.
08:30:38 <EvanR> SrPx: at this point i would say you want a database instead of a network of similarish but different records
08:30:44 <tdammers> SrPx: composition over inheritance is one possible answer
08:30:47 <dcoutts> eacameron: actually most of them are not, unless it's using "classic" win32.
08:30:55 <tdammers> SrPx: "use closures" is another
08:31:05 <SrPx> don't get neither
08:31:18 <EvanR> you can view the database in many ways, not even limited to the 9 record types you defined
08:31:26 <paolino> frerich, g x0 x1 =  let z = tail $ scanl (+) x0 (replicate 1 $ (x1 - x0)/ 1) in trace (show z) z prints [NaN]
08:31:32 <EvanR> different entities can share attributes, or have unique attributes
08:31:37 <eacameron> dcoutts: hmm...I must be accustomed to classic then (MFC)
08:31:38 <tdammers> first one: don't use inheritance, instead, make types that describe certain aspects of your things, and compose them into more complex types
08:31:52 <tdammers> data Entity = Entity Behavior Appearance
08:31:55 <eacameron> dcoutts: but we do install some win dlls now that I think of it
08:32:10 <eacameron> dcoutts: but your installer idea has promise. what does MinGHC use?
08:32:20 <dcoutts> eacameron: basically anything you build with VSC++ will use an external lib which they encourage you to ship, not to rely on being pre-installed. Though yes the C lib can be statically linked.
08:32:20 <tdammers> data Behavior = PlayerBehavior Player | NPCBehavior NPVC
08:32:53 <SrPx> So, instead of "data Creature = Creature { velocity :: ..., position :: ..., health :: ..., mana :: ..., shape :: ..., attack :: ..., defense :: ... }" and then "data Player = Player { almost_the_same ... }"
08:33:32 <EvanR> you can factor out the common fields, but then you have even more nesting than before
08:33:33 <eacameron> dcoutts: mauke^: MinGHC uses nsis. It's a single-exe download. That's probably what I need then!
08:33:40 <EvanR> i guess you can use lenses
08:34:08 <eacameron> dcoutts: mauke^: and now I must wonder: what does NSIS use?? ;)
08:34:11 <SrPx> you suggest that I have "data PhysicalObject = ... velocity, position etc"... "data FightingStatus = atk, def, etc..." "data GameCharacter = ... health, mana, etc... " and then "data Creature = Creature PhyiscalObject FightingStatus GameCharacter" etc?
08:34:15 <dcoutts> eacameron: I used to use Inno Setup when I used to write the gtk2hs installers for windows
08:34:21 <tdammers> second approach: describe the public interface(s) for your things as a monomorphic data type containing functions that close over the actual, polymorphic, entities
08:34:47 <tdammers> you can then freely reuse some of these across different entity "types"
08:37:34 <eacameron> dcoutts: mauke^: oh, nsis is just a DSL for building NSIS projects....a bit shallower than I was hoping for, but still a step in the right direction.
08:38:18 <dcoutts> eacameron: inno setup is similar, you give the innosetup compiler a .iss file and it builds you an installer exe
08:38:57 <eacameron> dcoutts: come to think of it, I've used inno setup before and really liked it. It doesn't have a cool haskell DSL, but big deal ;)
08:39:27 <dcoutts> eacameron: yeah, it's not too bad, and scriptable in pascal
08:40:07 <eacameron> dcoutts: Nothing like a dip into pascal to cool the senses
08:41:01 <dcoutts> eacameron: and it can call out to custom util exes, which would be a way to get at custom haskell code during setup
08:41:17 <eacameron> dcoutts: Now we're talking!
08:41:29 <eacameron> dcoutts: thanks. I found this which is a great start: http://www.sherlocksoftware.org/page.php?id=50
08:42:32 <dcoutts> eacameron: here's an example https://github.com/gtk2hs/gtk2hs/blob/master/tools/win32/gtk2hs.iss
08:42:45 <dcoutts> for installing gtk2hs itself (but very outdated)
08:43:12 <eacameron> dcoutts: Sweet!
08:48:24 <delrik> Hi guys: What are the implications of the following module definition?
08:48:26 <delrik> module Bitmap.RGB(module Bitmap.RGB)
08:48:45 <delrik> how does it affect modules that import Bitmap.RGB?
08:49:02 <Cale> delrik: That doesn't make much sense
08:49:09 <Cale> delrik: I'm not even sure that's allowed
08:49:13 <delrik> http://rosettacode.org/wiki/Basic_bitmap_storage#Haskell
08:49:16 <mauke^> I think it's allowed
08:49:27 <mauke^> AFAIK it's equivalent to module Bitmap.RGB where
08:49:30 <Cale> Usually you re-export modules which are imported by your module
08:49:44 <Cale> But yeah, if it's allowed, it's a no-op
08:50:16 <Cale> Whoever wrote that code didn't understand module declarations
08:50:31 <delrik> oh, ok. haskell needs an elements of style, is there something of the sort? http://www.bartleby.com/141/
08:51:34 <Cale> There's http://urchin.earth.li/~ian/style/haskell.html
08:51:49 <delrik> nice, thanks Cale!
08:51:56 <Cale> which is mostly about concrete syntactic things
08:52:31 <Cale> Other people have written similar style guides
08:53:37 <Cale> https://github.com/chrisdone/haskell-style-guide more
08:54:24 <Cale> I actually disagree with a couple small things there
08:55:00 <delrik> collections?
08:55:47 <delrik> I used that format for 10+ argument functions when writing C, but never for collections.
08:55:50 <Cale> The record types example, I would usually not press Enter after the name of the constructor
08:56:22 <Cale> Oh, yeah, the collections thing, I'll sometimes do that, but only if I expect the list or whatever to be changing
08:56:45 <Cale> I think it looks a bit ugly, but it's a little easier to manipulate
08:58:15 <delrik> Thanks again for the references =)
08:58:23 <frerich> I think it can be safely said that in a few years, chrisdone will dig up that style guide and disagree with a couple small things, too.
08:59:16 <frerich> At least if he's anything like me, his style changes ever so slightly over time as he's exposed to other people's code.
09:01:46 <wei2912> how do i create a bitstring of 4 bits? i'm working on http://cryptopals.com/sets/1/challenges/1/
09:03:00 <EvanR> Data Bit = I | O, [O,O,O,O]
09:03:23 <wei2912> well, i guess that works
09:07:02 <wei2912> thanks EvanR 
09:15:20 * hackagebot feed-crawl 0.1.1.0 - Utility for fetching feeds with redirect info and HTML link detection  http://hackage.haskell.org/package/feed-crawl-0.1.1.0 (DanielChoi)
09:15:43 <athan> tdammers: Have you ever gotten a runtime error like this? http://lpaste.net/127001
09:16:43 <tdammers> athan: hmm, no, don't think so
09:17:02 <athan> shoot. Must be from Yaml or something. Thanks!
09:26:24 <paolino> frerich, thanks it was a problem with SerialPort and threading (my guess) , I "resolved" with a isNaN check
09:27:32 <Retro14> I am working on small scripts. In the first part I return 'True' or 'False' if the input contains a decimal. Where should I look to have my second function grab all the decimals from the input and add them to a list? http://lpaste.net/8804114195755827200
09:27:47 <frerich> paolino: Glad to see you got a grip on it. For what it's worth, I found it by defining two functions g and g' (th latter being just "g' x0 x1 = [x1]") and then running 'quickCheck (\a b -> g a b == g' a b)' and it quickly got me some values where they differ.
09:29:55 <frerich> Retro14: Have a look at the 'span' function which you could use with your 'isNum' like 'span isNum "4235abcdef"', which would yield something like ("4235", "abcdef"). If you don't need the rest of the list, you could also look at 'takeWhile'
09:31:07 <frerich> Retro14: By the way, your "isNum" function could be shortend to 'isNum x = x `elem` "0123456789"'. Or, even nicer, "isNum = isDigit" (isDigit is from Data.Char and does the same as your isNum).
09:31:37 <Retro14> frerich: I know about isDigit, but I want to work without imports for now
09:32:02 <Retro14> But I shall take a look in elem, span and takeWhile :)
09:32:10 <frerich> Retro14: Ah, I see. Another thing you could shorten without importing anything is "or (map isNum xs)", which is the same as "any isNum xs".
09:32:22 <athan> Does anyone have suggestions for high-performance (but trivial) video processing? I'm considering accelerate
09:32:27 <frerich> Retro14: Alright, have fun! :-)
09:36:49 <athan> it looks like hs-ffmpeg is out of date
09:37:58 <voidzero> frerich, how about 'x >=0 && x <=9'?
09:45:01 <tnks> was thinking there'd be a NonEmptyList in Haskell, but I could only find a couple embedded in rouge libraries.
09:45:10 <tnks> is a NEL commonly encoded another way?
09:45:17 <EvanR> good old (a, [a])
09:45:40 <tnks> EvanR: okay, just thinking it might be nice to have TC instances for that.
09:45:46 <EvanR> or data NonEmpty = One a | More a (NonEmpty a)
09:45:53 <EvanR> or there are others
09:45:55 <tnks> right.
09:46:10 <tnks> so is that somewhere?  and I just looked for the wrong name?
09:46:20 <EvanR> theres one in comonad package i think
09:46:53 <tnks> I see one in semigroup
09:46:54 <Faucelme> It's on semigroups
09:47:40 <EvanR> requiring that you have a *list* that happens to be non empty is also a use case for dependent types
09:47:51 <EvanR> then you dont need to have two different types for the list
09:48:35 <EvanR> i.e. along with the list argument you must also provide the first element
09:49:03 <EvanR> (which is indeed the first element of the list0
09:49:25 <Ferdirand> pardon my ignorance, how do you use dependant types for that ?
09:49:25 <Retro14> frerich: I understand the span and takeWhile, I dont understand how I could create the script where as it takes input. http://lpaste.net/4717896625467424768 and this is the error http://lpaste.net/7315707886510800896
09:52:03 <EvanR> head : (xs : List a) -> NonEmpty xs -> a
09:52:35 <EvanR> head is a dumb example but it could be a more interesting function
09:53:45 <EvanR> MkNonEmpty : (x::xs) -> NonEmpty (x::xs)
09:55:41 <EvanR> i messed that up
09:57:38 <phadej> EvanR: I guess people opionions didn't converged, which way is "the best", having one type and refining it with predicates or have multiple types which hold properties by construction
09:57:55 <EvanR> MkNonEmpty : (x : a) -> (xs : List a) -> NonEmpty (x :: xs)
09:58:38 <EvanR> phadej: its similar to division by zero i think, its obvious you dont want to allow zero sometimes but cant be arsed to do anything about it
09:58:52 <foofoo> hi
09:59:06 <foofoo> how can i use quickcheck to get a list of random integers of a fixed size n?
09:59:15 <phadej> EvanR: yeah, zero is very good example!
09:59:36 <phadej> foofoo: is n itself generated?
09:59:53 <foofoo> phadej: no; I supply n
10:00:02 <foofoo> n is fixed
10:00:11 <foofoo> I just want different lists, all of the same length
10:00:28 <enthropy> :t \n -> replicateM n arbitrary
10:00:29 <lambdabot> Arbitrary a => Int -> Gen [a]
10:00:49 <enthropy> quickcheck probably has another name for replicateM
10:00:52 <phadej> foofoo: https://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Gen.html#v:vectorOf
10:01:01 <Iceland_jack> :t vector
10:01:02 <lambdabot> Arbitrary a => Int -> Gen [a]
10:01:21 <Iceland_jack> vectorOf if you have some bespoke generator
10:02:05 <foofoo> thank you! vectorOf was what I needed
10:13:57 <juanpablo___> So I'm writing some Snap code. In here: https://hackage.haskell.org/package/snap-0.14.0.1/docs/Snap-Snaplet-Heist.html#t:SnapletHeist it says I may want to use `Handler b v` instaed of `Handler b b` and indeed I want to do that. It says I can accomplish that with the SnapletHeist monad, but that type is still parameterized by `Handler b b`?
10:14:26 <enthropy> what do people do for tests that call 'getDataFileName'?
10:15:33 <enthropy> the problem being that 'cabal test' uses the data file that's installed in the system, not the one in the repo which is potentially different
10:17:42 <mightybyte> juanpablo___: Hmmm, that documentation is out of date.  SnapletHeist does not allow b v any more.
10:18:05 <juanpablo___> mightybyte: so how do I accomplish the same?
10:18:16 <mightybyte> You can't
10:18:31 <mightybyte> Your splices must be written in Handler b b
10:18:44 <mightybyte> If you need any environment from a different snaplet, you must pass it in as a parameter.
10:19:16 <juanpablo___> mightybyte: oh thanks!
10:19:29 <juanpablo___> I was so confused
10:19:33 <mightybyte> Yeah, sorry.
10:19:37 <mightybyte> I'm correcting the docuentation.
10:19:40 <athan> Anyone here familiar with System-Fc_pro? I'm over on #haskell-in-depth if anyone can clear my eyes
10:20:21 * hackagebot git-annex 5.20150317 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150317 (JoeyHess)
10:20:23 * hackagebot pagarme 0.1.0.0 - Pagarme API wrapper  http://hackage.haskell.org/package/pagarme-0.1.0.0 (diogob)
10:23:25 <juanpablo___> mightybyte: I guess I can ignore my HasHeist instance and just use "with heist" to render my templates, right?
10:23:36 <nkar`> is there a way to expand "No instance for ... plus 16 others" on error via a flag?
10:26:16 <mightybyte> juanpablo___: Sure
10:27:37 <erisco> taruti somewhat like this? https://github.com/erisco/extensible-ast/blob/master/example01/main.hs
10:28:01 <erisco> I have not wrote an extension for the AST but that would be the starting point, I think
10:28:24 <erisco> unfortunately it is cumbersome even to write 5 + 5, but maybe that is inevitable
10:28:43 <erisco> with TH perhaps it can be made much less tedious
10:30:10 <slomo> erisco: you can probably make that more beautiful by implementing a Num instance for your type
10:30:43 <erisco> it will not always be numeric operations though, but it might fit for this example
10:32:30 <Haskellfant> can I use a funptr in a c2hs #fun declaration? {#fun twice as ^ {FunPtr (CDouble -> CDouble)} -> `Double' #} complains that '(' is not allowed
10:33:07 <taruti> erisco: add some lifting functions and the code will be cleaner :)
10:34:27 <Haskellfant> oh nvm I am stupid
10:34:37 <Haskellfant> forgot ` and '
10:35:05 <zipper> Calling haddock on a whole repo can be done via?
10:35:38 <taruti> erisco: fMap :: (f (Fix f) -> t) -> Fix f -> t
10:36:08 <erisco> taruti I'll also try writing an extension first
10:37:25 <taruti> true
10:37:41 <taruti> erisco: the solution will be somewhat different depending on whether you need monads
10:40:53 <cfoch> io/
10:40:55 <cfoch> o/
10:41:05 <cfoch> is there a function GHC.lookupModule ?
10:42:05 <cfoch> forget it
10:44:56 <cfoch> I've just found it
10:45:04 <moghedrin> Can I still use record syntax in GADTs with a constructor that has a class constraint?
10:46:31 <athan> moghedrin: I don't think so :\
10:46:50 <athan> I never got record syntax to work with GADTs before, so I can't claim certainty
10:47:18 <moghedrin> athan: Well, I'll play with it a little more before I throw in the towel, but thanks :)
10:47:37 <athan> moghedrin: np :) I'll do the same
10:48:31 <athan> Yeah no dice for me :\
10:48:42 <moghedrin> athan: I got it to work :)
10:48:51 <athan> :o! Can you lpaste it for me?
10:49:00 <bernalex> how do I write an "instance Foo a Bar => Foo (Baz a, Baz b) Bar", only so that it understands that "Foo b Bar"?
10:49:10 <moghedrin> athan: Aye :)
10:49:35 <athan> bernalex: Hmm? Can you explain more?
10:50:05 <hodapp> today I learned, you're allowed to do: BlahConstructor foo bar baz <- whatever
10:50:23 <hodapp> how I missed this before, I don't know
10:50:28 <bernalex> athan: not really. I have a "Foo a Bar" instance. now I want to write an instance for size 2 tuples, with different types, that are both Foo a Bars.
10:50:41 <kaidelong> well that's what a pattern is and why constructors are special
10:50:43 <EvanR> if BlahConstructor isnt the only constructor then ...
10:51:10 <athan> bernalex: Why not `instance (Foo a Bar, Foo b Bar) => Foo (Bar a, Baz b) Bar`?
10:51:17 <athan> Does that not work?
10:51:18 <moghedrin> athan: http://lpaste.net/127007
10:51:56 <bernalex> athan: with "instance Foo a Bar => (a, b) Bar" you can write "where f = _1 . f", but not "where f = _2 . f", to take a lens example. I need to be able to write "where f = _1 . _2 . f", so both a & b must have instances.
10:52:01 <bernalex> athan: hmm
10:52:29 <athan> moghedrin: That's beautiful!!
10:52:55 <bernalex> athan: you know, I think it might.
10:53:16 <athan> bernalex: It should, instance heads aren't very destructive to existing deducability
10:53:24 <ski> moghedrin : why the `Ord a' constraints on the constructors ?
10:53:28 <athan> if you could whip together an lpaste, I could take a closer look too
10:53:32 <bernalex> athan: of course I learned now that I couldn't do _1 . _2 . f like I would use to though.
10:53:55 <bernalex> athan: it did "work". I can do _1 . f and _2 . f, so both a & b are proper instances like I'd expect them too.
10:54:15 * athan shrugs
10:54:18 <bernalex> but I need a lens-y way to apply the function to both 1 & 2 somehow... and the function is not an Applicative, merely a Functor.
10:54:33 <bernalex> like I would *like* to, not "like I would use to", heh.
10:54:35 <athan> bernalex: Why not fmap? O_o
10:54:37 <bernalex> athan: thanks though!
10:54:43 <athan> np :)
10:55:01 <ski> moghedrin : .. i'd probably try to factor out the constraint, if it would be ok
10:55:09 <athan> bernalex: I'm not sure if you want to extract both, then inline them with composition if you want to map across both at the same time
10:55:16 <bernalex> athan: f = fmap f? because "could not match 'Bar' with '(a, b)'"
10:55:17 <enthropy> bernalex: what's the type of f?
10:55:24 <athan> hmm
10:55:33 <athan> not sure bernalex :\ I'm not lensified yet
10:56:03 <bernalex> enthropy: :: Functor f =>(Maybe Bar -> f (Maybe Bar)) -> (a, c) -> f (a, c)
10:56:38 <bernalex> enthropy: & then I have instance (Foo a (Maybe Bar), Foo b (Maybe Bar)) => Foo (a, b) (Maybe Bar)
10:56:49 <bernalex> where f = ..?
10:56:51 <moghedrin> ski: Honestly, I could, but this project is more testing what I can do with some extensions rather than do anything useful :)
10:57:23 <bernalex> anastas: I want to go from my (a, b) to f'd versions of (a, b) basically.
10:57:27 <hacker> bernalex: that code doesn't make sense 
10:57:28 <bernalex> erm athan ^
10:57:32 <athan> moghedrin: I did some gnarly extension stuff in this project if you're interested
10:57:37 <hacker> er, type
10:57:41 <athan> @hackage dag moghedrin
10:57:41 <lambdabot> http://hackage.haskell.org/package/dag moghedrin
10:58:00 <erisco> taruti well so far this method of extending the AST is working
10:58:03 <erisco> here is the update: https://github.com/erisco/extensible-ast/blob/master/example01/main.hs
10:58:25 <bernalex> athan: I have this working instance for non-tuples (just Bazs): "instance Foo a (Maybe Bar) => Foo (Baz a) (Maybe Bar) where f g (Baz a b) = Baz <$> f g b"
10:58:26 <athan> bernalex: Now that's cool! I'm not sure though
10:58:29 <jophish> I'm about to ask to do the next project at work in Haskell. Any words of advice before I do this?
10:58:48 <EvanR> may the types be with you
10:58:53 <ski> moghedrin : so, i'm wondering why you have constraints on two constructors, but not the third ..
10:58:56 <erisco> I think what is becoming evident is not only does the AST need to be extensible but so does the compiler, which in the example is just an interpreter
10:59:01 <bernalex> athan: now I want the tuple to just do that too both members of it.
10:59:05 <athan> jophish: Use it or loose it :v
10:59:09 <athan> lose*
10:59:18 <bernalex> hacker: which type?
10:59:27 <jophish> Perhaps I'll give time estimates for Haskell and C++
10:59:29 <bernalex> s/too/to/
10:59:36 <jophish> we're writing a compiler! Haskell!
10:59:37 <athan> bernalex: So... mapping an fmap to it's constiutuent elements?
10:59:45 <hacker> bernalex: Functor f => (Maybe Bar -> f (Maybe Bar)) -> (a,c) -> f (a,c)
10:59:46 <athan> Something like `(a,b) -> (f a, f b)`?
10:59:46 <bernalex> jophish: I would not ask, I'd just do it. ;)
10:59:48 <erisco> noting that I had to repeat logic from evalSimpleExpr in evalExtendedExpr
11:00:04 <ski> moghedrin : and my inner compiler is asking about why we're storing the (same) instance constraint with every application of those constructors in a tree, rather than storing it only once ("at the top")
11:00:13 <bernalex> hacker: why not?
11:00:26 <bernalex> athan: I uh think. I don't really know lens or what I'm doing either. :p
11:00:26 <oconnore2> where can I read about the rules for haskell line breaks?
11:00:54 <bernalex> athan: I think I want what Control.Lens.both does, but I only have a measily Functor...
11:00:56 <hacker> bernalex: you'd need to either be able to get a Maybe Bar out of (a,c) or similar
11:01:03 <jophish> bernalex: I've already started at home :)
11:01:07 <oconnore2> my googling isn't working out
11:01:12 <athan> ski: *checks `refl` on literally everything*
11:01:23 <jophish> athan: say I'll quit if I can't do it in haskell?
11:01:24 <bernalex> hacker: -_o_- that's TH generated lens stuff.
11:01:42 <moghedrin> ski: Because I'm a nub, probably - is there a way to store it at only the top of the type declaration?
11:01:45 <athan> jophish: I feel like you can, one sec
11:01:57 <hacker> ah well, I missed a part of this conversation then, nevermind
11:02:04 <athan> :t fmap pure (undefined :: (a, b))
11:02:05 <lambdabot> Applicative f => (a1, f a)
11:02:14 <athan> hmm
11:02:21 <jophish> athan: well, I'm leaving in May anyway. I don't think that would hold much weight
11:03:05 <enthropy> bernalex: what do you do if both elements of the tuple have a Bar?
11:03:06 <bernalex> athan: oh. both is for the same type anyway. but I don't have a ~ b, so I couldn't use both anyway.
11:03:25 * athan flips a coin
11:03:35 <athan> not sure :\
11:03:48 <EvanR> heads
11:03:49 <JoaoPortela> Hi! Any of you guys doing google summer of code? I was thinking of (maybe) doing it in haskell. Any usefull tips? Application templates for I/O?
11:04:17 <jophish> JoaoPortela: there's a thread on /r/haskell about this
11:04:23 <jophish> I've not looked at it though
11:04:23 <enthropy> JoaoPortela: what does an application template for I/O look like?
11:04:27 <bernalex> enthropy: I'm not sure what you mean. they should have bars. the instance I'm trying to write is basically for a a tuple of 'Foo a (Maybe Bar)'s, where a might be different. does that help? I'm sorry for explaining poorly.
11:04:32 <mpickering> JoaoPortela: #haskell-gsoc
11:04:49 <JoaoPortela> jophish, totally missed it. gone look it up now.
11:05:46 <enthropy> bernalex: I have a feeling you might be writing an illegal lens if your lens (potentially) modifies two values
11:05:57 <bernalex> enthropy: maaaybe
11:05:59 <bernalex> :p
11:06:26 <JoaoPortela> enthropy, for what I understand the I/O part of gsoc tends to be quite similar, so I thought that someone might already have a base template taht you just adapt (and add the actual solution to :p).
11:06:41 <JoaoPortela> mpickering, thanks.
11:06:51 <enthropy> bernalex: but I guess you can make the choice that "I'll give you no value back if there are two I have to choose from"
11:07:35 <ski> moghedrin : yes. make two types. both your current `DivTree', with the `Ord a =>' parts removed. and a new `data TopDivTree :: * -> * where Top :: Ord a => DivTree a -> TopDivTree a' (the `:: * -> *' can be `a', if you prefer). rename them if you please
11:07:36 <JoaoPortela> OMG!
11:08:05 <JoaoPortela> I meant code jam. this is embarasing, that's why you didn't understad what i was saying. lol
11:08:25 <clrnd> still no idea what a IO template is
11:08:47 <ski> moghedrin : of course. this will mean that now you also need `Ord a' to build a `Top Leaf', which wasn't the case before. but possibly this is no big deal
11:09:10 <enthropy> clrnd: sounds like a template document for a project proposal
11:09:28 <ski> (moghedrin : you're replaced having zero or more `Ord a' constraints embedded inside any single `DivTree a' tree to having a single `Ord a' constraint embedded inside any single `TopDivTree a' treE)
11:09:29 <JoaoPortela> enthropy, no. I meant code jam. so sorry.
11:09:47 <ski> moghedrin : makes sense ?
11:09:59 <bernalex> enthropy: to be concrete: I have some old db code here. each table has a rubbish row. now there's lens code in place for dealing with any type of 'rubbishable' thing. however, there are a couple of special things in here. namely attributes. such as UserAttribute. a UserAttribute has a connection to a User. and when a User is rubbished, all its UserAttributes are rubbished as well. so the deletion code wants
11:10:01 <bernalex> to test this like a tuple of [User, [UserAttribute]]. this means it needs instances for rubbishable-ish-stuff for both a, [a] and (a, b). I might rewrite it all. heh.
11:13:11 <JoaoPortela> (my face is totally red right now, I meant code jam. I should have said: ) Hi! Any of you guys doing google code jam? I was thinking of (maybe) doing it in haskell. Any usefull tips? Application templates for the I/O part?
11:13:57 <moghedrin> ski: I understand the details, but I don't really understand the advantage of doing it that way. What benefits will doing it that way provide over how I currently have it?
11:14:48 <arkeet> JoaoPortela: for simple I/O like that you could use interact
11:14:50 <arkeet> :t itneract
11:14:51 <lambdabot>     Not in scope: ‘itneract’
11:14:51 <lambdabot>     Perhaps you meant one of these:
11:14:51 <lambdabot>       ‘interact’ (imported from Prelude),
11:14:52 <arkeet> :t interact
11:14:53 <lambdabot> (String -> String) -> IO ()
11:15:02 <arkeet> just provide it a function from input to output
11:15:23 <JoaoPortela> arkeet: thanks, I'll look into it.
11:15:29 <arkeet> @src interact
11:15:29 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:15:37 <arkeet> it's pretty simple.
11:16:27 <arkeet> maybe it's convenient to just do getLine a bunch though.
11:17:00 <JoaoPortela> I guess all I need to know is here https://wiki.haskell.org/Tutorials/Programming_Haskell/String_IO right?
11:17:03 <ski> moghedrin : i don't know. i was just thinking it seemed perhaps a little wasteful to replicate the constraint like that
11:17:22 <ski> moghedrin : i don't really know why you're attaching the constraint to the data type in the first place ..
11:17:25 <arkeet> JoaoPortela: looks good.
11:17:54 <jophish> He say's he'll have a think about it
11:18:22 <arkeet> JoaoPortela: and for splitting up the input, `lines` and `words` are probably very useful.
11:18:49 <moghedrin> ski: As far as I can tell, it's only to avoid duplicating the constraint in other places. Looking at it, there's not a lot of reason for me to have been doing it.
11:18:49 <arkeet> > map words . lines $ "a b\nc d"
11:18:50 <lambdabot>  [["a","b"],["c","d"]]
11:18:56 <jophish> he's concerned that after I leave he won't be able to hire anyone who know's haskell
11:19:29 <arkeet> jophish: tell him to hire me ;-)
11:19:51 <jophish> In the UK, arkeet?
11:19:57 <arkeet> nah, that's a bit far.
11:20:05 <jophish> I'll ask anyway :_)
11:20:10 <arkeet> I'm not serious.
11:20:19 <JoaoPortela> arkeet, yup.
11:20:26 <arkeet> I'm not about to leave my current job.
11:20:54 <JoaoPortela> I'm trying to see if I can filter their solutions by language to get a look at more examples. :)
11:20:54 <enthropy> let x = True in $(lamE [varP =<< newName "x"] (dyn "x")) False
11:22:05 <enthropy> is there a "pretty" way to make NameU names not get captured by NameS?
11:22:30 <enthropy> ie. make that expression above evaluate to True
11:22:55 <enthropy> the ugly way is to pass a long and "unique" string to newName
11:23:32 <JoaoPortela> found it: http://www.go-hero.net/jam/14
11:25:04 <ski> moghedrin : ok. i just wanted to raise the possibility
11:40:20 <bernalex> gah. someone with an awake brain, pls halp.
11:40:38 <njkdfg> wot?
11:40:51 <bernalex> I have [(a, [b]), and want to apply a function that takes [a]s too every a and every b
11:41:14 <ReinH> bernalex: what's the type of that function?
11:41:15 <bernalex> uh sorry I have [(a, [a])]
11:41:30 <bernalex> let me at least remotely get my brain working here
11:41:31 <ReinH> and what's the type of the function you want?
11:42:01 <bernalex> ReinH: the function is [a] -> [a] -> Bool. then I have a function that is [(a, [b]) -> [(a, [b])] -> Bool.
11:42:20 <bernalex> ReinH: the latter should basically call the former on every a and b
11:42:27 <ReinH> How would it work on b's?
11:42:44 <bernalex> the full types include some typeclasses
11:42:53 <ReinH> Uh.
11:42:54 <bernalex> (=^=) :: (HasRubbish a (Maybe UTCTime), ToJSON a) => [a] -> [a] -> Bool
11:42:58 <bernalex> (=^^=) :: (HasRubbish a (Maybe UTCTime), HasRubbish b (Maybe UTCTime)
11:43:00 <bernalex>           ,ToJSON a, ToJSON b)
11:43:02 <bernalex>        => [(a, [b])] -> [(a, [b])] -> Bool
11:43:15 <njkdfg> so i guess you have to call the first function on the sets [a] and on each set of [b]?
11:43:19 <bernalex> yeah
11:43:23 <ReinH> Well, that information makes the task not impossible, so it's sort of important
11:43:31 <bernalex> ReinH: :-P
11:43:53 <dredozubov> Can i somehow use lenses w/o screwing aeson generics?
11:44:03 <bernalex> njkdfg: presently it's '(fst <$> a) =^= (fst <$> b)', which means it only works on the as, but there's probably an elegant way to make it work on the bs too.
11:44:03 <njkdfg> bernalex: are a and b instances of the same typeclasses used in the constraints?
11:44:05 <dredozubov> Do we have a TH crutch for this at least?
11:44:25 <bernalex> njkdfg: yes
11:45:26 <njkdfg> bernalex: you get a Bool and a [Bool] from this
11:45:31 <njkdfg> do you know how to combine these?
11:46:09 <njkdfg> running the first function through a list of [b] will get you a Bool for each [b]
11:46:21 <njkdfg> then u have to combine them with the bool from a somehow
11:46:28 <njkdfg> do you have the logic for this?
11:46:34 <bernalex> njkdfg: make them one list & then use 'foldr (&&) True' or something.
11:46:41 <dredozubov> oh, deriveJSON will make it go away
11:46:52 <njkdfg> whats the logic in english? and them all together?
11:46:54 <johnw> bernalex: you mean, 'all'?
11:46:58 <bernalex> njkdfg: yep
11:47:03 <njkdfg> cause you can or them all together as well
11:47:08 <njkdfg> okay
11:47:16 <njkdfg> yeah
11:47:54 <njkdfg> do what you have and - && (all ...)
11:48:10 <bernalex> njkdfg: what do you mean?
11:48:50 <njkdfg> 1 sec
11:50:37 <mniip> @src all
11:50:37 <lambdabot> all p = and . map p
11:50:50 <mniip> @src and
11:50:50 <lambdabot> and  = foldr (&&) True
11:50:50 <njkdfg> just go through the lists and apply the function to each pair of [b] to get a list - [Bool]
11:51:01 <johnw> ah, right, and
11:52:28 <njkdfg> I think since you have to generate a list and then and it, both of those can be comibined with an 'all'
11:52:41 <cfoch> Hello
11:52:52 <cfoch> by installing GHC does it install Haddock?
11:53:10 <mmachenry> cfoch: Nope
11:53:23 <mmachenry> cfoch: "cabal install haddock"
11:53:33 <cfoch> I am trying to install Haddock from its source code
11:53:36 <cfoch> but I get
11:53:47 <cfoch> http://fpaste.org/199097/16377142/
11:54:02 <cfoch> I have GHC 7.8.4
11:54:20 <cfoch> I don't know if there are some conflicts or why I get this message
11:54:57 <bernalex> njkdfg: oh. I didn't pay attention to what you wrote
11:54:58 <bernalex> I did this lol
11:55:00 <bernalex> a =^^= b = and $ ((fst <$> a) =^= (fst <$> b)) : zipWith (=^=) (snd <$> a) (snd <$> b)
11:55:25 <zipper> How do I make haddock generate docs for a whole repo in one command?
11:56:47 <turtil> /buffer close
11:57:16 <cfoch> cabal haddock (?)
11:59:45 <njkdfg> bernalex: yeah I guess that would work, though it might be nicer with pattern matching on the left
12:00:22 * hackagebot gitrev 1.0.0 - Compile git revision info into Haskell projects  http://hackage.haskell.org/package/gitrev-1.0.0 (AdamFoltzer)
12:03:33 <hexagoxel> cfoch: you probably need to install haddock-api from source as well
12:06:31 <cfoch> ahh
12:07:28 <braup> hello, I'm trying to make a function that counts decimals in a String, it has to return a [Int] with the found decimals. the tricky part is that decimals are integers directly behind eachother. I'm trying to use a guard to accomplish this but don't think that it'll work out. can anyone help me?
12:07:45 <braup> this is my attempt: http://lpaste.net/3920703845826560
12:07:58 <hexagoxel> cfoch: and haddock-library, it seems :D
12:08:47 <hexagoxel> (and ghc-7.10)
12:08:57 <cfoch> yes... I was about saying that...
12:09:03 <cfoch> I have 7.8.4
12:09:29 <hexagoxel> i just checked; after adding sandboxes and using 7.10 the install plan is found successfully
12:09:38 <hexagoxel> s/sandboxes/add-sources/
12:10:39 <email> braup: Can you give an example of the input? I'm still learning as well but would like to see if I can manage it.
12:11:34 <fizruk> braup: you might want to take a look at wordsBy function from Data.List.Split
12:11:35 <braup> email: getDecimals "asd56fde89gh1" should give the result 3
12:12:14 <hexagoxel> cfoch: you can download the latest rc3 (still fresh, from today i think), set it up anywhere (like, somewhere in your home dir) and use `cabal install -w $path-to-ghc-7.10-binary`
12:12:49 <email> braup: You mean ouput is [56,89,1] ?
12:13:03 <braup> email: uh yeah exactly, sorry
12:13:22 <fizruk> > length . wordsBy (not . isDigit) $ "asd56fde89gh1"
12:13:23 <lambdabot>  3
12:13:31 <arkeet> > wordsBy (not . isDigit) $ "asd56fde89gh1"
12:13:32 <lambdabot>  ["56","89","1"]
12:13:43 <arkeet> although that's probably cheating if it's homework or something.
12:14:17 <arkeet> > map (read :: String -> Int) . wordsBy (not . isDigit) $ "asd56fde89gh1"
12:14:18 <lambdabot>  [56,89,1]
12:15:06 <arkeet> :t groupBy
12:15:07 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:18:07 <zipper> cfoch: Let me try that
12:19:02 <cfoch> hexagoxel: do you use linux? what distro?
12:19:11 <hexagoxel> cfoch: arch
12:21:12 <hexagoxel> (and sorry for assuming; i have no experience in using a non-platform ghc on a non-linux system; might be a bit harder to set up, dunno)
12:30:10 <juanpablo___> In Snap. I'm working with a handler of type "Handler App (AuthManager App) ()". How do I get the App from there? It doesn't have a instance of MonadState so it doesn't work :(
12:30:43 <mightybyte> juanpablo___: It has a MonadReader
12:31:25 <juanpablo___> mightybyte: oh god I feel so dumb now lol thank you very much.
12:32:07 <mightybyte> juanpablo___: Actually, it does have a MonadState.
12:32:18 <juanpablo___> mightybyte: but how do I use it?
12:32:20 <mightybyte> But both the state and the reader operate on the v.
12:32:34 <juanpablo___> I'm getting `No instance for (Control.Monad.Reader.Class.MonadReader
12:32:34 <juanpablo___>                    App (Handler App (AuthManager App)))`
12:32:44 <mightybyte> To get to the b, you need to use the MonadSnaplet functions.
12:32:54 <mightybyte> withTop' id ask
12:34:47 --- mode: ChanServ set +o shapr
12:35:02 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!' by shapr
12:35:07 * shapr cackles happily
12:35:11 --- mode: shapr set -o shapr
12:40:23 * hackagebot haskell-neo4j-client 0.3.0.13 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.13 (asilvestre)
12:42:35 <cfoch> hexagoxel: thanks
12:42:37 <cfoch> I could install it
12:42:51 <JLJ1> hey all
12:44:31 <cfoch> o/
12:45:56 <arkeet> @let filterGroup p = filter (p.head) . groupBy ((==) `on` p)
12:45:58 <lambdabot>  Defined.
12:46:12 <arkeet> > filterGroup isDigit "asd56fde89gh1"
12:46:13 <lambdabot>  ["56","89","1"]
12:48:35 <erisco> taruti there is a beautiful, nearly mechanical way to write the evaluators extensibly ... this is promising :D
12:48:40 <arkeet> I love using groupBy with non-transitive relations.
12:49:20 <arkeet> > groupBy (const id) [False,True,False,True,True,False,False,True]
12:49:21 <lambdabot>  [[False,True],[False,True,True],[False],[False,True]]
12:50:24 * hackagebot applicative-fail 0.0.1 - Applicative functor which collects all your fails  http://hackage.haskell.org/package/applicative-fail-0.0.1 (AlekseyUymanov)
12:53:37 <erisco> applicative-fail 0.0.2 ADD: fails are now posted to your YouTube channel
12:53:40 <arkeet> I like how the author of that library uses Constructor{}, with no space between the constructor and the {}
12:54:17 <arkeet> unfortunately he puts parenthese around them anyway.
12:54:40 <arkeet> the point of not putting a space is to emphasize that record syntax binds tighter than function application.
12:54:41 <Iceland_jack> arkeet: Writing Constructor{} is pretty common
12:54:54 <arkeet> I mean as opposed to Constructor {}
12:54:58 <NikolajK> @djinn: (a->b)->a
12:54:59 <lambdabot> -- f cannot be realized.
12:55:10 <arkeet> @djinn a->(b->a)
12:55:11 <lambdabot> f a _ = a
12:55:23 <Iceland_jack> Yeah
12:55:31 <NikolajK> where is the lambdabot again?
12:55:44 <arkeet> right here.
12:55:57 <NikolajK> I mean how to I talk with him privately?
12:56:04 <arkeet> /msg lambdabot 
12:56:05 <osa1> does --ghc-options=... part apply to dependencies too?
12:57:38 <arkeet> good question.
12:58:03 <erisco> I hope haddock takes function argument docs on the following line, because I am out of room on a single line
12:58:30 <arkeet> osa1: you can find out by giving it some option that makes it obvious.
12:58:34 <arkeet> like -v maybe.
12:59:42 <nvez-> hi everyone
12:59:53 <nvez-> data Entry = Entry {word       :: Word,                     definition :: Definition}              deriving (Eq, Show)
13:00:07 <nvez-> I'm not really understanding what this line "defines".. can someone let me know what part of Haskall can I read docs under?
13:00:09 <nvez-> *haskell
13:01:05 <Denommus> nvez-: it defines a new record type
13:01:18 <nvez-> We're defining a type here but the { .. } part means that it's a combination of two items in that type?
13:01:27 <arkeet> it is sugar for
13:01:31 <arkeet> data Entry = Entry Word Definition
13:01:35 <arkeet> and defining two functions
13:01:38 <arkeet> word :: Entry -> Word
13:01:42 <arkeet> definition :: Entry -> Definition
13:02:11 <nvez-> oh i see
13:02:19 <arkeet> in the report, see https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
13:02:20 <ChristianS> nvez-: that specific stuff is explained in https://wiki.haskell.org/Algebraic_data_type and http://en.wikibooks.org/wiki/Haskell/Classes_and_types#Deriving
13:02:22 <arkeet> under Labelled FIelds
13:02:44 <nvez-> I'll read these 3 pages and hopefully it'll clear up some more, I just wanted to know what to look for
13:03:03 <nvez-> thanks ChristianS and arkeet 
13:03:10 <Denommus> nvez-: it's more or less equivalent to a C struct
13:03:28 <nvez-> That's what I seem to be getting at
13:03:44 <ChristianS> nvez-: generally, "learn you a haskell" is a good intro book
13:06:18 <nvez-> ChristianS: i was on this exact page.. http://learnyouahaskell.com/making-our-own-types-and-typeclasses :P
13:10:24 * hackagebot llvm-general-pure 3.4.5.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.5.0 (BenjaminScarlet)
13:10:26 * hackagebot llvm-general 3.4.5.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.5.0 (BenjaminScarlet)
13:11:38 <frerich_> Does anybody know how to use template haskell via quasi quotation? The manual page at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html mentions that there’s a “d” quoter which can be used to get a Q [Dec], but I don’t see that quoter available anywhere. I see that there’s a “quoteDec” at http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Quote.html but I don’t quite get
13:11:39 <frerich_> to use that.
13:12:03 * frerich_ has only very little experience with quasiquoting, outside of what HTML templating libraries do.
13:17:57 <solarus> isn't the d quoter simply [d| stuff goes here |] ?
13:18:05 <solarus> or what is the question? :)
13:20:24 * hackagebot llvm-general-pure 3.3.14.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.14.0 (BenjaminScarlet)
13:20:26 * hackagebot llvm-general 3.3.14.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.14.0 (BenjaminScarlet)
13:21:00 <napping> edwardk: explain seems pretty baked-into Trifecta. Is there actually any way to add your own annotations to the careted line in the default error message, or do you have to use footnotes?
13:24:50 <frerich> solarus: Right, the issue is — ‘d’ is not in scope, according to GHC. Some sample code is at http://lpaste.net/127015 — all other cases seem to pull in ‘d’ by just importing Language.Haskell.TH
13:25:24 * hackagebot persistent 2.1.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.2 (MichaelSnoyman)
13:29:00 <solarus> frerich: think you need TemplateHaskell as well
13:29:23 <solarus> or is it implied by quasiquotes?
13:29:40 <frerich> Hm, really? I thought that’s only needed by the code which makes use of the function yielding a ‘Q a’.
13:29:46 <frerich> I.e. which wants to make use of the splice.
13:30:15 <Mgic> Does anyone know a better way to do this? I'm supposed to be able to turn this function into a pipeline, but my approach just feels sort of ugly (from the cis194 homework 4): http://lpaste.net/127016
13:30:24 <frerich> solarus: It seems you’re right though! At least I get a different error now, thanks! :-)
13:31:26 <glguy> Mgic: It looks like those two functions should give different answers for most inputs
13:33:44 <Mgic> You're right, it's pretty bad :p
13:34:33 <Mgic> I just don't know what I should be looking for
13:34:49 <glguy> Mgic: As you seem to have observed, that function sums some of the lists of a sequence of numbers that it generates
13:35:00 <glguy> of the list of*
13:35:05 <Cale> Mgic: You only want to add up the even n's
13:35:57 <Mgic> so I should add a filter before the iterate then?
13:36:07 <Mgic> I guess that works
13:43:08 <Mgic> I added a filter, and it works. Thanks! Is if there is a more idiomatic way to do it though? The if-then-else seems necessary. http://lpaste.net/127016
13:44:09 <ChristianS> Mgic: nothing wrong with using if-then-else there imho
13:44:42 <ChristianS> Mgic: though i don't know what "not quite correct but working" is supposed to be
13:46:00 <Mgic> Okay, thanks.
13:46:14 <Mgic> it's working, I just forgot to change the comment.
13:48:02 <athan> Hey guys, I've got a difficult problem if anyone wants to help me consider - I'm trying to make a "unique" list of elements, by indexing a list type with it's list of elements. My main issue is that my GADT is turning my constructors into painful type-level messes, where I can't deconstruct the list because I can't "undo" the type-level computations in my index
13:48:07 <funfunctor> is State/ReaderT something I should ultimately best avoid?
13:48:25 <athan> is there a straightforward way to make the list constructors both injective & surjective, while still having type-level computation?
13:49:29 <pavonia> funfunctor: And use what instead?
13:49:29 <athan> Here be what I mean, you skervy dogs: http://lpaste.net/127021
13:49:33 <roboguy_> athan: a bijective constructor for a finite type?
13:49:44 <athan> roboguy_: I believe so
13:49:48 <WigglesMcMuffin> Is there any alternative to storing printf if I wanted to do string manipulation type things? Basically I wanted to get hex numbers that "were pairs (i.e. 0c, and 02)". Which worked if I wanted to say "let thing = printf ...", but that'd break as soon as I did say take 3 $ repeat thing. What's the better alternative for that?
13:50:00 <athan> Wouldn't each `Cons` cell of a normal list be bijective?
13:50:09 <athan> (even though it's a recursive type?)
13:50:10 <roboguy_> athan: wouldn't that say that you can have an isomorphism between lists of different sizes?
13:50:30 <funfunctor> pavonia: I'm not sure, I don't want to litter MVar's everywhere, I feel my design maybe needs a rethink
13:50:43 <athan> roboguy_: I only want an isomorphism between the "outside" of a cons cell and it's contents, not hte list itself
13:50:50 <hexagoxel> Mgic: you can omit the parens around if/else expressions
13:51:06 <athan> S.T. I can pattern-match on my cons cell
13:52:02 <athan> roboguy_: If you look at `ExMethods` in my example, I wouldn't be able to pattern match on my Cons-cells, would I?
13:52:02 <pavonia> funfunctor: MVars are for multi-thread code, so if you can use Reader or State, I'd prefer that
13:52:08 <WigglesMcMuffin> In truth, this was for a codewars kata. I ended up solving it another way, but I'm really puzzled as to why it didn't work that way, and how I'd get something like that to work
13:52:13 <athan> because it wouldn't be obvious how to deconstruct the list type?
13:52:56 <funfunctor> pavonia: code is multithreaded
13:53:01 <pavonia> WigglesMcMuffin: What do you mean by the "take 3 $ repeat thing" here?
13:53:31 <roboguy_> athan: you can't match on it at a value level?
13:53:33 <pavonia> funfunctor: And several threads have to access the same state?
13:53:44 <funfunctor> pavonia: I sort of need someone to bounce my mind back and forth with for a while
13:53:53 <athan> roboguy_: Nope, skolem type variable :\
13:54:02 <funfunctor> good question,  in this case yes
13:54:12 <athan> Maybe if I declared that value-level pattern matching would return the tail of the type-level list, I could get away with it
13:54:14 <WigglesMcMuffin> pavonia: 'take 3 $ repeat foo; where foo = printf "%02x" (12::Int)'
13:54:17 <roboguy_> athan: hmm, I can...
13:54:19 <funfunctor> I know about STM also
13:54:23 <athan> o_o
13:54:26 <roboguy_> maybe my example is too simple
13:54:33 * athan rage fists to posiedon
13:54:36 <WigglesMcMuffin> I had said "let thing =" earlier, which was probably just a bad variable name :D
13:55:03 <pavonia> WigglesMcMuffin: An what is wrong with that?
13:55:22 <pavonia> > take 3 $ repeat foo where foo = printf "%02x" (12::Int)
13:55:23 <lambdabot>  <hint>:1:21: parse error on input ‘where’
13:55:36 <pavonia> > let foo = printf "%02x" (12::Int) in take 3 $ repeat foo
13:55:37 <lambdabot>  No instance for (GHC.Show.Show a0)
13:55:37 <lambdabot>    arising from a use of ‘M678120019294980635514808.show_M6781200192949806355...
13:55:37 <lambdabot>  The type variable ‘a0’ is ambiguous
13:55:57 <pavonia> O.o
13:55:57 <funfunctor> pavonia: do you have about 20min to spare so I can explain things properly?
13:56:10 <athan> roboguy_: Did you have to remove the head of the list at the type level to pattern match?
13:56:22 <athan> ie: the type reduction can't be inferred?
13:56:47 <pavonia> funfunctor: I have, but not sure I'm the best one to ask about multithreading
13:56:56 <funfunctor> ah ok
13:57:34 <athan> also on an awesome note, this list-level indexing of a value list preserves type-safety of `head` & `tail` et al :)
13:57:49 <funfunctor> this thing is fairly complicated to design. Abstraction that is very OO is hard in FP
13:58:04 <roboguy_> athan: well, maybe my test is too simple, but I just tried something like: test (GETCons a b) = 1; test (PUTCons a b) = 2
13:58:22 <WigglesMcMuffin> pavonia: it dun work. I was attempting to put an example together to prove it, but you seem to have broken it sufficiently in my absence :D
13:58:24 <athan> roboguy_: watch if you return `b` :)
13:58:28 <pavonia> funfunctor: Thinking about it, I'm not even sure you can use State with several threads. I had a problem like that with a Gtk program where I wanted to use StateT everywhere which didn't work
13:58:39 <athan> you'd need an explicit signature then
13:59:01 <roboguy_> oh I see
13:59:02 <EvanR> funfunctor: is it that RF driver, the issue isnt FP or OO, the underlying complexity is the goal of exposing literally anything an external device can do which itself already has a really complex api
13:59:11 <EvanR> OO doesnt make that go away
13:59:48 <EvanR> simplifying assumptions can make it go away
13:59:54 <funfunctor> EvanR: well the RF driver is in place now, admittedly not as gracefully as I once imagined but it works
14:00:08 <funfunctor> I'm further up the stack now
14:02:06 <funfunctor> EvanR: i'll commit what I have, 1sec
14:04:00 <biglama> hi guys, do you have any idea on how to generate the sequence [1,-1,1,-1...] ?
14:04:12 <EvanR> homework?
14:04:17 <biglama> I know how to do it as Floating, but not as integer
14:04:25 <biglama> nope, just need it in my code :p
14:04:37 <EvanR> how do you do it ith floating
14:04:47 <biglama> [(1)**i | i <- [1..n]]
14:04:51 <biglama> sorry
14:04:54 <biglama> [(-1)**i | i <- [1..n]]
14:05:00 <EvanR> nice
14:05:06 <roboguy_> athan: I can do it if I give it an explicit type
14:05:07 <EvanR> > (-1)^1
14:05:08 <lambdabot>  -1
14:05:10 <EvanR> > (-1)^2
14:05:11 <lambdabot>  1
14:05:30 <biglama> EvanR: d'oh :(
14:05:33 <biglama> thanks :)
14:05:36 <funfunctor> EvanR: this is the transceiver I wrote https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs there is a UDP socket for control commands much like a REPL. I parsed those commands using Attoparsec, now the dispatching is the part I am stuck with
14:05:54 <roboguy_> > cycle [1, -1]
14:05:56 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
14:06:10 <mniip> > iterate negate 1
14:06:11 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
14:06:28 <funfunctor> EvanR: I need to dispatch to actions in the RadioInterface record here https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioInterface.hs and they ofcourse expect me to pass which radio interface I should be using.
14:06:51 <biglama> roboguy_, mniip : really nice 
14:07:11 <biglama> i must be either stupid or tired not to have thought about cycle
14:07:17 <funfunctor> EvanR: example usage is currently in main for testing https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Main.hs
14:08:01 <SrPx> Hello, is there a list of generic typeclasses? For example, is there a generic for binary serialization and for databases?
14:08:06 <ReinH> funfunctor: Do you expect those control commands to be actually received?
14:08:34 <funfunctor> ReinH: sorry, how do you mean?
14:08:52 <ReinH> funfunctor: Well, you're using UDP, so if you expect any of the commands to actually be received then you're going to have a bad time.
14:09:19 <funfunctor> ReinH: well technically its on a localhost so it should be ok
14:09:20 <biglama> now, is there a way to avoid list comprehensions to generate [1,-2,3,-4..] ?
14:09:33 <ReinH> funfunctor: famous last words :)
14:09:44 <biglama> I [i*j | i <- take 10 $ cycle [1,-1], j <- [1..10]]
14:09:44 <kadoban> SrPx: binary serialization, there's Data.Binary's Binary. I haven't used it beyond toys, but it seemed nice.
14:09:48 <ReinH> funfunctor: You can use a sum type to describe the commands, then use pattern matching to dispatch
14:09:52 <biglama> (minus the I)
14:09:53 <roboguy_> athan: to return the b, you need to "pop" the last type off the type "stack" and that seems to work for me
14:09:54 <mniip> > zipWith (*) [1..] $ iterate negate 1
14:09:56 <lambdabot>  [1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-24,...
14:09:57 <SrPx> kadoban: ty!
14:10:11 <funfunctor> ReinH: the current implementation uses this abstraction in its transceiver so this allows me to test my haskell implementation in a otherwise much large complex system
14:10:22 <funfunctor> ReinH: i'm just implementing Layer0
14:10:28 <biglama> mniip: thanks a bunch !
14:10:34 <mniip> > iterate (
14:10:35 <ReinH> funfunctor: o_O for... fun?
14:10:36 <lambdabot>  <hint>:1:10:
14:10:36 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:10:36 <WigglesMcMuffin> mniip: doh!! That's so simple. Much to learn I have
14:10:36 <mniip> err
14:10:44 <biglama> i have trouble not using list comprehensions :(
14:10:54 <funfunctor> ReinH: yes
14:10:55 <augur> is there a good way to do multi-line string literals? something compatible with overloaded strings
14:10:56 <WigglesMcMuffin> biglama: You and me both
14:11:07 <mniip> > iterate (\x -> -x - signum x) 1
14:11:08 <lambdabot>  can't find file: L.hs
14:11:08 <funfunctor> ReinH: what is this sum data type?
14:11:10 <mniip> > iterate (\x -> -x - signum x) 1
14:11:14 <lambdabot>  [1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-24,...
14:11:28 <ReinH> funfunctor: a sum is like data SumType = A | B | C | D
14:11:35 <ReinH> e.g., Either
14:11:45 <funfunctor> ReinH: oh right, well I already have that see the above code
14:11:48 <ReinH> > iterate negate 1
14:11:51 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
14:11:54 <mniip> > iterate ((-) <$> negate <*> signum) 1
14:11:59 <lambdabot>  [1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-24,...
14:12:00 <Iceland_jack`> > cycle [1,-1]
14:12:07 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
14:12:11 <funfunctor> ReinH: https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs#L143
14:12:29 <ReinH> funfunctor: Ah. Then where are you running into trouble?
14:12:29 <funfunctor> ReinH: and the pattern match is here https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs#L185
14:12:36 <SrPx> kadoban: <3 Data.Binary
14:12:46 <kadoban> SrPx: Seems pretty cool, right? :)
14:12:48 <ReinH> funfunctor: That's not pattern matching. You should use pattern matching.
14:13:13 <ReinH> A case statement seems appropriate
14:13:28 <funfunctor> ReinH: well that does not matter for the moment..
14:13:35 <SrPx> kadoban: yep. It doesn't actually support deriving but has a script so that's close enough
14:13:41 <ReinH> funfunctor: It doesn't matter, but there's no reason to not do the right thing instead of the wrong thing
14:14:02 <ReinH> Bad software is the result of lots of bad decisions, after all.
14:14:06 <SrPx> kadoban: nevermind, the script is 404. </3 want my money back
14:14:12 <kadoban> Lol
14:14:40 <funfunctor> the primary issue is, RadioInterface actions https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioInterface.hs#L105 expect to know what radio interface they are going to use upon dispatch
14:14:46 <SrPx> we need more generics :/
14:14:53 <f|`-`|f> Uh
14:14:55 <f|`-`|f> Oleg's papers?
14:14:58 <f|`-`|f> :)
14:15:07 <funfunctor> ReinH: i'm not spending time messing with guards vs case statements when I could delete it all 2min later
14:15:14 <funfunctor> its irrelevant
14:16:33 <f|`-`|f> hum, do really know that
14:16:51 <roboguy_> funfunctor: would be a good idea for next time though. Less code, no Eq instance needed
14:17:36 <ReinH> I personally believe that all the decisions we make while programming affect the quality of the final program, so I don't think it's irrelevant at all. But then, that's an argument for another time.
14:17:37 <funfunctor> roboguy_: this isn't my question at all..
14:18:10 <ReinH> funfunctor: Maybe you could tell us what your question is, rather than what it isn't.
14:18:13 <roboguy_> that wasn't my answer either, just a side note
14:18:24 <funfunctor> ReinH: I have like 3 times now
14:18:35 <f|`-`|f> Is this a 52 Xanatos Pick Up?
14:18:52 <ReinH> funfunctor: You have? Where?
14:19:00 <ReinH> Maybe you can just quote yourself to save time.
14:19:06 <ReinH> Since I can't find it.
14:19:26 <Lutin`> :OO
14:19:31 <Lutin`> MSYS2 uses Pacman
14:19:34 <Lutin`> yayyy
14:19:39 <funfunctor> (08:12:00 AM) funfunctor: the primary issue is, RadioInterface actions https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioInterface.hs#L105 expect to know what radio interface they are going to use upon dispatch
14:19:39 <funfunctor> (08:03:49 AM) funfunctor: EvanR: I need to dispatch to actions in the RadioInterface record here https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioInterface.hs and they ofcourse expect me to pass which radio interface I should be using.
14:19:46 <funfunctor> ReinH: ^
14:19:55 <funfunctor> and one other instance
14:20:10 <ReinH> funfunctor: Ok, and what is the quesiton?
14:21:09 <funfunctor> how to deal with the apparent state of remembering the radio interface we are working with. it seems like a state to me
14:21:27 <ReinH> Where do you need to know the radio interface?
14:21:45 <f|`-`|f> on dispatch?
14:21:52 <funfunctor> f|`-`|f: correct
14:21:59 <ReinH> Well, yes, but I can't translate "on dispatch" to an actual location in the source code.
14:22:30 <funfunctor> ReinH: I linked you the line number
14:22:34 <funfunctor> ??
14:22:45 <ReinH> 105? 105 is the data type though
14:23:16 <funfunctor> come on man.. https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs#L185
14:23:58 <funfunctor> you where just telling me to change it to a case stmt a min ago
14:24:37 <funfunctor> most of those are going to need to know about the radio interface in order to dispatch to the correct radio interface actions
14:24:47 <ReinH> funfunctor: You have to realize that while you understand your own code, other people don't and will require some explanation.
14:25:19 <napping> funfunctor: is the trouble in implementing that RadioInterface?
14:25:51 <funfunctor> napping: no, already implemented see above link
14:25:59 <f|`-`|f> what "RadioInterface" use when "dispatching"
14:26:28 <ReinH> funfunctor: This code is much harder to understand because you are not using pattern matching. So, as I said before, it isn't irrelevant.
14:26:48 <ReinH> It's actually making it harder to answer your question.
14:27:26 <ReinH> I just spent a fair amount of time discovering that you are using field accessors and equality tests to simulate pattern matching.
14:27:39 <f|`-`|f> ...
14:27:48 <f|`-`|f> weht?
14:29:00 <funfunctor> yea what?
14:29:04 <ReinH> https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs#L185
14:29:07 <napping> funfunctor: it looks like that just puts things in freshly-allocated IORefs, and doesn't actually hook up to anything
14:29:13 <ReinH> uses field accessors and equality tests to simulate pattern matching
14:29:34 <funfunctor> napping: none of this code in finished..
14:30:43 <funfunctor> ReinH: I heard what you said but why would it take you so much time to realize the difference between and guard and a case and why are we still talking about it, it has no effect on the question about radio interface's valued state
14:30:54 <funfunctor> and marshaling that around
14:31:16 <ReinH> funfunctor: Like I said, it *does* have an effect: it is making it more difficult for me to understand your code, which makes it more difficult to answer your question.
14:31:29 <ReinH> Difficult enough in fact that, when combined with your attitude, I am not really interested in helping.
14:31:56 <napping> ReinH: I don't see why that kind of difference would throw you off
14:32:45 <ReinH> napping: Because I am not very smart, so the additional cognitive load is a problem for me.
14:33:01 <roboguy_> ReinH: Okay, I agree that a pattern match would be better but this seems like overkill here. I feel like that point is made
14:33:43 <ReinH> roboguy_: I haven't been able to figure out what the real problem is because I've been trying to understand what the code is doing, so for me it's a problem. Maybe not for others.
14:34:23 <ReinH> Anyway, I'm going to bow out and let others help, since I'm not being effective.
14:35:32 <napping> funfunctor: do you have a dedicated socket to a radio?
14:35:55 <napping> the type of your RadioInterface pretty much requires that the functions in the record close over the connection or device id or whatever they use to pick the device
14:36:01 <funfunctor> napping: yes, there are two sockets. one for the data path (not done yet) and one for the control
14:36:26 <napping> I doubt it's a good idea to try to mix commands from multiple threads to the same device anyway, right?
14:37:00 <funfunctor> napping: correct so I have example usage here https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Main.hs
14:37:26 <funfunctor> napping: well command handling is one thread
14:37:36 <funfunctor> napping: data path is another thread
14:43:13 <NemesisD> so is the point of the parsers package to provide a way to write a generic parser that works on multiple parser "backends"?
14:43:39 <napping> Mostly, but the tokenparsing stuff can be useful too
14:44:47 <ReinH> NemesisD: It's basically all the stuff from trifecta that could be generalized to arbitrary parsers.
14:44:59 <ReinH> via typeclasses
14:45:21 <NemesisD> ReinH: so theoretically i could port my attoparsec parser to instead just take a Parsing constraint and expect roughly the same performance?
14:45:39 <ReinH> NemesisD: Performance? No. Behavior? Yes.
14:45:55 <ReinH> Performance will be whatever the performance of the chosen parser impl is
14:46:12 <napping> In particular, Parsec's Token stuff hardcodes a bit more of the structure of whitespace than you might like (you can't easily make a /*@ */ be retained as an item while ignoring /* */ otherwise)
14:46:12 <NemesisD> oh sorry, to clarify i mean if the selected parser was attoparsec
14:46:12 <ReinH> There will also be some variance in behavior wrt error handling and such
14:46:20 <ReinH> NemesisD: Oh. Then yes.
14:46:40 <napping> but you can make a TokenParsing instance, maybe for a newtype, and pick some of that stuff yourself
14:46:42 <NemesisD> i'm parsing something pretty simple (uris) but i noticed all the packages out there only parse strings
14:47:22 <NemesisD> yeah i noticed most parsers unfortunately only support stringly typed errors
14:48:07 <NemesisD> once you build up to a monad seems like the temptation to just use the "fail" fire escape ladder is too great
14:48:31 <ReinH> NemesisD: I don't think so. Fail is generally only used for pattern match failures.
14:48:46 <NemesisD> i'm pretty sure attoparsec uses it for all error handling
14:48:47 <ReinH> Generally, I think there's a strong aversion to actually using fail directly.
14:49:01 <ReinH> NemesisD: Well, attoparsec has pretty bad error handling...
14:49:28 <ReinH> Also did you know that an attoparsec is roughly 3 centimeters?
14:50:00 <NemesisD> agreed. i actually tried to go down the route of fortifying the error handling and it involved serializing/deserializing errors through fail with show/read
14:50:05 <NemesisD> i didn't know that
14:50:18 <ReinH> 3.08 centimeters, apparently
14:52:13 <f|`-`|f> So is there a way to get around it without going the string route
14:52:22 <f|`-`|f> it probably involves a better library
14:52:32 <f|`-`|f> or overloading the error handling
14:53:40 <Kron> If cabal tells me it couldn't find link destinations for every type in my source code, how can I fix that?
14:53:44 <raek> https://github.com/bos/attoparsec/issues/49
14:53:59 <raek> "Most of the error information is discarded in Data.Attoparsec.ByteString.Internal.parseOnly in the construction of the Left value."
14:54:19 <raek> sounds like some of the error reporting problems can be fixed
14:54:53 <raek> if it's currently being discarded (by mistake?)
14:56:00 <napping> I don't see how generalizing the String in Attoparsec's IResult could hurt performance
14:57:23 <athan> napping: Did you know that placing a `where` clause strategically can affect performance?
14:58:04 <napping> what do you mean by "placing"?
14:58:25 <napping> certainly sharing vs. recomputing a value can be important
14:59:33 <athan> napping: That's what I mean - what syntactical abbreviation you choose is important
15:00:38 <napping> I mean something like let x = <..> in \y -> ... vs \y -> let x = <..> in ...
15:02:27 <napping> I'd be more surprised if a rearrangement that doesn't cross a lambda had a big effect
15:02:48 <napping> but STG does give all the laziness a pretty straightforward operational reading
15:06:16 <elvinz> hi, when I try to load in ghci the content presented at: http://pastebin.com/dhJZL52w, I get the error "main.hs:2:61: Not in scope: `*** Exception: <stderr>: commitBuffer: invalid argu
15:06:16 <elvinz> ment (invalid character)"
15:06:34 <elvinz> I am very new to Haskell
15:07:21 <arkeet> elvinz: you are using some funny dash character for subtraction.
15:07:22 <elvinz> yet amazed at this new way of programming (for me ...)
15:07:29 <arkeet> you need to use a regular hyphen -
15:07:55 <arkeet> that error message is very strange, though.
15:08:07 <geekosaur> "en dash". I do wonder what encoding it came from
15:08:17 <elvinz> yes I get a new error message correcting that
15:08:25 <elvinz> I copy pasted the formula from a website
15:08:30 <elvinz> thank you
15:08:49 <EvanR> encoding = html ;)
15:09:19 <geekosaur> it got utf8 converted on paste, I suspect. are you on mac or windows by any chance?
15:09:39 <geekosaur> iso8859 doesn't do en dash, but varous windows code pages do and mac roman-8 iirc does
15:09:39 <EvanR> webpages often literally have en dashes in them
15:10:02 <geekosaur> yes, but a utf8 en dash gets an error about it not being defined, not an encoding error
15:10:02 <napping> that's a very strange error, yes
15:10:08 <napping> What ghc are you using?
15:10:15 <geekosaur> which makes me think it copied as mac roman-8 or something
15:10:17 <arkeet> I suspect it's trying to print the not in scope error
15:10:23 <geekosaur> and then failed to decode
15:10:24 <arkeet> but then dies when actually writing out the message
15:10:32 <arkeet> because of encoding issues or whatever
15:10:33 <athan> If you were an existential type, how would you be used? :s
15:10:34 <napping> Yeah, copying the funny dash from your pastbin I can define things like let x – y = x * y in 12 – 13
15:10:39 <geekosaur> yes, encoding issue printing the not in scope error, which makes me think it's encoded oddly
15:10:43 <athan> ...by mapping the function into the contents?
15:10:47 <EvanR> without knowling literally what was in the source code, if you suspect it wasnt en dash, who knows
15:10:49 <geekosaur> which is why I asked about the platform
15:10:54 <elvinz> version 7.8.3 on windows 7 64
15:11:10 <napping> I also get Not in scope: ‘–’ - GHC 7.8.3 on Linux 64 bit here
15:11:29 <elvinz> and there is the page: http://www.experiglot.com/2006/06/07/how-to-convert-from-an-annual-rate-to-an-effective-periodic-rate-javascript-calculator/
15:11:32 <geekosaur> yep. on pastebin it's the correct utf8
15:11:37 <EvanR> > (–) = (-) in 3 – 6
15:11:38 <lambdabot>  <hint>:1:5: parse error on input ‘=’
15:11:40 <EvanR> > let (–) = (-) in 3 – 6
15:11:42 <lambdabot>  -3
15:12:17 <arkeet> maybe this is a lesson to not copy and paste formulas into code. :)
15:12:18 <napping> huh, even downloading the raw paste it at least gives a proper  "not in scope" error message
15:12:41 <Eiam> :t fmap
15:12:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:12:44 <Eiam> :t map
15:12:45 <lambdabot> (a -> b) -> [a] -> [b]
15:13:09 <geekosaur> yes, page is utf8. browser locale may be an issue
15:13:16 <arbelos> minus is different from en dash though −– 
15:13:34 <arbelos> oops.. they showed up as the same here
15:13:36 <geekosaur> it's 2015, why is encoding still so hard x.x
15:13:42 <napping> elvinz: if you can reproduce that error, it's probably a decent bug report
15:13:46 <geekosaur> they look different here
15:13:55 <reem> geekosaur: because it's 2015 :P
15:14:05 <EvanR> arbelos: slightly different here
15:14:18 <arkeet> well if it can't output that character in the error message because of the locale it's running in or whatever
15:14:23 <arkeet> what are you going to do about it
15:14:27 <geekosaur> if you have that in a file, can you by any chance zip it up and put it somewhere for inspection?
15:14:39 <arbelos> hyphen, minus, en dash and em dash are all different glyphs
15:14:45 <napping> ah
15:15:00 <napping> it was in the middle of printing not in scope and then crashed on the output.
15:15:05 <geekosaur> although there is not a lot to be done about it if this is a windows browser deciding it was going to re-encode a copy-paste in flight from utf8 to some strange code page
15:15:15 <EvanR> unlike many o character!
15:15:27 <EvanR> use them for variables without collision1
15:15:39 <napping> I guess that's reasonable enough, just that the error message from printing an unencodable character could be improved, if that's what it really was
15:15:52 <levi> funfunctor: So you need to be able to figure out which radio interface to dispatch on, right? How would you normally do that?
15:16:45 <elvinz> napping: I will report it then
15:16:59 <funfunctor> levi: the radio interface is constructed inside the transceiver I guess
15:17:01 <napping> is it reproducible where you are?
15:17:02 <geekosaur> yes, the raw copy-paste on pastebin is utf8
15:17:14 <geekosaur> I would like to see the file as it exists for you
15:17:16 <geekosaur> locally
15:17:22 <arkeet> the report better include details about the locale you're running ghc in.
15:17:25 <geekosaur> since copy-paste is apparently "fixing" it somehow
15:17:38 <arkeet> I kinda doubt it's a source encoding issue.
15:17:39 <geekosaur> (overly smart copy/paste ftl)
15:17:49 <funfunctor> levi: probably should do it inside here https://github.com/victoredwardocallaghan/hbts/blob/master/bts/Transceiver.hs#L24
15:19:21 <levi> funfunctor: Well, you have to be able to look up the right interface somehow. So you're going to have to have a data structure that holds onto the current interfaces. And then your dispatch function is going to have to be able to reference that data.
15:19:44 <funfunctor> levi: exactly
15:20:21 <funfunctor> levi: now my question is, is State something that should be used here or should I find another way
15:20:23 <napping> elvinz: looks like that's the error you generally get from printing a bad character
15:20:35 <napping> elvinz: so more of a request for an improved error message
15:20:42 <elvinz> ok
15:21:06 <napping> yall can reproduce it by doing hSetEncoding latin1 stderr before trigerring a "not in scope" error with unicode characters
15:21:08 <levi> funfunctor: If you're going to have a deep call chain where most of them don't care about state, then State is helpful. Otherwise, you may as well just pass the state as an explicit parameter.
15:21:26 <hacker> is there any "easy" way to return a tuple from a haskelldb query? 
15:22:09 <napping> funfunctor: what is an "interface" anyway? A pair of sockets?
15:22:22 <levi> funfunctor: Your current call tree for controlLoop doesn't look very deep, though, so passing state explicitly is a good place to start.
15:22:28 <funfunctor> levi: hmm deep call chain as a thumb of rule sounds reasonable
15:22:46 <funfunctor> napping: no
15:23:11 <funfunctor> napping: sockets are the entry point to the top of the stack
15:23:43 <napping> I suspect Reader will work instead of State - if you want to e.g. make an IORef available everywhere
15:24:06 <funfunctor> levi: I think your right, passing it explicitly is the way to go here
15:24:57 <napping> funfunctor: how do you implement a connection to a device?
15:25:19 <boothead> Anyone who's using nix seeing errors complaining about a wrong sha256 for packages?
15:25:37 <napping> if it's not the pair of sockets, maybe create also dedicated threads when connecting to the device, and want to pass around something like the Channel for talking to those threads?
15:26:19 <funfunctor> napping: thats pretty deep down the stack but yes there is a thread that handles data down to the hw using pipes
15:26:50 <napping> I get the impression you are still building most of the stack you want
15:27:02 <nvez-> Let's say I have the following: [Entry {word = "{", definition = "{"},Entry {word = "A", definition = "Un"},Entry {word = "a", definition = "une"}] .. what's a good way of "extracting" the "Entry" level matching a specific word in a function.. looping over each item or is there a way in Haskell?
15:27:29 <elvinz> napping, here is the ticket: https://ghc.haskell.org/trac/ghc/ticket/10167#ticket
15:27:44 <elvinz> must go to bed, thank you for the help
15:27:48 <elvinz> ++
15:27:52 <arkeet> nvez-: filter the list for Entries that have a matching word.
15:28:06 <napping> is the line break after "argu" actually how it prints?
15:28:09 <arkeet> :t lookup -- nvez-: also see this.
15:28:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:32:41 <Jello_Raptor> what is that property of labda calculus where no matter what order you do reductions in, the final answer is the same? 
15:33:14 <arkeet> confluence
15:33:41 <Jello_Raptor> arkeet: thank you :)
15:34:16 <hacker> also 'church-rosser property'
15:34:45 <Iceland_jack> Link: https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem 
15:35:45 <frerich> When using Template Haskell, I can use something like $(mkBlah ‘f) to refer to the function ‘f’. Is there a way to refer to some function without naming it, like $(mkBlah (not . null)) and then use the passed expression in the splice?
15:36:27 <c_wraith> frerich: you mean like [| not . null |] ?
15:36:48 <frerich> c_wraith: Yeah, like a quasi-quoted expression.
15:37:17 <c_wraith> frerich: err.  In what way does [| |] quoting not do what you need?
15:37:19 <napping> oh, if it's quoted like that you can splice the expression in
15:37:30 <frerich> Wait, you mean $(mkBlah [|not . null|]) imight work? That never occurred to me...
15:37:39 <c_wraith> frerich: yeah, that should work
15:37:42 <napping> if it's not quoted, then you could call it at compile time but you can't include it - there's no Lift instance for functions
15:37:48 <c_wraith> frerich: well, it might require a >>=
15:38:00 <c_wraith> frerich: since [| |] quoting gives you a Q Exp
15:38:08 <napping> c_wraith: that could be folded into the definition of mkBlah anyway
15:38:17 <napping> and lots of TH stuff is prepared to deal with ExpQ
15:38:19 <ReinH> c_wraith: hmm, I should ask you about my own QQ problem some time.
15:38:27 <ReinH> QQ seems like a black art to me
15:38:34 <ReinH> I've even read the paper...
15:38:37 <c_wraith> QQ is a slightly different art. A bit blacker. :)
15:38:40 <napping> But yeah, inside mkBlah you might need a bind to get an Exp out
15:38:45 <frerich> c_wraith: Is there a way to get some type checking? In particular, the given function is supposed to be a predicate (like ‘a -> Bool’). I guess I can only figure out type faults when compiling the generated code?
15:39:18 <c_wraith> frerich: Oh, recent versions of GHC have support for typed expression splices..  I haven't used them.  I can't help with them. But they exist
15:39:48 <napping> and untyped expressions?
15:39:50 <frerich> c_wraith: Ah, interesting. I’ll google for that, thanks for the pointer!
15:40:00 <napping> The [| ... |] will check that the code inside is well typed with *some* type
15:40:05 <c_wraith> napping: no, the expressions are typed too
15:40:14 <napping> yeah, that's the new part
15:40:55 <napping> The old style always gives you a Q Exp as the type of the quote, but it typechecks the code inside before even making that value for you
15:42:03 <napping> Isn't the new TH also adding an even less typed kind of quote?
15:42:24 <Iceland_jack> Yes there is
15:42:49 <Iceland_jack> http://gmainland.blogspot.com/2013/05/type-safe-runtime-code-generation-with.html
15:43:03 <Iceland_jack> You write [|| … ||] and $$x
15:43:35 <c_wraith> Iceland_jack: thanks for the link
15:43:39 <napping> that's the more typed way, opposite of what I was thinking of
15:43:46 <napping> but the useful one for frerich 
15:44:51 <napping> you can imagine something like $(monadify [| if e1 then f e2 e3 else () |]) ==> do x <- e1; if x then liftM2 f e2 e3 else return ()
15:45:03 <napping> but you can't do that because the if e1 then ... part is already untypeable
15:45:24 <napping> anyway, that's apparently something I just imagined
15:45:51 <tempname11_> is it possible to use "where" in an expression? doesn't seem to be, and it drives me nuts :(
15:47:20 <nvez-> I feel like my retrieve function is not correct/ideal.. can someone give any suggestions to clean it up (this is an assignment so I cannot change the signature.. http://lpaste.net/6590266443969855488
15:47:38 <nvez-> Just a note that they're grouped by word length
15:48:57 <f|`-`|f> qq?
15:49:28 <geekosaur> tempname11_, where is part of declaration syntax, not expression syntax. if you want the latter, you want let
15:50:33 <geekosaur> f|`-`|f, quasiquoter?
15:50:52 <f|`-`|f> ?
15:51:11 <geekosaur> [17 22:46] <f|`-`|f> qq?
15:51:16 <Lutin`> well then...
15:51:37 <geekosaur> I was assuming you were asking about 
15:51:37 <geekosaur> [17 22:36] <c_wraith> QQ is a slightly different art. A bit blacker. :)
15:51:40 <f|`-`|f> er, and that is
15:52:01 <nvez-> Can this be cleaned up or written in a bit better way: retrieve w h = definition $ head $ filter (\x -> w == word x) (h !! (length w - 1)) --- definition and word are to lookup from type
15:52:44 <roboguy_> nvez-: well, length with !! is never a good idea. You could probably replace that bit with dropWhile or takeWhile
15:53:02 <nvez-> because of possibly going out of bounds?
15:53:19 <roboguy_> nvez-: That and it has to traverse the list one entire time for length and then again for !!
15:53:41 <nvez-> I think I have no choice for doing that, no?
15:53:44 <roboguy_> > takeWhile (< 5) [1..]
15:53:45 <lambdabot>  [1,2,3,4]
15:54:06 <Lutin`> anyone here do a lot of Haskell dev on windows?
15:54:10 <tempname11_> geekosaur: I guess I want something like (f x y where x = g z; y = ...; z = ...; ...)
15:54:16 <nvez-> it's a nested list where the index of the top-most one is the length of the string
15:54:22 <roboguy_> Find would probably be better actually
15:54:26 <nvez-> and then the words are inside the second one
15:54:29 <Lutin`> I'm having issues with what I believe to be the lack of signals
15:54:30 <roboguy_> > find (== 5) [1..]
15:54:30 <f|`-`|f> > dropWhile (<5) [(-10),(-9)..]
15:54:31 <lambdabot>  Just 5
15:54:31 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
15:54:54 <f|`-`|f> :t find
15:54:55 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:54:55 <geekosaur> tempname11_, any reason you can't use let?
15:55:08 <nvez-> but for the find, i'd have to use it for the lookup in the 2nd list
15:55:12 <geekosaur> that is not a declaration, where won't work there
15:55:13 <nvez-> because the first one i just lookup by index
15:55:31 <tempname11_> geekosaur: I find my code way more readable like this
15:55:37 <geekosaur> the point of where is to scope over things like guards and multiple top level bindings
15:56:00 <tempname11_> I know it's not expression syntax, but inside the parentheses it would be unambiguous; no reason it could not work
15:56:10 <geekosaur> and trying to make `where` work in expression context will break existing programs
15:56:25 <roboguy_> nvez-: if you zip it with [0..] you can get a length indexed list and search based on the length pair of the pair
15:56:27 <roboguy_> *pairs
15:56:32 <geekosaur> only if you insist on the parentheses, and that is asking for trouble as a parsing rule
15:56:47 <pavonia> Lutin`: What issues?
15:57:02 <lpaste> Lutin` pasted “Windows networking issues” at http://lpaste.net/127024
15:57:16 <Lutin`> Unless I run this in ghci, nothing is ever printed
15:57:22 <roboguy_> > zip [1..] ['a'..'f']
15:57:24 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f')]
15:57:35 <tempname11_> I like "where", because it lets me state the overall result before going into computation details 
15:57:47 <pavonia> Lutin`: Do you compile with -threaded?
15:57:51 <Lutin`> and I end up having to kill ghc.exe or ghci.exe
15:58:08 <tempname11_> geekosaur: what parsing trouble do you anticipate?
15:58:47 <f|`-`|f> > find ((==20) . fst) $ zip [1..] ['a'..'z']
15:58:48 <lambdabot>  Just (20,'t')
15:58:52 <f|`-`|f> ayyyy
15:59:06 <Lutin`> pavonia: Well at the moment even runhaskell doesn't work
15:59:29 <Lutin`> I'll try runghc with -threaded
16:00:22 <tempname11_> I'm tempted to hack at GHC and make a language extension for this 'where' thing. I wonder if it's hard
16:00:30 <tempname11_> do language extensions include parsing?
16:00:45 <f|`-`|f> > let the a = find ((== n) . fst) $ zip [1..] ['a'..'z'] in map the [2,1,14,1,25,14,1,25]
16:00:46 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing]
16:00:51 <Lutin`> pavonia: Do you use Cygwin or MSYS2?
16:00:53 <hpc> language extensions include all sorts of things
16:01:18 <geekosaur> aside from the complexity, the main problem is comprehension --- where has grown an incomsistent meaning that only works inside parentheses. surely you can write it, likely to have some complexity due to being different from everything else
16:01:36 <Lutin`> pavonia: Even compiling with -threaded gives me nothing
16:01:42 <pavonia> Lutin`: Unless I have to compile a package with c libs, non of them
16:01:58 <Lutin`> maybe that's the issue?
16:02:10 <tempname11_> geekosaur: "let" has several meanings, but is still comprehensible
16:02:12 <roboguy_> f|`-`|f: oh it looks like n is bound to something already. that should be a
16:02:13 <f|`-`|f> > let the a = find ((== a) . fst) $ zip [1..] ['a'..'z'] in map the [2,1,14,1,25,14,1,25]
16:02:15 <lambdabot>  [Just (2,'b'),Just (1,'a'),Just (14,'n'),Just (1,'a'),Just (25,'y'),Just (14...
16:02:15 <tempname11_> but I see your point
16:02:29 <Lutin`> pavonia: I was just going off what the wiki said in regards to Windows
16:02:48 <f|`-`|f> > let the a = find ((== a) . fst) $ zip [1..] ['a'..'z'] in snd <$> (map the [2,1,14,1,25,14,1,25])
16:02:49 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe (a1, GHC.Types.Char)’
16:02:49 <lambdabot>                with ‘(a0, b)’
16:02:49 <lambdabot>  Expected type: a1 -> (a0, b)
16:03:01 <geekosaur> let has essentially one meaning, actually.
16:03:24 <geekosaur> it may not look the same to you, but it is
16:03:31 <f|`-`|f> > let the a = find ((== a) . fst) $ zip [1..] ['a'..'z'] in snd <$> . <$> (map the [2,1,14,1,25,14,1,25])
16:03:32 <lambdabot>  <hint>:1:67: parse error on input ‘.’
16:03:48 <juanpablo___> what's an example of a type that is an Applicative but isn't a Monad?
16:04:30 <pavonia> Lutin`: I had a similar issue once, but I don't recall exactly. Let me think about that a moment ...
16:04:35 <EvanR> :t ap
16:04:36 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:04:43 <roboguy_> juanpablo___: a simple one is data Proxy a
16:05:03 <EvanR> cant any applicative be made into a monad
16:05:07 <tempname11_> geekosaur: how is it different from my proposed "where" extension? I don't think it changes the meaning more than "let" inside "do" does
16:05:16 <roboguy_> EvanR: That's the other way
16:05:18 <juanpablo___> Any Monad can be made into an Applicative
16:05:24 <EvanR> ol
16:05:31 <Lutin`> pavonia: Yeah works find if I use GHCi or ghc --interactive
16:05:35 <arkeet> ZipList is another example
16:06:21 <geekosaur> whatever. go nuts, since you know what you want
16:07:57 <pavonia> Lutin`: I think I wasn't be able to use the same port on different program run in ghci, so probably not related
16:09:03 <pavonia> Lutin`: But if it works in ghci, it should also work with the compiled binary if -threaded is enabled. AFAIK, that's the only thing ghci does differently
16:10:00 <geekosaur> Lutin`, try setting output buffering to NoBuffering or LineBuffering?
16:10:04 <pavonia> Lutin`: Or maybe a buffering issue? You could try to enable line buffering explicitely
16:10:08 <geekosaur> not on the socket, but on stdout
16:10:11 <Lutin`> It's NoBuffering at the moment
16:10:14 <Lutin`> ah
16:10:16 <geekosaur> no, that's the socket
16:10:26 <Lutin`> yeah I'll try that
16:11:52 <Lutin`> ah there we go
16:12:16 <Lutin`> so GHCi automatically sets it to NoBuffering?
16:12:20 <geekosaur> yes
16:12:24 <Lutin`> gotcha
16:12:32 <geekosaur> and I have no idea what Windows uses for a default buffering convention
16:12:48 <geekosaur> Unix uses LineBuffering if it's on a terminal. Windows doesn't really have the concept of "on a terminal"
16:13:34 <Lutin`> Yeah, it must not be LineBuffering. Otherwise I should have seen putStrLn at least
16:13:42 <Lutin`> Strange..
16:14:01 <geekosaur> yes, I imagien if you waited long enough you'd see a bunch of output all at once; the default buffer size is often something like 4K or 8K bytes
16:15:04 <Lutin`> yeah I think that happened when I tried to run it using runhaskell
16:15:27 <Lutin`> as Ctrl-C didn't interrupt the process
16:15:28 * hackagebot cmark 0.3 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3 (JohnMacFarlane)
16:15:57 <geekosaur> *that* might qualify as a bug
16:16:15 <geekosaur> but I don't really know how Windows interrupt handling works
16:16:27 * geekosaur very much a POSIX type
16:17:48 <Lutin`> yeah I'm just trying to get a hang of Windows dev so I can help introduce some friends to Haskell who still haven't seen the light
16:18:19 <geekosaur> one problem you'll run into a lot on Windows is that most of the ghc devs are on Linux, and Windows support is ... variable
16:18:32 <Lutin`> Yeah I mean, I'm on Linux haha
16:18:38 <Lutin`> I'm doing this in a VM
16:18:40 <geekosaur> another is that the same applies to most third party libraries...
16:18:42 <EvanR> variable is a good way to put it
16:19:02 <EvanR> luckily Lutin` is on the job
16:19:18 <Lutin`> I got really excited when I saw MSYS2 uses a modified pacman
16:19:44 <Lutin`> and then I ran into issues like this and was reminded of one more reason I'm a nixer
16:20:35 <geekosaur> yeh
16:21:06 <Lutin`> ....
16:21:10 <Lutin`> It stopped working
16:21:10 <geekosaur> I generally avoid the emulation environments; win7 isn;t that painful natively, and the emulations always work right up until they don't and I get kneecapped by some difference that can't be hidden
16:24:25 <geekosaur> (this reminds me I need to buy a copy of windows to run in a VM on here)
16:24:55 <EvanR> window$
16:24:59 <EvanR> o$x
16:25:21 <koala_man> £inux
16:25:30 <EvanR> couldnt find my pound key
16:26:53 <koala_man> in GNU screen it's the digraph $$, for whichever reason
16:27:06 <RustyShackleford> i have a let statement in this function, and the first one is a list comprehension
16:27:27 <RustyShackleford> when I have a second let statement, i get a compile error for that list
16:27:38 <RustyShackleford> if I comment it out, it compiles fine
16:27:50 <RustyShackleford> let indices = [8*x + y | x <- reverse [0..7], y <- [0..7]] pieces = map pieceAtIndex indices
16:27:57 <RustyShackleford> is there something wrong?
16:28:31 <koala_man> > let a=1; b=2 in a+b
16:28:33 <lambdabot>  3
16:28:44 <RustyShackleford> do i need semicolons after each line?
16:28:46 <Lutin`> > let a=1 b=2 in a+b
16:28:47 <lambdabot>  <hint>:1:10: parse error on input ‘=’
16:29:00 <koala_man> RustyShackleford: after each variable if you keep them on the same line
16:29:03 <Lutin`> either that or use indentation
16:29:16 <RustyShackleford> yeah i'm indenting
16:29:19 <RustyShackleford> so confused
16:29:25 <koala_man> how are you indenting it?
16:29:59 <roboguy_> RustyShackleford: do you have an 'in'?
16:30:05 <RustyShackleford> i left alight the variable names
16:30:13 <RustyShackleford> hold on, lets throw this on pastebin
16:30:21 <Lutin`> !pastebin
16:30:26 <Lutin`> oh wrong channle
16:30:34 <Lutin`> see the topic, use lpaste.net
16:31:02 <RustyShackleford> http://pastebin.com/gXxetQRM
16:31:12 <RustyShackleford> er, sorry. i'll use lpaste instead
16:31:26 <frerich> Is there a way to generate a Template Haskell splice which corresponds to a whole module (and then it gets imported)?
16:31:45 <lpaste> RustyShackleford pasted “did it for you :)” at http://lpaste.net/127026
16:32:21 <frerich> I wonder whether I could use template haskell to generate abstract types.
16:32:28 <Enigmagic> frerich: like this? http://code.haskell.org/type-level/src/Data/TypeLevel/Num/Aliases.hs
16:33:22 <Lutin`> RustyShackleford: are you using spaces or tabs?
16:33:44 <RustyShackleford> Lutin`: spaces
16:33:58 <frerich> Enigmagic: Not quite - I was more thinking of a splice which is compiled as a separate module (and then imported). I’m trying to generate abstract types (i.e. whose data constructors are hidden).
16:34:34 <frerich> Enigmagic: Nice idea to use TH to generate type-level numerals tho :)
16:35:03 <roboguy_> RustyShackleford: that's strange. It definitely works for me if I copy and paste it
16:35:18 <Lutin`> same
16:35:28 <Lutin`> RustyShackleford: what's the error you get
16:35:40 <RustyShackleford> Lutin`: it complains about the list comprehension
16:35:51 <roboguy_> RustyShackleford: a syntax error?
16:36:15 <RustyShackleford> http://lpaste.net/127028
16:36:18 <RustyShackleford> roboguy_: ^
16:36:30 <roboguy_> ohh
16:36:40 <roboguy_> RustyShackleford: it's because you are trying to use numbers as Positions, essentially
16:37:01 <roboguy_> numeric literals are overloaded in Haskell, so it makes the error look a bit weird until you get used to it
16:37:13 <Lutin`> RustyShackleford: It's because of the type of pieceAtIndex
16:37:59 <RustyShackleford> what is the problem?
16:38:01 <RustyShackleford> pieceAtIndex :: Position -> Int -> Piece
16:38:43 <roboguy_> indices is a list of numbers
16:38:55 <roboguy_> not Positions
16:39:08 <roboguy_> there are more errors too, but that's the first one
16:39:13 <Lutin`> :t [8*x + y | x <- reverse [0..7], y <- [0..7]]
16:39:14 <lambdabot> (Num t, Enum t) => [t]
16:39:21 <RustyShackleford> oh wait. youre right this is messed up
16:39:59 <RustyShackleford> i forgot one parameter
16:40:11 <RustyShackleford> ugh, this is not going well today. haha
16:40:22 <RustyShackleford> now it compiles
16:41:09 <arkeet> > [7,6..0]
16:41:10 <lambdabot>  [7,6,5,4,3,2,1,0]
16:43:05 <platz> decoding json w/ aeson from an api: is it better to decode the response stream lazily, or to buffer the whole response and decode strictly?  any gotchas with streaming?
16:46:54 <f|`-`|f> > [8*x + y | x <- reverse [0..7], y <- [0..7]]
16:46:55 <lambdabot>  [56,57,58,59,60,61,62,63,48,49,50,51,52,53,54,55,40,41,42,43,44,45,46,47,32,...
16:47:20 <nitrix> Hi, I'm reading on a different language that has a lot of concepts inherited from Haskell. I'd like to know what are monadic and dyadic operators.
16:47:35 <f|`-`|f> :t (>>=)
16:47:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:47:37 <roboguy_> nitrix: that's actually completely unrelated to the monads in haskell
16:47:41 <f|`-`|f> :t return
16:47:42 <lambdabot> Monad m => a -> m a
16:47:50 <Lutin`> nitrix: You must be talking about J/APL
16:47:52 <f|`-`|f> well screw me son
16:48:29 <nitrix> Lutin`: It's a variation of APL as well, correct.
16:48:46 <roboguy_> at least, I'm almost positive it's unrelated
16:48:56 <nitrix> Lutin`: I'm looking at XY, which has things from K, which builds on APL from what I understand.
16:49:00 <Lutin`> In that case monadic isn't related to the haskell monad
16:49:10 <Lutin`> It just means it only takes a right argument
16:49:13 <roboguy_> I think it just means a unary function
16:49:15 <nitrix> Lutin`: I figured. Would you be kind enough to enlight me?
16:49:51 <Lutin`> yeah monadic means unary, dyadic means binary
16:49:58 <nitrix> That's it?
16:50:02 <Lutin`> yep
16:50:16 <nitrix> Oh, unary and binary are for functions and monadic and dyadic are for operators?
16:50:39 <roboguy_> the wikipedia page for APL has a link to the "monads in functional programming" page, which definitely isn't the right link
16:50:48 <Lutin`> they just use the term monadic and dyadic for unary and binary
16:50:56 <nitrix> Lutin`: Ah okay.
16:51:07 <Lutin`> it's the same for functions or operators
16:51:44 <nitrix> I don't like the K baggage from XY, but I really like that they managed to have a concatenative language that isn't stack-based.
16:52:00 <nitrix> They use a array-based paragdim I think, some kind of continuation passing.
16:52:21 <nitrix> I find concatenative languages cute :]
16:52:48 <Rembane> What is a concatenative language? Or... what makes it concatenative?
16:53:12 <Lutin`> Right now my job has been writing a distributed computing library in APL
16:53:19 <nitrix> Rembane: I think the idea is that function application is close to function composition.
16:53:19 <Lutin`> cute is a good word
16:53:25 <Lutin`> fun? i don't know about that haha
16:53:53 <nitrix> Rembane: You can factorize any function into smaller parts, and concatenating those parts will still have the same semantic.
16:53:55 <roboguy_> Lutin`: wow, that sounds interesting. I've never done any APL, but it looks intimidating and cryptic
16:54:00 <ReinH> @google concatenative programming language
16:54:01 <lambdabot> http://en.wikipedia.org/wiki/Concatenative_programming_language
16:54:01 <lambdabot> Title: Concatenative programming language - Wikipedia, the free encyclopedia
16:54:20 <Rembane> nitrix: That's very nice. And a bit strange. :)
16:54:29 <nitrix> Well, you need a little love for RPN :)
16:54:33 <Lutin`> roboguy_: It's really not once you learn what symbol is what function
16:54:45 <nitrix> Haskell uses prefix notation, so I doubt you guys will really enjoy that x]
16:55:05 <Lutin`> most of the issues come from the environments being a little behind the times
16:55:17 <roboguy_> Lutin`: what sort of development environment do you use?
16:55:30 <Lutin`> http://www.apl2000.com/
16:56:08 <Lutin`> Though I wish we were using http://www.dyalog.com/
16:56:32 <Lutin`> Most APL implementations are closed source
16:56:45 <Lutin`> and apl2000 is windows only :/
16:56:50 <roboguy_> I noticed that. That was the other big thing from preventing me from using it
16:56:52 <Rembane> nitrix: RPN is also strange. :D
16:57:04 <Lutin`> there's gnu-apl, but it's not quite as polished
16:58:01 <Lutin`> If you want to check it out, I would suggest J
16:58:21 <EvanR> what if there was a language that combined the windows-support of haskell with the readability of APL
16:58:30 <Lutin`> There is
16:58:39 <Lutin`> it's called APL+WIN
16:58:50 <roboguy_> Lutin`: is that one of the derivatives that just uses ASCII?
16:58:57 <Lutin`> yeah
16:59:11 <nitrix> The only thing that's missing in my little toy language are lambdas with RPN.
16:59:24 <nitrix> The only thing I could come up with is making `if` a primitive.
16:59:57 <nitrix> e.g.   1 0 eq [successMsg] [failureMsg] if print
17:00:18 <nitrix> Where [] denotes quotations (similar to haskell lazy computations).
17:00:43 <Lutin`> maybe take inspiration from the way dyalog does dfns
17:01:00 <glguy> nitrix: Have you tried the Factor programming language yet?
17:01:14 <nitrix> glguy: I'm familiar with Factor, yeah.
17:01:29 <nitrix> glguy: I remember, ehm... r> and >r from it.
17:02:34 <roboguy_> nitrix: that kind of quotation always seemed pretty similar to lambdas to me. I made a small forth-based language and I implemented booleans, conditionals and loops with quotations, rather making them primitive
17:02:43 <roboguy_> in the same way you would in lambda calculus, more or less
17:03:10 <lpaste> lightandlight revised “Parser Generator Problem”: “revision” at http://lpaste.net/124461
17:03:51 <nitrix> roboguy_: But how to semantically make this possible other than making `if` a primitive? Since the only punctuator is the space, any of those would be words and evaluated (unless inside a quotation).
17:04:02 <lightandlight> I'm still having trouble with date parsing, does anyone have ideas how to achieve the functionality described in that paste?
17:04:05 <benzrf> hmm
17:04:31 <nitrix> roboguy_: But still, "branching" to chose one quotation or the other requires a mechanism, and that'd be stepping on RPN/continuation-passing.
17:04:43 <benzrf> how do i say "class Monad (t m) => Thing t where"
17:04:50 <benzrf> without getting "m not in scoped"
17:04:51 <roboguy_> nitrix: I made the booleans non-primitive also. I had `: true swap call;`, `: false call ;` and `: if rot call ;`
17:05:01 <roboguy_> where call forces a quotation
17:05:36 <nitrix> roboguy_: How is if defined in terms of your language?
17:05:46 <roboguy_> : if rot call ;
17:05:55 <nitrix> What is rot then?
17:06:19 <hexagoxel> is there a (good) reason that MonadWriter and WriterT are in different packages? and that the class is not in Control.Monad.Trans.Writer.Class?
17:06:34 <roboguy_> it's builtin. The stack effect is a b c -- b c a
17:06:40 <roboguy_> it's the Forth rotation operator
17:06:52 <hexagoxel> the module structure seems strange and i would like to know if the main reason is backward-compatability.
17:08:53 <Lutin`> nitrix: so do you not want to add something besides quotation
17:09:01 <nitrix> roboguy_: I'm confused. true just swaps and call, and false just calls. How does
17:09:41 <nitrix> roboguy_: Sorry, how does that make `rot call` magically branch?
17:09:58 <roboguy_> nitrix: you can do stuff like [false] [1] [2] if
17:10:08 <roboguy_> Have you seen the Church encoding of booleans before?
17:10:42 <nshepperd> benzrf: what is that supposed to mean?
17:10:54 <roboguy_> It's a lot like that, but with (essentially) unnamed "lambda" arguments
17:11:55 <nitrix> roboguy_: Yes, I know church encoding, but church encoding benefit of always having lambdas, so you can describe true as \a.\b.a and false as \a.\b.b
17:11:57 <benzrf> nshepperd: i am constraining instantiating types to be monads when partially filled in
17:12:08 <nitrix> roboguy_: OH.
17:12:35 <ski> roboguy_ : Joy ?
17:12:52 <nitrix> roboguy_: HOLY
17:13:04 <nitrix> roboguy_: I love you <3
17:13:19 <roboguy_> nitrix: Haha thanks. It's the only time I've ever seen it too. Maybe I should write about it somewhere
17:13:35 <roboguy_> It feels like there's at least a bit of a connection between lambdas and this concept
17:13:46 <ski> roboguy_,nitrix : can you inspect the quotations ? or only apply them ?
17:13:46 <nitrix> It's brilliant.
17:14:08 <nitrix> ski: Well, in my case, because I have continuation passing, you can inspect everything at any point.
17:14:16 <roboguy_> ski: well, I never thought of inspecting them so just apply
17:14:31 <nitrix> If that's going to be a language feature, good question. Generally you just apply.
17:14:35 <nshepperd> benzrf: 'constraints' package has a Forall type for constraints
17:14:39 <ski> nitrix : i don't see how continuations's related to inspection
17:14:48 <benzrf> acharm_: 
17:14:50 <benzrf> *ach
17:14:56 <benzrf> that's harder core than i need
17:14:57 <benzrf> never mind!
17:15:24 <nshepperd> benzrf: class Forall (Monad t) => Thing t where
17:15:28 * hackagebot purescript 0.6.9 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9 (PhilFreeman)
17:15:29 <nitrix> ski: The continuation in my case are two dequeues. One describes the past of the computation, and the other the future of the computation.
17:15:44 <benzrf> nshepperd: do you mean Forall 
17:15:45 <benzrf> e
17:15:48 <benzrf> nshepperd: do you mean Forall Monad t
17:15:57 <nshepperd> nope
17:15:59 <benzrf> cause (Monad t) is not well-kinded
17:16:17 <nitrix> ski: Each steps pop an element from the future, evaluate it, and pushes to the end of the past.
17:16:19 <nshepperd> (Monad t) :: * -> Constraint
17:16:41 <benzrf> nshepperd: what?
17:16:43 <nshepperd> er, maybe not
17:16:44 <benzrf> :i Monad
17:16:46 <benzrf> er
17:16:48 <benzrf> :k Monad
17:16:49 <ski> nitrix : the past is the data stack ?
17:16:49 <lambdabot> (* -> *) -> Constraint
17:16:49 <arkeet> :k Monad
17:16:50 <lambdabot> (* -> *) -> Constraint
17:16:54 <nitrix> ski: Correct.
17:17:04 <ski> nitrix : can a program itself inspect these two ?
17:17:12 <ski> er, or rather
17:17:22 <ski> obviously it can access the data items on the stack
17:17:28 <shachaf> nshepperd: Hah, it uses unexported types to guarantee universal quantification?
17:17:31 <shachaf> "-- skolem variables, do not export!"
17:17:33 <f|`-`|f> I feel like Oleg is around the corner
17:17:37 <nitrix> ski: Yeah, it's allowed to manipulate both at will, as long as the type system is respected.
17:17:38 <ski> nitrix : can a program itself inspect the "future" (sequence of words) ?
17:17:39 <shachaf> "-- skolem variables, do not export!"
17:17:40 <shachaf> Er.
17:18:20 <nshepperd> benzrf: I guess that needs Forall (Monad . t), which I don't know if it's possible to write :(
17:18:28 <nitrix> ski: Mhm. You can inspections, make predictions, but solely on the type level. The values aren't known yet.
17:18:30 <benzrf> waahh waahh waaaaahh
17:19:07 <ski> nshepperd : interesting
17:19:54 <ski> nitrix : hmm .. can you check whether the next word is `dup' e.g. ?
17:20:24 <ski> nitrix : or can you check whether a quotation contains zero words or more ?
17:20:47 <roboguy_> nitrix, ski: hmm that becomes a bit like a cross between Lisp quotation and lazy evaluation if so
17:20:51 <nitrix> ski: You could write some peak function with type :: [A x^B] -> [A^x B]
17:21:04 <nshepperd> benzrf: oh wait, I'm an idiot. 'ForallF Monad t' -- from the same package
17:21:14 <benzrf> lol
17:21:15 <ski> nshepperd : `^' separates the two dequeue types ?
17:22:10 <nitrix> ski: Where [] is your continuation. A function takes and returns the continuation. A is your past, B is your future. x^B denotes popping a value from the future and A^x pushing to the past.
17:22:29 <ski> roboguy_ : to me, a delaying mechanism is distinct from a quoting mechanism. i'm trying to determine to which extent nitrix's thing (pet language ?) supports both
17:22:37 <nitrix> ski: In fact, that's the same signature as the evaluation strategy. To "inspect" you'd have to do it and undo I think.
17:22:42 <nshepperd> shachaf: yeah, there's an interesting story about how it turned out two skolem variables is exactly enough
17:23:06 <nitrix> ski: Meh. I think if I make it possible, it'd have to be a primitive for debugging purposes.
17:23:09 <shachaf> Why isn't one enough?
17:23:54 <nshepperd> https://csks.wordpress.com/2012/10/22/safe-polykinded-universally-quantified-constraints-part-1-of-3/
17:24:12 <dgorbik> hi guys. I need to implement the following: parse something, change certain values and return put it all together again. But I don't want to change the original indentation/layout/comments. Is there some common way to do this?
17:24:50 <ski> nshepperd : is it a bit like `var(X) :- \+ \+ X = chalk,\+ \+ X = cheese.' in Prolog ?
17:24:57 <roboguy_> Last time I worked on that language, I was implementing something that folds a given number of elements on the stack with a given operator... Maybe I should take another look at it
17:25:03 <ski> nitrix : ok, nice :)
17:25:07 <nitrix> ski: [A x^B] -> [A B]
17:25:27 <nitrix> ski: There we go, I figured it out. Inspect the next element from the future without modifying neither the past nor the future.
17:25:51 <nitrix> :D
17:25:53 <nshepperd> shachaf: if I recall correctly, it's due to things with instances like 'instance Foo (Bar a a)'. if you only have one skolem variable, using a Forall can lead you to believe that there is an 'instance Foo (Bar a b)'
17:25:59 <bernalex> what do you do when you have a String that's quite obviously a Double, but you want to read it as an Int?
17:26:25 <bernalex> like "1.0", I want to read as an Int, 1. 1.9 or 1.930453194 should probably just be an Int, 1, as well.
17:26:26 <shachaf> Ah.
17:26:30 <nitrix> ski: Give me a couple days and I'll have something more tangible, it's just a mess in my head right now.
17:26:37 <nitrix> ski: Thanks for testing the idea :)
17:26:51 <ski> nitrix : by "inspect" i mean do something that allows you to take different courses of action based on the result of the inspection
17:27:31 <bernalex> I don't really feel like being all super lulzy and writing a function that takes a String and throws away anything after '.', but I guess that could suffice if there is no elegant solution.
17:27:39 <ski> bernalex : what do you want to do with the remaining part ".930453194" ?
17:27:41 <gratimax> bernalex: you mean you want to floor it?
17:27:52 <bernalex> ski: "meh". I don't need it.
17:28:13 <bernalex> gratimax: I guess I could floor it. the type is only constrained by Real & Floating.
17:28:25 <nitrix> ski: I'm almost convinced it'll be possible and whitin the language semantics.
17:28:36 <ski> bernalex : but i suppose you want to get a parse failure if you have "1xy" as input ?
17:28:36 <nitrix> ski: What are the benefits of being able to do that?
17:28:46 <ski> bernalex : if so, what gratimax said seems simplest
17:28:56 <bernalex> ski: I guess it's not really possible to get that. hm.
17:29:16 <ski> nitrix : do what ? inspect ?
17:29:33 <nitrix> ski: yeah
17:29:39 <ski> nitrix : in this case, i was considering it as a disadvantage :)
17:30:07 <ski> (it makes it harder to reason about what some higher-order operation can do (probably looses parametricity), commonly for no good reason)
17:30:27 <ski> nitrix : if you specifically want to do meta-programming, then it can sometimes be useful
17:30:47 <ski> (iirc, you can inspect quotations in Factor)
17:31:03 <ski> nitrix : oh, and being able to inspect also hinders efficient compilation :)
17:32:30 <bernalex> ski: gratimax: actually floor works well here I think. thanks.
17:32:57 <ski> (in MetaML, they had inspectable quotations (a bit like in Lisp, but more principled. better, one could perhaps say). of course they have ordinary lambda abstractions as well (and there's a nice interaction between these two))
17:33:06 <ski> bernalex : cheers
17:36:10 <mikeplus64> is there a way to get the Name (as in TH) of a data family instance? for e.g. deriveJSON defaultOptions ''(SomeDataFamily somearg)
17:37:47 <enthropy> mikeplus64: it might be in there if you reify ''SomeDataFamily
17:38:22 <enthropy> though I guess deriveJSON wants a Name of a type, not constructor?
17:38:31 <mikeplus64> sadly no :(
17:38:33 <mikeplus64> yeah
17:39:08 <mikeplus64> i can probably get From/ToJSON via Generic but iirc that's a little slower
17:41:02 <nshepperd> eh, ForallF is isn't polykinded, that's a shame
17:41:16 <enthropy> you might be able to write    type Something = SomeDataFamily SomeArg; and   deriveJSON defaultOptions ''Something
17:41:41 <mikeplus64> tried, sadly nope :       Data.Aeson.TH.withType: Unsupported type: TySynD Types.LPost [] (AppT (ConT Types.L) (ConT Schema.Post))
17:42:09 <mikeplus64> L = the type family
17:42:41 <mikeplus64> i'll try with just mkName
17:43:31 <shachaf> nshepperd: Hmm, those articles seem to point out that this can still be worked around to write unsafeCoerce.
17:43:53 <shachaf> But .Forall is marked Trustworthy.
17:44:34 <mikeplus64> (nope)
17:47:51 <erisco> @pl \x -> g (f x) x
17:47:51 <lambdabot> g =<< f
17:51:40 <Axman6> are there any tools that can make suggestions/lint cabal files? I feel there's a good chance I'm making mistakes by possibly using older versions of packages than I should, or have poor version constraints
17:53:45 <nshepperd> shachaf: well, unsafeCoerce and OverlappingInstances. But it does surprise me that edwardk's package doesn't use the type family solution
17:53:57 * edwardk tunes in
17:54:00 <edwardk> which?
17:54:04 <shachaf> constraints
17:54:09 <bernalex> what's the best way to go from one Fractional to another? I have a Scientific, and I need to make it something Floating for a while
17:54:14 <edwardk> which type family solution is this?
17:54:19 <shachaf> Uisng type families for the skolems instead of regular data types.
17:54:34 <shachaf> As described in https://csks.wordpress.com/2012/10/22/safe-polykinded-universally-quantified-constraints-part-1-of-3/
17:55:06 <bernalex> rather I have a list of functions that should work on Fractional, and it includes (**), which requires Floating. so I need to "degrade" to Floating for that specific function, and back again.
17:55:29 * hackagebot syncthing-hs 0.1.2.0 - Haskell bindings for the Syncthing REST API  http://hackage.haskell.org/package/syncthing-hs-0.1.2.0 (JensThomas)
17:55:59 <nshepperd> edwardk: 'type family Skolem :: (k -> Constraint) -> k;    type Forall (p :: k -> Constraint) = p (Skolem p)' for the short version
17:56:18 <edwardk> that version fails due to attacks via MPTCs
17:56:19 <nshepperd> which seems to have the added benefit of making the whole thing polykinded
17:57:01 <nshepperd> ah, really
17:58:17 <bernalex> fromFloatDigits & toRealFloat works I guess
17:58:19 <arkeet> bernalex: you can't really convert from Fractional in general, but there is realToFrac
17:58:29 <arkeet> if your source type is Real
17:58:34 <edwardk> nothing tells me that the type family for Skolem is injective so Skolem p ~ Skolem q can drop into the environment just fine
17:58:42 <roboguy_> bernalex: would that be safe? What if it has an infinite decimal expansion?
17:58:57 <arkeet> (indeed, the only thing Real gives you is toRational)
17:58:59 <bernalex> roboguy_: then the user suffers, heh
17:59:08 <edwardk> the attack vectors i'm concerned with aren't nested foralls, they are a single forall over the second parameter of an MPTC with a fundep
17:59:13 <bernalex> roboguy_: I'm not sure that's worse than other functions giving Infinity tho
17:59:58 <edwardk> the two data type encoding tricked the compiler into knowing those A ~ B can't hold, which lets me shut down the fundep attack
18:00:11 <edwardk> because it can't both simultaneously be determined to be A and B.
18:00:15 <arkeet> bernalex: yeah, Scientific has a Real instance/.
18:00:18 <arkeet> so use realToFrac
18:00:24 <Zemyla> Is fromRational part of the minimum definition for Fractional?
18:00:31 <arkeet> bernalex: oh wait.
18:00:33 <arkeet> now read the documentation.
18:00:37 <arkeet> Always prefer toRealFloat over realToFrac when converting from scientific numbers coming from an untrusted source.
18:00:44 <bernalex> yeah
18:01:36 <nshepperd> hmm, I don't quite understand
18:01:42 <edwardk> nshepperd: i'd love to be able to get rid of the current forall solution, its ugly
18:02:07 <fread2282> will ghc use linux kernel aio?
18:04:53 <nshepperd> edwardk: do you have the same problem with 'type family Skolem1 :: k; type family Skolem2 :: k'?
18:05:06 <edwardk> nothing prevents Skolem1 ~ Skolem2
18:05:11 <edwardk> A ~ B is rejected however.
18:05:44 <edwardk> with an injective type family you could define an injective type family from Bool and talk about Skolem 'False and Skolem 'True
18:06:04 <edwardk> but we can't currently make an empty injective type family
18:06:38 <nshepperd> hmm, shouldn't the compiler reject it anyway, since it can't prove that Skolem1 ~ Skolem2?
18:07:32 <edwardk> consider a setting where we get a constraint through a fundep a b | a -> b   and it just picks up the constraint that b ~ Skolem1 and b ~ Skolem2 -- its perfectly happy to do that in your situation
18:07:46 <edwardk> it rejects it with the concrete data types A and B
18:08:06 <edwardk> hose are the cases where the parameter isn't truly 'forall' because it can't be generalized. it has constraints on it
18:08:50 <edwardk> i _want_ this solution to work, i just have no confidence in it
18:09:31 <edwardk> and the compiler doesn't know that Skolem1 and Skolem2 are truly closed. it doesn't see the lack of export
18:09:41 <edwardk> you really need an injective type family with no members
18:09:47 <edwardk> and we don't have a syntax for that right now
18:09:47 <nshepperd> ah, I see
18:14:09 <linman32> hi, trying to unregister binary to upgrade, but ghc-pkg tells me it would break packages
18:14:09 <linman32> http://lpaste.net/127100
18:14:18 <linman32> is there a way to fix this problem?
18:17:03 <jmcarthur> i'm seeing some closures in my Core output having types like "Void# -> ...". does anybody know why ghc creates these?
18:17:43 <shachaf> Do you have an example?
18:18:00 <jmcarthur> not a simple one :\
18:18:58 <shachaf> It looks like it's added for laziness?
18:19:18 <shachaf> Void# is confusingly a nullary tuple, not an "uninhabited" value like Void.
18:19:23 <jmcarthur> right
18:19:42 <roboguy_> linman32: that message makes me think that ghc might need binary to live. But it looks like you just need permission, if you really want to you could do this under root (this looks dangerous though, I would be very careful and look for other ways to solve the problem before doing that)
18:19:52 <jmcarthur> i guess i'll try to make a simpler example that i can share
18:20:06 <shachaf> Hmm, are you using pattern synonyms?
18:22:50 <shachaf> Is the thing on the right side of the Void# -> an unboxed type?
18:23:38 <jmcarthur> no, it's a boxed type
18:23:53 <jmcarthur> a full blown sum type
18:23:59 <jmcarthur> meh, gotta go now
18:24:04 <jmcarthur> thanks for starting to help though
18:24:17 <jmcarthur> i'll come back with a real example later, if i can come up with one
18:24:23 <shachaf> It looks like there could be several reasons for it.
18:24:32 <shachaf> No pattern synonyms either?
18:26:07 <roboguy_> The name makes me think that Void# is an uninhabited, unboxed type but that seems impossible?
18:27:44 <linman32> roboguy_: ok, g2g will come back to this one
18:28:11 <linman32> roboguy_: (sudo doesn't work, so gotta su, but can't find ghc-pkg)
18:29:29 <EvanR> unboxed and uninhabited seem to be from two areas of discourse
18:30:59 <roboguy_> EvanR: ?
18:31:23 <EvanR> type theory vs implementation details
18:32:07 <roboguy_> oh
18:32:28 <mgsloan> In haskell, type theory and implementation details collide ^_^
18:32:43 <EvanR> in ghc at least
18:34:52 <haasn> I wonder if Haskell 2010's type system contains any undefined behavior, in the sense that “Program X is accepted” is contradicting or impossible to determine
18:35:21 <haasn> As far as I'm aware there's no complete formal specification or proof of consistency/correctness of the Haskell type system?
18:39:35 <geekosaur> I think H2010 has that guarantee but you
18:40:20 <geekosaur> whoops
18:40:51 <roboguy_> haasn: isn't the Haskell standard type system itself just System Fw + type classes? I'd be surprised if there asn't a paper on that
18:40:52 <geekosaur> I think H'2010 has that btu turning on extensions loses it
18:40:54 <roboguy_> *isn't
18:42:54 <geekosaur> and I thought the *standard* type system was H-M + type classes. GHC is System Fw + type classes
18:45:01 <roboguy_> geekosaur: oh I'm probably mixed up. I thought H-M was the inference algorithm, but it looks like that's probably not the case
18:46:43 <KarmaFiveOhmm> hi
18:57:16 <nvez-> I'm trying to use "find" but I am getting the following when using it.. do I have something wrong here?  test.hs:46:16: Not in scope: ‘find’
18:57:27 <nvez-> retrieve w h = find (\x -> w == word x) (h !! (length w - 1))
18:57:43 <roboguy_> nvez-: I think it's in Data.List
18:57:59 <roboguy_> you'll need to import that
18:58:20 <nvez-> hmm i see
18:59:25 <ion> nvez: If you find yourself using operations like (!!) and length, you probably don’t want to use list as the data structure.
19:00:30 <nvez-> ion: this is a class assignment where i have to build a "hashtable" .. http://lpaste.net/3883108103004094464
19:00:36 <roboguy_> nvez-: I feel like you could get rid of your !! and length by zipping your list with [0..] and using find, but I haven't fully tried it
19:00:45 <nvez-> the "Hash" and "Bucket" aren't defined by me
19:00:57 <nvez-> I've had to write "e2fDict" and roboguy_ "retrieve"
19:01:02 <nvez-> sorry accidentally <tab>
19:01:19 <nvez-> the idea is that it's a hash table english ->  french translation, with word length as the hash function
19:02:06 <nvez-> (open to criticism btw, feel free to tear apart the two lines i wrote)
19:03:17 <jmcarthur> shachaf: i'm guessing that it's just a way to make something like a thunk without the memoization
19:03:39 <jmcarthur> shachaf: i see it happen a lot for things like the fail case for non-exhaustive patterns
19:03:46 <jmcarthur> though that is not all cases i see it
19:04:23 <mgsloan> "word length as the hash function" <- reminds me of PHP (http://news.php.net/php.internals/70691)
19:04:55 <nvez-> lol mgsloan TIL
19:05:29 * hackagebot linear 1.18 - Linear Algebra  http://hackage.haskell.org/package/linear-1.18 (EdwardKmett)
19:11:27 <acowley> Is there yet any way to get GHCi to simplify type family applications in the output of :t?
19:12:02 <roboguy_> acowley: does :kind! do it?
19:12:49 <acowley> roboguy_: Yeah, it does
19:12:56 <acowley> roboguy_: But then I have to copy paste the output of :t
19:13:37 <roboguy_> hmm, it's a shame there's no type level equivalent of "it"
19:13:43 <acowley> roboguy_: It also expands type synonyms :(
19:13:59 <acowley> Ugh
19:14:01 <acowley> that's annoying
19:14:20 <acowley> roboguy_: Yeah, we need itt
19:14:59 <acowley> Hah
19:15:05 <acowley> You can't do, "kind! (:t it)"
19:15:10 <acowley> Oh ghci
19:15:29 * hackagebot persistent-ratelimit 0.1.0.0 - A library for rate limiting activities with a persistent backend.  http://hackage.haskell.org/package/persistent-ratelimit-0.1.0.0 (jp_rider)
19:16:11 <roboguy_> acowley: haha, that would be nice
19:16:33 <roboguy_> composable GHCi commands
19:16:58 <funfunctor> Anyone know a way to make a new type that is modulo a int?
19:17:57 <roboguy_> funfunctor: there's a library for that
19:18:05 <koomi> funfunctor: look at the modular-arithmetic package for a fancy way
19:19:54 <funfunctor> thx
19:21:20 <fresheyeball1> hey
19:21:22 <fresheyeball1> I need some help
19:21:25 <fresheyeball1> http://haddocks.fpcomplete.com/fp/7.8/20140916-162/snap/src/Snap-Snaplet-Auth-Handlers.html#createUser
19:21:34 <fresheyeball1> I can't figure out how to unwrap this to the Either
19:22:36 <funfunctor> exellent
19:22:43 * funfunctor deletes more code
19:24:55 <glguy> You generally don't "unwrap" the either.
19:25:13 <fresheyeball1> I just want to respond differenlty for success and failure
19:25:18 <glguy> You "wrap" the thing that needs the either
19:27:21 <lightandlight> Normally wouldn't you used a case expression for Left AuthFailure and Right AuthUser?
19:28:12 <fresheyeball1> I got it now
19:28:16 <fresheyeball1> but its super ugly
19:29:19 <roboguy_> it doesn't make sense to make a Functor instance for something that uses GADT tricks does it?
19:29:47 <roboguy_> that question might be too general
19:30:20 <arkeet> generally it's not possible
19:30:30 <roboguy_> hmm, I had a feeling
19:30:54 <roboguy_> I was hoping I could make a nice DSL with a GADT and then be able to use some Monad stuff
19:31:47 <arkeet> have a look at operational
19:32:10 <roboguy_> arkeet: I will, thanks!
19:32:18 <arkeet> lets you turn anything into a monad basically.
19:32:49 <arkeet> and you'd typically write a GADT to specify the basic operations
19:33:07 <arkeet> http://apfelmus.nfshost.com/articles/operational-monad.html
19:33:23 <fresheyeball1> ok, I don't have it
19:33:38 <roboguy_> arkeet: ahh, that looks like the kind of thing I'm looking for. Thanks!
19:34:24 <Zer000> hey gents, I have a data definition I'm working on, it will look like this http://dpaste.com/1MY6DN4 but I'm trying to figure out how to have a common field to any Message (an id string)
19:34:27 <fresheyeball1> http://lpaste.net/127171
19:35:31 <arkeet> Zer000: have a different type that pairs a string with your Message?
19:35:43 <arkeet> like just use (String,Message) maybe
19:36:23 <Zer000> Hmm ok
19:36:38 <Zer000> I guess I'll do that, thanks arkeet 
19:37:09 <funfunctor> hyperframe = 2048 * 26 * 51
19:37:09 <funfunctor> type Hyperframe = Mod Int hyperframe
19:37:09 <funfunctor> Not in scope: type variable `hyperframe' eh?
19:37:40 <glguy> Fresheyeball1 bind createUser's result to a name with <- and then use case on that
19:37:43 <roboguy_> funfunctor: You can't really take things from a value level to a type level. Haskell isn't quite dependently typed
19:38:05 <roboguy_> Well, you sorta can but not directly like that
19:38:16 <funfunctor> roboguy_: I didn't know I was..
19:38:31 <fresheyeball1> @glguy sorry I don't understand
19:38:31 <lambdabot> Unknown command, try @list
19:38:35 <fresheyeball1> its not the same kind of Monad
19:38:49 <funfunctor> roboguy_: how do you fix that sort of thing?
19:38:56 <roboguy_> funfunctor: well, wait, what are you trying to do?
19:39:46 <roboguy_> oh, using modular-arithmetic
19:39:48 <funfunctor> roboguy_: just make a type Hyperframe that is modulo that int
19:40:13 <Cool> It can be your happy day,just try http://pastebin.com/ZniS3v62
19:41:25 <roboguy_> funfunctor: you would want something more like "type HyperframeMod = 2048 * 26 * 51"
19:41:38 <roboguy_> I'm not sure if type level integer multiplication comes with GHC, let's see...
19:42:40 <roboguy_> funfunctor: oh, hey it does
19:43:14 <roboguy_> funfunctor: import GHC.TypeLits and turn hyperframe into what I said a second ago
19:44:56 <funfunctor> roboguy_: you mean this package is redundant now?
19:45:04 <Zer000> can I stub in a data type but leave it undefined, just to have my code compile for now?
19:45:13 <Zer000> like data Blah = undefined? But that doesn't work
19:45:15 <roboguy_> funfunctor: ? no
19:45:31 <roboguy_> funfunctor: I mean the lowercase hyperframe
19:45:42 <roboguy_> should become uppercase and a type synonym
19:45:49 <funfunctor> roboguy_: sorry a little confused
19:46:43 <roboguy_> sorry, I'm probably not explaining this very well. Basically, instead of a integer *value* we need a type that represents that value at a type level, which is where the type synonym comes into play
19:47:13 <roboguy_> It would look something like "type HyperframeMod = 2048 * 26 * 51" and your other type would change a bit to "type Hyperframe = Mod Int HyperframeMod"
19:47:24 <funfunctor> :k Int
19:47:25 <lambdabot> *
19:47:29 <funfunctor> ok
19:47:29 <arkeet> typelits has been around for a while but I think they only added the solver in 7.8
19:47:35 <arkeet> :k 5
19:47:36 <lambdabot> GHC.TypeLits.Nat
19:49:34 <funfunctor> roboguy_: and what happens if I want the value I am modding by?
19:50:02 <roboguy_> funfunctor: natSing, I think
19:50:05 <roboguy_> :t natSign
19:50:05 <lambdabot>     Not in scope: ‘natSign’
19:50:06 <lambdabot>     Perhaps you meant ‘fmtSign’ (imported from Text.Printf)
19:50:09 <roboguy_> aw
19:50:33 <roboguy_> :t natVal
19:50:34 <lambdabot> Not in scope: ‘natVal’
19:51:24 <funfunctor> roboguy_: must I really use TypeOperators ?
19:51:45 <funfunctor> maybe if I put it in ()
19:52:05 <roboguy_> funfunctor: TypeOperators isn't really very controversial I think
19:52:17 <roboguy_> better than reimplementing type level multiplication, ha!
19:53:25 <funfunctor> I feel pretty uneasy when pragma's start to count up for something that seems trivial
19:53:54 <geekosaur> type literals and such are far from trivial
19:53:56 <roboguy_> well, I hate to tell you, but modular arithmetic isn't what I'd call trivial
19:54:00 <geekosaur> and are definitely an extension\
19:54:02 <roboguy_> *modular-arithmetic
19:54:17 <geekosaur> if you have extensions that much, code to the haskell 2010 report
19:54:27 <geekosaur> and notice how many things you can't do
19:55:41 <fresheyeball1> I am still blocked if anyone can help me understand what is wrong
19:56:36 <fresheyeball1> http://lpaste.net/127171 same problem
19:56:49 <nvez-> Can someone help me troubleshoot this a bit? http://lpaste.net/632190813417242624 -- I am getting -- No instance for (Ord Entry) arising from a use of ‘>’ -- It seems to me that for some reason e' or e (one of them) is not staying an Entry if I understand correctly?  I'm trying to build a simple tree
19:57:08 <nvez-> I cleaned up the code and narrowed it down to the portion that isn't working
19:58:06 <roboguy_> nvez-: e' and e are both type Entry, and there is no Ord instance for Entry so you can't use < and > on them
19:58:11 <geekosaur> your problem looks to be that you derive Eq but not Ord
19:58:19 <geekosaur> so you cannot use < or >
19:58:49 <nvez-> ah
19:59:04 <nvez-> that was it :D
19:59:04 <funfunctor> well this idea of having a type mod value is not really working out as nicely as I expected..
19:59:31 <nvez-> silly beginner mistake, thanks roboguy_ and geekosaur .. you guys have been a lot of help! i sincerely appreciate it
19:59:39 <roboguy_> funfunctor: type level stuff always involves turning on some extensions. Haskell 2010 is pretty limited as far as that goes
19:59:54 <roboguy_> nvez-: no problem!
20:00:00 <geekosaur> fresheyeball1, if you are not in the correct monad to use that expression and you can't lift or something to reach the correct monad, you can't do whatever it is
20:00:15 <funfunctor> roboguy_: the extensions are on, i've moved past that already..
20:00:21 <fresheyeball1> well all rountes in snap
20:00:22 <geekosaur> if you are in the correct monad, then you must use do expression <- (or equivalently >>= )
20:00:39 <fresheyeball1> take a (ByteString, Snap ())
20:00:53 <fresheyeball1> I should be able to use this code in a route
20:01:29 <funfunctor> roboguy_: this idea of toMod unMod wrapping sucks.. a better idea would have been getMod to get the value of the type I am modding with
20:01:51 <fresheyeball1> loginH = writeBS "login" :: Snap ()
20:01:53 <fresheyeball1> for example
20:02:09 <geekosaur> if there aren't any Snap folks in here right now then you may want to try one of the mailing lists
20:02:33 <fresheyeball1> writeBS :: MonadSnap m => ByteString -> m ()
20:02:40 <fresheyeball1> can't I just change out `m`?
20:04:54 <enthropy> acowley: if you :set +t; and then use  let x = blahblah, you get (more) type families expanded than if you just :t blahblah
20:06:44 <acowley> enthropy: Thanks, but it didn't have any effect on my test case
20:07:03 <enthropy> the case I did is: let x = hLength (hBuild 1 2 3)
20:07:31 <funfunctor> ok that was a complete wast of time.. typed modulo is garbage without proper dependent type support
20:08:23 <enthropy> which might be something slightly different (that hLength only reduces after numeric defaulting happens)
20:09:15 <enthropy> hLength (hBuild '1' '2' '3') :: Proxy (HLength '[Char, Char, Char]) -- is what :t spits out
20:09:30 <acowley> enthropy: I'm looking at a list append
20:12:02 <enthropy> hBuild '1' `hAppendList` hBuild 2 :: Num a => HList '[Char, a] -- doesn't have any unreduced type families
20:12:29 <acowley> huh
20:12:34 <acowley> Well I don't know then
20:12:35 <enthropy> acowley: you have kind variables involved or something?
20:12:57 <enthropy> -fprint-explicit-kinds is helpful for when things don't work properly
20:14:04 <roboguy_> funfunctor: You should see my implementation before I realized that package exists!
20:14:18 <roboguy_> it was not... as nice, haha
20:15:30 * hackagebot th-desugar 1.5.1 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.5.1 (RichardEisenberg)
20:15:47 <enthropy> acowley: I'm using ghc-7.8.4 if that makes a difference
20:16:04 <acowley> enthropy: Ohhh, you know what, I think this computer is on 7.8.3
20:16:17 <acowley> I wonder if that's it
20:17:18 <funfunctor> roboguy_: I can show you what I am trying to do
20:17:27 <roboguy_> funfunctor: sure!
20:18:14 <funfunctor> roboguy_: make this better typed https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/GSMCommon.hs#L376
20:18:32 <funfunctor> roboguy_: rather than doing mod hyperframe everywhere
20:20:05 <roboguy_> funfunctor: you could do a simpler implementation of the Mod type thing. Something like a newtype for Int and then implement a Num instance that automatically does the right modulo
20:20:16 <roboguy_> wouldn't be as general, but that's probably not a problem here
20:22:16 <roboguy_> and you wouldn't need to mess with any type level computation
20:22:38 <c_wraith> You could put the modulus in the type!
20:23:19 <funfunctor> c_wraith: that is what I was trying to do
20:24:13 <c_wraith> funfunctor: That's not so tricky, I think.  Using -XDataKinds type literals?
20:24:56 <funfunctor> c_wraith: I know
20:25:13 <c_wraith> funfunctor: on the other hand, if you want to implement div, you need an implementation of Euler's totient function, which I don't remember how to do..
20:25:30 * hackagebot clac 0.5.0 - Simple CLI RPN calculator  http://hackage.haskell.org/package/clac-0.5.0 (alexander)
20:25:35 <funfunctor> c_wraith: I know the totient function thats fine
20:25:40 <funfunctor> thats not the problem
20:26:27 <funfunctor> I didn't check but if this is prime I can just pre-compute the result as -1 of it
20:26:48 <c_wraith> Well, yes.  The totient of a prime number is easy. :)
20:28:37 <Zer000> If I have "data Msg = Query Msg | Resp Msg | Ping | Error" But in my system (this is just an example) a "Query Ping" is ok but a "Resp Ping" will never be built, should I split my data definition or keep it as one structure that "allows" incorrect values?
20:28:44 <c_wraith> Hmm.  If you want to do modular division very often, you need to cache the totient. There must be a clever way to cache it, but...  how..
20:29:13 <funfunctor> c_wraith: so is the product of co-primes and so the function is pretty simple really
20:29:45 <c_wraith> Can it be crammed into a class?  If a class contains a constant, is it shared between all uses of the class at the same type?
20:31:45 <Zer000> brb
20:34:19 <c_wraith> I guess I could test with a Debug.Trace...  After I go home.
20:42:03 <Axman6> ok, so I need a transformer for IO (Either (e | String) a, what's the current favourite way to do this?
20:42:28 <Axman6> (I'm not fussed what type the e is, currently it's String)
20:42:58 * enthropy is also wondering where you can get an ErrorT that isn't going away
20:44:53 <pavonia> EitherT is my preference
20:46:40 <Axman6> any reason to avoid ErrorT? I remember seeing that one is 'better' than the other, but can't remember which is which
20:47:07 <shachaf> EitherT works for any e.
20:47:25 <shachaf> ErrorT wants to support fail, so it restricts e.
20:47:49 <Axman6> ah, I see
20:49:46 <Axman6> I guess I should just look at the authors and if I have a choice between edwardk and not edwardk, I go with the former =)
21:00:21 <osa1> I'm reading a code that uses `if' p x y = if p then x else y` and I liked it a lot but does it have different strictness than if syntax?
21:01:35 <ion> No. This has the parameters in a more logical order: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/base/Data-Bool.html#v:bool
21:01:42 <c_wraith> I was thinking...  neither div nor (/) are really appropriate operators for modular division, are they?
21:05:15 <shachaf> Is (/) inappropriate?
21:06:56 <c_wraith> Hmm.  (/) is appropriate, I guess, but fromRational is part of the class too.  And defining 0.3 as 3 * recip 10 means literals would be *weird*
21:07:18 <c_wraith> I guess it's fair to say "don't use those"
21:07:26 <Lutin`> You could actually have a Fractional instance for a finite field
21:07:37 <Lutin`> like Z_p
21:07:45 <shachaf> Well, "the Haskell numeric type class hierarchy is inappropriate" is a different matter.
21:09:22 <c_wraith> shachaf: you know offhand if type class dictionaries are always shared?
21:09:43 <shachaf> What do you mean?
21:11:05 <c_wraith> class Foo a where bar :: Tagged a Int; instance Foo Baz where bar = Tagged someExpensiveCalculation
21:11:33 <c_wraith> Will that expensive calculation be shared?
21:11:47 <c_wraith> Err, the result of it.
21:12:00 <shachaf> Oh, I see. Well, I certainly wouldn't expect sharing in a case like instance Foo a => Foo [a]
21:12:57 <c_wraith> Oh, since that compiles down to a function internally.  Right.
21:14:18 <shachaf> When you just have an instance for a particular type like that, I'd vaguely expect that it'd be shared, but I don't know if there's a guarantee.
21:14:44 <c_wraith> I bet module boundaries and inlining issues could complicate things, too
21:15:01 <c_wraith> package boundaries could also complicate things.
21:15:54 <tenniscp25> I’m working on NICTA exercise. From this function..
21:15:54 <tenniscp25> seqOptional :: List (Optional a) -> Optional (List a)
21:15:54 <tenniscp25> seqOptional = foldRight f $ Full Nil
21:15:56 <tenniscp25>                 where
21:15:58 <tenniscp25>                   f a b = case (a, b) of
21:16:01 <tenniscp25>                               (Empty, _) -> Empty    - - (A)
21:16:04 <tenniscp25>                               (_, Empty) -> Empty    - - (B)
21:16:04 <tenniscp25>                               (Full a', Full b') -> Full $ a' :. b'
21:16:05 <Lutin`> funfunctor: You could use the binary extended euclidean algorithm
21:16:06 <tenniscp25> Please help explain why switching A and B results in an infinit evaluation
21:16:15 <Iceland_jack> It at least appaers to be shared when used as
21:16:15 <Iceland_jack>     (bar :: Tagged Bool Int, bar :: Tagged Bool Int)
21:16:18 <shachaf> tenniscp25: Please don't paste more than a couple of lines into the channel. Use hpaste.org.
21:16:36 <tenniscp25> shachaf: sorry. i'll do it in hpaste.
21:16:41 <funfunctor> Lutin`: why would I want to do all this math stuff when all I want is a int that wraps around
21:17:00 <Iceland_jack> Informally tested using Debug.Trace, so it was shared in this one case tested in ghci
21:17:17 <funfunctor> I can do it in Ada just fine with subtyping a Int
21:17:24 <Lutin`> oh so you just want the ring of modular integers
21:17:29 <Lutin`> not the division ring
21:18:16 <funfunctor> Lutin`: read from this line downwards https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/GSMCommon.hs#L373
21:18:21 <c_wraith> division should be a field, not a ring. :)
21:18:39 <Lutin`> well in this case it's also a field since it's commutative
21:18:43 <tenniscp25> Here.. http://lpaste.net/127251 Please explain why switching (A) and (B) results in infinite evaluation.
21:19:02 <funfunctor> I think the term your looking for is integral domain
21:19:17 <funfunctor> but whatever.. far too much math for a int that wraps
21:19:39 <shachaf> c_wraith: Yes, it's probably not something to depend on.
21:19:41 <Lutin`> well yes it's also an integral domain
21:20:17 <Lutin`> but integral domains are necessarily commutative
21:20:20 <funfunctor> when talking in resp. to the integers one often refers to integral domains instead
21:20:25 <Lutin`> anyways
21:20:45 <funfunctor> why would addition not be communicative
21:21:03 <Lutin`> addition is
21:21:12 <funfunctor> since its not a prime its likely not a field since I don't think its a power of a prime either
21:21:15 <Lutin`> I mean commutative in multiplication
21:21:17 <funfunctor> not that I checked
21:21:30 <Lutin`> And yeah it's not
21:22:11 <funfunctor> i'm really only doing addition any way
21:22:16 <funfunctor> typically just +1 or -1
21:22:19 <Lutin`> yeah I see that now
21:23:30 <funfunctor> Lutin`: basically its a clock that meets a certain spec
21:23:34 <Lutin`> You could just do a simple Num instance
21:23:44 <Lutin`> since hyperframe is a constant
21:24:25 <Lutin`> ah wait timeslot
21:25:00 <HeladoDeBrownie> tenniscp25, not sure if i'm on the right track or not, but how is foldRight implemented?
21:25:21 <HeladoDeBrownie> edit the original lpaste
21:26:35 <tenniscp25> HeladoDeBrownie: done
21:26:41 <Lutin`> yeah just make a datatype for frame number
21:26:44 <funfunctor> Lutin`: page 9 http://www.etsi.org/deliver/etsi_gts/05/0502/05.00.00_60/gsmts_0502v050000p.pdf
21:27:17 <tenniscp25> Optional/Full/Empty is like Maybe
21:27:40 <tenniscp25> List is not the built in list, but I think it works the same way
21:32:27 <HeladoDeBrownie> tenniscp25, i failed to reproduce, can you give what code *and* input you tried?
21:33:07 <HeladoDeBrownie> tenniscp25, in short, give all the code necessary to see what failed, including the datatype definitions even if they're obvious
21:33:07 <tenniscp25> HeladoDeBrownie: Thanks. Give me a minute. I'll paste a modified code ..
21:35:11 <c_wraith> funfunctor: do you want something like http://lpaste.net/127254 ?
21:35:52 <tenniscp25> HeladoDeBrownie: I replaced everything with built-in types in http://lpaste.net/127251
21:36:08 <tenniscp25> HeladoDeBrownie: please use `seqMaybe (Nothing : (map Just $ repeat 1))` to test
21:36:42 <tenniscp25> it works as expected if seqMaybe is defined like in lpaste but if i switch the line A and B, it results in an infinite eval
21:36:57 <Lutin`> funfunctor: Yeah why not just do something like `data TDMAfn = TDMAfn Int deriving (Eq, Ord)` and then write the proper Num instance
21:37:24 <funfunctor> c_wraith: Lutin`thx!
21:37:34 <Lutin`> Or newtype
21:37:47 <HeladoDeBrownie> tenniscp25, at a guess, it's because you're trying to evaluate the infinite part first if you switch them. i'd say this is an inappropriate operation to perform over an infinite list.
21:37:52 <funfunctor> don't really know much about Proxy
21:37:57 <funfunctor> will have to look into that
21:38:17 <c_wraith> funfunctor: my version depends on GHC 7.8.  If you throw out all the type-level Nat stuff, it doesn't really change much, but simplifies the requirements
21:38:38 <Lutin`> c_wraith: Yeah I mean hyperframe is fixed
21:39:00 <Lutin`> so it doesn't really need to be so general in this case
21:39:01 <c_wraith> all that changes is inserting a constant instead of the natVal call
21:39:06 <Lutin`> yeah
21:39:37 <tenniscp25> HeladoDeBrownie: I'm not sure if I understand pattern matching evaluation correctly.. Shouldn't it just eval the infinite part as Just (something) and stop at that?
21:39:57 <tenniscp25> I mean just eval enough to know it's Just (???) and not Nothing
21:40:25 <HeladoDeBrownie> tenniscp25, you get the same result either way without the Nothing in front to cut it off. if it's an infinite list of Just, there *is* no point at which you've told it to stop evaluating.
21:41:19 <funfunctor> c_wraith: ok I put a constant in instead of natVal what happens to the type constraint of KnownNat n => .. ?
21:41:36 <c_wraith> funfunctor: you can remove that constraint entirely
21:41:51 <c_wraith> funfunctor: as well as the whole n type parameter, and all of the imports and extensions. :)
21:41:54 <HeladoDeBrownie> tenniscp25, when you switch them, you're simply demanding the answer from folding the tail first. but this will never terminate.
21:42:56 <HeladoDeBrownie> because then to get that answer you have to look at *its* tail and so on, and there is no [] to stop at.
21:43:05 <tenniscp25> HeladoDeBrownie: please allow me few mins to think..
21:44:11 <jle`> so i discovered a trick
21:44:24 <jle`> if i had a data type like data Foo = Foo Int String Bool Blah ...
21:44:37 <jle`> and i wanted to have some functions be able to take and return Foo's, and *not* touch say, the String
21:44:53 <jle`> i can parameterize the data type -- `data Foo a = Foo Int String a Blah`
21:45:05 <tenniscp25> HeladoDeBrownie: Let's say I have an `x` bound to Just (repeat 1). When GHC match on `x`, does it evaluate the entire `repeat 1`?
21:45:11 <jle`> and so the functions that aren't allowed to change or touch can take `Foo a`, and the ones that are can take/return `Foo Bool`
21:45:19 <funfunctor> c_wraith: ok what am I missing here http://lpaste.net/127256 ?
21:45:49 <HeladoDeBrownie> tenniscp25, only as much of the expression as is demanded will be evaluated. so, what is demanding x or a part thereof?
21:46:03 <jle`> i'm trying to make this work though if one of the fields is Maybe ... Foo Int (Maybe String) ... and have some functions not allowed to "touch" the maybeness
21:46:06 <HeladoDeBrownie> tenniscp25, is it a pattern? if so, what pattern?
21:46:39 <HeladoDeBrownie> tenniscp25, and then it will also depend on how you use the variables bound by that pattern
21:46:43 <jle`> oh maybe i can parameterize over the functor... Foo f = Foo Int (f String), and functions that can't change the Maybe-ness status take Functor f => Foo f
21:46:45 <c_wraith> funfunctor: http://lpaste.net/1138539488788611072  (untested, but it should be rightish)
21:46:49 <jle`> sorry just asked and answered my own question
21:46:50 <shachaf> This trick is called parametricity. It's pretty popular.
21:46:53 <tenniscp25> HeladoDeBrownie: what if it's `case x of _ -> ...`
21:47:02 <shachaf> What you said, except that it's Functor f *> Foo f
21:47:04 <HeladoDeBrownie> tenniscp25, none of x will be demanded at all.
21:47:09 <c_wraith> funfunctor: whoops, not quite.  Need to remove the n from the instance definition
21:47:16 <HeladoDeBrownie> tenniscp25, so, it could even be undefined and you'd continue as if there were no problem.
21:47:17 <shachaf> Taking Functor f => Foo f as an argument is pretty useless.
21:47:18 <jle`> didn't realize i could use it to selectively hide fields of custom product types :)
21:47:23 <jle`> indeed shachaf 
21:47:33 <c_wraith> funfunctor: like http://lpaste.net/127257
21:47:40 <jle`> implied was Functor f => ... blah blah ... something involving Foo f ... blah blah
21:47:51 <shachaf> Maybe if I keep correcting this mistake people will change their ways.
21:47:56 <shachaf> Probably not.
21:48:17 <jle`> the first time i heard it i didn't understand...after a while i understood. but now i see it as a convenient abuse of notation
21:48:39 <jle`> perhaps it's misleading to people who are learning though, to abuse it like that
21:48:55 <jle`> because like you're using haskell syntax to describe something that isn't what the syntax actually represents
21:48:56 <shachaf> If I say "take X as an argument", that means I have something of type X -> ...
21:49:07 <shachaf> (Functor f => Foo f) -> ... doesn't make sense.
21:49:20 <shachaf> Functor f => Foo f -> ... does, and (Functor f *> Foo f) -> ... means exactly the same thing.
21:49:38 <shachaf> So why use misleading and wrong notation when the right notation is right there?
21:49:51 <shachaf> Admittedly it's not valid Haskell, but that's never stopped anyone on IRC.
21:50:22 <shachaf> You can also say things like "Foo f for a functor f".
21:50:43 <jle`> yeah the plain english version might not be too bad
21:50:45 <roboguy_> shachaf: where did that *> syntax come from?
21:51:48 <tenniscp25> HeladoDeBrownie: Please forgive my English and lack of Haskell understanding.. I still don't get it why it doesn't work when matching (a, b) on (_, Nothing) before (Nothing, _) where b is an infinite list of type [Maybe Int]
21:52:25 <c_wraith> roboguy_: *> is an operator defined in Control.Applicative
21:52:36 <enthropy> it comes from ski I think
21:52:39 <HeladoDeBrownie> tenniscp25, to attempt to match against (_, Nothing), b must be evaluated enough to know whether it is, or cannot possibly be, Nothing.
21:52:47 <shachaf> c_wraith: I'm not talking about that *>. I guess I should be clearer about that.
21:52:57 <c_wraith> shachaf: whoops.  My error.  Sorry.
21:52:57 <tenniscp25> HeladoDeBrownie: I mean, if GHC sees `b` is Just (xxx), it doesn't have to know what xxx is so it should move on to the next pattern.
21:53:02 <shachaf> I mean (*>) which is to an existential what (=>) is to a universal.
21:53:19 <HeladoDeBrownie> tenniscp25, but in this case it doesn't even get so far as to see it's a Just.
21:53:22 <shachaf> I.e. a pair of a value and a "constraint" on that value.
21:53:27 <HeladoDeBrownie> tenniscp25, which is exactly the problem and why it goes on forever.
21:53:34 <shachaf> There needs to be a better word than "constraint" for this.
21:53:40 <shachaf> What's the opposite of constraining someone?
21:53:41 <HeladoDeBrownie> tenniscp25, in fact, it isn't Just – semantically, it's bottom.
21:54:16 <HeladoDeBrownie> and when bottom gets evaluated the result of the computation needing it must also be bottom.
21:54:39 <HeladoDeBrownie> in this case that comes out as an infinite loop.
21:55:47 <tenniscp25> HeladoDeBrownie: Sorry. I don't know what bottom is. I'll look it up. But please allow me to ask you a few more questions first..
21:56:05 <HeladoDeBrownie> you can think of it as an "error" value, representing lack of a useful result.
21:56:21 <HeladoDeBrownie> also often written abusing ascii as _|_.
21:57:03 <HeladoDeBrownie> more properly written as ⊥ but most people don't have that handy (like me).
21:57:03 <jrenner> Hey all, I'm pretty new to haskell and ran into a problem that stumped me. Is there a point-free way to write a function that takes two strings and returns a concatenated string with a space in the middle?
21:57:31 <HeladoDeBrownie> jrenner, there is always a point-free way. the question is in terms of what, and whether it's better than the pointful one.
21:57:57 <HeladoDeBrownie> jrenner, do you have a pointful version of what you described?
21:58:20 <HeladoDeBrownie> we have a tool to automatically convert. it usually outputs garbage, but garbage is often the result of attempting to make something pointless.
21:59:04 <HeladoDeBrownie> @pl \a b -> a ++ " " ++ b
21:59:04 <lambdabot> (. (' ' :)) . (++)
21:59:08 <HeladoDeBrownie> see? garbage.
22:00:08 <jrenner> obviously the pointful one is way more readable: insert x y = x ++ (" " ++ y)
22:00:15 <HeladoDeBrownie> i would agree. :)
22:00:26 <wei2912> lol
22:00:29 <jrenner> but it was more a mental exercise I wanted to see if I could unravel
22:00:37 <wei2912> making something pointless is usually pointless :)
22:00:40 <jle`> point-free is only a means to an end, not an end in itself :)  except perhaps for such described mental exercises
22:00:42 <HeladoDeBrownie> ah, i see. so you want to know how to reduce it yourself?
22:00:43 <jle`> :)
22:01:03 <shachaf> Nothing is an end in itself.
22:01:49 <HeladoDeBrownie> well a good step is to put all the infix applications in prefix format. insert x y = (++) x ((++) " " y)
22:01:57 <HeladoDeBrownie> then try to turn this into a composition taking y as an argument.
22:02:00 <arkeet> well, it might be a coend.
22:02:43 <HeladoDeBrownie> once you have something like h . g . f $ y, you can take y out entirely.
22:03:02 <HeladoDeBrownie> then try to do the same with x.
22:03:13 <HeladoDeBrownie> i'm skipping lots of steps. but that's one way to do it.
22:03:55 <jrenner> yeah I was kinda stuck on (which was a horrible way of thinking about it) embedding x into the composition
22:04:19 <HeladoDeBrownie> at a glance you'll end up with composition at various levels of the expression tree.
22:04:34 <arkeet> well, take your infix . and put it in prefix ;)
22:05:36 <roboguy_> jrenner: one way to go about doing it is using flip to get the x on the outside
22:05:40 <jrenner> ah so if I reorder it like (++) ((++) " " y) x
22:05:54 <arkeet> you need a flip there.
22:05:56 <roboguy_> jrenner: that's a different function
22:06:07 <jrenner> lol right :P
22:06:14 <jrenner> that put them in the wrong order
22:06:26 <arkeet> I mean
22:06:39 <arkeet> starting with \x y -> (++) x ((++) " " y)
22:06:49 <arkeet> write it as a composition
22:06:58 <arkeet> \x y -> ((++) x . (++) " ") y
22:07:05 <arkeet> \x -> (++) x . (++) " "
22:07:10 <arkeet> but now write the . as prefix.
22:07:22 <arkeet> so \x -> (.) ((++) x) ((++) " ")
22:07:29 <tenniscp25> HeladoDeBrownie: You mentioned "tenniscp25, but in this case it doesn't even get so far as to see it's a Just." May I ask you if it doesn't get that far, where does it stuck?
22:07:31 <arkeet> now you can flip the (.) to get the x on the outside.
22:08:01 <HeladoDeBrownie> tenniscp25, it requests the result of folding the rest of the list, which requests the result of folding the rest of the list, which requests the result of folding the rest of the list…
22:08:08 <arkeet> eventually I get flip (.) ((++) " ") . (++)
22:08:18 <arkeet> but now you can change some of those to sections 
22:08:20 <HeladoDeBrownie> tenniscp25, but there is always more of the list, since it's infinite.
22:08:28 <arkeet> (++) " " = (" " ++)
22:08:35 <arkeet> and flip (.) f = (. f)
22:08:55 <arkeet> then I get (. (" " ++)) . (++)
22:08:59 <arkeet> which is pretty close to lambdabot's.
22:09:24 <arkeet> it's pretty mechanical I guess.
22:09:31 <tenniscp25> HeladoDeBrownie: I think this is where I'm lost.
22:09:36 <arkeet> if you have a variable that just appears once, flip stuff until it ends up on the outside.
22:09:43 <jrenner> huh interesting. I guess i've just never thought of . in prefix
22:10:08 <HeladoDeBrownie> tenniscp25, what specifically has you lost?
22:10:13 <shachaf> Prefix (.) is a funny operator. It means "map over the argument of this function".
22:10:31 <arkeet> :t [(.), fmap]
22:10:32 <lambdabot> [(b -> c) -> (a -> b) -> a -> c]
22:12:00 <HeladoDeBrownie> shachaf, sounds like this one function i know named fmap!
22:12:09 <shachaf> fmap maps over the result of a function.
22:12:12 <shachaf> This is contramap.
22:12:43 <HeladoDeBrownie> @type fmap
22:12:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:12:45 <HeladoDeBrownie> @type (.)
22:12:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:12:46 <shachaf> (Well, that has the wrong kind. But it's contramap for Op, or lmap.)
22:12:59 <HeladoDeBrownie> looks the same to me.
22:13:18 <shachaf> Amazing, I had no idea.
22:13:42 <HeladoDeBrownie> this turned from me being facetious to being confused what you meant :P
22:13:51 <shachaf> Unfortunately we're talking about (. f), not (f .)
22:13:53 <tenniscp25> HeladoDeBrownie: Does `b` should look something like `f a1 foldr ( f a2 foldr ( f a3 foldr ( .. ) ) )`?
22:14:08 <shachaf> This is flip (.), which is :: (a -> b) -> (b -> c) -> (a -> c)
22:14:45 <HeladoDeBrownie> shachaf, ah, then "prefix (.)" is the part of what you said that i misunderstood. i thought you simply meant (.) used in prefix application, rather than a section.
22:14:55 <arkeet> I was confused by that too.
22:15:00 <shachaf> 22:07 <jrenner> huh interesting. I guess i've just never thought of . in prefix
22:15:12 <HeladoDeBrownie> tenniscp25, there's no such thing as an infinite expression, but the evaluator can evaluate arbitrarily far and will never reach an end.
22:15:18 <shachaf> I suppose it's confusing without the preceding conversation.
22:16:00 <tenniscp25> HeladoDeBrownie: I mean conceptually, to know the result of f a1 x it has to know what x is and so the infinite loop
22:16:20 <HeladoDeBrownie> tenniscp25, basically
22:16:35 <jrenner> haha sorry! yeah that's what I meant. okay got it! just tried to rework it off to the side and ended at lambdabot's solution so I think I got it. Thanks! you've all been super helpful
22:18:06 <tenniscp25> HeladoDeBrownie: then why does `xs = foldr (:) [] $ repeat 1` and then `xs !! 1` work?
22:18:12 <roboguy_> Sometimes (>>>) is easier to look at than flip (.)
22:18:39 <HeladoDeBrownie> tenniscp25, because you aren't trying to collapse an infinite number of constructors into one.
22:19:13 <HeladoDeBrownie> tenniscp25, in fact foldr (:) [] is precisely id.
22:20:28 <tenniscp25> HeladoDeBrownie: what's exactly the "collapsing an infinite number of constructors into one" in my pasted code?
22:20:51 <HeladoDeBrownie> tenniscp25, you want to get a Just after matching on every single (:).
22:21:22 <HeladoDeBrownie> (or a Nothing, as the case may be)
22:23:06 <HeladoDeBrownie> in fact you could even write a terminating function that sums adjacent elements of a list, no problem for infinite lists. because that doesn't try to force every constructor to get even one answer.
22:23:24 <HeladoDeBrownie> i.e., [1, 2, 3, 4] → [3, 7]
22:23:40 <HeladoDeBrownie> [1, 2, 3, 4, …] → [3, 7, …]
22:24:03 <HeladoDeBrownie> the problem then only arises if something *else* tries to force every (:)
22:24:19 <arkeet> > map sum . chunksOf 2 $ [0..]
22:24:20 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
22:24:22 * tenniscp25 trying hard to follow..
22:24:46 <arkeet> just don't do something that needs to traverse the entire list to be productive.
22:26:29 <tenniscp25> HeladoDeBrownie: so what forces the evaluation in my code is the match on (_, Nothing) part...
22:26:41 <HeladoDeBrownie> right, because you have to ensure b is or isn't Nothing
22:26:50 <tenniscp25> oh.. i get it now
22:26:51 <HeladoDeBrownie> and the work required to get there, on an infinite list, is infinite
22:27:01 <tenniscp25> thank you so much
22:27:04 <HeladoDeBrownie> no problem
22:27:33 <HeladoDeBrownie> so, while this function might be inappropriate on an infinite list, there are still sane transforms you can do on infinite lists… but they themselves may end up being infinite. i think the one i'm thinking of is
22:27:36 <HeladoDeBrownie> @type scanr
22:27:37 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
22:27:47 <HeladoDeBrownie> scanr (+) 0 [0..]
22:27:51 <HeladoDeBrownie> > scanr (+) 0 [0..]
22:27:53 <lambdabot>  [*Exception: stack overflow
22:27:55 <HeladoDeBrownie> never mind
22:27:59 <HeladoDeBrownie> not sure what i was thinking
22:28:28 <HeladoDeBrownie> but anyway this is not a reasonable operation on an infinite list, but more reasonable ones may exist
22:28:58 <tenniscp25> i'll check it out. thanks.
22:32:26 <HeladoDeBrownie> oh of course
22:32:31 <HeladoDeBrownie> > scanl (+) 0 [0..]
22:32:32 <lambdabot>  [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253...
22:32:36 <HeladoDeBrownie> *that's* productive
22:37:10 <HeladoDeBrownie> woop, did tenniscp25 leave before or after i remembered scanl?
22:37:37 <HeladoDeBrownie> i'm guessing before, oh well
22:39:27 <Vektorweg> is there a good solution for mutually recursive modules, yet?
22:41:37 <HeladoDeBrownie> not sure, but apparently at least one non-ghc compiler handles them okay.
23:22:23 <Axman6> readability/golf time: what's a better way of doing uncurry (liftM2 (,)) ::(Maybe a, Maybe b) ->  Maybe (a,b)
23:23:21 <Axman6> or, even better, (x -> Maybe a) -> (x -> Maybe b) -> Maybe (a,b)
23:23:35 <abg> Can I have some behavior dispatch (using typeclasses) based on phantom types without declaring newtypes?
23:25:09 <HeladoDeBrownie> abg, as long as it's clear what instance is being used, you can go nuts
23:25:27 <HeladoDeBrownie> this may or may not require type signatures depending on what you're asking
23:25:42 <abg> Like suppose I have a Text object with a ToBinary instance (which converts it to a bytestring). Now I want to modify the behavior slightly: prepend the length of the string before the string itself. The length itself could be Word8, Word16, Word32. I might declare newtype PrefixedText l = PrefixedText Text and have it write length based on the type in l.
23:26:13 <abg> But then I have to wrap and unwrap PrefixedText everywhere because I don't want to expose this detail (that it's a PrefixedText Word8) outside.
23:26:13 <HeladoDeBrownie> i'm not sure what that has to do with phantom types
23:26:27 <abg> newtype PrefixedText l = PrefixedText Text
23:26:30 <abg> l is the phantom type
23:26:39 <abg> it denotes the type of length 
23:26:48 <HeladoDeBrownie> hrm, well, what i said before still applies. as long as you can make it clear what instance to use
23:26:56 <ddere> :t both id
23:26:57 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => r (f b) (f b) -> f (r b b)
23:27:06 <ddere> Axman6: ^^^
23:27:11 <Axman6> ah, thanks ddere!
23:27:21 <ddere> > both id (Just 1, Just 2)
23:27:22 <lambdabot>  Just (1,2)
23:27:29 <abg> I mean, yeah if I use a newtype it's all fine. Is there a way to make it use a different instance for Text without a newtype?
23:27:44 <Axman6> I was thinking about both earlier and managed to forget it
23:28:04 <ddere> Axman6: It may fall over if your types are different >_<
23:28:11 <HeladoDeBrownie> abg, not really.
23:28:21 <ddere> Axman6: in fact im pretty sure it will
23:28:24 <Axman6> ah, yes, they are =)
23:28:27 <aawe> :t both `asTypeIn` \both -> both id
23:28:28 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (f b -> f b) -> r (f b) (f b) -> f (r b b)
23:28:29 <Axman6> and yes it fails
23:29:07 <Axman6> it feels like a traversal...
23:29:09 <HeladoDeBrownie> abg, if i understand what you're asking, you want to choose another instance, but one that has the same head as the canonical one?
23:29:22 <abg> Yes
23:29:29 <HeladoDeBrownie> abg, then no.
23:29:35 <abg> Either that or a "generic" way to unwrap values from newtypes.
23:29:42 <HeladoDeBrownie> hrm, well there's coerce.
23:29:47 <abg> Ah.
23:29:49 <HeladoDeBrownie> @type coerce
23:29:50 <lambdabot> (Contravariant f, Functor f) => f a -> f b
23:29:52 <HeladoDeBrownie> not that one.
23:29:57 <abg> But I'll probably feel dirty using that, won't I?
23:29:59 <HeladoDeBrownie> coerce :: (Coercible a b) => a -> b
23:30:00 <abg> :)
23:30:03 <HeladoDeBrownie> nah, coerce is perfectly fine
23:30:09 <HeladoDeBrownie> it's unsafeCoerce you might have cause to feel dirty about
23:30:11 <Axman6> that coerce is safe
23:30:16 <ddere> Axman6: yeh its definitely a bitraversal
23:30:32 <abg> Do newtypes automatically have a coercible instance?
23:30:35 <HeladoDeBrownie> (unsafeCoerce is safe in the same situations where coerce is, afaik)
23:30:39 <Axman6> :t bitraverse
23:30:40 <lambdabot>     Not in scope: ‘bitraverse’
23:30:40 <lambdabot>     Perhaps you meant one of these:
23:30:40 <lambdabot>       ‘itraverse’ (imported from Control.Lens),
23:30:50 <Axman6> :(
23:30:57 <ddere> :t bisequence
23:30:57 <HeladoDeBrownie> abg, i believe so, though i'm not sure of the details, since i've never used it myself.
23:30:58 <lambdabot>     Not in scope: ‘bisequence’
23:30:58 <lambdabot>     Perhaps you meant one of these:
23:30:58 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
23:31:06 <abg> Alright. Thanks! 
23:31:20 <HeladoDeBrownie> abg, https://wiki.haskell.org/GHC/Coercible
23:31:39 <HeladoDeBrownie> abg, ah, maybe not entirely relevant, but possibly useful nonetheless
23:31:46 <ddere> Axman6: https://hackage.haskell.org/package/bifunctors-0.1/docs/Data-Bitraversable.html#v:bisequence
23:32:52 <ddere> Axman6: bisequence works for me in the repl
23:33:37 <Axman6> bitraverse looks useful; I'm currently using: `uncurry (liftM2 (,)) . ((^? timeLens) &&& (^? stateLens))` which is horrible
23:48:54 * Axman6 ended up with (\v -> (,) <$> v ^? timeLens <*> v ^? stateLens) which is much cleaner and clearer
23:50:48 <HeladoDeBrownie> use join, you know you want tooooooooooooooo
23:51:26 <HeladoDeBrownie> i bet @pl would output that actually
23:51:29 <HeladoDeBrownie> @pl (\v -> (,) <$> v ^? timeLens <*> v ^? stateLens)
23:51:29 <lambdabot> ((,) <$>) . (^? stateLens) . ((<*>) =<< (^? timeLens))
23:51:32 <HeladoDeBrownie> ah, nope
23:51:56 <Iceland_jack> HeladoDeBrownie: Would that have been a point in join's favour? :-)
23:52:13 <HeladoDeBrownie> nah, i think it would have been atrocious regardless
23:54:10 <HeladoDeBrownie> oh woops i forgot i need to wake up tomorrow good night
23:54:24 <supki> Axman6: another way to write that would be  v ^? runFold (liftA2 (,) (Fold timeLens) (Fold stateLens))
23:56:54 <Axman6> supki: huh, interesting
23:57:51 <Geraldus> Hi friends! How can I configure ghc-mod binary path for Flycheck in Emacs?
