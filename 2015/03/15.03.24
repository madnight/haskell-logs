00:00:59 <scott> aupiff: I think it generally boils down to making sure the type checker is correct. e.g. if some tactic in Coq goes wrong, the generated term still has to pass the type checker
00:01:22 <Cale> aupiff: I believe the Coq kernel is somewhere around 7-8k lines of code.
00:02:00 <Cale> That is, the type checker for CIC.
00:04:09 * hackagebot persistent-sqlite 2.1.3 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.3 (MichaelSnoyman)
00:09:09 * hackagebot persistent-postgresql 2.1.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.3 (MichaelSnoyman)
00:14:09 * hackagebot persistent-template 2.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1.1 (MichaelSnoyman)
00:17:55 <td123> is there a "bundle outdated" equivalent for cabal? Where it lists outdated dependencies?
00:19:09 * hackagebot persistent-mysql 2.1.3 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1.3 (MichaelSnoyman)
00:19:38 <arkeet> seems like free-operational is unmaintained... :(
00:22:43 <arkeet> no responses on github issues in over a year
00:27:56 <Kekkler> NAMES [#haskell [freenode]]
01:45:10 <tdammers> anyone familiar with the intricacies of ghc 7.4 vs. 7.6 wrt "Ambiguous constraint" errors?
01:46:07 <tdammers> https://bitbucket.org/tdammers/ginger/src/141388828e36444180e360326567117569bd79c9/src/Text/Ginger/Run.hs?at=master#cl-170
01:46:39 <tdammers> GHC 7.4.1 fails on this line, but on 7.6 it compiles just fine
01:47:06 <Cale> With what error message?
01:47:20 <tdammers> oh, sorry, one sec
01:47:50 <lpaste> tdammers pasted “error message "Ambiguous constrain"” at http://lpaste.net/128923
01:47:56 <tdammers> ^ this one
01:48:49 <merijn> tdammers: That sounds wrong in 7.6
01:48:54 <merijn> Unless there's a fundep somewhere
01:49:00 <Cale> That's line 181 rather than 170
01:49:05 <tdammers> yeah, it is
01:49:06 <tdammers> 181
01:49:33 <Cale> Where is the definition of the class?
01:49:49 <Cale> class ToGVal m a where
01:49:49 <Cale>     toGVal :: a -> GVal m
01:49:51 <Cale> aha
01:49:51 <echo-area> Is the `MonadTrans t` type of lift taken from the context an expression is compiled?
01:49:56 <Cale> So, no functional dependency
01:50:06 <echo-area> I don't see other sources to deduce it
01:50:12 <Cale> The error message is correct, and you're running into a 7.6 bug
01:50:14 <tdammers> https://bitbucket.org/tdammers/ginger/src/141388828e36444180e360326567117569bd79c9/src/Text/Ginger/GVal.hs?at=master#cl-118
01:50:19 <jle`> echo-area: yes, the type is inferred
01:50:21 <jle`> a
01:50:24 <jle`> same for `return`
01:50:28 <tdammers> ah
01:50:34 <jle`> > [return 10, Nothing]
01:50:36 <lambdabot>  [Just 10,Nothing]
01:50:44 <jle`> > [read "4",10]
01:50:46 <lambdabot>  [4,10]
01:50:56 <merijn> echo-area: It's inferred, yes
01:51:00 <Cale> makeContext :: (ToGVal (Run (Writer Html)) v) => (VarName -> GVal (Run (Writer Html))) -> GingerContext (Writer Html)
01:51:03 <Cale> look at this type
01:51:10 <echo-area> Okay, thank you.
01:51:11 <Cale> v occurs only in the class context
01:51:21 <tdammers> yeah, that just occurred to me too
01:51:22 <Cale> There's no sensible way to determine which instance to use
01:51:34 <tdammers> I know.. it doesn't really make sense :D
01:52:25 <merijn> Suppose I have "StateT Int IO ()" and "foo :: IO ()" then "lift :: m a -> t m a" means "lift foo" finds that 'm = IO', 'a = ()', so it tries to infer 't' from "StateT Int IO ()" and infers that 't = StateT Int'
01:53:10 <merijn> echo-area: So then it tries to find "instance MonadTrans (StateT Int)" which it finds because there is "instance MonadTrans (StateT s)"
01:53:27 <tdammers> hmm, I suspect I don't need the constraint at all
01:54:12 <tdammers> yep, that does the trick
01:54:22 <tdammers> weird that it would compile in 7.6
01:55:54 <tdammers> anyway, thanks
01:55:59 <Cale> Yeah, there was an IRC bot called geordi which had this sort of problem. I've run into a few people having trouble compiling it on 7.8 because it relied on that bug in 7.6 (was pretty trivial to fix the issue though)
01:56:34 <tdammers> my fix is trivial too - just remove the nonsensical constraint :D
01:56:54 <tdammers> think it was a remnant of when I tried to generalize that function a bit too much
01:57:08 <echo-area> merijn: That's very helpful, thanks
01:57:13 <tdammers> I used to pass arbitrary ToGVal instances, but I changed it to pass GVal's directly
01:57:17 <tdammers> way less confusing
01:59:13 * hackagebot soap 0.2.2.5 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.5 (AlexanderBondarenko)
01:59:15 * hackagebot soap-tls 0.1.1.2 - TLS-enabled SOAP transport (using tls package)  http://hackage.haskell.org/package/soap-tls-0.1.1.2 (AlexanderBondarenko)
02:02:39 <merijn> echo-area: Type inference is, essentially, just a game of adding lists of equations like that and then figuring out if you can make all the holes line up correctly (and complaining if you can't)
02:06:16 <echo-area> merijn: I have the feeling that manual type inference while reading a function definition helps a lot in understanding its correctness, and especially the definition itself if I am confused about it
02:07:29 <merijn> echo-area: Yes, I highly recommend grabbing a pen and paper and manually inferring/substituting types to figure things out
02:07:50 <echo-area> That's what I am getting used to now :)
02:08:03 <merijn> After awhile it becomes easy enough that you can quickly do it in your head and you stop even thinking about it :)
02:08:04 <shachaf> Don't force the people who read your code do type inference, please. :-)
02:08:43 <merijn> shachaf: Even with type signatures you need to infer/specialise to see what's going on :)
02:09:36 <tdammers> shachaf: you mean by writing Python?
02:10:47 <echo-area> merijn: BTW, is that kinda what the compiler does as well?
02:11:29 <merijn> echo-area: It is, althought the exact description of how "figuring out if you can make all the holes line up" is a bit more complicated and involved ;)
02:12:12 <merijn> But yes, adding sets of equations and trying to line them up is the high-level picture of what the compiler does during type inference
02:13:39 <uggwar> anyone here built a cross compiler for ARM?
02:16:33 <solatis> anyone here got any experience with acid-state?
02:16:36 <solatis> I read from the docs:
02:16:38 <solatis> "Acid-state does not write your data types to disk every time you change it. It instead keeps a history of all the functions (along with their arguments) that have modified the state. Thus, recreating the state after an unforeseen error is a simple as rerunning the functions in the history log."
02:16:47 <solatis> this strikes me as: this does not scale well
02:17:13 <solatis> this looks like a database with only an xfer log without checkpoints?
02:17:28 <Saizan> solatis: it also has checkpoints
02:17:41 <solatis> Saizan, i saw that, but i was unsure what to think of it
02:17:49 <mauke^> http://hackage.haskell.org/package/acid-state-0.12.3/docs/Data-Acid.html#v:createCheckpoint
02:18:00 <solatis> ok, so that is likely to do what i want?
02:18:13 <mauke^> I have no idea what you want
02:18:15 <solatis> since the documentation explicitly says it only keeps a history
02:18:24 <mauke^> it does not say that
02:18:49 <solatis> hmm
02:18:52 <merijn> solatis: acid-state is not a database
02:19:09 <solatis> i know, i want to store some simple configuration and state information
02:19:15 <merijn> solatis: It's a "persistent haskell heap objects with ACID guarantees"
02:19:23 <merijn> solatis: It's basically a journaled filesystem
02:19:31 <solatis> right
02:19:39 <solatis> then i think acid-state is what i'm looking for
02:19:41 <merijn> So logging + checkpointing
02:19:44 <solatis> yes
02:19:52 <solatis> the good parts of a relational database
02:19:58 <solatis> without the bad parts :)
02:20:14 <merijn> Well, I wouldn't say the other parts are bad, just not always necessary :)
02:20:30 <solatis> yeah this is going to be a user-facing application
02:20:42 <merijn> Also, yes, for config + state info acid-state would be a good solution
02:20:44 <solatis> i don't want any dependencies, but i do want to be able to recover from crashes
02:20:55 <solatis> (y)
02:20:56 <solatis> thanks
02:22:09 <tero-> does this function have a commonly known name? let fun op f a b = (f a) `op` (f b)
02:23:40 <frerich> tero-: It's called "on"
02:23:55 <jle`> :t \op f a b -> f a `op` f b
02:23:56 <lambdabot> (t1 -> t1 -> t) -> (t2 -> t1) -> t2 -> t2 -> t
02:24:00 <jle`> :t on
02:24:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
02:24:10 <tero-> frerich: thanks
02:24:54 <mauke^> > (g `on` f) a b :: Expr
02:24:56 <lambdabot>  No instance for (GHC.Show.Show b0)
02:24:56 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.g’
02:24:56 <lambdabot>  The type variable ‘b0’ is ambiguous
02:25:16 <mauke^> oh yeah?
02:25:41 <mauke^> > let op = fun "op" :: Expr -> Expr -> Expr in (op `on` f) a b
02:25:41 <Haskellfant> is there some delete function that tells me if it actually deleted something? so a type like delete' :: Eq a => a -> [a] -> ([a],Bool)
02:25:47 <lambdabot>  op (f a) (f b)
02:25:56 <Haskellfant> ofc I can use elem, but then I run two times through the list
02:26:15 <opqdonut> Haskellfant: I think you'll have to write one yourself
02:26:28 <frerich> Haskellfant: I think you'll have to roll one yourself, that seems like a fairly specialized usecase.
02:26:31 <Haskellfant> opqdonut: k thx
02:26:38 <opqdonut> or you can use e.g. partition
02:26:47 <mauke^> or maybe use a Set
02:26:55 <opqdonut> > partition (==1) [4,3,2,1,2,3]
02:26:57 <lambdabot>  ([1],[4,3,2,2,3])
02:27:08 <Cale> > partition (== 1) [4,3,1,2,1,2,3]
02:27:09 <opqdonut> that removes all the 1s though unlike delete
02:27:09 <lambdabot>  ([1,1],[4,3,2,2,3])
02:27:12 <Cale> yeah
02:27:21 <opqdonut> a Set might be nice
02:27:37 <Haskellfant> I need an order
02:27:50 <Haskellfant> (and not the one from the Ord instance)
02:27:58 <Haskellfant> so Set is not really an option
02:28:10 <frerich> You could use 'break' though, no?
02:28:47 <Cale> yeah
02:29:10 <Cale> > break (== 1) [4,3,1,2,1,2,3]
02:29:11 <lambdabot>  ([4,3],[1,2,1,2,3])
02:29:21 <Cale> > break (== 1) [4,3,2,2,3]
02:29:22 <lambdabot>  ([4,3,2,2,3],[])
02:29:23 <opqdonut> Haskellfant: consider a wrapper type that has the right Ord instance
02:29:55 <Haskellfant> opqdonut: that's not possible, the order depends on when I insert them. I really want a list
02:30:54 <jle`> it's a bit contrived but you can zip on [1..] and put those into the set and you'll preserve your order...but you wouldn't be deleting by equality
02:31:03 <jle`> anyways sometimes the best thing for a situation really is a list
02:31:36 <frerich> Haskellfant: I suspect you could have "delete' x xs = case break (== x) xs of { (left, []) -> (left, False); (left, (r:rs)) -> (left ++ rs, True)  }"
02:31:42 <Cale> > let delete' x xs = case break (== x) xs of (us, []) -> (xs, False); (us, v:vs) -> (us ++ vs, True) in delete' 1 [4,3,1,2,1,2,3]
02:31:43 <lambdabot>  ([4,3,2,1,2,3],True)
02:31:50 <Cale> > let delete' x xs = case break (== x) xs of (us, []) -> (xs, False); (us, v:vs) -> (us ++ vs, True) in delete' 1 [4,3,2,2,3]
02:31:52 <lambdabot>  ([4,3,2,2,3],False)
02:32:56 <Haskellfant> yeah that's what I implemented, thanks
02:33:41 <Cale> This would be another use case for separate
02:34:34 <Cale> @let separate [] = []; separate (x:xs) = ([],x,xs) : [(x:us,y,vs) | (us,y,vs) <- separate xs]
02:34:37 <lambdabot>  Defined.
02:34:50 <Cale> > separate [4,3,2,1,2,3]
02:34:52 <lambdabot>  [([],4,[3,2,1,2,3]),([4],3,[2,1,2,3]),([4,3],2,[1,2,3]),([4,3,2],1,[2,3]),([...
02:35:27 <Cale> > [us ++ vs | (us,x,vs) <- separate [4,3,2,1,2,3], x == 1]
02:35:29 <lambdabot>  [[4,3,2,2,3]]
02:35:36 <Cale> > [us ++ vs | (us,x,vs) <- separate [4,3,1,2,1,2,3], x == 1]
02:35:38 <uggwar> where is the best place to ask for help regarding compiling a cross compiler?
02:35:38 <lambdabot>  [[4,3,2,1,2,3],[4,3,1,2,2,3]]
02:35:49 <merijn> uggwar: Probably #ghc ?
02:36:01 <uggwar> :-) ha! thanks!
02:37:02 <merijn> uggwar: You're in the not-so-well-tested and uncharted territories of GHC, since cross-compilation has only recently gotten a bunch of attention, so I'm unsure of exactly what state it is in
02:37:29 <Cale> Oh, of course, we don't even need separate, select will do too:
02:37:54 <uggwar> merijn: yes, that is what i have stumbled upon. seems like the stage1 compiler generates some weird code
02:37:56 <aawe> merijn: where can I read more?
02:38:01 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
02:38:04 <lambdabot>  Defined.
02:38:05 <aawe> on the current discussions etc
02:38:23 <aawe> (if you have any specific threads in mind)
02:38:45 <Cale> > [xs | (x,xs) <- select [4,3,1,2,1,2,3], x == 1] -- ways to delete a 1
02:38:47 <lambdabot>  [[4,3,2,1,2,3],[4,3,1,2,2,3]]
02:39:18 <frerich> > select [4,3,2,1,2,3]
02:39:19 <lambdabot>  [(4,[3,2,1,2,3]),(3,[4,2,1,2,3]),(2,[4,3,1,2,3]),(1,[4,3,2,2,3]),(2,[4,3,2,1...
02:39:24 <frerich> Ah...
02:40:11 <merijn> aawe: ghc-devs mailing list and hanging out in #ghc are the best way to follow developments
02:40:44 <merijn> aawe: Also, you can lurk on phabricator and seeing which diffs are being reviewed and read their description (hell, review the code, more eyeballs is always good!)
02:41:38 <merijn> aawe: Also, the GHC wiki has lots of discussion/proposals on a billion things
02:42:10 <Cale> There's a lot of useful stuff you can do with select and separate, and I really wish they were in Data.List
02:42:17 <jle`> me too
02:42:25 <Cale> (but that seems a little bit unlikely apparently)
02:42:28 <jle`> i always have to look up simon marlow's select all the time
02:43:14 <Cale> Oh, does he use it somewhere?
02:43:41 <aawe> merijn: thank you very much
02:44:07 <kaiyin> In the diagrams package, there is a (#) operator, and its info says infixl 8 #, why is the fixity set at 8 here?
02:44:15 * hackagebot tex2txt 0.1.0.0 - LaTeX to plain-text conversion  http://hackage.haskell.org/package/tex2txt-0.1.0.0 (vdaudaravicius)
02:44:19 <mauke^> it's a nice round number
02:44:53 <frerich> Cale: I never heard of 'select' and 'separate' before, I suppose they are conventional names for those functions? Is 'separate' related to zippers by any chance?
02:45:07 <kaiyin> mauke^: :) 0 is arguably rounder.
02:45:21 <mauke^> frerich: they both are :-)
02:45:27 <Cale> frerich: Well, they're my names for these functions. They're both related to zippers
02:45:47 <mauke^> I may have invented the name "select"; I don't remember
02:46:14 <akegalj> why is this non exhaustive pattern? http://lpaste.net/1913388298072489984
02:46:26 * frerich can never remember whether it's 'seperate' or 'separate' :-(
02:47:14 <merijn> kaiyin: Probably high so that it's higher than, for example, <> (mappend from Monoid)
02:47:23 <indiagreen> frerich: a mnemonic: “part” → “separate”
02:47:32 <m0rphism> frerich: ohh, same here, don't feel alone ;)
02:47:41 <kaiyin> merijn: why does it need be higher than <>?
02:47:43 <mauke^> my trick is to not have english as my first language
02:47:46 <frerich> akegalj: Actually, it does look exhaustive to me.
02:47:56 <mauke^> I know how "se-pa-rat" is supposed to sound
02:48:08 <akegalj> frerich: but -Wall is saying thats non exhaustive
02:48:31 <mauke^> frerich: how appropriate :-)
02:48:34 <mauke^> akegalj: it's a spelling issue
02:48:51 <akegalj> mauke^: ah...thnx
02:48:53 <frerich> Ah, Frist vs. First!
02:48:56 * frerich sighs
02:49:00 <mauke^> and probably Greater vs Grater
02:49:07 <Cale> https://mail.haskell.org/pipermail/libraries/2008-February/009273.html
02:49:20 <akegalj> mauke^: yes, english
02:49:33 <mauke^> frerich: ^
02:49:35 <merijn> kaiyin: So you can write "foo # bar <> quux # xyzzy" or something. IIRC diagrams takes a monoidal approach of combining things together, so make sure it works nicely with infix mappend is important
02:49:51 <dashed> anyone know how to use this?  https://www.irccloud.com/pastebin/yBcRklVi
02:50:17 <mauke^> dashed: what
02:50:34 <dashed> It doesn't seem to "work"
02:50:34 <kaiyin> merijn: i see. 
02:50:35 <merijn> I'm guessing dashed doesn't know record syntax
02:50:39 <dashed> :<
02:50:59 <tero-> to efficiently remove duplicate elements in a list while discarding order, is Set.toList . Set.fromList good? or (map head) . group . sort ? or something else?
02:51:00 <Cale> https://mail.haskell.org/pipermail/libraries/2010-July/013843.html -- more, lol
02:51:05 <jle`> dashed: what do you mean by work?
02:51:07 <merijn> dashed: Can you show how you're trying to use it and which error you get?
02:51:07 <mauke^> dashed: define "work"
02:51:24 <jle`> a text file like that shouldn't really compile in haskell
02:51:28 <merijn> tero-: Through set should be reasonably efficient
02:51:39 <mauke^> tero-: those look both ok
02:51:43 <Cale> Whenever I suggest adding these functions to Data.List, Conor McBride helpfully adds all the detail about how they're algebraically relevant operations.
02:51:45 <jle`> you either need a value called "main", or define a module
02:52:16 <m0rphism> dashed: Nothing wrong with the code you've posted. What's the error you're getting?
02:52:36 * frerich thinks he owes mauke^ and indiagreen big time for settling the separate vs. seperate issue once and for all!
02:53:35 <frerich> Reminds me how happy I was when I noticed that the list functions were just called 'sepBy' or so, side-stepping the issue :)
02:54:57 <dashed> parseExpr (WrappedBaseExpr BaseExpr) { getBaseExpr = be, scopeLevel = scope, getBindings=bindings} = ...
02:55:04 <dashed> that's generally what I'm trying to do
02:55:07 <aawe> "Seperate   1. Misspelling of separate."
02:55:33 <dashed> This is the type I defined: parseExpr :: (WrappedBaseExpr BaseExpr) -> MaybeAST Expr
02:55:47 <aawe> frerich:^
02:55:53 <jle`> can you post full code?
02:56:05 <jle`> and the error?
02:56:20 <dashed> error https://www.irccloud.com/pastebin/fCEC2Rv2
02:56:35 <m0rphism> what is WrappedBaseExpr?
02:56:38 <m0rphism> full code please ^^
02:57:17 <m0rphism> (also the context where you are using it, that is the complete part referenced by the error message)
02:57:45 <dashed> code https://www.irccloud.com/pastebin/hZo1REzz
02:58:00 <dashed> this isn't the full code
02:58:11 <m0rphism> It's enough, thanks
02:58:34 <dashed> I think I'm not defining the types properly
02:58:47 <aawe> it's the function pattern matching
02:59:00 <Cale> frerich: Yeah, apparently it's from Latin parare in both cases (part and separate, also pare)
02:59:07 <dashed> im not intimately familiar with how pattern matching works in tandem with records
02:59:24 <m0rphism> parseExpr (WrappedBaseExpr be scope bindings) = ...
03:00:28 <m0rphism> Or if you want to go deeper into be:
03:00:28 <m0rphism> parseExpr (WrappedBaseExpr (BaseExpr a scope' bindings')  scope bindings) = ...
03:00:35 <Cale> Also, the se- prefix is the same in separate, secede, seclude, seduce, segregate
03:00:58 <m0rphism> The thing you did, using record syntax in pattern matching is also possible, but only as a ghc extension and slightly different syntax
03:01:30 <m0rphism> record syntax is the BaseExpr { getExpr = ..., ... } notation
03:01:42 <m0rphism> which constructs something by named arguments
03:02:07 <dashed> (WrappedBaseExpr x newScopeLevel bindings) seems to work
03:02:13 <dashed> especially for assigning values
03:02:52 <dashed> why doesn't it require an explicit kind?
03:03:02 <dashed> type inference?
03:03:16 <m0rphism> what do you mean by explicit kind?
03:03:18 <aawe> dashed: types are in the type signature (parseExpr :: type)
03:03:28 <aawe> dashed: in the definition, you use constructors
03:03:34 <aawe> that happen to have the same names as the types
03:03:40 <m0rphism> ahh, yeah, what aawe said
03:03:51 <dashed> so I don't need to put BaseExpr?
03:04:13 <aawe> dashed: more context please. put where?
03:04:17 <m0rphism> only if you want to match the things inside the contained base expression
03:04:48 <m0rphism> parseExpr x = ...   works too
03:05:10 <m0rphism> but if you want to match on what's inside x, you can do
03:05:10 <m0rphism> parseExpr (WrappedBaseExpr a b c) = ...
03:05:31 <dashed> thanks!
03:05:41 <m0rphism> Afterall there could be multiple constructors, i.e. there could also be
03:05:41 <m0rphism> parseExpr (WrappedBaseExpr2 a b) = ...
03:05:44 <dashed> is this form preferred over { } form?
03:06:11 <m0rphism> the { } form (record syntax) does not work in pattern matching without extensions
03:06:22 <dashed> ah I see
03:06:27 <m0rphism> an alternative (if you fear getting confused with names) is to do the following
03:06:52 <m0rphism> parseExpr we = doSomethingWith (getBaseExpr we)
03:06:52 <mauke^> what do you mean, record syntax doesn't work in patterns?
03:07:03 <m0rphism> what he tried in the beginning
03:07:20 <m0rphism> f (w { name = v }) = ...
03:07:31 <m0rphism> in the context of defining f
03:07:35 <mauke^> that works fine
03:07:39 <mauke^> and you don't need the parens
03:07:41 <m0rphism> it does? :O
03:08:00 <dashed> o.O
03:08:21 <mauke^> > case Node 42 [] of Node{ rootLabel = x } -> x
03:08:23 <lambdabot>  42
03:08:39 <dashed> m0rphism: ah yeah I understand the "getters" sugar
03:09:47 <m0rphism> mauke^: Ohh you're right
03:09:54 <m0rphism> mauke^: thanks for the correction
03:10:48 <m0rphism> dashed: Ok then, if you prefer that, you could also write
03:10:49 <m0rphism> parseExpr WrappedBaseExpr { getBaseExpr = be, ... } = ...
03:11:20 <dashed> ah.. i would just remove BaseExpr
03:12:22 <m0rphism> The ... are not of the language, by the way, I was just too lazy to write the whole expression
03:12:22 <dashed> m0rphism mauke^: thanks for the help! :D
03:12:33 <dashed> yeah I know :P
03:12:56 <m0rphism> but yes, you don't have to list all record fields, you are allowed to only match on the ones you need
03:13:02 <m0rphism> dashed: you're welcome :)
03:16:07 <m0rphism> mauke^: ahh, now I know where my confusion came from. I was confusing the regular pattern matching on records with -XNamedFieldPuns ;)
03:32:51 <ep0> hello
03:33:15 <ep0> i have a small question, might be silly, but I think it should help a little more to understand how haskell works
03:33:59 <ep0> i have a list of functions and i'm trying to map them over a list of numbers
03:34:01 <ep0> map $ [( + 1), ( * 1)] [1, 2, 3]
03:34:18 * hackagebot ede 0.2.5 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.5 (BrendanHay)
03:34:23 <ep0> this is what I came up with, but it's not working
03:34:44 <ep0> actually map $ [( + 1), ( * 2)] [1, 2, 3]
03:35:03 <ep0> i'm trying to achieve [[2, 3, 4], [2, 4, 6]]
03:35:06 <mauke^> that's an error because [...] [...] is an error
03:35:13 <mauke^> you can't apply a list to a list
03:35:22 <ep0> i'm applying $
03:35:26 <mauke^> no
03:35:40 <ep0> well at least that's what i'm thinking i'm applying
03:35:51 <mauke^> well, yes, but you're applying ($) to map and [( + 1), ( * 2)] [1, 2, 3]
03:35:52 <ep0> you're right
03:35:56 <jle`> function application binds tightest
03:35:59 <jle`> so that's reappy
03:36:07 <jle`> map $ ([(+1),(*2)] [1,2,3])
03:36:07 <ep0> you're correct
03:36:09 <jle`> *really
03:36:39 <raek> ep0: what do you want the code to return?
03:36:47 <ep0> [[2, 3, 4], [2, 4, 6]]
03:36:48 <mauke^> > map (\f -> map f [1, 2, 3]) [( + 1), ( * 2)]
03:36:49 <lambdabot>  [[2,3,4],[2,4,6]]
03:37:19 <echo-area> How many monad transformers are used together normally?
03:37:38 <jle`> echo-area: that's like saying how many items do people usually put in their lists :)
03:37:39 <kaiyin> Could anyone explain how applyAll works here? https://gist.github.com/kindlychung/adb3561c87fc34eb68bf
03:37:52 <kaiyin> applyAll :: [a -> a] -> a -> a
03:37:57 <ep0> @mauke i understand you're code
03:37:57 <lambdabot> Unknown command, try @list
03:38:07 <ep0> though i thought you can also use $
03:38:18 <mauke^> > map (\f -> map f $ [1, 2, 3]) $ [( + 1), ( * 2)]
03:38:19 <ep0> or maybe i misunderstood how $ is used
03:38:20 <lambdabot>  [[2,3,4],[2,4,6]]
03:38:30 <echo-area> jle`: I tried to combine StateT and MaybeT together just for fun, but the types involved were weird
03:38:51 <jle`> these days monad transformers (or at least stacked ones) are really only used at the exit point of your programming logic...your actual programs tend to be parametric over "contexts that have state", etc.
03:38:51 <echo-area> E.g. `v <- runMaybeT (runStateT g 0)`
03:39:39 <jle`> that, or people just write their own types that combine effects directly
03:39:47 <jle`> echo-area: weird in what way?
03:40:11 <raek> ep0: ($) is just function application
03:40:26 <raek> f $ x = f x
03:40:33 <frerich> ep0: Maybe you were also thinking of something like 'map (\f -> zipWith ($) (repeat f) [1,2,3]) [(+1), (*2)]'; i.e. you're explicitely applying each function to each value using '$'
03:41:11 <merijn> kaiyin: Well, if applyAll has type "[a -> a] -> a -> a" that means we need to somehow combine functions of type "a -> a" into one, right? Can you think of a function that does that? :)
03:41:49 <merijn> echo-area: It helps to translate the transformer types by what they represent
03:41:52 <kaiyin> merijn: (.) ?
03:41:53 <merijn> echo-area: For example
03:41:56 <merijn> kaiyin: Right
03:42:06 <merijn> :t foldr (.) id
03:42:07 <ep0> @roek (+ 1) $ 1
03:42:07 <lambdabot> unexpected "+": expecting number, "d" or "("
03:42:07 <lambdabot> [b -> b] -> b -> b
03:42:18 <ep0> i understand that applies 1 to (+ 1)
03:42:32 <merijn> kaiyin: Just compose all of them together and if the list is empty, simply use "id" :)
03:42:33 <ep0> and I also thought i could use it in map
03:42:37 <ep0> without labda functions
03:42:51 <merijn> @unmtl StateT s (MaybeT IO) a
03:42:51 <lambdabot> s -> (MaybeT IO) (a, s)
03:42:53 <kaiyin> merijn: cool. 
03:43:02 <merijn> @unmtl MaybeT IO a
03:43:02 <lambdabot> IO (Maybe a)
03:43:10 <echo-area> jle`: In fact I have type `StateT Int (MaybeT IO) String`, so the type of runStateT is `Int -> MaybeT IO (String, Int)`, and the above expr has type `IO (Maybe (String, Int))`.  I think this is meaningless, i.e. there must be some state, and Nothing as a state is, at least to me, invalid
03:43:35 <merijn> echo-area: So "StateT s (MaybeT IO) a" boils down to: "s -> IO (Maybe (a, s))"
03:43:47 <jle`> @unmtl StateT s (MaybeT IO) a
03:43:47 <lambdabot> s -> (MaybeT IO) (a, s)
03:44:01 <jle`> @unmtl MaybeT (StateT s IO) a
03:44:02 <lambdabot> (StateT s IO) (Maybe a)
03:44:13 <jle`> i guess unmtl doesn't understand MaybeT
03:44:16 <merijn> echo-area: Why must there be a state? You are forgetting that Maybe's monad short-circuits
03:44:25 <raek> ep0: but you were giving a list of functions as the first argument of map, not a function
03:44:40 <jle`> remember that these monad transformers are really just newtype wrappers over normal plain ol' functions
03:44:50 <merijn> echo-area: So if ANY intermediate transition returns Nothing the whole operation is Nothing
03:44:51 <jle`> or values
03:45:06 <jle`> just like how we use newtype wrappers over numbers to get Sum, Product, etc. Monoid instances
03:45:14 <jameseb> ep0: maybe you were thinking of <$>, which is a synonym for fmap, which is just map for lists?
03:45:18 <jle`> and have different implementations for mappend
03:45:30 <jle`> we use these to wrap and give different implementations for (>>=)
03:45:35 <raek> ep0: if you want to pass the $ function itself to map, then you need to wrap it in parentheses: map ($) ...
03:45:43 <merijn> echo-area: If you compose "foo :: s -> IO (Maybe (a, s))" and "bar :: s -> IO (Maybe (b, s))" and foo returns "Nothing", then clearly "bar" is skipped completely
03:46:09 <frerich> ep0: Note that 'map' will apply '$' to just one argument, so if you do 'map ($)' you will end up with a list of functions.
03:46:10 <ep0> jameseb: i'll take a look at fmap
03:46:19 <jameseb> > (<$> [1,2,3]) <$> [(+1), (*2)]
03:46:20 <lambdabot>  [[2,3,4],[2,4,6]]
03:46:52 <jle`> StateT Int (MaybeT IO) String is just a newtype wrapper over `Int -> IO (Maybe (String, Int))`.  MaybeT (StateT Int IO) String is just a newtype wrapper over `Int -> IO (Maybe String, Int)`
03:47:13 <jle`> if you try to imagine how you would implement (>>=) over these types... the result you get is really the only meaningful (>>=)
03:47:27 <jle`> so we have two different behaviors of (>>=) here
03:47:45 <ep0> raek: thanks.. will try some more and come back if i get it to work
03:47:47 <jle`> so you have to decide which one you really *want*
03:47:57 <ep0> raek: my goal is not to use labmdas
03:48:33 <jameseb> ep0: fmap just does the same as map when used on lists but it has an infix form which may be useful what what you want
03:48:48 <raek> ep0: you need to use two "levels" of map for this to work
03:49:01 <ep0> rake: i think you're right
03:49:15 <jameseb> so something like (<$> [1,2,3]) <$> [(+1), (*2)]
03:49:18 <ep0> raek: i think you're right
03:50:24 <raek> but it should be possible to write it in "point free" style (without lambdas). but it might not necessarily be pretty.
03:52:01 <m0rphism> ep0: For that goal you might be interested in the pointfree and hlint tools. The former converts expressions into pointfree ones (removing lambda in favor of composition), the latter is a linter which often provides helpful suggestions, also to remove lambdas.
03:52:32 <ep0> m0rphism: i'm pretty new to haskell, so i think that is a little to much right now for me :D
03:52:43 <ep0> m0rphism: but thank you for the suggestion
03:52:48 <m0rphism> ep0: However, pointfree does this unconditionally, which for more complex expressions often results in arguable obscure code ;)
03:53:19 <m0rphism> ep0: Yeah, no rush. Just wanted to point out that they are there. It's a good idea not to drown in tooling before you even required the tooling :)
03:53:42 <ep0> has anyone used this http://www.stephendiehl.com/posts/vim_haskell.html ?
03:54:16 <simg> hi. I'm getting the following error when trying to run some example code (digestive-functors fwiw) using ghci. "Couldn't match type Text.Blaze.Internal.MarkupM' with `blaze-markup-0.6.3.0:Text.Blaze.Internal.MarkupM'". I understand the reason for this, but how would I force ghci to use a particular version of the package ?        If I use ghc-pkg hide to hide the 0.6.3.0 version I get the...
03:54:17 <simg> ..."reverse" error message - Couldn't match type `blaze-markup-0.7.0.2:Text.Blaze.Internal.MarkupM'  with `Text.Blaze.Internal.MarkupM'
03:54:22 <m0rphism> ep0: almost the same setup, yes
03:54:37 <m0rphism> ep0: but I recently switched to emacs + evil vim emulation
03:54:45 <ddellacosta> I guess I want a Sequence if I want fast append operations?  (vs. List or Vector)
03:55:30 <ep0> m0rphism: i'm pretty happy with vim and i'm trying to make it help in learning haskell
04:02:12 <merijn> ep0: Personally I only use syntastic + hdevtools
04:02:25 <echo-area> I see.  I didn't come up with a meaningful scenario.  I did this to improve my understanding of monads, but I still had to implement some part of functions with the help of manual type inferring.  I need to practice more.  Thank you.
04:03:00 <merijn> I have a 7.8/7.10 compatible and sandbox aware branch of hdevtools here https://github.com/merijn/hdevtools (hackage doesn't seem to be updated anymore?)
04:03:12 <frerich> ep0: I use syntastic and 'vim-hdevtools'. Actually, I also seem to hvae something which runs 'hlint' automatically, not sure whether that's Syntastic or something else even.
04:03:37 <merijn> echo-area: If you haven't yet, I recommend implementing both State and StateT (see here: https://gist.github.com/merijn/098106abd45c940dab09) as exercise
04:03:50 <merijn> frerich: syntastic can run hlint if installed, afaik
04:03:59 <frerich> ep0: There's another nice thing (ghc-mod or so?) which syntax-checks code as you type. It also lets you press some key on a Haskell expression to see the type of that expression. It uses some background server for this though.
04:04:14 <merijn> frerich: You're confusing hdevtools with ghc-mod :)
04:04:27 <merijn> frerich: hdevtools uses a background server for typechecking/querying types :)
04:04:39 <ep0> frerich: i'll check it out
04:04:42 <merijn> ghci-ng will, hopefully, soon obsolote both ghc-mod and hdevtools
04:05:21 <frerich> merijn: Heh, indeed. I got so used to my vim plugins, I don't even know who's providing what. In fact, I'm not even sure how much a vanilla vim does...
04:06:01 <m0rphism> merijn: frerich: Out of curiosity: How much time does your syntastic check on save take? For me it was almost two seconds, where whole vim was frozen. I wonder if this was a problem with my configuration, though.
04:06:34 <frerich> morphism: I didn't even notice it pauses...
04:06:54 <frerich> m0rphism : ^
04:07:03 <m0rphism> ok, then this was probably related to my setup, thanks :>
04:09:40 <tdammers> no vim plugins here except ftplugin
04:09:48 <tdammers> even considering rolling without syntax highlighting
04:24:19 <tdammers> hrmphh, this is inconvenient
04:24:38 <tdammers> I want IntMap.Strict, and I want QuickCheck, and I want everything to compile on 7.4 *and* 7.6
04:25:19 <tdammers> but on 7.4, quickcheck wants containers < 0.5, which doesn't have IntMap.Strict
04:25:35 <ggVGc> sounds like it's time to hack some stuff up
04:25:40 <ggVGc> for you
04:25:53 <tdammers> I was hoping there'd be a better solution than #ifdefing everything into submission
04:26:40 <ggVGc> unrelated, why do you want to not use syntax highlighting?
04:26:44 <ggVGc> tdammers: ^
04:28:11 <tdammers> doesn't add an awful lot, really, is all
04:28:33 <sgronblo> ggVGc: playing devils advocate and assuming from your nick you are a vim user one could ask "why do you want to not use an IDE?" :)
04:29:07 <tdammers> sgronblo: vim can be part of an IDE
04:29:20 * hackagebot pagerduty 0.0.2 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.2 (BrendanHay)
04:29:21 <tdammers> (playing meta-devil's advocate here)
04:31:46 <sgronblo> tdammers: true true, but lets assume its not for the sake of argument :)
04:34:31 <ggVGc> sgronblo: sure, I'm not saying it's wrong to not use syntax highlighting. Just curious why one makes that choice
04:34:48 <ggVGc> to me it's something that makes my programming much more comfortable, and doesn't add anything negative really
04:36:07 <ggVGc> the only overhead I see in syntax highlighting is some files/filetypes where it's super slow(mostly large XML-files), and in those cases I turn it off
04:36:41 <tdammers> it gives a false sense of support, IMO
04:37:20 <tdammers> some IDEs actually do it mostly right, but they have to practically compile the entire project all the time, and this tends to be really heavy on resources
04:37:23 <ggVGc> tdammers: not sure what that means. What kind of support?
04:37:46 <tdammers> you rely on the syntax highlighting to reveal syntax errors
04:38:02 <ggVGc> oh, I have never done that
04:38:04 <tdammers> "if it doesn't highlight right, then I probably made a typo"
04:38:21 <ggVGc> yeah, I don't think about it like that
04:38:36 <tdammers> but if you want that kind of support, you need a really powerful highlighter - more than what vim can possibly do
04:38:41 <hodapp> auto-indentation can serve the same function
04:38:50 <ggVGc> to me it just makes stuff more comfortable to read
04:38:52 <hodapp> if things don't indent right, maybe I screwed something up
04:39:12 <tdammers> idk, I like my tools dumb and submissive
04:39:49 <sgronblo> if you go down the slippery slope then you wouldnt use ghci because ghci could have a bug that might compile your software incorrectly? :)
04:40:14 <tdammers> ghci serves a different purpose
04:45:22 <kaiyin> https://gist.github.com/kindlychung/adb3561c87fc34eb68bf how do i add margins to the whole diagram?
04:49:24 <kaiyin> i am trying to install gtk but got this error: Configuring cairo-0.13.1.0... setup: The program 'pkg-config' version >=0.9.0 is required but it could not be found.
04:49:55 <kaiyin> the problem is that the current version of pkg-config is 0.28, and there is no 0.9 out there.
04:50:06 <kaiyin> is there a way to disable this requirement?
04:51:23 <bergmark> kaiyin: i've had similar issues with other packages, gtks cabal file lists Cabal-Version: Cabal >= 1.18, try changing that to >= 1.10
04:52:11 <kaiyin> bergmark: my cabal version is 1.22, so that shouldn't be the issue here.
04:52:45 <bergmark> kaiyin: i've had issues even though my cabal version was above that
04:53:13 <kaiyin> but how do you change that if you are doing cabal install gtk?
04:53:27 <bergmark> cabal get gtk
04:54:18 <echo-area> merijn: Are Functor and Applicative the standard types?  I got error like "‘pure’ is not a (visible) method of class ‘Applicative’"
04:54:25 <echo-area> *classes
04:54:38 <merijn> echo-area: Applicative isn't in the Prelude yet in 7.8 (it will be in 7.10)
04:54:46 <merijn> So you need to import Control.Applicative
04:54:59 <echo-area> I did.
04:55:10 <kaiyin> bergmark: done. then what should i do?
04:55:12 <echo-area> import Control.Applicative (Applicative)
04:55:27 <echo-area> Is this not enough?
04:55:43 <Cale> echo-area: That only imports the class and not its methods
04:55:49 <bergmark> kaiyin: change the cabal file and then cabal install gtk/
04:55:53 <Cale> Leave the (Applicative) bit out, you want the whole module
04:55:57 <echo-area> Oh I see, I need to import the other names as well
04:56:31 <Cale> Or I suppose you could make it (Applicative(..))
04:56:41 <Cale> but there's no need to be so picky there
04:58:11 <echo-area> Anyway I have to go home now.  I will finish the exercise.  Thank you all for the help!
04:59:22 * hackagebot pagerduty 0.0.3 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.3 (BrendanHay)
05:00:37 <kaiyin> bergmark: that error goes away indeed, strange, why does this has anything to do with version requirement of cabal?
05:00:46 <kaiyin> anyways, I got another error: Package xcb-shm was not found in the pkg-config search path. Perhaps you should add the directory containing `xcb-shm.pc'
05:05:51 <merijn> pkg-config is used to track non-haskell dependencies (usually C/C++ libraries), so it's not finding some C library you need
05:12:24 <kaiyin> merijn: yes, and it's solved by doing this: export PKG_CONFIG_PATH="/opt/X11/lib/pkgconfig:$PKG_CONFIG_PATH"
05:14:23 * hackagebot configifier 0.0.3 - parser for config files, shell variables, command line args.  http://hackage.haskell.org/package/configifier-0.0.3 (MatthiasFischmann)
05:32:36 <kaiyin> > [(3 * 2) .. (7 * 6)]
05:32:37 <lambdabot>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3...
05:32:43 <kaiyin> how do you reason about this?
05:33:13 <kaiyin> i would expect only 5 numbers.
05:33:46 <opqdonut> why would you expect that?
05:34:09 <opqdonut> that's the same as [6..42], which includes all the numbers between 6 and 42
05:34:12 <opqdonut> did you mean
05:34:23 <opqdonut> > [6,12..42]
05:34:24 <lambdabot>  [6,12,18,24,30,36,42]
05:34:55 <kaiyin> oh, I see. I got confused.
05:59:25 * hackagebot ansi-wl-pprint 0.6.7.2 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.2 (HerbertValerioRiedel)
06:07:26 <kaiyin> It seems mathjax cdn is down. Is there a way to inject from another cdn site into http://projects.haskell.org/diagrams/doc/manual.html? 
06:10:27 <mauke^> works here
06:14:55 <kaiyin> mauke^: strange, is my computer hijacked by some virus?
06:18:05 <merijn> mauke^: Maybe you have it cached?
06:18:49 <mauke^> I've never visited that page before
06:19:54 <mauke^> http://cdn.mathjax.org/mathjax/latest/jax/output/HTML-CSS/jax.js?rev=2.5.1 took 76ms to finish with 200 OK
06:20:42 <mauke^> interestingly http://downforeveryoneorjustme.com/cdn.mathjax.org also thinks it's down
06:24:30 <jtanguy> mathjax is fine for me too
06:26:05 <kaiyin> merijn: clearing cache does not help here.
06:26:32 <kaiyin> it's not working on any of firefox, chrome or safari, on osx
06:27:02 <kaiyin> The strange thing is, if I fire up a linux virtual machine, and open a browser there, everything works like a charm.
06:35:44 <geekosaur> I just loaded that page (chrome os x) no problem, fwiw
06:35:57 <christiaanb> Hi, does anyone know how I generate haddock links to non-imported type-operators? For example, 'GHC.TypeLits.+' gives a base-4.8.0.0/GHC-TypeLits.html#v:-43- link... instead of the base-4.8.0.0/GHC-TypeLits.html#t:-43- link
06:39:13 <hvr> christiaanb: try in #haddock, but I'm afraid this is one of haddock's limitations that i can't let you provide namespace hints to blind references
06:40:13 <christiaanb> So I should do: import GHC.TypeLits (type (+)); import Prelude hiding ((+)) ?
06:42:27 <christiaanb> hvr: tnx, I'll try in #haddock
06:43:40 <bazqux> How can one rewrite?: do\n foo\n bar\n
06:43:58 <bazqux> To avoid do syntax.
06:44:09 <c_wraith> bazqux: foo >> bar
06:44:19 <c_wraith> @undo do { foo ; bar }
06:44:19 <lambdabot> foo >> bar
06:44:27 * hackagebot debian 3.87.2 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.87.2 (DavidFox)
06:45:21 <bazqux> c_wraith: Ah thanks. I thought it must be something like that.
06:46:23 <EvanR> is there a syntax trick to convert A to Maybe B using an incomplete case or something
06:46:30 <EvanR> so _ -> Nothing isnt necessary
06:46:52 <EvanR> i see lambda case
06:46:56 <frerich> EvanR: Try the 'maybe' function.
06:47:04 <merijn> cast?
06:47:08 <EvanR> maybe undoes what im saying
06:47:08 <c_wraith> fmap?
06:47:09 <merijn> :t cast
06:47:10 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
06:47:23 <c_wraith> I mean..  I really have no idea what you're asking
06:47:28 <frerich> EvanR: Sorry, I misread. Ignore me.
06:48:01 <EvanR> i have a sum type A and want Maybe B based on one of the casess
06:48:16 <c_wraith> EvanR: Oh.  use a Prism!  >_>
06:48:17 <sx> EvanR: then probably no.
06:48:18 <frerich> EvanR: Why bother with 'Maybe B' instead of just 'B' if you don't want a Nothing case?
06:48:35 <c_wraith> EvanR: Seriously, Prisms have all that machinery built in already
06:49:07 <sx> c_wraith: I guess you have to do the pattern match by implementing the prism, do you?
06:49:12 <EvanR> frerich: yeah youre right, its annoying to go through A at all
06:49:23 <EvanR> c_wraith: ah
06:49:44 <c_wraith> sx: if you write it manually, yes - but that's not usually necessary.
06:52:50 <haasn> If I understand the question correctly, you have a function like safeHead (x:_) = Just x; safeHead _ = Nothing and you want to make this smaller?
06:53:08 <EvanR> ill paste my function
06:53:15 <c_wraith> haasn: not as I understood it.
06:53:35 <EvanR> http://lpaste.net/129119
06:53:47 <c_wraith> haasn: It's about reducing syntactic overhead for caring only about one case of a sum type
06:54:19 <mauke^> c_wraith: isn't that what haasn's example is?
06:54:20 <haasn> c_wraith: That seems like a special case
06:54:23 <haasn> of what I described
06:54:44 <EvanR> yes haasn its like that
06:54:54 <haasn> safeCons (x:xs) = Just (x,xs); safeCons _ = Nothing might have been a closer example for that in particular
06:55:01 <haasn> Uncons
06:55:06 <EvanR> would be nice if it wasnt in the sum type in first place
06:55:39 <haasn> EvanR: prisms cover this special case very well; in the sense that they can be automatically generated by ‘lens’
06:55:52 <EvanR> yum
06:55:52 <haasn> Of course, you could write an equivalent “automatically generate the right pattern match” function using TH yourself
06:56:01 <EvanR> also yum
06:56:25 <haasn> (Prisms are also handy in that they can be composed etc.)
06:57:02 <EvanR> the prism haddock is very detailed
06:59:56 <EvanR> Overloaded Prismoid Mutator  If you see this in a signature for a function, the function is expecting a Prism, not some kind of alien invader.
07:01:33 <EvanR> haasn: i think i like your example better, have a bunch of these top level functions somewhere
07:05:33 <mpickering> How can I specify that my test file depends on a module which isn't exposed?
07:06:37 <bergmark> mpickering: include it as a source dir
07:10:08 <athan> Hi everyone. Can I make a custom data type an instance of QuickCheck's Property with a DeriveGeneric clause, or something similar?
07:10:19 <EvanR> on one hand it feels like of silly that a parser would go through the trouble of putting together a large sum type, and then something else splits it up again. but then again that seems like... modular?
07:10:49 <EvanR> i guess thats what lens and friends are for
07:11:49 <athan> erm, not property, Arbitrart
07:11:53 <athan> Arbitrary* ><
07:13:05 <jkarni> athan: the basic-sop package gives you that
07:13:23 <jkarni> athan: and I think the "regular" package too
07:13:42 <athan> jkarni: I just saw! Sorry, I'll dig a bit more. Thank you!
07:16:57 <Fuuzetsu> Using subparsers with optparse-applicative, we can encode commands like ‘git create --help’ which display help menu for the create command but is there a way to also make it display global flags? Say, every ‘git’ command needs --foo flag set so in the end we need to call ‘git --foo create blah blah blah’. I want the --foo to be mentioned in the --help for create command. Anyone know how? Hopefully I'm clear.
07:18:57 <athan> Fuuzetsu: I'm actually working on something like this
07:19:23 <athan> It's a "nested" optparse. Basically a rose tree of (commands, help sequences)
07:19:29 * hackagebot int-cast 0.1.2.0 - Checked conversions between integral types  http://hackage.haskell.org/package/int-cast-0.1.2.0 (HerbertValerioRiedel)
07:19:31 <athan> but it's not done yet :\
07:19:59 <Fuuzetsu> do you have an ETA
07:20:20 <Fuuzetsu> for now I'll most likely have to settle with a mention in README to run --help on main command first ;)
07:20:57 <athan> Fuuzetsu: Give me a month, I should have it done by then (I've got so much to do atm, sorry). I'll let you know as soon as it is
07:21:11 <Fuuzetsu> cool
07:21:29 <ep0> hi
07:21:35 <ep0> i found a paper called liskell
07:21:46 <ep0> and wanted to ask you guys what you think about it ?
07:21:50 <ep0> http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
07:22:07 <ep0> it writes: We argue that meta-programming in Haskell has not found
07:22:07 <ep0> wide-spread adoption because of the disparity between the
07:22:08 <ep0> abstract syntax tree and its visual appearance in source code
07:22:09 <jkarni> Fuuzetsu: could you maybe map the help function over all command parsers rather than using it for your main parser?
07:22:09 <ep0> form
07:22:22 <haasn> EvanR: I think the win here is modularity. Think about it this way, if an AST-generating parser is a function “unfold : x -> Tree y” and your consumer is a function “fold : Tree y -> Some z”; then sure, using “fold . unfold” is a bit silly. But on the other hand, so is writing a different copy of your parser for every ‘z’ you want to match.
07:22:49 <haasn> This way, the parts that interface with ‘x’ and the parts that interface with ‘z’ are cleanly separated
07:22:55 <haasn> And can even live in different domains / packages
07:23:06 <EvanR> yeah
07:23:17 <tdammers> also, you can hook things between the two
07:23:24 <haasn> EvanR: in this sense, lens is a decent “glue” between the two
07:23:26 <tdammers> I've done that with pandoc a few times
07:23:40 <tdammers> filter documents at the AST level
07:23:54 <haasn> But then again, that's just a special case of “constructors and pattern matching is a decent glue”
07:24:46 <EvanR> im just looking at 15 variants of the sum type, not wanting to type all the selectors, and wondering if i could have gotten by the fewer cases by combining them, and if they would have even helped
07:24:51 <haasn> The big win with lens is that it lets you compose them, and that it lets you be succinct in doing so
07:24:52 <EvanR> questioning existence
07:25:35 <Fuuzetsu> jkarni: maybe, that's why I'm asking first in case someone knows already
07:25:59 <EvanR> and also wondering if there was a better way to filter things in general
07:26:18 <EvanR> like am i insane kind of thing
07:27:14 <EvanR> thanks for the help
07:42:36 <frerich> Can anybody recommend a regexp library which also works on Windows without any Unix compat stuff (i.e. not pcre-light)?
07:43:10 <frerich> There's a whole bunch of them on Hackage, maybe there is some sort of quasi-standard like Aeson for JSON?
07:43:18 <alexclark> is there a way to create a global level let in haskell?  Like I want to say billion = 1e9, and that applies everywhere, so is there a way to set that constat?
07:43:23 <jkarni> is there any way at all of distinguishing a function of arbitrarily many arguments that is fully polymorphic (mentions no concrete types) from non-fully polymorphic ones? I was trying to capture some modal logics in haskell types, but I guess I shouldn't be very hopefuly about this
07:43:27 <alexclark> *constant
07:45:06 <jkarni> alexclark: the ImplicitParams extension is sort of that
07:45:57 <merijn> alexclark: What's wrong with just "billion = 1e9"?
07:46:04 <sx> alexclark, do you mean over module boundaries?
07:46:13 <merijn> Just import the module you define billion in?
07:46:30 <alexclark> merijn: I think thats what I was going for
07:47:10 <merijn> "module Constants where billion = 1e9" "module Foo where import Constants; foo = 10 * billion"?
07:47:12 <alexclark> I guess if theres no mutability everything is a constant so there doesnt need to be a keyword, right?
07:47:15 <EvanR> funny why didnt i think of that
07:47:25 <merijn> alexclark: Right, every value is always const :)
07:47:30 <EvanR> i put million = some crazy stuff to get warnings to go away and so i didnt have to put 6 zeros
07:47:41 <alexclark> const or let wouldnt make sense without var
07:48:04 <indiagreen> frerich: there's regex-tdfa
07:48:34 <merijn> frerich: Maybe it'd be easier to just write a parser and use that? Depending on your goal
07:48:45 <alexclark> EvanR: what kind of crazy stuff?
07:48:58 <indiagreen> I mean, the last time I was choosing a regex library, I spent an hour and ended up with regex-tdfa
07:49:08 <indiagreen> that's as much as I can tell
07:49:29 <EvanR> million = toEnum (10^(6::Int))
07:49:57 <merijn> EvanR: I think 1e6 requires an extension to be Int, but other than that it should work
07:50:00 <merijn> :t 1e6
07:50:01 <lambdabot> Fractional a => a
07:50:07 <EvanR> yeah i want a Double
07:50:09 <indiagreen> hm, what extension
07:50:09 <merijn> Yeah, it's considered float notation
07:50:37 <merijn> indiagreen: XNumDecimals
07:52:17 <frerich> indiagreen: Ah, thanks. For what it's worth, I now realied that I had a regexp library isntalled already (Text.Regx.Posix)
07:52:18 <merijn> I highly recommend browsing through the GHC manual for neat info like that :p
07:52:47 <Iceland_jack> (before NumDecimals) 1e6 :: Fractional a => a
07:52:48 <Iceland_jack> (after  NumDecimals) 1e6 :: Num        a => a
07:52:48 <Iceland_jack>  
07:53:32 <indiagreen> merijn: thanks!
07:54:18 <merijn> Or the Haskell Report for that matter, more people should read that instead of only LYAH/RWH and blogposts
07:54:59 <indiagreen> there should be annotated Haskell Report
07:55:07 <indiagreen> “here's what you won't know after reading LYAH”
07:55:32 <indiagreen> well, okay, “LYAH+RWH”
07:55:37 <tdammers> nothing wrong with reading blog posts, as long as you skip the ones titled "monad tutorial"
07:56:36 <merijn> indiagreen: The Haskell Report is (by far) one of the most readable specs/standards that are produced
07:57:07 <merijn> indiagreen: The C/C++ standards are horrific unreadable messes, but the Haskell Report is short and readable (I've heard good things about Scheme's RSR6 spec too)
07:57:26 <alexclark> shit I just read LYAH and was planning to start RWH
07:57:46 <alexclark> should I skip to The Haskell Report?
07:58:00 <_sloth> Is Haskell object oriented?
07:58:02 <merijn> alexclark: Nothing wrong with those, it's just a shame no one reads the report. It covers many little details easily glossed over
07:58:03 <indiagreen> merijn: yes, but at least I need great concentration to not start skipping “bits I already know”
07:58:13 <indiagreen> highlighting would really help
07:58:24 <indiagreen> it's not about readability
07:58:42 <merijn> > "like \      \ did you know \           \ haskell lets you skip arbitrary whitespace in string literals?"
07:58:43 <lambdabot>  "like  did you know  haskell lets you skip arbitrary whitespace in string li...
07:58:59 <alexclark> merijn: would I need to read RWH to get full value out of the report?
07:59:08 <mauke^> _sloth: no
07:59:16 <merijn> alexclark: No, RWH is mostly about libraries and program design
07:59:43 <alexclark> merijn: oh, that actually sounds like what i really need to read then
07:59:46 <merijn> alexclark: The report is about: which identifiers are legal, how does layout work, what are the rules for polymorphic literals, etc.
07:59:48 <tdammers> _sloth: you can do OOP in Haskell, but you have to invent your own conventions, and it's not something you
07:59:57 <alexclark> doing math problems is great, but...
07:59:59 <tdammers> typically need or want to do a lot
08:00:20 <tdammers> (so short answer: no, it's not)
08:00:29 <merijn> alexclark: RWH is good, but most of the APIs discussed have changed so not all snippets run as-is
08:00:37 <indiagreen> merijn: this neat thing about string literals was one of the first things I put into /r/haskelltil
08:01:05 <merijn> alexclark: For example, the parsec chapter covers parsec 2 and not 3. OTOH, if you understand how parsec2 works, then using 3 should be easy by looking at the haddocks
08:02:01 <_sloth> Any android compilers?
08:02:27 <indiagreen> JHC
08:03:04 <indiagreen> there was a recent post about making an Android game with Haskell
08:03:17 <indiagreen> I think they used GHC, but I don't remember
08:05:10 <indiagreen> _sloth: https://github.com/neurocyte/ghc-android
08:06:26 <merijn> Cale was working on an FRP based game on android, iirc, but they ran out of funding.
08:09:48 <_sloth> indiagreen: thanks
08:12:43 <akegalj> how can i strictify tuple constructor? 
08:13:14 <akegalj> I am trying to do   foldl' (...) (a,b)
08:13:23 <echo-area> akegalj: a `seq` b `seq` (a,b)?
08:13:45 <akegalj> echo-area: hm, but constructor wont be forced?
08:14:21 <akegalj> echo-area: only values will be forced, ... thus when folding i think there will be (((((((((...))))) multiple constructor thunks
08:14:35 * hackagebot ConcurrentUtils 0.4.2.0 - Concurrent utilities  http://hackage.haskell.org/package/ConcurrentUtils-0.4.2.0 (JamesCandy)
08:14:37 * hackagebot amazonka-sns 0.3.3 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.3 (BrendanHay)
08:14:39 * hackagebot amazonka-sqs 0.3.3 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.3 (BrendanHay)
08:14:41 * hackagebot amazonka-glacier 0.3.3 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.3 (BrendanHay)
08:14:42 <EvanR> constructor thunks?
08:14:43 * hackagebot amazonka-cloudhsm 0.3.3 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.3 (BrendanHay)
08:18:38 <echo-area> merijn: There is an error in MyState.hs.  At line 12, it should be `instance Functor (MyState s) where`.
08:19:24 <merijn> echo-area: Ah, you're right. That code was initiall StateT based :)
08:19:45 * hackagebot amazonka-iam 0.3.3 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.3 (BrendanHay)
08:19:47 * hackagebot amazonka-route53-domains 0.3.3 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.3 (BrendanHay)
08:19:49 * hackagebot amazonka-directconnect 0.3.3 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.3 (BrendanHay)
08:19:51 * hackagebot amazonka-cognito-sync 0.3.3 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.3 (BrendanHay)
08:19:52 <merijn> echo-area: Ironically, the StateT one is also wrong and is what the State one should be :p
08:19:53 * hackagebot amazonka-elb 0.3.3 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.3 (BrendanHay)
08:20:42 <echo-area> I see.  I am testing my implementation of MyState and not yet coming to MyStateT.hs :)
08:21:22 <tongcx> hi guys, i wrote a short tutorial on category theory with some concrete examples, hope you like it http://tongcx.github.io/2015/03/24/category.html
08:23:38 <merijn> tongcx: I'll have a look, but by the look of it, it might be a bit short for covering a topic that is fairly confusing :) You may wanna compare with: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
08:24:19 <merijn> echo-area: Anyway, I fixed both :)
08:24:23 <akegalj> echo-area: thnx for the advice, forcing values of tuple works great
08:24:46 <tongcx> merijn: i don't tri to be rigorous or complete, i basically use two examples to illustrate natural transformation and adjoint functors
08:24:55 * hackagebot amazonka-cloudformation 0.3.3 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.3 (BrendanHay)
08:24:57 * hackagebot amazonka-sts 0.3.3 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.3 (BrendanHay)
08:24:59 * hackagebot amazonka-kinesis 0.3.3 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.3 (BrendanHay)
08:25:01 * hackagebot amazonka-cloudwatch 0.3.3 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.3.3 (BrendanHay)
08:25:03 * hackagebot amazonka-cloudtrail 0.3.3 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.3 (BrendanHay)
08:25:04 <tongcx> merijn: the two examples really got me clear on those concepts
08:30:05 * hackagebot amazonka-elasticache 0.3.3 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.3.3 (BrendanHay)
08:30:07 * hackagebot amazonka-importexport 0.3.3 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.3 (BrendanHay)
08:30:09 * hackagebot amazonka-s3 0.3.3 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.3 (BrendanHay)
08:30:11 * hackagebot amazonka-swf 0.3.3 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.3 (BrendanHay)
08:30:13 * hackagebot amazonka-sdb 0.3.3 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.3 (BrendanHay)
08:32:49 <Fuuzetsu> it's 2015 and still no untilM in base ;;
08:33:14 <tdammers> #firstclassproblems
08:33:47 <EvanR> which untilM ?
08:34:03 <EvanR> the one in monad-loops which is like a do-while? ;)
08:34:09 <Fuuzetsu> the one that does what I mean
08:34:11 <Fuuzetsu> probably
08:34:18 <EvanR> i dont like that one
08:34:26 <Fuuzetsu> why
08:34:37 <EvanR> because it sounds like a not whileM
08:34:52 <EvanR> not a doWhileM
08:34:57 <alynn> :t until
08:34:58 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
08:35:03 <tdammers> "until" suggests a post-condition check
08:35:10 <merijn> tongcx: The problem is expect is that most people don't have a clear notation of what a Functor is, so explaining natural transformations and assuming knowledge of functors is probably not very clear. Although, maybe it'll help me figure out the details of natural transformations :)
08:35:10 <EvanR> it does?
08:35:11 <alynn> (Monad m) => (a -> m Bool) -> (a -> m a) -> a -> m a
08:35:15 * hackagebot amazonka-elasticbeanstalk 0.3.3 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.3 (BrendanHay)
08:35:17 * hackagebot amazonka-datapipeline 0.3.3 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.3 (BrendanHay)
08:35:18 <mauke^> tdammers: no, it doesn't
08:35:19 * hackagebot amazonka-support 0.3.3 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.3 (BrendanHay)
08:35:21 * hackagebot amazonka-redshift 0.3.3 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.3 (BrendanHay)
08:35:21 <alynn> would be in line with the other until
08:35:23 * hackagebot amazonka-opsworks 0.3.3 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.3 (BrendanHay)
08:35:52 <tongcx> merijn: i refer to another very nice tutorial for the basics http://www.cs.toronto.edu/~sme/presentations/cat101.pdf
08:35:53 <mauke^> I blame pascal
08:36:12 <tdammers> "do this until you have reached the goal" -> kind of implies you have to start doing the thing before checking
08:36:29 <mauke^> no, it doesn't
08:36:34 <tdammers> "as long as you haven't reached the goal, do this"
08:36:49 <mauke^> "do this while you have not reached the goal"
08:37:03 <Fuuzetsu> what I actually want is a forM with a predicate
08:37:05 <tdammers> I'm going with natural language usage here
08:37:17 <mauke^> you're using natural language wrong
08:37:24 <tongcx> i am thinking about a English name for myself, and I feel "Hello everyone, my name is Newton" is very hilarious
08:37:26 <EvanR> "do this while you have not reached the goal, unless you have already reached the goal in which case do it anyway, once"
08:37:30 <mauke^> and by that I mean "* rolls eyes *"
08:37:30 <EvanR> makes sense i never use this
08:38:06 <tdammers> go catch a cab at the station some time, and tell the driver to "follow this street until we have reached the station"
08:38:16 <Fuuzetsu> tongcx: I don't like the idea of ‘English name’, but this is -blah material 
08:38:31 * EvanR boggles
08:38:51 <tdammers> (but then, "while we're not at the station, keep driving" would come across equally nonsensical, so I guess I rest my case)
08:39:06 <EvanR> the untilM in monad loops is the only case where this terminology occurs with this behavior that i know
08:39:28 <merijn> tongcx: You mention "Interestingly, you don’t have a natural transformation in reverse direction.", but it's unclear to me why?
08:39:34 <mauke^> EvanR: pascal has 'while X do ... done' and 'repeat ... until X' for no reason
08:39:59 <tdammers> mauke^: precondition versus postcondition is the stated reason in pascal
08:40:06 <mauke^> tdammers: what
08:40:21 <tdammers> while loops loop 0 or more times; repeat-until loops at least once
08:40:25 * hackagebot amazonka-emr 0.3.3 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.3 (BrendanHay)
08:40:27 * hackagebot pinboard 0.3 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.3 (jonschoning)
08:40:29 * hackagebot amazonka-cognito-identity 0.3.3 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.3 (BrendanHay)
08:40:29 <mauke^> tdammers: ???
08:40:31 * hackagebot amazonka-ssm 0.3.3 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.3 (BrendanHay)
08:40:33 * hackagebot amazonka-dynamodb 0.3.3 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.3 (BrendanHay)
08:40:37 <tongcx> merijn: because <= is one direction, if you have Floor => Ceil, then the arrow will have wrong direction
08:41:00 <tongcx> merijn: sorry, the first <= is smaller or equal than, the second is for natural transformation
08:41:22 <tdammers> the while loop checks the condition, and as long as it evaluates to true, the body gets executed
08:41:36 <tdammers> the repeat/until loop executes the body, and then checks the condition
08:41:51 <tdammers> which means the first execution of the body happens unconditionally
08:42:10 <EvanR> how about an as long as loop would that help
08:42:52 <mauke^> tdammers: what is your point?
08:43:09 <tdammers> mauke^: that this difference is the reason why Pascal has both
08:43:15 <mauke^> "both"?
08:43:20 <mauke^> country *and* western?
08:43:32 <tdammers> both "repeat/until" and "while"
08:43:33 <frerich> :-))
08:43:40 <mauke^> tdammers: that's not "both"
08:43:50 * frerich puts on "Stand by your man"
08:43:51 <mauke^> that's exactly the WTF I don't see any reason for
08:43:51 <tdammers> if pascal had both country and western, I'd still be using it
08:44:15 <tdammers> how does having two syntax constructs not qualify as "both"?
08:44:20 <mauke^> why are pre-/postcondition coupled with positive/negative condition?
08:44:24 <tdammers> oh, that
08:44:28 <mauke^> they're completely orthogonal concepts
08:44:28 <tdammers> that's stupid
08:44:48 <tdammers> but pascal is full of that stuff
08:45:04 <tdammers> e.g., how there's an unsigned int, but not an unsigned long
08:45:35 * hackagebot amazonka-rds 0.3.3 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.3 (BrendanHay)
08:45:36 <merijn> tongcx: Oh, I see. because the Floor => Ceil natural transformation would introduce an extra arrow for every object compared to Ceil => Floor?
08:45:37 * hackagebot amazonka-ses 0.3.3 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.3 (BrendanHay)
08:45:39 * hackagebot amazonka-cloudwatch-logs 0.3.3 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.3 (BrendanHay)
08:45:40 <indiagreen> tdammers: isn't Cardinal this?
08:45:41 * hackagebot amazonka-route53 0.3.3 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.3 (BrendanHay)
08:45:43 * hackagebot amazonka-cloudsearch 0.3.3 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.3 (BrendanHay)
08:46:06 <merijn> Incidentally
08:46:08 <tdammers> indiagreen: Cardinal? we didn't have that when I was young
08:46:17 <indiagreen> well, we had
08:46:37 <tongcx> merijn: yes, the problem is that Floor => Ceil will introduce arrow with wrong direction, not compatible with Int category. But Ceil => Floor introduce arrows with right direction
08:47:00 <merijn> Pierce says that inverses of morphisms are unique, but doesn't give a proof
08:47:14 <merijn> I don't see why inverses of arrows would be unique?
08:47:58 <tongcx> merijn: think you can use the same proof of uniqueness of inverse in group theory to prove that
08:48:06 <merijn> Couldn't I have f : A -> B and g,h : B -> A so that both g.f = 1_A and h.f = 1_a ?
08:48:15 <tongcx> merijn: but here i'm not concerned with that, not quite relevant to what we are talking about
08:48:32 <tongcx> merijn: that's possible
08:48:33 <merijn> tongcx: I know, but it was a question I had this morning reading :)
08:48:48 <tongcx> merijn: but if g.f = f.g = 1, then the inverse is unique
08:48:49 <merijn> And I'd been meaning to ask here anyway, but I forgot until now :p
08:49:03 <merijn> tongcx: isn't it merely unique upto isomorphism?
08:49:13 <tongcx> merijn: yes
08:49:25 <merijn> Oh, wait, I see my mistake
08:49:34 <merijn> Well, no, wait
08:49:35 <tongcx> merijn: in category theory, unique upto isomorphism is "unique"
08:49:52 <merijn> tongcx: Yeah, but Pierce hasn't specified that yet :p
08:50:03 <merijn> oh well, it's nearly dinner time!
08:50:06 <tongcx> merijn: i see, why are you reading that book?
08:50:18 <tongcx> merijn: are you in eurpean?
08:50:23 <tongcx> merijn: european?
08:50:28 <Welkin> he lives on europa
08:50:44 <Welkin> or rather, inside europa
08:50:45 * hackagebot amazonka-storagegateway 0.3.3 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.3 (BrendanHay)
08:50:47 * hackagebot amazonka-ec2 0.3.3 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.3 (BrendanHay)
08:50:48 <merijn> tongcx: Because I've been working on teaching myself CT for like a year now ;) And yes
08:50:49 * hackagebot amazonka-kms 0.3.3 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.3 (BrendanHay)
08:50:49 <Welkin> deep under the surface ice
08:50:51 * hackagebot amazonka-elastictranscoder 0.3.3 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.3 (BrendanHay)
08:50:51 <Welkin> in the oceans
08:50:53 * hackagebot amazonka-lambda 0.3.3 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.3 (BrendanHay)
08:51:00 <tongcx> merijn: good luck!
08:51:05 <EvanR> hackage space
08:51:07 <EvanR> er spam
08:51:16 <tongcx> what's hackagebot?
08:51:21 <tongcx> what's that bot doing?
08:51:30 <EvanR> taking a dump
08:51:30 <tongcx> kind of annoying
08:51:37 <merijn> tongcx: Announcing new packages uploaded to hackage
08:51:54 <indiagreen> and we have these waves when amazonka* gets updated
08:52:03 <indiagreen> yesod too, probably, but I've never seen it
08:52:47 * indiagreen looks
08:52:59 <indiagreen> no, yesod packages seem to be updated at different times
08:54:38 <KaneTW> i just had someone mention : (as in cons) isn't a function, but (:) :: a -> [a] -> [a]
08:54:52 <merijn> KaneTW: It's a constructor
08:55:28 <merijn> KaneTW: Constructors have types like functions, but are conceptually different in how they behave
08:55:35 <KaneTW> i see, thanks
08:55:42 <merijn> i.e. you can't pattern match on functions, but you can match on constructors
08:55:55 * hackagebot amazonka-ecs 0.3.3 - Amazon EC2 Container Service SDK.  http://hackage.haskell.org/package/amazonka-ecs-0.3.3 (BrendanHay)
08:56:17 <frerich> Also, constructors may have no arguments, unlike functions.
08:56:23 <merijn> KaneTW: And they have statically known arities, etc. but in many (most?) ways constructors behave the same as functions
08:56:55 <KaneTW> what ways do they behave differently, aside from pattern matching?
08:57:28 <merijn> KaneTW: constructors must have a concrete runtime representation
08:57:52 <KaneTW> as in they can't be undefined?
08:59:43 <merijn> KaneTW: Actually, the more I try and pin down the difference, the more trouble I have explicitly listing the difference :) I think it's mostly something you shouldn't think about to hard, because I can't think of many scenarios where the difference is very important
09:01:13 <echo-area> merijn: I think `(MyState s) a` and `MyState s a` are the same, i.e. the parentheses here are left associative.  Is this true?
09:01:42 <KaneTW> yeah, i wasn't aware functions and constructors were different things since you use them in about the same way
09:02:05 <merijn> echo-area: Correct, the parens are there to clarify that 'm = MyState s' in the type signature
09:02:05 <EvanR> not all constructors are functions
09:02:39 <echo-area> EvanR: Is Nothing an example?
09:02:42 <KaneTW> :t Nothing
09:02:44 <lambdabot> Maybe a
09:02:52 <KaneTW> yup, not a function
09:03:03 <echo-area> merijn: Thanks
09:04:02 <KaneTW> EvanR: so stuff like (:) IS a function, but a constructor too?
09:04:06 <EvanR> yeah
09:04:13 <Welkin> :t Just
09:04:13 <lambdabot> a -> Maybe a
09:04:17 <Welkin> :t Nothing
09:04:18 <lambdabot> Maybe a
09:04:33 <EvanR> and an operator
09:04:40 <EvanR> its all very obvious and clear ;)
09:05:09 <KaneTW> yeah
09:05:51 <KaneTW> i was pretty sure it was a function at first since, well, it takes a value and gives you something else. then someone said it's not a function but a constructor and i decided to ask
09:06:49 <EvanR> also functions dont have constructors
09:06:58 * EvanR throws some fuel on the fire
09:08:06 <EvanR> not to be confused with -> the function type constructor
09:09:37 * hackagebot HaTeX 3.16.1.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.16.1.0 (DanielDiaz)
09:11:29 <KaneTW> EvanR: what's your definition of a function? 
09:11:51 <EvanR> im fresh out
09:12:14 <KaneTW> haha
09:12:22 <EvanR> im haskell there are function values and function types
09:12:38 <EvanR> function values are first class
09:12:46 <EvanR> and have a function type
09:15:04 <EvanR> things you can do with functions, pass them as arguments, return them as results, and apply them to an argument of the appropriate type
09:15:25 <Iceland_jack> KaneTW: Simple answer, if has a type like '_ -> _' (called a ‘function type’) then it's a function
09:16:19 <schell> does anyone have a recommended library on hackage for sending and recieving over UDP?
09:16:26 <Iceland_jack> When you define
09:16:26 <Iceland_jack>     addOne :: Int -> Int
09:16:26 <Iceland_jack>     addOne x = 1 + x
09:16:26 <Iceland_jack> then that's a function, the data constructor 'Just :: a -> Maybe a' is also a function
09:17:26 <KaneTW> the person i'm arguing says that he defined functions as a symbol that can be evaluated using definitions (the way i understand this, things like f 0 = 2; f n = 1)
09:17:54 <kazagistar> A function is anything that has a top level type of (->), no?
09:18:07 <Iceland_jack> KaneTW: No because then "thunks" would be functions
09:18:16 <Iceland_jack> Like
09:18:16 <Iceland_jack>     ones :: [Int]
09:18:16 <Iceland_jack>     ones = 1 : ones
09:18:48 <kazagistar> Just :: (->) a (Maybe a)
09:19:08 <kazagistar> (made it prefix to make it obvious that -> is the top level type)
09:19:24 <EvanR> kazagistar: whats a "top level type" ?
09:19:35 <kazagistar> im probably using the wrong word
09:19:39 <Iceland_jack> kazagistar: It doesn't have to be top-level, anonymous functions (\x -> not x) are also be considered functions no?
09:19:47 <kazagistar> the leftmost thing in the type
09:20:02 <Iceland_jack> kazagistar: Ah. I misunderstood what you said
09:20:05 <Roger__> Anyone know why a program would hang when compiled with GHC but run fine in GHCI?
09:20:32 <kazagistar> yeah, I was unclear. Whats the right word for it? Outermost type constructor?
09:22:55 <EvanR> as much as i was complaining about 15 selector functions it actually simplified my code a lot
09:23:18 <EvanR> and the 15 functions are braindead simple so kind of dont count as code
09:23:27 <quchen> Roger__: define "hang"
09:23:59 <Iceland_jack> kazagistar: I think what you said was fine, I understood what you meant after re-reading it
09:24:44 <Iceland_jack> If you had said "top-level type constructor" it would have been clearer
09:24:47 <Roger__> quchen: Gloss window pops up but nothing is drawn on it (Can see desktop through it), stuff from debug.trace that I should be getting spammed with doesn't appear
09:25:36 <EvanR> i would have expected the other way around, ghci screws up on opengl and the normal compiled program works 
09:25:38 <Roger__> My guess would have been an infinite loop, but given the ghc/ghci difference I don't know what to think
09:25:51 <Roger__> EvanR: So would I
09:26:04 <quchen> Hmm I'm not familiar with that bug, sorry
09:26:15 <EvanR> Roger__: maybe try #haskell-game
09:26:32 <Roger__> Mk
09:26:51 <Iceland_jack> kazagistar: I found some references for 'top-level type constructor' so I guess it's fine: http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/tfp08-full.pdf
09:28:22 <quchen> Roger__: Have you tried the alternative backend when compiling gloss? The docs mention some bug that sounds similar to yours. http://gloss.ouroborus.net/
09:28:38 <quchen> Roger__: It might be worth a shot, a long one though
09:28:49 <quchen> "Gloss freezes in ghci"
09:30:27 <Roger__> quchen: Worth trying, although I'm not super optimistic, since they describe the mirror problem
09:30:44 <quchen> Yes :-|
09:34:39 * hackagebot compstrat 0.1.0.2 - Strategy combinators for compositional data types  http://hackage.haskell.org/package/compstrat-0.1.0.2 (JamesKoppel)
09:38:04 <kazagistar> Iceland_jack: thanks for the research :P
09:38:24 <Iceland_jack> I was curious myself
09:38:48 <Iceland_jack> It was quite selfish :)
09:39:30 <kazagistar> the one I am not sure about is "things that are a lot like functions, but don't have a top level type constructor of (->)". like Endo
09:39:53 <EvanR> :t appEnd
09:39:53 <Iceland_jack> kazagistar: that's perfectly fine, 'Endo a' is isomorphic to 'a -> a' 
09:39:53 <lambdabot>     Not in scope: ‘appEnd’
09:39:54 <lambdabot>     Perhaps you meant one of these:
09:39:54 <lambdabot>       ‘appEndo’ (imported from Data.Monoid),
09:39:54 <EvanR> :t appEndo
09:39:55 <lambdabot> Endo a -> a -> a
09:40:15 <EvanR> myEndo `appEndo` foo
09:40:23 <Iceland_jack> Just like a datatype that stores a function
09:40:23 <Iceland_jack>     data Foobar = MkFoobar (Int -> Bool)
09:41:06 <kazagistar> I know what it is, I am just wondering about naming... ill probably just call it "newtype around a function"
09:41:14 <Iceland_jack> You cannot apply a value of Foobar (eliminating it via function application) like you can functions, you need to project the function out first
09:41:34 <Iceland_jack> You can morally call it a function I guess :)
09:42:01 <jameseb> "function up to isomorphism"
09:42:13 <EvanR> uhg
09:42:23 <Iceland_jack> “Wrapped function”, “function wrapped in a newtype”, everyone will know what you mean
09:42:25 <EvanR> its not a function, you cant apply it, its a newtype
09:42:36 <kazagistar> silly category theory and it's "_ up to (unique?) isomorphism" shenanigans
09:44:54 <Iceland_jack> Many datatypes like 'newtype Reader r a = Reader { runReader :: r -> a }', 'State s a', 'Parser a', ... wrap functions but aren't
09:45:05 <quchen> kazagistar: Isomorphic up to unique isomorphism ♥
09:45:45 <kazagistar> yeah, I think ill stick to Function iff (->) a b
09:46:56 <Iceland_jack> kazagistar: ;)
09:46:56 <Iceland_jack>     type family IsFunction (a :: *) :: Bool where
09:46:56 <Iceland_jack>       IsFunction (a -> b) = True
09:46:56 <Iceland_jack>       IsFunction a        = False
09:48:17 <NemesisD> is the AmbiguousTypes extension safe?
09:48:42 <NemesisD> i'm upgrading some ghc 7.6 code to 7.8 and am seeing suggestions to enable it crop up
09:49:07 <NemesisD> the description seems like it doesn't  degrade type safety but just defers the check to where its used, but it has a scary sounding name
09:49:13 <nitrix> Hi, my application seems to be getting serious enough that it'll need test units.
09:49:37 <nitrix> Which framework would you recommend and based on what criteria?
09:49:56 <nitrix> I'll admit hspec is the one that seems the most readable to me (still quite new to haskell).
09:50:03 <NemesisD> nitrix: i've used 3 test frameworks and found that they differ very little
09:50:37 <NemesisD> hspec is familiar if you've used rspec in ruby, i personally prefer tasty, but can't point to a wealth of advantages or anything
09:51:56 <kazagistar> hmm, tasty looks like it supports QuickCheck, HSpec, and HUnit, which basically makes it a superset functionally?
09:52:53 <NemesisD> i guess. i've never used their hspec integration
09:53:06 <NemesisD> i don't see the point unless you have a lot of work in hspec you don't want to port over
09:53:14 <bennofs> hspec also supports quickcheck and HUnit afaik
09:53:15 <kazagistar> makes sense
09:53:28 <NemesisD> i don't know of a test framework that doesn't support quickcheck, hunit and golden testing
09:53:50 <NemesisD> a superficial difference is that hspec uses blocks for defining test trees and tasty uses lists
09:54:24 <NemesisD> there may also be difference is test parallelism between them
09:55:40 <nitrix> How does it works, I'll neeed to put a special line in cabal I assume?
09:56:18 <nitrix> I'm using travis, I know it uses cabal --only-dependencies --run-tests or something.
09:57:34 <mmachenry> nitrix: https://github.com/tfausak/haskeleton
09:58:11 <mmachenry> That's a skeleton project for cabal with the current recommendations and includes hspec tests, haddock documentation, hlint style guide, etc
10:00:27 <breadmonster> Hi everyone.
10:00:27 <breadmonster> http://lpaste.net/129121
10:00:41 <breadmonster> That's a whitespace lexer I wrote as a part of a lexer for Python.
10:01:00 <breadmonster> Is there a cleaner way of writing equivalent code? Ideally with higher order functions?
10:03:55 <bennofs> breadmonster: I'd probably write "modifyState (const x); return $ case compare x n of { EQ -> []; GT -> [Indent]; LT -> [Dedent]; }"
10:04:00 <bennofs> breadmonster: instead of the nested if
10:04:10 <breadmonster> bennofs: Yeah, you're right.
10:07:26 <breadmonster> bennofs: Thanks!
10:11:46 <sritchie> hey guys - question on a parser I’m writing
10:11:49 <sritchie> about this snippet of code: https://gist.github.com/sritchie/e55f726b3624d3d3273b
10:11:59 <sritchie> I’ve got two nodes in my ADT that wrap numeric types
10:12:27 <sritchie> one that wraps integers, one that wraps floats. I’m trying to write a function that returns the wrapped numbers, so I can apply primitive “+”, “-“ etc operations to them
10:13:29 <sritchie> I have the error in there, but the main thing I see is Could not deduce (a ~ Integer) … from the context (Num a)
10:13:33 <c_wraith> sritchie: your type signature is a lie, there.  It promises the compiler that you can return *any* type, so long as it's an instance of Num
10:14:14 <sritchie> ah, because I’m leaving the type open to the caller?
10:14:18 <c_wraith> sritchie: correct
10:14:22 <sritchie> yeah, I really want to say that the return values here will conform to the Num typeclass
10:15:16 <c_wraith> sritchie: that's not too useful, though.  If I have two numbers, x and y, that I know are each of *some* type that is a member of Num, it still doesn't tell me I can add them together.  I need to know they're the same type.
10:16:01 <sx> sritchie: It is even impossible in general.
10:16:09 <kazagistar> sritchie: what is your purpose for unpacking them at the end? knowing that might help us figure out the best solution
10:17:06 <sritchie> yeah, for sure. I’m working through the “write you a scheme” tutorial and implementing the primitive numeric functions
10:17:14 <kazagistar> sritchie: a simple solution is { unpack :: Wrapper -> Either Integer Float }, but at that point you might as well use pattern matching
10:17:24 <safinaskar> i am writting something like compiler for haskell-like language. it has haskell-like type system. let's assume i have functions f :: a -> b -> a and g :: b -> b -> a in my language. when i write expression "f g" my compiler perform type-checking. but i should keep in mind that "a" in "f" and "a" in "g" are different a's. so, i rename this letters every time i type-check. is there some more natural way?
10:17:30 <safinaskar>  something like HOAS?
10:17:41 <sx> kazagistar: how does that help you? that's just rebundling them? :)
10:17:42 <c_wraith> sritchie: you will really need to just break down and handle all the cases in places that need to apply the operations
10:17:52 <RustyShackleford> does Setup.hs get compiled into you project too?
10:18:04 <RustyShackleford> or is that just info for the compiler
10:18:08 <sritchie> so if the evaluator sees List[Atom “+”, <tail>],
10:18:09 <c_wraith> sritchie: for instance, when you are adding two Wrapper values together, what do you do if they're not mathing types?
10:18:09 <safinaskar> and every time i should generate unique names for this types. this is very tricky. how to do another way without this ad hoc generating of unique names?
10:18:12 <sritchie> I want to fold the tail with +
10:18:12 <sritchie> but yeah, makes sense that even though I’m parsing an untyped scheme the numbers I’m folding have to be the same type
10:18:13 <sritchie> my AST has support for floats and integers, and I wanted to allow (+ 1 2.5) in my language
10:18:16 <kazagistar> sx: it only helps if you want to hide the type internals, so not very much at all
10:19:02 <sritchie> c_wraith: the version described here just substitutes 0 in for those cases, which is obviously busted http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1
10:19:03 <c_wraith> sritchie: in that case, you have two main options - just make everything a float (ie, the javascript approach), or write explicit promotion rules.
10:19:41 * hackagebot semver 0.3.3 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.3 (BrendanHay)
10:20:09 <sritchie> c_wraith: so one option would be to write a wrapper that takes two args and if either is a float, promotes the other to a float
10:20:39 <c_wraith> sritchie: yes..  Though if you get clever with the Rank2Types extension, that function can apply a binop at the same time
10:21:29 <c_wraith> sritchie: like...  binOp :: (forall a. Num a => a -> a -> a) -> Wrapper -> Wrapper -> Wrapper ; binOp f (WrappedInt x) (WrappedInt y) = WrappedInt (f x y) ; ... all the rest of your cases
10:22:05 <sritchie> nice, with proper promotions
10:22:06 <kazagistar> don't you already have to write rules for any type in the language? { Atom = AInt Integer | AFloat Float | AString String | ... ; add :: Atom -> Atom -> Either Error Atom } etc?
10:22:34 <c_wraith> sritchie: the difference there is that the polymorphism is inverted.  Instead of accepting a function that works on some type `a' chosen by the caller, the callee is demanding the caller provide a polymorphic function that can work on any instance of Num
10:22:54 <sritchie> kazagistar: yeah, to do it right - I’m following this tutorial which subverts that for simplicity by routing all the non-numeric args to 0
10:23:19 <sritchie> c_wraith: yeah, that makes sense
10:23:23 <sritchie> c_wraith: nice, this is helpful
10:24:02 <c_wraith> sritchie: that syntax will require you to enable the RankNTypes extension.  (it might also say Rank2Types - those are actually synonyms on recent versions of GHC, but weren't necessarily in the past)
10:24:36 <sritchie> c_wraith: I’ll start with casting everything to float and go back for a second pass
10:25:01 <c_wraith> sritchie: ok.  I think you understand why you got the error you did now, which is the important part.
10:25:07 <sritchie> yup, absolutely
10:25:31 <kazagistar> for Lua, the second pass didn't happen til version 5.2... you can get away with using Doubles to store Ints for a loooong time :P
10:25:33 <sritchie> c_wraith: I’m moving my type system intutition over from scala
10:25:56 <sritchie> kazagistar: haha, nice
10:26:01 <Peaker> c_wraith: Rank2Types=RankNTypes? Wasn't there a reason to distinguish?
10:26:06 <EvanR> kazagistar: where Int means Int32 ;)
10:26:18 <EvanR> even then detecting multiplication overflow is...
10:27:01 <c_wraith> Peaker: in theory there might be, but GHC has decided that limiting to Rank2Types doesn't give the compiler any extra power, the way it handles typing.  So it just treats them as the same thing now.
10:28:01 <kazagistar> EvanR: is that actually a problem? even if the accuracy degrades when multiplying i32 two when they are stored inside f64, you can still at least accurately detect that you overflowed
10:28:32 <EvanR> kazagistar: yeah you can, if youre careful
10:28:50 <EvanR> again assuming 32bits
10:28:57 <EvanR> but who does that ;)
10:29:41 * hackagebot text-manipulate 0.1.3 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.3 (BrendanHay)
10:34:42 * hackagebot ghc-exactprint 0.2 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.2 (mpickering)
10:35:54 <safinaskar> i am writting something like compiler for haskell-like language. it has haskell-like type system. let's assume i have functions f :: a -> b -> a and g :: b -> b -> a in my language. when i write expression "f g" my compiler perform type-checking. but i should keep in mind that "a" in "f" and "a" in "g" are different a's. so, i rename this letters every time i type-check. is there some more natural way?
10:36:00 <safinaskar> and every time i should generate unique names for this types. this is very tricky. how to do another way without this ad hoc generating of unique names?
10:36:03 <safinaskar>  something like HOAS?
10:37:22 <EvanR> you need totally unique names for each type variable, "a b and c" is a pretty printed way to show it in the end
10:37:44 <Ralith> safinaskar: that is, in some sense, the standard approach.
10:38:27 <Ralith> generally type variable "names" are actually just unique numbers that the user never sees outside of error messages, though
10:38:43 <Ralith> using actual strings is just gratuitous effort
10:38:59 <mpickering> safinaskar: There is a neat way you can do it -- http://www.cse.chalmers.se/~emax/documents/axelsson2013using.pdf
10:39:19 <Ralith> you normally have your typechecker operate in some name-generating state monad
10:39:27 <Ralith> so you can always easily ask for a fresh name
10:39:34 <mpickering> also includes a discussion of the other ways
10:39:42 * hackagebot ede 0.2.6 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.6 (BrendanHay)
10:42:49 <safinaskar> thanks
10:43:35 <safinaskar> how to store this types (i. e. a -> b -> a) in my program? i want to store them without identifiers. is this possible?
10:44:02 <Iceland_jack> safinaskar: Do you mean to store a polymorphic "forall a b. a -> b -> a" type?
10:44:11 <EvanR> Function 1 (Function 2 1)
10:44:45 <EvanR> unless its forall
10:44:45 <Iceland_jack> You can use a higher-order approach, but it's not very pretty so you may prefer de Bruijn indexes 
10:44:46 <arkeet> what do you mean by "store"?
10:44:57 <arkeet> oh I should read up.
10:45:10 <safinaskar> Iceland_jack: yes
10:45:38 <safinaskar> Iceland_jack: how to do this higher-order approach (in this a -> b -> a example)?
10:46:20 <Iceland_jack> safinaskar: good question, you basically want to model polymorphism
10:46:34 <safinaskar> Iceland_jack: yes
10:46:40 <arkeet> I guess forall would introduce type variables much like a lambda.
10:46:41 <Iceland_jack> So you need a way to model type lambdas
10:46:59 <EvanR> Forall 1 (Forall 2 (Function 1 (Function 2 1)))
10:47:16 <safinaskar> Iceland_jack: and in fact all is working now. i just want to rewrite my program more beautiful way. currently the program use string IDs and i don't like this
10:47:45 <mroman> so, one of things I've never liked about monads is that people are apt to talk about "THE list monad" as if there is only monad that could be sensibly applied to lists
10:47:45 <ReinH> Usually people use ints
10:47:57 <Iceland_jack> safinaskar: Look at this paper http://homepages.inf.ed.ac.uk/slindley/papers/embedding-f.pdf which adds a constructor
10:47:57 <Iceland_jack>     TLam :: (forall a. Exp env (k a)) -> Exp env (Poly k)
10:48:00 <EvanR> mroman: whats the other one?
10:48:18 <ReinH> mroman: what other list monads are there?
10:48:31 <Iceland_jack> where 'Poly k' boxes the polymorphism
10:49:01 <mroman> I suspect you could define >>= not just as concatMap?
10:49:22 <EvanR> mroman: you can but theres monad laws
10:49:43 * hackagebot pipes-cliff 0.6.0.0 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.6.0.0 (OmariNorman)
10:49:45 <kadoban> mroman: Well, [] in haskell has a Monad instance, so talking about /the/ list Monad isn't too weird.
10:49:45 <Iceland_jack> safinaskar: Since Haskell doesn't allow first-class type constructors, you'll have to create a new data type for each new polymorphic type, if you want to model 'forall a. a -> a'
10:49:45 <Iceland_jack>     newtype Foo a = MkFoo (a -> a)
10:50:05 <Iceland_jack> It's all in the paper
10:50:31 <ReinH> mroman: Define it as what?
10:50:42 <kadoban> What's the other one, ZipList or something? I don't know of another possible instance, but I'm not very well versed in that stuff.
10:50:48 <ReinH> ZipList isn't a monad.
10:50:58 <kadoban> Isn't it?
10:51:05 <Iceland_jack> No
10:51:13 <kadoban> Oh. Haha, nevermind.
10:51:13 <ReinH> It's Applicative but not a Monad
10:51:32 <kadoban> I thought it was, I've never used the thing just read about it.
10:51:44 <safinaskar> arkeet: Iceland_jack: yes, i want something like type lambda. how to do this? and i don't want Bij. indexes (they are to non-natural, i think), nor i want something like data Type = Lam (Type -> Type) | ..., because such modeling lambdas as _real_ lambdas make this lambdas difficult to operate with
10:52:03 <ReinH> I suppose it's called "the list monad" because a) there isn't another one and b) it's literally the Monad instance for []
10:52:24 <EvanR> safinaskar: i dont think lambda is a good way to think of it, forall is more like a binder
10:52:26 <Iceland_jack> safinaskar: Use 'bound' if you aren't using GADTs or look at parametric higher-order abstract syntax (PHOAS)
10:52:37 <mroman> so you can't define any other instance of Monad [] without breaking monad laws?
10:53:06 <mroman> like uhm
10:53:13 <mroman> xs >>= f = []?
10:53:18 <arkeet> that breaks the laws.
10:53:20 <merijn> mroman: Doesn't obey the law
10:53:28 <safinaskar> Iceland_jack: please explain without pointing to long articles :)
10:53:34 <Iceland_jack> safinaskar: You can then  use abstract syntax graphs (ASGs) that use PHOAS 
10:53:52 <Iceland_jack> safinaskar: Hmm, wait I need to put stuff aside real quick :)
10:53:55 <merijn> mroman: "return x >>= f == f x", which if 'f' returns something other than [] is not true for your example
10:54:14 <mroman> hm
10:54:24 <mroman> I see.
10:54:53 <EvanR> youre right though unless somebody proves thats the only monad, talking about "the list monad" and "the state monad" seems a little weird
10:55:10 <merijn> There is, in fact, another state monad
10:55:10 <ReinH> EvanR: It's not that weird. They are literally *the* instances.
10:55:24 <merijn> You can have state flow in reverse for State s
10:55:33 <merijn> Whoo! Time travel!
10:55:36 <EvanR> nice
10:55:46 <safinaskar> EvanR: " forall is more like a binder" - okey, so how to do this? :)
10:55:59 <EvanR> safinaskar: i already demonstrated that
10:56:25 <EvanR> a forall binder, denoting a polymorphic type, is just literally forall, the binding variable, and the body
10:56:38 <Fuuzetsu> isn't there a second list monad too?
10:57:17 <safinaskar> Iceland_jack: what is this "bound"?
10:57:19 <EvanR> safinaskar: you just need to make sure the variable doesnt clobber something in the body you didnt mean to
10:57:35 <Iceland_jack> safinaskar: 
10:57:37 <Iceland_jack> @hackage bound
10:57:37 <lambdabot> http://hackage.haskell.org/package/bound
10:59:54 <safinaskar> EvanR: "the binding variable, and the body" - i already have this. i just want to get rid of IDs of this variables
11:00:10 <EvanR> safinaskar: huh? you cant, thats their ... ID
11:00:18 <EvanR> thats how you tell the difference between them
11:00:43 <Iceland_jack> Keep in mind that keeping explicit variable names around/de Bruijn indices is a good thing for manipulating the structure
11:01:10 <Iceland_jack> What you really want is some kind of higher-order approach for the surface representation that translates directly to something like that
11:02:23 <safinaskar> EvanR: i want to make this IDs implicit. for example, i can do "data Type = Forall (Type -> Type)". this will remove IDs. but this also will make manipulation with such types difficult. so, i want to remove IDs but still easily to manipulate such types
11:03:00 <Iceland_jack> safinaskar: Did you find what I wrote earlier relevant?
11:03:13 <Iceland_jack> The Chalmers paper does that in an efficient way
11:05:18 <safinaskar> Iceland_jack: i don't like all solutions provided so far (i. e. just use IDs, Bij. idexes, real lambdas (Forall (Type -> Type))). and i didn't read that articles yet. i will read them
11:05:47 <EvanR> for a compiler, just numeric IDs doesnt seem horrible
11:05:57 <EvanR> of course youd have a prettifier at some point
11:06:18 <Iceland_jack> First of all there is nothing wrong with using de Bruijn indices, you said “i want to remove IDs but still easily to manipulate such types” but once you remove IDs manipulating higher-order terms is trikcy
11:06:20 <Iceland_jack> *tricky
11:06:28 <Iceland_jack> Especially if you care about preserving sharing
11:07:49 <safinaskar> in fact, this is not compiler. this is proof assistant similar to isabelle and which have type system similar to haskell
11:08:29 <Iceland_jack> safinaskar: Take a look at http://ropas.snu.ac.kr/~bruno/papers/ASGDSL.pdf
11:09:44 * hackagebot ede 0.2.7 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.7 (BrendanHay)
11:09:52 <Iceland_jack> Manipulating variables and binders is still a research problem
11:10:28 <ReinH> It still needs to compile or interpret the code
11:10:40 <ReinH> "Being a proof assistance" and "Being a compiler" are not mutually exclusive.
11:10:47 <ReinH> *assistant
11:11:20 <Iceland_jack> You can get away with performing different interpretations if you use PHOAS (/ASGs) but once you start manipulating them it stops being very fun
11:11:36 <Iceland_jack> (in a type-safe way)
11:12:19 <ReinH> Iceland_jack: the recent paper that ties the knot was pretty interesting, but probably not the best place to start
11:12:50 <Big_G> Axman6, I was just browsing your twitter and your profile came up
11:12:57 <ReinH> Oh, mpickering linked it.
11:13:15 <Iceland_jack> Yeah I referenced it though
11:13:24 <Iceland_jack> it's very simple, the entire implementation is only several lines of Haskell code
11:13:26 <ReinH> Yeah, I'm catching up a bit
11:13:32 <ReinH> Iceland_jack: Yeah, it's quite clever.
11:13:52 <ReinH> And can be easily implemented in a strict language by using a thunk for the body
11:14:26 <Iceland_jack> I suppose there is a lack of a comprehensive overview of this stuff, I don't have a lot of resources to link to except papers
11:14:41 <ReinH> Yeah, I've noticed that too
11:14:44 <safinaskar> let me say again my problem. i have type like "a -> b -> b". and i have set of its variables (i. e. a, b). i want this type not to have explicit IDs for this vars, but instead to have links to elements of this set. this set is unordered, so Bruijn indexes here are not natural (nor Lam (Type -> Type) is)
11:14:44 * hackagebot pugixml 0.3.1 - pugixml binding.  http://hackage.haskell.org/package/pugixml-0.3.1 (HirotomoMoriwaki)
11:15:09 <ReinH> safinaskar: what set?
11:15:34 <ReinH> Anyway, it doesn't change the problem, you still need some way of producing a fresh name
11:15:56 <ReinH> an enumerable set is nice because succ is an easy way to produce such a name
11:16:04 <ReinH> so all you're really doing is making fresh name generation harder
11:16:14 <safinaskar> ReinH: my language is not programming language, i. e. it cannot be evaluated. so my program is not interpreter nor compiler
11:16:16 <EvanR> save the original variable name for debugging purposes
11:16:27 <ReinH> safinaskar: That's not true, but it's also not relevant
11:16:30 <EvanR> but at some point those names will collide
11:16:46 <EvanR> so you cant use them directly for everything
11:17:16 <EvanR> you said earlier it was a compiler
11:17:26 <safinaskar> ReinH: "what set" - set of type variables of this complex type
11:17:51 <ReinH> Anyway, it doesn't matter if you use integers or strings or some other set, the problem is the same
11:18:04 <ReinH> just harder if you can't use succ to generate a fresh name
11:18:36 <safinaskar> EvanR: i said this is something like compiler :)
11:19:45 * hackagebot amazonka 0.3.3.1 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.3.1 (BrendanHay)
11:22:51 <safinaskar> thanks a lot everybody. i will read articles :)
11:26:52 <EvanR> speaking of compilers
11:27:35 <EvanR> im trying to hack haskell into allowing me to write cyclic code and give me meaningful error message if i accidentally write the wrong kind of loop
11:27:44 <EvanR> i dont know what im doing
11:29:07 <EvanR> i wonder what kind of type system stops some loops and allows others
11:29:25 <ReinH> EvanR: one that doesn't exist because of the halting problem, I suppose.
11:29:30 <EvanR> :(
11:29:50 <ReinH> well, it might allow iteration but not general recursion
11:30:02 <bennofs> EvanR: Most dependently typed languages have a termination checker I believe
11:30:05 <ReinH> but you said you wanted cyclic code
11:30:36 <mmachenry> EvanR: I don't know much about dependently typed languages, but they are capable of preventing infinite loops like you're talking about.
11:30:40 <EvanR> yeah so termination is probably good, termination of any given step in the process
11:30:49 <mmachenry> EvanR: They are also not subject to the halting problem. 
11:31:02 <kazagistar> just make the checker smart enough that you never run into to the remaining undecidable cases in day-to-day code :P
11:31:15 <EvanR> kazagistar: crazy talk
11:31:25 <EvanR> we want to be able to tell managers that something is theoretically impossible
11:31:32 <Fuuzetsu> maybe in 50 years
11:31:42 <ReinH> mmachenry: not all dependencly typed languages, no. Some dependently typed languages are turing complete.
11:31:52 <EvanR> idris ;)
11:31:57 <safinaskar> EvanR: :)
11:32:11 <mmachenry> EvanR: You want to tell managers some things they are requesting are impossible? Like what kinds of things?
11:32:26 <monochrom> and some non-dependently-typed languages can also restrict programs to be terminating.
11:32:30 <HeladoDeBrownie> anyone know of exercises for Cont and especially ContT?
11:32:52 <monochrom> System F is an example from academia
11:32:56 <ReinH> There's a difference between totality and dependently typed
11:33:42 <monochrom> in industry, there are some examples from domain-specific languages too
11:33:55 <kazagistar> "I dont care if it is impossible; you are an engineer, figure it out, thats what we pay you for"
11:34:36 <EvanR> im using observable sharing to detect bad recursion in my code and show numbered loopy paths, translating from that to my source code would be nice so i can fix it
11:39:02 <bennofs> EvanR: doesn't GHC already do something similar? I thought it detects when evaluating an expression leads to forcing the expression itself
11:39:06 <bennofs> > let x = x in 
11:39:07 <lambdabot>  <hint>:1:14:
11:39:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:39:09 <bennofs> > let x = x in x
11:39:12 <captcha> hi everyone, qqp, i would like to compile haskell code to dll, and call it from host lang. is it possible to pass function "callbacks" from host to haskell dll?
11:39:12 <lambdabot>  mueval-core: Time limit exceeded
11:39:35 <monochrom> yes captcha
11:39:41 <haasn> bennofs: GHC's non-threaded runtime can do it for compiled code
11:39:54 <haasn> But it can only detect direct self-references, it can't detect all infinite loops (trivially)
11:40:24 <EvanR> yeah im not triggering that behavior
11:40:33 <EvanR> and im using -threaded
11:41:14 <bennofs> Hmm, does GHC print the cost centre stack when encountering a **loop** ?
11:44:46 * hackagebot catamorphism 0.3.0.0 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.3.0.0 (frerich)
11:46:16 <bennofs> does GHC 7.8 allow defining kind-only types?
11:46:29 <bennofs> (Using DataKinds)
11:46:45 <Iceland_jack> no
11:47:10 <bennofs> Hmm, then is there any type whose promoted kind is * ?
11:47:38 <Iceland_jack> bennofs: https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/KindsWithoutData
11:48:01 <Iceland_jack> It's slated for GHC 7.12
11:48:05 <bennofs> I want to define a data T = T [...], such that I can later write T [Int, Bool, True ] of kind T
11:48:29 * frerich_ is kinda excited to have his first ever package on Hackage after tinkering with Haskell (on and off…) for something like four years :-)
11:48:35 <captcha> thanks monochrom
11:48:43 <Iceland_jack> Congratulations frerich_
11:49:09 <mmachenry> bennofs: You can't have a heterogeneous list. Would it be okay to have that be a tuple?
11:49:25 <mmachenry> data T a b c = T (a, b, c)
11:49:48 <bennofs> mmachenry: that is not a heterogenous list. it's a list of kind [*]
11:50:10 <bennofs> oops, ignore that True member there
11:50:12 <Iceland_jack> bennofs: You can have 'True ::: 'a' ::: () ::: Nil :: HList '[Bool, Char, ()]' using
11:50:12 <Iceland_jack>     data HList xs where
11:50:12 <Iceland_jack>       Nil   :: HList '[]
11:50:12 <Iceland_jack>       (:::) :: x -> HList xs -> HList (x ': xs)
11:50:31 <Iceland_jack> I'm not sure if that's what you're asking
11:50:37 <bennofs> I'm using data kinds, and I want to define a data type 
11:50:59 <bennofs> such that I can later use T [Int, Bool] as a type of kind T
11:51:06 <enthropy> maybe it would be clearer if you wrote 'T '[Int,Bool]
11:51:23 <jle`> congrats frerich_ !
11:51:28 <bennofs> enthropy: I always forget how many primes I need :) But yes, that's what I mean
11:51:49 <Iceland_jack> bennofs: You can't promote GADTs by the way
11:51:54 <enthropy> well or just make the constructor have a different name
11:51:58 <bennofs> Iceland_jack: it's not a GADT
11:52:08 <Iceland_jack> Okay, just making sure
11:52:31 <captcha> is there good known online way  to hire haskell expert, for different haskell related tasks..
11:52:56 <bennofs> Is it possible to define kind aliases? I guess not ...
11:53:29 <Iceland_jack> bennofs: So you want?
11:53:29 <Iceland_jack>     'T '[Int, Bool] :: T
11:53:29 <Iceland_jack>     
11:53:34 <kadoban> captcha: I hear there's a gathering place of #haskell people somewhere on the internet, some of whom are probably available for hire ;)
11:53:36 <Iceland_jack> That's not going to work
11:53:37 <bennofs> Iceland_jack: yes
11:53:46 <Iceland_jack> What do you need that for?
11:54:01 * EvanR captcha If you're hiring for remote haskell work, I'm looking for work.
11:54:17 <EvanR> ;)
11:54:28 <jle`> there's also haskellers.com i thin
11:54:47 * hackagebot bytestring-read 0.2.1 - fast ByteString to number converting library  http://hackage.haskell.org/package/bytestring-read-0.2.1 (HirotomoMoriwaki)
11:54:53 <Iceland_jack> brb
11:54:54 <enthropy> bennofs: live with "'T [Int, Bool] :: T *" from data T a = T [a] ?
11:55:25 <bennofs> enthropy: probably the best variant so far. Seems I can't do any better
11:55:34 <enthropy> well why involve the T at all now?
11:55:48 <Iceland_jack> Yes, why do you want that specific kind?
11:55:54 <bennofs> enthropy: because it's actually data T = A | B | C [...]
11:56:04 <Iceland_jack> (feels like XY prob)
11:56:11 <bennofs> Ok. I'll explain
11:57:11 <bennofs> I want to define a tag for qml object member types. An object member can be one of: a) read only property (Ro) b) read-write property (RW) c) Function from args of types T1, T2, ...
11:57:20 <bennofs> So I like a kind for that tag
11:57:34 <RustyShackleford> should I use HUnit or QuickCheck?
11:57:47 <kadoban> RustyShackleford: Yes.
11:57:51 <bennofs> the data type would look like data MemberType = RO | RW | Fun [......... something here so I can pass argument types .....]
11:57:57 <RustyShackleford> kadoban: good answer
11:58:18 <bennofs> So I will have to live with using 'MemberType * everywhere instead of just 'MemberType
11:58:27 <Iceland_jack> bennofs: Would something like this work
11:58:28 <Iceland_jack>     data QML tag where
11:58:28 <Iceland_jack>       ReadOnly :: ... -> QML RO
11:58:28 <Iceland_jack>       Fun      :: ... -> QML (Arr a b)
11:58:31 <Iceland_jack>       
11:58:46 <Iceland_jack> given 'tag :: State' for some 'data State = RO | Arr State State | ...'
11:59:05 <bennofs> Iceland_jack: I'm asking about State
11:59:12 <bennofs> Iceland_jack: the arguments to Arr should be types
11:59:15 <bennofs> Iceland_jack: not states
11:59:39 <bennofs> Iceland_jack: so that I can have 'Arr Int ... :: State
11:59:47 * hackagebot cryptol 2.2.0 - Cryptol: The Language of Cryptography  http://hackage.haskell.org/package/cryptol-2.2.0 (AdamFoltzer)
11:59:49 * hackagebot pugixml 0.3.2 - pugixml binding.  http://hackage.haskell.org/package/pugixml-0.3.2 (HirotomoMoriwaki)
11:59:53 <kadoban> RustyShackleford: I usually use both, depending on which seems better for the part I'm trying to test. I use uhm, the test-framework package on hackage, but there may be better ones (or not, I dunno).
12:00:37 <RustyShackleford> HUnit looks more straightforward
12:00:42 <RustyShackleford> maybe i'll start with that
12:01:34 <RustyShackleford> am i right that QuickCheck is for more specific use cases? The examples I see seem to test for mathematic-like properties
12:01:41 <Iceland_jack> bennofs: Would this suffice?
12:01:41 <Iceland_jack>     data State a = RO | Arr a a
12:01:41 <Iceland_jack> and
12:01:44 <Iceland_jack>     data QML :: State * -> * where
12:01:47 <Iceland_jack>       MkRO  :: ... -> QML RO
12:01:47 <Iceland_jack>       MkArr :: a -> b -> QML (Arr a b)
12:01:53 <captcha> great, can get emails . kadoban, EvanR.
12:02:18 <bennofs> Iceland_jack: yes, just wondering if there is any way to avoid having to write State * instead of State everywhere
12:03:29 <Iceland_jack> Well you wouldn't be writing 'State *' in many places
12:03:31 <enthropy> you could use * instead of State, and have   data RO; data RW; data Fun (args :: [*]); class MemberType a; instance MemberType RO; instance MemberType (Fun args)
12:03:42 <Iceland_jack> Yes that's another solution
12:04:21 <kadoban> RustyShackleford: It's for any time you can specify…a property that a function or whatever should always hold (or should hold under certain prerequisites). It doesn't always have to be very mathematical at all.
12:04:35 <Iceland_jack> bennofs: You can also create an type family that interprets some kind of code into a Haskell type
12:04:44 <Iceland_jack> *create a
12:05:00 <Iceland_jack> I.e. deeply embedding the semantics domain
12:05:02 <Iceland_jack> *semantic..
12:05:08 <Neoss1> Hi! I'm using cabal-install 1.18 & GHC 7.8.4 with sandboxes. I wish to build my project executable as fully optimized as possible. I have specified "ghc-options:  -O2" in my .cabal file, but was wondering whether I need to also specify it when installing its dependencies ("cabal install --only-dependencies") or whether the flags for the dependencies are irrelevant.
12:07:00 <Iceland_jack> bennofs: data Ty = TInt | TBool
12:07:00 <Iceland_jack>          data Val a where MkInt :: Int -> Val TInt; Bool -> Val TBool
12:07:00 <Iceland_jack> and 'data State = RO | Arr Ty Ty' with 'MkArr :: Val a -> Val b -> QML (Arr  a b)'
12:07:05 <Iceland_jack> *QML (Arr a b)
12:07:15 <Neoss1> For example, cabal will accept "cabal install --only-dependencies -O2", but I don't know it it makes any difference
12:07:54 <sinelaw> Peaker, yo
12:09:06 <Iceland_jack> (This will become much more powerful once we get first-class kind equality and indexing GADTs by kinds)
12:09:40 <bennofs> Iceland_jack: thanks, I will probably just make the tag be of kind *. That way, I can also use the Int -> Int syntax for functions
12:09:41 <Iceland_jack> bennofs: That's all I can suggest :)
12:19:44 <zipper> Hey could someone refer me to something I can read on regarding automatic code reloading in haskell maybe web stuff to be specific.
12:19:49 * hackagebot natural-transformation 0.2 - A natural transformation package.  http://hackage.haskell.org/package/natural-transformation-0.2 (ryanglscott)
12:24:49 * hackagebot hackage-mirror 0.1.0.0 - Simple mirroring utility for Hackage  http://hackage.haskell.org/package/hackage-mirror-0.1.0.0 (dysinger)
12:29:25 <kyagrd> I kind of realized more clearly why multi pram type classes make me uneasy.
12:30:32 <kyagrd> Inliing subexpressions can easly cause rather unexpected type error.
12:31:32 <kyagrd> Whey you have "e where y = f x" such that y appear several times in e and f is a method of multi param class 
12:32:09 <kyagrd> even if "e where y = f x" type checked, e[y := f x] might not
12:33:08 <bennofs> kyagrd: that can happen even without multi param type classes
12:33:31 <kyagrd> bennofs: does it happen with single paramter type classes?
12:33:41 <bennofs> or wait, let me try something
12:34:49 <kyagrd> I thought single param type classes was still pure Haskell
12:35:05 <arkeet> do you have a working example?
12:35:12 * bennofs is still trying
12:35:50 <S11001001> bennofs: if you have poly let binding (the default) might have to take an arg
12:36:25 <S11001001> @ty \a b -> (show a, show b)
12:36:26 <lambdabot> (Show a1, Show a) => a -> a1 -> (String, String)
12:36:42 <bennofs>  let g :: IO Int -> a -> IO Int; g = const; x = return 3; in g x x
12:36:42 <S11001001> @ty (\s a b -> (s a, s b)) show
12:36:43 <lambdabot> Show a => a -> a -> (String, String)
12:36:44 <bennofs> > let g :: IO Int -> a -> IO Int; g = const; x = return 3; in g x x
12:36:45 <lambdabot>  No instance for (GHC.Base.Monad m0) arising from a use of ‘x’
12:36:45 <lambdabot>  The type variable ‘m0’ is ambiguous
12:36:45 <lambdabot>  Note: there are several potential instances:
12:36:50 <bennofs> I thought that would type check
12:39:30 <enthropy> > let f str = case read str of x -> (show x, x+1 :: Int) in f "2"
12:39:31 <lambdabot>  ("2",3)
12:39:45 <bennofs> Oh, with -XMonomorphismRestriction, my example works
12:39:49 <enthropy> > let f str = (show (read str), (read str)+1 :: Int) in f "2"
12:39:50 <lambdabot>  ("*Exception: Prelude.read: no parse
12:40:28 <S11001001> bennofs: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#mono-local-binds
12:40:55 <RustyShackleford> know of a good guide to testing with HUnit?
12:41:03 <RustyShackleford> i would like to see some good examples
12:41:56 <jle`> there was that nice tasty guide posted on reddit a week or so back
12:42:28 <zipper> How can I check whether binaries have changed on disk and reload them?
12:43:20 <enthropy> kyagrd: ^^ that's an example that doesn't need MPTCs to show that inlining something changes the result (and whether it typechecks if you don't have -XExtendedDefaultRules on)
12:45:56 <kyagrd> enthropy: does it happen easily when (f x) is fully applied? like when f is show and it is given an argument.
12:46:26 <kyagrd> (show x) will be typed as string however you'd inline it
12:47:12 <kyagrd> So, unless x is some overloaded thing, inlining/expanding (show x) should preserve typing, I think
12:47:48 <kyagrd> But for MPTC method f, inlining/expanding (f x) refactoring can much easily cause type errors.
12:50:51 <kadoban> Is there some way to avoid repeating myself in 'build-depends' in .cabal files? I have a library, an executable, a test suite…do they really all have to repeat the same thing?
12:52:32 <bennofs> kadoban: the test-suite and executable can depend on the library defined in the same cabal file
12:53:01 <kadoban> bennofs: How do you specify that?
12:53:14 <bennofs> kadoban: just use build-depends: ..., yourLibName, ...
12:53:53 <kadoban> bennofs: Oh, like 'library someArbitraryName', and then later in the build-depends I use that name?
12:54:00 <bennofs> kadoban: yes
12:54:05 <kadoban> Ah cool, thanks
12:54:23 <bennofs> kadoban: ah no, sry. Just use what is in the name: field of your cabal file
12:54:33 <bennofs> kadoban: libraries inherit the package name
12:55:14 <kadoban> Oh, really? Odd, okay that works though.
13:04:51 <lpaste> amf pasted “never terminates” at http://lpaste.net/129128
13:05:41 <kaiyin> https://gist.github.com/kindlychung/9f60f5747568a89bc18c  How do I deal with scoping problems like this?
13:05:50 <amf> i am thoroughly stumped by my parsing attempt
13:06:12 <amf> is there a quick way to see what function ghc is spending all of its time in?
13:07:00 <mmachenry> amf: Yes, compile with profiling and do myprog +RTS -p
13:07:29 <mmachenry> You'll get a new file called something like myprog.prof and it'll have the times it spent in each function and how many times each was called.
13:09:40 <tempname11_> kaiyin: indent line 48 and beyond
13:09:42 <S11001001> kaiyin: you'll need to share your code too.
13:09:53 <S11001001> kaiyin: wait n/m
13:10:06 <tempname11_> I think it's treating this line like a top-level definition
13:10:09 <kadoban> kaiyin: indent line 48, remove "where" from the end of 48 and 50, de-indent 51. Something like that.
13:10:09 <kaiyin> S11001001: i did share it.
13:10:16 <S11001001> kaiyin: my fault for trusting the irccloud gist view, which only showed your err
13:11:23 <zyla> :t Just
13:11:25 <lambdabot> a -> Maybe a
13:11:25 <kaiyin> ok. I got it.
13:14:52 * hackagebot helics 0.5.1 - New Relic agent SDK wrapper for Haskell.  http://hackage.haskell.org/package/helics-0.5.1 (HirotomoMoriwaki)
13:20:58 <kaiyin> http://stackoverflow.com/questions/29241477/margin-of-a-haskell-diagrams-svg-file/29242040#29242040   Anyone care to have a look at this?
13:24:53 * hackagebot mysql 0.1.1.8 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.8 (BryanOSullivan)
13:24:55 * hackagebot helics-wai 0.5.1 - New Relic agent SDK wrapper for wai.  http://hackage.haskell.org/package/helics-wai-0.5.1 (HirotomoMoriwaki)
13:27:48 <hexagoxel> is there a way to define `HList (Append l1 l2) -> HList l1` without adding proxy arguments?
13:29:15 <HairyDude> Is there a package like haskeline or readline that works with Text?
13:29:32 <hexagoxel> i currently add a (Proxy (HList l2)) and a HList l1, which works, but is rather complicated
13:29:53 * hackagebot quickcheck-unicode 1.0.0.1 - Generator and shrink functions for testing  Unicode-related software.  http://hackage.haskell.org/package/quickcheck-unicode-1.0.0.1 (BryanOSullivan)
13:30:35 <frerich_> Is there a way to use the ‘forall’ quantifier for type variables used in a ‘newtype’?
13:30:50 <benzrf> no
13:30:53 <benzrf> wait
13:30:58 <benzrf> frerich_: can you be more detailed?
13:31:09 <benzrf> frerich_: you cant have existential newtypes but you can have rank-2 newtypes
13:31:58 <frerich_> benzrf: Usually I’d do “newtype Foo a = Foo a’ or so. Is there a way to stick a ‘forall’ somewhere? In the TH documentation I see that (in principle) you could have such a ‘forall constructor’.
13:32:03 <S11001001> benzrf: you can have existential newtypes, they just can't have constraints on the vars :)
13:32:33 <mmachenry> I'm having trouble making a decision about whether to add arguments to all of my functions with a logger object or to create a new type that's effectively ReaderT Logger IO. Anyone have any design rules of thumb to follow here?
13:32:51 <benzrf> S11001001: wait, really?
13:32:53 <benzrf> what?
13:32:57 <S11001001> benzrf: or I am totally wrong.  Huh.
13:33:03 <benzrf> @let newtype Bleh = forall a. Bleh a
13:33:04 <lambdabot>  .L.hs:152:16:
13:33:04 <lambdabot>      A newtype constructor cannot have existential type variables
13:33:04 <lambdabot>      Bleh :: forall a. a -> Bleh
13:33:07 <benzrf> told you :D
13:33:09 <S11001001> benzrf: I have no idea why that restriction would be in place.
13:33:21 <benzrf> S11001001: i'd assume because of what happens when you remove newtypes
13:33:34 <benzrf> haskell doesnt have existentials beyond a type to hold them
13:33:41 <benzrf> so when you eliminate the newtype and use the underlying one
13:33:44 <benzrf> what type is there?
13:33:57 <benzrf> frerich_: yes you can stick a forall somewher
13:34:02 <benzrf> frerich_: what do you want the forall to do
13:34:02 <S11001001> benzrf: doesn't seem any worse than when you bind variables to values with existential type.
13:34:09 <benzrf> S11001001: idk
13:34:11 <S11001001> benzrf: and representationally it's irrelevant
13:34:15 <benzrf> :?
13:34:21 <benzrf> ask somebody more qualified, huh?
13:35:01 <shachaf> S11001001: dolio had a reasoning for that restriction.
13:37:55 <zipper> Hey can anyone tell me how code reloading is done? Like somehow listening in to check whether the binaries have changed on disk and reloading if true.
13:38:19 <shachaf> I think it was that "newtype L a = forall (n :: Nat). L (Vec n a)" can support infinite lists.
13:42:02 <HeladoDeBrownie> zipper, hmm, do you need to keep the application state for the most part?
13:42:22 <S11001001> shachaf: hmm.
13:42:28 <dolio> Yes.
13:42:40 <dolio> The semantics of the value level doesn't match the type level in the right way.
13:42:40 <zipper> HeladoDeBrownie: I don't even know. All I know is that I need to learn about automatic code reloading.
13:42:41 <HeladoDeBrownie> zipper, if not, or possibly even if so, you could use an exec syscall if one is available for your platform
13:42:49 <zipper> HeladoDeBrownie: That's what I assume it meant.
13:43:01 <dolio> And not having irrefutable matches is the only thing keeping them consistent.
13:43:01 <zipper> HeladoDeBrownie: Haskell
13:43:14 <zipper> exec syscall? What's that?
13:43:26 <HeladoDeBrownie> actually don't remember if it's a syscall
13:43:33 <HeladoDeBrownie> but basically exec replaces the currently running program with a new one
13:43:42 <RaceCondition> I have `main = interact $ map toUpper`; I then execute both $ ./toUpper <input.txt as well as $ ./toUpper <(cat input.txt) -- the former produces output and exits immediately; the latter just hangs forever -- what am I missing?
13:43:58 <hiptobecubic> zipper, man exec
13:43:59 <HeladoDeBrownie> and it's agnostic of language, just matters that you have a binary
13:44:27 <zipper> HeladoDeBrownie: I was about to ask What is exec? Which syscall? I'm not getting any of this.
13:44:39 <zipper> hiptobecubic: Okay I'll read the docs for exec
13:44:53 <HeladoDeBrownie> zipper, what hiptobecubic said, run `man exec` (if you're on an appropriate platform for that)
13:45:00 <alynn> HeladoDeBrownie: execve is the syscall
13:45:03 <schell> has anyone here written a udp server and/or client?
13:45:05 <zipper> HeladoDeBrownie: Yeah
13:45:09 <zipper> alynn: Thanks
13:45:13 <hiptobecubic> zipper, you probably also should read about how programs run at all before you get too deep into how hot loading works
13:45:27 <zipper> hiptobecubic: Where can I read that?
13:45:27 <EvanR> schell: udp doesnt have the notion of server and client
13:45:44 <zipper> EvanR: Ouch, you take no prisoners.
13:46:05 <EvanR> uh its an important aspect of udp
13:46:11 <Welkin> schell: http://book.realworldhaskell.org/read/sockets-and-syslog.html
13:46:50 <zipper> hmmm I really should read RWH but it's so hard to read a book that has most of it's code snippets being unable to compile.
13:47:08 <Welkin> also helpful, http://www.catonmat.net/blog/simple-haskell-tcp-server/
13:47:37 <schell> EvanR: it does do transmit and recieve, which is really all i’m asking
13:47:52 <schell> Welkin: thank you!
13:48:49 <schell> EvanR: wouldn’t the entity sending be a client and the one recieving be the server?
13:49:01 <EvanR> schell: and then they swap?
13:49:25 <EvanR> assuming you want two way communication
13:51:23 <schell> EvanR: ah i see - no right now i’m only interested in one way :)
13:53:16 <quchen> jle`: Nice docs on Auto.
13:54:54 <quchen> jle`: Since your tutorial.md is pretty low on markup anyway, I think a great step would be to put it into a Tutorial module, like Pipes does.
13:55:52 <Peaker> jle`: "... for declaratively describing *locally programs* "
13:56:47 <bennofs> auto looks a lot like netwire
13:58:00 <S11001001> dolio: why is it not a problem that you can do that with 'data'?
13:58:16 <Peaker> I don't understand the use case for arrows, rather than applicative, though
13:58:34 <Peaker> Category+Applicative is nicer than Arrow
13:58:35 <dolio> You can't do it with data.
13:59:01 <dolio> Irrefutable matches on data with existential quantifiers (or GADTs) are not allowed.
13:59:19 <quchen> Peaker: For one, Applicative is not a tuples convenience functions module ;-)
13:59:20 <bennofs> Peaker: is Category+Applicative equavilent to Arrow?
13:59:42 <dolio> Or, I guess they are allowed for some GADTs, but they don't act like GADTs then.
13:59:47 <EvanR> quchen: i knew it
13:59:54 * hackagebot presburger 1.3.1 - A decision procedure for quantifier-free linear arithmetic.  http://hackage.haskell.org/package/presburger-1.3.1 (IavorDiatchki)
13:59:55 <jle`> Peaker: the main use case is expressive statements of recursive bindings
14:00:08 <jle`> it's not as easy to express recursive relationships with Applicative tools
14:00:23 <dolio> If you try to irrefutably match on an existential data type you get the 'my brain exploded' error.
14:00:57 <jle`> quchen: i would, but formatting haddocks is a pain v.v  switching between "" and '' and @@ depending on context...and making sure things are linked properly (because they can be)
14:01:08 <jle`> i did consider it at first. i might go ahead with it at some point
14:01:13 <Peaker> bennofs: it's equivalent modulo some laws, I think
14:01:44 <Peaker> jle`: recursive relationships - you mean stuff that proc do translates to ArrowLoop constraints?
14:01:52 <jle`> Peaker: https://github.com/mstksg/auto#check-it-out -- almost all of this is well-expressed as Applicative...pretty trivial actually. except for the recursive binding
14:01:55 <S11001001> dolio: *blink* whoa.
14:02:06 <jle`> response depends on control, which depends on err, which depends on respose
14:02:20 <Peaker> jle`: in the Arrow interface, does it use ArrowLoop?
14:02:20 <S11001001> I simply got "An existential or GADT data constructor cannot be used inside a lazy (~) pattern"
14:02:33 <jle`> there is an ArrowLoop instance, yes
14:02:36 <dolio> Oh. Did they remove "my brain exploded"?
14:02:38 <dolio> Bummer.
14:02:42 <bennofs> dolio: try let
14:02:59 <jle`> and yeah, the syntax for recursive bindings that i take advantage of here uses ArrowLoop
14:03:23 <Iceland_jack> dolio: It's still there in 7.10 :)
14:03:25 <bennofs> > let T a = T "wow"; in a
14:03:26 <lambdabot>  My brain just exploded
14:03:26 <lambdabot>  I can't handle pattern bindings for existential or GADT data constructors.
14:03:26 <lambdabot>  Instead, use a case-expression, or do-notation, to unpack the constructor.
14:03:44 <hpc> i can't believe that string made it into a release
14:03:45 <HairyDude> asking again: Is there a library like Haskeline or GNU readline that works with Text instead of String?
14:03:57 <quchen> jle`: And you should point to the README more prominently in the Hackage page, because the package description is mostly buzzwords that are explained in the readme.
14:04:08 <jle`> good call :)
14:04:18 <dolio> bennofs: Whew, that's a relief. :)
14:05:36 <jle`> i'm glad we can update .cabal files on hackage now without uploading new versions
14:05:49 <EvanR> you can?
14:06:10 <quchen> jle`: :-)
14:06:19 <Fuuzetsu> I'm not glad, it messes stuff up
14:06:22 <quchen> EvanR: You can only change cosmetic fields though.
14:06:36 <quchen> Updating dependencies for example wasn't possible last time I checked.
14:06:37 <EvanR> nice as many ascii arts as we want
14:06:54 <Fuuzetsu> quchen: you can update dependency versions and all that stuff
14:07:05 <quchen> Oh.
14:07:09 <Fuuzetsu> but tarball remains unchanged
14:07:18 <Fuuzetsu> so it says one thing on hackage, another in thing you download…
14:07:22 <jle`> oh
14:07:30 <jle`> if i could only edit the description than that'd be nice too
14:07:45 <jle`> didn't realize that i could edit the dependencies and versions
14:07:46 <schell> Welkin: the udp RWH section is what I needed, thanks :)
14:07:50 <quchen> Wait, I think I meant changing "the" .cabal file. I didn't know you could make Hackage/tar out of sync, that's indeed strange.
14:07:51 <jle`> that sounds a little bit overkill
14:08:20 <Fuuzetsu> well, the feature is bad because cabal users suddenly start working against different cabal files than what's in the tarball
14:08:31 <Fuuzetsu> but it's good because you can update too loose dependencies on old packages
14:09:35 <Fuuzetsu> but again it's only thinking about cabal users, such changes are made so the solver doesn't pick up ancient versions with loose bounds
14:09:38 <Fuuzetsu> but everyone else suffers :)
14:10:11 <bennofs> Is there still the restriction that bounds can only be added, not removed?
14:10:54 <Fuuzetsu> don't think so
14:11:07 <Fuuzetsu> AFAIK you can replace the whole file if you want but don't quote me on this
14:11:49 <jle`> can't we help the solver issue with that preferred versions thing
14:12:35 <jle`> it sounds like that's the whole reason preferred versions was implemented
14:13:07 <randir> for all of your amusement: https://s-media-cache-ak0.pinimg.com/736x/6b/25/99/6b2599fc20ebfb4a7113fe8bf199727f.jpg
14:13:18 <jle`> Peaker: if you do think of a nice way to express recursive relationships with Applicative than I'd be happy to hear it :)
14:13:38 <EvanR> jle`: exactly whats not nice?
14:13:57 <Fuuzetsu> abuse laziness ;P
14:14:26 <Peaker> jle`: ApplicativeFix a where afix :: f a -> f a   always made sense to me :)
14:14:38 <jle`> i don't think anything will be as nice as https://github.com/mstksg/auto#check-it-out
14:14:56 <jle`> it's just...layed out as a cyclic graph of relationships
14:14:56 <Iceland_jack> Peaker: There has been an 'afix' proposed, but with a more complicated type
14:15:00 <jle`> *laid
14:15:05 <Peaker> oops: more likely: (f a -> f a) -> f a
14:15:27 <EvanR> jle`: but, you can do that without arrows
14:15:33 <EvanR> or fix
14:15:43 <jle`> can you do it without the recursive part?
14:15:44 <Peaker> jle`: it's nice but I hate how proc do generates an arbitrary sequence where the ordering may matter but is arbitrary
14:15:53 <EvanR> why would you want to?
14:16:03 <jle`> i mean, can you do it with the recursive part
14:16:23 <Fuuzetsu> >You can also usually find me (the maintainer and developer) as jle` on #haskell
14:16:24 <jle`> response depends on control which depends on err
14:16:26 <Fuuzetsu> tsk tsk tsk
14:16:34 <jle`> is that bad :O
14:16:37 <EvanR> jle`: right
14:18:20 <EvanR> jle`: what is the type of input and output to black box?
14:18:30 <Iceland_jack> Peaker: The type is 'afix' is 'afix :: forall p. ApplicativeFix p => (forall q. Applicative q => p (q a) -> p (q a)) -> p a'
14:18:34 <Welkin> what are you developing and maintaining jle` ?
14:18:52 <bennofs> @hackage auto -- Welkin
14:18:52 <lambdabot> http://hackage.haskell.org/package/auto -- Welkin
14:18:55 <Iceland_jack> Peaker: From http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.360.1675
14:18:59 <Iceland_jack> (not official)
14:19:55 * hackagebot smartconstructor 0.1.0.0 - A package exposing a helper function for generating smart constructors.  http://hackage.haskell.org/package/smartconstructor-0.1.0.0 (frerich)
14:20:01 <Peaker> Iceland_jack: interesting, why does "a" need to be hidden by another "q" ?
14:20:02 <Welkin> ah, is this the next stage based on your tutorial series?
14:22:02 <jle`> the tutorial series explains some aspects of the implementation/mechanism that the library is built on :)
14:22:36 <mpickering> your documentation looks really good
14:23:25 <osa1_> what is the FFI addendum mentioned here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-ghcexts ?
14:23:32 <jle`> thanks :) it was one of the priorities of the project
14:24:29 <osa1_> it says "FFI addendum section 3.2" but I don't think such a section exists
14:25:08 <monochrom> that probably becomes 8.3.2 in Haskell 2010
14:25:30 <Iceland_jack> Peaker: It is covered in section 3.5 “The meaning of afix's type”, it does it better justice than I can
14:26:26 <monochrom> oops, foreign types are in 8.4.2
14:27:15 <osa1_> is the user manual in ghc repo?
14:29:01 <monochrom> yes. in some form.
14:29:04 <quchen> osa1_: You mean the GHC manual? It's not in the repo in a built format, no
14:29:32 <quchen> You can generate it from the data within the repo, but finding a pre-compiled source is probably easier.
14:30:14 <monochrom> osa1_ probably actually wants that data because there is a possible correction to submit
14:30:32 <osa1_> yes
14:30:56 <quchen> Oh, in that case have a look at the $GHC/docs directory.
14:35:32 <osa1> hm, what kind if XML format is this...
14:35:54 <spew> what do you guys think of real world haskell vs. learn you a haskell?
14:36:57 <spew> I started reading learn you a haskell but just found real world: I find it a lot clearer and easier to read
14:37:19 <spew> is there any reason to prefer one over the other?
14:37:23 <EnglishGent> I've read both - I think learn you a haskell is better for complete beginners
14:37:33 <EnglishGent> Real world haskell for people wanting to write real code
14:37:40 <mjboa> i like learn you a haskell's explanation of functor, applicative and monad more
14:37:42 <EnglishGent> I don't think they have the same audience in minde at all
14:37:47 <EnglishGent> in mind*
14:37:49 <quchen> Both have a good reputation, use whichever suits you best. Cross-reading chapters you already know in the other book might be useful as well.
14:38:11 <starless> mjboa: Does it use the "burrito" metaphor?
14:38:34 <EnglishGent> If you have never programmed before or have only minimal experience I'd go with 'Learn yourself a Haskell'
14:38:51 <mjboa> definitely not, (probably, it's been a while since i read it)
14:39:04 <quchen> starless: Nobody uses the burrito metaphor. It's not a metaphor anyway.
14:39:52 <EvanR> i believe it was an attempt to explain monads, well, monad transformer stacks as wrappers upon wrappers
14:40:15 <EvanR> and i think thats the idea a lot of people have about monads who have never used them
14:40:25 <Welkin> a quessarito!
14:40:41 <jle`> nobody actually used burritos to explain monads seriously.  it was a parody of monad tutorials... "someone's going to come along some day and write a tutorial saying monads are burritos"
14:40:51 <jle`> so it's like the running joke of a bad monad tutorial
14:40:55 <monochrom> "burrito" was a joke.
14:41:14 <hiptobecubic> Poe's law in action, I'd say.
14:41:17 <quchen> It is now superseded by the fishy monad tutorial.
14:41:32 <monochrom> http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
14:41:35 <Welkin> also, http://ergoproxy.wikia.com/wiki/Monad
14:41:44 <jle`> the difference is that fishy monad tutorial is actually amazing
14:41:48 <hiptobecubic> is it?
14:41:59 <hiptobecubic> I wasn't very amazed. Other than the art, which i liked.
14:42:35 <quchen> The fishy monad tutorial is a good check of human pattern regognition. If you saw the last (?) picture and thought "oh so this looks like applicative" you win.
14:42:35 <EnglishGent> what's the fishy monad tutorial? I haven't heard of that one!
14:42:49 <quchen> ?google fishy monad tutorial
14:42:50 <lambdabot> http://maciejpirog.github.io/fishy/
14:42:50 <lambdabot> Title: Fishy Monad Tutorial
14:42:56 <EnglishGent> thanks :)
14:46:32 <starless> let's see if I'll understand monads from the fishy tutorial
14:46:46 <starless> quchen: Good catch dude. I'll avoid the burrito metaphor from now on
14:47:07 <jle`> wait, don't >< it's also a tongue-in-cheek joke tutorial
14:47:17 <starless> jle`: oh shit hahahaha
14:47:37 <starless> yeah I just hit the end
14:47:43 <starless> wow they had me going
14:47:48 * starless continues not understanding
14:48:03 <jle`> i mean, it's accurate, but it's not meant to teach people about using haskell monads :P
14:49:24 <starless> jle`: the fact that it's accurate is horrifying
14:50:29 <quchen> It's not accurate at all. It makes sense to human understanding at best.
14:50:31 <jle`> don't worry about that :) you can make any simple or easy to understand thing sound horrifying in an accurate way
14:51:05 <starless> jle`: I suppose that's true
14:51:17 <jle`> my usual advice to trying to understanding monads is don't. juse use types normally and eventually it'll come to you
14:51:47 <dgorbik> monads are just burritos :D
14:52:06 <EvanR> applicatives are chimichangas?
14:52:06 <starless> dgorbik: be careful. that metaphor is deprecated.
14:52:41 <monochrom> there is no good layperson or ELI5 description of monads. every good description must get technical.
14:53:02 <monochrom> actually, there is a good ELI5 description. "I'll tell you when you're 18"
14:53:28 <srid> Damn, Haskell no longer works on my Mac (it used to). ghci => `can't load .so/.DLL for: libiconv.dylib` http://pastie.org/pastes/10050983/text?key=jeoote5boomrzwhool5w
14:53:37 <srid> Is ghci still working for you OSX 10.10 users?
14:54:00 <quchen> The correct description of what monads are in Haskell is unfortunatly not very helpful in practice, unless you understand monads already. ("A monad is an instance of the monad class whose functions satisfy the monad laws.")
14:54:01 * EvanR didnt upgrade
14:54:09 <ReinH> monochrom: "an instance of Monad is a type constructor of kind * -> * with well-behaved definitions of return and (>>=)" is as close as you can get
14:54:22 <monochrom> see, that gets techincal
14:54:29 <dgorbik> srid, works for me
14:54:44 <ReinH> monochrom: it does.
14:54:54 <monochrom> another approach is showing a variety of concrete examples like [], Maybe, State. this also gets technical.
14:54:57 <starless> monochrom: not too technical
14:55:05 <starless> monochrom: but it doesn't tell me anything
14:55:13 <starless> monochrom: and that's probably the very core of it
14:55:23 <starless> monochrom: it probably isn't anything
14:55:31 <ReinH> Well, the problem is that most people don't actually want to know what a Monad *is*. They want to know what monads *do* and how they can use them.
14:55:45 <randir> What's the stanard library to use for immutable arrays?
14:55:46 <starless> Right
14:55:51 <quchen> randir: Vector
14:56:02 <EvanR> i got confused a long time ago by an explanation of monads by example. the two examples were: State and a RNG monad
14:56:04 <quchen> (And in particular *not* Array)
14:56:12 <EvanR> therefore monads are about state
14:56:21 <srid> Trying to compile ghc, but this requires ghc :-/
14:56:28 <randir> if I return a new vector, how much actual space usage/copying is going on?
14:56:28 <bennofs> quchen: why not Array?
14:56:37 <srid> damn, i'm stuck at getting a functional ghc on my mac
14:56:38 <monochrom> by-examples is good or bad depending on variety
14:56:52 <quchen> bennofs: Very limited API, doesn't really offer anything over vector apart from built-in Ix handling
14:57:08 <starless> it just itches me that there's something so many smart people cannot explain
14:57:09 <starless> or worse
14:57:12 <ReinH> What monads *do* is let you write something like do { a <- return 5; b <- return 6; return (a,b) } in a polymorphic way. That's about it.
14:57:14 <starless> it's unexplainable
14:57:16 <randir> say I have a tree that each parses a modified vector, will each branch have an entire vector, or will they each have some sort of diff-based data that refers to a common datastructure?
14:57:24 <quchen> Vector has good optimization, all the current typeclass instances and so on.
14:57:27 <ReinH> Anything more interesting depends on what individual instances do
14:57:45 <jle`> starless: it's not unexplainable, but being explained it isn't the best way to learn about it
14:58:13 <starless> jle`: so then the question becomes not "what do monads do?", but "what do I do?"
14:58:22 <monochrom> it is explainable if I go technical
14:58:28 <starless> go technical
14:58:30 <bennofs> ReinH: there are also the laws that capture some of the more-or-less intuitive understanding of how such a do block should behave
14:58:33 <srid> ah. ghc works, only ghci is breaking.
14:58:40 <ReinH> bennofs: yep
14:58:52 <monochrom> Phil Wadler already wrote one.
14:59:07 <ReinH> Wadler's paper remains the best explanation of monads
14:59:11 <ReinH> Despite the hundreds of other attempts
14:59:25 <quchen> ReinH: Those attempts lead people to realize it though :-)
14:59:32 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
14:59:56 <monochrom> but it uses old notation. some day I want to translate it to modern, Haskell notation
15:00:20 <quchen> The more I learn about (categorical) monads the more I'm amazed by the fact that someone discovered their practicality for Haskell.
15:00:22 <monochrom> then mine will be really the best, although it's a derivative.
15:00:33 <mjboa> i still kind of like the overloaded semicolon explanation
15:00:49 <monochrom> yes, that works too
15:02:19 <ReinH> One of the issues with explaining Monad (and Functor and Applicative) is that most people don't have experience with higher-kinded types, let alone ad-hoc polymorphism of higher-kinded types, and most tutorials don't even mention that this is a thing or that it is important to understand.
15:02:52 <ReinH> higher-kinded types are one of the best things about Haskell and one of the things I miss most in other languages, even FP languages.
15:03:28 <quchen> ReinH: I'd like to add return type polymorphism to that list
15:03:44 <ReinH> quchen: Agreed.
15:03:57 <mjboa> ReinH: what do you mean ad-hoc polymorphism of HKT?
15:04:13 <ReinH> class Monad (m :: * -> *) where
15:04:27 <quchen> ReinH: On the other hand, monoids are *-kinded yet haven't seen much use either. But they're much easier to explain to people unfamiliar with them.
15:04:33 <ReinH> ad-hoc because it's typeclass constrained
15:04:49 <ReinH> as opposed to parametrically polymorphic
15:04:57 * hackagebot basic-lens 0.0.0 - Basic Lens type and functions  http://hackage.haskell.org/package/basic-lens-0.0.0 (ChrisDone)
15:06:05 <ProofTechnique> Anyone wanna help me read some simple Core? I'm just curious about some of the differences I'm seeing and what they mean. :)
15:06:45 <quchen> ?where justask
15:06:45 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:06:53 <ProofTechnique> Well, sure.
15:06:55 <ProofTechnique> http://jsfiddle.net/0ahu9ohk/
15:06:58 <ProofTechnique> Core there ^
15:07:29 <ProofTechnique> I'm just curious about the differences in the two direct recursion functions (search and search') and the foldr version (search'')
15:07:41 <ProofTechnique> I should mention that this is with -O2
15:08:10 <ProofTechnique> The two direct versions are, as I might expect, identical, but the fold one looks like it does some stuff that I don't get.
15:09:09 <ProofTechnique> And, I suppose, what (if anything) can we say about the performance characteristics of these functions based on the Core?
15:09:36 <ProofTechnique> Does more Core == more steps, or is it less straightforward than that?
15:13:09 <hpc> it's like assembly
15:13:15 <hpc> different things have different performance
15:13:34 <mjboa> what does HKT without ad-hoc polymorphism look like?
15:14:05 <ReinH> mjboa: Maybe, Either, etc
15:14:27 <randir> How does updating immutable vectors work, with memory usage?
15:14:41 <randir> does the updated vector refer to an underlying base vector?
15:14:50 <EvanR> no
15:14:58 * hackagebot parseerror-eq 0.1.0.0 - Adds and Eq instance for Parsec's ParseError if needed  http://hackage.haskell.org/package/parseerror-eq-0.1.0.0 (jsl)
15:15:02 <EvanR> its a copy
15:15:04 <arkeet> it copies the entire vector.
15:15:05 <ProofTechnique> hpc: Sure, that seems sensible enough.
15:15:08 <randir> hm
15:15:15 <arkeet> the values might be shared though.
15:15:21 <mjboa> ReinH: ah ok, so specific monads whereas the idea of a monad itself is ad-hoc polymorphic in haskell
15:15:27 <randir> arkeet: what do you mean by tat?
15:15:27 <EvanR> there is an experimental difference array thing, but i heard it sucked
15:15:28 <randir> that*
15:15:32 <randir> k
15:15:43 <randir> does Map or IntMap use diffs?
15:15:52 <EvanR> it uses sharing
15:16:02 <randir> how does that work?
15:16:04 <EvanR> they*
15:16:05 <randir> on an underlying level.
15:16:08 <ProofTechnique> hpc: For one, what do [Occ=Dead] and [Occ=LoopBreaker] signify?
15:16:26 <EvanR> randir: when you exchange one list head for another, you can keep the same tail. does that make sense?
15:17:12 <ReinH> mjboa: well, specific type constructors. They don't have to be instances of anything.
15:17:38 <randir> EvanR: and this works for even if I create 2 "new" lists with different heads
15:17:44 <NemesisD> is it possible to use CPP to determine if a language extension is supported?
15:17:49 <randir> they both refer to the original memory space?
15:18:04 <arkeet> depends on how you create them.
15:18:06 <mjboa> ReinH: right. cool, never really made that distinction before
15:18:16 <EvanR> if you have a list with a tail, and you replace the head, both lists can refer to the same tail
15:19:26 <EvanR> lucky for us because now you can replace the head on an infinite list
15:19:36 <randir> That's cool
15:19:37 <EvanR> among other things
15:19:38 <arkeet> think how you might implement a singly linked list in C. a list is either empty or a value together with a pointer to another list.
15:19:53 <randir> And the same general structure works for IntMaps and Maps?
15:20:01 <EvanR> right
15:20:03 <arkeet> given a list, you can cons something onto it without modifying the tail.
15:20:14 <arkeet> so you can have multiple lists that share tails.
15:20:43 <randir> Okay, excellent.
15:20:46 <arkeet> so to update a list, you only have to copy the nodes in the list down to the place where you update it.
15:21:03 <arkeet> Map is implemented with a binary tree. 
15:21:23 <arkeet> when updating a Map you only have to copy the path down the tree to where you modify it.
15:21:28 <arkeet> other subtrees can just be shared.
15:21:55 <Peaker> arkeet: btw, I wouldn't implement a list in C like that :)
15:22:42 <arkeet> Peaker: what do you mean?
15:22:46 <EvanR> heh
15:22:57 <randir> anyone know of a good way to hash a Map?
15:23:16 <EvanR> in C you arent limited to immutable nodes, but it turns out it simplifies things if you pretend like you are
15:23:18 <Peaker> arkeet: in C, the modern/Linux style is to implement a naked data structure (without any data) and then associate data with the structure externally, using ptr arithmetic to find the data from the naked node
15:23:26 <Peaker> EvanR: in C? nope
15:23:42 <EvanR> in C where you are dealing with concurrent workers, yeah
15:25:34 <ProofTechnique> randir: There are a couple of options, but depending on your needs, Map may be just fine.
15:25:51 <arkeet> Map is a good go-to structure.
15:26:23 <randir> I mean, a function from Map -> Hash String
15:26:35 <randir> for seeing if 2 maps are equal
15:26:38 <Peaker> EvanR: C isn't very good at FP/immutability
15:27:12 <wayne> http://conal.net/blog/posts/the-c-language-is-purely-functional
15:27:18 <adamse> cabal haddock seems to ignore settings for haddock in .cabal/config when run in a sandbox, is this correct behaviour or am I doing something wrong?
15:27:53 <Cale> randir: Hash its list of key/value pairs, I suppose
15:28:22 <Cale> wayne: haha
15:29:34 <EvanR> Peaker: just need a quick interpreter over const arrays ;)
15:31:02 <Cale> randir: If you needed to perform such an operation, you'd want to find an associative hash function like Rabin-Karp, and store the hashes of subtrees in the data structure. The associativity would be important to avoiding recomputing all the hashes whenever you rebalance the tree.
15:32:02 <osa1> > let nan = 0/0 in compare nan nan
15:32:04 <lambdabot>  GT
15:32:11 <osa1> let nan = 0/0 in nan > nan
15:32:14 <randir> I'm just trying to think of how I can implement the three-move repetition rule in chess 
15:32:16 <osa1> > let nan = 0/0 in nan > nan
15:32:17 <lambdabot>  False
15:32:23 <adamse> I have `hyperlink-source: True` in my cabal config but `cabal haddock` does not hyperlink source
15:32:26 <osa1> how
15:32:33 <mniip> > let nan = 0/0 in nan < nan
15:32:34 <lambdabot>  False
15:32:36 <osa1> compare for Float should be partial, right?
15:32:51 <mniip> osa1, compare is not implemented with > in Float (nor is vice versa)
15:32:59 <randir> any ideas?
15:33:07 <Cale> osa1: Well, it would also kind of suck if compare just gave an exception for that case.
15:33:08 <osa1> mniip: but it doesn't matter, right
15:33:19 <mniip> nan `compare` nan doesn't make a lot of sense for IEEE754 specification, so it just makes sure it isn't EQ
15:33:30 <Cale> osa1: It's just really unfortunate that floating point comparison isn't an equivalence relation
15:34:59 * hackagebot statistics 0.13.2.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.13.2.2 (BryanOSullivan)
15:35:07 <phaazon> hi, do you know what this is for http://research.microsoft.com/apps/pubs/default.aspx?id=71450
15:35:10 <phaazon> ?
15:35:15 <Cale> Sometimes I wonder how much we'd really lose by just saying "No, fuck you IEEE, NaN is equal to itself."
15:35:20 <phaazon> I’ve never seen that before
15:35:42 <randir> Cale: "fuck you IEEE" would make a good t-shirt
15:35:46 <Fuuzetsu> did you read the abstract?
15:36:06 <phaazon> yes, but I don’t see any link, any hackage lib, any github repo
15:36:11 <phaazon> that sounds like bullshit
15:36:16 <Cale> http://research.microsoft.com/pubs/71450/ipdps_haskell_multiway.pdf google
15:38:11 <randir> Any ideas how to implement the three-move repetition rule in a chess engine?
15:39:09 <Fuuzetsu> wow, things like this exist https://chessprogramming.wikispaces.com/Repetitions
15:39:56 <EvanR> the three move repetition rule, isn't that completely subjective, according to the rules?
15:40:15 <EvanR> you have the option of taking a draw but you arent forced to
15:40:42 <EvanR> so seems algorithmically pointless
15:41:01 <Cale> EvanR: It seems important. Sometimes taking a draw is good.
15:41:13 <Cale> It's better than losing by far.
15:41:16 <EvanR> i guess if you have a way to force three move repetition
15:41:18 <Fuuzetsu> how? say you're making a chess game online or whatever, if it's in a stalemate where repetitions happen, draw may be good
15:41:27 <Cale> EvanR: Yeah, it comes up quite a lot.
15:42:22 <Cale> It's weird that it's three times and not once though.
15:42:34 <EvanR> that would be a lot easier
15:42:45 <Cale> (or I guess twice?)
15:43:19 <EvanR> not only that, its any three board positions repeated at any point in the game
15:43:23 <Fuuzetsu> once may be a mistake and by twice you start sweating :)
15:43:25 <EvanR> so its a complex rule
15:43:52 <Cale> Fuuzetsu: Yeah, I guess it's just to account for the human factor of having to remember all the previous board positions.
15:44:32 <Fuuzetsu> good thing we have those computer things
15:44:43 <Cale> Also, it's not just the locations of the pieces, but the right to castle, the right to capture en passant for each pawn...
15:44:50 <EvanR> and whose turn it is
15:45:01 <Cale> yeah
15:45:03 <Fuuzetsu> yes
15:45:07 <Fuuzetsu> it's an interesting rule
15:45:09 <Fuuzetsu> didn't know it existed
15:45:24 <Cale> Chess is so buggy
15:45:25 <Cale> lol
15:45:32 <fengshaun> it's not the board throughout the game, the board has to be the same in three *consecutive* moves
15:45:46 <EvanR> im not sure about that
15:45:56 <Fuuzetsu> fengshaun: pretty sure that's wrong based on what I read a minute ago
15:46:30 <Fuuzetsu> the top 3 definitions stated either throughout the whole game or within 75 moves IIRC
15:46:43 <Cale> Chess 1.1 patch notes: Fixed a bug where sometimes castling wouldn't work if squares between the king and rook were in range of attack by an opposing piece.
15:47:01 <fengshaun> the 75 move rule is a whole other unrelated thing
15:47:03 <Fuuzetsu> Cale: is that actually disallowed
15:47:08 <Cale> (I know ;)
15:47:14 <Cale> yes, it is
15:47:26 <Fuuzetsu> o, didn't know
15:47:28 <Cale> You're not allowed to castle through a threat
15:47:29 <Fuuzetsu> only played as a kid really
15:48:35 <Cale> Fixed a bug where sometimes pawns who had moved 2 spaces on the first turn could capture pieces on a square which wasn't the square they landed on.
15:48:44 <HeladoDeBrownie> Cale, it would be neat if they had a database of "edge case" moves for the purpose of checking for compliance of chess rules in a given engine ;)
15:49:19 <EvanR> chess Arbitrary instance
15:51:04 <Cale> Fixed a bug where the game would crash if 50 moves had passed without any pawn moves or captures.
15:52:46 <kadoban> Hah…how would that situation even come up, and why would it cause a crash :-/
15:54:57 <monochrom> after hearing that squid can remove all your files (or die trying), I am no longer surprised by any bizzare bug and crashing
15:56:55 <Peaker> monochrom: hey, like early GHC
15:57:28 <Peaker> "if it compiles it works. If it doesn't, it is destroyed in a fire!"
15:57:50 <Rembane> That's the best feature of any compiler ever.
15:58:05 <EvanR> lol
15:58:06 <randir> can I construct a piece data-type that includes color, without using a record?
15:58:07 <tdammers> makes you think twice about kicking off a build
15:58:15 <randir> like data Piece = Pawn | Bishop | Knight | Rook | Queen | King  + White|Black
15:58:46 <Cale> data Colour = White | Black
15:58:56 <EvanR> maybe do data Piece = White Shape | Black Shape
15:59:10 <arkeet> why avoid a record?
15:59:10 <Cale> yeah
15:59:13 <arkeet> (= product type)
15:59:48 <randir> k
15:59:49 <randir> ty
16:00:17 <Fuuzetsu> wow look at that inefficient code; type Piece = Word8, type Colour = Bool, problem solved
16:00:18 <Fuuzetsu> ;^)
16:00:59 <tdammers> type Piece = String -- then import Prelude.PHP and all is fine
16:01:00 <mniip> Fuuzetsu, enumerations, and even specialized Bool equivalents are often very useful
16:01:12 <Fuuzetsu> mniip: I'm joking.
16:01:37 <Fuuzetsu> tdammers: can you even type alias in PHP
16:01:40 <Fuuzetsu> or type specify anything
16:01:43 <arkeet> what's a type
16:01:46 <Fuuzetsu> hue
16:01:48 <EvanR> Fuuzetsu: you sure can
16:02:05 <EvanR> you can make it warn if your argument is the wrong class
16:02:23 <tdammers> you can also query for the type of something at runtime
16:02:27 <EvanR> but it still cant tell the diff between number, string, null etc
16:02:32 <EvanR> in that way
16:02:53 <Fuuzetsu> tdammers: I don't consider those runtime tags to be types by any stretch of imagination
16:02:56 <tdammers> is_int(), is_string(), is_null()
16:03:04 <EvanR> is_defined
16:03:20 * Fuuzetsu shudders
16:03:23 <tdammers> Fuuzetsu: in that case, no, PHP doesn't have any types whatsoever
16:03:38 <Fuuzetsu> tdammers: well, PHPValue I guess ;)
16:03:56 <tdammers> yeah... one type, if you prefer to look at it that way
16:04:16 <tdammers> (not like any of the other dynamic languages are any different in that regard)
16:04:23 <arkeet> 0 type information.
16:04:33 <Fuuzetsu> yes
16:05:17 <mniip> the PHP category isn't very interesting
16:07:52 <Fuuzetsu> neither is Hask
16:08:11 <zomg> Fun fact: my Haskell PHP parser used PHPValue for most things
16:08:11 <zomg> :P
16:09:13 <Denommus> let's rewrite MRI in Haskell
16:09:19 <Denommus> wait, I'm not in #emacs
16:10:01 * hackagebot bit-vector 0.2.0 - Simple bit vectors for Haskell  http://hackage.haskell.org/package/bit-vector-0.2.0 (AdamFoltzer)
16:12:21 <Fuuzetsu> zomg: most?
16:12:53 <benzrf> oy Denommus
16:13:00 <benzrf> why are you mentioned on the wtfpl faq
16:13:45 <Denommus> benzrf: because I was on a discussion over what freedom of software means and argued something about WTFPL with someone that could edit the FAQ. It turns out I was right, but the guy didn't change the FAQ, so it became a weird joke that no one will get
16:14:09 <Denommus> I don't even remember what my argument was
16:15:01 <SrPx> Hello. Other day you suggested me JuicyPixels for dealing with images. But I noticed juicypixels doesn't define a functor instance for Image. It doesn't have a Zip function, a fold function, traverse. Nothing. So, how do I do things like comparing 2 images using juicypixels?
16:15:13 <zomg> Fuuzetsu: I forget, maybe it was all. I haven't touched it in a while
16:15:33 <sydneyhacker> msg NickServ SET HIDEMAIL ON
16:15:46 <Fuuzetsu> SrPx: Why do you think you need Functor to compare things?
16:15:59 <SrPx> Fuuzetsu: I never said that...
16:16:55 <Zekka> Hey, is STArray Traversable? If so, where's the instance?
16:16:56 <Fuuzetsu> your message certainly implies that it should
16:17:00 <SrPx> But without a "zip" I can't compare 2 images pixel per pixel other than implementing it myself... obviously that is always simple on Haskell, but why not just have the common functions... maybe it would be better if I just converted those images to Vectors since they offer a very nice API?
16:18:59 <Zekka> Anyone? This seems like a pretty obvious instance but I can't find anything of the sort by googling
16:19:25 <Fuuzetsu> SrPx: it has been a while since I used it but I think comparing the underlying vectors is how you're meant to do it
16:19:54 <SrPx> Oh! D'oh. Thank you that will work <3
16:20:11 <pixelgrid> hey guys
16:20:21 <pixelgrid> i have a question
16:20:26 <pixelgrid> (\x y -> x+y) ⇔ (+)
16:20:42 <pixelgrid> is this the haskell argument reducing in action?
16:21:03 <Zekka> pixelgrid: That's an eta reduce
16:21:23 <SrPx> actually... that is not a good solution since it doesn't allow to work with pixels
16:21:29 <SrPx> that is, the vector stores Word8's
16:21:30 <hpc> technically, two eta reductions
16:21:46 <pixelgrid> sorry what does eta mean?
16:21:48 <hpc> first to (\x -> (+) x)
16:21:52 <hpc> pixelgrid: it's a greek letter
16:21:56 <hpc> then to (+)
16:22:15 <pixelgrid> sure
16:22:18 <pixelgrid> thanks
16:22:23 <Iceland_jack> pixelgrid: The "eta" part isn't meaningful, "eta reduction" is just what going from "(\x -> f x)" to "f" is called
16:22:25 <hpc> pixelgrid: there's three different major reductions (translation rules) in lambda calculus
16:22:28 <hpc> alpha, beta, eta
16:22:48 <pixelgrid> helps reducing code
16:22:51 <hpc> you've seen eta
16:22:54 <hpc> alpha is just renaming
16:22:59 <pixelgrid> but doesnt it make code less readable?
16:23:03 <Fuuzetsu> o, apparently youtube-dl uses pandocc
16:23:05 <Fuuzetsu> pandoc*
16:23:07 <Iceland_jack> pixelgrid: Sometimes
16:23:08 <hpc> (\x -> whatever x) becoming (\y -> whatever y)
16:23:17 <mniip> pixelgrid, "reduction" in this context is formal and mathematical
16:23:20 <hpc> pixelgrid: it's not about readability, it's evaluating expressions
16:23:25 <mniip> nothing to do with readability
16:23:36 <hpc> pixelgrid: like execution rules for a state machine
16:23:44 <hpc> beta reduction is function application
16:23:49 <mniip> also to be fair (+) is just as readable, and even less ugly, than (\x y -> x + y)
16:24:01 <hpc> ((\x -> whatever x) y) becomes (whatever y)
16:24:58 <pixelgrid> really trying to get into the haskell mindset
16:25:01 * hackagebot statistics 0.13.2.3 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.13.2.3 (BryanOSullivan)
16:25:14 <pixelgrid> so im looking into these
16:25:15 <pixelgrid> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
16:25:24 <pixelgrid> http://learnyouahaskell.com/
16:25:29 <pixelgrid> http://book.realworldhaskell.org/read/
16:25:38 <pixelgrid> good starting point?
16:25:49 <Hijiri> try these too
16:25:51 <Hijiri> https://github.com/bitemyapp/learnhaskell
16:26:06 <hpc> pixelgrid: a lot of haskell comes down to equational reasoning
16:26:16 <hpc> which is to say, when you see an equals sign in say, java
16:26:21 <hpc> that means "assign this value to that"
16:26:26 <SwashBuckla> Hijiri: that is a geat link :)
16:26:28 <hpc> in haskell, it means "these things are equal"
16:26:30 <Iceland_jack> SwashBuckla: :)
16:26:55 <Iceland_jack> SwashBuckla: (Bring some scones please.)
16:27:05 <hpc> and you can evaluate a haskell expression in much the same way as solving an equation on paper
16:27:12 <SwashBuckla> Iceland_jack: (yes okay)
16:27:32 <hpc> using the three reduction rules above, among other things
16:27:36 <SwashBuckla> Iceland_jack: I have resumed Yorgey's course, by the way. I am up to 07-monads etc
16:28:02 <Iceland_jack> SwashBuckla: That's great! How far did you get with the Chalmers one?
16:28:09 <sebastianrkg> can I reference one of the other fields in a record declaration?
16:28:15 <SwashBuckla> I finished Chalmers intro to FP aaaages ago, Iceland_jack 
16:28:28 <pixelgrid> im a web dev just trying out haskell
16:28:41 <Iceland_jack> Geez :)
16:28:43 <pixelgrid> is yesod or anything similar gaining traction ?
16:28:44 <SwashBuckla> I decided, very late in the process, to add quickCheck properties to all the Yorgey (why do I keep typing Yogi?) exercises
16:28:54 <Iceland_jack> SwashBuckla: That's awesome!
16:28:59 <sebastianrkg> eg. Container { id = 1, calc = id * 2 }
16:29:03 <hpc> there's a variety of frameworks that are good at different things
16:29:13 <SwashBuckla> Iceland_jack: but I found it so hard that I just stopped entirely :(
16:29:21 <SwashBuckla> then work got me down etc etc
16:29:23 <Iceland_jack> Sure
16:29:36 <pixelgrid> so web dev can be fun in haskell?
16:29:37 <Iceland_jack> Have you looked into monadic QuickCheck and generating/shrinking/showing functions?
16:30:01 <hpc> pixelgrid: extremely
16:30:09 <hpc> pixelgrid: as an example, start with
16:30:19 <hpc> wrap open close middle = do
16:30:25 <SwashBuckla> Iceland_jack: I'm going to ask you where I go to learn this... knowing that the answer is probably "Chalmer's Intro to FP"
16:30:25 <hpc>   putStrLn open
16:30:26 <hpc>   middle
16:30:29 <hpc> putStrLn close
16:30:39 <hpc> pixelgrid: and then div = wrap "<div>" "</div>"
16:30:57 <hpc> repeat for the right tags and you can do stuff like
16:31:01 <hpc> foo = html $ do
16:31:03 <hpc>   head $ do
16:31:07 <hpc>     title "whatever"
16:31:09 <hpc>   body $ do
16:31:10 <hpc>     ...
16:31:12 <Iceland_jack> SwashBuckla: It isn't actually, if you have 30 minutes you can watch this talk on shrinking/showing functions https://www.youtube.com/watch?v=CH8UQJiv9Q4
16:31:22 <hpc> (appologies for the tons of lines)
16:31:42 <hpc> pixelgrid: for an actually good implementation of that, check out blaze-html
16:31:57 <Fuuzetsu> hpc: lpaste down for you? :)
16:32:30 <hpc> oh right
16:32:37 <hpc> man, i have had such a stupid day
16:32:38 <pixelgrid> hpc thank you
16:32:59 <Iceland_jack> SwashBuckla: And to use Monadic QuickCheck you only need a handful of combinators, I submitted a pull request to update the documentation on Hackage but it hadn't been updated last I checked
16:33:37 <Iceland_jack> No wait it has been SwashBuckla
16:33:37 <TRManderson> What's well developed, not insignificant, and relatively simple to understand Haskell project?
16:33:52 <Iceland_jack> SwashBuckla: Check this out hackage.haskell.org/package/QuickCheck-2.8/docs/Test-QuickCheck-Monadic.html
16:33:54 <TRManderson> I'm looking to learn a little more by example
16:34:19 <hpc> TRManderson: look at libraries on hackage that do specific things
16:34:47 <hpc> TRManderson: not stuff like xmonad that's huge, but things like markdown parsers, things that do IO, etc
16:35:10 <TRManderson> Oh yeah, pandoc is a thing!
16:35:23 <TRManderson> Would pandoc be an alright thing to look at?
16:35:44 <hpc> yes
16:35:49 <mpickering> It is quite simple 
16:35:50 <TRManderson> thanks
16:36:07 <hpc> pandoc has a fairly obvious structure, and the individual modules are quite digestable
16:36:14 <platz> TRManderson: is there are particular domain you're intereted in?  parsing, api's, data structures?
16:36:43 <TRManderson> platz: Right now I'm just trying to get an idea of general project structure
16:37:02 <TRManderson> I can do things with Haskell, but I don't know "the haskell way" of doing things
16:37:10 <platz> TRManderson: fair enough
16:37:23 <platz> i'd like some of that information myself ;)
16:37:38 <platz> but different kinds of applications will have different structure
16:37:52 <platz> unfortunately there is no "one way" of doing things in haskell
16:38:04 <platz> compared to say python
16:38:16 * EvanR wonders how much any of that is true
16:38:17 <mniip> TTMTOWTDI
16:38:25 <mniip> TMTOWTDI
16:38:38 <Iceland_jack> TRManderson: Programs in other languages quite often become libraries in Haskell, that's something to keep in mind
16:38:43 <platz> of course i may be wrong, feel free to disagree
16:38:54 * mpickering would appreciate it if TRManderson learnt about the structure of pandoc by fixing one of the open bugs on the tracker
16:39:10 <hpc> haha
16:39:21 <TRManderson> mpickering: I'll look at the tracker
16:39:47 <TRManderson> The next thing I intend to use Haskell for is Google Code Jam, not anything I'll support in the long term
16:40:09 <TRManderson> either that or an IRC bot, but there's probably a library for most of the IRC things
16:40:12 * mpickering thinks that the bugs tagged as "minor" should be quite easy to solve
16:40:46 <TRManderson> mpickering: okay, I'll see
16:40:51 <Denommus> TRManderson: I'll also use Haskell for the Google Code Jam
16:42:18 <Denommus> TRManderson: but knowing well how IO works is a must
16:42:42 <TRManderson> Denommus: Why do you say that?
16:43:12 <TRManderson> and how well is "well"?
16:43:49 <Denommus> TRManderson: because the Code Jam requires you to read input from a file and produce a file as output (though you could just pipe stdout to a file)
16:43:54 <rola> why wouldn't one want TupleSections by default
16:44:14 <arkeet> there are lots of extensions that would be fine by default.
16:44:36 <Denommus> TRManderson: well, you must know how to take command line arguments, how to open and read files, and how to write (either to a file or to stdout, if you are piping)
16:44:37 <arkeet> but they're not standard haskell.
16:44:45 <TRManderson> My plan was to just go cat infile | runhaskell problem > outfile
16:45:06 <Denommus> TRManderson: that... would probably work, too
16:45:23 <jle`> it's just like...it's not actually haskell
16:45:40 <jle`> and momentum on making a new haskell standard/report has fizzled out
16:45:43 <platz> there's a function called "interact" which basically makes your main function act like a pipe too
16:45:47 <TRManderson> lines over getContents, sequence . map putStrLn $ for output
16:45:57 <arkeet> sequence . map f = mapM f
16:46:01 <platz> but it's line based
16:46:10 <TRManderson> oh cool, thanks arkeet
16:46:29 <TRManderson> platz: yeah, I know about interact, not *quite* what I want because multiline problem cases are a thing
16:46:46 <Fuuzetsu> TRManderson: there are at least 5 IRC libraries but I think none of them complete and/or up to date
16:46:53 <Denommus> TRManderson: anyway, you seem to know enough to enter GCJ. Good luck to us
16:47:19 <TRManderson> Denommus: The worry is just writing the solutions in time! but yeah, good luck to us :)
16:50:02 * hackagebot Titim 0.1.1.0 - Game for Lounge Marmelade  http://hackage.haskell.org/package/Titim-0.1.1.0 (Jefffrey)
16:50:11 <mniip> unfortunately most advanced IRC bots are rather unidiomatic structures of things with dynamic reloading support
16:50:21 <mniip> which is a rather complicated thing to do in haskell
16:51:03 <Denommus> mniip: I heard FRP maps quite well to bots
16:51:14 <jle`> FRP doesn't but my new library does bots pretty well :3
16:51:27 <mniip> there should be a library for that... a lot of real world programs are dynamic reloading systems
16:52:45 <zipper> jle`: Which is your new library?
16:52:56 <jle`> oh i don't know about dynamic reloading yet
16:53:20 <jle`> that isn't there yet, but it does implicit serialization of components
16:53:23 <jle`> https://github.com/mstksg/auto#a-chatbot
16:55:57 <mmachenry> I current am writing a program where I want to pass several things through to my IO functions. A logging object and a db handle. This to me says I should probably use ReaderT MyStuff IO
16:56:30 <mmachenry> The problem is that I now have to put liftIO around every single IO action I've done. Is there a better way to do this?
16:56:57 <zipper> jle`: Do you get paid to write haskell? or how did you get the time to accumulate that much haskell knowledge?
16:57:11 <jle`> i'm a phd student so my job is basically to think about things all day
16:57:24 <mniip> jle`, dynamic reloading is /very/ nasty
16:57:36 <mniip> there are barely any haskellish idioms that apply
16:57:47 <jle`> yeah, i deifnitely misread your statement earlier :)
16:58:02 <mniip> it's practically all nasty IO and then some more Data.Dynamic
16:58:19 <mniip> with a tad bit of GHC.Prim.Any and unsafeCoerce
16:59:13 <ungov> Hi, I'm a total noob, so please bear with me
16:59:14 <zipper> jle`: Oh my. That's interesting.
16:59:39 <ungov> So I followed this tutorial: https://haskellonheroku.com/tutorial
16:59:42 <jle`> ungov: we are all noobs in one way or another :)
16:59:50 <ungov> True!
17:00:09 <jle`> let he who has never noobed throw the first stone.
17:00:34 <ungov> Now, I want to extend the code so that I can store and display images 
17:01:24 <ungov> So I'm pretty much duplicating every "Note" function
17:01:50 <ungov> But instead of notes, I'll use "Image"
17:02:22 <ungov> Which is probably gonna be a ByteArray or something of the sort, instead of a Text
17:02:34 <ungov> Makes any sense?
17:07:41 <zipper> jle`: first of all let me congratulate you for having a haskell project that actually does some explaining in the README
17:07:52 <zipper> I hardly see that
17:08:03 <ungov> Thank you! :)
17:08:28 <jle`> ungov: that makes sense :)
17:08:33 <ungov> I think it is a pretty good tutorial actually
17:08:35 <jle`> zipper: thank you :) that was one of the project goals
17:09:03 <pingu> ungov: That will not work, unfortunately.
17:09:11 <zipper> jle`: Second. So many new functions. proc, (-<)
17:09:11 <pingu> With the current version of servant on hackage.
17:09:20 <zipper> :t proc
17:09:21 <lambdabot> Not in scope: ‘proc’
17:09:29 <pingu> ungov: the (pending release) 0.3 version of servant allows multiple content types
17:09:32 <pingu> which would allow you to send an image.
17:09:51 <pingu> best you can do with the version in that tutorial will be sending a JSON object with an image encoded in it, somehow.
17:09:55 <jle`> zipper: proc is actually syntax, and it's explained in the tutorial
17:10:02 <zipper> jle`: Where are they from? I really like irc bots I don't know why so I'd like to write one in haskell.
17:10:26 <zipper> jle`: Oh you answered right before I hit enter
17:10:36 <zipper> :t (-<)
17:10:37 <lambdabot>     Not in scope: ‘-<’
17:10:37 <lambdabot>     Perhaps you meant one of these:
17:10:37 <lambdabot>       ‘-’ (imported from Prelude), ‘<’ (imported from Data.Ord),
17:10:47 <geekosaur> likewise syntax
17:10:52 <geekosaur> like <- is syntax
17:10:53 <zipper> I'm so sleepy I don't want to hoogle.
17:10:56 <glguy> zipper: If you're doing IRC stuff in Haskell you might join #haskell-irc, too.
17:10:58 <zipper> glguy: Oh
17:11:17 <zipper> glguy: I didn't expect such a channel to exist
17:11:30 <arkeet> zipper: -< is also just syntax.
17:11:37 <glguy> It's still small, but there are a number of people interested in the topic
17:11:41 <arkeet> like <-
17:11:42 <jle`> i had no idea about this either
17:11:56 <pingu> ungov: does that make sense? If you want to display images with that version of servant you're not going to have much luck.
17:12:16 <jle`> zipper: https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#brief-primer-on-proc-notation
17:14:19 <ungov> pingu: thank you. So I should just update the servant version
17:17:24 <pingu> ungov: The major release that would allow you to serve images nicely is 0.3
17:17:40 <pingu> Which is not on hackage yet. As it's not released yet.
17:17:46 <Roger__> Anyone know why a Gloss program would hang when compiled normally with GHC but run fine in GHCI or when compiled with "-osuf p_o -prof -auto-all"?
17:17:50 <pingu> ungov: I just realised, though, that you can probably do what you want with the Raw endpoint.
17:17:59 <pingu> Raw and warp helpers for serving files.
17:20:29 <pingu> So... Something like "images" :> Capture "image_name" Text :> Raw
17:20:34 <pingu> Would work.
17:20:51 <TRManderson> :t (:>)
17:20:52 <lambdabot>     Not in scope: data constructor ‘:>’
17:20:52 <lambdabot>     Perhaps you meant one of these:
17:20:52 <lambdabot>       ‘Seq.:>’ (imported from Data.Sequence),
17:21:28 <Fuuzetsu> in servant package :)
17:21:51 <ungov> pingu: those pointers will surelly help my tinkering
17:21:59 <ungov> pingu: thanks!
17:40:15 <srid> Hmm, GHC is taking ages to build.
17:40:34 <arkeet> that is normal.
17:41:34 <Fuuzetsu> By design WONTFIX
17:42:10 <randir> how can I put an element in a list every x elements?
17:42:27 <randir> like every 10 "\n" into a list of strings
17:42:48 <arkeet> split up the list into chunks of 10, then intercalate.
17:43:15 <pingu> or fold with a counter
17:43:17 <randir> how do I do that?
17:43:18 <arkeet> :t chunksOf -- from Data.List.Split
17:43:19 <lambdabot> Int -> [e] -> [[e]]
17:43:20 <randir> arkeet?
17:43:21 <randir> k
17:43:21 <arkeet> :t intercalate
17:43:21 <pingu> intercalate sounds clearer.
17:43:21 <lambdabot> [a] -> [[a]] -> [a]
17:44:10 <arkeet> > intercalate "." (chunksOf 4 ['a'..'z'])
17:44:11 <lambdabot>  "abcd.efgh.ijkl.mnop.qrst.uvwx.yz"
17:50:05 * hackagebot Titim 0.1.3 - Game for Lounge Marmelade  http://hackage.haskell.org/package/Titim-0.1.3 (Jefffrey)
17:54:54 <marchelzo_> @pl \xs i -> xs !! (i+1)
17:54:55 <lambdabot> (. (1 +)) . (!!)
17:57:23 <mniip> marchelzo_, (!!) . tail
17:57:57 <arkeet> clever.
17:58:13 <marchelzo_> mniip: ah, nice!
17:58:17 <pavonia> :t (!!) . tail
17:58:18 <lambdabot> [a] -> Int -> a
18:06:27 <eiffel> What's the best way to test this code? - should I create a cabal sandbox for it, or can I run it another way? https://github.com/ocharles/blog/blob/master/code/2013-12-06-persistent.hs
18:06:53 <arkeet> just runghc it?
18:06:58 <arkeet> or ghci if you want to play around
18:10:54 <eiffel> 10-4 thanks arkeet
18:16:01 <randir> I have a type data Piece = White Shape | Black Shape 
18:16:10 <randir> where data Shape = Pawn | Knight | etc...
18:16:23 <randir> isWhite (White _) = True works
18:16:34 <randir> but isPawn (_ Pawn) = True doesn't work
18:16:36 <randir> why not?
18:16:55 <randir> I can't implicitly dive down a level, I guess? 
18:17:00 <hiptobecubic> randir, what would be the type of isPawn?
18:17:15 <randir> Piece -> Bool
18:17:37 <EvanR> would be cool if that worked but it dont
18:17:54 <EvanR> patterns could be fancier but they arent
18:18:15 <randir> so-- what's the nicest way to do this?
18:18:21 <EvanR> use a couple more cases
18:18:27 <hiptobecubic> What if i make data SuperHero = Shade Shape; batman = Dark Knight :: SuperHero?
18:18:59 <EvanR> White Pawn = True
18:19:00 <Iceland_jack> randir: You can get it to work if you want to
18:19:02 <EvanR> Black Pawn = True
18:19:16 <EvanR> _ = False
18:19:16 <timothyh> my global ghc-pkg database is messed up. what's the easiest way to nuke it from orbit? (OS X)
18:19:46 <EvanR> also you might not need all those Bool functions
18:20:03 <randir> Iceland_jack: How?
18:20:26 <Iceland_jack>     data Piece = White { getShape :: Shape } | Black { getShape :: Shape }
18:20:27 <Iceland_jack> and then
18:20:27 <Iceland_jack>     pattern IsPawn <- (getShape -> Pawn)
18:20:27 <randir> EvanR: Ah, yeah, that'll work. Is that the way you'd recommend?
18:20:38 <Iceland_jack> randir: I would rather model it as a simple product though
18:20:40 <EvanR> randir: make sure you need the Bool functions
18:20:52 <Iceland_jack>     type Piece = (Color, Shape)
18:21:10 <Iceland_jack> Then you can write
18:21:10 <Iceland_jack>     pattern IsPawn <- (_, Pawn)
18:22:01 <randir> Iceland_jack: that makes sense
18:22:07 <Iceland_jack> Or if you want to create a new data type
18:22:07 <Iceland_jack>     data Piece = MkPiece Colour Shape  -- (not Color)
18:22:07 <Iceland_jack>     pattern IsPawn <- MkPiece _ Pawn
18:23:00 <Iceland_jack> randir: Hope that helped, you need an extension called PatternSynonyms for that
18:24:16 <randir> Iceland_jack: I think I'll go with the product type. I don't think I'll need a language extension for it though?
18:24:32 <randir> isPawn (_,Pawn) = True should work
18:24:37 <randir> from Piece -> Bool, right?
18:24:38 <Iceland_jack> randir: Using the product type you can always simply write
18:24:39 <Iceland_jack>     foo (_, Pawn) = ...
18:24:39 <Iceland_jack> yes
18:25:06 <Iceland_jack> There are some downsides to that approach but it's fine
18:25:33 <Fylwind> is there a way to make automatic differentation work with Double -> Complex Double functions in the ad package?
18:26:07 <randir> Iceland_jack: What are the downsides?
18:27:06 <Iceland_jack> randir: Well first of all you expose the implementation, if you at some point in the future decide to go from 'type Piece = (Colour, Shape)' to 'data Piece = MkPiece Colour Shape' you'll need to rewrite all the existing patterns
18:28:02 <Iceland_jack> Using pattern synonyms you can specify the pattern
18:28:02 <Iceland_jack>     pattern IsPiece <- (_, Piece)
18:28:03 <Iceland_jack> and then change it to this and existing patterns will continue to work
18:28:03 <Iceland_jack>     pattern IsPiece <- MkPiece _ Piece
18:28:32 <Iceland_jack> oops, *Pawn
18:28:57 <Iceland_jack> The second issue is simply ugliness, (_, Pawn) is fine in the small but it gets less attractive when you start nesting it in other patterns
18:29:54 <randir> hmm
18:30:04 <tromp> :t scanl
18:30:04 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
18:30:07 <tromp> :t scanr
18:30:08 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
18:30:12 <randir> I think I'll stick with this for now, but I'll definitely keep that in mind, thanks.
18:30:17 <tromp> :t scanl1
18:30:18 <lambdabot> (a -> a -> a) -> [a] -> [a]
18:30:23 <Iceland_jack> Great :)
18:31:07 <Iceland_jack> randir: I also wrote something about this some time ago, the first part of it exactly deals with maintaining abstraction
18:31:07 <Iceland_jack> @google pattern synonyms IRC bot
18:31:08 <lambdabot> https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
18:31:17 <tromp> > scanr (+) 0 [1,2,3]
18:31:19 <lambdabot>  [6,5,3,0]
18:31:25 <Iceland_jack> But it won't matter much starting out
18:31:28 <tromp> > scanl1 (+) 0 [1,2,3]
18:31:30 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[a0]’
18:31:37 <arkeet> > scanl1 (+) [1,2,3]
18:31:38 <lambdabot>  [1,3,6]
18:31:53 <tromp> thx:)
18:33:00 <randir> Iceland_jack: Nice, looks like a cool article 
18:36:08 <randir> Iceland_jack: I'm writing a Chess engine (with performance not as the main goal, but obviously desirable), and I'm planning on using an IntMap from square -> Piece
18:36:16 <randir> do you think that works well enough?
18:37:08 <Iceland_jack> That should be fine
18:37:46 <randir> I'm making a function to get a list of all the white pieces.. do you think it's worth having a list of locations of white pieces, or should I just manually generate that each time?
18:38:06 <randir> It's mainly a design question, just curious what you think.
18:39:32 <Iceland_jack> Both are valid choices, storing them separately does add a bit of complexity but not terribly much
18:40:01 <randir> Yeah.
18:40:23 <Iceland_jack> randir: A quick fyi, you can filter using patterns in list comprehensions
18:40:24 <Iceland_jack>     blackPieces pieces = [ piece | piece@IsBlack <- pieces ]
18:40:38 <Iceland_jack> Where IsBlack might be defined as 'pattern IsBlack <- (Black, _)'
18:40:54 <randir> Ooh, now that does seem really useful.
18:41:35 <Iceland_jack> The function Data.Maybe.catMaybes does a similar thing
18:41:36 <Iceland_jack> @src catMaybes
18:41:36 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:41:51 <Iceland_jack> > catMaybes [Nothing, Just 'a', Nothing, Just 'b', Nothing, Just 'c', Nothing]
18:41:52 <lambdabot>  "abc"
18:41:59 <Iceland_jack> > [ x | Just x <- [Nothing, Just 'a', Nothing, Just 'b', Nothing, Just 'c', Nothing] ]
18:42:00 <lambdabot>  "abc"
18:42:14 <randir> I've been using some Python recently, and it's def. made me realize how nice Haskell's comprehensions are 
18:43:23 <randir> by the way, how much additional memory will it actually take up when I create a new IntMap based on an old one? 
18:43:34 <fragamus> yeah i tried to make a functor in ruby out of a hash table and man it was rough
18:43:38 <randir> some people were telling me earlier that it didn't create a whole new one, but refered to the old structure
18:43:43 <fragamus> it worked though
18:44:09 <fragamus> it was a hierarchical hash table
18:44:24 <Iceland_jack> randir: You can take a look at https://hackage.haskell.org/package/containers-0.3.0.0/docs/src/Data-IntSet.html yourself
18:44:25 <lethjakman> fragamus: is it open source? I'd like to see that
18:44:46 <Iceland_jack> randir: Yes, it shares existing parts of the tree as much as possible
18:45:02 <Iceland_jack> and when it needs to rearrange the tree, it still shares the values in the leafs
18:46:00 <Iceland_jack> (randir: List comprehensions have somewhat fallen out of favour, I still quite like them when filtering by pattern matching. Someone asked me to find a local maximum where you had to split a list into 3 adjacent values and filter the values that were greater than their left and right value)
18:46:12 <Iceland_jack> a very nice way to do that is
18:46:12 <Iceland_jack> > [ (a, b, c) | a:b:c:_ <- tails [1,2,3,3,4] ]
18:46:14 <lambdabot>  [(1,2,3),(2,3,3),(3,3,4)]
18:46:50 <Iceland_jack> Something like
18:46:50 <Iceland_jack> > [ b | a:b:c:_ <- tails [1,2,10,3,5,4], a < b, b > c ]
18:46:51 <lambdabot>  [10,5]
18:46:59 <randir> why ave they fallen out of favour? :/
18:47:02 <randir> have*
18:47:12 <Iceland_jack> Becuase they are not nice to write in compositional style
18:47:16 <Iceland_jack> *Because
18:47:30 <randir> eh, fair enough
18:47:36 <randir> I still love them though
18:47:54 <fragamus> lethjakman: no
18:47:59 <Iceland_jack> They are amazing to work with for the right problem (especially with PatternSynonyms)
18:49:51 <lethjakman> fragamus: oh, well that'd make a great blog post
18:50:04 <lethjakman> :)
18:56:14 <erikd> if i compile a program (that uses forkIO) with --threaded, how do i get it to run on multiple cores? i've tried ./program +RTS -N2
18:56:37 <erikd> and it doesn't seem to like "-N2"
18:56:58 <erikd> it says: unknown RTS option: -N2
18:57:48 <arkeet> did you compile it with -rtsopts
18:59:26 <erikd> arkeet: ghc -Wall -O2 -threaded -rtsopts test.hs -o test
19:00:09 <arkeet> should work then.
19:02:05 <erikd> hmmm, this is on arm64. ghc --info says : "RTS ways","l debug  thr thr_debug thr_l thr_p  thr_debug_p"
19:03:40 <lethjakman> I see the pattern _ [] = [] a lot
19:03:48 <lethjakman> is it just returning [] to represent an empty thing?
19:04:10 <arkeet> [] is an empty list.
19:04:11 <mmachenry> lethjakman: Yes. It's returning the empty list.
19:04:36 <mmachenry> lethjakman: The underscore isn't part of the same argument, so that's not really one pattern. 
19:04:46 <lethjakman> what do you mean?
19:05:00 <arkeet> if you see  f _ [] = []
19:05:07 <arkeet> _ and [] match two different arguments.
19:05:10 <mmachenry> You're seeing that a lot because in some base cases for functions the non-list argment doesn't matter if the input is false.
19:05:24 <lethjakman> ahhh ok
19:05:32 <arkeet> it means "I don't care what the first argument is if the second is []"
19:05:35 <mmachenry> Perhaps I want to invoke a function "f" on every element of the list.
19:05:41 <arkeet> @src map
19:05:41 <lambdabot> map _ []     = []
19:05:41 <lambdabot> map f (x:xs) = f x : map f xs
19:05:50 <mmachenry> I don't care what that function is when I receive and empty list.
19:05:59 <mmachenry> So I match my arguments with _ []
19:06:00 <lethjakman> https://gist.github.com/anonymous/b8652513d17154b5867d
19:06:02 <mmachenry> And return []
19:06:03 <lethjakman> so I'm looking at that
19:06:22 <mmachenry> lethjakman: Yes, exactly as we were saying.
19:06:31 <lethjakman> the = [] at the end of that, does that set just the last argument in that?
19:06:39 <arkeet> no, that's the return value.
19:06:42 <lethjakman> oh
19:06:46 <lethjakman> so it exits at that point
19:06:52 <mmachenry> The function you're filtering by is matched by _ and discarded because the filter of the empty list is the empty list no matter what the function is.
19:07:06 <lethjakman> ahhhh
19:07:09 <lethjakman> ok
19:07:25 <lethjakman> what about the p (x:xs)
19:07:36 <mmachenry> "filter _ [] = [] " in English is "The filter of any function and the empty list is equal to the empty list. "
19:07:38 <arkeet> that matches the first argument with p and the second argument with x:xs.
19:07:39 <lethjakman> ahhh that's to be recursive
19:07:43 <arkeet> yes.
19:07:54 <lethjakman> so you can reuse p
19:07:56 <lethjakman> right?
19:08:06 <arkeet> there wouldn't be much point if you couldn't.
19:08:12 <lethjakman> that makes sense
19:08:19 <lethjakman> thank you :)
19:08:29 <arkeet> it's hard to talk about values without naming them.
19:09:17 <lethjakman> yeah, is it common practice in haskell to use single letter variables?
19:09:26 <arkeet> it's quite common.
19:09:26 <lethjakman> cause I'm not a fan of that in this book
19:09:55 <arkeet> especially for fairly generic things like filter.
19:09:58 <mmachenry> lethjakman: I don't tend to do that.
19:09:59 <EvanR> let myInt :: Int = xWhichIsAnInt + (1 :: Int)
19:10:17 <EvanR> there now its obvious
19:10:27 <mmachenry> lethjakman: But I'm not really writing generic code and I am working with a bunch of people who don't know Haskell. :)
19:10:30 <lethjakman> what is the filter p (x:xs) part called again?
19:10:38 <lethjakman> mmachenry: lol sounds smart
19:10:49 <arkeet> it's easier to see the overall structure of a piece of code when it's not cluttered with long variable names.
19:11:05 <lethjakman> I tend to write my code to make it understandable. 
19:11:07 <arkeet> I would just call that the left hand side
19:11:08 <arkeet> of the definition
19:11:18 <lethjakman> doesn't the (x:xs) do something special?
19:11:33 <arkeet> as I said, that matches the second argument with the pattern x:xs
19:11:35 <arkeet> which means
19:11:59 <arkeet> the second argument is a cons (something attached to the front of a list)
19:12:10 <arkeet> and it binds x and xs to the two parts of the list.
19:12:22 <lethjakman> that's thinking of it like a touple right?
19:12:23 <Iceland_jack> lethjakman: First thing to understand, lists only have TWO cases. Empty ([]) or non-empty (x:xs)
19:12:39 <arkeet> matching tuples looks similar, sure.
19:12:58 <arkeet> but it's a bit more specific than that.
19:13:03 <lethjakman> ahhhh
19:13:07 <lethjakman> Iceland_jack: that helps to think of it that way
19:13:09 <arkeet> every list is either the empty list []
19:13:23 <arkeet> or something attached to the front of another list
19:13:53 <arkeet> (which is written in the form x : xs, where x is the thing in front, and xs is the rest of the list)
19:14:09 <arkeet> when you see [1,2,3]
19:14:15 <arkeet> that's really just shorthand for 1 : (2 : (3 : []))
19:14:25 <Iceland_jack> > 1:(2:(3:(4:[])))
19:14:26 <lambdabot>  [1,2,3,4]
19:14:30 <arkeet> so if you match [1,2,3] with x:xs
19:14:32 <Iceland_jack> > 1:2:3:4:[]
19:14:33 <lambdabot>  [1,2,3,4]
19:14:38 <arkeet> that will bind x to 1 and xs to (2:(3:[]))
19:14:44 <arkeet> (i.e. [2,3])
19:15:22 <arkeet> (and : associates to the right so parenthese aren't really necessary there.)
19:15:27 <arkeet> parentheses.
19:15:31 <lethjakman> thank you!
19:15:33 <lethjakman> that helps
19:16:15 <arkeet> so that : sort of has two roles.
19:16:27 <arkeet> in a pattern (on the left side of =) it matches and deconstructs a nonempty list.
19:16:45 <arkeet> in an expression (on teh right side of =) it constructs a nonempty list.
19:17:27 <lethjakman> ahhh
19:17:30 <lethjakman> I think I see what you mean
19:32:49 <dpwright> Hello, I've written a blog post about getting up and running with edwardk's new 'gl' library
19:33:28 <dpwright> it's very basic, supposed to get you from zero to "spinning cube" as quickly as possible so people curious about using OpenGL with haskell can have a shot
19:33:50 <dpwright> but if anyone is interested and want to read the draft before I publish it and post it to reddit, I'd appreciate it
19:34:00 <dpwright> the draft is here: http://dpwright.com/pending-posts/2015/03/25/the-haskell-gl-package/
19:34:48 <EvanR> thats awesome
19:35:23 <randir> that does look really cool
19:35:23 <dpwright> EvanR: You haven't read it yet ;-) It might be rubbish!
19:35:33 <EvanR> the gif is enough
19:35:35 <EvanR> im sold
19:35:37 <randir> ^
19:35:39 <dpwright> :-D
19:35:41 <randir> seconded
19:36:44 * mniip complains about the gif using the same palette for every frame
19:37:21 <dpwright> mniip: Yeah, I did choose possibly the worst thing to use the GIF format for :-P
19:37:30 <dpwright> literally every colour is in that image
19:37:35 <EvanR> dpwright: this is pretty cool because its terribly low level, demonstrating to people who think haskell is all about higher order abstract nonsense , that it can be low and dirty like c++ tutorials ;)
19:38:23 <lethjakman> my cat is obsessed with that image
19:38:54 <dpwright> EvanR: Yeah!  I had to hold myself back quite a lot not to put in too many abstractions to keep the focus on gl, although I did cave when it came to extracting the uniform and attribute locations from the shader program
19:41:34 <randir> You have good text-format for the tutorial
19:41:53 <randir> which I think is key for good tutorials, it makes the information presentation clean
19:42:18 <dpwright> randir: Thank you, do you mean just the font choice and layout and stuff?
19:43:28 <randir> dpwright: Yeah, it's much, much better than just a block of text.
19:43:55 <dpwright> thanks!  :-D
19:44:01 <randir> Did you generate it with Markdown?
19:44:15 <dpwright> there's actually another blog post in my "pending" folder about how I have nicely-laid-out code despite using a proportional font
19:44:36 <dpwright> yeah, the source is markdown converted by pandoc/hakyll
19:45:01 <randir> A markdown LHS post.. nice :D
19:45:27 * hackagebot Titim 0.1.3 - Game for Lounge Marmelade  http://hackage.haskell.org/package/Titim-0.1.3 (Jefffrey)
19:45:27 * hackagebot dns 1.4.5 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.5 (KazuYamamoto)
19:45:45 <randir> oh, yikes, I didn't even notice that the code wasn't monospace
19:45:56 <dpwright> actually... the site itself is a LHS program.  All the code to generate the site is in blog posts, though some of them are in the pending folder.  So when I want to generate the site, I run the site... on itself
19:45:56 <randir> Definitely impressive 
19:46:14 <randir> boostrapped website. I like it. 
19:46:28 <randir> Definitely bookmarked.
19:46:42 <randir> What web framework are you using?
19:47:01 <randir> My personal website runs with Snap, but I havn't really had time to build anything real with it yet.
19:47:12 <dpwright> well, I use hakyll as a static site generator so the HTML is all static
19:47:17 <dpwright> then I just host it on github
19:47:41 <dpwright> so "none", I guess
19:47:42 <randir> ah, yeah, hakyll does look nice from what I've seen of it.
19:48:32 <randir> and a post about Haskell in Japanese. +1
19:48:34 <dpwright> feel free to check out some of my other posts if you want to give it a try!  not until you've given me any criticism you have of the gl post though ;-)
19:50:15 <randir> right now I'm just trying to wrap my head around how you have parentheses lining up without monospace fonts ;) 
19:50:19 <randir> It's dark magic.
19:51:05 <dpwright> ;-)
19:51:37 <randir> I'm trying to work on something else right now so I'll hold off on in-depth critiques. But on first glance, it looks like an excellent post.
19:51:48 <randir> Bookmarked, and def. want to read it later.
19:51:58 <randir> and follow along
19:52:26 <randir> I tried using OpenGL in Haskell awhile ago but it was kinda meh. Ended up using Cairo on top of the GTK bindings
19:53:27 <randir> By the way, here's a library you might find interesting: https://hackage.haskell.org/package/gloss
19:53:42 <dpwright> randir: OK, thanks!  I don't have a comments section on the site, and it's a draft anyway, but if I'm not on IRC when you get around to looking at it you can tweet me your comments or... open up an issue on github I guess? https://github.com/dpwright/dpwright.github.com
19:53:47 <randir> It was my first into to graphical stuff with Haskell, think it works like a charm. 
19:54:08 <jokester> dpwright: your site is cool!
19:54:53 <jokester> dpwright: tried to subcribe it but .. will there be a RSS feed someday?
19:55:01 <fragamus> offtopic: anybody have any experience with concorde TSP
19:55:22 <dpwright> jokester: Thanks!  I haven't publicised it much, because I didn't feel like there was an awful lot on there worth making a fuss about, but this GL post is the first "substantial" thing I've posted there so I thought I'd get a bit of feedback and then post it to reddit, become world famous, etc
19:55:43 <dpwright> there is a feed, but... I foolishly removed the link, thinking it would be picked up automatically by browsers
19:56:04 <randir> dpwright: I can't say I know much about OpenGL so I doubt my comments would help. I'm more interested in learning from it then telling you to write it differently :D but I'll let you know if I see anything.
19:56:29 <dpwright> it is http://dpwright.com/atom.xml.  It's also linked to in the post on how it's generated here: http://dpwright.com/posts/2015/03/18/generating-this-website-part-4-atom-feed/
19:57:11 <spearman> hi all, what does " Could not deduce (t ~ Double)" mean? the tilde?
19:57:17 <dpwright> randir: That's fine!  if it helps you to get started with it, that means I've written a good post; if there are things you struggle to understand, that might mean I need to modify it somewhat, so it would be worth knowing!
19:57:49 <dpwright> (though I didn't go into fundamentals like how matrix multiplication works and stuff because I wanted to focus on "getting something running NOW")
19:57:55 <roboguy_> spearman: that is the type equality operator
19:58:09 <randir> ooh man this makes me want to make something with gl.. but I probably should keep focused on stuff for work and school...
19:58:25 <randir> Haskell is a cruel temptress. 
19:59:07 <randir> dpwright: I think that's good, I tend to prefer minimal examples, they're much easier to build on.
19:59:44 <randir> maybe just noting "this uses matrix multiplication" so people can look it up if they don't know how it works (I don't know if you did that or not)
20:01:41 <dpwright> yeah, I've tried to give hints as to where to look if you don't understand the words I'm using, links to the GL docs, etc.  But I may have missed some, so please do let me know if there are parts you don't understand!
20:01:54 <spearman> roboguy_ : ok thanks. it's not available to use though in statements? typing :i ~ gives me an error
20:03:00 <roboguy_> spearman: it's a type level thing, so you can't use it as an expression. :i works with some type level things, but ~ is a builtin
20:03:12 <spearman> i'm trying to print the output pair of this function but it keeps telling me the type is ambiguous. whenever i try to give (t,t) a type like (Double,Double) i can't seem to get the types to come out right: http://pastebin.com/bVUsqLAJ
20:03:42 <randir> dpwright: I hope the post is successful on reddit! 
20:03:44 <spearman> or "no instance for (Show t0)" rather
20:03:50 <dpwright> randir: Thanks!
20:03:55 <randir> I'm always thankful of tutorials like this, when I'm learning someting new with Haskell
20:04:04 <spearman> "The type variable 't0' is ambiguous"
20:04:06 <randir> or anything, for that matter. Focused tutorials are a great thing.
20:04:14 <dpwright> ok, I've got to go afk for a while but if anyone has any more feedback please tweet me or similar!
20:04:17 <dpwright> @danielpwright
20:04:18 <lambdabot> Unknown command, try @list
20:04:26 <dpwright> thanks lambdabot :-/
20:04:28 <randir> cya!
20:04:47 <benzrf> @botsnack
20:04:47 <lambdabot> :)
20:06:20 <roboguy_> spearman: there is no type that is both Integral and Fractional
20:06:36 <roboguy_> you should pick one of those and convert when you need to
20:07:11 <mniip> I think I just invented a new monad!
20:07:52 <spearman> i started off with Integer -> Integer but i couldn't figure out how to coerce it properly in all the places
20:08:01 <benzrf> haskell doesnt have coercing, spearman
20:08:06 <benzrf> it has converting?
20:08:09 <benzrf> mniip: please, go on
20:08:16 <spearman> to/fromRational?
20:08:22 <benzrf> spearman: that kind of thing yeah
20:08:35 <spearman> :i toRational
20:08:35 * benzrf eagerly awaits the opportunity to reconstruct mniip's monad from Free and polynomial functors
20:08:37 <randir> is there any way to have functions all have access to a read-only structure, without it being passed to them?
20:08:38 <benzrf> mwahaha
20:08:54 <mniip> newtype Nasty a = Nasty a
20:09:00 <randir> but a read-only structure that is generated at run-time
20:09:01 <mniip> wait for it...
20:09:04 <roboguy_> spearman: you probably want fromIntegral
20:09:06 <benzrf> uh oh
20:09:07 <mniip> 	(Nasty x) >>= f = x `seq` f x
20:09:17 <benzrf> i bet that's not a monad
20:09:24 <roboguy_> spearman: In my experience, that's what you want 90% of the time
20:09:36 * benzrf cogitates
20:09:48 <roboguy_> mniip: is that StrictIdentity?
20:09:50 <benzrf> mniip: i assume return is just Nasty?
20:09:53 <mniip> yeah
20:10:02 <benzrf> that's just Nasty, man
20:10:21 <johnw> mniip: https://hackage.haskell.org/package/strict-identity-0.1.0.0/docs/Control-Monad-StrictIdentity.html
20:10:21 <mniip> you can then proceed to plug the GHC.Prim functions into that
20:10:39 <mniip> something like 'peekChar :: Addr# -> Nasty Char'
20:11:04 <mniip> and with a helper function of
20:11:08 <mniip> stateNasty f = case seq# () (f realWorld#) of (# _, x #) -> Nasty x
20:11:14 <mniip> you can write the poking functions
20:12:37 <benzrf> nasty poking
20:12:39 <benzrf> poking nasties
20:13:36 <roboguy_> mniip: so you use unsafePerformIO/unsafeCoerce?
20:14:21 <roboguy_> wow StrictIdentity takes its strictness very seriously
20:15:02 <benzrf> hmmmmmmmmmmm
20:15:06 <benzrf> oh wow
20:15:15 <benzrf> i think Nasty actually might be a monad after all
20:15:19 <benzrf> but only because it's a newtype
20:15:20 <benzrf> o_o
20:15:30 <benzrf> im not sure
20:16:04 <benzrf> Nasty ⊥ is the same as ⊥, right?
20:16:23 <arkeet> (->) e isn't a monad.
20:16:27 <benzrf> fffff
20:16:31 <arkeet> it's not even a functor.
20:17:46 <tnks> arkeet: what am I missing?  looks like Reader to me.
20:18:25 <spearman> back to where I started :\ `Could not deduce (a ~ Rational)` http://pastebin.com/k4eLDmkc
20:18:26 <randir> how much more efficient would IntMap be than Int, for a chess implementation
20:18:35 <randir> than Map*
20:18:42 <solatis> hmm ok, i'm trying to use acid-state, and i notice it uses Control.Monad.Reader (ask) and Control.Monad.State (get), that both seem to do more or less the same
20:18:45 <solatis> what is the difference?
20:18:46 <mniip> rats
20:18:50 <mniip> I can't do 'Nasty Addr#'
20:19:04 <roboguy_> benzrf: I don't think they're quite the same
20:19:08 <randir> It would be nice to map from (Rank,File) -> Piece, but obviously Int-> Piece works as well
20:19:08 <arkeet> tnks: fmap id ⊥ is not ⊥
20:19:23 <randir> the code would be nicer, but probably not worth the performance overhead
20:19:33 <solatis> ask is used in the Query monad, and get is used in the Update monad?
20:19:51 <arkeet> > (undefined :: () -> ()) `seq` ()
20:19:53 <lambdabot>  *Exception: Prelude.undefined
20:19:55 <arkeet> > fmap id (undefined :: () -> ()) `seq` ()
20:19:56 <solatis> since Query is an instance of MonadReader, and Update is an instance of MonadState ?
20:19:56 <lambdabot>  ()
20:20:25 <jle`> @google fast and loose reasoning is morally correct
20:20:26 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
20:20:26 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
20:20:26 <tnks> arkeet: does the implementation of Reader in mtl/transformers address this?
20:20:31 <arkeet> no.
20:20:49 <tnks> and does fast and loose reasoning save us from disaster?
20:20:50 <benzrf> arkeet: shit
20:20:57 <benzrf> arkeet: wait, whaaaat?
20:21:13 <benzrf> the fuck?
20:21:16 <arkeet> \_ -> ⊥ is different from ⊥
20:21:19 <jle`> no but it lets us reason with things
20:21:25 <jle`> in useful ways
20:21:33 <benzrf> > (id . undefined) ()
20:21:34 <lambdabot>  *Exception: Prelude.undefined
20:21:41 <benzrf> > (fmap id undefined) ()
20:21:42 <lambdabot>  *Exception: Prelude.undefined
20:21:45 <arkeet> > (id . undefined) `seq` ()
20:21:46 <lambdabot>  ()
20:21:57 <arkeet> Hask isn't a category.
20:21:59 <benzrf> ohhhh. i see
20:22:13 <arkeet> (at least, not with id and (.))
20:22:17 <benzrf> rip
20:22:29 <johnw> arkeet: it's not CPPO⊥?
20:22:43 <arkeet> what's that?
20:22:48 <johnw> a kind of category
20:22:54 <arkeet> it's not a category.
20:23:00 <roboguy_> arkeet: you could fix that with a seq
20:23:01 <arkeet> for id is not an identity for (.)
20:23:03 <johnw> discussed in http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
20:23:08 <arkeet> roboguy_: yes, hence the parenthetical statement
20:23:31 <roboguy_> arkeet: what does that have to do with id and (.) though? You could change fmap
20:23:36 <arkeet> yes.
20:23:50 <arkeet> johnw: I want to rather suggest that Hask is a 2-category.
20:24:02 <arkeet> where f <= id . f
20:24:19 <arkeet> (where x <= y means y is more defined than x.)
20:24:25 <lpaste> mniip pasted “eww, Nasty” at http://lpaste.net/129146
20:24:33 <arkeet> I haven't worked it out at all though.
20:25:19 <roboguy_> mniip: I feel like the nastiness is coming more from unsafePerformIO than seq
20:25:39 <mniip> I could make it even more nasty, roboguy_
20:25:51 <mniip> I have the technology
20:26:32 <mniip> ioNasty (IO m) = case m realWorld# of (# _, r #) -> Nasty r
20:27:07 <arkeet> oh, I mean lax 2-category.
20:29:01 <mniip> another nasty thing about this is
20:29:13 <mniip> eww $ peek nullAddr
20:29:52 <mniip> this was inspired by EvanR's "can be low and dirty like c++ tutorials"
20:30:07 <roboguy_> arkeet: is that like a weak 2-category?
20:30:33 <arkeet> roboguy_: no.
20:31:03 <arkeet> wait.
20:31:15 <arkeet> I'm forgetting my definitions.
20:33:20 <arkeet> yeah, it's different.
20:33:26 <mniip> hmm
20:33:41 <mniip> should totally make a Prelude.Cpp and get that on hackage
20:33:42 <arkeet> in a weak 2-category, you still need composition with identity 1-morphisms to be an isomorphism.
20:33:53 <roboguy_> ah
20:35:56 <arkeet> I am just asking for 2-morphisms f => id . f and f => f . id
20:36:13 <arkeet> that need not be isomorphisms.
20:37:37 <arkeet> they better be coherent still, but if the hom-categories are partial orders I think that's trivial.
20:38:11 <jmcarthur> does anybody know of anything documenting ghc's naming scheme for variables it creates internally? in particular, i'm hoping it will give me some more insight when reading core
20:39:30 <arkeet> http://arxiv.org/pdf/math/0305049v1.pdf section 3.4
20:39:32 <arkeet> defines a lax bicategory.
20:39:35 <arkeet> I think that's what I want.
20:42:24 <arkeet> ah, then perhaps 1-fold composition can just be eta expansion.
20:57:52 <lifter> boom
20:59:51 <gooshgooshurtoos> 1466 people online and no one is saying a word
21:00:53 <lifter> they are all haskelling hard
21:01:37 <mniip> a word
21:02:17 <lifter> I'm haskelling so hard over here that my CPU fan is spinning
21:02:31 <rootnode> "Everyday I'm haskelling..."
21:02:36 <rootnode> Sorry, couldn't resist
21:02:47 <lifter> #haskelling
21:02:48 <mniip> I'm haskelling so hard my # key broke
21:03:18 <bananagram> but you almost never use # in haskell
21:03:20 <lifter> (#) ?
21:03:33 <lifter> that's a lens operator
21:03:35 <mniip> bananagram hasn't been haskelling hard yet
21:03:37 <lifter> hard core
21:03:47 <bananagram> oh, okay
21:03:47 <mniip> lifter, no
21:03:52 <mniip> unboxed and prim stuff
21:04:03 <lifter> oh ah still hard core
21:04:05 <bananagram> yeah
21:04:14 <lifter> in fact even harder
21:04:21 <lifter> rock on
21:04:22 <mniip> http://lpaste.net/129146#line47
21:04:23 <bananagram> too hard for me
21:04:59 <lifter> "unsafeFreezeByteArray" ?  That's coooold
21:05:40 <lifter> love the nested case statements on the same line
21:05:50 <lifter> and the "Nasty" type
21:06:01 <rootnode> I love the functor instance
21:06:05 <rootnode> eww
21:06:15 <lifter> lol
21:06:29 <lifter> mniip: did u write this
21:07:20 <lifter> this is good stuff
21:07:53 <mniip> I know right
21:07:55 <rootnode> this needs to be in haskell weekly
21:08:22 <mniip> hmm
21:08:27 <mniip> this needs some typemagic
21:08:36 <bananagram> oh god
21:08:56 <bananagram> this is a bit freaky to me
21:09:07 <mniip> what if we rebind (RebindableSyntax) >>= to something that does >>= if Monad, and $! otherwise
21:09:35 <rootnode> I love it :D Made my lunchbreak :D
21:09:54 <lifter> mniip: I've done some wacky stuff with RedbinableSyntax, I will admit
21:10:23 <mniip> nah, I'll stick with Nasty
21:11:50 <mniip> but first
21:11:56 <mniip> I need to get rid of those cases
21:16:34 <mniip> (>>=#) :: (State# a -> (# State# a, b #)) -> (b -> State# a -> (# State# a, c #)) -> (State# a -> (# State# a, c #))
21:22:52 <mniip> rats
21:22:53 <mniip> can't do that
21:24:45 <rootnode> you could hide it in a type
21:25:28 * hackagebot Titim 0.2.1 - Game for Lounge Marmelade  http://hackage.haskell.org/package/Titim-0.2.1 (Jefffrey)
21:25:39 <mniip> rootnode, # doesn't match with 'a'
21:26:27 <rootnode> I meant for readability. type Foo a b = State# a -> (# State# a, c #)
21:26:53 <rootnode> as for getting rid of the cases...no idea whatsoever
21:40:29 * hackagebot Titim 0.2.3 - Game for Lounge Marmelade  http://hackage.haskell.org/package/Titim-0.2.3 (Jefffrey)
22:02:36 <mniip> guys
22:02:38 <mniip> I broke it
22:02:57 <mniip> > catch (Nasty undefined) Nasty
22:02:57 <mniip> ByteCodeLink.lookupCE(primop) During interactive linking, GHCi couldn't find the following symbol: ghczmprim_GHCziPrimopWrappers_seqzh_closure
22:02:58 <lambdabot>  Not in scope: data constructor ‘Nasty’Not in scope: data constructor ‘Nasty’
22:04:05 <mniip> interesting
22:04:12 <mniip> any use of the catch# primop gives this
22:04:24 <mniip> the most basic one being
22:04:27 <mniip> IO (catch# (seq# ()) (\_ -> seq# ()))
22:06:22 <EvanR> dont try that at home
22:14:33 <fizbin> Is there somewhere a list of infix operators in the base libraries and their precedences? I'm trying to decide what precedence to set something at.
22:15:19 <arkeet> fizbin: see the index for base
22:15:20 <arkeet> http://hackage.haskell.org/package/base-4.7.0.2/docs/doc-index.html
22:15:31 <arkeet> click to see precedence
22:15:54 <arkeet> (on the All page, they're all at the top or bottom)
22:16:03 <fizbin> Ugh. Was hoping to see them all together.
22:16:04 <kadoban> How do I avoid duplicating everything in my build-depends in .cabal for a project, between the library and the executable? I have https://gist.github.com/kadoban/969f76c00c11d519cba0 in my cabal file, but it still won't build. It complains when building AI.Vision.Canny that it can't find hidden vector and the rest. The error is fixed if I copy all of those to the executable, but…bleh that's annoying, is there really no other way?
22:16:09 <arkeet> sorry.
22:16:52 <arkeet> kadoban: you can have your executable depend on your library.
22:17:00 <arkeet> iirc they'd need to have separate source dirs.
22:17:05 <kadoban> arkeet: Isn't that what I already have though?
22:17:09 <kadoban> Oh…really?
22:17:22 <kadoban> Hmm, I'll try that
22:20:42 <arkeet> fizbin: at least you see them in the haddocks now, it wasn't until recently that it did that.
22:21:42 <arkeet> fizbin: the Report specifies the precedence for the Prelude operators in one place: https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009
22:22:21 <kadoban> arkeet: Huh, that indeed helped, thanks. Never knew the source-dirs were supposed to be separate.
22:22:28 <fizbin> arkeet: Ooh, thanks. That'll help.
22:22:32 <arkeet> kadoban: I seem to remember being bitten by that once.
22:51:27 <randir> what's a good way to do take-while that also takes the first one that fails the predicate?
22:51:48 <randir> takeWhile*
22:51:49 <EvanR> compose it with drop 1
22:52:12 <EvanR> drop 1 . takeWhile p
22:52:22 <randir> >drop 1 [1..4]
22:52:27 <randir> > drop 1 [1..4]
22:52:28 <EvanR> oops misread
22:52:28 <lambdabot>  [2,3,4]
22:52:35 <randir> np
22:52:40 <dmj`> :t takeWhile1
22:52:41 <lambdabot>     Not in scope: ‘takeWhile1’
22:52:41 <lambdabot>     Perhaps you meant one of these:
22:52:41 <lambdabot>       ‘takeWhile’ (imported from Data.List),
22:53:14 <mniip> the most elegant way would be to implement one just like takeWhile
22:53:17 <mniip> @src takeWhile
22:53:17 <lambdabot> takeWhile _ []                 = []
22:53:17 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
22:53:18 <lambdabot>                    | otherwise = []
22:53:30 <mniip> but of course one can come up with some point-free monstrosity
22:54:12 <randir> so just change otherwise = [] to otherwise = [x] should work
22:54:18 <mniip> yes
22:55:23 <dmj`> > partition (>5) [1..10] 
22:55:24 <lambdabot>  ([6,7,8,9,10],[1,2,3,4,5])
22:58:26 <randir> is there a way I can pattern match (a?!b) = [1..10] so that b is bound to 10
22:58:32 <randir> so I can access "last" without the overhead?
22:59:17 <randir> ?! here is just a hypothetical operator that I'm looking for
22:59:17 <lambdabot> Maybe you meant: v @ ? .
22:59:21 <kadoban> randir: Nope. If you need to do that often, list is probably not the correct data structure.
22:59:24 <EvanR> 1:2:3:4:5:6:7:8:9:b:[]
22:59:45 <randir> k
23:01:31 <EvanR> Data.Sequence lets you inspect the beginning and the end efficiently
23:01:40 <mniip> EvanR, _ = let b = 10 in
23:01:50 <EvanR> if you only need one end though, maybe your list is backwards
23:02:01 <randir> yeah
23:02:12 <randir> I'm writing a function to do what I needed, I was kind of just curious
23:02:22 <randir> currently trying to write out a move-tracing chess function
23:02:36 <randir> that checks for legality and provides a list of legal moves for a given piece
23:07:13 <randir> case (f x) of ..
23:07:22 <randir> will evaluate f x, and use te result for the match, right?
23:07:27 <dfeuer> case case of case -> case
23:07:49 <EvanR> randir: yes, if the case itself is evaluated
23:08:03 <EvanR> and then, only enough to do the match
23:08:44 <randir> pshaw, that's lazy of it. ;-)
23:08:45 <randir> thanks
23:12:10 <randir> this is gonna be kind of a weirdly phrased question, but:
23:13:09 <mniip> yeah, an emptiness is a weird phrasing
23:13:17 <randir> It was in whitespace.
23:13:46 <randir> I'm doing a recursive function, and I want one branch of the function (foo) to return (x:fst foo, snd foo) were the first part will be building up over time, and the second part will only be filled in the edge condition
23:13:54 <randir> what's the cleanest way to do this?
23:14:07 <mniip> @src break
23:14:07 <lambdabot> break p = span (not . p)
23:14:11 <mniip> @src span
23:14:11 <lambdabot> span _ xs@[]                  = (xs, xs)
23:14:11 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
23:14:11 <lambdabot>                   | otherwise = ([],xs)
23:14:13 <mniip> like this?
23:15:09 <randir> yep, pretty much
23:15:21 <randir> that's what I was thinking, just wanted to see if I was missing an obvious way to do it
23:15:22 <randir> thanks
23:15:37 <randir> And I'm starting to really like lambdabot. Who wrote it?
23:15:54 <mniip> you can find this stuff on hoogle too
23:20:35 * hackagebot ascii-progress 0.2.1.2 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.2.1.2 (yamadapc)
23:25:35 <romero_> What is the term for a function that takes input type A and returns it converted to type B. Not just any  A -> B function but with those semantics (converting)
23:26:23 <kadoban> romero_: Is there really a difference between that and :: A -> B ?
23:26:26 <mniip> romero_, you didn't specify the semantics
23:26:41 <EvanR> perhaps: a conversion ;)
23:27:01 <romero_> kadoban: I have another function where I can pass this B output and get back A
23:27:02 <mniip> I suspect they mean an isomorphism?
23:27:15 <mniip> yeah that's an isomorphism
23:27:30 <romero_> hmmm I will check it out thanks :D
23:27:44 <shachaf> "isomorphism" doesn't mean "converting"
23:28:00 <shachaf> Well, I don't know what "converting" means. Maybe it means "isomorphism".
23:28:12 <mniip> well in haskell an isomorphism means 2 functions f and g such that f.g=id and g.f=id
23:28:24 <mniip> which is roughly what they described
23:29:38 <mniip> so uh, something is wrong with the email in GHC's trac :|
23:29:40 <shachaf> So, for instance, (*2) is a function that converts an Integer to an Integer.
23:29:48 <echo-area> mniip: This reminds me about newtypes with one field
23:30:35 * hackagebot hoauth2 0.4.6 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.6 (HaishengWu)
23:30:50 <KaneTW> it's some sort of morphism
23:31:01 <mniip> echo-area, are there other sorts of newtypes?
23:31:22 <echo-area> mniip: No, except those with no fields
23:31:53 <mniip> um you can't have a newtype with no fields
23:32:20 <echo-area> Hmm, what I mean is not in field format
23:33:10 <echo-area> Ah, that too is exactly one field
23:33:29 <echo-area> mniip: Thanks, noted
23:52:13 <randir> can I make a show instance for a type?
23:52:19 <mauke> sure
23:52:31 <randir> type Piece = (Color, Shape)
23:52:39 <randir> instance Show Piece where
23:52:41 <mauke> no
23:52:43 <randir> k
23:52:46 <randir> only for data?
23:52:51 <mauke> that's not a type, that's just another name for (Color, Shape)
23:52:57 <pacak> randir: But your type is (Color, Shape)
23:53:10 <pacak> If you want to use tuples - add newtype around that.
23:53:37 <randir> how do I do that, pacak?
23:53:42 <EvanR> randir: to follow up with the product type suggestion you would do data Piece = Piece Color Shape
23:54:03 <EvanR> then you can do deriving Show
23:54:03 <mauke> newtype Piece = Piece (Color, Shape) -- but that's pretty pointless
23:54:05 <pacak> randir: newtype Piece = Piece (Color, Shape)
23:54:32 <randir> EvanR: That's what I had initially, but it wasn't working too well with pattern matching for some stuff
23:54:45 <randir> if I have data Piece = Piece Color Shape
23:54:53 <mauke> "wasn't working too well" is not a problem description
23:54:55 <randir> how do I write a "isWhite" function
23:55:03 <randir> from :: Piece -> Bool
23:55:05 <EvanR> randir: the same way you would if it was (,)
23:55:13 <mauke> randir: depends on what Color is
23:55:14 <randir> k
23:55:49 <EvanR> before you had issues with data Piece = White Shape | Black Shape
23:56:05 <EvanR> even though i dont think there was a real problem in that case either
23:56:33 <randir> Color is data Color = White | Black
23:56:52 <mauke> isWhite (Piece White _) = True; isWhite _ = False
23:56:52 <randir> and shape is the same thing, but with more | for different shapes
23:56:53 <kadoban> randir: isWhite (Piece White _) = True   is the first half
23:57:00 <randir> okay
23:57:05 <kadoban> Damn, too slow and not even as good, haha.
23:59:47 <pacak> randir: isWhite f = null [() | Piece Black <- [f]]
