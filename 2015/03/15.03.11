00:01:00 <dmj`> sgronblo: try disabling the monomorphism restriction
00:01:10 <dmj`> sgronblo: {-# LANGUAGE NoMonomorphismRestriction #-}
00:03:49 <nocturne777> shachaf: like I surmised, something makes "f" in that definition of foldMap monodic. in this case it's type holder Endo :)
00:04:22 <shachaf> Well, f is a function whose return type is a Monoid. You can pick any instance you like.
00:04:30 <shachaf> Another instance that would work is [a]
00:09:56 * hackagebot record 0.2.2 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.2.2 (NikitaVolkov)
00:09:56 * hackagebot record 0.3.0 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.3.0 (NikitaVolkov)
00:34:51 * hackagebot semver 0.3.2 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.2 (BrendanHay)
00:41:31 <mrkkrp> Hello, how to make `cabal build' use some options, like `-O2'?
00:42:10 <dmj`> mrkkrp: in your cabal file you can specify a 'ghc-options' line, there you can put -O2
00:42:28 <mrkkrp> dmj`: thank you
00:42:34 <dmj`>  ghc-options:         -Wall -threaded -rtsopts -O2
00:42:46 <dmj`> I have a question too
00:42:59 <dmj`> how do I use existential quantification with sum types?
00:43:24 <dmj`> data A = forall a . Show a => A a, makes sense
00:44:54 <supki> @let data A = forall a. Show a => A a | B
00:44:55 <lambdabot>  Defined.
00:46:12 <aawe> > let f (A x) = show x in f (A 2)
00:46:13 <lambdabot>  "2"
00:46:51 <aawe> @let f (A x) = show x
00:46:52 <lambdabot>  Defined.
00:46:53 <aawe> :t f
00:46:54 <lambdabot>     Ambiguous occurrence ‘f’
00:46:54 <lambdabot>     It could refer to either ‘L.f’,
00:46:54 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:156:1
00:47:10 <Trollinator> @let f = show
00:47:11 <lambdabot>  .L.hs:157:1:
00:47:11 <lambdabot>      Multiple declarations of ‘f’
00:47:11 <lambdabot>      Declared at: .L.hs:153:1
00:47:15 <Trollinator> @let g = show
00:47:16 <lambdabot>  Defined.
00:47:20 <shachaf> Please test lambdabot in /msg.
00:47:27 <Trollinator> oh, I'm surprised. 
00:47:40 <Trollinator> that used to not work. 
00:47:55 <sgronblo> dmj`: Already tried the no monomorphism i think
00:49:15 <dmj`> @let data J = forall j. Show j => K | J j
00:49:16 <lambdabot>  .L.hs:159:12: Not in scope: type variable ‘j’
00:49:52 * hackagebot http-client 0.4.8.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.8.1 (MichaelSnoyman)
00:50:03 <dmj`> supki: can it only be applied to the the first data constructor?
00:50:14 <dmj`> @let data J = forall j. Show j => J j | k
00:50:14 <lambdabot>  Parse failed: Illegal data/newtype declaration
00:50:30 <aawe> small case k
00:50:38 <dmj`> @let data J = forall j. Show j => J j | K
00:50:39 <lambdabot>  Defined.
00:52:21 <supki> dmj`: no, but you need to move the constraint too
00:53:01 <supki> @let data S where T :: S; V :: Show a => a -> S
00:53:02 <lambdabot>  Defined.
00:53:09 <supki> another way to write this
00:53:14 <aawe> @let data Zup = Zup | forall y. Show y => Yo y
00:53:15 <lambdabot>  Defined.
00:53:16 <supki> may be clearer
00:55:09 <aawe> @let data Anything = forall a. Read a => R a | forall a. Show a => S a
00:55:11 <lambdabot>  Defined.
00:56:56 <shachaf> Existential Read doesn't make sense. It would be universal.
00:57:08 <shachaf> (exists a. Show a *> a) and (forall a. Read a => a)
00:57:36 <shachaf> (Are the types of the argument of show and the result of read respectively.)
00:58:17 <aawe> shachaf: hm? is everything instance of Read automatically?
00:58:30 <shachaf> No.
00:59:52 * hackagebot network-conduit-tls 1.1.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.1 (MichaelSnoyman)
01:05:13 <jle`> dmj`: sup?
01:07:57 <dmj`> supki: for some reason that breaks my types ability to derive Eq/Show, ghc is telling to try standalone deriving, but the derived Eq instances don't type check either
01:08:04 <dmj`> telling me to*
01:08:13 <dmj`> supki: http://lpaste.net/94290612504756224
01:09:49 <dmj`> supki: any ideas?
01:14:31 <mrkkrp> Stupid question here: should I add type signatures for obvious things, like strings. I read somewhere that it's good style. When I omit signatures GHC gives me warnings...
01:14:52 * hackagebot comonad 4.2.4 - Comonads  http://hackage.haskell.org/package/comonad-4.2.4 (EdwardKmett)
01:15:01 <shachaf> Sounds like yes, you should have type signatures for top-level things including strings.
01:15:28 <shachaf> But you're not doing yourself or anyone else any favors by calling your question stupid. :-)
01:15:44 <dmj`> mrkkrp: you probably shouldn't be using String though
01:15:50 <mrkkrp> shachaf: thanks!
01:16:09 <mrkkrp> dmj`: my work with Strings not really intensive
01:16:45 <mrkkrp> and I'm not advanced enough to make Parsec work with something more efficient
01:17:57 <mrkkrp> although actually now I could try...
01:18:38 <mrkkrp> So, it is recommended never use String?
01:18:46 <shachaf> No.
01:19:53 * hackagebot hyphenation 0.4.2.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.4.2.1 (EdwardKmett)
01:20:45 <dmj`> mrkkrp: if you want performant parsing I'd try attoparsec
01:21:11 <mrkkrp> dmj`: I use Parsec because I need verbose error messages
01:25:47 <dmj`> mrkkrp: are you making a compiler
01:26:58 <mrkkrp> dmj`: well :) this is my modest project: https://github.com/mrkkrp/mida
01:27:19 <solatis> hmm lines of code in my code blocks in my haddock mark up seem to be separated by an extra newline
01:27:24 <solatis> is anyone familiar with that issue?
01:27:59 <solatis> https://www.dropbox.com/s/4u6lqhuqzm2u7vb/Screenshot%202015-03-11%2015.25.03.png?dl=0
01:28:31 <lpaste> solatis pasted “haddock markup” at http://lpaste.net/124473
01:28:42 <solatis> that is a screenshot and the haddock markup i use
01:28:54 <solatis> is there a haddock flag that controls it?
01:29:53 * hackagebot search 0.1.0.1 - Infinite search in finite time with Hilbert's epsilon  http://hackage.haskell.org/package/search-0.1.0.1 (EdwardKmett)
01:31:37 <dmj`> solatis: that's weird, my docs have the same markup, but no extra newlines
01:31:48 <solatis> might it be the way that cabal invokes haddock?
01:32:19 <solatis> should I just submit it to hackage and see what happens there?
01:32:45 <solatis> (i hate the 'trial and error' approach to this, and would create a lot of hackage noise)
01:34:49 <dmj`> solatis: I had a different formatting issue once, pushing it to hackage healed it. I'm not sure what hackage invokes to build the docs, Fuuzetsu told me it's a little different though
01:34:53 * hackagebot gl 0.7.2.4 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2.4 (EdwardKmett)
01:35:07 <dmj`> fuuzetsu: ping
01:35:11 <solatis> yeah they look very different from cabal haddock
01:35:13 <supki> dmj`: well, the problem there is that if you have  data T = forall a. Eq a => C a  and two values of type T you can't meaningfully compare them
01:35:38 <dmj`> supki: Ohhh that makes sense, duh
01:36:00 <dmj`> supki: I should probably drop the Eq altogether then
01:36:12 <supki> yeah, it's useless
01:37:03 <dmj`> supki: thanks a ton !
01:37:37 <dmj`> solatis: how long has this been an issue? Have others project done this too?
01:37:53 <solatis> dmj`, that's a great idea
01:38:07 <solatis> check out another project and see what my 'cabal haddock' does with that project
01:39:29 <solatis> dmj`, looks like my local install is doing the same thing for other projects
01:39:54 <solatis> well then it looks like a safe bet to just submit it to hackage
01:42:39 <dmj`> solatis: sounds good to me
01:51:13 <rickvonh> How do I get this to work? http://lpaste.net/124474
01:54:56 <dmj`> rickvonh: add this: "meaningless." :: String"
01:55:19 <rickvonh> dmj`: what would that do?
01:55:20 <dmj`> rickvonh: potential is utterly meaningless." :: String, 'a', 'b', 'c', 'd')] 
01:55:27 <dmj`> infer the type as a string
01:55:42 <dmj`> rickvonh: is this a type error or logic error  
01:56:09 <dmj`> rickvonh: does the program compile for you
01:56:35 <rickvonh> yes it compiles
01:56:38 <rickvonh> no way to run it tho
01:56:39 <dmj`> rickvonh: it only did for me when I inferred the type as String, but that me be due to my OverloadedStrings usage
01:56:53 <dmj`> rickvonh: you have to define a main method
01:57:03 <rickvonh> a main= do  at the top?
01:57:39 <dmj`> main :: IO ()                                                                                                        |d) Without training, potential is utterly meaningless.      
01:57:41 <dmj`> main = print =<< ask database [1..10]
01:58:01 <dmj`> rickvonh: ^
01:58:31 <rickvonh> so I should write that and the indent everything under it?
01:59:25 <dmj`> rickvonh: that indent was a typo
01:59:34 <dmj`> main :: IO ()                                                                                                                                                                     
01:59:35 <dmj`> main = print =<< ask database [1..10]  
01:59:37 <simg> Hi, would anyone be willing to look at my stack overflow question about multiple file uploads using digestive-functors? http://stackoverflow.com/questions/28973312/digestive-functors-multiple-file-upload-field
01:59:41 <dmj`> rickvonh: write that ^
02:00:08 <rickvonh> dmj`: ok it compiles, but how do I run the program?
02:00:13 <dpwright> I installed ghc a while back, using the binary package from the ghc website
02:00:24 <dpwright> I want to remove that and install it using homebrew instead
02:00:34 <dpwright> is there an easy uninstall procedure for the ghc binary package?
02:01:44 <dmj`> rickvonh: you can compile it with ghc Main.hs -o main, and then run it ./main, or do 'runhaskell Main.hs' or 'runghc Main.hs' or open it up in ghci (ghci Main.hs) and then call 'main'
02:02:51 <dmj`> dpwright: why do you want to use homebrew?
02:03:06 <dmj`> simg: what do you plan on using for persistence? 
02:03:20 <dmj`> simg: also what web server / framework are you using
02:03:39 <dmj`> dpwright: are you on osx?
02:03:44 <simg> dmg: snap framework. using postgres-simple for persistence
02:03:46 <dmj`> obviously :) doh
02:04:23 <dmj`> simg: where do you plan on storing the files, in postgres?
02:05:45 <dpwright> dmj`: Yes, osx
02:06:07 <dpwright> and, mainly because I manage a lot of other things with homebrew, so it's convenient if I can manage all my installations/upgrades the same way
02:06:44 <dpwright> more specifically: I want to upgrade my copy of ghc, and I went to type `brew upgrade ghc` without thinking, and then realised it wasn't managed using homebrew
02:06:54 <simg> currently on the filesystem. I have that part of the problem "solved". the challenge is in turning my naive file upload button into a multivalued field
02:06:56 <rickvonh> dmj`: ok the program works now, but it prints a pretty weird list.. it is supposed to only increase the first element by 1 when writing the input "a", and increase the second element by 1 when writing the input "b" etc.
02:06:58 <dmj`> dpwright: 3 things to get rid of then, ~/.cabal, ~/.ghc, and /usr/local/bin/ghc*
02:07:08 <dmj`> and you should be clean after that
02:07:15 <dpwright> dmj`: Excellent, thanks!
02:07:17 <dmj`> if you installed both cabal and ghc from their sites
02:07:28 <dmj`> dpwright: np
02:08:11 <dmj`> simg: are you using the 'multiple' attribute on your html input field?
02:08:29 <dmj`> rickvonh: be honest with me, is this homework?
02:08:43 <rickvonh> dmj`: yes of course hahah :D
02:09:38 <simg> dmg`: no, but what i'm actually trying to build is the more general case of handling multivalued fields. images is just the first one I'm tackling.
02:09:55 <dmj`> rickvonh: dude I will not do your homework for you
02:10:18 <dmj`> rickvonh: If you ask questions I can help, but I can't do the whole thing
02:11:00 <rickvonh> dmj`: im not asking you to do the whole thing, just wondering why it prints so random lists e.g. when i answer D on all questions it produces the list [1,2,3,14] (I have 10 questions all together)
02:11:19 <rickvonh> it should produce the list [0,0,0,10]
02:12:11 <dmj`> rickvonh: it prints random lists because its programmed to print random lists, why do you think it produces [0,0,0,10]
02:13:03 <dpwright> an interesting difference between those values is that [1, 2, 3, 14] is what you get by adding together each value in [0, 0, 0, 10] and [1, 2, 3, 4]
02:13:08 <dpwright> is that coincidence?
02:13:15 <rickvonh> dmj`: I don't really understand what you mean... Our goal is for it to produce [0,0,0,10] it hasn't produced it yet
02:13:35 <dmj`> rickvonh: our goal? I'm not the one who is getting graded on this
02:13:48 <rickvonh> dpwright: yeah I noticed.. will have to look into it further or something
02:14:00 <dmj`> rickvonh: trace the path of execution in your mind, or add print statements on each iteration, you're in I/O
02:14:00 <dpwright> (rickvonh: Looking for patterns like the one I just mentioned is a good way to get to the bottom of potential bugs in your code)
02:14:08 <rickvonh> dmj`: okay thx for the help but if you are gonna be that way I dont need your help :)
02:14:17 <mrkkrp> rickvonh: try to analyze your code that understand what's going on. Ability to do so is quite valuable, you know. Otherwise your education is just waste of time. I would do the whole exercise myself on principle.
02:15:20 <dmj`> simg: Are you trying to build a file upload snaplet?
02:15:23 <rickvonh> ah.. the program thinks the original list is [1,2,3,4] 
02:17:18 <rickvonh> so what I need to do is define the start value if the list as [0,0,0,0]
02:17:32 <dpwright> give it a shot! :-D
02:17:36 <rickvonh> of the list*
02:17:45 <rickvonh> dpwright: ya! ty for help :D
02:18:02 <dpwright> np.  I'm off, anyway -- good luck!
02:19:19 <simg> dmj': yes  
02:21:23 <dmj`> simg: someone did that, it never made it to hackage though
02:21:39 <dmj`> simg: https://groups.google.com/forum/#!msg/snap_framework/2IPpWcjPAbE/4yiM_ttG00MJ
02:29:40 <simg> dmj': that's very helpful, thanks :) !
02:51:13 <mrkkrp> Is there some way to disable `Orphan instance' warning?
02:51:27 <jle`> yes
02:51:42 <mrkkrp> How?
02:52:08 <jle`> sorry, trying to remember
02:52:24 <jle`> {-# OPTIONS -fno-warn-orphans #-}
02:52:45 <mrkkrp> jle`: cool, thank you
02:53:17 <mrkkrp> jle`, so, I can put any compiler option into source this way?
02:53:34 <jle`> hm. i would guess so, actually
02:53:41 <jle`> i haven't really used it with anything other than -fno-warn
02:53:54 <jle`> not sure if doing anything other than disabling warnings is a good idea though
02:54:05 <mrkkrp> jle`: I agree.
02:54:50 <merijn> You can't put all compiler options in this way, only dynamic options
02:54:57 <merijn> Consult the GHC flag reference
02:56:20 <phaazon> hm
02:56:34 <phaazon> is there a way to define specific default implementation of typeclass methods?
02:56:41 <phaazon> like imagine Semigroup and Monoid
02:56:59 <phaazon> how could we auto implement mappend = (<>) for (Semigroup a) => a?
02:57:12 <merijn> phaazon: Not really
02:57:21 <opqdonut> phaazon: you can do stuff like that with OverlappingInstances
02:57:33 <phaazon> hm
02:57:35 <opqdonut> phaazon: but it might not be a good idea in general
02:57:41 <phaazon> I don't want that
02:57:43 <phaazon> yeah
02:57:46 <phaazon> I don't use that extension
02:57:57 <merijn> s/it might not be/definitely is not/
02:58:02 <phaazon> what I'd love would be a way to define defaults
02:58:03 <phaazon> like
02:58:06 <phaazon> it's there by default
02:58:09 <phaazon> but you can override it
02:58:12 <merijn> phaazon: There's several proposals for this on the wiki
02:58:20 <merijn> Try campaigning/reraising one of them
02:58:25 <phaazon> exactly the same way we have regular defaults, actually
02:59:29 <yoshuawuyts> good morning!
02:59:43 <phaazon> class Monoid w where { mempty :: w; mappend :: w -> w -> w; default { mappend :: (Semigroup w) => w -> w -> w; mappend = (<>) } }
02:59:44 <yoshuawuyts> merijn: those videos from dr.Boolean you sent me yesterday were really nice, thanks for that
02:59:48 <phaazon> something like that would be neat
02:59:51 <phaazon> merijn: thanks
02:59:57 <phaazon> I'm gonna have look at that then
02:59:58 <yoshuawuyts> merijn: at least, I think it was you ^^
03:00:14 <phaazon> the actual good thing would be to remove mappend
03:00:29 <phaazon> and change Monoid to class (Semigroup w) => Monoid w where...
03:00:29 <alpounet> phaazon: that's actually possible
03:00:35 <phaazon> alpounet: ah?
03:01:09 <phaazon> with rewrite rules? :)
03:01:15 <phaazon> nah, sounds silly
03:01:17 <nsh> what would "comonadic CA" mean
03:01:18 <alpounet> phaazon: nope, just an extension: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#class-default-signatures
03:01:22 <nsh> specifically, the 'CA' bit
03:01:41 <nsh> context: 'I enjoyed this talk on comonads and fixed points: https://www.youtube.com/watch?v=F7F-BzOB670 (Of course I'm a bit biased as discusses comonadic CAs and loeb.)' (@sigfpe)
03:01:43 <phaazon> alpounet: hm yes, I remember something like that
03:01:45 <phaazon> thanks a lot
03:01:49 <phaazon> I'll read that ten! :)
03:02:01 <merijn> yoshuawuyts: I don't know who dr. Boolean is, so probably not :p
03:03:26 <yoshuawuyts> merijn: oh, haha. Ah well, my gratitude to errbody in the channel then ^_^
03:03:28 <phaazon> alpounet: that's exactly what I need!
03:03:29 <phaazon> thank you!
03:03:41 <alpounet> phaazon: cheers :)
03:03:43 <phaazon> I guess I can use that to resolve a _lot_ of boilerplate
03:03:50 <phaazon> like declaring instances for typeclasses of mine
03:03:54 <phaazon> where instances are bully
03:03:59 <phaazon> like foo = lift . foo
03:04:24 <merijn> phaazon: You still need to declare instances using default signatures
03:04:49 <phaazon> yeah but what I mean is
03:04:56 <phaazon> instance MyClass Stuff
03:05:02 <phaazon> is sufficient with default implementations
03:05:09 <phaazon> I have a lot of code like
03:05:18 <phaazon> instance MyClass Stuff { foo = lift . foo }
03:05:23 <phaazon> for several Stuffs
03:05:25 <phaazon> that's boring
03:05:35 <phaazon> there's an example of that in my monad-journal library
03:05:54 <nsh> (it's cellular automata, you unhelpful shits)
03:06:23 <jle`> :(
03:06:28 <phaazon> :(
03:07:07 <alpounet> phaazon: yeah that's exactly what this extension is there for
03:08:02 <phaazon> :)
03:08:04 <phaazon> pretty neat
03:11:24 <phaazon> ohoh
03:11:28 <phaazon> -XViewPatterns
03:11:31 <phaazon> what a weird extension :D
03:13:21 <nkar`> can I have two distinct lists for generating tests cases in quickcheck?
03:13:58 <nkar`> so, something like the elements function but that would allow me to pick a specific set
03:15:32 <phaazon> oh neat!
03:15:35 <phaazon> MonadComprehension
03:25:44 <merijn> I always think more people should go over the GHC manual (especially extensions) and the Haskell Report, so many useful and neat facts in there
03:26:02 <bergmark> M_b
03:26:45 <phaazon> merijn: indeed
03:26:52 <bitemyapp> merijn: yep
03:29:59 * hackagebot network-anonymous-i2p 0.9.0 - Haskell API for I2P anonymous networking  http://hackage.haskell.org/package/network-anonymous-i2p-0.9.0 (solatis)
03:33:45 <mroman> how lightweight are forkIO threads?
03:34:12 <bitemyapp> mroman: minute-of-Erlang
03:34:44 <mroman> I'm talking about like doing 512 forkIOs
03:35:05 <mroman> and I actually expect the runtime system to distribute them fairly well amongst cores and os threads
03:35:31 <sgronblo> Ok, could someone try to help me figure out this no instance for Stream s0 m0 Char with Parsec's string?
03:36:00 <bitemyapp> mroman: cool
03:36:13 <bitemyapp> mroman: http://chimera.labs.oreilly.com/books/1230000000929 http://stackoverflow.com/questions/5847642/haskell-lightweight-threads-overhead-and-use-on-multicores
03:36:18 <mrkkrp> Say I've defined a data type using record syntax. I don't use some functions that have been generated. Can I remove them somehow, or should I ignore `defined but never used' warning in this case?
03:36:34 <mroman> sgronblo: parse parseStuff "" input?
03:37:07 <mroman> or do you mean like parseDef = do { string "def"; optional spaces; foo <- parseFoo; }?
03:37:23 <mroman> I wanna do some simulation based on cells
03:37:30 <mroman> and I figured I might be able to use a forkIO for every cell
03:38:04 <mroman> (cells contain bacterias I want to simulate)
03:38:25 <mroman> (so a cell is merely a region of the world)
03:38:59 <bitemyapp> I don't know that you'll benefit from doing so.
03:40:39 <simg> dmg': thx for file dialog suggestion. I checked it out but as yet it doesn't support multiple files (and really, I'm also/more interested in the general case of handling multiple subforms where there isn't an immediate one-to-one mapping between the Data type fields and the Form fields.
03:41:17 <rickvonh> this program kind of works, except it assumes that the list 'points' start value is [1,2,3,4] when I want it to be [0,0,0,0]. help http://lpaste.net/124479
03:42:22 <sgronblo> I have this sub expression in a where "oneUnderTop = string [low, top] >> return $ 9 * base" which results in a lack of instance for Stream s1 m2 Char. This vim plugin I have installed can even tell me there is an instance that would match, I have the import that matches that, but still get the error.
03:43:41 <merijn> mroman: forkIO is more like "100k to 1 million threads on a moderate server should be more than fine"
03:44:03 <sgronblo> I thought this was related to the monomorhpism restriction but still get the error after adding no monomorphism restriction.
03:44:30 <merijn> In reality it depends, of course. More threads than cores only makes sense in the case of blocking for IO, not so much for doing computation (since more threads than cores is a bit silly)
03:45:16 <merijn> mrkkrp: If you export the record functions from your module that warning should go away
03:47:19 <merijn> sgronblo: If it was the monomorphism restriction GHC would tell you, it explicitly mentions that in any errors it produces
03:47:44 <merijn> sgronblo: Add a type signature for the parser type you want?
03:47:46 <mrkkrp> merijn: this would be conceptually wrong. However, I've found proper solution: names of such functions should start with underscore.
03:48:16 <merijn> mrkkrp: Right, but if you don't export them and don't use them, why have them?
03:49:09 <mrkkrp> merijn: I use some of them. When I need to access all fields I use positional pattern matching.
03:49:39 <mrkkrp> so, it turns out that some functions are useless..
03:51:33 <merijn> ah, right
03:52:47 <nkar`> in haddock, is there a way to refer to a module which is not in scope?  say, from an internal module to an upper-level one
03:53:09 <nkar`> refer as in hyperlink
03:53:15 <merijn> nkar`: AFAIK, no
03:53:26 <merijn> nkar`: You'd have to import it, but I'm not 100% sure
03:54:07 <nkar`> merijn: Control.Lens.Internal seems to use @Control.Lens@ for this reason.
03:54:59 <merijn> Actually double quotes for referring to a module seems to work even when not imported
03:55:28 <nkar`> let me try that
03:55:36 <merijn> "Control.Monad", not sure if that only applies to modules within the same package, though
03:55:59 <nkar`> merijn: oh, cool!  works indeed
03:59:25 <mrkkrp> rickvonh: so, what's the problem? If you need [0,0,0,0], just write it.
04:00:36 <rickvonh> mrkkrp: if u replace points with [0,0,0,0] it wont accumulate
04:01:28 <mrkkrp> What do you mean `replace points'? You need to change its initial value.
04:02:21 <rickvonh> mrkkrp: yes, that's my problem! I don't know how to accomplish that
04:02:41 <mrkkrp> You explicitly call `ask' with [1..10], so initial value of `points' is [1..10]. After `zipWith' with other lists (length 4) you get [1,2,3,4]. Now, what should you change in your program?
04:04:06 <rickvonh> mrkkrp: I owe you my firstborn child
04:04:14 <rickvonh> mrkkrp: THANKS!!
04:05:02 <rickvonh> mrkkrp: I feel so stupid that I didn't think of it earlier.. thanks once again lol
04:06:06 <rosen2> @help
04:06:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:14:34 <mroman> merijn: The point is that you create "virtual threads" as a means of a "computation unit".
04:14:57 <mroman> which means you can program without having to worry about how to distribute these units on the available cores
04:15:02 <mroman> because the underlying runtime will do that.
04:15:26 <mroman> "actor model" I think it is called
04:15:29 <mroman> to a certain degree
04:16:23 <Grisha> hello, I'm looking for something like iterate, but the single iterations should depend on another (given) list
04:16:58 <mroman> the idea is to spawn actors without having to worry how much cpus, cores or even distributed computers you have
04:17:09 <mroman> some Java Libraries support spawning and moving actors between hosts for example
04:17:27 <Grisha> a list of [x, f x, f (f x), ...], but f itself is parameterized by a given list
04:18:12 <mroman> ideally they will even automatically re-distribute actors on hosts depending on computational load
04:18:31 <quchen2> Grisha: \parameter -> iterate (f parameter)?
04:18:37 <mroman> as in if a host has too much load and another one not so much the system will automatically move the actors the less busy nodes
04:18:46 <mroman> *to the
04:19:01 <Grisha> quchen2, it's rather a list of parameters
04:19:28 <Grisha> quchen2, so each iteration should depend on the next element in the parameter list
04:20:05 <mroman> which is very scalable since if you need to do more computations you can just spawn a new actor and the system will do the rest
04:20:53 <tdammers> :t Data.Text.splitOn
04:20:53 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
04:21:10 <quchen2> You could build up a list [combiner p1 f, combiner p2 f, ...] and then use a scan on that list in that case
04:21:11 <tdammers> I want that for ByteString... does that exist?
04:21:28 <Grisha> quchen2, thanks! I will think about it
04:21:34 <mroman> (http://akka.io/ - Akka for example is a framework/library like that)
04:22:28 <mroman> I should look at CloudHaskell some day
04:23:13 <mrkkrp> Grisha: looks like you can write it using explicit recursion. When you have working function, it's much more easier to rewrite it with help of higher-order functions, if it's your goal.
04:24:39 <Grisha> mrkkrp, I see - the thing is that I have several functions that do nothing but iterations parameterized by a given list and I thought to express it in a slightly more general way
04:25:03 <Grisha> mrkkrp, thank you
04:25:12 <Grisha> mrkkrp, I'll give it a thought
04:25:14 <quchen2> iterate' f (param:ps) x = f param x : iterate' f ps x -- This is probably the easiest solution, based on "iterate" directly.
04:25:19 <quchen2> Grisha: ^
04:25:37 <quchen2> Woops, error.
04:25:56 <loki_> Hi, I have this rather simple OpenGL code: http://lpaste.net/124484 In Line:19 instead of scaling everything to the same size in every iteration (like stated in every tutorials) It adds up the scale calls on every displayCallback (e.g. resizing the window) I've searched for nearly an hour now. Any hints or ideas on this one?
04:26:20 <quchen2> iterate' f (param:ps) x = f param x : iterate' f ps (f param x) -- better.
04:26:47 <Grisha> quchen2, thanks - a quite straight-forward generalization indeed
04:27:09 <quchen2> I guess this is simpler than modifying "iterate" to do what you want.
04:27:32 <quchen2> Modifying iterate's surrounding functions, that is.
04:28:09 <quchen2> The solution above has poor sharing, you should put the "f param x" in a let-binding to share it between invocations.
04:28:12 <Grisha> quchen2, yes, the only thing that occures to me now is that the parameter list must be infinite as well
04:28:16 <quchen2> But it was more readable the way I wrote it.
04:28:51 <quchen2> Grisha: Sure. But you can add your own special case if the parameter list is empty.
04:29:23 <Grisha> quchen2, thanks a lot, that was most helpful
04:30:16 <quchen2> iterate' f defaultParam [] x = iterate (f defaultParam) x, iterate' f def (p:ps) x = let y = f p x in y : iterate' f def ps y -- something like this, Grisha 
04:30:49 <Grisha> yes, I see
04:31:06 <quchen2> It's getting ugly as a one-liner, but you can write it nicely in 3 lines.
04:35:02 * hackagebot network-anonymous-i2p 0.9.1 - Haskell API for I2P anonymous networking  http://hackage.haskell.org/package/network-anonymous-i2p-0.9.1 (solatis)
04:35:22 <Grisha> quchen2, I think I just need a special case for parameters = []
04:35:35 <Grisha> quchen2, one more pattern-matching definition
04:36:06 <quchen2> That's what I wrote two messages above this one
04:44:41 <fumieval> is there something like MonadSTM?
04:49:15 <merijn> fumieval: What would that do?
04:49:35 <merijn> fumieval: Actually, that makes no sense at all, since MonadX is usually a class for transformers
04:49:43 <merijn> And STM is not a monad transformer
04:50:12 <fumieval> merijn: I mean, MonadIO analogue for STM
04:50:22 <int-e> There's https://hackage.haskell.org/package/monad-stm
04:51:35 <fumieval> int-e: oh thanks
04:52:06 <int-e> But STM has restarts which I expect will produce weird semantics if this is used with anything but ReaderT.
04:52:07 <merijn> That likely won't help, though
04:52:30 <merijn> Because there's no MonadSTM instances in that package, except the MonadTrans one
04:52:46 <merijn> So unless you define a whole bunch of orphans liftSTM is basically just lift
04:53:13 <merijn> oh, maybe not
04:53:38 <merijn> Anyway, I still don't think this class is a very good idea
04:54:06 <merijn> I would recommend against STM in transformer stacks anyway
04:54:07 <fumieval> note the inductive instance declaration, though this style does not look to me 
04:54:15 <int-e> No, it's like liftIO. But the real question is  about the expected semantics, which are probably different from the actual semantics you'll get.
04:55:20 <fumieval> I expect that liftSTM = id or atomically or lift . atomically or ...
04:55:37 <merijn> fumieval: Yes, but what does "StateT s STM a" mean, for example?
04:56:33 <int-e> fumieval: As merijn said, STM is a base monad, not a transformer. Your "liftSTM" is more like a polymorphic "runSTM".
04:56:34 <fumieval> merijn: it is a bit questionable
04:58:41 <int-e> (Note that atomically :: STM a -> IO a, and the latter does not mention STM at all.)
04:58:45 <merijn> fumieval: I would probably just do "liftSTM x = liftIO . atomically $ x" (define that as small utility function in your package somewhere), that probably has the semantics you want in the first place
04:59:05 <merijn> eh, eta reduce that
04:59:10 <nkar`> how do I make tasty verbose?
04:59:45 <fumieval> merjin: I want `liftSTM = id` in addition to `liftIO . atomically`
05:00:20 <merijn> Are you sure you want that, though?
05:00:33 <merijn> I can't think of ever having wanted STM at the bottom of a monad stack
05:00:52 <fumieval>  MonadIO IO is important, isn't it?
05:02:17 <solatis> what is MonadIO IO ?
05:02:20 <merijn> Only for the recursive instance
05:03:01 <merijn> MonadIO IO is just the base case of the recursive (Monad (t m), MonadIO m, MonadTrans t) => MonadIO (t m) instance
05:03:25 <fumieval> IO is an instance of MonadIO
05:03:42 <fumieval> the trivial case of liftIO
05:03:47 <merijn> fumieval: If your stack has IO at the bottom, then "liftIO . atomically" already does all you want, no? That is, lifting an STM action into your stack
05:04:07 <solatis> ah right
05:06:08 <fumieval> merjin: although liftSTM = id :: STM a -> STM a does not work as a base case, I sometimes want this
05:06:49 <merijn> When/why?
05:07:10 <merijn> Really I'm just confused how you plan to use this
05:07:43 <fumieval> suppose someComputation :: MonadSTM m => m ()
05:07:55 <bennofs> anyone mentioned MonadBase STM yet?
05:08:00 <bennofs> @hoogle liftBase
05:08:02 <lambdabot> No results found
05:08:06 <bennofs> :|
05:08:28 <fumieval> we can compose someComputation atomically using the MonadSTM STM instance
05:09:02 <merijn> fumieval: Right and I'm saying "MonadSTM m => m ()" is not a very useful type
05:09:08 <merijn> imo
05:10:09 <bennofs> @hackage transformers-base
05:10:10 <lambdabot> http://hackage.haskell.org/package/transformers-base
05:10:19 <fumieval> merjin: the usefulness of this small example is not essential
05:10:47 <fumieval> we can also use someComputation as IO (), so that we don't have to call `atomically` manually
05:10:59 <merijn> I don't believe there's many sensible stacks that can exist with STM at the bottom, hence I question the value of automated lifting for such a stack
05:11:30 <Cale> I really dislike the whole "stack" terminology surrounding monad transformers.
05:11:49 <Cale> You don't call f (g (h x)) a "function stack"
05:12:28 <merijn> Cale: Feel free to coin a better term :p
05:12:34 <Cale> Monad.
05:12:40 <merijn> Cale: A transformer composition?
05:12:42 <fumieval> merjin: a monad stack on the STM is not the objective
05:12:47 <Cale> You either have a monad, or you have a monad transformer
05:13:10 <merijn> fumieval: Clearly it is, because MonadSTM is only useful for that
05:13:29 <tdammers> or you have a monad derived by composing another monad with a transformer
05:14:07 <fumieval> merijn: the key idea of MonadSTM is that there is liftSTM = atomically
05:14:20 <Cale> If you find it extremely relevant that your monad happens to have been constructed by applying some monad transformer to another monad, then you're probably using monad transformers poorly.
05:14:31 <merijn> fumieval: For what purpose?
05:14:39 <Cale> Yes, using 'lift' depends on this fact.
05:14:47 <Cale> But you shouldn't be using lifts everywhere.
05:14:49 <tdammers> Cale: not extremely relevant, but sometimes you do want talk about this fact...
05:15:00 <fumieval> merjin: as I described. MonadSTM sans IO instance is not useful for me
05:16:04 <merijn> fumieval: You're still refusing to say what you're actually trying to do. All common cases for what you are describing are fairly useless. You then say "I plan to do something else with it", I ask what and you don't answer. I'm not sure how you expect anyone to help you solve your problem if you refuse to say what it is
05:16:40 <Cale> It makes just as much sense to transform STM as it does to transform IO.
05:17:12 <merijn> Anyway, I should get back to paper writing
05:17:25 <Cale> (But if you ask me, the amount of sense it makes in both cases is "not a whole lot")
05:18:02 <Cale> Well, there are cases where it's exactly what you want, but you shouldn't be jumping to do it in either case.
05:18:52 <Cale> I kind of think MonadIO is evil, it helps people do the wrong thing more easily. (Even though there are perfectly non-evil uses.)
05:18:56 <tdammers> ReaderT ProgramOptions IO -- why not?
05:19:13 <Cale> Because ProgramOptions -> IO ()  is better
05:19:30 <tdammers> hmm
05:19:32 <Cale> In almost all cases I've ever run into
05:19:47 <Cale> The resulting programs are just easier to work with
05:19:59 <tdammers> I guess
05:20:04 * hackagebot tidal 0.4.30 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.30 (AlexMcLean)
05:20:18 <_dropp`> yoo
05:20:21 <tdammers> I tend to produce more clutter that way though
05:20:23 <Cale> The exception is when you're constructing a real, serious abstraction over IO
05:20:45 <Cale> and in that case, liftIO should be seen as a bit of a threat
05:20:53 <Cale> and certainly lift should
05:20:56 <tdammers> web application here... Handler is my IO abstraction
05:21:05 <_dropp`> how's everyone doing this morning (or whatever time of day it is where you are)?
05:21:15 <tdammers> and yes, liftIO is considered dangerous in this context
05:21:35 <tdammers> especially when you're running in CGI mode... putStrLn can cause invalid HTTP...
05:22:20 <merijn> Cale: Are you referring to in libraries or in programs?
05:22:26 <Cale> also, in those cases where ReaderT over IO makes sense, you're practically always going to want to wrap that in a newtype and not let anyone know that you're really using ReaderT anyway
05:22:36 <Cale> merijn: Both, sort of.
05:22:54 <merijn> Cale: i.e. I can see how liftIO is a problem if you're exposing your transformed IO to the outside, but otherwise how would you sensibly use it inside your library?
05:23:15 <Cale> merijn: Well, okay, really you just want to limit your use of lifting.
05:23:28 <nshepperd> isn't StateT STM just an STM transaction with some associated state
05:23:51 <nshepperd> that also gets "reset" to the "initial value" if the transaction retries
05:24:10 <Cale> merijn: The thing about liftIO in particular is that it replaces some lifts in a setting where you should know exactly how many lifts you need, because you're in abstraction implementation mode.
05:24:26 <Cale> merijn: Making that more convenient isn't necessarily a terrible thing
05:24:29 <merijn> Cale: Sure, but I'm lazy and typing 4-5 lifts is annoying
05:24:42 <Cale> merijn: It's just that it helps people who *don't* build the abstraction
05:25:04 <tdammers> Cale: yes, that's what I usually end up doing
05:25:05 <Cale> and get into a messy situation where they have these piles of monad transformers applied to IO all over the place
05:25:12 <nshepperd> seems fairly logical
05:26:09 <merijn> I guess you could newtype and don't derive MonadIO and implement your own internal/unexported liftIO that applies liftIO within the newtype
05:26:35 <Cale> merijn: Or figure out all the I/O which belongs, and put that stuff in your library
05:27:08 <Cale> (which is a big thing to try to do, which is why I'm a bit cautious about this whole situation)
05:27:11 <merijn> Cale: No, I meant so that you could use your internal liftIO in your library without a user having access to liftIO
05:27:17 <Cale> Oh, sure
05:27:55 <Cale> I sort of think that it should never really *matter* that you're using monad transformers
05:28:38 <fumieval> I tend not to introduce a concrete example
05:28:43 <merijn> Anyway time to quit IRC and write
05:28:48 <tdammers> in my case, I opted for exposing MonadIO after all
05:29:10 <fumieval> https://hackage.haskell.org/package/objective-1.0.1/docs/Control-Object-Instance.html#v:..-45- is what I'm goint to work on
05:29:29 <Cale> Yeah, you might choose to expose MonadIO for the same reason you might allow people access to the internals of your abstraction just in case they really need it.
05:29:38 <tdammers> because I have too many things that aren't specific to a HTTP request handler context, and I don't want any dependencies between those and my Handler monad
05:29:40 <fumieval> oh he has quitted
05:30:05 <tdammers> but I still want the Handler monad to hide the details of HTTP specific code and such
05:30:34 <tdammers> I don't want external code to mess with my ResponseHeaders list, for example
05:33:44 <Cale> fumieval: btw, you could write a Category instance for Object
05:34:34 <fumieval> actually it needs a functor
05:34:40 <Cale> oh
05:34:46 <Cale> I see, yeah
05:35:14 <fumieval> yoneda lemma allows us to get rid of that https://gist.github.com/fumieval/3b894b3bea867594b8d7
05:35:35 <nerium> Is there a way to remove a substring from a string in haskell?
05:36:36 <Cale> nerium: Well, you can use splitOn (from Data.List.Split) and concat
05:37:34 <Cale> > concat . splitOn "is" $ "mississippi"
05:37:35 <lambdabot>  "mssippi"
05:38:19 <nerium> Cale: thats, that worked
05:38:20 <Cale> nerium: If you're using Data.Text, you can use replace
05:38:22 <nerium> *thanks
05:40:05 * hackagebot waitra 0.0.1.0 - A very simple Wai router  http://hackage.haskell.org/package/waitra-0.0.1.0 (phadej)
05:41:09 <tdammers> there's no splitOn for ByteString though, is there?
05:41:37 <Cale> tdammers: Not sure.
05:42:22 <tdammers> haven't found any, wondered why that was
05:42:42 <EvanR> tdammers: theres this package stringsearch
05:42:50 <Cale> tdammers: There's breakSubstring, which is close
05:43:13 <tdammers> welp, plain split works for this, since I'm splitting on individual bytes
05:43:30 <tdammers> just a bit inconvenient that I have to do the somewhat dirty fromIntegral . ord thing
05:43:48 <EvanR> split :: ByteString -> ByteString -> [ByteString]
05:43:53 <EvanR> (stringsearch)
05:44:08 <Cale> You could also just use the .Char8 version of split
05:45:14 <tdammers> EvanR: right, that sounds like what I want... adding another dependency just for this one thing might be overkill though
05:45:27 <tdammers> Cale: ah, totally forgot about that
05:45:55 <EvanR> it seems to advertise high performance, if you dont care about performance, just do pack unpack ;)
05:46:22 <EvanR> (i wonder if these algorithms could be incorporated into base)
05:46:54 <tdammers> nah, split is good enough for now
05:47:17 <tdammers> all I'm doing is split a domain name by dots for the purpose of handling cookie domains in a type-safe-ish manner
05:47:31 <EvanR> oh
05:48:07 <EvanR> then split seems right
05:48:10 <nerium> Is there a way to check if a value (currently as a string) is of some type?
05:48:11 <nerium> I want for example want to check if "20" is of type Int
05:48:27 <EvanR> "20" is of type String
05:48:51 <keko-2> I thin he means "can be parsed as a value of some type"
05:49:09 <EvanR> > all isDigit "20"
05:49:11 <lambdabot>  True
05:49:30 <EvanR> > reads "20" :: [(Int, String)]
05:49:31 <lambdabot>  [(20,"")]
05:50:05 <bergey> > :t readMaybe
05:50:06 <lambdabot>  <hint>:1:1: parse error on input ‘:’
05:50:06 <nerium> EvanR: Does similar functions exist for Doubles and Booleans?
05:50:16 <tdammers> > all isDigit "000001"
05:50:17 <EvanR> theres readMaybe
05:50:17 <lambdabot>  True
05:50:27 <tdammers> > reads "000001" :: [(Int, String)]
05:50:29 <lambdabot>  [(1,"")]
05:50:35 <tdammers> mkay
05:50:54 <tdammers> :t reads
05:50:55 <keko-2> reads "00020" :: [(Int, String)]
05:50:55 <lambdabot> Read a => ReadS a
05:50:57 <keko-2> > reads "00020" :: [(Int, String)]
05:50:57 <EvanR> > 000001
05:50:58 <lambdabot>  [(20,"")]
05:50:59 <lambdabot>  can't find file: L.hs
05:51:50 <keko-2> > readMaybe "42" :: Maybe Int
05:51:52 <lambdabot>  Not in scope: ‘readMaybe’
05:52:02 <keko-2> http://hackage.haskell.org/package/base-4.7.0.2/docs/Text-Read.html#v:readMaybe
05:52:07 <EvanR> > Data.Text.readMaybe "42" :: Maybe Int
05:52:08 <lambdabot>  Not in scope: ‘Data.Text.readMaybe’
05:52:29 <Cale> nerium: reads will give you a list of parses for any type that's an instance of Read
05:52:31 <Cale> :t reads
05:52:32 <lambdabot> Read a => ReadS a
05:52:46 <Cale> type ReadS a = String -> [(a, String)]
05:53:01 <Cale> > reads "32.54" :: [(Double, String)]
05:53:02 <lambdabot>  [(32.54,"")]
05:53:13 <Cale> > reads "Truex" :: [(Bool, String)]
05:53:14 <lambdabot>  []
05:53:18 <Cale> > reads "True" :: [(Bool, String)]
05:53:19 <lambdabot>  [(True,"")]
05:53:36 <Cale> That's interesting, I didn't know that about the Bool instance, I guess it's reasonable enough
05:53:46 <Cale> > reads "132x" :: [(Integer, String)]
05:53:48 <lambdabot>  [(132,"x")]
05:54:02 <mniip> > reads "True x"
05:54:04 <lambdabot>  []
05:54:09 <nerium> Cale: Nice, that will work, thanks!
05:54:16 <mniip> oops monomorphism
05:54:22 <mniip> > reads "True x" :: [(Bool, String)]
05:54:23 <lambdabot>  [(True," x")]
06:12:14 <tristanp> What is the difference between let and where? Just the placement relative to the body of the main function?
06:13:03 <idem-pyon-tent> Does Applicative make sense in categories other than Hask?
06:13:37 <sujeet> tristanp, isn't where restricted to the statement before it
06:15:03 <sujeet> tristanp, https://wiki.haskell.org/Let_vs._Where
06:16:12 <nerium> Is it possible to pass a type as argument? I would like to pass "Int" as arg to a function
06:17:00 <EvanR> there is such a thing as typeable, and "Int" could be a type representation, but why do you want to do this?
06:17:20 <nerium> EvanR: I'm trying to check the type of a value
06:17:39 <nerium> And I would like to pass the type and a value to this particular "check" function
06:17:39 <EvanR> dont you mean check the format of a string?
06:17:52 <nerium> EvanR: Hmm, that's true
06:18:01 <cfoch> hello
06:18:41 <EvanR> nerium: you can define your own set of valid formats such as Numeric, AlphaNumeric, GPSCoords or whatever
06:18:53 <EvanR> and write a validators
06:18:53 <cfoch> why when I do "cabal --version" I get I have the 1.23.0.0 version. But If I do, cabal info Cabal, it says I have the version 1.18.1.5 ?
06:19:21 <EvanR> nerium: but more often you just write a parser which takes the string and gives you the parser value, or an error
06:19:28 <EvanR> parsed value*
06:19:35 <nerium> EvanR: I guess I can use regexp for this
06:19:44 <bergmark> cfoch: same here, it probably picks the version that ships with ghc for some reason
06:20:03 <EvanR> nerium: check out parsec or one of the other parser combinator libs
06:20:47 <cfoch> bergamark: so when I use the "cabal" command, it is really using 1.18.1.5 ?
06:21:07 <bergmark> cfoch: no, it'll be using what cabal --version says
06:22:59 <bergmark> cfoch: cabal --version says what version cabal-install is built against, you can have several executables...
06:23:09 <bergmark> cfoch: what does cabal info --package-db=user Cabal say by the way?
06:23:19 <bergmark> cfoch: and ghc-pkg list Cabal?
06:24:42 <cfoch> cabal info --package-db=user Cabal says
06:24:42 <cfoch> Versions installed: 1.18.1.5, 1.23.0.0
06:24:44 <cfoch> and
06:24:52 <cfoch> ghc-pkg list cabal says
06:24:53 <cfoch> http://fpaste.org/196617/14260801/
06:25:00 <cfoch> bergmark: ^
06:25:25 <bergmark> cfoch: perhaps cabal info defaults to only checking the global package db
06:25:51 <bergmark> unintuitive and maybe a bug if that's the case
06:26:12 <mrkkrp> Can I pass compiler options to cabal build without adding them to .cabal file? I would like to build my project with some options for profiling.
06:28:10 <idem-pyon-tent> IIRC, there was a Haskell package that decomposed Applicative into Pointed (just pure) and something else (just ap). And Similarly Monad into Pointed and Bind. What was it?
06:32:21 <nshepperd> idem-pyon-tent: i think the keyword to google is 'lax monoidal functor' re categories other than hask
06:35:00 <lexi-lambda> How could I make an "alternative" instance of a typeclass for function types via a newtype wrapper?
06:35:39 <lexi-lambda> I tried writing `newtype Foo a = ((->) a)`, but that gives me a kind error.
06:35:45 <Cale> newtype Fun a b = Fun (a -> b)
06:35:57 <idem-pyon-tent> Mmm... The thing is: I made a "class Functor (f :: * -> *)" (no methods), and a "class (Morphism m, Functor f) => FunctorMap m f where map :: m -> f (Source m) -> f (Target m)". I wanted to know if the following also makes sense: "class FunctorMap m f => ApplicativeAp where (<*>) :: f m -> f (Source m) -> f (Target m)".
06:35:58 <lexi-lambda> Oh, wait.
06:36:00 <lexi-lambda> I'm silly.
06:36:11 <idem-pyon-tent> Errr, ApplicativeAp m f *
06:40:08 * hackagebot language-puppet 1.1.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.0 (SimonMarechal)
06:42:30 <nerium> I*m trying to use the regexp package, but I*m getting an error
06:42:30 <nerium> https://gist.github.com/oleander/27916231197034d26bb1
06:42:37 <nerium> What I*m I doing wrong?
06:45:31 <gcganley> what is source1?
06:45:42 <bergmark> nerium: "The type variable ‘source1’ is ambiguous"
06:46:36 <bergmark> nerium: that means you have to help ghc infer the type, e.g. by adding a type signature
06:55:47 <mrkkrp> How to force `cabal build' rebuild project even if it thinks that it doesn't need to rebuild it?
06:56:44 <bergey> `cabal clean` first?
06:56:59 <bergmark> or --ghc-options='-fforce-recomp'
06:57:17 <gcganley`> mkkkrp: bump the version
06:57:17 <gcganley`> althought there should be a --force-rebuild
06:58:34 <nkar`> why does toTitle from the text package capitalizes "it's" as "It'S"?
06:58:40 <nkar`> what's the rationale?
06:59:09 <EvanR> error
06:59:56 <nkar`> EvanR: why are you so confident?  is it a well-known fact?
07:00:32 <EvanR> not that im the greatest capitalization and punctuation master, but It'S looks very wrong for english
07:02:03 <mrkkrp> I'm trying to use profiling, but when I do `cabal build --ghc-options='-prof -auto-all -caf-all'' it says that "Perhaps you haven't installed the profiling libraries for package <some package>’?". What am I doing wrong?
07:02:27 <nkar`> EvanR: my guess is that it's because "'s" is actually "is" which is a different word.  and there's no definitive answer to the "what's a word?" question.
07:02:38 <nkar`> I'll check the source, though
07:02:45 <EvanR> nkar`: thatS silly
07:03:06 <nkar`> what's silly exactly/
07:03:08 <nkar`> ?
07:03:14 <EvanR> that theory
07:03:36 <nkar`> some nlp libraries, for instance, treat 's as a separate word
07:04:49 <rui1> Is there any resource on what extensions are considered safe and good practice, which aren't, etc?
07:05:08 <EvanR> nkar`: its not supposed to be capitalized
07:05:17 <kaidelong> IncoherentInstances can break things in unpredictable ways
07:05:20 <EvanR> that'S absurd
07:05:33 <kaidelong> RankNTypes breaks type inference
07:07:48 <bergmark> rui1: i don't know of one
07:08:10 <sgronblo> All right, maybe someone could help me figure out this Parsec problem now...
07:08:26 <sgronblo> I'm trying to parse roman numerals
07:11:45 <rui1> bergmark: pity, thanks
07:11:56 <EvanR> im doing First ... <> First ..., is there a better way to write that?
07:12:01 <rui1> and which extensions do you you people use most often?
07:12:39 <bergmark> rui1: give me a way to grep for that in our source tree :-)
07:12:40 <Fuuzetsu> EvanR: maybe First (... <> ...) depending on what you're working with…
07:13:05 <EvanR> Maybe (MVar [ThreadId])
07:14:35 <rui1> Hehe
07:15:10 * hackagebot not-gloss 0.7.1.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.1.0 (GregHorn)
07:16:30 <bergmark> EvanR: <!> form semigroupoids? it's <|> without mempty
07:18:17 <EvanR> dont see that in semigroupoids haddock
07:18:48 <sgronblo> Guys, so I'm trying to use Parsec's string, but I'm getting a missing instance for Stream s1 m2 Char... Even though there should be a Stream [tok] Monad tok...
07:20:01 <L8D> sgronblo: code?
07:22:01 <nkar`> rui1: ghc bug tracker?
07:23:06 <L8D> rui1: pragmas?
07:23:33 <rui1> L8D: yes, language pragmas
07:23:48 <rui1> nkar`: Thanks, let me google that
07:24:44 <L8D> rui1: OverloadedStrings for working with ByteStrings or Text
07:24:56 <L8D> rui1: TemplateHaskell if you're using lens and friends
07:25:12 <clrnd> rui1, just use whatever you need, omit those you don't need
07:25:26 <L8D> rui1: GeneralizedNewtypeDeriving, Generic and DervieTypable for doing fancy type wrappers
07:25:44 <L8D> rui1: RankNTypes for 
07:25:53 <tdammers> GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings would be my top 3
07:25:59 <L8D> annoying nested types which I honestly still haven't clearly figured out
07:26:38 <L8D> oh and QuasiQuotes in addition to TemplateHaskell
07:27:05 <rui1> Nice, nice
07:27:09 <tdammers> oh yes, QQ... though not half as much as TH
07:27:13 <sgronblo> L8D: http://pastebin.com/rh2LZksx is this enough to figure out the problem?
07:29:56 <rui1> I was expecting MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, RankNTypes, and those. I can't seem to be able to write more than a few lines of code without the compiler suggesting me to add them. I woner if instead I should get some better design habits (I have none of those yet)
07:30:10 <L8D> sgronblo: I believe it's because of >> return $ 9 * base
07:30:17 <L8D> sgronblo: try >> return (9 * base)
07:30:32 <L8D> sgronblo: otherwise, the code looks fine
07:30:39 <L8D> sgronblo: I'd recommend using Parsec3 though
07:31:37 <tdammers> rui1: you're probably overusing instances
07:31:58 <bergmark> EvanR: it might not have been what you asked for, but it's there /Users/adam/repos/3rd/semigroupoids/dist/doc/html/semigroupoids/Data-Functor-Alt.html
07:32:02 <bergmark> noo :)
07:32:09 <bergmark> http://hackage.haskell.org/package/semigroupoids-4.3/docs/Data-Functor-Alt.html
07:32:13 <EvanR> bergmark: lol
07:32:18 <kaidelong> FunctionalDependencies is pretty safe
07:32:25 <kaidelong> it can only help type inference, not hurt it
07:32:52 <rui1> kaidelong: right. But it only makes sense with MultiParamTypeClasses I guess
07:33:10 <bergmark> i was trying to send a PR fixing the link to <|> but i don't know how what to write instead of @<|>@ for haddock to do the right thing, anyone know?
07:33:28 <EvanR> ah alternative functor
07:33:28 <bergmark> @(<|>)@ *
07:33:28 <lambdabot> Unknown command, try @list
07:35:23 <bergmark> ah it's just '<|>', i'm bad at haddock :-(
07:36:37 <Fuuzetsu> single quotes make a link to something, function, type, whatever
07:36:57 <Fuuzetsu> the @s make a code block/fixed width if you will
07:39:26 <bergmark> Fuuzetsu: @(<|>)@ turned into a link to | O_o, but thanks! i sent the PR
07:40:00 <Fuuzetsu> because <foo> will try to make a hyperlink, such as <google.com> :)
07:40:24 <sgronblo> L8D: Ah it was just a priority problem with return and >> ?
07:41:09 <L8D> sgronblo: yeah
07:41:17 <L8D> sgronblo: >> and $
07:42:09 <L8D> it thought you were writing (string [low, top] >> return) $ 9 * base
07:45:44 <sgronblo> L8D: ah, I feel stupid now
07:45:52 <sgronblo> the error message threw me off completely
07:46:21 <ocharles_> Anyone here familiar with Data.Singletons.Decide (pinging goldfire :))? I'm getting Could not deduce (Data.Singletons.Decide.SDecide 'KProxy) arising from a use of ‘%~’
07:46:58 <ocharles_> On the line `case chan %~ (sing :: M.SSubscriptionChannel c) of`   - chan :: M.SSubscriptionChannel unknown  , sing is from Data.Singletons
07:47:24 <ocharles_> SSubscription channel is coming from $(singletons [d| data SubscriptionChannel = ... |])
07:49:27 <ocharles_> Hmm, there is 'testEquality' too - I wonder if I'll have more luck with that
07:49:41 <ocharles_> bah, same problem
07:53:04 <sgronblo> L8D: Thanks for sorting it out for me!
07:53:28 <Denommus> hi
08:02:09 <L8D> Denommus: hi
08:08:42 <shourya> Hello.
08:08:47 <clrnd> hola
08:09:52 <ocharles_> blugh, I can't even write (sing :: Sing c) %~ (sing :: Sing c)
08:09:54 <ocharles_> same error :/
08:11:16 <Denommus> luite: ping
08:14:31 <ocharles_> huh M.SBookingsChannel %~ M.SBookingsChannel doesn't even type check. I must be doing something very wrong...
08:15:57 <Taneb> ocharles_, which %~ is that?
08:16:09 <ocharles_> ohhhh, I'm not deriving Eq! Could be that
08:16:14 <bergmark> it's the buttersquiddle
08:16:15 <ocharles_> Taneb: Data.Singletons.Decide.%~
08:20:21 <cfoch> How can I know what version of some package is an executable using?
08:21:02 <ocharles_> cfoch: maybe run `ldd` on it
08:21:09 <ocharles_> if it was linked with shared libraries, you might be in luck
08:25:07 <cfoch> ocharles_: I mean Haskell libraries
08:25:12 <ocharles_> yea
08:25:20 <ocharles_> they would show up, if they were built as shared libraries
08:29:13 <mrkkrp> This shit is killing me. I've enabled `library-profiling' in ~/.cabal/config, then reinstalled all packages (3 times). Then `cabal clean ; cabal configure --enable-profiling ; cabal build'. I'm still getting 'perhaps you haven't installed profiling libraries for package ...'. What a fuck? Does anybody know how to make profiling work?
08:29:54 <EvanR> no shitty language
08:30:08 <mrkkrp> EvanR: ok, sorry
08:31:55 <clrnd> mrkkrp, we all went trough that :P, now we use sandboxes
08:33:13 <clrnd> mrkkrp, are you?
08:33:27 <mrkkrp> no
08:33:39 <mrkkrp> I guess I need to learn one more thing now...
08:33:51 <clrnd> mrkkrp, also, some libraries are installed by the OS package manager, you should install the -prof version of those too
08:33:51 <EvanR> never stop
08:34:51 <mrkkrp> clrnd, I haven't installed such libraries.
08:35:11 <sgronblo> How can I check which version of quick check is included in my haskell installation again?
08:35:13 * hackagebot OpenGLRaw 2.4.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.4.0.0 (SvenPanne)
08:36:02 <lpaste> marcus pasted “No title” at http://lpaste.net/4040280854948216832
08:36:09 <clrnd> ghc-pkg list | grep quick?
08:37:12 <lpaste> marcus pasted “No title” at http://lpaste.net/8716371922318786560
08:37:41 <lpaste> marcus pasted “No title” at http://lpaste.net/7683046719826690048
08:40:14 * hackagebot GLURaw 1.5.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.5.0.0 (SvenPanne)
08:42:39 <Cale> ghc-pkg list QuickCheck
08:43:12 <EvanR> QuickCheck-2.7.6
08:54:56 <JoshieAS> holy shit, the upenn cis194 Haskell course is pretty nice
08:58:45 <mrkkrp> Funny enough, I just executed `cabal sandbox init', then `cabal install --only-dependencies ; cabal configure --enable-profiling ; cabal build' to get the same error messages. I have to admit that Cabal won. I'm mentally damaged now and I need some rest.
08:59:02 <mauke^> what's the error message?
08:59:14 <mrkkrp> "Perhaps you haven't installed the profiling libraries for package ..."
08:59:20 <mauke^> no, the actual error message
09:00:01 <mrkkrp> like: src/Translator.hs:31:8: Could not find module ‘Codec.Midi’ Perhaps you haven't installed the profiling libraries for package ‘HCodecs-0.5’? Use -v to see a list of the files searched for.
09:02:05 <mrkkrp> It looks like error message to me. `cabal run -- +RTS -p' doesn't work.
09:02:08 <raek> does the sandbox inherit packages that are installed globally, perhaps?
09:02:46 <bergmark> raek: i *think* so, but i haven't investigated this
09:03:08 <adamse> raek: pretty sure global packages are visible in sandboxes
09:03:48 <bergmark> it doesn't reinstall base for one thing :)
09:04:01 <bergmark> s/it doesn't/sandboxes don't/
09:07:03 <clrnd> mrkkrp, and well, are profiling libs installed for HCodecs-0.5?
09:08:38 <lpaste> NemesisD pasted “gadt mappend” at http://lpaste.net/124488
09:08:49 <NemesisD> could someone look at ^ i must be missing something
09:09:33 <shachaf> You have an existential. Those two "a"s aren't the same type, so you can't put them in the same list.
09:09:48 <shachaf> You probably shouldn't be doing whatever it is you're doing with this type.
09:10:23 <NemesisD> let's say i do
09:10:32 <mauke^> you're doing v1 ++ v2 where v1 and v2 are lists of different types
09:11:18 <EvanR> [1,2] ++ ['c','d']
09:11:23 <EvanR> [1,2,'c','d']
09:11:25 <EvanR> whats the problem
09:12:01 <mauke^> the Num instance for Char
09:12:39 <NemesisD> ah ok i think i know what i need to do
09:12:41 <mrkkrp> clrnd: I thought that since Cabal installed HCodecs itself, it's supposed to install profiling libs for it (when `library-profiling' is enabled).
09:13:09 <cfoch> Folks
09:13:13 <cfoch> what would happen
09:13:25 <cfoch> if I ghc-pkg unregister Cabal ?
09:13:27 <cfoch> http://dpaste.com/33CAFQ5
09:13:30 <glguy> if I
09:13:31 <glguy> pressed
09:13:32 <glguy> enter
09:13:40 <cfoch> Cabal 1.18.1.5
09:13:42 <cfoch> ?
09:13:59 <clrnd> ehhhh uhhhhh ,mmmmm,,, *dies*
09:14:06 <mrkkrp> clrnd: stop! I forgot to remove `--' before library-profiling: True !!
09:14:13 <mrkkrp> aaaa
09:14:23 <clrnd> mrkkrp, jajaja, oh man
09:14:57 <clrnd> mrkkrp, to be honest, if I need to profile something, I fire up a linode and do it there, seriously I don't even care
09:15:56 <mrkkrp> clrnd: how about http://book.realworldhaskell.org/read/profiling-and-optimization.html
09:16:11 <mrkkrp> Is it bad book?
09:16:16 <clrnd> mrkkrp, that's a good guide, I learnt a lot from there
09:16:48 <clrnd> it's kinda old, but iirc it still works "as is"
09:17:25 <sgronblo> whoa, i think my manyUpToN parser combinator actually worked on the first try!
09:18:00 <ab9rf> sgronblo: that happens to me fairly frequently in haskell
09:19:31 <mauke^> manyUpToN n p | n <= 0 = pure [] | otherwise = liftA2 (:) p (manyUpToN (n - 1) p) <|> pure []
09:19:35 <ab9rf> sgronblo: i wanted a parser combinator repeated :: Parser (a -> a) -> a -> Parser a
09:19:58 <ab9rf> once i figured out the type, actually writing it was fairly easy
09:21:11 <ab9rf> repeated p x = (p >>= (\ f -> repeated p (f x))) <|> return x
09:21:43 <ab9rf> i'm sure there's a pointfree version of that lambda that wouldb e even more opaque
09:21:58 <ab9rf> and you could probably implement it with fix too :)
09:22:43 <rui1> I am reading this https://wiki.haskell.org/Use_of_language_extensions and it says:
09:22:52 <rui1> We suggest the following hierarchy of complexity with respect to types:
09:22:54 <rui1>     Simple algebraic types
09:22:56 <rui1>     H98 type classes
09:22:58 <sgronblo> mauke^: ah yeah you dont need to use the monad typeclass like i did
09:22:58 <rui1>     Fancier instance heads (but still single-parameter, non-overlapping) 
09:23:09 <rui1> What would "fancier instance heads" be?
09:23:34 <ab9rf> instance heads with extra frills, doilies, or other decorative features?
09:23:58 <EvanR> class MonadDoilies
09:24:00 <rui1> ab9rf: such as instance S (Maybe [Char])?
09:24:10 <sgronblo> mauke^: but my version is also recursive like yours, i was wondering if there was some cooler non recursive version too
09:24:25 <rui1> I mean, what's single-parameter, non-overlapping, but not H98
09:24:37 <ab9rf> sgronblo: why would you want it to be nonrecursive?
09:24:38 <rui1> and what extension allows it
09:24:55 <sgronblo> ab9rf: Just out of curiosit
09:25:09 <sgronblo> Also my version is missing the <|> pure []
09:25:13 <ab9rf> sgronblo: it's a loop, it will be recursive
09:25:35 <mauke^> sgronblo: so it parses exactly N copies?
09:25:40 <sgronblo> ab9rf: yeah but i thought maybe there was some function that would do it for me
09:25:52 <sgronblo> mauke^: no its supposed to be up to N
09:26:16 <mauke^> what
09:26:29 <mauke^> I'm talking about what your code does, not what it's supposed to do
09:26:47 <sgronblo> mauke^: you are correct
09:27:03 <sgronblo> i hadnt tested that aspect yet
09:27:14 <sgronblo> but i was thinking that my version might have some problem like that
09:31:24 <Cale> rui1: Haskell 98 requires that instances are declared for a type constructor applied to a sequence of distinct type variables.
09:31:39 <Cale> rui1: You're not allowed to write an instance C [Char]
09:31:53 <Cale> It would have to be instance C [a]
09:33:37 <sgronblo> Parsec parsing is pretty fun... not sure if it becomes horrible when you start building a big parser though
09:34:46 <rui1> Cale: thanks. And that is enabled with FlexibleInstances, great
09:34:50 <mmachenry> sgronblo: There are some pretty substantial parsers written with Parsec. It performs very well if you're sticking to LL(1) grammars. 
09:35:02 <idem-pyon-tent> Does Parsec finally make it convenient to decouple lexing from parsing? So that, if I need to backtrack, I only need to reparse, not to relex.
09:35:18 <idem-pyon-tent> That is, I want to backtrack lexemes, not characters.
09:35:19 <rui1> I wonder why the site considers that safer than multiple instances without flexible instances
09:37:56 <Cale> rui1: You mean, safer than overlapping instances?
09:38:55 <rui1> Cale: I didn't quote the full list. It was: ADT -> H98 typeclasses -> Fancier instance heads (but single-par, non-overlapping) -> Existential and universal -> GADTs -> Multiparameter type classes with fundeps -> multipar type classes with undecidable instances, overlapping instances -> template haskell
09:39:26 <rui1> I mean safer than, say, allowing for "instance C Int Float"
09:39:59 <Cale> They didn't include multiparameter type classes without fundeps in the list
09:40:02 <Cale> So I dunno
09:40:24 <tdammers> idem-pyon-tent: you can always do it as a two-pass thing
09:40:26 <Cale> But multiparameter type classes without fundeps don't see that much application
09:40:41 <rui1> Cale: But I mean with fundeps. class C a b | a -> b    and then instance C Int Float. What's not safe in that
09:40:49 <tdammers> idem-pyon-tent: first, run parsec over your input, returning a list of custom tokens
09:41:02 <tdammers> idem-pyon-tent: then run another parsec parser over that list of tokens
09:41:08 <Cale> rui1: It's quite safe
09:41:41 <rui1> While with flexible instances, a module with "instance C [a]:  might allow some user to do instance c [Char]  and screw you
09:41:57 <nshepperd> that's really a complexity list more than a safety list
09:42:23 <Cale> rui1: However, maybe in the future, people decide that class associated types are better than fundeps and support for that extension eventually gets dropped? (I think that's pretty unlikely, but more likely than anything too devastating happening to GADTs)
09:42:41 <idem-pyon-tent> tdammers: Then using laziness, I could guarantee that the lexer only produces as many lexemes as the parser needs at that moment? Or would I have to store the entire list of lexemes before I can feed it to the parser?
09:42:59 <tdammers> idem-pyon-tent: of course you can exploit laziness here
09:43:17 <tdammers> lex :: String -> [Token]
09:43:28 <tdammers> parse :: [Token] -> Document -- or whatever
09:44:13 <rui1> Cale: I see, that makes sense. Associated types are the same as type families? I'll have to read on that
09:45:11 <dolio> Cale: They are better. But fundeps would probably stay around because they're syntactically nice for a lot of things.
09:45:13 <idem-pyon-tent> rui1: Associated types are type families that are "stuck inside a type class".
09:45:18 <Cale> dolio: I agree
09:45:18 <dolio> Just work slightly differently than they do today.
09:47:43 <sgronblo> Also quickcheck is so cool
09:48:47 <dolio> Cale probably means type families really, though, because plain associated types don't cover everything you can do with fundeps.
09:49:27 <rui1> idem-pyon-tent: thanks
09:49:59 <f|`-`|f> fundeps?
09:50:45 <glguy> fundeps : https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#functional-dependencies
09:51:37 <f|`-`|f> and associated types?
09:51:59 <f|`-`|f> wait no
09:52:01 <f|`-`|f> I can read
09:52:06 <f|`-`|f> but type family?
09:52:46 <glguy> associated types are type families associated with a class definition
09:54:44 <f|`-`|f> Can I retract my earlier question, and emphasise my confusion about type families. Are they just functionally (ie, a duck is a waterfowl, like a swan) similar types
09:54:53 <f|`-`|f> float to double?
09:55:32 <Saizan> f|`-`|f: a type family is a function from types to types
09:56:23 <f|`-`|f> that's somewhat of a misnomer to me
09:56:39 <f|`-`|f> So an associated function is (+)
09:57:15 <Saizan> i guess, though we call those methods
09:57:18 <prsteele> Question about laziness. Let's suppose I have a list xs with 'expensive' elements. If I do something like `f (zip xs (tail xs))`, so I perform the expensive computations once or twice?
09:57:34 <Saizan> prsteele: once
09:57:56 <f|`-`|f> tail (a:as) = as
09:58:10 <f|`-`|f> I don't think tail is that expensive
09:58:12 <prsteele> Saizan: thanks. Follow up: is there any way to have figured this out (without asking) without, e.g., inspeting the generated code?
09:58:38 <mniip> prsteele, Debug.Trace
09:59:00 <prsteele> mniip: Thanks!
09:59:31 <kadoban> prsteele: Well, you can kinda know based on the definition of lists. Like since (x:xs) and (xs) share just about all of their elements, it'd be pretty hard for haskell /not/ to share them. So intuition should suggest it at least.
09:59:49 <sgronblo> How do I fail a parser that still has unparsed input?
10:00:02 <f|`-`|f> haskell likes to memoise, afaik
10:00:21 <f|`-`|f> with or without destroying the output?
10:00:50 <mniip> f|`-`|f, not so much memoisation rather never evaluating a value twice
10:01:12 * f|`-`|f shrugs hard?
10:01:31 <f|`-`|f> That's sort of depreciative of other languages :^)
10:01:48 <EvanR> what?
10:01:52 <f|`-`|f> Not really
10:02:15 <hodapp> what?
10:02:39 <f|`-`|f> Can I register :^) as the crap sarcasm face
10:02:53 <mniip> already recognized as such
10:03:04 <EvanR> memoization is saving the outputs of a function and reusing them when the same input is requested. lazy evaluation suspends a computation in a thunk until something needs it
10:04:18 <mniip> f|`-`|f, if I recall correctly GHC has no means of memoization other than trying to remove the duplicate closures at compile time
10:04:34 <f|`-`|f> neat
10:05:56 <hodapp> referential transparency for the win
10:06:06 <prsteele> I'm 'memoizing' by storing function calls inside an array, which is where this question came from
10:06:49 <kallisti> is there any consensus on naming identifiers in Haskell that contain acronyms?
10:07:08 <f|`-`|f> as long as you will remember what they are
10:07:20 <f|`-`|f> which means "is it legible to other people", usually
10:07:27 <mniip> prsteele, pretty good choice
10:07:49 <HeladoDeBrownie> kallisti, i'd say treat the acronym as you would a normal word, e.g., performHttpRequest
10:07:52 <mniip> btw
10:07:58 <f|`-`|f> All I know is that arrays can do things laser fast
10:08:06 <mniip> is Data.Array actually an array?
10:08:09 <EvanR> yes
10:08:14 <mniip> the api makes it look like it's not
10:08:16 <EvanR> i love it when that happens
10:08:42 <EvanR> mniip: well, theres an array, but the indexes are mapped for you
10:09:02 <EvanR> so 2D coords etc make sense even if the underlying array isnt literally 2d, which it ... isnt
10:09:37 <mniip> it can be a 2d array in memory
10:09:46 <EvanR> memory is 1D
10:09:47 <mniip> ram chips are grids :^)
10:09:54 <EvanR> i was just thinking about the 2d chips
10:10:00 <f|`-`|f> How would you organise the memoised function call ins a roughly infinite array?
10:10:02 <EvanR> dont get confused
10:10:14 <mniip> f|`-`|f, a list probably?
10:10:35 <f|`-`|f> :v
10:10:39 <EvanR> memoization works for infinite domains
10:10:43 <f|`-`|f> then what's the point of an array?
10:10:54 <prsteele> arrays offer constant time lookup
10:10:56 <prsteele> lists require linear time
10:10:58 <mniip> ^
10:11:49 <EvanR> lists have constant time lookup if the lists length is fixed ;)
10:12:06 <EvanR> (like arrays)
10:12:32 <mniip> huh
10:12:34 <f|`-`|f> so
10:12:41 <f|`-`|f> what of infinite arrays
10:12:49 <mniip> you need to patternmatch N nodes
10:12:54 <mniip> O(N)
10:12:59 <EvanR> N is a constant
10:13:03 <EvanR> O(1)
10:13:08 <mniip> ah
10:13:10 <mniip> right
10:13:19 <mniip> wait no
10:13:22 <EvanR> lol
10:13:22 <f|`-`|f> This Big O crap seems to be a lower bounds
10:13:30 <mniip> N goes from 1 to n
10:13:33 <f|`-`|f> which feels wrong
10:13:41 <venice> i'm trying to compile with -fllvm but i'm getting compilation errors even on a "hello world" example as soon as I also add -O2; i'm on latest OsX using homebrew-installed llvm. Should I used some other llvm version maybe?
10:13:49 <EvanR> mniip: well take the worst case
10:13:50 <f|`-`|f> what if if goes from 1 to log n, mniip 
10:14:10 <EvanR> mniip: o(min(n, N)) if you will
10:14:18 <ersran9> hello, could someone explain why the type family version is failing? http://lpaste.net/124492
10:14:18 <mniip> EvanR, for any fixed n, time is bounded
10:14:23 <mniip> but as n grows,
10:14:27 <f|`-`|f> there are about 6 O's
10:14:30 <f|`-`|f> omicron
10:14:32 <f|`-`|f> O
10:14:34 <f|`-`|f> omega
10:14:39 <f|`-`|f> fug
10:14:52 <mniip> zero
10:14:55 <mniip> the octonion set
10:15:53 <EvanR> > nub ['o', 'о', 'ο']
10:15:55 <lambdabot>  "o\1086\959"
10:16:12 <EvanR> dont get confused
10:16:13 <EvanR> lol
10:16:40 <prsteele> > show (nub ['o', 'о', 'ο'])
10:16:41 <lambdabot>  "\"o\\1086\\959\""
10:16:48 <prsteele> damn, still nonsense on my screen
10:16:52 <EvanR> > text $ nub ['o', 'о', 'ο']
10:16:53 <lambdabot>  oоο
10:17:05 <f|`-`|f> amazing nubbing
10:17:12 <friden> woot
10:17:18 <f|`-`|f> :t nub
10:17:19 <EvanR> prsteele: thats anyones screen you should see number
10:17:19 <lambdabot> Eq a => [a] -> [a]
10:17:26 <f|`-`|f> :t text
10:17:27 <lambdabot> String -> Doc
10:17:28 <hodapp> :t nub
10:17:29 <lambdabot> Eq a => [a] -> [a]
10:18:01 <f|`-`|f> Isn't nub a poly time "remove all repeated elements"
10:18:09 <f|`-`|f> a noobish unique
10:18:15 <EvanR> i think its faster than that
10:18:24 <EvanR> @src nub
10:18:25 <lambdabot> nub = nubBy (==)
10:18:27 <f|`-`|f> it was O (n^2)
10:18:35 <f|`-`|f> that's pretty poly to me
10:18:40 <EvanR> you dont have to compare against all other elements
10:18:54 <f|`-`|f> @hoogle nub
10:18:56 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
10:18:56 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
10:18:56 <lambdabot> package pubnub
10:18:58 <EvanR> @src nubBy
10:18:59 <lambdabot> nubBy eq []     = []
10:18:59 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:19:00 <mmachenry> f|`-`|f: I think nub requires the list to be sorted.
10:19:12 <mniip> > text $ nub ['o', 'о', 'ο', 'о']
10:19:14 <lambdabot>  oоο
10:19:15 <prsteele> > nub [1, 2, 3, 1, 2, 3]
10:19:16 <lambdabot>  [1,2,3]
10:19:18 <mniip> ah
10:19:19 <mmachenry> > nub [1,1,1,2,2,2,1]
10:19:20 <EvanR> nub doesnt
10:19:21 <lambdabot>  [1,2]
10:19:22 <mniip> already included
10:19:24 <f|`-`|f> I see no sorting there, mmachenry 
10:20:05 <mmachenry> Oh hm… it doesn't. It removes the element even if it's not next to it. Maybe I'm thinking of group that requires sorting?
10:20:07 <EvanR> in the implementation its comparing against a sorted set at each step, with less and less in it
10:20:10 <ReinH> It is O(n^2) though
10:20:14 <mmachenry> > group [1,1,1,2,2,2,1]
10:20:16 <lambdabot>  [[1,1,1],[2,2,2],[1]]
10:20:18 * hackagebot waitra 0.0.2.0 - A very simple Wai router  http://hackage.haskell.org/package/waitra-0.0.2.0 (phadej)
10:20:19 <EvanR> i mean, filtered
10:20:24 <mmachenry> Yeah it's group I was thinking of.
10:20:34 <f|`-`|f> it filters per unique item
10:20:42 <f|`-`|f> which at worst is a filter for every element
10:20:43 <EvanR> still faster than the naive algorithm
10:20:49 <f|`-`|f> which is a traverse per element
10:20:49 <EvanR> most of the time
10:21:03 <f|`-`|f> which tends towards poly
10:21:10 <ReinH> EvanR: I don't think it does
10:21:17 <ReinH> It doesn't do any filtering
10:21:29 <EvanR> eh?
10:21:34 <f|`-`|f> time to go to wikipedia to look up what big o is
10:21:37 <ReinH> nub doesn't do any filtering
10:21:48 <f|`-`|f> @src nub
10:21:48 <lambdabot> nub = nubBy (==)
10:21:49 <EvanR> in the real implementation?
10:21:51 <ReinH> Yes.
10:21:53 <f|`-`|f> @src nubBy
10:21:53 <lambdabot> nubBy eq []     = []
10:21:53 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:21:54 <EvanR> :(
10:22:03 <f|`-`|f> really seems like it filters, ReinH 
10:22:07 <ReinH> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-List.html#nub
10:22:09 <ReinH> f|`-`|f: It doesn't.
10:22:15 <S11001001> ersran9: what do you get with :kind TF ?
10:22:31 <ReinH> With an Ord constraint you could use a Set and get better asymptotics
10:22:48 <mmachenry> Says it's O(n^2) in the docs.
10:22:52 <ReinH> It is.
10:22:59 <f|`-`|f> nub = nubBy (==) = x : nubBy (==) (filter (\ y -> not ((==) x y)) xs)
10:23:03 <f|`-`|f> And this is source
10:23:07 <ReinH> f|`-`|f: That's not the actual source, no
10:23:08 <ersran9> S11001001, I'm getting TF :: * -> Constraint
10:23:10 <EvanR> i guess only if USE_REPORT_PRELUDE if set
10:23:11 <f|`-`|f> fuck
10:23:11 <ReinH> My link is the actual source
10:23:36 <ReinH> EvanR: right
10:23:43 <ReinH> Which isn't, generally speaking.
10:23:57 <f|`-`|f> that definition seems worse
10:23:57 <JoshieAS> so `head` is a "partial function" and I shouldn't use it?
10:23:59 <EvanR> whats up with that other implementation, is it better?
10:24:07 <ReinH> JoshieAS: generally you should avoid it
10:24:10 <f|`-`|f> ^
10:24:13 <JoshieAS> alternative?
10:24:17 <ReinH> JoshieAS: pattern matching
10:24:22 <f|`-`|f> ^
10:24:26 <hodapp> JoshieAS: pattern-match and handle the empty case explicitly?
10:24:28 <JoshieAS> oh yeah like (x:xs) and shiat
10:24:44 <f|`-`|f> (a:as) /= [a] /= []
10:24:46 <JoshieAS> y'all are great, love you
10:25:07 <f|`-`|f> and those are the three patterns that matter within a list
10:25:21 <EvanR> [a] is redundant
10:25:26 <S11001001> ersran9: I'm surprised you're allowed to use an unapplied synonym in that way
10:25:32 <f|`-`|f> ur mom
10:25:35 <hodapp> ...
10:25:40 <f|`-`|f> so [a] = a:[]
10:25:42 <JoshieAS> haha
10:26:18 <ersran9> S11001001, Oh! is this that bug that is present in 7.8.3 - partial application of type families?
10:26:27 <ersran9> I mean, ghc letting me do that
10:29:44 <ersran9> https://ghc.haskell.org/trac/ghc/ticket/10054 eh? completely left my mind that I was partially applying type synonyms. Thanks a lot S11001001! 
10:30:26 <kadoban> This is probably a dumb question, but why does filterM require Monad, when in the nicta course I did the same thing on Applicative ? Is there a filterA I'm missing? After the AMP, will filterM be kinda outdated?
10:31:24 <sgronblo> Did somebody already explain how to fail a parser if it it still has unparsed input?
10:31:37 <mpickering> I think the type of filterM will become as you suggest
10:31:39 <HeladoDeBrownie> kadoban, i don't think it's possible to implement filterM exactly as-is using just Applicative
10:31:46 <S11001001> ersran9: no worries
10:31:48 <HeladoDeBrownie> kadoban, feel free to prove me wrong!
10:32:09 <mpickering> sgronblo: mzero?
10:32:11 <glguy> eof 07:: (Stream s m t, Show t) 07=> ParsecT s u m ()
10:32:26 <S11001001> ersran9: was on my mind because tnks and johnw were discussing partial application of synonyms ~13hrs ago
10:32:42 <glguy> sgronblo: You can use the eof combinator for parsers that expect to reach the end of a file
10:32:44 <S11001001> ersran9: and thanks for the link
10:33:04 <ersran9> S11001001, :)
10:33:05 <kadoban> HeladoDeBrownie: Hmm, let me try then and see what/if-anything goes wrong.
10:33:07 <sgronblo> Ah so just parse an eof at the end
10:33:09 <sgronblo> Lets try
10:33:40 <HeladoDeBrownie> kadoban, it would be sufficient to show what you implemented in the course you mentioned, i imagine
10:33:50 <sgronblo> Is eof some new fangled thing?
10:35:01 <lpaste> kadoban pasted “filtering” at http://lpaste.net/124494
10:35:06 <kadoban> HeladoDeBrownie: Well, I did but I'm not sure if their stuff has some subtle difference that makes it possible. In nicta it's just…that ^
10:35:22 <sgronblo> oops, didnt have text.parsec.combinator imported
10:35:36 <Denommus> what do I use to have a parallel filter?
10:35:49 <HeladoDeBrownie> kadoban, hmm, yeah, that does look suspiciously similar to filterM
10:35:55 <Cale> Denommus: what do you mean by that?
10:35:57 <sgronblo> Whee, it works. Thanks mpickering and glguy.
10:36:40 <Denommus> Cale: I have a list, and I want to produce a new list filtered from it, and I want the filter functions to run in parallel
10:37:23 <tnks> S11001001: actually, thinking about limitations with partial application. . . do you find yourself using type synonyms much at all?
10:37:29 <kadoban> Okay cool, makes sense then I think. Thanks both.
10:37:38 <HeladoDeBrownie> kadoban, ah, i figured out the flaw in my reasoning for not thinking it possible. i was thinking the Bool would not be useable for some reason.
10:38:10 <kadoban> Ahh, right. It took me like 2 days to actually figure out how to write that function, so I don't blame you XD
10:38:11 <S11001001> tnks: yeah, I like them.  I probably write more data and newtypes than synonyms, though.
10:38:17 <tnks> k.
10:38:44 <tnks> it's just for all the scenarios I have in my mind, newtypes+generalized-deriving seems more what I'd prefer.
10:39:05 <tnks> maybe at some point it's just style?
10:40:09 <Cale> Denommus: Probably use something like  map snd . parListChunk n (evalList (\(x,y) -> rseq y)) $ [(x,p x) | x <- xs]
10:40:19 * hackagebot validate-input 0.2.0.0 - Input validation combinator library  http://hackage.haskell.org/package/validate-input-0.2.0.0 (AlexanderThiemann)
10:40:43 <Cale> Denommus: If the predicate is really expensive, you could probably get by just using parMap
10:41:13 <Cale> Oh, and I meant map fst . filter snd . ...
10:42:36 <Denommus> Cale: what if it's the list that's too big?
10:43:36 <Cale> Denommus: hm?
10:43:38 <glguy> kadoban: I added an implementation of filterA to your paste earlier. It ends up being the same as your just with a different look if you're interested
10:43:39 <sgronblo> This was cool. Now my roman numeral converter works (using parsec). Verified by QuickCheck.
10:44:11 <Cale> Denommus: Lists are in order. You can't necessarily skip forward to the nth element of a list cheaply. Think of a list as a loop that is waiting to happen.
10:44:12 <Denommus> Cale: forget it. I'm probably using the wrong strategy in my algorithm
10:44:39 <sgronblo> And suddenly it was 2:41 AM...
10:45:00 <Cale> If you needed to skip forward to the nth element of your list (say to be able to spark the evaluation beyond that point in parallel), then it was wrong to put the elements in a list in the first place.
10:45:05 <funfunctor> what is the mathematical picture of Foldable? monoid or?
10:45:10 <mtottenh> Is there a way to pretty print user defined data types? (other than just calling print on a type which derives Show)
10:45:51 <funfunctor> mtottenh: yes there is a pretty print package
10:45:55 <kadoban> glguy: Ah, yes thank you. I like that, much more readable.
10:46:08 <Cale> funfunctor: Foldable doesn't really correspond to anything nice mathematically
10:46:33 <funfunctor> mtottenh: you should avoid using Show instances to do any kind of pretty printing. Also you could write a function that takes your type to a string
10:46:58 <funfunctor> Cale: ah ok, what is a short and sweet way to remember it then?
10:47:00 <Cale> funfunctor: In some cases, you could express it as endofunctors which have a specified natural transformation to the list endofunctor.
10:47:13 <Cale> i.e. it's data types T which have a toList :: T a -> [a]
10:47:13 <funfunctor> ok
10:47:26 <funfunctor> ok perfect
10:48:36 <shachaf> Cale: Except Foldable doesn't have a Functor superclasss. And its operation isn't *quite* toList.
10:49:37 <Cale> shachaf: right, that's why I said "in some cases"
10:49:45 <funfunctor> mtottenh: http://hackage.haskell.org/package/pretty  or just go with the function :: X -> String with a pattern match for a simple method
10:50:27 <Cale> Its operations in any case factor through toList, but sometimes perform better than they would if you wrote them that way.
10:50:55 <shachaf> Not quite, in the case of infinite trees with unusual shapes.
10:51:16 <shachaf> For instance you can have a "list" which is infinite on the left instead of on the right.
10:51:20 <breadmonster> Cale: Can I use Text as a drop in replacement for String?
10:51:30 <breadmonster> shachaf: How do you do that?
10:51:31 <shachaf> Or infinite in the middle.
10:51:41 <funfunctor> really could do with a hand with some of this project, why can't programmers have more spare time .. :p
10:52:12 <HeladoDeBrownie> breadmonster, the short answer is no, they have different purposes. what's the purpose you want to use Text for?
10:52:31 <mtottenh> funfunctor: Thanks
10:53:36 <breadmonster> HeladoDeBrownie: Writing a toy compiler.
10:53:46 <breadmonster> Thought I'd make the string type a wrapper for text.
10:53:51 <HeladoDeBrownie> breadmonster, be more specific
10:53:59 <HeladoDeBrownie> how are you going to use the Text?
10:54:14 <Cale> shachaf: And you can distinguish that with a monoid that actually satisfies the monoid laws?
10:54:29 <shachaf> Sure. First and Last, for instance.
10:54:41 <breadmonster> `string x = "hello world"` in my toy language will be represented internally as a Text object.
10:54:48 <breadmonster> HeladoDeBrownie: Like Integer and GMP.
10:54:59 <Cale> Ah, okay, Last
10:55:03 <Cale> fair enough
10:55:17 <shachaf> Everything https://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html does
10:55:20 * hackagebot broccoli 0.2.0.0 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.2.0.0 (evanrinehart)
10:55:22 * hackagebot broccoli 0.2.0.1 - Small library for interactive functional programs.  http://hackage.haskell.org/package/broccoli-0.2.0.1 (evanrinehart)
10:55:27 <HeladoDeBrownie> breadmonster, that's still kind of vague, but sounds like it should be okay.
10:56:01 <HeladoDeBrownie> breadmonster, do you know the basics of unicode text?
10:56:53 <funfunctor> I can't believe how well pipes is documented
10:57:06 <funfunctor> Seriously, who does that ! Stunning !
10:57:18 <HeladoDeBrownie> funfunctor, Gabriel Gonzalez aka Tekmo :)
10:57:29 <hodapp> perhaps I should learn about pipes!
10:57:50 <funfunctor> Gabriel is king !
10:58:01 <breadmonster> HeladoDeBrownie: So I'm writing a toy scripting language. I'd like to build string handling operations into the runtime. Like perl say?
10:58:11 <breadmonster> So that it's not totally useless.
10:58:21 <Cale> shachaf: Yeah, that's a better universal representation, I guess
10:58:26 <HeladoDeBrownie> breadmonster, okay, Text should be an appropriate choice for that.
10:58:40 <breadmonster> HeladoDeBrownie: So that means that I'd like a fast data type. String just doesn't cut it.
10:59:13 <shachaf> Cale: Well, it's certainly suitable for Foldable, because it's exactly the return type of foldMap.
10:59:14 <HeladoDeBrownie> breadmonster, i'd say the problem with String is less that it may be slow (i don't know) but more that it may not be correct for how it's used.
10:59:31 <funfunctor> There should be a rule; building a compiler? produce llvm..
10:59:39 <breadmonster> HeladoDeBrownie: It's very space-inefficient, iirc.
10:59:42 <EvanR> long Strings can be really bad depending on what you do to them
10:59:43 <breadmonster> funfunctor: Why?
10:59:47 <shachaf> The fact that it's the free monoid in Haskell, rather than [], is a bit annoying.
11:00:34 <EvanR> breadmonster: Text is probably a good default implementation for any String type
11:00:49 <breadmonster> EvanR: Over ByteString?
11:01:01 <EvanR> well, bytestring is a different thing entirely
11:01:07 <HeladoDeBrownie> breadmonster, Text and ByteString are for different things. if it's unicode text you want to represent, use Text
11:01:14 <HeladoDeBrownie> (if it's strings of bytes, use ByteString :P)
11:01:37 <EvanR> usually "string" means "text", of course there are some confusing exceptions in some languages
11:01:46 <EvanR> PHP
11:02:01 <HeladoDeBrownie> ah, right, php inherits its concept of strings from c, right? so it's… arrays of bytes then?
11:02:11 <EvanR> its a bytestring
11:02:16 <EvanR> with a bunch of text functions on it
11:02:23 <breadmonster> Yeah, sorry, I was thinking of C :P
11:02:24 <funfunctor> breadmonster: Genesis 11:7 "Come, let Us go down and there confuse their language, so that they will not understand one another's compiler IR"
11:02:37 <EvanR> breadmonster: C doesnt have strings, it has char* ;)
11:03:14 <HeladoDeBrownie> char is not chars either, it's bytes
11:03:20 <breadmonster> EvanR: Hahaha
11:04:06 <HeladoDeBrownie> that's why you have this "wide string" mess in addition, because char* doesn't cut it
11:04:24 <hodapp> wide strings + C++ faux-OOP + Microsoft APIs = :(((((
11:04:38 <hodapp> never again
11:05:07 <HeladoDeBrownie> i've messed with those first two a little bit (ncurses and gobject respectively) but never the last, and don't care to
11:05:44 <hodapp> "We use 16-bit characters instead of 8-bit characters because they're fixed-width, which simplifies a bunch of the code." "But UTF16 is NOT fixed-width." "We use 16-bit characters because it simplifies a bunch of the code."
11:05:56 <hodapp> "But it DOESN'T simplify the code one bit, because we have to do ugly conversions everywhere we interface with network APIs or files." "Shut up."
11:06:07 <jarvi> I have trouble loading hmatrix module in Windows. I was able to build hmatrix-0.16.0.6, but when cabal is loading it, it complains about unknown symbol __asinh. ( GHC 7.6.3 x86, cabal-install 1.18.0.8 ). What to do?
11:06:51 <HeladoDeBrownie> hodapp, seems kind of like a strawman argument to me; i mean, there are technical decisions made in any language that people later find out are mistakes
11:06:53 <HeladoDeBrownie> even in haskell
11:07:01 <tommd> jarvi: What about a more recent version of hmatrix?
11:07:17 <jarvi> tommd, I got some other error with the latest :/
11:07:31 <tommd> That might be the more interesting case to tackle.
11:07:39 <jarvi> tommd, I'll check.
11:08:25 <hodapp> HeladoDeBrownie: it is a non-trivial benefit that at this job I have not had to touch C++, Visual Studio, or a single Microsoft API even once.
11:08:40 <HeladoDeBrownie> hodapp, good for you
11:08:57 <hodapp> have to work with C, but that's manageable
11:09:07 <EvanR> livin the dream
11:09:12 <HeladoDeBrownie> there's a nonzero chance that one day i'll be working with javascript again but that can be… managed
11:09:24 <hodapp> HeladoDeBrownie: ghcjs, Faye, Haste :)
11:09:29 <HeladoDeBrownie> yep. also purescript
11:09:34 <hodapp> looks nice
11:10:32 <jarvi> tommd, hmatrix-0.16.1.4 doesn't even install. It says (among other errors and warnings): src\C\vector-aux.c:766:5: error: 'int32_t' undeclared (first use in this function)
11:11:07 <tommd> jarvi: So I'd fix that first.  int32_t is in stdint.h on most platforms.
11:11:45 <jarvi> tommd, ok. I might take a look tomorrow. Thanks.
11:11:50 <tommd> javrvi:  src/C/vector-aux.c line 12, add '#include <stdint.h>'
11:11:58 <tommd> jarvi: Ok, good luck.
11:17:29 <tommd> jarvi: I've sent a pull request to the project fixing this issue.  Feel free to give it a test and remember github issue tracker would, in this case, be a great venue for any issues you run into.
11:21:33 <Fr5n> @pl \x y -> (x + y)^2
11:21:33 <lambdabot> flip flip 2 . ((^) .) . (+)
11:27:04 <ab9rf> pointfree is called pointless for a reason
11:28:33 <HeladoDeBrownie> @type flip flip
11:28:34 <lambdabot> b -> (a -> b -> c) -> a -> c
11:28:38 <HeladoDeBrownie> amazing
11:30:20 <arkeet> @type (flip .)
11:30:21 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
11:30:25 <arkeet> @type (flip .) . flip
11:30:26 <lambdabot> (a1 -> a -> b -> c) -> a -> b -> a1 -> c
11:30:30 <arkeet> @type (flip .) . flip . (flip .)
11:30:31 <lambdabot> (a1 -> b -> a -> c) -> a -> b -> a1 -> c
11:36:47 <f|`-`|f> :t (flip flip) .
11:36:48 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:36:53 <f|`-`|f> :t (flip flip) (.)
11:36:54 <lambdabot> (a -> ((b -> c1) -> (a1 -> b) -> a1 -> c1) -> c) -> a -> c
11:37:00 <f|`-`|f> Mine's longer
11:37:44 <f|`-`|f> :t flip (.) (flip flip) (.)
11:37:45 <lambdabot> a -> (a2 -> a1 -> a -> c) -> a2 -> a1 -> c
11:38:57 <Enl> :t flip ((.)(.))
11:38:58 <lambdabot> b -> (b -> b1 -> c) -> (a -> b1) -> a -> c
11:40:02 <f|`-`|f> :t (.).(.)
11:40:03 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:40:31 <f|`-`|f> :t (.).(.) (-) (+)
11:40:31 <lambdabot> (Num (a -> a), Num a) => a -> (a1 -> a -> a) -> a1 -> a -> a
11:40:39 <f|`-`|f> :t (.).(.) (-) (+) 1
11:40:40 <lambdabot> (Num (c -> c), Num c) => (c -> c) -> (a -> c) -> a -> c
11:40:47 <f|`-`|f> :t (.).(.) (-) (+) 1 2
11:40:48 <lambdabot> (Num ((b -> c) -> b -> c), Num (b -> c)) => (b -> c) -> (a -> b) -> a -> c
11:41:07 <f|`-`|f> :t (.).(.) (-) (+) 1 2 3
11:41:08 <lambdabot> (Num ((a -> b -> c) -> a -> b -> c), Num (a -> b -> c)) => a -> (a1 -> b) -> a1 -> c
11:41:12 <clrnd> ok
11:43:06 <frerich> This may seem dull, but after considering what ghci gave me for ‘:i Foldable’ and ‘:i Traversable’ and then reading https://wiki.haskell.org/Foldable_and_Traversable I do wonder - does anybody know whether there are types for which there are plausible instances of Foldable but not Traversable?
11:43:28 <dolio> frerich: Set.
11:43:33 <bennofs> frerich: data Repeat a = Repeat Int a
11:43:47 <bennofs> frerich: where the Foldable instance repeats a the given number of times
11:44:51 <bitraten> tomjaguarpaw: Is there already json field support in opaleye?
11:45:27 <frerich> dolia: Hm! Set is a compelling example; I know how it cannot be a Functor, but I guess I should re-read about Traversable to see why Set wouldn’t work with that.
11:45:40 <dolio> It's the same reason as Functor.
11:45:52 <bennofs> frerich: Traversable allows to implement Functor
11:46:11 <bennofs> frerich: so anything that cannot be a Functor can't be a Traversable either
11:46:27 <bennofs> :t Data.Traversable.fmapDefault
11:46:28 <lambdabot> Traversable t => (a -> b) -> t a -> t b
11:47:53 <frerich> Oh, so Traversable is ‘shape-preserving’ like Functor? Ah, re-reading the Data.Traversable docs I see that indeed Functor is a, uhm, base class? Super class? Not sure what the right term is.
11:48:37 <HeladoDeBrownie> frerich, superclass, yeah
11:48:41 <bennofs> :t runIdentity . traverse (Identity . f)
11:48:42 <lambdabot> (FromExpr b, Traversable t, Show a) => t a -> t b
11:48:48 <bennofs> :t \f -> runIdentity . traverse (Identity . f)
11:48:49 <lambdabot> Traversable t => (a -> b) -> t a -> t b
11:49:17 <frerich> dolio, bennofs: Alright, thanks guys! It’s clear to me now :)
11:50:22 * hackagebot snap 0.14.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0 (DougBeardsley)
11:51:46 <Enl> frerich: don't all functors preserve the structure though?
11:52:02 <Enl> I guess it depends on what the structure is :)
11:52:11 <frerich> Enl: Yes *functors* do, I just didn’t realize that Traversable inherits this requirement.
11:53:59 <HeladoDeBrownie> Enl, just what it means to preserve the structure is encoded in the type and laws of fmap
11:54:43 <Enl> HeladoDeBrownie: is "shape" a "structure" synonym or does it mean something else?
11:54:59 <HeladoDeBrownie> Enl, i don't think either is quite a precise term.
11:55:23 * hackagebot pretty 1.1.3.1 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.3.1 (DavidTerei)
11:55:24 <Enl> I guess identity and compostition is a structure in a mathematical sense
11:55:38 <HeladoDeBrownie> yes, the structure in question is that of the category
11:56:00 <HeladoDeBrownie> but there are other structures that can be preserved; see group homomorphisms for another example
11:57:03 <clrnd> but Data.Set has a `map` funciton, I don't see why it isn't a Functor :/
11:57:21 <HeladoDeBrownie> clrnd, because haskell's Functor typeclass isn't expressive enough to permit things like the Ord constraint
11:57:57 <clrnd> HeladoDeBrownie, oh, just that? lol
11:58:03 <HeladoDeBrownie> yep, just that :)
11:58:27 <HeladoDeBrownie> oh, actually
11:58:41 <HeladoDeBrownie> wait never mind. was thinking it might violate a law but what i was thinking of wasn't a violation
11:58:45 <HeladoDeBrownie> it still might, i just haven't checked
11:59:09 <clrnd> HeladoDeBrownie, I checked a little, they seemed to hold, but maybe out of chance
11:59:18 <Hijiri> there was a discussion before, it seemed to hold
11:59:20 <HeladoDeBrownie> what do you mean "out of chance"?
11:59:29 <Hijiri> as long as you didn't introduce the possibility of broken Ord
11:59:45 <HeladoDeBrownie> Hijiri, e.g., things comparing equal when they're not?
11:59:54 <Hijiri> yeah, things like that
11:59:55 <quchen> Hijiri: If you have Ord that's not ordering you might as well have a Functor that's not functoring
12:00:38 <Hijiri> right, I guess then that's not an issue
12:01:21 <clrnd> exactly
12:01:37 <Hijiri> wouldn't be a Functor over Float or Double though
12:02:04 <quchen> Hm?
12:02:11 <Hijiri> actually, I'm not sure
12:02:15 <Hijiri> > compare NaN 5
12:02:16 <lambdabot>  Not in scope: data constructor ‘NaN’
12:02:24 <Hijiri> > compare (0/0) 5
12:02:26 <lambdabot>  GT
12:02:30 <Hijiri> > compare 5 (0/0)
12:02:32 <lambdabot>  GT
12:02:46 <HeladoDeBrownie> easy solution, never use floating point
12:02:58 <quchen> Yeah, right.
12:03:02 <HeladoDeBrownie> :D
12:03:03 <f|`-`|f> > compare 5 (1/0)
12:03:04 <geekosaur> yes, Float and Double (IEEE floating point) break Ord and therefore Map (and Set)
12:03:05 <lambdabot>  LT
12:03:19 <f|`-`|f> Hijiri  I think it tihnks that 0/0 is one
12:03:29 <quchen> No, it's NaN.
12:03:35 <geekosaur> NaN is non-comparable
12:03:36 <f|`-`|f> > compare 0 (0/0)
12:03:37 <lambdabot>  GT
12:03:44 <f|`-`|f> > compare 0 (1/0)
12:03:45 <lambdabot>  LT
12:03:53 <geekosaur> technically NaN isn't even Eq
12:03:58 <f|`-`|f> > compare (-0) (0/0)
12:04:00 <lambdabot>  GT
12:04:00 <clrnd> > 0/0
12:04:00 <Hijiri> if 0/0 was 1 then compare (0/0) 5 would have been LT
12:04:02 <lambdabot>  NaN
12:04:31 <f|`-`|f> how is 5 gt 0/0 but not 1/0
12:04:43 <tristanp> So is haskell in utter anarchy when it comes to how many spaces to indent by? It seems like every book or library i use has its own idea, with 2, 3, 4 and 6 all being seen
12:04:44 <Hijiri> 1/0 is infinity
12:04:48 <Hijiri> > 1/0
12:04:49 <lambdabot>  Infinity
12:05:02 <clrnd> > compare 1/0 1/0
12:05:03 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a -> GHC.Types.Ordering))
12:05:03 <lambdabot>    arising from the ambiguity check for ‘e_11010’
12:05:03 <lambdabot>  from the context (GHC.Classes.Ord a,
12:05:05 * geekosaur would repeat what he just said, but if it was ignored the first time...
12:05:14 <clrnd> > compare (1/0) (1/0)
12:05:15 <lambdabot>  EQ
12:05:18 <Hijiri> tristanp: seems like whatever indentation is fine as long as it's readable
12:05:29 <clrnd> > compare (1/0) (-1/0)
12:05:30 <lambdabot>  GT
12:05:31 <clrnd> :D
12:05:34 <tristanp> so utter anarchy. ok i guess...
12:05:40 <frerich> I think it’s plain glorious to realize how many useful functions can be defined in terms of fold. I knew similiar functions (e.g. ‘reduce’ in Python) for years but never realized their potential until I learned about Haskell.
12:05:43 <geekosaur> tristanp, you're a pythonist, right?
12:05:51 <tristanp> javascript actually
12:06:00 <tristanp> there isn't a standard there either
12:06:11 <tristanp> i was hoping there would be one in haskell but ah well it's not a big deal
12:06:14 <geekosaur> I've never heard of JS having a Thou Shalt Indent Exactly This Way
12:06:17 <monochrom> only a communist will say that free will, private property, and free choice of indentation are utter anarchy
12:06:20 <geekosaur> that's more a python thing
12:06:31 <tristanp> i know. I only wish there was one, but I'm not used to it
12:06:48 <tristanp> white space gets ignore for the most part in js so it's actually more understandable
12:06:59 <geekosaur> haskell does have some fairly hard indentation rules via layout. which almost guarantees that people will be loose anywhere they can >.>
12:07:15 <geekosaur> because people
12:07:41 <clrnd> frerich, I know! read this: https://www.cs.nott.ac.uk/~gmh/fold.pdf
12:08:55 <enthropy> tristanp: nobody uses 1 or 5 space indents?
12:09:09 <tristanp> enthropy: not that i've seen
12:09:21 <tristanp> which thank god
12:09:28 <monochrom> tibbe has a stye guide
12:09:52 <monochrom> https://github.com/tibbe/haskell-style-guide
12:10:12 <milli> indenting rules are for Python and Fortran punch card artists, but forced style (indenting) also makes code easier to deal with by the next programmer who has touch the code..
12:10:29 <monochrom> if you are a communist and want absolute directions, just use tibbe's style guide and be done with it
12:10:50 <guldfiskn> How do I accomplish what i'm trying to do at line 58-59 (which I have made into comment because obviously it doesnt work) http://lpaste.net/124509
12:11:10 <dolio> monochrom: But there are multiple style guides. :)
12:11:50 <monochrom> yeah, but that's what a communist doesn't want to hear
12:12:21 <Hijiri> what about libertarian socialists or syndicalists
12:12:31 <frerich> guldfiskn: You mean, printing multiple lines of text without ending up with a terribly long source code line? What I like to do is to use ‘putStrLn $ unlines [ … ]’ where the list elements are spread over multiple lines.
12:13:16 <guldfiskn> frerich: well, the code doesnt allow me to put a putStrLn at all there.. so thats's the only thing im trying to accomplish
12:13:31 <monochrom> anyway, to more horror for anti-anarchists, hackage doesn't host or recommend one single xml library either. it hosts many and doesn't single out any. it is up to your free will to choose one suitable for your job.
12:13:38 <guldfiskn> freirich: or just have it so that i ONLY print the maximum element of the list "points"
12:14:03 <tristanp> im just getting into haskell and i love that some of the functions have names like "unlines" which sound like Newspeak from 1984. Is it intentional?
12:14:18 <EvanR> lol
12:14:21 <clrnd> jajaja
12:14:32 <monochrom> I don't know. but you probably like unfoldr, too
12:14:36 <clrnd> we hatecode a lot too
12:14:57 <EvanR> should rename when to ununless
12:15:15 <tristanp> I can sort of role play that im wilson typing away doing some sort of newspeak thing when I get to occasionally use a function with a name like that
12:15:18 <clrnd> guldfiskn, so, what's the error when you putStrLn?
12:15:28 <geekosaur> well, if they'd really wanted to be cutesy, they'd have called it senil
12:15:33 <monochrom> oh! you will love this too
12:15:41 <monochrom> > let 2+2=5 in 2+2
12:15:43 <lambdabot>  5
12:15:48 <clrnd> :P
12:15:52 <EvanR> newmath
12:16:00 <clrnd> @let 2 + 2 = 5
12:16:00 <lambdabot>  .L.hs:153:20:
12:16:00 <lambdabot>      Ambiguous occurrence ‘+’
12:16:00 <lambdabot>      It could refer to either ‘L.+’, defined at .L.hs:154:3
12:16:25 <guldfiskn> clrnd: it's a loong error message but the top line is: Couldn't match expected type ‘IO [Int]’ with actual type ‘[a0]’
12:16:30 <geekosaur> someone put a definition of (+) in @let
12:16:37 <geekosaur> yesterday
12:16:43 <geekosaur> @undefine
12:16:43 <lambdabot> Undefined.
12:16:50 <frerich> tristanp: Hihi! One thing I liked was that the function for prependingan element to a list is sometimes called “cons” and the function for appending to a list is… “snoc” :o)
12:16:53 <clrnd> I think it was me, lol
12:17:13 <clrnd> that's from lisp though, iirc
12:17:19 <tristanp> frerich: did not know about the snoc thing, awesome
12:17:38 <EvanR> clrnd: we should have support for both definitions being established simultaneously
12:18:32 <clrnd> guldfiskn, `ask [] points = do { putStrLn "hi" ; return points }` is gonna work, what were you trying to do?
12:19:49 <frerich> guldfiskn: I think the idea of using ‘zipWith’ to keep track of how often each answer was given is quite creative, I would have never thought of that :-) However, it might have been easier to just collect all answers and at the end, determine which element occurs most often (seeing that your commented code suggests that only the most common answer is relevant anyway)
12:21:09 <clrnd> guldfiskn, on that point, yeah, you should try to separate pure from impure code
12:22:23 <guldfiskn> frerich: Hmm.. thanks! I'll see if I can implement that! :-D
12:23:21 <frerich> guldfiskn: Have fun! I’m positive it’ll end up pretty short, but I don’t want to spoil the fun. :-)
12:23:52 <guldfiskn> oh wait.. I realized another problem!
12:24:29 <guldfiskn> What if there is no maximum element? What if u answer equally on two alternatives
12:24:43 <frerich> guldfiskn: Just ask yourself
12:24:59 <frerich> guldfiskn: What would JK Rowling do?
12:25:07 <guldfiskn> frerich: Lol! :D
12:25:26 <guldfiskn> frerich: It would be fun to call the person a muggle! ;)
12:26:13 <monochrom> what would JK Rowling do?
12:26:39 <frerich> guldfiskn: I’m not sure, maybe the trick is to ask 4*n+1 questions or something such that there’s always a dominant answer.
12:34:38 <guldfiskn> frerich: How would one implement something in the code that will (if the maximum element is two (or even three)) so that the code will create a string line?
12:35:17 <guldfiskn> if the maximum element is two or even three equal elements * i.e. there is not one single maximum element
12:35:44 <tnks> okay, so if I didn't know what module "hoist" was in, how would I find it?
12:35:52 <tnks> Hoogle doesn't seem to have it indexed.
12:36:03 <clrnd> @google hoist hackage
12:36:04 <lambdabot> https://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html
12:36:17 <monochrom> you first have to find a single maximum. then you filter the original list for everyone who equals the found maximum.
12:36:39 <monochrom> filter (maximum your_list ==) your_list
12:36:53 <tnks> clrnd: so is googling the best way?
12:36:58 <monochrom> example:
12:37:08 <clrnd> tnks, oh I dunno, it's my way at least
12:37:29 <monochrom> > let mylist = [3,1,4,1,4,5,4] in filter (maximum mylist ==) mylist
12:37:31 <lambdabot>  [5]
12:37:39 <monochrom> oops, I guess the 5 ruins it
12:37:43 <tnks> clrnd: I'm okay with that. . . open to someone else that does it in a more direct way.
12:37:45 <monochrom> > let mylist = [3,1,4,1,4,2,4] in filter (maximum mylist ==) mylist
12:37:46 <levi> tnks: The hoogle at FPComplete includes more modules in the modules it searches by default.
12:37:47 <lambdabot>  [4,4,4]
12:38:41 <guldfiskn> monochrom: okay, so where do you mean that I should implement this in my code? 
12:38:59 <guldfiskn> http://lpaste.net/124536
12:39:45 <tnks> levi: cool, I was hoping for an answer like tht.
12:39:56 <tnks> I forget that FPComplete runs another Hoogle instance.
12:39:59 <monochrom> I don't know. does it find maximums anywhere?
12:40:35 <frerich> guldfiskn: In general, when I face problems like what you described, I found it nice to have a ‘type-driven’ approach. I write something like ‘isAmbiguous :: [Int] -> Bool’ and then set ‘isAmbiguous = undefined’. That way, I can ‘pretend’ the function exists already (the code compiles) and start using it. I implement it lateron. It’s kind of a ‘top-down’ method which nicely decomposes problems into smaller tasks.
12:40:44 <guldfiskn> monochrom: it doesn't lol... I chose the lazy way of just printing the list and a stringline that would explain how to interpet the list hehe :D
12:41:03 <mniip> why are integers so asymmetric
12:41:30 <mniip> either I have to specialcase Zero, or end up with two zeros, and then I can't use derived Eq anymore
12:41:54 <monochrom> it seems somewhere inside "ask"
12:42:09 <EvanR> mniip: what you can do is start with positive numbers only, no zero
12:42:22 <EvanR> then integers are either positive, negative or zero
12:42:28 <EvanR> zero is a special case of course
12:42:31 <tnks> levi: is there a way to get the "hoogle" command-line utility to point to the FPComplete instance?
12:42:38 <guldfiskn> in line 67-71 the code increases the elements of the list
12:43:09 <EvanR> mniip: two zeros sucks
12:43:31 <EvanR> unless thats where i put my money on roulette
12:43:33 <guldfiskn> frerich: This method sounds really intriguing, but I don't really follow your train of thought... How would you continue using this method after defining isAmbiguos as undefined?
12:43:35 <tnks> actually, I guess that command downloads a very specific subset of data.
12:43:47 <tnks> maybe I'll just end up on a web page no matter what.
12:44:20 <levi> tnks: That I don't know... I don't use the command line one much. You could certainly get it to point at the FPComplete instance if you modified the source and rebuilt, but there may be an easier way via configuration.
12:46:31 <frerich> guldfiskn: Take the case at hand: if I understood you correctly, you’d like your “ask” function to print a message in case there’s no single ‘maximum’ answer but two (or three, or four) answers which were given equally often, right?
12:46:58 <guldfiskn> frerich: correct
12:47:41 <frerich> guldfiskn: The idea is that instead of starting to think how to do that, you first think about what type a function would have which can tell whether some list of numbers has a single maximum. In your case, something like ‘hasSingleMaximum :: [Int] -> Bool’ might be a plausible start. You give it some numbers, and it yields True if there is a single maximum, false otherwise.
12:48:25 <frerich> guldfiskn: Now, to make the code compile, you write ‘hasSingleMaximum = undefined’ such that you get the typechecking help from the compiler but a runtime error when you try to use the undefined function. The benefit of this is that you can see how to stick this function into ‘ask’ right away.
12:49:35 <frerich> guldfiskn: I.e. instead of trying to implement ‘hasSingleMaximum’, you first try to plug it into your ‘ask’ function. If ‘ask’ has some list of numbers, then it could probably pass that to your yet-to-be-defined ‘hasSingleMaximum’ function and then print a message (or not).
12:50:25 * hackagebot pgdl 7.77 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.77 (sifmelcara)
12:50:41 <frerich> guldfiskn: If you continue this trail of thought, you find that you have a lot of ‘undefined’ functions and you just combine them, letting the compiler (via the type system) tell you when you’re doing something silly.
12:51:11 <frerich> guldfiskn: At any point, your code compiles (you could even devise tests for it) and you have lots of small functions which you can tinker with individually in ghci.
12:51:47 <guldfiskn> frerich: I like this! I will try to solve this problem using this method, thank you very much! :)
12:58:26 <frerich> guldfiskn: It works better the more power you give to the type system by extending it with new types, i.e. using ‘data’ or ‘newtype’ a lot.
13:01:32 <erisco> what does Haskell use for streams?
13:01:52 <EvanR> data Stream a = Stream a (Stream a)
13:02:51 <EvanR> if you want IO, try pipes
13:05:59 <tristanp> Why is it if I put a plain ol' r = 1.0 in a file and load it into ghci with :load it works...but if I boot up ghci and type r = 1.0 it has a parse error on '='?
13:06:20 <monochrom> add "let "
13:06:29 <tristanp> ah
13:06:31 <JoshieAS> git status
13:06:33 <JoshieAS> oops
13:06:40 <monochrom> because ghci is a file
13:06:42 <tristanp> so I'm getting something for free when I put stuff in a file vs using ghci
13:06:54 <monochrom> err, because ghci is not a file
13:07:14 <EvanR> ghci is sort of like an implicit do block, where a = b is not allowed either
13:07:22 <tristanp> yeah but I guess I'm used to how it was in js where typing something in teh repl was literally the same thing as putting it in a file
13:07:39 <EvanR> it is teh pretty much the same as if you had a do block in a file
13:07:51 <EvanR> you cant expect to do IO commands at the top level in a file 
13:08:04 <monochrom> to tell you the truth, no one has paid money to make ghci behave exactly like a file
13:08:27 <_deepfire> is there a way to create a Map/HashMap, where the values would contain lists of values grouped by key?
13:08:38 <monochrom> it can be done, everyone wishes for it, but no one does it. 10 years from now, it will still be the same impasse.
13:08:45 <_deepfire> (other than writing it myself)
13:09:02 <bennofs> :t Data.Map.fromListWith
13:09:03 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
13:09:14 <dolio> It's so close right now it's basically not worth going the extra step.
13:09:44 <dolio> Also, it will never work exactly like a file, because if you added all the things you can do in a file, it would still have all the things you can't do in a file.
13:09:50 <monochrom> oh, there lies the evil. it is close, but different, and so it's infinitely more confusing.
13:10:05 <ab9rf> ecvil?
13:10:18 <bennofs> :t  \f -> Data.Map.fromListWith (++) . map (f &&& pure)
13:10:19 <lambdabot> Ord k => (a -> k) -> [a] -> M.Map k [a]
13:10:25 <monochrom> it understands "data John = Jon | Joan" and not "x = Jon"
13:10:38 <_deepfire> bennofs, thank you a lot!
13:11:00 <ab9rf> "pure" is one of those magical things that works in ways i don't understand
13:11:09 <sinelaw> @src pure
13:11:09 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
13:11:17 <sinelaw> :_(
13:11:27 <monochrom> pure is analogous to return. e.g., for [], pure a = [a] = return a
13:11:30 <ab9rf> pure is in the Applicative typeclass
13:11:44 <dolio> "x = Jon" is the only thing I can think of that it doesn't understand, really.
13:11:52 <_deepfire> applicative pure is the same as arrow pure?
13:11:52 <dolio> Not counting really weird stuff like template Haskell.
13:12:08 <bennofs> :t  \f -> Data.Map.fromListWith (++) . map (f &&& (:[]))
13:12:08 <sinelaw> kk
13:12:08 <sinelaw> @src Applicative
13:12:09 <lambdabot> class Functor f => Applicative f where
13:12:10 <lambdabot>     pure  :: a -> f a
13:12:12 <lambdabot> Ord k => (a -> k) -> [a] -> M.Map k [a]
13:12:16 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:12:21 <sinelaw> oy
13:12:29 <ab9rf> monkeyface operator!
13:12:29 <bennofs> I just used pure :: a -> [a] as shortcut for (:[])
13:12:31 <monochrom> the more you provide for free, the more people demand from you for free
13:13:06 <dolio> "x = Jon" is really annoying to detect, too.
13:13:12 <dolio> It's the most annoying thing to support.
13:13:23 <ab9rf> bennofs: you could have used retrun as well, i take it?
13:13:37 <bennofs> ab9rf: yes, but pure is shorter :)
13:13:44 <sinelaw> and more general
13:13:44 <ab9rf> who is Jon and why is he being equated with x?
13:13:53 <ab9rf> bennofs: fair point
13:14:01 <monochrom> Jon is a data constructor with no arguments
13:14:05 <_deepfire> monochrom, the immortal "I want more life, f***er!"
13:14:25 <clrnd> I learnt today you can define instances in ghci, pretty rad
13:14:42 <monochrom> yes
13:15:12 <monochrom> if you don't mind adding a bunch of "let"s, ghci is a pretty complete environment for typing in code
13:15:14 <ab9rf> x = Jon Snow
13:15:21 <ab9rf> monochrom: yeah, i've done that in development
13:15:26 * hackagebot ghc-exactprint 0.1.1.0 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.1.1.0 (AlanZimmerman)
13:15:31 <monochrom> code that aren't saved, code that you will lose when you pull the plug
13:16:02 <monochrom> I don't understand why people do that in ghci or python. they don't even save your code.
13:16:19 <sinelaw> I can't see any plug
13:16:21 <monochrom> can I call it "development" when you don't save your code?
13:16:21 <_deepfire> all this code.. will be lost in time.. like tears.. in rain..
13:16:42 <ab9rf> everything that has a beginning has an end
13:17:05 <sinelaw> > fix (1:)
13:17:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:17:10 <monochrom> I can understand the SML/NJ case. it has a command for saving your code you entered into its REPL.
13:17:34 <ab9rf> monochrom: you should add that to ghci
13:17:40 <arw_> ab9rf: robert the ray disagrees
13:17:47 <monochrom> this is why I say: the more you provide for free, the more people demand from you for free
13:18:07 <ab9rf> monochrom: and it's your turn!
13:18:08 <sinelaw> $5 per line then
13:18:16 <_deepfire> the key question is whether one enjoys the process..
13:18:31 <EvanR> $1 per 1 in ones
13:19:05 <EvanR> will accept lazy payment
13:19:07 <tripped> I've seen things you people wouldn't believe... infinite lists on fire off the shoulder of an applicative functor... lenses glittering in the dark near the tannhauser gate...
13:19:21 <sinelaw> tripped, that's the spirit!
13:19:29 <dolio> monochrom, ab9rf: Why not use a file and :e?
13:19:32 * EvanR doesnt know how to use @quote
13:19:52 <monochrom> I use a file and I advocate doing so
13:20:20 <monochrom> I have been speaking sarcastically about entering wholesome code into the REPL
13:20:26 * hackagebot snaplet-fay 0.3.3.11 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.11 (AdamBergmark)
13:20:47 <tripped> I wonder... would burning an infinite list produce infinite smoke and asphyxiate the world, like Borges's book of sand?
13:20:59 <tripped> I suppose not if it were burned lazily
13:21:02 * frerich thought everybody used a file and then some parallel ghci session in a separate tab, so you hack, save file, :r, tinker.
13:21:18 <monochrom> it will take infinite time to burn through an infinite list
13:21:23 <ReinH> You can also :e from inside ghci
13:21:47 <monochrom> it produces infinite smoke after infinite time. now it's a boring useless tautology.
13:21:59 <EvanR> it burns twice as bright, and half as long: 2*inf = inf/2 = inf
13:22:31 <tripped> lol EvanR
13:22:55 * EvanR extracts a free 4 from there and runs
13:22:59 <dolio> Unfortunately :e seems buggy.
13:23:27 <dolio> I think if you enter a line in the repl that causes an error, it will sometimes put :e in a state where it can no longer find the file for some reason.
13:23:47 <dolio> So you have to restart ghci.
13:24:59 <dolio> It's a good way to work, though.
13:26:37 <_deepfire> freirich, emacs has pretty awesome integration with ghc
13:26:52 <ReinH> dolio: huh
13:27:37 <glguy> afaik the :e breakage is new to the 7.10 series
13:27:57 <dolio> Ah. That's what I've been using lately.
13:28:30 <glguy> Iavor put a ticket in for it, I don't know that anyone is worried about it, though
13:29:10 <dolio> Compared to the other issues before 7.10 gets released, it's pretty minor.
13:30:48 <glguy> https://ghc.haskell.org/trac/ghc/ticket/10101
13:31:41 <dolio> Yeah, that's what I see.
13:32:16 <dolio> The interesting part is that only a type error in a repl line causes that, not a type error in the file.
13:32:49 <dolio> Maybe that's not surprising, though.
13:34:59 <tristanp> Am I using let correctly to process I/O here? my first haskell program so if anything is naive or dumb please say so https://gist.github.com/tristanpendergrass/80abe6f1543119837567
13:35:38 <erisco> EvanR, thanks
13:36:02 <mauke> tristanp: well, I'd use readLn instead of getLine
13:36:18 <erisco> what I was thinking about is reading lines in a file and modelling this as   Stream (Stream Char)
13:36:27 <mauke> and it's a bit unusual that getArea has type String -> String -> String instead of working on numbers
13:36:29 <erisco> there are a number of problems with actually implementing that model
13:36:31 <bergmark> tristanp: if you let bind something not in IO i don't see a way you could do it wrong if it compiles (unless you endlessly loop or something)
13:36:49 <erisco> just curious how you would model reading a file by lines using a stream in Haskell
13:36:49 <EvanR> erisco: Stream is infinite-only. and since your are using IO for input, you cant produce a pure Stream value
13:37:02 <EvanR> pipes though
13:37:35 <erisco> you can extend it to infinite just by returning EOF forever
13:37:42 <EvanR> EOF isnt a character
13:37:50 <erisco> don't use Char
13:37:55 <EvanR> ok
13:38:01 <EvanR> but lines arent infinite
13:38:16 <erisco> granted
13:38:29 <erisco> well, whatever you want to call finite streams
13:38:34 <erisco> segments? whatever, doesn't matter to  me :P
13:38:57 <erisco> Segment (Segment a)   this seems like a nice model but has a lot of problems with implementation
13:39:09 <erisco> curious how Haskell models this
13:39:27 <EvanR> pipes, conduits, interatees, or just basic IO actions
13:39:33 <EvanR> iteratees
13:39:47 <EvanR> each line is a String or Text
13:40:03 <EvanR> and you have a IO stream of lines
13:40:06 <EvanR> iostream is another one
13:40:17 <erisco> what does the pipes type look like for this?
13:41:12 <EvanR> Producer String ?
13:41:22 <lpaste> Matt pasted “No title” at http://lpaste.net/6854928796970123264
13:41:29 <benzrf> EvanR: for what
13:41:34 <benzrf> * erisco
13:41:43 <benzrf> Producer String IO () probably
13:42:10 <EvanR> Producer' String IO ()
13:42:41 <EvanR> erisco: check out the docs
13:42:59 <tristanp> Ok I revised it to: https://gist.github.com/tristanpendergrass/06cf0afb379220c95329. The book I'm reading hasn't explained how the do block works yet but i know it is just syntactic sugar. It essentially chains together all the commands with a .then() ?
13:43:11 <lpaste> Matt pasted “No title” at http://lpaste.net/4900492117765259264
13:46:11 <nkar`> is a (remote) cabal.config taken in account when a package is installed from hackage?
13:46:23 <nkar`> or does hackage disallow them?
13:46:28 <nkar`> or does it work differently?
13:46:37 <nkar`> it being the solver
13:51:03 <frerich> tristero: Kinda, yeah. Or like a semicolon in other languages (like C++ or JavaScript). ‘do’ lets you write imperative programs.
13:51:41 <EvanR> frerich: he left
13:51:57 * frerich sobs
13:52:08 <lpaste> NemesisD pasted “type families type variable scoping” at http://lpaste.net/3843375901714677760
13:52:41 <NemesisD> could someone have a look at that? i think i need a single type variable in the scope of this instance but i can't figure out where to put it
13:54:19 <NemesisD> i think i need to somehow annotate both liftWith and the newtype in that type family to have the same m
13:55:54 <erisco> benzrf, doesn't look right because you have to yield the string all at once
13:56:04 <erisco> the point is to yield each line character by character
13:56:22 <EvanR> why ?
13:56:32 <erisco> why what
13:56:45 <EvanR> if you want a file character by character, why is it split into lines?
13:56:59 <erisco> you want the file by lines, and the lines by character
13:57:08 <EvanR> you can easily split a line into characters
13:57:34 <EvanR> (a String is a list of characters already)
13:57:46 <erisco> if you're reading the entire line then splitting it after you're missing the point I am after
13:57:58 <EvanR> @src String
13:57:58 <lambdabot> type String = [Char]
13:58:21 <EvanR> im not sure what the point is
13:58:40 <ttt_fff> does hoogle generate data from my local ~/.cabal, or does it just download some data from some foreign server ?
13:59:43 <benzrf> erisco: well
14:00:12 <benzrf> erisco: the code recognizes 5 different categories formed by Proxy
14:00:26 <benzrf> EvanR: 1 is the kleisli category from its monad instance
14:00:29 <benzrf> * erisco
14:00:41 <erisco> why is that important?
14:01:11 <EvanR> if you want your module to output characters theres several ways to do that already described
14:01:18 <benzrf> erisco: one of them corresponds to the kleisli category that Proxy would form if it were a monad in the downstream-out argument instead of the final-result argument 
14:01:20 <EvanR> if you want it to output lines, several ways already described
14:01:25 <benzrf> erisco: which means you can do a join
14:01:39 * benzrf checks which one does that
14:01:48 <erisco> you're referring to monad join?
14:01:51 <benzrf> =yes
14:01:53 <benzrf> *yes
14:02:09 <erisco> what type is being joined?
14:02:20 <benzrf> Proxy
14:02:39 <EvanR> i dont think erisco is interested in the theory behind pipes implementation
14:02:45 <benzrf> fine
14:02:58 <EvanR> i could be wrong 
14:03:04 <erisco> no I am just curious if there is any notion of higher order streams
14:03:11 <erisco> or segments, or whatever your finite variant is
14:03:13 <benzrf> it is nearly trivial to do `Producer (Producer Char IO ()) IO () -> Producer Char IO ()' in pipes
14:03:14 <EvanR> oh then continue ;)
14:03:16 <benzrf> that's all
14:03:47 <benzrf> you just find what amounts to bind for that argument, then bind to id
14:03:52 <benzrf> just like with an ordinary monad instance
14:04:23 <erisco> that is the wrong direction, I presumably read the file and start with Producer Char IO ()
14:04:33 <EvanR> you can do that
14:04:37 <erisco> then I want to chunk by line and get Producer (Producer Char IO ()) IO ()
14:05:06 <EvanR> but depending on what youre going to do with it, getting lines might be simpler
14:05:47 <erisco> but maybe that type doesn't let you do much, I haven
14:06:07 <EvanR> pipes are composable
14:06:07 <erisco> 't looked at pipes for a while and I forget too much of it
14:06:53 <erisco> the implementation concern is that I only have one file descriptor and I only want to move from start to end, never backwards
14:07:39 <erisco> so, for instance, if I could get two line producers in scope at once that'd be a problem
14:08:16 <EvanR> you should only have one thing reading a FD at a time
14:08:18 <erisco> the second line producer doesn't know where it starts until the first line producer has finished
14:08:41 <EvanR> two line producers? :S
14:08:55 <erisco> sure
14:09:08 <erisco> I will have to check pipes to see what  Producer (Producer Char IO ()) IO ()  means
14:10:02 <EvanR> the idea is to chain them so one thing is producing Chars while reading the file, and the next thing is reading the Chars until it sees a line, then yields that line
14:10:07 <EvanR> both arent reading the file at once
14:10:28 * hackagebot not-gloss 0.7.1.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.1.1 (GregHorn)
14:10:50 <SCHAAP137> if I want to wipe all the packages i installed with cabal and start new,
14:11:00 <SCHAAP137> would it be sufficient to delete ~/.cabal and ~/.ghc ?
14:11:49 <avocado> SCHAAP137: that's what i do
14:12:00 <SCHAAP137> cool, then i'll do that as well
14:14:47 <kadoban> ~/.cabal has your cabal config in it, which you usually shouldn't wipe out.
14:15:02 <kadoban> (at least if you've changed it at all, which you probably should)
14:19:10 <JoshieAS> what got everyone into Haskell?
14:19:52 <zomg> Masochism
14:20:19 <zygentoma> decision to learn ocaml or haskell :) and a university course
14:20:24 <quchen> lexi-lambda: Who the hell suggested using Compose for your task :-s
14:20:26 <voidzero> heh
14:20:44 <voidzero> with me.. it was 'Liquidsoap.'
14:21:46 <voidzero> liquidsoap is an audio streaming language
14:22:11 <JoshieAS> zygentoma: similar here, I learned SML and loved it and fell into Haskell
14:22:15 <JoshieAS> Liquidsoap, eh?
14:22:24 <voidzero> when i started to use it, it was the first time i heard of "functional programming language"
14:22:28 <prsteele> Joshieas: I'd heard good things, and people on ProjectEuler who used haskell had good scores
14:23:03 <zygentoma> i had some contact with lisp before …
14:23:12 <voidzero> although, I did remember a buddy with a book about Haskell. So I borrowed the book and got intrigued
14:23:40 <voidzero> in fact, so intrigued that I have yet to continue my adventures with liquidsoap :P
14:23:51 <voidzero> longest detour ever
14:25:01 <voidzero> liquidsoap itself is written in OCaml, but I still chose Haskell
14:25:25 <voidzero> mainly because I've been using xmonad since forever, and never really understood how to read my config file. :P
14:25:38 <prsteele> that is a nice plus
14:26:12 <voidzero> :)
14:26:49 <Cale> quchen: That was my initial reaction too :D
14:28:38 <Cale> quchen: It wasn't such a bad suggestion though, lexi was just interested in how to points free (\x y -> f (g x y) (h x y))
14:29:30 <quchen> The correct answer to that is "don't do that"
14:31:46 <nkar`> does hackage generate the docs automatically right now?
14:32:33 <bergmark> nkar`: yes
14:32:54 <prsteele> so anyone actually use literate Haskell?
14:33:09 <mmachenry> prsteele: A lot of people do, yes.
14:33:12 <nkar`> bergmark: cool, and how long does it take to get a confirmation email?  I've just requested an account, but my inbox is empty
14:33:29 <mmachenry> I've seen a lot of documentation and or tutorials written that way. I haven't.
14:33:41 <mmachenry> Meaning I haven't written one myself.
14:33:41 <bergmark> nkar`: i have no idea, i registered in the old system
14:33:54 <prsteele> mmachenry: I'm torn. On one hand, I love it. On the other, I can't use Haddock unless I double up comments, which seems wasteful
14:35:13 <YaRly> Is there a predefined round half up function?
14:35:47 <arkeet> :t round
14:35:48 <lambdabot> (RealFrac a, Integral b) => a -> b
14:35:59 <arkeet> -- | @'round' x@ returns the nearest integer to @x@; --   the even integer if @x@ is equidistant between two integers
14:36:04 <YaRly> that's not round half up
14:36:13 <arkeet> what do you mean by half up
14:36:24 <YaRly> 0.5 -> 1, 1.5 -> 2
14:36:25 <mmachenry> prsteele: Doubling up comments is a very small thing if the bulk of your document is prose. So know when to make the trade off.
14:36:43 <arkeet> ok, peek at the definition of round then.
14:36:52 <kadoban> YaRly: round to even is a pretty common bias-reducing measure. Do you really need round-up?
14:36:53 <prsteele> YaRly: \x -> floor (x + 1/2)
14:37:13 <prsteele> Yarly: is probably what you're looking for
14:37:26 <mmachenry> If your primary consumer is a reader hoping to get some high-level insight to this code and learn concepts, I'd use literate Haskell. But if you're writing a program and the primary goal is a maintainable living piece of code, I'd use normal syntax
14:38:02 <prsteele> mmachenry: ya that seems to be the divide, I suppose. Write code for papers in lit, write libraries in regular
14:38:48 <YaRly> kadoban: Well I can live without it, but I was wondering if there was a predefined round up in Haskell
14:39:02 <YaRly> prsteele: Thanks, I suppose that works...
14:39:25 <YaRly> I've grown up with round half up my entire life, so when I try things out I intuitively think round half up
14:39:59 <lexi-lambda> quchen: blame mniip :p
14:45:25 <quchen> lexi-lambda: I hope there's still going to be a day 3 ;-)
15:03:08 <S11001001> @tell SrPx re Elm v PureScript: Elm lacks typeclasses and higher kinds and is very unlikely to get the latter (see https://groups.google.com/d/msg/elm-discuss/oyrODCgYmQI/T2I_8L-AL6EJ and conversation), so common abstractions (e.g. Monads, Traversable, Hashable for HashMap, van Laarhoven lenses) you might use in Haskell are unavailable in Elm, but available
15:03:08 <lambdabot> Consider it noted.
15:03:08 <S11001001> in PureScript.
15:03:24 <S11001001> @tell SrPx ...in Purescript.
15:03:25 <lambdabot> Consider it noted.
15:04:39 <xnil> :t mapM
15:04:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:05:27 <gyaretto> :t mapM_
15:05:28 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
15:05:54 <RustyShackleford> what the heck is a monad and why do I need them?
15:05:55 <xnil> gyaretto: that seems useful
15:06:08 <gyaretto> xnil: Yeah, I love it.
15:06:34 <xnil> RustyShackleford: Monad is a typeclass with functions `return' and `>>='
15:06:47 <SrPx> S11001001: oh, thanks! Interesting. What about library support, though? I've noticed elm has a lot of them
15:08:01 <S11001001> SrPx: No idea.  You might check out https://gist.github.com/paf31/8e9177b20ee920480fbc though
15:09:05 <EvanR> when you read from a TChan and then retry, does it put the value back in the chan?
15:09:15 <SrPx> S11001001: awesome :) ty
15:09:24 <EvanR> or else not commit the dequeuing
15:10:49 <ReinH> @google monads for functional programming pdf
15:10:51 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
15:10:51 <lambdabot> Title: Monads for functional programming
15:11:10 <monochrom> it doesn't commit the dequeuing.
15:11:25 <EvanR> good
15:11:55 <monochrom> to test: have one thread atomically { dequeue; retry }. one second later, have another thread atomically { dequeue }, see what it gets.
15:12:28 <monochrom> it is very important to think up an experiment to test my theory
15:12:32 <EvanR> i did it
15:13:18 <EvanR> it works like you said
15:13:35 <EvanR> one less reason for my program to be not behaving
15:15:07 <EvanR> its pretty cool, if you dont like something that happened while taking from a bunch of chans, retry "undoes" it all
15:15:31 * hackagebot apiary 1.4.1 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.4.1 (HirotomoMoriwaki)
15:16:49 <prsteele> anyone know the indentation rule for long constructors that don't fit in 80 chars?
15:17:04 <ReinH> prsteele: Indentation rule?
15:17:22 <ReinH> There's no 80 character column limit
15:17:39 <ReinH> There's no special rule for long constructors
15:17:44 <monochrom> this is the purpose of the T in STM
15:18:28 <prsteele> thanks
15:18:52 <shachaf> How do I extract the T from STM String?
15:18:55 <flounders> You should still do line wrapping though if the line is too wide.
15:19:09 <voidzero> i guess the question is, what's a valid way to wrap long lines
15:19:11 <ReinH> I might suggest not making constructors that are over 80 characters long for other reasons, though
15:19:12 <EvanR> unsafePerformSTM
15:19:26 <ReinH> Well, not in the middle of an identifier.
15:19:50 <prsteele> flounders: Of course. So the style is just to indent until the non-whitespace starts after the = on the previous line, then?
15:19:59 <prsteele> e.g.
15:20:05 <prsteele> data F = F A B C
15:20:10 <prsteele>          D E F
15:20:25 <flounders> prsteele: I haven't run into the issue of long data constructors yet, so I can't answer your question.
15:20:47 <voidzero> that should work though
15:21:01 <ReinH> You can also put the first F constructor on a new line, indented
15:21:11 <ReinH> data F =\n  F
15:21:43 <ReinH> or you can indent the =: data F\n  = F
15:22:04 <bergmark> prsteele: i usually do this http://lpaste.net/124649
15:22:15 <voidzero> iirc, any line that starts with more spaces than the previous, is considered to be a continuation of the previous line
15:22:19 <ReinH> bergmark: same
15:22:33 <bergmark> utrecht style baby
15:22:33 <voidzero> the same amount, or more spaces
15:22:44 <ReinH> voidzero: not a continuation of the previous line, no
15:22:50 <prsteele> bergmark: the difference here is that this isn't two constructors, its one constructor with a large number of arguments
15:23:29 <bergmark> prsteele: http://lpaste.net/124651
15:23:45 <prsteele> bergmark: sure, nice.
15:24:10 <ReinH> prsteele: among the ways you can do it are https://gist.github.com/reinh/ad366c0f9b4034315d95
15:24:11 <bergmark> maybe i wouldn't put the = on a new line with only one constructor, dunno :-)
15:25:17 <prsteele> bleh, haskell-mode doesn't like these styles
15:26:01 <bergmark> haskell-mode seems to never like anything i do :)
15:26:12 <bergmark> i use the simple indentation though, messes with me the least
15:26:54 <prsteele> hm, simple let's me do this
15:27:29 <bergmark> i think all those modes were written to work well with whatever style the author liked at that point
15:29:05 <NemesisD> could someone more well versed in type families than me take a look at this blasted MonadTransControl instance and tell me what i'm doing wrong?
15:29:06 <NemesisD> http://lpaste.net/3843375901714677760
15:30:25 <shachaf> That thing is not like Reader but more specific.
15:30:44 <norte_y_sur> 01hola soy spain
15:31:16 <EvanR> norte_y_sur: your colors arent showing up
15:31:57 <EvanR> [black]aeris dies
15:32:05 <EvanR> oops
15:32:24 <norte_y_sur> 01alguien de spain?
15:33:11 <prsteele> norte_y_sur: no, soy de los estados unidos
15:33:42 <norte_y_sur> 4[prsteele4] 01hola soy espaol
15:33:56 <voidzero> ciao a tutti!
15:34:21 <glguy> This is an English language channel
15:34:23 <voidzero> btw, this is an English channel. 
15:34:30 <FireFly> That has to be the most annoying way I've see someone use to address someone else on IRC
15:35:14 <norte_y_sur> 4[prsteele4] 01de donde eres tu eres chica?
15:35:15 --- mode: ChanServ set +q *!*@62.117.223.208.dyn.user.ono.com
15:35:32 <arw_> FireFly: you lurk in too many civilized channels >
15:36:22 * voidzero remembers when the bold colon (BitchX default setting) was enough to get you banned from #linux @ ircnet
15:36:31 <arw_> or rather too few uncivilized ones.
15:37:00 <arw_> voidzero: or forgetting the colon or using a comma
15:38:03 <jacquerie> wait, where is this proper IRC etiquette written?
15:38:06 <Lutin`> I can't even see his text
15:38:58 <Lutin`> 10F11i02r12e06f13l05y04: 07W08h03a09t 10a11b02o12u06t 13t05h04i07s
15:39:23 <voidzero> this etiquette was written many, many moons ago
15:39:45 <glguy> I'd rather kick people who abuse colors than disable the colors
15:39:47 <FireFly> jacquerie: it's kind-of implicit
15:40:21 <FireFly> Lutin`: very colourful
15:42:44 <NemesisD> shachaf: ignore the misnomer then
15:42:45 <Lutin`> woops
15:42:54 <Lutin`> now I know what /upgrade does in weechat
15:43:00 <shachaf> NemesisD: OK, but is your thing a monad transformer?
15:43:20 <NemesisD> shachaf: yes. i've got instance MonadTrans LogContextT
15:44:40 <EvanR> guh, i couldnt debug . trace values deep in my code because no Show constraint
15:44:47 <EvanR> tried to add them everywhere, gross
15:45:32 * hackagebot mgeneric 0.0.0.0 - Generics with multiple parameters  http://hackage.haskell.org/package/mgeneric-0.0.0.0 (rbocquet)
15:45:44 <monochrom> I don't think you need the Show constraint
15:46:14 <EvanR> trying to print out the values
15:46:31 <EvanR> which might not have a Show instance, but in my test they do
15:48:40 <EvanR> unsafeCoerce to the rescue ;)
15:49:02 <NemesisD> shachaf: might i be missing a lift somewhere?
15:49:40 <drewbert> what does | mean in a class type declaration?
15:49:51 <glguy> Functional dependencies
15:49:52 <bergmark> drewbert: functional dependency
15:50:09 <RustyShackleford> haskell makes so much sense when you read the guides
15:50:23 <RustyShackleford> then i'm totally lost when I try to write some code
15:50:40 <monochrom> this is why programming is not a spectator sport
15:50:45 <bergmark> drewbert: i will plug myself http://www.reddit.com/r/haskell/comments/2pal4v/24_days_of_ghc_extensions_functional_dependencies/cmvaaqq
15:55:14 <RustyShackleford> so i'm trying to create something like a struct
15:55:19 <lpaste> NemesisD revised “type families type variable scoping”: “No title” at http://lpaste.net/3843375901714677760
15:55:43 <RustyShackleford> now record syntax for a type class will automatically create those accessor functions for me
15:55:52 <RustyShackleford> is that what I'm looking for?
15:56:15 <sternenseemann> RustyShackleford: data Foo = Foo { bar :: Int, fooBar :: String }
15:56:23 <sternenseemann> it's what you want I suppose
15:56:37 <NemesisD> shachaf: i'm probably reading that wrong but the second error would seem to indicate that the m in the StT type is not the same as the one in liftWith
15:57:00 <drewbert> haskell is not just a steeper learning curve, it's a bigger mountain altogether
15:57:11 <glguy> What does it mean when you declare a newtype instance of an associated type synonym?
15:58:16 <zipper> Does anyone have a problem getting yesod apps via curl. It seems to work with the browser but `curl "localhost:3000"` isn't working.
15:58:36 <NemesisD> glguy: are you talking to me? i don't follow
15:59:09 <shachaf> You wrote "newtype StT ..." but MonadTransControl defines an associated type synonym.
15:59:25 <drewbert> zipper: works for me
15:59:31 <shachaf> I think it would mean an error, but you don't seem to be getting an error.
16:00:33 <NemesisD> oh sorry! i should be clear i'm stuck on monad-control 0.3.3.1
16:01:01 <NemesisD> the newest monad-control looks like it would make this much nicer but i think one of my dependencies is preventing the upgrade
16:01:19 <NemesisD> http://hackage.haskell.org/package/monad-control-0.3.3.1/docs/Control-Monad-Trans-Control.html
16:03:12 <bergmark> NemesisD: there's a package for deriving those instances, have you tried it?
16:03:35 <NemesisD> bergmark: i haven't heard of that. i'd be willing to give it a shot
16:04:03 <bergmark> now where was it
16:04:37 <bergmark> https://hackage.haskell.org/package/newtype-deriving
16:04:49 <bergmark> it says "typical" newtype instances, whatever that means
16:13:38 <zipper> Haskell is always on hacker news lol
16:24:47 <NemesisD> bergmark: back to square one, newtype-deriving requires monad-control == 1.*, guess i should try to get that working
16:31:45 <bergmark> oh...
16:48:04 <prsteele> :t \f x -> zip x (map f x)
16:48:05 <lambdabot> (a -> b) -> [a] -> [(a, b)]
16:48:49 <prsteele> that seems like it should exist
16:51:52 <ReinH> :t map . (id &&&)
16:51:53 <lambdabot> (c -> c') -> [c] -> [(c, c')]
16:52:14 <prsteele> :t (&&&)
16:52:15 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:52:29 <prsteele> I'm impressed if you pulled that out of thin air
16:52:57 <ReinH> Well, I guess you're impressed then
16:53:30 <prsteele> heh. I should read up on Arrows, I know they exist but I've never used them. I would say never needed them, but that is just because I don't know them...
16:53:49 <ReinH> you really just need fanout f g x = (f x, g x)
16:54:06 <ReinH> but (&&&) works
16:55:09 <ReinH> Or
16:55:12 <ReinH> :t map . liftA2 (,) id
16:55:13 <lambdabot> (a -> b) -> [a] -> [(a, b)]
17:00:32 <xnil> :t map (mapM succ)
17:00:33 <lambdabot> (Monad m, Enum (m b)) => [[m b]] -> [m [b]]
17:08:30 <HeladoDeBrownie> is there a well known EitherT that's still maintained? i looked at the EitherT package but its maintainer seems not to have done anything with it recently, and it's missing some instances
17:08:43 <hpc> ErrorT
17:09:22 <HeladoDeBrownie> hpc, ah, perfect. seems like an odd name for it.
17:09:36 <hpc> sort of
17:09:39 <peddie> HeladoDeBrownie: also ExceptT perhaps
17:09:47 <hpc> it's the same way that ((->) a) is Reader
17:09:50 <HeladoDeBrownie> peddie, where is that found?
17:10:00 <peddie> @hoogle ExceptT
17:10:02 <lambdabot> No results found
17:10:04 <peddie> butts
17:10:23 <peddie> looks like transformers-compat
17:10:42 <HeladoDeBrownie> hpc, i wouldn't say it's the same at all; Reader is a name in letters for (->), whereas Either already has such a name
17:10:52 <peddie> or in the MTL
17:11:11 <peddie> HeladoDeBrownie: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
17:11:16 <HeladoDeBrownie> peddie, thanks
17:12:05 <HeladoDeBrownie> hmm, how are they different?
17:13:12 * peddie shrugs
17:13:36 <HeladoDeBrownie> oh, ErrorT is deprecated
17:13:42 <HeladoDeBrownie> ExceptT it is then
17:14:04 <glguy> They do slightly different things, you should just use the one that does what you want
17:14:09 <hpc> ExceptT sounds like it's dealing with real IO-y exceptions
17:14:20 <pyon> Is there any way to make GHC aware that overlapping type instances "are okay because they yield the same type"?
17:16:03 <peddie> glguy: I'm curious too; could you explain the difference?
17:16:38 <HeladoDeBrownie> glguy, it doesn't seem like using something deprecated is a good idea, if something almost the same that isn't deprecated exists.
17:17:05 <glguy> HeladoDeBrownie: Marking it deprecated it was probably a mistake
17:18:10 <glguy> The difference is the ExceptT passes fail down to the monad it transforms and ErrorT implements it as throwing an exception in ErrorT
17:19:10 <HeladoDeBrownie> i don't understand that explanation
17:19:26 <HeladoDeBrownie> what does "passes fail down" mean? what does "throwing an exception in ErrorT" mean?
17:19:42 <glguy> Open the source code and look at the implementations of the "fail" method in the Monad instances for those two types
17:19:53 <glguy> That's the difference
17:19:56 <peddie> glguy: thank you
17:20:16 <NemesisD> shachaf: glguy  I managed to upgrade monad-control to 1.x and while the instance simplified, it indeed has the same issue of a mismatch in the monad type variable
17:23:14 <lpaste> NemesisD pasted “type families type variable scoping 2: electric boogaloo” at http://lpaste.net/5997828598008905728
17:43:41 <glguy> NemesisD: Do you understand what the Run type synonym is?
17:44:23 <glguy> 03type Run t 07= forall n β07. Monad n 07=> t n β 07-> n (StT t β)
17:46:00 <hpc> glguy: do you have a macro or something to highlight?
17:46:13 <hpc> and if irssi, can i has?
17:46:27 <glguy> It's part of myclient: https://github.com/glguy/irc-core
17:46:49 <hpc> ah, the age-old UI tutorial program
17:46:54 <hpc> write an irc client :P
17:47:09 <glguy> Yup, but most tutorials stop short of this one
17:47:24 <hpc> well
17:47:38 <hpc> what makes it so great is that it's got all the basic pieces, and so much room for expansion
17:47:39 <Rotaerk> I like how up-front you are about it
17:47:45 <Rotaerk> "This client has fewer features than the one you're using now. You probably don't want to use it."
17:47:46 <hpc> but you have to decide which way you go
17:48:15 <hpc> it's the same reason writing an irc bot is a good exercise
17:48:24 <hpc> with the bot being more directed toward automation than interaction
17:49:09 <glguy> the core library that the client is written on top of would be useful for bot writing
17:50:23 <hpc> well yeah :P
17:52:45 <Lutin`> ...and I totally forgot I was taking a coursera course
17:52:47 <Lutin`> WOO
17:53:53 <prsteele> Lutin`: I feel like that is the case with everyone I know who has tried MOOCs
17:54:09 <HeladoDeBrownie> is there some way i can visualize the package dependency graph that cabal builds for a given project?
17:54:11 <Lutin`> yeah esp since I'm also in uni
17:54:23 <Lutin`> so all my other classes kind of take over
17:54:31 <HeladoDeBrownie> or, view directly in any manner really
18:10:16 <randir> Any recommendation for a URL parsing library?
18:10:36 <randir> like something that says if two urls have equal roots, if one is a level about the other, etc.
18:13:34 <randir> On another note, I'm having a weird error
18:16:06 <randir> nevermind, figured it out :)
18:16:17 <randir> but still looking for the best URL lib
18:20:56 <Axman6> randir: Network.URI
18:21:07 <Axman6> note I not L
18:22:14 <randir> Yeah, thanks-- looks perfect!
18:35:40 * hackagebot collection-json 0.1.0.0 - Collection+JSON hypermedia type tools  http://hackage.haskell.org/package/collection-json-0.1.0.0 (DanielChoi)
18:44:53 <randir> Do you guys have a standard naming convention you use for a value that's a Maybe value?
18:45:14 <pacak> randir: m'blah
18:46:06 <noobie> How do I handle a close request due to a browser closing in yesod?
18:47:17 <Hafydd> randir: personally, either maybeName or mn depending on how long I want it to be.
18:47:53 <Hafydd> When space isn't a concern (which is hopefully often the case), I think it doesn't hurt to be explicit about what the variable is.
18:48:30 <noobie> The issue i am facing is that i want to clean up connected clients when the user hits refresh.
18:48:35 <noobie> How do I do that?
18:48:50 <randir> Hafydd: I tend to agree.
18:49:07 <randir> pacak: and thanks for the suggestion, I kind of like that way of doing it.
18:49:28 <ReinH> noobie: Er, how are the browsers connected?
18:49:28 <Hafydd> m'blah sounds like a swear word from a made-up language.
18:49:57 <pacak> Hafydd: It's Klingon.
18:50:04 <Hafydd> Likely.
18:50:09 <noobie> @Reinh: browser is running a haxe client (websockets client) and the server is a yesod websockets server
18:50:09 <lambdabot> Unknown command, try @list
18:50:18 <ReinH> noobie: Ah. Websockets.
18:50:31 <noobie> ReinH : yeah.
18:50:44 <siddhu> is there a way to undo-memoization?
18:50:48 <noobie> ReinH: so I was able to get the basic scenario to work.
18:51:09 <noobie> ReinH : but when the user hits refresh..i get this CloseRequest from within warp.
18:51:28 <noobie> and I have no way of handling to remove the connected clients.
18:52:26 <noobie> Reinh: http://lpaste.net/124755 is the server..
18:55:27 <noobie> What is the best approach to follow?
18:55:37 <sm> don't miss http://joeyh.name/code/scroll , just two days to go
18:59:41 <bydo> siddhu: what would that do?
19:03:14 <NemesisD> glguy: sorry had to run out but i'm back for now. looking at the run type now. does that mean this instance is not possible?
19:03:59 <siddhu> bydo: Lets say I want to print all numbers [1..]. In GHCi, I can limit memory with +RTS -M50m. Then mapM_ print [1..] works which takes constant memory. But using let x = [1..] and then mapM_ print x memoizes and takes up memory till max heap size is hit. I want to be able to make  x lazy after it's value gets printed. Just wondering if it's possible.
19:05:25 <Cale> siddhu: In an actual program, so long as you didn't use x after that point, it would behave just like mapM_ print [1..]
19:06:00 <Cale> siddhu: This is just an effect of having x remain in scope: ghci doesn't know that you're not going to need it
19:06:11 <Cale> Another thing I suppose you could do is to make it a function
19:07:02 <EdThePoor> Hello. I have a very easy question. I am reviewing haskell and wanted to go about proving that For every odd number there is a greater even number. Given that our universe is u= [1..10]. I want to do list comprehension
19:07:33 <EdThePoor> for example. every number is greater than 1 or less than 2 would be Every number is either greater than 1 or less than 2
19:07:42 <EdThePoor> prob u = and [(n > 1) || (n < 2) | n <- u]
19:09:38 <Cale> I guess you could write something like:
19:09:44 <Cale> > let u = [1..10] in and [or [y > x | y <- u, even y] | x <- u, odd x]
19:09:46 <lambdabot>  True
19:10:03 <EdThePoor> yes thanks
19:10:04 <siddhu> Cale: True, but, I'm thinking, how would I read a file larger than memory, requiring some portion of the file to be in memory at one time.
19:10:07 <EdThePoor> thats what i was looking for
19:10:27 <Ryanar> ((f.).)
19:10:49 <Ryanar> :t ((f.).)
19:10:50 <lambdabot> (FromExpr c, Show b) => (a -> a1 -> b) -> a -> a1 -> c
19:11:11 <Cale> siddhu: There are a bunch of ways, but the simplest is to use lazy IO, and just be careful to consume the contents of the file you read in just one place.
19:11:56 <Cale> (so that the initial chunk of the file becomes garbage immediately after it has been processed and can be garbage collected)
19:12:24 <Cale> Well, simplest if your program isn't too complicated
19:12:32 <Ryanar> :t (.(.(ap)(f).)(ap.))
19:12:33 <lambdabot> parse error on input ‘)’
19:12:35 <Ryanar> :t (.(.(ap)(f).)(ap.)
19:12:36 <lambdabot> parse error on input ‘)’
19:13:19 <glguy_> Ryanar: You can experiment with lambdabot in /msg
19:13:36 <Ryanar> sorry, will do
19:13:55 <Ryanar> tmobile
19:14:25 <siddhu> Cale: If the application is a text editor, I might run into a situation where the entire file could be traversed at some point, and the user might want to go back to a portion that might have been garbage collected before. Does lazy io allow that?
19:14:59 <Cale> siddhu: Oh, in that case, it wouldn't have been garbage collected. If you retain a reference to the previous parts of the file, then it's not garbage
19:15:56 <Cale> Unless you're doing something like reading the contents of the file in blocks off the disk as the user scrolls and discarding anything which is too far off the screen.
19:16:19 <Cale> That's doable, but it's not really something lazy I/O is going to help you with
19:17:17 <tmobile> Cale siddhu : Couldn't iteratees/enumeratees be used to ensure that only references to currently displayed parts of file are retained?
19:17:25 <Cale> If you want very careful control over resource usage, you'll eventually want to be doing strict I/O, and perhaps even be using one of the libraries like conduit or pipes.
19:17:44 <Cale> tmobile: Probably. I'd have to think a bunch about how to do it correctly.
19:17:58 <Cale> It wouldn't be totally straightforward.
19:18:38 <maurer> Has anyone used IHaskell, and if so, do you happen to know the invocation to convince IPython's notebook app to launch with the IHaskell kernel?
19:18:42 <tmobile> I've never used conduit in context where I wanted to "rewind."
19:21:04 <siddhu> tmobile Cale: so, along the lines of bi-directional pipes? I haven't used pipes or conduits or iteratees/enumeratees before so I'm not sure.
19:25:15 <siddhu> I did not mean to ping so.
19:25:32 <geekosaur> I ave to imagine they're either used to it or have disabled it :p
19:26:17 <geekosaur> (imagine the poor person who chooses the nick "git" on freenode :p ...if that's even allowed)
19:27:09 <pacak> //whois git
19:29:34 <glguy_> NemesisD: I don't see how you'd be able to implement that class. Eventually you'll need to construct a value of "DemoT r n b -> n b" and you don't get to assume anything about n
19:29:46 <glguy_> other than that it's a Monad
19:31:24 <Cale> siddhu: Yeah, and if you're loading the stuff off of the disk as the user scrolls, and letting them edit it, you have to deal with what happens when the user makes a change, scrolls far away, and then back. It'd probably involve storing all the changes separately.
19:31:29 <NemesisD> glguy_: i think i may have it. if i make it newtype LogContextT n m a = LogContextT { runLogContextT :: n Whatever -> m a }, then anywhere i need to use it i can have a type alias LogContextT' m a = LogContextT' m m a
19:32:29 <glguy_> NemesisD: Yeah, at that point you've got a funny version of ReaderT and it will work fine
19:33:11 <NemesisD> glguy_: yeah and the whole reason why i'm doing this is because i want this to be pass through and not conflict with an existing MonadReader. i provide a MonadReader for it that requires the inner monad to be monad reader
19:33:38 <NemesisD> success! probably. i'm not at my machine where this whole project is but my minimal use case seems to work
19:35:15 <siddhu> Cale: good point. Thanks for the input :)
19:36:14 <glguy_> NemesisD: Probably a better solution if it was available would be to avoid exposing MonadReader and making a newtype for your monad stack
19:50:50 <xpilot> style question: should I use constraint kinds and type Constraint12 a = (Constraint1 a, Constraint2 a), or typeclass (Constraint1 a, Constraint2 a) => Constraint12 a
19:51:25 <xpilot> if I want shorthand for Constraint1 and Constraint2 both holding
19:58:39 <NemesisD> glguy_: newtype over monadreader?
20:01:09 <noobie> I have been trying to get some solution to handling closerequest inside a yesod handler?
20:01:14 <noobie> how do i do that?
20:01:23 <mhitza> do you guys know of a package that "wraps" IntMap in such a way that keys are incremented automatically on insert?
20:02:12 <jmcarthur> xpilot: i would prefer the former, unless there are some additional laws implied
20:02:48 <pacak> mhitza: How do you want it to behave if you insert over existing key or into a gap where one key is missing?
20:02:52 <mizu_no_oto> currently, 'sbt test' is running ScalaTest, but I've added in some ScalaCheck tests.  How do I get 'sbt test' to run both?
20:03:17 <noobie> http://lpaste.net/124755 : most of the code is application code..but i want to be able to handle the exceptions that we receive when the browser hits refresh.
20:04:11 <mhitza> pacak, I'm not really interested in inserting in existing keys, I want something like insert :: IntMap a -> a -> IntMap a Only insert/update operations, no deletes basically
20:04:54 <pacak> insert' = insert (M.size)
20:06:16 <mhitza> pacak, yeah but size is a O(n) operation, I guess I'll have to write my own datatype "wrapper" and keep the counter inside the structure
20:08:27 <mizu_no_oto> >_<  accidentally posted that in the wrong channel
20:08:27 <pacak> Then yes, that should be as simple as newtype IM a = IM (Int, IntMap a)
20:10:17 <ion> Why not data IM a = Im Int (IntMap a)?
20:11:20 <jmcarthur> mhitza: why not Data.Sequence?
20:12:20 <mhitza> jmcarthur, you are right, Data,Sequence is a better choice for this, forgot about that
20:24:30 <noobie> I need some help in handling exceptions thrown  from warp: yesod dispatach?
20:24:43 <noobie> http://lpaste.net/124755
20:27:50 <creichert> noobie: when does it happen?
20:28:18 <noobie> creichert: I refresh the browser page simulating a disconnect.
20:28:48 <noobie> creichert: I have 2 options: send a close request upon page reload (which i would have to do anyway).
20:29:24 <noobie> creichert: rather 2 requirements: one handle in the server and the other at the client. 
20:30:48 <creichert> hmm, not sure. I've seen the error too, though
20:33:06 <noobie> creichert: so when that happens, how should the application cleanup?
20:33:49 <creichert> that's a good question. I first assumed your server wasn't sending ping's to the client and it was happening mid-session.
20:33:50 <noobie> creichert: and i have 2 threads: i was trying 'finally'..i think that requires a handlerInIO.
20:33:55 <creichert> Can you open a bug?
20:34:57 <noobie> creichert: I could do it..for keep alive, i am having the client send pings every 15 seconds in haxe (javascript) similar to the chat-with-timeout example. I could open the bug..but the code has too much bloat..
20:35:53 <creichert> that shouldn't be necessary anymore, the server "should" be handling that now https://github.com/yesodweb/yesod/blob/master/yesod-websockets/Yesod/WebSockets.hs#L56
20:37:38 <noobie> creichert: i found that the session was being disconnected..so i did add it (i am using                      , yesod-core                     >= 1.4.4). Perhaps i need to upgrade?
20:38:46 <creichert> if possible, try setting your yesod-websockets version >= 0.2.1.1.
20:38:48 <noobie> creichert: i may need to upgrade to 1.4.8 and above.
20:38:59 <creichert> Want to move this conversation to #yesod?
20:39:03 <noobie> sure.
20:39:06 <creichert> thanks
20:41:06 <dmj`> jle`: ping
20:41:27 <jle`> hi
20:43:26 <tmobile> Anyone used GHCJS on the client side? If so, how do you normally handle plain HTTP requests, as the HTTP packages are unusable due to dependency on the 'network' package? Perhaps I don't know enough JavaScript to identify this as a trivial question.
20:46:22 <dmj`> tmobile: the most common communication from the browser to the server via js is ajax or websockets. There is a ghcjs jquery package, which probably includes jQuery ajax
20:51:12 <maurer> I just used zip`ap`tail in actual code >_>
20:51:14 <mhitza> can someone help me understand from where the error comes from http://lpaste.net/7257348708411375616 ? a few comments at the bottom, and the error I get
20:51:36 <dmj`> @typ zip <*> tail
20:51:37 <lambdabot> [b] -> [(b, b)]
20:51:49 <dmj`> > zip <*> tail $ [1..10]
20:51:51 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
20:52:36 <tmobile> dmj`: Ah, so there is. Thanks.
20:54:18 <EdTheOne> hello
20:55:30 <dmj`> EdTheOne: hello !!
20:55:45 <rui1> i3lock
20:56:43 <EdTheOne> So i did this problem: "There is a number that is at least as large as every number" my solution is prob7 u = and [or [y >= x | y <- u] | x <- u]. Im having trouble with this one: "For every number, there is a different number such that there are no numbers between these two." can somebody provide the solution please? 
20:56:57 <EdTheOne> let u = [1..10] for example
20:58:36 <dmj`> EdTheOne: is this for homework?
20:59:41 <EdTheOne> no.. im just looking through some old labs that i did in school. never figured this one out. just re-practicing haskell right now
21:00:39 <EdTheOne> like we cant use x - y == 1 because we could be talking about only even numbers in our universe of discourse
21:01:45 <platz> cant say I like the applicative (->) instance much for making readable code
21:01:48 <EdTheOne> so i feel like we have to introduce a new variable... hmmmm
21:02:48 <bramgg> I'm using Fay (https://github.com/faylang/fay/wiki) to compile JS for my Haskell based website, but since it's not actually a build dependency for the executable I'm not sure where to put it in my .cabal file.
21:03:12 <bramgg> Should it be included at all? It's not needed to run the script, but if one wants to edit the JS it's needed to compile.
21:03:24 <EdTheOne> say like there is no z such that z<y && z>x
21:05:46 * hackagebot witherable 0.1.2.1 - Generalization of filter and catMaybes  http://hackage.haskell.org/package/witherable-0.1.2.1 (FumiakiKinoshita)
21:06:05 <tmobile> maurer: I once used this: flip flip () . (,,)
21:06:26 <dmj`> @typ flip flip () . (,,)
21:06:27 <lambdabot> a -> a1 -> (a, a1, ())
21:09:09 <EdTheOne> Does anybody know how to do this? Let u = [1,3,4,5,6,9] or whatever. Show that for every number there is a diff number such that there are no numbers inbetween. Its not for homework. so for example. i have this to check that there is a number that is as large as every number: ex1 u = and [or [y >= x | y <- u] | x <- u] 
21:13:36 <EdTheOne> dmj': you got an idea on how to do my problem? at all?
21:14:03 <tomberek> @EdTheOne: not sure what you mean
21:14:03 <lambdabot> Unknown command, try @list
21:15:52 <EdTheOne> so given a list of numbers, i want to show that for every number, there exists a different number, such that there are no numbers in betwee.
21:16:42 <dmj`> EdTheOne: in between what?
21:16:51 <mhitza> tomberek, I think what he wants is given a list like [1, 2, 3, 4, 5], when x = 1 and y = 2 there are no numbers in between so it satisfies the criteria. But when x = 1 and y = 3 is doesn't because 2 is in between
21:16:54 <EdTheOne> I did a similar one a while back that was a lot simpler. I never got this problem and its bugging me. Here is one I did: it was like: return True if there is a number as large as every number. 
21:17:07 <EdTheOne> this stuff seems so obvious. but the problem is getting haskell to actually prove it. 
21:17:46 <EdTheOne> the function would pass in a list and return either True or False
21:17:59 <dmj`> EdTheOne: does the 'different number' have to exist in the range of the given numbers?
21:18:02 <tomberek> EdTheOne, example?
21:18:13 <EdTheOne> our list can be [1,3,4,5] which would also be true
21:18:39 <mhitza> EdTheOne, does the list contain unique numbers and is assumed sorted?
21:18:54 <dmj`> EdTheOne: wouldn't 3 exist between 1 and 4 in that case?
21:19:01 <EdTheOne> its hard to even understand this lol
21:19:01 <tomberek> btw: anyone know of a partial ordering topological sort available in any library? Data.Graph.topSort is total ordering.
21:19:18 <EdTheOne> yes. it is sorted
21:19:24 <enthropy> is 1 in between 1 and 1?
21:19:33 <EdTheOne> no
21:20:27 <KaneTW> so f [1,2,3] should be False, and f [1,2,4] True?
21:20:32 <EdTheOne> so like i did this problem a while back For every even number, there is a greater odd number. this wouldnt work for u = [1..8]
21:20:47 <EdTheOne> no. 
21:20:53 <mhitza> EdTheOne, what would be "there exists a different number, such that there are no numbers in between" for 5 from the list [1,3,4,5]?
21:20:53 <EdTheOne> they should both be true
21:21:19 <KaneTW> what would be a example that gives False
21:21:29 <EdTheOne> my problem exactly with this question
21:21:42 <EdTheOne> mhitza, i think it would be true since there are no numbers between 4 and 5
21:21:43 <enthropy> repeat 1 -- would be false
21:21:58 <EdTheOne> hmm
21:22:01 <EdTheOne> thats interesting
21:22:04 <enthropy> or any list that doesn't have "a dif number"
21:22:12 <KaneTW> right
21:22:21 <KaneTW> but a nontrivial example where there are numbers in between
21:22:29 <KaneTW> would be more interesting*
21:22:43 <enthropy> > iterate (/2) (1 :: Rational)
21:22:45 <lambdabot>  [1 % 1,1 % 2,1 % 4,1 % 8,1 % 16,1 % 32,1 % 64,1 % 128,1 % 256,1 % 512,1 % 10...
21:23:47 <EdTheOne> this just seems like a silly question...
21:24:30 <EdTheOne> like my solution to "there exists a larger odd number" is ex1 u = and [or [y > x | y <- u, odd y] | x <- u, even x]
21:26:14 <EdTheOne> ^ for every even number..
21:26:52 <mhitza> EdTheOne, if the list is of unique numbers, then the only case it would be false would be if list length = 1, no ? :)
21:27:57 <EdTheOne> mhitza, or if the list is a repition of the same number. [1,1,1,1,1,1]
21:28:09 <EdTheOne> oh
21:28:10 <EdTheOne> unique
21:28:11 <EdTheOne> duh
21:28:15 <EdTheOne> nvm
21:28:39 <enthropy> > [1,3] ++ repeat 4 ++ [2]
21:28:41 <lambdabot>  [1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
21:29:10 <enthropy> it has to go to the end of the list to check if there's a number between 1&3
21:30:33 <EdTheOne> this question is rather confusing. the way that it is asked. thanks for ur help fellas.. 
21:30:47 <mhitza> EdTheOne, let satisfiesCondition l = not . (== 1) . length $ nub l
21:30:47 * hackagebot here 1.2.7 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.7 (TaylorHedberg)
21:30:47 <EdTheOne> but i am finished thinking about this. might just go crazy a lil.
21:35:14 <mhitza> EdTheOne, actually the only way that problem makes sense is if the list is unsorted and you have things like [3, 4, 10, 5] and if based on list position, where 5 would be invalid since 10 would be between it and 4, but 10 would be valid because the closest number is 5
21:55:03 <bramgg> Hey all, earlier today I shared 99 Haskell (http://99h.bram.gg/) here, a live coding problem site based on H-99 (https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems). As some people pointed out the questions weren't great, so I thought instead of being based on H-99 some people might like to help out and write new questions? It would be awesome if people with better understandings of the language t
21:55:09 <bramgg> han I helped. Again I hope this is appropriate here.
21:55:35 <Hijiri> maybe we should explain referential transparency by saying that haskell functions are equivalence homomorphisms
21:55:41 <Hijiri> that should help newcomers
21:56:09 <johnw> lol
21:56:33 <xnil> Hijiri: i'd like to learn haskell well enough to say things like that.
21:56:45 <xnil> how might i go about that, other than reading more books on the language?
21:57:15 <xnil> i mean, i'm able to write high-functioning programs in haskell just fine, but i'd like to be able to talk about it like that
21:57:19 <mhitza> is there an easy way to do early termination in MonadPlus?
21:57:44 <xnil> is there a field of mathematics to study?
21:57:52 <EvanR> xnil: theres a handful of books on math which you can get and do exercises in
21:58:02 <oconnore2> I don't think I understand Control.Failure.Failure. How do I catch a failure in lookup here https://github.com/selectel/yaml-config/blob/64b19404ad3fedfa8fd543f0b89c38af9ac9741b/src/Data/Yaml/Config/Internal.hs#L115 ?
21:58:03 <EvanR> a list of these would be nice
21:58:07 <xnil> ^
21:58:14 <dzack> ...you mean category theory?
21:58:26 <xnil> dzack: yes
21:58:34 <xnil> that's what i'm looking for
21:58:41 <EvanR> homomorphisms were first introduced to me in algebra
21:58:47 <EvanR> abstract algebra
21:58:51 <oconnore2> I can do things like "putStrLn =<< lookup "string" config", but I can't figure out the right syntax for a case statement
21:59:16 <dzack> yep, same. that'd probably be a good starting point, too
21:59:34 <ttt_fff> Currently, are the two only HS -> JS options Haste & GHCJS ?
21:59:52 <xnil> case myValue of {myPattern -> myStuff; myPattern2 -> myOtherStuff; ...}
21:59:53 <Hijiri> xnil: I started thinking of homomorphisms when doing haskell, but I was thinking of it today because I was doing awodey
21:59:54 <xnil> oconnore2: ^
22:00:25 <oconnore2> xnil: yeah, but I can't write a pattern because the Failure constructor is not exported
22:01:12 <xnil> oh, didn't see your first message
22:01:25 <oconnore2> xnil: I have a type: "s :: Failure KeyError m => m Config"
22:02:07 <RustyShackleford> does haskell allow function overloading?
22:02:25 <RustyShackleford> i.e. functions with different types, but with the same name
22:02:35 <xnil> RustyShackleford: not in the same module, no
22:02:37 <oconnore2> If it has a Config, I want to get the Config out, if it's a failure, I want to get the KeyError and do something with it. I can't seem to select between the two
22:02:39 <Axman6> type classes are the means of function overloading in haskell.
22:02:39 <RustyShackleford> not sure if it's called overloading in haskell
22:02:44 <xnil> Axman6++
22:03:02 <RustyShackleford> Axman6: how do you do that?
22:03:03 <EvanR> :t (+)
22:03:04 <lambdabot> Num a => a -> a -> a
22:03:05 <Axman6> but, don't do that unless you know it's a good idea; poorly designed type classes cause more problems than they're worth
22:03:06 <EvanR> ^ overloaded function
22:03:35 <xnil> RustyShackleford: to make a typeclass you might do
22:03:49 <mniip> :t printf
22:03:50 <lambdabot> PrintfType r => String -> r
22:03:54 <mniip> ^ overloaded function
22:04:22 * Axman6 class Func a b where f :: a -> b
22:04:54 <xnil> class Addable a where
22:04:57 <EvanR> class Whitespace 
22:05:02 <mniip> instance Func a b where f = unsafeCoerce
22:05:26 <RustyShackleford> xnil: oh okay, i knew you could do that
22:05:26 <xnil> class Addable a where addThree :: a -> a -> a -> a
22:05:43 <RustyShackleford> it's been some time since I've used haskell. I'm hardly an expert
22:05:49 * hackagebot network-anonymous-i2p 0.9.2 - Haskell API for I2P anonymous networking  http://hackage.haskell.org/package/network-anonymous-i2p-0.9.2 (solatis)
22:05:51 <xnil> instance Addable Int where addThree a b c = a + b + c
22:06:38 <xnil> addThree has the type
22:06:54 <xnil> addThree :: Addable a => a -> a -> a -> a
22:07:10 <xnil> though it should actually be
22:07:18 <xnil> addThree :: Addable a => a -> a -> a -> b
22:07:20 <xnil> and
22:07:28 <xnil> class Addable a where addThree :: a -> a -> a -> b
22:07:45 <mniip> forall b. ?
22:07:51 <xnil> maybe it is
22:07:57 <xnil> :t (+)
22:08:05 <xnil> uh, lambdabot?
22:08:07 <EvanR> addition is associative so you only need 2
22:08:18 <EvanR> its associative cuz i said
22:08:20 <RustyShackleford> how long did it take you to get the hang of haskell
22:08:31 <RustyShackleford> i'm not new to programming, but this really makes my head spin
22:08:43 <xnil> RustyShackleford: not very long honestly
22:08:47 <xnil> less than C++ took
22:08:54 <xnil> i still suck at C++
22:09:05 <RustyShackleford> not just the syntax, but the way you solve problems too
22:09:10 <mniip> the thing is that imperative programming experience helps very little when learning haskell
22:09:13 <xnil> same
22:09:14 <EvanR> it doesnt take very long to suck at c++
22:09:24 <xnil> mniip: unless you want to IORef everything
22:09:30 <RustyShackleford> yeah I always used imperative or OOP languages
22:10:02 <xnil> i am seriously considering IORef'ing an algorithm i can't seem to figure out in haskell right now
22:10:08 <xnil> and not using recursion
22:10:14 <mniip> xnil, at least try STRef?
22:10:23 <xnil> mniip: i dont know about it
22:10:29 <xnil> explain the differences, please
22:10:54 <johnw> ST only allows interaction with STRefs, no other IO
22:10:59 <mniip> RustyShackleford, yeah thing is, if you know, say, C, C++, Python, and Lua, learning Ruby would take another week tops
22:11:12 <mniip> none of the 5 mentioned languages helps when learning haskell
22:11:32 <xnil> my code uses no actual IO
22:11:44 <xnil> it parses text
22:11:49 <xnil> a String specifically
22:12:02 <lambdabot> Num a => a -> a -> a
22:12:02 <twhite> xnil: Sounds like a great place for a recursive solution. :) 
22:12:06 <xnil> but an iterative approach would be most efficient
22:12:10 <solatis> mniip, i must say that coming from a haskell backround, a lot of the other functional languages are a piece of cake
22:12:11 <xnil> twhite: yeah, yeah
22:12:16 <Hijiri> netsplit?
22:12:17 <RustyShackleford> holy netsplit
22:12:19 <xnil> dat netsplit
22:12:20 <Hijiri> it's not showing as a netsplit for me
22:12:24 <xnil> ^
22:12:24 <Hijiri> bad detection
22:12:24 <johnw> correction, you think it would be most efficient :)
22:12:24 <mniip> solatis, that is true
22:12:29 <solatis> (for example, discovering F# is extremely easy)
22:12:32 <mniip> Hijiri, not a netsplit
22:12:36 <xnil> johnw: yeah
22:12:40 <Hijiri> oh
22:12:42 <Hijiri> what is it then
22:12:43 <xnil> but in terms of brainpower required...
22:12:45 <Hijiri> this happens sometimes
22:12:47 <mniip> it's a mass ping timeout
22:12:49 <RustyShackleford> does the server kick idlers eventually?
22:12:56 <johnw> breaking your brain to think functional has two benefits
22:13:02 <Hijiri> so internet disrupted somewhere or something?
22:13:07 <johnw> one, you solve your problem in a functional way; two, you improve your ability to think functionally
22:13:08 <xnil> johnw: yeah it's just this one weird problem
22:13:12 <solatis> yes Hijiri 
22:13:12 <mniip> some connections broke
22:13:26 <xnil> i have no issue with it; the majority of the compiler i am writing is done functionally
22:13:29 <solatis> johnw, i still remember my first days with scala 1.5 year ago
22:13:32 <EvanR> internet disruption lol
22:13:34 <xnil> but this one little algorithm
22:13:34 <xnil> ugh
22:13:37 <mniip> but not the one that connects the server with the rest of the net
22:13:38 <twhite> xnil: What's the function signature again? 
22:13:40 <xnil> it's stumped me for 2 days
22:13:44 <solatis> "but.. if containers are immutable.. HOW DO I SOLVE THIS PROBLEM?!"
22:13:55 <solatis> it took me a while to be able to solve problems functionally :)
22:14:05 <xnil> twhite: Char -> Char -> String -> Int -> String
22:14:15 <xnil> solatis: yeah, but i have no issue with it most times
22:14:23 <mniip> solatis, same
22:14:25 <oconnore2> Why are there no articles online about Control.Failure?
22:14:27 <xnil> i have solved a ton of problems functionally
22:14:32 <solatis> xnil, not anymore no
22:14:36 <Hijiri> just use string-indexed variables, nothing could go wrong
22:14:38 <mniip> oconnore2, because it is a failure /s
22:14:47 <xnil> Hijiri: ?
22:14:49 <Hijiri> in a Map
22:15:04 <oconnore2> :)
22:15:22 <twhite> xnil: What is the goal of the function again? Looks simple enough to write recursively 
22:15:39 <Hijiri> imperative programming without even the safety that your variable exists
22:16:17 <oconnore2> is Control.Failure an Exception or an Error?
22:16:40 <mniip> Hijiri, Map String Dynamic
22:16:44 <mniip> :)
22:16:47 <xnil> twhite: to recurse over the elements of the String, adding 1 to a counter if the element is equal to the first Char, and decreasing by one if it is equal to the second Char. it's to match parens and get their contents
22:17:20 <mniip> xnil, care to provide the resulting type signature?
22:17:27 <xnil> twhite: Char -> Char -> String -> Int -> String
22:17:31 <xnil> mniip*
22:17:41 <mniip> what's the Int for?
22:17:46 <xnil> the counter
22:17:50 <xnil> it starts at 1
22:17:57 <xnil> if it reaches 0 then it returns
22:18:22 <mniip> if it always starts at 1 what's the point of making it a function parameter
22:18:42 <xnil> it starts at 1
22:18:47 <xnil> and when the function recurses
22:18:50 <xnil> it may increase or decrease
22:18:58 <xnil> and it continually increase or decrease
22:19:07 <mniip> the function can recurse into a binding inside the function's definition instead
22:19:11 <xnil> this function is called by yet another function, which generates the parameters
22:19:35 <xnil> hmm?
22:19:37 <xnil> example, please?
22:19:38 <mniip> twhite x y a = go x y a 1
22:19:43 <mniip>  where go = ...
22:19:55 <xnil> yes, that's what the parent function does
22:20:14 <mniip> ah well then I don't see the problem
22:20:15 <twhite> xnil: Think about writing a version of your function that only counts one kind of character  
22:20:26 <xnil> i did
22:20:28 <xnil> i used a case statement
22:20:42 <xnil> what freaking baffles me is that it doesn't stop, even when it reaches 0
22:20:51 <ProofTechnique> There was a neat discussion on one of the mailing lists about go being the common name for those auxiliary functions. I should find it again
22:20:56 <xnil> how do i debug haskell code
22:21:05 <xnil> i'd like to step through the program step-by-step
22:21:14 <xnil> i'm sure the issue is the result of a lack of sleep
22:21:21 <ProofTechnique> Can you post a gist?
22:21:34 <ProofTechnique> Also, there's a debugger in ghci, and there's trace
22:21:34 <twhite> http://lpaste.net/new/haskell could work too 
22:21:59 <xnil> ProofTechnique: https://gist.github.com/xnil/87ae9bfe60ee7a9e15ec
22:22:04 <mniip> twhite _ _ _ 0 = []; twhite x y (a:as) n | a == x = a : twhite x y as (n + 1); | a == y = a : twhite x y as (n - 1); | otherwise = a : twhite x y as n; twhite _ _ [] _ = []
22:22:07 <mniip> or something
22:23:11 <xnil> AST is defined as
22:23:23 <xnil> well hrm
22:23:30 <mniip> xnil, case doesn't do what you think it does
22:23:31 <xnil> just look at `getContained'
22:23:38 <xnil> what do i think it does?
22:24:04 <xnil> i think it returns an expression based on another expression being applied to a pattern
22:24:05 <mniip> > let foo = "hello" in case "bar" of foo -> foo
22:24:07 <lambdabot>  "bar"
22:24:20 <xnil> mniip: yes
22:24:24 <xnil> OH WOAH.
22:24:26 <xnil> SHIT
22:24:29 <xnil> sorry for my french
22:24:32 <ProofTechnique> xnil: I feel like this would be easier to reason about if you refactored some of those deeply nested wheres into top-level functions.
22:24:33 <xnil> my sleep
22:24:42 <xnil> ProofTechnique: it's fixed
22:24:45 <mniip> you want
22:24:52 <xnil> mniip: yes, yes i know
22:24:53 <mniip> case "bar" of x | x == foo -> foo
22:24:55 <xnil> i want guards
22:25:04 <xnil> wait, case allows guards?
22:25:06 <xnil> that's awesome
22:25:13 <ProofTechnique> Fixed? Like, you have to do it this way?
22:25:22 <xnil> ProofTechnique: it is corrected
22:25:25 <xnil> the problem is solved
22:25:28 <ProofTechnique> Oh, okay
22:25:30 <ProofTechnique> Awesome
22:25:35 <xnil> but yes i agree on your opinion
22:25:53 <ProofTechnique> Oh, I just saw your woah moment. :D
22:26:02 <xnil> > let foo = "hello" in case "bar" of x | x == foo -> foo
22:26:03 <ProofTechnique> What did you figure out?
22:26:04 <lambdabot>  "*Exception: <interactive>:3:22-54: Non-exhaustive patterns in case
22:26:23 <xnil> mniip: i'm confused.
22:27:07 <xnil> ProofTechnique: how to solve my problem! i was accidentally rebinding a name in a case statement instead of matching against the contents of a variable
22:27:14 <ProofTechnique> Ah!
22:27:52 <xnil> mniip: how does that case guard work?
22:28:10 <xnil> also i'll just remove the case statement and use guards all the way through
22:31:13 <xnil> wow, it actually solved the whole issue. thank you so much mniip
22:35:20 <xnil> i wish the typesystem could catch those sorts of bugs
22:39:28 <xnil> oop, now we have another issue
22:40:16 <ProofTechnique> Uh oh
22:41:30 <oconnore2> so I figured out my earlier issue. Is there a way to do it without using the IO monad? https://gist.github.com/oconnore/688c893505ccf6de42d5
22:45:10 <RustyShackleford> so a typeclass is what exactly?
22:45:30 <funfunctor> hi
22:45:33 <ProofTechnique> How exactly do you want?
22:45:34 <RustyShackleford> seems like it creates generic functions
22:46:01 <xnil> RustyShackleford: it does, sort of
22:46:07 <ProofTechnique> RustyShackleford: I recommend Oleg's article: http://okmij.org/ftp/Computation/typeclass.html
22:46:32 <RustyShackleford> thanks I'll read it
22:46:46 <ProofTechnique> jfischoff has a good post on FP Complete, too. https://www.fpcomplete.com/user/jfischoff/instances-and-dictionaries
22:47:16 <funfunctor> RustyShackleford: like Interfaces in OOP but at the type level and more powerful
22:47:29 <funfunctor> and more general
22:48:14 <ProofTechnique> @type try
22:48:15 <lambdabot> Exception e => IO a -> IO (Either e a)
22:48:36 <ProofTechnique> oconnore2: If you're using try, not really, it looks like.
22:49:15 <ProofTechnique> @hoogle Config +Data.Yaml.Config
22:49:17 <lambdabot> package ConfigFile
22:49:17 <lambdabot> package ConfigFileTH
22:49:17 <lambdabot> package Configger
22:49:35 <RustyShackleford> funfunctor: yeah I was going to say that
22:49:40 <oconnore2> ProofTechnique: is there a way to not use try?
22:50:26 <funfunctor> RustyShackleford: its best to practice some simple examples, Functor comes to mind
22:50:53 <funfunctor> RustyShackleford: but a simple example would be Num
22:51:16 <funfunctor> RustyShackleford: you how all kinds of types of numbers, but they belong to the class of number types
22:51:50 <ProofTechnique> oconnore2: What about just removing the try?
22:52:07 <funfunctor> RustyShackleford: just like you have a class of various monads so you end up with things like :: Monad m => a -> m a
22:52:28 <funfunctor> RustyShackleford: this is called a type-class constraint
22:52:35 <funfunctor> :t (+)
22:52:35 <lambdabot> Num a => a -> a -> a
22:52:40 <ProofTechnique> Maybe has a Monad instance, so your type would end up [Text] -> Config -> Maybe Config
22:52:41 <funfunctor> RustyShackleford: take a look at that
22:52:46 <ProofTechnique> Then you drop the extraneous returns
22:53:28 <funfunctor> RustyShackleford: it says the that function (+) is polymorphic up-to the type-class constraint Num
22:53:31 <ProofTechnique> I got confused because I didn't see that you had subconfig and subnconfig in there. 
22:53:49 <funfunctor> RustyShackleford: hope this helps
22:55:06 <oconnore2> ProofTechnique: ah, I used Either instead of maybe, but same idea: https://gist.github.com/oconnore/688c893505ccf6de42d5
22:55:09 <oconnore2> ProofTechnique: thanks
22:55:42 <ProofTechnique> Cool! No problem.
22:56:12 <RustyShackleford> funfunctor: thanks for the explanation
22:56:25 <RustyShackleford> although i havent a clue what a monad is yet
22:56:30 <RustyShackleford> i'm learning
22:56:48 <ProofTechnique> Don't let anyone tell you what a monad is. :D
22:57:15 <ProofTechnique> Just use some :)
23:00:37 <xnil> ProofTechnique++
23:00:51 * hackagebot Redmine 0.0.2 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.2 (cstpierre)
23:01:16 <funfunctor> RustyShackleford: for a maths guy, a monad is a bunch of axioms.. for a programmer, a monad is a unit of computation.. you enter it by 'return' and you 'bind' its result to the next unit of computation
23:02:02 <funfunctor> RustyShackleford: simply put, if you imagine you wrap up some unit of computation into a atomic step, you have a monad
23:02:09 <pacak> And for everybody else monad is a fuzzy thing, similar to burrito.
23:02:52 <funfunctor> RustyShackleford: the best one to start with is the Maybe monad, defined as follows  data Maybe a = Just a | Nothing
23:03:14 <xnil> funfunctor: can a monad not be thought of as a piece of data contained in a box (sort of a functor) by which one may inject computations into?
23:03:41 <xnil> or should it rather be thought of as a unit of computation
23:04:19 <xnil> oh, i see
23:04:25 <xnil> i was thinking backwards
23:04:28 <xnil> altogether
23:04:49 <funfunctor> Co-Monad
23:05:00 <xnil> what's...
23:05:11 <johnw> monads are not about data, they relate to type formers, like Maybe or [] or IO
23:05:20 <johnw> and how Maybe (Maybe a) can be related to Maybe a
23:05:33 <echo-area> Is bang pattern defined in Haskell 2010?  I didn't find it in the doc
23:05:33 <ProofTechnique> https://hackage.haskell.org/package/comonad-4.2.4/docs/Control-Comonad.html
23:05:47 <xnil> johnw: type formers = type constructors?
23:05:51 <johnw> sorry, yes
23:05:56 <xnil> gotcha
23:06:37 <ProofTechnique> > join (Just Nothing)
23:06:39 <lambdabot>  Nothing
23:06:41 <RustyShackleford> so i'm trying to write chess, my first task is to print out the game board
23:06:44 <ProofTechnique> > join (Just (Just 4))
23:06:45 <lambdabot>  Just 4
23:07:27 <johnw> so, thinking of a monad as something that exists in memory at runtime is very wrong
23:07:28 <RustyShackleford> rather, write a function that will return a string containing a crude graphical representation of the board
23:07:32 <funfunctor> > Just =<< Just 4
23:07:33 <lambdabot>  Just 4
23:07:50 <RustyShackleford> is there a good way to parameterize 64 things in a string?
23:08:10 <funfunctor> > Just =<< Just =<< Just 4
23:08:11 <lambdabot>  Just 4
23:08:12 <xnil> > return 4 :: Num a => Maybe a
23:08:13 <lambdabot>  Just 4
23:08:14 <johnw> the Monad instance for Maybe tells you that the structure of Maybe admits of monadic operations, like return and >>=, and so these functions are callable for any value of type Maybe a
23:08:31 <xnil> > return 4 :: Maybe a
23:08:32 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal ‘4’
23:08:32 <lambdabot>  Possible fix:
23:08:32 <lambdabot>    add (GHC.Num.Num a1) to the context of
23:08:37 <xnil> huh, neat-o.
23:09:07 <xnil> > return 4 :: Show a => Maybe a
23:09:08 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal ‘4’
23:09:08 <lambdabot>  from the context (GHC.Show.Show a)
23:09:08 <lambdabot>    bound by the inferred type of
23:09:11 <funfunctor> xnil: yep, thats right, return gets you into the Maybe context with the type class constraint of Num
23:09:17 <johnw> (well, return returns a Maybe a, it's not callable *on* a Maybe a)
23:09:23 <xnil> funfunctor: i know, i was just showing that
23:10:04 <xnil> > (return 4) :: Show a => Maybe a
23:10:05 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal ‘4’
23:10:05 <lambdabot>  from the context (GHC.Show.Show a)
23:10:05 <lambdabot>    bound by the inferred type of
23:10:07 <xnil> uwot
23:10:09 <xnil> m8
23:10:09 <echo-area> It seems 4.2.1 documents about !
23:10:15 <Axman6> you need Num a too
23:10:18 <Axman6> or just say:
23:10:26 <Axman6> > return 4 :: Maybe Int
23:10:27 <lambdabot>  Just 4
23:10:33 <xnil> that defeats the purpose ;_;
23:10:33 <funfunctor> RustyShackleford: ^ try some of the examples above in ghci and write them down, takes a while before you see so much meaning behind so little syntax
23:10:42 <xnil> > (return 4) :: Maybe Char
23:10:44 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
23:10:44 <lambdabot>    arising from the literal ‘4’
23:11:04 <Axman6> > return 4 :: (Num a, Show a) => Maybe a
23:11:05 <lambdabot>  Just 4
23:11:14 <xnil> Axman6: i know
23:11:29 <funfunctor> > return '4' :: Maybe Char
23:11:30 <xnil> but still, i was kinda hoping Show alone would be sufficient
23:11:30 <lambdabot>  Just '4'
23:11:48 <xnil> funfunctor: i wanted to convert it to char-code 004 or whatever
23:11:51 <johnw> of course, in this case you can always just say Just 4.  What is monadic about this is that "return" works for any value whose type was contsructed by a type constructor that is an instance of Monad
23:11:53 <xnil> like ascii value
23:12:05 <Axman6> how would it know what 4 is then? to be able to use the literal '4', you need a Num
23:12:14 <xnil> > return 4 :: Identity Int
23:12:16 <lambdabot>  Identity {runIdentity = 4}
23:12:18 <Axman6> 4 is not a character literal
23:12:35 <xnil> > return 4 :: Maybe Int
23:12:36 <lambdabot>  Just 4
23:12:47 <funfunctor> > import Data.Char
23:12:48 <lambdabot>  <hint>:1:1: parse error on input ‘import’
23:12:52 <xnil> > return 4 :: Either Int a
23:12:53 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal ‘4’
23:12:53 <lambdabot>  Possible fix:
23:12:53 <lambdabot>    add (GHC.Num.Num a1) to the context of
23:12:58 <xnil> > return 4 :: Either Int Float
23:12:59 <lambdabot>  Right 4.0
23:13:00 <funfunctor> xnil: look up chr
23:13:04 <xnil> woah, that's weird.
23:13:06 <funfunctor> chr :: Int -> Char
23:13:08 <xnil> > return 4 :: Either Int Char
23:13:09 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
23:13:09 <lambdabot>    arising from the literal ‘4’
23:13:13 <xnil> wat?
23:13:23 <xnil> return can't do Left?
23:13:34 <Axman6> no, of course not
23:13:38 <ProofTechnique> RustyShackleford: If you want crude, have I got the representation for you!
23:13:42 <Axman6> return = Right for maybe
23:13:51 <xnil> hmm
23:14:09 <xnil> > return 4 :: ST Int
23:14:10 <lambdabot>  Expecting one more argument to ‘GHC.ST.ST GHC.Types.Int’
23:14:10 <lambdabot>  Expected a type, but ‘GHC.ST.ST GHC.Types.Int’ has kind ‘* -> *’
23:14:18 <xnil> :k ST
23:14:19 <lambdabot> * -> * -> *
23:14:30 <xnil> > return 4 :: ST Int Int
23:14:32 <lambdabot>  <<ST action>>
23:14:33 <Axman6> perkaps it's time for you to pm lambdabot, you're making a lot of noise
23:14:41 <johnw> > return 4 :: forall s. ST s Int
23:14:42 <lambdabot>  <<ST action>>
23:14:44 <xnil> ok, sorry. i'm done.
23:15:09 <xnil> johnw: i've not seen much use of the forall syntax. does it come in handy much?
23:15:15 <johnw> indeed it does :)
23:15:34 <johnw> like when you want to pass around polymorphic things as values
23:16:03 <funfunctor> xnil: see existential type
23:16:32 <lpaste> ProofTechnique pasted “RustyShackleford” at http://lpaste.net/124767
23:18:08 <funfunctor> xnil: also see Monomorphism restriction
23:19:41 <funfunctor> johnw: i've mostly got my head around Pipes I believe
23:19:56 <johnw> nice
23:20:10 <johnw> when you think you've got it, dig into pipes-parse next
23:20:32 <johnw> and pipes-group
23:20:37 <ProofTechnique> We'll see how long that lasts. :D
23:20:53 <ProofTechnique> Also, is the mailing list really quiet lately, or have I just not been getting the messages?
23:20:57 <funfunctor> johnw: next question is, given my data stream flowing in from the Producer, how can I make sure data is timestamped?
23:21:05 <funfunctor> I sort of need a running clock or something
23:21:12 <johnw> how do you mean?
23:21:40 <johnw> you mean Producer (a, UTCTime) m r?
23:22:05 <ProofTechnique> The pipes mailing list, that is
23:23:57 <funfunctor> johnw: well no, I have ByteString coming from the radio right, with some meta data that contains the timestamp info.. now I am sure pipes-parse may help me with that perhaps.. But once I have that information I will need to associate bursts of data with the correspond timestamp and order them as they flow though the Pipes, having demodulation/modulation and filters applied along the way.. >-> demod >-> filter >-> ..
23:27:43 <funfunctor> idk if that makes any sense?
23:28:01 <johnw> not enough for me to have an opinion
23:28:21 <lpaste> xnil pasted “No title” at http://lpaste.net/124768
23:28:31 <xnil> i am having trouble with the above code.
23:28:52 <xnil> i included the error message, and if anyone needs it i will supply the desired output
23:29:24 <xnil> actually, the desired output is `[TContainer Option [TContainer Option [TTerminal (TermIdentifier "test")]]]'
23:30:19 <funfunctor> johnw: I just have to understand my problem more then..
23:30:23 <xnil> no, no, no
23:30:25 <xnil> i'm all wrong
23:33:51 <ab9rf> so just negate yourself and you'll be all right
23:34:52 <ProofTechnique> Then you'll be at least one right.
23:35:53 * hackagebot apiary 1.4.2 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.4.2 (HirotomoMoriwaki)
23:35:55 * hackagebot yesod-form 1.4.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.4.1 (MichaelSnoyman)
23:37:52 <gfixler> is newtype with record syntax the only vector for creating a Monad instance of a function a -> b?
23:38:39 <gfixler> more specifically, can I instance Monad (Foo a) where Foo is a type synonym?
23:39:46 <ProofTechnique> TypeSynonymInstances is a safe extension
23:39:57 <Hijiri> you can't partially-apply type synonyms though
23:40:02 <xnil> my whole problem was that i had typed `succ' instead of `pred'
23:40:11 <xnil> once again, sleep needs to happen
23:40:12 <ProofTechnique> xnil: Haha, that'll do it
23:40:30 <xnil> :P
23:50:34 <RustyShackleford> is there something like make for haskell?
23:50:44 <RustyShackleford> so I can build my project in one easy command?
23:51:05 <ProofTechnique> cabal build?
23:51:19 <ProofTechnique> There's also Shake.
23:51:24 <ProofTechnique> ?hackage shake
23:51:24 <lambdabot> http://hackage.haskell.org/package/shake
23:52:38 <pacak> RustyShackleford: ghc --make
23:56:06 <gfixler> ProofTechnique: TypeSynonymInstances hasn't been working :(
23:56:35 <RustyShackleford> what bugs me is removing the built object files
23:57:00 <RustyShackleford> it seems like ghc will not recompile your file if the object file already exists
