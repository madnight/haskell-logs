00:04:40 * cYmen__ learns how to use cabal.
00:06:55 * hackagebot filecache 0.2.8 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.8 (SimonMarechal)
00:08:50 * hackagebot monad-skeleton 0 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0 (FumiakiKinoshita)
00:08:50 * hackagebot filecache 0.2.8 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.8 (SimonMarechal)
00:29:07 <rtpg> is there a list anywhere of haskell projects that need a bit of love? bugfixes or the like
00:41:57 <hvr> rtpg: sure, http://hackage.haskell.org/packages/ >;->
00:44:41 <rtpg> pretty sure ACME is in need of a big update
00:52:38 <srid> is there a 4clojure.com equivalent for haskell?
01:03:02 <jstolarek> say I have a module that imports some function f and also defines another function called f
01:03:12 <jstolarek> I can use qualified import to disambiguate
01:03:25 <jstolarek> but is there a way to qualify current module?
01:03:32 <jstolarek> so that I can say
01:03:37 <jstolarek> THIS_MODULE.f
01:03:38 <jstolarek> ?
01:03:50 <cYmen__> you could just rename the function
01:03:57 <jstolarek> what if I couldn't?
01:04:16 <cYmen__> ignore me, I'm a newbie
01:04:27 <jstolarek> :-)
01:04:29 <jstolarek> that's ok'
01:04:45 <cYmen__> yes, that's just the disclaimer ;)
01:04:46 <jstolarek> I guess someone had to ask that question
01:08:25 <mauke^> jstolarek: well, you can use whatever the name of your module is
01:08:25 <srenatus> srid: is it like koans? https://www.fpcomplete.com/blog/2013/03/learning-through-koans
01:08:41 <cYmen__> Why do you want to qualify the current module anyway?
01:13:33 <decentdog> is there a way to specify in cabal.config (or elsewhere) that a local source should be preferred? I.e. I don't want to keep doing `cabal sandbox add-source <foo>` each time before I start work.
01:21:26 <funfunctor> hi
01:21:39 <funfunctor> who was interested in SPIR-V and Haskell again?
01:22:53 <capisce> funfunctor: sounds interesting
01:24:30 <funfunctor> capisce: someone wanted to work on something to do with it, I was thinking of writing a SPIR-V codegen in Haskell
01:24:51 <funfunctor> spare time sort of project
01:27:16 <mpickering>  v xc vbnmhtlo;['\]
01:35:03 <cYmen__> hm... in this line: makeCookie :: BS.ByteString -> BS.ByteString -> SetCookie what is the easiest way to find out what SetCookie is?
01:36:07 <arkeet> ghci's :info might help?
01:36:10 <arkeet> :i SetCookie
01:36:29 <arkeet> also hoogle might have it. http://hoogle.haskell.org/?hoogle=SetCookie
01:44:41 <cYmen__> thx
01:45:15 <cYmen__> who calls a type "setcookie"? :)
01:45:30 <cYmen__> or is that a "cookie which has been set"?
01:45:52 <arkeet> or "Data describing how to set a cookie"
01:45:56 <arkeet> I dunno.
01:46:22 <arkeet> it seems like that's what it is.
01:57:04 <yac> I seem to have a problem here https://github.com/yaccz/yac-build-server/blob/refactor-job-requests/library/YacBuildServer/Jobs.hs#L57
01:57:31 <yac> When the job finishes, the connection stayes open and the data I expect to be sent at line 55 never get there
01:57:34 <yac> I have no idea why
01:58:08 <Axman6> do you need to (or can you) flush the socket before closing it?
01:58:31 <sgronblo> cYmen__: the header is called Set-Cookie
01:58:48 <yac> actually that may be it
01:59:09 <yac> I suppose it is flushed automatically on newlines, which I'm missing I think
01:59:39 <jellie> Uh which package exports Monoid?
01:59:41 <yac> https://github.com/yaccz/code-samples-haskell-connection-counter/blob/master/main.hs here it's working fine
01:59:47 <arkeet> jellie: base.
02:00:20 <jellie> arkeet: Shouldn't that be imported by default in a .hs file?
02:00:28 <arkeet> you import modules, not packages.
02:00:50 <arkeet> Monoid is in the Prelude. 
02:00:56 <arkeet> so you don't even need to import anything to use it.
02:01:08 <jellie> arkeet: I thought so too but
02:01:15 <arkeet> it's defined in GHC.Base, but no one imports that.
02:01:19 <jle`> try the Data.Monoid package
02:01:22 <arkeet> Data.Monoid contains many useful functions related to monoids.
02:01:23 <Axman6> import Data.Monoid
02:01:28 <jle`> *module
02:01:32 <jle`> Data.Monoid module :)
02:01:38 <jellie> arkeet: Before Prelude import --> Not in scope: type constructor or class ‘Monoid'
02:01:58 <jle`> ghci tells me Monoid is defined in Data.Monoid
02:01:59 <jellie> arkeet: after --> Module ‘Prelude’ does not export ‘Monoid’
02:02:07 <jellie> jle`: Thanks
02:02:11 <arkeet> oh, it does in ghc 7.10
02:02:12 <arkeet> but did not before.
02:02:18 <jle`> times are a'changin
02:02:28 <jle`> i remember always having to import Data.Monoid
02:02:32 <jle`> :)
02:02:34 <jle`> those days are gone it seems
02:02:53 <arkeet> I guess I did too.
02:04:41 <jellie> arkeet: It does what in 7.10?
02:04:59 <arkeet> Prelude exports Monoid.
02:05:21 * jellie updates system and hopes 7.10 will be in it.
02:05:29 <jellie> I hope everything doesn't break
02:05:39 <jellie> arkeet: Do we lose the Data.Monoid module?
02:05:49 <arkeet> no.
02:06:14 <jle`> it probably exports Monoid because Foldable uses Monoid
02:06:16 <jle`> hm
02:06:22 <arkeet> I think so.
02:06:22 <jle`> or maybe it was just time
02:06:30 <jle`> :t sum
02:06:31 <lambdabot> (Num a, Foldable t) => t a -> a
02:06:33 <jle`> it's too real
02:06:38 <arkeet> haha
02:07:02 <jellie> naah ghc 7.10 isn't in the arch repos yet or something
02:07:17 <jellie> Is it out yet?
02:07:36 <Axman6> yes
02:07:37 <arkeet> too bad sum is still foldl (+) 0
02:07:39 <arkeet> and not foldl'
02:08:10 <jellie> Axman6: Okay let me see if I can ask someone in arch channels
02:08:23 <mauke^> > sum Nothing
02:08:25 <lambdabot>  0
02:08:27 <Axman6> it only came out in the last week or so
02:08:27 <yac> Axman6: yeah, that was it. https://github.com/yaccz/yac-build-server/commit/921a549650b1ef37ddddd06d57ded541e7590aba fixed it. Thanks
02:08:43 <Axman6> yac: excellent =)
02:08:56 <mauke^> might be slightly more efficient as 'shows xs "\n"'
02:10:19 <arkeet> jle`: this seems broken. http://blog.jle.im/
02:10:28 <jle`> yea heroku doesn't like me
02:10:30 <jle`> v.v
02:10:32 <jle`> thanks for the heads up
02:11:32 <jle`> thanks arkeet :)
02:12:08 <arkeet> yep it's back. :)
02:12:21 <cYmen__> sgronblo: ah, right
02:15:36 <yac> how can I flush the socket?
02:15:51 <Axman6> @hoogle flush
02:15:56 <lambdabot> Data.Text.Internal.Builder flush :: Builder
02:15:56 <lambdabot> Data.Text.Lazy.Builder flush :: Builder
02:15:56 <lambdabot> Data.ByteString.Builder.Extra flush :: Builder
02:16:07 <Axman6> @hoogle Socket -> IO ()
02:16:11 <lambdabot> Network.Socket close :: Socket -> IO ()
02:16:11 <lambdabot> Network sClose :: Socket -> IO ()
02:16:11 <lambdabot> Network.Socket sClose :: Socket -> IO ()
02:16:21 <yac> I looked at the network-2.6.0.2/docs/Network-Socket.html and don't see it
02:16:30 <Axman6> hmm, not sure, it may not exist
02:18:36 <ggVGc> I am trying to write a simple indentation parser based on this example(learning haskell as I go). How would I change main so that it processes several repetitions of aNamedList? https://gist.github.com/14238aa0d8df1e5c8fae
02:19:44 <yac> I guess I could disable buffering via hSetBuffering
02:19:55 <yac> but it's quite weird to not have flush
02:20:15 <Axman6> hSetBuffering works on Handles not Sockets doesn't it?
02:20:47 <yac> yeah, but it should work somehow
02:20:53 <yac> see the bottom at http://hackage.haskell.org/package/network-2.6.0.2/docs/Network.html
02:20:57 <arkeet> you can convert a socket to a handle.
02:21:13 <Axman6> well if you can do that then you should also be able to flush it =)
02:22:19 <yac> depends which accept apparently.
02:22:22 <yac> @hoogle accept
02:22:27 <lambdabot> Network accept :: Socket -> IO (Handle, HostName, PortNumber)
02:22:27 <lambdabot> Network.Socket accept :: Socket -> IO (Socket, SockAddr)
02:22:27 <lambdabot> Network.CGI data Accept a
02:23:00 <merijn> You can can also turn Socket into a Handle
02:23:09 <merijn> So it doesn't really matter which accept
02:23:23 <cYmen__> eek
02:23:30 <merijn> "socketToHandle :: Socket -> IOMode -> IO Handle"
02:23:46 <cYmen__> combination of $ and newlines instead of parens is confusing me :)
02:25:45 <yac> merijn: cool, thanks
02:35:07 <tsahyt> Can anyone shed some light on why ghc-mod suddenly stopped working after I did cabal install cabal-install lately (to 1.22 i think)?
02:35:20 <tsahyt> It's quite annoying as I'm now lacking pretty much all the code introspection in vim
02:36:38 <tsahyt> Alternatively, is there a clean way to downgrade cabal-install?
02:36:47 <teddet> wI am trying to install yesod. After typing "cabal install happy alex yesod-bin" it seems to install all three, but then running "yesod init --bare" results in "yesod: command not found". Any help greatly appreciated. 
02:36:58 <kadoban> tsahyt: ghc-mod can't work with recent cabal, unless you're also using ghc 7.10, IIUC.
02:37:56 <merijn> tsahyt: Because ghc-mod is tightly tied into cabal and thus fairly brittle
02:38:09 <tsahyt> kadoban: I've just found this issue https://github.com/kazu-yamamoto/ghc-mod/issues/417 which apparently says the same. Is there a way to downgrade cabal again?
02:38:32 <merijn> tsahyt: Chris Done is working on extending ghci with the necessary introspection tools so we can just use ghci and don't have to rely on brittle external tools
02:38:40 <kadoban> tsahyt: I dunno, I just reinstalled the world, but in my setup that's pretty easy to do.
02:38:42 <merijn> But I don't think he's looked at vim yet
02:39:05 <Axman6> teddet: do you have ~/.cabal/bin in your path (or ~/Library/Haskell/bin if you're on OS X)
02:39:09 <Axman6> ?
02:39:23 <tsahyt> merijn: That's good news. Someone will hack the vim part together I'm sure.
02:39:45 <tsahyt> kadoban: If I start reinstalling things, I might as well just upgrade to GHC 7.10.
02:39:59 <kadoban> Is 7.10 even out?
02:40:03 <Axman6> yes
02:40:17 <teddet> Axman6, I'm very new to all this, so I'm sorry, but I don't even know how to check what I have in my path. Can you please assist me?
02:40:19 <kadoban> Oh yeah? nice
02:40:25 <merijn> tsahyt: The nice thing is that you can use it in a sandbox aware way too: https://github.com/chrisdone/ghci-ng
02:40:29 <teddet> (I am on OSX Mountain Lion)
02:40:40 <Axman6> teddet: run this in your shell: echo $PATH
02:41:00 <Axman6> hmm, Mountain Lion is quite old, but should be ok
02:41:07 <teddet> Axman6, I got: /usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
02:41:16 <kadoban> So cool, I'll have to upgread sometime. Stackage probably won't work yet though, that'll suck.
02:41:32 <mauke^> teddet: oh, you're doing this as root?
02:41:49 <tsahyt> merijn: If only it had colored output too. That's the one thing I've been missing most from ghci lately. I've been running it through vim and abused vim to color the output but that's not exactly a nice solution.
02:42:13 <merijn> tsahyt: I remember seeing a patch for coloured ghci output sometime ago
02:42:20 <teddet> mauke^, I just opened a command line shell and followed the instructions to install yesod. I'm not sure what it means "doing that as root". 
02:43:31 <Axman6> teddet: can you run ls ~/Library/Haskell/bin and tell me if it lists anything?
02:43:32 <tsahyt> merijn: The only way I've seen was piping it through HsColour. To me that seems about as nasty as running it through vim
02:43:45 <Axman6> (yesod should be one of the things listed hopefully)
02:44:14 <teddet> Axman6: Yes, yesod is listed. 
02:44:21 <Axman6> teddet: ok
02:44:33 <Axman6> teddet: run 'open -t ~/.profile' and then add the line 'export PATH=~/Library/Haskell/bin:$PATH'
02:44:49 <tsahyt> And then there's this hack https://github.com/rhysd/ghci-color/blob/master/ghci-color, which does something similar using sed.
02:45:04 <Axman6> and then save the file, run 'source ~/.profile', and hopefully you should be able to use yesod
02:45:41 <teddet> Axman6: it claims profile does not exist when I try to open -t ~/.profile
02:45:56 <Axman6> run 'touch ~/.profile' first then
02:46:29 <teddet> Axman6: ok, touch went well. I'll now follow your instructions. 
02:48:04 <teddet> Axman6: it works!! :) Thank you so much!
02:48:15 <Axman6> no worries
02:48:42 <Axman6> also, now running 'cabal install cabal-install' should work; it would have broken before
02:53:57 * hackagebot tasty-golden 2.3.0.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.3.0.1 (RomanCheplyaka)
02:58:09 <tsahyt> yay, after having to put the whole project in a new cabal package, ghc-mod works again
03:09:24 <ggVGc> Can someone quickly explain the <> operator from Data.Monoid?
03:09:31 <arkeet> it is the same as mappend.
03:09:33 <ggVGc> I don't really get it from the documentation
03:09:40 <ggVGc> arkeet: well, what is mappend?
03:09:46 <arkeet> it's the monoid operation.
03:09:54 <arkeet> what it does depends on the monoid.
03:09:58 <ggVGc> right
03:10:01 <ggVGc> okay, thanks
03:10:10 <Axman6> > [1,2,3] <> [4,5,6]
03:10:11 <lambdabot>  [1,2,3,4,5,6]
03:10:12 <arkeet> > "abc" <> "de"
03:10:14 <lambdabot>  "abcde"
03:10:17 <arkeet> > Sum 2 <> Sum 3
03:10:19 <lambdabot>  Sum {getSum = 5}
03:23:26 <tsahyt> why does "(a,) if ... then .. else ..." not compile, but "(a,) $ if ..." does?
03:23:50 <tsahyt> with TupleSections enabled of course
03:24:46 <mauke^> > id do ""
03:24:48 <lambdabot>  <hint>:1:4: parse error on input ‘do’
03:24:50 <mauke^> > id $ do ""
03:24:51 <lambdabot>  ""
03:25:10 <mauke^> because the grammar is dumb, apparently
03:25:32 <tsahyt> hm. well okay. One more reason why ($) is magical
03:26:21 <arkeet> $ is pretty magical. https://mail.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html
03:26:24 <mauke^> no, any operator will do
03:26:37 <mauke^> > id `id` do ""
03:26:39 <lambdabot>  ""
03:26:47 <mauke^> > 42 `const` do ""
03:26:48 <lambdabot>  42
03:27:17 <arkeet> > show $ do pure 5 :: [Int]
03:27:18 <lambdabot>  "[5]"
03:27:41 <arkeet> > succ $ do read "5" :: Int
03:27:43 <lambdabot>  6
03:27:52 <arkeet> thanks shachaf.
03:34:00 * hackagebot ede 0.2.8 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.8 (BrendanHay)
03:44:50 <tsahyt> Is there a cleaner way to clip floating point values than "if f > 1 then (if f < 0 then 0 else 1) else f"?
03:45:01 <tsahyt> wait that's wrong anyhow
03:46:03 <tsahyt> if f > 1 then 1 else (if f < 0 then 0 else f)
03:46:09 <tsahyt> That should be it. Seems ugly though
03:47:45 <tsahyt> Nevermind, I can do it with guards and that's a lot nicer already.
03:49:14 <bergmark> Hackage trustee package curation! https://mail.haskell.org/pipermail/haskell-cafe/2015-March/118875.html
03:52:53 <huonw> tsahyt: `min 1 (max 0 f)` works too
03:57:58 <MrNosco> hello
04:00:06 <MrNosco> I was wondering something about pure vs return. If Monads were a subclass of Functors, would there be any need for return?
04:01:39 <Axman6> well, pure comes from Applicative. and no, not really
04:02:09 <MrNosco> oh yes, my bad
04:02:12 <MrNosco> Why not?
04:02:39 <Axman6> because i think the laws for the two essentially mean they have to do the same things
04:02:52 <MrNosco> yes
04:02:57 <Axman6> I could be wrong though. someone like edwardk would be able to articulate it
04:04:17 <MrNosco> I just think that, if you have a type which is an instance of Monad, it also has to be an instance of Applicative, so it needs to have an implementation of pure. And since return does the same as pure, we can just ommit an implementation of return
04:04:41 <tsahyt> As far as I know, return = pure by default now, isn't it?
04:05:14 <tsahyt> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#Monad See here.
04:05:17 <MrNosco> But then, why even have return? Is there a case where you would like them to do different things?
04:05:33 <tsahyt> Backwards compatibility. There's a lot of code with a lot of returns in it
04:05:41 <MrNosco> I see
04:05:42 <zinfandel> MrNosco: Historical reasons I guess
04:06:24 <MrNosco> well, thank you for the brief clarification
04:07:26 <tsahyt> I'm not quite sure whether the monad laws and the applicative laws can even be satisfied with two different implementations.
04:07:26 <jle`> MrNosco: Monad was in the standard libraries before Applicative
04:07:42 <jle`> so the main reason why we have both pure and return is historical
04:07:56 <jle`> Monad was actually there before Functor, even
04:09:10 <edwardk> MrNosco: return = pure holds. The AMP did not go out of its way to remove any of the now redundant members from the classes involved.
04:09:48 <tsahyt> edwardk: So the laws concerning return and pure enforce this?
04:09:58 <edwardk> MrNosco: We could in theory now work on making a transition whereby explicit redefinition of 'return' would become deprecated eventually, and then remove it from the Monad class entirely.
04:10:05 <ggVGc> based on this, how can I emit tokens called INDENT and DEDENT each time indendation changes? https://gist.github.com/7bcc817ab46ec6fc4144
04:10:07 <edwardk> tsahyt: yes
04:10:16 <ggVGc> my haskell is very bad, and this is my first real learning project
04:10:33 <jle`> there are examples of monad and applicative instances where the two produce the same results in the end, but the underlying implementations are very different
04:10:43 <edwardk> MrNosco: we haven't taken up that torch yet though, because well, frankly, folks just got access to Applicative as a superclass of Monad some time last week =P
04:10:55 <MrNosco> So, would it be seen as an ok practice to use pure instead of return always
04:11:17 <MrNosco> last week?! Wow, I must be psychic or something
04:11:19 <edwardk> MrNosco: So any such removal would be premature without a plan for how people could deal with supporting both Haskell before and Haskell after.
04:11:26 <jle`> the common example is a type where the Applicative instance gives you parallel operations, and the Monad gives you sequential operations
04:11:46 <edwardk> MrNosco: I mean the official 7.10.1 build. we had earlier builds before that for release candidates, etc.
04:12:11 <edwardk> jle`: sure, though i'm not aware of any of them where return and pure differ, merely (<*>) and (>>=);
04:12:29 <jle`> yeah, was going to correct myself heh
04:12:32 <jle`> i'm trying to imagine
04:12:33 <zinfandel> If my understanding is correct there is also no much difference between (*>) and (>>), right ?
04:12:44 <MrNosco> jle`: Implicitly having paralel vs sequential operations seems like a bad practice
04:12:45 <edwardk> zinfandel: that is another such case. the only difference is fixity
04:12:56 <jle`> MrNosco: not implicit...they'd be different functions
04:13:00 <Haskellfant> are there any plans for getting the ghc patches the fpco guys did for ide-backend upstream? I'm a bit reluctant to use a patched ghc
04:13:05 <edwardk> (*>) matches (<*>) in fixity, and (>>) is much lower (1?), down with (>>=)
04:13:06 <jle`> and different type signatures, too
04:13:22 <MrNosco> jle`: Yea, maybe implicit is not the best word for it, but it would not be obvious IMO
04:13:39 <Axman6> Haskellfant: what patches?
04:13:50 <jle`> not sure what you mean
04:13:56 <kqr> does any of the smaller lens packages (such as lens-family) include a way to update an element at a specific position in a list?
04:13:58 <jle`> in haskell it's common to have things like [IO ()], a list of IO actions
04:14:06 <jle`> and then chose to combine them into an IO () by sequencing them
04:14:15 <jle`> or, with a differen function, combine them into an IO () by executing them in parallel
04:14:19 <edwardk> kqr: lens does of course, but i don't think any of the others offer it
04:14:23 <jle`> they're different functions...sort of like (+) and (*)
04:14:31 <jle`> if you (+), you add...if you (*), you multiply :)
04:14:48 <Haskellfant> Axman6: it says here https://github.com/fpco/ide-backend/blob/master/setup/SETUP.md that one needs to install a patched version. but then I just tried cloning that repository and it doesn't even seem to exist
04:14:50 <Haskellfant> I'm confisude
04:14:54 <Haskellfant> *confused
04:14:56 <MrNosco> jle`: I mean like, there is nothing about return vs pure that implies they should operate differently, so having them do very slightly different things can be confusing
04:15:25 <jle`> ah
04:16:01 <zinfandel> When writing Applicative/Monadic code I always have to make a choice between (*>)/(>>) and pure/return
04:16:02 <Axman6> those two shouldn't do different things
04:16:07 <MrNosco> I mean, it would not cause bugs or anything, but it might lead developers to look for why is their code so much slower than that other code
04:16:11 <kqr> edwardk, yeah, I saw lens does that. I'm trying to wean myself off of depending on lens for small scripts because people are scared of the compilation times... but I don't see that happening as long as the alternatives don't provide lenses for things like that :(
04:16:15 <edwardk> MrNosco: the only cases that exist right now are places where folks have (<*>) and (>>=) acting differently in that (<*>) acts more efficiently in a manner we ignore up to some quotient on the monad involved.
04:16:17 <Axman6> but liftM2 and listA2 may behave differently
04:17:20 <MrNosco> hmm
04:18:16 <edwardk> MrNosco: in some cases you might have, say, a parsing combinator library for LL(1) grammars where if you stick to the applicative fragment you get hard linear time parsing guarantees, but you can use the monadic fragment to break out to LL(*)
04:18:55 <edwardk> in this case pure = return, but (>>=) is 'blind' in a fundamental way that prevents it from meeting the same guarantees we can supply for (<*>)
04:19:09 <edwardk> you could cripple (<*>) and get Parsec.
04:19:27 <edwardk> or you could just say that it opportunistically improves upon that model
04:19:50 <MrNosco> I don't really see how <*> can be equivalent to >>=
04:19:59 <edwardk> :t ap
04:20:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:20:04 <edwardk> :t (<*>)
04:20:05 <merijn> MrNosco: It's not possible to have pure and return be different without violating the laws
04:20:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:20:16 <edwardk> ap is (<*>) written in terms of return and (>>=)
04:20:24 <merijn> MrNosco: They're not equivalent, but >>= is more powerful and can thus be used to write <*>
04:20:53 <MrNosco> Oh, ok
04:21:01 <MrNosco> I can see that
04:21:10 <edwardk> (<*>) = ap is a law, but the question is is your monad a monad up to structural equality or some quotient
04:21:11 <merijn> MrNosco: "(x <*> y) = x >>= \f -> fmap f y"
04:23:02 <edwardk> lots of monads out there are implemented as quotients of types that are too specific to actually meet the laws if you consider what you could inspect, rather than what they do. is this a good idea? well, i tend to shy away from it, but there are places where its the only thing you can do
04:24:02 * hackagebot blaze-builder-enumerator 0.2.0.7 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.7 (SimonMeier)
04:25:13 <MrNosco> I feel as though I don't have enough experience to have a meaningful conversation about this
04:26:07 <MrNosco> I will just keep this in mind in the future
04:27:07 <MrNosco> Oh, are there any types in prelude where I should be midful about these differences between Aplicative and Monad?
04:34:37 <edwardk> MrNosco: no
04:34:51 <edwardk> MrNosco: nothing in the platform even
04:35:15 <edwardk> MrNosco: this is all the specialized domain of things like haxl
04:35:21 <edwardk> ad they are very rare
04:35:25 <edwardk> er and
04:35:55 <arkeet> edwardk: how goes the sleep? =)
04:36:32 <rudi_s> Hi. I have two threads handling a network connection (one to read, another to write). Can I notify/kill the write thread when the read thread dies?
04:36:59 <lpaste> cYmen pasted “typestypestypes” at http://lpaste.net/8177225652609482752
04:37:38 <cYmen__> Would somebody please look at that and explain it to me. It's just a common type error but I still don't understand them...
04:38:20 <kqr> edwardk, do you have a reference for how I would change a particular element of a list? stackoverflow references an 'inner' function which isn't in scope when I've imported Control.Lens
04:38:23 <arkeet> :t newStdGen
04:38:25 <lambdabot> IO StdGen
04:38:28 <arkeet> :t randomR
04:38:29 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
04:38:44 <mniip> :t randomRIO
04:38:45 <lambdabot> Random a => (a, a) -> IO a
04:38:52 <arkeet> :t randomR :: Random a => (a,a) -> StdGen -> (a,StdGen)
04:38:53 <lambdabot> Random a => (a, a) -> StdGen -> (a, StdGen)
04:39:19 <arkeet> cYmen__: you have to "run" the newStdGen action to get a StdGen you can pass to randomR.
04:39:40 <arkeet> (all this has to be done inside IO.)
04:40:29 <arkeet> e.g. do { g <- newStdGen; do something with randomR (3::Int,4) g }
04:40:32 <cYmen__> so randomR wants a RandomGen ...and ...wait what would a RandomGen in a Monad thingy look like again? IO Randomgen?
04:41:21 <arkeet> the only RandomGen around is going to be a StdGen.
04:41:39 <arkeet> newStdGen is an IO action that makes a new StdGen.
04:44:03 * hackagebot graph-core 0.2.2.0 - Fast, memory efficient and persistent graph implementation  http://hackage.haskell.org/package/graph-core-0.2.2.0 (AlexanderThiemann)
04:44:55 <ggVGc> with a tree structure like this, data Tree = Node [Tree] | Leaf String
04:45:20 <ggVGc> can I traverse it and detect when I get into a new level of the tree?
04:45:36 <merijn> Define "detect"
04:45:58 <arkeet> the answer is most likely "yes", whatever the question is exactly.
04:46:13 <hyPiRion> ggVGc: with traversable, you mean?
04:46:54 <arkeet> well, as written it can't be Traversable, since there is no type parameter.
04:47:49 <ggVGc> arkeet: as I mentioned earlier, what I am trying to do is use this, https://gist.github.com/e371553fb093c776fcf3 , and make it emit the strings INDENT and DEDENT whenever the tree depth changes
04:47:54 <ggVGc> but my haskell is not strong enough
04:50:04 <lpaste> cymen pasted “more types” at http://lpaste.net/8891801154309062656
04:50:11 <cYmen__> what!?
04:50:24 <cYmen__> where in this code is anything resembling a tuple of Int and StdGen?
04:50:34 <arkeet> :t randomR (3::Int,9) ?g
04:50:36 <lambdabot> (?g::g, RandomGen g) => (Int, g)
04:50:39 <arkeet> there's your tuple.
04:50:53 <arkeet> you have to do something with it.
04:51:23 <cYmen__> :t randomR
04:51:24 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
04:51:25 <arkeet> ggVGc: sorry, it's far too late for me to try to understand that. 
04:51:32 <arkeet> I ought to sleep
04:52:17 <merijn> cYmen__: The return value has type (Int, StdGen), instead of "IO (Int, StdGen)", you need to wrap the result of randomR with return
04:52:22 <arkeet> cYmen__: randomR (3,9) takes a generator, and returns a random number between 3 and 9, paired with a generators.
04:52:25 <arkeet> -s
04:52:34 <cYmen__> don't I need first?
04:52:45 <arkeet> (the returned generator is used if you want to generate further random values.)
04:52:46 <merijn> cYmen__: All lines in a do block have to be in the same monad (I usually recommend avoiding do-notation until you know how to write it without)
04:53:07 <arkeet> cYmen__: if all you want is to generate a single random value, randomRIO is fine.
04:53:10 <arkeet> :t randomRIO
04:53:11 <lambdabot> Random a => (a, a) -> IO a
04:53:19 <arkeet> no messing about with StdGens.
04:53:27 <cYmen__> but I want a list! :)
04:53:43 <merijn> :t randomRs
04:53:44 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
04:53:48 <cYmen__> merijn: next thing you're going to tell me I need to understand monads :p
04:53:59 <merijn> No, that bit isn't very helpful
04:54:02 <merijn> :)
04:54:16 <arkeet> (that produces an infinite list)
04:54:33 <merijn> :t randomRs (1, 2) (mkStdGen 5)
04:54:34 <lambdabot> (Num a, Random a) => [a]
04:54:40 <merijn> :t return $ randomRs (1, 2) (mkStdGen 5)
04:54:41 <lambdabot> (Monad m, Num a, Random a) => m [a]
04:54:51 <arkeet> > randomRs (1,2::Int) (mkStdGen 5)
04:54:53 <lambdabot>  [2,2,2,1,1,2,1,1,1,2,2,2,1,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,2,2,1,2,2,1,1,1,1,2...
04:55:19 <cYmen__> Now I have a fish. ;)
04:56:19 <arkeet> ok, well the point is that if you want to use the result of an IO action (namely newStdGen), you have to feed it to another IO action.
04:56:36 <merijn> cYmen__: I recommend reading this to see how do notation works: https://en.wikibooks.org/wiki/Haskell/do_notation
04:56:37 <cYmen__> right and to get a value out of an action you use return, right?
04:57:02 <arkeet> :t return
04:57:03 <lambdabot> Monad m => a -> m a
04:57:09 <arkeet> that makes an action from a plain value.
04:57:18 <arkeet> merijn: how about this? https://wiki.haskell.org/Introduction_to_IO
04:57:21 <cYmen__> oh so wrong way :)
04:57:56 <arkeet> you can use <- in do notation to bind a variable to the result of an action, but the only way you can use it is to pass it to another action.
04:58:25 <arkeet> do notation does kind of obscure what's actually going on.
04:58:39 <arkeet> at least in terms of the types of things.
04:58:41 <cYmen__> hm...indeed
04:59:03 <cYmen__> i am more than unhappy that this doesn't work do { return (fst (randomR (3::Int, 9) newStdGen)) }
04:59:15 <cYmen__> all I did was replace the g with its definition
04:59:27 <arkeet> well, <- is not equality or assignment.
04:59:43 <arkeet> when you see x <- a in a do block,
04:59:48 <cYmen__> that's why I said indeed, seems to obscure something alright
04:59:52 <arkeet> yeah.
05:00:05 <arkeet> ... a is some action, and x refers to the result of running that action.
05:00:26 <arkeet> well, have a look at those two links I guess.
05:00:36 <cYmen__> oh so g is a value and newStdGen is the action creating that value...I see
05:00:40 <arkeet> correct
05:00:49 <cYmen__> alright, I'll have a look
05:01:29 <arkeet> and you can't pass newStdGen to randomR, because randomR needs just a StdGen, not some action that promises to make one.
05:02:01 <arkeet> (because the types don't match.)
05:02:01 * mniip mumbles something about <$>
05:02:09 <arkeet> heh.
05:07:24 <jstolarek> how do I install a binary built inside cabal sandbox?
05:07:30 <arkeet> > evalState (sequence . repeat . state $ randomR (0,9)) (mkStdGen 0)
05:07:31 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
05:08:04 <zinfandel> jstolarek: Just `cabal install package_name` in the directory with your sandbox
05:08:18 <arkeet> that will install a package into the sandbox.
05:08:24 <jstolarek> exactly
05:08:33 <arkeet> are you hoping to build somethign inside your sandbox and install it outside?
05:08:34 <zinfandel> jstolarek: And the binary will be in .cabal-sandbox/bin/
05:08:43 <zinfandel> (if the package has any binaries)
05:08:44 <jstolarek> arkeet: yes
05:08:57 <arkeet> if it's an executable I guess you can just copy it out of there.
05:08:58 <jstolarek> not sure if that;s possible
05:09:02 <arkeet> if it's a library, that is probably a Bad Idea.
05:09:48 <arkeet> (if you try to use that library, the sandboxed versions of library's dependencies might differ from the user's versions.)
05:10:17 <jellie> What is the "TAGS" file for in a cabal project?
05:10:22 <mniip> interesting
05:10:26 <mniip> there's no repeatM
05:10:32 <arkeet> jellie: isn't that just a ctags file?
05:10:33 <hexagoxel> jstolarek: you can use --bindir and --datadir to specify sandbox-external location for the executable
05:10:43 <jellie> arkeet: I don't know.
05:10:52 <jstolarek> hexagoxel: oh, that looks like what I'm looking for 
05:10:52 <jellie> arkeet: I want to add it to .gitignore
05:10:53 <jstolarek> thanks
05:11:24 <arkeet> jellie: where did it come from?
05:11:30 <zinfandel> jellie: It's just an index of all definitions and their locations
05:11:44 <hexagoxel> jstolarek: see https://github.com/quchen/cabal-install-bin/blob/master/cabal-install-bin or https://github.com/lspitzner/cabal-exec-install/blob/master/cabal-exec-install.sh
05:11:45 <zinfandel> It can be used for "go to definition" in vim
05:11:55 <arkeet> if it's some auto-generated file like a ctags file, then sure I'd add that to .gitignore.
05:11:59 <jellie> arkeet: I don't know where it camm from but zinfandel seems to know about it.
05:12:10 <jellie> zinfandel: hmm weird because I use emacs
05:12:19 <zinfandel> arkeet: Well, someone generated it with certain tool
05:12:19 <arkeet> well, zinfandel just described what a ctags file is.
05:12:26 <arkeet> maybe emacs generates it automagically.
05:12:31 <arkeet> I don't use emacs so I dont' know.
05:12:32 <zinfandel> arkeet: I guess, emacs also can make use of it
05:12:43 <zinfandel> arkeet: Most editors support ctags
05:12:59 <zinfandel> arkeet: Vim was just an exampl
05:13:41 <arkeet> mniip: repeatM would be unproductive for many monads (IO, say). but I guess there's no reason for it not to exist.
05:13:46 <arkeet> :t sequence . repeat
05:13:47 <lambdabot> Monad m => m a -> m [a]
05:14:13 <mniip> arkeet, I don't see a problem with--
05:14:17 <mniip> oh, strictness in the baton
05:14:25 <zinfandel> jellie: It's up to you if you want to keep it in your repo or not
05:14:43 <arkeet> mniip: it can be made productive in IO with unsafeInterleaveIO, but that's IO-specific.
05:14:46 <arkeet> (and lazy IO is scary.)
05:15:05 <arkeet> but it seems perfectly fine in Reader or State or whatever.
05:15:22 <arkeet> (although in something like Reader it's the same as fmap repeat)
05:15:52 <arkeet> (exercise: figure out what "something like Reader" means exactly here)
05:16:35 <arkeet> (exercise: help me go to bed.)
05:16:38 <arkeet> bye.
05:16:54 <mniip> don't see anything other than ((->) e) that matches
05:31:48 <Jep> Hey, can someone explain to me why fmap (mapM_ print) (sequence [getLine, getLine, getLine]) will take my three lines of input but not then print them out? Is it because my final IO action looks like IO (IO [()]), or something like that? I know I can fix this by doing lines <- sequence [getLine, getLine, getLine] followed by mapM_ print lines, just wondering whyt he former doesn't work.
05:32:29 <haasn> For “infinite sequence of IO actions”, one way you can avoid the strictness problem is by restating IO [a] as [IO a] and deferring execution to whatever needs it. (Or perhaps make a type like T = IO (a, T))
05:32:47 <mauke^> :t fmap (mapM_ print) (sequence [getLine, getLine, getLine])
05:32:48 <lambdabot> IO (IO ())
05:33:01 <Bajtek> Hi! Should I always listen to "Please report this as a GHC bug"? As in, is this really really a bug?
05:33:05 <KaneTW> there exists a function Monad m => m (m a) -> m a
05:33:14 <tsahyt> :t join
05:33:15 <Bajtek> join
05:33:15 <lambdabot> Monad m => m (m a) -> m a
05:33:20 <tsahyt> This one
05:33:20 <Jep> Aha, so not quite IO (IO [()])
05:33:22 <mauke^> Jep: you never told it to print anything
05:33:29 <Jep> I didn't?
05:33:32 <mauke^> nope
05:34:04 <Jep> Because the IO action wasn't performed because it's held in another IO action?
05:34:06 * hackagebot cabal-debian 4.24.8 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.24.8 (DavidFox)
05:34:13 <Bajtek> anyway what I tried to do was running example of GHC Api on... itself
05:34:15 <Bajtek> and it panicked
05:34:20 <Jep> I don't understand why mapping print over the strings didn't print them
05:34:21 <mauke^> "held in" ... :-/
05:34:31 <mauke^> Jep: because functions are pure
05:34:36 <haasn> Jep: It's returned by another IO action, but this result is never executed
05:34:43 <Bajtek> Jep: because then you get a list of functions printing a string
05:34:53 <mpickering> Bajtek: If you're using the GHC API and you pass in junk then it generally causes a panic
05:35:05 <Bajtek> mpickering: so that's nothing worth reporting?
05:35:12 <mpickering> Bajtek: What were you trying to do? I would generally consider a panic caused by using the API to be user induced
05:35:40 <haasn> Jep: (IO String) somehow “holding” a String is a misconception
05:35:41 <Bajtek> I took example 4 from there https://wiki.haskell.org/GHC/As_a_library and run A on A.hs
05:35:46 <merijn> Jep: IO actions don't get always get executed, they're effectivelly first class IO operations
05:36:17 <mauke^> I'm not sure "effectively first class IO operations" is meaningful
05:36:29 <merijn> Jep: So "[IO ()]" is a list of IO actions. The only action that ever gets run is "main" (and any directly hooked onto/into main using >> and >>=)
05:36:35 <mpickering> Bajtek: look at this line -  modSum <- getModSummary $ mkModuleName "B"
05:36:41 <Bajtek> oh lol
05:36:44 <mpickering> the module name "B" is hard coded in so you get the panic
05:37:07 <Bajtek> yeah I haven't even read the thing yet, but the "please report this as a bug" got me wondering
05:37:22 <Jep> Huh. I guess I understand, only just started learning Haskell and I guess I'm still a newbie full of misconceptions. How would I go about taking an IO [a] and printing out each 'a' on a separate line then, without first doing something like as <- {the IO [a]}?
05:37:29 <Bajtek> mpickering: thanks
05:37:32 <haasn> Jep: A good way to think about IO is to think of (IO String) like a program that returns a String when executed. A comparison can be made to /bin/ls, which is a program that, when executed, gives you a list of files - but the program itself doesn't really “contain” that list. Similarly, a value of type IO (IO String) might be like a program that prints the source code to /bin/ls when it runs. Does that
05:37:34 <haasn> make sense?
05:37:34 <merijn> :t (>>=)
05:37:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:37:44 <merijn> Or rathher
05:37:56 <mauke^> Jep: you don't
05:38:06 <merijn> :t (>>=) :: IO [String] -> ([String] -> IO ()) -> IO ()
05:38:07 <lambdabot> IO [String] -> ([String] -> IO ()) -> IO ()
05:38:19 <merijn> That's probably the type you were looking for
05:38:30 <merijn> :t sequence [getLine, getLine, getLine]
05:38:31 <lambdabot> IO [String]
05:38:33 <mada> what does it mean for the signature of a function to say 'forall b. ···'?
05:38:33 <mauke^> Jep: <- is syntactic sugar for a call to >>=
05:38:36 <haasn> Jep: “<-” is just syntax sugar for (>>=), and that's the only way to chain one monad action (“program” in IO) into another. So “without using ->” is just playing around with words
05:38:39 <merijn> :t mapM_ print
05:38:39 <lambdabot> (Show a, Foldable t) => t a -> IO ()
05:38:40 <mauke^> Jep: and >>= is a combination of fmap and join
05:38:43 <haasn> or rather, playing around with syntax
05:38:45 <Bajtek> Jep: a <- x; b a is shorthand for x >>= b
05:38:54 <merijn> :t sequence [getLine, getLine, getLine] >>= mapM_ print
05:38:56 <lambdabot> IO ()
05:38:56 <Bajtek> well, "shorthand"
05:39:04 <Jep> Ah! Okay I think I'm getting it. Thanks guys :)
05:39:24 <Jep> (and/or gals)
05:39:39 <merijn> mada: Usually nothing :) forall is an artifact of the internal language used in GHC which requires explicit bindings for type variables
05:39:55 <merijn> mada: "id :: forall a . a -> a" this is identical to "id :: a -> a"
05:40:22 <merijn> mada: Literally it's just saying "for all types 'a', id has type 'a -> a'"
05:40:39 <haasn> Jep: So to go back to your example: “getLine” is a program that, when executes, does something (user I/O) and then returns a String. “sequence [getLine, getLine, getLine]” is a program that, when executed, does that three times in a row and then returns all three results as a list of strings. “fmap f x” is a program that, when executed, executes ‘x’ and then applies ‘f’ to the result.
05:41:13 <mada> merijn: I somehow ended up on Dan Piponi's blog post about the Yoneda lemma, and there's this signature:  uncheck1 :: (forall b . (a -> b) -> b) -> a
05:41:37 <mada> that 'forall b.' seems to be 'scoped' to the function argument
05:41:41 <mauke^> that means uncheck1 takes a polymorphic function as an argument
05:41:56 <mauke^> rank-2
05:41:59 <merijn> mada: Right, this is an example of a RankNType
05:42:10 <merijn> mada: The difference is "who gets to pick 'b'"
05:42:19 <haasn> Jep: But the thing is: “print x” is itself just a program that, when executed, prints out x. For the sake of simplicity, let's ignore the list and just consider “fmap print getLine”. When executed, this gets a line of input, takes the resulting string and returns “print "that string"”. So unless you actually execute this “print "that string"” program, nothing happens after that
05:42:32 <merijn> mada: in "id :: forall a. a -> a" the CALLER of 'id' gets to pick 'a', because id promises to work for ANY 'a'
05:42:37 <mada> couldn't you just write uncheck1 :: ((a -> b) -> b) -> a ?
05:43:01 <merijn> mada: In "uncheck1 :: (forall b . (a -> b) -> b) -> a" the CALLEE (i.e. something inside uncheck1!) gets to pick the type 'b'
05:43:32 <merijn> mada: No, because with that type I could pass "(Int -> Bool) -> Bool" to uncheck1
05:43:37 <mauke^> > let mada :: forall a. (a -> a) -> (Char, String); mada f = (f 'A', f "hello") in mada id
05:43:39 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘a’
05:43:39 <lambdabot>        ‘a’ is a rigid type variable bound by
05:43:39 <lambdabot>            the type signature for mada ∷ (a → a) → (Char, String)
05:43:40 <haasn> Jep: For the solution: “x >>= f” is a program that, when executed, first executes ‘x’, then applies f to the result, then executes *that*, then returns the final result. So “getLine >>= print” works like this: first “getLine” gets executed, then ‘print’ gets applied to the result (print "that string"), then this function is executed, and its result (which is just () in the case of print)
05:43:43 <haasn> gets returned
05:43:43 <merijn> mada: The current notation that's not allowed
05:43:46 <mauke^> > let mada :: (forall a. a -> a) -> (Char, String); mada f = (f 'A', f "hello") in mada id
05:43:47 <lambdabot>  ('A',"hello")
05:44:00 <mauke^> ooh, unicode output
05:44:35 <merijn> mada: uncheck1 is saying "IF you give me a function that can turn an 'a' of YOUR CHOICE into ANY 'b' of MY CHOICE, THEN I'll give you an 'a'"
05:44:58 <merijn> mada: "BUT, I'm not going to tell you in advance which 'b'!"
05:45:20 <merijn> But yeah, see also mauke^'s example
05:45:20 <Jep> haasn: Thanks so much man, that's made it much clearer for me :)
05:45:21 <haasn> Jep: so re-introducing the lists, the result would be: sequence [getLine, getLine, getLine] >>= mapM_ print
05:45:26 <mada> this is tough to grok
05:45:37 <mauke^> yes :-(
05:45:42 <mada> :>
05:46:01 <jellie> jle`: Hey, in your Seen bot module did you get an issue with UTCTime not being an instance of Serialize?
05:46:01 <haasn> Jep: for the reference: the only way to “execute” something in Haskell is to define it as ‘main’. :)
05:46:29 <merijn> mada: Oh, I actually have an example lying around already
05:46:41 <haasn> but of course, if your “main” is “main = a >>= b >>= c” then executing ‘main’ will also entail executing a, b and c
05:46:44 <merijn> mada: https://gist.github.com/merijn/77e3fa9757658e59b01d
05:46:53 <mauke^> > id :: Int → Int
05:46:54 <lambdabot>  <Int -> Int>
05:46:57 <mauke^> sweet
05:47:31 <mada> merijn: thank you
05:47:48 <mauke^> > id ∷ Int → Int
05:47:50 <lambdabot>  <Int -> Int>
05:47:50 <merijn> mada: Do you see why the first example there can't work? It's because "Num a => (a -> a)" claims to work for ANY function 'a -> a' where 'a' is a num instance, but suppose I pass in "(+1) :: Int -> Int", that clearly doesn't typecheck with the Double case, right?
05:48:25 <merijn> mada: The second type states "it's not enough to work for A Num instance, you have to work for ALL Num instances"
05:48:33 <mada> right
05:49:04 <Jep> haasn: Right. I think I get it. I need to throw away some of the analogies I've been using I think, probably they're doing more harm than good. I am off to go play with more Haskell, thanks again :)
05:49:10 <mada> merijn: is "forall a . Num a =>" a sort of 'composition' of type constraints?
05:49:27 <mauke^> no, forall isn't a constraint
05:49:34 <merijn> mada: Not so much, it's more like the maths qualifier forall
05:49:36 <mada> ah ok
05:49:42 <merijn> mada: The dot is just a separator
05:49:47 <mada> yeah didn't see "forall b ." was there before.
05:49:51 <mauke^> forall "declares" type variables, sort of
05:50:21 <jellie> What is the Generic typeclass for exactly?
05:50:29 <merijn> mada: An alternate view is: Consider "forall a . a -> a" as a type level function that takes a type as argument and returns a type
05:50:45 <merijn> mada: i.e. applying "forall a . a -> a" to Int returns "Int -> Int"
05:50:53 <haasn> Jep: Feeling like you need to throw away your existing thought models is a good sign when it comes to learning Haskell.
05:51:06 <mada> so in the second case, that forall a. states that you should pass mangle a function that *itself* works for all a (+ Num a)?
05:51:08 <merijn> The position of the 'forall' then indicates who gets to pass in the type argument
05:51:17 <merijn> mada: Correct
05:51:19 <jellie> I'm looking for pointers on making a Generic instance for UTCTime
05:52:00 <mada> merijn: I can kind of see that. The Int/Double/(+1) example helped clear that up a lot
05:52:08 <merijn> mada: No problem :)
05:52:42 <merijn> I should improve it a little, since (+1) does work for both, I should use "div 2" and (2/) as example...
05:52:44 <mada> thanks! cc mauke^  :)
05:52:47 <merijn> Since those don't work
05:52:55 <f-a> I am getting some trouble with parsec, parsing a string (like, a string with quotes) If I pass it "\"hey\\\"you\"" it only consumes hey\\. Is there a way to tell parsec "please ignore \" ?"
05:53:48 <jellie> jle`: How come you didn't have to write a generic instance for UTCTime for trackSeens to work?
05:53:56 <mauke^> f-a: what does your parser look like?
05:54:07 * hackagebot base-compat 0.6.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.6.0 (SimonHengel)
05:54:09 * hackagebot errorcall-eq-instance 0.2.0 - An orphan Eq instance for ErrorCall  http://hackage.haskell.org/package/errorcall-eq-instance-0.2.0 (SimonHengel)
05:54:40 <f-a> mauke^: codeString = (quote *> manyTill anyChar quote)
05:54:47 <mauke^> f-a: ...
05:54:48 <f-a> where quote is char '"'
05:54:53 <mauke^> what did you expect
05:55:15 <f-a> well, I thought " was different that \"
05:55:23 <mauke^> \ is anyChar
05:56:20 <mauke^> quote *> many ((char '\\' *> anyChar) <||> noneOf "\"\\") <* quote
05:56:30 <mauke^> won't handle escape sequences like \n, though
05:59:09 <f-a> thanks mauke^ , I will play with it a bit
06:01:10 <mauke^> this is basically "(?:\\.|[^"\\])*"
06:07:25 <dramforever> whoa
06:07:30 <dramforever> just checked logs
06:07:48 <dramforever> ImplicitParams can be used like holes!
06:08:06 <dramforever> > ?f `fmap` [1,2,3]
06:08:07 <lambdabot>  mueval-core: internal error: PAP object entered!
06:08:08 <lambdabot>      (GHC version 7.10.1 for x86_64_unknown_linux)
06:08:08 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
06:08:14 <dramforever> ouch
06:08:20 <dramforever> :t ?f `fmap` [1,2,3]
06:08:21 <lambdabot> (Num a, ?f::a -> b) => [b]
06:09:33 <dramforever> wait a sec...GHC bug?? looks like mueval (or something under it) doesn't really know about implicit params
06:10:40 <merijn> No, it tries to run a non-existent param ?f, which caused it to enter a PAP, which is not supposed to be possible
06:11:43 <berndl> Newbie question: How would I go about defining a restricted version of one of the basic types? For example, how would I define the type Even of even integers?
06:12:06 <dramforever> merijn: oh what's a PAP then
06:12:30 <merijn> Partial Application something
06:12:41 <merijn> It's for compiling function application
06:12:55 <dramforever> merijn: so mueval (or something else below it) should have reported an error before letting it run?
06:12:55 <merijn> berndl: That's not really possible, but kinda fakeable
06:13:00 <merijn> dramforever: Yes
06:13:31 <merijn> berndl: You can define a newtype (will have the exact same runtime representation), hide the constructor (so no one can create them) and export a "smart constructor" (i.e. construction function)
06:13:33 <dramforever> berndl: how? can you give an example? (We are/I am not sure what are you trying to do)
06:14:02 <berndl> I think I found my answer: http://brianmckenna.org/blog/evenodd_agda_idris_haskell_scala
06:14:25 <merijn> berndl: For example "module Even (Even, mkEven) where newtype Even = Even Int; mkEven :: Int -> Maybe Even; mkEven i = if even i then Just (Even i) else Nothing"
06:14:58 <dramforever> merijn: I don't know, but how about newtype Even = Even Int so that Even a behaves like 2*a?
06:15:18 <dramforever> could be bad, I don't know
06:15:29 <zinfandel> dramforever: You need to define an instance of Num for Even
06:15:51 <dramforever> zinfandel: oh sure
06:15:54 <dramforever> yeah...
06:16:10 <berndl> So basically, I have to define my type from scratch in Haskell.
06:16:11 <zinfandel> dramforever: But I am not sure what you mean by "Even a behaves like 2*a"
06:16:25 <jellie> Do I need to make any import to use the "proc" syntax? I'm getting a parse error on `->`
06:16:29 <berndl> I can't really just restrict the Integer type to even numbers.
06:16:33 <dramforever> Even x * Even y = Even (2 * x * y)
06:16:39 <dramforever> fromEven (Even x) = 2*x
06:16:44 <dramforever> and so on
06:17:02 <dramforever> jellie: {-# LANGUAGE Arrows #-} on the top of your file
06:17:03 <dramforever> that is
06:17:23 <zinfandel> dramforever: Why do you have to multiply it by two?
06:17:30 <dramforever> below module header comments (If you have one), above "module Blah where"
06:17:37 <dramforever> zinfandel: even numbers!
06:17:59 <dramforever> okay It's a bad idea
06:18:17 <zinfandel> dramforever: Well, 2 * 4 == 8
06:18:29 <zinfandel> 2 * 4 /= 2 * 4 * 2
06:18:31 <zinfandel> right?
06:18:38 <dramforever> zinfandel: that would be Even 1 * Even 2 = Even 4
06:18:48 <dramforever> okay okay okay
06:18:53 <dramforever> bad idea after all
06:18:59 <zinfandel> dramforever: If you multiply even numbers by each other the result would be even
06:19:09 * hackagebot overture 0.0.4 - An alternative to some of the Prelude.  http://hackage.haskell.org/package/overture-0.0.4 (fozworth)
06:19:12 <zinfandel> so, Even x * Even y = Even (x * y)
06:19:14 <dramforever> BAD IDEA. PERIOD
06:20:27 <jellie> dramforever: Thanks
06:23:03 <dramforever> Hi...Um...
06:23:34 <dramforever> I'm still pretty interested in lens, can anyone recommend some reading materials?
06:23:48 <johnw> dramforever: how much do you know now?
06:24:09 * hackagebot c2hs 0.25.2 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.25.2 (IanRoss)
06:24:26 <dramforever> johnw: I think I know how do Lens compose and how to construct and how to get/set with it
06:24:33 <johnw> dramforever: a very beginner intro is here http://newartisans.com/2012/11/getting-started-with-lenses/, although I never finished it
06:24:37 <dramforever> I mean, that var laarhoven lens
06:24:59 <johnw> then I would watch http://ftp.newartisans.com/pub/Lenses.mp4
06:25:14 <johnw> and then https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
06:25:19 <dramforever> but I don't want usage examples, I want some theory
06:25:31 <johnw> you could read var laarhoven's blog articles
06:25:39 <johnw> this is theoretical: https://www.fpcomplete.com/user/tel/lenses-from-scratch
06:27:21 <dramforever> oh and I'd really like some more about Prism, Traversal, etc.
06:27:42 <johnw> try https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
06:27:48 <johnw> good explanation of them in context of usage
06:27:51 <dramforever> hmmm...
06:27:58 <dramforever> johnw: thanks...
06:28:21 <dramforever> lol it does seems you have a file/folder of lens article links
06:28:27 <dramforever> wait they are all fpcomplete
06:28:29 <johnw> it's called Google, actually
06:28:42 <johnw> I take your question, I type it into the search box, I copy&paste the link for you :)
06:28:43 <dramforever> johnw: good for you. google blocked here
06:28:50 <johnw> are you in China?
06:28:54 <dramforever> correct
06:29:02 <johnw> oh wow, they block Google but not IRC?
06:29:19 <dramforever> johnw: I don't think "they" know what's IRC
06:29:29 <Xe> johnw: it's all okay as long as we don't link dramforever to the bible or the koran
06:29:58 <dramforever> Xe: Heh? I think those are okay in China
06:30:07 <Xe> they aren't iirc
06:30:22 <johnw> they should just block searches like, "How do I overthrow my regime in 10 days or less?"
06:30:41 <narendraj9> dramforever: duckduckgo?
06:30:49 <dramforever> johnw: a while ago they would block searches containing sensitive words
06:30:55 <dramforever> narendraj9: blocked.
06:31:03 <dramforever> now it's whole site
06:31:15 * dramforever led us off topic
06:31:49 <isocliff> Can anyone tell me if something in particular happened to "lift" in 7.10?
06:31:58 <lpaste> Aruro pasted “LLVM error” at http://lpaste.net/129910
06:32:17 <Aruro> guys please take a look at this error
06:32:23 <Aruro> tyring to install diagrams
06:32:35 <Aruro> have arch and just installed llvm
06:32:51 <Aruro> http://lpaste.net/129910
06:33:11 <dramforever> Xe: how long have "they" "blocked" bible/koran?
06:33:12 <fryguybob> Aruro: You can install arithmoi-0.4.1.1 with the flag -f-llvm (I think) and it will avoid using llvm
06:33:25 <narendraj9> I have a question. How do I prove (pure f <*>  u) = (pure (flip ($)) <*> u <*> pure f)?
06:33:25 <Aruro> ok
06:33:31 <Aruro> its a cabal flag?
06:33:36 <fryguybob> Aruro: Yes
06:33:40 <Aruro> let me try
06:33:41 <mniip> narendraj9, ohh I remember that one
06:33:58 <narendraj9> mniip: I understand what it does. 
06:34:03 <fryguybob> Aruro: That is it is a flag for the cabal package, not a cabal flag directly
06:34:18 <narendraj9> mniip: But I can't seem to find out how to derive it from the Applicative laws.
06:34:35 <dramforever> because I think I have a copy of the bible here, bought as an English reading material (with Chinese translation so I'm pretty sure "they" know what it says)
06:34:39 <Aruro> so cabal install flag package?
06:35:05 <mniip> narendraj9, one way to do this is to go through functor
06:35:11 <narendraj9> mniip: You have done it? Any hints? I don't want the answer straight if hings can lead me to it.
06:35:26 <dramforever> Aruro: for example with a flag called foo-bar, enable it: cabal install pack -ffoo-bar
06:35:34 <narendraj9> mniip: fmap f ma = pure f <*> ma?
06:35:35 <dramforever> disable: cabal install pack -f-foo-bar
06:35:37 <mniip> yeah I proved that too when was reading typeclassopedia
06:35:39 <mniip> and yes
06:35:59 <Aruro> ty guys
06:36:14 <narendraj9> mniip: Okay. Will try again.
06:36:16 <Aruro> cabal install diagrams -f -llvm
06:36:19 <Aruro> did not work
06:36:23 <Aruro> still asks for it
06:36:42 <dramforever> Aruro: no space
06:36:45 <dramforever> seriously
06:37:02 <dramforever> cabal install diagrams -f-llvm
06:37:17 <dramforever> oh maybe space-ful one also right...dunno
06:37:26 <Aruro> no change
06:37:30 <dramforever> ok
06:37:32 <zinfandel> Aruro: I prefer simpler syntax for flags `cabal install package-name -f "foo bar -baz -qux" (this will enable flags foo,bar and disable baz,qux)
06:38:00 <dramforever> Aruro: can you post full error message?
06:38:13 <dramforever> I mean, full output
06:38:21 <Aruro> http://lpaste.net/129910
06:38:38 <dramforever> oh enough for now
06:39:05 <dramforever> Aruro: as you can see it's arithmoi's problem
06:39:07 <Aruro> same error brakes installation of gloss-raster
06:39:19 <dramforever> cabal install arithmoi -f-llvm
06:39:22 <fryguybob> Aruro: Do that for arithmoi, not diagrams:  cabal install arithmoi-0.4.1.1 -f-llvm
06:39:33 <dramforever> buuut...
06:39:33 <Aruro> let me try
06:39:34 <dramforever> wait
06:39:41 <dramforever> Default: disabled???
06:39:57 <Aruro> in arithmoi?
06:40:15 <dramforever> Aruro: you tried fryguybob's command
06:40:33 <fryguybob> dramforever: It is disabled in the latest version, not the version cabal is picking
06:40:59 <Aruro> i think your last suggestion worked :)
06:41:01 <Aruro> building :)
06:41:04 <Aruro> just arithmoi
06:41:09 <Aruro> yes, installed it.
06:41:10 <fryguybob> Aruro: Excellent
06:41:12 <Aruro> hm, funny
06:41:23 <Aruro> so flag does not get to arithmoi?
06:41:31 <Aruro> in case of cabal install diagrams
06:41:45 <tik_> @pl \f x -> f x
06:41:45 <lambdabot> id
06:41:50 <fryguybob> Aruro: I don't pretend to know how cabal flags work.
06:42:37 <Aruro> how do i tell cabal to not reinstall arithmoi in case of diagrams install?
06:42:53 <Aruro> when i type cabal install diagrams he complains arithmoi did not manage to install
06:42:57 <Aruro> even if its there already
06:43:59 <fryguybob> Aruro: You can do it in one invocation of cabal:  cabal install diagram arithmoi-0.4.1.1 -f-llvm
06:45:30 <Aruro> ok ty guys a lot
06:45:34 <Aruro> i think now working
06:45:38 <hop_> hello all, for performance: is it better to pattern match string literal or to use hash maps/Data.Map when I need to get some data for each string literal?
06:46:23 <hop_> I have something like 50 entries.
06:46:37 <Aruro> thank you guys! installed diagrams :D
06:46:56 <hop_> Patterm match of string literals is optimized in some way or is it just linearly scanned?
06:47:10 <fryguybob> Aruro: Great!  There is also the #diagrams channel if you have other diagrams questions.
06:47:31 <zinfandel> hop_: I guess it depends on the size of the problem
06:47:32 <Aruro> ty! :)
06:47:39 <mniip> hop_, I think let-case floating might try to optimize it
06:48:47 <hop_> miip: so, this is safe to assume that for a reasonably big number of strings, this is better to use some container?
06:49:02 <hop_> miip: (instead of matching)
06:49:10 <hop_> mniip (sorry) :-)
06:49:39 <mniip> well
06:50:09 <jellie> jle`: Hey
07:05:17 <ggVGc> how can I change this to have different behaviour depending on if the first Node in children is a Node or a Leaf? https://gist.github.com/e2dbbad679778accbde4
07:05:40 <byorgey> hop_: probably, yes.  Also, who wants to write a giant 50-line pattern match?
07:06:12 <byorgey> ggVGc: just pattern match on children
07:06:41 <byorgey> ggVGc: (Node []) = ...     (Node (Leaf : children)) = ...      (Node (n : children)) = ...
07:07:10 <mniip> oh it's that vim dude again
07:07:29 <ggVGc> :(
07:07:42 <ggVGc> mniip: trying to improve my haskell past the level of a toddle
07:07:45 <mauke^> with the unnecessary visual selection
07:07:45 <ggVGc> toddler*
07:07:48 <ggVGc> so far not doing so well
07:07:55 <mauke^> ggcG
07:08:00 <ggVGc> mauke^: http://tinyurl.com/NickAnswer
07:08:02 <mniip> mauke^, you're not the first
07:08:27 <ggVGc> byorgey: thanks, will try to make it work
07:08:58 <zomg> ggVGc: lol, such philosphy about vim commands
07:09:13 * hackagebot bytestring-read 0.3.0 - fast ByteString to number converting library  http://hackage.haskell.org/package/bytestring-read-0.3.0 (HirotomoMoriwaki)
07:12:55 <hop_> In hashtables package, there is no way to make the hashtable immutable to return it from runST (like with Data.Vector, if I am correct)?
07:13:12 <c_wraith> hop_: I'm sure there is
07:13:21 <c_wraith> hop_: oh, in hashtables..  Maybe not.
07:14:03 <hop_> c_wraith: too bad, it seems to be pretty optimized and clean interface. Am I stuck with HashMap so?
07:14:30 <c_wraith> hop_: there's no immutable versions of the structures in hashtables.  They're fundamentally designed in terms of mutation.
07:15:21 <hop_> c_wraith: Too bad, There is a use case when you build it once and read it then with no further mofications.
07:16:42 <c_wraith> hop_: true, but not what that package was designed for.  It was designed as part of the snap-server implementation, and being mutated constantly.
07:18:04 <hop_> c_wraith: OK. I see. I have a (simple) lexer in Parsec and the inner loop contains the list of keywords I need to discriminate. I am stuck with Map so. I'll see if it is good enough. Thanks!
07:18:25 <c_wraith> hop_: there's always unordered-containers if you'd prefer it
07:34:15 * hackagebot th-desugar 1.5.3 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.5.3 (RichardEisenberg)
07:43:26 <sebastard> Is there a "takeWhile" function that does include the element on which the property failed?
07:43:37 <nitrix> :t (.)
07:43:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:49:17 * hackagebot minimorph 0.1.6.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.1.6.0 (MikolajKonarski)
07:54:18 * hackagebot hjsonschema 0.5.3.0 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.3.0 (seagreen)
07:54:24 <ggVGc> is there an opposite of drop, that drops elements from the end instead?
08:01:06 <eacameron> How can you stop folding in the middle of a fold when you realize you have the answer (as an example, summing all the numbers in an infinite list until you see zero)
08:01:11 <eacameron> ?
08:01:44 <saep> > let dropEnd n xs = take (length xs - n) xs in dropEnd 3 [1..10]
08:01:46 <lambdabot>  [1,2,3,4,5,6,7]
08:02:04 <eacameron> saep: I need to use a fold
08:02:31 <seagreen> Possibly foldM?
08:03:33 <saep> eacameron: It was not intended for you. But to your problem: It depends on the fold function you use.
08:04:33 <saep> With foldr, you can terminate early, if your function does not have to inspect the second parameter of your function to return a reselt.
08:04:39 <eacameron> saep: I realized that after the fact ;) thanks.
08:04:55 <saep> > foldr (&&) True (repeat False)
08:04:57 <lambdabot>  False
08:06:54 <eacameron> saep: excellent
08:09:37 <humanoyd> Sorry for asking this here, but I guess I'm more likely to get an answer in #haskell than in #javascript: is it possible to use ADTs in javascript? I've found a few libraries but I'm not even sure if it is a good idea in the first place
08:15:02 <merijn> humanoyd: Simple solution: Use ghcjs, write haskell and compile it to javascript, problem gone ;)
08:16:13 <zomg> humanoyd: I think with most things the answer is "it depends".. If it makes your use-case easier to implement, easier to maintain, or better in some way, go for it. But don't try to blindly apply it to everything
08:16:18 <bergmark> humanoyd: there are libraries to help out with that, but you can also model it yourself by doing e.g. { a : {} }, { b : {} } and then pattern match with if (o.a)
08:17:01 <bergmark> that's how generic-aeson derives ToJSON instances
08:24:20 * hackagebot fay 0.23.1.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.4 (AdamBergmark)
08:25:04 <humanoyd> merijn: Compiling to js is a little bit too experimental for me :-) (I'm not really an experienced programmer and would probably encounter too many road blocks)
08:25:12 <hop_> Is there any function to create tuple of 3 elements in Haskell? I would like to merge three lists into a non-deterministic way. So, I am wondering if this function already exists. Hoogle does not seem to find it a->b->c->(a,b,c)  
08:25:25 <bergmark> :t (,,)
08:25:26 <lambdabot> a -> b -> c -> (a, b, c)
08:25:37 <hop_> Something like (,) for three elements tuple basically
08:25:43 <hop_> :-)
08:25:54 <hop_> bergmark: Thanks!
08:26:56 <humanoyd> bergmark: fay looks good too :>
08:27:12 <humanoyd> On the compile-to-js side, I was really impressed with elm
08:27:43 <bergmark> humanoyd: it's simpler to get started with, but if you are unexperienced with haskell any runtime errors you get may be hard to deal with, e.g. if you make a mistake in the FFI
08:27:59 <bergmark> this probably applies to ghcjs as well though
08:28:38 <geekosaur> fwiw I think the oproblem with hoogle is that it indexes actual functions, whereas tuple constructors are something of a syntax hack in ghc
08:31:35 <enthropy> @hoogle a -> [a] -> [a]
08:31:37 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:31:37 <lambdabot> Data.Text.Internal.Functions intersperse :: a -> [a] -> [a]
08:31:37 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:31:42 <humanoyd> bergmark: I guess I could cope with errors, but I wouldn't be sure how to layout an application architecture etc...I've tried elm's architecture (https://github.com/evancz/elm-architecture-tutorial) but some things like routing etc still seem unsolved
08:37:15 <Ryanar> Question about pattern matching in Haskell, if I match f x:xs = ... -- How can I refer to the whole instead of head or tail (x xs)
08:37:33 <geekosaur> f l@(x:xs) = ... 
08:37:34 <Ryanar> do I just say f x:xs = if x:xs 
08:37:43 <geekosaur> l will refer to the whole list
08:37:49 <Ryanar> geekosaur, ah gotcha, thank you
08:38:15 <amf> is there a list and accompanying docs for all the base derivable typeclasses?
08:38:36 <sritchie> maybe this? https://wiki.haskell.org/Typeclassopedia
08:41:20 <Ryanar> so I have a function that goes through a list and takes off certain elements and returns them, but I also want the rest of the list that I went through, do I just use a tuple to return both?
08:42:29 <nkar`> Ryanar: sounds alright
08:43:08 <nkar`> > map (\x -> (x, x+1) [1,2,3] -- something like that
08:43:09 <lambdabot>  <hint>:1:51:
08:43:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:43:17 <nkar`> > map (\x -> (x, x+1)) [1,2,3] -- something like that
08:43:19 <lambdabot>  [(1,2),(2,3),(3,4)]
08:44:55 <Ryanar> thanks
08:46:01 <nkar`> Ryanar: though, it might be better to use a custom type instead of a tuple in certain cases, to make things more explicit
08:46:50 <Ryanar> right
08:47:23 <dwins> Ryanar: actually there's a function in the Data.List module for that. it returns a pair of lists
08:48:03 <Ryanar> dwins, I am trying to just use the stuff in Prelude or build it myself for learning purposes
08:48:47 <timmy_tofu> Why am I getting this error? I'm trying to assert that the "querier" qc (a postgres-simple query function already partially applied with a connection) must accept any ToRow (which it does) - http://lpaste.net/2615996925668753408
09:17:39 <wz1000> Why doesn't 'a -> a' have a monoid instance?
09:18:36 <geekosaur> I think there's too many possible instances, so the provided one is a newtype Endo
09:18:47 <geekosaur> :t Endo
09:18:48 <lambdabot> (a -> a) -> Endo a
09:19:54 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Data-Monoid.html#t:Endo
09:20:51 <wz1000> Ah. It overlaps with the instance for 'Monoid b => a -> b'
09:23:32 <exio4> wz1000: you could have (.) or flip (.) as <> for (a -> a), too
09:24:05 <wz1000> exio4: I hadn't thought of that
09:25:44 <exio4> wz1000: if you added ''tags'' to the monoid to force some kind of ordering, you've got a category :P 
10:04:30 * hackagebot arbtt 0.9.0.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.9.0.1 (JoachimBreitner)
10:27:35 <haskell907> @pl map (map (uncurry (++)) . uncurry zip)
10:27:35 <lambdabot> map (map (uncurry (++)) . uncurry zip)
10:28:09 <haskell907> @pl \a b -> map (map (uncurry (++)) . uncurry zip) $ zip a b
10:28:09 <lambdabot> zipWith (curry (map (uncurry (++)) . uncurry zip))
10:42:04 <ggVGc> how can I convert tree into tree2? https://gist.github.com/28e1896be8b10ce85207
10:44:05 <quchen> What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong? 
10:45:26 <ggVGc> quchen: well, I barely know haskell and am trying to learn. The bigger problem is that I am trying to generate indentation tokens from a parse tree, but this specifically is about me trying to understand how to pattern match correctly
10:47:13 <quchen> Pattern matching requires you to consider all structucal cases. The function you want has to answer the questions "how do I convert a Node, how do I convert a Leaf".
10:47:39 <quchen> So that'll be something like "f (Leaf ...) = ...; f (Node ...) = ..."
10:48:06 <quchen> So the first one of those asks "how do I transform a leaf"
10:48:33 <ggVGc> yeah, that's about as far as I got
10:48:34 <quchen> So you want something that does the mapping  Leaf "foo bar baz" → Leaf "foo", Leaf "bar", Leaf "baz]" here.
10:48:48 <ggVGc> quchen: hm, no, the reverse
10:48:53 <ggVGc> I think?
10:49:06 <ggVGc> I want all leaves to become one leaf
10:49:11 <quchen> Ah okay.
10:49:23 <ggVGc> well, hm, not all leaves. But all consecutive leaves
10:50:26 <ggVGc> so I need to match (Leaf lf):(Node) = ... or something?
10:50:32 <ggVGc> this is the part I can't formulate
10:51:06 <ggVGc> I need to discern between a leaf followed by a leaf, and a leaf followed by a node
10:51:09 <ggVGc> and a node followed by a leaf
10:51:13 <quchen> That looks conceptually right, yes. You'd write it as `f (Leaf x : rest) = ...`, which matches a leaf followed by other stuff.
10:51:50 <ggVGc> so how do I know if the first element of "other stuff" is a node or a leaf?
10:52:17 <quchen> You don't, that's why you pattern match against it. The "Leaf x : rest" case is only one of the ones you have to consider.
10:52:28 <quchen> Another one will be the case where there isn't a Leaf at the head of the list.
10:52:41 <quchen> And then one in case there's nothing in the list at all, and so on.
10:53:48 <quchen> So you'll need  f []  (nothing there),  f (Leaf x : stuff),  f (Node stuff : morestuff),  f stuff
10:54:09 <quchen> And then think about how to handle each of these cases individually.
10:54:46 <quchen> You can also pattern match on multiple leafs like  f (Leaf x : Leaf y : stuff).
10:55:06 <quchen> So what do you think should be the result of  f (Leaf x : Leaf y : stuff)?
10:55:12 <ggVGc> quchen: well, the problem is I don't know how to implement f (Leaf x:stuff) since it depends on what the first element in stuff is
10:55:21 <ggVGc> ahh, you can write that too
10:55:27 <quchen> Indeed!
10:55:32 <ggVGc> now it's much easier
10:55:33 <ggVGc> thakns
10:56:22 <ggVGc>  f (Leaf x : Leaf y : stuff) = Node [Leaf x<>y] <> stuff
10:56:25 <ggVGc> or something?
10:57:06 <sellers> newbie question -- I've worked through http://www.cs.nott.ac.uk/~gmh/monads this writeup on monads, and I'm trying to do the exercise at the absolute bottom (writing a Monad instance for data Expr a = ...).  I'm a little confused about return.  It seems to me return x should use the Val constructor when x is an Int, but I'm not sure how to get it to typecheck.  Here is my (probably wrong) code:
10:57:08 <sellers> http://sprunge.us/SIRF (that includes the question in comments)
10:57:45 <sellers> it barfs on return (Int n) = Val n saying the Int constructor isn't in scope (well I guess it isn't a constructor...) how should I pattern match that
10:58:48 <quchen> You want to combine the two Leafs' contents if there are two of them, and the result should probably a list as well. So that gives you "f (Leaf x : Leaf y : stuff) = Leaf (x++y) : stuff". But wait, that will only combine the first two leaves, what if there are more in "stuff"?
11:00:24 <ggVGc> f (Leaf x : Leaf y : stuff) = f (Leaf (x++y):stuff)
11:00:28 <ggVGc> should work right?
11:00:46 <quchen> Right, you've reduced the number of leaves by one.
11:01:05 <ggVGc> yep, thanks
11:01:09 <ggVGc> this helped me a lot on the way
11:01:14 <ggVGc> stil, haskell syntax eludes me a lot
11:01:21 <quchen> sellers: If you've got the `Val n >>= f` case and `f` needs an `a` to do something, which value of type `a` do you have available to apply `f` to?
11:02:10 <sellers> errr, ok, I see that's wrong
11:02:52 <sellers> but even before that
11:03:00 <sellers> i don't know how to implement return properly
11:03:10 <Lis> hello everyone.
11:03:23 <quchen> sellers: You implemented it too properly, one of the cases is redundant :-)
11:03:48 <quchen> return transforms *any* argument `a` to an `m a`. You cannot define it using `Int`.
11:04:14 <Lis> i want to generate a function from a file. like writing "foo bar = putStrLn bar" into a file and then set this function on runtime. how could this be done?
11:04:30 <sellers> quchen: even though Expr has the Val Int constructor?
11:04:44 <merijn> sellers: return can't know what it's input type is
11:04:54 <quchen> sellers: Why do you think return needs to address all constructors?
11:04:58 <quchen> That's not the case.
11:05:05 <dgorbik> Lis: Hi!
11:06:29 <quchen> sellers: If you have a function "String -> Int", you don't need to reach every single possible Int value on the right hand side of your function definition either, for the same reason.
11:06:53 <sellers> quchen: merijn: ok, I just thought return acting on and Int = Val Int was the simplest way to wrap an int.  return 5 giving Var( 5:: Int) is strange to me
11:06:58 <quchen> sellers: Exhaustiveness is something you only have to be concerned about when looking at values, but you're not looking at return's argument at all, you're just bringing it into the monadic domain
11:08:13 <quchen> You cannot "pattern match on types", that is, do something dependent on which type the argument has, that way. Pattern matching is structural in terms of your data types; you can't have a case along the lines of "if an Int is coming in".
11:09:00 <sellers> quchen: merijn: thanks for all the help, I think I'm starting to get it
11:09:00 <quchen> return's type, "Monad m => a -> m a", says that it a) works for all "a" and "monadic m", and b) that it does exactly the same thing in all cases.
11:09:08 <sellers> right
11:09:30 <quchen> Haskell omits an explicit forall here, but if you wanted to spell it out a bit more, the type would read "∀a. Monad m => a -> m a"
11:09:34 * hackagebot monoidal-containers 0.1.2.1 - Containers with monoidal accumulation  http://hackage.haskell.org/package/monoidal-containers-0.1.2.1 (BenGamari)
11:10:09 <quchen> This concept that you cannot react to what "a" is there is quite an important feature of Haskell's type system and provides great benefits in practice, although they may not be obvious when starting out.
11:10:13 <laudiacay_mobile> Who is hackagebot
11:10:17 <laudiacay_mobile> !help
11:10:26 <laudiacay_mobile> No?
11:10:37 <quchen> Just a very hard-working haskeller that keeps helping people in here.
11:10:42 <laudiacay_mobile> Is lambdabot doing any better
11:10:58 <laudiacay_mobile> I know it died for a while :(
11:11:05 <quchen> ?botsnack
11:11:05 <lambdabot> :)
11:11:06 <sellers> quchen: I read through a little bit of the "theorems for free" paper, so I do get what you mean and why that's useful, I think I just didn't make the connection between that idea and this exercise
11:11:12 <geekosaur> hackagebot only writes into the channel
11:11:12 <sellers> quchen: thanks again, you've been super helpful
11:11:40 <quchen> sellers: The concept is known as parametricity, and closely related to Haskell's main method of polymorphism, namely parametric polymorphism
11:12:19 <EricJones> Anybody know whats up with liquid-haskell giving this error when I try to load a " trying to use module x which is not loaded"
11:12:30 <quchen> The second way stuff can be polymorphic in Haskell is via type classes, known as ad-hoc polymorphism. We often refer to both of them just as "polymorphism" when we're lazy. :-)
11:13:16 <laudiacay_mobile> Hey wait can you explain parametricism
11:14:03 <merijn> quchen: Actually, that's not a second way to be polymorphic
11:14:11 <quchen> It's not?
11:14:30 <merijn> quchen: No, it lets you do more things, but the polymorphism isn't differently implemented
11:14:34 * hackagebot pandoc-lens 0.3.2 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.3.2 (BenGamari)
11:14:50 <laudiacay_mobile> ??????
11:15:17 <ggVGc> quchen: thanks you really helped me on the way. Managed to get my first step working with this, https://gist.github.com/e9fba682a0e9056be6d0
11:15:40 <exio4> quchen: bounded parametric polymorphism, is how it is called, I think
11:15:51 <quchen> merijn: I don't think that's right, they serve two very different purposes. Parametric polymorphism gives a single function ways to work with different types, while ad-hoc gives a unified interface to heterogeneous functions.
11:15:58 <quchen> Hm, maybe I don't have the terminology right then.
11:16:15 <exio4> typeclasses aren't ad-hoc
11:16:24 <merijn> quchen: AFAIK there's 3 ways to implement polymorphism (maybe 2.5?). You have parametric polymorphism where you essentially box every value to hide it's runtime representation. Then there's specialisation (where you just duplicate the machine code for each different type), and then there's subtyping which also boxes everything, but some boxes can be expected whether they conform to some interface X
11:16:37 <merijn> Which tells you a bit more about the runtime representation of whatever's inside
11:17:05 <quchen> exio4: That's the name I've always seen the concept under
11:17:31 <merijn> quchen: Typeclasses aren't really part of the polymorphism at all, they're merely part of obtaining "limited extra" information about a polymorphic type at runtime
11:18:04 <laudiacay_mobile> I UNDERSTAND PARAMETRIC POLY <3 quchen merijn
11:18:40 <quchen> When I talk about ad-hoc polymorphism I mean it in the Wadler sense, ala homepages.inf.ed.ac.uk/wadler/papers/class/class.ps
11:18:53 <quchen> Just to justify the silly name ;-)
11:19:31 <sellers> The name seems rather.. ad-hoc :X
11:19:35 * hackagebot linear-opengl 0.2.0.7 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.7 (BenGamari)
11:19:42 <merijn> laudiacay_mobile: Parametric polymorphism is basically "generics where it's impossible to query the actual type inside"
11:19:59 <merijn> laudiacay_mobile: i.e. there's no instance-of style operator
11:20:01 <laudiacay_mobile> I get it :)
11:20:05 <quchen> Don't mention generics and type systems in the same sentence please ;-(
11:20:06 <laudiacay_mobile> Happy face
11:20:13 <forgottenone> is it possible to define a where clause for multiple function definitions
11:20:22 <merijn> forgottenone: Nope, sadly
11:20:35 <quchen> forgottenone: You can span multiple guards with a single "where" though
11:20:45 <merijn> forgottenone: Although you can move the pattern match into a case and reuse the same 'where' that way
11:20:48 <quchen> f | p = … | q = … where blabla
11:21:46 <forgottenone> quchen,merjin thanks for answers
11:22:39 <frerich> That makes me wonder - is there a way to access definitions in a 'where' from ghci? I noticed that I often start using 'where' but then end up making things toplevel anyway because I like tinkering in ghci.
11:23:20 <quchen> I don't think so. But you can access the types with the (`asTypeOf` _hole) trick at least.
11:23:45 <clrnd> quchen, how's that trick?
11:24:12 <ion> or as-hole to be concise
11:24:24 <quchen> Put (x `asTypeOf` _hole) in your code and it'll tell you the type of "x" no matter how deep it is nested in other stuff
11:24:28 <enthropy> frerich, quchen I think with the debugger you can poke at things defined in a where
11:27:47 <exio4> quchen: I normally used (_info x) for that :P 
11:29:01 <Zemyla> Hmm. If I have a random generator monad RandomT m a = RandomT (forall g. (RandomGen g) => g -> m (a, g)), then how do I do things like lift catch or local to it?
11:29:35 * hackagebot ring-buffer 0.1.1 - A concurrent, mutable ring-buffer  http://hackage.haskell.org/package/ring-buffer-0.1.1 (BenGamari)
11:32:57 <HeladoDeBrownie> Zemyla, if i understand your question, it involves Control.Monad.Trans.Class.lift
11:33:15 <HeladoDeBrownie> @type lift
11:33:16 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:33:34 <HeladoDeBrownie> e.g., lift :: IO () -> RandomT IO ()
11:39:36 * hackagebot pipes-vector 0.6 - Various proxies for streaming data into vectors  http://hackage.haskell.org/package/pipes-vector-0.6 (BenGamari)
11:43:12 <Zemyla> HeladoDeBrownie: Yes, but, for instance, liftLocal has a different type, because local's type is (r -> r) -> ReaderT r a -> ReaderT r a.
11:43:22 <Zemyla> You can't just lift that.
11:48:14 <paolino> :t catch
11:48:15 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
11:48:34 <jle`> Zemyla: you might be able to use hoist...but this is a known kink in transformer approaches i think
11:48:39 <jle`> hoist from mmorph
11:48:51 <jle`> @hackage mmorph
11:48:52 <lambdabot> http://hackage.haskell.org/package/mmorph
11:49:37 * hackagebot imagesize-conduit 1.1 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.1 (lostbean)
11:50:02 <jle`> hoist . handle :: (e -> IO a) -> t IO a -> t IO a
11:50:23 <jle`> but i think that this is actually something that monad-control was meant to solve
12:14:08 <Luke> guys I'm trying to install pandoc on OS X but it can't link against gmp. I have gmp installed via brew. anyone else run into this?
12:16:21 <mpickering> install pandoc from source?
12:16:42 <mpickering> I've not heard of anyone come across that problem installing pandoc so it might be a more general issue
12:16:43 <Luke> mpickering: i'm using cabal to install pandoc
12:17:01 <Luke> and brew seems to already have gmp
12:17:05 <mpickering> ok
12:17:19 <mpickering> can you paste the result of "cabal install pandoc -v3"
12:18:45 <Luke> mpickering: another hint: when I uninstall gmp, I get a very clearly different error: dyld: Library not loaded: /usr/local/lib/libgmp.10.dylib
12:18:53 <Luke> so cabal install is definitely finding gmp
12:19:15 <Luke> mpickering: it's actually regex-pcre-builtin-0.94.4.8.8.35 which needs gmp
12:19:22 <mpickering> ok :)
12:19:25 <Luke> ld: library not found for -lgmp
12:20:54 <Luke> mpickering: http://lpaste.net/129922
12:22:44 <mpickering> I don't know sorry
12:26:57 <Zemyla> Holy crap, there are nonad transformer monads. :O
12:27:10 <EvanR> nonads?
12:27:18 <Zemyla> *monad
12:27:29 <Zemyla> Sorry, phone keyboard.
12:28:36 <EvanR> no-monads sounds like a future popular movement to make haskell more user friendly or easier
12:28:59 <EvanR> lik no-sql
12:29:25 <EvanR> Zemyla: so like, monad transformer transformers?
12:29:43 <quchen> No monads also make a language experienced-unfriendlier.
12:29:51 <HeladoDeBrownie> ((* -> *) -> * -> *) -> (* -> *) -> * -> *
12:29:57 <quchen> Elm has no monad abstraction, it's painful to use if you know about its usefulness.
12:29:59 <barrucadu> type Nonad m a = Monad m a
12:30:05 <barrucadu> There, a friendlier language
12:31:31 <Zemyla> EvanR: embed :: (forall a. m a -> t n a) -> t m b -> t n b
12:32:03 <Zemyla> That is the bind analogue, with the return analogue being lift.
12:32:23 <EvanR> is there are transformer for those
12:32:36 <Zemyla> Not yet.
12:32:40 <Zemyla> I hope bot.
12:32:43 <Zemyla> *not
12:33:20 <EvanR> monad transformer monad transformers
12:36:57 <Zemyla> <ekidd> Things which can only be said on #haskell, part 1. shachaf: "wouldn't using monad transformer transformers make it simpler?" :-)
12:38:56 <shachaf> Hmm, that was in 2007. You can probably disregard most anything I said back then as nonsense.
12:40:05 <HeladoDeBrownie> there's sort of a point behind that though, which is that this can be argued: (a) this specific tool makes things simpler; or (b) we shouldn't use it
12:40:16 <HeladoDeBrownie> (not saying that's what the point being made was)
12:41:15 <merijn> Luke: How did you install GHC?
12:41:22 <Luke> grew
12:41:26 <Luke> brew*
12:42:06 <merijn> In general I would recommend not using Homebrew or Macports for installing on OSX, both of them are rather poorly maintained and the maintainers have done weird things in the past
12:42:44 <nitrix> Hi, I have a question.
12:43:20 <Luke> merijn: it's worked well for me in the past
12:43:47 <WraithM> merijn: What's your suggestion for OS X GHC install?
12:43:48 <nitrix> How come catMaybes works on a :: ParsecT Data.Text.Internal.Text u Data.Functor.Identity.Identity [Maybe Resource]  ?
12:43:50 <merijn> If you want to use pandoc, I would simply recommend installing pandoc directly via homebrew/macports. If you want to hack it, I would recommend installing GHC via https://ghcformacosx.github.io/, platform or binary release to make sure it links all the system libraries you want
12:43:54 <merijn> WraithM: ^^^
12:44:07 <WraithM> Ahh, thanks
12:44:09 <Luke> merijn: I used to use that
12:44:13 <Luke> saw no difference
12:44:15 <HeladoDeBrownie> @type catMaybes
12:44:16 <lambdabot> [Maybe a] -> [a]
12:44:36 <HeladoDeBrownie> nitrix, what catMaybes are you talking about?
12:44:40 <Luke> merijn: i'll try via brew. good thinking. thanks
12:44:46 <HeladoDeBrownie> nitrix, or, maybe you're mistaken that it works on it
12:45:18 <HeladoDeBrownie> or maybe i misunderstand what you mean when you say it works on it
12:45:18 <nitrix> HeladoDeBrownie: catMaybes from Data.Maybe
12:45:26 <HeladoDeBrownie> nitrix, show code
12:45:33 <merijn> Luke: Well, one problem that macports tends to have with C libraries is that some of the libraries ports uses are different from the C libraries the GHC binary uses and can thus break things during linking, but I dunno how that works for homebrew
12:45:53 <nitrix> HeladoDeBrownie: https://github.com/nitrix/udfs/blob/develop/src/Inode.hs#L80
12:46:22 <Luke> merijn: yeah with brew it uses the same libs
12:46:23 <WraithM> merijn: I've totally had that problem in the past with macports too.
12:46:37 <Luke> i had that problem with ports years ago
12:46:40 <Luke> brew seems to be a lot better
12:46:46 <HeladoDeBrownie> nitrix, catMaybes is being used on the *result* of a parser
12:47:09 <nitrix> Oh yeah, you're right.
12:47:20 <nitrix> I was being distracted. It's bound.
12:48:13 <nitrix> I'm disapointed because my IDE shows `resources` has the type ParsecT Data.Text.Internal.Text u Data.Functor.Identity.Identity [Maybe Resource]
12:49:56 <romero_> so  a pair of functions are isomorphism if one goes a -> b and the other goes b -> a in a unique way. Is this right
12:50:12 <HeladoDeBrownie> romero_, specifying "in a unique way" is important
12:50:14 <HeladoDeBrownie> but yeah
12:50:21 <nitrix> I think it might be worth stepping through the code with ghci
12:50:46 <romero_> HeladoDeBrownie: I have a question to this nature... what do we call the above if they're not unique
12:51:11 <HeladoDeBrownie> romero_, i'm not aware of a special term
12:51:34 <EvanR> what is a pair of functions that are not unique
12:51:50 <HeladoDeBrownie> romero_, actually i need you to be more explicit with what you mean by "they're not unique"
12:52:15 <romero_> HeladoDeBrownie: well that'll sound stupid but let's say I'm converting from bitmap to JPEG and back
12:52:32 <HeladoDeBrownie> that's a reasonable example
12:52:44 <romero_> Ostensibly isomorphic to the domain (image perceived by human) yet not quite unique/perfect
12:52:58 <HeladoDeBrownie> you want to ensure the conversion is non-lossy, essentially
12:52:59 <HeladoDeBrownie> right?
12:53:06 <EvanR> doesnt sound like the right usage of isomorphic / isomorphism
12:53:22 <Gurkenglas> @seen narvius
12:53:22 <lambdabot> n4r\/iU5
12:53:24 <romero_> HeladoDeBrownie: I want to use the right terms to classify bi-directional transforms that are lossy and non-lossy
12:53:44 <Gurkenglas> Did someone swap the seen and 1337 commands?
12:53:45 <EvanR> an encoder decoder pair which is non-lossy can be considered a bijection
12:53:57 <Zemyla> @1337 narvius
12:53:58 <lambdabot> naRVIU$
12:53:59 <enthropy> @seen has been gone for a while
12:53:59 <lambdabot> HAz 83En gON3 phOr a WhiLE
12:54:24 <merijn> There is not seen command
12:54:50 <merijn> lambdabot uses approximate commands to correct typos and seen is within correction distance of leet
12:54:57 <EvanR> if there is loss, then it isnt a bijection, and in any case theres no isomorphism
12:55:03 <sellers> http://sprunge.us/DPOQ  Do I have the right idea here? specifically with the implementation of (Add x y) >>= f?  (Exercise from http://www.cs.nott.ac.uk/~gmh/monads)
12:55:25 <ion> @@ @seen @src replicateM
12:55:26 <lambdabot> Plugin `compose' failed with: Unknown command: "seen"
12:55:30 <ion> @@ @leet @src replicateM
12:55:30 <lambdabot>  REpLIcA+Em N x = zEqUENce (r3P1ica73 n x)
12:55:46 <sellers> amazing
12:55:52 <romero_> EvanR: I wonder how to call this. Ostensibly there's isomorphism if we consider the human observer :P
12:56:00 <romero_> EvanR: but not to a machine
12:57:19 <EvanR> romero_: i dont think this is correct usage of isomorphic. id be glad to hear your specific redefinition in detail 
12:57:36 <HeladoDeBrownie> well not every isomorphism is a bijective function. but specfically in the category Set i believe bijective iff iso
12:58:10 <nitrix> class Monad m => Stream s m t | s -> t
12:58:15 <nitrix> What does the | means?
12:59:10 <ion> nitrix: Functional dependencies.
12:59:16 <exio4> it is a separator, between parameter and 'functional dependencies'
12:59:20 <HeladoDeBrownie> nitrix, it introduces a functional dependency; t can be uniquely determined given s
12:59:40 <nitrix> That's new to me.
12:59:58 <nitrix> I'll google it. Functional dependencies :/
13:00:09 <ion> Why “:/”?
13:00:10 <HeladoDeBrownie> https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/type-class-extensions.html#functional-dependencies
13:00:13 <enthropy> EvanR: I think it's the same idea as saying  "data Three a b = L a | R a | LR a b" is isomorphic to type Three' a b = (Maybe a, Maybe b)
13:00:18 <nitrix> !u
13:00:18 <HeladoDeBrownie> woops, old version
13:00:25 <nitrix> Parsec has such weird types, wth.
13:00:33 <nitrix> What's a !u
13:00:41 <HeladoDeBrownie> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#functional-dependencies
13:00:58 <HeladoDeBrownie> nitrix, where'd you see "!u" written?
13:01:04 <ion> nitrix: A strictness annotation probably.
13:01:25 <nitrix> Strict type it seems.
13:01:26 <sellers> "Yell if you need it." Ha...
13:01:48 <vandenoever> i wonder if this can be done more elegantly:
13:01:54 <vandenoever> fromMaybe True $ listToMaybe $ catMaybes m
13:02:04 <EvanR> enthropy: i keep thinking of isomorphisms as operation preserving rather than set theoretic bijective functions
13:02:06 <vandenoever> m :: [Maybe Bool]
13:02:46 <vandenoever> in other words, find the first Just, or if there is no Just, return True
13:03:09 <EvanR> enthropy: like homomorphisms
13:03:25 <ion> vandenoever: Why do you have a [Maybe Bool] in the first place?
13:03:41 <nitrix> vandenoever: I'd exploit the fact your contained type is a Bool
13:03:49 <nitrix> And use isJust
13:04:04 <caconym> data NotSure = Yes | No | Dunno
13:04:40 <vandenoever> i've a value a and [a -> Maybe Bool]
13:05:20 <vandenoever> so the total sig is :: a -> [a -> Maybe Bool] -> Bool
13:05:40 <nitrix> [a -> Maybe Bool] seems very ill-designed to me.
13:06:12 <frerich> nitrix: How so?
13:06:21 <vandenoever> nitrix: it's a list of filters, they say either 'the value is in, the value is out or i dont care'
13:06:41 <EvanR> you probably want a new three-valued type for this
13:07:11 <EvanR> and to decide what i dont care really means
13:07:12 <enthropy> vandenoever: and you're intentionally taking the first filter only?
13:07:33 <enthropy> the first one to have an opinion
13:07:37 <vandenoever> enthropy: the first filter that has an opinion (pass or fail) decides
13:08:30 <caconym> you could do it in Either rather than Maybe
13:08:34 <vandenoever> if one denying filter would suffice to deny, it was easier
13:08:59 <vandenoever> caconym: how would that differ? the filter does not give a reason for the deny or pass
13:09:17 <verement> what if none of the filters make a decision?
13:09:25 <vandenoever> verement: then it's a pass
13:09:42 * hackagebot Win32-services 0.2.5 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.5 (MichaelSteele)
13:09:50 <vandenoever> i guess i could add a pass filter as the last filter
13:09:55 <caconym> i may not be understanding your use case perfectly but i've used Either when I want to run a sequence of computations and possibly abort with a value
13:09:56 <vandenoever> that way i avoid the Maybe
13:09:58 <jellie> jle`: Hey are you online?
13:10:11 <frerich> vandenoever: I'd say a plain 'case catMaybes xs of (Just b:_) -> b; _ -> True' wouldn't be so bad.
13:10:36 <vandenoever> caconym: that's the use case, but i dont so how you can do that with Either and not with Maybe
13:10:36 <jle`> jellie: hey, sup?
13:10:44 <jle`> sorry I wasn't online earlier for your pms
13:10:48 <nitrix> vandenoever: So far: listToMaybe . catMaybes
13:10:48 <caconym> vandenoever: do it in the Either monad
13:11:04 <nitrix> vandenoever: But EitherT might be worth looking into.
13:11:08 <jle`> I've rewritten the blog post since then to account for the jumbled order of things :) thanks for the tip!
13:11:18 <caconym> vandenoever: so it'll return a `Left Whatever` if a filter trips, or a `Right WhateverElse` if not
13:11:22 <xplat> vandenoever: you could mconcat the opinions in First
13:12:25 <vandenoever> ah
13:12:26 <jellie> jle`: Give me a few seconds to push some code and show you. It's to do with building an IRC bot with auto
13:12:50 <xplat> > getFirst . mconcat . map First $ [Nothing, Nothing, Just True, Just False]
13:12:51 <lambdabot>  Just True
13:13:04 <xplat> > getFirst . mconcat . map First $ [Nothing, Nothing, Just False, Just True]
13:13:06 <lambdabot>  Just False
13:13:16 <jle`> if you have a recent ghc you can do getFirst . mconcat . coerce
13:13:46 <jle`> jellie: np!
13:14:23 <jellie> jle`: Well look at this gist it's faster. It doesn't store reputation. Yet it's from your example. https://gist.github.com/urbanslug/b46c80895487f0753dff
13:14:57 <jellie> jle`: I have a bot running in #zippy You can try see if I've done anything wrong there
13:15:14 <Zemyla> But yeah, I want there to be a RandomT monad instead of just using State so I can know it's not taking advantage of the internal structure of the passed RandomGen.
13:15:44 <HeladoDeBrownie> MonadRandom might solve a similar problem
13:16:06 <EvanR> there is a RandomT
13:16:24 <HeladoDeBrownie> oh there actually is a RandT in a package
13:16:30 <JordiGH> Would someone be willing to walk me very slowly and patiently through translating a Python function into Haskell? I could pay in bitcoins, if desired.
13:16:37 <EvanR> but you have to use StdGens
13:16:46 <EvanR> each rng package seems to reinvent all this
13:16:47 <jle`> no you don't...
13:17:00 <jle`> @hackage MonadRandom
13:17:00 <lambdabot> http://hackage.haskell.org/package/MonadRandom
13:17:03 <JordiGH> I've been bumbling myself through this for a while, and while I think I could be able to do it, I feel like I'm making an unreadable mess.
13:17:08 <EvanR> JordiGH: homework?
13:17:18 <jle`> jellie: what's the problem? :)
13:17:19 <JordiGH> EvanR: Sure, self-assigned homework, if you will.
13:17:22 <jle`> or are you just showing me?
13:17:34 <EvanR> jle`: i meant RandomGem
13:18:28 <frerich> JordiGH: Shoot!
13:18:35 <JordiGH> Okay...
13:18:39 <JordiGH> Let me set up...
13:18:51 <EvanR> be prepared to pay a bunch of people bitcoins ;)
13:19:09 <JordiGH> Well, I was only going to pay one person for one-on-one tutoring.
13:19:11 <jellie> jle`: It's not adding reputation
13:19:24 <JordiGH> But if you're all romantics willing to ruin the market, I have no problem with that either. ;-)
13:19:29 <jellie> jle`: LOL there is a problem
13:19:31 <jellie> haha
13:19:32 <JordiGH> LOL
13:19:42 * hackagebot hjsonpointer 0.2.0.1 - JSON Pointer library  http://hackage.haskell.org/package/hjsonpointer-0.2.0.1 (seagreen)
13:19:44 * hackagebot hjsonschema 0.5.3.1 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.3.1 (seagreen)
13:19:53 <jle`> oh interesting haha
13:22:56 <Zemyla> jle`: It still has the RNG's type as a parameter.
13:23:27 <Zemyla> I'd prefer it not show up at all, so you can't do anything untoward to the generator.
13:23:34 <jle`> you cant arbitrarily modify it
13:23:44 <jle`> but you can also use MonadRandom
13:24:00 <jle`> MonadRandom does not parameterize on generator
13:24:57 <Zemyla> Yes, but MonadSplit does.
13:25:13 <frerich> JordiGH: Still setting things up? :-)
13:25:35 <timmy_tofu> Why am I getting this error? I'm trying to assert that the "querier" qc (a postgres-simple query function already partially applied with a connection) must accept any ToRow (which it does) - http://lpaste.net/2615996925668753408
13:26:21 <Zemyla> I'd much prefer split to have the same general type and semantics as unsafeInterleaveIO, but safe because it's using split.
13:26:22 <JordiGH> frerich: I'm in /query with EvanR now. 
13:26:33 <Zemyla> System.Random.split, I nean.
13:29:35 <Gurkenglas> Sorry guys, but I need to try this.
13:29:39 <Gurkenglas> @where+ loop @@ @where loop
13:29:39 <lambdabot> Good to know.
13:30:01 <sellers> ..huh.
13:30:03 <Gurkenglas> @@ @@ @where loop
13:30:19 <lambdabot> Plugin `compose' failed with: <<timeout>>
13:30:21 <ion> nice
13:30:22 <Gurkenglas> :D
13:30:57 <Gurkenglas> Now to use this power for the Greater Good.
13:34:43 * hackagebot pseudo-trie 0.0.1 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.1 (athanclark)
13:36:07 <Gurkenglas> A competent Slytherin made sure that all variable outputs start with a space.
13:43:09 <Zemyla> Like, this is what I want the splitting to d, in general semantics.
13:43:17 <Zemyla> :t \m -> fmap System.Random.split get >>= (\(gl, gr) -> put gr >> (lift (evalStateT m gl) `asTypeOf` m))
13:43:18 <lambdabot> (Monad m, RandomGen s) => StateT s m b -> StateT s m b
13:53:39 <__monty__> I was wondering if Takusen is still being maintained and one of the recommended ways to interect with SQL databases from haskell?
13:54:07 <mmachenry> __monty__: I am using it in production for Oracle and found it
13:54:17 <mmachenry> it's the best way to connect to Oracle
13:54:44 * hackagebot rose-trees 0.0.1 - A collection of rose tree structures.  http://hackage.haskell.org/package/rose-trees-0.0.1 (athanclark)
13:54:46 <mmachenry> If I were using Postgres, which I wish I were, then I'd use Esqualito and the DB driver that that supports. 
13:54:46 * hackagebot rose-trees 0.0.1.1 - A collection of rose tree structures.  http://hackage.haskell.org/package/rose-trees-0.0.1.1 (athanclark)
13:55:43 <mmachenry> __monty__: The Takusen Oracle bindings are indeed being maintained still. I sent the author a pull request a couple of months ago and he was very prompt about responding to me and pulling and merging. 
13:56:08 <__monty__> mmachenry: My question was mostly sparked by noticing that the package on hackage was last updated in 2011. But maybe the core package doesn't matter much?
13:57:00 <mmachenry> __monty__: Likely it does not. What are you trying to do though? What database are you using? 
13:58:09 <sinelaw> Peaker, hey
13:58:43 <__monty__> mmachenry: I want to use sqlite, mostly because it's easier to run locally. I'm actually trying to interface to SQL databases from Agda and Coq.
14:04:32 <athan> __monty__: O=!
14:04:41 <athan> that sounds really cool
14:04:48 <athan> Have you got the Coq code working?
14:06:34 <__monty__> athan: No, I'm still trying to figure out which haskell binding I will use to actually communicate with a database. Also, don't expect too much, the first step will just be implementing the relational algebra from The Power of Pi.
14:06:57 <athan> <__monty__>: That's where it all starts :)
14:07:11 <athan> good luck!
14:08:21 <__monty__> mmachenry: I see esqualeto doesn't support sqlite but that isn't a dealbreaker for me per se. Why would you use it over takusen? And, have you worked with hdbc, which seems to be the other main binding?
14:09:14 <mmachenry> I was using https://hackage.haskell.org/package/postgresql-simple
14:09:18 <__monty__> athan: Thank you. May I ask why the interest? Have you done some actual programming with Coq?
14:09:35 <mmachenry> But when I had to move to Oracle that wasn't supported and I needed to go to Taukusen.
14:09:51 <athan> <__monty__>: I plan on implementing some compilers with it
14:09:55 <mmachenry> Esqualito has a bunch of great features for type checking your schema.
14:10:07 <athan> I'm focusing more on the calculi at the moment, but I will soon :)
14:10:16 <mmachenry> I am envious of it. I wish it had oracle support. I've considered biting the bullet and adding it but I haven't had time.
14:10:30 <mmachenry> Takusen's iterators I'm not a big fan of. 
14:10:38 <barrucadu> __monty__: esqueleto does support sqlite, as it works on anything persistent supports.
14:10:51 <mmachenry> I'd rather have a nice type class I can implement called FromDB like in postgres-simple.
14:12:01 <__monty__> barrucadu: Ah, thank you, didn't notice that because I looked at it only briefly. Do you have an opinion on esqueleto vs takusen?
14:12:17 <barrucadu> __monty__: I've not used Takusen, but I found esqueleto quite nice
14:12:45 <__monty__> mmachenry: Is there a reason you don't want to use HaskellDB which supposedly gives you more static guarantees than most bindings?
14:15:28 <mmachenry> __monty__: Yes. Oracle
14:17:01 <lpsmith> timmy_tofu, 2615996925668753408
14:17:03 <lpsmith> err
14:17:10 <lpsmith> timmy_tofu, http://lpaste.net/2615996925668753408
14:17:24 <lpsmith> you reversed your quantifiers
14:17:51 <malthe> any thoughts on milena vs haskakafka?
14:18:54 <lpsmith> timmy_tofu, Basically,  if you view it using the game semantics of quantifiers,   the qc function gets to pick the type of ToRow parameter,  not you.
14:19:05 <SwashBuckla> where am I going wrong here? https://github.com/spanners/cis194/blob/master/Course/answers/07-folds-monoids/JoinList.hs#L23 ? Here is the error output from GHC: http://lpaste.net/4500216902538231808
14:19:19 <lpsmith> So you have to provide qc with a value that can be *any* ToRow type.
14:19:50 <timmy_tofu> lpsmith: yes, I see... 
14:20:14 <lpsmith> And   (forall x. P(x)) -> Q(y)     <=>  exists x. ( P(x) -> Q(y) )
14:20:45 <SwashBuckla> to deal with these compiler errors one-by-one seems quite involved. I was just wondering if anyone could see something obviously wrong with the type signature of my instance Arbitrary JoinList
14:20:54 <timmy_tofu> so, how can I constrain this? The FromRow bit works, how can I make a general type alias for this
14:21:47 <timmy_tofu> if I move the tr over to the front of the Query I think it works, but I'm not sure
14:22:40 <timmy_tofu> yeah, so far it seems to work
14:22:59 <Luke> i'm trying to make a fast circular array with vector but I also need to keep the index around. what's the best way to do that? Seems like keeping it in a state monad will defeat the purpose and reallocate something new each time I change the index
14:23:20 <cfoch> hello. Does somebody use NixOS?
14:23:37 <moghedrin> cfoch: Yes, somebody does.
14:23:39 <timmy_tofu> lpsmith: sorry, you sent me exactly that... at first it looked like the same lpaste I put originally
14:23:39 <cfoch> what is the correct way to install Cabal. Or the way you recommend?
14:23:50 <pavonia> I remember one of the *Instances extensions was considered bad practice, was it UndecideableInstances?
14:23:53 <lpsmith> timmy_tofu, np :)
14:24:08 <cfoch> moghedrin: ^
14:24:19 <barrucadu> SwashBuckla: First error, you're calling liftM3 on a function that only takes two arguments.
14:25:05 <moghedrin> cfoch: #nixos is probably where you want to go.
14:25:12 <SwashBuckla> barrucadu: oh wow that is embarrassing
14:25:38 <barrucadu> Second error probably has the same root cause, as GHC will have inferred a weird type for that function
14:26:02 <lpsmith> timmy_tofu, sometimes you can't abstract out the quantifiers using Haskell's type synonyms.
14:26:22 <cfoch> so... I suppose I should follow the wiki. I just was to know if there was a recommendation from the Haskell community to install Cabal in NixOS. But it seems not. 
14:26:43 <timmy_tofu> lpsmith: yes, that's what I was/am worried about. thus far (lo, these past twenty seconds) it has worked for what I'm doing, though, at least
14:27:09 <SwashBuckla> barrucadu: (thanks for this by the way). I am now left with one error saying we need an instance Arbitrary (Sized a)
14:27:25 <SwashBuckla> it's *this* bit that I am stuck on
14:27:50 <mpickering> cfoch: do you not just do .. nix-env -i -A haskellngPackages.cabal-install
14:29:09 <SwashBuckla> barrucadu: like so http://lpaste.net/2010166998016720896
14:29:28 <SwashBuckla> now, this seems pretty tricky
14:30:23 <barrucadu> Yeah, it's trying to generate a 'Sized a' value, because of your use of arbitrary there, but you haven't told it how to do that
14:30:36 <barrucadu> So you'll need to write an Arbitrary instance for Sized a
14:30:45 <cfoch> I suppose the answer is... yes
14:30:47 <cfoch> mpickering
14:31:04 <mpickering> Have you seen this SO answer? http://stackoverflow.com/questions/27968909/how-to-get-cabal-and-nix-work-together
14:31:13 <cfoch> I was not sure if I should have some consideration before doing that.
14:31:23 <cfoch> Anyway... I will do it. 
14:31:24 <cfoch>  nix-env -i -A haskellngPackages.cabal-install
14:34:12 <SwashBuckla> barrucadu: done. So now we have http://lpaste.net/7235817281442283520
14:34:45 <SwashBuckla> how on earth do I write an instance for something so nested?
14:34:56 <barrucadu> What is your Sized class supposed to be?
14:35:24 <SwashBuckla> barrucadu: https://github.com/spanners/cis194/blob/master/Course/answers/07-folds-monoids/Sized.hs
14:35:36 <barrucadu> Yes, but I don't know what it's supposed to mean
14:35:38 <SwashBuckla> things that have a size
14:35:43 <barrucadu> If just containing the value 1 is suitable for testing, then it doesn't appear to carry any useful information
14:35:52 <SwashBuckla> they can be summed
14:35:57 <SwashBuckla> oh, I know
14:36:09 <SwashBuckla> but I am just trying to get this instance JoinList to work
14:36:19 <barrucadu> Surely you'll want the size to relate to the JoinList you're generating somehow, not just being different
14:36:33 <SwashBuckla> definitely
14:36:35 <barrucadu> Or is it the size of the elements in the list?
14:36:39 <SwashBuckla> but I have no idea how to do that
14:37:10 <SwashBuckla> well, if you look at `example' in JoinList.hs, you can see that the Sized thing is (Product Int)
14:37:26 <SwashBuckla> and in this case it is the product of the ints in the list
14:37:44 <SwashBuckla> but an instance Arbitrary Sized is more general
14:38:16 <barrucadu> Ok, so, say Product 5 is the size for 'y' in that case
14:38:19 <SwashBuckla> I want to use whatever mappend is appropriate for the Sized thing (+, *, ...)
14:39:21 <barrucadu> In which case something like: do { a <- arbitrary; return $ Single (size a) a } maybe?
14:39:30 <SwashBuckla> yea
14:39:32 <SwashBuckla> that could do
14:39:54 <barrucadu> And then for Append, you'll combine the sizes of the subtrees, which you can extract by pattern matching
14:39:59 <mjrosenb> does anyone know if there is a filter for Maybe, filter :: (a -> Bool) -> a -> Maybe a?
14:40:31 <mjrosenb> e.g. map filter isEven [1..4] = [Nothing, Just 2, Nothing, Just 4]
14:40:57 <SwashBuckla> barrucadu: but the 'Single' concept isn't known to Sized
14:41:04 <SwashBuckla> the two are unrelated
14:41:23 <SwashBuckla> only in JoinList do I relate them
14:41:35 <SwashBuckla> not in Sized
14:42:07 <ReinH> @hoogle (a -> Bool) -> a -> Maybe a
14:42:09 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:42:09 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:42:09 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
14:42:13 <barrucadu> Yeah, that's fine, you don't need an Arbitrary instance for Sized, because the size is computed from the value stored in the Single
14:42:22 <ReinH> mjrosenb: probably not
14:42:48 <SwashBuckla> barrucadu: how do I suppress the warning from GHC complaining that I do need an instance Arbitrary Sized?
14:44:03 <mjrosenb> ReinH: danke, I'll just write one myself.
14:44:05 <barrucadu> So you actually want something like: instance Sized a => Arbitrary (JoinList s a), but you'd also need to get a Monoid constraint from somewhere, which should probably go on the Sized class if you want to always be able to combine them
14:44:08 <ReinH> mjrosenb: \p -> mfilter p . Just would work
14:44:31 <ReinH> > map (mfilter even . Just) [1..4]
14:44:32 <lambdabot>  [Nothing,Just 2,Nothing,Just 4]
14:44:41 <SwashBuckla> I see
14:44:43 <sinelaw> anyone aware of a language that has both type guards and type-inferred polymorphism?
14:44:43 <barrucadu> Uh, something like, instance Sized a => Arbitrary (JoinList Size a)
14:44:48 <sinelaw> or even without type inference
14:45:02 <sinelaw> but type guards inside polymorphic functions
14:45:56 <EvanR> sinelaw: like type case?
14:46:04 <SwashBuckla> barrucadu: hmm, what happened to my Monoid? (in cinemas now!)
14:46:14 <mjrosenb> ReinH: that is just about as long as what I was going to write, so I'll stick with my own definition.
14:46:19 <sinelaw> EvanR, I guess - are you referring to a specific language/feature?
14:46:54 <EvanR> in c# java the idiom of switching on the class of an object determined at runtime
14:47:18 <SwashBuckla> oh, I get it from the type definition of Size, right?
14:47:27 <EvanR> not called type case or type inferred, i was just wondering if thats the same feature
14:47:49 <SwashBuckla>  newtype Size = Size Int   {deriving (Eq, Ord, Show, Num)}
14:48:03 <sinelaw> EvanR, yeah, something like that
14:48:04 <SwashBuckla> and instance Monoid Size 
14:48:07 <sinelaw> so in C# you could do 
14:48:15 <barrucadu> I'm just trying to think of how to mesh your Product Integer example with what I've just been saying... because the Monoid instance for that just use s(+)
14:48:18 <barrucadu> *uses
14:48:40 <sinelaw> T Foo<T>(T val) { if (val is String) { return "haha"; } else {return val; } }
14:48:48 <sinelaw> Foo would still be polymorphic
14:49:08 <sinelaw> but C# isn't smart enough to know that inside the "haha" branch, val is surely a String
14:49:08 <EvanR> so maybe theres something like that in F#
14:49:19 <sinelaw> that last feature is what I actually mean
14:49:22 <sinelaw> typescript has it
14:49:31 <barrucadu> If sizes only need to be added, then instance (Arbitrary a, Sized a) => Arbitrary (JoinList Size a) would work, using the Monoid instance for Size to combine them when calculating the size to store in an Append
14:49:31 <SwashBuckla> barrucadu: no you have it exactly right
14:49:42 <SwashBuckla> barrucadu: that's what I want to mesh :)
14:49:48 <barrucadu> Right, ok
14:50:37 <sinelaw> EvanR, in TypeScript, "val" could be a union type (String|Number), then inside the first 'if' branch it's a string, in the else branch one it's a number
14:50:57 <btcNeverSleeps> :t elem
14:50:58 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:51:07 <EvanR> sinelaw: or null ?
14:51:29 <btcNeverSleeps> is  elem  polymorphic?
14:51:37 <sinelaw> EvanR, maybe, that's not the point though
14:51:37 <EvanR> yes
14:52:21 <EvanR> sinelaw: would be interesting to see 
14:52:27 <btcNeverSleeps> my repl/gchi gives me another type signature for elem:  elem :: Eq a => a -> [a] -> Bool    is it still polymorphic (no "Foldable a" here, maybe not the same elem)
14:52:57 <EvanR> btcNeverSleeps: lambdabot is on the newer version of ghc now
14:53:10 <btcNeverSleeps> 7.10?
14:53:21 <EvanR> list operations were recently upgraded to Foldable and Traversable
14:53:34 <btcNeverSleeps> ok...  But is "Eq a" a bit like an interface in Java?
14:53:58 <EvanR> its a type class, interfaces in java is a remote analog
14:54:14 <btcNeverSleeps> EvanR: things seems to move fast, or I just happened to "jump in" when a big GHC change happened :)
14:54:14 <sinelaw> EvanR, but typescript is unsound
14:54:31 <EvanR> btcNeverSleeps: yeah you did
14:54:31 <sinelaw> function f(x) { if (typeof x === 'string') { return 3; } else { return x; } }
14:54:37 <sinelaw> typescript infers: f: any -> any
14:54:39 <btcNeverSleeps> So   Eq a => a -> [a] -> Bool   is polymorphic right?
14:54:46 <EvanR> sinelaw: brilliant
14:54:46 <sinelaw> 'any' is like Java's Object
14:54:57 <EvanR> any is "i give up, good luck"
14:55:01 <sinelaw> right
14:55:17 <sinelaw> it has a --noImplicitAny flag, which causes it to fail on that program
14:55:38 <btcNeverSleeps> :t Eq
14:55:39 <lambdabot>     Not in scope: data constructor ‘Eq’
14:55:39 <lambdabot>     Perhaps you meant one of these:
14:55:39 <lambdabot>       ‘EQ’ (imported from Data.Ord),
14:56:02 <Denommus> :k Eq
14:56:03 <lambdabot> * -> Constraint
14:56:07 <Denommus> btcNeverSleeps: ^
14:56:08 <sinelaw> EvanR, and if you explicitly declare it to be a generic function, it fails too:
14:56:08 <sinelaw> function f<T>(x : T): T { if (typeof x === 'string') { return 'a'; } else { return x; } }
14:56:22 <sinelaw> error: Type 'string' is not assignable to type 'T'.
14:56:40 <sinelaw> so my question is: do you know of any language in which the above DOES WORK?
14:56:47 <btcNeverSleeps> Denommus: thanks, didn't know about :k
14:56:50 <EvanR> btcNeverSleeps: check out the type of (==)
14:56:57 <clrnd> what's the pygame of haskell? (meaning a standard lib for doing sdl like games)
14:56:59 <sinelaw> or research papers, etc.
14:57:09 <EvanR> clrnd: probably SDL
14:57:11 <sinelaw> clrnd, there's sdl 
14:57:24 <clrnd> that sounds low level EvanR sinelaw 
14:57:49 <sinelaw> clrnd, there's graphics-drawingcombinators
14:57:56 <EvanR> theres several game engines
14:57:58 <sinelaw> which wraps opengl in a nice combinator library
14:58:01 <btcNeverSleeps> EvanR: ok so the type of == is something that is "Equalable", it takes two things that are Equalable but of the same type, and tells if they're equal?
14:58:11 <EvanR> sinelaw: sort of nice
14:58:18 <EvanR> the language is ok but the output is
14:58:29 <EvanR> annoying
14:58:33 <sinelaw> heh
14:58:38 <sinelaw> it's improved I think
14:58:41 <sinelaw> Peaker would know
14:58:42 <Denommus> btcNeverSleeps: :t describe the type for a value, but Eq is not a value, it is a typeclass
14:58:45 <EvanR> btcNeverSleeps: literally Eq a => a -> a -> Bool
14:58:55 <btcNeverSleeps> yes
14:59:00 <Denommus> btcNeverSleeps: :k describes the KIND of a given type
14:59:11 <Peaker> sinelaw: know what?
14:59:42 <clrnd> EvanR, like?
14:59:45 <sinelaw> Peaker, about graphics-drawingcombinators state of the union 
14:59:48 <EvanR> btcNeverSleeps: so for any type a which has an Eq instance, == will work. for example == can be specialized to the type Char -> Char -> Bool
14:59:48 * hackagebot language-c-inline 0.7.9.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.9.0 (ManuelChakravarty)
14:59:53 <jellie> I wish there was a short term series of blog posts on  category theory for people with little or no math experience.
14:59:57 <clrnd> sinelaw, it's nice if only too small
15:00:01 <jellie> Anyone?
15:00:05 <sinelaw> Peaker, EvanR has some reservations about its output
15:00:21 <EvanR> clrnd: its for 2d graphics, and so if youre expecting something like postscript, you will be disappointed
15:00:49 <btcNeverSleeps> What would be an example of the type signature of a simple monomorphic function?
15:00:55 <sinelaw> Peaker, clrnd is looking for a high-level game library
15:01:07 <sinelaw> btcNeverSleeps, String -> String
15:01:10 <Peaker> EvanR: what's wrong with graphics-drawingcombinators output?
15:01:12 <EvanR> btcNeverSleeps: check the type of chr
15:01:13 <btcNeverSleeps> :k String
15:01:14 <lambdabot> *
15:01:14 <EvanR> :t chr
15:01:15 <lambdabot> Int -> Char
15:01:32 <clrnd> Peaker, nothing, I'm just seeing if I will use it
15:01:40 <EvanR> Peaker: due to limitations of opengl, it will be slightly off when compared to a 2d drawing api like cairo
15:01:47 <clrnd> it's definitelly a very nice choice
15:01:59 <clrnd> it's for a game, I wouldn't care
15:02:00 <EvanR> so for "width 1 lines" you might get blur
15:02:20 <btcNeverSleeps> if I compare these two:
15:02:22 <btcNeverSleeps> :k Eq
15:02:22 <lambdabot> * -> Constraint
15:02:24 <btcNeverSleeps> :k String
15:02:25 <lambdabot> *
15:02:43 <sinelaw> btcNeverSleeps, you probably want :t? you are looking at kind signatures, not type signatures
15:02:50 <btcNeverSleeps> sinelaw: no no
15:03:10 <EvanR> i think kind stuff is confusing for btcNeverSleeps who needs to understand types first
15:03:26 <btcNeverSleeps> I come from a Java background :(
15:03:32 <EvanR> Constraint being a kind is not too helpful really
15:03:39 <btcNeverSleeps> (many years of Java have destroyed my brain : )
15:03:41 <sinelaw> btcNeverSleeps, forget about kinds
15:03:41 <Peaker> EvanR: off in what way?
15:03:41 <EvanR> might as well talk about boxed
15:04:00 <Denommus> are kinds really that difficult?
15:04:02 <Peaker> AFAIK, 2d drawing libraries aren't prettier than OpenGL based drawing, they're just slower :)
15:04:06 <Denommus> I had no problem learning them
15:04:09 <sinelaw> btcNeverSleeps, when you'll need to understand them you will. it's not a basic or super-useful concept
15:04:16 <btcNeverSleeps> ok
15:04:23 <sinelaw> :t Eq
15:04:24 <lambdabot>     Not in scope: data constructor ‘Eq’
15:04:24 <lambdabot>     Perhaps you meant one of these:
15:04:24 <lambdabot>       ‘EQ’ (imported from Data.Ord),
15:04:26 <sinelaw> oops
15:04:31 <sinelaw> :t (==)
15:04:32 <EvanR> Peaker: they probably dont have to be better than opengl implementations they just are
15:04:32 <lambdabot> Eq a => a -> a -> Bool
15:04:51 <btcNeverSleeps> It's not that I need it: I just want to know how I can easily determine if a function is polymorphic or monomorphic.
15:05:04 <sinelaw> btcNeverSleeps, if it has type variables, it's polymorphic
15:05:09 <Denommus> btcNeverSleeps: a typeclass (like Eq) is somewhat similar to Java's interfaces
15:05:24 <Denommus> btcNeverSleeps: it describes that a given type must follow some constraints
15:05:25 <sinelaw> btcNeverSleeps, == above has a type variable 'a'
15:05:30 <sinelaw> :t id
15:05:31 <lambdabot> a -> a
15:05:37 <sinelaw> btcNeverSleeps, id has a type variable too
15:05:41 <clrnd> EvanR, Peaker how would you move an imagen on screen? render doesn't take a position (I must be way off)
15:06:01 <clrnd> oh with affine
15:06:11 <clrnd> huh ..
15:06:16 <sinelaw> :t chr
15:06:17 <lambdabot> Int -> Char
15:06:33 <Denommus> btcNeverSleeps: a type variable is somewhat similar to Java's generics. It's a type that will be "assigned" when the function is called
15:06:35 <btcNeverSleeps> But how do I then know that String is just a String and that nothing else can be a String?  In "Java talk", how do I know that the "String class" is final?
15:06:35 <sinelaw> btcNeverSleeps, 'chr' is monomorphic: types are fully specified, no room for variance in types. no type variables.
15:06:50 <hpc> btcNeverSleeps: emphasis on the somewhat
15:06:52 <hpc> ;)
15:07:05 <Denommus> btcNeverSleeps: String is a concrete type, so it's final
15:07:13 <sinelaw> btcNeverSleeps, upper case names in types are specific (concrete) types, monomorphic 
15:07:17 <Denommus> btcNeverSleeps: when you see Eq, you'll see it like in (==)'s type signature
15:07:19 <Denommus> :t (==)
15:07:20 <lambdabot> Eq a => a -> a -> Bool
15:07:31 <Denommus> btcNeverSleeps: it will be followed by a type variable
15:07:38 <sinelaw> btcNeverSleeps, if you have a => expression, the left side is a constraint - NOT TYPES, the right hand side is the type. 
15:07:53 <sinelaw> btcNeverSleeps, the upper case names on the left are type classes, not types. 
15:08:11 <Denommus> btcNeverSleeps: that means that (==) works on a type "a", given that "a" must respect "Eq"
15:08:22 <btcNeverSleeps> is it correct to say this: "Every time there's a constraint in a type signature, it means the function is polymorphic" ?
15:08:25 <sinelaw> btcNeverSleeps, did you read a tutorial or something on types?
15:08:37 <Denommus> btcNeverSleeps: no
15:08:37 <sinelaw> btcNeverSleeps, probably but that's not the only case
15:08:45 <arkeet> btcNeverSleeps: a type is polymorphic if and only if it has a type variable.
15:08:46 <sinelaw> btcNeverSleeps, a function can be polymorphic without constraints
15:08:51 <sinelaw> like id
15:08:59 <sinelaw> :t id
15:09:00 <lambdabot> a -> a
15:09:02 <sinelaw> @src id
15:09:02 <lambdabot> id x = x
15:09:02 <Denommus> btcNeverSleeps: id is an example of a polymorphic function without constraints
15:09:03 <btcNeverSleeps> sinelaw: oh gotcha
15:09:12 <sinelaw> btcNeverSleeps, do you understand from the implementation: id x = x
15:09:16 <sinelaw> btcNeverSleeps, why it can be polymorphic?
15:09:28 <btcNeverSleeps> sinelaw: yes... Because it works with anything
15:09:29 <Denommus> btcNeverSleeps: the thing that defines if a given function is polymorphic is the presence or lack of type variables
15:09:57 <sinelaw> btcNeverSleeps, right, so if you have constraints then you say "this can work with *almost* everything, just satisfy these constraints..."
15:10:04 <sinelaw> still polymorphic, but less so
15:10:07 <sinelaw> (in some sense)
15:10:21 <saml> hey, given a list of addition expressions  [a+b, a+b+d, b+c+d, ...]   how can I draw dependency graph?
15:10:28 <sinelaw> btcNeverSleeps, and if you have not type variables, then you're saying "this works with exactly the following types..."
15:10:33 <saml> like,  I can see a+b is repeating
15:10:39 <schell> if i have an effectful comp (specifically an Eff r (), from extensible-effects) and I’d like to wait for an async comp on another thread, how do i perform my Eff r () once that async comp finishes?
15:11:00 <sinelaw> *no
15:11:59 <schell> i basically have to lift $ async $ do {void $ _ <- wait otherAsync;  liftBackIntoEff $ eff}
15:12:08 <saml> i guess it's np complete
15:12:22 <saml> to find maximum subsets
15:12:56 <Denommus> btcNeverSleeps: an example of function that IS NOT polymorphic is words
15:12:58 <Denommus> :t words
15:12:58 <lambdabot> String -> [String]
15:13:06 <saml> or it's just trie
15:13:10 <Denommus> btcNeverSleeps: no type variables, see?
15:13:17 <EvanR> or chr and ord
15:13:21 <btcNeverSleeps> Denommus: yes but
15:13:44 <EvanR> which only involves simple types
15:13:47 <EvanR> :t chr
15:13:48 <lambdabot> Int -> Char
15:14:05 <btcNeverSleeps> "not in scope: 'chr'"
15:14:14 <EvanR> import Data.Char
15:14:17 <btcNeverSleeps> k
15:14:47 <Denommus> btcNeverSleeps: have you ever constrained a generic with an interface in Java?
15:15:43 <btcNeverSleeps> Denommus: what do you mean by "constrained"? I used to use generics all the time since Java 1.5 came out (1.5 IIRC, it was a long time ago) :-/
15:17:22 <Denommus> btcNeverSleeps: like `public <T extends Foo> boolean bar(Collection<T> c);`
15:17:32 <btcNeverSleeps> Denommus: oh yes yes sure
15:17:48 <Denommus> btcNeverSleeps: the type "T" is being coonstrained by the class or interface "Foo" in this example
15:18:03 <Denommus> btcNeverSleeps: so. When using a typeclass, you're doing more or less the same
15:18:34 <mniip> I found an interesting trick
15:18:45 <mniip> > let nan = 0/0 in nub [nan, nan]
15:18:46 <Denommus> btcNeverSleeps: Eq a => a -> a -> Bool means that the type parameter a "extends" Eq
15:18:46 <lambdabot>  [NaN,NaN]
15:18:47 <btcNeverSleeps> Denommus: thanks, that really helps... From seeing thinks like "Eq" and "Show" etc. I didn't think about generics but simply in term of interface.
15:19:10 <quchen> mniip: NaN is unequal to everything by definition
15:19:20 <mniip> yeah
15:19:24 <verement> > 0/0 == 0/0
15:19:25 <lambdabot>  False
15:19:39 <Denommus> btcNeverSleeps: something equivalent in Java would be public <A extends Eq> boolean equal(T a, T b);
15:19:40 <mniip> which has fancy effects over nub
15:19:43 <mniip> because it uses Eq
15:22:27 <btcNeverSleeps> ok and I may have another related silly question: once you have   Eq a => a -> a -> Bool    can you somehow take this function and make it monomorphic?   (not that it would make sense to make something less "generic", it's just to understand)    Say I want to write "charequal" and have it be   "Char -> Char -> Bool"
15:22:47 <mniip> yes
15:22:49 <c_wraith> btcNeverSleeps: just put a type signature on it
15:22:51 <mniip> just add a type annotation
15:23:10 <c_wraith> btcNeverSleeps: charequal :: Char -> Char -> Bool ; charequal = (==)
15:23:37 <btcNeverSleeps> ooooooh
15:23:37 <mniip> charequal = (==) :: Char -> Char -> Bool
15:23:44 <mniip> although this is usually not used
15:24:29 <mniip> it is considered good tone to have all functions type-annotated, and the type restriction becomes useless once you do that, and you end up with c_wraith 's code
15:24:39 <btcNeverSleeps> I would have written    charequal :: Char -> Char -> Bool ; charequal a b = a (==) b      but that's just because I'm an Haskell newbie : )
15:24:50 * hackagebot language-c-inline 0.7.9.1 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.9.1 (ManuelChakravarty)
15:24:58 <mniip> if you use infix ==, you should remove the parentheses
15:25:26 <btcNeverSleeps> mniip: the compiler would have caught that ; )
15:25:29 <quchen> Hmm, when I enter `:t (==) :: Char -> _` in GHCi 7.10 I get a warning
15:25:43 <quchen> (And the right type)
15:25:50 <CapitalSigma> hello all
15:26:00 <c_wraith> quchen: did you enable the extension for partial type signatures?
15:26:04 <quchen> Yes
15:26:07 <CapitalSigma> what does the output "filename: <<loop>>" mean? google isn't very helpful
15:26:26 <c_wraith> quchen: I *think* that's a bug, then.  I reported it before the RCs, but no one appeared to care.
15:26:27 <mniip> CapitalSigma, it's GHC attempting to detect infinite loops in your program
15:26:27 <shachaf> @google ghc loop
15:26:28 <lambdabot> http://stackoverflow.com/questions/21505192/haskell-program-outputs-loop
15:26:28 <lambdabot> Title: debugging - Haskell program outputs `<<loop>>` - Stack Overflow
15:26:29 <btcNeverSleeps> thanks a lot everyone... Once again: cut 'n' pasting all this in my "Haskell notes".
15:26:36 <shachaf> Works for me. :-)
15:26:42 <CapitalSigma> thanks
15:26:54 <quchen> c_wraith: When I don't enable partial type signatures then I don't get the right type out, but the warnings happen in both cases.
15:27:11 <quchen> Time to start lobbying for making ?foobar the hole syntax
15:28:19 <c_wraith> I wonder why that warning persists when the extension is enabled.  It kind of gets in the way of using it when it's helpful.
15:29:05 <quchen> The warning changes though, because if you don't have it enabled it tells you about it.
15:29:25 <quchen> http://lpaste.net/129944
15:30:02 <quchen> c_wraith: Is that your bug or should I see whether it's a new ticket?
15:30:17 <c_wraith> I didn't report it on trac
15:31:10 <ryantrinkle> anyone have an opinion on what the current best "ListT done right" implementation is?
15:33:32 <quchen> ryantrinkle: pipes?
15:34:10 <ryantrinkle> quchen: woah, really?
15:34:19 <ryantrinkle> that's cool
15:34:39 <ryantrinkle> how does that work?
15:36:41 <quchen> Pipes.Tutorial talks about it a bit
15:36:51 <quchen> (In the pipes module)
15:36:55 <quchen> package*
15:38:50 <ryantrinkle> quchen: isn't this more like a ZipListT?
15:39:14 <ryantrinkle> i'm looking for something to search a solution space with backtracking
15:39:40 <quchen> I don't know what a ZipListT is.
15:40:59 <ryantrinkle> quchen: i mean, if i do something like sequence [[1,2,3], [4,5,6]], am i going to get 3 results or 9?
15:42:12 <quchen> 9. The docs even mention that ListT is the nondeterminism monad transformer.
15:42:21 <ryantrinkle> quchen: ah, ok, cool
15:42:28 <ryantrinkle> ohh, i see
15:42:36 <quchen> The Applicative instance is quite readable
15:43:02 <quchen> And it clearly cross-multiplies things, enumerating all RHS-elements for each LHS-element
15:43:06 <ryantrinkle> ListT is also provided by pipes; i was thinking that pipes *was* the ListT implementation
15:43:14 <quchen> Ah, no :-)
15:43:21 <ryantrinkle> that makes way more sense, lol :)
15:43:22 <quchen> ListT is just a very thin wrapper though
15:43:26 <ryantrinkle> right
15:43:28 <ryantrinkle> that's really cool
15:43:58 <quchen> Yes it is! That said, good night.
15:44:11 <ryantrinkle> goodnight
15:47:56 <dedgrant> Hi haskellers.. anyone using hxt on windows notice that xunpickleDocument causes openBinaryFile to emit an invalid path to the Windows CreateFile API after being invoked a number of times? (It is perhaps some sort of cache or buffer overflow triggering this.) Very mysterious.
15:48:28 <dedgrant> (by invoked I mean runX $ xunpickleDocument .. )
15:54:34 <fnord__> hey guys, I'm having troubles with OpenGL: Everything segfaults, even minimal programs
15:54:52 * hackagebot clist 0.1.0.0 - Counted list  http://hackage.haskell.org/package/clist-0.1.0.0 (MatthewFarkasDyck)
15:55:14 <fnord__> for example a single invocation of GLFW.init or GLUT.createWindow causes the program to die
15:59:35 <dedgrant> fnord__: Which OS/architecture?
15:59:50 <fnord__> dedgrant: I'm on nixos using proprietary ati drivers
15:59:52 * hackagebot monad-logger-json 0.1.0.0 - JSON-friendly Logging APIs  http://hackage.haskell.org/package/monad-logger-json-0.1.0.0 (dysinger)
15:59:54 * hackagebot monad-logger-syslog 0.1.1.0 - syslog output for monad-logger  http://hackage.haskell.org/package/monad-logger-syslog-0.1.1.0 (dysinger)
16:00:02 <fnord__> glxgears runs fine
16:01:57 <dedgrant> fnord__: Shoot that's a bit out of my ken. Perhaps the wrong dev libs are in your path? Maybe do a quick spot check using 'file' to make sure the correct dev and distro libs for your architecture are on the path?
16:02:15 <dedgrant> fnord__: 64 vs 32 bit mixups etc.
16:02:38 <fnord__> and it's a 64bit architecture
16:02:44 <HeladoDeBrownie> what does this mean when it says "Running two AcidState's from the same directory is an error but will not result in dataloss."? http://hackage.haskell.org/package/acid-state-0.12.4/docs/Data-Acid-Local.html
16:03:11 <HeladoDeBrownie> in other words, what *does* go wrong?
16:03:27 <fnord__> dedgrant: what do you mean by "spot check using file"?
16:06:04 <dedgrant> fnord__: Shell command: http://explainshell.com/explain?cmd=file   .. try checking the file types of the libraries (.so) you're linking 
16:06:14 <EvanR> HeladoDeBrownie: i bet its written to assume only one acid state is running on a database at a time
16:06:25 <EvanR> basically unpredictable corruption of the logs
16:06:46 <fnord__> dedgrant: Ah I see. Thanks, I'll try! :)
16:06:54 <HeladoDeBrownie> EvanR, that sounds like it contradicts "will not result in dataloss"
16:06:59 <dedgrant> fnord__: Just a shot in the dark.. :)
16:07:02 <EvanR> oh
16:07:08 <HeladoDeBrownie> looking at the source, it seems to use a lock of some sort
16:07:25 <EvanR> HeladoDeBrownie: then i guess they check for that and bail out before it causes mayhem
16:09:45 <HeladoDeBrownie> ah, i think i found it. in the internal FileIO module it seems to throw if the lock cannot be taken
16:19:53 * hackagebot wai-middleware-consul 0.1.0.0 - Wai Middleware for Consul  http://hackage.haskell.org/package/wai-middleware-consul-0.1.0.0 (dysinger)
16:25:36 <TRManderson> best way to install haskell for a recent GHC/base on ubuntu?
16:27:11 <kadoban> TRManderson: I follow these: https://gist.github.com/ion1/2815423   Haven't used them for 7.10 yet, but it should work.
16:28:33 <TRManderson> I don't necessarily want 7.10, but higher than 7.6.3 would be nice
16:28:46 <TRManderson> Is there any reason I shouldn't want 7.10?
16:28:57 <TRManderson> other than it being super new
16:29:23 <mpickering> TRManderson: the easiest way is to use hvr's ppa
16:29:29 <kadoban> TRManderson: No idea. I'm on 7.8.4 and it's good. I'm excited about the prelude changes and stuff in 7.10, but they'll also break some parts of my work I think.
16:29:44 <arkeet> it's super new so a fair bit of code probably needs to be updated to work with it
16:29:44 <glguy> Some libraries haven't been updated to work with 7.10.1. If you wanted to use one that could be a problem
16:29:48 <kadoban> (Like stackage isn't going to work yet I'm sure, etc.)
16:29:53 <mpickering> https://launchpad.net/~hvr/+archive/ubuntu/ghc
16:30:22 <TRManderson> Oh yeah, the monad/applicative thing
16:30:44 <TRManderson> thanks for the help/comments everyone :)
16:31:07 <kadoban> That and the generalization of some of the prelude list stuff and etc, the bridge-burning-proposal
16:34:54 * hackagebot gl 0.7.4 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.4 (Polarina)
16:34:56 * hackagebot overture 0.0.5 - An alternative to some of the Prelude.  http://hackage.haskell.org/package/overture-0.0.5 (fozworth)
16:34:58 * hackagebot pseudo-trie 0.0.2 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.2 (athanclark)
16:54:55 * hackagebot simple-smt 0.6.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.6.0 (IavorDiatchki)
17:07:19 <juri_> has anyone started on a slicer, for 3d printable objects?
17:10:48 <dreams> Is there a function like partition that returns [[a]] instead of ([a],[a]) ?
17:11:16 <mniip> group
17:11:17 <mniip> ?
17:12:00 <hodapp> whoa... I just discovered Data.Reify
17:12:14 <dreams> mniip: the problem with group is that it only group by next elements.
17:12:26 <dreams> > group [1,3,1]
17:12:27 <lambdabot>  [[1],[3],[1]]
17:12:32 <hodapp> thank you to whoever put me on the long road via the paper "Type-Safe Observable Sharing in Haskell"
17:12:42 <dreams> mniip: I want it [[1,1],[3]]
17:12:43 <mniip> group.sort
17:12:43 <hodapp> since that gave some nice insight into its desgin
17:12:48 <hodapp> s/desgin/design/
17:12:52 <mniip> hmm that's terrible
17:13:05 <dreams> mniip: why?
17:13:43 <mniip> unnecessary Ord constraint
17:13:53 <dreams> > (group . sort) ["blue","red","blue"]
17:13:55 <lambdabot>  [["blue","blue"],["red"]]
17:14:17 <dreams> mniip: the order doesn't matter as long as their uniquely grouped.
17:14:23 <dreams> > (group . sort) ["blue","red","blue", "red"]
17:14:24 <lambdabot>  [["blue","blue"],["red","red"]]
17:14:34 <dreams> mniip: yup that's what I wanted thanks.
17:14:46 <mniip> no I mean
17:14:50 <mniip> :t group . sort
17:14:51 <lambdabot> Ord a => [a] -> [[a]]
17:14:59 <dreams> ah
17:15:03 <mniip> you're unable to operate on values that have Eq but not Ord
17:15:19 <arkeet> without the Ord constraint it would be a lot slower.
17:15:56 <arkeet> asymptotically.
17:16:01 <mniip> true
17:17:22 <scshunt> argh I hate cabal
17:17:39 <scshunt> hlint is broken
17:17:41 <scshunt> whyyyyy
17:30:22 <rcyr> Hi, I would like to know how you would name these two functions (<*) and (*>) in applicative.I'm writing a FP lib for some awful language...
17:31:06 <HeladoDeBrownie> rcyr, less than asterisk, asterisk greater than :P
17:31:15 <rcyr> Haha :D
17:31:32 <HeladoDeBrownie> rcyr, anyway, not sure, but they're like "ap" (<*>) albeit with one side's output discarded
17:31:38 <HeladoDeBrownie> leftAp?
17:31:40 <HeladoDeBrownie> rightAp?
17:31:48 <rcyr> Yeah, it's basically lifted "const"
17:31:52 <HeladoDeBrownie> probably not very good names, but might get you started
17:32:29 <mniip> rcyr, how did you name <*>
17:32:30 <rcyr> HeladoDeBrownie: Actually, your idea is not bad.
17:32:34 <rcyr> mniip "ap"
17:32:42 <mniip> hmm
17:32:59 <rcyr> :t ap
17:33:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:33:05 <mniip> close enough
17:33:26 <rcyr> I thought of calling them apFst and apSnd but meh..
17:33:29 <HeladoDeBrownie> ap and (<*>) are functionally the same for well behaved instances
17:34:03 <mniip> rcyr, apConst
17:34:04 <mniip> apConstId
17:34:35 <rcyr> mniip: I thought of something similar... but then I couldn't find a name for the opposite
17:34:38 <rcyr> Heh.
17:34:49 <mniip> the opposite?
17:34:49 <rcyr> apFlipConst ? :P
17:35:01 <mniip> apConst is the opposite of apConstId
17:35:12 <mniip> :t const
17:35:13 <lambdabot> a -> b -> a
17:35:14 <mniip> :t const id
17:35:15 <lambdabot> b -> a -> a
17:35:29 <jle`> rcyr: *> is commonly called sequence
17:35:41 <jle`> or "and then", or "semicolon"
17:35:50 <arkeet> I wouldn't call it sequence, because sequence is something else.
17:35:52 <khumba> lap, rap?
17:36:01 <jle`> i wouldn't call it sequence, but it's commonly called sequence informally
17:36:13 <rcyr> khumba: I might just go with those
17:36:26 <jle`> i wouldn't really call it ap because it doesn't really apply anything
17:36:37 <jle`> hm
17:36:44 <jle`> lap and rap are cute though
17:36:46 <rcyr> seql and seqr?
17:36:58 <jle`> ooh
17:37:14 <jle`> some people also call it fast forward but that's kinda weird
17:37:57 <jle`> why 'fast'?
17:38:08 * jle` ponders
17:38:41 <mniip> think cassette players
17:38:59 <jle`> i guess
17:39:15 <mniip> <* wouuld then be rewind?
17:39:16 <jle`> x *> y is like...play x, then fast forward and play y?
17:39:19 <jle`> lol
17:39:44 <rcyr> Haha
17:40:28 <rcyr> Thanks everyone :)
17:40:40 <jle`> maybe...squashl and squashr
17:40:57 <jle`> x *> y, squash x and y together but only keep the reuslt of y
17:41:05 <jle`> heh
17:41:21 <mniip> and <* is rebase?
17:42:03 <jle`> *> is "andThen"... <* is "alsoWith" :o
17:42:28 <arkeet> > join (*>) "asdf"
17:42:29 <lambdabot>  "asdfasdfasdfasdf"
17:43:44 <jle`> getLine <* putStrLn "hey" is getLine...but also with printing "hey"
17:43:58 <int-e> scshunt: fwiw, "foo is broken" is not a useful error description.
17:44:12 <jle`> putStrLn "hey" *> getLine is putting "hey" and then getting a line
17:44:35 <jle`> :|
17:46:06 <scshunt> int-e: yeah, I'm sure that they'll notice it. I think an upstream dependency of hlint changed something
17:46:23 <scshunt> I don't need ghc-mod working now, if it's still broken in a week I'll actually investigate
17:46:28 <scshunt> but hlint won't build for me atm
17:46:59 <khumba> > join (<*) "adsf"
17:47:00 <lambdabot>  "aaaaddddssssffff"
17:47:06 <arkeet> :)
17:47:10 <khumba> that's cool
17:47:18 <jle`> oh that's cute
17:47:36 <jle`> > "asdf" <* [1,2,3,4,]  -- concatMap (replicate 4)
17:47:37 <int-e> scshunt: Well, I've just successfully built hlint-1.9.19 with ghc-7.8.3 on Linux. Trying ghc-7.10.1... haskell-src-exts always takes a while.
17:47:38 <lambdabot>  <hint>:1:20: parse error on input ‘]’
17:47:43 <jle`> > "asdf" <* [1,2,3,4]  -- concatMap (replicate 4)
17:47:44 <lambdabot>  "aaaassssddddffff"
17:48:42 <jle`> > [1,2,3,4] *> "asdf"  -- concat . replicate 4
17:48:43 <lambdabot>  "asdfasdfasdfasdf"
17:48:49 <int-e> Btw, why does hlint treat potential eta reductions as an error?
17:48:52 <timmy_tofu> Can anybody help me figure out this quantification issue? http://lpaste.net/9034070077678288896
17:53:05 <jle`> i've had the same issue with ($) too :|
17:54:03 <HeladoDeBrownie> timmy_tofu, you normally cannot instantiate a variable with a polytype
17:54:23 <HeladoDeBrownie> timmy_tofu, you might try hiding it behind a constructor? not sure, that may help
17:55:16 <HeladoDeBrownie> (|>) could be given a more specific type perhaps
17:55:17 <fluvian> in the first example, how does ghc know where to look for "time" and "sin" in the foreign import statements?
17:55:18 <fluvian> https://wiki.haskell.org/FFI_complete_examples
17:55:28 <timmy_tofu> HeladoDeBrownie: I'm not sure what you mean, hide what behind a constructor?
17:55:33 <HeladoDeBrownie> timmy_tofu, the polytype
17:55:34 <fluvian> which header files is it using?
17:55:50 <mniip> fluvian, header files?
17:55:57 <mniip> FFI doesn't need header files
17:56:00 <HeladoDeBrownie> timmy_tofu, so practically that means something like data T = A (forall …. …)
17:56:12 <arkeet> (a newtype will do)
17:56:24 <fluvian> mniip: OK, but what's the entry point to the C library?
17:56:38 <mniip> you only need the name of a value, and its type
17:56:40 <fluvian> "sin" is in "math.h" but I never specified to include that
17:56:48 <mniip> sin is not in math.h
17:56:53 <mniip> sin is in libm.so
17:57:12 <mniip> which is used by default in GHC along with libc
17:58:18 <fluvian> OK, how do I see which libraries GHC is including?
17:58:31 <fluvian> is it just libm and libc?
17:58:32 <rcyr> I'm writing a FP lib for PHP... I'm disgusted as I'm writing it. So ugly... so verbose. Wish I could use Haskell at work :'(
17:58:33 <timmy_tofu> That doesn't seem to have helped, though I don't know if I've done it as you were imagining.
17:58:48 <timmy_tofu> Still, if I'm wrapping it up like that I'm not saving anything, really
17:59:12 <mniip> fluvian, try 'ldd' on the compiled executable
18:00:22 <fluvian> I have to use `otool -L` since I'm on OS X... but I get neither libc nor libm
18:00:36 <fluvian> I get libiconv, libgmp, and libSystem
18:02:17 * mniip has little idea of OS X dynamic linking
18:03:29 <int-e> scshunt: works for me with ghc-7.10.1 too. Maybe the OS matters.
18:03:33 <scshunt> hmm
18:03:37 <scshunt> I'm on debian jessie
18:03:47 <scshunt> int-e: is this on a fresh cabal?
18:03:47 <HeladoDeBrownie> rcyr, oddly that was my guess based on what you said earlier
18:04:08 <scshunt> int-e: I suspect what happened is a dependency changed an API and broke it
18:04:18 <rcyr> HeladoDeBrownie: Hehe, could have been JavaScript too :) But yeah...
18:04:25 <HeladoDeBrownie> rcyr, i will note that haskell's notion of higher-kinded polymorphism tends not to translate well to unityped languages
18:04:56 <int-e> scshunt: same here, but I build my own ghcs.
18:05:01 * hackagebot config-value 0.4 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.4 (EricMertens)
18:08:36 <rcyr> HeladoDeBrownie: I just wanted to have a "Maybe" and a "EIther" monad + a "Validation" applicative... and some utilities for arrays... It's probably as FP as it's ever going to get at my workplace.
18:10:03 <scshunt> int-e: can you try again in a fresh sandbox?
18:10:14 <scshunt> I'm on 7.6.3 of ghc, apparently
18:11:03 <HeladoDeBrownie> rcyr, hmm, i can see a church encoding working out there. have a function (or an object with a method, if you prefer) that takes two other functions, one for the Left/Nothing case, one for the Right/Just case. implement everything else in terms of that.
18:11:21 <int-e> scshunt: I used a sandbox. Let's see how ghc-7.6.3 fares...
18:12:03 <rcyr> HeladoDeBrownie: I'll take a look at that, right now... it's implemented via class inheritance :X
18:12:35 <HeladoDeBrownie> that could work too
18:12:39 <HeladoDeBrownie> lots of ways to encode that type
18:15:01 * hackagebot vector-algorithms 0.6.0.4 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.6.0.4 (DanDoel)
18:15:25 <HeladoDeBrownie> left = \x f g.f x ; right = \x f g.g x ; return = right ; id = \x.x ; mapRight = \g e.e id g ; …
18:15:48 <HeladoDeBrownie> (i don't know enough php to actually do this translation)
18:18:14 <HeladoDeBrownie> join = \e f g.e id (\e'. e' f g)
18:18:20 <HeladoDeBrownie> i think that's right
18:18:30 <HeladoDeBrownie> i'm getting a little carried away, this is kind of fun :P
18:18:58 <rcyr> HeladoDeBrownie: You don't miss much... it's like the worst language ever for closures... You need to explicitly pass the 'outer scope' variables into it.
18:19:09 <HeladoDeBrownie> ah, well
18:19:18 <HeladoDeBrownie> inheritance it is, i guess?
18:19:39 <HeladoDeBrownie> i'm sure the above can be translated relatively straightforwardly into js at least
18:22:25 <int-e> scshunt: oh do you have alex and happy installed?
18:23:19 <scshunt> int-e: no. but I was getting type errors
18:24:21 <scshunt> trying again with a completely clean cabal
18:41:24 <pacak> Btw, is there any easy ways with cabal sandboxes to get a list of packages installed in a given sanbox?
18:42:10 <bergey> cabal sandbox hc-pkg list
18:42:46 <pacak> That also gives globally installed packages. 
18:43:06 <pacak> I want only those from sandbox itself.
18:44:02 <pacak> It's possible to do some magic with awk but that kind of feels wrong.
18:44:26 <geekosaur> sadly it ignores -- --user (the -- needed to hide --user from the main cabal command)
18:44:41 <geekosaur> interestingly -- --help does what I'd expect, so something else is overriding
18:44:56 <bergey> Something like --user or --global for ghc-pkg ... I don't know of one.
18:46:15 <geekosaur> awk is overkill anyway. cabal sandbox hc-pkg list | sed '1,\,/,d'
18:48:17 <pacak> geekosaur: Or that, yes. It's just awk is my usual to go instrument for this kind of stuff.
19:25:02 <pacak> Can't use shell pipes since that should be executed as a subprocess from shell. Don't want to parse output in haskell...
19:26:44 <recliner> can someone tell me the best way to parse arbitrary text between keywords "begin" and "end" using parsec?
19:28:25 <recliner> something similar to the regex /begin.*?end/
19:28:42 <pacak> recliner: between (try $ string "begin") (try $ string "end")  (many blah), just make  sure your blah won't match "end"
19:29:10 <pacak> But I'd go with tokenizer in this case.
19:29:36 <recliner> ive tried something similar with "many anyChar", but obviously that matches "end"
19:30:05 <erikd> recliner: you should probably be using a Token parser rather than a Char parser
19:30:25 <pacak> many (fail "kaboom" <$ string "end" <|> many anyChar)
19:30:51 <pacak> try (string "end")
19:32:17 <recliner> pacak: would that be very efficient. it seems like you would be doing lots of backtracking
19:32:37 <pacak> recliner: That's why you should use tokenizer
19:32:52 <int-e> pacak: the -- works fine, but --user doesn't work because sandboxes do not use the user package db; they rely on ghc's support for several ("global") package databases. (try  cabal sandbox -v hc-pkg list  to see the command line)
19:33:39 <recliner> pacak, erikd: does parsec have a tokenizer built into it that would be sufficient for my purposes? i'm already using it but havent come across anything that would solve my problem directly
19:34:00 <arkeet> that's a pretty old ghc
19:34:15 <arkeet> oops I was scrolled way up.
19:34:15 <arkeet> ugh
19:34:26 <erikd> recliner: yes, built in : http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Token.html
19:34:45 <erikd> sorry, use http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html
19:36:39 <pacak> int-e: I know the command line. At the moment I'm trying to automate sources registering/unregistering in sandbox using shake after unpacking-removing package sources into some specific  folder.
19:36:58 <recliner> erikd: is this really a tokenizer? the multiline comment parsing looks like char parsing to me
19:37:41 <pacak> recliner: It's easy to make tokenizers with that
19:38:00 <pacak> For some definitions of "easy" :)
19:41:02 <recliner> i use the "reserved" and "identifer" functionalities in other places in the parser
19:41:40 <recliner> but i dont think that between (reserved "begin") (reserved "end") (many identifier) will work
19:43:26 <glguy> recliner: What're you parsing?
19:43:46 <recliner> glguy: i'm trying to make an island parser for the verilog language
19:44:47 <Buttons840> instance Functor ((->) t) where ...     -- what is this? 
19:45:08 <recliner> glguy: there are only a few things i care about, so im stripping out all the junk im not going to look at (like expressions) and save myself the trouble of writing more parser than i need
19:45:09 <HeladoDeBrownie> Buttons840, that's an instance declaration. the part up to the ellipsis is called an instance head
19:45:11 <int-e> pacak: I hope there's something better than this: cabal exec -- sh -c 'ghc-pkg list --package-db=${GHC_PACKAGE_PATH%:*} --simple-output'
19:45:14 <Buttons840> (->) must be a name of a data type i'm guessing? where is it defined, or is this a magic part of the language?
19:45:27 <HeladoDeBrownie> Buttons840, correct. it's the (primitive) type of functions
19:46:21 <Buttons840> wow, I just made the connection between 1 :: Double and f :: Int -> Int     they're both just types
19:46:27 <HeladoDeBrownie> yep!
19:47:09 <Buttons840> but a function valid function type is something like   f :: a -> a
19:47:19 <Buttons840> not  f :: -> a
19:47:52 <HeladoDeBrownie> (->) t is not a concrete type, right; it's still a valid type though.
19:48:17 <HeladoDeBrownie> types of the Functor class are of kind * -> *
19:48:26 <HeladoDeBrownie> which means, if you apply them to a concrete type, you get a concrete type
19:48:31 <HeladoDeBrownie> concrete, like Bool or Int -> Int
19:48:45 <HeladoDeBrownie> if you look at the type of fmap this might be clearer
19:48:47 <HeladoDeBrownie> @type fmap
19:48:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:49:03 <HeladoDeBrownie> so, f equals (->) t for some t for the function instance
19:49:09 <HeladoDeBrownie> so, substituting, you get
19:49:24 <HeladoDeBrownie> fmap :: (a -> b) -> (->) t a -> (->) t b
19:49:41 <HeladoDeBrownie> this can be converted so the (->) constructor is applied infix as usual:
19:49:46 <Buttons840> so just like Maybe is a...  partial type? (terminology?)  (->) a is a partial type
19:49:49 <HeladoDeBrownie> fmap :: (a -> b) -> (t -> a) -> (t -> b)
19:50:16 <HeladoDeBrownie> (->), Maybe, and Int are all type constructors. (->) and Maybe are, you could call them, type-level functions.
19:50:52 <HeladoDeBrownie> though the terminology can get a bit confusing.
19:51:03 <HeladoDeBrownie> some people use "type constructor" to mean "type-level function".
19:51:04 <Buttons840> and i guess (->) Int Int would be a concrete type?
19:51:08 <HeladoDeBrownie> that's right.
19:51:12 <monochrom> it may be desirable to directly talk about their kinds. Int's kind is *, (Maybe Int)'s kind is * too, and Maybe's kind is * -> *
19:51:16 <HeladoDeBrownie> you can see this by looking at the *kinds* of those terms
19:51:25 <HeladoDeBrownie> @kind (->)
19:51:26 <lambdabot> * -> * -> *
19:51:27 <HeladoDeBrownie> @kind Int
19:51:28 <lambdabot> *
19:52:04 <monochrom> similarly, (Int->Bool) aka ((->) Int Bool)'s kind is *, ((->) Int)'s kind is * -> *
19:52:07 <HeladoDeBrownie> so, (->) can be applied to Int since the kinds match. and (->) Int can be applied to Int, and then you end up with (->) Int Int, a concrete type.
19:54:10 <HeladoDeBrownie> by the way, the only types that are inhabited (by values) are of kind *.
19:54:21 <HeladoDeBrownie> that's why we care so much about "concrete types"
19:54:40 <HeladoDeBrownie> welll
19:54:46 <HeladoDeBrownie> that's not quite the whole story but it's close
19:54:55 <HeladoDeBrownie> there's also unboxed types, of kind #
19:55:05 <Buttons840> i read all this in LYAH, but it hasn't all fit together for me yet
19:55:55 <Buttons840> now I'm doing the NICTA course
19:57:21 <joeyh> has anyone else ever been shot in the foot by Default r => Default (e -> r) ?
19:58:10 <Buttons840> so a function like add :: Int -> Int -> Int :: (Int -> Int) -> Int :: (->) (Int -> Int) Int
19:58:13 <joeyh> A while ago I had a bug where I thought def was providing a default value, but it was instead providing this default function, that ignored the parameter I'd accidentially left off
19:58:25 * joeyh is feeling wary of Default now
19:58:33 <arkeet> Buttons840: Int -> Int -> Int is Int -> (Int -> Int)
19:58:35 <HeladoDeBrownie> Buttons840, you're using :: incorrectly, but i'm not sure what you mean to say
19:58:53 <Buttons840> ah
19:59:00 <geekosaur> joeyh, a number of people think Data.Default is asking for trouble in general
19:59:00 <HeladoDeBrownie> :: means "has type" or "has kind"
19:59:17 <Buttons840> ok
19:59:32 * geekosaur is inclined to agree and would have recommended against xmonad using it if he'd been asked before that change got pushed...
20:00:01 <HeladoDeBrownie> Buttons840, do you know what's meant by "right-associative"?
20:00:22 <joeyh> yeah, I can see maybe refactoring something to a different data type and suddenly that def in the code is providing a value that's not at all suitable anymore ..
20:00:27 <Buttons840> HeladoDeBrownie: well enough
20:00:49 <HeladoDeBrownie> Buttons840, okay, well (->) is right-associative.
20:01:18 <HeladoDeBrownie> so A -> B -> C is really just a function accepting a value of type A and resulting in a value of type B -> C.
20:01:35 <dpwright> I am looking for a function something like "Map k a -> Map a [k]" -- in other words it turns the values into keys and then gives you a map from value to "the keys which would give you this value in the original map"
20:02:03 <dpwright> that feels like something that is probably much more general than just "Map", but I'm not sure what to search for to find it
20:02:50 <geekosaur> http://hackage.haskell.org/package/bimap ?
20:03:08 <geekosaur> hm, possibly not
20:03:15 <HeladoDeBrownie> dpwright, i'm not sure if it exists but the multimap package might help
20:03:36 <HeladoDeBrownie> inserting into a MultiMap is basically just appending to a list
20:03:37 <pavonia> insertWith something . fromList . swap . toList
20:03:44 <dpwright> geekosaur: Thanks, but "Each value in the bimap is associated with exactly one value of the opposite type" is the problem with that one
20:04:58 <dpwright> pavonia: Yeah, I suppose it's not that hard to create by shuffling to and from a list, I just wondered if there was a solution already out there (perhaps something more general than exactly what I outlined above which would teach me something new and beautiful about things of that structure)
20:05:07 * hackagebot Redmine 0.0.5 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.5 (cstpierre)
20:06:31 <dpwright> HeladoDeBrownie: MultiMap looks like the kind of shape I'm looking for... will have a bit more of a look and see if it's appropriate -- thanks
20:09:24 <srid> Reading how foldl/foldr can be generalized into other data-structures (catamorphisms) is mildly mind-blowing. Well, something new learned today. http://en.wikibooks.org/wiki/Haskell/Other_data_structures
20:09:35 <arkeet> just foldr though.
20:11:31 <arkeet> if someone knows how to generalize foldl I want to hear about it.
20:11:39 <johnw> well, foldl by implementing it using foldr :)
20:12:52 <shachaf> arkeet: i,i "*2. Show that 17 × 17 = 289. Generalise this result."
20:13:20 <shachaf> srid: The common name for "catamorphism" is "fold".
20:13:28 <shachaf> No need to use a fancy word.
20:14:13 <monochrom> generalised result: n×n = n^2
20:14:16 <HeladoDeBrownie> there's a *profusion* of fancy words involved in haskell already :)
20:15:13 <shachaf> Fancy words are to be avoided.
20:15:25 <arkeet> common words are also to be avoided.
20:15:32 * enthropy writes combinators
20:15:42 <johnw> sufficiently fancy to be clear, sufficient common to be understood
20:15:50 <HeladoDeBrownie> johnw++
20:15:58 <dolio> Most of those are fancy words that lead you to work in some other field that's relevant to what you want to know.
20:16:19 <srid> i like to hear about things like 'catamorphism' because then i can look up how such a common concept like 'fold' is connected all the way back to its theoretical underpinnings (category theory, in this case, apparently)
20:16:29 <dolio> 'Catamorphism,' is a word that was made up for one paper, and leads you to work on people making up other fancy words for slight variations on folds and unfolds.
20:16:59 <arkeet> common words have the other problem that they already carry meaning.
20:17:08 <arkeet> well, existing words in general.
20:17:14 <srid> out of curiosity, have anyone made an animation of how fold 'works'. 
20:17:16 <shachaf> The category name for "fold" is "fold" as far as I know.
20:17:17 <HeladoDeBrownie> let's just stick to nonverbal communication
20:18:12 <srid> s/animation/visualization
20:18:19 <srid> i'm thinking of something like this: http://betterexplained.com/archives/
20:18:38 <monochrom> Cale made one
20:18:56 <Cale> I didn't make an animation
20:19:27 <johnw> I guess his explanation was so good, it made one in monochrom's mind
20:19:29 <Cale> but I did make this to help visualise the result of various folding operations http://cale.yi.org/share/Folds.png
20:19:30 <HeladoDeBrownie> i was going to say "i thought that was monochrom" before noticing who spoke
20:20:00 <HeladoDeBrownie> in short, i can't tell the difference between a fruit and lack of coloration.
20:20:15 <Cale> and I often like to link to this, even though it's fundamentally unsatisfying that we can't download and run it: http://www.cas.mcmaster.ca/~kahl/HOPS/
20:20:21 <dolio> I'm not sure category theorists would call it a 'fold' (if they thought to call it anything), but that'd be more likely than them calling it 'catamorphism.'
20:20:29 <Cale> It has some animated gifs of graph reduction: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
20:20:51 <srid> ^ pretty good link
20:20:53 <johnw> dolio: morphism in the category of F-Algebras?
20:21:18 <dolio> Yeah, it's a morphism out of an initial F-algebra.
20:21:20 <shachaf> I guess they'd just call it the initial arrow or something.
20:22:09 <dolio> _The_ morphism, I suppose.
20:23:30 * srid is skimming through http://en.wikibooks.org/wiki/Haskell hoping to be ready to hack afterwards.
20:23:45 <HeladoDeBrownie> srid, how about during?
20:24:12 <srid> skimming fast. for eg., i am just getting to the chapter in 'classes'. 
20:24:36 <srid> just need to complete skimming beginner's track, then i can start coding my ideas.
20:25:00 <srid> (until a couple of days ago, i was tempted to write it all in Go, but i resisted the temptation)
20:25:42 <srid> tutorial; skim book/ref.; hack, hack, hack; study in depth.
20:25:56 <HeladoDeBrownie> i wonder why that wikibook isn't more recommended.
20:26:05 <srid> it is pretty good actually.
20:26:26 <dpwright> pavonia, ended up hacking something together based on yours.  This did the job: foldr (uncurry $ M.insertWith (++)) M.empty . map (second (:[]) . swap) . M.toList
20:26:29 <srid> i guess wikibooks doesn't have that usually "authoritarian" association as that of published books.
20:27:02 <srid> i like this wikibook more than LYAH. it has a straightforward no-BS approach.
20:27:42 <HeladoDeBrownie> i think i might show it to a friend who's trying to learn haskell. it looks better than most beginner resources i've seen. thanks for mentioning it.
20:28:52 <pavonia> dpwright: Ah right, fold, not fromList
20:38:18 <nitrix> Hi, I'm picking up SDL for Haskell, and I can't help but notice the SDL.Init and SDL.Quit. I'm okay with side effects, because it's typed, but I am a little disapointed by the SDL.Quit. You risk bringing C problems in with call order and so on.
20:38:31 <nitrix> Does Haskell has a mechanism to defer a function call upon termination of a computation?
20:38:45 <nitrix> Sort of RAII destructors from C++ or the `defer` keyword from Go ?
20:39:14 <HeladoDeBrownie> nitrix, depends on what you mean by "function call", "defer", "computation"…
20:40:03 <HeladoDeBrownie> nitrix, i'm not sure what you're expecting without involving IO though
20:40:31 <HeladoDeBrownie> oh, i misunderstood i think
20:40:38 <nitrix> HeladoDeBrownie: Computation could be the IO monad, defer as in deferring its execution to a further timeframe, function call as function evaluation (since haskell is lazy).
20:40:38 <HeladoDeBrownie> still, elaborate?
20:40:45 <carter>  nitrix  you can attach a finalizer to a foreign poitner
20:40:58 <nitrix> carter: Ah, that sounds a little closer.
20:41:03 <HeladoDeBrownie> nitrix, so, you want to execute an IO action… when?
20:41:05 <nitrix> carter: Only to pointers though?
20:41:26 <carter> nitrix: do you want to have an action run when a resource is no longer reachable via GC tracing?
20:41:28 <carter> or something else
20:41:34 <carter> please dont invent jargon :)
20:41:49 <nitrix> It's no new jargon.
20:42:18 <HeladoDeBrownie> the haskell jargon is notably different from that of other languages. in cases like this you're often better off saying "here's some code, here's what it does, here's what i'd rather do"
20:42:26 <carter> yes
20:42:29 <nitrix> HeladoDeBrownie: That's solely english here.
20:42:32 <nitrix> >> deferring: put off (an action or event) to a later time; postpone.
20:42:40 <carter> derfer til when
20:42:41 <HeladoDeBrownie> nitrix, "function call"
20:42:45 <carter> nitrix: is what i described what you want?
20:42:51 <carter> @google haskell ghc finalizer
20:42:53 <lambdabot> http://blog.ezyang.com/2014/05/the-cost-of-weak-pointers-and-finalizers-in-ghc/
20:42:53 <lambdabot> Title: The cost of weak pointers and finalizers in GHC : Inside 206-105
20:43:02 <nitrix> You're creating a meta problem, please don't and let me clarify.
20:45:16 <nitrix> I'd like to mark SDL.Quit to be executed upon program termination. I'm looking for a system that'd bring that guaranteed without relying on the developer to do it, which is a characteristic of C I didn't like,
20:46:03 <nitrix> Rust has a mechanism for lifetimes and resources like file handles are very well defined.
20:46:07 <awesomehaircut> hi I'm learning haskell after using python for about a year. Is there a cheat sheet type thing you guys would recommend?
20:46:20 <nitrix> Haskell it's abstracted; but then there's this, where you have Foreign C in haskell.
20:47:33 <HeladoDeBrownie> nitrix, your best option may be simply to use quit as the last thing in main. you could also make it the handler for the termination signal if necessary.
20:47:53 <HeladoDeBrownie> how "automatic" you can get in this regard may depend largely on the package interface.
20:48:24 <nitrix> HeladoDeBrownie: I understand, the goal is to NOT have quit as the last thing in main, because, again, you're relying on the user to sequence the IO in the sensible order.
20:48:40 <HeladoDeBrownie> nitrix, so, are you asking from the perspective of a package designer?
20:48:43 <nitrix> I'd like SDL.Quit to be necessarily the last thing.
20:49:08 <nitrix> HeladoDeBrownie: Of a language researcher, of a package designer, of a developer, all three maybe.
20:49:31 <nitrix> The concern revolves around the same idea.
20:49:36 <enthropy> instead of main = do SDL.init; blahblah; SDL.quit, consider withSDL blah = do SDL.init; blah; SDL.quit
20:49:56 <enthropy> so that main ends up being withSDL blahblah
20:50:09 * hackagebot indentation 0.2.1.1 - Indentation sensitive parsing combinators for Parsec and Trifecta  http://hackage.haskell.org/package/indentation-0.2.1.1 (AlekseyKliger)
20:50:17 <HeladoDeBrownie> one alternative that several packages use it to invert control, becoming a framework of sorts, where the user just provides a function that is used by the "main loop" and the library handles all the piping stuff together
20:50:20 <HeladoDeBrownie> gloss does this for example
20:50:24 <srid> interesting how 'class' and 'instance' have different semantics in Haskell, than in other languages.
20:50:27 <HeladoDeBrownie> so in that case you might have something like
20:50:40 <HeladoDeBrownie> runMyFramework :: (World -> Event -> World) -> IO ()
20:51:01 <newsham> hrmm.. why cant I make a typeclass that is the constraint "less than 25"? :)
20:51:02 <HeladoDeBrownie> srid, they're totally different concepts
20:51:21 <nitrix> enthropy: That doesn't solve anything. Your withSDL IO is sensible to the computation order.
20:51:34 <Maxdamantus> they mean the same thing, it just happens that instances are in a different universe (the universe containing types)
20:51:34 <nitrix> If I place SQL.quit before SDL.init, things break.
20:51:36 <srid> the wikibook says "Classes are not types, but categories of types; and so the instances of a class are types instead of values."
20:51:54 <srid> categories of types, not values.
20:51:58 <newsham> acc :: LT25 a -> a -> Vec25 b -> b
20:52:03 <newsham> acc :: LT25 a => a -> Vec25 b -> b
20:52:04 <enthropy> nitrix: how do you mean. The user calls withSDL and never sees SDL.quit/SDL.init
20:52:05 <Maxdamantus> "types" in a lazy sense.
20:52:23 <nitrix> enthropy: Except this isn't what the library exposes. The library gives SDL.quit and SQL.init.
20:52:35 <jxv> srid, "class" is short for typeclass. That quote is correct.
20:52:40 <HeladoDeBrownie> nitrix, not all packages are designed ideally
20:52:42 <roboguy_> srid: a type class is pretty much literally a "class of types"
20:53:11 <Maxdamantus> except they're not necessarily classes of actual types.
20:53:12 <HeladoDeBrownie> (although i'm not sure that what you're looking for *is* the ideal, if there is such a thing)
20:53:13 <srid> that makes more sense
20:53:19 <Maxdamantus> they could have kinds other than *.
20:53:22 <enthropy> nitrix: so you're saying withSDL is not a solution because SDL doesn't define it?
20:53:39 <Maxdamantus> like Monad.
20:53:51 <nitrix> HeladoDeBrownie: I agree. But I'm convinced someone takled the issue where foreign io actions would have a sensible ordering and build a mechanism to ensure deferring of some computations, for deallocation of resources, file handles and whatnot.
20:53:58 <HeladoDeBrownie> Maxdamantus, concrete types aren't the only things that are types
20:54:31 <Maxdamantus> > foo :: Monad m => m -> m Int; foo = foo
20:54:33 <lambdabot>  <hint>:1:29: parse error on input ‘;’
20:54:40 <Maxdamantus> > let foo :: Monad m => m -> m Int; foo = foo in foo
20:54:41 <lambdabot>      Expecting one more argument to ‘m’
20:54:41 <lambdabot>      Expected a type, but ‘m’ has kind ‘* → *’
20:54:41 <lambdabot>      In the type signature for ‘foo’: foo ∷ Monad m ⇒ m -> m Int
20:55:06 <Maxdamantus> HeladoDeBrownie: so why did it say a type is expected there?
20:55:11 <roboguy_> srid: instance puts a type into that class. A constraint (SomeClass t => ...) says that a type must be in that class. Things can get a little more complicated/different with some of the extensions, but that's one way to look at it
20:55:18 <HeladoDeBrownie> Maxdamantus, because the error message is poorly worded.
20:55:31 <roboguy_> Maxdamantus: an unfortunate wording
20:55:38 <Maxdamantus> Maybe other people's use of the term "type" is poorly worded.
20:56:15 <Maxdamantus> so is a type constructor a type?
20:56:16 <jxv> srid, another way of thinking of typeclasses is that they're similar adjectives. They imply some properties or functionalities and aren't the noun.
20:56:17 <HeladoDeBrownie> i would say that's pretty likely. terminology does have a tendency to get misused and misappropriated.
20:56:24 <HeladoDeBrownie> Maxdamantus, yeah
20:56:25 <jxv> to adjectives*
20:56:48 <nitrix> Maxdamantus: It's a type, but it isn't a concrete type.
20:57:07 <HeladoDeBrownie> nitrix, ah, you're using "type constructor" to mean "type-level function"?
20:57:13 <Maxdamantus> nitrix: what's a concrete type, if not the result of a type constructor?
20:57:24 <HeladoDeBrownie> Maxdamantus, not all type constructors result in a concrete type
20:57:31 <nitrix> Maxdamantus: Type constructors doesn't guarantee a concrete type.
20:57:40 <Maxdamantus> Do you have an example?
20:57:43 <nitrix> Maxdamantus: You can have partial application of your constructor.
20:57:48 <nitrix> Either a
20:57:48 <roboguy_> Maxdamantus: I think of it as similar to the fact that functions are values.
20:57:48 <Maxdamantus> one with a finite kind.
20:57:59 <Maxdamantus> (Either a) Int
20:58:00 <roboguy_> Maxdamantus: type functions are also types
20:58:04 <Maxdamantus> constructed a type.
20:58:31 <roboguy_> (just like "value functions" are values)
20:58:51 <nitrix> Either with the type a. Constructs another type, that isn't concrete.
20:59:00 <nitrix> It's like partial application for types, if you will.
20:59:30 <Maxdamantus> Yes, so `Either` and `Either a` are both ultimately type constructors.
20:59:32 <HeladoDeBrownie> i believe we should use "type constructor" to be analogous with "data constructor", and "type" to be analogous with "value" (with respect to type-level and value-level functions). not everyone does this however.
20:59:48 <arkeet> data constructors are values though.
20:59:49 <Maxdamantus> because you eventually get a type after applying the right things the right number of times in the right order.
20:59:53 <HeladoDeBrownie> Maxdamantus, so, for example, considering what i just said, Either a would not be a type constructor.
21:00:04 <nitrix> Maxdamantus: Yeah, but `Either a` could be considered a type constructed by Either.
21:00:50 <HeladoDeBrownie> (hmm, i wonder if "concrete value" is a useful term :P)
21:01:44 <roboguy_> Maxdamantus: having a distinction ends up causing more problems than it solves. It's like when someone asks how to have a type that allows any types that have "values" (meaning, no function types)
21:02:11 <naevathecat> hey folks, quick question. I need to have some 2D arrays I can pass to C functions. What's the best for this? Is it possible with Data.Vector.Unboxed?
21:02:23 <Maxdamantus> There isn't a construction that's limited to non-function values.
21:02:27 <arkeet> Data.Vector.Storable probably.
21:02:32 <Maxdamantus> There are constructions that are limited to types.
21:02:39 <arkeet> if you're using vector.
21:02:45 <Maxdamantus> definitions; you can't write `a :: IO`
21:02:55 <arkeet> vector only handles 1d arrays though.
21:03:08 <arkeet> so maybe you want to flatten it first or something.
21:03:17 <roboguy_> Maxdamantus: that's because values must have kind * (or kind #). Something that has a type like Int can't have a function as it's value either
21:03:36 <roboguy_> but that doesn't make functions values any less
21:03:36 <Maxdamantus> roboguy_: values don't have kinds.
21:03:42 <roboguy_> I didn't say they did
21:03:52 <nitrix> >> that's because values must have kind * (or kind #)
21:03:52 <arkeet> "values must have kind _"
21:03:55 <Maxdamantus> they have types, which are things of kind *.
21:04:03 <roboguy_> oh, I mean values must have types that have kind *
21:04:03 <nitrix> Maxdamantus is correct.
21:04:09 <roboguy_> that was a typo
21:04:19 <arkeet> * is the kind of types that have values.
21:04:20 <naevathecat> arkeet: I've been using vector so far for 2D you can do Vector (Vector a) but obviously this doesn't work with unboxed types
21:04:26 <roboguy_> arkeet: exactly
21:04:30 <Maxdamantus> they don't have to have values.
21:04:45 <Maxdamantus> (unless you consider bottom things to be values)
21:04:47 <HeladoDeBrownie> hmm, this discussion looks like material for #haskell-bikeshed
21:04:53 <roboguy_> Maxdamantus: that is true, but not really relevant to what I'm saying
21:05:04 <arkeet> naevathecat: it doesn't work with Storable either.
21:05:06 <Maxdamantus> they just have to be things you can define things as being.
21:05:10 * hackagebot reserve 0.1.1 - Reserve reloads web applications  http://hackage.haskell.org/package/reserve-0.1.1 (SimonHengel)
21:05:12 * hackagebot arion 0.1.0.8 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.8 (karun012)
21:05:26 <shachaf> id :: Void -> Void; id x = x
21:05:30 <shachaf> x is a value of type Void
21:05:46 <Maxdamantus> x is an expression that never evaluates to a value.
21:05:55 <srid> any irc bot in haskell that can be extended simply?
21:06:04 <srid> other than lambdabot which seems tied to #haskell
21:06:12 <Maxdamantus> it's never attempted to be evaluated.
21:06:33 <arkeet> > (id :: Void -> Void) (error "hi")
21:06:35 <lambdabot>  Not in scope: type constructor or class ‘Void’Not in scope: type constructor...
21:06:36 <Maxdamantus> evaluate is a pretty cool word.
21:06:39 <arkeet> mm.
21:06:41 <arkeet> @let import Data.Void
21:06:42 <Maxdamantus> it sounds like it has something to do with "value".
21:06:44 <lambdabot>  Defined.
21:06:44 <roboguy_> srid: I think lambdabot can run anywhere (that it can be compiled anyway)
21:06:46 <arkeet> > (id :: Void -> Void) (error "hi")
21:06:48 <lambdabot>  *Exception: hi
21:07:12 <naevathecat> arkeet: Well, what would you recommend. Basically I have a bunch of vectors containing information about graphs that I do things to in Haskell. At some point I need to solve isomorphism problems which only need AdjMatricies made from parts of these passed to C along with some ancillary info
21:07:41 <arkeet> naevathecat: ok, what does the C interface look like?
21:08:01 <naevathecat> arkeet: It's unwritten atm, this is a research project
21:08:07 <arkeet> ok, well I dunno.
21:08:52 <srid> roboguy_: and 'lambdabot 2' will include plugin mechanism: https://wiki.haskell.org/Lambdabot
21:08:57 <naevathecat> Pretend all I need to pass is 2D arrays made of ints or binary values. What would you use? (I can make these from the vectors)
21:10:15 <Maxdamantus> If I ever get around to implementing my language, I'll just make a new term for things with kinds.
21:10:41 <roboguy_> Maxdamantus: either way, types can have kinds though
21:10:51 <roboguy_> they *do* have kinds, in fact
21:11:08 <Maxdamantus> yes, *
21:12:39 <Maxdamantus> I think I'll call it a vand.
21:12:47 <roboguy_> Maxdamantus: another place you run into issues with that sort of distinction is when you consider something like * -> *. This is "something" (a thing with a non-* kind) that takes a type, right? What about (* -> *) -> *? Is it different because its argument is no longer a type?
21:13:45 <Maxdamantus> It's still a type constructor because you apply it and get a type.
21:14:04 <Maxdamantus> it's also a vand (my new term).
21:14:20 <roboguy_> yeah, but its argument is a different sort of thing. That feels inconsistent to me, but I guess it's a preference thing
21:14:23 <monochrom> sorry, what is "vand"? :)
21:14:35 <Maxdamantus> Something between a value and a kind.
21:14:55 <monochrom> ok, are Int and Maybe both examples of vands?
21:14:59 <Maxdamantus> Yes.
21:15:03 <monochrom> thanks :)
21:15:03 <Maxdamantus> as is IO.
21:15:09 <roboguy_> Int would be?
21:15:22 <Maxdamantus> a vand (particularly, a type)
21:15:28 <monochrom> yeah, I see how you may dislike calling the naked Maybe "a type"
21:15:46 <Maxdamantus> GHC seems to too.
21:16:17 <Maxdamantus> if someone can find a message in GHC that calls what I'm calling a "vand" a "type", feel free to point it out.
21:16:45 <roboguy_> Maxdamantus: the :help info for :kind says ":kind[!] <type>             show the kind of <type> (!: also print the normalised type)"
21:16:52 <monochrom> you will catch the Haskell 2010 Report (98 too) saying things like "the IO type", if that helps.
21:17:07 <monochrom> also, it spells "type class" not "typeclass" :)
21:17:08 <Maxdamantus> Yeah, that's just more stuff written by humans in informal contexts.
21:17:08 <shachaf> monochrom: It also calls getLine a function.
21:17:16 <monochrom> \∩/
21:17:36 <roboguy_> Maxdamantus: The Haskell standard that defines the language is informal?
21:17:56 <Maxdamantus> roboguy_: yes.
21:17:59 <arkeet> define formal.
21:18:02 <monochrom> OTOH, feel free to disagree with it. I am only pointing out that some people do it, not arguing that everyone must do it.
21:18:03 <Maxdamantus> roboguy_: it's an informal specification.
21:19:18 <Maxdamantus> I've heard they've tried specifying Haskell formally and failed.
21:19:38 <roboguy_> Maxdamantus: what is a formal specification?
21:19:38 <Maxdamantus> generally—I remember hearing they formally specified pattern matching or something.
21:19:57 <roboguy_> the Haskell report has BNF and denotational semantics, iirc, which is about as formal as it gets...
21:20:29 <thomasha`> can someone help me with an install problem? I'm getting a build error on https://github.com/haskoin/haskoin
21:20:38 <Maxdamantus> roboguy_: one that can be verified.
21:20:42 <thomasha`> I'm getting a build error on https://github.com/haskoin/haskoin
21:20:46 <Maxdamantus> roboguy_: through objective means.
21:20:48 <roboguy_> Maxdamantus: what does verified mean
21:20:50 <arkeet> thomasha`: show the error.
21:20:50 <thomasha`> http://pastebin.com/hHNBm315
21:20:57 <thomasha`> sorry, just pasted
21:20:57 <arkeet> (and how you tried to install it.)
21:21:25 <arkeet> well, do you understand the error message?
21:21:40 <roboguy_> doesn't something need to be verified against a certain set of semantics? Would that need to be verified as well, or how do you know when to stop and that it is formal enough?
21:21:54 <Maxdamantus> roboguy_: preferably, it would be written in mathematical notation.
21:22:04 <Maxdamantus> roboguy_: well, I'd prefer some textual representation.
21:22:23 <thomasha`> arkeet: not really
21:22:23 <Maxdamantus> roboguy_: basically, it should be written as a program, rather than as a text for humans.
21:22:37 <roboguy_> Maxdamantus: the ghc source code, then
21:22:39 <thomasha`> seems to be looking for a .so file, but the package doesn't include it
21:22:53 <arkeet> thomasha`: does that file exist anywhere on your system?
21:22:55 * Maxdamantus is looking for a nice concise image of the simply typed lambda calculus' type system on Wikipedia, but it seems to have disappeared.
21:22:58 <arkeet> libleveldb.so
21:23:00 <thomasha`> no, nowhere
21:23:01 <arkeet> the first error on line 5.
21:23:05 <arkeet> well, better install it then.
21:23:17 <Maxdamantus> roboguy_: potentially, yes, though GHC can have bugs.
21:23:19 <thomasha`> I apt-get installed libleveldb-dev already
21:23:33 <Maxdamantus> roboguy_: but a reference implementation of something can be a formal specification, yes.
21:23:36 <thomasha`> the package doesn't include .so files, just a .a file and some other files
21:23:58 <Maxdamantus> (the Haskell report could also have bugs)
21:24:01 <thomasha`> (libleveldb version 1.15)
21:24:04 <arkeet> what distribution?
21:24:08 <thomasha`> pangolin
21:24:30 <arkeet> well then.
21:24:34 <thomasha`> but I don't see why the distribution would matter, as opposed to the libleveldb version
21:24:40 <arkeet> http://packages.ubuntu.com/precise/amd64/libleveldb-dev/filelist
21:25:01 <arkeet> sure it would.
21:25:05 <arkeet> e.g. http://packages.ubuntu.com/trusty/amd64/libleveldb-dev/filelist has that file.
21:25:11 * hackagebot hoogle-index 0.4.1 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.4.1 (BenGamari)
21:26:10 <thomasha`> what generates the .so file? the package only comes with headers/source
21:26:42 <thomasha`> libleveldb.a is there, but not libleveldb.so 
21:26:44 <arkeet> .a is neither headers nor source, it contains a compiled library for static linking.
21:26:50 <arkeet> well
21:27:04 <arkeet> .so is for dynamic linking.
21:27:15 <arkeet> so whoever built that package didn't build a dyanmic library with it.
21:27:24 <roboguy_> Maxdamantus: type constructors/type functions and concrete types are represented in the ghc code in the same data type, so in that sense it would be reasonable, in my opinion, to say that they are both types
21:27:29 <thomasha`> do I need to generate the .so file beforehand, or supply some additional environment parameter or some such so cabal install knows what to do?
21:27:54 <Maxdamantus> roboguy_: does GHC have a name for the type representing them.
21:27:56 <Maxdamantus> s/.$/?/
21:28:01 <roboguy_> Maxdamantus: yeah, TyCon
21:28:01 <roboguy_> https://github.com/ghc/ghc/blob/0fcc454329c4e3e0dc4474412bff599d0e9bdfcd/compiler/types/TyCon.hs#L309
21:28:07 <Maxdamantus> Right.
21:28:10 <thomasha`> "whoever built that packgae" -- the ubuntu package, or the haskell one?
21:28:28 <Maxdamantus> which pretty much works with how I was using "type constructor".
21:28:29 <arkeet> thomasha`: the ubuntu package.
21:28:37 <arkeet> it's not exactly a haskell problem. :)
21:28:52 <Maxdamantus> 16:57:50 < Maxdamantus> Yes, so `Either` and `Either a` are both ultimately type constructors.
21:28:55 <Maxdamantus> 16:58:08 < Maxdamantus> because you eventually get a type after applying the right things the right number of times in the right order.
21:29:02 <thomasha`> so, should I generate the .so file myself, using gcc or some such?
21:29:04 <roboguy_> Maxdamantus: well, I agree with that part
21:29:31 <arkeet> you'd have to compile the library such that you get a .so
21:29:39 <arkeet> or find a package that already has it.
21:29:50 <thomasha`> ok, so download the source and configure/make sounds like
21:30:12 <roboguy_> Maxdamantus: although, even though I agree, isn't that based on pretty shaky grounds? I mean, TyCon was named by and for humans after all and has no intrinsic meaning in and of itself...
21:30:35 <Maxdamantus> Yes. I think it is still flimsy.
21:30:39 <Maxdamantus> which is why I want a new term.
21:31:10 <thomasha`> looks like trusty tar has the .so file, pangolin (where I am does not). thanks arkeet.
21:31:10 <arkeet> well
21:31:21 <thomasha`> I think I understand the problem and can solve from here
21:31:55 <roboguy_> Maxdamantus: but you will need a term that *does* have an appropriate, intrinsic meaning and not meaning assigned by and for humans and I'm curious about how that'll work
21:32:18 <Hijiri> use the language of the void beyond the stars
21:32:20 <roboguy_> haha, anyway. A bit inconsequential either way
21:33:06 <Maxdamantus> roboguy_: the names themselves don't have any formal significance, they just need to help humans understand the formal logic.
21:33:36 <Maxdamantus> roboguy_: and saying a "type" is a special case of a "type constructor" is confusing.
21:33:50 <Hijiri> a type isn't a special case of a type constructor
21:33:52 <Maxdamantus> and the opposite of what's currently used in the Haskell scene.
21:33:52 <roboguy_> Maxdamantus: that was my point
21:33:55 <Hijiri> you can have a type that isn't a type constructor
21:34:08 <roboguy_> I was saying we should call both of them types
21:34:41 <roboguy_> but type constructor is really just as good, probably
21:34:47 <Boreal> Is numerical integration referentially transparent assuming a constant step size?
21:35:25 <roboguy_> Boreal: any calculation can be implemented in a referentially transparent way
21:35:48 <Cale> Boreal: You mean, does it not matter which algorithm you use? You can get different results due to rounding error accumulating differently depending on the choice of algorithm.
21:36:01 <Maxdamantus> fwiw, Idris uses the term type accurately in the language (where Int : Type and Maybe : Type -> Type)
21:36:17 <Maxdamantus> Type : Type too.
21:36:20 <Cale> But for any given choice of algorithm, you can treat it as a referentially transparent function.
21:36:40 <Maxdamantus> and to make things more interesting, Monad : Type -> Type
21:36:54 <roboguy_> Maxdamantus: Type -> Type : Type in idris as well
21:36:55 <Boreal> So is it standard practice to handwave away floating-point error?
21:37:00 <Cale> and there might be multiple algorithms which produce *exactly* the same floating point result, but that's usually not exactly how you're interested in comparing them
21:37:10 <Maxdamantus> roboguy_: indeed.
21:37:16 <Cale> You usually are more interested in bounding the difference
21:37:41 <Cale> Boreal: I don't know what standard practice is, but it all depends on how careful you're being.
21:37:55 <Maxdamantus> roboguy_: but that's saying that `Type -> Type` is of type `Type`, not that `Type -> Type` is a type.
21:38:41 <roboguy_> Maxdamantus: that seems about as formal as it gets. It's saying that they are the same thing, which is what I was suggesting earlier
21:38:41 <Hijiri> what is the type of all types that do not contain themselves
21:38:42 <Maxdamantus> er, actuall, it is saying that.
21:38:54 <Hijiri> probably just runs the type checker as a heater
21:39:03 <Cale> Boreal: But there are formally different functions which we'd nonetheless like to refer to as numerical integrators.
21:39:07 <Hijiri> not sure if you could express such a type
21:39:15 <Maxdamantus> `Type -> Type` isn't a function; that's the important thing.
21:39:55 <scott> Hijiri: Idris checks behind the scenes that you don't introduce any kind of paradoxes having to do with Type
21:40:11 <roboguy_> Maxdamantus: it takes a type and maps it to a type, where each input type is given exactly one output type. That seems like a function
21:40:12 * hackagebot monad-logger-syslog 0.1.1.1 - syslog output for monad-logger  http://hackage.haskell.org/package/monad-logger-syslog-0.1.1.1 (MichaelSnoyman)
21:40:19 <Hijiri> scott: ah, ok
21:40:31 <Maxdamantus> roboguy_: it doesn't. You're thinking of things of type `Type -> Type`, not `Type -> Type` itself.
21:40:42 <Cale> Boreal: any one of them typically ought to be a pure function, though some might require some supply of random numbers as part of their input.
21:40:45 <Maxdamantus> roboguy_: `(Type -> Type) a` will never be a valid expression.
21:41:37 <Maxdamantus>         Type -> Type does not have a function type (Type)
21:41:41 <roboguy_> oh, I thought you meant it didn't represent a type containing functions
21:41:48 <roboguy_> that's true
21:42:33 <EvanR> you could say Type -> Type is a function type ... if you had dependent types
21:42:49 <Boreal> Cale: I'm not worried about that, I would say that Monte Carlo methods are outside the scope of my application.  I'm more interested in modelling game networking with the assumption that a referentially transparent function on multiple machines will produce a suitably consistent answer.
21:43:38 <EvanR> which i guess was already the topic
21:43:40 <Maxdamantus> EvanR: yes, but you can't apply function types.
21:43:53 <Cale> Boreal: Ah, okay, you might choose to care about the results of numerical integrations then, if this is for something like the ability to consistently replay what happened in a game.
21:43:54 <EvanR> you cant apply types
21:43:56 <Maxdamantus> you apply function values, some of which will have type `Type -> Type`
21:44:01 <Maxdamantus> Exactly!
21:44:07 <EvanR> function or not ;)
21:44:23 <Rotaerk> you can apply types to type arguments
21:44:33 <roboguy_> Maxdamantus: you can apply pi types
21:44:41 <Cale> Boreal: If you switch out that algorithm, and it affects, say, the manner in which a dude pathfinds his way around an obstacle, you can get yourself into trouble.
21:45:14 <scott> roboguy_: rather, you apply values of pi types, which are functions
21:45:23 <roboguy_> good point
21:45:48 <Cale> Boreal: So you might want to commit to one particular numerical integrator, so as to know that you'll always get the same result
21:47:53 <Maxdamantus> er, what I said about Monad before was wrong; Monad : (Type -> Type) -> Type
21:48:16 <arkeet> :k Monad
21:48:17 <lambdabot> (* -> *) -> Constraint
21:48:19 <Maxdamantus> in Haskell, you might just say the first thing is a type.
21:48:34 <Maxdamantus> (informal Haskell talk)
21:48:50 <Boreal> Cale: Yeah, I figure that what I'll do is keep game logic functions referentially transparent and have some kind of check to make sure all players in a given session have the same implementation.  Rendering or sound, or even something like particle physics can be marked with a monad that indicates it's unnecessary to synchronize across players since it's only a cosmetic difference.
21:49:46 <Boreal> I was just wondering if I could safely assume that the only significant errors would come from a) different integrators or b) different step sizes.  Even b) is probably not such a big deal if I use a "good" integrator like RK4.
21:50:12 * hackagebot wai-middleware-consul 0.1.0.1 - Wai Middleware for Consul  http://hackage.haskell.org/package/wai-middleware-consul-0.1.0.1 (MichaelSnoyman)
21:50:18 <Boreal> I don't want to betray the type system too much ;)
21:51:14 <zalami> Hey, I'm reading lyah
21:51:17 <zalami> http://learnyouahaskell.com/types-and-typeclasses
21:51:20 <zalami> removeNonUppercase :: [Char] -> [Char] 
21:51:23 <zalami> What does that line mean?
21:51:34 <zalami> Give it a type of list of Chars, ok
21:51:36 <zalami> whats the arrow?
21:51:45 <Boreal> It means "removeNonUppercase" is a function that takes a list of Chars and returns a list of Chars
21:52:03 <zalami> takes a list is on the left correct?
21:52:09 <Boreal> Yes
21:52:17 <Maxdamantus> zalami: `a -> b` is a function type, describing functions that take an `a` and yield a `b`.
21:52:34 <zalami> ok, thanks
21:52:35 <Boreal> In mathematics, -> means "maps to".  Functions are really just mappings.
21:53:09 <EvanR> are functions and mappings more or less obvious as an idea than each other? ;)
21:54:35 <monochrom> some people find both obvious. some other people find both non-obvious. statistics about this can be obtained from highschool marks over the past 100 years.
22:01:54 <Orgamic> plop lamers
22:02:55 --- mode: ChanServ set +o monochrom
22:03:00 --- mode: monochrom set +b *!*@APuteaux-655-1-88-179.w92-151.abo.wanadoo.fr
22:03:01 --- kick: Orgamic was kicked by monochrom (Orgamic)
22:12:06 <L8D> what are some incredibly obscure but fleshed out data types in Haskell?
22:12:19 <L8D> I'm writing a satire article, and need a bunch of random types as examples
22:13:26 <EvanR> anything from any oleg paper
22:13:51 <L8D> link?
22:13:57 <monochrom> for example, "iteratee"
22:14:26 <L8D> hm...
22:15:08 <L8D> any more?
22:15:10 <qz> lenses? :)
22:15:37 <L8D> hm...
22:15:40 <EvanR> zippers
22:15:55 <pharaun> Zippers are a good one
22:16:02 <pharaun> *is ?
22:16:34 <L8D> cool
22:16:46 <EvanR> free monad
22:17:34 <L8D> Is that a type constructor?
22:17:38 <L8D> :t Free
22:17:40 <lambdabot> Not in scope: data constructor ‘Free’
22:17:42 <L8D> :/
22:18:07 <L8D> so far: Iteratee, Optical, Iso, Zipper, These and FTP
22:18:17 <L8D> FTP meaning file transfer protocol
22:18:20 <L8D> I guess those are enoguh
22:18:32 <EvanR> data Free f a = Pure a | Free (f (Free f a))
22:18:42 <L8D> for context, I'm writing a satire Haskell version of: https://blog.engineyard.com/2015/seven-unusual-ruby-datastores
22:18:45 <srid> what is a good resource deeply understand monands, applicative functors and such?
22:18:56 <srid> no-BS direct explanations
22:19:24 <L8D> :i Monad
22:19:29 <L8D> :info Monad
22:19:31 <L8D> :(
22:19:36 <L8D> srid: look at the types
22:19:49 <L8D> http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#t:Monad
22:20:12 <srid> too direct! :)
22:20:37 <L8D> something from here http://github.com/bitemyapp/learnhaskell
22:21:00 <pacak> L8D: Something like Cojoined from lens?
22:21:17 <catsup> srid: this may not be what you want, but... https://wiki.haskell.org/Typeclassopedia
22:21:22 <L8D> pacak: Cojoined is better than Optical
22:21:49 <caconym> srid: oh hey you're back :)
22:22:12 <srid> catsup: hmm, that link is what this guy recommends as well: http://dev.stephendiehl.com/hask/#monads
22:22:15 <catsup> srid: i mean, that might be a little bit too direct as well
22:22:45 <pacak> L8D: Type signature for Optical is relatively simple.
22:23:06 <caconym> srid: I found Learn You a Haskell to have some nice basic explanations of functors and applicatives
22:23:30 <srid> caconym: yea, but it feels a bit slow and less rigorous though.
22:23:45 <EvanR> @where cis194
22:23:46 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
22:23:55 <L8D> pacak: I'm looking for obscurity
22:24:03 <srid> i guess i should read just Typeclassopedia and start hacking
22:24:14 <pharaun> L8D: that seems specific
22:24:20 <caconym> srid: yeah that's really the only way to truly grasp this stuff
22:25:11 <L8D> pharaun: I'm writing a parody article
22:25:14 * hackagebot dbus 0.10.10 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.10 (JohnMillikin)
22:25:16 <caconym> srid: but you also have to know what tools are available to you; i found (and still find) that to be harder with Haskell than some other languages
22:25:30 <srid> caconym: what do you mean? tools like what?
22:25:49 <caconym> srid: well, you might have run across Functors
22:25:53 <srid> yes
22:25:56 <srid> for fmap
22:26:08 <caconym> srid: and you might use them happily for a bunch of stuff
22:26:22 <EvanR> L8D: same advice as spring break, dont do anything youre going to regret later
22:26:32 <EvanR> when its on the internet ;)
22:26:46 <caconym> srid: but if I didn't tell you about Bifunctors, you probably wouldn't find out about them organically for quite a while
22:27:06 <srid> caconym: ok. so you mean concepts rather than tools.
22:27:07 <caconym> srid: just as an example of a somewhat obscure but potentially useful construct
22:27:18 <EvanR> concepts are tools
22:27:27 <srid> that's something i like about Haskell. more concepts, and concepts built on top of others
22:27:50 <srid> by 'tool' i was thinking of stuff like compilers, formatters, interpreters, make, etc.
22:28:17 <srid> i guess 'abstraction' would be a fitting word here?
22:28:38 <srid> ah. 'bifunctor' is a package; https://hackage.haskell.org/package/bifunctors
22:29:08 <srid> caconym: ok, i see what you mean. you were referring to packages that provide helpful constructs.
22:29:32 <caconym> srid: sure, but you could also trivially implement Bifunctor yourself if you felt like it
22:29:44 <caconym> srid: you just have to be aware that such a thing is possible, and useful
22:29:58 <srid> right. 
22:30:07 <srid> i'm learning Haskell at such a late age.
22:30:08 <caconym> srid: that's what reading a lot of Haskell-related literature will get you
22:30:22 <srid> spent most time with Python and, lately, Go.
22:30:37 <srid> Go was gateway drug to other static typed languages.
22:30:48 <srid> until Go i never appreciated static typing
22:31:05 <srid> C++, Java and Python messed me up.
22:31:16 <caconym> srid: ah yes, then you must already be starting to understand how awesome Haskell's type system is :)
22:31:24 <srid> and the fact that most Scheme, Lisp and Clojure are not statically typed didn't help
22:31:25 <EvanR> what go is static?
22:31:34 <Javran> is partial type family application possible? http://lpaste.net/6993694779372470272 just messing around with type family, so the code might not make sense at all
22:31:40 <caconym> EvanR: yeah it's a little bit C-ish, actually
22:31:48 <EvanR> i thought it was more like javascript
22:32:04 <srid> Go is statically typed like C, but also with some primitive form of type inference
22:32:31 <Maxdamantus> yay dynamic typing: https://gist.github.com/Maxdamantus/9184ff4b72017a8de0cc
22:32:48 <EvanR> statically typed like C, i only think of void* and casting to stop annoying warnings about using uint8 as uint32 ;)
22:33:02 <EvanR> i.e. not very
22:33:05 <scott> EvanR: Go is a lot like that. interface{} is the new void*
22:33:37 <EvanR> :(
22:33:45 <srid> haskell shines when it comes to nil.
22:33:56 <caconym> srid: I think the process of "discovering" concepts like functors and monads is longer and more difficult in Haskell, simply because the ecosystem of such generally useful things in Haskell is much richer than what I've seen in most other languages
22:34:01 <srid> with Go; you do a lot of `if err == nil { panic("oopsie"} )`
22:34:07 <srid> err != nil.
22:34:41 <srid> caconym: ya, i can already see that. just when i came to the monad chapter, my mind decided to take a break ... and here I am. :)
22:34:46 <EvanR> yeah nil is a stupid feature
22:34:57 <caconym> srid: ha yeah, it's a hard road, but worth it
22:35:34 <EvanR> haskell doesnt have nil, instead has _|_ ;)
22:35:46 <EvanR> harder to design away
22:35:47 <srid> I may not have considered learning Haskell if it not for being unemployed and living off savings.
22:37:19 <EvanR> learning haskell is a lengthy sequence of "head explode"s
22:37:31 <caconym> srid: well if you were looking for an intellectually stimulating exercise with no end of complicated stuff to wrap your head around, you found it
22:37:39 <Maxdamantus> > head []
22:37:41 <lambdabot>  *Exception: Prelude.head: empty list
22:38:14 <EvanR> possibly infinite sequence
22:38:34 <pacak> > head [1..]
22:38:35 <lambdabot>  1
22:38:39 <pacak> > last [1..]
22:38:43 <lambdabot>  mueval-core: Time limit exceeded
22:38:59 <caconym> srid: also it's truly humbling how incredibly smart Haskell people are
22:39:00 <j201> maybeHead explode
22:39:48 <srid> i should go to a haskell conference
22:39:52 <srid> just to bask in the vibes
22:39:56 <L8D> > let explode = explode in head explode
22:39:57 <caconym> srid: I thought I was pretty clever until I got a look at what the Haskell community gets up to on a regular basis
22:39:59 <lambdabot>  mueval-core: Time limit exceeded
22:40:10 <srid> caconym: agree with that sentiment.
22:40:15 * hackagebot elevator 0.2.3 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.2.3 (FumiakiKinoshita)
22:41:05 <srid> ah, damn it, in 2008 they had a conference in the city I live! https://www.haskell.org/haskell-symposium/2008/
22:41:28 <Javran> > let explode = explode in fix (head explode)
22:41:32 <lambdabot>  mueval-core: Time limit exceeded
22:41:58 <Javran> and fixing it takes longer than expected
22:42:02 <EvanR> the 2008 haskell logo, gross ;)
22:42:42 <caconym> http://www.willamette.edu/~fruehr/logos/PNGs/BlueHaskellLogo.png
22:47:28 --- mode: monochrom set -o monochrom
22:55:30 <mjrosenb> when I have a literal, "\223" in haskell, is that treated as decimal, or hex?
22:56:28 <shachaf> > ord '\223'
22:56:29 <lambdabot>  223
22:56:39 <shachaf> It is treated as decimal.
22:56:58 <platz> One day I will understand when I need MonadBaseControl.  that day has not come yet.
22:56:59 <EvanR> L8D: https://wiki.haskell.org/Blow_your_mind
22:57:55 <mjrosenb> aand when used in a string, that means that unicode codepoint, however it may be encoded?
22:58:16 <EvanR> for String, its not encoded
22:58:28 <EvanR> String is list of Char, and Char is unicode
22:58:40 <EvanR> maxBound :: Char
22:58:45 <EvanR> > maxBound :: Char
22:58:46 <lambdabot>  '\1114111'
22:59:15 <shachaf> Strin is [Char]. No encoding, other than however [Char] is represented in memory.
22:59:22 <shachaf> String
22:59:31 <shachaf> But Char is a Unicode code point (almost).
22:59:51 <EvanR> almost because utf16 surrogates?
23:00:33 <mjrosenb> > "ß"
23:00:34 <lambdabot>  "\223"
23:00:46 <mjrosenb> coool.
23:02:05 * mjrosenb guesses getting show to escape everything *except* non-ascii unicode characters would be futile
23:02:43 <shachaf> Sounds like a job for something other than show.
23:05:11 <jle`> sometimes i forget that `Rational` is a type synonym
23:05:14 <mjrosenb> yup
23:06:19 <Javran> what does something like "a ~ b" mean in a type signature?
23:07:01 <shachaf> a is the same type as b
23:07:37 <Javran> shachaf: is there a document about this?
23:07:49 <shachaf> Probably.
23:08:07 <shachaf> It's called an equality constraint.
23:08:16 <shachaf> @google ghc equality constraints
23:08:17 <lambdabot> https://www.haskell.org/platform/doc/2014.2.0.0/ghc/users_guide/equality-constraints.html
23:08:36 <Javran> shachaf: thanks!
23:08:52 <glguy> shanks
23:09:31 <shachaf> Hoogle can often answer these questions.
23:09:43 <shachaf> For instance searching for ~ on Hoogle would link you to https://wiki.haskell.org/Keywords#.7E
23:10:01 <shachaf> glguyw
23:11:35 <AshyIsMe> EvanR: nice!
23:11:39 <AshyIsMe> i hadnt seen that page
23:11:45 <Javran> https://wiki.haskell.org/GHC/Type_families for the injectivity issue mentioned in 7.2, I'm thinking about putting some constraints like ((F a ~ F b) => a ~ b) would do, not sure if this is possible 
23:15:06 <Javran> can I simply understand it as data family enforces RHS to be unique and therefore guarantees injectivity?
23:17:20 <shachaf> There's also talk about adding injective type synonym families.
23:18:18 <EvanR> nice the wikipage for point free lists ((.)$(.)) as a combinator found using @pl. i guess $ is needed to avoid a not safe for work but equivalent version
23:19:42 <Javran> :t ((.) (.)) -- I think this is equivalent?
23:19:43 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
23:19:57 <EvanR> yeah
23:20:08 <mjrosenb> I mean, clearly, that one is just a stripper that has been paid.
23:20:11 <KaneTW> :t (.)$(.)
23:20:12 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
23:20:15 <EvanR> :t (.)(.)
23:20:16 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
23:20:18 <EvanR> mjrosenb: lol
23:20:40 <Javran> lol
23:20:59 <EvanR> i havent seen any occasion to use either. (.).(.) is more common
23:22:36 <Javran> I feel Data.Function.on and (.:) just make functions like (a -> a -> b) profunctors
23:23:30 <shachaf> How do you mean?
23:24:01 <Javran> :t (on)
23:24:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:24:10 <Javran> :t (.).(.)
23:24:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
23:24:52 <Javran> (.:) as fmap and "on" as flipped contramap
23:25:54 <EvanR> a -> a -> b, vs a -> b -> c
23:26:08 <EvanR> two types three typs
23:26:21 <Javran> need some more constraints
23:27:17 <Javran> (.:) has a more general type signature
23:28:43 <shachaf> Do you mean (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b) or something else?
23:35:15 <Javran> http://lpaste.net/129955 I meant this
23:37:00 <shachaf> OK, sure.
23:39:13 <Javran> I find "data instance F Int = Int | Bool" causes no problem, but then what "F Int" would become?
23:40:37 <shachaf> F Int is a type
23:40:45 <shachaf> It has two constructors named Int and Bool.
23:40:57 <shachaf> data instance F Int = A | B is equivalent.
23:41:21 <Javran> I see, it looks a little confusing
23:41:22 <mauke> ~ Bool
23:41:27 <shachaf> Using data families is similar to using type families and wrapping with a newtype.
23:42:03 <shachaf> type family F a; newtype G a = G (F a); type instance F Int = Bool -- for instance
23:46:24 <Javran> what's "G" doing here?
23:47:40 <Javran> is it similar to "data instance F Int = G (F Int)" or something
23:48:26 <shachaf> It's making it injective.
23:48:37 <shachaf> You might have F Int = Bool; F Char = Bool
23:48:56 <shachaf> So F Int is equal to F Char. But G Int isn't equal to G Char.
23:50:08 <Javran> seems like there are many ways to ensure injectivity
23:51:19 <Javran> need some thinking to make sense of these, but thanks for the help!
