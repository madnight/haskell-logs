00:02:20 <dmwit> augur: An orphan instance is one that is not in the same module as either the type or the class.
00:02:56 <augur> dmwit: ah i see
00:03:15 <dmwit> (I'm not sure how this interacts with MPTCs.)
00:03:36 <dmwit> They're considered bad style because it's too easy to create conflicting instances.
00:04:57 <dmwit> ?. ?pl ?undo \x -> do { a <- fa x; b <- fb x; return $ f a b }
00:04:57 <lambdabot> Plugin `compose' failed with: Unknown command: "?pl"
00:05:10 <dmwit> ?. pl undo \x -> do { a <- fa x; b <- fb x; return $ f a b }
00:05:10 <lambdabot> liftM2 (>>=) fa (flip (fmap . f) . fb)
00:05:18 <dmwit> aw yeah, that's the stuff
00:08:59 <akfp> I'm looking for a concept similar to semigroup for "optimization".  The rule is that the result only "improves" with extra data.  So while adding data might change the result, it can never become "worse".  So  while (+, N) is a semigroup,  (+, N, >=) would be an "optimization group" because if I get extra elements, they result would always be >= what I had.
00:10:58 <dmwit> Not sure if there is a name for that. "monotonic" is similar but not quite the same.
00:11:30 <dmwit> Nothing stopping you from inventing a name for it, though.
00:12:18 <shachaf> A semilattice might be relevant, depending on which properties you're looking for.
00:14:41 <dmwit> What are you hoping to get out of the concept?
00:21:05 <akfp> I want to be able to say that if X is a <concept>, then it can deal with lost messages.
00:22:05 <akfp> or to say that if X is <concept>, then adding data only improves things.
00:22:51 <akfp> or, to say that if I have a result calculated over a set of messages, and another result calculated over a larger set of messages, I can replace the first result with the second result.
00:34:12 <akfp> thanks!  googling monotonic semigroup doesn't give me much though.  it doesn't seem like an established term.
00:35:33 <shachaf> akfp: How are + and >= related?
00:37:20 <akfp> shachaf:  I think it would be something like (x + y + z) >= (x + y)
00:38:11 <shachaf> Can that just be x + y >= x?
00:38:29 <akfp> shachaf: yes
00:42:39 <rola> akfp, are you looking for something like https://en.wikipedia.org/wiki/Ordered_semigroup
00:45:42 <akfp> rola: it is not the same it seems.  (+, Z) is mentioned as an ordered semigroup, but x + y >= x does not hold for Z.
00:46:04 <breadmonster_> dmwit: I figured out how to do it!
00:47:13 <breadmonster_> dmwit: I can use the Writer monad to keep track of indentation at each line.
00:50:10 <hunteriam> I've got some gl code here thats just rendering totally wrong
00:50:19 <hunteriam> right now its drawing a line from 0,0 to .5,.5
00:50:29 <hunteriam> if anyones got a sec help would be greatly appreciated
00:50:50 <hunteriam> heres the code http://lpaste.net/128058
00:50:57 <hunteriam> is there anyone here at this hour anyways?
00:51:21 <hunteriam> i hard coded a few things for debugging
00:51:40 <hunteriam> please ping me if you respond
00:52:02 <rola> gl looks spooky
00:52:17 <rola> i've have to try it out someday
00:55:47 <hunteriam> rola: yea
00:55:50 <hunteriam> accurate
01:08:11 <dgorbik_> What's the main difference between conduit and pipe packages?
01:13:21 <quchen2> dgorbik_: The authors explain that very well in the Haskell Cast (With Gabriel Gonzalez and Michael Snoyman). They're quite similar at their cores. Pipes offers bidirectional communication, Conduit has built-in leftover handling and finalization handlers.
01:13:54 <dgorbik_> quchen2: thanks, I will check that out
01:14:46 <dgorbik_> quchen2: but in general it
01:14:52 <dgorbik_> it's just a matter of preference?
01:15:42 <quchen2> If you don't need any of the differences then you can choose either. It might also be a matter of what ecosystem you want to dive into.
01:15:58 <quchen2> I personally prefer pipes because it's prettier if I have no other constraints.
01:17:40 <dgorbik_> quchen2: is it somewhat true that pipes is more mathematical in a sense that it tries to formalize concepts using category theory?
01:18:41 <quchen2> Not really, no. Gabriel uses a very practical approach to category theory, it's not formalized in any way.
01:19:21 <quchen2> You can view a category in Haskell as something "that has a combination function with identity elements", which is a helpful abstraction with or without the math.
01:19:50 <quchen2> In Pipes, certain basic functions satisfy the category laws, allowing for easier reasoning about your code.
01:20:46 <quchen2> For example,  pipe >-> cat = pipe  is a "category law", but it also stands for the intuitive "reading from a pipe via the Unix cat program changes nothing".
01:21:54 <dgorbik_> quchen2: yeah, I guess since pipes form a category anyway, it doesn't matter what the implementation is
01:24:10 <jle`> i think it might be safe to say that because objects in pipes have relationships that follow category laws, etc, they are more open to easy and intuitive refactoring based on intuition you have already gained from working with the same objects elsewhere
01:25:04 <jle`> you can refactor conduit programs too, but because conduit programs don't obey maths laws the same way that pipes does, you get a lot less intuition "for free" just from past experience.
01:25:48 <jle`> s/same objects/same mathematical structures
01:25:58 <hunteriam> hey could anyone help me with my OpenGL code
01:25:58 <hunteriam> http://lpaste.net/128059
01:26:04 <hunteriam> its drawing funky shapes
01:26:19 <hunteriam> using the square formula it drew a straight line from 0 0 to 1 1
01:27:13 <quchen2> A category by itself is a very simple concept with very useful laws in practice, and you get a lot of mileage from recognizing something that obeys these laws.
01:27:27 <quchen2> It's a little like simplifying formulas with numbers and lots of zeros and ones.
01:28:11 <quchen2> dgorbik_: pipes form multiple categories even! :-D
01:28:28 <quchen2> The Pipes.Tutorial module introduces some of them.
01:29:49 <dgorbik_> quchen2: reading it now, exciting stuf
01:29:51 <dgorbik_> stuff
01:33:02 <hunteriam> how do i get the byte size of a data type in haskell
01:34:46 <shachaf> What is the byte size of a data type?
01:36:02 <Cale> hunteriam: Assuming you're talking about FFI, the Storable type class provides  sizeOf :: (Storable a) => a -> Int
01:36:05 <alpounet> hunteriam: programmatically? for the types that support it: https://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-Storable.html -- however, you can reason about the memory requirements of your data types using knowledge from http://blog.johantibell.com/2011/06/computing-size-of-hashmap.html or similar other documents
01:38:56 <hunteriam> i tried using sizeof the way it was used in a c example
01:39:04 <hunteriam> sizeof float*
01:39:10 <hunteriam> but it gave me 8
01:39:17 * hackagebot highlighter2 0.2.5 - source code highlighting  http://hackage.haskell.org/package/highlighter2-0.2.5 (chemist)
01:39:22 <hunteriam> the real answer was 24
01:39:27 <hunteriam> as it was an array with 6 floats
01:39:29 <Cale> hm?
01:39:37 <hunteriam> i had this 
01:39:44 <erikd> hunteriam: "float*" in C is a pointer to float
01:39:48 <hunteriam> verts <- newArray [1,2,3,4,5,6]
01:39:53 <hunteriam> sizeOf verts == 8
01:40:03 <hunteriam> whereas the correct number is 24
01:40:17 <hunteriam> am i misusing sizeof?
01:40:28 <Cale> What's the type of verts?
01:42:16 <Cale> It seems weird that sizeOf verts would even typecheck there
01:42:24 <hunteriam> Cale: Ptr GLfloat
01:42:30 <Cale> Oh, well, then it's a pointer
01:42:48 <Cale> and you're apparently on a 64 bit architecture, so a pointer is 8 bytes indeed
01:42:52 <erikd> and hunteriam is on a 64 bit machine where pointers are 64 bit (8 bytes)
01:43:21 <hunteriam> how do you think i could cleanly get the size of the entire array?
01:44:26 <erikd> hunteriam: i don;t believe its possible. its a pointer, in contains no information about the length of what its pointing to.
01:44:47 <erikd> you would have exactly the same problem in C
01:45:32 <Cale> You could use withArrayLen instead of newArray
01:45:34 <hunteriam> yea which is why it baffled me to see this in the official OpenGL tutorial
01:46:02 <hunteriam> glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
01:46:20 <hunteriam> if you run sizeof on an array that wasn't inited as a pointer does it somehow work in c??
01:46:23 <Cale> hunteriam: Is vertices an array on the stack?
01:46:27 <hunteriam> yea
01:46:30 <hunteriam> is that why it works?
01:46:33 <Cale> yes
01:46:42 <Cale> If it had been allocated with malloc, that wouldn't work
01:46:51 <hunteriam> ok so i guess i need to get the sizeof float and then * by the length of the list?
01:46:51 <frerich> erikd: Actually arrays and pointers are different things in C (and if you have a particular array type you can get the size in bytes using something like 'sizeof(arr) / sizeof(*arr)'. It just happens that arrays decay to pointers very quickly (e.g. when passing to/returning from functions).
01:47:02 <frerich> s/size in bytes/size in elements/
01:47:05 <Cale> hunteriam: You could, but it would be better just to use withArrayLen
01:47:11 <Cale> withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
01:47:34 <hunteriam> kind of awkward to use that with the really long gl call
01:47:46 <yac> there's this famous programmer's blog where he explains memory, pointers, c strings, pascal strings and their big O
01:47:47 <hunteriam> oh but that makes my job very easy
01:47:51 <Cale> Well, this makes sure you deallocate
01:47:53 <yac> I can't remember his name
01:48:05 <erikd> frerich: i am aware of difference, but the use of newArray provides a pointer, not an array
01:48:09 <hunteriam> Cale: what package/module is that in?
01:48:24 <Cale> Foreign.Marshal.Array
01:48:28 <Cale> (same as newArray)
01:48:30 <hunteriam> ah! already imported!
01:49:12 <hunteriam> Cale: that is going to provide the byte length, right? not just the element length?
01:49:24 <Cale> The Int is the number of values
01:49:35 <Cale> It should always be the same as the length of the list you gave
01:49:54 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/src/Foreign-Marshal-Array.html#withArrayLen
01:49:59 <Cale> you can see how it works there
01:50:38 <Cale> It just saves you from recomputing the length of the list because that needs to be computed anyway
01:52:27 <Cale> hunteriam: So, you're implementing an FFI binding to OpenGL?
01:52:49 <hunteriam> Cale: yea I'm using the gl package
01:53:01 <hunteriam> Cale: should i just sizeof $ head list
01:53:07 <hunteriam> to get the byte size
01:53:15 <hunteriam> is there a nicer way?
01:53:29 <hunteriam> Cale: i was suggested the gl package, I'm totally open to higher end stuff
01:53:36 <hunteriam> higher level sorry
01:54:21 <yac> ha, it's Joel Spolsky, it's just that ddg failed me
01:54:49 <yac> hunteriam: you might find http://www.joelonsoftware.com/articles/fog0000000319.html interesting
01:54:50 <Cale> hunteriam: Yeah, I think this library is designed for people who want to build the higher level libraries, not really for direct use.
01:56:00 <hunteriam> Cale: frustrating to have spent so much time on it already
01:56:06 <hunteriam> Cale: although i do like the freedom you get
01:56:16 <hunteriam> Cale: some things i just don't care to be doing though, honestly
01:58:54 <hunteriam> thanks yac 
01:58:55 <Cale> You might try http://hackage.haskell.org/package/OpenGL
02:00:35 <arkeet> I don't like OpenGL 
02:00:49 <arkeet> I find the StateVar stuff annoying.
02:01:02 <arkeet> gl is perfectly fine for normal use
02:01:17 <yoshuawuyts> arkeet: what is StateVar?
02:01:18 <shachaf> Oh, you meant the Haskell library.
02:01:22 <arkeet> yeah.
02:01:27 <EvanR> Cale: gl /is/ the ffi binding to opengl
02:01:40 <arkeet> yoshuawuyts: it's the annoying stuff the OpenGL package makes you deal with.
02:01:56 <EvanR> Cale: ^ see complaints about OpenGL the package
02:02:00 <Cale> EvanR: Yeah, but it's a direct low level binding which doesn't look very usable, since it has you working directly with Ptr () values and such
02:02:14 <yoshuawuyts> ah right :(
02:02:29 <EvanR> Cale: well you might say the same about the C library
02:02:38 <EvanR> except people dont think of it like that either
02:02:40 <Cale> ... sure
02:03:00 <Cale> We usually hold ourselves to slightly better standards than the average C library
02:03:32 <EvanR> basically its the same as its always been (since opengl 3), you use opengl directly or you use a game engine
02:03:45 <EvanR> you cant really expect opengl to be high level and directly usable
02:03:57 <hunteriam> until now
02:03:59 <hunteriam> with vulcan
02:04:02 <hunteriam> hopefully
02:04:18 <EvanR> hunteriam: speaking of which theres a few engines like this in haskell
02:04:26 <hunteriam> like what?
02:04:37 <Cale> I'm not sure I buy the argument that just because the C library sucks, all Haskell bindings to it have to suck in the same way
02:04:46 <arkeet> the C library is fine for C.
02:04:51 <arkeet> API*
02:05:13 <Cale> Well, I'd say OpenGL's API is pretty terrible, even for C.
02:05:16 <EvanR> when the question is "how do i use opengl" the answer doesnt really depend on language
02:05:19 <Cale> But that's a different discussion :P
02:05:23 <EvanR> well yeah
02:05:31 <hunteriam> I'm going to draw the line at writing shaders
02:05:33 <EvanR> OpenGL made it even worse though
02:05:39 <hunteriam> but its still been a pleasant and valuable learning experience
02:05:57 <EvanR> but shaders are where it became actually usable :(
02:06:02 <hunteriam> oh really?
02:06:06 <hunteriam> shaders have always terrified me
02:06:12 <hunteriam> i thought it never became usable
02:06:19 <EvanR> are you following the tutorial at open.gl
02:06:24 <hunteriam> yea i am
02:06:26 <int-e> hunteriam: you will hate Vulcan then.
02:06:34 <hunteriam> int-e: well I've never tried them
02:06:38 <hunteriam> int-e: i just assumed they were nasty
02:06:43 <arkeet> it's impossible to avoid shaders in modern opengl.
02:06:47 <arkeet> they're not that bad.
02:06:49 <hunteriam> int-e: if they're good and loved then I'm open to them
02:07:11 <hunteriam> i wish i had more time...
02:07:17 <int-e> (well, there's no spec yet, but from what I've read they stripped out every high-level feature that OpenGL has, keeping the various buffer objects and the shader)
02:07:19 <EvanR> Cale: how do i use opengl at a high level doesnt seem to be a well formed problem
02:07:20 <int-e> *s
02:07:33 <hunteriam> int-e: i thought it was supposed to be much more usable though?
02:07:37 <hunteriam> int-e: more functional
02:07:39 <EvanR> you can use something at a high level and its not opengl, or you can use opengl, and its not high level
02:07:58 <arkeet> vulkan pushes a lot more work onto the developer.
02:08:03 <int-e> Which is a good move for the purpose, but it's not going to be any higher level; more the contrary.
02:08:06 <hunteriam> arkeet: why is it the future then?
02:08:07 <arkeet> you have to do memory management yourself.
02:08:13 <arkeet> hunteriam: because it's lower overhead.
02:08:17 <hunteriam> arkeet: ah
02:08:26 <arkeet> so you can extract some more performance out of it.
02:08:28 <hunteriam> arkeet: but also still more usable
02:08:36 <arkeet> building command buffers in parallel and whatnot.
02:08:38 <int-e> It might spur the development of higher level APIs, but Vulkan itself will not fill that niche.
02:08:41 <EvanR> hunteriam: the trend in graphics programming has been the opposite motion as in haskell, less and less abstraction for more and more performance, making it basically harder
02:08:44 <hunteriam> arkeet: I've heard they're going to copy some dx functional style calls
02:08:52 <arkeet> I don't know what that means.
02:09:01 <hunteriam> arkeet: idk really either
02:09:06 <EvanR> opposite in the sense that haskell is more and more abstraction with also more performance ;)
02:09:07 <arkeet> DX12 is doing the same thing btw.
02:09:13 <arkeet> (although that's tied to windows obviously.)
02:09:20 <hunteriam> arkeet: i just heard something good about vulcan and being more function oriented and less state machine
02:09:26 <Cale> EvanR: Well, okay. I'll put it this way: There ought to be a Haskell library for controlling 3D graphics hardware in the same generality that the gl library does, but which isn't complete crap.
02:09:36 <arkeet> hunteriam: yes, it doesn't keep track of as much state.
02:09:44 <arkeet> what that means is *you* have to do that instead.
02:09:47 <EvanR> Cale: that would awesome
02:09:56 <hunteriam> arkeet: those bastards
02:09:59 <hunteriam> arkeet: they lied to me
02:10:04 <hunteriam> arkeet: baited me
02:10:16 <hunteriam> this thing isn't easier at all
02:10:20 <EvanR> but the full generality of opengl is huge
02:10:23 <arkeet> I never said it was.
02:10:26 <Cale> EvanR: *Probably* such a library would use FFI to OpenGL, but if you have some other general way to do it, I don't care.
02:10:30 <hunteriam> you're not the bastard arkeet 
02:10:32 <EvanR> you probably dont want it all
02:11:13 <hunteriam> you could use OpenGL to do normal calculations probably, right?
02:11:29 <arkeet> what do you mean by that
02:11:32 <EvanR> im working on a library that uses `gl' and exports something digestible, in the scope of something like webgl or ES2
02:11:33 <rdema> hunteriam: Compute shaders?
02:11:42 <arkeet> compute shaders are a thing
02:11:50 <hunteriam> i think thats what i mean
02:12:22 <hunteriam> I've always wanted to program a graphical style thats water colory
02:12:29 <hunteriam> but i have no idea how massive a challenge that is
02:12:32 <int-e> I wish there was an actual publicly visible specification for Vulcan, rather than just a marketing campaign.
02:12:36 <hunteriam> i assume its pretty hard though
02:12:38 <int-e> *Vulkan.
02:13:02 <hunteriam> int-e: as a valve fan, i both agree and love the hype anyways
02:13:10 <hunteriam> I'm really pumped to see the source 2 graphics
02:13:21 <EvanR> hunteriam: you should really go through the tutorial to the end and make notes of how it all fits together before you dismiss the whole endeavor, its hard to know how much is necessary and how much is "omg performance maybe" effort
02:13:43 <hunteriam> you guys are so useful
02:13:49 <hunteriam> i got to go to bed
02:13:50 <EvanR> and how much the necessary part is actually hard
02:14:00 <hunteriam> yea i will
02:14:07 <hunteriam> I'm way too tired to process anything else now though
02:14:13 <arkeet> I like the modern opengl way.
02:14:18 <arkeet> to draw stuff it's basically
02:14:27 <arkeet> send the gpu some data
02:14:28 <EvanR> glDrawArrays ;)
02:14:42 <arkeet> the vertex shader knows how to interpret that data
02:14:54 <arkeet> and rasterize it
02:15:01 <arkeet> and fragment shader colours the pixels.
02:15:07 <hunteriam> wow you got me kind of interested in shaders
02:15:16 <EvanR> raster it * onto a texture that you use in another pass
02:15:16 <hunteriam> is there a haskell way of writing shaders
02:15:30 <arkeet> I never said the pixels were on screen.
02:15:30 <EvanR> there are some projects for shader DSLs
02:15:49 <arkeet> if you use a plain opengl library you'll have to write the shaders in glsl like everyone else.
02:16:03 <hunteriam> what do people think of glsl
02:16:16 <arkeet> well, it's your only option. :p
02:16:19 <arkeet> for opengl
02:16:28 <hunteriam> also does the program compile the shaders at start up, or do you write a program to compile your shaders alongside your main program?
02:16:29 <arkeet> I think it's reasonable.
02:16:45 <arkeet> you privode opengl your shader source
02:16:50 <arkeet> and the driver compiles it
02:16:55 <arkeet> at runtime
02:17:07 <EvanR> theres a way to precompile shaders but just dont bother thats "omg performance"
02:17:17 <EvanR> save yourself the headache
02:17:18 <hunteriam> is writing shaders at all fun
02:17:21 <hunteriam> or neat
02:17:24 <EvanR> yes
02:17:28 <arkeet> https://www.opengl.org/wiki/Shader_Compilation
02:17:33 <arkeet> yes
02:17:35 <EvanR> god that wiki :(
02:17:38 <arkeet> :(
02:18:14 <arkeet> shaders are where you write the meat of your fun graphics algorithms.
02:18:14 <hunteriam> so did they buy the entire .gl domain or what
02:18:23 <hunteriam> sorry I'm all over the place
02:18:25 <hunteriam> I'm very tired
02:18:28 <EvanR> some guy did
02:18:41 <hunteriam> not the org?
02:18:51 <arkeet> .gl is greenland's ccTLD
02:19:00 <hunteriam> oh really lol
02:19:08 <EvanR> nice
02:19:10 <hunteriam> does greenland even get internet
02:19:15 <arkeet> they obviously do.
02:19:18 * hackagebot hblock 0.1.0.2 - A mutable vector that provides indexation on the datatype fields it stores  http://hackage.haskell.org/package/hblock-0.1.0.2 (HugoGomes)
02:19:18 <hunteriam> or human contact
02:19:23 <bramgg> there's open.gl
02:19:25 <EvanR> hunteriam: opengl.org is kronos group
02:19:25 <arkeet> maybe you should sleep if you're tired.
02:19:37 <hunteriam> yea i will
02:19:45 <hunteriam> arkeet: i was kidding ik they do
02:19:49 <arkeet> :p
02:19:58 <EvanR> does greenland "get" the internet though ;)
02:20:01 <hunteriam> but all i ever read or hear about greenland is how desolate it is
02:20:21 <hunteriam> special piils to retain sanity due to 18 hours of night
02:20:21 <EvanR> people live there but dont find xkcd funny
02:20:52 <EvanR> or cats cute
02:20:59 <hunteriam> they have no hearts
02:21:08 <hunteriam> their hearts are the first to freeze
02:21:20 <mrkkrp> Can someone tell me why `interactive-haskell-mode' tells me that it can't find some packages and that I should add them to .cabal file, while they are already added to the file? This is ridiculous, it's absolute unusable. Cabal works fine, but this mode says it can't find Options.Applicative... it's installed and added to .cabal file! Nonsense.
02:22:01 <hunteriam> mrkkrp: how do you enter interactive haskell mode
02:22:08 <mrkkrp> C-c C-l
02:22:21 <hunteriam> oh this is an emacs thing?
02:22:27 <mrkkrp> yes
02:22:30 <hunteriam> I'm sorry i use a real editor
02:22:33 <hunteriam> (vim)
02:22:36 <hunteriam> ;)
02:22:50 <mrkkrp> I'm not in that mood for these jokes...
02:23:02 <hunteriam> sorry, i wish i could help you
02:23:12 <EvanR> vim draggin me down
02:23:19 <mrkkrp> maybe it's because of sandbox...
02:23:24 <mrkkrp> I don't know
02:23:47 <hunteriam> have you tried cabal installing applicative just to see
02:24:08 <hunteriam> ok I'm going to sleep
02:24:09 <mrkkrp> it's installed in sandbox
02:24:28 <hunteriam> thanks so much for the help guys, got me through an impossible amount of learning and struggling
02:24:30 <hunteriam> night
02:25:26 <m0rphism> mrkkrp: Maybe this helps? http://stackoverflow.com/questions/28396635/haskell-mode-with-sandboxes
02:29:12 <mrkkrp> I have that hook and I've set `haskell-process-type' to 'cabal-repl ...
02:29:51 <mrkkrp> oh, I need a break... I only wish I could somehow setup all this stuff and do some Haskell...
02:34:18 * hackagebot warp 3.0.10 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.10 (MichaelSnoyman)
02:36:22 <ibid> (anybody else in the dark right now?:)
02:36:46 <frerich> Alas, I'm not only in the dark but also in the fog.
02:38:13 <ibid> frerich: cloudy here too, but the darkness is palpaple
02:38:42 <EvanR> i attack the darkness
02:38:54 <EvanR> @dice 1d20
02:38:54 <lambdabot> EvanR: 8
02:43:58 <nshepperd> are you attacking with SAN?
02:46:22 <albertid> only fog here, too :(
02:50:13 <mauke^> ibid: it's not really dark here
02:51:01 <mauke^> nice crescent sun, though
02:51:26 <EvanR> ah total solar eclipse today?
02:51:49 <hyPiRion> yeah
02:52:00 <mauke^> partial here
02:52:08 <makalu> what was the name of the extension that brought field names into scope when I pattern match "Constructor{...}"?
02:52:22 <hyPiRion> It's like 2-3 mins to 88% here
02:52:23 <frerich> RecordPunning or so?
02:52:34 <mauke^> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-wildcards
02:52:35 <EvanR> i like the pictures from london
02:53:05 <makalu> found it, RecordWildcards
02:54:48 <mauke^> ...
02:55:43 <makalu> sorry and thanks :)
02:56:22 <mauke^> > let runIdentity = () in Identity { .. }
02:56:23 <lambdabot>  Illegal `..' in record construction
02:56:23 <lambdabot>  Use RecordWildCards to permit this
02:56:31 <mauke^> > let runIdentity = () in Identity { runIdentity }
02:56:32 <lambdabot>  Illegal use of punning for field â€˜runIdentityâ€™
02:56:32 <lambdabot>  Use NamedFieldPuns to permit this
02:56:37 <mauke^> well then
02:59:18 * hackagebot Plot-ho-matic 0.5.0.3 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.3 (GregHorn)
02:59:20 * hackagebot generics-sop 0.1.1.1 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.1.1 (AndresLoeh)
03:01:09 <ghorn> @dgpratt_ i heard you were having trouble with Plot-ho-matic so I tried to add usable documentation
03:01:09 <lambdabot> Unknown command, try @list
03:01:26 <ghorn> dgpratt_: i heard you were having trouble with Plot-ho-matic so I tried to add usable documentation
03:01:46 <indiagreen> mrkkrp: do you by any chance have several executables defined in your .cabal file
03:06:46 <ghorn> should have waited for docs to build to announce though.......
03:07:28 <EvanR> theres a way to upload docs
03:09:18 * hackagebot basic-sop 0.1.0.4 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.4 (AndresLoeh)
03:09:22 <ghorn> EvanR: i heard it wasn't straightforward yet, and this package should build ok
03:10:15 <ghorn> EvanR: is the standard workflow something like https://gist.github.com/stbuehler/7068764 ?
03:10:53 <EvanR> i dont know, i have a hacked script
03:11:05 <EvanR> not the greatest workflow
03:11:51 <ghorn> it would be rad if it was in cabal "cabal upload-docs" or something
03:25:45 <mrkkrp> What "build target (empty for default)" is meant in interactive-haskell-mode?
03:25:57 <mrkkrp> What can I enter there?
03:26:18 <adamse> mrkkrp: presumably different build targets from your cabal file
03:26:51 <mrkkrp> ok, great. I see that it thinks that library is the default target. How can I specify executable instead?
03:27:52 <adamse> try putting the name of the executable
03:28:09 <adamse> `executable NAME_HERE` in your cabal file
03:28:19 <mrkkrp> let's try it...
03:29:59 <mrkkrp> Now it's working... now I've to fix flycheck and it's done...
03:30:34 <adamse> otoh, just `cabal build` without any target builds all targets I think
03:51:17 <arjen-jonathan> Are there any Agda people here?
03:51:31 <arjen-jonathan> #agda is very very quiet
03:55:23 <hpc> arjen-jonathan: there's a lot of overlap, but agda is generally off-topic here
03:56:50 <mrkkrp> My project consists of library and executable. `cabal build' works ok, however, when I call `cabal repl exe:my-project' it says that <command line>: can't load .so/.DLL for: ... How to fix this?
03:57:23 <arjen-jonathan> hpc: Ah, thanks.
04:07:08 <jophish> Yo, We're doing continuous integration on some Haskell. At the moment it's build in a sandbox in a clean virtual machine. Nealy all of the time is spent grabbing and building dependencies because it starts from clean every time. Can anyone suggest some kind of network cache for packages? 
04:07:35 <jophish> so instead of building lens from scratch every time, it grabs the prebuilt library from some cache
04:09:22 <adamse> mrkkrp: I've mostly encountered similar errors when using template haskell, are you using template haskell?
04:09:38 <mrkkrp> no
04:10:04 <adamse> what's the full error?
04:10:51 <mrkkrp> Loading package my-lib-0.4.1 ... <command line>: can't load .so/.DLL for: /home/mark/projects/programs/my-project/git/dist/build/libHS-0.4.1-ghc7.8.4.so (/home/mark/projects/programs/mida/git/dist/build/libHSmida-0.4.1-ghc7.8.4.so: undefined symbol: midazm0zi4zi1_MidaziRepresentationziBase_reverseOp_closure)
04:12:02 <mrkkrp> There are library and executable in one .cabal file. When I try to load repl for executable it can load the lib... weird
04:15:32 <adamse> mrkkrp: on OSX loading in repl uses dynamic linking vs building that uses static linking (if I'm not mistaken), do there is a difference between ghci and ghc...
04:16:11 <adamse> but I might be wrong, don't really know what I'm talking about :)
04:16:42 <mrkkrp> adamse: I'm on Arch Linux...
04:17:26 <adamse> mrkkrp: well, my guess was that things are probably similar, but I cannot say since I don't run linux
04:18:24 <mauke^> > interact ((++) <*> maximumBy (comparing length) . lines)
04:18:25 <lambdabot>  <IO ()>
04:18:39 <ni291187> http://goo.gl/KMD3CM
04:19:43 <ni291187> http://goo.gl/KMD3CM
04:20:16 <ni291187> http://yrkp.alkerz.ru/191404540/6447523/
04:20:51 <mauke^> @where ops
04:20:52 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:23:09 <ni291187> http://uzlq.asfet.ru/191404540/1835177/
04:23:23 --- mode: ChanServ set +o byorgey
04:23:31 --- mode: byorgey set +b *!*u931732@*.nationalcablenetworks.ru
04:23:31 --- kick: ni291187 was kicked by byorgey (ni291187)
04:23:57 --- mode: ChanServ set -o byorgey
04:24:29 <mrkkrp> One more curious thing: Test/Framework/Providers/QuickCheck2.hs:16:31: Module â€˜Test.QuickCheck.Testâ€™ does not export â€˜runâ€™. cabal: Error: some packages failed to install: test-framework-quickcheck2-0.2.4 failed during the building phase. The exception was: ExitFailure 1.
04:24:29 <mrkkrp>  
04:24:39 <mrkkrp> yesterday it worked...
04:28:22 <byorgey> mrkkrp: that is an extremely old version of test-framework-quickcheck2.  here's what happened: a new version of QuickCheck (2.8) was recently released.  The latest version of test-framework-quickcheck2 has a constraint saying it only works with QuickCheck < 2.8. cabal then tried to find an older version of test-framework-quickcheck2 that supposedly does work with QuickCheck-2.8 (because it didn't specify any version bounds), with disastrous resu
04:29:05 <byorgey> mrkkrp: a good solution would be to pass the flag   --constraint='QuickCheck < 2.8'  to cabal
04:29:08 <mrkkrp> So, I should downgrade QuickCheck to at least 2.7
04:29:10 <mrkkrp> &
04:29:13 <mrkkrp> *?
04:29:45 <byorgey> you don't necessarily need to "downgrade", just tell cabal not to use 2.8
04:30:14 <byorgey> mrkkrp: are you using a cabal sandbox?
04:30:17 <mrkkrp> yes
04:30:42 <mrkkrp> I have to use it, because otherwise I cannot install anything because of dependency hell...
04:31:02 <byorgey> ok, good.  then just delete the sandbox and build again but with  --constraint='QuickCheck < 2.8' this time
04:31:46 <mrkkrp> byorgey: thank you! I will try.
04:32:39 <arbelos> From Okasaki's book on FP Data Structures: "Most (sequential) functional programming languages ...". What does sequential mean in this context mean? 
04:32:39 <hvr> byorgey: btw, feel free to file an issue at https://github.com/haskell-infra/hackage-trustees/issues if it makes sense
04:33:26 <arbelos> sequential, as in not purely declarative.. no time-sequentiality or?
04:37:07 <jophish> Tomatoes are not vegetables! http://blog.ezyang.com/2014/11/tomatoes-are-a-subtype-of-vegetables/
04:51:31 <ccapndave> Hey everyone - this isn't really a Haskell questions as such (I'm actually working in Javascript), but anyway - normally composing two functions would pass the return of one into the arguments of the next.  Is there a different operation that always passes the arguments given to the new combined function to all the functions in the chain?
04:52:12 <frerich> ccapndave : That 'different option' would then yield all the answers from all the functions in the chain?
04:52:12 <ccapndave> So specialCompose(fnA, fnB, fnC)("hello") would call fnA("Hello"); fnB("Hello"); fnC("Hello"); regardless of anything's return type
04:52:20 <unknownloner> like f(a, b, g(a, b)) ?
04:52:25 <ccapndave> Actually the functions are impure
04:52:36 <ccapndave> Maybe this doesn't make any sense in this channel (they have side effects)
04:53:59 <unknownloner> you want to take an array of functions and apply each one to the same argument if im reading right
04:54:03 <ccapndave> Right
04:54:31 <ccapndave> Conceptually am I still composing a bunch of functions into a single function?
04:55:19 <unknownloner> I dont think so, because the output isnt an input of the next
04:55:30 <ccapndave> True
04:55:37 <ccapndave> Am I combining them?
04:55:51 <exio4> it'd be (>>) in Haskell 
04:55:56 <ccapndave> I'm definitely doing something to them since I'm taking a bunch of impure functions and turning them into a single function that calls all of them
04:55:59 <ccapndave> Aha
04:56:03 <ccapndave> What's the name of that operator?
04:56:14 <exio4> I mean, (>>) is just sequencing
04:56:24 <exio4> you'd actually want something like mapM apparently 
04:56:33 <unknownloner> you're doing something slightly different from >> yeah
04:56:41 <ccapndave> Really I'm just trying to thing of the right name for the JS function
04:56:48 <ccapndave> Since I can't really use compose
04:57:46 <ccapndave> https://gist.github.com/ccapndave/3bd831f8c90eb5da919a
04:57:47 <frerich> ccapndave : Something like http://lpaste.net/128065 ?
04:58:09 <ccapndave> Right
04:58:15 <ccapndave> Except it just returns the value of the last function in the chain
04:58:53 <ccapndave> Could I call it 'sequence' maybe?
04:59:17 <ccapndave> Or maybe 'combine'
04:59:19 * hackagebot deepseq 1.4.1.1 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.4.1.1 (HerbertValerioRiedel)
04:59:51 <mrkkrp> ccapndave: heh, it's `progn' is lisp :)
04:59:53 <frerich> ccapndave: 'sequence' would be a fitting name in a Tcl or Perl context. In those languages, a procedure consists of a sequence of statements and the return value of the proceduce is the return value of the last command.
05:00:00 <mrkkrp> *in
05:00:07 <ccapndave> frerich: Perfect then
05:00:09 <ccapndave> sequence it is
05:00:24 <frerich> ccapndave : In in Tcl, what you describe is called 'proc'
05:00:55 <ccapndave> I reckon sequence would be more readable for your average JS dev
05:01:08 <ccapndave> So long as it doesn't mean something totally different in FP I am happy
05:01:51 <ccapndave> Programming in Javascript is hard work :(  Have you guys seen this?  http://www.purescript.org/
05:02:31 <unknownloner> yup
05:02:44 <ccapndave> Someone just pointed me at it the other day.  Very cool
05:07:23 <mrkkrp> Has anyone done a project that had a library and an executable depending on the library in single .cabal file? Could you call `cabal repl exe:foo'? I wonder if I'm running into absolutely unique problem here, so nobody knows how to fix that...
05:07:52 <ghorn> yes
05:08:07 <ghorn> ah wait sorry, i use ./dist/build/....
05:08:21 <ghorn> but it does work, you have to put the executable in a different folder than the library
05:09:14 <ghorn> i can find an example project if you want
05:09:28 <mrkkrp> ghorn: I would be great
05:09:31 <mrkkrp> *it
05:09:45 <ghorn> https://github.com/ghorn/Plot-ho-matic
05:10:05 <ghorn> that one has an "examples" flag so you can turn it on or off if you want
05:10:11 <ghorn> see https://github.com/ghorn/Plot-ho-matic/blob/master/Plot-ho-matic.cabal
05:10:30 <ghorn> cabal configure -fexamples
05:10:31 <ghorn> cabal build
05:10:39 <ghorn> ./dist/build/example/example
05:10:45 <ghorn> not sure if cabal repl example works
05:12:37 <mrkkrp> ghorn: I didn't know about `ghc-prog-options'...
05:12:43 <mrkkrp> *prof
05:13:58 <dgpratt> thanks, ghorn :)
05:14:20 <ghorn> dgpratt: no problem, let me know if there's more i can do
05:15:18 <ghorn> mrkkrp: i've learned a lot by browsing the .cabal files for widely used projects
05:15:35 <dgpratt> I just got gifted a kindle -- what are some good CS books I can put on there?
05:17:22 <rola> functional pearls
05:20:55 <rola> Pearls of Functional Algorithm Design*
05:21:08 <dgpratt> I'll check it out, thanks rola
05:29:30 <mrkkrp> ghorn: funny enough, cabal sandbox init ; cabal configure ; cabal install --only-dependencies for your project failed.
05:29:34 <mrkkrp> cabal: Error: some packages failed to install:
05:29:34 <mrkkrp> Chart-cairo-1.3.3 depends on cairo-0.13.1.0 which failed to install.
05:29:34 <mrkkrp> cairo-0.13.1.0 failed during the configure step. The exception was:
05:29:34 <mrkkrp> ExitFailure 1
05:29:37 <mrkkrp> gio-0.13.0.4 depends on glib-0.13.1.0 which failed to install.
05:29:42 <mrkkrp> glib-0.13.1.0 failed during the configure step. The exception was:
05:29:45 <mrkkrp> ExitFailure 1
05:29:48 <mrkkrp> gtk-0.13.4 depends on cairo-0.13.1.0 which failed to install.
05:29:51 <mrkkrp> pango-0.13.0.5 depends on cairo-0.13.1.0 which failed to install.
05:29:54 <mrkkrp>  
05:29:56 <ghorn> maybe cabal install gtk2hs-buildtools ?
05:29:57 <mrkkrp> like this...
05:30:50 <dgpratt> mrkkrp, I had to install buildtools (as ghorn said) and the gtk 2 libs before I could build the project
05:31:10 <dgpratt> but in my case it was on Windows, so ymmv
05:31:32 <mrkkrp> I naively thought that cabal can manage dependencies...
05:31:41 <ghorn> dgpratt: does it work on windows?
05:31:54 <dgpratt> ghorn, like a champ
05:32:02 <ghorn> \o/
05:32:05 <dgpratt> :)
05:34:06 <mrkkrp> so I've installed this ghc2hs-buildtools package
05:34:16 <mrkkrp> now I should try again?
05:39:37 <ghorn> mrkkrp: yes
05:39:47 <ghorn> "gtk2hs-buildtools"
05:40:18 <mrkkrp> ...building gtk...
05:40:18 <ghorn> this is guaranteed to work, at least on whatever travis-ci is using https://github.com/ghorn/Plot-ho-matic/blob/master/.travis.yml
05:41:24 <mrkkrp> ghorn: your description in .cabal file is inside braces, can I omit them?
05:41:37 <mrkkrp> or they are necessary?
05:42:00 <ghorn> mrkkrp: not sure, sorry
05:43:15 <mrkkrp> ghorn: so, `cabal repl exe:example' works for you?
05:44:09 <ghorn> "cabal run example"
05:45:54 <mrkkrp> well, `cabal run' works for my project too. I'm asking because of interactive-haskell-mode, because it uses cabal-repl, but cabal-repl works only for library, not for executable.
05:47:05 <ghorn> ok yes
05:47:09 <mrkkrp> I've examined the log and it turns out that interactive haskell calls cabal repl exe:my-program, which fails...
05:47:37 <ghorn> "cabal repl example" and "cabal repl exe:example" both load the example in ghci after i "cabal build" the whole thing
05:47:56 <ghorn> and if i run "main" it runs the program
05:48:20 <ghorn> sorry, i should have tested that for you originally
05:49:31 <mrkkrp> `cabal repl exe:example' => cabal: Cannot build the executable 'example' because the component is marked as disabled in the .cabal file.
05:49:32 <mrkkrp>  
05:49:38 <mrkkrp> new troubles...
05:49:52 <ghorn> is that because of my flag?
05:49:58 <ghorn> you need "cabal configure -fexamples"
05:50:57 <mrkkrp> oh, great it works!
05:52:57 <ghorn> seems like that example doesn't work well in ghci though
05:53:16 <mrkkrp> wait, I need to put library and executable in different directories?
05:53:29 <poi_> :t span
05:53:30 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:54:10 <livingBEEF> is CPP the standard preprocessor to use, or does haskell hava its own preprocessor that should be used?
05:54:34 <livingBEEF> I need it for some debugging things...
05:55:12 <ghorn> mrkkrp: i'm not sure, i had to at one point but i don't remember why
05:58:11 <livingBEEF> I could just use the C preprocessor with -cpp, but since I've read somewhere that I shouldn't need it for smaller things, I want to make sure that it's common practice.
05:59:13 <poi_> today i have  memory leak.
05:59:55 <unknownloner> wut
06:00:54 <poi_> finaly i fix by upgading lens libray 4.6.0.1 to 4.8
06:02:24 <zipper> liftIO is life.
06:03:54 <poi_> i find just luky,because i tryed 2nd pc. one worked another not. then i compare and undestand,.
06:05:01 <poi_> now i ask how i can find if only one pc ?
06:09:36 <ghorn> poi_ did you try a backtrace with gdb, or try using valgrind?
06:13:15 <poi_> i dont know both. thaks keywords. are those can show the leak caused lens , you suppose ?
06:14:53 <mrkkrp> Now I'm starting to look at the problem from another point of view.. cabal says that it can't load my library, although it exists. It says: undefined symbol: midazm0zi4zi1_MidaziRepresentationziBase_reverseOp_closure. Why would it say that? Representation.Base.reverseOp is a symbol in Representation.Base, module that is used by some modules that are exported, but this module itself it not exported. Maybe I'm wrong here? I'm sorry for
06:14:53 <mrkkrp> asking so many questions...
06:15:44 <ghorn> poi_: use gdb to debug a binary file: "gdb ./myfile" then "run" then "bt"
06:16:07 <needhalp> yo, any1 here?
06:16:09 <ghorn> poi_: that is for segfaults caused by memory problems
06:16:54 <ghorn> poi_: valgrind can find memory leaks: "valgrind ./myfile"
06:17:43 <needhalp> plebby student here with less than 4 hrs left on his deadline for his last assignment on a course, any1 willing to help?
06:18:35 <mrkkrp> needhalp: don't ask to ask on these channels...
06:19:03 <needhalp> oh well I'd have to send a file
06:19:26 <indiagreen> if it's textual, just upload it on lpaste
06:19:28 <indiagreen> @where lpaste
06:19:28 <lambdabot> http://lpaste.net/
06:19:33 <needhalp> thanks
06:19:34 <poi_> ghorn: valgrind is for linux. i windows. any simmilar idea?
06:20:05 <needhalp> do lpastes show up on google?
06:20:41 <indiagreen> needhalp: not if you make them private, but there's still a possibility of Google indexing IRC logs
06:21:04 <needhalp> aight
06:21:42 <indiagreen> I don't think anyone would be willing to help you if you can't be bothered to rephrase a problem in such terms that your instructor won't be able to google you asking it
06:22:03 <needhalp> it's not that I can't be bothered
06:22:06 <needhalp> it's that I'm super short on time
06:22:21 <needhalp> and if creditet I am allowed to ask for help
06:22:32 <needhalp> I can just say that I asked on this channel
06:24:29 <mrkkrp> ghorn: thanks for your help. I've fixed that by adding that module to `exported-modules'. Now cabal repl works for executable too. Crazy thing...
06:24:59 <ghorn> mrkkrp: great!
06:25:23 <mrkkrp> Now I need to fix flycheck to make it work with sandboxes, and I'm done! :-)
06:25:35 <supki> mrkkrp: you can add it to other-modules: instead if you don't want to export it
06:25:56 <mrkkrp> supki: oh great!
06:39:31 <mrkkrp> According to this issue, https://github.com/flycheck/flycheck/issues/293#issuecomment-31580700 one needs to create `.dir-locals.el' file in project directory to make flycheck respect cabal sandboxes. Is it normal practice nowadays? I guess many folks use flycheck and sandboxes.
06:40:48 <mauke^> > sort [4, 15, 11, 0/0, 11, 2, 1, 4, 3, 0/0, 8]
06:40:50 <lambdabot>  [1.0,2.0,4.0,8.0,NaN,3.0,4.0,11.0,NaN,11.0,15.0]
06:44:54 <adamse> mauke^: have you tried ghcmod with emacs? I imagine it is similar to what flycheck-haskell does and works out of the box with sandboxes
06:45:09 <clrnd> wow
06:45:25 <adamse> mauke^: sorry that was meant for mrkkrp 
06:45:44 <clrnd> > sort [8, 3] :: [Float]
06:45:46 <lambdabot>  [3.0,8.0]
06:46:28 <mrkkrp> I've installed ghc-mod. Earlier I used flycheck in many modes. So, ghc-mode can substitute flycheck completely, so I just need to disable flycheck in haskell-mode?
06:48:38 <hexagoxel> mrkkrp: there exists `other-modules` for such things, that you need to include but do not want exposed
06:49:05 <hexagoxel> (you meant "exposed", not "exported", right?)
06:49:09 <Denommus> mrkkrp: doesn't flycheck use ghc-mod as backend?
06:49:20 * hackagebot pokitdok 4.1.0.2 - PokitDok Platform API Client for Haskell  http://hackage.haskell.org/package/pokitdok-4.1.0.2 (Decryptic)
06:51:58 <mrkkrp> hexagoxel: thanks for your reply, but someone has already mentioned `other-modules' and the problem has been fixed.
06:52:53 <mrkkrp> So, `flycheck' is not used by Haskell programmers?
06:56:10 <mrkkrp> Denommus: I doubt it, since flycheck worked well even without ghc-mod. ghc-mod has been not easy to install, since it has some unspecified dependencies.
06:56:45 <mrkkrp> `happy' and `alex', as I know now.
06:57:52 <decentdog> Hi, does anyone know if there such a thing as a "namespace" / module library? I.e. I want to write some DSL that will use modules, but I'd prefer to not re-implement the mechanism of imports/exports/namespace'ing etc. 
06:58:19 <decentdog> It would be like a library for "naming things", whatever that means
07:01:39 <btcNeverSleeps> mrkkrp: flycheck-mode seems to be working for me under Emacs with sandboxes, but I'm a Haskell beginner so I'm not too sure everything is correct.  I had too many issues with ghc-mod.
07:02:25 <mrkkrp> I'm having too many issues with everything so far.. ;-)
07:11:10 <athan> How does haskell turn a recursive function into the non-recursive intermediate language?
07:11:52 <btcNeverSleeps> mrkkrp: it took me a very long time to set everything up, but now I've got what seems to be a working Emacs + Haskell setup with cabal sandboxes, ghci-ng (if I understand correctly it's like ghci but enhance with a few functionalities, like "jump to definition") / flycheck
07:18:18 <lulzer2> so quiet in here
07:18:55 <bigs> athan: that gets into the details of the runtime. one concept that may be of interest is tail call optimization 
07:19:41 <mrkkrp> btcNeverSleeps: I used to use `flycheck' + `haskell-mode' (and inferior-haskell, since it seemed to be simpler for me) until I started to do more complex projects with sandboxes, test suites and other stuff. Now I need to adapt my Emacs setup.
07:19:56 <athan> bigs: Hmm, okay I'll check it out. Thanks!
07:20:07 <bigs> absolutely
07:20:22 <bigs> essentially haskell doesn't have a "stack" as you would in most languages
07:20:38 <bigs> it operates on thunks -- expressions not yet evaluated
07:24:20 * hackagebot blunt 0.0.8 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.8 (fozworth)
07:26:37 <arbelos> If I have; f xs = map (\x -> x:ys x) xs where ys x = filter (/= x) xs
07:27:03 <arbelos> and the type of f is Eq a => [a] -> [[a]]
07:27:33 <arbelos> what should the type of ys be?
07:28:06 <mrkkrp> I've tired to use `ghc-mod' alone, it doesn't prove on-the-fly checking...
07:28:17 <mniip> ys :: Eq a => a -> [a]
07:28:25 <mniip> note that ys has an implicit parameter though, xs
07:29:28 <arbelos> mniip: but then I get the "could not deduce ..." error
07:29:43 <quchen2_> arbelos: Holes to the rescue!
07:29:46 <quchen2_> :t let f xs = let ys x = filter (/= x) xs in map (\x -> x:(ys `asTypeOf` _hole) x) xs in f
07:29:47 <lambdabot>     Found hole â€˜_holeâ€™ with type: a1 -> [a1]
07:29:47 <lambdabot>     Where: â€˜a1â€™ is a rigid type variable bound by
07:29:47 <lambdabot>                 the inferred type of f :: [a1] -> [[a1]] at <interactive>:1:5
07:30:07 <quchen2_> _hole `asTypeOf` something -- is a pretty useful development idiom.
07:30:32 <mniip> _hole?
07:30:35 <mauke^> arbelos: I wouldn't write an explicit type signature
07:30:40 <arbelos> Yes, which reminds me that I need to upgrade GHC
07:30:57 <quchen2_> mniip: "Guaranteed type error with a useful message"
07:31:02 <mniip> interesting
07:31:17 <quchen2_> :t Just 3 >>= return . _whatShouldIPutHere
07:31:18 <lambdabot>     Found hole â€˜_whatShouldIPutHereâ€™ with type: a0 -> b
07:31:19 <lambdabot>     Where: â€˜a0â€™ is an ambiguous type variable
07:31:19 <lambdabot>            â€˜bâ€™ is a rigid type variable bound by
07:31:36 <arbelos> no maybe I should just leave it without a type, it was just annoying me
07:31:37 <quchen2_> Running that in GHCi gives you a longer message with suggestions on what things are in scope.
07:32:16 <nkar> is there a library that provides an Eq-like typeclass which allows to compare newtypes if they unpack to the same type?  (so I could write newtype1 == newtype2 instead of unNewtype1 newtype1 == unNewtype2 newtype2)
07:32:18 <{AS}> > 2 `Prelude.mod` 3 - 1
07:32:19 <lambdabot>  1
07:32:34 <{AS}> sorry
07:32:40 <{AS}> forgot to private message lambdabot
07:33:08 <arbelos> or I could pass the whole array as an argument to ys, but that feels a bit clumsy
07:33:42 <quchen2_> nkar: You could do that using Data.Type.Coercion, but I'm not sure how suited that is for your task.
07:33:58 <quchen2_> It would certainly work though.
07:34:40 <nkar> quchen2_: let me see
07:35:26 <quchen2_> If you're comparing the same newtype-types then you can of course use derived Eq
07:35:41 <nkar> now, they are different
07:35:43 <nkar> no
07:36:35 <nkar> quchen2_: it's not clear how to use the said module.  could you provide an example?
07:37:43 <quchen2_> Instead of a coercion you should consider using a phantom type to tag your data instead. Data.Tagged can be used for that. Coercions aren't really meant to be used in userland I think.
07:38:17 <nkar> quchen2_: oh, right
07:38:26 <nkar> a phantom is what I need
07:39:04 <quchen2_> And Tagged is the type that is meant for that. :-)
07:39:36 <quchen2_> In particular, you have Eq a => Eq (Tagged tag a)
07:40:18 <mpickering_> what are the most popular refactoring tools?
07:40:52 <nkar> quchen2_: I'm not familiar with Tagged.  why couldn't two Void-like types work along with a newtype?
07:41:31 <quchen2_> nkar: Are you familiar with Proxy?
07:41:35 <nkar> quchen2_: not really
07:41:39 <quchen2_> It's basically "the phantom type type".
07:41:46 <quchen2_> data Proxy a = Proxy
07:41:58 <quchen2_> So you can pass a type around without having any meaningful values
07:42:06 <nkar> quchen2_: what I'm planning to do is: data Sender; data Receiver; newtype NotificationUser a = UserId
07:42:22 <quchen2_> And then  Tagged tag a = (Proxy tag, a)
07:43:04 <nkar> quchen2_: could you look at the example above and explain what Tagged/Proxy buys me in this case?
07:43:20 <livingBEEF> This is weird, I have preprocessor option that skips checks for verbose output. When higher verbosity is enabled (but not used) it's faster, than when it's disabled (and thus should skip some checks and stuff).
07:43:26 <quchen2_> It buys you not having to write your own phantom types ;-)
07:43:58 <quchen2_> nkar: I don't understand your newtype, it seems unrelated to Sender/Receiver.
07:44:00 <livingBEEF> It's not by much, but it's still weird...
07:44:18 <quchen2_> Or is the "a" your tag?
07:44:20 <nkar> quchen2_: a will be filled by the datatypes
07:44:22 <nkar> yes
07:44:40 <nkar> so, I'll have NotificationUser Sender -> NotificationUser Receiver -> ...
07:44:57 <quchen2_> Ah. Well in that case, NotificationUser = Tagged UserId where data UserId = <something>
07:45:14 <quchen2_> i.e. Tagged Sender UserId -> Tagged Receiver UserId -> ...
07:45:40 <albeit> How can I do something like "[a -> f b] -> t a -> f ()? Basically traverse_ that calls multiple functions with the unfolded t a
07:46:44 <nshepperd> Writing your own newtypes with phantom type parameters seems worthwhile though, if it makes the types more descriptive
07:46:53 <kaiyin> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf   Could anyone explain why nest i (text s) = text s? 
07:49:04 <nkar> quchen2_: ah, a phantom is not a want, you confused me :)  I want to distinguish things at the value level when the function is being called, but use == without hassle on both values inside the function body.  so I need two newtypes, and a way to compare them without unwrapping.
07:49:28 <nkar> quchen2_: alternatively, I could just unwrap them, but it'd be nice to know how to do it without that if it's possible
07:52:26 <quchen2_> You could create a function "ignoreTagsEquality :: Tagged t1 a -> Tagged t2 a -> Bool" as well, i.e. a comparison function that ignores the tags.
07:52:32 <quchen2_> +Eq constraint
07:56:41 <nkar> quchen2_: I guess it's an overkill since I'm using it only once, but I'll definitely try something along the lines if I need to generalize
07:56:51 <nkar> quchen2_: thanks for sharing your thoughts!
07:57:31 <jacobian> If I get a conflict while installing something which requires installing base-4.7.0.2, is there any recourse that wont break everything?  Is there a way to have two copies of the libraries with different versions? 
08:00:43 <jtanguy> iirc versions of base are tied to a specific version of ghc
08:02:54 <c_wraith> jacobian: only ghc 7.10 comes with base 4.7
08:03:02 <c_wraith> jacobian: and ghc 7.10 hasn't been released yet
08:04:15 <breadmonster> c_wraith: Can you help me out with a little bit of cabal help?
08:04:21 <breadmonster> parsec won't compile.
08:04:22 <breadmonster> :(
08:04:55 <Big_G> How can I read a file bit by bit
08:05:02 <c_wraith> jacobian: whoops.  I was wrong.  Base 4.7 is GHC 7.8
08:06:12 <c_wraith> jacobian: 4.7.0.2 is probably specifically GHC 7.8.4
08:06:28 <nkar> breadmonster: please describe your problem in more detail
08:06:31 <c_wraith> breadmonster: can you paste the entire cabal output on lpaste?
08:06:41 <nkar> breadmonster: are you using a sandbox?
08:06:59 <breadmonster> nkar, c_wraith: absolutely.
08:07:02 <breadmonster> nkar: Nope.
08:07:15 <jacobian> So I guess there is no easy way to have multiple haskells lying around
08:07:16 <breadmonster> I recently compiled 7.8.4 from source.
08:07:18 <nkar> breadmonster: well, then it's not surprising
08:07:32 <indiagreen> kaiyin: because in the beginning it's said that this design for â€œnestâ€ (only adding spaces after newlines, not in the beginning of the string) makes it possible to use 1 composition operator instead of 2. As a downside, you now have to explicitly do â€œnest n (line <> ...)â€. As an upside, you can get rid of 2 operators for vertical and horisontal composition, plus you can have nesting such as at the top of page 3 (look
08:07:32 <indiagreen> at â€œffff[gg,â€)
08:08:00 <nkar> breadmonster: go to the root of your project dir (the one with a .cabal file) and type cabal sandbox init; cabal install --only-dep
08:08:05 <c_wraith> jacobian: actually, it's pretty easy.  The tooling keeps libraries separated by version
08:08:07 <breadmonster> Okay, cool.
08:08:12 <nkar> breadmonster: alternatively, just cabal install parsec
08:08:37 <breadmonster> One second, let me try with a sandbox?
08:08:45 <mrkkrp> Sorry for repeating my question about flycheck and cabal sandboxes. I've found out that I can set `flycheck-ghc-package-databaes' variable to list of strings that are paths to packages installed in sandboxes. Then `flycheck' works fine. Path to the packages is in `cabal.sandbox.config', variable is named `package-db'. Now I could write a hook and grab that string and set the variable. Maybe someone has done this already? Any other
08:08:45 <mrkkrp> options to make flycheck respect cabal sandboxes?
08:08:53 <nkar> breadmonster: you can read more about it by searching for "cabal sandboxes"
08:09:00 <c_wraith> jacobian: you just need to install them in different places, and make sure the one you currently want to use is the first one in your path
08:09:09 <indiagreen> kaiyin: and â€œnest n (text s) == text sâ€ because it's assumed that the argument of â€œtextâ€ doesn't contain any newlines
08:09:10 <breadmonster> nkar: Will do, thanks
08:09:16 <nkar> sure
08:09:25 <zipper> LOL waiting for haskell 7.10 while we're still on 7.8 I thought applicative - monad proposal was coming in effect this year. Therefore 7.10 should come out this year.
08:09:28 <Ryanar> Hey all, question about the history of Haskell, Haskell Curry passed away before the specification for the open functional language was created at the 1990 conference right?
08:09:28 <breadmonster> nkar: Also, are you familiar with parsec?
08:09:29 <c_wraith> jacobian: I've currently got GHC 7.8.4 and 7.10rc3 installed at the same time.
08:09:31 <kaiyin> indiagreen: thanks a lot.
08:09:42 <c_wraith> zipper: final release of 7.10 is expected in the next few days
08:09:59 <zipper> c_wraith: Shouldn't we be on 7.9 then?
08:10:08 <zipper> Because I am also on 7.8.4
08:10:18 <zipper> will we just make a jump to 7.10?
08:10:18 <c_wraith> zipper: Nope.  Odd numbers are for dev versions.  Release versions get even numbers
08:10:24 <zipper> Oh
08:10:31 <c_wraith> zipper: 7.10 and 7.11 are both in development now
08:10:37 <zipper> c_wraith: hmmmm
08:10:40 <nkar> breadmonster: to some extent
08:10:53 <nkar> breadmonster: I used it and wrote a similar library from scratch
08:10:59 <c_wraith> zipper: depending on whether it's fixes for the 7.10 release, or development for future versions
08:11:06 <nkar> breadmonster: but I'm no expert on parsing
08:11:08 <Welkin> breadmonster: is your name based on the American slang "bread" referring to money?
08:11:10 <breadmonster> nkar: suppose I have a parser `p :: Parser a` and some input string `xs`. Is there a way to parse `xs` using `p` to return `(a, Int)` where the second parameter is the number of times `p` succeeded in a row?
08:11:24 <breadmonster> Welkin: It's a long story, I'll PM.
08:12:00 <indiagreen> breadmonster: you can use â€œcountâ€ to parse a list of as, and then just count them using length
08:12:30 <indiagreen> http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Combinator.html#v:count
08:12:40 <indiagreen> ouch
08:12:42 <indiagreen> no, sorry
08:12:47 <indiagreen> not â€œcountâ€
08:12:49 <indiagreen> â€œmanyâ€
08:13:03 <breadmonster> indiagreen: Yeah, except like count takes an argument that's the number of times you want to run a parser against the input, yeah?
08:13:33 <indiagreen> I just keep confusing them for some reason
08:15:50 <ben__> Having a mind blank - how would I rename a symbol function I've got .= from Csv that conflicts with Lens I want to rename it to ..= which I'm trying like so:       (..=) = Csv.(.=)     What's the correct syntax?
08:16:06 <indiagreen> â€œ(Csv..=)â€
08:16:22 <ben__> indiagreen, thank you very much :-)
08:17:32 <RaceCondition> would Haste (or GHCJS or Fay) FFI bindings for something like Appcelerator Titanium be a major undertaking?
08:18:51 <aawe> RaceCondition: you can do it function by function as you need it
08:21:04 <RaceCondition> aawe: perhaps there's an approach wherein I can generate the FFI bindings from a machine readable APIdoc or smth?
08:21:16 <RaceCondition> I know there is no TH for Haste but I could just codegen 
08:29:07 <safinaskar> is there "general fold" in haskell, something like fmap?
08:30:07 <hodapp> general fold in what sense?
08:30:41 <safinaskar> hodapp: i want to fold not only over lists, but other set, too
08:30:55 <safinaskar> hodapp: (just "fold over set" will go)
08:31:00 <Welkin> foldr/foldl are general folds
08:31:10 <Welkin> in most languages, "reduce" is a left fold
08:31:14 <phaazon> Data.Fold.fold{l,r}
08:31:20 <phaazon> Data.Foldable*
08:31:21 <Welkin> and if they only have "fold" it is often a left fold
08:31:52 <Welkin> yes, Data.Foldable
08:32:15 <Welkin> the foldr/foldl in prelude will be replaced by the generaly version from Foldable in GHC 7.10
08:32:22 <Welkin> general*
08:34:40 <safinaskar> hodapp: Welkin: phaazon: thanks
08:44:34 <aawe> Welkin: same with Traversable?
08:47:47 <lpaste> echo-area pasted â€œProof of (f <=< g) <=< h = f <=< (g <=< h)â€ at http://lpaste.net/128074
08:47:58 <echo-area> Is my proof correct?
08:49:05 <echo-area> Or valid
08:51:58 <c_wraith> echo-area: well, that's a valid strategy for proving associativity of <=< follows from the monad laws.
08:52:24 <c_wraith> echo-area: but each monad instance needs to prove it follows the monad laws independently
08:53:24 <echo-area> c_wraith: I see.  That's the requirement for monad definitions
08:53:54 <echo-area> c_wraith: Thank you.
08:54:54 <c_wraith> echo-area: you can go the other way, too, and prove the monad law about >>= is the same as <=< being associative
08:55:11 <c_wraith> echo-area: that lets you prove either one, depending on which seems easier
08:55:32 <echo-area> c_wraith: You mean assuming one and proving the other?
08:56:05 <c_wraith> echo-area: no, I mean for proving that a monad instance is valid, you can prove either form of the rule.
09:00:46 <echo-area> c_wraith: That is, if a monad instance satisfies the associativity rule, then it is valid.  Is this what I am supposed to prove?
09:01:02 <c_wraith> echo-area: that and the identity rules
09:01:30 <echo-area> c_wraith: Okay, let me try.  Thank you for the pointer
09:09:28 * hackagebot pipes-cliff 0.2.0.0 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.2.0.0 (OmariNorman)
09:19:28 * hackagebot aws-general 0.2.1 - Bindings for Amazon Web Services (AWS) General Reference  http://hackage.haskell.org/package/aws-general-0.2.1 (larsk)
09:20:22 <meoblast001> does anyone know if there's a haskell function which can take characters like '\n' and return ['\\', 'n']?
09:23:40 <lsix> > init $ tail $ show "\n"
09:23:41 <lambdabot>  "\\n"
09:24:17 <lsix> does that help ?
09:27:29 <stbuehler> ghorn: i wrote that script after having looked at the hackage code iirc, so it should be "something like the standard workflow", but ofc not exactly the same
09:29:41 <lsix> meoblast001: a nicer way to write this function would be "init . tail . show"
09:30:11 <lsix> > init . tail . show $ "\n"
09:30:12 <lambdabot>  "\\n"
09:30:15 <meoblast001> hm
09:30:22 <meoblast001> that could work but it relies a lot on show
09:30:35 <meoblast001> i decided to just build my own mapping to handle the characters i'm dealing with
09:30:39 <meoblast001> thanks though
09:33:07 <frerich> meoblast001: there is a 'showLitChar' in Data.Char which does what you want
09:33:13 <frerich> > showLitChar '\n' ""
09:33:14 <lambdabot>  "\\n"
09:33:25 <meoblast001> oh. thanks
09:33:39 <meoblast001> > lexLitChar "\\n"
09:33:40 <lambdabot>  [("\\n","")]
09:33:42 <meoblast001> hmm
09:34:29 * hackagebot hdbc-aeson 0.1.3.2 - Deserialize from HDBC rows to FromJSON instances  http://hackage.haskell.org/package/hdbc-aeson-0.1.3.2 (DanielChoi)
09:35:08 <sammex> I'm totally new to this IRC channel, so I have a question - If many users talk in this channel simultaniously, how do you keep conversations seperate?
09:37:54 <manhha> Hello, I'm new to Haskell. Do you know how to structure unit tests in Haskell+Cabal? I have a module M which has functions f1, f2, f3. Only f1 is exposed. However, I want to unit-test (HSpec) f2, f3 too? Any suggestion? Thanks.
09:38:20 <Luke> manhha: i have that question too. right now I just have to expose everything I want to test
09:38:24 <zomg> manhha: so f2 and f3 are used internally by f1?
09:38:38 <manhha> zomg: yes
09:38:49 <zomg> well, in that case wouldn't their behavior be validated by testing f1?
09:39:04 <zomg> if f1 works correctly, then by extension all functions it uses internally should do so too
09:39:34 <manhha> zomg: you are right. But I have to test all combination of f2, f3.
09:39:47 <manhha> if there is more functions than just these two
09:39:53 <manhha> it would be not easy
09:40:09 <EvanR> stable names lets you know that two objects are the same object at runtime, but does that mean they came from the same expression?
09:41:17 <zomg> manhha: I don't really see how they would require separate tests. If you test all behaviors of f1, then that should also verify all behaviors of anything it uses internally
09:41:18 <manhha> Luke: I've looked at this one: http://stackoverflow.com/questions/14379185/function-privacy-and-unit-testing-haskell, but I don't know it is good idea
09:41:21 <mniip> what's the nowadays "in-fashion" haskell tutorial?
09:41:34 <mniip> (for someone with no functional, but some imperative programming experience)
09:41:58 <sammex> I really liked to read "Learn You A Haskell!"
09:42:14 <mniip> I heard it's not recommended nowadays or something
09:42:49 <sammex> Hmm, then I can't help you :(
09:43:04 <Luke> manhha: an yeah the internal modules is the way to do it
09:43:16 <EvanR> @where cis194
09:43:16 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
09:43:24 <wowca> mniip: why isn't it recomended nowaydays?
09:43:27 <wowca> -y
09:43:43 <mniip> that I don't know
09:43:56 <manhha> zomg: for instance, if each f2, f3 has their own an if condition, so to test f2, f3 implicitly via f1, I have to test at least 4 case for f1
09:44:02 <sammex> Trying it out is free :)
09:44:13 <zomg> iirc the complaint against LYAH is "it's not pedagogically sound"
09:44:25 <zomg> at least I've seen that phrase here a few times when it came up.
09:44:29 * hackagebot satchmo 2.9.7 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.7 (JohannesWaldmann)
09:45:07 <zomg> manhha: wouldn't the behavior of such ifs affect the behavior of f1 anyway, so in order to fully test f1, you would need to include those cases?
09:45:14 <wowca> zomg: eh...That it may be. I'm working mostly with imperative languages (not in school anymore) so maybe it was easier for me. I understand how it could be confusing for a fist-timer.
09:45:22 <wowca> The same way as "Learn C the hard way"
09:45:53 <zomg> Yeah I dunno, I read LYAH too coming from a similar background as yours and didn't see any issues with it :P
09:46:34 <zomg> bitemyapp seems to have a lot of opinions on that topic, I'm sure he can explain it better
09:46:56 <wowca> zomg: are you now working with Haskell? I mean - professionally
09:47:21 <zomg> Well I did write a small haskell application we used for a while at work, if that counts =)
09:47:58 <zomg> but 99.5% of my work actually involves javascript at the moment
09:48:09 <wowca> Not really :) I just don't know if it makes sense investing time into something that I won't be able to use at work and won't get me any better employment opportunities. .)
09:48:26 <zomg> I think it does
09:48:34 <zomg> As a result of knowing Haskell, I write better code overall
09:48:38 <athan> wowca: You'll eventually be able to write compilers with a flick of the wrist!
09:48:55 <athan> And also establish correctness like some crazy voodoo!
09:49:02 <zomg> Besides, it's interesting
09:49:10 <wowca> athan: I don't need to write compilers :D I'm a back-end dev (system integrations & online payment systems implementator)
09:49:11 <zomg> If it's interesting it's a good enough reason to learn something to me =)
09:49:26 <wowca> zomg: that's true, but that's a "purely academic" standpoint :)
09:49:30 * hackagebot digestive-functors 0.7.1.5 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.5 (JasperVanDerJeugt)
09:49:37 <athan> wowca: Well how about this - my haskell web server gets 10k+ responses per second on my laptop!
09:49:46 <wowca> zomg: yeah, but that's why I don't know if I should progress from LYAH
09:49:57 <athan> don't use LYAH
09:49:59 <athan> @learn
09:49:59 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
09:50:05 <EvanR> athan: serving a static doge png ? ;)
09:50:10 <EvanR> from cache
09:50:23 <wowca> athan: What about it? I can't write a server at work if I'll be the only one able to support it.
09:50:32 <athan> EvanR: ._.
09:50:47 <wowca> athan: What do you mean don't use LYAH @learn?
09:50:48 <athan> wowca: Have you heard of fantasyland?
09:51:00 <athan> follow the link lambdabot spewed out!
09:51:11 <wowca> Ah, sure
09:51:41 <wowca> What do you mean - fantasyland? I mean, I have to be realistic sometimes :)
09:51:57 <athan> wowca: It's a javascript library / standard
09:52:01 <athan> it does a lot of category theory stuff
09:52:12 <athan> mirroring (or taking a lot of influence by) haskell
09:52:13 <wowca> oh, never heard of it
09:52:33 <breadmonster> What's the point of the category theory library?
09:52:42 <athan> breadmonster: organization
09:52:52 <breadmonster> athan: Oh okay.
09:52:55 <c_wraith> breadmonster: it was created mostly for its author to learn about category theory
09:52:56 <athan> and clear intentions / capabilities
09:53:05 <c_wraith> breadmonster: that it is sometimes handy is just a coincidence. :)
09:53:12 <breadmonster> Oh okay.
09:53:31 <c_wraith> (or maybe a sign of the deep underlying value of category theory)
09:53:45 <breadmonster> c_wraith: probably more so the latter
09:53:57 <exio4> haskell is a gateway drug to category theory and type theory 
09:54:15 <c_wraith> Just another example of the unreasonable effectiveness of math.  No reason to believe math should be so useful, a priori.
09:54:30 * hackagebot blaze-html 0.8.0.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.8.0.1 (JasperVanDerJeugt)
09:54:32 * hackagebot blaze-markup 0.7.0.1 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.7.0.1 (JasperVanDerJeugt)
09:54:38 <athan> exio4++
09:54:38 <exio4> there'll be a point when you can't get enough Haskell and start looking for hard drugs^Wtheories
09:55:03 <EvanR> reported
09:55:27 <c_wraith> @karma c/c
09:55:27 <lambdabot> c/c has a karma of 1196
09:56:07 <athan> time to go get high (-er order)
09:56:14 <tromp> :t floor
09:56:15 <lambdabot> (RealFrac a, Integral b) => a -> b
09:58:01 <chpatrick> exio4: first theorem's free ;)
09:58:03 <chpatrick> har de har
09:58:28 <btcNeverSleeps> ok but can you learn Haskell without much interest in category theory / type theory?  My reason for learning Haskell is: concise code, good looking code, type safety, easy to "reason about" code (thanks FP), etc.
09:58:50 <chpatrick> btcNeverSleeps: of course
09:58:55 <exio4> chpatrick, athan, heh, those are good ones, I am stealing those!
09:59:30 * hackagebot hakyll 4.6.7.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.7.1 (JasperVanDerJeugt)
09:59:33 * hackagebot websockets 0.9.3.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.3.1 (JasperVanDerJeugt)
09:59:40 <c_wraith> btcNeverSleeps: yeah.  You can use haskell quite productively without learning CT
09:59:56 <exio4> btcNeverSleeps: it's mostly a joke that if you go "down the rabbit hole" you'll end learning category theory and type theory, but you don't really need to 
09:59:59 <chpatrick> I have very basic CT knowledge but 99% of haskell code is no problem
09:59:59 <btcNeverSleeps> good, that is some relief!
10:00:10 <chpatrick> unless it's some super-cokmett library
10:00:11 <c_wraith> btcNeverSleeps: Sometimes, though, you'll find something from CT makes a really nice pattern and it just keeps creeping into your code. :)
10:09:37 <platz> interesting, seems like incremental json parsing with aeson is not yet doable: http://stackoverflow.com/questions/29159486/is-it-possible-to-parse-and-consume-the-results-of-an-aeson-parser-from-a-stream/
10:10:22 <platz> but it is with yajl
10:11:48 <dcoutts> platz: json is pretty bad for trying to parse incrementally because object fields can arrive in any order
10:11:53 <L8D_> hipsterslapfight: because that is bad
10:11:59 <L8D_> noooo
10:12:02 <L8D_> my nick
10:12:07 <EvanR> theres a C json library which works incrementally
10:12:22 <dcoutts> EvanR: but how useful is it if you want to parse into a structure?
10:12:37 <c_wraith> The only thing that really makes sense to parse incrementally is json lists
10:12:38 <EvanR> dcoutts: well thats kind of defeating the purpose of incremental
10:12:53 <EvanR> you want the whole object
10:13:11 <EvanR> object fields can be considered pairs in a list
10:13:18 <dcoutts> well, true, as c_wraith says
10:13:20 <EvanR> you can take those incrementally for some purposes
10:13:42 <EvanR> and you should be able to take strings character by character, but the C lib im talking about doesnt do that
10:14:13 <lpaste> test pasted â€œtestâ€ at http://lpaste.net/351840418058469376
10:15:10 <dcoutts> platz: so I guess the answer is it'd be doing something totally different
10:16:08 <platz> dcoutts: i see it only makes sense for json lists.  but wouldn't XML SAX parsers suffer the same problem?
10:16:16 <platz> i.e. event-based xml parsers
10:16:38 <dcoutts> platz: yes, and those are also not for serialising to/from structures
10:16:52 <dcoutts> which is what aseon is for (primarily)
10:17:12 <dcoutts> SAX "parsers" are more or less just lexers
10:17:23 <dcoutts> giving you a sequence of tokens
10:17:42 <dcoutts> not for deserialising xml to structures
10:18:38 <platz> hrm, I guess I haven't seen much examples of how a SAX parsers are actually used if their not deserializing to structures
10:18:47 <platz> unless they are just used in a larger parser
10:18:56 <dcoutts> platz: but if that's what they're doing, then they're not really incremental
10:19:12 <dcoutts> platz: because the result is not usable until the whole xml token stream has been consumed.
10:19:42 <dcoutts> (except perhaps for the special case of an xml doc being basically one big list of records)
10:20:40 <platz> dcoutts: well thanks, this was enlightening and cleared up some of my questions on this
10:21:03 <dcoutts> platz: so here's a more interesting difference
10:21:40 <dcoutts> sax-based xml deserialisers are typically written such that they deserialise directly into the target object, and don't go via a DOM-like generic structure
10:21:49 <dcoutts> indeed that's the whole point of the approach
10:22:00 <dcoutts> where as currently aeson goes via an intermediate Value type
10:22:27 <dcoutts> the reason it does that is mainly because it makes converting into the user's type easier
10:22:38 <dcoutts> because the parser can look for fields and extract them
10:23:14 <dcoutts> where as if you parse directly from the incomming stream of json tokens, you cannot look for object fields, because they can arrive in any order
10:23:32 <dcoutts> you instead have to "accumulate" your result, updating it whenever a field that you care about arrives
10:23:45 <platz> that sounds a bit harder ;)
10:23:47 <dcoutts> and that's a less straightforward way of writing the parser
10:23:49 <dcoutts> right
10:23:53 <dcoutts> but, there is a cost
10:24:20 <dcoutts> aeson is quite slow for large JSON values because that intermediate structure grows very big
10:24:27 <platz> certainly makes the tradeoff clear though
10:24:30 <dcoutts> this is actually one of the main reasons the binary libs are faster
10:24:46 <dcoutts> they get the input in a known order, so don't need to use an intermediate structure
10:25:09 <EvanR> you could use the Value result directly and there would be little validation and reordering to do
10:25:18 <EvanR> and it would kind of suck
10:25:18 <platz> ordering is a nice guarantee
10:25:25 <dcoutts> otherwise for small inputs aeson is only 2x slower than the binary libs
10:25:34 <EvanR> eh relying on ordering is weird
10:25:43 <dcoutts> but for big ones, the GC overhead for aeson kills the performance
10:26:01 <dcoutts> due to the massive memory spike
10:26:26 * dcoutts has been benchmarking serialisation libs recently
10:26:31 <EvanR> parsec parsers dont have that issue?
10:26:41 <EvanR> or, its possible to avoid the same issue for large inputs?
10:26:45 <platz> i thought of fmapping the Parser Value into something like a Parser FileWrittenToDisk, which is probably stupid (and doesn't give you a data structure you can serialize to)
10:27:00 <platz> doesn't solve the inital problem though
10:27:24 <EvanR> part of aesons service is the validation it does when reading
10:27:31 <EvanR> if you dont need it, you can go faster
10:27:47 <EvanR> by using Value
10:27:50 <dcoutts> EvanR: right, parsec does not have that issue because you write the parser, so if you don't need to accept input in any order then you're ok
10:28:11 <dcoutts> EvanR: but if you use parsec to write a json parser then you have to face the issue somehow
10:28:30 <EvanR> if its just a reading it of the structure then you dont need to worry about order
10:28:33 <EvanR> reading in
10:28:54 <EvanR> did you benchmark getting Values?
10:29:33 <dcoutts> EvanR: sure, if you're parsing into a generic structure then you can accept the fields in the order in which they appear in the input string
10:29:43 <dcoutts> but that's kind of just dodging the issue
10:29:55 <dcoutts> the typical use case is to deserialise into a user type
10:29:59 <EvanR> its a way to getting more performance for more hassle later
10:30:08 <EvanR> dcoutts: well, in js its not ;)
10:30:09 <dcoutts> and it costs more memory
10:30:15 <dcoutts> EvanR: heh, true
10:30:28 <dcoutts> they always defer the typechecking problem
10:30:35 <EvanR> or omit it
10:31:15 <dcoutts> EvanR: no, I didn't benchmark reading just the Value, as that wouldn't be a fair comparison. But no doubt it's a bit faster.
10:32:06 <lpaste> chpatrick pasted â€œApplicatorâ€ at http://lpaste.net/128082
10:36:23 <platz> If I was more skilled I might try and write a parser for the Transit format, but I'm not sure it's within my ability 
10:38:17 <dcoutts> platz: oh it's a pity they're using msgpack rather than cbor which has direct support for tagging for extensions
10:39:12 <Welkin> I feel that Dr. Seuss and Haskell are a perfect match in regard to the terminology, much of which is taken from category theory
10:39:14 <platz> dcoutts: it's always nice to take advantage of existing solutions 
10:39:56 <dcoutts> all their examples would fit nicely within cbor
10:47:05 <vjeranc> Could anyone help me speed up this code http://lpaste.net/128081 - it's about 3 times slower than C version.
10:48:45 <Welkin> vjeranc: if you can run the code while approaching 10% the speed of light, it will be very fast
10:49:04 <vjeranc> Welkin: hahaha
10:51:07 <dcoutts> vjeranc: 32bit or 64bit machine?
10:51:36 <vjeranc> dcoutts: 64bit
10:53:03 <btcNeverSleeps> a function returning a "Maybe xxx" is fine.  What about a function taking a "Maybe xxx" as its argument, is that a code smell in Haskell?
10:53:32 <EvanR> more often theres another function taking less arguments
10:53:41 <EvanR> but sometimes the api takes a Maybe to simulate that
10:54:33 * hackagebot cayley-client 0.1.2.0 - A Haskell client for Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.2.0 (MichelBoucey)
10:54:37 <dcoutts> vjeranc: couple things to try... change iter from being IO and writing lots of small things into a builder, so that it does the formatting faster (avoiding String) and does a few large I/O ops, rather than having to do lots of small operations on the Handle buffer
10:55:08 <dcoutts> vjeranc: and make sure the Builder-based iter is a foldr, not a foldl, and that should let it fuse with the map.
10:56:21 <dcoutts> vjeranc: the remaining thing will be that using words is convenient, but could be faster.
10:57:16 <vjeranc> dcoutts: cool, I'll try everything, and report my results here again.
10:57:21 <vjeranc> dcoutts: thanks!
10:57:21 <dcoutts> and you could do better with a recursive function that uses BS.break
10:57:42 <lpaste> glguy annotated â€œNo titleâ€ with â€œfirst stepâ€ at http://lpaste.net/128081#a128084
10:58:09 <glguy> that doesn't take advantage of dcoutts's suggestion to avoid multiple calls to print
10:59:19 <dcoutts> oh yes, glguy's suggestion is good, as that avoids the word issue entirely by using the builtin int parser
10:59:44 <glguy> The strictness anotations all over the place weren't doing anything
11:00:33 <jle`> btcNeverSleeps: taking `Maybe a` as an argument can have many useful meanings...however, if your code can be refactored into an `fmap f` or a `>>= f`, then you should just leave it as `f` (a -> b) or (a -> Maybe b) if possiblwe
11:02:33 <jle`> if you accidentally write the function "already-fmapped", then that'll mean your function will unecessarily take a Maybe a.  but...the legitimate/meaningful uses are very abundant, so I wouldn't call just seeing "Maybe a" as a function being a good indicator for use as a "code smell"
11:05:15 <nitrix> foo :: Maybe RawBlock -> IO (Maybe RawBlock)
11:05:17 <nitrix> bar :: RawBlock -> IO (Maybe RawBlock)
11:05:35 <nitrix> Hi, how can I feed the rawBlock received in foo, to bar, so that one can return to the other?
11:06:19 <nitrix> I tried <$> but the IO seems to generate a type error.
11:07:20 <nitrix> Looking on hoogle for (f a) -> (a -> g b) -> g b
11:07:33 <Welkin> :t (>>=)
11:07:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:07:47 <nitrix> Actually, it's m m b
11:07:50 <Welkin> you want bind
11:07:50 <nitrix> Because of IO ?
11:07:57 <lpaste> glguy annotated â€œNo titleâ€ with â€œzoomâ€ at http://lpaste.net/128081#a128085
11:08:00 <EvanR> theres two levels here IO and Maybe
11:08:14 <glguy> vjeranc: Check that ^
11:08:20 <nitrix> EvanR: I think that's the issue, bind didn't work for me either :/
11:08:32 <EvanR> you need to combine >>= and fmap somehow
11:08:40 <EvanR> might require pointless fu ;)
11:08:44 <nitrix> EvanR: maybeRawblock >>= bar was an error.
11:08:48 <EvanR> right
11:08:56 <glguy> vjeranc: err, scratch that one :)
11:09:15 <glguy> dcoutts: I don't think going via builder turns into a win on that one
11:09:31 <EvanR> nitrix: if you write it with do notation, you can then put that in @pl ;)
11:09:46 <EvanR> or a combination of @pl and @undo
11:09:53 <nitrix> EvanR: I had it with do notation before but it looked silly. 
11:10:09 <EvanR> not sure but it might look even sillier with combinators
11:10:40 <EvanR> youre basically running a MaybeT over IO
11:11:02 <nitrix> EvanR: Let me paste it.
11:11:13 <lpaste> glguy revised â€œzoomâ€: â€œNo titleâ€ at http://lpaste.net/128085
11:11:18 <nitrix> EvanR: http://lpaste.net/128087
11:11:20 <glguy> that's better
11:11:59 <nitrix> EvanR: It was a lot more disgusting with nested cases, I'm trying to reduce it with <$> because the Nothing cases always return Nothing.
11:12:09 <nitrix> EvanR: But then I hit the issue with that IO at the top
11:12:30 <EvanR> nitrix: i would take care of the maybe earlier rather than making a function that takes a maybe
11:12:45 <vjeranc> glguy: the first version you posted did have a lower execution time, the last version is near C but GC activity is large
11:12:50 <EvanR> or trying to do the rest of the computation in a maybe moday
11:13:12 <EvanR> well you have a lot of maybe so maybe you want MaybeT
11:13:33 <nitrix> EvanR: The whole function ihas many paths that can abort the computation :/
11:13:41 <nitrix> Which is to be expected of a file system.
11:13:49 <EvanR> sometimes you take for granted code that cant Nothing ;)
11:13:56 <EvanR> nitrix: sounds like exceptions
11:14:36 <EvanR> especially since this is IO
11:15:10 <glguy> vjeranc: so... success?
11:16:13 <vjeranc> glguy: seems that the parsing is buggy somewhere, i'm checking it
11:16:48 <glguy> vjeranc: the code assumes space delimited numbers
11:17:12 <vjeranc> glguy: yes, I did change the check to isSpace
11:17:30 <vjeranc> glguy: but the output is wrong, the numbers don't match...
11:18:16 <Iceland_jack> > isSpace euclidianSpace
11:18:17 <Iceland_jack>     
11:18:17 <lambdabot>  True
11:18:38 <EvanR> :t minkowskiSpace
11:18:39 <lambdabot> Not in scope: â€˜minkowskiSpaceâ€™
11:19:55 <breadmonster> Guys, what do I do if I need to parse with state?
11:20:29 <breadmonster> Like when parsing context sensitive languages?
11:20:30 <EvanR> make sure you need to parse with state
11:20:33 <threestrikes> breadmonster:state?
11:20:35 <mauke> doesn't parsec have built in state support?
11:20:45 <EvanR> then use parsec
11:20:54 <glguy> breadmonster: If you need to parse with state, go ahead
11:20:56 <breadmonster> threestrikes: Languages that aren't context free, for instance.
11:21:08 <breadmonster> glguy: How do you do that?
11:21:23 <breadmonster> I've only used parsec from the Text.ParserCombinators.Parsec interface.
11:21:58 <glguy> You either pass around some state as function arguments or you tuck it in parsec's user-state
11:21:58 <breadmonster> In the definition of ParsecT s u m a, is that what m is for?
11:22:22 <glguy> ParsecT s u m a is a parser with stream type s, user state type u, underlying monad m and return type a. Parsec is strict in the user state. If this is undesirable, simply used a data type like data Box a = Box a and the state type Box YourStateType to add a level of indirection.
11:22:43 <glguy> http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec.html
11:22:50 <breadmonster> iirc, s is the type of the parser input, a is what the parser is supposed to return and I never quite got what u and m are for.
11:23:08 <breadmonster> glguy: Seen it, but I don't really get that :(
11:23:12 <mauke> you can ignore m
11:23:29 <mauke> u is the type of your state
11:23:40 <mauke> you pass the initial value into runParser
11:23:54 <mauke> within the parser you can use getState and putState
11:23:57 <breadmonster> runParser?
11:24:00 <breadmonster> Not parse?
11:24:09 <breadmonster> Hmm, okay, fine.
11:24:15 <mauke> no, parse is the simplified interface without state
11:24:24 <breadmonster> Yeah, that seems reasonable.
11:24:38 <mauke> parse p = runParser p ()
11:24:43 <breadmonster> Is there a good tutorial on monad transformers?
11:24:43 <mauke> -- () is the dummy state
11:24:46 <SrPx> Does anyone know where I can find the source code for "PELCR: Parallel Environment for Optimal (...)"
11:24:51 <breadmonster> Hmm, okay, I got that.
11:24:58 <SrPx> Looked up to the 6th page on google
11:24:59 <vjeranc> glguy: yes, I found the bug, you weren't reading the first number
11:25:52 <vjeranc> glguy: still, GC is 13%, so I guess there's room for improvement
11:26:13 <breadmonster> mauke: Does u have to be a monad?
11:26:36 <mauke> breadmonster: no
11:26:39 <breadmonster> I only need to thread one value throughout, so do I necessarily have to use the State monad?
11:26:44 <mauke> in fact, it can't be a monad because kinds
11:27:01 <breadmonster> mauke: So I can't put a State in there?
11:27:04 <glguy> u *can't* be a Monad
11:27:12 <mauke> breadmonster: what does that mean?
11:27:35 <glguy> (oh, I was scrolled up)
11:27:55 <breadmonster> Is it okay to consider ParsecT String (State Int) Identity a?
11:28:05 <mauke> no
11:28:08 <mauke> that's a kind error
11:28:32 <breadmonster> A kind error?
11:28:41 <nh2> is there a convenient way to disambiguate symbols from the own module, like `module A.B.C.D as This (...)`?
11:28:47 <mauke> but you can use ParsecT String Int Identity a
11:29:01 <breadmonster> Okay, fine.
11:29:08 <breadmonster> How do I update the Int?
11:29:11 <mauke> > [Maybe]
11:29:11 <josephle> breadmonster, basically your type doesn't "kind check". You can think of kinds as types for types
11:29:12 <lambdabot>  Not in scope: data constructor â€˜Maybeâ€™
11:29:12 <mauke> er
11:29:16 <mauke> > [] :: [Maybe]
11:29:18 <lambdabot>  Expecting one more argument to â€˜Data.Maybe.Maybeâ€™
11:29:18 <lambdabot>  Expected kind â€˜*â€™, but â€˜Data.Maybe.Maybeâ€™ has kind â€˜* -> *â€™
11:29:22 <mauke> ^ this is a kind error
11:29:52 <breadmonster> mauke: Okay, wow, this is really cool, I haven't seen this before.
11:30:08 <mauke> > [] :: [Maybe Int]
11:30:09 <lambdabot>  []
11:30:18 <mauke> > [] :: [Maybe Int Char]
11:30:19 <lambdabot>  â€˜Data.Maybe.Maybeâ€™ is applied to too many type arguments
11:30:44 <mauke> > [] :: [Maybe (Int Char)]
11:30:46 <lambdabot>  â€˜GHC.Types.Intâ€™ is applied to too many type arguments
11:30:54 <mauke> all sorts of kind errors
11:31:10 <EvanR> kind errors of the third kind
11:34:21 <breadmonster> So what about StateT [Int] (ParsecT String () Identity a)?
11:34:42 <breadmonster> Will that still be a kind error?
11:35:05 <mauke> :t undefined :: StateT [Int] (ParsecT String () Identity a)
11:35:06 <lambdabot>     Not in scope: type constructor or class â€˜ParsecTâ€™
11:35:08 <mauke> aw
11:35:35 <glguy> breadmonster: yes, also a kind error, but it's recoverable
11:36:08 <glguy> StateT [Int] :: (* -> *) -> * -> *
11:36:18 <breadmonster> ...there's something really strange about Parsec on my box.
11:37:04 <breadmonster> glguy: So what I understand is that ParsecT String () Identity :: * -> *
11:37:17 <glguy> yes
11:37:29 <breadmonster> Okay, so what's the last algorithm for?
11:37:33 <breadmonster> *last slot
11:38:16 <breadmonster> Oh the return type, my bad.
11:40:22 <lifter> ^
11:40:55 <Big_G> I'm getting an error with the following line. Any ideas why?
11:41:40 <mauke> sorry, we're dividing by zero over in #haskell-blah
11:41:40 <Big_G> zipWeights x:xs y:ys = (x,y) : zipWeights xs ys
11:41:47 <mauke> Big_G: precedence
11:41:59 <breadmonster> mauke: Umm, also, I'm getting a really strange ghci error.
11:42:12 <Big_G> mauke, How is that the issue?
11:42:12 <mauke> why are you putting spaces around the one : on the right but not the ones on the left?
11:42:16 <breadmonster> Prelude> import Text.Parsec  <no location info>:     Could not find module â€˜Text.Parsecâ€™     Perhaps you haven't installed the "dyn" libraries for package â€˜parsec-3.1.8â€™?     Use -v to see a list of the files searched for.
11:42:28 <nitrix> EvanR: http://lpaste.net/128087
11:42:30 <Big_G> mauke, Looks nicer in my opinion
11:42:31 <lifter> Big_G: put parens around your pattern matches
11:42:40 <nitrix> EvanR: I simplified it a lot, we can easily see the repetition now.
11:42:42 <mauke> Big_G: looks misleading
11:42:45 <mauke> Big_G: it fooled you
11:43:01 <geekosaur> breadmonster, you have a recent ghc that uses shared objects in ghci, and don't have the shared object version of parsec installed. how did you install it?
11:43:02 <Big_G> mauke, Around each x:xs or x:xs y:ys?
11:43:03 <mauke> a b:c d is still parsed as (a b) : (c d)
11:43:08 <Denommus> is there a good functional language for mono/.NET?
11:43:08 <geekosaur> and what platform?
11:43:12 <Denommus> F# is kinda lacky
11:43:21 <breadmonster> geekosaur: Fedora 21.
11:43:25 <breadmonster> And cabal install parsec.
11:43:34 <lifter> Big_G: (x:xs) (y:ys)
11:43:39 <EvanR> nitrix: so you really want monads do notation here not a regular where
11:44:10 <Big_G> lifter, How would I define a tuple then?
11:44:13 <EvanR> nitrix: or exceptions and drop the Maybe
11:44:18 <geekosaur> hm, I think you need to remove it, edit ~/.cabal/config to have `shared: True`, and reinstall it
11:44:19 <nitrix> EvanR: I have maybes and eithers, I'll have nested monadic contexts?
11:44:30 <EvanR> nitrix: no you probably want exceptions
11:44:34 <breadmonster> geekosaur: Will do, hang on a second?
11:44:35 * hackagebot aws-kinesis 0.1.4 - Bindings for Amazon Kinesis  http://hackage.haskell.org/package/aws-kinesis-0.1.4 (larsk)
11:44:44 <lifter> Big_G: Define a tuple? "let x = (1,2)"
11:44:50 <EvanR> nitrix: notice almost none of System.IO is returning Maybe or Either and is a lot easier to use ;)
11:44:53 <breadmonster> geekosaur: What's the removal command?
11:44:57 <Big_G> lifter, I meant in the pattern match.
11:44:59 <breadmonster> cabal uninstall doens't work.
11:45:00 <nitrix> EvanR: I would prefer not getting into exceptions yet. Still a beginner.
11:45:08 <Welkin> ghc-pkg unregister
11:45:24 <EvanR> nitrix: youre getting into triply nested escape transformers instead? to emulate exceptions? in IO? ;)
11:45:25 <Welkin> use ghc-pkg to remove packages
11:45:34 <nitrix> EvanR: These aren't your traditional IO exceptions, I'd have to create my own exceptions and so on.
11:45:38 <lifter> Big_G: "let (a, b) = pair in a + b" or whatever
11:45:38 <breadmonster> `ghc-pkg unregister parsec`?
11:46:21 <EvanR> nitrix: i think youre making it too complicated
11:46:25 <nitrix> EvanR: Lets say I go with exceptions, how do I do that?
11:46:48 <EvanR> whats an example reason why youd return a Nothing?
11:47:39 <breadmonster> geekosaur: It's installing, let's see.
11:48:45 <nitrix> EvanR: It starts with an inodeId, tryign to fetch a block. If the block doesn't exist, that's a error. If the block exist, we parse it. If it doesn't have the proper format, that's an error. If the format is good and our entry is missing, that's an error. If the entry is there, we recursively call the function again with new blocks to parse.
11:48:54 <breadmonster> geekosaur: Still doesn't work for some strange reason.
11:48:55 <nitrix> EvanR: And that, can be an error.
11:49:00 <EvanR> nitrix: definitely exceptions here
11:49:23 <nitrix> EvanR: Why not just chain maybes with <$> though?
11:49:25 <EvanR> make a type for your errors, implement the Exception class, and use throwIO
11:49:35 <EvanR> nitrix: because your code will be 10 times larger?
11:49:42 <EvanR> and it will almost never error out
11:49:56 <nitrix> It will error out pretty often.
11:50:04 <EvanR> it will?
11:50:08 <EvanR> sounds useless ;)
11:50:26 <nitrix> It's a file system, there's more errors than successes, I'm not even kidding.
11:50:42 <EvanR> uh, you mean page faults or something?
11:50:44 <nitrix> Cache misses, block mislocated, bit rot..
11:50:49 <EvanR> those arent errors
11:51:09 <breadmonster> EvanR: Could you give me a hand?
11:51:14 <EvanR> thats control flow
11:51:16 <nitrix> They're all maybes though.
11:51:25 <EvanR> dont use a Maybe for that
11:51:27 <nitrix> Not all IO, but certainly maybes
11:52:13 <EvanR> make different types to describe all the kinds of ways operations can result, and then use case expressions on all of them to make it explicit why whats happening is happening
11:52:19 <EvanR> Nothing doesnt say anything
11:52:21 <nitrix> How come? I use Either when the error matters but when its so fine grained like that, a simple maybe is enough
11:52:35 <EvanR> and a function that always returns Just because it never fails is making it ever harder to grok
11:52:40 <nitrix> EvanR: It's the point, it's too deep to care the reason.
11:52:41 <EvanR> nitrix: what, Either String?
11:53:01 <EvanR> if you dont care, then throw an exception
11:53:08 <nitrix> EvanR: There's actually no either yet, but I assume when I reach the point where I'll need them, it'll start being important to use exceptions
11:53:16 <nitrix> EvanR: Because a string cannot be programatically inspected.
11:53:23 <EvanR> i dont think a large nest of Maybe and Either is a good idea
11:54:07 <EvanR> especially if all the Nothings actually mean something different from each other
11:54:18 <nitrix> It's one of the most complicated function of this application, so having 2 maybes and one either is actually not that bad as the very last step.
11:54:22 <nitrix> *of the computation.
11:54:34 <EvanR> then use nested cases
11:56:10 <vin-ivar> I can't seem to import any of my cabal modules after updating cabal
11:56:13 <vin-ivar> what could the problem be?
11:56:42 <Welkin> are you using the new version?
11:56:55 <vin-ivar> 1.22.1.1?
11:56:58 <vin-ivar> yes
11:57:19 <c_wraith> the package format changed
11:57:26 <c_wraith> Err, the package index format changed
11:57:31 <c_wraith> That might be the issue?
11:57:32 <vin-ivar> ah, it did?
11:57:46 <vin-ivar> i'd built this package myself, not using cabal install
11:59:16 <ackthet> here comes another newb question... why is [1,1,1]<[2,1,1] True? I would have naively assumed it would be false
11:59:42 <vin-ivar> because 1 < 2
11:59:44 <voidzero> first match 
11:59:51 <kaiyin> > pred 0 = 0
11:59:52 <lambdabot>  <hint>:1:8: parse error on input â€˜=â€™
11:59:58 <ReinH>  ackthet (<) compares lists element-wise
12:00:37 <kaiyin> > let pred 0 = 0
12:00:38 <lambdabot>  not an expression: â€˜let pred 0 = 0â€™
12:01:00 <safinaskar> please say me analogue for     a@{ x = b},   but for normal constructors
12:01:01 <ackthet> ReinH: so wouldn't it do 1 < 2, 1 < 1, 1 < 1?
12:01:03 <voidzero> > [1,2,3] < [2,10,10]
12:01:05 <lambdabot>  True
12:01:18 <nitrix> ackthet: Think how you'd sort elements how a list of names alphabetically. You check their first two character if one is smaller than the other. Only if they are equal, do you go to the next character, otherwise you're already done, you know Alex is before George.
12:01:31 <mauke> ackthet: "aaa" < "baa"
12:01:33 <ReinH> ackthet: It stops with the first non-EQ comparison
12:01:34 <voidzero> > [1,20,30] < [2,10,10]
12:01:36 <lambdabot>  True
12:01:38 <ackthet> ahhh ok
12:01:59 <ReinH> ackthet: Otherwise (<) would be useless
12:02:26 <ReinH> Well, I guess it would be useful in a very specific case
12:02:26 <nitrix> Just think how a dictionary would sort the same two lists if they were words.
12:02:50 <ReinH> But its behavior would be surprising.
12:06:12 <nitrix> EvanR: If I had MaybeT I could just chain them in one do block, right?
12:06:27 <EvanR> except for the Either
12:06:44 * EvanR but mentions MaybeT again
12:07:19 <EvanR> i use cases to deal with Maybes in IO all the time, i dont know if MaybeT is worth it for 2 maybes
12:07:25 <nitrix> I'm still surprised that something like `f a -> (a -> m f a) -> m f a` doesn't exists.
12:07:43 <EvanR> if you dont care about readability just write it yourself
12:07:48 <EvanR> (and use it)
12:08:14 <EvanR> (if it even makes sense for two general monads)
12:08:29 <EvanR> (i dont think it does)
12:08:35 <nitrix> I don't know, it's an IO function that calls itself recursively.
12:08:49 <EvanR> MaybeT over IO is well defined
12:08:51 <nitrix> And the type happens to be a `f a`... so it looks funky :/
12:08:59 <EvanR> but m1T over m2 isnt
12:09:57 <nitrix> EvanR: Okay, let's see, the two core functions are:
12:09:59 <nitrix> findInode :: InodeId -> CookedBlock -> Maybe (Either [Resource] [Resource])
12:10:05 <EvanR> nitrix: you can easily convert "f a" to "m f a" but thats not your problem
12:10:07 <nitrix> and inodeRead :: Ledger -> InodeId -> IO (Maybe RawBlock)
12:10:14 <EvanR> m (f a)
12:10:35 <nitrix> Those that look funky? I'm implementing inodeRead, findInode is done.
12:10:46 <hexagoxel> :t (>>=) . lift
12:10:47 <lambdabot> (MonadTrans t, Monad (t m), Monad m) => m a -> (a -> t m b) -> t m b
12:11:06 <nitrix> hackagebot: fancy O:
12:11:09 <nitrix> hexagoxel: ^
12:11:14 <EvanR> t m b = (t m) b
12:11:23 <EvanR> IO (Maybe RawBlock) = t (m b)
12:11:25 * hexagoxel has no idea what exactly you are talking about, but that looks similar ..
12:16:49 <Welkin> not the MuffinMan` !
12:17:53 <Welkin> is there a site with statistics about the channel?
12:18:10 <Welkin> I think a country-level breakdown of the user would be fascinating
12:18:14 <Welkin> users*
12:18:52 <nitrix> hexagoxel: http://lpaste.net/128097
12:19:02 <nitrix> hexagoxel: This is what I'm trying to simplify.
12:19:13 <nitrix> I gave them meaningful names now.
12:19:36 * hackagebot satchmo 2.9.7.1 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.7.1 (JohannesWaldmann)
12:20:50 <Welkin> they should always have meaningful names
12:21:09 <nitrix> hexagoxel: And it'd be a side effect of having a crazy parsing function: findInode :: InodeId -> CookedBlock -> Maybe (Either [Resource] [Resource])
12:23:26 <breadmonster> So I just figured out putState and getState.
12:24:50 <breadmonster> So in a do-block to access the user state, I have to insert a command like this `x <- getState`?
12:25:54 <raek> breadmonster: yes
12:26:03 <breadmonster> raek: Awesome, thanks :)
12:27:28 <mathnewbpi> Could anyone explain me the definition of D here? http://upload.wikimedia.org/math/5/4/4/5440c194eab4a4c89a7e1fdbcf957d6b.png can't find it anywhere in the article
12:28:07 <hexagoxel> nitrix: so.. what about MaybeT?
12:28:48 <shachaf> mathnewbpi: Harder to help when you don't say which article it is. :-)
12:28:56 <raek> mathnewbpi: it is in the syntax part
12:29:08 <raek> type constructor application
12:29:20 <mathnewbpi> thanks, raek, shachaf, article is here: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
12:29:22 <raek> because this is http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system, right?
12:29:36 <mathnewbpi> yeah, exactly thanks
12:30:24 <raek> mathnewbpi: so "D" stands for type constructors such as Maybe, Either and (->)
12:31:06 <mathnewbpi> Would types like Map<A, B> also be valid?
12:32:12 <erisco> f :: A -> B -> C;    type AB = A -> B;   f' :: AB -> C       the hope is A -> B -> C ~ AB -> C but this ends up not being the case, is there any way to fix this?
12:32:14 <raek> yes. the type would be written like "Map a b" in that syntax though
12:32:47 <mathnewbpi> sure, this is how my parser transforms generics
12:32:48 <raek> A -> B -> C means A -> (B -> C)
12:33:11 <raek> so you don't have a (A -> B) in there
12:33:12 <erisco> yes, and?
12:33:40 <ReinH> erisco: There is no way to unify (A -> B) -> C with A -> (B -> C)
12:33:47 <nerium> I'm getting "cabal: Test.hs doesn't exist" when trying to "cabal sdist", but the file exists, why?
12:34:03 <erisco> maybe I am not asking this correctly
12:34:20 <ReinH> f and f' have different types
12:34:25 <dcoutts> nerium: in the right dir?
12:34:31 <breadmonster> Alright, night guys (:
12:34:37 <erisco> I want to abbreviate   A -> B -> C   to   AB  by making  AB an alias
12:34:48 <dcoutts> nerium: is the src search path in the stanza right?
12:34:48 <ReinH> ok, then type AB = A -> B -> C
12:35:14 <erisco> it is unfortunate if I'd have to do  (A, B) -> C    type AB = (A, B)
12:35:39 <erisco> okay I misstated again
12:35:50 <erisco> I want to abbreviate many parameters
12:36:30 <ReinH> You can't do it from the left. (->) binds to the right.
12:36:43 <ReinH> (A -> B) -> C and A -> (B -> C) are different types
12:36:54 <erisco> you're telling me the problem, I know what the problem is
12:37:00 <clrnd> @let a = 5
12:37:00 <ReinH> I'm telling you that there's no solution
12:37:02 <Welkin> associates to the right
12:37:02 <lambdabot>  Defined.
12:37:03 <Welkin> not binds
12:37:15 <ReinH> Welkin: No, not associates.
12:37:36 <ReinH> Hmm. Maybe associates.
12:37:43 <Welkin> the associative property
12:37:47 <raek> don't know how much this helps, but you could do something like "type StandardArguments r = A -> B -> r"
12:37:53 <ReinH> Welkin: There's no associative property here.
12:37:56 <Ke> can someone explain, why I am not getting trace from case branches https://bpaste.net/show/f5b29b7250b7 from http://users.aalto.fi/~jkarlson/codes/xmonad.hs
12:38:16 <Welkin> yes, I mentioned that to highlight the similarities
12:38:17 <raek> then a function that takes an A, a B, and returns a C has type StandardArguments C
12:38:27 <erisco> raek that actually may work for my scenario, let me try that, thanks
12:38:39 <erisco> else maybe there is something like preprocessor macros?
12:38:49 <raek> and a funciton that takes three arguments could be expressed like "StandardArguments (C -> D)"
12:38:57 <nerium> dcoutts: I used the wrong path apparently
12:39:33 <ReinH> Ke: Can you be more specific about where the issue is?
12:39:37 * hackagebot hedis-config 0.0.1 - Easy trivial configuration for Redis  http://hackage.haskell.org/package/hedis-config-0.0.1 (AlekseyUymanov)
12:40:08 <Ke> ReinH: motifIsFullscreen function
12:40:19 <kaiyin> > map (-3) [1, 2, 3]
12:40:20 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
12:40:20 <lambdabot>    arising from the ambiguity check for â€˜e_13123â€™
12:40:21 <lambdabot>  from the context (GHC.Num.Num (a -> b), GHC.Num.Num a)
12:40:31 <kaiyin> Why is this not working?
12:40:36 <ReinH> Ke: What is the issue?
12:40:47 <hiptobecubic> kaiyin, it thinks it's a negative 3, you need the subtract function
12:40:48 <ReinH> kaiyin: (-3) is the number negative three because of a quirk in the grammar
12:40:50 <hiptobecubic> :t subtract
12:40:52 <ReinH> you want map (subtract 3)
12:40:52 <lambdabot> Num a => a -> a -> a
12:41:10 <Ke> ReinH: you see a lot more seq than any of the case branches
12:41:16 <Elite6809> map (- 3) [1, 2, 3]
12:41:22 <kaiyin> ok.
12:41:30 <hiptobecubic> Elite6809, needs a > at the front
12:41:36 <ReinH> Ke: Where do you expect to see a trace that you aren't seeing a trace?
12:42:22 <Elite6809> hiptobecubic: thanks... just realised it won't work anyway heh
12:42:25 <Ke> ReinH: after line1 in would expect to see Nothing branch
12:43:17 <bitemyapp> ReinH: from the Haskell Report: "A function type has the form t1 -> t2, which is equivalent to the type (->) t1 t2. Function arrows associate to the right."
12:43:30 <bitemyapp> ReinH: if the report shouldn't say "associate" here, you should let Simon know and get it amended.
12:43:44 <ReinH> bitemyapp: Thanks for the correction.
12:43:49 <ReinH> Bind is commonly used as well though
12:44:00 <bitemyapp> bind is going to be confusing, given >>=, anyway.
12:44:03 <arkeet> "bind to the right"?
12:44:05 <arkeet> I've never heard that.
12:44:14 <bitemyapp> and I'm not really sure what "binding" would mean WRT (->) and I've never heard it before either.
12:44:20 <ReinH> Alright. It isn't worth arguing about.
12:44:21 <arkeet> until just now.
12:44:23 <arkeet> :p
12:44:34 <bitemyapp> it's not an argument, just a statement of anecdotal differences.
12:44:58 <ReinH> You're seriously arguing with me about whether we're having an argument
12:45:00 <ReinH> This is silly
12:45:11 <ReinH> associate is correct, bind is not, let's move on
12:45:35 <bitemyapp> no argument there ^_^
12:45:39 <ReinH> :p
12:45:47 <arkeet> type AB C = A -> B -> C
12:45:48 <arkeet> :>
12:45:58 <ReinH> arkeet: does that work?
12:46:01 <arkeet> of course.
12:46:19 <arkeet> er, AB c = A -> B -> C
12:46:21 <arkeet> lowercase c.
12:46:30 <ReinH> arkeet: No, it doesn't.
12:46:33 <ReinH> Yeah, that does.
12:46:48 <arkeet> it's not very useful, though.
12:46:53 <ReinH> No, it isn't.
12:48:26 <raek> the Attoparsec source code uses CPS heavily and most functions there take the same three arguments first
12:48:58 <raek> in that code, such a type synonym could be useful
12:49:08 <cfoch> Hello
12:49:37 <cfoch> could somebody please tell me what is this function
12:49:39 <cfoch> programConfigurationPaths
12:49:41 <cfoch> ?
12:52:09 <ReinH> cfoch: Probably not. Where did you find it?
12:52:14 <clrnd> cfoch, whre is it from?
12:52:20 <clrnd> cfoch, what is it's type?
12:52:21 <cfoch> ReinH: in Cabal, wait
12:52:29 <ReinH> Ah. It's helpful to provide context.
12:53:18 <ReinH> raek: It would be more helpful if the type variable wasn't ignored. ;)
12:53:19 * geekosaur already checked hayoo... and promptly got annoyed at what cabal considers documentation
12:53:30 <ReinH> geekosaur: I made the mistake of checking hoogle :)
12:53:54 <ReinH> geekosaur: Also, having spent some time with it myself, I can assure you that Cabal documentation isn't intended for use by anyone other than Cabal developers.
12:53:56 <geekosaur> (the variant programConfigurationPaths' is "documented", in terms of programConfigurationPaths which isn't even shown)
12:54:06 <cfoch> ReinH, clrnd: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Setup.hs#L1311
12:54:17 <dcoutts> Geekingfrog: it's an internal function, simply exported because all the internals are
12:54:27 <dcoutts> oops, meant geekosaur 
12:56:24 <cfoch> geekosaur: that's right
12:57:07 <vin-ivar> okay, so
12:57:10 <vin-ivar> I can't install haskeline
12:57:28 <vin-ivar> /usr/bin/ld: cannot find -lHStransformers-0.4.2.0-ghc7.8.4
12:57:33 <vin-ivar> what could the problem be
12:57:34 <vin-ivar> ?
12:57:53 <ReinH> vin-ivar: can you put the full error in an lpaste?
12:57:58 <vin-ivar> sure, hang n
12:58:29 <geekosaur> how did you install ghc? on what platform?
12:58:53 <lpaste> vin-ivar pasted â€œHaskeline errorâ€ at http://lpaste.net/128102
12:59:06 <vin-ivar> there you go^
12:59:09 <vin-ivar> this is linux mint
12:59:16 <cfoch> dcoutts: but what does this function do?
12:59:38 <Clint> vin-ivar: apt-get install libghc-haskeline-{dev,doc,prof}
13:00:22 <vin-ivar> i've installed dev, hang on
13:00:32 <vin-ivar> \whois Clint 
13:00:39 <cfoch> and what module does the function programConfigurationPaths belongs to?
13:00:43 <vin-ivar> whoops
13:00:50 <vin-ivar> aren't you the same Clint from #linguistics
13:00:58 <Clint> obviously not
13:01:05 <vin-ivar> ok
13:01:22 <vin-ivar> anyway, geekosaur, i installed it from source
13:01:57 <vin-ivar> Clint: libghc-haskeline-prof is 45 mb so it's clearly the right pacakge
13:01:58 <vin-ivar> thanks
13:02:19 <lifter> ping
13:02:44 <arkeet> :t guard
13:02:44 <lambdabot> MonadPlus m => Bool -> m ()
13:02:51 <arkeet> I wish we had an Alternative version of this.
13:03:32 <arkeet> maybe call it guardA.
13:04:07 <ReinH> vin-ivar: I wouldn't recommend mixing cabal installed Haskell packages with apt-get installed Haskell packages.
13:04:30 <cfoch> I like this description
13:04:32 <cfoch> http://hackage.haskell.org/package/Cabal-1.22.1.1/docs/Distribution-Simple-Setup.html#v:programConfigurationPaths-39-
13:04:42 <cfoch> "Like programConfigurationPaths, but allows to customise the option name."
13:05:01 <vin-ivar> ReinH: isn't installing through cabal, though :(
13:05:13 <ReinH> vin-ivar: Right, so we should try to fix that
13:05:40 <vin-ivar> sounds like a good idea
13:06:11 <vin-ivar> what could the problem be, though?
13:06:20 <vin-ivar> all of this started when I upgraded ghc :(
13:06:34 <vin-ivar> shoulda just stuck with 7.6.2
13:07:09 <Clint> because the .debs work
13:07:27 <rui2> \quit
13:07:30 <vin-ivar> eh?
13:08:22 <ReinH> Clint: the deb is out of date, per usual
13:08:38 <ReinH> Anyway, "use apt-get" isn't a viable long term solution for a messed up cabal-install
13:09:10 <Clint> ReinH: i'll take working over bleeding-edge most of the time
13:09:11 <ReinH> vin-ivar: I'd guess that it's a path issue, perhaps cabal is trying to use the ghc package database from the previous installation or something
13:09:39 <Clint> especially if it helps me avoid cabal hell
13:10:14 <vin-ivar> oh yeah, cabal update is being shady, too
13:10:15 <voidzero> I think I remember running into a case where 7.6.2 (on debian) was too old, it would not install certain dependencies
13:10:34 <voidzero> 'it' being cabal.
13:11:11 <vin-ivar> wait, cabal update broke, now
13:11:12 <vin-ivar> gah
13:11:19 <vin-ivar> what's the best way to wipe everythign and start afresh?
13:11:22 <ReinH> Clint: the version installed by apt-get is three years old.
13:12:07 <Clint> ReinH: yikes, how old is the OS?
13:12:23 <ReinH> The next minor version update to that package is also 3 years old, but hasn't made it into apt yet.
13:12:27 <vin-ivar> lovely
13:12:45 <aawe> who is the package mantainer?
13:12:46 <voidzero> yeah this is why I prefer Funtoo (a Gentoo derivative)
13:12:57 <vin-ivar> RIP cabal
13:12:59 <ReinH> apt-get is not a good source for haskell packages, or any other programming language packages, in my experience
13:13:00 <vin-ivar> uninstalled it
13:13:02 <voidzero> the haskell overlay is maintained very well
13:13:03 <vin-ivar> installing it again, now
13:13:17 <Clint> ReinH: in my experience it is
13:13:37 <ReinH> Not if you want to use anything released in the last 3 years
13:13:47 <Clint> ReinH: i use debian testing.  it's all current enough.
13:13:49 <vin-ivar> wait, I can't uninstall the pesky bastar
13:13:51 <vin-ivar> what
13:14:36 <voidzero> erm, Debian Jessie also has GHC 7.6.3
13:14:52 <Clint> yes, and 7.8's in experimental
13:16:31 <ReinH> Sure, if you work hard enough you can make it only a bit less useful than a working cabal install.
13:16:41 <Clint> hahaha
13:17:12 <voidzero> and experimental (sid) isn't the same as testing (jessie).
13:17:12 <ReinH> Clint: I don't think vin-ivar's problem is switching to apt-get, I think it's getting cabal to wrok.
13:17:13 <Clint> it's already far more useful for me
13:17:28 <Clint> ReinH: if he wants working haskeline he can get it without coming in here for help
13:17:38 <Clint> this seems potentially valuable to me
13:17:48 <ReinH> The issue isn't haskeline, it's cabal
13:18:06 <ReinH> and the rest of the ghc environment on that machine, which is borked
13:18:07 <Clint> voidzero: no, but i don't need ghc 7.8 either
13:19:20 <voidzero> done feeding you. :)
13:19:39 * hackagebot aws-kinesis-client 0.3.0.2 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.3.0.2 (JonSterling)
13:20:19 <vjeranc> any libraries for multiprocess communication?
13:20:34 <Clint> STM?
13:22:03 <tommd> Anything under Control.Concurrent, really.  Also, Data.IORef, also 'network', 'distrubuted-haskell'... many many such libraries.  Are you looking for a particular type of IPC?
13:22:44 <ReinH> vjeranc: You should read Simon Marlow's free book on parallel and concurrent programming in Haskell
13:23:06 <voidzero> Free | Paper
13:23:18 <vjeranc> would this be an overkill for processes running on the same machine?
13:23:29 <tommd> vjeranc: Define 'this'.
13:23:43 <vjeranc> STM + network + distributed-haskell
13:23:51 <vjeranc> I'd gladly use just forkProcess
13:24:20 <vjeranc> and do the communication without network
13:24:26 <tommd> STM is useful for multiple threads, one process.  Distributed Haskell would be multiple process and it uses networking.  The network package would be if you'd like to roll your own solution and use IP networking to perform IPC.
13:24:27 <ReinH> vjeranc: Well, we don't know what you want to do
13:24:35 <ReinH> So it's hard to suggest things
13:24:39 * hackagebot checkers 0.4.2 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.4.2 (ConalElliott)
13:24:40 <kurt21> What is the best way to install basic Haskell and ghci on Mac OS 10.10.x? Homebrew?
13:24:48 <ReinH> "multiprocess communication" is a huge topic
13:24:56 <ReinH> kurt21: homebrew works for me
13:25:39 <kurt21> ReinH: ok, thanks
13:28:54 <maurer> Out of curiosity, is there any work going on making an implementation of the STM interface using intel's new HTM features?
13:29:22 <vjeranc> ReinH: I'm just experimenting, I'd like to spawn local processes, each would have an access to a single shared resource, and I'd like to write a simple synchronization protocol, there's no need for network, and I don't want to use threads.
13:29:39 * hackagebot feed-crawl 0.1.1.2 - Utility for fetching feeds with redirect info and HTML link detection  http://hackage.haskell.org/package/feed-crawl-0.1.1.2 (DanielChoi)
13:29:41 * hackagebot blunt 0.0.9 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.9 (fozworth)
13:34:40 * hackagebot seqloc-datafiles 0.4.2 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.4.2 (NicholasIngolia)
13:35:04 <barrucadu> heh, "blunt", good name
13:35:54 <Elite6809> Hi, new to Haskell here - does the `case _ of` construct have any support for conditionals like in F#?
13:36:05 <ReinH> Elite6809: you can use guards
13:36:59 <Elite6809> ah, so you can put a guard over an alternative?
13:41:48 <kaiyin> > fromIntegral  3 / fromIntegral  $ length [1..5]
13:41:49 <lambdabot>  No instance for (GHC.Show.Show a0)
13:41:49 <lambdabot>    arising from a use of â€˜M18648519401292282615790.show_M18648519401292282615...
13:41:49 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
13:41:58 <kaiyin> why isn't this working?
13:42:11 <kaiyin> > fromIntegral  3 / (fromIntegral  $ length [1..5])
13:42:12 <lambdabot>  0.6
13:42:32 <dfeuer> I was reading an SO answer by Luis Casillas, and he used the type  newtype f :-> g = Natural { eta :: forall x . (Functor f, Functor g) => f x -> g x }. I wondered what those Functor constraints were doing, and I still haven't figured it out. It seems I can build such a value without satisfying the constraints, but can't pattern match on one unless the constraints are satisfied. I don't get it.
13:43:19 <barrucadu> dfeuer: It's a type for natural transformations, which are mappings between functors
13:43:29 <ReinH> Er, how is that a newtype?
13:43:44 <arkeet> that's a pretty weird constraint.
13:43:49 <dfeuer> ReinH, it's clearly *not* holding a dictionary.
13:43:54 <dfeuer> Somehow it compiles.
13:44:04 <ReinH> dfeuer: You don't need the constraints at the definition site
13:44:12 <arkeet> it might be a mistake. 
13:44:17 <ReinH> They aren't useful there anyway
13:44:30 <dfeuer> ReinH, I understand they don't seem useful there, but I'm very curious what it is that they're doing.
13:44:58 <dfeuer> I don't understand why I'm allowed to apply the constructor without the constraints being satisfied.
13:45:46 <arkeet> ah, I get what you're asking now.
13:46:00 <ReinH> Because constraints on data declarations don't work like they are supposed to
13:46:17 <ReinH> They're a misfeature.
13:46:38 <dfeuer> ReinH, I thought that had to do with constraints appearing before the type constructor. Is that wrong?
13:47:17 * enthropy thinks a -XDataTypeContext would require the constraint to hold when applying the constructor
13:47:35 <dfeuer> And this compiles with -XNoDatatypeContexts
13:47:47 <cindy> hi
13:47:52 <cindy> i have a hard time with folding trees
13:47:54 <dfeuer> Hallo, cindy. 
13:48:00 <cindy> here's the link: http://lpaste.net/631074207819628544
13:48:08 <cindy> I can't grasp how to iterate recursively
13:48:08 <dfeuer> cindy, that is because wood is not *that* elastic.
13:48:26 <cindy> dfeuer: no need to talk about wood now
13:48:43 <glguy> dfeuer: I don't know why it's useful, but it allows you to take an operation that has those function constraints and hide them
13:48:55 <glguy> dfeuer: and then you can pass around some   f:->g without constraints
13:49:03 <cindy> I got this reverse function: rev (Leaf x) = (Leaf (0-x)); rev (B x y) = B (rev y) (rev x)
13:49:07 <glguy> not needing them until you actually use it
13:49:08 <dfeuer> cindy, I don't see anything wrong with your folding code.
13:49:17 <ReinH> glguy: but if you want to use them again, you have to supply the constraints again
13:49:19 <cindy> doesn't work
13:49:20 <ReinH> so it doesn't buy you anything
13:49:27 <cindy> it doesn't even compile in its current shape
13:49:27 <ReinH> cindy: define "doesn't work" please
13:49:34 <cindy> the issue is 'rev2'
13:49:35 <ReinH> cindy: then include the compilatino error please
13:49:39 <glguy> ReinH: It's probably less straightforward than that
13:49:46 <cindy> rev2 is supposed to do the same as rev
13:49:57 <ReinH> cindy: show us the compiler error in your lpaste please
13:50:23 <cindy> done
13:50:38 <erisco> is there something like Reader for Category?
13:50:56 <erisco> such as functions which read from a shared state?
13:51:07 <ReinH> cindy: what is the type of foldT?
13:51:08 <dfeuer> ReinH, glguy, I'm quite curious why the definition even compiles without DatatypeContexts.
13:51:17 <ReinH> dfeuer: me too.
13:51:52 <dfeuer> cindy, well, you're passing foldT a function of one argument.
13:51:57 <dfeuer> It needs a function of two arguments.
13:52:12 <dfeuer> cindy, give me a second to try to understand what rev does.
13:52:19 <cindy> according to ghci, the type is foldT :: (Int -> t) -> (t -> t -> t) -> Tree -> t
13:52:44 <glguy> ReinH: I'd expect it to need RankNTypes, not DAtatypeContexts
13:52:49 <ReinH> cindy: f is of type a -> a, but foldT expects a function of type a -> a -> a
13:53:07 <ReinH> Or, in this case, Tree -> Tree and Tree -> Tree -> Tree
13:53:16 <glguy> DatatypeContexts are these:  data C a => T a = ...
13:53:49 <cindy> well, you can write 'f = undefined"; the issue I have is that I don't see how to do the case distinction like it is done in 'rev' in rev2 by using a fold
13:53:50 <ReinH> Oh, I see
13:54:13 <arkeet> the case distinction is done by foldT.
13:54:13 <ReinH> cindy: undefined is a member of every type. \x -> x is not
13:54:15 <dfeuer> cindy, I understand what rev does now. Using Leaf as your first argument is _almost_ right, but you need to add something to it to get the negation.
13:54:19 <arkeet> the arguments to foldT tell what to do in each case.
13:54:32 <dfeuer> The f is wrong, yeah. You can fix it though.
13:54:42 <cindy> let's talk about (Leaf) first
13:54:43 <ReinH> The compile error has to do with f being the wrong type.
13:54:49 <dfeuer> Yes.
13:54:55 <dfeuer> Set f=undefined and talk about Leaf.
13:54:55 <ReinH> cindy: There's no point in working on a different problem while you have a compile error
13:54:57 <cindy> For some strange reason (Leaf) gets accepted by the compiler
13:55:00 <ReinH> You won't know if you've solved it
13:55:03 <dfeuer> ReinH, let's go step by step.
13:55:05 <arkeet> it's not strange :)
13:55:16 <arkeet> foldT :: (Int -> Tree) -> (Tree -> Tree -> Tree) -> Tree -> Tree
13:55:19 <cindy> yuo can set f = undefined and the code compiles
13:55:24 <ReinH> cindy: Ok, then let's do that.
13:55:25 <arkeet> Leaf has type Int -> Tree so that part works.
13:55:27 <cindy> with (Leaf) as it is
13:55:36 <dfeuer> The gist of a fold (or catamorphism) is that it replaces each constructor in the argument with what you tell it to.
13:55:39 <cindy> so, I'm wondering why (Leaf) is accepted as the base case in the fold
13:55:51 <cindy> when the constructor has the form 'Leaf Int'
13:55:56 <ReinH> cindy: the base case is a function, and Leaf has the right shape.
13:55:59 <dfeuer> So you'r telling it to replace the constructor Leaf with the constructor Leaf.
13:56:03 <arkeet> cindy: try ":t Leaf"
13:56:07 <Wizek> Good Morning!
13:56:11 <cindy> can I put a function in the base case?
13:56:23 <dfeuer> cindy, Leaf 3 is not a constructor. Leaf is a constructor.
13:56:31 <arkeet> as I said, foldT :: (Int -> Tree) -> (Tree -> Tree -> Tree) -> Tree -> Tree
13:56:31 <cindy> thanks, that is helpful!
13:56:34 <arkeet> and Leaf :: Int -> Tree
13:56:35 <ReinH> foldT k f (Leaf x) = k x, so foldT Leaf f (Leaf x) = Leaf x
13:56:41 <dfeuer> You're effectively replacing the Leaf in that value with another thing, in this case Leaf.
13:56:53 <dfeuer> But Leaf isn't actually what you mean to be putting there, because you want negation.
13:57:09 <cindy> okay, so I can write 'rev2 tr = foldT (\x -> Leaf (0-x)) f tr'
13:57:16 <cindy> which takes care of the base case
13:57:19 <cindy> thanks!
13:57:29 <dfeuer> Yes, that's right.
13:57:31 <dfeuer> I believe.
13:57:41 <Wizek> Does anyone know about something that could translate a snippet of JS to Haskell? Like `fn "function(x) { return x * x }" == "\\x -> x * x"`
13:57:45 <ReinH> Yes, or \x -> Leaf (negate x), or (Leaf . negate)
13:57:49 <dfeuer> So now the "recursive case" is what you use to replace the B constructors.
13:58:01 <dfeuer> Or even Leaf (-x)
13:58:05 <cindy> ok
13:58:09 <dfeuer> But yeah.
13:58:10 <kaiyin> > 2^3
13:58:11 <lambdabot>  8
13:58:19 <kaiyin> > 1.2^2
13:58:20 <lambdabot>  1.44
13:58:22 <cindy> good, so what about the recursive case?
13:58:28 <cindy> can f take an argument?
13:58:39 <ReinH> cindy: f needs to take two arguments
13:58:41 <dfeuer> cindy, so your nodes look like   B x y
13:58:44 <cindy> why two?
13:58:50 <dfeuer> You're replacing the B with whatever you choose.
13:58:53 <arkeet> because foldT :: (Int -> Tree) -> (Tree -> Tree -> Tree) -> Tree -> Tree
13:58:59 <arkeet> so f :: Tree -> Tree -> Tree
13:59:02 <dfeuer> B x y  ==>   f x y
13:59:17 <dfeuer> er ...
13:59:20 <dfeuer> Sort of.
13:59:22 <cindy>   where f x y = B y x
13:59:26 <cindy> just had the same idea
13:59:30 <dfeuer> I'm being fast and loose.
13:59:42 <dfeuer> Yes.
13:59:46 <ReinH> If you want to negate the nodes and keep the structure, replace Node x with Node (-x) and Leaf x y with Leaf x y
13:59:50 <ReinH> er
13:59:54 <ReinH> I got the ctors wrong
13:59:56 <cindy> okay
14:00:13 <cindy> but can you explain to me why f has two arguments
14:00:18 <ReinH> replace Leaf x with Leaf (-x) and B x y with B x y
14:00:21 <dfeuer> Because B has two arguments.
14:00:21 <cindy> when the rev function takes one argument?
14:00:36 <cindy> what happens to 'B'?
14:00:45 <cindy> I thought (B x y) is ONE argument
14:00:46 <dfeuer> There are a lot of Bs.
14:00:50 <cindy> or am I mistaken
14:00:56 <dfeuer> Well....
14:01:02 <dfeuer> You're not passing (B x y) to f.
14:01:09 <dfeuer> You're replacing B with f.
14:01:14 <dfeuer> Essentially.
14:01:15 <ReinH> cindy: let's look at this another way
14:02:14 <ReinH> cindy: look at the definitions of foldT and rev
14:02:21 <ReinH> cindy: you see that they both have two cases
14:02:26 <ReinH> One case for Leaf and one case for B
14:02:38 <cindy> I got it, I got it!
14:02:40 <cindy> thanks!!
14:02:56 <arkeet> here's some way of looking at it.
14:03:10 <arkeet> indeed, compare the definitions of foldT and rev.
14:03:19 <gbiv> is there a simpler-than-grep way to find a specific typeclass instance declaration?
14:03:42 <ReinH> cindy: in rev, you are doing the recursion yourself by calling rev again. In foldT, the recursion is handled for you automatically.
14:03:42 <dfeuer> gbiv, haaaaaa. That is a challenge.
14:03:52 <dfeuer> gbiv, let me know if you find one.
14:04:04 <ReinH> cindy: so you don't need to worry about the *shape* of the recursion, just what happens at each spot in the tree.
14:04:17 <arkeet> ok so.
14:04:24 <gbiv> dfeuer: wonderful! i'll definitely let you know if i do :p
14:04:28 <arkeet> you want to write rev2 using foldT.
14:04:35 <arkeet> rev2 = foldT k f where ...
14:04:38 <arkeet> but you also want rev2 = rev
14:04:42 <arkeet> well, 
14:04:43 <gbiv> thanks
14:04:43 <ReinH> cindy: If you want to negate leaves and keep the structure intact, what you want to do is replace each B with itself (thus keeping the structure intact) and replace each Leaf with its negated value.
14:04:52 <arkeet> rev (Leaf x) = Leaf (-x)
14:04:56 <arkeet> and foldT k f (Leaf x) = k x
14:05:09 <arkeet> so if you want rev = foldT k f, you better have k x = Leaf (-x)
14:05:18 <arkeet> similarly compare the B cases.
14:05:34 <arkeet> foldT k f (B x y) = f (foldT k f x) (foldT k f y)
14:05:41 <arkeet> rev (B x y) = B (rev y) (rev x)
14:05:50 <cindy> okay
14:06:00 <cindy> thanks for all your help ReinH!
14:06:05 <arkeet> ok, this one's recursive so it's a bit more work.
14:06:12 <ReinH> arkeet: but it isn't!
14:06:16 <arkeet> but we already said we want foldT k f = rev
14:06:24 <ReinH> you want to find a foldT k f = rev
14:06:34 <arkeet> so foldT k f (B x y) = f (rev x) (rev y)
14:06:39 <arkeet> and you want that to equal B (rev y) (rev x)
14:07:07 <arkeet> that should suggest how f needs to be defined.
14:22:02 <cjay> is there a good way to compose functions like minimum and maximum, in a way that needs only one pass over the list and returns a tuple of (min value, max value)?
14:22:20 <cjay> the only way I can think of, is using threads and channels and getChanContents
14:22:35 <arkeet> uh you don't need anything like that.
14:22:42 <arkeet> you can do it with a plain fold.
14:22:44 <ReinH> dfeuer: So you can say Natural listToMaybe :: [] :-> Maybe, btw. :D I ramble about this a bit here http://reinh.com/notes/posts/2014-07-19-notes-on-edward-kmett-on-hask.html
14:22:51 <dfeuer> Oh, hi.
14:23:13 <dfeuer> cjay, look at the foldl package.
14:23:17 <ReinH> (:->) forms a category, etc
14:23:32 <arkeet> just think about how to do it with a plain fold.
14:24:14 <arkeet> foldl package gives you a nice way of composing folds.
14:24:22 <arkeet> but you don't *need* it.
14:24:44 <dfeuer> ReinH, you're talking there about what Natural does, not this peculiar version, right? I should surely read your essay, as I would like to understand that too....
14:24:44 <cjay> arkeet: assuming I don't know what minimum and maximum do ;)
14:25:01 <ReinH> dfeuer: yes
14:25:10 <ReinH> My version doesn't use the constraints because they are useless as given
14:25:13 <cjay> using a fold directly would force me to reimplement the behavior of minimum and maximum
14:26:00 <ReinH> > foldMap (Sum &&& Sum) [1,2,3,4]
14:26:03 <lambdabot>  (Sum {getSum = 10},Sum {getSum = 10})
14:27:29 <ij> STM is something different, better and cooler than CSP and I should read about it?
14:27:43 <cjay> ok the foldl package seems to be the right one, thanks dfeuer 
14:27:45 <dfeuer> ReinH, are constraints like that ever useful?
14:27:52 <dfeuer> cjay, no problem.
14:28:06 <ReinH> > foldl' (\(a,b) y -> (max a y, min b y)) (minBound, maxBound) ([1,2,3,4] :: [Int])
14:28:07 <lambdabot>  (4,1)
14:28:10 <ReinH> cjay: That traverses once.
14:28:17 <ReinH> You can make Max and Min monoids for Bounded Ord instances
14:28:24 <arkeet> @let newtype Min a = {getMin :: Maybe a} deriving Show
14:28:24 <lambdabot>  Parse failed: Parse error: {
14:28:29 <dfeuer> cjay, there's been some research into automatically fusing vector operations like that, but I don't know if it's made it to practical Haskell yet.
14:28:32 <arkeet> @let newtype Min a = Min {getMin :: Maybe a} deriving Show
14:28:34 <lambdabot>  Defined.
14:29:24 <arkeet> @let instance Ord a => Monoid (Min a) where mempty = Min Nothing; Min (Just a) `mappend` Min(Just b) = Just (a `min` b); Min Nothing `mappend` b = b; a `mappend` Min Nothing = a
14:29:25 <lambdabot>  .L.hs:157:49:
14:29:25 <lambdabot>      Couldn't match expected type â€˜Min aâ€™ with actual type â€˜Maybe aâ€™
14:29:25 <lambdabot>      Relevant bindings include
14:29:29 <dfeuer> ReinH, yeah, you can do that, but it's not as strict as you're pretending.
14:29:30 <arkeet> oh.
14:29:36 <ReinH> dfeuer: what do you mean?
14:29:38 <dfeuer> ReinH, you'd need to use strict pairs.
14:29:42 <arkeet> @let instance Ord a => Monoid (Min a) where mempty = Min Nothing; Min (Just a) `mappend` Min(Just b) = Min$Just (a `min` b); Min Nothing `mappend` b = b; a `mappend` Min Nothing = a
14:29:44 <cjay> hmm I guess the compiler could find out by itself that a funcion does a kind of fold
14:29:45 <lambdabot>  Defined.
14:29:48 <ReinH> dfeuer: The pairs are scrutinized.
14:30:00 <arkeet> > foldMap (Min.Just &&& Sum) [3,2,6,7]
14:30:01 <lambdabot>  Not in scope: data constructor â€˜Min.Justâ€™
14:30:07 <arkeet> > foldMap (Min . Just &&& Sum) [3,2,6,7]
14:30:08 <lambdabot>  (Min {getMin = Just 2},Sum {getSum = 18})
14:30:14 <dfeuer> ReinH, ah, yes, you're right.
14:30:16 <ReinH> arkeet: indeed :)
14:30:18 <dfeuer> Er..
14:30:34 <arkeet> or you can use foldl' (\(!a,!b) ...
14:30:40 <ReinH> dfeuer: when the constructor is scrutinized, the members are scrutinized.
14:30:43 <dfeuer> ReinH, the pairs are scrutinized, but not their elements.
14:30:53 <ReinH> Hmm.
14:30:56 <ReinH> I think you're right.
14:30:58 <dfeuer> Not unless the strictness analysis figures it out.
14:31:02 <ReinH> Yeah.
14:31:06 <ReinH> So bangs or strict Pair
14:31:07 <dfeuer> Which it often will, but no guarantees.
14:31:48 <ReinH> dfeuer: in fact, it's the opposite of what I said: foldl and foldl' will behave almost equivalently
14:31:52 <dfeuer> And will require inlining, I guess, in this context. For if the result components are not scrutinized, they need to stay lazy.
14:31:56 <ReinH> because the ctor is scrutinized
14:32:17 <ReinH> iow, foldl' doesn't add any strictness over foldl
14:32:23 <dfeuer> Well, foldl might actually be slightly less awful in this case, but don't do any of that :-P
14:32:27 <ReinH> dfeuer: :p
14:32:40 <dfeuer> Use the foldl package which will make it work automagically, and be very flexible too.
14:32:59 <ReinH> dfeuer: That's true, but this was also a nice opportunity to demonstrate that the composition of monoids is a monoid
14:33:09 <ReinH> so you can get a nice result with foldMap as well
14:33:10 <arkeet> or folds package
14:33:26 <dfeuer> Interestingly, it appears that at least one but I think two others invented the Fold type before Gonzalez also did so independently, but he was the first to actually make a package to actually make it useful.
14:33:41 <ReinH> yep
14:33:56 <ReinH> profunctors are all around us, silently waiting ;)
14:34:04 <dfeuer> Now you're scaring me.
14:34:06 <dfeuer> but
14:34:09 <dfeuer> I have to GOOOOOO.
14:34:10 <arkeet> I guess folds doesn't come with much.
14:34:17 <arkeet> profunctors are easy.
14:34:32 <ReinH> btw I mentioned to Eugenia Cheng that she should do some more Catsters episodes and she responded!
14:34:44 <dfeuer> Positively, negatively, or neutrally?
14:34:57 <dfeuer> I have heard very good things about her work, but I have not yet seen more than a few minutes.
14:34:59 <ReinH> She agreed and asked for topics. I suggested profunctors and kan extensions.
14:35:04 <dfeuer> :-D
14:35:06 <ReinH> You should watch the videos, they're great.
14:35:07 <arkeet> :)
14:35:10 <dfeuer> I will.
14:35:27 <ReinH> I also suggested monoidal and closed categories, and exponentials. But mostly kan extensions and profunctors.
14:35:44 <ReinH> Since they're everywhere
14:45:26 <ReinH> dfeuer: natural transformations are boring in Haskell though
14:49:03 <FreeFull> Implementing automatic differentiation with dual numbers is a good exercise
14:49:36 <FreeFull> Make sure that your Dual type is polymorphic, or it's boring
14:52:24 <Luke> I'm trying to run hpc on a tix file that was generated via -fhpc flag and hpc is complaining it can't find a whole bunch of my modules. am I doing this right? I'm following this guide: https://wiki.haskell.org/Haskell_program_coverage
14:56:57 <fresheyeball_> hello out there
14:57:26 <fresheyeball_> have any of you use fpcomplete for webdevelopment?
14:59:12 <enthropy> Luke: and you're passing in the --src flag to hpc markup?
14:59:22 <Luke> no. but I tried that and it still complained
14:59:31 <Luke> my stuff's just in ./src
14:59:53 <enthropy> http://code.haskell.org/HList/hpcReport.sh is a working hpc example
15:00:30 <enthropy> but it doesn't look that the wiki page is asking you to do anything different
15:00:34 <Luke> --enable-library-coverage that sit
15:00:44 <Luke> I used to have that in my .cabal.config then it stopped working in the latest version of cabal
15:02:12 <enthropy> I dunno about "stopped working", I think they just want you to use another flag
15:02:55 <enthropy> Warning: The flag --enable-library-coverage is deprecated. Please use
15:02:57 <enthropy> --enable-coverage instead.
15:05:42 <Luke> enthropy: yeah I saw that
15:05:45 <Luke> thanks
15:05:50 <Luke> this is definitely trying to do a lot more now
15:06:20 <Luke> it'd be nice if the guide mentioned something about these flags as well
15:07:33 <d34df00d> Hi!
15:07:42 <d34df00d> Is it possible to use fundeps or type families with overlapping instances?
15:07:54 <d34df00d> Something along the lines of http://melpon.org/wandbox/permlink/3CrqnpZkUgaCoKxJ doesn't work for me.
15:08:11 <enthropy> Luke: cabal's manual probably goes over them... it can't be too hard to add a link there from that wiki page
15:08:32 <Luke> yeah i'm sure it does but just for the sake of having it all in one place
15:10:14 <fresheyeball_> have any of you use fpcomplete for webdevelopment?
15:11:41 <enthropy> d34df00d: yes with fundeps you can have overlap. Or if you only have those two instances you could make the type family in there a closed type family
15:11:42 <d34df00d> Or, in other words, is it possible to write an instance declaration with precondition of the type variable that it is NOT of a given class?
15:12:00 <d34df00d> Enigmagic: I tried rewriting that with fundeps, still getting the error about conflicting fundeps.
15:12:10 <d34df00d> enthropy: eh, sorry, that was for you :)
15:12:15 <d34df00d> And what's a closed type family?
15:15:36 <johnw> d34df00d: like the patterns of a "case" statement represent all patterns to be matched (and thus it's a warning if you omit a pattern), a closed type family represents all the types to be matched at each type variable
15:15:45 <enthropy> d34df00d: http://lpaste.net/128112 is the trick to get around the conflicting fundeps
15:17:00 <d34df00d> johnw: hm, I'm not sure I follow. Could you please give an example?
15:17:12 <johnw> d34df00d: are you familiar with open type families?
15:17:15 <d34df00d> I'm not sure how this "represents" relation is expressed for type families.
15:17:26 <d34df00d> johnw: well, I'm somewhat familiar with "just" type families :)
15:17:35 <johnw> a closed type family does not allow future type family instances
15:17:46 <johnw> and so the set of possible matches is known
15:18:07 <d34df00d> enthropy: > instance (b ~ LogExp a) => Expable a b where
15:18:12 <d34df00d> What does ~ mean?
15:18:33 <johnw> d34df00d: I recommend https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html for a better presentation
15:18:34 <enthropy> it means b must be equal to LogExp a
15:19:11 <johnw> hmm.. did ocharles_ never do closed type families?
15:19:29 <enthropy> so if ghc finds out b is LogExp Int, then the `a' type variable has to be Int
15:19:31 <d34df00d> johnw: hmmm, when exactly does that match? Isn't the correct instance selected purely on my function's arguments types, so no matching or type derivation for type families should be performed?
15:19:59 <d34df00d> Thanks for the link, I'll try this.
15:20:01 <johnw> for example: type Family F a where F Int = Bool; F a = Int
15:20:14 <johnw> no one can come along and add an instance: type family instance F Float = Float
15:20:23 <johnw> and so we know all the possible things 'a' might match against
15:20:56 <d34df00d> But what if I want to support arbitrary stuff like F a = LogExp a?
15:21:07 <johnw> this lets you write a type-level function that does pattern matching against types
15:21:11 <d34df00d> It's closed in a sense, but the set of possible variants is infinite.
15:21:15 <johnw> you can, but it has to be within the type family declaration
15:21:21 <johnw> type family F a where F a = LogExp a
15:21:27 <johnw> (if it's closed)
15:21:34 <d34df00d> Hmm, cool. Must try this.
15:21:53 <johnw> more here: https://wiki.haskell.org/GHC/Type_families#Closed_family_simplification
15:23:30 <d34df00d> Thank you! I hope I'll grasp this level of type system some day :)
15:23:42 <johnw> take what you know about functions, basically, and lift it up to the type level
15:23:44 <johnw> done
15:24:04 <johnw> instead of matching values against constructor patterns, you're matching types against type patterns
15:24:24 <johnw> instead of producing a value at runtime, you're evaluating to a type at compile-time
15:24:52 <d34df00d> enthropy: ok, this works, but why does this hack produce different results (namely, type-checking program) than something like Expable a (LogExp a)?
15:25:19 <d34df00d> johnw: well, this approach worked quite good for me in C++ templates world, but I still have to wrap my head around Haskell thingies.
15:25:25 <johnw> it gets more complex when you add GADTs and DataKinds, because then you can do real computation at the type-level, like adding and subtracting numbers
15:26:09 <johnw> (since numbers can be represented as types, using Peano arithmetic)
15:28:30 <enthropy> http://lpaste.net/128113 with closed type families
15:30:26 <ttt_fff> in threepenny gui, is there anyway to pop up a new window?
15:31:18 <enthropy> d34df00d: I dunno why. I think instance Expable a (LogExp a) -- should probably not get rejected
15:32:17 <d34df00d> enthropy: yeah, when I've googled solutions to the type families case, I've found some post mentioning some Oleg's post (which I could not find) dating 2010 where he claims that fundeps work while type families doesn't (and since they're equivalent, that's bad).
15:32:23 <d34df00d> Probably some kind of regression or smth.
15:32:36 <d34df00d> Thanks for the closed famlies example, some code for me to wrap my head around too!
15:33:21 <enthropy> they aren't equivalent because you can have overlap with the FDs
15:34:21 <enthropy> you can't write   data T a where Con :: Expable a b => b -> T a
15:34:46 * hackagebot feed-crawl 0.1.2.0 - Utility for fetching feeds with redirect info and HTML link detection  http://hackage.haskell.org/package/feed-crawl-0.1.2.0 (DanielChoi)
15:35:27 <enthropy> because if you leave off the second Expable instance, you can define  x = Con (LogExp (LogExp ())) :: T (LogExp ())
15:35:37 <enthropy> then you import that x into a module that has that second Expable instance
15:36:52 <enthropy> and then the FD would tell you that `x' holds a (LogExp ()), not a (LogExp (LogExp ()))
15:49:19 <cjay> > liftM (+1) (return 2)
15:49:20 <lambdabot>  No instance for (GHC.Show.Show (m0 r0))
15:49:20 <lambdabot>    arising from a use of â€˜M79703445206793372217718.show_M79703445206793372217...
15:49:20 <lambdabot>  The type variables â€˜r0â€™, â€˜m0â€™ are ambiguous
15:49:42 <cjay> hm, in ghci this surprisingly works
15:49:50 <cjay> there is defaulting for monads?
15:52:00 <Peaker> I think GHCI defaults to IO
16:00:23 <bluezone> this language is confusing :( i'm at chapter 4 in learnyouahaskell and more or less lost
16:00:50 <pavonia> What are you confused about?
16:01:15 <bluezone> everything, now just looking at how he's using let in list comprehensions 
16:02:02 <bluezone> the syntax i don't understand what is happening, what is visible to what, and he's not using in
16:02:21 <aawe> bluezone: could you show us?
16:02:37 <bluezone> calcBmis :: (RealFloat a) => [(a, a)] -> [a]
16:02:37 <bluezone>  
16:02:37 <bluezone> calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0] 
16:02:58 <bluezone> i might be able to pull off writing this with a where statement
16:03:08 <bluezone> but this let nonsense i don't know what he's doing
16:03:37 <bluezone> i have an idea of what he's doing, but i don't see why it should work
16:03:47 <aawe> bluezone: ah, it's let inside a list comprehension
16:04:47 * hackagebot haskell-updater 1.2.9 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.9 (SergeiTrofimovich)
16:04:52 <bluezone> i just feel like i don't understand why the syntax is the way it is
16:05:07 <aawe> list comprehensions are syntactic sugar for monad composition. Don't care one bit if that does not make sense to you, you just need to know that there is "let x in y", "[ z | let x, y]" and the "let x = y" inside do blocks
16:05:08 <pavonia> bluezone: let introduces new local variable bindings which are only visible inside of the list comprehension
16:05:47 <bluezone> mkay
16:05:56 <pavonia> Where the latter two are basically the same AFAIU
16:07:52 <Fylwind> might be missing something obvious, but is there a shorthand for the identity lens (i.e. 'to id') ?
16:14:48 <edwardk> 'id'
16:14:49 <liyang> Fylwind: id
16:15:03 <Fylwind> edwardk, liyang: ah
16:15:14 <edwardk> :t id :: Lens a b a b
16:15:15 <lambdabot> Functor f => (a -> f b) -> a -> f b
16:15:54 <edwardk> id is a Lens, Prism, Iso, Equality, Traversal, Getter, Setter ... pretty much anything you want in lens ;)
16:18:48 <Fylwind> edwardk: makes sense
16:19:48 * hackagebot executable-hash 0.2.0.0 - Provides the SHA1 hash of the program executable  http://hackage.haskell.org/package/executable-hash-0.2.0.0 (MichaelSloan)
16:22:57 <begriffs> I'm trying to sample random NominalDiffTimes from within a range of two others (http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime). Any ideas?
16:23:41 <begriffs> Thought I could turn them into Integers and sample another Integer and turn it back, but this type seems kind of restrictive.
16:24:16 <lpaste> cjay pasted â€œfoldl package missing (total) foldl1' equivalentâ€ at http://lpaste.net/128116
16:24:58 <bluezone> isn't there going to be effeciency problem if we must define many algorithms recursively? 
16:24:59 <cjay> I'm surprised it doesn't define something like that, and uses it to simplify all the Folds that return a Maybe
16:27:14 <Fylwind> hrm, seems that IndexPreservingGetter not a specialization of Lens'
16:27:18 <bluezone> for instance, defining the fibonacci sequence recursively will run much slower than writing it with iteration
16:27:38 <bluezone> does haskell do some black magic to fix that? :)
16:28:10 <cjay> bluezone: you can pass the accumulator in the recursive call to make it efficient
16:28:10 <Fylwind> bluezone: you could define it tail-recursively
16:30:06 * bluezone was secretly hoping for black magic
16:30:11 <exio4> bluezone: haskell's evaluation is probably different to any model you already know, so pretty much what could look like wasting ram in other language would actually use constant(ish) space and what'd look like an efficient algorithm may actually be a space leak
16:30:43 <johnw> bluezone: sometimes, GHC will turn recursion into iteration
16:31:40 <cjay> interesting question though, is there software that could derive the efficient version from a naive definition of fibonacci?
16:32:15 <edwardk> Fylwind: "Lens" doesn't preserve indices. there is an "IndexPreservingLens", however.
16:32:39 <edwardk> type IndexPreservingLens s t a b = forall p f. (Conjoined p, Functor f) => p a (f b) -> p s (f t)
16:33:07 <edwardk> every IndexPreservingLens can be used as a Lens
16:33:20 <bluezone> we could set up a program to send the naive version to torvalds, cook popcorn, and wait for response :)
16:33:40 <shachaf> You can also compose with <.
16:35:42 <Fylwind> edwardk: should _1 be an index preserving lens?
16:36:03 <edwardk> in general most lenses aren't index preserving
16:36:04 <zipper> What can I read to know more about GHC for a total beginner?
16:36:20 <shachaf> A lot of lenses used to be index-preserving.
16:36:30 <edwardk> foo.bar  usually takes the index from bar.
16:36:37 <edwardk> well, a lot of them used to be indexed, anyways
16:36:43 <shachaf> Then that for changed. I don't remember why.
16:36:50 <shachaf> Well, before that.
16:36:52 <edwardk> foo.bar when bar is index preserving keeps 'foo's index if its there
16:37:01 <cfoch> hello
16:37:01 <shachaf> s/for/got/
16:37:12 <shachaf> Shouldn't talk about lenses from phone.
16:37:16 <cfoch> please I need to know what is the function of "programConfigurationPaths"
16:37:51 <edwardk> to is index preserving because its useful to be able to have something like foo.to count   or foo.to sum  -- take some traversal of groups and turn it into a fold of some summary of the group, without discarding the index along the way
16:38:13 <edwardk> as for things like _1 and _2, we had them have indices  (boring numerical positions) at one point
16:38:21 <cfoch> I asked about it before, but nobody told me what it is... (or maybe you didn't know.) But I need to know what is this function and its type?
16:38:31 <edwardk> but we recanted, it made the FieldN instances harder for users to define
16:38:36 <edwardk> so it doesn't come without a cost
16:38:48 <Fylwind> I see
16:39:25 <edwardk> if we supply a Lens in the package and its not overloaded? we can probably make it index preserving pretty easily but the ones that live in classes where the end user gets to redefine them are probably best unindexed
16:40:24 <edwardk> iplens sa sbt pafb = cotabulate $ \ws -> sbt (extract ws) <$> corep pafb (sa <$> ws)
16:40:32 <edwardk> is a lot messier than
16:40:36 <edwardk> lens sa sbt afb s = sbt s <$> afb (sa s)
16:41:01 <edwardk> and a lot harder to expect someone to figure out how to write themselves inline ;)
16:42:06 <Fylwind> ah
16:46:28 <cfoch> forget my question
16:53:28 <Fylwind> cfoch: http://hackage.haskell.org/package/Cabal-1.22.1.1/docs/src/Distribution-Simple-Setup.html#programConfigurationPaths
16:56:00 <hexagoxel> #neverforget
16:58:03 <EvanR> channels empty
17:00:10 <EvanR> is there a word for the value of a function at 0 (on a real domain for example)
17:01:34 <Fylwind> EvanR: x-intercept?
17:01:40 <Fylwind> *  y-intercept
17:01:42 <arkeet> y-intercept.
17:01:43 <EvanR> no thats a "zero"
17:01:51 <EvanR> ah y-intercept
17:02:06 <arkeet> I think "value at 0" is clear.
17:02:08 <arkeet> I'd just say that.
17:02:21 <EvanR> i know thats usually what its called ;)
17:02:43 <arkeet> for a polynomial or power series you could say "constant term".
17:03:17 <EvanR> when the domain is a 2d plane, or complex plain y-intercept kind of makes no sense
17:03:28 <arkeet> z-intercept ;)
17:03:55 <arkeet> for a function (x,y) -> z anyway.
17:04:50 * hackagebot hplayground 0.1.2.9 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.9 (AlbertoCorona)
17:19:50 * hackagebot process-streaming 0.6.8.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.8.0 (DanielDiazCarrete)
17:24:29 <cfoch> Fylwind: yes... thanks, I didn't find it
17:25:07 <cfoch> what do you understand by a 'knownProgram' in 
17:25:15 <cfoch> https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/Db.hs
17:25:16 <cfoch>  ?
17:27:19 <cfoch> I've just realized I have english classes in 4 minutes... I'll be back later
17:27:21 <cfoch> o/
17:41:58 <funfunctor> anyone got a quick way to strip the \n off the end of a string?
17:43:17 <pavonia> > head $ words "foo\n"
17:43:18 <lambdabot>  "foo"
17:44:20 <funfunctor> ta, filter (/= '\n') seemed a bit expensive
17:44:24 <hodapp> > head $ words "some other string \n"
17:44:25 <lambdabot>  "some"
17:44:41 <funfunctor> ah hmm yea that wont work
17:44:52 <pavonia> Err, I meant *lines
17:44:59 <funfunctor> :t lines
17:45:00 <lambdabot> String -> [String]
17:45:07 <EvanR> @pl \b x -> if b then Just x else Nothing
17:45:07 <lambdabot> flip flip Nothing . (. Just) . if'
17:45:19 <funfunctor> > head $ lines "i d k\n"
17:45:21 <lambdabot>  "i d k"
17:47:14 <arkeet> I don't see how head . lines is any less expensive than filter (/= '\n')
17:47:53 <arkeet> and it's less safe
17:48:10 <arkeet> and it's more like takeWhile (/= '\n')
17:48:18 <funfunctor> ok so the filter solution is better?
17:48:27 <arkeet> depends on what exactly you want.
17:48:39 <exio4> @pl \b x -> guard b >> return x
17:48:39 <lambdabot> (. return) . (>>) . guard
17:48:42 <arkeet> neither of those will only strip the \n from the end.
17:48:44 <funfunctor> ah well render from the boxes package annoying puts a new line at the end
17:48:50 <arkeet> they'll do different things if there's a \n in the middle.
17:49:26 <funfunctor> I guess it works well enough, this part is not so critical since i'll be throwing this code away later
17:49:57 <arkeet> takeWhile (/= '\n') seems reasonable to  me.
17:50:07 <funfunctor> I'm just trying to shim my haskell component in to this much larger C++ project
17:50:08 <arkeet> if you just want the first line of something.
17:51:21 <funfunctor> Ambiguous occurrence god damm, I hate those
17:51:45 <Fylwind> reverse . dropWhile (== '\n') . reverse  (not the most efficient but you're already using String anyway)
17:51:57 <gyaretto> In Parser.hs, on line 14, I have a function that is not in scope for the rest of the functions in the module. How do I put that in the same scope? https://gist.github.com/e25d0962d6dc8b0c8dc1
17:52:01 <arkeet> awful.
17:52:35 <arkeet> gyaretto: just move that outside of the definition of parseProgram.
17:52:42 <arkeet> oh, except
17:52:43 <funfunctor> does not matter head . lines . reader will do the job here
17:52:46 <arkeet> it depends on arg.
17:52:53 <gyaretto> Right. That's the issue.
17:52:54 <arkeet> gyaretto: so what do you want it to do?
17:53:30 <gyaretto> I'm excepting the argument in the Main module. I'd like to have the debug function defined based on the argument and I'm not sure of the best way to do it.
17:53:42 <gyaretto> Because I'm doing to use debug to print everything that happens in the parser.
17:53:52 <gyaretto> s/excepting/accepting/
17:54:10 <gyaretto> s/doing/going/
17:54:14 <vjeranc> glguy: I've managed to get haskell code faster than C, hihi
17:54:37 <arkeet> well, if you're already using trace...
17:54:47 <arkeet> may as well make a top level IORef or something.
17:54:53 <arkeet> that holds the verbosity.
17:55:49 <arkeet> and then in debug you'd unsafePerformIO (read the ioref) or something.
17:55:50 <arkeet> :x
17:56:48 <EvanR> wut
17:57:25 <arkeet> if it's just for debugging.
17:58:01 <gyaretto> arkeet: I'm not sure what that means, lol.
17:58:10 <arkeet> I mean something like
17:58:27 <arkeet> you have
17:58:40 <arkeet> verbose :: IORef Bool; verbose = unsafePerformIO (newIORef False) 
17:58:46 <arkeet> {-# NOINLINE verbose #-}
17:58:51 <arkeet> and then something like
17:59:09 <arkeet> debug a b = if (unsafePerformIO $ readIORef verbose) then trace b a else a
17:59:35 <arkeet> and you'd set the ioref to true somewhere in main
18:00:15 <EvanR> thats some hax
18:00:27 <gyaretto> What do unsafePerformIO and readIORef do?
18:00:43 <arkeet> well,
18:00:47 <arkeet> unsafePerformIO :: IO a -> a
18:00:50 <gyaretto> I'm pretty new to Haskell, so a lot of this is unfamiliar to me. Sorry.
18:00:55 <arkeet> executes some IO action when it's evaluated.
18:01:01 <arkeet> in most cases you shouldn't use this.
18:01:09 <arkeet> because it's evil.
18:01:17 <gyaretto> Good to know. XD
18:01:26 <arkeet> and then IORef is just a mutable reference.
18:01:29 <arkeet> :t newIORef
18:01:30 <lambdabot>     Not in scope: â€˜newIORefâ€™
18:01:30 <lambdabot>     Perhaps you meant â€˜newSTRefâ€™ (imported from Data.STRef)
18:01:33 <arkeet> bleh.
18:01:47 <arkeet> and normally you can only operate on IORefs in IO
18:02:05 <shachaf> Puzzle: If you have unsafeCoerce but no IO actions in scope, how do you run arbitrary code in GHC?
18:02:19 <gyaretto> Would there be a more Haskell-y way to do it? :3
18:02:37 <arkeet> you could pass the verbosity down to all your functions. possibly using a Reader monad.
18:02:49 <arkeet> but I think that's a lot of work just for some debugging.
18:03:01 <arkeet> alternatively you could decide whether to be verbose at compile time.
18:03:32 <gyaretto> Unfortunately, I'm supposed to have a "verbose mode." This is a project for my compilers class.
18:03:39 <arkeet> ok.
18:03:46 <arkeet> if it's for a class.
18:04:00 <arkeet> I'd probably do the safe route and pass a verbosity argument everywhere.
18:04:04 <arkeet> (Â´ãƒ»Ï‰ãƒ»ï½€)
18:04:30 <Rembane> Verbosity monad! Woop woop!
18:04:48 <gyaretto> Ohkay, haha. I appreciate the help! :)
18:04:49 <rui> qui
18:04:52 <rui> \quit
18:04:57 <gyaretto> Thanks arkeet!
18:05:17 <arkeet> and I'd use a Bool, not a String that you check for equality with "verbose" everywhere.
18:05:24 <arkeet> do the conversion to Bool once, in main.
18:05:36 <gyaretto> Oh, that makes more sense. Will do!
18:06:07 <arkeet> were you instructed to use Debug.Trace?
18:09:01 <arkeet> hm.
18:09:14 <arkeet> I wonder if it would be useful for Debug.Trace to provide some way of turning trace messages on/off.
18:12:32 <enthropy> shachaf: "unsafeCoerce :: ByteString -> Maybe ()" will run code in the bytestring when you evaluate the ()?
18:12:57 <shachaf> enthropy: Will it?
18:13:03 <EvanR> haha
18:13:17 <EvanR> its like eval
18:13:21 <exio4> can't we just import GHC.Prim? ;P
18:13:31 <shachaf> Oh, wait, you wrote Maybe (), not ().
18:14:04 <shachaf> Right, I wanted to do it without ByteString either, with nothing imported.
18:15:05 * enthropy wonders what you can do with [Int]
18:15:58 <Rembane> Machine code.
18:16:59 <shachaf> Maybe () doesn't work anyway, because the tag is wrong.
18:18:50 <mgsloan> Random, but kinda fun.  I recently realized this works, because STM is defined identically to IO:
18:18:54 <mgsloan> (unsafeCoerce  (newTVar 1)) >>= readTVarIO >>= (print :: Integer -> IO ())
18:22:51 <rgb-one> Hello
18:23:04 <rgb-one> Any project maintainers around?
18:24:19 <rgb-one> Put another way, does anyone here maintain any software projects?
18:24:41 <glguy> Yes, many of the people in this channel do that.
18:27:59 <gyaretto> arkeet: Sorry!
18:28:31 <gyaretto> arkeet: No, I wasn't instructed to. We were allowed to use any language, so I chose Haskell because I wanted a project to learn it with. :3
18:28:39 <arkeet> ah.
18:29:00 <funfunctor> gezz when is Mesa going to finish off GL_ARB_shader_subroutine already so we can have GL 4
18:34:43 <rgb-one> I would be grateful if you could impart some of your knowledge on the daily activities involved with administering and maintaining a repository.
18:35:05 <EvanR> bitching on the issue tracker
18:35:12 <EvanR> very important
18:35:26 <rgb-one> can you elaborate?
18:35:37 <threestrikes> this is going to great :)
18:36:13 <threestrikes> be*
18:36:22 <fryguybob> mgsloan: :D newTVar is about the only STM operation where that will work and there is no guarantee it will work.
18:37:13 <rgb-one> EvanR: What project do you maintain?
18:37:20 <EvanR> that was a joke
18:37:22 <rui> Any nix user here? I'm trying it on Fedora. Is there any stable channel? I'm getting all my software's  develop branches
18:37:26 <gyaretto> EvanR: http://www.commitlogsfromlastnight.com
18:38:06 <EvanR> that is hilarious
18:38:19 <rui> There seem to be stable channels for nixos, but I would like reassurance that those are ok for non-nixos
18:38:30 <fryguybob> mgsloan: For instance, it would be perfectly reasonable to add a new TVar to the transaction's read set which would fail if not run in the context of attomically
18:39:54 * hackagebot eigen 2.1.0 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-2.1.0 (OlegSidorkin)
18:40:11 <fryguybob> mgsloan: So while the actions appear to be IO actions there is assumed machinery in the RTS that is initialized by atomically making it quite different from IO.
18:44:07 <mgsloan> fryguybob: Makes sense!  Of course, it works the other way around as well, so that you could use unsafeCoerce to implement unsafeIOToSTM
18:44:57 <mgsloan> Which is actually just implemented as an unwrapping / rewrapping of the newtypes, which makes sense
18:47:37 <funfunctor> whats the deal with that commitlogsfromlastnight.com url?
18:48:12 * EvanR laughtrack
18:49:51 <jle`> i made a monad to manage correlated random/experimental values
18:49:52 <jmcarthur> Cale: i feel a bit better now https://github.com/ekmett/deque/blob/master/Data/Deque/Cat.hs
18:52:12 <shachaf> Occasionally people talk about that code in the other channel.
18:52:26 <shachaf> I'm mostly glad to have managed to avoid it so far.
18:53:01 <Cale> jmcarthur: hahahaha
18:56:46 <so> has anyone run halvm on ec2?
18:57:36 <fryguybob> mgsloan: Yes, that direction is much less problematic, but is still fraught with unexpected danger :D
18:57:53 <mgsloan> Indeed :)
18:58:17 <fryguybob> mgsloan: For instance, if you unsafeIOToSTM and use information from that action to make a decision about `retry` your thread may never wake up.
18:59:20 <mgsloan> Right, but that at least has very understandable semantics - you shouldn't do that unless you're sure some TVar that's already been read will be updated
19:01:01 <fryguybob> mgsloan: Well it gets less understandable when you compound it with transactions continuing to execute after seeing inconsistent state.  You can reach impossible code paths and that is difficult to reason about if you have unsafe around :D
19:01:48 <mgsloan> Ah, interesting!
19:02:24 <mgsloan> Unfortunately I gotta go, have an excellent friday / saturday everybody :D
19:02:34 <fryguybob> mgsloan: You too!
19:04:28 <lpaste> cjay revised â€œfoldl package missing (total) foldl1' equivalentâ€: â€œworking versionâ€ at http://lpaste.net/128116
19:07:35 <dgorbik_> What's the deal with Scotty's ScottyError?
19:07:37 <dgorbik_> No instance for (ScottyError e0) arising from a use of â€˜getâ€™
19:07:52 <dgorbik_> why do I have to explicitly specify a type for an error if I use ScottyT?
19:46:59 <derekv> there must be some more consise way to do this:    foldl1 (\(xd,x) (yd,y) -> if (xd<yd) then (xd,x) else (yd,y)) [ (1,[ 4,5,7]),(99,[1,4,3]) ]
19:50:03 <haasn> derekv: minimumBy (comparing fst) ?
19:51:07 <derekv> haasn: lemme try
19:54:30 <edwardk> Quick non-binding straw poll: In profunctors, I've had something I've wanted to fix for a while, UpStar and DownStar follow the wrong convention.
19:54:39 <edwardk> Should I rename UpStar to Down and DownStar to Up?
19:54:47 <edwardk> Or should I rename DownStar to Star and UpStar to Costar. In this latter case you get instance Functor f => Representable (Star f)  and instance Functor f => Corepresentable (Costar f) -- and Star is like Kleisli.
19:55:07 <edwardk> change is being contemplated for a profunctors-5
19:55:08 <haasn> edwardk: Potential conflict: â€œDownâ€ is used to re-order Ord in some submodule of â€˜baseâ€™
19:55:50 <Iceland_jack> > sortBy (comparing Down) "hello"
19:55:52 <lambdabot>  "ollhe"
19:55:53 <edwardk> haasn: that is the other objection to the former, but Down is buried in base pretty far down
19:56:30 <Iceland_jack> Down hasn't seen much use though 
19:56:41 <EvanR> down with down
19:57:34 <haasn> edwardk: Based purely on the names I would go for â€œStarâ€ and â€œCostarâ€, especially due to the symmetry with Representable and Corepresentable
19:57:58 <Iceland_jack> Down with the name of 'Down' :) up with 'Down'
19:58:02 <haasn> And â€œStarâ€ seems to carry some more meaning than simply â€œUpâ€
19:58:19 <haasn> (Why is it called â€œStarâ€?)
19:59:28 <edwardk> well, UpStar and DownStar have their roots in notation used in complex analysis and all over topology, etc. where f_* g_* = (fg)_*   and f^* g^* = (gf)^*  -- using _* for subscript star and ^* for superscript stars.
19:59:38 <edwardk> the piponi article on them flipped them and i copied it
19:59:50 <edwardk> and i didn't think about it until months later when it was set
19:59:57 * hackagebot process-streaming 0.6.9.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.9.0 (DanielDiazCarrete)
20:00:00 <edwardk> i'm sick of it and want to rip off the bandaid
20:01:27 <threestrikes> what does flattening a list mean
20:01:31 <jle`> it's okay i'll forgive dan
20:01:38 <edwardk> the upstar thing is basically like the conjugate transpose for matrices. B^* A^* = (AB)^*, while downstar acts more like elementwise conjugation, A_* B_* = (AB)_*
20:01:52 <jle`> threestrikes: do you mean something like [[1,2,3],[5,6]] => [1,2,3,5,6] ...?
20:02:13 <edwardk> jle`: yeah i figure he's allowed one mistake after all those years of being the infallible oracle of 'all that is cool' =)
20:02:28 <jle`> =)
20:02:51 <jle`> yeah the first thing everyone thinks when reading the docs for Data.Profunctor is why are down and up flipped
20:04:23 <threestrikes> jle: I think I understand what the author is trying to say now 
20:04:35 <derekv> haasn: closer, minimumBy helps some
20:04:48 <jle`> real talk though lmap being backwards still really unsettles me
20:05:26 <arkeet> what's backwards about it?
20:05:51 <jle`> lmap f g => g . f   , for functions
20:06:01 <arkeet> oh you're saying it should be flipped.
20:06:02 <haasn> derekv: What's the difference between my function and your function?
20:06:28 <shachaf> lmap should be flipped?
20:06:30 <arkeet> I think it's fine.
20:06:35 <derekv> I have do like this minimumBy (\x y -> compare (fst x) (fst y))
20:06:53 <arkeet> it's like contramap.
20:06:55 <derekv> haasn: unless comparing wasn't a typo and is a different thing i didn't find yet
20:06:58 <jle`> it just feels weird to me...i imagine something being "pre-applied", and i associate it with (. g)
20:06:59 <shachaf> lmap is good
20:07:07 <arkeet> it wasn't a typo.
20:07:08 <jle`> rmap f g = f . g
20:07:20 <haasn> derekv: comparing should be in Data.Ord
20:07:21 <shachaf> rmap = fmap. It's good.
20:07:23 <jle`> lmap f g = g . f
20:07:29 <shachaf> lmap is the same except on the other argument.
20:07:30 <jle`> it feels like i should be seeing `f` on the right hand side
20:07:39 <derekv> haasn: ah, found it thanks 
20:07:51 <jle`> seing it on the lef thand side of the g just kind of goes against my intuition about pre-application
20:08:05 <haasn> derekv: comparing fst = compare `on` fst
20:08:36 <shachaf> Then you must fix your intuition.
20:08:40 <arkeet> well I want to be able to wrote lmap f . lmap g
20:08:46 <jle`> but it's embedded deep in haskell idiom
20:08:51 <arkeet> (which equals lmap (g.f))
20:08:58 <jle`> to write (f . g) instead of (g >>> f)
20:09:12 <jle`> the thing "applied" first is on the right
20:09:14 <arkeet> maybe what you want is another operator.
20:09:30 <shachaf> Most often lmap isn't applied to functions.
20:09:37 <derekv> haasn: so awesome, thanks
20:09:39 <shachaf> Otherwise there wouldn't be a point.
20:10:16 <jle`> how about things that are both Profunctors and Categories
20:10:17 <haasn> Why not write (g . f) instead of (lmap f g) ?
20:10:25 <jle`> i'm talkinga bout non-functions
20:11:14 <jle`> if you do a lot of (f . g . h) stuff using categories, if you want to pre-apply q to the chain, you'd do lmap q (f . g . h)
20:11:18 <arkeet> I think in practice it would be more common to partially apply it to the function argument.
20:11:23 <arkeet> not the profunctor one.
20:11:29 <shachaf> Profunctors and categories are two different things.
20:11:45 <shachaf> I think most things that are one aren't the other.
20:11:59 <arkeet> why not let (<.) = flip lmap
20:12:05 <c_wraith> mealy is both!
20:12:07 <jle`> it's this intersection of the two that gives rise to weird things
20:12:08 <shachaf> I suppose the analogy is with left and right actions, or something.
20:12:24 <arkeet> so p <. (f . g) = (p <. f) <. g
20:12:28 <arkeet> etc
20:12:48 <jle`> no more operators, heh
20:13:04 <EvanR> <. and . look similar
20:13:17 <arkeet> precisely.
20:13:33 <shachaf> The flipped version only makes sense as an operator.
20:13:44 <shachaf> lmap (lmap p f) g?
20:13:55 <jle`> hm that would probably be true
20:14:27 <jle`> it might just be my narrow universe where most of my profunctor usage is with categories
20:14:39 <jle`> that clouds my opinion of lmap
20:14:47 <arkeet> lots of profunctors aren't categories.
20:15:09 <shachaf> They're pretty different things.
20:15:23 <jle`> they are different things, but in practice i usually work with things that are both
20:16:48 <jle`> narrow universe etc., i'll probably refrain from making too strong of a suggestion/opinion until i get a chance to work practically with non-cat profunctors :)
20:17:43 <Booboorocks998> what would be the type sig of: digitCount = (+) 1 . truncate . log10
20:17:49 <Booboorocks998> if log10 returns a Floating a
20:18:13 <arkeet> ask :t
20:18:23 <jle`> Booboorocks998: do you want us to tell you the answer, how you would ask ghc to find it for you, or how you would do it by hand?
20:19:12 <jle`> it also depends on what log10 takes as input
20:19:33 <Booboorocks998> I tried using :t on digitCount
20:19:39 <Booboorocks998> with both 10 and 10.0
20:19:47 <Booboorocks998> and it says integer for both
20:19:53 <arkeet> try it with no arguments
20:20:19 <Booboorocks998> !
20:20:24 <jle`> ie, :t digitCount
20:20:49 <Booboorocks998> welp problem solved
20:21:02 <Booboorocks998> I wasn't aware you could do it with no arguments
20:21:12 <Booboorocks998> and it would still give you useful info
20:21:22 <jle`> all functions in haskell are values too
20:21:22 <EvanR> :t (+)
20:21:23 <lambdabot> Num a => a -> a -> a
20:21:37 <EvanR> :t takes expressions (rather than values)
20:21:38 <lambdabot>     Not in scope: â€˜takesâ€™
20:21:38 <lambdabot>     Perhaps you meant one of these:
20:21:38 <lambdabot>       â€˜takeâ€™ (imported from Data.List),
20:21:46 <jle`> (1 + 3) is just as much of a value as (+), or (+) 1
20:21:56 <arkeet> digitCount wasn't even defined as a function.
20:21:56 <shachaf> If your thing is both a Profunctor and a Category, you can define arr for it, :: (a -> b) -> p a b
20:22:08 <jle`> so everything that works with values should work with functions
20:22:16 <arkeet> just add Strong and you get an Arrow.
20:22:28 <jle`> everything that works with any value will also work with any function
20:22:39 <EvanR> everything that works with expressions should work with expressions that evaluate to functions
20:23:18 <shachaf> Then you can use (. arr f) and (arr f .) instead of lmap and rmap, presumably.
20:23:20 <shachaf> I don't know.
20:23:46 <jle`> oh that's neat
20:24:04 <shachaf> There's actually no reason to expect that to work.
20:24:07 <shachaf> Is there?
20:24:22 <shachaf> Maybe there is because of parametricity.
20:24:58 * hackagebot dotgen 0.4.2 - A simple interface for building .dot graph files.  http://hackage.haskell.org/package/dotgen-0.4.2 (ryanglscott)
20:25:24 <jle`> arr f . g would be (rmap f id) . g ....
20:25:34 <jle`> trying to make the last step to rmap f (id . g) = rmap f g
20:25:42 <derekv> haasn: minimumBy with comparing allowed me to collapse down my whole function not just the part I pasted in =]
20:25:44 <jle`> *thats arrP
20:26:34 <jle`> i'm not sure if you're allowed to go from (rmap f id) . g to rmap f (id . g) without some laws of interaction between profunctor and category
20:29:24 <shachaf> Oh, of course it's fine.
20:29:30 <derekv> was foldl1 (\(xd,x) (yd,y) -> if (xd<yd) then (xd,x) else (yd,y)) $ map (\(x,s) -> (abs $ k - x,s)) $ map (\x -> (sum x, x)) $ subsequences m     and is now   minimumBy (comparing (abs . (-) k . sum)) $ subsequences m
20:30:34 <EvanR> (-) k is the same as (k -)
20:30:51 <EvanR> fyi
20:31:07 <derekv> EvanR: Yup I forget, thanks
20:31:36 <EvanR> (- k) is negate k
20:31:38 <c_wraith> :t (-5+)
20:31:39 <lambdabot> Num a => a -> a
20:32:04 <EvanR> mmm unary plus
20:32:27 <Iceland_jack> â€œThe magic wandâ€ :)
20:38:06 <bydo> l/quit
20:56:41 <kloplop321> Can someone help me understand how I can make type families encode other properties? Here's some code to set some context (and that can be played with) http://lpaste.net/128134
20:58:36 <haasn> derekv: Caveat: minimumBy (comparing f) will recompute â€˜fâ€™ more often than once per input
21:00:04 <haasn> derekv: (But it should only be slower by a factor 2 or so)
21:00:56 <derekv> haasn: i think the kicker here is subsequences
21:01:35 <derekv> i was just thinking there should be some easy way to do it more quickly if m will only have positive numbers
21:01:49 <haasn> And if that does turn out to be an undesirable property, you can easily avoid it by using tuples again: snd . minimumBy (comparing fst) . map (\x -> (x, f x))
21:03:17 <haasn> derekv: Sure. If the numbers are only positive, then map sum (sequences m) will be monotonically increasing
21:03:23 <haasn> subsequences*
21:03:31 <derekv> yea
21:03:38 <haasn> Oh, that's not true
21:03:41 <haasn> I was thinking of tails, not subsequences
21:04:00 <derekv> yea but basically there's the principle that it can only grow larger
21:04:01 <haasn> (Or inits, rather)
21:04:10 <derekv> sum, that is
21:04:36 <derekv> so if your summing a subsequence and you overshoot the smallest difference already, you can stop
21:04:44 <haasn> derekv: I think the property you're looking for is that every number must be greater than (or equal to) the sum of all numbers before it, in the initial list
21:05:52 <haasn> What series of numbers does that generate, actually? 1 1 2 4 8 16 for the >= case, which makes sense I guess
21:06:11 <haasn> 1 2 4 8 16 ... for the > case
21:06:39 <haasn> Rough guess: If every number is >= double the number before it, then map sum . subsequences is monotonically increasing
21:06:50 <derekv> well, if your curious, someone sent me this and asked that I show how to do it in a functional language, but I only did the bruteforce method and I missed the part about max size being 4, but thats trivial https://stackoverflow.com/questions/19572043/given-a-target-sum-and-a-set-of-integers-find-the-closest-subset-of-numbers-tha 
21:06:51 <haasn> derekv: There's probably an easier way to get the list of subsequencies in a way that's monotonically increasing, though
21:07:56 <haasn> derekv: If you can sort the initial list, you can take subsequences in a way that's different than â€˜subsequencesâ€™
21:09:07 <derekv> i wonder if it might help to sort by absolute value, and then create and index of pairs/triples etc that sum to numbers that fit inbetween the numbers that are there
21:09:46 <derekv> like creating an index of interesting sequences that can be composed, since he says he's OK with an approximate answer 
21:10:36 <derekv> idk it was just for fun, time for bed
21:11:22 <haasn> derekv: This is suspiciously similar to the (NP-hard) knapsack problem
21:11:58 <haasn> The twist is that we want the best approximation in case no solution exists
21:12:13 <haasn> But I don't think that's enough of a twist to make it solvable in polynomial time
21:12:33 <haasn> As for the non-polynomial solution, iterating over subsequences is probably the best you're going to get.
21:14:21 <derekv> haasn: agreed it's a varient of knapsack, seems like
21:16:42 <haasn> derekv: Thinking about it this way: Suppose this problem was solvable in polynomial time. If so, then we could solve the knapsack problem in polynomial time by solving this problem followed by an O(1) check to see if the solution's sum is equal to k or not
21:16:58 <haasn> So this can't be done in polynomial time
21:17:51 <EvanR> O(1) equality test of numbers? ;)
21:17:56 <EvanR> impressive
21:18:09 <c_wraith> haasn: err.  Who says you can't solve the knapsack problem in polynomial time? :P
21:18:21 <c_wraith> I mean, I'm pretty sure you can't, but no one's proven it.
21:18:46 <haasn> c_wraith: Oh, right. Assuming P=NP. :)
21:18:49 <haasn> â‰ 
21:20:19 <haasn> EvanR: The difference is already an inherent part of the algorithm, you just need to store (and check) whether it's â€œ0 or notâ€ :)
21:20:44 <EvanR> ah
21:23:02 <pavonia> Are there any sets of exercises on type-level programming in Haskell, primarily on type/data families?
21:25:49 <enthropy> pavonia: implement Data.List?
21:26:52 <pavonia> With the various functions on it you mean?
21:28:23 <enthropy> right type family SplitAt (n :: Nat) (xs :: [k]) :: '([k],[k]) -- for example
21:30:27 <pavonia> Hhm, I guess re-implementing parts of the Prelude in general is a good idea
21:32:53 <enthropy> you could figure out why http://code.haskell.org/HList/Data/HList/HCurry.hs doesn't work with the ghc-7.10 RC
21:33:13 <enthropy> but I guess an exercise has to have a solution
21:34:44 <pavonia> Uh, that's type class programming
21:34:59 <enthropy> there are type families in there
21:35:52 <enthropy> I guess not in that particular module, but some defined elsewhere get used
21:37:04 <pavonia> I haven't used them for some years, I need something simple first to resume
21:41:56 <funfunctor> is there a list function that does :: [a] -> a -> a  where the list is two elements?
21:42:08 <funfunctor> @hoogle [a] -> a -> a
21:42:10 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:42:10 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
21:42:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
21:42:51 <kadoban> Is 'repa' still a currently used thing, or has it been obsoleted?
21:43:25 <funfunctor> kadoban: I think accelerate is the framework these days?
21:43:58 <pavonia> funfunctor: What would that function do?
21:45:13 <funfunctor> pavonia: [a] !! 0 and [a] !! 1
21:45:26 <funfunctor> so split the list into its two elements
21:46:00 <roboguy_> funfunctor: wouldn't that be more like [a] -> (a, a)?
21:46:02 <kadoban> funfunctor: Any idea if it's actually any good without the CUDA backend?
21:47:04 <funfunctor> kadoban: i'm not sure, I don't know enough about it.. i've only gone the LLVM way so far
21:47:17 <funfunctor> @hoogle [a] -> (a,a)
21:47:18 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
21:47:18 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
21:47:18 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
21:47:19 <kadoban> Okay, thanks. I'll take a look at it
21:47:44 <pavonia> > head &&& (head . head) $ "abc"
21:47:45 <funfunctor> roboguy_: it does not matter
21:47:46 <lambdabot>  Couldn't match type â€˜GHC.Types.Charâ€™ with â€˜[c']â€™
21:47:46 <lambdabot>  Expected type: [GHC.Types.Char] -> ([c'], c')
21:47:46 <lambdabot>    Actual type: [[c']] -> ([c'], c')
21:47:55 <roboguy_> funfunctor: ?
21:48:23 <funfunctor> I just did ++ show (v !! 0) ++ " " ++ show (v !! 1)
21:48:35 <funfunctor> I was just wondering if it existed
21:48:38 <roboguy_> oh
21:49:42 <jle`> funfunctor: what does the second a input do?
21:50:01 <pavonia> > unwords . map show $ [1, 2]
21:50:03 <lambdabot>  "1 2"
21:50:25 <funfunctor> :t unwords
21:50:25 <lambdabot> [String] -> String
21:50:46 <roboguy_> funfunctor: I thought you meant the *type* doesn't matter
21:50:52 <funfunctor> pavonia: thx, I like that one
21:51:07 <funfunctor> roboguy_: ah no sorry :)
21:52:05 <nitrix> :t <|>
21:52:06 <lambdabot> parse error on input â€˜<|>â€™
21:52:09 <nitrix> :t (<|>)
21:52:10 <lambdabot> Alternative f => f a -> f a -> f a
21:52:24 <nitrix> The heck is the point of this?
21:52:46 <nitrix> > Just 2 <|> Just 3
21:52:47 <lambdabot>  Just 2
21:52:56 <pavonia> It's used frequently with parsing combinators
21:52:59 <nitrix> > Nothing <|> Just 3
21:53:01 <lambdabot>  Just 3
21:53:06 <nitrix> Ah, I get it.
21:53:24 <dgc137> kinda like a defined-or?
21:53:42 <haasn> dgc137: This is only the Maybe instance
21:54:05 <nitrix> pavonia: I'm looking at Snap :)
21:54:23 <haasn> dgc137: There are no actual semantics on (<|>) other than that it's a monoid
21:54:27 <haasn> (empty is the identity)
21:55:02 <haasn> But it's typically used as a sort of â€œfallback in case of failureâ€-type Monoid.
21:56:55 <dgc137> so, I have what I think is a ridiculously simple question regarding IO
21:57:23 <dgc137> I'm trying to tail recurse over the elements inside an IO [(String,String)]
21:58:11 <dgc137> and I can't figure out the syntax to make that happen
21:58:19 <haasn> dgc137: What does â€œtail recurseâ€ mean?
21:59:16 <dgc137> haasn: I need to evaluate each tuple against a value; it's basically a dictionary lookup
22:00:18 <dgc137> I want to reduce to the second tuple member of the first pattern match against a seed value
22:00:57 <dgc137> I am brand new to haskell so I appologize if my terminology is broken
22:01:09 <haasn> :t lookup
22:01:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:01:12 <haasn> Does this help?
22:01:47 <haasn> :t \x k -> x >>= lookup k
22:01:49 <lambdabot> Eq a => Maybe [(a, b)] -> a -> Maybe b
22:01:49 <dgc137> maybe, how do I extract the [] from IO?
22:01:54 <haasn> You don't
22:02:11 <haasn> You lift the operation you want to perform into the IO action instead
22:02:15 <haasn> :t (>>=)
22:02:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:02:19 <ion> :t fmap
22:02:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:02:45 <haasn> :t \x k -> fmap (lookup k) x -- this is what I meant earlier
22:02:46 <lambdabot> (Functor f, Eq a) => f [(a, b)] -> a -> f (Maybe b)
22:03:08 <dgc137> oooo
22:27:30 <nocturne777> do most people implement monads in terms of functors using the fact that "m >>= f" is equivalent to "join( fmap f m)"
22:29:00 <nocturne777> ?
22:29:48 <jle`> as in writing the instance?
22:31:12 <nocturne777> jle`: yeap
22:31:23 <funfunctor> do notation?
22:32:14 <nocturne777> here http://goo.gl/858wp
22:32:53 <jle`> for me i usually write (>>=) directly
22:32:57 <jle`> or use Free
22:33:13 <nocturne777> author implments the monad using the join ( fmap f m) relationship
22:33:38 <roger__> Having an odd problem where my program seems to work when run from GHCI but hangs from GHC. Anyone know what could be the issue there?
22:33:52 <nocturne777> jle`: what's "Free"?
22:33:58 <jle`> in real code, (>>=) is used more than `join`, so here are some efficiency benefits
22:34:42 <nocturne777> jle`: so it is more efficient to write it without the join ?
22:34:51 <johnw> nocturne777: imagine if, instead of bind doing something, all it did was record the fact that a bind had been done, so that later you can traverse this AST of binds (and a return), and decide what to do then.  That is Free
22:35:05 * hackagebot th-instance-reification 0.1.3 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.3 (NikitaVolkov)
22:35:15 <johnw> instead of the constructors being called Return and Join (which they could have been), they are called Pure and Free
22:36:43 <shachaf> Free doesn't give you an AST of Monad operations, it gives you a quotiented AST.
22:36:54 <johnw> shachaf: can you please clarify?
22:37:04 <shachaf> x >>= return = x
22:38:07 <nocturne777> jle`: every monad is also a functor. so do you usually make a data type also an instance of  Functor if you decide to make it an instance of Monad ?
22:38:25 <johnw> shachaf: well, I'll be, thank you for that
22:38:35 <johnw> > (return 1 :: Free Identity Int) >>= return
22:38:36 <jle`> nocturne777: yes
22:38:37 <lambdabot>  Not in scope: type constructor or class â€˜Freeâ€™
22:38:37 <lambdabot>  Perhaps you meant â€˜Treeâ€™ (imported from Data.Tree)
22:38:42 <johnw> Pure 1
22:38:44 <jle`> in the new version of GHC, you'll actually be required to
22:39:42 <ProofTechnique> @hoogle m (m (m a)) -> m a
22:39:49 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
22:39:49 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
22:39:49 <lambdabot> Prelude concat :: [[a]] -> [a]
22:40:00 <shachaf> Similarly [A] is a free monoid but x ++ [] = x
22:40:01 <jle`> even today it's expected that if you see something with a Monad instance, it'll also have a Functor instance.  in a few months, it'll be enforced by ghc
22:40:03 <nocturne777> jle`: so, in thise case you implement them seperately ? I like that author is sort of simplifying things by relying on "m>>=f  === join (fmap f m) 
22:40:13 <nocturne777> you end up writing less code
22:40:18 <johnw> I suppose that's another way of saying that the monad laws apply to the Free object, otherwise it would be a lawless AST
22:40:33 <nocturne777> jle`: yes, I see the warnings about this in ghci
22:40:37 <jle`> nocturne777: writing the code for `join` is probably about as involved as writing the code for `>>=` directly
22:42:07 <shachaf> Writing join is simpler than writing (>>=), but writing (>>=) is simpler than writing both fmap and join.
22:44:14 <nocturne777> shachaf: so better to define (>>=) and fmap seperately and not deal with join at all?
22:45:00 <glguy> There isn't necessarily a universal answer to this
22:45:05 * hackagebot objective 1.0.3 - Extensible objects  http://hackage.haskell.org/package/objective-1.0.3 (FumiakiKinoshita)
22:47:47 <shachaf> Better to do what works for you.
22:48:01 <shachaf> join isn't a method of Monad, so if you define it, you'll have to call it something else.
22:48:19 <nocturne777> yes, something like "flatten"
22:49:01 <nocturne777> I will try both approaches, see which one I like better
22:55:11 <vin-ivar> gah, the source install doesn't have an uninstall target
22:55:13 <vin-ivar> T_T
23:02:10 <haskell854> I am trying to code an expression evaluator, which saves state of the expression in (Int,[String]) where [String] is a  a list of eg . ["Var", "Plus", "Value"] . Sorry I am using this chat for the first time and I dont knoew how I should be asking a question 
23:03:07 <ProofTechnique> Directly?
23:03:17 <haskell854> This is how I tried coding aEval2 :: AExp -> State Int Int aEval2 (Value v)        =   get >>= \x -> put (x + 1) >> return v aEval2 (Var k)          =  get >>=                                 \x -> put(x+1) >>                                                (return . fromJust . Map.lookup k $ currEnv) aEval2 (Plus ax1 ax2)   =  do                               modify (+1)                               val1 <- aEval2 ax1          
23:03:25 <ProofTechnique> @where paste
23:03:25 <lambdabot> Haskell pastebin: http://lpaste.net/
23:03:30 <ProofTechnique> haskell854: ^
23:03:30 <haskell854> for State Int Int
23:03:36 <haasn> shachaf: What about writing join + using DeriveFunctor for fmap?
23:03:58 <haskell854> I kind of need to use State Monad
23:04:26 * haasn .oO( If you â€œneedâ€ to use the State monad, then you don't understand the State monad )
23:05:40 <haskell854> http://lpaste.net/7356097789027155968
23:06:03 <ProofTechnique> haskell854: And what is the problem?
23:06:12 <haskell854> I know I am weak considering Monads
23:06:43 <haskell854> I racked my brain a lot since more than a day
23:07:06 <haskell854> Even if I could get a hint is enough
23:07:13 <ProofTechnique> What is your question, though?
23:07:40 <shachaf> haasn: Sounds plausible.
23:08:15 <haskell854> Yes . So I am supposed to be changing the format of aEval2 function to AExp -> State [String] Int
23:08:52 <haskell854> where [String] would contain ["Value" , "Plus","Var"]
23:10:16 <haskell854> if given an input say (Plus (Var "X") (Value 2)) it should be giving back (4,["Value" , "Plus","Var"])
23:10:51 <haasn> shachaf: That said, I think the most compelling reasons to write things directly rather than finding some â€œcheapâ€ way to define them is performance.
23:12:04 <haskell854> Even a hint to do something someway would do
23:12:12 <shachaf> If only join was in Monad.
23:13:11 <nocturne777> is there a tool that checks whether a monad obeys all three laws ?
23:13:14 <ProofTechnique> haskell854: What is it giving you now?
23:13:25 <ProofTechnique> nocturne777: Math?
23:13:54 <nocturne777> ProofTechnique: yes, it can be done on a piece of paper
23:14:31 <nocturne777> to speed up development, I was wondering if quickcheck or smth like that could do that for me
23:14:41 <ProofTechnique> You might be able to write QuickCheck properties for some instances.
23:15:58 <ProofTechnique> nocturne777: http://www.austinrochford.com/posts/2014-05-27-quickcheck-laws.html
23:16:32 <nocturne777> I like that
23:17:04 <ProofTechnique> I expect there are places where it blows up, but that's life.
23:19:56 <haskell854> This is a function to give (Addition of Variables and or Values,previous state + input value) for input like runState (aEval2 (Plus (Var 'X') (Value 2)) 1  gives (4,4)
23:29:54 <jle`> traversable is such a powerful abstraction
23:30:45 <haasn> Lenses are such a powerful abstraction, too
23:30:48 <ProofTechnique> An EDAL
23:30:58 <ProofTechnique> Embedded domain agnostic language
23:46:09 <shafox> what kind of applications/software can be build with haskell ? 
23:49:24 <pavonia> Haskell is a general purpose programming language
23:51:44 <shafox> yes can it be used whereas java/c/erlang is used before ? 
23:52:35 <pavonia> I think so
23:55:20 <pavonia> shafox: You could have a look at hackage.haskell.org to see the various fields it is used in
23:55:42 <shafox> thanks pavonia :)
23:56:22 <pavonia> No problem
