00:08:58 * hackagebot monadic-arrays 0.2.1.4 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.1.4 (EdwardKmett)
00:08:58 * hackagebot http-date 0.0.6 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.6 (KazuYamamoto)
00:13:52 * hackagebot dlist 0.7.1.1 - Difference lists  http://hackage.haskell.org/package/dlist-0.7.1.1 (SeanLeather)
00:28:23 <Ryanar> hey is anyone here?
00:28:40 <shachaf> A lot of people.
00:29:05 <Ryanar> :) I have a pretty simple question
00:29:29 <Ryanar> I am defining a function "mylast" which gets the last element of a list
00:29:55 <Ryanar> mylast xs = drop (length xs - 1)
00:30:25 <Ryanar> I feel like the type of this should be taking a list of xs, and returning a list with one element
00:30:40 <Ryanar> mylast :: [a] -> [a]
00:30:47 <arkeet> that is correct
00:30:54 <arkeet> wait.
00:31:04 <jle`> you might mean mylast xs = drop (length xs - 1) xs
00:31:06 <arkeet> yeah that.
00:31:16 <Ryanar> oh.
00:31:19 <Ryanar> that explains it
00:31:21 <arkeet> :)
00:31:40 <Ryanar> so
00:31:41 <jle`> notice that [a] -> [a] doesn't let you encode the invariant/guaruntee that the result list only has one element
00:31:53 <jle`> you can take advantage of the type system to give a type signature that does
00:31:55 <jle`> [a] -> a
00:32:06 <arkeet> jle`: the result list might have no elements!
00:32:20 <jle`> yeah :O but "last element of a list" is onyl defined for lists with at least one element anyway
00:32:32 <jle`> last [] should rightly be undefined
00:32:46 <Ryanar> so you are saying if I did [a] -> a instead
00:32:46 <jle`> it doesn't make sense to talk about a last element for an empty list :O
00:32:52 <Ryanar> it would guarantee that only one element is returned?
00:33:01 <arkeet> you would have to give a different definition for it to work.
00:33:04 <jle`> yes...if your list has at least one element
00:33:52 * hackagebot eddie 0.5.1 - Command line file filtering with haskell  http://hackage.haskell.org/package/eddie-0.5.1 (MikeMeyer)
00:34:13 <Ryanar> GHCi is telling me that it couldn't match the expected return [a] with what I listed as a
00:34:47 <Ryanar> is that because drop returns a list?
00:34:49 <arkeet> well yes, you didn't change any actual code.
00:34:50 <arkeet> yes
00:34:52 <shachaf> No, he's saying that he wants you to write a different function.
00:35:07 <Ryanar> That is what I thought, hah, got confused
00:35:24 <Ryanar> so a different function could be something like using !!
00:35:36 <arkeet> you could.
00:35:38 <jle`> mhm. but your function is no longer defined for all lists now
00:35:45 <arkeet> jle`: you're so demanding!
00:35:48 <jle`> which makes it less useful in this case
00:35:52 <jle`> *in most cases
00:35:59 <jle`> i want it all
00:36:17 <shachaf> I don't think that's very helpful.
00:36:29 <Ryanar> why isn't it defined for all lists?
00:36:36 <arkeet> consider the empty list
00:36:39 <jle`> it isn't defined for lists with no elements
00:36:59 <Ryanar> I thought we already agreed that we wwere just getting the last element of an extant list
00:37:10 <Ryanar> and that the empty list should be undefined
00:37:16 <Ryanar> oh no my battery is at 7%
00:37:22 <jle`> yes, so that means that your function is not defined for empty lists
00:37:32 <jle`> hence, mylast' [] = undefined :) not defined
00:37:36 <arkeet> there's not much you can do about that, with that type.
00:37:45 <Ryanar> so I need to pattern match mylast' [] = []
00:37:51 <Ryanar> oh
00:37:53 <Ryanar> actually
00:37:53 <Ryanar> yeah
00:37:55 <Ryanar> I see what you mean
00:38:01 <Ryanar> my computer might die
00:38:03 <Ryanar> in a moment here
00:38:17 <arkeet> [] has the wrong type though, if you want [a] -> a.
00:38:28 <Ryanar> but thank you for the help you guys if it does
00:38:40 <arkeet> there is yet another option.
00:38:46 <Ryanar> what is that?
00:38:52 <arkeet> have the return type essentially be a list with at most one element.
00:38:55 <arkeet> i.e. a Maybe
00:38:59 <jle`> your implementation before was good for your type, [a] -> [a]. this is just a little exercise to sort of see that you can express the invariants that ghc enforces in your code by just changing the type signature of what you want :)
00:39:03 <Ryanar> Ah, yeah the maybe
00:39:06 <arkeet> so, type [a] -> Maybe a
00:39:30 <Ryanar> so if it is one element it will say "Just a"
00:39:33 <Ryanar> otherwise Nothing
00:39:36 <arkeet> there is also the other issue of having an efficient implementation.
00:39:38 <shachaf> How do you write last :: [a] -> Maybe a efficiently?
00:39:39 <arkeet> right.
00:39:39 <jle`> [a] -> a says "the result can only have one element."  [a] -> Maybe a says "the result can have 0 or 1 elements".  [a] -> [a] says "the result can have 0, 1, or...well, any amount."
00:40:17 <Ryanar> jle`, Understood
00:40:28 <jle`> if you're writing a function that you want to say, "my thing only returns 0 or 1 elements", then you can etiher convey it through documentaiton, or you can convey it through types
00:40:29 <Ryanar> jle`, I can see why its kind of a bad use of the type enforcing
00:40:46 <Ryanar> jle`, which the preference is through types of course
00:40:52 <Ryanar> jle`, especially in Haskell
00:40:57 <jle`> documentation as in: "the returned list can only have 0 or 1 elements!"; the types as in, returning Maybe a
00:41:07 <jle`> well, there are some practical reasons too
00:41:22 <jle`> GHC can statically prove that `[a] -> Maybe a` can only have 0 or 1 elements
00:41:28 <jle`> (provided you don't do anything crazy)
00:41:46 <jle`> ghc can't statically prove that [a] -> [a] can only have 0 or 1 elements....so implementations that ar e[a] -> [a], but return more, will still typecheck
00:41:50 <jle`> you won't see the bug until runtime :O
00:41:59 <Ryanar> gotcha
00:42:25 <Ryanar> so what would be an efficient way to get the last element of a list
00:42:32 <Ryanar> if drop isn't efficient
00:42:39 <shachaf> You can write last' = go Nothing where go _ (x:xs) = go (Just x) xs; go m [] = m
00:42:42 <arkeet> the reason drop (length xs - 1) xs is inefficient
00:42:44 <shachaf> But that'll allocate a lot.
00:42:48 <arkeet> is because it has to walk the entire list to get the length
00:42:52 <arkeet> and then walk it again to get at the last element
00:42:58 <Ryanar> ah I see
00:43:09 <shachaf> If you had unboxed sums you could do better easily, but what otherwise?
00:43:16 <arkeet> in particular, it has to hold the entire list structure in memory.
00:43:45 <Ryanar> so if I just kept taking the first element off hte list
00:43:48 <Ryanar> recursively
00:43:52 <Ryanar> until I got to the last one
00:43:57 <Ryanar> then I dont have to remember the whole list
00:44:00 <arkeet> yup
00:44:07 <Ryanar> heh
00:44:13 <Ryanar> jeez its so hard switching to this style of thinking
00:44:19 <Ryanar> once you prod me I get there
00:44:21 <arkeet> :)
00:44:35 <jle`> it's a fun journey :D
00:44:36 <shachaf> Is there a nicer way to write last'?
00:44:43 <Ryanar> ok my computer is about to die, thanks so much for the help jle`, shachaf and arkeet
00:44:46 <forgottenone> how creating a new function works internaly e.g. newFunc in this example?define x = newFunc where newFunc y = x+y
00:44:50 <arkeet> np
00:45:04 <shachaf> forgottenone: Exactly like that.
00:45:21 <jle`> np!
00:45:32 <shachaf> p
00:45:59 <jle`> same thing
00:46:48 <forgottenone> shachaf i mean how it stored as internally, does newFunc compiled as a two parameter function and uses x as one argument or something else
00:47:05 <shachaf> Oh, I see.
00:47:21 <shachaf> For a good answer you should read the STG paper.
00:47:23 <shachaf> @where stg
00:47:23 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
00:48:34 <forgottenone> shachaf thanks i will read it when i have time, i hope i understand it :D
00:50:21 <shachaf> You don't need to read the whole thing. It talks about it pretty early on.
00:50:39 <augur> uh oh
00:50:46 <augur> i found a bug in aeson :x
00:50:57 <augur> at least the version im running
00:55:45 <augur> specifically: if you have a record type, you cannot have a field named "tag"
00:56:28 <augur> this could easily be fixed tho by treating record tags like non-record tags and having { "tag": <tag>, "values": <fields> }
01:19:43 <brbblnch> Hi
01:19:54 <cymen__> Would somebody mind telling me what's wrong with this code: https://ideone.com/N1dZ2W - Trying to do exercises from rwh.
01:21:32 <shachaf> What does GHC say is wrong with it?
01:21:50 <brbblnch> cymen: If you put parenthesis around "sum count" it doesn't give the error anymore
01:22:13 <shachaf> There's a "-- your code goes here" without any code in it.
01:22:19 <brbblnch> Anybody here is comfortable with the normalization theorem on simply typed lambda calculus?
01:22:22 <shachaf> brbblnch: That's almost certainly not true.
01:22:32 <shachaf> (sum count) is not a pattern.
01:22:38 <brbblnch> schachaf: yea
01:22:46 <brbblnch> schachaf: sorry
01:23:26 <cymen__> shachaf: i't doesn't compile so i haven't bothered calling anything yet
01:23:48 <cymen__> somehow i got the syntax in the mymean function wrong, i tried copying the pluralize function
01:23:56 <shachaf> OK, but "main = -- ..." is a syntax error anyway.
01:23:57 <cymen__> and I can't find the difference :p
01:24:34 <shachaf> Anyway you still haven't posted the error.
01:25:12 <cymen__> shachaf: You realize that site has a compiler? :)
01:25:13 <cymen__> prog.hs:10:43: parse error on input `='
01:25:50 <shachaf> Oh, there is an error listed right below. OK.
01:25:58 <arkeet> you have tab characters in your code.
01:26:16 <shachaf> All the websites that show ads around the code have trained me not to look around the little gray box.
01:26:27 <cymen__> awww man.....
01:26:31 <cymen__> tabs, srsly
01:26:47 <cymen__> even checked the editor settings to make sure they are replaced :(
01:27:12 <cymen__> arkeet: thx
01:27:23 <arkeet> try using an editor that displays tab characters.
01:29:52 <tdammers> shachaf: y u no adblock?
01:30:52 <tdammers> (anyway: sed -i -e's/\\t/    /g' filename)
01:30:57 <tdammers> sth like that
01:31:12 <arkeet> or :retab
01:32:19 <tdammers> vim?
01:32:26 <tdammers> vim can do it in a dozen different ways
01:32:57 <tdammers> :set expandtab, then reindent everything :D
01:33:01 <arkeet> well that regex won't do anything about tabs that aren't aligned with tab stops.
01:33:06 <arkeet> correctly, anyway.
01:33:37 <arkeet> (the above code had two spaces followed by a tab in one line.)
01:33:40 <tdammers> if there are tabs in the middle of a line, then we're talking full armageddon anyway, and all hope for humanity is lost
01:33:54 * hackagebot scientific 0.3.3.8 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.8 (BasVanDijk)
01:50:17 <simg> hi, I've been struggling with digestive-functors and multiple file uploads (using snap) for a couple of weeks. I'm getting somewhere slowly but I'm now stuck and could do with some help. I've documented the specific problem I'm having (with example code) as a github issue because I think the answer will be significantly helpful to other digestive-functors noobs. https://github.com/jaspervdj/digest
01:50:19 <simg> ive-functors/issues/111       any suggestions appreciated :)
01:50:31 <simg> that link again ... https://github.com/jaspervdj/digestive-functors/issues/111
01:53:54 <L8D> is this a good place to ask for opinions and suggestions on language design?
02:18:55 * hackagebot pretty 1.1.3.2 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.3.2 (DavidTerei)
02:21:45 <simg> will be afk for the next hour or so, but if anyone did have any comments on https://github.com/jaspervdj/digestive-functors/issues/111 I'll read / reply when I get back.
02:23:55 * hackagebot mandrill 0.2.1.0 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.2.1.0 (AlfredoDiNapoli)
02:24:41 <frerich> L8D: There's a whole bunch of people with strong opinions on language design here, but in general I'd try to avoid primaily opinion-based questions in a room with about 1500 people.
02:31:01 <Javran> is there a way to let "cabal exec" use a specified sandbox?
02:32:06 <alpounet> it'll use "the current one", which is specified in the cabal.sandbox.config file, smth like that, iirc
02:32:36 <alpounet> cabal sandbox init to create a new one, cabal sandbox init --sandbox /path/to/.cabal-sandbox to use an existing one
02:33:26 <Javran> not feeling comfortable creating some extra files though
02:33:41 <Javran> but anyway this should work
03:03:55 * hackagebot OpenSCAD 0.2.1.0 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.2.1.0 (MikeMeyer)
03:04:19 <sigrlami>  Does anybody know some third-party service that provide embedding haskell code with evaluation like in FP Complete - School of Haskell?
03:04:30 <sigrlami> I have static website and don't want migrate to bigger framework like Yesod to do this, but want to make site mote interactive
03:04:42 <sigrlami> maybe some yesod-package to run on server but alone from static site
03:11:31 <vlkm> Hi there, learning Haskell, trying to use the libtagc package, functions in Audio.TagLib.TagLib return IO (Maybe a) - so my main function works in IO monad, which takes care of the IO part - now how do I elegantly chain together the Maybe values without pattern matching on Just/Nothing or doing if-then-else?
03:13:52 <bergmark> @type MaybeT
03:13:53 <lambdabot> Not in scope: data constructor ‘MaybeT’
03:14:08 <bergmark> :( vlkm: MaybeT :: m (Maybe a) -> MaybeT m a
03:18:27 <vlkm> right, so monad transformer
03:24:00 <jle`> vlkm: mhm, it basically just is a newtype wrapper that gives you a convenient (>>=) implementation
03:24:00 <solrize> @pl \f x y -> g (h x y)
03:24:01 <lambdabot> const ((g .) . h)
03:24:28 <jle`> vlkm: you might have seen newtype wrappers to give convenient multiple instances before... like the various Monoid ones (Sum, Product)
03:24:31 <solrize> @pl \x y -> g (h x y)
03:24:31 <lambdabot> (g .) . h
03:24:53 <jle`> MaybeT gives you a (IO (Maybe a)) -> (a -> IO (Maybe b)) -> IO (Maybe b)
03:25:13 <jle`> at least, MaybeT IO does.
03:25:36 <jle`> it gives you a new (>>=) that respects Maybeness...and short circuits when there's nothing to chain from
03:26:03 <vlkm> ok, I get it
03:26:21 <vlkm> though how do I apply that in my case?
03:26:27 <vlkm> sample code:
03:27:18 <vlkm> import qualified Audio.TagLib.TagLib as TL
03:27:18 <vlkm> main = do
03:27:18 <vlkm>   f <- TL.tagFileOpen testFileName
03:27:18 <vlkm>   t <- TL.tagFileGetTag f
03:27:18 <vlkm>   s <- TL.tagGetTitle t
03:27:18 <vlkm>   putStrLn maybe s
03:27:40 <vlkm> this won't typecheck because return values are wqrapped in Maybe
03:27:49 <{AS}> Hi
03:27:50 <vlkm> not clear to me how to apply MaybeT
03:28:12 <frerich> Heh, cool. People are using taglib.
03:28:19 <vlkm> :-)
03:29:01 <jle`> runMaybeT $ do { f <- MaybeT (TL.tagFileOpen testFileName); t <- MaybeT (TL.tagFileGetTag f); s <- MaybeT (TL.tagGetTitle t); liftIO $ printLn s }
03:29:04 <{AS}> Does anybody know if there is a reason why you cannot customize deriving in Haskell? For example, if I have a large datatype where I have an function or something that cannot derive Eq somewhere.
03:29:38 <jle`> the newtype wrappers are kind like line noise, but...that should work
03:29:44 <{AS}> or rather how to :)
03:30:12 <jle`> they fill the same place as getProduct (mconcat [Product 2, Product 3, Product 5])
03:30:41 <jle`> er, `getProduct $ Product 2 <> Product 3 <> Product 5` might be more analogous
03:31:20 <jle`> {AS}: what kind of mechanism of customization would you expect?
03:32:30 <{AS}> jle`: Maybe something that allows me to annotate constructor with custom handlers, or perform some default action
03:32:48 <{AS}> In a sense anything that allows me to plug-in in the deriving mechanism for some specific constructors
03:33:01 <{AS}> plug-in my own functionality 
03:34:05 <{AS}> Now if I have to customize the case for 1 constructor, I have to manually implement the steps for all other n-1 constructors which is a bit laborious :)
03:34:34 <{AS}> and potentially error introducing
03:36:52 <indiagreen> {AS}: no, we simply don't have this currently. You *probably* can get close with generics, tho.
03:37:19 <{AS}> indiagreen: OK, thanks. what do you suggest with regarding to generics?
03:37:46 <{AS}> Any references I could look at?
03:39:20 <{AS}> Also, if possible could anyone please point me at the procedure for suggesting feature requests?
03:40:24 <indiagreen> {AS}: I'm looking into it. I don't have much experience with generics, so I'm going to use this opportunity to learn.
03:40:43 <{AS}> indiagreen: OK, thanks :)
03:41:43 <vlkm> jle`, bergmark: thanks, trying this with MaybeT out here......
03:41:57 <indiagreen> The procedure for suggesting feature requests is... well, there's no procedure, but people usually make a thread on Haskell-cafe, and if nobody voices any good reasons why the feature shouldn't be implemented, a ticket is created on GHC Trac
03:42:33 <{AS}>  I know a bit of generic coding, but I am unsure if it is possible/how to get access to the "derivers"(deriving algorithms?) for various type classes
03:42:52 <{AS}> indiagreen: OK, many thanks 
03:44:00 <indiagreen> I don't think you can get access, but if you just want something simple like Eq, it really wouldn't be hard to implement by yourself. Also, you can use some option of GHC (I forgot, which) to dump the generated instance for you (which you can then modify and include into your code)
03:44:27 <indiagreen> finally, there are tools like Drift, which can derive instances independently of GHC, but I really never used one and so can't say anything
03:46:19 <{AS}> indiagreen: Ah, awesome
03:47:58 <{AS}> I wanted to avoid implementing things myself because I was working on some specific program where I needed the thing :), but it might be a good idea if I experience the need again.
03:48:53 <Saizan> a newtype would be the next low-tech solution, after just writing the full instance
03:49:49 <{AS}> Saizan: Yeah, I guess you are right :)
03:50:32 <indiagreen> Saizan: how would this be done? I mean, imagine “data X = A String | B Int | C (Bool -> Bool)” – how can you define an Eq instance for this using a newtype?
03:51:54 <{AS}> indiagreen: I think he means wrapping the function Bool -> Bool in a new type an define a small instance of Eq for that
03:52:27 <{AS}> and the you can use GND to get the rest you want to derive for it that is possible
03:54:23 <Saizan> yeah
03:54:31 <frerich> indiagreen: You could probably reduce the question to how to define a function '(==) :: (Bool -> Bool) -> (Bool -> Bool) -> Bool'
03:54:59 <Saizan> frerich: const (const True)!
03:56:05 <frerich> Saizan: There aren't many possible plausible implementations for 'Bool -> Bool', yeah. So with that in mind, you could define Eq.
03:56:14 <{AS}> Saizan: well it is decidable for that case so you can make something useful :)
03:56:30 <Saizan> meh, boring cases :)
03:56:53 <Saizan> it wasn't the point of the discussion anyway :)
04:07:59 <makalu> so I want my IO function to be usable from any stack that has IO at the base. I add MonadIO m constraint. I also want to throw exceptions so I need to add MonadThrow m (from 'exceptions'). Apart from using ConstraintKinds, is there a common solution to avoid having to write the long class constraint for each function?
04:10:18 <indiagreen> you can make a class without methods
04:11:00 <crispweed> hi there, having problems understanding some results in ghci
04:11:18 <crispweed> Prelude> import System.Random
04:11:32 <crispweed> Prelude System.Random> let gen = mkStdGen 4
04:11:49 <crispweed> Prelude System.Random> let (val, gen2) = random gen
04:12:04 <crispweed> gives No instance for (Random t0)
04:12:36 <crispweed> but I can do:
04:12:39 <Ferdirand> it doesn't know the type of the val you are asking for
04:12:40 <crispweed> Prelude System.Random> random gen
04:13:06 <crispweed> without any complaints
04:15:15 <crispweed> I'm actually trying to chase down why the getRandom example, in http://book.realworldhaskell.org/read/monads.html doesnt load into ghci
04:16:04 <Ferdirand> defaulting rules are weird
04:17:09 <indiagreen> {AS}: http://lpaste.net/127970
04:17:53 <{AS}> indiagreen: Great :)
04:19:23 <indiagreen> I don't like it, to be honest – there is generic “geq” in syb already, as well as “gread” and “gshow”, but they are unusable for adding special cases 
04:19:41 <{AS}> indiagreen: Yeah
04:19:53 <mrkkrp> Hello, I have a project that consists of lightweight executable on top of a library. Now I want to test the library, but `haskell-mode' doesn't see modules of the library (when I open tests/Main.hs), it says "Could not find ...". `cabal test' seems to compile the tests well. Do you know how to make `haskell-mode' recognize modules of my application-specific library?
04:23:31 <lpaste> “{AS}” pasted “Custom Eq” at http://lpaste.net/127971
04:23:38 <{AS}> indiagreen: ^
04:23:54 <{AS}> Something like that is what I prefer :)
04:25:15 <a3f> Foreign.C.String has a function peekCAString :: CString -> IO String, which doesn't support null strings unfortunately. I wrote some code to add this capability but I can't decide if the replacement should be peekCAString' :: CString -> Maybe (IO String) or peekCAString' :: CString -> IO (Maybe String)
04:25:45 <a3f> Maybe IO makes more sense, as there is no IO involved if the CString is nullPtr
04:27:32 <a3f> IO Maybe would be the least work though
04:27:52 <tdammers> IO Maybe would probably also be more convenient for the consumer
04:28:37 <a3f> Clarification: with null string I mean a null pointer not a null-terminated string
04:28:56 * hackagebot filepath 1.4.0.0 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.4.0.0 (NeilMitchell)
04:29:28 <a3f> tdammers: That's what I thought too, but I can't decide
04:29:42 <frerich> OT: sometimes I actually wish websites would cooperate with Google on serving targeted ads to me: http://i.imgur.com/oAr00Ja.png
04:30:30 <frerich> Depending on where you work, it may not be safe for work. ;-)
04:32:27 <tdammers> 2 days left on current job
04:32:30 * tdammers is clicking
04:37:50 <aubergines> join math
04:44:31 <Hafydd> frerich: what website does that ad link to?
04:45:47 <frerich> Hafydd : I don't know, I didn't click it :]
04:49:43 <a3f> Any other opinion on Maybe (IO a) vs IO (Maybe a) ?
04:50:15 <frerich> a3f: In my opinion the "versus" is strange because they are very different thing.
04:50:52 <frerich> a3f: If you can post some code giving some context, maybe it would be easier to say something useful.
04:51:00 <a3f> frerich: You are correct, let me paste what I wrote earlier: Foreign.C.String has a function peekCAString :: CString -> IO String, which doesn't support null strings unfortunately. I wrote some code to add this capability but I can't decide if the replacement should be peekCAString' :: CString -> Maybe (IO String) or peekCAString' :: CString -> IO (Maybe String)
04:51:23 <a3f> I wasn't too sure on how much time should pass, before one restates a question.
04:51:32 <indiagreen> can you decide whether to return “Nothing” or “Just something” without doing any IO?
04:52:06 <frerich> a3f: I'd definately go for 'IO (Mayb String)'. peekCAString still yields an IO action as before. The only thing you're adding is that the IO action *maybe* yields a string.
04:52:10 <a3f> indiagreen: yes, if it's a nullPtr I return Nothing directly
04:52:15 <Axman6> you can test a pointer for whether it's null without IO
04:52:17 <a3f> No IO is required
04:52:38 <shachaf> Possibly even better would be to disallow null pointers in the first place.
04:52:49 <indiagreen> hm... okay, well, actually I'd go with “IO (Maybe String)” in this case anyway, even tho it loses some freedom
04:52:56 <frerich> a3f: Wait, peekCAString does not need to perform any IO to tell whether 'CString' is a null pointer? then why was it 'IO String' in the first place?
04:52:58 <shachaf> I suppose that depends on the context.
04:52:59 <a3f> frerich: In the case of CString being nullPtr, no IO will be done.
04:53:10 <frerich> Ah
04:54:14 <a3f> shachaf: Take system(3) for example, system(NULL) checks for the availability of a command interpreter. Having only String means we lose the freedom to cleanly do System(NULL)
04:54:16 <theorbtwo> It sounds like perhaps you want to return Maybe (IO String), and have a little helper that returns IO (Maybe String) for when you want that instead?
04:54:50 <frerich> a3f: I think it would be useful to see how people usually use that function. As it is, they always gt an IO String, so I suppose for them it would be easier if it is 'IO (Maybe String)'
04:54:54 <Axman6> called "traverse"
04:54:55 <Axman6> >_>
04:55:04 <indiagreen> isn't it sequence?
04:55:07 <shachaf> Called sequenceA, but close enough.
04:55:14 <Hafydd> I see.
04:55:50 <Axman6> oh right
04:55:52 <a3f> theorbtwo: I am not sure what I want. I can implement the functions that depend on peekCAString either way, but as this will be a breaking change, it ought to be correct this time
04:56:06 <a3f> Not sure what is correcter though
04:56:24 <Axman6> I always forget traverse is more general, I always thing of the transposition as being a traversal
04:56:31 <Axman6> think*
04:56:56 <a3f> frerich: So far all the existing code, depends on it being an IO String.
04:58:03 <shachaf> You're implementing system()? Or what?
04:58:56 * hackagebot FenwickTree 0.1.2.1 - Data structure for fast query and update of cumulative sums  http://hackage.haskell.org/package/FenwickTree-0.1.2.1 (MichalGajda)
04:58:58 * hackagebot json-autotype 0.2.5.9 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.9 (MichalGajda)
05:00:57 <a3f> shachaf: No it was just an example. I will link you the issue.
05:01:58 <a3f> shachaf: https://github.com/haskell/win32/issues/24#issuecomment-83274959
05:04:39 <shachaf> a3f: I see two issues here: Going from CString to String and going from String to CString.
05:05:06 <shachaf> You're talking about the former, where you're consuming CStrings that might be null pointers.
05:05:09 <shachaf> Where does it come up?
05:06:11 <simg> sorry to "go on :)" (not sure how frequently it's acceptable to post) but if anyone were willing to look at my "digestive-functors" problem it would be much appreciated https://github.com/jaspervdj/digestive-functors/issues/111
05:08:02 <shachaf> I feel a little betrayed by the name "digestive functors".
05:09:36 <a3f> shachaf: Hmm, can't think of a concrete example at the moment, but it's more of an interface question.
05:10:04 <shachaf> a3f: I was thinking that the only code that consumes CStrings is C code which you're calling.
05:10:16 <simg> shachaf: yeah, I found it confusing at first.
05:11:12 <shachaf> I don't know whether that's true.
05:11:41 <shachaf> Anyway I need to go to sleep.
05:12:15 <livingBEEF> Heyo. If I want function that creates and returns IOArray of type (IOArray Int a) where I have :: (Num a) in function signatures, it can't figure out it's type. Is it possible to do it generally like this at all?
05:13:35 <unknownloner> my friend: "Whats the monad for fmap?"
05:13:52 <a3f> shachaf: I see what you are getting at. Let's assume someone used newCString :: Maybe String -> IO CString and wanted to turn that one back
05:14:13 <livingBEEF> it can't figure out the type of arr <- NewArray (0,len) (fromInteger 0) :: IO(IOArray Int a) to be precise
05:14:19 <Iceland_jack> unknownloner: Are you asking that question on behalf of your friend?
05:14:29 <unknownloner> no :P
05:14:40 <Iceland_jack> Just making sure 
05:15:02 <a3f> Although, thinking about it that one seems off too. If the String is Nothing, there is no IO done either
05:15:36 <livingBEEF> it works flawlessly when I have the function return specific type, like IOArray Int Int or something ....
05:15:37 <shachaf> a3f: Maybe it should have type Maybe String -> IO (Maybe CString) or Maybe String -> Maybe (IO CString) :-)
05:16:18 <shachaf> a3f: Where you use Maybe CString until the very last step, where you collapse Nothing into a null pointer.
05:16:22 <a3f> shachaf: This is turning ugly. How would you write this signature?
05:16:43 <shachaf> a3f: In this case Maybe String -> Maybe (IO CString) seems much nicer, though.
05:17:05 <shachaf> Since that's just (fmap stringToCString)
05:17:19 <shachaf> Anyway, I don't know.
05:17:36 <lpaste> TheInfosphere pasted “why is this non-exhaustive?” at http://lpaste.net/127972
05:17:40 <shachaf> I really need to go to sleep.
05:18:07 <a3f> propagating the Maybe would be much additional effort. I'd prefer to just check for Nothing and then call the same old code if Just
05:18:19 <shachaf> TheInfosphere: What's the error?
05:19:04 <TheInfosphere> shachaf when I run this it says the pattern match is non-exhaustive, but I can't see why if there's an otherwise at the end
05:19:13 <shachaf> That's the whole error?
05:19:24 <shachaf> Warning, I guess.
05:19:56 <exio4> TheInfosphere: you are pattern matching on (c:d:cs) string, which wouldn't match with [x] or [] 
05:20:18 <shachaf> (Also, you should really take hlint's advice here. And try not to use length.)
05:20:51 <shachaf> (Or head or tail.)
05:20:58 <exio4> TheInfosphere: the code is also hard to read, I'd try to remove any uses of length, head and tail
05:21:23 <TheInfosphere> yeah, I plan on cleaning it up significantly, I'm just trying to make sure I understand how it is supposed to work first
05:21:34 <shachaf> What's the warning?
05:21:47 <shachaf> Really, you should put it right in the hpaste, next to your code.
05:21:48 <TheInfosphere> ah, thanks exio4
05:22:00 <TheInfosphere> ok shachaf 
05:22:08 <Javran> want to ask something about the core: https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-7.8.4/CoreSyn.html#t:Expr for case expression, it says "The DEFAULT case alternative must be first in the list, if it occurs at all", but isn't the default alternative short-cutting all the other alternatives if it appears as the first one?
05:22:17 <dgpratt> cabal error: "setup.exe: The pkg-config package gtk+-2.0 is required but it could not be found."
05:22:42 <dgpratt> is this because I installed GTK 3.x when I should have installed 2.x?
05:22:51 <exio4> that code suffers from boolean blindness 
05:23:05 <shachaf> Javran: No, it's special.
05:23:57 <shachaf> Javran: This isn't Haskell's case, these things aren't checked in order.
05:27:06 <Javran> shachaf: I see, thanks!
05:27:55 <a3f> shachaf: Maybe String -> Maybe (IO CString) doesn't sound right. even if String is Nothing, the result should be nullPtr not Nothing. So the two outcomes are actually IO CString and plain CString
05:28:40 <shachaf> I was suggesting to avoid nullPtrs at all as far as possible.
05:28:55 <shachaf> But actually maybe the type I gave doesn't make sense.
05:30:29 <shachaf> You can always use traverse instead of fmap.
05:30:36 <shachaf> I don't know. I'm actually going to sleep now.
05:30:52 <a3f> shachaf: Well your input is most welcome. Here is the link again: https://github.com/haskell/win32/issues/24
05:31:37 <a3f> I am leaving too.
05:31:38 <ben__> any spacemacs users around? Do you have to press anything special (other than <RETURN>) to evaluate a command types into the haskell repl?
05:32:46 <echo-area> Hi.  I accidentally typed `newtype N a b = N (a b)` and it was compiled, but I didn't find any way of using the result type.  What does this type mean?
05:33:30 <quchen2> echo-area: it's "a applied to b".
05:33:31 <quchen2> ?let newtype N a b = N (a b)
05:33:31 <int-e> echo-area: you could have   N (Nothing) :: N Maybe Int -- both the constructor and its first argument can vary
05:33:32 <lambdabot>  Defined.
05:33:45 <mauke^> :t N "Hello"
05:33:46 <lambdabot> N [] Char
05:34:06 <mauke^> :t N (Just 'H')
05:34:08 <lambdabot> N Maybe Char
05:34:26 <exio4> :t N (N "hi") 
05:34:27 <lambdabot> N (N []) Char
05:34:35 <quchen2> It's pretty much type-level ($).
05:34:37 <quchen2> ?src ($)
05:34:37 <lambdabot> f $ x = f x
05:34:47 <quchen2> N a b = N (a b)
05:35:16 <livingBEEF> I'm a bit confused by signatures. I have a function with (Num a) => ... in signatures. When I want to write signatures for another subfunction (after where) involving (Num a) from the original signatures, it complains. How can I do it, when I need the signature? Is it possible to "bind" the (Num a) to subfunctions (Num a)? Just using "a" isn't working for me...
05:35:34 <mauke^> livingBEEF: needs scoped type variables
05:36:23 <tdammers> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/other-type-extensions.html#scoped-type-variables
05:36:25 <livingBEEF> I'll look into that.
05:36:27 <livingBEEF> thanks
05:37:03 <dgpratt> replacing GTK 3.x with 2.x did the trick
05:39:27 <echo-area> mauke^: N "Hello" :: N [] Char  <--  Is this sequence monad?
05:39:43 <mauke^> huh?
05:39:55 <echo-area> I mean I don't see why this is N [] Char
05:40:04 <mauke^> what else would it be?
05:41:04 <echo-area> Does it mean applying [] to Char?
05:41:14 <int-e> echo-area: note that  [] Char  is the same type as  [Char]. The N constructor has type  N :: a b -> N a b, or concretely, N :: [] Char -> N [] Char, which is the same as N :: [Char] -> N [] Char
05:41:17 <tdammers> [] is a type constructor for lists
05:41:48 <echo-area> tdammers: Oh I see, didn't know about this
05:41:50 <mauke^> > "Hello" :: [] Char
05:41:52 <lambdabot>  "Hello"
05:42:47 <echo-area> So [] is defined with `data [] a = ...`
05:43:12 <echo-area> Thanks all, now I understand
05:43:43 <pavonia> > 1 :: (a -> Int) String
05:43:44 <lambdabot>  ‘a -> GHC.Types.Int’ is applied to too many type arguments
05:46:26 <mauke^> > show :: (->) Int String
05:46:29 <lambdabot>  <Int -> [Char]>
06:03:21 <benzrf> how do i do a module target for ghci in a cabal sandbox
06:06:28 <tempname11_> benzrf: not sure what you mean, but try using "cabal repl" instead of ghci
06:06:40 <benzrf> tempname11_: yeah im doing that
06:06:47 <benzrf> but it appears not to support giving a filename to load :|
06:07:19 <benzrf> Warning: Ignoring <file path>. The whole library will be built.
06:07:27 <benzrf> (Support for module and file targets has not been implemented yet.)
06:10:24 <tempname11_> benzrf: this might very well be beyond my understanding, but just as a suggestion: what if you specify a normal module path (i.e. Foo.Bar.Bar) instead of a filename?
06:10:42 <benzrf> >Support for module and file targets
06:11:20 <tempname11_> benzrf: I'm pretty sure I can use ":load Foo.Bar" and it works
06:11:29 <benzrf> oh i meant in the command
06:11:30 <benzrf> :P
06:12:40 <benzrf> hmm, is there a ghci cli option to run a command before giving the prompt
06:12:51 <benzrf> like
06:12:58 <benzrf> ghci -run-first ":l file"
06:14:58 <osa1> is extra-include-dirs removed from Cabal? I can't see it here https://www.haskell.org/cabal/users-guide/developing-packages.html
06:16:01 <jtanguy> benzrf: cabal help repl gives me  "For certain scenarios, `cabal exec -- ghci :l Foo` may be used instead."
06:16:13 <jtanguy> does that help ?
06:16:24 <benzrf> jtanguy: :-o interesting neat
06:16:26 <benzrf> thanks!
06:16:38 <osa1> so extra-include-dirs is not working as I expected but it's not giving an error either. include-dirs worked.
06:16:46 <osa1> I'm wondering what has happened to extra-include-dirs
06:22:08 <bergmark> osa1: is there a difference between them?
06:22:51 <nkar> benzrf: so does the above command work with cabal repl?
06:23:28 <benzrf> i'm now using this:
06:23:28 <benzrf> :!cabal exec -- ghci % -Wall -ignore-dot-ghci
06:24:23 <phaazon> hey, is there a way to poke ByteString into C?
06:24:40 <jacquerie> > :t (***)
06:24:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
06:24:56 <ski> @type (***)
06:24:56 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:25:39 <jacquerie> ski, thanks. Yes, Typeclassopedia didn't lie: that looks scary.
06:26:25 <mauke^> Arrow (~>) => (b ~ c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
06:26:35 <mauke^> b ~> c
06:26:39 <ski> jacquerie : you used to be able to write `(***) :: Arrow (~>) => (a0 ~> b0) -> (a1 ~> b1) -> ((a0,a1) ~> (b0,b1))'
06:28:13 <ski> (if not using an infix type variable, i prefer something like `(***) :: Arrow ar => ar a0 b0 -> ar a1 b1 -> ar (a0,a1) (b0,b1)'. makes the arrow tyvar stand out better)
06:29:16 <ski> @type \f g ~(x,y) -> (f x,g y)
06:29:17 <lambdabot> (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
06:29:18 <ski> @src (->) (***)
06:29:18 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
06:30:33 <tempname11_> phaazon: maybe unsafeUseAsCString will help you?
06:30:36 <tempname11_> https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Unsafe.html
06:31:36 <phaazon> thanks
06:34:26 <bazqux> Hello.
06:37:12 <bazqux> Which library should I use for processing JSON?
06:37:19 <clrnd> bazqux, aeson is pretty nice
06:37:22 <tdammers> Aeson
06:37:46 <tdammers> depends on the purpose, but 9/10 cases, aeson is the right tool
06:38:17 <bazqux> clrnd, tdammers: Okay, thanks guys.
06:38:37 <niluje> I want to make a UDP server in haskell, which package should I use? network-simple seems to only handle TCP
06:38:53 <niluje> isn't there something in the stdlib?
06:39:48 <Selwyn015> Hello guys I have some problems with my Haskell assignment, I dont really know how to get started on this one. This is the assignment: http://lpaste.net/127975 anybody got some ideas?
06:40:27 <tdammers> Selwyn015: decompose the problem into sub-problems
06:40:47 <Selwyn015> Yes I figured i need Patternmatching and the !! operator
06:40:51 <tdammers> can you write a function that produces the first element of the output list?
06:40:56 <Selwyn015> And also deconstruct the data
06:41:02 <phaazon> hm tempname11_ 
06:41:09 <phaazon> I've found a way better way :)
06:41:14 <phaazon> Data.Binary.encode
06:41:30 <tdammers> can you write one that produces the 2nd element? 3rd? nth?
06:41:42 <phaazon> that will turn anything that is in Binary into a Bytestring
06:41:43 <Selwyn015> I think i can
06:41:52 <phaazon> then I can just use the IO functions to poke that into C
06:42:39 <tempname11_> phaazon: sorry, I'm not following. I thought you had a ByteString already?
06:43:00 <tdammers> Selwyn015: can you generalize those functions into one that takes a list and an "n"?
06:43:03 <tempname11_> at least the initial question was phrased like that
06:43:53 <tdammers> i.e., [Char] -> Int -> [Char]
06:44:11 <Selwyn015> Yes I guess so
06:44:34 <Selwyn015> But I'd also need something to concatinate the characters together again
06:45:01 <tdammers> no, I meant, can you write a function that gets you from "Selwyn" to "ewn"?
06:45:19 <tdammers> iow, can you write a "every nth element of a list" function?
06:45:36 <Selwyn015> ill give it a try anyway
06:45:43 <tdammers> everyNth :: [a] -> Int -> [a]
06:46:17 <Selwyn015> ah
06:46:21 <Selwyn015> I think i have an idea
06:48:06 <ocramz> hi room
06:48:12 <phaazon> ah yeah
06:48:19 <phaazon> there's no way to poke ByteStrings
06:48:28 <phaazon> only something to transform them into CStrings
06:48:39 <phaazon> if my ByteString contains floating point values
06:48:43 <phaazon> that doesn't make any sense
06:48:51 <tempname11_> phaazon: what do you mean by "poke" ?
06:49:12 <phaazon> ByteString -> Ptr Word8 -> IO ()
06:49:41 <frawgie> Haskell has ruined all other languages for me :/ all I can think of now is: "it would be so much easier if this was written i Haskell..." :(
06:49:53 <juanpaucar> +1
06:49:56 <ocramz> frawgie: same same
06:50:33 <phaazon> I guess I should use a [Word8] instead of a ByteString then
06:50:38 <phaazon> [Word8] has an instance®
06:50:39 <phaazon> ...
06:50:49 <ocramz> I have an FFI question, anybody here has experience with https://hackage.haskell.org/package/haskell-mpi ?
06:51:31 <tempname11_> phaazon: assuming the "Ptr" argument points to a sufficiently large memory chunk, you could use unsafeUseAsCStringLen, and then "memcpy" the raw data into your pointer
06:52:15 <tempname11_> and by memcpy I mean copyBytes from Foreign.Marshall.Utils
06:52:45 <tempname11_> oops, nope. not that
06:53:34 <phaazon> or...
06:53:40 <phaazon> I can just unpack the ByteString
06:53:46 <phaazon> and call pokeArray
06:54:14 <phaazon> yeah
06:54:18 <phaazon> that sounds a better way
06:54:48 <tempname11_> phaazon: pokeArray with Word8?
06:55:00 <tempname11_> sure, you could, but it'd be much slower
06:55:21 <phaazon> why would it be?
06:55:29 <phaazon> at least it's not unsafe
06:55:47 <osa1> how do I tell cabal to keep tmp files?
06:56:13 <tempname11_> well, it builds up a list of Word8's just to discard it moments after
06:56:41 <tempname11_> and my proposed solution would just copy the bytes in memory
06:57:05 <tempname11_> actually, you can use copyBytes. I was confused for a moment there.
06:58:03 <phaazon> tempname11_: the doc says it violates ref transparency.
06:59:01 <tempname11_> phaazon: what does?
07:00:41 <ski> phaazon : you should only use `unsafeUseAsCStringLen' if you have no other reference to that `ByteString' (or part of it), except the one you pass to the operation
07:02:15 <phaazon> why the Len version btw?
07:02:32 <phaazon> unsafeUseAsCString sounds enough to me, doesn't it?
07:02:49 <ski> dunno. i saw tempname11_ name mentioning that version
07:02:58 <ski> same applies to `unsafeUseAsCString', obviously
07:04:18 <tempname11_> I mentioned the Len version, because if you have a raw memory chunk with floats in it, it can't be a NULL-terminated string
07:05:32 <phaazon> so the version without Len excepts such a thing?
07:05:47 <tempname11_> and the referential trasparency only breaks if you poke _into_ the resulting CString(Len). And we don't want to do that, we only want to read from it
07:06:03 <tempname11_> sorry if I made it more confusing than it is :)
07:06:17 <phaazon> oh
07:06:19 <phaazon> great then
07:06:39 <phaazon> but I really think the version without Len is enough
07:06:54 <phaazon> the documentation says that it'll do nothing about \0
07:07:04 <phaazon> and nor the source code btw
07:07:26 <tempname11_> phaazon: but you still need to get the length from somewhere, right?
07:08:04 <phaazon> tempname11_: I have it before calling that function
07:08:31 <phaazon> but hm
07:08:39 <phaazon> tempname11_: what would be the length here?
07:08:43 <phaazon> the number of bytes?
07:08:47 <tempname11_> yes
07:08:52 <phaazon> that could, indeed, be useful
07:13:57 * hackagebot yesod-core 1.4.8.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.8.3 (MichaelSnoyman)
07:15:37 <bartavelle> ( amusing note, seemingly from Martin Odersky : https://twitter.com/waxzce/status/578316020420591616/photo/1 )
07:17:06 <tempname11_> phaazon: did you need this for the Vertex thing you mentioned in #haskell-game? :)
07:22:03 <echo-area> Is [] the only constructor that is composed of only symbol characters?
07:23:13 <tdammers> echo-area: ()
07:24:14 <bartavelle> also all the tuples
07:25:01 <dgpratt> I have a feeling I'm on my own with this one, but...
07:25:02 <Geraldus> Hi friends!
07:25:06 <lpaste> dgpratt pasted “cabal build error” at http://lpaste.net/127978
07:25:22 <ibid> also :
07:25:34 <Geraldus> Can't figure out is `readTChan` blocking or not?
07:25:39 <tdammers> : isn't a type constructor though
07:25:57 <tdammers> but, also, ->
07:26:02 <EvanR> Geraldus: it will retry if nothing is ready
07:26:13 <EvanR> retry might mean block
07:26:33 <Geraldus> EvanR: that's really strange... Let me paste some code
07:27:03 <livingBEEF> Is it wise to have a library that needs -XScopedTypeVariables?
07:27:13 <bartavelle> dgpratt, are you sure you don't have several GTK DLLs around, and you compiled part of your libs against one, and are linking against another ? wild guess, but this did bit me several times when writing C applications on windows due to the .DLL load order
07:27:19 <EvanR> ScopedTypeVariables is teh boss
07:27:30 <dgpratt> bartavelle, that's possible
07:28:34 <dgpratt> bartavelle, not knowing any better, I got the GTK 3 libs first and got so far with those, but eventually something demanded v2
07:29:01 <dgpratt> so I got the v2 libs and tried again, but at that point some packages were already built
07:29:33 <bartavelle> oh then you are certainly in a world of trouble, if those were gtk-related packages
07:29:41 <phaazon> tempname11_: yes
07:29:46 <dgpratt> what's the easiest way to force a complete rebuild? should I reinstall the dependencies?
07:29:51 <phaazon> I plan to shrink my vertices into ByteString
07:30:04 <phaazon> to pass them as opaque memory buffers to OpenGL
07:30:08 <bartavelle> on linux I usually rm -rf .cabal and .ghc, don't know where it is located on windows
07:30:23 <dgpratt> ok, thanks bartavelle
07:30:54 <bartavelle> ghc-pkg list
07:30:58 <echo-area> tdammers: The report defines `data` as `data [context =>] simpletype [= constrs] [deriving]`, where `simpletype` is `tycon tyvar1 ... tyvark`.  Are "[]" and "()" valid as `tycon` because the language reserves them?
07:30:59 <bartavelle> should give you the location
07:31:05 <osa1> does anyone know what's difference between extra- fields in Cabal and non-extra-prefixed versions of same fields?
07:31:29 <dgpratt> bartavelle, this is a sandboxed project
07:31:30 <bartavelle> then if you are unlucky enough for them to be in the system-wide store, you can "unregister" the faulty packages
07:31:38 <bartavelle> oh then it should be trivial
07:32:02 <dgpratt> bartavelle, I suspected as much, but good :)
07:32:05 <echo-area> Because otherwise I cannot match [] or () with the lexical definition of `tycon`
07:32:07 <Geraldus> Here is simple STM code http://lpaste.net/127979. I expect to see some output, however it does not output anything.
07:32:15 <tdammers> echo-area: I'm not that familiar with this internal voodoo
07:32:37 <EvanR> Geraldus: you duped it, so it lost all contents
07:32:40 <EvanR> try cloning
07:32:52 <EvanR> or not duping
07:32:55 <Geraldus> but what about last statement?
07:33:10 <EvanR> the last statement happens then the program ends immediately
07:33:13 <Geraldus> I suppose not to see "1", but to see "2"
07:33:22 <EvanR> the program ends with the main thread ends
07:33:23 <echo-area> tdammers: Okay.  Is it true that users cannot define constructors like [] or () themselves?
07:33:34 <EvanR> try a threadDelay after the last statement
07:33:43 <Geraldus> oh, let me see!
07:34:16 <EvanR> and if that doesnt work, try a threadDelay right before the last statement, since it might happen before the dup
07:34:32 <meoblast001> is this supposed to work this way?
07:34:33 <meoblast001> > groupBy (\a b -> a == b) [1, 2, 3, 4, 1, 2, 3, 4]
07:34:35 <lambdabot>  [[1],[2],[3],[4],[1],[2],[3],[4]]
07:34:39 <EvanR> yes
07:34:46 <EvanR> sort first
07:34:58 <meoblast001> yeah.. i made that change, but this still seems sort of unintuitive
07:35:06 <EvanR> yeah, but efficiency
07:35:06 <meoblast001> i don't think i've ever seen a "group" function that doesn't handle that
07:35:09 <FreeFull> > group . sort $ [1,2,3,4,1,2,3,4]
07:35:10 <lambdabot>  [[1,1],[2,2],[3,3],[4,4]]
07:35:27 <FreeFull> Having it this way is more flexible
07:35:27 <EvanR> if its already sorted youre golden
07:35:37 <FreeFull> It lets you use group to implement RLE for example
07:35:49 <meoblast001> oh yay.. my type isn't part of Ord lol
07:36:01 <indiagreen> echo-area: [], () and (,) (and also (,,), (,,,), etc.) are special, yep
07:36:28 <EvanR> :t sortBy
07:36:29 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
07:36:35 <EvanR> meoblast001: you dont need Ord
07:36:36 <Geraldus> EvanR: both variants not working...
07:36:44 <EvanR> Geraldus: paste new code
07:36:56 <Geraldus> let me check this code somewhere else, e.g. FPComplete
07:37:03 <Geraldus> oh, sec
07:37:04 <meoblast001> EvanR: yeah.. at some point it's going to get difficult for me to assign ordering but i'll figure something out
07:37:05 <nkar> benzrf: why are you calling ghci from ghci itself?
07:37:17 <benzrf> huh?
07:37:20 <benzrf> i'm not?
07:37:28 <benzrf> oh that's a vim cmd
07:37:29 <echo-area> indiagreen: Thanks.  In fact I tried to define them in my module and I got the "Illegal binding of built-in syntax" error
07:37:30 <benzrf> vim also uses :!
07:37:32 <EvanR> meoblast001: i guess you could writing ==-only group...
07:37:34 <nkar> benzrf: ah
07:37:45 <meoblast001> EvanR: what would that do?
07:37:52 <EvanR> what you expected
07:37:54 <frerich> meoblast001: If group(By) can rely on sorted input, it can be more efficient because it only needs to traverse the list once and look for subsequent equal elements. It's a tradeoff between convenience and efficiency for the "input is sorted" case.
07:37:56 <indiagreen> echo-area: the curious thing about GHC is that they aren't exactly magic/built-in
07:38:09 <Geraldus> EvanR: all I've done added two threadDelay's before and after `atomically (writeTChan chan "2")`: http://lpaste.net/127979 (update)
07:38:16 <indiagreen> you can find actual definitions of (,) and friends in some GHC.* file
07:38:25 <meoblast001> frerich: yeah. that seems probably best. i just didn't see that in the docs for it
07:38:27 <EvanR> Geraldus: try 1000000 instead
07:38:39 <indiagreen> however, there's also a check later which prevents you from defining them anywhere but that particular GHC.* file
07:38:43 <echo-area> Yes I saw that;  that's why I tried to define them in my own files
07:38:52 <echo-area> Ah I see
07:39:00 <EvanR> Geraldus: ah... you only read from the chan 1 time
07:39:07 <EvanR> then the thread disappears
07:39:08 <Geraldus> yes
07:39:16 <EvanR> so its not surprising you see nothing
07:39:20 <tdammers> echo-area: afaik, type constructors need to start with an uppercase letter
07:39:37 <echo-area> tdammers: Got it.  Thank you!
07:39:39 <Geraldus> But I've supposed it should block until any avail value
07:39:41 <meoblast001> i found a way i could put this into ord
07:39:42 <meoblast001> thanks
07:39:46 <EvanR> youre right, testing
07:40:42 <tempname11_> anyone know if Data.Vector.Storable stores the data in a marshalled form internally?
07:42:12 <crispweed> hi, can someone try this: Prelude> let (a,g) = System.Random.random (System.Random.mkStdGen 4) in a :: Int
07:42:57 <crispweed> (I get "No instance for (System.Random.Random t0) arising from the ambiguity check for `g'..")
07:43:06 <indiagreen> so do I
07:43:20 <crispweed> but it works in the sandbox on haskell.org
07:43:22 <EvanR> Geraldus: for me its blocking on the readTChan, tried a few things still havent gotten something resembling your code to print val
07:43:41 <nkar> benzrf: fwiw, you could also use cabal exec sh and call ghci later.  I learned it from smdiehl's guide.
07:43:47 <indiagreen> it works if you turn monomorphism restriction off
07:43:55 <indiagreen> I mean, on
07:44:00 <EvanR> Geraldus: i have a feeling i know whats going on though
07:44:03 <crispweed> aha
07:44:08 <indiagreen> it's turned off by default starting from GHC 7.8, I think
07:44:43 <Geraldus> EvanR: feel free to share your guesses
07:44:46 <EvanR> Geraldus: ok. so if you atomically dup before you atomically read it works. i think the effect of duping does not get committed by the time you write, so it doesnt get duped
07:44:59 <crispweed> I turned that off in my .ghci though, I think
07:45:02 <EvanR> the message doesnt get duped
07:45:13 <tempname11_> OK, found the answer to my own question by reading the source. It actually does! So cool :)
07:45:40 <indiagreen> crispweed: well, and that's why you're getting the error
07:45:49 <indiagreen> move the type signature
07:45:57 <indiagreen> > let (a::Int,g) = System.Random.random (System.Random.mkStdGen 4) in a
07:45:58 <Geraldus> it's strange, because of this quote: Duplicate a TChan: the duplicate channel begins empty, but data written to either channel from then on will be available from both.
07:45:59 <lambdabot>  -258552320774346181
07:46:30 <EvanR> Geraldus: right that works, but because the dup action is an STM action it has no effect until you complete an atomically
07:46:33 <EvanR> which your code doesnt
07:46:37 <jophish> Is there any kind of network cache for cabal builds?
07:46:44 <benzrf> nkar: neat
07:46:46 <crispweed> ah, indeed, with ":set -XMonomorphismRestriction", it works
07:46:46 <Geraldus> EvanR: oh, catch it
07:47:04 <indiagreen> hey, c'mon, move the signature, don't enable monomorphism restriction
07:47:35 <echo-area> Found one more symbol data constructor: ->
07:47:47 <indiagreen> echo-area: it's not data constructor
07:47:50 <indiagreen> it's type constructor
07:48:04 <Geraldus> EvanR: THANK YOU A LOT! (:
07:48:13 <osa1> hm, we don't have wait or join for ThreadId ?
07:48:21 <Geraldus> I've spent whole day struggling with it
07:48:35 <crispweed> ok, so I also need ":set -XScopedTypeVariables" by the looks of things, but then your version works
07:48:47 <echo-area> indiagreen: Oh yes.  `tycon` means type constructor
07:49:30 <crispweed> but, this is just me chasing down a problem I get somewhere else, and where I got this originally, the code wants to deal with generic types :(
07:49:31 <EvanR> Geraldus: also you might want a broadcast tchan here since youll get an error message if you accidentally read from it without duping
07:50:00 <EvanR> and the original chan goes to /dev/null instead of accumulating messages
07:51:36 <fedemaster> hello, I have some issues about mtl-style
07:51:42 <Geraldus> EvanR: I though this dupTChan is something _like_ broadcast channel. What do you mean by broadcast TChan?
07:51:55 <fedemaster> is there a document that I can read about it?
07:52:20 <EvanR> Geraldus: newBroadcastTChan, its the same thing but acts like i said
07:52:40 <EvanR> look at latest version of STM
07:54:45 <fedemaster> which are the differences between mtl-style and no mtl ?
07:58:50 <Geraldus> The sad news is that it still does not work when compiled by GHCJS :(
07:59:12 <EvanR> havent tried GHCJS
08:00:25 <Geraldus> EvanR: oh, threadDelay do the trick!
08:00:55 <EvanR> Geraldus: another thing (which might not apply to ghcjs) is that linking with -threaded seems to improve a lot of stuff
08:01:27 <EvanR> threadDelay timing is one thing
08:02:35 <Geraldus> EvanR: thank you once again! 
08:04:19 <dgpratt> bartavelle, you are da man! :)
08:04:25 <dgpratt> it worketh!
08:04:55 <bartavelle> dgpratt, nice to hear, it looked at first like a nightmarish problem
08:05:17 <dgpratt> indeed, I thought likewise
08:08:04 <Ryanar> hey all, I am writing my own last function to get the last element of a list of elements. The function works properly, but I have no idea how you are supposed to write the type signature. GHC was able to figure it out for me but I dont understand it
08:08:47 <frerich> Ryanar: Do you mean, in terms of syntax or in terms of "How do you come up with *what* the signature is"?
08:08:59 <Iceland_jack> Ryanar: The function gets the last element of a list right?
08:09:06 <fedemaster> [a] -> a?
08:09:32 <Iceland_jack> So its first argument should be a list, like a list of Ints ([Int]) or a list of Bools ([Bool]), ...
08:09:34 <lpaste> ryanar pasted “my last function” at http://lpaste.net/127983
08:09:52 <Iceland_jack> Ryanar: Don't use “return” there
08:09:53 <Ryanar> http://lpaste.net/127983
08:10:01 <sgronblo> hehe my last function sounds dramatic
08:10:03 <Ryanar> oh it posts it for me
08:10:07 <Ryanar> Hahahaha!
08:10:14 <frerich> sgronblo: :-))
08:10:42 <Ryanar> so it just takes the first element off the list until the tail of the list is empty
08:10:43 <sgronblo> after this i will make no more functions!
08:10:47 <Ryanar> and then returns that element
08:10:59 <sgronblo> but yeah return is misused here
08:11:00 <Iceland_jack> Ryanar: remove the return
08:11:15 <Ryanar> so I just say else x?
08:11:16 <Iceland_jack> and (==) makes the function too restrictive
08:11:21 <Iceland_jack> Ryanar: that's right
08:11:32 <fedemaster> you can define it by cases
08:11:44 <Ryanar> ah ok
08:11:54 <Ryanar> so what would I use instead of ==?
08:11:54 <frerich> Ryanar: 'return' was an arguably unfortunate naming choice in Haskell. It means something very different than what the 'return;' means in imperative languags (think C, Java).
08:12:05 <Iceland_jack> Ryanar: What your logic is basically doing is checking if the list only has a single element
08:12:15 <Iceland_jack> Ryanar: That's the same as pattern matching on [x]
08:12:22 <Iceland_jack> So you'd want to write
08:12:22 <Iceland_jack>     mylast [x] = x
08:12:29 <Ryanar> ah I see what you mean
08:12:32 <Iceland_jack> does that make sense?
08:12:39 <Ryanar> I thought [x] could represent a list of any size
08:13:04 <sgronblo> thats when you use the [] type constructor
08:13:05 <fedemaster> try something like: mylast [x] = x ; mylast (x:xs) = ...
08:13:09 <Iceland_jack> Ryanar: When it appears as a *pattern* or as a term it's just syntactic sugar for (x:[])
08:13:25 <Iceland_jack> So you could also write
08:13:25 <Iceland_jack>     mylast (x:[]) = x
08:13:47 <Iceland_jack> Ryanar: Look at fedemaster's suggestion and see if you can't fill in the blank :)
08:13:50 <lpaste> ryanar revised “my last function”: “No title” at http://lpaste.net/127983
08:13:58 * hackagebot cless 0.3.0.0 - Colorized LESS  http://hackage.haskell.org/package/cless-0.3.0.0 (HideyukiTanaka)
08:14:09 <Iceland_jack> (‘last function’ is a bit dramatic) :-)
08:14:18 <Ryanar> hahahaha!
08:14:18 <Iceland_jack> Ryanar: Yes, perfect
08:14:28 <Ryanar> yeah and now it is of the type that I thought it would be, [a] -> a
08:14:36 <fedemaster> yep, "MY last function" sounds creepy :P
08:14:46 <Ryanar> should I just call it "last'"
08:14:56 <Iceland_jack> Ryanar: Yeah exactly, I understand that you're confused by the original type if it's “(Eq a, Monad m) => [a] -> m a”
08:15:26 <Ryanar> yeah it was Iceland_jack , I was completely lost as to how that came about since I havent learned Monads
08:15:45 <Iceland_jack> Ryanar: If you remove the 'return' the type is still wrong, would you like to venture a guess why?
08:16:04 <Iceland_jack>     mylast :: Eq t => [t] -> t
08:16:04 <Iceland_jack>     mylast (x:xs) = if xs == [] then x else mylast xs
08:16:08 <lpaste> ryanar revised “my last function”: “No title” at http://lpaste.net/127983
08:16:26 <Iceland_jack> Not wrong as such, just too restrictive :)
08:16:34 <Ryanar> I am assuming that
08:16:39 <Ryanar> Eq can only compare certain types
08:16:46 <Iceland_jack> Exactly
08:16:56 <Ryanar> so if I had some data
08:16:58 <Ryanar> it might not work
08:17:05 <fedemaster> Anyone could help me with mtl style? :P
08:17:21 <Iceland_jack> Yes, for the special case of an empty list ([]) you don't need the 'Eq a' constraint
08:17:28 <Iceland_jack> *'Eq t'
08:17:35 <fedemaster> Particullary don't understand what the mtl-style is
08:17:42 <jophish> I'd like to associate an integral value with every constructor of a particular datatype. is Enum the right tool for the job? It doesn't really make sense to implement enumFrom and friends
08:17:43 <jophish> is there a smaller class I could use?
08:17:43 <brbblnch> Hi
08:17:46 <Iceland_jack> But Haskell isn't that nuanced :)
08:18:13 <indiagreen> fedemaster: I don't understand it either
08:18:21 <EvanR> jophish: its done for you with deriving
08:18:21 <indiagreen> what do you mean by “mtl style”?
08:18:24 <echo-area> Which books do you recommend for learning type theory in Haskell and type theory in general?  Thanks
08:18:38 <Iceland_jack> Ryanar: As a simpler eample if you write a function like this, you don't need a constraint:
08:18:38 <Iceland_jack>     isEmpty :: [a] -> Bool
08:18:38 <Iceland_jack>     isEmpty [] = True
08:18:38 <Iceland_jack>     isEmpty _  = False
08:18:43 <jophish> EvanR: ah, I have a specific values I like :)
08:18:50 <Iceland_jack> Which is basically how 'null' is implemented
08:18:50 <Iceland_jack> @src null
08:18:50 <lambdabot> null []     = True
08:18:50 <lambdabot> null (_:_)  = False
08:18:53 <EvanR> jophish: then you need a big case or two
08:19:06 <jophish> yeah, These files are machine generated, so that's not a problem
08:19:09 <brbblnch> Is anybody familiar with the proof of weak normalization in the book "proofs and types", by Girard ? (I asked before but maybe more people are there now)
08:19:15 <fedemaster> I think it's the coding style where you put type instances like foo :: Monad m => m a
08:19:17 <EvanR> worry about instances later
08:19:20 <jophish> I'm wondering if the "standardness" of Enum is worth this
08:19:28 <Ryanar> Iceland_jack, ah that is interesting, and neat
08:19:38 <EvanR> fromInt :: Int -> MyTYpe, toInt :: MyType -> Int
08:19:39 <jophish> I've also got about 15 of these datatypes
08:19:40 <Iceland_jack> Ryanar: But if you defined it as
08:19:40 <Iceland_jack>     isEmpty :: Eq a => [a] -> Bool
08:19:40 <Iceland_jack>     isEmpty xs = xs == []
08:19:57 <Iceland_jack> Ryanar: Then you couldn't write 'isEmpty [id, id, id]'
08:20:10 <Ryanar> right
08:20:15 <Iceland_jack> Because you can't compare functions for equality, even though that has nothing to do with checking whether a list is empty or not
08:20:25 <jophish> EvanR: what I'm doing exactly is writing a haskell representation of the Spir-V spec. See here for an example: https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#_a_id_addressing_model_a_addressing_model
08:20:36 <jophish> this data type has three constructors
08:20:43 <EvanR> dont use Enum
08:21:28 <lpaste> ryanar revised “my last function”: “No title” at http://lpaste.net/127983
08:21:50 <lpaste> ryanar revised “my last function”: “No title” at http://lpaste.net/127983
08:21:59 <Ryanar> sorry for all the pastes
08:22:05 <jophish> so the idiomatic thing to do would be to have: addressingModelToIntegral and addressingModelFromIntegral
08:22:42 <Iceland_jack> Ryanar: Looks good :) your last' :: [a] -> Maybe a is sometimes called 'safeLast'
08:22:43 <EvanR> theres also pattern synonyms
08:23:12 <hexagoxel> lpaste: if you have more than one paste to report, please paste the the list of pastes on lpaste
08:23:23 <Iceland_jack> lol
08:23:23 <Ryanar> oh great so I wrote a function already implemented
08:23:24 <jophish> EvanR: a la 'gl'? I don't think they're the best fit here
08:23:35 <jophish> because these enums have other data associated with them
08:23:36 <Ryanar> well it was a good exercise, thank you for the help
08:23:41 <fedemaster> he couldn't define last, now he's using maybe :D
08:24:37 <Iceland_jack> Ryanar: No problem, does it make sense that [x] is sugar for (x:[])? 
08:24:58 <Ryanar> Iceland_jack, oh, no, I didn't realize, that makes more sense to me now
08:25:12 <Iceland_jack> This also holds for lists of length 2 ([x,y] is sugar for (x:(y:[]))) and 3 ([x, y, z] being sugar for (x:(y:(z:[])))) and so on
08:25:22 <Ryanar> Iceland_jack, its confusing because in the type signature [a] means a list of any length, yet [x] in the function means (x:[])
08:25:41 <Iceland_jack> Ryanar: Yes, it might be clearer if the type of a list would just be 'List a'
08:25:58 <Iceland_jack>     []    :: List a
08:25:58 <Iceland_jack>     [1,2] :: List Int ..
08:26:05 <frerich> Ryanar: Yeah, it's a bit confusing since '[]' on the type level and on the value level mean something different.
08:26:31 <Iceland_jack> Ryanar: When you have a type '[Int]' that's actually also sugar
08:26:57 <Iceland_jack> it's the same as '[] Int' where '[]' is a type constructor, so the Haskell people had a sweet tooth :)
08:27:05 <Ryanar> ah I see, so List is a data type and we have this sugar of brackets instead which is more similar to mathematics
08:27:06 <Iceland_jack> m
08:27:19 <Iceland_jack> @src []
08:27:19 <lambdabot> data [] a = [] | a : [a]
08:27:30 <ParahSailin> have people mostly given up on the GRIN optimization approach?
08:28:10 <Iceland_jack> If the type constructor [] were called 'List' it would look something like this
08:28:10 <Iceland_jack>     data List a = [] | a : List a
08:28:22 <Iceland_jack> This confuses a lot of people
08:28:58 * hackagebot hpc 0.6.0.2 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.6.0.2 (HerbertValerioRiedel)
08:29:09 <Ryanar> yeah that is confusing
08:29:12 <Iceland_jack> Hope that helped
08:29:21 <Ryanar> Yeah it definitely did
08:29:41 <dolio> Haskell has an unfortunate number of puns like that.
08:30:38 <dolio> And it's increasingly becoming a technical problem.
08:30:45 <ski> Ryanar : except it is not a math tradition to write something like `[Integer]'
08:31:06 <Ryanar> ski, true
08:31:15 <ski> dolio : which problems are you thinking about ? confusion in type expressions, when lifting constructors ?
08:31:21 <dolio> ski: Yeah.
08:31:45 * ski always thought the ML notation for product/tuple types were more sensible than the Haskell one
08:31:59 <fedemaster> I have a problem, when we are defining things like    foo::(MonadError e m, MonadWriter w m) => m a -> m a
08:32:11 <ski> (i've several times wanted to be able to pass around a tuple (or record) of types)
08:32:12 <fedemaster> we can't assume the stacking order of the first m a, right?
08:32:38 <dolio> Yeah, I like it, too. Although it'd be a little weird in Haskell, because (a * b) * c might not be isomorphic to a * b * c.
08:32:50 <dolio> Assuming the latter turns into what is currently (a, b, c).
08:33:12 <dolio> In ML you don't have to worry about that.
08:33:28 <ski> (instead of a record, one could possibly use something of kind `Tag -> *', where `Tag' enumerates the "field names")
08:34:02 <ski> dolio : i don't see how you don't have to worry about that in the MLs ?
08:34:12 <frerich> ski: OTOH, the Haskell notion is probably familiar to people coming from languages like Python or even C++ (if you let std::pair<> count...).
08:34:18 <frerich> s/notion/notation/
08:34:30 <ski> all three of `t * u * v',`(t * u) * v',`t * (u * v)' are different in the MLs
08:34:35 <fedemaster> anyone familiar with monad transformers?
08:34:53 <tdammers> fedemaster: just ask your question
08:34:58 <ski> (and `t * u * v' is literally a record with three fields, named `1',`2',`3' .. at least in SML. not sure about O'Caml)
08:35:17 <dolio> Oh, okay.
08:35:17 <napping> ski: but they are still isomorphic in ML, right?
08:35:20 <fedemaster> I have a problem, when we are defining things like fn::(MonadError e m, MonadWriter w m) => m a -> m a
08:35:28 <fedemaster> we can't assume the stacking order of the first m a, right?
08:35:36 <ski> frerich : i don't see why that should be important (e.g. seeing that so much other notation is different)
08:35:47 <dolio> ski: I thought maybe there were only binary products, and n-ary were an optimization on that.
08:36:03 <ski> napping : hm. yes. i see your point
08:36:18 <dolio> And if you design matching right, that can also be an optimization on binary products.
08:36:19 <napping> dolio: oh, I thought you were worried about lifting and laziness
08:36:43 <dolio> napping: Well, yes. You can't do that optimization because of the lifting.
08:36:54 <napping> Even without it, how would you do the pattern matching thing?
08:37:06 <ski> dolio : you can even write `{1 = "abc"}' for an unituple, if you like (though there's no sugar for it, or its type)
08:37:09 <napping> If it's right associated, how do you get something smart out of a pattern like (_,_,_,True)?
08:37:46 <napping> ah, if there's just one case I guess I see it
08:37:48 <dolio> napping: Like Agda, maybe. _,_ is a constructor, and doesn't require parens, so you can chain them.
08:37:51 <ski> napping : in O'Caml, the notation for a triple is `x,y,z', not `(x,y,z)'
08:37:52 <dolio> Then the rest is optimization.
08:38:13 <napping> I'm specifically asking how you think the optimization would go, to turn the nested patterns into a single offset
08:38:30 <ski>   match ... with
08:38:31 <ski>     x,y,z -> f x y,g y z
08:38:33 <ski> e.g.
08:38:34 <napping> case x of (_,x1) -> case x1 of (_,x2) -> case x2 of (_,True) -> e
08:38:59 <ski> (s/True/()/)
08:39:02 <napping> somehow turns into code that just fetches a field offset in x
08:39:46 <napping> I guess if you don't have to worry a much about strictness you can compile a one-level match of x into (a,b) with something like a == x, b == x+sizeof(pointer)
08:39:46 <dolio> napping: It'd probably be similar to optimization of n-ary functions and exactly saturated function calls in GHC, or eliminating function calls on tuples in ML.
08:39:58 <dolio> Fast path and slow path.
08:40:03 <dolio> I'm not really sure.
08:40:15 <napping> and then optimize those expressions a bit, I guess
08:40:59 <dolio> napping: Anyhow, I hadn't really thought about it very hard. It was just a guess as to how it might work.
08:41:14 <dolio> I'm not too familiar with ML.
08:41:31 <napping> seems like it out to work out, as long as you can basiclly use irrefutable patterns, which laziness would get in the way of
08:42:04 <dolio> Yeah, it might work in Haskell, too, if we had actual cartesian products.
08:42:31 <dolio> But we don't. Also seq breaks those even if you arrange everything else nicely.
08:42:57 <dolio> You can actually make Cartesian products now that we have pattern synonyms, though.
08:43:13 <dolio> As an abstract type.
08:43:33 <ski> if matching on a tuple pattern `(x,y)' was irrefutable, would that give use Cartesian products ?
08:43:41 <dolio> I guess you could technically always make them as an abstract type, but you wouldn't get pattern matching.
08:43:54 <dolio> ski: Yeah, except for seq.
08:43:57 <Iceland_jack> Oh I wonder if you can use irrefutable patterns in pattern synonyms
08:44:05 <Iceland_jack> Yes you can :)
08:44:06 <dolio> Iceland_jack: You can.
08:44:13 <Iceland_jack> Great
08:44:22 <dolio> ski: That's how Miranda was.
08:44:24 <Iceland_jack> This makes me more happy than it should
08:45:07 <ski> (of course, a pattern `(Just x,y)' would of course not be irrefutable in total .. it should be like a(n irrefutable) pattern `(mx,y)' plus a pattern guard `Just x <- mx')
08:45:48 <dolio> Well, presumably it'd work like ~(Just x, y) does now.
08:46:08 <dolio> Which is actually pretty weirdly, as I recall.
08:46:11 <napping> How does that work now?
08:46:39 <dolio> > case (Nothing, 5) of ~(Just x, y) -> y
08:46:41 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
08:47:03 <dolio> > case (Nothing, 5) of ~(Just x, y) -> 5
08:47:04 <napping> ok, that makes sense
08:47:04 <lambdabot>  5
08:47:10 <Iceland_jack> > case (Nothing, 5) of ~(~(Just x), y) -> y
08:47:11 <lambdabot>  5
08:47:52 <napping> it is a bit weird, but you can't exactly go back to matching the inner stuff refutably
08:48:11 <dolio> Well, you could. But that's not how it works.
08:48:27 <ski> dolio : last i was thinking of cartesian products, i was thinking we wanted `(<pat 0>,<pat 1>)' to be irrefutable (if and) only if `<pat 0>' and `<pat 1>' was also irrefutable
08:48:52 <dolio> ski: I don't think so.
08:50:13 <ski> dolio : elaborate ?
08:50:34 <brbblnch> ski: You're good with typed lambda calculus, right ? Could you help me understand a proof?
08:52:22 <btcNeverSleeps> The type of sequence is "sequence :: Monad m => [m a] -> m [a]" and if I do, say: "sequence [Just 1, Just 42]", I get: Just [1, 42].  So I take it it is correct to say that the monad m here is the mHaybe monad, right?
08:52:28 <dolio> ski: Hmm. Actually, that's how newtypes work, apparently.
08:52:33 <btcNeverSleeps> s/mHaybe/Maybe/
08:53:16 <Iceland_jack> btcNeverSleeps: Yes the type used there is
08:53:16 <Iceland_jack> :t sequence :: [Maybe a] -> Maybe [a]
08:53:16 <lambdabot> [Maybe a] -> Maybe [a]
08:53:39 <btcNeverSleeps> ok thanks, so since the type of sequence is "sequence :: Monad m => [m a] -> m [a]", what is the monad in: sequence [id, reverse] "abc" ?
08:53:53 <Iceland_jack> Good question :)
08:53:58 * hackagebot array 0.5.1.0 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.5.1.0 (HerbertValerioRiedel)
08:54:15 <btcNeverSleeps> Iceland_jack: my question about sequence you mean?
08:54:18 <Iceland_jack> Yes
08:54:20 <btcNeverSleeps> ^ ^
08:54:36 <ski> @type sequence `asTypeIn` \sequence -> sequence [Just 1,Just 42]
08:54:37 <lambdabot> Num a => [Maybe a] -> Maybe [a]
08:54:40 <ski> @type sequence `asAppliedTo` [Just 1,Just 42]
08:54:40 <lambdabot> Num a => [Maybe a] -> Maybe [a]
08:54:56 <ski> btcNeverSleeps : you can check the specific type used like that ^
08:55:01 <dolio> ski: (case undefined of Identity (Just _) -> 5) = undefined; (case undefined of ~(Identity (Just _)) -> 5) = 5.
08:55:19 <dolio> ski: So maybe you're right.
08:55:24 <ski> dolio : *nod*
08:55:46 <ski> brbblnch : dunno, i haven't seen the proof yet
08:56:01 <Iceland_jack> btcNeverSleeps: Take a look at the return type of
08:56:01 <Iceland_jack> :t sequence [id]
08:56:02 <lambdabot> a -> [a]
08:56:37 <ski> @type sequence `asAppliedTo` [id]
08:56:37 <Iceland_jack> That should correspond to the type of 'Monad m => m [a]'
08:56:38 <lambdabot> [a -> a] -> a -> [a]
08:56:55 <ski>   [(a ->) a] -> (a ->) [a]
08:57:09 <ski> `(a ->)' here corresponding to `m' in `[m a] -> m [a]'
08:57:22 <btcNeverSleeps> is there an equivalent to lambdabot's   @type sequence `asAppliedTo` [id]    in GHCi ?
08:57:46 <Iceland_jack> btcNeverSleeps: If looks more complicated because (->) is infix, but if you define
08:57:46 <Iceland_jack> @let type Arr a b = a -> b
08:57:46 <Iceland_jack> then the type is simply
08:57:46 <Iceland_jack>  
08:57:48 <lambdabot>  Defined.
08:57:49 <indiagreen> btcNeverSleeps: you can just define asAppliedTo
08:57:50 <Iceland_jack> @ty sequence :: [Arr a a] -> Arr a [a]
08:57:51 <lambdabot> [Arr a a] -> Arr a [a]
08:57:55 <ski> @src asTypeIn
08:57:55 <lambdabot> a `asTypeIn` f = a where _ = f a
08:57:55 <lambdabot> infixl 0 `asTypeIn`
08:57:56 <indiagreen> @src asAppliedTo
08:57:56 <lambdabot> Source not found.
08:57:58 <indiagreen> darn
08:58:10 <ski>   f `asAppliedTo` x = f `asTypeIn` ($ x)
08:58:17 <dolio> ski: Apparently this is actually laid out in the report, even. I'd never thought of that subtlety. But yes, cartesian products should behave similarly to newtypes.
08:58:23 <ski> btcNeverSleeps : try that
08:58:39 <btcNeverSleeps> I'll copy/paste (well, copy/yank really) this discussion for further reading btw :)
08:58:47 <ski> (possibly with `infixl 0' on the other one as well, if you want to)
08:58:50 <btcNeverSleeps> but then (a ->) is following the monad laws?
08:58:55 <ski> yes
08:58:56 <Iceland_jack> btcNeverSleeps: Yes
08:59:10 <ski> (you can check it, if you like :)
08:59:29 <Iceland_jack> btcNeverSleeps: It may be helpful to take a simple Monadic function
08:59:29 <Iceland_jack>     return :: Monad m => a -> m a
08:59:29 <Iceland_jack> and replace 'm' with (a ->)
08:59:37 <Iceland_jack> or well,
08:59:44 <Iceland_jack> and replace 'm' with (r ->) :)
08:59:52 <Iceland_jack> So that the variable names don't clash
09:00:06 <ski> dolio : (i assume you mean the `newtype' behaviour is laid out in the report ?) .. ok, i don't recall the details of my thinking now, but i recall that i thought having that behaviour would be sensible
09:00:09 <mustafa_> Hey guys! I'm trying to use arrays for the first time -- specifically UArrays -- and I'm having a little bit of trouble which I think boils down to not understanding imports/typeclasses
09:00:30 <mustafa_> I have a UArray whose type I THINK is UArray (Int, Int) Bool
09:00:48 <mustafa_> but when I try to print it I get     Expected a type, but ‘IArray UArray Bool’ has kind ‘Constraint’     In an expression type signature: IArray UArray Bool
09:01:00 <ski> dolio : if we had this behaviour, then we'd not need the `~' in `partition', e.g.
09:01:11 <mustafa_> sorry -- that is not the right error: This is:
09:01:12 <mustafa_>     No instance for (IArray a0 Bool) arising from a use of ‘it’     The type variable ‘a0’ is ambiguous     Note: there are several potential instances:       instance IArray Array e -- Defined in ‘Data.Array.Base’       instance IArray UArray Bool -- Defined in ‘Data.Array.Base’     In the first argument of ‘print’, namely ‘it’     In a stmt of an interactive GHCi command: print it *Main> let blackBox = U.ar
09:02:44 <ski> dolio : (re the `seq' problem) otoh, sometimes it could be somewhat useful to be able to force a function without applying it (yet) .. perhaps something similar would hold for tuples
09:02:57 <brbblnch> ski: in [www.paultaylor.eu/stable/prot.pdf], page 26 (4.3.3): In the third point of the proof it is said that "r is destroyed and possibly replaced by redexes of strictly smaller degrees". But if $t = ( fst ( \x -> u , w) )v$ and $r = \fst (\x -> u, w)$ is the redex to reduce. Then you get $t' = (\x -> u)v$ and its degree as a redex should be strictly less than the degree of r, but I can't prove why
09:03:28 <ski> (think "serious use of currying", like (run-time) compiling a regexp description into a matcher function)
09:03:48 <mustafa_> (I suddenly realize I should have put it in a pastebin link: Here it is: http://pastebin.com/7SBNccZm)
09:05:24 <NemesisD> i'm confused. why do cabal sandboxes still try to use installed user packages when trying to install dependencies
09:06:00 <tdammers> I think the idea is that you install common packages system-wide, and more specific ones in the sandbox
09:06:15 <tdammers> such that you don't have to pull in haskell-platform for every little project
09:06:32 <NemesisD> aka don't install anything not in platform to your user sandbox it seems
09:06:35 <NemesisD> erm user package db
09:06:39 <NemesisD> what a pain in the ass
09:06:49 <bergey`> NemesisD: They shouldn't use user packages (in  ~/.ghc).  They do use the global package-db.
09:07:26 <indiagreen> mustafa_: “array” doesn't create an unboxed array specifically
09:07:30 <indiagreen> it creates any array
09:07:30 <bergey`> Which is where packages go if you apt-get install or `cabal install --global`
09:07:39 <indiagreen> even if you import it from Data.Array.Unboxed
09:07:48 <indiagreen> so you should add a type signature to your function
09:08:33 <NemesisD> i don't install packalges with apt and don't use --global
09:09:17 <mustafa_> indiagreen: I thought that might be the problem, so I tried to solve it by adding :: IArray UArray Bool to the end of the blackBox declaration, but then ghci complained that "Expected a type, but ‘IArray UArray Bool’ has kind ‘Constraint’"
09:09:25 <indiagreen> IArray isn't a type
09:09:27 <indiagreen> it's a class
09:09:34 <indiagreen> you should've added just “UArray ...”
09:09:57 <mustafa_> :D
09:10:00 <mustafa_> Thanks!
09:10:00 <indiagreen> these names are a bit confusing
09:10:06 <bergey`> I've never seen the behavior you describe.  If cabal is pulling things from the user db into a sandbox, I'm pretty sure that's a bug.  If you post the output from cabal, preferably with -v3, I can try to help more.
09:10:26 <indiagreen> like, “IArray” is a class, but “UArray” and “Array” are types, and it doesn't make much sense
09:11:10 <mustafa_> I see... So You just use the IArray stuff and then use :: to designate what specifically you want?
09:11:16 <NemesisD> it seems to be related to doctest. i always have problems with it and ghc 7.6
09:12:54 <ski> brbblnch : iiuc .. if the types of `v',`u',`w' are atomic, then the degree of the redex `t' is `2', and of the redex `r' is `3'. after reducing, the degree of the modified `t' redex is now still `2' (but the redex of degree `3' has disappeared)
09:13:17 <indiagreen> mustafa_: yes, all operations here (http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-IArray.html) are common for all arrays, so you have to add a type signature
09:13:43 <mustafa_> Okay. Thanks! 
09:14:47 <bergey`> Does --constraint='transformers installed' help?  Things that use the GHC API are trickier to sandbox.
09:15:28 <bazqux> If I'm using aeson and I have JSON of the form {"foo": "bar"} is it possible to capture "foo" as well as "bar"?
09:15:37 <mustafa_> indiagreen: and now my sierpinski program works :) Thanks so much!
09:17:51 <brbblnch> ski: But if v has a type V of high degree n, the degree of the redex t is n+1 which is greater than the degree of r, no ?
09:18:58 * hackagebot jose-jwt 0.4.1.1 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.4.1.1 (LukeTaylor)
09:21:38 <indiagreen> bazqux: http://lpaste.net/128001
09:23:16 <indiagreen> bazqux: if this is not what you meant, then give more details
09:23:17 <bazqux> indiagreen: Interesting, thanks.
09:24:19 <ski> brbblnch : if `n' is high enough, then the redex `t' would have degree `n+1', yes. but then the degree of `r' would be at least `n+2' (perhaps more, depending on `w'). since the relevant type here would be `(V -> U) * W'
09:24:49 <bazqux> indiagreen: I think that is what I was after. :-)
09:27:46 <brbblnch> ski: Oh, yeah… Thanks for the help, I was quite desperate with that!
09:30:43 <ski> brbblnch : hm. i still don't really see what the problem was, but ok :)
09:35:02 <Big_G> How would I write the signature for a list of lists with an unkown depth?
09:35:35 <EvanR> data Tree a = Tree a [Tree a]
09:35:43 <Iceland_jack> Big_G: You can define a (rose) tree
09:36:14 <Iceland_jack> What EvanR said.
09:36:26 <Big_G> So I'd definitely have to make a custom data structure and not a regular list?
09:36:49 <Denommus> Big_G: yes, because it's not a regular list, you know
09:36:51 <Iceland_jack> Big_G: You can use a regular list with some gymnastics but you really don't want to
09:36:51 <EvanR> for [[[a]]], the elements "at the bottom" are not necessarily lists
09:37:03 <EvanR> but you want them to be
09:37:07 <Denommus> Big_G: just like [[a]] isn't a regular list
09:37:32 <quchen> [[a]] is a regular list with elements of type [a].
09:37:43 <Big_G> Would there be an easy way to write a function to accept regular lists and then convert it to the tree format?
09:37:44 <Denommus> quchen: ok, point taken
09:38:08 <quchen> Int is not a regular list.
09:38:48 <Iceland_jack> Big_G: You can insert each element into the rose tree (in which case it would simply be something like 'foldr insertRT emptyRT')
09:39:00 <quchen> Big_G: There's no canonical way to do that, but sure, you can create a tree out of a list in many ways.
09:39:24 <Big_G> I know I was able to do it without issue in Python which is why the question arose
09:39:27 <quchen> Big_G: A parser takes a lexer's resulting list of tokens and makes a parse tree out of the, for example.
09:39:32 <cschneid> what was that lens trick to apply and unapply a iso over a list? I want to `unSum $ map Sum [1,2,3,4]` which is redundant. 
09:39:37 <EvanR> python uses dynamic types
09:39:39 <ski> Big_G : alternatively `data Tree a = Leaf a | Branch [Tree a]' .. or perhaps you wanted the depth to be the same everywhere ? then `data NestList a = Here a | Nest (NestList [a])'
09:39:42 <quchen> cschneid: ala?
09:39:49 <cschneid> quchen: that sounds right. :)
09:40:05 <quchen> > ala Sum foldMap [1,2,3]
09:40:07 <lambdabot>  6
09:40:07 <EvanR> the tree structure essentially accomplishes the same thing, you can tell whether this element is a sub list or not
09:40:13 <Iceland_jack> Big_G: You structure your problems differently in different languages :) rather than writing language X in language Y etc.
09:40:30 <Big_G> Iceland_jack, Of course. Just hard to switch sometimes
09:40:42 <Iceland_jack> Yeah I gotcha
09:40:57 <ski> Big_G : writing `fromList :: [a] -> Tree a' should be easy .. but it's possibly not what you intended
09:41:07 <Iceland_jack> I second ski 
09:41:17 <EvanR> Big_G: its instructive to think about why it seems to work in python, and then consider your ways (tm)
09:41:42 <Welkin> EvanR: in python, it works via magic pixie dust
09:42:00 <Welkin> it fails if you don't offer enough souls to their god, though
09:42:43 <Big_G> Does a have to be a primitive like Int or can it be something more Complex like [Int]. Would [a] be able to represent [[Int]]?
09:42:55 <ski> Big_G : in Python, you can query the "type" of a value. this would be like always using `data Value = AnInt Int | ADouble Double | AList [Value] | ...' all the time (not that nice, even ignoring the extra syntactic noise)
09:43:03 <Big_G> Welkin, I have an open account with Guido already
09:43:07 <Iceland_jack> Big_G: Yes to your latter
09:44:10 <dncr> Has anyone implemented graph planarity testing in Haskell? I didn't see anything that I recognized in the undocumented Data.Graph.Inductive.Query.* modules of fgl.
09:44:13 <ski> Big_G : in dynamically typed languages, sometimes people use the same type of construction (say lists) for what in Haskell would be different types (corresponding to different kinds of usages), like tuples vs. lists
09:44:51 <Iceland_jack> Big_G: The main issue is that 'True :: Bool' and '[True, False] :: [Bool]' have different types, you can get the same effect as Python gets by creating a type (like ski's 'Value') so that 'True' and '[True, False]' have the same type and storing those in the list
09:44:53 <dncr> Nor in ~erwig's "Inductive Graphs and Functional Graph Algorithms" paper.
09:45:00 <quchen> Big_G: "a" in [a] can be *any* type. In fact [a] is short for "for all a, [a] is a type". [Int] is a type, so [[Int]] works fine when you identify "a" with "[Int]".
09:45:30 <ski> Big_G : if you want to roughly "treat all the elements on equal footing", then you probably want a (Haskell) list. if not, then not
09:46:18 <EvanR> Big_G: i think your original assumption was that in your list you want "regular elements" and "another list", which you can do with a list of a special type you make
09:46:21 <EvanR> to distinguish
09:46:33 <ski> Big_G : different intended usages call for different types. if you always want to have three elements, where the first is always a string, the second is a count (integer), and the third is any object, then you could use `(String,Int,a)' or define a new data type `data MyThing a = MkMyThing String Int a'
09:46:43 <Denommus> Big_G: my favorite way to represent what you want is with an ADT
09:46:59 <Denommus> Big_G: data Tree a = Leaf a | Node [Tree a]
09:47:30 <EvanR> thats a good one
09:47:36 <ski> Big_G : saying "nested lists" isn't enough to determine the intended usage. can you have elements at differents levels in the same nested list, or only at the same (bottom) level ?
09:48:16 <Big_G> ski, All leafs are ints and all branches are lists
09:48:18 <Welkin> a matrix?
09:48:19 <ski> Big_G : if only at the bottom level, then do you only want to handle a fixed number of levels (like three) ?
09:48:40 <Big_G> ski, No the lists are of any size and any depth
09:48:42 <ski> Big_G : &c. .. you need to determine the answer to questions like this, to find out the correct type for you
09:49:10 <Denommus> Big_G: see my solution, it describes what you want concisely
09:49:52 <ski> Big_G : you still haven't answered (that i can see) whether you want to allow both elements and lists at the same level
09:50:05 <Big_G> Denommus, Yeah. That looks like it should be what I want
09:50:23 <Big_G> ski, No. that shouldn't be allowed
09:50:31 <ski> Denommus : yea, i mentioned it a bit up, but possibly Big_G didn't notice it :)
09:50:34 <Denommus> Big_G: maybe you can call "Node" a "Branch" instead, since both leafs and branches are nodes
09:50:36 <Big_G> Denommus, Would that allow tuples to be at leaves instead of ints?
09:50:46 <Big_G> ski, There is too much text :)
09:50:52 <ski> yeah, i understand
09:50:57 <Denommus> ski: I also haven't seen it XD
09:51:05 <EvanR> Big_G wants a big tree of anything
09:51:06 <ski> Big_G : if we ignore the details of how to write it in Haskell, is `[1,[2]]' to be allowed ?
09:51:11 <Denommus> Big_G: any element will be on the leafs
09:51:23 <ski> Big_G : how about `[[0,1],[[2,3],[4,5]]]' ?
09:51:30 <EvanR> big trees of anything hurt
09:51:41 <Big_G> ski, No
09:51:47 <Big_G> to the first one
09:51:54 <ski> and the second ?
09:52:17 <Denommus> Big_G: the `a` there means a parametric type. So it can be Int, String, Float, (Pokemon, Digimon), or whatever you put there
09:52:35 <Big_G> ski, No
09:52:38 <Big_G> to the second
09:52:41 <ski> ok
09:53:27 <ski> Big_G : so then it seems my `data NestList a = Here a | Nest (NestList [a])' suggestion above is closer to what you want than my/Denommus's `Tree'
09:53:29 <NemesisD> does anyone know if there's a better algorithm for converting a string representing a number, e.g. "42" to a number? Currently i'm multiplying each positional character by increasing powers of 10 and then summing them
09:53:59 * hackagebot pokitdok 4.1.0.0 - PokitDok Platform API Client for Haskell  http://hackage.haskell.org/package/pokitdok-4.1.0.0 (Decryptic)
09:54:02 <EvanR> read ?
09:54:09 <Big_G> ski, Why do you think that?
09:54:26 <NemesisD> EvanR: algorithmically i mean
09:54:28 <ski> Big_G : using this, we can write (in Haskell) `Nest (Nest (Nest (Here [[[0],[],[1,2]],[[3],[4,5,6]]])))' -- this has type `NestList Integer'
09:54:42 <indiagreen> NemesisD: use a fold
09:54:48 <ski> Big_G : because this enforces that all the elements occur at the same level in the nested lists
09:55:06 <indiagreen> go over each character, convert it to digit, multiply the result you already have by 10 and add the digit
09:55:18 <ski> Big_G : it is not possible to express the above `[1,[2]]', nor the above `[[0,1],[[2,3],[4,5]]]', using this type
09:55:31 <int-e> NemesisD: are you reading big numbers?
09:55:32 <fiola> NemesisD:  You could take the digits 2 at a time and multiply by 100, and so on :P
09:55:36 <Big_G> ski, Ah, that makes sense. Have all of the example data you've been sending been ADTs?
09:55:50 <NemesisD> int-e: not too big no, this is in a parser
09:56:04 <indiagreen> fiola: +
09:56:30 <ski> Big_G : however, there is one more option. `NestList' doesn't keep track in the types of the number of levels in a nest-list, so if you have two of them, the only way to check that they have the same number of nested levels would be to count the number of `Nest' constructors in each, comparing
09:57:12 <int-e> NemesisD: ok, then there's no point in going beyond the simple folding approach (n, followed by a digit d, evaluates to n*10 + d).
09:57:23 <ski> Big_G : the other option is to keep track of the number of nested levels in the type. then the above example would have a type like `NestList (Succ (Succ (Succ Zero))) Integer' (perhaps you can write that as `NestList 3 Integer' with some extension, i don't recall)
09:57:32 <NemesisD> int-e: ok, just figured i'd check
09:58:28 <ski> Big_G : "Have all of the example data you've been sending been ADTs?" -- `[1,[2]]' and `[[0,1],[[2,3],[4,5]]]' was just vague pseudo-code to check what you wanted to be able to express and what shouldn't be possible to be expressed
09:58:48 <Big_G> ski, I meant the data a = tree ..
09:58:59 * hackagebot servant-jquery 0.2.2.1 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.2.2.1 (jkarni)
09:59:02 <ski> Big_G : other than that, all the `data' declarations and the `Nest'&`Here'-example was using Algebraic Data Types, yes
09:59:20 <ski> (ADT could also mean *Abstract* Data Type, which i wasn't talking about here)
09:59:27 <fiola> NemesisD:  Fast conversion is done by table lookup though, which would be harder to do in O(1) with 2-digit sequences. With single digits you only need a 256-byte table, or generally 128 will do.
09:59:43 <Big_G> So you were using Algebraic DTs and not Abstract DTs?
10:00:07 <Denommus> Big_G: yes
10:00:14 <ski> Big_G : so .. there's a bit of a trade-off here -- you could use a datatype that is more flexible (allowing more that you don't really care for, or don't want) .. or one that is more strict (but perhaps slightly more cumbersome to work with)
10:00:42 <ski> Big_G : `data' in Haskell introduces a new algebraic data type
10:02:15 <Denommus> abstract data types are typeclasses
10:02:21 <ski> no
10:02:33 <ski> Big_G : assuming you don't change your mind about what you want to allow and not allow, i'd suggest to try to use `NestList', and see if you can use it to do whatever you wanted to do (possibly coming back here if you can't see how to express some specific operation that you think you should be able to express)
10:02:50 <lpaste> ryanar pasted “toDigits function” at http://lpaste.net/128003
10:03:05 <ski> Big_G : *maybe* the option that keeps track of the number of levels in the type is more appropriate, but it's also a bit more technical ..
10:03:26 <Ryanar> Hey all, not really sure how to implement this helper function
10:04:03 <ski> Big_G : if you can't make `NestList' work, you should be able to fallback to the more lenient `data Tree a = Leaf a | Branch [Tree a]', even though it's not as accurate (so there'll be more opportunity for useless error conditions in your code)
10:04:29 <Big_G> I'll experiment with it and see what happens
10:04:35 <ski> Denommus : type classes are one *way* to capture an abstract data type
10:04:47 <ski> (or rather, the interface of it)
10:04:57 <Iceland_jack> Ryanar: The type of 'helper' should be 'helper :: Integer -> [Integer] -> [Integer]' right?
10:05:21 <ski> Denommus : `Integer' is an abstract data type. so is `IO' and `Double' and `(->)'
10:05:24 <fiola> ryanar: Generally avoid ming functions "helper" or "step", etc.  A lot of FP books have got into that habit, but it's a very bad one, since the name tells the reader nothing about its function and it becomes poorly declarative.
10:05:25 <ski> and `Set'
10:05:26 <Ryanar> Iceland_jack, theoretically yes, though I get all sorts of compiler errors
10:05:30 <Iceland_jack> Ryanar: You seem to be calling it with 4 arguments here
10:05:30 <Iceland_jack>     helper div x 10 (mod x 10 : [])
10:05:36 <fiola> s/ming/naming/
10:06:08 <Ryanar> div x 10 should give a single integer x/10 right?
10:06:12 <Iceland_jack> Ah
10:06:18 <Iceland_jack> You need to parenthesise it
10:06:26 <dmj`> :t (/)
10:06:27 <lambdabot> Fractional a => a -> a -> a
10:06:28 <dmj`> :t div
10:06:29 <Ryanar> and then (mod x 10 : []) should give the result of mod x 10 cons'd to empty list
10:06:29 <lambdabot> Integral a => a -> a -> a
10:06:31 <Iceland_jack>     helper (div x 10) (mod x 10 : [])
10:06:34 <Ryanar> oh
10:06:37 <dmj`> slighlty different
10:06:51 <Ryanar> I didnt think I would need to
10:06:53 <Ryanar> heh
10:06:54 <Iceland_jack> Then it works Ryanar
10:06:56 <quchen> fiola: There are names that have cultural meaning. folding or recursing with "go" is a popular idiom, and it's pretty much an anonymous function that you had to give some name.
10:07:30 <fiola> But still better when you se a descriptive name.
10:07:36 <quchen> fiola: I don't think you could give the function in "foldl expressed with foldr" a good name, for example. That's where "go" comes in handy.
10:08:11 <Ryanar> As far as the naming of that goes, should it be something like peel_x_into_list?
10:08:19 <Iceland_jack> Ryanar: One thing you could have done is giving 'helper' an explicit type signature and using 'undefined' as a placeholder body definition just to see it that compiles
10:08:20 <Iceland_jack>     where helper :: Integer -> [Integer] -> [Integer]
10:08:20 <Iceland_jack>           helper a b = undefined
10:08:36 <Ryanar> Ah I see
10:08:41 <fiola> I seem to be dropping characters today, odd.  Coffee needed perhaps.
10:08:43 <Ryanar> thanks for that tip
10:08:55 <Iceland_jack> Then incrementally adding clauses
10:08:55 <Iceland_jack>     helper x [] = helper undefined undefined
10:08:55 <Iceland_jack>     
10:08:59 <Iceland_jack> until something fails :)
10:09:08 <Ryanar> Iceland_jack, writing that strategy down, haha
10:09:09 <ski> fiola : keyboard is thirsty ?
10:09:18 <x77686d> I'm curious about how often experienced Haskell programmers use primitive recursion vs. higher-order functions.  If you're an experienced Haskell programmer, how would you characterize your use of recursion?  "Rarely"?  "Often"?  50/50?
10:09:36 <fiola> Iceland_jack: +1 on type signature advice
10:09:41 <Iceland_jack> x77686d: It depends a lot on the problem domain
10:09:44 <edwardk> :t beneath
10:09:45 <lambdabot> Not in scope: ‘beneath’
10:09:50 <ski> x77686d : more often than in strict programming languages
10:09:52 <edwardk> :t below
10:09:52 <lambdabot> (Choice p, Traversable f, Applicative f1) => APrism' s a -> p (f a) (f1 (f a)) -> p (f s) (f1 (f s))
10:10:01 <Ryanar> fiola, I find im addicted to coffee, and I think its the reason I never sleep well, it creates this vicious cycle where you don't sleep well with caffeine in your system, leading to you feeling tired and needing the "boost" of energy from more caffeine
10:10:03 <edwardk> ^- cschneid 
10:10:18 <fiola> ski: keyboard taking a slice of the action, creaming off the top?
10:10:36 <cschneid> edwardk: while I'm sure that helps, reading lens type sigs is something I've not yet fully grown into :)
10:10:43 <dolio> ski: I think it's more realistic for seq to be useful for tuples. But it's kind of unfortunate that the breaks the semantics.
10:10:55 <ski> fiola : perhaps :)
10:11:03 <Iceland_jack> x77686d: If you're working with a library of lists or you can quite often take the 'wholemeal' approach and just use combinators to do what you want
10:11:23 <x77686d> Iceland_jack: thx
10:11:25 <Iceland_jack> But if you're working with some language/AST you quite often just pattern match on cases
10:11:48 <x77686d> ski: thx
10:11:57 <Iceland_jack>     eval (Plus x y)         = eval x + eval y
10:11:57 <Iceland_jack>     eval (IfThenElse c t e) = if eval c then eval t else eval e
10:12:41 <Iceland_jack> But it's not often that you prefer a recursive solution when there is a nice way of expressing it with functions/combinators
10:13:16 <ski> x77686d : see "Reuse" under <http://augustss.blogspot.hu/2011/05/more-points-for-lazy-evaluation-in.html>
10:13:29 <ski> dolio : any use case for `seq' on tuples ?
10:13:51 <int-e> quchen: just an idea for a name: how about  foldl f a xs = foldr f_cps id xs a where f_cps x cont a = cont (f a x)
10:14:10 <x77686d> Appreciated!  Anybody else care to offer a thought?
10:14:38 <quchen> int-e: And "cont" is a descriptive name?
10:14:47 <int-e> quchen: sure, for a continuation.
10:15:33 <quchen> f is also a function, yet "function" would not make a good name.
10:15:33 <int-e> quchen: I may have used continuations a bit too much in the past, so I tend to abbreviate the term to  cont  or  cnt.
10:15:33 <Iceland_jack> Ryanar: (for future reference, GHC 7.10 includes natural numbers (0,1,2...) in Numeric.Natural so 'toDigits :: Natural -> [Natural]' wouldn't have to check for the 'x <= 0' case)
10:16:03 <Iceland_jack> Ryanar: the 'toDigits 0 = []' case is also redundant: it is caught by your helper function 
10:16:05 <Ryanar> Oh, that is useful
10:16:36 <Ryanar> Oh, heh, I didnt even think about that redundancy
10:16:41 <x77686d> ski: Good link--thanks!
10:16:48 <cschneid> how does Natural work? is there a doc about it somewhere
10:17:08 <shachaf> int-e: Everyone knows that "k" stands for "kontinuation".
10:17:50 <int-e> shachaf: Well, I never liked those k very much.
10:17:59 <Denommus> ski: that's true
10:18:39 <quchen> "k" is probably fine in a setting that's clearly about continuations.
10:18:46 <int-e> In any case, I was just trying to suggest that 'f_cps' may be a suitable name for the helper function for foldl-in-terms-of-foldr. I didn't want to discuss the name of continuations.
10:18:55 <quchen> It certainly wouldn't help to call your continuation (>>).
10:18:59 * hackagebot cmark 0.3.0.1 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.0.1 (JohnMacFarlane)
10:19:15 <dolio> ski: Not creating lots of thunks in an accumulator.
10:19:42 <shachaf> I don't think f_cps is a very good name.
10:19:50 <shachaf> But I don't think it mattrs that much either.
10:19:59 <Welkin> "k" also stands for "kontention"
10:20:07 <ski> dolio : hm, oh of course
10:20:12 <ski> x77686d : also see such frameworks as Scrap Your Boilerplate, Compos, Uniplate, Biplate, Multiplate, Multirec
10:20:40 <int-e> And I wouldn't really use the name; personally I'm content with  foldl f a xs = foldr (\x xs a -> xs (f a x)) id xs a, not giving it a name at all.
10:20:48 <dolio> ski: I feel like that's a more significant concern for tuples than for functions.
10:23:25 <ski> x77686d : <https://www.haskell.org/haskellwiki/Uniplate>,<http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm>,<https://www.haskell.org/haskellwiki/Multiplate>,<https://hackage.haskell.org/package/multirec>,<http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf>,<http://foswiki.cs.uu.nl/foswiki/GenericProgramming/SYB>
10:26:38 <ski> x77686d : those are for removing some of the tedium of writing more or less standard recursions explicitly. a bit like recursion schemes (fold/catamorphism, unfold/anamorphism, paramorphism, &c.. see <https://hackage.haskell.org/package/recursion-schemes>,<http://comonad.com/reader/2009/recursion-schemes/>,<https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms>)
10:27:51 <ski> dolio : *nod*
10:28:05 <x77686d> ski: wow!
10:28:35 <ski> x77686d : granted, these latter links are more tangential to your original question .. but could be interesting regardless
10:29:05 * hackagebot wordpass 1.0.0.3 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.3 (MichalGajda)
10:35:51 <ais_> how does <- know how to draw from a Monad?
10:36:41 <yac> how can I find out if a package is bundled with ghc?
10:36:48 <int-e> @undo do x <- foo; bar x
10:36:48 <lambdabot> foo >>= \ x -> bar x
10:36:49 <napping> ais_: it uses >>=
10:37:18 <ais_> napping, does it draw from Applicative too?
10:37:46 <napping> for now, it's always translated to >>=
10:41:23 <hunt> whats the standard way of installing up to date haskel on macs?
10:41:31 <hunt> the one on the haskell website is old, right?
10:41:46 <byorgey> hunt: https://ghcformacosx.github.io/
10:41:51 <Guest24562> thanks bra
10:41:53 <Welkin> I use haskell platform
10:42:25 <Guest24562> is it up to date?
10:42:35 <Guest24562> i thought the haskell platform was notoriously unupdated
10:42:39 <Welkin> no
10:42:42 <Welkin> it is fine
10:42:46 <Welkin> it is 7.8.x
10:42:57 <Guest24562> also what're the standard 2d graphics packages
10:43:10 <Guest24562> meh i already started downloading haskell for mac so ill just stick with it
10:44:05 <byorgey> Guest9000: https://ghcformacosx.github.io/ includes the Haskell Platform, plus a bit of other stuff to make the installation seamless
10:44:25 <byorgey> sorry, I meant Guest24562 
10:44:58 <byorgey> Guest24562: what kind of 2d graphics do you want to do?
10:45:12 <Guest24562> game graphics
10:45:20 <Guest24562> so OpenGL basically
10:45:27 <Guest24562> but i was hoping there might be something more high level
10:45:39 <Guest24562> although I'm no enemy of opengl
10:47:31 <Guest24562> im not even sure what the OpenGL lib is called
10:47:38 <Guest24562> so really any pointers are very useful
10:47:47 <byorgey> Guest24562: well, for OpenGL bindings see e.g. http://hackage.haskell.org/package/gl
10:48:25 <byorgey> you might also be interested in https://lambdacube3d.wordpress.com/
10:49:05 * hackagebot highlighting-kate 0.5.12 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.12 (JohnMacFarlane)
10:49:42 <byorgey> Guest24562: you can also take a look at  http://hackage.haskell.org/packages/search?terms=GL to see what else is out there
10:50:01 <Guest24562> thanks!
11:00:22 <napping> Is there any workaround for injective type families? I'd like to be able to use a type-level map
11:00:52 <shachaf> What about injective type families?
11:01:06 <napping> They're not available yet
11:02:01 <shachaf> Oh. I didn't even know they were going to be available.
11:02:05 <exio4> data families are supposed to be injective, aren't they? 
11:03:25 <napping> yeah, but those are completely separate types
11:04:41 <napping> actually, I think I can just unfold one side myself to fix my code
11:05:10 <napping> but in general I'm thinking of something like TMap Maybe '[ Char, String, Integer ] --> '[Maybe Char, Maybe String, Maybe Integer]
11:05:47 <napping> A data family couldn't use existing type constructors in the result
11:11:56 <fiola> Constructive Solid Geometry sounds like an ideal match for a Haskell GL-based widget set.  The composition of functions could be made to mirror compositional effects in the graphics, making a nice DSL.
11:15:46 <enthropy> napping: you could make a type family TUnmap f xs; type instance TUnmap f (f x ': xs)  x ': TUnmap f xs
11:16:29 <enthropy> but doing that will probably break in 7.10: https://ghc.haskell.org/trac/ghc/ticket/10009
11:17:52 <napping> looks like that will be temporary
11:18:29 <clrnd> monoids seems to be deprecated, but I need semi-near-rings, any alternative?
11:19:18 <dmj`> :t (<|>)
11:19:19 <lambdabot> Alternative f => f a -> f a -> f a
11:19:23 <dmj`> there's some alternative
11:19:28 <enthropy> you mean they are going to fix the problem?
11:19:41 <indiagreen> I think I missed it
11:19:46 <indiagreen> when were monoids deprecated
11:20:25 <dmj`> I don't think you can deprecate typeclasses
11:21:17 <hunteriam> ghc-pkg: cannot create: dist/package.conf.inplace already exists
11:21:22 <hunteriam> I'm having a nightmare of a time right now
11:21:41 <hunteriam> all i did was cabal sandbox init, cabal init, then i installed my dependancies
11:21:45 <indiagreen> well, just remove the file
11:21:49 <indiagreen> it happens sometimes
11:21:54 <hunteriam> i then learn that none of them have been added to my cabal build-depends
11:22:10 <hunteriam> and when i try to add them manually i get that it failed to parse build-depends
11:22:23 <clrnd> :P <|> ಠ_ಠ
11:22:38 <indiagreen> can you paste it
11:22:42 <hunteriam> could someone give me an example build-depends?
11:22:45 <indiagreen> I mean, your build-depends section
11:22:46 <hunteriam> yea ill paste it
11:22:54 <hunteriam> i think i just have the wrong separator for my depends
11:22:59 <clrnd> http://hackage.haskell.org/package/monoids-0.1.2 <-- this monoids
11:23:01 <hunteriam> base >=4.7 && <4.8 && OpenGl && GLUT
11:23:18 <indiagreen> you're supposed to use a comma
11:23:25 <indiagreen> base >=4.7 && <4.8, OpenGl, GLUT
11:23:26 <hunteriam> ah ok
11:23:32 <hunteriam> :t &&?
11:23:33 <lambdabot> parse error on input ‘&&?’
11:23:36 <hunteriam> :t &&
11:23:37 <lambdabot> parse error on input ‘&&’
11:23:40 <indiagreen> :t (&&)
11:23:41 <lambdabot> Bool -> Bool -> Bool
11:23:50 <indiagreen> .cabal files aren't written in Haskell anyway
11:23:52 <hunteriam> I'm very rusty
11:23:58 <indiagreen> clrnd: ah
11:26:21 <napping> enthropy: the discussion on the ticket suggests they intend to fix it and have tried a few times, then just missed out on including it in the RC
11:28:20 <lpaste> napping pasted “injective type family?” at http://lpaste.net/128008
11:29:19 <napping> Turns out the injectivity was actually about needing a proxy argument to figure out "sig", but I'm again stuck
11:36:12 <ouanixi> Hi guys, teaching myself haskell and I'm now struggling with an exercise
11:36:36 <ouanixi> how can one map a function over all values of a Rose tree?
11:37:38 <ouanixi> Here's the definition of the tree      data RoseTree a = Node a [RoseTree a] 
11:37:55 <ouanixi> and what I tried so far
11:37:56 <ouanixi> mapRose f (Node x (y:yx))  = Node (f x) ((mapRose f y) : mapRose yx)
11:39:23 <ReinH> ouanixi: In mapRose f y, y is of type RoseTree a. In mapRose yx, mapRose is only being applied to one argument and that argument is a list.
11:39:52 <ReinH> ouanixi: you need to treat the element y and the list yx differently
11:40:39 <ReinH> (As a minor aside, the convention would be to name the vars (y:ys))
11:40:59 <ouanixi> ReinH: yx is a list of RoseTrees isn't it ?
11:41:03 <ReinH> ouanixi: Yes.
11:41:13 <ouanixi> hmm
11:41:28 <ouanixi> ok thanks, I'll keep thinking :)
11:41:44 <ouanixi> ReinH: Thank you!
11:41:48 <ReinH> ouanixi: do you already have a function that maps a function onto a list?
11:42:23 <ouanixi> ReinH: I think I do yes.
11:42:35 <ReinH> I kind of gave it away ;)
11:42:45 <ouanixi> ReinH: haha you did
12:05:22 <parnmatt> @pl \xs -> f xs - g xs
12:05:22 <lambdabot> liftM2 (-) f g
12:07:19 <ReinH> I wish we had time to ask these drive by lambdabot users to pm instead
12:07:51 <EvanR> yeah fuck those guys
12:08:34 <t7> yumadtho?
12:08:59 <t7> 为什么你很生气? 
12:09:06 * hackagebot pokitdok 4.1.0.1 - PokitDok Platform API Client for Haskell  http://hackage.haskell.org/package/pokitdok-4.1.0.1 (Decryptic)
12:09:57 <parnmatt> @pl \xs -> f xs - g xs
12:09:57 <lambdabot> liftM2 (-) f g
12:10:16 <EvanR> you can use PM
12:10:38 <f|`-`|f> ah yes, the "List is in CLass Monad"
12:11:15 <mauke> parnmatt: HELLO
12:11:43 --- mode: ChanServ set +o mauke
12:11:43 --- mode: mauke set +q $a:parnmatt
12:12:02 <EvanR> 01134
12:12:12 <ReinH> Are they not aware that it's rude? Do they not care? I have so many questions.
12:12:41 <ReinH> Maybe they don't know that you can /msg lambdabot. Now we may never know.
12:12:43 <ReinH> Anyway
12:12:59 <EvanR> the dare disturb the peace tranquility silence of the channel *returns to the rock garden*
12:13:01 <mauke> maybe if he comes back yet again (within the next 30 minutes)
12:13:42 <ski> would a `@tell' help ?
12:13:43 --- mode: mauke set -o mauke
12:15:03 <shachaf> @tell doesn't get triggered by lambdabot commands.
12:18:26 <nh2> what can be benefits of using an associated type vs. a "plain" type family?
12:19:40 <Iceland_jack> nh2: http://stackoverflow.com/questions/28247832/type-families-top-level-vs-associated would this help?
12:20:22 <Iceland_jack> (type families that aren't associated are sometimes called "unassociated type families" when a distinction is being made)
12:21:40 <EvanR> is there a maxBy
12:21:47 <Iceland_jack> :t maximumBy
12:21:48 <lambdabot> (a -> a -> Ordering) -> [a] -> a
12:21:51 <EvanR> ah
12:22:06 <clrnd> :t comparing
12:22:06 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:22:07 <Iceland_jack> nh2: https://wiki.haskell.org/GHC/Type_families notes " Each of these flavors can be defined in a standalone manner or associated with a type class. Standalone definitions are more general, while associated types can more clearly express how a type is used and lead to better error messages. "
12:22:21 <EvanR> :t maximumBy (comparing snd)
12:22:22 <lambdabot> Ord a => [(a1, a)] -> (a1, a)
12:24:24 <Iceland_jack> nh2: It also has non-technical reasons, associated data/type families signal intent and a correspondence to the type class
12:26:56 <nh2> Iceland_jack: thanks. The motivation why I'm asking is: My class `Myclass` has an associated type `MyFamilyInstanceOf` and a function `myfun`. I want to separate the two, so that I can separate giving the type family instance and what `myfun` shall be for my type.
12:26:56 <nh2> For example, I currently have a package `mypackage` and wish to split it into `mypackage-types` and `mypackage-impl`, where things like `MyFamilyInstanceOf Int` are supposed to go into `mypackage-types` and `instance Myclass Int where myfun = ...` shall go into `mypackage-impl`
12:27:30 <nh2> according to the resources you linked, using non-associated typeclasses would let me do that all fine
12:28:38 <nh2> Now I wonder though how it would compare to making a superclass `MyclassTypes` that defines the `MyFamilyInstanceOf`, and having `Myclass` use that: `class (MyclassTypes c) => Myclass c where ...`
12:28:46 <nh2> might this be better in terms of error messages?
12:29:46 <Iceland_jack> nh2: Is there a reason why you want to separate the two? If the methods of ‘Myclass’ depend on the type family then you will never define an ‘instance Myclass’ without creating an associated type right?
12:30:32 <Iceland_jack> Or will you ever use the type ‘MyFamilyInstanceOf’ without using ‘Myclass’?
12:33:22 <nh2> the second: Or will you ever use the type ‘MyFamilyInstanceOf’ without using ‘Myclass’?
12:33:22 <nh2> I will use this to provide a set of `-types` packages, for the reason that I need to avoid that those packages link in the actual code that implements `myfun`
12:35:26 <Iceland_jack> Should be fine
12:36:36 <breadmonster> Hey guys.
12:36:47 <threestrikes> Hi
12:36:53 <breadmonster> I'm writing a lexer for Python.
12:37:14 <breadmonster> And I've declared an ADT Token, which represents a token.
12:37:31 <breadmonster> And I'd like to do something like type TokenStream = [Token]
12:37:51 <breadmonster> Except, if I do that, can I override the instance of Show for TokenStream?
12:38:28 <ParahSailin> you cannot, but you may make your own Show instance for a newtype
12:38:42 <breadmonster> Or if I instead use `newtype TokenStream = [Token]` will that mean I can't use any list processing functions?
12:39:06 <hunteriam> can someone help me debug these OpenGL problems?
12:39:17 <hunteriam> when i draw a sphere with a radius > 1 it turns into a square
12:39:19 <dolio> Show is specifically designed to allow you to override the behavior of show on lists of things.
12:39:31 <hunteriam> heres the formula I'm using with the renderPrimitive Polygon
12:39:45 <hunteriam> [(r * sin (2*pi*i/n),r * cos (2*pi*i/n),0) | i <- [1..n]]
12:39:52 <ouanixi> ReinH: I've managed it thank you. Here's what I've done
12:39:52 <hunteriam> anyone know why this is a square when r > 1?
12:40:40 <ParahSailin> ah, Show doesnt define an instance for [a]
12:40:40 <hunteriam> can anyone assist me here?
12:40:58 <hunteriam> how could it?
12:41:06 <hunteriam> it'd just be [a, a, a...]
12:41:42 --- mode: ChanServ set +o mauke
12:41:43 --- mode: mauke set -q $a:parnmatt
12:42:20 <ParahSailin> @source Show
12:42:21 <lambdabot> Unknown command, try @list
12:42:34 <breadmonster> @source show
12:42:34 <lambdabot> Unknown command, try @list
12:42:44 <ParahSailin> @src Show
12:42:45 <lambdabot> class  Show a  where
12:42:45 <lambdabot>     showsPrec :: Int -> a -> ShowS
12:42:45 <lambdabot>     show      :: a   -> String
12:42:45 <lambdabot>     showList  :: [a] -> ShowS
12:43:04 <hunteriam> [(r * sin (2*pi*i/n),r * cos (2*pi*i/n),0) | i <- [1..n]]
12:43:15 <hunteriam> in OpenGL this is a square with r > 1
12:43:25 <hunteriam> please someone assist, i have no idea where to start with debugging this
12:43:42 --- mode: mauke set -o mauke
12:44:11 <arkeet> those look like the right vertices, so something is going funny when you're drawing it I guess.
12:44:22 <arkeet> I'm assuming n is large, and not 4.
12:44:24 <hunteriam> yea, any ideas what that might be?
12:44:29 <hunteriam> n is 10 right now
12:44:36 <hunteriam> I'm just trying to familliarize myself with opengl
12:44:49 <breadmonster> arkeet: Can you give me a slight hand?
12:44:50 <ski> breadmonster : you can "override the instance of Show for" `Token', by defining `showList'
12:44:52 <hunteriam> so i really don't know what things to check out for why my sphere is a square
12:45:06 <hunteriam> circle*
12:45:17 <breadmonster> ski: showList :: TokenStream -> String?
12:45:32 <ski> yes, with `type TokenStream = [Token]'
12:45:50 <ski> breadmonster : well, `ShowS' as result, not `String'
12:45:55 <breadmonster> ski: is there some class I need to instantiate?
12:45:56 <ski> (see above)
12:46:02 <ski> breadmonster : it's called `Show'
12:46:03 <breadmonster> @src ShowS
12:46:03 <lambdabot> type ShowS = String -> String
12:46:11 <breadmonster> Okay, yeah, perfect.
12:46:31 <breadmonster> Wait, one second.
12:46:34 <ski> breadmonster : `instance Show Token where ...; showList toks = ...'
12:46:47 <breadmonster> okay, so implement both?
12:46:50 <breadmonster> Perfect.
12:47:10 <ski> breadmonster : btw, note that if you want a custom pretty-printing out otherwise display your data not as a Haskell expression, it's better to not use `Show' at all
12:47:36 <arkeet> the idea of Show is that its output should look like a haskell expression
12:47:39 <arkeet> that can be read back with Read
12:47:55 <arkeet> it's not for pretty printing.
12:47:56 <dolio> More importantly, it should be able to be pasted in a source file.
12:47:57 <breadmonster> ski: Okay, fine, I think that's best.
12:48:03 <ski> breadmonster : imho, if you make an instance of `Show', then you should try to make it output a valid string representation of a Haskell expression that in the correct environment can be evaluated to a value equal to the original one
12:48:20 <breadmonster> Yeah, no, that's not what I was using it for.
12:48:26 <breadmonster> I was basically just pretty printing it.
12:48:48 <ski> ok, then i'd advice to just define a new function, `displayToken' or whatever you want to call it
12:48:51 <arkeet> hunteriam: maybe if you showed more code we might be able to help.
12:48:57 <arkeet> like how exactly you're drawing it
12:49:10 <arkeet> and how you're setting up opengl
12:49:10 <hunteriam> arkeet sure although its not very particular
12:49:23 <hunteriam> I'm almost certain that part is fine and that theres something i haven't set that i should
12:49:25 <hunteriam> ill paste it though
12:49:27 <breadmonster> ski: Okay, will do.
12:49:29 <breadmonster> Thanks (:
12:50:12 <hunteriam> arkeet: http://lpaste.net/128011
12:50:15 <ski> breadmonster : normally, only define a new type class if you have at least two different instances in mind, and think twice then anyway
12:50:32 <hunteriam> anyone who was looking for my gl code to help me draw circles larger than radius 2, http://lpaste.net/128011
12:50:59 <breadmonster> ski: You mean instantiate?
12:51:30 <geekosaur> define
12:51:44 <EvanR> @djinn (c -> (a -> b)) -> (c -> a) -> (c -> b)
12:51:44 <lambdabot> f a b c = a c (b c)
12:51:49 <ski> breadmonster : no. in some cases there could be a case for making a new type class `class PrettyPrint a where ...' -- but it's not evident it would help much in your case
12:51:50 <EvanR> is this already some combinator
12:52:23 <EvanR> ... <*>
12:52:24 <ski> EvanR : it's the `S' combinator. `ap' for the `(rho ->)' monad fits the bill
12:52:31 <ski> also `(<*>)', yes
12:52:44 <EvanR> doh
12:53:07 <ski> @quote aztec
12:53:07 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:53:40 <arkeet> hunteriam: well, it seems to do what I'd expect.
12:53:59 <arkeet> if you give it a large enough radius it fills the entire screen.
12:55:13 <hunteriam> although if i resize the screen and give it a big radius id think it wouldn't?
12:55:26 <arkeet> no
12:55:34 <hunteriam> ah!
12:55:37 <hunteriam> so what do i need to do
12:55:41 <hunteriam> to solve that
12:56:00 <hunteriam> how do i resize the render area
12:56:03 <arkeet> well first of all you're not resizing the viewport when the window is reshaped.
12:56:23 <hunteriam> ok, googling it
12:56:31 <hunteriam> and second?
12:56:32 <arkeet> second, without any sort of transformation matrices, the viewport will just cover -1 to 1 for x and y.
12:56:39 <arkeet> no matter the size of the viewport.
12:57:00 <arkeet> so if you resize the viewport without doing anything else it'll just stretch the image.
12:57:16 <teurastaja> if i understand well, a monoid would be a folded upon object?
12:59:17 <hunteriam> arkeet: i see... i don't know anything about using transformation matrices properly... ill have to do a bit of research for that i think
12:59:22 <levi> teurastaja: That's not how I usually think of a monoid, but maybe explaining more about what you mean by "folded upon object" would help me see whether it's close to how I think of them.
12:59:50 <jackhill> :q
13:00:29 <arkeet> a monoid is just a thing where you can squish zero or more elements together to get another element.
13:00:56 <arkeet> like if you have a bunch of numbers, you can add them.
13:01:05 <arkeet> or if you have a bunch of lists, you can concatenate them.
13:01:19 <teurastaja> levi: an object that has an accumulated value and an accumulation operator, takes an external value and "folds" it to the new value?
13:01:22 <levi> And folding is a summarization process via an operator and a unit.
13:02:57 <teurastaja> so what is the difference between a "folded upon object" and a monoid?
13:02:58 <hunteriam> a monoid is a set S for which there exists a function f: S x S -> S
13:03:02 <hunteriam> is that correct?
13:03:09 <arkeet> (and the order of the elements matters, in general. and it has to be coherent, i.e. if you group some elements together, squish the groups, and then squish the resulting elements from each group, it's the same as squishing everything together in one go.)
13:03:16 <dolio> No, that's a magma.
13:03:18 <levi> So a monoid is definitely something you can fold, but I'm not sure I'd use that to characterize what a monoid is.
13:03:37 <teurastaja> which is a magma? my definition or his?
13:03:43 <hunteriam> mine i think
13:03:44 <dolio> hunteriam's
13:03:52 <arkeet> teurastaja: I don't think anyone else is clear on what a "folded upon" object is.
13:04:11 <arkeet> hunteriam: there are some extra conditions.
13:04:11 <dmwit> that's not a magma, either, just a set
13:04:26 <arkeet> oh, yeah.
13:04:31 <teurastaja> i thought it was like an accumulated value with an accumulation operation
13:04:35 <dmwit> magma's have a -specific- choice of f
13:04:39 <hunteriam> dmwit: what i defined is not a magma?
13:04:40 <arkeet> it's not just "there exists", the function is part of the data.
13:04:51 <arkeet> there is always a function S x S -> S, for any set S.
13:04:52 <hunteriam> arkeet: the function is a member of the set?
13:05:14 <dolio> No. It's, "a magma is a set together with a function ...'
13:05:16 <arkeet> a magma is a pair of (S, f: S x S -> S)
13:05:17 <arkeet> where S is a set.
13:05:22 <dmwit> hunteriam: yes, i was talking about your definition
13:05:39 <arkeet> magmas aren't very useful.
13:05:40 <dolio> The function is not a member of the set (necessarily).
13:05:42 <hunteriam> so how would we define a monoid? ill just look it up
13:05:55 <arkeet> a monoid is a particular kind of magma.
13:06:15 <dmwit> magma with an identity atd the operation is associative
13:06:38 <teurastaja> i thought a magma was a set closed under composition
13:07:20 <hunteriam> a magma appears to be the grouping of a set closed under some computation, and the computation
13:07:23 <hunteriam> according to wikipedia
13:07:28 <dmwit> what is "composition" there?
13:08:02 <hunteriam> i love how mathy haskell is
13:08:06 <hunteriam> its definitely the future
13:08:24 <EvanR> the future is the past, today (tm)
13:08:51 <teurastaja> an "operation" which takes 2 members within the magma and creates another value which is closed under that magma?
13:08:59 <hunteriam> EvanR: i steal your tm
13:09:14 <KaneTW> lawsuit inc
13:09:16 <hunteriam> teurastaja: the magma is the set and the function
13:09:46 <dmwit> teurastaja: then yes. but that is a very nonstandard use of "composition"
13:09:46 <hunteriam> teurastaja: its basically a tuple of (S, S -> S -> S)
13:10:26 <teurastaja> so monoids can be used to fold objects but are more general? in what way?
13:10:30 <dolio> In the future, people may actually use ideas from 30 years ago instead of 50 years ago (but it will probably be 50 years ago, then).
13:11:00 <teurastaja> sorry but what is (S, S -> S -> S) ?
13:11:27 <dmwit> every monoid is a magma if you forget about the identity
13:11:36 <yac> teurastaja: it's a tuple
13:11:52 <hunteriam> arkeet: sorry, I'm having a hard time figuring out how i can resize the viewport independent of its contents, could you point me in the right direction?
13:11:57 <dmwit> so i would call monoid less general than magma
13:12:05 <hunteriam> teurastaja: a magma
13:12:19 <hunteriam> teurastaja: or do you not understand the notation?
13:12:22 <ais_> what should i do when cabal cant resolve dependencies?
13:12:23 <teurastaja> i figured it looked like a pair (a,b), but what does S -> S -> S do?
13:12:44 <hunteriam> teurastaja: its a function that takes two elements of the set S as input, and outputs another element of S
13:12:48 <yac> teurastaja: function from S to S to S
13:12:56 <hunteriam> teurastaja: think of S as a haskell type
13:13:24 <teurastaja> oh! makes sense! its like a translation of the magma axiom right?
13:13:38 <dmwit> i don't like this tuple description. dolio's was more precise
13:14:13 <dmwit> (s : set, s -> s -> s)
13:14:47 <hunteriam> dmwit: i don't see the difference
13:14:56 <dmwit> the first member is a set named s, not a member of the set s
13:15:06 <hunteriam> dmwit: it was meant to be a type S
13:15:15 <hunteriam> dmwit: its basically (a, a -> a -> a)
13:15:16 <teurastaja> so what else besides floding stuff can a monoid do?
13:15:30 <teurastaja> *folding
13:15:31 <ski> hunteriam : no
13:15:39 <ReinH> dmwit: (and also forget about associativity)
13:15:41 <hunteriam> ski: ?
13:15:43 <dmwit> hunteriam: no, that is a wrong description of magma
13:15:56 <hunteriam> dmwit: aren't types analagous to sets?
13:16:10 <hunteriam> analogous* 
13:16:11 <EvanR> sort of kind of no
13:16:13 <teurastaja> yes, curry-howard isomorphism
13:16:21 <dmwit> even if they are it is still wrong
13:16:27 <ski> hunteriam : depends on which sense you place in "sets"
13:16:28 <hunteriam> dmwit: whys that?
13:16:34 <EvanR> set theory <---------------> type theory
13:16:35 <hunteriam> ski: could you say more?
13:16:45 <dmwit> (s, ...) has a value of type s
13:16:59 <dmwit> you want a type, not a value
13:17:08 <dolio> It's a sigma type.
13:17:28 <hunteriam> dmwit: you're saying a tuple that begins with s has type s? 
13:17:44 <ReinH> I like Eugenia Cheng's description of algebraic (and categorical) structures.
13:17:47 <ski> hunteriam : in Haskell terms, a value of type `(a,a -> a -> a)' is a pair of a *value* of type `a' (the type must be specified beforehand) and a function that can combine any two values in `a' into a new value in `a'
13:17:50 <dmwit> no, i'm saying it has a value of type s inside
13:17:55 <ski> hunteriam : but this is not what a magma is
13:18:12 <hunteriam> ski: what is a magma then?
13:18:13 <ski> hunteriam : a magma has the function, but not the distinguished value
13:18:22 <hunteriam> ski: oh duh
13:18:24 <hunteriam> im sorry
13:18:27 <hunteriam> that was dumb of me
13:18:28 <benzrf> is there anything in Control.Monad.State or Control.Monad.Trans or anywhere to convert StateT s Identity a into StateT s m a for Monad m (or even Applicative m i guess)
13:19:03 <hunteriam> ski: but if it was (S, s -> s -> s), where S is a type, is that correct? or no because its not a set?
13:19:05 <dmwit> benzrf: yes, see mmorph package
13:19:07 * hackagebot th-orphans 0.11.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.11.1 (MichaelSloan)
13:19:14 <teurastaja> what else than folding can a monoid do?
13:19:17 <ReinH> She calls it the "Data-Structure-Properties" trichotomy.
13:19:30 <benzrf> dmwit: er sorry i already knew mmorph
13:19:33 <dedgrant> Can anyone remind me of the record pattern matching syntax that just binds all applied record fields as local names?
13:19:39 <dmwit> benzrf: but also transformers has something... mapstatet itdink
13:19:48 <Clint> dedgrant: {..}
13:19:48 <benzrf> dmwit: im using it like 1 place monomorphically, so i dont really wanna pull in a new dep
13:19:56 <dedgrant> Clint: thank you kindly!
13:19:59 <ski> hunteriam : first, to avoid some confusion, i think we'd better switch away from using Haskell's notation for tuple types (since it is too easily confused with tuple *values*, especially in this context)
13:20:14 <dmwit> :t mapStateT
13:20:15 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
13:20:41 <hunteriam> ski: is there really a difference in the real non-haskell world? although that is true, there is confusion
13:20:44 <ski> hunteriam : so, instead of `(a,a -> a -> a)', i'll write `a * (a -> a -> a)' for the above type of pairs of a value in `a' and a binary operation over `a'
13:20:46 <dmwit> :t mapStateT (return . runIdentity)
13:20:47 <lambdabot> Monad n => StateT s Identity b -> StateT s n b
13:20:52 <dmwit> benzrf: 
13:21:03 <ski> hunteriam : is there really a difference between what ?
13:21:08 <benzrf> dmwit: figured that out already :P
13:21:10 <benzrf> thanks though!
13:21:16 <hunteriam> ski: a value tuple and a type tuple
13:21:25 <benzrf> dmwit: er i mean i figured that out thanks to yr mapStateT tip
13:21:25 <dmwit> :t state . runState
13:21:26 <lambdabot> MonadState s m => State s a -> m a
13:21:34 <ReinH> A magma in Haskell is some type T equipped with a binary operation T x T -> T. In Haskell, we prefer to curry this: T -> T -> T. It's confusing to use the standard tuple notation here.
13:21:35 <dmwit> benzrf: also this
13:21:47 <ski> hunteriam : "type tuple" is very different from "tuple type"
13:21:48 <benzrf> oh gdammit
13:22:07 <teurastaja> so.... what else than folding can a monoid do?
13:22:13 <hunteriam> id love to continue this conversation but i need to get back to work
13:22:17 <hunteriam> thanks for teaching me things though
13:22:21 <ski> ok
13:22:32 <hexagoxel> ais_: depends
13:22:43 <dolio> It is the same as the difference between a pair of things and a set of pairs of things.
13:22:44 <ReinH> teurastaja: folding is quite a lot
13:23:22 <teurastaja> but if it does just that then a monoid would be a fold, which everybody here tells me its more than just that
13:23:37 <ReinH> teurastaja: all monoids are foldable, not all folds are monoidal.
13:23:55 <dmwit> nobody told you it was more than that...
13:24:17 <ais_> hexagoxel, isnt there any stable version where it dependencies dont make problem, i have haskell platform 14.2 64bit windows
13:24:26 <ReinH> Well, in fact all folds can be encoded as a monoid.
13:24:29 <teurastaja> difference between a fold and a monoid please?
13:24:45 <ReinH> teurastaja: A monoid is a structure, a fold is an operation.
13:24:53 <hodapp> ReinH: how does one encodea fold as a monoid?
13:24:56 <ReinH> or a function, depending on how you define "operation"
13:25:01 <ReinH> hodapp: the Endo monoid
13:25:38 <hodapp> ...wait, I think I've used this before
13:25:42 <ReinH> hodapp: for example, look at how foldr and foldl are defined in terms of foldMap in Foldable
13:25:45 <hunteriam> in haskell OpenGL what are the requirements for resizing the viewport without stretching the scene? I'm new to OpenGL and haskell opengl
13:26:00 <EvanR> hunteriam: haskell opengl is not different from opengl
13:26:17 <hunteriam> EvanR: it seems that there are some steps that are cut out by the high level OpenGL lib
13:26:19 <dmwit> there are some awfully imprecise claims flying around in here about monoids
13:26:24 <EvanR> hunteriam: it would be good to review opengl principles
13:26:32 <dolio> And folds, probably.
13:26:32 <hodapp> dmwit: like what?
13:26:48 <EvanR> hunteriam: in particular the viewport transformation
13:26:52 <hexagoxel> ais_: are you using a sandbox? that might help.
13:27:03 <dmwit> like "they are foldable"
13:27:06 <hunteriam> EvanR: thanks thats very googleable!
13:27:07 <teurastaja> so what are the uses of magmas (if any), and what difference is there between a magma and a monoid?
13:27:19 <EvanR> hunteriam: what high level opengl lib, i dont think any of them do any commands on your behalf without being told to
13:27:29 <dmwit> or "not all folds are monoids"
13:27:30 <hunteriam> EvanR: just "OpenGl"
13:27:52 <hunteriam> EvanR: There are things that seem standard in OpenGl set up that i haven't been instructed to do in any haskell tutorials
13:28:00 <dmwit> teurastaja: monoids are magmas with an identity and associativity
13:28:19 <EvanR> hunteriam: follow opengl tutorials instead, and use `gl'
13:28:23 <EvanR> instead of OpenGL
13:28:23 <hodapp> and.... yup, I just had to make a 5-line type signature
13:28:57 <hunteriam> EvanR: You mean OpenGlRaw?
13:29:10 <hiptobecubic> hunteriam, no
13:29:15 <teurastaja> and are there uses to magmas?
13:29:17 <EvanR> hunteriam: no
13:29:18 <hodapp> oh, there, I got it down to 4 lines
13:29:31 <EvanR> hunteriam: and check out this doc https://hackage.haskell.org/package/lowgl-0.3.1.1/docs/Graphics-GL-Low-EntirePictureUpFront.html
13:29:33 <ais_> hexagoxel, can you give me some pointers on how sandboxes solve dependency issues?
13:29:35 <hunteriam> theres a lib called 'gl'? EvanR hiptobecubic 
13:29:39 <hiptobecubic> yes
13:29:42 <dmwit> teurastaja: you use magmas all the time
13:29:57 <teurastaja> how?
13:30:11 <dolio> Some binary operations are not associative or unital.
13:30:26 <dmwit> practically any stupid binary operation is a magma...
13:30:33 <dolio> Neither associative nor unital, I should say.
13:30:35 <hunteriam> hiptobecubic: EvanR why should i use 'gl' over 'OpenGl'?
13:31:11 <EvanR> youll find it easier to follow tutorials because its exactly like opengl in C
13:31:14 <hiptobecubic> hunteriam, I believe the answer is, "More complete, less magic."
13:31:31 <benzrf> every function whose domain is A × A for some A forms a magma
13:31:40 <dmwit> no
13:31:44 <ReinH> teurastaja: magmas are boring because they have little structure and no laws
13:31:45 <benzrf> oh, derp
13:31:46 <hexagoxel> ais_: see https://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
13:31:48 <benzrf> im stupid
13:31:50 <benzrf> :|
13:32:07 <ReinH> teurastaja: Every tree is a magma, but that's both the beginning and the end of what you can say about trees using magmas.
13:32:16 <ReinH> because magmas are boring
13:32:26 <benzrf> i was thinking "closure doesnt matter because you can just union the image with the domain arbitrarily"
13:32:29 <benzrf> but i misphrased
13:32:36 <ReinH> well, every binary tree, at least.
13:32:44 <dolio> Leaf binary tree.
13:33:13 <ReinH> dolio: right
13:33:24 <teurastaja> any binary operation enclosed in that magma?
13:33:56 <ReinH> teurastaja: any binary operation at all forms a magma with its underlying set.
13:34:27 <teurastaja> wow lol ok so almost everything is a magma
13:34:54 <ReinH> Yep. And magmas are boring.
13:35:02 <benzrf> teurastaja: a magma is simply a function A -> A -> A, basically
13:35:04 <benzrf> along with A
13:35:34 <hiptobecubic> hunteriam, finally found it. http://www.reddit.com/r/haskell/comments/2wii6n/haskell_google_summer_of_code_proposal/cpcg5rb
13:35:52 <teurastaja> ok. so since magmas are so simple, what are groups useful at in functional programming?
13:36:00 <hexagoxel> ais_: alternatively, provide some info about your concrete problem
13:37:06 <Cale> But it's worth noting that there are other specialisations of magmas which are interesting than the usual progression through magma -> semigroup -> monoid -> group
13:37:19 <ais_> hexagoxel, i was just cabal updating or installing yesod or sth that it said cant install HTTP because of incompatible dependencies
13:37:30 <arkeet> arguably less interesting though
13:37:54 <teurastaja> what are they?
13:38:06 <Cale> Quasigroups and loops
13:38:46 <teurastaja> explain how they are related?
13:39:11 <arkeet> it's more interesting when you don't require the operation to be total
13:39:14 <dolio> There's also mobiles.
13:39:14 <Cale> A quasigroup is a magma whose multiplication table is a Latin square
13:39:18 <arkeet> then you get categories and groupoids
13:39:55 <teurastaja> what is a sudoku?
13:39:58 <hunteriam> hiptobecubic: how important is using PatternSynonyms with gl? I prefer to work without language extensions
13:40:11 <Cale> i.e. for each a and b in A, there exist unique x and y in A such that a * x = b and y * a = b
13:40:32 <Cale> A loop is a quasigroup which has an identity element
13:40:59 <Cale> i.e. there exists an element 1 in A such that for any x in A, x * 1 = x and 1 * x = x
13:42:46 <teurastaja> that is the absorbing element right?
13:42:53 <Cale> no, identity element
13:43:13 <Cale> Quasigroups can't have absorbing elements
13:43:45 <Cale> Because their multiplication table is a Latin square, so every row and column of the multiplication table is a permutation of the elements of the quasigroup.
13:44:41 <teurastaja> what do you mean by "multiplication table"?
13:44:42 <Cale> (an absorbing element gives you a row and column which are filled with itself)
13:44:55 <int-e> So if A has size 1...
13:45:03 <Cale> Oh, well, okay :)
13:45:11 <arkeet> :)
13:45:15 <Cale> If there's only one element, then that element is absorbing
13:46:02 <teurastaja> what difference is there between a matrix and your "multiplication table"?
13:46:34 <arkeet> a multiplication table is just a table of x*y for each x and y
13:47:15 <teurastaja> so the multiplication table of a magma would be?
13:47:23 <arkeet> depends on the magma.
13:48:08 <Cale> teurastaja: Wikipedia has a couple examples here: http://en.wikipedia.org/wiki/Multiplication_table#In_abstract_algebra
13:48:41 <Cale> Oh, right, they're also sometimes called Cayley tables
13:48:56 <arkeet> generally that term is reserved for groups.
13:49:07 * hackagebot hspec-webdriver 1.0.2 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-1.0.2 (JohnLenz)
13:50:05 <sinelaw> what's the definition of a higher-kinded type? 
13:50:22 <sinelaw> is (->) a higher-kinded type constructor?
13:50:33 <sinelaw> * -> * -> *
13:50:42 <teurastaja> uh... those multiplication tables seem wrong but i bet theyre not :S
13:50:59 <c_wraith> sinelaw: really, any type with a kind other than *
13:51:01 <Cale> teurastaja: Well, it's addition and multiplication for arithmetic modulo 5
13:51:09 <arkeet> any type with a kind that has -> in it, I'd say.
13:51:11 <teurastaja> oh!
13:51:21 <teurastaja> then i understand
13:51:24 <c_wraith> sinelaw: though having higher-kinded types doesn't mean all that much unless you can also abstract over higher-kinded types.
13:51:36 <sinelaw> c_wraith, ok
13:51:54 <sinelaw> that's the crux of it, I guess
13:52:05 <Cale> teurastaja: You can see the absorbing element 0 in the multiplication table there leads to a row and column of all 0's
13:52:08 <c_wraith> sinelaw: like, Rust's option type is higher-kinded.  It needs a type argument to complete it.  But rust has no facility for abstracting over types with kinds other than *
13:52:47 <Cale> teurastaja: The addition on the other hand has no absorbing element (and this is actually a group under addition)
13:53:09 <teurastaja> so does a loop have anything to do with a programming loop?
13:53:21 <Cale> no
13:53:21 <arkeet> no
13:53:29 <Cale> I actually don't have any idea why the term loop is used
13:53:39 <Cale> We run out of words for set-like things in mathematics
13:53:41 <c_wraith> Heck, you can argue that even java and C# have higher-kinded types...  With no particular abstraction value.
13:53:41 <arkeet> not to be confused with a ring
13:53:52 <Cale> So the less popular ones start to get shitty names
13:54:31 <teurastaja> is a ring something like a loop might intuitively be?
13:54:42 <sinelaw> c_wraith, yes, they aren't much more than a type constructor you must always apply
13:54:49 <arkeet> no, a ring is some other algebraic structure.
13:54:49 <Cale> Well, there are loops you can define for any ring
13:54:58 <Cale> But it's really just another algebraic structure entirely
13:57:27 <teurastaja> how would a programming loop be described with algebraic structures if possible? monads maybe?
13:58:48 <Cale> teurastaja: Well there are various loops you can define for arbitrary monads
13:58:55 <Cale> :t replicateM
13:58:56 <lambdabot> Monad m => Int -> m a -> m [a]
13:59:01 <Cale> :t mapM
13:59:02 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:00:06 <teurastaja> im having trouble reading that notation... working on it...
14:00:22 <arkeet> oh I thought you were talking about algebraic loops lol
14:00:55 <teurastaja> no, paths that start and end at the same point
14:01:50 <Cale> teurastaja: replicateM takes an Int, say n, and an action of type m a, i.e. an action whose result has type a, and produces an action whose result has type [a] (list of values of type a) which will execute the given action the given number of times, collecting the results into a list
14:02:13 <Cale> For example, you might try   replicateM 3 getLine   in ghci
14:02:19 <arkeet> > replicateM 3 [0,1]
14:02:20 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
14:02:34 <Cale> which will get three lines of text, and result in the list of the collected lines
14:02:49 <teurastaja> wow its counting!
14:02:52 <Cale> Yeah, in the list monad, replicateM basically gives a Cartesian power
14:03:08 <Cale> "pick an element from [0,1] three times, in all possible ways"
14:03:32 <Cale> > replicateM 3 [0,1,2]
14:03:34 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1,...
14:03:46 <Cale> > replicateM 4 [0,1]
14:03:48 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
14:03:51 <ReinH> a.k.a. "n-fold cartesian product"
14:04:08 * hackagebot pinboard 0.2 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.2 (jonschoning)
14:04:15 <hiptobecubic> I never see how to appropriately use the list monad
14:04:36 <hiptobecubic> other than the obvious list-comprehension way.
14:04:39 <kaidelong> nondeterminstic functions
14:04:41 <teurastaja> > replicateM 10 [0]
14:04:42 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0]]
14:04:51 <kaidelong> if you've worked with something like prolog the list monad is much less weird
14:05:04 <teurastaja> > replicateM 10 [0,1,2,3,4,5,6,7,8,9]
14:05:06 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,2],[0,0,0,0,...
14:05:22 <hiptobecubic> @src replicateM
14:05:22 <lambdabot> replicateM n x = sequence (replicate n x)
14:05:22 <kaidelong> generally your workflow consists of narrowing down results with more and more constraints until you at least demand only the head of the list
14:05:34 <platz> isn't the "list monad" essentially just nested for loops?
14:05:51 <hiptobecubic> aha
14:05:52 <platz> as "list comprehensions" are
14:06:00 <kaidelong> at last*
14:06:26 <EvanR> my functor fu is failing, how do i use fmap f on "two levels"
14:06:31 <arkeet> yes, sometimes it helps to think of the list monad as a "nondeterminism" monad
14:06:38 <hiptobecubic> So we make n copies of the list, then do x1 <- _1; x2 <- _2; .... return [x1, x2,...]
14:06:40 <arkeet> EvanR: fmap (fmap f)?
14:07:00 <ReinH> hiptobecubic: classic example of lists for nondeterminism might be dice rolling
14:07:05 <ReinH> > let d x y = replicateM x [1..y] in 2 `d` 4
14:07:06 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,...
14:07:14 <kaidelong> LogicT is essentially just a transformer for the list monad
14:07:21 <teurastaja> what is the difference between continuations in scheme and the continuation monad?
14:07:27 <EvanR> arkeet: ah the issue is pair functor is going on the wrong side
14:07:28 <kaidelong> however it's internally implemented differently, IIRC
14:07:40 <arkeet> EvanR: yeah I wasn't sure exactly what you were doing.
14:07:43 <kaidelong> because continuations make it faster or something
14:07:44 <hiptobecubic> ReinH, I guess it doesn't help me mentally because it isn't nondeterministic
14:07:45 <Cale> > filterM (const [False, True]) [1,2,3,4]
14:07:46 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
14:08:07 <ReinH> hiptobecubic: nondeterministic here means that the same action can have multiple outcomes.
14:08:14 <ReinH> That's what the list represents: the list of possible outcomes.
14:08:18 <arkeet> > fmap sum (replicateM 2 [1..6])
14:08:19 <lambdabot>  [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11,12]
14:08:29 <ReinH> The list above is the list of all outcomes of rolling 2d4
14:08:33 <Cale> Yeah, it's nondeterminism in the sense of nondeterministic finite automata
14:08:34 <arkeet> > sort . fmap sum . replicateM 2 $ [1..6]
14:08:36 <lambdabot>  [2,3,3,4,4,4,5,5,5,5,6,6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,9,9,9,9,10,10,10,11,11,12]
14:08:36 <kaidelong> randomness monads are loosely isomorphic to list monads anyway
14:08:41 <platz> the thing that irks me about "nondeterminism" is that it seems to imply more than what is really going on.  if something was really nondeterministic I wouldn't expect any kind of ordering or predicatable properties of the output
14:09:01 <arkeet> nondeterministic and probabilistic are different things.
14:09:03 <kaidelong> (you can take a list and turn it into a uniform distribution to sample from, and generate infinite lists of sampling results)
14:09:06 <platz> hrmm, maybe that's too strong, yes
14:09:25 <hiptobecubic> platz, that was my intuition as well
14:09:26 <arkeet> nondeterminism is something like:
14:09:35 <arkeet> when faced with a choice, take all choices.
14:09:42 <ReinH> platz: I think that's baggage from other uses of "nondeterministic", which often happens when the same word is used to mean multiple, subtly different things depending on context
14:09:55 <platz> dice are both probabilistic as well though
14:10:24 <kaidelong> probabalistic things can be represented as non-probablistic things
14:10:29 <kaidelong> the distribution of the results
14:10:30 <Cale> platz: It's just a different sense of the term. In computer science, there's a long history of using the term nondeterministic to refer to cases where "all possible paths are explored".
14:10:35 <platz> ReinH: I agree, the "CS" meaning does make sense here
14:10:45 <shachaf> arkeet: i,i "When you come to a fork in the road, take it."
14:10:50 <arkeet> haha
14:11:00 <platz> still potentially confusing to newcomers though due to this baggage
14:11:13 <hiptobecubic> platz, "potentially"
14:11:19 <hiptobecubic> We have a constructive proof that it is :)
14:11:22 <arkeet> yeah, nondeterminism means different things between CS and, say, physics.
14:11:43 <kaidelong> that's what replicateM 2 [0..6] is
14:11:48 <Cale> Like, the nondeterministic Turing machines which the "N" in the P vs. NP problem refers to are like ordinary Turing machines except that they can take many possible paths at once, essentially "forking the universe"
14:11:49 <kaidelong> a uniform distribution of outcomes
14:13:04 <Cale> btw, if you want to keep track of probabilities WriterT (Product Rational) []  is pretty good for that
14:13:08 <ReinH> hiptobecubic: If I want to know how likely I am to hit an armor class of 12, I can say:
14:13:11 <teurastaja> ii refer to a nondeterministic function as a function which can produce different output on each run
14:13:37 <Cale> teurastaja: Yeah, that's not at all the sense that we mean here
14:13:39 <hiptobecubic> teurastaja, right. The point everyone is making is that that is wrong in this context.
14:13:52 <ReinH> > let d x y = replicateM x [1..y] in map (head &&& length) . group . sort . fmap (\role -> sum role > 12) $ 3 `d` 6
14:13:54 <lambdabot>  [(False,160),(True,56)]
14:13:56 <shachaf> Cale: Well, it is "from the inside", sort of.
14:14:03 <teurastaja> im a schemer :)
14:14:44 <ReinH> I can get the same number using probability theory
14:14:56 <ReinH> Or I can actually simulate the rolls using nondeterminism
14:15:19 <breadmonster> :t many1
14:15:20 <lambdabot>     Not in scope: ‘many1’
14:15:20 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
14:15:43 <rui> Boo
14:16:43 <ReinH> hiptobecubic: nondeterminism doesn't mean "produces different results each time", it means "explores the entire space of possible outcomes"
14:17:02 <ReinH> the different results are what is encoded into the list
14:17:20 <hiptobecubic> ReinH, sure. In this context I can see that that definition applies.
14:17:24 <ReinH> At least, "nondeterminism" as being used here. Elsewhere, it means different things.
14:17:29 <hiptobecubic> This is the only context in which I've ever seen the word used that way.
14:17:40 <teurastaja> why is haskell much harder to learn than assembly?
14:17:54 <ReinH> hiptobecubic: This is how you represent that other form of nondeterminism in a pure context.
14:18:02 <ReinH> or, rather, a referentially transparent context.
14:18:07 <EvanR> teurastaja: is it?
14:18:15 <hiptobecubic> non-deterministic previously uniquely meant "not pre-determined"
14:18:15 <teurastaja> oh yes it is
14:18:23 <EvanR> ok
14:18:34 <teurastaja> i work in C and various assembly archs
14:18:42 <arkeet> > M.unionsWith (+) . map (flip M.singleton 1) . map sum $ replicateM 8 [0,1]
14:18:43 <lambdabot>  fromList [(0,1),(1,8),(2,28),(3,56),(4,70),(5,56),(6,28),(7,8),(8,1)]
14:18:44 <ReinH> teurastaja: I suppose for the same reason that English is harder to learn than nodding yes and no.
14:18:53 <ReinH> arkeet: nice
14:18:58 <hiptobecubic> teurastaja, I think you're mixing up Haskell with "interesting applications of abstract algebra"
14:19:04 <ReinH> arkeet: You can do that nicely with lens and non
14:19:08 <ReinH> ... as welll
14:19:08 * hackagebot ConcurrentUtils 0.4.0.0 - Concurrent utilities  http://hackage.haskell.org/package/ConcurrentUtils-0.4.0.0 (JamesCandy)
14:19:22 <arkeet> hm?
14:19:34 <hiptobecubic> teurastaja, I would say assembly is also really hard if you qualify it with "high performance on a particular architecture" for example
14:19:38 <ReinH> arkeet: the frequency map
14:19:43 <ReinH> there's a nice lens version using non
14:19:50 <kaidelong> teurastaja: modern assemblers are not really as simple as the ones taught in university but the sheer simplicitly of assembler does impose enormous costs when writing large, complex programs that have to interact with code you didn't write
14:19:53 <arkeet> hmm.
14:20:06 <hiptobecubic> if you just consider the couple of opcodes you have and the registers you use, assembly isn't so hard. If you just consider writing functions and applying them to stuff, neither is haskell.
14:20:06 <arkeet> don't spoil it.
14:20:10 <ReinH> arkeet: ok :)
14:20:13 <hunteriam> how am i supposed to use the gl library?
14:20:24 <ReinH> arkeet: I don't remember it verbatim anyway
14:20:26 <hunteriam> how do i even open a window in the gl library? I'm not seeing things like window hint and whatever
14:20:35 <kaidelong> so even if the basic concepts of things like register assignments, arithmetic, and jumps are easy to learn, modern systems have things like vector instructions and actually programming in assembler is a nightmare, which is why we don't do it anymore (people used to!)
14:20:36 <hunteriam> it seems really hard to find the appropriate module
14:20:42 <arkeet> hunteriam: opengl doesn't specify how to create a window or opengl context.
14:20:43 <EvanR> im still wondering what the evidence is for "assembly is easier to learn than haskell"
14:20:53 <arkeet> hunteriam: you need to use something else, like glut or glfw or sdl or whatever.
14:20:56 <EvanR> not even considering how easy it is to write programs in
14:21:01 <ReinH> EvanR: for some value of assembly, I suppose
14:21:04 <hunteriam> arkeet: ok
14:21:05 <arkeet> (or some platform-specific api)
14:21:14 <ReinH> EvanR: 8080 assembly is pretty easy to learn
14:21:14 <arkeet> hunteriam: I like GLFW-b.
14:21:19 <teurastaja> assembly is just a few instructions to learn and everything works with voltages and turing-machines. haskell is full of monads and abstract type stuff i cant even name
14:21:27 <kaidelong> hunteriam: you want to look at GLUT or GLFW
14:21:31 <EvanR> teurastaja: uh uh...
14:21:35 <kaidelong> GLFW is more in vogue these days
14:21:36 <EvanR> er, uh huh
14:21:39 <hunteriam> if I'm using GLUT shouldn't i just use OpenGl
14:21:43 <hunteriam> ok GLFW
14:21:51 <hunteriam> which GLFW is recommended for gl
14:22:16 <ReinH> teurastaja: Probably mostly because your experience is biased towards assembly-like systems.
14:22:22 <hunteriam> I'm trying to go about things the right way
14:22:59 <hunteriam> anyone?
14:22:59 <kaidelong> teurastaja: monads and abstract type stuff are properties of programs, the only thing Haskell really does is allow you to express this and give you tools to check if you expressed it correctly automatically
14:23:09 <barrucadu> teurastaja: With Haskell you just learn how to define and call functions and everything works
14:23:10 <kaidelong> oh, as well as tools to autogenerate it (polymorphism)
14:23:20 <hunteriam> how about this: whats the difference between GLFW and GLFW-b?
14:23:25 <barrucadu> Everything is simple when put like that
14:23:27 <yac> teurastaja: would you like to implement facebook in assembly?
14:23:27 <ansible1> assembly: easy to learn, hard to write correct programs.  haskell: the opposite-ish.
14:23:27 <kaidelong> but they still exist in a program you write in assembler
14:23:44 <rui> I hope we'll see more big Haskell open projects in the future
14:23:47 <arkeet> ReinH: oh it's this thing I guess.
14:23:49 <arkeet> > foldr (\x -> at x . non 0 +~ 1) M.empty . map sum $ replicateM 8 [0,1]
14:23:50 <lambdabot>  fromList [(0,1),(1,8),(2,28),(3,56),(4,70),(5,56),(6,28),(7,8),(8,1)]
14:23:59 <teurastaja> kaidelong: people used to? I still need to program machines in binary so that higher-level programmers can put monads on top ;)
14:24:13 <kaidelong> teurastaja: oh? What work do you do?
14:24:30 <ReinH> arkeet: Looks about right, yeah.
14:24:39 <teurastaja> embedded electronics
14:24:55 <kaidelong> no C microcontroller?
14:24:57 <arkeet> except I guess it would be better to use foldl. but I'm too lazy to flip.
14:24:57 <ReinH> arkeet: modulo performance of foldr there but that's not the point
14:25:08 <ReinH> teurastaja: I think I nailed it. ;)
14:25:26 <ReinH> arkeet: heh
14:25:27 <arkeet> foldl' with a strict map.
14:25:29 <kaidelong> I had to do work with gameboy stuff and that was all done with assembler but I didn't know people still did that today
14:25:32 <ReinH> arkeet: yep
14:25:48 <ReinH> arkeet: There's probably a nice foldMap version
14:25:51 <teurastaja> of course i use C a lot, but when it takes a page of assembly code to write a 1-instruction equivalent in assembly, ill use the assembly instruction
14:26:10 * EvanR uses the IO () 
14:26:16 <ReinH> arkeet: Although I'm not sure if foldMap for strict Map is strict enough
14:26:20 <teurastaja> lol
14:26:40 <ReinH> teurastaja: Have you considered using a free assembly monad to write your assembly? *ducks*
14:27:00 <kaidelong> ReinH: people actually do stuff like this
14:27:05 <ReinH> kaidelong: I know.
14:27:08 <ReinH> :)
14:27:33 <arkeet> ReinH: I think I prefer the unionsWith one.
14:27:35 <arkeet> at least conceptually.
14:27:36 <EvanR> free monads are blowing my brain
14:27:55 <arkeet> over the lensy one
14:27:56 <ReinH> arkeet: I didn't say the lens one was *better* ;)
14:28:06 <arkeet> :)
14:28:12 <hexagoxel> ahh.. there is a difference between `let (!a, b) = c` and `let !(!a, b) = c`
14:28:20 <teurastaja> sometimes, assembly is the only option. dont think its dead :P
14:28:23 <kaidelong> anyway the complex concepts from Haskell largely stem from programmers not being able to express useful things in the languages that did exist and programmers not wanting to repeat themselves
14:28:36 <ReinH> hexagoxel: when in doubt, let !(!a,!b) = c ;)
14:28:53 <ReinH> hexagoxel: (not really, when in doubt figure it out so you are no longer in doubt)
14:29:11 <kaidelong> the impression I had was that SSE3 and other modern extensions made assembly programming almost impossible to do without generating worse results than modern compilers but maybe I'm too restricted by thinking about desktops
14:29:38 <ansible1> i imagine PIC assembly is pretty simple still
14:30:26 <kaidelong> anyway if there is a weird pattern you want to reify in your language, or something you're repeating that you don't want to repeat
14:30:43 <kaidelong> you generally approach that by introducing an abstraction
14:30:46 <edwardk> arkeet: you can make it a little more obfuscated and lensy with:
14:30:47 <edwardk> > replicateM 8 [0,1] & mapped %~ sum & foldr (\x -> at x . non 0 +~ 1) M.empty
14:30:48 <lambdabot>  fromList [(0,1),(1,8),(2,28),(3,56),(4,70),(5,56),(6,28),(7,8),(8,1)]
14:30:54 <kaidelong> either in software architecture or in the language
14:31:13 <arkeet> edwardk: now that's just silly. :p
14:31:21 <kaidelong> a lot of this is about studying real programs and finding the abstractions hiding within them
14:31:25 <teurastaja> kaidelong: as i said, a C compiler can generate a whole page of assembly code for just 1 line in C. that same line could be expressed with just a single instruction. So C isnt as good as we think it is
14:31:39 <kaidelong> this is pretty much how monads became a thing
14:31:54 <kaidelong> a mathematician in italy was looking at computer programs and noticed some common patterns
14:32:10 <bob_twinkles> kaidelong: if you're doing heavily data-parallel stuff (lots o' vector math) vectorizing stuff manually can frequently beat the compiler
14:32:15 <rui> What does the notation "module BLA( module BLO) where" mean?
14:32:17 <ReinH> edwardk: nice...ish...
14:32:19 <rui> I mean, the module inside the module
14:32:21 <edwardk> > sum <$> replicateM 8 [0,1] & foldr (\x -> at x . non 0 +~ 1) M.empty
14:32:24 <lambdabot>  fromList [(0,1),(1,8),(2,28),(3,56),(4,70),(5,56),(6,28),(7,8),(8,1)]
14:32:30 <ReinH> edwardk: stahp
14:32:45 <ReinH> also pls <&> with &
14:32:47 <yac> teurastaja: wheter those lines are actually needed depends on external constraints
14:32:48 <ReinH> it's only proper
14:32:51 <edwardk> hah
14:33:05 <ReinH> (the <&> version actually reads sort of well too)
14:33:07 <kaidelong> bob_twinkles, teurastaja: I see, I suppose advances in processor features might actually extend rather than constrain the need for people who write assembler directly
14:33:07 <edwardk> the function is simple enough that <$> is fine =)
14:33:17 <yac> teurastaja: so your statement of C spitting useless page of assembly is useless without further qualification
14:33:28 <ReinH> edwardk: :p
14:34:02 <ReinH> teurastaja: I don't think you're going to find a lot of people here who want to pick a fight with "C isn't as good as we think it is"...
14:34:08 * hackagebot ViennaRNAParser 1.0.1 - Libary for parsing ViennaRNA package output  http://hackage.haskell.org/package/ViennaRNAParser-1.0.1 (FlorianEggenhofer)
14:34:46 <arkeet> > replicateM 8 [0,1] & foldrOf (folded . to sum) (\x -> at x . non 0 +~ 1) M.empty
14:34:48 <lambdabot>  fromList [(0,1),(1,8),(2,28),(3,56),(4,70),(5,56),(6,28),(7,8),(8,1)]
14:35:19 <teurastaja> compilers rarely utilize more than the most common and basic assembly instructions. the only things that use those "special instructions" are drivers written in assembly
14:35:31 <Enigmagic> rui: it reexports everything exported from BLO
14:35:58 <rui> Enigmagic: Ah, great
14:36:05 <rui> So it only makes sense if you also imported that
14:36:10 <Enigmagic> *nod*
14:36:28 <megajosh2> @src (+~)
14:36:28 <lambdabot> Source not found. :(
14:36:30 <rui> *thankfully-reverences*
14:36:42 <arkeet> @index (+~)
14:36:42 <lambdabot> bzzt
14:36:47 <arkeet> well whatever, it's from lens.
14:36:51 <megajosh2> Ah, I see
14:37:02 <megajosh2> Never put myself to learn that package back when I was actively making Haskell programs
14:37:14 <arkeet> half the stuff in that line is from lens.
14:37:27 <megajosh2> all I remember is that it had an intimidatingly long install time
14:37:30 <arkeet> haha
14:37:48 <edwardk> l +~ y = over l (+ y); over l f = runIdentity . l (Identity . f)
14:38:20 <arkeet> :t (+~ 1)
14:38:20 <lambdabot> Num a => ASetter s t a a -> s -> t
14:38:23 <arkeet> bah.
14:38:48 <edwardk> the Setter machinery lets it work with setters that have been reversed, etc.
14:39:46 <edwardk> ASetter s t a b = (a -> Identity b) -> s -> Identity t  -- basically
14:40:22 <edwardk> you can dress up fmap (with some newtype noise) and make it into a setter
14:40:24 <edwardk> :t mapped
14:40:25 <lambdabot> (Settable f1, Functor f) => (a -> f1 b) -> f a -> f1 (f b)
14:40:58 <teurastaja> yac: external constraints without an operating system means nothing
14:41:52 <teurastaja> picture yourlsef in a while loop
14:42:41 <johnw> "You are in a twisty maze of passages, all alike."
14:43:12 <EvanR> the lunch bag smells of onions
14:45:19 <hunteriam> could someone quickly remind me how to prompt the user for input?
14:45:24 <hunteriam> string input
14:45:56 <EvanR> getLine
14:45:57 <pavonia> getLine
14:46:01 <hunteriam> thanks guys
14:46:06 <EvanR> putStr followed by getLine
14:47:29 <hexagoxel> after putting some thought into it, i still am not certain whether there would be sensible ways to define distinct .Lazy and .Strict for ReaderT.
14:48:04 <arkeet> EvanR: putStr followed by hFlush followed by getLine
14:49:03 <EvanR> putStr followed hFlush followed fsync followed a visit from the good cop and bad cop to get the information
14:50:53 <hexagoxel> comparing WriterT from Writer.Lazy and Writer.Strict, it seems that i can get differing behaviour without using any of the Writer-specific methods (other than runWriterT ofc)
14:51:31 <zipper> How do I access packages that are in vendor/ directory when I want to build a package? I cloned the repo with --recursive.
14:51:45 <yac> hunteriam: IO String
14:51:58 <hunteriam> yac: thanks brah 
14:52:24 <yac> hunteriam: you welcome brah
14:54:09 * hackagebot ClustalParser 1.0.2 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.0.2 (FlorianEggenhofer)
14:57:23 <EvanR> -Wall defined but not used warnings are saving my ass
14:57:36 <EvanR> and shadowing
15:01:55 <c_wraith> huh.  Latest criterion output format is *way* cleaner.
15:02:15 <c_wraith> While containing more info - definitely a big win.
15:02:32 <lifter> shwoop
15:08:13 <gabim> Hello
15:08:20 <gabim> I have a question
15:08:26 <gabim> can someone help me?
15:08:38 <Peaker> gabim: just ask, don't ask to ask
15:08:39 <zipper> gabim: Just ask, don't worry.
15:08:59 <gabim> I want a account in wiki haskell
15:09:28 <gabim> where I do a reqest for account?
15:10:01 <pyon> What monads are commutative, besides readers, and writers to commutative monoids?
15:10:29 <zipper> How do I install packages that are in the form of gitsubmodules in a sandbox?
15:10:35 <c_wraith> pyon: Maybe is, for instance
15:10:48 <gabim> Peaker: I want a account on wiki haskell
15:10:52 <zipper> *git submodules
15:10:55 <pyon> c_wraith: Oh, right.
15:10:57 <c_wraith> pyon: also, I don't think writers are commutative
15:11:09 <pyon> c_wraith: Not even when the underlying monoid is commutative?
15:11:28 <c_wraith> pyon: oh, with a commutative monoid, yes
15:12:27 <c_wraith> pyon: also, boringly, Identity is commutative. :)
15:13:25 <Peaker> Const () and Const Void too :)
15:13:56 <pyon> It's just that I've been thinking "in what cases could I use Foldable/Traversable-like classes, but which don't guarantee anything about the order in which elements are traversed?"
15:14:12 <hunteriam> how do i prevent a GLFW window from closing in haskell?
15:14:17 <gabim> know someone where I make a reqest for a wiki account?
15:14:20 <hunteriam> in other languages they just have a loop
15:15:01 <Denommus> is there another auto-completion tool besides ghc-mod?
15:15:38 <pyon> And it dawned upon me that the answer is "you can only apply commutative-monadic actions in that case".
15:18:35 <SrPx> Hello, does anyone know if there is any advance since "The Optimal Implementation of Functional Programming Languages" (the book)?
15:18:49 <levi> hunteriam: You probably want to make a loop too. There's an example on the haskell wiki page for GLFW.
15:22:28 <hunteriam> levi: thanks!
15:24:08 <hunteriam> guys i have a question
15:24:12 <hunteriam> in the 'gl' library
15:24:15 <hunteriam> where are all the gl calls
15:24:23 <hunteriam> they're not in core45
15:24:30 <EvanR> look under Core 32
15:24:40 <EvanR> or 10 for old stuff
15:25:33 <hunteriam> EvanR: why is core45 so empty?
15:25:38 <hunteriam> i wanted to use the latest opengl
15:25:41 <EvanR> it includes 44
15:25:43 <EvanR> which includes 43 etc
15:25:48 <hunteriam> oh i see
15:25:49 <EvanR> 45 only has stuff that appeared in 45
15:26:00 <hunteriam> so i import 45 but it will allow me to use 32?
15:26:04 <EvanR> yes
15:26:07 <hunteriam> neat
15:26:11 <hunteriam> although really annoying to navigate
15:26:17 <EvanR> or just include the main module which includes 45
15:26:19 <levi> SrPx: I'd never heard of it before, but it looks like someone's got the VM described there working again: https://github.com/cls/bohm
15:26:43 <hunteriam> EvanR: sounds good, is there a way to browse the compiled list of functions instead of just core45 or just core44?
15:26:54 <EvanR> hunteriam: go to core32
15:27:08 <hunteriam> EvanR: that lists stuff from core45 as well? o_0
15:27:16 <EvanR> like what?
15:27:22 <SrPx> levi: interesting. Starred, thanks.
15:27:28 <hunteriam> EvanR: i don't know, i was assuming the stuff in core45 was new?
15:27:37 <EvanR> indeed, you dont know ;)
15:27:47 <EvanR> you can look at this too http://docs.gl/
15:27:49 <hunteriam> EvanR: there is stuff in core45 though
15:27:58 <EvanR> stuff i dont want to know about ;)
15:28:05 <hunteriam> EvanR: lol true me neither
15:28:18 <hunteriam> EvanR: yea alright
15:28:23 <hunteriam> EvanR: probably never going to use that stuff
15:28:29 <MP2E|Work> docs.gl, what an incredibly convenient URL
15:29:12 <fiola> :-)
15:29:31 <fiola> Wish it would set a trend :-)
15:29:43 <hunteriam> so is there a team assembled to write the bindings for vulcan in 5 months or whenever?
15:29:56 <EvanR> hahaha
15:30:09 <hunteriam> no?
15:30:13 <EvanR> bindings team: assemble!
15:30:29 <hunteriam> i mean, are there any plans for doing the bindings
15:30:37 <hunteriam> has anyone said "ill do it"
15:31:06 <EvanR> ask in #haskell-game
15:31:11 <hunteriam> i guess its not that hard
15:31:32 <hunteriam> since haskell is pretty solid as far as calling c functions goes
15:35:58 <Javran> is it possible to make the following code compile? http://lpaste.net/128030
15:36:51 <Javran> seems like type checker tried to match two forall types
15:37:31 <shachaf> Javran: Not really.
15:37:32 <int-e> Javran: no, you cannot reuse 'm' in the 'Left' case, you'll have to create a new one.
15:37:45 <shachaf> Javran: You say Left x -> Left x and take the cost of the extra allocation. :-(
15:37:58 <int-e> (but you can cheat with unsafeCoerce)
15:38:00 <shachaf> Or you can unsafeCoerce, which is probably perfectly safe. But I'm not recommending it.
15:38:09 <Javran> I see
15:38:11 <shachaf> This is probably an optimization that GHC could do in some cases.
15:38:42 <hunteriam> will i cause a memory leak with this function? f = if (someBoolean) then f else return ()
15:38:51 <Javran> not sure if it is possible to say that "m" gets refined when it goes to the "Left _" branch
15:38:54 <mniip> Javran, unsafeCoerce guarantees "probably safe" in your case
15:39:09 * hackagebot hplayground 0.1.2.7 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.7 (AlbertoCorona)
15:39:12 <EvanR> wut
15:41:48 <Welkin> EvanR: when is mardi gras?
15:41:54 <Welkin> do you celebrate it for a whole month?
15:41:58 <EvanR> a couple weeks ago
15:42:09 <Welkin> like carnival?
15:42:15 <EvanR> yes
15:43:01 <Welkin> do you dance naked in the streets
15:43:02 <Welkin> ?
15:43:06 <Welkin> what is it like?
15:43:13 <EvanR> not this year
15:43:17 <EvanR> #-blah
15:45:54 <c_wraith> hunteriam: That should run in constant space when it goes into an infinite loop.  It is a tail call.
15:46:16 <hunteriam> c_wraith: i don't really understand tail call optimization
15:46:36 <EvanR> f by itself isnt really a call
15:46:54 <hunteriam> EvanR: http://lpaste.net/128031
15:47:23 <arkeet> yes that's tail recursive.
15:47:32 <arkeet> so it won't blow up your memory.
15:47:46 <c_wraith> hunteriam: that's actually fundamentally different.
15:47:47 <hunteriam> what makes it tail recursive
15:47:52 <c_wraith> hunteriam: it's not tail recursive
15:48:00 <arkeet> well ok it's not exactly.
15:48:06 <c_wraith> hunteriam: but the IO type is designed so that it runs in constant space anyway
15:48:06 <arkeet> as written.
15:48:09 <EvanR> f a b c = f ...
15:48:37 <EvanR> @src foldr
15:48:37 <lambdabot> foldr f z []     = z
15:48:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:48:43 <EvanR> hmm nevermind that
15:48:47 <arkeet> @src foldl
15:48:47 <lambdabot> foldl f z []     = z
15:48:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:48:54 <EvanR> foldl
15:49:06 <c_wraith> hunteriam: also, I'd write those last 4 lines as "when (not shouldClose) $ windowLoop window"
15:49:17 <hunteriam> c_wraith: or unless
15:49:22 <hunteriam> c_wraith: save yourself a not
15:49:25 <EvanR> or when (not shouldClose) (windowLoop window)
15:49:30 <hunteriam> c_wraith: but i didn't include control.monad
15:49:32 <c_wraith> hunteriam: eh, I don't like unless. :)
15:49:43 <c_wraith> hunteriam: it's not saving myself a not, it's just hiding it. :)
15:49:56 <hunteriam> c_wraith: well when is just hiding things as well
15:50:05 <hunteriam> @src when
15:50:05 <lambdabot> when p s = if p then s else return ()
15:50:27 <arkeet> windowLoop window = untilM (windowShouldClose window) $ do ...
15:50:41 <c_wraith> hunteriam: in any case - it's not a tail call.  But the IO type is designed so that it stays in constant space when used like that.
15:52:12 * EvanR goes ahead and swaps all his tuples because functor
15:55:22 <hunteriam> EvanR: wait why are you swapping your tuples
15:55:25 <hunteriam> EvanR: that sounds interesting
15:55:40 <EvanR> i had (a, T) everywhere
15:55:53 <EvanR> but functor fmaps the second element
15:55:55 <EvanR> so (T, a) is better
15:58:33 <migimunz> Hi. I'm having trouble understanding universal qualifiers. For example, what is the difference in saying forall a b. m a -> (a -> m b) -> m b, instead of the same thing but without the universal qualifier?
15:59:09 <arkeet> nothing, unless you are using ScopedTypeVariables
15:59:22 <acowley> In which case m is out of scope
16:00:05 <migimunz> Thanks!
16:05:40 <levi> It's when you move the forall to the right that things start changing.
16:06:03 <shachaf> Moving it to the right doesn't change much.
16:06:21 <shachaf> migimunz: In Haskell in general, "::" has a built-in forall.
16:06:46 <arkeet> moving it into the left side of a (->) changes things.
16:06:47 <shachaf> So "const :: a -> b -> a" really means "const :: forall a b. a -> b -> a"
16:06:50 <funfunctor> @hoogle String -> Int
16:06:54 <lambdabot> Test.HUnit.Base Label :: String -> Node
16:06:54 <lambdabot> Prelude error :: [Char] -> a
16:06:54 <lambdabot> Prelude length :: [a] -> Int
16:08:05 <migimunz> aha, I remember reading that forall is implicit in that case, though I forgot that. 
16:08:36 <migimunz> could you provide an example of the forall quantifier moved into the left side of (->) ? And what would it mean?
16:08:39 <seanparsons> Stuff like forkIO being written in terms of IO instead of MonadIO makes some stuff so hateful.
16:10:36 <Luke> is there a function like this?: Applicative f => (a -> b -> f c) -> f a -> f b -> f c
16:10:43 <Luke> couldn't find anything on hoogle
16:10:47 <ion> @type liftA2
16:10:48 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:10:52 <Luke> oh thanks
16:10:54 <EvanR> different
16:10:56 <Luke> ooh
16:10:57 <Luke> so close
16:11:01 <shachaf> Luke: join (liftA2 f x y)
16:11:05 <Luke> thank you
16:11:07 <ion> @type join (\f a b -> liftA2 f a b)
16:11:07 <shachaf> Or join (f <$> x <*> y)
16:11:07 <lambdabot> ((b -> c) -> b -> c) -> ((b -> c) -> b) -> (b -> c) -> c
16:11:12 <shachaf> You need Monad for it, though.
16:11:21 <ion> uh, i’m too tired to brain
16:11:34 <Luke> yeah it's monad so it's ok
16:11:36 <Luke> thanks
16:12:34 <arkeet> :t \f a b -> join (liftM2 f a b)
16:12:35 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
16:14:43 <shachaf> That also works, but it could be less efficient.
16:14:56 <shachaf> liftM2 uses two joins, liftA2 uses zero.
16:14:58 <levi> migimunz: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#universal-quantification
16:15:09 <arkeet> I just wanted the cleaner type.
16:15:09 <shachaf> You generally want to minimize the number of joins you use if you can.
16:17:52 <mgsloan> seanparsons: https://hackage.haskell.org/package/lifted-base helps a lot with that
16:18:24 <migimunz> levi, Thank you!
16:18:30 <seanparsons> mgsloan: Yeah, used that a bit, just feels a bit wrong using something outside of base for something like that.
16:18:49 <mgsloan> It uses https://hackage.haskell.org/package/monad-control-1.0.0.4/docs/Control-Monad-Trans-Control.html , which takes some getting used to, but is quite nice for working around stuff like that
16:19:39 <levi> migimunz: The GHC User's Guide really has a lot of good stuff in it.
16:21:12 <migimunz> levi, I haven't seen it before - been browsing the haskell wiki and hackage for explanations and descriptions. Guess it'll take time for it to click intuitively.
16:22:01 <levi> Yeah, intuition definitely takes time and effort to develop.
16:22:34 <EvanR> intuition isnt intuitive
16:22:39 <EvanR> which is counterintuitive
16:22:59 <EvanR> literally
16:23:52 <mgsloan> This is why "intuitive UI" is rather subjective
16:32:28 <levi> Well, intuition is perception of something without rational thought. That can happen either because of training or instinct, but people often fail to distinguish the two sources when talking about whether things are "intuitive".
16:34:22 <zipper> How do I point a sandbox to a package already in $HOME/.cabal?
16:35:01 <zipper> Copying it from $HOME/.cabal to the sandbox doesn't seem to work.
16:35:02 <zipper> SMH
16:35:23 <arkeet> I think one normally just installs it again into the sandboxl.
16:37:04 <EvanR> i think every line of code in 150 lines has a backwards tuple in it :(
16:37:12 <EvanR> need to learn vim
16:39:11 <bob_twinkles> <3 vim macros
16:39:23 <exio> backward tuple? what would that be?
16:39:37 <EvanR> (expr1, expr2) when i want (expr2, expr1)
16:39:40 <hpc> (foo' bar)
16:39:54 <kaidelong> EvanR: why not emacs? I really regret learning vim
16:40:01 <kaidelong> the UI for it is great but the extensions matter more
16:40:10 <kaidelong> once you use vim you feel stuck because emacs seems terrible
16:40:15 <kaidelong> it's kind of like learning Haskell
16:40:29 <EvanR> i tried emacs years ago and the north south east west controls were weird
16:40:48 <kaidelong> emacs is awful, but it has better network effects behind it than vim does
16:40:53 <EvanR> but i definitely feel like vim has been failing me in recent months
16:41:30 <kaidelong> it's probably better to just learn emacs instead if you're starting fresh, just like I'd recommend people not learn Haskell but something like Python if they want to actually be productive
16:41:40 <kaidelong> well
16:41:44 <kaidelong> python is still iffy
16:41:45 <kaidelong> java
16:41:47 <kaidelong> or C++
16:42:00 <EvanR> what
16:42:00 <kaidelong> or C#
16:43:52 <EvanR> @hoogle (a, Maybe b) -> Maybe (a,b)
16:43:54 <lambdabot> No results found
16:44:22 <EvanR> thats gotta be something
16:44:40 <Welkin> kaidelong: I disagree
16:44:41 <EvanR> :t traverse
16:44:41 <kaidelong> @type traverse
16:44:41 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:44:41 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:45:07 <Welkin> haskell takes more work to become proficient enough to write useful programs when compared to python
16:45:12 <Welkin> but it is well worth it
16:45:18 <Welkin> python is a waste of time
16:45:23 <ion> @type Data.Traversable.sequence `asAppliedto` (undefined :: (a, Maybe b))
16:45:23 <lambdabot>     Not in scope: ‘asAppliedto’
16:45:24 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 162)
16:45:28 <ion> @type Data.Traversable.sequence `asAppliedTo` (undefined :: (a, Maybe b))
16:45:29 <EvanR> sequenceA
16:45:29 <lambdabot> (a1, Maybe a) -> Maybe (a1, a)
16:45:36 <kaidelong> Welkin: yeah I wasn't sure about python but what is your definition of useful here?
16:45:54 <Welkin> kaidelong: a web application, for example
16:45:58 <Welkin> using scotty or yesod
16:46:06 <kaidelong> haskell is slightly more mature on that front I guess
16:46:57 <kaidelong> if you're read Haskell and Yesod though...
16:47:01 <kaidelong> you've*
16:47:16 <kaidelong> it's not a very clear or helpful book and the documentation is pretty impenetrable
16:47:28 <Welkin> it took quite a lot of effort
16:47:31 <kaidelong> so in terms of effort needed to get something done, it'll take longer
16:47:38 <Welkin> but anything worthwhile does
16:47:53 <Welkin> once you learn it, it is very easy to use
16:48:02 <Welkin> you only need to learn something once
16:48:08 <Welkin> so why not learn the best
16:48:09 <kaidelong> the closest thing to a good GUI story for haskell at this point seems to be HQML
16:48:20 <kaidelong> HsQML*
16:48:21 <oneeman> as far as vim and emacs, I hear a lot of people nowadays very happy with emacs + evil mode
16:48:37 <Welkin> I hated emacs when I first started using it, but now I enjoy it
16:48:53 <Welkin> I took 2 solid days to customize it and learn the key bindings
16:48:58 <Welkin> it was hard work, but worth it
16:49:24 <kaidelong> I've heard a lot of good things about SublimeText
16:50:13 <fiola> You don't have to use just one tool you know, it rarely produces the best results.  Remember the hammer/screwdriver thing.
16:50:38 <johnw> Welkin: that experiences describes any "insert powerful concept/library/application here", such as Haskell
16:50:45 <Welkin> fiola: of course, but when comparing two tools that do the same thing, that is not relevant
16:51:23 <fiola> They don't do the same thing, they do *similar* things, and each one is slightly better for different things.
16:52:32 <oneeman> true, which is why I hear people saying evil mode gives them the best of both worlds.  I don't know either of them well enough though, slowly picking it up
16:53:11 <johnw> discussion of different editors is better taken off-channel
16:53:17 <fiola> +1
16:53:44 <oneeman> cool
16:54:10 * hackagebot hplayground 0.1.2.8 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.8 (AlbertoCorona)
16:54:33 <Welkin> that's right! You're in the Church of Emacs where we worship Saint IGNUsius!
16:55:00 <Fylwind> MonadIO doesn't have Functor as a superclass :(  [yeah I know AMP is happening soon but I can't wait!]
16:55:19 <Fylwind> so I'm stuck using liftM instead of <$>
16:55:39 <johnw> and if you want to be backwards compatible at all, you still will be
16:55:49 <Fylwind> johnw: yup :(
16:55:56 <Welkin> Fylwind: <$> = liftM
16:55:59 <Welkin> then remove it later
16:57:16 <Fylwind> Welkin: I see
16:57:40 <dolio> What's wrong with adding Functor to the type signature?
17:00:13 <johnw> maybe he's in a MonadIO context due to the calling code
17:02:55 <zipper> How do I install the Cabal library into a sandbox without using cabal install? I have tried with ./Setup install which will seems to install in the sandbox but the sandbox doesn't register it.
17:07:51 <hexagoxel> zipper: see https://github.com/lspitzner/cabal/blob/hacking-doc/HACKING.md
17:08:27 <hexagoxel> there, i do not install, only configure; but the rest of the process should be the same.
17:09:09 <hexagoxel> i.e. you need --package-db=$sandbox-packagedb-location
17:13:36 <hexagoxel> zipper: are you trying to run the Cabal/cabal-install tests with a sandbox?
17:17:28 <SrPx> How does edwardk's Bound library relate to the idea of optimality defined by Levi on 78, as well as John Lamping's 90 paper?
17:18:31 <lpsmith> hmm,  the superclass constraint on MonadReader is much too restrictive
17:19:09 <lpsmith> Is there any reason why it shouldn't be     class Functor m => MonadReader r m | m -> r where
17:19:39 <dgorbik> I am implementing an IRC bot and I want to have modules that would be able to subscribe to certain events. All listeners for events belonging to the same module should share some state. What's the best way to pass this state around and tie it to each module? In theory I could have a huge single object with record getters for every module and I would add them by hand every time I add a new module. Is there a way to handle that automatically?
17:19:40 <fizruk> because it has Monad in its name?
17:20:19 <dgorbik> this object would contain state for every of the modules and pass it explicitly to every modules' handlers so that handlers have only access to their own state
17:20:46 <EvanR> are you sure you need state as such
17:21:01 <EvanR> an IRC bot could use a database of sorts
17:21:38 <EvanR> web request handlers dont have state
17:24:22 <pavonia> dgorbik: You could use a Chan for each module that broadcasts all relevant events, and sub-modules may listen to this channel
17:25:58 <zipper> How do I make a package that I can see is registered by ghc-pkg be registered in a sandbox using hc-pkg?
17:26:08 <dgorbik> pavonia: so modules would be just running in a forever StateT and just process the queue?
17:26:39 <EvanR> ReaderT IO ? :\
17:26:57 <pavonia> dgorbik: Something like that, yes
17:27:28 <pavonia> EvanR: You probably need StateT for bot
17:27:41 <EvanR> why?
17:27:48 <mniip> mutability
17:27:54 <EvanR> uh
17:28:03 * EvanR points at IO
17:28:06 <dgorbik> EvanR: I need to have bot commands that will populate some information or stuff
17:28:29 <pavonia> e.g. if it has a @more command, you need to store how much data has already been displayed
17:28:30 <dgorbik> like !addquote for the most obvious example
17:28:30 <EvanR> StateT really only make sense over not IO
17:28:48 <EvanR> or if it was generalized
17:29:11 <dgorbik> hm, why? because you could just use IORefs?
17:29:18 <EvanR> IORefs or anything
17:29:34 <mniip> using IORef with ReaderT seems much less transparent than just using StateT
17:29:37 <EvanR> theres a whole world of mutable thingies out there, including a proper database like acid-state
17:30:17 <EvanR> if youve try the StateT IO mixture, youll find it more complex
17:30:20 <EvanR> you*
17:30:47 <EvanR> StateT gives you a single value, IO gives you anything you need
17:31:07 <EvanR> including immutable values
17:31:22 <dgorbik> pavonia: I think what you proposed to my original question is just have one single handler inside a module, send all messages there and just let it figure out the type and do everything internally. Right?
17:31:56 <dgorbik> there is probably no need to run them concurrently, but they can forkIO if needed themselves
17:32:20 <EvanR> running different aspects of the bot in forkIOs would probably simplify things
17:32:29 <dgorbik> EvanR, but if you use StateT you will not even notice IO unless you have to do IO stuff?
17:32:32 <hiptobecubic> Does anyone know why it's called "ST" instead of "Mem" or "Mut" or something similarly evocative?
17:33:05 <EvanR> dgorbik: i was under the impression this was StateT over IO
17:33:18 <pavonia> dgorbik:  No, I thought of all sub-modules deciding what events they which to process and which not, so no module handler at all, only a module channel
17:33:23 <EvanR> i.e. you are going to notice IO, because youre doing IO
17:33:31 <EvanR> at least youll hopefully notice
17:33:40 <pavonia> *want to process
17:34:07 <barrucadu> hiptobecubic: Because the paper calls it "State Threads"
17:34:10 <EvanR> dgorbik: if you wanted pure code for some parts of your bot, thats another story, and there would be no IO
17:34:11 * hackagebot Random123 0.2.0 - Haskell port of Random123 library  http://hackage.haskell.org/package/Random123-0.2.0 (BogdanOpanchuk)
17:34:56 <EvanR> StateT over IO is like not admitting that youre writing IO code
17:35:26 <hiptobecubic> barrucadu, ah
17:35:43 <zipper> RTFMing is so painful and takes so long but in the end one ends up understanding so much it's shocking.
17:35:45 <hpc> extra credit if your state is an IORef
17:35:51 <dgorbik> EvanR, I guess I could use operational to abstract over read/write functions and then use StateT on top of that
17:36:02 <EvanR> o_O
17:36:06 <zipper> I've been asking a question about deps here for a while with no help but now I think I have it.
17:36:15 <dgorbik> EvanR: to unit test modules and stuff
17:36:25 <levi> You might write in StateT m where m happens to be IO in the production app, so you can run it 'purely' over Identity or something for testing.
17:36:45 <EvanR> that would only work if you didnt use any IO 
17:37:31 <dgorbik> my IO is pretty well defined, it's just read and write. I don't need all other stuff from realworld (hopefully)
17:37:45 <EvanR> then you probably dont need a StateT over IO
17:37:51 <EvanR> and you can use no IO
17:37:56 <EvanR> (in the meat of the module)
17:38:27 <EvanR> or anywhere in the module
17:39:03 <dgorbik> how do I restrict liftIO usage inside of the module?
17:39:14 <EvanR> one way is not using IO or MonadIO
17:39:37 <EvanR> the fact that you want StateT says youre interested in pure code, so might as well do it
17:39:58 <EvanR> or just go with IO since it will make everything simpler
17:40:30 <levi> You might also be using StateT for something entirely different than you use IO for.
17:40:40 <levi> And just using IO doesn't necessarily make everything simpler.
17:40:54 <dgorbik> I just want the possibility to unit test everything nicely and a well-confined (hidden) IO, since my IO is restricted to only two functions which essentially just operate on a FIFO, nothing else
17:40:55 <EvanR> a single IORef would serve the purpose of the entire StateT
17:41:10 <EvanR> whatever it is
17:41:24 <EvanR> you cant unit test your IO
17:41:41 <hunteriam> is there a way to do this with proper abstraction?
17:41:42 <hunteriam> http://lpaste.net/128037
17:42:14 <hunteriam> the way i have it now gets an error because n' is bound by a floating and by [1..n']
17:42:20 <hunteriam> how do i escape this kink?
17:43:21 <dgorbik> pavonia: interesting. So if I use channel stuff I guess I have to forkIO every module since they are going to be blocked on read. That's probably okay. 
17:44:11 <hunteriam> how can i divide a Floating a by a number used in [1..n]?
17:44:17 <hunteriam> it seems impossible
17:44:33 <pavonia> dgorbik: You can duplicate a channel, so each module can process all events
17:44:35 <EvanR> > [1..3] :: Float
17:44:37 <lambdabot>  Couldn't match expected type ‘GHC.Types.Float’
17:44:37 <lambdabot>              with actual type ‘[t0]’
17:44:38 <levi> dgorbik: You can make a type class that has the operations you want to use, and then make both IO and FakeIO members of it. That can lead to a lot of MyIOClass m => .... constraints in your code, though. Alternatively, you can have your pure code return an 'update command' that describes the operations you want to perform in IO. 
17:44:39 <EvanR> > [1..3] :: [Float]
17:44:41 <lambdabot>  [1.0,2.0,3.0]
17:44:48 <hunteriam> hm
17:44:49 <siddhu> fibs = 0 : 1 : scanl1 (+) fibs     .... is there a reason why the zipWith (+) implementation is more popular?
17:45:11 <EvanR> i dont think adding custom IO type classes to the mix will help
17:45:18 <levi> dgorbik: And of course there's nothing wrong with just using IO.
17:45:34 <hunteriam> :t (\x -> 1) :: a -> Int
17:45:35 <lambdabot> a -> Int
17:45:49 <c_wraith> siddhu: fibs = 0 : scanl (+) 1 fibs
17:46:28 <c_wraith> siddhu: fibs = fix $ (0:) . scanl (+) 1
17:46:37 <levi> dgorbik: Probably the best recommendation would be to look at programs others have written and see how they've handled the issues you're dealing with.
17:46:45 <c_wraith> siddhu: zipWith is just easier for people to think about in general
17:46:48 <siddhu> ah. yes. made a mistake. I meant, let fibs = 1 : 1 : scanl1 (+) fibs
17:46:48 <dgorbik> pavonia: right, but still in different threads. I like this approach, I just wonder what would be the way to achieve similar things if I went with single threaded approach.  I would probably have a function-handler in each module and call it passing an event, but then it would be much harder to create state in each of the modules
17:47:09 <hunteriam> :t (\f -> [pi / i | let f' = fromIntegral f, i <- [1..f']) :: Floating a => Int -> a
17:47:10 <lambdabot> parse error on input ‘)’
17:47:19 <hunteriam> :t (\f -> [pi / i | let f' = fromIntegral f, i <- [1..f']]) :: Floating a => Int -> a
17:47:20 <lambdabot>     Could not deduce (a1 ~ [t0])
17:47:20 <lambdabot>     from the context (Floating a)
17:47:20 <lambdabot>       bound by the inferred type of it :: Floating a => Int -> a
17:47:21 <c_wraith> siddhu: eh, starting at 0 seems more common these days
17:47:28 <hunteriam> whats wrong with that
17:47:44 <siddhu> c_wraith: really? It took me quite a while to understand zipWith for fibonacci. But, I guess that might just be me.
17:47:52 <hunteriam> what is t0
17:48:01 <c_wraith> siddhu: my point was that you could use scanl instead of scanl1
17:48:19 <pavonia> dgorbik: Do you mean one thread per module or only a single for the whole program?
17:48:40 <dgorbik> levi, are there benefits to using operational in this case to be able to have pure stuff for tests or does it just complicates everything and doesn't provide much in turn?
17:48:44 <siddhu> c_wraith: yes, scanl seems nicer, since there is an option of starting at 0
17:48:49 <dgorbik> pavonia: one thread per app
17:48:56 <dgorbik> so no forking 
17:49:55 <hunteriam> could someone tell me why this doesn't work?
17:49:56 <dgorbik> siddhu, the best way to understand these recursive things is probably to learn about graph reduction. I couldn't wrap my head around this until I understood how it's actually evaluated.
17:49:58 <hunteriam> :t (\f -> [pi / i | let f' = fromIntegral f, i <- [1..f']]) :: Floating a => Int -> a
17:49:59 <lambdabot>     Could not deduce (a1 ~ [t0])
17:49:59 <lambdabot>     from the context (Floating a)
17:49:59 <lambdabot>       bound by the inferred type of it :: Floating a => Int -> a
17:50:00 <levi> dgorbik: You don't necessarily need to use operational to make things pure. You might be fine with just a Writer of a Commmand type or something.
17:50:17 <pavonia> dgorbik: Then each module would have to register an event handler action and be called if the relevent event occurs, I guess
17:51:04 <dgorbik> pavonia, of course, but then the module will not be able to have any state until the main program passes it explicitly to an event handler every time and keeps it somewhere in the meantime 
17:51:12 <hunteriam> does anyone see what I'm typing?
17:51:19 <mami> yes hunteriam 
17:51:24 <nshepperd> hunteriam: Int -> [a]
17:51:37 <hunteriam> nshepperd: is there no way to use Floating
17:51:48 <EvanR> dgorbik: you shouldnt be thinking about modules having state, threads can have state, threads can use many modules
17:51:51 <hunteriam> oh
17:51:55 <siddhu> dgorbik, thanks! will look into that.
17:51:57 <hunteriam> :t (\f -> [pi / i | let f' = fromIntegral f, i <- [1..f']]) :: Floating a => Int -> [a]
17:51:57 <lambdabot>     Could not deduce (Enum a1)
17:51:58 <lambdabot>       arising from the arithmetic sequence ‘1 .. f'’
17:51:58 <lambdabot>     from the context (Floating a)
17:52:05 <hunteriam> thats the error i wanted to deal with
17:52:08 <hunteriam> not the [a] typo
17:52:10 <pavonia> dgorbik: Yeah, unless you use IORefs
17:52:19 <levi> dgorbik: And I found that general approach pretty nice to work with, though I can't really compare it to other approaches I haven't taken. :)
17:52:30 <EvanR> dgorbik: in this sense a thread would be as simple as a -> IO b, where a is the request and b is the response
17:52:37 <nshepperd> oh, right, floating isn't necessarily Enum
17:52:43 <hunteriam> yea
17:53:01 <hunteriam> i can give you context as to why i don't want to change it to just Float
17:53:05 <hunteriam> but i don't think it matters
17:53:10 <nshepperd> hunteriam: it's better to do [pi / fromIntegral i | i <- [1..f]]
17:53:22 <nshepperd> if you can
17:53:32 <hunteriam> nshepperd: that will work, and i can do it, but damn if its not ugly as hell
17:53:45 <hunteriam> in this case I'm going to have to do that a LOT
17:53:54 <hunteriam> i know what i will do
17:54:18 <nshepperd> alternatively, (Floating a, Enum a), but floating point values do not necessarily have a reliable Enum instance
17:54:34 <hunteriam> :t (\f -> [pi / i' | i <- [1..f], let i' = fromIntegral i]) :: Floating a => Int -> [a]
17:54:35 <lambdabot> Floating a => Int -> [a]
17:54:39 <hunteriam> nshepperd: ^^
17:55:02 <dgorbik> pavonia but then module would need to store these refs somewhere themselves :)
17:55:22 <ReinH> hunteriam: what's the point of introducing i'? It's more readable without it.
17:55:43 <EvanR> dgorbik: have you seen the technique where IO actions hide state using partial application?
17:55:58 <EvanR> dgorbik: this can simplify a lot
17:56:01 <dgorbik> EvanR, no, where can I read about it?
17:56:11 <hunteriam> ReinH: so that it will be Floating a
17:56:23 <hunteriam> ReinH: it has to be de-integralized 
17:56:39 <ReinH> hunteriam: nshepperd's does that without the let binding. That's what I'm referring to.
17:56:49 <hunteriam> ReinH: in my case his is less readable
17:57:00 <hunteriam> ReinH: because that would require many uses of fromIntegral
17:57:02 <EvanR> i dont know, but just think of an IO program like prog :: IORef a -> b -> IO c, if you created the IORef somehow then do prog ref, now you have :: b -> IO c 
17:57:06 <hunteriam> ReinH: as opposed to just one
17:57:21 <EvanR> that state is "stored somewhere" but you didnt have to design the system for it
17:57:22 <ReinH> why?
17:57:35 <hunteriam> ReinH: because in my actual program i use i many times
17:57:49 <hunteriam> ReinH: in many circumstances where it needs to be ambiguously typed
17:57:57 <EvanR> dgorbik: in this way IO makes state vars easy
17:58:04 <ReinH> Alright then.
17:58:22 <dgorbik> EvanR, ah, interesting. So even handlers would be stored as functions partially applied to an IORef already
17:58:25 <dgorbik> that's cool
17:58:33 <dgorbik> event*
17:58:48 <EvanR> dgorbik: if you need an IORef, or whatever else
17:59:23 <EvanR> this makes the type IO () very powerful, you never know what its going to do, or how much it knows
18:00:03 <EvanR> basically this gives you the encapsulation chapter from OOP
18:00:14 <nshepperd> hunteriam: [pi / i  |  i <- fromIntegral <$> [1..f]]
18:01:32 <dgorbik> I will experiment with that, thanks for all the helpful suggestions EvanR and pavonia! 
18:01:38 <dgorbik> I wonder if socket write is thread safe...
18:01:54 <nshepperd> aka. [pi / i  |  i <- map fromIntegral [1..f]]
18:02:12 <EvanR> dgorbik: are you writing to the same socket with multiple threads?
18:02:24 <EvanR> that will interleave bytes
18:02:43 <dgorbik> http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid — this claims posix sockets are thread safe
18:02:50 <dgorbik> I wonder if that applies to haskell
18:02:54 <EvanR> ghc has its own IO system
18:03:08 <EvanR> sockets are exposed as Handles
18:04:16 <dgorbik> EvanR does this mean I need to use QSems for my write operation that uses socket write inside?
18:04:20 <EvanR> im still not sure what people mean when they talk about thread safe, like can you use threads to do anything at all without a segfault?
18:04:36 <EvanR> dgorbik: no, what would you be guarding against?
18:04:57 <dgorbik> bytes interleaving? :)
18:05:06 <EvanR> so the answer to the question was yes?
18:05:13 <EvanR> you want to write to the same socket with multiple threads
18:05:31 <hunteriam> in 'gl' are we supposed to be using actual c arrays and pointers with things like the vertex array?
18:05:48 <EvanR> if you want messages to be written serially, you will need to serialize them
18:06:12 <EvanR> with a Chan or an MVar lock or STM
18:06:36 <EvanR> hunteriam: yeah
18:06:52 <hunteriam> :/
18:06:58 <hunteriam> i wish there were a better way
18:07:29 <EvanR> you can pretty quickly write simple ffi wrappers around those operations to do what you personally are trying to do
18:07:57 <EvanR> theres a package which does this for you though
18:08:32 <nshepperd> c arrays are Storable vectors
18:10:47 <EvanR> hunteriam: you can look at the code to copy the ffi parts, or follow tutorials on gl and ffi at the same time, always fun ;)
18:10:51 <ReinH> handles are threadsafe in GHC for some value of threadsafe, but I wouldn't necessarily depend on that in a multi-threaded environment.
18:11:20 <EvanR> hunteriam: https://hackage.haskell.org/package/lowgl
18:17:28 * bluezone is very confused
18:18:55 <Welkin> redzone!
18:19:19 * bluezone is not Kane
18:19:35 <dgorbik_> EvanR: I am actually using TSL's IO, I wonder if it's any different in handling these. Going to check this
18:19:46 <EvanR> TSL?
18:20:09 <bluezone> what exactly is a polymorphic constant?
18:20:48 <mmachenry> bluezone: 1 can be a Float or a Double or an Integer
18:21:03 <bluezone> oh
18:21:07 <mmachenry> bluezone: Just like the type of (+) …
18:21:10 <ReinH> constrained polymorphic, at least
18:21:11 <mmachenry> :t (+)
18:21:11 <lambdabot> Num a => a -> a -> a
18:21:14 <mmachenry> :t 1
18:21:15 <lambdabot> Num a => a
18:21:23 <ReinH> The only parametrically polymorphic constant is bottom
18:21:27 <shachaf> Nothing is polymorphic too.
18:21:32 <shachaf> It has type forall a. Maybe a
18:21:34 <ReinH> shachaf: Oh, good point.
18:22:09 <mmachenry> :t []
18:22:10 <lambdabot> [t]
18:22:23 <mmachenry> Empty list as well.
18:22:33 <ReinH> Sure, and a variety of other vacuous things ;)
18:22:49 <shachaf> id is a polymorphic constant. It has type forall a. a -> a
18:22:55 <shachaf> And it doesn't change.
18:22:56 <EvanR> lol
18:23:00 <ReinH> shachaf: touché
18:23:04 <mmachenry> Yeah I guess like any nullary constructor of a type with holes.
18:23:07 <EvanR> no more constants
18:23:16 <mmachenry> Like if I were to make a tree. 
18:23:25 <EvanR> let ones = ones in ones is a constant
18:23:34 <ReinH> EvanR: yes, it's bottom
18:23:36 <EvanR> er ones [1..]
18:23:39 <EvanR> alskdjfasd
18:23:56 * bluezone is getting more confused
18:23:57 <EvanR> nothing is not a constant
18:24:31 <ReinH> Every value is a constant fsvo "constant"...
18:24:46 <EvanR> variables however
18:24:48 * EvanR runs
18:25:08 <shachaf> Is x constant in map (\x -> x + 1) [1,2,3]?
18:25:29 <shachaf> Not that that contradicts "every value is constant", since x isn't a value.
18:25:53 <ReinH> shachaf: I was going to mention that, but then I realized that you already knew that.
18:25:57 <dgorbik_> EvanR: spawning a thread reading form a TChan or TQueue and writing is probably the best way to implement this independent of the level of thread safety of these writes themselves.
18:26:27 * EvanR wishes there was a better way to describe what youre trying to do than "thread safety"
18:27:24 <EvanR> haskell programs dont typically segfault
18:30:32 <dgorbik_> EvanR: I just mean performing every write operation as a transaction serially. But yeah, TChat looks awesome for this. By the way, doesn't it purify the code that performs commands that send to TChan?
18:30:35 <dgorbik_> at least in some sense
18:31:10 <EvanR> you can write most of your program in STM instead of IO
18:31:19 <EvanR> and it will only be able to do STM
18:32:22 <dgorbik_> EvanR: so whatever I perform inside `atomically` knows nothing about IO?
18:32:36 <EvanR> it can only modify STM objects
18:32:40 <dgorbik_> sweet
18:33:02 <EvanR> your IO code can then read it and do something
18:35:15 <dgorbik_> EvanR: and wrap everything inside ReaderT so I don't have to pass STM objects around
18:35:29 <dgorbik_> in*
18:35:46 <EvanR> if you want to, though that make it more cumbersome too
18:36:04 <EvanR> passing arguments in can be pretty light weight
18:36:22 <dgorbik_> EvanR: well, now I already have to pass the connection Handle to every function that wants to write
18:36:58 <EvanR> one idea if you a really itching to use transformers is you wrap STM in something that lets you "commit" at any point in additional to the usual retry ability
18:37:03 <dgorbik_> it would probably much more simple to just have read/write commands that don't take a handle as an argument, since there is only one handle at a time anyway unless I decide to support multiple networks
18:37:06 <ski> bluezone : perhaps try getting less confused ?
18:37:13 <EvanR> though that might not be as convenient as it sounds
18:37:23 <johnw> EvanR: you mean like having flush points?
18:37:42 <EvanR> i could mean that, i was thinking of it like "exit" plus commit
18:37:52 <EvanR> dunno
18:38:20 <dgorbik_> EvanR: which cases this would be useful for?
18:38:26 <EvanR> dgorbik_: writeTChan ch whatever vs... writeWhatever whatever ?
18:38:37 <dgorbik_> yes
18:38:45 <EvanR> not seeing much a difference
18:39:30 <EvanR> > map length ["writeTChan ch whatever", "writeWhatever whatever"] -- ;)
18:39:31 <lambdabot>  [22,22]
18:39:42 <dgorbik_> I actually like transformers, I end up with nested StateT's sometimes when I want some scoping
18:39:48 <dgorbik_> not sure if it's too bad to do
18:39:51 <EvanR> amount of extra code you write to support it [none, alot]
18:41:03 <zipper> hexagoxel: Thanks
18:47:43 <dgorbik_> EvanR: what's the usual way to have some shared state object for multiple threads?
18:47:53 <dgorbik_> IORefs?
18:47:58 <EvanR> an MVar or a TVar
18:48:24 <Cale> IORefs work, but can be difficult to coordinate compared with MVars or using STM and TVars
18:48:27 <Cale> Or Chans
18:48:41 <EvanR> use withMVar to modify an MVar atomically, putting the value back if an error occurs
18:48:45 <EvanR> use STM to operate on TVars
18:54:12 * hackagebot test-sandbox 0.1.3 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.3 (junjihashimoto)
18:59:21 <dgorbik_> EvanR: what would be the analog to having event handlers in closures over some state in haskell? It seems like the only way to achieve that is to have one single event handler for all events reading from a TChan (and maybe some TVars) and then branching if needed.
18:59:38 <EvanR> well theres FRP
19:00:20 <EvanR> irc bot seems like a good application for it
19:01:57 <dgorbik_> Interesting.
19:02:47 <Axman6> IORefs are awesome if you only have a single piece of shared data. modifying it with atomicModifyIORef can give excellent results where things are safe and fast
19:03:19 <johnw> I wonder when management will ask for Functional Proactive Programming
19:03:31 <Axman6> works well with multiple readers and only a few writers too
19:03:32 <EvanR> haskell CEO
19:03:50 <Axman6> johnw: "Must have 20 years of FRP experience"
19:04:12 * hackagebot rethinkdb-client-driver 0.0.15 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.15 (wereHamster)
19:04:35 <Axman6> I remember seeing a while ago one of the original Rails devs had found an ad that required more experience with rails than it had existed, even internally, for
19:04:41 <Axman6> or something along those lines
19:06:48 <dibblego> I have seen same for java, a while ago
19:08:56 <geekosaur> that's pretty SOP any more
19:09:19 <geekosaur> new tech shows up, there will immediately be ads looking for people with 5-10 years of experience with it
19:10:25 <Cale> dgorbik_: If you can give an example of what you mean in another language, perhaps a direct translation is possible? It ought to be possible to translate most things in a fairly straightforward way.
19:13:15 <dgorbik_> Cale: something like http://lpaste.net/128038
19:13:26 <dgorbik_> (My JS is rusty, so it might not be syntactically valid, but you get the point)
19:13:46 <EvanR> IO actions are already like callbacks in js
19:13:56 <EvanR> they can be saved and executed later on demand
19:14:31 <EvanR> using the closure trick from earlier you can hide values of various state in them, and keep them all in the same container
19:14:38 <EvanR> of various types
19:15:42 <dgorbik_> EvanR: it looks the direct translation in haskell would be to return functions of the form: inc :: IO Int, dec :: IO Int, which are actually IORef -> Int
19:15:48 <dgorbik_> but they are partially applied already
19:16:05 <dgorbik_> so it's almost one to one translation
19:17:12 <Cale> dgorbik_: http://lpaste.net/128038
19:17:49 <EvanR> dgorbik_: yes js is cool like that, it can emulate haskell techniques ;)
19:18:50 <dgorbik_> Cale: that's so cool
19:18:58 <dgorbik_> EvanR: :D
19:19:12 * hackagebot ConcurrentUtils 0.4.1.0 - Concurrent utilities  http://hackage.haskell.org/package/ConcurrentUtils-0.4.1.0 (JamesCandy)
19:19:59 <lpaste> Cale annotated “No title” with “Pure version” at http://lpaste.net/128038#a128041
19:20:13 <Cale> That's a little different of course
19:20:43 <Cale> If you wanted to, you could omit val and have inc and dec produce the current value alongside the new counter
19:21:09 <Cale> Of course, you can also put back the mutation with an approach like that...
19:21:49 <dgorbik_> Awesome, thanks! great to know
19:21:54 <dgorbik_> going to change the machine...
19:32:34 <lpaste> Cale annotated “No title” with “fancier example” at http://lpaste.net/128038#a128042
19:33:19 <Cale> Is it just me, or did something weird happen to the formatting there? :)
19:33:59 <EvanR> , add = \n  on the next line
19:34:39 <lpaste> Cale revised “fancier example”: “No title” at http://lpaste.net/128042
19:34:56 <Cale> yeah, that's odd
19:35:08 <Cale> In the raw, it's fine
19:35:42 <lpaste> Cale revised “fancier example”: “No title” at http://lpaste.net/128042
19:35:48 <Cale> weeeeeeird
19:36:10 <Cale> Well, whatever
19:36:25 <Cale> dgorbik: ^^ :)
19:36:59 <Cale> oh, it also messed with my other spacing
19:37:03 <lpaste> Cale revised “fancier example”: “No title” at http://lpaste.net/128042
19:37:10 <Cale> there
19:37:15 <Cale> Sorry for the spam
19:39:12 * hackagebot blunt 0.0.6 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.6 (fozworth)
19:52:56 <CoolestBot123048> Cale: so the last one is half pure half IOish?
19:53:59 <dgorbik_> Cale: I could apply that to my IRC bot modules and just make module's callback return the new version of module with state and same callbacks
19:54:13 * hackagebot blunt 0.0.7 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.7 (fozworth)
20:09:12 * hackagebot barecheck 0.2.0.8 - QuickCheck implementations for common types  http://hackage.haskell.org/package/barecheck-0.2.0.8 (OmariNorman)
20:10:00 <Cale> dgorbik_: Well, the last one is combining the record type with IO
20:11:34 <dgorbik_> Cale: is it better to implement event driven APIs that way or by forking handlers and feeding them events through TChan?
20:19:13 * hackagebot terminfo 0.4.0.1 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.4.0.1 (JudahJacobson)
20:24:02 <funfunctor> @hoogle String -> String
20:24:05 <lambdabot> Data.Data tyconModule :: String -> String
20:24:05 <lambdabot> Data.Data tyconUQname :: String -> String
20:24:05 <lambdabot> Test.QuickCheck.Text bold :: String -> String
20:24:22 <funfunctor> is there a function to uppercase a string?
20:24:42 <enthropy> > map toUpper "funFunctor"
20:24:43 <lambdabot>  "FUNFUNCTOR"
20:24:51 <funfunctor> :t toUpper
20:24:52 <lambdabot> Char -> Char
20:24:56 <funfunctor> ok
20:25:02 <funfunctor> thx enthropy
20:27:07 <funfunctor> @hoogle toUpper
20:27:09 <lambdabot> Data.Char toUpper :: Char -> Char
20:27:09 <lambdabot> Data.Text toUpper :: Text -> Text
20:27:09 <lambdabot> Data.Text.Lazy toUpper :: Text -> Text
20:27:15 <funfunctor> Data.Char ok
20:28:01 <ski> @index toUpper
20:28:01 <lambdabot> Data.Char
20:29:13 * hackagebot haskeline 0.7.2.0 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.2.0 (JudahJacobson)
20:30:19 <funfunctor> I wish packages would refrain from re-exporting other packages
20:30:48 <funfunctor> function namespace control can become a bit unwildly in Haskell
20:31:02 <arkeet> you mean modules, not packages?
20:37:45 <nitrix> It's sad that Haskell is so amazingly good, and yet, it feels like Records and Modules are an aftertought.
20:38:05 <nitrix> It makes for very terribles situations to be stuck in sometimes.
20:38:18 <bitemyapp> nitrix: such as?
20:39:11 <Reiser> Silly question, I have a Maybe Bool, when Just True, I want a default value, otherwise Nothing. fmap (const default) v only works if it is already Nothing of course, is there a nice way of doing this?
20:39:41 <Iceland_jack> Reiser: default <$ Just True
20:39:51 <Iceland_jack> > () <$ Just "something"
20:39:52 <lambdabot>  Just ()
20:39:54 <Iceland_jack> > () <$ Nothing
20:39:54 <lambdabot>  Nothing
20:40:06 <arkeet> what about Just False?
20:40:19 <Iceland_jack> > () <$ Just False
20:40:19 <Iceland_jack>  
20:40:20 <lambdabot>  Just ()
20:40:24 <Reiser> That looks like it does it, he used a string but looks like it works for all values
20:40:28 <shachaf> What do you want? f (Just True) = Just x; f _ = Nothing?
20:40:31 <Reiser> Would work for True/False
20:40:39 <carter> aside from ermine or purescript or ur/lang, or ocaml, what languages have row polymorphic records?
20:40:40 <Iceland_jack> oh no actually, "maybe" is what you want
20:40:56 <arkeet> I don't know what Reiser wants.
20:40:57 <Reiser> Nah, what you had first is precicely what I wanted
20:40:59 <nitrix> :t (<$)
20:41:00 <lambdabot> Functor f => a -> f b -> f a
20:41:17 <enthropy> carter: in what sense is haskell missing them (in HList)?
20:41:19 <Iceland_jack> or 'fromMaybe'
20:41:19 <Iceland_jack> > fromMaybe False (Just True)
20:41:19 <nitrix> Seems okay to me.
20:41:20 <lambdabot>  True
20:41:23 <Reiser> Wait, no I'm wrong I'm sorry
20:41:28 <carter> enthropy: unclear! 
20:41:38 <Reiser> My own brain died, what I want is Just True to become Just x, and Just False or NOthing to become Nothing
20:41:41 <carter> enthropy: i think most folks dont realize how tricky inference is on row polymoprhic records
20:41:56 <ReinH> Reiser: why are you using Maybe Bool then? Why not just Bool?
20:42:05 <Reiser> Aeson uses Maybe _ for possibly missing json values
20:42:10 <Reiser> I have a bool that may or may not be in a config file
20:42:15 <Reiser> So Maybe Bool
20:42:27 <nitrix> If you already know the default is false, you might just have a Bool though.
20:42:32 <echo-area> Is (# #) the internal ()?
20:42:35 <arkeet> :t fromMaybe False
20:42:36 <lambdabot> Maybe Bool -> Bool
20:42:39 <johnw> \mx -> case mx of Just True -> default; _ -> Nothing
20:42:43 <Reiser> nitrix, I can't though, aeson will error if I do that
20:42:54 <ReinH> Reiser: aeson allows default values
20:43:18 <Reiser> Hmm, I guess I need to look harder at the docs, one second
20:44:13 * hackagebot quickpull 0.4.2.2 - Generate Main module with QuickCheck tests  http://hackage.haskell.org/package/quickpull-0.4.2.2 (OmariNorman)
20:44:14 <Reiser> (.!=), I didn't see it before
20:44:20 <Reiser> Thank you
20:44:34 <carter> echo-area: no
20:44:38 <carter> thats unboxed tuples
20:44:44 <carter> (##) has size zero
20:45:50 <echo-area> carter: I see.  Where can I find its document?
20:45:58 <carter> i'm telling you
20:46:02 <carter> its also not ()
20:46:12 <carter> @google ghc unboxed tuples
20:46:12 <lambdabot> https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/primitives.html
20:46:17 <carter> @google ghc unboxed tuples wiki
20:46:17 <lambdabot> https://wiki.haskell.org/Unboxed_type
20:46:31 <carter> @google ghc unboxed tuples wiki trac
20:46:32 <lambdabot> https://ghc.haskell.org/trac/ghc/ticket/9390
20:46:38 <carter> @google ghc unboxed  wiki trac
20:46:38 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType
20:46:50 <echo-area> carter: Okay, okay.  That works.  Thank you.
20:47:10 <carter> echo-area: the cool thing about unboxed tuples is we have size ONE unboxed tuples
20:47:13 <carter> unlike normal tuples
20:47:18 <carter> and size one is kind handy
20:47:27 <carter> for certain crazy tricks
20:47:32 <enthropy> carter: elm
20:47:39 <carter> enthropy: ?
20:47:42 <carter> the langugage?
20:48:12 <Reiser> Sorry to push this, I just realised using a default aeson value still means I have Just True/False, shachaf that function you showed is what I was after, still am, is there a nice way to do it
20:48:18 <enthropy> yes it has record stuff
20:49:14 <ackthet> i saw the light of FP and want to start with Haskell for reasons, which do you recommend starting with, learn you a haskell, gentle haskell, or other?
20:49:44 <Iceland_jack> Learn You a Haskell is good
20:49:59 <shachaf> > let foo m = if fromMaybe False m then Just 'a' else Nothing in map foo [Nothing, Just False, Just True]
20:50:00 <lambdabot>  [Nothing,Nothing,Just 'a']
20:50:01 <carter> ackthet: whats your CS / programming exposure thus far?
20:50:02 <Iceland_jack> If you like videos: http://www.cse.chalmers.se/edu/year/2014/course/TDA452/FPLectures/Vid/
20:50:02 <shachaf> Maybe that.
20:50:07 <shachaf> I'd just write it out, probably.
20:50:46 <Reiser> Alright, thanks again
20:51:07 <kadoban> ackthet: other. https://github.com/bitemyapp/learnhaskell has good advice, specifically the cis194 class is nice. It has suggested readings from LYAH and RWH, and has exercises so you actually end up learning how to code in haskell instead of just…not.
20:52:24 <ackthet> carter: okay, so i'm a physics grad student so I know a little C++, I never had any formal classes on it so I'm sure its bad
20:52:52 <carter> ackthet: 1) lurk on #numerical-haskell, its sometimes quiet, but sometimes fun
20:53:18 <carter> 2) ackthet  read http://dev.stephendiehl.com/hask/ and then go from there
20:53:32 <carter> you're smart, lets toss you into the water
20:53:38 <nitrix> I read a lot about Haskell for I think an entire year. I thought I knew was I was doing until I decided to write something.
20:53:48 <carter> trick is : write stuff
20:53:55 <carter> the type checker will tell you you're wrong
20:53:56 <carter> fix it
20:53:58 <carter> iterate
20:54:13 * hackagebot multiarg 0.30.0.4 - Command lines for options that take multiple arguments  http://hackage.haskell.org/package/multiarg-0.30.0.4 (OmariNorman)
20:54:16 <ackthet> oh yeah and I wrote an xmonad config :P
20:54:19 <nitrix> I was wrong. And you do learn a lot from writing code with Haskell. It's very hard to write incorrect code due to the type system.
20:54:48 <nitrix> carter: That's what I died. I didn't know what I was doing much, but just by matching the types, it was still not that bad.
20:54:52 <nitrix> s/died/did/
20:55:03 <carter> honestly if you dont understand an api's types, but you undrestand what the operations should be, try writing stuff with them, and see what the type checker tells you
20:55:20 <carter> which is the exact same thing as doing a HUGE refactor, see how the type checker yells, then fix it
20:55:53 <pacak> nitrix: Just use more unsafeCoerces and type system won't get in your way.
20:56:11 <carter> pacak: somtimes that safe to do :)
20:56:13 <ackthet> i feel like map/reduce will make my life so much easier (i just went to a talk at school about basic FP)
20:56:29 <carter> ackthet: we call it map and foldl' here :)
20:56:33 <nitrix> I think haskell calls it fold.
20:56:45 <carter> foldl' or foldmap
20:57:09 <nitrix> foldl' being? The strict version?
20:57:12 <ackthet> ahh okay, it was basically general FP concepts with examples for haskell and closure (sp)
20:57:42 <pacak> carter: In boring cases - yes,  relatively safe. But who cares about boring cases...
20:58:23 <pacak> > unsafeCoerce (Just 42) :: [Int]
20:58:24 <lambdabot>  Not in scope: ‘unsafeCoerce’
20:58:25 <carter> pacak: i have just the present for you
20:58:26 <carter> hangon
20:58:43 <carter> pacak: https://gist.github.com/cartazio/c0b0f624ff0ba7489085 :) 
20:59:21 <fsfgsfg> @pl \xs n -> take n xs
20:59:21 <lambdabot> flip take
21:00:10 <pacak> carter: Yep, that works nicely.
21:00:28 <Cale> ackthet: Not sure if anyone linked you this yet http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
21:00:43 <Cale> ackthet: But a lot of people have been enjoying that course lately
21:00:49 <fsfgsfg> @pl Just eval <*> parseExp Lit Add Mul x
21:00:49 <lambdabot> Just eval <*> parseExp Lit Add Mul x
21:01:15 <fsfgsfg> @pl \x -> Just eval <*> parseExp Lit Add Mul x
21:01:15 <lambdabot> (Just eval <*>) . parseExp Lit Add Mul
21:01:38 <ackthet> nice, thanks
21:06:50 <ReinH> Just f <*> x = f <$> x
21:07:12 <ReinH> so you want fmap eval . parseExp Lit Add Mul
21:09:13 * hackagebot cartel 0.14.2.2 - Specify Cabal files in Haskell  http://hackage.haskell.org/package/cartel-0.14.2.2 (OmariNorman)
21:09:16 * hackagebot goatee 0.3.0 - A monadic take on a 2,500-year-old board game - library.  http://hackage.haskell.org/package/goatee-0.3.0 (khumba)
21:13:02 <ackthet> not seeing the type on variables is... disconcerting at first
21:14:03 <EvanR> IntFactory myIntFactor = new IntFactory(); 
21:15:04 <EvanR> other language X called they want their disconcerting back
21:15:49 <ackthet> well, i did start learning 5 minutes ago
21:16:04 <Cale> ackthet: Are you talking about the case where type inference is being used?
21:16:15 <ackthet> yeah
21:16:41 <Cale> Usually it's considered good style to at least give type signatures for top-level bindings
21:17:28 <Cale> You get better error messages as well if you give explicit signatures.
21:17:32 * ackthet is just playing around in ghci
21:17:43 <ackthet> but, noted
21:17:56 <Cale> But it's nice sometimes just to be able to write definitions without worrying about specifying the type
21:18:22 <EvanR> thats like, cowboy coding
21:18:29 <EvanR> only safe ;)
21:18:45 <hunteriam> whats the best way to generate an array and a Ptr in haskell?
21:18:54 <hunteriam> which module should i use, that is
21:18:58 <Iceland_jack> ackthet: One way to define it in GHCi is like this
21:18:58 <Iceland_jack>     ghci> let plusOne :: Int -> Int; plusOne x = x + 1
21:18:58 <Iceland_jack>     ghci> :t plusOne
21:18:58 <Iceland_jack>     Int -> Int
21:19:02 <EvanR> Foreign.Marshal
21:19:04 <hunteriam> theres CArray and Marshal Array
21:19:05 <Iceland_jack>     ghci> plusOne 15
21:19:05 <Iceland_jack>     16
21:19:15 <hunteriam> im not sure which one is better
21:19:33 <EvanR> hunteriam: you probably want a list and then on the C side a Ptr to whatever
21:19:47 <hunteriam> EvanR: how is that possible
21:20:14 <hunteriam> EvanR: also this is for gl
21:20:17 <EvanR> hunteriam: just to give you a heads up, when doing ffi, you should use alloca instead of malloc to get pointers to a single thing, it will clean up the temporary space for you
21:20:23 <EvanR> yeah i know
21:20:45 <hunteriam> EvanR: i really just need to turn a list into an array i think, would you agree?
21:20:50 <EvanR> newArray :: Storable a => [a] -> IO (Ptr a)
21:21:05 <ackthet> Iceland_jack: cool, i think i get it
21:21:06 <EvanR> withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
21:21:16 <EvanR> hunteriam: withArray is the array equivalent of alloca
21:21:24 <EvanR> but you will need alloca at some point soon
21:21:27 <hunteriam> what module is it in?
21:21:33 <EvanR> Foreign.Marshal.Array
21:21:48 <hunteriam> cool, thanks dude you've been really helpful today
21:25:03 <ackthet> should also note that haskell has the best error messages
21:25:37 <EvanR> thats a new one ;)
21:25:43 <Iceland_jack> haha
21:25:47 <ackthet> esp after dealing with g++
21:26:02 <Iceland_jack> Hm fair point
21:26:03 <ackthet> g++ "you screwed up... somewhere... probably"
21:26:32 <EvanR> more like 3 pages of gobbledegook with that string embeded in it in a disconnected fashion
21:26:39 <hunteriam> How would i replicate this -- I don't see how i can create a one length array with Array Marshal :/ GLuint vertexbuffer;  glGenBuffers(1, &vertexbuffer);
21:26:59 <EvanR> in that case dont make an array if you only want 1
21:27:11 <EvanR> use alloca to get temporary space for 1 object
21:27:27 <fsfgsfg> @ReinH Thanks!
21:27:27 <lambdabot> Unknown command, try @list
21:27:38 <fsfgsfg> (a little later, haha)
21:27:41 <hunteriam> oh right nice thanks evan
21:28:10 <hunteriam> except i think i want to keep the pointer to the buffer
21:28:16 <EvanR> no you dont
21:28:26 <EvanR> that doesnt give you the buffer anyway, it gives you an ineger
21:28:30 <EvanR> integer
21:28:40 <hunteriam> oh ok, thats great then
21:29:14 * hackagebot goatee-gtk 0.3.0 - A monadic take on a 2,500-year-old board game - GTK+ UI.  http://hackage.haskell.org/package/goatee-gtk-0.3.0 (khumba)
21:30:23 <hunteriam> EvanR: actually i think i do need that number back, since its reused for future calls
21:30:34 <EvanR> yeah you need the number, not the pointer or the space
21:30:42 <EvanR> so use peek
21:31:38 <funfunctor> :t (<|>)
21:31:39 <lambdabot> Alternative f => f a -> f a -> f a
21:31:48 <hunteriam> EvanR: could you give me an example of how id use that here without losing the value added to the array? I have allocaArray 1 $ glGenBuffers 1
21:32:13 <funfunctor> > Just 3 <|> Jusr 4
21:32:14 <lambdabot>  Not in scope: data constructor ‘Jusr’
21:32:14 <lambdabot>  Perhaps you meant ‘Just’ (imported from Data.Maybe)
21:32:24 <funfunctor> > Just 3 <|> Just 4
21:32:24 <EvanR> hunteriam: should be alloca $ \ptr -> do
21:32:25 <lambdabot>  Just 3
21:32:29 <EvanR>   glGenBuffers 1 ptr
21:32:31 <EvanR>   peek ptr
21:32:40 <hunteriam> alright thanks
21:33:03 <funfunctor> hunteriam: also there is heaps of examples in the hlibBladeRF package
21:33:17 <hunteriam> thanks fun functor ill check it out next time I'm wondering something
21:33:20 <funfunctor> hunteriam: http://hackage.haskell.org/package/hlibBladeRF
21:33:45 <EvanR> hunteriam: theres also tons of examples in lowgl wrapper package, and its gl related ;)
21:34:06 <hunteriam> thanks man
21:35:47 <lpaste> funfunctor pasted “No title” at http://lpaste.net/128051
21:36:12 <funfunctor> How would I go about fixing this parser to deal with zero or more arguments
21:36:49 <funfunctor> in the case of zero arguments I want Nothing in the Maybe otherwise the list of vaules each space delimited
21:37:17 <funfunctor> so, CMD arg1 arg2 .. becomes [arg1,arg2,..]
21:38:31 <EvanR> funfunctor: optparse-applicative is pretty good, the idea is you want to generate a more detailed options data structure than list of Maybe
21:38:52 <EvanR> like, thats not much better than list of strings
21:38:59 <EvanR> where some are ""
21:39:23 <EvanR> that package gives you a bunch of functionality for free
21:39:57 <funfunctor> oh man /another package/ I literally can't handle learning another package just at the moment..
21:40:13 <EvanR> toolbox getting heavy
21:40:14 <funfunctor> the requirement is fairly simple here
21:40:31 <EvanR> well if the options arent given how do you know which is Nothing
21:41:14 <funfunctor> EvanR: ok, maybe we can simplify further basically I just want to parser not to fail on 0 arguments
21:41:31 <funfunctor> many' should do that for me right?
21:41:31 <EvanR> do you just want a list of strings?
21:41:43 <funfunctor> I need a list of doubles
21:41:52 <EvanR> split on whitespace map read
21:42:01 <funfunctor> the format is: CMD SETRXGAiN 3.3 4.4
21:42:25 <funfunctor> and: CMD SETPOWERON
21:43:00 <EvanR> after SETRXGAIN you can use many and optional
21:44:34 <funfunctor> EvanR: do you mean option
21:44:38 <EvanR> yeah
21:45:07 <EvanR> if it fails to get at least one, you can take that as an empty list
21:45:43 <EvanR> if gibberish is there instead and thats supposed to be an error, you can require whitespace EOF after that
21:46:05 <funfunctor> EvanR: so v <- option [] (many' double)
21:46:15 <EvanR> something like that
21:46:28 <funfunctor> how to get that to deal with spaces in between values?
21:46:36 <EvanR> i thought you had that taken care of
21:46:42 <EvanR> use sepBy
21:46:59 <funfunctor> ok how do you tigh that together?
21:47:11 <EvanR> id have to pull up the docs
21:47:38 <EvanR> you do it ;)
21:47:59 <funfunctor> :p I know its some applicative thing but I was a little confused
21:48:13 <EvanR> i dont think you have to use applicative
21:50:18 <funfunctor> ok I think commaSep p  = p `sepBy1` space is it 
21:50:33 <EvanR> comma = space ?
21:50:33 <funfunctor> well somerthing like that ;)
21:50:50 <funfunctor> spaceSep p  = p `sepBy1` (symbol ' ')
21:50:54 <EvanR> (note that '\n' equals space ;)
21:51:21 <EvanR> well you probably want to be more lenient with whitespace
21:51:24 <ski> (s/equals/is included in/ ?)
21:52:19 <EvanR> remark equals equals for some value of equals
21:53:40 <funfunctor> EvanR: well I got as far as v <- option [] many' (double `sepBy1` (char ' '))
21:53:50 <funfunctor> but something is wrong there
21:54:08 * EvanR guesses what it is
21:54:51 <EvanR> k i give up
21:55:42 <pavonia> option doesn't take that many argument, does it?
21:55:43 <EvanR> maybe you need parens around many (doub e.. )
21:56:11 <EvanR> the compiler error message should say something to the effect of what pavonia said
21:56:37 <ackthet> how come if i do plusOne x = x + 1 in ghci, it bitches at me (it will work if it do let plusOne :: Int -> Int; plusOne x = x + 1) but if i compile it it works fine?
21:56:45 <ackthet> (sorry for newb questions)
21:56:59 <EvanR> ghci is like in a do block
21:57:06 <EvanR> so you need let foo = bar
21:57:24 <Iceland_jack> ackthet: the 'let'
21:57:25 <funfunctor> ok v <- option [] (many' (double `sepBy1` space)) is better but [[Double]] but [Double] expected
21:57:55 <ackthet> Iceland_jack: right, i was more wondering what was different
21:57:58 <funfunctor> ah hmm
21:58:05 <ackthet> i think EvanR covered it
21:58:27 <khumba> funfunctor: Just jumping in here, but what does many' do; do you need it there?  sepBy and sepBy1 already read a list of 'double's.
21:58:56 <funfunctor> khumba: ah oh yea i'm confused thats it
21:59:22 <ski> ackthet : GHCi accepts expressions and `do'-commands (and some more things). `let plusOne x = x + 1 in [plusOne n | n <- [3,1]]' is an expression, `let plusOne x = x + 1' is a (`do'-)command, `plusOne x = x + 1' is a declaration (specifically a definition)
22:00:32 <funfunctor> I don't think ill ever master parsers
22:04:26 <EvanR> funfunctor: if you doubt mastery, then doubt will master you
22:04:51 <funfunctor> EvanR: ;)
22:04:59 <ackthet> ski: thanks
22:05:02 <echo-area> Is there a function that has type `Monad m => (m b -> m c) -> (m a -> m b) -> (m a -> m c)`?
22:05:04 <funfunctor> well my parser works I guess
22:05:10 <Iceland_jack> @ty (>=>)
22:05:11 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:05:19 <funfunctor> CMD SETMAXDLY 3.3 4.4 5
22:05:20 <funfunctor> [ 127.0.0.1:5701 ] Response was: { RSP SETMAXDLY 1 [3.3,4.4,5.0] }
22:05:23 <Iceland_jack> Or (<=<) is not the same, but similar
22:05:36 <echo-area> Iceland_jack: But those two are not what I meant
22:05:48 <Iceland_jack> Yeah, I'm not sure about the exact type
22:05:51 <ski> echo-area : `(.)'
22:06:21 <ski> @type (.) :: Monad m => (m b -> m c) -> (m a -> m b) -> (m a -> m c)
22:06:21 <lambdabot> Monad m => (m b -> m c) -> (m a -> m b) -> m a -> m c
22:06:30 <Iceland_jack> (ah derp.....)
22:07:08 <echo-area> ski: So the normal compose operator can be applied to monads as well?
22:07:32 <ski> echo-area : in this case, it doesn't care that `m' is a monad. `(.)' will just ignore that fact
22:07:47 <echo-area> ski: I see.  Thank you!
22:07:48 <EvanR> the above type is a specialization of the usual ftype for .
22:07:49 <ski> this is really no different from e.g.
22:07:54 <EvanR> s/ftype/type/
22:08:12 <ski> @type (.) :: Ord a => (a -> String) -> (Integer -> a) -> (Integer -> String)
22:08:13 <lambdabot> Ord a => (a -> String) -> (Integer -> a) -> Integer -> String
22:09:26 <ski> in both cases it'll ignore the constraint (`Monad m'/`Ord a'), and just pass the things around, without caring whether they're `m a's or `Integer's or what-not
22:10:31 <echo-area> Yeah I have seen similar patterns when I try to deduce types of expressions on paper.  I think I need to learn something about Husk
22:10:45 <echo-area> Thanks all
22:10:51 <dmwit> I don't think you do.
22:11:07 <echo-area> dmwit: What?
22:11:10 <dmwit> Assuming "Husk" is a typo for "Hask", the "category" of Haskell types and functions.
22:11:29 <dmwit> I don't think you need to learn anything about category theory to understand what happened with composition here.
22:12:06 <ski> echo-area : another similar thing is wanting to do some kind of monadic fold, only realizing it's just the ordinary `foldr' with result type specialized to `m r' when you're spelled out the definition
22:12:47 <echo-area> dmwit: Sure.  What I meant was not to understand things happened there.  I meant to be able to explain everything happens in the compiler
22:13:18 <dmwit> You can probably do all of that comfortably without any CT, too.
22:13:43 <dmwit> I don't want to discourage you from learning CT if that seems interesting to you.
22:13:51 <dmwit> But it's definitely not a prerequisite.
22:14:08 <echo-area> ski: Noted.  Thanks
22:14:51 <funfunctor> stupid C++ code.. it wants the command returned but with padding of whitespaces of a certain length
22:14:52 <ackthet> oh, one more question, what style guide do you guys recommend, don't want to form any bad habits
22:15:35 <ski> ackthet : write readable code
22:15:45 <platz> lol haskell style guide
22:15:57 <ackthet> ski: im a physics grad, thats the last thing I know how to do
22:16:04 <kadoban> ackthet: Use hlint. Do most of what it tells you to do.
22:16:30 <ackthet> oh cool, thanks
22:16:32 <platz> hlint is actually very good
22:16:34 <funfunctor> > repeat space
22:16:36 <lambdabot>  [ , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ...
22:16:36 <dmwit> glguy: Thank you for the comment in irc-core.cabal about why you made the restriction on base that you did.
22:16:37 <EvanR> funfunctor: this package lets you exactly layout text https://hackage.haskell.org/package/boxes-0.1.4
22:16:50 <EvanR> what you broke lambdabot
22:17:30 <funfunctor> EvanR: thx
22:17:32 <funfunctor> hehe
22:17:38 <ski> ackthet : sometimes hlint comes with silly suggestions
22:17:52 <pavonia> :t space
22:17:52 <lambdabot> Doc
22:18:15 <ski> (consider what it says more as rough guidelines, in the best case)
22:18:26 <ski> (`Doc' is a bit evil, yes)
22:19:46 <echo-area> dmwit: I see.  When I made deductions of types, I also made several hypotheses about the correctness of the steps I took, e.g. priority, left or right associative etc.  I am not sure even now.  That is my trouble and I want to solve it later on.
22:20:19 <dmwit> echo-area: That sounds like a good idea. People in this channel can definitely help with that.
22:21:02 <dmwit> We've got a lot of type theory experts; and at the beginning, even type theory beginners will be able to help. =)
22:22:48 <shachaf> dmwit: I found out the hard way. :-(
22:23:38 <glguy> dmwit: I hope you saw it before you forged ahead ^_^
22:25:19 <dmwit> I did. =)
22:25:46 <dmwit> shachaf: Thanks for finding out th ehard way!
22:29:36 <glguy> dmwit: Did you get it installed or was 7.8.4 a deal breaker?
22:30:22 <dmwit> Still installing 7.8.4.
22:30:34 <dmwit> Upgrading GHC is not really a dealbreaker.
22:33:10 <dmwit> Not sure whether I'll have time to play with it tonight, though.
22:36:36 <glguy> It'll be around for a while :)
22:42:26 <Guest51330> Hey.
22:42:57 <Guest51330> Does the string parser from parsec consume any input on failure?
22:43:19 <ski> no parsec parser should do that
22:43:21 <Guest51330> so `string "Hello World"` on "Hellish world" will fail, but will it consume any input?
22:43:51 <Guest51330> ski: that's not what the docs say.
22:45:00 <ski> perhaps you're talking about whether you need a `try' or not
22:45:01 <pacak> Guest51330: There's `try' to prevent it from doing that.
22:45:09 <ski> (which is a different thing)
22:45:11 <dmwit> I think I know how to count how many fully-defined inhabitants a type has now.
22:45:45 <Guest51330> ski: Yup.
22:45:49 <ski> dmwit : for stuff like `forall a. a -> a -> a' ?
22:45:56 <dmwit> ski: I think "consume" is a technical term in Parsec that means "do I need try".
22:46:11 <dmwit> ski: I don't try to do arrows. Just sums, products, and recursion.
22:46:21 <dmwit> Not even polymorphism.
22:46:25 <ski> dmwit : ok
22:46:33 <hunteriam> (void*)0  
22:46:36 <hunteriam> what is that in haskell
22:46:38 <Guest51330> ski: Okay, so `string "Hello" <|> string "Hellish"` do I need to insert a try there somewhere?
22:46:39 <dmwit> Seems that's hard enough already.
22:46:40 <hunteriam> is that the same as null ptr?
22:46:46 <dmwit> :t nullPtr
22:46:46 <lambdabot> Not in scope: ‘nullPtr’
22:46:50 <Guest51330> hunteriam: We don't have that in Haskell.
22:46:54 <dmwit> Yes we do.
22:46:58 <dmwit> ?hoogle nullPtr
22:46:59 <hunteriam> is it the same as nullptr?
22:46:59 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
22:47:06 <dmwit> Yes.
22:47:09 <hunteriam> Guest51330: we have everything in haskell
22:47:11 <hunteriam> neat, thanks
22:47:24 <dmwit> Well. Not quite. But (void*)NULL is similar to nullPtr.
22:47:27 <ski> dmwit,Guest51330 : i wouldn't express it as "does it consume input", but rather "does it commit after initially consuming input in an attempt" or something like that
22:47:29 <dmwit> (void*)0 is an abomination.
22:47:37 <hunteriam> dmwit: its for opengl
22:47:41 <hunteriam> dmwit: its legit somehow
22:47:42 <dmwit> I don't care what it's for.
22:47:43 <Guest51330> ski: Well, that's what the docs say.
22:48:00 <dmwit> It's legal, but not what I would call legit. NULL exists for a reason.
22:48:20 <ski> dmwit,Guest51330 : perhaps the docs use "consume input" as a shorthand for that longer one, but if so, i think they should explain what it really means somewhere
22:48:34 <Guest51330> dmwit: so if I have two string parsers that start off with the same substring, do I need to use a try?
22:48:50 <dmwit> Yes, or factor the shared prefix.
22:48:50 <ski> Guest51330 : yes, unless you factor
22:49:37 <Guest51330> Argh okay, thanks.
22:49:49 <Guest51330> I'm parsing Python, and there's a bunch of keywords that start off the same.
22:50:11 <ski> (this is one reason why i think parsec isn't that nice. i understand that there's reasons for it being like this, but i'd prefer a nicer solution, that didn't need any such silly `try' thing ... :)
22:50:48 <dmwit> Guest51330: You can tokenize first; or you can write a combinator that understands collections of strings.
22:51:00 <dmwit> I'm a bit surprised there isn't something like the latter in parsec already, in fact.
22:51:15 <Guest51330> dmwit: I'm actually writing a tokenizer.
22:52:14 <Guest51330> So I have `keywords = ["def", "class", ...]` and I thought I could implement keyword tokenization like this.
22:52:44 <Guest51330> `keyword = liftM ID $ foldl (<|>) (map string keywords)`
22:52:57 <Guest51330> but that's clearly not going to work if Parsec doesn't backtrack.
22:53:39 <dmwit> Right. You could instead build a trie-like structure. It's a bit more work, but maybe not all that much after all.
22:54:15 <dmwit> But I'm a little bit surprised how precise you're trying to be if you're just writing a tokenizer.
22:54:18 <ski> (hm .. i believe Parsek would do this automatically for you)
22:54:43 <dmwit> I was sort of under the impression that tokenizers generally just broke things up at spaces and punctuation, with some extra code for comments and strings.
22:54:44 <Guest51330> dmwit: Being precise?
22:54:56 <khumba> Is `map (try . string)` too ugly? :)
22:55:09 <Guest51330> Oh right, yeah, it just makes the parsing stage easier.
22:55:12 <dmwit> khumba: It could be pretty slow.
22:55:42 <Guest51330> khumba: try has a performance penalty on failure.
22:55:57 <khumba> Oh okay, thanks -- haven't looked into the 'why' of parsec design yet.
22:56:01 <Guest51330> ski: parsek?
22:56:08 <ski> @hackage parsek
22:56:08 <lambdabot> http://hackage.haskell.org/package/parsek
22:57:02 <ski> (doesn't have as much stuff. and is based around a different implementation idea)
22:57:07 <Guest51330> Okay.
22:57:27 <Guest51330> dmwit: How do I build a trie?
22:57:45 <ski> basically it tries to explore different alternatives in parallel. so the effect is that it automagically factors
22:58:22 <Guest51330> Just give me the basic idea; this isn't homework, but I'm treating it as such if I want to learn Haskell properly.
22:58:22 <hunteriam_> I've got a function taking  Ptr () that i need to stuff a [Float] into
22:58:42 <hunteriam_> what ma i supposed to do? all the marshaling functions generate typed ptrs
22:58:53 <dmwit> Guest51330: Well. Are you planning to do everything yourself, or lean on libraries?
22:59:18 <Guest51330> dmwit: depends. What do you mean by lean on libraries?
22:59:26 <hunteriam_> Guest51330: use libraries
22:59:28 <dmwit> Guest51330: If the former, Wikipedia probably has some information on how tries work. If the latter, there's several packages on Hackage, and I can point you at one that I have used in the past and found to have a pretty complete API.
22:59:31 <Guest51330> I'm using Text.Parsec and Control.Monad thus far.
22:59:48 <hunteriam_> [Float] ->  Ptr () anyone?
23:00:05 <Guest51330> dmwit: Does a trie structure come with the Haskell Platform?
23:00:14 <Guest51330> hunteriam_: Forgive my ignorance, but what is OpenGL for?
23:00:19 <hunteriam_> Guest51330: graphics
23:00:21 <dmwit> Guest51330: dunno what's in the Platform
23:00:28 <ElderFain> any preferences on http packages? https://hackage.haskell.org/package/http-streams or http-conduit or even the FFI bindings for curl.lib ... 
23:01:03 <ski> hunteriam_ : hm, why not `Ptr Float' ?
23:01:03 <dmwit> hunteriam: You can poke Float's into a Ptr Float. Why do you want it to be a Ptr ()?
23:01:22 <hunteriam> dmwit: the function I'm calling takes a Ptr ()
23:01:28 <hunteriam> dmwit: its throwing up errors
23:01:32 <hunteriam> i think i have to cast it
23:01:36 <Guest51330> dmwit: No, I get how to build a trie, just how do I use it here?
23:01:53 <dmwit> Guest51330: To factor the shared prefixes of your strings for you. =)
23:02:00 <ski> (.. why does it take a `Ptr ()' ?)
23:02:19 <dmwit> hunteriam: Something smells.
23:02:20 <bramgg> What packages come with the default Haskell Package install? Is it all of Base?
23:02:35 <Guest51330> bramgg: Nope.
23:02:43 <Guest51330> I've had to install some base packages.
23:02:54 <Guest51330> dmwit: Okay, fine.
23:02:58 <Guest51330> I'm not sure I get it, but I'll do my best.
23:03:04 <bramgg> Guest51330: thanks
23:03:21 <bramgg> Am I correct in thinking that it installs more than just Prelude though?
23:03:55 <dmwit> Guest51330: I just mean if you stuff ["foobar", "foobaz"] into a trie, you're going to get out a trie that looks like Prefix "fooba" [Prefix "r" [], Prefix "z" []] or something.
23:04:06 <hunteriam_> ski: dmwit glBufferData :: MonadIO m => GLenum -> GLsizeiptr -> Ptr () -> GLenum -> m ()
23:04:16 <Guest51330> bramgg: Yeah, it has a good bit.
23:04:17 <hunteriam_> the Ptr () is the vertices data afaik
23:04:32 <dmwit> Guest51330: Then when you traverse that thing you can make it string "fooba" >> ((string "r" >> return "foobar") <|> (string "z" >> return "foobaz")) or whatever.
23:04:43 <dmwit> Guest51330: And the transformation from a trie to the factored grammar is straightforward.
23:04:47 <Guest51330> Ooooh okay right that's awesome.
23:05:09 <Guest51330> I haven't ever seen this before.
23:05:37 <dmwit> bramgg: You can see on Hackage all the modules provided by GHC's base:
23:05:39 <dmwit> ?hackage base
23:05:39 <lambdabot> http://hackage.haskell.org/package/base
23:05:54 <dmwit> bramgg: Though I think GHC comes with a number of other packages as well. array, containers, that kind of thing.
23:05:55 <Guest51330> dmwit: Is this standard stuff?
23:06:09 <bramgg> dmwit: thanks!
23:06:10 <dmwit> Guest51330: What is "this"? What does "standard" mean?
23:06:17 <bramgg> oh, yeah
23:06:32 <bramgg> was wondering what else comes with it
23:06:45 <Guest51330> Using a trie to parse? Like is this taught in compilers classes?
23:07:20 <dmwit> My GHC came with 25 packages.
23:07:36 <dmwit> You can "ghc-pkg list" to see what packages your GHC knows about.
23:07:51 <Guest51330> brb guys.
23:08:00 <dmwit> Guest51330: Dunno. But tries are a specialization of regular languages, which are definitely taught in compilers classes.
23:08:20 <hunteriam_> I'm taking a ~compiler class
23:08:25 <hunteriam_> we have not been taught tries
23:08:32 <hunteriam_> we have been taught regular languages
23:09:22 <dmwit> Tries are tree-shaped DFAs.
23:10:06 <breadmonster> dmwit: Is it standard to use tries for parsing?
23:10:20 <dmwit> I have no idea!
23:10:24 <dmwit> Probably not?
23:11:08 <dmwit> I mean, even if Guest51330 does the thing, he won't really be using tries for parsing, right? Just using them to build the parser.
23:11:12 <dmwit> Which is a different task.
23:11:25 * ski recalls hearing about somone using tries to construct rap lyrics
23:11:49 <augur> is it possible to define   type constraint C a = (C' a, C'' a)
23:11:52 <augur> or something like that?
23:11:57 <arkeet> yes
23:12:15 <arkeet> well, without the word "constraint"
23:13:03 <augur> arkeet: if you just do   type C a = (C' a, C'' a)   you'll get C :: * -> * th
23:13:04 <augur> tho
23:13:09 <augur> i want C :: * -> Constraint
23:13:34 <arkeet> uh no, not if C' and C'' have kind * -> Constraint
23:13:45 <dmwit> augur: ConstraintKinds
23:13:50 <arkeet> oh yeah you need that
23:14:00 <augur> oh yes thats true arkeet. im a dope. :)
23:14:36 <dmwit> () :: () :: * and () :: Constraint
23:14:38 <dmwit> confusing
23:14:51 <augur> then i propose that we define:   type Applicative f = (Pointed f, Apply f)
23:15:17 <dmwit> augur: Congratulations. You just broke every library that includes "instance Applicative Foo"
23:15:21 <augur> class Pointed f where point :: a -> f a    class Apply f where apply :: f (a -> b) -> f a -> f b
23:15:26 <augur> dmwit: yes i know :)
23:15:34 <arkeet> there must be some other thing that breaks.
23:15:35 <ski> doesn't work, you also need laws relating `pure' to `apply'
23:15:38 <dmwit> Though there are proposals to deal with that, too.
23:15:40 <breadmonster> dmwit: I am Guest51330.
23:15:50 <augur> ski: yes tho those are ephemeral in haskell anyway
23:16:04 <ski> should still be a common subclass (with no operations)
23:16:07 <dmwit> breadmonster: Okay. Then: even if *you* do the thing... =P
23:16:13 <breadmonster> Haha :P
23:16:27 <jle`> although i suppose this discussion is more about typeclass trickery than with actual typeclass design issues
23:16:49 <ski> (so if you use that in a constraint, you're expressing that you're (possibly) relying on those "coherence" laws to hold)
23:16:54 <augur> i like the idea of fragmenting out functionality and using conjunction + laws to make the bigger classes we want
23:17:09 <ski> augur : that's sortof what Clean does
23:17:14 <augur> ski: oh?
23:17:25 <breadmonster> dmwit: So yeah, that's what I was thinking, it would make an interesting bit of code.
23:17:30 <ski> it has a class named `+' that only contains the `(+)' operation
23:17:32 <ski> and so on
23:18:03 <augur> Magma~
23:20:24 <Axman6> anyone have any preference for how to do logging in haskell? looking for something suitable for a web app, but general purpose enough that we can use it in other apps like cron jobs
23:21:06 <breadmonster> Axman6: Logging for errors?
23:21:24 <Axman6> well, preferably with log levels
23:22:28 <breadmonster> dmwit: The other hiccup I had with the parser is that Python is whitespace sensitive.
23:27:51 <breadmonster_> dmwit: What I usually do for something like that would be to walk through the source in C++, keeping track of the indentation level at each line.
23:27:59 <breadmonster_> Though this can't be done in Haskell.
23:28:52 <breadmonster_> So what I was thinking of doing was to look at the first line, and count the indentation.
23:32:43 <dmwit> breadmonster_: Why not do it the way the original Python implementation does?
23:32:51 <breadmonster_> And then define some parser pyWhitespace = string "..." where the ... is the first line indentation, and run 
23:33:30 <dmwit> i.e. track what levels are currently "known" in the tokenizer, and emit indentation tokens.
23:34:01 <breadmonster_> dmwit: Yeah, but that's from an imperative frame of mind, yeah?
23:34:12 <dmwit> So "foo:\n  bar:\n     baz\n  quux" gets tokenized to foo newline indent bar newline indent indent baz newline indent quux
23:34:34 <dmwit> I don't really know what that means. But it seems pretty reasonable to me.
23:40:00 <lpaste> wizao pasted “Is there a common function to replace this:?” at http://lpaste.net/128057
23:42:24 <augur> what's an orphan instance?
23:42:27 <MP2E> wizao: f <$> (fa x) <$> (fb x) ?
23:42:36 <MP2E> (@ your lpaste)
23:42:42 <wizao> hmm
23:43:02 <wizao> i originally was using applicatives when the fa and fb were not monadic
23:43:23 <wizao> f <$> fa <*> fb
23:43:33 <wizao> But i had to use that and just was wondering
23:43:41 <wizao> I'll try that out
23:44:55 <shachaf> You should include the type in your pastes.
23:45:02 <shachaf> Otherwise people have to work hard to understand them.
23:45:15 <shachaf> Anyway, (liftA2 . liftA2) does the thing you want.
23:45:21 <MP2E> ooh
23:45:24 <MP2E> even better.
23:45:25 <shachaf> But I don't think I recommend it as opposed to just writing it out.
23:45:53 <wizao> I'll be sure to add the signature in the future
23:46:08 <wizao> thanks thats a good one
