00:00:06 <Hijiri> it's definitely not portable though, although whether that matters in the era of everything-ghc is debatable
00:00:13 <Hijiri> it's also ugly if you don't really, truly need it
00:00:16 <bloot> I'm happy as long as it works with ghc
00:00:41 <bloot> and my code is already ugly :D
00:00:47 <bloot> so
00:00:56 <bloot> myRef = unsafePerformIO $ newIORef?
00:00:59 <Hijiri> if it's something you could have multiple states across different parts of the program and not break everything, it's not something you want to do generally
00:01:15 <Hijiri> yes, I think that's how it would work
00:01:15 <bloot> I just need it for debugging.
00:01:32 <bloot> @hoogle unsafePerformIO
00:01:34 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
00:01:34 <lambdabot> Foreign unsafePerformIO :: IO a -> a
00:03:06 <bramgg> why doesn't lambdabot provide hoogle links for the hoogle command? Seems logical.
00:03:20 <bramgg> err, the links that hoogle provides
00:03:23 <Hijiri> the lambdabot's hoogle is the instance on lambdabot
00:03:44 <Hijiri> I think local hoogle doesn't give you hackage links
00:04:12 <bramgg> ah, interesting
00:05:46 <bloot> Hijiri: http://codepad.org/7gdI08iv
00:05:50 <bloot> at least it looks like it works
00:06:57 <Hijiri> am I looking at lisp?
00:07:02 <bloot> yes
00:07:13 <bloot> a lisp dialect to be precise
00:10:42 <ski> bloot : is `atom' something like SRFI 26 "Notation for Specializing Parameters without Currying" by Sebastian Egner in 2002-0[26] at <http://srfi.schemers.org/srfi-26/srfi-26.html> ?
00:43:10 <gamegoblin> I’m looking to have a ~2GB cache — should I abandon the idea of using a purely functional datastructure and just go with a mutable array?
00:48:03 <vandenoever>  /join #yesod
00:48:06 <vandenoever> oops
00:48:22 <Zemyla> Hey, that's channel advertising! :P
00:48:56 <bernalex> Zemyla: at least it's relatively on-topic chan advertising. :-]
01:02:10 <bloot> ski: let me read that article
01:02:27 <HeladoDeBrownie> how do i go from [a] to ListT Identity a?
01:02:54 <Zemyla> :t ListT . fmap Identity
01:02:55 <lambdabot> Not in scope: data constructor ‘ListT’
01:03:11 <bloot> ski: It "Blocks" Evaluation
01:03:17 <pavonia> Without the fmap, no?
01:03:22 <bloot> i.e. (add 5 5) evaluates to 10
01:03:29 <bloot> (atom (add 5 5)) evaluates to (add 5 5)
01:03:47 <gfixler> I can't remember a name for list concatenation using functions
01:03:51 <EvanR_> bloot: atom = quote?
01:03:58 <gfixler> the one that avoids walking the same list over and over
01:04:16 <bloot> EvanR_: pretty much, yes
01:04:28 <EvanR_> ok ;)
01:04:42 <EvanR_> bloot: in clojure atom is something else
01:04:52 <gfixler> I remember thinking it wasn't a great name for them, which could be why it didn't stick
01:05:01 <pavonia> gfixler: Do you mean ShowS?
01:05:17 <bloot> EvanR_, ski: http://codepad.org/Bf129Ubd
01:05:31 <gfixler> pavonia: apparently I do - but the words I was looking for were: difference list
01:05:44 <gfixler> pavonia: (which showS helped me find, so thanks)
01:06:18 * gfixler thinks showS is also not all that great a name for these... sigh
01:06:49 <HeladoDeBrownie> Zemyla, that doesn't look right to me, or maybe you're relying on a specific implementation of ListT that isn't the same one i'm using. regardless, i think it should be possible without using a constructor.
01:08:23 <HeladoDeBrownie> although i could be wrong…
01:08:41 <HeladoDeBrownie> this seems like it should be a simple problem. maybe i just need to go to bed
01:09:59 <pavonia> HeladoDeBrownie: ListT . Identity should work, at least the same pattern is used for EitherT
01:10:21 <pavonia> or even ListT . return
01:10:58 <HeladoDeBrownie> pavonia, i don't know what ListT you're using
01:10:59 <bloot> EvanR_: http://codepad.org/AIBKG18Y
01:11:11 <HeladoDeBrownie> pavonia, i'm using the one from pipes, which has no ListT constructor
01:11:18 <pavonia> The transformer's one
01:11:28 <HeladoDeBrownie> but i didn't think that ought to matter, since it shouldn't have to use a constructor
01:12:12 <bloot> However: ~(do #(1 2) (atom *(add $0 $1))) does not result in an INTEGER
01:12:29 <bloot> ~(eval (do #(1 2) (atom (add &0 &1)))) does result in an INTEGER
01:12:43 <bloot> mainly (type 3) == INTEGER (type (atom 3)) == EXPRESSION
01:12:45 <EvanR_> bloot: what language is this
01:13:00 <bloot> EvanR_: It doesn't have a name yet
01:13:03 <bloot> it's a WIP of mine
01:13:22 <bloot> I call it P@ for now
01:13:35 <pavonia> HeladoDeBrownie: I think you can use lift then
01:13:53 <bloot> (atom (add $0 $0)) is essentially \x -> x + x
01:14:00 <bloot> except you have to eval it
01:14:01 <bloot> like
01:14:10 <bloot> (eval (atom (add $0 $0)) 1)
01:14:16 <EvanR_> bloot: maybe #haskell-blah is better place for it
01:14:18 <bloot> :)
01:14:26 <bloot> K. Sry.
01:14:41 <EvanR_> dynamic types will rot your brain
01:15:42 <bloot> well... I do have a typesystem in my mind that copes with that
01:15:54 <EvanR_> oh?
01:20:22 <mauke\> EvanR_: I'm comfortable with languages where it's unclear what a "type" even is :-)
01:21:51 <EvanR_> mauke\: that would be better
01:22:33 <EvanR_> than languages where "type" is a special language construct corresponding to record </rant>
01:22:37 <HeladoDeBrownie> i ended up using foldr (\x xs -> lift x <> xs) mzero . map return. probably can be better but works fine
01:23:00 <mauke\> hmm
01:23:20 <mauke\> foldr . map can be fused
01:23:34 <mauke\> foldr (\x xs -> lift (return x) <> xs) mzero
01:23:55 <HeladoDeBrownie> ah true. thanks
01:24:04 <Zemyla> Or just foldr (mplus . return) mzero
01:24:46 <Zemyla> :t Foldable.foldr (mplus . return) mzero
01:24:48 <lambdabot> Not in scope: ‘Foldable.foldr’
01:24:59 <HeladoDeBrownie> even better
01:25:02 <Zemyla> :t F.foldr (mplus . return) mzero
01:25:03 <lambdabot> (Foldable t, MonadPlus m) => t a -> m a
01:25:53 <Zemyla> :t F.foldr ((<|>) . pure) empty
01:25:53 <lambdabot> (Foldable t, Alternative f) => t a -> f a
01:27:06 <Zemyla> > (F.foldr (mplus . return) mzero [1, 2]) >>= (guard . (/= 1))
01:27:07 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
01:27:08 <lambdabot>    arising from a use of ‘M80740319731578970508437.show_M80740319731578970508...
01:27:08 <lambdabot>  The type variable ‘m0’ is ambiguous
01:27:18 <Zemyla> > (F.foldr (mplus . return) mzero [1, 2]) >>= (guard . (/= 1)) :: Maybe ()
01:27:19 <lambdabot>  Nothing
01:27:38 <merijn> Zemyla: Could you move your playing around to private messages/ghci?
01:27:49 <Zemyla> Okay.
01:34:58 <Athas> Anyone here with type-natural experience?
01:37:15 <mniip> Athas, natural as in natural numbers?
01:37:53 <Athas> mniip: yes, this library: https://hackage.haskell.org/package/type-natural-0.2.3.2/docs/Data-Type-Natural.html
01:38:04 <Athas> I'm getting all lost in this nest of singletons and type-level naturals.
01:45:13 <mrkkrp> Suppose I have a function `f :: a -> b -> c' and a tuple `(a, b)', what is the most elegant way to apply the function to the tuple and get result of `c' type?
01:45:27 <EvanR_> :t curry
01:45:28 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:45:36 <EvanR_> :t uncurry
01:45:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
01:45:52 <mrkkrp> EvanR, excellent! Thanks!
01:48:27 <merijn> Athas: What are you getting lost with?
01:49:24 <mrkkrp> One more question: is there some way to apply function `a -> b' to a tuple `(a, a)' to get `(b, b)'. I'm learning arrows now, and `f *** f' is pretty close.
01:49:56 <EvanR_> :t (***)
01:49:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:50:08 <EvanR_> a = (->)
01:51:18 <mrkkrp> EvanR_: so, f *** f is OK?
01:51:28 <EvanR_> :t f *** f
01:51:29 <lambdabot> (FromExpr (a b' c'), FromExpr (a b c), Arrow a) => a (b, b') (c, c')
01:51:41 <merijn> :t (&&&)
01:51:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
01:51:48 <merijn> oh, wrong one
01:52:13 <merijn> :t odd *** odd
01:52:14 <lambdabot> (Integral a, Integral b') => (a, b') -> (Bool, Bool)
01:52:31 <merijn> Or for extra obfuscation
01:52:34 <merijn> :t join (***) odd
01:52:35 <lambdabot> Integral b' => (b', b') -> (Bool, Bool)
01:53:21 <lpaste> bramgg pasted “Holy shit I did it!” at http://lpaste.net/214270171731197952
01:53:47 <bramgg> ^ 2 AM and stoked. Only question now is how would the pros merge that into one function?
01:54:23 <mauke\> I'd simplify it first
01:54:37 <merijn> simplify first, then merge
01:54:42 <bramgg> mauke\: anything big jump out, besides lpaste's suggestions?
01:54:46 <merijn> I'd use guard over case for the bool, for example
01:55:11 <mauke\> leading (x : xs) = length (filter (x ==) xs)
01:55:18 <mauke\> + 1
01:55:33 <bramgg> -_-
01:55:54 <merijn> bramgg: Ideally you'd be able to merge the cases on line 5 and 6
01:56:22 <mauke\> :t map (length &&& head) . group
01:56:23 <lambdabot> Eq c' => [c'] -> [(Int, c')]
01:56:23 <bramgg> merijn: looks like mauke\'s code does that?
01:56:53 <merijn> mauke\: nice
01:57:05 <mauke\> > (map (length &&& head) . group) "bramgg"
01:57:06 <lambdabot>  [(1,'b'),(1,'r'),(1,'a'),(1,'m'),(2,'g')]
01:57:42 <merijn> Although maybe a bit to concise to arrive at for a beginner :p
01:58:04 <mauke\> yeah, I'm now thinking about how I'd do it "manually"
01:58:16 <bramgg> woah
01:58:29 <merijn> @quote jcreigh hyper-monad
01:58:29 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement for your entire program.")
01:58:34 <bramgg> did you just rewrite my program in 0.5 lines of code
01:58:51 <bramgg> ^^ relevat quote
01:59:13 <merijn> bramgg: He's being clever by abusing the laziness of group and map to make a nicely streaming implementation
01:59:24 <bramgg> :t group
01:59:25 <lambdabot> Eq a => [a] -> [[a]]
01:59:41 <bramgg> :t group is "not in scope" for me
01:59:42 <lambdabot>     Not in scope: ‘is’
01:59:42 <lambdabot>     Perhaps you meant one of these:
01:59:42 <lambdabot>       ‘id’ (imported from Data.Function),
01:59:43 <mniip> > group "hhhellllloo"
01:59:45 <lambdabot>  ["hhh","e","lllll","oo"]
01:59:51 <mniip> bramgg, Data.List
01:59:54 <bramgg> ahhh
02:00:00 <mauke\> @index span
02:00:01 <lambdabot> Data.List, Prelude
02:00:04 <bramgg> Prelude only was my self set task
02:00:10 <lpaste> mauke annotated “Holy shit I did it!” with “Holy shit I did it! (annotation)” at http://lpaste.net/214270171731197952#a122580
02:00:27 <mauke\> bramgg: ^ (untested)
02:00:44 <mauke\> and it's broken
02:00:46 <mniip> mauke, xs'
02:00:53 <lpaste> mauke revised “Holy shit I did it! (annotation)”: “No title” at http://lpaste.net/122580
02:01:06 <mniip> also
02:01:10 <mniip> I would use xs@(x:_) instea
02:01:24 <mauke\> why?
02:01:25 <mniip> span call doesn't change at all but you get rid of the ugly +1 in length
02:01:36 <mauke\> but you gain a redundant comparison
02:01:55 <lpaste> merijn annotated “Holy shit I did it!” with “Holy shit I did it! (annotation)” at http://lpaste.net/214270171731197952#a122582
02:01:58 <mauke\> (==) can be slow
02:02:23 <merijn> bramgg: I'd write the straightforward implementation like that
02:02:30 <merijn> Although I didn't check that compiles :p
02:02:46 <mauke\> needs more strictness in n
02:02:54 <merijn> mauke\: Yeah, I was just about to remark that
02:03:09 <merijn> But that seemed a bit complex to mention
02:03:35 <merijn> mauke\: To be fair, doesn't your "head &&& length" leak memory due to not forcing length?
02:03:39 <mauke\> mniip: I don't think the +1 is ugly, btw. it nicely shows that I expect the result list to be all positive
02:03:49 <bramgg> merijn: I'm assuming last implementation on the link you gave?
02:03:58 <merijn> bramgg: runLength, yeah
02:04:07 <bramgg> merijn: compiles & works
02:04:13 <merijn> bramgg: Rule 1 of recursion: Always introduce helpers that make your life easy :)
02:04:18 <mauke\> merijn: yeah, probably
02:04:55 <bramgg> damn, that's some impressive stuff. Gonna spend some time going over what you guys did and understanding it.
02:05:27 <merijn> bramgg: As mauke\ points out there's a nasty performance issue with my version in that it's not strict in the count argument, which for long lists will screw you over. It's a common pitfall, to understand it you probably wanna read up on the difference between foldl and foldl'
02:06:28 <merijn> bramgg: Decomposing problems like this becomes easier with practice. Once you learn to see that, for example "this function would be easier if I had an explicit current element and current count", then all you need to think of is "how do I rewrite it as a wrapper around a simpler helper"
02:07:23 <merijn> bramgg: As a bonus, it also avoids the error case of your initial version :)
02:07:30 <bramgg> merijn: thanks. Just to be clear, by helper do you mean any function within a where block?
02:08:14 <merijn> bramgg: A helper function is just a function that "helps" tackle the outer functions actual task
02:08:22 <lpaste> mniip annotated “Holy shit I did it!” with “Holy shit I did it! (annotation) (annotation) (annotation)” at http://lpaste.net/214270171731197952#a122584
02:08:32 <merijn> bramgg: Liberal use of where blocks and local definitions can make a lot of code much simpler :)
02:09:08 <bramgg> mniip: wow
02:09:30 <merijn> mniip: If you wannt go for real speed you could use unboxed int as your counter
02:09:38 <mniip> hmm
02:09:41 <merijn> Although then you're limited to run counts no more than a machine word
02:11:06 <lpaste> merijn revised “Holy shit I did it! (annotation)”: “Need for speed!” at http://lpaste.net/122582
02:11:26 <merijn> That requires MagicHash and GHC.Prim levels of magic, though :p
02:11:59 <lpaste> mniip annotated “Holy shit I did it!” with “Holy shit I did it! (annotation) (annotation) (annotation) (annotation)” at http://lpaste.net/214270171731197952#a122586
02:12:01 <mniip> :)
02:12:38 <merijn> If someone's bored I'd be interested to see benchmarks for the different versions
02:12:55 <merijn> I'd hope GHC's strictness analyzer would be smart enough to unbox the counter in 'go', but I have no idea
02:13:07 <mniip> last time I tried benchmarking haskell I got bogus data
02:18:16 <mniip> original 0m0.948s
02:18:49 <mniip> span 0m0.856s
02:19:22 <mniip> runLength thing 0m0.596s
02:19:46 <mniip> mine 0m0.643s
02:20:00 <mniip> mine unboxed 0m0.597s
02:20:39 <mniip> unboxed runLength doesn't kindcheck...
02:20:52 <merijn> What's the error?
02:20:53 <mniip> fixed + to +#
02:20:56 <merijn> oh
02:20:57 <merijn> right
02:21:02 <mniip> unboxed runLength 0m0.602s
02:21:07 <merijn> awww
02:21:18 <merijn> How long was the input?
02:21:28 <bramgg> mniip: was just about to ask, how did you test those?
02:21:30 <mniip> tr -cd a-f < /dev/urandom | head -c 10000000
02:21:33 <bramgg> very interesting btw
02:22:49 <mniip> main = getContents >>= \n -> encode n `deepseq` return ()
02:22:57 <mniip> then just ghc -O3 and bash `time`
02:23:07 <merijn> bramgg: criterion is a really nice benchmarking library/framework for haskell
02:23:12 <merijn> Creates pretty graphs :)
02:34:59 <putis> hello! flip is used when we want to exec function with flipped arguments. Suppose whe have an 'val :: MyType { a :: Int, b :: Int }'; is there a way to bind my val to val2 with flipped fields just like using 'flip' function?
02:37:03 <frerich> putis: I guess 'flipMyType (MyType a b) = MyType b a' is too boring?
02:38:30 <putis> frerich: yes, it is good; I was wondering if is there such function in Prelude or somewhere; thanks
02:38:40 <mniip> how can it be a function
02:38:45 <mniip> what would its type be
02:39:09 <frerich> putis: Maybe one could whip up something using curry and swap or so, but I suspect that's all just going to be convoluted.
02:40:13 <mniip> putis, maybe paste some code?
02:50:50 <putis> I was looking for a way to use a type in my function in flipped form in some situations, and non-flipped in some others
02:51:26 <putis> frerich led me to some sollution as following: we have data: data Ab = Ab { a :: Int, b :: Int }
02:51:46 <putis> we can define function: let flipMe inv (Ab x y) = inv Ab x y
02:52:23 <putis> and from now I can use it in such way: let Ab x y = flipMe id (Ab 1 2); or let Ab x y = flipMe flip(Ab 1 2)
02:52:50 <putis> And it was what I were looking for; really thanks
02:52:51 <mniip> putis, duh
02:52:56 <mniip> you can just write Ab 1 2
02:53:01 <mniip> and flip Ab 1 2
02:53:16 <EvanR_> :t flip
02:53:17 <lambdabot> (a -> b -> c) -> b -> a -> c
02:53:34 <EvanR_> flip Ab 2 1
02:53:38 <mniip> Ab is of the type Int -> Int -> Ab, it would fit in flip
02:54:13 <exio4> that "flipMe" is a fold 
02:54:34 <exio4> a weird one because that Ab
02:55:13 <exio4> I'd define a function foldAb g (Ab x y) = g x y ; and then use this one + other combinators for writing those functions
02:55:53 <exio4> @type (\f -> curry (f.swap) 
02:55:54 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:55:55 <exio4> @type (\f -> curry (f.swap) )
02:55:56 <lambdabot> ((b, a) -> c) -> a -> b -> c
02:56:17 <exio4> heh, was reimplementing flip 
02:58:16 <EvanR_> @src flip
02:58:16 <lambdabot> flip f x y = f y x
02:58:24 <mniip> boring
02:59:01 <EvanR_> flip .:: flip .:: flip for good measure
02:59:57 <EvanR_> :t flip (.).(.).(.) flip
02:59:58 <lambdabot> (b -> a1 -> b1 -> c1) -> ((a -> b1 -> a1 -> c1) -> c) -> (a -> b) -> c
03:00:28 <EvanR_> :t flip (.).(.) flip
03:00:29 <lambdabot> (a -> a1 -> b -> c1) -> ((b -> a1 -> c1) -> c) -> a -> c
03:00:34 <EvanR_> maybe not
03:01:54 <mniip> (. const) . (<*>)
03:01:59 <mniip> = flip
03:10:14 <akegalj> in https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/deamortized-st edward uses pattern matching   m@Step{}  . What is this {} for?
03:10:39 * hackagebot data-easy 0.5 - Consistent set of utility functions for Maybe, Either, List, Monoids.  http://hackage.haskell.org/package/data-easy-0.5 (jcristovao)
03:11:20 <mniip> akegalj, it's a record syntax pattern match with no fields to match
03:13:01 <ocharles_> Is there a way (perhaps GHC specific) that I can get the memory address of a value - regardless of its type? Perhaps StablePtr is what I'm looking for
03:13:06 <ocharles_> wondering what else there is
03:13:51 <ocharles_> I see there is also https://stackoverflow.com/questions/18560833/how-to-print-memory-address-of-a-list-in-haskell
03:14:52 <EvanR_> ocharles_: you want a memory address and dont care if its immediately invalid because of a collection?
03:15:19 <ocharles_> yea
03:15:23 <ocharles_> so I have this slightly crazy idea
03:15:25 <akegalj> mniip: aha, so in this case it is the same as doing m@(Stop _) i suppose
03:15:36 <mauke\> akegalj: Foo{} matches the data constructor Foo, no matter how many arguments it takes
03:15:38 <EvanR_> ocharles_: maybe unsafeCoerce can help
03:15:47 <mniip> Stop might have more than 1 argument
03:15:59 <opqdonut> ocharles_: https://downloads.haskell.org/~ghc/7.8.1-rc2/docs/html/libraries/ghc-prim-0.3.1.0/GHC-Prim.html#g:20 ?
03:16:01 <akegalj> mniip: yes, in this case it doesnt have
03:16:07 <mauke\> > case pure 42 of Nothing{} -> "nope"; Just{} -> "just"
03:16:08 <lambdabot>  "just"
03:16:11 <ocharles_> I'm working on a my GHCJS web framework thing, and I use virtual-dom. But I thought - what if I can tag every HTML tree/forest with some sort of memory address. Then, when I diff this tree into the browser dom, I can look at the underlying memory addresses - if that hasn't changed, then I can skip that part of the DOM entirely
03:16:21 <akegalj> mauke\: yes, its more flexible
03:16:22 <opqdonut> ocharles_: oh right, that just uses stableptr which you just mentioned
03:16:23 <ocharles_> so if you have a huge static HTML tree, I'll just completely step over that - because it can't have changed
03:16:52 <opqdonut> ocharles_: that sounds like a usecase for StableNames or StablePtr, sure
03:16:53 <ocharles_> I can't really/don't want to enforce any type classes on my users - so memory addresses seems like the best I've got
03:16:56 <putis> mnip, it is true, that I can use flip during construction; but I have already bound value, taken from Map for example. In such situation I can't just use flip; exio4 properly marked, that my function is an fold in fact
03:16:59 <mauke\> but values move around in memory
03:17:06 <opqdonut> ocharles_: people've used them for e.g. hash table keys also
03:17:11 <ocharles_> opqdonut: ah, interesting
03:17:24 <ocharles_> mauke\: hmm. do you know under what circumstances?
03:17:39 <opqdonut> ghc has a compacting gc
03:17:40 <ocharles_> this is also a bit like observable sharing - so maybe that's something to look in to
03:18:02 <opqdonut> yeah
03:18:03 <ocharles_> if I'm given a deep embedding of a HTML tree, and I know the last HTML tree I rendered - I can observe sharing in both of them and maybe find common nodse
03:18:34 <ocharles_> basically trying to optimise away any deep equalities
03:20:36 <nilg> Guys, is it possible to type check a function that use other functions without binding, just their type definitions?
03:20:43 <nilg> I tried but I get the following error:
03:20:53 <nilg> The type signature for `is_bottom' lacks an accompanying binding
03:21:26 <kstt> is_bottom = undefined 
03:21:27 <silver> is_bottom = undefined
03:22:18 <EvanR_> is_bottom undefined
03:22:19 <EvanR_> True
03:22:24 <kstt> maybe some flag can tell ghc to consider this a default binding
03:22:24 <nilg> that's awesome thanks!
03:22:32 <kstt> but not sure
03:23:18 <nilg> *Main> :t undefined
03:23:18 <nilg> undefined :: a
03:23:18 <nilg>  
03:23:20 <nilg> :-)
03:24:46 <kstt> You can also use is_bottom = error "!! is_bottom !!"
03:28:02 <EvanR_> > error undefined
03:28:04 <lambdabot>  *Exception: Prelude.undefined
03:28:21 <EvanR_> double bottom
03:28:55 <jle`> > undefined error
03:28:56 <lambdabot>  *Exception: Prelude.undefined
03:29:02 <jle`> undefined error = error undefined
03:29:04 <jle`> omg
03:29:11 <EvanR_> symmetric
03:29:14 <EvanR_> and transitive
03:29:16 <jle`> commutative
03:29:28 <mniip> $ is commutative!
03:29:48 <EvanR_> id error = error id
03:30:07 <jle`> i'm not sure if that's true...
03:30:21 <EvanR_> i meant undefined
03:34:22 <EvanR_> :t undefined undefined undefined undefined
03:34:23 <lambdabot> t
03:35:28 <dimsuz> hi. I feel a bit lost in function application associativity: "seqn (c:cs) = return (:) `ap` c `ap` sequence cs" <= how should I interpret this? return is consuming only (:) then ap is called with result and applies to c?
03:37:46 <mniip> dimsuz, ap (ap (return (:)) c) (sequence cs)
03:38:53 <dimsuz> mniip: thank you, will stare at this for some time now :)
03:40:54 <mniip> dimsuz, I fail to see how seqn is different from sequence
03:41:20 <dimsuz> mniip: it is sequence, I just shortened it for irc-ing purposes
03:41:55 <mniip> seqn (c:cs) = do c' <- c; cs' <- seqn cs; return (c':cs')
03:41:58 <mniip> is how I'd write it
03:42:29 <dimsuz> (but I forgot to shorten last call, recursive one)
03:42:35 <merijn> dimsuz: the backticks make ap infix and the rules are as follows: infix functions have precedence from 0 to 9 (9 being highest), prefix function application has precedence 10, record syntax has precedence 11
03:43:03 <mniip> iirc, if you don't set "infix `ap`" it is assumed to be 9
03:43:31 <dimsuz> mniip: yep. I am just reading the paper on Applicative style and found this there. I am just begginning, learning some theory, so sometimes still get lost in basics...
03:43:32 <saep> I'd write it: seqn (x:xs) = (:) <$> x <*> seqn xs
03:43:34 <merijn> dimsuz: So "return (:)" is return in prefix notation applied to (:) (since it's prefix notation), followed by infix `ap` followed by c, followed by infix `ap`, followed by sequence cs which is again prefix application
03:43:52 <mniip> saep, different constraint
03:44:02 <dimsuz> merijn: thank you!
03:44:10 <merijn> The default fixity of an infix function is "infixl 9" you can use ":info" in ghci to query the fixity (not printed == default)
03:57:41 <hibou107> hello
03:58:16 <hibou107> I'm trying to solve the problem 64
03:58:35 <hibou107> https://wiki.haskell.org/99_questions/61_to_69
03:58:47 <hibou107> I can not find the error
03:58:48 <hibou107> http://paste.ofcode.org/fpiqfRRHuvNiE2vuK9PprV
03:59:00 <hibou107> arithmetic.hs:78:92:     Occurs check: cannot construct the infinite type:       b0 = (t0, (b0, t1))     In the first argument of `(+)', namely `xRoot'     In the first argument of `shiftX', namely `(xRoot + 1)'     In the second argument of `(++)', namely       `(shiftX (xRoot + 1) (shiftY 1 (fst fright)))' Failed, modules loaded: none.
03:59:36 <hibou107> someone have some idea ?
04:00:24 <mauke\> snd $ e + x looks wrong
04:00:34 <mauke\> add type signatures to get better error messages
04:02:05 <hibou107> eys
04:02:10 <mauke\> also, that looks like a lot of code for turning a tree into a list
04:02:12 <hibou107> it's so hard to find error from this
04:02:58 <hibou107> you means for performance ? or just code repetition
04:03:26 <mauke\> code complexity
04:03:38 <hibou107> ah
04:04:15 <hibou107> actually it compiles
04:04:16 <hibou107> thanks!
04:04:32 <mauke\> internals Empty = []; internals (Branch _ Empty Empty) = []; internals (Branch x left right) = internals left ++ [x] ++ internals right
04:04:34 <hibou107> (fst . snd $ e) + x
04:04:39 <mauke\> done
04:05:15 <mauke\> oh, I'm looking at the wrong problem
04:05:23 * mauke\ <- stupid
04:05:24 <hibou107> it's not the problem 62
04:05:26 <hibou107> yes
04:05:30 <hibou107> no problem
04:05:33 <frerich> hibou107: Somewhat unrelated to your question, but I think you could benefit from some pattern matching. E.g. "\ e -> (fst e, (fst $ snd e, snd $ snd e + y)))" could be "\(e0,e1) -> (e0, (fst e1, snd $ e1 + y))"
04:05:51 <mauke\> somehow I misread "4 Problem 62" as "64"
04:05:58 <hibou107> yes ,  you are right
04:07:14 <hibou107> it does not work yet but i'm still working on it
04:18:07 <mauke\> https://www.fpcomplete.com/project/99511/mYAxO4HEwA (spoilers)
04:21:22 <mniip> I am bored
04:21:24 <mniip> where is ski
04:35:43 * hackagebot euler 0.4.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.4.0 (decomputed)
04:38:07 <hibou107> cool
04:38:12 <hibou107> i don't know that
04:38:18 <hibou107> the online compiler
04:44:55 <quchen2_> bernalex: ZuriHac here I come :-)
04:45:39 <bernalex> quchen2_: hm. have I talked about ZuriHac?
04:45:44 * hackagebot generic-accessors 0.1.0.0 - stringly-named getters for generic data  http://hackage.haskell.org/package/generic-accessors-0.1.0.0 (GregHorn)
04:45:59 <quchen2_> bernalex: No, but you just confirmed my application (David Luposchainsky)
04:46:07 <bernalex> quchen2_: I did what?
04:46:12 <quchen2_> Or was that someone who has a name remarkably close to your nick
04:46:16 <quchen2_> Nevermind in that case.
04:46:33 <bernalex> quchen2_: haha. I'm considering going though. it's in May, right?
04:46:44 <quchen2_> Right, 29th to 31st
04:46:56 <has_skull> hi can someone explain this to me? http://lpaste.net/122587 for example wouldn't this be infinite recursion?
04:47:05 <bernalex> quchen2_: how much is it? (moneywise)
04:47:32 <quchen2_> bernalex: Well, you'll have to travel there and sleep somewhere, other than that I'm not aware of any cost
04:47:46 <quchen2_> bernalex: Let's take this to -blah
04:47:47 <bernalex> quchen2_: oh ok that's rather cheap then hehe
04:50:55 <frerich> has_skull: The recursion would be infinite if the input list is infinite. intListLength calls itself with the tail of the input list (i.e. all elements but the first one), so if the list if finite it'll eventually call itself with an empty list at which point the recursion stops.
04:50:57 <hibou107> :mauke
04:54:01 <merijn> When is ZuriHac?
04:54:22 <merijn> Although I'm not sure I could afford to go anyway :\
04:54:50 <merijn> oh, I should read :p
05:01:56 <aleator_> This is not really about Haskell, but does anyone know a safe (ie. execute stuff from internet), embeddable expression language? If the project was done with haskell, I'd just roll my own, but it ain't.
05:02:18 <ChristianS> aleator: lua is popular for such cases
05:03:08 <aleator_> ChristianS: I didn't research lua that deeply, but it seemed that it needs to be sandboxed before it can safely be used.
05:04:23 <ChristianS> aleator: ah, yes, i somewhat ignored the "execute stuff from internet" part. that's going to be difficult in most languages.
05:05:36 <aleator_> ChristianS: Taking a look at how most things work, it seems parsec+evaluator would fit in less lines of code than proper sandbox.. (Might have been wrong about lua though)
05:15:46 * hackagebot hxt-regex-xmlschema 9.2.0.2 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.2.0.2 (UweSchmidt)
05:21:45 <ap01> hi...I am interested in learning haskell...What is a good place to start ?
05:22:05 <mada> ap01: #haskell-beginners is a good place to start, as well as this channel
05:25:08 <merijn> Learn You a Haskell
05:25:11 <merijn> @where lyah
05:25:11 <lambdabot> http://www.learnyouahaskell.com/
05:25:18 <merijn> and https://github.com/bitemyapp/learnhaskell
05:26:16 <Cale> ap01: btw, beginner questions are just as welcome here
05:26:51 <aawe> but will not be answered as pedagogically
05:26:52 <Cale> ap01: #haskell-beginners was set up for a specific study group of beginners
05:26:59 <Cale> That's not necessarily true
05:27:22 <aawe> Cale: Perhaps not, just thought of http://chrisdone.com/posts/teaching
05:37:21 <aawe> nightmare-inducing
05:40:26 <poi_> :t map
05:40:26 <lambdabot> (a -> b) -> [a] -> [b]
05:49:00 <pavonia> Is there any reason why groupWith :: Ord b => (a -> b) -> [a] -> [[a]] is in GHC.Exts and not in e.g. Data.List?
05:50:49 <merijn> pavonia: Wouldn't you want
05:50:54 <merijn> :t groupBy
05:50:54 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
05:50:59 <merijn> Which is in Data.List
05:51:58 <opqdonut> pavonia: Data.List is dictated by the standard: https://www.haskell.org/onlinereport/haskell2010/haskellch20.html#x28-22800020
05:52:11 <opqdonut> but yeah, GHC.Exts is a funny place, why not e.g. Data.List.Exts :)
05:52:12 <pavonia> merijn: I don't think so, I want a more general partition function
05:53:58 <mmachenry> Ever since I upgraded to cabal 1.22 I get my .tix file for HPC test coverage in the root directory of my project instead of the dist/ directory. Anyone know how to control that?
05:54:40 <nshepperd> why Ord constraint, rather than Eq?
05:54:49 <jtanguy> I believe it is in GHC.Exts because it is required by a GHC extension
05:55:11 <jtanguy> it seems like a sort of groupBy . sortBy
05:55:57 <fizruk> :t sortBy
05:55:58 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
05:56:02 <fizruk> :t sortOn
05:56:03 <lambdabot>     Not in scope: ‘sortOn’
05:56:03 <lambdabot>     Perhaps you meant one of these:
05:56:03 <lambdabot>       ‘BSC.sort’ (imported from Data.ByteString.Char8),
05:57:02 <nshepperd> hmm.... quotient :: Eq b => (a -> b) -> [a] -> [[a]]
05:58:03 <jtanguy> like groupWith f = groupBy ((==) `on` f) . sortBy (comparing f)
05:59:47 <nshepperd> https://ghc.haskell.org/trac/ghc/ticket/2659 <-- groupOn
06:00:00 <nshepperd> but something that sorts the list first seems like a different operation
06:00:48 <jtanguy> the haddock for groupWith seems to say so
06:01:28 <jtanguy> (oh sorry, I misread the trac link)
06:01:36 * nshepperd looks up synonyms for 'group'
06:02:58 <nshepperd> 'collate(With|By|On)'
06:06:24 <t4nk436> Hello everyone, I am a student learning OS. I have some difficulty in choosing a term project topic. We are considering writing some OS-related stuff in haskell. Does anyone have any idea?
06:08:01 <pavonia> Interesting, so I actually *can* use groupBy for what I need, though it's not obvious from its type
06:08:21 <frerich> t4nk436 : What would 'OS-related stuff' be?
06:08:22 <pavonia> t4nk436: OS = operating system?
06:08:50 <t4nk436> yes, operating system. Like a kernel, or some higher level.
06:10:44 <pavonia> Well, it's still not very clear what you mean, every program is OS-related to some degree :p
06:15:02 <frerich> t4nk436 : Maybe some filesystem management utility would count? You could write some sort of 'xplorer' which lets you list files, copy them around, open them in some program etc. (like like Norton Commander in case that rings a bell).
06:15:44 <frerich> t4nk436 : A system monitor application which provides a web interface to inspect things like memory usage, CPU temperature and processes running might be another idea.
06:16:42 <phaazon> hey
06:16:54 <phaazon> I’d like to be able to emit UTF-8 files within happstack
06:17:00 <phaazon> for the file serving
06:17:02 <phaazon> any idea?
06:17:11 <t4nk436> Our professor is a strange person, he wants some project "sounds awesome" and have application in real world, such as UAV etc.
06:18:07 <phaazon> http://hackage.haskell.org/package/happstack-server-7.4.1/docs/Happstack-Server-FileServe-BuildingBlocks.html#v:sendFileResponse
06:18:10 <phaazon> got it!
06:18:21 <ibid> t4nk436: so not so much OS as bare metal, embedded?
06:20:40 <merijn> t4nk436: Take a look at House
06:20:44 <ClaudiusMaximus> t4nk436: someone wrote a netbsd kernel driver https://mail.haskell.org/pipermail/haskell-cafe/2014-February/112802.html , perhaps also see halvm http://galois.com/project/halvm/ or atom http://hackage.haskell.org/package/atom
06:20:51 <merijn> Or halvm, yeah
06:22:27 <phaazon> actually not sure
06:53:57 <hibou107> I'm working on problem 70
06:53:58 <hibou107> http://lpaste.net/122665
06:54:09 <hibou107> It compiles but ahs error
06:54:25 <hibou107> nnodes $ Node 'a' [Node 'b' [Node 'c' []]]
06:54:37 <hibou107> No instance for (Num ([a0] -> a0))       arising from a use of `nnodes'     Possible fix: add an instance declaration for (Num ([a0] -> a0))     In the expression: nnodes     In the expression: nnodes $ Node 'a' [Node 'b' [Node 'c' []]]     In an equation for `it':         it = nnodes $ Node 'a' [Node 'b' [Node 'c' []]]
06:54:43 <nuser> problem 70 from?
06:54:57 <hibou107> https://wiki.haskell.org/99_questions/70B_to_73
06:56:03 <mauke\> put a type signature on nnodes
06:56:04 <jorr> can you do the parts right of the $ in parenthesis?
06:56:13 <jorr> in case of precendence issue
06:56:23 <mauke\> oh, you pasted your attempt
06:56:31 <juanpablo_> Why isn't there an instance of contramap for ((->) r)?
06:57:26 <juanpablo_> Shouldn't it be like (flip (.))?
06:58:32 <hibou107> nnodes (Node x childs) = 1 + (sum $ map nnodes childs)
06:58:37 <hibou107> it works now
06:58:41 <jorr> :)
06:58:43 <jorr> noice
06:58:54 <hibou107> but it's weird that it compiles
06:59:21 <jorr> I think it was trying to do something like (1 + sum) (map nnodes childs)
06:59:32 <mauke\> nnodes (Node _ children) = 1 + sum (map nnodes children)  -- this line is all you need
06:59:36 <jorr> rather than 1 + (sum (map nnodes childs))
06:59:39 <mauke\> it's a complete definition
07:00:14 <hibou107> yes
07:00:33 <hibou107> :mauke\ without the []
07:00:39 <hibou107> ?
07:00:41 <mauke\> yes
07:00:58 <mauke\> map nnodes [] = []
07:01:00 <mauke\> sum [] = 0
07:01:03 <mauke\> 1 + 0 = 1
07:01:14 <hibou107> ah ok
07:02:15 <hibou107> yes it works like a charm
07:08:00 <abhinav> hello
07:08:49 <jorr> hello
07:10:09 <abhinav> Jorr - Could you please help me in getting this output:  [["1,2,3"],["1,2,3"]]  -> [["1","2","3"],["1","2","3"]]
07:11:13 <abhinav> hi Jorr you there>
07:11:14 <abhinav> ?
07:11:33 <frerich> abhinav: As a first step you cold simplify the problem of translating '["1,2,3"]' to '["1", "2", "3"]' -- once you have a function which does that you could use 'map' to apply it to an entire list.
07:11:54 <frerich> Simplify the problem *to* translating... I mean.
07:12:10 <hibou107> hi did somebody use haskell for numerical calculus, 
07:12:22 <hibou107> like matrix multiplicaiton, integration ...
07:12:41 <hibou107> because normally we use array for that
07:12:48 <abhinav> bro, frerich could you please type the code snippet for that. Sorry I am new to haskell
07:12:51 <hibou107> and not list
07:12:58 <jorr> abhinav: what do you need to do to get from "1,2,3" to [1,2,3], conceptually?
07:16:46 <frerich> abhinav: Before spoiling the fun - did you try something yourself already? Maybe we can rather help with overcoming whatever problems you hit while devising your own solution.
07:17:47 <abhinav> jorr : frerich : sure
07:18:43 <abhinav> frerich : map (sepBy::[[String]] -> [[String]] "," r
07:19:10 <josgraha> hello
07:19:54 <josgraha> question: does haskell work on azure platform?
07:20:13 <frerich> abhinav: That looks good - except for the odd type you try to assign to 'sepBy'
07:20:46 <abhinav> frerich : what do i do ?
07:20:48 <frerich> abhinav: Also, I don't see where "r" is coming from.
07:20:49 <abhinav> :)
07:21:32 <abhinav> frerich : let r = [["1,2,3"],["1,2,3"]]
07:22:54 <frerich> abhinav: What's the *actual* code you tried to run? There's at least a ")" missing in "map (sepBy::[[String]] -> [[String]] "," r" so I suspect you tried something different?
07:23:49 <abhinav> frerich : [["1,2,3"],["1,2,3"]]
07:24:00 <abhinav> frerich : (sepBy :: [[String]] -> [String]) "," r
07:27:04 <frerich> abhinav: Your type signature says that 'sepBy' should expect a list of list of strings as the first argment -- but then you give it a plain string. That seems strange. What you need is a function 'f :: [String] -> [String]' which can take a list (which is supposed to contain just one string) and which yields a list of strings, so you can get 'f ["1,2,3"]' to evaluate to '["1", "2", "3"]'. If you had such a function, you could run 'map f r'.
07:27:04 <frerich> abhinav: Now, to define 'f' you'd need to extract the string "1,2,3" out of the given list and then split that (sepBy is a good utility for that!).
07:41:15 <hibou107> are there general way to implement dynamic programming in haskell
07:41:35 <hibou107> in other programming language like python, it's very simple
07:44:57 <osfameron> what do you mean? the memoizing strategy in https://en.wikipedia.org/wiki/Dynamic_programming#Algorithms_that_use_dynamic_programming ?
07:45:16 <hibou107> yes but haskell does not have state
07:45:43 <hibou107> in python i can just store calculated result in a map
07:45:50 <hibou107> and the algorithm is the same
07:45:58 <osfameron> haskell has maps too...
07:46:03 <hibou107> for example the problem 31 https://wiki.haskell.org/Euler_problems/31_to_40
07:46:21 <osfameron> https://wiki.haskell.org/Memoization might be a good place to look?
07:46:22 <frerich> hibou107 : You can do the same in Haskell, in fact memoization is pretty common. See https://wiki.haskell.org/Memoization
07:46:26 <whiteline> import Data.Map
07:46:27 <frerich> Dammit.
07:46:32 <osfameron> frerich: ^5
07:46:40 <frerich> :-)
07:46:55 <osfameron> I have to admit I personally found memoization a bit tricky with haskell  (but I didn't look at it very hard :D)
07:47:07 <whiteline> use a state monad for global state, use arrows for quick state-holding
07:48:07 <mmachenry> Does anyone know how to use Async to say "If the parent dies, also kill this child async I'm about to spin off" ?
07:48:18 <hibou107> for example the problem Euler 31
07:48:39 <hibou107> http://lpaste.net/122726
07:48:49 <hibou107> I can't find a way to understand it
07:48:59 <mmachenry> I am using Control.Concurrent.Async.link for that and realized that it does the opposite. Kills the parent when the child dies. I want to kill either if either dies.
07:51:03 <hibou107> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:51:21 <hibou107> how haskell start to make calculation with this ?
07:51:56 <ibid> it doesn't, until you demand a value from it
07:52:09 <clrnd> hibou107, https://hackage.haskell.org/package/permutation
07:52:39 <hibou107> ok
07:52:45 <hibou107> let say I want fibs !! 10
07:52:54 <hibou107> how ghc make the calculation ?
07:53:07 <ibid> what do you suppose yourself?
07:53:11 <clrnd> hibou107, well, try it, go ahead, write in a piece of paper the steps one by one
07:53:34 <clrnd> (!! 10) will take the head 10 times
07:53:38 <hibou107> first we have fibs = [0, 1]
07:53:52 <clrnd> hibou107, well no, you have `0 : something`
07:54:03 <clrnd> then, `0 : 1 : something`
07:54:12 <clrnd> think it like that, and replace accordingly
07:54:13 <c_wraith> hibou107: haskell is very constructor-oriented.  think in terms of (:) constructors
07:54:13 <hibou107> ah that's clearer
07:54:46 <hibou107> it's like 0:(1:something)
07:54:47 <hibou107> ?*
07:54:47 <lambdabot> Maybe you meant: v @ ? .
07:54:50 <clrnd> then, `0 : 1 : (0 + 1) : etc`
07:54:59 <clrnd> hibou107, yes
07:55:12 <clrnd> hibou107, yes, (:) associates like that
07:55:38 <clrnd> (it's infixr 5)
07:55:48 <mmachenry> using withAsync allows me to kill the child if the parent dies, but I can't use withAsync. I need to use just plain async because I'm forking off a process and recurring. 
07:55:55 * hackagebot hdbc-aeson 0.1.0.0 - Deserialize from HDBC rows to FromJSON instances  http://hackage.haskell.org/package/hdbc-aeson-0.1.0.0 (DanielChoi)
07:55:58 <mmachenry> How can I ensure that process is killed?
07:57:36 <clrnd> mmachenry, mmmm you can call `cancel parent` on the child, you'd just need to ensure it always calls it
07:58:21 <mmachenry> clrnd: I don't want to cancel the parent, I want to cancel the child if the parent dies for any reason.
07:58:27 <josgraha> is there a newbie haskell chan?
07:58:35 <c_wraith> mmachenry: link the processes, then?
07:58:37 <clrnd> josgraha, #haskell-beginners
07:58:45 <mmachenry> josgraha: Welcome, we're also kind to newbies here.
07:58:57 <frerich> josgraha: This channel is fine for Haskell newbies, too!
07:59:01 <mmachenry> c_wraith: That's what I did. link works the opposite direction.
07:59:15 <c_wraith> mmachenry: you could use link2
07:59:20 <neuroserpens> josgraha: We are all noobs.
07:59:24 <mmachenry> c_wraith: also I don't have the Async object of the process I'm in.
07:59:36 <c_wraith> mmachenry: ah
07:59:39 <hopla> hello all, I have a syntax problem that confuses me: https://gist.github.com/anonymous/c09ec3766a8d32301c16
07:59:41 <mmachenry> c_wraith: is there a getCurrentThread for Async?
07:59:44 <neuroserpens> josgraha: And if anyone says they're not noobs they're lying
07:59:48 <c_wraith> mmachenry: have the parent link the child?
07:59:50 <mmachenry> Get me the current async object I'm in
07:59:55 <josgraha> i searched on reddit for haskell cloud support but wondering how people deploy haskell on cloud platforms (e.g. docker), sorry the question is so broad.  not sure where to start on this
08:00:07 <mmachenry> c_wraith: Still how do I get a pointer to the parent?
08:00:14 <hopla> I simplified my "real life" issue but basically I fail to use ($) directly
08:00:29 <mmachenry> I guess I could pass that in from god knows where it's created off somewhere else.
08:00:43 <c_wraith> mmachenry: it'd have to be passed in or closed over.  Why not have the parent link the child after spawning it?
08:00:48 <ibid> neuroserpens: well, if spj says it?
08:01:01 <mmachenry> c_wraith: That doesn't work.
08:01:01 <neuroserpens> ibid: Who is spj?
08:01:19 <frerich> hopla: I don't know the error message, but I saw that you define 'f = ($) x' with 'x :: Int', but ($) expects a function as its first argument.
08:01:24 <c_wraith> neuroserpens: one of GHC's primary developers - for over 20 years
08:01:30 <mmachenry> If the parent does this: forever $ do { a<-async action; link a}
08:01:40 <neuroserpens> c_wraith: Alright. ibid: He'd be lying too.
08:01:41 <ibid> c_wraith: i think he started it all?
08:01:43 <mmachenry> Then that only kills the parent if the child dies. not the other way around.
08:01:48 <mmachenry> I want both.
08:01:54 <mmachenry> If I were to do this:
08:01:59 <josgraha> trying to build a system that reacts to message bus events but not sure what is the best config stack should be, amazon sqs, rabbit with ec2 images and so on
08:02:03 <ibid> neuroserpens: :D
08:02:21 <clrnd> hopla, try `$ 5` instead of `($) 5`
08:02:24 <hopla> frerich: ah yes. of course. What a shame. How can I pass the second argument to ($) directyly?
08:02:47 <c_wraith> mmachenry: Ok, I finally see what you want. :)
08:02:47 <clrnd> hopla, when using an infix function you can curry it on the second arg like that ^
08:02:49 <mmachenry> loop = withAsync action (\a-> link a >> loop)
08:02:55 <mmachenry> That might work but I think it's a space leak.
08:03:05 <hopla> clrnd: Thanks!
08:03:06 <clrnd> > map (`mod` 5) [1..3]
08:03:07 <lambdabot>  [1,2,3]
08:03:12 <clrnd> > map (5 `mod`) [1..3]
08:03:14 <lambdabot>  [0,1,2]
08:03:36 <neuroserpens> let ln = do { n <- getLine ; if n == "" then return [] else do { l <- ln ; return read n : l } }
08:03:44 <neuroserpens> > let ln = do { n <- getLine ; if n == "" then return [] else do { l <- ln ; return read n : l } }
08:03:46 <lambdabot>  not an expression: ‘let ln = do { n <- getLine ; if n == "" then return [] e...
08:03:50 <neuroserpens> lol
08:03:58 <mmachenry> c_wraith: So a way to get the current async would be handy. Then I could link2.
08:04:04 <neuroserpens> I want to getLine in irc haha
08:04:16 <c_wraith> mmachenry: there's no guarantee any of those are being called in an Async
08:04:33 <mmachenry> c_wraith: Yeah good point.
08:04:41 <hopla> clrnd: ah yes. I was completely confused between ($) and `$`. Thanks!
08:04:51 <mmachenry> c_wraith: I suppose a ResourceT would work for this.
08:04:54 <merijn> `$` is syntax error
08:05:16 <hopla> merijn, clrnd: yes, I just tried it
08:05:17 <c_wraith> mmachenry: I was thinking about that too.  It's a bit verbose, but it's designed for exactly this sort of thing
08:05:29 <clrnd> hopla, yeah, putting parenthesis un-infixes the function
08:05:42 <clrnd> > (+) 1 2 -- look ma, Lisp
08:05:43 <lambdabot>  3
08:05:47 <hopla> clrnd: ok I use flip so
08:05:55 * hackagebot hdbc-aeson 0.1.1.0 - Deserialize from HDBC rows to FromJSON instances  http://hackage.haskell.org/package/hdbc-aeson-0.1.1.0 (DanielChoi)
08:06:27 <saep> > map ($ 5) [(+) 7, (*) 8]
08:06:28 <lambdabot>  [12,40]
08:06:40 <narendraj9> >let ln = do { n <- (return "I was going to type this."); if n == "" then return [] else do { l <- ln; return read n : l}}
08:07:02 <hopla> saep: ah yes. even better :-)
08:07:24 <narendraj9> > let ln = do { n <- (return "I was going to type this."); if n == "" then return [] else do { l <- ln; return read n : l}}
08:07:25 <mmachenry> c_wraith: It's probably the right idea.
08:07:25 <lambdabot>  not an expression: ‘let ln = do { n <- (return "I was going to type this.");...
08:07:42 <hopla> hopla: Thanks all!
08:08:22 <narendraj9> > let ln = do { n <- (return "I was going to type this."); if n == "" then return [] else do { l <- ln; return read n : l}} in ln
08:08:24 <lambdabot>  Couldn't match type ‘[t1]’ with ‘GHC.Base.String -> a0’
08:08:24 <lambdabot>  Expected type: [GHC.Types.Char] -> [t1]
08:08:24 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Base.String -> a0
08:09:03 <narendraj9> Oh. This is stupid, sorry.
08:09:16 * neuroserpens always gets type errors...
08:09:19 * neuroserpens is mad!!!
08:09:39 <saep> neuroserpens: It's better than unexpected runtime errors. (IMHO)
08:09:40 <merijn> neuroserpens: Better than getting runtime errors :)
08:09:49 <neuroserpens> lmao
08:10:04 <merijn> neuroserpens: My personal favourite description is the following
08:10:29 <merijn> neuroserpens: "Writing correct programs is hard in any language. Writing broken programs is hard in Haskell. Therefore everything is hard in Haskell"
08:10:45 <neuroserpens> merijn: hahahahahahhahahahahaha
08:11:03 * neuroserpens is still mad though
08:11:19 <merijn> There's a lot of truth in that, I think. A lot of simplicity/speed in things like python/JS comes from being able to gloss over problems
08:11:28 <merijn> neuroserpens: You might want to lpaste your code + exact error?
08:12:04 <neuroserpens> merijn: I'll do better. I'll paste a program that works and ask for a small maintenance xD
08:13:05 <neuroserpens> merijn: This will return me a list of strings http://pastie.org/10005229
08:13:13 <neuroserpens> I want a list of integers...
08:13:21 <neuroserpens> If I put a read in there it blows up
08:13:30 <neuroserpens>  >:C
08:14:15 <whiteline> you remember you can't escape the IO monad right?
08:14:22 <neuroserpens> whiteline: wat?
08:14:41 <ptcek> any fool proof, platform independent solution for reading continuously from file that's being appended to?
08:14:44 <whiteline> also, it's easier to write that using binding operators
08:14:59 <neuroserpens> whiteline: please elaborate
08:16:21 <clrnd> neuroserpens, this needs heavy refactoring, first, try to separate IO code from pure code, so don't put a `read` there
08:16:32 <merijn> Or simpler
08:16:33 <Cale> neuroserpens: If you put a read in where?
08:16:34 <merijn> :t readLn
08:16:35 <lambdabot> Read a => IO a
08:17:05 <clrnd> :t read
08:17:06 <lambdabot> Read a => String -> a
08:17:10 <neuroserpens> ooooooooooh
08:17:12 <Cale> n should be a string, so you could apply read to it if you want
08:17:12 <neuroserpens> there is readLn
08:17:29 <clrnd> @hackage Prelude
08:17:29 <lambdabot> http://hackage.haskell.org/package/Prelude
08:17:30 <Cale> But yeah, readLn would perhaps be better
08:17:38 <neuroserpens> clrnd: I don't get it
08:17:49 <Cale> clrnd: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html
08:17:59 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/Prelude.html
08:18:12 <clrnd> :P
08:19:57 <Cale> neuroserpens: One thing you might do is to separate out the idea of a loop which executes some IO action until the result of that action satisfies some condition, and produces a list of the results
08:21:06 <Cale> neuroserpens: Something like  untilM cond x = do { v <- x; if cond v then return [] else do { vs <- untilM cond x ; return (v : vs) } }
08:21:24 <Cale> neuroserpens: and then you could write your function as  untilM null getLine
08:24:45 <juanpablo_> Why isn't there an instance of contramap for ((->) r)?
08:24:47 <juanpablo_> Shouldn't it be like (flip (.))?
08:25:08 <juanpablo_> At least that's what my intuition tells me
08:25:57 * hackagebot hdbc-aeson 0.1.2.0 - Deserialize from HDBC rows to FromJSON instances  http://hackage.haskell.org/package/hdbc-aeson-0.1.2.0 (DanielChoi)
08:34:52 <acid123> hello
08:39:46 <ab9rf> olleh
08:52:33 <Cale> juanpablo_: ((->) r) is the covariant Hom functor
08:52:51 <Cale> juanpablo_: Remember that ((->) r) s = r -> s
08:53:12 <juanpablo_> But can't you declar an instance for Contravariant for the same?
08:54:39 <Cale> Well, try defining a function of type (a -> b) -> (r -> b) -> (r -> a)
08:55:06 <Cale> So, you're given a function f :: a -> b, and a function g :: r -> b, and some x :: r
08:55:17 <Cale> and you need to produce something of type a somehow
08:55:24 <Cale> But you have no way to do it
08:56:51 <Cale> If you had  newtype To a b = To (b -> a)
08:57:03 --- mode: ChanServ set +b *!*@wn-campus-nat-129-97-124-145.dynamic.uwaterloo.ca
08:57:03 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
08:58:04 <Cale> then you could have  instance Contravariant (To r) where contramap f (To g) = To (g . f)
08:58:48 <joobus> got a noob question on imports.  What is one's preferred way of doing imports?  If I import Data.Text, then I have to qualify every call to, for instance, Data.Text.lines.  Or is "import Data.Text (lines)" preferred?  Or is it generally better to qualify everything?
08:59:12 <Cale> Here, f :: a -> b, and g :: b -> r
08:59:31 <Hijiri> for Text I usually qualify import as T
08:59:32 <Cale> joobus: import qualified Data.Text as T
08:59:40 <Hijiri> and I separately import Data.Text (Text)
08:59:43 <Cale> right
08:59:58 <joobus> ok, thanks guys
08:59:59 <Cale> So you don't have to write T.Text in your type signatures
09:01:31 <joobus> do i generally need to always qualify calls to, for instance, map or filter (things that have multiple arity)?
09:02:10 <Hijiri> probably, but because the prelude has functions of the same name, not because of arity
09:02:24 <joobus> ok, that makes sense with the errors i'm seeing
09:02:49 <saml> give me minimum (x,y,z)  that satisfies  100.0 * x + 9999.0 * y + 9999.0 * z = Infinity
09:03:04 <saml> IEEE754
09:03:13 <saml> double precision
09:03:31 <c_wraith> saml: write a program to find it
09:03:37 <c_wraith> saml: should basically be a binary search
09:03:41 <saml> that's easiest way?
09:03:47 <saml> really?
09:03:52 <Hijiri> how are we measuring minimum of three things?
09:03:52 <saml> i was gonna do it in a loop
09:03:57 <saml> sum
09:04:03 <saml> minimum x+y+z
09:04:26 <Cale> saml: Well, if you don't mind waiting approximately forever, a loop will work
09:04:37 <joobus> is that a project euler problem or something?
09:04:41 <Hijiri> must be some trick related to floating point addition, because otherwise I would just guess putting everything in y or z
09:04:45 <saml> how does binary search would work there?
09:05:00 <saml> https://peatix.com/sales/event/75127/tickets  no.. i aws just wondering
09:05:12 <saml> you input three numbers.. and eventually Total becomes Infinity
09:05:12 <c_wraith> saml: well, binary search in each dimension.  This actually has a lot in common with the saddleback search
09:05:20 <c_wraith> Except it's in three dimensions instead of two
09:05:33 <c_wraith> But that doesn't change much
09:05:51 <Hijiri> do we know that it uses double?
09:06:00 <saml> javascript is all double
09:06:03 <Hijiri> oh
09:06:14 <Cale> Also, when you say "minimum (x,y,z)" do you mean in the usual lexicographic ordering on triples?
09:06:20 <c_wraith> Cale: minimum sum
09:06:27 <c_wraith> Cale: that was clarified
09:06:29 <Cale> oh
09:06:32 <Cale> yeah, okay
09:06:47 <c_wraith> This really does have a ton in common with a saddleback search
09:07:08 <c_wraith> Which was covered in some depth in bird's book on calculating functional pearls
09:07:14 <saml> 100x + 9999y = infinity
09:07:29 <saml> and y/2
09:07:48 <saml> let me read up on saddleback saerch
09:07:58 <saml> would this  be a good interview question?
09:08:04 <c_wraith> Pearls of Functional Algorithm Design by Richard Bird, chapter 3
09:08:09 <Welkin> is that a search space with two maxima and one local minimum ?
09:08:26 <Welkin> with symmetry about the minimum?
09:08:34 <c_wraith> Welkin: in two dimensions - doesn't need to be symmetric
09:09:27 <saml> http://codingrecipies.blogspot.com/2013/10/saddleback-search.html  pretty simple
09:09:30 <saml> not sure how that works
09:09:33 <saml> oh sorted matrix
09:10:03 <c_wraith> saml: Bird's discussion actually improved on the standard algorithm
09:10:38 <c_wraith> saml: By taking advantage of the fact that the function is monotonic in each variable, allowing a binary search in each dimension
09:11:15 <saml> you decrement by one if too big,  increment by length of a dimension if too small?
09:11:28 <joobus> so uhh, 9999.0 * 10^305 == infinity on my comp in node.
09:11:51 <joobus> so uhh, 9999.0 * 10^304 == 9.999000000000005e+307.
09:12:16 <saml> > 9999.0 * 10^305
09:12:17 <lambdabot>  Infinity
09:12:23 <saml> > 9999.0 * 10^304
09:12:24 <lambdabot>  9.999000000000005e307
09:12:44 <saml> why test only 10 100 1000, ... etc?
09:12:45 <c_wraith> saml: well, you keep bounds that you know the solution lies inside, then test the midpoints to see what parts of the bounds can be eliminated
09:12:52 <joobus> ballpark first approximation
09:12:56 <Cale> The solution probably has x near -8.987e305
09:14:23 <Cale> > -8.98846567431158e305 * 100
09:14:24 <lambdabot>  -8.98846567431158e307
09:14:43 <Cale> > encodeFloat (-1) 1023 :: Double
09:14:45 <lambdabot>  -8.98846567431158e307
09:15:04 <Welkin> > 9999.0 * 10^305 :: Integer
09:15:05 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
09:15:05 <lambdabot>    arising from the literal ‘9999.0’
09:15:05 <saml> x, y, z are unsigned int
09:15:12 <saml> i mean natural numbers
09:15:14 <Welkin> > 9999 * 10^305
09:15:16 <lambdabot>  9999000000000000000000000000000000000000000000000000000000000000000000000000...
09:15:23 <saml> actually, x, y, z are doubles cause javascript
09:15:24 <Welkin> ah, using Double/Float
09:17:55 <saml> i mean, trick answer is that you set x = Infinity
09:18:09 <saml> no, then the result of 100x+9999y+9999z  will be NaN
09:18:11 <Cale> saml: hm?
09:18:32 <Cale> x = Infinity certainly won't minimise the sum
09:18:34 <saml> that web form also doesn't let me use decimal points like 8.345  
09:18:39 <saml> ah right
09:18:49 <saml> i made this quiz and i can't solve it
09:19:20 <saml> https://peatix.com/sales/event/75127/tickets  they just added a new row  $15
09:19:42 <saml> is this NP-Complete
09:20:59 * hackagebot geniserver 0.24.1.1 - Simple HTTP server for GenI results  http://hackage.haskell.org/package/geniserver-0.24.1.1 (EricKow)
09:23:10 <mmachenry> I've just made an update to my threading mechanism to handle zombie threads with ResourceT and I've love any feedback on it. http://lpaste.net/122819 Particularly revolving around potential to miss catching an asynchronous exception or having introduced a space leak.
09:23:31 <mmachenry> c_wraith: That link I just posted is my solution to the issue you and I were just talking about an hour ago.
09:25:11 <c_wraith> mmachenry: I think that's going to be correct. I'm pretty sure ResourceT goes through the appropriate effort to be exception-safe
09:26:01 <mmachenry> c_wraith: Yeah I've read the tutorial and I think that's right too. Though it's really nice to have some folks from #haskell critique as always :)
09:26:09 <mmachenry> Thanks for taking a look. 
09:31:00 * hackagebot geni-util 0.24.1.1 - Companion tools for use with the GenI surface realiser  http://hackage.haskell.org/package/geni-util-0.24.1.1 (EricKow)
09:31:16 <JaAnTr> ski: I'm not sure if you remember me, you were helping me last night with the increment and decrement thing. Anyway my internet disconnected, just wondering if you were still here/can still help.
09:37:19 <clrnd> I thought haclyon was only for heroku, but it seems it's useful for local dev too, how so?
09:37:23 <clrnd> halcyon*
09:42:09 <clrnd> wow this is magic
09:44:10 <exio4> what'd be the "best" way to do something based on the operating system I ran/compiled the binary? 
09:45:52 <clrnd> LANGUAGE CPP maybe?
09:46:01 * hackagebot not-gloss 0.7.0.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.0.1 (GregHorn)
09:46:07 <chrisdone> is there a tool that takes a haskell file and spits out the same source with all expressions wrapped in trace-like wrappers that writes the source location to some place? such that it can be used with e.g. {-# OPTIONS -pgmF trace #-}
09:47:11 <exio4> clrnd: I thought there'd be some action like IO String which would say which OS I am running or something like that, but I'll look at CPP :/
09:47:45 <clrnd> eisbehr, I thought you needed something at compile time ...
09:48:06 <clrnd> otherwise you have System.Info
09:48:13 <exio4> that'll do it
09:50:21 <gganesan> hi
09:50:33 <gganesan> hello haskell people
09:50:48 <chrisdone> hello!
09:50:54 <chrisdone> allo allo
09:50:56 <schell> hi all - i’m having a problem with cabal sdist - it seems it’s not archiving a folder of C headers
09:51:01 * hackagebot Plot-ho-matic 0.5.0.0 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.0 (GregHorn)
09:51:08 <schell> I’m sure it’s because they’re not listed correctly in the cabal file
09:51:16 <schell> I’m just not sure of the correct way to do that
09:51:24 <gganesan> I have a basic doubt, I just have a list .. say [ 1 .. 500 ] I just need to stop taking elements when I find 400 - how do I do it with takeWhile ?
09:51:41 <dropp> hey hey
09:51:53 <chrisdone> gganesan: you want the answer or help figuring it out?
09:51:59 <chrisdone> sup dropp
09:52:17 <gganesan> just a hint would do - let me try - I am a beginner to haskell :-)
09:52:23 <dropp> chrisdone! i scoured your emacs dots :-)
09:52:30 <chrisdone> the first hint is to check out the type of takeWhile
09:52:32 <chrisdone> :t takeWhile
09:52:33 <lambdabot> (a -> Bool) -> [a] -> [a]
09:52:37 <chrisdone> dropp: :D
09:52:57 <chrisdone> gganesan: have you already seen its type and does that aid, or no nothing for you? :)
09:53:07 <gganesan> yup .. so my problem is that the list isn't ordered - like [ 1, 2, 3, 4, 3, 2, 1 ]
09:53:18 <gganesan> I just want to stop when I find, say 3
09:53:50 <gganesan> so I do takeWhile ( < 3 ) [ list ] -> which just gives me [ 1, 2 ]
09:53:53 <dropp> takeWhile would be ideal like chris mentioned
09:54:13 <gganesan> yeah .. so in my above example - I want to stop when I find 3
09:54:21 <gganesan> and print that one too
09:54:27 <chrisdone> gganesan: what value are you expecting instead of what you got?
09:54:29 <dropp> you want the 3 included or no?
09:54:36 <gganesan> 3 included
09:55:16 <dropp> you could write a little wrapper, using takeWhile and then grab the head of the tail of your param and cons it to the takeWhile return value
09:55:17 <chrisdone> how about (<=3)?
09:55:33 <chrisdone> though, i suppose that would yield duplicates
09:55:53 <chrisdone> as would (<3)
09:55:58 <gganesan> oh ( <= 3 ) seems fine - let me try that one ... I can head it so that iteration stop at the first occurence
09:56:08 <gganesan> thanks chrisdone
09:56:23 <chrisdone> oh, if that's fine then good — it'll be a lazy result anyway so it'll stop when you stop consuming :-)
09:57:29 <chrisdone> one can also use listToMaybe instead of head, so that the possibility of no value is encoded in the type rather than implicitly lurking in the code
09:58:29 <gganesan> actually, I've been more of a python guy - I'm applying my haskell brain to crack problems at projecteuler.net
09:58:41 <dropp> good point, chrisdone. on a similar topic, is there any implicit difference between using Either or Maybe?
09:58:42 <gganesan> currently at https://projecteuler.net/problem=12
09:59:04 <dropp> Left v Nothing, Right v Just
09:59:11 <dropp> Anything else?
09:59:24 <chrisdone> i suppose Either () a is isomorphic to Maybe a :)
09:59:34 <dropp> ahh
09:59:37 <clrnd> dropp, Left can carry information, unlike Nothing 
09:59:56 <dropp> oh, error messages and what not. that's right.
10:00:24 <clrnd> lots of project euler newbies today, my first contact with haskell was for project euler :D
10:00:35 <chrisdone> indeed -- one tends to use Maybe for "no value and that's fine", whereas Either has better use for "something bad happened and here's what it was"
10:00:36 <dropp> project euler is fun!
10:00:45 <clrnd> very fun how j solutions where 10000 times faster and 1000000 times shorter
10:01:02 * hackagebot bindings-GLFW 3.1.1 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.1.1 (SchellScivally)
10:01:07 <chrisdone> i did my Euler solutions in C back when i was a C junkie =p
10:01:36 <moghedrin> > pl \x y -> fst x == fst y
10:01:38 <lambdabot>  <hint>:1:4: parse error on input ‘\’
10:01:41 <dropp> i've been doing them in C++ and Haskell to try and think through the problems in slightly different ways
10:01:47 <chrisdone> @pl \x y -> fst x == fst y
10:01:47 <lambdabot> (. fst) . (==) . fst
10:01:57 <moghedrin> chrisdone: Ha, thanks XD
10:02:06 <chrisdone> moghedrin: i think you're probably after on (==) fst
10:02:07 <dropp> plus i'm expert w/ C++, but Haskell is kinda new, so it's also for learning purposes
10:02:13 <chrisdone> :t on (==) fst
10:02:15 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
10:02:33 <moghedrin> chrisdone: Ah! Thanks! That's incredibly useful!
10:02:46 <chrisdone> welcome :)
10:03:21 <EvanR> "nobody is expert w/ C++" --feynman
10:03:42 <chrisdone> “"nobody is expert w/ C++" --feynman” --EvanR
10:04:01 <clrnd> lol
10:04:51 <dropp> let me re-phrase then. solving a problem in c++ doesn't require me to spend 30 minutes muling through documentation first :-)
10:05:10 <dropp> damn feynman and his quotes
10:05:12 <clrnd> @google c++ tutorial
10:05:15 <lambdabot> http://www.cplusplus.com/doc/tutorial/
10:05:15 <lambdabot> Title: C++ Language - C++ Tutorials
10:06:17 <dropp> haskell on the other hand, it's a bit more reading docs than coding at the moment. but it's getting better :-)
10:06:37 <clrnd> and :type
10:07:24 <gganesan> Again a silly question : I want the divisors of a number 6 => [ 1, 2, 3, 6 ]
10:07:35 <gganesan> so I do divs x = [ y | y <- [ 1 .. x ], x `mod` y == 0 ], which seems kind of brute
10:07:49 <clrnd> the emphasis should between "reading tutorials" and "reading docs"
10:07:52 <gganesan> when I try divs x = [ y | y <- [ 1 .. x / 2 ], x `mod` y == 0 ] ++ [x]
10:08:09 <gganesan> it says you can't mix Fractionals with Integrals
10:08:22 <gganesan> my type signature is divs :: ( Integral a ) => a -> [a]
10:08:25 <gganesan> any ideas ?
10:08:26 <dropp> use `div`
10:08:30 <dropp> instead of /
10:08:30 <clrnd> gganesan, yes, look
10:08:33 <clrnd> :t (/)
10:08:34 <lambdabot> Fractional a => a -> a -> a
10:08:43 <clrnd> :t div
10:08:44 <lambdabot> Integral a => a -> a -> a
10:08:49 <gganesan> oh ok ok - let me try the div way
10:09:07 <gganesan> but isn't `div` same as / ? I thought both were same ... :-(
10:09:32 <geekosaur> no
10:09:33 <clrnd> > 5 / 2
10:09:34 <lambdabot>  2.5
10:09:38 <clrnd> > 5 `div` 2
10:09:40 <lambdabot>  2
10:09:40 <chrisdone> div is for integrals, that's classic in some languages
10:09:40 <geekosaur> :t div
10:09:41 <lambdabot> Integral a => a -> a -> a
10:09:45 <geekosaur> :t (/)
10:09:46 <lambdabot> Fractional a => a -> a -> a
10:09:55 <dropp> think of `div` as dividing and then flooring the value
10:10:07 <dropp> where as / just divides it 
10:10:13 <cfoch> Hello
10:10:20 <chrisdone> because 5/2 cannot produce 2.5 if your type is Integer or alike
10:10:22 <clrnd> @src div
10:10:22 <lambdabot> Source not found. You type like i drive.
10:10:26 <gganesan> got it got 
10:10:34 <cfoch> can I use "cabal haddock" using a shared sandbox?
10:10:38 <gganesan> thanks for the clarification ...
10:10:39 <chrisdone> lambdabot: drunkenly?
10:10:44 <dropp> @src (/)
10:10:44 <lambdabot> Source not found. Just try something else.
10:10:53 <dropp> not much on source today
10:11:08 <chrisdone> what would the source of (/) be? =p
10:11:14 <dropp> no idea :-)
10:11:14 <c_wraith> dropp: (/) is part of a class anyway.  It's going to have a different implementation for every type
10:11:19 <chrisdone> :t (/)
10:11:20 <lambdabot> Fractional a => a -> a -> a
10:11:25 <chrisdone> it's a method of the class Fractional
10:11:31 <clrnd> @src Integral
10:11:31 <lambdabot> class (Real a, Enum a) => Integral a where
10:11:31 <lambdabot>     quot, rem, div, mod :: a -> a -> a
10:11:31 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
10:11:31 <lambdabot>     toInteger       :: a -> Integer
10:11:38 <chrisdone> @src Fractional
10:11:38 <lambdabot> class (Num a) => Fractional a where
10:11:38 <lambdabot>     (/)          :: a -> a -> a
10:11:38 <lambdabot>     recip        :: a -> a
10:11:38 <lambdabot>     fromRational :: Rational -> a
10:11:39 <clrnd> @src Integral Int
10:11:39 <lambdabot> Source not found. Abort, Retry, Panic?
10:11:45 <chrisdone> Panic!
10:11:48 * chrisdone takes cover
10:11:51 <clrnd> lol
10:12:01 <chrisdone> ᕕ( ᐛ )ᕗ
10:12:23 <cfoch> I don't like when lambdabot types too many lines :S
10:12:47 <cfoch> Fuuzetsu: how do you pass ghc parameters in "cabal haddock" ?
10:12:51 <cfoch> --ghc-options=OPTS
10:13:12 <cfoch> what do you put in OPTS
10:13:29 <chrisdone> "-O0 -fforce-recomp -release-the-hounds"
10:16:13 <cfoch> Fuuzetsu: for example I want to pass the -package-db parameter to "cabal haddock --ghc-options" how would it be?
10:16:29 <chrisdone> --ghc-options="-package-db potato"
10:16:35 * chrisdone taps the mic. is this thing on?
10:18:13 <indiagreen> chrisdone: no one will tell you
10:18:17 <indiagreen> bystander effect
10:18:17 <indiagreen> sorry
10:19:36 <cfoch> I got, I think
10:19:57 <funfunctor> hi
10:21:10 <clrnd> hi
10:21:19 <clrnd> idris makes me scared, looks fun though
10:22:06 <funfunctor> what is the usual pattern to use for a "main loop"? i.e. I have a action that needs to be run multiple times until some condition is meet
10:22:21 <funfunctor> clrnd: Idris is cool yes
10:22:38 <clrnd> funfunctor, recursion?
10:22:53 <exio4> funfunctor: go n = do ... unless cond $ go (f n)
10:22:56 <exio4> basically, recursion
10:23:08 <funfunctor> well this is not a function, its a action
10:23:24 <funfunctor> IO to be exact
10:23:27 <indiagreen> funfunctor: you could use untilM from monad-loops, or mfix if you want recursion but don't want to declare anything in let
10:24:07 <clrnd> funfunctor, well everything is an expresion in haskell, usually
10:24:22 <exio4> funfunctor: still the same 
10:24:24 <lpaste> funfunctor pasted “No title” at http://lpaste.net/122877
10:24:26 <exio4> main = do
10:24:31 <exio4>   x <- getLine
10:24:39 <exio4>   if x == "quit"
10:24:41 <funfunctor> the equiv of that
10:24:43 <exio4>   then return ()
10:24:47 <exio4>   else main 
10:24:52 <funfunctor> ok
10:25:01 <clrnd> main = do { lol <- something ; if lol then main else return () }
10:25:21 <ayeganov> Hello, I am trying to understand typeclasses in Haskell.
10:25:37 <ayeganov> Ooops, didn't finish typing sorry
10:25:54 <t7> ayeganov: its kinda like interfaces in c#
10:25:57 <indiagreen> funfunctor: note that using when or unless instead of “if ... then ... else return ()” would probably be more idiomatic
10:26:03 * hackagebot GLFW-b 1.4.7.1 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.7.1 (SchellScivally)
10:26:16 <clrnd> true, I was being lazy
10:26:40 <c_wraith> I like using fix to write loops in IO.
10:26:49 <funfunctor> indiagreen: thx, I usually get hlint to help me lol
10:26:58 <rnhmjoj> @pl \x -> [x, x+1]
10:26:58 <lambdabot> ap (:) (return . (1 +))
10:27:36 <t7> ayeganov: except even better: you can use generic types (List, Nullable) as parameters 
10:28:10 <funfunctor> ayeganov: a type is essentially a proposition, a type class is a proposition class, if that is helpful to you
10:28:17 <c_wraith> I think the best view of classes is as functions from types to values.
10:28:59 <ayeganov> In LYAH last part of chapter on "Making your own typeclasses" - we get to make Barry an instance of Functor. They give an example of mapping its first field. I undesrtand that part, but how do I now map the second field if I wanted to?
10:29:58 <ayeganov> I understand the part about kinds, but I am not sure how to "debug" my kinds
10:30:18 <c_wraith> ayeganov: You can't use Functor to map over the second field
10:30:37 <c_wraith> ayeganov: Functor always maps over the last type parameter
10:30:53 <ayeganov> aaaa
10:30:58 <glguy> Functor isn't generic for "map any field", it's specific to the last parameter
10:30:59 <ayeganov> what is produced
10:32:29 <ayeganov> thank you for your help, I understand it better now
10:34:19 <c_wraith> ayeganov: You can see why that's true, if you look at the type parameters carefully
10:34:41 <c_wraith> ayeganov: fmap :: Functor f => (a -> b) -> f a -> f b
10:35:01 <c_wraith> ayeganov: since a and b are parameters to (->), you know they must have kind *
10:35:14 <c_wraith> ayeganov: from that, you can see that f must have kind * -> *
10:36:04 <marchelzo_> Is there a way to catch exceptions without requiring the use of IO?
10:36:11 <c_wraith> ayeganov: So when you write an instance of Functor for something like Barry, it starts with  instance Functor (Barry t k) where ...
10:36:32 <ayeganov> c_wraith: My initial thinking was that I simply needed to massage "instance Functor (Barry a b etc)" properly to get to a specific field
10:36:56 <c_wraith> ayeganov: You need to do that to get the kinds to match.  But when you do that, you find that Functor only gets to vary the last type parameter - the other two aren't allowed to be touched by fmap
10:38:13 <c_wraith> ayeganov: ah, yes - you were wondering about type-level lambdas, more or less.  Haskell doesn't have those because they prevent this kind of inference from working simply.  If it didn't work, you'd have to put type annotations all over everything, and you'd lose most of the cleanness
10:42:51 <ayeganov> c_wraith: Is Barry example something that I may find useful in the wild, or is it simply an educational example?
10:43:14 <c_wraith> ayeganov: I've never seen exactly that type in the wild, but I've seen lots of types that make use of those same ideas
10:48:34 <Buck> I'm trying to get a list of all odd positioned items from another list, but I get the following error and I don't know why: Occurs check: cannot construct the infinite type: t0 = [t0]
10:48:49 <Buck> this is my code: Prelude> let odds [] = [] ; odds [a] = [a] ; odds [a:xs] = a:odds(tail xs)
10:49:04 <Buck> what am I doing wrong?
10:49:28 <geekosaur> (a:xs)
10:49:40 <geekosaur> [a:xs] is a single element list containing another list
10:50:05 <Buck> ahhhh
10:50:22 <Buck> thank you geekosaur!
10:50:29 <Buck> makes perfect sense
10:50:37 <Buck> yet I fall for these kind of things all the time
10:51:16 <geekosaur> it's very common. I can see why Prolog went with [H|T] instead, even though from a type-centric standpoint it looks weird
10:55:06 <KaneTW> i don't like prolog's [H|T] syntax personally
10:55:28 <geekosaur> I didn't say I liked it, just that I can see why they did it
10:55:58 <geekosaur> ML-family syntax is more pedantically "correct" but Prolog's is more compatible with how most people think
10:57:43 <geekosaur> because most people don't visualize lists as decomposable cons cells, they visualize them as a thing you can take pieces off the front of
10:57:53 <geekosaur> (in some sense "the same list")
10:58:19 <kallisti> hey guys, does the GHC LLVM backend make use of matrix and vector types?
10:59:07 <geekosaur> I don't think so. that sounds like something DPH should do, but DPH is kinda suffering from lack of developers/tuits
11:01:05 * hackagebot clafer 0.3.9 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.9 (mantkiew)
11:01:07 * hackagebot claferIG 0.3.9 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.9 (mantkiew)
11:01:09 * hackagebot claferwiki 0.3.9 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.9 (mantkiew)
11:01:12 <kallisti> geekosaur: the reason I ask because there's an LLVM to SPIR-V translator in the works for the new vulkan API
11:01:44 <kallisti> but I somehow doubt that LLVM code produced from the GHC backend would compile into efficient shaders
11:01:52 * hodapp perks up
11:01:56 <hodapp> LLVM to SPIR-V?
11:02:18 <hodapp> kallisti: I've heard that Haskell's LLVM bindings are quite good as well...
11:02:18 <kallisti> that's what I've heard through the grapevine
11:02:45 <kallisti> being "good" for a CPU architecture and being good GPU architecture surely have different requirements, no?
11:06:03 <kallisti> guess the only way to really find out will be to wait until the LLVM translator is released and test it.
11:06:48 <ptcek> any fool proof "tail -f" in haskell?
11:07:56 <chrisdone> please use more grammar! you had me confused for a while =p
11:07:59 <chrisdone> fool-proof
11:08:57 <hpc> ptcek: what are you trying to do?
11:09:00 <chrisdone> anyway, not aware of an implementation of tail 
11:09:01 <ptcek> chrisdone: I promise I'll do
11:09:41 <ptcek> hpc: I try to monitor a file thats appended to and moving the new data somewhere else
11:10:34 <clrnd> Bytestring exports 'interact'
11:11:40 <mietek> clrnd: hi!
11:11:49 <clrnd> mietek, hi
11:12:08 <mietek> clrnd: if you’re interested in Halcyon, join us in #haskell-deployment
11:12:36 <clrnd> mietek, oh that, I may try it sometime, I learned so much cabal it'd be a pitty to throw that away so soon :P
11:12:47 <mietek> clrnd: thoughtbot posted a great field study about it; https://robots.thoughtbot.com/building-haskell-projects-with-halcyon
11:12:58 <mietek> clrnd: well, Halcyon builds on top of Cabal — and you can mix and match
11:13:21 <clrnd> mietek, just what I needed, I'll read it right away
11:13:23 <mietek> clrnd: i.e. use Halcyon to install GHC and Cabal only, or also to build your sandbox
11:13:35 <clrnd> mietek, question, does it work on windows and OSX?
11:13:37 <mietek> clrnd: I also recommend my tutorial ;)  https://halcyon.sh/tutorial/
11:13:48 <clrnd> I've read the tutorial, twice
11:14:01 <clrnd> and the heorku one, looks very promising
11:14:01 <mietek> Ah. Oh dear. And you still thought it’s only good for Heroku?
11:14:18 <clrnd> mietek, no! that was before that
11:14:21 <mietek> OK :)
11:14:22 <chrisdone> i've only seen you talk about examples with heroku
11:14:33 <mietek> chrisdone: I don’t get it
11:14:37 <clrnd> yeah me too, it lacks propaganda
11:14:41 <ptcek> clrnd: interact reads from stdin, but I need to read from file, right?
11:15:00 <mietek> chrisdone, clrnd: but every example on https://halcyon.sh/examples/ even has a button which deploys to DigitalOcean
11:15:13 <chrisdone> i didn't say i read your examples page =p
11:15:16 <clrnd> ptcek, yeah, sorry missread, what about pipes or counduit?
11:15:41 <mietek> All right.
11:15:47 <chrisdone> oh, your new page is nice
11:16:00 <mietek> I think the word "Heroku" is so strong that whenever it appears, it overwhelms everything else
11:16:40 <mietek> chrisdone: I could use a quote from you about https://halcyon.sh/examples/#haskell-language or https://halcyon.sh/examples/#try-haskell ;)
11:16:40 <clrnd> mietek, what about windows and OSX?
11:16:57 <mietek> clrnd: OS X is supported, except the ability to install native OS packages via Halcyon
11:17:02 <mietek> clrnd: Windows is planned
11:17:16 <clrnd> mietek, ahhh nice
11:17:20 <mietek> clrnd: https://github.com/mietek/halcyon/issues/38
11:17:26 <mietek> List of supported platforms and status
11:17:44 <mietek> I need to run. #haskell-deployment!
11:17:59 <clrnd> cya
11:18:41 <ptcek> clrnd: I'll look at pipes, thanks for tip
11:29:58 <meditans> hi, does someone know which is the best haskell library for minikanren?
11:30:09 <__jim__> are functions monoids only if they have the form (a->a) ? 
11:30:50 <dolio> No.
11:33:45 <Ryanar> hope everyone is having a great day :)
11:35:37 <syndarion> Same goes for you Ryanar! :)
11:51:16 <S11001001> @let thefun :: a -> b; thefun = undefined
11:51:18 <lambdabot>  Defined.
11:51:39 <S11001001> @ty mempty `asTypeOf` thefun
11:51:40 <lambdabot> Monoid b => a -> b
11:56:08 * hackagebot pdf-toolbox-core 0.0.3.1 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.3.1 (YurasShumovich)
12:00:59 <athan> S11001001: Why the constraint only on `b`?
12:01:09 * hackagebot pdf-toolbox-core 0.0.3.2 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.3.2 (YurasShumovich)
12:01:11 * hackagebot pdf-toolbox-content 0.0.3.2 - A collection of tools for processing PDF files  http://hackage.haskell.org/package/pdf-toolbox-content-0.0.3.2 (YurasShumovich)
12:01:13 * hackagebot pdf-toolbox-document 0.0.5.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.5.0 (YurasShumovich)
12:01:42 <S11001001> athan: it is simply the Monoid b lifted into the (->) a applicative functor
12:01:44 <athan> I would imagine something like `Monoid (a -> b) => a -> b` or something silly like that
12:01:51 <athan> oh!!
12:02:30 <Fylwind> seems like the Functor instance of Scope (from bound by edwardk) is not compatible with the Monad instance: for example, (+1) `fmap` Scope [F [1, 2]] == Scope [F [2, 3]], yet Scope [F [1, 2]] >>= return . (+1) == Scope [F [2], F [3]]
12:03:02 <edwardk> Fylwind: Scope is only a Monad up to quotienting out the location of the internal 'F's
12:03:15 <edwardk> this is mentioned throughout the documentation
12:03:24 <edwardk> the alternative is asymptotically far far worse
12:06:09 * hackagebot pdf-toolbox-viewer 0.0.3.1 - Simple pdf viewer  http://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.3.1 (YurasShumovich)
12:07:51 <xplat> what's a good haskell library for reading config files?
12:08:41 <Fylwind> edwardk: but wouldn't it make sense to at least provide a consistent fmap?
12:08:51 <kaidelong> xplat: one of my friends used this and it worked for him, http://hackage.haskell.org/package/ini-0.3.1/docs/Data-Ini.html
12:08:56 <dolio> edwardk: I noticed the other day, the double-F version isn't just asymptotically better for some things. It's easier to write certain things, too.
12:09:25 <edwardk> Fylwind: no. doing so makes the functor require the monad and makes it slower too
12:09:31 <dolio> One might think the Maybe-only version is 'easier' in some sense, but they're just kind of incomparable.
12:09:44 <kaidelong> I used xpickle but I cannot really recommend it
12:09:49 <kaidelong> but it's there too
12:09:55 <kaidelong> it's more for serialization though
12:10:17 <edwardk> Fylwind: besides you then get that fmap yields a different answer than fmapDefault from Data.Traversable
12:10:22 <edwardk> Fylwind: so you lose either way
12:10:33 <edwardk> Fylwind: so we take the one that incurs the least number of constraints
12:11:09 * hackagebot pdf-toolbox-viewer 0.0.3.2 - Simple pdf viewer  http://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.3.2 (YurasShumovich)
12:11:22 <Fylwind> edwardk: makes me a bit queasy about it :\
12:12:20 <edwardk> Fylwind: its documented pretty clearly that you should not assume anything about the relative placement of "F's in the structure. it is a monad up to the result of toScope/fromScope.
12:12:36 <edwardk> the very point of the library is that it enables us to encapsulate that behavior
12:12:49 <edwardk> otherwise lift requires O(n)
12:12:59 <edwardk> if you go with the simpler Scope = EitherT definition
12:13:13 <edwardk> lift for EitherT has to walk all the values in the structure and put them in Right's
12:13:20 <edwardk> lift for Scope is O(1)
12:13:34 <edwardk> but it comes at the cost of quotienting out the placement information
12:14:11 <xplat> kaidelong: i don't think .ini files are powerful enough for my needs :7
12:14:49 <xplat> kaidelong: also, i'd kind of like a library that does a bit more.  xpickle might be closer.
12:14:59 <athan> xplat: I usually start from the beginning with configurator or yaml
12:15:22 <xplat> i wouldn't mind a format that looks kinda like .cabal
12:15:38 <Fylwind> edwardk: oh, I think I get what you mean now; so they are semantically equivalent expressions, even though they look different under Show?
12:15:46 <edwardk> yes
12:16:01 <edwardk> they are semantically equivalent under the quotient all of bound works with
12:16:14 <athan> xplat: Where is xpickle? Is it a package? :\
12:16:28 <Fylwind> edwardk: thanks for clarifying that
12:17:48 --- mode: ChanServ set +b *!*@wn-campus-nat-129-97-124-21.dynamic.uwaterloo.ca
12:17:48 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
12:17:58 <xplat> hm, configurator was on 24 days
12:18:09 <osa1_> wow, did you people knew about `cabal format` command?
12:18:49 <athan> xplat: I like it for the most part. Yaml is as easy as aeson, though
12:18:49 <Fylwind> osa1_: TIL
12:19:05 <inkjetunit> osa1_: what does it do?
12:19:13 <osa1_> it formats your cabal file :o
12:19:20 <Fylwind> reformats the .cabal file, it seems
12:19:31 <athan> osa1_++
12:19:45 <Fylwind> not sure I like it though; it also leaves trailing whitespace :(
12:20:02 <osa1_> interestingly I think it's not listed in --help
12:20:15 <osa1_> ooh that sucks (trailing ws)
12:24:04 <xplat> the main things that i see missing from configurator are automatically knowing what is a good place to look for a config file (~/.foo, ~/.config/foo, /etc/foo on unix, and whatever it is on windows, etc), and integration with optparse-applicative
12:25:28 <xplat> oh, autovalidation is missing too, that's a big one :(
12:25:51 <Tordek> hi
12:26:21 <Tordek> can every monad be turned into a comonad and vice-versa?
12:27:42 <edwardk> Tordek: no
12:28:02 <edwardk> Tordek: every comonad gives rise to a monad transformer
12:28:12 <edwardk> at least monads and comonads in 'hask' anyways
12:28:46 <Tordek> any examples?
12:28:59 <MP2E|Work> i did not know that (comonad giving rise to monad transformers). very interesting!
12:30:06 <athan> edwardk: how the heck..?!
12:30:16 <gyaretto> If I have f5 . f4 . f3 . f2 . f1 xs, is there a clean way to reverse it so the functions are in order?
12:30:26 <ab9rf> but they are in order.
12:30:56 <gyaretto> ab9rf: Well, so they read in order. Not important, but I'm curious.
12:31:13 <athan> gyaretto: You could use >>> instead of .
12:31:17 <athan> because . is basically <<<
12:31:23 <gyaretto> :t (>>>)
12:31:24 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
12:31:39 <gyaretto> What is Category?
12:31:41 <Tordek> edwardk: can't you trivially apply any Monad Transformer obtained from a Comonad to Identity and get a aMonad?
12:31:53 <athan> or alias it with `let >>> = flip .`
12:32:01 <athan> gyaretto: You'll see :)
12:32:31 <kaidelong> athan: http://hackage.haskell.org/package/xml-picklers-0.2.2/docs/Data-XML-Pickle.html
12:32:45 <xplat> > (+1) >>> show $ 11
12:32:46 <lambdabot>  "12"
12:32:55 <athan> thank you kaidelong
12:33:00 <kaidelong> xplat: if you're starting from scratch on a project I'd rather you not use XML unless there really is nothing better on hackage
12:33:18 <kaidelong> so I was hesitant to link it without better opinions from other more experienced people
12:34:37 <xplat> kaidelong: understandable.  so far i'm less than extremely impressed with the options, but yaml seems strictly better than an xml pickler and configurator is probably better too (but not strictly better)
12:36:08 <xplat> worse in that it doesn't do validation nicely, better in that it has a more readable syntax and some nice optional features like autoreloading
12:36:10 * hackagebot hlibBladeRF 0.1.0.3 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.3 (eocallaghan)
12:36:12 * hackagebot bytes 0.15 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.15 (EdwardKmett)
12:39:03 <randir> Hey guys, I have a question-- not directly about Haskell, but you guys are super nice and give good advice. I'm finishing my CS major in college (last semester) and a company I've been talking with wants to give me an offer to join their team (about to talk with them about the compensation for the offer, I believe).
12:39:20 <wayne> randir: cool congrats
12:39:21 <randir> I don't really have much context for it, so I'm wondering what a good amount to shoot for would be.
12:39:29 <randir> It's for a position as a security engineer.
12:39:51 <wayne> randir: look on a site like glassdoor for similar positions near that area
12:39:54 <sleepomeno> i see that parsect supports monadstate in the type of the state of a wrapped state monad. why does not support it monadstate in the type of the parsing state instead?
12:40:08 <wayne> randir: geography is probably the biggest influencer on that number
12:41:10 * hackagebot linear 1.17 - Linear Algebra  http://hackage.haskell.org/package/linear-1.17 (EdwardKmett)
12:41:20 <randir> wayne: okay, thanks
12:42:03 <randir> wayne: How much is it appropriate/expected to haggle, for an offer? I don't want to be rude, but also don't want to settle for something less than I should get.
12:42:26 <randir> I'm a talented programmer, above the median for CS grads. Active github and personal projects, and a few months of a great internship under my belt.
12:42:49 <randir> (Although frequenting this channel definitely humbles me, you guys are impressive.)
12:46:46 <HeladoDeBrownie> sleepomeno, presumably because the user state is always accessible with the appropriate parsers
12:47:12 <levi> randir: I think there are too many unknowns for anyone to give great advice on that. I second wayne's advice to look at sites that do salary surveys in your area.
12:47:17 <HeladoDeBrownie> namely getState and putState
12:47:18 <Ralith> randir: read and obey the advice of http://www.kalzumeus.com/2012/01/23/salary-negotiation/
12:48:28 <sleepomeno> HaladoDeBrownie: well otherwise I couldn't access that user state at all. still it would be nicer to access it "like being in the state monad", so that I can use the nice lens combinators there
12:48:45 <HeladoDeBrownie> sleepomeno, why wouldn't you be able to access the user state?
12:48:59 <HeladoDeBrownie> (i can think of some reasons but want to know about your issue in particular)
12:49:37 <HeladoDeBrownie> by the way, that didn't highlight me because you typo'd my nick
12:51:07 <sleepomeno> HeladoDeBrownie: i just meant if getState and putState didn't exist I couldn't access the user state at all. so I still wonder if it is a deliberate design choice to favor the monadstate state of a wrapped state monad over the user state
12:51:52 <HeladoDeBrownie> sleepomeno, well, they do exist. Parsec gives you the user state for free, it's *always* accessible, regardless of what you parameterize ParsecT on (including Identity). i imagine it's that so that they *could* have it regardless
12:52:24 <HeladoDeBrownie> the user state and MonadState state also serve different purposes
12:52:42 <HeladoDeBrownie> though i'd find it difficult to come up with a specific example of how
12:52:58 <HeladoDeBrownie> iirc, the user state backtracks whereas the other one doesn't necessarily?
12:53:05 <HeladoDeBrownie> someone else can confirm maybe
12:53:12 <sleepomeno> yes i think so actually
12:53:37 <sleepomeno> maybe that's the reason why it needs to be designed that way so that some monad law with respect to the monadstate holds...
12:54:18 <HeladoDeBrownie> i think you have the right idea with that
12:57:36 <dolio> I don't think it's necessary. Just someone made the decision that lifting a second MonadState through would be more useful than having ParsecT provide MonadState.
12:58:02 <dolio> That may or may not be true.
12:58:30 <HeladoDeBrownie> the cases are rare where not only is ParsecT not topmost but its user state has been hidden
13:00:08 <gcganley> I'm having some trouble with Network.Socket. is there any project/tutorial that shows how to use sockets well? 
13:00:23 <HeladoDeBrownie> i think there may have been a good book on this…
13:00:40 <HeladoDeBrownie> ah, Real World Haskell?
13:00:43 <gcganley> HeladoDeBrownie: is it in RWH?
13:00:44 <HeladoDeBrownie> i think that has a chapter on it
13:00:46 <HeladoDeBrownie> yes
13:01:00 <gcganley> HeladoDeBrownie: ok, ill take a look later. i have it on my iPad
13:01:11 * hackagebot linear 1.17.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.17.1 (EdwardKmett)
13:01:32 <gcganley> edwardk: you're still updating linear?
13:01:55 <edwardk> gcganley: found a few things that should go in after i pushed 1.17
13:01:58 <edwardk> hence 1.17.1
13:02:25 <edwardk> basically wanted support for the Data.Functor.Classes from transformers 0.5 (shimmed by transformers-compat) and I'd missed the serialization needs of Point.
13:02:48 <edwardk> gcganley: right now i think its stabilizing unless you have something else you think it needs right now
13:03:30 <gcganley> edwardk: Not right now. right now im struggling with a lot of the Networking side of Haskell
13:03:50 <edwardk> fun stuff that
13:04:03 <HeladoDeBrownie> threads and tvars and queues, oh my!
13:05:14 <gcganley> HeladoDeBrownie, edwardk: I'm trying to program a DHCP server. I've never done network programming I've only worked with cisco routers and switches for the past 2-3 years. The programming side of it is a new challenge to me
13:05:30 <gcganley> i missed a comma after network programming
13:05:55 <HeladoDeBrownie> gcganley, i'm pretty sure rwh is the book that gave me more or less exactly the idea of how to do it
13:07:17 <gcganley> HeladoDeBrownie: some of that book is a little dated though, thats why i usually go with online tutorials because they have a higher turn-over rate
13:07:23 <edwardk> I once wound up having to write a custom DHCP server in perl back around 97-98 or so because we were playing games looking things up in ARP tables to figure out how many machines were connected to each DSL line, and assigning them internal addresses until they paid up for more IPs. Kinda evil now that I think back on it.
13:07:50 <gcganley> edwardk: yeah you worked at that ISP right/
13:07:56 <gcganley> s/\//?
13:08:06 <edwardk> once upon a time, yeah
13:08:42 <gcganley> edwardk: how did the dot com bubble treat you?
13:08:46 <edwardk> One of my more catastrophically-failed get-rich-quick schemes ;)
13:09:03 <gcganley> edwardk: ah so not that well i see lol
13:09:19 <edwardk> Let's just say it took me from retiring at 25 and moving to an island somewhere to having to work for a living. ;)
13:10:23 <gcganley> edwardk: ahh, so lots and lots of money
13:10:32 <athan> edwardk: If you could change what you did, what would you have done differently?
13:10:43 <edwardk> gcganley: yes, athan: yes
13:10:49 <athan> (I hate being invasive sorry)
13:10:55 <athan> lol
13:13:14 <edwardk> athan: I turned down a job at NASA that would have let me leave with all my invested capital intact _and_ have NASA on my resume, in order to take a position in a company with a friend of mine, which was later then acquired back into the place I was leaving in the first place. In retrospect I probably should have just taken the job. That said, I don't think
13:13:14 <edwardk> I would have had the chance to go back and collect degrees or find Haskell the way I did, so its a bit of a karmic wash.
13:13:22 <edwardk> Just a very expensive wash
13:14:12 <clrnd> we would have like 50% less libraries, so good for us
13:15:00 <athan> edwardk: Sometimes the bait is worth taking? Thank you :)
13:15:06 <dmj`> edwardk: that's NASA's loss :P 
13:15:30 <athan> We need a statue for edwardk
13:15:41 <athan> (and all other major heros)
13:15:41 <clrnd> wasn't NASA really really surprised you turned them down?
13:15:53 <athan> out of GOLD DIAMONDS
13:16:22 <Cale> edwardk: lol, so you can still put "Turned down job at NASA" on your resume.
13:16:24 <clrnd> I'd pay for a statue of SPJ, someone kickstart it
13:16:32 <edwardk> hah
13:16:35 <athan> I wonder if we could make a haskell-based mmo, then put statues in it
13:16:50 <edwardk> do i get to put the list of companies on my resume where i've turned down jobs? that seems a bit like burning bridges
13:17:19 <edwardk> i can see it now, rating employees by how many google recruiter emails they ignore each month
13:17:47 <clrnd> and linkedin HR Consultant Friend Requests
13:17:54 <athan> contravariant in the category of opportunities
13:18:13 <edwardk> Given that Cale has turned down a job offer from me at least a few times, I think that puts him on top of the heap. =P
13:18:21 <clrnd> lol
13:18:40 * geekosaur has been tempted, having recently achieved the trifecta of {google,amazon,facebook}
13:19:01 <gcganley> I'm still in highschool :(
13:19:10 <geekosaur> (except that, well, that would imply that I was actively looking, in which case I might not have turned them down...)
13:19:19 <athan> gcganley: I'm a hobo :\
13:19:31 <athan> ANYONE HAVE A HOTDOG? v_v
13:21:02 <gcganley> edwardk: would you take the job at NASA now?
13:21:03 <clrnd> #haskell, where hobos ask NASA employes how to Category Theory
13:21:17 <dmj`> edwardk: did you turn down NASA to write haskell? 
13:21:22 <edwardk> gcganley: i'm probably in the wrong price range these days
13:21:35 <gcganley> dmj`: the NASA stuff was pre-haskell
13:21:58 <edwardk> dmj`: I turned down nasa way back when i was more of a perl junkie / what would now be called DevOps kinda person.
13:22:00 <vandenoever> missiles with lazy evaluation ...
13:22:20 <gcganley> vandenoever: unsafeLaunchMissles
13:22:24 <Cale> If you've turned down a job at NASA, your NASA number is 0. Otherwise, it's the successor of the minimum of the NASA numbers of people from whom you've turned down jobs.
13:22:37 <josephle> safeLaunchMissiles :: Launcher -> Maybe Missile
13:22:37 <edwardk> Cale: =)
13:24:40 <dgpratt> oh edwardk, I am determined that someday I will understand more than 15% of what you write about
13:24:49 <dgpratt> same goes for Cale too, actually
13:25:09 <akegalj> HashSet.insert of unordered-condainers package says its O(min(n,W)). What is W here?
13:25:14 <edwardk> dgpratt: I'm determined that someday I will understand more than 15% of what I write about as well.
13:25:19 <dgpratt> :D
13:25:43 <WraithM> akegalj: The number of bits on your CPU, iirc, so 32 or 64.
13:26:02 <akegalj> WraithM: oh, ok
13:26:05 <acetoline> so the type system in system F_\underline{\omega} is a STLC, right?
13:26:12 <acetoline> even without quantification over types?
13:26:22 <WraithM> akegalj: That might be a total lie. It should be in the documentation.
13:26:26 <gcganley> edwardk: I am determined to make it to one of the Haskell meetups during the summer
13:26:38 <edwardk> gcganley: where are you located again?
13:26:47 <gcganley> edwardk: Sandwich, MA
13:26:51 <edwardk> oh yes
13:26:54 <dgpratt> edwardk, speaking of, is "p => (q => r)" equivalent to "(p, q) => r" ?
13:27:09 <akegalj> WraithM: in header it says "The implementation uses a large base (i.e. 16) so in practice these operations are constant time."
13:27:12 <edwardk> dgpratt: at least check it was 'almost' the same
13:27:15 <akegalj> WraithM: is this some kind of clue?
13:27:39 <edwardk> i was able to get something to typecheck with (p, q) => r   with fundeps that i didn't get to check with p => (q => r)  -- but i haven't duplicated that test lately
13:27:45 <edwardk> they may have improved things since then
13:27:56 <dgpratt> edwardk, so they are morally the same?
13:28:05 <vandenoever> is it ok to ask beginner questions about compilation errors here?
13:28:11 <Cale> vandenoever: absolutely
13:28:18 <edwardk> morally
13:28:25 <dgpratt> :)
13:28:36 <vandenoever> https://paste.kde.org/poqc2ohpn does not like my Builder
13:28:52 <vandenoever> Couldn't match expected type ‘blaze-builder-0.3.3.4:Blaze.ByteString.Builder.Internal.Types.Builder’
13:29:14 <lpaste> Cale pasted “vandenoever's code” at http://lpaste.net/123054
13:30:15 <Cale> vandenoever: Maybe you could give the whole error message? :)
13:30:25 * frerich_ is a bit frustrated to realize that approx. 70% of the time he spent on this web application are spent on the JQuery code which tries to layout some puny dialogs. OTOH, Scotty is pretty nice.
13:30:29 <gcganley> vandenoever: anything remotly related to haskell is more than welcome
13:31:07 <gcganley> frerich: i love Scotty, I've never had any gripes with it now that i think about it
13:31:10 <hexagoxel> is it a bad idea to bump a libraries version bounds to base<4.9 if it works fine with ghc-7.10-rc2 ? is it possible that stuff will break with the final ghc-7.10?
13:31:51 <vandenoever> Cale: http://lpaste.net/123054
13:32:04 <dmj`> vandenoever: you should be using OverloadedStrings if you aren't
13:32:09 <Cale> aha!
13:32:24 <vandenoever> dmj`: i removed that to figure out what was going wrong, i was using that
13:33:01 <vandenoever> after swapping out blaze for vanilla builder, i still had no luck, caveat: i'm really a haskell beginner
13:33:06 <Cale> vandenoever: This sort of error happens when you have multiple versions of a package (in this case blaze-builder) installed, and your dependencies depend on different versions of it.
13:33:13 <jaga1> Can someone explain memoization briefly?
13:33:18 <vandenoever> so i'm not entirely sure yet when i'm doing really silly stuff
13:33:24 <meoblast001> hi
13:33:35 <vandenoever> Cale: ah, so wai uses a different blaze-builder?
13:33:39 <clrnd> hi
13:33:41 <Cale> yeah
13:33:45 <vandenoever> Cale: how can that be avoided?
13:34:31 <Hijiri> jaga1: Memoization means you store the result of some computation, so you can reuse it if you need it again later
13:34:36 <vandenoever> i tried removing the blaze-builder dep, but perhaps it comes in via another package, cabal says build-depends: base, wai, case-insensitive atm
13:34:56 <jaga1> Hijiri: I know that :) But how it works?
13:35:00 <clrnd> jaga1, memoization is when you save an "expensive to compute" value when you suspect it's gonna needded later
13:35:02 <Cale> Hopefully, ghc-pkg unregister all but one of the versions, and rebuild things which depended on the one you don't want to use.
13:35:03 <Hijiri> jaga1: 
13:35:10 <Hijiri> jaga1: it depends on the specific implementation
13:35:10 <clrnd> jaga1, how it works where?
13:35:41 <clrnd> when using paper, you can write in the edges
13:36:12 <Hijiri> in GHC haskell, everything (most things) is pointers, because when you have immutable data, pointers to it are "just as good" as the data itself
13:36:30 <Cale> vandenoever: Also, it tends to help when asking cabal-install to install things to specify as many of the packages at once as you can (obviously not always an option, but in the case of sandboxes, you can often do it)
13:36:35 <Hijiri> If you point to an incomplete computation, and you have to get the value, you end up computing the value. Then you can replace the incomplete computation with the result
13:36:58 <jaga1> Hijiri: oh! That's what I needed to realize. Thank you.
13:37:02 <Cale> vandenoever: It'll try to find a consistent set of versions of everything to install which will satisfy all the dependencies at once that way.
13:37:19 <dgpratt> edwardk, I've decided the problem is my brain has no intution for formal logic
13:37:27 <clrnd> jaga1, but ahskell doesn't memoize functions, watch oout
13:37:28 <dgpratt> everytime bit of Haskell I see, my brain feels it must mechanically...evaluate it before it makes sense
13:37:42 <dgpratt> and by the time that happens, the context is lost
13:37:47 <jaga1> clrnd: ahskell?
13:37:51 <clrnd> haskell*
13:37:57 <S11001001> dgpratt: Give it a bit.  "Intuition" often means "that with which I am familiar".
13:38:29 <dgpratt> S11001001, true -- I just wish I felt I had more time to explore it
13:38:35 <Cale> vandenoever: You don't *have* to unregister the old versions (and in the case of packages that are installed globally because they came with GHC, don't worry about it), but as far as the packages you installed locally are concerned, it's helpful to try to make sure you only install one version of each at a time.
13:38:37 <jaga1> clrnd: what do you mean? :/
13:38:56 <silver> yea, intuition can be acquired
13:39:03 <clrnd> jaga1, that ahskell doesn't memoize functions automatically because they are pure, a common misconception
13:39:10 <clrnd> again, haskell, damn
13:39:29 <vandenoever> Cale: great, that did the trick, i unregistered the newer blaze-builder, removing the old one would break a lot of things
13:39:52 <jaga1> clrnd: if I call function with the same args many times - it will compute it everytime?
13:40:10 <clrnd> jaga1, it depends on the context, but generally yes
13:40:23 <jaga1> clrnd: isn't there a way to avoid it?
13:40:37 <Cale> dgpratt: One thing about Haskell expressions which is different from expressions in most other languages is that you don't necessarily have to understand how they're evaluated because at least with regard to the result and termination behaviour of your program, it (at least most of the time) doesn't matter.
13:40:38 <clrnd> jaga1, if it auto-memoized every call, it'd consume a lot of memory, wouldn't it?
13:40:41 <Hijiri> jaga1: Give a name to the result, and store it somewhere
13:40:52 <vandenoever> Cale: thanks a lot, now i have some faith in potentially grokking haskell again
13:40:54 <jaga1> Hijiri: oh, yeah, obvious :D
13:41:11 <Hijiri> Top-level: fib5 = fibonnaci 5; Somewhere else you would have to explicitly store it
13:41:19 <jaga1> clrnd: Hijiri thank you, guys!
13:41:19 <clrnd> python has a cool decorator, do we have one laying around?
13:41:31 <Hijiri> like in a Map, or as part of some other data structure
13:41:31 <dgpratt> Cale, would that I could convince my brain of that fact :)
13:41:35 <Cale> dgpratt: You just need to understand which value the expressions have, which is less work than understanding the step by step evaluation process. Any order of evaluation which terminates will get the same result, and if there is an order which terminates, then the order that the Haskell implementation does it will terminate.
13:42:04 <clrnd> glad I helped, gotta go now
13:42:12 <dgpratt> makes sense, Cale
13:42:14 <edwardk> my intuition for logic is 'could i write a program with that type'
13:42:27 <edwardk> its not the right way to think classically
13:42:37 <edwardk> but it lets me flit through quickly and filter out a lot of stuff
13:42:44 <edwardk> then i add double negation elimination and i can do logic
13:44:28 <Cale> dgpratt: This also gives you a lot more freedom, because it means for instance that if you can evaluate in strict order and get a result, that's the same result as you'd get if you'd used lazy evaluation. (GHC uses this fact when compiling)
13:44:48 <dgpratt> I see
13:45:25 <edwardk> i went back and picked up a more formal grounding later on, but i pretty much get by on the fact that as a little kid i drew Karnaugh maps to simplify little TTL logic chip circuits, and they had to be simple enough that i'd be willing to wirewrap the board. that pretty much gave me what little intuition i have in that space
13:45:37 <dgpratt> :)
13:46:09 <dgpratt> as a little kid, I played nintendo
13:46:13 * hackagebot natural-transformation 0.1 - A natural transformation package.  http://hackage.haskell.org/package/natural-transformation-0.1 (ryanglscott)
13:46:25 <edwardk> "Now, I want my robot to back up and _turn_ when it hits the wall" ugh.
13:48:33 <edwardk> there was a book i grew up with by David Heiserman called "Build your own working robot" (he later did a second edition)
13:49:08 <edwardk> http://www.amazon.com/Build-your-own-working-robot/dp/0830668411/ref=tmm_hrd_swatch_0?_encoding=UTF8&sr=&qid=
13:49:18 <athan> So I want to make a monad / higher-kinded data type to represent a "parser", something like parsec. Do I have to encode alternatives and expectations in this data type? Does anyone have suggestions for starting out with this style of parser design?
13:49:51 <athan> and by encode, I mean "include all alternatives/expectations in it's constructor"
13:50:04 <Cale> athan: Start with "A parser for things is a function from strings to lists of pairs of things and strings"
13:50:05 <gcganley> athan: two ways of thought. using the Maybe type-class or using lists
13:50:29 <athan> Cale: Ahh, that makes sense - the leftovers, correct?
13:50:31 <Cale> athan: i.e.  newtype Parser a = P { runParser :: String -> [(a, String)] }
13:50:33 <Cale> yeah
13:50:44 <athan> ahh okay that makes sense
13:51:04 <dgpratt> one of my minor life goals is to prove wrong the famous Dijkstra quote about programmers who learned BASIC
13:51:06 <athan> I just did an `:i` on optparse-applicative's Parser, and it had something like alternatives built in
13:51:16 <athan> (at least I think ><)
13:51:37 <wayne> what's the maximum line byte size for IO LineBuffering?
13:51:52 <gcganley> dgpratt: i started with Just Basic. an absolutly terrible language
13:51:56 <Cale> athan: My suggestion here doesn't give you the most efficient parsers -- they're pretty bad space-wise, you often end up holding on to the beginning of the input for a long time.
13:52:19 <gcganley> dgpratt: i think his beef was people trying to make better languages regress back to basic using things like goto
13:52:29 <dgpratt> I'm sorry gcganley, but I'm glad you seem to be on the road to recovery :)
13:52:30 <Cale> athan: So other data types can avoid that, or improve the time performance by building tables or things like that. But this is the nicest way to start to get a handle on it :)
13:52:31 <athan> hmm. I'll try a few different ideas Cale, I'm not looking for anything performant right now though
13:52:49 <athan> I'm just making an options parser library, not a document parser :)
13:53:05 <Cale> athan: If you're already familiar with StateT, you might notice that this is StateT String []
13:53:22 <athan> Ahh yes that makes sense!
13:53:24 <Cale> But it might be a good idea to write the instance of Monad by hand just to get a feel for it :)
13:53:49 <vandenoever> btw: my first serious haskell project should become a filtering and caching http(s) proxy
13:53:53 <athan> Would the alternative instance just be a case analysis? hmm...
13:54:07 <Cale> athan: It's just concatenation of the lists of results
13:54:08 <vandenoever> porting to haskell from nodejs
13:54:45 <Cale> p <|> q = P (\s -> runParser p s ++ runParser q s)
13:54:49 <gcganley> vandenoever: how much haskell have you written?
13:55:04 <athan> Cale: ...wait... for an attoparsec-style alternative instance?
13:55:10 <ab9rf> porting from almost anything to haskell is usually a nontrivial exercise
13:55:15 <athan> hmm, okay
13:55:24 <vandenoever> gcganley: examples from RWH and LYAH
13:55:47 <vandenoever> gcganley: but mostly tiny bits
13:55:47 <athan> oh shoot okay, it just runs them both and handling the result is where you get different behaviour..?
13:55:48 <Cale> athan: Well, there won't be any need for "try" here
13:55:49 <ab9rf> i suppose you could cheat and write everything as a do ....
13:56:14 * hackagebot buffer-builder 0.2.2.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.2.0 (chadaustin)
13:56:16 * hackagebot profunctors 4.4 - Profunctors  http://hackage.haskell.org/package/profunctors-4.4 (EdwardKmett)
13:56:20 <athan> hmm. Thanks Cale :)
13:56:30 <Cale> athan: Well, the ways of parsing a string s with the parser p <|> q are all the ways of parsing it with p together with all the ways of parsing it with q
13:56:39 <gcganley> vandenoever: hmm, ok, so not just running in blind you have a tad bit of experience, i usually start with something akin to project euler to get my feet wet in a language that makes me think but doesnt make me create an entire project
13:57:01 <ab9rf> your first several projects in haskell will be terrible
13:57:21 <athan> Ahh! And the first successful result could be seen as the implementation for failing-over p to q?
13:57:40 <athan> gcganley: That's what I did :)
13:57:56 <Cale> athan: Yeah, if p produces no parses, then you might end up with the first parse being one from q
13:58:07 <Cale> (or you might end up with no parses from q either)
13:58:16 <athan> that makes perfect sense! Thank you Cale!!
13:58:29 <ab9rf> neither parsec nor attoparsec will attempt q unless p has already failed.
13:58:33 <gcganley> athan: wait what did you do? i went back to my hw and lost track
13:58:53 <athan> gcganley: project euler with haskell :)
13:59:06 <athan> taught me a lot about using comprehensions wisely
13:59:11 <Cale> athan: Also, as far as places to start with after you get Monad implemented, I highly recommend implementing  satisfy :: (Char -> Bool) -> Parser Char
13:59:17 <gcganley> athan: i did the first few i didnt do all of them like i did with Clojure
13:59:40 <Cale> athan: That'll get you lots of useful primitives, like char, space, letter, number, etc.
13:59:44 <vandenoever> gcganley: thanks for the hint, i might do some of those on the side or when i'm stuck
13:59:55 <athan> hmm, okay will do! Thank you Cale!!
14:00:09 <Cale> athan: and with char and mapM, you can implement string
14:00:12 <athan> gcganley: Same here >< I stopped at #24 last year :\
14:00:31 <athan> ahh yeah that makes sense
14:01:19 <Cale> ab9rf: and we'll get at least that much here just due to lazy evaluation
14:02:23 <Cale> ab9rf: but one major difference with parsec and attoparsec is that if p manages to consume some input, those libraries immediately abandon the option of q (unless you explicitly used try)
14:02:29 <ab9rf> i've been learning a great deal about parsec the last week or so
14:02:37 <athan> Cale: So satisfy takes as many characters that satisfy the predicate, then delimits the resulting list on failure to False, right?
14:02:46 <Cale> athan: No, just a single character
14:02:50 <ab9rf> Cale: yup, the parser i'm writing is littered with "try" to deal with that aspect of parsec :)
14:02:51 <athan> oh shoot
14:03:15 <ab9rf> satisfy accepts exactly one token
14:03:18 <Cale> athan: It's really simple -- there will be just one parse, extracting a single character from the input if it matches the predicate, and no parses otherwise
14:03:21 <ab9rf> if it accepts any at all
14:03:30 <athan> yeah :P
14:04:09 <Cale> You can write it pretty nicely using a list comprehension that has no <-'s in it.
14:04:21 <Cale> (and one boolean guard)
14:05:19 <lifter> I'm trying to learn conduit. The Sink type returns (), and this seems to be getting in my way. I'd like to have a sink return some other value that could then be passed around to other functions and so on. I suppose any code that directly deals with the "result" of some conduit operation must be enclosed in the sink? Any advice?
14:06:15 * hackagebot buffer-builder 0.2.2.1 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.2.1 (chadaustin)
14:06:27 <gcganley> lifter: isnt that just Conduit?
14:06:28 <Cale> lifter: A Sink doesn't produce an output stream, but it does have a final result.
14:07:07 <lifter> I must be missing something. It seems to me that a Sink must have () as its final result.
14:07:17 <Cale> nope!
14:07:21 <Cale> type Sink i = ConduitM i Void
14:07:22 <athan> Cale: satisfy p = [c|p c] :D
14:07:32 <lifter> oh
14:07:33 <athan> erm, something like that
14:07:45 <lifter> Sorry, I think this might be due to my use of awaitForever
14:07:51 <ab9rf> no, the stream type of a Sink is () but the result of evalating a conduit can be anything you like
14:08:07 <lifter> awaitForever :: Monad m => (i -> ConduitM i o m r) -> ConduitM i o m ()
14:08:18 <athan> satisfy p (c:cs) = [(c, cs)|p c]
14:08:44 <lifter> I guess I should stop using awaitForever
14:09:00 <Cale> athan: Up to inclusion of the data constructor for the newtype, and handling the case for an empty list, yeah
14:09:19 <athan> Sweet :) thank you Cale!!!
14:09:20 <gcganley> lifter, you just have to face Sink is never going to return your calls
14:09:50 <ab9rf> you can write a Sink that does some sort of combination on the stream of values it receives and returns them
14:10:01 <ab9rf> as a single "value" of any type that amuses you
14:10:38 <lifter> ab9rf: Yes that is precisely what I want to do
14:10:50 <lifter> somehow I'm just having trouble figuring out how to do this
14:10:51 <ab9rf> i had code that did that once, but i don't seem to have it around any more
14:13:22 <jaga1> https://wiki.haskell.org/Memoization#Memoization_with_recursion Does memoized_fib work for o(n)?
14:14:03 <hpc> yes
14:14:25 <jaga1> hpc: why?
14:14:42 <ab9rf> lifter: ah, i remember.  conduit lives in an underlying monad, which is often IO
14:14:51 <hpc> because it stores the result values in a "global variable"
14:15:00 <Cale> Uh, that one might be O(n^2) though
14:15:03 <hpc> (technically in a partially evaluated thunk)
14:15:04 <Cale> It's not exponential
14:15:11 <lifter> ab9rf: Yep, I have a stack w/ IO in my case
14:15:16 <Cale> But a list is a really bad choice of data structure for a memo table
14:16:02 <NemesisD> is it possible to constrain a type variable to a particular kind?
14:16:16 * hackagebot haskell-neo4j-client 0.3.0.10 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.10 (asilvestre)
14:16:16 <NemesisD> e.g. i need type variable a to be of kind [*]
14:16:24 <Cale> xs !! n takes O(n) time
14:16:25 <jaga1> Cale: yeah, I thought about o(n^2) too
14:16:35 <athan> Cale: What's the traditional way to represent failure for a result? Maybe something like `Parser a = Parser (String -> Either Err (a, String))`?
14:16:46 <geekosaur> -XKindSignatures?
14:17:05 <Cale> athan: Well, yeah, if you want to report error messages you need to do something better than just producing an empty list of parses
14:17:14 <lifter> ab9rf: I may have got it.
14:17:18 <athan> hmm okay :) thanks!!
14:17:32 <ab9rf> lifter: there's an example right at the top of https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
14:17:39 <Cale> athan: If you lose the list structure though, you'll miss out on the possibility of doing any backtracking
14:17:55 <athan> Yeah I forgot to add that in my note, sorry ><
14:18:32 <ab9rf> lifter: look at the implementation of Data.Conduit.List.fold
14:19:15 <lifter> ab9rf: ok
14:20:11 <ab9rf> lifter: although i admit that that implenentation is confusing
14:20:15 <kallisti> NemesisD: as long as you're using DataKinds extension you should be able to do this
14:20:35 <NemesisD> i think kind signatures what what i needed
14:20:36 <ab9rf> lifter: basically the sink should use return in the underlying monad
14:20:48 <lifter> ab9rf: Yeah, this is rather dumb of me, but you are right, I can just use return.
14:21:02 <NemesisD> i'm pretty sure i'm sinking deeper into a tar pit of haskell i don't understand right now
14:21:06 <lifter> ab9rf: And then get the value out of the result of the "runResourceT"
14:21:16 * hackagebot webcrank-dispatch 0.1 - A simple request dispatcher.  http://hackage.haskell.org/package/webcrank-dispatch-0.1 (purefn)
14:21:18 * hackagebot semigroups 0.16.2 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.2 (EdwardKmett)
14:21:45 <ab9rf> i haven't worked with conduits in a while.
14:22:03 <Hijiri> NemesisD: perhaps the ideal will help you find inner strength, like in wuxia or anime
14:22:07 <Hijiri> ordeal
14:22:16 <lifter> I get it now. Thanks everyone.
14:22:32 <NemesisD> lol
14:23:06 <ab9rf> i have a parsec tokenizer that feeds tokens to a parsec parser
14:23:09 <vandenoever> does anyone know why wai >= 3 does not use conduit anymore?
14:24:13 <kallisti> NemesisD: basically you use `[] and a `: b to represent the two type constructors that have kind [*]
14:24:21 <ab9rf> right now the tokenizer produces a list of tokens, which is then parsed by the parser, but i suspect i could make that nicer
14:24:31 <frerich_> “Plain old functions go a long, long way.” must be about the best Haskell advice I ever got.
14:24:33 <ab9rf> using a yield approach instead of the current mess
14:24:59 <NemesisD> maybe i can explain my problem better. i can't quite grasp a strategy for what i'm trying to do
14:25:43 <kallisti> NemesisD: maybe you're instead trying to say "this type variable should always be of the form [a]"? That is not quite what the [*] kind means
14:26:53 <NemesisD> so i'm working on some logging code with a logging function that can take something like Map String String, we'll call it an env, a long message and to log it. the way the app is structured, there's nesting of monads, so you'll have some stuff happening at the web layer (with its own domain-specfic env), and then maybe a layer at the feature level
14:27:21 <kallisti> NemesisD: assuming Map String String is like an interpolation map or something?
14:27:30 <NemesisD> i'd like each monad to define how to extract its environment and not have to worry about the larger context its called in, and then i'd like to be able to mappend those Map String String
14:27:42 <kallisti> like to convert #{foo} into the log message into something else
14:27:44 <NemesisD> kallisti: no just a key value context, like say requestid, session id, etc
14:27:51 <kallisti> ah okay
14:28:25 <NemesisD> so i've devised a type-level list, so I could have something like LCons WebContext (LCons FeatureContext LNil) and be able to combine those together
14:29:29 <kallisti> NemesisD: there's already a built-in type-level list you can use for that, with the ': and '[] type operators
14:29:42 <kallisti> I think it also supports '[a, b, c]? not sure though.
14:30:47 <NemesisD> the trick is defining a typeclass that will let those compose, so a specifc monad need only specify how to get its context and it will automatically be prepended to the list
14:30:56 <NemesisD> kallisti: that's exactly what i'm using :)
14:31:09 <kallisti> NemesisD: and then to actually get the environment value you could just have a typeclass with a single method env :: t -> Env
14:31:30 <kallisti> and have an instance for '[] ': WebContext etc
14:32:51 <athan> Cale: Would `return` & `pure` simply not consume any input? :S
14:32:58 <kallisti> NemesisD: so is it a situation where your logging structure has its own env, and you want to take the environment encoded into the type paramter of that structure and combine it with your user-defined env?
14:33:17 <NemesisD> its like i need a secret monadreader, i don't want monadic code at the low level to have to carry a constraint that points out specifically its higher level context, just that it exists
14:35:09 <NemesisD> kallisti: something like class LogEnv m where getLogEnv :: m (Map String String), class LogEnvStack m where curStack :: m (LogEnvStack xs)
14:35:11 <kallisti> NemesisD: maybe something like: instance HasEnvironment context => HasEnvironment (Logger context a) where getEnv logger = ...
14:35:45 <NemesisD> where LogEnvStack is a GADT using type-level lists, so xs :: [*]
14:36:05 <ab9rf> better results are had if you save your changes to your shource before recompiling and retesting
14:36:17 * hackagebot htsn-import 0.2.2 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.2.2 (MichaelOrlitzky)
14:36:19 * hackagebot bifunctors 4.2.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.2.1 (EdwardKmett)
14:37:00 <mmachenry> I just finished running the first day of the first Haskell class at my company.
14:37:22 <mmachenry> Wahoo.
14:37:28 <xplat> mmachenry: cool
14:37:56 <Hijiri> how was the reception?
14:38:21 <xplat> some say class Teacher doesn't have a Monad constraint
14:39:02 <mmachenry> Great. It was all opt-in. So reception was guaranteed to be good. But I was pleasantly surprised with the number of people who were interested and attended. 
14:41:17 * hackagebot comonad 4.2.3 - Comonads  http://hackage.haskell.org/package/comonad-4.2.3 (EdwardKmett)
14:43:41 <athan> So I want to add a couple of functions to Data.Tree in containers, but I've never written a proposal before. Does anyone have a professional-looking idea of what I should mash on my keyboard? :(
14:44:59 <kallisti> NemesisD: something like this http://lpaste.net/123128
14:48:51 <kallisti> NemesisD: the kind signature isn't even necessary really
14:50:35 <NemesisD> kallisti: hmm hold on i'm fleshing out a reduced example of what i'm thinking
14:57:36 <Cale> athan: That's right. They produce a single parse, not having consumed any input, with the given value as the result
15:01:18 * hackagebot buffer-builder 0.2.2.2 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.2.2 (chadaustin)
15:02:32 <athan> Cale: That seems so strange, as the function is a parser
15:03:26 <Cale> athan: return v is generally the action which does nothing except to, well, return v
15:04:08 <kallisti> is there anything on hackage for type-level maps?
15:10:19 <lpaste> NemesisD pasted “nested logging contexts” at http://lpaste.net/123148
15:11:30 <NemesisD> kallisti: its kind of a mess right now but its a rough sketch of what i'm looking for. i'm thinking rather than keeping a type level list if i could do something like a ReaderT [LogContextGetter m] m a
15:13:16 <NemesisD> i want a dictionary to be carried around where at any given time, it gives you a dicitonary method that will pull up the current log context from all the monads its embedded in. *hand waving*
15:14:36 <Zemyla> How much extra space does a GADT constructor take over a normal data constructor?
15:15:01 <exio4> extra space where?  
15:15:57 <Zemyla> In the object itself.
15:27:53 <Cale> Zemyla: none
15:28:09 <Zemyla> Okay.
15:28:23 <Cale> Zemyla: The only differences between GADTs and ordinary datatypes is one which exists at compile time in the type system.
15:28:42 <Cale> Their runtime representation is identical, and at that point the types are gone.
15:38:35 <bsummer4> haskell-src-exts gives me a parse error when it sees a line pragma. I'm calling it like this: https://www.irccloud.com/pastebin/EjV8VuqK Any idea what I'm doing wrong? Does HSE even support line pragmas?
15:45:08 <camm1> How to know if a programming languge is functional?
15:45:36 <Cale> camm1: It's not a clear cut notion
15:45:40 <bsmt> if it has functions
15:45:59 <ab9rf> if it functions, then it's functional.  badum bump.
15:46:00 <Cale> camm1: Different programming languages support functional programming techniques better or worse than others
15:46:22 <kaidelong> lexical scope and tail call elimination
15:46:35 <kaidelong> higher order functions of a kind too
15:46:42 <camm1> C++ has functions, Is it a functional programming language?
15:46:51 <kaidelong> this could be done by passing a pointer to the start of another function though
15:46:52 <Cale> camm1: It doesn't have what most of us would call functions
15:47:12 <Cale> camm1: Oh, well, C++11 has lots of crazy stuff I don't know about...
15:47:33 <kaidelong> oh yeah, closure of some kind is pretty important too
15:47:46 <Cale> I hate calling closures a language feature
15:47:54 <kaidelong> yeah it's pretty fundamental
15:47:55 <Cale> They're a language implementation mechanism :)
15:48:47 <Cale> They can be used to implement first class functions which capture the values of variables in lexical scope (otherwise known as "functions")
15:49:36 <Cale> But closures are fundamentally not functions, they're pairs of a certain sort
15:50:22 <Cale> Once you can no longer project out the code and environment separately, they're not closures any more.
15:52:36 <camm1> Is there any web framework to work with Haskell?
15:52:52 <Cale> camm1: There are at least 4 popular ones
15:53:06 <xplat> Cale: so calling closures a language feature is like calling a pear an orange?
15:53:06 <Cale> Happstack, Snap, Yesod and Scotty
15:53:34 <dmj`> camm1: you can also roll your own with just wai/warp
15:54:06 <xplat> they all have pretty different approaches.  probably Happstack and Yesod are the most similar pair out of the four.
15:54:19 <bsummer4> Nm, I figured it out. Haskell has it's own syntax for LINE pragmas and cpphs needs to be configure to output that.
15:54:56 <camm1> Thanks guys, your are great!
15:55:14 <Cale> xplat: There's probably a better analogy than that...
15:55:16 <xplat> Scotty is minimalistic, Yesod is batteries-included with magic syntax, Snap is batteries-included without magic syntax
15:55:52 <Chobbes> xplat: I want that to be the description on the web frameworks wiki page.
15:56:10 <Cale> xplat: Perhaps it's like calling a stack of blank paper and a toner cartridge a book.
15:56:41 <Cale> You can turn those things into a book, and that's a pretty natural thing to make with them
15:56:50 <JoshieAS> anyone have a resource that is the clearest possible explanation for what a monad is?
15:56:57 <Cale> Or, vice versa
15:57:02 <xplat> Cale: sure it's better, but that analogy is no pun at all
15:58:21 <Cale> JoshieAS: I could link you to my tutorial...
15:58:29 <Cale> JoshieAS: But what is it that you already know?
15:58:47 <Cale> JoshieAS: Do you know what type classes are?
15:58:57 <JoshieAS> I have a basic understand of type, typeclasses, functors
15:59:01 <JoshieAS> understanding*
15:59:11 <JoshieAS> I can make my own datatypes, shit like that
15:59:19 <JoshieAS> I had experience with SML before I dove into Haskell
15:59:22 <Cale> Okay, so Monad is just another type class, similar to Functor in that it abstracts over a type constructor
15:59:30 <NemesisD> kallisti: i've simplified the problem dramatically but i'm getting an infinte type error now
15:59:33 <lpaste> NemesisD pasted “infinite type” at http://lpaste.net/123190
15:59:52 <Cale> class Monad m where
15:59:57 <Cale>   return :: a -> m a
16:00:05 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
16:00:16 <JoshieAS> >>= is bind, right?
16:00:19 <Cale> yeah
16:00:28 <NemesisD> kallisti: i realized that there was a monoid to be had here, so nesting contexts can just mappend them
16:00:34 <Cale> and there are three laws which these are meant to satisfy
16:02:49 <Cale> JoshieAS: The intuition which applies to essentially all of the contexts we use the idea for in programming is that if M is a monad, we think of values x of type M a as describing actions or computations of some sort, whose results (when carried out) have type a
16:03:19 <Cale> JoshieAS: return v is then the action which "does nothing" (whatever that means for the sort of action we're talking about), and has v as its result
16:03:56 <JoshieAS> I see
16:04:47 <Cale> JoshieAS: and whenever x is an action having a result of type a, and f is a function from values of type a to actions whose result have type b, then (x >>= f) is the action which when executed will first execute x, getting some result, say v, and then execute f v, producing its result as its own.
16:06:14 <Cale> That's a bit of a mouthful... it's like "do x, then y", but where we then allow which action y is to depend on the result of x
16:06:50 <JoshieAS> I see, so it's sort of a directive for applying certain procedures
16:06:52 <Cale> In Haskell's do notation:  (x >>= f) = do { v <- x; f v } = do { v <- x; w <- f v; return w }
16:07:22 <Cale> So, there are a lot of simple examples of monads which might not look much like sorts of actions at first
16:07:33 <kaidelong> fortunately [] does
16:07:41 <Cale> Well, heh
16:08:49 <Cale> The type constructor for lists is a monad which probably most people wouldn't initially regard as a sort of action
16:09:06 <Cale> while perhaps Parser or IO or something like that would be easier to see the analogy for
16:09:56 <Cale> But yeah, the idea there is that you can think of a list as a nondeterministic computation, which forks the universe, having each of the elements of the list as a result
16:10:21 <Cale> [1,2,3] >>= (\x -> [x, 10*x])
16:10:22 <Cale> > [1,2,3] >>= (\x -> [x, 10*x])
16:10:24 <lambdabot>  [1,10,2,20,3,30]
16:11:04 <Cale> So x is selected from the list [1,2,3] in all possible ways, and then the results of that branch of the computation are x and 10*x
16:11:33 <Cale> i.e. xs >>= f = concat (map f xs)
16:11:56 <Cale> and for the list monad, return v = [v]
16:12:22 <JoshieAS> I see, I see
16:12:30 <JoshieAS> That was very helpful
16:12:40 <kaidelong> you know
16:12:47 <Cale> https://wiki.haskell.org/Monads_as_computation
16:12:53 <dmj`> @typ flip concatMap
16:12:53 <lambdabot> [a] -> (a -> [b]) -> [b]
16:12:56 <Cale> is a more thorough description
16:14:39 <Cale> I always find it curious the ways in which people feel the need to edit my articles. I don't really mind, but it's funny that someone replaced the k in x >> y = x >>= (\k -> y) with a _
16:14:58 <bitemyapp> Cale: what article?
16:15:18 <Cale> https://wiki.haskell.org/Monads_as_computation
16:15:46 <Cale> I have a slight aversion to underscores
16:16:04 <Cale> Sometimes I'll name variables when I don't really need to
16:17:57 <Cale> (and not even feel guilty about it)
16:18:21 <bitemyapp> Cale: interesting. Any rationale there?
16:18:35 <Cale> bitemyapp: I just think they're typographically ugly
16:18:55 <Cale> Especially as the parameter of a lambda I think \_ -> ... looks bad
16:19:13 <Cale> But just visually
16:19:23 * bitemyapp nods
16:19:51 <kaidelong> I just think of (\_-> ... ) as an alias for (const $ ... )
16:20:00 <vandenoever> the _ is reasonable to me, even in normal text it can be used to represent a placeholder
16:20:09 <vandenoever> an alternative would be *
16:20:37 <Cale> Also, if there's an opportunity to convey a couple bits of information about the type or meaning of what that parameter is, even if I'm not going to use it in some case, I don't like to use _ instead.
16:20:58 <Cale> Like, xs will tell you that the thing in that position is a list
16:21:01 <bitemyapp> Cale: that's a good point. Seeing "k" lets you know what it was.
16:21:23 <bitemyapp> it is effectively an unchecked assertion about what things are and are not, when they're not used though.
16:21:30 <Cale> yeah
16:21:56 <Cale> and it's a subtle and ignorable assertion, but it's there, and I think it can help slightly
16:22:11 <vandenoever> wont it send people on a wild goose chase: 'where is that k/xs used?'?
16:22:23 <Cale> vandenoever: That's the counterargument I suppose
16:22:35 <vandenoever> i like the idea of conveying type
16:22:50 <vandenoever> even though type is the line above, it could help
16:23:27 <kaidelong> k doesn't give any information
16:23:33 <kaidelong> _ gives information that the value won't be used
16:24:55 <Cale> When the entire body of the lambda is a single character though, it's a bit questionable whether _ is really giving information
16:32:23 <kaidelong> Cale: well, it does signal that you really did mean v and not something like k v or v k
16:36:45 <cmccann> Cale: obviously a list of _ should be named "_s" ;]
16:37:56 <kaidelong> I can actually see this working
16:38:15 <kaidelong> _s is a valid haskell identifier and (_:_s) works as a pattern
16:38:29 <kaidelong> however (_:_) does seem clearer to me
16:38:35 * cmccann isn't entirely joking, wink emoticon aside
16:45:10 <lifter> Can anyone explain why Data.Conduit.List has a "consume" sink while Data.Conduit.Text doesn't seem to have anything like that?
16:49:18 <Clint> lifter: what would it do?
16:49:57 <acowley> Presumably call T.pack or whatever it is once everything is in memory.
16:50:14 <lifter> Clint: Well, in other words, I'd like to write a sink of this type: Sink T.Text (ResourceT MudStack) T.Text  ...where the return Text on the right is the same value as the other Text in the type sig.
16:50:38 <lifter> sorry, Mudstack is ReaderT blah IO
16:51:46 <Clint> lifter: so you want to concatenate all the incoming T.Texts?
16:51:46 <lifter> I can't figure out how to get text from upstream and return it as the result of the conduit operation such that it can be retrieved as in "resultText <- runResourceT ..."
16:52:01 <lifter> Clint: Yes.
16:52:02 <johnw> I think there's a sinkLazy that will do it, lifte
16:52:09 <johnw> consume is sort of the "old way"
16:53:26 <lifter> I'll paste some code
16:53:34 <johnw> always a good plan :)
16:58:16 <Clint> lifter: http://hackage.haskell.org/package/conduit-combinators-0.3.0.6/docs/Conduit.html#v:foldC ?
16:59:23 <Jello_Raptor> ... huh, I'm looking at code i wrote a few years back
16:59:44 <lpaste> lifter pasted “Conduit woes” at http://lpaste.net/123243
17:00:02 <Jello_Raptor> and I reinvented a incredibly shitty version of do notation over Maybe using macro hackery in C 
17:01:19 <johnw> lpaste: I think that paste has other problems
17:01:30 <johnw> there is a stream in conduit for transforming to utf8
17:01:39 <hyPiRion> Jello_Raptor: I think you might be me
17:01:44 <johnw> if you do it chunk-wise like this, you run the risk of a multibyte character getting split at a chunk boundary
17:01:45 <hyPiRion> Jello_Raptor: https://twitter.com/hyPiRion/status/572857901703811075
17:02:13 <lifter> johnw: Ah. 
17:02:15 <johnw> lpaste: you could do what you want with a fold sink
17:02:22 <johnw> but I think sinkLazy will do it too
17:02:53 <johnw> sinkLazy is polymorphic in the result type, so just treat it like it's a lazy text and it should be
17:02:55 <Jello_Raptor> hyPiRion: the same project has me creating generic data structures though absurd amounts of macro hackery, and implementing fold, and map etc, over them. 
17:03:01 <johnw> (even though everything will be memory)
17:03:11 <hyPiRion> Jello_Raptor: okay, you might be a bit more serious than me
17:03:53 <lifter> hmm ok
17:04:08 <Jello_Raptor> hyPiRion: nah, this was a one off project, that code was *not* safe enough to use in anything vaguely important 
17:04:16 <hyPiRion> haha
17:04:17 <Jello_Raptor> class project*
17:04:35 <Jello_Raptor> hyPiRion: I was casting function pointers into other *different* function pointers >_> 
17:04:42 <Jello_Raptor> there are so many ways that could go wrong 
17:05:05 <lifter> interesting
17:05:21 <hyPiRion> sounds like the most typesafe code ever written
17:05:34 <Jello_Raptor> but it's the closest i could get to properly typechecked generic datastructures. Macros that wrap void* verions of functions with well typed ones
17:05:49 <Jello_Raptor> hyPiRion: it's in C ... that's patently impossible
17:06:16 <hyPiRion> Jello_Raptor: yes, I know. I wrote my master's in it
17:06:25 <Jello_Raptor> hyPiRion: oh what was your masters? 
17:06:56 <hyPiRion> Jello_Raptor: optimisations over a data structure, coincidentally. RRB-tree improvements: https://github.com/hyPiRion/c-rrb
17:07:33 <Jello_Raptor> hyPiRion: seriously, I'm an embedded systems dev, and i'm doing everything I can to avoid C 
17:07:54 <hyPiRion> I don't blame you
17:07:55 <Jello_Raptor> hyPiRion: oh cool, most of the interesting immutable datastructures are still beyond me :/ 
17:08:08 * Jello_Raptor really wants systems level rust to take off 
17:08:14 <Jello_Raptor> also i want rust to have higher kinded types 
17:08:54 <dmj`> Jello_Raptor: what's stopping you from using haskell
17:09:31 <kaidelong> higher kinded types are planned for rust I think although not a high priority
17:09:56 <Jello_Raptor> dmj`: mostly the need to develop all the bootstrapping and FFI things needed for each microcontroller I use. 
17:10:33 <Jello_Raptor> dmj`: also I'm not sure what the best model is, an entire monad for the state of the device? how do i do interrupts? etc .. 
17:11:17 <Jello_Raptor> (the question of interrupts in a pure functional context is actually really vexing, and I've not come up with any useful mappings from imperative land into functional land)
17:11:37 <Jello_Raptor> (read: if any of you have any insights, i'm all ears) 
17:19:17 <dmj`> Jello_Raptor: maybe relevant, http://blog.ezyang.com/2010/08/interrupting-ghc/
17:31:25 * hackagebot sbv 4.1 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-4.1 (LeventErkok)
17:35:43 <xplat> Jello_Raptor: considered atom?
17:37:53 <sellout> Is there already something like ***, but `(f a -> b) -> (f c -> d) -> f (a, c) -> (b, d)`?
17:40:44 <Jello_Raptor> xplat: nope, what's that? 
17:41:45 <Jello_Raptor> xplat: http://hackage.haskell.org/package/atom ? 
17:51:14 <dibblego> sellout: looks very similar to the Profunctor instance of DownStar
17:56:41 <lukke100> I'd like to create a Functor instance for my "Zipper c a". However, rather than just mapping over the "a" type variable, I'd like my instance declartion to assert that "c" is a Functor instance of a as well, and fmap over it. Is this possible?
17:57:14 <benzrf> hmm
17:57:24 <benzrf> liftA2 (***) (fmap fst) (fmap snd)
18:00:43 <enthropy> is there a wrapper around cabal that makes it try harder (ex. you type "cabal test" and it tells you to reconfigure with --enable-tests... instead of actually just reconfiguring)
18:02:21 <S11001001> lukke100: yes; Control.Monad.Free.Free does exactly this.
18:05:55 <lukke100> I've found the module on Hackage, do you know of any good tutorial for Free Monads? I've heard of the concept, but this module isn't really connecting with what I know of them.
18:11:27 * hackagebot ersatz 0.3 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.3 (EdwardKmett)
18:16:31 <amalloy> i am trying to manually desugar the layout portion of a do block, and i don't see what i'm missing here. this runs fine when spread over 3 lines, but as a single line with braces and semicolons i get a parse error: do {let x = undefined; y <- Nothing; return $ x + y}
18:16:54 <shachaf> do { let { x = undefined }; ... }
18:17:03 <shachaf> The ; is being associated with the let rather than the do.
18:17:07 <geekosaur> let also intruduces layout that needs to be replaced with braces
18:17:17 <amalloy> ohhh, i see
18:17:37 <amalloy> i opted out of layout for the do, so i don't get any for the let either
18:17:43 <geekosaur> right
18:18:56 <geekosaur> well, not entirely sure that's the right explanation but you can use ; in let or do without using braces, 
18:19:12 <geekosaur> so you need the braces if you want the semicolon to be part of the do instead of the let
18:19:30 <geekosaur> (whereas braces are what turn off layout. it's kinda tangled)
18:22:06 <amalloy> anyway, thanks folks
18:38:18 <xrumb> I have a question about Category Theory by Awodey - http://lpaste.net/123331
18:38:50 <xrumb> surely the conditions can't be true for _any_ f?
18:39:09 <xrumb> surely the conditions can't be true for _all_ f? *
18:39:50 <xrumb> it seems that f can be any arbitrary function between sets
18:40:42 <xrumb> it doesnt have to be structure-preserving but (_f_ . i) is structure preserving...
18:46:38 <shachaf> xrumb: Right, any f.
18:46:57 <xrumb> shachaf: what am i missing here?
18:48:23 <xrumb> i think im missing something trivial and obvious
18:48:57 <shachaf> xrumb: Well, it's |_f_| o i = f, in your notation, not _f_ o i = f
18:49:03 <shachaf> Which would be a type error.
18:49:07 <xrumb> yeah shachaf thats right
18:49:50 <meoblast001> hi... suppose i'm using the binary package and want to (for example) open a large file, skip to the end of the file, and read the last byte
18:49:59 <meoblast001> are there any ways i can do this without loading the entire file into memory?
18:50:28 <shachaf> You might look at the example in the book, which shows that this holds for the type [A]
18:50:38 <meoblast001> well.. i know there are ways.. but are there ways that aren't extremely complex?
18:50:41 <acowley> meoblast001: Use a Handle and the System.IO facilities for seeking with a Handle
18:51:01 <shachaf> xrumb: You should keep in mind that f : A -> |N|, not e.g. f : |M(A)| -> |N|
18:51:14 <meoblast001> acowley: and to get the binary data out?
18:53:30 <acowley> meoblast001: You'd use decode as normal
18:54:35 <acowley> meoblast001: So you seek to where you want on the Handle, you use hGet from bytestring to get a ByteString, and you decode that with your Binary instances.
18:56:19 <acowley> meoblast001: You do need to take care that you understand if and when the Handle is closed.
18:56:29 * hackagebot ascii-progress 0.1.1.0 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.1.1.0 (yamadapc)
18:57:09 <meoblast001> acowley: ah okay. so i need to bounce in and out of Get?
18:57:26 <acowley> meoblast001: Possibly
18:57:35 <meoblast001> hm, okay
18:57:39 <meoblast001> that could work
18:59:47 <xrumb> in a monoid the object is the set of elements, and the arrows are like curried operators with the first parameter being each element right? 
19:01:02 <shachaf> I don't know exactly what you're asking, but I think the answer is no.
19:01:24 <shachaf> If you mean the way you represent a monoid as a category with one object, I guess I see what you mean.
19:01:34 <xrumb> yeah thats what i mean
19:01:39 <shachaf> I suppose it's not wrong but it misses the point a bit. It doesn't matter what the object is.
19:01:53 <dmj`> meoblast001: I'd use io-streams
19:02:07 <dmj`> meoblast001: check out this function, https://hackage.haskell.org/package/io-streams-1.2.1.2/docs/src/System-IO-Streams-File.html#withFileAsInputStartingAt
19:03:21 <xrumb> shachaf: the object cant be just a one element set containing the identity because then you wouldnt be able to map any arrow other than identity onto this object
19:03:25 <xrumb> right?
19:03:28 <dmj`> meoblast001: it will seek to that byte before attaching the file descriptor to the input stream for reading.
19:03:46 <shachaf> The object doesn't need to be a set.
19:03:53 <shachaf> It can be the number 8, or my cat.
19:04:01 <xrumb> right
19:04:12 <xrumb> but the arrows have to be valid mappings between the objects
19:04:24 <shachaf> No they don't.
19:04:24 <relrod> shachaf: don't trap your cat in a monoid, that's mean :(
19:04:31 <xrumb> shachaf: they dont?
19:04:46 <shachaf> relrod: Don't worry, monoids are so easy to escape.
19:05:14 <xrumb> this book says that the arrows have to be morphisms/maps between objects of the category
19:05:18 <acowley> Is this a hairball joke?
19:05:21 <shachaf> The arrows aren't (necessarily) mappings at all.
19:05:42 <shachaf> Well. I guess it depends on what you mean by "mapping". If you define it to mean "arrow", then arrows are mappings.
19:05:49 <monochrom> there are a couple of famous categories in which arrows are not maps.
19:05:50 <shachaf> But they aren't necessarily functions.
19:06:09 <xrumb> right
19:06:20 <xrumb> but it says that arrows always have a domain and codomain
19:06:28 <xrumb> which are objects of the category
19:06:50 <monochrom> that may only be abusing those words to really just mean sources and targets.
19:07:04 <xrumb> ok sure
19:07:51 <xrumb> but the group operation maps (AxA) -> A
19:08:22 <monochrom> either this book has a prelude that declares "this book is only interested in categories that have functions for arrows", or it is bunk.
19:08:24 <xrumb> so if the monoid category is represented as one object which is the set A
19:08:34 <meoblast001> dmj`: i tried looking into io-streams and messing with it but i've been told it could take me some time to grasp it
19:08:38 <xrumb> im not saying that arrows are functions
19:09:27 <dmj`> meoblast001: who said such things? io-stream docs are some of the best, there's even a tutorial section written by Tekmo
19:09:45 <meoblast001> he's in this channel and he won't want me to highlight him
19:10:02 <dmj`> meoblast001: he's not here right now
19:10:09 <dmj`> meoblast001: did you look at that function I showed you?
19:10:39 <monochrom> there is no contradiction among "it has good docs", "it takes some time to learn", and "you should learn it"
19:10:45 <meoblast001> mhm.. i wouldn't be able to use that to skip ahead after reading some things, right?
19:10:48 <meoblast001> or skipping backwards?
19:11:07 <monochrom> in fact, "it takes some time to learn" is a tautology. everything worth learning takes some time to learn. will you avoid it then?
19:11:23 <acowley> io-streams may be fantastic, but pulling it in to seek in a file seems a bit heavy handed
19:13:55 <dmj`> main = withFileAsInputStartingAt (fromIntegral 5) "foo.txt" (supplyTo stdout)
19:14:26 <meoblast001> acowley: well. i'm dealing with something where i'm going to probably be jumping around a lot
19:14:55 <monochrom> not to mention that if the name "io-stream" is faithful, i.e., it really talks about streams, then it has nothing to do with seeking.
19:15:04 <cmccann> monochrom: learning nothing takes no time, and as the identity value for knowledge acquisition learning nothing is necessarily worthwhile in a trivial way!
19:15:13 <dmj`> meoblast001: I'd wrap it in bracket, or fork it with async, but you will get deterministic resource handling
19:15:14 <meoblast001> hmm
19:15:21 <acowley> cmccann: I don't have the time to parse that
19:15:49 <monochrom> just add a comma after "acquisition"
19:16:33 <cmccann> acowley: and not parsing it is a worthwhile non-use of your time, I agree
19:16:50 <acowley> Oh crap, have I been tricked into learning a valuable life lesson?
19:16:54 <monochrom> but logically I don't think "nothing" qualifies for consideration in a for-all sentence.
19:17:10 <shachaf> cmccann is an expert at non-uses of his time and also of my time.
19:17:24 <cmccann> shachaf: yes, exactly
19:17:42 <shachaf> Some of my best non-work hasn't been done by cmccann.
19:18:06 <meoblast001> dmj`: i've seen some hints about memory mapped files possibly resolving this. is that possibly the case?
19:18:07 <acowley> He's very efficient
19:18:35 <cmccann> acowley: I think you've been not-tricked into not-learning a valuable life lesson, which by double negation elimination might be the same thing
19:19:11 <jmcarthur> double negation doesn't exist in real life
19:19:11 <exio4> cmccann: we're not classical
19:19:13 <cmccann> which is to say, it's not a constructive use of anyone's time
19:19:21 <exio4> cmccann: we're constructive 
19:19:26 <exio4> hahahah
19:19:26 <monochrom> I am not a non-nobody
19:19:30 <acowley> Hah, classic cmccann
19:19:32 <relrod> cmccann: nice pun :D
19:19:56 <monochrom> (double negation is so passe. real logicians do at least triple negation.)
19:19:58 <relrod> or… not-nice non-pun?
19:20:25 <acowley> meoblast001: I don't think using hSeek is too onerous if you want to jump around a file. The hardest part is managing an explicit import list from System.IO if your editor doesn't do it for you.
19:20:25 <jmcarthur> when people use double negation in conversation they don't normally mean quite the same thing as if there had been zero negation.
19:20:26 <dolio> exio4: You should begin with saying you're constructive, rather than not classical, obviously.
19:20:29 <cmccann> relrod: I'll defer to shachaf's judgment on that. he's the pun expert, modulo 13.
19:20:37 <dolio> Since it's the stronger statement.
19:20:56 <meoblast001> acowley: explicit import list of what?... you mean for name collisions?
19:21:00 <jmcarthur> well, exio4 is not not constructive, at least.
19:21:25 <shachaf> cmccann: I'm only the expert on a certain class of puns, and I'm not sure whether yours qualify.
19:21:32 <monochrom> I like Kripke's semantics for intuitionistic logic
19:21:39 <monochrom> @quote monochrom Kriple
19:21:39 <lambdabot> No quotes match. My brain just exploded
19:21:43 <monochrom> @quote monochrom Kripke
19:21:43 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
19:21:58 <acowley> meoblast001: Yes, System.IO exports rather a lot of identifiers, so either importing qualified or with an explicit list is good policy
19:22:04 <cmccann> shachaf: what class of puns is that
19:22:09 <jmcarthur> just wait until we start talking about double positives
19:22:40 <monochrom> is "doubleplusungood" double positive or double negative?
19:22:49 <shachaf> jmcarthur doesn't seem to believe that Double is an instance of Num. Which is probably just as well.
19:22:55 <acowley> My personal beliefs have been trending towards ultradoublepositivism
19:23:10 <shachaf> cmccann: The fun puns.
19:23:13 <meoblast001> acowley: okay. i'll definitely consider that
19:23:17 <acowley> I saw a gist that provided a Num instance for shachaf's cat
19:23:28 <jmcarthur> monochrom: it's double positive single multiplicative inverse
19:23:45 <shachaf> acowley: I don't even have a cat.
19:23:45 <jmcarthur> i think i just broke
19:23:46 <monochrom> :)
19:24:07 <acowley> shachaf: don't speak of little m(eow)empty like that
19:24:16 <monochrom> shachaf's cat is the king of france
19:24:37 <acowley> All I know is it has a monoid instance and he hasn't mappended it in weeks.
19:25:03 <monochrom> ah, I am uncreative
19:25:43 <jmcarthur> Double negative all the way across the sky!
19:26:18 <cmccann> jmcarthur: I think I've actually put that in a comment once or twice
19:26:37 <relrod> shachaf: You should get a cat and name it Kleisli :)
19:26:37 <acowley> Worst Pull Request Ever
19:26:40 <cmccann> well, either that or s/negative/negation/
19:26:44 <jmcarthur> cmccann: i googled it. i am apparently the 43rd person to say it
19:26:54 <relrod> shachaf: Then you can have a Kleisli cat. :)
19:27:28 <shachaf> I do have a cat, actually.
19:27:29 <cmccann> well, the only google result for "double negation all across the sky" appears to be me
19:27:34 <shachaf> I keep it in /bin.
19:27:43 <acowley> Messed up
19:28:01 <monochrom> then simply change your shell prompt to say "kleisli>"
19:28:28 <monochrom> then there will be times your terminal shows "kleisli> cat"
19:28:32 <dmj`> meoblast001: potentially yea, http://hackage.haskell.org/package/mmap-0.5.9/docs/System-IO-MMap.html
19:28:51 <shachaf> Better yet, change your shell prompt to say "kleisli cat>"
19:29:57 <monochrom> but then when you enter "cat amorphism.txt", the screen will read like "kleisli cat> cat amorphism.txt" and it will be a very confusing double-catative
19:30:46 <dmj`> meoblast001: I'm just not sure exactly what you're trying to do
19:32:00 <monochrom> I now have an improved idea. don't change your prompt. just do "ln -s /bin /kleisli"
19:34:48 <mseeks> i have two concurrently-accessed lists contained in TVars, and I do an operation where I remove an item from one list and add it to another atomically. now I want to persist one of the lists -- i thought about using acidstate but it doesn't do atomicity and doesn't seem to integrate with STM well
19:34:50 <mseeks> any suggestions?
19:36:44 <dmj`> mseeks: what do you mean it doesn't do atomicity
19:37:16 <mseeks> dmj`: if you have two acidstates you can't atomically remove from one/add to the other
19:38:50 <nurupo> say i have "[(Integer, Integer)]" and i split it like this "list@((x, y):xs)". i have trouble writing "find (w, u) in xs such that w==x and u is the maximum among all tuples with w==x"
19:39:23 <dmj`> mseeks: yes, agreed, but if you're using two states you're trying to achieve atomicity across the network, correct?
19:39:45 <mseeks> dmj`: what do you mean by atomicity across the network?
19:40:03 <alexclark> so I want to through a custom error in a little program im writing
19:40:07 <dmj`> mseeks: why not just use one state? 
19:40:17 <alexclark> im also reading 'learn you a haskell'
19:40:25 <alexclark> im going to get to monads soon
19:40:36 <monochrom> what does "find" mean? that is, what answer must you emit? simply the w? simply the u? simply the (w,u)? the index position where it occurs in xs?
19:40:52 <alexclark> should i read about monads before trying to figure out exception handling?
19:40:55 <nurupo> monochrom: (w, u)
19:41:16 <monochrom> ok. since w==u anyway, can I emit (u,u) instead?
19:41:16 <mseeks> dmj`: yeah, i considered that but was reluctant to restructure without seeing if there was STM-friendly persistence
19:42:00 <nurupo> i could get a list of all tuples with w==x using, but how do i get a tuple with maximum u
19:42:06 <nurupo> s/using//
19:42:58 <monochrom> "maximumBy" may be useful
19:43:12 <mseeks> nurupo: maximumBy (comparing snd)
19:43:36 <monochrom> unless you want to write your own recursion, which is also instructive if you want
19:44:07 <mseeks> maybe `maximumBy (comparing snd) . filter ((== x) . fst)`
19:44:36 <nurupo> nice
19:45:24 <nurupo> then, what if i don't want the tuple, but just its index in the "list@"?
19:45:41 <jle`> time for a huge refactoring that only ghc can give me the confidence to do
19:45:51 <nurupo> i guess i could write a recursive function for that then
19:46:05 <dmj`> mseeks: acid-state uses stm when it writes the transaction log to disk, and when using the remote module. 
19:47:12 <scott> nurupo: you could zip the list with [0..] (and do `comparing (snd . snd)` to compensate). the the result will have the index as well
19:47:39 <scott> you'd have to adjust the filter too
19:48:14 <dmj`> mseeks: why not just use one remote acid-state?
19:48:37 <dmj`> mseeks: put both lists in there
19:48:54 <mseeks> dmj`: yeah, that's probably the best way to do it
19:55:33 <gcganley> is there a "POSIX network programming for OK high level programmers but (for now) shitty low level programmers" book anywhere?
19:55:58 <gcganley> i just want the concepts of how sockets and threads work at the OS level
19:56:05 <geekosaur> W. Richard Stevens, UNIX Network Programming?
19:56:54 <gcganley> geekosaur: is that book aimed at beginers or intermediate programmers?
19:57:33 <geekosaur> intermediate; it's assumed you know general programming and want to learn sockets
19:58:09 <gcganley> geekosaur: any sugestion about threads?
19:58:18 <gcganley> im looking for a firm grasp on low level concepts
20:00:45 <geekosaur> 2nd or later edition of his (with additional authors because he died partway through writing 2nd edition) _Advanced Programming in the Unix Environment_
20:01:06 <geekosaur> Stevens is pretty much the Bible on Unix/POSIX
20:01:46 <gcganley> geekosaur: so his full name should be "Stevens, Blessed be his name"
20:02:03 <geekosaur> APUE picks up where _The Unix Programming Environment_ (aka K&P) left off; that was for beginners and taught shell scripting and basic C programming
20:02:23 <geekosaur> pretty much. cf. http://www.salon.com/2000/09/01/rich_stevens/
20:03:36 <gcganley> geekosaur: I work on Cisco routers and switches and i play in haskell im just trying to marry those two fields. im making a DHCP server to start because it didnt seem that hard
20:04:05 <geekosaur> DHCP's relatively easy until you get to things like dynamic updates, yeh
20:04:32 <geekosaur> although much of the complication there is more in DNS than DHCP, there's iirc some interplay
20:04:46 * geekosaur is less a network geek than a general sysadmin
20:05:55 <gcganley> geekosaur: I know how to run the services and how they work in general but i want to be able to make them to gain a deeper respect for them
20:06:00 <gcganley> if you know what i mean
20:06:48 <geekosaur> sure. I suspect implementing DHCP may get interesting though, since it involves broadcast packets
20:12:32 <gcganley> geekosaur: we had a big argument in shop over whether or not that Request (R in DORA) packet was broadcast or unicast. we found out it was actually broadcast
20:13:26 <geekosaur> it varies actually. IIRC unix broadcasts, (maybe only some versions) AD unicasts?
20:13:47 <geekosaur> one of the ocmplications in a real world DHCP implementation
20:14:40 <gcganley> when i see AD i think Admin Distance what does it mean in this sense?
20:14:42 <danclien> Any one have any ideas why `runhaskell -package-db .cabal-sandbox/*-packages.conf.d test.hs` would fail with `Not in scope: ‘main’`?
20:14:48 <geekosaur> ...and that is one thing you'll definitely learn by rolling your own
20:14:53 <geekosaur> Active Directory
20:14:56 <geekosaur> aka Windows servers
20:15:04 <gcganley> geekosaur: ok, i see
20:15:05 <danclien> Works fine without specifying -package-db.
20:15:22 <gcganley> geekosaur: do they just use a WINS address?
20:16:03 <geekosaur> because there's what the spec says and there's what actual implementations do, including various things like managed routers/switches that have their own TCP/IP stacks that aren't always sensible
20:16:33 * hackagebot htsn-import 0.2.3 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.2.3 (MichaelOrlitzky)
20:17:01 <geekosaur> hm? they hand out IP addresses, optionally hostnames which may vary (I don't know details offhand for what's in a DHCP response from a domain controller)
20:18:10 <gcganley> geekosaur: since when have DHCP servers handed out hostnames?
20:18:29 <geekosaur> WINS isn't an address, it's basically Microsoft's implementation of zeroconf (avahi/Bonjour)
20:18:36 <wcaleb> any ideas about a straightforward way to create a pager clone (like more/less) in IO so that output to the terminal that exceeds terminal height can be paged?
20:18:38 <geekosaur> hostname is an optional part of the response
20:19:31 <geekosaur> http://www.networksorcery.com/enp/protocol/bootp/options.htm see option 12
20:20:29 <glguy> wcaleb: The easiest way I know would be to write it using the vty package
20:20:45 <gcganley> geekosaur: never heard of BOOTP :/
20:21:55 <geekosaur> it's an older protocol that served a similar purpose. old Unix workstations could use bootp+tftp to boot over the network
20:22:18 <geekosaur> or just bootp to get basic network information including getting assigned an IP address
20:23:17 <geekosaur> (except Suns which used an RPC service bootparamd)
20:23:42 <geekosaur> (and reverse arp to get an address)
20:23:58 <glguy> I remember having to relink a SCO kernel to change its IP address
20:27:41 <geekosaur> wcaleb: use terminfo to get the terminal width/height
20:31:33 * hackagebot semigroups 0.16.2.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.2.1 (EdwardKmett)
20:32:27 <geekosaur> oh, feh, the terminal ioctl module in the unix package doesn't support the size entries
20:32:34 <gcganley> > SockAddrInet 547 323223577
20:32:36 <lambdabot>  Not in scope: data constructor ‘SockAddrInet’
20:33:16 <geekosaur> you might be better off capturing the output of `tput lines` and `tput cols`
20:33:32 <gcganley> can anyone help me out? when i run "SockAddrInet 547 323223577" i get the ip in reverse
20:33:46 <wcaleb> geekosaur: thanks
20:33:52 <wcaleb> glguy: thanks for the tips
20:34:05 <geekosaur> gcganley, sounds right to me? it's in network byte order
20:34:28 <gcganley> geekosaur: network byteorder?
20:34:31 <gcganley> whats that
20:34:33 <geekosaur> most of the constructors in Network shouldn't be used directly unless you know what you are doing
20:34:55 <gcganley> geekosaur: what should i be doing?
20:34:56 <geekosaur> `man ntohl`
20:36:07 <gcganley> geekosaur: interesting...
20:36:25 <gcganley> still, what should i be doing instead of messing with Constructors
20:37:15 <glguy> You should be using getAddrInfo
20:37:28 <geekosaur> as glguy says
20:38:03 <geekosaur> in general you should not be making addresses or ports by hand if you can help it, getAddrInfo can take human-understandable representations and return the right information
20:38:53 <geekosaur> meanwhile HostAddress unlike PortNumber does not have the weird*ss Num instance that confuses everyone with its network byte order magic
20:39:07 <geekosaur> it just documents that it should be in network byte order
20:39:31 <geekosaur> (and then HostAddress6 says it's in *host* byte order, consistency, who needs it?)
20:41:09 * geekosaur needs to knock off for the night...
20:41:27 <gcganley> geekosaur: good night sweet prince
20:48:53 <ultra_Sabreman> Is there any easy console library i can use on windows
20:49:02 <ultra_Sabreman> that would allow me to get raw user input?
20:49:15 <ultra_Sabreman> Because for some reason, I can't get ncurses or hscurses to install
20:49:50 <ultra_Sabreman> normal io doesn't do raw input 
20:51:04 <Axman6> what do you mean by 'raw input'?
20:51:23 <Axman6> you can't work with bytestrings on the stdin handle?
20:56:37 <sellout> dibblego: Ah, perfect. Thanks!
20:57:54 <wcaleb> i'm working on a haskell clone of urlview that reproduces context for links, suitable for use in Mutt; welcome code review, tips because I'm still pretty green https://github.com/wcaleb/muttells/blob/master/hurlview.hs
20:58:34 <Axman6> wcaleb: sp n = concat $ replicate n " " === repeat ' '
20:58:39 <ultra_Sabreman> Axman6: i mean I want to only "Read in" one key press at a time
20:58:40 <Axman6> wcaleb: sp n = concat $ replicate n " " === repeat n ' '
20:58:42 <Axman6> I think
20:58:43 <ultra_Sabreman> like up arrow
20:58:45 <ultra_Sabreman> or enter
20:58:46 <Axman6> something like that anyway
20:59:25 <wcaleb> Axman6: i think i used repeat initially and HLint suggested replicate
20:59:52 <Axman6> @check \n -> replicate n ' ' == (concat $ replicate n " ")
20:59:53 <lambdabot>  +++ OK, passed 100 tests.
20:59:55 <wcaleb> Axman6: I think I had take n $ repeat " "
21:01:12 <ultra_Sabreman> Is there any way to do that though? Take only ONE raw button press as input?
21:01:15 <wcaleb> trying to concat n number of spaces
21:01:16 <ultra_Sabreman> without external libraryes?
21:01:42 <Axman6> right, you only need replicate n ' '
21:02:07 <Axman6> replicate n x = take n $ repeat x -- btw
21:03:30 <jle`> ultra_Sabreman: you can set your buffering settings
21:03:31 <wcaleb> Axman6: Right, but both of those return lists, and I in fact want to concatenate n spaces
21:04:05 <jle`> ultra_Sabreman: also why not `getCar` ?
21:04:11 <jle`> getChar
21:04:14 <jle`> is that not what you want?
21:04:14 <Axman6> wcaleb: that's what a string is...
21:04:17 <Axman6> :t String
21:04:18 <lambdabot> Not in scope: data constructor ‘String’
21:04:19 <Axman6> uh
21:04:23 <Axman6> @src String
21:04:23 <lambdabot> type String = [Char]
21:04:41 <Axman6> > replicate 10 ' '
21:04:42 <lambdabot>  "          "
21:04:53 <jle`> > ['a','b','c']
21:04:54 <lambdabot>  "abc"
21:05:38 <ultra_Sabreman> jle`: because getChar requires you to press enter
21:05:52 <ultra_Sabreman> I need it to return on any keypress
21:05:53 <Axman6> ultra_Sabreman: you need to turn off line buffering on stdin
21:06:00 <glguy> not if you turn off buffering
21:06:01 <ultra_Sabreman> Axman6: how?
21:06:19 <Axman6> @gogole hSetBuffering
21:06:19 <lambdabot> https://www.haskell.org/hoogle/?hoogle=hSetBuffering
21:06:26 <Rotaerk> > replicate 5 (replicate 5) <$> replicate 5
21:06:27 <lambdabot>  Couldn't match expected type ‘[a] -> b’
21:06:27 <lambdabot>              with actual type ‘[a0 -> [a0]]’
21:06:35 * hackagebot free 4.11 - Monads for free  http://hackage.haskell.org/package/free-4.11 (EdwardKmett)
21:06:38 <Rotaerk> > replicate 5 (replicate 5) <$> replicate 5 (replicate 5)
21:06:39 <lambdabot>  Couldn't match expected type ‘(a1 -> [a1]) -> b’
21:06:39 <lambdabot>              with actual type ‘[a0 -> [a0]]’
21:07:01 <jle`> Rotaerk: anything in particular you're trying to do?
21:07:04 <Rotaerk> nah
21:07:08 <Axman6> wcaleb: what is your code actually supposed to be doing?
21:07:22 <glguy> you can play with lambdabot in /query
21:07:46 <wcaleb> Axman: look at lines 37 and 38, it's inserting some strings of spaces to create a margin
21:08:24 <wcaleb> Axman: program as a whole takes stdin, looks for lines with URLs, numbers those lines in output, allows user to choose one to open
21:08:28 <jle`> Rotaerk: you can try out lambdabot in private pm, if you want
21:08:29 <Axman6> wcaleb: I meant the whole code. I haven't used mutt so have no idea what the thing you made analogy to is
21:08:32 <wcaleb> Axman: like urlview, but with context
21:09:39 <wcaleb> Axman: usage in Mutt is to pipe a plain text email message to urlview so that you can open selected url with keystroke
21:10:18 <Axman6> right, I have no idea what urlview is. but anyway, it appears like quite a brittle way to do what you're after; you should probably be trying to use some kind of parser to find the URLs
21:11:16 <Axman6> tty <- openFile "/dev/tty" ReadMode seems like a pretty hacky to do what you're doing... but I guess it makes sense
21:11:38 <ultra_Sabreman> Axman6: ok cool, but how do i get the handle to the stdin
21:11:54 <wcaleb> Axman6: yes, probably … still learning
21:11:55 <ultra_Sabreman> can't find anything in .io to get one
21:12:04 <Axman6> ultra_Sabreman: you use `stdin` =)
21:12:07 <Axman6> :t stdin
21:12:08 <lambdabot> Not in scope: ‘stdin’
21:12:11 <Axman6> bleh
21:12:14 <Axman6> @hoogle stdin
21:12:15 <lambdabot> System.IO stdin :: Handle
21:12:15 <lambdabot> GHC.IO.Handle.FD stdin :: Handle
21:12:16 <lambdabot> System.Posix.IO.ByteString stdInput :: Fd
21:12:32 <Axman6> you want something like hSetBuffering NoBuffering stdin
21:19:45 <ultra_Sabreman> Axman6: setting buffering to NoBuffering still requires you to press enter
21:19:49 <ultra_Sabreman> when using getChar
21:19:50 <ultra_Sabreman> :/
21:21:16 <jle`> does anyone know of a good reason why you shouldn't always ~(x,y) when matching on tuples
21:22:19 <Axman6> it makes your code look like there's little sperm cells all over it?
21:22:30 <ultra_Sabreman> Axman6: since when is that a bad thing :p
21:22:51 <Axman6> in some places it's frowned upon
21:23:28 <dolio> jle`: Sometimes that will result in bad performance.
21:26:40 <unknownloner> What should I use instead of 'nub' when I know that all duplicate elements will be next to eachother in the list
21:27:17 <unknownloner> example:  [1,1,1,4,4,3,3,3] -> [1,4,3]
21:27:34 <Axman6> > map head . group $ [1,1,1,4,4,3,3,3]
21:27:35 <lambdabot>  [1,4,3]
21:27:41 <Axman6> :t group
21:27:42 <lambdabot> Eq a => [a] -> [[a]]
21:29:23 <unknownloner> thanks
21:31:19 <heatsink> jle`: I'd say you should only use lazy patterns when bottom values are possible in non-error situations, which isn't often.
21:32:23 <dolio> That's not really the right answer, I think.
21:32:58 <dolio> The thing is that thinking about bottoms tells you about performance of non-bottom cases.
21:33:25 <kaidelong> oh it does? by showing how much work can be avoided?
21:33:43 <dolio> Yes. Or what order the work will happen in.
21:34:31 <dolio> So there's no universally applicable rule.
21:46:37 * hackagebot persona-idp 0.1.0.2 - Persona (BrowserID) Identity Provider  http://hackage.haskell.org/package/persona-idp-0.1.0.2 (frasertweedale)
21:57:37 <Lokathor> i wrote my first fmap
21:57:38 <Lokathor> wheee
21:58:01 * neuroserpens lights up a firecracker
21:58:11 <neuroserpens> *a very small one*
21:58:41 * neuroserpens gives Lokathor a party hat
21:58:53 <neuroserpens> Here... Have a piece of cake
21:58:59 <neuroserpens> The cake is a lie though.
21:59:02 <sw3bmasterscrubl> hi. first time here
21:59:04 <Lokathor> my neighbor was holding too many fire works at once one time
21:59:08 <Lokathor> and set off all the firecrackers in his lap
21:59:10 <sw3bmasterscrubl> back on irc after 12 years
22:01:09 <sw3bmasterscrubl> looking for the best way to learn haskell. reference, im ok in python and knew c++ years go. i want to learn functional, the right way
22:01:43 <Lokathor> start here, http://www.seas.upenn.edu/~cis194/spring13/lectures.html
22:01:58 <Lokathor> each lesson will also direct you to read part of another site called Learn You A Haskell
22:02:30 <Lokathor> be sure to do the homework exercises. do lots of exercizes all the time in fact
22:02:38 <jle`> dolio: how can i know when it will be bad performance.  it's not really deferring anything through laziness because i use the x and y immediately in the actual branch body
22:02:42 <sw3bmasterscrubl> oh awesome. a friend told me about learn you a haskell but it looked more like just a textbook
22:02:55 <jle`> the only thing the ~ is deferring is the resolution of the (,) constructor
22:03:03 <jle`> ...but the fields of a tuple are lazy anyway...
22:03:14 <Lokathor> yeah LYAH is more like a huge reference tome that shows up in google searches a lot
22:03:16 <sw3bmasterscrubl> Lokathor: thanks
22:03:19 <Lokathor> but is very poor on exercises
22:03:28 <Lokathor> which is why the cis194 homeworks are key
22:03:57 <Lokathor> sw3bmasterscrubl, are you on windows, mac, or linux?
22:04:01 <sw3bmasterscrubl> yeah. being new to funcitonal, it was hard to get my head into thinking functionally without doing it. if you know what i mean
22:04:02 <sw3bmasterscrubl> mac
22:04:30 <Lokathor> hmm, don't have a mac, so i don't really have any special extra advice there
22:06:30 <sw3bmasterscrubl> whats a good kind of first kind of project to shoot for with haskell? 
22:07:09 <Axman6> I would start with the lectures above before trying to write something; you'll find there's a lot you need to learn before you do anything useful
22:07:13 <johnw> sw3bmasterscrubl: something that has a feature you personally want
22:07:27 <johnw> i started with reimplementing tools I had written in Python
22:07:38 <Axman6> and you might get inspiration along the way for something you want to write
22:08:01 <shelf> IRC bot was a fun early project for me, also small compilers/interpreters
22:08:35 <ultra_Sabreman> YEah so
22:08:43 <ultra_Sabreman> i messed asround with the buffering some more
22:08:45 <ultra_Sabreman> and that wont work
22:08:53 <pharaun> i like ircbot for early projects
22:08:57 <ultra_Sabreman> You still need to press enter when doing input
22:08:59 <pharaun> theyre great, network, etc, etc
22:09:02 <ultra_Sabreman> does anyone have any other ideas?
22:09:32 <Lutin`> and they're really fun as NLP testbeds :)
22:09:44 <pharaun> ircbot?
22:09:54 <pharaun> yeah i'm probably going to be playing with a NLP stuff sooner or later on my bot
22:09:54 <Lokathor> sw3bmasterscrubl, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours guides you through a simplified scheme interpreter, but it's largely for after you've done some lessons
22:10:19 <pharaun> i also learned how haskell ffi worked via integrating a markov chain in c into haskell
22:11:11 <jle`> command line hangman is fun
22:11:43 <glguy> ultra_Sabreman: Put what you tried on the pastebin
22:11:45 <glguy> ?where lpaste
22:11:45 <lambdabot> http://lpaste.net/
22:12:25 <Lokathor> jle`, i once saw a haskell blog post about a hangman implementation involving [Maybe Char] and mappend and stuff, it was pretty cool
22:12:38 <sw3bmasterscrubl> yes, i plan to finish exercises first. but i like having something personal to work up to
22:12:56 <jle`> the nice thinkg about command line hangman is that there are many many approaches
22:13:07 <jle`> and every week or month in your haskell learning adventure you can try implementing it again
22:13:12 <jle`> and you might have a completely new method to use
22:13:30 <sw3bmasterscrubl> lokathor: ive looked at scheme before. it was cool but i didnt know if i wanted to spend time learning lisp
22:14:37 <Axman6> don't, just write an interpteter for it =)
22:14:44 <Lokathor> sw3bmasterscrubl, well, scheme is pretty simple. The basics of scheme can fit on a single page of paper, and from there it's just library calls and special forms, each of which are explained in the tutorial as it goes
22:16:39 * hackagebot influxdb 0.9.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.1 (MitsutoshiAoe)
22:23:44 <ultra_Sabreman> glguy: nevermind. It turns out there's a bug with NoBuffer and windows
22:23:50 <ultra_Sabreman> because of how it reads files
22:23:53 <ultra_Sabreman> and stuff
22:24:11 <ultra_Sabreman> so i've migrated to 
22:24:20 <ultra_Sabreman> haskeline
22:30:34 <Lokathor> > Illegal literal in type (use DataKinds to enable): 2
22:30:35 <lambdabot>  <hint>:1:17: parse error on input ‘in’
22:30:58 <Lokathor> is there some common typo that causes such an error?
22:31:37 <Lokathor> I'm looking at Exercise 3 of http://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf
22:32:33 <Lokathor> they say to test out your typeclass and instance definition using: mul (add (lit 2) (lit 3)) (lit 4) :: ExprT == Mul (Add (Lit 2) (Lit 3)) (Lit 4)
22:32:51 <Lokathor> but then i get an illegal literal error
22:35:47 <jle`> Lokathor: if you put a number in a type
22:36:00 <jle`> and...it looks like you did
22:36:19 <Lokathor> yes, the typeclass uses Integer
22:37:02 <jle`> what page is this on?
22:37:10 <Lokathor> top of page 3
22:37:19 <jle`> oh, those are two different lines
22:37:40 <jle`> mul (add (lit 2) (lit 3)) (lit 4) :: ExprT
22:37:45 <jle`> it wants you to see if *that*
22:37:58 <Lokathor> ah, you're not intended to execute the line? I thought it was wrapped just because it was a long line
22:37:58 <jle`> is equal to Mul (Add (Lit 2) (Lit 3) (Lit 4) :: ExprT
22:38:16 <jle`> yeah it's a bit of an abuse of notation
22:38:25 <jle`> the line could technically be executed if you put the first line in parentheses
22:38:45 <Lokathor> oh i see
22:46:40 * hackagebot ascii-progress 0.2.0.0 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.2.0.0 (yamadapc)
23:20:10 <nurupo> how to pattern match -1 argument?
23:20:44 <nurupo> it treats - as an unary operator
23:21:37 <Hijiri> you could do fun n = | n == -1 = something | otherwise = somethingelse
23:21:52 <Hijiri> I mean fun n | n == ...
23:22:02 <mauke> > (\(-1) -> "?") (-1)
23:22:04 <lambdabot>  "?"
23:22:14 <dmj`> > case (-1) of { (-1) -> True; otherwise -> False }
23:22:15 <lambdabot>  True
23:22:28 <reactormonk> if you have a typeclass that requires Show and Read, if you have Show, can you recover Read?
23:22:58 <nurupo> dmj`: thanks, parenth helped :)
23:23:08 <nurupo> *parens
23:23:19 <dmj`> nurupo: np ! 
23:28:37 <apricity> can you program gpu cores using haskell?
23:31:43 * hackagebot semigroups 0.16.2.2 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.2.2 (EdwardKmett)
23:32:07 <dmj`> apricity: http://hackage.haskell.org/package/accelerate
23:34:06 <dmj`> apricity: http://www.cse.unsw.edu.au/~chak/papers/CKLM+11.html
23:34:28 <apricity> thanks checking it out
23:56:45 * hackagebot integration 0.2.1 - Fast robust numeric integration via tanh-sinh quadrature  http://hackage.haskell.org/package/integration-0.2.1 (EdwardKmett)
