00:09:30 * hackagebot semigroups 0.16.2.2 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.2.2 (EdwardKmett)
00:09:30 * hackagebot integration 0.2.1 - Fast robust numeric integration via tanh-sinh quadrature  http://hackage.haskell.org/package/integration-0.2.1 (EdwardKmett)
00:14:25 * hackagebot language-python 0.5.0 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.5.0 (BerniePope)
00:19:25 * hackagebot fixed 0.2.1.1 - Signed 15.16 precision fixed point arithmetic  http://hackage.haskell.org/package/fixed-0.2.1.1 (EdwardKmett)
00:35:46 <hibou_> hi
00:35:57 <hibou_> are there any exemple for using this (RandomGen g, Random a, Floating a) => g -> (a, g)
00:35:59 <hibou_> ?
00:36:08 <hibou_> what does the "=>" means ?
00:40:37 <Yuras> hibou_: it is a list of constraints
00:41:22 <Yuras> hibou_: e.g. `a` is not an arbitrary type, but an instance of `Floating` type class -- `Float`, `Double` etc
00:42:42 <JaAnTr> Hi, I'm trying to implement a mini imperative programming language in Haskell, specifically implementing increment and decrement functionality. I've done some of it but am having a few issues and was hoping someone could have a quick look at the code and give me a hand. http://pastebin.com/0genrWQk
00:42:49 <hibou_> ah thanks Yuras:
00:43:12 <hibou_> it's just a function that takes g and return (a, g) with type constraints
00:43:45 <pavonia> What extension do you need to define a type like "type Parser = Parsec String u"?
00:44:54 <Yuras> pavonia: RankNTypes?
00:45:11 <pavonia> Let me try ...
00:46:54 <pavonia> Yuras: Okay thanks, "type Parser a = forall u . Parsec String u a" works with RankNTypes
00:53:13 <pavonia> JaAnTr: You're not returning a pair in your evalA function
00:53:38 <pavonia> but your type signature says so
00:54:23 <JaAnTr> pavonia: Ah yes, the evalA function was from some past code that i've been given whereas the type signature is new so I need to modify the evalA function then?
00:55:16 <pavonia> Yes
01:07:13 <JaAnTr> pavonia: Is this one correct - evalA (Num n) s   = s n ?
01:08:21 <pavonia> "s n" means apply function s to value n. A pair in Haskell is denoted by "(x, y)"
01:09:27 * hackagebot language-python-test 0.5.0 - testing code for the language-python library  http://hackage.haskell.org/package/language-python-test-0.5.0 (BerniePope)
01:10:59 <JaAnTr> pavonia: Ok, so it would be evalA (Num n) s   = (s, n) ?
01:11:26 <pavonia> Yep
01:39:29 * hackagebot configifier 0.0.2 - parser for config files, shell variables, command line args.  http://hackage.haskell.org/package/configifier-0.0.2 (MatthiasFischmann)
01:49:38 <zipper> How to convert an Int to a String? Basically how to wrap an Int in double quotes.
01:49:50 <JaAnTr> pavonia: I'm struggling with the rest of the evalA functions, like this one evalA (a :+: b) s = evalA a s + evalA b s, can you explain how to return both state and integer?
01:52:20 <jle`> zipper: you can turn an Int into its string representation with `show`
01:52:30 <jle`> but that just gives you the Int as a string
01:52:39 <jle`> you can add double quotes by concatenating strings together if that's what you want
01:52:58 <jle`> like "\"" ++ show n ++ "\""
01:53:15 <jle`> JaAnTr: you can use `let` bindings
01:53:20 <zipper> jle`: LOL why didn'y I think of that?
01:53:23 <jle`> let ... = ... in ...
01:53:29 <zipper> jle`: :D thanks
01:53:32 <jle`> np :)
01:54:08 <JaAnTr> jle: I'm not sure I undestand, why do i need to use let?
01:54:54 <jle`> JaAnTr: let (s1, n1) = evalA a s; ...
01:54:57 <jle`> so you can use the sate later
01:55:04 <jle`> i'm not 100% sure what your types are, sorry
01:55:46 <jle`> oh i see it now
01:56:24 <jle`> let (s1, n1) = evalA a s; (s2, n2) = evalA b s in (new state, new number)
01:56:35 <jle`> hm
01:56:51 <jle`> or, if you wanted to have the state after the first addition be used in the second addition, you can say `evalA b s1` instead
01:57:04 <pavonia> JaAnTr: Do you actually need that state? It seems none of your branches modifes it
01:57:57 <jle`> evalA (a :+: b) s0 = let (s1, na) = evalA a s0; (s2, nb) = evalA b s1 in (s2, na + nb)
01:58:28 <jle`> the initial state gets used in evaluating `a`, the resulting state gets used in evaluating `b`, and the final state is the resulting state of that.
01:58:36 <jle`> and you add the Integer results together
01:59:18 <jle`> i wonder if there is a way to abstract out this manual state threading...
01:59:24 <jle`> . o O ( in a world... )
02:06:37 <JaAnTr> jle: Thanks! So does this look right so far, obviously I need to do the increment and decrement still http://pastebin.com/1auBayq0
02:07:12 <jle`> JaAnTr: it looks good, but i suggest you ask ghc and the typechecker :)
02:07:23 <jle`> btw, you can leave a "blank" in your code and see if it compiles with `undefined`
02:07:47 <Cale> JaAnTr: I think you need to do something more for the variable case
02:08:06 <Cale> JaAnTr: In particular, you probably want to look up the present value of the variable in the state.
02:09:06 <jle`> yeah...it also doesn't typecheck, unless Variable is a type alias for Integer
02:09:20 <JaAnTr> I tried to compile it and got lots of errors.
02:09:42 <jle`> in haskell we like to do type-checker-driven/hole-driven development.  leave a lot of `undefined` holes and just fill things in, knowing the types...and whenevery ou try to fill something new in, run the typechecker on it :)
02:09:53 <jle`> if you typecheck everythinga s you go along then things go pretty smoothly
02:10:01 <jle`> it's almost as if the compiler writes your code for you :)
02:10:25 <JaAnTr> How do I type check, just compile it and read the errors?
02:10:37 <jle`> mhm
02:10:46 <jle`> or sometimes text editors/IDE's do it for you
02:10:56 <jle`> whenever you save, it'll highlight on your screen where the type errors are
02:11:26 <JaAnTr> what texteditors/IDE's do that? I'm just using sublime text which doesn't seem to do it.
02:11:37 <jle`> well, you'll have to install a plugin depending on your editor, heh
02:11:51 <jle`> i'm sure there are some ghc-mod plugins available for sublime, a lot of people here seem to use it :)
02:15:02 <bbri06> Hey everyone. I've got a bit of a nooby question. If I'm following a tutorial, and I know I need to import say "Text.Templating.Heist" but I need to install the package first because I don't yet have it, what's the easiest way to find the name of the package? Essentially I'm not sure what to use for "cabal install [name?]".
02:15:31 <jle`> bbri06: my go-to is hoogle
02:15:37 <jle`> @hoogle Text.Templating.Heist
02:15:41 <lambdabot> package heist
02:15:41 <lambdabot> package heist-aeson
02:15:41 <lambdabot> package heist-async
02:15:55 <jle`> it's also online too if you google hoogle...the results ar emuch more detailed/meaningful and have links to the docs
02:16:02 <jle`> you can also install hoogle locally and search on a local index :)
02:16:32 <jle`> a lot of people just hook it onto their ghci and you can run it right there on the REPL
02:16:45 <bbri06> Ah, I see thanks. I'll take a look :)
02:16:52 <jle`> happy haskelling!
02:26:22 <sternenseemann> what is recommendable for configuration
02:26:29 <sternenseemann> as in what package to use
02:26:37 <sternenseemann> I have looked at htoml
02:26:42 <sternenseemann> but it uses Text
02:27:11 <sternenseemann> I have not yet found a convenient way to use Text
02:27:22 <sternenseemann> this qualified stuff is just annoying :/
02:27:38 <Cale> import qualified Data.Text as T
02:27:42 <Cale> import Data.Text (Text)
02:28:16 <sternenseemann> Cale: it is possible to import a package qualified and unqualified at the same time? :O
02:28:19 <Cale> yes
02:28:20 <sternenseemann> nice
02:28:35 <Cale> You'll generally want to do something similar for Data.Set and Data.Map
02:28:42 <Cale> and a lot of packages like that
02:32:05 <sternenseemann> I currently don't need to much from Data.Map
02:32:18 <sternenseemann> import Data.Map (Map (), fromList, lookup)
02:32:31 <sternenseemann> import Prelude hiding (lookup)
02:32:51 <Cale> I usually just do
02:32:56 <Cale> import qualified Data.Map as M
02:33:06 <Cale> import Data.Map (Map)
02:33:39 <Cale> and then I don't have to import the Prelude explicitly hiding stuff
02:33:46 <gfixler> I like to do import qualified Data.Map as M, and then fix lookup to M.lookup, fromList to M.fromList, etc over and over
02:34:23 <Cale> Especially if you'
02:34:30 <Cale> you're working with both maps and sets
02:34:44 <Cale> It's nice to be able to distinguish S.fromList and M.fromList
02:34:48 <gfixler> is Vector only for numbers?
02:34:52 <Cale> no
02:34:54 <Keiya> Sigh... I can't get as into haskell as my beloved. It doesn't help that I was interrupted by having to learn a new text editor because the developer of my previous one went completely insane and now everything is like "argh I know this" or "argh I forgot all this" >_>
02:35:00 <gfixler> can I have vectors of ADTs?
02:35:03 <Cale> yes
02:35:14 <Cale> Vector is just another array library
02:35:31 <gfixler> what other array libraries are there?
02:35:31 <Cale> It's slightly unfortunately named, I suppose.
02:35:57 <Cale> Data.Array.*
02:36:11 <Cale> i.e. the array package
02:36:11 <sternenseemann> I suppose I really want to use Text?
02:36:25 <Cale> sternenseemann: It doesn't hurt
02:36:27 <gfixler> wow, 14 array libraries
02:36:30 <sternenseemann> ++ looks so much nicer than `T.append`
02:36:32 <sternenseemann> etc.
02:36:58 <sternenseemann> Is there a usable String typeclass already? :D
02:37:08 <gfixler> let (++) = T.append in <rest of the module>
02:37:10 <Cale> sternenseemann: If you have a bunch of things to append, T.concat [...] isn't too bad
02:37:21 <sternenseemann> Cale: thanks!
02:38:23 <gfixler> import Data.Text (append as (++))?
02:38:40 <Cale> gfixler: I'm not sure that's valid...
02:38:49 <Cale> Would be a cute feature
02:38:52 <gfixler> why won't haskell dwim?
02:39:13 <gfixler> I also want [(*2),1..]
02:39:19 <sternenseemann> gfixler: would be cool
02:39:46 <Cale> But yeah, if you don't care too much about performance of string processing, you might just get away with using String. The thing is, if you're using the JSON library aeson, it uses Text, because there are users who care about performance there.
02:40:11 <Cale> and that configuration library you mentioned uses aeson
02:41:36 <Cale> If you're just writing something quick, you can even just use Read/Show instances to save configuration to a file.
02:41:58 <gfixler> can I have arrays of functions?
02:42:07 <Cale> Yes
02:42:23 <gfixler> don't arrays need fixed-size elements?
02:42:52 <Cale> Most Haskell values are represented by pointers to code
02:42:58 <Cale> which are conveniently all the same size
02:43:04 <gfixler> cool
02:43:36 <Cale> If you want to use unboxed arrays, which have a compact representation in memory, then you can't make an array of functions
02:43:57 <mniip> don't unboxed arrays only store unboxed values?
02:43:59 <gfixler> that was my next question
02:44:03 <Cale> that's right
02:44:25 <gfixler> are unboxed arrays still immutable?
02:44:49 <Cale> There are both mutable and immutable versions of unboxed arrays
02:44:57 <Cale> They're separate data types
02:45:07 <gfixler> I'm very curious about unboxed immutability
02:45:12 <Cale> as well as mutable and immutable versions of boxed arrays
02:45:44 <kaidelong> unboxed immutable arrays are somewhat pointless, though
02:46:02 <Cale> what?
02:46:05 <Cale> No!
02:46:09 <kaidelong> Cale: really?
02:46:11 <gfixler> ¿Qué?
02:46:25 <kaidelong> what would they be used for? When you have to pass flat, fully evaluated data?
02:46:45 <kaidelong> what I'm wondering is where unboxed array is better than unboxed tuple
02:47:01 <Cale> Well, when you have more than about 2 values
02:47:06 <gfixler> I don't think of tuples as holding tons of values
02:47:22 <gfixler> but I would like arrays to do this
02:47:35 <Cale> If tuples are ever any larger than pairs, you're usually better off with something else.
02:47:49 <kaidelong> alright, I guess I can accept that, you can use unboxed immutable arrays kind of like tuples
02:48:07 <kaidelong> I guess they're variable in their length too, potentially
02:48:10 <Cale> Like, puzzle solvers might use unboxed immutable arrays to represent board states.
02:48:18 <gfixler> when I think of unboxed, I think of raw speed - is this a decent intuition?
02:48:39 <kaidelong> Cale: why unboxed rather than boxed? Doesn't unboxed mean you get no sharing or lazy evaluation?
02:48:47 <Cale> Well, depends on what you're doing with them, but they are pretty fast in a lot of cases.
02:48:59 <gfixler> is there a reason to go unboxed that doesn't have to do with speed?
02:49:09 <Cale> kaidelong: Well, depending on what your boards look like, you may get to real benefit from sharing.
02:49:11 <Cale> no*
02:49:11 <gfixler> (my grokking of unboxed values is in its early stages)
02:49:15 <kaidelong> unboxed gives you "bottom-less" values
02:49:21 <Cale> kaidelong: Arrays are pretty flat structures already
02:49:49 <Cale> kaidelong: If you do an update to an array, evaluating the update will require O(array size) space anyway
02:50:11 <kaidelong> really? Data.Vector doesn't support O(n) mutation?
02:50:12 <kaidelong> err
02:50:14 <kaidelong> O(1)
02:50:21 <Cale> The cool thing about boxed arrays is that you can define their elements recursively in terms of the other elements of that same boxed array
02:50:36 <kaidelong> or in terms of elements of other boxed arrays
02:50:37 <Cale> kaidelong: We're talking about immutable arrays aren't we?
02:50:56 <kaidelong> Cale: well I thought you were meaning that if it were mutable it'll still be O(n) so there's no advantage in the mutable case
02:51:03 <indiagreen> kaidelong: immutable Vector still supports O(1) mutation if it can detect you're only using one copy of the array
02:51:06 <Cale> oh, no
02:51:09 <indiagreen> when you use “modify”
02:51:32 <Cale> I always feel a bit awkward calling array indexing O(1)
02:51:45 <Cale> Everyone does it, but it's clearly not true.
02:52:04 <gfixler> Cale: it's not arraystart + cellwidth * index?
02:52:14 <kaidelong> well I guess if we consider the limitations of memory look up on real machines it's technically O(log n)
02:52:23 <seafood> Anyone got experience here using the -staticlib flag? Why are the resulting .a files so large?
02:52:29 <Cale> No function whose range has n elements can be computed in less than O(log n) time.
02:52:50 <kaidelong> people use O(1) because it really is O(1) at their level of abstraction
02:53:16 <kaidelong> I guess it's not quite correct, but it's "correct enough"
02:53:27 <gfixler> I thought machines could jump a pointer in one operation
02:53:43 <Cale> gfixler: The problem is with the asymptotics.
02:54:00 <Cale> gfixler: You can't assume you have a bounded amount of memory, or else *every* operation is O(1).
02:54:03 <kaidelong> gfixler: the time accessing main memory takes increases the more memory you have
02:54:15 <kaidelong> this is actually a pretty severe limitation in building supercomputers
02:54:23 <kaidelong> which is why things like NUMA exist
02:55:04 <kaidelong> from the programmer's point of view it still looks like it is constant though
02:55:10 <Cale> Yeah, assuming that pointers have a fixed size is a poor assumption when trying to do asymptotic complexity as well -- you collapse a lot of stuff that way which you probably don't want to collapse.
02:55:27 <Cale> (Well, it's the same assumption as finite memory)
02:55:39 <narendraj9> Cale: No function whose range has n elements can be computed in time less than (log n). Why is it so?
02:55:48 <gfixler> Cale: which asymptotics?
02:55:58 <kaidelong> anyway I do think it's a bit pedantic but I did once do something very similar to this to one of my professors so I shouldn't complain
02:56:38 <Cale> narendraj9: Because in order to distinguish between n different cases, you need to examine at least log(n)/log(2) bits of your input.
02:57:16 <bbri06> Quck question about cabel, if I update GHC, do I need to update cabal?
02:57:22 <Cale> oh, he d/ced
02:57:28 <bbri06> cabal*
02:57:36 <kaidelong> (isn't CS convention that log means log 2 unless specified otherwise?)
02:57:39 <Cale> bbri06: You don't have to, but it's often a good time to do it
02:57:56 <Cale> I dunno, I'm a mathematician. log usually means natural log for me.
02:58:10 <Cale> But if I take the quotient of two logarithms, it doesn't matter what base they are.
02:58:15 <gfixler> I wish all of these dependencies were in a proper tree
02:58:22 <bbri06> Alright. I ask because I just update GHC, then tried instaling some packages, and they installed succesfully but my build file said they were still missing... so I thought something might be up
02:58:25 <kaidelong> I guess it does not hurt to be explicit
02:58:41 <kaidelong> I know the traditional thing was for log to mean base 10 and ln to mean the natural log
02:58:51 <kaidelong> so I guess a lot of people will expect that
02:58:56 <sternenseemann> okay, switching to Text is simpler as thought
02:58:56 <Cale> Well, traditional for certain people
02:59:22 <Cale> It's mostly calculator manufacturers that use that convention.
02:59:31 <gfixler> and ln -s is the symbolic natural log
02:59:38 <Cale> heh
03:00:06 <Cale> 10 is kind of a stupid choice of default base
03:00:32 <Cale> The only thing it's good for is being easy to approximate in your head.
03:00:43 <gfixler> it's only good for that because that's what we know
03:00:48 <kaidelong> well that would be true for any base you're practiced in
03:00:56 <gfixler> I'm going to raise my children on base 2
03:00:58 <Cale> Yeah, because of our choice of base 10 representation of numbers.
03:01:13 <kaidelong> if we were like ancient sumerians we would think of base 60 as the more natural thing
03:01:38 <kaidelong> and it's a better base because it has 3 prime factors, so division is easier
03:02:17 <kaidelong> actually you know
03:02:25 <kaidelong> we do use base 60 pretty often when dealing with time
03:02:35 <kaidelong> we just don't have a numeral system for it
03:02:35 <gfixler> speaking of bases and 3s: http://www.reddit.com/r/dailyprogrammer/comments/2xx86n/20150302_challenge_204_intermediate_its_like/cp756bc?context=3
03:02:45 <gfixler> I like /u/Syrak's solution
03:03:02 <gfixler> I need to think in terms of the list monad more often
03:08:22 <narendraj9> Cale: Sorry I got disconnected. I was curious as to where can I find more information about what you said. About computing a function with a range of size n.
03:08:57 <Cale> In order to distinguish between n different cases, you need to examine at least log(n)/log(2) bits of your input.
03:09:33 * hackagebot tinylog 0.12.1 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.12.1 (ToralfWittner)
03:09:36 <narendraj9> Cale: Oh, we are going that deep.
03:10:01 <mniip> [13:46:51] <kaidelong> unboxed gives you "bottom-less" values
03:10:02 <mniip> what no
03:10:20 <mniip> that's neither the idea of unboxed nor a true statement
03:11:38 <mniip> ok maybe I am wrong...
03:12:25 <mniip> maybe it's true after all but the idea of unboxed is that they're not in a box, like all other values are
03:12:40 <Cale> I think kaidelong is pretty correct. It depends on how you model unboxed values mathematically, but it's reasonable not to include a bottom element in those types, because on the operational side of things, a variable whose type is unboxed can't be an unevaluated expression.
03:12:59 <Cale> can't be bound to one
03:13:02 <mniip> mathematically?
03:13:24 <mniip> aren't unboxed values an implementation specific thing?
03:13:36 <Cale> Well, if you want to talk about bottom at all
03:14:16 <gfixler> I guess I need to expand my idea of what arrays are
03:14:19 <Cale> Bottom is an element of the partially ordered sets we use to understand types.
03:14:54 <mniip> unboxed values are outside of the mathematical idea of types and values
03:15:12 <Cale> I disagree.
03:15:42 <Cale> You tend to want to formulate some mathematical conception of what's going on there if you're going to implement a compiler for a language with such values.
03:15:58 <mniip> they are consistent with boxed types
03:16:05 <Cale> It's just helpful in a lot of ways to have such a model
03:16:11 <mniip> because you have no (I# ⊥)
03:17:06 <kaidelong> I hear this argument repeated but I honestly don't like it myself
03:17:13 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/unboxed-values.ps.Z
03:17:17 <Cale> There's this paper
03:17:17 <kaidelong> boxed values are bottomless in the same way once they're evaluated, really
03:17:44 <mniip> postscript? heh
03:18:22 <kaidelong> the only way to really preclude bottoms is to prove your program valid
03:18:44 <Cale> kaidelong: You could also include a bottom element in your semantics of course -- it's a matter of choice
03:19:14 <Cale> If there's only one bottom to deal with, you can handle that by just doing the semantics a bit differently.
03:19:42 <kaidelong> essentially if you really want to say that there are no bottoms in unboxed types then you have to still prove your program correct, hence why I was using scare quotes
03:20:11 <kaidelong> the main difference is that you can't be passed some thunk that will turn out to blow up
03:20:37 <Cale> Well, the paper I linked uses domains lacking a bottom element when representing unboxed types
03:20:52 <Cale> in its semantics
03:20:59 <Cale> But it's really just a matter of taste
03:21:12 <Cale> You could do it either way and be just as good about it
03:21:25 <kaidelong> mmm, well, I guess that's fair enough when you're dealing with laziness because the bottom is "hidden" from the consumer behind a side effect (evaluation)
03:21:25 <Cale> It would just change some of the rules about the interpretation.
03:21:42 <kaidelong> wheras with boxed values it can potentially be ignored
03:21:53 <kaidelong> and thus thinking about it might be important
03:22:13 <Cale> yeah
03:22:25 <kaidelong> so you can think of it as a side effect rather than a value although honestly
03:22:55 <kaidelong> I think you can do that anyway, even when dealing with unevaluated thunks, bottom is just a particularly nasty potential side effect that pops up when the value is demanded
03:23:04 <kaidelong> it's not really a value
03:23:46 <Cale> Well, the idea there is that you're representing functions as monotone maps between directed-complete partial orders
03:23:55 <kaidelong> I guess you could argue that it's simpler just to treat all bottoms as values and then you end up with types being uncountable
03:24:08 <kaidelong> except unboxed ones
03:24:11 <Cale> in order to capture the idea that there are functions which don't need to examine all of their input
03:24:21 <mniip> kaidelong, huh
03:24:24 <mniip> how is () uncountable
03:24:34 * hackagebot spatial-math 0.2.1.2 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.1.2 (GregHorn)
03:26:11 <kaidelong> mniip: the problem is with partial functions
03:26:17 <mniip> ?
03:26:19 <kaidelong> what you really have is "() and all the bottoms"
03:26:26 <kaidelong> which are all programs that fail to generate it
03:26:28 <Cale> So a function may choose to send _|_ to some value which is not _|_
03:26:39 <mniip> kaidelong, aren't all bottoms eqiuvalent?
03:26:46 <kaidelong> Nat -> Nat is equivalent in its cardinality
03:26:48 <Cale> But it must send everything lying above _|_ to values which lie above the one which it sent _|_ to
03:26:50 <kaidelong> and is uncountable
03:27:30 <mniip> Nat -> Nat is the cardinality of R, no?
03:27:30 <Cale> e.g. you might have a function [Bool] -> [Bool] which sends _|_ to True : (False : _|_), say
03:27:37 <kaidelong> yes
03:27:39 <mniip> oh right that's uncountable
03:28:11 <Cale> but then you know that for any x :: [Bool], you have True : (False : _|_) <= f x  in the definedness ordering
03:28:27 <Cale> So you can determine the first two elements of the resulting list without knowing what x is.
03:28:34 <kaidelong> with an unboxed () you really are talking about the unit, rather than all the ways you can generate it
03:28:43 <kaidelong> or that would be the idea
03:28:52 <kaidelong> I'm not sure this is a good level of abstraction honestly
03:29:29 <Cale> The domain representing () has two elements, _|_ and (), and _|_ < ()
03:29:49 <kaidelong> however it might be good if you are extending or implementing Haskell itself or libraries that transform/optomize/transpile haskell code
03:30:01 <Cale> and functions between () and other types have to be order preserving
03:30:30 <Cale> So if _|_ gets sent to a maximally defined value, then () must be sent to the same value
03:30:49 <Cale> But if _|_ gets sent somewhere else, then () may be sent to something lying above that
03:31:35 <Cale> e.g. I can define a function () -> [Bool] which sends _|_ to True : (False : _|_), and () to True : (False : (True : [])) perhaps
03:32:41 <Cale> f x = True : False : case x of () -> True : []
03:34:22 <Cale> > let f x = True : False : case x of () -> True : [] in f undefined
03:34:23 <lambdabot>  [True,False*Exception: Prelude.undefined
03:34:31 <Cale> > let f x = True : False : case x of () -> True : [] in take 2 (f undefined)
03:34:32 <lambdabot>  [True,False]
03:34:40 <Cale> > let f x = True : False : case x of () -> True : [] in f ()
03:34:41 <lambdabot>  [True,False,True]
03:59:35 * hackagebot not-gloss 0.7.0.2 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.0.2 (GregHorn)
04:03:01 <kaidelong> @hoogle [Maybe t] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=t
04:03:02 <lambdabot> Parse error:
04:03:02 <lambdabot>   [Maybe t] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=t
04:03:02 <lambdabot>                          ^
04:03:06 <kaidelong> what
04:03:08 <kaidelong> why did
04:03:12 <kaidelong> what
04:03:19 <kaidelong> konversation why is that a thing that you do
04:03:35 <kaidelong> @hoogle [Maybe t] -> [ [t] ]
04:03:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:03:36 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
04:03:36 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
04:04:03 <xandaros> http://lpaste.net/123422 any ideas?
04:04:46 <kaidelong> xandaros are you on windows?
04:04:59 <xandaros> kaidelong: negative, Arch Linux
04:05:02 <kaidelong> oh wait no you're not, it successfully loaded unix
04:05:31 <kaidelong> anyway the problem is pretty much laid out for you in the error message
04:05:55 <kaidelong> either you don't have libcurses installed or you have it but your library path isn't set up in a way that GHC can find it
04:06:13 <xandaros> well, /usr/lib/libcurses.so exists, so I'm not sure what it can't find
04:07:02 <saep> Is it a symlink to a file that does not exist? 
04:07:21 <kaidelong> mmm, I'm not sure how cabal sandboxes work in linux, it may be a chroot
04:07:46 <kaidelong> so you might want to check in .sandbox or whatever that directory was called again
04:07:47 <xandaros> saep: it's a symlink to libncurses.so, which is a regular file
04:08:05 <kaidelong> and see if there is a /usr/lib in there
04:08:41 <kaidelong> xandaros: it's looking for libcurses, not libncurses
04:08:45 <kaidelong> oh
04:08:48 <kaidelong> you mean
04:08:51 <kaidelong> libcurses is
04:08:52 <kaidelong> I see
04:08:54 <kaidelong> nm
04:09:17 <xandaros> I just tried to create a symlink from .cabal-sandbox/usr/lib/libcurses.so to /usr/lib/libcurses.so - no such luck :(
04:09:55 <xandaros> without llvm-general in the dependencies list, it works fine and I do believe ghci uses curses, so I'm really confused
04:10:01 <kaidelong> try using strace?
04:10:53 <kaidelong> this is bizzare
04:11:55 <xandaros> Never used strace before and that is a lot of output... wow
04:12:04 <kaidelong> strace -e trace=open 
04:12:12 <kaidelong> will only look at system calls to open
04:12:32 <Forgetaboutit> is there any combinator to run multiple folding functions over a Foldable instance in a single fold?
04:14:25 <Forgetaboutit> essentially something like `(Foldable t) => foldr ((a -> b -> b), (a -> c -> c)) -> (b, c) -> t a -> (b, c)' for some arities from, say, two to seven or so?
04:15:06 <xandaros> kaidelong: http://lpaste.net/123423
04:16:06 <kaidelong> xandaros: mm, that's not helpful, I guess strace needs to be told to attach to child processes
04:16:10 <kaidelong> lemme look up how to do that
04:17:38 <xandaros> -f and I found something interesting in that
04:17:41 <kaidelong> strace -e trace=open -f
04:25:37 <xandaros> kaidelong: http://sf.inp.io/xan/output.txt
04:26:12 <xandaros> looks like it is looking for a file "-lncursesw"
04:30:33 <kaidelong> xandaros: mm, is that even a valid file name?
04:30:48 <xandaros> kaidelong: I got it to work by creating a symlink from -lncursesw to libncursesw.so
04:30:58 <kaidelong> okay
04:31:02 <kaidelong> so there is a problem with this
04:31:08 <xandaros> Yes, it is, but it's a pain to work with since most tools will interpret it as argument to them
04:31:16 <kaidelong> yeah
04:31:25 <kaidelong> let's hope you don't run into trouble, I guess
04:31:32 <kaidelong> this might be a GHC bug
04:31:38 <kaidelong> perhaps go ask in #ghc
04:31:52 <xandaros> not sure - only happens with llvm-general, though
04:31:59 <xandaros> never had this before
04:34:31 <xplat> Forgetaboutit: no, but there are various libraries that let you combine multiple folding functions into one
04:34:33 <xandaros> Well, I have my repl now - I'm happy
04:35:21 <Forgetaboutit> xplat: I was hoping for that, couldn't find one however.  Can you point me to one?
04:38:24 <kaidelong> @type (&&&)
04:38:25 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
04:38:43 <kaidelong> @instances-importing Arrow
04:38:44 <lambdabot> (->), Kleisli m
04:39:31 <xplat> Forgetaboutit: try folds + folds-common, foldl, foldl-incremental, ZipFold
04:39:38 * hackagebot euler 0.5.1 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.5.1 (decomputed)
04:42:04 <xplat> @hackage folds
04:42:04 <lambdabot> http://hackage.haskell.org/package/folds
04:42:20 <Forgetaboutit> xplat: Thank you, sir!
04:56:24 <wz1000> How do you treat forall when reasoning about types? Bool -> Maybe Bool is inhabited by 3^2 non _|_ values. How would you predict how many values (a -> Maybe a) is inhabited by?
04:57:07 <EvanR> infinite
04:57:23 <wz1000> s/(a -> Maybe a)/(forall a. a -> Maybe a)
04:57:55 <EvanR> 3^2 times cardinality of a
04:58:47 <wz1000> It is inhabited by exactly two values. const Nothing and Just.
04:59:18 <EvanR> ah polymorphic
04:59:45 <wz1000> Yes
05:01:50 <EvanR> a:Type -> Bool -> Maybe a
05:02:18 <EvanR> a:Type -> a -> Maybe a
05:05:10 <wz1000> ?
05:05:28 <EvanR> not to be construed as helpful i was just thinking outloud
05:19:35 <akegalj> how could I implement foldable for this type http://lpaste.net/6323237357831061504 . I would like to fold over Node.keyStrokes
05:33:07 <ClaudiusMaximus> akegalj: Foldable won't do what you want (it would fold the 'a's), but you could write your own fold function, or change your type to  data Tree k v  with keyStrokes :: v, then you could have  Foldable (Tree k)
05:35:01 <nkar> how can I talk to a python library from haskell?  I've had high hopes for cpython, but it fails to build with recent packages
05:43:26 <KaneTW> write your own bindings i guess?
05:43:45 <nkar> nah, I managed to build pyfi
05:44:01 <nkar> though, it yet to be determined whether it works for my usecase
05:46:24 <ClaudiusMaximus> akegalj: i annotated your paste
05:53:43 <akegalj> ClaudiusMaximus: oh thanks... i am looking at it now
05:54:10 <funfunctor> hi
05:55:15 <funfunctor> Is there a way to guaranty ordering of three IO actions?
05:55:35 <Cale> funfunctor: x >> y >> z
05:55:48 <Cale> or  do { x ; y ; z }
05:56:11 <funfunctor> Cale: sorry, I mean to say these are part of a API and so the IO actions could happen with other things in between
05:56:22 <Cale> ah
05:56:28 <EvanR> you need dependent-like types ;)
05:56:37 <funfunctor> yea I thought so
05:56:38 <Cale> You can do a lot of type hackery to make that work
05:56:42 <funfunctor> so only in Idris
05:56:46 <Cale> But it's usually not worth it
05:56:50 <Cale> you don't need dependent types
05:57:00 <funfunctor> well its done in SPARK/Ada
05:57:01 <EvanR> its not worth it for raw bindings
05:57:01 <akegalj> ClaudiusMaximus: ok i get it, thank you
05:57:10 <funfunctor> using pre-condition pragmas
05:57:27 <EvanR> funfunctor: these do runtime checks?
05:57:39 <funfunctor> EvanR: no they are compile time in SPARK
05:57:54 <EvanR> interesting
05:58:11 <Cale> One approach to making sure that something is initialised is to define some new monad in which the actions that require that resource to be initialised are defined, and write some action runFoo :: Foo a -> IO a which initialises it
05:58:31 <Cale> If you have 3 levels like that, it might be a bit tedious to use
05:58:34 <funfunctor> EvanR: I believe they annotate the AST and do the checks there
05:58:53 <Cale> But you could use a phantom type parameter there to indicate levels
05:59:16 <funfunctor> Cale: ok, I guess i'll just leave a comment in the Haddock docs
05:59:17 <Cale> and there's a bunch of type level hackery you can do with either type families or functional dependencies
05:59:35 <funfunctor> no idea how to start with that
05:59:36 <EvanR> you can represent the state of the context with types
05:59:37 <Cale> to do fancy things like encoding sets of resources
05:59:48 <EvanR> indexed monad
05:59:58 <Cale> oh, yeah, and there's indexed monads
06:00:03 <Cale> that's true
06:00:06 <funfunctor> It maybe too complex for my use case perhaps?
06:00:10 <Cale> That's a whole other approach to it
06:00:13 <Cale> probably
06:00:34 <Cale> I mean, it comes down to how much convenience you're willing to sacrifice for safety
06:00:38 <funfunctor> see end of this page http://www.nuand.com/libbladeRF-doc/v1.2.1/group___f_n___d_a_t_a___s_y_n_c.html
06:00:55 <EvanR> the filenames on that site are awesome
06:01:01 <funfunctor> Well I am pretty strong on safety
06:01:11 <funfunctor> lol yea I know..
06:01:33 <funfunctor> Doxygen :p
06:02:12 <funfunctor> I feel I didn't do such a bad job on my binding so far http://hackage.haskell.org/package/hlibBladeRF
06:02:34 <funfunctor> both of you have been a huge help it would be nice to credit that somehow?
06:02:56 <EvanR> im good
06:03:18 <exio4> funfunctor: the "easiest" way to force you to do something, is to use phantom types, you can't force an ordering, but it's the easiest without going to type hackery
06:03:39 <EvanR> you can force an ordering
06:04:03 <EvanR> T A -> T B, T B -> T C, and only give them a T A to start with
06:06:17 <exio4> you'd need to keep changing the phantom types, and some things that could run in more than one order, but need certain precondition would make it weird
06:06:40 <EvanR> well yeah, it can get really complex
06:06:48 <funfunctor> ah too complicated for the moment..
06:06:51 <EvanR> if the ways you are allowed to use it are complex
06:07:11 <funfunctor> I was just hoping for a pragma like in SPARK :p
06:07:34 <EvanR> why dont you explain exactly what the preconditions are and the kind of ordering youre trying to enforce is
06:11:14 <mrkkrp> Is there something like "Community-driven Haskell style guide"?
06:11:30 <EvanR> theres haskell style guide on github
06:11:49 <mrkkrp> https://github.com/tibbe/haskell-style-guide
06:11:50 <mrkkrp> ?
06:13:10 <EvanR> maybe chrisdone one
06:14:13 <drbean> What's a function like unwords which joins strings with a custom string instead of spaces.
06:14:36 <mrkkrp> intercalate ?
06:14:46 <EvanR> :t concat . intercalate
06:14:47 <lambdabot>     Couldn't match type ‘[[a1]] -> [a1]’ with ‘[[a]]’
06:14:47 <lambdabot>     Expected type: [a1] -> [[a]]
06:14:47 <lambdabot>       Actual type: [a1] -> [[a1]] -> [a1]
06:14:53 <EvanR> :t intercalate
06:14:55 <lambdabot> [a] -> [[a]] -> [a]
06:15:10 <mrkkrp> "intercalate xs xss is equivalent to (concat (intersperse xs xss)). It inserts the list xs in between the lists in xss and concatenates the result."
06:15:10 <EvanR> :t concat (.).(.) intercalate
06:15:11 <lambdabot>     Couldn't match expected type ‘(a -> [[a2]] -> [a2]) -> c’
06:15:11 <lambdabot>                 with actual type ‘[a0]’
06:15:11 <lambdabot>     Possible cause: ‘concat’ is applied to too many arguments
06:15:39 <saml_> > concat . (intercalate '/') $ "abc"
06:15:40 <lambdabot>  Couldn't match expected type ‘[[a]]’
06:15:40 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match type ‘GHC.Types....
06:15:40 <lambdabot>  Expected type: [[[a]]]
06:15:51 <EvanR> oh i got intercalate and intersperse mixed up again
06:16:26 <funfunctor> hmm __bold__ should make that text bold in Haddock right?
06:16:47 <funfunctor> because its just showing the underscored text and not making it bold?
06:21:48 <mrkkrp> By the way, what's your Emacs setup for Haskell? Currently I just use bare haskell-mode. Maybe there is something better? Maybe some seasoned haskeller could share `.emacs' or something?
06:29:43 * hackagebot snowglobe 3.0.0.1 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-3.0.0.1 (ClaudeHeilandAllen)
06:34:43 * hackagebot snowglobe 3.0.0.2 - randomized fractal snowflakes demo  http://hackage.haskell.org/package/snowglobe-3.0.0.2 (ClaudeHeilandAllen)
06:37:07 <tomjaguarpaw> Can someone tell me how to make a local-repo for cabal?
06:39:43 * hackagebot haste-perch 0.1.0.8 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.8 (AlbertoCorona)
06:39:56 <funfunctor> EvanR: i'm still not 100% what I should do with these C return values, i.e. should I return a enum type value or throw an exception as an instance of the enum error types
06:44:44 * hackagebot hplayground 0.1.2.4 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.2.4 (AlbertoCorona)
06:54:44 * hackagebot xcffib 0.2.0 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.2.0 (TychoAndersen)
07:28:08 <SleepyPikachu> Is anyone familiar with Parsec? I want to store some state inside the parser, does anyone know if this is possible?
07:30:05 <geekosaur> SleepyPikachu, GenParser YourStateType
07:30:12 <geekosaur> er
07:30:34 <geekosaur> GenParser TokenType StateType, where TokenType is e.g. String
07:31:30 <SleepyPikachu> ah so in the examples I've been working from state stype has been st, is that some sort of empty state?
07:31:55 <SleepyPikachu> geekosaur: and does it work the same as the usual state monad? (Also where are my manners? Thanks very much :-))
07:32:08 <EvanR> @where manners
07:32:09 <lambdabot> I know nothing about manners.
07:32:22 <geekosaur> it's a type variable
07:32:32 <geekosaur> the empty state is ()
07:32:51 <geekosaur> so the types are just telling you that you can use an arbitrary state type in your parser
07:33:09 <geekosaur> (the same one across the entire parser of course)
07:33:49 <SleepyPikachu> Awesome, thanks :-)
07:35:21 <geekosaur> and yes, it's an instance of MonadState if your state is also an instance of MonadState, so the usual stuff should work
07:35:56 <geekosaur> s/also//
07:38:55 <for1096> Is it true that Haskell don't fully support HKT?
07:40:18 <silver> what's HKT?
07:41:39 <lpaste> funfunctor pasted “foo.hs:22:2: Not in scope: data constructor `BladeRFError'” at http://lpaste.net/123432
07:41:52 <funfunctor> what am I doing wrong here?
07:42:07 <funfunctor> something simple but my eye is not seeing it
07:42:30 <for1096> HKT - higher kinded type
07:49:38 <Cale> funfunctor:  BladeRFError $ toEnum ret -- you didn't define BladeRFError as a constructor anywhere
07:49:47 * hackagebot vcache-trie 0.1 - patricia tries modeled above VCache  http://hackage.haskell.org/package/vcache-trie-0.1 (dmbarbour)
07:49:48 <Cale> funfunctor: and moreover, even if you did, it's not an IO action
07:50:37 <Cale> funfunctor: The actions which you execute inside of a do-block must be of the same monad as the whole do-block (and each other)
07:51:11 <funfunctor> Cale: oh yes there should be a return on line 22
07:51:11 <Cale> funfunctor: I think you meant to use return instead of BladeRFError
07:51:53 <funfunctor> Cale thx
07:53:35 <funfunctor> Cale: i'm just a little confused by the difference between the type-signature restriction of the codomain and type construction by putting BladeRF $ infront
07:53:58 <funfunctor> how is toEnum constructing a Kind * ?
07:54:25 <funfunctor> sorry if my question is not well formed
08:02:01 <d3lxa> how can I write beautifully this: (myfunc <$>) <$> myval ?
08:02:13 <utopia-lied> hey everybody!
08:02:33 <utopia-lied> I've got a pretty beginner question
08:03:03 <utopia-lied> in this type definition
08:03:05 <utopia-lied> ;(RealFrac a, Integral b) => a -> b
08:03:16 <utopia-lied> why are there 2 types
08:03:20 <utopia-lied> for one thing
08:03:26 <utopia-lied> i.e. RealFrac and Integral
08:03:31 <EvanR> so it can convert between two different types
08:03:46 <utopia-lied> what do you mean?
08:03:50 <unknownloner> it means a is a RealFrac and b is an Integral
08:03:51 <EvanR> oh, two type classes
08:03:57 <utopia-lied> yeah
08:04:05 <unknownloner> so the function takes a RealFrac
08:04:10 <EvanR> the conversion operation uses different methods from different classes
08:04:12 <unknownloner> and returns an Inyegral
08:04:16 <unknownloner> Integral*
08:04:42 <utopia-lied> http://zvon.org/other/haskell/Outputprelude/round_f.html is the function
08:04:57 <utopia-lied> so should the argument be a type of both?
08:05:00 <utopia-lied> is that what its saying
08:05:08 <unknownloner> no, just RealFrac
08:05:11 <EvanR> :t floor
08:05:12 <lambdabot> (RealFrac a, Integral b) => a -> b
08:05:16 <unknownloner> notice it says a -> b
08:05:30 <unknownloner> a can be a different type from b
08:05:31 <EvanR> utopia-lied: in order to do floor, you only need the argument to be fractional. and you only need the result to be integral
08:05:52 <EvanR> if the result had to be fractional, that would make floor not very useful
08:05:53 <utopia-lied> gotcha
08:06:07 <utopia-lied> ah its enforcing a return val
08:06:09 <utopia-lied> word
08:06:30 <EvanR> its a requirement of the algorithm
08:06:58 <utopia-lied> yeah
08:07:16 <utopia-lied> enforcing the right return type*
08:07:17 <EvanR> hmm well floor's implementation depends on the class but
08:07:25 <EvanR> :t fromIntegral
08:07:26 <lambdabot> (Num b, Integral a) => a -> b
08:07:32 <EvanR> @src fromIntegral
08:07:32 <lambdabot> fromIntegral = fromInteger . toInteger
08:08:20 <EvanR> you can see this conversion uses operations from two different classes, and only on the argument and result respectively
08:08:21 <utopia-lied> what about something like: take' :: (Num i, Ord i) => i -> [a] -> [a]  
08:09:13 <silver> same thing -- type class constraint on the type(s)
08:09:29 <fluvian> Is it possible to write a function which is polymorphic in members of IsString? I need to use ByteStrings internally.
08:09:34 <utopia-lied> but why are there two class constraints here?
08:09:42 <fluvian> IsString a => a -> b
08:09:50 <EvanR> utopia-lied: depends on what take' does
08:09:56 <utopia-lied> :t fromInteger
08:09:57 <lambdabot> Num a => Integer -> a
08:10:06 <utopia-lied> :t toInteger
08:10:07 <lambdabot> Integral a => a -> Integer
08:12:24 <silver> utopia-lied, because author of the function want's to use functions from given type classes on arguments of types i
08:13:07 <narendraj9> > toInteger (12 :: Int)
08:13:09 <lambdabot>  12
08:13:31 <narendraj9> Are there any other Integrals other than Ints and Integers?
08:13:55 <unknownloner> :t Word8
08:13:56 <lambdabot>     Not in scope: data constructor ‘Word8’
08:13:56 <lambdabot>     Perhaps you meant ‘Word’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:14:07 <EvanR> @instances Integral
08:14:08 <lambdabot> Int, Integer
08:14:14 <EvanR> no, never
08:14:15 <unknownloner> oh hey that exists
08:14:23 <narendraj9> @instances Numeric
08:14:23 <lambdabot> Couldn't find class `Numeric'. Try @instances-importing
08:14:28 <narendraj9> @instances Num
08:14:29 <lambdabot> Double, Float, Int, Integer, Product a, Sum a
08:14:34 <EvanR> > toInteger ()
08:14:35 <narendraj9> This is cool
08:14:36 <lambdabot>  No instance for (GHC.Real.Integral ())
08:14:36 <lambdabot>    arising from a use of ‘GHC.Real.toInteger’
08:15:02 <narendraj9> > (Sum 12) + (Sum 22)
08:15:04 <lambdabot>  No instance for (GHC.Show.Show a0)
08:15:04 <lambdabot>    arising from a use of ‘M604852288817038059312341.show_M6048522888170380593...
08:15:04 <lambdabot>  The type variable ‘a0’ is ambiguous
08:15:13 <unknownloner> o.0
08:15:24 <fizruk> :t Sum
08:15:25 <lambdabot> a -> Sum a
08:15:26 <EvanR> l2q3nf2l3knwk3fn
08:15:33 <fizruk> > Sum 1 + Sum 2
08:15:35 <lambdabot>  No instance for (GHC.Show.Show a0)
08:15:35 <lambdabot>    arising from a use of ‘M161081683210152030212356.show_M1610816832101520302...
08:15:35 <lambdabot>  The type variable ‘a0’ is ambiguous
08:15:48 <fizruk> > getSum $ Sum 1 + Sum 2
08:15:49 <narendraj9> > getSum (Sum 12 + Sum 22)
08:15:49 <lambdabot>  No instance for (GHC.Show.Show a0)
08:15:49 <lambdabot>    arising from a use of ‘M365443642526910091612379.show_M3654436425269100916...
08:15:49 <lambdabot>  The type variable ‘a0’ is ambiguous
08:15:50 <lambdabot>  No instance for (GHC.Show.Show a0)
08:15:50 <lambdabot>    arising from a use of ‘M368193518893792237212389.show_M3681935188937922372...
08:15:51 <lambdabot>  The type variable ‘a0’ is ambiguous
08:15:53 <fizruk> > 1 + 2
08:15:54 <lambdabot>  3
08:15:55 <EvanR> arrrrrrggg
08:16:25 <fizruk> > x + y
08:16:26 <lambdabot>  Ambiguous occurrence ‘x’
08:16:26 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:177:1
08:16:26 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
08:16:55 <EvanR> > Sum 3 <> Sum 4 :: Sum Int
08:16:57 <lambdabot>  Sum {getSum = 7}
08:17:25 <narendraj9> Oh. I see.
08:17:47 <EvanR> > Product 3 <> Product 4 :: Product Int
08:17:47 <narendraj9> > getSum (Sum 12 :: Sum Int + Sum 22)
08:17:48 <lambdabot>  can't find file: L.hs
08:17:48 <lambdabot>  Not in scope: type constructor or class ‘+’
08:18:06 <narendraj9> > getSum ((Sum 12 :: Sum Int) + Sum 22)
08:18:07 <fizruk> hehe
08:18:08 <lambdabot>  Overlapping instances for GHC.Num.Num
08:18:08 <lambdabot>                              (Data.Monoid.Sum GHC.Types.Int)
08:18:08 <lambdabot>    arising from a use of ‘GHC.Num.+’
08:18:16 <EvanR> lambdabot is coming apart
08:18:29 <fizruk> lambdabot: are you ok?
08:18:40 <EvanR> > Product 3 <> Product 4 :: Product Int
08:18:41 <lambdabot>  Product {getProduct = 12}
08:19:08 <funfunctor> I love Either
08:19:20 <narendraj9> > mconcat $ map Sum [1..]
08:19:21 <lambdabot>  Sum {getSum = *Exception: stack overflow
08:19:29 <narendraj9> > mconcat $ map Sum [1..10]
08:19:30 <lambdabot>  Sum {getSum = 55}
08:20:24 <narendraj9> @instances Real
08:20:24 <lambdabot> Double, Float, Int, Integer
08:20:37 <funfunctor> EvanR: would it be good or bad design to deal with C ret's by using the following bladeRFErrorTy :: CInt -> Either BladeRFError Int   to translate them for each of my actions?
08:20:53 <SleepyPikachu> geekosaur: How do I put and get the state?
08:21:52 <EvanR> funfunctor: in your wrappers use Either
08:21:58 <geekosaur> looked to me like it should use the usual get/put/modify? if not you'll have to find someone who knows more about Parsec state, as I've not needed it
08:22:15 <EvanR> in the raw bindings i would directly use the C function signature
08:22:25 <SleepyPikachu> geekosaur: I recalled something from the docs, it's getState, putState
08:22:47 <geekosaur> I saw those but thought they were internal, having to do with its internal state support
08:23:09 <geekosaur> since they seem to operate on things that are not just your state
08:23:25 <geekosaur> but maybe
08:23:57 <SleepyPikachu> geekosaur: I assumed the same but they aren't, if you look at the type lines you'll see u (which stands for user state) is the input and result for putState and getState respectively.
08:27:52 <kaiyin> Why doesn't mapt work here: http://lpaste.net/123436 ? Error message is at the bottom.
08:32:16 <kaiyin> hm, I got it, missed a pair of parentheses
08:36:43 * hackagebot digestive-functors-blaze 0.6.0.5 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.5 (JasperVanDerJeugt)
08:36:44 * hackagebot digestive-functors-snap 0.6.1.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.1.1 (JasperVanDerJeugt)
08:41:40 <lpaste> funfunctor pasted “EvanR” at http://lpaste.net/123439
08:41:58 <funfunctor> does something like that seem reasonable?
08:42:16 <EvanR> the next 16 lpasters will get a free gift!
08:42:22 <EvanR> whoever gets 123456
08:42:33 <funfunctor> :)
08:42:36 <EvanR> > 56 - 16
08:42:37 <lambdabot>  40
08:42:39 <EvanR> > 56 - 39
08:42:40 <lambdabot>  17
08:43:09 <funfunctor> we had changeset 8086 at coreboot lol
08:43:14 <EvanR> "Erase block to start erasing at"
08:43:16 <funfunctor> about a month or so ago
08:43:41 <funfunctor> EvanR: thx for the typo spot
08:43:53 <funfunctor> that came from the C header
08:43:54 <EvanR> what does the returned Int mean
08:44:34 <EvanR> and whats bladeRFErrorTy
08:44:55 <funfunctor> EvanR: 0 on success, or BLADERF_ERR_INVAL on an invalid erase_block or count value, or a value from Error codes list on other failures 
08:45:10 <EvanR> so the Int means nothing
08:45:14 <artem> @pl \a n -> chunk : chunks n rest where (chunk, rest) = splitAt n a
08:45:14 <lambdabot> (line 1, column 52):
08:45:14 <lambdabot> unexpected " "
08:45:14 <lambdabot> expecting operator
08:45:14 <EvanR> the one youre returning
08:45:42 <lpaste> funfunctor pasted “No title” at http://lpaste.net/123440
08:45:59 <funfunctor> EvanR: line 97
08:46:29 * EvanR says why return an Int that is always zero
08:46:35 <funfunctor> EvanR: not in this particular case, some return Int's mean something when >0
08:46:59 <EvanR> no reason to return an Int then
08:47:12 <funfunctor> EvanR: ah that was just for testing.. will fix it back to how it was now
08:47:24 <funfunctor> no that should be >= 0
08:47:35 <EvanR> Either Error Int
08:48:23 <ololo> @pl chunks a b = chunk : chunks n rest where (chunk, rest) = splitAt n a
08:48:23 <lambdabot> (line 1, column 57):
08:48:23 <lambdabot> unexpected " "
08:48:23 <lambdabot> expecting operator
08:48:36 <EvanR> ololo: you can use lambdabot in PM
08:50:09 <funfunctor> EvanR: my question is mainly, is this a nice way to present errors returned back?
08:50:32 <EvanR> ... isnt that what im trying to talk to you about?
08:50:45 <funfunctor> yep
08:50:58 <EvanR> do you have an answer to any of my questions
08:51:25 <funfunctor> umm, which question I thought I had answered
08:51:45 <funfunctor> (03:44:18 AM) funfunctor: EvanR: not in this particular case, some return Int's mean something when >0
08:51:56 <EvanR> why are you returning an Int
08:54:49 <funfunctor> EvanR: some functions it means something, for example "1 if FPGA is configured, 0 if it is not, and value from Error codes list on failure "
08:55:15 <EvanR> funfunctor: ok. so no i dont think what you have is good
08:55:23 <quchen> Is this some low-level interface? Otherwise you should not be using Int but your own error type.
08:55:32 <quchen> Plus some conversion function from C return codes to that type.
08:55:46 <funfunctor> quchen: thats exactly what I am doing
08:56:03 <funfunctor> I only return Int on success 
08:56:38 * hackagebot euler 0.6.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.6.0 (decomputed)
08:56:44 <funfunctor> EvanR: another example would be "Number of items populated in list, or an error value from the Error codes list on failure"
08:56:50 <EvanR> 1) 1, 0 or an error type is not your own result type. 2) because sometimes the Int might not be zero has nothing to do with why you return Int when its always zero
08:57:00 <EvanR> im specifically asking about that function you pasted
08:57:40 <funfunctor> EvanR: do you mean the == 0 part, I already said.. that was me just testing something.. read it as >= 0
08:57:53 <EvanR> i have no idea what the == 0 part is, im talking about the return type of your function
08:57:57 <EvanR> Either BladeError Int
08:58:43 <EvanR> bladeRFEraseFlash
08:58:46 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/123440
08:59:00 <c_wraith> lolblug2rth
08:59:00 <EvanR> what am i looking at now?
08:59:02 <funfunctor> ok I fixed line 98
08:59:52 <EvanR> youre insisting on using this function for every return type in your library?
09:00:22 <EvanR> i would suggest determining an appropriate return type for each function which makes sense for that function
09:00:22 <funfunctor> EvanR: I figured if they all have the same return type it makes it consistent no?
09:00:29 <funfunctor> ok
09:00:45 <EvanR> i would be annoyed if every return type in the Prelude was Int to be consistent
09:00:56 <funfunctor> so in that case, for bladeRFEraseFlash it should return IO (Maybe BladeRFError) ?
09:01:26 <EvanR> that would be better than Left Error or Right 0
09:01:45 <EvanR> but its backwards from the usual usage of Maybe
09:02:00 <EvanR> Either Error () instead maybe
09:02:20 <EvanR> or data Result = Ok | Error
09:03:16 <funfunctor> do you think it makes sense to define a data BladeRFStatus = BladeRFError | Success type?
09:03:26 <funfunctor> and consistently return that?
09:03:47 <EvanR> not if you inconsistently have something important to return
09:04:00 <funfunctor> ok
09:04:49 <funfunctor> is Either BladeRFError ()  really so great?
09:05:04 <EvanR> that would be consistent with all the other Eithers
09:05:18 <funfunctor> does that not make it awkward to deal with the errors?
09:05:27 <EvanR> why would it
09:05:35 <EvanR> the Left is considered an error by all the instances
09:05:59 <funfunctor> ok I guess
09:06:16 <funfunctor> alright, i'll take your advice very good. Thanks for the input!
09:07:59 <EvanR> like i was saying weeks ago (or however long) you can also export exception throwing versions
09:08:53 <funfunctor> EvanR: yea I was not sure which to go with, I thought the idea was "do both"
09:09:39 <EvanR> thats the idea behind "also"
09:09:55 <funfunctor> oh sorry
09:10:12 <funfunctor> I'm dyslexic, I sometimes miss these things
09:14:37 <meoblast001> so.. i'm trying to use applicative some more... i find myself right now writing the same line over and over... something <*> something <*> something <*>.... is there something like <*> which will allow me to apply it n amount of times?
09:16:04 <meoblast001> hmm... maybe replicate and then fold....
09:17:58 <EvanR> you cant arbitrarily apply <*> n times because the types are different
09:18:13 <quchen> meoblast001: You can fold using <*> if you've got (a->a) actions,
09:18:16 <quchen> :t foldr (<*>)
09:18:17 <lambdabot> Applicative f => f a -> [f (a -> a)] -> f a
09:18:43 <meoblast001> quchen: thanks... replicate and fold seem like they might work in conjunction
09:19:04 <meoblast001> i can't compile to see if the types match yet.. but i'm basically doing this: foldl1 (<*>) (replicate 6 (toInteger <$> getWord32le))
09:19:47 <quchen> Why foldl?
09:20:13 <meoblast001> hm.. you're right
09:20:14 <quchen> Any you're trying to <*> lots of "Foo Integer" actions, that won't typecheck
09:20:15 <meoblast001> i do want foldl
09:20:39 <quchen> What is it you want to accomplish?
09:21:21 <meoblast001> i have a data structure which starts with a bunch of integers.... so i was doing MyData <$> (toInteger <$> getWord32le) <*> (toInteger <$> getWord32le) <*> ....
09:21:26 <meoblast001> n times
09:21:57 <enthropy>  foldl (\f x -> [| $f <*> $x |]) [| MyData |] (replicate n [| toInteger <$> getWord32le |])
09:22:12 <meoblast001> hm... that looks fun
09:22:23 <quchen> I don't think so.
09:22:33 <meoblast001> i was being sarcastic
09:23:08 <quchen> I'd say you should give "toInteger <*> foo" a good name and then just <*> that a couple of times by hand.
09:23:20 <meoblast001> that's a good idea
09:26:13 <enthropy> meoblast001: well you can probably write it once, and then you have  $(thatFunction 'MyData)
09:26:39 * hackagebot basic-prelude 0.3.11.1 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.11.1 (MichaelSnoyman)
09:26:44 <meoblast001> where are these [| and |] even coming from?
09:27:27 <enthropy> template haskell
09:29:48 <EvanR> four GADT references / introductions in a row and none of them mention the exact spelling of the LANGUAGE pragma
09:30:44 <EvanR> LANGUAGE GADTs
09:30:53 <quchen> meoblast001: [| <something> |] basically gives you the parse tree of the contained stuff.
09:31:04 <Zemyla> Hey EvanR, what do you think of the idea of a polymorphic $ or $-like function?
09:31:07 <quchen> $(foo) takes such a value and converts it back to Haskell.
09:31:23 <EvanR> Zemyla: isnt $ already polymorphic
09:31:32 <meoblast001> hmm
09:31:38 <meoblast001> i will need to look into that
09:31:41 <meoblast001> right now it's a bit over my head, heh
09:32:01 <quchen> It's not something you should use without good reason.
09:32:07 <Zemyla> No, it only works on normal, unwrapped functions/
09:32:18 <quchen> I think it's only to avoid writing boilerplate, such as generating lenses for a datatype yourself.
09:32:29 <EvanR> whats an example other type
09:33:24 <Zemyla> Endo, Kleisli, StateT...
09:33:42 <EvanR> oh so a typeclass
09:33:49 <Zemyla> Precisely.
09:33:54 <xplat> Zemyla: so a polymorphic 'find a function somewhere in here and apply it to an argument' function?
09:34:01 <Zemyla> Basically.
09:34:03 <EvanR> class Dollar a where
09:34:14 <EvanR>   ($) :: a b c -> b -> c
09:34:33 <Zemyla> class Dollar f a b | f -> a b where...
09:34:34 <quchen> unArr, so to speak?
09:34:46 <xplat> EvanR: that wouldn't work for Endo
09:35:30 <EvanR> -XDollarDollarBillsYall
09:35:50 <xplat> EvanR: actually wouldn't work for any of them, you'd at least have to be able to return something other than c
09:36:37 <xplat> well, i guess you could manage it for StateT, and for Kleisli with a Comonad instance...
09:36:59 <xplat> er.  for State, but not StateT
09:37:07 <quchen> EvanR: I'd be interested in the typeclass that turns an "a -> IO b" into an "a -> b" :-þ
09:37:27 <Zemyla> If you want to stretch definitions, you could make an instance for Map that calls lookup.
09:37:42 <EvanR> gross
09:38:05 <enthropy> an instance for (a -> b, x -> y)
09:38:16 <enthropy> [a -> b]
09:38:33 <xplat> i don't like this dollar class.  i don't know what it is
09:38:47 <EvanR> well i dont see a good type sig for it
09:39:22 <EvanR> but as clojure people say "who cares just do it" ;)
09:39:30 <exio4> class Category cat => CategoryConst cat where const :: a -> cat x a 
09:39:39 <Kron> what's the best library to use for simple 2D immutable arrays?
09:39:49 <EvanR> Array?
09:39:51 <exio4> or something fancy, who knows
09:40:21 <Kron> large sequences of some type which are indexed using pointer arithmetic, so O(1) read time for elements
09:40:24 <Kron> those arrays
09:40:29 <Kron> the old boring C ones
09:40:50 <Zemyla> Kron: Data.Array.IArray.
09:41:01 <Kron> thanks Zemyla
09:41:26 <Zemyla> http://hackage.haskell.org/package/array-0.5.0.0
09:41:59 <Kron> is there a strict version?
09:42:03 <EvanR> Kron: for that kind of array, where you want to mess with mapping 2d to 1d, you can use vectors
09:42:16 <Kron> hmm, okay. What are vectors in haskell?
09:42:20 <EvanR> Data.Vector
09:42:23 <Kron> they seem to mean something new in every language
09:42:30 <EvanR> packed arrays
09:42:38 <EvanR> 1D
09:42:44 <Kron> I'm basically poking at making a very simple board game AI (min max, pruning, etc.)
09:42:52 <mpickering> What is the default c pre-processor/ how do I find which is being invoked
09:42:53 <Kron> best representation of the game I can find is just a 2D strict immutable array
09:42:59 * enthropy wonders why when you pack something it's unboxed
09:43:06 <EvanR> lol
09:43:43 <EvanR> and a shipment comes by truck, and ships carry CARgo
09:44:54 <EvanR> Kron: save yourself some headache and use 2D Arrays until/if it becomes a bottleneck
09:45:29 <Kron> yeaaaah Vector looks... complicated
09:45:36 <Kron> neat that it supports slicing though
09:49:14 <kaiyin> what does it mean to parameterize functions with abstract data types?
09:55:02 <Zemyla> Why isn't Array foldable?
09:56:31 <EvanR> maybe orphan instance issue
09:57:20 <hibou_> I always have this error
09:57:22 <hibou_> http://lpaste.net/123444
09:57:30 <hibou_> nce.hs:14:43:
09:57:31 <hibou_>     Couldn't match expected type `Integer -> Double'
09:57:31 <hibou_>                 with actual type `Double'
09:57:31 <hibou_>     In the first argument of `valOption', namely `k'
09:57:31 <hibou_>     In the first argument of `(.)', namely `(valOption k)'
09:57:31 <hibou_>     In the first argument of `zipWith', namely `((valOption k) . s)'
09:57:45 <hibou_> any idea ?
09:58:10 <Cale> hibou_: What's the type signature of valOption?
09:58:31 <hibou_> valOption k s = max (k - s) 0.0
09:59:04 <Kron> it does seem strange that Array isn't foldable
09:59:16 <Kron> it's relatively trivial to generate a toList implementation for it thanks to the Ix stuff
09:59:33 <EvanR> where would you put the instance code
09:59:38 <hibou_> http://lpaste.net/123444
09:59:51 <Cale> Okay, so  valOption k :: Double -> Double, and it appears that s :: Integer -> (Integer -> Double)
09:59:55 <hibou_> :Cale I updated the code
10:00:31 <Cale> So, s produces an Integer -> Double function as its result
10:00:39 <hibou_> ah
10:00:43 <untseac> Hey
10:00:45 <Cale> which is not the correct type of argument to valOption k
10:00:57 <hibou_> what is your suggession ?
10:01:02 <hibou_> suggestion ?
10:01:03 <Cale> Use a lambda :)
10:01:17 <Cale> (\x y -> valOption k (s x y))
10:01:19 <hibou_> for s ?
10:01:44 <Cale> as the argument to the zipWith
10:01:56 <Cale> You could also write something like  (valOption k .) . s
10:02:18 <Cale> But that's not really as easy to follow, even if you're used to the pattern
10:02:18 <untseac> Is it correct to say that GHC Prelude implements the Haskell 2010 standard libraries?
10:02:31 <sritchie> hey all - which web library would you guys recommend for writing a JSON api in haskell?
10:02:37 <sritchie> this’ll be my first deployed JSON api
10:02:37 <Cale> untseac: Uh, not on its own...
10:02:51 <hibou_> yes it works thanks :Cale
10:02:55 <hpc> https://www.haskell.org/hoogle/?hoogle=json
10:02:56 <Cale> untseac: There are other non-Prelude libraries which are specified by Haskell 2010
10:03:12 <sritchie> there are a bunch of good REST libs out there in Haskell, looks like - 
10:03:14 <Cale> untseac: also, GHC's Prelude is a little different from the one in Haskell 2010 already
10:03:38 <sritchie> just looking for recs on Snap vs Yesod vs Scotty
10:03:43 <untseac> Cale: I see, thanks
10:03:56 <Welkin> Yesod is great for big, complex apps
10:04:12 <Welkin> scotty is great for single-purpose apps or JSON  APIs
10:04:13 <Cale> untseac: It's important to realise that the Haskell Report is just as much a report on some fragment of the current state of things as it is a specification. Changes happen in the implementations first before they end up in the Report.
10:05:16 <sritchie> Welkin: and snap is kind of a lightweight yesod, yeah?
10:05:34 <Cale> sritchie: Also keep an eye on happstack :)
10:18:39 <fluvian> I wrote a module SimpleCipher to provide a super-simple API for encrypting and decrypting messages using a password. I used the cipher-aes package and AES256 encryption in authenticated GCM mode. I'd really appreciate feedback!
10:19:58 <lpaste> fluvian pasted “SimpleCipher” at http://lpaste.net/123451
10:22:04 <fluvian> Is it worth sharing this on hackage? I've never submitted anything before
10:22:49 <davean> fluvian: It doesn't detract to if it is in a reasonable state for people to use
10:23:29 <davean> fluvian: I'd say if you think it is good enough people might reasonably use it for its intended purpose then release it
10:24:32 <fluvian> It seems useful to me, but I wouldn't mind getting feedback from some more knowledgeable folk first :)
10:24:59 <fluvian> Maybe something similar exists, or I could have messed up the crypto somehow
10:30:13 <fluvian> Also I'd like to know if there's a way to make the encrypt/decrypt functions polymorphic in different IsString types
10:30:37 <fluvian> e.g. you can run it on Text and it will return Text
10:31:14 <EvanR> :t fromString
10:31:15 <lambdabot>     Not in scope: ‘fromString’
10:31:15 <lambdabot>     Perhaps you meant one of these:
10:31:15 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
10:31:23 <EvanR> fromString :: String -> a
10:32:02 <EvanR> fluvian: youd have to have code that works specifically on each type, such as Text, ByteSTring
10:32:21 <EvanR> IsString just lets people use a "string" literal as input
10:32:23 <fluvian> I was afraid of that. Wouldn't I need to define differently named functions?
10:32:37 <fluvian> e.g. EncryptBS, EncryptS, ...
10:32:38 <EvanR> well a lot of them are named the same, just different modules and different types
10:32:48 <fluvian> ah OK
10:33:02 <EvanR> to answer your question i dont know what youd have ot do
10:33:16 <fluvian> so I would have SimpleCrypt.Text and SimpleCrypt.ByteString, each with encrypt and decrypt method
10:33:27 <EvanR> String Text and ByteString are all very different data structures
10:34:13 <fluvian> maybe it's better to leave it as ByteString, since that's the representation that's used by the cipher
10:34:25 <EvanR> fluvian: probably makes more sense to concentrate on one data type and have conversions to/from that type for the purposes of processing with encryption
10:36:42 <xandaros> How exactly do Text and ByteString differ? Why would you choose one over the other?
10:37:06 <EvanR> one is text the other is a string of bytes
10:37:27 <EvanR> in particular unicode text
10:37:47 <EvanR> > maxBound :: Word8
10:37:49 <lambdabot>  255
10:37:52 <EvanR> > maxBound :: Char
10:37:54 <lambdabot>  '\1114111'
10:38:22 <sitlo> hey guys, c-can I ask a haskell question? been on it for 4 hours now :/
10:38:37 <geekosaur> just ask it, if someone can answer they will
10:38:45 <xandaros> So basically, Text has the added semantics of being "printable"?
10:38:49 <sitlo> thx
10:38:52 <sitlo> let's see
10:39:36 <EvanR> xandaros: no Text represents text, sequence of characters
10:39:41 <monochrom> I don't think "unicode" implies "printable"
10:39:43 <Hijiri> xandaros: Text has unicode information in it
10:39:49 <solrize> fluvian, 1) i'd say split out the encrypt function to a pure function that accepts its IV as an argument, and an IO action like the one you have now, that makes a random IV;  and 2) use a password-to-key derivation function like pbkdf2,
10:39:57 <sitlo> so I have this trie data structure initialized by Data True = MakeTrie Char [Trie] ... one of the functions I am required to write is a function called wordsintrie that returns a list of all the words in a Trie structure
10:39:58 <Hijiri> bytestring is just a string of bytes, you don't know what it is until you try to decode it
10:39:59 <solrize> or even bcrypt/scrypt
10:40:05 <monochrom> but certainly Text has the semantics of "being unicode"
10:40:23 <xandaros> kk, got it
10:40:35 <solrize> pbkdf2 is a fancier version of your makekey function
10:40:43 <sitlo> pm me if you've got any ideas please, and thanks
10:40:43 <EvanR> also, ByteString is printable, quite convenient
10:41:00 <solrize> also don't use newStdGen to get IV's
10:42:12 <solrize> use the system RNG, i don't know if there's a haskell wrapper for it but basically read n bytes from /dev/urandom or the new linux api whose name i'm forgetting
10:42:58 <Hijiri> randomd? (I don't actually know)
10:45:54 <fluvian> solrize: good idea, I'll refactor out the IO from the encryption. But I still think I should export the IO function in the API, that way anyone using the library will realize that the operation should be nondeterministic
10:46:08 <solrize> yes, that's reasonable
10:46:15 <catsup> sitlo: you didn't ask a question
10:46:20 <fluvian> I assumed that stdGen *was* using the system RNG
10:46:26 <fluvian> i'll look into the documentation
10:46:31 <solrize> don't assume
10:46:36 <solrize> typically it uses the timer or something
10:46:46 <solrize> to seed a non-crypto prng
10:46:59 <sitlo> I did lol it was in between all the other chat ;p, let me re send it ;p
10:47:08 <sitlo> so I have this trie data structure initialized by Data True = MakeTrie Char [Trie] ... one of the functions I am required to write is a function called wordsintrie that returns a list of all the words in a Trie structure
10:47:20 <catsup> sitlo: no, i saw what you said
10:47:27 <sitlo> oh
10:47:54 <catsup> sitlo: it's not a question.  you just want someone to solve your homework problem for you?
10:48:03 <fluvian> solrize: good idea using a KDF, I realized my passwords are unsalted this way
10:48:05 <sitlo> no no lol
10:48:20 <sitlo> I see what u mean lol let me ask questions then ;p
10:49:00 <sitlo> I started by having a helper function that takes a list of tries and returns a string of the chars in every one consecutively
10:49:37 <sitlo> but I can't quite call it on every individual Trie recursively cuz I am stupid ;/
10:49:53 <solrize> fluvian, passwords should only be used in some lightweight situations, in general keys should be completely random.  i realize you don't want to bloat up the ciphertext in a simple api like that but in something fancier you'd generate a random key for a given message or session, and use the kdf'd password (if at all) as a KEK (key-encrypting key)
10:50:31 <predator117> sitlo: that sounds like bfs, maybe you should try a dfs approach
10:51:12 <sitlo> u mean depth first search, okay, i'll try to implement that 
10:51:34 <nocturne777> > :i Applicative
10:51:35 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:51:57 <fluvian> solrize: it wouldn't clutter the API itself so I'm not opposed to it. does it really add more security though, compared to just using a KDF?
10:52:14 <fluvian> KDF + true random IV should be just as secure, no?
10:52:44 <nocturne777> why I can't get any info about "Applicative"  in ghci 7.8.4?
10:52:55 <solrize> no - passwords are terrible as sources of keys.  people use their spouse's name as their password etc
10:53:56 <fluvian> but if you use a PBKDF with KEK it improves security?
10:54:21 <fluvian> if someone has access to the decryption API they can still guess passwords
10:54:24 <solrize> using the password as a KEK means you can at least change the password without having to re-encrypt the message
10:55:08 <phaazon> huh
10:55:09 <fluvian> ah, so you would put the encrypted key in the header and just rewrite the header when you change the password
10:55:15 <phaazon> I have an error when uploading a package on hackage
10:55:25 <phaazon> it says that a file has a timestamp in the future
10:56:20 <catsup> nocturne777: did you :m +Control.Applicative ?
10:56:21 <nocturne777> it's in Control.Applicative
10:56:27 <solrize> well in the bytestring->bytestring api maybe you don't want that overhead.  you can put a key identifier there (64-bit hash of the key, say) or put it separately depending on the application
10:56:33 <nocturne777> catsup: I just figured it out :)
10:57:04 <gfixler> are :m + and :import the same?
10:57:07 <solrize> i have a python lib that does all that stuff, that i've been wanting to rewrite in haskell using more modern methods
10:57:12 <gfixler> I've always done :import
10:57:31 <fluvian> solrize: I'll keep an eye out for it on hackage ;)
10:57:35 <solrize> :)
10:57:56 <solrize> unfortunately my web site is down but the docs for the python lib are on it (i seem to have actually lost the code)
10:58:11 <fluvian> ah that's too bad
10:58:44 <fluvian> what do you think of the cipher-aes package that I used? it seemed to be the best choice for this use case, since the other packages don't seem to offer accessible authentication
10:58:50 <catsup> gfixler: :m lets you remove with - or reset the list with neither +/-
10:59:41 <gfixler> catsup: ooh, reset, eh?
11:00:05 <nocturne777> ":m" resets your imports
11:00:24 <gfixler> this is exciting news
11:00:32 <gfixler> I've been extracting each thing
11:00:40 <gfixler> subtracting*
11:01:50 <solrize> i haven't looked at cipher-aes, have you looked at snarc's stuff?  he's really on top of haskell crypto stuff, istm
11:02:33 <solrize> http://tab.snarc.org/posts/haskell/2012-07-07-building-a-better-haskell-aes.html
11:03:01 <solrize> that's kind of old but there's some other pages on his site
11:03:11 <solrize> anyway i haven't really done any crypto in haskell though i've been wanting to
11:03:55 <fluvian> yeah, cipher-aes is his
11:04:06 <fluvian> actually the page you linked is about cipher-aes :P
11:04:24 <fluvian> under the heading "One AES to rule them all"
11:06:38 <fluvian> he actually implemented AES in C/ASM to enable use of the AES-NI instructions
11:09:13 <solrize> oh cool :)
11:10:04 <solrize> i just wish he had some better key management stuff... that's what i'm wanting to write, i guess.  (it was most of my python lib)
11:12:51 <fluvian> at least there's a pbkdf library, I'll use that
11:13:07 <fluvian> from the System.Random documentation, "It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator."
11:13:18 <solrize> cool
11:13:45 <solrize> i mean, cool re pbkdf
11:14:05 <ph88> is it possible to do some kind of pattern matching that allows me to traverse a list from right to left ?
11:14:28 <solrize> for system.random you want the initialization to be good and the update mechanism to be good... and by that description either or both might be bad.
11:14:35 <solrize> ph88 example ?
11:14:59 <Cale> fluvian: Yeah, System.Random's initialisation is pretty sad
11:15:10 <Cale> It really does use the time
11:15:43 <phaazon> huhuhuhuhu
11:15:45 <phaazon> http://i.imgur.com/dtnmwdX.png
11:15:51 <phaazon> any idea what might cause such a nasty error?
11:16:26 <ph88> solrize: toDigits :: Integer -> [Integer]    toDigits should convert positive Integer s to a list of digits. (For 0 or negative inputs, toDigits should return the empty list.)     toDigits 1234 == [1,2,3,4]
11:17:13 <Cale> phaazon: The error message itself offers some suggestions
11:17:22 <phaazon> yeah 
11:17:31 <phaazon> but my system _is_ correct
11:17:40 <phaazon> I checked all the files
11:17:47 <arkeet> did you just enter DST?
11:17:48 <phaazon> they aren’t “in the future”
11:17:53 <phaazon> DST?
11:17:56 <arkeet> summer time
11:18:05 <phaazon> what
11:18:07 <phaazon> summer time what
11:18:20 <geekosaur> that should be tomorrow I think?
11:18:25 <arkeet> it is tonight.
11:18:28 <geekosaur> yeh
11:19:00 <ph88> solrize: this is my non-working attempt    let toDigits i | i `div` 10 == 0 = [i] | otherwise = toDigits (i `div` 10) : i `mod` 10
11:19:27 <phaazon> ok, let’s retry that
11:19:44 <arkeet> ph88: what is the type of (:) ?
11:20:11 <solrize> ph88 the thing on the right of the : is not a  list
11:20:19 <phaazon> arkeet: geekosaur Cale, nah, still doesn’t work
11:20:20 <ph88> arkeet: (:) :: a -> [a] -> [a]
11:20:21 <phaazon> wtf
11:20:44 <ph88> solrize: yes i know it doesnt work like that, hence my question earlier ...
11:21:07 <geekosaur> you aren't on a network filesystem, are you? things like that often happen with improperly time-synced nfs...
11:21:18 <solrize> > let toDigits i | i `div` 10 == 0 = [i] | otherwise = toDigits (i `div` 10) : [i `mod` 10]
11:21:20 <lambdabot>  not an expression: ‘let toDigits i | i `div` 10 == 0 = [i] | otherwise = toD...
11:21:23 <arkeet> phaazon: worst case you can just wait 47 minutes.
11:21:25 <arkeet> and try again.
11:21:45 <arkeet> with the same file
11:21:50 <phaazon> that’s insane
11:21:52 <phaazon> fucking time
11:21:53 <phaazon> :D
11:22:18 <solrize> ph88 look at the "otherwise" case in your example
11:22:25 <solrize> it has a : in it
11:22:26 <phaazon> is there a way to get the time of a server with curl?
11:22:29 <phaazon> curl -I?
11:22:32 <phaazon> is that in the header?
11:22:42 <phaazon> Date: Sat, 07 Mar 2015 19:20:20 GMT
11:22:44 <phaazon> oooh
11:22:48 <arkeet> hackage server has the correct time.
11:22:51 <solrize> what are the types of the terms on each side of the : ?
11:22:56 <arkeet> it is 19:20 UTC now.
11:22:58 <phaazon> it’s 20:20 here
11:23:08 <arkeet> what timezone are you in?
11:23:54 <ph88> solrize: single element : list
11:24:13 <arkeet> ph88: right, what you have is a list on the left, and a single element on the right.
11:24:21 <arkeet> so (:) is not the thing to use here.
11:24:30 <phaazon> arkeet: I just reconfigured my time
11:24:32 <arkeet> (at least, not directly.)
11:24:39 <phaazon> to be able to send the package
11:24:50 <phaazon> yeah it works now :D
11:24:51 <ph88> arkeet: can it be done without using the list reverse function ?
11:25:05 <arkeet> ph88: yes
11:25:26 <arkeet> hint: adding a single element to the end is the same as appending a 1-element list
11:25:29 <ph88> arkeet: i'm stuck at this point. Even though i already read many chapters of LYAH
11:26:46 * hackagebot smoothie 0.1.1 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.1.1 (DimitriSabadie)
11:26:56 <Zemyla> Oh, do you know what else is missing from the array package?
11:27:15 <Zemyla> Besides a foldable implementation?
11:28:17 <Zemyla> A sort function.
11:28:49 <Haskellfant> could someone point me to simple c bindings that use c2hs? I read ezyangs blogposts and understand the basic examples but I am having trouble understanding how to work with a huge nested struct
11:29:13 <arkeet> I was going to suggest using vector instead, but apparently that also has neither of those things.
11:32:41 <ph88> arkeet: that appending the one element list to the end gives me this error http://lpaste.net/5825729417371975680
11:33:03 <arkeet> well : isn't quite the thing to use for appending lists.
11:33:20 <ph88> oh
11:33:29 <ph88> ok i will google for it
11:33:33 <arkeet> you have a list on both sides
11:33:39 <arkeet> so you are looking for something like [a] -> [a] -> [a]
11:34:23 <ph88> arkeet: i found it. Thank you very much for assistence
11:34:28 <arkeet> np
11:34:31 <monochrom> to append, use ++, example: [1,2,3] ++ [9]
11:34:32 <ph88> i remember this operator now
11:34:40 <ph88> takes some time to know everyhing by heart
11:40:14 <yamadapc> Hey guys
11:43:07 <Cale> yamadapc: hello!
11:43:29 <yamadapc> I'm implementing multiple concurrent progress bars into https://github.com/yamadapc/haskell-ascii-progress, and I have a little doubt. There can't be multiple threads writing to the terminal at the same time, or else moving up and down to update a running progress bar will end up being all messed up. I added an `MVar` lock to prevent multiple threads from writing at the same time (there also could be a single writer Thread). I'm wondering h
11:43:30 <yamadapc> ow ugly that is.
11:44:33 <osa1> trac wiki is down https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects ;-(((
11:45:18 <Cale> yamadapc: You might prefer the approach of having a Chan (IO ()) or something with a single thread that reads from the Chan and carries out terminal I/O
11:46:32 <yamadapc> Oh... `Chan (IO ())` is funny concept.
11:47:07 <yamadapc> Is that strictly better though? The users would then have to initialise the library 
11:47:36 <Cale> Well, you already have to share an MVar, no?
11:48:01 <yamadapc> Yeah... Can't I use unsafePerformIO to share a global MVar? hehe
11:48:08 <EvanR> same as a Chan
11:48:14 <EvanR> same evil!
11:49:14 <Cale> EvanR: Well, he does have a point with respect to the fact that you now have a running thread in addition to the global state
11:49:31 <monochrom> gtk2hs uses Chan (IO ()) for those "you need to post an action asyncly so only the main thread calls GTK" things
11:51:57 <yamadapc> Maybe if the progress bars need to be `started` explicitly, this wouldn't be a problem. Something in the lines of `start :: [ProgressBar] -> IO ThreadId`. Then for every set of progress bars you have a single writer thread, a channel, etc.
12:00:41 <Cale> yamadapc: and of course, instead of a ThreadId, you could give back an IO action to stop them.
12:01:32 <yamadapc> makes sense
12:01:49 <Cale> yamadapc: Or even a record containing that and methods for getting and setting them.
12:02:04 <monochrom> give a man an IO action, and he can stop your thread for a day. give him your ThreadId, and he can stop your thread for life.
12:02:53 <EvanR> Fix IO
12:04:11 <yamadapc> what?
12:04:24 <yamadapc> haha
12:04:51 <yamadapc> Cale: getting and setting progress you mean?
12:05:19 <vbogatyrev> good evening 
12:07:01 <Cale> yamadapc: yaeh
12:07:03 <Cale> yeah*
12:09:18 <Javran> about MonadPlus: I noticed that one of its properties states that "v >> mzero = mzero", is this saying that when something is wrong, "v"'s effect should also be cancelled?
12:10:12 <hseg> Javran: I think so.
12:10:44 <Cale> Javran: Yes, though that law doesn't hold of some instances.
12:10:55 <HeladoDeBrownie> i was just thinking, "wait, does that even hold for []"?
12:11:03 <Javran> I see
12:11:06 <Cale> it holds for []
12:11:14 <Cale> But it won't hold for IO
12:11:18 <HeladoDeBrownie> > [1, 2, 3] >> []
12:11:20 <lambdabot>  []
12:11:21 <hseg> Javran: But that law doesn't seem to be useful.
12:11:21 <HeladoDeBrownie> right, of course
12:11:26 <Javran> now I know why IO isn't a MonadZero
12:11:29 <Cale> It is useful
12:11:47 <Cale> ?
12:11:52 <Cale> Wait, what?
12:12:02 <Javran> oops sorry
12:12:05 <Javran> I meant MonadPlus
12:12:08 <Cale> IO is a MonadPlus with exceptions isn't it?
12:12:15 <hseg> Cale: How come? Your monad needs to hold onto the entire call stack, as it might potentially rewind the entire effect tree.
12:12:17 <HeladoDeBrownie> no instance for MonadPlus IO listed there
12:12:36 <Cale> hseg: look at []
12:12:39 <Cale> and Maybe
12:12:48 <hseg> On the other hand, what you're probably thinking of is the law mzero >>= k = mzero.
12:12:53 <Cale> also Parser
12:13:33 <Cale> Typically p >> mzero = mzero for parsers
12:13:49 <Javran> looks like "p >> mzero = mzero" means the ability to do backtracking
12:13:54 <HeladoDeBrownie> hseg, doesn't need to go to that bother when it can just not bother evaluating the left side
12:14:06 <Cale> Javran: Maybe doesn't really have backtracking.
12:15:21 <Javran> Cale: but Maybe can only have one option at most
12:15:22 <Rotaerk> "backtracking"?
12:16:31 <Javran> v's effect can be cancelled depending on a future computation.
12:16:49 * hackagebot hlibBladeRF 0.1.0.4 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.4 (eocallaghan)
12:16:50 <Javran> maybe it's more about list
12:17:14 <hseg> That's a very odd law.
12:17:35 <Cale> Rotaerk: Lists and (some) parsers have backtracking nondeterminism, where each action effectively produces multiple different results, and so if one branch fails to produce a result (e.g. via mzero), you can go back and try other choices from previous computations.
12:17:45 <HeladoDeBrownie> Javran, i think you're thinking about (>>) too much as if it were some notion of "sequencing". you could easily evaluate the right side then the left side in many cases, for example.
12:17:50 <Rotaerk> ah
12:18:06 <HeladoDeBrownie> Javran, or, evaluate the right side and notice you don't *need* to evaluate the left side
12:18:17 <hseg> As I said above, it requires the monad to either have revertable effects, or hold onto the entire call tree.
12:18:22 <Rotaerk> I never really thought of lists as "nondeterminism", but I suppose they can be considered that way
12:18:34 <HeladoDeBrownie> hseg, did you see my response to that?
12:18:57 <HeladoDeBrownie> hseg, also, there isn't even necessarily a reasonable notion of "effects"
12:18:59 <EvanR> grumble at notion of call tree
12:19:03 <Javran> HeladoDeBrownie: could you give some example?
12:19:07 <Javran> :t (>>)
12:19:08 <lambdabot> Monad m => m a -> m b -> m b
12:19:12 <Javran> :t (>=>)
12:19:13 <Cale> Yeah, I don't get what hseg means by "call tree"
12:19:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:19:14 <hseg> HeladoDeBrownie: Yes. Lists and parsers just revert all effects by destroying the nondeterminism
12:19:20 <Cale> What is a call?
12:19:35 <HeladoDeBrownie> Javran, the Maybe implementaiton of (>>) could evaluate the right side, see it's Nothing, then just return Nothing.
12:20:21 <HeladoDeBrownie> hseg, i'm unclear on what you mean by "destroying the nondeterminism"
12:20:41 <hseg> Sorry for my lack of clarity. It is a concept I don't fully understand.
12:20:53 <hseg> Let me try again.
12:20:57 <HeladoDeBrownie> hseg, i think that your intuition is misguiding you
12:21:02 <hseg> Maybe
12:21:49 * hackagebot markup-preview 0.2.2.1 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.2.2.1 (MariusGhita)
12:21:54 <Javran> HeladoDeBrownie: I think monad laws enforce you to get left hand side done before examing right hand side
12:22:09 <HeladoDeBrownie> Javran, which law(s) say(s) that?
12:22:16 <Javran> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Maybe.html#Maybe and (>>) isn't implemented the way you said
12:22:32 <HeladoDeBrownie> Javran, i didn't say it was implemented that way in base, i said it could be implemented that way
12:22:40 <HeladoDeBrownie> you'd get exactly the same result
12:22:54 <Javran> even for undefined?
12:23:07 <Javran> > undefined >> Nothing
12:23:09 <lambdabot>  *Exception: Prelude.undefined
12:23:16 <HeladoDeBrownie> no, not for undefined, you're right
12:23:24 <HeladoDeBrownie> often we just ignore that though
12:24:06 <Cale> Usually equational laws for type classes only apply to the fully defined values of the type
12:24:24 <Javran> I think it's the associativity of (>=>)
12:25:22 <Cale> You can state the monad laws in terms of (>=>) and return, and they basically just say that (>=>) is associative and return is a unit for it. (i.e. the Kleisli category is a category)
12:26:29 <Javran> I like to state monad laws in terms of (>=>)/(<=<) and return, that looks decent 
12:28:24 <Cale> The downside is that if you have them in that form, you have to do slightly silly looking things to recover the usual laws in terms of fmap/return/join or return/(>>=)
12:28:40 <ph88> is it possible to take elements from the right side of the list without using the list reverse function ?
12:29:02 <HeladoDeBrownie> ph88, you can drop the elements before them. e.g., drop 10 to drop 10 elements
12:29:09 <HeladoDeBrownie> ph88, what exactly do you want to do?
12:29:56 <ph88> HeladoDeBrownie: i want to make a function like this  doubleEveryOther [8,7,6,5] == [16,7,12,5]   where i double every second number from the RIGHT side of the list
12:31:06 <HeladoDeBrownie> hmm, well, one way might be to determine first whether the list's length is even or odd, though that might not be much less work if any.
12:33:33 <arkeet> there might be a really sneaky way of doing it.
12:34:03 <Hijiri> is this the cis194 one
12:34:20 <arkeet> probably not really any better than looking at the length of the list though.
12:35:02 <hseg> OK. Basically, the idea I'm trying to get across is this. You can express many monads we care about as free monads. e.g. StateF s r = Get (s -> r) | Put s r
12:35:02 <hseg> and State s = Fix (State s).
12:35:02 <hseg> Now the monad instance will give you morphisms join :: StateF s (StateF s r) -> StateF s r and return :: r -> StateF s r (modulo isomorphism).
12:35:02 <hseg> That is, the monad instance allows you to get just one layer of monadicity. If we build the graph of the StateF nodes in a value of type StateF, we will get a tree. This is true for all free monads.
12:35:02 <hseg> Now the law v >> mzero = mzero requires one of two things. Either you keep your tree as it is and statically scan it for occurrences of mzero before applying the effects (expensive, not usually done) or your effects are such that some (possibly effectful) computation will cancel them.
12:35:02 <hseg> In the case of lists, we use the latter option. The null nondeterministic computation cancels out all nonderminism effects we might have had.
12:35:02 <hseg> I hope this is clearer. But it probably isn't.
12:35:03 <hseg> cf. http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
12:35:10 <hseg> Sorry for the wall of text.
12:39:09 <hseg> And it turns out Oleg has already given a clearer explanation: https://stackoverflow.com/questions/15722906/must-mplus-always-be-associative-haskell-wiki-vs-oleg-kiselyov#15853770
12:42:00 <Haskellfant> how can I marshall argc (an int) & argv (a pointer to a char) into a list of haskell strings using c2hs? I only find examples of marshalling a single string or a string + length, but that is not what is needed here as there are multiple strings 
12:42:35 <Hijiri> I thought arv was a pointer to pointer to char
12:42:37 <Hijiri> argv
12:42:47 <Haskellfant> Hijiri: oh right, sorry
12:43:03 <Haskellfant> doesn't change the fact that I have no idea how to marshall that :)
12:43:15 <Hijiri> maybe you can marshall to list of Ptr Char, and then marshall those into strings?
12:44:04 <Hijiri> with peekArray
12:44:21 <Cale> peekArray :: Storable a => Int -> Ptr a -> IO [a]
12:44:35 <Cale> yeah
12:44:45 <Haskellfant> ah that looks like the right thing
12:51:51 * hackagebot effect-handlers 0.1.0.2 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.2 (edofic)
12:58:33 <xplat> deep handlers?
13:00:01 <Haskellfant> hm c2hs tries to use CBool for a bool from stdbool.h, but that type doesn't seem to exist. hoogle doesn't know it and hayoo only finds it in atom and FerryCore. Where do I get CBool from?
13:00:29 <safinaskar> hi
13:00:37 <safinaskar> is there incapsulation in haskell?
13:01:21 <safinaskar> i. e. it is possible to create datatype, then create some functions which returns this datatype and then deny directly calling raw constructors of this datatype?
13:01:59 <kadoban> safinaskar: Yes, via modules. You can choose what you export.
13:02:02 <exio4> safinaskar: you make a module with that datatype, and then you don't export the constructors, but the type and the functions working with it
13:03:52 <safinaskar> kadoban: exio4: i have to put module to separate file, right?
13:04:08 <Cale> Yes, that's right.
13:04:42 <Cale> iirc, there was nothing in the standard which requires that modules go in separate files, but in practice the implementations demand it in order to be able to know where to look for them
13:05:45 <xplat> the standard originally didn't have hierarchical namespaces
13:13:04 <whiteline> is this sensible: http://pastebin.com/A8GeNe4E
13:13:37 <safinaskar> kadoban: exio4: Cale: xplat: thanks
13:14:30 <Cale> whiteline: Not how I'd write it :P
13:15:28 <whiteline> Cale: elaborate
13:16:07 <Cale> It feels like you're trying a bit too hard to be points free at the expense of clarity
13:16:50 <whiteline> but there are no, like, technical reasons I can't express it like that?
13:17:06 <Cale> That's a better question to ask your compiler
13:18:52 <Cale> Oh also consider moving the type signatures off of the expressions and making proper declarations for them
13:18:56 <safinaskar> is there possible to generate yacc/happy-like parser in runtime?
13:19:21 <safinaskar> i. e. i want my haskell program to add new productions to yacc/happy-like parser in runtime. is there possible?
13:19:22 <Cale> You'll thank me when you eventually want to generate documentation for your modules
13:19:23 <whiteline> Cale: yeah, i just pasted it in from ghci let statements
13:19:38 <whiteline> i ususally write it properly
13:21:53 * hackagebot ascii-progress 0.2.1.0 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.2.1.0 (yamadapc)
13:22:01 <Cale> @pl a >->+> b = curry $ a >>> curry b
13:22:01 <lambdabot> (line 1, column 12):
13:22:01 <lambdabot> unexpected " "
13:22:11 <Cale> @pl fish a b = curry $ a >>> curry b
13:22:11 <lambdabot> fish = (curry .) . (. curry) . (>>>)
13:22:18 <Cale> there you go, lol
13:22:47 <whiteline> neat
13:22:50 <Cale> @pl fish a b = curry $ a >>> uncurry b
13:22:50 <lambdabot> fish = (curry .) . (. uncurry) . (>>>)
13:23:51 <KaneTW> :5 (.)
13:23:54 <KaneTW> :t (.)
13:23:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:39:11 <quchen> Cale: Fish is a reserved word for >=>
13:39:49 <Cale> @quote fish
13:39:49 <lambdabot> monochrom says: the selfish program's motive is to fool the programmer
13:39:52 <Cale> @quote fish
13:39:52 <lambdabot> Cale says: Cale's Lemma: Any sufficiently long string of operator symbols looks like a fish.
13:39:59 <Cale> there we go, haha
13:40:11 <quchen> Cale: I stand corrected. Lambdabot is normative.
13:40:32 <bitemyapp> @quote quchen
13:40:32 <lambdabot> quchen says: A syntax highlighter for vomit.
13:40:35 <quchen>  ?remember quchen Lambdabot is normative.   -- in case anyone doubts it
13:40:44 <bitemyapp> @quote normative
13:40:44 <lambdabot> No quotes match. I don't think I can be your friend on Facebook anymore.
13:40:50 <bitemyapp> kay.
13:41:05 <quchen> bitemyapp: I do not recall what I might have said that about.
13:46:55 <funfunctor> Off-topic but WUT!? http://directorsblog.nih.gov/2015/03/05/shattering-news-how-chromothripsis-cured-a-rare-disease/
13:47:13 <Cale> funfunctor: #haskell-blah
13:47:35 <funfunctor> Cale don't you ever sleep !?
13:47:49 <Cale> huh?
13:47:54 <Cale> I slept
13:48:07 <Cale> It's 16:45 here
13:48:38 <Cale> I just have highly irregular sleep patterns
13:53:27 <funfunctor> so it looks like I am able to use the vector space package to do some real calculations on real signals coming in from radio hardware in Haskell as of today!
13:53:34 <funfunctor> pretty cool really
13:54:03 <Cale> nice
13:55:05 <quchen> Cale sleeps regularly: every tuesday
13:55:23 <funfunctor> bbl
13:56:01 <Cale> http://ircbrowse.net/nick/Cale
13:56:24 <Cale> My active hours graph :D
13:57:43 <Cale> http://ircbrowse.net/nick/Cale?recent=false
13:58:55 <WinniFrog> argh
13:58:58 <greato> is polyphasic sleeping useful?
14:02:24 <NemesisD> newtype JSONable = JSONable (forall a. (ToJSON a) => a), instance ToJSON JSONable where toJSON (JSONable x) = toJSON x gives me errors about a type variable being ambiguous. what's up with that
14:02:35 <Cale> Calling what I do polyphasic sleeping would be silly. There is no plan.
14:02:40 <tomberek> is anyone familiar with the syntax specification of haskell?
14:03:15 <tomberek> I'm trying to decipher a particular line: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/arrow-notation.html   what does "with cmd0 up to cmd9 defined using infix operators as for expressions" mean?
14:04:32 <tomberek> what do those superscripts mean?
14:04:43 <heatsink> they're probably precedences
14:04:48 <heatsink> as in "infix 9"
14:06:02 <heatsink> cmd0 would be expressions where the operator has precedence 0, and subexpressions may have higher-precedence operators
14:06:37 <tomberek> interesting, though then the next line starts defining cmd10: :: = \ apat ...
14:08:09 <Cale> tomberek: right, so that's *after* all those precedence levels, i.e. those things bind more tightly than any infix operator
14:08:49 <tomberek> ah!, I see
14:09:32 <heatsink> Since 'let' binds more tightly than infix operators, does that mean that let {} in f @@@ x is parsed as (let {} in f) @@@ x ?
14:09:32 <Cale> https://www.haskell.org/onlinereport/syntax-iso.html -- nearer the bottom than the top, you'll see how exp^i is defined
14:11:02 <Cale> the grammar is ambiguous with respect to lambda abstractions, let expressions and conditionals, and the ambiguity is resolved in the opposite way from what you're suggesting
14:11:16 <Cale> Each of those constructs extends as far to the right as possible
14:11:37 <tomberek> ok... that makes more sense
14:12:03 <heatsink> ok
14:15:20 <tomberek> Cale: the last thing is that I'm not sure if the cmd10 ::== \apat ... apat -> cmd   line is implemented properly,,, i can't get any expression of that form to work
14:16:13 <tomberek> I'm writing a quasiquoter for arrows notation. The standard quoter [|  |]  does not have support for proc notation, so i'm building it after parsing with haskell-src-exts,, i'd like to conform to the standard
14:18:44 <tomberek> what exactly does something like this mean:   proc n -> \a -> returnA -< n ?
14:21:36 <Cale> hm, I can't get it to parse either, but I can with parens
14:21:43 <Cale> > (proc x -> do { y <- \v -> v+v -< x ; returnA -< y }) 5
14:21:45 <lambdabot>  Pattern syntax in expression context:
14:21:45 <lambdabot>      proc x -> do { y <- \ v -> v + v -< x;
14:21:45 <lambdabot>                     returnA -< y }
14:21:55 <Cale> > (proc x -> do { y <- (\v -> v+v) -< x ; returnA -< y }) 5
14:21:56 <lambdabot>  Pattern syntax in expression context:
14:21:57 <lambdabot>      proc x -> do { y <- (\ v -> v + v) -< x;
14:21:57 <lambdabot>                     returnA -< y }
14:22:05 <Cale> uh, what?
14:22:14 <Cale> the latter expression works in ghci
14:24:19 <tomberek> Cale: that a lambda in a do
14:24:36 <tomberek> so that lambda is a cstmt
14:24:43 <tomberek> not cmd10
14:25:07 <Cale> oh, right
14:25:50 <pavonia> proc n -> \a -> returnA -< n  ===  proc (n, a) -> returnA -< n, I think
14:26:13 <tomberek> pavonia: yes, that's what the Arrow papers specify
14:26:14 <Cale> yeah, I'm not even sure what that case is for really
14:26:23 <tomberek> but I don't think GHC actually implements it
14:26:30 <Cale> That's a weird corner of the syntax I've never used
14:26:45 <Cale> oh, no wait
14:26:49 <Cale> look at cstmt
14:26:57 <Cale> It recursively uses cmd
14:27:07 <Cale> So my lambda really was part of a cmd
14:28:00 <callumacrae> I'm not writing haskell right now, but I am trying to write functional code
14:28:06 <tomberek> Cale: no, it was an expr10
14:28:17 <callumacrae> Is there a good variable naming thing I can do to mean one or more of?
14:28:19 <tomberek> cmd   ::= exp10 -<  exp
14:28:46 <callumacrae> Eg I havea  function which deals with one or more elements, argument could be either "element" or "elements", one reads weirdly whichever I choose
14:28:54 <Cale> tomberek: Oh, you're right
14:29:18 <tomberek> so, expanded out......      y <- (\v -> v+v) -< x     is     pat <- expr10 -< expr
14:29:26 <Cale> callumacrae: In Haskell, we usually name list arguments something like xs or ys
14:29:32 <Cale> callumacrae: i.e. plural
14:29:52 <Cale> yeah
14:29:54 <callumacrae> fair enough. i guess my question is completely invalid in here anyway
14:30:16 <callumacrae> because it's a function that accepts either an array or a single value, and that wouldn't work in haskell
14:30:18 <tomberek> my suspicion is that the lambda part of cmd10 is not implemented correctly in GHC, but I'm not sure... is this worth a ticket?
14:30:19 <callumacrae> I didn't think that one through
14:30:45 <Cale> callumacrae: One general rule of thumb about naming that I think is generally applicable: names should get longer the larger their scope is, and shorter the more frequently they're used.
14:32:11 <Cale> callumacrae: If the entire scope of a variable is within a few lines, it's acceptable for it to be a single character. If it's a function which is exported, it should have a descriptive name, but the name should be shorter if you expect that it will be used a lot.
14:32:29 <callumacrae> awesome, thanks
14:32:53 <callumacrae> that didn't answer my question at all, but that's because it was a stupid question. I am learning haskell too though, so that's pretty useful to know!
14:33:23 <Cale> Well, that remark really had nothing to do with Haskell in particular
14:33:40 <Cale> I think it's appropriate in essentially all programming languages
14:34:36 <callumacrae> fair point
14:36:08 <Cale> callumacrae: Oh, I suppose I could say -- when the type of something is very polymorphic, such that you don't know what sort of thing it is that you have, it tends to be appropriate that the name is short, because nothing descriptive is possible.
14:36:33 <Cale> Words like "element" aren't usually much better than "x"
14:36:57 * hackagebot lens 4.8 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.8 (EdwardKmett)
14:38:15 <edwardk> a new lens is born, now with 100% fewer unsafeCoerces (on modern GHCs)
14:38:44 <Cale> nice
14:39:46 <c_wraith> what are we going to do without unsafeCoercing?
14:39:57 <Zemyla> Well, that was fun. I got GHC to panic.
14:40:37 <Zemyla> And by "fun" I mean "annoying".
14:40:39 <c_wraith> does ghc's brain still explode if you pattern-match a GADT in a let binding?
14:40:41 <quchen> edwardk: Oh, the unsafeCoerce count in the topic is missing as well!
14:41:41 <Zemyla> c_wraith: No, I was trying to write code to use SIMD tuples.
14:41:58 * hackagebot hindent 4.4.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.4.0 (ChrisDone)
14:42:40 <tomberek> edwardk: what made it possible to remove the coerce?
14:43:11 <glguy> The new Coercible machinery
14:43:13 <edwardk> tomberek: we switched Data.Profunctor.Unsafe to use 'coerce' rather than 'unsafeCoerce' on GHC 7.8+
14:43:47 <edwardk> then i worked with glguy and we killed all the uses of unsafeCoerce in lens using that change and a couple of judicious applications of CPP
14:43:55 <hseg> Nice. Searching for the relevant commits...
14:44:12 <glguy> The relevant commits are in the profunctors repository, mostly
14:44:25 <glguy> lens was using unsafeCoerce by association
14:44:28 <edwardk> c_wraith: yes it does
14:44:46 <edwardk> there were something like 6 unsafeCoerce's left in lens after the profunctors change
14:45:11 <edwardk> most of them before were through calls to (#.) and (.#)
14:55:55 <Zemyla> edwardk: The latest version has no documentation. How long does that take?
14:56:28 <edwardk> Zemyla: up to 12 hours or until glguy or i remember how to build it and push it directly
14:57:01 <HeladoDeBrownie> edwardk, was this ghc changing in response to a library need or did lens just happen to benefit?
14:57:52 <edwardk> HeladoDeBrownie: ghc added coerce as part of the work on roles. it is used internally to make GeneralizedNewtypeDeriving no longer able to cause segfaults
14:58:15 <edwardk> HeladoDeBrownie: lens is just using that machinery to get rid of a bunch of unsafeCoerces that now GHC can prove are okay
14:58:21 <HeladoDeBrownie> ah, neat
14:58:45 <HeladoDeBrownie> what about the remaining ones?
14:58:55 <HeladoDeBrownie> are those potentially provable okay?
15:01:07 <glguy> Oh, docs are easy, one sec
15:01:10 <mpickering> How can I see which cpp is invoked?
15:02:02 <glguy> Zemyla: docs are up
15:02:26 <c_wraith> mpickering: not much of an easier way than searching the source for lines that start with #
15:03:02 <mpickering> how does that help to see which program is used? is it always cpphs?
15:03:25 <c_wraith> mpickering: oh, whoops. I totally misunderstood your question
15:03:52 <mpickering> I have a problem where the preprocessor adds extra blank lines to the end of my file
15:03:55 <c_wraith> mpickering: I don't actually know the answer to your question! :)
15:04:18 <mpickering> and I don't even know how to start to debug this :)
15:06:59 * hackagebot zlib-lens 0.1.1.2 - Lenses for zlib  http://hackage.haskell.org/package/zlib-lens-0.1.1.2 (EdwardKmett)
15:10:04 <edwardk> HeladoDeBrownie: they are all gone. its just that ~6 of them had to have some special casing in the library
15:10:23 <HeladoDeBrownie> edwardk, what special casing?
15:10:36 <edwardk> CPP
15:11:17 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Prism.hs#L99 and https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Coerce.hs
15:11:29 <edwardk> the latter is used in a couple of places
15:12:08 <edwardk> the fact that coerce' isn't just 'coerce' is kind of annoying
15:13:00 <HeladoDeBrownie> edwardk, oh, i see. so you only use unsafeCoerce when it's not implemented by the current ghc?
15:13:22 <HeladoDeBrownie> s/it's/coerce is/
15:24:07 <ion> Why is coerce' needed?
15:24:21 <Zemyla> edwardk: What's my best resource for figuring out how the lens library works behind the scenes?
15:24:32 <glguy> Because the Coercible constraint solve doesn't know that Coercible a b given Coercible b a (on its own)
15:27:01 <Zemyla> Like, what are markets and bazaars?
15:27:32 <ion> And GHC doesn’t generate Coercible instances both ways?
15:27:56 <glguy> Suppose you declare a function: f :: Coercible a b => [a] -> [b]
15:28:11 <glguy> all that the solver knows is Coercible a b, it doesn't know Coercible b a
15:28:21 <glguy> For concrete types it knows both
15:28:37 <ion> Ok, thanks
15:29:16 <hseg> But isn't Coercible supposed to witness a certain -for lack of a better word - isomorphism of the types?
15:30:44 <glguy> In this context it's just a constraint, nothing magic
15:31:31 <homovitruvius> what would be a good way for keeping configuration for different passes of a compiler separate? separate Reader monads? not worth the effort?
15:32:10 <bananagram> is irc a stable library?
15:32:28 <hseg> Yes. But I'd then expect the instance Coercible a b => Coercible b a
15:32:34 <bananagram> I heard it wasn't a long time ago, and am not sure it's a good source
15:34:19 <glguy> bananagram: If you're in the market for an irc library you might look at the one I'm working on now for my client
15:34:31 <glguy> bananagram: http://github.com/glguy/irc-core
15:34:51 <glguy> It's probably less stable since I'm actively working on it, but it has a lot of stuff
15:36:33 <glguy> The irc library is "stable" though, Trevor's not actively working on it now
15:42:00 <Zemyla> Oh, edwardk, question about your latest article.
15:43:20 <Zemyla> Your free monoid class makes me wonder, could one declare (Monoid r) => MonadPlus (ContT r)?
15:45:01 <Zemyla> Wait, hmm/
15:45:09 <Zemyla> Possibly not. :V
15:50:09 <bananagram> glguy: I'll check it out
15:52:35 <bitemyapp> bananagram: I've really liked it so far.
15:53:01 <osa1> does anyone know any conduits vs. pipes articles?
15:53:53 <bitemyapp> osa1: Gonzalez and Snoyman have both written about it.
15:55:18 <quchen> osa1: There's also the Haskell Cast with both of them as guests.
15:56:08 <solrize> git-annex is written in haskell????  i never knew that
15:56:11 <osa1> thanks for pointers
15:56:14 <randir> What Haskell web server would you guys recommend for a simple blog system?
15:57:17 <dmj`> randir: hakyll 
15:58:21 <peddie> solrize: you must be better at using it than I am, because mine constantly spits out "Prelude.head: empty list" :P
15:59:16 <xplat> peddie: to be fair, randir asked for simple, not easy ;)
15:59:30 <peddie> xplat: I was talking about git-annex
15:59:54 <xplat> peddie: oh.  i don't think i ever got git-annex to do that ..l.
16:00:43 <xplat> Zemyla: if you mean 'list is not the free monoid', dolio actually wrote that.
16:01:22 <xplat> hseg: that instance would overlap with everything.  luckily, though, you can coerce the a and b in Coercible a b with coerce!
16:01:46 <dolio> Zemyla: Yes, you can declare that.
16:02:11 <dolio> Well, not ContT r.
16:02:16 <dolio> But Cont r.
16:02:42 <dolio> And (Monoid r, Applicative f) => MonadPlus (ContT r f)
16:04:32 <hseg> xplat: Dammit, you're right. Don't understand your second half though.
16:05:05 <Zemyla> Oh, wait, wow, I just realized the simplest possible way to do restricted monads ever.
16:05:42 <exio4> Zemyla: which is? :p
16:07:35 <Zemyla> You use codensity. newtype RMonad m a = RMonad { runRMonad :: forall b. (Suitable m b) => (a -> m b) -> m b }
16:11:09 <Zemyla> For instance, SetMonad a = SetMonad { runSet :: forall b. (Ord b) => (a -> Set b) -> Set b }
16:13:26 <Zemyla> Then embed s = SetMonad $ (`F.foldMap` s) and unembed s = runSet s S.singleton.
16:15:02 <hseg> Anyone got a better rewrite of http://pastebin.com/A8GeNe4E than the following:
16:15:02 <hseg> let { (f %-> g) a b= f a . g b; clamp = max %-> min } in uncurry fmap . ((chr.) . xor . clamp 0 255 *** fmap ord)
16:15:45 <hseg> let clamp a b= max a . min b in uncurry fmap . ((chr.) . xor . clamp 0 255 *** fmap ord)
16:16:11 <Javran> @quote edwardk Codensity
16:16:12 <lambdabot> edwardk says: you can view Yoneda f as enforced fmap fusion and Codensity f as enforced bind fusion.
16:18:33 <shachaf> Zemyla: That representation of Sets is a monad but it's pretty bad.
16:21:15 <Zemyla> shachaf: Why so?
16:23:26 <mpickering> ghc.haskell.org down?
16:23:56 <MP2E> works for me
16:24:01 <MP2E> it was a little slow
16:26:18 <mpickering> I'm just hitting the cloudflare page
16:29:45 <shachaf> Zemyla: Take the simpler version, the Coyonedaization of Set.
16:30:22 <shachaf> If you fmap f . fmap g, and g collapses a lot of points to the same point, you'll do a lot of repeated work.
16:31:01 <osa1> can anyone help me with my hslogger problem? even if I remove all the handlers, my logging calls are printed to stdout. any ideas why?
16:32:21 <Zemyla> Hmm. Is this fixable at all?
16:34:44 <osa1> never mind, I was using wrong logger name
16:37:02 <Zemyla> Codensity seems to force right association of binds, but what we want is left association whenever possible.
16:47:11 <Zemyla> shachaf: Oleg says basically that you need to specifically wrap . unwrap on the set whenever possible.
16:47:54 <zubir> greetings
16:48:26 <Vektorweg> whats the difference between type families and functional dependencies in efficient problem solving coverage?
16:48:33 <zubir> wat
16:49:12 <Vektorweg> zubir: wat, wat?
16:49:21 <zubir> ……………………………………….¸„„„„
16:49:21 <zubir> …………………….…………...„--~*'¯…….'\
16:49:21 <zubir> ………….…………………… („-~~--„¸_….,/ì'Ì
16:49:21 <zubir> …….…………………….¸„-^"¯ : : : : :¸-¯"¯/'
16:49:21 <zubir> ……………………¸„„-^"¯ : : : : : : : '\¸„„,-"
16:49:23 <zubir> **¯¯¯'^^~-„„„---~^*'"¯ : : : : : : : : : :¸"
16:49:26 <zubir> .:.:.:.:.„-^" : : : : : : : : : : : : : : : : :„-"
16:49:28 <zubir> :.:.:.:.:.:.:.:.:.:.: : : : : : : : : : ¸„-^¯
16:49:31 <zubir> .::.:.:.:.:.:.:.:. : : : : : : : ¸„„-^¯
16:49:33 <zubir> :.' : : '\ : : : : : : : ;¸„„-~"
16:49:36 <zubir> :.:.:: :"-„""***/*'ì¸'¯
16:49:38 <zubir> :.': : : : :"-„ : : :"\
16:49:41 <zubir> .:.:.: : : : :" : : : : \,
16:49:45 <Vektorweg> a parser combinator? 
16:49:46 <zubir> :.: : : : : : : : : : : : 'Ì
16:49:46 <zubir> : : : : : : :, : : : : : :/
16:49:48 <zubir> "-„_::::_„-*__„„~"﻿
16:49:52 <zubir> 　　　　　　　　＿　＿
16:49:52 <zubir> 　　　　　　　 ／::.　ｿ .::;;ヽ
16:49:54 <zubir> 　　　　　　 /::.　　　　 ..:::;;;ヽ
16:49:56 <zubir> 　　　　 　 /::.　　　　　　..::;;;;ヽ
16:49:59 <zubir> 　　　　　/::.　　　　　　　 ..::::;;;;i
16:50:01 <zubir> 　　　　 （::.　　　　　　　　..::;;;丿
16:50:04 <zubir> 　　　　　　>::...＿＿＿..::::;;;イ
16:50:06 <zubir> 　　　　　　!ヾ.￣⌒_＿￣彡|
16:50:09 <zubir> 　 　 　 　 iﾐ:::ミＣ＝　≡..:::　）
16:50:11 <zubir> 　　　　　　|::::　　　　　″. ´/
16:50:14 <zubir> 　　　　　　|:::::　ヽ 　　　/ /;|
16:50:14 <quchen> ?where ops
16:50:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:50:16 <zubir> 　　　　　　|::: （ '　　　（　.::;;;|
16:50:19 <zubir> 　　　　　　|:::　| ﾐ　　　.ヽ＼|
16:50:21 <zubir> 　　　　　　|:::　丶ヽ　　..:ヽ ）
16:50:24 <zubir> 　　　　　　|::: 　 .i　!　　 ::;;;;;|
16:50:26 <zubir> 　　　　　　|::: 　 i .ﾉ 　 . ::;;;;;|
16:50:29 <zubir> 　　　　　　|::: 　 i .ﾉ 　 . ::;;;;;|
16:50:31 <zubir> 　　　　　　|::: 　 i .ﾉ 　 . ::;;;;;|
16:50:49 --- mode: ChanServ set +o geekosaur
16:50:49 <geekosaur> mm, services under attack?
16:50:52 --- mode: geekosaur set -o geekosaur
16:50:54 <gyaretto> Hm.
16:50:57 <randir> anyone have any idea what that's supposed to be?
16:51:08 <randir> just junk data, or something else?
16:51:11 <quchen> randir: Spam not to be commented on
16:51:12 <geekosaur> er, no
16:51:53 <randir> At first I thought he was trying to draw something. Why can't spammer at least be interesting? *sigh
16:52:08 <randir> I think Haskell broke his brain:
16:52:16 <randir> <zubir> greetings <Vektorweg> whats the difference between type families and functional dependencies in efficient problem solving coverage? <zubir> wat
16:52:24 <untseac> that's not a drawing?
16:52:39 <Plasmastar> /msg randir IT'S A PENIS
16:52:40 <Vektorweg> lol
16:52:44 <geekosaur> derp
16:52:45 <randir> "modern art"
16:52:47 <mpickering> Vektorweg: they have very similar power
16:52:49 <Zemyla> Looks kind of like a cave in Dwarf Fortress.
16:53:16 <gyaretto> I can't help but feel like I'm writing ugly, inefficient code.
16:53:20 <Zemyla> Vektorweg: I think the main difference is fundeps can be bidirectional.
16:53:36 <Zemyla> gyaretto: We all have that feeling sometimes.
16:53:37 <untseac> looks like some sort of spaceship to me
16:53:53 <Vektorweg> Zemyla: thank you. something i can google for. ;)
16:54:10 <untseac> maybe its one of those drawings they show nutjobs and ask what it is
16:54:24 <mpickering> Vektorweg: What is your precise problem, there are several papers looking at the differece between the two
16:54:24 <Zemyla> Does that make us all nutjobs?
16:54:26 <Vektorweg> a forgotten beast, i guess.
16:54:29 <gyaretto> Zemyla: I'm new to Haskell, but I'm sort of rushing learning it. Probably a bad idea to write a school project in it.
16:55:00 <Vektorweg> mpickering: actually, i considered to troll around. but in a different manner. but this other guy just blamed everything. :p
16:55:09 <randir> I love the personality of the Haskell irc, best one I've seen.
16:55:13 <Zemyla> Hmm, is your code inefficient or just inelegant? Also, how well do you understand monads?
16:55:15 <randir> My favorite example of the quality here: https://gist.github.com/quchen/5280339
16:56:05 <Vektorweg> mpickering: i'm basically not really aware what i can do with type families. i saw some functional dependencies stuff but couldn't understand it fully. 
16:56:23 <gyaretto> Zemyla: Probably both, lol. And I feel like I understand monads, but I don't understand in what situations they can/should be used.
16:56:55 <randir> gyaretoo: I first learned Haskell for a school project, but that's because it really interested me and I did it on my own time-- it takes some practice. 
16:57:12 <randir> gyaretto: Do you have any prior experience with functional programming? 
16:57:28 <untseac> randir: lol that gist was hilarious
16:57:44 <gyaretto> I took a class on Haskell two years ago, but the professor wasn't very helpful. I didn't learn much.
16:57:47 <heatsink> Vektorweg: Type families are like functions, but at the type level.  They let you specify relations on types.
16:57:52 <Vektorweg> is it the same like in the haskell humor archive? 
16:57:58 <randir> untseac: I know right? A good thing to read whenever one is having a bad day. 
16:58:17 <jmcarthur> gyaretto: "I know! I'll use a monad!" is rarely how a decision to use a monad comes about. Usually it's just a matter of noticing that you are already using a monad.
16:58:21 <enthropy> Vektorweg: http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HZip.html has FDs and TFs to implement the same thing
16:58:32 <heatsink> Vektorweg: An example of a relation would be the "element type" of a special-purpose container.
16:58:33 <heatsink> ElemType [a] = [a], because a list of a contains a
16:58:45 <heatsink> ElemType ByteString = Word8, because a ByteString contains Word8
16:58:49 <randir> gyaretto: Don't get super caught up in monads yet-- yes, they are important for Haskell, but I'd say the most important thing is learning how to think functionally.
16:59:05 <randir> gyaretto: getting a feel for list comprehensions, maps, recursion and such.
16:59:06 <gyaretto> jmcarthur: Yeah, I figured the intuition would come about naturally.
16:59:29 <Vektorweg> thank you guys. i think the Hlist example is sufficient.
16:59:30 <glguy> What's the trick to getting the .cabal file description field in the haddock contents page?
16:59:33 <gyaretto> randir: Yeah, I think my biggest issue right now is I'm not good at thinking functionally yet.
16:59:54 <dmj`> glguy: shouldn't it do that automatically?
16:59:59 <glguy> that's what I thought
17:00:18 <jmcarthur> gyaretto: "Using a monad" is like "using a monoid" in the sense that it affects how you think about the code more than it actually affects your code.
17:00:27 <SrPx> Hello, is there any tutorial about the OpenGL package including how to compile shaders, upload buffers and so on?
17:00:33 <randir> gyaretto: It takes time, but it's totally worth it. I found that after I learned Haskell, it actually made my C++ (and other imperative programming) easier.
17:00:35 <dmj`> glguy: hackage builds your docs but the description is empty?
17:01:04 <glguy> dmj`: I'm testing locally
17:01:14 <gyaretto> randir: That's the main reason I get so excited about learning it. :3
17:01:20 <glguy> dmj`: Does cabal haddock not do it?
17:01:37 <enthropy> Vektorweg: data T a where Con :: C a b => b -> T a -- is illegal if C has a FD a -> b... but you can write the same existential type if that a -> b dependency is a type family
17:02:04 <dmj`> glguy: They have different behavior I've noticed. 
17:02:07 <gyaretto> I decided to write my compiler project in Haskell because I wanted a real project to to force me to learn it.
17:02:11 <dmj`> glguy: We need Fuuzetsu
17:02:19 <dmj`> Fuuzetsu: you're being summoned
17:02:38 <dmj`> not here :/
17:02:50 <randir> gyaretto: While a compiler project will help you learn it pragmatically, I think a project that's a bit more lighthearted might actually help more in learning how to think functionally. I learned a lot by programming a game just for fun.
17:02:50 <dmj`> fuuzetsu: ping !
17:03:31 <gyaretto> randir: I definitely have some ideas for personal projects, but I'm taking a Design of Compilers course this semester and I had to choose a language to write my compiler in.
17:03:34 <glguy> dmj`: OK, I used the package candidate function nd it seems to work differently from cabal haddock
17:03:57 <randir> gyaretto: Sounds like you're going to a *real* school. I had to pretty much teach myself everything about programming here :P
17:04:12 <utopia> sup
17:04:41 <utopia> any reason why this won't compile?
17:04:44 <utopia> firstelementcheck :: [a] -> [b] -> [c] firstelementcheck [] b:bs = [b] firstelementcheck a b:bs 	| b elem a = a 	| otherwise = a:b
17:04:51 <gyaretto> randir: Well, it's a liberal arts school, but it's small enough that one or two exceptional professors can carry the department pretty well.
17:05:03 <utopia> more like firstelementcheck :: [a] -> [b] -> [c]
17:05:07 <heatsink> utopia: Did you try to compile and get an error message?
17:05:10 <utopia> and firstelementcheck [] b:bs = [b]
17:05:49 <randir> gyaretto: we have on excellent professor, but he's so far above the skill level of the students that if he tried to have them write a compiler, they would die. Most students here can't even program something utterly trivial :/ What year are you in?
17:06:32 <randir> gyaretto: If you're up for the challenge, you'd definitely learn a lot about Haskell by making a compiler-- but it can be frustrating at first, especially for something so technical. 
17:06:38 <gyaretto> randir: Oh, that's unfortunate. I'm a senior, but I'll be graduating in December.
17:10:24 <vandenoever> could someone help me figure out why there is an extra -> IO()? http://lpaste.net/123463
17:11:01 <vandenoever> type StreamingBody = (Builder -> IO ()) -> IO () -> IO () 
17:12:57 <heatsink> vandenoever, it's probably inferring the wrong monad type for 'loop' due to one of the calls inside
17:13:19 <heatsink> vandenoever: You can write a type signature for loop to get a better error message
17:13:35 <vandenoever> heatsink: that's possible inside the 'where' ?
17:13:39 <heatsink> yes
17:13:45 <vandenoever> ok, i'll try
17:14:24 <SrPx> Did my question go last time? I'm having connection issues. I asked if there is any OpenGL tutorial (the haskell lib) including shader and buffers usage?
17:15:51 <nocturne777> lyh book says that it would be better if the Data.List.length return type was Num instead of Int. I understand why he says that. If it was Num, it could play nicely with any other Num without having to use fromIntegral. 
17:16:06 <heatsink> No one answered while you were gone, SrPx
17:16:11 <nocturne777> But returning "Num" makes things too general in this case
17:16:13 <vandenoever> heatsink: the 'write builder' is interpreted to be applied to two arguments, somehow the 'loop' on the next line is counted
17:16:31 <vandenoever> s/else/else do/ fixes it
17:16:36 <heatsink> Oh, right
17:17:02 <heatsink> the part after 'else' is an expression
17:17:07 <nocturne777> is this the idiomatic way to write Haskell code?
17:17:23 <vandenoever> heatsink: yep, thanks for the signature hint
17:17:36 <vandenoever> my proxy now works (for simple requests)
17:18:06 <nocturne777> from an API point of view, it does not look good, as far as I am concerned, but it makes things convenient in this case
17:19:14 <SrPx> heatsink: ah no problems :) thanks
17:19:51 <heatsink> nocturne777: Int is used as the default choice for an integral type in practice
17:20:40 <Zemyla> nocturne777: Returning Num also means it can't be optimized.
17:20:58 <nocturne777> heatsink: hmm. makes sense
17:22:17 <nocturne777> returning the explicit type also makes the purpose of the function more obvious in this case too.
17:23:15 <heatsink> The Int convention perpetuates itself because it is inconvenient for an API using a different integer type to interoperate with other libraries.
17:25:58 <Zemyla> heatsink: Also, the number of objects you can meaningfully reason about in a program is on the order of your computer's Int size.
17:26:39 <dmwit> nocturne777: What does "too general" mean?
17:26:45 <dmwit> What is bad about general?
17:27:04 <heatsink> true
17:27:30 <dmwit> Zemyla: That doesn't mean Int is a good proxy for all meaningful return values of length, though.
17:28:56 <dmwit> :t generalLength
17:28:57 <lambdabot>     Not in scope: ‘generalLength’
17:28:57 <lambdabot>     Perhaps you meant ‘genericLength’ (imported from Data.List)
17:29:00 <dmwit> :t genericLength
17:29:01 <lambdabot> Num i => [a] -> i
17:29:09 <enthropy> Zemyla: there isn't a SPECIALIZE pragma to work around that?
17:29:23 <dmwit> nocturne777: This (and other similar generic* functions) are available, and often quite useful.
17:29:40 <enthropy> that genericLength used when i ~ Int will be slower than length
17:29:40 <nocturne777> dmwit: like I said, returning Int makes the purpose of the function more clear
17:29:57 <nocturne777> otherwise, a person looking at the API may wonder if this might return Float
17:30:14 <nocturne777> dmwit: yes, I am aware of those functions :)
17:30:20 <dmwit> nocturne777: No; if it is polymorphic over all Num instances, you know much more about it than you do if it returns Int.
17:31:20 <dmwit> Because it can only use the functions available from Num; whereas Int can use all of those plus other, Int-specific functions.
17:31:34 <nocturne777> the thing is, I do not want to know much more
17:31:53 <nocturne777> I want to now that it returns an Int when I look at the type signature
17:32:19 <nocturne777> at least, if it is a function like length
17:32:30 <Zemyla> Well, it has to be some function of the length,
17:32:31 <dmwit> Why?
17:32:51 <nocturne777> it's more explicit than just Num
17:32:59 <dmwit> Explicit about what?
17:33:03 <nocturne777> any instance of Num could be num
17:33:33 <dmwit> The caller gets to pick which Num instance is used.
17:33:56 <dmwit> Including Int, of course.
17:34:08 <nocturne777> so you are saying that it would been better if length returned Num actually
17:34:14 <dmwit> yes
17:34:20 <dmwit> (I think so, anyway.)
17:34:29 <nitrix> GAH! I created circular dependencies with my modules!
17:34:30 <heatsink> Why not Integral?
17:34:32 <nitrix> NOOOOOOOO.
17:34:52 <dmwit> nitrix: Time to learn about hs-boot files!
17:34:55 <dmwit> heatsink: Why Integral?
17:34:59 <heatsink> Or refactor
17:35:23 <nitrix> dmwit: The worst is I have no clue how to not make it mutually dependent. They really, really seem to depend on one another :/
17:35:30 <enthropy> dmwit: I think all those Int-specific functions could use Integer instead, and since you have fromInteger it doesn't really help you to reason about which number you'll actually get out of length
17:35:49 <enthropy> nitrix: put all the definitions into one module instead
17:36:00 <dmwit> enthropy: Using Integer may be stricter than making it really polymorphic.
17:36:16 <dmwit> I've used genericLength at a lazy nat type before to good effect.
17:36:27 <dmwit> And other generic* functions.
17:36:30 <enthropy> yes that's true
17:37:05 <Zemyla> Well, any (Num i) => [a] -> i has to return f . length for some f.
17:37:13 <nitrix> enthropy: Oh that's kind of clever. A module dedicated to records?
17:37:15 <heatsink> nitrix: Sometimes you can remove the dependence by making module A more generic, using type parameters instead of types from module B
17:37:42 <enthropy> base doesn't have anything for zipAndGiveMeWhat'sLeftOver :: [a] -> [b] -> [Either (a,b) (Maybe a, Maybe b)]
17:37:51 <nitrix> heatsink: They seem highly specific, but I'll have a look, it's a good tip.
17:37:52 <dmwit> You might like
17:37:54 <dmwit> ?hackage these
17:37:54 <lambdabot> http://hackage.haskell.org/package/these
17:38:02 <dmwit> Specifically, Data.Align.align
17:39:50 <nocturne777> dmwit: some of the folks here mentioned optimization 
17:40:23 <nocturne777> dmwit: does haskell do optimizations whether the return type is Num or Int ?
17:41:02 <Zemyla> dmwit: Why not just use [()] as your lazy natural type?
17:41:28 <Zemyla> (+) = (++), a * b = concatMap (const b) a.
17:41:31 <dmwit> Zemyla: Sometimes I do. Sometimes that's inconvenient.
17:41:47 <dmwit> nocturne777: One could easily instruct GHC to specialize length when used at the Int type.
17:43:09 <Zemyla> :t F.foldr (const (1+)) 0
17:43:10 <lambdabot> (Foldable t, Num b) => t a -> b
17:43:39 <Zemyla> That is reallyGenericLength.
17:44:19 <shachaf> genericLength isn't a useful function.
17:44:36 <randir> > [1..10]
17:44:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:45:12 <randir> How does lambdabot limit the interpreter output? 
17:45:54 <randir> I'm sure it wouldn't actually print out [1..100000] if I tried, right?
17:46:10 <ion> It probably just reads a given amount of bytes from the subprocess evaluating your code.
17:46:14 <mniip> > take 10 $ show [1..]
17:46:15 <lambdabot>  "[1,2,3,4,5"
17:46:59 <randir> hmm, strange that [1..10] worked but that cut off at 5
17:47:01 <randir> > [1..100]
17:47:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:47:23 <Javran> randir: that "take 10" truncates the string 
17:47:26 <randir> > [1..]
17:47:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:47:53 <heatsink> dmwit: genericLength :: Integral n => [a] -> n, to say that the result is integral.
17:47:56 <randir> Jarvan: ah, of course XD
17:48:07 <mniip> I was trying to demonstrate that even when 'show' produces an infinite string, you can cut a piece of it
17:48:13 <mniip> because lazy evauation
17:48:53 <heatsink> dmwit: If the constraint is Num, then you need to deduce that the function can only generate numbers using the methods of Num, and it can only generate integers from those methods.
17:49:08 <Javran> > take 10 (iterate show "")
17:49:09 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
17:49:24 <mniip> > fix show
17:49:26 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:49:28 <randir> mniip: yeah, that is interesting. I love lazy eval
17:49:45 <randir> :t fix
17:49:46 <lambdabot> (a -> a) -> a
17:50:26 <Zemyla> > fix myProgram
17:50:27 <lambdabot>  Not in scope: ‘myProgram’
17:50:32 <Zemyla> D:
17:50:33 <Javran> > fix error
17:50:35 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:50:40 <dmwit> heatsink: But then your type needs to implement division.
17:50:49 <dmwit> heatsink: Which isn't used at all in the implementation of length.
17:50:55 <dmwit> heatsink: So that kind of sucks.
17:51:41 <heatsink> I see.
17:53:30 <randir> What haskell web server would you guys recommend, for a personal website? I want to make a blog on it, as well as showcasing various coding projects.
17:53:37 <randir> I've used Snap before, awhile ago.
17:53:45 <mniip> > fix cycle
17:53:49 <lambdabot>  mueval-core: Time limit exceeded
17:53:56 <randir> fix id
17:53:59 <randir> > fix id
17:54:03 <lambdabot>  mueval-core: Time limit exceeded
17:54:15 <randir> > let a = a
17:54:16 <mniip> nah just coming up with puns now
17:54:16 <lambdabot>  not an expression: ‘let a = a’
17:54:33 <byorgey> randir: if you don't need it to connect to a database etc., then hakyll works really well for building that kind of personal website
17:54:40 <mniip> > fix fail
17:54:42 <lambdabot>  ""
17:54:42 <randir> > fix ego
17:54:43 <lambdabot>  Not in scope: ‘ego’
17:55:01 <ttt_fff> for development, is there something fastter than ghc .... && ./Main ? I'd be willing to have it interpret teh code (at slower rate than compiled code) to avoid the compile times
17:55:47 <bananagram> ghci ....
17:55:59 <bananagram> seems like what you want
17:56:01 <ttt_fff> ghci can run all my *.hs files ?
17:56:05 <mniip> ttt_fff, ghci, runhaskell
17:56:12 <bananagram> yes
17:56:19 <Javran> or runghc xD
17:56:27 <randir> byorgey: I'll have to check it out, thanks.
17:57:10 <randir> ttt_fff: as mniip said, runhaskell works exactly for what you want.
17:57:18 <randir> runhaskell myprog.hs
17:57:24 <randir> interprets it, and enters in the main function
18:00:29 <mniip> is there a better way to write \x -> x ++ (guard (null x) >> default)
18:01:09 <dmj`> mniip: what is default
18:01:14 <mniip> some value
18:01:25 <mniip> free variable of the expression
18:01:41 <Zemyla> :t \default x -> x ++ (guard (null x) >> default)
18:01:42 <lambdabot> parse error on input ‘default’
18:01:53 <mniip> the semantics are 'if null x then default else x'
18:01:56 <Zemyla> :t \def x -> x ++ (guard (null x) >> def)
18:01:57 <lambdabot> [a] -> [a] -> [a]
18:02:25 <ion> What’s wrong with “if null x then default else x” then?
18:02:41 <Zemyla> mniip: foldr (const x) default x
18:02:41 <mniip> well
18:02:56 <mniip> I was hoping for a one-x solution
18:03:02 <mniip> that is not infested with ap or join
18:03:04 <dmj`> > concat [ x | x <- [ [], [1,2,3], [], [4,5] ], not (null x) ]
18:03:06 <lambdabot>  [1,2,3,4,5]
18:03:10 <jle`> accidentally used fmap f <$> x, how silly of me
18:03:51 <mniip> Zemyla, that looks neat
18:04:38 <heatsink> That solution lazily traverses the entire list, though
18:04:40 <dmj`> > do { c <- [ [], [1,2,3], [], [4,5] ]; guard (not null $ c); return c }
18:04:41 <lambdabot>  Couldn't match expected type ‘[t] -> GHC.Types.Bool’
18:04:41 <lambdabot>              with actual type ‘GHC.Types.Bool’
18:04:41 <lambdabot>  Relevant bindings include c :: [t] (bound at <interactive>:1:6)Couldn't matc...
18:04:50 <heatsink> Oh wait, it doesn't
18:05:00 <dmj`> > do { c <- [ [], [1,2,3], [], [4,5] ]; guard (not $ null c); return c   }
18:05:02 <lambdabot>  [[1,2,3],[4,5]]
18:05:13 <dmj`> does lambdabot have it?
18:05:18 <dmj`> *it*
18:05:28 <heatsink> have what?
18:05:29 <heatsink> > it
18:05:30 <lambdabot>  Not in scope: ‘it’
18:05:30 <lambdabot>  Perhaps you meant one of these:
18:05:32 <lambdabot>    ‘id’ (imported from Data.Function),
18:05:32 <heatsink> I guess not
18:05:43 <mniip> it did have it
18:05:51 <mniip> however it was abused so it was removed from it
18:07:12 <randir> they abused it.
18:07:13 <Zemyla> mniip: It should actually be foldr (const . const x) default x.
18:07:16 <randir> heh.. I'm sorry.
18:10:50 <Javran> > [ c | c <- [ [], [1,2,3], [], [4,5] ], not $ null c]
18:10:52 <lambdabot>  [[1,2,3],[4,5]]
18:12:22 <dmwit> > filter (not . null) [ [], [1,2,3], [], [4,5] ]
18:12:24 <lambdabot>  [[1,2,3],[4,5]]
18:15:12 <Javran> so far I found many projects that compile codes to js, any recommendations for generating greasemonkey scripts?
18:16:13 <Javran> ghcjs / haste / fay compiles Haskell code to js, and PureScript is a new language that compiles to js if I understand it correctly
18:18:49 <HeladoDeBrownie> Javran, purescript seems like a straightforward choice, as long as you don't mind the investment in learning how it differs from haskell
18:18:49 <dmwit> mniip: head ([default | null x] ++ [x]) -- not serious
18:21:15 <mniip> dmwit, fromMaybe x [def | null x]
18:21:28 <mniip> (MonadComprehensions)
18:21:30 <dmwit> cute =)
18:24:56 <Javran> HeladoDeBrownie: I see, maybe it's overkill
18:25:31 <HeladoDeBrownie> Javran, up to you. for short scripts i don't mind writing in js too much, but for applications i probably would. that's just my preference though, yours may differ.
18:26:31 <Javran> HeladoDeBrownie: guess I need to investigate a little bit myself. still new to frondend programs.
18:35:33 <okino> umm.. I have this haskell trie basic implementation, we're not allowed to use imports so i can't use Map. basically, one of the functions I need to write is the insert function. I just can't get the function to remember the trie after inserting. so I can't return the new trie with the added word..
18:37:34 <okino> the function I have so far only returns a tri of the new word added, but i can't get it to return all the parents after that
18:37:35 <heatsink> Inserting should create a new trie.  Each recursive step should return a new trie.
18:37:48 <heatsink> Return all the parents?
18:38:17 <okino> don't think I can, I have to return the right trie each step
18:38:21 <okino> that's what I can't nail
18:38:46 <heatsink> When insertion calls itself recursively, what does it do with the result of the recursive call?
18:39:13 <okino> well with haskell I can't save previous results 
18:39:39 <okino> the trie is Data Trie = MakeTrie char [Trie]
18:41:20 <heatsink> To focus on how to build the new tree, let's take a simpler problem
18:41:31 <heatsink> Here is a binary tree type: data Tree = Node Tree Tree | Leaf Int
18:41:53 <okino> I think I could do it with a binary tree since I know there's max two children you see
18:41:54 <okino> but with a trie
18:42:13 <okino> i have to compare a letter of the word with a whole possible level 
18:42:15 <heatsink> Okay, how would you define insertOnLeft :: Int -> Tree -> Tree ?
18:42:38 <okino> hmmm.. let me see here, i am quite a slow thinker as you can tell ;p
18:42:48 <heatsink> for the Node case.  It should insert at the bottom of the tree, all the way on the left.
18:43:05 <okino> right
18:47:16 <heatsink> Are you still trying to write insertOnLeft?
18:47:57 <okino> no sorry, kind of struggling a bit
18:48:20 <okino> and I have to go in a bit, but thanks for your help anyway, I might come back tomorrow if I still can't figure it out tonight
18:48:34 <heatsink> okay
18:48:48 <okino> thx, and cheers
18:49:43 <heatsink> goodnight, feel free to ask again later.
18:54:32 <paxcoder> I'm using curlGetString from the curl module, and I keep getting (CurlOK,"  ") whenever trying to read from a particular domain (arguments I'm passing are the URI and an empty list). Does anyone have a clue why that might be happening, esp. considering that it works fine for other domains, and that using this one domain with curl CLI works also.
18:55:01 <gyaretto> :t (>>>)
18:55:02 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
18:55:02 <paxcoder> *IO(CurlOk, "  ")
18:55:11 <gyaretto> randir: ^
18:56:56 <Zemyla> Which operators can I use without conflicting with lens?
18:57:31 <paxcoder> it makes no seeeense
18:57:37 <edwardk> Zemyla: https://github.com/ekmett/lens/blob/master/HLint.hs should have the whole list of lens operators
18:57:44 <edwardk> so anything except those
18:58:35 <edwardk> we've left ? open for now
18:58:37 <edwardk> =)
19:00:21 <lpaste> Exio4 pasted “HLists.hs” at http://lpaste.net/123465
19:00:56 <exio4> edwardk: now that you are here, would it be possible to define some kind of lens operator that does something like get in that paste? 
19:02:24 <edwardk> exio4: can you give me a quick summary of what you are trying to do?
19:03:16 <exio4> I'd have to try a few things I just thought while asking the question
19:07:11 * hackagebot foreign-var 0 - Encapsulating mutatable state in external libraries  http://hackage.haskell.org/package/foreign-var-0 (EdwardKmett)
19:10:00 <heatsink> edwardk: Reading about the Bound library, it seems like Bound is for substitution, not for renaming.  Is that right?
19:10:13 <Zemyla> edwardk: Oh, how can a lens work with readSTRef and writeSTRef?
19:10:20 <edwardk> bound works 'locally nameless'
19:10:26 <edwardk> Zemyla: they don't
19:10:38 <edwardk> Zemyla: fact is you can't write law abiding lenses for them basically
19:11:16 <Zemyla> Well, that's a real shame.
19:11:24 <edwardk> consider an data Foo = Foo (IORef Foo) Int -- or something like it -- nothing stops the IORef from referencing the Foo that holds it
19:11:52 <edwardk> so if you 'walked into it' and then walked into the ref you got there, and changed something you'd have 2 things to write back to the same IORef
19:12:02 <edwardk> and you'd have to remember both for the lens laws to work
19:12:08 <edwardk> you just can't have this thing you want, sorry
19:12:11 * hackagebot bet 0.1.2.2 - Betfair API bindings. Bet on sports on betting exchanges.  http://hackage.haskell.org/package/bet-0.1.2.2 (Adeon)
19:13:35 <heatsink> I don't think that answers my question
19:14:54 <edwardk> heatsink: i don't think i understand your question then
19:16:29 <heatsink> The example on FPcomplete uses a recursive data type, Exp a, that contains variables (a) and subexpressions (Exp a)
19:16:33 <enthropy> exio4: you've seen how the HList library does lenses?
19:16:53 <exio4> enthropy: no, I haven,t I'll check
19:17:04 <enthropy> you define another class that does the update
19:17:27 <heatsink> The main operation on expressions is substitution, which replaces a variable with an expression
19:17:43 <heatsink> This is more powerful than renaming, which replaces a variable with a variable
19:18:08 <edwardk> bound provides the latter as well
19:18:13 <heatsink> Oh, okay
19:18:17 <heatsink> That's what I was asking about
19:18:24 <enthropy> then you have a  hlistLens :: Get (n s a, Update n s b t)  => Proxy n -> Lens (L s) (L t) a b
19:18:30 <edwardk> https://github.com/ekmett/bound/blob/master/src/Bound/Term.hs#L26
19:19:05 <utopia> how do I get every element in a list but the last?
19:19:15 <heatsink> utopia: init
19:19:19 <edwardk> > init [1..10]
19:19:20 <lambdabot>  [1,2,3,4,5,6,7,8,9]
19:21:40 <arkeet> > init []
19:21:41 <lambdabot>  *Exception: Prelude.init: empty list
19:27:12 * hackagebot foreign-var 0.0.0.1 - Encapsulating mutatable state in external libraries  http://hackage.haskell.org/package/foreign-var-0.0.0.1 (EdwardKmett)
19:37:12 * hackagebot contravariant 1.2.2 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.2.2 (EdwardKmett)
19:39:13 <Zemyla> Why are there so many kinds of functors?
19:42:43 <dibblego> like covariant, contravariant, exponential, binary, etc?
19:51:34 <byorgey> Zemyla: because they are so important.  Since they come up so often it's useful to give names to certain special kinds of functors
19:51:36 <pedantic> Can someone explain to me why my memory usage for the second variation of my code so much more than the first? http://pastebin.com/LYQKA7RW
19:52:33 <byorgey> note that all the examples of "_____ functor" I can think of (covariant, contravariant, bi-, forgetful, etc.) are actually just plain old functors, with some special property or context
19:53:01 <joejev> Does anyone know any financial backtesters that are written in haskell?
19:53:13 <byorgey> e.g. a bifunctor is just a functor from a product category, a contravariant functor is just a functor from an opposite category, etc.
19:53:58 <joobus> how do i convert a lazy bytestring to a bytestring?
19:54:31 <glguy> Data.ByteString.Lazy.toStrict
19:54:38 <joobus> thank you
19:56:26 <byorgey> pedantic: dunno, perhaps in the first case it's able to unbox a lot of things since it's just doing simple arithmetic
19:56:36 <indiagreen> pedantic: maybe it's because arccot' is building thunks?
19:56:46 <byorgey> pedantic: you'd have to look at the generated core to know for sure
19:57:09 <indiagreen> try writing it as “arccot' !sum xpower mult sign”
19:57:48 <indiagreen> (and enabling {-# LANGUAGE BangPatterns #-})
19:57:53 <byorgey> yes, that should help regardless of whether you pass a sign or an sfunc
20:00:00 <paxcoder> Any reason why I'd get a CurlOK but no response body using curlGetString with a a particular domain, one that works fine with the standard CLI curl, all the while getting correct responses for other domains?
20:00:57 <glguy> paxcoder: Perhaps it's getting a redirect of some kind that you have to follow manually
20:03:52 <paxcoder> glguy, I'm a dumbass for not trying head sooner. Anyway, I'm getting 200 BadClient
20:06:03 <paxcoder> I don't believe they have a  client whitelist, and I don't think they'd specifically block haskell's curl.
20:06:25 <pedantic> byorgey: thanks. That helped.  Now I just need to figure out why that works
20:07:10 <pedantic> indiagreen: sorry i meant to say that to you
20:07:37 <paxcoder> 200 BadClient. It sounds like the Australian "Yeah, no".
20:10:00 <glguy> pedantic: GHC tries to analyze the strictness of functions, and if it determines that the result depends strictly on the inputs it will optimize things accordingly
20:10:34 <byorgey> pedantic: you may be interested in reading https://wiki.haskell.org/Performance/Strictness and https://wiki.haskell.org/Performance/Accumulating_parameter
20:10:34 <glguy> but when you pass in a function you defeated the analyzer. By adding the strictness annotation you told GHC to compile it strictly
20:11:55 <jfischoff> I’m trying to debug why a file with a lot of TH is taking so long to compile. I ran it with -v3 and the CorePrep said there were 1,000,000+ types. What does that mean?
20:17:43 <paxcoder> glguy, thanks for the suggestion, it helped. It seems they have some kind of a regex-based whitelist, setting user string to "curl" worked (since they serve my debian browsers fine I reckon they also have "WebKit", "Gecko" etc). Weird.
20:20:10 <paxcoder> It's also weird that haskell's curl doesn't set something like that by default.
20:23:04 <dbt_> Hi. I need to write a simple web app which receives HTTP requests on one end and sends corresponding JSON-RPC calls on the other end. What frame work is best suited to this case?
20:32:34 <rofer> Is there an easy way to install all of the packages I currently have installed?
20:32:47 <rofer> I'm trying to also get all of the documentation for each package I have
20:33:14 <indiagreen> rofer: there's “cabal install world”
20:33:27 <rofer> indiagreen: It doesn't seem to recognize world
20:33:32 <indiagreen> it won't install completely the same set of packages you have installed, tho
20:33:53 <indiagreen> hm, weird
20:33:56 <rofer> I also can't even re-install base
20:34:05 <indiagreen> you can't possibly reinstall base
20:34:08 <rofer> It seems to reject every candidate for some reason
20:34:11 <indiagreen> it's tied to GHC
20:34:18 <rofer> Ah
20:34:45 <rofer> Does that mean I should already have the documentation for it?
20:35:05 <indiagreen> yes
20:35:38 <indiagreen> where are you looking for documentation?
20:35:56 <SrPx> Guys sorry for the stupidity but how do I write this shorter? http://lpaste.net/123466 I am sure this is possible without monads (just applicative) since I've done this before but somehow my mind froze and I can't remember it
20:36:23 <pedantic> paxcoder: it's because libcurl doesn't set it by default
20:36:34 <SrPx> combs [1,2,3] == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
20:37:36 <rofer> indiagreen: Didn't realize I already had the base docs. Just found them, thanks!
20:38:54 <indiagreen> SrPx: you can just rewrite it as a list comprehension
20:39:13 <indiagreen> it would probably be the simplest way
20:39:46 <indiagreen> combs xs = [x:ys | x <- xs, ys <- combs (delete x xs)]
20:40:05 <SrPx> indiagreen: good idea, but can I get rid of the monad?
20:40:11 <indiagreen> what monad
20:40:18 <SrPx> also delete x, nice
20:40:31 <indiagreen> list is a monad already
20:40:46 <SrPx> I mean, using the list'd monad instance
20:41:30 <indiagreen> the comprehension doesn't use the monad interface; as for rewriting your function to use Applicative instead of Monad, I believe it's impossible
20:41:36 <indiagreen> because y depends on x
20:41:59 <indiagreen> Applicative doesn't let you have parameters that depend on each other
20:42:15 * hackagebot miniforth 0.1.0.1 - Miniature FORTH-like interpreter  http://hackage.haskell.org/package/miniforth-0.1.0.1 (L8D)
20:42:17 * hackagebot yabi-muno 0.1.0.1 - Yet Another Brainfuck Interpreter  http://hackage.haskell.org/package/yabi-muno-0.1.0.1 (L8D)
20:43:05 <indiagreen> oh, and just in case
20:43:25 <indiagreen> if you're not doing it as an exercise but just need the function, it's “permutations” in Data.List
20:43:59 <rofer> Hmmm, apparently I'm not very good at "optimizing" haskell. Just got code that took 50s to run to take over two minutes :/
20:45:09 <Rotaerk> I don't think delete is what you want, SrPx 
20:45:17 <Rotaerk> seems to only delete the first instance of the value
20:45:29 <kadoban> rofer: Well, just undo that and then you've instantly improved it over 60% ! :)
20:45:49 <rofer> kadoban: Heh, yup.
20:45:57 <rofer> The goal was to get this code to run in <2s
20:46:09 <rofer> So still a little off from there
20:46:11 <Rotaerk> SrPx, what about:  let combs xs = map (\x -> x : filter (/= x) xs) xs
20:46:12 <kadoban> Oh. Well then you still have a ways to go :-/
20:46:36 <rofer> It started at something like 1.5m, so the 50s was already an improvement
20:46:55 <rofer> Just surprised to find I lost speed going from List to Sequence
20:46:55 <Rotaerk> oh nm
20:46:58 <indiagreen> Rotaerk: won't work, you're not recursing
20:47:02 <Rotaerk> misunderstood what you were doing
20:50:06 <SrPx> Rotaerk: I tried almost the same thing before !
20:50:24 <nitrix> Guys, I need help fixing mutual dependencies.
20:50:32 <paxcoder> pedantic, so the CLI does? I guess that makes sense.
20:50:46 <nitrix> "module Ledger imports Inode which imports Ledger"
20:50:58 <indiagreen> rofer: Sequence has bad constant factors, so it might not help unless your lists are big
20:51:14 <pedantic> paxcoder: looks like that. compiled a simple C program and used netcat. It didn't set the user-agent string from what i saw
20:51:16 <indiagreen> you can paste your code if you want and somebody might look at it
20:51:22 <Rotaerk> SrPx, is this supposed to eliminate duplicates in the process?
20:51:52 <pedantic> paxcoder: http://curl.haxx.se/libcurl/c/simple.html
20:51:58 <SrPx> Rotaerk: there are no duplicates :) 
20:52:11 <SrPx> I've considered using a set but... dunno
20:52:43 <Rotaerk> SrPx, but why the filter where /= x?
20:52:52 <Rotaerk> that seems to be designed specifically to eliminate duplicates
20:53:02 <paxcoder> pedantic, thanks
20:53:06 <SrPx> Rotaerk: uhm just a quick way to remove x
20:53:21 <Rotaerk> can't you just use ys?
20:53:21 <SrPx> Rotaerk: I didn't know about delete
20:53:29 <rofer> indiagreen: Yeah, that could be the problem. My test case has a list of 20k elements
20:53:30 <Rotaerk> err
20:53:37 <SrPx> how exactly? 
20:53:43 <Rotaerk> nm
20:53:57 <indiagreen> nitrix: you can get GHC to work with mutually circular dependencies, but it's complicated and you'd be better off just extracting common pieces of code into the 3rd module or something
20:54:23 <SrPx> okay :) I guess it could be faster if I had a different monad instance for list that binded both the element and the rest
20:54:38 <nitrix> indiagreen: I think it's a design mistake on my part, but it still scares me, because I thought I was doing fine until now.
20:54:54 <indiagreen> nitrix: is your code available somewhere?
20:55:49 <nitrix> indiagreen: https://github.com/nitrix/udfs/tree/lean/src
20:56:04 <nitrix> indiagreen: Trying to add nextInodeId to the Ledger.
20:56:58 <nitrix> indiagreen: InodeId comes from the Inode module, which has a bunch of functions that takes a Ledger, and so, mutually requires each others. I was getting ahead of myself with the nextInodeId, it's not needed now, but it will be necessary in the future and that's what scares me. I'd rather figure the problem now.
20:58:18 <nitrix> indiagreen: Maybe a State monad would be better for my Ledger?
20:58:30 <indiagreen> (by the way, it sounds cool, I'll be watching the repo)
20:58:54 <nitrix> :)
20:58:57 <Zemyla> Hmm. The free monad Free f a is copointed if f is copointed.
20:59:11 <nitrix> indiagreen: It'd be finished already if it wasn't my toy project to learn Haskell :)
21:04:22 <nitrix> indiagreen: I commited a fix, don't bother too much. It'll wait then :/
21:08:58 <indiagreen> nitrix: I don't really understand what's going on (I have little idea about how filesystems work), but all your inode* functions (apart from inodeRead, okay) look like they're – in a sense – methods of Ledger, so you could just put them into one module. Alternatively, if Ledger is some kind of global state, then you could indeed use State monad – put Ledger and Inode into one module, and functions operating on them
21:08:58 <indiagreen> into separate modules.
21:09:49 <indiagreen> so far the simplest thing would be just moving the definition of Inode into Ledger.hs
21:10:21 <indiagreen> and then you could say that Ledger.hs implements “the state of the filesystem” and Inode.hs implements Inode-related functions”
21:10:48 <nitrix> indiagreen: Yeah, what happens is I'm writting the bottom layer and I'm trying to create an abstration over the resources that are individually stored at multiple endpoints
21:11:29 <nitrix> So one inode represent some data, but that data can have multiple resources for multiple endpoints.
21:11:56 <nitrix> As far as the FS is concerned, you need to be able to reference things without having to think of the distribution at some point.
21:12:22 <nitrix> Hence inode numbers :/
21:12:38 <hodapp> hrmph, my brain has failed me. Trying to figure out how to take foo ! bar ! baz1 ! baz2 ! baz3..., and factor out the baz1 ! baz2 ! baz3... because it occurs at several points.
21:13:15 <indiagreen> hodapp: “!” is array indexing?
21:13:38 <hodapp> indiagreen: oh, no, this is with Text.Blaze.Svg
21:13:43 <hodapp> (!) :: Text.Blaze.Internal.Attributable h => h -> S.Attribute -> h
21:14:08 <nitrix> indiagreen: Correct, Ledger is the state and Inode are inode-related functions.
21:14:34 <indiagreen> hodapp: attributes seem to be monoids
21:14:39 <nitrix> I could merge both but then I thought the goal was to have a separation of concerns.
21:14:51 <nitrix> And now suddently, they're merged togheter for GHC's convenience :/
21:14:53 <indiagreen> you can do “mconcat [baz1, baz2, baz3]”
21:15:08 <hodapp> indiagreen: ahh, this is true... I knew AttributeValues were monoids but hadn't looked to see that Attributes were
21:15:42 <hodapp> indiagreen: good observation there!
21:19:32 <joejev> I am trying to use quasiquotes and I am wondering why I cannot use an expression as the quasiquoter argument
21:19:55 <joejev> for example: `[quoteFile r|testfile|]`
21:21:07 <gfixler> I wonder if that's possible
21:21:21 <gfixler> the expansion may happen before any expressions can be evaluated
21:22:29 <indiagreen> joejev: imagine what would happen if testfile was a string read from console
21:22:56 <indiagreen> you'd have to include a whole Haskell interpreter into the compiled executable
21:23:05 <indiagreen> or are we misinterpreting your intent?
21:24:19 <joejev> hmm, how would testfile be a string, testfile is literal
21:25:14 <joejev> like, it is not a variable, that would try to open the file named testfile
21:26:55 <indiagreen> ouch
21:26:59 <indiagreen> sorry
21:27:03 <indiagreen> I didn't notice the “r”
21:27:33 <indiagreen> and thought you were talking about testfile (some variable from outside) being the argument
21:32:22 <indiagreen> joejev: yeah, turns out you can't
21:32:25 <indiagreen> https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/template-haskell.html#th-quasiquotation
21:32:31 <indiagreen> “The quoter must be the (unqualified) name of an imported quoter; it cannot be an arbitrary expression. ”
21:33:16 <indiagreen> you can't even have spaces before or after the quoter's name
22:29:11 <ttt_fff> is haste from stackage-lts broken ?
22:29:46 <ttt_fff> is haste-compiler from stackage-lts broken ?
22:37:24 <aport> I have too many monads plz help
22:38:00 <dmj`> aport: how many do you have?
22:38:44 <aport> lots
22:38:51 <ab9rf> it's not how many monads you have, it's how many monad transformers you have
22:39:37 <dmj`> are monad transformers still monads though?
22:40:08 <ab9rf> how would i know? i'm not a category theorist.
22:40:49 <bob_twinkles> they're monads, otherwise what would be the point?
22:40:52 <dmj`> ab9rf: can a monad transformer successfully make an instance of the Monad type class?
22:40:58 <dmj`> bob_twinkles: hush
22:43:10 <Cale> :k MonadTrans
22:43:11 <lambdabot> ((* -> *) -> * -> *) -> Constraint
22:43:14 <Cale> :k Monad
22:43:14 <lambdabot> (* -> *) -> Constraint
22:43:21 <Cale> No.
22:47:00 <ab9rf> cale to the rescue once again
22:47:20 <ab9rf> much better than being rescued by kale
22:47:39 <ab9rf> kale, for when your dinner needs more chlorophyll
22:48:58 <ab9rf> there should be colored monads
22:50:15 <Cale> http://hackage.haskell.org/package/indexed-0.1/docs/Control-Comonad-Indexed.html
22:50:22 <Cale> http://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed.html
22:50:40 <Cale> Kind of like coloured monads? :)
23:02:22 * hackagebot warp 3.0.9.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.9.3 (MichaelSnoyman)
23:02:51 <pharpend> Oh god here comes the torrent of snoyman uploading new versions
23:02:58 <HeladoDeBrownie> i have a type i frequently add constructors to. i have a match that has a catch-all that basically says "not implemented". can i leave this in, yet not have ghc complain when i've already handled all the cases?
23:03:38 <pharpend> HeladoDeBrownie: can you provide some code? I'm not sure what you're talking about
23:03:56 <Cale> HeladoDeBrownie: If you have a catch all case, you should be handling all the cases already
23:04:27 <kadoban> I think he means that GHC is complaining when it's made redundant because he's handling all of the cases, and then the default exists too.
23:04:28 <Cale> so ghc ought not to be complaining, I think
23:04:35 <Cale> oh
23:04:35 <HeladoDeBrownie> um, sure. let's say data Foo = A | B | C. i have an expression case x of { A -> … ; B -> … ; C -> … ; _ -> putStrLn "not implemented" }
23:04:38 <Cale> yeah, okay
23:04:41 <Cale> hmm
23:04:42 <HeladoDeBrownie> but i may then add a case D, and forget to update the case
23:04:47 <HeladoDeBrownie> kadoban, s/he/they/
23:04:57 <kadoban> Yeah, sorry.
23:05:28 <HeladoDeBrownie> either forget or just not do it yet, in which case i want it to say not implemented
23:06:06 <HeladoDeBrownie> so, basically was wondering if i could disable the warning in ghc. not vital, but it's annoying
23:06:30 <kadoban> Only thing I can think of is adding a DontImplementOrUseMe constructor and just don't ever use or export it anywhere, but that's…awful.
23:06:40 <HeladoDeBrownie> haha. maybe.
23:06:46 <Cale> -fno-warn-overlapping-patterns
23:06:52 <HeladoDeBrownie> Cale, awesome
23:06:57 <HeladoDeBrownie> any idea how i'd tell cabal to always pass that?
23:07:59 <Cale> ghc-options: -fno-warn-overlapping-patterns
23:08:30 <Cale> Note that some overlapping patterns are bugs though
23:08:32 <HeladoDeBrownie> can that go in the executable field?
23:08:41 <HeladoDeBrownie> i understand that, but i'm not worried about running into them
23:08:42 <Cale> yeah
23:08:48 <HeladoDeBrownie> okay let's see…
23:09:47 <HeladoDeBrownie> awesome, looks good! thanks all
23:22:23 * hackagebot http-client 0.4.8 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.8 (MichaelSnoyman)
23:32:06 <Geraldus> hi friends!
23:32:45 <HeladoDeBrownie> o/
23:34:03 <Ch0c0late> Is there any other material related to Security in Haskell? As an instance I could find Information Flow and Label Lattice.
23:38:06 <Geraldus> I'm trying to make a Transient (https://github.com/agocorona/transient/) library to use it my current project. I guess I need Base9 module, but it fails to compile. Can someone help me a bit?
23:39:17 <intaoe> Is there a specific phrase for pattern matching like `let (a, b) = (1, 2)`?
23:39:47 <HeladoDeBrownie> intaoe, in what context do you want to talk about it?
23:42:37 <intaoe> HeladoDeBrownie: Well, I think purescript allows you to do that sort of binding in a `do (a, b) <- pure (1, 2)` context, but not with let, where or top level. I'm looking for a search term to confirm
23:43:26 <johnw> Ch0c0late: what kind of security are you looking for?
23:43:56 <johnw> there are several information flow control libraries
23:44:16 <HeladoDeBrownie> intaoe, i'm not sure there is a term for it, but let me see if i can find it for you in the syntax
23:44:23 <Ch0c0late> Joh Well, my research is on language based information flow
23:44:43 <johnw> there's a rather large amount of literature on this
23:44:50 <HeladoDeBrownie> intaoe, this may help https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
23:44:54 <johnw> I recommend asking the ACM digital library, or Google Scholar
23:45:09 <HeladoDeBrownie> intaoe, essentially, you can have patterns, not simply identifiers there
23:45:20 <halvorg> I have a data type T = A | B; A = A1 | A2; B = B1 | B2. I want to create a function f :: T -> Something, can I match A1/A2/B1/B2 in the function without using a case statement?
23:45:35 <halvorg> eg. I want to do f A1 = ...
23:45:38 <Geraldus> what is the right way to fix errors like `Could not deduce (m ~ StateT EventF m)`?
23:45:40 <halvorg> doesnt compile tho
23:45:48 <HeladoDeBrownie> halvorg, why not? what's the error? what's the code?
23:46:03 <HeladoDeBrownie> halvorg, oh i see
23:46:12 <halvorg> couldnt match expected type T with A1 or something
23:46:31 <HeladoDeBrownie> halvorg, you need a constructor name and then the type(s) it's parameterized by in the data declaration, e.g., data T = TA A | TB B
23:46:50 <Ch0c0late> johnw: yes, could you please point me to some of them. Well, I did read Enforcing Information Flow in Haskell. I found some open questions that are left to solve but still I'm in the process of researching on Security related methods such as Taint checking and Trademark.
23:46:57 <halvorg> Okay, ill try that thanks.
23:46:58 <HeladoDeBrownie> halvorg, then you construct a t with TA A1, TA A2, TB B1, or TB B2
23:47:02 <HeladoDeBrownie> s/t/T/
23:47:45 <johnw> Ch0c0late: I'm afraid that's a large task, since I don't know exactly what you want
23:47:49 <johnw> ask Google to begin with
23:47:58 <HeladoDeBrownie> Geraldus, could be any number of things
23:48:02 <intaoe> HeladoDeBrownie: Thanks
23:48:47 <Geraldus> HeladoDeBrownie: hi! Can you help taking a look at source?
23:49:01 <Ch0c0late> johnw: well I have some questions to ask.
23:49:26 <HeladoDeBrownie> Geraldus, give code and complete error using lpaste, whoever can help may
23:50:00 <Geraldus> I'm trying to make a Transient (https://github.com/agocorona/transient/) library to use it my current project. I guess I need Base9 module, but it fails to compile. I'll upload errors in a moment
23:50:30 <HeladoDeBrownie> Geraldus, this is someone else's library?
23:51:37 <Geraldus> HeladoDeBrownie: yes, but it's quite small and simple I think.
23:51:42 <Geraldus> here is error http://lpaste.net/123603
23:51:53 <Geraldus> I think the main issue is line 193
23:53:11 <HeladoDeBrownie> i don't think i have the mental fortitude right now to figure that out, but maybe someone else does
23:53:25 --- mode: ChanServ set +b *!*@70.51.242.179
23:53:25 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
23:53:57 <Geraldus> HeladoDeBrownie: Thank you anyway! Have a good day!
23:54:52 <Ch0c0late> Can I say that because of pure behavior of Haskell and its immutability feature the only place that I can find security hole is when I talk to outside of haskell world using Monads or Arrows? So the type system is safe enough. Right? johnw
23:55:38 <johnw> Ch0c0late: that is not really correct
23:55:56 <johnw> the security hole can come either from the Haskell runtime, or from an error in your program
23:56:03 <johnw> types can help eliminate the latter
23:56:08 <johnw> but you will always be at the mercy of trusting the runtime
23:56:12 <Ch0c0late> Yes
23:56:24 <johnw> so, purity here isn't a guarantee of anything
23:56:29 <Ch0c0late> Yes
23:56:38 <johnw> but it doesn't make certain errors more obvious
23:56:40 <johnw> does8
23:56:48 <Ch0c0late> Yes
