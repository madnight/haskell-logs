00:08:44 * hackagebot esqueleto 2.1.2.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.2.2 (MichaelSnoyman)
00:08:44 * hackagebot Zora 1.1.22 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.22 (bgwines)
00:28:40 * hackagebot HaTeX 3.16.1.1 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.16.1.1 (DanielDiaz)
00:29:08 <safinaskar> as well as i know simple reference counting doesn't enough in haskell runtime. so, runtime uses gc. why? there is cyclic graphs of references? why? i don't see any cyclic data structures in haskell
00:32:33 <Axman6> @src cycle
00:32:33 <lambdabot> cycle [] = undefined
00:32:33 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:32:40 <Axman6> > cycle [1,2,3]
00:32:41 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
00:33:50 <Axman6> safinaskar: it's not that uncommon to have things in haskell
00:35:04 <safinaskar> Axman6: so, "cycle" creates data which is represented internally as cyclyc graph, right? and so, we need GC to collect such garbage?
00:45:06 <Axman6> safinaskar: yes
01:02:01 <safinaskar> Axman6: if i just write "a = "a" ++ a" at top level, this is cyclic structure, too? and "f 0 = 1; f n = n * f (n - 1)" too? i. e. recursive functions implemented as cyclic structures?
01:08:06 <nelk> Does anyone know why I might be getting linker errors for multiple label definitions when installing mtl-2.2.1 as part of bootstrapping cabal-install-1.22.2.0? I just installed ghc-7.10.0.
01:13:55 <dgorbik_> how can I change the "selection" for haskell-structured-mode?
01:27:29 <ij> I have a RWST monad with IO as the inner monad. Suppose I'm inside it and I have another such RWST+IO action that I want to forkIO. I can go IO -> RWST with liftIO from MonadIO, but how could I do it the other way around?
01:28:43 * hackagebot HDBC 2.4.0.1 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.4.0.1 (ErikHesselink)
01:59:57 <nshepperd> ij: what would you expect that to do?
02:01:56 <nshepperd> ij: the forked action won't be able to manipulate the pure RWST state from the original thread
02:04:41 <nshepperd> ij: ie. forkIO (put "hello") wouldn't do anything useful
02:08:45 * hackagebot rest-client 0.5.0.2 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.5.0.2 (ErikHesselink)
02:11:04 <ij> Hmm, I see the problem now.
02:13:26 <nshepperd> if you want a bunch of forked threads to be able to manipulate some mutual state, you probably want a TVar or something
02:18:34 <ij> And could I do it if I want it to be able to access state that was there when the thread was spawned, but not change state?
02:20:25 <mniip> just use a closure
02:20:34 <mniip> (reader monad)
02:45:55 <nshepperd> ij: yes, if you don't care about manipulating the main thread's state, you can use runRWST and manually decide what to do with the new thread's Reader, State and Writer data
02:58:48 * hackagebot stackage-curator 0.7.0.3 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0.3 (MichaelSnoyman)
03:23:59 <Tehnix> In a lot of Miller-Rabin (primality check) implementations I see functions to do exponential modulo instead of just `a^d mod m`. Is the only reason for efficiency, or does it give different results?
03:27:22 <randir> If I have two pattern-matching function instances, can I get a where binding to bind to both?
03:27:34 <randir> like: foo :: Int -> Int
03:27:43 <randir> foo 5 = 1
03:27:56 <randir> foo 6 = b
03:28:01 <randir> foo 7 = b+1
03:28:05 <randir> where b = 3
03:28:29 <mniip> randir, you can have foo x = case x of
03:28:43 <mniip> at no performance cost because that's what it gets immediately translated into
03:29:41 <randir> okay, thanks
03:29:43 <int-e> Tehnix: it's essential for efficiency; d is rather large and a is of the same order of magnitude as p; modular exponentiation keeps the intermediate results below p, wheras a^d would have about d times as many bits..
03:30:13 <int-e> Tehnix: err, m, not p.
03:32:44 <int-e> Tehnix: It's really the same with calculations on paper. 2^16 (mod 11) is quick by squaring 2 four times: 2 -> 4 -> 5 -> 3 -> 9, whereas reducing 65536 modulo 11 will take a bit longer.
03:49:20 <Tehnix> int-e: ah, thanks :)
04:13:52 * hackagebot snaplet-recaptcha 1.0.2 - A ReCAPTCHA verification snaplet with Heist integration and connection sharing.  http://hackage.haskell.org/package/snaplet-recaptcha-1.0.2 (MikeLedger)
04:48:54 * hackagebot snaplet-recaptcha 1.0.3 - A ReCAPTCHA verification snaplet with Heist integration and connection sharing.  http://hackage.haskell.org/package/snaplet-recaptcha-1.0.3 (MikeLedger)
04:51:11 <merijn> Whoo
04:51:20 <merijn> SIGBOVIK conference proceedings are out :p
04:58:23 <merijn> oh lord...
04:59:06 <merijn> "Bashing Haskell: Reimplementing the Parsec Library Inside the Unix Shell - Functional^H^H^H^H^H^H^H^H^HImperative Pearl"
05:02:46 <mniip> I implemented 2048 for sh (dash) once
05:03:22 <merijn> http://sigbovik.org/2015/proceedings.pdf
05:07:19 <FireFly> They're amusing
05:08:40 <mniip> red
05:08:41 <mniip> i
05:08:42 <mniip> removal
05:09:53 <merijn> :)
05:10:14 <merijn> I also liked the "Burritos for mathematicians" paper :p
05:11:00 <FireFly> The hand-held printing device was amusing as well
05:11:18 <merijn> "a burrito is just a strong monad in the symmetric monoidal category of food; what's the big deal?"
05:11:45 <FireFly> http://xen.firefly.nu/up/2015-03-29_141006.png
05:12:18 <mniip> FireFly!
05:12:26 <FireFly> mniip!
05:12:47 <FireFly> It's that time of the year again
05:13:10 <mniip> march 29?
05:13:18 <FireFly> Well, almost-april-1
05:13:26 <mniip> :)
05:13:31 <int-e> mniip: a leak from the future
05:13:44 <mniip> int-e, ?
05:14:40 <int-e> mniip: it says rright there on the cover page that the proceedings are from April 1st this year.
05:16:24 <mniip> FireFly, are you looking forward to fn's april fools challenge
05:16:33 <FireFly> Indeed
05:16:49 * mniip shows off his fancy cloak
05:16:56 <FireFly> :<
05:17:15 <FireFly> I gotta reach the final room this year
05:17:33 <mniip> where did you get last year
05:17:55 <FireFly> I think the UVB-76-referencing channel
05:18:04 <mniip> ah
05:18:21 <FireFly> So the second or third to last
05:18:33 <mniip> I think I ended up reverse-engineering the foursquare cipher from the known plaintext-ciphertext pair
05:18:59 <mniip> reverse engineering the key I mean
05:19:01 <FireFly> I did win the #ircpuzzles puzzle last summer, so there's that
05:20:55 <mniip> FireFly, I also won the book btw
05:21:21 <mniip> s/the/a/
05:21:24 <lpaste> d-snp pasted ‚ÄúFlipping monads‚Äù at http://lpaste.net/129824
05:22:16 <FireFly> mniip: fancy, what book?
05:22:16 <d-snp> I'm a bit stuck with this monad thing, I now have a Maybe (M Type) and I want it to be M (Maybe Type)
05:23:24 <mniip> http://imgur.com/a/TqIaF
05:23:34 <merijn> d-snp: What's the type of 'ret'?
05:24:03 <merijn> d-snp: And the type of maybeExpression, and the type of generateExpression, etc.
05:24:34 <d-snp> ret :: Maybe Operand -> Codegen (Named Terminator)
05:25:09 <d-snp> generateExpression takes a CExpr and returns a Codegen (Operand)
05:25:21 <d-snp> shall I put all that in the paste as well?
05:26:12 <mniip> FireFly, ^
05:27:57 <lpaste> d-snp revised ‚ÄúFlipping monads‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/129824
05:31:00 <FireFly> mniip: neat
05:33:05 <d-snp> this sort of thing always gets me stuck
05:33:28 <d-snp> is it because I've not gone through a disciplined course on monads, or is it just practice?
05:46:06 <mpickering> d-snp: I would say it's just practice
05:46:34 <mpickering> see on lines 4 and 5 how you have a return on both branches
05:46:55 <mpickering> that's a bit of a smell that you should have used "let" instead of "<-"
05:49:25 <absence> is it possible to interpret a Vector Double as a Vector (Double, Double) with half the number of elements, and/or the other way round?
05:49:40 <mpickering> but that won't work as the first branch uses "generateExpr" 
05:50:10 <merijn> Just <$> generateExpression expr
05:50:20 <mpickering> so I think you need .. ^
05:50:45 <mmachenry> absence: what do you mean interpret? You want to convert to that? There's one caveat is what do you do it there's an odd number of elements?
05:50:48 <merijn> d-snp: You're wrapping the entire Codegen in maybe and then wrapping in Codegen *again* to make it match the bottom case
05:51:04 <merijn> d-snp: While you clearly want to wrap the Just *inside* the codegen to match the Nothing case
05:51:10 <merijn> d-snp: i.e., you want fmap
05:53:00 <absence> mmachenry: by "interpret" i mean not create a whole new vector by copying the elements, but rather have a dummy vector sit on top of it or something, and convert each element on demand. i'll just assume that there's an even number of elements for now
05:53:33 <d-snp> thanks mpickering, merijn, I'll try it out
05:53:56 <mmachenry> absence: On demand? You mean lazily? Yes that'd be the default if you were to write a program to convert from one to the other.
05:54:47 <merijn> d-snp: Also, why not simplify like so to eliminate the case: http://lpaste.net/129824
05:55:03 <merijn> It's still a bit ugly due to the way ret expects to take it's arguments
05:55:17 <merijn> But you could refactor that
05:55:20 <absence> mmachenry: true, but it would also store the values afterwards, right?
05:56:05 <d-snp> hmm
05:56:06 <lpaste> merijn annotated ‚ÄúFlipping monads‚Äù with ‚ÄúSimplified more‚Äù at http://lpaste.net/129824#a129827
05:56:09 <merijn> Or better, this
05:56:56 <mmachenry> absence: Well the same references but it wouldn't take any more memory that the memory it would take to have a vector of tuples of references.
05:57:12 <merijn> Depending on what 'ret' does, you could make it nicer still
05:57:29 <d-snp> that makes total sense merijn
05:57:59 <absence> mmachenry: but i don't want to store a vector of tuples
05:58:27 <absence> mmachenry: by "dummy vector that sits on top" i meant one with no storage
05:58:55 <absence> mmachenry: or rather, one that uses the underlying non-tuple vector as its storage
05:59:51 <ocramz> hi there; anyone with FFI experience here?
06:00:02 <mmachenry> absence: Why don't you just write a function that looks up the vector using the new scheme you're talking about?
06:00:21 <ocramz> namely, using wrapping shared library functions
06:02:18 <absence> mmachenry: i'd need to write functions for some of the other vector operations as well. i can do that, but just wanted to check if there was an alternative solution before i go ahead and reimplement parts of the vector api
06:02:45 <merijn> d-snp: Refactor early, refactor often ;)
06:02:50 <merijn> ocramz: Yeah, what's the problem?
06:03:33 <mmachenry> absence: If I were you, I'd do the first suggestion. I don't think what you're talking about is possible but I could be wrong.
06:04:12 <fractalsea> Is there a way of using the websockets library that doesn‚Äôt involve writing the client app as a callback?
06:04:34 <fractalsea> i.e. connect -> handle errors -> run app -> close connection all linearly
06:06:32 <absence> mmachenry: oh wait, Vector is a typeclass! minimal complete definition is five functions, which gives me the whole api
06:06:35 <ocramz> merijn: do the "foreign ccall" interfaces stay the same if I link to static or dynamic versions of the libraries? 
06:08:10 <mmachenry> absence: Isn't your data type already an instance of Vector?
06:08:11 <ocramz> merijn: I wrote about it in some detail here: http://stackoverflow.com/questions/29324155/library-design-of-petsc-ffi-in-haskell
06:08:57 <absence> mmachenry: yes, it's a Storable.Vector. if i wrap it in a newtype or something, i can provide a Generic.Vector instance
06:08:58 <merijn> ocramz: foreing ccall interface should produce binary that is identical to what C exposes for the platform you're compiling on
06:09:33 <merijn> ocramz: Quick note: alloca and unsafePerformIO will lead to tears
06:09:41 <merijn> ocramz: Why do you think you need unsafePerformIO?
06:10:02 <absence> mmachenry: sorry, that's apparently "no, it's a Storable.Vector" which isn't a typeclass. a bit confusing with the overloaded naming :)
06:10:36 <ocramz> to operate on the results within the pure part of the Hs code
06:10:56 <absence> mmachenry: but either way, newtype or data does the trick
06:10:57 <merijn> ocramz: That's not going to work, because your C code most likely isn't pure
06:11:27 <mmachenry> absence: Ah cool. Good luck.
06:11:32 <merijn> ocramz: Your C functions HAVE to be IO, unless you're 100% sure they're pure and even most you're sure a pure aren't
06:11:47 <absence> thanks
06:12:00 <merijn> Consider that ANYTHING using errno is not threadsafe, for example
06:12:19 <merijn> Can you use mpirun with GHC binaries, yes, BUT
06:12:21 <ocramz> merijn: true, it's not pure code. So these parts will have to stay in IO and I will have to lift the purely functional bits
06:13:02 <merijn> Most people use mpicc for compiling mpi programs, which does some pre-/postprocessing on the compiled C. Which GHC clearly won't do
06:13:27 <merijn> You can probably somehow get MPI to work when compiled with something other than mpicc, but this will require some hairy work
06:14:38 <merijn> I don't think it'll be inherently difficult, but it'll probably be really poorly documented what to do
06:15:03 <merijn> As for mpirun itself, it doesn't actually do anything magical except set a bunch of environment stuff, afaik
06:15:31 <merijn> ocramz: Also, your sample are using unsafe imports, which is almost certainly not what you want
06:16:28 <ocramz> merijn: could you expand on this? I'm still processing a question regarding mpicc
06:17:11 <merijn> ocramz: Expand on which part?
06:17:27 <ocramz> about unsafe imports being a bad idea
06:18:12 <merijn> ocramz: unsafe imports mean "import in an unsafe way", not "import an unsafe thing" :)
06:18:24 <merijn> See, for example, http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
06:20:19 <ocramz> merijn: thanks, I did see that article some time ago but only now appreciate its meaning
06:21:49 <fractalsea> If a library has modules that are non-exposed, is there any way of using them without patching the library?
06:21:59 <merijn> Anyway, if you tell GHC where to find your mpi libraries and headers it should be able to compile and link with MPI no problem and that should also work with mpirun
06:22:03 <merijn> fractalsea: No
06:22:20 <fractalsea> merijn: OK, thanks
06:22:40 <ocramz> merijn: I guess I also have to compile mpich as a dynlib then?
06:23:47 <merijn> ocramz: AFAIK GHC defaults to using dynamic linking for C libraries, but I'm pretty sure it can statically link them without too much problems, since GHC uses the system linker since 7.8 (or was it 7.6?)
06:26:07 <merijn> ocramz: You can use -optl to pass options to the linker, so that should be the same as using C
06:26:45 <ocramz> merijn: awesome, thanks
06:29:13 <haskell933> Hi, all. 
06:31:07 <breadmonster> Hi haskell933 
06:31:21 <merijn> ocramz: I expect something like "-optl-static -lopenmpi" or similar should be sufficient
06:31:23 <lemmih> haskell933: Yo.
06:31:50 <haskell933> This is the first time I am using IRC. Seemed like a regular chatroom at first. But it's kind of weird 
06:32:52 <breadmonster> merijn: When you run --ddump-simpl what are all the # symbols after identifiers?
06:33:59 <merijn> breadmonster: # by convention is used for unboxed types/values
06:34:19 <merijn> So Int# is an unboxed int, vs Int which is a boxed int
06:34:20 <breadmonster> Is it a legal Haskell identifier character?
06:34:25 <merijn> no
06:34:32 <merijn> You need -XMagicHash to allow it
06:34:45 <breadmonster> No, but what I mean is can I use it in my identifiers?
06:34:52 <breadmonster> In high level Haskell code?
06:34:58 <merijn> Yes, if you enable MagicHash, but you shouldn't
06:35:31 <merijn> Because by convention it is ONLY used for unboxed, so unless your high level haskell involves lots of unboxed values (which almost certainly means it's not high level :p)
06:35:52 <doweaver> Is there a standard approach to making custom data types printable? That is, if I wanted to be able to print my type "Foo", I think I could do it by making it an instance of Show, or creating a function directly that converts Foo -> IO (). I'm guessing one of those ways is the normal way... but I'm not sure which one 
06:36:01 <merijn> breadmonster: Repercussions may involve people calling you names, cursing you with voodoo dolls and/or crying
06:36:45 <merijn> doweaver: Show for "haskell syntax/debug representations" "Foo -> IO ()" and/or one of the pretty-print classes for formatted user output
06:37:22 <doweaver> merijn: Makes sense. Thank you!
06:37:45 <bazqux> Foo -> String would probably be nicer than just Foo -> IO () I'd think.
06:38:14 <merijn> Oh, true
06:38:16 <doweaver> bazqux: Ah, yeah.
06:38:32 <merijn> But then there's probably even better alternatives in the billion pretty-print libraries :p
06:38:44 <bazqux> Foo -> IO () can always call the Foo -> String of course.
06:44:41 <ocramz> merijn:  "-optl-static" produces a statically built binary, whereas "-lopenmpi" links to the dynlib version of OpenMPI, is this correct?
06:46:23 <merijn> ocramz: "-lopenmpi" just tells it to link OpenMPI (static or dynamic), "-optl-static" just passes "-static" to the linker, which should force it into linking everything statically, but I'm not 100%, my linker knowledge is fairly basic
06:47:56 <ocramz> merijn: the aim being to obtain a large binary with all the dependencies inside, in order to call it with mpirun
06:49:02 <merijn> ocramz: You don't need to be statically linked for mpirun
06:49:35 <ocramz> merijn: ok, I see. I haven't experimented with it yet
06:49:40 <merijn> You just need all machines that will run the binary to have the right libraries installed
06:49:49 <merijn> I never static linked my MPI C code
06:50:01 <ocramz> merijn: this is excellent, I should be able to produce a mini-binding in few days :)
06:50:52 <ocramz> merijn: yeah well the machines will either be my laptop or the CentOS HPC cluster at my uni
06:51:34 <ocramz> as long as I can provide something that's runnable by mpirun, all is fine. The dependencies are already in place
06:56:22 <absence> is there an overview or something that can tell me which memoisation library to use for different situations?
06:59:58 <nshepperd> hmmm, is there anything that would make it silly to use GADTs to carry around the type constraints for Data.Vector.Unboxed and the like?
07:00:49 <bazqux> Is there any sort of accepted standard for when one should use $ as opposed to parentheses?
07:01:20 <nshepperd> I mean like "data Vector a where Vector :: (Unbox a) => U.Vector a -> Vector a"
07:01:33 <ChristianS> bazqux: i tend to use $ whenever it's possible
07:01:49 <nshepperd> I found myself wishing for this, because it would allow us to make Unboxed vectors Foldable
07:01:59 <bazqux> ChristianS: Would you use it multiple times in one line?
07:02:44 <ChristianS> bazqux: rarely, usually i write a . b . c $ d instead of a $ b $ c d
07:02:50 <bazqux> Of course one can use where clauses to avoid both.
07:03:01 <ChristianS> bazqux: or something like that, i.e. i prefer . over $
07:03:27 <bazqux> ChristianS: Yes, composition seems more proper than both to me.
07:05:22 <fractalsea> Is there a way of lifting a function (a -> IO b) -> IO b to MonadIO? I know I could use liftBaseOp from Monad Base Control, but then the type signature would not be what I want (i.e. MonadIO m => (a -> m b) -> m b)
07:11:41 <mauke> :t \f g -> liftIO (f (liftIO . g))
07:11:43 <lambdabot> (MonadIO m, MonadIO m1) => ((a1 -> m1 a2) -> IO a) -> (a1 -> IO a2) -> m a
07:12:23 <mauke> oh, right
07:15:30 <safinaskar> is this true that (==) instantly returns true if operands are same object (i. e. same object in memory)?
07:18:47 <ion> bazqux: FWIW, I find (f . g . h) x nicer to read than f . g . h $ x
07:19:28 <bazqux> ion: Yes I think I do too.
07:23:31 <safinaskar> ion: bazqux: you can write "f $ g $ h $ x" or "f $ g $ h x" instead of both variants
07:25:34 <merijn> safinaskar: That's highly unlikely
07:25:48 <merijn> safinaskar: Also, what do you mean by instantly?
07:26:12 <merijn> safinaskar: And further: Don't write "f $ g $ h $ x" OR "f $ g $ h x", write "f . g . h $ x"
07:28:22 <bazqux> To me $ feels like a bit of a hack whereas . feels like something more 'proper'. But I'm a newbie so maybe that is just daft.
07:29:09 <hpc> it's not that ($) is a hack, so much as the properties of (.) being more useful
07:29:26 <merijn> Exactly
07:29:33 <hpc> for instance, ($) really shines here
07:29:37 <merijn> bazqux: The problem is with associativity
07:29:55 <hpc> > fmap ($ 5) [(+ 6), (* 2), (`div` 3)]
07:29:57 <lambdabot>  [11,10,1]
07:30:07 <merijn> bazqux: Any subexpression of a (.) pipeline can be moved into a local binding without changing the code's meaning/type
07:30:19 <merijn> bazqux: The same doesn't hold for $, therefore . is easier to refactor
07:30:30 <merijn> And should be preferred over $
07:31:09 <hpc> and that's because of how it gets "parenthesized"
07:31:13 <hpc> (f . g . h) x
07:31:14 <hpc> vs
07:31:19 <hpc> f (g (h x))
07:31:58 <merijn> "f . g . h $ x" -> "let foo = g .h in f . foo $ x" this works
07:32:35 <merijn> "f $ g $ h $ x" -> "let foo = g $ h {- whoops, doesn't type check! -} in f $ foo $ x" this doesn't
07:33:09 <nshepperd> (.) is a form of category composition, and therefore intrinsically better :p
07:33:31 <safinaskar> merijn: instantly - i. e. using just pointer comparision (of course, if pointers differ, fail-back to normal comparision)
07:34:04 * hackagebot blunt 0.0.15 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.15 (fozworth)
07:35:45 <safinaskar> merijn: instantly - i. e. using just pointer comparision (of course, if pointers differ, fail-back to normal comparision)
07:36:08 <safinaskar> merijn: and why f . g $ x is better?
07:36:13 <merijn> Haskell is lazy, it won't compare at all if you never check, so the definition of instantly is vague
07:36:24 <merijn> And no, it never uses ptr equality, afaik
07:36:37 <merijn> Read the past few minutes on why f.g $ x is better
07:38:53 <safinaskar> merijn: ok, thanks
07:39:53 <safinaskar> why :~: exists?
07:40:00 <safinaskar> i. e. Data.Type.Equality
07:40:57 <safinaskar> if i want to be sure that "a" and "b" have same type, i can just pass it to, for example, "f :: a -> a -> b -> b", "f _ _ x = x"
07:44:05 * hackagebot blunt 0.0.5 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.5 (fozworth)
07:47:44 <bananagram> readIO seems to be read but with the IO monad...
07:47:49 <bananagram> what's the point of that?
07:48:40 <bananagram> maybe so you can bind it with readFile?
07:49:05 * hackagebot blunt 0.0.4 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.4 (fozworth)
07:49:06 <Clint> The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program. 
07:49:07 * hackagebot blunt 0.0.3 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.3 (fozworth)
07:49:09 * hackagebot blunt 0.0.2 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.2 (fozworth)
07:49:11 * hackagebot blunt 0.0.1 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.1 (fozworth)
07:49:20 <bananagram> oh, okay
07:52:45 <raek> When writing attoparsec parsers I feel the need for an OverloadedChars extension :-)
07:53:27 <Mark-z> 8√≤ This is your game ? http://www.desura.com/games/aeon-ball
08:11:54 <rabisg> safinaskar: https://typesandkinds.wordpress.com/2012/12/01/decidable-propositional-equality-in-haskell/ is the motivation behind this. It is helpful for the same reason as (a ~ b) is
08:14:32 <Hi-Angel> Is Module ¬´Text.Regex.Posix¬ª buggy? I.e. when I am enter there ¬´"qtext\">–∫–æ–º–±–∏–Ω–∞—Ü–∏—è</div" =~ "qtext\">[^<]*" :: String¬ª, I got just ¬´"qtext\">\1082\1086"¬ª, that's too low ‚òπ Are there any non-buggy good libraries?
08:14:40 <Darwin226> Hey guys, got a parsec question. Let's say my monad is State Int, if I have a parser like this one 'modify (+1) *> p <* modify (subtract 1)', what happens if p fails? Does the state still get incremented?
08:15:36 <geekosaur> ew, regex for html/xml
08:16:29 <Hi-Angel> geekosaur, it is pretty simple script, just for self-education in haskell
08:17:02 <geekosaur> "Note that the posix library works with single byte characters, and does not understand Unicode. If you need Unicode support you will have to use a different backend."
08:17:07 <glguy> Darwin226: Not afaik. If you want state that rolls back on failure you can use Parsec's built-in user-state
08:17:24 <Hi-Angel> geekosaur, ahÖ I seeÖ
08:17:28 <Hi-Angel> Thank you
08:17:36 <jdnavarro> I can't manage to build the documentation of the dependencies in a cabal sandbox
08:17:45 <merijn> Hi-Angel: Posix regex doesn't do unicode
08:18:05 <merijn> Hi-Angel: You should use a HTML parser anyway
08:18:27 <Darwin226> glguy: I think I just realized a fatl flaw in my understanding of Parsec. I use both the user state Int and my monad is State Int.
08:18:45 <jdnavarro> shouldn't `cabal install --only-dependencies --enable-documentation` just build the documentation for all depencencies?
08:18:49 <Darwin226> glguy: Wait a second. How does that even work. What does modify do then?
08:19:15 <Hi-Angel> merijn, okay, since Regex.Posix if off, now I'll try an html parser)
08:19:23 <Hi-Angel> *is off
08:19:24 <geekosaur> there are other backends
08:20:06 <geekosaur> T.R.TDFA is slower but handles Haskell native Char-s and is available everywhere as well (T.R.Posix obviously only on POSIX systems)
08:20:15 <geekosaur> there are also several PCRE backends
08:20:41 <geekosaur> ...one that obeys the baroque Text.Regex interface and several that provide saner ones
08:21:24 <hexagoxel> jdnavarro: what did you try, what did you observe, what do you not like about it?
08:22:13 <Hi-Angel> Thank you geekosaur 
08:22:17 <merijn> Hi-Angel: html-conduit worked pretty well for me
08:23:52 <jdnavarro> hexagoxel: I already created a sandbox, but when installing the dependencies with documentation enabled, I can't see any documentation being built
08:24:38 <jdnavarro> hexagoxel: I tried `cabal install --only-dependencies --enable-documentation -j`
08:24:51 <hexagoxel> jdnavarro: enabled via ~/.cabal/config? the documentation should be put in .cabal-sandbox/share/..
08:25:41 <jdnavarro> hexagoxel: yeah, I also enabled it in .cabal/config and I'm looking in .cabal-sanbox...
08:26:11 <geekosaur> is there a cabal.sandbox.config? and if so, does it set the documentation flag?
08:26:15 <jdnavarro> hexagoxel: I'm trying to reinstall the packages, now I'm building from scratch
08:27:01 <jdnavarro> it works when I do it from scratch
08:28:47 <jdnavarro> geekosaur: I don't see the documentation flag in cabal.sandbox.config
08:29:03 <geekosaur> ok, just checking
08:30:20 <jdnavarro> well, it works when recreating the sandbox
08:30:38 <jdnavarro> for some reason when reinstalling it wasn't building the docs
08:31:21 <jdnavarro> hexagoxel, geekosaur: thanks for your help!
08:32:38 <lpaste> glguy pasted ‚Äúparser state example for Darwin226‚Äù at http://lpaste.net/129829
08:34:08 * hackagebot dynamic-cabal 0.3.5 - Access the functions from the Cabal library without depending on it  http://hackage.haskell.org/package/dynamic-cabal-0.3.5 (BennoFuenfstueck)
08:44:08 * hackagebot overture 0.0.1 - An alternative to some of the Prelude.  http://hackage.haskell.org/package/overture-0.0.1 (fozworth)
08:59:09 * hackagebot nicovideo-translator 0.1.0.0 - Nico Nico Douga (À≥À≥’;) Comment Translator  http://hackage.haskell.org/package/nicovideo-translator-0.1.0.0 (hongminhee)
09:02:04 <xIzIv> hi here
09:02:53 <xIzIv> I want to know is my object list of tuples or just string
09:03:22 <geekosaur> Haskell is strictly typed; you should know the type beforehand...
09:04:52 <xIzIv> geekosaur: yep;) I even forgot about it
09:04:59 <xIzIv> thanks)
09:09:10 * hackagebot llvm-general-pure 3.3.14.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.14.1 (BenjaminScarlet)
09:09:12 * hackagebot llvm-general 3.3.14.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.14.1 (BenjaminScarlet)
09:09:14 * hackagebot llvm-general-pure 3.4.5.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.5.1 (BenjaminScarlet)
09:09:16 * hackagebot llvm-general 3.4.5.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.5.1 (BenjaminScarlet)
09:14:39 <kafor7> hello
09:14:54 <kafor7> I don't know what does it mean discarded with QuickTest ?
09:15:08 <kafor7> I get a lot of discraded test and after all gave up...
09:15:15 <mauke> my crystal ball says: ==>
09:15:20 <mauke> but what's the actual message?
09:15:58 <kafor7> *** Gave up! Passed only 9 tests.
09:16:10 <kafor7> I got this script from my university
09:16:22 <kafor7> and others don't have that error
09:17:06 <kafor7> it makes me crazy...
09:17:14 <mauke> that doesn't contain "discarded"
09:17:50 <kafor7> ...
09:18:04 <kafor7> it shows after too many tests are discarded
09:18:10 <dolio> kafor7: For certain ways of combining properties where a first property has to hold before checking a second, quickcheck will just generate possibilities for the first property, and throw out the whole case if it doesn't pass.
09:18:11 <mauke> but what's the actual message?
09:18:33 <dolio> And it will only try so many total checks before giving up entirely.
09:18:35 <kafor7> mauke: I worte it *** Gave up! Passed only 9 tests.
09:18:39 <mauke> that doesn't contain "discarded"
09:18:43 <kafor7> ahh
09:18:50 <dolio> Even if it doesn't get the target number of passed tests.
09:19:05 <kafor7> mauke if you are not familiar with QuickTest please do not waste my time :)
09:19:30 <mauke> if you are not able to copy/paste text, please do not waste my time
09:19:56 <kafor7> so goodbye
09:20:18 <kafor7> Gave up error is generated afetr too many tests are discarderd.. I've written it
09:20:24 <kafor7> dolio: hmm I don't get it
09:20:46 <mauke> that's not the actual message
09:20:49 <StoneCypher4k> <3 mauke
09:20:57 <mauke> for one, it wouldn't say "discarderd"
09:21:06 <kaiyin> how can you demonstrate that Num t => t is a monoid under multiplication in actual code?
09:21:23 <kaiyin> for example, this won't work:
09:21:29 <kaiyin> > mconcat [1, 2, 3]
09:21:31 <lambdabot>      No instance for (Show a0)
09:21:31 <lambdabot>        arising from a use of ‚Äòshow_M716237208535127564712992‚Äô
09:21:31 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
09:21:32 <mauke> kaiyin: I don't think that's true
09:21:39 <StoneCypher4k> kafor7: is quicktest a knockoff of quickcheck or something
09:21:42 <kafor7> dolio: what do you exactly mean because I'm not very familiar with haskell
09:22:29 <mauke> kaiyin: wait, I don't understand what you're trying to do
09:22:38 <mauke> is this about monoids in general or Monoid the class?
09:22:45 <kafor7> StoneCypher: there is something like this it runs several tests (8 tests, 1000 discarded) for istance and after all I get *** Gave up! Passed only 8 tests.
09:22:46 <mauke> and are you trying to write a mathematical proof?
09:22:54 <dolio> @check \x y -> (x > 1000000) ==> (y > 1000000)
09:22:55 <lambdabot>  *** Gave up! Passed only 0 tests.
09:22:55 * StoneCypher4k reads the rest of the text, realizes he doesn't want to be involved, and walks away
09:23:02 <kaiyin> mauke: why not? 1. closure 2. unit is 1 3. associativity 
09:23:07 <StoneCypher4k> mauke: he's doing his homework
09:23:25 <mauke> kaiyin: how do you know 1 is a unit?
09:23:34 <kaiyin> mauke: x * 1 = x
09:23:37 <dolio> kafor7: That test generates random x and y, and then tests for x > 1000000. If it isn't, it throws that test case away.
09:23:50 <dolio> Even if (y > 1000000) doesn't hold.
09:23:53 <mauke> kaiyin: that's just a repetition of your statement. why would it hold true?
09:24:01 <StoneCypher4k> dolio: careful not to do too much of his homework for him.  if he can't figure this out he's screwed when they start using the tool seriously
09:24:22 <kaiyin> mauke: I don't know, because it's defined so?
09:24:25 <dolio> StoneCypher4k: Is his homework to explain how quickcheck works?
09:24:41 <mauke> kaiyin: it's not defined so
09:24:57 <StoneCypher4k> dolio:  no.  did you think later work in quickcheck won't require him to be able to write tests that actually get used?
09:24:57 <kafor7> dolio : I've just get a script from my university and my friends say it works fine and I have no idea how QuickTest works
09:25:08 <StoneCypher4k> dolio: ... see?
09:25:33 <kaiyin> mauke: I am not getting it. What's your point?
09:25:38 <kafor7> I'm a C++ programmer I'm not interested in haskell at all :)
09:25:44 <kafor7> I just wan to pass this subject
09:25:58 <StoneCypher4k> kafor7: you're not going to succeed with that attitude.  also not in c++.
09:26:23 <kafor7> BUt I have no time to investigate in carefully :)
09:26:32 <kafor7> I've got plenty of proffesional work to do
09:26:43 <mauke> kaiyin: that "Num t => t is a monoid under multiplication" is not a true statement
09:26:46 <StoneCypher4k> kafor7: that's nice.  this isn't the "let's cheat because we're too busy for school" channel.
09:26:53 <mauke> and hence would be impossible to prove
09:26:55 <dolio> kafor7: You didn't write the script?
09:27:00 <StoneCypher4k> no of course he didn't
09:27:08 <StoneCypher4k> he doesn't even know what quickcheck does yet
09:27:08 <kafor7> dolio: yes, I get it from my University
09:27:13 <kaiyin> mauke: so can we disprove it?
09:27:37 <dolio> StoneCypher4k: I thought you weren't interested in this conversation.
09:27:48 <mauke> kaiyin: instance Num Char where _ * _ = 'A'
09:28:23 <dolio> kafor7: Can you paste the script somewhere?
09:28:39 <kaiyin> mauke: i see your point. what about Int is a monoid under multiplication?
09:29:07 <kafor7> dolio: http://pastebin.com/6LNUUaqf
09:29:14 <kaiyin> that must be true, right?
09:29:23 <mauke> ... maybe?
09:29:33 <mauke> I haven't thought about how associativity interacts with overflow
09:29:47 <homovitruvius> if somebody has a few seconds, why I need the type constraint for Stream in http://dpaste.com/2MRYVFB?
09:29:57 <kaiyin> ok, i see, we may still have a problem.
09:30:03 <mauke> > (minBound * (-1)) * 2
09:30:04 <lambdabot>      No instance for (Show a0)
09:30:04 <lambdabot>        arising from a use of ‚Äòshow_M8598927788010359313174‚Äô
09:30:04 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
09:30:10 <mauke> > (minBound * (-1)) * 2 :: Int
09:30:12 <lambdabot>  0
09:30:40 <kaiyin> > minBound :: Int
09:30:42 <lambdabot>  -9223372036854775808
09:31:04 <simukis_> no overflow checking.
09:31:53 <exio4> @test \x y -> minBound * (x * maxBound) == (mindBound * x) * maxBound
09:31:53 <lambdabot> Maybe you meant: tell list let leet
09:32:00 <exio4> @check \x y -> minBound * (x * maxBound) == (mindBound * x) * maxBound
09:32:01 <lambdabot>  Not in scope: ‚ÄòmindBound‚Äô
09:32:01 <lambdabot>  Perhaps you meant ‚ÄòminBound‚Äô (imported from Prelude)
09:32:05 * StoneCypher4k sighs
09:32:21 <kaiyin> mauke: I see your point. 
09:32:34 <exio4> @check \x y -> minBound * (x * maxBound) == (minBound * x) * (maxBound :: Int)
09:32:36 <lambdabot>  +++ OK, passed 100 tests.
09:32:37 <exio4> there
09:32:54 <dolio> kafor7: You see the ==> in testSumA1 and such?
09:33:05 <kafor7> yes
09:33:27 <dolio> Well, if the first argument of ==>, which is the premise, doesn't hold, then the whole test case is thrown out.
09:33:49 <dolio> If enough test cases are thrown out, it gives up, and just reports how many actually worked.
09:34:07 <dolio> So that's what's happening.
09:34:16 <kafor7> hmm
09:34:45 <kafor7> accepts is a function that tells whether non deterministic finite automata accepts a word
09:34:45 <mauke> (psychic debugging)++
09:35:00 <mauke> (see my first answer)
09:35:05 <kaiyin> > minBound * (-1) :: Int
09:35:06 <lambdabot>  -9223372036854775808
09:35:10 <dolio> That code is pretty strange, though. a1 does not appear to be defined anywhere.
09:35:24 <dolio> Unless it's in Auto.
09:35:34 <kafor7> a1 is define here [a1,a2] = map fromAD [ad1,ad2]
09:35:46 <kafor7> 2 lines below testSumA1
09:35:56 <dolio> Oh, I see. The layout just hid it from me.
09:36:03 <kafor7> ok
09:37:30 <exio4> I didn't know 'where' could be used that way
09:38:07 <dolio> kafor7: Well, this appears to be generating random automata and random words, and testing whether the automata accept the words.
09:38:08 <kafor7> dolio: so ==> behaves like a mathematical implication ?
09:38:09 <kaiyin> How come minBound * 2 :: Int is equal to 0?
09:38:21 <kafor7> dolio: yes you're right
09:38:22 <dolio> kafor7: Yes.
09:38:46 <mauke> kaiyin: it's probably 100...000 in binary and the (*2) shifts the last 1 bit out
09:38:54 <kafor7> and it fails if and only if when True ==> False ?
09:39:27 <_aj> hey guys
09:39:27 <dolio> kafor7: Right. And 'False ==> a' just generates a new test case and tries again.
09:39:35 <kafor7> ok
09:40:00 <dolio> kafor7: So, randomly generating automata and words might not pass that premise very often.
09:40:22 <kafor7> But I'm the only person that my program doesn't work :D
09:40:28 <kafor7> so probably I've got a bug in my code
09:41:01 <_aj> Could anyone please help me with the usage of $ function. Oftentimes I get it wrong.
09:41:09 <dolio> I guess. If you wrote the automatas, maybe they reject too many things.
09:41:15 <mauke> _aj: when in doubt, don't use $
09:41:42 <dolio> Or, wrote the function that decides if an automata accepts.
09:41:47 <geekosaur> (a $ b) is the same as (a b) but with low precedence, so it kinda acts like reverse parentheses
09:42:17 <kaiyin> mauke: so, Integer must be a monoid under multiplication?
09:42:42 <geekosaur> as far as available memory permits, at least
09:42:55 <mauke> kaiyin: yeah, I'm pretty sure that's true
09:43:13 <kaiyin> ok, how can we demonstrate that?
09:43:16 <mauke> geekosaur: if (a * b) * c runs out of memory, then so should a * (b * c) :-)
09:43:24 <mauke> kaiyin: what do you mean by "demonstrate"?
09:43:51 <dolio> kafor7: The one you have uncommented, testThenA, is even more problematic. It has to randomly generate two automata and two words that are accepted by the respective automata.
09:44:05 <dolio> So if either of those fail, the test case will be thrown out.
09:44:27 <kafor7> yes
09:44:33 <kaiyin> mauke: sorry, at the moment I just want to show that mconcat works as expected with the Integer monoid.
09:44:55 <mauke> mconcat only works on instances of Monoid, not monoid-the-mathematical-concept
09:45:04 <mauke> and Integer is not an instance of Monoid
09:45:09 <kaiyin> oh, i see.
09:45:21 <mauke> > mconcat [2, 3, 5] :: Product Integer
09:45:22 <lambdabot>  Product {getProduct = 30}
09:45:25 <mauke> but Product is
09:45:36 <mauke> > mconcat [2, 3, 5] :: Product Int
09:45:37 <lambdabot>  Product {getProduct = 30}
09:47:00 <dolio> kafor7: A better way to write these tests would be to use the randomly generated automata and write a function that generates words that are accepted by them, so you never throw out a test case. But if that's not what your course gave you, there's not a lot you can do, I guess.
09:47:30 <kafor7> But I don't knoiw why I'm the only one that got that problem :)
09:47:35 <kafor7> I asked 3 my friends
09:47:40 <kafor7> So I have to figure it out..
09:48:05 <mauke> what's the exact assignment?
09:48:14 <dolio> Yeah, if no one else has noticed, it's probably a bug in your code, I guess. Good luck.
09:48:44 <kafor7> anyway, thanks dolio for your patience :)
09:48:50 <dolio> kafor7: Are you the one who wrote 'accepts'?
09:49:18 <kafor7> yes
09:49:22 <dolio> Okay.
09:49:46 <kafor7> But we have some other functions to write like sum of 2 automatas or concatenation
09:51:45 <dolio> Well, I would guess your accepts is wrong. Bugs in sumA and thenA would cause test failures rather than what you're seeing.
10:00:21 <monochrom> hahaha an oleg paper called "the next stage of staging"
10:01:10 <rasen> Hi, guys! Is there a quasi-quoter that just returns file content?
10:02:29 <rola> rasen, for example?
10:03:00 <Elite6809> Is there a function in prelude like this?: withSelf f x = (x, f x)
10:03:18 <Elite6809> > withSelf f x = (x, f x); withSelf exp 3
10:03:20 <lambdabot>  <hint>:1:14: parse error on input ‚Äò=‚Äô
10:03:30 <Elite6809> > let withSelf f x = (x, f x); withSelf exp 3
10:03:32 <lambdabot>  <hint>:1:44:
10:03:32 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:03:36 <Elite6809> > let withSelf f x = (x, f x)
10:03:38 <lambdabot>  <no location info>:
10:03:38 <lambdabot>      not an expression: ‚Äòlet withSelf f x = (x, f x)‚Äô
10:03:45 <Elite6809> you know what I mean
10:03:58 <Elite6809> > let withSelf f x = (x, f x) in withSelf exp 3
10:04:00 <lambdabot>  (3.0,20.085536923187668)
10:04:09 <rasen> rola: I have a file (at compile time) and want to have it available as pure variable
10:04:13 * hackagebot pipes-cliff 0.8.0.0 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.8.0.0 (OmariNorman)
10:04:27 <rola> rasen, oh so if I have a file1 with the content "foo $ bar", [yourQQ| file1 |] would be substituted for "foo $ bar" ?
10:05:05 <rasen> for "foo $ bar" :: String
10:05:43 <rasen> rola: Just found that answer: http://stackoverflow.com/a/12717160 Seems like what I want
10:05:45 <rola> oh ok
10:05:52 <rola> great !
10:09:14 * hackagebot JuicyPixels 3.2.3.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.3.1 (VincentBerthoux)
10:25:29 <narvius> Hello; I'm doing a thing where I have listen-reply loop, but I wanted to listen on two different channels. So what I did is, I took two Asyncs and poll them alternatingly (and when one finishes, I replace it with a functionally identical new Async).
10:25:54 <narvius> By "channel" I mean stdin and a socket handle.
10:26:16 <narvius> It seems to work just fine, but I'm wondering if there's a "better" or more idiomatic approach?
10:26:57 <narvius> I would use forkIO or something, but both listen "threads" are inside a monad transformer stack with state they both make use of.
10:30:17 <bennofs> hmm, would it be possible to have a function executeB :: :: Behavior t (FrameworksMoment a) -> Moment t (Behavior t a) in reactive-banana?
10:43:41 <breadmonster> Hey everyone.
10:43:45 <breadmonster> What are MVars?
10:44:16 * hackagebot pipes-cliff 0.8.0.2 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.8.0.2 (OmariNorman)
10:44:18 * hackagebot json-autotype 0.2.5.10 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.10 (MichalGajda)
10:44:50 <glguy> breadmonster: http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-MVar.html
10:53:00 <gelisam> bennofs: here's the closest I could reach: "stepper x0 <$> execute (b <@ eachFrame)". I use an extra value "x0 :: a" for the initial frame and an "eachFrame :: Event t ()" event to tell reactive-banana to recreate the network on every frame. Which is what I assume you're trying to do?
10:54:14 <fresheyeball_> hello out there
10:54:28 <fresheyeball_> anyone else on fpcomplete?
10:56:40 <fresheyeball_> hey phil
10:58:10 <bennofs> gelisam: I think I'll use start <- join $ initial b; (event, handler) <- newEvent; reactimate' (fmap handler <$> changes b); return $ stepper start event
11:04:17 * hackagebot fay 0.23.1.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.3 (AdamBergmark)
11:04:44 <mniip> how would one implement a safe variant of getLine
11:04:50 <mniip> maybeLine :: IO (Maybe String)
11:06:26 <lachenmayer> mniip: you could catch the EOF error, for example using `tryIOError :: IO a -> IO (Either IOError a)` in System.IO.Error
11:12:54 <gelisam> speaking of reactive-banana, is anybody here familiar with its implementation? I'm trying to understand its internal network of pulses and latches.
11:17:32 <jpsantos> (jpsantos) hey everybody. What's the usual way to implement join in terms of bind (>>=)?
11:17:43 <bennofs> jpsantos: (>>= id)
11:17:45 <bennofs> :t (>>= id)
11:17:46 <lambdabot> Monad m => m (m b) -> m b
11:17:59 <jpsantos> God I feel dumb now haha. Thanks bennofs
11:19:24 <jpsantos> For some reason bind in terms of join took me half a second
11:20:44 <tnks> jpsantos: I think it's because it involves figuring out what type parameters unify to.
11:21:17 <tnks> and sometimes people's first guess is wrong
11:22:29 <breadmonster> Can anyone point me to a good reference on IORef v MVar v TVar?
11:27:59 <Fuuzetsu> parconc book talks about this IIRC
11:29:35 <breadmonster> Fuuzetsu: parconc?
11:30:04 <Fuuzetsu> parallel and concurrent programming in haskell
11:30:11 <Fuuzetsu> though on second thought it might not have‚Ä¶
11:30:56 <Fuuzetsu> IORef = unsynchronised; MVar = synchronised; TVar = in STM
11:31:13 <Fuuzetsu> someone can correct me if I'm wrong
11:31:36 <breadmonster> synchronized?
11:31:38 <breadmonster> What do you mean?
11:31:41 <foolie> is the book any good?
11:31:48 <breadmonster> Sorry, I can't seem to find a good reference on this anywhree.
11:31:51 <Fuuzetsu> foolie: pretty good
11:31:52 <Thedarkb> oh i thought i was banned from here
11:31:53 <Thedarkb> wow
11:32:09 <Fuuzetsu> breadmonster: for threaded stuff
11:32:21 <Fuuzetsu> in what context are you asking this
11:32:35 <Fuuzetsu> or rather, MVar has the concept of being empty
11:32:46 <breadmonster> Fuuzetsu: I just heard about them, and I thought mutable variables in Haskell were done through the ST Monad.
11:32:53 <breadmonster> And more importantly, as IORefs.
11:32:56 <Fuuzetsu> so if one thread tries to read from empty MVar, it will wait until another thread puts into it
11:33:36 <safinaskar> i use expression parser in parsec. i have "~" prefix operator. and parser gives me syntax error on "~~a" and "~ ~a" (but not on "~(~a)"). what to do?
11:34:19 * hackagebot mwc-random 0.13.3.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.3.1 (AlexeyKhudyakov)
11:46:28 <mauke> safinaskar: show your code?
11:49:20 <safinaskar> mauke: my code is big. well, i will try to reduce it and show
11:57:25 <breadmonster> mauke: Umm, I have a question about Parsec.
11:57:41 <gelisam> Prefix operators? I've heard of the PostfixOperators language extension, but I'm not aware of anything for prefix operators.
11:57:53 <breadmonster> The way I've learned to use it, I feed a string in and get it to match against patterns in that string.
11:58:01 <breadmonster> Or like some bunch of text.
11:58:26 <caconym> safinaskar: in general, unary operators in haskell seem to be a tricky business
11:58:43 <breadmonster> What if I have an arbitrary list of tokens?
11:58:46 <caconym> safinaskar: including prefix operators i think
11:58:46 <breadmonster> That I want to parse?
11:58:54 <breadmonster> because I'm tokenizing and parsing separately.
11:59:03 <caconym> safinaskar: googling 'prefix operator haskell' or 'unary operator haskell' may help you find a solution
11:59:13 <caconym> safinaskar: solutions seem to generally involve adding parentheses
11:59:21 <mauke> wtf
11:59:40 <mauke> caconym: did you miss the "parsec" bit?
12:00:05 <mauke> breadmonster: that should still work
12:00:14 <safinaskar> mauke: http://paste.debian.net/163852/
12:00:14 <mauke> it's just that the default "tokens" are Chars
12:00:22 <breadmonster> mauke: Yeah, I'm sure it will because whoever designed Parsec was a genius.
12:00:31 <safinaskar> mauke: (meanwhile i will try to reduce the code even more)
12:00:35 <breadmonster> But I'm going to need to write my own token analysis back end ueah?
12:00:41 <gelisam> mauke: I did!
12:00:46 <breadmonster> I don't know what that type class or interface or whatever is.
12:01:00 <safinaskar> mauke: this code parses "~(~a)", but not "~~a" nor "~ ~a" (but i want to parse this exprs!)
12:01:30 <caconym> mauke: i guess i did, apologies
12:02:09 <mauke> ok, I don't know how buildExpressionParser works
12:02:24 <safinaskar> gelisam: (my question is not about haskell language itself, but about implementing my own language in haskell using parsec)
12:02:40 <breadmonster> mauke: Is there a particular type class I need to instantiate by hand to get it to parse my token stream?
12:02:55 <breadmonster> Or something along those lines?
12:03:28 <mauke> breadmonster: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html#t:Stream
12:03:40 <mauke> looks like there's already an instance for lists
12:03:54 <breadmonster> Right now, I'm parsing Python, and I have some token information in the lexer, like the types of numeric literals and strings.
12:03:54 <mauke> so it should Just Work for [SomeToken]
12:04:39 <jxv> Where does cabal's extra-libraries get its path from?
12:05:09 <breadmonster> Oh cool.
12:05:27 <breadmonster> Though now that I have a look at it, it's going to involve delving into Parsec's internals a fair bit.
12:06:08 <safinaskar> i am trying to parse my language with prefix operator "~" using parsec. my code here: http://paste.debian.net/163852/ . but the code parses "~(~a)" and doesn't parse "~~a" nor "~ ~a". what to do?
12:08:31 <safinaskar> i found some solutions here: http://stackoverflow.com/questions/10475337/parsec-expr-repeated-prefix-postfix-operator-not-supported :)
12:16:36 <t4nk174> Hey guys, quick Q
12:16:46 <t4nk174> I am trying to use the Graphics.GD module
12:16:51 <t4nk174> https://hackage.haskell.org/package/gd-3000.4.0/docs/Graphics-GD.html#4
12:17:10 <t4nk174> But its not found in my libraries, so I am trying to set up a cabal sandbox wit hit
12:17:41 <t4nk174> can I get some help with the setup
12:24:21 * hackagebot rest-example 0.2.0.1 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.2.0.1 (ErikHesselink)
12:26:07 <ndklfg> Hi, I have a function 'foo :: [String] -> IO [String]' that uses wreq to query an http API many times, once of each string in the list, to print the list of results I have to wait for the entire operation to complete.. is there away to leverage lazyness to print each element of the result as it become available?
12:27:40 <lyxia> ndklfg: I think you need to break thi
12:27:42 <lyxia> s function
12:27:54 <lyxia> and weave printing and querying actions
12:28:06 <ndklfg> Is there a way without doing that?
12:29:41 <ndklfg> For example what if I have an infinite list as a parameter and I have 'take 100 $ foo inifiniteList' somewhere?
12:33:14 <merijn> ndklfg: You probably want the async library
12:33:41 <ndklfg> merijn: I got it working by using unsafeInterleaveIO :D
12:33:58 <ndklfg> i wrapped the actual wreq get call with unsafeInterleaveIO and it works :D
12:34:46 <ndklfg> man lazyness is pretty awesome
12:34:57 <ndklfg> its like magic
12:34:59 <merijn> this has nothing todo with laziness
12:35:16 <merijn> And unsafeInterleaveIO, as the name implies is unsafe unless you know what you're doing (and even then...)
12:35:28 <ndklfg> 'unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded.'
12:36:42 <ndklfg> merijn: i think regular IO actions will by default be done non-lazily unless something like this function is used
12:38:19 <merijn> Yes, which means you've lost the ability to ensure things like handling like IO exceptions/errors properly
12:39:22 * hackagebot matrix 0.3.4.3 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.4.3 (DanielDiaz)
12:49:23 * hackagebot pcg-random 0.1.2.0 - Haskell bindings to the PCG random number generator.  http://hackage.haskell.org/package/pcg-random-0.1.2.0 (cchalmers)
12:51:06 <L8D> oh gahd I'm building haskell-src-exts
12:51:16 <L8D> my laptop is melting
12:55:45 <t4nk174> Hey guys, I'm trying to install this hackage https://hackage.haskell.org/package/friday-devil
12:56:02 <t4nk174> so I put the dependency in my cabal file
12:56:04 <t4nk174> when i run cabal install
12:56:05 <t4nk174> it gives me
12:56:16 <t4nk174> Missing C library: IL
12:56:22 <t4nk174> you guys know what that is
12:56:35 <mniip> intermediate language?
12:56:39 <ProofTechnique> You need to install the library through your package manager. It had a C dependency
12:56:59 <ProofTechnique> http://sourceforge.net/projects/openil/
12:56:59 <t4nk174> I have a windows machine
12:57:04 <ReinH> From the package description, "The library uses FFI calls to the DevIL image library". So presumable something to do with that
12:57:13 <ReinH> *presumably
12:58:13 <t4nk174> ah okay i see .dll's
12:58:19 <t4nk174> I just put them somehwere and point to it?
12:58:28 <t4nk174> or should I put in my system folder
13:01:39 <athan> Is there a `applyWhen :: (a -> Bool) -> (a -> a) -> [a] -> [a]` function anywhere?
13:01:58 <athan> Ideally, it would only apply f as soon as p returns True, then quit - it assumes unique contents
13:02:13 <athan> or lazilly goes through the list, if you want to add more jargon :\
13:05:44 <t4nk174> Hey guys, I am trying to install this hackage: https://hackage.haskell.org/package/friday-devil
13:05:45 <t4nk174> it says
13:05:54 <t4nk174> * Missing C library: IL
13:05:57 <t4nk174> on cabal
13:06:07 <t4nk174> and I am downloaded this 
13:06:08 <t4nk174> http://sourceforge.net/projects/openil/?source=typ_redirect
13:06:16 <t4nk174> which includes some dlls
13:06:21 <t4nk174> but I am not able to resolve the issue still
13:07:06 <capisce> t4nk174: instead of downloading you probably want to install it using your package manager
13:07:16 <t4nk174> I have a windows machine
13:07:43 <capisce> then no idea :/
13:07:51 <t4nk174> would mac work?
13:08:11 <capisce> on mac I'd use brew
13:08:17 <ReinH> The dll needs to be in your system path, so moving it to C:\Windows\System32 may work
13:09:03 <pharaun> anyone know if the c2hs/hsc2hs can handle C structs with *function* pointers? i have a C struct here with something like 50 function pointers
13:09:23 <pharaun> wondering if i can extract those out or if i would be better off writing a wrapper c that does func-call to the struct?
13:16:15 <osa1> "despite its simplicity the language is complete and universal" <- what does "complete" mean in this sentence?
13:18:38 <osa1> t4nk174: alternatively, try --extra-lib-dirs
13:18:58 <t4nk174> so make a folder and stick them in tehre
13:19:01 <osa1> t4nk174: cabal install --extra-lib-dirs=<path to DevIL DLLs>
13:19:12 <t4nk174> i will try
13:19:25 * hackagebot vivid 0.1.0.2 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.1.0.2 (TomMurphy)
13:19:27 * hackagebot include-file 0.1.0.2 - Inclusion of files in executables at compile-time.  http://hackage.haskell.org/package/include-file-0.1.0.2 (DanielDiaz)
13:19:53 <sritchie> does anyone know how to do the opposite of haskell-mode-jump-to-def in haskell-mode in emacs?
13:19:58 <sritchie> I‚Äôve got it bound to M-.
13:20:07 <sritchie> I‚Äôm just not sure how to jump back up to where I started
13:23:35 <t4nk174> I run this
13:23:36 <t4nk174> cabal install --extra-lib-dirs=./DLLs
13:23:38 <t4nk174> but it says
13:23:47 <t4nk174> the folder is not found
13:23:50 <t4nk174> do I have to give the full path?
13:25:12 <t4nk174> still no good =[
13:25:18 <osa1> what is it saying?
13:26:37 <osa1> you may need header files as well, in that case also add --extra-include-dirs=<path to DevIL header files>
13:27:01 <t4nk174> which are the header files?
13:27:06 <osa1> .h files
13:27:20 <osa1> what is the error message you're getting?
13:27:21 <t4nk174> ah I only get the dlls from the donwload page
13:27:35 <osa1> OK, what's the error message?
13:27:43 <t4nk174> http://lpaste.net/129839
13:28:43 <osa1> hm, try wrapping path with double quotes and remove escaping before spaces
13:28:48 <osa1> I'm not sure how windows path resolving works
13:28:59 <t4nk174> ok ill try
13:29:02 <osa1> last time I used Windows was several years ago I think
13:29:16 <osa1> t4nk174: cabal install --extra-lib-dirs="T:\Dropbox\FLORIDA POLY\Digital Image Processing\HW_3\Dlls"
13:30:12 <t4nk174> nope no good
13:30:15 <t4nk174> is there a image library
13:30:17 <osa1> same error?
13:30:17 <t4nk174> that doesn't need all this
13:30:19 <t4nk174> yeah
13:30:34 <t4nk174> I just need an image hackage
13:30:35 <osa1> t4nk174: if you look at the error
13:30:39 <osa1> it's printing an invalid path
13:30:55 <osa1> t4nk174: there's a problem with escaping
13:30:57 <osa1> figure it out
13:31:09 <t4nk174> I did the double quotes and it got rid of the error
13:31:21 <osa1> what? you just said it didn't work
13:31:38 <t4nk174> it got rid of that error
13:31:54 <osa1> OK, what is it saying now?
13:32:08 <t4nk174> In my log file it just goes back to where it started
13:32:25 <osa1> t4nk174: is there an error or not? what's console output saying?
13:32:48 <t4nk174> http://lpaste.net/129840
13:33:55 <osa1> t4nk174: please include the command you're running in the paste. make sure DLLs are really in that folder and you have correct versions.
13:35:13 <t4nk174> http://lpaste.net/129841
13:35:20 <divVerent> why does "let" appear to change the type of an expression? http://paste.debian.net/163861/
13:35:25 <t4nk174> I can try doing both the includes statemtns
13:35:35 <divVerent> similar in code itself
13:35:43 <osa1> t4nk174: what's output of `ls "T:\Dropbox\FLORIDA POLY\Digital Image Processing\HW_3\Dlls"` ?
13:35:48 <divVerent> x = 42 declares as integer when auto deducting types, while :t 42 returns Num a => a
13:36:13 <osa1> divVerent: it should be monomorphism restriction, try -XNoMonomorphismRestriction and see if it has general type now
13:36:48 <osa1> divVerent: ghci -XNoMonomorphismRestriction
13:36:54 <kmerz> Hey, how do I hide '!' in a import, like in import Data.Map hiding (!) as M
13:37:01 <osa1> kmerz: hiding ((!))
13:37:10 <kmerz> thx a lot
13:37:12 <kmerz> :D
13:37:22 <t4nk174> http://lpaste.net/129842
13:38:06 <divVerent> osa1: ah, thanks, that "solves" it
13:38:16 <divVerent> of course, there's a point in ghc doing what it does, despite it being weird
13:38:25 <divVerent> I was actually trying to do this WTF:
13:38:33 <osa1> t4nk174: this should be related with Windows DLL name resolving, I think it may be looking for IL.dll or LibIL.dll or something like that
13:39:08 <t4nk174> probably, I am going to try using the this package: http://hackage.haskell.org/package/unm-hip
13:39:23 <osa1> t4nk174: for example if on Linux if you try to link with dynamic "blah" library, you run linker with -lblah and it looks for libblah.so file
13:39:32 <divVerent> osa1: http://paste.debian.net/163863/
13:39:57 <divVerent> so I agree that this isn't what people would expect integer "constants" to do :)
13:40:03 <t4nk174> should I rename some of those files then
13:40:36 <osa1> divVerent: that's an interesting piece of code, and yeah it may be confusing for most people :)
13:40:58 <osa1> t4nk174: DevIL.dll may be the right file
13:41:21 <kaiyin> could anyone have a look at this? http://stackoverflow.com/questions/29334571/foldmap-taking-the-wrong-type-of-parameter
13:44:32 <hsk3> main = do
13:44:33 <hsk3>     if Nothing == Nothing
13:44:34 <hsk3>         then putStrLn "hey"
13:44:35 <hsk3>         else putStrLn "ho"
13:44:37 <hsk3> Why doesn't this compile?!
13:44:45 <hsk3> No instance for (Eq a0) arising from a use of ‚Äò==‚Äô
13:45:02 <barrucadu> Because the type of the Nothings is ambiguous
13:45:25 <ReinH> :t foldMap
13:45:26 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:45:27 <barrucadu> 'Maybe a' values can only be compared with (==) when 'a' has an Eq instance
13:45:37 <ReinH> :t foldMap (+)
13:45:38 <lambdabot> (Num a, Foldable t, Monoid a) => t a -> a -> a
13:45:38 <osa1> kaiyin: http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Monoid.html#t:Sum this may be related
13:45:44 <barrucadu> But the compiler doesn't know which type to pick
13:45:46 <ReinH> :t (+)
13:45:47 <lambdabot> Num a => a -> a -> a
13:45:56 <barrucadu> It's irrelevant in this case, but that's the problem
13:46:00 <ReinH> kaiyin: foldMap takes a function a -> m for some Monoid m
13:46:05 <ReinH> you gave it a function a -> a -> a
13:46:18 <ReinH> for some Num a
13:46:21 <kaiyin> ReinH: so (a -> a) is a Monoid?
13:46:34 <ReinH> That is what you are claiming
13:46:54 <kaiyin> Yeah, that's what's required by F.foldMap.
13:47:03 <ReinH> or rather, that a is a Monoid
13:47:12 <ReinH> since there is an Monoid b => Monoid (a -> b)
13:47:37 <ReinH> so a -> m unifies with a -> (a -> a) by m ~ a -> a
13:48:07 <ReinH> and the claim is that m is a Monoid, which means a -> a must be a Monoid, so the instance for functions is used
13:48:20 <ReinH> note that this arises because you are trying to do the wrong thing with foldMap
13:48:35 <ReinH> and type inference is attempting to make sense of it
13:49:00 <ReinH> so it comes up with a sensible but useless type for z
13:49:19 <ReinH> since there are no instances that satisfy (Monoid a, Num a) => a -> a
13:49:35 <hsk3> barrucadu: THANKS.
13:50:03 <kaiyin> ReinH: what is that useless type?
13:50:24 <ReinH> the one that is inferred based on your use of foldMap
13:50:36 <mniip> > f <**> x
13:50:36 <ReinH> foldMap takes a function that returns a Monoid instance
13:50:37 <lambdabot>      Couldn't match expected type ‚Äòf (a0 ‚Üí b)‚Äô with actual type ‚ÄòExpr‚Äô
13:50:37 <lambdabot>      In the second argument of ‚Äò(<**>)‚Äô, namely ‚Äòx‚Äô
13:50:37 <lambdabot>      In the expression: f <**> x
13:50:39 <ReinH> but you provided (+)
13:50:42 <mniip> sigh
13:50:44 <ReinH> which returns an (a -> a)
13:50:56 <kaiyin> yeah
13:51:11 <ReinH> so you are making a claim that (a -> a) could be an instance of Monoid
13:51:39 <kaiyin> yeah, and what does ghc do then?
13:52:12 <ReinH> (a -> a) is a Monoid if a is a Monoid because of instance Monoid b => Monoid (a -> b)
13:52:30 <kaiyin> ok
13:52:42 <kaiyin> but a is not a Monoid.
13:52:47 <ReinH> You are claiming that it is
13:53:10 <kaiyin> so there is no way that ghc can verify this?
13:53:34 <ReinH> an instance *could* exist
13:54:02 <kaiyin> ok, so ghc assumes it exists, then what does it do?
13:54:15 <ReinH> F.foldMap (+) testTree is a proof that the type (Monoid a, Num a) => a -> a is inhabited
13:54:54 <ReinH> If you want to *apply* this function, you as the caller have to supply an a that is an instance of both Monoid and Num
13:55:30 <kaiyin> ok
13:56:00 <kaiyin> so z is of the type (Num a, Monoid a) => a -> a ? 
13:56:23 <ReinH> Yes.
13:56:33 <kaiyin> cool. it makes sense now.
13:56:52 <ReinH> And actually, there are types that would work here
13:56:56 <ReinH> but this function won't do what you want
13:56:58 <ReinH> > foldMap (+) [] (Sum 1)
13:57:00 <lambdabot>  Sum {getSum = 0}
13:57:56 <ReinH> because, again, you are using foldMap to do something that is useless but perfectly sensical from GHC's "does this typecheck?" perspective
13:58:27 <ReinH> The way you generally use foldMap is like
13:58:32 <ReinH> > foldMap Sum [1,2,3]
13:58:34 <lambdabot>  Sum {getSum = 6}
13:58:45 <benzrf> > ala Sum foldMap [1, 2, 3
13:58:47 <lambdabot>  <hint>:1:25:
13:58:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:58:47 <benzrf> > ala Sum foldMap [1, 2, 3]
13:58:49 <lambdabot>  6
13:59:06 <ReinH> benzrf: not helpful
13:59:37 <kaiyin> :t Sum
13:59:38 <lambdabot> a -> Sum a
14:00:02 <kaiyin> so foldMap usually takes a value constructor.
14:00:06 <ReinH> No
14:00:14 <ReinH> foldMap takes a function that returns a monoid
14:00:41 <kaiyin> ok
14:00:46 <ReinH> Some useful monoids are encoded as newtypes, so their type constructors are that function
14:00:50 <ReinH> er, data constructors
14:01:05 <kaiyin> :t ala
14:01:07 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
14:01:15 <ReinH> This is why I said ala isn't helpful :)
14:01:29 <benzrf> rip
14:01:42 <ReinH> ala is, in this case, being used to do:
14:01:51 <ReinH> > getSum (foldMap Suim [1,2,3])
14:01:53 <lambdabot>      Not in scope: data constructor ‚ÄòSuim‚Äô
14:01:53 <lambdabot>      Perhaps you meant ‚ÄòSum‚Äô (imported from Data.Monoid)
14:01:54 <ReinH> > getSum (foldMap Sum [1,2,3])
14:01:56 <lambdabot>  6
14:02:08 <ReinH> but understanding ala requires a lengthy and unhelpful digression into lens
14:02:30 <kaiyin> ok, got it, I'll save that for later.
14:02:34 <ReinH> kaiyin: the important thing here is that foldMap (+) is a claim that (+) returns a monoid
14:02:42 <ReinH> but (+) returns a (a -> a) for some Num instance
14:02:47 <kaiyin> yes
14:03:03 <ReinH> So this is true, but not particularly useful
14:03:13 <ReinH> you might want to use the definition of foldMap to understand this behavior though
14:03:18 <ReinH> > foldMap (+) [] (Sum 1)
14:03:20 <lambdabot>  Sum {getSum = 0}
14:03:41 <ReinH> You will also need the definition of the instance Num b => Num (a -> b)
14:04:25 <kaiyin> you mean Num b => (a -> b)?
14:04:53 <ReinH> kaiyin: no
14:05:00 <ReinH> Num b => Num (a -> b)
14:05:10 <kaiyin> what does that mean?
14:05:12 <ReinH> means "if b is a Num then so is (a -> b)"
14:05:18 <ReinH> for all a
14:05:56 <kaiyin> but a -> b is the type of some function.
14:06:03 <kaiyin> how can it be a Num?
14:07:58 <kaiyin> :t (5+) `mappend` (3+)
14:07:59 <lambdabot> (Num a, Monoid a) => a -> a
14:08:18 <kaiyin> :t (5+) `mappend` (3+) $ Sum 1
14:08:19 <lambdabot> Num a => Sum a
14:08:23 <cwr> Building gtk2hssetup with a global package I get the error Gtk2HsSetup.hs:167:16: Not in scope: `LBI.getComponentLocalBuildInfo' although it builds fine as a user package.  Anyone any idea of a fix?
14:08:44 <ReinH> kaiyin: Think about it this way.
14:09:11 <ReinH> kaiyin: Are you familiar with the fmap instance for functions?
14:09:40 <kaiyin> yes, sort of. fmap = (.) in that case, right?
14:10:09 <ReinH> Right, the fmap instance for functions goes: instance Functor ((->) a)
14:10:27 <kaiyin> yeah
14:11:03 <ReinH> which means: given I can produce a b and I have a function b -> c, I can apply that function after I produce a b
14:11:23 <ReinH> Num b => Num (a -> b) says: given that I can produce a b which is a Num instance, I can do Num stuff to that value once I produce it
14:12:27 <ReinH> :t liftA2 (+)
14:12:28 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
14:12:41 <kaiyin> yeah, makes sense. but is that valid haskell code?
14:12:50 <kaiyin> this: Num b => Num (a -> b)
14:12:55 <ReinH> It's a valid type
14:13:41 <ReinH> the instance has, e.g., (+) = liftA2 (+)
14:14:13 <kaiyin> but since Num (a -> b) is guaranteed when Num b, why should we go to the trouble of writing it down?
14:14:40 <ReinH> So that it exists?
14:15:03 <ReinH> It isn't "guaranteed". It's provable, and writing the instance is the proof.
14:16:20 <kaiyin> wouldn't Num b => a -> b be equivalent? What actual difference does that extra Num make?
14:16:21 <ReinH> so because the Applicative instance here is ((->) a), that definition is equivalent to f + g = \x -> f x + g x
14:16:51 <ReinH> Num b => a -> b is a theorem that functions of type a -> b exist when b is a Num
14:17:07 <ReinH> instance Num b => Num (a -> b) is a theorem that if b is a Num then so is (a -> b)
14:17:23 <ReinH> The former says nothing about whether (a -> b) is itself an instance of Num
14:18:20 <ReinH> Hmm. I've been doing a lot of talking. Happy to move to #haskell-overflow if folks would like.
14:18:40 <kaiyin> :)
14:20:19 <kaiyin> > getSum ((5+) `mappend` (3+) $ Sum 1)
14:20:20 <lambdabot>  10
14:20:32 <kaiyin> why should this thing end up being 10?
14:20:45 <ReinH> f + g = \x -> f x + g x
14:20:52 <ReinH> so what is happening?
14:21:13 <ReinH> There's an implicit thing happening here btw
14:21:18 <ReinH> > 5 :: Sum Int
14:21:19 <lambdabot>  Sum {getSum = 5}
14:21:42 <ReinH> > getSum ((Sum 5 +) `mappend` (Sum 3 +) $ Sum 1) -- is what you're really saying
14:21:44 <lambdabot>  10
14:22:09 <ReinH> So.
14:22:10 <ReinH> > (Sum 5 +) `mappend` (Sum 3 +) $ Sum 1
14:22:12 <lambdabot>  Sum {getSum = 10}
14:22:17 <kaiyin> oh, that's why.
14:22:37 <ReinH> Oh wait
14:22:40 <ReinH> I've been wrong this whole time.
14:22:45 * ReinH facepalms
14:22:52 <kaiyin> :D
14:23:00 <ReinH> kaiyin: it isn't Num b => Num (a -> b)
14:23:06 <ReinH> it's Monoid b => Monoid (a -> b)
14:23:12 <ndklfg> How do I handle indentation-based expressions with parsec?
14:23:14 <ReinH> the Num instance doesn't exist in base
14:23:28 <ReinH> kaiyin: But my argument is basically correct, just substitute mappend for (+)
14:23:36 <ReinH> kaiyin: so f <> g = \x -> f x <> g x
14:23:51 <ReinH> > (Sum 5 +) <> (Sum 3 +) $ Sum 1
14:23:52 <lambdabot>  Sum {getSum = 10}
14:23:59 <ReinH> kaiyin: What is f, what is g, what is x?
14:24:27 <ProofTechnique> ndklfg: The space and tab combinators could probably help
14:24:44 <ReinH> kaiyin: Honestly I have no idea why I was talking about Num, sorry. It's instance Monoid b => Monoid (a -> b)
14:24:45 <ndklfg> ProofTechnique: i mean how do i keep track of indentation level and relative indentation
14:25:07 <ReinH> So just replace all occurrences of Num with Monoid in the above and re-evaluate
14:25:09 <kaiyin> ReinH: that's ok, confusion builds the brain. :)
14:25:43 <kaiyin> let me think about it for a moment. 
14:25:50 <ReinH> :t foldMap (+)
14:25:51 <lambdabot> (Num a, Foldable t, Monoid a) => t a -> a -> a
14:26:11 <ReinH> what we need is not an instance Num a => Num (a -> a), it's an instance Monoid a => Monoid (a -> a)
14:26:12 <ndklfg> > (3 +) >>= (5 +) $ 1
14:26:13 <lambdabot>      Occurs check: cannot construct the infinite type: r0 ~ r0 ‚Üí b
14:26:13 <lambdabot>      Expected type: r0 ‚Üí r0 ‚Üí b
14:26:13 <lambdabot>        Actual type: r0 ‚Üí r0
14:26:25 <ReinH> and we have instance Monoid b => Monoid (a -> b), so just set a = b
14:26:48 <ProofTechnique> ndklfg: Maybe add an IndentLevel to one of your types? Then decide on some regular indentation scheme and work from there?
14:27:07 <ProofTechnique> Probably something clever to be done with a Writer-like, too
14:27:28 <ReinH> ndklfg: I believe Stephen Diehl's language implementation thing includes an indentation-sensitive parser
14:28:02 <ReinH> ndklfg: The specific chapter is http://dev.stephendiehl.com/fun/008_extended_parser.html but the whole thing would be worth reading
14:28:25 <ReinH> kaiyin: sorry about that. If you reparse correcting for Num to Monoid does it make sense?
14:28:51 <ProofTechnique> Somehow I have not seen that Stephen Diehl thing before. Great link, ReinH 
14:28:59 <ReinH> ProofTechnique: it's awesome!
14:29:28 * hackagebot mwc-random 0.13.3.2 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.3.2 (AlexeyKhudyakov)
14:29:33 <kaiyin> ReinH: this boils down to assuming that (+) is of the type (Monoid a, Monoid a -> a) =>  a -> a -> a
14:29:36 <ReinH> He's a bit behind. I hope he finds time and interest to finish it.
14:29:56 <ReinH> kaiyin: Hmm. It isn't of that type, but it can unify with that type
14:30:22 <ReinH> kaiyin: so you probably have the right idea
14:31:07 <ndklfg> ReinH: just glancing at the article is parsec being used or alex and happy?
14:31:17 <ReinH> ndklfg: yes. Both at different times :)
14:31:35 <ReinH> ndklfg: Hmm, although the indentation stuff might be using happy now that I think about it. Sorry.
14:32:00 <ReinH> ndklfg: I haven't seen a good writeup on it otherwise, although the parsers library has some nice combinators for it. Just no examples.
14:32:25 <ndklfg> okay this article is very helpful either way thanks ReinH 
14:32:51 <ProofTechnique> @hackage indents
14:32:52 <lambdabot> http://hackage.haskell.org/package/indents
14:32:54 <ProofTechnique> ndklfg: ^
14:32:56 <ProofTechnique> That, also
14:33:15 <ProofTechnique> Not updated recently, but it might be something to look at
14:33:25 <ndklfg> ah ok
14:33:29 <ReinH> ndklfg: cool, good luck :)
14:33:38 <ndklfg> thanks :)
14:33:45 <ReinH> ndklfg: what are you parsing?
14:34:13 <ndklfg> Some BASIC-like DSL
14:34:26 <ndklfg> from an old app
14:34:41 <ProofTechnique> ndklfg: And also a potentially instructive SO question: http://stackoverflow.com/questions/24983203/
14:35:11 <ProofTechnique> Oh!
14:35:16 <ProofTechnique> And this: http://michaeldadams.org/papers/layout_parsing_2/LayoutParsing2-2014-haskell-authors-copy.pdf
14:36:10 <ReinH> oh nice
14:36:23 <kaiyin> so (Sum 5 +) is a Monoid?
14:36:33 <kaiyin> how is mappend defined for it?
14:36:56 <ndklfg> ah cool :)
14:37:36 <ProofTechnique> kaiyin: mappend = coerce ((+) :: a -> a -> a)
14:39:02 <kaiyin> ProofTechnique: how would you define it in a more explicitly way? 
14:39:29 * hackagebot pipes-cliff 0.10.0.0 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.10.0.0 (OmariNorman)
14:39:46 <ProofTechnique> kaiyin: Sum x `mappend` Sum y = Sum (x + y)
14:40:24 <ProofTechnique> > Sum 5 <> Sum 6
14:40:25 <lambdabot>  Sum {getSum = 11}
14:40:37 <ProofTechnique> > getSum $ Sum 5 <> Sum 6
14:40:38 <lambdabot>  11
14:41:00 <ReinH> instance Monoid b => Monoid (a -> b) where f <> g = \x -> f x <> g x
14:41:21 <ReinH> mempty = const mempty
14:41:46 <ReinH> that's the instance we were talking about before
14:41:54 <kaiyin> ah, this is what i was searching for. 
14:42:00 <kaiyin> yeah.
14:42:11 <kaiyin> :t const
14:42:12 <lambdabot> a -> b -> a
14:42:57 <kaiyin> i don't quite understand the mempty part here.
14:44:18 <ProofTechnique> :t const mempty
14:44:19 <lambdabot> Monoid a => b -> a
14:44:57 <ReinH> Monoid b => Monoid (a -> b)
14:45:09 <ProofTechnique> In the instance ReinH gave, you're just throwing away the a
14:45:10 <ReinH> const mempty says ignore the argument (of type a) and use mempty (of type b, which is a Monid)
14:45:45 <ReinH> @src const
14:45:45 <lambdabot> const x _ = x
14:46:51 <kaiyin> wouldn't that lead to const const const ... mempty?
14:47:06 <ReinH> why?
14:47:14 <ProofTechnique> kaiyin: It's the mempty from the Monoid b.
14:47:15 <kaiyin> well, circular definition
14:47:28 <ReinH> Ah.
14:47:41 <ReinH> mempty is overloaded
14:47:53 <ReinH> so these are two different functions with the same name
14:48:15 <ReinH> on the left hand side, we are defining mempty for Monoid b => Monoid (a -> b). On the right hand side we are using the definition for b
14:49:15 <kaiyin> how would you the right hand side is using the definition for b?
14:49:46 <ReinH> GHC looks it up for whatever type b the caller provides
14:49:48 <pantsman-> kaiyin, this is type class polymorphism. The implementation of mempty depends on its type.
14:50:11 <ReinH> kaiyin: So b might itself be of the form Monoid b => Monoid (a -> b)
14:50:14 <ReinH> :t mempty :: (Monoid b, Monoid c) => a -> b -> c
14:50:15 <lambdabot> (Monoid b, Monoid c) => a -> b -> c
14:50:39 <ReinH> But you can't construct an infinite type such that it becomes circular
14:51:10 <ProofTechnique> As long as you have that Monoid constraint, anyway
14:51:16 <jle`> const mempty :: a -> [Bool], for example, then mempty would be []
14:51:28 <jle`> const mempty :: a -> String, then mempty there would be ""
14:51:52 <jle`> (mempty :: a -> String) == const (mempty :: String)
14:52:27 <ReinH> That does mean that you can do rather odd but probably useless things like
14:52:29 <ReinH> > mempty 1 "foo" () (+) :: String
14:52:31 <lambdabot>  ""
14:53:34 <ReinH> which throws away all arguments and gives mempty :: String
14:53:42 <ReinH> for as many arguments as you care to provide
14:54:46 <kaiyin> > mempty :: (Monoid b, Monoid c) => a -> b -> c
14:54:47 <lambdabot>      No instance for (Typeable a0)
14:54:48 <lambdabot>        arising from a use of ‚Äòshow_M486245368414519756718581‚Äô
14:54:48 <lambdabot>      In the expression:
14:56:13 <ReinH> That rather unhelpful error is telling you that GHC can't provide a mempty definition for an arbitrary type
14:56:55 <kaiyin> ok
14:57:04 <ReinH> Well, I suppose it would provide undefined if it weren't for the Typeable stuff
14:57:21 <ReinH> Maybe.
14:57:25 <ReinH> I'm not sure actually.
14:58:11 <Deneys> Should I migrate all my android eclipse project to "Android studio" or should I wait a year to see what happens
14:58:36 <Deneys> Mmmm not to sure what to do
14:59:16 <Deneys> I still think A.S is a bit buggy
14:59:39 <Deneys> What do u guyZ think
14:59:56 <jmcarthur> Deneys: is this a haskell question?
15:00:19 <Deneys> Yip
15:00:23 <jmcarthur> how so?
15:01:05 <Deneys> Because it's tech related
15:01:16 <jmcarthur> haskell is a specific programming language, not all tech
15:01:36 <Deneys> O my bad forgive me
15:01:54 <jmcarthur> it's all good. it happens a surprising number of times. :)
15:05:07 <igniting> Deneys: try #android or #android-dev
15:13:13 <CapitalSigma> hey all
15:13:50 <CapitalSigma> i'm a little confused by the docs i'm reading -- i'm a standard ML programmer; is it possible for me to put type constraints on values like it is in SML?
15:13:53 <CapitalSigma> e.g. 
15:14:25 <CapitalSigma> "let val foo : int = 5 in foo + foo end"
15:14:30 * hackagebot stm-chans 3.0.0.3 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-3.0.0.3 (WrenThornton)
15:14:36 <bob_twinkles> :t (undefined :: Int)
15:14:37 <lambdabot> Int
15:14:43 <ReinH> > let foo :: Int; foo = 5 in foo
15:14:45 <lambdabot>  <no location info>: can't find file: L.hs
15:14:56 <Axman6> > let foo = 1 :: Int in foo + foo
15:14:57 <lambdabot>  2
15:15:00 <ReinH> or that
15:15:07 <ReinH> (mine works on multiple lines)
15:15:10 <Axman6> but I prefer your version ReinH 
15:15:29 <CapitalSigma> okay. and will it work inside a pattern match?
15:16:21 <CapitalSigma> what i'm actually trying to do is something like "let [_, foo::[Int]]:(bar::[[Int]]) = someExpression"
15:16:35 <Axman6> I don't think so, but I think there is an extension which allows that. if you write case 1 of (x :: Int) -> undefined then ghc should tell you what you need
15:17:03 <Axman6> May I was why you want to do that? it looks really messy
15:17:20 <Axman6> may I ask*
15:18:53 <CapitalSigma> Axman6: debugging a type issue that i don't understand (i'm new to haskell)
15:19:11 <bob_twinkles> lpaste the error?
15:19:14 <CapitalSigma> i'd delete it once i got the problem fixed, i'd just like to figure out what type haskell things this expression has
15:19:45 <CapitalSigma> bob_twinkles: hang n
15:20:05 <bob_twinkles> (and the code that causes it would be nice too, I guess)
15:21:18 <hexagoxel> > let f [x :: Int] = x+3 in f [4]
15:21:19 <lambdabot>  7
15:21:36 <lpaste> CapitalSigma pasted ‚ÄúNewbie Type Errors‚Äù at http://lpaste.net/129845
15:21:56 <CapitalSigma> bob_twinkles: see the link from lpaste 
15:26:26 <bob_twinkles> CapitalSigma: check out the type of (:)
15:26:29 <bob_twinkles> :t (:)
15:26:30 <lambdabot> a -> [a] -> [a]
15:27:23 <bob_twinkles> I think line 18 isn't doing what you expect it too
15:27:52 <CapitalSigma> bob_twinkles: ah
15:29:16 <CapitalSigma> bob_twinkles: that was it, thank you!
15:29:30 <bob_twinkles> glad to help
15:31:57 <osa1> can anyone help me understanding this Core output: http://lpaste.net/129846 where's my definition of `test` here?
15:33:05 <osa1> is it eta_s3J2 ?
15:34:04 <osa1> how do I see what's eta_s3J2?
15:34:31 * hackagebot unification-fd 0.10.0 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.10.0 (WrenThornton)
15:36:56 <xplat> is there a webdav server written in haskell?
15:42:19 <sritchie> hey all - I‚Äôm trying to define an applicative instance for monad
15:42:22 <sritchie> I‚Äôve got class Functor f => Apply f where (<*>) :: f (a -> b) -> f a -> f b
15:42:46 <sritchie> and I can write instances like instance Apply P.Maybe where f <*> a = f P.>>= \f' -> P.fmap f' a
15:43:20 <sritchie> but this isn‚Äôt working ‚Äî  ‚Äúinstance Apply P.Monad where f <*> a = f P.>>= \f' -> P.fmap f' a‚Äù
15:43:42 <xplat> you can't define instances of a class for another class, only for types
15:44:03 <enthropy> instance P.Monad m => Apply m where ...
15:44:24 <xplat> (well, barring odd uses of ConstraintKinds, but you still can't define instances of *that* class for another class)
15:44:29 <sritchie> ah, okay
15:44:29 <shachaf> If you define that, though, it'll overlap with every other instance of Apply.
15:44:50 <kaidelong> however you will run into trouble here
15:44:54 <kaidelong> m and f are the same type
15:44:57 <kaidelong> with different constraints
15:45:04 <kaidelong> Haskell's class system does not handle this well
15:45:13 <shachaf> Every class is an instance of Typeable.
15:45:17 <sritchie> shachaf: the goal was to define a general instance of apply for every type with a monad
15:45:20 <mniip> can I somehow tell the typechecker that a multiparamtypeclass is a bijection
15:45:30 <kaidelong> mniip: FunctionalDepencies
15:45:31 <xplat> 'instance P.Monad m => Apply m' doesn't create an instance of Apply for Monad -- it creates an instance of Apply for *every* type, which then needs a Monad instance to work
15:45:31 <mniip> functionaldependencies only lets me declare it a function
15:45:43 <shachaf> sritchie: Can't do it.
15:45:46 <sritchie> I‚Äôm working through the nicta course and wanted to kill this duplication: https://github.com/NICTA/course/blob/master/src/Course/Apply.hs#L244
15:45:58 <sritchie> shachaf: since those are all defined in terms of bind and fmap
15:46:06 <sritchie> and apply already has a Functor requirement
15:46:35 <shachaf> You can write (<*>) = ap instead.
15:46:42 <sritchie> xplat: ah, interesting
15:46:43 <mniip> kaidelong, I can't say 'a b -> b a' can I
15:46:56 <mniip> or something of that nature
15:47:13 <xplat> sritchie: basically, if you could do the thing you want to do nobody would have needed to go through the headache of the AMP ;)
15:47:14 <kaidelong> mniip: mmm, that looks like a kind error to me
15:47:30 <mniip> no I mean in the fundeps field
15:47:59 <kaidelong> you can say "a -> b, b -> a" 
15:48:01 <xplat> mniip: no, you need separate 'a -> b' and 'b -> a' fundeps
15:48:02 <kaidelong> is this not what you want?
15:48:06 <sritchie> xplat: I guess what I want requires a typeclass heirarchy
15:48:21 <kaidelong> it means that a and b both uniquely determine one another
15:48:21 <sritchie> xplat: more like what the Scala compiler has for its implicit searches
15:48:25 <xplat> mniip: if a relation is a function and so is its transpose, it is a bijection
15:48:25 <mniip> xplat, can I do that in one class?
15:48:29 <kaidelong> IE, knowing only one of them is good enough
15:48:40 <kaidelong> mniip: yes, I gave you the syntax too, just put in a comma
15:48:47 <mniip> ohh
15:48:53 <kaidelong> class Foo a b | a -> b, b -> a
15:48:55 <kaidelong> IIRC
15:49:39 <kaidelong> basically "if I know a, then I know b, and if I know b, then I know a"
15:50:24 <xplat> this is, interestingly, a thing you can do with MPTCs that you cannot do with TypeFamilies
15:50:52 <mniip> I'm working on some fancy stuff here
15:51:18 <kaidelong> xplat: in all cases I used FunctionalDependencies this was exactly how I used it, so I guess I can stop worrying I had to use TypeFamilies instead then
15:51:21 <xplat> TypeFamilies only lets you have this kind of dependency in the special case where you have a data family (that is, you always have to define one of the types inline in the instance)
15:51:32 <mniip> started out as a hypothetically useful thing, but the more pragmas I add, the more academic this becomes
15:52:33 <kaidelong> well given that you can always replace a specialized function with a more general one later you don't need to spend too much time generalizing
15:52:43 <kaidelong> unless you are writing a library and these fucntions are going to be exposed
15:53:09 <hexagoxel> osa1: optimized away in some magic way. try exporting `test`
15:53:34 <enthropy> https://ghc.haskell.org/trac/ghc/ticket/10009 is how to do a bijection with type families (which is broken in 7.10 but hopefully fixed later)
15:55:59 <mniip> hmm
15:56:21 <mniip> in a mptc, how would I declare a constraint where one of the arguments is basically any type
15:56:46 <mniip> if I make up a type variable ghc complains about it not being used in the instance head (I guess?)
15:57:01 <xplat> enthropy: heh, that's freaky
15:57:16 <enthropy> xplat: that it used to work, or that it broke?
15:57:28 <xplat> enthropy: both!
15:58:09 <xplat> i see why it works, but i can also see why it wouldn't exactly be supported behavior
15:58:15 <mniip> is there no better solution than
15:58:27 <mniip> (forall m0. H0 h1 m0) => H1 h1 m1
15:58:42 <enthropy> @hackage constraints
15:58:43 <lambdabot> http://hackage.haskell.org/package/constraints
15:59:15 <enthropy> Forall h1 => H1 h1 m1
15:59:18 <sm> hi alll
15:59:39 <xplat> who's this al?
15:59:43 <mniip> enthropy, you're missing the H0 part
16:00:00 <osa1> hexagoxel: but even if it's evaluated in compile time and reduced to a value, I should at least be seeing a 'False` value somewhere, right?
16:00:03 <enthropy> oops,  Forall (H0 h1) => H1 h1 m1
16:00:22 <sm> for 7.8/7.10 compatibility, I replaced import Control.Applicative with Control.Applicative.Compat from base-compat. Why do I still get "import of ‚ÄòControl.Applicative.Compat‚Äô is redundant" warnings ?
16:00:32 <mniip> given that module uses even more extensions I'll just use forall. instead
16:00:57 <sm> I thought the whole point of base-compat was to avoid needing CPP
16:01:29 <enthropy> my guess is that base-compat is out of date
16:01:36 <pharaun> is there a good paper or ref for taking a sequence of callback (in a chain) and turn it into more cps style so that its more "linear" to code up?
16:01:36 <xplat> mniip: i think probably Forall is going to behave better than rank-2 constraints :-/
16:02:00 <osa1> hexagoxel: yeah I can see it when I export it, it's not completely evaluated statically but at least there's some loop fusioning going on, I think
16:02:01 <hexagoxel> osa1: i would agree, and found that strange as well. maybe `shows17` does unexpected things (like inverting)? i don't know more, sorry
16:02:22 <sm> enthropy: hmm, yes it's almost a year old, but still
16:02:25 <sagittarian|3> how can i tell when i know enough haskell to write a real program?
16:02:34 <osa1> s/loop fusion/deforestation
16:02:50 * sm just wasted a few hours >:|
16:03:04 <xplat> sagittarian|3: try to write a real program.  if it works, you know enough haskell to write a real program.
16:03:27 <sagittarian|3> sounds scary
16:03:55 <pharaun> naw
16:04:33 <xplat> sagittarian|3: only if you try it for work/a grade
16:05:03 <sagittarian|3> ha i wish i was doing it for work
16:05:33 <sagittarian|3> maybe i should suggest to everyone at work that we should do the now front-end web project using ghcjs, see how well that goes over
16:07:21 <xplat> sagittarian|3: maybe with reflex you'd have an actual chance
16:09:49 <sagittarian|3> i spent about 5 hours today reading javascript code and cursing at the team that speaks javascript with a heavy heavy java accent
16:10:19 <xplat> ouch
16:11:07 <xplat> javascript has noise in all the wrong places as it is
16:11:50 <sagittarian|3> it's not a lot of code and it's almost incomprehensible
16:11:58 <xplat> (like, you have to write 'function' on a lambda, but your 'standard library' has half of its functions overloaded onto the name '$')
16:12:42 <sagittarian|3> es6 gives you arrow functions, so there's that
16:13:21 <sagittarian> this perfectly describes the code i've spent the past week trying to understand on and off (and it's in javascript, not java): http://steve-yegge.blogspot.co.il/2006/03/execution-in-kingdom-of-nouns.html
16:13:25 <dhil> say I got two MTs "type A = WriterT String (ReaderT [Int] Maybe) Int" and "type B = ReaderT (WriterT String [Int]) Maybe Int"; how may I define a function permute :: A -> B ?
16:14:20 <Axman6> that second type seems pretty strange to me
16:14:32 <jle`> you probably mean (WriterT String [])
16:14:38 <dhil> ye
16:14:47 <jle`> dhil: you might first think about what your types are actually saying
16:15:02 <jle`> remember that monad transformers are actaully just newtype wrappers...like First/Sum/etc.
16:15:08 <dhil> yes
16:15:09 <jle`> so think about the types they wrap
16:15:24 <jle`> WriterT String (ReaderT [Int] Maybe) Int is
16:15:35 <jle`> ...one sec heh this is a doozie.
16:15:49 <jle`> hm. the better question probably is, why do you have concrete stacks like that in the first place?
16:16:09 <dhil> I am just toying around with MTs...
16:16:15 <jle`> are you controlling where they come from?  couildn't you make them both the same in the first place, or paraterize them?
16:16:19 <jle`> oh i see
16:16:22 <xplat> dhil: when you figure out what you actually ask, you probably want to use @unmtl to figure out the 'real' types, @djinn to write a conversion function, and then add ReaderT/WriterT/runReaderT/runWriterT where needed
16:16:41 <jle`> @unmtl WriterT String (ReaderT [Int] Maybe) Int
16:16:41 <lambdabot> (ReaderT [Int] Maybe) (Int, String)
16:16:46 <jle`> oh the second type is still weird
16:16:53 <jle`> why is your environment a (WriterT String [Int]) ?
16:17:09 <jle`> you want to carry a WriterT as an environment...?
16:17:35 <jle`> there is a good chance that there really isn't a meaningful permutation
16:17:49 <xplat> i'm assuming B wants to be ReaderT [Int] (WriterT String Maybe) Int
16:17:51 <dhil> maybe that is my problem. I actually started with first definition and then "swapped" them to see if I could translate between the two
16:19:03 <jle`> [Int] -> Maybe (Int, String) is the first one
16:19:33 <xplat> @unmtl ReaderT [Int] (WriterT String Maybe) Int
16:19:33 <lambdabot> [Int] -> (WriterT String Maybe) Int
16:19:33 * hackagebot pipes 4.1.5 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.5 (GabrielGonzalez)
16:19:39 <jle`> assuming the second one is ReaderT [Int] (WriterT String Maybe) Int...
16:20:32 <dhil> well, thanks. I will try it out
16:20:35 <jle`> then it's [Int] -> Maybe (Int, String)
16:20:37 <jle`> oh huh
16:20:50 <jle`> did i do something wrong
16:20:58 <xplat> no, probably not
16:21:06 <jle`> i guess Writer and Reader commute?
16:21:12 <dhil> I am hoping they are
16:21:49 <jle`> interesting
16:22:09 <dhil> but I think you are right; the definition of my second MT is wrong.
16:22:38 <jle`> :t WriterT
16:22:40 <lambdabot> m (a, w) -> WriterT w m a
16:22:46 <jle`> :t WriterT . runReaderT
16:22:48 <lambdabot> ReaderT r ((,) a) w -> WriterT w ((->) r) a
16:22:57 <xplat> a lot of libraries are updating after the primitive-0.6 release
16:23:33 <jle`> that is...almost right, exceptthe underlying monad saren't newtype-wrapped
16:23:34 <jle`> heh.
16:23:50 <xplat> :t ReaderT . WriterT . runReaderT . runWriterT
16:23:50 <jle`> :t ReaderT . runWriterT
16:23:51 <lambdabot> WriterT a ((->) r) a1 -> ReaderT r ((,) a1) a
16:23:51 <lambdabot>     Couldn't match type ‚ÄòWriterT (a2, w) ((->) r1) a1‚Äô with ‚Äòr -> m a‚Äô
16:23:51 <lambdabot>     Expected type: (r1 -> (a1, (a2, w))) -> r -> m a
16:23:51 <lambdabot>       Actual type: (r1 -> (a1, (a2, w)))
16:24:18 <xplat> :t ReaderT . WriterT . runReaderT . (runWriterT .)
16:24:19 <lambdabot>     Couldn't match type ‚ÄòWriterT w0 ((->) r0) a0‚Äô with ‚Äòr -> m a‚Äô
16:24:19 <lambdabot>     Expected type: (r0 -> (a0, w0)) -> r -> m a
16:24:19 <lambdabot>       Actual type: (r0 -> (a0, w0)) -> WriterT w0 ((->) r0) a0
16:24:33 * hackagebot vivid 0.1.0.3 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.1.0.3 (TomMurphy)
16:24:54 <xplat> :t ReaderT . (WriterT .) . runReaderT . runWriterT
16:24:55 <lambdabot> WriterT w (ReaderT r m) a -> ReaderT r (WriterT w m) a
16:25:01 <xplat> ah, there we go
16:25:03 <jle`> the most clean way would probably be to do it by manually breaking things down and using do notation
16:25:21 <xplat> i find mine pretty readable
16:25:31 <xplat> better read-only code than write-only
16:25:32 <mniip> woah
16:25:44 <mniip> I invented some fancy shmancy tuple operations :o
16:25:59 <jle`> "read"-only :P
16:26:22 <mniip> 'map get1 $ iterate (fold12 (+) . swap12) (0, 1)' gets the fibonacci numbers
16:26:32 <xplat> :t WriterT . ReaderT . (runWriterT .) . runReaderT
16:26:33 <lambdabot> ReaderT r (WriterT w m) a -> WriterT w (ReaderT r m) a
16:27:42 <mniip> what's worse, I can say 'map get1 $ iterate (fold12 (+) . swap12) ("hello", 0, 1)'
16:27:43 <xplat> jle`: what's not readable?  unwraps both transformers, rewraps them in the opposite order, some administrivia is reduced to one dot and two parens.
16:27:53 <mniip> and the program still typechecks and gives fibonacci numbers
16:29:34 * hackagebot morte 1.1.2 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.1.2 (GabrielGonzalez)
16:30:08 <xplat> jle`: of course, if you're willing to limit yourself to recent enough ghc, you can replace the whole thing with 'coerce' :)
16:30:08 <jle`> i guess i wouldn't bat too much of an eye when reading it if it had a type annotation
16:30:19 <jle`> ah yes, that does work too :P
16:31:06 <jle`> :t \wtr -> ReaderT $ \r -> do (x, w) <- runReaderT (runWriterT wtr) r; tell w; return x
16:31:07 <lambdabot> MonadWriter w m => WriterT w (ReaderT r m) a -> ReaderT r m a
16:36:24 <xplat> :t \wtr -> do asks $ \r -> do (x, w) <- runReaderT (runWriterT wtr) r; tell w; return x
16:36:25 <lambdabot> (MonadReader r m, MonadWriter w m1) => WriterT w (ReaderT r m1) b -> m (m1 b)
16:37:26 <xplat> :t \wtr -> do (x, w) <- asks $ runReaderT (runWriterT wtr) r; tell w; return x
16:37:27 <lambdabot> (MonadReader r m, MonadWriter w m) => WriterT w (ReaderT Expr ((->) r)) b -> m b
16:38:12 <xplat> :t \wtr -> do (x, w) <- asks $ runReaderT (runWriterT wtr); tell w; return x
16:38:13 <lambdabot> (MonadReader r m, MonadWriter (a, w) m) => WriterT w (ReaderT r ((,) b)) a -> m b
16:39:23 <xplat> that's still not *quite* right :(
16:39:34 * hackagebot foldl 1.0.9 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.9 (GabrielGonzalez)
16:39:37 <xplat> see, mine is easier to write too!
16:41:27 <yuung> hi, total haskell noob here and wanting to learn, what does it mean when one says haskell checks types statically?
16:41:30 <xplat> :t \wtr -> do (x, w) <- lift $ lift $ asks $ runReaderT (runWriterT wtr); tell w; return x
16:41:32 <lambdabot> (Monad (t1 m), MonadReader r m, MonadTrans t, MonadTrans t1, MonadWriter (a, w) (t (t1 m))) => WriterT w (ReaderT r ((,) b)) a -> t (t1 m) b
16:41:50 <jle`> yuung: all the types of your functions are made sure to work and match at compile-time
16:41:59 <jle`> so you can't do something like True + "hello"
16:42:10 <yuung> jle` ah, okay - and that goes along with its certainty principle?
16:42:17 <jle`> what is the certainty principle?
16:42:25 <xplat> le sigh
16:42:31 <jle`> xplat: i think the original do one i wrote out sin't too bad on multiple lines? ><
16:42:32 <yuung> something like if your code compiles then there's a very good chance it'll run
16:42:45 <jle`> ah. yeah, that's a part of it.  
16:42:54 <jle`> the other part is that your types can encode a lot of things about the correctness of your program
16:42:58 <jle`> moreso than most other languages
16:43:16 <jle`> it can do more than just prevent True + "hello"...it can prevent bad logic, too
16:43:23 <yuung> jle`, i see
16:43:26 <xplat> jle`: i figured if i was using do i'd like to have the extra generality
16:43:39 <yuung> jle`, i think that's something i'll come to grips with while programming haskell
16:43:58 <xplat> yuung: when you get good with writing fancy types, you can actually type your code so that the only way it can go wrong is an infinite loop
16:44:07 <jle`> yuung: yeah, it's something that's a bit hard to show with a flashy code golf example, but it'll become clear as you write more :)
16:44:28 <yuung> xplat, is "writing a type" analagous to defining a class?
16:44:34 <yuung> jle`, i look forward to it!
16:44:36 <xplat> yuung: usually it's a little less than that, but it still helps a lot and lets you focus testing on complex, interesting properties
16:44:45 <yuung> xplat i see
16:46:10 <xplat> yuung: "writing a type" in the sense i mean is something you probably won't be able to get a grip on from an analogy, because you probably haven't used another language with a type system expressive enough to do it in, and it's very much its own thing
16:47:07 <xplat> it's one of those things you learn by reading and writing code
16:47:21 <yuung> xplat ah - fortunately that's the best way i learn :)
16:52:26 <narvius> Hello; I'm currently fiddling around with binary trees (defined as data T a = Leaf a | T (T a) (T a)). I have a Monoid m => Monoid (T m) instance, and for Monoid m => T m, I could construct an Applicative instance. Because I can't constrain the last type argument in an Applicative instance, I can't, though. Is there some sorcery that would allow me to do so anyways?
16:54:08 <Hijiri> not that I know of
16:54:11 <shachaf> No, Applicative needs to be parametric.
16:54:26 <jle`> you can't, because Applicative as Haskell has to be a functor from *any* type
16:54:34 * hackagebot json-autotype 0.2.5.11 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.11 (MichalGajda)
16:54:36 <jle`> it has to be able to take Int, String, Bool, anything
16:54:38 <Hijiri> could you make a GADT that only accepts things with monoid instances?
16:54:42 <Hijiri> or does it unwork that way
16:54:51 <Hijiri> oh, you couldn't fmap
16:54:54 <Hijiri> if you did that
16:55:07 <shachaf> What is your Monoid instance, anyway?
16:55:37 <narvius> http://lpaste.net/129848
16:55:58 <jle`> you can do something with an Applicative typeclass that is slightly different...the "restricted monad" trick will work here too.  but as Applicative in base is at this point, something like this would betray the spirit
16:56:24 <narvius> I figured as much, thanks. :)
16:56:44 <jle`> this is the same reason why Set isn't a Functor
16:56:58 <jle`> well. if you ignore non-structural equality
16:57:37 <lpaste> mniip pasted ‚Äúthe most beautiful way to process tuples‚Äù at http://lpaste.net/129849
16:57:37 <lpaste> mniip pasted ‚Äúthe most beautiful way to process tuples‚Äù at http://lpaste.net/129850
16:57:51 <mniip> wot
16:57:54 <mniip> I only pasted one
16:59:35 * hackagebot wai-lens 0.1 - Lenses for WAI  http://hackage.haskell.org/package/wai-lens-0.1 (purefn)
16:59:42 <lifter> I have a line of conduit code: "yield (toJSON tbl) $$ CL.map (BL.toStrict . encode) =$ CB.sinkFile file" (CL = conduit list, BL = bytestring lazy, CB = conduit binary). How can I ensure that this code is safe from async exceptions?
17:02:11 <mniip> one can even define prelude functions with that
17:02:54 <mniip> const = (runIdentity .) . curry delete1
17:04:35 * hackagebot logfloat 0.13.3 - Log-domain floating point numbers  http://hackage.haskell.org/package/logfloat-0.13.3 (WrenThornton)
17:17:44 <dibblego> sritchie: the duplication in this case is just a consequence of history, but you could use (<*>) = M.ap after you have imported Control.Monad as M
17:20:13 <sritchie> dibblego: nice. I remember hearing about that historical quirk - guess this is a good time to read up
17:20:15 <sritchie> dibblego: thanks
17:21:18 <dibblego> the important point there is that ap is constrained by Monad, but you can weaken that constraint to Applicative (<*>) and have equivalent power (and weakened constraint means more instances).
17:21:29 <dibblego> you might sometimes hear, "all monads are applicative" ó that is what is meant here
17:24:36 * hackagebot picoparsec 0.1.2.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/picoparsec-0.1.2.1 (MarioBlazevic)
17:37:03 <d-snp> "Assertion failed: (isValidElementType(EltTy) && "Invalid type for pointer element!"), function get, file Type.cpp, line 732."
17:37:12 <d-snp> did that come from ghc itself?
17:37:19 <d-snp> or perhaps the library I'm linking against?
17:38:50 <monochrom> Type.cpp is not part of ghc
17:39:30 <d-snp> hmm I think it's part of the LLVM.General
17:40:17 <d-snp> I don't feel like reading Type.cpp at all :P
17:55:11 <yuung> why is null("") true?
17:55:28 <yuung> does "" become an empty list?
17:55:52 <shachaf> "" is an empty list of characters. It's equal to [].
17:57:26 <pacak> > 'h':'i':[] == "hi"
17:57:28 <lambdabot>  True
17:57:45 <jle`> "" is syntactical sugar for [] :: [Char]
17:58:31 <pacak> yuung: Also you don't need () in this case
17:59:09 <pacak> > null ""\
17:59:10 <lambdabot>  <hint>:1:8: parse error on input ‚Äò\‚Äô
17:59:11 <pacak> > null ""
17:59:12 <lambdabot>  True
18:00:39 <Gurkenglas> What ghci command will tell me whether an instance declaration is loaded for some typeclass and type? (Attempting to use features of the typeclass doesn't seem like the "right" way.)
18:01:29 <heatsink> :info T will list all classes whose instances mention T 
18:02:49 <fresheyeball_> does anyone on here know how use fpcomplete?
18:17:40 <Gurkenglas> I've tried it for a while. Ask away.
18:18:56 <narvius> If anyone remembers my earlier question about having a monoid instance for a binary tree with values on leaves only; I've realized I'm dumb and could just define a straightforward Applicative instance instead.
18:19:04 <lpaste> narvius pasted ‚ÄúBinary Tree fiddlery‚Äù at http://lpaste.net/129851
18:23:17 <Gurkenglas> narvius, why do you need line 13? Is that just optimization?
18:25:41 <narvius> Gurkenglas: Yeah, pretty much.
18:27:07 <narvius> It probably makes less of a difference than I'd think it does, though...
18:27:25 <Gurkenglas> I have a hunch it would be better for the right side to not be pattern-matched at that point
18:27:48 <Gurkenglas> Allows for more laziness - who knows whether the functions to be applied care about the argument, or something
18:28:43 <EvanR> more laziness more laziness
18:28:46 <narvius> I have no clue, so I'll just believe you. Probably.
18:29:30 <Gurkenglas> Which might of course be a rationalization, the reason I started looking for reasons not to include that line is "hey that line isn't necessary"
18:29:57 <narvius> Haha, fair enough.
18:30:25 <narvius> But yeah, about 5 hours ago I found a piece of code where I solved an old problem I was once presented with, and have been fiddling around since then pretty much. :x
18:31:07 <narvius> (The problem: Given a list of binary strings, determine whether an infinite binary string can be constructed, such that it doesn't include any of the input strings)
18:31:47 <Gurkenglas> Cool.
18:31:59 <Gurkenglas> Alphabet is small?
18:32:02 <EvanR> when would it not be possible
18:32:13 <bob_twinkles> input string is "1" or "0"
18:32:18 <Gurkenglas> EvanR, when every one-character string is in the list
18:32:31 <Gurkenglas> (Oh, "binary" strings. <.<)
18:32:35 <narvius> :)
18:32:52 <bob_twinkles> *and, not or. derp
18:33:39 <narvius> also *contains, not includes
18:33:41 <narvius> but whatever.
18:34:39 * hackagebot lifted-async 0.7.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.7.0 (MitsutoshiAoe)
18:35:44 <Gurkenglas> Sounds like you should take all strings of length one, remove those in the list, crossproduct-concat the resulting list with itself, remove all forbidden length-2s, cross-concatenate, and now the length3s might result in some solvable inefficiency...
18:36:41 <lpaste> narvius pasted ‚ÄúProblem solution (without imports and stuff)‚Äù at http://lpaste.net/129852
18:39:40 * hackagebot xcffib 0.2.2 - A cffi-based python binding for X  http://hackage.haskell.org/package/xcffib-0.2.2 (TychoAndersen)
18:40:27 <Gurkenglas> :t All
18:40:28 <lambdabot> Bool -> All
18:40:48 <Gurkenglas> wut. umm. some wrapper with an instance?
18:40:51 <Gurkenglas> :info All
18:40:56 <narvius> Yeah, from Data.Monoid
18:41:07 <narvius> It's a wrapper for bools that pretty much corresponds to (&&)
18:41:14 <Gurkenglas> kk
18:41:16 <narvius> Any is (||)
18:44:13 <Gurkenglas> Is it just me or are you checking the infinite string not for containing a forbidden string, but starting with one?
18:46:03 <narvius> I'm not going anywhere near the hypothetical infinite string
18:46:29 <Gurkenglas> Well yes cause if you're just checking for whether it starts with that you need not go beyond the longest forbidden string
18:46:47 <narvius> Instead I construct a binary tree encoding all the strings I can't use, and if any leaves remain "open", then that can always be exploited to create an infinite string
18:47:13 <narvius> If you have, say "00", "01", "10", I could construct a string "11 11 11 11 11" because 11 is not forbidden
18:47:18 <narvius> and that's information I can read from the trie
18:47:20 <narvius> tree*
18:47:40 <Gurkenglas> Let me look for a counterexample...
18:48:27 <Gurkenglas> solve ["0","11"]
18:48:49 <narvius> "01 01 01 01 01 01"
18:48:59 <Gurkenglas> That one contains 0.
18:49:00 <narvius> or "00 00 00 00" for that matter
18:49:03 <narvius> oh, right
18:49:10 <narvius> yeah, you can't create an infinite string with that I guess
18:49:18 <Gurkenglas> Your code finds 10.
18:49:45 <narvius> Okay.
18:50:26 <Gurkenglas> I think. Test it. Also now I feel bad.
18:51:01 <Gurkenglas> "But anything that can be destroyed by the truth should be." *wipes a tear*
18:52:22 <Gurkenglas> *that which, dangit
18:57:22 <narvius> Hm.
18:57:46 <narvius> Gurkenglas: Just by swapping True <=> False inside build everywhere, it works.
18:57:58 <narvius> It shouldn't.
18:59:06 <Gurkenglas> Did you just swap all Trues with all Falses while thinking it wouldnt work to see whether it did? You can go to Haskell Hell for that.
18:59:12 <narvius> No, it doesn't.
18:59:17 <narvius> Good, it doesn't.
18:59:20 <narvius> My sanity is saved.
18:59:45 <narvius> Nah, I'm writing a couple cases out by hand on paper
19:01:51 <Gurkenglas> Damn my memory for thinking the clipboard was gonna keep hold of what I was writing before it was interrupted by my last line and damn YChat for occasionally wiping my clipboard for no good reason.
19:04:40 <Gurkenglas> Ah, I still have a relevant tab open: There should be a typeclass Wrapper a b where ∞ :: b -> a
19:04:55 <Gurkenglas> So all the unwrap operations can be replaced with one character.
19:05:59 <narvius> I actually thought the same thing like a couple minutes ago
19:06:02 <Gurkenglas> -writing+thinking
19:06:34 <narvius> It would be a bit problematic, though
19:06:48 <narvius> because usually when you do wrap-something-unwrap, you have multiple options
19:06:56 <narvius> and the only difference is the behavior during [something]
19:07:08 <narvius> so you would still have to signal WHICH wrapper you want to use
19:07:20 <narvius> Which means hello type annotations in the middle of code
19:07:34 <Gurkenglas> You mean the something might return another wrapper than the input? Aww I was hoping wrap-something-∞ would be enough
19:08:41 <narvius> f :: Wrapper w => w a -> w b    -------- unwrap . f . wrap :: a -> b
19:08:47 <narvius> the information what wrapper to use gets lost
19:09:45 <Gurkenglas> The typeclass wouldn't provide an wrap operation, only unwrap.
19:09:51 <Gurkenglas> *a
19:10:07 <Gurkenglas> (Maybe it should be called Wrapped)
19:10:31 <narvius> Oh, that.
19:10:34 <EvanR> Burrito
19:10:45 <narvius> Yeah, that could easily be a thing I guess.
19:14:26 <Gurkenglas> If there was Flip ::: (* -> * -> *) -> (* -> * -> *), Wrapped = Flip Coercible
19:16:08 <Gurkenglas> As a bonus, Read = Wrapped String
19:16:33 <Gurkenglas> Wait no nvm, Read = Coercible String
19:16:54 <Gurkenglas> Show = Wrapped String.
19:17:29 <Gurkenglas> We should probably demand the axiom that ∞ be bijective.
19:38:40 <solirc> sm: We still need to update base-compat for that
19:39:22 <solirc> sm: You would then enable NoImplicitPrelude and import Prelude.Compat
20:04:48 * hackagebot overture 0.0.2 - An alternative to some of the Prelude.  http://hackage.haskell.org/package/overture-0.0.2 (fozworth)
20:12:01 <pacak> overture package? Why would you want a different name for id and const?
20:13:29 <alxgnon> I need help with a "Overlapping instances" error
20:13:32 <alxgnon> http://lpaste.net/4653242739004014592
20:14:20 <shachaf> Your instances are overlapping.
20:14:37 <geekosaur> correct
20:14:49 <lpaste> narvius pasted ‚Äúsolv2‚Äù at http://lpaste.net/129853
20:14:54 <geekosaur> note that the context does NOT play a part in instance resolution
20:14:55 <narvius> Gurkenglas: You made me do this.
20:15:50 <shachaf> The general problem is: What if someone else defines instance Functor Set?
20:15:51 <lpaste> narvius revised ‚Äúsolv2‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/129853
20:16:09 <geekosaur> which is to say, the firstinstance will match and only then check for Functor
20:16:20 <geekosaur> yes, there are good reasons for this
20:16:27 <alxgnon> I see
20:16:42 <alxgnon> the problem here is there is no way to define Functor for Set from what I've read
20:17:28 <shachaf> Yes. But that's the problem nonetheless.
20:17:31 <mauke> if classes were functions, that code would look like: Transpose (f a) = (Functor f, Transpose a); Transpose (Set a) = (Ord a, Transpose a)
20:17:53 <mauke> i.e. the context is like a function body, only used after a particular instance is selected
20:19:06 <alxgnon> Is there a way I could implement Transpose for Set without colliding with the implementation for Functors?
20:20:18 <shachaf> You could write instance Transpose (T a) for each Functor T.
20:22:06 <alxgnon> fair enough, considering I only really need to support some specific functors
20:22:23 <drewbert> Does haskell have any base62 encoding facilities?
20:22:38 <alxgnon> thank you
20:22:42 <drewbert> Or other url-friendly encoding schemes?
20:24:10 <drewbert> Ah, I found it.
20:24:15 <erikd> @hackage base64-bytestring
20:24:15 <lambdabot> http://hackage.haskell.org/package/base64-bytestring
20:25:10 <erikd> @hackage uri-encode
20:25:11 <lambdabot> http://hackage.haskell.org/package/uri-encode
20:25:12 <drewbert> I had found the base64 package, but I did not see that it had a url module.
20:26:14 <drewbert> I don't understand why google is so insistent on indexing such old versions of these packages.  I wish hackage could give google some hints to show new versions.
20:26:33 <drewbert> https://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64-URL.html
20:26:46 <monochrom> I think I know
20:27:10 <monochrom> Google's algorithm (at least the classical one) prefers a page referenced by many other pages
20:27:39 <monochrom> the oldest version is the most referenced
20:28:08 <drewbert> I wonder if we could write a chrome extension that would reorder the results for hackage pages.
20:28:11 <geekosaur> yep
20:28:28 <geekosaur> and it's not just a haskell problem, I know both perl and python have to deal with it as well
20:31:47 <glguy> Maybe robots.txt could block the version specific pages and require Google to use the links for latest version
20:32:24 <glguy>   Package/latest/
20:35:07 <shachaf> You can put <link rel="canonical"> tags in the HTML to tell search engines what the canonical URL for a page is.
20:35:28 <shachaf> Then it'll only link to the canonical version of a page. That might or might not be a good thing.
20:47:24 <Gurkenglas> narvius, *read your code, thought for <300 seconds*: solve ["00", "01", "11"] finds "10", but neither "100" nor "101" are allowed.
20:53:38 <Gurkenglas> I just thought of the first algorithm I'm certain will work, and the trivial implementation takes 2^(2^max) time. :D
20:54:14 <Gurkenglas> (No wait its even (2^max)!)
21:00:28 <Gurkenglas> drewbert, couldn't you just edit the robots.txt to that effect?
21:02:29 <Gurkenglas> (Hmm, found a slight variation that gets it down to max*(2^max).)
21:23:12 <lethjakman> Hey, I've been reading the documentation about "on" and I can't seem to understand what it does. How does this function work? 
21:23:59 <EvanR> :t groupBy
21:24:00 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:24:14 <EvanR> :t on
21:24:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:25:14 <EvanR> :t comparing
21:25:15 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:25:22 <lethjakman> Maybe I'm too new...I get that it returns a function that returns a function that can accept two arguments. But I don't know what it actually does. 
21:25:38 <lethjakman> What am I missing? 
21:25:58 <EvanR> its for coming up with a way to compare two values
21:26:16 <EvanR> by using other functions defined in that type
21:26:42 <caconym> this is a good example:
21:26:55 <caconym> sortBy (compare `on` fst)
21:27:02 <EvanR> ah sortBy
21:27:12 <caconym> (from Data.Function docs)
21:27:31 <EvanR> on is a generalization of comparing
21:28:05 <lethjakman> So it compares based off of the first of each in the list? Am I ubderstanding that right? 
21:28:20 <EvanR> it sortsBy doing that
21:28:23 <EvanR> :t sortBy
21:28:24 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
21:28:30 <caconym> in that example, yeah, it would compare on the first element of a list of tuples
21:29:42 <caconym> :t on
21:29:43 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:29:58 <arkeet> comparing = (compare `on`)
21:30:04 <lethjakman> Us there an easy way to see a function definition? 
21:30:10 <EvanR> @src on
21:30:10 <lambdabot> (*) `on` f = \x y -> f x * f y
21:30:19 <arkeet> sometimes @src lies.
21:30:32 <lethjakman> When's that? 
21:30:40 <arkeet> you can look up the function's docs on hackage and click the source link.
21:30:49 <geekosaur> it's just a database, which was populated somewhat randomly
21:30:55 <arkeet> @where src
21:30:55 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
21:31:04 <geekosaur> the definition ghc actually uses can be gotten from the haddocks
21:32:00 <caconym> https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Function.html#on
21:32:17 <Axman6> ghc 7.10 has a new function that serves a similar purpose (sortWith I think?) it performs a schwartzian transform to make things more efficient
21:32:52 <arkeet> sortOn
21:34:41 <arkeet> ah, they changed nub to take an Ord constraint.
21:34:53 <arkeet> yet nubBy still takes an (==)-like argument.
21:34:53 <Axman6> hoorah
21:35:09 <arkeet> oh wait.
21:35:13 <arkeet> no, it's by (<) now.
21:35:20 <arkeet> wait.
21:35:25 <arkeet> I'm looking at at different package.
21:35:36 <arkeet> https://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/Data-List-Ordered.html
21:35:58 <arkeet> but sortOn made it into base.
21:36:40 <arkeet> I wonder who would actually be opposed to changing nub.
21:38:10 <EvanR> if its for de-duping, and its needs Ord, then it only works on things with ORd
21:38:26 <EvanR> which might be annoying or impossible 
21:38:31 <EvanR> to satisfy
21:38:46 <mauke> > nub [0 ..]
21:38:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:39:01 <Rotaerk> what a nub
21:39:19 <EvanR> wait what
21:39:45 <EvanR> > nub (3:[0..])
21:39:46 <lambdabot>  [3,0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:39:56 <EvanR> stupid haskell tricks
21:42:22 <EvanR> > nub (repeat 3 ++ [0..])
21:42:25 <lambdabot>  mueval-core: Time limit exceeded
21:42:49 <mauke> yeah, that's not going to terminate no matter what type nub has
21:43:16 <EvanR> shouldnt it at least start with 3
21:43:24 <mniip> it does
21:43:29 <mniip> > head $ nub (repeat 3 ++ [0..])
21:43:31 <lambdabot>  3
21:43:32 <mauke> > take 1 (nub (repeat 3))
21:43:33 <lambdabot>  [3]
21:43:45 <EvanR> > take 2 (nub (repeat 3))
21:43:50 <lambdabot>  mueval: ExitFailure 1
21:43:52 <EvanR> meh
21:48:28 <EvanR> [1, 2, 3] ++ let x = x in x
21:48:34 <EvanR> [1,2,3*** Exception: <<loop>>
21:48:39 <EvanR> i guess lambdabot is different
21:50:19 <mauke> lambdabot does something like 'take 80 (show ...)'
21:50:56 <mauke> it can't just send every character it gets to IRC immediately
21:51:01 <mauke> it has to build a whole message first
21:51:16 <EvanR> "[1,2,3*** Exception: <<loop>> ;)
21:51:44 <EvanR> i guess thats not a complete string
21:51:47 <EvanR> somehow
21:53:29 <mniip> it discards the output when mueval fails
21:53:50 <mniip> (but doesn't when there's an exception)
21:54:00 <EvanR> > [1, 2, 3, undefined]
21:54:02 <lambdabot>  [1,2,3,*Exception: Prelude.undefined
22:04:55 * hackagebot json-rpc-server 0.1.5.0 - JSON-RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.5.0 (grayjay)
22:05:28 <mniip> hmmm
22:05:50 <mniip> is there some sort of Contravariant Monad out there
22:06:07 <EvanR> Comonad?
22:06:29 <mniip> nope
22:06:48 <mniip> Comonad is the reverse of Monad
22:07:00 <mniip> depends on Functor and not Contravariant
22:10:26 <EvanR> mniip: this reddit post has a response on the subject by edwardk http://www.reddit.com/r/haskell/comments/1vc0mp/whats_up_with_contravariant/
22:13:00 <Cale> mniip: You could look into what a monoid object in the category of functors C^op -> C would be, but the tricky part is finding an appropriate monoidal structure on that category.
22:13:10 <Cale> There's a paper which does it here: http://cs.ioc.ee/~james/papers/Relative_Monads.pdf
22:13:24 <Cale> (Not just for C^op, but for an arbitrary index category J)
22:13:46 <mniip> trying to port my tuple-isms to functions...
22:14:27 <mniip> you can write 'set2 :: x -> (a -> b -> r) -> (a -> x -> r)', but 'get2 :: (a -> b -> r) -> b' is uh
22:14:55 * hackagebot hasql-backend 0.4.1 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.4.1 (NikitaVolkov)
22:14:57 * hackagebot hasql-postgres-options 0.1.4 - An "optparse-applicative" parser for "hasql-postgres"  http://hackage.haskell.org/package/hasql-postgres-options-0.1.4 (NikitaVolkov)
22:15:32 <EvanR> @pl \a b r -> b
22:15:33 <lambdabot> const const
22:15:49 <mniip> misinterpreting the type here
22:15:50 <EvanR> oops
22:16:08 <EvanR> you cant get the b
22:18:57 <mniip> yeah
22:19:07 <mniip> so it has to return a context-ed value then
22:19:12 <mniip> like a reader in a reader
22:19:50 <mniip> whatever I have to go now
22:19:56 * hackagebot http-streams 0.7.2.6 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.2.6 (AndrewCowie)
22:20:04 <EvanR> lambda calculus ftw
22:20:33 <EvanR> who needs data structures
22:31:35 <begriffs> How would I parse a string like "a->b->>c" into a data structure like (DoubleArrow (SingleArrow (Identifier "a") (Identifier "b")) Identifier "c")? Would parsec be good for this?
22:50:45 <johnw> begriffs: yeah, it'd be great at that
23:00:28 * hackagebot config-value 0.3 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.3 (EricMertens)
23:00:34 <jle`> hi begriffs , big fan of your blog
23:02:41 <begriffs> jle`: oh thanks! Gotta write more again soon. Been playing around with data lately, but have a few ideas for Haskell posts.
23:02:53 <jle`> looking forward to it :D
23:08:06 <begriffs> jle`: are you jle on github?
23:14:59 <begriffs> jle`: Ah no, you're mstksg right? I enjoyed your IO "monad" post.
23:25:29 * hackagebot cabal-test-quickcheck 0.1.6 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.6 (TimothyJones)
23:30:30 * hackagebot cabal-test-quickcheck 0.1.5 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.5 (TimothyJones)
23:35:30 * hackagebot http-media 0.6.1 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.6.1 (TimothyJones)
23:40:30 * hackagebot cmark 0.3.1 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.1 (JohnMacFarlane)
