00:08:02 * hackagebot th-instance-reification 0.1.3 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.3 (NikitaVolkov)
00:08:02 * hackagebot objective 1.0.3 - Extensible objects  http://hackage.haskell.org/package/objective-1.0.3 (FumiakiKinoshita)
00:34:53 <Misha> Hi guys
00:35:19 <Guest89715> is there any chance i can ask a quick question
00:39:39 <jle`> yes
00:39:41 <jle`> aw they left
01:02:32 <hunteriam> how would i get the "sizeof" a storable type in haskell
01:03:03 <glguy> The Storable class has a sizeOf method
01:03:10 <hunteriam> but you have to pass it a value
01:03:17 <hunteriam> its really really awkward in my situation to do that
01:03:29 <glguy> It's an old fashioned api, you can pass in undefined
01:03:30 <hunteriam> i have a Ptr <datatype>
01:03:36 <jle`> the typical trick is sizeOf (undefined :: MyType)
01:03:40 <hunteriam> ahhh
01:03:43 <jle`> not the cleanest solution but
01:03:45 <hunteriam> ok thanks guys
01:03:52 <hunteriam> way better than what id have to do otherwise
01:04:31 <dashster18> hi
01:04:56 <jle`> hi dashster18 
01:05:05 <jle`> np hunteriam !
01:05:52 <hunteriam> in the gl library, do i need a shader to paint anything at all, or is my code broken
01:05:58 <hunteriam> cause im currently not drawing anything at all
01:06:20 <dashster18> How does haskell fare for large scale data processing applications? I would think it's good due to the dependency on parallelism when dealing with lots of data and the strict functional nature of haskell.
01:06:24 <hunteriam> it worked on a different computer
01:28:01 * hackagebot Cabal 1.22.2.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.2.0 (ryant)
01:31:30 <jle`> dashster18: i believe there are a few analytics companies that use haskell for just that
01:40:36 <gfixler> what are my options for 'live' 2D drawing with Haskell?
01:40:49 <gfixler> and ASCII/text is an invalid answer in this case :)
01:41:17 <gfixler> think things like 2D games, HTML canvas (but not online), or Flash videos, in their own window
01:45:57 <aawe> gfixler: you can play around with http://paste.hskll.org/get/2353
02:00:26 <gfixler> aawe: that's the diagram library, though, right?
02:00:33 <aawe> gfixler: yes
02:00:39 <gfixler> yeah, that won't do
02:00:50 <gfixler> I'm talking like 30fps in a window, reacting to keypresses
02:01:27 <forgottenone> why random library removed from ghci?
02:11:52 <aawe> forgottenone: you're going to have to elaborate
02:12:17 <aawe> gfixler: If it was 3d graphics I could help you. I don't know what people use for 2d graphics in any language.
02:25:23 <forgottenone> aawe i tried import System.Random but it won't work so i checked and see that module removed from ghc
02:26:08 <jle`> have you tried installing the `random` package?
03:09:27 <raek> if I want to move my source files into a "src" directory (to separate them from my tests), what should I add to my cabal file? just hs-source-dirs: src?
03:10:11 <ChristianS> raek: yes
03:10:25 <raek> ChristianS: ok, thanks!
03:22:12 <lpaste> dramforever pasted “My new lens idea” at http://lpaste.net/128137
03:22:48 <dramforever> I had this idea in the shower. As usual I want approval/suggestions/corrections...
03:24:23 <lpaste> dramforever revised “My new lens idea”: “My new lens idea” at http://lpaste.net/128137
03:24:55 <edwardk> dramforever:  type Lens s t a b = forall r. (a -> (b -> r) -> r) -> s -> (t -> r) -> r  -- is forall r. (a -> Cont r b) -> s -> Cont r t -- once you add in the quantifier this is almost isomorphic to the original  (forall r. Cont r b) ~ b but the quantifier is lifted
03:25:33 <dramforever> edwardk: yep
03:25:41 <dramforever> did you see my bottom hack?
03:26:08 <edwardk> the get ?
03:27:34 <edwardk> type Lens s t a b = forall r. (a -> (b -> r) -> r) -> s -> (t -> r) -> r  can probably be further generalized to
03:27:52 <edwardk> type Lens s t a b = forall q r. (a -> (b -> q) -> r) -> s -> (t -> q) -> r
03:28:50 <edwardk> anyways, the Cont here is playing its role as "mother of all monads"
03:30:16 <edwardk> we can also pick: type ALens s t a b = (a -> Context a b b) -> s -> Context a b t
03:30:45 <edwardk> ALens is provided by the lens library because it gives one choice of 'f' that is universal for lenses.
03:30:55 <edwardk> you can cloneLens :: ALens s t a b -> Lens s t a b
03:31:27 <edwardk> notice the fact that ALens s t a b is rank-1 though, so inference works really well for it
03:32:03 <Peaker> edwardk: you said having Rank2 lens parameters ruins inference, did you mean at use site?  Using the same type synonyms everywhere would probably make things more understandable (even if Rank2)
03:32:23 <Peaker> at definition site it matters less (given it's inside the library)
03:34:07 <edwardk> use site
03:34:31 <edwardk> your combinators that call those functions wind up with rank-2 arguments
03:34:51 <edwardk> foo l = do something with l here that passes it as a rank-2 argument to something else
03:34:55 <edwardk> now foo needs a rank-2 type
03:35:03 <edwardk> you infect with this need throughout the user program
03:35:12 <edwardk> they can now _never_ use type inference again until they aren't touching a lens
03:35:22 <edwardk> so you get that problem
03:35:33 <edwardk> then you also get the problem that the magic upgrade property of lens stops working
03:35:49 <edwardk> > (1,2)^._2
03:35:50 <dramforever> edwardk: sorry I was afk to fix the stupid sound system here. it's very annoying when the remote control panel and the actual mixer gets inconsistent
03:35:51 <lambdabot>  2
03:35:58 <edwardk> > ("hello","world")^..both
03:35:59 <lambdabot>  ["hello","world"]
03:36:05 <raek> when I want a cabal executable to on a library in the same project, what name should I put in the build-depends section?
03:36:08 <edwardk> > ("hello","world")^.both
03:36:09 <lambdabot>  "helloworld"
03:36:27 <dramforever> edwardk: yes the forall q r. one looks great, I'm gonna try this
03:36:29 <edwardk> that used the fact that both was a traversal to demand a monoid from you for String.
03:36:44 <raek> here the answer uses the name "mylib", but I don't see where that name comes from: http://stackoverflow.com/questions/12305970/how-to-make-a-haskell-cabal-project-with-libraryexecutables-that-still-run-with
03:37:13 <dramforever> > [Nothing ^. _Just, Just "foo" ^. _Just] -- I like this a lot
03:37:14 <lambdabot>  ["","foo"]
03:37:22 <raek> can I name a library the way I can name an executable?
03:37:54 <edwardk> Peaker: so basically by the time you're done, the encapsulated version now has combinators that don't work with as many types and you lose inference for everyone forever. hence why lens takes rank-1 arguments for almost everything
03:38:31 <edwardk> "everything you expect to work with something else should work"
03:38:41 <Peaker> edwardk: ah, I see
03:38:55 <edwardk> even if the types are nuts, as long as there we don't have to make stuff up to make it happen =)
03:39:07 <Peaker> edwardk: makes one wonder what kind of language would allow a library like lens without all the difficult compromises in type readability/etc
03:39:10 <dramforever> hmm..
03:39:39 <dramforever> to me lens is white magic
03:39:48 <Peaker> or even the question: should something like lens be elevated to special status in a language?
03:39:52 <edwardk> not sure. i have a weird form of binder i've been playing with that could allow polymorphic lens composition in a language, but i've never really figured out how to deal with all the corner cases
03:40:31 <edwardk> and my experience is i prefer the rather principled encodings that makes lens go to the kind of ad hoc overloadings that make things like perl go
03:41:41 <edwardk> i do think lens could use some love from the compiler to try to cling to type synonyms longer, etc.
03:42:06 <edwardk> or even hint at how to reapply them in cases
03:42:23 <edwardk> no idea how to do that though
03:43:07 * hackagebot audiovisual 0.0 - A battery-included audiovisual framework  http://hackage.haskell.org/package/audiovisual-0.0 (FumiakiKinoshita)
03:43:09 * hackagebot call 0.2 - The call game engine  http://hackage.haskell.org/package/call-0.2 (FumiakiKinoshita)
03:47:09 <Peaker> edwardk: if Control.Category.(.) and id were the Prelude ones -- would that open up a different design space?
03:47:29 <edwardk> not really
03:47:32 <dramforever> there aren't many magics in haskell. lens is white magic, and ghc-prim is black magic. Period. (Not meant to be accurate)
03:51:58 <Peaker> is there any unsafeCoerce-based library, that does O(0) deserialization from a strict ByteString to an unboxed data structure (i.e: type-level change only)?
03:52:56 <Peaker> I deserialize lots of small things from a BS key/value store, and Binary.decode seems expensive!
03:53:55 * dramforever sees that maybe a whole new language of O(0) functions is coming
03:54:40 <dramforever> Peaker: well 1. at least you need to check the length, or it gets too unsafe
03:54:52 <Peaker> true :)
03:55:11 <dramforever> 2. how about manual deserializing?
03:55:28 <Peaker> I wonder how it would interact with GC -- if I have a bunch of unboxed types inside a ByteString that I refer to -- is the GC smart enough to find the "container" BS to keep it alive?
03:55:40 <Peaker> (or better yet, keep a slice of it alive)
03:55:50 <dramforever> like ((bs `B.index` 0) .<<. 16) .|. (bs `B.index` 1)
03:56:04 <dramforever> for 16 bit big endian integers
03:57:06 <zipper> :t [a] -> [[a]]
03:57:07 <lambdabot> parse error on input ‘->’
03:57:07 <Peaker> except, without the costs
03:57:14 <zipper> @hoogle [a] -> [[a]]
03:57:16 <lambdabot> Data.List inits :: [a] -> [[a]]
03:57:16 <lambdabot> Data.List permutations :: [a] -> [[a]]
03:57:16 <lambdabot> Data.List subsequences :: [a] -> [[a]]
03:57:30 <dramforever> Whoa whoa, I was talking about looking for a regex combinator lib quite a while ago, and the scary thing: here it is: https://github.com/feuerbach/regex-applicative
03:57:32 <int-e> Peaker: note that the data in a bytestring is held on the C heap (it's a ForeignPtr), so that severely limits your options.
03:57:33 <Peaker> Endianess need not matter -- I have a k/v store that is used with the same endianess
03:57:52 <Peaker> int-e: worst-case, I could keep the BS alive?
03:59:15 <int-e> Peaker: yes. you can slice the bytestring by working with take/drop and friends.
03:59:55 <dramforever> Hmm...I guess peeking the ForeignPtr is okay?
04:00:52 <int-e> Peaker: (note: data ByteString = PS !(ForeignPtr Word8) !Int !Int, where the ints are offset and length, respectively. I dropped the {-# UNPACK #-} pragmas.)
04:01:30 <Peaker> (with new ghc, no need for the unpack pragmas, right? :-) )
04:02:17 <dramforever> -funpack-strict-fields, iirfc
04:02:18 <dramforever> s/iirfc/iirc
04:02:21 <int-e> Peaker: There's the -funpack-strict-fields  option, but I hope it's not enabled by default...
04:02:37 <Peaker> dramforever: that's old.. the new thing is that GHC unpacks small strict primitive types by default
04:02:51 <Peaker> if it's <= size of an indirection, why indirect? copy
04:03:17 <dramforever> okay
04:03:46 <Peaker> so, Data.Binary has quite a bit of overhead when deserializing a simple C struct, apparently. Storable requires a mutable backing of the data (AFAIK?).  ByteString<->unsafe-coerced-data  functions sound useful
04:04:04 <Peaker> I wonder if one can build up a big data-type that is guaranteed to be fully unboxed (equivalent to a known C struct)
04:04:26 <dramforever> Peaker: you can withForeignPtr, castPtr and peek from it
04:04:38 <dramforever> and wrap the whole thing with unsafe...You name it
04:05:27 <Peaker> that lets you get one particular field.  Can you get the entire string as a big unboxed record?
04:06:29 <int-e> Peaker: s/indirection/pointer/, so that works for the ints but not for the foreign pointer.
04:06:30 <dramforever> dunno
04:07:14 <int-e> Peaker: (An indirection is an auxiliary heap object consisting of a tag and another pointer to the real object)
04:09:35 <dramforever> whoa whoa: big numbers, long names:
04:09:35 <dramforever> http://hackage.haskell.org/package/HsOpenSSL-0.11.1.1/docs/OpenSSL-BN.html#g:5
04:16:48 <zipper> Hey, say I have a superset list of type [a] which has some values that are equal to each other. I want to create a list of subsets of equal values. I'll end up with [[a]]
04:17:00 <zipper> How could I do this?
04:17:17 <Peaker> zipper: you could sort and then group
04:18:27 <zipper> Peaker: hmmmm I still don't see how I'll put them in different lists even after they are sorted?
04:18:29 <zipper> *.
04:18:49 <zipper> Because I'll be using recursion.
04:19:05 <Peaker> @type group
04:19:06 <lambdabot> Eq a => [a] -> [[a]]
04:19:47 <jedai> @src group
04:19:47 <lambdabot> group = groupBy (==)
04:19:54 <jedai> @src groupBy
04:19:54 <lambdabot> groupBy _  []     =  []
04:19:54 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
04:19:54 <lambdabot>     where (ys,zs) = span (eq x) xs
04:20:15 <zipper> Peaker: Which package exports group?
04:20:28 <mauke> @index group
04:20:28 <lambdabot> Data.List
04:21:59 <zipper> Peaker: mauke jedai Thanks
04:23:38 <zipper> In fact groupBy is even better
04:43:10 * hackagebot jalla 0.2 - Higher level functions for linear algebra. Wraps BLAS and LAPACKE.  http://hackage.haskell.org/package/jalla-0.2 (ChristianGosch)
04:48:10 * hackagebot hydrogen-prelude 0.16 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.16 (JulianFleischer)
04:53:10 * hackagebot pipes-zeromq4 0.1.0.0 - Pipes integration for ZeroMQ messaging  http://hackage.haskell.org/package/pipes-zeromq4-0.1.0.0 (peddie)
04:58:10 * hackagebot hydrogen-prelude-parsec 0.16 - Hydrogen Prelude /w Parsec  http://hackage.haskell.org/package/hydrogen-prelude-parsec-0.16 (JulianFleischer)
05:21:36 <Haskellfant> how can I use an output marshaller that combines one input parameter and the output parameter with c2hs? the function I am using requires that I pass in a pointer to size_t and then returns a pointer. I'd like to marshall this so that it doesn't take an argument and returns a haskell list, but I fail to understand how I can marshall in and out parameters together
05:22:29 <Haskellfant> currently I have {#fun wlc_output_get_views as ^ {id `WLCHandle', alloca- `CSize' peek*} -> `(Ptr WLCHandle)' id#}
05:23:16 <zipper> Haskellfant: They haven't killed you for your tusks yet? You must be a lucky elephant.
05:23:27 <Haskellfant> I am :)
05:24:06 <zipper> Haskellfant: When elephants go extinct because people are morons. I'll remember that joke and weep.
05:24:26 <Haskellfant> hm I could just write a haskellwrapper around the thing c2hs produces and be done with it
05:24:31 <Haskellfant> probably the easiest way
05:27:21 <Haskellfant> I'll never understand why all the marshalling functions use Int instead of CInt
05:27:44 <Haskellfant> anyway, got it working with an additional function
05:53:12 * hackagebot hspec-attoparsec 0.1.0.2 - Utility functions for testing your attoparsec parsers with hspec  http://hackage.haskell.org/package/hspec-attoparsec-0.1.0.2 (AlpMestanogullari)
06:13:29 <nerium> I'm trying to install yesod-bin using cabal, but I'm getting nowhere
06:13:29 <nerium> https://gist.github.com/oleander/41811c884a17daae6de7
06:13:30 <nerium> What I'm I doing wrong?
06:14:51 <ralu> cabal update
06:30:10 <nerium> ralu: Nope, that didn't solve it
06:33:14 * hackagebot mgeneric 0.0.0.1 - Generics with multiple parameters  http://hackage.haskell.org/package/mgeneric-0.0.0.1 (rbocquet)
06:36:58 <zipper> Hamlet isn't expressive enough for my taste :(
06:39:38 <nerium> Isn't cabal suppose to solve dependency problems? I can't manage to install anything on my system 
06:39:39 <nerium> https://gist.github.com/oleander/d1a6fafa1c2f704e5b04
06:43:15 * hackagebot mgeneric 0.0.0.2 - Generics with multiple parameters  http://hackage.haskell.org/package/mgeneric-0.0.0.2 (rbocquet)
07:10:27 <tempname11_> syntax question: is it possible to "unlet" names inside do-notation?
07:11:51 <opqdonut> tempname11_: no
07:12:45 <opqdonut> tempname11_: except by nested scopes, something like "do x <- foo; {do let y = x+1; print y;} somethingElse"
07:13:38 <tempname11_> opqdonut: yeah, that's what I use sometimes
07:16:17 <tempname11_> unfortunately, this means I have to shift indentation for everything inside the nested block
07:17:28 <arkeet> why do you want to unlet something?
07:18:31 <arkeet> I can't think of any reason to unless you're shadowing some global thing.
07:18:42 <arkeet> which I would suggest not doing.
07:18:48 <tempname11_> arkeet: it's useful, for example, if you have a Ptr you just freed and don't want to use anymore
07:19:07 <tempname11_> or any other kind of "handle invalidation"
07:19:29 <arkeet> why wouldn't it be freed before it goes out of scope?
07:19:52 <arkeet> er
07:19:57 <tempname11_> well, the Ptr was a contrived example
07:19:58 <arkeet> I get what you mean.
07:20:10 <tempname11_> you could use "withPtr" and friends for that
07:20:16 <arkeet> yes, I was going to suggest that.
07:20:18 <tempname11_> but I mean the general case
07:30:08 <echo-area> `class Functor (f :: * -> *) where`  <--  What does (f :: * -> *) mean?
07:31:34 <tempname11_> echo-area: it means f has kind * -> *
07:31:55 <tempname11_> i.e. it is not a type, but a type constructor
07:32:00 <tempname11_> like Maybe
07:33:13 <echo-area> tempname11_: Thanks
07:37:46 <osa1> is there a way to load hsc files in cabal repl?
07:38:30 <enthropy> you don't have to do anything special (if the hsc file is part of your library/executable)
07:38:43 <enthropy> :reload doesn't re-run the preprocessor however
07:58:16 <athan> Hello everyone! I have a bit of a tricky question - is there a way to make a monad that has some kind of internal accumulator?
07:58:18 * hackagebot idris 0.9.17 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.17 (EdwinBrady)
07:58:20 * hackagebot hspec-discover 2.1.5 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.5 (SoenkeHahn)
08:00:10 <jmcarthur> athan: state? writer?
08:00:11 <tempname11_> athan: how about... the State monad? :)
08:00:30 <athan> That's what I'm thinking, except I need one thing - I need to preserve ordering, if that makes sense
08:00:48 <enthropy> what about writer reorders things?
08:00:49 <athan> so the accumulator should be well ordered (and probably unique)
08:00:49 <jmcarthur> that is already ensured, no?
08:01:03 <jmcarthur> could you explain what you *really* need?
08:01:24 <athan> jmcarthur: It's a bit difficult to explain haha
08:01:56 <jmcarthur> so far nothing you have said is different from State acc, Writer acc, or even ReaderT (IORef acc) IO.
08:01:59 <athan> I'll look into the writer monad for a bit, but I don't think that `put` would keep ordering, would it?
08:02:09 <jmcarthur> what do you mean by keep ordering?
08:02:11 <athan> Could I even have the constraint of `Ord a =>` somewhere in the monad?
08:02:20 <athan> hmm
08:02:48 <athan> So basically, this is for a routing library for WAI
08:03:18 * hackagebot hspec-core 2.1.5 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.5 (SoenkeHahn)
08:03:20 * hackagebot hspec 2.1.5 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.5 (SoenkeHahn)
08:03:23 <athan> I'd like my `get` and `put` etc. functions to have some kind of implicit ordering (representing "likelyness of use")
08:03:50 <enthropy> does this mean your state is a Map Priority Thingy?
08:04:00 <jmcarthur> was going to say the same thing enthropy just said
08:04:29 <athan> so if I did `main = do {put undefined; get undefined}`, then the GET response would actually be >= PUT in the result (to mimic likeleness of responses, PUT requests aren't as common as GET requests)
08:04:43 <athan> enthropy: I think so
08:04:53 <athan> Wait, yes it is :p
08:05:01 <jmcarthur> State (Map Priority Thingy)
08:05:16 <athan> Could I just make `put` do a sorted insertion?
08:05:43 <jmcarthur> write your own wrapper around State with your own primitive operations, which internally use put and get
08:06:15 <athan> jmcarthur: Alrgiht I'll give it a go, thank you!
08:10:00 <SrPx> What is the meaning of the 5th line here? http://lpaste.net/128149 I don't recognize this syntax
08:14:22 <dmj`> SrPx: it's the -XRecursiveDo extension
08:14:28 <dmj`> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#recursive-do-notation
08:15:57 <safinaskar> how to get list of modules in my installation of haskell? (i use ghc on gnu/linux debian)
08:17:11 <Welkin> cabal list --installed
08:17:17 <Welkin> or, ghc-pkg list
08:18:35 <jdnavarro> I know it's a bad idea in general, but is there any easy way to append a value to a tuple? perhaps with some `lens` trickery?
08:19:10 <Welkin> that changes the type
08:19:25 <Welkin> (a, a) is not the same as (a, a, a)
08:19:43 <Iceland_jack> jdnavarro: Do you mean something like
08:19:43 <Iceland_jack>     function :: a -> (b, c) -> (a, b, c)
08:19:43 <Iceland_jack>  
08:19:57 <SrPx> dmj`: thanks !
08:20:02 <jdnavarro> Iceland_jack: exactly
08:20:33 <Iceland_jack> Could you model them inductively instead? I.e.
08:20:33 <Iceland_jack>     (a, (b, (c, d))) instead of (a, b, c, d)
08:20:46 <jdnavarro> Iceland_jack: well, the 2 argument could be a tuple of size up to 4
08:20:48 <SrPx> again, if anyone here knows any efficient/optimal untyped lambda calculus evaluator please let me know :(
08:21:09 <Iceland_jack> jdnavarro: Then the function would simply be
08:21:09 <Iceland_jack> :t (,) ∷ a -> (b, c) -> (a, (b, c))
08:21:10 <jdnavarro> like (a,b) or (a,b,c) or (a,b,c,d)
08:21:10 <lambdabot> a -> (b, c) -> (a, (b, c))
08:22:22 <Iceland_jack> jdnavarro: And then you've basically reinvented
08:22:22 <Iceland_jack>     data HList xs where
08:22:22 <Iceland_jack>       Nil  ::                  HList '[]
08:22:22 <Iceland_jack>       Cons :: x -> HList xs -> HList (x ': xs)
08:22:50 <Elite6809> R&K?
08:22:54 <Elite6809> oops never mind
08:23:20 <jdnavarro> Iceland_jack: yeah... I was trying to get around using heterogeneous lists but I guess I'll have to look into it, thanks!
08:23:38 <Iceland_jack>     Cons True (Cons 'a' Nil) :: HList '[Bool, Char]
08:23:38 <Iceland_jack> versus
08:23:38 <Iceland_jack>     (True, 'a')              :: (Bool, Char)
08:23:48 <Iceland_jack> Not as pretty
08:24:06 <Iceland_jack> But because it's inductive, manipulating it will be much simpler
08:27:44 <kuribas> Why is # |(x -> y)| = # |(y)| ^ # |(x)| ?  at Page 49 http://people.cs.kuleuven.be/~tom.schrijvers/Research/talks/lhug1.pdf
08:28:18 <kuribas> This is the number of functions from x to y?
08:30:27 <Saizan> yeah
08:32:44 <kuribas> Hm, I think I get it...
08:33:34 <kuribas> Assuming only total functions.
08:35:18 <echo-area> Are `map f xs` and `[y | x <- xs, y <- f x]` the same?  I want to define (>>+) for Monad [] as `xs >>= f = map f xs`, is it correct?
08:36:19 <echo-area> The generator definition is what is defined in GHC's Base.hs.
08:36:36 <kuribas> map f xs is [f x | x <- xs]
08:36:41 <athan> echo-area: what's the type of `f`? Something like `f :: a -> b`?
08:36:51 <athan> it doesn't look like `f :: a -> [b]`
08:37:32 <echo-area> Oh...  I didn't notice it.  Thank you both
08:38:09 <kuribas> or [y | x <- xs, let y = f x]
08:39:12 <athan> :)
08:40:36 <detrumi> Hi, can someone help me with a cabal problem? I've got a simple test-suite set up, and it works when calling it from ghci, but it just fails when calling 'cabal test'.
08:40:41 <lpaste> detrumi pasted “Failing test suite” at http://lpaste.net/128150
08:44:50 <athan> detrumi: Is there any more info in the log?
08:44:57 <detrumi> Nope, that's it
08:45:13 <detrumi> That's mainly why I'm stuck: I don't know what's going wrong
08:49:20 <athan> hmm. I've always had some issues with hspec. Maybe looking at this code might help: https://github.com/fujimura/hi-hspec
08:49:21 <supki> detrumi: what happens if you run the test manually? e.g. ./dist/build/test-NAME/test-NAME
08:52:04 <detrumi> supki: Getting a 'permission denied' then
08:52:10 <Welkin> https://twitter.com/aisamanra/status/579040253169668096
08:52:16 <Welkin> that is very hard to read
08:52:47 <Welkin> using hieroglyphics for programming
08:55:18 <supki> detrumi: is the execute permission set for the file?
08:55:43 <detrumi> Yes, it is
08:55:45 <Beardful> Why shouldn't i generate Game of Life  with lists? I was told that's a bad idea, but why?
08:57:02 <Welkin> Beardful: if you want to use a list for storage and manipulation of data, you probably want a Sequence instead
08:57:07 <Welkin> it has better access time
08:57:09 <dmj`> Beardful: lists in haskell are linked lists, so traversals are linear time complexity, game of life would require constant time lookups
08:57:14 <Welkin> lists are better suited as control structures
08:57:15 <supki> detrumi: uhm, that's weird, maybe you have your filesystem mounted with noexec?
08:58:24 <hughfdjackson> morning all :) 
08:58:29 <detrumi> supki: Hmm, I'll look into that then
08:58:50 <hughfdjackson> I've found myself writing a `convertEither` function in two of my haskell projects - so i can use Either easily in the context of the IO monad
08:59:42 <hughfdjackson> e.g. `convertEither :: (Monad m, Show a) => Either a b -> m b`, where the Left result is `fail $ show a` and the Right one is handled as `return b`
08:59:59 <hughfdjackson> i've looked in hoogle, and couldn't find an equivalent.. 
09:00:03 <hughfdjackson> am i missing something? 
09:00:08 <Welkin> why would you want to fail?
09:00:18 <Welkin> failing on user input is a bad idea
09:00:46 <hughfdjackson> Welkin: i'm making a couple of command-line utils
09:00:50 <hughfdjackson> one compiler for a toy language
09:01:01 <hughfdjackson> another a basic OCR program for typewritten content
09:01:07 <dmj`> hughfdjackson: Why not use an EitherT s m a ? with IO as m
09:01:38 <detrumi> supki: Ah, that was it! Thanks, I've been having more problems thanks to that
09:01:56 <hughfdjackson> lots of the code there is in the IO monad (for file fetching, etc) - and i want to use the parsing / ocr functions in that context easily
09:02:18 <Welkin> pull as much as possible out of IO and put it in pure functions
09:02:22 <hughfdjackson> dmj`: hrm - i don't actually need to use the IO monad inside the either - unless there's something i'm missing
09:02:49 <hughfdjackson> Welkin: i believe that i have - although i might be missing something
09:02:53 <hughfdjackson> here's an example of the usage: https://github.com/hughfdjackson/runt-lang/blob/master/src/Main.hs#L20-L21
09:03:31 <hughfdjackson> there I'm parsing a string (which may fail), then piping it through a pure compilation step, then evaluating it using `readProcess` to invoke the node program
09:03:39 <hexagoxel> raek: the library's name is the package name
09:04:05 <hughfdjackson> how else would it be idiomatic to 'unwrap' the parse result from the Either to use it with the later IO actions?
09:04:45 <hughfdjackson> :D I feel like maybe i'm missing some basic haskell idiom
09:04:57 <dmj`> @typ either handleLeft handleRight =<< (\xs -> if null xs then Left "boo" else Right xs) <$> (return "hey" :: Identity String))
09:04:58 <lambdabot> parse error on input ‘)’
09:05:13 <dmj`> hughfdjackson: the either function is handy
09:05:36 <hughfdjackson> dmj`: oh, great :) that makes sense!
09:06:23 <hughfdjackson> thanks
09:06:25 <dmj`> if you had a function f that returned IO (Either a b), you could either handleError handleSuccess =<< f, where handleError :: b -> IO (), handleSuccess :: a -> IO ()
09:06:35 <dmj`> hughfdjackson: np
09:06:59 <dmj`> er :: IO c
09:09:48 <hughfdjackson> :# hopefully without being annoying, there's another question that i haven't been able to find the answer to 
09:10:14 <hughfdjackson> i've made a .pgm parser to use with the friday image processing library
09:10:35 <hughfdjackson> i'm using attoparsec internally - but if someone requires my library as a dependency then we might end up in cabal hell..
09:11:04 <hughfdjackson> is there any way to 'sandbox' or 'hide' my dependency on attoparsec, so that my library uses its version of attoparsec, and the users' code uses whatever version they require? 
09:12:07 <safinaskar> Welkin: no, i want list of modules (i. e. list of things i can include), not packages. and i have no cabal
09:12:08 <dmj`> hughfdjackson: did you modify your version of attoparsec so that it's different from the original?
09:12:30 <dmj`> hughfdjackson: why do you think dep. hell will occur
09:12:46 <hughfdjackson> dmj`: if a user wants to use my library, but wants to also use attoparsec (or use a second library that does use attoparsec)
09:12:51 <hughfdjackson> then there might be a conflict
09:12:56 <hughfdjackson> so far, in my stack, only i use attoparsec
09:13:22 * hackagebot unfoldable 0.8.2 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.8.2 (SjoerdVisscher)
09:13:58 <athan> Is there a monoid-rose-tree librariy? Where the tree looks something like `RTree (NonEmpty w, [a])`, and you can "normalize" the tree into a list where every `w` is a singleton, and the duplicate tags for children are merged?
09:14:28 <athan> If not I'll make it :p
09:14:31 <dmj`> hughfdjackson: a conflict because you export similar types to attoparsec, or a conflict becasue you depend on a different (older?) version of attorparsec, and your assumption is that most users will use a different version?
09:14:51 <hughfdjackson> dmj`: conflict because we depend on different versions
09:15:40 <hughfdjackson> and not assuming they will, but most of my work happens in either node.js or scala
09:16:09 <hughfdjackson> in node.js we don't have a problem with upgrades or our libraries sharing dependencies - because all dependnecies have their own dependencies sandboxed
09:16:26 <dmj`> hughfdjackson: you can use flags in your cabal file based on the version number of attoparsec to define CPP flags which can be referenced in your code, so you can have specifc blocks that will be used when specifc packages are specified. But normally it shouldn't be too much of an issue. 
09:16:29 <hughfdjackson> in scala, you get quite a lot of bitrot and incompatibility because libraries share their dependencies
09:16:41 <hughfdjackson> i'm keen to avoid the scala situation if there's a way to do it with cabal 
09:16:59 <dmj`> hughfdjackson: it sounds like a premature optimization.
09:17:58 <hughfdjackson> dmj`: hrm - if that's the solution available, then i'd agree that it's not good to go down
09:20:17 <osa1> any criterion maintainers here?
09:20:51 <dmj`> hughfdjackson: it's rarely a problem, package maintainers use cpp flags to ensure their package is compatible on windows. Just ensure you abide by the PVP. You can know for sure up to a package version that an api will be consistent if you abide by the PVP
09:21:56 <hughfdjackson> dmj`: I'll be sure to check out the PVP document again :) 
09:22:20 <hughfdjackson> (although I do feel quite strongly that the ability to sandbox your dependencies has a magical effect on reusability)
09:22:34 <dmj`> hughfdjackson: agreed
09:24:59 <safinaskar> > 0
09:25:00 <lambdabot>  0
09:26:23 <safinaskar> data GlobalCtx = GlobalCtx { gctxSimpleTypes :: Data.Set.Set String }; typeIdent :: GlobalCtx -> String -> (); typeIdent { gctxSimpleTypes = sts } ident = ()
09:26:30 <safinaskar> why this code doesn't compile?
09:26:43 <OutlawStar> does anyone know how I might get the current tag of the active workspace in xmonad?
09:26:48 <safinaskar> ghc says: Parse error in pattern: typeIdent {gctxSimpleTypes = sts}
09:31:45 <EvanR> im having trouble separating out my types, my operations, and my instances because the operations require the instances, and the instances are defined in terms of the operations ...
09:32:03 <EvanR> im fine with putting everything in the same module, but its a lot of operations
09:32:23 <EvanR> when i start putting what i need in the module with instances, it kind of snowballs
09:33:32 <hughfdjackson> safinaskar: are you in the context of the repl? 
09:33:37 <EvanR> i guess i need to make a clear distinction which operations are higher level and which are lower
09:33:54 <hughfdjackson> oh, sorry :# misread
09:34:32 <safinaskar> hughfdjackson: no, not in repl. file
09:34:41 <safinaskar> hughfdjackson: i already found
09:35:00 <safinaskar> hughfdjackson: "GlobalCtx {...}" should be instead of just "{...}"
09:35:41 <hughfdjackson> safinaskar: aah - makes sense :) 
09:35:53 <athan> EvanR: I always do :\
09:36:27 <EvanR> alright
09:37:09 <athan> The way I see it, the class' operations should be independent of other things
09:37:31 <EvanR> well
09:37:43 <EvanR> my Comonad extract uses a non trivial algorithm
09:37:50 <EvanR> which takes up a whole file ;)
09:38:20 <EvanR> so its all going in one file
09:38:30 <EvanR> to avoid orphans
09:39:18 * athan pretends he knows what's going on
09:39:22 <athan> Yes yes, I see
09:40:28 <albel727> Hey, guys. A question unrelated to Haskell, but you here are more likely to know the answer. There was some experimental language that used labels like "io" and "memory" on functions, if they or someone in their callgraph did io/allocated memory. Does anyone remember what was it called, or in which paper I might have read about it?
09:49:18 <geekosaur> albel727, I think there are several such? what immediately comes to mind for me though is http://math.andrej.com/eff/
09:53:10 <albel727> Alas, that's not the one I had in mind. It was more imperative-y. Thanks anyway.
10:58:14 <breadmonster> Is there a parsec instance for text?
10:58:18 <breadmonster> Or rather Data.Text?
10:58:26 <breadmonster> Or at least, is Data.Text a stream class?
10:59:09 <EvanR> Text.Parsec.Text
10:59:22 <EvanR> type Parser = Parsec Text ()
10:59:59 <breadmonster> EvanR: Oh, okay, I didn't see that, I think I was looking at Parsec 2.
11:00:32 <osa1> any ideas what is this mkReadme executable generated by cabal in .cabal-sandbox/bin? that's certainly not related with my package
11:01:05 <glguy> osa1: One of your dependencies must have an executable that it builds
11:01:18 <osa1> but why executable parts of dependencies are installed?
11:06:48 <livingBEEF> Is there any way to test Num for being zero? Like isZero or something. Num apparently does not guarantee that there's fromIntegral function for the type...
11:07:18 <EvanR> :t (== 0)
11:07:19 <lambdabot> (Num a, Eq a) => a -> Bool
11:07:51 <livingBEEF> oh, so 0 is universal?
11:07:52 <EvanR> you dont need Eq though
11:08:16 <EvanR> you can pattern match on 0 and give a True False
11:08:31 <EvanR> :t 0
11:08:32 <lambdabot> Num a => a
11:08:33 <mauke> EvanR: try it
11:08:43 <EvanR> uh oh
11:08:58 <livingBEEF> well... that was half an hour spent for nothing... for some reason I thought 0 is only Int/Integer
11:09:07 <Iceland_jack> :t let isZero 0 = True; isZero n = False in isZero
11:09:08 <lambdabot> (Num a, Eq a) => a -> Bool
11:09:14 <EvanR> :t (\x -> case x of 0 -> True; _ -> False)
11:09:15 <lambdabot> (Num a, Eq a) => a -> Bool
11:09:21 <barrucadu> livingBEEF: Integer literals in Haskell are overloaded, 0 == fromInteger 0, 1 == fromInteger 1, etc
11:09:24 <barrucadu> :t fromInteger
11:09:25 <lambdabot> Num a => Integer -> a
11:09:51 <Iceland_jack> I guess lambdabot doesn't support LambdaCase but (\case 0 → True; n → False)
11:09:58 <EvanR> works!
11:10:17 <mauke> EvanR: it's exactly equivalent to (== 0)
11:10:27 <livingBEEF> good to know
11:10:29 <livingBEEF> thanks
11:11:00 <EvanR> mauke: oh dang
11:11:22 <EvanR> pattern match induces an Eq constraint :S
11:13:41 <livingBEEF> Num does require Eq though, so that's not really a problem...
11:13:51 <mauke> Num doesn't require Eq
11:13:53 <Iceland_jack> livingBEEF: No it doesn't
11:13:58 <Iceland_jack> not anymore in GHC
11:14:14 <livingBEEF> I must have old info then
11:14:15 <EvanR> random bad quality png's disagree, and its annoying
11:14:47 <Iceland_jack> livingBEEF: http://stackoverflow.com/questions/27561604/why-i-get-the-class-num-a-where-instead-of-the-class-eq-a-show-a-num-a
11:14:57 <livingBEEF> good thing I'm working with (Num a, Ord a) then :3
11:15:55 <EvanR> :t toInteger
11:15:57 <lambdabot> Integral a => a -> Integer
11:16:06 <EvanR> so you either need Eq or Integral
11:29:16 <kuribas> Wasn't there a program that can write a function definition from a type?
11:29:49 <EvanR> @djinn a -> b -> b
11:29:50 <lambdabot> f _ a = a
11:30:09 <kuribas> Can I use djinn on my own code?
11:30:14 <HeladoDeBrownie> sometimes
11:30:20 <HeladoDeBrownie> it doesn't recognize many common types, like []
11:30:37 <kuribas> For example solving the exercises: https://bitbucket.org/tom_schrijvers/leuven-haskell-user-group/raw/f30cd6213d47539a052fc30c1fb38913a8887139/Meeting1.hs
11:30:39 <joneshf-laptop> did 7.10 come out?
11:30:56 <HeladoDeBrownie> i doubt it will be of much help there
11:31:24 <kuribas> The function definition follows completely from the type.
11:31:48 <kuribas> So I thought there might be an automated program that does just that :)
11:31:57 <mauke> kuribas: oleg has done it as a library
11:32:29 <mauke> http://okmij.org/ftp/Haskell/types.html#de-typechecker
11:33:28 * hackagebot process-extras 0.3.3.3 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.3.3 (DavidFox)
11:34:23 <kuribas> mauke: great thanks!
11:36:26 <kuribas> mauke: Although it will probably choke on the type extensions...
11:41:30 <Beardful> Are functional lenses a special thing for Haskell ?
11:41:56 <HeladoDeBrownie> what does "special" mean here?
11:42:34 <Beardful> That the idea of lens is used only in Haskell
11:42:50 <Beardful> The right word would be specific
11:42:52 <HeladoDeBrownie> i don't think that's quite true, although i think it is more of a statically typed functional thing
11:43:06 <Cale> Beardful: You could use the idea in other languages.
11:43:37 <Cale> Though the 'lens' library specifically would be almost impossible to implement in anything other than Haskell right now, due to the heavy use of type classes.
11:44:19 <Cale> You could implement lenses in another way and make it work in essentially any language with first class functions though.
11:45:15 <HeladoDeBrownie> there's a less powerful sort of lens you can make more easily, where a lens is a record of getter and setter
11:45:21 <HeladoDeBrownie> that should be realizable in more languages i think
11:45:45 <Cale> That type of lens is equally powerful if you want it to be
11:46:04 <Cale> (though you're probably thinking of the variation with only two type parameters)
11:46:19 <HeladoDeBrownie> well, i suppose i meant "harder to compose"?
11:46:21 <breadmonster> Cale: Can you get segfaults in Haskell?
11:46:32 <breadmonster> Or does the type system guarantee that they won't exist?
11:46:34 <Cale> breadmonster: If you use the FFI, or there is a bug in the compiler.
11:46:53 <HeladoDeBrownie> also if you use unsafe primitives, like unsafeCoerce, right?
11:47:01 <Cale> yeah
11:47:26 <joneshf-laptop> how does the `-C` flag of ghc work?
11:47:37 <Cale> ghci> :m + Foreign
11:47:37 <Cale> ghci> peek nullPtr
11:47:37 <Cale> Segmentation fault
11:47:43 <joneshf-laptop> i can't seem to get the c output with a simple file
11:47:51 <joneshf-laptop> i'm running: `ghc -C hello.hs`
11:48:16 <monochrom> does -C even mean "output C code"?!
11:48:16 <joneshf-laptop> the other flags seem to work
11:48:26 <joneshf-laptop> `-E` and `-S`
11:48:27 <Cale> joneshf-laptop: Are you compiling via C?
11:48:35 <Cale> Well, you won't be
11:48:39 <joneshf-laptop> Cale, i dunno
11:48:46 <Cale> if those are your only commandline flags
11:48:50 <arielsanflo> hello
11:48:54 <arielsanflo> help 
11:49:00 <arielsanflo> function reverse
11:49:03 <arielsanflo> ?
11:49:10 <Iceland_jack> :t reverse
11:49:11 <lambdabot> [a] -> [a]
11:49:13 <HeladoDeBrownie> arielsanflo, can you phrase that as a question?
11:49:18 <arielsanflo> prelude
11:49:22 <Iceland_jack> arielsanflo: Are you looking for that function?
11:49:23 <Cale> joneshf-laptop: try adding -fvia-C
11:49:30 <porglezo1p> :k reverse
11:49:31 <lambdabot> Not in scope: type variable ‘reverse’
11:49:36 <arielsanflo> mi english is so so
11:49:38 <porglezo1p> I don't know how to use that
11:49:42 <HeladoDeBrownie> arielsanflo, what's your native language?
11:49:44 <Cale> joneshf-laptop: Note that the C code which will be emitted won't actually work if compiled by anything that's not GHC
11:49:48 <arielsanflo> yes
11:49:53 <kuribas> How does void work in djinn?
11:49:57 <Cale> joneshf-laptop: The resulting assembly needs to be mangled to actually function
11:50:08 <Iceland_jack> > reverse "Example."
11:50:10 <lambdabot>  ".elpmaxE"
11:50:13 <joneshf-laptop> Cale, same error, but also a warning about `-fvia-C` being deprecated soon
11:50:18 <kuribas> @djinn x :: (Either x Void) -> x
11:50:18 <lambdabot> Cannot parse command
11:50:38 <kuribas> @djinn x (Either x Void) -> x
11:50:38 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 3),KVar 0)
11:50:45 <HeladoDeBrownie> arielsanflo, ¿acaso hablas español? yo sí
11:50:46 <kuribas> @djinn (Either x Void) -> x
11:50:46 <lambdabot> f a =
11:50:46 <lambdabot>     case a of
11:50:46 <lambdabot>     Left b -> b
11:50:46 <lambdabot>     Right c -> void c
11:50:51 <arielsanflo> si
11:50:53 <arielsanflo> gracias 
11:50:57 <kuribas> :t void
11:50:58 <lambdabot> Functor f => f a -> f ()
11:51:05 <HeladoDeBrownie> arielsanflo, puedo traducir, ¿qué necesitas?
11:51:09 <arielsanflo> necesito todas las funciones de el porelude
11:51:12 <arielsanflo> para listas
11:51:19 <sternenseemann> what does one want to use instead of ghc-mod as soon as the cabal version gets too new?
11:51:20 <arielsanflo> ejemplo
11:51:23 <HeladoDeBrownie> arielsanflo is looking for all functions in the prelude involving lists.
11:51:24 <Cale> joneshf-laptop: I'm not even sure compiling via C is still actually a thing. Maybe the flag is present but just gets ignored
11:51:26 <arielsanflo> invertir una nlista
11:51:32 <sternenseemann> I espacially need vim-integration
11:51:38 <Cale> joneshf-laptop: Probably the -C flag is just a remnant in the documentation.
11:51:45 <arielsanflo> gracias
11:51:50 <arielsanflo> por la ayuda
11:52:14 <arielsanflo> fine thanks 
11:52:31 <Cale> joneshf-laptop: The usual compilation path compiles via Core to Cmm and then to machine code.
11:52:44 <porglezo1p> I'm trying to install Haskell on my raspberry pi 2 (an up-to-date version) and I'm running into "Template Haskell splice illegal in a stage-1 compiler." while trying to install alex
11:52:51 <porglezo1p> What does that mean?
11:52:54 <HeladoDeBrownie> arielsanflo, hay un montón en Data.List (there are several in Data.List)
11:52:54 <joneshf-laptop> Cale, i see
11:53:08 <arielsanflo> yes 
11:53:10 <porglezo1p> Or actually, that's while installing QuickCheck
11:53:16 <arielsanflo> in english
11:53:22 <Cale> porglezo1p: Finish compiling GHC?
11:53:29 <arielsanflo> no speack inglis
11:54:10 <HeladoDeBrownie> arielsanflo, ¿es que no sabes averiguar qué hacen? (Is it that you don't know how to find out what they do?)
11:54:15 <Cale> porglezo1p: Or wait, which architecture is that?
11:54:40 <porglezo1p> armv7l
11:55:27 <michaelt> arielsanflo: http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-List.html 
11:55:29 <porglezo1p> Cale, I have GHC 7.4.1 + cabal 1.14, I'm trying to update it
11:55:34 <Cale> porglezo1p: Oh, okay, so the problem is that the ARM support is limited.
11:55:37 <arielsanflo> fine thanks
11:56:10 <porglezo1p> There are guides on compiling it
11:56:13 <Cale> porglezo1p: Do you really need to build alex or QuickCheck?
11:56:15 <arielsanflo> reverse [1,2,3,4, 5,6,7] 
11:56:36 <michaelt> > reverse [1,2,3,4, 5,6,7]
11:56:37 <lambdabot>  [7,6,5,4,3,2,1]
11:56:38 <arielsanflo> [7,6,5,4,3,2,1]
11:56:45 <arielsanflo> ?
11:56:46 <Cale> porglezo1p: If you really needed alex, you could just run it on another computer and copy the resulting code over
11:56:49 <arielsanflo> how
11:56:56 <porglezo1p> Cale: I'm not sure why I'm installing them honestly, it's part of the guide.
11:56:58 <HeladoDeBrownie> arielsanflo, ¿cuál es la pregunta? (What's the question?)
11:57:04 <porglezo1p> I'll try skipping that
11:57:07 <arielsanflo> como lo hace internamente
11:57:08 <Cale> porglezo1p: but I think the source actually comes with the precompiled lexer and parser
11:57:15 <arielsanflo> reverse como funciona
11:57:16 <arielsanflo> ?
11:57:21 <michaelt> arielsanflo: '>' tells the irc to ask 'lambdabot'
11:57:26 <Cale> porglezo1p: So you shouldn't need alex or happy unless you're actually modifying the lexer or parser.
11:57:39 <HeladoDeBrownie> arielsanflo, ah, quieres ver la deficinición? un momento. (ah, you want to see the definition? one moment.)
11:57:47 <michaelt> @src reverse 
11:57:47 <lambdabot> Source not found. Sorry.
11:57:48 <HeladoDeBrownie> @src reverse
11:57:48 <lambdabot> reverse = foldl (flip (:)) []
11:57:48 <porglezo1p> This guide is working from the git repo, so they might not include them
11:58:00 <HeladoDeBrownie> arielsanflo, ahí está (there it is)
11:58:07 <Cale> hmm
11:58:21 <HeladoDeBrownie> definición*
11:58:21 <porglezo1p> There's dumb linker issues that are apparently fixed in 7.8
11:58:23 <Cale> go to compiler/parser/ and see if Parser.hs and Lexer.hs exist
11:58:28 <porglezo1p> But I don't get the fixes until I update
11:58:42 <arielsanflo> fine thanks
11:58:47 <HeladoDeBrownie> arielsanflo, ¿la entiendes? (do you understand it?)
11:58:51 <HeladoDeBrownie> puedo explicar (i can explain)
11:58:52 <arielsanflo> yes
11:58:55 <HeladoDeBrownie> okay
11:59:13 <arielsanflo> helado fine thaks
11:59:20 <HeladoDeBrownie> arielsanflo, ¿necesitabas algo más? (did you need anything else?)
11:59:26 <arielsanflo> yes
11:59:29 <arielsanflo> esperame 
11:59:33 <HeladoDeBrownie> vale
11:59:35 <arielsanflo> un segundo
11:59:37 <porglezo1p> Just a moment, it's downloading stuff
11:59:40 <arielsanflo> la estoy realizando
11:59:55 <arielsanflo> es que son muchos ejercicios
12:00:12 <arielsanflo> la idea es hacerlo desde el nivel mas alto
12:00:16 <arielsanflo> me entiendes
12:00:28 <HeladoDeBrownie> explica.
12:00:28 <arielsanflo> sin funciones predeterminadas
12:00:34 <arielsanflo> osea mira
12:00:40 <HeladoDeBrownie> ah, quieres hacerlo desde cero (ah, you want to do it from scratch)
12:00:47 <arielsanflo> ongitud :: (Num b) => [a] -> b
12:00:47 <arielsanflo> longitud    []       = 0
12:00:47 <arielsanflo> longitud     (_:xs)     = 1 + longitud xs
12:01:04 <arielsanflo> ese la longitu de un vector
12:01:15 <arielsanflo> me explique bien?
12:01:29 <HeladoDeBrownie> ¿qué es lo que quieres hacer con eso? (what is it you want to do with that?)
12:01:34 <arielsanflo> si
12:01:42 <HeladoDeBrownie> ¿qué?
12:01:46 <arielsanflo> asi tengo que hacer todas las demas
12:01:49 <HeladoDeBrownie> ah
12:02:08 <HeladoDeBrownie> ¿sólo usando la recursión? (just with recursion?)
12:02:12 <arielsanflo> es sin funciones predetermindas en haskell
12:02:18 <arielsanflo> si
12:02:20 <HeladoDeBrownie> ya veo. (i see)
12:02:20 <arielsanflo> eso
12:02:21 <arielsanflo> excato
12:02:28 <arielsanflo> ejemplo
12:02:30 <HeladoDeBrownie> arielsanflo is trying to implement some things without using existing library functions
12:02:34 <arielsanflo> concatenar dos vectore
12:02:59 <michaelt> reverse [] = []; reverse (s:xs) = ???
12:03:04 <HeladoDeBrownie> arielsanflo, vamos a #haskell-overflow, que es más adecuado (let's go to #haskell-overflow, which is more appropriate)
12:07:59 <kuribas> is "x (Left a) = a; x :: Either a Void" a total function?
12:08:14 <kuribas> where Void has no constructors.
12:09:49 <Peaker> kuribas: x is of type Either a Void, or x is a function?
12:10:16 <kuribas> Peaker: right...
12:10:27 <kuribas> is "x :: Either a Void -> a"
12:11:20 <kuribas> Since Void has no constructors, "Right v" cannot exist...
12:11:34 <Peaker> kuribas: it is a total function if you ignore (Right _|_) (which is not _|_)
12:12:07 <monochrom> in Haskell, "Right v" can exist even when "v" doesn't.
12:12:28 <Peaker> Bottoms are such a mess :-(
12:12:33 <monochrom> but you can say your program doesn't use all of Haskell, only a total subset.
12:13:06 <monochrom> at the end of the day, x is total iff you call it total.
12:13:12 <kuribas> Is it mathematically total?  (I guess yes?)
12:13:40 <kuribas> monochrom: total means it is defined for all the possible input arguments right?
12:13:41 <monochrom> mathematically, x is total iff you adopt a set of definitions that calls it total.
12:14:01 <monochrom> but it is still in your hand what are "all the possible inputs"
12:14:19 <monochrom> mathematically, everything varies according to your definitions.
12:14:59 <monochrom> there is no Platonic astral plane of handed-down definitions that everyone must adopt without thinking.
12:15:17 <kuribas> monochrom: mathematically, bottom is not part of the domain?
12:15:19 <monochrom> you think for yourself and choose your definitions to suit your needs.
12:15:28 <kuribas> right
12:15:35 <EvanR> you can include bottom or not 
12:15:40 <monochrom> mathematically, bottom is or is not part of the domain depending on which domain you choose.
12:15:41 <arw_> monochrom: mathematically something is always "total on $domain"
12:15:46 <porglezo1p> Cale: The git repo only has Lexer.x and Parser.y
12:15:57 <arw_> monochrom: total without that addition is pointless. 
12:16:05 <EvanR> arw_: the fact that there is such a term as "total" means that sometimes thats not the case
12:16:07 <Peaker> kuribas: in Haskell, "_|_" contains no information, whereas "Right _|_" does contain information (it's not a Left!)
12:16:14 <monochrom> yes, what arw_ says
12:16:31 <Peaker> kuribas: so (Right _|_) is not _|_. So whether it is considered an interesting case you must handle to be total or not is indeed just a matter of definition
12:16:32 <porglezo1p> Cale: But perhaps I can run this on a source tarball
12:16:38 <Cale> porglezo1p: Oh, okay, so you'll probably have to compile those on another machine and copy over the results (which should be arch independent)
12:16:39 * simukis_ gifts people unicode. take this: ⊥
12:16:43 <EvanR> haha
12:16:44 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
12:16:50 <threestrikes> If I'm at the ghci prompt and I've written a couple of functions that I'm currently using.  Is there a way to display the code I used to create the function if I forget what I've written?
12:17:12 <Peaker> in Haskell, you can even be total in the domain that includes _|_, so indeed you must qualify $domain
12:17:35 <monochrom> people hate me because they don't want to accept the cold hard truth "you can vary your definitions" but I keep telling it to them.
12:17:36 <Cale> threestrikes: No. This is why you should keep a separate window open with your text editor to put definitions in. :)
12:17:57 <porglezo1p> Cale: I'm going to try from a tarball again
12:18:00 <monochrom> they want some tyrant to tell them rules.
12:18:13 <threestrikes> :P ohh well lol thanks
12:18:22 <Cale> threestrikes: It would be kind of nice to have that feature, but people don't tend to write a lot of code at the ghci prompt... then again, maybe that's a self-fulfilling prophecy
12:18:23 <monochrom> they want some tyrant to tell them "indent by 4 spaces"
12:18:32 <kuribas> monochrom: commonly agreed definitions can be very usefull for discussions :)
12:18:42 <monochrom> they want some tyrant to tell them what to make lazy and what to make eager.
12:18:53 <Cale> threestrikes: If you load a file in ghci, :r will reload it
12:19:10 <monochrom> they want some tyrant to do their work and they take the money.
12:19:14 <kuribas> monochrom: you are wrong, it is 8 spaces: https://www.kernel.org/doc/Documentation/CodingStyle
12:19:15 <hiptobecubic> threestrikes, you can push up arrow a bunch to see what you've entered recently
12:19:21 <Cale> oh, right, that's true
12:19:31 <Cale> There is the line edit history at least
12:19:37 <threestrikes> great idea 
12:19:48 <hiptobecubic> ctrl+r  will let you search it (these are standard readline features)
12:20:09 <monochrom> they exploit and rip off tyrants. Tyrants of the world, unite and revolt against this suppression!
12:20:23 <monochrom> err, oppression!
12:20:49 <threestrikes> thanks for the tips 
12:21:41 <monochrom> anyway, I have already said, in Haskell, "Right v" can exist even when "v" doesn't.
12:22:28 <monochrom> if you're interested in a commonly agreed definition, then use mine, it belongs to Haskell 2010.
12:22:56 <monochrom> the only problem is that it gives answers you don't want to hear. what to do now?
12:27:59 <kuribas> monochrom: so, according to Haskell 2010 the function isn't total, right?
12:28:10 <livingBEEF> I can't figure out how to use when truefalse do .... it aways complains, if it's anything longer than oneliner. Is there any way to do that? I could use if-then-else, but I'm not using the "else", so it looks weird.
12:28:16 <arw_> the nice thing about mathematics is, one can often find proof. if that proof doesn't agree with you, you change your major to philosophy or something.
12:28:20 <monochrom> right
12:29:11 <monochrom> arw_: wait a second, that sounds more like a nice thing about going to a university/college that lets you change major...
12:29:19 <kuribas> arw_: in philosophy when science disagrees with you, you invoke quantum mechanics :)
12:29:33 <livingBEEF> I mean the "when :: bool -> ...." thing
12:29:41 <EvanR> in science when philosophy disagrees with you ignore it?
12:30:08 <monochrom> in postmodernism everyone disagrees with each other and still gets along
12:30:49 <arw_> kuribas: yeah, but only works because in philosphy, nobody knows enough QM ;)
12:31:41 <monochrom> livingBEEF: you can add parentheses. when (x>0) (do ...  [10 lines later] )
12:32:14 <monochrom> you can align the open parenthesis with the close parenthesis vertically
12:33:44 <porglezo1p> I think the compile will work this time.
12:33:49 <livingBEEF> oh, I was putting the closing one on line AFTER last line and assumed that's not it. Thanks.
12:34:24 <livingBEEF> instead putting it on the end of last line
12:40:00 <ralu> is there much difference in Aplicative pure vs Monadic return ? 
12:40:34 <MP2E> as of GHC 7.10, they are the same for any Monad. return = pure
12:41:11 <ralu> So that also mean that Monad is Aplicative ?
12:41:32 <monochrom> yes
12:41:42 <MP2E> yep exactly, there's a wiki page on it https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
12:41:43 <ralu> ok thanx
12:44:26 <EvanR> i should be able to take two [a] where Ord a that are both sorted and combine them so the result is sorted lazily right
12:45:29 <EvanR> seems like a "one liner" im missing
12:45:48 <EvanR> where one line in haskell means an expression with three terms
12:46:13 <thetallguy> anyone use -ddump-minimal-imports?  I can't find the output.
12:49:26 <EvanR> merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a], also i feel like im missing some math on this one
12:50:30 <Cale> EvanR: I think I'd just write it recursively.
12:50:42 <EvanR> i wrote the function, now im wondering wth this is
12:50:45 <EvanR> some kind of monoid
12:50:46 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/src/Data-List.html#sort does it recursively
12:51:21 <EvanR> interesting so this is a fragment of a quick sort
12:51:26 <EvanR> or merge sort
12:51:29 <Cale> mergesort
12:51:31 <ReinH> EvanR: Yes, that function is often called "merge" for that reason.
12:51:47 <mauke> merge xs'@(x : xs) ys'@(y : ys) | x <= y = x : merge xs ys' | otherwise = y : merge xs ys'; merge xs ys = xs ++ ys
12:52:04 <ReinH> Or perhaps mergesort is called mergesort because that function is called merge.
12:52:21 <ReinH> It's the kernel of both mergesort and insertion sort :)
12:52:49 <EvanR> lists of this form seem to form their own monoidal type
12:53:09 <ReinH> EvanR: They do.
12:53:29 <ReinH> EvanR: http://stackoverflow.com/questions/28992450/is-this-a-correctly-implemented-mergesort-in-haskell/28994079#28994079
12:53:37 <ReinH> As always, pigworker has some really interesting thing to say about it
12:54:21 <alynn> sorted lists with merge are a free abelian group aren't they?
12:54:50 <alynn> n*k for natural n and each possible value k of that type
12:55:34 <Cale> alynn: yes
12:55:54 <EvanR> sweet
12:56:33 <alynn> Cale: actually no thinking about it, free abelian group would be integer n
12:56:34 <EvanR> copying pigworkers names
12:56:38 <alynn> bah
12:56:43 <alynn> free commutative monoid perhaps
12:57:09 <ReinH> alynn: I was going to ask what the inverse is
12:57:16 <thetallguy> alynn: what would the inverse of
12:57:16 <ReinH> But then I thought you and Cale must be smarter than me so I didn't
12:57:48 <alynn> yeah, I should have thought about it more :P
12:58:15 <Cale> Oh, yeah, free commutative monoid
12:58:48 <Cale> You can make it a group if you throw in formal inverses :)
12:59:08 <ReinH> Cale: formal inverses?
12:59:53 <kaiyin> http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13 Slide 12, the program doesn't compile, what's wrong with it?
13:00:11 <Cale> Like, just tag each element in the list with whether it's positive or negative, and cancel corresponding opposites when you find them.
13:01:07 <Cale> kaiyin: uhhhh
13:01:13 <lpaste> glguy pasted “sorting with merge monoid using lens package” at http://lpaste.net/128164
13:01:15 <Cale> I can't find the code you're referring to
13:01:24 <Cale> kaiyin: Can you just paste it on lpaste.net ?
13:02:04 <glguy> Youd want to balance things better than that does on list, but just wanted to paste the lens version of the things pigworker was writing
13:02:54 <kaiyin> Cale: https://gist.github.com/kindlychung/f43fcde4e869ee75eafe
13:03:32 * hackagebot process-extras 0.3.3.4 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.3.4 (DavidFox)
13:03:59 <Cale> kaiyin: The problem is that you're using do-notation, but Parser is being defined as a type synonym, so you can't write an instance of Monad for it
13:05:04 <kaiyin> ok, I'll try to rewrite it. The lecture is probably a little outdated.
13:05:11 <alynn> type Parser = StateT String [] might be closer to what you want?
13:05:22 <burp> is anyone aware of a fully working/maintained bittorrent client implementation?
13:06:09 <Cale> kaiyin: It's not that it's outdated, this code would never have worked verbatim
13:06:29 <Cale> kaiyin: It's probably just that this is effectively intended as pseudocode
13:06:36 <Cale> He's leaving out some details
13:07:49 <Cale> Oh, not to mention that bind isn't actually defined anywhere there...
13:09:26 <EvanR> i guess merging lists might be a bad priority queue
13:09:50 <EvanR> but it supports infinite
13:10:29 <mauke> I think it's O(n) in the size of the prefix you examine (assuming O(1) comparison)
13:11:14 <EvanR> O(n) dequeue ?
13:11:19 <lpaste> Cale pasted “fixed” at http://lpaste.net/128166
13:11:26 <Cale> kaiyin: ^^
13:13:00 <dreams> How do you :r in ghci without having to redefine everything.
13:13:04 <kaiyin> Cale: thanks!
13:13:13 <dfeuer> ReinH, you mention dealing with functors between categories other than Hask, but you never actually get there. Is that something like class Functor' f c where fmap' :: c a b -> f c a b ?
13:13:15 <hpc> dreams: make definitions in your hs file
13:13:33 * hackagebot cabal-debian 4.24.5 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.24.5 (DavidFox)
13:13:52 <EvanR> O(n) where n is the number of lists that were merged
13:13:59 <Beardful> What do i do if i need "update" from Data.Sequence and "update" from Data.Lenses ?
13:14:00 <dreams> hpc: they're temporary for testing. It would be a pain to keep adding and removing from hs files.
13:14:02 <alynn> dfeuer: edward kmett has a polykinded functor somewhere
13:14:08 <alynn> dfeuer: https://www.youtube.com/watch?v=Klwkt9oJwg0
13:14:42 <Cale> Beardful: import qualified Data.Sequence as Seq
13:15:19 <dfeuer> alynn, the reason to read ReinH's explanation is that edwardk's is written primarily for people who are already intimately familiar with both category theory and fancy Haskell extensions.
13:15:52 <Cale> Beardful: import Data.Sequence (Seq)  -- and possibly some other stuff like (<|) and whatnot
13:16:10 <Cale> Beardful: you can import it twice to import certain things unqualified if you like
13:16:30 <Cale> (especially the type itself, it sucks to have to write Seq.Seq all over)
13:16:38 <alynn> dfeuer: apologies
13:16:48 <Beardful> Cale: Awesome, thanks.
13:17:07 <dfeuer> No problem at all, alynn. I'm just trying to learn step by step.
13:17:58 <RustyShackleford> i'm not sure how to do this. So I have a list of something like ["a", "b" "c"] and ["hey", "hi", "hello"]. I want to get ["a: hey", "b: hi", "c: Hello"
13:18:19 <alynn> :t zipWith
13:18:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:18:27 <alynn> ^ this may be of use to you RustyShackleford
13:18:31 <Cale> RustyShackleford: zipWith (\x y -> concat [x, ": ", y])
13:18:58 <mauke> zipWith (printf" %s: %s") :-)
13:19:10 * alynn vomits just a little bit
13:20:04 <dfeuer> alynn, I did at least manage to find his Functor class from ther.
13:20:15 <RustyShackleford> alright i'll play around with that. Thanks
13:20:22 <RustyShackleford> can i ask, what does the \x do?
13:20:35 <dfeuer> Based on the Category' class.... whew....
13:20:56 <mauke> RustyShackleford: what other programming languages do you know?
13:21:06 <edwardk> dfeuer: the Category', Category'', ... etc. machinery is to work around a bug in GHC's kind inference for polykinds in 7.8
13:21:20 <edwardk> dfeuer: in 7.10 i could consolidate everything back into single classes.
13:21:44 <RustyShackleford> mauke: python, java, c, c++ mostly
13:21:47 <RustyShackleford> a little ruby
13:21:50 <HeladoDeBrownie> RustyShackleford, \x is not a thing by itself; \ introduces an anonymous function, and x and y are its parameters.
13:21:53 <MP2E> Hmm. Hitting a strange bug, I have a simple IRC markov bot I'm working on and I've been using bracket_ to read the chat markov chain on startup, and update the file on shutdown. The issue is that the file gets truncated down to 16 bytes every time if I shut the bot down by running 'exitSuccess' but if I use CTRL+C or have it error out in some way, the file serializes just fine.
13:21:56 <alynn> RustyShackleford: do you know what lambda does in python?
13:22:13 <mauke> RustyShackleford: zip_with(lambda x, y: ...,
13:22:24 <dfeuer> edwardk, that sounds like a good idea :-). It looks like Category' makes the object class explicit somehow? But  type Ob p :: i -> Constraint .... uh ... no idea what that all means.
13:22:29 <dfeuer> I mean, sort of.
13:22:46 <dfeuer> I guess it's expressing as a constraint that something is an object of a certain category?
13:22:57 <RustyShackleford> alynn: no i've never used it
13:23:08 <edwardk> dfeuer: i need the object constraints to be explicit because i need things like "the category of endofunctors" or product categories and sum categories you can't write in haskell with a Category with a capital C out of base.
13:23:35 <edwardk> without explicit knowledge of the objects, you can't write limits/colimits that can rederive products/sums, etc.
13:23:38 <edwardk> they are all too weak
13:23:49 <kaiyin> Cale: http://lpaste.net/128166#line26 what would be the type of x in x <- item?
13:23:51 <alynn> RustyShackleford: "lambda" basically introduces a function without a name
13:23:58 <dfeuer> edwardk, so (vaguely guessing here) the usual Category is approximately recovered using constraints involving ~?
13:24:00 <edwardk> this is what i found when i gave the original Hask talk, so I went and investigated how bad it'd be to "just do it right" and it turned out to be interestingly pleasant
13:24:09 <mauke> RustyShackleford: ok, \ PARAMS -> BODY is a function
13:24:14 <edwardk> the usual category would have Ob p = Trivial
13:24:17 <mauke> RustyShackleford: PARAMS is the list of parameters; BODY is the function body
13:24:21 <edwardk> class Trivial a; instance Trivial a
13:24:24 <RustyShackleford> mauke: what do i search? anonymous function?
13:24:30 <Cale> kaiyin: Char
13:24:35 <HeladoDeBrownie> RustyShackleford, or lambda
13:24:35 <edwardk> no constraints on the objects
13:24:45 <dfeuer> edwardk, oh, okay. I think I sort of see now.
13:24:47 <RustyShackleford> alright i'll do that. Thanks
13:24:49 <alynn> RustyShackleford: in Python, def bees(x): return x + 2 and bees = lambda x: x + 2 are more or less equivalent
13:24:54 <kaiyin> Cale: why? I thought it would be [(Char, String)]
13:24:54 <alynn> if that's any help
13:25:06 <Cale> kaiyin: Whenever you see  v <- x  it means "run the action x and call its result v", so if x is an action of type M a, then v is of type a
13:25:09 <dfeuer> edwardk, can your version also deal with non-full subcategories of Hask?
13:25:49 <xplat> dfeuer: yes, like the category of Things With Enough Structure For a Set Monad
13:25:56 <dfeuer> Also, when do you expect to come up with the 7.10-only version that will hopefully be simpler?
13:25:58 <HeladoDeBrownie> although i use it sometimes, "anonymous function" sounds kind of odd to me for similar reasons to why "anonymous value" might in general.
13:26:07 <Cale> kaiyin: Or, more formally, the desugaring of the do-notation says that:
13:26:29 <Cale> kaiyin: do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
13:26:30 <HeladoDeBrownie> (not all languages have functions as values, which is what makes the distinction useful, i think)
13:26:38 <xplat> dfeuer: 7.10 actually made things harder, not easier.  although that's because some of the easiness came from ... kind of a hack
13:27:00 <Cale> kaiyin: Along with  do { x ; <stmts> } = x >> do { <stmts> }
13:27:07 <Cale> kaiyin: and do { x } = x  as a base case
13:27:08 <edwardk> dfeuer: yes but to model them you build them as their own categories
13:27:20 <xplat> dfeuer: (namely, using Any as a real constructor at arrow kinds)
13:27:25 <edwardk> dfeuer: well, when i replace 7.8 on my working machine with 7.10 i'd guess ;)
13:27:32 <dfeuer> Heh.
13:27:32 <Cale> kaiyin: as well as  do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
13:27:43 <Cale> so for example
13:27:44 <dfeuer> xplat, you're going over my head now, unfortunately.
13:27:53 <edwardk> dfeuer: the main thing that just needs to happen is to move Category', Category'''s constraints up into Category and Functor respectively
13:27:59 <Cale> @undo  do { x <- item ; item ; y <- item ; return (x,y) }
13:27:59 <lambdabot> item >>= \ x -> item >> item >>= \ y -> return (x, y)
13:28:13 <edwardk> so it might be straightforward
13:28:19 <edwardk> we might still need one level of this though
13:28:21 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
13:28:40 <xplat> dfeuer: well, it used to be you could write things like 'Any [] Monad Int' and use them as types or constraints or whatever, and match them in instances or type families
13:28:41 <dfeuer> edwardk, if there's a nice way to do it in Category, could that replace the current Category?
13:28:47 <edwardk> the main thing i'm proud of in that library is it does all of its category theory "curried" (which works for locally small categories)
13:29:02 <edwardk> dfeuer: i wouldn't
13:29:04 <xplat> dfeuer: you can no longer do the 'and match them' part
13:29:08 <kaiyin> Cale: what does >> do?
13:29:12 <Cale> So this is why when the thing on the left of the >>= (equivalently on the right of the <-) has type Parser a, the variable that gets bound (the parameter of the lambda) has type a
13:29:20 <edwardk> this is pretty much its own specialized beast for specialized purposes
13:29:27 <Cale> kaiyin: x >> y = x >>= (\k -> y)
13:29:35 <dfeuer> Ah. OK.
13:29:56 <edwardk> there are several reasonable points in the design space and i value the existing Category's ability to do polymorphic recursion for _haskell_, but i value this one's ability to use Ob for category theory
13:29:58 <Cale> kaiyin: i.e. it uses the parser y to parse the remainder of the input regardless of what the result of the parser x was
13:30:06 <randir> Does anyone have a good word-list to recommend of the top 5000 (or so) common English words?
13:30:23 <dfeuer> randir++
13:30:28 <Cale> It's essentially the concatenation of parsers, where we only produce the result of the second parser.
13:30:37 <kaiyin> Cale: you mean  x >> y = x >>= (\ _ -> y)
13:30:44 <Cale> Yes, same thing
13:31:27 <xplat> randir: that's an interesting question.  i don't remember any of my wordlists coming with frequencies.  probably you can find something of the sort included in linguists' sample corpora though
13:31:36 <n00bster> can someone explain me why when i define a function add x y = x + y the type signature is Num a => a -> a -> a but when defined as add = (\x -> (\y -> x + y)) then a gets concretized as Integer?
13:31:42 <Cale> (I just think underscores are typographically ugly there for no particular good reason)
13:31:59 <mauke> n00bster: the dreaded monomorphism restriction
13:32:25 <xplat> randir: augur can possibly tell you where to find a good one, and can definitely tell you at least 30 reasons you shouldn't want to find it.
13:32:27 <n00bster> mauke: i'll google it. thanks
13:32:29 <Cale> n00bster: If you add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file, that will get turned off.
13:32:49 <n00bster> Cale: thanks.
13:33:05 <augur> xpika: lol
13:33:10 <Cale> n00bster: Basically, things which are defined in such a way that they *look* like constants and don't have explicit type signatures are not allowed to be type class polymorphic
13:33:15 <haasn> Cale: n00bster: The monomorphism restriction serves a purpose, though. Instead of turning it off, add a type signature to top-level functions
13:33:17 <xplat> some of which will be pretty good reasons
13:33:25 <Cale> haasn: Barely.
13:33:32 <augur> xplat: there are lots of reasons to want a word list with frequency :p
13:33:39 <augur> i think wikipedia has some actually, xplat, randir
13:33:43 <dfeuer> randir, you might start digging around http://googlebooks.byu.edu/x.asp
13:33:45 <mauke> haasn: if I wanted a restricted monomorphic type, I'd add a type signature
13:34:00 <augur> but if you just google for english word list frequency youll find stuff
13:34:00 <randir> Thanks guys
13:34:45 <Cale> n00bster: This is because you might expect that such a thing is evaluated once and the result shared between occurrences (doesn't make sense here, but would for other cases), but the type class dictionary is a secret function argument, and functions are not memoised by default.
13:35:11 <xplat> mauke: some would say 'if i wanted a function i'd add an argument' instead though
13:35:12 <Cale> For example, you might write  n = product [1..100000]
13:35:23 <mauke> xplat: if I wanted a function, I'd use \
13:35:27 <Cale> This would have inferred type  (Num a) => a
13:35:38 <n00bster> Cale: my head hurts now. but thanks :)
13:35:53 <Cale> But if you gave it that type explicitly, then every time n got used, the product of those 100000 numbers would be recomputed
13:36:25 <Cale> Whereas if you have n :: Integer, say, then it will be computed once, and remain in memory until it's no longer needed
13:36:33 <xplat> so hey i'm starting to write a network media server thing for haskell (starting by porting mediatomb)
13:37:07 <xplat> basically because there are some features i want like 'back it with a git-annex store instead of a bare directory'
13:37:19 <alynn> so, smart people of #haskell, am I crazy for seeing some kind of duality between patterns and expressions
13:37:22 <Cale> This is because the (Num a) => ... is implemented as an implicit argument, so the polymorphic n behaves more like a function (which takes the definitions for (*) and fromInteger and whatnot in a record as an argument)
13:37:28 <xplat> alynn: no
13:37:35 <alynn> one turns a context of name->value bindings into a single value, and one turns a single value into a context of name->value bindings
13:37:45 <alynn> in which case is there a pattern-equivalent of lambda expressions?
13:38:21 <Cale> alynn: There is not, because such a thing would allow you to see the differences between functions which we don't want to admit are different
13:38:35 <xplat> alynn: zeilberger's thesis explains some things about pattern-expression duality
13:38:56 <xplat> alynn: and your particular question may have to do with funsplit
13:39:09 <kaiyin> Cale: http://lpaste.net/128166#line7 how come you can use <- with runParser?
13:39:17 <alynn> xplat: intriguing
13:39:21 * alynn gives it a read
13:39:25 <Cale> kaiyin: I'm using the list monad there
13:39:32 <xplat> alynn: but haskell doesn't have any patterns that take apart lambdas
13:39:57 <Cale> runParser x inp :: [(a, String)],  so (v,inp') :: (a, String)
13:40:18 <Cale> kaiyin: and the whole do-block there is a list of type [(b,String)]
13:40:40 <alynn> xplat: naturally
13:40:48 <alynn> I wondered if there was some kind of co-lambdas for patterns or something
13:40:52 <xplat> does anyone want to help get this media server started?
13:40:57 <Cale> kaiyin: It's essentially the same thing as if I'd written a list comprehension: [(w,inp'') | (v,inp') <- runParser x inp, (w,inp'') <- runParser (f v) inp']
13:41:19 <kaiyin> @undo x <- [1]
13:41:19 <lambdabot> <unknown>.hs: 1: 3:Parse error: <-
13:41:34 <Cale> @undo do x <- [1]; return x
13:41:34 <lambdabot> [1] >>= \ x -> return x
13:41:44 <kaiyin> cool
13:41:58 <Cale> For the list monad,  xs >>= f = concat (map f xs)
13:42:27 <xplat> @@ @pl @undo do x <- [1]; return x
13:42:27 <lambdabot>  [1]
13:42:33 <Cale> So in a do-block v <- xs effectively means "pick v from xs in all possible ways"
13:42:51 <xplat> @@ @pl @undo do x <- [1]; return $ x+1
13:42:51 <lambdabot>  [2]
13:42:57 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
13:42:59 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
13:43:20 <xplat> @@ @pl @undo do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
13:43:20 <lambdabot>  ([4, 5] >>=) . ((([6, 7, 8] >>=) . (return .)) .) . (,,) =<< [1, 2, 3]
13:43:35 <kadoban> Any reason why 'cabal install repa-examples' works fine, but 'cabal fetch repa-examples' gives me… "cabal: There is no package named 'repa-examples'."
13:43:50 <xplat> @@ @unpl @pl @undo do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
13:43:50 <lambdabot>  (([1, 2, 3]) >>= \ g -> ([4, 5]) >>= \ s -> ([6, 7, 8]) >>= \ v -> return (((,,)) g s v))
13:44:05 <Cale> xplat: why are you using @pl there?
13:44:24 <Cale> @undo do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
13:44:24 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5] >>= \ y -> [6, 7, 8] >>= \ z -> return (x, y, z)
13:44:36 <Cale> That's nice and clear on its own :)
13:44:39 <xplat> Cale: sometimes it helps get rid of unnecessary things, doesn't seem to do a good job here
13:45:57 <kaiyin> what is the definition of >>= for the list monad?
13:46:52 <xplat> so much of a C/C++ program is usually taken up with pointless repetition.  like mediatomb has a couple hundred lines of option parsing and starting a daemon stuff that basically every other unix daemon ever written duplicates
13:47:10 <xplat> the only real difference is which bugs it has
13:47:29 <xplat> kaiyin: (>>=) = concatMap
13:47:49 <augur> kaiyin:  [] >>= f = []   ;   (x:xs) >>= f = f x ++ xs >>= f
13:48:21 <augur> xplat: maybe flip concatMap?
13:48:24 <augur> :t concatMap
13:48:25 <lambdabot> (a -> [b]) -> [a] -> [b]
13:50:51 <joneshf-laptop> is using haskell on android still a pipe dream?
13:50:52 <Cale> kaiyin: I actually had anticipated your question and answered it 4 minutes before you asked ;)
13:51:07 <joneshf-laptop> or have things actually improved to the point that you can actually get set up easily?
13:51:25 <kaiyin> Cale: yeah, I realized that, too. :-)
13:51:43 <kadoban> How do I grab a copy of the repa-examples sourcecode? 'cabal fetch repa-examples' gives me "cabal: There is no package named 'repa-examples'.", even though I just installed it so…obviously it exists.
13:52:21 <augur> warning! warning!
13:52:25 <augur> Cale: ^
13:52:27 <xplat> dpkg source repa-examples?
13:53:10 <xplat> kadoban: or: https://hackage.haskell.org/package/repa-examples-3.3.1.1/repa-examples-3.3.1.1.tar.gz
13:53:11 <kaiyin> https://github.com/DDCSF/repa/tree/master/repa-examples 
13:53:34 <kadoban> Thanks
13:54:10 <Cale> augur: oh, now I realise what you're warning me about
13:54:15 --- mode: ChanServ set +o Cale
13:54:20 --- mode: Cale set +b *!*@cpc29-walt12-2-0-cust7.13-2.cable.virginm.net
13:54:20 --- kick: nigerSLAVEgg was kicked by Cale (nigerSLAVEgg)
13:55:24 --- mode: Cale set -o Cale
13:55:34 <kaiyin> Cale: you are the author of repa?
13:55:38 <EvanR> Cale: thx
13:55:40 <Cale> kaiyin: no
13:56:12 <Cale> I kinda wish I was the author of repa, it's pretty awesome.
13:59:02 <kadoban> It sure looks pretty neat…if I can ever figure out how to use it.
14:01:02 <xplat> kadoban: don't fear the repa
14:01:13 <kadoban> Haha. Boo.
14:01:40 <irishsultan>  
14:01:45 <nomeata> Is Neil Mitchell on IRC sometimes, and what would his nickname be?
14:02:11 <ralu> ?
14:02:38 <Cale> nomeata: ndm
14:02:42 <nomeata> Cale: thanks
14:03:11 <ralu> head $ drop 1000000 $ iterate (+ 1)  1
14:03:24 <ralu> in ghc why this eat stack ?
14:03:49 <nomeata> ralu: the (+1) is not evaluated until 100000 of those have been, well, stacked
14:03:58 <kaiyin> Cale: one more thing, http://lpaste.net/128166#line8   there is no return statement in this do block?
14:04:07 <Cale> ralu: Because it constructs a giant expression of the form (...((1 + 1) + 1) ...) + 1
14:04:19 <Cale> ralu: and then the outermost (+) needs to pattern match on its left argument
14:04:47 <Cale> ralu: and so the case expression waits on the stack while the slightly smaller expression is evaluated, and it does the same thing and so on
14:05:22 <Cale> ralu: You can imagine that the stack effectively consists of pattern matches that are waiting for their scrutinee to be sufficiently evaluated to match a pattern
14:05:24 <ralu> so super long expression is generated?
14:05:36 <ralu> and then evaluated on end?
14:05:43 <ralu> at head?
14:05:55 <Cale> Yeah, because drop doesn't look at the elements of the list, it just walks down it.
14:06:27 <ralu> but sum  $ iterate (1 +)  1 just keep running
14:06:35 <Cale> You can fix the behaviour with a function which makes sure that the elements get a chance to be evaluated as the spine of the list is evaluated, like
14:06:46 <mauke> iterate ((+ 1) $!) 1
14:06:59 <ralu> of course
14:07:02 <ralu> i got it
14:07:04 <Cale> strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs)
14:08:00 <Cale> mauke: I wouldn't expect that to help. (+) is already as strict as can be
14:08:05 <Cale> (and in fact, that's the problem)
14:08:30 <bennofs> Does traverse1 :: (Applicative f, Traversable1 t) => (forall a. g a -> f (g a)) -> t g -> f (t g)  exist somewhere already?
14:08:39 <kaiyin> is there something similar to @undo in ghci?
14:08:48 <Cale> kaiyin: nope
14:09:17 <bennofs> I'd also need it in indexed form, like (Applicative f, IndexedTraversable1 i t) => (forall a. i -> g a -> f (g a)) -> t g -> f (t g)
14:10:24 <mauke> Cale: ah, you're right. it'd have to be intertwined with the list generation
14:10:52 <mauke> strictList (x : xs) = (: strictList xs) $! x :-)
14:11:10 <bennofs> Oh, and I need it over 2 arguments. I guess IndexedBitraversable1 is too specific to exist somewhere ...
14:11:23 <Cale> Yeah, the nice thing is you can do that *after* iterate
14:11:40 <Cale> (well, for some sense of "after")
14:11:43 <alynn> bennofs: what's the kind of g?
14:11:46 <xplat> Cale: heh, i wonder if there should be a drop' that forces all the elements before dropping them :)
14:11:58 <Cale> xplat: Nah, we just need strictList :D
14:12:06 <bennofs> alynn: g :: * -> *
14:12:16 <mauke> :t foldr (\x z -> (: z) $! x) []
14:12:17 <lambdabot> [a] -> [a]
14:12:33 <Cale> It really ought to be in Data.List, but it's not
14:12:48 <Cale> I end up needing it more often than some of the things in Data.List anyway
14:13:21 <xplat> Cale: you need to give it a catchier name, like spinalTap
14:13:28 <Luke> I'm trying to use Shake but when I runhaskell my Shakefile it complains about all the "cmd" calls not being IsString instances. I have OverloadedStrings at the top of the file. Does runhaskell not honor extensions in the same way?
14:13:44 <mauke> @pl (\x z -> (: z) $! x)
14:13:44 <lambdabot> flip (($!) . flip (:))
14:14:00 <Luke> i'm sorry, not an instance of Shake.Command.Arg
14:14:01 <Cale> I also really want  select :: [a] -> [(a,[a])]; select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:14:14 <mauke> Luke: what's the actual error message?
14:14:45 <Luke> mauke: http://lpaste.net/4869335389912956928
14:14:46 <Cale> (otherwise totally unrelated, but while we're on the topic of stuff that ought to be in Data.List)
14:15:04 <jmcarthur> i wish there was a way to remove a variable from a given scope without having to extract a separate function or move to another module
14:15:52 <jmcarthur> i guess i could shadow the variable with something that will never be type correct, but then i have to turn off the warning about shadowing
14:16:16 <Luke> mauke: refresh. Added another error that's suspicious
14:16:19 <Cale> perhaps also  separate :: [a] -> [([a],a,[a])]; separate [] = []; separate (x:xs) = ([],x,xs) : [(x:ls,y,rs) | (ls,y,rs) <- separate xs]
14:16:19 <xplat> Cale: sounds like duplicate for some suitable comonad
14:16:22 <jmcarthur> and the unused variables warning
14:16:38 <xplat> Cale: that one too
14:16:42 <Cale> xplat: yeah
14:16:49 <edwardk> Cale: building a zipper?
14:17:26 <xplat> edwardk: hilighted you with comonad?
14:17:31 <edwardk> ok, so that takes a list and gives back the list of one hole contexts?
14:17:36 <edwardk> xplat: maybe =)
14:17:46 <Cale> edwardk: Basically simple zippery things which come up rather often
14:18:16 <edwardk> sure. that said Data.List is mentioned in the report. not sure i want to fossilize stuff around this _that_ hard.
14:18:17 <mauke> Luke: that looks like OverloadedStrings is the problem
14:18:30 <xplat> simple frequent zippery frippery
14:18:39 <Cale> https://mail.haskell.org/pipermail/libraries/2010-July/013843.html
14:18:55 <Luke> mauke: I have it at the top of the file: {-# LANGUAGE OverloadedStrings #-}
14:18:59 <mauke> Luke: yeah. remove it
14:19:01 <Cale> There's Conor's reply to my original request where he discusses the connection to differentiation
14:19:01 <Luke> oh
14:19:15 <Luke> mauke: nice thanks. would have never guessed
14:19:25 <Cale> (and comonads)
14:21:02 <Cale> You don't always want a whole zipper library though. Sometimes you just need one of these things. If you're using lists for nondeterminism, they're really common things to want.
14:21:24 <Cale> I've written both of them many many times over the years
14:22:39 <dgorbik_> Do I understand right that when I do forkIO inside some monad transformer I have to reinstantiate the whole stack? (or "copy" the stack, not sure what the term would be)
14:23:03 <xplat> Cale: but maybe you do always want a whole zipper library, you just want it in base ;)
14:23:15 <Cale> xplat: I'm not sure that I do...
14:23:33 <edwardk> Cale: sure, but most of the time i'm reaching for Data.List i'm going in to get 'sort'. so the wants of having that function on hand are balanced against the wants of folks to not get inundated with new functions in scope the moment they import a report-specified module
14:23:47 <Cale> xplat: Even just the extra newtype baggage which would be introduced makes it less useful than the raw functions for me
14:24:00 <edwardk> does such a function have a place elsewhere? not sure. seems likely, but in Data.List? i'd have a hard time selling it
14:24:20 <augur> is there a good tutorial for doing testing in Haskell, especially with databases, etc.?
14:24:27 <Cale> edwardk: It can be in GHC's Data.List and not in the Report for all I care
14:24:47 <Peaker> dgorbik_: you have to explicitly handle the conversion to/from IO, yeah
14:25:03 <Cale> edwardk: Is permutations in the Report?
14:25:35 <edwardk> we've dumped a handful of functions in there that aren't in the Report over the last few years
14:25:46 <edwardk> but those additions are getting a lot more scrutiny going forwar
14:25:47 <dgorbik_> Peaker, that totally makes sense. I just was puzzled for a couple of seconds when I tried doing that now for the first time
14:25:50 <edwardk> forward
14:26:34 <edwardk> since there are folks who are rather laser focused on what changes in the Prelude/report over what happens in base in general.
14:27:01 <edwardk> just saying that almost anywhere else in base? you'd have a much easier sell =P
14:27:06 <dgorbik_> Peaker: creater a readerT inside a readerT then run it, forkIO and finally lift again into the external readerT
14:27:08 <xplat> Cale: you could be using something like 'ala' to handle the newtype noise though
14:27:09 <Cale> Data.List2
14:27:10 <Cale> lol
14:27:19 <Cale> Control.List? :D
14:27:27 <mauke> Data.List.Moar
14:27:33 <xplat> Data.Ana.List
14:27:40 <mauke> Data.List.Prime
14:27:53 <mauke> wait, is Data.List' legal?
14:28:02 <Cale> dgorbik_: ReaderT over IO is almost always more trouble than it's worth imo.
14:28:36 * hackagebot cabal-install 1.22.2.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.2.0 (ryant)
14:28:43 <xplat> Data.List.Extra(s).  Data.MissingList.
14:28:58 <Cale> edwardk: I kind of think it's stupid that politics should ever prevent us from organising things in a sensible way.
14:29:12 <mauke> Data.List.Cale
14:29:52 <xplat> Cale: sadly, that's the price of getting other people to write your compiler and some libraries for you
14:30:10 <xplat> you can only avoid success so much without straight-up failing
14:30:37 <Cale> I also want to fix the argument order in the function argument to mapAccumR
14:30:50 <Cale> \f -> mapAccumR (flip f) is better
14:31:05 <Cale> (for more consistency with foldr)
14:31:17 <Cale> Not that anyone uses mapAccumR anyway
14:31:24 <edwardk> Cale: focused on picking battles worth winning ;)
14:31:25 <dgorbik_> Cale, I ended up using Pipes for my bot, the main state machine is actually pretty concise: runReaderT (runEffect (messages >-> handlePing >-> sequence_ [nickNegotiation, nickServId, forever await]) con). But the monad pipes operate on is ReaderT, in theory it's extremely easy to replace IO by just list producer and I can unit test stuff for free
14:31:33 <Cale> We could make that change, and nobody would even notice
14:31:34 <joncol> My Emacs keeps getting hanged when running Haskell interactive mode in it. It's fixed by killing the ghc process. Anyone knows of a better way around this?
14:31:54 <dgorbik_> Cale: forever await part would be replaced by broadcasting the message to all bot's modules.
14:32:24 <gilligan_> meh, stupid vpn
14:32:35 <Cale> dgorbik_: ah, hmm
14:32:56 <Cale> dgorbik_: Are you sure you can't just pull out the argument and make it explicit?
14:32:58 <xplat> :t mapAccumR
14:32:59 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:33:35 <Cale> http://cale.yi.org/share/Folds.png -- see the bottom right corner :)
14:34:35 <Cale> I guess the analogy is moreso with scanl/scanr
14:34:48 <augur> Cale: 0__________0;
14:35:40 <dgorbik_> Cale, yeah, before I was just passing con around to every producer/pipe/consumer. Do you think this implicit passing is hiding things too much? I added a (type Bot = ReaderT Connection IO), which means that my write/read commands only operate in this new Bot monad, which means there is a single connection associated with it
14:35:41 <EvanR> that explains everything
14:36:21 <dgorbik_> So whenever you are in a Bot monad there is a connection and it's handler is being implicitly passed around
14:36:34 <EvanR> looking at those fold diagrams i feel like im 4 years old again looking at real textbook pictures
14:36:35 <dgorbik_> EvanR, hi! :) I am here to annoy you with my stuff
14:36:51 <Cale> dgorbik_: Well, I guess you could make it a newtype and everything and figure out what all the primitives ought to be, but if you need to forkIO, that's rather tricky.
14:37:11 <EvanR> dgorbik_: well im about to go get drunk so it may have to wait
14:37:23 <Cale> EvanR: Do you need something explained?
14:37:31 <dgorbik_> EvanR, good strategy!
14:37:31 <augur> @src mapAccumR
14:37:32 <lambdabot> Source not found. :(
14:37:37 <xplat> EvanR: does being drunk make you easier or harder to annoy?
14:37:58 <EvanR> Cale: no i understand foldr and foldl, but those pretty diagrams have an initial impression of wonder rather than enlightenment ;)
14:38:08 <dgorbik_> Cale: are there any benefits to using newtype to hide monad transformer stacks instead of just type?
14:38:24 <Cale> dgorbik_: type doesn't really hide anything
14:38:46 <augur> oh i see, mapAccumR is foldr on the left of the pair, plus some weird stuff on the right list
14:38:58 <xplat> benefits: actually hides things
14:39:07 <xplat> drawbacks: actually hides things
14:39:10 <Cale> dgorbik_: When you have  type A = B  the compiler treats A and B as the very same type. You can imagine that A is macro-expanded to B anywhere that it occurs.
14:39:10 <dgorbik_> Cale, ah, so if I use newtype and derive Monad, Functor and Applicative it would be seen by clients as just single monad and they will not be able to do liftIO and stuff on it (unless I make it MonadIO instance)
14:39:20 <Cale> dgorbik_: right
14:39:46 <Cale> dgorbik_: So with newtype, if you don't export the data constructor from your module, you can make sure that the clients of your library can only do certain things.
14:40:04 <xplat> like 'not forkIO'
14:40:09 <Cale> hehe
14:40:29 <dgorbik_> I was thinking about forking before I execute any module's functions
14:40:46 <dgorbik_> so forking would be done automatically and from module's perspective it all will be well-confined in this Bot monad 
14:41:21 <dgorbik_> I haven't figured yet how to dynamically add broadcast clients when using pipes-concurrency 
14:41:22 <Cale> augur: Yeah, it's like a combination of foldr and scanr
14:41:29 <xplat> dgorbik_: forking is remarkably difficult to confine, from a reasoning perspective
14:41:36 <monochrom> if you don't export cryptography, other countries cannot use cryptography. (famous last words :) )
14:41:45 <Cale> augur: ... sort of :)
14:41:55 <augur> Cale: yeah. its weird. what are some uses of it??
14:42:19 <dgorbik_> xplat, I basically want modules to export their Consumer. I will then forkIO and connect the concurrency box with that Consumer
14:42:31 <xplat> if you don't export cryptography, other countries cannot use cryptography you exported...
14:42:40 <Cale> ... trying to think -- I know it's come up one or two times that it was the appropriate sort of answer for something.
14:43:06 <augur> Cale: also whats the def? is there a nice simple def, given the name?
14:43:14 <xplat> dgorbik_: it's just that as soon as you have one other thread that shares IORefs or Sockets or anything with you the semantics of all the primitives changes
14:43:34 <Cale> @src mapAccumR
14:43:34 <lambdabot> Source not found. That's something I cannot allow to happen.
14:43:40 <Cale> mapAccumR _ s []        =  (s, [])
14:43:40 <Cale> mapAccumR f s (x:xs)    =  (s'', y:ys)
14:43:40 <Cale>                            where (s'',y ) = f s' x
14:43:40 <Cale>                                  (s', ys) = mapAccumR f s xs
14:43:43 <augur> like, sometimes a name can be obscurant, but sometimes revealing. concatMap is transparent enough that the use pattern is somewhat clear
14:43:46 <xplat> mapAccumL and mapAccumR are basically mapM for State and ReverseState
14:43:47 <augur> hmm
14:44:04 <augur> xplat: say more?
14:44:06 <Cale> It's kind of like map in the State monad.
14:44:12 <Cale> or mapM rather
14:45:06 <augur> ahh like.. if we flip it a bit
14:45:27 <augur> mapAccumR' f [] = \s -> (s,[])
14:45:48 <Cale> Yeah, the variant of mapM where the effects are in the other order :P
14:45:56 <dgorbik_> xplat, I am not sure yet how to be able to share state between two modules, what the API would be for that... Say I have a module that maintains a database of users and can process commands to add/delete/modify users in that structure. But I want other modules to give access to that. It seems like such module should be broken into to parts: service provider and the part that operates on it using provider's primitives to add/delete
14:45:57 <dgorbik_>  users. And all other modules would be able to use same primitives to do other stuff as well
14:46:05 <augur> Cale: interesting..
14:46:23 <augur> Cale: and mapAccumL is in-order effects?
14:46:35 <xplat> dgorbik_: that's basically the way android usually handles things like that
14:46:43 <Cale> augur: yes
14:47:11 <augur> Cale: iiiii see. that makes sense then
14:47:47 <augur> probably then.. mapAccumR f s xs = fmap reverse (mapAccumL f s (reverse xs))
14:47:50 <dgorbik_> xplat so I should come up with some way to let the module add primitives to my Bot monad. I could store them in a hash or something
14:48:04 <xplat> if you use traverse instead of mapM you don't have to have ReverseState as a primitive thing
14:48:12 <monochrom> no wonder I completely forgot about mapAccumL/R after a certain year. that year must have been when I learned State
14:48:23 <augur> xplat: whats reverse state again
14:48:48 <Cale> Yeah, maybe the correct answer is just to remove mapAccumL/R because nobody actually uses them
14:49:04 <augur> haha
14:49:30 <Peaker> it's nice to use mapM with State, yeah
14:49:56 <dgorbik_> xplat these primitives would be just using TVar's under the hood, so in theory it should work without changing the structure I have right now too much.
14:51:14 <augur> im a sucker for forM, i'm afraid
14:51:21 <augur> functions last!
14:51:27 <Peaker> augur: Ruby influence?
14:51:31 <augur> yep
14:51:41 <augur> but its just so much nicer regardless
14:51:43 <Peaker> I'd put the functions anywhere else just to spite Ruby! :)
14:51:57 <augur> if you've got a non-trivial function, then this:
14:51:58 <Luke> mauke: is there a way to use OverloadedStrings in a Shakefile?
14:52:02 <augur> map (\x ->
14:52:03 <augur>    ...
14:52:05 <augur>    ...
14:52:06 <augur>    ...
14:52:12 <augur>  xs
14:52:15 <augur> is hideous
14:52:21 <augur> better to do
14:52:25 <augur> flip map xs $ \x ->
14:52:25 <Peaker> augur: or:  map foo xs where foo ...  (if a name is deserved)
14:52:39 <evincar> So I'd like to generate globally unique IDs in multiple threads.
14:52:51 <evincar> Currently I have a global IORef Int and increment it atomically.
14:52:57 <augur> Peaker: i dont like trailing definitions like. tho maybe i should start doing that more
14:53:14 <augur> my haskell stylistics isnt so great :p
14:53:17 <Peaker> evincar: you could give a unique prefix/suffix to each thread, and then they can generate their own unique incrementing IDs
14:53:22 <evincar> Would it be a bad idea to use IORef () instead of Int as my ID type?
14:53:38 <evincar> Then a fresh ID would just be newIORef ()
14:53:53 <evincar> (I only need equality.)
14:53:56 <augur> i'd really benefit, i think, from some iterations of algorithms, showing improving stylistic
14:54:08 <augur> like, v1 works, but is ugly, v2 is better, v3 is ideal
14:54:13 <augur> for a lot of different things
14:54:21 <Peaker> evincar: IORef () is pretty useless :)
14:54:30 <Peaker> evincar: () has 0 bits of information in it
14:54:34 <xplat> evincar: depends what you want to do with them.  it's hard to use IORef ids in a map, or store them on disk.  if you don't need to do any of those things you might be better off with the IORef solution
14:54:48 <evincar> Peaker: Sure, but it's unique and supports equality, which is all I need.
14:55:07 <kadoban> augur: http://exercism.io/ ? Only thing better than seeing them is…writing them.
14:55:08 <evincar> I'm just wondering whether a highly-contended counter is slower than hitting the allocator a lot.
14:55:09 <xplat> Peaker: yeah but the IORef itself has (unknown) number of bits of information representing its identity
14:55:51 <xplat> evincar: the allocator is probably faster than your handrolled global counter
14:56:14 <bennofs> With reactive banana, if I have Behavior t [Behavior t a], is it possible to get a Behavior t [a] from that?
14:56:16 <Peaker> oh, I misunderstood :)
14:56:17 <ryantrinkle> what would it take to add support for 'rec' blocks to Template Haskell?
14:56:30 <evincar> xplat: Probably. I guess I should just benchmark, but I thought I'd ask first in case there's some folk knowledge about this.
14:57:06 <xplat> bennofs: that sounds expensive
14:57:14 <bennofs> xplat: hmm, why?
14:57:39 <Peaker> How expensive is IORef ()? An Int is probably cheaper
14:58:22 <xplat> bennofs: btw what do you expect it to do?
14:58:28 <carter_cloud> ryantrinkle:  so we have a practical FRP system now? i cloned the code but haven't read it yet
14:58:38 * hackagebot opaleye 0.3.1.1 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.3.1.1 (tomjaguarpaw)
14:58:48 <xplat> Peaker: i expect the allocator would handle contention better than a single locked or atomic-incremented counter
14:59:15 <ryantrinkle> carter_cloud: yep, that's the idea :)
14:59:19 <xplat> bennofs: particularly if the number of Behavoir t a 's in the list changes
14:59:33 <Cale> ryantrinkle: link? :)
14:59:33 <carter_cloud> ryantrinkle:  haven't had the time yet to work thorugh it yet
14:59:35 <carter_cloud> https://github.com/ryantrinkle/reflex
14:59:50 <ryantrinkle> https://hackage.haskell.org/package/reflex
14:59:52 <ryantrinkle> also that
14:59:54 <xplat> bennofs: hm, could you use (join . (map sequence)) ?
15:00:24 <Peaker> xplat: but if each thread has its own IORef with its own Int range, then there's no contention.. as long as the range is large enough, there's no problem. Out of range? Can allocate a new full "range" from the central thread
15:01:04 <Peaker> But using newIORef sounds fine, if only Eq is needed, and the potential extra cost of IORef() (vs Int) are not a problem
15:01:06 <xplat> Peaker: yes, but the original question was about a single global Int counter rather than a zoned one
15:01:09 <ryantrinkle> carter_cloud, Cale: it still needs some cleanup, e.g. with the unnecessary modules and such
15:01:25 <ryantrinkle> but all the important stuff is solid
15:01:48 <xplat> Peaker: if you know about a zoned global id supply in a library on hackage that would be one thing, i don't think i'd suggest implementing that for one-off use though
15:02:33 <Cale> ryantrinkle: cool stuff :)
15:03:03 <xplat> ryantrinkle: what makes it more practical than [insert long list of previous systems here] ?
15:03:21 <bennofs> xplat: Behavior is not a monad
15:03:45 <ryantrinkle> xplat: you'll have to watch the talk :)
15:03:56 <ryantrinkle> http://www.meetup.com/NY-Haskell/events/221142235/
15:04:09 <xplat> ah, i got an email about that
15:06:43 <jmcarthur> i have a recursive higher order function that i want to apply the static argument transformation to. however, one of the recursive calls passes some other (statically known, even floatable) function as an argument instead. ideally, i would like to tell ghc to generate a dedicated, specialized loop for that argument, so that my use of the static argument transformation allows it the wrapper to be nonrecursive
15:06:45 <jmcarthur> (and inlinable). i don't know of a nice way to do this though. does anybody know of a way to do this without a ton of code duplication?
15:09:05 <xplat> jmcarthur: you could use 'fix' instead of syntactic recursion for the part that's actually recursive...that way you have the loop body to reuse in the wrapper
15:09:23 <Hixon10> Hi, guys. I want to say that Haskell is a pain. I write on it the second day, and I want to cry. If my professor did not force me develop with Haskell, I would be the happiest man in the world. It was a cry from the heart :)
15:10:10 <xplat> Hixon10: no pain no gain
15:10:57 <Hixon10> xplat, yep, but today I develop function like "2 + 2" more, than 2 hours. It is a terrible.
15:11:05 <monochrom> I wouldn't say "no pain no gain", since if you bother to tell us this, obviously you had no pain with other languages previously, and you certainly felt that you did gain.
15:11:19 <Hixon10> I like IDE like IDEA.
15:11:52 <xplat> monochrom: don't analyze the snappy comment, that ruins it ;-(
15:12:14 <dreams> Hixon10: you'll get used to it.
15:12:17 <ttt_fff> is there a way to somehow get haddock locally?
15:12:24 <ttt_fff> I want a way to generate docs for all local cabal pacakges
15:12:24 <monochrom> what I do say is: my condolence, but I didn't have (or feel) pain when I learned it.
15:12:39 <monochrom> or in other words, I guess everyone is different.
15:12:53 <Hixon10> dreams, does haskell have cool IDE?
15:12:59 <monochrom> people say "everyone is different" happily like it's a happy thing.
15:13:15 <monochrom> today you see an instance where "everyone is different" is not a happy thing.
15:13:17 <dreams> Hixon10: well there is an OS for that: emacs.
15:13:20 <Hixon10> I try to find some tools, but I could not.
15:13:20 <kurogoma> vim is the best ide
15:13:38 <xplat> Hixon10: what were you using to write haskell today?
15:13:47 <OutlawStar> I actually found emacs better for haskell then vim, even though i use vim
15:13:52 <Peaker> was there some @flame command for lambdabot? :)
15:14:00 <dreams> kurogoma: its not an IDE unless you make it one.
15:14:01 <Hixon10> xplat, IDEA with plugin. 
15:14:44 <dreams> OutlawStar: I agree, emacs seems better suited for Haskell. This also applies to Latex.
15:14:52 <xplat> Hixon10: ah, i never tried that.  i develop haskell with vim mostly, but the first couple of days i used vim i wanted to cry too
15:15:11 <Hixon10> The Plugin is a terrible. No autocomplete, no refactoring, no some cool stuff like java.
15:15:21 <ttt_fff> how do I HADDOCK ALL OF CABAL ?
15:15:22 <dreams> xplat: no pain no gain.
15:15:28 <xplat> refactoring in haskell is kind of different
15:15:28 <ttt_fff> HADDOCK ALL THE PACKAGES / meme
15:15:31 <xplat> dreams: indeed!
15:15:35 <dreams> Hixon10: then use notepad
15:15:44 <OutlawStar> yes notepad!
15:15:45 <kurogoma> dreams: yup, but it's what i use
15:15:53 <xplat> actually refactoring haskell is easy even without plugins.  once you get used to it.
15:16:24 <alynn> there was some kind of haskell refactoring tool on hackage a few years ago but I think it went unmaintained
15:16:27 <alynn> HaRe?
15:16:37 <xplat> but it's pretty hard to deal without autocomplete once you get used to that
15:16:41 <OutlawStar> honestly the biggest pain of haskell is setting up the dev env, I love the language itself
15:16:43 <Peaker> xplat: A good IDE could have made it much less painful still
15:16:44 <kurogoma> i'm curious, i have to learn haskell for a class next semester and thought i'd play around in xmonad configs to wrap my head around the language. does this seem counterproductive to anyone?
15:17:29 <monochrom> also, while I certainly made great use of an IDE like Eclipse when I worked on Java, I still haven't needed one for Haskell very much.
15:17:30 <monochrom> I mean, certainly would be nice, but don't ignore the difference in degrees. I would pay $5 for a Haskell IDE, $50 for a Java IDE. that's how much.
15:17:30 <monochrom> speaking of which, FPComplete is an IDE that probably doesn't make you pay. so there.
15:17:30 <monochrom> but it does require a stable Internet connection. it's a web thing.
15:17:35 <kadoban> kurogoma: Probably, unless you've done some basic haskell learning first.
15:17:44 <Cale> kurogoma: You might have a better experience following along with some properly constructed course
15:18:22 <kurogoma> alright, i got the learn haskell for great good book, i guess i'll follow along
15:18:34 <Cale> kurogoma: Unless you've done a lot of programming in other statically typed functional programming languages, learning Haskell is going to be a little bit like learning to program from scratch at first.
15:18:58 <OutlawStar> <-- agrees with Cale
15:19:00 <Hixon10> Cale, it is a very true statement... :(
15:19:03 <Cale> kurogoma: http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html is also highly regarded
15:19:09 <kadoban> kurogoma: The cis194 class suggested by https://github.com/bitemyapp/learnhaskell is a nice course. It has suggested readings from LYAH and RWH, and has exercises so you actually end up using what they try to teach.
15:19:18 <kurogoma> Cale: thanks
15:19:30 <dreams> kurogoma: I'd start with something simpler. Perhaps reading a good book on the subject. I keep saying the book "Introduction to Functional Programming" by Richard Bird, Philip Wadler the first edition, is the best book on functional programming. Though it uses Miranda but its very close to Haskell.
15:19:36 <kurogoma> I'll probably be around from time to time to ask questions.
15:19:55 <Cale> kurogoma: Yeah, definitely asking questions here is a great way to learn :)
15:20:15 <kurogoma> thanks guys, i appreciate the input
15:20:18 <kurogoma> take care
15:21:27 <Cale> Hixon10: It's a somewhat sad fact, but perhaps more happy than sad, in the end. The ways in which Haskell is different from other languages are mostly good things :D
15:21:33 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml
15:21:41 <xplat> i think the tooling from Java doesn't really suit haskell well.
15:21:49 <xplat> better would  be the tooling from go
15:22:32 <monochrom> bear in mind that no IDE can bridge a mental gap
15:22:54 <monochrom> to bridge a mental gap, you need a USB 3.0 port on your head so I can simply upload stuff.
15:23:02 <Hixon10> Cale, there is one problem. I don't understand, why my professor says, that I have to study haskell, not some cool language (e.g., Scala). I think, that Haskell is not used for production. Therefore I don't know, why to study this FP.
15:23:21 <Cale> Hixon10: Haskell is way cooler than Scala imo
15:23:33 <Cale> Hixon10: also, my last few jobs have all been Haskell jobs
15:23:35 <Hixon10> is there some profit? 
15:23:37 <xplat> Hixon10: you will learn more about scala if you use haskell first than if you learn scala directly
15:23:48 <Cale> It does get used in production.
15:23:50 <Hixon10> 0o, there is haskell job.
15:23:52 <dreams> Hixon10: who told you that? Haskell is used in the industry.
15:24:22 <Luke> anyone know of anything that can return the number of errors and warnings in a ghc build?
15:24:27 <Hixon10> dreams, I thought so. Is it wrong?
15:24:42 <dreams> Hixon10: It is not used compared to imperative languages.
15:24:51 <hiptobecubic> I would argue that what most people mean when they ask about jobs is whether or not there are jobs for people who are mediocre and/or suck at this. For Scala and Python and Ruby and Javascript and many other languages that's still a yes. I don't think it is for Haskell yet.
15:24:55 <monochrom> you won't understand https://www.youtube.com/watch?v=TS1lpKBMkgg until you have learned some haskell
15:25:00 <xplat> it's a little hard to tell what's used in the industry outside the top 5 or so
15:25:01 <evincar> Looks like "newIORef ()" is a bit faster than an atomic increment, but I'll actually have to use the latter because I need Show as well as Eq for these IDs, sadly.
15:25:20 <Cale> Hixon10: Scala is trying to steal lots of things from Haskell while remaining compatible with the JVM. It sort of works, but it also ends up being way more complicated and stupid than it needs to be for a variety of reasons. Still, if you *need* to be on the JVM, that's maybe what you have to put up with.
15:25:27 <xplat> because a lot of the top like 25 after that network very inwardly
15:25:28 <monochrom> Facebook uses Haskell. this is well known.
15:25:51 <dreams> Cale: Scala tries to shove everything to the language. Its terrible.
15:26:10 <xplat> and in fact the top 5 do too, it's just that they're so huge you can see them pretty clearly just from the spillover
15:26:15 <Cale> Hixon10: But from the point of view of "let's design a language which has a lot of nice properties", Scala is terrible, while Haskell does a less shitty job than most programming languages anyway.
15:26:24 <dreams> There is Clojure for that too.
15:26:38 <Peaker> btw, whatever happened to that Scala guy who gave the "We're doing it all wrong" talk? His talk sounded a lot like the Diff(Scala, Haskell) :)
15:27:02 <monochrom> it is perfectly normal that what one person finds cool, another person finds painful.
15:27:20 <monochrom> a happy consequence of "everyone is different"
15:27:26 <Cale> Well, sure
15:28:31 <xplat> everyone isn't different.  everyone is the same.
15:28:31 <monochrom> likewise, that kid depicted in my article (he said that he flunked math and he coded asm fine), I'm pretty sure he would not be able to learn haskell.
15:29:01 <monochrom> (he was also the poster boy for a community college here, a decade ago)
15:29:12 <dreams> The pain in Haskell is complexity. Well reasoning in general.
15:29:34 <monochrom> (yes, the college explicitly uses a kid who flunked math as a role model.)
15:29:44 <monochrom> (or I guess s/uses/used/ )
15:30:27 <xplat> monochrom: i think they were using him as a role model for other people who flunked math?
15:30:41 <xplat> (or almost flunked math.  or hated math.)
15:30:44 <Cale> dreams: Depends on what sort of reasoning. I find at least the meaning of Haskell code a lot easier to reason about than code in most popular languages anyway.
15:31:13 <glguy> Anyone have a favorite either library or at least existing format for doing config files? I'm going to want to be able to programatically change the config, to. Supporting comments/keeping them around would be good.
15:31:22 <evincar> Kinda disappointing that "atomicModifyIORef' ref (\x -> (succ x, x)" doesn't get compiled to a CAS. :(
15:31:26 <dreams> Cale: not denotational reasoning.
15:31:37 <xplat> glguy: this is exactly what i wanted last week.  i didn't actually find one.
15:31:42 <dreams> Cale: reasoning about efficiency for instance.
15:32:13 <dreams> It is easier in other languages.
15:32:19 <xplat> glguy: configurator and yaml were the best approximations, but not very good ones
15:32:32 <Cale> dreams: I don't find reasoning about efficiency to be all that much harder, but maybe there are some technical ways in which it's harder in the worst case. :)
15:32:53 <monochrom> glguy: do you mind using JSON in config files? then you can simply call up aeson. not sure about comments though.
15:33:04 <Cale> dreams: It's very different though... it takes a long time to get used to quickly "seeing" performance problems
15:33:06 <xplat> dreams: have you read okasaki?
15:33:11 <dreams> Cale: well then you must be smart. Reasoning about efficiency is still an open problem as far as the literature go.
15:33:27 <jmcarthur> xplat: i managed to get what i wanted. i settled on creating toplevel specializations of my function that don't get inlined themselves and using them inside the definition of the function. apparently this is enough for the optimizer to make my function inlinable.
15:33:33 <glguy> I'm specifically planning how I graduate my irc client from commandline args to actual configs
15:33:37 <dreams> xplat: nope, what's that?
15:33:50 <xplat> monochrom: yaml is nearly a superset of JSON, the library interface in haskell is similar, and it's much nicer to use for config files
15:33:50 <Cale> dreams: Well, I'm not really talking about general tools for formally proving things about complexity for a large class of programs at once
15:34:00 <glguy> monochrom: Yeah, going JSON or Yaml might help people not have to learn a new format
15:34:14 <Cale> dreams: I'm just talking about doing what you need to do to get your programs to perform well enough.
15:34:32 <xplat> @where okasaki
15:34:32 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:35:59 <xplat> glguy: i really wanted something that worked similar to, and along with, optparse-applicative, and would provide sensible defaults as to where to find config files
15:36:07 <xplat> glguy: this i did not find
15:37:24 <xplat> glguy: if you have similar goals maybe we could hack something together that would help us both
15:38:19 <dreams> Cale: I find it hard to "understand" the cause of a problem (eg. bottleneck) in complex programs, even with existing profiling tools. Its much easier in say C.
15:38:39 <Cale> Have you been programming in C longer than you've been programming in Haskell?
15:38:43 <kaiyin> It seems difficult to reason about monadic actions, especially when when you use it recursively: https://gist.github.com/kindlychung/4f8a562faf4087047473#file-1-hs-L64
15:39:35 <Cale> kaiyin: Did you have a question about that parser?
15:39:41 <monochrom> I used to believe that Haskell asymptotic complexity was as easy as Pascal asymptotic complexity. So I set out to do my PhD on exactly that.
15:40:07 <monochrom> When I finished, I admitted that the Haskell case is harder.
15:40:15 <dreams> Cale: not really. To be honest I started both at the same time. And I know how to use Haskell profiling tools better than C ones.
15:40:29 <xplat> dreams: C used to be an *especially* nice language to reason about performance because it mapped almost directly to assembly instructions, especially when it came to the expensive ones.  this is no longer as much the case as it used to be.
15:40:30 <Cale> monochrom: I think it's formally harder, but in like 99.9% of real world cases, it's just as your intuition suggested
15:40:30 <monochrom> http://www.cs.utoronto.ca/~trebla/albert-thesis-ut.pdf
15:40:30 <kaiyin> Are there any tips for better understanding this kind of things? I can substitute things around according to definitions and conclude that these functions do work as they are supposed to, but this is very tedious.
15:40:49 <kaiyin> Cale: I don't have questions about this parser per se, at the moment. 
15:41:02 <dreams> xplat: Interesting, I actually read "ALL" profiling papers on lazy functional languages. That was sort of enough to get me started.
15:41:10 <Peaker> xplat: it's still quite nice, because performance on modern Intels is roughly the number and kind of cache misses, which is easy to assess in C vs. other languages
15:41:16 <Cale> kaiyin: First of all, understand what it's intended that this parser do
15:41:21 <dmj`> what module exports the IO data constructor?
15:41:29 <Peaker> xplat: instructions don't matter that much anymore
15:41:47 <dreams> xplat: Its not about that for me. Its that you can step-in the execution. You have no chance for that in Haskell. 
15:41:53 <xplat> Peaker: yeah, it's just that there are more languages that can compete with C now
15:42:17 <dmj`> GHC.IO
15:42:27 <dreams> xplat: imperative-style is what I meant.
15:42:39 <Cale> kaiyin: string xs  is the parser which tries to match xs, and if it finds it, produces that string as its result, otherwise, it fails
15:43:04 <kaiyin> Cale: yes, I understand that. 
15:43:13 <Cale> kaiyin: When defining something recursively on a nonempty list (x:xs), you can assume that it works correctly on xs
15:43:40 <Cale> So, string (x:xs) is the parser which first tries to match x, and then tries to match the string xs
15:43:49 <Cale> and if so, it produces (x:xs) as its resulty
15:43:52 <Cale> -y
15:44:41 <xplat> dreams: http://felsin9.de/nnis/ghc-vis/ https://www.youtube.com/watch?v=X4-212uMgy8 http://www.reddit.com/r/haskell/comments/87v5v/use_vacuum_to_graph_your_heap/
15:45:12 <monochrom> should I include mathematical induction in my prerequisite article? XD
15:45:14 <kaiyin> Cale, how can you be sure that the parser will take care of the inp' part of (v, inp') correctly without jumping into the definition of >>=?
15:45:20 <Cale> monochrom: maybe :)
15:45:33 <Cale> kaiyin: By understanding (>>=) on its own separately
15:45:52 <Cale> kaiyin: If you still don't understand that (>>=) does its job correctly, you shouldn't be looking at string
15:46:01 <monochrom> put it this way. on odd-numbered days I want this article to scare some people away - people who are hopeless anyway.
15:46:18 <Cale> You need to have confidence in the things that you use when defining something new.
15:46:36 <dreams> xplat: even with stepping tools. graph-reduction is so huge. Its hard to keep track of things. This is a problem in the nature of the language, the way I see it.
15:46:49 <Peaker> xplat: most languages these days still box everything in a cache-unfriendly and somewhat opaque way
15:47:01 <monochrom> on even-numbered days I want this article to assure some other people - people who have not programmed anything and wonder if they can still learn haskell (they probably can do way better)
15:47:05 <kaiyin> I see. I need have a better understanding of >>=.
15:47:49 <dmj`> kaiyin: are you familiar with the Monad typeclass
15:47:59 <Cale> kaiyin: Okay, so... one moment, I just need to get something to drink, I'll be right back. I can give you a tutorial on the State monad first (because it's a little bit simpler) and then Parser, where we examine in detail how (>>=) works in particular.
15:48:14 <dreams> xplat: Hat filters reduction steps for you. But its broken.
15:48:24 <monochrom> perhaps it is better if I write an article to teach induction nicely
15:48:26 <kaiyin> Cale: cool.
15:49:11 <kaiyin> dmj`: no, but I have read something about it months ago.
15:49:12 <monochrom> yeah! I should do that. it will have many benefits. it helps teach haskell, but there are other benefits outside.
15:50:35 <monochrom> yeah, learn State first, then Parser is just a bit more stuff on top of State
15:51:07 <monochrom> I think I learned them in that order, too
15:51:32 <monochrom> it's why I basically had no problem with following Parser
15:52:03 <Cale> So, should we perhaps do this in #haskell-overflow? It might be easier to keep track of everything without other discussions being interleaved
15:54:08 <kaiyin> Cale: cool
15:58:21 <cjheath> Has anyone here used Purescript and want to offer an opinion?
16:08:03 <artemshitov__> Does anybody know what the state of GHC-7.10.1 is?
16:08:54 <geekosaur> they're discussing delaying it for a severe performance regression that was reported yesterday and tracked down earlier today
16:09:05 <artemshitov__> Oh
16:09:40 <geekosaur> actually worse than performance... apparently an exception could silently turn into code in a random place executing
16:09:44 <geekosaur> which, erm.
16:09:47 <ion> nice
16:10:45 <artemshitov__> This is sad
16:11:54 <geekosaur> https://mail.haskell.org/pipermail/ghc-devs/2015-March/008532.html discussion thread for the bug
16:12:50 <artemshitov__> Thank you
16:13:39 <ReinH> dfeuer: ping
16:13:52 <dfeuer> ReinH, pong
16:14:19 <ReinH> dfeuer: Yeah, that thing I linked is incomplete and a bit of a ramble :)
16:14:28 <dfeuer> Ah....
16:15:44 <ReinH> dfeuer: categories in Haskell can be represented by their hom-sets, which is how Control.Category works: class Category hom where id :: hom a a; (.) :: hom b c -> hom a b -> hom a c
16:16:28 <dfeuer> All a-righty.
16:16:29 <bernalex> my brain isn't coopretaing
16:16:35 <ReinH> dfeuer: Hask itself has an internal hom represented by (->) so you have instance Category (->) where id = Prelude.id; (.) = Prelude.(.)
16:16:38 <ReinH> or however that needs to be spelled
16:16:41 <bernalex> how do I 'f (a -> b) -> a -> f b'?
16:16:52 <bernalex> [a->b] -> a -> [b] to be more specificr
16:16:57 <bernalex> s/r$//
16:17:09 <dfeuer> bernalex, are you drunk?
16:17:25 <dfeuer> ReinH, okay ...
16:17:36 <bernalex> dfeuer: if you are referring to s/r$//, then that is a correct substitution. hi, btw.
16:18:00 <enthropy> @type \ fs x -> map ($ x) fs
16:18:01 <lambdabot> [a -> b] -> a -> [b]
16:18:13 <enthropy> sequence will do it too
16:18:18 <dfeuer> bernalex, no, it just seems like you're stumbling over keys and saying strange things. That would be normal for me, but less so for you.
16:18:18 <bernalex> enthropy: that was what I was sort of thinking about doing
16:18:33 <bernalex> :t sequence
16:18:34 <lambdabot> Monad m => [m a] -> m [a]
16:18:57 <bernalex> dfeuer: 'r' is next to 'c' on my keyboard, so I hit 'r' after 'c' by a mistake. :)
16:19:10 <dfeuer> @djinn f (a->b) -> a -> f b
16:19:10 <lambdabot> -- f cannot be realized.
16:19:17 <dfeuer> @djinn Functor f => f (a->b) -> a -> f b
16:19:17 <lambdabot> Error: Class not found: Functor
16:19:23 <dfeuer> Hmm
16:19:29 <bernalex> enthropy: uhm which sequence?
16:19:33 <dfeuer> bernalex, ah, it's there on my keyboard too.
16:19:42 <bernalex> not sure how "t (m a) -> m (t a)" will help here
16:19:53 <ReinH> dfeuer: So a functor between categories would carry homs to homs
16:20:00 <enthropy> there's  instance Monad ((->) a)
16:20:57 <ReinH> so you have, e.g., class (Category c, Category d) => Functor f c d where fmap :: c a b -> d (f a) (f b)
16:21:15 <enthropy> :t undefined :: (m ~ ((->) a)) => m b
16:21:16 <lambdabot> a -> b
16:21:19 <ReinH> dfeuer: you probably need fundeps to convince GHC to typecheck it
16:21:45 <dfeuer> ReinH, ok, so ... how do you actually express that? edwardk has a fancy Functor based on a fancy Category', but that's different.
16:21:46 <ReinH> Functor f c d | f c -> d, f d -> c, perhaps
16:22:50 <ReinH> dfeuer: Well, you have instances like instance Functor ((,) e) (->) (->) where fmap f (a, b) = (a, f b)
16:23:01 <dfeuer> Gleeek.
16:23:04 <ReinH> Which I believe is a statement that functors in haskell are strong
16:23:10 <ReinH> Cale: maybe?
16:23:24 <ReinH> er, I said e and then a
16:23:26 <dfeuer> I don't even know what that means yet. 
16:23:36 <ReinH> ((,) a) (->) (->) where fmap f (a, b) = (a, f b)
16:24:26 <ReinH> in instance Functor f c d, f is a usual functor on Hask, c and d are categories
16:24:42 <dfeuer> OK, I think I finally understand your Functor definition.
16:24:58 <ReinH> in this case, c and d are Hask itself, the ambient category where the hom-set is represented by (->)
16:25:04 <ReinH> remember that categories here are represented by their hom-sets
16:25:12 <dfeuer> Yes.
16:25:30 <ReinH> So this is a statement that ((,) a) is a functor from Hask to Hask
16:25:32 <ReinH> which we already know
16:25:39 <dfeuer> But ...
16:25:45 <ReinH> we're just being explicit about the dom and codom of the functor
16:25:49 <dfeuer> these are only certain sorts of functors, I think.
16:26:28 <ReinH> Every Prelude.Functor f is a Functor f (->) (->)
16:26:33 <bernalex> can someone tell me a better/more clever way to achieve this:
16:26:35 <bernalex>   where g m | m > 0     = [1 .. m] ++ [(m - 1),(m - 2) .. 1]
16:26:37 <bernalex>             | otherwise = [0]
16:26:51 <ReinH> dfeuer: but we are no longer restricted to endofunctors from (->) to (->)
16:27:04 <bernalex> @let bernalex m | m > 0     = [1 .. m] ++ [(m - 1),(m - 2) .. 1] | otherwise = [0]
16:27:07 <bernalex> > bernalex 5
16:27:08 <lambdabot>  Defined.
16:27:08 <dfeuer> OK.
16:27:09 <lambdabot>  [1,2,3,4,5,4,3,2,1]
16:27:44 <dfeuer> bernalex, what's wrong with that?
16:27:54 <bernalex> dfeuer: feels a bit verbose
16:27:57 <ReinH> So you want (some efficient version of) [1..m] ++ (reverse (m-1 .. 1))?
16:28:10 <dfeuer> bernalex, the part where you only have 0 sometimes is a bit weird.
16:28:12 <ReinH> er, reverse (1 .. m - 1)
16:28:31 <ReinH> Ugh I have a mental block about range syntax, sorry
16:28:35 <ReinH> replace () with [] as appropriate
16:28:41 * dfeuer is getting sleepy.
16:28:42 <bernalex> dfeuer: lol yes it should only work for >1 really
16:28:55 <dfeuer> bernalex, so only make it work for >1?
16:29:00 <bernalex> ReinH: not efficient but short/cute would be nice. I don't need performance.
16:29:13 <dfeuer> bernalex, your current version is pretty efficient already.
16:29:15 <ReinH> so \n -> [1..n] ++ reverse [1..n-1]
16:29:25 <bernalex> I guess
16:29:40 <ReinH> guard on | n < 1 = [] as well
16:29:41 <bernalex> I actually have that in here as a previous edit heh
16:29:42 <dfeuer> ReinH, that's harder to understand and slower.
16:29:52 <ReinH> dfeuer: It isn't harder to understand for me. It is slower.
16:30:41 <monochrom> [1..n] ++ [n-1 , n-2 .. 1]
16:30:44 <bernalex> I'm basically just doing some late night golfing for fun.
16:31:03 <ReinH> dfeuer: So, I suppose the exercise for the reader is: what categories other than Hask (represented by (->)) can we define, and what Functor instances other than endofunctors on Hask can we define. ;)
16:31:05 <monochrom> I guess you already know
16:31:17 <bernalex> monochrom: yeah that's what I went with now
16:31:18 <dfeuer> Cuter, perhaps:  \n -> [1..n] ++ map negate [1-n..(-1)]
16:31:27 <bernalex> monochrom: I guess it's OK
16:31:27 <enthropy> n is simpler than m
16:31:36 <ReinH> enthropy: by at least a stroke ;)
16:31:49 <dfeuer> ReinH, yeaaaah. Not an easy exercise, generally.
16:32:34 <monochrom> that's like saying the Chinese character 一 is simpler than n
16:33:07 <bernalex> @unlet
16:33:07 <lambdabot>  Define what?
16:33:13 <bernalex> erm
16:33:24 <bernalex> @undefine
16:33:24 <lambdabot> Undefined.
16:33:26 <bernalex> ?
16:33:31 <bernalex> @let bernalex p n = mapM_ (print . unwords . flip id p) (replicate <$> [1 .. n] ++ [n - 1, n - 2 .. 1])
16:33:35 <lambdabot>  Defined.
16:33:39 <monochrom> > (\一 -> [1 .. 一] ++ [一-1, 一-2 .. 1]) 10
16:33:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1]
16:33:46 <bernalex> oh wait can't do IO here anyway
16:33:52 <bernalex> @undefine
16:33:52 <lambdabot> Undefined.
16:33:59 <bernalex> @let bernalex p n = map (unwords . flip id p) (replicate <$> [1 .. n] ++ [n - 1, n - 2 .. 1])
16:34:00 <monochrom> "so simple. very Chinese" :)
16:34:02 <lambdabot>  Defined.
16:34:06 <bernalex> @bernalex "test" 5
16:34:06 <lambdabot> Unknown command, try @list
16:34:10 <bernalex> > bernalex "test" 5
16:34:12 <lambdabot>  ["test","test test","test test test","test test test test","test test test t...
16:34:16 <ttt_fff> is it bad if I have a haskell file called MyTypes.hs and have it include all the "data *" declarations I have ?
16:34:17 <bernalex> ok so that's what I'm golfing atm
16:34:30 <bernalex> golfing technique assistance is welcome
16:34:49 <monochrom> ttt_fff: sometimes it's good, sometimes it's bad.
16:35:11 <ttt_fff> monochrom: you should advise people on how to invest in stocks
16:35:59 <enthropy> ttt_fff: it's bad because that means you have one less place to define instances if you're to avoid making orphan instances
16:36:13 <ttt_fff> enthropy: oh, I like orphan instances
16:36:17 <monochrom> see? people do hate me for saying the cold hard truth "you have to think for yourself on a case-by-case basis". it's true.
16:36:20 <ReinH> dfeuer: Anyway, does that answer your question about functors in Haskell that aren't endofunctors on Hask?
16:36:22 <ttt_fff> the main downside I see is that whenever I create a new type, EVERYTHING recompiles
16:36:50 <dfeuer> data POrd :: * -> * -> * where POrd :: (Ord a, a ~ b) => a -> b -> POrd a b   is a category, right?
16:36:54 * enthropy doesn't see the monochrom hate
16:37:07 <dfeuer> ReinH, kinda. Still learning basics, but somewhat, yes.
16:37:08 <dfeuer> Thanks.
16:37:13 <ReinH> dfeuer: np :)
16:39:41 <ReinH> dfeuer: feel free to ask questions if you want me to follow up on something
16:39:48 <bernalex> my current iteration (not in IO because that's dumb) is: unlines $ unwords . flip id p <$> (replicate <$> [1 .. n] ++ [n - 1, n - 2 .. 1])
16:39:58 <bernalex> bit longwinded
16:40:48 <Fylwind> if I install a package with 'library-profiling: True' in .cabal/config, does that mean I get BOTH profiled and unprofiled versions, or ONLY profiled version?
16:40:53 <dfeuer> ReinH, thanks. Right now I'm a little sleepy for this, but maybe tomorrow.
16:41:02 <monochrom> you get both, Fylwind
16:41:03 <ReinH> dfeuer: sure thing
16:41:13 <Fylwind> monochrom: that's good to know, thanks!
16:44:45 <hyPiRion> bernalex: let b x n = unlines $ (iterate (++' ':x) x !!) . pred <$> [1 .. n] ++ [n - 1, n - 2 .. 1]
16:44:58 <bernalex> hyPiRion: that's cute for all the wrong reasons
16:45:15 <hyPiRion> bernalex: yep, it's not pretty runtime wise
16:45:30 <bernalex> hyPiRion: my entire function atm is 'unlines $ unwords . flip id p <$> (replicate <$> [1 .. n] ++ [n - 1, n - 2 .. 1])'
16:45:59 <bernalex> uhm f n p = ... ^ that
16:46:42 <bernalex> hyPiRion: I'm going to oslo tomorrow & having lunch & dinner. want to join for one of them? :) we're two people confirmed for lunch, three for dinner -- with erlend potentially being a fourth for dinner.
16:47:49 * monochrom misread that as "with erlang being a fourth" and wondered how to dine with erlang
16:48:21 <hyPiRion> bernalex: yeah, sure thing! I can do either, but I think I'm too busy to do both
16:48:52 <hyPiRion> Would be cool with dinner
16:49:42 <bernalex> hyPiRion: lunch will be at 12-ish at cafe sara. dinner will be at some Indian restaurant. time & place undecided as of yet.
16:50:18 <bernalex> hyPiRion: if you join #plaimi, we're all in there and will be discussing/announcing the plans there.
16:52:12 <augur> barring emacs/vi/etc what're people's favorite Mac text editors for programming?
16:52:38 <SaraDR> it's windows. LOL
16:52:49 <hpc> augur: vmware
16:52:54 * hpc ducks
16:53:12 <cjheath> ppl like Atom
16:53:15 <hpc> xcode is sort of the canonical editor
16:53:20 <cjheath> I use vim
16:53:25 <augur> hpc: xcode is awful :(
16:53:32 <glguy> If you don't want to use vi there's MacVim
16:53:41 <augur> cjheath: atom, hmm. isnt that the online one?
16:53:58 <cjheath> It uses the browser code, but it’s local
16:54:09 <augur> hmm
16:54:13 <cjheath> so you can extend it with JS and CSS
16:54:32 <hpc> augur: eclipse
16:55:36 * cjheath tried to learn Atom, but has vi under his fingernails
16:56:34 <cjheath> So I take it from the non-response that no-one here has tried Purescript?
16:56:48 * cjheath is surprised
16:57:13 <arkeet> I haven't tried it. I'm sure there are a few people here who have.
16:57:53 <cjheath> concerned about any difficulty in debugging before I try it
16:58:28 <ReinH> glguy: "If you don't want to use vim there's vim with lipstick." ;)
16:59:11 <ReinH> augur: I think sublime text is popular with some people. Not with me though.
17:00:27 <ReinH> cjheath: Well, perhaps no one who is paying attention at the moment. I'm sure some ppl here use it.
17:04:33 <Luke> is there a shake channel?
17:05:20 <Cale> Luke: I don't know, but it wouldn't be too out of place if you asked here
17:05:41 <Luke> I'm having an issue where tasks are rerunning even though the target files haven't changed
17:05:48 <Luke> not sure the best way to track down the issue
17:06:08 <Luke> I even changed to the digest mode for change detection and confirmed md5 hasn't changed
17:14:56 <Fylwind> even Stackage nightly has only cabal-install 1.18 :(
17:16:12 <Cale> Luke: hmm...
17:16:43 <Luke> correct me if I'm wrong but if the target link doesn't change then the action shouldn't run
17:16:53 <Luke> s/target link/target/
17:17:23 <Cale> Luke: I'm pretty sure that's the whole point of the thing :)
17:17:41 <Luke> right... i'm not sure where to get debug input on why shake is doing something
17:18:13 <Cale> Luke: What's in the .shake file?
17:18:44 <Luke> it's a folder with .database in it
17:18:44 * hackagebot pointful 1.0.4 - Pointful refactoring tool  http://hackage.haskell.org/package/pointful-1.0.4 (MikhailGlushenkov)
17:22:02 <Cale> Luke: ah, and looking through its code, Shake stores that in binary...
17:22:21 <Luke> stores what in binary?
17:22:27 <Cale> Its database
17:23:20 <Luke> oh - yeah
17:23:26 <Luke> unfortunately
17:23:45 * hackagebot pointful 1.0.5 - Pointful refactoring tool  http://hackage.haskell.org/package/pointful-1.0.5 (MikhailGlushenkov)
17:24:42 <Luke> is .shake used for something else? In my config I set .shake as the folder for shake to use
17:25:11 <Cale> I think that's the default anyway
17:27:49 <funfunctor> hi
17:28:47 <funfunctor> suppose I wish to have a thread that increments a clock counter exposed via a UDP socket. What is the usual design flow for this kind of interthread messaging in Haskell?
17:30:18 <Luke> Cale: the default is a file .shake.database
17:30:34 <Luke> Cale: still doesn't seem to help
17:30:51 <funfunctor> I'm guessing MVar
17:32:37 <imalsogreg> funfunctor: That would work. I think TVar may be even easier, if the other (non UDP
17:32:41 <Cale> funfunctor: I don't exactly know what "exposed via a UDP socket" means exactly, but an MVar probably won't be too out of place for a counter where you don't want to miss updates
17:32:59 <imalsogreg> - listening) thread does anything complicated.
17:34:11 <funfunctor> well I am just emulating some pretty poor behavior so I can fit in with the rest of the stack. But it has a clock main loop that fires upon various call sites littered around the code
17:35:54 <Cale> funfunctor: If you want to have a thread that manages sending messages over a UDP socket, you might consider having it read its messages from a Chan, and other threads write to the Chan in order to get their message into queue.
17:36:24 <funfunctor> Cale: yea something like that
17:36:34 <funfunctor> wonder how that would be done?
17:37:17 <lpaste> funfunctor pasted “No title” at http://lpaste.net/128172
17:37:29 <funfunctor> ^ thats my clock thread so far
17:40:56 <Cale> So, you want procClockMessages to be getting the messages to send from elsewhere in the program?
17:41:06 <Fylwind> does anyone know what syntax is in ~/.cabal/world ?
17:41:18 <Fylwind> I couldn't find any docs on it
17:42:19 <Cale> Fylwind: I don't know exactly, but it appears to be one package per line, followed by a space, followed by either -any or a version constraint in the usual syntax like ==1.1.4
17:42:48 <Cale> I see an ==0.4.*
17:42:50 <Fylwind> I see
17:43:02 <bernalex> f n p = unlines [unwords $ replicate (n - abs x) p | x <- [1 - n .. n - 1]] -- the best I've got golfing for me atm.
17:43:13 <Cale> Probably inequality bounds work, but I don't have any examples of those in mine
17:43:58 <Fylwind> do you mind linking a short example?
17:44:24 <Cale> http://lpaste.net/128173
17:51:41 <seafood> What library do people use for parsing command line arguments?
17:51:49 <seafood> (The last one I used was GetArgs)
17:52:10 <seafood> Sorry, GetOpt
17:52:52 <enthropy> I think the most popular are cmdargs and optparse-applicative
17:52:55 <glguy> I use System.Console.GetOpt or sometimes Iavor's simplified interface to it http://hackage.haskell.org/package/simple-get-opt
17:56:12 <seafood> glguy: I’ve used GetOpt before and was looking to try something else.
18:02:22 <funfunctor> Cale: thats correct yes
18:02:31 <timothyh> optparse-applicative is also ok
18:02:41 <negatratoron> writing haskell makes me giddy
18:02:44 <negatratoron> is that normal?
18:04:46 <Cale> funfunctor: So in the main thread, before you fork, you'll have something like  c <- newChan  and then you'll want to pass (readChan c) to the procClockMessages function which you forkIO, and pass (writeChan c) to the rest of the program.
18:05:07 <Cale> negatratoron: Yeah, sometimes :D
18:05:51 <negatratoron> i can't believe much better the software to code ratio is over here
18:06:05 <negatratoron> alright /me goes back
18:06:09 <funfunctor> Cale: actually I am doing parallel_ [controlLoop trx, clockLoop trx, dataLoop trx] >> stopGlobalPool
18:06:10 <funfunctor>  what is the difference between that and forkIO ?
18:06:59 <Cale> What library is that?
18:07:22 <Cale> Control.Concurrent.forkIO is the standard basic way to create a new thread
18:07:36 <Iceland_jack> <negatratoron> writing haskell makes me giddy
18:07:36 <Iceland_jack> <negatratoron> is that normal?
18:07:37 <Iceland_jack> I sure hope so
18:08:21 <bibaijin2014>  /quit
18:09:45 <funfunctor> Cale: thats import Control.Concurrent.ParallelIO.Global
18:12:48 <Cale> funfunctor: I guess this library is okay. I probably wouldn't just start off with using it unless I foresaw that I'd need lots of careful management of my running threads. For just one additional thread that manages a socket, I think it's overkill.
18:14:09 <funfunctor> Cale: its gearing up so there is three sets of UDP sockets for each arfcn :: Int
18:14:23 <Fylwind> why is installing profiling libraries so painful :(
18:14:28 <funfunctor> currently I am just fixing it so that I only manage one arfcn
18:14:28 <Fylwind> profiled*
18:14:45 <Cale> funfunctor: Yeah, I don't know the rest of what you're doing, so it's quite possible that you'll end up needing thread pools I suppose.
18:14:57 <Cale> Fylwind: Because of bad defaults :(
18:15:16 <Fylwind> my issue is this: the boot packages that came with GHC don't have profiling
18:15:21 <Fylwind> so I have to reinstall all of those
18:15:22 <Cale> oh, what?
18:15:32 <Cale> Where'd you get your GHC?
18:15:41 <funfunctor> Cale: i'm still a little confused how to adapt the above code to have this channel idea so that messages are blocked until it gets a "ok" signal
18:15:45 <Fylwind> actually I'm not sure if they are boot packages
18:15:57 <Fylwind> Cale: official Arch repo
18:16:10 <Cale> Fylwind: Often a problem is the packages which got installed when you hand-bootstrapped cabal-install.
18:16:35 <Cale> But if you're using your repo's packages, that just means they split up the profiling libraries
18:16:39 <Fylwind> I think it's because of xmonad, which depends on a few packages, and they were install globally w/out profiling
18:16:44 <Cale> There are probably other repo packages for them
18:16:47 <funfunctor> :t newChan
18:16:48 <lambdabot> Not in scope: ‘newChan’
18:16:52 <Fylwind> and xmonad is installed from the Arch Repo
18:16:54 <funfunctor> @hoogle newChan
18:16:55 <lambdabot> Control.Concurrent.Chan newChan :: IO (Chan a)
18:17:05 <Cale> @hoogle readChan
18:17:05 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
18:17:09 <Cale> @hoogle writeChan
18:17:09 <lambdabot> Control.Concurrent.Chan writeChan :: Chan a -> a -> IO ()
18:17:18 <Cale> ^^ pretty much everything you need to know about Chan
18:17:21 <funfunctor> yep I was just trying to find where it was
18:17:57 <nshepperd> Fylwind: the packages that come with ghc are compiled with profiling, afaik, but those with xmonad probably aren't
18:18:09 <Fylwind> nshepperd: hmm
18:18:29 <Fylwind> I should dig into this more and find out where data-default-* is coming from
18:18:35 <Fylwind> that, and stm
18:18:39 <nshepperd> you're probably better off cabal installing xmonad
18:20:05 <Fylwind> oh, there's a variable PKGBUILD_HASKELL_ENABLE_PROFILING
18:20:16 <Cale> Honestly, I never use my system package manager for anything Haskell related because it's just way more frustrating than just installing the generic linux binary GHC, and then cabal-install
18:20:52 <Fylwind> Cale: yeah, I just hoped Arch would be a bit better :\
18:20:54 <Cale> Every distribution splits up GHC into 100 tiny pieces
18:20:55 <negatratoron> the system package manager would be liable to have older versions too
18:21:02 <Cale> and you end up missing some of those and hating yourself
18:21:19 <Cale> yeah, and it's usually out of date too, that's another reason
18:22:10 <Fylwind> one issue I've found is that, if I have locally compiled packages that depend on the packages from the package manager
18:22:19 <Fylwind> and it gets upgraded, then it will break all of my local packages
18:22:34 <Fylwind> all of my local packages that depend on it* of course
18:23:27 <Fylwind> I admit I just like being lazy and 'sudo pacman -S ghc' rather than follow a more complicated set of procedures
18:27:03 <Fylwind> alright so it looks like: PKGBUILD_HASKELL_ENABLE_PROFILING=1 should be set … probably worth adding to the ArchWiki
18:33:48 * hackagebot parsec 3.1.9 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.9 (AntoineLatter)
18:34:44 <Fylwind> bright red warning on the ArchWiki page for Haskell:
18:34:44 <Fylwind> "Warning: Discouraged method, keep in mind that cabal-install is not a package manager."
18:35:11 <Fylwind> yet everyone seems to do it anyway :\
18:36:56 <c74d> I would say that it *is* a package manager, just a feature-poor, annoying, and critically insecure one.
18:38:25 <hpc> ghc-pkg is the package manager
18:39:03 <c74d> If one's OS package manager doesn't satisfy, there's always Nix, which seems to keep up-to-date on Haskell things.
18:39:55 <Cale> Fylwind: Well, right, it's a tool for *installing* packages, but not managing them.
18:40:41 <hpc> it's sort of the same as "linux isn't the operating system", but the other way around
18:40:53 <Fylwind> right, I just think the phrase is a bit overused now
18:42:07 <nshepperd> cabal-install is half of a package manager
18:42:16 <nshepperd> unfortunately
18:43:46 <glguy> Make is also a terrible package manager
18:55:14 <funfunctor> Is readChan blocking?
18:55:51 <glguy> yes
18:56:07 <funfunctor> glguy: the docs really should specify it
18:56:13 <glguy> ok
18:56:34 <funfunctor> no idea who maintains that?
18:58:35 <glguy> The Core libraries committee is the ultimate maintainer, there's no one person in charge of it
18:58:49 * hackagebot haskeline 0.7.2.1 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.2.1 (JudahJacobson)
18:59:48 <RustyShackleford> is the convention to name source files Main.hs or main.hs
18:59:53 <RustyShackleford> does it matter either way?
19:00:03 <glguy> They should be capitalized the same way as the module name
19:00:12 <glguy> and the first letter of module names are capitalized
19:00:32 <RustyShackleford> CapsCase or whatever it's called?
19:01:06 <glguy> You can capitalize the rest of the letters however you want
19:01:37 <glguy> It's extremely common to capitalize the first letter of each word in the module name
19:01:43 <funfunctor> hmm thread blocked indefinitely in an MVar operation !
19:02:22 <glguy> funfunctor: That means you were trying to read from a chan with no threads that could write to it
19:02:29 <ackthet> do you need ghc-mod for syntastic to work with haskell?
19:02:55 <funfunctor> glguy: so it throws an exception if threads are not started in the correct order
19:03:08 <funfunctor> clever
19:03:11 <glguy> it throws an exception when it's deadlocked
19:03:17 <glguy> not because of the order
19:05:36 <dzack> has anyone run into cabal install crashing while updating the index cache file?
19:05:54 <dzack> (new install here, ubuntu)
19:07:28 <funfunctor> glguy: can you help me with this channel business http://lpaste.net/128174#line257  writeClock here isn't appearing to fire the procClockMessages loop into doing anything
19:09:10 <funfunctor> i'm doing the following to start the threads,   trx <- constructTransceiver 1 1 5700
19:09:10 <funfunctor>   parallel_ [controlLoop trx, clockLoop trx] >> stopGlobalPool
19:09:51 <glguy> What's parallel_?
19:10:33 <glguy> I don't think you're supposed to run withSocketsDo more than once, incidentally. Usually it
19:10:41 <glguy> is at the top of your main definition
19:11:06 <funfunctor> glguy: but I am creating several socks
19:11:12 <glguy> that's fine
19:11:23 <glguy> That function is for initializing the socket library on windows
19:11:27 <glguy> not for making a new socket
19:11:39 <funfunctor> ohhh ok..
19:11:46 <funfunctor> well I am not even on windows
19:13:11 <glguy> Well, it's possible parallel_ doesn't do what you think it so (I don't know what it does other than its name)
19:13:20 <glguy> or that you have two different Chans
19:13:29 <glguy> or that you aren't using the threaded runtime
19:13:42 <funfunctor> threaed runtime?
19:13:51 <funfunctor> s/threaded
19:14:11 <glguy> Try making your executable with the -threaded flag to GHC
19:14:21 <funfunctor> ah ok
19:15:02 <funfunctor> how do you do that in cabal files?
19:15:08 <funfunctor> flag: -threaded ?
19:15:30 <glguy> ghc-options: -threaded
19:17:01 <funfunctor> ta! yea that didn't help
19:17:24 <funfunctor> @hoogle parallel_
19:17:25 <lambdabot> No results found
19:18:48 <funfunctor> glguy: Control.Concurrent.ParallelIO.Global
19:18:50 * hackagebot conduit-audio 0.1 - Combinators to efficiently slice and dice audio streams  http://hackage.haskell.org/package/conduit-audio-0.1 (mtolly)
19:18:52 * hackagebot conduit-audio-sndfile 0.1 - conduit-audio interface to the libsndfile audio file library  http://hackage.haskell.org/package/conduit-audio-sndfile-0.1 (mtolly)
19:18:54 * hackagebot conduit-audio-lame 0.1 - conduit-audio interface to the LAME MP3 library  http://hackage.haskell.org/package/conduit-audio-lame-0.1 (mtolly)
19:18:56 * hackagebot conduit-audio-samplerate 0.1 - conduit-audio interface to the libsamplerate resampling library  http://hackage.haskell.org/package/conduit-audio-samplerate-0.1 (mtolly)
19:20:01 <glguy> https://hackage.haskell.org/package/parallel-io-0.3.2/docs/Control-Concurrent-ParallelIO-Global.html
19:20:07 <glguy> Check out the line under the code sample
19:20:24 <glguy> So what's probably happening is that you're using a threadpool abstraction with a single thread
19:22:43 <glguy> I don't think threadpools are the right fit for the code you pasted
19:23:44 <funfunctor> glguy: ok I have ghc-options:         -threaded +RTS -N2 -RTS
19:23:52 <funfunctor> still not behaving
19:24:34 <glguy> if it's not working once the threadpool code is gone we can try other things
19:25:16 <funfunctor> glguy: sure ok, so should I leave those ghc-options as is for the moment?
19:26:20 <glguy> +RTS -N2 isn't a a ghc opgtion
19:26:26 <glguy> option, it's an option to your executable
19:28:52 <funfunctor> glguy: ok how do I stick that in?
19:30:48 <funfunctor> glguy: cabal doc is very wordy without much content
19:32:18 <funfunctor> would that be cc-option: ?
19:33:42 <barrucadu> It's not in the cabal file, it's when you run your binary, eg: ./dist/build/foo/foo +RTS -N2
19:37:35 <min> Can I ask a programming language theory question here? Is there a standard algorithm that takes a context-free grammar and returns something like a regular grammar that generates every string generated by the context-free grammar, but whose language is the least divergent (up to some equivalence) from the context-free one? I seem to remember something like this, but the internet wasn't very helpful. I figured #haskell would know.
19:40:09 <pavonia> min: You can't transform any CFG into a regular one in general
19:40:56 <pavonia> Maybe I'm misunderstanding the question
19:44:08 <min> pavonia: Right - I'm wondering whether there is a useful notion of the "least-divergent" regular grammar for a given context-free one, in the sense that the language of the CFG diverges "least" from the language of the regular grammar (up to some equivalence).
19:45:28 <pavonia> I don't know what divergent mean in that context
19:45:32 <nshepperd> "regular approximation to cfg" turns up a few results on google
19:47:03 <min> nshepperd: "Regular approximations" looks like what I was looking for - thanks.
19:50:37 <jle`> GADTs really were invented since the 70's?
19:50:42 <jle`> haskell is so slow to adopt new things
19:59:37 <HeladoDeBrownie> yeah, just look how long it took haskell to get java member update technology
20:01:11 <jle`> have to find myself an actual modern language then that stays ahead of the trends
20:01:57 <Fylwind> where did Numeric.GSL go?  I see it in the docs for hmatrix for older versions but nothing for new ones
20:02:24 <Fylwind> oh nvm it got split off into hmatrix-gsl
20:02:45 <dfeuer> Is there a reason that attoparsec's parseWith yields an IResult, when an IResult can be Partial? Shouldn't parseWith always produce either Fail or Done?
20:03:04 <Fylwind> dfeuer: maybe it's because it's incremental?
20:03:36 <dfeuer> Fylwind, that's why parse does that.
20:03:49 <dfeuer> But if I understand it correctly, parseWith shouldn't.
20:03:52 * hackagebot picoparsec 0.1.2 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/picoparsec-0.1.2 (MarioBlazevic)
20:04:18 <jle`> is femtoparsec coming next?
20:04:37 <dfeuer> Fylwind, parseWith takes an action it can use to get more input when needed.
20:05:24 <dfeuer> Even my extremely minor messing around with attoparsec today really helps explain why pipes-attoparsec is a good idea, but it's just slightly beyond my ability to understand.
20:05:51 <Fylwind> dfeuer: perhaps it's so that you can still run more 'parseWith' afterwards just in case?
20:07:38 <dfeuer> Fylwind, I don't see how that could make sense, really.
20:08:32 <Fylwind> or maybe it's was just a design decision, since they seem to use mempty for EOF
20:11:24 <HeladoDeBrownie> endOfInput? as mempty? i can't think of what operation that would be the monoidal identity of
20:11:38 <Fylwind> parseWith refill p s = step $ parse p s
20:11:38 <Fylwind>   where step (T.Partial k) = (step . k) =<< refill
20:11:38 <Fylwind>         step r             = return r
20:12:33 <glguy> HeladoDeBrownie: just means that empty string is used for eof
20:12:36 <glguy> nothing really to do with monoids
20:12:49 <Fylwind> dfeuer: I guess you right, it can never return Partial
20:12:59 <HeladoDeBrownie> mempty is a method of monoid. so perhaps i misunderstood the original statement.
20:13:03 <dfeuer> Weird, eh?
20:13:18 <glguy> HeladoDeBrownie: It's a coincidence that it's mempty
20:14:00 <Fylwind> HeladoDeBrownie: I'm referring to the fact that Attoparsec uses the empty string as a sentinel value for EOF in the Partial continuation
20:14:15 <HeladoDeBrownie> the empty ByteString?
20:14:34 <Fylwind> yup
20:14:38 <HeladoDeBrownie> okay, that makes sense
20:17:54 <jle`> edwardk: would this 'data UnFree t m a = UnFree ((forall x. t m x -> m x) -> t m a)' have any place in your hierarchy of monadey structuring/destructuring tools?
20:17:58 <jle`> http://stackoverflow.com/a/29186217/292731
20:20:25 <edwardk> jle`: that one is a bit weird
20:21:06 <jle`> it's a monad transformer that operates with a global "untransformer" in context
20:21:21 <jle`> i wonder if it's a part of a bigger picture
20:21:28 <jle`> other than as a way to write that MonadFix instance
20:21:38 <shachaf> They're calling it "ReaderT", but the "environment" has access to m.
20:21:43 <shachaf> That's not very Readery.
20:23:12 <edwardk> jle`: yes, the main concern i'd have is that the monad homomorphism from t m to m almost suredly loses something in the translation making this thing a bit messy to use
20:29:14 <jle`> do you mean that its usage is unpredictable/unweildy/messy, or that its analysis is messy?
20:53:54 * hackagebot hjsonschema 0.5.0.0 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.0.0 (seagreen)
21:06:00 <funfunctor> ok how do I use forkIO without my main exiting? probably misunderstanding something..
21:06:39 <glguy> You have your main wait for notification that the threads are done
21:06:48 <glguy> When main exits the program exists
21:06:50 <glguy> exits*
21:07:18 <funfunctor> glguy: how do get main :: IO () to wait on its forkIO ThreadID's?
21:07:59 <Hijiri> have it wait on an mvar that the forked thread fills
21:08:38 <funfunctor> ah ok, a binary semaphore MVar ()
21:10:02 <funfunctor> one other thing, suppose I have n :: Int and I wish to create n threads so that I have (k, ThreadID) with 0 \leq k < n what is a good pattern for that since no for loops
21:10:36 <funfunctor> recursion is one idea but I thinking maybe some neat one-liner
21:11:07 <glguy> we have "for loops":   for_ [1..k] $ \i -> stuff with i
21:11:24 <glguy> if you want k threads: replicateM k (forkIO something)
21:11:41 <glguy> (assuming you want them all to be doing the same "something"
21:11:57 * glguy is interleaving IRC chat with Mario Kart races
21:13:37 <funfunctor> glguy: thx :)
21:13:51 <funfunctor> never knew about for_
21:13:53 <funfunctor> :t for_
21:13:54 <lambdabot>     Not in scope: ‘for_’
21:13:54 <lambdabot>     Perhaps you meant one of these:
21:13:54 <lambdabot>       ‘F.for_’ (imported from Data.Foldable),
21:14:06 <funfunctor> :t replicateM
21:14:06 <lambdabot> Monad m => Int -> m a -> m [a]
21:14:35 <abg> Is there much of a runtime cost of using singletons to enforce safety at compile time?
21:15:31 <glguy> for_ is in Data.Functor, for is in Data.Traversable
21:15:42 <glguy> for_ is for when you don't need the results, for is when you do
21:16:13 <Gomboc> so I'm just getting started with template haskell. How do I get the type of a an expression in a data structure?
21:16:15 <funfunctor> glguy: ah ok, well I want to have the ThreadID matched with the key (k, ThreadID)
21:16:45 <funfunctor> @hoogle replicateM
21:16:46 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
21:16:46 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
21:16:46 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
21:19:01 <glguy> funfunctor: and they all do the same thing?
21:19:43 <funfunctor> glguy: yep, replicateM arfcns (forkIO $ controlLoop trx)  where arfcns :: Int
21:22:36 <glguy> for [0..k-1] $ \i -> do tid <- forkIO (controlLoop trx); return (i,tid)
21:23:39 <funfunctor> glguy: ah I was wondering around Control.Monad looking for something like replicateM but not
21:23:41 <funfunctor> thx
21:23:54 <funfunctor> btw, what is MonadPlus for exactly?
21:27:57 <glguy> it's for Monad's with an associative operation with an identity where mzero >>= _ = mzero. It's kind of all over the place
21:28:09 <glguy> it tends to get used for things that support a notion of alternatives
21:30:52 <funfunctor> ah ok
21:40:22 <funfunctor> :t for
21:40:23 <lambdabot>     Not in scope: ‘for’
21:40:23 <lambdabot>     Perhaps you meant one of these:
21:40:23 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
21:40:24 <funfunctor> :t forM
21:40:25 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
21:40:33 <funfunctor> glguy: did you mean forM ?
21:40:44 <funfunctor> no that cant be right
21:40:49 <glguy> I meant Data.Traversable.for
21:40:52 <glguy> forM is the old one
21:41:00 <glguy> lambdabot calls it T.for
21:45:34 <funfunctor> ah ok thx sorry, my eye missed that
22:38:46 <carter> glguy: i'm kinda stoked about how much more fun typeable will be in 7.10 :)
22:38:50 <carter> :)))
22:39:15 <glguy> so many instances
22:39:17 <glguy> so little time
22:39:22 <carter> ALL OF THEM
22:39:25 <carter> for FREEE
22:39:31 <carter> (ignoring *.hi space usage)
22:39:48 <kaidelong> so this means Haskell is getting reflection?
22:39:54 <carter> kaidelong: it had it already
22:40:01 <carter> its just before you had to rub deriving on everything
22:40:10 <glguy> arbitrary type variables won't automatically be Typeable
22:40:17 <kaidelong> yeah but the advantage of that is that you don't need RTTI everywhere
22:40:18 <glguy> but all concrete types will have instances of the class
22:40:21 <carter> you'll have to add Typeable a => 
22:40:34 <kaidelong> .NET paid in performance over java for supporting reflection
22:40:34 <carter> kaidelong: no, its still a normal type class wrt use sites
22:40:53 <carter> no runtime reflection if you dont have a typeable instance passed in
22:41:05 <carter> its just every mono type WILL have a typeable instance
22:41:39 <carter> so when composing polymoprhic things, you'd need to push up the typeable constraints to get things to compose if you wanna use typeable on the insided
22:42:18 <carter> glguy:, for my uses, i think i could get away with doing type TNum a = (Typeable a, Num a)
22:42:19 <isBEKaml> so, when is 7.10 landing?
22:42:28 <carter> isBEKaml: pretty soon
22:42:30 <isBEKaml> it's in RC right now, right?
22:42:32 <carter> yeah
22:42:38 <isBEKaml> \o/
22:42:55 <carter> do :  git clone --branch ghc-7.10 --recursive git://git.haskell.org/ghc.git  ghc-7.10
22:43:06 <carter> then perl boot ; ./configure ; make
22:43:11 <carter> if you wanna build it right nowww
22:43:19 <glguy> carter: this change actually reduces .hi size for non-users
22:43:27 <funfunctor> does this smell bad? :: Chan (MVar Int) ?
22:43:30 <carter> glguy: oh? how so?
22:43:42 <carter> funfunctor: depends on the goal
22:43:44 <glguy> The typerep is constructed as the use-site, it doesn't live in the module
22:43:53 <carter> ohh
22:43:57 <carter> really?
22:44:08 <carter> ooh
22:44:15 <glguy> Why would I joke about that?
22:44:17 <carter> because it just needs name + module + pkg 
22:44:20 <funfunctor> carter looking to create a thread that writes clock increments
22:44:22 <carter> unlike Data
22:44:33 <carter> which needs more info
22:44:37 <glguy> yeah
22:59:36 <lpaste> funfunctor pasted “No title” at http://lpaste.net/128181
22:59:57 <funfunctor> can anyone see where the dead lock is in writeClock :: Transceiver -> IO () ?
23:02:08 <HeladoDeBrownie> funfunctor, no, because it's not shown how/where writeClock is invoked.
23:02:28 <HeladoDeBrownie> funfunctor, things that *could* deadlock include reading a chan and taking an mvar.
23:02:37 <HeladoDeBrownie> also putting an mvar.
23:04:07 <HeladoDeBrownie> if you take the MVar, and something else was trying to write to it, and succeeds, the next time you try to write to it will block. just as an example. may or may not be the problem.
23:04:21 <HeladoDeBrownie> (unless there was a take between the writes)
23:09:17 <rola> Stephanie Weirich's super informative talk on using and implementing a dependently lang: https://www.youtube.com/watch?v=6klfKLBnz9k
23:13:16 <funfunctor> HeladoDeBrownie: well the idea was for it to be called in different places from other threads to increment the clock
23:13:43 <funfunctor> HeladoDeBrownie: unfortunately I have to implement this shitty idea to emulate poor C++ code..
23:14:29 <funfunctor> maybe I should use IORef and atomic updates?
23:21:24 <HeladoDeBrownie> i'm not sure that'd be better
23:21:51 <HeladoDeBrownie> i usually default to TVar unless i have a reason not to, has worked for me so far. not sure how helpful that'd be to you though
23:22:15 <HeladoDeBrownie> TVar gives you transactions and the strongest guarantees of all of those three mutable containers
23:22:50 <HeladoDeBrownie> the tradeoff is if a transaction fails it may be performed over and over until it succeeds. but this may not be so bad if you were going to have lots of failures anyway
23:24:32 <funfunctor> HeladoDeBrownie: well I would kind of like to know whats going on
23:24:49 <HeladoDeBrownie> i don't have enough information to say beyond what i've said
23:25:07 <HeladoDeBrownie> look at all the things i mentioned that can block and see what elsewhere might cause them to block
23:25:22 <HeladoDeBrownie> e.g., empty MVar, empty Chan
23:25:27 <HeladoDeBrownie> full MVar
23:25:48 <HeladoDeBrownie> (for taking an MVar, reading a Chan, and putting an MVar, respectively)
23:26:19 <funfunctor> yep, I think its actually readChan
23:27:20 <funfunctor> HeladoDeBrownie: i'm using readChan as-if it reads the previous value from the Channel but that is clearly wrong
23:27:43 <funfunctor> so I need to figure out how to unwrap out the Chan so I can get to the MVar wrapped in it
23:28:21 <funfunctor> but I think Chan (MVar Int) is wrong, maybe it should be MVar (Chan Int)
23:29:00 <funfunctor> actually, maybe I should just forget Chan
23:29:26 <HeladoDeBrownie> i don't follow on why you need to peek into the Chan's implementation
23:29:56 <funfunctor> i've massively confused myself..
23:30:27 <funfunctor> can Chan give me the previous value so I can increment it?
23:35:53 <funfunctor> HeladoDeBrownie: thx I got it to work
23:39:03 <HeladoDeBrownie> i don't know what you mean about "previous value", but glad you got it working
