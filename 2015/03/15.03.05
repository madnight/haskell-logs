00:02:04 <brbblnch> hi
00:02:11 <brbblnch> Does the Curry-Howard Correspondence require that you build typed lambda calculus with ordered pairs and projections as primitives, or can you just use (application+abstraction) ? (Because for a proof of  $A \land B$ you need the ordered pair $(a,b)$ of proofs of A and B, of type $A \times B$, whych you can't get from only types of the form $X -> Y$…)
00:04:25 <Ralith> brbblnch: can't you just represent a pair as \f -> f a b?
00:05:06 <brbblnch> Ralith: (note that I'm not sure of anything, that's why I asked). The problem is that 
00:05:10 <shachaf> You need some sort of polymorphism for that.
00:05:15 <dmwit> brbblnch: You can include ordered pairs or not; then you get different logics out of the isomorphism.
00:05:16 <brbblnch> … the type isn't good
00:05:57 <dmwit> Though they may not be different in any "important" way, which can be an interesting theorem.
00:06:11 <dmwit> metatheorem
00:06:23 <brbblnch> dmwit: You mean (including pair => I can use the \land connector), (not including => no \land) ?
00:06:30 <dmwit> right
00:07:08 <brbblnch> dmwit: But I'm right in thinking that you can't create the "ordered pair type" from the "X->Y" type ?
00:07:28 <dmwit> There are various encodings of data types.
00:07:41 <dmwit> The Church encoding is a popular one.
00:08:17 <brbblnch> but that doesn't take care of types
00:08:24 <dmwit> I don't know what you mean.
00:08:33 <shachaf> But you can't use that in a typed lambda calculus without some sort of polymorphism.
00:09:21 * hackagebot temporal-csound 0.4.3 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.3 (AntonKholomiov)
00:09:21 * hackagebot temporal-csound 0.4.3.1 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.3.1 (AntonKholomiov)
00:09:50 <brbblnch> Let's say I want to prove the correspondence with classical natural deduction with all connectors. Let's say I build my typed lambda-calculus only from application+abstraction. I won't be able to do my proof because I didn't include the ordered pair ?
00:10:36 <brbblnch> dmwit: (That's what I mean)
00:11:04 <dmwit> Um. Curry-Howard says if you have a logic, you can produce a language out of it "for free". And vice versa. It doesn't say arbitrary logic-language pairs are related in any meaningful way.
00:12:12 <brbblnch> dmwit: I'm actually trying to understand/do the proof of Curry-Howard: The essence of my question is: will I be blocked if I don't include the ordered pair in my language?
00:12:53 <dmwit> The question is backwards.
00:13:05 <brbblnch> dmwit: ?
00:13:08 <dmwit> If you "turn the crank", the language you will get out will have an ordered pair primitive.
00:14:07 <brbblnch> dmwit: ok
00:14:28 <brbblnch> Thanks all
00:15:25 <brbblnch> I've got another question: in untyped: you can do :  \z -> zuv to get an ordered pair, is that typable?
00:15:43 <dmwit> :t \u v -> \z -> z u v
00:15:44 <lambdabot> t1 -> t2 -> (t1 -> t2 -> t) -> t
00:16:12 <dmwit> yes =)
00:17:05 <brbblnch> And the church encoding still works in typed?
00:17:19 <Yaniel> > isMark 'ä'
00:17:20 <lambdabot>  False
00:17:29 <Yaniel> > isMark '¨'
00:17:30 <lambdabot>  False
00:17:44 <dmwit> brbblnch: As shachaf said, it depends how exciting your type language is.
00:17:54 <Rotaerk> > isMark mark
00:17:55 <lambdabot>  Not in scope: ‘mark’
00:17:55 <lambdabot>  Perhaps you meant ‘mask’ (imported from Control.Exception)
00:18:03 <dmwit> Haskell's isn't quite rich enough for "real" Church encodings, but with enough GHC extensions it is.
00:18:49 <HeladoDeBrownie> general haskell programming strategy: haskell not expressive enough? throw ghc extensions at it till you can express what you wanted
00:18:49 <dmwit> (By way of an existence proof that there are typed languages that are exciting enough and typed languages that are not exciting enough.)
00:19:35 <tdammers> HeladoDeBrownie: general haskell programming strategy: haskell not expressive enough? complain about lack of dependent types and mutter something about Idris in #haskell
00:19:51 <HeladoDeBrownie> tdammers, i was trying to find some way to bring that topic up but failed
00:20:27 <HeladoDeBrownie> (possibly because i should be in bed)
00:20:29 <dmwit> General #haskell trolling strategy: Haskell's type system not expressive enough? Use a *real* static analysis tool.
00:20:40 <HeladoDeBrownie> dmwit, just write it in coq
00:20:47 <brbblnch> dmwit: As far as I know, you use the church encoding to prove that lambda calculus can compute "Computable Functions" (ie it is equivalent to Turing machines), isn't it problematic then ?
00:20:54 <dmwit> HeladoDeBrownie: What, and do the machine's work for it?
00:20:58 <HeladoDeBrownie> coq can do i/o, right?
00:21:06 <tdammers> we need a meta-coq
00:21:10 <L8D> how do I read a single Word8 from input?
00:21:12 <dmwit> brbblnch: different Church encoding
00:21:19 <dmwit> brbblnch: ...I think.
00:21:36 <acetoline> coq needs to be bigger
00:21:41 <dmwit> brbblnch: But even so I'm not sure what would make you think that's problematic.
00:22:10 <tdammers> acetoline: size isn't everything. I bet coq can prove that.
00:22:24 <L8D> is there a Char -> Word8 function?
00:22:25 <dmwit> L8D: Binary, ByteString, or latin1 encoding
00:22:36 <HeladoDeBrownie> i bet you can use coq to prove that, for an arbitrary natural number, there is always one greater
00:22:47 <acetoline> L8D: use hoogle
00:22:54 <L8D> acetoline: I did
00:22:58 <HeladoDeBrownie> let's see
00:23:00 <HeladoDeBrownie> @hoogle Char -> Word8
00:23:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:23:02 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
00:23:02 <lambdabot> Prelude error :: [Char] -> a
00:23:06 <HeladoDeBrownie> yep that looks pretty unhelpful
00:23:07 <brbblnch> dmwit: Well typed is less powerful than untyped, but is still powerful (equivalent to Primitive Recursive functions, right ?). So if you can't encode the basis… But I'm not sure of anything
00:23:08 <tdammers> L8D: what for?
00:23:14 <L8D> tdammers: brainfuck interpreter
00:23:22 <tdammers> why do you need Char for that?
00:23:22 <dmwit> L8D: hGet :: Handle -> Int -> IO ByteString gets a certain number of bytes
00:23:29 <HeladoDeBrownie> L8D, try reading in ByteStrings
00:23:35 <tdammers> I'd use Word8 / ByteString for everything
00:23:41 <tdammers> brainfuck doesn't need unicode really
00:23:45 <dmwit> brbblnch: There are Turing-complete typed languages.
00:23:49 <L8D> dmwit: that'll do it
00:24:10 <HeladoDeBrownie> dmwit, even ones whose type systems are consistent and complete logics?
00:24:11 <acetoline> did someone say brainfuck
00:24:37 <acetoline> I love brainfuck
00:24:52 <acetoline> I've written like 5 brainfuck interpreters
00:24:52 <dmwit> HeladoDeBrownie: Why restrict yourself in that way?
00:24:58 <Lokathor> wrote a brainfuck interpreter in python once
00:25:07 <HeladoDeBrownie> dmwit, because i'm afraid of how deep the rabbit hole goes, i guess? i dunno!
00:25:10 <Lokathor> was a slow afternoon
00:25:15 <acetoline> I wrote a fast C one with jit compilation
00:25:23 <brbblnch> dmwit: but isn't "classical" (if that exists) simply typed lambda-calculus equivalent to Prim. Rec. functions ?
00:25:39 <tdammers> doesn't "Turing complete" imply that Gödel's theorem applies?
00:25:42 <dmwit> STLC is strongly normalizing (hence not Turing complete).
00:26:09 <Lokathor> L8D, Char -> Word8 probably uses fromEnum or somesuch
00:26:13 <dmwit> But this is the very first time you've said "simply" in front of "typed". =)
00:26:21 <Zemyla> acetoline: I wrote an optimizing brainfuck interpreter.
00:26:27 <tdammers> Lokathor: Char -> Word8 is lossy
00:26:35 <Lokathor> well duh
00:26:40 <dmwit> Zemyla: In this channel, who hasn't? =P
00:26:50 * tdammers raises hand
00:27:04 <HeladoDeBrownie> i've written a bf interpreter but i don't know what it means for one to be "optimizing", specifically
00:27:09 <Lokathor> but this is a brainfuck interpreter, so there's a low more wrong with the situation than a lossy conversion
00:27:35 <HeladoDeBrownie> Lokathor, just because you're implementing a joke language doesn't mean you can't do it with style!
00:27:38 <brbblnch> dmwit: :), just to be clear, I'm just beginning to study all that, don't know what is what. And thank you for the explanations, it was really useful!
00:27:39 <tdammers> well, sure... for brainfuck you could simply ignore all non-brainfuck characters...
00:27:48 <Zemyla> HeladoDeBrownie: First off, turn ++ into *p+=2, >> into p+=2, and such.
00:27:57 <tdammers> still, reading in bytes rather than characters in the first place would be a better approach
00:28:17 <HeladoDeBrownie> Zemyla, eh, think i'll pass. optimization is the compiler's j—waitaminute… (:P)
00:28:21 <Lokathor> maybe. i don't think the language is well defined enough for it to make a difference
00:28:23 <dmwit> [-] to *p=0
00:28:53 <Zemyla> [->+<] to *(p+1) += *p, *p = 0.
00:28:57 <dmwit> There are bigger idioms to watch for, too. Addition, copying, that sort of thing.
00:29:00 <HeladoDeBrownie> i guess the real question is do translations like that even really matter
00:29:01 <dmwit> Can make a big difference.
00:29:14 <dmwit> HeladoDeBrownie: They can make a huge difference in runtime, yeah.
00:29:21 <dmwit> Whether that matters or not is up in the air.
00:29:28 <HeladoDeBrownie> hmm, okay
00:29:37 <tdammers> take a sha512 hash of your brainfuck program, match it against a dictionary of known programs
00:29:54 <brbblnch> dmwit: One last thing and I leave: Do you have a specific reference on typed lambda calculus, I know of "Barendregt" and "Krivine".
00:29:57 <Zemyla> http://calmerthanyouare.org/2015/01/07/optimizing-brainfuck.html
00:30:10 <dmwit> brbblnch: Everything I know is in TAPL.
00:30:12 <dmwit> ?where TAPL
00:30:12 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:30:41 <HeladoDeBrownie> tdammers, just compute an infinite dictionary of all possible bf programs mapped to their behavior and… um, where was i going with this?
00:31:14 <tdammers> HeladoDeBrownie: while you're at it, might as well tag the ones that don't terminate
00:31:17 <HeladoDeBrownie> yes
00:31:23 <brbblnch> dmwit: thanks
00:31:30 <tdammers> once you're done enumerating all the programs, that is
00:31:36 <HeladoDeBrownie> right
00:31:44 <tdammers> you could take it one step further
00:31:57 <tdammers> enumerate all possible programs *and* all possible inputs
00:32:16 <tdammers> then you don't need to run any programs at all, just do a simple lookup
00:32:20 <HeladoDeBrownie> ah yes, so that way you can just tell the user what to type, and spit out a constant string in response
00:32:23 <HeladoDeBrownie> perfect optimization
00:32:34 <tdammers> the other way around
00:32:41 <HeladoDeBrownie> i like my way better! :P
00:33:01 <tdammers> you have the user type stuff, then you look up the correct constant response based on the user's input and the desired program
00:33:35 <tdammers> actually, if we limit ourselves to practical input and program sizes, this could actually work
00:33:56 <HeladoDeBrownie> isn't that basically supercompilation
00:33:58 <quchen2> As long as "practical" means "2"
00:34:14 <tdammers> quchen2: 2 bits? I think we can do better
00:34:54 <xandaros> seeing that we have infinite possible programs and potentially infinite possible inputs, that'd be one hell of a lookup table
00:35:04 <tdammers> xandaros: that is the joke, yes
00:35:15 <HeladoDeBrownie> xandaros, just throw lazy evaluation at it, it's cool
00:35:39 <tdammers> HeladoDeBrownie: that's called "caching"
00:35:39 <xandaros> heh
00:35:42 <HeladoDeBrownie> if it's too strict, lazify it. if it's too lazy, strictify it
00:35:43 <quchen2> The easy part would determining whether a program terminates to find out how to put it into the lookup table.
00:35:46 <Zemyla> > 8^64
00:35:48 <lambdabot>  6277101735386680763835789423207666416102355444464034512896
00:36:16 <tdammers> quchen2: if there are only 256 programs or so to consider, might as well do it manually
00:36:40 <tdammers> HeladoDeBrownie: strictness and laziness are the duct tape and wd-40 of functional programming
00:36:49 <HeladoDeBrownie> tdammers, i was hoping someone would make that connection
00:36:59 <tdammers> :D
00:37:08 <Zemyla> Man, I wrote a program to make all the powersets of a list.
00:37:25 <dmwit> Is it filterM (const [False, True])?
00:37:33 <dmwit> If not, are you jealous of how awesome my program is now?
00:37:38 <Zemyla> And then I realized it wouldn't act sensibly for infinite lists.
00:38:26 <Zemyla> But then I realized afterwards that no program that enumerates powersets can act sensibly for infinite lists.
00:38:31 <Zemyla> :t filterM
00:38:32 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
00:38:34 <acetoline> well brainfuck isn't a 'joke' language
00:38:54 <HeladoDeBrownie> Zemyla, i bet it could, for some sense of "sensibly". you just need to enumerate the natural numbers in binary
00:38:57 <acetoline> it's based on P"
00:39:05 <acetoline> with added ascii i/o operations
00:39:12 <acetoline> it makes a lot of sense too
00:39:19 <acetoline> it just has an unfortunate name
00:39:31 <Zemyla> HeladoDeBrownie: You'd miss an infinite number of sets.
00:39:43 <mauke\> > filterM (pure [False, True]) [0 ..]
00:39:45 <lambdabot>  *Exception: stack overflow
00:39:47 <acetoline> the problem of the name can be solved though
00:39:52 <frerich> acetoline: BF makes a lot of sense for very small values of "a lot" only.
00:39:53 <acetoline> just write it B****fuck
00:39:55 <dmwit> HeladoDeBrownie: Something something, the reals are uncountable.
00:40:13 <HeladoDeBrownie> Zemyla, dmwit, yeah okay, point taken :P
00:40:34 <acetoline> frerich: I guess I'm the only guy who finds it intuitive
00:40:46 <acetoline> it should have numeric constants though
00:41:50 <Zemyla> acetoline: That's what a preprocessor is for.
00:41:59 <xandaros> brainfuck is not that bad to program, but try figuring out what your program does 5 minutes later
00:42:11 <HeladoDeBrownie> xandaros, that's what comments are for
00:42:42 <HeladoDeBrownie> and lucky for you you get to format them however you want without pesky # or // as long as you remember not to write . or , or several other characters
00:42:49 <acetoline> xandaros: brainfuck is hardly the worst offender here
00:42:49 <dmwit> [-] This line zeros the current cell and prints it out.
00:42:57 <acetoline> xandaros: C++ is much the same ;p
00:42:59 <Lokathor> brainfuck is better than literate haskell, the entire program is a literate program all the time!
00:43:01 <xandaros> HeladoDeBrownie: I disagree, a program should be self-descri ing
00:43:03 <HeladoDeBrownie> dmwit, i see no print
00:43:17 <HeladoDeBrownie> xandaros, agreed, but bf does not and cannot meet that standard
00:43:25 <dmwit> HeladoDeBrownie: Look again.
00:43:44 <HeladoDeBrownie> dmwit, never mind, forgot it prints characters and not the actual numbers
00:43:45 <mauke\> [-][ This line zeros the current cell. ]
00:43:46 <acetoline> I find C++ just as unreadable as brainfuck
00:43:51 <acetoline> and perl... far worse
00:44:07 <dmwit> mauke\: cute =)
00:44:13 <xandaros> fyfdyhfdyhcftuhcf valid perl
00:44:13 <mauke\> perl is much easier to parse than C++
00:44:36 <tdammers> C++ and perl at least have some sort of formal specification to them that you can learn
00:44:43 <mauke\> %#$@*$#&@ valid haskell
00:44:44 <Zemyla> mauke\: Only perl can parse Perl.
00:44:45 <acetoline> and brainfuck doesn't?
00:44:50 <tdammers> it does
00:44:55 * frerich hopes this of the merits of Perl/BF/C++ will eventually converge to Haskell :-}
00:45:00 <frerich> s/this/this discussion/
00:45:01 <tdammers> PHP doesn't
00:45:02 <mauke\> Zemyla: only lisp can parse Lisp
00:45:13 <Lokathor> mauke\, not true
00:45:15 <HeladoDeBrownie> xandaros, though, one can argue that "self-describing" is objective. for an extreme case, imagine trying to read code whose names are in a language you don't know, or with very undescriptive names. then, program structure is all that guides you.
00:45:19 <mauke\> Lokathor: why?
00:45:20 <HeladoDeBrownie> subjective*
00:45:31 <HeladoDeBrownie> xandaros, i said the opposite of what i meant in that first sentence :P
00:45:51 <Lokathor> mauke\, you can write a lisp interpreter or compiler in another language. Perl (at least perl5) only has the binary as a spec
00:46:03 <xandaros> HeladoDeBrownie: true
00:46:08 <HeladoDeBrownie> actually, this is practically a reality in haskell. it's *common* to write undescriptive variable names because there *is* no good description.
00:46:11 <tdammers> Lokathor: the word "parse" is ambiguous in Lisp though
00:46:11 <mauke\> Lokathor: that's besides the point
00:46:19 <acetoline> actually I never thought about that, it might be true that php has no formal specification
00:46:27 <acetoline> php is undecidable.
00:46:39 <tdammers> Lokathor: it can mean "byte streams to s-expressions", or "s-expressions to programs"
00:47:00 <HeladoDeBrownie> woops, when did it get to be 3am. bedtime, good niiiiiiiight~
00:47:03 <tdammers> acetoline: they are currently working on a formal specification for PHP
00:47:09 <acetoline> ahahahaha
00:47:12 <mauke\> Lokathor: "only perl can parse Perl" means "anything that parses Perl correctly must be a full Perl implementation"
00:47:12 <tdammers> acetoline: ("they" being facebook)
00:47:13 <acetoline> let me know how that turns out
00:47:27 <tdammers> my bet is I won't be around to witness that
00:47:35 <mauke\> i.e. your parser will be another "perl"
00:47:59 <Lokathor> well i've never met a tautology that i didn't meet, i guess
00:48:03 <acetoline> it figures that the worst site would use the worst language
00:48:23 <tdammers> mauke\: but that's pretty close to the Lisp saying that "every non-trivial program will at some point contain a bug-ridden ad-hoc implementation of half of Common Lisp"
00:48:54 <mauke\> I don't think so
00:48:59 <acetoline> if only that were true
00:49:11 <acetoline> more like a subset of lisp
00:49:14 <tdammers> personally, I prefer the saying that "every non-trivial program will at some point contain a bug-ridden ad-hoc implementation of half a type system"
00:49:15 <mauke\> (also, Common Lisp is pretty ad-hoc itself)
00:49:20 <tdammers> yes
00:49:24 <tdammers> CL is the dirty listp
00:49:27 <tdammers> *lisp
00:49:39 <Zemyla> Lokathor: It means you can't write a truly general pretty-printer, syntax hilighter, etc.
00:49:45 <tdammers> but then, Scheme is the ivory tower lisp, and clojure is the hipster lisp
00:49:47 <tdammers> so uhm
00:50:02 <Zemyla> tdammers: Including GHC?
00:50:02 <Lokathor> Zemyla, i think you meant that for someone else?
00:50:04 <acetoline> what's racket?
00:50:19 <tdammers> acetoline: haven't decided yet :D
00:50:31 <acetoline> why did they name it racket anyway
00:50:37 <tdammers> vOv
00:50:52 <mauke\> acetoline: it's like a scheme, only more so
00:51:03 <acetoline> ah
00:51:07 <tdammers> my impression so far is "scheme on crack cocaine with a shitty IDE"
00:51:08 <acetoline> didn't think of that
00:51:29 <acetoline> hey! I like racket's ide
00:51:32 <tdammers> which one
00:51:36 <tdammers> DrRacket?
00:51:39 <acetoline> ya
00:51:54 <tdammers> idk, I found it pretty repulsive
00:52:00 <acetoline> why
00:52:02 <tdammers> not sure
00:52:14 <tdammers> I'm not a huge fan of IDE's in general
00:52:19 <tdammers> I prefer the hard way
00:52:30 <acetoline> it's very hard to do ides right
00:52:37 <acetoline> 95% of the time they get in the way
00:52:40 <tdammers> yes
00:52:52 <tdammers> but it's also a matter of "bottom up vs. top-down"
00:53:09 <tdammers> some people like to start their learning endeavors from a complete fully-featured system
00:53:34 <acetoline> except for some rough edges I thought DrRacket was pretty good
00:53:37 <tdammers> you have this huge thing that does everything, and then you start diving deeper and deeper into it, learning the relevant parts as you go
00:53:47 <acetoline> better than any clojure ide I've used at least
00:53:54 <Lokathor> java is better with an IDE than without
00:54:16 <acetoline> that's because 99% of java programming is boilerplate and copying other people's code
00:54:29 <tdammers> but I prefer the bottom-up approach - build primitive versions of everything myself, then once I know how they're supposed to work, pick an industry-strength library that does the same thing better
00:54:38 <acetoline> and if no one else has written it yet, asking about it on stackoverflow
00:54:43 <tdammers> sure
00:54:49 <tdammers> as a last resort
00:54:53 <acetoline> that's the java problem-solving procedure
00:55:04 <acetoline> ide -> copypasta -> stackoverflow
00:55:05 <tdammers> but SO has been pretty shitty the past few years
00:55:15 <echo-area> tdammers: Which word would you use for Emacs Lisp?
00:55:15 <tdammers> "I have this problem here"
00:55:26 <tdammers> echo-area: haven't emacs lisp yet
00:55:29 <tdammers> echo-area: nor emacs
00:55:38 <Lokathor> i'm not saying that java isn't boilerplate of course
00:55:40 <echo-area> Okay
00:55:42 <tdammers> echo-area: but I guess the only sane choice for emacs lisp would be emacs
00:56:04 <tdammers> top voted SO answer: "Here's some random code that worked for me"
00:56:12 <echo-area> NVM, I just found your adjectives for the LISPs interesting :)
00:56:25 <tdammers> :D
00:56:43 * frerich wonders whether tdammers is getting paid by experts-exchange or something
00:57:18 <acetoline> expertsexchange
01:02:26 <tdammers> oh dear
01:02:32 <Zemyla> Oh, do you know what the smallest program is to add 171 to a cell is?
01:02:34 <tdammers> does expertsexchange even exist anymore?
01:04:53 <Zemyla> [-]+[--->+<]
01:06:57 <mauke\> this assumes wraparound at some point
01:11:31 <Zemyla> You kind of have to assume it, because otherwise you can't clear a cell with [-].
01:12:00 <mauke\> that's not a problem if you only set your cells to positive values :-)
01:12:12 <hnfmr> hi, suppose I have a C header file that defines a type: typedef char Type[10]; Is there anyway using hsc2hs to automatically determine the char array size 10?
01:14:33 <ibid> hnfmr: note that the 10 is not a part of the C type, it's ignored
01:24:19 * hackagebot yabi-muno 0.1.0.0 - Yet Another Brainfuck Interpreter  http://hackage.haskell.org/package/yabi-muno-0.1.0.0 (L8D)
01:24:21 * hackagebot miniforth 0.1.0.0 - Miniature FORTH-like interpreter  http://hackage.haskell.org/package/miniforth-0.1.0.0 (L8D)
01:28:45 <aawe> tdammers: I'd have thought the demand for expert sex change is bigger than ever
01:29:51 <tdammers> :P
01:41:16 <gfixler> is there a simple explanation for what cothings are?
01:41:28 <ibid> gfixler: they are the dual of things
01:41:36 <gfixler> always?
01:41:39 <merijn> gfixler: things with the arrow reversed
01:41:56 <gfixler> all this time, and that's my answer?
01:42:00 <ibid> gfixler: no. cooperation is not the dual of operation
01:42:03 <merijn> gfixler: If we have a category C with objects A and B and a single morphism A -> B
01:42:06 <gfixler> ibid: :)
01:42:18 <merijn> gfixler: Then CoC is a category with objects A and B and a single morphism B -> A
01:42:36 <gfixler> merijn: sounds simple enough
01:42:38 <merijn> Well, and the identities, obviously
01:42:43 <gfixler> of course
01:43:12 <makalu> is there a library like repa or accelerate that has multidimensional unboxed arrays but without any parallelism?
01:43:34 <mauke\> gfixler: coconut == nut
01:43:36 <merijn> gfixler: Consider the product type "A x B" which has arrows "A x B -> A" and "A x B -> B" then coproduct has arrows "A -> A x B" and "B -> A x B", therefore coproducts are sums
01:43:54 <ibid> but note that the co-X terminology is not owned not invented by category theory :)
01:43:55 <makalu> vector is one dimensional
01:43:57 <frerich> http://www.amazon.de/Mastering-CMake-Cross-Platform-Build-System/dp/1930934092/ <-- 2000EUR for a Cmake book?
01:44:04 <gfixler> mauke\: we made a similar joke at my last haskell meetup (someone was drinking coconut water - joke was "it's just nut water")
01:44:25 <mauke\> nice coincidence
01:44:28 <merijn> gfixler: If workers turns work into results, then coworkers...
01:44:39 * frerich apologizes, wrong channel
01:44:48 <gfixler> merijn: hmmm... turning results into workers - I'm going to be rich!
01:44:49 <keko-2> hey, someone has that book a few desks over at work
01:45:04 <keko-2> I doubt they paid 2000e, though :D
01:45:07 <merijn> gfixler: Have you read the CT for programmers blog series by Bartosz?
01:45:08 <ibid> what's ffee?
01:45:15 <gfixler> merijn: the first 3, I think
01:45:23 <gfixler> merijn: it's high on my current reading list
01:45:25 <merijn> gfixler: The rest is good to and covers this
01:45:45 <merijn> gfixler: Specifically the sums == coproducts and other explanations
01:46:01 <gfixler> merijn: good to know
01:46:55 <gfixler> should we rename runReader to coreader?
01:47:15 <gfixler> I guess that doesn't make sense
01:47:38 <gfixler> it's not the morphisms that are cothings
01:48:46 <gfixler> so would a comonoid want to split a monoidal value?
01:51:47 <gfixler> hmmm, according to this, yes: http://stackoverflow.com/a/15419213/955926
01:52:05 <gfixler> I was also wondering if comempty threw away a value, and it seems to
01:55:26 <shachaf> "split" suggests the wrong things for that operation.
01:55:31 <shachaf> It should be called "duplicate".
01:55:56 <gfixler> the ms are all the same?
01:55:57 <shachaf> I guess that name is taken by comonads (but of course comonads are comonoids, so it's reasonable).
01:56:21 <gfixler> split 7 = (7,7)?
02:00:33 <ilias>  
03:12:11 <akegalj> let say I have m :: Array Int Int. So its immutable structure. What will happen if I update  k = m//[(0,1)] in terms of memory? If then I use   print $ m!0  will he under copy array m to array k and update its field or will he lazily return me 0 ?
03:20:16 <ChristianS> akegalj: i can't give details, but i think the vector package is usually recommended over Array these days
03:21:29 <akegalj> ChristianS: yes I know. But vector is not included in base. (not yet)
03:21:49 <ChristianS> akegalj: does that matter?
03:22:15 <akegalj> ChristianS: if you are using it for codeforces or other thirt party which compiles your code only with base, then yes
03:22:27 <akegalj> ChristianS: codeforces.com
03:23:45 <ChristianS> akegalj: hmm, i see, though i think using haskell with only base libs is not have as much fun as it can be otherwise
03:24:42 <akegalj> ChristianS: thats true, but using haskell with base only is more fun than using other language with their standard library. At least it is for me :)
03:24:53 <ChristianS> true as well
03:27:03 <jameseb> akegalj: Data.Array isn't technically in base
03:27:59 <akegalj> jameseb: how do you mean, hackage says base does have Data.Array
03:28:18 <Yuras> it is in haskell98 IIRC
03:28:42 <akegalj> Yuras: IIRC means?
03:28:55 <Yuras> if I remember correctly
03:29:46 <jameseb> akegalj: as far as I can see from hackage, Data.Array isn't in base
03:29:47 <Yuras> akegalj: I don't see Data.Array in base-4.7.0.2
03:29:57 <akegalj> hm... wait
03:30:01 <jameseb> it is in Haskell2010 and array
03:30:13 <Yuras> akegalj: and both the `array` and `vector` are in Haskell Platform
03:31:16 <akegalj> hm thats the case then
03:31:48 <akegalj> codeforces uses ghc-7.6 and they have Array but dont have Vector
03:32:05 <akegalj> do they chose which packages to install then?
03:36:16 <MarkArts> Hello. I'm trying to do the homework for cis194 to learn haskell but i'm stuck. 
03:36:39 <akegalj> jameseb: aha, so i get it. Haskell2010 specifies what is included
03:37:01 <MarkArts> I wrote some code that apparently is an infinite loop but i'm having trouble understanding why it loops 
03:37:46 <jameseb> akegalj: okay, that makes sense - Haskell2010 is the package that contains exactly what is specified by the Haskell 2010 report
03:38:14 <jameseb> so they may be trying to stick to standard Haskell there
03:42:09 <xacktm> MarkArts: hello, are you able to give us a minimal reproducible test case?  if not, (pasted) full code would be ok too
03:43:57 <MarkArts> xacktm: I'm trying to get the sum of an array of ints while treating number higher than 10 as seperate numbers. 
03:44:13 <MarkArts> i use : -- int to list
03:44:13 <MarkArts> toDigits :: Integer -> [Integer]
03:44:13 <MarkArts> toDigits n
03:44:13 <MarkArts>   | n <= 0 = []
03:44:13 <MarkArts>   | otherwise = toDigits(div n 10) ++ [n `mod` 10 ] to convert a number to a list
03:44:21 <MarkArts> an:
03:44:22 <MarkArts> -- add al numbers (sepperate long nmbers)
03:44:22 <MarkArts> sumDigits :: [Integer] -> Integer
03:44:22 <MarkArts> sumDigits [] = 0
03:44:24 <MarkArts> sumDigits (x:xs) = (sumDigits ( toDigits x )  ) + ( sumDigits xs )
03:44:26 * hackagebot libmpd 0.9.0.2 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.9.0.2 (JoachimFasting)
03:44:33 <xacktm> eek, use lpaste.net next time
03:44:40 <MarkArts> oh oeps srry :p
03:45:06 <MarkArts> http://lpaste.net/121611
03:45:18 <bloot> There's a digits package on cabal
03:45:56 <bloot> Prelude Data.Digits> concatMap (digits 10) [1,2,33,4,10]
03:45:57 <bloot> [1,2,3,3,4,1,0]
03:46:12 <MarkArts> :bloot i'm trying to write as much as possible myself for learning purposes
03:46:22 <bloot> Ah. then nvm :)
03:47:29 <pavonia> MarkArts: What is wrong with that code?
03:47:48 <MarkArts> It loops infite when you call sumDigits [1,12,3]
03:48:11 <bloot> @pl \c -> [c]
03:48:11 <lambdabot> return
03:48:20 <MarkArts> or call sumDigits with any integer list for that matter
03:50:09 <pavonia> MarkArts: Roll out the expression by hand for [1,2] to see what happens in the (sumDigits ( toDigits x )  ) part
03:50:59 <MarkArts> :pavonia how would i do that?
03:52:13 <pavonia> Well, evaluate a simpel expression like "sumDigits [1,2]" on paper
03:52:34 <MarkArts> ah ok il try that
03:56:47 <MarkArts> :pavonia thanks i see whats going wrong :D So i need to make sure that sumDigits [{number < 10}] returns the number without calling toDigits and sumDigits on it 
03:57:23 <lpaste> Exio4 pasted “cabal.exe: failed on cabal update” at http://lpaste.net/121620
03:57:47 <exio4> any ideas why cabal update would fail that way? ^ it works without wine 
03:59:38 <Axman6> so in Pipes, how do you know you've reached the end of all the input you're going to get? I need to be able to do some finalisation on the last bytestring of a stream
04:00:45 <merijn> Axman6: You can't
04:01:10 <merijn> Axman6: Look into pipes-safe for resource finalisation or pipes-parse for parsing potentially early terminated input
04:01:20 <MarkArts> This fixes my loop issue http://lpaste.net/121623 doens't look liek the best solution but it works at least
04:01:26 <MarkArts> thanks for the help
04:01:46 <merijn> MarkArts: Why use guards over pattern matching?
04:01:57 <Axman6> merijn: hmm, ok. it's some encryption stuff so the pipe needs to output some padding and HMAC
04:02:45 <MarkArts> merijn: I didn know it was possible to match a list with length 1 that way
04:02:54 <merijn> MarkArts: Also, your last pattern is never used
04:03:06 <merijn> in sumDigits
04:03:45 <merijn> Axman6: I recommend the pipes mailing list, Tekmo is very good at writing up example implementations for whatever you want
04:04:04 <Axman6> ok, I might just do that tomorrow
04:04:14 <merijn> MarkArts: The line 17 pattern will match all lists, causing line 24 to never be used
04:04:14 <Axman6> thanks for letting me know
04:04:19 <merijn> oh, wait
04:04:24 <merijn> You use "length == 1"
04:04:28 <merijn> That's pretty bad too
04:04:38 <merijn> Because that'll be really expensive for long lists
04:07:24 <lpaste> merijn annotated “No title” with “sumDigits (annotation)” at http://lpaste.net/121623#a121629
04:07:30 <merijn> MarkArts: How about that version>
04:09:31 <MarkArts> thats pretty cool
04:09:43 <xandaros> doubleEveryOther will also fail for any list that has an odd length
04:09:46 <MarkArts> http://lpaste.net/121623#a121631 I came up with this in the meanwhile
04:10:13 <xandaros> I suggest you try to avoid partial functions like head, they only cause problems
04:10:46 <merijn> MarkArts: FYI, instead of writing "(x:[])" it's legal to write "[x]" in a pattern
04:11:08 <merijn> In fact, more generally [x,y,z] in a pattern desugars, as normal, to "x:(y:(z:[]))"
04:11:38 <MarkArts> oh that looks better ty
04:11:40 <merijn> I would personally avoid if-then-else whenever possible and prefer guards
04:12:15 <merijn> Same goes for preferring pattern matching over head/tail
04:12:26 <MarkArts> :xandaros thansk for pointing that out
04:13:12 <lpaste> merijn annotated “No title” with “doubleEveryOther (annotation)” at http://lpaste.net/121623#a121636
04:13:26 <merijn> MarkArts: Consider that version of doubleEveryOther, for example
04:14:01 <merijn> Note that you can create arbitrarily complex nested pattern matches if you wish :)
04:15:10 <msl09> why is cabal so awful?
04:15:24 <merijn> msl09: Compared to what?
04:15:36 <merijn> Cabal is probably the best build tool I've used
04:15:53 <msl09> pip, javascript package manager, ruby package manager
04:16:03 <merijn> Not to say there's no room for improvement, but it catches more flack than it deserves
04:16:06 <EvanR> not a package manager
04:16:19 <msl09> even maven is more consistent 
04:16:24 <merijn> msl09: Because all of those silently ignore errors that cabal is forced to report due to haskell's stronger typing
04:16:57 <xandaros> The only issue I have with cabal is that sometimes it is impossible to install a library due to version conflicts
04:16:57 <merijn> JS' package manager blindly copies the source files of dependencies in your tree and you better cross your fingers the interface is still correct...
04:17:05 <msl09> that is a pretty weak excuse for not getting th job done
04:17:26 <xandaros> That's really the maintainer's fault, though. Not cabal's
04:17:31 <merijn> msl09: None of those get the job done, because where cabal throws errors they silently accept wrong things delaying the error until runtime
04:17:37 <EvanR> youre comparing something like autotools to something like apt
04:17:42 <merijn> msl09: What error are you getting
04:17:58 <msl09> gee
04:19:30 <msl09> currently I getting that error that cabal reports that it have installed the dependencies x y and z but when I try to use them ghc informs me that they weren't properly installed
04:19:59 <merijn> msl09: Did you use force-reinstalls at any point? Did you mix cabal + apt (or whatever package manager) installs?
04:20:08 <msl09> nope
04:20:20 <msl09> I'm compiling all packages from source
04:20:26 <merijn> How does cabal report that you have those dependencies installed?
04:20:33 <merijn> Also, lpaste the actual error
04:20:36 <msl09> just a sec
04:21:03 <MarkArts> Thanks everyone for helping me out :D
04:28:03 <ww> > (7**7 * 6**6)**(1/6.52)
04:28:04 <lambdabot>  42.014959994500735
04:28:51 <msl09> apparently I have rage-quit-removed my haskell installation and the build directory
04:29:28 * hackagebot amazonka-core 0.3.2 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.2 (BrendanHay)
04:29:30 * hackagebot amazonka 0.3.2 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.2 (BrendanHay)
04:29:32 * hackagebot amazonka-autoscaling 0.3.2 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.2 (BrendanHay)
04:29:34 * hackagebot amazonka-cloudformation 0.3.2 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.2 (BrendanHay)
04:29:36 * hackagebot amazonka-cloudfront 0.3.2 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.2 (BrendanHay)
04:30:46 <mniip> if I were to collect a list of all paths through a 2d field
04:31:20 <mniip> would it be more reasonable to pass the current path down the recursion, or to map the addition of the current location over the recursion result
04:33:17 <akegalj> mniip: http://www.markhneedham.com/blog/2012/03/24/haskell-memoization-using-the-power-of-laziness/
04:33:26 <akegalj> mniip: i was just reading this so maybe it relates
04:33:50 <mniip> traverse = [here]:map (here:) traverse
04:33:51 <mniip> versus
04:34:06 <mniip> traverse path = [path]:traverse (here:path)
04:34:36 <mauke\> do you allow cyclic paths?
04:34:38 * hackagebot amazonka-cloudhsm 0.3.2 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.2 (BrendanHay)
04:34:40 * hackagebot amazonka-cloudsearch 0.3.2 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.2 (BrendanHay)
04:34:42 * hackagebot amazonka-cloudsearch-domains 0.3.2 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.2 (BrendanHay)
04:34:44 * hackagebot amazonka-cloudtrail 0.3.2 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.2 (BrendanHay)
04:34:46 * hackagebot amazonka-cloudwatch 0.3.2 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.3.2 (BrendanHay)
04:34:51 <mniip> mauke, no
04:35:13 <mniip> there's a matrix of already used cells passed down the recursion
04:35:40 <mauke\> ok, but you allow non-shortest paths
04:35:47 <mniip> yes
04:36:16 <mniip> there is also a clause that a certain cell value can only be passed once but that
04:36:19 <mniip> 's details
04:38:37 <mniip> the field "ab" "cd" should produce
04:38:39 <mniip> ["a","ba","dba","cdba","ca","dca","bdca","b","ab","cab","dcab","db","cdb","acdb","c","dc","bdc","abdc","ac","bac","dbac","d","cd","acd","bacd","bd","abd","cabd"]
04:38:44 <mniip> in this or some other order
04:39:48 * hackagebot amazonka-cloudwatch-logs 0.3.2 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.2 (BrendanHay)
04:39:50 * hackagebot amazonka-codedeploy 0.3.2 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.3.2 (BrendanHay)
04:39:52 * hackagebot amazonka-cognito-identity 0.3.2 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.2 (BrendanHay)
04:39:54 * hackagebot amazonka-cognito-sync 0.3.2 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.2 (BrendanHay)
04:39:56 * hackagebot amazonka-config 0.3.2 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.2 (BrendanHay)
04:41:03 <hpc> that's a lot of packages for one thing
04:44:58 * hackagebot amazonka-datapipeline 0.3.2 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.2 (BrendanHay)
04:45:00 * hackagebot amazonka-directconnect 0.3.2 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.2 (BrendanHay)
04:45:02 * hackagebot amazonka-dynamodb 0.3.2 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.2 (BrendanHay)
04:45:04 * hackagebot amazonka-ec2 0.3.2 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.2 (BrendanHay)
04:45:06 * hackagebot amazonka-iam 0.3.2 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.2 (BrendanHay)
04:48:07 <mniip> akegalj, btw, that thing talks about a pretty simple dynamic thing
04:48:36 <mniip> such dynamics only work if you want to count something
04:48:44 <mniip> not iterate
04:49:45 <ambrozyk> hi! cabal (1.22) seems to ignore the --extra-lib-dirs flag... Is this a common issue, or perhaps there is some easy workaround?
04:50:08 * hackagebot amazonka-importexport 0.3.2 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.2 (BrendanHay)
04:50:10 * hackagebot amazonka-kinesis 0.3.2 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.2 (BrendanHay)
04:50:12 * hackagebot amazonka-kms 0.3.2 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.2 (BrendanHay)
04:50:14 * hackagebot amazonka-lambda 0.3.2 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.2 (BrendanHay)
04:50:16 * hackagebot amazonka-opsworks 0.3.2 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.2 (BrendanHay)
04:50:28 <mniip> sigh
04:50:54 <mniip> what
04:51:10 <mniip> nubbing a list of 44k elements to 31k elements takes 16 seconds?
04:51:13 <mniip> where did I go wrong
04:51:36 <mniip> hm
04:51:42 <mniip> probably by using O(N^2) nub
04:53:13 <exio4> mniip: you could try with (Set.toList . Set.fromList) 
04:53:59 <mniip> that's better
04:54:04 <clrnd> mmmm would that be faster than, say, ordering the list and doing a linear nub? (Data.List.Ordered for example)
04:54:08 <mniip> only 0.1s
04:55:18 * hackagebot amazonka-rds 0.3.2 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.2 (BrendanHay)
04:55:20 * hackagebot amazonka-redshift 0.3.2 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.2 (BrendanHay)
04:55:21 <mniip> ugh
04:55:22 <exio4> clrnd: Set.fromList is O(nlogn) and Set.toList is O(n), so it's just O(nlogn)
04:55:22 * hackagebot amazonka-route53 0.3.2 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.2 (BrendanHay)
04:55:24 * hackagebot amazonka-route53-domains 0.3.2 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.2 (BrendanHay)
04:55:26 * hackagebot amazonka-s3 0.3.2 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.2 (BrendanHay)
04:55:36 <mniip> still lags quite bad with the list containing 2316892 elements
04:55:52 <mniip> but I guess that's okay
04:55:55 <clrnd> exio4, well ordering can be O(log n) and linear nub is O(n), so same thing
04:56:04 <exio4> mniip: don't use a list then
04:56:14 <exio4> clrnd: ordering can be O(log n)? 
04:56:26 <mniip> exio4, the elements are produced in a list manner
04:56:30 <mniip> and consumed in a list manner
04:56:39 <clrnd> best case (?)
04:57:45 <mniip> how can ordering be O(log n)
04:57:53 <mniip> you have to at least check if the input is ordered
04:58:00 <mniip> which is O(n)
04:59:03 <aawe> fastSort xs = xs -- Assume already sorted
05:00:16 <mniip> I have a function,
05:00:20 <mniip> or rather
05:00:28 * hackagebot amazonka-sdb 0.3.2 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.2 (BrendanHay)
05:00:30 * hackagebot amazonka-ses 0.3.2 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.2 (BrendanHay)
05:00:32 * hackagebot amazonka-sns 0.3.2 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.2 (BrendanHay)
05:00:34 * hackagebot amazonka-sqs 0.3.2 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.2 (BrendanHay)
05:00:36 * hackagebot amazonka-ssm 0.3.2 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.2 (BrendanHay)
05:00:38 <aawe> there doesn't see to be a nub in Data.Sequence, I wonder how hard it would be to implement one
05:01:26 <aawe> maybe with a fold
05:02:16 <aawe> sortAndNub
05:02:33 <mniip> I need to split a list of lists into a list of lists of lists by lengthd
05:02:51 <mniip> I have a function: mkLengths l = map (\x -> filter ((x ==) . length) l) [0..]
05:03:00 <mniip> however it seems that l is evaluated multiple times
05:03:13 <exio4> length l is evaluated more than once there
05:03:26 <mniip> length l is not evaluated
05:03:44 <exio4> mkLengths l = let len = length l in map (\x -> filter (x==len)) [0..]
05:03:45 <mniip> mkLengths :: [[a]] -> [[[a]]]
05:03:59 <mniip> exio4, that's not what my function does
05:04:21 <exio4> oh, nevermind :P 
05:04:35 <mniip> @let mkLengths l = map (\x -> filter ((x ==) . length) l) [0..]
05:04:38 <lambdabot>  Defined.
05:04:46 <mniip> > mkLengths ["hello", "world", "foo", "bar"]
05:04:48 <lambdabot>  [[],[],[],["foo","bar"],[],["hello","world"],[],[],[],[],[],[],[],[],[],[],[...
05:05:39 * hackagebot amazonka-storagegateway 0.3.2 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.2 (BrendanHay)
05:05:41 * hackagebot amazonka-sts 0.3.2 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.2 (BrendanHay)
05:05:43 * hackagebot amazonka-support 0.3.2 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.2 (BrendanHay)
05:05:45 * hackagebot amazonka-swf 0.3.2 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.2 (BrendanHay)
05:19:08 <absence> @pl inproc a b c d = (\img -> process img a b c d) =<< readImage "in4.png"
05:19:08 <lambdabot> inproc = flip flip (readImage "in4.png") . ((flip . ((flip . ((=<<) .) . flip) .) . flip) .) . flip . flip process
05:19:16 <absence> is there a more clever way to do that? :p
05:19:47 <unknownloner> so much flip
05:19:49 <absence> i seem to recall something about defining operators for (.) . (.) etc to handle composition with functions that take multiple parameters
05:20:06 <frerich> absence: A common name for that is '.:'
05:20:25 <merijn> I'd recommend against that, though
05:20:36 * frerich concurs
05:20:42 <exio4> absence: that code is already easy to read and terse enough
05:21:36 <merijn> "inproc a b c d = do { img <- readImage "in4.png"; return $ proces img a b c d }" <- what's the problem?
05:22:31 <mauke\> too many returns
05:23:16 <exio4> merijn: why return?
05:23:51 <merijn> oh, right I thought it was using fmap
05:23:54 <merijn> brainfart
05:23:55 <absence> i don't like to either invent bogus names for parameters, or to duplicate them all over the place, but if there's no clever way that makes it clear what happens, i'm not going to go out of my way to obfuscate it :)
05:24:23 <absence> it's just that if readImage wasn't monadic, i could write inproc = process (readImage "..")
05:24:48 <absence> which is leaps and bounds clearer
05:25:21 <absence> so i thought someone might have figured out something clever for monadic values as well
05:27:36 <jtanguy> absence: could you write process as: process a b c d img ?
05:27:55 <niluje> hey, for someone who's new with haskell, do you advise to use the package console-program to parse arguments, or is there something simpler/better?
05:29:58 <frerich> niluje: For a quick start you could do something like 'getArgs >>= \args -> case args of { [what,I,expect] -> ..; _ -> bailout }'
05:30:20 <absence> jtanguy: maybe
05:31:32 <niluje> frerich: ok :p
05:32:09 <niluje> thanks, then I guess I'll try to do something useful before spending some time in advanced argument parsing :-)
05:32:22 <mniip> absence, curry $ curry $ curry $ (readImage "in4.png" >>=) . flip ((uncurry . uncurry . uncurry) . process)
05:32:32 <mniip> semi-/s
05:35:56 <absence> mniip: well at least there's a very obvious pattern :)
05:36:25 <merijn> niluje: optparse-applicative is rather nice, albeit perhaps a bit confusing if you're really new
05:36:40 <mniip> curry4 $ (readImage "in4" >>=) . flip (uncurry4 . process)
05:36:42 <merijn> niluje: There should be some good tutorials on teh googlez, though
05:36:45 <mniip> does start sounding serious
05:36:47 <EvanR> i found it confusing
05:36:54 <mniip> if only curry4 would exist
05:37:14 <EvanR> because the examples dont explain the types
05:37:41 <niluje> merijn: ok thanks a lot
05:38:06 <funfunctor> what is the turn around time on hackage building my documentation for me?
05:38:30 <merijn> funfunctor: Could be a few hours, I think?
05:38:35 <merijn> funfunctor: It uses batch processing
05:38:55 <EvanR> you can upload your own docs
05:39:20 <funfunctor> merijn: hmm its not happened in 8+ hours, is there something wrong? http://hackage.haskell.org/package/hlibBladeRF-0.1.0.1
05:39:43 <funfunctor> EvanR: do I just tar.gz the doc directory under dist/ ?
05:39:55 <EvanR> pretty much
05:40:24 <funfunctor> I mean what is the path structure it expects?
05:40:25 <CogSciNoob> We are using JuicyPixels. What do we have to do with our png image in order to use the function pixelAt?
05:41:06 <EvanR> pixelAt :: Image a -> Int -> Int -> a
05:41:15 <EvanR> you have to have an image and two Ints
05:41:45 <mniip> there are 5 functions in Data.Tuple, what did swap do to deserve not being included in Prelude with the other 4
05:42:06 <EvanR> :t swap
05:42:07 <lambdabot> (a, b) -> (b, a)
05:42:36 <mniip> :t Prelude.swap
05:42:37 <lambdabot>     Not in scope: ‘Prelude.swap’
05:42:37 <lambdabot>     Perhaps you meant one of these:
05:42:37 <lambdabot>       ‘Prelude.fmap’ (imported from Prelude),
05:42:57 <mniip> as opposed to, say, Prelude.fst
05:43:16 <EvanR> as simple as swap is i have never needed it
05:43:34 <EvanR> and 4 tuples are pretty rare
05:43:40 <CogSciNoob> @EvanR it wants an image of type Image iO(), our type is Image PixelRGB8
05:43:41 <lambdabot> Unknown command, try @list
05:43:56 <EvanR> CogSciNoob: it wants a what
05:43:59 <CogSciNoob> Image(iO())*
05:44:11 <mniip> Image (IO ()) ?
05:44:16 <EvanR> no
05:44:50 <EvanR> pixelAt :: Image a -> Int -> Int -> a
05:44:57 <EvanR> it wants whatever you want
05:45:05 <EvanR> a = RGB8 for example
05:45:15 <CogSciNoob> It tells us there is a mismatch between the actual type imageRGB8 and expected type image( IO a0)
05:45:39 <EvanR> you must be using it wrong. for example you used <- like pixelAt was an IO action
05:45:55 <EvanR> use let pixel = pixelAt img 3 4
05:46:16 <mniip> CogSciNoob, it inferred the IO from the way you used the resulting expression
05:47:01 <CogSciNoob> Oooh, that's it. We still haven't gotten used to the Haskell syntax. Thank you!
05:49:59 <ragusa> ciao
05:50:11 <ragusa> list
05:55:44 <bitonic> I have a QuickCheck Arbitrary instance that generates huge test cases after 3 or 4 generations.  are there any guidelines to write Arbitrary instances that won't blow up like that?
05:56:04 <merijn> funfunctor: There's an easy script to automate uploading docs, lemme look it up
05:56:34 <merijn> funfunctor: See http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
06:02:10 <jtanguy> merijn: maybe this tool? https://github.com/ndmitchell/neil
06:02:50 <frerich> heh, he called a tool "neil"? :)
06:03:05 <EvanR> neil
06:03:27 <EvanR> and i thought ruby libs had dumb names ;)
06:03:37 <jtanguy> well at first it was only a compilation of scripts for himself
06:04:02 <EvanR> evanr upload
06:04:06 <EvanR> evanr clear
06:04:12 <EvanR> coming soon
06:08:17 <funfunctor> merijn: thx! I wonder why hackage has not got around to it
06:08:23 <kaiyin> What does this do?  \x->( x .&. 0xff) 
06:08:31 <kaiyin> it looks like id to me.
06:08:41 <EvanR> > 256 .&. 0xff
06:08:43 <lambdabot>  0
06:08:46 <bloot> It only allows 0-255
06:08:50 <bloot> by masking out all higher bits
06:08:59 <bloot> like (x & 0xFF) in C
06:09:26 <mauke\> @check \x -> (x .&. 0xff) == x
06:09:28 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
06:09:28 <lambdabot>  -1
06:09:36 <mniip> also you should probably write (0xFF .&.)
06:09:49 <kaiyin> mniip: why is that?
06:10:02 <bloot> @pl \x -> (x .&. 0xFF)
06:10:02 <lambdabot> (.&. 255)
06:10:04 <mniip> it's shorter, simpler, and still understandable?
06:10:25 <EvanR> at least you dont need parens around x .&. 0xff
06:10:29 <EvanR> in that lambda
06:10:39 <kaiyin> hm, got it.
06:11:41 <kaiyin> Is Char in haskell 0-255?
06:11:57 <ibid> no
06:11:58 <EvanR> > maxBound :: Char
06:12:00 <lambdabot>  '\1114111'
06:12:23 <mniip> 0-0x10FFFF
06:12:31 <mniip> just as unicode recommends
06:12:31 <EvanR> > reverse ['a' ..]
06:12:33 <lambdabot>  "\1114111\1114110\1114109\1114108\1114107\1114106\1114105\1114104\1114103\11...
06:12:51 <ibid> > length ['a' ..]
06:12:52 <lambdabot>  1114015
06:13:14 <EvanR> ... that reverse was pretty fast
06:13:47 <ibid> it's only about a million or so elements in the list. piece of cake
06:13:50 <mniip> EvanR, enumFromThenTo/reverse rule maybe?
06:13:58 <EvanR> dunno
06:14:07 <xandaros> How does "length ['a' ..]" even terminate?
06:14:13 <EvanR> Bounded
06:14:15 <ibid> xandaros: it's a finite list
06:14:24 <mniip> xandaros, all Bounded types return finite lists
06:14:30 <mniip> > [True ..]
06:14:32 <lambdabot>  [True]
06:14:36 <mniip> wait ugh
06:14:38 <mniip> > [False ..]
06:14:40 <lambdabot>  [False,True]
06:14:52 <xandaros> ahhhhh, I see
06:15:31 <ibid> > reverse ([0..] :: Int)
06:15:32 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
06:15:32 <lambdabot>              with actual type ‘[t0]’Couldn't match expected type ‘[a]’ with a...
06:15:44 <exio4> > reverse [0::Int..] 
06:15:45 <lambdabot>  <hint>:1:13: parse error on input ‘Int..’
06:15:48 <ibid> > reverse [0..] :: [Int]
06:15:54 <lambdabot>  mueval: ExitFailure 1
06:16:08 <mniip> > maxBound :: Int
06:16:09 <lambdabot>  9223372036854775807
06:24:33 * hackagebot jsontsv 0.1.4.6 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.6 (DanielChoi)
06:24:56 <funfunctor> merijn: great, my docs are up with my package, thx !
06:33:48 <Stratege> If one installs libraries via cabal with profiling support enabled, does that mean that there is only the profiling enabled version installed? (and if so, does that mean that without profiling enabled in the program it will still be slower than if one had not installed the profiling versions of the libraries?)
06:35:15 <mauke\> no
06:35:44 <Stratege> cool, thanks.
06:38:56 <kaiyin> What went wrong with my definition of log2?
06:38:57 <kaiyin> https://gist.github.com/kindlychung/4d690e7ac1fbf1173b7b
06:40:03 <aawe> kaiyin: line 89
06:40:06 <shiona> kaiyin: in the 'where' part you give a type for function log2, but a definition for log2_
06:40:20 <kaiyin> oh, yes.
07:04:40 <kaiyin> what is wrong with my adler32? http://hastebin.com/atiqizujut.vhdl
07:05:19 <EvanR> pixelAt :: Image a -> Int -> Int -> a
07:05:25 <EvanR> Application Error
07:05:53 <mniip> use lpaste
07:06:41 <kaiyin> http://lpaste.net/121788
07:07:11 <EvanR> :t ord
07:07:13 <lambdabot> Char -> Int
07:07:48 <EvanR> ord words on Chars
07:07:57 <EvanR> ord works on Chars but you used it on an Int
07:09:05 <arboris> wie geht man in Haskell mit Situationen um in denen relativ komplexes Speichermanagement unabdingbar ist? Der konkrete Fall den ich im Sinn habe ist sind Buffer in OpenGL, for a particle system many concurrent tasks have to update one region of the buffer, while a second is streamed to the GPU and a third is used in the current frame
07:09:40 <arboris> oh sorry was thinking in german for a moment, how does not cope with situations in haskell where manual memory management is inevitable
07:10:00 <arboris> the concrete situation I have in mind is buffers in OpenGL
07:10:25 <EvanR> it is possible to attach finalizers to values which will run when they are collected
07:10:30 <EvanR> might help
07:10:46 <silver> :t chr
07:10:47 <lambdabot> Int -> Char
07:10:52 <arboris> essentially i need some nice abstraction for a ringbuffer, plus the possibility to update that ringbuffer in place with many (~10000) tasks
07:11:30 <EvanR> you can use the ffi to access a ring buffer you wrote in C
07:11:37 <octatoan> @pl (***)
07:11:37 <lambdabot> (***)
07:11:55 <octatoan> @pl flip ($) x (***)
07:11:55 <lambdabot> (x ***)
07:12:18 <arboris> well, ideally I want to use Haskells concurrency mechanisms with that ring buffer
07:12:22 <EvanR> but unagi chan might be fast enough
07:12:24 <arboris> how would that work
07:12:44 <EvanR> with a lock-free ring buffer.. you wouldnt be using any concurrency mechanisms
07:13:18 <EvanR> nevermind, that only works with one reader and one writer
07:13:32 <arboris> well you need locking just in case, essentially the default is tripple buffering
07:13:33 <EvanR> arboris: https://hackage.haskell.org/package/unagi-chan
07:13:45 <EvanR> locking is not good for performance
07:14:01 <arboris> so there aren't any races and minimal syncs in the driver
07:14:34 <arboris> but you still need a thread sync in the outer loop
07:14:38 <octatoan> @pl (\f x y -> f x : f y)
07:14:38 <lambdabot> flip =<< (((.) . (:)) .)
07:14:42 <EvanR> if you want
07:14:50 <octatoan> @pl (\f x y -> f x : f y : x y )
07:14:50 <lambdabot> liftM2 ap (((.) . (:)) .) (liftM2 (:))
07:15:05 <arboris> (at least that is what the people from Nvidia and AMD are telling you)
07:15:06 <octatoan> @pl (\f x y -> f x : f y : x y : x f : y f : y x)
07:15:07 <lambdabot> liftM2 ap (fmap (.) (:) .) (ap ((.) . liftM2 (:)) (liftM2 ap ((:) .) . ap (ap . (((.) . (:)) .) . flip id) ((. flip id) . ap . ((:) .) . flip id)))
07:15:52 <octatoan> @pl (\f x y z -> f x : f y : x y : x f : y f : y x : Just (f . x. y. z) <*> (x,y,z))
07:15:55 <lambdabot> ap (ap . (((.) . (.) . (:)) .)) (ap ((.) . ap . (((.) . (:)) .)) (ap (ap . (((.) . (:)) .)) . ap (ap . (((.) . (.) . (:)) .) . flip id) (ap ((.) . ap . (((.) . (:)) .) . flip id) (ap (ap . (((.) . (:)) .) . flip id) . flip ap (,,) . ((ap . (ap .)) .) . ((((<*>) .) .) .) . (((Just .) .) .) . (. ((. (.)) . (.) . (.))) . (.) . (.) . (.)))))
07:15:55 <lambdabot> optimization suspended, use @pl-resume to continue.
07:16:08 <arboris> unagi-chan is unfortunately not an option, the buffer you get by the driver in such a way that underneath the hardware has DMA access to it
07:16:14 <octatoan> Oh my God, this bot is insane.
07:16:44 <arboris> any copying or memory transfer done by the CPU kills performance
07:16:44 <hpc> :t (\f x y z -> f x : f y : x y : x f : y f : y x : Just (f . x. y. z) <*> (x,y,z))
07:16:45 <lambdabot>     Couldn't match expected type ‘[b1 -> b]’
07:16:45 <lambdabot>                 with actual type ‘Maybe (a -> b1 -> b)’
07:16:45 <lambdabot>     Relevant bindings include
07:16:49 <EvanR> arboris: im not totally clear what youre talking about at this point
07:16:52 <hpc> it has issues with type errors
07:16:53 <octatoan> @pl (\f x y -> (f,x,y))
07:16:53 <lambdabot> (,,)
07:17:10 <octatoan> @pl (\x y f -> f (x,y))
07:17:10 <lambdabot> (flip id .) . (,)
07:17:28 <arboris> EvanR: well in the case of OpenGL you essentially need to shovel lots of data to the GPU
07:17:35 <octatoan> @pl (\f x y z -> (z. y.x).(x.y.z) f)
07:17:35 <lambdabot> ap (ap . ((ap . ((.) .) . flip (.)) .) . flip (.)) . flip (flip . (flip .) . (. (.)) . (.) . (.))
07:17:48 <octatoan> @pl (\f x y z -> flip(z. y.x).(x.y.z) f)
07:17:49 <lambdabot> ap (ap . ((ap . (((.) . flip) .) . flip (.)) .) . flip (.)) . flip (flip . (flip .) . (. (.)) . (.) . (.))
07:17:56 <bjornars> octatoan: are you done soon?
07:18:03 <EvanR> arboris: well, or do as much as you can on the gpu
07:18:04 <octatoan> Haha, yes.
07:18:08 <Welkin> octatoan: you can private message lambdabot 
07:18:21 <Welkin> that is preferred unless you are demonstrating something for someone else in the channel
07:18:31 <octatoan> Sorry if that was spammy, I'm kind of new. I'll make sure to do that.
07:18:35 <octatoan> Thanks.
07:19:06 <arboris> EvanR: the approach advocated in 
07:19:06 <arboris> http://www.slideshare.net/CassEveritt/approaching-zero-driver-overhead
07:19:40 <EvanR> arboris: it is possible to optimize haskell programs so they are fast, but if youre trying to use massive parallelism on the cpu to drive graphics, that seems hard in any language
07:19:40 <arboris> is to write concurrently to memory the gpu also has access to
07:20:01 <arboris> and manually manage the possible memory conflicts and allocations
07:20:11 <EvanR> im not sure if youre talking about not using the opengl driver or not
07:20:26 <steffen> Whats the most efficient method of doing 'Map k v -> Map v k'
07:20:32 <arboris> with this approach the overhead of the opengl driver is essentially zero
07:20:39 <Lokathor> id
07:20:52 <steffen> going over a list and swapping the tuples?
07:20:57 <EvanR> arboris: seems like you want to tackle other bigger sources of overhead first
07:21:04 <arboris> it just compiles the shaders and tells the gpu where it can find data in main memory
07:21:15 <arboris> EvanR: Like what?
07:22:08 <EvanR> your graphics algorithms, your haskell code
07:22:33 <octatoan> I've finished doing Applicatives in LYAH, would it be wise to go through the Typeclassopedia now? 
07:25:14 <Welkin> octatoan: yes
07:25:26 <Welkin> although it is a reference, not a tutorial like LYAH
07:25:44 <Welkin> read only the sections relevant to you and read them carefully
07:25:52 <Welkin> do the exercises at the end of each section as well
07:26:05 <arboris> EvanR: i'm not doing this as some kind of premature optimization, I take the words of experts for it that this is the way to achieve the best performance on current graphics hardware
07:26:12 <Welkin> you'll likely refer back to it many times over the next several months
07:26:27 <EvanR> arboris: uh huh
07:26:46 <EvanR> dont use haskell either, you need to write it all in assembly language
07:27:37 <arboris> one option is as you said to just implement some ring buffer in c and access it from Haskell
07:28:05 <arboris> im not sure how to make multiple haskell tasks concurrently write to it
07:28:57 <EvanR> lock it
07:29:11 <EvanR> since you dont want to use unagi chan
07:30:43 <octatoan> Welkin: I am doing them. I'm also trying to prove the laws (I've succeeded so far with Functor and Applicative) :)
07:37:27 <octatoan> Does anyone know of any good intuitive explanation for the composition law for applicatives?
07:39:47 <EvanR> octatoan: are you refering to this remark that its tricky and unintuitive
07:41:06 <EvanR> ignore that ;)
07:41:11 <octatoan> No. I've managed to prove it in a "mathematical" sort of way using the previous laws, but I can't . . . *grok* it.
07:41:55 <octatoan> I mean, I have a kind of foggy idea of what it means, but not as clearly as I'd like.
07:42:39 <EvanR> maybe if you rewrite it in applicative syntax
07:44:12 <nshepperd> I bet it turns out to be equivalent to associativity of <.> :: Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
07:44:14 <ayeganov> Haskell newbie here - I am currently reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses and close to the end of the chapter we get to create a new typeclass called YesNo. It is suppose to mimic true-ish behavior of JavaScript: if("BLA") -> True. Everything looked great until we got to defining the (Maybe a) type. The definition says that Nothing is always False, anything Just is True. I've coded an example, with what I think is a problem
07:44:51 <nshepperd> (<.> = liftA2 (.))
07:44:53 <EvanR> ayeganov: your message was cut off
07:45:13 <ayeganov> EvanR: Thank you, i'll repost
07:45:26 <ayeganov> Haskell newbie here - I am currently reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses and close to the end of the chapter we get to create a new typeclass called YesNo
07:45:35 <ayeganov> It is suppose to mimic true-ish behavior of JavaScript: if("BLA") -> True. Everything looked great until we got to defining the (Maybe a) type. The definition says
07:45:40 <ayeganov> that Nothing is always False, anything Just is True. I've coded an example, with what I think is a problematic case - specifically "yesno $ Just []". Empty list should return
07:45:45 <ayeganov> False, but because the type gets unfolded first as the Maybe - it doesn't actually evaluate the true value. Here is my example https://gist.github.com/ayeganov/ec152adfb9363329beed
07:45:50 <tnks> so I'm trying to map out extensions a little better.  If I turned on FlexibleInstances by default, what kind of downside might I face?
07:46:00 <tnks> slower compile times?  something worse?
07:46:27 <Lokathor> ayeganov, you could adjust the definition to make the YesNo check recursive (in a sense) if you wanted to
07:46:57 <clrnd> ayeganov, exactly, why not, if Just something, return yesno something?
07:47:00 <Lokathor> but then it wouldn't be YesNo (Maybe a) because the a would also have to already be an instance of YesNo as well
07:47:15 <ayeganov> Lokathar: I tried that, but the compiler complained
07:47:28 <octatoan> nshepperd: I don't understand fully. Do you mean that the fact that  <.> is recursive will help me get the fourth Applicative law?
07:47:39 <octatoan> recursive -> associative
07:47:41 <octatoan> sorrt
07:47:49 <octatoan> *sorry :/
07:48:00 <wz1000> Does GHCi use readline?
07:48:06 <Lokathor> did you use: instance (YesNo a) => YesyNo (Maybe a) where
07:48:27 <nshepperd> octatoan: no, I mean that I suspect that the fourth Applicative law is secretly _stating_ that <.> is associative
07:48:29 <Lokathor> the inner type needs to also pick up a YesNo restriction
07:48:49 <ayeganov> hmm, let me try that
07:48:57 <octatoan> Uhm, okay.
07:49:01 <albeit> I seem to use a pattern in State like "foo <- gets myFoo; if foo then ... else ...". Is there an easier way? Like a monadic "if"?
07:50:02 <kaiyin> Any new development on the numerical computing front, for example something like pandas for python?
07:50:12 <nshepperd> octatoan: I mean, I reckon you could prove that the 4th law implies "<.> is associative" and vice versa. and that that might be enlightening
07:50:16 <Lokathor> albeit, Control.Monad.when might be what you want
07:50:28 <octatoan> I'll try that, thanks.
07:50:30 <ayeganov> Lokathor: That worked, thank you. If I understand correctly now I've contstrained the contents of "a" in YesNo Maybe a to also be of YesNo type.
07:50:41 <mniip> albeit, when and unless
07:50:54 <mniip> if you need both branches then an if is probably better
07:50:59 <Lokathor> ayeganov, correct, like the example with "instance (Eq m) => Eq (Maybe m) where" above
07:51:02 <nshepperd> sort of like how the 3rd monad law can be rephrased as ">=> is associative"
07:51:14 <albeit> Lokathor, mniip: But don't both of those still require me to get the boolean before? And they only do one branch?
07:51:28 <mniip> :t when
07:51:29 <lambdabot> Monad m => Bool -> m () -> m ()
07:51:31 <mniip> oh
07:51:33 <mniip> right
07:51:35 <albeit> I was hoping for something like "ifM (gets myFoo) then ... else ..."
07:51:37 <ayeganov> I am beginning to REALLY like haskell =)
07:51:42 <Lokathor> albeit, correct, you could write whenM if you wanted i guess
07:51:50 <mniip> albeit, you can define your own ifM
07:52:12 <mniip> ifM b t f = b >>= \x -> if x then t else f
07:53:13 <albeit> True... though I guess then I dont'get the benefit of not needing parentehses around the two branches
07:54:30 <mniip> gets myFoo >>= \x -> if x
07:54:39 <mniip> then whatever else whatever
07:57:11 <siddhu> Just pointing out, ifM is part of Control.Monad.Extra, so you could use the version there. Control.Monad.Extra provides a lot of useful functions.
08:12:07 <cfoch> hi. How can I apply "cabal haddock" to all the packages located at a sandboxed directory ?
08:16:50 <ianjneu> Q: what's the type signature I need to have to implement a monad command? Currently I've been using somenthing like bind, but I have to introduce a \ _ -> :/
08:16:54 <solrize> http://heeris.id.au/2014/if-programming-languages-were-harry-potter-characters/   <-- haskell is ginny weasley in this, shrug
08:18:10 <clrnd> solrize, no, it's hermione
08:18:19 <solrize> oh whhops sorry i got them confused
08:18:27 <solrize> i read a couple of those books but got bored
08:18:34 <clrnd> javscript with haskell, oh my god
08:18:39 <frerich> albeit, mniip: If you change the argument order slightly, 'ifM' is just 'liftM3 bool'
08:18:42 <clrnd> I didn't read any :P
08:18:59 <exio4> frerich: it is not
08:19:21 <exio4> frerich: lift(AM)x evaluate _all_ arguments
08:19:23 <albeit> :t liftM3 bool
08:19:24 <lambdabot> Monad m => m r -> m r -> m Bool -> m r
08:19:46 <siddhu> :t bool
08:19:46 <lambdabot> a -> a -> Bool -> a
08:19:48 <exio4> ifM can shortcircuit
08:20:07 <albeit> :source bool
08:20:12 <albeit> :s bool
08:20:28 <quchen> bool t f p = if p then t else f
08:20:57 <exio4> > liftM3 bool (fail "...") (return "true") (return True) 
08:20:58 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
08:20:59 <lambdabot>    arising from a use of ‘M272387200763435450025131.show_M2723872007634354500...
08:20:59 <lambdabot>  The type variable ‘m0’ is ambiguous
08:21:06 <exio4> > liftM3 bool (fail "...") (return "true") (return False) :: Maybe String  
08:21:08 <lambdabot>  Nothing
08:21:12 <exio4> > liftM3 bool (fail "...") (return "true") (return True) :: Maybe String  
08:21:13 <lambdabot>  Nothing
08:21:29 <Yuras> @src bool
08:21:29 <lambdabot> Source not found. Abort, Retry, Panic?
08:21:40 <siddhu> Which package would bool be from?
08:21:42 <Yuras> @slap lambdabot
08:21:42 * lambdabot puts on her slapping gloves, and slaps lambdabot
08:21:47 <albeit> Just found it, Data.Bool
08:22:17 <siddhu> albeit: That's Bool?
08:22:26 <exio4> Data.Bool in base 
08:22:30 <albeit> Data.Bool.bool
08:22:52 <siddhu> Module `Data.Bool' does not export `bool'
08:23:00 <siddhu> maybe it's in a newer version of GHC?
08:23:07 <quchen> It's fairly recent, yes.
08:23:24 <Yuras> @hoogle bool
08:23:24 <lambdabot> package bool-extras
08:23:24 <lambdabot> package boolexpr
08:23:24 <lambdabot> package bools
08:24:22 <frerich> exio4: Good point!
08:24:58 <Rotaerk> hrm, how do I convert an (m a) into an (EitherT e m a)
08:25:11 <Yuras> bool is in base Since: 4.7.0.0
08:26:16 <adamse> Rotaerk: lift would do it
08:26:22 <adamse> :t lift
08:26:23 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
08:26:29 <Rotaerk> oh
08:26:36 <adamse> where t is EitherT e
08:26:43 <Rotaerk> I was looking at liftM
08:26:51 <Rotaerk> thanks
08:26:52 <exio4> liftM is just fmap
08:26:59 <adamse> :t liftM
08:27:00 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:27:08 <adamse> liftM does not do what you ask
08:27:16 <adamse> ah, yes
08:27:35 <adamse> well, just lift is probably the answer ;)
08:28:35 <frerich> exio4: Quite a shock to realize that lift(AM)* changes the 'strictness' of the function being lifted I think I never considered that when using those functions...
08:28:40 * frerich should probably review those cases...
08:28:48 <Rotaerk> weird, I don't think there's an instance of MonadTrans for EitherT
08:29:19 <adamse> which EitherT are you using?
08:29:29 <Rotaerk> ah, that's an old version...
08:29:33 <Rotaerk> i need to stop using google to find my packages
08:29:37 <Rotaerk> it always turns up old versions
08:30:37 <frerich> exio4: I guess it makes sense if one thinks about it, noticing how e.g. 'liftM3 bool (return 1) undefined (return True)' differs from 'liftM3 bool (return 1) (return undefined) (return True)'
08:30:39 <Rotaerk> and to answer your question, http://hackage.haskell.org/package/either-4.3.3.2/docs/Control-Monad-Trans-Either.html
08:31:44 <exio4> frerich: it's applicative vs monad
08:34:41 * hackagebot api-builder 0.5.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.5.0.0 (Intolerable)
08:44:13 <quchen> EitherT is called ExceptT in the standard libraries.
08:44:32 <quchen> EitherT from the "either" package pulls in a huge amount of transitive dependencies compared to its utility.
08:44:42 * hackagebot cabal-debian 4.24.3 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.24.3 (DavidFox)
08:44:56 <phaazon> the standard libraries
08:44:57 <phaazon> wat ?
08:45:05 <quchen> Base.
08:45:10 <phaazon> to me EitherT _is_ the standard
08:46:24 <quchen> That makes semigroupoids standard too then?
08:46:32 <phaazon> ExceptT is in transformers, not base
08:49:26 <quchen> Alright, not base, but certainly more standard than Kmett's universe.
08:50:20 <int-index> Hi. How do I turn '[Int, Char, Double] into (Int -> Char -> Double)? (type-level programming)
08:50:38 <int-index> Particularly I'm trying to supply a HList from vinyl with a consumer function
08:50:56 <Ferdirand> [Int,Char,Double] is a valid type now ?
08:51:07 <int-index> Note the prime
08:51:13 <int-index> It's '[Int, Char, Double]
08:51:13 <Ferdirand> aah
08:51:28 <int-index> It's a type-level list.
08:51:40 <int-index> You need a whole lot of extensions to get these.
08:51:43 <int-index> But they work.
08:52:00 <Ferdirand> so wait
08:52:10 <Ferdirand> ' lifts a constructor to a type constructor or something ?
08:52:14 <int-index> Yes.
08:52:29 <Ferdirand> mind blown
08:53:08 <int-index> And you need it only for constructors with special syntax (like lists). You can promote terms to types with DataKind extension without special syntax.
08:53:11 <exio4> int-index: a closed type family? type family Conv (ls :: [*]) where Conv '[x] = x ; Conv (x ': xs) = x -> Conv xs  or something like this, what are you trying to do?
08:54:27 <int-index> exio4, that type family sounds like a neat idea. Going to try it.
09:01:06 <quchen> Does anyone know what happened to Better's website?
09:01:13 <dmj`> quchen: I noticed that too
09:01:24 <quchen> http://www.better.com/ seems very non-Better
09:01:37 <quchen> jaspervdj: ping?
09:02:06 <dmj`> quchen: check http://erudify.com or http://app.better.com
09:02:34 <dmj`> erudify is just a redirect
09:02:49 <quchen> That makes sense.
09:03:00 <quchen> Maybe their website was rooted?
09:04:43 * hackagebot postgrest 0.2.7.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.7.0 (begriffs)
09:05:31 <JoshieAS> does anyone know the story with why tryhaskell.org/eval is down?
09:06:43 <quchen> JoshieAS: http://tryhaskell.org/ works for me
09:07:15 <Sarthak> I'm a beginner and i want to learn haskell. 
09:07:24 <JoshieAS> but not http://tryhaskell.org/eval
09:07:26 <Sarthak> good tutorials?
09:07:35 <JoshieAS> Says "Down for Maintenance" but it's been down for several days.
09:07:38 <quchen> JoshieAS: Oh, I see.
09:07:52 <Sarthak> i have experience in java, c, python and R.
09:07:55 <quchen> Chrisdone isn't here so we'll have to wait
09:08:17 <Booboorocks998> I have a quick question.  What is wrong with this: replicate 3 (max (head xs) (tail xs))
09:08:31 <Booboorocks998> I'm self teaching myself 
09:08:58 <quchen> Sarthak: The two beginner books are Learn You A Haskell (LYAH) and Hutton. LYAH is free to read online.
09:09:00 <Booboorocks998> oh! i wanted last not tail
09:09:00 <quchen> ?lyah
09:09:00 <lambdabot> Unknown command, try @list
09:09:04 <quchen> ?where lyah
09:09:04 <lambdabot> http://www.learnyouahaskell.com/
09:09:09 <siddhu> Sarthak: https://wiki.haskell.org/Tutorials has way too many tutorials. LYAH is really nice: http://learnyouahaskell.com/
09:09:11 <Booboorocks998> I'm reading learnyouahaskell right now, actually
09:09:31 <Sarthak> Thanks, is anyone contributing to the community here?
09:09:54 <quchen> This channel is a community, and by talking we're contributing. :-)
09:10:31 <Sarthak> I'd like to be a part of it asap. I want to try my luck at gsoc. I know I should've picked a language i'm more comfortable with, but i'm just very interested in learning haskell. ")
09:10:34 <quchen> There are plenty of experienced users, compiler contributors, and library maintainers around here.
09:10:49 <c_wraith> Sarthak: there are lots of way to contribute other than GSoC
09:11:05 <c_wraith> Sarthak: and there will probably be at least 10x as many applicants as people selected.
09:12:52 <Sarthak> Yes, i know. I just want to try my luck. My original goal is to contribute to this community and apply next year, but I'd like to do as much as possible for this year too. :)
09:13:40 <c_wraith> Sarthak: in that case, pay attention to https://www.reddit.com/r/haskell/comments/2wii6n/haskell_google_summer_of_code_proposal/
09:13:54 <c_wraith> Sarthak: in particular, it notes there's a channel devoted to gsoc stuff. :)
09:14:10 <c_wraith> Sarthak: but it's also a good place to see what kinds of things are being proposed
09:14:30 <Sarthak> Thank you very much c_wraith. :)
09:15:58 <Sarthak> Anyone else here trying for GSoC?
09:17:07 <JagaJaga> What's the way to curry n args?
09:17:37 <Booboorocks998> http://pastebin.com/FJe2shjz
09:19:09 <quchen> JagaJaga: You mean varargs-like functionality? It's not a thing we usually do.
09:19:21 <int-index> exio4: thanks! That type family works well (with a slight modification)
09:19:33 <Booboorocks998> What does that error mean? How must I fix it?
09:19:38 <exio4> int-index: \o/ :P
09:20:09 <quchen> Booboorocks998: What are the types of `(++)`, `x`, `xs` in your function?
09:20:12 <int-index> Booboorocks998: it means that you can't do xs ++ x, because ++ takes two lists
09:20:21 <int-index> And x is not a list.
09:20:27 <int-index> It's a single element.
09:21:01 <JagaJaga> quchen: no, it's fixed args, but I need (a,b,c,d) turn into a -> b -> c -> d
09:21:09 <Booboorocks998> !! of course. I actually solved that kind of problem once before...
09:21:33 <quchen> JagaJaga: There is no generic way to do that using only Haskell. You'd have to write that function yourself.
09:21:36 <Booboorocks998> when i made this.... left2 (x:y:xs) = xs ++ [x] ++ [y]
09:21:59 <JagaJaga> quchen: thank you.
09:22:15 <quchen> JagaJaga: TH can programmatically generate "curryN" functions for you if you really need it, but using tuples larger than 2-3 entries is not recommended anyway.
09:22:38 <int-index> You can also use nested tuples and use some type-level magic.
09:23:08 <quchen> JagaJaga: If you need a tuple you should usually think about whether a custom data type might be more appropriate; tuples are the "default anonymous bunching up of two things".
09:23:57 <Booboorocks998> If anyone would like to take a look here, I'm really curious if I'm properly using signatures.  My script compiles, but I want to make sure that I'm using proper style, too.
09:23:57 <Booboorocks998> http://pastebin.com/hXRw4YH1
09:24:54 <Booboorocks998> Also I think haskell convention is to use camel casing.  I'm using underscores because that's how codingbat names its functions
09:25:14 <tommd> Booboorocks998: I suggest you use pattern matching more and partial functions such as 'head' less.
09:26:43 <quchen> Booboorocks998: The usual way to write identifiers is camelCase in Haskell.
09:26:57 <Booboorocks998> Is it possible to pattern match the first and last element of a list? like x:_*:y, kind of. 
09:27:03 <quchen> Booboorocks998: Concerning head/tail/..., see https://github.com/quchen/articles/blob/master/fbut.md#head-tail-isjust-isnothing-fromjust-
09:27:07 <JagaJaga> quchen: int-index: well, now I just used tuples and it's ok :)
09:27:10 <siddhu> Booboorocks998: It's awkward to see if then else with so much indentation.
09:27:14 <int-index> Booboorocks998, don't indent so much, I couldn't find then/else in your combo_string for a second
09:27:24 <laudiacay> Booboorocks998: that first/last pattern matching though
09:27:28 <laudiacay> what about infinite lists
09:27:40 <laudiacay> (note, i am on week one of haskell, disregard pls)
09:27:47 <Booboorocks998> It isn't so indented in the editor.  That's just pastebin
09:27:58 <Booboorocks998> http://i.imgur.com/LruHdHe.png
09:28:11 <quchen> Booboorocks998: A list is literally either empty or an element followed by another list. There is no notion of a "last" element in a list, so you can't pattern match on it.
09:28:48 <Booboorocks998> That's what I thought. Do you basically have to use last then?
09:29:02 <quchen> You can implement it yourself.
09:29:03 <ski> Booboorocks998 : `if ... then True else False' is simpler written as just `...' (this is called "eta-reduction, on booleans")
09:29:06 <int-index> quchen, well... {-# LANGUAGE PatternSynonyms, ViewPatterns #-} pattern Last x <- (last -> x)
09:29:15 <int-index> And now you can. But that's slow, yeah.
09:29:25 <int-index> And doesn't work for infinite/empty lists.
09:29:36 <int-index> And isn't actually pattern matching... ugh. It will crash.
09:29:38 <tommd> Booboorocks998: If you find a need for 'last' then chances are you are wanting a data structure other than lists.
09:29:38 <quchen> int-index: I don't think that's very helpful to a beginner.
09:29:44 <mniip> ski, sounds like beta-reduction following the defition of if
09:29:48 <quchen> int-index: It's also more sugar than pattern matching.
09:29:52 <breadmonster> What's the difference between ByteString and Text?
09:30:10 <tommd> Booboorocks998: Think about what primtiive operations you'd like and find a structure to suit, don't abuse lists for everything... even if it seems like others do.
09:30:17 <quchen> breadmonster: ByteString is a performant version of a list of bytes, Text is for text.
09:30:21 <ski> mniip : you could prove it like that, by considering cases of `...', yes
09:30:26 <siddhu> breadmonster: Text is packed in unicode, whereas bytestring is binary ascii
09:30:33 <breadmonster> quchen: Whta if I'm interested in strings?
09:30:40 <quchen> breadmonster: Text.
09:31:05 <quchen> Despite having "String" in its name, ByteString has very little to do with strings.
09:31:07 <breadmonster> Like I'm writing a compiler?
09:31:24 <miguelarauj1o> hi, :)
09:31:25 <Booboorocks998> ski: Yeah I didn't notice I could have tightened that up a lot
09:31:27 <miguelarauj1o> anyone can help to develop a project (hosted at github) in haskell that we can gather useful functions, tutorials, and other haskell-related things? like this repo for python: https://github.com/rasbt/python_reference 
09:31:28 <mniip> bytestring is literally a block of octets
09:31:33 <int-index> quchen: sure. But if we define custom 'last' that returns Maybe a (or just use a prism), then this sugar can be neat.
09:31:49 <breadmonster> quchen: Cool
09:31:54 <quchen> miguelarauj1o: Like this? https://github.com/bitemyapp/learnhaskell
09:32:02 <Booboorocks998> laudiacay: what do you mean?
09:32:12 <breadmonster> quchen: Will XOverloadedStrings convert to Text though?
09:32:23 <quchen> Yes, Text works with IsString.
09:32:43 <laudiacay> Booboorocks998: it was more a question than anythng and int-index answered it for me, thanks :)
09:33:54 <Booboorocks998> So is there a cleaner way to write this line: max_end3 x:xs = replicate 3 (max x (last xs))
09:34:09 <miguelarauj1o> quchen: one minute and I'll come back
09:34:58 <ski> Booboorocks998 : you need brackets around `x:xs' there, otherwise your left-hand side will be parsed as `(max_end3 x):xs'
09:35:11 <Booboorocks998> yeah compiler caught it
09:35:31 <siddhu> Booboorocks998: max_end3 (x1:x2:xs) = replicate 3 (max x xs) ?
09:35:32 <mniip> Booboorocks998, sounds like 'max_end3 x = replicate 3 $ max (head x) (last x)' is cleaner
09:35:41 <laudiacay> ski: you just pinged brackets 
09:35:43 <laudiacay> lol
09:35:43 <siddhu> I mean, (max x1 xs)
09:36:01 <mniip> siddhu, that's a type error
09:36:03 <ski> laudiacay : "pinged" ?
09:36:20 <laudiacay> ski: brackets is a user in this channel and like
09:36:26 <laudiacay> you just pinged him lol
09:36:29 <siddhu> I just realized I forgot what last does.
09:36:34 <siddhu> :t last
09:36:34 <laudiacay> brackets tab completes
09:36:34 <lambdabot> [a] -> a
09:36:44 <ski> Booboorocks998 : `max_end3 xs@(x:_) | y:_ <- reverse xs = replicate 3 (max x y)', perhaps (using the pattern guards extension)
09:36:54 <mniip> if you're pinged because your nickname is a common english word, well your fault
09:36:56 <ski> laudiacay : i see
09:37:08 <laudiacay> :P
09:38:10 <quchen> ski: a well-known combinator calculus
09:38:16 <ski> Booboorocks998 : note than my version will work on singleton lists, while your version above won't (though it can be fixed)
09:38:46 * ski is actually not a calculus, doesn't have bound variables
09:38:53 <Booboorocks998> Technically the function is supplied with a list of length 3
09:39:05 <ski> ok, then it doesn't matter
09:39:14 <mniip> ski is lame
09:39:16 <mniip> u is better :P
09:39:20 <jaspervdj> quchen: pong
09:39:48 <miguelarauj1o> quchen: I wasn't think about it. I want to write a doc with usefull functions that I founded in this tutorial: http://learnyouahaskell.com/introduction#about-this-tutorial
09:39:49 <miguelarauj1o> Thinking a little bit more, this is unecessary. thanks!
09:39:52 <quchen> jaspervdj: Hello. I'll PM you if that's alright.
09:39:57 <ski> mniip : i think arbitrarily mashing together different concepts into a single axiom/operation isn't very useful
09:40:04 <mniip> where u f = f const (<*>)
09:40:05 <jaspervdj> quchen: Yes
09:40:06 <mniip> or something
09:43:10 <_Booboorocks998> This doesn't compile: max_end3 (x1:x2:xs) = replicate 3 (max x1 xs)
09:43:21 <_Booboorocks998>  Couldn't match expected type `Int' with actual type `[Int]'  In the second argument of `max', namely `xs'
09:45:08 <siddhu> Yes, that was silly me thinking last is tail.
09:46:12 <weasel__> I have an elegance question: is there a better way to get Functor f => f (a -> b) -> a -> f b than \g x -> fmap ($x) g
09:46:46 <JagaJaga> How to count how many times my function was called in another function? For example in python I can add a count field to a class and everytime it's called increase it.
09:46:58 <weasel__> @pl \g x -> fmap ($x) g
09:46:58 <lambdabot> flip (fmap . flip id)
09:47:05 <saml> JagaJaga, StateMonad
09:47:37 <weasel__> I'm not sure that's actually more elegant
09:47:53 <ski> _Booboorocks998 : `x1' and `x2' are elements (`Int's), `xs' is a list (a list of `Int's, iow of type `[Int]')
09:48:09 <ski> _Booboorocks998 : `max' wants two arguments of the same type
09:48:19 <JagaJaga> saml: only like that? :(
09:48:43 <ski> weasel__ : not really
09:48:54 <saml> f :: Int -> a -> (Int, b)  
09:48:59 <saml> you can do that as well
09:49:02 <clrnd> JagaJaga, is this for debugging? have you checked Debug.Trace?
09:49:08 <ski> weasel__ : btw, for a while, `flip' in lambdabot had that type :)
09:49:16 <_Booboorocks998> would this be considered bad practice: replicate 3 $ (max x . last) xs
09:49:36 <JagaJaga> clrnd: no, it's for a research
09:49:45 * hackagebot tzdata 0.1.20150129.1 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20150129.1 (MihalyBarasz)
09:49:46 <weasel__> so it was a recognized combinator you'd want? I was surprised there wasn't anything in Control.Applicative with that signature
09:49:51 <mniip> _Booboorocks998, why write (f.g)x if you can write f$g x
09:50:21 <mniip> $ chains are normal sight in haskell
09:50:29 <exio4> they're not as cute!
09:50:30 <weasel__> it seems like an obvious partner to (<*>)
09:50:35 <JagaJaga> clrnd: doing  this https://en.wikipedia.org/wiki/Golden_section_search and need to count f(x) and f(b)
09:50:51 <clrnd> mniip, some people prefer to do `f . g . h $ j`
09:50:56 <ski> _Booboorocks998 : if you know `xs' won't be empty, it would be ok to use `last' there .. but if it turns out (because of a bug elsewhere) that it is empty, `last' erroring our won't directly say which call to `last' was at fault (though possibly it can be traced with the more fancy exception stuff in GHCi, not sure)
09:51:38 <mniip> clrnd, never seen someone do that
09:51:38 <ski> _Booboorocks998 : if you used pattern-matching to handle the potential failure (like in my pattern guards suggestion), then a failure would directly pinpoint the mismatching pattern in the source
09:51:48 <int-index> Help me invent an operator. It takes a function and a heterogeneous list to fold over. Example: given (a -> b -> c) and '[a, b] it gives you c.
09:52:01 * ski often prefers `(f . g . h) j'
09:52:02 <quchen> weasel__: g <*> pure x -- works but has an Applicative constraint
09:52:02 <int-index> It will be used for parsing grammars.
09:52:21 <int-index> I mean, help me invent a symbolic name for that operator.
09:52:50 <quchen> int-index: hcurry?
09:53:05 * ski thinks `$' looks ugly
09:53:12 <weasel__> int-index: I think you want chainl1, is it even possible to fold using that operator
09:53:13 <int-index> It needs to be a symbolic name for this kind of usage: f <%> a <+> b <+> c <+> d
09:53:13 <clrnd> JagaJaga, like saml said, State or (a, Int) will do
09:53:21 <int-index> <%> is my operator here
09:53:36 * clrnd prefers `a . b c . d $ f` too
09:53:40 <ski> (what's `(<+>)' there ?)
09:53:50 <weasel__> quchen: I was hoping I would be able to say that x is not part of an applicative. My use case is Maybe
09:53:50 <int-index> <+> here is from vinyl
09:53:54 <int-index> It's heterogeneous ++
09:54:42 <int-index> I think <%> will do for now.
09:55:06 <weasel__> int-index: what about <#> to suggest <++>
09:55:37 <saml> what about <{--}>
09:56:04 <int-index> saml, lol that's taken by Monoid
09:56:14 <saml> > let a <{--}> b = 1 in 1 <{--}> 1
09:56:15 <lambdabot>  <hint>:1:12: parse error on input ‘>’
09:56:35 <clrnd> -- is comment
09:56:45 <_Booboorocks998> Does (x1:x2:xs) match [1,2]
09:56:50 <ski> yes
09:56:54 <quchen> > let (--.) = (+) in 1 --. 2
09:56:55 <_Booboorocks998> and xs is []
09:56:56 <lambdabot>  3
09:57:08 <ski> > case [1,2] of x1:x2:xs -> (x1,x2,xs)
09:57:11 <lambdabot>  (1,2,[])
09:57:17 <quchen> Haskell has pretty awkward comment grammar to allow operators starting with "--".
09:57:21 <clrnd> wth ...
09:57:24 <clrnd> yeah
09:57:32 <saml> {- is comment
09:57:33 <voidzero> <°}}>
09:57:33 <siddhu> Using arrows, one could write `(\(x,y) -> max x y) (head &&& last$ [1..10])`
09:57:40 <quchen> Remember the first time you tried to use --| in Haddock? :-)
09:57:51 <ski> siddhu : `uncurry max'
09:57:55 <siddhu> So, is there a function to do: (\(x,y) -> f x y) ?
09:58:45 * ski notes that siddhu's question arrived after the answer
09:59:23 <siddhu> ski, how did you guess :P
09:59:32 <ski> i didn't
09:59:44 <ski> i just remarked on the code you mentioned already
10:00:09 <weasel__> quchen: that frustrated me, it took me about 15 minutes to find the answer because it's not really written down anywehre
10:00:18 <cfoch> please
10:00:22 <weasel__> quchen: that -- works that way, that is
10:00:26 <cfoch> can somebody give me a hand
10:00:33 <ski> (i couldn't know that that was what you were going to ask about. in fact i didn't realize you were going to ask anything at all)
10:00:36 <clrnd> cfoch, what is it?
10:00:37 <cfoch> I am trying to execute cabal haddock
10:00:38 <cfoch> http://fpaste.org/193935/55782431/
10:00:47 <cfoch> look ^ what happens
10:00:47 <quchen> weasel__: It's written *somewhere* (namely the language spec), but that's hardly very accessible, I agree.
10:01:27 <weasel__> quchen: fortunately I was reading about how haskell-type language grammars work that week already, or I would never have found it
10:02:05 <clrnd> cfoch, does `ghc-pkg list` show the package?
10:02:14 <clrnd> cfoch, are you in a sandbox?
10:02:15 <quchen> weasel__: I can only guess where the special comment syntax comes from. For one, --{2,} for line comments means that you can write separating lines of "-------".
10:02:18 <siddhu> uncurry max $ (head &&& tail)     vs     \xs -> max (head xs) (tail xs)    ?
10:02:29 <quchen> s/--/-/
10:02:38 <weasel__> siddhu: the first one
10:02:47 <_Booboorocks998> http://pastebin.com/K7M8JRZi
10:03:28 <_Booboorocks998> woops my comment block doesn't comment out everything. the last 3 lines are the code
10:03:45 <_Booboorocks998> 4*
10:03:58 <cfoch_> I lost my internet connection
10:04:10 <clrnd> _Booboorocks998, looks okay, weird the phrasing "if less than two, sum the elements" when they should be one
10:04:13 <ski> @type uncurry max . (head &&& last)  -- siddhu
10:04:15 <lambdabot> Ord c => [c] -> c
10:04:18 <cfoch_> If someone replied to me please tell me what you say again, please
10:04:22 <cfoch_> this was my error
10:04:24 <siddhu> shouldn't it just be, sum (take 2 xs) ?
10:04:27 <clrnd> cfoch, does `ghc-pkg list` show the package? are you in a sandbox?
10:04:28 <cfoch_> this is my error
10:04:28 <cfoch_> http://fpaste.org/193935/55782431/
10:04:35 <_Booboorocks998> I think it is just a mistake. It's from coding bat
10:04:41 <_Booboorocks998> http://codingbat.com/python/List-1
10:04:45 <cfoch_> clrnd: yes, I am in a sandbox
10:04:47 <_Booboorocks998> I'm doing those
10:05:14 <ski> _Booboorocks998 : that's a list, not an array
10:05:36 <clrnd> cfoch_, try doing `cabal exec ghc-pkg -- list | grep adjunctions`
10:05:41 <_Booboorocks998> The Python problems seemed like a pretty good way to play with haskell some before continuing on with lyah
10:05:53 <ski> _Booboorocks998 : also, i'd use `[x1]' and `[]' for patterns instead of `(x1:xs)' and `xs', in the latter two definition equations
10:06:35 <cfoch_> clrnd: let my explain what happens
10:06:46 <ski> _Booboorocks998 : this makes the three patterns disjoint (and still exhaustive), and so imho (because of disjointness) makes it easier to read (because you don't have to take ordering of the equations into account)
10:06:48 <_Booboorocks998> Ah yes! Ok. I vaguely remembered something like that from lyah, but I couldn't remember the syntax exactly
10:06:49 <cfoch_> I have a "sandboxed" folder called diagrams/
10:07:08 <cfoch_> in diagrams I have diagrams-core/ diagrams-lib/ diagrams-svg/ ...
10:07:26 <cfoch_> So... the command you told me when I am in diagrams/ folder shows me
10:07:32 <cfoch_>  adjunctions-4.2
10:07:43 <ski> _Booboorocks998 : `[x1]' is syntactic sugar for `x1:[]' .. if you really wanted to, you could use that, instead of `x1:xs'
10:07:56 <cfoch_> but if I am in the diagrams-core/ folder  (for example) it doesn't show anything
10:08:06 <cfoch_> clrnd: ^
10:08:08 <clrnd> cfoch_, wait, it's more complicated than that, each of those folders is a cabal pkg
10:08:31 <cfoch_> yes, each folder is a cabal package
10:08:39 <clrnd> cfoch_, if you want to build them all from source, you need to add them as pkg-dirs to your cabal sandbox
10:08:40 <_Booboorocks998> I've read through this part of lyah: http://learnyouahaskell.com/higher-order-functions
10:08:46 <clrnd> I never did it but I've read about it
10:09:21 <clrnd> cabal sandbox add-source
10:09:46 * hackagebot liquid-fixpoint 0.2.3.1 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.3.1 (EricSeidel)
10:11:30 <cfoch_> it would be something like
10:11:32 <cfoch_> cabal sandbox add-source diagrams-core/
10:11:34 <cfoch_> ?
10:14:24 <clrnd> cfoch_, in theory, yes
10:14:47 * hackagebot spatial-math 0.2.1.1 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.1.1 (GregHorn)
10:16:06 <cfoch_> but if after that i "cd diagrams-core/" and i make "cabal-harorddock" i get the samr er
10:16:11 <cfoch_> same error
10:16:20 <cfoch_> clrnd: ^
10:17:10 <clrnd> cfoch_, mmm what are you trying to build exactly? I understood you had a package that used this packages
10:17:52 <cfoch_> I just want to generate haddock documentation html files fore diagrams-core/
10:18:04 <cfoch_> *for diagrams-core/
10:19:06 <kaiyin> http://youtu.be/zYhkmMLEr18?t=28m37s could anyone explain the eq :: EqDict a -> a -> a -> Bool part?
10:19:24 <kaiyin> It just doesn't seem to be a correct type signature.
10:19:49 <clrnd> cfoch_, then, why not build the sandbox in diagrams-core?
10:20:18 <weasel__> kaiyin: it could be a typo ('->' for '=>') or EqDict a could be something you can use as (a -> a -> Bool)
10:20:25 <weasel__> kaiyin: I would guess the second
10:21:19 <cfoch_> #diagrams folks told me to create a diagrams/ folder with all the diagrams-*/ packages subfolders
10:22:08 <kaiyin> weasel__: What do you mean "EqDict a could be something you can use as (a -> a -> Bool)"?
10:23:12 <weasel__> kaiyin: Suppose EqDict a is [(a,a)], then you could do a lookup to see if two things are together. that lookup has type a -> a -> Bool
10:23:31 <weasel__> kaiyin: so EqDict is a dictionary of everything that's equal
10:24:16 <clrnd> cfoch_, ok ... and, don't you need a cabal file that declares a dependency on this other packages?
10:26:21 <cfoch_> clrnd
10:26:23 <cfoch_> http://fpaste.org/193954/42557984/
10:26:36 <cfoch_> does it suggest something for you?
10:27:21 <clrnd> cfoch_, I don't know if haddock needs the docs of the dependencies to build the docs of your pkg ...
10:27:24 <clrnd> does it?
10:27:46 <kaiyin> weasel__: what about the eq (EqDict f)  = f part, shouldn't it be (EqD f) instead?
10:28:18 <cfoch_> Fuuzetsu: ^
10:28:33 <weasel__> kaiyin: Yeah that's almost certainly a typo
10:29:04 <_Booboorocks998> [x + y | x <- [0..small], y <- [z * 5 | z <- [0..big]]]  Not sure how scope works in there.  Does z need to be z? Or would [x + y | x <- [0..small], y <- [x * 5 | x <- [0..big]]]  be fine
10:29:20 <weasel__> kaiyin: The same mistake is make with EqD so I think the lecturer just forgot which was the type constructor and which was the data constructor
10:29:47 * hackagebot fwgl 0.1.1.0 - FRP 2D/3D game engine  http://hackage.haskell.org/package/fwgl-0.1.1.0 (ZioCrocifisso)
10:30:34 <kaiyin> The lecturer is the famous Philip Wadler, ;-). Famous people make mistakes, too.
10:31:09 <cfoch_> clnrd: idk
10:33:48 <ski> _Booboorocks998 : the latter would be fine. though then you're having two separate/distinct variables, both called `x', which might be considered confusing
10:34:42 <ski> _Booboorocks998 : also, the former is equal to `[x + y | x <- [0 .. small],z <- [0 .. big],let y = z * 5]', or just `[x + z * 5 | x <- [0 .. small],z <- [0 .. big]]'
10:36:04 <ski> (obvious in this case, if you rename `z' to `x', then the `x' in `x + y' (or `x + x * 5') will refer to the latter `x', which isn't the same as in the above
10:36:07 <ski> )
10:36:33 <_Booboorocks998> ski: oh yep that'd be better, huh
10:37:05 <cfoch_> clnrd: the problem i think is that it is not finding the adjunctions package
10:37:20 <_Booboorocks998> http://codingbat.com/prob/p143951
10:37:26 <_Booboorocks998> I'm super stuck on this problem
10:38:01 <weasel__> _Booboorocks998: will sum . nub work?
10:38:03 <cfoch_> so i would have in some way to tell cabal: "hey, cabal, i am using sandbox... look for adjunctions here"
10:38:14 <cfoch_> how can i do that?
10:38:45 <clrnd> cfoch_, I just went ahead, cloned diagrams-core and built haddocks, it worked
10:39:00 <clrnd> cfoch_, first, it doesn't need docs of dependencies
10:39:28 <ski> _Booboorocks998 : are those `lone_sum' examples part of the specification, or part of your interpretation of it ?
10:39:44 <ski> weasel__ : not according to those examples, at least
10:39:48 <clrnd> cfoch_, my guess is that your sandbox is not in diagrams-core
10:39:55 <_Booboorocks998> they are part of the example
10:39:59 <ski> ok
10:40:04 <ski> hm
10:40:07 <_Booboorocks998> specification*
10:40:09 <cfoch_> no... this is in "../diagrams-core/"
10:40:12 <ski> yea
10:40:19 <cfoch_> so in "diagrams/" folder as I said
10:40:35 <_Booboorocks998> i was thinking creating a list x:y:z:[] and then comparing each to it before adding it
10:40:49 <_Booboorocks998> as in checking if it is an elem
10:40:55 <ski> _Booboorocks998 : you could check the three cases ..
10:40:58 <clrnd> cfoch_, I gues you could in theory make a pkg that depends on diagrams-* and build them all, I'm not sure it's that simple thought
10:41:12 <_Booboorocks998> shit that won't work. it'd have to exclude itself once
10:41:14 * ski doesn't see how checking elementhood in `[x,y,z]' would help
10:41:24 <_Booboorocks998> lol
10:42:15 <weasel__> ski: oh of course. something along the lines of sum . map fst . filter ___ . map (length and value) . groupBy (==)
10:42:42 <ski> weasel__ : *nod*
10:44:03 <_Booboorocks998> wot
10:44:34 <clrnd> cfoch_, I guess you could start a project that depends on diagrams-*, and then haddock that
10:45:14 <clrnd> cfoch_, hey I just got your error
10:45:20 <bergey> cfoch: if you have a sandbox already in diagrams/ you can init a sandbox in diagrams/diagrams-core that just points to the existing sandbox, but makes commands run while in diagrams-core use that sandbox.
10:45:22 <clrnd> cfoch_, it's because it doesn't have adjuncitons
10:45:38 <bergey> cabal sandbox init --sandbox=../
10:47:16 <siddhu> hmmm. we could potentially write unreadable code by saying [x + z*5 | x <- [0..5], z <- [0..10]] is equivalent to (+) <$> (*5) <$> [0..10] <*> [0..5].
10:48:00 <siddhu> using fmap instead of (<$>) would probably make it readable.
10:48:01 <bergey> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html has a more complete explanation.
10:48:57 <clrnd> > succ `fmap` (Just 5)
10:48:58 <lambdabot>  Just 6
10:49:48 <_Booboorocks998> http://pastebin.com/WNvpzzSz
10:53:33 <JaAnTr> Hi, I'm trying to implement post increment and decrement operators in Haskell but in IMP(Not sure exactly what this is, we use it in lectures but googling it gives languages which I'm not sure it is). I need to write constructors Incr and Decr for those two operations but I'm not sure exactly how to do that. Here is my code so far - http://pastebin.com/x0SVK33G . Thanks.
10:54:40 <ski> JaAnTr : apparently you're implementing interpreters for mini-programming-languages, in Haskell. presumably "IMP" will be a mini-imperative-language
10:55:07 <JaAnTr> Ski: Yes that makes sense with regards to what we've been doing in lectures.
10:55:46 <ski> JaAnTr : it's not clear if you want `Incr'/`Decr' to be constructions for expressions (represented in Haskell by your datatype `Aexp') or by commands/statements (which would need another datatype then)
10:56:08 <_Booboorocks998> it looks so terrible
10:56:27 * ski deduces `type State = Variable -> Integer' in JaAnTr's code
10:56:51 <JaAnTr> ski: These our the instructions if it helps - Complete the data type Aexp for Aexp given in coursework_1.hs, using the constructors Incr and Decr for post-increment and post-decrement. Un- comment factorial and runfactorial, which should pass type-checking.
10:56:58 <ski> _Booboorocks998 : use guards
10:57:48 <ski> JaAnTr : ok, so sounds like your expressions will then be side-effecting. then you'll need to change the type of `evalA' (or make a variant of it with a chaned type)
10:58:40 <JaAnTr> ski: Is this the type - evalA :: Aexp -> State -> Integer because I've added that in myself to the skeleton code provided but could be totally wrong.
11:00:10 <_Booboorocks998> can I overload a function based on number of arguments/type?
11:03:32 <HeladoDeBrownie> _Booboorocks998, the short answer is no.
11:03:32 <mgsloan> _Booboorocks998: Yes, but it's not something people do very often.  Having a variable number of arguments isn't a feature of the language, but instead something you can do with typeclasses
11:03:33 <siddhu> _Booboorocks998, I wouldn't recommend it: http://okmij.org/ftp/Haskell/polyvariadic.html
11:04:13 <HeladoDeBrownie> that was a discordant fugue
11:04:17 <siddhu> There's some good papers on polyvariadic functions, but there's almost no good reason to use them.
11:05:03 <ianjneu> siddhu: o_O map? apply? zip?
11:05:04 <mgsloan> Yup, I'm glad it itsn't part of the language
11:05:20 <HeladoDeBrownie> ianjneu, those are polymorphic, not polyvariadic
11:05:35 <_Booboorocks998> I ended up just making slightly different function names 
11:05:41 <HeladoDeBrownie> polyadic? anyway the latter means varying number of arguments
11:05:54 <ianjneu> HeladoDeBrownie: they're polyvariadic in Racket. I'm referring to Haskell's plethora of zip2 up to zip26
11:06:18 <ski> JaAnTr : that is the type of your current `evalA'
11:06:33 <HeladoDeBrownie> ianjneu, ah, i see. well afaik racket is unityped, right? i think that's what makes that feasible
11:06:46 <siddhu> ianjneu: I didn't realize that. Though, don't we normally abstract to listzippers instead of using zip6 ?
11:06:48 <ianjneu> HeladoDeBrownie: Typed Racket has "polydots" to model them.
11:06:54 <JaAnTr> ski: currently, but I just copied that from some problem sheets I'd done a few weeks ago as we had an data Aexp in.
11:07:06 <ski> JaAnTr : however, if the state can be modified (by post-increment and pre(?)-decrement operations) by evaluating an expression, then you also need to return the new state, not just the resulting integer value
11:07:08 <HeladoDeBrownie> ianjneu, what is that?
11:07:46 <ianjneu> HeladoDeBrownie: (forall (B A ...) (A ... -> B) (List A) ... -> (List B))
11:07:55 * ski . o O ( polyvariant specialization )
11:07:58 <ianjneu> A is some heteorgeneous list of types..
11:08:01 <HeladoDeBrownie> hmm
11:08:06 <rmorgan1> I have a question about some code: http://lpaste.net/122040. The parseSent function works, to an extent, but it gets tripped up when there are multiple newline characters separating words. Why is this? The issue seems to be with the newLn combinator, but I don't know what.
11:08:49 <ski> ianjneu : rather, `(A ...)' is that list of types
11:09:00 <HeladoDeBrownie> rmorgan1, it's expecting a word between
11:09:01 <JaAnTr> ski: I'm not sure if the state needs to be modified. Here is the semantics of the increment and decrement. A[v++](s)=(t,n) where t=s[v􏰀→n+1] and n=s(v)                                    A[v−−](s)=(t,n) where t=s[v􏰀→n−1] and n=s(v)
11:09:12 <ski> (`A' itself is more like a side-effectful variable. compare with plurals in natural language)
11:09:16 <HeladoDeBrownie> rmorgan1: ((many1 (char '\n')) *> word) -- and word involves at least one character
11:09:37 <ianjneu> ski: Yes
11:09:48 <ski> JaAnTr : ok, so post-decrement, not pre-decrement (it wasn't clear above)
11:09:59 <ianjneu> It's a nice balance between ML-ish typing and full dependent types.
11:10:09 <HeladoDeBrownie> rmorgan1, oh, i may have misread, sorry. let me take another look
11:10:21 <ianjneu> As such, there are ways to knock it over and get frustrated.
11:10:30 <ski> JaAnTr : so, you see that here you return a pair of the new state `t', and the resulting integer value `n'
11:10:43 <ski> JaAnTr : so, you need a modified type signature
11:11:01 <rmorgan1> HeladoDeBrownie: No worries! It's really strange, because I'd think that (many1 (char '\n') *> word should parse an arbitrary number of '\n's before trying to parse a word
11:11:05 <HeladoDeBrownie> rmorgan1, i do notice you use word in two places, was that intentional?
11:11:41 <HeladoDeBrownie> rmorgan1, you wants "words" to be separated by "word separators", but those separators also include words.
11:11:49 <ski> ianjneu : the `...' as used in `syntax-rules' macros (and some of the more fancy macro systems) -- and apparently also in Typed Racket -- is quite an interesting thing
11:12:00 <ski> JaAnTr : makes sense ?
11:12:03 <rmorgan1> HeladoDeBrownie: Ohhh! I think I see what you're saying
11:12:54 <JaAnTr> ski: I think I understand kind of. Initially n is v in the state s. After it has been decremented that's what I'm not sure I understand. Is it in the state t and n is 1 less?
11:12:57 <rmorgan1> HeladoDeBrownie: So the parser 'thinks' that it is suppose to parse a word that is separating *other* words?
11:13:56 <ianjneu> ski: the semantics of ellipses is quite different between the two systems, since polydots actually defines an abstraction, and not a process.
11:14:45 <HeladoDeBrownie> rmorgan1, imagine this scenario: "worda\n\nwordb\nwordc". parses worda fine, then wants to parse the separator which will consume \n\nwordb. now you don't have a valid word left to consume for the next word, since the separator parsed it.
11:14:52 <cfoch_> bergey: "cabal sandbox init --sandbox=../" inside diagrams-core/ and then "cabal haddock" right?
11:15:18 <HeladoDeBrownie> rmorgan1, i didn't run the code, but i *suspect* that's the problem. my suggestion then would be to take the use of word out of the separator
11:15:19 <JoshieAS> why all the hate for 'do' blocks?
11:15:41 <ski> ianjneu : i don't see what you mean by "abstraction" and "process" here
11:16:05 <ski> JoshieAS : sometimes it feels too operational
11:16:07 <rmorgan1> HeladoDeBrownie: I tried making the newLn separator just (many1 (char '\n')), but the same thing still happens, where it fails, because of an 'unexpected \n'
11:16:25 <ski> JoshieAS : of course, it depends on what you're comparing with
11:16:39 <HeladoDeBrownie> rmorgan1, hmm, can you describe the language you're attempting to parse? make an lpaste of it
11:17:28 <bergey> cfoch_: right
11:17:48 <_Booboorocks998> thanks for the help
11:17:52 <_Booboorocks998> <3
11:18:05 <clrnd> > 2 <3
11:18:06 <lambdabot>  True
11:18:08 <ski> JaAnTr : in state `s', the value of `v' is fetched, and called `n'. the result of evaluating the `v++' or `v--' expression will be this value `n'. however, in the new state `t' (after evaluating the expression), the value of `v' is set to be `n+1'/`n-1'
11:18:40 <JoshieAS> ski: is the case FOR them that they're more readable?
11:18:44 <ianjneu> ski: The ellipses in syntax-rules define how to apply a syntax transform, but there is nothing about its interface that's checked.
11:18:44 <cfoch_> bergey: I get the same error
11:18:47 <ski> JaAnTr : so, now the evaluation of *every* expression will return a pair of the (possibly) new state (after evaluating that expression) and the result value of evaluating the expression
11:18:57 <cfoch_> remember that diagrams/ folder is already "sandboxed"
11:19:31 <JaAnTr> ski: Ok, cheers that makes sense. What do you mean by a modified type signature? Is that what I need to do next?
11:19:46 <ski> JaAnTr : .. which means that you need to go change all the previous cases in your evaluation of expressions, to properly pass ("thread") through the state through the subcomputations (here recursive calls)
11:20:23 <rmorgan1> HeladoDeBrownie: Does this help: http://lpaste.net/122061?
11:20:34 <ski> JoshieAS : `do' is often (not always) more readable than using plain `(>>=)'s and `(>>)'s, yes
11:21:15 <HeladoDeBrownie> rmorgan1, that's an example input; i was wondering what the actual language was. is it just strings of alphabetical characters separated by one or more newlines?
11:21:25 <ski> JoshieAS : however, you might be comparing `do' to using some monadic "combintor" functions .. or to idiomatic/applicative combinators .. and then one might prefer to not use the `do' version
11:21:32 <rmorgan1> HeladoDeBrownie: The docs I'm working with are sort of complicated, so I've been using very simplified inputs just to get the parser going for enough cases to make it feasible to start trying to parse the whole document
11:21:42 <bergey> cfoch_: Yes, the command I gave only makes sense if there's already a sandbox in diagrams/
11:21:50 <ski> ianjneu : ok ?
11:22:08 <rmorgan1> HeladoDeBrownie: It's mostly English text in word perfect/sgml formatted documents
11:22:09 <bergey> `cabal info` still shows that adjunctions is installed in diagrams/ but not in diagrams-core/?
11:22:17 <ski> ianjneu : i still don't see how `...' behaves differently in the two cases
11:22:20 <cfoch_> bergey: http://fpaste.org/193983/42558320/
11:22:42 <rmorgan1> HeladoDeBrownie: By text, I guess I mean scientific and literary prose
11:23:13 <ski> JaAnTr : by "modified type signature" i mean that you'll have to modify `Aexp -> State -> Integer' to something that expresses that we now not only returns a result value (an integer), but also a (possibly) new state
11:23:23 <cfoch_> bergey: according "cabal info"  in the diagrams-core/ directory it says it is not installed
11:24:23 <HeladoDeBrownie> rmorgan1, i'm installing parsec now and going to attempt fiddling with it
11:25:06 <HeladoDeBrownie> rmorgan1, i still do think the problem is that word gets used twice, but we'll see
11:25:20 <rmorgan1> HeladoDeBrownie: Aww thanks :)
11:25:22 <HeladoDeBrownie> rmorgan1, what happens if you just delete " *> word"
11:25:28 <bergey> cfoch_: I don't know what's going on.  If it were me, I'd start `cabal clean` and rebuilding things.  I realize that's not satisfying advice.
11:25:55 <rmorgan1> HeladoDeBrownie: The same sort of error, actually
11:26:10 <HeladoDeBrownie> rmorgan1, i actually never saw you paste an error, can you do that?
11:26:29 <fragamus> is there an n choose 2 function
11:26:31 <rmorgan1> HeladoDeBrownie: It complains about there being an unexpected \n. Will lpaste an error
11:26:32 <ski> HeladoDeBrownie : hmm .. i wondered why `*> word' was there
11:27:24 <HeladoDeBrownie> so the input "foo\nbar\n\nbaz" should result in ["foo", "bar", "baz"]
11:27:37 <JaAnTr> ski: So it would look like this -  evalA :: Aexp -> State -> (Integer, State) ?
11:27:50 <ski> fragamus : `\n -> div (n * (n - 1)) 2' ?
11:27:52 <HeladoDeBrownie> (realizing it's Text; i'm using overloaded string literals here)
11:28:14 <rmorgan1> HeladoDeBrownie: Here is the updated lpaste to reflect the deletion of *> word and the sort of error I've been getting: http://lpaste.net/122040 
11:28:20 <ski> JaAnTr : yes .. or perhaps in the other order, to conform more closely with the "mathy" specification
11:28:24 <ski> (matter of taste)
11:29:25 <fragamus> ski: i need to generate the actual permutations
11:29:31 <HeladoDeBrownie> rmorgan1, okay, reproduced that error, now taking a look why
11:29:48 <gyaretto> I'm getting a parse error on the `print` on the last line of Main.hs. https://gist.github.com/42ccabe78fdf9b9f992c
11:29:51 * hackagebot HostAndPort 0.1.0 - Parser host and port pairs like localhost:22  http://hackage.haskell.org/package/HostAndPort-0.1.0 (slava)
11:29:53 <gyaretto> I can't figure out why.
11:31:38 <rmorgan1> HeladoDeBrownie: Cool -- Thanks so much for helping me out :)
11:31:39 <ski> > [[x,y] | x:xs <- tails "abcd",y <- xs]  -- fragamus ?
11:31:39 <nickc_> I'm writing a parser (with an Expr type that can be of several subtypes) and need to be able in one part to filter by type. Here's how I'm doing it and how I would like to do it. Please let me know if I'm thinking about it the wrong way or can provide more information. https://gist.github.com/ncammarata/15c56ec49b53f4603ba5
11:31:41 <lambdabot>  ["ab","ac","ad","bc","bd","cd"]
11:32:33 <pavonia> rmorgan1: Note that you only allow a single seppr between two words
11:32:55 <fragamus> ski:       : )
11:33:16 <ski> fragamus : what you wanted ?
11:33:30 <rmorgan1> pavonia: Oh! Whoa, so i need to have something that allows for arbitrarily many seppr(s)?
11:34:04 <pavonia> rmorgan1: Oh wait, there's "many1 (char '\n')"
11:34:11 <rmorgan1> yeah
11:34:58 <ski> nickc_ : `[s | Two s <- all]'
11:35:32 <rmorgan1> pavonia: The applicatives in the sepprs part of the where clause are multicharacter sequence, but the applicatives seem to allow them to be treated like one
11:35:51 <HeladoDeBrownie> rmorgan1, i'm running into a small web of type errors but i think once around those it should be fine without the "*> word"
11:36:03 <S11001001> nickc_: if you use the prism generators from lens, you get a filter for free
11:36:06 <HeladoDeBrownie> trying to get this into a workable form so i can show you
11:36:27 <S11001001> nickc_: though this is slightly more involved at the start than ski's suggestion
11:36:34 <JaAnTr> ski: Ok thanks, what do I need to do next? I assume it's this bit - "Complete the data type Aexp for Aexp given in coursework_1.hs, using the constructors Incr and Decr for post-increment and post-decrement. " but what does a constructor look like? I've read about them on the Haskell wiki but I'm not sure how to implement it here.
11:36:40 <S11001001> @ty (^.. folded . _Left)
11:36:41 <lambdabot> Foldable f => f (Either a c) -> [a]
11:37:06 <S11001001> @ty (^.. folded . folded . _Left . _Right)
11:37:07 <lambdabot> (Foldable f1, Foldable f) => f (f1 (Either (Either c1 a) c)) -> [a]
11:37:26 <rmorgan1> HeladoDeBrownie: Okay :). Unfortunately the errors have been a little more opaque to me than usual
11:38:02 <nickc_> S11001001 & ski thanks! I'll start off with the simple fix and if I end up needing to use it more than once I'll definitely research further
11:38:09 <ski> JaAnTr : `Num',`Var',`(:+:)',`(:-:)',`(:*:)' are the current five (data) constructors of `Aexp' in the paste <http://pastebin.com/x0SVK33G>
11:38:40 <HeladoDeBrownie> rmorgan1, one thing to notice is you really don't need to make the output of sepprs into Text, it's just going to be discarded
11:38:44 <HeladoDeBrownie> seppr*
11:38:53 <ski> JaAnTr : you need to add two more cases, for post-increment and post-decrement, specifying type(s) for the argument values that the constructors will need for the information you want them to carry
11:38:57 <HeladoDeBrownie> rmorgan1, so PT.Parser () will serve just as well
11:39:42 <rmorgan1> HeladoDeBrownie: Ahh okay. Would I then be able to eliminate the fmapped T.pack/T.singleton calls then?
11:39:57 <ski> JaAnTr : iow, you make new constructors by just listing them in the data type definition, with the attendant argument type(s) that you want for each one of them
11:40:04 <HeladoDeBrownie> rmorgan1, well that's funny. i managed to get it to work if you didn't have sepprs as a possibility (inside seppr). i wonder why
11:40:16 <pavonia> rmorgan1: Ah, "space" is misleading, it doesn't parse only the space character but any white space satisfying isSpace
11:40:23 <HeladoDeBrownie> rmorgan1, i only see you use pack in a place where you needed it
11:40:40 <HeladoDeBrownie> singleton on the other hand, yeah
11:40:41 <ski> JaAnTr : e.g. `Num' is declared to take a single argument, which must be of type `Integer'. `Var' is also declared to take a single argument, this time of type `Variable'
11:41:16 <moghedrin> Can anybody lend an eye, tell me what I'm not understanding here? :L http://pastebin.com/Sj3dNqUj
11:41:19 <HeladoDeBrownie> rmorgan1, i got it.
11:41:28 <HeladoDeBrownie> rmorgan1, did you know, \n is parsed by space?
11:41:54 <rmorgan1> HeladoDeBrownie: I had no idea, lol
11:41:56 <HeladoDeBrownie> XD
11:41:57 <ski> JaAnTr : `(:+:)' is declared to take two arguments, of types `Aexp',`Aexp'. also it is given a "symbolic" name, so that it becomes an infix operator (which is why it is written between, instead of in the front). similarly for the two other infix operator data constructors
11:42:26 <HeladoDeBrownie> rmorgan1, i think that is a poorly named parser, it should be whitespace or something :P
11:42:40 <dolio> moghedrin: prereqs :: forall b. (Prereq b) => a -> [b]
11:42:52 <EvanR> > isSpace '\n'
11:42:53 <lambdabot>  True
11:42:56 <EvanR> wtf
11:43:01 <rmorgan1> HeladoDeBrownie: Would you be able to lpaste hoow you changed the code?
11:43:05 <HeladoDeBrownie> EvanR, also a poorly named function!
11:43:09 <dolio> That means that function is obligated to produce a 'b' of any requested type, with the knowledge that it is a Prereq.
11:43:15 <HeladoDeBrownie> rmorgan1, okay, in that case i still have a few changes to make. one moment.
11:43:24 <dolio> moghedrin: But, you have instead chosen a specific Prereq type.
11:43:26 <rmorgan1> okay, no worries :)
11:44:41 <moghedrin> dolio: Okay. I understand. How else would I express what I'm trying to do here?
11:45:05 <HeladoDeBrownie> rmorgan1: http://lpaste.net/122040#a122090
11:45:24 <dolio> moghedrin: Depends. Does the Action type determine the Prereq type?
11:45:32 <moghedrin> dolio: Yes.
11:45:44 <HeladoDeBrownie> rmorgan1, you can feel free to remove the OverloadedStrings pragma, i just used that for the literal in main
11:45:48 <dolio> Then you could use multi-parameter type classes and functional dependencies.
11:45:55 <HeladoDeBrownie> rmorgan1, on the other hand it can be useful
11:46:03 <moghedrin> dolio: Will look into :) Thank ye!
11:46:08 <dolio> class Prereq b => Action a b | a -> b where ...
11:46:17 <NemesisD> i've got a weird, vague question so apologies upfront. i'm looking for a way to combine several types in some sort of type-level set, say i've got a typeclass ToMap a where toMap :: a -> Map String Value, and that has a monoid instance, i want to combine Foo, Bar, Baz into a type-level set and then have a ToMap instance that mappends each individual toMap
11:46:17 <NemesisD> call
11:46:23 <NemesisD> is this complete crazy talk?
11:46:46 <dolio> You could also use an associated type intead of a functional dependency.
11:46:49 <dolio> Instead, even.
11:47:16 <rmorgan1> HeladoDeBrownie: Thank you so much! I've been tweaking this for sometime -- I'm fine with the overloaded strings bit :)
11:47:27 <HeladoDeBrownie> rmorgan1, so, works as you expected now?
11:48:09 <dolio> class Prereq (Pre a) => Action a where type Pre a :: * ; prereqs :: a -> [Pre b] ; ...
11:48:29 <HeladoDeBrownie> anyway, no problem. that was kind of a "fun" debug attempt XD
11:49:22 <HeladoDeBrownie> rmorgan1, oh oops, i didn't put back the <?> annotation. although, it was attached to the wrong thing anyway.
11:49:32 <rmorgan1> HeladoDeBrownie: It seems to be!
11:49:36 <rmorgan1> oopsie :)
11:49:39 <HeladoDeBrownie> rmorgan1, okay sweet. glad i helped
11:50:05 <rmorgan1> Yay!! It's working in ghci. Thank you so so so much
11:50:09 <lpaste> funfunctor pasted “No title” at http://lpaste.net/122096
11:50:23 <moghedrin> dolio: Uhhhh... *backs away slowly* Baby steps ;P I think I'll stick with the other approach.
11:50:28 <funfunctor> how do I convert this snip from malloc to alloca ?
11:50:48 <rmorgan1> I love haskell, but it's my first general purpose language, so I feel like i'm the lowliest haskeller around sometimes ;)
11:50:59 <dolio> moghedrin: Just two subtly different ways of doing the same thing.
11:51:16 <JaAnTr> ski: Would the constructors be           | Incr State Variable           | Decr State Variable
11:51:48 <ski> rmorgan1 : ooc, what other languages have you come into contact with ?
11:52:27 <funfunctor> because naturally the last stmt in the do block can't be an assigment
11:52:29 <ski> JaAnTr : `State' is part of the evaluation process. `Aexp' describes a program (expression). the program exists before it starts to evaluate
11:52:46 <speeder> distance :: [Score] -> [Score] -> Score
11:52:49 <speeder> distance a b = sum . map abs $ zipWith (-) a b
11:52:51 <speeder> what this thing do?
11:52:53 <rmorgan1> ski: I tried about five times to learn python but i didn't know what to do with it so that stalled
11:53:08 <ski> JaAnTr : .. ergo, the program (think of it as "text", if you like) should probably not contain an evaluation-time concept like "state"
11:53:11 <speeder> I am not a haskell coder (I am a C++ codeR) but the only algorithm I found for what I want is in a book about haskell
11:53:23 <rmorgan1> ski: then in grad school, i took statistics and got into R, which really opened up ideas about what i could use programming for
11:53:23 <speeder> and seemly to me the most important part is the lines I pasted
11:53:30 <JaAnTr> ski: Oh yes of course. So           | Incr Variable           | Decr Variable ?
11:53:34 <funfunctor> speeder: take a look at the the type-signature (prototypes) for each of those functions in ghci
11:53:51 <funfunctor> speeder: ghci  and do :t (.) and :t map for example
11:53:57 <funfunctor> :t (.)
11:53:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:54:02 <rmorgan1> ski: so basically R is my first programming love, but haskell is my favourite
11:54:18 <speeder> funfunctor: I don’t understood a word of what you said
11:54:34 <funfunctor> speeder: (.) is function composition, so (sum . map) is the composition of those functions
11:54:34 <ski> JaAnTr : think of expressions like `n' (for any integer numeral/literal `n'), `v' (for any variable name/identifier `v'), `e0 + e1',`e0 - e1',`e0 * e1' (for any expressions `e0' and `e1') -- these are the "concrete syntax" versions of your expressions (sans the increment and decrement stuff)
11:54:39 <rmorgan1> ski: since learning enough haskell to make sense of programming more generally, i've played with python, rust, c
11:54:47 <HeladoDeBrownie> haskell quickly became my favorite language after i started it. previously i was studying javascript, and managed to learn a good amount of its ins and outs, but, looking back, i think i much prefer haskell's ins and outs.
11:54:51 <speeder> funfunctor:  oh, this helps
11:54:54 <funfunctor> speeder: (f . g) x = f (g (x))
11:55:00 <speeder> funfunctor:  and $?
11:55:09 <funfunctor> speeder: $ is function application
11:55:12 <funfunctor> :t ($)
11:55:13 <lambdabot> (a -> b) -> a -> b
11:55:47 <speeder> my impression or haskell is a langauge to describe math functions?
11:56:06 <funfunctor> speeder: so that says "give me a function from a to be (a -> b) and 'a' and i'll give you back the b
11:56:07 <ski> JaAnTr : we *represent* these expressions by various possible shapes of an `Aexp' in Haskell, by `Num n' (for a Haskell number `n', acting as a standing for the numeral/literal), `Var v' (with `v' being some Haskell representation of a variable name/identifier', and `e0 :+: e1',`e0 :-: e1',`e0 :*: e1' (with `e0',`e1' being the corresponding subexpressions, represented in Haskell)
11:56:11 <moghedrin> speeder: It certainly does well at that, but it's a general purpose language.
11:56:22 <HeladoDeBrownie> speeder, it's a general-purpose programming language, however its syntax and semantics are definitely inspired by math things to a degree.
11:56:38 <EvanR> math is a general purpose language ;)
11:56:47 <funfunctor> :D
11:57:04 <moghedrin> EvanR: Oooh. I like that.
11:57:18 <funfunctor> EvanR: i'm being dumb with these alloca conversions
11:57:36 <EvanR> why do you think that
11:58:02 <funfunctor> http://lpaste.net/122096 <- my retardedness
11:58:09 <ski> JaAnTr : now, similarly, for the new possible forms of expressions, `v++' and `v--' we need concrete shapes (constructors) of the `Aexp' type to represent them. in both cases, the only "variable" information is `v' (which stands-in for any concrete variable identifier), therefore, we only need one argument for the `Incr' and `Decr' constructors. so `Incr v' and `Decr v' (with `v' being a Haskell representation of the variable identifier, iow of type `Variab
11:58:31 <ski> JaAnTr : er. possible cut off there near ".. so `Incr v' and `Decr v' (with `v' being a Haskell representation of the variable identifier, iow of type `Variable', as for the `Var' case above)"
11:58:36 <ski> JaAnTr : makes any sense ?
11:58:59 <EvanR> funfunctor: looks good to me except the extraneous comments
11:59:05 <HeladoDeBrownie> funfunctor, would prefer if you didn't use that sort of slur here
11:59:14 <ski> JaAnTr : .. and of course i now notice you said "So           | Incr Variable           | Decr Variable ?" -- which is exactly what i gave a rationale for, good :)
11:59:39 <ski> rmorgan1 : ok, interesting
12:00:07 <funfunctor> EvanR: but line 8 is an assignment in the last stmt of a do block which obviously can't happen
12:00:16 <funfunctor> HeladoDeBrownie: no worries, sorry.
12:00:28 <ski> speeder : math is a language to describe reality (and non-reality)
12:00:30 <EvanR> funfunctor: oh right
12:00:59 <EvanR> funfunctor: i updated it
12:01:15 <funfunctor> EvanR: also, is that alloca just type-inferring the size?
12:01:17 <funfunctor> thx!
12:01:24 <lpaste> sebastard pasted “Consume infinite list” at http://lpaste.net/122109
12:01:24 <HeladoDeBrownie> funfunctor, thanks
12:01:30 <EvanR> funfunctor: size of what?
12:01:45 <funfunctor> EvanR: the pointer
12:01:54 <funfunctor> oh derr, should have seen that
12:02:08 <sebastard> Can someone help me with the code I pasted there? I am looking for a way to consume an infinite list of input until the output is large enough
12:02:24 <JaAnTr> ski: just copied everything you've said in to a word doc and gonna go over and read it slowly haha.
12:02:25 <EvanR> funfunctor: the size of the object the pointer is pointing to... yes thats being determined from the Storable instance
12:02:42 <ryanar> Hello
12:03:43 <sebastard> Hi :)
12:03:56 <ski> sebastard : it's not clear what "consume" means here
12:03:57 <lpaste> ryanar pasted “instance Show” at http://lpaste.net/122113
12:04:15 <ski> consume by repeated `bar'ring ?
12:04:24 <ski> or by some function of the same type ?
12:04:43 <ski> JaAnTr : it happens :)
12:04:55 <ski> ryanar : hello yourself
12:05:06 <funfunctor> EvanR: thx ok. I'll go though and fix all my malloc's to alloca now then. Offhand, why do you prefer the style of (return . toEnum . fromEnum) over return $ (toEnum . fromEnum) ?
12:05:21 <funfunctor> is there some "good practice" advice I am missing there?
12:05:29 <EvanR> i dont prefer it i just felt like removing the $
12:05:31 <ryanar> trying to figure out why the zip is assuming [1..length[a]] is of type [Char]
12:05:32 <ski> funfunctor : "avoid `$'" ?
12:05:41 <ryanar> zip function*
12:05:43 <sebastard> yes repeated barring, it needs to "eat" one bool at the time and update the state
12:06:06 <sebastard> then eat the next bool (and update the state), until the output it generated is large enough
12:06:20 <ski> sebastard : so you know `bar' will always output a subsingleton string ?
12:06:26 <funfunctor> whats so bad about $ ?
12:06:37 <ski> it's ugly ?
12:06:39 <mauke> ryanar: what's the error message?
12:06:40 <lpaste> ryanar revised “instance Show”: “No title” at http://lpaste.net/122113
12:06:42 <funfunctor> lol
12:06:44 <sebastard> well here I pasted a minimal example, but in my real code it could be several characters long
12:06:50 <funfunctor> ok, nothing technical then
12:07:05 <voidzero> I always do that too, it makes things slightly easier to read
12:07:27 <ski> funfunctor : `f . g . h $ x' is better than `f $ g $ h $ x'. the former is easier to refactor, since both `f . g' and `g . h' are valid subexpressions
12:07:28 <funfunctor> $ helps me read the code "apply the stuff on the RHS and then call return with the result on the LHS"
12:07:35 <voidzero> plus, sometimes it can be an exercise to learn where you can replace them
12:07:53 <ryanar> erorr is Couldn't match expected type `[Char]` with actual type `Integer` in the expression: a in the second argument of 'zip', namely `[a]`
12:07:58 <EvanR> funfunctor: but thats a weird distinction
12:08:10 <ryanar> on line 4
12:08:12 <ski> sebastard : so, in general you'd have to check the length of the string that `bar' outputs, right ?
12:08:23 <sebastard> ski: yes
12:08:24 <EvanR> funfunctor: return $ toEnum $ fromEnum $ l would also work
12:08:27 <mauke> ryanar: what's the type of sudokuConfigToString?
12:08:29 <funfunctor> its only because the return function is the "way out" of the IO monad, the exit door if you will
12:08:42 <ski> sebastard : .. or at least to count down/up, when comparing it with `outputLength'
12:08:43 <JaAnTr> ski: Ok, so I've got my head around it. Next i need to do the evalA bit I think, correct?
12:08:47 <EvanR> return function is the way *in* into the IO monad ;)
12:08:48 <funfunctor> I think of it as the sink
12:08:51 <ski> JaAnTr : i think so
12:09:01 <EvanR> there is no way out
12:09:09 <ryanar> mauke: easier to just show
12:09:11 <funfunctor> oh, well true
12:09:16 <levi> I waffle between preferring `f . g . h $ x`  or  `(f . g . h) x` 
12:09:16 <voidzero> I'm also assuming that (f . g . h) works differently from (f $ g . h)
12:09:26 * HeladoDeBrownie tries to dig up that lambda cats thing…
12:09:28 <S11001001> return -- going beyond the event horizon
12:09:31 <EvanR> funfunctor: you can use return at any point in your do block, it will not "return" like in C
12:09:35 <voidzero> but i didn't realise this assumption until just now. :)
12:09:41 <ski> voidzero : yes
12:09:45 <funfunctor> oh true I mean the way from the action to the monad
12:09:54 <funfunctor> the outter IO action context
12:09:56 <lpaste> ryanar pasted “sudokuConfigToString” at http://lpaste.net/122122
12:10:08 <EvanR> i dont think that explanation is very good ;)
12:10:22 <mauke> ryanar: that doesn't tell me the type
12:10:26 <funfunctor> yea, nor I ;)
12:10:40 <voidzero> levi, waffle, meaning undecided?
12:10:52 <mauke> ryanar: also, head [x] is just x
12:10:54 <levi> voidzero: Yeah.
12:10:55 * ski sometimes uses the former, sometimes the latter
12:10:57 <sebastard> ski: does that mean I'll have to pass a counter all the way into the foo function?
12:11:02 <HeladoDeBrownie> i give up, who knows where those haskell lol cats were hosted?
12:11:11 <ryanar> mauke: because I don't have it listed, I am super new to Haskell, I was trying to take a tuple [(a,b)] and pull out elements of the tuple and make them into a string
12:11:12 <voidzero> Yeah, hehe, then you and me both :)
12:11:17 <ski> sebastard : not necessarily
12:11:25 <EvanR> funfunctor: return creates an IO action that does nothing except produce some value. you only have to use it at the end of a do block if whats there isnt an IO action
12:11:56 <mauke> ryanar: [(a,b)] is not a tuple, it's a one-element list
12:11:59 <ski> sebastard : btw, it's not clear to me what the `Int' state in `foo' and `bar' is for. i'm assuming that it's for something unrelated to the count thing you want to do in `barsUntil'
12:12:14 <ww> list o' tuple
12:12:15 <ryanar> mauke: wouldnt [(a,b)] be a list of tuples?
12:12:17 <levi> I think (f . g . h) x is a bit easier to read, but f . g . h $ x is easier to type if I didn't plan far enough ahead in my composition.
12:12:19 <mauke> ryanar: yes
12:12:20 <funfunctor> EvanR: ok, thats more what I was trying to say
12:12:23 <weasel__> Is there a name for a Comonad that doesn't have extract?
12:12:25 <ryanar> mauke: that is what I meant to say
12:12:26 <mauke> ryanar: well, a list of one tuple
12:12:35 <HeladoDeBrownie> found it (slightly nsfw due to partial view of nudity): http://spl.smugmug.com/Humor/Lambdacats/i-tSKXkj9
12:12:46 <weasel__> i.e. it might be nothing in no context 
12:12:48 <ryanar> mauke: I want to take a list of tuples created by the output of zip and parse through them to construct a string, namely a sudoku board
12:13:02 <sebastard> ski: yes it is, I realise that the example code is not actually using it, but I was trying to simplify it a bit to extract the essence of my question, in reality the state is some complex binary tree with no direct relation to the output length
12:13:13 <funfunctor> I guess I make 'return' a little special in my "parsing mind brain"
12:13:13 <EvanR> funfunctor: simply because every step in a do block has to be an `m a' or `m b' not an a or b. it has not much to do with other contexts
12:13:28 <ski> sebastard : anyway, you could either make `foo'/`bar' return the number of characters it outputs (then it can't be inifinite), or you could simply compute each length in `barsUntil' (still can't be infinite), or you could count down/up as you emit each character in `barsUntil' (allows a `foo'/`bar' to generate an infinite string)
12:13:37 <ryanar> mauke: when I read zip it showed that it took two lists and returned a list of tuples of them mixed together in the form [(a,b)]
12:13:51 <mauke> ryanar: are you confusing values and types?
12:13:58 <funfunctor> EvanR: right, yes, because return is the lifter to m a
12:14:06 <ski> sebastard : i'm not sure whether allowing `foo'/`bar' to generate an infinite string is very useful here, but i thought i'd mention that aspect. possibly it doesn't matter to you here
12:14:14 <ryanar> mauke: I might be, not sure!
12:14:23 <EvanR> funfunctor: and if you used return at the end when you didnt need to, you might end up with something weird
12:14:34 <EvanR> like IO (IO X)
12:14:43 <EvanR> which is cool but usually not what you want
12:14:49 <ski> weasel__ : what would the dual be ?
12:15:01 <funfunctor> yea because lazyness you may never see that run
12:15:05 <ryanar> mauke: if I called zip [1..5] [5..9] id expect to get [(1,5),(2,6),(3,7),(4,8),(5,9)]
12:15:21 <ski> sebastard : "the state is ... with no direct relation to the output length", good
12:15:21 <ttt_fff> https://gist.github.com/anonymous/281df32bbf7e17f09f4b <-- how do I make this compile? (since Map's constructors supposedly aren't exposed)
12:15:24 <ttt_fff> https://gist.github.com/anonymous/281df32bbf7e17f09f4b <-- how do I make this compile? (since Map's constructors supposedly aren't exposed)
12:15:25 <ryanar> mauke: which I thought would be shown as [(a,b)]
12:15:33 <mauke> ryanar: what do you mean, "shown as"?
12:15:36 <ww> > zip [1..5] [5..9]
12:15:37 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9)]
12:15:43 <EvanR> funfunctor: not because lazyness, because IO (IO X) is an IO command that when executed gives you some IO command
12:16:08 <hjulle> What arrows are there which are not of the type Arrow a => a b c === Applicative f => b -> f c ? 
12:16:24 <ryanar> mauke: like if I were to pass those values into another function, namely sudokuConfigToString, in the function definition I would list it as sudokuConfigToString :: [(a,b)]
12:16:25 <ww> @ty zip [1..5] [5..9]
12:16:26 <lambdabot> (Num b, Num a, Enum b, Enum a) => [(a, b)]
12:16:52 <sebastard> ski: actually, that would be really useful (to be able to output infinite strings), so I'd count in barsUntil... should barsUntil call bars or bar?
12:16:54 <funfunctor> oh ok
12:16:55 <ryanar> cool so the bot agrees with me
12:16:57 <mauke> ryanar: you mean in the type? depends
12:17:02 <ski> hjulle : stream processors ? "hyper functions" ?
12:17:14 <mauke> ryanar: I'd say it's [(Integer, Integer)]
12:17:28 <ryanar> mauke: oh I thought a stood for anything
12:17:36 <ryanar> mauke: ill try that
12:18:12 <ttt_fff> GHC.Generics issue: https://gist.github.com/anonymous/adbbb1bdec488bb9ad23 <-- minimal failure case; please help me get this to compile
12:18:38 <ww> it's not yet specific enough to be Integer 
12:18:52 <ww> could be doubles or fractionals or whatever
12:19:03 <ww> @ty [1..5]
12:19:04 <lambdabot> (Num t, Enum t) => [t]
12:19:10 * ww shrugs
12:19:34 <ski> sebastard : since you'll probably want the final state even if you internally have infinite output (which gets cut off), you should call `bars'. `mapM' in `State s' on an infinite list yield an undefined "final" state (the result list is defined or undefined corresponding to using the lazy or the strict version of `State')
12:19:45 <mauke> ww: who in their right mind would use the Enum instance of fractionals?
12:21:25 <ww> someone trying to prove xeno's paradox?
12:21:26 <moghedrin> dolio: So, in that example, I how want to do something along the lines of `map isMetBy . prereqs`. How would I make the second parameter of the 'Action' typeclass unambiguous?
12:21:35 <ww> it's a bit silly...
12:21:40 <EvanR> enum instance for Float... NaN, -Infinity, "minBound", "minBound"+epsilon, ... ;)
12:21:50 <sebastard> ski: ok thanks :) I'll see if I can work out something, else I'll be back ;)
12:21:50 <mauke> I wish
12:22:15 <ollehar1> can I make refined types in haskell, e.g. a type where the first element in a list is always of type t and others of type s?
12:23:16 <EvanR> enum instance for Rational... -GMPmax/1 , ........ uh
12:24:16 <EvanR> > [1%1 ..]
12:24:17 <lambdabot>  [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1,11 % 1,12 % 1,...
12:24:28 <HeladoDeBrownie> ollehar1, is that different from (a, [b])?
12:24:33 <EvanR> wtf
12:24:50 <joneshf-laptop> :t (%)
12:24:51 <lambdabot> Integral a => a -> a -> Ratio a
12:24:56 <EvanR> why does that type even have Enum
12:25:01 <joneshf-laptop> :i Ratio
12:25:05 <ollehar1> HeladoDeBrownie: Hm, guess not.
12:25:05 <joneshf-laptop> erm
12:25:07 <levi> ollehar1: Not in today's Haskell, at least not with a straightforward list type.
12:25:08 <joneshf-laptop> guess not
12:25:09 <ww> same could be said for
12:25:12 <exio4> EvanR: what's wrong with it? 
12:25:18 <ww> > [1..] :: [Double]
12:25:19 <EvanR> its skipping a few
12:25:19 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
12:25:32 <geekosaur> because someone thought all numbers ought to have Enum and it ought to count up by 1
12:25:36 <EvanR> ww: yes but in principle you could enumerate all the Doubles
12:25:46 <ww> EvanR: but that's not what it does...
12:25:47 <ollehar1> levi: ok, thanks.
12:25:58 <HeladoDeBrownie> ollehar1, and if you wanted the possibility of that being empty, Maybe (a, [b]). might get syntacticall icky to work with, would be the main downside i'd guess.
12:26:00 <EvanR> > [0 :+ 1 ..]
12:26:02 <lambdabot>  No instance for (GHC.Show.Show a0)
12:26:02 <lambdabot>    arising from a use of ‘M86717370130441211328950.show_M86717370130441211328...
12:26:02 <lambdabot>  The type variable ‘a0’ is ambiguous
12:26:09 <EvanR> > [(0 :+ 1) ..]
12:26:10 <lambdabot>  No instance for (GHC.Show.Show a0)
12:26:10 <lambdabot>    arising from a use of ‘M283766093301198698528960.show_M2837660933011986985...
12:26:10 <lambdabot>  The type variable ‘a0’ is ambiguous
12:26:16 <mauke> EvanR: ಠ_ಠ
12:26:18 <lpaste> ryanar pasted “what am I doing wrong?” at http://lpaste.net/122140
12:26:32 * EvanR rage quits
12:26:41 <levi> ollehar1: There's a project called Liquid Haskell that's about adding refinement types to Haskell, although I don't know enough about it to say whether it's the same as what you're asking.
12:26:51 <ollehar1> levi: Yeah, know about it.
12:27:25 <HeladoDeBrownie> i don't know what refinement types are so i'm not sure if i'm being helpful
12:27:27 <EvanR> the enum instance for Rationals should literally enumerate all the rationals ;)
12:27:37 <ollehar1> levi: but that's more for {l | length always < 10} and such?
12:27:38 <EvanR> who needs the usual ordering
12:27:57 <HeladoDeBrownie> EvanR, like the diagonal enumeration?
12:28:14 <EvanR> is that what its called
12:28:17 <HeladoDeBrownie> no idea
12:28:24 <HeladoDeBrownie> i was just trying to mention it descriptively
12:28:25 <hjulle> ski, Thanks.
12:28:56 <EvanR> the cool enumeration
12:28:57 <HeladoDeBrownie> the idea is you enumerate the pairs of integers, omitting those with common divisors
12:29:06 <levi> ollehar1: Well, I'm not sure you can really call 'a list where the first element is a different type than the others' as a reasonable refinement of 'a list'.
12:29:19 <siddhu> > take 10 [1%2,2%3..]
12:29:20 <lambdabot>  [1 % 2,2 % 3,5 % 6,1 % 1,7 % 6,4 % 3,3 % 2,5 % 3,11 % 6,2 % 1]
12:29:26 <ollehar1> levi: yeah.
12:29:32 <siddhu> can someone explain the enumeration?
12:29:42 <geekosaur> ryanar, so what is the problem exactly? if you had an error, you should add the full error message to your paste
12:29:54 <Hijiri> WeirdList a b = Nil | WL a [b] ?
12:30:00 <EvanR> siddhu: its counting by 2/3s
12:30:01 <ski> levi : i don't think it would be a refinement type of t
12:30:05 <geekosaur> otherwise describe (ideally with sample expected / actual output) what you expected and what you got
12:30:06 <ski> er, of `[a]'
12:30:58 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/122096
12:31:22 <funfunctor> EvanR: the other case I was a little confused to convert to alloca was the above?
12:31:42 <ski> ollehar1 : "refinement type" is here a technical term that more or less is : you start with some (possible recursive) variant type (or algebraic data type). you consider the set of its elements, and you take some subset, and make a type (a subtype) for this
12:31:52 <EvanR> funfunctor: do two allocas in a row
12:32:16 <ski> ollehar1 : this is to be contrasted with the usual approach to mix subtyping and variant types, in which you start with a type, and then *add* (not remove) alternatives, to get a new (super)type
12:32:35 <funfunctor> beguiling
12:33:03 <ski> hjulle : .. also Swierstra's and Duponcheel's original example of parsing arrows, that had a static and a dynamic component
12:33:16 <ollehar1> ski: so the internal structure of a list would not be considered a sub type of list?
12:33:37 <funfunctor> maybe I will just leave these until I support the new ghc that allows me to coerce instead of manually marshaling these data types values across..
12:34:05 <EvanR> funfunctor: eh?
12:34:16 <lpaste> quchen annotated “what am I doing wrong?” with “what am I doing wrong? (annotation)” at http://lpaste.net/122140#a122153
12:34:19 <hjulle> ski, Aren't those stream processors? That was the impression I got from http://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Stream_processing
12:35:21 <quchen> ryanar: I've added some annotations to your paste.
12:35:37 <ryanar> quchen: thank you for the notes, my book instructs me to implement it as a 1D list
12:35:38 <quchen> The diff might show more clearly what's changed: http://lpaste.net/diff/122140/122153
12:36:02 <EvanR> funfunctor: for one thing you dont need to alloc until half way through that command, and then you dont need the pointers for most of the rest of it. so you can do the alloca only near the middle
12:36:04 <ryanar> so when you do x:xs doesn't that take off the head of the list?
12:36:06 <EvanR> and get out
12:36:32 <siddhu> EvanR, I still don't understand.
12:36:46 <quchen> ryanar: No, it doesn't "do" anything. It gives you access to the head of the list via the name "x", and similarly for xs.
12:37:05 <EvanR> siddhu: the code you wrote counts by increments of 2/3
12:37:07 <funfunctor> EvanR: ok thanks
12:37:10 <funfunctor> I see it now
12:37:12 <samba1> What does this mean? When trying to cabal install with tests enabled and, I think, doctest causing the problem:
12:37:15 <samba1> conflict: ghc =>
12:37:16 <samba1> transformers==0.4.0
12:37:18 <samba1> transformers==0.3.0.0/installed-645..., other-package =>
12:37:19 <quchen> `let (x:xs) = foo in (x:xs)` is identical to `foo`, ryanar.
12:37:31 <samba1> what does it mean that ghc depends on transformers 0.3?
12:37:37 <karshan_> > :i Monad
12:37:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:37:44 <ryanar> quchen: thanks, total misconception I had
12:37:45 <karshan_> > i Monad
12:37:46 <lambdabot>  Not in scope: data constructor ‘Monad’
12:37:49 <quchen> karshan_: Lambdabot can't do :i
12:37:55 <glguy> samba1: GHC 7.8 comes with transformers-0.3.0.0. You should be using that version with it
12:38:04 <karshan_> quchen: damn, thanks for pointing that out!
12:38:05 <glguy> (yes, due to GHC depending on it)
12:38:14 <samba1> glguy: but I've used 0.4 in other places
12:38:28 <glguy> samba1: You'll need to reinstall those things against 0.3
12:38:30 <quchen> karshan_: :t works, but it's a hack that probably aliases ?type
12:38:32 <geekosaur> samba1, when that dependency comes up, it is not refering to ghc the compiler but ghc the library
12:38:32 <samba1> glguy: this only happens with tests enable, otherwise it's fine
12:38:48 <glguy> samba1: This is why the transformers-compat package exists
12:38:56 <geekosaur> for many things you may well not care, but if you have something depending on ghc-api then you must use the matching transformers version
12:39:03 <samba1> geekosaur: yes, but I still don't understand why adding a doctest dependency would do this
12:39:12 <quchen> ryanar: The name "pattern matching" really fits, there's nothing fancy going on when you do it
12:39:23 <geekosaur> probably because doctest requires haddock which uses ghc-api for parsing
12:39:27 <quchen> You just get access to different parts of a structure. You don't alter it in any way.
12:39:34 <samba1> doctest depends on the ghc package, I see
12:39:41 <glguy> samba1: doctest uses the ghc-api, ghc-api uses transformers-0.3.0.0
12:39:52 <siddhu> > take 5 [1%3, 2%3..]
12:39:54 <lambdabot>  [1 % 3,2 % 3,1 % 1,4 % 3,5 % 3]
12:40:04 <geekosaur> or perhaps just duplicates haddock...
12:40:09 <ww> you can even do (x:(y:(z:rest))) if you want though it's rarely a good idea
12:40:15 <samba1> so I just can't have doctest and anything requiring transformers 0.4?
12:40:23 <quchen> ww: You don't need the inner parentheses even.
12:40:39 <siddhu> ah. That makes sense now. Thanks EvanR !
12:41:02 <quchen> > let swapFirst2 (x:y:zs) = y:x:zs in swapFirst2 [1..10] -- ww
12:41:03 <lambdabot>  [2,1,3,4,5,6,7,8,9,10]
12:41:19 <ww> right
12:42:17 <samba1> how do I tell what the ghc library depends on?
12:42:57 <geekosaur> ghc-pkg describe ghc
12:43:03 <geekosaur> or: ghc-pkg field ghc depends
12:43:56 <ski> ollehar1 : what is "the internal structure of a list" here ?
12:44:00 <samba1> so, again, if something requires transformers 0.4, i just can't use doctest, even if I'm not going to doctest anything requiring the thing that needs transformers 0.4?
12:44:02 <ski> hjulle : no
12:44:21 <ollehar1> ski: first element has type a, second type b, etc. enforce this at type level.
12:44:51 <Hijiri> is that HList
12:44:57 <ski> hjulle : i was thinking of something like (synchronous) `newtype SSP a b = MkSSP (a -> (b,SSP a b))' and (asynchronous) `data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)'
12:45:27 <Hijiri> ollehar1: https://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HList.html
12:45:37 <bergmark> samba1: sometimes that can happen and then you get a warning like "compilation is highly likely to fail"
12:45:55 <ski> ollehar1 : that's a generalization of the outset homogenous list type `[a]' in Haskell. hence not a "refinement type" (in the technical sense) of it
12:46:38 <bergmark> samba1: but patching any package to support older transformers is easy, just depend on transformers-compat as well
12:47:08 <Javran> how is maintaining lambdabot? can I ask lambdabot to listen to another freenode channel?
12:47:31 <geekosaur> Javran: talk to int-e
12:47:59 <Javran> geekosaur: I see, thanks!
12:48:03 <ollehar1> ski: ok
12:48:27 <ollehar1> Hijiri: well, now I wish I knew haskell :)
12:50:23 <JaAnTr> ski: Hi ski, I'm back. So far I have this for the evalA   -   evalA (Incr v) s  =            is that right so far?
12:51:17 <quchen> Javran: Lambdabot is free software, you could just run your own instance if you wanted to.
12:52:57 <clrnd> you only need a vm with over >4gb ram
12:53:07 <Javran> quchen: yeah, I just checkout the source code. wondering if I can reuse existing ones that'll be convenient
12:53:40 <Javran> btw I compiled ghc 7.10, to get it to work with hsenv, how should I prepare the tarball file?
12:54:34 <Javran> is there a makefile target?
12:58:47 <int-e> clrnd: That's not quite accurate. 512MB + a bit of swap or 1GB is doable, IME. Compiling lambdabot on such a VM is a bit tricky though.
12:59:18 <clrnd> int-e, je joking, I actually did it last week, 1GB ram + 1GB swap
13:01:17 <mmachenry> When I do cabal install —only-dependencies I don't get all the things my test-suites depend on. so I need to install these things by hand before running cabal test.
13:01:23 <rola> on some idris talks, they do this neat pattern matching completion thing (e.g. http://youtu.be/4i7KrG1Afbk?t=5m50s), is there a plugin to do this in haskell when using vim?
13:01:25 <mmachenry> Is there a way to get cabal to automate this?
13:01:32 <bergmark> mmachenry: cabal install --only-dependencies --enable-tests
13:01:46 <mmachenry> Oh brilliant. 
13:04:57 <rola> by pattern matching completion thing, i mean you write out a type signature like foo :: Bool -> Bool, and you hit some keycombo, and it gives you something like "foo True = undefined" "foo False = undefined"
13:06:17 <dolio> moghedrin: The functional dependency makes it unambiguous.
13:09:12 <hexagoxel> rola: what happens when you do `foo :: Bool -> Bool -> Bool -> Bool -> Bool` ? :D
13:09:40 <mada> plugin solves SAT obviously
13:09:41 <cfoch_> How do you use the packages installed with sandbox in another directory =
13:09:41 <cfoch_> ?
13:09:48 <benzrf> hexagoxel: it pops up saying "combinatorial explosion so nope"
13:10:32 <benzrf> hexagoxel: n e way that's only 16 pfft
13:10:57 <siddhu> cfoch_: maybe you're looking for cabal sandbox add-source lib?
13:13:19 <cfoch_> siddhu: I have a sandbox folder (sandboxed/) and other folder (folder/) where I have my .hs files that imports modules of the packages in "sandboxed/". How can I compile those .hs files using the sandbox of "sandboxed/" ?
13:14:02 <bergmark> cfoch_: cabal sandbox --help
13:15:31 <nkar> do people use ' in identifiers in high-assurance software or finance?
13:16:23 <c_wraith> nkar: do people use z in identifiers in high-assurance software or finance?
13:16:27 <siddhu> cfoch_: I know you can create a new sandbox in folder/ which depends on the sandbox at sandboxed/ . Not sure if there's a better way.
13:16:43 <athan> Is there a fold that just uses the head of the list as the accumulator?
13:17:09 <c_wraith> athan: do you mean like foldl1?
13:17:11 <siddhu> :t foldl1
13:17:12 <lambdabot> (a -> a -> a) -> [a] -> a
13:17:21 <athan> c_wraith: I think so! Awesome, thank you
13:17:30 <athan> I thought that only worked with numbers for some reason ><
13:18:53 <rola> hexagoxel, there's a way they do it step by step to break it down. for example in that video they have "or : Bit -> Bit -> Bit" *keycombo* "or x x1 = ?or_rhs" *select that and keycombo* "or O x1 = ?or_rhs_1" "or I x1 = ?or_rhs_2"
13:20:09 <rola> i think, it's sort of like doing induction on the types, i dunno
13:20:41 <nkar> c_wraith: well, I understand it's a silly-sounding question.  the general question that I'm asking is whether there are policies regarding names of identifiers in such projects.  ' is a common haskell idiom, but it's easy to miss.  in some cases it may cost you a lot of money.
13:20:47 <ski> ollehar1 : perhaps learn it ? :)
13:21:08 <ollehar1> ski: no time :( also, coq is priority. already now ocaml.
13:21:10 <ski> JaAnTr : looks ok
13:21:13 <ollehar1> *know
13:21:15 <ski> ollehar1 : ok
13:21:40 <ski> (Coq is a worthy task)
13:22:04 <ski> JaAnTr : you also need to adapt the existing defining equations of `evalA', as i mentioned before
13:22:53 <cfoch_> do I need to do
13:23:01 <ski> yes (?)
13:23:02 <cfoch_> export PATH=.cabal-sandbox/bin:$PATH ?
13:23:23 <cfoch_> siddhu
13:23:28 <cfoch_> -----------^
13:26:25 <geekosaur> export $(pwd)/.cabal-sandbox/bin:$PATH
13:26:52 <hexagoxel> cfoch_: if you want to use executables installed in a sandbox, something like this is one option
13:27:07 <siddhu> cfoch_: I don't think so, unless your sandbox folder contains executables.
13:27:17 <geekosaur> cabal exec is another option, I think?
13:28:05 <siddhu> I meant, just doing cabal sandbox init in folder/ then setting up the entire project using cabal.
13:28:37 <siddhu> or, what geekosaur said. I'm not exactly sure how that would work though.
13:30:33 <JaAnTr> ski: Why do the existing evalA definitions need modifying?
13:36:36 <levi> Doing 'cabal exec bash' in your sandboxed cabal directory is a handy way to be able to do various haskell-related commands with the sandbox setup active.
13:39:01 <avocado> levi: nifty!
13:47:06 <funfunctor> EvanR: so I believe I fixed all my malloc to alloca usages now
13:47:08 <funfunctor> https://github.com/victoredwardocallaghan/hlibBladeRF/commit/8962b10fe3bfa814b95eee6430cff9ff22a0db38
13:47:35 <ski> JaAnTr : because they adhered to the old type signature, which has changed
13:48:29 <kaiyin> http://www.cs.nott.ac.uk/~gmh/fold.pdf          On page 360 "More generally, by replacing the use of addition in this example by an arbitrary infix operator ⊕ that is associative, a simple application of fusion shows that..."
13:48:56 <kaiyin> Does it also require ⊕ to be commutative?
13:49:09 <JaAnTr> ski: Oh yeah makes sense. So this is what is was - evalA (a :+: b) s = evalA a s + evalA b s so I guess what's after the equals sign needs to change to match (state, integer)?
13:50:37 <shachaf> kaiyin: No.
13:50:49 <kaiyin> shachaf: why not?
13:51:02 <shachaf> > (* a) . foldr (*) b $ [x,y,z]
13:51:03 <lambdabot>  x * (y * (z * b)) * a
13:51:05 <shachaf> > foldr (*) (b * a) $ [x,y,z]
13:51:06 <lambdabot>  x * (y * (z * (b * a)))
13:52:11 <shachaf> Why would it require commutativity?
13:52:55 <johnw> are there any Haskellers here with experience at object-level linking, who would be interested in discussing future directions for GHC?
13:53:45 <kaiyin> Indeed. 
13:54:03 <kaiyin> I overlooked the word `infix`
13:54:34 <erynn> Can the '..' operator skip numbers? Example: [1..6] produces [1,2,3,4,5,6] but what if I only want [1,3,6] ?
13:54:57 <erynn> Oh, wait. I can just use a filter can't I.
13:55:09 <erynn> Feed the output from [1..6] into a filter?
13:55:27 <shachaf> Which numbers do you want to skip?
13:59:42 <NemesisD> is there a performance penalty to using a GADT with a constructor that has a typeclass constraint?
14:00:19 <shachaf> What sort of penalty? It'll store the dictionary with the value, if that's what you mean.
14:03:55 <NemesisD> shachaf: whereas typically the dictionary is only around at compile time right?
14:04:21 <shachaf> The dictionary is a runtime thing.
14:05:13 <NemesisD> oh, i thought at compile time in if it could know which dictionary member to use it would just inline it at the call site
14:05:42 <shachaf> Yes, GHC can do that.
14:07:34 <geekosaur> ...sometimes
14:08:49 <shachaf> Yes, it's a big "if".
14:09:07 <shachaf> If your function is polymorphic, there isn't much that GHC can do in general.
14:10:46 <NemesisD> oh ok, so in practice this isn't a big concern?
14:11:31 <shachaf> What you're concerned about is up to you.
14:11:41 <shachaf> The topic is too broad for me to say whether I'm concerned about it.
14:17:44 <gyaretto> If I have `data Person = Person { name :: String, age :: Int }`, how do I declare Person as an instance of the Eq typeclass such that two instances of Person are equal if their ages are equal?
14:18:53 <ski> @tell JaAnTr "So this is what is was - evalA (a :+: b) s = evalA a s + evalA b s so I guess what's after the equals sign needs to change to match (state, integer)?" -- yes. i suggest using `where' or `let' here
14:18:53 <lambdabot> Consider it noted.
14:18:54 <ianjneu> gyaretto: instance Eq Person where Person {name=n} == Person {name=n'} = n == n'
14:19:07 <ianjneu> er, flip that for ages.
14:19:39 <Rotaerk> that seems like a terrible implementation of Eq Person, in any case
14:19:43 <ski> gyaretto : btw, i believe that to be evil :)
14:19:56 <siddhu> I believe (==) p1 p2 = age p1 == age p2 would work?
14:19:56 <Rotaerk> ageist
14:19:59 * hackagebot hlibBladeRF 0.1.0.2 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.2 (eocallaghan)
14:20:40 <Heffalump> siddhu: yes, "(==) = (==) `on` age" is another way of writing that (using Data.Function.on)
14:21:16 <Heffalump> as ski says, it's a bad idea to have two things be equal when they're not really the same though, all sorts of things like Sets will behave oddly
14:21:18 <siddhu> :t on
14:21:19 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:21:29 <siddhu> wow, that's super nice
14:22:15 <gyaretto> Hm, well I'm currently comparing two instances of the same type based on one of its fields.
14:23:23 <Heffalump> gyaretto: I'd arrange to use a customised function where you actually need it
14:24:12 <gyaretto> Ohkay, thanks! :)
14:24:31 <Javran> or define a newtype and make another Eq instance
14:24:53 <Javran> no runtime penalty though
14:28:00 <kaiyin> Could you recommend some books on mathematics of functional programming? 
14:28:38 <kaiyin> In the spirit of a http://www.cs.nott.ac.uk/~gmh/fold.pdf but more comprehensive.
14:29:59 * hackagebot vcache 0.2.3 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.2.3 (dmbarbour)
14:30:01 * hackagebot contravariant 1.2.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.2.1 (EdwardKmett)
14:31:30 <levi> kaiyin: There's Bird & DeMoor's 'The Algebra of Programming'
14:32:03 <levi> It's a bit expensive, though.
14:34:41 <int-index> I need some really heavy type trickery... Suppose I have a type-level list of values, such as '[Int, (), Char] and an additional type, say Bool. I then turn it into a function type, using a closed type family, so it becomes (Int -> () -> Char -> Bool). If I modify the type family slightly, it can ignore the unit types, so in this particular case it gives me (Int -> Char -> Bool).
14:35:19 <int-index> Now, the problem is how to turn the actual function of type (Int -> Char -> Bool) into a function of (Int -> () -> Char -> Bool) using the type-level list.
14:35:29 <ski> siddhu :  equating f = (==) `on` f
14:35:31 <ski> @type comparing
14:35:33 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:36:06 <int-index> I need that so the user could supply simpler functions when using my library, instead of explicitly ignoring all units.
14:36:27 <int-index> Any ideas?
14:38:11 <funfunctor> Is there a good monad for using the sound card about without heaps of C/C++ library bindings to wizzbang stuff that has terrifying C/C++ warnings while compiling about?
14:38:43 <funfunctor> i.e. the more pure haskell the better
14:41:18 <c_wraith> funfunctor: why would it be a monad?
14:41:55 <funfunctor> c_wraith: its IO isn't it?
14:42:17 <c_wraith> funfunctor: oh, so the answer is IO?
14:42:18 <mniip> IO is IO
14:42:22 <mniip> monads are monads
14:42:41 <funfunctor> ?
14:42:58 <mniip> why do people always relate impure/side-effected/IO code to monads
14:43:03 <kaiyin> levi: thanks
14:43:25 <int-index> funfunctor: IO provides a monadic interface, but that's it. IO can be used without monads at all, monads can be used in absence of IO as well.
14:43:38 <funfunctor> this does not answer my question..
14:43:52 <funfunctor> int-index: i know that, for instance Maybe isn't IO
14:44:00 <c_wraith> funfunctor: I'm pretty sure the answer to your question is "IO", but I'm being a bit of a jerk.
14:44:02 <funfunctor> IO is IO
14:44:13 <mniip> funfunctor, Maybe is a monad though
14:44:23 <funfunctor> c_wraith: yes, IO but wrapped in what..
14:44:23 <c_wraith> funfunctor: because you asked if there was a monad for it.  Well there is.  IO!
14:44:27 <mniip> yet you can't access the sound card with a Maybe
14:44:34 <c_wraith> funfunctor: why would it be wrapped in something?
14:44:34 <funfunctor> IO just lets me talk to /dev/dsp or some shit
14:44:46 <int-index> funfunctor: for sound programming try http://hackage.haskell.org/package/synthesizer-core
14:44:57 <funfunctor> mniip: I just said that
14:44:58 <c_wraith> funfunctor: I'm just saying - it's way more useful to ask about a library for something than to assume a special monadic interface exists
14:45:32 <funfunctor> c_wraith: because I am looking for a monadic interface
14:45:38 <funfunctor> in particular
14:46:07 <c_wraith> funfunctor: that seems oddly presumptious.
14:46:15 <mniip> ah, an IO monad transformer?
14:46:21 <int-index> funfunctor: why? Monads are not the best abstraction for signal processing (which sound programming actually is)
14:46:25 <mniip> like, say, the GHC api thingy
14:46:43 <kaiyin> levi: what would be the prerequistes of this book?
14:47:03 <funfunctor> I don't want signal processing
14:47:22 <funfunctor> I want to access the sound card but not just open /dev/dsp
14:47:32 <funfunctor> which sucks as a interface
14:47:52 <funfunctor> I'm interested in IO
14:47:52 <mniip> what kind of interface do you want
14:47:58 <koala_man> funfunctor: is the point to generate samples or just to play wav sound effects?
14:48:30 <int-index> funfunctor: http://hackage.haskell.org/package/soxlib would this suffice?
14:48:37 <funfunctor> koala_man: I have a binary data stream, I want to dispatch it to the sound card, thats IO, a.k.a IO monad
14:49:59 <c_wraith> funfunctor: I have a very specific objection. You asked for a "monad for using the sound card", but the answer to that is IO.  You want a *library* for using the sound card.
14:50:38 <funfunctor> c_wraith: yes a monadic library, for transformers
14:50:55 <c_wraith> funfunctor: why would it be a transformer? That doesn't make much sense at all.  It has to be IO.
14:51:23 <int-index> IO usually sits on the bottom of the monadic stack and feels just fine.
14:51:24 <funfunctor> ?? IO gets lifted into something else
14:51:25 <lambdabot>  IO gets lifted into something else
14:51:37 <c_wraith> funfunctor: transformers are much more useful when they're agnostic about the underlying layer
14:51:56 <int-index> funfunctor: You need to abstract over your monadic stacks with mtl, then you'll have no such problems.
14:52:07 <int-index> look for liftIO
14:52:25 <funfunctor> i'm not asking for liftIO, I know what liftIO is..
14:52:55 <mniip> then what are you asking for
14:53:08 <funfunctor> just, never mind..
14:53:12 <osa1_> what is the "timeout function" mentioned in this text: https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/exceptions-best-practices.md ?
14:53:14 <mniip> 'monadic library' is not a description
14:53:17 * funfunctor figures it out for himself
14:53:35 <int-index> funfunctor: ok, I'm sorry for misinterpreting you multiple times. I hope the libraries I linked may be of some help to you.
14:53:36 <c_wraith> osa1_: System.Timeout
14:53:40 <osa1_> thanks
14:53:44 <osa1_> and package?
14:53:52 <quchen> osa1_: http://hackage.haskell.org/package/base-4.7.0.2/docs/System-Timeout.html#v:timeout
14:53:59 <osa1_> oh it's base :o
14:54:23 <funfunctor> int-index: I was able to find synthesizer-core but it seems overly complex to me for my needs, not sure just groking it at the moment
14:54:29 <osa1_> wow, I've been using my own implementation of same thing
14:54:53 <funfunctor> I may just wrap up /dev/dsp or something
14:56:24 <exio4> I need another soul, I already gave mine to satan, and I still can't compile things on windows
14:56:38 <exio4> oh
14:56:46 <exio4> thought this was #-blah, sorry heh
14:57:59 <karshan> is it possible to have ghc warn you if you write a function that doesn't account for all patterns ?
14:58:40 <TallerGhostWalt> karshan: like all possible type patterns?
14:58:57 <karshan> yea, so warn me if I write a function like (f (Just x) = x)
14:59:01 <glguy> -fwarn-incomplete-patterns
14:59:07 <karshan> glguy: thanks
14:59:45 <quchen> karshan: -W is almost always a good choice to have enabled. I usually use -Wall with two or 3 warnings disabled for even more safety.
15:00:08 <ski> mniip : "why do people always relate impure/side-effected/IO code to monads" -- could be related to Filinski's monadic reflection of any (computable) monad as a side-effect in an imperative language, provided it has composable continuations ?
15:00:26 <karshan> alright now onto the real question :). Can I somehow write a function f :: [[a]] -> [(a,a)]; f = map (\[a,b] -> (a,b)) . filter ((== 2) . length))
15:00:44 <karshan> and not have it complain that I don't match all possibilities of patterns in the lambda
15:01:04 <ski> karshan : `f ass = [(a0,a1)| [a0,a1] <- ass]'
15:01:10 <karshan> quchen: hmm -Wall didn't seem to warn me about (\[a,b] -> (a,b))
15:02:16 <karshan> ski: nice, that's pretty cool
15:02:23 <bam365> karshan: what do you do when your list is an odd length?
15:02:39 <bam365> urg, nevermind that question
15:02:42 <mmachenry> bam365: I go see a doctor. 
15:02:49 <mniip> bam365, from what I gather they ignore all non-2 lists
15:03:14 <glguy> karshan: Those are different, it only warns in things like case statements where it's possible to put additional patterns
15:03:27 <karshan> ski: did you choose ass over xss for a particular reason ? ;)
15:03:29 <glguy> as far as I know the flag -fno-warn-incomplete-uni-patterns was supposed to cover uni-patterns like this, but doesn't seem to
15:03:59 <ski> karshan : only because you used `a' as your type variable ;p
15:04:00 <glguy> karshan: since you can only put one pattern in those positions it's presumed that you meant to have one pattern when you do it
15:04:04 <karshan> glguy: yea, I guess what I'm getting at is: Does ghc have a totality checker ?
15:04:06 <glguy> rather than that you forgot the rest
15:04:26 <mniip> ski, I wonder what which side-effect would a Void monad represent
15:04:36 <karshan> glguy: yea that makes sense
15:05:07 <ski> glguy : it's nice that in the MLs, you've always been able to have multiple branches in a function abstraction ("lambda")
15:05:10 <mniip> s/what//
15:05:32 <ski> mniip : how is your `Void' defined ?
15:06:25 <mniip> newtype Void = Void Void
15:06:34 <ski> that's not of the correct kind
15:07:09 <mniip> oh right
15:07:16 <mniip> I meant Proxy
15:07:27 <exio4> Proxy is just Const
15:07:32 <exio4> the trivial monad 
15:07:55 <mniip> no?
15:08:04 <mniip> Proxy is nothing like Const
15:08:14 <c74d> Can one make GHC list all available modules? If so, how?
15:08:23 <ski>   `data Proxy _ = Proxy' ?
15:08:30 <mniip> yes
15:08:33 <mniip> that's the definition
15:08:45 <hpc> for comparison, data Const a b = Const a
15:08:54 <mniip> _ >>= _ = Proxy
15:08:56 <hpc> which isn't a Monad
15:09:09 <mniip> (Const a) is a Monad
15:09:16 <hpc> not forall a
15:09:24 <mniip> obviously
15:09:36 <exio4> forall m. Monoid m => Const m 
15:09:46 <glguy> It's at least an Applicative
15:09:46 <mniip> that's a Monoid
15:09:50 <glguy> if not a Monad
15:10:11 <hpc> Applicative has the same issue - can't write a totally generic pure
15:10:23 <hpc> but it is Functor, fmap _  = id
15:10:28 <ski> mniip : so i suppose it represents the side-effect of stopping and refusing to compute anything ?
15:10:45 <glguy> 03instance Monoid m 07=> Applicative (Const m)
15:10:47 <glguy> but it's not a Monad
15:10:59 <mniip> o
15:11:00 <mniip> right
15:11:05 <mniip> Const is not a Monad
15:11:07 <hpc> when did #haskell get colors added back to the mode?
15:11:16 <xplat> i kind of want to bash together a media server thing.  anybody interested in working with me?
15:11:21 <ski> hpc : yesterday or yesteryesterday, iirc
15:11:26 <xplat> mniip: Const () is a Monad
15:11:34 <hpc> are there plans for syntax highlighting in lambdabot?
15:11:45 <Welkin> like xmbc?
15:11:52 <xplat> mniip: well, it's a monad anyway, not sure anybody wrote the instance
15:12:18 <glguy> hpc: I set the channel -c so I could syntax highlight code ^_^
15:12:19 <mniip> wouldn't Const () be equivalent to Proxy?
15:12:22 <ski> hpc : yes, glguy .. ^
15:12:24 <mniip> ah wait no
15:12:27 <Welkin> hpc: that would be a mess since eveyrone has a different setup for their irc colors
15:12:32 <xplat> Welkin: more like subsonic or mediatomb kind of thing
15:12:37 <mniip> Proxy ~ Const Void
15:12:45 <hpc> Welkin: i would expect that to be very rare, actually
15:12:57 <mniip> () has more values than Void
15:12:59 <hpc> the only thing i can think is the occasional dink with black-on-white
15:13:32 * ski nods proudly
15:13:34 <hpc> but configuring mirc colors would be a lot like configuring terminal colors - everything expects them a certain way so there's little to do
15:13:39 <xplat> hpc: yellow on white is not that readable
15:14:09 <hpc> does anyone here use a white background?
15:14:16 <mniip> hpc, the first 8 colors are pretty standartised
15:14:19 <mniip> and yes, white bg here
15:14:45 <xplat> Welkin: (actually i want something that serves through both upnp and subsonic protocols from the same database)
15:14:52 <glguy> We'll have to pick syntax highlighting that works well on both white and black backgrounds. If someone's using a colorscheme where the colors are all unreadable they'd just need to tell their client not to render colors
15:14:57 <hpc> the upper 8 are pretty standard too - they're accents on the base color
15:15:19 <mniip> hpc, 0 is white and 8 is yellow
15:15:20 <mniip> huh?
15:15:42 <hpc> ... hang on
15:15:42 <mniip> we're talking about first 8 mirc colors right?
15:16:25 <hpc> wait nvm, you're right
15:16:35 <hpc> just tested, zero consistency
15:16:51 <hpc> i might be mixing mirc colors and terminal colors
15:17:28 <ski> <http://www.mirc.com/colors.html>,<https://en.wikipedia.org/wiki/Select_Graphic_Rendition_(ANSI)#Colors>
15:17:55 <hpc> that was it
15:18:32 <xplat> you expected mirc to be consistent with anything older than mirc?
15:18:50 <mniip> let's examine another question
15:18:54 <mniip> why would you highlight =>
15:19:02 <hpc> i actually expected the color standard to evolve beyond mirc
15:19:12 <hpc> but who am i kidding, this is irc
15:19:29 <hpc> where you can have {} in your nick but not :
15:19:43 <mniip> icechat does evolve beyond mirc
15:19:52 <mniip> by defining hundreds of proprietary colors
15:20:05 <xplat> irc will evolve again when there's another client as popular as mirc
15:20:13 <mniip> \3\&16 to \3\&99 and beyond
15:20:19 <hpc> oh god, that means mibbit
15:21:02 <glguy> mniip: Because I copied what Vim was doing as the starting point
15:21:38 <mniip> huh
15:21:41 * hpc has been off-and-on considering contributing his duckduckgo code to lambdabot
15:21:45 <mniip> my vim does something else
15:21:56 <glguy> and the default vim seems to color operators orange
15:21:58 <mniip> note that I did no configuration of colors
15:22:09 <mniip> they appear brown here
15:22:30 <glguy> in vim or irc?
15:22:36 <mniip> ah
15:22:58 <ajcoppa>  
15:23:40 <mniip> brown in gtk frontend
15:23:44 <mniip> yellow in curses frontend
15:24:07 <glguy> The gui vims have more colors to play with, I was copying from my terminal
15:24:31 <glguy> and it seemed like a color that would show up on black or white
15:24:33 <ski> glguy : 256-color terminal ?
15:24:43 <mniip> I'm pretty used to the brown-greet-purple-violet-blue colorscheme
15:24:48 <nanomad> Uhm, I need help with a function.. Is there something to produce ?? :: (a -> b) -> IO [a] -> IO [b]
15:24:57 <glguy> map.map
15:25:02 <glguy> errm fmap.fmap ^_^
15:25:03 <mniip> nanomad, fmap.fmap
15:25:07 <nanomad> doh!
15:25:07 <hpc> :t fmap . fmap
15:25:08 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:25:14 <mniip> or map.fmap
15:25:22 <mniip> :t map.fmap
15:25:23 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
15:25:23 <hpc> put the spaces in there, this isn't javascript ;)
15:25:29 <mniip> wait no, fmap.map
15:25:52 <glguy> I usually use the solarized color scheme, but it uses a lot more colors, so I started with the simpler default
15:26:53 <glguy> This is why I'm using if you want to try your hand at making things look prettier: https://github.com/glguy/irc-core/blob/master/driver/HaskellHighlighter.hs
15:28:01 <nanomad> Ah! spaces! That's it hpc 
15:29:00 <nanomad> :t splitPath
15:29:01 <lambdabot>     Not in scope: ‘splitPath’
15:29:01 <lambdabot>     Perhaps you meant one of these:
15:29:01 <lambdabot>       ‘BS.splitWith’ (imported from Data.ByteString),
15:29:19 <mniip> glguy, eww
15:29:21 <mniip> solarized
15:29:26 <mniip> the undercontrasted stuff
15:29:46 <glguy> It's excellent, but it's OK if you don't like it
15:29:56 <ski> (then there's 24 bit colors in terminals .. <https://gist.github.com/XVilka/8346728>,e.g. <https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors>)
15:30:35 <mniip> http://i.imgur.com/7cK0TIH.png
15:34:33 <glguy> mniip: This is what I normally use: http://imgur.com/u1aLAFb
15:35:46 <mniip> well with that font size the contrast isn't much of an issue
15:43:56 <mniip> glguy, another weird thing to note that the most noticiable color - red, is used for punctuation
15:44:03 <mniip> sounds counter-intuitive
15:46:16 <geekosaur> Fortran IV holdover? :p
15:48:53 <Heffalump>  /part
15:54:28 <kaiyin> Why isn't list defined as something like Nil | Cons a List a  | Snoc List a a , so that elements can be added in both directions?
15:54:49 <mniip> kaiyin, Data.Sequence
15:54:57 <mniip> also list is defined that way for simplicity
15:55:50 <kaiyin> ok, thanks
15:56:02 <mniip> a Snoc won't pattern-match against a Cons
15:56:04 <ski> kaiyin : you'd like `Cons a0 (Snoc as a1) = Snoc (Cons a0 as) a1', but you can't have that with Haskell's anarchic data types (they're lawless)
15:56:04 <shachaf> kaiyin: Because that (if you add the parentheses to make it kind-check) would be a tree, not a list.
15:56:10 <mniip> making even head a non-trivial operation
15:56:29 * ski is basically saying the same thing as mniip
15:56:42 <ski> (and shachaf)
15:56:42 * mniip is basically ski
15:56:54 <ski> we're all in the same equivalence class !
15:56:56 <shachaf> That's funny, because I'm not saying the same thing as mniip.
15:57:03 <shachaf> Something is fishy about this "equivalence" relation.
15:57:11 <mniip> shachaf is merely picking at the incorrect syntax
15:57:30 <ski> shachaf : you can't express negative thoughts in universal algebra
15:57:47 <shachaf> I don't agree with "for simplicity".
15:58:01 <shachaf> The types are both simple, they're just different.
15:58:37 <mniip> ski, why do you like a0/a1/etc so much :(
15:58:48 <shachaf> Maybe "tree" is a bad name, or at least it requires additional interpretation.
16:00:03 * hackagebot satchmo 2.9.3 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.3 (JohannesWaldmann)
16:02:03 <ski> mniip : you don't like numbering ?
16:02:21 <mniip> I wouldn't be surprised if ski stated the distributive law as (a0 `a1` a2) `a3` a4 = (a0 `a3` a4) `a1` (a2 `a3` a4)
16:02:38 <ski> heh, no
16:02:48 <mniip> well maybe it's just me, but numbers in variable names are sorta like a blind spot for me
16:03:32 <ski> mniip : are ⌜a₀⌝,⌜a₁⌝ better ?
16:03:42 <mniip> oh dear
16:04:02 <glguy> 0ₐ 1ₐ ?
16:04:23 * ski grins
16:05:34 <ski> (.. in other news, i confirmed that i didn't make the word "anarchic" up myself)
16:07:48 <mniip> a⃝, a⃞, a⃤
16:07:54 <mniip> dang that looks unnice in a monospace font
16:08:26 <mniip> or maybe I'm just using these diacritics wrong
16:08:31 <ski> looks nice here, fwiw ..
16:09:51 <kaiyin> ski: what do you mean anarchic data types in haskell? 
16:10:45 <ski> kaiyin : anarchic data types are data types not abiding any laws (or at least not any auxilary laws, specific to them)
16:10:55 <mniip> @let add x⃗ y⃗ = zipWith (+) x⃗ y⃗
16:10:56 <lambdabot>  Parse failed: Illegal character ''\8407''
16:11:00 <mniip> rats
16:12:11 <ski> kaiyin : Miranda allowed you to express the equivalent of `data Integer = Zero | Pred Integer | Succ Integer where Pred (Succ n) = n; Succ (Pred n) = n' -- this would be an archic data type
16:12:42 <mniip> you can abstract from anarchy with Eq
16:13:04 <ski> kaiyin : in an anarchic data type, one data constructor (applied to any valid argument(s)) is never equal to (never matches with) a distinct data constructor (also similarly applied)
16:13:14 <ski> (this is known as "disjointness")
16:13:15 <mniip> you fail at pattern match level then though
16:14:28 <ski> mniip : yes, you can simulate quotient types by making an abstract data type, and by making sure that all the exported operations respect the equivalence relation `(==)' on the representations
16:15:11 <mniip> I'm currently thinking
16:15:16 <ski> mniip : tbh, i find that usage of arrows (or bold) for denoting "vectors" a bit silly
16:15:17 <mniip> of a pattern matching typeclass
16:15:58 <mniip> that you could define instances of
16:16:16 <mniip> and implement the 'archy'
16:16:28 <ski> (because if ⌜x⃗⌝ is a vector, then why do people write ⌜x₀⌝ instead of ⌜x⃗₀⌝ for the zeroeth scalar component of that vector. it seems inconsistent to me ..)
16:16:39 <mniip> huh
16:16:52 <mniip> the _0 is an operator obviously
16:16:53 <kaiyin> ski: Your Miranda example looks wonderful, why is this feature not available in Haskell then?
16:16:59 <mniip> has a lower precedence than ->
16:17:12 <ski> kaiyin : there are problems
16:17:21 <ski> mniip : yep
16:17:35 <kaiyin> what kind of problems?
16:17:46 <mniip> ski, the one thing I don't understand in math notation, is partial derivatives
16:18:48 <mniip> δf/δx, why write a fraction if it's not a fraction
16:19:15 <ski> kaiyin : being able to define functions which break the laws ("don't respect the laws") -- thereby breaking "extensionality" (the principle that says that if ⌜x = y⌝, then ⌜f x = f y⌝ .. you know, perhaps the most important ingredient of "equational reasoning", which we use all the time when we reason about and refactor Haskell code)
16:19:18 <mniip> δ²x /= δx² /= (δx)²
16:19:48 <Axman6> change in f divided by change in x, no?
16:20:18 <ski> mniip : first, ⌜δf/δx⌝ is nonsense, assuming ⌜f⌝ is a function here. perhaps you mean ⌜δ f(x) / δ x⌝
16:20:39 <mniip> some write just δf/δx
16:20:48 <kaiyin> ski: what does that have to do with archic data types?
16:20:57 <ski> mniip : doesn't make it any less nonsense, imho
16:21:02 <mniip> yep
16:22:08 <ski> mniip : the fraction thing is a historical thing with Leibniz notation (it originates from one definition of the derivative as a limit of a fraction/quotient. still, a limit of a fraction is not (necessarily) a fraction)
16:23:32 <ski> mniip : if you're interested, i could explain how total vs. partial derivatives are related to dependent vs. independent variables, which in a programming context is related to dynamic vs. static scope
16:23:36 <mniip> it should be a binary operator of its own
16:24:31 <kaiyin> ski: I am interested.
16:24:37 <benzrf> ski: lexical scope is called static scope now?
16:24:50 <ski> benzrf : it's a common alternative name for it
16:24:50 <mniip> ski, derivatives have little relation to programming
16:24:55 <benzrf> ski: hh
16:25:46 <mniip> (') :: (a -> b) -> a -> b
16:26:30 <mniip> partial derivatives are just a hack to apply that ' to only one of the input arguments, which in haskell you'd accomplish with argument reordering etc
16:26:48 <mniip> or if you're into it, flip and (.)
16:27:02 <mniip> possibly curry/uncurry
16:27:12 <ski> kaiyin : anyway, one could use two different approaches here .. either we could (eagerly) try to simplify values when we construct them (or maybe when we force them ?), simplify to some normal form, perhaps even a canonical form .. or, we could (lazily) defer applying any rewrite rules/laws until we match with a specific pattern (and then only rewrite as little as possible)
16:29:28 <ski> mniip : more like ⌜_′ : (U → V) ⟶ (U → (U ⊸ V))⌝, where ⌜U ⊸ V⌝ is the space of linear transformations (think matrices) from ⌜U⌝ to ⌜V⌝
16:29:55 <mniip> why do you keep using weird quotes
16:30:10 * ski is weird like that
16:30:27 <Axman6> so weird
16:30:29 <mniip> they render a bit weird over here
16:31:22 <mniip> they're froma different character set than the latin-1 part, and whilst text renders pretty sharp, ⌜ has a bit of a blur to it
16:31:23 <ski> kaiyin : the first approach could be what we want in some cases .. but sometimes it's inefficient in that we don't need to normalize to be able to compute some properties
16:31:38 <mniip> also huh
16:31:43 <mniip> not sure I understand that definition
16:32:01 <mniip> also why are there 3 different arrows
16:33:57 <ski> <Cale> Specifically, if V and W are Banach spaces (complete normed vector spaces, e.g. R^n), then a function f: V -> W is differentiable at some x in V if there exists a linear transformation A: V -> W such that the limit as h -> 0 of ||(f(x + h) - f(x)) - Ah|| / ||h|| = 0
16:34:01 <ski> <Cale> This linear transformation is called the (total or Fréchet) derivative of f at x.
16:34:35 <ski> (from yesterday in ##math)
16:35:03 <ski> mniip ^
16:35:04 * hackagebot jose 0.3.41.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.3.41.0 (frasertweedale)
16:36:00 <mniip> woah
16:36:04 <ski> iiuc, you can think of the main one as expressing how to compute one morphism from another
16:36:05 <mniip> what
16:36:41 <mniip> stop dissolving my simple understanding of everything with your complex bits D:
16:37:01 <ski> the two identical ones are morphism arrows in some kind of category of Banach spaces and differentiable maps
16:38:27 <ski> the one with a ring at the end expresses linear map/transformation (iow vector space morphism, basically a matrix for finite-dimensional stuff) .. presumably internalized as a Banach space itself
16:38:34 * ski doesn't know that much about Banach spaces
16:38:57 <ski> (ask Cale for details ;)
16:40:01 <Cale> If you don't know much about Banach spaces, R^n is an example for each n, with the usual vector norm
16:40:45 <ski> mniip : have you heard about <https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant> ?
16:41:13 <mniip> afraid not
16:41:24 <ski> mniip : <https://en.wikipedia.org/wiki/Del> ?
16:41:27 <mniip> neither I have heard about banach spaces
16:41:39 <mniip> Del the key?
16:41:42 <ski> (aka gradient)
16:41:45 <mniip> ah, nable
16:41:48 <mniip> nabla
16:41:51 <mniip> heard of that yes
16:41:57 <ski> (<https://en.wikipedia.org/wiki/Gradient>)
16:45:29 <ski> gradient is defined on scalar fields, iow stuff like ⌜f : ℝⁿ → ℝ⌝ (mapping every point in some "space" to some scalars, perhaps temperature), giving basically ⌜∇ f : ℝⁿ → ℝⁿ⌝. so at each point, we get a vector, describing in which direction the temperature increases most rapidly, and the magnitude of the vector describes how rapidly that is
16:47:25 <mniip> that I know
16:47:40 <mniip> well, heard of, at least
16:48:08 <ski> for each ⌜i⌝ with ⌜0 ≤ i < n⌝, we compute ⌜∇ f x⌝ as a vector of the partial derivatives of ⌜f x⌝ wrt each ⌜i⌝th component of the vector ⌜x⌝
16:48:13 <mniip> divergence does the inverse, and rotor, defined only on 3-dimensional spaces, gives the whirls in the field
16:49:39 <mniip> and we get an ℝ
16:49:51 <mniip> ?
16:50:05 <ski> however, when we generalize from ⌜f : ℝⁿ → ℝ⌝ to a function that maps from ⌜n⌝-dimensional space to ⌜m⌝-dimensional space (if ⌜m = n⌝, then this is called a "vector field", for each point in space we have specificed a vector), then we get ⌜m·n⌝ combinations of partial derivatives of each of the ⌜m⌝ components of ⌜f x⌝ wrt each of the ⌜n⌝ components of ⌜x⌝
16:51:43 <mniip> yes
16:52:25 <bwiklund> real quick thing i'm stuck on -- anyone have a clue why this is happening?
16:52:26 <bwiklund> http://pastebin.com/5ngwWYff
16:52:34 <ski> and we order these partial derivatives in a matrix, called the jacobian. it has ⌜n⌝ columns and ⌜m⌝ rows (if you multiply by a direction vector ⌜d⌝ with ⌜n⌝ components, on the right, then you get a vector with ⌜m⌝ components. this is the <https://en.wikipedia.org/wiki/Directional_derivative> in the direction of ⌜d⌝)
16:53:32 <bwiklund> the only difference is the "0 :" in the else expression
16:53:36 <bwiklund> which is threw there for debugging
16:53:43 <bwiklund> but it somehow makes it actually work...
16:54:06 <ski> (if you take the directional derivative in the direction of the coordinate axes (the directional vector would normally be normalized, iow having magnitude ⌜1⌝), then you simply get the partial derivative(s) (of the ⌜m⌝ components of ⌜f x⌝) wrt the component that corresponds to that coordinate axis vector)
16:54:08 <Cale> bwiklund: You should get some results before it hangs
16:54:13 <bwiklund> exactly
16:54:14 <Cale> bwiklund: But you have no base case
16:54:29 <bwiklund> oh, i'm calling it above the snippet
16:55:02 <bwiklund> "primeFactors (foo) 2
16:55:05 * hackagebot linear 1.16.4 - Linear Algebra  http://hackage.haskell.org/package/linear-1.16.4 (EdwardKmett)
16:55:24 <Cale> I mean, consider what happens when you do primeFactors 1 2
16:55:58 <bwiklund> mm
16:56:11 <bwiklund> good point, but the only thing i'm calling it with is a large number
16:56:19 <bwiklund> (and yeah it should be checking that kind of thing)
16:56:20 <Cale> It's recursive
16:56:28 <Cale> eventually you get to the case where n = 1
16:56:52 <bwiklund> right, but shouldn't i at least see some results before it hangs / etc
16:57:04 <Cale> you should (and do?)
16:57:07 <bwiklund> i don't
16:57:08 <ski> bwiklund : unrelatedly, consider using `divMod' (or `quotRem') instead of `div'&`mod' or `quot'/`rem' -- also, please don't mix operations from the latter two groups (unless you really intend to for some unfathomable reason)
16:57:10 <Ryanar> Hello all!
16:57:19 <bwiklund> only in the snippet that adds zeros as placeholders in the else expression
16:57:21 <ski> hello Ryanar
16:57:24 <Cale> If you don't see some, it's a problem with whatever terminal emulator you're using
16:57:47 <bwiklund> thanks for the tip ski
16:57:56 <ski> mniip : do you see why we get a matrix ?
16:58:00 <bwiklund> i'm running it with runhaskell inside tmux
16:58:16 <Cale> I'm just running it out of ghci
16:58:23 <Cale> in gnome-terminal
16:58:37 <Cale> ghci> primeFactors 2032112934 2
16:58:37 <Cale> [2,3,3,3,3,331,37897^CInterrupted.
16:58:37 <bwiklund> and version one works (or at least gives some results)?
16:58:42 <bwiklund> the heck
16:58:42 <bwiklund> ok
16:58:43 <Cale> yep
16:58:55 <bwiklund> so it's something else, thanks for the tips
16:59:02 <ski> mniip : *nod*. "rotor" is aka "curl"
16:59:14 <mniip> ski, sorry was away for abit
16:59:26 <ski> (is curl defined on seven-dimensional space ?)
16:59:36 <ski> mniip : np
16:59:56 <Cale> ski: yes
17:00:09 <mniip> but yes
17:00:18 <mniip> I see why is it a matrix
17:00:29 <mniip> last time I checked curl relies on vector multiplication
17:00:48 <mniip> which is specific to 3-dimensional space
17:01:45 <ianjneu> Does Haskell have ML functors, or do I have to use the module pattern to curry out an argument from several functions?
17:01:48 <bwiklund> hmm, @Cale it does work fine if i handle the case of n=1
17:01:59 <bwiklund> still wierd that it didn't print partial results....
17:02:06 <Cale> bwiklund: Yeah, I think your terminal is just line buffering the output for some reason
17:03:37 <bwiklund> yeah, for me it works in ghci but not in runhaskell or built with ghc
17:03:54 <bwiklund> regardless of what terminal i use
17:04:00 <Cale> Oh, okay, maybe try import System.IO
17:04:03 <ski> mniip : anyway, i don't seem to have a superscript ⌜m⌝ handy atm, so i'll use ⌜i⌝ here instead. the linear space ⌜ℝⁿ ⊸ ℝⁱ⌝ is the space of ⌜i⌝-by-⌜n⌝ matrices. so ⌜_′ : (ℝⁿ → ℝⁱ) ⟶ (ℝⁿ → (ℝⁿ ⊸ ℝⁱ))⌝ expresses that given ⌜f : ℝⁿ → ℝⁱ⌝, and a point ⌜x : ℝⁿ⌝, we get ⌜f′ x : ℝⁿ ⊸ ℝⁱ⌝ as our jacobian matrix of all partial derivatives, so that ⌜f′ x · d⌝ (
17:04:14 <Cale> and then at the start of main,  hSetBuffering stdout NoBuffering
17:04:27 <ski> (er, probably cut off near ".., so that ⌜f′ x · d⌝ (for ⌜d : ℝⁿ⌝ a direction vector) will be the directional derivative of ⌜f⌝ at ⌜x⌝ in the direction of ⌜d⌝")
17:04:27 <bwiklund> trying
17:04:55 <mniip> ski, stop
17:04:56 <ski> mniip : btw, i'm only talking about gradient (and generalizations) here, not about divergence or rotor/curl
17:05:04 * ski stops dead
17:05:15 <mniip> "the linear space ⌜ℝⁿ ⊸ ℝⁱ⌝ is the space of ⌜i⌝-by-⌜n⌝ matrices"
17:05:23 <mniip> huh
17:05:40 <bwiklund> ah, that's totally it ski
17:06:17 <ski> an ⌜i⌝-by-⌜n⌝ matrix is such that if you (on the right) multiply it by a vector from ⌜n⌝-dimensional space, then you get a vector from ⌜i⌝-dimensional space
17:06:27 <semigroup> Is there a way to get GHC to emit all of CPP's #defines?
17:06:35 <bwiklund> er, @Cole
17:06:38 <bwiklund> not ski
17:07:14 <mniip> ski, do you meant the derivative of a ⌜ℝⁿ ⊸ ℝⁱ⌝ space is a ⌜i⌝-by-⌜n⌝ matrix?
17:07:26 <ski> mniip : no, not at all
17:07:40 <ski> mniip : we're taking the derivative of a ⌜f : ℝⁿ → ℝⁱ⌝, here
17:07:44 <ski> this is not a matrix
17:08:06 <mniip> it's an ℝⁿ -> matrix
17:08:11 <ski> it's some arbitrary (differentiable) function from ⌜n⌝-space to ⌜i⌝-space
17:08:31 <mniip> I'm confused
17:08:36 <ski> if it was a *linear* function/map/transformation, *then* it would exactly correspond to such a matrix
17:08:58 <ski> but ⌜f : ℝⁿ → ℝⁱ⌝ is not assumed to be linear
17:09:26 <mniip> where did "linear" get from
17:09:59 <ski> matrices are very closely related to linear transformations
17:10:17 <mniip> hold on
17:10:24 <mniip> am I getting this right
17:10:27 <ski> (this is known as linear algebra)
17:10:38 <laudiacay> linear <3 <3 <3
17:11:39 <ski> ianjneu : unfortunately Haskell doesn't have ML-style module functors
17:11:51 <ski> (ianjneu : not sure what you mean by "the module pattern to curry out an argument from several functions")
17:12:12 <mniip> if f : ℝⁿ → ℝⁱ then f' : ℝⁿ → ℝⁿ⁻ⁱ
17:12:26 <mniip> where ℝⁿ⁻ⁱ is a matrix
17:13:08 <octatoan> .
17:13:26 <ski> hmm .. i found an ⌜ᵐ⌝ :)
17:14:06 <mniip> so uh
17:14:08 <Cale> mniip: If V and W are vector spaces, T: V -> W is a linear transformation, and {b_1,...,b_n} is a basis for V, then for any v in V we can write v = v_1 b_1 + ... + v_n b_n for some scalars v_1,...,v_n, and so T(v) = T(v_1 b_1 + ... + v_n b_n) = v_1 T(b_1) + ... + v_n T(b_n).
17:14:33 <Cale> mniip: So if we know what T does on the basis {b_1,...,b_n}, we know which linear transformation T is
17:14:44 <mniip> hold on
17:14:49 <ski> mniip : basically yes (if i interpret your ⌜⁻⌝ as a multiplication rather than as a subtraction :)
17:15:04 <mniip> there doesn't appear to be a superscript multiplication
17:15:22 <mniip> ℝⁿˣⁱ maybe
17:15:34 <mniip> that's an x though
17:16:12 <Cale> mniip: If in addition to this, we have some basis {c_1,...,c_m} for W, then we can write out T(b_1) = a_11 c_1 + a_21 c_2 + ... + a_m1 c_m, ..., T(b_n) = a_1n c_1 + ... + a_mn c_m
17:16:32 <Cale> and these coefficients a_ij completely determine which linear transformation T is
17:16:38 <mniip> what is a linear transformation
17:16:40 <ski> mniip : perhaps you could use ⌜ ̇⌝ (though that's a dot)
17:16:46 <Cale> Oh, right, okay
17:17:42 <mniip> ski, that's a combining dot above
17:17:48 <ski> mniip : one way to think of it, "linear transformation" is more or less the appropriate generalization of "matrix"
17:17:51 <ski> mniip : i know
17:17:52 <Cale> So a linear transformation is a function T: V -> W such that for any vectors v and v' in V, and scalar a in F (where F is usually the real numbers in our discussion), we have T(v + v') = T(v) + T(v'), and T(a*v) = a*T(v)
17:18:06 <Cale> i.e. a function which preserves addition of vectors and preserves scalar multiplication
17:18:11 <mniip> ok
17:18:36 <mniip> how are linear transformations related to matrices
17:18:46 <Cale> Well, that's what I was just explaining
17:18:58 <Cale> So if you go back and read my last few lines there
17:19:27 <ski> (perhaps Cale should define what an abstract vector space is, to begin with)
17:19:43 <Cale> You can see that once we choose a basis for both V and W, any linear transformation T: V -> W is completely determined by these coefficients a_ij
17:20:06 * hackagebot bindings-GLFW 3.1 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.1 (SchellScivally)
17:20:08 * hackagebot GLFW-b 1.4.7 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.7 (SchellScivally)
17:20:33 <Cale> Yeah, and I also didn't define what a basis was
17:21:24 <Cale> But if you want to skip that discussion, you can let V = R^n and W = R^m, and take b_i = (0,0,...,0,1,0,...,0) where the 1 is in the ith position, and similarly for the vectors c_i
17:22:04 <mniip> ugh
17:22:12 <Cale> and note that every vector in R^n can be written uniquely as a linear combination of the b_i's i.e. as v_1 b_1 + ... + v_n b_n
17:22:30 <Cale> which is just (v_1,v_2,...,v_n)
17:22:54 <mniip> different notations, different notations everywhere
17:23:12 <Cale> hm?
17:23:30 <Cale> Which notation is bothering you?
17:24:44 <mniip> not bothering, but rather
17:25:10 <scott> mniip: basically, any function T: V -> W such that  T(v + v') = T(v) + T(v')  and  T(a*v) = a*T(v)  (a linear transformation) can be represented as T(v) = A*v for some matrix A of the right dimensions to make the multiplication work, and vice versa (matrices give rise to linear transformations)
17:26:14 <mniip> I think it's the generalization that's bothering me
17:26:24 <mniip> I have an intuition for vectors and spaces on R
17:26:32 <Cale> Yeah, I'm used to explaining this in a fairly general context
17:27:30 <mniip> right
17:27:41 <ski> kaiyin : hmm .. you were interested in anarchic and archic data types ? or "total vs. partial derivatives","dependent vs. independent variables","dynamic vs. static/lexical scope" ? both ?
17:27:48 <Cale> http://en.wikipedia.org/wiki/Vector_space#Definition -- like I'm assuming we're working with general (but finite dimensional) vector spaces over an arbitrary field of scalars, just because it works there
17:28:47 <Cale> mniip: But we could also say it like this
17:29:02 <Cale> mniip: If we have some linear transformation R^n -> R^m
17:29:20 <mniip> dae think math is much simpler when represented in haskell typesystem
17:29:51 <Cale> Say, T: R^n -> R^m, then T is completely determined by where it sends the vectors (1,0,...,0), (0,1,0,...,0), ..., (0,0,...,0,1)
17:30:15 <Cale> we can record the results of applying T to each of those vectors as the columns of a matrix
17:30:19 <octatoan> mniip: Maybe.
17:30:37 <mniip> Cale, because feeding such vectors to T will obtain the cols of the matrix A?
17:30:44 <Cale> yeah
17:31:03 <Cale> Well, that's basically how we define the matrix representation of T (with respect to the standard basis)
17:31:03 <ski> mniip : well, consider a geometric space (like in Euclidean geometry, no coordinates), like a single point, a line, a plane, or three-dimensional space. *if* you fix an origin point, and one/two/three more distinct points to serve as "unit" points on coordinate axes from the origin, *then* you can translate between the three former vector spaces and ⌜ℝ⁰⌝,⌜ℝ¹⌝,⌜ℝ²⌝,⌜ℝ³⌝ (which are vector spaces where the "vectors" are tuples of r
17:31:19 <ski> (er, overflow again "(which are vector spaces where the "vectors" are tuples of real numbers)")
17:32:39 <mniip> ski, what
17:32:39 <ski> mniip : in these geometric spaces, a vector is a *translation* of all the points in the space (you can define a vector as an equivalence class of all directed line segments that have the same length and direction)
17:33:32 <mniip> lost it on '*if* you fix an origin point, and one/two/three more distinct points to serve as "unit" points on coordinate axes from the origin,'
17:33:33 <ski> (usually you draw a vector by drawing such a directed line segment, drawing it as an arrow from some starting point to some ending point)
17:34:13 <ski> mniip : there's no reason to prefer any particular point, over any of the other points, as the origin point
17:34:27 <scott> mniip: e.g. in R^3 you pick (0,0,0) and the unit points are (1,0,0), (0,1,0), (0,0,1), but it doesn't technically matter what you pick
17:34:53 <mniip> no I mean
17:34:58 <mniip> I pick some points and then what
17:36:27 <ski> mniip : there's no reason to prefer any particular directed lines (coordinate axes) through the origin point to any other set of ⌜n⌝ such lines (⌜n⌝ being the dimension of the geometric space, above ⌜0⌝,⌜1⌝,⌜2⌝,⌜3⌝, respectively), as long as they are distinct (any maybe orthogonal to each other)
17:37:15 <mniip> yes
17:37:19 <mniip> I understand that
17:37:38 <ski> mniip : if you pick some points/lines specifying a coordinate system, *then* you can use that to *translate* between ⌜n⌝-dimensional geometric space and the ⌜ℝⁿ⌝ space of coordinate tuples
17:38:17 <ski> (this was what Descartes did to start analytic geometry. as opposed to the older synthetic one, which didn't analyze points in terms of a bunch of numbers)
17:38:26 <mniip> ah
17:38:41 <mniip> you said such a simple thing in such a complicated way the first time
17:39:46 <ski> my point is to distinguish between ⌜ℝⁿ⌝, which is the set/type of ⌜n⌝-tuples of real numbers (with vector addition and scaling defined componentwise) from ⌜n⌝-dimensional geometric space
17:40:05 <mniip> what
17:40:32 <mniip> why would you want to distinguish them
17:40:49 <ski> because one is a set that contains geometric points
17:41:00 <ski> the other is a set that contains ⌜n⌝-tuples of numbers
17:41:08 <ski> there's conceptually quite distinct
17:42:30 <mniip> but they're equivalent, aren't they
17:42:31 <ski> there's a special element of ⌜ℝⁿ⌝ that you can "canonically" pick out, ⌜(0,⋯,0)⌝ (⌜n⌝ ⌜0⌝s in there)
17:43:16 <ski> you can't pick a similar special point out of a geometric space (well, say positive-dimensional) in any similar way ..
17:43:21 --- mode: ChanServ set +b *!*@209-112-40-2.dedicated.allstream.net
17:43:21 --- kick: ParmesanCaesar was kicked by ChanServ (User is banned from this channel)
17:43:56 <mniip> not unless you fix an origin
17:43:57 <ski> .. unless you've already selected say an origin point (in which case you can again pick out the point you decided to earlier call "origin point" out of all the others)
17:44:20 <ski> so, yes. in some sense these two spaces are equivalent (the term is "isomorphic")
17:44:50 <ski> but the isomorphism depends on an *arbitrary* choice of origin (and some more stuff)
17:45:28 <ski> this means that it's good to distinguish between these, since there isn't a "canonical" isomorphism
17:46:27 <ski> (if you have already selected a coordinate system (iow selected a basis for your geometric space), then you can blur the lines here, and implicitly convert from the geometric space to the space of coordinate tuples, and vice versa, as you like, if you please)
17:46:54 <mniip> so you're saying that there are multiple equivalent choices of isomorphism between the two and thus they should be distinguished?
17:47:06 <ski> also, sometimes we use more than one coordinate system (i.e. basis) for the same space at the same time, and then it again makes sense to distinguish
17:47:06 <Rotaerk> here's my AtomicT so far:  http://lpaste.net/58249609188737024
17:47:28 <ski> mniip : multiple *nonequivalent* choices of isomorphism
17:47:37 <Rotaerk> I'm wondering if there should be a function for trivially converting an EitherT to an AtomicT *without* a rollback
17:48:04 <ski> if i choose one coordinate system, then for a given point i get some coordinate tuple. if i choose a different coordinate system, then for the same point i'd usually get a *different* coordinate tuple
17:48:19 <Rotaerk> and if so, I'm trying to come up with a name for it
17:49:40 <ski> Rotaerk : `Monad m => EitherT e m a -> AtomicT e m a' ?
17:49:53 <Rotaerk> yea that would be the signature
17:50:07 <Rotaerk> I'm thinking maybe calling it "enduring" or something
17:50:32 <Rotaerk> because it's an action that it doesn't try to rollback, if the overall atomic fails
17:51:31 <mniip> ski, different isomorphisms
17:51:42 <mniip> but equivalent in the sence that none is better
17:51:45 <mniip> than any other
17:52:09 <Rotaerk> oo, I think I have a better symbol for -/>
17:52:13 <Rotaerk> -^
17:52:22 <ski> Rotaerk : would `deriving Monad' not give you the inlining there ?
17:52:28 <ski> mniip : right
17:52:38 <ski> mniip : no preferred one
17:53:07 <ski> mniip : now, there *is* a preferred basis coordinate system on the space ⌜ℝⁿ⌝ :)
17:53:10 <Rotaerk> ski, no idea
17:53:24 <ski> mniip : possibly you didn't even realize that there could be other ones :)
17:54:37 <ski> mniip : the preferred basis is ⌜(1,0,⋯,0)⌝,⌜(0,1,0,⋯,0)⌝,...,⌜(0,⋯,0,1,0)⌝,⌜(0,⋯,0,1)⌝. the chosen origin point here is ⌜(0,⋯,0)⌝, obviously
17:54:39 <mniip> 'preferred' is relative but I get where you're going
17:55:14 <ski> (yes, i think "canonical" is probably the best more or less technical term for what i meant by "preferred" above)
17:55:43 <ski> mniip : but there's lots of other bases on ⌜ℝⁿ⌝ as well
17:56:55 <mniip> on an unrelated note I implemented a very hack-ish derivative calculator for RealFloat
17:57:47 <mniip> derivative log 4 -> 0.24999999627470973
17:58:56 <lpaste> mniip pasted “derivative” at http://lpaste.net/122317
18:02:44 <mniip> ski, anyway
18:03:02 <ski> mniip : now consider the space of polynomials "in one variable", of degree at most ⌜j⌝. the elements here looks like ⌜λ x ↦ a₀·x⁰ + a₁·x¹ + a₂·x² + ⋯ + aⱼ·xʲ⌝, for various choices of real numbers ⌜a₀⌝,⌜a₁⌝,⌜a₂⌝,...,⌜aⱼ⌝
18:03:38 <mniip> ok
18:04:29 <ski> this is an ⌜j+1⌝ dimensional space. the basis vectors are ⌜λ x ↦ x⁰⌝,⌜λ x ↦ x¹⌝,⌜λ x ↦ x²⌝,...,⌜λ x ↦ xʲ⌝ -- using these you get an isomorphism between this space and ⌜ℝʲ⁺¹⌝
18:04:48 <ski> once again, there are other bases for this space as well. but this one is a canonical choice
18:05:10 <mniip> ok
18:06:07 <ski> mniip : have you looked any into automatic differentiation ?
18:06:21 <mniip> ?
18:06:41 <mniip> is that a comment to my derivative thingy?
18:07:12 <ski> mniip : yep
18:07:19 <mniip> not really
18:07:49 <mniip> I would guess differentiation is usually done with some arbitrary dx, or symbolically
18:09:41 <ski> well, the "automatic differentiation" is not a symbolic approach, nor does it numerically try to approximate limits
18:10:26 <acowley> It's a limit as the square of the infinitesimal goes to zero
18:10:32 <ski> mniip : see e.g. "Functional Differentiation of Computer Programs" by Jerzy Karczmarczuk in 2001 at <https://karczmarczuk.users.greyc.fr/arpap/>
18:10:56 <ski> (that uses Haskell to illustrate)
18:11:08 <ski> it's a really beautiful idea
18:27:14 <zq> ski: there's a typo in that paper
18:27:29 <ski> ok ?
18:28:01 <ski> (i can see one on page 5)
18:28:11 <zq> definition of division
18:31:50 <Rotaerk> yay AtomicT works
18:34:19 <ski> mniip : hm .. so should i mention what i had in mind wrt "total vs. partial derivatives","dependent vs. independent variables","dynamic vs. static/lexical scope" ? perhaps another time ?
18:35:11 <ski> Rotaerk : did you add `enduring' ? why `-^' ?
18:35:31 <mniip> what
18:36:06 <Rotaerk> ski, -^ because it's the closest symbol I could think of to:  http://png-3.findicons.com/files/icons/2338/reflection/128/button_undo.png
18:36:31 <ski> Rotaerk : your `Monad' and `Functor' instances should be derivable by `GeneralizedNewtypeDeriving'. perhaps the `Applicative' one as well, not sure
18:36:58 <ski> hm, ok
18:37:03 <arkeet> certainly Applicative can be derived for newtypes.
18:37:23 <ski> (i thought the `-/>' looked nice, myself)
18:38:08 <ski> arkeet : yes. but here he uses `return' and `ap' as implementations. the question would be whether they'd be equivalent to using the derived `pure' and `(<*>)'
18:38:18 <Rotaerk> i could go back to that, but here's what I've got now:  http://lpaste.net/58249609188737024
18:38:31 <Rotaerk> some ad hoc test cases at the bottom
18:38:43 <arkeet> ah, I haven't been following.
18:39:24 <ski> Rotaerk : and `enduring :: Monad m => EitherT e m a -> AtomicT e m a' ?
18:39:38 <Rotaerk> lemme implement that; do you think "enduring" is a good choice of name?
18:39:43 <Rotaerk> I was considering some others as well
18:40:01 <Rotaerk> maybe just "noRollback"
18:40:54 <Lokathor> what would a "function :: a -> b" look like?
18:40:57 <ski> mniip : this whole vector discussion started because you were (if i may read it so) dismissing partial derivatives as a hack
18:41:31 <ski> Rotaerk : i'm not quite sure what semantics you were wanting for it
18:42:22 <mniip> ski, yeah
18:43:15 <Rotaerk> ski, for when you want to convert an EitherT to an AtomicT, but where there is no rollback plan for it.  I'll make an example
18:43:39 <acowley> Lokathor: ⊥
18:44:22 <Lokathor> and that's the only possible implementation, right?
18:44:36 <mniip> purely speaking, yes
18:44:45 <acowley> Lokathor: There are many ways to implement bottom
18:45:10 <Lokathor> oh?
18:45:16 <Lokathor> i thought it was an escape value, like undefined
18:45:54 <acowley> Yes, but you can also infinitely loop in whatever way you see fit. 
18:46:12 <acowley> And, practically speaking, unsafeCoerce has that type
18:46:44 <ski> Rotaerk : perhaps `enduring = AtomicT . mapEitherT lift . runAtomicT' (if i got the types right in my head) ?
18:46:59 <acowley> So, you have to ask if you're talking about Haskell, and whether the compiler optimizes away the body of your loop, or, if it doesn't, do spurious calculations really matter
18:48:21 <ski> Lokathor : bottom means any "improper value", like nontermination, partiality (pattern-match failure) or some explicit use of `error' or `throw'. anything that when forced doesn't return a normal value
18:48:48 <Lokathor> well, i am talking about Haskell for one
18:49:15 <ski> mniip : so, have you heard about "dynamic scope (or extent)" vs. "static/lexical scope" in programming ?
18:49:30 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures/05-type-classes.html has a list of example parametric signatures
18:49:39 <Lokathor> most of them i could identify an example for
18:49:39 <Rotaerk> ski, enduring = AtomicT . mapEitherT lift
18:49:47 <mniip> uh
18:49:53 <mniip> depends on what you mean by those terms
18:50:02 <Rotaerk> (thanks; my implementation was much more explicit...)
18:50:10 <Rotaerk> (still kind of a noob at dealing with monad transformers)
18:50:53 <ski> Rotaerk : *nod*, that's the "obvious" implementation, but possibly you had something else in mind, i didn't know
18:51:49 <ski> (or, i should say s/implementation/behaviour/ .. that particular implementation is how i conceptually think about it (e.g. when i forget the actual behaviour that this results in, as in this case))
18:51:53 <mniip> ski, on the other hand I'd rather resume our discussion sometime later
18:51:59 <ski> mniip : ok, np
18:52:14 <Rotaerk> http://lpaste.net/58249609188737024
18:52:51 <Rotaerk> now to try out deriving...
18:54:19 <ski> Rotaerk : fwiw, i'm not fond of the `String' in `failingEither'
18:55:15 <Rotaerk> ski, those are just for the sake of testing
18:55:20 <Rotaerk> not permanent residents of Atomic
18:55:33 <Rotaerk> the signature is perhaps a little unnecessarily extensible
18:55:33 <ski> (because i'm not fond of encoding information in strings. i'd prefer waiting until the last moment before interpreting some error code/constructor, translating it to a string (possibly dependent on the context))
18:55:37 <ski> @quote stark
18:55:38 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18:55:43 <Rotaerk> ski, right.
18:55:45 <Rotaerk> I agree
18:56:06 <Zemyla> Why is there no Control.Monad.ST.Class?
18:56:13 <ski> if it's just of testing, then it's fine
18:57:23 <Rotaerk> and yes, the deriving of Monad, Applicative, and Functor worked
18:57:38 <ski> Zemyla : i assume because there's no corresponding class for `ST', and because there's no corresponding transformer for it
18:59:43 <ski> (oh, right. no `runAtomicT', of course)
19:02:41 <has_skull> is functional programming the future?
19:03:10 <ski> Rotaerk : hm, so i suppose `enduring' runs a possibly failing computation, but without adding a rollback in case it succeeds :)
19:03:35 <Rotaerk> ski, yea, I'm still undecided as to whether it's a good idea
19:03:47 <johnw> has_skull: it's one future
19:03:49 <ski> s/:)/?/
19:03:51 <johnw> I have a feeling there will always be room for alternative approaches to problem solving
19:04:06 <has_skull> yah thats a good point
19:04:11 <Rotaerk> ski, oh, it's a question:  yes, that's what it does
19:04:13 <Axman6> hellertime: it is one of infinitely many alternative futures. luckily it is well suited to dealing with infinities
19:04:26 <has_skull> guess thats why i want to learn haskell
19:04:37 <has_skull> right now i just know some python
19:04:43 <johnw> has_skull: just learn it because it's fascinating; the future will let you know what it needs
19:04:52 <Axman6> you've probably got a lot of unlearning to do then =)
19:05:07 <ski> has_skull : well, multi-core probably won't go away. it's easier to take advantage of parallelism when you ban mutation side-effects ..
19:05:39 <has_skull> from what i understand in haskell you write like 20 functions then add them all together in one line to run your program?
19:06:01 <johnw> has_skull: that is so of the defining characteristic of functional programming: you build complex programs by composing smaller parts
19:06:07 <johnw> s/so/one
19:06:24 <has_skull> johnw yeah thats thats the part of functional programming that sounded the best
19:06:33 <johnw> it's indeed pretty awesome
19:06:35 <has_skull> and when i make these tiny functions i can use them in different programs
19:07:03 <ski> has_skull : in Haskell, instead of "statements/commands" and "side-effects", you should think "expressions" and "(immutable) values"
19:07:04 <johnw> yep
19:07:32 <has_skull> what are side effects exactly
19:07:34 <Axman6> has_skull: it's not always that simple though; not all programs are a bunch of steps that can be fed into each other
19:07:51 <ski> has_skull : our functions just have an expression as body, has no side-effects
19:08:07 <johnw> Axman6: what kind of program isn't?
19:08:12 <Axman6> you can't print to the terminal or modify variables from within functions*
19:08:26 <johnw> because you can describe an action that prints to the terminal, and compose those the same way
19:08:31 <johnw> s/because/but
19:08:37 <glguy> You can still modify references or print to the terminal, we just don't use "function" for that
19:08:43 <ski> has_skull : "side effects" are what happens "on the side" when you're calling a Python function : anything observable effect that isn't part of deterministically returning a single result value is a side-effect
19:08:46 <Axman6> johnw: well, the way it was being described implied that you could write main = f . g . h $ x got pretty much all programs, and that's usually far from true
19:09:00 <johnw> for the right definition of . and $, that's still true
19:09:05 <johnw> that was my point
19:09:21 <johnw> the "magic" of monads is that you can still compose in the presence of effects
19:10:31 <has_skull> i am currently a student in CS, will learning haskell help me get a job lol
19:10:34 <ski> has_skull : mutating some global variable, or an argument is a side-effect. *depending* on the current value of some *mutable* global variable is a side-effect. accepting input to the program, emitting output to the program, getting some random bits from a random bits source, are all side-effects, if done as usual in imperative programming (such as Python)
19:10:54 <ski> has_skull : raising/throwing/signaling some exception is a side-effect
19:11:26 <Axman6> many of us have jobs writing haskell, and there are plenty of employers who use the knowledge of haskell as a positive trait when choosing candidates, whether they will be using haskell or not
19:11:42 <ski> has_skull : a function possibly returning different results because of how some threads happen to be scheduled (concurrency, race conditions) is a side-effect
19:11:59 <ski> has_skull : that's the most common sources of side-effects :)
19:12:07 <has_skull> ski cool thank you
19:12:09 <Axman6> and errors in concurrent code
19:12:41 * Rotaerk ponders alternatives to (-^).
19:12:51 <ski> (has_skull : then there's also jumps and continuations .. and some more stuff)
19:13:24 <has_skull> ski: and i heard a lot about monoids, i sort of understand them, are they really that important in haskell/functional programming?
19:13:58 <Axman6> they're just a useful abstraction
19:14:11 <Axman6> you can write some really generic code that works on all sorts of monoids
19:14:43 <ski> has_skull : Haskell cleanly *separates/distinguishes* the parts of a program that may perform effects (this time *not* "on the side", but as part of the "main result") from the parts of a program that may not. this is basically the same (good) idea as separating UI in a program from internal machinery, only enforced (in some sense) by the language
19:16:04 <ski> has_skull : this means that it's much easier to *reason* about and refactor Haskell programs, since you can use equational reasoning (as with equations in math, more or less), without fear of introducing bugs by "changing the order two functions are called" or by "calling the same function (with the same arguments) more times or less times (reusing the result)"
19:16:23 <ski> has_skull : "monoids" is one thing. "monads" is another
19:16:44 <has_skull> are they important to understand?
19:17:16 <ski> has_skull : monoids is just a sometimes useful idea, like the idea of a priority queue e.g.
19:18:05 <Axman6> you already know many monoids (+ with 0, * with 1, && with True, list append with the empty list)
19:18:25 <ski> has_skull : after you have understood how Haskell expresses effects using monads (and also by "applicative functors", and sometimes by some other things), monads will also be a "sometimes useful idea"
19:19:04 <shachaf> Haskell expresses printing effects using String, with putStr as the interpreter.
19:19:16 <has_skull> ski: about the separation of performing effects, those would be the functions, right? then what else is not allowed to perform effects?
19:19:44 <has_skull> and how is that different from python functions? if i keep them seperate and dont use global variables or dumb stuff in python isn't that about the same?
19:20:20 <ski> has_skull : to do input/output in Haskell, you must use `IO', which has a lot of primitive operations for doing specific input and output operations (basically, communicating with the Operating System, and occasionally with another language, like C or perhaps Python). `IO' happens to support a monadic style of composing some primitive actions
19:20:58 <ski> has_skull : `IO' also has an "applicative functor" interface (and a plain "functor" interface), and sometimes you'll be using those instead
19:21:24 <Zemyla> Man, that forall makes it difficult to write typeclasses about ST.
19:22:18 <ski> has_skull : "those would be the functions, right?" -- no. functions are only used in haskell to express some (internal) dependency from arguments to return values (independent of everything else, e.g. not depending on input from the OS)
19:23:37 <ski> has_skull : take `putStr'. it is a function that takes a string as input. this function does *not* output that string when called with it as argument (there is no such thing in Haskell as "output happening when calling a function". that would be a side-effect, which is banned)
19:24:53 <ski> has_skull : perhaps in Python, a corresponding function would return nothing, or `0', or some other uninteresting value. in Haskell, the corresponding uninteresting value is called "unit", written `()'
19:25:27 <has_skull> ski: haskell seems to have a serious learning curve cmpared to python but it's worth it right lol
19:25:43 <ski> has_skull : yeah, we tend to think it's worth it :)
19:25:44 <has_skull> in python you can dick around a lot but haskell has rules and fancy terminology and stuff
19:26:32 <has_skull> but is it really that much more efficient in terms of development time compared to python?
19:26:44 <ski> has_skull : it's probably best to assume that you know nothing about programming, and are starting to learn it from scratch, when learning Haskell (unless you have any previous experience with any other functional (or perhaps logic) programming language)
19:26:59 <ski> has_skull : obviously some things will carry over, but possibly less than you think
19:27:33 <Axman6> Haskell has teaches you some discipline, which pays off in the long run because you end up with more maintainable code, which has far fewer chances to go wrong
19:28:01 <carter> Axman6: i just finished a CRAZY ass prototype for work
19:28:12 <has_skull> i want to learn haskell but how will i impress potential employers if they can't read my code because it's haskell
19:28:24 <ski> Zemyla : it does ?
19:28:31 <carter> lol, my boss haskells
19:28:52 <cmccann> has_skull: no worries, after spending enough time learning to think in Haskell they won't be able to read your python either
19:29:10 <Axman6> the 'ease' of development you get with python, imo, is a false economy; you will end up spending less time later trying to fix bugs than you would with a language lacking many of the great features of haskell (particularly the amazing type system)
19:29:18 <Javran> @yhjulwwiefzojcbxybbruweejw
19:29:18 <lambdabot> Just 'J'
19:29:32 <ski> has_skull : going back to `putStr', when called with a string, it returns an "action" (an `IO'-action), than when *executed* will output the string (and then return the uninteresting value `()' to the invoker as result)
19:29:47 <ski> @yhjulwwiefzojcbxybbruweejw
19:29:48 <lambdabot> Just 'J'
19:30:00 <Axman6> cmccann: ... without crying*
19:30:04 <Axman6> =)
19:30:18 <carter> Axman6: i can top that, a friend who's considered himself a python expert, spent the past 2 months learning haskell, and now he's very uncomfortable with the guarantees in python code
19:30:25 <carter> so now his python code looks a lot more defensive
19:30:34 <Axman6> python has guarantees?
19:30:42 <Axman6> when did they add that?
19:30:46 <exio4> yup, any function may crash 
19:31:15 <Axman6> to be far, so may any function in haskell; they just tend to avoid it at all costs
19:31:15 <cmccann> Axman6: well, what I meant was that after has_skull learns to think in Haskell, nobody will be able to read has_skull's python code either
19:31:28 <Axman6> heh, yes
19:31:31 <cmccann> the code may also make various people cry for various reasons though
19:31:49 <carter> *lack of guarantees
19:31:52 <has_skull> is haskell good for big programs
19:31:56 <carter> yes
19:32:00 <has_skull> like thousands of lines for a business program
19:32:02 <Axman6> haskell is good for programs
19:32:09 <carter> has_skull: i'm doing big data processing at a bank with haskell
19:32:11 <johnw> has_skull: it's especially good for large programs
19:32:13 <ski> has_skull : conceptually, Haskell can be thought of as both doing "evaluation" (computing the resulting values of expressions, doing no effects), and "execution" (actually performing effects, like showing some output on the screen)
19:32:31 <Lokathor> fpcomplete says that they talked to a company that turned a 5mil line non-haskell program into a 1mil line haskell program
19:32:50 <johnw> Lokathor: I don't usually trust statistics like that
19:32:57 <has_skull> i'm doing the learn you haskell tutorial
19:33:06 <johnw> you can rewrite any 5-mil line program into a 1-mil line program, just by understanding the problem better after having written the first 5-mil lines
19:33:18 <Axman6> indeed
19:33:21 <Lokathor> well it doesn't prove that haskell is better
19:33:29 <Lokathor> but it does prove that you can write a 1mil line haskell program
19:33:38 * ski grins
19:33:39 <johnw> ah, good point!
19:33:40 <cmccann> has_skull: tbh, giant piles of complicated business logic code is exactly where I'd most want to use Haskell in the world of generic corporate development
19:34:05 <Lokathor> So I read a thing the other day about hackage modules having too many dependencies and orphan instances and all that
19:34:25 <Lokathor> it left me wondering: why aren't there controls about what instances are imported from a module, or exported from a module?
19:34:51 <cmccann> Lokathor: because every proposed solution for that sort of thing has been worse than the problem
19:34:57 <cmccann> in one way or another
19:34:58 <Lokathor> oh dear :(
19:34:59 <f|`-`|f> YOu'd probably have to implement a rule engine for that, cmccann 
19:35:17 <has_skull> does having good haskell programs look good on a resume, at my college they dont' teach haskell so i'm thinking it would be a cool way for me to stand out (also i'd be a better programmer for learning it) sound good?
19:35:23 <ski> has_skull : you can also consider doing <http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html> (including the exercises)
19:35:40 <cmccann> if nothing else they at least fail on the criterion of "ok, so who's gonna design and implement this"
19:35:42 <Axman6> has_skull: sounds about right
19:35:56 <f|`-`|f> Have a portfolio on github or soemthing, has_skull 
19:36:17 <has_skull> i have an account but havn't really built anything big...makes me feel sad
19:36:24 <f|`-`|f> There is a special file type called Literate Haskell Source, it is a *.lhs
19:36:35 <ski> Lokathor : the obvious way to do it breaks the "at most one instance of a type, per class" guarantee, which in turn breaks some libraries that depend on that assumption, like e.g. `Set'
19:36:42 <nybble> Hello there! I've just started learning Haskell (and am completely new to irc channels so forgive me if I seem a bit lost...I totally feel like I'm eavesdropping...) and was wondering if I could get some guidance on a problem I'm struggling with?
19:36:45 <f|`-`|f> It allows you to write an essay easier in betwixt your actual code, has_
19:37:03 <Axman6> nybble: only if you tell us what the problem is =)
19:37:16 <cmccann> nybble: first point of guidance: ask the question, don't ask if you can ask ;]
19:37:41 <f|`-`|f> If I recall, for the .lhs file, the compiler only interprets a line as code if it starts with a "> "
19:37:52 <ski> nybble : no worry about lurking :) feel free to chime in anytime you like (as long as it's at least tangentially related to Haskell, in this channel, of course)
19:37:56 <f|`-`|f> So you don't need to comment out comments
19:38:02 <f|`-`|f> You just need to comment in code
19:38:15 <nybble> Thanks! :) Axman6 and cmccann and ski, I'm trying to write something similar to take on lists but for an infinite binary tree
19:38:17 <RageD> alright. Decided to install haskell platform fresh and upgrade to latest ghc on my mac. anyone ever see this problem when running "cabal install vector" ?
19:38:17 <RageD> Loading package primitive-0.5.4.0 ... <command line>: can't load .so/.DLL for
19:38:27 <RageD> looks like it can't find shared lib for base.
19:38:30 <RageD> which indeed does not exist
19:38:37 <RageD> so I suppose the real question is, how do I fix that?
19:39:08 <has_skull> ski: thanks for the link that looks really good
19:39:21 <Axman6> nybble: where have you got to?
19:39:28 <ski> nybble : second point of guidance : never ask a question in a technical IRC channel, and then leave too soon (like in less than half an hour). many IRC channels are slow, much of the time, and people don't sit and look at their IRC clients all day (some are logged all week, but must sleep at some point, of course)
19:39:32 <carter> RageD: dont use haskell platform
19:39:34 <f|`-`|f> https://github.com/bitemyapp/learnhaskell <- This is a compilation of learning materials, has_skull 
19:39:36 <Axman6> nybble: and in what order do you want to return the elements?
19:39:37 <carter> use ghc for os x app
19:40:44 <ski> nybble : so, it may take some time for people to notice someone has said something. also many people are shy of offering themselves for help if you don't think they have some good chance of being able to help. so give as much upfront info as you can rather than asking "does anyone know anything about X ?"
19:41:00 <has_skull> functional programming makes me excited is that normal
19:41:06 <ski> has_skull : yes :)
19:41:06 <f|`-`|f> yes
19:41:13 <Lokathor> literate haskell programs aren't quite my bag, because the "> " prefix on lines makes the tab key (only inserting spaces with it, of course) not work out quite right
19:41:20 <ski> (it brings back the fun in programming)
19:41:27 <carter> Lokathor: you can use latex style LHS :)
19:41:29 <f|`-`|f> You will learn that mathematics is overpowered
19:41:45 <has_skull> mathematics is overpowered i love it lol
19:41:54 <f|`-`|f> I think it's bullcrap
19:41:59 <f|`-`|f> But I love it anyways
19:42:06 <Cale> pls nerf
19:42:12 <ski> has_skull : there's also a #haskell-beginners channel that you can also try. people in there will suggest the CIS 194 course over LYAH
19:42:16 <Lokathor> carter, i've used LaTeX on a few projects, but i'm not familar with "latex-style" in this context
19:42:27 <RageD> carter: thanks. downloading now
19:42:28 <carter> \begin{code} .... \end{code}
19:42:38 <f|`-`|f> I got the https://github.com/bitemyapp/learnhaskell from haskell_beginners :^)
19:42:39 <carter> RageD: its pretty good
19:42:46 <has_skull> ski and every1 thank u a bunch for the help whenever i have some free time i'll be learning haskell
19:42:50 <ski> has_skull : .. however, i don't want to dissuade you from staying in here (possibly as well). by all means please do :)
19:42:58 <carter> i think i hit 1-2 quirks with how it links haddocks of base libs
19:42:59 <carter> but whatever
19:43:01 <has_skull> ski yah now i just have 2 channels to afk in lol
19:43:03 <Lokathor> yes yes, both channels
19:43:06 <f|`-`|f> This place is usually where more complicated things are talked about
19:43:17 <f|`-`|f> It is generally slower in beginners
19:43:23 <exio4> ski: then you start mixing value-level functional programming with type-level constraint logic programming, would be that super-fun, or what? :p 
19:43:27 <Lokathor> i got spooked out of beginners once >_>
19:43:34 <ski> has_skull : oh, and if you're going to be using IRC regularly (like when you're wondering something about Haskell), you might consider getting proper IRC client
19:43:37 <f|`-`|f> YOu will quickly learn that things talked about in beginners is not really beginner stuff
19:43:41 <nybble> Axman6: I've got an infinitree implemented and have a type signiture of ttake :: Tree -> x -> Tree and then I started with ttake (Node n l r) x = something....I guess I'm kinda lost because I don't know how to get just x amount of branches
19:44:01 <ski> (bah)
19:44:04 <nybble> ski: thanks for the tips!
19:44:08 <ski> nybble : that comment to has_skull above also applies for you :)
19:44:24 <Lokathor> nybble, i'd make a sub-function that also takes a paramater for a depth limit that can call itself recursively
19:44:26 <Axman6> nybble: what does Tree look like? if it's acutall infinite, then you have no choice how many branches you take right?
19:44:39 <Zemyla> But yeah, I wish I could lift runST inside a wrapper monad.
19:45:16 <ski> exio4 : it can be fun, yeah :)
19:45:34 <arkeet> Zemyla: there's a ST transformer, STT. is that maybe what you want?
19:45:35 <ski> f|`-`|f : some of it is
19:45:50 <Zemyla> @hoogle STT
19:45:52 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
19:45:52 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
19:45:52 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
19:45:56 <Axman6> STT IO a <- win
19:45:58 <arkeet> it's in package STMonadTrans
19:49:18 <nybble> Axman6: this is how I implemented the tree add :: Tree -> Tree add (Node n l r) = Node n (add (Node (n + 1) Empty Empty)) (add (Node (n + 1) Empty Empty))  infinitree :: Tree infinitree = add (Node 0 Empty Empty)  If it's actually infinite how come I wouldn't have any choice? What if I only want like the root and  the next two nodes out of that? instead of all the subtrees?
19:49:48 <RageD> carter: Eureka. I like when things "just work" :) thanks!
19:52:30 <Axman6> nybble: if data type is actually infinite (data Tree a = Node a (Tree a) (Tree a) - notice no Empty constructor), then you have no choice. you happen to have an infinite instance of a tree which doesn't have to be infinite. anyway, that's a digression. how do you want to select which elements are returned?
19:55:28 <samba1> can someone look at this for me please? http://lpaste.net/7184197478260932608
19:57:17 <nybble> Axman6: Ohhh..I get it. The instance of my tree is infinite but the data type isn't! I want to just give a number x as an argument to ttake and get the whole tree up to that depth, I think similar to what Lokathor was saying
19:57:32 <carter> Axman6: you could use unsafePtrEquality tricks though:)
19:58:35 <Axman6> nybble: so you want to just go to a certain depth and not a certain number of elements? That's very simple =)
19:58:44 <Axman6> nybble: so what have you tried so far?
19:59:51 <ski> samba1 : "will stillMore be executed because of the pattern match above?" -- yes
20:00:06 <ski> samba1 : would it be possible for you to use a state monad instead of `IO' ?
20:01:16 <ski> nybble : what should `ttake' and `add' do ?
20:01:19 <samba1> ski: say no, the functions are calling the database and parsing Foos out of rows
20:03:56 <newsham> https://github.com/Geal/nom_benchmarks
20:04:03 <newsham> attoparsec vs. nom
20:04:05 <nybble> Axman6: well, I thought that maybe writing something like a helper to just get the head or the left node or right node might be a good place to start...but I'm getting errors..
20:04:17 <ski> samba1 : perhaps you could use `unsafeInterleaveIO' .. however, it may be tricky to control exactly how many database interactions and parsing will be performed using this (and if you get an exception/error/unexpected result you won't be able to handle it in a nice way, and perhaps not cleanup actions either)
20:05:29 <ski> samba1 : if you use an exception monad on top of `IO', you could possibly abort the execution in that as soon as you reach your maximum
20:06:42 <ski> samba1 : there's also various "pipes" libraries for controlling more exactly computations involving I/O that will result in a sequence of results, that you want to interleave with other processing code -- i haven't looked much into such
20:07:00 <samba1> ski: okay. or i could do state inside io maybe. in general though i feel like there's something there, like i should be able to hide away that combining and short circuiting like monads do, but it's not parameterized so i can't. is there something else i'm looking for?
20:07:42 <nybble> ski: add just creates an infinite tree where the value of the leaves of every node are + 1 more than the parent node
20:08:01 <ski> samba1 : obviously a very simple approach here would be to just pass down a number parameter that says how many more results are wanted at most. but presumably you wanted some way of hiding the plumbing of such
20:08:10 <nybble> ski: ohhhh, I could use the value to find the depth! right?
20:08:31 <ski> nybble : which value ?
20:09:03 <ski> samba1 : i wouldn't be surprised if one the the pipe things has something specifically for your use case ..
20:10:00 <samba1> ski: yes, and this is a simplified example, maybe instead of length it's something else that influences future action... a maximum, or I want to stop when the list has some known value in it (but want to keep things up to that point). it feels like a monad. maybe i should just use state, but it feels like theres a pattern i'm missing
20:10:16 <nybble> ski: the value of a particular node? since all the leaves of the tree at a particular level have a value that is one greater than their parents value
20:10:27 <samba1> ski: maybe i'll look at pipes, but i'm just starting and those libraries look very advanced for me
20:10:52 <samba1> ski: or even if they're easy to use without understanding maybe, i want to be able to make this myself
20:10:54 <Lokathor> samba1, the trick is that every Haskell library is very advanced :3
20:10:56 <Lokathor> gotta dive in
20:11:50 <ski> samba1 : your best bet there is probably either to find someone who's familiar with the library, or failing that, enough explanation in docs or blags to be able to figure out how to get started and to carry on
20:11:51 <samba1> Lokathor: yes, but more than using the library i want to understand the pattern
20:12:29 <samba1> i understand monads and monoids, but things i make never quite fit into them
20:12:30 <nybble> ski: oh, but that would only work for this particular tree perhaps?
20:13:02 <ski> samba1 : anyway, iiuc, there is no clear consensus yet which (if any) of these libraries are the "best". they're exploring different conceptions of how to do it. some can do more, others can do less, some don't have quite the same aims
20:13:03 <Lokathor> I find that throwing out something until it compiles, and then looking back to see how i did it, is often how things work out
20:13:21 <samba1> it's not that i'm worried i can't use the library, i can figure it out, i just wish i could make things neat like the core libraries are
20:14:06 <ski> (practice. and contemplation. probably discussion as well)
20:14:08 <Lokathor> ah. That's tricky, and the parts fall into place once you've got enough parts in your head.
20:14:28 <ski> (exposure to various things helps as well, yes)
20:15:42 <augur> what happens with Aeson and sum types?
20:15:43 <samba1> like instead of Foo, i feel like i could do data LimitedList a = LimitedList [a] Int
20:15:49 <samba1> which could maybe be a monad
20:15:59 <augur> like.. if I define   data Foo = Bar | Baz   what will this encode into JSON as?
20:16:30 <Lokathor> don't you need to provide an instance yourself anyway?
20:16:31 <samba1> and I could use >>= to short circuit
20:17:24 <Lokathor> samba1, i don't know what your LimitedList is representing with that Int... the maximum size?
20:17:32 <samba1> but in my case the second part is the interesting part, not the first
20:17:47 <samba1> Lokathor: the current size in the example i gave, but that's just a made up example
20:18:20 <samba1> maybe instead if a is bounded it keeps track of the minimum a so far
20:18:26 <Lokathor> well you could define most things for list on limitedlist as well i suppose
20:18:30 <ski> samba1 : hmm. perhaps i'd try `Int -> [a]' instead there
20:19:22 <samba1> that's easy to do, the minimum, and maybe i want to short circuit when the minimum is = minBound
20:19:52 <ski> (so given a `LimitedList a', you'd have to tell it the limit before it computes a list with length no more than that)
20:21:05 <augur> ahh interesting -- Aeson encodes a boring sum like   data Foo = Bar | Baz   as strings, but encodes more interesting sums as objects with tags
20:21:09 <augur> neat!
20:22:05 <samba1> ski: what is Int -> a? the value inside LimitedList?
20:22:43 <peddie> augur: you can configure how it encodes sums (http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-TH.html#t:SumEncoding)
20:22:49 <ski> samba1 : yes i meant as `data LimitedList a = MkLimitedList (Int -> [a])' (or with `newtype' instead of `data')
20:23:40 <ski> samba1 : so, yes. inside it'd be a function that waits to be told the actual limit before proceeding
20:24:15 <huckleberry78> https://gist.github.com/vallasd/d15ca29f9913d79076d1 trying functional programming with swift, running into this issue
20:24:39 <huckleberry78> I really want to pass object as Self, but swift isn't letting me do this...  When I cast the object, it seems to still be saving it to UniqEntity instead of the subclass.  Any suggestions
20:24:46 <samba1> ski: i don't know how i'd use that
20:25:16 <samba1> ski: make a runLimitedList that takes an int and then calls `take n`?
20:25:25 <augur> huckleberry78: perhaps the swift channel is a better place to ask :)
20:25:32 <Axman6> huckleberry78: not sure what that has to do with Haskell?
20:25:37 <ski> samba1 : the list itself will keep track of its length. you could use `length' if you want to know it
20:25:52 <augur> peddie: neat. im not really concerned with what it chooses, i just wanted to make sure it could do it :p
20:25:57 <ski> samba1 : in your `Monoid Foo' example, you had hardcoded a `5' as the limit. with my version, you don't need to hardcode it
20:26:10 <huckleberry78> thought that there may be some cross programmers that are running into similar issues when implementing swift
20:26:22 <samba1> ski: yes, but if i want to not do IO once it's reached the limit
20:26:31 <Axman6> implementing swift?
20:26:33 <samba1> ski: or not do something, whatever it is
20:26:38 <ski> samba1 : now .. one could perhaps make a monad transformer out of this, hmm
20:26:46 <huckleberry78> coding in swift
20:27:12 <Axman6> I don't think many people in here are coding in Swift
20:27:25 <Axman6> you might find #macdev a better place to ask
20:27:45 <Axman6> the things you appear to be doing seem quite unhaskell like afaict
20:28:09 <mmachenry> I installed a bunch of libraries for my project into a sandbox. I want to install the documentation so that when I "cabal haddock" it don't get warnings that it's not there. cabal install—enable-documentation —reinstall doesn't work because it's all already installed. How can I do this?
20:28:34 <mmachenry> Is there a way to do it without deleting all my libraries
20:29:07 <Lokathor> i was about to say "yes it's easy", until that second line
20:29:29 <Lokathor> i think there's a flag like --force-reinstall, is that the one you used?
20:32:35 <mmachenry> Oh let me try
20:33:32 <mmachenry> I tried that. They don't reinstall
20:46:26 <bramgg> Can I get the iteration number within a mapM_ function?
20:47:04 <shachaf> You can mapM_ f . zip [0..]
20:47:22 <bramgg> shachaf: beautiful, thanks
20:49:58 <Javran> just noticed map and zipWith are the same thing in lisp
20:50:45 <glguy> With lens there is imapM_
20:51:15 <HeladoDeBrownie> glguy, of course lens would have a dependency on an email program, of all things /s
20:51:54 <Javran> :t imapM_
20:51:55 <lambdabot> (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()
20:52:18 <Javran> wow nice, the typeclass explains it
20:53:12 <shachaf> :t imapMOf_ traversed
20:53:13 <lambdabot> (Traversable f, Monad m) => (Int -> a -> m r) -> f a -> m ()
20:56:18 <shachaf> zipWithN :: (HList ts -> r) -> HList (Map [] ts) -> [r]
21:03:56 <nybble> Haha silly me, I just figured out how to do what I was trying to do! (I was making it way more complicated than it needed to be...) thanks Axman6, ski, Lokathor, cmccann for being so welcoming! It's like having all this moral support helped me figure it out!
21:05:04 <Axman6> no worries. Just remember in the future that the more info you can provide to us, the more we can help. pasting code on somethinbg like lpaste.org is usually a fantastic start
21:06:18 <nybble> ski: btw irc is really cool, are there any particular clients you would suggest for a beginner?
21:06:52 <nybble> Axman6: Yes, next time i'll do that! :) Thanks!
21:09:23 <ryanar> hello everyone
21:12:09 <Axman6> hello ryanar 
21:13:35 <ski> nybble : for windows, you could try X-Chat (don't get it from <http://xchat.org/>, iirc that Windows version is nagware. try instead <http://www.silverex.org/download/> (hm, seems to be not updated anymore, try <http://hexchat.github.io/downloads.html> as it suggests ?)) or perhaps mIRC
21:13:58 <glguy> nybble: It depends on what OS you're using and if you prefer GUI or console applications
21:14:32 <ski> nybble : on a *nix, X-Chat should be fine. there's also lots of others that people use. if you prefer a terminal-based client, you could e.g. try Irssi
21:15:15 <ski> (on Mac, i dunno what's popular. probably many of the typical *nix ones would work there as well)
21:15:24 <glguy> Textual is nice on OS X
21:17:05 <nybble> lol ok, I'll look into those thanks!
21:17:56 <ski> (perhaps one of the versions in the archive at the <www.silverex.org> site would still work, even if not the most recent. i dunno)
21:19:45 <dolio> hexchat is more current for windows (still developed).
21:19:50 <dolio> Luckily that page links to it. :)
21:20:20 <ryanar> hexchat is nice
21:20:20 <glguy> There's always glirc ;-)
21:20:50 <Axman6> i imagine that's an IRC client implemented entirely in OpenGL
21:21:22 <flounders> Konversation works pretty well for KDE.
21:21:41 <Axman6> irssi works pretty well for anything that has ssh =)
21:24:52 <apo> and a keyboard
21:25:02 <apo> using irssi without a real keyboard is a bit of a pain
21:25:08 <Axman6> yes, that is also fairly important
21:25:10 * HeladoDeBrownie used to use irssi but now uses glowing bear with weechat, and has not noticed it missing any features
21:25:21 <johnw> I was about to say that this is offtopic, but everyone in this discussion would know that :)
21:25:47 <Axman6> not a whole lot of on topic discussion going on at the moment anyway
21:26:26 <HeladoDeBrownie> i think usual etiquette is that offtopic is okay as long as it doesn't get out of hand and we go back on-topic if someone requests or if an on-topic discussion comes up
21:26:49 <johnw> but some may not ask if they see an active discussion going on, feeling they will interrupt it with their Haskell question
21:26:58 <HeladoDeBrownie> that's a good point
21:27:22 <ski> nybble : btw, if you feel like it, you could paste your current version of `ttake',`add' and so on, and perhaps we could come with some suggestions regarding it ..
21:27:23 <Axman6> I feel that is related to the don't ask to ask, just ask idea
21:27:31 <HeladoDeBrownie> oh, what i said was ambiguous; when i said "someone requests" i meant "someone requests that the conversation go back on-topic".
21:27:39 <HeladoDeBrownie> which indeed happened.
21:27:45 <johnw> :)
21:27:56 <glguy> Guys, this topic discussion is off-topic, take it to #haskell-ops ;-)
21:28:01 <ski> HeladoDeBrownie : when ?
21:28:09 <Axman6> ironically, you making that point has lead to another off topic discussion
21:28:19 <HeladoDeBrownie> ski, well, it was implied by johnw i guess.
21:28:34 * HeladoDeBrownie backs out
21:28:43 * ski forwards in
21:40:57 <ianjneu> is there a cheat sheet for all the notations? I've yet found a way to determine the type of <$> or what it does. Can't search for punctuation.
21:41:15 <ski> @type (<$>)
21:41:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:41:22 <Javran> ianjneu: try wrapping it with parens
21:41:35 <Javran> @hoogle (<$>)
21:41:37 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
21:41:37 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
21:41:57 <ianjneu> Javran: gotcha. The question still stands for other common notations.
21:42:15 <flounders> ianjneu: ghci is very helpful for these things. With infix functions you do need to wrap them in parens in order for :t to work.
21:42:16 <ski> ianjneu : in GHCi, `:t (<$>)'
21:43:44 <Axman6> ianjneu: which 'notations'?
21:43:55 <jle`> ianjneu: there's syntax, and then there's operators...operators are just normal functions
21:43:58 <jle`> :t (+)
21:43:59 <lambdabot> Num a => a -> a -> a
21:45:34 <ianjneu> Pardon, operators. Notation is a separate issue.
21:47:40 <nybble> ski: Thanks, but there probably isn't much to suggest. It was just a short exercise for school and actually in retrospect pretty simple. (The part I was asking about was optional) I'll probably be back with other questions soon though!
21:48:06 <jle`> ianjneu: all operators you can look up on ghci if you have them in scope (imported)...also, you can search for operators on hoogle and hayoo
21:48:10 <jle`> @where hoogle
21:48:10 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
21:48:17 <jle`> @hoogle (<$>)
21:48:17 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
21:48:17 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
21:48:33 <jle`> it'll tell you the type, and what package/module offers the operator
21:51:57 <Lokathor> why does: cabal install sdl2 --extra-lib-dirs=C:\SDL2-2.0.3\include --extra-include-dirs=C:\SDL2-2.0.3\lib\x86
21:51:58 <Lokathor> work?
21:52:18 <Lokathor> why does --extra-lib-dirs= have the include path, and the --extra-include-dirs= have the libs?
21:52:21 <Lokathor> why oh why
21:52:54 <Axman6> ... that doesn't look right at all, where is that from?
21:53:10 <Lokathor> a guide i read about installing sdl2 on windows
21:53:32 <Lokathor> the damning thing is that (as the final step in a list of steps, that is) it absolutely does work and let you install sdl2
21:53:49 <Lokathor> but the include and lib directories sure do seem to be backwards
22:24:16 <ianjneu> programmatically printed expressions + indentation sensitivity = :(
22:25:21 <Azel|3> It's possible to write Haskell code which isn't sensitive to indentation though, trankfully
22:25:34 <ianjneu> Azel: how?
22:26:27 <ianjneu> my emacs buffer refuses to insert a line break because I've reached max eval depth. What.
22:26:52 <pavonia> ianjneu: How are you printing the values? The pretty-printing libraries usually do a good job at that
22:27:51 <Azel> You'd use braces at the beginning of blocks and semicolons in place of line breaks. Let me see if I can find a ref on that in the wiki. If not, it's described in the report but well…specs are usually quite dry.
22:27:53 <ianjneu> pavonia: I have a function in Racket that crawls over an s-expression and prints the haskell term constructor
22:31:59 <Lokathor> do {line1 ; val <- line2; thing val} and so on
22:34:20 <pavonia> > let { f x = case x of { x | odd x -> "foo"; _ -> "bar" }; x = 10 } in f x
22:34:21 <lambdabot>  "bar"
22:36:19 <Azel> And the last keyword after which you can put braces for layout-insensitive code is where, like thus: case s of {r -> i r where {i x = x}} 
22:37:23 <Azel> If you don't mind going to the report, it's described in section 2.7 here: https://www.haskell.org/onlinereport/lexemes.html#lexemes-layout
22:42:37 <nybble_> Can someone explain why I would get a parse error when I do p3 == p4 in a haskell repl but when I do (==) p3 p4 its fine? I've posted a short snippet of code here: http://lpaste.net/122557 (probably better in #haskell-beginners but it seems dead atm)
22:43:51 <Axman6> nybble_: where are you getting a parse error?
22:44:54 <nybble_> Axman6: I'm using sublime and the line it gives me is a line that doesnt even exist in the file. Like it only goes to line 57 but its giving me an error at line 105
22:45:47 <Axman6> that sounds unlikely... make sure you're looking at the right file
22:48:22 <pavonia> nybble_: What REPL are you using, ghci?
22:50:15 <nybble_> pavonia: SublimeREPL I think... it's a plugin to sublime
22:50:47 <nybble_> pavonia: ya ghci
22:53:37 <jle`> i don't see why it would be a haskell problem...it works fine in ghci...it must be a problem with the sublime plugin
22:56:47 <nybble_> jlc`: oh mannn... you are right it works when I try it outside of sublime... I spent like hours trying to figure this out..man I should go to sleep. Thanks
23:00:24 <dmj`> in core what does [Occ=Dead] mean?
23:01:54 <ski> nybble_ : ok
23:04:14 <shachaf> dmj`: Unused variable.
23:04:41 <dmj`> shachaf: thanks, how did you come to know that?
23:05:17 <shachaf> dmj`: I searched for "Occ=" in the GHC sources and then read the definition of OccInfo in BasicTypes.hs
23:05:55 <dmj`> shachaf: I see, thanks
23:07:04 <Zemyla> Hmm. Has any progress been made toward strictifying GHC to reduce memory usage?
23:08:15 <dmj`> Zemyla: https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
23:09:23 <quchen2> I wonder what a good name for Reader's >>= operation would be if there had to be a non-monad-polymorphic synonym. "withEnvironmentApply" comes close, but it doesn't feel very good.
23:10:08 <Hijiri> passRelay
23:10:14 <Hijiri> Stick
23:10:17 <Lokathor> would it still be intended as infix or would it be generally prefix? that affects the language you pick somewhat perhaps
23:10:45 <Zemyla> dmj`: So I should recompile ghc with -XStrict?
23:11:06 <quchen2> It would be prefix, Lokathor.
23:11:39 <quchen2> Well, depends on how you view "prefix". It will be between a monadic value and the function to be bound.
23:11:42 <shachaf> Why do you think "strictifying GHC" is the best way to "reduce memory usage"?
23:11:51 <dmj`> Zemyla: I think it's still just a proposal
23:12:00 <quchen2> a.foo(b) -- something between pre- and infix.
23:12:04 <Zemyla> Well, okay, I'm honestly not sure.
23:12:16 <dmj`> Zemyla: "strictifying" seems to do with evaluation, not allocation
23:12:22 <Zemyla> But something has to be done. The amount of memory GHC usss is absurd.
23:12:47 <quchen2> Zemyla: head [1..10^9] uses a lot less memory if you're non-strict.
23:13:26 <Zemyla> shachaf: I was actually wondering, though, if the compiler was holding on in places to unevaluated thunks containing old code that could be cleaned up.
23:13:34 <Lokathor> quchen2, i mean how you'd write it down on the page. for example, elem is generally used infix as `elem` instead
23:14:13 <ski> quchen2 : `environmentBind' i suppose
23:14:25 <dmj`> Zemyla: you can modify ghc's garbage collection settings
23:14:56 <Zemyla> Oh?
23:15:38 <quchen2_> ski: The problem with that is that "bind" is a very non-descriptive name if you're not familiar with monads.
23:15:54 <platz> Zemyla: I thought the high allocation was somewhat mitigated by way GC was tuned so it's released quickly as well
23:16:14 <jle`> laziness has helped my performance/memory usage in haskell a *lot* more times than it has hurt
23:17:12 <jle`> i've spent so much time hunting down unnecessary strictness ;_;
23:21:39 <dmj`> Zemyla: do you have specific code where memory usage is an issue?
23:22:55 <Zemyla> dmj`: I cannot update cabal. It runs out of memory,
23:23:01 <Zemyla> That is my issue.
23:24:04 <Hijiri> sometimes I get the issue when I'm installing lens with lots of jobs
23:24:15 <Hijiri> and if I'm already low on memory
23:24:47 <lfairy> I think GHC is kinda doomed to use lots of memory
23:24:57 <lfairy> it's the cost of having such a high-level language
23:25:34 <bloot> haha yeah
23:25:42 <bloot> try compiling ghc on a low memory system :)
23:25:47 <bloot> It won't work :)
23:25:48 <platz> it's the cost of immutability.  scala has same problems on mobile
23:25:53 <dmj`> Zemyla: if my package db is old the cabal process will get up to 300MB sometimes (eyeballed with top), but I have memory to spare, how much do you have?
23:28:27 <Zemyla> It's an Amazon EC2 instance.
23:29:33 <bramgg> must one use newlines to seperate functions in a "do" block?
23:30:00 <Hijiri> sometimes I'll ctrl c and restart cabal to get back memory
23:30:10 <dmj`> Zemyla: micro right? 
23:30:37 <dmj`> Zemyla: cabal always gave out on me when I used it on micros 
23:31:22 <dmj`> the ones with 256MB/512MB RAM
23:32:26 <pavonia> bramgg: What functions?
23:33:23 <pavonia> I have the same problem with cabal lately. Without killing other processes, I can hardly build any cabal project :/
23:33:29 <Zemyla> dmj`: Yep.
23:33:41 <bramgg> pavonia: I'd like to add multiple HTML elements with BlazeHtml on one line, but they seem to need to be in a do block
23:34:01 <dmj`> Zemyla: try small
23:34:28 <pavonia> bramgg: You don't need a do block, you can also use (>>=) directly
23:35:26 <dmj`> Zemyla: or, you could use circleci to build it for you, for free, then push your binary straight to amazon from there. Not sure what your setup is though
23:36:08 <akegalj> Zemyla: you could introduce disk swap space (I used to compile things on digitalocean before, 512MB). It took some time, but with SSD its ok.
23:36:44 <Zemyla> dmj`: I just have a little EC2 instance for IRC and Haskell and stuff, because my normal computer died and I can ssh to it from my tablet.
23:37:52 <dmj`> i see
23:42:17 <Javran> I've cloned & compiled ghc, how can I build the tarball file like those found in https://www.haskell.org/ghc/download ?
23:42:32 <bob_twinkles> bramgg: you can either use >>= or >> directly as pavonia suggested or have something like do { addElem1; addElem2 }
23:44:32 <bloot> Can you benchmark IO functions with criterion?
23:45:21 <bramgg> thanks pavonia & bob_twinkles 
23:47:02 <bloot> also I wish trace were recursion depth aware
23:47:22 <shachaf> What is recursion depth?
23:47:33 <bloot> or "nesting" depth
23:47:35 <bloot> well
23:47:49 <bloot> f x = trace "f" $ g x; g x = trace "g" $ id x
23:47:52 <bloot> prints
23:47:54 <bloot> f
23:47:54 <bloot> g
23:48:02 <bloot> I'd love for it to print something like
23:48:05 <bloot> f
23:48:08 <bloot>  g
23:48:19 <Cale> f x = trace "f" $ g x; g x = trace " g" $ id x
23:48:29 <Cale> :D
23:48:31 <bloot> Cale: that's wrong
23:48:35 <bloot> then g 5 would print
23:48:37 <bloot>  g
23:48:38 <bloot> rather than
23:48:39 <bloot> g
23:48:41 <Cale> (I'm joking)
23:48:45 <bloot> I hope so :D
23:49:06 <Haskellfant> does anybody know why Interal from the intervals packages is no longer a functor? I found a package that relies on that and I'm trying to update it.
23:49:22 <bloot> also it would need to be thread aware as well
23:49:26 <Cale> There's a problem though, when g is evaluated, there's nothing on the stack.
23:49:32 <Haskellfant> the instance is trivial: fmap f (I a b) = I (f a) (f b)
23:49:44 <Cale> The "depth" you're talking about isn't a real thing
23:50:09 <haasn> Haskell evaluation can be “out of order”, depending on when things are forced
23:50:25 <Zemyla> Haskellfant: Because it kind of needs Ord in order for that to work.
23:50:28 * hackagebot yesod-bin 1.4.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.4 (MichaelSnoyman)
23:50:28 <Cale> Well, even just with plain lazy evaluation
23:50:53 <Cale> With profiling turned on, perhaps something could be provided to give the stack of cost centres which are active
23:51:32 <bloot> http://codepad.org/gpn1KWuV
23:51:43 <shachaf> It can hardly be out of order when there's no order to it in the first place.
23:51:43 <Haskellfant> Zemyla: ah right, I just need to work around that then, thx
23:51:45 <bloot> It would have been nice to have it show correct indentation
23:52:27 <bloot> but Ok. I would have to program that myself I guess :)
23:53:05 <platz> -61-139.washdc.fios.verizon.net [James Curbo]
23:53:06 <platz> -!-    #hakyll seagreen  H   0  ~seagreen@gateway/shell/ncsu/x-agisibumgnauggts [seagreen]
23:53:08 <platz> -!-    #hakyll honestly  G   0  ~luke@unaffiliated/luketheduke [Luke]
23:53:11 <platz> -!-    #hakyll acomar    G   0  ~acomar@pool-108-28-109-83.washdc.fios.verizon.net [Arjun Comar]
23:53:14 <platz> -!-    #hakyll felixsch  G   0  ~felixsch@2a00:dcc0:eda:3754:247:55:6e8a:1dfa
23:53:21 <platz> ah sorry
23:57:19 <bloot> maybe I can put a state monad over it
23:57:21 <bloot> and then hm.
23:57:54 <bloot> or otherwise
23:57:59 <bloot> Is there some way to get GLOBAL state
23:58:05 <bloot> without having a function parameter to carry around
23:58:13 <bloot> i.e. IORef obviously won't work
23:58:17 <bloot> named pipes
23:58:22 <bloot> hm
23:58:41 <Hijiri> global mutable state?
23:58:55 <bloot> kinda like uhm foo = do { q <- getState "huhu"; putState "huhu" (q+1); }
23:58:58 <bloot> Hijiri: yeah
23:59:11 <Hijiri> there are some hacks using unsafePerformIO and IORef
23:59:14 <bloot> foo :: IO ()
23:59:22 <bloot> yeah but I'd need to carry around IORef
23:59:36 <Hijiri> no, it involves unsafePerformIO to get top-level IORefs
23:59:38 <bloot> as in foo x = do { q <- readIORef x; }
23:59:44 <bloot> Hijiri: oh. that works?
