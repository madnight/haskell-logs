00:21:23 <lolisa> Hello, I wonder whether inverse of isomorphism in a category is unique, is it the case?
00:21:37 <shachaf> It is the case.
00:22:32 <lolisa> How can I prove it in Coq? Do I need anymore axiom of modification of Category Rule(add one beside compose assoc, compose unit_l and compose unit_r
00:24:13 <shachaf> I don't know Coq. Maybe #coq would be able to tell you that.
00:24:33 <shachaf> The proof is pretty straightforward. For some arrow f, let g and g' be inverses of f, and show that they're equal.
00:25:59 <lolisa> shachaf, you don't have to show me how to do it in Coq, I just want to know how to prove it...
00:26:25 <lolisa> shachaf, so I need an axiom of compose extensionality?
00:26:34 <shachaf> I don't know what that is.
00:27:18 <shachaf> If it isn't clear, it might be simpler if you prove it for a monoid first.
00:27:18 <lolisa> So I need an axiom which show that if, for two arrow A -> B, composing them with the same arrow will return the same thing, they are the same?
00:27:31 <shachaf> No, that's not an axiom.
00:27:43 <lolisa> Need something sort of like function extensionality?
00:27:46 <shachaf> I'm just saying how to prove something is unique. :-)
00:28:07 <lolisa> I know, but do I need axiom to help me prove it :)
00:28:50 <shachaf> What have you proved so far?
00:28:56 <shachaf> Have you proved that identity arrows are unique?
00:29:22 <lolisa> No... I haven't prove anything about uniqueness yet
00:30:07 <shachaf> OK. I can't help you with Coq. #coq might be able to.
00:30:25 <shachaf> But my suggestion to figure this all out with monoids stands.
00:30:43 <lolisa> OK, thankyou
00:31:07 <shachaf> I don't think you need any extra axioms.
00:32:10 <lolisa> I got one telling me how to prove it in monoid, thankyou, I think I am fine now. Thankyou verymuch :)
00:42:16 * hackagebot IPv6Addr 0.6.0.1 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.6.0.1 (MichelBoucey)
00:48:23 <lolisa> thankyou, I got it
01:30:55 <safinaskar> how to kill haskell program if it starts to eat a lot of memory?
01:30:59 <safinaskar> gnu/linux, ghc
01:31:17 <safinaskar> or how to start haskell program in some restricted environment
01:31:26 <safinaskar> which will kill it if it starts to eat memory?
01:32:20 * hackagebot epic 0.9.3.3 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.9.3.3 (AndreasAbel)
01:33:00 <peddie> safinaskar: you can adjust the heap and stack sizes that your program is allowed using the GHC RTS options
01:33:29 <peddie> safinaskar: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#setting-rts-options
01:35:16 <safinaskar> peddie: thanks
01:35:23 <lf94> what is the 2nd best haskell compiler next to ghc?
01:45:56 <ttt_fff> in haskell, what is the most optimal way to (1) while streaming a file in, (2) calculate it's sha256 sum, and (3) store the jpeg, with sha256 as the filename
01:51:24 <arkeet> store what jpeg?
01:52:21 <ChristianS> ttt_fff: you could store it using an temporary filename, and then rename once the file is complete and you have its checksum
01:52:50 <ttt_fff> ChristianS: how do I get a temporary file name?
01:53:56 <ChristianS> ttt_fff: well, however you want. maybe there are functions for that in the directory package, i don't know
02:00:35 <arkeet> on unix there's a mkstemp function
02:00:55 <arkeet> for making a temporary file
02:01:31 <arkeet> not sure about the best cross-platform way to do it 
02:03:42 <arkeet> but using a temporary filename and renaming after is the only way to go that I can think of.
02:06:18 <ChristianS> well, the alternative would to be read the whole file into memory and write it to disk only once it's complete
02:10:34 <alpounet> i think there's a function for that somewhere indeed
02:12:01 <alpounet> https://hackage.haskell.org/package/temporary-1.2.0.3 there you go
02:13:03 <ttt_fff> in haskell, what is the simplest webserver (i.e. lowest level) taht lets me do "zerocopy' file upload from the client to the webserver to the filesystem
02:31:45 <a3f> Is using Haskell for scripting worth investigating?
02:32:09 <a3f> I am writing a small bot for a game and looking what other choices than lua I got
02:34:12 <ChristianS> a3f: haskell is usually compiled these days. if that's acceptable, then it's probably a good choice.
02:36:19 <R0b0t1> I've not seen anything like a read-eval loop after I went looking for it. I believe Yi (https://wiki.haskell.org/Yi) supports code reloading, so if you were interested you could check how it does it.
02:36:36 <a3f> ChristianS Currently, the bot has an ingame terminal where one can write simple commands like say "Hello", move x y z. Adapting this for lua is very straight forward. I wonder if there is some work done to give Haskell the same capability
02:36:53 <a3f> For that reason I don't think compilation would work
02:37:26 <a3f> I just stumbled upon this: http://hackage.haskell.org/package/hint
02:39:35 <ChristianS> a3f: didn't know that package, but it looks suitable
02:40:50 <R0b0t1> oh hey
02:45:48 <a3f> hey
02:55:34 <Kensan> Hello
02:56:16 <Kensan> I have very little prior exposure to functional programming and am thinking about learning both Haskell and Ocaml. Are there reasons to learn them in a particular order, e.g. Haskell then Ocaml or the other way around?
03:01:50 <jle`> Kensan: I don't believe so
03:02:30 <jle`> on the surface the two have similar syntax, superficially, but if you go just a little deeper the two languages have fundamental differences that make their usage and idoms diverge drastically
03:02:54 <jle`> it's more like two different roads from a fork than a "this is more advanced than that" thing
03:04:35 <jle`> up to a certain point, learning one will help you learn the other; but past that surface level, things diverge quickly enough that you're basically learning two different languages.
03:06:26 <Kensan> jle`: Thank you for the comment. I certainly want to appear to be throwing both languages in the same bucket.
03:07:44 <kaidelong> Kensan: umm, probably OCaml first but, both of them are a little bit hard coming out of a prior background working with imperative languages
03:08:05 <ttt_fff> does anything in wai/warp/scotty handle file uploads, or do I have to handle this myself?
03:08:07 <jle`> i guess learning ocaml first, you don't have to learn about laziness
03:08:11 <kaidelong> Haskell has the advantage of being somewhat simple and consistent in its design, somewhat like Racket and Java
03:08:16 <Kensan> jle`: Could it be that one would pick up certain understanding or "image" of functional programming that could cause some confusion when learning the other language?
03:08:44 <kaidelong> Kensan: if you're coming out of .NET look at Nermerle or F#, they're both in the ML family and are more accessible than OCaml is
03:08:59 <kaidelong> there's also SML.NET
03:09:17 <kaidelong> Java world has Scala or Clojure but I can't vouch for either of them
03:09:31 <Kensan> kaidelong: I have been doing a lot of Ada/SPARK with some C/C++ "on the side" the past years.
03:09:54 <kaidelong> C++ can be used as a functional language so googling how to do functional programming in C++ would be another way
03:10:27 <kaidelong> however it's verbose, unreadable, and arcane
03:10:55 <kaidelong> OCaml and Haskell are probably both solid options for you
03:10:58 <kaidelong> then
03:11:01 <Kensan> kaidelong: I am not so fond of the C family of languages and I want to pick up something "new".
03:12:21 <kaidelong> Haskell is a solid way to introduce yourself to functional programming because it pushes the paradigm pretty far into everything (at the cost of not being able to cleanly mix the two as well as ML programmers do all the time)
03:12:49 <arkeet> I think that would be a good reason to pick haskell first.
03:14:05 <kaidelong> whether or not you'll like it better than OCaml depends on the company you keep and how much you value structural typing vs purity + higher kinds
03:14:59 <Kensan> I see.
03:15:00 <kaidelong> if your friends are not already using functional programming you're probably going to find better community support for Haskell
03:15:12 <kaidelong> so I would go with that
03:16:40 <kaidelong> Haskell and OCaml are more similar than they are different, especially with regards to their deficiences (spare library ecosystem, little documentation, poor tool support, poor editor support)
03:16:59 <kaidelong> deficiencies, sparse
03:17:03 <Kensan> arkeet: So you think one is more likely to focus on the functional paradigm than trying to solve problems with an "imperative mindset"?
03:17:21 <arkeet> yes.
03:17:40 <kaidelong> Kensan: well it's about more than just that, because of that other people have implemented libraries that makes the functional paradigm way possible/palatable
03:17:53 <kaidelong> wheras in OCaml the libraries may expect you to work with them imperatively
03:18:15 <Kensan> kaidelong: Ok, I do not worry too much about ecosystem and libraries. It is a similar situation with Ada.
03:18:44 <jle`> well, the libraries you use will determine how you solve and approach problems :)
03:18:51 <kaidelong> whether or not this is a good thing is debatable, I'm personally of the opinion that it's better to have a functional interface for imperative stuff like with Haskell
03:18:54 <Kensan> Interesting point.
03:19:26 <kaidelong> the counter-argument is that some problems really are expressed better imperatively and mixing paradigms should carry as little overhead as possible
03:19:52 <kaidelong> I disagree with this because I think Haskell demonstrates that the overhead of "embedding" imperative into functional is pretty low overhead and not worth worrying about
03:20:42 <kaidelong> although there is room for improvement
03:22:06 <Kensan> ok.
03:22:41 <Kensan> Thanks for the thoughtfull input.
03:24:33 <kaidelong> Going to say Haskell for your case, anyway
03:37:30 <safinaskar> how to debug haskell programs? something like visual debugging (as in visual studio) or at least gdb-like will be perfect
03:41:00 <Axman6> safinaskar: that's easier said than done in haskell. GHC has a debugger, but the way haskell is evaluated can make debugging difficult
03:41:51 <Axman6> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
03:46:36 <f-a> I am using optparse to parse command line arguments. Does anyone know which function to use for args which can be repeated multiple times?
03:46:52 <safinaskar> Axman6: thanks
03:46:58 <f-a> as in `command -a foo.txt -baz -a bar.jpg`
04:00:10 <utdemir> Hey. I just installed GHC 7.10.1 and removed `import Control.Applicative` from my code since I only used (<$>). But I get `Not in scope: ‘<$>’`. `ghc-pkg list` shows "base-4.8.0.0" correctly. Can you tell me why I can't use `(<$>)` from Prelude?
04:08:36 <hvr> utdemir: what does `ghc --print-project-git-commit-id
04:08:38 <hvr> say?
04:09:31 <hvr> utdemir: also, do you have any `import Prelude ...` line which could hide the Prelude-re-exported <$> ?
04:10:15 <safinaskar> how to set max stack size in ghci?
04:20:49 <safinaskar> ahaha! using just "ghci" without any debugger (with :l) is easyier even than visual studio! because haskell has no state, so there is no need for stepping back. and any function performed twice will give same output
04:24:17 <kaidelong> satinaskar: I can't give you specific help but since no one else has answered, what you want is to enable "rtsopts"
04:24:25 <kaidelong> with that you can set max heap and stack sizes
04:27:29 * hackagebot hdocs 0.4.1.3 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.1.3 (AlexandrRuchkin)
04:57:31 * hackagebot fast-logger 2.3.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.3.1 (KazuYamamoto)
05:02:19 <kaiyin> https://github.com/albertoruiz/hmatrix/blob/master/examples/bool.hs#L10-L13  What does cond do here?
05:06:49 <Geraldus> Hi folks! How can I strip binary option to be configured for cabal project? I need to turn it off
05:14:37 <c_wraith> kaiyin: well, it's not defined in the file, and the file only has one import...
05:20:23 <Geekingfrog> How can I read a file inside a repl? readFile returns an IO String and I don't know how to extract the String from this IO
05:23:05 <hexagoxel> :t do { content <- readFile "abc.txt"; print content }
05:23:06 <lambdabot> IO ()
05:23:09 <hexagoxel> Geekingfrog: ^
05:23:41 <Geekingfrog> oh ok, I was missing the semicolon (and ended up using >>=)
05:23:58 <hexagoxel> (or putStrLn instead of print)
05:25:05 <hexagoxel> Geekingfrog: or `:set +m` to enable multi-line input in ghci
05:25:30 <hexagoxel> then you get the indentation-based parsing, without need for { ; }
05:26:58 <Geekingfrog> cool, thanks
05:37:33 * hackagebot wai-app-file-cgi 3.0.5 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.5 (KazuYamamoto)
05:46:07 <kaiyin> c_wraith: it seems to be defined in a C file: https://github.com/albertoruiz/hmatrix/blob/b16a9e8214832205537bec18a77ead03d3e05f51/packages/base/src/C/lapack-aux.c#L1468-L1489
05:47:33 * hackagebot language-lua 0.6.3.2 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.3.2 (OmerAgacan)
05:49:04 <kaiyin> :join #c
05:49:51 <ouanixi> Hi guys, I'm working on the cis194 lecture notes to teach myself Haskell and stumbled upon a function that I don't understand, I was wondering if anyone can help to shed a light
05:50:03 <ouanixi> foobar' :: [Integer] -> Integer
05:50:10 <ouanixi> foobar' = sum . map ((+2) . (*7)) . filter (>3)
05:50:23 <ouanixi> Where is the pattern matching on a list here ?
05:50:58 <sphaso> point free style
05:51:00 <Clint> ouanixi: no need for pattern matching
05:51:04 <c_wraith> ouanixi: every single one of sum, map, and filter can be implemented with pattern matching
05:51:23 <c_wraith> ouanixi: the important part is that they have the right types, not that they be the right syntactic form
05:52:00 <ouanixi> c_wraith: is it because they all need a list as input ?
05:52:26 <c_wraith> ouanixi: well, that and that filter and map also produce lists as output
05:52:34 * hackagebot github-utils 0.1.0 - Useful functions that use the GitHub API  http://hackage.haskell.org/package/github-utils-0.1.0 (RobinGreen)
05:52:48 <ouanixi> c_wraith: oh yes of course :)
05:53:33 <ouanixi> c_wraith: is this what sphaso called point free style ?
05:54:48 <c_wraith> ouanixi: it's an example of point-free style, but that's not *too* important.  It doesn't require pattern matching even if you name all the arguments
05:55:13 <ouanixi> c_wraith: I understand it now thank you.
05:57:34 * hackagebot hdocs 0.4.2.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.2.0 (AlexandrRuchkin)
05:59:30 <absence> is there (or can there even be) something like the Endo monoid for applicative functors?
06:02:35 * hackagebot mighttpd2 3.2.5 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.5 (KazuYamamoto)
06:05:41 <c_wraith> absence: in what sense?  You can easily have a Monoid instance that lifts another monoid into an applicative functor
06:06:57 <c_wraith> instance (Monoid a) => Monoid (SomeApplicative a) where mempty = pure mempty ; (mappend) = liftA2 mappend
06:07:14 <c_wraith> absence: or did you mean something else?
06:07:35 * hackagebot simple-log 0.3.2 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.3.2 (AlexandrRuchkin)
06:11:59 <absence> c_wraith: i haven't thought through it very carefully, but something like using mconcat to apply a bunch of arguments (like folding with <*>)
06:13:51 <c_wraith> absence: oh..  newtype LiftedEndo f a = LiftedEndo (f (a -> a)) ; instance (Applicative f) => Monoid (LiftedEndo f a) where mempty = pure id ; mappend = liftA2 (.)
06:13:56 <c_wraith> absence: like so?
06:14:56 <c_wraith> absence: err, plus the necessary newtype wrapping and unwrapping to get it to typecheck, of course
06:15:03 <absence> c_wraith: yes, i think so
06:15:20 <absence> c_wraith: it's not defined in any common library is it?
06:15:26 <c_wraith> not that I know of
06:16:46 <absence> c_wraith: ok, i'll play with it and see if it's useful, thanks :)
06:25:19 <mauris> hmm, i'm trying to do something tricky that i don't know if it will work. i think i need real dependent types for it, but i'm not sure; i don't know much about them
06:26:30 <mauris> i'm implementing some finite automata stuff and keeping track of the sets states and symbols as just types, and using universeF :: Finite a => [a] when i need to loop over them all
06:26:51 <utdemir> hvr, are you still here? i'm the guy asking missing (<$>) in Prelude?
06:27:08 <utdemir> hvr: ghc --print-project-git-commit-id is ca00def1d7093d6b5b2a937ddfc8a01c152038eb
06:27:55 <utdemir> hvr: And I got: `import Prelude hiding (appendFile, readFile, writeFile)` line, but I don't think this is about <$>
06:30:09 <mauris> now, I want to implement a conversion from regular expressions (Void | Literal a | Union (Regex a) (Regex a) | Concat (Regex a) (Regex a) | Star (Regex a)) to NFAs
06:30:21 <mauris> but this means i have to "construct" a type of all the states i'll need in advance
06:33:55 <mauris> http://userpages.umbc.edu/~squire/images/re2.gif this is how that works. i've eliminated the first base case since it's actually just Void Star
06:46:44 <mauris> but i guess something like this can never work: https://bpaste.net/raw/b5414d72f7ef
06:49:20 <mauris> and i guess what i would end up wanting is some kind of  regexToNFA :: Regex a -> NFA q a   where the type of q is dependent on the value passed in, somehow
06:52:08 <mauris> if the given "Regex a" is "Void", i make an "NFA () a". if the given "Regex a" is a "Literal a", i make an "NFA Bool a"  with a non-accepting state (False) that moves to the accepting state (True) on the given input (see (3) in http://userpages.umbc.edu/~squire/images/re2.gif )
06:53:15 <c_wraith> maurer: is the type q dependent on the value of the Regex a, or the type a?
06:53:27 <c_wraith> maurer: oh, I see
06:54:28 <c_wraith> maurer: yeah, that doesn't work so well in haskell - callers of a function get to choose what to substitute in for any type variable in the function's type.
06:54:59 <geekosaur> you're pinging the wrong person...
06:55:09 <mauris> aw :<
06:55:10 <c_wraith> err.  darn it.
06:55:14 <c_wraith> sorry to both
06:59:15 <mauris> i guess  lift :: Int -> SNat  (lifting some number to the single instance of the singleton type-level nat) is impossible for the same reason
06:59:56 <mauris> or, wait, maybe not, if you do something hackish with the typeclasses?
07:13:39 <hvr> utdemir: that's totally weird then... <$> should be available via Prelude with the ghc you have there (you can easily try out in GHCi)
07:14:06 <hvr> utdemir: are you sure the right 'ghc' is picked up?
07:14:15 <hpc> not in my version of ghc
07:14:36 <hpc> 7.4.1
07:20:01 <kaiyin_> It scares me to see (.) operator being overriden. Is it a good practice? https://github.com/kindlychung/hmatrix/blob/710/examples/multiply.hs#L13-L14 
07:20:25 <EvanR> thats not .
07:20:30 <EvanR> its (⋅)
07:20:44 <merijn> kaiyin_: No, it's not good practice, but as pointed out that's not . :)
07:20:52 <EvanR> see also (×)
07:21:06 <merijn> kaiyin_: Well, there's one acceptable overloading for (.) and that is the one from Control.Category
07:21:11 <EvanR> merijn: what about ... yeah
07:21:16 <merijn> :t (Control.Category..)
07:21:17 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
07:21:21 <merijn> ouch
07:21:26 <merijn> That's not the type I wanted :p
07:21:35 <kaiyin_> :t (.)
07:21:37 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:21:53 <kaiyin_> I am confused, aren't they the same thing?
07:21:54 <EvanR> (.) :: Category c => c b c -> c a b -> c a b
07:22:02 <EvanR> uhg
07:22:04 <EvanR> (.) :: Category c => c b c -> c a b -> c a c
07:22:06 <EvanR> hmm
07:22:09 <merijn> kaiyin_: Control.Category has a generalised version with type "(.) :: Category cat => cat b c -> cat a b -> cat a c"
07:22:56 <EvanR> kaiyin_: you are looking at two different characters that look similar period and "dot"
07:23:03 <merijn> kaiyin_: Which if you pick "cat = (->)" turns into "(.) :: ((->) b c) -> ((->) a b) -> ((->) a c)", or in infix notation: "(.) :: (b -> c) -> (a -> b) -> (a -> c)"
07:23:06 <EvanR> the dot is raised to the middle of the line
07:23:17 <merijn> kaiyin_: It's a unicode operator in the source you linked :)
07:23:58 <merijn> > let (☃) x y = x^2 + y^2 in 2 ☃ 4 -- unicode all the things...
07:24:00 <lambdabot>  20
07:24:20 <kaiyin_> OH, my goodness, I see. 
07:24:43 <merijn> For allowed operators/variable names, consult chapter 2 of the haskell report :)
07:24:55 <merijn> > generalCategory '☃'
07:24:57 <lambdabot>  OtherSymbol
07:25:08 <kaiyin_> merijn: did you just put a bug into your code intentionally? 
07:25:24 <merijn> kaiyin_: Bug in which code?
07:25:28 <EvanR> lol its a snowman
07:25:43 <merijn> kaiyin_: Sounds like you're IRC client doesn't render unicode properly :>
07:25:49 <merijn> It was the unicode snowman
07:26:07 <merijn> In general any unicode character that's classified as a symbol is allowed in operator names
07:27:13 <kaiyin_> merijn: it does render it properly, but it's so small, it looks like a spider. :D
07:27:13 <safinaskar> is there way to disable laziness completely for program? (ghc)
07:27:27 <EvanR> kaiyin_: http://unicodesnowmanforyou.com/
07:27:50 <kaiyin_> :)
07:28:14 <kaiyin_> having unicode symbols as operators is nice, but don't you find it difficult to type?
07:28:20 <EvanR> safinaskar: that would make most IO programs cease to function
07:28:38 <EvanR> the ones with loops would never begin
07:28:43 <merijn> kaiyin_: Yes, therefore I don't usually use them :p
07:28:52 <merijn> kaiyin_: I had to google + copy/paste for that one :p
07:29:04 <kaiyin_> ok, that's what i thought.
07:29:13 <EvanR> im surprised hmatrix uses them
07:29:34 <merijn> kaiyin_: But some people like them using emacs or some fancy unicode input
07:29:47 <safinaskar> EvanR: good site :)
07:30:33 <safinaskar> EvanR: at least, how to try non-lazy mode?
07:30:51 <EvanR> im not sure that makes sense in haskell at all
07:31:04 <safinaskar> EvanR: of course, make sense
07:31:22 <EvanR> not everything has a normal form
07:31:38 <safinaskar> EvanR: in my program all has normal form
07:32:23 <safinaskar> EvanR: my program eats all memory. i use big data structures. but in normal form they are less than in thunk form. so i think cause is lazyness. i want to disable it
07:32:58 <EvanR> in this case you should selectively use seq or similar to evaluate the specific thing that you determine is causing the problem
07:33:12 <kaiyin_> https://www.google.nl/search?newwindow=1&safe=off&espv=2&q=%E2%98%83&oq=%E2%98%83&gs_l=serp.12...0.0.0.9028.0.0.0.0.0.0.0.0..0.0.msedr...0...1c..64.serp..0.0.0.o-f1QoFLp_k
07:33:23 <EvanR> because evaluating the wrong thing could cause even worse memory performance
07:33:37 <EvanR> like a very large list
07:33:50 <merijn> safinaskar: Probably you just want to add strictness annotations on your data structures?
07:33:52 <safinaskar> EvanR: i already do this
07:34:20 <EvanR> also bang patterns
07:34:20 <safinaskar> EvanR: i just want some quick and dirty way to disable laziness. just to see whatever my program really will get fast
07:34:29 <merijn> safinaskar: "data Foo a = Foo !a" <- the ! means that GHC should make the 'a' strict. i.e. when applying Foo to an 'a' it will force the thunk to WHNF
07:35:05 <merijn> safinaskar: See also the BangPatterns extension (the last example is standard haskell, bang patterns can help making functions stricter but require an extension)
07:35:53 <EvanR> safinaskar: have you done the work necessary to know what the problem is?
07:36:02 <EvanR> profiling etc
07:37:29 <kaiyin_> what is the difference between these two instance declarations? https://gist.github.com/kindlychung/c208aa7c01d620c4678f
07:37:47 <EvanR> two t's
07:39:13 <kaiyin_> ok, not a good question.
07:39:22 <bazqux> In hackage what is the significance of a bang, !, in front of a constructor?
07:40:19 <merijn> bazqux: Read the BangPatterns sectio of the GHC manual
07:40:28 <merijn> bazqux: Essentially: strictness
07:40:29 <rabisg> bazqux: generally it means strictness
07:40:49 <bazqux> Ah right, okay thanks guys.
07:43:01 <safinaskar> EvanR: "have you done the work necessary to know what the problem is?" - of course, no :)
07:44:50 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
07:46:06 <kaiyin_> I am still having trouble understand this: https://github.com/kindlychung/hmatrix/blob/710/examples/multiply.hs#L16  It does not seem to conform to the instance Typeclass Type where ... syntax
07:47:01 <EvanR> kaiyin_: maybe its the FlexibleInstances
07:47:33 <safinaskar> EvanR: thanks! (please, put "safinaskar" in front next time :))
07:52:15 <chris2> anyone have experience cross-compiling ghc? i can build up to stage2 of ghc for arm on a x64_86 linux, but it seems inplace/bin/dll-split is built for the wrong architecture, yet executed
07:53:18 <kaiyin_> found something nice, but not really answering my question. http://connectionrequired.com/blog/2009/07/my-first-introduction-to-haskell-extensions-flexibleinstances/
07:54:10 <EvanR> kaiyin_: well, the illegal instance declaration message on that post explains the issue literally
07:55:14 <kaiyin_> EvanR: instance (Num t) => Scaling t t t where ... This does not specify what is an instance of Scaling t t t at all.
07:55:23 <kaiyin_> The subject is missing.
07:55:36 <EvanR> anything that is a Num
07:55:44 <c_wraith> actually, everything, Num or not
07:55:53 <c_wraith> So long as all three type parameters are the same
07:56:03 <EvanR> oh
07:56:08 <c_wraith> That requires UndecideableInstances, by the way
07:56:15 <c_wraith> In addition to FlexibleInstances
07:56:23 <EvanR> its a multiparameter type class, missed that
07:58:07 <Phillemann> Is there a way to specify multiple (hunit) test source files without creating a separate target for it in the cabal file?
07:58:41 <kaiyin_> c_wraith: you mean something like data Anything a a a = Foo a | Bar a | Baz a
07:58:53 <Phillemann> Ah, I might just create a HUnitTestMain.hs and import all the other tests...of course.
07:59:18 <c_wraith> kaiyin_: no, it's a multiparameter type class.  class Scaling a b c where ...
07:59:24 <EvanR> kaiyin_: instance Scaling Char Char Char
07:59:31 <c_wraith> kaiyin_: instance selection depends on all three types, not a single type
08:00:43 <ouanixi> Hi again! I'm trying to solve the cis194 problems and I was wondering if I can ask for feedback in here ??
08:01:04 <kaiyin_> c_wraith: I am still not getting it. Could you give a concrete type that satisfies instance (Num t) => Scaling t t t where (*) = scale
08:02:10 <kaiyin_> data Anything a a a = Foo a a a | Bar a a a | Baz a a a ?
08:02:15 <c_wraith> kaiyin_: well, no.  Not *a* type.  It's a multiparameter type class.
08:02:33 <c_wraith> kaiyin_: it's impossible to determine what instance to use from only a single type
08:03:25 <c_wraith> kaiyin_: Scaling :: * -> * -> * -> Constraint
08:03:37 <c_wraith> kaiyin_: Scaling Int Int Int :: Constraint
08:04:15 <c_wraith> kaiyin_: to put it in terms of explicit kinds as you'd get from the ConstraintKinds extension
08:06:36 <kaiyin_> c_wraith: there must be some concrete type that is an instance of this multiparam type class, right?
08:06:43 <kaiyin_> otherwise what's the use of it?
08:06:43 <c_wraith> kaiyin_: no
08:06:54 <c_wraith> kaiyin_: there are *triples* of concrete types that together form an instance of it
08:07:28 <c_wraith> kaiyin_: the triple of Int, Int, and Int is one such example.
08:08:28 <EvanR> could be confusing because that is one type, in addition to three types ;)
08:08:59 <c_wraith> That's why I didn't write it as the type of a 3-tuple where each component is Int
08:12:11 <kaiyin_> class Eq a where    (==) :: a -> a -> Bool      (/=) :: a -> a -> Bool  
08:12:26 <c_wraith> kaiyin_: that class has only one parameter, a
08:12:43 * hackagebot http2 0.9.1 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-0.9.1 (KazuYamamoto)
08:12:53 <c_wraith> kaiyin_: so you can determine an instance to use from only a single type
08:13:09 <kaiyin_> I see, so a is the type variable. and in instance Eq TrafficLight where ... TrafficLight is the type.
08:13:47 <kaiyin_> and in instance (Num t) => Scaling t t t where... t t t are the types, and together they are an instance of Scaling.
08:14:19 <c_wraith> kaiyin_: that sounds right.
08:14:34 <EvanR> whats the Num t for 
08:14:44 <kaiyin_> But it's hard to imagine how to make use of such a type.
08:14:52 <c_wraith> @let class MPTC a b where mptc :: a -> b -> (a, b) -- dumbest class ever
08:14:52 <lambdabot>  .L.hs:41:8:
08:14:52 <lambdabot>      Failed to load interface for ‘Prelude’
08:14:52 <lambdabot>      There are files missing in the ‘base-4.8.0.0’ package,
08:14:59 <c_wraith> err.  what?
08:15:01 <c_wraith> @undefine
08:15:02 <lambdabot> Undefined.
08:15:05 <c_wraith> @let class MPTC a b where mptc :: a -> b -> (a, b) -- dumbest class ever
08:15:05 <lambdabot>  .L.hs:41:8:
08:15:05 <lambdabot>      Failed to load interface for ‘Prelude’
08:15:05 <lambdabot>      There are files missing in the ‘base-4.8.0.0’ package,
08:15:14 <c_wraith> ok, @let seems to be broken!
08:15:29 <EvanR> @let x = 0
08:15:30 <lambdabot>  .L.hs:41:8:
08:15:30 <lambdabot>      Failed to load interface for ‘Prelude’
08:15:30 <lambdabot>      There are files missing in the ‘base-4.8.0.0’ package,
08:15:40 <c_wraith> @version
08:15:40 <lambdabot> lambdabot 5.0.1
08:15:40 <lambdabot> git clone https://github.com/lambdabot/lambdabot
08:15:40 <kaiyin_> ah...
08:16:07 <c_wraith> Huh.  Who's running lambdabot these days?  Doesn't seem to be working right with GHC 7.10, completely.
08:16:34 <c_wraith> Though that could just be an environment issue
08:17:43 * hackagebot highlighting-kate 0.5.14 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.14 (JohnMacFarlane)
08:19:12 <kaiyin_> c_wraith: could you paste that example somewhere so I can study it? Thanks!
08:19:28 <c_wraith> kaiyin_: sure, I'll write up a quick demo
08:19:39 <kaiyin_> cool.
08:22:43 * hackagebot wai-logger 2.2.4 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.4 (KazuYamamoto)
08:26:00 <c_wraith> kaiyin: http://lpaste.net/129788
08:26:16 <kaiyin> nice~
08:28:03 <kaiyin> c_wraith: so the "togetherness" is defined by a binary function?
08:28:19 <c_wraith> kaiyin: in that case, yes.
08:28:54 <kaiyin> what if you have 3 typeclass params?
08:29:28 <c_wraith> kaiyin: the important part is that all the types in the class definition appear in every member of the class
08:29:53 <c_wraith> kaiyin: without that information, it's impossible to select the instance to use
08:30:11 <c_wraith> kaiyin: it need not be a binary function, though..  You could do something as simple as...
08:30:21 <c_wraith> class Foo f a where foo :: f a
08:30:53 <c_wraith> kaiyin: The important part is that every type parameter from the class appears in the members of the class, one way or another.
08:31:20 <c_wraith> kaiyin: (that rule is relaxed a bit when Functional Dependencies are introduced, but I think it's not worth bogging you down with that right now)
08:33:41 <kaiyin> ok
08:35:05 <kaiyin> c_wraith: https://github.com/kindlychung/hmatrix/blob/710/examples/multiply.hs#L32-L52  in the case of the Mul class, all of its instances involves one binary function (×), why does it include 3 type params?
08:35:36 <c_wraith> kaiyin: oh.  That example *does* use functional dependencies.
08:36:12 <c_wraith> kaiyin: the part between the | and the where is the functional dependency
08:36:41 <kaiyin> ok, I will read that up in the wikibook.
08:36:46 <c_wraith> kaiyin: it says that you can uniquely determine the types after the -> from the types before the ->.  And you can have a comma-separated list of them
08:37:05 <c_wraith> kaiyin: so those dependencies say that knowing any pair of types is enough to uniquely determine what the third type has to be.
08:37:27 <c_wraith> kaiyin: that is enforced by the compiler not allowing multiple instances that have two types in common with each other, but the third type different
08:37:44 * hackagebot hruby 0.3.1 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.1 (SimonMarechal)
08:39:38 <kaiyin> c_wraith: sounds cool
08:40:26 <laudiacay> nyello
08:40:43 <voidzero> maheya
08:42:09 <kaiyin> I noticed there is a haskell report 2010, but many people often refer to the 98 version, why is that?
08:42:44 * hackagebot pcre-utils 0.1.5 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.5 (SimonMarechal)
08:43:35 <geekosaur> because the main differences between H'98 and H'2010 were (a) deprecation of n+k patterns (b) adding hierarchical modules, which were an annex to H'98, to the main Report
08:44:59 <merijn> Don't forget, deprecating those damn DatatypeContexts!
08:45:18 <EvanR> n+k patterns are deprecated but still work ?
08:45:34 <merijn> no
08:45:38 <merijn> Requires an extension
08:48:40 <absence> can Control.Lens.Wrapped or Control.Newtype be of any assistance in cases like getCompose $ f <$> Compose a <*> Compose b?
08:52:45 * hackagebot conceit 0.2.2.1 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.2.2.1 (DanielDiazCarrete)
08:52:47 * hackagebot filecache 0.2.6 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.6 (SimonMarechal)
08:59:57 <bazqux> Can anyone give me any pointers on the meaning of comments of the form: {-# SOMETHING #-} do they have some special meaning?
09:00:12 <merijn> bazqux: Yes, {-# are pragmas
09:00:36 <merijn> bazqux: Usually they enable extensions are have annotations on whether something should be inlined or not
09:00:53 <EvanR> safinaskar: did -XStrict make your program go super fast?
09:01:06 <bazqux> merijn: Is it in anyway analagous to the C pre-processor?
09:01:09 <voidzero> bazqux, OverloadedStrings is a pragma that's easy to understand
09:01:20 <merijn> bazqux: No, more like OpenMP pragmas in C
09:01:28 <voidzero> it makes working with "strings" of different types more loosely
09:01:41 <bazqux> Okay. Thanks for the help guys.
09:05:36 <voidzero> bazqux, also, to use these in ghci, you can use :set
09:05:47 <voidzero> for example ':set -XOverloadedStrings'
09:10:21 <RageD> anyone have a particular favorite lib for writing gui's in haskell?
09:10:54 <kaiyin> how do you declare an instance like this in ghci? https://github.com/kindlychung/hmatrix/blob/master/packages/tests/src/Numeric/LinearAlgebra/Tests/Instances.hs#L49-L53
09:12:46 * hackagebot list-tries 0.6.0 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.6.0 (MattiNiemenmaa)
09:13:14 <rabisg> kaiyin: as a general way you can use ; to separate multi line things
09:13:52 <kaiyin> ok, I have used :set +m, but it does not seem to work in this case.
09:14:47 <hexagoxel> kaiyin: in what way does it not work?
09:16:21 <kaiyin> hexagoxel: like this: https://gist.github.com/kindlychung/315ae48ec4d5e3b44e99
09:16:54 <hexagoxel> kaiyin: but that would not work in ghc either :)
09:17:22 <hexagoxel> because you go left of shrinkListElementwise, basically
09:17:54 <hexagoxel> kaiyin: indent the "++" more
09:18:01 <kaiyin> hexagoxel: like this? https://github.com/kindlychung/hmatrix/blob/master/packages/tests/src/Numeric/LinearAlgebra/Tests/Instances.hs#L39-L41
09:18:49 <kaiyin> hexagoxel: still the same: https://gist.github.com/kindlychung/e4a0364edc748f9cb6e4
09:22:08 <Caballer> Hello, quich question, when calling ghc (7.8.4) and multiple "conflicting" parameters are given on the same command line, eg: ghc -O0 -O2 -O1, which one is the one used?
09:22:47 <Caballer> I would guess that it's the last one specified, but I'd like to make sure
09:25:07 <hexagoxel> kaiyin: i cannot reproduce that problem, this seems to parse fine over here.
09:25:26 <kaiyin> oh, I am using ghci-ng, maybe that's the problem.
09:26:45 <hexagoxel> is there some Data.Proxy available for ghc-7.6 ?
09:27:17 <hexagoxel> (how am i supposed to keep my stuff backwards-compatible..?)
09:27:39 <bennofs> hexagoxel: see tagged package
09:27:40 <glguy> http://hackage.haskell.org/package/tagged
09:28:19 <ij> What's the a in RWST r w s m a?
09:28:38 <geekosaur> result of a given computation
09:28:48 <glguy> ?unmtl RWST r w s m a
09:28:49 <lambdabot> r -> s -> m (a, s, w)
09:29:29 <glguy> Given an environment and state, produce an m of a (result, newstate, accumulatedwrittenstuff)
09:30:43 <hexagoxel> bennofs, glguy: thanks a lot; that did not turn up in my searches.
09:31:30 <Peaker> btw, RWST probably has the same associativity-related leak that WriterT has
09:32:14 <kaiyin> how can something be imported when it's not defined? https://github.com/albertoruiz/hmatrix/search?utf8=%E2%9C%93&q=IArray&type=Code
09:32:48 * hackagebot process-streaming 0.7.0.2 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.0.2 (DanielDiazCarrete)
09:33:24 <glguy> kaiyin: Can you be more specific about what you don't understand about that line?
09:33:25 <rabisg> kaiyin: from a different package https://hackage.haskell.org/package/array-0.4.0.1/docs/Data-Array-IArray.html probably
09:34:13 <ij> Thanks, got it!
09:34:48 <rabisg> kaiyin: it is a dependency defined in https://github.com/albertoruiz/hmatrix/blob/a194062a082230ca00cc4991407cc4c926d4b810/packages/base/hmatrix.cabal#L43 
09:41:10 <ij> Why would be using RWST be preferrable to just smth like f a = g a >> f (z a)? Easier composition with other monadish functions?
09:42:10 <Peaker> ij: if you have a monad you work in anyway, propagating a parameter manually everywhere is unnecessary
09:42:24 <Peaker> ij: if you don't use the parameter in every function, it's nicer to let it propagate in
09:44:07 <exio4> it's a nice way to reduce boilerplate by giving something somewhat common a name and a nice interface 
09:45:00 <ij> Right, thanks. 
09:45:21 <Peaker> note that WriterT (and similarly, RWST) is a bit broken
09:46:03 <Peaker> The way it associates the writer-actions, it must leak memory
10:02:45 <kaiyin> rabisg: thanks.
10:17:51 * hackagebot tce-conf 1.1 - Very simple config file reading  http://hackage.haskell.org/package/tce-conf-1.1 (DinoMorelli)
10:18:42 <voidzero> I'm a bit uncertain about the scope of 'where'
10:18:58 <monochrom> "where" attaches to the "="
10:19:09 <bergmark> it doesn't always attach to a =
10:19:19 <monochrom> right, simplified lie
10:19:21 <voidzero> do .. where
10:19:25 <bergmark> :-)
10:19:31 <monochrom> no, "where" does not belong to "do".
10:19:54 <voidzero> ah
10:20:16 <voidzero> lol ok, see, now I wonder what else it doesn't belong to... I'm guessing 'case' :P
10:20:20 <monochrom> "x = do{...} where y=4" y=4 belongs to "x=", not to "{...}"
10:22:26 <bergmark> voidzero: i can't tell you exactly how it works, i guess i've just built intuition for it. but the haskell report contains the specifics
10:22:40 <voidzero> so with 'let x = .. where', where is limited to the scope of x, so to say?
10:22:42 <monochrom> "case john of x:xs -> expr where y=4; [] -> fxpr where z=10"  y=4 belongs to "x:xs -> expr", z=10 belongs to "[] -> fxpr"
10:22:56 <monochrom> yes
10:23:00 <bergmark> i was surprised when i noticed each guard in a pattern match could have its own where binding :)
10:23:13 <narendraj9> How can a I have a monotone function [a morphism between two Posets] that is bijective and yet not an isomorphism?
10:23:22 <voidzero> I can work with "binds to '='" :)
10:24:02 <voidzero> tnx monochrom
10:24:04 <hexagoxel> but the where-declared bindings are local to that equation
10:24:40 <monochrom> narendraj9: map a 4-point diamond to a 4-point vertical line
10:24:43 <hexagoxel> if, at top-level, you have `f True = .. where g=..`, w is not visible in other equations for f
10:25:19 <hexagoxel> s/w/g/
10:25:22 <narendraj9> monochrom: 4-point diamond. I don't understand what that means. 
10:26:09 <monochrom> {top, left, right, bottom} such that bottom<=left, bottom<=right, left<=top, right<=top, left and right incomparable.
10:27:14 <narendraj9> monochrom: Okay. Let me think about this. I will be back.
10:27:29 <monochrom> but a smaller example just uses 3 points, e.g., V to 3-point vertical line
10:29:36 <narendraj9> monochrom: How would a monotone map the left and right points because the order isn't specified? It can map them any way?
10:29:51 <monochrom> yes. this is why.
10:29:52 <voidzero> bergmark, Wish I checked the Haskell Report sooner, thanks for the tip.
10:30:40 <monochrom> I agree with reading the Haskell Report
10:31:03 <monochrom> no, I disagree, you should always pay me for consultation :)
10:31:23 <narendraj9> monochrom: So, both of those monotones would be bijective. 
10:31:34 <monochrom> yes.
10:31:41 <voidzero> Is it ok if I just keep radiating my appreciation? :-)
10:32:07 <narendraj9> monochrom: But to go back to the diamond from the vertical line, I need to figure out which way I took. But I don't have that info with me.
10:32:40 <monochrom> there is no monotone bijective way to go back.
10:33:07 <narendraj9> monochrom: Why can't I invent an inverse given one montone? If I can do it, why isn't it an isomorphism?
10:33:41 <monochrom> call the 4-point line {0,1,2,3} such that 0<=1<=2<=3. f(1)=left f(2)=right is not monotone. f(1)=right f(2)=left is not monotone.
10:34:21 <narendraj9> monochrom: Okay. Yes.
10:34:39 <narendraj9> monochrom: The inverse has to be a monotone. 
10:34:43 <narendraj9> monochrom: Thank you so much. :)
10:34:49 <monochrom> you're welcome
10:35:11 <narendraj9> monochrom: What book did you read category theory from? 
10:35:16 <alxgnon> Can I ask questions about cabal here?
10:35:27 <narendraj9> monochrom: I am following Steve Awodey's book. 
10:36:30 <narendraj9> monochrom: Any suggestions? :)
10:36:33 <alxgnon> I'm doing cabal install on a local package and it's giving me a "inappropriate type" error
10:37:05 <monochrom> I read Fokkinga's "a gentle introduction to category theory: a calculational approach" and Pierce's "basic category theory for computer scientists"
10:37:52 <monochrom> I should buy a kindle copy
10:38:37 <narendraj9> monochrom: Okay. Thanks. :) I will keep coming back here for help :-D
10:39:47 <monochrom> I forgot Bird & de Moor "algebra of programming", but I guess it is now hard to find anyway
10:40:45 * narendraj9 notes
10:41:00 * narendraj9 jots them down in ord-mode.
10:41:28 <narendraj9> Oho. org-mode. 
10:43:42 <bergmark> i fail to use org-mode often enough to remember how to use it
10:44:07 <narendraj9> bergmark: I keep reminding myself that I must use it. :_D
10:44:58 <narendraj9> bergmark: I must make it a habit. I started using it with pomodoro technique and it was working like a charm. And then I forgot using it.
10:53:55 <lpaste> sx pasted “QuickCheck, checking for timeout” at http://lpaste.net/129793
10:54:00 <sx> Hi, I'm trying to check for not terminating expressions in QuickCheck/HUnit/Hspec, while my function 'timeoutAt' works for things like 'threadDelay' it doesn't for others. Can someone image why?
10:57:54 * hackagebot cgi 3001.2.2.1 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.2.2.1 (cheecheeo)
11:02:54 * hackagebot rest-client 0.5.0.1 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.5.0.1 (AdamBergmark)
11:05:24 <int-e> sx: "for others" ... if you're testing a sufficiently simple infinite loop, then you may be running into https://ghc.haskell.org/trac/ghc/ticket/367
11:06:33 <c_wraith> int-e: are you still running lambdabot?
11:07:00 <int-e> c_wraith: yes
11:07:08 <c_wraith> @let foo = "foo"
11:07:09 <lambdabot>  .L.hs:41:8:
11:07:09 <lambdabot>      Failed to load interface for ‘Prelude’
11:07:09 <lambdabot>      There are files missing in the ‘base-4.8.0.0’ package,
11:07:15 <c_wraith> that's been happening all morning
11:07:52 <c_wraith> Everything other than @let seems fine
11:08:27 <int-e> Ah. I updated to ghc-7.10.1 yesterday, I'll try to figure out what's going wrong for @let. Thanks!
11:08:34 <sx> int-e: I already thought it could be this, but shouldn't forkOS then work? (Which it does not)
11:09:20 <int-e> sx: no.
11:09:38 <c_wraith> sx: forkOS doesn't do what you think it does.
11:09:39 <int-e> sx: forkOS is only different from forkIO for foreign function calls.
11:09:41 <c_wraith> (It's poorly named)
11:10:17 <sx> ah, sad, so there is no way to get arround this issue? (other than using pthread via ffi? :P )
11:10:43 <int-e> sx: Oh, FFI is another case where timeouts don't really work, because the C doesn't have a notion of async exceptions.
11:10:51 <c_wraith> sx: well, you could use something like the mueval approach - which is in fact to launch it in another process...
11:12:57 <c_wraith> > let x = tail x in x
11:12:58 <lambdabot>  L.hs:92:8:
11:12:58 <lambdabot>      Could not find module ‘Data.List.Split.Lens’
11:12:58 <lambdabot>      Perhaps you meant
11:13:15 <c_wraith> ...  Apparently int-e is busy poking lambdabot's internals right now. :)
11:18:12 <Fuuzetsu> so cautious-file bounds need updating for filepath-1.4 but the URL maintainer e-mail listed bounces, what now? :)
11:18:35 <Fuuzetsu> disregard that
11:19:14 <int-e> c_wraith: /msg lambdabot @quit brb
11:19:18 <int-e> uh.
11:19:26 <c_wraith> haha
11:19:39 <int-e> @let a = 1
11:19:46 <lambdabot>  Defined.
11:19:49 <int-e> > a
11:19:56 <lambdabot>      Ambiguous occurrence ‘a’
11:20:02 <lambdabot>      It could refer to either ‘L.a’, defined at L.hs:141:1
11:20:03 <int-e> oh, right.
11:20:04 <int-e> @undef
11:20:05 <c_wraith> other than the super-slowness, it appears to be working
11:20:12 <lambdabot> Undefined.
11:20:17 <int-e> c_wraith: it's super slow as long as it's joining channels
11:20:21 <c_wraith> ah
11:20:27 <int-e> which it does for the first 5 minutes...
11:20:30 <c_wraith> How many channels does it join these days?
11:20:42 <int-e> 85
11:20:47 <c_wraith> That's quite a lot
11:20:53 <Fuuzetsu> why is it super slow at joining?
11:21:10 <c_wraith> Probably rate-limiting itself to not get banned
11:21:11 <mniip> with a naive approach, to join 85 channels you need ~40 seconds
11:21:20 <int-e> because it throttles messages rather than flooding the server
11:21:34 <mniip> with a multi-channel join you can join 85 channels with probably a handful messages
11:22:31 <mniip> JOIN #foo,#bar,#baz
11:23:08 <mniip> iirc you can join as many as you can fit on an irc line
11:23:31 <mniip> int-e, how slowly does it throttle
11:24:48 <int-e> something like 2s/per message, plus the mesages received from the server (list of nicks) factor into this somehow. I do not know lambdabot's code in that area very well.
11:25:12 <mniip> you only need 0.5s per message
11:25:39 <mniip> also sendq is a whole different throttle
11:26:04 <int-e> Honestly I don't care very much, it's not like lambdabot's being restarted all the time.
11:26:48 * mniip has spent too many nights fighting freenode recvq throttle
11:39:45 <lpaste> wilywampa pasted “repeat monad” at http://lpaste.net/129794
11:40:34 <limepod> is there a more idiomatic way to do fmap ($ f) xs?
11:40:51 <wilywampa> Is there a function that lets me repeat a function on a monad like that, like mapM but where each step depends on the result from the previous step?
11:42:11 <bergmark> limepod: i don't think so
11:42:28 <monochrom> wilywampa: perhaps foldM
11:42:57 * hackagebot attoparsec 0.12.1.5 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.5 (BryanOSullivan)
11:43:18 <tempname11_> hello guys. repeating my question from #haskell-lens: how can I combine "lensAB :: Lens' A (Maybe B)" and "lensBC :: Lens' B C" to get "lensAC :: Lens' A (Maybe C)" ?
11:45:34 <fifosine> hi, I understand that there are functional, dependently typed programming languages like Agda and Coq, so are there logic, dependently typed programming languages?  like a dependently typed prolog?  or does that not actually make sense?
11:45:59 <dolio> fifosine: twelf
11:46:29 <fifosine> dolio: is twelf the only of its kind?
11:47:04 <wilywampa> monochrom: almost - foldM only gives the last result, so foldM (\x _ -> f x) 1 [0..3] is map last (foo 4) instead of foo 4
11:47:57 * hackagebot monad-classes 0.3.1.1 - more flexible mtl  http://hackage.haskell.org/package/monad-classes-0.3.1.1 (MatthewFarkasDyck)
11:48:25 <dolio> fifosine: Not sure. I think there might be other -elfs than twelf but they'd probably be pretty similar.
11:48:42 <dolio> There's also lolli, which is based on linear logic, but I'm not sure if it has the type theory bits.
11:50:35 <dolio> Those are the ones I know about.
11:51:11 <bennofs> Is there a fix for the warning  '-XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS' without needing CPP?
11:52:02 <dolio> Stop using overlapping instances. :)
11:53:11 <bennofs> ok hmm, seems this file doesn't actually use overlapping instances. 
11:55:36 <monochrom> my fix would be: use OverlappingInstances for the current version. 6 months later, switch to the new scheme in the next version. no one should be using an old compiler by then.
11:55:51 <monochrom> if 6 months looks too soon to you, make it 12 months.
11:56:47 <monochrom> this is why deprecation has such a long grace period
11:57:58 * hackagebot warp 3.0.10.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.10.1 (MichaelSnoyman)
11:59:01 <quchen> monochrom: 6 months can be very short for deprecation, depending on the feature.
12:16:17 <cfoch> Hello... does somebody know what is the nickname of Petersen?
12:16:49 <monochrom> hmm, could it be "Evil Graph"? :)
12:17:01 <monochrom> does wikipedia know?
12:19:26 <ij> "do x <- getClockTime" Do I call 'x' a variable?
12:20:55 <dmj`> ij: no, it's more like you're associating a value with a symbol, variable implies you can mutate it's contents
12:21:10 <ij> That's why I'm asking.
12:21:20 <ij> It's not an argument, it's not a variable. What is it?
12:21:34 <ij> Well it is an argument if you desugar it.
12:21:44 <dmj`> It's a value
12:21:48 <ij> Ok.
12:22:35 <ij> So x is a value or it contains value or both?
12:23:13 <EvanR> this question seems to come up a lot
12:23:29 <EvanR> ij: x <- foo, x is a variable, its just not variable ;)
12:24:01 <EvanR> that syntax isnt any different in that regard from function params, pattern variables, list comprehensions, etc
12:24:11 <EvanR> or names of top level entities
12:24:37 <ChristianS> EvanR: calling something that's non-variable a variable seems bad style
12:24:47 <EvanR> thats what its called, nonetheless
12:25:23 <EvanR> people get confused over what varying even means
12:25:32 <EvanR> just give up ;)
12:27:11 <EvanR> ChristianS: variables are the syntactic elements that look like identifiers, arent keywords, and evaluate to the bound value
12:27:13 <dmj`> EvanR: but x can never vary
12:27:28 <EvanR> in haskell no variables can vary
12:27:36 <dmj`> EvanR: how so?
12:27:44 <dmj`> oh I read that wrong
12:27:48 <dmj`> EvanR: yes I agree
12:27:49 <EvanR> because i arbitrarily chose the definition of vary just like you did
12:28:05 <ij> Maybe not in the scope of the function, but in the scope of the program it probably will be representing different values.
12:28:05 <dmj`> EvanR: semantics :)
12:28:27 <Hijiri> I thought semantics was important in haskell
12:28:29 <EvanR> semantics yes, i.e. the important details of what something means 
12:28:43 <EvanR> (as opposed to semantics, i.e. the unimportant details of what something means)
12:29:00 <dmj`> EvanR: What definition of vary are you using then?
12:29:07 <EvanR> here, mutating in place
12:29:48 <dmj`> EvanR: What else can vary mean in this context
12:30:05 <EvanR> > map (\x -> x + 1) [0,1,2]
12:30:07 <lambdabot>  [1,2,3]
12:30:09 <ij> What about my suggestion?
12:30:10 <EvanR> x has varied
12:31:07 <dmj`> EvanR: that's a function though, not a value, I would so no, that function has not varied. 
12:31:09 <dmj`> > let f x = x + 1 in map f [0,1,2]
12:31:10 <EvanR> ij: right
12:31:11 <lambdabot>  [1,2,3]
12:31:23 <EvanR> dmj`: a function? were talking about variables
12:31:28 <dmj`> s/so/say
12:31:42 <EvanR> f didnt even vary
12:32:22 <EvanR> ij: really, the point is that "variables" are a syntax element, thats what they are called, dont worry about why. its tradition
12:32:37 <EvanR> haskell didnt name them that
12:33:08 <dmj`> EvanR: x still never varies, would the haskell report refer to x as a value
12:33:14 <dmj`> or variable
12:33:17 <EvanR> its a variable
12:33:40 <EvanR> whether it varies is just trolling
12:33:41 <ij> EvanR, I feel secure about my beliefs now. 
12:35:13 * EvanR renames IORefs, MVars, TVars to "Muts" to cause more confusion in the process of trying to help
12:35:42 <doweaver> Hey guys - I'm trying to do a very basic module import, but I must be misunderstanding something, because I'm failing miserably. I've read through several docs online but can't figure out where I'm going wrong. Could someone check out this pastebin and let me know what rookie mistake I'm making here? http://pastebin.com/iXjdNgs8
12:36:40 <dmj`> doweaver: module Measurement (Measurement(..)) where
12:36:50 <dmj`> doweaver: add the (..), you're just exporting the type, not the constructor
12:37:04 <doweaver> Ohhh
12:37:06 <doweaver> Gah
12:37:08 <doweaver> Thank you!
12:37:11 <dmj`> np
12:37:43 <doweaver> Also - is it an acceptable practice to export something with the name of the module?
12:37:59 <doweaver> I thought maybe I was hitting a weird collision there at one point
12:38:14 <safinaskar> etabot: are you bot?
12:38:19 <dmj`> doweaver: sure, if you have a library many authors have one module that re-exports all submodules, so you only have to import one module to get all the others
12:38:57 <dmj`> module Library.CoolProject ( module Library.CoolProject.Foo (..), module Library.CoolProject.Bar (..) ) where
12:39:11 <dmj`> you'd have to import them to be able to export them though
12:39:27 <doweaver> So pretty much just piping them through?
12:39:29 <doweaver> Makes sense
12:39:56 <absence> can Control.Lens.Wrapped or Control.Newtype be of any assistance in cases like getCompose $ f <$> Compose a <*> Compose b?
12:41:36 <safinaskar> int-e: is this possible to get @hoogle to print links to docs?
12:42:18 <vandenoever> is there something nicer than 'let a = maybe Nothing dosomething maybevalue' ?
12:43:29 <EvanR> let a = doSomething <$> maybevalue
12:44:40 <int-e> safinaskar: I don't think so. It's using the `hoogle` command line tool, and I see no way of getting links out of that.
12:50:22 <vandenoever> EvanR: maybe returns a Maybe and <$> returns a non-maybe
12:50:36 <kaidelong> absence: AFAICT, no. However Compose a <*> Compose b should be equivalent to a <$> Compose b, IIRC, if Compose is pure for its applicative functor
12:50:50 <hpc> > maybe Nothing (+ 5) Nothing
12:50:51 <exio4> vandenoever: sounds like (>>=) 
12:50:51 <lambdabot>      No instance for (Show a0)
12:50:52 <lambdabot>        arising from a use of ‘show_M113885589030353060826973’
12:50:52 <lambdabot>      The type variable ‘a0’ is ambiguous
12:50:53 <EvanR> vandenoever: no other way around
12:50:57 <kaidelong> so you may b able to get rid of one of those constructors
12:51:04 <hpc> > maybe Nothing (+ 5) (Just 5)
12:51:06 <lambdabot>      No instance for (Show a0)
12:51:06 <lambdabot>        arising from a use of ‘show_M594039989367792451226996’
12:51:06 <lambdabot>      The type variable ‘a0’ is ambiguous
12:51:15 <hpc> :t maybe
12:51:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:51:17 <exio4> @type \something value -> maybe Nothing something value
12:51:18 <lambdabot> (a -> Maybe a1) -> Maybe a -> Maybe a1
12:51:25 <vandenoever> EvanR: i mean the doSomething should return a Maybe with maybe
12:51:32 <exio4> @type (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b 
12:51:33 <lambdabot> (a -> Maybe b) -> Maybe a -> Maybe b
12:51:44 <vandenoever> EvanR: well, i could make partial application from 'maybe Nothing'
12:51:47 <EvanR> vandenoever: it should be changed to be simpler given <$> simplericity
12:51:50 <kaidelong> well
12:51:55 <kaidelong> I just looked it up and it isn't
12:52:08 <kaidelong> AFAICT lens will not help though
12:52:25 <EvanR> vandenoever: make doSomething work with Maybe's Functor instance
12:52:44 <cfoch> hi
12:52:48 <EvanR> which might be as simple do nothing
12:53:00 <cfoch> is there a repo on gihub for SourceGraph?
12:53:57 <doweaver> Is there a standard way for avoiding collisions with custom data types? That is, I could have two custom data types that both have a name, but I can't call both of the fields "name" and then import them in to the same namespace. I could rename the fields to something like fooName and barName, OR have everything be fully qualified, OR probably do any of a number of other things (including making a typeclass,
12:53:57 <cfoch> https://hackage.haskell.org/package/SourceGraph
12:53:59 <doweaver> I guess?). Is there a standard approach?
12:54:04 <vandenoever> EvanR: well, i'm using the pattern 'maybe Nothing' about 5x in my codebase, making my doSomthing functions (all short and different) work withMaybe's functor sounds overengineerd
12:54:30 <EvanR> vandenoever: ... it sounds like you should have been using Maybe's fmap and >>= the whole time
12:54:31 <exio4> vandenoever: isn't (>>=)/bind enough? 
12:55:16 <EvanR> you did the over engineering ;)
12:57:47 <vandenoever> >>= might work, i'm a bit too haskell n00b to use >>= a lot yet, this is good learning step
12:58:05 <heatsink> doweaver: Basic solution is to give field names a prefix based on the type
12:58:08 <EvanR> but you are probably using do notation
12:58:17 <vandenoever> in one place it works, looking through the other ones now, nice way to get more into haskellisms
12:58:31 <vandenoever> EvanR: i know >>= == do
12:58:41 <vandenoever> but i usually only do do in IO stuff
12:58:43 <vandenoever> so far
12:59:05 <heatsink> doweaver: If many types have the same fields with the same meaning, you could abstract the common fields with type classes
12:59:21 <EvanR> when you have a Maybe Something, that makes sense, it might be Nothing. When you have a Maybe Something and the next step is to use Something -> Maybe SomethingElse, wham this is >>= ;)
12:59:22 <doweaver> heatsink: like Foo { fooName :: String } and Bar { barName :: String }
12:59:26 <heatsink> yes
12:59:38 <doweaver> heatsink: Yeah, the typeclass thing makes sense too
12:59:40 <EvanR> and you get a Maybe SomethingElse, which also makes sense
12:59:41 <heatsink> and class HasName a where name :: a -> String
12:59:43 <doweaver> heatsink: Thank you!
12:59:53 <vandenoever> EvanR: it's a good crowbar to get monoids in my brain :-)
13:00:19 <EvanR> when your pieces parts make sense in isolation, and then you can put them together that also makes sense, this is good
13:00:33 <EvanR> into something that makes sense*
13:00:44 <EvanR> vandenoever: >>= is Monad
13:00:54 <vandenoever> right, monad
13:01:33 <vandenoever> it's a chain of actions some of which can introduce a Nothing i.e. fail for some reason
13:04:27 <divVerent> There is a value x (namely, -2**31::Int), for which x < 0 and -x < 0 - is this a bug or a feature? 
13:04:58 <EvanR> vandenoever: btw Either e's >>= works similarly if you need an e value in the process of failing, rather than the boring Nothing
13:05:13 <EvanR> Either String for example
13:05:44 <vandenoever> EvanR: yeah, it's nice that this principle is reusable
13:07:12 <divVerent> example: http://codepad.org/5B6zrOyN
13:08:00 <glguy> > minBound `div` (-1) :: Int
13:08:01 <lambdabot>  *Exception: arithmetic overflow
13:08:02 * hackagebot fingertree 0.1.0.2 - Generic finger-tree structure, with example instances  http://hackage.haskell.org/package/fingertree-0.1.0.2 (RossPaterson)
13:08:13 <cfoch> o/ Does somebody use Fedora here
13:08:14 <cfoch> ?
13:08:26 <divVerent> glguy: yes
13:08:30 <glguy> divVerent: The strange behavior of the minBound of bounded integral types is a consequence of its 2s-complement representation
13:08:33 <divVerent> actually a CPU feature too :P
13:08:39 <divVerent> glguy: sure, I am aware it is
13:08:56 <__ryan> hello everyone
13:09:02 <divVerent> just... I'd kinda prefer if these overflows would error instead of silently yielding wrong results
13:09:07 <divVerent> i.e. some kind of CheckedInt type
13:09:14 <divVerent> that uses "as fast as possible" bounds checking at runtime
13:09:39 <divVerent> as for div by -1 - yes
13:09:46 <glguy> divVerent: If you're more concerned with overflow than speed you can use Integer
13:09:59 <divVerent> even more fun: the most common way of SIGFPE "floating point exception" is an INTEGER division by zero
13:10:06 <verement> divVerent: I have an open GHC bug about this
13:10:35 <divVerent> as float divisions by zero just yield nan/inf values :)
13:10:54 <divVerent> speaking of which, what's the "best" way to distinguish positive from negative zero?
13:11:27 <hpc> the best way is to reconsider the problem you're trying to solve
13:11:46 <verement> https://ghc.haskell.org/trac/ghc/ticket/8695
13:11:48 <hexagoxel> can i run a test-suite as an executable in cabal?
13:12:00 <divVerent> hpc: in the application i once needed this for
13:12:10 <divVerent> it was "save a float value as an ascii string that's both human readable and can be read back"
13:12:14 <divVerent> i.e. a "show" function
13:12:22 <divVerent> of course, I then was just using what the libraries provide
13:12:29 <divVerent> just wondering how you'd actually implement this
13:12:45 <divVerent> most probably would look at the number bit pattern for this, I suppose...
13:13:00 <int-e> :t isNegativeZero
13:13:01 <lambdabot> RealFloat a => a -> Bool
13:13:02 * hackagebot ShellCheck 0.3.6 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.6 (vidarhol)
13:13:13 <kadoban> hexagoxel: Isn't that pretty much what 'cabal test theSuite' does?
13:13:14 <divVerent> ah, right
13:13:20 <divVerent> how is it implemented? Bit pattern?
13:13:39 <divVerent> as I think the only IEEE way to detect negative zeroes "within" float itself is 1/0 == +inf, 1/-0 == -inf
13:13:43 <hpc> > (-0) / 0 :: Float
13:13:45 <lambdabot>  NaN
13:13:49 <hpc> > (-0) / 1 :: Float
13:13:50 <lambdabot>  -0.0
13:14:05 <divVerent> > 1 / -0 :: Float
13:14:07 <lambdabot>      Precedence parsing error
13:14:07 <lambdabot>          cannot mix ‘/’ [infixl 7] and prefix `-' [infixl 6] in the same infi...
13:14:15 <divVerent> > 1 / (-0) :: Float
13:14:16 <lambdabot>  -Infinity
13:14:21 <divVerent> exactly this way
13:14:53 <divVerent> so IEEE supports two values a == b with f a != f b, neither being NaN, for a pure function f x = 1/x 
13:14:55 <hexagoxel> kadoban: but that redirects the output
13:15:39 <int-e> divVerent: http://lpaste.net/129800 ... pretty much
13:15:46 <kadoban> hexagoxel: I don't understand what you mean.
13:18:38 <hexagoxel> kadoban: "Test suite logged to: dist/test/foobar"
13:19:17 <hexagoxel> while running as an executable would print that stuff to stdout
13:20:13 <hexagoxel> i can `cabal exec -- ghci` and `:l tests/Test.hs`, but that is fragile and annoying
13:22:08 <kadoban> Oh, hmm. I'm not sure
13:22:08 <safinaskar> int-e: ok
13:23:08 <Zemyla_> Hmm, can new packages define bew C-- primops?
13:23:14 <Fuuzetsu> is there something like concatMapM? like \x -> fmap concat . mapM x
13:23:14 <Zemyla_> *new
13:23:26 <hpc> :t \x -> fmap concat . mapM x
13:23:27 <lambdabot> (Monad f, Traversable t) => (a1 -> f [a]) -> t a1 -> f [a]
13:23:50 <hpc> :t mapM
13:23:51 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
13:23:53 <hpc> :t sequence
13:23:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:24:01 <hpc> :t traverse -- rather
13:24:02 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:24:55 <hpc> you want traverse
13:25:04 <Fuuzetsu> that still misses a concat
13:25:44 <hpc> where? the type is the same
13:25:48 <Zemyla_> And if so, is there any reason why Integer-simple is written in pure Haskell rather than with C-- primops for performing integer operations?
13:26:35 <Fuuzetsu> :t (\x -> fmap concat . mapM x) (undefined :: String -> IO [String])
13:26:36 <lambdabot> Traversable t => t String -> IO [String]
13:26:40 <Fuuzetsu> :t traverse (undefined :: String -> IO [String])
13:26:41 <lambdabot> Traversable t => t String -> IO (t [String])
13:31:50 <bennofs> Is there a way to return witnesses for constraints from type families in GHC haskell? For example, with the type family T a where T a = Int; T [a] = [T a], I know that Show (T a) can be satifisfied for any a. is there a way to prove this to GHC?
13:32:42 <heatsink> You can pass reified dictionaries
13:32:55 <heatsink> data Dict c where Dict :: c => Dict c
13:33:08 <bennofs> with type families?
13:33:26 <bennofs> how would I return a dictionary as a type?
13:34:00 <hexagoxel> kadoban: ah, there is --show-details=streaming .. i should have rtfm
13:34:18 <heatsink> I don't know how closed type families work
13:34:31 <bennofs> heatsink: how would it work for non-closed type families?
13:34:47 <safinaskar> EvanR: i cannot find -XStrict option even in ghc 7.10.1. is this option implemented? in what version?
13:35:37 <heatsink> For non-closed type families, you can often write type class instances so that GHC will auto-derive the Show method
13:36:24 <kadoban> hexagoxel: Oh hah, I missed it too
13:36:45 <bennofs> heatsink: say I had type family T a :: * with some instances. Then, can I define: f :: T a -> String; f = show ? No, I can't. I need to write f :: Show (T a) => T a -> a. I find this ugly if I can prove that all instances of T will have a Show instance
13:36:47 <heatsink> You can't get it automatically though, because it's still possible to instantiate functions at uninhabited types.
13:37:55 <heatsink> With open type families, you can have a function like (T Handle -> T Handle) -> Handle -> Handle, even though T Handle is uninhabited
13:38:18 <heatsink> so you can't assume that T a is showable even if every instance that you defined is showable
13:38:26 <hexagoxel> kadoban: i'll add a note for it to the `cabal run` documentation :)
13:38:34 <Cahu> Hi, I need to read an undefined number of bytes from a Handle until I see a delimiter of my choosing. Can you recommend an efficient way to do that ?
13:39:13 <Cahu> until now, I was using hGetLine but the code for '\n' collides with my protocol
13:39:38 <bennofs> heatsink: oh. This is kind of nice, since I guess I can define type family Void   which is a really uninhabited type? nice
13:40:30 <bennofs> ah, doesn't work :|
13:40:32 <heatsink> bennofs: I think it's necessary to introduce another parameter or constraint with the showable implementation.
13:40:41 <bennofs> there is still (undefined :: Void)
13:41:36 <heatsink> right
13:44:51 <cfoch> If I install a new version of GHC, will it re-write my already installed version of GHC? or it will 'add' a new version ?
13:45:58 <zbrown> cfoch: it would probably depend on what OS, your PATH variable, whether or not the version is append to the install directory and so on
13:46:12 <zbrown> cfoch: what OS and how are you installing
13:46:44 <cfoch> zbrown: I use Fedora
13:46:54 <hunteriam> Why haven't we made head a complete function yet?
13:46:55 <cfoch> and I am building it from the source
13:47:11 <zbrown> cfoch: was the other version of GHC you have installed also from source?
13:47:34 <madmax88> I'm trying to use the State Monad to implement a Stack, but I'm having problems. Here is my code; can a more experienced Haskeller help me understand what's going wrong? type NumberStack = [Double]
13:47:34 <madmax88> type OperatorStack = [(Double -> Double -> Double)]
13:47:34 <madmax88> pop :: State NumberStack Double
13:47:34 <madmax88> pop = do
13:47:34 <madmax88>   (x:xs, _) <- get
13:47:34 <madmax88>   put xs
13:47:35 <madmax88>   return x
13:47:39 <cfoch> I have installed 7.10 from a repo and I wish to install 7.8 
13:47:45 <cfoch> zbrown: ^
13:48:29 <zbrown> cfoch: so 7.10 installed via RPM and you want to install 7.8 as source?
13:48:49 <glguy> madmax88: If you have code to share you should put it on lpaste.net and not the channel
13:49:05 <madmax88> I'm sorry. I'll post it there
13:49:07 <glguy> madmax88: Try:  x:xs <- get
13:49:21 <glguy> madmax88: Since NumberStack isn't a tuple you can't pattern match it with one
13:49:21 <mniip> :t get
13:49:22 <lambdabot> MonadState s m => m s
13:49:36 <mniip> yeah no, not that one
13:49:53 <glguy> mniip: That's the one being used in the code above
13:50:27 <mniip> ah right
13:50:32 <cfoch> zbrown: well... actually I don't care if I install it from the source. I just want to install the 7.8 version. PD: I remember that when I tried to install from the binaries in the website of GHC I got an error, so someone here recommended me to install it from the repo. The thing is if I add another repo with another version of GHC it causes conflicts.
13:50:53 <cfoch> I've been following the instructions
13:50:57 <cfoch> in
13:51:03 <cfoch> https://github.com/ghc/ghc/blob/master/README.md
13:51:04 <mniip> State is a specialization of StateT
13:51:32 <cfoch> but I am not sure if it will re-write the version of GHC I have now
13:51:36 <zbrown> cfoch: what version of Fedora are you running?
13:51:55 <glguy> cfoch: I have 10 versions of GHC installed side by side (I should clean some older ones up) You just need to specify different --prefix when you ./configure them and it works out
13:51:58 <zbrown> cfoch: it all depends on configuration of both the RPM you installed as well as any configuration you pass when building from source
13:52:10 <zbrown> cfoch: ^^ what glguy said
13:52:28 <cfoch> zbrown: Fedora 20
13:52:55 <madmax88> That worked glguy. Thank you very much for your help!
13:53:38 <mniip> anyway
13:53:42 <mniip> get :: State s s
13:53:45 <mniip> no tuples
13:54:31 <zbrown> cfoch: I would do as glguy said and specify a prefix when you run ./configure - for example: ./configure --prefix=$HOME/opt/ghc-7.8
13:55:25 <cfoch> you install GHC as a normal user and not as a superuser?
13:55:42 <glguy> It's certainly common
13:57:00 <zbrown> cfoch: Unless I've got multiple users on a system that need to use the software, if I build software from scratch I only ever install it in my home directory
13:57:32 <zbrown> cfoch: personal technique only - I just prefer not to run into conflits with OS package manager
14:00:09 <cfoch> zbrown: I run the same command of your example
14:00:14 <cfoch> is this a good signal?
14:00:15 <cfoch> http://fpaste.org/204253/14275763/
14:00:18 <cfoch> --^
14:01:48 <zbrown> cfoch: looks like it's good.
14:01:57 <glguy> cfoch: Good except your building an old GHC 7.8.X
14:02:29 <glguy> But perhaps that's intentional
14:06:25 <cfoch> I have
14:06:26 <cfoch> ghc-7.8             ghc-7.8.1-release   ghc-7.8.2-release   ghc-7.8.3-release 
14:06:54 <cfoch> is not 7.8.3 the last one? :S
14:07:03 <zbrown> 7.8.4 is the most recent
14:07:19 <zbrown> cfoch: https://downloads.haskell.org/~ghc/7.8.4/
14:07:37 <cfoch> it is not in the github repo?
14:10:29 <jmcarthur> 7.10.1 is the most recent one, actually
14:10:44 <cfoch> we are talking about 7.8.x
14:10:44 <jmcarthur> but don't use that one if you are new
14:10:47 <jmcarthur> ah
14:13:05 * hackagebot hs-inspector 0.1.0.0 -   http://hackage.haskell.org/package/hs-inspector-0.1.0.0 (flbulgarelli)
14:13:07 * hackagebot fez-conf 1.0.3 - Simple functions for loading config files  http://hackage.haskell.org/package/fez-conf-1.0.3 (DinoMorelli)
14:20:51 <cfoch> zbrown: do I need to set a path?
14:21:31 <cfoch> (before execute "make" command )
14:23:08 <kaidelong> https://hackage.haskell.org/package/TypeCompose-0.9.10/docs/src/Control-Instances.html <-- is there any reason why this is not in base?
14:23:35 <kaidelong> I guess it's too specific
14:25:19 <iola> What's the preferred approach for maintaining invariants in data structures?
14:25:19 <iola> i.e. with `sumsTo10 :: [Int] -> Maybe TenList` would you have `mapTenList :: (Int ->
14:25:19 <iola> Int) -> TenList -> TenList` (with a comment), `mapTenList :: (Int -> Int) -> TenList -> Maybe
14:25:19 <iola> Maybe TenList`, or something else entirely?
14:25:27 <cfoch> zbrown: http://fpaste.org/204267/77818142/
14:25:39 <cfoch> not a good signal ^
14:25:59 <heatsink> What does that do, iola?
14:27:09 <iola> heatsink: Just an example of a function that might violate an invariant you
14:27:09 <iola> want to maintain. Should you do a runtime check or leave it up to the user?
14:28:16 <heatsink> What is the invariant, and how may it be violated?
14:28:53 <iola> heatsink: In the example, that a list of Ints sums to 10.
14:29:43 <EvanR> you can combine a runtime check with the type system to make sure you only use it after the runtime check was done
14:30:15 <EvanR> smart constructor
14:30:51 <kaidelong> anyway for that particular example (mapTenList) returning Maybe TenList is the correct behavior
14:30:57 <kaidelong> you could alternatively return [Int]
14:31:14 <kaidelong> think about (^2)
14:31:23 <kaidelong> it may or may not preserve the property
14:31:29 <kaidelong> depending on the list in question
14:31:39 <kaidelong> so you're being partial over your TenLists and should use Maybe
14:32:15 <kaidelong> if you explicitly drop the invariant you can just compose the constructor in to add it again and then you end up with Maybe TenList anyway
14:33:46 <iola> violate the invariant isn't too onerous?
14:41:39 <bennofs> is there a general data Some c = forall a. c a => Some a defined somewhere?
14:42:03 <heatsink> Maybe in the constraint package
14:43:07 * hackagebot c2hs 0.25.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.25.1 (IanRoss)
14:43:09 * hackagebot ip6addr 0.5.0.1 - Commandline tool to generate IPv6 address text representations  http://hackage.haskell.org/package/ip6addr-0.5.0.1 (MichelBoucey)
14:43:10 <heatsink> Actually, I don't see a use for that type
14:43:25 <heatsink> since the 'a' is existential, the constraint can't be used
14:43:36 <bennofs> SomeException = Some Exception
14:43:44 <bennofs> is an example
14:44:12 <heatsink> Oh I was reading it as a GADT
14:46:05 <heatsink> No, I don't know of a library providing that
14:47:55 <cfoch> could someone please give me a hand?
14:48:24 <cfoch> http://fpaste.org/204278/57921214/
14:48:36 <cfoch> I am trying to install GHC-7.8.3
14:50:59 <athan> bennofs: Now that's what I call ecapsulation volume 12!
14:51:25 <athan> are you going to throw that in a library? It seems very nice :)
14:51:57 <bennofs> athan: just need it one time now, so specialized it for a concrete c for now
14:52:01 <bennofs> athan: so no
14:52:31 <heatsink> cfoch: Are you trying to install from a binary distribution?
14:52:59 <cfoch> heatsink: no I am doing it from the source
14:53:01 <d34df00d> Hi!
14:53:08 <athan> bennofs: I think it would fit well in the constraints lib. Your code seems to work (so far) for me
14:53:21 <d34df00d> Say I have some kind of a trie with payload:
14:53:22 <cfoch> because there is not binary created for Fedora (I think)
14:53:26 <d34df00d> https://bpaste.net/show/362d3af3f7f8
14:53:30 <heatsink> cfoch: If you just want to install GHC, not build it, then you can use a binary distribution
14:53:48 <d34df00d> And say I want to be able to turn `Trie a ()` into `Trie a Int`, enumerating the nodes in some order.
14:54:03 <d34df00d> Do I understand correctly that Traversable is the typeclass for that class of tasks?
14:54:17 <heatsink> The binary distribution should work on any linux distribution.
14:54:31 <heatsink> any x86 or x86-64 distribution, at least
14:54:45 <heatsink> others are less well tested
14:55:02 <cfoch> I say it becuse it was built on CentOS
14:55:14 <bennofs> athan: here it is: http://hackage.haskell.org/package/exists-0.2/docs/Data-Exists.html
14:55:17 <cfoch> https://www.haskell.org/ghc/download_ghc_7_8_4#x86_64linux
14:56:09 <heatsink> The binary distribution only depends on a few libraries, so it should be ok
14:56:52 <athan> bennofs: Thanks :)
14:57:16 <cfoch> heatsink: I remember I had a problem with some library, but let me try again
14:57:24 <heatsink> Is it gmp?
14:57:48 <cfoch> IIRC, so... yes
14:58:07 * hackagebot tz 0.0.0.10 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.10 (MihalyBarasz)
15:00:06 <heatsink> cfoch: Some distributions have gmp10 instead of gmp3.  That's a bit difficult to work around, unfortunately.
15:01:40 <heatsink> cfoch: You can check if there's a compatibility library for your OS
15:01:45 <Hijiri> I remember there being two distributinos for gmp 10 and 3
15:03:08 * hackagebot cayley-client 0.1.2.1 - A Haskell client for Cayley graph database  http://hackage.haskell.org/package/cayley-client-0.1.2.1 (MichelBoucey)
15:03:21 <heatsink> Oh, that's new
15:07:53 <whittle> I am working on a private project called euler (a personal record of my solutions to Project Euler). Someone else has uploaded a package to Hackage name euler, and now when I try to `cabal install --only-dependencies`, cabal identifies the public euler package as the target. How do I convince cabal that I’m talking about the local package? 
15:08:49 <hvr> whittle: sounds almost like a cabal-install bug
15:09:25 <hvr> whittle: i.e. maybe it's worth filing a bug
15:10:23 <dgorbik_> I am implementing an ORM-style library. What's the best way to infer the fields based on the type of the structure I use as a result for a "select" type query?
15:10:50 <whittle> hvr: Will do. 
15:12:11 <cfoch> heatsink: http://dpaste.com/06RTJT4
15:12:12 <whittle> Yikes. 601 open issues on https://github.com/haskell/cabal/issues
15:13:34 <whittle> In the meantime, is there any way to manually specify to cabal how I want it to resolve a particular package? 
15:13:47 <heatsink> which libgmp do you have, cfoch?
15:14:32 <bergmark> whittle: give the filepath to it, eg `cabal install .'
15:14:35 <ij> bar doesn't see foo, shouldn't it see it? "do foo <- f; return bar where bar = g foo"
15:15:04 <bergmark> ij: no, the where binds outside the do block, use a let  inside the doblock instead
15:15:13 <ij> Ok!
15:15:30 <cfoch> http://fpaste.org/204285/58084314/
15:15:37 <cfoch> heatsink: ^
15:17:03 <heatsink> cfoch: The other GHC linux binary distribution is compiled against gmp10
15:17:30 <cfoch> I suppose. IDK, actually.
15:17:42 <cfoch> I installed it from a RPM repo
15:18:46 <heatsink> idk who makes the rpms
15:18:52 <cfoch> Petersen
15:19:03 <heatsink> Here's the linux x86-64 binary distribution https://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux
15:19:07 <cfoch> IDK what is the nickname of Petersen
15:19:30 <whittle> bergmark: That doesn’t seem to work. I think the issue is that my test suite has a build-depends on euler, and when cabal tries to solve its dependencies, it prefers the hackage euler over the fact that the package the test suite is in has "name: euler". 
15:19:43 <cfoch> heatsink: I'm using that binary distribution
15:20:35 <heatsink> The error message you showed me is that it cannot load libgmp.so.3
15:20:52 <lpaste> whittle pasted “euler.cabal” at http://lpaste.net/129805
15:20:55 <cfoch> because it does not exist maybe ?
15:21:07 <heatsink> And the file list you showed me has libgmp.so.10
15:21:32 <heatsink> So, try downloading the one that depends on libgmp.so.10 
15:21:43 <cfoch> IDK if it would be a good idea to create a symlink called libgmp.so.3 pointing to libgmp.so.10
15:21:52 <heatsink> That is not a good idea
15:22:18 <heatsink> They are incompatible library versions
15:22:46 <ttt_fff> anyone here familiar with frp-sodium? (I'm considering using it with ghcjs)
15:23:12 <cfoch> heatsink: ok, it could work
15:23:41 <hexagoxel> whittle: i find that strage, as the maintainers of hackage packages work with new versions of their packages as well, without that problem (?). but with what you told so far, this really sounds like a bug.
15:23:43 <cfoch> it was built against Debian... I have my doubts if it is going to work
15:23:52 <hexagoxel> whittle: ah, maybe because your version number is lower than the published one
15:24:18 <hexagoxel> which would not make the behaviour valid
15:27:22 <hexagoxel> (and it would mean that when you run tests on an older version for your hackage package, you would actually run the tests on the latest published version.. uh oh)
15:27:38 <whittle> hexagoxel: Ah. When I change the local version to 1.0.0, it now respects the local package. 
15:27:46 <whittle> I will definitely file this one. 
15:28:19 <hexagoxel> 602!
15:28:48 <whittle> Hahahaha
15:35:11 <hexagoxel> whittle: pls include the cabal version you use; this might have been introduced recently
15:37:52 <d-snp> if I'm in a do block, was there some way to extract a value from a Maybe and only do something with it if it's not Nothing?
15:38:10 <d-snp> I sort of recall there being some really neat way of doing it
15:38:41 <whittle> hexagoxel: Will do. 
15:39:13 <d-snp> the neat thing is when you're in the Maybe monad right? then you can just do <- and it'll only go to the next statement if it was a Just?
15:41:03 <cfoch> sinkheat: what distro do you use?
15:44:09 <cfoch> heatsink ^
15:44:50 <heatsink> cfoch: I've used Debian, OpenSUSE, and OS X
15:45:17 <frerich> Did anybody here successfully install 'llvm-general' on OS X? 'cabal install llvm-general' bails out for me because it cannot find the 'llvm-config' program (which I indeed don't have). I could install llvm manually (e.g. via Homebrew) but AFAIK that could cause some conflicts because OS X already ships with (parts of) LLVM.
15:46:00 <heatsink> Did you try installing from the binary archive that depends on gmp 10?
15:47:05 <frerich> heatsink: You mean, installing llvm from a binary archive? I didn't try anything except 'brew install llvm35' yet (just as a test, but now I see that llvm-config --prefix yields a directory which probably doesn't work).
15:47:30 <frerich> My understanding is that I already have a couple of LLVM things installed since I use clang - it's just that I have no llvm-config returning the right paths?
15:47:40 <heatsink> That question was for cfoch.
15:47:55 <frerich> Oh.
15:48:10 * hackagebot webcrank 0.1 - Webmachine inspired toolkit for building http applications and services.  http://hackage.haskell.org/package/webcrank-0.1 (purefn)
15:48:12 * hackagebot filecache 0.2.7 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.7 (SimonMarechal)
15:48:24 <cfoch> heatsink: yes... but -> http://dpaste.com/26Y8W99
15:50:29 <heatsink> That is strange.  Is that file missing?
15:51:04 <cfoch> oh... I have to leave the library of the university in 10 minutes
15:51:21 <heatsink> ok
15:52:15 <cfoch> but yes
15:52:18 <cfoch> it is missing
15:52:33 <cfoch> http://dpaste.com/2BHCG26
15:54:45 <heatsink> That seems like a mistake in the scipt.  Probably the correct name is ghc-pwd.
15:54:58 <cfoch> heatsink: ŵill you be on-line later, in 4 hours? 
15:55:27 <heatsink> I think so
15:58:10 * hackagebot yesod-purescript 0.0.5 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.5 (mp)
16:02:57 <whittle> hexagoxel: I’m not going to log the bug after all, because it’s not a bug, it’s just me being confused by the error message. I’m not able to reproduce the issue when I’m not doing something stupid. 
16:08:11 * hackagebot stringsearch 0.3.6.6 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.6 (davean)
16:15:42 <bazqux> Is it possible to write functions that pattern match based on the type of the argument without importing the constructors?
16:16:00 <bennofs> bazqux: do you have an example?
16:17:18 <bazqux> f (SomeType x) = g (SomeType x)
16:17:45 <bazqux> If I understand correctly that would deconstruct then reconstruct the type.
16:18:01 <hexagoxel> whittle: maybe your build-depends was on specific version? anyway, i could not reproduce either with a quick test.
16:18:06 <bennofs> bazqux: why is that necessary? because SomeType has a phantom type argument which you like to change?
16:19:06 <bazqux> bennofs: f works on a whole class of types and I need to write an implementation for each one.
16:19:33 <bennofs> bazqux: so f is a type class member?
16:20:56 <bazqux> bennofs: Yes I believe so. (I'm working with Aeson if you are familiar with that, I'm trying to write a new instance of FromJSON.)
16:21:19 <bennofs> bazqux: hmm, why can you not just write f x = x, or f = id ?
16:21:38 <bennofs> eh, I meant f = g or f x = f x
16:21:55 <bennofs> f x = g x * now finally correct
16:23:31 <bazqux> bennofs: Because: f (SomeOtherType x) = h (SomeOtherType x)
16:24:06 <bazqux> I'm starting to think that I'm going about this entirely the wrong way.
16:24:18 <bennofs> bazqux: that is actually the same type, just a different constructor then
16:24:40 <bennofs> bazqux: but I don't think that such a thing is necessary with Aeson. Can you explain what you really want to do?
16:25:15 <_ryan> hi what does this error mean? Error occured when launching bundle Main: Codec.Compression.Zlib: incorrect header check
16:25:33 <bennofs> _ryan: what do you get that error from?
16:25:57 <bazqux> bennofs: Well here is my code: http://lpaste.net/129807
16:26:21 <_ryan> once i upload my keter file to the /opt/keter/incoming..
16:27:06 <_ryan> bennofs: once i upload my keter file to the /opt/keter/incoming..
16:27:12 <bazqux> bennofs: Basically, I have some JSON code emitted by PHP, and one of the fields can either be a JSON array, or a JSON IntMap. I'd like to be able to parse this using JSON.
16:27:57 <bennofs> bazqux: the problem with that code is that there is no such thing as a "JSON intmap". there are only json objects, whose keys can be strings which could represent ints
16:28:12 * hackagebot binary-list 1.1.0.1 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.1.0.1 (DanielDiaz)
16:28:52 <bazqux> bennofs: Yes. But Aeson seems to think it can read into an IntMap so I think it supports reading those JSON objects as intmaps.
16:30:24 <bennofs> bazqux: that commented out line actually seems like it would work
16:30:36 <bennofs> bazqux: except you probably need to remove the I.fromList
16:30:48 <bazqux> bennofs: It compiles just fine. But it doesn't work.
16:31:20 <bennofs> bazqux: so PHPIntMap <$> parseJSON (Object v)
16:31:37 <bazqux> Regardless of the presense of I.fromList, it get errors at runtime: when expecting a [a], encountered Object instead
16:31:57 <bennofs> bazqux: those errors will not appear when you remove the fromList
16:32:16 <bennofs> bazqux: the fromList makes parseJSON choose the list instance, since it needs to return a list for fromList
16:32:35 <bennofs> bazqux: if you remove it, it will directly produce the intmap, which should be possible from an object
16:33:12 * hackagebot hackport 0.4.5 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4.5 (SergeiTrofimovich)
16:33:14 * hackagebot binary-list 1.1.0.2 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.1.0.2 (DanielDiaz)
16:33:32 <bazqux> bennofs: The error remains.
16:34:04 <bennofs> bazqux: ah, it's because aeson encodes intmaps as [[k1,v2],[k2,v2]]
16:34:11 <bazqux> bennofs: The fromList was lifted from the FromJSON IntMap instance, so I was trying to redo the work that was done there.
16:34:17 <bennofs> so a list of key-value lists
16:34:29 <bazqux> Yes.
16:36:35 <canadianpotato> Hello there
16:36:54 <canadianpotato> I'm new to haskell
16:36:58 <bennofs> bazqux: hmm, you could try: parseJSON (Object v) = PHPIntMap . map (\(k,v) -> (read k,v)) . M.toList <$> parseJSON (Object v)
16:37:05 <bennofs> bazqux: where M is from import qualified Data.Map as M
16:37:18 <canadianpotato> Is anyone even here?
16:37:24 <SwashBuckla> I've done some Haskell
16:37:29 <canadianpotato> I haven't done enough
16:37:35 <SwashBuckla> but I am currently having Haskell withdrawal sympoms
16:37:36 <canadianpotato> I'm doing the "Learn you a Haskell" tutorial
16:37:39 <canadianpotato> I'm at Curried Functions
16:37:44 <SwashBuckla> need to get re-acquainted with it
16:38:16 <hpc> canadianpotato: having trouble?
16:38:29 <canadianpotato> Yeah
16:38:45 <bazqux> bennofs: parseJSON v = PHPIntMap <$> parseJSON v -- Also compiles but retains the runtime errors.
16:38:49 <canadianpotato> I've only ever done some worked with imperative languges
16:39:00 <bennofs> bazqux: hmm, you could try: parseJSON (Object v) = PHPIntMap . map (\(k,v) -> (read k,v)) . M.toList <$> parseJSON (Object v)
16:39:19 <SwashBuckla> ah right
16:39:44 <bennofs> bazqux: oops, forgot a I.fromList there: parseJSON (Object v) = PHPIntMap . I.fromList . map (\(k,v) -> (read k,v)) . M.toList <$> parseJSON (Object v)
16:39:48 <SwashBuckla> canadianpotato: what specifically are you struggling with in Curried functions?
16:40:30 <bennofs> bazqux: anyway, bye, going to sleep :)
16:40:45 <canadianpotato> Hold on a sec
16:40:49 <hpc> canadianpotato: feel free to answer "i don't even know what i don't know" btw ;)
16:40:56 <canadianpotato> Sorry I went afk some sec
16:41:06 <bazqux> bennofs: Okay. Thanks for the help.
16:41:20 <SwashBuckla> hpc: haha
16:41:25 <SwashBuckla> I feel like that very often
16:41:27 <canadianpotato> I'm only an aleventh grader so I don't exactly have the advanced concepts down pat
16:41:43 <canadianpotato> Especially the calculus
16:41:48 <hpc> canadianpotato: what other languages do you know? currying it probably one of the easier concepts to translate
16:41:54 <canadianpotato> Java
16:42:22 <hpc> right, so let's extend java with a very un-javay feature
16:42:24 <canadianpotato> I can handle the concept
16:42:32 <canadianpotato> The problem is this: multThree :: (Num a) => a -> (a -> (a -> a))
16:42:37 <hpc> ah
16:42:38 <canadianpotato> I still don't get how these arrows
16:43:36 <Cale> canadianpotato: Well, a function of type A -> B is something which accepts an argument of type A, and produces a result of type B
16:43:38 <hpc> so, (a -> b) means "function from a to b"
16:43:38 <bazqux> bennofs: If you are still there, it looks like you've solved it! So thanks again. :-)
16:43:45 <hpc> multThree takes some number
16:43:59 <hpc> and returns a function of type (a -> (a -> a)), whatever that means
16:44:08 <hpc> and that returns a function of type (a -> a)
16:44:10 <hpc> which returns a
16:44:11 <Cale> So a function of type A -> (B -> C) is something which accepts an argument of type A, and produces (a function accepting an argument of type B and producing a result of type C)
16:44:20 <hpc> in java, that's be like writing
16:44:29 <hpc> multThree(5) and getting back some kind of Method object
16:44:41 <hpc> supposing the syntax was there, you could write
16:44:44 <Cale> canadianpotato: It might help to know that whenever you write f x y z in Haskell, it really means ((f x) y) z
16:44:52 <hpc> multThree(5)(6)(7) and get back a real number
16:45:14 <canadianpotato> One sec I'm thinking
16:45:40 <Cale> i.e. first apply f to x, obtaining some result which is another function, which gets applied to y, getting yet another function, which is lastly applied to z
16:45:50 <canadianpotato> So like nested functions?
16:45:56 <hpc> exactly that
16:46:03 <SwashBuckla> I personally would write it this way:   `multThree :: (Num a) => a -> a -> a -> a
16:46:09 <SwashBuckla> `
16:46:19 <hpc> SwashBuckla: the parenthesization is for demonstration
16:46:24 <canadianpotato> I'll have to go over type declarations
16:46:25 <SwashBuckla> ah I see
16:47:01 <canadianpotato> er
16:47:04 <canadianpotato> whatever those are called um
16:47:22 <hpc> type signature
16:48:48 <canadianpotato-> Sorry about that, connection drop
16:49:47 <canadianpotato-> Is anyone still here?
16:50:00 <mauris> 1499 people are!
16:50:23 <hpc> everyone left in the 5 seconds you've been gone
16:50:32 <hpc> there was a surprise birthday party to get to
16:50:46 <canadianpotato-> ah
16:50:49 <canadianpotato-> not again
16:50:57 <canadianpotato-> I'm new to IRC
16:50:59 <hpc> twist, it's your birthday
16:51:02 <hpc> surprise!
16:51:27 <canadianpotato-> :D
16:52:03 <canadianpotato-> Pattern matching, that's what it's called
16:52:06 <canadianpotato-> Yeah that's confusing
16:52:19 <hpc> anyway, you see how currying is just nesting a bunch of functions with a single parameter
16:52:24 <hpc> that's pretty much the whole thing
16:52:56 <canadianpotato-> Oh I was talking about the "(Ord i) => a -> b" sort of stuff
16:53:16 <Cale> canadianpotato-: I think you're referring to type classes?
16:53:50 <canadianpotato-> Yes
16:53:50 <mauris> or constraints!
16:54:00 <canadianpotato-> Yes constraints
16:54:01 <Cale> The Ord a constraint says that a must be a type which is an instance of the Ord type class. Ord is specifically a type class which defines operations like (<=), (>) and compare
16:54:04 <canadianpotato-> That's exactly it
16:54:12 <canadianpotato-> Alright
16:54:32 <canadianpotato-> But what about the variables used to define the constraints: i, a, and b. Do their letters matter, can they be used in the function?
16:55:06 <mauris> (Ord i) => a -> b  doesn't make much sense. you'd rather see something like:  (Ord a) => a -> b
16:55:13 <Cale> Which variable names you use doesn't matter, so long as they start with a lowercase letter. Whether they match or not matters.
16:55:17 <hpc> the letters don't matter, they're just names for variables
16:55:23 <mauris> where the variable inside the constraint occurs to the right of the =>
16:55:31 <canadianpotato-> So how does the matching work
16:55:43 <canadianpotato-> Does a have to be Ord but b can be anything?
16:55:47 <bennofs> canadianpotato-: same variable name means same type
16:55:47 <mauris> yep
16:55:54 <hpc> the variables can be anything that satisfies the constraints
16:55:58 <Cale> If you use the type variable in multiple places, it means those types have to be the same
16:56:00 <hpc> so for instance
16:56:02 <hpc> :t 5
16:56:03 <lambdabot> Num a => a
16:56:09 <hpc> pick an 'a', any 'a'
16:56:11 <Cale> For example, let's get away from type classes for a moment and look at the type of map
16:56:16 <hpc> but it has to be an instance of Num
16:56:18 <Cale> map :: (a -> b) -> [a] -> [b]
16:56:19 <hpc> > 5 :: Integer
16:56:20 <lambdabot>  5
16:56:23 <hpc> > 5 :: Double
16:56:25 <lambdabot>  5.0
16:56:51 <canadianpotato-> that's weird
16:56:56 <hpc> in map, the type variables are unconstrained
16:56:59 <Cale> map takes as its first argument a function of type (a -> b), so what type of argument and result the function has can be anything, however
16:57:20 <Cale> it then also takes a list of values of type a, and that has to be the same type a as was chosen for the function
16:57:27 <Cale> and it produces a list of values of type b
16:57:31 <Cale> and that's the same b
16:57:39 <hpc> > map ord "abcdefg"
16:57:41 <lambdabot>  [97,98,99,100,101,102,103]
16:57:47 <hpc> :t ord
16:57:48 <lambdabot> Char -> Int
16:57:59 <Cale> :t map ord
16:58:00 <lambdabot> [Char] -> [Int]
16:58:58 <Elite6809> map "abcdefg" "abcdefg"
16:59:02 <Elite6809> > map "abcdefg" "abcdefg"
16:59:04 <lambdabot>      Couldn't match expected type ‘Char → b’ with actual type ‘[Char]’
16:59:04 <lambdabot>      In the first argument of ‘map’, namely ‘"abcdefg"’
16:59:04 <lambdabot>      In the expression: map "abcdefg" "abcdefg"
16:59:16 <Elite6809> > map \_->"abcdefg" "abcdefg"
16:59:17 <lambdabot>  <hint>:1:5: parse error on input ‘\’
16:59:41 <canadianpotato> >map "this is a string"
16:59:45 <canadianpotato> > map "this is a string"
16:59:46 <lambdabot>      Couldn't match expected type ‘a → b’ with actual type ‘[Char]’
16:59:46 <lambdabot>      In the first argument of ‘map’, namely ‘"this is a string"’
16:59:46 <lambdabot>      In the expression: map "this is a string"
17:00:07 <canadianpotato> > map ord "this is a string"
17:00:08 <lambdabot>  [116,104,105,115,32,105,115,32,97,32,115,116,114,105,110,103]
17:00:17 <canadianpotato> :t map
17:00:18 <lambdabot> (a -> b) -> [a] -> [b]
17:00:20 <Cale> > map (*10) [1,2,3,4,5]
17:00:21 <canadianpotato> :t ord
17:00:21 <lambdabot>  [10,20,30,40,50]
17:00:22 <lambdabot> Char -> Int
17:00:48 <hpc> > map chr [0..] -- the ascii symbol names
17:00:50 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
17:00:56 <hpc> (also the rest of unicode)
17:01:23 <canadianpotato> So :t map takes a function that has an input of whatever and returns something else, then puts that into an array that returns another array?
17:01:48 <hpc> map takes a function
17:02:07 <hpc> and returns a function that takes a list and applies whatever to every element of it
17:02:13 <Cale> canadianpotato: :t is a command for the bot (and for ghci) which says "please tell me the type of the expression which follows"
17:02:19 <canadianpotato> Oh
17:02:23 <canadianpotato> I understand
17:02:23 <hpc> it also works in ghci
17:02:32 <canadianpotato> Yes I know
17:02:47 <canadianpotato> Sorry, shouldn't clog up the chat with commands
17:02:48 <Cale> canadianpotato: also, lists and arrays are not the same thing
17:03:02 <canadianpotato> What's the difference in Haskell?
17:03:06 <Cale> (we know what you mean here, but in general you might want to know that)
17:03:16 <hpc> arrays are what you're used to
17:03:20 <Cale> Arrays are structures which have fast random access
17:03:23 <hpc> lists are like LinkedList in java
17:03:47 <hpc> lists are defined as either, the empty list []
17:04:00 <hpc> or an element consed with another list (a:as)
17:04:10 <hpc> > 5 : []
17:04:12 <lambdabot>  [5]
17:04:16 <hpc> > 5 : 6 : []
17:04:18 <lambdabot>  [5,6]
17:04:32 <canadianpotato> > 5 (x:xs)
17:04:33 <lambdabot>      Not in scope: ‘xs’
17:04:33 <lambdabot>      Perhaps you meant one of these:
17:04:33 <lambdabot>        ‘x’ (imported from Debug.SimpleReflect), ‘s’ (line 142),
17:04:35 <Cale> > 1 : (2 : (3 : []))
17:04:35 <canadianpotato> oops
17:04:36 <lambdabot>  [1,2,3]
17:04:50 <Cale> > let (x:xs) = [1,2,3] in x
17:04:51 <lambdabot>  1
17:04:54 <Cale> > let (x:xs) = [1,2,3] in xs
17:04:55 <lambdabot>  [2,3]
17:05:02 <hpc> > let xs = 1 : xs in xs -- a sneak peek of what's to come
17:05:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:05:50 <canadianpotato> I do like this language
17:06:29 <canadianpotato> Thank you guys for being so friendly and helpful
17:06:37 <canadianpotato> When I get better at this language I'll be here doing the same
17:07:49 <mauris> i started learning haskell in 11th grade too!
17:08:03 <canadianpotato> Nice
17:08:06 <canadianpotato> How long ago was that?
17:08:08 <hpc> i started... two or three years into college
17:08:14 <hpc> 2010ish
17:08:34 <canadianpotato> Are you American?
17:08:40 <mauris> 2 years ago... hm. it might have been 10th grade
17:08:48 <mauris> and i'm from belgium
17:08:49 <canadianpotato> I find America seems to teach harder math at the same grade then Canadian schools do
17:08:51 <canadianpotato> Ah
17:09:12 <hpc> the US has really asymmetrical science and math education
17:09:27 <hpc> i took differential equations my last year
17:09:28 <canadianpotato> I wouldn't know haha
17:09:31 <hpc> most people finish with algebra
17:09:51 <canadianpotato> I'm still doing basic functions, although next year I'll be taking Advanced Functions, Data Management, and Calculus
17:10:08 <canadianpotato> Then I should be able to understand Lambda Calculus in Haskell if I couldn't before
17:10:57 <barrucadu> Calculus as taught in school and λ-calculus are very different beasts
17:11:25 <canadianpotato> Would that e university level?
17:11:29 <hpc> calc helps
17:11:42 <hpc> the chain rule is most people's first encounter with real recursion
17:11:45 <barrucadu> Depends what courses you do, "calculus" is a really broad term
17:11:56 <hpc> instead of naive "we can do this instead of a loop" like factorial
17:12:17 <barrucadu> I think a calculus is just a definition of a formal language + axioms to reason about members of the language, which covers a huge range of things
17:12:21 <mauris> i don't think your average maths education teaches lambda calculus at all?
17:12:33 <barrucadu> I would be surprised if it did
17:12:51 <canadianpotato> I am so underqualified haha
17:12:52 <mauris> it's more a comp.sci. thing, and even then it's more a functional programming thing
17:13:08 <barrucadu> Typically the calculus studied in maths courses is differential and integral calculi
17:13:09 <hpc> derivatives and integrals are all operations on functions, too
17:13:24 <hpc> you'll be well into functions-as-parameters territory before you even notice
17:13:47 <hpc> function composition is briefly covered too
17:13:48 <arkeet> "calculus" in the sense of lambda calculus just means something like "computational system" to me
17:13:57 <canadianpotato> I find functions as parameters pretty easy
17:14:04 <canadianpotato> It's just like in any other language, right?
17:14:27 <hpc> well, it's certainly one of java's weak points
17:14:40 <hpc> C too, just because of the nightmare of writing a function type signature
17:14:52 <kaiyin> How can you be sure that fmap (:) f a1 <*> f [a2, a3] will end up with something like f [a1, a2, a3] when f a is a applicative functor?
17:15:07 <arkeet> kaiyin: what's f?
17:15:20 <kaiyin> (f a) is a applicative functor.
17:15:20 <arkeet> in the first part 
17:15:25 <arkeet> fmap (:) f a1 <*> f [a2, a3] 
17:16:08 <arkeet> this is an expression, so f is a value, not a type
17:16:18 <mauris> i'm confused too. what's the type of f
17:16:45 <canadianpotato> I feel like a child here haha
17:16:46 <kaiyin> arkeet: I don't intend for this to be an expression, just see it as a kind of equation.
17:17:07 <arkeet> well, I don't understand it then.
17:17:30 <kaiyin> > fmap (:) [1] <*> [[2, 3]]
17:17:32 <lambdabot>  [[1,2,3]]
17:17:37 <mauris> canadianpotato: it gets a bit overwhelming sometimes! lots of scary talk about monads and monoids and whatnot
17:17:40 <kaiyin> that's a specific example.
17:17:56 <arkeet> ok, well
17:17:59 <arkeet> there are some Applicative laws
17:18:01 <arkeet> that say stuff like
17:18:10 <arkeet> fmap k (pure x) = pure (k x)
17:18:17 <arkeet> pure x <*> pure y = pure (x y)
17:18:28 <Hijiri> applicative functors are things on the type level
17:18:43 <arkeet> in your specific example, [1] = pure 1. (because that's what pure is for [])
17:18:45 <Hijiri> so (f a) would have to be a typpe-level expression
17:18:56 <Hijiri> to be an applicative
17:20:01 <arkeet> as a consequence,
17:20:38 <arkeet> fmap (:) (pure a1) <*> pure [a2, a3] = pure [a1, a2, a3]
17:20:47 <arkeet> for any lawful Applicative
17:20:57 <arkeet> idk if that's what you were looking for
17:21:24 <hpc> orc :: Lawful Applicative
17:22:31 <kaiyin> From the wikibook: And the Functor instance should satisfy the following law:   fmap f x = pure f <*> x  
17:22:48 <kaiyin> arkeet: how is <*> defined for a functor?
17:23:08 <barrucadu> It's not
17:23:10 <arkeet> <*> is part of Applicative
17:23:20 <hpc> it's different for every instance
17:23:56 <kaiyin> ok, i see. this means if a functor happens to be also applicative, then fmap f x = pure f <*> x , correct?
17:24:43 <arkeet> yes
17:25:35 <enthropy> that seems more like a requirement for the Applicative instance, not for the Functor instance
17:28:27 <mauris> are there other "bases" for applicative than pure and (<*>)?
17:29:15 <mauris> like, the way you can define a monad out of either (>>=) and return or join and return
17:29:16 <hpc> like (>>=) vs join, i assume?
17:29:28 <hpc> i remember reading about an alternate formulation
17:29:32 <hpc> very vaguely
17:30:19 <mauris> oh! https://wiki.haskell.org/Typeclassopedia 4.5
17:30:26 <mauris> that is cool
17:30:32 <jmcarthur> mauris: well, you need fmap in addition to join and return
17:30:57 <jmcarthur> mauris: fmap+join is enough for bind
17:31:16 <hpc> and return is pure
17:31:37 <jmcarthur> mauris: another formulation of applicative is pure and liftA2
17:31:45 <jmcarthur> mauris: (plus fmap, of course)
17:31:51 <hpc> a more narrow formulation of the three classes would be
17:31:56 <hpc> Functor has fmap
17:32:00 <hpc> Pointed has pure
17:32:10 <jmcarthur> bah, Pointed
17:32:14 <hpc> (Functor f, Pointed f) => Applicative f has (<*>)
17:32:27 <hpc> Applicative f => Monad f has join
17:32:37 <hpc> but yeah, Pointed's obsolete because of a free theorem
17:32:44 <enthropy> :t \f -> liftA2 (\ _ -> f) (pure ())
17:32:45 <lambdabot> Applicative f => (b -> c) -> f b -> f c
17:32:59 <jmcarthur> i've come around to ed's point of view that bind is more interesting than return and ap more interesting than pure
17:33:01 <enthropy> no need for fmap
17:33:17 <jmcarthur> enthropy: ah!
17:33:40 <hpc> enthropy: cool trick
17:34:04 <kaiyin> what does () stand for in haskell?
17:34:24 <enthropy> a tuple with 0 elements maybe
17:34:28 <jmcarthur> kaiyin: it is both a type and the only value of that type
17:34:39 <hpc> calling it a tuple gets into a whole big thing
17:34:43 <hpc> it's the unit type
17:34:51 <hpc> data () = ()
17:34:57 <enthropy> what's the big whole thing?
17:35:09 <enthropy> the mess of having no one-tuple?
17:35:11 <jmcarthur> it's more like a degenerate product than a degenerate sum, at least, in defense of the tuple point of view
17:35:27 <kadoban> There's one-tuples I think, or am I thinking of python?
17:35:27 <hpc> yeah, Void would be the degenerate sum
17:35:35 <hpc> one-tuple would be Identity, if anything
17:35:47 <jmcarthur> data Identity a = Identity a
17:35:54 <juanca_> () stands for an action with no return
17:35:55 <hpc> but the only place any tuple-y properties become interesting is 2 and up
17:36:05 <juanca_> you could say it's a void
17:36:07 <jmcarthur> juanca_: what?
17:36:10 <jmcarthur> no
17:36:25 <jmcarthur> juanca_: () actually has a value. Void does not (ignoring _|_)
17:36:26 <juanca_> i mean in a easy way, you could easily find it on IO actions
17:37:05 <jmcarthur> IO Void is an action that doesn't return
17:37:05 <kaiyin> enthropy: what did intend to show by this? :t \f -> liftA2 (\ _ -> f) (pure ())
17:37:06 <juanca_> ge: IO () means that there was and action with sid effects and with no return
17:37:16 <jmcarthur> IO () is an action that returns a ()
17:37:26 <jmcarthur> (again, all ignoring _|_)
17:37:35 <kaiyin> Isn't liftA2 defined in terms of fmap?
17:37:46 <arkeet> no
17:37:54 <arkeet> @src liftA2
17:37:54 <lambdabot> liftA2 f a b = f <$> a <*> b
17:37:54 <jmcarthur> hmm... i guess an infinite loop could be expressed using IO without it necessarily being _|_
17:37:55 <juanca_> i mean as a begginer it was easier for me that definition
17:37:57 <arkeet> well
17:38:00 <arkeet> yes
17:38:03 <jmcarthur> a sort of infinite loop at least
17:38:16 <arkeet> kaiyin: in the definition of Applicative you could take pure and liftA2 as primitive
17:38:16 <kaiyin> @src (<$>)
17:38:16 <lambdabot> f <$> a = fmap f a
17:38:21 <arkeet> and derive <*> from it
17:38:34 <arkeet> :t liftA2 id
17:38:35 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
17:39:33 <kaiyin> arkeet: clearly f <$> a = fmap f a
17:39:46 <canadianpotato> There we are
17:39:52 <canadianpotato> Finally
17:40:06 <arkeet> kaiyin: that's not the point though.
17:40:52 <arkeet> :t liftA2 id . pure
17:40:53 <lambdabot> Applicative f => (b -> c) -> f b -> f c
17:41:15 <canadianpotato> I was asking before, how would you chain functions like in Java
17:41:50 <canadianpotato> Ex. new java.util.Scanner(System.in).nextLine.toCharArray();
17:41:55 <arkeet> you can also define it using pure and this thing:
17:42:00 <arkeet> :t uncurry (liftA2 (,))
17:42:01 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
17:42:15 <nshepperd> there's an orthogonal definition of Applicative, descending from Functor: class Functor f => Applicative f where { pure :: a -> f a, (**) :: f a -> f b -> f (a,b) }
17:42:16 <arkeet> (which is exactly the data for a monoidal functor)
17:42:20 <enthropy> kaiyin: what arkeet explained
17:42:27 <jmcarthur> canadianpotato:  toCharArray . nextLine . Scanner
17:42:30 <nshepperd> lol yes that
17:42:39 <canadianpotato> oh
17:42:41 <jmcarthur> canadianpotato: System.in would be the argument you pass to that
17:43:25 <canadianpotato> Thank you, I'll try that
17:43:41 <jmcarthur> canadianpotato: it's not quite like in Java. i'm demonstrating function composition
17:44:11 <jmcarthur> canadianpotato: the most Java-like chaining would just look like   toCharArray (nextLine (Scanner System.in))
17:44:22 <jmcarthur> canadianpotato: or you could define an operator to make it more infixy
17:44:30 <nshepperd> I haven't able to find a similar definition for Monad that avoids making functor and applicative operators redundant
17:44:43 <mauris> :t (?)
17:44:44 <lambdabot> Not in scope: ‘?’
17:44:46 <jmcarthur> nshepperd: return and join doesn't make fmap redundant
17:44:54 <mauris> :t (&)
17:44:55 <lambdabot> a -> (a -> b) -> b
17:45:25 <nshepperd> jmcarthur: it makes (**) redundant though
17:45:43 <kaiyin> :t liftA2
17:45:44 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:45:52 <kaiyin> :t liftA2 id . pure
17:45:53 <lambdabot> Applicative f => (b -> c) -> f b -> f c
17:45:55 <jmcarthur> canadianpotato: Scanner(System.in) & nextLine & toCharArray    -- with the (&) operator mauris just showed the type of, which is found in lens (and maybe elsewhere?)
17:46:06 <jmcarthur> nshepperd: yup
17:46:23 <mauris> > "hello" & length & (^2)
17:46:24 <lambdabot>  25
17:46:25 <enthropy> would less people use HList if it depended on lens?
17:46:32 <jmcarthur> enthropy: yes
17:46:40 <nshepperd> I think there might not be a solution, because of the ordering choice implied by (**) / (<*>)
17:46:52 <arkeet> by ** you mean <**>?
17:46:52 <nshepperd> i dunno
17:47:14 <nshepperd> (**) = liftA2 (,)
17:47:17 <canadianpotato> I'll just keep learning and see how it goes
17:47:18 <kaiyin> :t id
17:47:19 <lambdabot> a -> a
17:47:21 <arkeet> oh.
17:47:35 <jmcarthur> canadianpotato: have fun, and feel free to ask more questions if you get stuck!
17:48:02 <kaiyin> arkeet: liftA2 requires (a -> b -> c), while id is (a -> a), so how can you feed id to liftA2?
17:48:26 <arkeet> a -> (b -> c)
17:48:28 <arkeet> let a = (b -> c)
17:48:31 <enthropy> jmcarthur: I just think it's really hard to remember what an Iso' (Record a) (HList a) and Iso' (TIC a) (Variant a) should be called
17:48:34 <jmcarthur> kaiyin: ($) is just a specialized id
17:48:46 <jmcarthur> :t id `asTypeOf` ($)
17:48:47 <lambdabot> (a -> b) -> a -> b
17:49:22 <enthropy> _Wrapping/_Unwrapping are exactly right for that problem
17:49:29 <jmcarthur> enthropy: i know some people roll their eyes at this kind of talk, and i truly believe i understand why, but i think lens is a bit of an abomination :)
17:49:46 <enthropy> well I think the same people would think HList is an abomination too
17:50:07 <jmcarthur> HList has a very directed purpose, limited scope, and fits well into the haskell ecosystem
17:50:53 <jmcarthur> it may not have the greatest, simplest design...
17:51:08 <jmcarthur> but at least it doesn't try to be all things and doesn't bring in a huge load of dependencies
17:51:38 <enthropy> right. Currently it's just profunctors&tagged
17:51:53 <arkeet> what's wrong with lens's dependencies?
17:52:06 <arkeet> :>
17:52:09 <kaiyin> > liftA2 id . pure 1
17:52:11 <lambdabot>      No instance for (Typeable f0)
17:52:11 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:52:11 <lambdabot>        arising from a use of ‘show_M812754003029649544731864’
17:52:13 <jmcarthur> to be fair, most of lens's dependencies are common or themselves small
17:52:34 <arkeet> they're all either platform stuff or stuff needed to implement lens itself.
17:53:12 <kaiyin> :t liftA2 id . [1]
17:53:13 <lambdabot>     Couldn't match expected type ‘a -> f (b -> c)’
17:53:13 <lambdabot>                 with actual type ‘[Integer]’
17:53:13 <lambdabot>     In the second argument of ‘(.)’, namely ‘[1]’
17:53:25 <kaiyin> > liftA2 id . [1]
17:53:27 <lambdabot>      Couldn't match expected type ‘a → f (b → c)’
17:53:27 <lambdabot>                  with actual type ‘[Integer]’
17:53:27 <lambdabot>      In the second argument of ‘(.)’, namely ‘[1]’
17:53:27 <arkeet> kaiyin: please experiment in /msg lambdabot
17:53:31 <enthropy> arkeet: at some point GHC-7.9 didn't compile lens... so that's something to be expected with ghc-7.11 some time?
17:53:45 <arkeet> enthropy: at some point ghc 7.7 didn't
17:53:50 <enthropy> of course
17:54:06 <arkeet> lens would be updated to work.
17:54:45 <jmcarthur> i don't mean to denigrate lens, and i like the core idea. i just think applying it pervasively just because you can unnecessarily leads to complicated code.
17:55:15 <jmcarthur> it's like if somebody made a library for writing OO and, instead of selectively applying it where it makes the most sense, spreads it everywhere they can
17:55:39 <arkeet> I don't think it makes sense to use lens everywhere.
17:55:54 <JoeyA> Why do the directions on the website for installing Haskell say to install alex and happy after installing MinGHC?
17:56:08 <enthropy> well "avoid lens" makes people do strange things like http://hackage.haskell.org/package/record-0.3.1/docs/Record-Lens.html
17:56:37 <lpaste> dgorbik pasted “Convert Integers” at http://lpaste.net/129812
17:56:52 <dolio> I don't think most of using lens has anything to do with writing OO-like code.
17:57:01 <arkeet> JoeyA: those programs are needed for building a lot of stuff.
17:57:04 <dolio> Or has that much to do with lenses proper.
17:57:12 <dgorbik_> is there anything I could improve in my conversion function?
17:57:18 <jmcarthur> enthropy: i think a lot of the lenses (such as traversals) make sense to just include with the types they work for, and none of them require special lens type definitions to make sense
17:57:34 <xplat> argh, fast-logger has so many underspecified dependencies
17:57:49 <dgorbik_> I don't like the predicate — I have to check both fst and snd, just not to implement dropWhileIncluding or something
17:57:58 <enthropy> jmcarthur: right, but does it make sense to then go on and provide definitions that are not as good as the ones in lens?
17:58:03 <JoeyA> arkeet: Oh.  In particular, all the Haskell Platform packages that are left out of MinGHC?
17:58:16 * hackagebot keycode 0.1 - Maps web browser keycodes to their corresponding keyboard keys  http://hackage.haskell.org/package/keycode-0.1 (ryanglscott)
17:58:36 <jmcarthur> enthropy: could you provide a strawman for this line of reasoning?
17:58:42 <xplat> i really don't want to try to guess what versions of these things it actually builds with :(
17:59:31 <enthropy> jmcarthur: that Record.Lens linked above uses RankNTypes which are unneeded
18:00:06 <jmcarthur> enthropy: i was thinking there would be no Lens type at all
18:00:50 <jmcarthur> enthropy: they are perfectly fine (better, in my opinion) without opaque names and weird ways of thinking of them as having subtyping rules
18:01:54 <enthropy> yes then you don't end up with "what, %%~ is just id?!"
18:02:18 <jmcarthur> enthropy: and, as is often advertised for lens, it's still compatible with lenses even if you don't assign it the name
18:03:59 <canadianpotato> #java
18:04:21 <jmcarthur> #haskell
18:04:48 <hpc> $perl
18:05:34 <enthropy> jmcarthur: so what should I do about the _Wrapping problem?
18:05:56 <jmcarthur> _Wrapping problem?
18:08:15 <xplat> i have a serious technical question!
18:08:32 <xplat> how do you build fast-logger so that it actually builds?!?
18:08:34 <enthropy> I don't know what to call an Iso (Record a) (HList a)
18:09:00 <xplat> enthropy: call it boo
18:09:57 <jmcarthur> enthropy: i admit that (Profunctor p, Functor f) => p (HList a) (f (HList a)) -> p (Record a) (f (Record a)) doesn't exactly roll off the tongue
18:10:13 <enthropy> oh the type doesn't matter that much
18:10:23 <xplat> jmcarthur: i think this is talking about the name of the value
18:10:37 <enthropy> it's that it would be nicer to have _Unwrapping Record
18:11:01 <xplat> i'm still partial to 'boo'.  or maybe 'oleg'.
18:11:32 <enthropy> heh there isn't an oleg function there yet
18:11:45 <jmcarthur> enthropy: oh you are talking about what happens if the type class is not there?
18:12:39 <enthropy> the Rewrapping class
18:12:41 <enthropy> yes
18:13:49 <jmcarthur> enthropy: i often write (without lens) functions named inFoo and asFoo, to serve a similar purpose, and i think a similar naming scheme would work for Isos. alternatively, the class could actually exist. it doesn't rely critically on the rest of lens as far as i can tell
18:14:41 <enthropy> yes what is that similar scheme you propose?
18:21:28 <jmcarthur> eh, i dunno. naming is hard. as i said, i think it's fine for the type class to exist in this case.
18:21:37 <jmcarthur> i thought i had an idea, but i can't make it work
18:28:06 <pharaun> hello, is there any good way to deal with an plugin api that is almost 100% macros in the haskell FFI
18:28:16 <pharaun> or am i just going to have to define a C layer in between?
18:28:37 <thoughtpolice> You can use the 'capi' calling convention with GHC 7.6+
18:28:57 <pharaun> https://github.com/weechat/weechat/blob/master/src/plugins/weechat-plugin.h#L992-L1015 <- nearly the entire api looks like this
18:29:12 <arkeet> "GHC will generate code to call f using the C API defined in the header header.h. Thus f can be called even if it may be defined as a CPP #define, rather than a proper function. "
18:29:16 <thoughtpolice> pharaun: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-capi
18:29:19 <pharaun> most looks like wrapper around the weechat struct
18:29:24 <pharaun> looking at that
18:29:34 <thoughtpolice> Yes, it does what arkeet says. So it basically operates like 'foreign import', but can be used for #define'd things or whatnot
18:29:42 <pharaun> perfect
18:30:00 <pharaun> i am on uh, lemme check ghc 7.8.3
18:30:43 <pharaun> ok great that looks like it should do the trick, lemme test it out
18:31:24 <dmj`> 7.10 doesn't have a binary release for osx?
18:32:41 <pharaun> hInit.hs:47:16: parse error on input ‘capi’
18:34:02 <pharaun> AH doh me
18:34:17 <pharaun> hm
18:34:52 <pharaun> yeah ok great i got it to use the capi, getting other build issues but i should be able to resolve from here on
18:34:55 <pharaun> thanks thoughtpolice arkeet 
18:41:19 <isd> Hey all. I'm pretty sure this exists, but I'm just not finding it in the docs: Does parsec have a parser that just unconditionally fails? (does the monad instance's fail do the right thing?)
18:41:35 <arkeet> empty/mempty
18:41:51 <arkeet> well, just use empty.
18:41:52 <arkeet> :t empty
18:41:53 <lambdabot> Alternative f => f a
18:42:39 <arkeet> I would avoid using fail.
18:43:48 <arkeet> isd: also, parsec provides something called `unexpected`
18:43:49 <isd> arkeet: thanks.
18:43:58 <arkeet> which can be used to write an error message I guess.
18:49:27 <Cale> It also has parserZero, parserFail, and unexpected in Text.Parsec.Prim
18:55:20 <td123> so, does anyone know what the deal is with integer-gmp vs integer-gmp2 that is shipped with ghc 7.10 src under the libraries directory?
18:55:37 <td123> like, why do we have integer-gmp and integer-gmp2
18:58:04 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Design/IntegerGmp2
19:01:27 <Cale> I don't entirely understand why implementing Integer by positive and negative cases like that was desirable or necessary though.
19:02:00 <Cale> It seems possibly questionable, as I'd imagine that GMP has specific stuff related to signed integers.
19:03:25 <int-e> Cale: afaiu the point is that the mpn (which only supports natural numbers) interface allows the caller to do the allocation for the space, while the mpz interface does its own allocation via malloc.
19:03:38 <Cale> ah
19:03:45 <Cale> That's bizarre
19:04:57 <alokbeniwal> hey
19:05:21 <Cale> hello
19:09:55 <int-e> Cale: also gmp's mpz type is implemented in a very similar fashion: http://lpaste.net/129813
19:10:34 <Cale> hah, okay :)
19:13:03 <int-e> in any case integer-gmp2 should solve the long-standing incompatibility between C libraries that use libgmp and the ghc runtime.
19:17:33 <pharaun> hello its me again. I have a new sticky issue. The #def depends on a c global var. Now i *set* it in the dll init so its non NULL and it exists. However when i attempt to compile the capi hs file it complains that it is undeclared
19:17:38 <pharaun> how do i deal with this in this case?
19:17:52 <pharaun> it is declared in the c wrapper file
19:22:12 <geekosaur> do you have an include file that the capi hs file can reference?
19:23:02 <pharaun> yes. oh :| the global is not defined there, ok i'm going to copy this include and move the global def there then
19:23:44 <geekosaur> well, normally you'd leave the definition where it is and put an extern declaration in the header file
19:23:55 <pharaun> hm k
19:25:57 <pharaun> geekosaur: ok your extern suggest did the trick, did have to modify the header to include the extern
19:26:00 <pharaun> thanks
19:38:21 * hackagebot mysql-simple 0.2.2.5 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.5 (BryanOSullivan)
19:43:31 <dmj`> main = putStrLn "hello world" produces a .cmm file of 520kb
20:08:07 <narvius> Hello; I've been wondering if there is an elegant way (ergo not writing each case out by hand) for extending Data.Function/on so that the first argument has more than two arguments
20:08:22 * hackagebot hmatrix-gsl-stats 0.2.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.2.1 (VivianMcPhail)
20:08:23 <narvius> like on3 :: (a->a->a->c)->(a->b)->b->b->b->c
20:08:35 <dmj`> :t comparing
20:08:36 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:11:25 <dmj`> narvius: I'm not sure that type makes sense
20:11:46 <dmj`> @src on
20:11:47 <lambdabot> (*) `on` f = \x y -> f x * f y
20:11:50 <dmj`> :t on
20:11:51 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:12:07 <narvius> Oh yeah, I mixed up the order.
20:12:23 <narvius> (b->b->b->c)->(a->b)->a->a->a->c, then
20:12:25 <dmj`> on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
20:12:51 <dmj`> on3 f g x y z = f (g x) (g y) (g z)
20:12:57 <dmj`> @def on3 f g x y z = f (g x) (g y) (g z)
20:12:59 <lambdabot>  Defined.
20:13:06 <narvius> It's a sort of hypothetical question anyways, I just write it out by hand, exactly like that.
20:13:22 <glguy> :t (liftA2 . liftA2) :: (x -> x -> y) -> (a -> b -> x) -> (a -> b -> x) -> a -> b -> y
20:13:23 <lambdabot> (x -> x -> y) -> (a -> b -> x) -> (a -> b -> x) -> a -> b -> y
20:13:26 <narvius> It works fine; was just wondering if there was a fancier way that doesn't involve specific definitions for each arity.
20:14:18 <dmj`> @pl \f g x y z -> f (g x) (g y) (g z)
20:14:19 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
20:14:24 <dmj`> there, much better
20:14:31 <glguy> dmj`: liftA2.liftA2.liftA2
20:14:39 <narvius> Haha, definitely much better
20:14:48 <dmj`> :t liftA2.liftA2.liftA2
20:14:49 <lambdabot> (Applicative f, Applicative f1, Applicative f2) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
20:15:04 <dmj`> ooo :) 
20:15:07 <dmj`> glguy: cool
20:15:24 <dmj`> @src liftA2
20:15:24 <lambdabot> liftA2 f a b = f <$> a <*> b
20:16:08 <dmj`> you could just chain fmaps for miles
20:16:33 <glguy> narvius: Haskell functions have arity 1, so doing stuff on arity tends not to work out
20:17:07 <glguy> dmj`: My chained liftA2s actually solve a different problem than your last lambda, though. I read what you wrote incorrectly
20:18:12 <narvius> glguy: Fair enough.
20:26:05 <jmcarthur> :t ap (fmap . fmap . flip fmap) . on
20:26:06 <lambdabot> (a -> a -> a -> b) -> (a1 -> a) -> a1 -> a1 -> a1 -> b
20:26:19 <jmcarthur> i disgust myself
20:26:28 <dmj`> dude nice
20:27:09 <dmj`> :t ap (fmap `fmap` fmap `fmap` flip fmap) `fmap` on
20:27:10 <lambdabot> (a -> a -> a -> b) -> (a1 -> a) -> a1 -> a1 -> a1 -> b
20:27:28 <jmcarthur> what have i done
20:38:24 * hackagebot hsignal 0.2.7 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.7 (VivianMcPhail)
20:41:07 <pepper_chico> guys, I'm trying to recall... what's the name for a optimization in... GHC I guess, for stripping out list copies from your final executable that are produced in simple operator like fold or.. append
20:41:26 <pepper_chico> s/operator/operations/
20:41:31 <heatsink> loop fusion?
20:41:44 <jmcarthur> what do you mean by "stripping out"?
20:41:57 <pepper_chico> I guess it's fusion, seems what is most spot on from google
20:42:07 <pepper_chico> jmcarthur yeah, eliminating
20:42:21 <jmcarthur> do you mean eliminating intermediate lists and turning two loops into just one loop?
20:42:22 <heatsink> like executing let ys = map f xs in sum ys without creating a list for ys?
20:42:34 <glguy> http://en.m.wikipedia.org/wiki/Deforestation_%28computer_science%29
20:43:08 <pepper_chico> heatsink, yeah, but I guess I've asked this long ago here not in the context of map or fold, but specifically append
20:43:29 <pepper_chico> heatsink and it was the same response I guess, I'm trying to confirm
20:44:57 <pepper_chico> I mean, it's was a general concern about too much copies of data and someone told me X would mostly vanish with it if it were simple trivial enough manipulation
20:45:21 <pepper_chico> X being the optimization
20:48:02 <heatsink> There's "deforestation" and "loop fusion."  Their meanings overlap.  I don't know how appending is related.
20:48:14 <pepper_chico> ok
20:48:44 <heatsink> There are ways of doing loop fusion with concatMap, which is a fairly general way of dealing with variable-length intermediate lists
20:49:30 <heatsink> Is concatMap what you wanted to know about?
20:55:11 <pepper_chico> heatsink no, it's the name for the technic for eliminating intermediate lists, it can only be fusion it seems
21:19:51 <xplat> i guess my question is really 'how can i install yesod without using stackage LTS?'
21:20:58 <kadoban> xplat: Why not just use stackage if it makes it easier?
21:22:00 <xplat> kadoban: because there is some other stuff i need to combine it with, so i don't think it'll make the overall thing easier
21:26:53 <kadoban> xplat: That's not really a dealbreaker AFAIK. I don't really have any other guidance though, I gave up trying without stackage, it seemed like a pain.
21:38:27 * hackagebot base-prelude 0.1.17 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.17 (NikitaVolkov)
21:42:46 <jume> Hello haskell enthusiasts. Question: This tutorial mentions that arrows have 6 robots. What are robots in this context? http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
21:44:54 <arkeet> it describes them in the second section.
21:45:36 <Cale> lol, robots
21:45:45 <arkeet> lol
21:47:43 <mgsloan> Combinators: Robots in Disguise
21:55:18 <jokester> lol
21:55:29 <jle`> lol
22:02:22 <f-a> I have a collection of datatypes; I fond myself filtering, grouping, sorting, etc. them frequently, i.e. doing SQLy things with some ad hoc functions.
22:02:51 <f-a> Is thee a 'standard' way to convert some [Type] to a table and then a query language to extract info from that?
22:03:20 <f-a> what I am doing is not difficult but feels like an already solved problem
22:03:26 <Javran> I'm messing around with RTS hooks, wondering what's the easiest way to hit stack overflow and out of heap error respectively?
22:06:01 <kadoban> > foldl (+) 0 [1..10000000]
22:06:04 <Axman6> f-a: GHC has an extension which gives you many SQL like operations in list comprehensions
22:06:05 <lambdabot>  mueval-core: Time limit exceeded
22:06:13 <kadoban> Bah
22:06:55 <kadoban> > foldl (+) 0 [1..1000000]
22:06:57 <lambdabot>  *Exception: stack overflow
22:07:14 <Axman6> f-a: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#generalised-list-comprehensions
22:07:48 <f-a> thanks Axman6 
22:12:09 <Javran> kadoban: it acutally works fine on my machine, even with [1..]. the program seems to be killed by OS before rts has a chance to worry about it :(
22:13:23 <jume> thanks everyone
22:14:26 <Javran> never mind, problem solved by "-with-rtsopts -M1m"
22:27:46 <rishi_> Hi,
22:28:16 <rishi_> I had few questions . Is there any api in haskell that can communicate with jade gateway
22:28:49 <rishi_> and also with some front end technology like jqury and angular js ?
22:30:45 <ReinH> f-a: there isn't a standard way but edwardk has a nice package
22:30:58 <ReinH> @hackage tables
22:30:58 <lambdabot> http://hackage.haskell.org/package/tables
22:31:24 <f-a> thanks ReinH 
22:32:28 <ReinH> rishi_: not sure what jade gateway is. Generally frontends communicate with backends via a JSON api. Various web packages like scotty and yesod can be used to build JSON apis.
22:33:05 <rishi_> ReinH: Can haskell replace spring mvc framework ?
22:33:31 * hackagebot config-value 0.2 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.2 (EricMertens)
22:33:33 * hackagebot esqueleto 2.1.2.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.2.2 (MichaelSnoyman)
22:33:33 <ReinH> More or less, sure.
22:35:28 <rishi_> can you please provide me some links to learn more about to make serverlet in haskell
22:36:00 <dmj`> rishi_: what is a serverlet
22:36:34 <ReinH> dmj`: I think that's what Java people called a web service a decade ago.
22:36:38 <rishi_> A code that run on server and catches queries which are thrown by users
22:36:52 <ReinH> @google yesod book
22:36:54 <lambdabot> http://www.yesodweb.com/book
22:36:54 <lambdabot> Title: Yesod Web Framework Book- Version 1.4
22:37:29 <rcyr> I dislike crossposting... but does anyone has hanging/freezing issues with emacs + interactive haskell mode? 
22:37:39 <dmj`> ReinH: ah, that's what I thought :)
22:37:59 <ReinH> rcyr: you might have better luck if you describe your problem
22:38:19 <ReinH> There's also #haskell-emacs, fwiw
22:38:44 <dmj`> rishi_: you have sql on the client?
22:39:08 <rishi_> not sure i am planning to use orient db
22:39:22 <rcyr> ReinH: I open a .hs file then start the interactive haskell mode by doing: haskell-interactive-bring (it works well), then I start to write: main = putStr<emacs freeze here>
22:39:32 <rcyr> ReinH: Ah, didn't know about #haskell-emacs
22:39:58 <ReinH> rcyr: Chris Done hangs out in there so it would be a good place to ask
22:41:05 <dmj`> rishi_: so you want to make a web server in haskell?
22:41:30 <ReinH> rcyr: you might find some error in the haskell process log, it's a buffer (that you might have to enable in customize-group RET haskell)
22:42:01 <rishi_> dmj` : jade gateway throw  output in java and I wanted some intermediate which can catches that output and give it to any frontend technology.
22:42:29 <ReinH> what does "output in java" mean?
22:42:35 <rishi_> dmj`: yup i wanted to make web server in haskell
22:42:38 <dmj`> rishi_: what is a jade gateway
22:42:43 <ReinH> The Java language isn't used as a transport protocol afaik
22:42:52 <rishi_> http://jade.tilab.com/
22:45:28 <ReinH> Well, it seems unlikely that there are any Haskell bindings for whatever protocol JADE uses for interop.
22:47:05 <rishi_> okay so is there any api in haskell that can talk with java
22:47:51 <ReinH> I do enjoy the fact that JADE is an acronym for Java Agent Development Framework. Those Java folks sure do love their acronyms, no matter how much of a stretch they have to make to create them.
22:48:28 <ReinH> rishi_: There are a variety of ways that two processes can communicate, regardless of language.
22:48:32 <ReinH> @google interprocess communication
22:48:33 <lambdabot> http://en.wikipedia.org/wiki/Inter-process_communication
22:48:33 <lambdabot> Title: Inter-process communication - Wikipedia, the free encyclopedia
22:49:17 <rishi_> ReinH : thanks a lot I will look at it .
22:49:54 <dmj`> rishi_: yea, maybe ditch jade for a custom grammar on tcp, or just use REST
22:49:58 <ReinH> TCP sockets (e.g., used for HTTP communication via a JSON API) and messaging systems are common
22:50:43 <ReinH> Haskell has good support for a variety of IPC techniques
22:51:13 <Geraldus> o/
22:51:22 <ReinH> Geraldus: \o
22:52:06 <rishi_> ok thanks a lot guys . I will look at it .
22:52:17 <Geraldus> How strip binary option can be configured for cabal project? I need to turn it off (I'm trying to build Haste project)
22:53:23 <ReinH> Geraldus: --enable-executable-stripping (or --disable-...)
22:53:39 <rishi_> and can anyone suggest me particular person to whom i can contact regarding to this questions .
22:53:46 <ReinH> As seen in the user guide https://www.haskell.org/cabal/users-guide/installing-packages.html
22:54:28 <ReinH> rishi_: Well, some of us may be available for consulting services. If you have general questions, you should address them to the channel.
22:54:50 <rishi_> ReinH: ok, I will . thanks.
22:55:38 <ttt_fff> so I'm porting http://www.htmlgoodies.com/html5/javascript/drag-files-into-the-browser-from-the-desktop-HTML5.html#fbid=PoKb45vN7Nd to ghcjs ... and the problem I'm running into is: I can trigger a callback on the DROP event -- however, how do I read the files?
22:55:42 <Geraldus> ReinH: thank you a lot, man! (:
22:55:49 <ttt_fff> in ghcjs, is there an example of reading dropped files ?
22:55:52 <ReinH> Geraldus: yw :)
22:56:09 <ttt_fff> err, sorry, meant for #ghcjs, not #haskell
22:56:17 <dmj`> ttt_fff: there is #ghcjs
22:56:28 <ttt_fff> dmj`: right
22:56:34 <Geraldus> and how I could set this flag permanently in `.cabal` file?
22:56:41 <Geraldus> a ghc-option?
22:57:34 <glguy> Geraldus: try adding: executable-stripping: False to your ~/.cabal/config
22:58:19 <mniip> is it 'safe' to unsafeCoerce a polymorphic value to a type that is a subset of that type
23:00:02 <glguy> mniip: You'll probably get a better answer if you give more detail
23:00:04 <Geraldus> glguy: this option is not recognised neither in executable section, nor top level
23:00:16 <glguy> Geraldus: which version of cabal?
23:00:18 <ReinH> Geraldus: I'm not sure if you can set it in a project's cabal file, actually.
23:00:51 <glguy> Oh, right. I specifically was talking about "~/.cabal/config"
23:00:55 <ReinH> glguy: I believe the question is about a project cabal, not the user cabal config file
23:01:08 <Geraldus> cabal version 1.20.0.3
23:01:08 <ReinH> *project cabal file
23:01:30 <Geraldus> oh, I've understood
23:01:50 <mniip> glguy, I have a value of a type analogous to Any (HValue), I know the expected type but it could be a polymorphic value from the supertype of the expected type
23:01:51 <ReinH> Geraldus: Oddly enough, the project cabal file doesn't have a field for cabal options.
23:02:17 <Geraldus> truely
23:02:18 <ReinH> Geraldus: you might write a tiny shell script that runs cabal with the options you want
23:02:48 <Geraldus> or even create an alias, I guess. 
23:03:15 <ReinH> Geraldus: it's not a bad idea to have a little shell script that keeps build options consistent anyway
23:03:35 <ReinH> (it would be better if they could be put in the cabal file, but so it goes)
23:04:12 <glguy> You can put a cabal.config in your package directory
23:04:12 <Geraldus> not a big deal (fish shell helps a lot!), I did not found it yesterday by myself, so just wanted to be certain, that this is not possible for now. 
23:04:34 <ReinH> glguy: oh yeah, I forget about that
23:04:41 <ReinH> Geraldus: glguy has the answer, as usual
23:05:45 <Geraldus> ReinH: I want not to strip only that executable, which was generated by haste compiler, in other words, text files with javascript code, which could not be stripped.
23:06:18 <ReinH> Does your project cabal file have multiple executables?
23:06:38 <Geraldus> glguy: this is quite common practice for me, thanks for suggestion!
23:06:49 <Geraldus> ReinH: nope
23:07:50 <ReinH> Geraldus: Ah, then you can set it for the entire project, in the cabal.config file.
23:08:06 <ReinH> If you needed to enable it for some but disable it for others you might be out of luck
23:08:28 <glguy> Geraldus: glad to help :)
23:08:39 <ReinH> glguy: I'm actually surprised that you can't specify cabal options in the cabal file o_O
23:08:41 <glguy> or at least glad to almost help!
23:08:46 <ReinH> Seems like an oversight
23:08:54 <ReinH> Or maybe I overlooked something myself
23:09:07 <Geraldus> well. I tried to write `flags: disable-executable-stripping`. It's not correct. 
23:09:18 <ReinH> Surely some projects have common cabal options
23:10:19 <ReinH> The documentation on cabal file options seems a bit sparse. Does anyone know if this is where I should be looking? https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
23:10:41 <glguy> ReinH: I figured out that it supported project-level config by monitoring stat64 calls with dtruss...
23:10:47 <ReinH> glguy: wat
23:10:51 <glguy> I'm not sure if all of this stuff is written down
23:11:03 <ReinH> glguy: Oh, well, I mean, anyone could figure that out... o_O
23:14:36 <Geraldus> glguy: I can write only constraints in cabal.config file. How can I specify mentioned flag there?
23:17:38 <glguy> The setting I wrote earlier would just go on its own line
23:18:01 <glguy> But I'm not sure what your question meant exactly
23:19:49 <Geraldus> glguy: you're understood right, your suggestion was 100% correct (:
23:24:07 <safinaskar> i cannot open link http://ghc.haskell.org/trac/ghc/wiki/Building/Using
23:24:13 <safinaskar> can you open it?
23:25:04 <f-a> nope safinaskar 
23:25:50 <safinaskar> why? this is wrong link or something bad happened with wiki?
23:27:05 <ReinH> safinaskar: Doesn't seem to be available, not sure why. Maybe someone in #ghc knows.
23:43:34 * hackagebot Zora 1.1.22 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.22 (bgwines)
