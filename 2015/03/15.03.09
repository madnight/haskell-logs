00:00:19 <nshepperd> SrPx: are you worrying about MonadWhatever contraints infecting all your code? type inference is smarter than that, the constraints only propagate to parts that actually need it
00:00:50 <dmj`> jle`: oh for date parsing?
00:00:51 <jle`> SrPx: if you're trying to describe the effects of a card, one nice solution is to just reify the effects of the card as an ADT with constructors representing effects, etc.
00:00:53 <jle`> dmj`: yes
00:01:02 <jle`> SrPx: I believe there was a tutorial on a 7 wonders clone that did something like this
00:01:23 <jle`> data CardEffect = DoDamage Int | Heal Int | ...
00:01:40 <jle`> FlipCoinSomething (FlipResult -> Int)
00:02:02 <dmj`> jle`: you can parse time with the time package
00:02:14 <jle`> yeah but i need to look up the atom spec and everything v.v
00:02:24 <jle`> if `feed` is the best that's out there then i can go and do it
00:06:32 <HeladoDeBrownie> you could also probably make that FlipCoinSomething less inscrutable (i.e., more scrutable) by, instead of a function something like Bool -> CardEffect, receiving two CardEffects as arguments and branching based on the result.
00:07:04 <HeladoDeBrownie> this may or may not work depending on the rest of your rules but it definitely helps if you want to analyze the structure of effects
00:09:43 * hackagebot farmhash 0.1.0.1 - Fast hash functions.  http://hackage.haskell.org/package/farmhash-0.1.0.1 (abhinav)
00:09:43 * hackagebot fgl 5.5.1.0 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.5.1.0 (IvanMiljenovic)
00:11:08 <SrPx> Hmm okay, I guess I understand how free monads could be used for this. But indeed, as I'm having only one interpreter, maybe it is not so bad to do it as I'm doing.
00:11:45 <SrPx> My actual issue is that I could, in a future, depend on another monad (I don't know... I didn't think I'd depend on Random) and then I'd have to rewrite the definition of every card I've written so far
00:12:08 <SrPx> this is how I'm defining a card effect: http://lpaste.net/124256 see erk
00:20:16 <nshepperd> SrPx: if you just add a new card with a new effect, you shouldn't need to rewrite anything
00:21:01 <nshepperd> for instance, erk still works if you add launchMissiles :: (MonadIO m) => m () to your list of cards or whatever
00:21:26 <SrPx> nshepperd: suppose that a card effect needs a player decision. So it now depends on the IO Monad. This would mean that it has a different type from other card effects. I can't have a list of card effects, for example... or compose them. Right? Maybe I'm overthinking this but...
00:21:54 <SrPx> hmm..
00:22:07 <SrPx> how?
00:22:10 <nshepperd> erk, as you've currently written it, is polymorphic
00:22:43 <mrkkrp> Hello. Can you install `ghc-mod'? I can't: http://lpaste.net/124257 :(
00:22:45 <nshepperd> it can turn into a (Player -> RandT IO Player) or whatever is need by itself
00:23:51 <SrPx> nshepperd: uh? It creates the monad transformer on the fly? I'm confused. Let me test this
00:24:54 <nshepperd> it's not any specific type. '(MonadRandom m, Functor m) => Player -> m Player' means that it can be whatever you want, as long it allows taking random numbers
00:26:33 <SrPx> yes but how it knows how that "RandT IO Monad" is the right type when you have a list with both lanchMissiles and erk...
00:27:00 <nshepperd> well, let's take launchMissies :: (MonadIO) => Player -> m Player
00:27:50 <nshepperd> 'cards = [erk, launchMissiles]' most general type is (MonadRandom m, MonadIO m, Functor m) => [Player -> m Player]
00:28:22 <nshepperd> the type inferencer automatically unifies the constraints
00:28:59 <nshepperd> you can instantiate it as 'm = RandT IO' in your runGame function
00:32:59 * SrPx is thinking
00:33:06 <jle`> SrPx: as you have it written, your functions can work on any MonadRandom...not just Rand
00:33:20 <jle`> it's like, if you had a value `x :: Monoid m => m; x = mempty`
00:33:36 <jle`> mappend x "hello" = "hello"
00:33:48 <jle`> mappend x (Sum 3) = Sum 3
00:33:54 <jle`> you can use x with any Monoid
00:34:15 <jle`> it knows what to instantiate x as by type inference
00:34:21 <jle`> if you use x with "hello", it knows that x is ""
00:34:39 * hackagebot netwire-input-glfw 0.0.3 - GLFW instance of netwire-input  http://hackage.haskell.org/package/netwire-input-glfw-0.0.3 (Mokosha)
00:35:26 <haasn> SrPx: Because you probably have ‚ÄúrunStateT‚Äù somewhere in your code.
00:35:43 <haasn> (If you didn't, there's not a whole lot you could do with a StateT)
00:36:31 <haasn> SrPx: Think about ‚Äúask >>= put‚Äù. It involved both MonadReader and MonadState
00:37:16 <haasn> Whether that's ReaderT s (StateT s m) or StateT s (ReaderT m) probably ultimately depends whether you're using runStateT s (runReaderT r x) or runReaderT r (runStateT s x)
00:37:18 <haasn> Does that make sense?
00:38:30 <haasn> Of course, in a real program it's more common to have something like type MyMonad = ReaderT Foo (StateT Bar)
00:38:40 <haasn> and then declade all of your things as :: MyMonad whatever
00:39:01 <pavonia> Is "fail" the correct way to make a Parsec parser fail with a custom error message?
00:39:55 <haasn> pavonia: Looks like it; it's defined as parserFail
00:40:30 <haasn> pavonia: http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Prim.html#v:parserFail has some relevant things
00:40:33 <Cale> pavonia: unexpected might be better
00:40:38 <pavonia> Oh, I haven't seen parserFail
00:40:38 <Cale> unexpected :: Stream s m t => String -> ParsecT s u m a
00:40:56 <haasn> (<?>) is also a type of failure
00:41:06 <haasn> also replaces the message of a type of failure, rather
00:41:14 <pavonia> I want it to fail if a certain assertation fails
00:41:29 <Cale> Yeah, in that case use unexpected
00:41:41 <pavonia> Okay
00:42:30 <haasn> What's the difference between unexpected and fail/parserFail?
00:44:04 <haasn> notFollowedBy p =  (try p >>= unexpected . show) <|> return ()  <- could this have been ‚Äòfail‚Äô instead?
00:46:53 <haasn> Seems to be a different error message. I can't figure out another difference
00:48:08 <haasn> They are virtually identical, except for the error message. One uses (Message s) and the other (UnExpect s) but otherwise their definitions are identical
00:48:10 <haasn> The more you know!
00:51:23 <Cale> Yeah, parserFail would be just as good, depending on what error message you want. I tend to pretend that 'fail' itself doesn't exist though
00:53:05 <haasn> Cale: I still like fail, as long as it isn't defined to be ‚Äúerror‚Äù. For example, it means you could write a parser like this: do string "foo"; 0x123 <- number; X a b c <- someParser; ...
00:53:16 <haasn> And the ‚Äú0x123 <- number‚Äù in particular would fail if the number parsed is not 0x123
00:53:37 <Cale> Yeah, I just don't believe it should be part of the Monad class
00:53:46 <haasn> Right. MonadFail or something would be more appropriate
00:54:03 <Cale> So, I tend to avoid it, because it'll result in work later when someday it gets moved :)
00:54:20 <Cale> (at least using it *explicitly* might)
00:57:16 <haasn> Pattern match failures are the whole reason for being of ‚Äòfail‚Äô, so if it got moved I would find it hard to imagine that adding an explicit pattern match to your do-block would not include a MonadFail constraint as well
00:57:36 <SrPx> Okay guys, I kinda get what you are trying to say, but I'm still confused. Notice this: http://lpaste.net/124258 card effects won't compose on this case because I used a different monad for one of them (IO)
00:58:06 <haasn> (Although it gets a bit trickier, since you probably don't want a MonadFail for things that are virtually guaranteed to succeed, like when your pattern only has one constructor or when it's irrefutable)
00:58:12 <Cale> Well, yeah, I suppose in any case where you're using a specific monad, it's not likely to be a problem, while cases where you're using it polymorphically would require work
00:58:25 <Cale> haasn: Oh, that's not tricky, that's what GHC already does
00:58:30 <jle`> SrPx: what's the error?
00:58:42 <Cale> haasn: And you just about fully described it :)
00:58:45 <SrPx> maybe I just need something like "evalRandIO" that works for `RandT g IO Player" ?
00:59:04 <SrPx> jle`: updated with error
00:59:50 <haasn> SrPx: What's the type of evalRandIO?
00:59:54 <SrPx> do you guys suggest a course/book/whatever for learning about monad transformers? All I've learned was from accident so I'm kinda lacking on this
01:00:03 <Cale> haasn: Haskell 1.4 specified that a pattern is non-failable if it's irrefutable, or it's a constructor from a type with only one constructor applied to some non-failable patterns, and used a simpler translation of the do-notation in that case. GHC still does that.
01:00:07 <jle`> there's that monad transformers step-by-step
01:00:13 <jle`> but your thing here doesn't have anything to do with monad transformers
01:00:39 <SrPx> haasn: evalRandIO :: Rand StdGen a -> IO a ... okay, I get it, but then what do I do.
01:00:40 <haasn> SrPx: Ah, evalRandIO is tricky. It isn't polymorphic enough
01:00:47 <jle`> SrPx: evalRandIO takes a concrete type, `Rand StdGen a -> IO a`
01:00:49 <jle`> why don't you just bind it
01:00:52 <jle`> like normal
01:00:56 <haasn> SrPx: It forces your type to by Rand StdGen a = RandT StdGen (IO a
01:01:03 <haasn> err
01:01:04 <jle`> p <- erk >=> sayHi
01:01:06 <SrPx> jle`: hm?
01:01:06 <haasn> RandT StdGen Identity a
01:01:15 <jle`> because both erk and sayHi can be IO
01:01:23 <jle`> IO is a MonadRandom, a Functor, and a MonadIO
01:01:30 <haasn> SrPx: But your (sayHi >=> erk) has type RandT StdGen IO here
01:01:46 <jle`> it doesn't
01:02:06 <jle`> erk and sayHi don't have anything to do with RandT
01:02:16 <haasn> Oh, yes. IO is also an instance of those things
01:02:22 <jle`> they can be anything that is MonadRandom, Functor, and MonadIO
01:02:26 <jle`> so...IO is a candidate
01:03:25 <jle`> p <- sayHi =<< erk player
01:05:00 <jle`> this is similar to what happens if you have something like x :: Num a => a, y :: Fractional a => a, and z :: Real a => a, and you did x + y / z
01:05:08 <jle`> it picks a type that is an instance of all of those typeclasses
01:05:20 <jle`> ie, Double
01:07:30 <nshepperd> or, if you feel like making the randomness deterministic, p <- evalRandT (sayHi =<< erk player) (mkStdGen 7)
01:10:48 <SrPx> okay I'm still really confused
01:10:55 <SrPx> but as you said, IO has all the needed instances
01:11:21 <SrPx> so "print <<= (erk >=> sayHi) player" just works ... 
01:11:29 <favetelinguis> when using C code from haskell do i need to cara about garbage collection in my C code, newver understood if garbage collection only relates to OOP and destructors?
01:11:44 <SrPx> which means I can compose card effects with >=>
01:12:00 <SrPx> so, hmm... 
01:12:24 <SrPx> that means my code is fine how it is? So, what if I have a card effect that isn't random? I just use the identity monad?
01:13:32 <SrPx> Or just... foo :: (Monad m) => Player -> m Player; foo = return (player { deck = ... }) ? 
01:13:59 <tdammers> favetelinguis: OOP and GC are orthogonal concerns
01:14:03 <SrPx> Also, can I just, then, say "type CardEffect = (Monad m) => Player -> m Player"? 
01:14:04 <tdammers> most Haskell code isn't OOP
01:14:31 <SrPx> woops, rather "type CardEffect m = Player -> m Player" ? Is that the right way?
01:15:34 <rnhmjoj> @pl \x y -> fst x == fst y
01:15:34 <lambdabot> (. fst) . (==) . fst
01:16:10 <frerich> rnhmjoj: A nicer way to write that is '(==) `on` fst'
01:16:33 <jle`> SrPx: yes, if you want something that doesn't have any effects, you'd use Monad m => ...
01:16:46 <rnhmjoj> thanks
01:16:50 <jle`> also print =<< (erk >=> sayHi) player is a little silly
01:16:55 <jle`> why not print =<< erk =<< sayHi player ?
01:17:35 <jle`> SrPx: what are you trying to accomplish with your type synonym?
01:18:08 <favetelinguis> but if i write in plain C do i need to think about garbage collection?
01:18:19 <SrPx> jle`: I was just trying to determine if I can use >=> to compose effects, so I could define another card as "a = b >=> c"
01:18:44 <jle`> mhm that works :)
01:18:57 <SrPx> jle`: dunno... have a single name type for card effects? Is it bad?
01:19:15 <jle`> how are you planning on using it?
01:19:34 <jle`> you might like `type CardEffect m = Player -> m Player`
01:19:37 <jle`> oh yeah you wrote that
01:19:48 <SrPx> Like "sayHi :: (MonadIO m) => CardEffect m"
01:19:51 <SrPx> sounds reasonable?
01:19:52 <jle`> then you could do something like erk :: (MonadRandom m, Functor m) => CardEffect m
01:19:55 <jle`> yeah
01:19:57 <jle`> i do that :)
01:20:58 <SrPx> interesting... where ?
01:25:07 <jle`> most recently in a chatbot library i'm writing
01:25:56 <jle`> type ChatBot m = Auto m ChatBotInput ChatBotOutput
01:25:59 <jle`> roughly
01:26:30 <jle`> then i can write each module (ChatBot) under its own monad with minimal effects
01:26:41 <jle`> some are just Monad m => ..., some are MonadIO m => .., etc.
01:30:39 <Liffon> I'm having trouble setting up haskell-mode in emacs (Windows 7); it autocorrects :: to ‚à∑ and -> to ‚Üí, which gives me "Illegal operator `*** Exception: <stderr>: commitBuffer: invalid argument (invalid character)" in the repl
01:31:26 <Liffon> Does anyone know why this happens? I'm running haskell-mode from melpa
01:40:47 <majoh> vim
01:42:38 <catsup> is there an infix form of (fmap . fmap) somewhere?
01:43:59 <merijn> Looks like we have a new candidate for the ACME category
01:44:02 <merijn> https://github.com/edwinb/idris-php
01:45:31 <catsup> "Please, don't ever use this."
01:45:55 <mikeplus64> i seriously wonder how not-awful performance with that and hhvm would be
01:45:57 <catsup> that's too bad
01:46:17 <catsup> it'd be genuinely useful if it were a serious project
01:46:27 <kadoban> The license on that thing is‚Ä¶weird. I can't tell if that's a serious license or a joke.
01:47:09 <kadoban> It seems to say it grants no rights, and then‚Ä¶enumerates rights it grants‚Ä¶which are themselves kinda odd.
01:47:22 <tdammers> fwiw, I made a template compiler once that could use PHP as a backend
01:47:39 <merijn> kadoban: How does it not grant any rights?
01:47:42 <JaAnTr> Hi, can someone help me negate a boolean. Here's the type signature  evalB :: Bexp -> State -> (State, Bool) but I'm struggling to negate it evalB (Neg b) = ?
01:48:09 <kadoban> merijn: III.5 ?
01:48:45 <merijn> kadoban: Lawyer speak: "reserve all rights" in a license means "anything we didn't explicitly mention is not granted"
01:48:57 <merijn> kadoban: Note that there is such a thing as "implicit" rights
01:49:29 <merijn> Suppose I put my stuff on github without a license and you sue me when I fork + modify it, I might argue in court that putting it on github is implicitly saying I can do that
01:49:45 <kadoban> merijn: I don't think that's what it's supposed to mean in lawyerese. Reserve all rights is‚Ä¶just that, you get nada.
01:50:06 <merijn> kadoban: "we reserve all rights" followed by "you're allowed to: X"
01:50:15 <merijn> It's "default deny" vs "default accept"
01:50:17 <tdammers> merijn: you could argue that, but I doubt that you'd win
01:50:30 <merijn> tdammers: To be fair github EULA requires that you allow forks + pulls
01:50:37 <kadoban> merijn: Err, that's very much /not/ how copyright works as far as I know. You can't just use stuff from github without a licenese and say you assumed you could because the published it.
01:50:38 <merijn> tdammers: So it's rather grey
01:50:42 <tdammers> well yeah
01:50:57 <tdammers> github could kick you out and sue *you* for violating the EULA
01:51:07 <merijn> kadoban: In the end a judge decides what is and is not copyright violation
01:51:17 <jberg_> hi, im thinking of maybe downloading an haskell-project and try to get involved with writhing code so i get exposure to more real haskell code than my projects can produce. Are there some popular projects with beginner entry-level?
01:51:25 <tdammers> generally speaking though, the default for copyright is "all rights reserved"
01:51:26 <merijn> kadoban: Suppose you verbally told me I could do something but I didn't get it in writing (because I'm an idiot)
01:51:27 <catsup> tdammers: yes, but that's a separate thing
01:51:36 <tdammers> catsup: yes, that's my point.
01:51:50 <merijn> kadoban: No judge is going to read this and go "well, you had no rights to use this"
01:52:01 <merijn> kadoban: Since it clearly grants you a small set of rights
01:52:23 <kadoban> merijn: Sure, but that doesn't sound like something that will fly with any sane judge. That's the kind of logic that people get sued for, and lose, /all/ the time. "Published on the internet" does /not/ mean "public domain", "free for all" or anything like that.
01:52:26 <merijn> jberg_: xmonad is pretty readable and pandoc is pretty hackable (at least the parsers/writers)
01:52:29 <kala> hi angrygoats: could you please write me a code to do this ---  [["1,2,3],["1,2,3"]] -> [["1","2","3"],["1","2","3"]]
01:52:39 <kala> hi people: could you please write me a code to do this ---  [["1,2,3],["1,2,3"]] -> [["1","2","3"],["1","2","3"]]
01:52:44 <merijn> kadoban: I didn't say "published on the internet" is public domain
01:52:51 <jberg_> merijn, hmm okay. thanks
01:53:17 <kadoban> merijn: You seemed to be saying "published on github" is? Or at least that you have implicit rights to do quite a bit with it? Perhaps I misunderstood.
01:53:20 <merijn> kadoban: I said "putting all your code openly on github" and suing someone for fork+pulling is probably going to be ruled confusingly
01:53:33 <shiona> kala: you are missing a ", where do you want it
01:53:36 <tdammers> the github EULA protects github in two ways; one, when someone complains that their copyright has been violated by a fork, github can't be blamed; and two, when that happens, github can kick the offender out without further ado
01:53:53 <kala> shiona: could you please write me a code to do this ---  [["1,2,3"],["1,2,3"]] -> [["1","2","3"],["1","2","3"]]
01:54:08 <tdammers> "a code"?
01:54:18 <kala> Yup
01:54:20 <merijn> kadoban: Considering that github is a sharing site and they only allow repos under licenses that allow fork+pull, then suing someone for doing that "because there was no license in the repo" is unlikely to go over well with a judge
01:54:21 <tdammers> "hunter42" <- here's a code
01:54:26 <catsup> kala: is it a homework problem?
01:54:27 <kala> I have been trying for hours!
01:54:31 <kala> Nope
01:54:37 <Chousuke> kala: simplify the problem
01:54:42 <tdammers> anyway
01:54:59 <tdammers> kala: can you write some code that turns "1,2,3" into ["1", "2", "3"] ?
01:55:02 <catsup> kala: can you go from "1,2,3" -> ["1","2","3"] ?
01:55:11 <kadoban> merijn: That is possible. Doing any more with it than that though seems unlikely to go well though. I'm not sure how it relates to the convo before it though?
01:55:16 <merijn> kadoban: The fact that github requires fork+pull rights strongly argues that if you put something publicly on github without a license you're implicitly granting those rights, because else you would not be allowed to put it on github
01:55:29 <shiona> > map . map ((map show).read) [["1,2,3"],["4,5,6"]]
01:55:30 <lambdabot>  Couldn't match expected type ‚Äòa -> a1 -> b‚Äô
01:55:30 <lambdabot>              with actual type ‚Äò[[GHC.Base.String]]‚ÄôCouldn't match expected ty...
01:55:30 <lambdabot>              with actual type ‚Äò[GHC.Types.Char]‚ÄôCouldn't match expected type ...
01:55:34 <merijn> kadoban: Sure, I wouldn't build a commercial product out of it
01:55:41 <kala> tdammers : sepBy "," "1,2,3"
01:55:50 <tdammers> > sepBy "," "1,2,3"
01:55:52 <lambdabot>  ["1","2","3"]
01:55:55 <tdammers> there you go
01:56:07 <tdammers> now do the same with ["1,2,3"]
01:56:21 <merijn> kadoban: My point was, there is a tendency to explicitly assert you are reserving all rights before granting any to make it completely obvious that you don't intend to waive any of your rights
01:56:41 <Galvus> kadoban, you can buy a private repo on github btw
01:56:56 <merijn> kadoban: Note that the BSD license says "All rights reserved" too
01:57:08 <kala> tdammers: it does not work :/
01:57:17 <tdammers> well, you don't do exactly the same
01:57:34 <tdammers> let the types guide you
01:57:36 <merijn> kadoban: Like I said, starting out with "All rights reserved" reads as a "default deny" rule for any unmentioned rights
01:57:43 <kala> Sure.
01:57:47 <Galvus> tdammers, may the types be with you.
01:58:11 <kadoban> merijn: Oh hmm, I guess it does. I thought those were usually stated like "All rights reserved except: blah blah blah". Apparently not.
01:58:12 <ChristianS> merijn: though "All rights reserved" is actually a redundant claim since that's the default of modern copyright law anyway
01:59:00 <merijn> ChristianS: I know
01:59:17 <Galvus> "Even if this is what you intend, if you publish your source code in a public repository on GitHub, you have accepted the Terms of Service which do allow other GitHub users some rights. Specifically, you allow others to view and fork your repository."
01:59:18 <ChristianS> merijn: indeed, the https://en.wikipedia.org/wiki/ISC_license which is boiled down to the legally required minimum doesn't use that phrase
01:59:19 <merijn> So is the copyright symbol, but hey, it can't hurt
01:59:32 <kadoban> Thanks for the correction, that makes sense now. The rights granted still seems pretty odd to me though.
01:59:39 <merijn> kadoban: How so?
01:59:45 <nshepperd> this license looks like a half-joke
01:59:52 <catsup> Galvus: it seems unlikely to me that the courts would recognize that as binding
02:00:07 <catsup> Galvus: actually, that's understated
02:00:22 <merijn> kadoban: I have collegues that invested 15 years writing a high-performance compiler that they do want to sell for money. At the same time they would like to contribute to science in the sense that people should be able to verify your claims
02:00:27 <kadoban> merijn: Well, most of them‚Ä¶don't really require a license as far as I know. I could already use any program I can find to validate published scientific claims, as far as I know and I don't think that violates‚Ä¶any law.
02:00:27 <Chousuke> kala: generally, asking for complete solutions on a programming channel won't get you many answers. :) you have one part of the problem solved though. now that you have something that goes from "1,2,3" to ["1","2","3"], write something that goes applies that to a list of strings. (it's very simple)
02:01:05 <kala> tdammers!
02:01:07 <kala> help
02:01:09 <merijn> kadoban: It makes sense to allow OTHER academics to use their compiler for writing papers, but they don't want to allow someone to just take their compiler they spend ages building and start selling it for money without them getting any of it
02:01:10 <kala> help
02:01:43 <merijn> kadoban: The problem is "I wrote this algorithm that has 100x speed up, but I'm not showing you the source so you can't verify"
02:02:00 <Galvus> catsup, yeah TOS are kinda worthless lately.
02:02:15 <merijn> kadoban: A surprising number of papers I read don't open source their code and the end result is that I can't possibly check whether they are lying
02:02:38 <kadoban> merijn: Yeah, I've noticed that myself; pretty annoying.
02:02:45 <merijn> kadoban: The idea behind the license is that I'm open sourcing it ONLY for validation/further experiments, but not allowing you to, e.g. repackage/sell it
02:03:44 <kadoban> Yeah, that seems like a reasonable intent.
02:04:18 <Galvus> merijn, GPL is pretty effective tat that.
02:04:42 <merijn> Galvus: No, because you'd still be allowed to sell/repackage GPL code
02:04:43 <EvanR_> you can repackage and sell GPL programs
02:04:45 <kadoban> Galvus: Not really. You can build stuff on GPL code and sell it.
02:04:46 <kala> chosuke: I have tried for hours now!
02:04:46 <Galvus> (Generally commercials entities cannot comply with the GPL terms)
02:05:04 <merijn> Galvus: Eh, they might be able to
02:05:11 <Galvus> You also have to distribute/release your source code.
02:05:19 <merijn> Cisco seems to have no trouble with open sourcing their router source...
02:05:24 <merijn> At least the linux based ones
02:05:25 <EvanR_> you dont have to distribute it with the product, you just have to produce it on request
02:05:27 <Galvus> merijn, hahahahaah true story.
02:06:04 <merijn> Galvus: Take the compiler example, I can easily sell a standalone compiler/consulting without needing to open up anything
02:06:32 <EvanR_> not if its GPL
02:06:59 <Galvus> There is also the... https://creativecommons.org/licenses/by-nc-nd/4.0/
02:09:44 * hackagebot linearscan 0.4.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.4.0.0 (JohnWiegley)
02:09:46 * hackagebot linearscan-hoopl 0.4.0.0 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.4.0.0 (JohnWiegley)
02:18:34 <niko> /15/22
02:29:45 * hackagebot handsy 0.0.12 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.12 (utdemir)
02:33:27 <adhominem> .
02:34:46 * hackagebot repa-stream 4.0.0.1 - Stream functions not present in the vector library.  http://hackage.haskell.org/package/repa-stream-4.0.0.1 (BenLippmeier)
02:44:46 * hackagebot repa-eval 4.0.0.1 - Low-level parallel operators on bulk random-accessble arrays.  http://hackage.haskell.org/package/repa-eval-4.0.0.1 (BenLippmeier)
02:54:47 * hackagebot repa-array 4.0.0.1 - Bulk array representations and operators.  http://hackage.haskell.org/package/repa-array-4.0.0.1 (BenLippmeier)
02:59:47 * hackagebot repa-array 4.0.0.2 - Bulk array representations and operators.  http://hackage.haskell.org/package/repa-array-4.0.0.2 (BenLippmeier)
03:09:31 <fractalsea> Is there a way of changing the order of monad transformers in a stack?
03:09:47 * hackagebot repa-flow 4.0.0.1 - Data-parallel data flows.  http://hackage.haskell.org/package/repa-flow-4.0.0.1 (BenLippmeier)
03:10:22 <bloot> Is there a guarantee that "IO ()" wont be executed when used as an argument to certain functions?
03:10:40 <bloot> I.e. let's say I have a Chan (IO ())
03:10:46 <aawe> bloot: hm? Do you have an example scenario?
03:10:57 <merijn> bloot: IO () is merely a value
03:11:08 <bloot> and I use readChan on that chan from another thread 
03:11:09 <merijn> bloot: There is no way to run IO actions within haskell
03:11:14 <bloot> which thread executes the action?
03:11:19 <merijn> bloot: You can only compose them into bigger actions
03:11:26 <bloot> the one writing to the chan or the one reading from it?
03:11:27 <EvanR_> bloot: maybe no thread
03:11:28 <ClaudiusMaximus> :t readChan
03:11:29 <lambdabot> Not in scope: ‚ÄòreadChan‚Äô
03:11:39 <ClaudiusMaximus> :t Control.Concurrent.readChan
03:11:40 <lambdabot> Control.Concurrent.Chan.Chan a -> IO a
03:11:54 <EvanR_> readChan :: Chan (IO ()) -> IO (IO ())
03:12:23 <merijn> bloot: if I do "do { action <- readChan myChan; action }" then it gets executed in the thread doing readChan
03:12:41 <ClaudiusMaximus> readChan doesn't know anything about the a, so it couldn't execute it even if it happened that a ~ IO b (would be a type error in the implementation)
03:12:56 <EvanR_> :t join
03:12:57 <lambdabot> Monad m => m (m a) -> m a
03:13:05 <EvanR_> join :: IO (IO ()) -> IO ()
03:13:06 <bloot> http://codepad.org/pF9Tn34d
03:13:10 <bloot> seems to work as expected at least
03:13:35 <merijn> bloot: Right, that should do what you want
03:19:48 * hackagebot casadi-bindings 2.2.0.8 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.8 (GregHorn)
03:19:50 * hackagebot repa-flow 4.0.0.2 - Data-parallel data flows.  http://hackage.haskell.org/package/repa-flow-4.0.0.2 (BenLippmeier)
03:25:56 <bloot> @hoogle times
03:25:58 <lambdabot> Graphics.Rendering.OpenGL.GL.QueryObjects timestamp :: GettableStateVar GLuint64
03:25:58 <lambdabot> package timestamp-subprocess-lines
03:25:58 <lambdabot> Graphics.Rendering.OpenGL.GL.QueryObjects timestampQuery :: QueryObject -> IO ()
03:30:20 <bloot> need to enqueu dummy actions to stop threads :)
03:30:27 <bloot> http://codepad.org/cEvYk71O
03:30:32 <bloot> unless somebody else has a better idea
03:30:39 <bloot> (I'm not keen on using killThread)
03:31:12 <selveskii> Hello, everyone. I have a project written using GHC 7.8 and cabal. Today I upgraded my GHC to 7.10.1rc2 (as Homebrew reported, though the ghc itself said that it's 7.10.0.20150123).
03:31:18 <selveskii> Then I faced a lot of dependency conflicts. For example, syb-with-class requires template-haskell < 2.10, but I now only have TH 2.10. I checked the Hackage and it also said the latest version of TH was 2.9.
03:31:26 <selveskii> How can I resolve those dependency conflicts without rolling back to GHC 7.8?
03:31:30 <selveskii> Thanks!
03:31:44 <merijn> selveskii: Can't
03:31:50 <pacak> selveskii: Rollback and wait for release.
03:31:51 <merijn> selveskii: Template Haskell is wired into GHC
03:32:15 <pacak> Or you can update syb-with-class yourself and send patches upstream.
03:32:18 <merijn> selveskii: If a package like syb-with-class wasn't updated for the new template haskell version you can't use it with 7.10 until it is
03:32:41 <EvanR_> bloot: one way to kill threads is have your threads exit their loop when they get a certain message
03:32:46 <EvanR_> on a Chan or MVar
03:33:18 <EvanR_> if the type of their commands is IO (), well then the only way is for the IO () to be to killThread yourself
03:33:28 <merijn> EvanR_: You can't poll with Chan/MVar, so if he has a Chan of incoming actions he can't wait for a terminate from another
03:33:34 <absence> is there a clever way to express if empty somelist then otherlist else somelist? i naively tried <|> based on how it works for Maybe, but somelist <|> otherlist just concats them
03:33:37 <merijn> Alternatively, use STM which does allow polling
03:33:58 <EvanR_> merijn: i was assuming it would be on the same channel as all the other messages
03:34:05 <selveskii> thanks‚Ä¶I accidentally updated my cabal to 1.22, which doesn't work with ghc-mod. so I updated my GHC-_-#
03:34:16 <tdammers> absence: how about if null a then b else a?
03:34:44 <tdammers> @hoogle [a] -> [a] -> [a]
03:34:45 <merijn> selveskii: ghc-mod (like hdevtools) is kinda brittle, due to cabal not really distinguishing between build time and compile time dependencies
03:34:48 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
03:34:48 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
03:34:48 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:34:53 <tdammers> ahem
03:34:54 <tdammers> not useful
03:34:56 <merijn> selveskii: ghci-ng will hopefully obsolete this problem
03:34:58 <tdammers> I rest my case
03:35:12 <novemberkilo> Hello! I'm new to Haskell and have a specific question. I would like to work with the Safe library (so that I can use functions like safeHead). How do I import Safe into my program (or into ghci)? Thanks.
03:35:18 <EvanR_> bloot: the simplest way is to killThread or throw an async exception at the target thread. but it requires that your threads work be safe against async exceptions
03:35:28 <merijn> selveskii: Since it will extend ghci with the necessary tools/messages for reporting errors/resolving types that hdevtools and ghc-mod are being used for
03:35:31 <EvanR_> which may or may not be simple
03:35:35 <frerich> bloot: You might like https://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html which provides a convenient API on top of threads, including things like waiting for threads of cancelling them.
03:35:49 <tdammers> novemberkilo: have you tried writing "import Safe" in your source file?
03:35:52 <tdammers> (or in ghci)
03:35:52 <absence> tdammers: null is what i meant in the example i want to replace :)
03:36:00 <merijn> selveskii: But since ghci won't be linking with cabal (it can be invoked via "cabal repl") that problem should go away
03:36:14 <frerich> bloot: Mentioning this since 'async' is one of those packages of which I wished I'd have heard about them earlier instead of rolling my own thread pool libraries and whatnot...
03:36:22 <merijn> But I don't think ghci-ng is far enough along for all the usual editor extensions to be able to use it yet
03:36:58 <novemberkilo> tdammers: yes. I get 'could not import module 'Safe' 
03:37:02 <Yuras> frerich: except that async itself is not async-exception safe :)
03:37:14 <selveskii> Thanks! I am checking it.
03:37:17 <tdammers> novemberkilo: then you probably need to install the 'safe' package
03:37:33 <novemberkilo> tdammers: and how do I do that please?
03:37:51 <tdammers> novemberkilo: either through your OS package manager, or using cabal
03:37:53 <tdammers> cabal install safe
03:38:27 <novemberkilo> tdammers: thanks - will try that
03:38:35 <hvr> what's the currently hippest javascript library for making Haskell slides? I'm currently using remark.js
03:39:30 <erikd> hvr: reveal?
03:40:04 <frerich> hvr: I liked Reveal in the past because it let me do slides in Markdown and it syntax-highlights code nicely.
03:40:25 <aleator_> hvr: I just used lucid and haskell (and bit of inline javascript): https://github.com/aleator/LambdaLuento
03:40:32 <aleator_> ..and deck.js
03:41:41 <hvr> erikd: isn't reveal.js a bit too animated? :)
03:42:00 <hvr> erikd: the transition seem a bit too distracting at first
03:42:22 <frerich>  hvr: You don't *need* to use any transitions.
03:42:47 <hvr> does reveal have a presneter mode like remark.js has?
03:43:00 <frerich> hvr: Yes, it does - it shows internal notes and a timer.
03:43:12 <aleator_> Actually, since in reveal you can move either from left to right or up to down you actually need some kind of transition to show you where you're going.
03:44:06 <absence> since i made a quite confusing typo the first time, i'll ask again: is there a clever way to express "if null a then b else a"? i naively tried a <|> b, but it just concats them (because that's what the monoid does i guess?)
03:44:29 <erikd> hvr:  i saw someone use reveal jsut recentlt. i still use pdflatex :-P
03:45:07 <hvr> erikd: I'm mostly experimenting... I've been using beamer class for over a decade
03:45:30 <hvr> erikd: but recently I started looking at pandoc first, and then tried remark.js
03:45:52 <hvr> and now I'm evaluating whether I should try something else or stay w/ remark.js
03:47:20 <kadoban> absence: I don't think there's going to be a cute way to do that in haskell like there is in some other languages. The boring way looks fine to me.
03:48:05 <tdammers> could make your own operator
03:48:11 <kadoban> absence: I mean if you're using that pattern a lot, you could factor it out to a function of course
03:48:38 <tdammers> let a <<>> b = if null a then b else a in [] <<>> [1,2,3]
03:48:41 <tdammers> > let a <<>> b = if null a then b else a in [] <<>> [1,2,3]
03:48:43 <lambdabot>  [1,2,3]
03:49:57 <Yaniel> what's happened to the trend of unicode abuse from a couple of years back
03:50:46 <EvanR_> ascii is the eternal president of text
03:51:06 <tdammers> heresy! EBCDIC forever!
03:51:31 <bernalex> can't you use "if' =<< null" or something?
03:51:33 <gfixler> unicode abuse went Œ£where else
03:51:59 <EvanR_> ¬¨_¬¨
03:52:02 <bernalex> where 'if' True = const; if' False = const id'.
03:52:13 <EvanR_> ¬±_¬±
03:53:15 <tdammers> bernalex: I think there's a package for that
03:53:39 <mniip> how much mantissa does Double have again?
03:53:46 <mniip> I thought it's 52
03:53:57 <bernalex> @let if' True = const; if' False = const id
03:53:59 <JaAnTr> Hi, I'm trying to change some code I've written from post increment to pre increment but I'm struggling. Here's the code - evalA (Incr v) s  = let n = get v s in                       let t = set v (n + 1) s in                         (t, n)
03:54:00 <lambdabot>  Defined.
03:54:09 <bernalex> > (if' =<<) null [3, 4] [1, 2]
03:54:11 <lambdabot>  [1,2]
03:54:14 <bernalex> > (if' =<<) null [3, 4]
03:54:15 <lambdabot>  <[Integer] -> [Integer]>
03:54:24 <bernalex> > (if' =<< null) [3, 4] [1, 2]
03:54:26 <lambdabot>  [1,2]
03:54:27 <bernalex> > (if' =<< null) [3, 4] []
03:54:29 <lambdabot>  []
03:54:39 <bernalex> (i did goofd once there but uh you get the point)
03:54:59 <mniip> absence, I had the exact same question recently
03:55:03 <tdammers> I think mine is significantly less obscure
03:55:15 <tdammers> proof: you goofed, I didn't. q.e.d
03:55:31 <bernalex> I could just as weel goofd on the exact same thing for yours...
03:55:33 <absence> kadoban: yeah, just wanted to check that i don't go reinventing library wheels :) thanks
03:56:02 <tdammers> so my proof lacks rigor, big deal
03:56:11 <bernalex> anyway I don't find (if' =<< null) terribly obscure
03:56:21 <absence> mniip: did you end up with a custom combinator or just leave it?
03:56:42 <bernalex> also "if" is a terrible plague upon our lands, and we shan't speak of it unless necessary or to mock.
03:56:46 <mniip> I found no way to remove the 2 occurencies of x, without join/ap heresy
03:56:52 <hvr> erikd, frerich: is there a list of the default keyboard shortcuts for reveal.js?
03:56:58 <tdammers> if blindness?
03:56:59 <mniip> but there were some neat ways to do that like
03:57:06 <mniip> fromMaybe x [y | null x]
03:57:08 <frerich> hvr: https://github.com/hakimel/reveal.js/wiki/Keyboard-Shortcuts
03:57:14 <hvr> thx
03:57:24 <mniip> that requires -XMonadComprehensions though
03:57:26 <EvanR_> the if wears no clothes
03:57:30 <bernalex> hvr: good afternoon-ish btw
03:57:47 <absence> :t \x y -> fromMaybe x [y | null x]
03:57:48 <lambdabot>     Couldn't match expected type ‚ÄòMaybe [a]‚Äô with actual type ‚Äò[t]‚Äô
03:57:48 <lambdabot>     Relevant bindings include
03:57:48 <lambdabot>       y :: t (bound at <interactive>:1:4)
03:58:18 <hvr> bernalex: likewise :)
03:58:24 <bernalex> absence: MonadComprehensions aren't enabled in lambdabot.
03:58:24 <mniip> absence, -XMonadComprehensions
03:58:30 <mniip> I don't think lambdabot has that
03:58:30 <absence> ahh, i see
03:58:45 <mniip> here's an extension-less way to say the same thing
03:58:47 <mniip> x ++ (guard (null x) >> "hello")
03:58:51 <mniip> er
03:58:54 <mniip> x ++ (guard (null x) >> y)
03:59:09 <bernalex> I still maintain that (if' =<< null) is nice. -_o_-
03:59:22 <mniip> hmm
03:59:56 <tdammers> @hoogle [a] -> Maybe [a]
03:59:57 <lambdabot> Prelude cycle :: [a] -> [a]
03:59:57 <lambdabot> Data.List cycle :: [a] -> [a]
03:59:57 <lambdabot> Prelude init :: [a] -> [a]
04:00:04 <tdammers> pfff
04:00:10 <mniip> (++) <*> (>> y) . guard . null
04:00:19 <mniip> not sure of the precedence
04:00:38 <absence> mniip: i was about to say it was "kinda" cute before you wrote that :D
04:00:51 <mniip> next step is
04:01:08 <mniip> ((++) <*>) . (. (guard . null) . flip (>>)
04:01:12 <der7leo> :q
04:01:13 <mniip> ((++) <*>) . (. (guard . null)) . flip (>>)
04:02:26 <bernalex> mniip: yeah. no. :p
04:02:30 <mniip> bernalex, maybe if there was a function like mapMaybe
04:02:47 <mniip> (a -> Bool) -> Maybe a -> Maybe a
04:02:55 <mniip> or even (a -> Bool) -> a -> Maybe a
04:03:04 * frerich thinks tdammers' initial suggestion beats them all, hands down.
04:03:12 <EvanR_> @djinn (a -> Bool) -> a -> Maybe a
04:03:12 <lambdabot> f a b =
04:03:12 <lambdabot>     case a b of
04:03:12 <lambdabot>     False -> Nothing
04:03:12 <lambdabot>     True -> Just b
04:03:22 <mniip> pretty much that
04:03:22 <mniip> yes
04:03:26 <EvanR_> i see
04:03:33 <mniip> @hoogle (a -> Bool) -> a -> Maybe a
04:03:34 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:03:34 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:03:34 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
04:03:38 <mniip> sad
04:03:56 <EvanR_> mfilter p x
04:04:02 <EvanR_> no
04:04:48 <nshepperd> > (\a b -> case a of { [] -> b; _ -> a }) [] "abc"
04:04:49 <lambdabot>  "abc"
04:05:43 <mniip> fromMaybe y (find (not . null) [x])
04:07:03 <gfixler> > let a = []; b = [2,3] in head [x | x <- [a,b], not $ null x]
04:07:04 <lambdabot>  [2,3]
04:07:41 <mniip> head $ dropWhile null [x, y]
04:07:51 <gfixler> nice
04:08:16 <mniip> generalizable to any amount of lists
04:08:24 <nshepperd> nonEmpty x <|> nonEmpty y
04:08:49 <mniip> @hoogle nonEmpty
04:08:50 <lambdabot> Test.QuickCheck.Modifiers NonEmpty :: [a] -> NonEmptyList a
04:08:50 <lambdabot> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
04:08:50 <lambdabot> package NonEmpty
04:09:01 <JaAnTr> How would I change these two functions from post incremement (v++) to pre increment (++v). http://pastebin.com/p5HeXtZJ Thanks!
04:09:03 <mniip> that's rather arbitrary
04:09:09 <gfixler> wait, I think I have the winner here...
04:09:19 <nshepperd> Data.List.NonEmpty.nonEmpty :: [a] -> Maybe (NonEmpty a)
04:09:19 <gfixler> if null a then b else a
04:09:56 <mniip> gfixler, that was the initial statement
04:10:02 <bernalex> gfixler: no thanks
04:10:05 <bernalex> at least use case
04:10:05 <gfixler> (i know)
04:10:26 <bernalex> 'case a of [] -> b; _ -> a' is nice enough imo.
04:11:30 <gfixler> why were trying to avoid if again?
04:13:58 <bernalex> my optimal solution would just be: f [] x = x; f x _ = x, probably.
04:14:11 <mniip> maybe y toList (nonEmpty x)
04:14:51 * hackagebot gearbox 1.0.0.3 - zooming rotating fractal gears graphics demo  http://hackage.haskell.org/package/gearbox-1.0.0.3 (ClaudeHeilandAllen)
04:14:51 <bernalex> oh wait I just remembered what we were talking about.
04:14:56 <bernalex> I'm tired. lol.
04:17:57 <exio4> @type \f -> filterm f . return
04:17:58 <lambdabot>     Not in scope: ‚Äòfilterm‚Äô
04:17:58 <lambdabot>     Perhaps you meant one of these:
04:17:58 <lambdabot>       ‚Äòfilter‚Äô (imported from Data.List),
04:18:06 <exio4> @type \f -> mfilter f . return
04:18:07 <lambdabot> MonadPlus m => (a -> Bool) -> a -> m a
04:19:59 <mniip> rats
04:21:38 <mniip> what is so undecidable about 0.100000... - 0.0100000... (binary)
04:22:19 <mniip> I'm getting 0.0‚ä• as result :/
04:22:54 <nshepperd> > (liftA2 flip bool null) [] [1,2,3]
04:22:55 <lambdabot>  [1,2,3]
04:22:58 <EvanR_> :ùöù rats
04:23:16 <mniip> EvanR_, 'tis an interjection
04:24:21 <mniip> ah, it doesn't know whether the answer is 0.010000... or 0.00111111... because it doesn't know whether there are 1's further down in 0.0100000...
04:24:42 <EvanR_> 1s all the way down
04:26:11 <hpc> now you know why CReal is so incredible
04:26:29 <Ch0c0late> Could anybody guide me about this sentence?
04:26:37 <Ch0c0late> "encoding the security lattice of n points would require O(n2) definitions for binding operators."
04:29:04 <bloot> EvanR_: they exit when the MVAR is empty
04:29:22 <bloot> but you have to enqueue dummy action this way because readChan will block
04:29:40 <noyp-esrever> Just wondering... After Applicative is made a superclass of Monad, will the Monad combinators in Data.Foldable and Data.Traversable be eliminated/deprecated/whatever?
04:29:44 <EvanR_> bloot: i was saying, you can multiplex different messages on the same mvar or chan using sum types
04:30:05 <noyp-esrever> It's confusing that the documentation itself doesn't point me towards the most general version.
04:30:17 <EvanR_> data Command = DoIO (IO ()) | Die
04:33:18 <ww> [ot] so much painful housekeeping trying to fix some guy's c++ code. not how i like to spend my morning :(
04:33:19 <merijn> noyp-esrever: Currently the answer is: no
04:33:40 <merijn> noyp-esrever: Basically, removing them will needlessly break a ton of code
04:33:49 <merijn> noyp-esrever: So, it's easier to keep them for now
04:34:24 <noyp-esrever> At least the documentation should contain a warning that <monadic combinator> is the same as <applicative combinator>.
04:35:06 <EvanR_> the docs can say a lot of things, theres a lot of things to be said about a lot of things
04:35:18 <EvanR_> if only it only said what i needed to hear
04:35:23 <nshepperd> I imagine they would be marked deprecated eventually
04:36:18 <nshepperd> some of them, at least
04:36:24 <merijn> noyp-esrever: If you're willing to write the required changes, I'm sure lots of people would be grateful
04:37:43 <merijn> noyp-esrever: You could simply attach a patch to the GHC Trac and/or submit a Phab diff, depending on how much time you're willing to commit
04:38:19 <mniip> hpc, I wonder if 'data Quotient = Bool :. Quotient | Ones | Zeros' would help
04:38:21 <noyp-esrever> What's the difference between those?
04:38:25 <noyp-esrever> merijn: ^
04:41:05 <merijn> noyp-esrever: Trac is the bug tracker, so attaching a patch there means a committer has to manually apply the patch locally and merge it into upstream. Phabricator is the code review/testing infrastructure in which case it can be merged directly. However, figuring out how to use Phab can be a bit daunting so people would rather see a bare patch than someone intimidated by phab and not contributing
04:41:33 <noyp-esrever> Oh.
04:52:34 <Yaniel> :t lift
04:52:34 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
04:58:42 <mniip> hmm
04:58:52 <mniip> should I consider 0.011111111... == 0.100000000...
05:01:54 <EvanR_> yes
05:02:00 <EvanR_> (in binary)
05:02:05 <mniip> hmm
05:02:13 <mniip> how would I implement == then...
05:02:18 <EvanR_> you cant
05:02:54 <mniip> no I mean for 'data Quotient = Bool :. Quotient | Ones | Zeros'
05:03:24 <EvanR_> you still cant, unless the language for making a Quotient isnt turing complete in some way
05:03:52 <mniip> the language is haskell?
05:04:10 <EvanR_> you cant verify an infinite list is equal to another
05:04:35 <mniip> sure, irrational == irrational is bottom
05:04:50 <EvanR_> in this case the problem is with rationals too
05:04:54 <mniip> but stuff like True :. Zeros == False :. Ones
05:05:32 <EvanR_> i.e. does this list have an infinite number of ones after this point
05:11:21 <ab9rf> aren't computers wonderful?
05:15:55 <mniip> hmm
05:15:59 <mniip> can't figure out division
05:16:31 <mniip> 0.01 / 0.1 -> 0.010101010101... doesn't seem correct
05:17:19 <EvanR_> four divided by half?
05:17:21 <EvanR_> fourth
05:17:24 <mniip> yeah
05:17:36 <mniip> for the record 0.0101010101 is third
05:17:46 <EvanR_> > 0.25 / 0.5
05:17:48 <lambdabot>  0.5
05:17:51 <EvanR_> yep not right
05:18:46 <mniip> hmm
05:18:54 <mniip> reimplemented subtraction, that case is fixed
05:19:08 <mniip> now 1 / 0.75 -> 2/7
05:21:28 <mniip> hmm
05:22:11 <merijn> What exactly are you trying to do?
05:22:29 <mniip> implementing numbers as infinite lazy streams of bits
05:23:40 <merijn> You can't do much sensibles with number in that representation
05:23:52 <merijn> But my more fundamental question was: What do you want to use this for?
05:24:01 <mniip> you can evaluate it to a needed precision
05:24:22 <EvanR_> > pi == (pi :: CReal)
05:24:23 <lambdabot>  True
05:24:26 <EvanR_> ;)
05:24:40 <mniip> and it should be possible to implement Num, Fractional and Floating on that
05:24:54 <mniip> > pi :: CReal
05:24:56 <merijn> mniip: So what about infinite fractions? As EvanR_ pointed out
05:24:56 <lambdabot>  3.1415926535897932384626433832795028841972
05:25:08 <EvanR_> luckily you dont need Eq for Num anymore
05:25:22 <mniip> EvanR_, it is possible to implement Eq
05:25:28 <merijn> I think you really want something like Ratio instead
05:25:30 <mniip> however most of the time it would return bottom
05:25:30 <EvanR_> not as a total function
05:25:38 <merijn> That has arbitrary precision for rationals...
05:25:39 <mniip> [15:21:27] <merijn> But my more fundamental question was: What do you want to use this for?
05:25:42 <mniip> I'm just bored
05:25:45 <mniip> :P
05:25:54 <merijn> mniip: Oh, in that case, carry on
05:26:18 <merijn> mniip: While you're at it, you could add a Peano arithmetic "instance Num [()]" :)
05:26:27 <merijn> Or even "Num [a]"
05:26:32 <mniip> nah
05:26:41 <mniip> I've already implemented peano arithmetic at type level
05:26:56 <merijn> ls
05:27:00 <mniip> and even insertion sort operating on type-level lists of type-level numbers
05:27:17 <mniip> not DataKinds, my own numbers and lists
05:28:35 <mniip> https://gist.github.com/mniip/bb1352bc87e42b667257
05:32:11 <mniip> I like this line
05:32:14 <mniip> instance (LEQ a b c, Insert a d e, IfThenElse c (Cons a (Cons b d)) (Cons b e) f) => Insert a (Cons b d) f
05:33:06 <EvanR_> i want to see an FPS at the type level
05:38:16 <bloot> uhm
05:38:19 <bloot> what's AppData o_O
05:40:30 <Liffon> bloot:
05:40:36 <Liffon> C:\>echo %AppData%
05:40:41 <Liffon> C:\Users\bloot\AppData\Roaming
05:40:46 <Liffon> :D
05:40:46 <bloot> no
05:41:20 <bloot> I mean this weird Conduit AppData
05:41:44 <mniip> EvanR_, 
05:41:57 <mniip>  :t let square x = x `multiply` x in let _256 = square $ square $ square $ succ $ succ zero in _256 `add` zero
05:41:58 <mniip>     Context reduction stack overflow; size = 201
05:42:26 <mniip> you can't operate on numbers above 200 :(
05:42:51 <mniip> one could probably implement some sort of binary representation
05:43:03 <EvanR_> whats that, type level naturals?
05:43:32 <EvanR_> unary is really bad for arithmetic in any case
05:43:36 <shiona> :t multiply
05:43:37 * frerich believes type level naturals must be some sort of shampoo.
05:43:37 <lambdabot> Not in scope: ‚Äòmultiply‚Äô
05:43:47 <shiona> :i multiply
05:43:51 <EvanR_> frodwith: i would buy it
05:43:55 <EvanR_> frerich: 
05:44:00 <dropp> whats up peepz
05:44:25 <mniip> shiona, multiply :: Multiply a b c => a -> b -> c
05:44:46 <mniip> a bottom value that serves only to simplify type calculation
05:45:10 <EvanR_> mniip: was that in response to my FPS comment? youd obviously have to make do with arithmetic below 200
05:45:16 <EvanR_> like in the old days
05:45:19 <mniip> instead of (undefined :: Multiply a b c => a -> b -> c) (undefined :: Succ (Succ Zero)) (undefined :: Succ (Succ Zero))
05:45:31 <mniip> you write (succ $ succ zero) `multiply (succ $ succ zero)
05:45:37 <mniip> +`
05:45:57 <mniip> EvanR_, how do you do IO from the typechecker
05:46:15 <EvanR_> the idea is you dont have to literally compute using the type system
05:46:21 <EvanR_> you just need it for type checking
05:46:36 <EvanR_> the computations (including at the type level) can be implemented another way by the compiler
05:46:45 <EvanR_> if you could prove they would produce the same result
05:46:57 <mniip> well you can turn types into values
05:47:06 <mniip> making output possible
05:47:08 <mniip> but not values into types
05:47:13 <mniip> making input impossible
05:47:45 <EvanR_> as far as IO goes i have no idea, but it sounds like the same question about how you would do IO in a purely functional language repeated
05:47:47 <mniip> unless you turn input-expecting types into input-expecting values
05:48:04 <EvanR_> haskell is a purely functional language so how would you do IO
05:49:14 <EvanR_> alternatively you dont need IO all you need to do is ensure that i would have quad damage double fragged you at whatever time ;)
05:49:16 <tdammers> EvanR_: you don't *do* IO in Haskell, you just *describe* IO actions, and then the runtime "does" them for you :D
05:49:17 <bloot> how do I get an AppData :(
05:49:35 <mniip> yeah
05:49:49 <EvanR_> tdammers: right same as C ;)
05:49:57 <mniip> you could describe IO actions in the typesystem
05:49:59 <EvanR_> C is purely functional
05:50:12 <mniip> and then serialize them into IO values
05:50:26 <EvanR_> IO is overrated
05:50:47 <EvanR_> what do you expect from a language where people serious use pointless style
05:50:48 <bloot> data AppData :: *
05:50:51 <bloot> and wtf is that?
05:51:07 <EvanR_> a kind signature
05:51:13 <mniip> class IOable a where ioify :: a -> IO ()
05:52:03 <bloot> this rawProxyTo expects me to pass an AppData
05:52:11 <mniip> instance (IOable a, IOable b) => IOable (Bind a b) where ioify x = bindfst x >>= bindsnd x
05:52:25 <dropp> EvanR_: C is purely functional? huh?
05:52:39 <EvanR_> http://conal.net/blog/posts/the-c-language-is-purely-functional
05:53:35 <dropp> bah
05:54:18 <bloot> EvanR_: but ghci tells something else
05:54:20 <EvanR_> all good explanations of haskells IO system apply to C ;)
05:54:28 <bloot> ata AppData = Data.Streaming.Network.Internal.AppData {Data.Streaming.Network.Internal.appRead' :: !IO
05:54:45 <bloot> it's not exported
05:54:49 <bloot> so I can't create an AppData
05:54:52 <mniip> EvanR_, state monad explanation?
05:55:01 <EvanR_> state monad?
05:55:06 <bloot> this is like the worst API I've ever had to work with o_O
05:55:53 <EvanR_> bloot: i dont think youre supposed to look in internal modules to figure out how to use an API
05:57:41 <bloot> https://hackage.haskell.org/package/http-reverse-proxy-0.4.1.2/docs/Network-HTTP-ReverseProxy.html
05:58:43 <bloot> also this API doesn't allow you to rewrite requests
05:58:47 <nshepperd> the state monad explanation of haskell IO is a fake explanation though
05:59:22 <EvanR_> bloot: so AppData is any type of kind *
05:59:27 <nshepperd> as I understand it, the State# RealWorld stuff is just a hack to make things evaluate in order
05:59:28 <EvanR_> its a type family
06:00:08 <EvanR_> bloot: er hold on
06:00:11 <frerich> EvanR_: Are you sure about that?
06:00:22 <frerich> It actually means 'AppData' has kind '*'.
06:00:30 <frerich> As opposed to, say, Maybe.
06:00:46 <EvanR_> yeah im not sure
06:00:56 <mniip> nshepperd, pretty much
06:01:35 <EvanR_> mniip: nshepperd im not sure what the state monad explanation of IO is
06:01:37 <frerich> EvanR_: 'AppData' is a plain data type, not a 'type family'. Compare e.g. ':k Bool' vs. ':k Maybe' vs. ':k Either' in ghci.
06:01:58 <mniip> EvanR_, newtype IO = IO (State# RealWorld)
06:02:03 <EvanR_> frerich: youre right. bloot AppData is a normal type which would be passed to you by the framework at some point
06:02:09 <mniip> er
06:02:20 <EvanR_> mniip: *headscratch* well i was referring to good explanations
06:02:21 <mniip> newtype IO = IO (RealWorld -> State# RealWorld)
06:02:30 <mniip> er
06:02:33 <mniip> I can't get it right
06:02:48 <EvanR_> that doesnt look like a good one
06:03:37 <nshepperd> newtype IO a = IO (RealWorld -> (# a, RealWorld #)) or something like that
06:04:12 <EvanR_> is there a place that uses that as an explanation of IO?
06:04:15 <mniip> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
06:05:12 <merijn> mniip: Requires MagicHash and unboxedtuples
06:05:16 <mniip> yes
06:05:24 <mniip> where State# is a Proxy that takes up no space and only enforces evaluation order
06:05:44 <merijn> This is not really an explanation as much as an implementation detail, though
06:05:47 <mniip> merijn, also import GHC.Exts and GHC.Prim
06:05:50 <merijn> Because it doesn't account for multithreading
06:06:01 <EvanR_> it sounds like something that should never have left ghc headquarters
06:06:11 <merijn> EvanR_: It should, it useful for low level code
06:06:12 <EvanR_> because its not illuminating about haskell 
06:06:25 <EvanR_> and misleadingly labeled
06:06:27 <merijn> EvanR_: It's exported because it allows you to write more efficient primitives
06:06:44 <merijn> EvanR_: In GHC ST and IO are just specialisations of a lower level primitive monad
06:07:24 <merijn> nshepperd: It's not so much a hack as it is an implementation detail of GHC, there are other ways to do the same
06:07:45 <nshepperd> also the fact that you can't actually save the RealWorld and put it back later to undo your evil deeds when it all goes wrong
06:08:17 <merijn> EvanR_: It's exposed for the same reason that "data Int = I# Int#" is exposed, because it's useful
06:08:27 <merijn> nshepperd: Did you see the acme realworld package? :D
06:09:09 <muzzle> hi can anyone help me with a question about the sodium FRP package ?
06:11:04 <nshepperd> hypothetically is my favourite combinator
06:11:30 <fractalsea> If I want to define a new typclass instance for a library type, where should I put this?
06:11:39 <fractalsea> At the moment it‚Äôs warning me that it‚Äôs an orphaned instance
06:12:08 <muzzle> I want to build something like (a -> b -> c) -> Behaviour a -> Behaviour b -> Behaviour c, how can i best do this ?
06:12:19 <pacak> fractalsea: Either next to class declaration or next to datatype declaration.
06:12:31 <merijn> fractalsea: An instance is an orphan when it's not in either 1) the same module as the datatype or 2) the same module as the class
06:13:02 <fractalsea> Is there anything I can do then if both the class, and the type are in library modules?
06:13:04 <merijn> fractalsea: Orphan instances work, but the problem is that orphans may result in multiple instances for a class+type in a single program, which is not allowed
06:13:09 <fractalsea> Other than modifying the libraries
06:13:17 <fractalsea> OK
06:13:37 <merijn> fractalsea: Hence the warning. They should be avoided *if possible*
06:13:51 <ab9rf> muzzle: isn't that liftM2?
06:13:52 <fractalsea> merjin: I guess I‚Äôll just leave it then. Thanks
06:13:55 <merijn> And you should be aware that if some other library you use defines the same instance your code might break
06:13:55 <ab9rf> :t liftM2
06:13:56 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:14:19 <fractalsea> merjin: Got ya. Pretty sure it doesn‚Äôt though
06:14:37 <gcganley> :t liftM2 id
06:14:38 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
06:14:47 <EvanR_> when is it not possible to avoid orphan instances
06:14:58 <merijn> fractalsea: Depends on the type/instance, you're *usually* fine, avoiding orphans just guarantees you're fine
06:15:11 <merijn> EvanR_: If neither the type NOR the class are in your own package
06:15:24 <fractalsea> merjin: Makes sense
06:15:27 <merijn> i.e. a class defined in package foo and datatype defined in bar where bar does not depend on foo
06:15:34 <merijn> (nor foo on bar)
06:15:41 <EvanR_> oh that sucks
06:15:48 <merijn> Otherwise you'd have to add a package dependency just to define the instances
06:16:19 <merijn> For classes in base that doesn't matter, but for example something like contravariant can be an issue
06:16:23 <mniip> getContents is interleaved?
06:16:47 <merijn> What if a library has a datatype that can be contravariant, do you add that dependency or not?
06:17:01 <merijn> It's an open problem, Rust is having similar issues
06:17:56 <ab9rf> i think all language ecosystems end up struggling with this issue at some point
06:18:05 <mniip> merijn, I guess a simple take would be only to add dependencies to "common" packages
06:18:21 <merijn> I hope ezyang comes up with a neat way to solve this in his backpack work
06:18:32 <merijn> mniip: OCaml style functors might work
06:18:46 <merijn> If someone comes up with a sensible way to combine OCaml functors + typeclasses
06:18:48 <mniip> merijn, "if-installed" sort of macros?
06:19:16 <merijn> mniip: That's already possible, but breaks in the presence of transitive dependencies
06:20:00 <merijn> mniip: foo implements a class for a type from "bar" IFF bar is installed. Now quux uses foo's instance for bar which wasn't yet installed when I compiled foo, now what?
06:20:30 <muzzle> ab9rf: Behaviour is not a monad
06:22:14 <merijn> muzzle: It should be an Applicative, no?
06:22:18 <merijn> :t liftA2
06:22:19 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:22:50 <merijn> Also known as "f <$> a <*> b"
06:23:02 <merijn> :t \f a b -> f <$> a <*> b
06:23:03 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
06:24:03 <EvanR_> how do you turn the monomorphism restriction on?
06:24:58 * hackagebot Plot-ho-matic 0.5.0.1 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.1 (GregHorn)
06:25:00 <nshepperd> -XMonomorphismRestriction seems to exist
06:25:00 <muzzle> :merijin yeah, it is 
06:25:01 <muzzle> thx
06:25:23 <merijn> EvanR_: It's on by default (except in ghci in recent versions)
06:25:34 <EvanR_> i thought it was recently turn off
06:25:41 <merijn> EvanR_: Only for ghci
06:25:43 <EvanR_> ok
06:25:47 <nshepperd> also, ':set -X<tab>' in ghci is suprisingly useful
06:25:50 <merijn> EvanR_: Because you almost never want that in ghci
06:26:09 <hibou107> hi
06:26:23 <hibou107> I don't know how to use the library https://hackage.haskell.org/package/linear-1.17.1/docs/Linear-Matrix.html
06:26:33 <hibou107> i did cabal install linear
06:26:57 <hibou107> from ghci i did: "import Linear.Matrix"
06:27:11 <hibou107> but when I type : "V2 (V3 1 2 3) (V3 4 5 6) !*! V3 (V2 1 2) (V2 3 4) (V2 4 5)"
06:27:34 <hibou107> I'vve got the error  Not in scope: data constructor `V2'
06:27:57 <mniip> import Linear.V2
06:28:01 <mniip> and V3
06:28:15 <frerich> Or just 'import Linear'
06:28:34 <dramforever> Hi all.
06:28:52 <hibou107> Thanks
06:28:58 <hibou107> thanks mniip 
06:28:59 <hibou107> and frerich 
06:31:11 <dramforever> hello?
06:31:34 <Xenasis> Is there any combination of library functions I could use to get the combinations of two lists (arguments) as pairs/two elment lists?
06:31:36 <Xenasis> As an example
06:31:45 <Xenasis> f [1, 2] [3, 4] = [(1, 3), (2, 4), (1, 4), (2, 3)]
06:31:47 <dramforever> :t zip
06:31:48 <lambdabot> [a] -> [b] -> [(a, b)]
06:31:54 <Xenasis> Yeah, that's not what I mean
06:32:07 <dramforever> > liftM (,) [1,2] [3,4]
06:32:07 <Xenasis> Zip doesn't give combinations
06:32:08 <lambdabot>  Couldn't match expected type ‚Äò[t0] -> t‚Äô
06:32:08 <lambdabot>              with actual type ‚Äò[b0 -> (a10, b0)]‚Äô
06:32:13 <dramforever> how about this?
06:32:14 <dramforever> ouch
06:32:21 <Xenasis> doesn't look like it compiles
06:32:28 <dramforever> > liftM2 (,) [1,2] [3,4]
06:32:29 <mniip> > liftA2 (,) [1,2] [3,4]
06:32:31 <lambdabot>  can't find file: L.hs
06:32:31 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
06:32:53 <dramforever> heh? who's one is that
06:32:54 <mniip> alternatively
06:33:00 <Xenasis> Sweet
06:33:02 <mniip> > (,) <$> [1,2] <*> [3,4]
06:33:04 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
06:33:10 <Xenasis> that one looks unreadable :P
06:33:13 <Xenasis> thanks anyway!
06:33:18 <Xenasis> I'll use the first one
06:34:10 <clrnd> > (<*>) ((<$>) (,) [1,2]) [3,4]
06:34:11 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
06:34:17 <dramforever> Is there any good tutorial on free monads? it seems that it's kinda like Operational
06:34:19 <merijn> How about zipWith?
06:34:24 <merijn> oh, wait nvm
06:34:27 <dramforever> @hackage operational
06:34:27 <lambdabot> http://hackage.haskell.org/package/operational
06:34:45 <clrnd> I read one by kmett pretty nice
06:34:46 <merijn> dramforever: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ?
06:35:10 <dramforever> merijn: thanks for that I'll check it out
06:36:00 <clrnd> dramforever, http://comonad.com/reader/2011/free-monads-for-less/
06:36:10 <dramforever> also has anyone compared operational with free monads?
06:36:21 <dramforever> clrnd: yeah thanks
06:37:09 <dramforever> hmm...actually I was looking for the "monad evaluator" usage of free monads
06:37:18 <mniip> Xenasis, the mnemonic is simple
06:37:27 <mniip> <$> and <*> are like application
06:37:39 <Xenasis> Is <$> a different way of writing $?
06:37:42 <mniip> you have 'function <$> list' and 'list of functions <*> list'
06:37:46 <dramforever> :t (<$>)
06:37:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:37:53 <Xenasis> what's a Functor?
06:37:55 <tdammers> Xenasis: it's not the same, but somewhat similar
06:37:58 <mniip> Xenasis, uhh
06:38:05 <dramforever> uhh...
06:38:06 <tdammers> <$> is a synonym for fmap
06:38:13 <Xenasis> ah
06:38:30 <dramforever> mniip: ouch maybe it's too early to tell Xenasis that stuff
06:39:03 <mniip> Xenasis, I guess it's the time you need to read about functors and applicatives
06:39:37 <dramforever> Xenasis: how much haskell do you have? (I just found a new way to ask!)
06:39:41 <EvanR_> i got by a long time without knowing about Functor, haskell is great that the learning curve is slow shallow ;)
06:39:44 <Xenasis> I do remember reading about fmap if that helps
06:40:09 <dramforever> EvanR_: the learning curve is polymorphic
06:40:15 <dramforever> ouch spelling...
06:40:26 <Xenasis> I'm not sure exactly how much, but I can sometimes use the List monad and I've written a Sat solver in Haskell
06:40:37 <EvanR_> bit by bit you can accumulate tools
06:40:41 <Xenasis> I'm not sure what exactly what metric to use
06:41:06 <dramforever> EvanR_: there's almost nothing you can't do yourself
06:41:09 <tdammers> there's not really a uniform one-dimensional learning curve
06:41:15 <tdammers> just a bunch of concepts and idioms you can learn
06:41:22 <lpsmith> hmm,  out of curiousity,  is there a concurrent bracket combinator,  something along the lines of    bracket (concurrently (connect source) (connect dest)) (\s d -> concurrently (close s) (close d)) (do something)
06:41:24 <tdammers> and some of them depend on one another, others don't
06:41:26 <dramforever> I mean, you could have re-invented a large part of the standard library
06:41:57 <EvanR_> dramforever: sometimes you wouldnt think to invent it though
06:42:05 <alanz> bgamari: I see in the logs you had an issue installing gio-0.13.0.5. How did you get around it?
06:42:41 <lpsmith> One issue with the construct I gave,  is if one connection succeeds,  and then the other fails,  you'll have to rely on GC to close the successful connection.  
06:43:04 <bgamari> alanz, I ended up getting sucked down the rabbit hole looking for the root cause and ultimately gave up
06:43:26 <mniip> [16:36:06] <dramforever> mniip: ouch maybe it's too early to tell Xenasis that stuff
06:43:28 <alanz> ok. This was with 7.10 RC2 ?
06:43:35 <mniip> when a function and a container love each other very much...
06:43:51 <Guest37504> >https://gist.github.com/anonymous/5ad12cd925494285d7b9
06:43:52 <bgamari> alanz, I have heard reports that adding --force somewhere in the cabal command line helps
06:43:53 <exio4> I'd say context
06:43:59 <bgamari> alanz, yep
06:44:01 <Guest37504> what does ! mean in this
06:44:16 <mniip> Guest37504, strict fields
06:44:18 <alanz> bgamari: ok, thanks. Time to investigate the travis script
06:44:30 <lpsmith> which,  if the second unsuccessful connection fails slowly,  i.e. several minutes or maybe even several hours,  then the first connection is likely been promoted several GC generations,  and will thus take a long time to collect.
06:44:54 <mmachenry> Guest37504: It means that creation of those fields are strict rather than lazy
06:44:59 * hackagebot vcache-trie 0.1.1 - patricia tries modeled above VCache  http://hackage.haskell.org/package/vcache-trie-0.1.1 (dmbarbour)
06:45:12 <Guest37504> mniip: Ah, thanku
06:45:53 <alanz> bgamari: it fails with the same problem. Step gently away ...
06:46:06 <bgamari> alanz, heh, I'm trying to find the reference in my logs
06:46:44 <bgamari> It would be nice if gtk2hs's build system were a little more conventional
06:47:43 <alanz> bgamari: http://ircbrowse.net/browse/haskell?q=gio
06:47:56 <bgamari> I'd really like to split cairo out of gtk2hs entirely
06:48:05 <alanz> and yes, it would be. But a complex environment I guess
06:48:21 <bgamari> as it's not even really a gtk package and should be easy to bind
06:54:22 <fractalsea> Is there a way of lifting a function from IO a -> IO b to working with MonadIO instead? 
06:54:44 <ski> fractalsea : not really, in general
06:55:05 <fractalsea> ski: hmm OK, what about System.Timeout?
06:55:06 <dramforever> the word "contravariant" comes out
06:55:31 <dramforever> I mean, pops up in my mind
06:55:35 <kala> hello people
06:55:52 * ski lifts hat to kala
06:56:13 <ski> fractalsea : hm, i'm not sure
06:56:22 <fractalsea> ski: My IO is wrapped in a monad transformer, and I would like to add a timeout while still staying in the transformer
06:56:36 <dramforever> kala: yes, we are "helloed"
06:56:44 <__Guest> given "data A = B | C" and "data AKind :: A -> * where BType :: AKind B" and "CType :: AKind C" and "run :: (forall a. (String -> Maybe (AKind a))) -> (AKind a -> r) -> String -> Maybe r" how can i get a polymorphic "(String -> Maybe (AKind a)" ?
06:57:08 <fractalsea> ski: hmm OK, seems like a common requirement, but I can‚Äôt seem to find much on it
06:58:07 * ski imagines that kala might have a question
06:58:46 <kala> lol
06:59:11 <kala> ski : Can we make a list of all the intermediate calculations of a recursive function
06:59:12 <kala> ?
06:59:22 <mniip> hmm, if a `coprime` b then (a `mod` b) `coprime` b, right?
06:59:32 <dramforever> hi, how portable is {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-}
06:59:40 <fractalsea> ski: I guess I could do valueInTransformer >>= (\v -> liftIO $ timeout 1000000 (return v) 
06:59:43 <ski> kala : do you have some example code to paste ?
07:00:01 <ski> __Guest : sounds a bit useless
07:00:10 <dramforever> kala: yes but what's "intermediate calculations"
07:00:15 <indiagreen> fractalsea: http://hackage.haskell.org/package/lifted-base-0.2.3.6/docs/System-Timeout-Lifted.html
07:00:29 <kala> ski :yeah for exponential smoothing : avg (x:xs) = (a*x) + (1-a)*(avg xs)
07:00:35 <__Guest> ski: parsing user input in to GADTs
07:00:39 <fractalsea> indiagreen: Awesome!
07:01:06 <indiagreen> in general, if you're looking for a MonadIO version of a function, it'll be in lifted-base
07:01:12 <ski> fractalsea : do you want to timeout an I/O-computation, or just an evaluation ? if the latter, look into using `evaluate', and possibly `seq' or similar inside `timeout'
07:01:43 <fractalsea> ski: Timeout an io computation
07:01:46 <ski> kala : and the base case ?
07:01:56 <ski> fractalsea : then what you suggested will not work
07:02:13 <Xnuk> I just installed lambdabot on my computer, and when I tried "> 1+1", it says: L.hs:63:8: Could not find module `Lambdabot.Plugin.Eval.Trusted'
07:02:18 <Xnuk> what should I do?
07:02:25 <fractalsea> indiagreen: And I need to do the same for HUnit.Test.TestCase‚Ä¶
07:02:33 <ski> __Guest : yes. but i think `forall a. (String -> Maybe (AKind a))' doesn't mean what you think it means
07:02:57 <fractalsea> ski: Hmm OK, I thought there might be something wrong with it, but I‚Äôm never sure when it comes to reasoning about when things are actually evaluated in Haskell
07:03:24 <ski> __Guest : it means that an operation of that type must, given a string, maybe return a value of type `AKind a', for any value `a' (of type `A') the *caller* of this operation wants
07:03:40 <kala> ski : please have a look at the code here ---  http://lpaste.net/124274
07:04:12 <ski> __Guest : so, the code that implements this operation can *not* decide whether to use `B' or `C' for `a' there, depending on which `String' it sees -- since that's not what the type means
07:04:19 <__Guest> ski: my bad, i mean 'forall k. (String -> Maybe (AKind a))'
07:04:46 <ski> __Guest : hm, `k' is unused there, so why quantify over it ? also, where is `a' quantified ?
07:05:00 <hibou107> what is the best haskell library to inverse a matrix ?
07:05:10 <niluje> I have data Sample = Sample {hello :: String, quiet :: Bool}. How can I write a function that takes a Sample and pattern matching only on "quiet"? func Sample { quiet=True } = <whatever> works, but I can't use "hello" in it
07:05:23 <__Guest> ski: i will upload my test code
07:05:27 <kala> ski : can i save the intermediate values created during every recursion in a list.. Please have a look at the code here : http://lpaste.net/124274
07:05:59 <ab9rf> kala: maybe use the writer monad to accomplish that
07:06:32 <nerium> How come the Art constructor takes a string in this example? https://gist.github.com/oleander/69b6c7922d3e11e7e2e8
07:06:42 <nerium> When I*ve only told "run" to do so
07:07:16 <__Guest> ski: http://sprunge.us/IPUS i realize the forall was redundant, my bad. i still am troubled with (in this example) converting a Food in to a FoodKind
07:07:26 <ski> kala : which intermediate values do you want to see ? the partial sums ?
07:08:16 <lpaste> alanz pasted ‚Äúgio.cabal installing 7.10 Rc2‚Äù at http://lpaste.net/124276
07:08:24 <indiagreen> fractalsea: that's impossible without rewriting half of HUnit
07:08:46 <alanz> bgamari: Commented out the modules it was complaining about dups, it installed
07:08:58 <fractalsea> indiagreen: OK thanks. That‚Äôs good to know so that I don‚Äôt waste anymore time
07:11:15 <indiagreen> dramforever: are you talking about supported GHC versions, or other compilers too?
07:11:40 <indiagreen> GHC and Hugs support both fundeps and MPTC, but JHC doesn't
07:12:14 <indiagreen> on the other hand, JHC has type families, which can often replace those
07:15:17 <geekosaur> nerium: you told Art to take a String. the only difference between data Art = Art String; and data Art = Art { run :: String }; is that the latter names the parameter and gives you an accessor function, whereas it must be pattern matched by position in the former
07:15:35 <geekosaur> what did you think record syntax did?
07:16:05 <nerium> geekosaur: I trough it was just a struct with a function called "run" which takes a string
07:16:51 <geekosaur> "takes a string" and produces what? that is, it can't be what you're thinking of
07:17:43 <ski> __Guest : hm .. as you placed the `forall' above, it was not redundant
07:17:50 <geekosaur> (note, it can't be "takes a String and produces an Art"; GADTs give you that but you have to say so explicitly in the constructor type. and in fact what `run` does is the opposite, given an Art give you the String)
07:18:43 <ski> __Guest : anyway, i think you rather want existentials here than universals (`forall')
07:19:40 <nerium> geekosaur: Aha, thanks!
07:19:43 <__Guest> ski: i've heard of existentials but i haven't found any good material. my specific goal is to 'merge' 'hayToKind' and 'seaweedToKind' in a way, though that may not be possible. could you suggest any good reading? 
07:21:11 <ski> fractalsea : evaluation is not execution, when `valueInTransformer >>= (\v -> liftIO $ timeout 1000000 (return v)' is executed, first `valueInTransformer' is executed, and `v' is bound to the monadic value of that (possibly not evaluated (completely) yet, depending). then `liftIO $ timeout 1000000 (return v)' is executed, which executes `timeout 1000000 (return v)' in an underlying I/O-layer, which executes `return v' after setting up a timeout thing, which
07:21:30 <ski> (cut off : ".., which executes `timeout 1000000 (return v)' in an underlying I/O-layer, which executes `return v' after setting up a timeout thing, which immediately results in `v'")
07:21:50 <fractalsea> ski: I see, thanks for the explanation
07:22:26 <sleepomeno> how can I update the first element of a list which satisifies a condition using the lens library?
07:22:46 <ski> fractalsea : one can use `evaluate' to make sure that (the top constructor) of some value is evaluated as an `IO'-action is executed. so the action won't "release" the value until that part of the evaluation has been done
07:23:14 <ski> fractalsea : but in this case you didn't just want to timeout on evaluation of `v', but on the I/O-operations in `valueInTransformer' as well
07:23:36 <fractalsea> ski: Yeah that‚Äôs right
07:23:51 <__Guest> ski: thanks for the help, ciao
07:24:18 <ski> (argh, __Guest left before i could answer ..)
07:24:50 <mniip> hpc, I found another interesting problem in Quotient
07:24:57 <mniip> 0.1 - 0.1 :: Quotient is bottom
07:25:02 <ski> fractalsea : anyway, "Monadic tunnelling: the art of threading one monad through another" by Jules Bean in 2007-07-11 at <https://mail.haskell.org/pipermail/haskell-cafe/2007-July/028501.html> is relevant to your question
07:30:35 <juanpaucar> In cabal files which is preferred, ==version.*
07:30:54 <juanpaucar> or >=version.subversion && < version.anothersubverison ?
07:38:28 <indiagreen> sleepomeno: taking 1 (filtered pr) %~ f
07:38:31 <indiagreen> probably
07:40:01 <ClaudiusMaximus> juanpaucar: ==a.b.* is what i usually use, unless i know it works with more than one a.b, then i use >= a0.b0 && < a1.b1
07:40:20 <indiagreen> > [1,3,4,8] & taking 1 (filtered even) %~ negate
07:40:22 <lambdabot>  No instance for (GHC.Show.Show t0)
07:40:22 <lambdabot>    arising from a use of ‚ÄòM695642306958705276727410.show_M6956423069587052767...
07:40:22 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
07:40:34 <indiagreen> > [1,3,4,8] & taking 1 (filtered even) %~ negate :: [Int]
07:40:35 <lambdabot>  No instance for (GHC.Real.Integral [GHC.Types.Int])
07:40:36 <lambdabot>    arising from a use of ‚ÄòGHC.Real.even‚ÄôNo instance for (GHC.Num.Num [GHC.Typ...
07:40:36 <lambdabot>    arising from a use of ‚ÄòGHC.Num.negate‚Äô
07:41:54 <sleepomeno> indiagreen: thanks!
07:42:06 <indiagreen> no, wait
07:42:10 <indiagreen> I found the correct one
07:42:11 <indiagreen> > [1,3,4,8] & taking 1 (each . filtered even) %~ negate
07:42:13 <lambdabot>  [1,3,-4,8]
07:42:34 <indiagreen> I wonder whether there's a simpler solution...
07:43:02 <BurningCa007> Hi, anyone mind helping me getting haskell setup on windows? I can't seem to figure out how to do hello world with it...
07:43:20 <bloot> BurningCa007: did you install the haskell plattform?
07:43:25 <bloot> with/without winghci?
07:43:38 <BurningCa007> Uhm I've tried that and minghci
07:43:47 <BurningCa007> but I kept getting errors in windows 8.1 64 bit
07:43:58 <indiagreen> show us the error, please
07:44:03 <bloot> what kind of error, yes?
07:44:16 <BurningCa007> it had to do with cabal and the roaming config file
07:44:17 <sleepomeno> indiagreen: i just found: [1,3,4,8] & elementOf (Control.Lens.each . filtered even) 0 %~ Prelude.negate
07:44:25 <sleepomeno> seems to be doing the same
07:44:53 <BurningCa007> so for a newbie do I want haskell platform or that minghc?
07:45:00 <indiagreen> it's the same, but it's not really simpler
07:45:01 <silver> platform
07:45:17 <BurningCa007> 64 bit I presume?
07:45:19 <bloot> can you launch WinGHCI?
07:45:22 <silver> works on win7
07:45:36 <bloot> (winghci is the graphical version)
07:46:06 <bloot> silver: it works for me on 8.1
07:46:18 <BurningCa007> alright
07:46:20 <BurningCa007> winghci
07:46:21 <BurningCa007> is up
07:46:42 <bloot> dois it show Prelude >?
07:46:47 <BurningCa007> yes
07:47:01 <bloot> then type putStrLn "hi" and press enter
07:47:08 <BurningCa007> alright that works
07:47:15 <bloot> Prelude> putStrLn "hi"
07:47:15 <bloot> hi
07:47:25 <BurningCa007> thanks, so how the hell do I get this to compile a .hs file?
07:47:38 <bloot> With ghc but you have to use the windows command prompt
07:47:48 <BurningCa007> -.-
07:47:54 <geekosaur> ghci is not an IDE, it's a deskcalculator
07:47:59 <bloot> yep
07:48:06 <bloot> Windows+R -> cmd.exe
07:48:07 <indiagreen> sleepomeno: you can replace ‚Äútaking 1‚Äù with ‚Äúsingular‚Äù, turns out it won't error out when there's no matching element when you use it as a traversal and not as a lens
07:48:23 <BurningCa007> ok so I got a hellohaskell project
07:48:27 <bloot> ghc --make foo.hs -o foo.exe
07:48:29 <BurningCa007> it is sandbox init'd on cmd
07:48:48 <geekosaur> if you want an IDE, there's leksah and there's an eclipse plugin (eclipsefp) and I think some other things
07:48:54 * geekosaur doesn't use IDEs much
07:49:01 <BurningCa007> yea intellij plugin gave me errors
07:49:18 <dropp> i didn't have much luck with leksah
07:49:22 <dropp> i just use emacs
07:49:26 <dropp> emacs = king
07:49:27 <bloot> I never got leksah running
07:49:28 <BurningCa007> leksah appears to be broken on windows
07:49:39 <bloot> I use notepad++ :)
07:49:44 <dropp> leksah crashes pretty regularly on mac too
07:49:59 <dropp> i liked notepad++ when i was using a windows box
07:50:04 * hackagebot StateVar 1.1.0.0 - State variables  http://hackage.haskell.org/package/StateVar-1.1.0.0 (SvenPanne)
07:50:11 <dropp> but there is no notepad++ on mac or linux
07:50:17 <dropp> and those are my preference environments
07:50:24 <BurningCa007> oh ty bloot
07:50:27 <BurningCa007> for the command
07:50:39 <BurningCa007> now why would I want to cabal sandbox init?
07:50:40 <aawe> dropp: sublime text is great if you liked np++
07:51:09 <indiagreen> aawe: also not free
07:51:48 <aawe> indiagreen: Yeah, it says so on right on their home page
07:52:27 <tdammers> "not free" -> "I am at the vendor's mercy and may have to find a new text editor on a moment's notice"
07:52:27 <dropp> just use emacs like real developers :-)
07:52:37 <joobus> dropp: you mean vim...
07:52:38 <tdammers> dropp: s/emacs/vim/ ftfy
07:52:52 <dropp> joobus: i most certainly do *not*
07:53:02 <joobus> no, you do.  you're just confused.
07:53:07 <dropp> lol
07:53:11 <dropp> i used to use vim
07:53:27 <joobus> sorry to hear about your debilitating injury :P
07:53:31 <dropp> in fact, when i started using emacs, i caufght myself typing :wq into the buffer by accident
07:53:33 <aawe> tdammers: Give me a scenario where you would have to instantly uninstall your proprietary editor
07:53:52 <dropp> also, when i started using emacs, i used to open a file, make a change, close emacs
07:53:56 <carter_cloud> worst case you have to migrate to Atom, which is slower than sublime but not proprietary
07:54:00 <carter_cloud> but slower
07:54:00 <joobus> lol
07:54:02 <dropp> i just recently got inot the habit of keeping it open
07:54:10 <tdammers> aawe: upgrade OS to next release; proprietary editor is now incompatible
07:54:14 <ski> dropp : `emacsclient'
07:54:29 <tdammers> aawe: I wouldn't have to reinstall, but the editor would still be useless
07:54:32 <joobus> carter_cloud: in my experimentation, atom just isn't ready yet.
07:54:34 <aawe> tdammers: yeah, free software is never incompatible *cough*
07:54:47 <carter_cloud> yeah, its not very mature
07:55:04 <jtanguy> let's not get into $EDITOR wars please
07:55:07 <dropp> i have a emacs client already :-) what is that supposed to do, ski?
07:55:13 <aawe> Atom recently switched out the rendering code, might be faster now
07:55:18 <tdammers> aawe: it is, but when that happens, me or someone else can usually fix it
07:55:43 <dropp> ski: nm, google ftw
07:55:46 <tdammers> sometimes even just by recompiling
07:55:49 <dropp> this might be helpful
07:55:52 <exio4> and most of the problems with propietary stuff is just old build
07:55:53 <ski> dropp : you start an emacs server, then `emacsclient' will connect to it every time you start it. you could set `:e' in GHCi' to call it, e.g.
07:55:57 <dropp> but i have kicked the habit as it were
07:56:07 <BurningCa007> ty for help guys
07:56:16 <dropp> hrm.. that is kind of cool
07:57:26 <osa1> any ideas about how to solve this: http://lpaste.net/124277 ?
07:57:29 <aawe> I guess I am too pragmatic to base my choice of editor on whether it will break some time in the future rather than how productive I am using it
07:57:33 <dropp> emacs just makes things easier for me as a whole though, between orgmode for tasks/scheduling, various modes for coding in haskell, c++, ruby, etc., running code directly via interactive ghci, and the like, etc.
07:57:46 <ski> dropp : .. and `C-x C-c' will of course just save the file passed to `emacsclient', and detach and terminate that, not terminate the emacs session
07:57:51 <dropp> i know some vimmers will say that all of these are available in vim too
07:58:07 <aawe> osa1: you could try using a cabal sandbox to avoid clashes with your current packages
07:58:16 <osa1> aawe: this is already in a sandbox
07:58:21 <dropp> i just understand why anyone would want to learn such a horrible language like VIMscript
07:58:30 <tdammers> dropp: I won't say that. Rather, I'll say that these things don't belong in a text editor :D
07:58:41 <dropp> lol, touche tdammers
07:58:43 <tdammers> (and fwiw, I've never written a line of vimscript)
07:58:43 <phadej> osa1: prune the sandbox and install with tests
07:58:54 <osa1> phadej: didn't work
07:59:01 <BurningCa007> uhm what does Int :: y do?
07:59:22 <BurningCa007> declare an int?
07:59:26 <indiagreen> BurningCa007: seems meaningless to me, did you mean ‚Äúy :: Int‚Äù?
07:59:27 <ski> no
07:59:34 <ski> BurningCa007 : where did you see it ?
07:59:35 <dropp> i love that if i need some custom feature, i just pop into a new buffer, write up some lisp code, and voila, the editor sucumbs to my wishes
07:59:47 <BurningCa007> http://www.seas.upenn.edu/~cis194/lectures/01-intro.html
07:59:51 <aawe> dropp: example?
08:00:09 <tdammers> dropp: I do that by popping into a new buffer, writing a shell script, and voila, I can run it with :! or whatever
08:00:14 <BurningCa007> how do you use y :: Int?
08:00:20 <indiagreen> BurningCa007: ‚Äúy :: Int‚Äù means that ‚Äúy‚Äù has type ‚ÄúInt‚Äù
08:00:48 <aawe> BurningCa007: it doesn't "do" anything, it declares that y is an int. it's like an annotation
08:01:10 <BurningCa007> so how would I declare an int and assign a value to it and print it
08:01:11 <phadej> osa1: the next step would to try with some stackage config
08:01:17 <indiagreen> the whole piece of code, ‚Äúy :: Int; y = y + 1‚Äù means that you're declaring ‚Äúy‚Äù to be equal to ‚Äúy + 1‚Äù (which means that you won't ever be able to compute ‚Äúy‚Äù, by the way), and that ‚Äúy‚Äù is a number, i.e. ‚ÄúInt‚Äù
08:01:27 <dropp> aawe: lets say that i have a bunch of code to sort through and i need a function to break it up by a delimiter and then run some additional processing, maybe add underscores or something. i could code up a function to do this and bind it to a key and voila
08:01:32 <ski> it declares your intension that `y' should be an `Int' (a fixed-precision integer, typically roughly what fits into a machine word)
08:01:44 <phadej> osa1: and tweak it, if you need something newer somewhere. Seems that you don't, as transformers is 0.3
08:01:52 <ski> if the remaining code is not consistent with `y' being an `Int', the implementation will complain
08:02:08 <osa1> phadej: that is probably globally installed version, I use newer versions but I always use sandbox
08:02:09 <dropp> sure this is possible in other languagesand certainly you could do this in the the shell too, but hwy have to jump around? 
08:02:32 <aawe> dropp: I just select the first delimiter and press CTRL+D until all occurences I want are selected, then I can edit all those places simultaneusly. Or I select some lines, press CTRL+SHIFT+L, and edit the beginning or end of those lines simultaneously
08:02:33 <osa1> well, I have transformers-0.4.1.0 installed globally too
08:02:47 <ski> BurningCa007 : btw, note that there is no *re*assignment of variables in Haskell. you can set an initial value, but you can't change the value to something else. that's by design
08:02:54 <aawe> or create a selection and use regex search-and-replace within it
08:02:58 <dropp> aawe: that was a contrived example, that's possible in emacs too
08:03:03 <dropp> by default
08:03:16 <osa1> I've never seen this cabal error before, is this new?
08:03:21 <dropp> oh whatever, agree to disagree
08:03:29 <dropp> nerdtree is nice in vim
08:03:34 <ski> BurningCa007 : so, typically we don't talk about "assigning a value to a variable", we talk about "binding a variable to a value" or "defining a variable to be equal to a value"
08:03:36 <aawe> perhaps it's unfair of me to demand an example, examples are hard
08:03:38 <dropp> i've been using neotree, a copy of nerdtree, for emacs
08:03:50 <aawe> emacs scares me away with the tonnes after tonnes of keybindings
08:04:08 <BurningCa007> eugh I really should read up on this, but just a simple piece of code please, declare integer, set it and print it
08:04:10 <dropp> aawe: that was a little tough at first i admit
08:04:25 <dropp> and sometimes the commands can be several strokes long
08:04:41 <indiagreen> BurningCa007: the whole *point* is that you don't ‚Äúset‚Äù variables
08:04:45 <dropp> i tend to bind the ones i use more commonly to shorter key strokes
08:04:54 <BurningCa007> I mean set it once
08:05:01 <indiagreen> ah, okay
08:05:05 * hackagebot lucid-svg 0.4.0.4 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.4.0.4 (jeffreyrosenbluth)
08:05:12 <ski> BurningCa007 : `main = print x where x :: Int; x = 42'
08:05:21 <indiagreen> http://lpaste.net/124279
08:05:25 <ski> BurningCa007 : you can omit the `x :: Int;' part
08:05:41 <osa1> hm, so apparently a version of this package is globally installed because it's a dependency of ghc-7.8.3
08:06:11 <BurningCa007> huh haskell is weird, like I think I better run away and go back to C++ atm
08:06:15 <BurningCa007> ty for all your support tho
08:06:29 <aawe> giving up eh?
08:06:33 <BurningCa007> not really
08:06:37 <aawe> ;)
08:06:41 <BurningCa007> I just can't take the time atm
08:06:47 <BurningCa007> Got a school project to finish in C++
08:06:52 <ski> ok. feel free to come back later
08:06:55 <dropp> i unfortunately had to write an async job scheduling application in ruby and now i am dealing with the complications having to make numerous patches due to issues with ruby's (lack-of valid) concurrency. :-(
08:06:58 <BurningCa007> and I was told I should learn haskell for this uni I got an offer for
08:07:01 <dropp> bbl lads
08:07:13 <mmachenry> I'm having a problem with backtracking in Parsec. http://lpaste.net/124280 I tried to throw in some try's so that it would not suck up input when it fails. I'm trying to parse Scheme characters like #\A or #\newline.
08:07:19 <aawe> BurningCa007: "learn you a haskell for great good" is great for grokking the basics
08:07:33 <nilg> I'm looking for a type class constraint that tells that variable type a is a function, does that exist?
08:08:00 <yoshuawuyts> What do you guys think of rust? Genuinely curious about it.
08:08:12 <EvanR_> nilg: no but you can use (a -> b) instead as the type variable
08:08:19 <aawe> yoshuawuyts: I hope it replaces C++
08:08:34 <aawe> and I like C++
08:09:31 <nilg> EvanR_: it's tricky I what to use that in a GADT, I'm not sure I can
08:09:32 <EvanR_> nilg: (->) is a type constructor like Maybe and [], you can simply use this in your type
08:09:53 <EvanR_> assuming that all you care about is that its a function
08:10:14 <nilg> Schema :: (MyFuncTypeClass a) => a -> (Atom a)
08:10:30 <EvanR_> thats not just "a function"
08:10:31 <hexagoxel> osa1: cabal version? .cabal file? (no promises i can help, i am just curious)
08:10:57 <EvanR_> nilg: whats MyFuncTypeClass ?
08:11:06 <nilg> the magic type class I'm after
08:11:21 <nilg> I'm using data Atom a where
08:11:21 <nilg> ... GADT construct
08:11:30 <EvanR_> why not type Schema = (a -> b) -> Atom (a -> b)
08:11:41 <EvanR_> oh gadt
08:11:42 <ski> s/=/::/
08:13:00 <EvanR_> nilg: so you probably dont want typeclass constraints on the data constructors themselves
08:13:16 <EvanR_> instead putting them on the library operations for the type
08:13:27 <EvanR_> and allow the type to be parameterized by any type a
08:13:37 <indiagreen> nilg: http://lpaste.net/124286
08:13:52 <indiagreen> wouldn't that work?
08:14:06 <Kujanator> I'm trying to implement short circuit booleans in a mini imperative language but am struggling. I've done the eager booleans though. Here's the code if you could have a quick look. http://pastebin.com/iyqQsSV4
08:15:06 * hackagebot hack2-handler-snap-server 2015.3.9 - Hack2 Snap server handler  http://hackage.haskell.org/package/hack2-handler-snap-server-2015.3.9 (JinjingWang)
08:15:24 <nilg> I think that works indiagreen , thank you soooo much!
08:15:50 <cfoch> hello
08:15:52 <EvanR_> did not know about that
08:16:00 <EvanR_> S :: (x -> y) -> G (x -> y)
08:16:05 <kala> indiagreen : can we save intermediate values while applying recursive functions i a list?
08:16:11 <cfoch> what is the config-setup and where do I find it? Does it change when I use a sandbox?
08:16:27 <indiagreen> EvanR_: there's also a fairly common piece of olegery available, http://okmij.org/ftp/Haskell/isFunction.lhs
08:16:48 <aawe> s = return/pure?
08:16:49 <indiagreen> kala: yes, scanl/scanr
08:17:02 <kala> indiagree : thank you
08:17:06 <cfoch> setup-config *
08:17:25 <indiagreen> kala: if your recursion can be expressed with foldl/foldr, of course
08:17:29 <ski> Kujanator : your `Neg' case looks wrong
08:17:36 <ski> kala : wb
08:17:47 <ski> kala : you didn't answer my question from before
08:18:15 <Kujanator> ski: Oh ok, why is that?
08:18:32 <kala> ski : Apologies, I missed it
08:18:48 <ski> Kujanator : it discards any possible updates to the state made by the subexpression (you use the `snd' part, but not the `fst' part)
08:19:12 <ski> <ski> kala : which intermediate values do you want to see ? the partial sums ?
08:19:30 <kala> ski and indiagreen : Please refer to the link here it is a function to perform exponential smoothing : http://lpaste.net/124274
08:19:54 <ski> Kujanator : for short-circuiting, look at the answer of the first evaluation, before deciding whether to do the second or not
08:19:59 <kala> ski: the intermediate values are Exponential moving weigted moving averages
08:20:37 <ski> kala : ok. that doesn't answer my question, though
08:20:55 <ski> aawe : no
08:20:56 <kala> ski : sorry, 
08:21:04 <osa1> what does $w prefix in generated stg name mean?
08:21:27 <indiagreen> kala: I don't know math, can you say where in your function can I see a ‚ÄúExponential moving weigted moving average‚Äù?
08:21:52 <kala> indiagreen: sure.  avg (x:xs) = (a*x) + (1-a)*(avg xs)
08:22:03 <kala> a is the smoothing constant from 0-1
08:22:11 <indiagreen> okay, then I'm confused about what avg does
08:22:19 <indiagreen> it computes an average of a list?
08:22:29 <indiagreen> then what are intermediate values you want?
08:22:35 <indiagreen> averages of parts of the list?
08:22:55 <kala> nope it does compute the average of a list , indiagreen give me a minute i shall lpaste it
08:23:10 <indiagreen> like, if the list is [1,2,3], then you want averages of [1,2,3], [2,3], [3]? confu-usion
08:24:04 <ski> kala : a call like `avg [x1,x2,...,xn]' will evaluate to a sum like `a*x1 + (1-a)*(a*x2 + (1-a)*(..(a*xn + (1-a)*0)..))' .. do you want a list of all the intermediate partial sums `a*xi + (1-a)*(..(a*xn + (1-a)*0)..)' ? in order of ascending `i' ? descending `i' ?
08:24:30 <kala> ski : yes
08:24:38 <ski> which ? :)
08:25:06 * hackagebot handsy 0.0.13 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.13 (utdemir)
08:27:41 <Kujanator> Ski: For the short circuit I think I understand but am struggling to convert it to code. Essentially what I want to say is evalB (a :||: b) s = if a then a else b
08:29:53 <ski> Kujanator : first do a `let' (or `where') for the evaluation of the first subexpression
08:29:59 <ski> then an `if'
08:35:12 <kala> indiagreen and ski : please find the complete explanation here - http://lpaste.net/124288
08:35:14 <kala> Thnaks
08:35:20 <Kujanator> ski: In my head this makes sense and it does compile but it could be completely wrong. evalB (a :&&: b) s = let a = (s a) if a else let b = (s b) if b
08:38:39 <ski> Kujanator : you need an `in' before the first `if'. also that one needs a `then'. dunno what the idea with the second `if' would be
08:39:26 <ski> Kujanator : you need to call an evaluation function on `a' (it's an expression). you can't pass it to a state as an argument (states wants variable names/identifiers, iirc)
08:39:42 <ski> kala : you first have to decide on the order you want
08:41:14 <hibou107> if I make a executable in Haskell, It will include all the dependencies in it ?
08:41:34 <hibou107> so I just have to send the binary file to client ?
08:42:18 <tdammers> no
08:42:27 <tdammers> well, it will include all the haskell dependencies by default
08:42:37 <tdammers> but you still need the system dependenceis
08:42:52 <tdammers> libc, libgmp, and anything used via ffi
08:43:11 <hibou107> but the client does not need haskell platform ?
08:43:14 <tdammers> no
08:43:26 <Kujanator> ski: I think I've confused myself here. The code I sent was meant to be the OR not the AND. 
08:43:35 <hibou107> ok I see, for example the hmatrix package, the client need to install gsl
08:43:37 <ski> Kujanator : same idea applies in either case
08:43:47 <tdammers> hibou107: I think so, yes
08:43:55 <tdammers> hibou107: if that's what hmatrix depends on, that is
08:44:01 <Kujanator> ski: Ok, so since I have an evalA function, that needs to be used?
08:44:11 <tavoll> Hello! Just a simple question: does anyone know any website created with haskell?
08:45:04 <merijn> tavoll: lpaste.net and ircbrowse.net
08:45:11 <indiagreen> haskellers.com
08:45:21 <voidzero> haskellnews.org
08:45:28 <indiagreen> lots of blogs generated with Hakyll
08:45:43 <tavoll> merijn: Thank you
08:45:56 <indiagreen> tavoll: https://github.com/yesodweb/yesod/wiki/Powered-by-Yesod
08:45:58 <exio4> haskell.org too
08:47:00 <tavoll> Thank you to everyone, i think they are enough lol
08:47:08 <kala> ski : the order is from top to bottom
08:47:12 <merijn> exio4: oh, is the new design running on haskell?
08:47:20 <merijn> tavoll: Oh, and obviously Hackage is haskell too
08:47:24 <ski> kala : but in the resulting list, i mean
08:47:33 <merijn> exio4: The wiki was just mediawiki
08:48:15 <exio4> merijn: I checked the link in haskell.org, and saw a .cabal, no idea how haskelly it is :P 
08:50:12 <kala> ski: the resulting list is the last column
08:50:14 <Ferdirand> > (,) <$> [1,2] <*> [3,4]
08:50:14 <kala> forecasts
08:50:15 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
08:50:39 <Ferdirand> whoops, wrong window, sorry
08:52:12 <ski> kala : i still don't know whether you want `[f1,f2,f3,f4]' or `[f4,f3,f2,f1]'
08:55:07 <kala> ski : it is `[f1,f2,f3,f4]' thanks
08:55:08 * hackagebot gulcii 0.2.0.3 - graphical untyped lambda calculus interactive interpreter  http://hackage.haskell.org/package/gulcii-0.2.0.3 (ClaudeHeilandAllen)
08:58:14 <ski> kala : ok. is the input list `[a1,a2,a3,a4]' with this example ?
08:58:55 <kala> yes ski
08:59:01 <ski> kala : if so, it looks to me like your `avg' isn't computing the final `f4' correctly
08:59:23 <kala> ok, nevermind! but how do i save intermediate values?
08:59:51 <kala> ski: at this point I just want to save the intermeduate values in a list
09:00:00 <ski> well, first you'd probably name the result from the recursive call in a `where' (or `let')
09:00:38 <kala> ski, could you lpaste it? im sorry :/
09:00:48 <ski> then you'd decide whether the most recent result (which you want to compute the next recursive result from) is at the front or the back at this list. according to what you said above, it should be at the back, which is slightly awkward ..
09:01:01 <funfunctor> hi
09:01:32 <ski> so, you'd change the single result to a list of results, and extract the most recent one to compute the next one, tacking it on to the list of results (at the end, given what you waid above)
09:02:01 <ski> .. you could alternatively store the list reversed, and only reverse it back at the end, if you prefer (or not reverse back at all, if you decide you like this order better)
09:02:28 <Kujanator> ski: I'm just not getting this. Here's my latest attempt evalB (a :||: b) s = let (s a) in evalA a s if a else let (s b) in evalA if b
09:03:06 <ski> one could also consider rewriting the function to not use explicit recursion, but rather `foldr' or `foldl', and then just replace those by `scanr' or `scanl', as indiagreen suggested
09:03:28 <ski> kala : i'd rather not just give away the solution
09:03:59 <ski> kala : previously, you used a comma in your pairs, why not now ?
09:04:14 <kala> ski : I have been trying this for hours ski :/
09:04:19 <ski> kala : sorry, disregard my last comment
09:04:25 <ski> Kujanator : previously, you used a comma in your pairs, why not now ?
09:04:30 <kala> np
09:04:51 <ski> Kujanator : .. and you still need a `then' for that `else'
09:05:13 <ski> Kujanator : it is `if ... then ... else ...'. no part is optional
09:05:36 <tempname11_> what is the current preferred monad transformer library?
09:05:45 <ski> kala : let's take a simpler example, ok ?
09:06:02 <kala> sure ski
09:06:06 <ski> consider
09:06:11 <geekosaur> tempname11_, mtl. if you are asking based on a web page somrewhere that said that mtl was obsolete, please tell us so we can get it fixed
09:06:31 <geekosaur> *please tell us where you found it
09:06:37 <tempname11_> geekosaur: nope, just had no idea
09:06:50 <ski>   sum :: [Double] -> Double
09:06:55 <tempname11_> thanks
09:06:57 <ski>   sum [    ] = 0
09:07:05 <ski>     sum (x:xs) = x + sum xs
09:07:16 <ski> kala : do you understand this definition ?
09:07:20 <Kujanator> ski: Not sure, just didn't realise I hadn't. Added them in now, when compiling i'm getting an error on the "in", but don't understand why.
09:07:58 <ski> Kujanator : oh, the `in' should be just before the `if' (it's `let ... in ...', where in this case the second `...' is just an `if ... then ... else ...')
09:08:01 <kala> Yes ski, it is to find sum of all element in a list sum[1..n]
09:08:27 <ski> Kujanator : before `evalA', you need `=', as with your other `let's, e.g. the `:&:' case
09:08:36 <lpaste> funfunctor pasted ‚ÄúNo title‚Äù at http://lpaste.net/124289
09:08:46 <funfunctor> ^ is this "good practice" ?
09:09:32 <kala> ski : Yes, it is to find sum of all element in a list sum[1..n]
09:09:46 <ski> kala : now, let's say that we want to return a list of all partial sums, so instead of `sum [a,b,c]' evaluating to `a + (b + (c + 0))', we want `partialSums [a,b,c]' evaluating to a list `[a + (b + (c + 0)),b + (c + 0),c + 0,0]', ok ?
09:10:06 <kala> ski : yes
09:10:32 <ski> funfunctor : sounds fine to me (perhaps a `newtype' instead of a `type', depending ..)
09:10:42 <funfunctor> To give some context the return is from IO actions
09:10:48 <ski> kala : so, we start with
09:10:58 <ski>   partialSums :: [Double] -> [Double]
09:11:04 <funfunctor> ski: wont newtype winding me up with lots of liftIO's though?
09:11:16 <kala> ski : sure.
09:11:31 <ski>   partialSums [    ] = [0]  -- here we return a *list* containing the single result `0', instead of just returning `0' as the result
09:11:42 <kala> ok
09:11:45 <funfunctor> ski: what did you mean by "depending"?
09:12:14 <ski>   partialSums (x:xs) = x + partialSum : partialSums
09:12:16 <ski>     where
09:12:46 <ski> er, actually, it's not so good to name the list the same as the function :)
09:12:48 <ski> retake that
09:12:54 <kala> haha
09:13:20 <ski>   partialSums (x:xs) = x + lastSum : allSums
09:13:21 <ski>     where
09:13:33 <ski>     allSums@(lastSum:_) = partialSums xs
09:13:48 <ski> so, we name the whole list of the partial sums for `xs' `allSums'
09:14:05 <ski> and we also name the first element of that list (the most recent one) `lastSum'
09:14:37 <ski> kala : do you know the `@' symbol in patterns ?
09:15:03 <ski> funfunctor : depending on whether you want it as a distinct type or not ;)
09:15:38 <ski> funfunctor : i don't see how `liftIO' would be related to this ..
09:15:47 <Kujanator> ski: Still not working, although hopefully it's a little bit closer to the solution. evalB (a :||: b) s = let (s, a) = evalA s a in (s, a) if a else let (s, b) = evalA s b in (s, b) if b
09:16:42 <kala> ski : f s@(x:xs)             = x:s
09:17:30 <ski> kala : yes. to match a value with a pattern `<variable>@<pattern>', we first bind `<variable>' to the value, and then *also* try to match the value with `<pattern>'
09:17:30 <funfunctor> ski: http://hackage.haskell.org/package/hlibBladeRF-0.1.0.4/docs/LibBladeRF-Sync.html see the -> IO (Either BladeRFError ())
09:17:47 <ski> kala : so we both give a name to the whole list and to the first element of it, in this case
09:18:10 <ski> kala : do you understand the definition of `partialSums' ? and how it corresponds to the definition of `sum' ?
09:18:33 <funfunctor> ski: have I this the right way around? type is distinct and newtype isn't?
09:19:26 <Lutin`> ski: Is there a reason we're not going the scanl route?
09:19:31 <ski> Kujanator : ok. the next problem is that your `(s, a) = evalA s a' is recursive. it tries to feed back the same state `s' in for evaluating `a' as it got from that same evaluation as output. this `s' in unrelated to the `s' in `evalB (a :||: b) s = ...'
09:20:31 <Lutin`> ski: Or are you working towards that
09:20:32 <ski> Lutin` : i dunno whether kala knows about `foldl' .. also their recursion was direct, didn't use an accumulator
09:20:53 <Lutin`> ah alright, I just popped into the convo
09:21:10 <ski> funfunctor : no, `type' just introduces a synonym, a shorthand. `newtype' (and `data') makes new distinct types
09:21:52 <funfunctor> ski: ah oh, thats what you mean by distinct, ok I had a feeling I was reading that wrong
09:22:03 <ski> funfunctor : .. anyway, i still don't see how `type' vs. `newtype' here would interact with `liftIO'ing
09:22:12 <Kujanator> ski: Would copying the way it's been done in the similar examples i.e (a :&: b) work? So something along the lines of evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in (s1, a) if a else let (s2, b) = evalA b s0 in (s2, b) if b
09:22:16 <RegEchse> (buffer notify highlight 
09:22:18 <RegEchse> argh
09:22:30 <funfunctor> ski: no it wont. So my question is what is best practice here in my use case?
09:22:36 <ski> Kujanator : yes, numbering would do fine
09:24:16 <ski> Kujanator : anyway, `(s, a) if ...' in your `let (s, a) = evalA s a in (s, a) if ...' doesn't look sensible. after you've used `let' to get the result of evaluating the first expression (and the new state), you immediately want to check that boolean you got (so use `if'). it doesn't make sense to write a pair in front of an `if' (a pair is not a function, you can't apply it to anything)
09:24:37 <ski> funfunctor : it depends :)
09:24:51 <funfunctor> ski: on? :)
09:25:00 <funfunctor> i'm still a little confused
09:25:10 <funfunctor> lack of experience if you will
09:26:22 <chpatrick> does anyone know if there's some clever way to flip an applicative around?
09:26:39 <chpatrick> by which I mean: f <$> a <* >b      to (a </> b) f
09:26:55 <chpatrick> where </> is some operator
09:27:10 <chpatrick> I have a feeling you can do it with CPS but I can't wrap my head around it
09:27:16 <kala> ski: nope, I do not understand this sorry
09:27:19 <ski> funfunctor : perhaps you don't want to have to think about how `BladeRFReturnTy' is defined (or you don't want clients/users to depend on it). e.g. perhaps later you'd like to be able to change the definition of it, without having to change that many places in the code (specifically, without having to change more code than that which is in the same module as the definition of `BladeRFReturnTy') -- then a `newtype' (or `data') could be reasonable
09:27:38 <EvanR_> :t (<**>) 
09:27:39 <ski> (cut off near ".. in the same module as the definition of `BladeRFReturnTy') -- then a `newtype' (or `data') could be reasonable")
09:27:39 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
09:27:45 <EvanR_> :t (<&>) 
09:27:46 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:28:37 <ski> funfunctor : but perhaps you just intend this as a "thin shorthand", and expect users to be able to make use of the knowledge than an `BladeRFReturnTy a' is just a `Either BladeRFError a' -- and then you'd go with `type'
09:29:00 <funfunctor> ski: ok that makes more sense, many thanks!
09:29:21 <funfunctor> yes since its exposed as part of the API then I guess type is what I should indeed be using
09:29:49 <ski> kala : so, perhaps look at an intermediate step
09:29:53 <ski>   sum [    ] = 0
09:30:02 <ski>   sum (x:xs) = x + lastSum
09:30:05 <ski>     where
09:30:10 <ski>     lastSum = sum xs
09:30:25 <ski> compare this with the previous
09:30:27 <ski>   partialSums [    ] = [0]
09:30:35 <ski>   partialSums (x:xs) = x + lastSum : allSums
09:30:37 <ski>     where
09:30:42 <ski>     allSums@(lastSum:_) = partialSums xs
09:31:16 <ski> so, i changed the base case to return a list (containing the single result), instead of just returning its result
09:31:42 <kala> ok, :)
09:31:56 <ski> and i changed the recursive case to extract the `lastSum' from the front of the list of all the recursive results (also naming the whole recursive result list `allSums')
09:32:08 <chpatrick> EvanR: but then the arguments are still reversed right?
09:32:36 <ski> and then i tacked on the new result `x + lastSum' in front of that list `allSums' (whose first element is `lastSum'). instead of returning *only* `x + lastSum'
09:33:15 <ski> kala : so i adapted the recursion from returning the "current result" to returning "a list of the current result, and also all intermediate recursive results"
09:33:41 <ski> kala : hopefully you should now get an idea of how to achive something like that with your `avg'
09:33:42 <chpatrick> EvanR: what I would really like is (fa1 / fa2 / fa3) $ \a1 a2 a3 -> ...
09:33:45 <Lutin`> Something to work towards :)
09:33:52 <Lutin`> @let ewma a (x:xs) = scanl (\s y -> a*y + (1-a)*s) x xs
09:33:54 <lambdabot>  Defined.
09:34:15 <Lutin`> > ewma 0.5 [20.0,27.0,25.0,22.0]
09:34:17 <lambdabot>  [20.0,23.5,24.25,23.125]
09:34:21 <EvanR_> chpatrick: i dont really understand
09:34:26 <kala> Yes I do ski :D thank a ton
09:34:28 <kala> :)
09:34:32 <kala> thnaks
09:34:45 <ski> kala : note that, with the above approach, you'd get a list `[f4,f3,f2,f1]' as output (most recent result in front of the list) .. if you don't like this, then either do a final reverse, or (more tedious) add to the end and extract most recent from the end, instead
09:34:49 <EvanR_> chpatrick: whats the type of the operation you want
09:35:00 <Kujanator> ski: What is supposed to go in front on the if, just 'a'? I can't see what else there is to put infront of it..
09:35:20 <ski> kala : but anyway, if the table you pasted is anything to trust, the code in your original `avg' is already wrong, for two reasons
09:36:04 <chpatrick> EvanR: what I want is to produce (
09:36:12 <chpatrick> \f -> f <$> arg1 <*> arg)
09:36:15 <chpatrick> but without using a lambda
09:36:38 <EvanR_> @pl \f -> f <$> arg1 <*> arg
09:36:38 <lambdabot> (<$> arg1 <*> arg)
09:36:53 <EvanR_> for some reason i didnt think it would be that obvious
09:37:06 <ski> Kujanator : .. nothing ?
09:37:19 <chpatrick> ha, nice one
09:37:26 <ski> Kujanator : why would you put anything in front of it ?
09:38:04 <ski> @type (<$> ?arg0 <*> ?arg1)
09:38:05 <lambdabot>     The operator ‚Äò<$>‚Äô [infixl 4] of a section
09:38:05 <lambdabot>         must have lower precedence than that of the operand,
09:38:05 <lambdabot>           namely ‚Äò<*>‚Äô [infixl 4]
09:38:17 * ski thinks this is silly
09:38:36 <Kujanator> ski: So it's just 'in if a'? Was reluctant to do that since it just didn't seem to make sense in English, though that is a stupid reason.
09:38:42 <ski> (obviously that ought to expand to `\x -> (x <$> ?arg0) <*> ?arg1')
09:39:17 <ski> Kujanator : yes, after `in' you write the expression you want to compute after performing the bindings in between the `let' and the `in'
09:40:31 <ski> Kujanator : .. you could also use `where' in your case, but then you'd have the `(a,s1) = evalA a s0' part after the `if'-expression .. which you may or may not find an unnatural reading/writing order (Haskell doesn't care)
09:43:46 <Kujanator> ski: It's not compiling as there's a parse error on on "else", which from what I've just googled seems to be down to the structure but I can't see what's wrong with mine 
09:43:48 <Kujanator> evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in if a else let (s2, b) = evalA b s0 in if b
09:44:36 <geekosaur> Kujanator, weren't you already rold that "if a else" is not legal? and what is "in if b"? if then.. .what?
09:44:50 <geekosaur> I have no idea what you think "if" is...
09:45:05 <geekosaur> or why you would think "if a else" makes any sense
09:45:23 <chpatrick> EvanR: does that actually make any sense though? the f goes to deepest position inside the brackets
09:45:36 <chpatrick> I thought sections partially applied the outermost operator
09:45:50 <Zemyla> Hmm, does circular programming work with stream transformers? Because it does work with build/foldr.
09:45:57 <EvanR_> chpatrick: i didnt know you could write it like that, or even if you can despite @pl
09:45:57 <chpatrick> @pl \f -> f <$> arg1 <*> arg2 <*> arg3
09:45:58 <lambdabot> (<$> arg1 <*> arg2 <*> arg3)
09:46:03 <ski> Kujanator : as geekosaur is saying, you're still missing a `then ...' branch for your `if'
09:46:06 <chpatrick> I think it's incorrect
09:46:17 <chpatrick> pl just doesn't do operators
09:46:56 <EvanR_> chpatrick: if you want it to work for arbitrary number of <*>'s, then what is the type?
09:47:00 <chpatrick> @pl \f -> ap (ap (fmap f arg1) arg2) arg3
09:47:01 <lambdabot> (`ap` arg3) . (`ap` arg2) . flip fmap arg1
09:47:20 <chpatrick> hey that's progress
09:47:25 <chpatrick> I can flip that around with CPS right?
09:47:39 <ski> Kujanator : if you're confused what to change, you might try : putting everything after the first `in' there in a comment on another line, and then write what you want after the `in' from scratch
09:48:08 <ski> chpatrick : "I thought sections partially applied the outermost operator" -- they do. i think it's a silly restriction
09:51:48 <Kujanator> ski: Ah, I see what you're saying. What does this look like:
09:51:49 <Kujanator> evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in if a then (s1, a)                   else let (s2, b) = evalA b s0 in if b then (s1, b)
09:54:08 <Zemyla> Why is if' not in Prelude?
09:54:17 <geekosaur> you need an else to go with that final if
09:54:24 <EvanR_> :t if'
09:54:25 <lambdabot>     Not in scope: ‚Äòif'‚Äô
09:54:25 <lambdabot>     Perhaps you meant ‚Äòf'‚Äô (imported from Debug.SimpleReflect)
09:54:32 <geekosaur> what should the value be if b is false?
09:54:34 <EvanR_> :t bool
09:54:35 <lambdabot> a -> a -> Bool -> a
09:56:39 <quchen> Is the term "profunctor" an artificial word, or does it have any roots in math?
09:57:02 <Zemyla> @let if' b t f = if b then t else f
09:57:03 <lambdabot>  Defined.
09:57:28 <quchen> Oh, Wikipedia started loading. Nevermind. (Slow servers today, eh?)
09:57:38 <jtanguy> Zemyla: because if-then-else is a language construct, not defined in a library
09:57:59 <levi> quchen: I follow your meaning, but your usage of 'artificial word' there makes me chuckle. I dunno the answer, though.
09:58:08 <EvanR_> > bool 1 0 False
09:58:10 <lambdabot>  1
09:58:13 <ab9rf> are there natural words?
09:58:15 <EvanR_> Zemyla: this version is easier to partial
09:59:11 <Zemyla> jtanguy, EvanR_: Actually, if' b = if b then const else flip const could work better.
09:59:32 <EvanR_> eh why
10:00:07 <levi> I assume in this context 'artificial word' means 'made up by Haskell programmers' rather than 'made up by and in somewhat general use by some faction of mathematicians'.
10:00:33 <ab9rf> because when mathematicians make something up, that's perfectly natural :)
10:00:34 <EvanR_> artificial = made by man, i.e. nothing as far as we know
10:01:30 <EvanR_> god made the integers, so i guess that would make them supernaturals
10:01:36 <Kujanator> geekosaur: The value should be false if b is false. This might be a really stupid question but how do I return a state and a false boolean?
10:01:59 <ab9rf> EvanR_: god made the natural numbers, not the integers :)
10:02:07 <EvanR_> gah
10:02:16 <monochrom> God made the supernatural numbers. There.
10:02:28 <Kujanator> geekousar: Like I understand that it should be false, but not what to return.
10:02:37 <ab9rf> monochrom: which ones?  there are several different things that are known as "supernatural numbers"
10:03:09 <levi> quchen: This might help answer your question? http://ncatlab.org/nlab/show/profunctor
10:03:13 <geekosaur> Kujanator, so you were expecting "if b then (s1,b)" to be the same as "if b then (s1,b) else b"? that does not typecheck
10:03:16 <silver> as well as number of gods
10:03:18 <juanpablo_> Should I use EitherT or ErrorT?
10:03:19 <Zemyla> EvanR_: Because it shows better that True truly is const and False truly is const id.
10:03:34 <ab9rf> you can't have something that returns a variable type
10:03:57 <EvanR_> Zemyla: truly?
10:04:11 <monochrom> it was a joke, ab9rf
10:04:14 <quchen> levi: I just had connectivity problems, now I've found multiple sources. But thanks!
10:04:46 <levi> nLab is my go-to source for determining if some word has connection to category theory, even though I can't understand most of what I read there.
10:05:46 <ab9rf> i jkust assume that every word i encounter is connected in some way to category theory
10:05:53 <ab9rf> so far this assumption has not done me wrong
10:06:22 <quchen> levi: Sounds pretty good actually.
10:06:36 <Kujanator> geekosaur, sorry I don't understand what you're saying. Is there stuff wrong with evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in if a then (s0, a)                        else let (s2, b) = evalA b s0 in if b then (s0, b) else                    besides the fact I haven't finished the final else statement?
10:07:54 <geekosaur> well, you need to finish it somehow. your original one ended with "... in if b then (s0, b)". and I ddi not understand your followon question
10:08:36 <levi> ab9rf: Actually, there are a bunch of terms in common use in Haskell that *sound* category-theoryish but aren't.  Like the fancy recursion scheme names, e.g. catamorphism, anamorphisms, zygohistomorphic prepromorphisms.
10:09:02 <ab9rf> "zygohistomorphic" sounds anatomical
10:09:53 <Zemyla> EvanR_: Truly
10:10:07 <Zemyla> There is an isomorphism between them.
10:10:12 * hackagebot hlibBladeRF 0.1.0.5 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.5 (eocallaghan)
10:10:38 <EvanR_> there is an isomorphism doesnt mean one of the things is the true form, thats the point of the isomorphism to reveal that either is good enough
10:12:26 <Zemyla> Well, in the pure lambda calculus, const and const id are the true forms of the booleans.
10:12:32 <EvanR_> i.e. why would Either () () not be the true form
10:12:51 <EvanR_> true form != implementation detail
10:13:22 <Kujanator> geekosaur: Problem is i'm not sure how to finish it. Am I correct in saying it will only get to the final else statement if a and b are both false. In which case I need to return false? But I don't know how to do that.
10:13:46 <geekosaur> you need to return something that looks like (s,False)
10:13:49 <juanpablo_> Is first and second from Data.Bifunctor the same as first and second from Control.Arrow?
10:14:06 <quchen> juanpablo_: No, they're different things.
10:14:15 <geekosaur> because the others are going to be (s,True)
10:15:12 <juanpablo_> Can we define bimap in terms of second and firt from Control.Arrow?
10:15:12 * hackagebot propellor 2.2.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.2.0 (JoeyHess)
10:15:16 <Kujanator> geekosaur, Can I return (s, b) since if it gets to the else bit then it means b will have to have been false so (s,b) is false?
10:16:05 <geekosaur> sure
10:16:19 <geekosaur> what you can't do is leave off the state part
10:16:40 <geekosaur> in that case, though, you have `if b then (s,b) else (s,b)` which is the same as just `(s,b)`
10:16:49 <quchen> juanpablo_: No. The "first"s coincide for the (->) arrow and the (,) Bifunctor, but that's about it.
10:17:29 <quchen> juanpablo_: Arrow abstracts over function application, Bifunctor abstracts over the data constructor operated on.
10:17:33 <juanpablo_> quchen: sucks. I wished it was more than a coicindence and I didn't need to bring data.bifunctor into my dependencies
10:18:36 <phadej> osa1: to answer you question. You can install dependencies by hand (cabal install; cabal install QuickCheck-2.7.6 template-haskell-2.9.0.0; cabal configure --enable-tests) for pretty 1.1.2.1
10:18:55 <phadej> seems that osa1 is not here anymore, but if they come back, some one could pass the info
10:19:19 <NemesisD> hey folks. i need a constructor with a constraint on it. the way i see it i can use existential quantification and do data A = forall a. (Constraint a) => A a, or GADTs: data A where A :: (Constraint a) => a -> A, is there any advantages/disadvantages for one over the other?
10:19:25 <quchen> juanpablo_: Yes, the dependency footprint of those libraries is usually quite large, and not worth it if you don't get serious mileage out of them.
10:19:50 <NemesisD> and second question, am i correct that there's no way to be able to use a newtype here without exposing a type parameter?
10:20:04 <Kujanator> geekosaur, I've changed it to (s, False)
10:20:53 <geekosaur> that doesn't answer my point...
10:21:03 <geekosaur> since b is known to be False at that point, there's no difference.
10:21:25 <geekosaur> my point is, what is the point of testing b if you're returning what amounts to (s,b) in both cases?
10:21:30 <geekosaur> and doing nothing else?
10:23:00 <Kujanator> geekosaur, I suppose there isn't
10:25:46 <ski> Kujanator : sorry, had to leave for a while, back now. yes, `evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in if a then (s1, a) else let (s2, b) = evalA b s0 in if b then (s1, b)' is on the right track (not quite there yet)
10:27:48 <ski> NemesisD : no technical advantage (a cosmetic one is that you can leave out the `forall a.' part in the GADT syntax, as you did)
10:27:50 <Kujanator> ski: no problem :). Does adding else on to the end make it correct, so, evalB (a :||: b) s0 = let (s1, a) = evalA a s0 in if a then (s1, a)                        else let (s2, b) = evalA b s0 in if b then (s2, b) else (s2, False)
10:28:08 <NemesisD> ski: gotcha. thanks!
10:28:28 <ski> NemesisD : i don't see where you thought to use a `newtype'. neither an "existential datatype" or a GADT can be a `newtype' (perhaps sadly)
10:29:04 <NemesisD> ski: just instinctual since its only wrapping one value, but i could imagine why that's disallowed
10:29:52 <chpatrick> EvanR, ski: I got it to work: http://lpaste.net/2004930277536694272
10:29:58 <chpatrick> but I have no idea what it means :D
10:30:06 <chpatrick> I'm sure it's already in some ekmett library
10:30:39 <NemesisD> turns out though that in this case i need to use existentials w/ a smart constructor
10:30:46 <ski> NemesisD : oh, i just realized another problem. you're using the same name, `a', for both the expression to evaluate, and its resulting (here boolean) value. `(s1, a) = evalA a s0' will (as with `s' for `(s, a) = evalA a s' above) be interpreted recursively, feeding back in the same `a' as you get out (and in addition, this is a type error in this case)
10:31:49 <ski> NemesisD : in the other cases you had `na' and `nb' for the values of the (sub)expressions `a' and `b' -- perhaps adopt the same name convention here, for consistency ?
10:32:11 <NemesisD> ski: i think you mean these for Kujanator 
10:32:20 <ski> er, you're right
10:32:22 <ski> Kujanator ^
10:33:52 <ski> NemesisD : imho, if there was no constraint, i think an "existential `newtype'" would make sense. but they conservatively decided to disallow it for `newtype' altogether (possibly later allowing it, if desired)
10:34:07 <Zemyla> Hmm. Is there a built-in interface to the bytecode compiler used in GHCi?
10:34:56 <ski> NemesisD : there's also an idea that would looks a bit like a "GADT" `newtype' which i think would make sense, that i've been pondering
10:36:04 <ski> @hackage applicative-quoters
10:36:04 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
10:36:27 <ski> chpatrick : perhaps `ado' ^ might also be interesting
10:36:57 <chpatrick> ski: it's not so much a syntactic thing really
10:37:19 <cfoch> hello folks
10:37:41 <Kujanator> ski: Fixed that hopefully. evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if a then (s1, na)                        else let (s2, nb) = evalA b s0 in if b then (s0, nb) else (s2, False)
10:38:19 <cfoch> how do I know what version of Cabal I've built cabal-install with ?
10:38:21 <ski> Kujanator : you're still checking `a' rather than `na' in the `if' condition
10:38:50 <Kujanator> ski: Ah of course, fixed it.
10:38:51 <ski> Kujanator : another problem is that you've managed to use the wrong state version in some places
10:40:05 <ski> (btw, mixing up various "state versions" is exactly one good reason why the state monad was invented .. iow to avoid making that mistake more than once)
10:40:21 <supki> cfoch: cabal --version
10:40:32 <Kujanator> ski: I was afraid of that. I've tried to fix it, but not completely sure. evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na)                        else let (s2, nb) = evalA b s0 in if nb then (s2, nb) else (s2, False)
10:41:35 <ski> Kujanator : in a typical imperative language, after the programmer has changed the value of some mutable variable to some new value, they typically expect that variable to keep containing that value (not changing to anything else), until further notice
10:42:15 <ski> Kujanator : in particular, they usually wouldn't expect the variable to automagically revert back to an earlier version (an earlier value that was previously stored in the mutable variable, before it was changed)
10:42:22 <BurningCa007> cabal update keeps telling me there's a new version of cabal to get yet running cabal install cabal-install states it fails to install cabal-install-1.22.0.1 during the configure step ExitFailure 1
10:42:56 <ski> Kujanator : because you're using the wrong state, your code will have the effect of reverting back to earlier values of variables in your state
10:43:43 <cfoch> supki: and how do I know what version of Cabal my package database contains?
10:43:49 <ski> Kujanator : at each point you should continue with the "current state" that you conceptually have reached so far
10:44:13 <ski> Kujanator : .. can you see which parts need to be changed ?
10:44:50 <Kujanator> ski: Is it stuff after the else let?
10:44:57 <supki> cfoch: ghc-pkg list Cabal  or  cabal exec -- ghc-pkg list Cabal  if you're in a sandbox
10:45:14 * hackagebot contravariant 1.3 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.3 (EdwardKmett)
10:46:15 <ski> Kujanator : after the first `in', you have "evaluated `a'", and thus gone from state `s0' to `s1', so `s1' is now the current state
10:46:53 <ski> Kujanator : this is why you should return `s1' (and not the old `s0') in case `na' was `True' (iow, in the `then (s1,na)' branch)
10:48:01 <Kujanator> ski: Isn't that already returning s1?
10:48:29 <cfoch> supki: why the versions doesn't match ?
10:48:29 <cfoch> http://fpaste.org/195896/92308414/
10:49:17 <supki> cfoch: they don't need to
10:49:26 <ski> Kujanator : yes it is
10:49:30 <cfoch> If I do cabal install  it will write a setup-config file using Cabal 1.18.1.5 or 1.23.0.0 in this case ?
10:49:49 <ski> Kujanator : .. so which other mentions of states are right, and which aren't ?
10:50:19 <Kujanator> ski: should evalA b s0 actually be evalA b s1?
10:50:46 <cfoch> supki: ^
10:51:10 <ski> Kujanator : yes, because at this point, you've already conceptually evaluated `a' (progressing from state `s0' to `s1')
10:51:35 <Raptortin> the more I learn about haskell, the more white papers I find myself reading o.O
10:51:37 <Kujanator> ski: Is that the only one? I can't see any others.
10:51:38 <ski> Kujanator : remember that you want to (conceptually) evaluate `a' and `b' in order, with `a' before `b' (though in some cases not evaluate `b' at all)
10:52:06 <ski> Kujanator : this means that (in case `b' is to be evaluated) the input state of the evaluation of `b' should be the output state of the evaluation of `a'
10:52:41 <kaidelong> are you sure they are technically white papers?
10:52:46 <supki> cfoch: it should use the version it was compiled against, that is 1.23.0.0 in your case
10:52:52 <Kujanator> ski: So change all s2 to s1?
10:52:54 <kaidelong> what is a white paper anyway, a draft for a journal publication?
10:53:03 <ski> Kujanator : nono, not at all
10:53:15 <ski> Kujanator : looking at your most recent version that you showed above, i think that's all places to fix states
10:53:27 <ski> (in an earlier version of your code, you had more places)
10:53:31 <Kujanator> ski: Oh ok, I thought so. Thank you. 
10:53:53 <ski> Kujanator : now, we still should simplify the code a little bit. could you please show me the most recent version ?
10:54:05 <supki> BurningCa007: any other errors in the log?
10:54:06 <Kujanator> ski: evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na)                        else let (s2, nb) = evalA b s1 in if nb then (s2, nb) else (s2, False)
10:54:56 <ski> Kujanator : ok. now look at `if nb then (s2, nb) else (s2, False)' there. in both cases it will return a pair with `s2' as the first component
10:55:21 <ski> Kujanator : this suggests we could replace this snippet with `(s2, if nb then nb else False)' -- do you see that ?
10:56:18 <Kujanator> ski: Yes that makes sense
10:56:51 <ski> Kujanator : now, look at `if nb then nb else False' .. the `then' branch is selected in case `nb' is `True', and the `else' branch in case `nb' is `False'
10:57:25 <ski> Kujanator : this means that the `nb' in the `then' branch must in that case be `True'. iow `if nb then nb else False' is the same as `if nb then True else False' -- agree ?
10:57:47 <Kujanator> ski: yeah
10:57:53 <ski> Kujanator : can you see how to simplify this ?
10:58:24 <Kujanator> ski: so simplify (s2, if nb then nb else False) ?
10:59:37 <ski> Kujanator : atm i'm asking if you can see how `if nb then True else False' (which you agreed is the same as `if nb then nb else False') could further be simplified
10:59:49 <BurningCa007> files missing in the cabal-1.22.0.1 package
10:59:52 <BurningCa007> new error
11:00:31 <Kujanator> ski: can you get rid of the 'then true'? Not sure how to do it in Haskell syntax, but like 'nb else false'?
11:00:40 <monochrom> if nb is true, then nb equals true. if nb is false, then nb equals false. (greatest tautology ever)
11:01:11 <monochrom> when nb equals false, you can replace "false" by nb.
11:01:16 <ski> Kujanator : every `if' in Haskell must have a `then' and an `else' branch
11:01:24 <monochrom> "if nb then nb else nb"
11:01:53 <ski> monochrom : i was going in the other direction, to iterate on recognizing this anti-pattern :)
11:02:15 <Kujanator> ski: What monochrome said then ? Makes sense to me.
11:02:23 <monochrom> I am trying to give a spoiler without spoiler
11:02:34 <monochrom> clearly, "if nb then nb else nb" cannot be the final answer
11:02:39 <ski> Kujanator : `if nb then True else False' says : if `nb' is `True', the result is `True'. if `nb' is `False', the result is `False'
11:02:43 <geekosaur> yes, I'm trying to figure out how to hint at the point myself.
11:02:56 <ski> Kujanator : so, in either case, the result has the same value as `nb' itself
11:03:04 <Kujanator> so just nb?
11:03:09 <ski> Kujanator : therefore `if nb then True else False' is the same as simply `nb'
11:03:12 <ski> Kujanator : yes :)
11:04:00 <ski> Kujanator : now, another way to do this (which is what monochrom did) is to start at `if nb then nb else False' and reason : in the `else' branch, we know that `nb' must be `False' (otherwise we wouldn't be in the `else' branch)
11:04:55 <ski> Kujanator : therefore, `if nb then nb else False' must be the same as `if nb then nb else nb' -- and here, as monochrom said, we clearly see that we give `nb' as answer in both branches, regardless of the value of the condition `nb' -- iow, we also get just `nb' in this way
11:05:09 <Kujanator> ski: so this is what it looks like now, right?  evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na)                        else let (s2, nb) = evalA b s1 in (s2, nb)
11:05:17 <ski> Kujanator : now, if i said `if nb then False else True', how would you restate that in a simpler way ?
11:05:33 <chpatrick> type Wat f r a = forall c. (f r -> c) -> (f a -> c)
11:05:37 <chpatrick> does this ring a bell for anyone?
11:06:36 <Kujanator> ski: true else nb?
11:06:53 <Kujanator> ski: no scrap that
11:06:58 <ski> chpatrick : hm, that's basically the same as `f a -> forall c. (f r -> c) -> c', which is basically the same as `f a -> f r'
11:07:42 <Kujanator> ski: I'm not sure how to make that simpler
11:08:04 <mauke> 'if X then Y else Z' ==> 'if not X then Z else Y'
11:16:36 <lpaste> ‚Äú__Guest‚Äù pasted ‚ÄúsafeHead attempt‚Äù at http://lpaste.net/124305
11:17:06 <__Guest> ^ could someone help me use safeHead through extistential types, or is that not possible
11:17:26 <_deepfire> does [([a], [b])] -> ([a], [b]) have a name?
11:17:38 <_deepfire> am I crazy for wanting it?
11:17:47 <kadoban> _deepfire: 'head' ?
11:18:17 <_deepfire> kadoban, no, I mean a concatenation, not the first element
11:18:42 <mauke> :t unzip
11:18:43 <lambdabot> [(a, b)] -> ([a], [b])
11:19:11 <mauke> :t (concat *** concat) . unzip
11:19:12 <kadoban> _deepfire: I think mconcat can do that, there should be a Monoid instance for that
11:19:12 <lambdabot> [([a], [a1])] -> ([a], [a1])
11:19:43 <_deepfire> *** is from Control.Arrow?
11:19:46 <arkeet> yes
11:20:26 <ski> __Guest : you disappeared to quickly earlier, before i could respond properly
11:20:40 <HeladoDeBrownie> __Guest, unfortunately, by making it into an AnyList, you've thrown away the information you needed to ensure it was safe. the function provided to withAnyList has to work regardless of whether it's non-empty
11:20:49 <_deepfire> (concat *** concat) . unzip  did it!
11:20:56 <_deepfire> mauke, thanks!
11:20:57 <kadoban> :t mconcat `asAppliedTo` [([5], "hi")] -- _deepfire
11:20:58 <lambdabot> Num t => [([t], [Char])] -> ([t], [Char])
11:21:03 <__Guest> ski: sorry
11:21:42 <mauke> :t [(concat *** concat) . unzip, mconcat]
11:21:43 <lambdabot> [[([a], [a1])] -> ([a], [a1])]
11:21:49 <__Guest> HeladoDeBrownie: i see. i have trouble seeing the use of GADTs then when it comes to user input?
11:22:00 <kadoban> > mconcat [([5], "foo"), ([10], "bar")]
11:22:02 <lambdabot>  ([5,10],"foobar")
11:22:06 <kadoban> Oh, he left. Oh well.
11:23:12 <HeladoDeBrownie> __Guest, what is it you were hoping to do?
11:24:08 <ski> __Guest : there, you were talking about a hypothetical `run :: (forall a. String -> Maybe (AKind a)) -> (AKind a -> r) -> String -> Maybe r', that you seemed to want to feed with some parsing operation `parse :: forall a. String -> Maybe (AKind a)'
11:25:01 <ski> <__Guest> given "data A = B | C" and "data AKind :: A -> * where BType :: AKind B" and "CType :: AKind C" and "run :: (forall a. (String -> Maybe (AKind a))) -> (AKind a -> r) -> String -> Maybe r" how can i get a polymorphic "(String -> Maybe (AKind a)" ?
11:25:08 <ski> HeladoDeBrownie : ^, also see <http://sprunge.us/IPUS>
11:25:18 <__Guest> ski: yes, that was one of the ways i thought of doing it when messing with types
11:25:37 <__Guest> HeladoDeBrownie: just fool around with GADTs and learn them, perhaps write programs with compile-time checking
11:26:12 <ski> __Guest : i tried to suggest that you probably didn't want the `forall' in the type of your parsing operation there, since it would mean that the *caller* of the parser would get to decide whether to use `B' or `C' for the `a' type variable (tyvar for short)
11:26:47 <ski> __Guest : while you probably wanted to let the parser itself decide whether to use `B' or `C', depending on the actual string passed
11:26:53 <Kujanator> ski: What am I supposed to be doing now? :)
11:27:52 <_deepfire> it's a bit sad (concat *** concat) . unzip doesn't generalize..
11:28:04 <__Guest> ski: yes, which is why i figured that the parser could figure out what to call functions with, ie if it knew a list was nonempty from parsing it could construct a nonempty list and call the safehead function
11:28:06 <ski> __Guest : this would correspond basically to `parse :: String -> Maybe (exists a. AKind a)' (but e.g. GHC doesn't allow an `exists' syntax, so we'd have to *encode* it in some way. in any way, this is what we *intend* to express, in this case)
11:28:13 <_deepfire> it'd be nice if (concat *** concat *** concat) . unzip3 worked as well : -)
11:28:19 <ski> Kujanator : mauke gave a hint
11:28:31 <Kujanator> ski: oh sorry, must have missed it. i'll find it now.
11:28:48 <ski> Kujanator : you're supposed to make some kind of reply. perhaps a suggestion, or a statement that you don't know, or something
11:29:20 <__Guest> ski: i've seen the 'exists' syntax and it was explicitly listed on the wiki page for GADTs but GHC doesn't support it so i didn't really have much to go on considering i'm a newbie. if there were an `exists' term could it be used to call safeHead?
11:29:57 <ski> __Guest : let's wait a bit with commenting on your later <http://lpaste.net/124305>, ok ?
11:29:59 <jtanguy> _deepfire: kadoban had a solution for that
11:30:09 <mauke> _deepfire: did you see the mconcat solution?
11:30:13 <jtanguy> > mconcat [([5], "foo"), ([10], "bar")]
11:30:14 <lambdabot>  ([5,10],"foobar")
11:30:29 <jtanguy> let's hope he saw this one
11:30:55 <__Guest> ski: sure thing
11:30:56 <Kujanator> ski: So is it "if not nb then true else false"
11:31:22 <JustAPerson> In Haskell, how would you construct a large application with many interconnected parts? I'm trying to write an irc client in another language, and I'm running into the problem of needing to access  the same data from all over the program.
11:31:39 <ski> Kujanator : .. and what does that in turn simplify to ?
11:31:55 <__Guest> JustAPerson: try picturing your program as a flowchart
11:32:36 <EvanR_> JustAPerson: im currently working on something like this. im thinking like theres a database which everything has access to
11:33:11 <EvanR_> JustAPerson: thats just one aspect of your question though
11:33:15 <ski> __Guest : so .. there's two main ways to encode existentials in current Haskell. one is to use "existential datatypes" (possibly using the GADT (Generalized Algebraic Data Type) syntax). the other is using rank-2 types
11:33:20 <_deepfire> a question:  is the two-tuple-ness a fundamental limitation of arrows?
11:33:40 <_deepfire> FSVO fundamental..
11:34:05 <__Guest> ski: ah
11:34:09 <ski> _deepfire : it's not really related to arrows
11:34:20 <kadoban> > mconcat [([5], "foo"), ([10], "bar")] -- _deepfire: in case you missed this
11:34:21 <lambdabot>  ([5,10],"foobar")
11:34:25 <_deepfire> sure, sure
11:34:38 <_deepfire> I just want to better understand the inherent properties of ***
11:34:57 <_deepfire> thank you, mconcat is wonderful, indeed : -)
11:35:15 <ski> __Guest : so, let's say we accept `parse :: String -> Maybe (exists a. AKind a)' for the moment
11:35:26 <kadoban> Okay, just making sure, sorry :) As far as my limited understanding of Arrows goes, yes it's inherent in them.
11:36:44 <Kujanator> ski: I don't get it. Surely, "if not nb then true else false" is the same as "nb then false else false"?
11:37:00 <ski> __Guest : the "existential datatypes" (which imho is somewhat of a misnomer) approach goes like this : we make a new data type (it has to be `data', can't be `newtype' (nor `type', obviously, since that just introduces shorthands, and we didn't have any `exists' to begin with)), call it `SomeAKing', that will represent the `exists a. AKind a' part (the existentially quantified part of the type)
11:37:10 <monochrom> "if x then True else False" = x
11:37:23 <mauke> Kujanator: no, that returns False always
11:37:24 <ski> Kujanator : hint : we already determined that `if nb then True else False' is equal to `nb'
11:37:35 <indiagreen> a small survey
11:37:51 <indiagreen> do you use lazy or strict Text by default?
11:38:11 <mauke> "no"
11:38:18 <ski> __Guest : following, so far ?
11:38:23 <monochrom> I don't have a default.
11:38:31 <HeladoDeBrownie> i'm too lazy to figure out whether i use lazy or strict Text. (i use whatever Data.Text exports.)
11:38:39 <indiagreen> Data.Text is strict
11:38:41 <monochrom> :)
11:38:46 <mauke> I've never used Text
11:38:50 <ChristianS> indiagreen: mostly strict, but lazy for reading/writing bigger files
11:39:02 <monochrom> I am too strict to have a default.
11:39:03 <__Guest> ski: for the most part
11:39:09 <HeladoDeBrownie> monochrom, well done
11:39:26 <HeladoDeBrownie> (on following up on the pun)
11:39:29 <Kujanator> ski: so if, 'if nb then True else False' is equal to nb then 'if not nb then true else false' then the only difference is the not. so not nb?
11:39:30 <monochrom> :)
11:39:40 <Lutin`> HeladoDeBrownie: But wouldn't him asking force the thunk? ;)
11:39:58 <HeladoDeBrownie> Lutin`, who?
11:40:17 <Lutin`> them
11:40:18 <Lutin`> indiagreen: 
11:40:27 <ski> __Guest : so, after doing this, we will then end up with `parse :: String -> Maybe SomeAKind' -- the drawback here is that we will explicitly need to wrap into and unwrap out of the `SomeAKind' data type, when we want to access the (conceptual) `exists a. AKind a' contents
11:40:55 <HeladoDeBrownie> ah. nah, there's another constructor around it in the result :P
11:40:57 <edwardk> > magnify (to succ) (+1) 2
11:40:59 <lambdabot>  4
11:40:59 * Lutin` sighs.
11:41:01 <edwardk> wrong channel
11:41:15 <Lutin`> on an unrelated not someone messed up the school firewall it seems!
11:41:23 <Lutin`> Can't access the VPN so now I have to go to campus
11:41:27 <__Guest> ski: i see
11:41:30 <ski> __Guest : anyway, we will need a data constructor for this data type, to hold the value we want. (it would be more proper to call this data *constructor* "existential", rather than the whole data type. one could have a data type with some constuctors "existential", and others not)
11:42:59 <ski> __Guest : let's call the data constructor `WrapAKind'. so, we want to express something like `WrapAKind :: (exists a. AKind a) -> SomeAKind', because we want to be able to give it an `exists a. AKind a', getting back a wrapped `SomeAKind', that hides/forgets which actual value for `a' (`B' or `C') was actually used in the type of the argument
11:43:24 <ski> Kujanator : right (sorry i missed your reply at first)
11:44:24 <ski> Kujanator : so, the reason i was insisting on this is that you really should learn to recognize when you write `if ... then True else False' or `if ... then False else True', and immediately simplify those to `...', respectively `not (...)'
11:45:01 <ski> Kujanator : the latter two are much more readable than manually checking all the parts of the `if' and attempting to grasp the whole effect
11:45:14 <Kujanator> ski, so (s2, if nb then nb else False) becomes, (s2, not nb)
11:45:18 <__Guest> ski: i'm following
11:45:22 <mauke> any time you have 'if X then Y else Z' and Y or Z is True or False, you can rewrite without using if/True/False
11:45:35 <BurningCa007> quick question, what is the | operator for in haskell?
11:45:40 <BurningCa007> example: [x|x<-[1,2,3]]
11:45:43 <mauke> BurningCa007: | is not an operator
11:45:44 <ski> Kujanator : and something similar goes for `(...) == True' and `(...) == False' -- these should also always be simplified (to what ?)
11:45:48 <mauke> BurningCa007: that's a list comprehension
11:45:57 <ski> Kujanator : no. i'm sorry but you're confusing stuff again
11:46:00 <kadoban> BurningCa007: That's just syntax, not an operator.
11:46:03 <mynm> @pl \x -> x
11:46:03 <lambdabot> id
11:46:15 <mynm> @pl \xy -> g (k x y)
11:46:15 <lambdabot> const (g (k x y))
11:46:37 <mynm> \x y -> g (k x y)
11:46:42 <mauke> BurningCa007: sure, guards for example
11:46:44 <Lutin`> Anyone know of an APL irc channel?
11:46:44 <mynm> @pl \x y -> g (k x y)
11:46:44 <lambdabot> (g .) . k
11:46:49 <mauke> and functional dependencies
11:46:52 <BurningCa007> mauke: ok ty
11:46:57 <mauke> BurningCa007: and alternatives in a data declaration
11:47:04 <ski> Kujanator : `if nb then nb else False' is the same as `if nb then True else False' (since `nb' is `True' in the `then' branch) .. and is also the same as `if nb then nb else nb' (since `nb' is `False' in the `else' branch) -- and both of these can be simplified to just `nb'
11:47:20 <ski> Kujanator : therefore `(s2, if nb then nb else False)' becomes just `(s2, nb)'
11:48:19 <Kujanator> ski, I'm confused, it's been a long time. Is the "final answer" so to speak (s2,nb)?
11:48:35 <ski> BurningCa007 : `|' is syntax used in list comprehensions, and in guards. some operators also have `|' in their (symbolic) names. e.g. `||'
11:48:56 <ski> Kujanator : the most simplified version of `(s2, if nb then nb else False)' is `(s2,nb)', yes
11:48:59 <ski> Kujanator : but consider
11:49:01 <BurningCa007> ski: ty
11:49:22 <ski> Kujanator : you had `evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na) else let (s2, nb) = evalA b s1 in (s2, nb)'
11:49:35 <monochrom> | also appears in multiple parameter type class functional dependency
11:49:55 <ski> Kujanator : where this simplification was applied'
11:50:07 <ski> Kujanator : now consider the `let (s2, nb) = evalA b s1 in (s2, nb)' ending part of this
11:50:35 <ski> Kujanator : the value of this will be `(s2, nb)', after defining `(s2, nb)' to be equal to `evalA b s1' ..
11:50:51 <ski> Kujanator : can you see how one could simplify this whole `let (s2, nb) = evalA b s1 in (s2, nb)' expression further ?
11:51:09 <xnull_> is there a way to use two patterns in a case statement? sort of like `case x of 1 || 2 -> blah'
11:51:27 <ski> xnull_ : unfortunately Haskell doesn't have disjunctive patterns
11:51:33 <xnull_> aww.
11:51:40 <ski> in this case you could perhaps use `elem'
11:51:46 <xnull_> ski: i was previously using guards for my algorithm, but eh
11:51:48 <xnull_> ok.
11:51:50 <xnull_> :t elem
11:51:51 <lambdabot> Eq a => a -> [a] -> Bool
11:52:26 <ski> __Guest : ok
11:52:29 <xnull_> ski: ahem, the issue is that i have more matches
11:52:47 <Cale> xnull_: Yeah, every so often they're something which would be very nice to have. The trickier case is when your patterns actually bind variables
11:52:49 <ski> __Guest : so, continuing from the (conceptual, not actual Haskell) `WrapAKind :: (exists a. AKind a) -> SomeAKind'
11:52:50 <xnull_> case x of 1 || 2 -> blah; 3 -> blah
11:52:55 <Kujanator> ski: I see that we have (s2,nb) twice but not how to actually simplify it
11:53:08 <xnull_> Cale: so, would i be best off using guards here instead?
11:53:13 <Cale> yes
11:53:15 <xnull_> ok.
11:53:30 <ski> Cale : O'Caml, i believe they either require both to bind the same set of variables, or take the intersection
11:53:35 <Cale> yeah
11:54:28 <ski> Kujanator : well, conceptually what we do in `let (s2, nb) = evalA b s1 in (s2, nb)' is (a) compute `evalA b s1'; (b) name the result of that `(s2, nb)', and then return `(s2, nb)' as result of evaluating the whole `let'-expression
11:55:52 <ski> Kujanator : so .. since we don't *do* anything more with the result of (a) in (b), we just pass it on, unchanged, unrearranged, we could just *skip* the (b) step, returning the result of `(a)' *directly* (without naming the two components of the resulting pair, namely the final state and the second boolean)
11:56:06 <ski> Kujanator : so, we can simplify `let (s2, nb) = evalA b s1 in (s2, nb)' to just `evalA b s1'
11:56:14 <mauke> intermediate step: let s2_and_nb = evalA b s1 in s2_and_nb
11:56:22 <ski> yes
11:56:50 <__Guest> ski: i've read up some more and understand what you've said so far
11:56:52 <ski> Kujanator : makes sense ?
11:57:14 <Kujanator> ski: Ah yes
11:57:34 <cfoch> hello
11:57:46 <cfoch> is there a function like
11:57:47 <cfoch> getPersistBuildConfig
11:57:58 <ski> Kujanator : as an exercise with booleans and `if', you could work through enough of the cases of mauke's "any time you have 'if X then Y else Z' and Y or Z is True or False, you can rewrite without using if/True/False"
11:58:04 <ReinH> cfoch: What would it do?
11:58:06 <cfoch> that does not fail when "the file was created by an older version of Cabal"? 
11:58:35 <ski> __Guest : ok. now, consider the general situation `frob :: (exists a. Foo a) -> Bar' .. what does such a type signature mean ?
11:58:42 <cfoch> that "returns" the LocalBuildInfo even if "it was created by an older version of Cabal" ?
11:59:08 <Kujanator> ski: I used to be pretty good at boolean logic, did lots of it last year in a module at uni but have forgotten/not used it for a while now.
11:59:12 <ski> __Guest : well, we expect to be able to pass a value of type `Foo a' to the function `frob' (getting back a result value of type `Bar'), for *any* `a'
11:59:34 <__Guest> ski: ah! i see
11:59:47 <monochrom> most boolean logic courses fail to recognize and honour the if-then-else expression. and the iff operator.
12:00:14 <monochrom> they only tell you about and-or-not, which are hardly the most important ones you need
12:00:23 <ReinH> cfoch: No, that logic is baked into the function that reads the file
12:00:27 <ski> __Guest : it's enough that there *exists* *some* `a' such that the argument can have type `Foo a' -- e.g. if the actual argument has type `Foo B', then this would be ok, since then it has type `Foo a' for some `a' (in this case `B'), and therefore it can be considered to have type `exists a. Foo a'
12:00:41 <monochrom> the most important operators a programmer need are ==>, <==, <=>, and if-then-else.
12:00:53 <ReinH> cfoch: You'd have to write your own version of https://downloads.haskell.org/~ghc/7.8.2/docs/html/libraries/Cabal-1.18.1.3/src/Distribution-Simple-Configure.html#tryGetConfigStateFile, I suppose
12:01:08 <ski> __Guest : now, what is the difference between that type signature and `frob :: forall a. Foo a -> Bar' (which means `frob :: forall a. (Foo a -> Bar)', if you're unsure) ?
12:01:48 <ski> Kujanator : also, you didn't suggestion simplifications for the `(...) == True' and `(...) == False' cases :)
12:01:48 <StrangeLoop> Hi, is there anyway to take several variables from the same list in list comprehension? Something less redundant then [ (a,b,c) | a <- x, b <- x, c <- x]?
12:01:59 <ReinH> cfoch: Sorry, that's an older version. http://hackage.haskell.org/package/Cabal-1.22.1.1/docs/src/Distribution-Simple-Configure.html#getConfigStateFile
12:02:17 <__Guest> ski: it's not scoped, it doesn't apply to just the Foo, so it wants to have any a that can be fit in to (Foo a -> Bar) as a function?
12:02:19 <ski> StrangeLoop : `[a,b,c] <- replicateM 3 x'
12:02:36 <HeladoDeBrownie> ski, typo?
12:03:09 <Cale> > [ (a,b,c) | [a,b,c] <- replicateM 3 [0,1] ]
12:03:10 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
12:03:18 <HeladoDeBrownie> huh
12:03:20 <ski> HeladoDeBrownie ?
12:03:28 <HeladoDeBrownie> i didn't realize [a,b,c] was valid
12:03:41 <Cale> Yeah, you can pattern match against lists like that :)
12:03:55 <ski> __Guest : yes, there's a difference in scope. in this case, the `Bar' part doesn't mention `a' so that doesn't matter here
12:03:56 <HeladoDeBrownie> woops, i just had a brain fart is all
12:04:17 <ski> __Guest : however, when this other variant of `frob' is called, what does that mean ?
12:04:20 <HeladoDeBrownie> my brain lied to me and told me it involved tuples, similar to python
12:04:42 <ski> __Guest : well, `frob :: forall a. Foo a -> Bar' means that, for every type `a', `frob' can be considered to have type `Foo a -> Bar'
12:05:16 <nerium> Can any one explain to me why I need "join" on line #6?
12:05:17 <nerium> https://gist.github.com/oleander/a03901895cae8a39db10
12:05:20 <ski> __Guest : so, if we have a `Foo B', then `frob' could be considered to have type `Foo B -> Bar', and so we could apply `frob' to the same value of type `Foo B' as before
12:05:28 <nerium> Should fmap be enough?
12:05:33 <StrangeLoop> Is there anyway to do it without monad voodoo?
12:05:41 <ski> __Guest : in effect, these two possible type signatures for `frob' behaves the *same* !
12:05:53 <monochrom> nerium, "fmap f m" has type "m (m b)", not "m b".
12:06:16 <StrangeLoop> Maybe I'm asking the wrong question, I'm just trying to generate the 4th cartesian power of a specific list
12:06:21 <__Guest> ski: but with the existential version the a is hidden from scope, meaning it'd look like 'Foo -> Bar', yes?
12:06:27 <ski> __Guest : it's a logical law that the `forall a. (..a.. -> ...)' (where the former `..a..' may mention `a', but the latter `...' may not) is equivalent to `(exists a. ..a..) -> ...'
12:06:34 <__Guest> ski: i see
12:06:35 <nerium> monochrom: (a -> b) -> f a -> f b, doesn't that mean that I will "unpack" the monad , apply "f" and then pack it again?
12:06:39 <Cale> nerium: Well, think about what the type would be. It may help you to rename the type variables first. So suppose you have x :: m t and f :: (t -> m s), as well as fmap :: (a -> b) -> f a -> f b. Now what type will fmap f x have?
12:07:18 <monochrom> nerium, do you mind if I use non-name-clashing type variables for the type of fmap? "fmap :: (x -> y) -> f x -> f y"?
12:07:22 <Kujanator> ski: What bit am I supposed to be simplifying from this?  evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na)                        else evalA b s1
12:07:26 <ski> __Guest : anyway, going back to the data constructor `WrapAKind' for our type `SomeAKind' which was supposed to contain (conceptually) a `exists a. AKind a'
12:07:40 <monochrom> or I guess Cale's naming scheme
12:07:48 <Cale> Well, to make the types match, (with f = m) we need a = t, and b = m s, so then f a = m t, and finally f b = m (m s)
12:08:12 <nerium> Cale: I would say "m t"
12:08:29 <ski> __Guest : so, by the above insight, we could rephrase the (pseudocode) `WrapAKind :: (exists a. AKind a) -> SomeAKind' into `WrapAKind :: forall a. AKind a -> SomeAKind' -- which makes sense, since `WrapAKind' is supposed to be able to hide *any* `a' (so should work with *every* possible `a' here)
12:08:29 <Cale> nerium: Why? Do you think b = t?
12:08:44 <nerium> Cale: Hold on
12:08:48 <ski> Kujanator : oh, nothing more :)
12:08:57 <ski> Kujanator : if you wanted to, you could rephase it like
12:09:07 <ski>   evalB (a :||: b) s0 = evalA b s1
12:09:09 <ski>     where
12:09:12 <__Guest> ski: interesting
12:09:13 <ski>     (s1, na) = evalA a s0
12:09:46 <ski> er, sorry, i forgot the `if' part
12:09:53 <ski> we could use a guard, so then it'd be
12:09:55 <monochrom> nerium: don't use intuition. use mechanization. do the matching up and plugging in.
12:09:58 <ski>   evalB (a :||: b) s0
12:10:19 <ski>     | na        = (s1,na)
12:10:21 <nerium> Cale: https://gist.github.com/oleander/3aa1142b036ed3f2eaa1
12:10:29 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
12:10:32 <ski>     | otherwise = evalA b s1
12:10:35 <ski>       where
12:10:41 <nerium> monochrom: I*m trying to :)
12:10:42 <ski>       (s1,na) = evalA a s0
12:10:47 <Cale> nerium: write down the type of fmap as well
12:11:10 <Cale> nerium: then determine equations between the types which are forced in order to allow fmap to be applied to first f and then x
12:11:22 <monochrom> wait, "f :: (a -> b) -> f a -> f b"? shouldn't that belong to fmap?
12:11:25 <Cale> (well, f will be enough to completely determine things in this case)
12:11:38 <Cale> yeah, also, you've given f the type of fmap
12:12:08 <ski> __Guest : ok. so using GADT syntax, it's now straightforward to write this : `data SomeAKind :: * where WrapAKind :: forall a. AKind a -> SomeAKind' -- and here it is possible to elide the `forall a. ' part
12:12:13 <nerium> monochrom: Yes, that's try
12:12:16 <nerium> *true
12:12:52 <monochrom> I'm going to combine Cale's naming and my naming. that is, there is no "a" or "b" anywhere. only s, t, x, y
12:12:56 <JagaJaga_> I have two libs (A and B) in one folder. How to make B search for A.Module?
12:13:15 <ski> __Guest : as i mentioned before, you'll need to explicitly wrap using `WrapAKind' whenever you want to hide/forget the `a' (e.g. if you want to store several `AKind a' with potentially differing `a's in the same list)
12:13:15 <nerium> Cale: How about this? https://gist.github.com/oleander/3aa1142b036ed3f2eaa1
12:13:39 <monochrom> no, f :: t -> m s
12:14:05 <monochrom> (>>=) will not accept (x :: m t) >>= (f :: a -> b).
12:14:08 <nerium> monochrom: Aha, it sit
12:14:13 <nerium> *is it
12:14:36 <ski> __Guest : .. and you need to pattern-match when you want to extract the innards, and by then, you won't (in general) have any idea what `a' actually is (`B' or `C' in your case), and so the implementation won't allow you to treat it as if it have to be a `B' or a `C' (unless you *gain* the knowledge of what `a' is from somewhere else, possibly by matching on the data constructors of some other GADT)
12:14:43 <ski> __Guest : makes any sense ?
12:14:44 <Kujanator> ski: Got disconnected. Last message I sent was "What bit am I supposed to be simplifying from this?  evalB (a :||: b) s0 = let (s1, na) = evalA a s0 in if na then (s1, na)                        else evalA b s1" but got disconnected straight after
12:15:04 <ski> Kujanator : i'll pm, stand by
12:15:25 <lpaste> Cale pasted ‚Äútypechecking‚Äù at http://lpaste.net/124315
12:15:28 <monochrom> x :: m t, f :: t -> m s. therefore for "fmap f x" to make sense, fmap :: (t -> m s) -> m t -> m (m s). a=t, b=ms
12:15:30 <Cale> nerium: ^^
12:15:36 <Cale> see my paste
12:15:42 <__Guest> ski: yes, yes it does make sense
12:16:14 <nerium> Cale: Looking
12:16:26 <nerium> monochrom: Thanks, I need to think for a few min :)
12:18:48 <Cale> nerium: Here I'm using the fact that whenever you have f :: a -> b and x :: c, and you see a function application f x, you know that a = c (for if not, there is a type error)
12:19:50 <Cale> nerium: I also used the fact that (a -> b) = (c -> d) if and only if a = c and b = d
12:19:51 <nerium> Cale: Is it really "f"s job to repack "x" again?
12:20:07 <Cale> nerium: I have no idea what you're talking about with respect to "packing"
12:20:27 <nerium> Cale: fmap (+4) (Just 10)
12:20:36 <Cale> nerium: Everything we're looking at here is all taking place at the type level at compile time
12:20:48 <HeladoDeBrownie> nerium, you cannot understand this in terms of packing and unpacking, not even in general at the value level.
12:20:49 <nerium> fmap unpacks the "Just", apply the function and apply Just again
12:21:06 <ab9rf> nerium: that's only true for container-like monads
12:21:15 <nerium> HeladoDeBrownie: That's how they explained it at learnyouahaskell
12:21:17 <Cale> nerium: You're asking how the types of things are being inferred, which is not a runtime question.
12:21:18 <ab9rf> and even then there are exceptions
12:21:25 <HeladoDeBrownie> nerium, lyah has some problems, and that's one of them.
12:21:31 <ski> __Guest : i want to reiterate that if you get a `SomeAKind', then while it contains a `exists a. AKind a', if you use pattern-matching to extract a value, it will have type `AKind a', but you'll have no idea at all what `a' is
12:21:47 <monochrom> I say, get the types right first.
12:21:48 <Cale> nerium: Do you follow my argument for why fmap f x has the type that it does?
12:22:04 <monochrom> there is no unpack or repack if there is a type error. this is not lisp.
12:22:05 <Cale> nerium: If not, then what's the first thing that doesn't make sense?
12:22:06 <nerium> Cale: I'll read what you wrote again, hold on
12:22:08 <HeladoDeBrownie> well, no. the problem isn't necessarily explaining it in terms of packing and unpacking. the problem is not clearly labeling that as a possible intuition rather than technically what is happening.
12:22:18 <Kujanator> ski: Not sure if PM went through to you, did you receive it?
12:22:34 <Kujanator> ski: I got yours though :)
12:23:00 <__Guest> ski: i understand now, it makes a lot more sense
12:23:08 <ski> __Guest : in this particular case, you had `data AKind :: A -> * where BType :: AKind B; CType :: AKind C', so in thts case, by pattern-matching on the value of type `AKind a' (for unknown `a'), in the `BType' case you (and the implementation) realize that `a' must have been `B', and in the `CType' case that `a' must have been `C'
12:23:28 <nerium> Cale: In the case of my just example, what would "m s" be in f : t -> m s?
12:23:40 <nerium> An int?
12:23:48 <Cale> m = Maybe in your case
12:23:55 <Cale> and s = Int
12:23:59 <ski> __Guest : in this case, we could recover `a' by looking at the data itself. in other cases, one could possibly recover it by looking at some other part of the data (that is "under" the same `exists a.') and which refers to the same `a'
12:24:09 <Cale> but your example isn't an example of this
12:24:20 <nerium> Cale: But the function I*m passing (+10) returns an int
12:24:42 <Cale> > fmap (\x -> if even x then Just (x `div` 2) else Nothing) (Just 6)
12:24:44 <lambdabot>  Just (Just 3)
12:24:50 <Cale> this is a better example
12:24:54 <Cale> :t (\x -> if even x then Just (x `div` 2) else Nothing)
12:24:55 <lambdabot> Integral a => a -> Maybe a
12:25:07 <Cale> Let's just say Integer -> Maybe Integer
12:25:23 <ski> __Guest : now, for the older syntax for "existential datatypes". consider again `WrapAKind :: forall a. AKind a -> SomeAKind'. this means that for any valid `a' (in this case only `B' or `C'), we can consider `WrapAKind' to have type `AKind a -> SomeAKind'
12:25:26 <Cale> So, in this example, we have t = s = Integer
12:25:31 <Cale> and m = Maybe
12:25:54 <Cale> f :: Integer -> Maybe Integer, and x :: Maybe Integer
12:26:03 <Cale> So fmap f x :: Maybe (Maybe Integer)
12:26:23 <ski> __Guest : using the old syntax, the datatype with this data constructor would be defined as `data SomeAKind = forall a. WrapAKind (AKind a)' -- note that the `forall a. ' is *before* the constructor (expressing that the constructor itself is polymorphic, works for any `a')
12:26:24 <nerium> Cale: Aha, then everything makes sense
12:26:38 <Cale> Or for another example:
12:26:46 <nerium> Which is also why I need to apply join
12:26:46 <Cale> > fmap (\x -> [x, 10*x]) [1,2,3]
12:26:48 <lambdabot>  [[1,10],[2,20],[3,30]]
12:26:52 <saml> wow
12:27:16 <saml> for each x, [x,10x]
12:27:16 <Cale> Here, f :: Integer -> [Integer], and x :: [Integer], so fmap f x :: [[Integer]]
12:27:44 <saml> how can I do  so that result is [1,10,2,20,3,30] ?
12:27:48 <saml> given [1,2,3]
12:27:59 <ski> __Guest : it is also possible to write `data SomethingElse = WrapSE (forall a. AKind a)', but that means something else. it means that not the data constructor `WrapSE', but rather its *argument* is required to be polymorphic
12:28:00 <Cale> [1,2,3] >>= (\x -> [x, 10*x])
12:28:02 <Cale> > [1,2,3] >>= (\x -> [x, 10*x])
12:28:03 <lambdabot>  [1,10,2,20,3,30]
12:28:07 <nerium> Cale: Cool, not I understand it all, thanks!
12:28:18 <nerium> Maybe not everything, but this particular example
12:28:23 <nerium> and how fmap works
12:28:26 <ski> __Guest : (so you can't pass something of type `AKind B', nor something of type `AKind C'. `WrapSE :: (forall a. AKind a) -> SomethingElse' requires the argument to the constructor has *both* types at the same time -- in this case, there is no sensible such argument)
12:28:31 <ski> __Guest : ok ?
12:28:46 <Cale> nerium: In other cases, f/m might not look like container types (at least not without a very general notion of what a container is)
12:29:06 <Cale> nerium: It's very common for (f t) to be some type of computations whose result has type t
12:29:13 <saml> > foldr (\x -> acc -> x : (10*x) : acc) [] [1,2,3]
12:29:14 <lambdabot>  Pattern syntax in expression context:
12:29:14 <lambdabot>      \ x -> acc -> x : (10 * x) : acc
12:29:16 <__Guest> ski: i see
12:29:43 <ski> Kujanator : yes, i got it. what is your question ?
12:29:51 <EvanR_> f t might be using t as a phantom has it has no operational significance
12:29:53 <nerium> Make sense
12:29:53 <Cale> nerium: and then fmap f x will effectively construct a computation which does the same thing as x, but applies f to the result before returning it.
12:30:21 <ski> __Guest : .. which brings us to rank-2 (and in general rank-`n', for `n >= 2', called higher-rank) operations
12:30:40 <Kujanator> ski: When I compile it I get 5 errors about the type and the errors. Would it be OK if I put it on pastebin and I let you have a look?
12:30:46 <ski> __Guest : some operation of type `forall a. ..a..' is polymorphic
12:31:11 <saml> how can I micro benchmark?   foldr (\x acc -> x : (x*10) : acc) [] [1,2,3]      vs.   [1,2,3] >>= (\x -> [x, 10*x])
12:31:24 <ski> __Guest : some operation/value of type `exists a. ..a..' would be said to be an existential value/operation. it is "abstract" in the sense that it hides/forgets some type detail
12:31:39 <nerium> Also, without using the "do" notation, would this be the correct way to implement "join"? 
12:31:39 <nerium> https://gist.github.com/oleander/425083cd713f0d93fa55
12:31:51 <__Guest> ski: ah
12:31:53 <nerium> I type checks, but I'm not sure if it works
12:32:23 <ski> __Guest : an operation of type `(exists a. ..a..) -> ...' is basically the same as one of type `forall a. (..a.. -> ...)', so this is just a polymorphic function (whose result type happens to not mention the universally quantified type variable)
12:33:10 <__Guest> ski: interesting
12:33:34 <ski> __Guest : now, for an operation of type `... -> (exists a. ..a..)', we need to *encode* the existential in some way. i explained the "existential data type" way above, because we can't just "translate it away" by using a logical law as in the case where the `exists' was in the argument type
12:33:53 <ski> Kujanator : yes, you could e.g. use
12:33:54 <Kujanator> ski: If you don't mind having a look, http://pastebin.com/SX1BreUx
12:33:54 <ski> @lpaste
12:33:54 <lambdabot> Haskell pastebin: http://lpaste.net/
12:33:58 <ski> Kujanator : ok
12:35:01 <__Guest> ski: ahhh i see
12:35:10 <ski> Kujanator : ok, you used the wrong evaluation function in the last defining equation of `evalB'
12:35:21 * hackagebot GLUtil 0.8.5 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.5 (AnthonyCowley)
12:35:26 <ski> (i didn't notice this before)
12:35:45 <monochrom> nerium: it is correct. but it can be simplified to m >>= id
12:36:05 <monochrom> (\m'' -> return m'') = return
12:36:10 <ski> __Guest : an operation of type `... -> (forall a. ..a..)' is also basically the same as one of type `forall a. (... -> ..a..)'
12:36:13 <kaiyin> How is the Foldable/Traversable plan for Prelude going?
12:36:17 <monochrom> (m' >>= return) = m'
12:36:23 <monochrom> (\m' -> m') = id
12:36:26 <ski> __Guest : and then, for an operation of type `(forall a. ..a..) -> ...', this is a new thing
12:36:41 <nerium> monochrom: Hmm, that looks easier 
12:36:43 <nerium> thanks
12:37:11 <ski> __Guest : this is called a rank-2 operation. (sometimes it's called "rank-2 polymorphism", but i think that's a misnomer. because such an operation is *not* polymorphic)
12:37:24 <ski> __Guest : such an operation *expects* its argument to be polymorphic
12:37:24 <Kujanator> ski: Wait so I never use evalA, I've changed both to evalB and it compiles now. evalB (a :||: b) s0 = let (s1, na) = evalB a s0                        in if na then (s1, na)                          else let (s2, nb) = evalB b s1                            in (s2, nb)
12:37:53 <__Guest> ski: ohh
12:37:55 <ski> __Guest : one reason for wanting such could be that one wants to apply the operation at several distinct types, and so one really needs to argument to be polymorphic
12:38:39 <ski> __Guest : another reason could be that one wants to hide some (type) information, not divulging to the caller at exactly which type it wants to use the polymorphic operation
12:39:32 <__Guest> ski: the idea of polymorphism is against me trying to have concrete data, isn't it
12:39:46 <ski> __Guest : that could be done both for hiding implementing detail, and also for protecting the behaviour of the function by not allowing the "callback" argument operation to "mess with" the parts it otherwise wouldn't be polymorphic in, so to speak
12:40:16 <ski> Kujanator : you use `evalA' in the `:==:' and `:<=:' cases
12:40:55 <ski> __Guest : `runST :: (forall s. ST s a) -> a' could possibly be considered a case of the latter
12:41:09 <ski> __Guest : i'm not sure i understand the question
12:41:53 <__Guest> ski: oh, it was more of a note to myself
12:42:00 <ski> __Guest : for `frob :: forall a. ..a..', the caller decides what `a' should be, the callee (`frob' here) must be prepared to handle any possible `a'
12:42:31 <ski> __Guest : for `frob :: exists a. ..a..', the *callee* (`frob' itself) decides what `a' should be, the caller/user must be prepared to handle any possible `a'
12:42:51 <Kujanator> ski: So I don't use it in the :||:, not sure why I thought i should to be honest.
12:42:53 <ski> __Guest : same goes for when those two are used in the *return* type of functions
12:42:54 <teneen> where is the Ord instance for [a] located in the sources?
12:43:13 <ski> __Guest : when they are used in the *argument* types of function, they get swapped
12:43:28 <ski> Kujanator : *nod*. all is fine, no ?
12:44:17 <Kujanator> ski: Yeah, gonna try and implement short circuit and now. One thing, I'm slightly confused. I understand short circuit or works by if the first one is true it just doesn't check the other thing, but with and surely it always has to check both?
12:44:35 <geekosaur> think about it
12:44:42 <__Guest> ski: swapped, meaning the caller decides what a should be?
12:44:45 <geekosaur> it's very similar to the or case
12:44:46 <ttt_fff> yesod, snap, happstack <-- these fit in the same category; does 'wai' also fit in the same category, or is it some layer on top / beneath those three ?
12:45:28 <tdammers> ttt_fff: beneath
12:45:55 <tdammers> WAI is really just a little abstraction layer between a web server and a web application
12:46:07 <ttt_fff> tdammers: is it documented anywhere? I am havin trouble finding documentation; but all I want is something which lets me dispatch on GET/POST/PUT requests, so I thikn wai sufficies for my needs
12:46:23 <tdammers> ttt_fff: sure; the haddock on hackage is pretty OK
12:46:42 <ttt_fff> tdammers: I was looking for something slightly more hand-holdy ish, like a tutorial or something
12:46:45 <tdammers> ttt_fff: also, look into scotty - it's one small step up, adding routing and a few other conveniences to WAI
12:47:10 <Kujanator> geekosaur, so if it's false it doesn't need to look at the other one?
12:47:17 <geekosaur> exactly
12:47:27 <ski> Kujanator : yep
12:47:30 <tdammers> ttt_fff: well, WAI is pretty straightforward really, if you know your HTTP
12:47:44 <ski> Kujanator : this is related to the mauke exercise above
12:47:45 <teneen> in which module is the Ord instance for [a] located now?
12:47:49 <ttt_fff> tdammers: I do not know my HTTP, but https://github.com/martinrehfeld/wai-example/blob/master/App.hs looks close enough
12:47:55 * Lutin` dies
12:47:57 <ski> __Guest : yes
12:47:59 <tdammers> right
12:48:11 <Lutin`> Anyone want to take over my job?
12:48:11 <tdammers> it really helps to understand the basics of HTTP for this kind of stuff
12:48:15 <Lutin`> I'm tired of writing APL
12:48:19 <bergmark> teneen: :i Ord in ghci
12:48:19 <sinelaw> What's an accepted name for "things that can have covariant parts and contravariant parts" such as a function (args vs. result)?
12:48:22 <ttt_fff> tdammers: where do I learn that?
12:48:26 <ski> __Guest : so in `(exists a. ..a..) -> ...' (which we know is `forall a. (..a..) -> ...') the caller decides on `a'
12:48:29 <tdammers> ttt_fff: idk... wikipedia?
12:48:31 <ttt_fff> Lutin`: please write a APL interpreter in haskell
12:48:38 <ttt_fff> tdammers: I was thiking some book
12:48:43 <ttt_fff> tdammers: you learn just by reading wikipedia links?
12:48:52 <sinelaw> maybe things that can be both covariant and contravariant functors?
12:48:54 <Kujanator> is the only time when you need to check the second one when the first one is true?
12:48:55 <Lutin`> ttt_fff: But I want to stop writing apl lol
12:48:58 <sinelaw> is there a name for that?
12:49:15 <tdammers> reading wikipedia, reading documentation, tinkering, thinking about stuff, asking on IRC and other channels, yes
12:49:29 <Lutin`> ttt_fff: Having to do a ton of networking and it's driving me crazy
12:49:50 <tdammers> I think I haven't read a treeware tech book in over 15 years
12:50:10 <tdammers> no wait, that's a lie... they made me read two of them for MS certification
12:50:12 <ski> __Guest : and in `frob :: (forall a. ..a..) -> ...', the callee (the rank-2 `frob' itself) decides on `a' -- in this case, it may use the argument multiple times, possibly with a different `a' each time (possibly depending on other input argument values, .. also, there could be a potential infinite number of types it could actually use for `a', so it's not in general fixed to a finite set at compile-time)
12:51:15 <sinelaw> Cale, if you're there, did you see my question?
12:51:28 <Cale> sinelaw: Profunctor
12:51:44 <Cale> https://hackage.haskell.org/package/profunctors-4.4.1/docs/Data-Profunctor.html
12:51:55 <Cale> sinelaw: Is that what you're thinking of?
12:52:20 <ski> __Guest : btw, note that if you have e.g. `frob :: ((forall a. ..a..) -> ...) -> ...' (which is rank-3), then it is again the caller that (indirectly) decides on `a' (indirectly, because it is the (rank-2) callback function of type `(forall a. ..a..) -> ...' that will decide which type(s) to use for `a')
12:52:23 <Cale> sinelaw: I've also seen such things referred to as difunctors
12:52:31 <ski> __Guest : now, i wanted to go back to the other representation of existentials
12:52:45 <ski> __Guest : .. if you're up for it, i.e. ?
12:52:55 <sinelaw> Cale, looks like it
12:53:10 <sinelaw> Cale, so a function a -> b is a Profunctor, right?
12:53:24 <Cale> The type constructor (->) itself is a profunctor
12:53:38 <sinelaw> Cale, that's what I meant
12:53:41 <sinelaw> Cale, ok
12:53:50 <__Guest> ski: hmm, i don't think i am sorry. it's pretty early in the morning so i should probably get going. this is fascinating though
12:54:14 <sinelaw> Cale, nice to have stumbled onto that by myself!
12:54:53 <ReinH> sinelaw: especially as profunctors are sort of a big deal :)
12:55:15 <Lutin`> ttt_fff: I would much rather be writing a distributed computing library for Haskel than for APL
12:55:16 <sinelaw> ReinH, I've heard of them, didn't get around to learning more - now I have a good excuse
12:55:35 <ski> __Guest : ok, perhaps some other time. this will tie in some more with your <http://sprunge.us/IPUS>, and what you can usefully do to handle `FoodKind' there (basically doing, in a better way, what it looks like you're trying to do with `tryKind', and possibly also `hayToKind',`seaweedToKind')
12:55:57 <ski> __Guest : also, i had some comments on <http://lpaste.net/124305> .. but perhaps later then
12:56:21 <BurningCa007> night yall
12:56:25 <sinelaw> ReinH, my trigger was that in a type system I need to represent function types as a special type-level AST node, until now they were just "type constructors", and I thought maybe I could generalize the concept
12:56:52 <ski> Cale : i think difunctor is (at least along one axis) more general
12:57:17 <Cale> ski: hm?
12:57:18 <ski> Cale : difunctor is "just like a bifunctor, except contravariant in the first argument component"
12:57:37 <ski> at least according to <http://ncatlab.org/nlab/show/profunctor>, the codomain of a profunctor should be `Set'
12:58:58 <ab9rf> i prefer amateur functors anyway
12:59:00 <Cale> ski: Oh, good point. I haven't seen a formal definition of difunctor outside the context of Haskell though.
12:59:07 <__Guest> ski: mmm... i'm not sure when i'll be around next :\ i'm up for any quick notes on that sprunge though, if you have any
12:59:53 <Cale> But yeah, perhaps we could use that term for the more general case
13:01:41 <orvqol> part
13:02:38 <clrnd> quick doubt, what gets exported when I don't specify anything? like in `module Something where; import Data.Set; id x = x; etc...`
13:02:46 <ReinH> Everything.
13:02:53 <clrnd> including Data.Set?
13:02:58 <ReinH> Everything defined in your module.
13:03:11 <clrnd> ReinH, ah, it doesn't rexports imports
13:03:14 <clrnd> thanks
13:03:17 <ReinH> Correct.
13:03:19 <clrnd> :)
13:04:27 <Cale> Another meaningful generalisation of profunctor would demand that the codomain be some sort of monoidal category with enough coends to be able to define composition. I wonder if anyone does that.
13:12:34 <sinelaw> can list be a Profunctor where lmap f = (:) . f  ?
13:13:15 <sinelaw> (and rmap = map = fmap)
13:13:54 <c_wraith> sinelaw: [] doesn't have a kind compatible with Profunctor
13:14:12 <c_wraith> sinelaw: Profunctor needs a kind compatible with * -> * -> *
13:14:34 <sinelaw> c_wraith, ok, so what I mean is...
13:15:30 <Zemyla> newtype Assoc a b = Assoc [(a, b)]
13:15:37 <ski> Cale : hm, i think i first saw it in some CT book ..
13:17:18 <sinelaw> newtype PList a b = PList (a -> b) [b]
13:17:44 <c_wraith> sinelaw: that'd need to be a data. :P
13:17:57 <sinelaw> c_wraith, err yip. :)
13:18:11 <c_wraith> sinelaw: But yes, that can be an instance of Profunctor
13:21:17 <SrPx> Hey guys, as a follow up to yesterday's questions, you said it is fine to define a card that depends on player's input as `(MonadIO m) => Player -> m Player`. My question is: what if I later on decide to create an AI that plays the game? Since MonadIO needs a human typing stuff on the console, doesn't that make the game impossible to simulate programatically? 
13:21:57 <Zemyla> No reason why it can't.
13:22:06 <ReinH> Cale: Well, of course a profunctor p : C -/-> D when C and D are V-enriched is a V-functor D^op * C -> V
13:22:34 <ReinH> SrPx: you could use a free monad.
13:22:45 <Cale> ReinH: Yeah, but I'm not sure that gives you enough structure to define the composition of profunctors on its own
13:23:18 <SrPx> But... yesterday you told me not to... 
13:23:19 <ReinH> Cale: Ah. You can use coends to get a bicategory
13:23:22 <Zemyla> SrPx: If you have a function f :: Player -> Player, then return . f gives you the signature you want.
13:23:28 <ReinH> SrPx: I didn't talk to you yesterday
13:24:32 <ReinH> MonadIO doesn't need a human typing stuff on the console anyway
13:24:35 <gdoteof> i am trying to add the `hedis` package to my yesod app.  i'm running into some cabal hell and tyring to understand how cabal is deciding the packages to use
13:24:42 <ReinH> As Zemyla said, you can lift a function a -> a to a function a -> IO a
13:24:48 <Cale> ReinH: Right, but how to ensure that the appropriate coends will exist?
13:24:53 <gdoteof> for example, the first thing it says is In order, the following would be installed:
13:24:56 <gdoteof> asn1-parse-0.9.0 (reinstall) changes: text-1.1.1.3 -> 0.11.3.1
13:25:03 <ReinH> Your AI might also want to do IO-related things, like generating a random number (although this could also be done from a seed)
13:25:21 <Luke> is there a good way to restrict a StateT to a ReaderT for certain functions?
13:25:25 <gdoteof> best asn1-parse has a dependency that test >= 0.11   why is it downgrading?
13:25:36 <ReinH> er, to MonadIO m => a -> m a
13:25:37 <Cale> SrPx: What is going on? Why MonadIO?
13:25:40 <gdoteof> s/best/but/
13:26:16 <Cale> I missed yesterday's discussion.
13:27:15 <gdoteof> is there a way to use cabal to drill down on a dependency?  i can't figure out what is the thing that is requiring text < 1.1 that is forcing th downgrade
13:28:29 <glguy> gdoteof: You can build with --constraint=text==1.2.04 (or whatever) and see which package fails to install because of that constraint
13:28:53 <glguy> 1.2.0.4
13:29:04 <gdoteof> glguy: ah.. cool thanks illt ry that
13:29:23 <ReinH> Cale: btw, since profunctors in Haskell are endoprofunctors, do we have a theory of monoids in the category of endoprofunctors?
13:30:13 <Cale> ReinH: I am reminded of this paper https://www.cs.ox.ac.uk/people/chris.heunen/publications/2006/arrows/arrows.pdf
13:30:33 <ReinH> Cale: huh
13:30:50 <gdoteof> lol  it just built fine
13:30:51 <gdoteof> wtf
13:31:08 <juanpaucar> lol
13:31:20 <Hijiri> you intimidated cabal into doing what you want
13:31:38 <Cale> ReinH: Note, the result isn't quite as nice as the one line summary might suggest -- Hughes' Arrows are *particular* monoids of that sort
13:31:48 <ReinH> Hmm.
13:31:48 <glguy> gdoteof: Perhaps it was trying to use an outdated package version you already had installed of another package
13:31:48 <gdoteof> how can haskell be so amazing and cabal suck so much?
13:32:09 <glguy> cabal doesn't really suck, is how
13:32:31 <glguy> It's not cabal's fault that people construct such large and varying constraints of dependencies
13:32:35 <joobus> gdoteof: were you using a sandbox?
13:32:41 <tdammers> cabal is pretty good, actually; the haskell community just got spoiled and drove it to its limits
13:32:44 <ReinH> Cale: On a somewhat related note, this paper looks pretty interesting http://www.cl.cam.ac.uk/~gw104/fossacs2013_submission_12.pdf
13:32:49 <SrPx> (a second, just had a problem)
13:33:15 <gdoteof> glguy: i already had 1.1.x so it seems weird it would force a downgrade to 0.11 only to break everything
13:33:28 <ReinH> gdoteof: do you know of any other systems that do what cabal does better?
13:33:54 <gdoteof> joobus: kind of; not a cabal sandbox; but a container that does nothing but hold dependencies for hte one app
13:33:58 <glguy> gdoteof: When you've got a random assortment of libraries installed on your computer in various states of being outdated or not
13:34:15 <glguy> cabal does what it can to make things work. It necessarily has to make some arbitrary decisions
13:34:21 <gdoteof> ReinH: npm works like a charm
13:34:38 <tdammers> npm ignores a lot of things that cabal considers important
13:34:43 <bergmark> gdoteof: that's because npm just ignores most of the problems it faces
13:34:58 <ReinH> for some value of "works", I suppose
13:36:04 <bergmark> and then maybe you'll find out later when your server has been running for a while that there were problems
13:36:10 <ReinH> Cale: Probably something in Leinster explains where the coends come from ;)
13:36:27 <ReinH> Cale: I have a vague recollection that profunctors preserve colimits, though
13:37:05 <gdoteof> well.  i don't mean to diss on cabal as a technical thing.  but from a user perspective it sucks.  and trying to force me to downgrade text 1.1 to 0.11 and then breaking everygthingg.. i'm having a hard time figuring out how that was the right thing to do
13:37:28 <gdoteof> alas.  thanks for the hint
13:38:46 <ReinH> gdoteof: You should probably use cabal sandbox, which is how npm behaves by default
13:39:30 <ReinH> gdoteof: If your container only holds dependencies for the app, how did it get text 1.1 on it to begin with?
13:39:33 <gdoteof> ReinH: is using cabal sandbox any different than having only a single haskell project on the whole system
13:39:51 <gdoteof> ReinH: that's the thing.. i have been *using* text 1.1.  it was already there
13:39:54 <ReinH> Yes, if your system includes other random packages for some reason
13:40:08 <glguy> gdoteof: It's different because it enforces a single version of each package
13:40:09 <gdoteof> ReinH: but it doesn't.  everything on that system is for the one project
13:40:25 <gdoteof> glguy: ah.  that *is* different
13:41:14 <ReinH> So you introduced a dependency with a transitive dependency on text <= 0.11 or something? There isn't really any way to solve that than by downgrading, if downgrading produces a valid plan.
13:41:27 <gdoteof> i should probably clean the dev container at this point.  in production i make the container on the fly with cabal install --only-dependencies
13:41:34 <ReinH> Or by relaxing that package's upper bound on text
13:42:00 <ReinH> ofc, since there is a major version difference, it's unlikely that this would work in this case
13:42:01 <gdoteof> ReinH: that is why I was confused.  i introduced a dependency (hedis) and somehow cabal thought I needed < 0.11  when at first glance it didn't seem that was the case anywhere
13:42:27 <gdoteof> ReinH: but then when i constrained it to text=1.1.1.3 or whatever it actually installed fine
13:43:12 <gdoteof> which is why i asked how to figure out where that dependency was coming from.  then glguy suggested the constraint, and instead of telling me where that dependency came from it just worked
13:43:13 <ReinH> gdoteof: hedis actually has a transitive dependency on text (>=1.1.1.3)
13:43:17 <ReinH> through attoparsec
13:43:38 <ReinH> So that's odd
13:43:41 * gdoteof shrugs
13:44:00 <gdoteof> yeah.  idk.. i added one line to my cabal file build depends : hedis and it got all upset
13:44:08 <ReinH> I'm not sure how it came up with text 0.11
13:44:50 <ReinH> Oh, that's not true.
13:45:12 <ReinH> hedis depends on attoparsec (>=0.10), which has a transitive dependency on text (>=0.11.1.5)
13:46:37 <ReinH> Cale: hmm, http://www.math.ias.edu/~mshulman/papers/cfapaafcc.pdf
13:49:18 <gdoteof> maybe cabal has some preference for not upgrading major versions and i tricked it by having two copies of text in the library
13:49:59 <SrPx> Sorry guys, I'm back. So, the reason for MonadIO is that certain cards require a decision from the player's part, such as "chose a card in play and send it to graveyard". The "chose a card in play" requires such decision, so I could implement the card using IO
13:50:26 * hackagebot linearscan-hoopl 0.4.0.1 - Makes it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.4.0.1 (JohnWiegley)
13:50:33 <SrPx> How would you model that other than "myCardEffect :: (MonadIO m) => Player ‚Üí m Player" ?
13:51:24 <bergmark> SrPx: wouldn't it be useful to be able to run that in something other than IO, e.g. for testing?
13:51:52 <SrPx> yes, that's the point, it would be essential to be able to plug it into an AI that would play the card, instead of an actual human
13:52:37 <ReinH> So a free monad would be a good option
13:52:45 <StrangeLoop> http://lpaste.net/124323 <-- can anyone help me figure out why the first function compiles fine and the second one returns the compilation error below?
13:53:28 <SrPx> Uh okay, I will study free monads deeper now :) thanks
13:53:32 <raek> back to basics question: is there a higher order function that combines foldl and map? I want to map over a list, but keep a "state" that gets chained through the function applications...
13:53:53 <SrPx> I guess I kinda know what to do already. Lets see if I can get it to work
13:54:09 <ReinH> raek: sure, a fold :)
13:54:10 <glguy> Data.List.mapAccumL 07:: (acc 07-> x 07-> (acc, y)) 07-> acc 07-> [x] 07-> (acc, [y])
13:54:10 <bergmark> SrPx: here's how purescript does it http://hackage.haskell.org/package/purescript-0.6.8/docs/Language-PureScript.html
13:54:17 <bergmark> (MonadMake)
13:54:17 <ReinH> although you probably want foldr
13:54:43 <raek> I want to decorate a list of tokens with source position information
13:54:46 <ReinH> glguy's packages it up for you nicely though
13:55:32 <peddie> I'm trying to find the slides from Don Stewart's tech talk that used to be at http://code.haskell.org/~dons/talks/dons-google-2015-01-27.pdf ; that URL gives a 403, but does anyone happen to have downloaded a copy?
13:55:36 <raek> glguy: thanks! that feels like the right function
13:56:11 <dmwit> StrangeLoop: Perhaps you have given oneTwoThreeZ a type signature which does not appear in this paste and is incorrect.
13:56:41 <StrangeLoop> dmwit: *sigh* you're right
13:57:39 <dmwit> raek: You may also like mapM :: (a -> State acc b) -> [a] -> State acc [b]
13:58:05 <dmwit> raek: ...which if you run through ?unmtl will look suspiciously similar to mapAccumL's type signature.
14:00:02 <apriori> hello everyone. did anyone of you manage to parse XML with HaXMl, yet? I've a XSD-schema from which I'd like to get a proper parser. XsdToHaskell does the heavy lifting but doesn't seem to handle namespaces at all. does anyone have any hints/suggestions?
14:08:56 <Cale> SrPx: Oh, when I asked "Why MonadIO?" I was really asking "Why not IO instead?"
14:09:58 <Cale> Surely it will be easier to use functions Player -> IO Player as data than it will be to use polymorphic functions (MonadIO m) => Player -> m Player
14:10:06 <SrPx> Cale: because otherwise how I will be able to make a list of card effects? Suppose that "card0 :: Player -> IO Player" and "card1 :: (MonadRandom m) => Player -> m Player"... I guess I can't make [card0,card1] typecheck this way
14:10:18 <SrPx> right??
14:10:44 <SrPx> same thing for composition of effects, `card0 >=> card1`
14:10:46 <Cale> There should be an instance of MonadRandom for IO
14:10:59 <Cale> But that's beside the point...
14:11:06 <SrPx> there is
14:11:39 <SrPx> but hmm... if I'm going to make everything IO in the end then I could just "card1 :: Player -> IO Player" too
14:11:55 <cfoch> Is there a function that tells me if I am in a sanbox?
14:11:57 <cfoch> sandbox
14:12:00 <Cale> Well, yeah, if you write [card0, card1] you'll be specialising the type like that anyway
14:12:09 <Cale> cfoch: A cabal sandbox?
14:12:18 <cfoch> yes
14:12:37 <Cale> Is this like, you're writing a custom Setup.hs or something?
14:13:50 <cfoch> Cale: no, I am just trying to fix this bug
14:13:50 <cfoch> http://hackage.haskell.org/package/Cabal-1.4.0.1/docs/Distribution-Simple-Configure.html#v%3AgetPersistBuildConfig
14:13:56 <Cale> cfoch: It seems like most of the sandbox handling is in the cabal-install package itself
14:14:25 <Cale> What bug?
14:14:42 <cfoch> oh... sorry wrong link
14:14:46 <Cale> also, that's quite an old version of Cabal
14:14:58 <Cale> http://hackage.haskell.org/package/Cabal-1.22.1.1/docs/Distribution-Simple-Configure.html#v%3AgetPersistBuildConfig
14:14:59 <cfoch> this one in Diagrams
14:15:00 <cfoch> http://git.io/pCem
14:15:43 <ww> @let earth_year = 36526.0
14:15:45 <lambdabot>  Defined.
14:15:49 <Cale> http://hackage.haskell.org/package/cabal-install-1.22.0.1/src/Distribution/Client/Sandbox.hs -- probably something from here will be useful
14:15:50 <ww> @let venus_year = 22465.0
14:15:51 <lambdabot>  Defined.
14:16:06 <Cale> Unfortunately, this is all in the source code of the cabal-install program and not a separate library
14:16:27 <Cale> I suspect that some of this code ought to get moved to Cabal itself.
14:16:54 <ww> @let f_earth = 1.0
14:16:55 <ski> > 365 + 1/4 - 1/100 + 1/400
14:16:55 <lambdabot>  Defined.
14:16:56 <lambdabot>  365.2425
14:17:03 <ww> @let f_venus = earth / venus
14:17:04 <lambdabot>  .L.hs:154:11: Not in scope: ‚Äòearth‚Äô
14:17:04 <lambdabot>  
14:17:04 <lambdabot>  .L.hs:154:19: Not in scope: ‚Äòvenus‚Äô
14:17:14 <ww> @let f_venus = earth_year / venus_year
14:17:16 <lambdabot>  Defined.
14:17:31 <monochrom> ww, what are you doing, that you can't do in pm?
14:17:31 <Cale> ww: You're aware that you can "/query lambdabot" right?
14:17:44 <ww> monochrom: 1 minute
14:19:52 <ww> so the question is, how often is the  angle  earth-venus-sun the same?
14:20:54 <ww> i would have thought of the beat frequency, but
14:21:14 <ww> > 1.0 / (abs $ f_earth - f_venus)
14:21:15 <monochrom> this is better off a ##math question
14:21:15 <lambdabot>  1.5976815304743615
14:21:38 <Cale> Yeah, this question isn't really a Haskell question, it's more of a physics or geometry question
14:22:00 <ww> perhaps, ok fine
14:22:22 <ww> but they don't have lambdabot...
14:22:34 <Cale> #haskell-blah has lambdabot, and you can talk about anything there
14:22:35 <glguy> lambdabot works in private message regardless of channel
14:22:39 <monochrom> they have something better. they have mathematicians.
14:23:10 <Cale> Also, I'm an op in ##math and can bring lambdabot if really needed, but this doesn't seem like something you'd really need lambdabot for
14:35:29 * hackagebot ObjectName 1.1.0.0 - Explicitly handled object names  http://hackage.haskell.org/package/ObjectName-1.1.0.0 (SvenPanne)
14:38:37 <mwr54> is there a combinator like "comb f x = return $ f x", the type is "Monad m => (a -> b) -> a -> m b"
14:38:41 <mwr54> if not, then why
14:40:52 <pyon> I have written a single type class (Functorial) that can handle arbitrary n-ary covariant functors: http://lpaste.net/124228 . In particular, instances are provided for any Functor and Bifunctor. The problem is that, if you want to use this class with a Bifunctor, you effectively need to apply "first" and "second" separately. Is there any way to tweak it so that it can handle applying "bimap" in a single
14:40:54 <pyon> pass?
14:41:58 <mwr54> i feel like it would be usefull for chaining in a non-monadic call with monadic ones, like instead of "do { x <- funcM; return $ func x;}" you could do "funcM >>= (comb . func)"
14:42:21 <mwr54> or is there a way to do this without creating this new combinator?
14:42:25 <Enigmagic> mwr54: `func <$> funcM` works
14:42:43 <Enigmagic> or: fmap func funcM
14:43:32 <shachaf> The most direct answer is liftM:
14:43:33 <shachaf> @src liftM
14:43:33 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:43:55 <mwr54> Enigmagic: oh yeah that makes way more sense
14:43:56 <Enigmagic> if you're stuck with a Monad constraint, yes :P
14:44:04 <shachaf> (But fmap does the same thing with a more general type, so you usually shouldn't use liftM.)
14:44:06 <L8D> @pl liftM
14:44:06 <lambdabot> fmap
14:44:13 <Cale> lol
14:44:14 <Welkin> @pl fmap
14:44:14 <lambdabot> fmap
14:44:17 <Cale> that simplifier :)
14:44:22 <mwr54> don't know why I wanted to do it this wierd way
14:44:25 <Welkin> @pl liftA
14:44:25 <lambdabot> liftA
14:44:39 <Welkin> @pl (.)
14:44:39 <lambdabot> (.)
14:44:41 <EvanR_>  @pl liftM
14:44:41 <Enigmagic> guess lambdabot isn't so smart after all
14:44:43 <EvanR_> yes
14:44:57 <L8D> liftA is not fmap in Haskell
14:45:09 <L8D> since applicatives don't have the Functor constraint
14:45:13 <L8D> (or do they?)
14:45:15 <Welkin> ?
14:45:17 <EvanR_> they will
14:45:18 <pyon> L8D: I thought it was monads that didn't.
14:45:20 <Welkin> all applicatives are functors
14:45:23 <Welkin> monads do not
14:45:25 <L8D> maybe lambdabot hasn't been updated to 7.8.10
14:45:26 <Enigmagic> applicative always has
14:45:27 <Welkin> in 7.10 they will
14:45:29 <Welkin> er
14:45:29 <L8D> that's it
14:45:30 * hackagebot ghcid 0.3.6 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.6 (NeilMitchell)
14:45:37 <Welkin> monads don't have an applicative constraint
14:45:42 <Welkin> they do have a functor one
14:45:46 <L8D> Welkin: they will
14:45:48 <shachaf> liftA and fmap and liftM are all the same function. Functor is a superclass of Applicative. liftA exists for the same reason fmapDefault exists.
14:45:56 <pyon> Welkin: I don't think they even have a Functor constraint.
14:46:09 <L8D> in former versions of Haskell, liftA was defined independently of fmap
14:46:24 <EvanR_> could have sworn my Applicative didnt have functor constraint
14:46:26 <L8D> with the Applicative-Monad proposal, they will be
14:46:29 <EvanR_> ah its monad that does not
14:46:55 <L8D> lambdabot is not at 7.8.10 yet
14:47:07 <L8D> so
14:47:10 <L8D> @pl liftA
14:47:10 <lambdabot> liftA
14:47:20 <orion> https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/haskell <-- Anyone know when tutorial six will be completed?
14:48:30 <L8D> orion: ask Michael Klishin
14:58:08 <Luke> is there a good way to restrict a StateT to a ReaderT for certain functions?
14:58:22 <Luke> I'm thinking maybe monad-control?
14:59:48 <hpc> you can write a function that does get and runReaderT yourself
14:59:50 <Cale> Luke: Just use runReaderT?
15:00:16 <hpc> readonly m = do x <- get; runReaderT m x -- or something like that
15:00:34 <Luke> good call - there's nothing generic for this though right?
15:01:23 <Luke> my suspicion was I could use monad-control for this
15:04:18 <phaazon> hey, I need some help about my attempt at interpreting an expression
15:04:19 <phaazon> http://lpaste.net/8224093572694016000
15:04:25 <phaazon> I can‚Äôt interpret that because of Lit, right?
15:04:39 <phaazon> I should be able to interpret that without putting a constraint on a
15:05:45 <phaazon> or I could put the constraint inside, I guess
15:21:41 <ttt_fff> what does warp provide over wai; and what does scotty provide over warp ? [sorry for newbiness]
15:23:05 <Luke> ttt_fff: warp is the web server, wai is an HTTP request/response + headers library with simple IO streaming
15:23:22 <Luke> ttt_fff:  scotty is a library on top of that which I don't know much about
15:23:24 <ttt_fff> Luke: and what is scotty 
15:23:28 <ttt_fff> Luke: ah, noted, thanks
15:23:58 <ReinH> scotty provides a basic DSL for handling HTTP requests
15:24:06 <ReinH> It's similar to Ruby's Sinatra if you're familiar
15:24:16 <Luke> ttt_fff: scotty sits on top of wai which sits on top of warp
15:24:28 <ttt_fff> luke: No, I thought warp sits on top of wai
15:24:36 <ttt_fff> Luke: which is lower, warp or wai ?
15:24:42 <Luke> warp is the server
15:24:57 <ttt_fff> yeah, I thought wai was closer to the TCPIP level
15:25:04 <Luke> warp uses wai to communicate to the "app"
15:26:05 <Luke> ttt_fff: warp could be considered closer to TCP
15:26:42 <ttt_fff> alright
15:26:46 <ttt_fff> i've decided to go with scotty http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
15:26:48 <ttt_fff> very nice tutorial
15:26:52 <Luke> ttt_fff: this is pretty much all wai is: http://hackage.haskell.org/package/wai-3.0.2.3/docs/Network-Wai.html
15:26:53 <Luke> ttt_fff: it's just some types
15:27:57 <BoMbZu> Does anybody have time to review my Haskell statement? http://paste.ofcode.org/NWzDHL6ysM9Y8eJauMcT3H
15:28:07 <BoMbZu> its a homework assignment the problem is stated in the paste
15:28:31 <glguy> BoMbZu: isDigit' otherwise = False -- should be -- isDigit' _ = False
15:28:47 <glguy> otherwise is actually a name defined in the Prelude as: otherwise = True
15:28:56 <glguy> which you're shadowing here
15:28:58 <BoMbZu> ohh
15:29:08 <BoMbZu> Well the isDigit' is working afaik
15:29:42 <glguy> It works, but it usually means you didn't understand why, is all
15:30:03 <BoMbZu> I see
15:30:05 <BoMbZu> thanks
15:30:32 <joelwilliamson> Is there a common data structure that acts as a two-way map?
15:30:36 <joelwilliamson> Basically I'd like to be able to have Map k a, with efficient findByKey :: k -> Maybe a, and findByVal :: a -> Maybe k.
15:30:46 <geekosaur> @hoogle BiMap
15:30:48 <lambdabot> package bimap
15:30:53 <glguy> for digitIndex' you can either keep track of which index you're at as you go, or you can check that you aren't adding 1 to the -1 result case
15:30:55 <joelwilliamson> Thanks
15:32:29 <BoMbZu> There is no way in Haskell to Hard return -1 I guess?
15:32:48 <BoMbZu> Or atleast I would not know how
15:32:50 <geekosaur> meaning?
15:32:51 <monochrom> what is "hard return"?
15:33:03 <BoMbZu> http://paste.ofcode.org/NWzDHL6ysM9Y8eJauMcT3H
15:33:33 <BoMbZu> I am counting the index in the x:xs loop
15:33:45 <mniip> BoMbZu, separate recursive function from the -1 part
15:33:53 <monochrom> you must have a very wide screen, that can display your long sentence in full
15:34:02 <BoMbZu> ah yeah sorry about that 
15:34:34 <mniip> digitIndex' [] = -1; digitIndex xs = go xs
15:34:37 <mniip> where go = ...
15:34:55 <ion> You don‚Äôt want to overload a number as a magic value for failure. When using Maybe, the type system and the compiler will ensure the user remembers to handle any failures.
15:35:06 <ttt_fff> what's a good haskell library for making (not serving) GET/POST/PUT requests ? i.e. something to implement curl / wget
15:35:31 <mniip> actually I am wrong
15:35:46 <geekosaur> ttt_fff, http://hackage.haskell.org/package/curl ?
15:35:48 <mniip> digitIndex' xs = if go xs == 0 then -1 else go xs
15:36:03 <BoMbZu> alright
15:36:11 <BoMbZu> ill try to play arround with it a bit, thanks for your help
15:36:16 <monochrom> digitIndex' (x:xs) = if isDigit' x then 0 else (if digitIndex' xs == -1 then -1 else 1 + digitIndex' xs)
15:36:24 <mniip> that works too
15:36:41 <ttt_fff> geekosaur: nice; thanks!
15:36:59 <mniip> oh wait
15:37:03 <joelwilliamson> @BoMbZu, consider using the fact that the ASCII digits are contiguous to simplify isDigit.
15:37:03 <lambdabot> Unknown command, try @list
15:37:04 <mniip> I read the task wrong :(
15:37:25 <geekosaur> there are also some pure haskell ones, I think, and sometimes (e.g. on windows, where linking to third party libraries like libcurl can be fraught) it's easier to use those although they're less feature complete
15:37:47 <mniip> what monochrom wrote is correct
15:38:47 <mniip> now for nicification
15:39:20 <mniip> digitIndex' xs = fromMaybe (-1) $ find inRange ('0', '9') xs
15:39:28 <mniip> digitIndex' = fromMaybe (-1) . find inRange ('0', '9')
15:39:48 <mniip> oops I mean fromMaybe (-1) . find (inRange ('0', '9'))
15:40:12 <BoMbZu> Ah I see I got it working now
15:40:21 <BoMbZu> ill try to understand it and play arround for a bit
15:40:22 <mniip> if you're lacking Data.Ix,
15:40:32 <mniip> (`elem` ['0'..'9'])
15:40:43 <BoMbZu> I try to do all assignments without the help of libraries so I truly understand the basics
15:41:06 <BoMbZu> But thanks for the help I can move on now 
15:41:12 <mniip> BoMbZu, understanding combinator logic as opposed to lambdaing and recursing by hand is a neat skill too
15:42:06 <synergy_> What kinds of things should I learn to gain expertise in functional programming?
15:42:11 <NemesisD> whats the purpose of stToIO?
15:43:09 <kadoban> BoMbZu: Might be cool to do stuff both ways, very manually and then "the right way", if you can find the right libraries and functions to use.
15:43:19 <lexi-lambda> Fiddling with Haskell, had a random question: is there a nicer way to write a function like this? \a b -> f a b - g a b
15:43:33 <mniip> @pl \a b -> f a b - g a b
15:43:34 <lambdabot> ap (ap . ((-) .) . f) g
15:43:37 <mniip> ew
15:43:40 <lexi-lambda> Yeah, I tried that.
15:43:43 <lexi-lambda> Wasn't nice. :P
15:43:55 <joelteon> with ansi-wl-pprint, if I want to add spaces inside the separators that encloseSep gives me, what's the best way to do that?
15:44:09 <joelteon> right now it produces "{foo}" and I want "{ foo }"
15:44:37 <ion> lexi-lambda: It already looks nice to me.
15:44:46 <mniip> curry $ (-) <$> uncurry f <*> uncurry g
15:45:05 <lexi-lambda> mniip: That's less readable than I'd hoped. :P
15:45:19 <mniip> curry $ liftA2 (-) $ uncurry f $ uncurry g
15:45:57 <kadoban> Seems like the original is maybe the best in this case :)
15:46:20 <mniip> possible
15:46:43 <lexi-lambda> Okay. It feels like there should be a simple way to do it nicely, but eh.
15:48:36 <paxcoder> I'm trying reading an atom feed and retrieving item properties using hxt. This which gets me a flat list of results. How do I go about grouping them, so that there's a list for each item?
15:49:09 <mniip> lexi-lambda, something something bifunctors
15:49:39 <lexi-lambda> mniip: I only just figured out monads. D:
15:49:53 <monochrom> define "up op f g x = f x `op` g x". define "(---) = up (up (-))". then you're looking at "f --- g"
15:49:58 <paxcoder> If I need to first get items, then get properties of each one, how do I do that? I can't seem to figure out how to re-select from the resultset.
15:50:21 <monochrom> except that --- starts a comment and is not a legal operator
15:50:35 <mniip> monochrom, neat
15:50:45 <monochrom> I guess I will have to make do with ^-^
15:51:11 * paxcoder learns that it's illegal to be apathetic
15:51:41 <glguy>  liftA2 (liftA2 (-)) :: Num c => (a -> b -> c) -> (a -> b -> c) -> a -> b -> c
15:51:45 <glguy> <_<
15:52:00 <idem-pyon-tent> Guys, just wondering, why isn't Functor a superclass of Bifunctor?
15:52:12 <glguy> idem-pyon-tent: wrong kind
15:52:13 <idem-pyon-tent> And Profunctor.
15:52:28 <idem-pyon-tent> Oh.
15:52:59 <idem-pyon-tent> So it isn't possible to do something like "instance (forall a. Functor f a) => Bifunctor f" ?
15:54:00 <glguy> That'd be another kind error, but it isn't possible to write instance (forall a. Functor (f a)) => Bifunctor f, either
15:54:27 <idem-pyon-tent> Errr, yes, (f a).
15:54:29 <idem-pyon-tent> My bad.
15:55:02 <dicioccio1> i have some code generating a log of tokens using a Writer monad, and a Parsec to read-back the log of tokens into some more interesting structure. I feel like I should be able to combine both
15:55:42 <dicioccio1> do I miss something obvious like "use a comonad to parse while evaluating the computation that writes the log"?
15:56:42 <dicioccio1> (I'm exploring alternative designs for https://github.com/lucasdicioccio/deptrack )
15:56:57 <mniip> Tannen ((->) r) (->)
15:57:05 <mniip> hmm no (->) is not a binfuctor
15:57:12 <mniip> bifunctor
15:59:47 <mniip> oh wait
15:59:48 <mniip> wrong end
16:01:40 <dicioccio1> mniip: was it for me?
16:01:47 <ReinH> ttt_fff: wreq
16:01:49 <dicioccio1> (->) is profunctor
16:01:49 <mniip> no, lexi-lambda's problem
16:01:51 <ReinH> woops
16:01:57 <ReinH> ttt_fff: Sorry, I was scrolled up.
16:03:05 <lexi-lambda> mniip: I wrote my original code and moved on, but I'd still be pleased to know of a more elegant solution if it exists. ;)
16:03:16 <glguy> It best solution is to use that lambda or name it
16:03:37 <glguy> but the (liftA2 . liftA2) I mentioned works
16:04:21 <glguy> > let confuse = liftA2 . liftA2 in  confuse (-) max min 12 15
16:04:22 <lambdabot>  3
16:05:11 <paxcoder> tfw you don't even know how to ask proper questions about what you don't know
16:07:15 <dicioccio1> lexi-lambda: your proposed code looks beautiful already
16:07:58 <lexi-lambda> dicioccio1: It's fine, I was just curious if there was some ubiquitous function to make the composition more explicit.
16:07:59 <mniip> getCompose (liftA2 (-) (Compose max) (Compose min))
16:08:05 <mniip> simple and plain
16:08:11 <mniip> Compose ((->) a) ((->) b) r
16:08:30 <mniip> > getCompose (liftA2 (-) (Compose max) (Compose min)) 12 15
16:08:32 <lambdabot>  Not in scope: ‚ÄògetCompose‚ÄôNot in scope: data constructor ‚ÄòCompose‚ÄôNot in sco...
16:08:36 <mniip> aww shame
16:08:42 <Rc43> Does anybody know a good introduction to implementation of inductive types (dependent).
16:08:44 <Rc43> ?
16:08:46 <lexi-lambda> mniip: That's neat.
16:09:20 <SrPx> ReinH: hey... I understood the normal approach and the operational package approach, but I still don't quite get how free monads could be used for this... http://lpaste.net/124333 sorry for any additional stupidity 
16:09:25 <mniip> you can even get higher
16:09:57 <mniip> getCompose $ getCompose $ liftA2 (,) (Compose $ Compose (,,)) (Compose $ Compose (,,))
16:10:05 <mniip> who would you need that is a whole another question
16:10:24 <lexi-lambda> mniip: I'll stick with the first example, thanks
16:10:26 <lexi-lambda> haha
16:10:30 <SrPx> ReinH: that is, I understand how free monads can be used to build a tree-like datatype using the do notation... but how do I encode the notion of a return value so that "x <- foo" works... hmm
16:10:47 <ReinH> SrPx: that's built into the free monad construction
16:11:14 <ReinH> How it's built in depends on whether you use edwardk's free monad or the operational monad
16:11:55 <SrPx> Uh huh I mean the edwardk's free monad... the operational idea was well explained on that SO question
16:12:23 <SrPx> although nobody explained the differences but I guess I will get that when I manage it using free monads
16:12:28 <shachaf> Operational f is the same as Free (Coyoneda f)
16:12:54 <ReinH> shachaf: Ah, nice.
16:13:00 <ReinH> SrPx: Have you seen https://github.com/ekmett/free/blob/master/examples/Teletype.lhs "
16:13:13 <ReinH> SrPx: You can look at readLine
16:13:20 <dicioccio1> SrPx: your base functor encodes the "return value" as a "dependency for next action"
16:13:32 <ttt_fff> at what point in time
16:13:38 <ttt_fff> should I start splitting my haskell app into little cabal pckages ?
16:13:54 <ReinH> ttt_fff: when you have little libraries you can easily split off
16:14:00 <dicioccio1> then the eval function for your free monad has to "pass the value" that gets returned in x <- impurePrimitive
16:14:08 <SrPx> ReinH: that does it, thaaanks sz
16:14:13 <ttt_fff> ReinH: so it should be asap, rather than "when your brain can n olonger handle one monolotic cabal proejct" ?
16:14:41 <ReinH> ttt_fff: well, at least you should consider it.
16:14:56 <ReinH> There might be other tensions, like how well your team can manage lots of little packages
16:17:05 <paxcoder> Using hxt, how can I work on each (sub)tree individually? I want to select multiply items, and then apply some selectors to each one so as to end up with mutliple resultsets.
16:17:15 <paxcoder> *multiple
16:21:38 <ReinH> paxcoder: that sounds like fmap to me
16:23:52 <paxcoder> ReinH, How do I fmap? http://blogimg.ngfiles.com/167000/167593/878884359_Untitled_1.jpg
16:27:08 <SrPx> ReinH: that's awesome, I get it now! I'm in love with free monads right now
16:27:12 <ReinH> SrPx: :)
16:27:40 <SrPx> Haskell needs more examples. Examples for everything.
16:28:06 <rom1504> make an example generator
16:28:23 <ReinH> SrPx: Agree.
16:28:32 <SrPx> rom1504: but how? could you show an example
16:28:37 <rom1504> :D
16:29:13 <Lutin`> ReinH: github needs lhs support 
16:29:26 <johnw> SrPx: I have an example that uses both Free and FreeT, if you're interested
16:29:32 <ReinH> Lutin`: doesn't it have some?
16:29:46 <ReinH> johnw: yes pls
16:29:47 <Lutin`> I thought it used to
16:29:52 <johnw> https://github.com/jwiegley/linearscan-hoopl/blob/master/LinearScan/Hoopl/DSL.hs
16:29:59 <johnw> I'm using Free to record instructions for an Assembly DSL
16:30:08 <johnw> and FreeT to allow creating and reference to labels at entry/exit of the blocks
16:30:20 <ReinH> Lutin`: lhs is annoying because it uses the same extension for two completely different formats
16:30:32 <Lutin`> ah
16:30:37 <johnw> so the ultimate syntax tree is a FreeT with Free values hanging off it
16:30:49 <ReinH> johnw: heh
16:30:56 <SCHAAP137> made some music with Vivid
16:30:57 <SCHAAP137> http://paste2.org/cFCdnMWg
16:31:31 <johnw> here's what the use of it looks like for a sample assembly language: https://github.com/jwiegley/linearscan-hoopl/blob/master/test/Main.hs
16:32:01 <johnw> i'm comparing an assembly program that references variables, to the compiled version that now has registers allocated in place of variables
16:35:13 <paxcoder> ReinH, can you give an example? Let's say you have a doc which consists of multiple item tags. How do you "/> getText" of each item using fmap?
16:37:20 <ReinH> paxcoder: well I'm not sure if it's fmap, but it sounds like the kind of thing that fmap might do
16:37:52 <randir> How do I export a record in a module?
16:38:25 <paxcoder> :/
16:38:58 <HeladoDeBrownie> randir, if you want to export a type and all its constructors and fields, TypeName(..) in the export list will work. for specific things, TypeName(Constructor, field) etc.
16:41:27 <randir> HeladoDeBrownie: Thanks. 
16:45:35 * hackagebot simple-log 0.3.1 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.3.1 (AlexandrRuchkin)
16:50:11 <SrPx> Why `data Foo x = Foo (Bool -> x)`. Why is the functor instance for Foo `instance Functor Foo where { fmap f (Foo g) = Foo (f . g) }` ? I'd expect it to be `fmap f (Foo g) = Foo (f g)` ... 
16:50:43 <SrPx> s/Why/Consider/
16:50:47 <randir> What's the module naming convention?
16:50:57 <randir> Capital first letter, and same name as file?
16:51:32 <pacak> SrPx: Because function composition is (.).
16:51:38 <SrPx> as the entire file path afaik, so /Control/Foo/Bar.hs becomes `module Control.Foo.Bar` ... someone might correct me on this though
16:52:23 <SrPx> pacak: I know, but why? What if I have a list of functions and just want to map a high order function (such as applyTwice) to it?
16:52:58 <TeslaCuil> woo people
16:53:04 <arkeet> SrPx: look at the types
16:53:42 <arkeet> consider fmap :: (a -> b) -> Foo a -> Foo b, f :: a -> b, Foo g :: Foo a
16:53:49 <arkeet> what's the type of g?
16:53:57 <arkeet> and then how would you construct something of type Foo b?
16:54:53 <SrPx> arkeet: ...? fmap f (Foo g) 
16:55:02 <arkeet> we are trying to define fmap here.
16:55:09 <arkeet> fmap f (Foo g) = ?
16:55:18 <pacak> SrPx: You can have only one Functor instance for functions and it works by applying functions. If you want to do something with higher order functions - newtype and write your own instance. If that can be made info Functor.
16:55:45 <SrPx> fmap f (Foo g) = f g ... ? '-' wait
16:56:17 <arkeet> in "fmap f (Foo g) = ..."
16:56:21 <arkeet> what are the types of f and g?
16:56:38 <arkeet> and what is the type of the result?
16:56:54 <SrPx> :( f :: (a -> b), g :: a... result :: Foo b?
16:57:14 <arkeet> g is wrong
16:57:48 <arkeet> well, Foo g has type Foo a.
16:58:14 <arkeet> what type of thing does the Foo constructor take?
16:59:28 <arkeet> have another look at the definition of the Foo type.
16:59:44 <SrPx> ... I can only see it being `a` o.o guess I'm missing something obvious, wait
17:01:07 <SrPx> data Foo a = Foo a... so "Foo :: a -> Foo a" ... no?
17:01:08 <mniip> zonking everything by hand is much easier
17:01:18 <arkeet> that's not the definition I saw earlier.
17:01:54 <SrPx> oooh... my bad 
17:02:06 <SrPx> I didn't know you were refering to my Foo
17:02:19 <SrPx> thought you were explaining it in general. okay
17:02:24 * arkeet wonders whose Foo he could have been referring to.
17:04:57 <mniip> I wrote a Foo today too
17:05:23 <SrPx> Honestly I didn't remember I called my data "Foo" when i asked here. And I was anxious I was missing something obvious about the types lol. Okay, so `g :: Bool ‚Üí a` and.. hm
17:05:31 <arkeet> yes.
17:06:24 <Cale> randir: Yes
17:07:34 <randir> Cale: thanks
17:08:26 <SrPx> fmap f (Foo g) = Foo (f . g)... f :: a ‚Üí b, g :: Bool ‚Üí a... so the resulting thing is Foo b where b :: Bool ‚Üí b okay
17:08:58 <TeslaCuil> I am doing an assignment where I need to generate a list of triples that represent all bit strings of length 3
17:09:09 <TeslaCuil> like [(0,0,0),(0,0,1) etc]
17:09:35 <ReinH> TeslaCuil: what have you tried?
17:09:45 <TeslaCuil> and I need to do it using list comprehension
17:10:27 <TeslaCuil> I've been looking around trying to figure out the best way of doing this, and so far I havn't seen anyone do it with list comprehension
17:11:15 <TeslaCuil> they usually just import Numeric and use the showIntBase and intToBase functions
17:11:21 <ab9rf> TeslaCuil: list comprension or monad addition
17:11:23 <ReinH> TeslaCuil: well, here's a list of all single bits:
17:11:29 <ReinH> > [x <- [0,1]]
17:11:31 <lambdabot>  <hint>:1:4: parse error on input ‚Äò<-‚Äô
17:11:35 <ReinH> > [x | x <- [0,1]]
17:11:36 <lambdabot>  [0,1]
17:11:40 <arkeet> SrPx: yup :)
17:11:45 <SrPx> ty
17:12:02 <ReinH> And here's a list of all possible 2d6 roles:
17:12:07 <ab9rf> > [(x,y,z) | x <- [0,1], y <- [0,1], z <- [0,1]]
17:12:08 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
17:12:14 <ReinH> > [(a,b) | a <- [1..6], b <- [1..6]]
17:12:16 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
17:12:30 <HeladoDeBrownie> ab9rf, did you miss the part where they said it was an assignment?
17:12:33 <ReinH> ab9rf: Let's not just give away answers to homework questions please
17:12:35 <ab9rf> HeladoDeBrownie: yes :)
17:12:44 <ab9rf> sorry
17:13:09 <SrPx> I'm still upset though, I thought "deriving Functor" only worked when you had things like "data Foo a = Foo a | Bar a | Terminal | ...". So now I know "data Foo a = Foo (Something ‚Üí a)" works too. Next logical step is texting if (Something ‚Üí Something ‚Üí a) will work. hmmm
17:13:31 <TeslaCuil> I'm still getting used to the syntax
17:13:46 <arkeet> SrPx: deriving Functor works when you have nested Functors in your datatype
17:13:50 <TeslaCuil> I've only been using it for a day or so
17:13:55 <ReinH> SrPx: and ((->) r) is an instance
17:13:56 <arkeet> and (Something ->) happens to be a Functor
17:14:55 <ReinH> Here's a version you probably shouldn't use
17:14:57 <ReinH> > join (join (liftA3 (,,))) [0,1]
17:14:58 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
17:15:09 <arkeet> lol
17:15:28 <ab9rf> heh
17:15:47 <ab9rf> ReinH: i knew there was a way to do it like that, but wasn't sure what it was
17:15:56 <HeladoDeBrownie> note that join there uses the function instance
17:16:03 <arkeet> the joins there are just to abbreviate
17:16:09 <ReinH> I should probably say liftM3
17:16:09 <arkeet> > liftA3 (,,) [0,1] [0,1] [0,1]
17:16:10 <lambdabot>  [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
17:16:15 <TeslaCuil> so far, non of the code here does anything, because > is not a valid start
17:16:17 <arkeet> liftM3 does the same thing.
17:16:23 <ReinH> TeslaCuil:  it is for lambdabot
17:16:33 <TeslaCuil> ah
17:16:33 <TeslaCuil> I see
17:16:39 <arkeet> the > is just to get lambdabot to evaluate it.
17:16:48 <TeslaCuil> I see
17:16:49 <ReinH> arkeet: ofc, but I used join so prefer only one constraint until AMP lands.
17:17:04 <arkeet> ReinH: but we are working with a fixed type so it's ok.
17:17:07 <ReinH> s/so/so I
17:17:16 <ReinH> arkeet: perhaps
17:17:52 <SrPx> √µ.o
17:17:58 <HeladoDeBrownie> TeslaCuil, ignore the bit with the join and liftA3, it's mostly a distraction :P
17:18:04 <arkeet> > liftA3 (,,) [0,1] [4,5] [7,8]
17:18:06 <lambdabot>  [(0,4,7),(0,4,8),(0,5,7),(0,5,8),(1,4,7),(1,4,8),(1,5,7),(1,5,8)]
17:18:11 <arkeet> agreed.
17:18:13 <TeslaCuil> yeah
17:18:16 <HeladoDeBrownie> in fact can we have less lambdabot noise in here?
17:18:17 <ReinH> In some language you could define an n-ary join that takes m^n -> m for any n >= 0, I suppose
17:18:18 <TeslaCuil> didn't work anyway :p
17:18:20 <TeslaCuil> not in scope
17:19:13 <TeslaCuil> bla
17:19:27 <HeladoDeBrownie> TeslaCuil, feel free to ask for help if you're running into problems
17:20:26 <TeslaCuil> I got some code to work in the command prompt
17:20:34 <TeslaCuil> but I can't get it to work in a function
17:21:02 <TeslaCuil> not in scope "bitstringthree" perhaps you mean bitstringthree?
17:21:31 <HeladoDeBrownie> TeslaCuil, show what you tried
17:21:39 <HeladoDeBrownie> use http://lpaste.net/new/haskell
17:21:45 <TeslaCuil> bitstringsthree using list comprehension = [(x,y,z) | x <- [0,1], y <- [0,1], z <- [0,1]]
17:22:03 <HeladoDeBrownie> is that literally the code you executed?
17:22:17 <TeslaCuil> yeah
17:22:27 <HeladoDeBrownie> well, you can't put spaces in the names of things
17:22:41 <HeladoDeBrownie> spaces are used (mostly) for separating things from their arguments
17:23:05 <TeslaCuil> I also tried just bitstringsthree = [(x,y,z) | x <- [0,1], y <- [0,1], z <- [0,1]]
17:23:28 <HeladoDeBrownie> you've said both bitstringthree and bitstringsthree. which is it?
17:23:45 <TeslaCuil> XD
17:24:01 <HeladoDeBrownie> this is one reason it's important to copy the error message verbatim rather than retype it yourself
17:24:08 <TeslaCuil> did not see that little detail
17:24:57 <TeslaCuil> ok, that works'
17:25:08 <TeslaCuil> and I think I understand what it's doing
17:26:03 <ReinH> Computers are kind of a stickler for detail.
17:27:33 <TeslaCuil> btw that was only the last question. Managed to get the rest by myself
17:27:47 <HeladoDeBrownie> good
17:29:45 <rui1> I am wondering
17:30:05 <rui1> class C a => S a where (f :: a -> a)
17:30:19 <rui1> class C a => S a where (f :: C a => a -> a)
17:30:26 <rui1> class S a where (f :: C a => a -> a)
17:30:29 <TeslaCuil> thanks for your help!
17:32:00 <arkeet> rui1: what is the question?
17:32:45 <rui1> arkeet: Those all seem to compile. Is there a clear difference? Is there an obvious favourite?
17:33:57 <HeladoDeBrownie> rui1, partly guessing, the first two will require the C a instance to be present where that's defined; the latter two will require it to be present at the use site.
17:34:03 <arkeet> rui1: the second does the same thing as the first, the extra C a is redundant.
17:34:21 <arkeet> consider the type of f in each case.
17:34:26 <arkeet> in the first two, f :: S a => a -> a
17:34:31 <arkeet> the last one is f :: (C a, S a) => a -> a
17:34:43 <Cale> I vote for #1, since in #2, the class constraint on the method is redundant, and in #3, you would never be able to use an instance of S for a type that didn't have an instance of C, but the compiler would let you get away without writing one.
17:34:56 <arkeet> pretty much that.
17:36:21 <rui1> Thanks! (reading your answers and processing)
17:39:42 <ReinH> What Cale said.
17:42:17 <randir> I have a module Foo
17:42:21 <randir> in file Foo.hs
17:42:31 <randir> but if I open ghci in that dir, I can't "import Foo"
17:42:37 <randir> why not? What should I do instead?
17:43:18 <rui1> randir I usually do :load Foo.hs  (but I am new at this)
17:43:33 <arkeet> yes, you should do that.
17:43:38 <arkeet> or :l Foo
17:43:45 <ReinH> or :m+ Foo
17:43:53 <arkeet> does that work?
17:43:57 <ReinH> Perhaps.
17:44:10 <arkeet> I thought import in ghci basically did the same thing as :m +
17:44:10 <randir> it works
17:44:24 <ReinH> randir: :m+ ?
17:44:27 <randir> :l
17:44:30 <ReinH> Oh.
17:44:31 <randir> gonna try the other now
17:45:36 <ReinH> Well, :l works, so use that
17:45:38 <randir> ::m+
17:46:00 <randir> yeah. I wonder why import doesn't?
17:46:26 <randir> can I load qualified?
17:47:49 <randir> using :l
17:47:59 <arkeet> I don't believe so.
17:48:38 <randir> k
17:49:30 <HeladoDeBrownie> i always found non-trivial circumstances painful with `cabal repl`
17:49:33 <HeladoDeBrownie> without*
17:50:52 <ReinH> HeladoDeBrownie: Yeah, but it isn't *that* hard to put stuff in a cabal file
17:51:07 <idem-pyon-tent> Would it be correct to explain free monads as "uninterpreted effectful languages", and monad morphisms from these as "type-safe eval functions"?
17:51:22 <HeladoDeBrownie> ReinH, what do you mean "but"? what i said would likely agree with that
17:52:01 <ReinH> HeladoDeBrownie: Ok. "Yeah, and it isn't *that* hard to put stuff in a cabal file"
17:52:01 <HeladoDeBrownie> idem-pyon-tent, you lost me at "effectful languages".
17:52:14 <HeladoDeBrownie> idem-pyon-tent, which is to say, i disagree.
17:52:17 <idem-pyon-tent> Oh.
17:52:35 <ReinH> idem-pyon-tent: I can see what you're getting at, but at best that might be an interpretation of one thing that you can use free monads for
17:52:40 <HeladoDeBrownie> Monad does not have to do with effects. specific types that have Monad instances can be used to represent effects, however.
17:53:25 <HeladoDeBrownie> idem-pyon-tent, however, i would say the intuition of "languages that can be interpreted" is okay.
17:54:09 <idem-pyon-tent> HeladoDeBrownie: Yeah, I see your point... if anything, the effects are in the interpreter side, not in the language itself.
17:54:54 <HeladoDeBrownie> as for "type-safe eval functions", i'm not sure what you're saying with "type-safe" that isn't already implicit in the presence of a type system; and also that if by "eval function" you mean "interpreter", i suppose that might be one way to *use* monad morphisms, anyway.
17:55:09 <HeladoDeBrownie> idem-pyon-tent, that's probably closer to the truth, i think, yeah.
17:55:59 <HeladoDeBrownie> however, an interpreter for a free monad need not have any effects.
17:56:02 <idem-pyon-tent> HeladoDeBrownie: The reason why I'm adding "type-safe" is that the people I'm going to talk to are only used to eval as in JavaScript's eval.
17:56:14 <ReinH> idem-pyon-tent: Best to not call it "eval" at all
17:56:33 <ReinH> No point in bringing up incorrect associations
17:56:34 <Welkin> poynter!
17:56:41 <Welkin> oh
17:56:48 <Welkin> that is someone's nickname
17:57:20 <Welkin> I thought it was a satirical discussion of idempotence
17:57:32 <idem-pyon-tent> lol
17:58:40 <ReinH> wat
17:59:33 <idem-pyon-tent> ReinH: If "eval" ever comes up, how should I establish a distinction between "eval" and "interpreter"?
18:01:21 <ReinH> eval can do anything the host language can do
18:01:55 <ReinH> "interpreting" a free monad restricts you to type-safe transformations of values that inhabit the type in question
18:02:05 <idem-pyon-tent> Ah, okay, so "eval" is just one particular kind of interpreter, then, right?
18:02:58 <idem-pyon-tent> (And, in this case, a kind of interpreter we don't want to use.)
18:02:58 <koala_man> I would require that eval interprets the code in the same context as the call to eval
18:03:12 <gregnwosu> hello i would like some feedback on my haskell program, whats the best way ,via github, lpaste? haskell cafe?
18:03:32 <Hijiri> lpaste for short things, github or some other repo for longer things, I think
18:03:44 <HeladoDeBrownie> gist is also usually an acceptable substitute for lpaste
18:04:00 <lispy> github is nice when there is a cabal file involved
18:04:21 <gregnwosu> yes , i would like there to be a permanent record of comments , rather like comments on a github PR
18:04:22 <arkeet> I like gist
18:04:35 <gregnwosu> will gist allow people to comment on lines?
18:04:43 <HeladoDeBrownie> afair yes
18:04:56 <HeladoDeBrownie> but they may need github accounts unfortunately
18:04:56 <arkeet> I'm not aware of any comment thing in gist though.
18:05:06 <HeladoDeBrownie> arkeet, you can definitely leave comments on gists
18:05:12 <HeladoDeBrownie> but the above restriction may apply
18:05:19 <arkeet> oh I guess you can.
18:05:23 <arkeet> not inline though.
18:05:35 <gregnwosu> one last thing, where should i ask, haskell cafe? irc? reddit?
18:05:45 <HeladoDeBrownie> here is fine, or reddit. i don't know what haskell cafe is so can't say
18:05:53 <gregnwosu> mmmm would really like inline comments
18:06:18 <HeladoDeBrownie> inline comments are possible in commits for github repos
18:06:29 <HeladoDeBrownie> lpaste allows annotations
18:06:40 <gregnwosu> think that may be the way to go HeladoDeBrownie 
18:06:51 <gregnwosu> oooh lpaste eh?
18:06:56 <HeladoDeBrownie> an annotation is just some text that gets attached to the paste though, but it can contain the code in question plus comments
18:06:57 <Hijiri> HeladoDeBrownie: haskell-cafe is the mailing list
18:06:59 <arkeet> oh it sounds like gist actually can.
18:07:28 <HeladoDeBrownie> Hijiri, thanks
18:07:44 <arkeet> wait, that's not gist. just github
18:08:10 <gregnwosu> sounds like gist is out , k i will choose between github and lpaste
18:08:17 <arkeet> mailing list is also an option.
18:08:25 <arkeet> depending on the level, haskell-beginners might be more appropriate.
18:08:39 <Axman6> just paste the damn code, give us a link and we'll give you comments here, like a notmal person =)
18:08:44 <arkeet> heh
18:09:49 <arkeet> agreed, just throw it up on lpaste or gist or whatever and link it here.
18:14:41 <meretrix> I'm trying to store my application's state in a nested ADT using the State monad, but it seems very difficult to update values.
18:14:45 <gregnwosu> ok coming up
18:14:49 <meretrix> Example: http://lpaste.net/124338
18:15:18 <ion> meretrix: You might benefit from lens.
18:15:21 <meretrix> The function to update the order qty should be very simple, but it gets very messy with the record syntax.
18:15:32 <meretrix> Yeah, I was hoping to avoid lens..
18:15:38 <ion> Why?
18:15:38 <acowley> meretrix: This is lens's sweetspot
18:15:45 <acowley> meretrix: Consider lens-family-core
18:16:36 <Axman6> yeah this is literally what lens was invented for
18:17:10 <meretrix> Ugh ok.. I guess I'll finally give in and learn lens.
18:17:27 <pacak> meretrix: This is probably the worst channel to be on if you want to avoid lens.
18:17:28 <meretrix> It just seems very un-functional to me.
18:17:39 <acowley> You don't need to learn all of the lens package
18:17:48 <pacak> Hmmm... Actually no, there's one even worse, right below... #haskell-lens
18:17:52 <meretrix> So start with lens-family-core?
18:17:55 <bitemyapp> lens is pretty easy to learn in a piecemeal fashion as acowley 
18:18:10 <acowley> meretrix: lens-family-core is just smaller
18:18:14 <bitemyapp> I don't think using something other than `lens` is the answer. You can learn one operator/lens/module at a time.
18:18:17 <acowley> meretrix: But compatible with lens
18:23:10 <octalsrc> I'm doing some Natural Language Processing things
18:23:24 <octalsrc> specifically with frequency lists of character tri-grams
18:24:10 <octalsrc> would it make more sense to represent these lists as [(Text, Int)]
18:24:13 <octalsrc> or,
18:24:17 <lpaste> gregnwosu pasted ‚Äúrefactorings and style suggestions please‚Äù at http://lpaste.net/124339
18:24:21 <jle`> meretrix: lens actually makes this simple to a degree of ridiculous
18:24:35 <ion> meretrix: Un-functional?
18:24:38 <octalsrc> [((Char,Char,Char), Int)] ?
18:25:13 <acowley> octalsrc: Create a trigram data type, give it an Ord instance, stick it in a Map
18:25:59 <gregnwosu> ive posted the code on lpaste, its sanatised as its a webscraper, just want ideas on how to distill it a bit more
18:26:08 <octalsrc> acowley: sure, but should I use Text or (Char,Char,Char) ?
18:26:17 <octalsrc> with performance in mind?
18:26:41 <acowley> octalsrc: I'd start with data Trigram = Trigram Char Char Char
18:26:47 <pacak> octalsrc: Pack those into Int if you want performance.
18:27:04 <acowley> pacak: That might not be possible
18:28:00 <acowley> But, I agree with pacak if you know exactly how much space you need for each character (e.g. ASCII)
18:28:24 <pacak> acowley: If you are dealing with Chinese or other long unicode then yes - it won't fit as it is (but even then there are tricks possible), for most languages it should fit.
18:29:16 <octalsrc> okay thanks
18:30:39 <gregnwosu> octalsrc: if you create a Trigram type and a function to create a Trigram perhaps you can hide how its constructed
18:31:03 <gregnwosu> which will enable you to play with different representations
18:31:25 <acowley> Yeah, it's just that programmers have a tradition of prematurely optimizing representations of text :)
18:32:34 <gregnwosu> any comments on my lpaste?
18:32:53 <octalsrc> gregnwosu: oh yeah, I will probably due that
18:32:58 <octalsrc> *do
18:34:05 <HeladoDeBrownie> s/ representations of text//
18:34:19 <HeladoDeBrownie> (i know, especially text :P)
18:35:18 <lpaste> arkeet annotated ‚ÄúNo title‚Äù with ‚ÄúNo title (annotation)‚Äù at http://lpaste.net/124338#a124340
18:35:28 <arkeet> meretrix: ^
18:35:38 <pacak> octalsrc: Start with newtype Trigram = Trigram Char Char Char, but don't expose the constructor. As soon as you see it's too slow - start packing it into Int.
18:35:43 <acowley> gregnwosu: Setting aside low-level quibbling, I'd factor asAction into helper functions as it's too spread out at the moment
18:35:57 <acowley> That's not a valid newtype, though :(
18:36:11 <pacak> (Char,Char,Char)
18:36:24 <gregnwosu> acowley: thanks
18:36:45 <gregnwosu> acowley: low level quibbles are appreciated too
18:36:57 <acowley> Yeah, the reason I'd do a data type straight off is that the first optimization I'd try is to make the fields strict
18:37:19 <arkeet> meretrix: the thing you were trying to do is pretty much exactly one of the things lens aims to help with.
18:38:11 <arkeet> also augh tabs.
18:38:19 <acowley> gregnwosu: I would also pull some of the let bindings into a where clause if possible (e.g. connData in negotiate)
18:38:23 <arkeet> serves me right for not using my usual editor.
18:39:13 <acowley> gregnwosu: The minor quibbling stuff is something like 'url ="https....' where the spacing is inconsistent. But I'd also pull that definition into a where
18:39:13 <homovitruvius> is there any package that replace the IO monad so that file contents are served from a map where keys are hierarchical file names? is such a thing even possible? I'd love to have such a thing for testing
18:39:42 <gregnwosu> cool yes , i think the where clauses there will tidy it a lot
18:39:47 <acowley> homovitruvius: Use operational or a free monad to provide the file IO interface you want
18:40:04 <shachaf> Or some other monad, or some other thing which isn't a monad.
18:40:06 <acowley> homovitruvius: Then run it against whatever backend you want (normal IO or a Map)
18:40:18 <acowley> Yes
18:40:48 <gregnwosu> arkeet: i think using state monad to represent stateful computation on an order book is valid, not sure if lens really fits here
18:41:24 <acowley> gregnwosu: Something that folks disagree on would be in initialState, if you write it "S.withSession $ \sess -> do" you can avoid the closing parenthesis at the end
18:41:44 <arkeet> gregnwosu: lens is perfect for getting your hands on deeply nested structures in a state.
18:41:47 <acowley> gregnwosu: Which I prefer doing, but some folks like using parentheses instead. I just prefer to use whitespace for long-distance scoping rather than parens
18:42:10 <gregnwosu> arkeet: agreed
18:42:28 <arkeet> compare the big 4-line mess that meretrix was using before.
18:43:58 <xpilot> hello; HList question here
18:44:30 <acowley> The answer will involve a type family
18:44:55 <xpilot> why doesn't this work: hMap f (1 .*. "one" .*. HNil) where f x = [x]
18:45:27 <xpilot> (doesn't typecheck)
18:45:30 <acowley> Little Bobby Monobinds
18:45:40 * hackagebot prednote 0.32.0.0 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.32.0.0 (OmariNorman)
18:45:51 <arkeet> xpilot: because the same f gets mapped over all the elements.
18:45:51 <acowley> xpilot: Can you try giving f a type signature?
18:46:12 <arkeet> and I guess it wasn't made polymorphic enough.
18:46:21 <xpilot> uh, ok
18:46:29 <arkeet> yes try that.
18:46:30 <acowley> Also, I am disappointed my preemptive answer was wrong
18:46:35 <arkeet> haha
18:47:56 <xpilot> doesn't help to give f :: a -> [a]
18:48:02 <xpilot> (same error)
18:48:12 <xpilot> maybe give the resulting value a type?
18:48:13 <arkeet> where did you give it.
18:48:19 <xpilot> top-level
18:48:21 <arkeet> try hmap (f :: a -> [a]) (...)
18:48:28 <xpilot> f :: a -> [a]; f = return
18:49:31 <arkeet> otherwise it tries to instantiate f at a monomorphic type and it won't work.
18:49:33 <arkeet> I think.
18:50:10 <xpilot> well, it doesn't help :(
18:50:18 <xpilot> maybe some foralls are needed?
18:50:24 <arkeet> nah.
18:50:27 <xpilot> although they should be implicit afaik
18:50:28 <arkeet> what's hmap exactly, anyway
18:50:30 <HeladoDeBrownie> what's the actual error?
18:50:40 <xpilot> Couldn't match type ‚ÄòInt‚Äô with ‚Äò[Char]‚Äô
18:50:52 <HeladoDeBrownie> give the full error message and the code that causes it, in an lpaste
18:50:59 <xpilot> ok
18:51:01 <acowley> installing hlist
18:51:23 <HeladoDeBrownie> (i'm not familiar with hlist either, but this is the thing to do when asking for help with an error)
18:51:45 <arkeet> the first example in http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HList.html#v:hMap
18:51:48 <arkeet> suggests that this can be done.
18:52:04 <lpaste> xpilot pasted ‚ÄúhMap error‚Äù at http://lpaste.net/124342
18:52:11 <arkeet> wait, what's HJust/.
18:53:24 <xpilot> I'm not sure
18:56:11 <xpilot> arkeet: but it appears that it has some instances
18:58:27 <acowley> I guess none of us know how to use HList
18:59:19 <meretrix> arkeet: Thanks, just saw your paste.. ok I guess that is pretty cool.
18:59:27 <meretrix> still feels dirty :/
19:00:39 <acowley> "feels dirty" is just a phase
19:01:09 <xpilot> acowley :(
19:01:28 <arkeet> ok hlist is just getting me confused. heh
19:01:30 <xpilot> arkeet: hMap is map for heterogenous lists
19:01:35 <acowley> xpilot: You can look at mapMono and mapMethod that Frames provides as extensions to vinyl!
19:01:37 <arkeet> evidently.
19:03:17 <acowley> xpilot: They are defined here https://github.com/acowley/Frames/blob/master/src/Frames/RecF.hs#L97 and here https://github.com/acowley/Frames/blob/master/src/Frames/RecF.hs#L112
19:03:40 <acowley> xpilot: But neither would work for your example :/
19:03:49 <acowley> xpilot: But
19:03:54 <acowley> regular vinyl mapping would I think
19:04:03 <acowley> You have a natural transformation from Identity to []
19:04:26 <xpilot> what is vinyl? an hlist alternative?
19:04:38 <acowley> xpilot: Yes
19:04:39 <ab9rf> how does map work on heterogenous lists?
19:05:00 <arkeet> acowley: so how do you get the Identity in there?
19:05:07 <ab9rf> that would require the function being mapped to be polymorphic
19:05:07 <acowley> Yeah, vinyl's rmap
19:05:19 <xpilot> acowley: I see, will check it out
19:05:20 <SrPx> btw if someone ever comes asking the same thing I did yesterday, that is what I'm looking for : http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
19:05:35 <SrPx> specifically, "The above rewrite concentrates all of the impure code within the run function. I like to call this process "purifying the code" because we distill out all of the program's logic into pure code leaving behind only the bare minimum impure residue in our run interpreter."
19:05:46 <SrPx> I'm glad free monads worked so well. :)
19:05:56 <ab9rf> monads just want to be free
19:06:19 <ski> ab9rf : i suppose you could have something like `(forall a. F a -> G a) -> ([exists a. F a] -> [exists a. G a])'
19:06:51 <acowley> arkeet: It looks like we lost some syntax for making that nicer
19:06:55 <ab9rf> ski: i suppose, but that sort of thing makes my earlobes itchy
19:07:00 <ski> why ?
19:07:05 <acowley> arkeet: You'd have to do pure 1 :& pure "one" :& RNil
19:07:12 <ski> (also, it's not clear what you mean by "heterogenous lists")
19:07:27 <ab9rf> ski: someone else brought them up
19:07:37 <ski> ic
19:07:56 <shachaf> I think people are talking about HList.
19:10:52 <darkroom> is it possible to make a generic zip function that works on any foldable?
19:11:26 <shachaf> That depends on what you want it to do.
19:12:18 <arkeet> you can take two foldables, turn them into lists, and then zip them.
19:12:22 <arkeet> but maybe that's not what you want.
19:12:42 <darkroom> I was just thinking no goal in mind
19:12:56 <arkeet> Applicative contains some generalization of zip.
19:13:18 <darkroom> arkeet: is ziplist what youre thinking off
19:13:28 <arkeet> ZipList just witnesses that it's a generalization.
19:31:16 <chao-tic> \quit
19:31:26 <mniip> is there a way to provide a default implementation for values whose type signatures are specified but that aren't otherwise defined
19:32:18 <ab9rf> so, what if i say a :: Int but never give a a value, it'll be 0?
19:32:48 <mniip> nah more like 'fix id' or 'error "boo"'
19:32:53 <Axman6> mniip: foo :: a -> b; foo = undefined
19:33:27 <Axman6> a better choice is error "Something descriptive", but undefined kind of exists for that purpose
19:33:40 <jle`> usually we say undefined if we intend on filling it in later
19:33:54 <jle`> ghc uses let x = x in x
19:34:12 <mniip> jle`, that's because undefined isn't available at that point
19:34:13 <jle`> but only because it doesn't want to use functions from a module probably
19:34:21 <jle`> yeah i'm just giving another option
19:34:28 <Axman6> well, it uses that when the implementation is defined elsewhere as a primop or something
19:34:44 <jle`> it uses it to just give a dummy value that fits any type
19:34:50 <jle`> the same reason we use `undefined`
19:34:56 <ab9rf> :t let x = x in x
19:34:56 <lambdabot> t
19:35:32 <jle`> :t [Maybe True, Nothing, let x = x in x]
19:35:32 <lambdabot> Not in scope: data constructor ‚ÄòMaybe‚Äô
19:35:38 <jle`> :t [Just True, Nothing, let x = x in x]
19:35:39 <lambdabot> [Maybe Bool]
19:51:36 <mniip> how can I make a typeclass accept a (* -> Constraint) as an argument
19:52:00 <mniip> class Foo a b
19:52:00 <arkeet> what did you try, and how did it fail?
19:52:00 <mniip> instance a b => Foo a b
19:52:03 <mniip> doesn't seem to work
19:52:08 <shachaf> Just write the class.
19:52:08 <mniip>     Expecting one more argument to `a'
19:52:25 <arkeet> you need to specify the kind in the class definition.
19:52:27 <shachaf> You might need to specify a kind signature if the class doesn't have any methods.
19:52:31 <arkeet> yeah.
19:52:44 <arkeet> ConstraintKinds extension, and import GHC.Exts
19:52:47 <arkeet> er
19:52:52 <arkeet> also KindSignatures.
19:52:53 <mniip> ohh
19:53:03 <arkeet> class Foo (a :: * -> Constraint) b where
19:53:08 <arkeet> etc
19:53:26 <mniip> yeah that works thanks
19:53:27 <shachaf> Another thing you could do is turn on PolyKinds.
19:54:38 <ski> mietek : btw, i'm not sure if i have any archived copy of it (or parts of it) ..
19:54:51 <ski> mniip : were you looking for me, a couple of days ago ?
19:55:13 <mniip> yeah
19:55:17 <mniip> nothing serious though
19:55:22 <ski> just curious
19:56:41 <mietek> ski: oh hi
20:00:43 <ski> hmm
20:00:45 <ski> @where Charity
20:00:45 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
20:02:00 <ski> mietek : i suppose you already tried links from that one, yes ?
20:07:13 <mietek> Yep
20:07:15 <mietek> All the FTP links are gone
20:07:23 <mietek> I was able to find most of the papers mirrored
20:07:33 <mietek> But I can‚Äôt find any of the example code (.ch files)
20:08:12 <mietek> ski: would be totally cool if you had those
20:08:22 <mietek> Otherwise I‚Äôll be emailing the authors soon
20:08:26 <mietek> Haven‚Äôt yet gotten around to it
20:09:36 <ski> i may have the implementation and some example files lying around somewhere. not sure
20:12:40 <mietek> The implementation and some papers are mirrored at https://synrc.com/publications/cat/Functional%20Languages/Charity/
20:13:14 <mietek> The implementation is also probably at http://pll.cpsc.ucalgary.ca/charity1/tmp/
20:13:46 <mietek> There are a few examples in http://pll.cpsc.ucalgary.ca/charity1/misc/examples/
20:13:50 <mietek> But not all listed on the webpage
20:16:27 <ski> i have a vague recollection of downloading the examples at <http://pll.cpsc.ucalgary.ca/charity1/www/examples.html>
20:20:43 * hackagebot unbound-generics 0.0.3 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.0.3 (AlekseyKliger)
20:27:47 <echo-area> lispy: I think I am following your steps, to switch from LISP to Haskell
20:29:53 <funfunctor> hi
20:30:48 <homovitruvius> earlier I asked for a library that served IO file actions from a "virtual filesystem" kept in a map. This for testing. Unfortunately I had to leave just after porting. acowley suggested to use operational or a free monad, but that is a bit too cryptic for me. I've found the following stackoverflow question http://stackoverflow.com/questions/7370073/testing-functions-in-haskell-that-do-io, and some of the answers are in the di
20:30:48 <homovitruvius> what I was thinking. Anybody could comment on how operational would fit? just help in writing the IO replacement monad or am I missing something?
20:31:42 <shachaf> The suggestions were all along the same lines, namely, find some non-IO way of expressing your intended actions and then write a function that turns that description into IO.
20:32:04 <idem-pyon-tent> Instead of manually making functor instances for every bifunctor, couldn't something like "instance Bifunctor f => Functor (f a) where map = second" work?
20:32:14 <idem-pyon-tent> Similarly for every profunctor.
20:32:14 <ski> echo-area : which Lisp(s) ?
20:32:27 <idem-pyon-tent> Errr, s/map/fmap/
20:32:33 <shachaf> A free monad is one approach. There are also other approaches.
20:32:34 <ski> idem-pyon-tent : overlap
20:32:48 <shachaf> idem-pyon-tent: No, because it would overlap with everything else with the shape (f a)
20:33:09 <shachaf> For instance if something is both Bifunctor and Profunctor, you wouldn't know which instance to use.
20:33:24 <idem-pyon-tent> That would be something that ignores its next-to-last type argument, right?
20:33:34 <shachaf> Yes.
20:34:01 <idem-pyon-tent> Well, then we can prove that the overlapping instances agree.
20:34:35 <shachaf> Yes. But GHC doesn't know that.
20:34:59 <shachaf> And can you prove that it works for every possible class?
20:35:10 <shachaf> Well, OK, you can in this case, because Functor instances are unique.
20:35:51 <shachaf> But this is a general problem.
20:36:09 <idem-pyon-tent> Mmm...
20:39:45 <SrPx> How do I simplify (m >>= (\x ‚Üí f x k)) using applicative?
20:40:00 <lispy> echo-area: I have steps for that?
20:40:39 <lispy> echo-area: or do you just mean generally making a transition? (I thought you were referencing an article)
20:40:46 <pacak> SrPx:  m >>= f x
20:40:49 <mmachenry> SrPx: I think it's m >>= flip f
20:40:58 <echo-area> lispy: You told me you came from LISP, IIRC
20:41:05 <lispy> indeed :)
20:41:06 <echo-area> Or I may be wrong :)
20:41:06 <mmachenry> I mean m >>= flip f k
20:41:29 <echo-area> lispy: That's what I'm trying to do now
20:41:57 <SrPx> pacak: hm that sounds wrong
20:42:07 <SrPx> but I mean using <$> and <*>
20:42:18 <lispy> echo-area: I hope you enjoy it. It's been good to me.
20:42:45 <ski> SrPx : the answer is no
20:43:00 <mmachenry> SrPx: Doesn't m >>= flip f k work?
20:43:20 <ski> SrPx : in general, for any `m' and `f', it can't be done. if you tell us more about `m', and `f', then perhaps
20:44:18 <echo-area> lispy: Yeah, pretty good.  I noticed this progress when I found that the program I wrote down on the paper was actually in Haskell's syntax several days ago
20:44:32 <SrPx> ski: uh interesting... how did you know that, though? mmachenry nope :( mmachenry yep works
20:44:37 <ski> SrPx : .. of course (possibly not obvious ?), you can rewrite it using `<*>' and `<$>', if you also allow `join' .. but that's not what you asked about
20:44:48 <SrPx> ah
20:45:25 <ski> the general thing you asked about is inherently using the full monadic power, can't be expressed solely using the idiomatic/applicative operations
20:45:45 * hackagebot wai-middleware-throttle 0.2.0.0 - WAI Middleware for Request Throttling  http://hackage.haskell.org/package/wai-middleware-throttle-0.2.0.0 (ChristopherReichert)
20:45:56 <SrPx> ski: so, join $ f <$> m <*> return k ?
20:46:08 <heatsink> It would be nice if applicatives had do-like syntax.
20:46:24 <lispy> echo-area: heh, nice. I like that the types make it easier to refactor my code later after it's not in my brain.
20:46:26 <SrPx> interesting... how did you know I needed the full monadic power, though?
20:46:44 <ski> SrPx : yes, or just  join ((`f` k) <$> m)
20:47:02 <SrPx> clever
20:47:07 <chirpsalot> heatsink: sounds like something that could have been stuffed in AMP? I think Idris does interesting things with do notation.
20:47:10 <ski> SrPx : because you didn't use `>>=' in one of the more restricted ways
20:47:26 <ski> @hackage applicative-quoters
20:47:26 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
20:47:41 <ski> heatsink ^
20:48:13 <heatsink> cool
20:48:26 <ski> (thank Philippa)
20:49:50 <ski> echo-area : .. ooc, which paper ?
20:52:53 <lpaste> funfunctor pasted ‚ÄúNo title‚Äù at http://lpaste.net/124350
20:53:24 <funfunctor> hi, I am a little stuck on a problem in the above module
20:53:52 <funfunctor> how can I translate a Word32 back into an array of flags defined by the data BladeRFGPIOFlags
20:54:54 <sgronblo> Does the Haskell community seem to have preference when it comes to fmap vs liftM?
20:55:06 <jle`> sgronblo: fmap whenever possible
20:55:11 <jle`> liftM only when forced to
20:55:25 <jle`> within a month or so, there will no longre be situations where we need liftM
20:55:56 <funfunctor> jle`: is that when all monads become Functor instances or something?
20:55:58 <nitrix> How does Ada compare to Haskell? I asked a couple haskellers few weeks ago what would be the next logical step on their list to learn and that suggestion came up multiple times. I realise this isn't the place to ask, but if some of you mind sharing your opinion, using Haskell as a reference?
20:56:15 <jle`> funfunctor: it is when functor is a superclass of monad
20:56:16 <heatsink> funfunctor: Do you want an array of flags, or a list of flags?
20:56:46 <ski> funfunctor : btw, i'd not use `Show' in that way
20:57:07 <funfunctor> heatsink: how do you mean? [] being "array" here but I guess list yea
20:57:13 <funfunctor> ski: why not?
20:57:40 <heatsink> funfunctor: You could use a list comprehension to build a list containing only the flags whose corresponding bit in the Word32 is set
20:58:15 <ski> funfunctor : because `Show' is meant for outputting a string representation of a Haskell expression that when evaluated in the appropriate environment will yield a value equal to the original
20:58:23 <funfunctor> heatsink: ok.. that sounds about right, how would I do that? [x | x <- ??]
20:59:08 <heatsink> wordToFlags w = [x | x <- list_of_all_flags | bit_is_set w x]
20:59:17 <funfunctor> ski: yea I am abusing Show I guess
20:59:25 <ski> funfunctor : e.g., if you have a `[BladeRFGPIOFlags]', and have it (implicitly) `show'n as a result (or part of it) in an interactor (such as GHCi), then you'll get a weird mix of Haskell syntax and english
20:59:48 <ski> heatsink : s/| bit/, bit/
20:59:49 <heatsink> Uh, that second | should be a ,
21:00:33 <funfunctor> ski: yea true, I guess i'll remove it once I used it to debug..
21:01:18 <ski> funfunctor : you could always make your own custom function for outputting a description of what the flag in question controls. just don't name it `show'
21:02:17 <funfunctor> sorry heatsink I didn't understand to pseudo code so well, wordToFlags w = [x | x <- list_of_all_flags, bit_is_set w x]    bit_is_set is a lambda expression of some kind?
21:02:43 <heatsink> it is a function call with two arguments
21:02:45 <ski> presumably you're to write `bit_is_set w x'
21:03:13 <funfunctor> list_of_all_flags is a comma delimited list or?
21:03:33 <funfunctor> the list is fairly long as you can see from the past
21:04:18 <heatsink> You can derive Enum when defining the data type
21:04:38 <heatsink> and then write [minBound..]
21:04:55 <ski> (if you also derive `Bounded')
21:04:57 <heatsink> it's like [1..], but for your data type
21:05:16 <heatsink> ah, I forgot about Bounded
21:05:23 <heatsink> > [True..]
21:05:24 <lambdabot>  <hint>:1:8: parse error on input ‚Äò]‚Äô
21:05:28 <funfunctor> I already have a custom Enum instance to map the type members to the C #define's
21:05:34 <heatsink> > [True .. ]
21:05:35 <lambdabot>  [True]
21:05:40 <heatsink> > [False .. ]
21:05:41 <lambdabot>  [False,True]
21:06:34 <heatsink> [x..] is syntactic sugar for enumFrom x
21:06:55 <ski> funfunctor : should be equivalent to what heatsink suggested, since you're not using any weird numbering
21:07:11 <heatsink> So if you defined enumFrom, you should be fine
21:07:37 <funfunctor> heatsink: so I need  wordToFlags w = [x | x <- enumFrom w, bit_is_set w x] ?
21:08:04 <heatsink> not enumFrom w
21:08:32 <funfunctor> only I only defined fromEnum and toEnum not enumFrom
21:08:35 <heatsink> (enumFrom x) will list out each value in order, starting with x
21:09:14 <funfunctor> how would ghc infer the type of x there though?
21:09:21 <heatsink> > take 5 (enumFrom 2)
21:09:22 <lambdabot>  [2,3,4,5,6]
21:09:47 <heatsink> It infers the type based on how the result of enumFrom is used
21:10:09 <heatsink> or based on how x is defined
21:10:20 <lispy> > enumFrom id
21:10:21 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
21:10:21 <lambdabot>    arising from a use of ‚ÄòM49221931017134569377748.show_M49221931017134569377...
21:10:21 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
21:10:38 <lispy> You can't enumerate functions? lame
21:11:43 <funfunctor> heatsink: would enumFrom x       =  map toEnum [fromEnum x ..]  be ok to put in my instance?
21:12:08 <heatsink> No, because that would count out integers and try to convert them to BladeRFGPIOFlags
21:12:49 <heatsink> Does fromEnum produce you values like 1, 2, 3, 4, or values like 1, 2, 4, 8?
21:14:39 <heatsink> When enumerating integers, you would reach an integer that has no corresponding BladeRFGPIOFlags value, and toEnum can't give a useful result.
21:14:41 <lpaste> funfunctor pasted ‚ÄúNo title‚Äù at http://lpaste.net/124351
21:15:06 <funfunctor> heatsink: thats how they are defined in C land
21:15:14 <funfunctor> I'm just mapping those over
21:15:26 <funfunctor> I don't know why they didn't use a enum there
21:15:37 <heatsink> Weird, that one is defined as "2 << 3" and not "1 << 4"
21:16:00 <funfunctor> heatsink: probably API changes over time
21:17:30 <funfunctor> heatsink: I don't think I can trust these values wont change at any time..
21:18:12 <pavonia> Aren't these ints the same values?
21:18:35 <pavonia> *value
21:18:59 <heatsink> funfunctor: If you want to generate the Haskell code from the values in the C header file, you could look at c2hs
21:19:38 <funfunctor> heatsink: i'm already doing all that
21:19:43 <heatsink> ok
21:20:11 <funfunctor> heatsink: see how the Enum instance maps c'BLADERF_bla.. to the haskell data type
21:20:30 <funfunctor> so the values are mapped over
21:20:46 <heatsink> Ok
21:21:00 <heatsink> Then, gpios is the list of values you want
21:21:32 <heatsink> [e | (e, bit) <- gpios, bit .&. w /= 0]
21:21:48 <heatsink> In this comprehension, (e, bit) gets each pair of values from gpios
21:22:36 <heatsink> The bitwise and bit .&. w tests whether the bit is set
21:22:52 <heatsink> If it is set, then e becomes part of the output.
21:23:50 <funfunctor> heatsink: thx!
21:23:58 <heatsink> > [x | (x, b) <- [('a', 1), ('b', 2), ('c', 4), ('d', 8)], b .&. 9 /= 0]
21:24:00 <lambdabot>  "ad"
21:27:59 <funfunctor> heatsink: I just have a type-mismatch somewhere Couldn't match type `Word32' with `Int'
21:30:02 <heatsink> You can convert the Int to Word32 using fromIntegral
21:30:23 <heatsink> Really, it's better to make all your bit values be Word32, not Int
21:30:26 <funfunctor> heatsink: yep, I know I just had to figure out where to put it ;)
21:30:46 * hackagebot CLI 0.1.0.0 - CLI tools  http://hackage.haskell.org/package/CLI-0.1.0.0 (g960059)
21:30:47 <heatsink> Since Int is only guaranteed to hold 29 bits
21:33:34 <funfunctor> heatsink: yea not sure where the Int inference is even coming from
21:36:10 <funfunctor> ah I see, ghc is infering int from the to/fromEnum's there heatsink
21:36:59 <xnull_> is there a function with type signature `:: [a] -> [a] -> Maybe Int' that finds the location of the first occurence of a list in another list
21:38:28 <heatsink> > findIndex ("yo" `isPrefixOf`) $ tails "toyota"
21:38:29 <lambdabot>  Just 2
21:38:58 <funfunctor> this sleep pattern I have at the moment is fucked
21:39:15 <funfunctor> sleeping at 4pm waking up at 12pm
21:39:29 <xnull_> > findIndex . isPrefixOf "yo" . tails $ "toyota"
21:39:30 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Bool‚Äô with ‚Äòa -> GHC.Types.Bool‚Äô
21:39:30 <lambdabot>  Expected type: [GHC.Types.Char] -> a -> GHC.Types.Bool
21:39:30 <lambdabot>    Actual type: [GHC.Types.Char] -> GHC.Types.BoolCouldn't match type ‚Äò[GHC.T...
21:39:46 * ski can't tell whether 12pm is midnight or midday
21:40:12 <heatsink> So, you are awake only four hours a day?
21:40:12 <xnull_> > findIndex ("yo" `isPrefixOf`) . tails $ "toyota"
21:40:13 <lambdabot>  Just 2
21:45:06 <funfunctor> is there a short way to get Right from the return of a action with type Either BladeRFError [BladeRFGPIOFlags] ?
21:50:22 <heatsink> funfunctor, there are several ways, depending on what you want to happen if the value is a Left value
21:51:01 <heatsink> Do you want it to throw an exception, produce a default value, or propagate the Left value?
21:52:21 <funfunctor> heatsink: oh I mean I just want to ignore the Left value, so an exception would then be thrown automatically since I have an Exception instance there
21:52:46 <heatsink> An Exception instance for BladeRFError?
21:52:54 <funfunctor> heatsink: correct
21:53:21 <funfunctor> so I want to ignore the /value/ or Left and just have Right
21:54:04 <funfunctor> I only know how to do
21:54:04 <funfunctor> case ret of
21:54:04 <funfunctor>    Left e -> e
21:54:04 <funfunctor>    Right v -> ..
21:54:17 <funfunctor> but I was looking for something short hand just to get Right
21:54:57 <xnull_> case ret of
21:55:01 <xnull_>    Left e -> e
21:55:06 <xnull_>    _ -> ..
21:55:18 <heatsink> Like I said, you can't just get the value of of Right because you're not guaranteed that you have a Right constructor.
21:55:37 <xnull_> :t error
21:55:38 <lambdabot> [Char] -> a
21:55:41 <heatsink> You could do something like either throw id, which will throw an exception in the Left case and extract the value in the Right case
21:56:01 <heatsink> I mean, it will take the value from Left and throw it as an exception
21:56:31 <funfunctor> :t throw id
21:56:32 <lambdabot>     No instance for (Exception (a0 -> a0))
21:56:32 <lambdabot>       arising from a use of ‚Äòthrow‚Äô
21:56:32 <lambdabot>     In the expression: throw id
21:56:47 <ski> @type throw `either` id
21:56:48 <lambdabot> Exception a => Either a c -> c
21:57:07 <funfunctor> yea that looks like what I want
21:57:17 <heatsink> either f g x = case x of {Left y -> f y; Right z -> g z}
21:57:29 <heatsink> That is, it calls f to get the value from a Left or g to get the value from a Right
22:04:13 <gyaretto> Is there an easy way to pattern match the last element of a list?
22:04:52 <HeladoDeBrownie> gyaretto, what's your purpose in wanting that?
22:04:59 <kadoban> gyaretto: Not really, nor is it going to be fast. Finding the last element takes O(n) time, so if you're doing that at-all-often, you might be using the wrong data structure.
22:05:51 <gyaretto> I'm trying to write a parser and I'm appending failed token matching attempts to the end of a token list.
22:06:14 <HeladoDeBrownie> gyaretto, how about the front instead?
22:06:32 <gyaretto> The front is used for an error token.
22:06:49 <HeladoDeBrownie> so, you're using various places in a list for different purpose?
22:06:54 <HeladoDeBrownie> that sounds like you need a structure besides a list
22:07:00 <gyaretto> Probably.
22:07:01 <HeladoDeBrownie> how about a tuple? maybe a tuple of lists?
22:07:35 <gyaretto> I was previously using a tuple, but it got really confusing really fast.
22:08:21 <kadoban> gyaretto: Perhaps an actual record type then?
22:09:38 <gyaretto> Maybe.
22:09:46 <gyaretto> Hm.
22:11:25 <bramgg> What do I do with this mike tyson export error
22:18:30 <Hijiri> bramgg: punch it out
22:19:48 <funfunctor> heatsink: thx for all the help! My API is looking really polished now
22:20:07 <heatsink> you're welcome
22:20:29 <funfunctor> all the wacky C'ism is hidden away behind nice types
22:21:05 <funfunctor> like you can read gpio flags, get an array, concatenate a new flag on and write it back. you can use elem to check a flag is set also
22:21:08 <bramgg> I think cabal hates me
22:21:09 <heatsink> it seems like you've learned a lot since you started.
22:22:10 <funfunctor> heatsink: yea, its because every time I worked on haskell I kept getting interrupted with other work in C++/C or some other language for jobs. Its the first time I had my own time to properly work on things for myself
22:23:00 <funfunctor> my encoding is pretty poor because of my dyslexia
22:23:23 <funfunctor> so I need to be told a million times before it sinks in :p
22:23:38 <heatsink> Is C better or worse for that?
22:24:33 <funfunctor> heatsink: well instead of having users read a int, do random shifts and (.&.) so on then write back with possibly incorrect GPIO flags this way is much cleaner
22:24:56 <funfunctor> you know whats in the list of flags, there can only be valid flags and so valid bits set
22:25:14 <heatsink> Sure
22:25:16 <funfunctor> its pretty neat really
22:26:39 <funfunctor> gpios <- readGPIO ; if (gpios .&. Flag) == Flag then .. else ..   simply becomes gpio <- readGPIO ; if elem Flag gpios then .. else ..
22:28:03 <heatsink> Yeah, C APIs get bogged down in how to move data, or how to avoid moving data
22:29:27 <heatsink> Btw, Data.Bits has 'setBit', 'clearBit', and 'testBit' for single-bit operations on words
22:29:56 <bramgg> WTF. "cabal install x y z cgi" gave some errors for cgi and failed, but "cabal install x y z" & "cabal install cgi" seperately worked. Now all x, y, z, and cgi are installed.
22:30:13 <funfunctor> heatsink: thanks yea I know, but I don't think they help me in this case.
22:30:24 <funfunctor> since the bits are defined in the C header as defines
22:30:31 <funfunctor> so its a bit messy
22:30:49 <funfunctor> beyond me why they didn't use a enum
22:31:54 <heatsink> When mulitple packages are installed in the same command, are their dependences resolved separately?
22:32:19 <xnull_> :t isPrefixOf
22:32:20 <lambdabot> Eq a => [a] -> [a] -> Bool
22:32:33 <xnull_> :t Data.Text.isPrefixOf
22:32:34 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> Bool
22:33:53 <xnull_> :t Data.Text.findIndex (Text.pack "yo" `isPrefixOf`) . Data.Text.tails . Data.Text.pack
22:33:54 <lambdabot> Not in scope: ‚ÄòText.pack‚Äô
22:34:01 <xnull_> :t Data.Text.findIndex (Data.Text.pack "yo" `isPrefixOf`) . Data.Text.tails . Data.Text.pack
22:34:01 <lambdabot>     Couldn't match expected type ‚Äò[a0]‚Äô
22:34:02 <lambdabot>                 with actual type ‚ÄòData.Text.Internal.Text‚Äô
22:34:02 <lambdabot>     In the first argument of ‚ÄòisPrefixOf‚Äô, namely ‚ÄòData.Text.pack "yo"‚Äô
22:34:05 <funfunctor> heatsink: any advice on how a printGPIOFlags :: [BladeRFGPIOFlags] -> IO () should look? guards comes to mind but pattern matching every combo sucks naturally
22:34:19 <xnull_> :t Data.Text.findIndex ("yo" `isPrefixOf`) . Data.Text.tails
22:34:20 <lambdabot>     Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòChar‚Äô
22:34:20 <lambdabot>     Expected type: Char -> Bool
22:34:20 <lambdabot>       Actual type: [Char] -> Bool
22:34:35 <xnull_> :t findIndex ("yo" `isPrefixOf`) . tails
22:34:36 <lambdabot> [Char] -> Maybe Int
22:35:09 <SrPx> Any better way to express a function that moves the head of a list to the head of another list? i.e., transforms ([1,2,3],[4,5]) into ([2,3],[1,4,5]) ? I've got that mess: foo a = (_1 %~ tail) . (_2 %~ ((head $ a^._1) :)) $ a
22:35:17 <SrPx> (new to lens)
22:35:28 <arkeet> I think lens isn't the thing to use for that.
22:35:39 <edwardk> srpx: i'd just pattern match =P
22:35:43 <arkeet> :p
22:35:56 <SrPx> but how can I learn lens if I don't use lens :(
22:35:59 <heatsink> funfunctor: You could make a string for each flag individually, intercalate spaces or newlines, then put the string to stdout
22:36:04 <edwardk> some things aren't really suited
22:37:56 <xnull_> :t Data.Text.splitAt
22:37:56 <lambdabot> Int -> Data.Text.Internal.Text -> (Data.Text.Internal.Text, Data.Text.Internal.Text)
22:39:58 <f|`-`|f> the ((a:as), bs) = (as,a:bs)
22:40:28 <f|`-`|f> :t intercalate
22:40:29 <lambdabot> [a] -> [[a]] -> [a]
22:40:29 <SrPx> well, okay then :( the pattern match isn't a work of beauty, too: `foo (Foo {deck=(x:xs), hand=hand}) = Foo { deck = xs, hand = x : hand }`
22:40:40 <SrPx> since I'm using records, but... yea
22:40:49 <SrPx> at least it is readable
22:41:55 <heatsink> Maybe use a lens to view a Foo as a (deck, hand) pair?
22:43:47 <SrPx> foo (Foo {deck=(x:xs), hand=hand})@player = player { deck = xs, hand = x : hand } *
22:43:50 <SrPx> heatsink: dunno ...
22:45:44 <SrPx> well, `play (Free (DrawCard next)) player    = let (Player {_deck=(x:xs),_hand=hand}) = player in play next (player {_deck=xs, _hand=x:hand})` at least aligns :P
22:47:04 <HeladoDeBrownie> SrPx, readability being subjective, and those who can read lens being a subset of those who can read haskell, you might try an explicit case analysis
22:47:08 <HeladoDeBrownie> gah, was scrolled up
22:47:22 <SrPx> HeladoDeBrownie: ^_^
22:49:16 <xnull_> > findIndex ("yo" `isPrefixOf`) . tails $ "toyota"
22:49:17 <lambdabot>  Just 2
22:49:44 <xnull_> :t findIndex ("yo" `isPrefixOf`) . tails
22:49:45 <lambdabot> [Char] -> Maybe Int
22:51:17 <xnull_> :t Data.Text.findIndex
22:51:18 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> Maybe Int
22:51:33 <xnull_> :t findIndex
22:51:34 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
22:59:25 <echo-area> Is there a simpler way of writing \x -> x - 1 ?
22:59:33 <shachaf> subtract 1
22:59:35 <kadoban> echo-area: subtract 1
22:59:40 <arkeet> :t \f xs -> xs ^? folded . to f . filtered id . join . indexed
22:59:41 <lambdabot> Foldable f => (a -> Bool) -> f a -> Maybe Bool
22:59:53 <arkeet> oops
22:59:53 <echo-area> Thank you guys
23:00:04 <shachaf> arkeet: join?
23:00:19 <arkeet> read it as (join . indexed)
23:00:31 <arkeet> but indexed didn't do what I wanted it to do.
23:00:33 <shachaf> Ah. I was about to ask about indexed.
23:00:49 <arkeet> :t \f xs -> xs ^@? folded . to f . filtered id
23:00:50 <lambdabot> Foldable f => (a -> Bool) -> f a -> Maybe (Int, Bool)
23:01:09 <arkeet> > (\f xs -> xs ^@? folded . to f . filtered id) (> 3) [1,2,4,6]
23:01:11 <lambdabot>  Just (2,True)
23:01:18 <arkeet> ahh that's silly.
23:01:22 <arkeet> useless bool.
23:01:31 <arkeet> I just want the index.
23:02:02 <arkeet> why didnt' I use filtered f
23:02:07 <arkeet> > (\f xs -> xs ^@? folded . filtered f) (> 3) [1,2,4,6]
23:02:08 <lambdabot>  Just (2,4)
23:02:11 <arkeet> slightly more useful.
23:06:36 <glguy_> > ifind (\_ x-> x>3) [1,2,4,6]
23:06:37 <lambdabot>  Just (2,4)
23:09:39 <arkeet> :t ifind
23:09:40 <lambdabot> FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)
23:10:56 <arkeet> I forget, what was the obstruction to moving Indexed stuff outside of lens?
23:12:24 <edwardk> well, for one its a pile of MPTCs that then need to depend on half the packages lens does to avoid orphaning, and being MPTCs you're going to get objections from folks about inverting that construction, etc.
23:12:34 <glguy_> https://github.com/ekmett/lens/wiki/FAQ#lens-core is relevant
23:13:00 <glguy_> mainly it'd be a waste of time to do it, people stil lwouldn't depend on it in the name of dependency reduction and lens would be split into more packages unnecessarily
23:14:01 <shachaf> The real question is what's the obstruction to moving lens into Prelude.
23:14:22 <edwardk> my experience is that the same folks who want to move these things out, are the same folks who then when we do, want even smaller dependencies. i've basically decided i can't win down that road
23:15:12 <arkeet> I suppose.
23:15:50 <edwardk> arkeet: i split up a package i had called category extras into 20+ packages once. the maintenance nightmare almost made me stop developing haskell
23:16:00 <edwardk> i'm not going to repeat that experience with lens
23:16:43 <edwardk> once you have a package split, the cost of managing any change the 'crosses the split' rises exponentially
23:18:51 <edwardk> we've been splitting out bits and pieces as we can that don't need anything to really do with lens, e.g. when we found we could use the existing profunctors machinery, or contravariant functors, etc. that let us kick more and more things out of the library
23:20:03 <shachaf> Gettable is gone despite improving error messages in theory.
23:20:06 <edwardk> but the ad hoc overloading classes are an active pain point.
23:21:05 <edwardk> because they need so many dependencies, so the win for splitting them out is marginal, and it comes at a huge maintenance cost, and it does almost nothing to encourage third party users to provide instances
23:21:45 <edwardk> because they are going to look at the nice small core that includes classes like "Conjoined" and just walk away
23:22:15 <edwardk> moreover, the documentation suffers terribly. we have docs all over lens that hyperlink and criss-cross the entire package
23:22:37 <edwardk> when you rip out a tenth of the package, that whole 'nest' of hyperlinks falls apart.
23:22:47 <edwardk> nothing crosses the boundaries
23:24:07 <edwardk> so i get more maintenance, worse headaches, more complaining, worse documentation, and almost no new users ;)
23:24:10 <edwardk> sign me up =)
23:24:19 <kadoban> Anyone know exactly what the LTS major version numbers mean‚Ä¶as in, when is another major version expected? Is it tied to GHC releases or something? Scheduled based on time or something? Totally arbitrary?
23:24:36 <kadoban> Sorry, that's for stackage, thought I mentioned that.
23:24:54 <edwardk> kadoban: IIRC, LTS is something like 3 months
23:25:07 <kadoban> Ah, thanks.
23:25:25 <glguy_> In Haskell, LTS is 3 months ^_^
