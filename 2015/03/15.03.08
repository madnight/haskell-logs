00:00:04 <Athas> Hm... I am writing a compiler.  Would it be gross to define Num and Integral instances for my expression AST?
00:00:04 <Ch0c0late> Another question. Still don't get why implementing non interference in Haskell would be problematical? johnw Any insight?
00:00:24 <johnw> non interference?
00:00:26 <Ch0c0late> In concurrent Haskell I mean
00:01:00 <johnw> I really don't know what yo'ure referring to
00:01:02 <Ch0c0late> Yes, johnw. No two object can access each other. Preventing covert channel.
00:01:52 <johnw> you mean, security guarantees pertaining to the executing process?
00:01:54 <kadoban> Athas: Sounds pretty gross to me. What would that gain you?
00:03:08 <Athas> kadoban: reusing generic functions that work on numbers.
00:03:19 <Athas> As the simplest example, I could use 'product' to generate expressions.
00:03:38 <Ch0c0late> johnw: not really.  https://en.m.wikipedia.org/wiki/Non-interference_(security)
00:05:11 <johnw> Ch0c0late: i'll let others answer further
00:05:31 <Ch0c0late> Yes. Thanks johnw
00:05:47 <kadoban> Athas: Just that information by itself sounds more like Monoid to me, no?
00:06:43 <Athas> kadoban: then 'sum' would also generate a product.
00:07:10 <Athas> This is probably a bad idea for more reasons, though...
00:08:04 <Lokathor> a Num instance of an AST is bascically part of that thing Godel did right?
00:08:17 <kadoban> Athas: The way that's dealt with for Integers for instance is to have a newtype wrapper for each Monoid instance, like Sum and Product. I have no idea if that'd be applicable to what you're looking for.
00:08:22 <Lokathor> with encoding logical statements into integers?
00:09:07 <Athas> kadoban: it's not, since I have single functions that use different operators at once.
00:09:28 <Athas> For example, I have a function that generalises the concept of "compute a flat index into an array, given an array shape and an index set".
00:09:45 <Athas> Sometimes I want to use this function to generate expressions in my high-level AST, other times in my low-level AST.
00:12:10 <dmj`> Cale: ping
00:12:23 <Cale> hi
00:13:47 <Cale> Lokathor: uh, probably not, you want the (+) and (*) to at least approximately correspond to the ring axioms (Float and Double don't, but floating point numbers suck algebraically)
00:14:10 <dmj`> Cale: hey! A while ago I believe there was a haskell reddit post about visualizing lazy graph reduction, do you remember the name of that project?
00:14:36 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ -- maybe you're thinking of this?
00:15:17 <glguy> Is there a non-short-circuiting MaybeT like type laying around. It wouldn't give up on failure, but keep running the underlying effect
00:15:26 <glguy> wouldn't support a Monad instance but would support an Applicative
00:15:33 <HeladoDeBrownie> glguy, what would failure mean then?
00:15:43 <dmj`> Cale: yes exactly !
00:15:44 <dmj`> Cale: Also, have you toyed with the vacuum project? I asked on #haskell a while ago for a visualization of ghc's heap. Apparently vacuum can export to this format, http://ubietylab.net/ubigraph/
00:15:56 <glguy> It means you aren't getting an "a" out at the end, but the effects would still happen
00:16:04 <dmj`> Cale: http://hackage.haskell.org/package/vacuum
00:16:28 <Cale> dmj`: Yeah, I've played with it a bit. It's not really the same as the graphs that HOPS shows you
00:16:37 <Cale> But I guess it's an okay approximation for data.
00:16:57 <Cale> You can't really visualise function expressions with Vacuum too well.
00:18:50 <dmj`> Cale: did you use it with ubigraph or graphviz? or both... I hope it can make movies, I would like to watch my programs reduce graphs all day, besides a great pedagogical exercise, it'd make a fantastic screen saver
00:19:08 <lpaste> glguy pasted “PersevereT” at http://lpaste.net/123637
00:19:46 <glguy> HeladoDeBrownie: This is what it'd be
00:19:47 <Cale> I didn't really use it for too long. The graphs that vacuum produces are interesting when applied to mostly-evaluated data structures and otherwise not too informative.
00:20:12 <Cale> You can't really watch graph reduction take place.
00:20:50 <glguy> Maybe this is just Compose _ Maybe
00:21:06 <dmj`> Cale: why not
00:21:12 <dmj`> sorry if that's a dumb question
00:21:56 <Cale> dmj`: Well, GHC compiles stuff to machine code, and most of the information about the structure of computations isn't really visible any longer
00:24:31 <Ch0c0late> Why? "This approach works well for simple lattices, but encoding the security lattice of n points would require O(n2) definitions for binding operators. This makes it dif- ficult to implement more complex security lattices such as the decentralized label model."
00:24:34 <dmj`> Cale: would you be able to glean that information from the runtime system?
00:25:14 <Ch0c0late> Any idea on above sentence?
00:25:40 <Cale> dmj`: Most of the information which makes the HOPS graphs fun to look at has been destroyed by compilation. You'd have to do some interesting stuff to maintain it through the compilation process which would probably severely damage performance, but would be really interesting nonetheless.
00:31:54 <dmj`> Cale: I imagine profiling uses some of those techniques, I understand optimizations occur, but are you saying HOPS graphs are not indicative of actual program performance?
00:32:26 <dmj`> or memory usage
00:33:08 <dmj`> sorry if this is all naive
00:33:18 <Cale> dmj`: They're very approximate
00:33:50 <Cale> dmj`: I mean, I often have something like those graphs going on in my head when I'm trying to understand the performance of Haskell programs
00:34:40 <Cale> But what GHC is *actually* doing is probably some constant factor better than my mental model of what it's doing
00:35:19 <dmj`> that's pretty cool
00:35:43 <dmj`> but does HOPS lazy eval model mimic the ghc rts's lazy eval strategy?
00:36:16 <Cale> Mostly. HOPS can implement arbitrary rules for graph reduction though.
00:36:56 <Cale> and GHC does strictness analysis which results in a different order of reduction taking place
00:37:36 <Cale> and GHC also does a bunch of unboxing and constructor specialisation which destroys the graph structure altogether in many tight loops
00:38:52 <dmj`> which is very cool, can HOPS express any haskell expression? what are the limits I guess. It obviously can't handle certain extensions I assume
00:39:07 <dmj`> s/express/handle
00:40:07 <Cale> It's not really Haskell at all
00:40:17 <Cale> It's just a somewhat similar functional programming language.
00:40:23 <Cale> Those graphs *are* its expressions
00:41:34 <Cale> You actually program by constructing graphs visually
00:42:17 <dmj`> Cale: so I make the graph, then name it as a function? Like filter
00:42:41 <dmj`> I hope this thing compiles on osx
00:42:48 <Cale> Yeah, look at the screenshot, you draw those graphs labelled filter_[] and filter_:
00:43:00 <Cale> Wait, you have the source code for it?
00:43:46 <Cale> I've been wanting Dr. Kahl to release it for a long time.
00:43:47 <dmj`> Cale: I assumed there was a link for it
00:43:53 <dmj`> Cale: how have you been using it?
00:44:05 <Cale> I just saw it demoed while I was working at McMaster
00:44:57 <dmj`> so you've never wrote your own graph, you just watched it?
00:45:31 <dmj`> I mean, that would have the same effect, I'd be fine with that too
00:45:33 <Cale> I watched Dr. Kahl enter some graphs
00:46:56 <dmj`> Cale: there's a number, maybe we could call him
00:47:04 <dmj`> Cale: do you know him personally?
00:47:09 <Cale> In a sense HOPS is lower-level than Haskell, in that you can specify nearly-arbitrary term graph rewritings, including ones which are not necessarily implementable by functions.
00:47:30 * hackagebot exceptions 0.8.0.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.8.0.1 (EdwardKmett)
00:47:30 <Cale> I don't know him very well, it's been quite a few years since we last spoke to each other
00:47:32 * hackagebot json-autotype 0.2.5.6 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.6 (MichalGajda)
00:48:02 <Cale> He also has this really nice library in Haskell for relations that isn't on Hackage but should be.
00:48:57 <dmj`> Cale: so the rts has one model alone for graph reduction, but hops let's you specify arbitrary reductions, that while different yield the same result ?
00:50:38 <Cale> Yeah... and I'm not sure, maybe even different results.
00:52:44 <dmj`> Cale: I'll try vacuum, and if it sucks (no pun intended) maybe we could email him.
00:52:58 <dmj`> Cale: I just really want to learn more about the rts, found this gem today: http://web.mit.edu/~ezyang/Public/jfp-ghc-rts.pdf
00:53:00 <Cale> Vacuum is good for what it is
00:53:09 <Cale> It's just very limited in its scope
00:53:30 <dmj`> You can't create your own graphs :/
00:54:43 <dmj`> I just don't get why it's not open source
00:55:39 <Guest67821> http://book.realworldhaskell.org/read/using-parsec.html Is this guide outdated? When googling for Parsec I got to this page instead http://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec.html
00:56:05 <EvanR> sgronblo: and 3.1.8 is the latest on hackage
00:56:27 <Cale> sgronblo: The module names have changed a bit
00:56:40 <Cale> Instead of Text.ParserCombinators.Parsec.*  it's just  Text.Parsec.*
00:57:31 * hackagebot profunctors 4.4.1 - Profunctors  http://hackage.haskell.org/package/profunctors-4.4.1 (EdwardKmett)
01:02:31 * hackagebot influxdb 0.9.1.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.9.1.1 (MitsutoshiAoe)
01:05:46 <sgronblo> Cale: Right I'll try to see if I can make sense of it. Thanks.
01:07:31 * hackagebot contravariant 1.2.2.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.2.2.1 (EdwardKmett)
01:12:31 * hackagebot json-autotype 0.2.5.7 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.7 (MichalGajda)
01:12:33 * hackagebot reflection 1.5.1.2 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.5.1.2 (EdwardKmett)
01:27:32 * hackagebot json-autotype 0.2.5.8 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.8 (MichalGajda)
01:32:32 * hackagebot heaps 0.3.2 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.3.2 (EdwardKmett)
01:36:08 <Guest58321> john
01:36:18 <Guest58321> luigi
01:36:57 <Guest58321> jalina
01:37:02 <sivteck> mario?
01:37:04 <EvanR_> #haskell is not for coded messages between spies
01:37:14 <Guest58321> Guest58321
01:37:33 * hackagebot foreign-var 0.1 - Encapsulating mutatable state in external libraries  http://hackage.haskell.org/package/foreign-var-0.1 (EdwardKmett)
01:42:33 * hackagebot cql-io 0.13.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.13.1 (ToralfWittner)
01:43:32 <bobajett> hello, I don't understand how to run the calculator program from Graham Hutton's book as a stand alone executable?
01:43:35 <bobajett> http://www.cs.nott.ac.uk/~gmh/calculator.lhs
01:43:59 <bobajett> I can run it from ghci just fine by typing the last function in the source "run"
01:44:01 <Lokathor> your haskell install might have a "runhaskell" command
01:44:27 <Lokathor> oh, yeah, this file doesn't have a main function
01:44:45 <Lokathor> so you can't run it standalone, you have to do it through ghci or make a main function
01:44:50 <bobajett> yeah that's what Im confused about, I set "main = do run" but when I do ghci --make calc
01:45:03 <bobajett> and run it, it just sits there with no output as if its buffered or something.
01:45:21 <Lokathor> try using: main = run
01:45:23 <Lokathor> instead of do run
01:45:32 <bobajett> Lokathor: ok cool, I'll try that
01:46:07 <Lokathor> wrapping a do around run would make it IO (IO ()), which isn't quite what ghc is looking for
01:46:40 <bobajett> Lokathor: ok even with main = run, I see nothing on the screen, however when I press Ctrl-C, the output then shows up.
01:46:57 <EvanR_> thats an output buffering issue
01:46:58 <Lokathor> that does sound like a buffering issue
01:47:12 <EvanR_> hSetBuffering
01:48:02 <bobajett> why would there be no buffering when run through ghci but when run as a stand alone? is ghci autoflushing some bufferering stuff?
01:48:19 <Lokathor> ghci in fact does many nonstandard things >_>
01:48:25 <bobajett> :-)
01:48:40 <bobajett> ok I'll check out hSetBuffering
01:48:49 <Lokathor> also hFlush might help
01:49:35 <EvanR_> bobajett: windows?
01:50:13 <bobajett> EvanR_: MacOSx / screen
01:50:44 <EvanR_> putStrLn etc work for me by default
01:50:49 <EvanR_> no fiddling with buffering
01:50:51 <bobajett> but Im running it in MacOSx/screen/emacs/terminal/ghci where it works :-)
01:55:58 <Haskellfant> Hi, I am trying to write bind to wlc using c2hs, but it fails on bool from stdbool.h. http://lpaste.net/123745 the header file is here https://github.com/Cloudef/wlc/blob/master/include/wlc.h#L108 I found a related issue here https://github.com/haskell/c2hs/issues/125 but sadly I don't what I should do to make it work
03:02:34 * hackagebot redis-io 0.4.1 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.4.1 (ToralfWittner)
03:02:58 <Haskellfant> hm apparently c2hs doesn't work with stdbool
03:04:49 <ibid> stdbool is just a bunch of #defines. the real problem is probably _Bool
03:04:53 <hexagoxel> glguy: see https://github.com/haskell/haddock/issues/327
03:05:36 <hexagoxel> i now resort to using a readme.md; when i cannot use local testing that feature is unusable imo.
03:07:34 * hackagebot lca 0.3 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing  http://hackage.haskell.org/package/lca-0.3 (EdwardKmett)
03:23:20 <benneh> I'm trying to write a function foo :: (Functor f) => f (Maybe a) -> Maybe (f a)
03:23:29 <benneh> I want this function to essentially be defined as foo = Just . fmap fromJust, but for it to return Nothing if any of the fromJust's fail
03:23:49 <benneh> it seems simple enough, but I cannot work out how to do it
03:24:52 <EvanR_> dont use fromJust
03:25:38 <EvanR_> :t traverse
03:25:39 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:25:52 <EvanR_> :t catMaybes
03:25:53 <lambdabot> [Maybe a] -> [a]
03:26:05 <EvanR_> :t foldMap
03:26:06 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
03:27:39 <Cale> benneh: A fully-defined function with that type signature is not possible to write.
03:28:09 <Cale> All that knowing f is a Functor gives you is fmap :: (a -> b) -> f a -> f b
03:28:45 <Cale> So while you could write Just . fmap fromJust, that isn't really what you mean, and any Nothings will result in errors
03:28:59 <benneh> can you prove that no such function can exist?
03:29:34 <dibblego> Yes.
03:30:03 <dibblego> Use (Apply f) or (Applicative f), then it becomes possible.
03:31:07 <benneh> if the function were in the other direction then (Applicative f) would be enough, since Maybe is Traversable
03:31:19 <dibblego> Yes.
03:32:03 <dibblego> or if Maybe were Distributive (which it isn't)
03:32:33 <benneh> how would you go about proving that no function of the type I'm looking for can exist?
03:33:07 <hexagoxel> Cale: does "fully defined" imply "does not lose information"?
03:33:31 <dibblego> well, it can exist. It is (const Nothing). You need to prove that it definitely is this.
03:34:06 <benneh> good point
03:34:09 <dibblego> you can do that using parametricity (Theorems for Free, Wadler)
03:35:33 <dibblego> or using a proof assistant
03:37:47 <benneh> well I guess it's time for me to learn what parametricity is then
03:37:56 <benneh> thanks for the help
03:38:37 <safinaskar> why "show (genericLength [])" works? how ghci knows type of "genericLength []"? it can be any numeric type!
03:39:16 <mauke> defaulting
03:39:25 <mauke> same way '42' works
03:39:27 <mauke> :t 42
03:39:28 <lambdabot> Num a => a
03:39:34 <EvanR_> can be, but isn't
03:40:50 <safinaskar> mauke: thanks
03:44:48 <EvanR_> dupTChan :: TChan a -> STM (TChan a)
03:45:19 <EvanR_> this is boggling me, is the idea to dup a chan only for the purposes of one transaction
03:45:46 <EvanR_> if the STM is an infinite loop, will anything every happen
03:45:49 <EvanR_> ever
03:46:27 <EvanR_> oh, atomically (dupTChan ch)
03:49:13 <bobajett> figured out my flushing problem. There was code in there that said: getCh = hSetEcho stdin false; c <- getChar;
03:53:02 <Cale> Oh, yeah, the const Nothing is a good point :)
03:57:37 * hackagebot speculation 1.5.0.2 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.5.0.2 (EdwardKmett)
03:57:40 <sgronblo> Why is there a type like this type Parsec s u = ParsecT s u Identity, wouldn't it make more sense to use Maybe or List?
03:58:14 <Maxdamantus> sgronblo: a list of what?
04:01:13 <sgronblo> List of possible matches?
04:02:26 <kaiyin> could anyone give an example where f . g == id but g . f != id ?
04:02:36 <Maxdamantus> sgronblo: that doesn't represent the possible matches.
04:02:37 * hackagebot extensible 0.3.1 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.1 (FumiakiKinoshita)
04:03:01 <Maxdamantus> sgronblo: it represents a parser that you can run.
04:03:01 <sgronblo> Oh, runParser already returns Either ParseError a
04:04:11 <lyxia> kaiyin: f n = () ; g () = 0
04:05:41 <kaiyin> lyxia: great.
04:06:57 <EvanR_> speaking of defaulting whats up with this: http://lpaste.net/123820
04:07:03 <sgronblo> "Stream type s" does that mean s would normally be Char?
04:07:37 * hackagebot Rasterific 0.5.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.1 (VincentBerthoux)
04:08:27 <EvanR_> instance Num Double -- Defined in ‘GHC.Float’ how are any of these an option given the type of threadDelay
04:09:28 <EvanR_> and adding type annotations isnt helping so theres something else wrong
04:10:09 <EvanR_> had to add it to the 6
04:11:30 <fizruk> kaiyin: f = (`div` 2); g = (* 2)
04:12:37 * hackagebot time-patterns 0.1.3.0 - Patterns for recurring events.  http://hackage.haskell.org/package/time-patterns-0.1.3.0 (jfmueller)
04:13:09 <kaiyin> fizruk: how so? 
04:14:02 <fizruk> kaiyin: (3 `div` 2) * 2 = 2; (3 * 2) `div` 2 = 3
04:14:49 <kaiyin> oh, cool. 
04:15:06 <fizruk> kaiyin: also, f = take 5; g = ("hello" ++)
04:15:30 <fizruk> err, drop 5
04:22:38 * hackagebot time-patterns 0.1.3.1 - Patterns for recurring events.  http://hackage.haskell.org/package/time-patterns-0.1.3.1 (jfmueller)
04:27:38 * hackagebot traced 3000 - Simple evaluation trace  http://hackage.haskell.org/package/traced-3000 (EdwardKmett)
04:42:02 <solatis> hmmm i'm generating 100% cpu usage when using Network.Socket.ByteString.sendAll on a Datagram socket. is that a known fact / side-effect?
04:42:12 <solatis> (as in, that I should not use sendAll on a DGRAM socket)
04:42:39 * hackagebot svg-tree 0.1.0.2 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.1.0.2 (VincentBerthoux)
04:42:56 <EvanR_> you might have an unrelated infinite loop
04:45:51 <solatis> nah i think i already have the error
04:45:59 <solatis> the remote is not there
04:46:05 <solatis> so sendAll attempts to, well, send everything
04:46:31 <EvanR_> i guess that makes sense
04:47:04 <solatis> .send returns -1
04:47:17 <EvanR_> check errno
04:47:21 <solatis> yessir
04:48:13 <solatis> i think i might be doing something wrong in my socket connection building functions, since this is the first time i'm doing anything datagram/udp related
04:53:07 <solatis> ok, fixed my issue
04:57:40 * hackagebot hyperloglog 0.3.1 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.3.1 (EdwardKmett)
05:02:40 * hackagebot rasterific-svg 0.1.0.3 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.1.0.3 (VincentBerthoux)
05:07:08 <vandenoever> cabal has a hard time installing scion-browser, i'm using -max-backjumps 10000 now, is that excessive?
05:27:42 * hackagebot network-attoparsec 0.12.1 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.12.1 (solatis)
05:31:59 <reaper2k6> I'm not even sure what the point of haskell is
05:32:17 <reaper2k6> But read the logs of a failed attempt to troll the channel, hilarious!
05:32:22 <reaper2k6> Seems like a great community
05:32:52 <EvanR_> aliens
05:35:40 <reaper2k6> Aliens is the point?
05:39:07 <quchen> Haskell is a general purpose programming language. Its point is to make programs.
05:39:31 <edwardk> reaper2k6: that incident has been a mixed bag. On one hand, it showcases the community here at its best. On the other, it has invited tons of imitators trying to check to see if it "really works that way"
05:40:28 <reaper2k6> edwardk: I can imagine! Not about to try
05:40:45 <reaper2k6> Not been on irc for a few years so brought back some nostalgia 
05:41:08 <RaceCondition> is there anything beyond the sophistication of align-rules-list/align-regexp?
05:41:43 <reaper2k6> quchen: Wasn't dissing Haskell! Learning python atm, just meant I wasn't sure what advantages the whole 'functional' side brings
05:42:20 <EvanR_> functions are just the beginning of functional
05:42:48 <quchen> edwardk: People keep claiming that imitators come around, but I haven't seen proof of that. It's one of those claims one can easily make, but not verify in the same way.
05:43:11 * edwardk shrugs and goes off to sleep
05:46:09 <vandenoever> reaper2k6: three advantages of haskell: very good type checking, fast io with libuv, less surprises because of functional style
05:46:48 <EvanR_> ive not heard of libuv
05:47:12 <EvanR_> looks like node.js stuff
05:47:54 <reaper2k6> vandenoever: Thanks for the advice! Taking me ages to get any good with python; will check out Haskell after I guess!
05:51:15 <quchen> vandenoever: What's libuv?
05:51:36 <quchen> (In relation to Haskell)
05:52:46 <quchen> Whenever I read event loop it means "hack for languages that can't do concurrency well", and libuv seems to fall into that domain.
05:54:09 <EvanR_> node.js gets a lot of credit for being very intuitive and very high performance
05:54:21 <EvanR_> for some reason
05:54:39 <vandenoever> quchen: sorry, i was mistaken, i somehow thought haskell was also using libuv
05:55:15 <quchen> vandenoever: GHC, you mean? Could be. That's why I'm asking. GHC does do non-blocking IO, but I don't know how.
05:57:29 <vandenoever> quchen: "GHC's thread system and IO manager is implemented in terms of epoll, for example." https://news.ycombinator.com/item?id=3116131
05:58:00 <EvanR_> thats an OS-specific mechanism for doing IO multiplexing
05:58:23 <vandenoever> i'm on that os :-)
05:58:31 <EvanR_> im not ;)
06:10:59 <funfunctor> hi
06:11:26 <funfunctor> can someone help me with this guard syntax parse error here please? http://lpaste.net/123941
06:13:38 <lyxia> funfunctor: Don't you mean "if ret < 0 then ... else ..."?
06:14:07 <lyxia> funfunctor: And case ... of uses ->, not =.
06:14:27 <funfunctor> lyxia: I could use that but why does the guard not work?
06:14:37 <lpaste> hesiod pasted “cabal strangely rejecting package” at http://lpaste.net/123945
06:15:21 <detrumi> You can't use a guard on line 8
06:15:38 <hesiod> Why does cabal reject containeers-0.5.*, as seen in above paste?
06:16:44 <EvanR_> aw i really wanted there to be a package called containeers
06:17:15 <detrumi> funfunctor: Afaik, you can only use guards after a function or case, not directly in a do
06:17:22 <hesiod> EvanR_: :D
06:17:45 * hackagebot hoe 1.0 - hoe: Haskell One-liner Evaluator  http://hackage.haskell.org/package/hoe-1.0 (HideyukiTanaka)
06:22:45 * hackagebot xmobar 0.23 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.23 (JoseAntonioOrtegaRuiz)
06:24:03 <hexagoxel> hesiod: because the installed version of template-haskell depends on containers-0.5.0.0 (and array-0.4.0.1, which causes the problem)
06:25:25 <hexagoxel> as i understand it, the "installed" constraint fixates the versions of template-haskell, containers, array (and more)(transitively)
06:30:03 <hesiod> hexagoxel: which is kind of strange because I depend on array-any, not array-0.4.0.1... some other dependency probably wants a specific array version
06:30:34 <funfunctor> how can I diagnose if any use-after-free's are occuring while using allocaBytes ?
06:31:11 <hexagoxel> hesiod: see line 9, xenocrat
06:31:52 <indiagreen> how can I make a mirror of Hackage?
06:32:36 <indiagreen> nevermind, found it
06:34:09 <hesiod> hexagoxel: that is my package (which does not require a specific version of array)
06:37:57 <hexagoxel> hesiod: no idea then, sorry. maybe --upgrade-dependencies is doing strange stuff (?)
06:40:20 <vandenoever> is eclipsefp a popular choice for haskell editing? i'm looking for an ide that shows errors quickly
06:45:07 <sgronblo> there is no parsec combinator for many1toN?
06:47:46 * hackagebot hdbc-aeson 0.1.3.0 - Deserialize from HDBC rows to FromJSON instances  http://hackage.haskell.org/package/hdbc-aeson-0.1.3.0 (DanielChoi)
06:57:47 * hackagebot hoe 1.0.1 - hoe: Haskell One-liner Evaluator  http://hackage.haskell.org/package/hoe-1.0.1 (HideyukiTanaka)
07:02:46 <gwm_> Can someone walk me through defining a recursive function in haskell?
07:03:08 <EvanR_> @src fix
07:03:08 <lambdabot> fix f = let x = f x in x
07:04:11 <EvanR_> fix f = f (fix f)
07:06:41 <sgronblo> gwm_: define a base case and another case that calls itself in manner that the execution proceeds toward termination, assuming thats what you want
07:07:32 <hpc> > let fact 0 = 1; fact n = n * fact (n - 1) in fact 5
07:07:34 <lambdabot>  120
07:07:41 <hpc> you can also leave out the base case
07:08:04 <hpc> > let repeat n = n : repeat n in repeat "like this"
07:08:06 <lambdabot>  ["like this","like this","like this","like this","like this","like this","li...
07:08:32 <gwm_> Define a recursive function triangle :: Int → Int that returns the sum of all natural numbers between its argument and zero (inclusive). For example, triangle 4 should return 4 + 3 + 2 + 1 + 0, i.e. the value 10.
07:08:36 <gwm_> So
07:08:40 <gwm_> Base case first
07:10:08 <gwm_> Do I even need one?
07:10:19 <quchen> Yes, recursion needs a base case.
07:10:33 <quchen> Otherwise you're just recursing forever.
07:10:37 <EvanR_> or else youll get
07:10:40 <EvanR_> > fix error
07:10:41 <gwm_> Okay
07:10:42 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:11:09 <gwm_> Sorry could you show me the base case for that example
07:11:33 <quchen> It's the triangle number of the simplest triangle.
07:11:40 <JaAnTr> Hi, would someone be able to have a quick look at some Haskell I've done for implementing a mini imperative programming language just to check what I've done so far is correct. Thanks! http://pastebin.com/yq81Qupr
07:11:47 <gwm_> triangle 1 = 1
07:11:50 <gwm_> no
07:11:58 <quchen> There's a simpler triangle.
07:12:01 <geekosaur> hint, it's named in the problem statement
07:12:11 <gwm_> 0
07:12:13 <geekosaur> and an example shown
07:12:38 <gwm_> what triangle 4?
07:12:45 <gwm_> or triangle 0
07:12:51 <quchen> Which one is simpler?
07:13:13 <gwm_> 0
07:14:18 <quchen> And now, do you know an expression to calculate the triangle number of (n+1) if you know the one for (n) already?
07:15:51 <EvanR_> triangle (n+1) = 
07:16:18 <mauke> EvanR_: :-(
07:16:49 <EvanR_> n+1 patterns proving useful
07:16:51 <gwm_> erm
07:17:16 <mauke> >implying
07:17:48 <Alex-xd> -4- I Like the Shit┌∩┐(◣_◢)┌∩┐
07:19:42 <gwm_> Don't know why I'm finding this so difficult
07:21:30 <mauke> because you're not thinking of integers as recursive structures
07:21:35 <mauke> and because this exercise kind of sucks
07:22:43 <gwm_> Like I don't even see the need for recursion
07:22:46 <gwm_> 'triangle x = [x |  <- [0..x]'
07:22:57 <gwm_> I mean
07:23:02 <gwm_> triangle x = sum  [x |  <- [0..x]
07:23:07 <gwm_> ]
07:23:12 <quchen> gwm_: The triangle number for 4 is (4+3+2+1+0), the triangle number for 3 is (3+2+1+0). Do you see how you can use "triangle 3" in "triangle 4"?
07:23:33 <mauke> gwm_: correct
07:23:34 <EvanR_> gwm_: or just [0..x]
07:23:43 <EvanR_> sum ^
07:23:54 <mauke> did you mean: triangle x = sum [1 .. x]
07:23:58 <gwm_> Yeah
07:24:17 <mauke> and this is why the exercise sucks
07:24:21 <gwm_> quchen: yeah so triangle 4 is 4 + triangle 3
07:24:29 <quchen> gwm_: Excellent.
07:24:44 <quchen> How would you use triangle 7 to define triangle 8?
07:24:55 <gwm_> 8 + triangle 7
07:25:06 <quchen> How would you use triangle 123 to define triangle 124?
07:25:19 <gwm_> 124 + triangle 123
07:25:20 <EvanR_> why was triangle 6 afraid of triangle 7
07:25:20 <gwm_> I see
07:25:20 <quchen> I'll keep going until you tell me this is stupid and tell me the pattern :-þ
07:25:35 <gwm_> 7 8 9
07:25:40 <gwm_> Ahaha
07:25:42 <gwm_> Okaya
07:25:53 <gwm_> So my base case
07:26:09 <gwm_> I'll have a go and report back
07:26:31 <quchen> ಠ_ಠ 
07:26:33 <markarts> Does someone know if it is possible to do something along the lines of this: http://lpaste.net/124015 
07:26:49 <mauke> > let triangle (-4) = triangle (-99); triangle x = sum [1 .. x] in triangle 5
07:26:51 <lambdabot>  15
07:26:56 <mauke> ^ technically correct
07:26:56 <markarts> Or set the step size of list comprehension?
07:27:48 * hackagebot friday 0.2.1.0 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.1.0 (RaphaelJavaux)
07:28:07 * geekosaur wonders if describing it in terms of nats would help
07:29:24 <gwm_> quchen: triangle :: Int -> Int                triangle n = sum [0..n]                triangle n+1 = n + triangle n
07:30:00 <EvanR_> poor n+k patterns
07:30:58 <gwm_> I don't see the need for anything other than the base case?
07:31:40 <quchen> gwm_: The "sum" part is not in the spirit of the exercise, because that allows you to calculate any triangle number already, but in a non-recursive way.
07:31:45 <EvanR_> youre having more trouble with the problem structure than with the actual problem
07:31:54 <EvanR_> you obviously know how to implement triangle
07:32:12 <mauke> > let lM xs = [ m | (l,m,r) <- zip3 xs (drop 1 xs) (drop 2 xs), m > l, m > r ] in lM [1,4,2,3,6,0]
07:32:13 <lambdabot>  [4,6]
07:32:19 <gwm_> okay
07:32:25 <mauke> markarts: ^
07:32:39 <quchen> gwm_: Suppose I give you "triangle n = n + triangle (n-1)", what happens when you calculate (triangle 2)?
07:32:50 <quchen> Go ahead, do it step by step
07:32:58 <quchen> triangle 2 = ...?
07:33:21 <Cale> markarts: you're looking for tails
07:33:36 <gwm_> 2 + triangle (2-1)
07:33:42 <gwm_> 2 + triangle (1)
07:34:02 <gwm_> 3
07:34:07 <Cale> > let localMaxima xs = [y | (x:y:z:_) <- tails xs, x < y, y > z] in localMaxima [1,4,2,3,6,0]
07:34:09 <lambdabot>  [4,6]
07:34:11 <quchen> Where does that 3 come from, gwm_?
07:34:11 <mauke> gwm_: where did you get 3 from?
07:34:20 <mniip> gwm_, more like, 2 + 1 + triangle 0
07:34:30 <Cale> markarts: ^^
07:34:34 <zett_zelett> Is there syntatic-sugar way of writing »readFile "some/path/file.dat" >>= putStrLn"« without using extra variables like »text <- readFile "some/path/file.dat"; putStrLn text«?
07:34:39 <mniip> which is 2 + 1 + 0 + triangle (-1)
07:34:56 <quchen> ?quote socratic
07:34:56 <lambdabot> chrisdone says: It's actually impossible to employ the socratic method in here. Ask a newbie a question and it *will* be answered by someone else.
07:34:57 <Cale> zett_zelett: no
07:35:01 <zett_zelett> k thx.
07:35:12 <EvanR_> at least let him get to -11 on his own
07:35:16 <Cale> zett_zelett: you might prefer =<< though
07:35:28 <Cale> putStrLn =<< readFile "some/path/file.dat"
07:35:35 <markarts> :Cale :mauek ty for the suggestions
07:35:37 <zett_zelett> Uh, didn’t know that existed.
07:35:40 <zett_zelett> Thanks.
07:35:48 <gwm_> triangle(1) =1
07:35:55 <mauke> markarts: what's a weird way of using colons
07:36:04 <quchen> gwm_: Why? All I gave you was "triangle n = n + triangle (n-1)".
07:36:18 <quchen> You know nothing else about triangle from that equation.
07:36:32 <gwm_> Right
07:36:36 <quchen> You can apply it to calculate "triangle 1".
07:36:44 <markarts> :mauke ?
07:36:48 <gwm_> So it's just 2 + 1
07:37:02 <mauke> markarts: why are you putting : before words?
07:37:10 <EvanR_> :markarts youre weird
07:37:11 <mauke> markarts: that's like putting punctuation before the end of the .sentence
07:37:16 <quchen> gwm_: From what I gave you, you cannot deduce that "triangle 1" is "1".
07:37:21 <mauke> markarts: see how weird that ?is
07:37:28 <quchen> gwm_: All you can say is that "triangle 1 = 1 + triangle 0".
07:37:28 <gwm_> Yeah I understand that
07:37:33 <quchen> So that gives you
07:37:38 <voidzero> ¡lol!
07:37:45 <quchen> triangle 2 = 2 + triangle 1 = 2 + 1 + triangle 0
07:38:01 <quchen> gwm_: What's the next step?
07:38:02 <EvanR_> (+ 'x :y $z @w)
07:38:53 <mauke> EvanR_: ITYM (+ 'x :y $z )@w
07:39:19 <mniip> for a second I thought this was #perl
07:39:28 <EvanR_> !@#$
07:39:30 <quchen> \mauke: it's not much weirder than putting a backslash at the wrong end of one's name occasionally :-þ
07:39:37 <mauke> mniip: except for $z that's all lisp
07:40:10 <gwm_> quchen i'll brb in 30 have to go do something, ty for all help people 
07:40:35 <mauke> quchen: that's just an uppercase |
07:41:17 <markarts> ohhh. I wasn't paying attention. did it subconsciously
07:42:07 <quchen> ?quote highlyInterested
07:42:07 <lambdabot> highlyInterested says: *** highlyInterested has joined channel #haskell <highlyInterested> hi! I'm highly interested, but have no attention span!!! <highlyInterested> Can anyone help me?!?!? * highlyInterested runs around!! *** highlyInterested has quit: Client Quit
07:42:34 <mauke> markarts: why are you not using tab completion?
07:42:53 <markarts> tab completion ?
07:43:43 <quchen> markarts: Try typing "lam<tab>" and see what happens.
07:43:52 <mniip> lamilami
07:44:05 <mniip> ;)
07:45:20 <markarts> quchen: oh wow ty. first time using IRC so ty for the tip :D
08:08:30 <hnfmr> what does the hash (pound) sign mean here?
08:08:31 <hnfmr> do pokeElemOff ptr (I# n#) val; go vals (n# +# 1#)
08:08:41 <hnfmr> in a function definition
08:08:54 <mpickering> It's an unboxed literal
08:09:09 <mpickering> see the MagicHash extension
08:09:46 <hnfmr> mpickering: thanks. can I get more info if I read relevant section on GHC docs?
08:09:57 <mpickering> https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/syntax-extns.html
08:10:18 <hnfmr> mpickering: great. cheers
08:11:47 <brainstalked> does anyone know of a game thats made from haskell?
08:13:39 <phaazon> huhu
08:13:40 <brainstalked> it doesnt have to be popular
08:13:44 <phaazon> what’s happening
08:13:46 <phaazon> glx_context.c:(.text+0x8b4): undefined reference to `_glfwSetCurrentContext'
08:13:52 <phaazon> I have that for a lot of functions
08:13:56 <brainstalked> i dont think ive ever seen a game made out of haskell
08:14:01 <brainstalked> phaazon
08:14:14 <EvanR_> phaazon: didnt glfw-b just release a new version
08:14:20 <phaazon> brainstalked: hi
08:14:21 <mpickering> there's #haskell-game I think?
08:14:22 <EvanR_> maybe they fucked up
08:14:31 <phaazon> EvanR_: two days ago, yeah
08:14:51 <EvanR_> brainstalked: there was that FPS a while back
08:15:06 <EvanR_> "Frag"
08:15:14 <phaazon> EvanR_: they fucked up very hard then
08:15:23 <phaazon> it’s a minor increment.
08:15:34 <EvanR_> make sure you have the right versions of the bindings etc
08:15:56 <dredozubov> do we have a paper on "exceptions and composability" topic or something relevant?
08:16:00 <phaazon>     Versions installed: 1.4.7.1
08:16:08 <phaazon> which is the latest
08:16:20 <phaazon> I should use sdl2 I guess
08:17:02 <dredozubov> it would be even better if it's "exceptions vs composability" ;)
08:17:03 <EvanR_> id check out whats going on because blaming GLFW-b
08:17:50 * hackagebot friday-devil 0.1.1.0 - Uses the DevIL C library to read and write images from  and to files and memory buffers.  http://hackage.haskell.org/package/friday-devil-0.1.1.0 (RaphaelJavaux)
08:18:09 <phaazon> EvanR_: I guess they might have forgotten a link somewhere
08:19:04 <phaazon> EvanR_: see https://github.com/bsl/GLFW-b/issues/49
08:19:32 <EvanR_> glad i didnt upgrade
08:19:35 <phaazon> I thought it was me lacking the library
08:19:39 <phaazon> but I do have it installed
08:19:50 <phaazon> EvanR_: you see
08:19:53 <phaazon> upper bounds ;)
08:20:03 <EvanR_> broken is broken, bounds or not
08:20:14 <phaazon> EvanR_: I mean
08:20:16 <phaazon> I can fix that
08:20:19 <phaazon> with upper bounds
08:20:37 <EvanR_> you can fix their screw up with upper bounds?
08:21:15 <phaazon> yeah
08:21:16 <phaazon> in my project
08:21:21 <phaazon> instead of using < 1.4.7
08:21:23 <EvanR_> how?
08:21:29 <phaazon> huh
08:21:36 <phaazon> instead of using < 1.5
08:21:41 <phaazon> I use < 1.4.7
08:21:48 <phaazon> to exclude the recent chhanges
08:21:56 <EvanR_> that doesnt fix their breakage, it just protects you from auto upgrading which is good, but also not auto upgrading also does that
08:22:24 <phaazon> EvanR_: yeah, and I’ll upgrade when they fix the issue :)
08:22:37 <phaazon> I guess I could even do something like
08:22:39 <EvanR_> unless you rage quite and use sdl2 lol
08:22:48 <phaazon> < 1.5 && !1.4.7 && !1.4.7.1
08:22:51 * hackagebot users 0.1.0.0 - A library simplifying user management for web applications  http://hackage.haskell.org/package/users-0.1.0.0 (AlexanderThiemann)
08:22:53 * hackagebot users-postgresql-simple 0.1.0.0 - A PostgreSQL backend for the users package  http://hackage.haskell.org/package/users-postgresql-simple-0.1.0.0 (AlexanderThiemann)
08:22:55 * hackagebot users-test 0.1.0.0 - Library to test backends for the users library  http://hackage.haskell.org/package/users-test-0.1.0.0 (AlexanderThiemann)
08:22:58 <phaazon> EvanR_: yeah
08:23:02 <phaazon> I might do that anyway
08:23:08 <phaazon> because sdl2 has more gamepads support
08:23:19 <EvanR_> does it?
08:23:50 <EvanR_> the both seem to have access to the ancient "joystick is a file" technology
08:24:34 <phaazon> hm
08:24:38 <phaazon> I might know!
08:24:45 <phaazon> I might need to update my C glfw!
08:25:00 <phaazon> phaazon@illusion ~/dev/initialrevision % pacman -Qi glfw                master 
08:25:00 <phaazon> Name           : glfw
08:25:00 <phaazon> Version        : 3.1-1
08:25:06 <phaazon> hm, it doesn’t tell me shit…
08:25:26 <EvanR_> glfw 3.1 is the latest
08:25:33 <phaazon> ok, so they screwed up
08:25:45 <EvanR_> the bindings were still exporting 3.0 as far as i know
08:25:46 <phaazon> it works again with GLFW-b-1.4.6
08:25:53 <EvanR_> until now
08:26:05 <EvanR_> lots of good stuff in there
08:26:05 <phaazon> they don’t maintain a changelog
08:26:07 <phaazon> what a pity
08:26:33 <EvanR_> theres been github chatter about this on GLFW-b and the for some reason separate bindings repo
08:41:02 <hesiod> Why does linear check whether the determinant is near zero in its inv22/inv33/inv44 functions (https://github.com/ekmett/linear/blob/master/src/Linear/Matrix.hs#L370)?
08:41:10 <hesiod> Is it about floating point precision?
08:41:43 <carter> zero is a neighborhood in finite precision land :)
08:43:40 <Cale> hesiod: Because if the determinant is zero, the matrix is not invertible, but rounding errors can occur in computing the determinant which you have to allow for. If the determinant is very close to zero, the chances are good that even if what you got back from the formula for the inverse didn't involve NaN or Infinity, it still likely wouldn't be very good numerically.
08:43:44 <hesiod> carter: But wouldn't it be ridiculous if I had to devert to some arbitrary-precision math library just for computing some inverse matrices? That would be overkill!
08:44:00 <carter> i dont understand your question
08:44:08 <carter> you dont have magic infinite precision 
08:44:24 <carter> at some point you have to say "is this near zero enough to be zero for my problem domain"
08:44:29 <EvanR_> "just for computing some inverses"
08:44:36 <EvanR_> piece of cake
08:44:38 <hesiod> carter: Well, I need that inverse matrix. I'm using Doubles. What options do I have other than employing something mpfr-like?
08:44:52 <carter> umm, fix your problem so its not ill conditioned
08:45:13 <carter> det(m) near zero === your problem might be ill conditioned and you need to reformulate it
08:45:39 <hesiod> carter: I will have a look at it again
08:46:18 <carter> a good trick for low dim linear algebra is ask "how does my matrix transform the corners of a cube"
08:46:33 <carter> it it looks so pointy and skinny that det is near zero
08:47:02 <Cale> hesiod: Matrices don't easily get determinants within 1e-12 of zero by chance.
08:47:43 <carter> yeah
08:47:48 <Cale> The probability if you select the entries at random from a continuous distribution (like a Gaussian distribution) is similarly small
08:48:25 <carter> random matrices are REALLY well behaved
08:48:59 <Cale> Yeah, similarly most matrices are diagonalisable
08:49:34 <carter> probabilyt 1 you have a full rank matrix if its a random square matrix right?
08:49:50 <carter> its that measure zero set that happens half the time thats the problem :)
08:50:03 <Cale> yeah
08:50:31 <Cale> assuming the random distribution you're using to pick the entries is continuous
08:53:15 <carter> yah
08:53:22 <Cale> (like, if you have a 1/3 probability of picking 0 and 1/3 probability of picking 1, and then a 1/3 probability of picking a normally distributed real number, then this doesn't work anymore)
08:53:28 <carter> true
08:53:44 <carter> Cale: actually thats a really good distribution for doing sparsity preserving dimension reduction
08:53:45 <carter> roughly
08:55:12 <hesiod> Cale, carter: Turns out you were right - I don't actually need the inverse...
08:55:18 <carter> yay
08:55:34 <carter> first rule of matrix math: you never ever need the explicit matrix inverse ever
08:55:38 <carter> dont ever bother getting it
08:55:43 <Cale> haha
08:55:44 <carter> you'll get sad instead
08:56:00 <carter> #numerical-haskell is  a fun channel for this and other madness too :)
08:56:15 <carter> hesiod: though since you're using linear, i imagine #haskell-game might be fun too
08:56:44 <hesiod> carter: you hit the nail on the head
08:57:52 * hackagebot chaselev-deque 0.5.0.5 - Chase & Lev work-stealing lock-free double-ended queues (deques).  http://hackage.haskell.org/package/chaselev-deque-0.5.0.5 (RyanNewton)
09:00:11 <Cale> Man... that implementation doesn't appear to use any of our nice concurrency abstractions.
09:00:42 <Cale> It had better get good performance :)
09:04:47 <carter> woah, he made a new relasee
09:05:28 <carter> https://github.com/rrnewton/haskell-lockfree/blob/master/chaselev-deque/Data/Concurrent/Deque/ChaseLev.hs
09:07:33 <enthropy> "It is tempting to write the last line as [Branch x' l' r' | x' <- shrink x, l' <- shrink l, r' <- shrink r] but this is the wrong thing! It will force QuickCheck to shrink x, l and r in tandem, and shrinking will stop once one of the three is fully shrunk"
09:08:21 <enthropy> doesn't the text description describe [ Branch x' l' r' | (x',l',r') <- zip3 shrink shrink shrink ]?
09:11:36 <Cale> enthropy: does that typecheck? What?
09:12:03 <mauke> Cale: ?
09:12:29 <mauke> oh, the missing arguments
09:12:53 <enthropy> pretend they are there
09:13:13 <enthropy> [ Branch x' l' r' | (x',l',r') <- zip3 (shrink x) (shrink l) (shrink r) ]
09:13:20 <Cale> enthropy: Well, you want to shrink exactly one of x, l, or r
09:13:40 <Cale> never all three at once
09:13:59 <Cale> I don't think the text is referring to zip3 in any way
09:14:00 <mauke> what is the actual "last line"?
09:14:50 <Cale> I believe the actual last line should look something like [Branch x' l r | x' <- shrink x] ++ [Branch x l' r | l' <- shrink l] ++ [Branch x l r' | r' <- shrink r]
09:14:57 <safinaskar> how to import System.Random module (as described in "learn you a haskell") in ghc 7.6.3?
09:15:05 <taruti> Any examples of "implicitely lifting cons" infixr operator "class T t where ($:) :: t -> M [X] -> M [X]; instance T X where ($:) x xs = (:) x <$> xs; instance T (M X) where ($:) x xs = liftA2 (:) x xs" ? Except something that works :)
09:15:17 <safinaskar> ghc 7.6.3 says "Failed to load interface for `System'. It is a member of the hidden package `haskell98-2.0.0.2'"
09:15:27 <enthropy> Cale: that's what the instance for Arbitrary (a,b,c) does
09:15:38 <Cale> safinaskar: That error message is complaining about System, not System.Random
09:15:50 <safinaskar> Cale: okey, so how to import it?
09:15:52 <Cale> safinaskar: It seems like you have  import System
09:15:56 <enthropy> mauke: it's [Branch x' l' r' | (x', l', r') <- shrink (x, l, r)]
09:15:57 <mauke> safinaskar: import System.Random
09:16:00 <Cale> use   import System.Random   instead
09:16:18 <Cale> enthropy: Oh, right, that's more concise
09:16:35 <carter> as of friday afternoon i'm also the maintainer of random :-|
09:16:36 <Cale> enthropy: It makes use of the fact that shrink for triples does what I did :)
09:16:51 <carter> i thought ghc doesn't ship with random though..
09:18:02 <safinaskar> Cale: mauke: okey, i typed "imports" instead of "import" in ghci :). but if i type "import" i get errors, too. "import System" reports "Could not find module `System'. It is a member of the hidden package `haskell98-2.0.0.2'.". and "import System.Random" reports "Could not find module `System.Random'. It is not a module in the current program, or in any known package."
09:18:17 <safinaskar> so, how?
09:18:20 <mauke> safinaskar: import System.Random
09:18:32 <mauke> I don't know why you keep talking about "import System"
09:18:34 <Cale> safinaskar: cabal install random
09:20:20 <safinaskar> Cale: mauke: "sudo apt-get install libghc-random-dev" helped me (on my debian), thanks
09:22:54 * hackagebot svgcairo 0.13.0.2 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.13.0.2 (HamishMackenzie)
09:31:46 <meretrix> If I have a type "data Wrapper = WrapEvent1 Event1 | WrapEVent2 Event2 | ..." and all the Events are instances of "class Event a where eventTime :: a -> UTCTime", is there a way to take a wrapped event and get its time without having to pattern match every constructor?
09:33:54 <Cale> meretrix: Not really, no.
09:37:55 * hackagebot friday-devil 0.1.1.1 - Uses the DevIL C library to read and write images from  and to files and memory buffers.  http://hackage.haskell.org/package/friday-devil-0.1.1.1 (RaphaelJavaux)
09:44:25 <BadCodSmell> Among professionals, has anyone had difficulties with academic/theoritical/toolkit elitism in haskell versus practical, experience based and realistic approaches to problems?
09:45:18 <carter> i use theory in production code all the time
09:45:28 <EvanR_> i had people dismiss me from interviews on haskell grounds
09:45:34 <BadCodSmell> So do I but some people can be one sided.
09:45:51 <BadCodSmell> And at this point I do not know how to help them bridge that gap beyond being mean.
09:45:53 <hodapp> No, but I've had issues with the elitism people develop from thinking that their solution is the only "practical, experience based, and realistic" one.
09:45:54 <Welkin> interviews are shit
09:45:56 <EvanR_> sometimes people are anti-elitist
09:46:02 <carter> i think one sublety is if you accidentaly imply you'll rewrite their code in haskell, that scares people
09:46:08 <Welkin> the entire industry is fucked
09:46:13 <haasn> @tell roconnor Data.Colour.CIE could use some functions for computing deltaE metrics.
09:46:14 <lambdabot> Consider it noted.
09:46:19 <carter> "i'll rewrite stuff in a language you know into one you dont"
09:46:26 <EvanR_> i.e. elitism of the proletariat
09:46:39 <hodapp> EvanR_: part of why I left the last job.
09:46:40 <Welkin> random engineer from a company come up with their own interview questions, and pass on people who they don't want to drink a beer with
09:46:42 <exio4> carter: you're gonna get fired! muahaha! 
09:46:47 <BadCodSmell> carter: When there is no real benefit to this, it is considered harmful.
09:47:05 <hodapp> EvanR_: "Languages are obviously pretty much all the same, so just use whichever one we already know."
09:47:19 <exio4> brb using brainfuck 
09:47:37 <funfunctor> Welkin: the entire industry is fucked " <~ could not find finer words myself good sir !!!
09:47:59 <BadCodSmell> haskell tends to have a lot of mathematical background and people can come onto the scene applying this without really knowing about programming in general, there is a wide divide between doing a thing and studying general concepts related to it
09:48:33 <EvanR_> i take it you have a lot of experience in both
09:48:37 <BadCodSmell> So the net result can be someone applying a lot of solutions, many of them nice on and of themselves, but not really appropriate or necessary. There tends to be a lot of lack of real understanding of real world problems.
09:48:51 <BadCodSmell> Not enough to be able to effectively help others bridge this gap
09:49:21 <EvanR_> a good start is knowing that you dont know stuff
09:49:26 <BadCodSmell> So I wonder if anyone else did/how they did it
09:49:53 <hodapp> We're talking about Haskell, not "Design Patterns", though.
09:49:54 <Cale> BadCodSmell: Can you give an example of what you mean?
09:50:17 <funfunctor> everyone has lots of "views" while critical systems around us are written in C with classes of bugs which have been "theoretically solved" long ago.. People think fixing compiler warnings are stupid, People "think"..
09:50:35 <BadCodSmell> Cale: The "know it all" for example contests every tool I use under the basis of it not being automatically scalable across cores.
09:50:52 <BadCodSmell> Many of these tasks are very light load and will never need to be multithreaded.
09:51:11 <EvanR_> running separate tasks on different cores is one thing, "scaling" a problem to be solved in parallel is something else
09:51:15 <taruti> funfunctor: then again what makes economic sense and what is right can unfortunately be different in projects :(
09:51:49 <funfunctor> taruti: true however these systems are actually costing /more/
09:51:50 <Cale> Whoa, I don't even understand how that relates to what was said above.
09:51:58 <EvanR_> BadCodSmell: luckily the basic pattern of concurrency doesnt care what or how many cores you run on
09:52:02 <taruti> funfunctor: it really depends
09:52:31 <hodapp> extra complexity is rarely cheaper in the long run.
09:52:34 <funfunctor> taruti: studies indicate that things are going to blow up both in $$ and "bad things"
09:52:41 <mietek> ski: ping
09:53:04 <taruti> funfunctor: actually it heavily depends on the project and the alternatives
09:53:04 <mietek> Does anyone happen to have an archived copy of ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/ ?
09:53:09 <BadCodSmell> From what I see, the use of haskell for the tasks at hand is costing us a lot more.
09:53:11 <hodapp> funfunctor: what such studies?
09:53:22 <hodapp> funfunctor: I've only ever found a few, so I'm always delighted to hear of others.
09:53:33 <mietek> ski: do you happen to have an archived copy of ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/ ?
09:53:50 <EvanR_> using haskell or any language for real work takes training and experience
09:53:58 <Cale> BadCodSmell: What are you using Haskell for?
09:54:00 <EvanR_> big difference between hobbies and work
09:54:01 <BadCodSmell> EvanR_: yes :)
09:54:11 <funfunctor> hodapp: lockheed and esa did a fair number of studies about project timelines vs system faults vs $
09:54:25 <mietek> The web site is still online, but all the source/code links are dead: http://pll.cpsc.ucalgary.ca/charity1/www/home.html
09:54:36 <hodapp> funfunctor: what about the project timelines in particula?
09:54:37 <hodapp> +R
09:54:47 <Welkin> mietek: try the web archive
09:54:53 <EvanR_> BadCodSmell: and the amount of training and experience is haskell available on the market is probably not very viable
09:54:55 <Cale> BadCodSmell: Also, a lot more than what?
09:54:59 <EvanR_> in haskell
09:55:03 <mietek> Welkin: doesn’t appear to cover FTP
09:55:08 <BadCodSmell> Cale, web bases stuff, etc, well it have become a big monolith of a system spanning several areas it shouldn't (mixing passive components with active ones) where DSLs in common languages that everyone else can access are used otherwise in a very modular fashion.
09:55:33 <funfunctor> hodapp: came down to having clear specifications so directions were not so fluid while the dev life-cycle was in full spin
09:56:22 <funfunctor> things are going to get a lot worse. Heck UEFI is around the same size as the Linux kernel
09:57:01 <BadCodSmell> Though the real problem I have is teaching someone when to use haskell and when not to, for example, when the benefits aren't realised, when it's not good for business/team cohesion, etc.
09:57:08 <funfunctor> ACPI is coming to ARM (actually its basically here). So yea ACPI in your phone :p
09:57:25 <Cale> BadCodSmell: Using Haskell vs. using what?
09:57:39 <funfunctor> BadCodSmell: first what are the requirements
09:57:53 <EvanR_> funfunctor: get shit done yesterday
09:58:04 <EvanR_> disregard maintainability
09:58:05 <hodapp> requirements: must use mediocre techniques so that we can easily find people to hire to help us be mediocre
09:58:05 <Zoetrope_> I've read above and I'm with Cale at a few parts, BadCodSmell you seem to be jumping around a lot
09:58:11 <Cale> Haskell is just a programming language, you use it for the most part in cases where a general purpose programming language would be appropriate, and you happen to enjoy programming in Haskell.
09:58:11 <hodapp> sorry, did I say mediocre? I meant "industry-standard"
09:58:11 <Rotaerk> haskell vs javascrapt
09:58:12 <funfunctor> project requirements + project specification
09:58:17 <funfunctor> EvanR_: haha :)
09:58:49 <BadCodSmell> JS, C, Shell scripts, php, etc. Common solutions to problems that have worked for years, are mature, tried and tested.
09:58:55 <EvanR_> Rotaerk: yeah a lot of startups now using javascript for infrastructure
09:59:04 <Rotaerk> there's this anime with all the countries personified by a character... they should do the same for programming languages
09:59:08 <hodapp> And they're proven.
09:59:09 <Rotaerk> wonder how haskell would be
09:59:09 <funfunctor> I'm a huge advocate of using Haskell not to program in Haskell. i.e. EDSL
09:59:11 <hodapp> Proven to be what, I won't say.
09:59:19 <EvanR_> node.js, worked for years, mature, tried and tested
09:59:23 <carter> lol
09:59:30 <Zoetrope_> Every line of PHP is unspecified behavior
09:59:36 <BadCodSmell> productivity + stable enough, etc
09:59:38 <hodapp> Zoetrope_: even comments?
09:59:47 <funfunctor> when is uefi.js coming is the real question?
09:59:48 <codehero> could someone explain me why this works?
09:59:50 <codehero> (<*>) f a = (<$> a) =<< f
09:59:50 <EvanR_> Rotaerk: if programming languages were anime characters
09:59:52 <Zoetrope_> hodapp: Not in the spec!
09:59:55 <kadoban> hodapp: Would honestly not be that surprised if that was true.
09:59:59 <hodapp> o_O
10:00:10 <Cale> BadCodSmell: A lot of Haskell stuff is pretty mature and well-tested at this point.
10:00:12 <Zoetrope_> There is no spec, or was no spec, maybe there is now
10:00:12 <BadCodSmell> PHP and JS can be awful especially with the low bars to entry but if you know what you're doing, run a proper shop then actually they offer very high productivity.
10:00:15 <Cale> BadCodSmell: You'd have to be more specific
10:00:23 <hodapp> BadCodSmell: "if you know what you're doing", "proper shop"
10:00:26 <carter> i'm helping some folks write a hardened/secured web api service in haskell currently, its suprisingly easy
10:00:29 <BadCodSmell> Cale: But the company is not a haskell company and the readability of haskell is awful.
10:00:41 <EvanR_> BadCodSmell: ive had a lot of trouble with "productivity" using JS and PHP for things
10:00:48 <hodapp> BadCodSmell: those phrases are so vague they can let you completely ignore the design of a language.
10:00:51 <BadCodSmell> Additionally, everything else is written in more common languages.
10:00:53 * carter debates getting dibblego  to opine :)
10:01:14 <funfunctor> readability of Haskell isn't awful !
10:01:15 <Cale> BadCodSmell: If your complaint is "we're attempting to program in Haskell and we suck at it", well, I dunno -- you have a couple of options. You can program in something else, or you can get better at Haskell.
10:01:20 <funfunctor> change your font
10:01:20 <hodapp> BadCodSmell: you can write "good code" in any language at all "if you know what you're doing" and run a "proper shop"
10:01:21 <BadCodSmell> hodapp: My point is, there's more to a language that simply, is it better than this. You also have environments, etc
10:01:36 <hodapp> BadCodSmell: because if you can't, well, clearly you didn't know what you were doing and you didn't run a proper shop.
10:01:39 <BadCodSmell> hodapp: basically, but if you build a house, you can't have each builder bring their own bricks.
10:01:41 <hodapp> BadCodSmell: it's one massive tautology.
10:01:58 <hodapp> BadCodSmell: if you know what you're doing and you have proper instructions, you can have each builder bring their own bricks.
10:02:14 <EvanR_> BadCodSmell: then theres twitters github using 19 different programming languages ;)
10:02:37 <funfunctor> if your Haskell is hard to read, much like any language for that matter, then its not the language at fault. It is something you are doing, anti-patterns and so on..
10:02:37 <hodapp> BadCodSmell: if you know what you're doing and you have proper instructions, it doesn't even matter what the bricks are made of, or if they're even there.
10:02:37 <BadCodSmell> It's not an open source project.
10:02:56 <BadCodSmell> And mixing bricks is nearly almost always problematic unless you plan on building a clown house.
10:03:04 <Rotaerk> funfunctor, it's also possible that it's hard to read just because it's conceptually difficult
10:03:11 <hodapp> BadCodSmell: No, mixing bricks is only problematic if you don't know what you're doing, or you don't run a proper shop.
10:03:15 <Rotaerk> haskell code often involves a lot more abstractions than the code in other languages
10:03:16 <BadCodSmell> It's also less efficient because it means each worker ends up stuck on one area, no transferability.
10:03:17 <Welkin> analogies like that are useless
10:03:25 <Welkin> you may as well use a car analogy
10:03:31 <hodapp> BadCodSmell: It's only less efficient if you don't know what you're doing.
10:03:32 <Welkin> they are just not the same thing
10:03:42 <EvanR_> Welkin: if programming languages were cars
10:03:47 <funfunctor> Rotaerk: that is rare once you actually know how to program in said langauge.
10:03:51 <hodapp> EvanR_: ...then my car would probably be COBOL.
10:03:54 <BadCodSmell> hodapp: even if you know what you're doing, it's less efficient.
10:04:13 <carter> BadCodSmell: less efficient than hand tuned c+assembly yeah
10:04:16 <hodapp> BadCodSmell: and this is why design matters.
10:04:17 <carter> but only sometimes
10:04:29 <funfunctor> the uni UNSW still teaches FORTRAN in its physics & math dep
10:04:45 <EvanR_> you should probably switch to fortran
10:04:50 <hodapp> BadCodSmell: the fact that someone has found a way to make it physically possible doesn't mean the language's design is completely irrelevant.
10:05:08 <funfunctor> EvanR_: yea, they could atleast switch to the lower case dialect
10:05:13 <Zoetrope_> I'm not sure I understand the point of this conversation
10:05:22 <funfunctor> Zoetrope_: same
10:05:23 <BadCodSmell> Zoetrope_ it went off topic
10:05:27 <carter> funfunctor: i'm slowly working on fighting fortran
10:05:31 <carter> :)
10:05:46 <funfunctor> I just like saying computers are fucked
10:05:55 <BadCodSmell> I wanted to know if anyone has some experience bridging the gap from being studied to being practiced and if they had any pointers on this.
10:06:05 <mietek> Found it.  https://synrc.com/publications/cat/Functional%20Languages/Charity/
10:06:15 <EvanR_> BadCodSmell: i do
10:06:31 <funfunctor> BadCodSmell: well Hackage has many packages that are based off research papers being used in real systems
10:06:40 <EvanR_> and i gave up trying to reason with people
10:06:50 <EvanR_> so i guess thats my tip
10:06:54 <BadCodSmell> Haha
10:07:00 <Cale> BadCodSmell: Basically bridging that gap is just doing stuff with what you know.
10:07:04 <carter> BadCodSmell: i'm the second haskeller in a new team at an org that has > 10k java devs, and we're already doing some things that would be quite a bit more work if written in java
10:07:10 <hodapp> BadCodSmell: Do you want some pointers on this? Quit assuming that the fact that something is used in the "real world" means it is in some inherent sense "practical".
10:07:34 <BadCodSmell> hodapp: You clearly misinterpreted that.
10:07:41 <hodapp> BadCodSmell: You clearly miscommunicated that.
10:07:47 <EvanR_> the amount of people you can find you help you for what price has a lot to do with practicality
10:08:04 <Cale> BadCodSmell: Haskell is (at least in my opinion), at least among the language which are seeing much industry use, one of the best with respect to being able to write things in a style where you can reason about what code means effectively. Of course, that assumes you're actually somewhat experienced, both while writing the code and reading/understanding it.
10:08:05 <hodapp> EvanR_: the number of people who you end up *needing* to help you has a lot to do with practicality
10:08:14 <Cale> languages*
10:08:17 <BadCodSmell> I am being constantly told that these conventional languages and tools are not up to anything because of their theoretical inferiority despite them being behind billion dollar industries.
10:08:17 <funfunctor> If English was a programming langauge we would all get along like a big happy complex system <g>
10:08:42 <hodapp> BadCodSmell: I don't believe you're constantly told that. I believe you're perhaps periodically told something that is a small shadow of that.
10:09:08 <EvanR_> BadCodSmell: thats the labor theory of value, its worth the amount of money people waste on it
10:09:10 <Cale> BadCodSmell: It's not that other languages are not up to various tasks -- obviously it's possible to accomplish a lot in C or PHP or whatever.
10:09:15 <pleasant-pyon> Does it ever make sense for a Foldable instance not to be a Functor?
10:09:22 <Zoetrope_> Well I've heard people working for finance companies talk about the terrible C++ codebases they maintain
10:09:27 <Zoetrope_> Things can be bad and widely used
10:09:27 <BadCodSmell> EvenR: I'm talking about the money these tools/languages make.
10:09:36 <hodapp> Zoetrope_: what, finance?
10:09:49 <Zoetrope_> As in Bloomberg, etc
10:09:53 <FreeFull> What do Haskellers in general think about Rust?
10:09:56 <BadCodSmell> Most codebases are terrible :(
10:09:59 <EvanR_> BadCodSmell: how much money they make is partially a function of how much you waste employing them
10:10:05 <hodapp> FreeFull: looks neat, wish I had time to look at it more.
10:10:20 <hodapp> FreeFull: there's one Haskeller's opinion!
10:10:33 <EvanR_> BadCodSmell: the space shuttle must have been the best spacecraft possible, because of the amount of money it wasted
10:10:55 <EvanR_> dont worry about facts
10:11:06 <Welkin> there are no facts in this building
10:11:48 <BadCodSmell> EvanR_: Knowledge and training in appropriate enough tools saves most of the money versus particular tools unless the tools are grossly inappropriate. Except for specific domains, going down the haskell/functional/pure/mathematicians language versus any other DSL, etc just means diminishing returns/premature optimisation.
10:11:56 <hodapp> BadCodSmell: [citation needed]
10:12:10 <Zoetrope_> Yeah that's crazy talk BadCodSmell
10:12:13 <EvanR_> BadCodSmell: im convinced
10:12:13 <Cale> BadCodSmell: Haskell is pretty general purpose.
10:12:24 <Welkin> BadCodSmell: you are assuming that the developers working on the project are coming from an imperative/oop background
10:12:29 <JaAnTr> Hi, I'm having a few issues with a mini imperative language I'm implementing. My boolean expressions are giving me errors when compiling. If someone could take a look that would be great - http://pastebin.com/bPKJG91M
10:12:33 <Cale> BadCodSmell: How much Haskell programming have you done?
10:12:37 <Welkin> if they already know haskell and are familiar with FP, then you are wrong
10:12:45 <Zoetrope_> Your problem is you view FP as fundamentally fringe
10:13:15 <Welkin> haskell is the easiest language for me to use
10:13:17 <EvanR_> ive become unable to function in a heavily OOP work environment, dont hire me
10:13:44 <hodapp> When you get into, well, most software, basically all details, and in many cases large, central problems it solves (whether people acknowledge them or not), are *all* specific domains.
10:14:17 <hodapp> You can pretend it's just some sort of "general" problem, and half-ass your way through it, yes.
10:14:32 <lpaste> Cale pasted “JaAnTr's code” at http://lpaste.net/124178
10:14:49 <Cale> JaAnTr: could you annotate the paste with the error you're getting?
10:14:49 <carter> theres also the whole confounding matter of "you already have a huge code base youre stuck with" vs "you have a new project"
10:14:52 <carter> wrt tool choice
10:15:51 <jberg_> hi, i have a single .hs file where i have module Foo where import Data.ByteString.Lazy and compile it with ghc -c foo.hs ghc foo.o -o foo but then i get undefined reference to ByteString (if i just do runghc foo.hs it works)
10:16:07 <JaAnTr> Cale: I edited that link and put the errors at the bottom, I hope that's what you meant - http://lpaste.net/124178
10:16:23 <EvanR_> jberg_: try ghc --make foo.Hs
10:16:28 <Cale> JaAnTr: yeah, that helps me help you :)
10:16:32 <jberg_> EvanR_: hmm ok
10:16:35 <hodapp> To quote Dijkstra, "The problems of the real world are primarily those you are left with when you refuse to apply their effective solutions."
10:17:20 <jberg_> EvanR_: no luck. btw, does foo.hs need to have capital F like Foo.hs?
10:17:29 <EvanR_> jberg_: id do that
10:17:30 <Cale> JaAnTr: So, the first message is on line 75: Couldn't match expected type ‘Bexp’ with actual type ‘Aexp’ In the first argument of ‘evalB’, namely ‘a’ In the expression: evalB a s0
10:17:44 <Cale> JaAnTr: Line 75 appears to be: evalB (a :<=: b)  s0 = let (s1, na) = evalB a s0; (s2, nb) = evalB b s1 in (s2, na <= nb)
10:17:52 <jberg_> EvanR_: okay, but can it be the source of the problem?
10:18:05 <EvanR_> jberg_: ghc -c whatever doesnt actually create a program
10:18:13 <EvanR_> you have to link
10:18:16 <Cale> JaAnTr: and indeed, the arguments to the constructor (:<=:) are Aexp values, and not Bexp values
10:18:25 <EvanR_> such as ghc Foo.hs where Foo.hs contains a main
10:18:34 <Cale> JaAnTr: given that you have an evalA function, you probably meant to use that.
10:18:42 <Cale> (to evaluate a and b)
10:20:09 <jberg_> EvanR_: i know, i just did that because im learning how to write makefiles so i did it a bit more complicated
10:20:10 <BadCodSmell> Cale: None. But in conventional languages I produce far more than my collegue does in Haskell but also I am able to get many others involved and scale as a team.
10:20:32 <EvanR_> jberg_: well i wouldnt expect the program to work if i didnt compile it before running it
10:20:33 <jberg_> EvanR_: but if i do ghc foo.hs or runghc foo.hs it works, but not ghc foo.o
10:20:40 <JaAnTr> Cale: Ah I see what you're saying. This is built upon code I've been given a few weeks ago. I've edited the paste again with the original code. How come sometimes EvalA is used and sometimes EvalB?
10:20:51 <hodapp> BadCodSmell: Yes. It's normal that in "conventional" languages, it requires substantially more code, as well as more help from colleages, to solve the same problems.
10:20:59 <Cale> BadCodSmell: Well, that has nothing to do with Haskell specifically, it's more about your colleague's experience using it, and the experience of other people you happen to be around.
10:21:23 <JaAnTr> Cale: Also, just changed the first two constructors to EvalA and have gone from 6 errors to 2 :)
10:21:26 <EvanR_> jberg_: make? perhaps try ghc --make or cabal
10:21:27 <jberg_> EvanR_: it works with ghc foo.hs or runghc foo.hs, but not ghc -c foo.hs\n ghc -o foo foo.o
10:21:49 <EvanR_> jberg_: indeed if you manually link you have to include all of the runtime object files
10:21:57 <EvanR_> and the libraries
10:22:00 <Cale> JaAnTr: evalA appears to evaluate an arithmetic expression, getting an Integer result
10:22:16 <Cale> JaAnTr: while evalB evaluates a boolean expression, getting a Bool result
10:22:18 <jberg_> EvanR_: ah okay, thanks
10:22:22 <EvanR_> jberg_: doing that and using make are pretty non standard
10:22:41 <JaAnTr> Cale: The only issue is the "evalB (Neg b)     s = not (evalB b s)" this is the code I was given but I haven't changed it so it returns a state and a boolean. Would you be able to explain how to negate a boolean so it fits with the type signature?
10:22:54 <BadCodSmell> Cale: It's not entirely, but it's the problems are linked to a mindset that tends to exist particularly heavily in haskell, for example, hodapp does not help with language wars myths and arguments :D. This is the mindset I have problems battling, IE, there's no best language in general, just situations and the best languages/tools for those.
10:22:57 * hackagebot svm-light-utils 0.1.2 - Parsers and formatters for the SVMlight input file format  http://hackage.haskell.org/package/svm-light-utils-0.1.2 (BenGamari)
10:23:30 <BadCodSmell> Poor use of IE there
10:23:56 <Cale> I'm not even sure there's such a thing as best tools
10:24:05 <Cale> for a specific problem
10:24:11 <hodapp> BadCodSmell: Did you actually have something you wanted to disagree on, or just felt the need to take a potshot at something I said?
10:24:13 <BadCodSmell> For any given situation, some will be better than others.
10:24:14 <Cale> But there are good ones
10:24:34 <Cale> Once you define what "better" means, perhaps.
10:24:36 <BadCodSmell> hodapp: That you say haskell will always let you do things in less code.
10:24:56 <hodapp> BadCodSmell: No one said "always". Please read what I said.
10:25:12 <BadCodSmell> The implication is enough.
10:25:14 <hodapp> BadCodSmell: You should do a better job not misrepresenting what people tell you abotu functional languages.
10:25:28 <hodapp> BadCodSmell: No, the implication is not enough. I said it the way I said it for a reason. Don't exaggerate it.
10:25:31 <Cale> BadCodSmell: In my experience, it *is* often true that Haskell programs are shorter than their counterparts in some other languages, but that's not really the biggest benefit of using it typically.
10:26:06 <BadCodSmell> It's that its explicit and you can do a lot of stuff with it in complication.
10:26:39 <EvanR_> BadCodSmell: if youre the manager, i suggest concentrating more on learning haskell so you can help people. if you cant do that, then its probably better to unilaterally make everyone stop using haskell for your own sake
10:26:46 <BadCodSmell> I know this a lot from the otherside/using dynamic languages :D. IE, static analysis for security, etc is not so easy.
10:27:27 <Cale> A much larger benefit is that the manner in which effects are expressed in Haskell makes testing things in isolation far more effective and meaningful.
10:27:46 <Zoetrope_> Safety trumps everything else for me in programming now
10:27:57 * hackagebot ireal 0.2.1 - Real numbers and intervals with relatively efficient exact arithmetic.  http://hackage.haskell.org/package/ireal-0.2.1 (sydow)
10:28:05 <BadCodSmell> EvanR_: It's not really worth it when that is a one sided relationship.
10:28:18 <EvanR_> BadCodSmell: thats exactly what i was getting at
10:28:44 <Cale> BadCodSmell: I do recommend learning some Haskell if you haven't tried it. It's a lot of fun to program in.
10:29:58 <Cale> BadCodSmell: Definitely takes a bit of getting used to though. I knew a dozen or so programming languages already when I started programming in it, and it was a bit like learning to program from the beginning again.
10:30:04 <BadCodSmell> A lot of languages are but they don't all afford my time :P
10:30:20 <EvanR_> clocks ticking
10:30:27 <Cale> It's definitely worth the time you put into it, imo.
10:30:28 <hodapp> BadCodSmell: What are some other languages that are 'fun' to program in?
10:30:40 <BadCodSmell> hodapp: Most of them.
10:30:44 <BadCodSmell> I like programming.
10:30:52 <exio4> Cale: haskell made me love programming again, <3
10:31:12 <hodapp> BadCodSmell: Most of them are "fun" to program in when they're not being used in the "real world".
10:31:29 <EvanR_> i.e. like esoteric languages
10:31:51 <BadCodSmell> hodapp: I do use them in the real world.
10:32:04 <hodapp> BadCodSmell: I highly doubt you've used "most of them" in the real world.
10:32:13 <Zoetrope_> It seems to me that you have some problem with Haskell but you don't actually know it at all?
10:32:26 <BadCodSmell> The problem is it's my buddy who acts like this is a hobby rather than a business.
10:33:00 * EvanR_ sends BadCodSmell's complaints to haskell CEO
10:33:00 <hodapp> BadCodSmell: I've probably only used 20-25 in the "real world" in the past decade, and that's a tiny, tiny minority.
10:33:05 <Zoetrope_> What has that got to do with Haskell? It seems like you want to throw the baby out with the bath water
10:33:06 <BadCodSmell> Zoetrope_: No, in the right place/situation haskell is fine. I have a problem with rigid mindsets about haskell.
10:33:27 <Zoetrope_> Yeah, so the problem all humans face in almost every area of life?
10:33:46 <Cale> BadCodSmell: In any case, if you doubt that Haskell can be useful for real world tasks, but don't actually know enough about it to be able to evaluate whether that's the case or not, I suppose I could tell you that I'm of the opinion that it's useful in many real world business settings.
10:33:58 <Cale> BadCodSmell: I'm not sure that means anything at all to you though.
10:34:11 <Zoetrope_> I understand where you're coming from but it's making you form opinions of Haskell that don't relate to it at all really
10:34:21 <hodapp> BadCodSmell: Perhaps we have a problem with trying to blindly apply what amounts to a generic watered-down relativism in a way that overrides more specific experiences.
10:34:28 <Cale> BadCodSmell: There are quite a few companies where Haskell is in use in various capacities. My last several jobs were all Haskell programming jobs.
10:35:16 <Zoetrope_> I think I've had a similar conversation too many times and I guess my point is always: Learn a bit of Haskell then come back
10:35:23 <BadCodSmell> Cale I don't doubt that :) and hodapp that sounds fairly accurate.
10:37:32 <hodapp> BadCodSmell: Please don't take this the wrong way, but you come off as young, inexperienced, and attempting to wield some naive, vaguely philosophical principle to combat a mindset you observe from the outside and disagree with not on any specifics but on it violating that principle.
10:37:37 <hexagoxel> is there really no readProcessWithExitCode where i can set the working directory?
10:37:37 <hodapp> BadCodSmell: And I suspect most people here are reacting to that.
10:37:54 <Zoetrope_> hodapp: Yes, perfect summary of what I was thinking
10:38:29 <hexagoxel> i began building a new function, but i have to copy half of System.Process, because they do not expose any of their stuff :/
10:38:57 <EvanR_> System.Process is kind of weird
10:39:13 <EvanR_> but i assumed it was like that because windows
10:39:25 <quchen> pleasant-pyon: Set is Foldable but not Functor
10:39:27 <hodapp> BadCodSmell: If you talk down to people from that philosophical standpoint, expect to be talked down to in return.
10:39:32 <BadCodSmell> hodapp: No, I'm just asking for advice in the enemy camp how to bring someone a bit fanatical about haskell into reality.
10:39:41 <hodapp> BadCodSmell: This is what I'm talking about.
10:39:50 <EvanR_> hodapp: well he probably was so thats a good reason not to
10:40:04 <Zoetrope_> BadCodSmell: Learn Haskell then you can tell what's valid and invalid
10:40:07 <pleasant-pyon> quchen: Mmm... In a sense, Set is a "Functor" whose domain is the category of Ord types with monotone morphisms.
10:40:09 <Zoetrope_> There is no other way
10:40:20 <pleasant-pyon> monotone functions as morphisms*
10:40:20 <hodapp> BadCodSmell: We're not idiots. We can see when you're slipping little insults into your questions.
10:40:42 <Cale> BadCodSmell: I spent a while working for skedge.me a while back. My boss ended up deciding that we should rewrite their web application in Haskell (using the snap framework), and it ended up much cleaner and easier to maintain than the previous (groovy/grails) codebase that we'd inherited and had been struggling to remove bugs from. Mind you, there were a lot of things wrong with that old code which had more to do with
10:40:43 <Cale>  the inexperience of the original programmers than anything else, but there were a lot of things about Haskell which made the rewrite nicer.
10:40:45 <pleasant-pyon> quchen: So my intuition is that "Functor is morally still there".
10:40:53 <jmcarthur> What's this about an enemy camp? :(
10:41:06 <hodapp> jmcarthur: it was probably those Scala guys.
10:41:15 <hodapp> jmcarthur: I think I saw one throw an egg at your car earlier.
10:41:28 <BadCodSmell> jmcarthur: It was a subtle joke :P
10:41:58 <hodapp> BadCodSmell: A subtle joke mixed in with un-subtle condescension just comes off like more condescension.
10:42:15 <Zoetrope_> BadCodSmell: The point is if you're unwilling to learn Haskell how can you tell he's wrong?
10:42:50 <BadCodSmell> hodapp: When I say someone if fanatical about your favorite language I expect you make this issue, if it were about another language I expect you would agree.
10:43:06 <BadCodSmell> Zoetrope_: I took a look at it.
10:43:17 <jmcarthur> I claim A. You do not understand A. A must be false.
10:43:18 <hodapp> BadCodSmell: What is my favorite language?
10:43:29 <BadCodSmell> I think saying you're not allowed to make a judgement until you have learn the entire thing is an abuse though.
10:43:35 <Zoetrope_> No
10:43:40 <BadCodSmell> hodapp: I have no favorite, depends what I'm doing.
10:43:47 <hodapp> BadCodSmell: That's not what I asked.
10:43:50 <EvanR_> BadCodSmell: dont worry i dislike rust and ive never even looked at it
10:43:58 <BadCodSmell> Oops
10:44:10 <BadCodSmell> hodapp I have no idea but you clearly seem to feel strongly about haskell
10:44:12 <EvanR_> i also dont inhabit the rust irc channel
10:44:17 <Zoetrope_> You're coming across just as fanatical as I'm sure he appears to you
10:44:26 <hodapp> BadCodSmell: Please quit using that word "clearly".
10:45:27 <monochrom> what is all this about? can we get back to more on-topic things? or if anything, golden silence?
10:45:29 <quchen> pleasant-pyon: Hmm, in that case I don't know.
10:45:37 <pleasant-pyon> By the way, why is there no type class for monotone maps?
10:45:46 <jmcarthur> pleasant-pyon: monotone?
10:45:51 <codehero> what's this even about?
10:46:01 <BadCodSmell> Yes, I think EvanR_ was the most reasonable here. With that I'm off because I'm being baited now.
10:46:03 <quchen> Traversable is Functor+Foldable+X, so that's too much already.
10:46:10 <hodapp> BadCodSmell: You're not being baited.
10:46:21 <pleasant-pyon> jmcarthur: A monotone map is a function "f" such that "x <= y" implies "f x <= f y".
10:46:22 <monochrom> ok how about this
10:46:24 --- mode: ChanServ set +o monochrom
10:46:27 <monochrom> what is all this about? can we get back to more on-topic things? or if anything, golden silence?
10:47:06 <jmcarthur> pleasant-pyon: what would such a type class look like?
10:47:14 <quchen> monochrom: The polite way to kill a discussion is suggesting a move to #haskell-blah
10:47:36 <hodapp> codehero: Just a young guy who's due to be knocked off of a high horse sometime in the near future. No longer important. Back to Haskell!
10:47:38 --- mode: monochrom set -o monochrom
10:47:51 <codehero> okay! thank you :)
10:47:56 <codehero> well then
10:48:06 <codehero> if someone could please explain this to me
10:48:09 <codehero> (<*>) f a = (<$> a) =<< f
10:48:25 <pleasant-pyon> jmcarthur: Not entirely sure, but perhaps something like "class (Ord a, Ord b) => Monotone a b m | m -> a b where monotone :: m -> a -> b".
10:48:27 <codehero> i don't get how the types should fit
10:48:32 <Cale> hodapp: Do you know that guy IRL?
10:48:47 <monochrom> quchen: you're probably right mostly, but I guess I deplored that particular quarrel so much that I didn't even think of any other channel, I simply wanted it stop.
10:49:08 <fizruk> :t \f a -> f <*> a
10:49:09 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:49:17 <monochrom> it is not polite to move vain-glorious quarrels to #haskell-blah
10:49:20 <fizruk> :t \f a -> (<$> a) =<< f
10:49:21 <lambdabot> (Functor m, Monad m) => m (a -> b) -> m a -> m b
10:49:28 <quchen> monochrom: Not move, suggest to move!
10:49:39 <Cale> pleasant-pyon: Type classes are better suited to cases where there's a canonical choice of structure per type
10:49:48 <monochrom> well yeah, but you never know.
10:49:52 <quchen> I keep a list of discussions that went on after doing this. I retrieve it with "cat /dev/null"
10:50:31 <hodapp> quchen: *slow clap*
10:50:35 <codehero> fizruk: i see that they're the same. but why?
10:50:47 <Cale> pleasant-pyon: Given two ordered types, there's usually not a canonical choice of monotone map between them.
10:50:56 <codehero> how do the individual parts combine to make that one big type?
10:50:58 <fizruk> codehero: actually, f <*> a = f >>= (<$> a)
10:51:10 <Cale> pleasant-pyon: But if something like that seems suitable for your application, then feel free to define such a class.
10:51:11 <zett_zelett> sudo ln -s discussions_that_went_on.txt /dev/null?
10:51:19 <pleasant-pyon> Cale: I'm not imposing a single monotone map. I'm allowing for multiple types of monotone maps.
10:51:36 <mauke> zett_zelett: bad idea. replacing /dev/null will break your whole system
10:51:37 <fizruk> codehero: that should read a bit more easily
10:51:48 <hodapp> zett_zelett: https://i.imgur.com/KmdD0Ml.jpg stare at the fluffy cat picture. Now return to the channel, and talk only of Haskell!
10:51:49 <Cale> So, you'd have dummy types for specifying which map you meant?
10:52:01 <pleasant-pyon> Cale: But I can't make it work with the existing Data.Set and Data.Map.
10:52:12 <jberg_> hmm, i compile with ghc Foo.hs and get Foo.o and Foo.hi, why not an executable "Foo"?
10:52:13 <Cale> I mean, you can do that, but it's a little weird :)
10:52:19 <monochrom> in fact I prefer "f >>= (\x -> x a)"
10:52:38 <zett_zelett> hodapp: Awww. (Didn’t say anything before, though.)
10:52:45 <hodapp> This might be an even more off-topic question, but was there a reason for preferring typeclasses in Haskell vs. something more like the module system in OCaml?
10:52:48 <pleasant-pyon> Cale: class (Ord a, Ord b) => Monotone m a b | m -> a b where ...". In particular, "m" doesn't have to be a singleton - although it could well be.
10:52:50 <codehero> fizruk: and (<$> a) equals ((flip (<$>)) a)?
10:53:07 <jberg_> btw, does cabal and make do different things? Should i use both or just cabal or just make?
10:53:17 <fizruk> codehero: (<$> a) = (\f -> fmap f a)
10:53:28 <monochrom> oh oops, it is not (\x -> x a)
10:53:32 <FireFly> mauke: reminds me of http://askubuntu.com/questions/435887/i-can-read-from-dev-null-how-to-fix-it
10:53:34 <fizruk> monochrom: I think you've lost fmap :)
10:53:35 <Welkin> cabal calls make
10:53:45 <EvanR_> hodapp: using + for different kinds of addition, is there a way to do with modules?
10:53:51 <jberg_> Welkin: ok
10:53:55 <Cale> hodapp: http://i.imgur.com/98q0ZHp.jpg
10:53:55 <codehero> gienah: now i'm totally lost
10:54:04 <hodapp> Cale: STOPPP
10:54:16 <hodapp> EvanR_: ahh, that is true. I think I'd read of that and just forgotten about it.
10:54:16 <jmcarthur> EvanR_: yes, if you fully qualify it or use locally open the module
10:54:25 <jmcarthur> -use
10:54:30 <mauke> jberg_: is there a 'module' declaration in Foo.hs?
10:54:38 <jmcarthur> EvanR_: i'm not claiming that's just as nice, though
10:55:05 <EvanR_> jmcarthur: could be
10:55:10 <hodapp> EvanR_: are you talking of OCaml modules here though?
10:55:17 <Cale> FireFly: LOOOOL
10:55:20 <EvanR_> hodapp: no just any modules
10:55:32 <jberg_> mauke: yes, module Foo where
10:55:33 <hodapp> EvanR_: I don't know enough about OCaml modules to say whether or not they can do this.
10:55:46 <pleasant-pyon> hodapp: I think there are use cases for both type classes and modules. I miss type classes in ML, and I miss modules in Haskell.
10:55:48 <jberg_> mauke: i don't expose any functions though, but i have a main function
10:56:07 <monochrom> I agree with pleasant-pyon :)
10:56:10 <jmcarthur> ocaml may be getting implicit modules soon, as an alternative to type classes, and the proposed feature addresses the canonicity problems with types like Set that Scala suffers from with its similar feature.
10:56:15 <mauke> jberg_: the main entry point to a program is Main.main, not Foo.main
10:56:16 <hodapp> pleasant-pyon: I have not used ML much but I have run into cases in Haskell where it seems modules were a better bit.
10:56:25 <mauke> jberg_: if there is no Main.main, no program can be generated
10:56:30 <fizruk> codehero: (f <*> a) runs f then runs a then applies the function from f to the value from a
10:56:45 <jberg_> mauke, meaning? do i import Main and write Main.main or what?
10:56:51 <hodapp> pleasant-pyon: but, the idea that I got was that they have some overlap, and Haskell elected to go to the typeclass side of things, and not to OCaml-style modules.
10:56:52 <pleasant-pyon> hodapp: They are suited to different use cases. Type classes give you coherence, which implicit modules can't possibly give you.
10:56:56 <jmcarthur> also finally adds something for higher kinded type variables and higher rank types. all a bit more verbose than in haskell, bit not nearly impossible anymore
10:56:57 <hodapp> pleasant-pyon: coherence?
10:57:05 <mauke> jberg_: ???
10:57:11 <jmcarthur> i miss modules in haskell and miss type classes in ocaml
10:57:13 <fizruk> codehero: f >>= (<$> a)  =  f >>= \g -> g <$> a
10:57:14 <pleasant-pyon> hodapp: Coherence = you always get the same instance.
10:57:16 <mauke> jberg_: no, you have to define a Main module with a 'main' in it
10:57:21 <pleasant-pyon> hodapp: No matter what part of your program you're in.
10:57:32 <jberg_> mauke: hmm okay, and in Main import Foo module?
10:57:35 <hodapp> pleasant-pyon: oh, hmmmm
10:57:36 <pleasant-pyon> hodapp: ekmett's talk "Type Classes vs. the World" explains it pretty clearly.
10:57:39 <hodapp> pleasant-pyon: thanks.
10:57:42 <jberg_> mauke: so i need another Main.hs file?
10:57:49 <codehero> fizruk: oh. okay
10:57:56 <fizruk> codehero: so (f >>= (<$> a)) runs f then runs a then applies the function from f to the value from a
10:58:17 <mauke> jberg_: no, just get rid of Foo. why do you even need it?
10:58:21 <fizruk> codehero: does that help? :)
10:58:41 <Zoetrope_> I'm not sure if I value coherence that much, I'd hear some arguments for it though
10:58:42 <jberg_> mauke: okay, i just had Foo because i didn't know about Main
10:58:50 <monochrom> codehero: in "f >>= (\x -> fmap x a)", well let me do (\x -> fmap x a) first. so I think it is easy to deduce (\x -> fmap x a) :: (A -> B) -> M B. (and it requires a::A)
10:59:02 <mauke> jberg_: well, you could also remove 'module ... where' because Main is the default :-)
10:59:45 <codehero> fizruk: yeah. i think so
11:00:18 <Cale> Zoetrope_: It's really really nice not to have to worry that the Set data structures you get from two different libraries are using different instances of Ord, and thus will break horribly when you try to union them or something.
11:00:23 <monochrom> in "f >>= (\x -> fmap x a)", the >>= forces f :: M ???, and this ??? has to match the type of x, which was determined to be A->B. so f :: M (A -> B)
11:01:34 <monochrom> so the whole thing is this: "\f a -> f >>= (\x -> fmap x a)" :: M (A -> B) -> M A -> M B, since the body requires f :: M (A -> B), a :: M A. (I had a typo when I said "a::A")
11:02:36 <monochrom> "module Main where" is not the same as "module Main(main) where".
11:02:44 <codehero> monochrom: well. i'm currently doing this https://github.com/NICTA/course/blob/master/src/Course/Bind.hs#L66
11:02:49 <codehero> so i'm not supposed to use bind
11:03:07 <monochrom> this is important because when you leave out your module header, it is implicitly "module Main(main) where".
11:03:26 <codehero> in fact, i'm supposed to only use (=<<) and (<$>)
11:03:35 <Cale> Zoetrope_: Most of the really good examples of how it improves your life though come about in cases where you start putting instances inside data structures. It's really good to know that if you have an instance of class C for type t, you don't have to worry about whether you're using the one that you unpacked from the first argument of your function when you pattern matched, or the second.
11:03:59 <Cale> (or the one which you got from the function's overall type signature, if one is there too)
11:04:18 <monochrom> well ok, replace fmap by <$>, and write like "(\x -> x <$> a) =<< f"
11:04:29 <fizruk> codehero: also, you can try typing subexpressions in GHCi like `:t \a -> (<$> a)` to get a better understanding/verify yourself
11:04:39 <monochrom> it is the same story with some re-ordering
11:04:39 <Cale> But also, in any case where the use of an instance affects the content of a data structure, it's really important to have coherence (like the Set/Map example)
11:04:58 <Cale> I suppose FingerTree also gets pretty good use out of it
11:05:07 <Zoetrope_> Right, I see
11:05:35 <fizruk> :t (>>=)
11:05:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:05:37 <codehero> oh lol. fmap = <$>
11:05:39 <fizruk> :t (=<<)
11:05:39 <codehero> interesting
11:05:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:05:50 <fizruk> codehero: (=<<) is just (flip (>>=))
11:06:55 <codehero> yeah
11:07:33 <jberg_> okay thanks, everything worked with a Main module
11:08:37 <jmcarthur> Cale: the proposed modular implicits feature for ocaml would give the type of Data.Set.union something like this:     val union : (implicit O : Ord) -> Set(O).t -> Set(O).t -> Set(O).t
11:08:59 <jmcarthur> Cale: i believe this addresses the canonicity issues that Scala and such have
11:09:15 <codehero> well. the thing is. when i have `f <*> a = (<$> a) =<< f` then `(<$> a) :: f a -> (a -> b) -> f b`. but the first argument for (=<<) is supposed to be (a -> f b)
11:09:24 <Zoetrope_> Cale: I think what I'm on the fence is whether just stating the instance explicitly in those cases is fine. Or is it better to block that off because if something has two separated instances for the same type then you probably actually have 2 types
11:09:33 <jmcarthur> Cale: that is, sets using different orderings have different types
11:10:27 <monochrom> no, (<$> a) :: (a -> b) -> f b.
11:10:38 <zett_zelett> Can someone explain to me https://wiki.haskell.org/Monad#Fun?
11:10:44 <jmcarthur> Cale: which is already how it is even without modular implicits, since sets in ocaml are defined as a functor (as in parameterized module, not as in category theory)
11:11:59 <codehero> monochrom: okay. but that's still not (a -> f b)
11:12:37 <monochrom> do you mind if I use different variables for the type of (=<<)?
11:13:19 <codehero> sure. go ahead
11:14:02 <monochrom> (=<<) :: (c -> f d) -> f c -> f d
11:14:17 <monochrom> so you're looking at: plug (a->b) into c, plug b into d
11:14:36 <zett_zelett> Let me correct that: Can someone explain https://wiki.haskell.org/Monad#Fun to me?
11:15:08 <c_wraith> zett_zelett: looks like a poorly-executed bad joke to me
11:15:18 <codehero> monochrom: ohh. so c is a function?
11:15:48 <monochrom> I don't understand the question. c is an unknown type to be solved for.
11:16:07 <codehero> well. i was suprised that c could be a function
11:16:57 <c_wraith> codehero: functions have types.  a type variable can (often) be any type - even a function
11:17:13 <c_wraith> codehero: while the (->) type might be special in a couple ways - that isn't one
11:17:13 <zett_zelett> c_wraith: I thought so, but in what sense? “You can easly get rid of them. Oh, look: They’re ubiquitous – my bad, you cannot get rid of them after all.” or is it a Category (Category:Monad) pun?
11:17:26 <zett_zelett> Is there any philosophy behind it?
11:18:02 <c_wraith> zett_zelett: I'm not sure.  It might even be spam of some sort - you'll note that it doesn't link to the original site
11:18:28 <c_wraith> zett_zelett: it redirects back there, but after doing who knows what..  It's probably spam, in fact
11:18:47 <monochrom> zett_zelett, look at the url of that link. the domain name is some "monadtransformer.parallelnetz.de".
11:19:02 <athan> Cale: ping
11:19:28 <monochrom> it used to be a website set up to mirror haskell.org but do a word substitution of "monad" by something else
11:20:25 <athan> Cale: I think I screwed up on my applicative instance. *> isn't chaining parsers, it's demanding both be satisfied (I think). Is the implementation for parsers that result in lists basically "non-deterministically try all remainders" for the next parser?
11:20:36 <monochrom> it seems the owner no longer cares, and it now simply redirects you back to haskell.org
11:21:22 <athan> meaning something like: `x *> y` means that we run `x` first, resulting in `[(String, a)]`. Now, we throw away `a` and try `y` on all elements of the list, non-deterministically?
11:24:30 <jberg_> does anyone use the "vim haskell now"-vim addon?
11:25:24 <jberg_> or does anyone know of a good way to look at the type of the expression under the cursor in vim?
11:25:47 <jberg_> hmm nm
11:36:56 <gnimmelf> Quiz: here [http://snapframework.com/docs/tutorials/snaplets-tutorial], why do I get `Parse error: naked expression at top level` on `makeLenses ''App`?
11:38:02 * hackagebot transformers 0.4.3.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.4.3.0 (RossPaterson)
11:41:05 <lyxia> gnimmelf: Doesn't it say something about template haskell?
11:42:57 <gnimmelf> lyxia: nope. All examples I have seen uses `makeLenses ''XXX` as "naked" (no indent, just standalone on a line)
11:46:21 <lyxia> gnimmelf: Does your file begin with {-# LANGUAGE TemplateHaskell #-}?
11:46:48 <gnimmelf> ah, nope! I'll add that in...
11:47:36 <gnimmelf> no error! Joy! Thnx. Now onto next... 
11:47:54 <gnimmelf> (learning haskell using Snap)
12:00:42 <Testaa> What do you think about http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839 ?
12:01:03 <dmwit> Athas: right
12:01:09 <dmwit> err, misnick
12:01:41 <dmwit> ?tell athan I think your characterization of (*>) for parsers (as running both parsers, but throwing away the result of the first one) was basically right.
12:01:41 <lambdabot> Consider it noted.
12:02:15 <dmwit> Testaa: You can give it a test run online. It was too verbose and cutesy for me, but others seem to like it well enough.
12:02:32 <dmwit> ?where LYAH
12:02:32 <lambdabot> http://www.learnyouahaskell.com/
12:02:58 <Athas> dmwit: well, we can continue the conversation!  This is how new friends are made!
12:03:12 <Yaniel> @where rwh
12:03:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:03:24 <Yaniel> the other de facto guide
12:03:27 <dmwit> Athas: Nice haircut! It's good to see you around. How's the weather over by you...?
12:03:38 <dmwit> ?where gentle
12:03:39 <lambdabot> http://www.haskell.org/tutorial/
12:04:18 <Testaa> dmwit: Thanks
12:04:20 <dmwit> Testaa: That's the intro that got me hooked, though some dislike its density.
12:04:22 <Athas> dmwit: the weather is OK, how is your haircut?
12:04:35 <mmachenry> Does anyone know how to get Parsec to do nothing? I have a condition where my character must be followed by a delimiter only if it's alpha. This is my not-type-checking version here http://lpaste.net/124226
12:05:14 <Testaa> lambdabot: Thank you too!
12:05:33 <mmachenry> Basically I want to parse any one character but if it's an alpha I want to impose a restriction that it's followed by whatever my parseDelimitingCharacter function would match
12:05:38 <dmwit> mmachenry: Are you trying to leave the delimiting character in the input stream to be parsed by some later parser?
12:06:03 <mmachenry> dmwit: Yep
12:06:26 <Testaa> dmwit: Does the book cover nearly everything or just the most important things?
12:06:43 <Athas> mmachenry: there is lookAhead in Parsec.
12:06:49 <dmwit> mmachenry: Bad luck. You'll have to refactor, and push that test into the part that's supposed to parse the delimiter.
12:06:54 <Athas> Text.Parsec.Combinator.lookAhead.
12:06:57 <mmachenry> Athas: Read my lpaste, I'm using it. But thanks
12:07:02 <Athas> Oh, sorry.
12:07:15 <mmachenry> I am having trouble no-op ing
12:07:37 <dmwit> Or perhaps I'm misunderstanding the problem.
12:07:55 <dmwit> Testaa: I think LYAH covers the language and the base library fairly well.
12:08:11 <mmachenry> dmwit: My problem>
12:08:13 <mmachenry> ?
12:08:14 <dmwit> Testaa: Nothing quite like experience to get wider library coverage, of course.
12:08:17 <dmwit> mmachenry: yes
12:08:32 <Athas> mmachenry: void (lookAhead parseDelimitingCharacter)
12:09:12 <Athas> void is just a helper function from Control.Monad, so it's the same as 'lookAhead parseDelimitingCharacter >> return ()'.
12:09:15 <mmachenry> dmwit: My parser should match "*abc" and give me the * or "A(B)" and give me the A but not "ABC" because A isAlpha but not followed by a delimiting character (which is a paren or space)
12:10:16 <Testaa> dmwit: Thank you for your opinion
12:18:05 * hackagebot fixed-vector-hetero 0.3.1.0 - Generic heterogeneous vectors  http://hackage.haskell.org/package/fixed-vector-hetero-0.3.1.0 (AlexeyKhudyakov)
12:22:28 <mmachenry> dmwit: Here's a better expression of my problem. I rewrote it as a fully running program with HUnit. The commented code attempts to do a no-op in Parsec but does not type check http://lpaste.net/124226
12:24:19 <geekosaur> mmachenry, as written you need some kind of "noop character". this suggests you want the type to be Parser (Maybe Char)
12:24:47 <geekosaur> (your other option is to signal parse failure)
12:27:17 <geekosaur> if you want just that conditional to be optional then I think you need to rephrase your parser, as you can't currently do anything with that condition
12:27:48 <mmachenry> I think I'm going to write it slightly different. 
12:27:48 <dmwit> mmachenry: Athas' suggestion seems fine.
12:28:02 <dmwit> mmachenry: (() <$ oneOf "() ") <|> eof
12:28:11 <dmwit> At least, the tests pass.
12:28:30 <dmwit> Though you may have trouble later if you put parseSingleCharacter in alternation with another parser that can accept alphas.
12:28:43 <mmachenry> Yeah
12:28:49 <dmwit> Which can be solved with try.
12:28:56 <dmwit> But I think you should rethink your grammar, instead.
12:28:58 <mmachenry> I am thinking of doing this:
12:29:22 <mmachenry> noneOf alpha <|> (alpha >> lookAhead …)
12:29:55 <dmwit> Yes, or forget the lookahead entirely and merge this thing with the bit that consumes a delimiter.
12:30:01 <dmwit> Which is the suggestion I made at the beginning.
12:31:01 <geekosaur> yes, that's the problem I'm seeing
12:33:12 <jonkri> Is there any other way than Hoogle that I can search for a function in my installed Cabal packages?
12:33:52 <HeladoDeBrownie> jonkri, what do you know about the function? its name? its type?
12:33:53 <dmwit> You could grep the documentation. You told cabal to install documentation, right? =)
12:33:59 <HeladoDeBrownie> jonkri, one way, given the name, is the index
12:34:22 <dmwit> Oop, yes, the index is even better if you know the name.
12:34:38 <HeladoDeBrownie> but yes, it involves looking at the documentation
12:34:44 <HeladoDeBrownie> either on hackage or locally
12:35:01 <HeladoDeBrownie> though hackage can be slow to compile docs sometimes
12:35:15 <jonkri> HeladoDeBrownie: I know the name - "<>". I tried grepping my project directory (I'm using a Cabal sandbox), but it didn't show up.
12:35:43 <jonkri> dmwit: I haven't told Cabal to explicitly do anything, except to install my package.
12:36:34 <jonkri> HeladoDeBrownie: What's the index?
12:40:31 <dmwit> jonkri: The index is only built if you ask cabal to install documentation.
12:40:45 <dmwit> It's a web page that lists all functions in all packages, with links to their haddocks.
12:42:05 <dmwit> I guess you could also grep the .hi files in ~/.cabal/$arch/lib/$compiler
12:43:23 <tenniscp25> from this parser module, http://www.seas.upenn.edu/~cis194/spring13/extras/11-applicative2/AParser.hs, could you please give me a hint how i can implement `zeroOrMore :: Parser a -> Parser [a] ` without access to Parser constructor?
12:43:55 <dmwit> tenniscp25: Use the Alternative instance.
12:44:11 <fizruk> :t many
12:44:12 <lambdabot> Alternative f => f a -> f [a]
12:44:19 <fizruk> tenniscp25: ^
12:44:41 <tenniscp25> yeah i know i can use many but i wanna try implementing many
12:44:44 <dmwit> I'm sure the exercise is to reimplement `many` without peeking at the implementation of `many`. ;-)
12:45:03 <tenniscp25> yeah that's the point
12:45:19 <fizruk> tenniscp25: try encoding "zero" "or" "more" literally in haskell
12:45:24 <dmwit> tenniscp25: Tell us a bit about what you've thought.
12:45:37 <dmwit> tenniscp25: Then we can give a more targeted hint than "use the code that's there". =P
12:45:44 <jonkri> Thanks all.
12:45:50 <tenniscp25> the only solution i can think of right now is to create a new parser, giving it a string, parse it, check if it returns just or nothing and do recursion
12:46:19 <dmwit> tenniscp25: Okay. Can you write a parser that would do the `zero` part of `zeroOrMore`?
12:46:36 <dmwit> tenniscp25: Without resorting to the underlying constructor, of course.
12:46:37 <tenniscp25> yeah
12:46:41 <dmwit> tenniscp25: Cool, how?
12:46:48 <mauke> morpheus.jpg
12:47:21 <tenniscp25> uh..
12:47:57 <tenniscp25> i don't get it what's exactly a parser for zero..
12:48:12 <tenniscp25> did you mean a parser that don't match?
12:48:18 <tenniscp25> doesn't
12:48:30 <mauke> zero :: Parser a -> Parser [a]
12:48:48 <mauke> 'zero p' parses 0 occurrences of what 'p' would parse and returns the results in a list
12:49:05 <ReinH> tenniscp25: Alternative has two base methods: empty and (<|>)
12:49:22 <tenniscp25> ah yeah .. so it's empty
12:49:48 <mauke> no, empty has the wrong type
12:49:50 <tenniscp25> zero _ = empty
12:49:51 <fizruk> don't listen to ReinH 
12:49:55 <tenniscp25> ah no
12:49:56 <ReinH> fizruk: ?
12:49:58 <mauke> ok, that does typecheck
12:49:58 <antitone-pyon> What extensions would I need to make a "class Foo (k :: * -> Constraint)" ?
12:50:02 <mauke> but it's still wrong
12:50:28 <mauke> ReinH: empty is basically a parse error
12:50:36 <ReinH> mauke: I didn't say "use empty"
12:50:48 <ReinH> I just described the Alternative class.
12:50:51 <mauke> ReinH: why?
12:51:03 <ReinH> To make sure tenniscp25 knows what is available for use
12:51:09 <fizruk> ReinH: just the timing was bad, I guess
12:51:13 <mauke> ReinH: why didn't you describe the Ord class?
12:51:39 <dmwit> ReinH: (The file he linked to includes an implementation of Alternative. So he should have that information readily available anyway.)
12:51:39 <ReinH> mauke: because dmwit said "use the Alternative instance"
12:51:56 <mauke> ReinH: wow, you're super lagged
12:52:04 <ReinH> mauke: I guess so, sorry
12:52:13 <mauke> that was a full 5 minutes ago :-)
12:52:33 * ReinH goes away now
12:53:27 <fizruk> tenniscp25: how much input would zero take? on what input will it succeed/fail?
12:53:45 <antitone-pyon> What GHC extensions do I need to use to make a "class Foo (k :: * -> Constraint)" ?
12:54:04 <ReinH> many is actually relatively hard to define from scratch imo
12:54:36 <fizruk> antitone-pyon: KindSignatures, ConstraintKinds, I guess, maybe something else
12:54:37 <ReinH> and its relationship to some is rather subtle
12:55:02 <tenniscp25> does zero fail on a parse error? or does it always return an empty list no matter what p is?
12:55:28 <antitone-pyon> fizruk: I'm using both of those, and ghci complains that "Not in scope: type constructor or class 'Constraint'".
12:55:42 <ReinH> the implementation in base uses mutual recursion
12:55:53 <fizruk> antitone-pyon: import GHC.Something, I don't remember what exactly
12:56:25 <fizruk> tenniscp25: do you know the answer to my first question?
12:56:40 <mauke> tenniscp25: it applies p 0 times, so how can it ever get a parse error?
12:56:52 <fizruk> because it should lead you to the answer to my second question
12:57:02 <ReinH> It would be easier to start with a parser for "zero or one", for example
12:57:14 <mauke> ReinH: we're starting with a parser for zero
12:57:16 <fizruk> ReinH: we are starting with just zero
12:57:26 <ReinH> mauke: ok, I guess I should just shut up now
12:57:29 <tenniscp25> okay..
12:57:32 <ReinH> sorry
12:57:33 <mauke> that was 12 minutes ago
12:57:51 <ReinH> ok
12:58:19 <tenniscp25> so zero doesn't take any string and it doesn't care what p is
12:58:40 <fizruk> tenniscp25: so basically that means zero has no side effects, right?
12:58:46 <tenniscp25> yes
12:59:10 <arkeet> AntiSpamMeta: import GHC.Exts
12:59:14 <arkeet> er, antitone-pyon ^
12:59:35 <fizruk> tenniscp25: and what should be the return value of zero?
12:59:48 <tenniscp25> let me think..
13:00:38 <tenniscp25> for a parser, it should return Just ([], s) where s is a given string
13:00:46 <tenniscp25> no
13:00:58 <tenniscp25> it should return a parser ..
13:01:23 <tenniscp25> a parser that's when given a string s returns Just([], s)
13:01:41 <dmwit> I'm on board so far.
13:01:42 <fizruk> abstract away from Parser internals
13:01:56 <dmwit> tenniscp25: Do we have a nice way to construct a parser that behaves like that?
13:02:19 <dmwit> (not much of a hint: the answer to that is yes)
13:02:36 <tenniscp25> dmwit: ha ha sure
13:02:40 <int-index> Is there someone here capable of advanced type fu? Because I'm already desperate in my attempts to implement something.
13:02:49 <dmwit> ?where justask
13:02:49 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:03:17 <tenniscp25> oh this is hard (just for me)
13:03:17 <int-index> Here's my code: https://github.com/int-index/engram/blob/master/src/Engram/Grammar.hs
13:03:20 <dmwit> ?hpaste some code and the error it gets
13:03:20 <lambdabot> Haskell pastebin: http://lpaste.net/
13:03:39 <int-index> I have no error, I just don't know what to do next.
13:04:08 <int-index> I need to somehow work with the Rule data type I defined. It has a heterogeneous list and a function to consume the values in it.
13:04:17 <int-index> If I change the order of elements in this list
13:04:21 <int-index> How do I modify the function?
13:04:45 <int-index> Basically I need a version of flip that also accepts the positions of function arguments to be flipped
13:05:24 <fizruk> tenniscp25: just to repeat myself: you need something that lets you construct a parser with no side effects (which will not consume input of fail)
13:06:21 <tenniscp25> fizruk: i'm knocking my head on the wall..
13:06:41 <dmwit> tenniscp25: Okay. Write `zero` using the Parser constructor.
13:06:54 <dmwit> tenniscp25: Then look through the provided operations, and compare each one of them to your implementation.
13:07:15 <dmwit> tenniscp25: See if you find any that look similar.
13:07:31 <tenniscp25> ok
13:07:51 <int-index> I have a relevant paper in Agda that does what I need, but it uses dependent types to an extent that I'm unable to reproduce in Haskell.
13:10:06 <tenniscp25> yay.. it's zero p = pure []
13:10:10 <int-index> For example, if I have a heterogeneous list that contains the types '[a, b, c] and a function f :: a -> b -> c -> result. Now I want to move the element in this list to the end, so I get '[b, c, a], but what do I do with the function? How do I turn it into f :: b -> c -> a -> result?
13:10:12 <dmwit> tenniscp25: Great!
13:10:45 <tenniscp25> now i got something to return when it fails
13:11:32 <Cale> int-index: Is this all just for fun, or are you trying to accomplish something in particular with your program?
13:11:45 <fizruk> tenniscp25: you also know how to implement `one`, right? now try to implement zeroOrOne :)
13:12:06 <int-index> I'm trying to create a parsing library capable of handling left-recursion and optimizing grammars on the fly.
13:12:34 <int-index> So I create a type-indexed set of production rules of the grammar and need to work with them.
13:12:52 <Cale> hmm
13:13:30 <int-index> So it's like a parser generator, but implemented as an EDSL.
13:14:00 <dmwit> tenniscp25: Okay, let's do the "more" part. Can you write `more :: Parser a -> Parser [a]`? `more p` should parse something that starts like `p`, and then continues with zero or more `p`s. You can assume you have already implemented `zeroOrMore`.
13:14:22 <tenniscp25> zeroOrOne p = (:) <$> p <*> (zero p) <|> zero p 
13:14:42 <fizruk> tenniscp25: congrats!
13:15:14 <tenniscp25> dmwit: let me try..
13:15:16 <fizruk> you're just one step from zeroOrMore now :)
13:15:18 <Cale> int-index: All right. I suppose I can imagine how that might get you into some cases where fancy types are needed.
13:16:31 <int-index> I've found a paper that does exactly what I need and it's for Agda and uses dependent types like crazy. It references a similar paper that uses Haskell, but it doesn't cover semantic rules (which are precisely the reason I'm having troubles right now)
13:16:32 <Cale> int-index: Can you somehow do the permutation of the list and the permutation of the function type at the same time? Or perhaps construct a type level function which takes the list of types and produces the function type you need?
13:16:59 <Cale> Yeah, translating Agda into Haskell is usually not going to be easy
13:17:58 <int-index> Cale, well I need to do them at the same type. I've got as far as flipping the first two elements, because at term level I have the function flip
13:18:19 <int-index> I could easily define flips for other arguments, but I can't think of a generic solution.
13:18:26 <int-index> *at the same time
13:18:46 <Cale> Oh, right, you actually need the value level operation to go along with it
13:18:57 <Cale> hmm
13:22:09 <int-index> Cale: all my code is at https://github.com/int-index/engram - I will gladly explain every bit of what I'm doing (and trying to do) there if you think you can help me.
13:30:11 <jmcarthur> int-index: is it that you are looking for something like    Function (args :: [*]) (result :: *) -> Function (Rotate args) result   ? (where Function is a type family producing curried functions and Rotate is a type family moving the first element of a type-level list to the end)
13:31:18 <int-index> jmcarthur, yes, exactly! And something to accompany it at value level
13:31:40 * jmcarthur gives it a shot
13:35:10 <jmcarthur> meh, i broke my haskell-mode
13:38:52 <tenniscp25> i'm not sure if the exercise wants me to implement oneOrMore in terms of manyOrMore .. but i did it the other way around
13:39:49 <tenniscp25> oneOrMore p = (:) <$> p <*> (oneOrMore p <|> zero p) 
13:39:54 <tenniscp25> zeroOrMore p = oneOrMore p <|> zero p 
13:40:14 <Yaniel> what are those operators even
13:40:30 <Yaniel> I almost grokked <*> and <$> last week
13:40:46 <tenniscp25> Yaniel: you mean the <|> ?
13:40:50 <Yaniel> yeah
13:40:57 <Yaniel> is that from the optics set?
13:41:00 <tenniscp25> Yaniel: it's Alternative. i learned it yesterday haha
13:41:02 <tdammers> Yaniel: alternative.
13:41:30 <tdammers> pick the left one, unless it's "empty" / "failure" / "false" / "negative", in which case, pick the right one
13:42:00 <Yaniel> ah
13:42:17 <tdammers> very popular in parsec, for example
13:42:18 <Yaniel> so kinda like ( a ? a : b ) in C?
13:42:31 <tdammers> it can be, but it's more generic
13:43:30 <Yaniel> I see
13:46:32 <codehero> isn't ( p ? a : b) more like ( if p then a else b)?
13:47:18 <tdammers> codehero: yes
13:49:24 <JagaJaga_> What lib to manage command-line args can you suggest? I need the most simple one and handle commands (like `git <command>`)
13:49:25 <tenniscp25> oh i got it! thanks dmwit, fizruk !!!
13:49:58 <int-index>  JagaJaga_ : I've been satisfied with optparse-applicative
13:50:03 <codehero> tdammers: okay
13:50:11 <mniip> JagaJaga_, base is the simplest one :P
13:50:14 <codehero> so i guess that <|> is usually used for stuff like maybe
13:50:43 <tdammers> well, it's used for all sorts of things
13:50:50 <codehero> well, yeah
13:51:03 <tdammers> the unpleasant thing with (a ? a : b) is that it's not DRY
13:51:09 <codehero> DRY?
13:51:13 <codehero> it's wet?
13:51:16 <tdammers> Don't Repeat Yourself
13:51:20 <tdammers> it repeats the "a
13:51:23 <tdammers> "
13:51:25 <codehero> wait a second
13:51:29 <codehero> it repeats the a?
13:51:33 <codehero> oh
13:51:37 <codehero> oh now i get it
13:51:39 <codehero> i see
13:52:01 <tdammers> in javascript, you could use the || operator for the same purpose
13:52:01 <ab9rf> some languages have a ?: operator (a ?: b) that is just (a ? a : b)
13:52:15 <ab9rf> the problem with a ? a : b is that it's a type nightmare
13:52:28 <Cale> > [1,2,3] <|> [4,5]
13:52:29 <capisce> that's a GCC extension for C
13:52:29 <lambdabot>  [1,2,3,4,5]
13:52:39 <codehero> huh
13:52:39 <ab9rf> in a proper language it's equivalent to a || b
13:52:46 <JagaJaga_> int-index: thank you :)
13:52:50 <codehero> > Maybe 5 <|> Maybe 3
13:52:51 <capisce> you mean in an improper language
13:52:51 <flux> ab9rf, it's no more nightmare than an 'if' expression, is it?
13:52:51 <lambdabot>  Not in scope: data constructor ‘Maybe’Not in scope: data constructor ‘Maybe’
13:53:00 <codehero> duh
13:53:02 <codehero> i'm an idiot
13:53:04 <Cale> > Just 5 <|> Just 3
13:53:05 <tdammers> > Just 4 <|> Just 2
13:53:06 <lambdabot>  can't find file: L.hs
13:53:06 <lambdabot>  Just 5
13:53:10 <tdammers> D:
13:53:14 <codehero> yeah. it's Just
13:53:17 <codehero> :D
13:53:26 <codehero> > Nothing <|> Just 5
13:53:27 <lambdabot>  Just 5
13:53:29 <codehero> yay
13:53:43 <tenniscp25> > [1,2] <|> [3,4]
13:53:44 <lambdabot>  [1,2,3,4]
13:53:48 <codehero> that operator seems handy
13:53:55 <codehero> why does it combine the lists?
13:54:03 <codehero> > [] <|> [2,3]
13:54:05 <lambdabot>  [2,3]
13:54:15 <int-index> codehero, because you can see lists as undetermenistic computations
13:54:21 <codehero> hmm
13:54:24 <codehero> okay
13:54:39 <int-index> <*> applies a list of functions to a list of values
13:54:41 <int-index> each with each
13:54:42 <flux> ab9rf, are there btw languages other than GCC extensions that have a?:b ?
13:54:53 <int-index> because you are not sure, what is the correct function/value, you get them all
13:54:55 <tenniscp25> flux: groovy
13:54:55 <tdammers> flux: C# IIRC
13:55:04 <int-index> and <|> always works in conjunction with <*>
13:55:31 <flux> tdammers, tenniscp25, ok, learned something today ;-)
13:55:36 <rhllor> This may sound a little stupid, but please stay with me. Every Rubiks cube can be solved within 20 moves. Is it possible to make some program that makes like a tree of moves for a scramble, but with lazy evaluation so it only evaluates the solution without evaluating every move?
13:56:05 <jmcarthur> rhllor: yes
13:56:26 <int-index> jmcarthur, any success so far?
13:56:39 <jmcarthur> int-index: type families are always tricky because they aren't injective. i'm not there yet
13:56:49 <jmcarthur> int-index: would you object to a data family or gadt?
13:57:19 <codehero> rhllor: i'm pretty sure you could even make one type for that with idris
13:57:20 <int-index> jmcarthur, I have a HList (from vinyl), so there's already a data type to pattern match on
13:57:49 <jmcarthur> int-index: oh, so you are actually working with curried functions (who arguments are HLists)?
13:57:56 <int-index> Yes
13:57:59 <jmcarthur> i admit i was too lazy to look at your code
13:58:01 <jmcarthur> i see
13:58:03 <rhllor> how efficient would that be? About how long do you think it would be for a program to find a solution for that
13:58:23 <jmcarthur> rhllor: it depends on your search algorithm.
14:01:03 <int-index> jmcarthur, here's the relevant part of my code: http://lpaste.net/6213960968775401472
14:01:22 <int-index> Given a Rule, I need to modify both the list in it and the function in it.
14:01:59 <int-index> The Rec data type is from vinyl (and it's a simple heterogeneous list)
14:02:12 <Cale> rhllor: You could navigate the infinite tree of moves without evaluating them all, but there are lots of algorithms you could apply to try to find the solution. If you're searching the tree by brute force, you'll take approximately forever.
14:02:45 <jmcarthur> ah so it is curried after all
14:02:46 <antitone-pyon> arkeet: A little bit late, but... Thanks!
14:05:49 <rhllor> Cale: now, I know almost nothing of haskell. I know that I could generate a infinite tree without evaluating anything, but how to can I get the one that evaluates to the solution without having to evaluate all the other no useful stuff?
14:06:08 <Cale> rhllor: By knowing something about Rubik's cubes
14:06:21 <jmcarthur> int-index: okay, i'm going to start over using your types. that the vinyl thing is a gadt should be helpful. installing vinyl right now
14:06:27 <Cale> rhllor: Or knowing general things about group theory and permutation groups
14:07:03 <arkeet> antitone-pyon: np :)
14:07:07 <int-index> jmcarthur, thanks for your effort
14:07:25 <Cale> rhllor: If you make the correct sequence of moves, you can walk directly from the root, down the tree to a solution of the cube
14:07:34 <Cale> and not evaluate any other subtrees than that
14:07:53 <Cale> But *finding* that sequence of moves is a whole other matter. Lazy evaluation isn't magic.
14:08:42 <rhllor> I know several methods for solving a rubiks cube, I can even solve one in 30 seconds, but there aren't any for finding the least possible moves for a specific scramble. You can't just start building blocks because the solution isn't obvious in any way.
14:08:42 <Cale> Lazy evaluation just means evaluating expressions outermost-first, and sharing the evaluation which is done to a bound variable between its occurrences.
14:09:31 <quchen> Cale: Are you sure sharing is part of the deal?
14:09:52 <Cale> quchen: Yeah, that's what differentiates lazy evaluation from normal order evaluation.
14:10:20 <quchen> Interesting. I thought laziness was literally another name for leftmost/outermost.
14:10:25 <rhllor> I was kind of hoping to generate a tree of all possible moves and just take out the solution. I guess I didn't understand lazy evaluation enough
14:10:31 <jmcarthur> int-index: wait, the Rule type existentially quantifies over the list of arguments. i'm now a bit lost as to the goal. the function you are looking for... does it even mention Rule or just the fields of a Rule?
14:10:40 <rhllor> i was hoping lazy evaluation was magic
14:10:57 <int-index> jmcarthur, it's Rule -> Rule
14:11:00 <Cale> rhllor: Well, if lazy evaluation *was* magic in that way, we'd have solved all of mathematics by now
14:11:08 <int-index> I need to move the first symbol to the end
14:11:15 <jmcarthur> int-index: i see.
14:11:22 <quchen> rhllor: Magic should not be practiced carelessly :-)
14:11:31 <Cale> rhllor: Prove any theorem by simply generating the tree of all possible proofs and finding the one in it which is the proof of your theorem
14:11:31 <codehero> rhllor: idris is magic
14:11:40 <codehero> it has code completion.....
14:11:52 <codehero> though haskell has too
14:11:57 <codehero> with some extensions
14:12:04 <Cale> Also, you could break encryption, probably determine whether programs halt or not...
14:12:16 <quchen> Cale: You can enumerate all possible Rubik's Cube moves, but you can't enumerate all terminating programs up to a size :-(
14:12:24 <int-index> codehero, no language has code completion, repl/ide has
14:12:38 <codehero> int-index: well, hole filling
14:12:38 <int-index> and GHCi pretty much has completion.
14:12:50 <codehero> but it's sort of like code completion
14:12:55 <quchen> augur: Updates on the hole-vs-partial issue?
14:12:55 <rhllor> Cale: thanks for your help, for now Im going to try to implement finding a solution using a regular method, and then see where I can go from there
14:13:03 <codehero> you give the type signature and idris makes some code for you
14:13:15 <int-index> codehero, that's possible in Haskell too
14:13:32 <codehero> int-index: that's what i wrote.
14:13:35 <rhllor> codehero: lisp macros too
14:13:35 <codehero> "with some extensions"
14:13:44 <codehero> lisp, really?
14:13:45 <Cale> quchen: Well, okay. It depends on the exact nature of the oracle which is doing the searches in infinite trees
14:14:05 <int-index> codehero, no, extensions are irrelevant, there was a library that could generate Haskell code for you given a type signature
14:14:10 <quchen> codehero: typed holes aren't really an extension. It's a smart compiler error message.
14:14:10 <codehero> oh
14:14:24 <quchen> Also,
14:14:28 <quchen> ?djinn a -> b -> a
14:14:29 <lambdabot> f a _ = a
14:14:35 <int-index> djinn, right, that's the name
14:14:37 <quchen> Meet our local oracle
14:14:41 <quchen> FSVO oracle
14:14:44 <antitone-pyon> How do I represent the empty constraint?
14:14:51 <rhllor> codehero: yeah, macros generate code for you
14:14:54 <Cale> antitone-pyon: ()
14:15:00 <antitone-pyon> Oh, just like that? Awesome!
14:15:09 <int-index> ?djinn a -> b
14:15:09 <lambdabot> -- f cannot be realized.
14:15:21 <codehero> rhllor: huh. so you can give them a type signature for a list and they'll generate the code for the list?
14:15:32 <quchen> :t let f :: () => a -> a; f = id in f -- antitone-pyon 
14:15:33 <lambdabot> a -> a
14:15:56 <jle`> if mutliple threads are waiting on putting into an MVar, is there any guaruntees about what happens when the MVar becomes free to put?
14:15:57 <Cale> codehero: Most lisps don't have types, but macros are programs which generate code.
14:15:58 <tenniscp25> int-index: i read your answer above about picking (<|>) from two lists. i still don't understand how nondeterminism and <*> relate to <|>. could you please explain a bit more?
14:16:11 <jle`> will at least *one* of the threads be able to put?
14:16:11 <quchen> int-index: The canonical cool thing to let Djinn solve is >>= for Cont
14:16:19 <antitone-pyon> Cale: quchen: ty
14:16:28 <jle`> will they be putted in the order that they began waiting? (like a queue?)
14:16:39 <quchen> ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
14:16:40 <lambdabot> f a b c = a (\ d -> b d c)
14:16:42 <arkeet> ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
14:16:42 <lambdabot> f a b c = a (\ d -> b d c)
14:16:46 <arkeet> oh I'm too slow.
14:16:52 <Cale> codehero: So you could do something like implement djinn's solver in scheme (taking some representation for the type and producing the appropriate function of that type), even though there really isn't a type system to speak of.
14:16:58 <int-index> tenniscp25, yes. If you look at a list as a list of possible values, than <*> is function application and <|> is choice
14:17:21 <int-index> When you are unsure whether the first list contains the correct value or the second one, you simply concatenate them.
14:17:37 <rhllor> codehero: well what you do is     (defmacro foo (a b c) `(do this thing with ,a ,b ,c))
14:17:39 <tenniscp25> this is the part i don't understand
14:17:42 <int-index> When you are unsure what is the correct function to be applied and what is the correct value, you apply each to each.
14:17:51 <tenniscp25> why don't just check if the first is empty?
14:18:07 <rhllor> and then you can put (foo 1 2 3) and it will generate    (do this thing with 1 2 3)  for you
14:18:20 <int-index> tenniscp25, because you want to get all the values
14:18:48 <rhllor> or rather, that's what goes on under the hud
14:18:52 <rhllor> *hood
14:19:08 <Fuuzetsu> can I somehow have cabal re-guess dependencies like it does in ‘cabal init’ stage?
14:19:13 <tenniscp25> int-index: why would one want to get all the values?
14:19:14 <codehero> rhllor: well. that's not really what i meant
14:19:20 <Fuuzetsu> say, I deleted a bunch of modules and no longer need everything it previously guessed
14:19:35 <jle`> is Control.Concurrent.Chan intended for concurrent usage?
14:19:36 <int-index> tenniscp25, because you are unsure which one is correct, and you have no right to choose
14:19:42 <jle`> usage with concurrency?
14:19:45 <rhllor> codehero: well what does it look like in idris?
14:19:47 <jle`> the documentation doesn't really say anything
14:20:30 <rhllor> codehero: that's as close to 'code completion' as I know a language can do
14:21:06 <tenniscp25> can't i define <|> like this .. ?
14:21:09 <tenniscp25> [] <|> ys = ys
14:21:10 <tenniscp25> xs <|> [] = xs
14:21:13 <quchen> jle`: Sure. A Chan is a chain of MVars, basically. Marlow talks about them quite a bit in his book.
14:21:24 <int-index> tenniscp25, that's non-exhaustive
14:21:31 <int-index> you have one more case to cover
14:21:39 <tenniscp25> oh
14:21:47 <tenniscp25> xs <|> ys = xs
14:22:16 <chaosmasttter> tenniscp25: why xs? and not ys?
14:22:32 <tenniscp25> because we're sure xs is not empty
14:22:42 <tenniscp25> othwerwise it'd match the first case already
14:22:45 <int-index> tenniscp25, what if the correct answer was in ys? and you find it out later in your calculations
14:23:06 <int-index> You work with all the values unless you can choose one.
14:23:12 <tenniscp25> it's a list.. can i use it for further calculations?
14:23:18 <int-index> Yes.
14:23:20 <stephen_> Is anyone else having issues with the ArchHaskell repos for archlinux?
14:23:22 <tenniscp25> i mean.. it's just a value
14:23:43 <stephen_> The servers are inaccessable for me.
14:24:21 <codehero> rhllor: it's a bit hard to explain. if i understood it correctly you give idris a type and some proof. and then you can let idris generate the code for you
14:24:30 <tenniscp25> please bear with me.. how can a list be "correct"?
14:24:36 <codehero> if it's ambigious it'll give you choices to pick
14:25:08 <int-index> tenniscp25, not a list, but a value in it. It's non-determenism. The notion of correctness is probably not the best metaphor I piced.
14:25:09 <rhllor> codehero: okay cool, I've been hearing a lot about Idris, maybe I'll try it out one day
14:25:10 <int-index> picked
14:25:24 <codehero> there's a talk that explains it much better
14:25:26 <codehero> wait a sec
14:25:57 <int-index> tenniscp25, imagine you have a function f :: Int -> [Int]. So you give it, say, a 5, and it says 'Maybe the answer is 4, maybe -4, dunno lol'
14:26:13 <chaosmasttter> > filter (> 10) $ (* 2) <$> ( ([(+ 1), (+ 2)] <*> [ 1, 2, 3 ]) <|> [12, 13] )
14:26:15 <lambdabot>  [24,26]
14:26:15 <int-index> And then you have to work with both answers, up to the point when you can pick one
14:26:29 <codehero> rhllor: http://media.ccc.de/browse/congress/2014/31c3_-_6162_-_en_-_saal_6_-_201412281400_-_programming_with_dependent_types_in_idris_-_raichoo.html
14:26:46 * tenniscp25 my eyes bleed..
14:27:41 <int-index> You're also not sure what to do with those results. Maybe you need to leave them as they are, maybe you need to increment them. So it's either id or succ
14:27:49 <int-index> [id, succ] <*> [4, -4]
14:28:02 <int-index> > [id, succ] <*> [4, -4]
14:28:03 <lambdabot>  [4,-4,5,-3]
14:28:30 <int-index> Now you have four values and you are again not sure which one is what you want.
14:28:48 <tenniscp25> okay...
14:29:05 <tenniscp25> so it's more like the definition of the List?
14:29:28 <tenniscp25> chaosmasttter: thanks. i think i got it now ;)
14:29:34 <jmcarthur> int-index: i have lost interest in your problem, sorry. type families continue to be tricky. :)
14:29:44 <int-index> jmcarthur, happens, lol
14:29:54 <tenniscp25> int-index: thanks. i got it
14:30:48 <jmcarthur> int-index: one thing that confuses me is *why* you want this. in particular, the type of Rule doesn't change, and there is no observable difference in behavior
14:31:04 <jmcarthur> so it's really a glorified identity function
14:31:26 <int-index> jmcarthur, that's because the order of the elements in the HList matters when it comes to actually applying the rule.
14:31:30 <int-index> It's a rule for parsing.
14:31:50 <jmcarthur> but you can't observe the difference if it's hidden in Rule
14:32:09 <int-index> jmcarthur, no it isn't, I pattern match on it in the parser
14:32:33 <jmcarthur> int-index: but since that type is an existential you can't observe the difference, even with pattern matching
14:33:40 <int-index> jmcarthur, I'm not sure what you mean right now, because parsing with the rule [Symbol 'a', Symbol 'b'] gives you certainly a different result than parsing with the rule [Symbol 'b', Symbol 'a']
14:33:50 <int-index> It accepts different strings
14:34:21 <jmcarthur> int-index: oh, i forgot that you have that Symbol type. i had to abstract that away since i didn't have the definition, and i forgot i had done that. nevermind
14:36:45 <michi7x7> hi all
14:43:14 * hackagebot users-postgresql-simple 0.1.0.1 - A PostgreSQL backend for the users package  http://hackage.haskell.org/package/users-postgresql-simple-0.1.0.1 (AlexanderThiemann)
14:45:57 <jle`> quchen: cool, thanks :)
14:46:20 <jle`> i remember he did but looking through the table of contents nothing jumped out at me...i think i just see the chapter manually implementing an mvar queue
14:46:36 <quchen> Yes, that's a good starting point.
14:48:11 <ttt_fff> waht hapened to kronos haskepp ? http://www.kronosnotebook.com/haskell
14:49:53 <Taneb> I am impressed with how easy the accelerate library can make GPU programming
14:51:16 <quchen> Step 1: add "Acc"
14:51:19 <quchen> Step 2: Done
14:54:13 <ttt_fff> even for deep lerning gpu tuff?
14:54:31 <funfunctor> whats the function that can give me [Word16] -> ByteString again?
14:54:56 <funfunctor> oh actually, [Complex Word16] -> ByteString rather
14:55:06 <quchen> Binary.encode?
14:55:13 <funfunctor> :t encode
14:55:14 <lambdabot> Not in scope: ‘encode’
14:55:47 <funfunctor> quchen: thx!
14:56:23 <EvanR_> Complex Word16 doesnt work that great
14:56:38 <EvanR_> you need Complex E16 or something from binary fixed point package
14:56:56 <EvanR_> Word16 isnt fractional
14:57:35 <ttt_fff> https://gist.github.com/anonymous/3039e27e3cd9df805a04 <-- this is with stackagae lts
14:57:39 <ttt_fff> how do I install the haste compiler?
14:58:51 <funfunctor> ah No instance for (Binary (Complex Word16))
14:59:00 <funfunctor> ah
14:59:06 <keegan__> Hello all, has anyone tried acid-state? I'm interested in hearing about how it compares with other data stores
14:59:20 <funfunctor> E16 hmm?
14:59:48 <EvanR_> keegan__: as long as you dont change your schema
15:00:13 <keegan__> so the schema is fixed once created?
15:00:26 <EvanR_> no but youll have to go through a migration
15:00:51 <keegan__> That is pretty typical with SQL data stores
15:01:15 <keegan__> honestly Mongo has been the only store I have ever used that does not require migrations
15:01:16 <jmcarthur> keegan__: you can upgrade your schema, actually. you just need to anticipate doing so
15:01:45 <jmcarthur> keegan__: that is, by versioning your types and providing upgrade functions
15:01:51 <funfunctor> oh god, now cabal is fighting me over fixed-point
15:02:02 <funfunctor> all I wanted was a binary stream of complex numbers.
15:02:22 <keegan__> Any real world experience with it? I'd like to know if its production ready or if I should look into something else
15:02:23 <EvanR_> keegan__: since sql is dynamic you might find it easier to "bash your head against the database" to get a migration to work than a statically typed binary database
15:02:51 <jmcarthur> funfunctor: fixed-point? i'm surprised
15:02:56 <keegan__> So far I have not found much documentation
15:03:03 <jmcarthur> funfunctor: why is binary requiring fixed-point?
15:03:05 <EvanR_> keegan__: its in the package safe-copy
15:03:26 <keegan__> Ok, I'll look into it
15:03:38 <jmcarthur> funfunctor: fixed-point is my package. it's old and i haven't been supporting it well
15:03:46 <jmcarthur> it has known bugs and everything
15:04:12 <jmcarthur> ... i don't even like the interface anymore
15:04:17 <lpaste> funfunctor pasted “No title” at http://lpaste.net/124235
15:04:40 <funfunctor> jmcarthur: i'm trying to do that
15:04:42 <jmcarthur> funfunctor: oh, you've been using Data.Fixed.Binary
15:04:42 <EvanR_> jmcarthur: i suggested it for funfunctor to export types with arithmetic for signed 16bit fixed point numbers between -1 and 1, used by the C library hes writing bindings for
15:05:06 <funfunctor> EvanR_: nar this isn't for the binding..
15:05:12 <jmcarthur> EvanR_: seems a sane suggestion. i'm just a bit embarrassed about that package.
15:05:20 <funfunctor> binding works fine now
15:05:44 <jmcarthur> EvanR_: oh, actually, i don't think fixed-point supports shifted ranges like that
15:05:48 <funfunctor> this is me trying to simulate a tone in QAM data
15:06:21 <EvanR_> jmcarthur: ah i couldnt determine that
15:10:43 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/124235
15:11:05 <funfunctor> jmcarthur: how would I get that going?
15:12:08 <Fuuzetsu> @pl f x = g <$> h x
15:12:08 <lambdabot> f = (g <$>) . h
15:12:32 <Fuuzetsu> ugh, I think this is the 50th time I wish for this to be an existing operator ;(
15:12:51 <EvanR_> <$>.
15:13:10 <jmcarthur> :t \f x -> f <$> h x
15:13:11 <lambdabot> (FromExpr (f a), Show t, Functor f) => (a -> b) -> t -> f b
15:13:16 <benzrf> yeah same
15:13:19 <jmcarthur> :t \f h x -> f <$> h x
15:13:20 <lambdabot> Functor f => (a -> b) -> (t -> f a) -> t -> f b
15:13:34 <jmcarthur> :t (fmap.fmap) `asTypeOf` (\f h x -> f <$> h x)
15:13:35 <lambdabot> Functor f => (a -> b) -> (t -> f a) -> t -> f b
15:13:57 <Qfwfq> Fuuzetsu: See https://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html and https://hackage.haskell.org/package/functor-infix-0.0.1/docs/Data-Functor-Infix.html.
15:14:09 <jmcarthur> i basically like fmap.fmap, honestly
15:14:10 <Fuuzetsu> haha
15:14:16 <Fuuzetsu> that second one is great
15:14:26 <Qfwfq> Thanks, I wrote it. <3
15:14:31 <jmcarthur> omg
15:15:09 <Fuuzetsu> oh, now I know who you are ;)
15:15:17 <funfunctor> ugh this is so annoying
15:15:57 <jmcarthur> funfunctor: you asked how you would "get that going", but i don't know what getting it going means
15:16:20 <sternenseemann> when scrolling these docs you feel like you'd taken durgs o_O
15:16:24 <sternenseemann> *drugs
15:16:43 <EvanR_> teh durgs
15:17:13 <funfunctor> jmcarthur: just the No instance for (Binary (Complex Word16)) issue, its just annoying because I had some python code that had issues and I though (oh surely I can just write this in haskell instead)
15:17:44 <funfunctor> python was not serializing into pure binary the way I intended it to
15:17:50 <jmcarthur> funfunctor: you could convert it to a (Word16, Word16) and use that binary instance
15:18:15 <sinelaw> jmcarthur, hey
15:18:23 <jmcarthur> sinelaw: what's up?
15:18:49 <sinelaw> jmcarthur, working on this https://github.com/sinelaw/infernu
15:19:10 <EvanR_> you renamed it?
15:19:23 <sinelaw> EvanR_, unfortunetly (or not), I did.
15:19:28 <jmcarthur> cool!
15:19:29 <sinelaw> *unfortunately
15:19:36 <EvanR_> infernü
15:20:26 <sinelaw> JS prototypes are a headache to model in a reasonably simple type system
15:20:44 <ElectricSolstice> *looks at Data.Functor.Infix docs* @_@ I don't know anything about haskell, but why is it like that? Just guessing, but looks like it's hard coded for different number of args when looking at that doc.
15:20:45 <EvanR_> does anybody even use js prototype feature
15:20:50 <funfunctor> jmcarthur: awesome! thx for the quick fix
15:20:55 <jmcarthur> sinelaw: what the heck is the length method of a function?
15:21:04 <jmcarthur> funfunctor: glad i could help!
15:21:35 <sinelaw> jmcarthur, number of arguments in the definition
15:21:42 <sinelaw> jmcarthur, just as you'd expect
15:21:42 <jmcarthur> ah
15:21:47 <sinelaw> ;)
15:22:20 <jmcarthur> it's a weird name, but ghc stores function arity in closures too :)
15:22:31 <jmcarthur> well, in the info table at least
15:22:50 <jmcarthur> and in the lower bits of the pointer if known/possible at the time
15:23:24 <jmcarthur> everything has a length!
15:24:23 <sinelaw> EvanR_, the common usage of prototypes is for using functions as 'constructors'
15:24:34 <sinelaw> chaining them is less common, at least I hope
15:24:50 <EvanR_> like new f() ?
15:25:21 <akfp`> If I have data Foo a b c = ..., what is a "3-argument" functor called, such as:  f :: (a->a', b->b', c-c') -> Foo a b c -> Foo a' b' c'
15:25:24 <sinelaw> EvanR_, yes, it's common syntax to do; function F() {..} F.prototype.method = function(...)
15:25:32 <EvanR_> oh
15:25:40 <EvanR_> weird
15:26:02 <EvanR_> seems kind of like "we can so we will"
15:26:03 <sinelaw> EvanR_, more readable (and faster) than assigning all those methods in the constructor body
15:26:05 <jmcarthur> akfp`: sounds like Applicative to me :)
15:26:10 <jmcarthur> :t liftA3
15:26:11 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
15:26:14 <EvanR_> sinelaw: yeah, performance
15:26:17 <jmcarthur> oh
15:26:19 <jmcarthur> nevermind
15:26:21 <jmcarthur> i misread
15:26:54 <jmcarthur> akfp`: there are Bifunctors, which are types that are functors over two argument. i guess your thing would be a Trifunctor
15:27:01 <quchen> akfp`: That would be a Trifunctor of sorts.
15:27:06 <quchen> Oh, too late.
15:27:26 <sinelaw> so I'm thinking function types should actually wrapped in tuples: (f, p) where f is a function type, p is the type of the associated prototype
15:27:27 <augur> quchen: i didnt bother to email. 7.10 is already in a release candidate, they wont listen
15:27:28 <EvanR_> BOX x BOX x BOX -> BOX
15:27:33 <jonkri> I have a stupid question. :) In persistent, how can I go from "Entity <Type>" to "Key <Type>"?
15:27:51 <quchen> augur: "I did not bother telling them" and "they won't listen" sound contradictory.
15:28:18 <augur> quchen: interesting, because they're not contradictory :)
15:28:20 <akfp`> jmcarthur: quchen: right, so bimap (bifunctor) is very similar.  thanks.
15:28:35 <sinelaw> denotationally equivalent to tuples, that is.
15:28:54 <Clint> jonkri: use entityKey or pattern matching
15:29:05 <quchen> akfp`: One problem with "longer" functors is that you need increasinly many to distinguish between the co-/contravariant forms.
15:29:54 <jonkri> Clint: Thank you. :)
15:30:06 <akfp`> quchen: expand?
15:30:24 <akfp`> quchen: can you expand on that?
15:31:32 <quchen> There's Functor and CovariantFunctor, there's CovCovBifunctor, ConCovBifunctor, CovConBifunctor, ConConBifunctor, and for Trifunctor there would be
15:31:36 <quchen> > intercalate ", " [ a ++ b ++ c ++ "Functor" | let x = ["Cov", "Con"], a <- x, b <- x, c <- x]
15:31:37 <lambdabot>  "CovCovCovFunctor, CovCovConFunctor, CovConCovFunctor, CovConConFunctor, Con...
15:31:55 <akfp`> ouch. scary stuff.
15:32:03 <quchen> Not really scary, just a load of it.
15:32:42 <quchen> akfp`: Covariant functor in Haskell is simply one where "fmap' :: (a -> b) -> f b -> f a".
15:33:04 <quchen> An example is (-> a), where fmap f g = g . f.
15:33:10 <quchen> fmap', I mean.
15:33:27 <quchen> It looks a bit like a flipped version of Functor.
15:34:37 <quchen> "Covariant" simply means that the functor turns an arrow from (a -> b) to an arrow from (f a -> f b).
15:34:47 <quchen> Contravariant takes an (a -> b) to an (f b -> f a).
15:35:21 <quchen> Maybe you've heard about covariance in OOP languages like Java, there it's the same principle, where arrows denote "is a subtype of".
15:36:24 <akfp`> quchen: yes.  what is an example of a contravariant functor?
15:36:43 <zq> type MyContraFunctor p = p -> Bool
15:36:56 <quchen> akfp`: In Haskell or Java?
15:37:14 <quchen> In Haskell zq's answer is probably the easiest one.
15:37:26 <EvanR_> whats an example of a contravariant functor in java
15:37:27 <drewbert> I'm having a problem with interactive-haskell.  When I run haskell-process-do-type on things that used to work, it now says "Not in scope"
15:37:39 <drewbert> I'm using Emacs24
15:37:43 <akfp`> quchen: I'm confused.  You said: Covariant functor in Haskell is simply one where "fmap' :: (a
15:37:43 <akfp`> 	 -> b) -> f b -> f a".  Didn't you just turn the arrow to make fmap' contravariant?
15:38:02 <Zemyla> Fun fact: If somethingnis both a normal functor and a contravariant functor, the type is a phantom.
15:38:16 * hackagebot yaml-light-lens 0.3.1.7 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.7 (AnthonyCowley)
15:38:21 <ttt_fff> why is it easier for idris than haskell to have a -> js compiler ?
15:38:32 <quchen> akfp`: Did I say that? Woops. Contravariant is the one that's flipped, with "Covariant" being the ordinary Functor.
15:38:54 <akfp`> quchen: ok. thanks.
15:39:02 <quchen> contrafmap :: (a -> b) -> f b -> f a, fmap = covariantfmap :: (a -> b) -> f a -> f b
15:41:33 <quchen> akfp`: For some reason, covariant functors are a lot more useful than contravariant ones, hence Functor is ubiquitous and ContraFunctor is in some library.
15:41:55 <edwardk> quchen: working on fixing that (the fact that folks view contravariant functors as less useful)
15:42:05 <edwardk> quchen: i've been getting a ton of mileage out of them lately
15:42:38 <edwardk> This last summer I figured out when talking to xplat at Hac Boston that we can make a contravariant form of 'Applicative' -- and that it is _quite_ useful
15:43:00 <quchen> edwardk: Oh? Do you have an example?
15:43:14 <edwardk> sure. several.
15:43:40 <quchen> edwardk: I can see the usefulness of certain things that just don't quite make it to the "absolutely great" domain. Comonads are an example. But that might just be a personal or cultural problem.
15:43:51 <edwardk> class Contravariant f => Divisible f where divide  :: (a -> (b, c)) -> f b -> f c -> f a; conquer :: f a -- is the Applicative in question
15:43:58 <Zoetrope_> ttt_fff: Smaller, newer compiler I'd say
15:44:14 <ttt_fff> Zoetrope_: yeah, I was thinking the same
15:44:16 <edwardk> think of 'divide' as liftA2 where the argument (a -> b -> c)  is curried (a, b) -> c   and flipped
15:44:24 <ttt_fff> probably easier when, fron the start, you have "not only x86, but also js"
15:44:34 <akfp`> zq: quchen: I don't get the example.  So I have a function f :: p -> q, and MyContraFunctor q (q -> Bool) , and I get a MyContraFunctor p (p -> Bool).  So contrafmap :: (p -> q) -> (q -> Bool) -> (p -> Bool).  Weird.  it works out!  I need to let this sink in.  Weird stuff.
15:44:38 <quchen> edwardk: What would example instances be?
15:44:38 <edwardk> we also have a contravariant 'Alternative'
15:44:57 <edwardk> class Divisible f => Decidable f where choose :: (a -> Either b c) -> f b -> f c -> f a;  lose :: (a -> Void) -> f a
15:45:09 <Zoetrope_> Yeah, I think backend genericism was in mind from early on
15:45:10 <edwardk> well, lets start with any contravariant functor that comes to mind.. first up, let's do Predicate
15:45:32 <edwardk> instance Divisible Predicate where  divide f (Predicate g) (Predicate h) = Predicate $ \a -> case f a of   (b, c) -> g b && h c;  conquer = Predicate $ const True
15:45:42 <quchen> Predicate comes to mind so much it must be terminal or initial *somewhere* ;-)
15:45:47 <edwardk> basically it lets you split out your structure into two parts and apply both predicates
15:45:54 <int-index> Seeing that edwardk and merijn are online now, I'm going to repeat my question. Given a heterogeneous list (from vinyl) and a function that takes the values from this list as arguments, how do I move the first value of the list to the end, flipping function arguments accordingly? Relevant part of my code: http://lpaste.net/6213960968775401472
15:46:21 <edwardk> conquer is the unit of divide in the same sense True is the unit of (&&)
15:46:32 <edwardk> we also have that Predicate is "Decidable" (contravariant alternative)
15:46:48 <edwardk> instance Decidable Predicate where lose f = Predicate $ \a -> absurd (f a); choose f (Predicate g) (Predicate h) = Predicate $ either g h . f
15:47:13 <edwardk> so that says, if 'a' can't occur at all (a -> Void)  -- then we can use that mapping to handle the impossible case
15:47:33 <edwardk> and if we can split into two different cases and can handle both we can give you a joint predicate
15:47:38 <SrPx> Is there a way to set the first element of a tuple to the result of a monadic action using lens? i.e., shortening `do { newVal <- action (tuple^._1); return ((_1 .~ newVal) tuple) }`
15:47:42 <quchen> Interesting. So these instances would kind of be generalizing logic programming?
15:47:47 <edwardk> this is a nice worked example because it shows the sort of 'monoidal' structure you'd expect
15:47:49 <edwardk> this one is
15:47:53 <edwardk> lets do something more interesting
15:48:06 <antitone-pyon> How much time should it take me to reimplement Data.Set, so that it can take advantage of this notion of monotone morphism? http://lpaste.net/124228
15:48:11 <edwardk> newtype Comparison a = Comparison { getComparison :: a -> a -> Ordering }
15:48:23 <edwardk> now divide is responsible for lexicographically ordering two comparisons
15:48:34 <edwardk> conquer always returns EQ
15:48:43 <edwardk> lose uses the fact that the case is absurd to rule it out
15:48:55 <phaazon> I think I’m gonna write a new article about FRP and netwire
15:49:00 <phaazon> but not sure it’ll help people
15:49:06 <supki> SrPx: _1 action tuple
15:49:07 <phaazon> I just think we lack material about that
15:49:15 <edwardk> and choose treats lefts as less than rights, and compares if both are left or both are right using the constituent orders
15:49:21 <quchen> phaazon: I'll read it, if that helps!
15:49:29 <edwardk> ou can do the same thing for Equivalence classes
15:49:49 <quchen> edwardk: Wait, lexicographically ordering *comparisons*?
15:49:52 <edwardk> in fact, you can do this for  newtype Op r a = Op { getOp :: a -> r } -- as long as r is a Monoid
15:49:56 <SrPx> supki: wait what. Thanks.
15:50:17 <edwardk> quchen: instance Divisible Comparison where divide f (Comparison g) (Comparison h) = Comparison $ \a b -> case f a of (a',a'') -> case f b of (b',b'') -> g a' b' `mappend` h a'' b''; conquer = Comparison $ \_ _ -> EQ
15:50:17 <quchen> SrPx: %%~ if you wish
15:50:29 <edwardk> > EQ <> LT
15:50:29 <funfunctor> can anyone see if there is a error in the maths here, like a truncated double to int or something http://lpaste.net/124240
15:50:30 <lambdabot>  LT
15:50:35 <edwardk> > LT <> GT
15:50:37 <lambdabot>  LT
15:50:53 <SrPx> No really, how this works? "_1 action tuple"
15:50:56 <edwardk> the Monoid on Ordering glues together the results as if you were comparing lexicographically
15:51:13 <codehero> > 'a' <> 'f'
15:51:14 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:51:14 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
15:51:17 <codehero> hmm
15:51:24 <quchen> Ah, so just like Alternative often feels like a lifted Monoid, this would be another thing in that spirit. I can't formalize this properly, but from the looks of it that seems to work.
15:51:27 <jle`> codehero: what did you expect?
15:51:38 <codehero> that it compares them
15:51:43 <codehero> i don't know
15:51:46 <quchen> <> = mappend
15:51:48 <jle`> ah, that would be `compare`
15:51:57 <edwardk> quchen: for Decidable: choose f (Comparison g) (Comparison h) = Comparison $ \a b -> case f a of Left c -> case f b of { Left d -> g c d; Right{} -> LT }; Right c -> case f b of { Left{} -> GT; Right d -> h c d }
15:51:59 <jle`> <> is mappend, it "combines" two things
15:52:01 <codehero> quchen: oh.. well
15:52:03 <jle`> > "hello" <> "world"
15:52:05 <lambdabot>  "helloworld"
15:52:11 <glguy> SrPx: _1 is like "mapM" for the first element of a tuple
15:52:22 <codehero> i didn't know that you could combine LT and GT
15:52:28 <edwardk> quchen: formally these are 'monoid objects of contravariant Day convolution'
15:52:33 <codehero> i expected that it would compare them
15:52:38 <jle`> 'a' <> 'b' has to be some Char that combines both 'a' and 'b'...and no such Char really meaningfully exists
15:52:42 <edwardk> quchen: so far so good?
15:52:47 <glguy> SrPx: That's all that Lens and Traversal are
15:52:48 <jle`> codehero: ah yeah, <> is a function that combines LT and GT in a useful way :)
15:53:00 <glguy> SrPx: Just generalized mapM
15:53:10 <edwardk> quchen: now we can go down the rabbit hole further
15:53:12 <phaazon> quchen: :)
15:53:14 <SrPx> glguy: oh...
15:53:27 <phaazon> I find it quite hard to know exactly which model I should use to react to events
15:53:30 <quchen> edwardk: I can follow along, but I don't really get the intuition you're probably trying to convey. But examples are usually a good way of making sense of classes.
15:53:48 <jle`> SrPx: you know how you can replace `show x` with `f x`, where f :: Thing -> String ?
15:53:48 <edwardk> newtype Disc a = Disc { (%) :: forall b. [(a,b)] -> [[b]] } -- is an incredibly useful Decidable functor.
15:53:59 <phaazon> there’s event accumulation, event-based switching (switch, kSwitch, etc.), inhibition
15:54:11 <jle`> SrPx: a lens is just any function that fits the type signature of `mapM`/`traverse`
15:54:12 <edwardk> here its responsible for 'discriminating' between 'a's by placing them into some kind of ordering or equivalence class, then giving back the individual equivalence classes or sorted groups
15:54:32 <jle`> a lens is to traverse as `show` is to any ol `f :: Thing -> String`, roughly
15:54:35 <edwardk> you can view Disc as sort of Comparison/Equivalence on steroids
15:54:55 <EvanR_> jle`: a b ligature ;)
15:55:00 <edwardk> quchen: https://github.com/ekmett/discrimination/blob/master/src/Data/Discrimination/Type.hs#L72 has the instances for Disc
15:55:03 <SrPx> Is traverse a generalization of mapM?
15:55:06 <jle`> edwardk: ;)
15:55:10 <jle`> SrPx: traverse is mapM for Applicative
15:55:22 <jle`> so you can replace `mapM` for `traverse` there and get roughtly the same intuition
15:55:27 <jle`> :t traverse
15:55:28 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:55:29 <jle`> :t mapM
15:55:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:55:35 <phaazon> yeah
15:55:38 <edwardk> the nice thing is you can use it to do _linear_ time sorting and discrimination for most haskell data types, because it can side-step the pairwise comparison limit
15:55:41 <jle`> :t T.mapM
15:55:41 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:55:42 <phaazon> traverse is not an Applicative mapM
15:55:42 <quchen> mapM is the historical accident that is now shadowed by traverse.
15:55:48 <phaazon> it’s a generalization of mapM
15:56:06 <quchen> edwardk: Huh wait what
15:56:15 <jle`> it's an Applicative mapM in the same way that sequenceA is an applicative sequence
15:56:20 <edwardk> quchen: think 'radix sort on steroids'
15:56:25 <quchen> edwardk: Are you breaking fundamentals of maths again?
15:56:30 <edwardk> quchen: yes
15:56:31 <phaazon> jle`: it’s weird saying tha
15:56:32 <jle`> sequenceA is sequence generalized to work on all Applicative
15:56:32 <edwardk> its a Sunday
15:56:34 <phaazon> that*
15:57:36 <edwardk> quchen: i have another one that does linear time joins as well
15:58:02 <SrPx> Hmm okay, thanks guys :) very enlightening, I got to test that now
15:58:09 <edwardk> quchen: moreover it can do them on things like IORefs that have no right to be less than O(n^2) to partition into equivalence classes
15:58:15 <quchen> edwardk: You probably have one that solves TSP in O(n^2)
15:58:24 <edwardk> quchen: only approximately =)
15:58:36 <sinelaw> how does it do the equivalence in linear time?
15:58:43 <edwardk> TSP is quite easy if you have a triangle inequality
15:58:48 <edwardk> sinelaw: think radix sort
15:59:33 <edwardk> sinelaw: basically the trick is to break down the pieces into case we can handle in linear time due to radix sorting
16:00:00 <edwardk> and use the divisible/decidable machinery above to do it
16:00:40 <edwardk> quchen: stepping back from discrimination for a sec, we can do a lot with these as 'consumers' of generic data types:
16:00:40 <edwardk> http://ekmett.github.io/discrimination/src/Data-Discrimination-Generic.html#Deciding
16:00:59 <edwardk> class (Generic a, GDeciding q (Rep a)) => Deciding q a where deciding :: Decidable f => p q -> (forall b. q b => f b) -> f a
16:01:06 <edwardk> is the core bit of generic programming i'm doing there
16:01:09 <edwardk> so lets see what it says
16:01:53 <quchen> edwardk: Is this by any chance something you're planning on presenting at ZuriHac?
16:02:11 <edwardk> it says give me a proxy for some constraint you are interested in, e.g. Ord, Eq, etc.  and a function that says given that constraint on any type b  i can give you a member of f b, which is you Decidable functor, then I can give you an 'f a'
16:02:20 <edwardk> quchen: possibly, haven't picked my talk topic for there yet
16:02:56 <quchen> I don't know the alternatives, but I'd love to hear more about this in case you're undecided. :-)
16:02:56 <edwardk> gcompare :: Deciding Ord a => a -> a -> Ordering; gcompare = getComparison $ deciding (Proxy :: Ord) (Comparison compare)
16:03:19 <edwardk> gcompare is not a generic definition for compare that uses the ability to compare the leaf level generic elements in 'a'
16:03:32 <edwardk> geq = getEquivalence $ deciding (Proxy :: Eq) (Equivalence (==))
16:03:34 <edwardk> is a generic equality
16:03:51 <edwardk> gives a default definition you could use for (==) if we didn't have deriving (Eq) in the world
16:04:43 <edwardk> and we can build up the same things for discrimination, we can have discrimination that gives you only equivalence class-style partitioning, and we can have discimination that gives you sorting/partitioning radix style, both of which are classes in that half-finished package
16:05:33 <edwardk> class Grouping a where grouping :: Grouped f => f a; default grouping :: (Grouped f, Deciding Grouping a) => f a; grouping = deciding (Proxy :: Proxy Grouping) grouping
16:05:47 <edwardk> that lets me overload specific cases like Ints, etc. to do radix sorting
16:05:55 <edwardk> and let generics handle all the rest of the structure
16:06:04 <quchen> That's pretty impressive.
16:06:22 <edwardk> and the net result is linear time sorting/partitioning for almost everything
16:06:54 <quchen> In the end, might there be a very simple API similar to free's "improve"?
16:07:25 <edwardk> it has been a fun low-priority project for me
16:07:30 <edwardk> well, sort of
16:07:44 <edwardk> you get an API like:
16:07:45 <edwardk> nub :: Grouping a => [a] -> [a]
16:07:51 <edwardk> but now that nub is linear time
16:08:04 <edwardk> sort :: Sorting a => [a] -> [a] -- linear time as well
16:08:13 <EvanR_> head explode
16:08:15 <edwardk> http://ekmett.github.io/discrimination/Data-Discrimination-Combinators.html
16:08:27 <ocharles_> Anyone here got any recommendations for using Haskell to write Haskell code? I can build up an AST in haskell-src, but it's really painful
16:08:37 <ocharles_> was hoping there were some quasiquoters available
16:08:53 <edwardk> and you can just write instance Deciding Grouping Foo => Grouping Foo -- with no body for almost all data types you want
16:09:13 <edwardk> the join API is currently a bit messier
16:09:32 <edwardk> but it lets us do discrimination-based inner/outer/left/right joins in linear time in the size of the input and output
16:09:42 <quchen> ocharles_: Volkov built his own parser for his records I think :-\ But maybe that's changed, he might be a good person to ask
16:09:47 <mniip> ohh, it's an edwardk!
16:09:53 * edwardk waves
16:10:03 <ocharles_> quchen: wasn't that haskell-src-meta?
16:10:08 <EvanR_> quick throw a pokeball
16:10:10 <EvanR_> not very effective
16:10:35 <quchen> ocharles_: Not that I know at least. But I might be wrong, as usual.
16:11:18 <mniip> EvanR_, kind mismatch!
16:11:25 <quchen> You could ask him anyway to see what solution he's come up with in the meanime, ocharles_ 
16:11:33 <ocharles_> yea, not a bad idea
16:11:41 <edwardk> quchen: anyways, like with comonads, contravariant functors are a bit of a niche, compared to the covariant kind, but there is a surprising amount you can do with them
16:11:50 <jmcarthur> edwardk: i'd been meaning to implement discriminators, but i am glad you are already on the case, so i will simply await the release of your implementation
16:12:16 <edwardk> quchen: we can also build a contravariant functor for forcing things, parallel.strategies style, and all the divisible/decidable machinery just works
16:12:28 <jmcarthur> i also wasn't planning on doing the tricky IORef stuff, so i'm glad you're doing it!
16:13:14 <EvanR_> ... how do you sort IORefs ?
16:13:18 <quchen> edwardk: I'll let that sink in overnight. I think up to the ordering part I got a pretty good idea about the utility of this. The parts after that seem a bit magic still, but I'll get there.
16:13:20 <edwardk> getSeq $ deciding (Proxy :: Proxy NFData) (Seq rnf) -- could give you a generic rnf suitable for a default definition in NFData using the same machinery
16:13:24 <jmcarthur> EvanR_: low level trickery
16:13:28 <quchen> edwardk: I can't get over linear time sorting ;-)
16:13:28 <EvanR_> k
16:13:44 <ocharles_> quchen: oh I just saw that you can pretty print Template Haskell
16:13:55 <edwardk> EvanR_: first observation, you shouldn't be able to. basically we want to break up IORefs into _equivalence classes_ based on (==)
16:13:57 <whiteline> why is a Data.Map.Map not a Functor?
16:13:58 <jmcarthur> quchen: it's not *exactly* linear time. it's still O(log n) since there must be at least log n bits of information to distinguish n elements
16:14:20 <jmcarthur> quchen: it's just radix sort
16:14:21 <edwardk> but within a GC we can use the address of the IORef as an integer representing its equivalence class
16:14:26 <quchen> ocharles_: Maybe, but as far as I recall TH doesn't necessarily generate runnable code when printed. At least that's what I've heard roughly 2 years ago.
16:14:37 <ocharles_> sure, i will have to be careful
16:14:49 <ocharles_> worst comes to worst i'll just get a compiler error
16:15:01 <edwardk> but if  give back the equivalence classes in the order we encounter them, not the order they'd sort into by those temporary integer assignments, we give a result that is stable across GCs.
16:15:05 <quchen> jmcarthur: Somewhat-O(n) is confusing enough for me.
16:15:25 <SrPx> @pl Is there any shortcut for "foo (return . fn)" ?
16:15:25 <lambdabot> (line 1, column 48):
16:15:25 <lambdabot> unexpected end of input
16:15:25 <lambdabot> expecting white space or simple term
16:15:35 <SrPx> woops
16:15:50 <edwardk> so what I do is take the [(IORef a, b)]'s you give me, force the list of pairs all the way down to each IORef, counting up references as I go
16:15:57 <jmcarthur> quchen: you can't consider this O(n) to be describing the same thing as the O(log n) of a decent comparison sort. you aren't really doing the same kind of comparisons
16:16:02 <edwardk> now I know how many entries I have
16:16:19 <edwardk> I make a MutableByteArray# with enough room to store that many addresses.
16:16:52 <edwardk> and then i call a custom foreign prim that walks hand over hand through a list of pairs of IORefs that _must_ be forced hand-skipping-past all the forwarding pointers
16:17:00 <edwardk> since i'm in a foreign prim GC can't happen
16:17:10 <edwardk> because i never check in with the RTS
16:17:15 <dibblego> codehero: FYI there is #nicta-course
16:17:21 <edwardk> and i copy the addresses into the mutablebytearray
16:17:42 <codehero> dibblego: oh. cool. thanks :)
16:17:45 <edwardk> when i'm done i can copy those addresses back into the input list [(Addr, b)] -- and discriminate up to equivalence (not sorting)
16:17:53 <EvanR_> edwardk: ok so some of the stuff involved isnt normal ghc operations
16:17:58 <phaazon> ocharles_: how can you use Applicative only to use netwire?
16:18:11 <edwardk> EvanR_: for IORefs and STRefs. for everything else its implementable in straight haskell
16:18:11 <ocharles_> phaazon: you can't use only applicative, it's applicative + category
16:18:20 <phaazon> yeah, sure
16:18:22 <phaazon> but still
16:18:27 <phaazon> I have two wires
16:18:39 <edwardk> EvanR_: with just pairwise equality comparisons its Omega(n^2) -- you can't do better.
16:18:39 <phaazon> one that takes a value and outputs another
16:18:46 <phaazon> like Wire s e m a b
16:18:54 <edwardk> with just pairwise ordering comparisons its Omega(n log n) -- you can't do better
16:19:07 <phaazon> and another wire, Wire s e m (a,d) (a,d)
16:19:11 <EvanR_> right
16:19:12 <edwardk> with the radix trick its Theta(n) -- best and worst bounds meet
16:19:32 <phaazon> the final type of the wire should be Wire s e m (a,d) b
16:19:37 <edwardk> The trick isn't mine, its based on a couple of papers by Fritz Henglein
16:19:43 <phaazon> I know how to compose that with -XArrows
16:19:45 <phaazon> but without it…
16:19:47 <edwardk> He has a more "initial" encoding of the problem
16:19:47 <phaazon> I feel lost
16:19:56 <phaazon> like, a ton of boilerplate :(
16:19:58 <edwardk> But when you make it final like this you get "all the instances"
16:20:09 <edwardk> which feels really really nice to work with
16:20:31 <phaazon> the arrow-do version is simple: wire0 -< a; wire1 -< (a,d)
16:20:34 <phaazon> something like that
16:20:36 <Hijiri> >>> arr fst >>> firstwire ?
16:20:47 <phaazon> Hijiri: you’re using Arrow here
16:20:50 <Hijiri> oh
16:20:52 <Hijiri> right
16:21:00 <phaazon> ocharles_ said he knows how to do that with only applicative and category
16:21:12 <EvanR_> this is the kind of stuff im missing in #haskell by being asleep at 6pm
16:21:32 <jmcarthur> edwardk: in what sense is Data.Discrimination.Table a table? it looks like FMList with its length cached
16:21:33 <ocharles_> phaazon: can you give me the two things you have and their types?
16:21:33 <phaazon> and that’s an aspect of netwire that makes me very anxious
16:21:36 <phaazon> it’s just a very simple case
16:21:44 <jle`> what's wrong with proc notation
16:21:49 <phaazon> how complex my types and code will be with a “real world” example
16:21:57 <phaazon> ocharles_: yeah
16:22:02 <Hijiri> fmap fst and then >>> with first wire?
16:22:04 <jle`> are you ignoring the results of wire0 ?
16:22:04 <edwardk> in theory one could extend Eq and Ord with members for discrimination, and have the derive'd Eq and derive'd Ord generate the fancy ones, while falling back on a lame implementation that is always legal if the user defined the instance by hand
16:22:09 <ocharles_> jle`: it's awkward, I constantly confuse myself with let bindings and scope there
16:22:11 <edwardk> jmcarthur: that is exactly what it is.
16:22:20 <ocharles_> it has like two different scopes at the same time
16:22:24 <ocharles_> not to mention it just doesn't need to exist
16:22:32 <edwardk> jmcarthur: look at a couple of fancy things it can do though: (*>) and (<*) have dead-sexy implementations
16:22:40 <edwardk> jmcarthur: also the Traversable for it is magic.
16:22:43 <ocharles_> once we get idiom brackets and applicative do, we're in an even better place!
16:22:50 <phaazon> god I can’t copy my nvim content
16:22:52 <phaazon> rrrgh
16:23:02 <jle`> phaazon: if you're ignoring the results of wire0, it's just `first wire0 *> wire1`
16:23:13 <edwardk> jmcarthur: basically its designed as an efficient multiset
16:23:27 <edwardk> jmcarthur: table's primary use is with Join however.
16:23:35 <edwardk> jmcarthur: becaue i need an efficient multiset i can do joins with
16:23:56 <edwardk> and i'm going to be adding a more traditional Set, etc. so the Multiset vocabulary is a bit awkward to adopt
16:24:10 <jle`> if a0 :: r a e, a1 :: r (a, b) (c, d), then (first a0 *> a1) :: r (a, b) (c, d)
16:24:13 <phaazon> ocharles_: http://lpaste.net/2439583789685407744
16:24:16 <edwardk> because another thing that can fit into this bag of toys is a Set with linear time fromList, that otherwise acts like normal
16:24:18 <phaazon> jle`: that’s a good point, yeah
16:24:27 <edwardk> same with a Map
16:24:42 <ocharles_> phaazon: you want to write mainWire without -XArrows?
16:24:45 <EvanR_> a presorted list
16:24:45 <edwardk> each of which has a rather generic trie-like structure
16:25:00 <jle`> yeah that just looks like `first (unless hasQuit) *> intro ratio phong_`
16:25:01 <phaazon> ocharles_: yeah, and I guess jle` gave the answer
16:25:07 <EvanR_> or sortable in linear time
16:25:09 <phaazon> still
16:25:12 <phaazon> that uses arrow.
16:25:13 <jle`> idk if that's more readable than the proc notation version though
16:25:15 <edwardk> anyways, i'll probably ship discrimination-0 pretty soon as it is
16:25:20 <edwardk> and get some mindshare with the ideas
16:25:24 <ocharles_> phaazon: then use first'
16:25:25 <jmcarthur> edwardk: ah, i see, knowing the lengths lets you write an efficient replicate
16:25:27 <edwardk> i don't currently have the IORef/STRef primop finished
16:25:31 <ocharles_> now you're just using strong profunctors ;)
16:25:36 <edwardk> jmcarthur: yep =)
16:25:44 <phaazon> strong profunctors? :(
16:25:56 <phaazon> I just want to make a stupid and damned game loop
16:25:59 <ocharles_> http://hackage.haskell.org/package/profunctors-4.4.1/docs/Data-Profunctor.html#v:first-39-
16:26:00 <phaazon> what strong profunctors :D
16:26:01 <Hijiri> is there anything wrong with fmap fst adwire >>> abwire?
16:26:14 <edwardk> and given Monoid m => (a -> m) -> m  -- i can replicate either of those m's. one repeats the monoidal result per element, the other repeats the monoidal result for the whole multiset
16:26:17 <jle`> Hijiri: that feeds the output of adwire into abwire
16:26:20 <Hijiri> oh
16:26:31 <jle`> phaazon: strong profunctors are just first' and second' without having to touch Arrow
16:26:33 <jmcarthur> edwardk: and indeed that Traversable is pretty awesome
16:26:37 <jle`> i think it was mostly a tongue-in-cheek answer...
16:26:38 <edwardk> phaazon: Strong is basically 'not-quite-arrow'
16:26:48 <jle`> you don't gain much from using first' adn second' if you are working on a concrete type
16:26:50 <phaazon> so bifunctors?
16:27:00 <edwardk> jmcarthur: the traversable is neat in that it lets you build up the result applicative _with sharing_ and the resulting structure still retains sharing. =)
16:27:18 <jle`> i don't really know what's wrong with using `first` on a concrete type when that's exactly what you need :P
16:27:18 <ocharles_> phaazon: no, bifunctors are covariant in both arguments
16:27:27 <ocharles_> nothing is, i'd use it
16:27:29 <jmcarthur> that doesn't even require the cached length, if i'm understanding it correctly? that should probably go into the fmlist package
16:27:31 <edwardk> jmcarthur: so you can traverse over (rep 100000000 (pure "a")) -- and it only takes log n uses of (<*>)
16:27:40 <jmcarthur> well okay, there's that
16:27:52 <phaazon> ocharles_: imagine I pass more values as inputs
16:27:53 <jle`> unless you are allergic to Arrow :)
16:27:53 <phaazon> such as
16:28:06 <phaazon> (Event QzrEvents,IntroAssets,Stuff,Foo,Bar)
16:28:06 <ocharles_> i'm pretty sure you can write first using just category and applicative though
16:28:24 <edwardk> yeah that trick fits in the general fmlist mold
16:28:36 <jle`> you can write first with Applicative and Category
16:28:38 <jle`> but it's pretty awkward
16:28:46 * ocharles_ nods
16:28:46 <jmcarthur> there should be a Data.Monoid.replicate. i recall your monoids package having that a long time ago.
16:28:47 <jle`> unless you alias it as firstAC or something
16:28:59 <edwardk> :t replicate
16:29:00 <lambdabot> Int -> a -> [a]
16:29:05 <edwardk> ^- has the wrong type
16:29:06 <jmcarthur> meh
16:29:27 <edwardk> hence why i don't use exactly that name
16:29:45 <edwardk> i think i call it times these days in general
16:29:47 <edwardk> and times1p in semigroups
16:29:48 <ocharles_> phaazon: well, tuples are inherently annoying to work with. if you have a product of values going in, then I'd use a record. but each "component" in your composition is going to have to pull out the data it needs
16:29:51 <edwardk> :t Data.Semigroup.times1p
16:29:52 <lambdabot> (Data.Semigroup.Semigroup a, Numeric.Natural.Internal.Whole n) => n -> a -> a
16:29:57 <ocharles_> you can choose what data you want by lmap'ping
16:29:58 <edwardk> because that replicates n + 1 times
16:30:00 <sinelaw> edwardk, what do you use as the key in the key/value pair during equivalence partitioning? the value type is arbitrary
16:30:05 <ocharles_> again, from profunctors
16:30:06 <jmcarthur> mconcatReplicate doesn't quite roll off the tongue
16:30:12 <ocharles_> you can also do it by fmap'ing over id
16:30:14 <sinelaw> or did I read it wrong
16:30:15 <ocharles_> but I find that weirder
16:30:28 <phaazon> fmaping over id
16:30:30 <phaazon> :D
16:30:37 <phaazon> in order to forward the input?
16:30:53 <phaazon> and because arrows are contravariant in « b », in that case, they’re profunctors?
16:31:06 <edwardk> sinelaw:  newtype Disc a = Disc { (%) ::  forall b.  [(a,b)] -> [[b]] } -- a discriminator can do almost anything it wants as long as it yields a valid set of equivalence classes either in the original order, or sorted
16:31:12 <edwardk> (or a weird mixture of both)
16:31:23 <jmcarthur> sinelaw: the key is generally something from the "head" of whatever data structure it is
16:31:27 <ocharles_> phaazon: they are contravariant in their first argument
16:31:38 <phaazon> yeah
16:31:39 <edwardk> e.g. conquer = Disc $ \xs -> [fmap snd xs]
16:31:41 <ocharles_> and yea, fmap whatever id lets you change the data flowing "in"
16:31:41 <phaazon> god
16:31:52 <phaazon> I think I eventually understand the use of profunctors!
16:32:19 <ocharles_> it's a use :) the only time I've used them though
16:32:24 <edwardk> phaazon: profunctors are like arrows that don't have all the baggage bolted on, e.g. the ability to compose, first, second, etc.
16:32:26 <phaazon> it’s a way to “transform” the intput
16:32:30 <edwardk> then we recover that baggage bit by bit
16:32:35 <jle`> mhm
16:32:37 <edwardk> by adding Category to Profunctor we get almost to Arrow
16:32:44 <phaazon> and mapping over
16:32:50 <jle`> there's this nice blog i know that did a series about hackage packages...and one of them was on profunctors
16:32:52 <sinelaw> edwardk, so it's expected that they are paired with 'a' values that are useful for the desired discrimination?
16:32:58 <edwardk> by replacing Profunctor with Strong we get 'first' and 'second'
16:32:59 <jle`> i can't quite remember the bloke who hosted it though
16:33:04 <edwardk> Strong and Category is 'Arrow'
16:33:05 <jle`> some british chap
16:33:05 <phaazon> I guess a profunctor has the power of Functor and Contravariant at the same time
16:33:15 <EvanR_> profunctor tutorial: I eventually understand profunctors
16:33:15 <jle`> phaazon: yes :)
16:33:15 <ocharles_> jle`: sounds like a helpful gent
16:33:19 * hackagebot validate-input 0.1.0.0 - Input validation combinator library  http://hackage.haskell.org/package/validate-input-0.1.0.0 (AlexanderThiemann)
16:33:21 <edwardk> sinelaw: the 'a's are the information we supply the discriminator, it knows nothing about 'b'
16:33:47 <phaazon> interesting
16:33:49 <jle`> in the language of arrows, lmap f a = a . arr f
16:33:54 <sinelaw> edwardk, right, so for generally radix-like sorting we need to have a-priori 'a' vlaues assigned conveniently
16:33:56 <sinelaw> ?
16:34:04 <edwardk> it just carries around whatever b's you give it, breaks them up into whatever equivalence classes or ordering you chose for the discriminator, and then has to give back the 'b's grouped by properties of 'a'
16:34:06 <jle`> but you know i am still really bugged that lmap, rmap, and dimap all have the wrong order
16:34:09 <ocharles_> jle`: or (f ^>>) :P
16:34:13 <jle`> phaazon: https://ocharles.org.uk/blog/guest-posts/2013-12-22-24-days-of-hackage-profunctors.html
16:34:24 <jle`> ocharles_: or (<<^ f) ?? ;)
16:34:25 <phaazon> yeah
16:34:31 * ocharles_ shudders
16:34:38 <edwardk> sinelaw: lets consider a discriminator for 'small numbers' that returns a radix sorted list in order
16:34:45 <jle`> i still don't like using lmap because it has the wrong order
16:34:47 <jle`> and dimap too
16:34:55 <jle`> but i guess it's better than (<<^)
16:34:55 <ocharles_> what do you mean "the wrong order"
16:34:59 <phaazon> I still have hard times using function-like-structures as Monads / Applicatives
16:35:00 <ocharles_> it makes all the other maps
16:35:08 <ocharles_> matches*
16:35:12 <jle`> for functions, lmap f g = g . f
16:35:23 <jle`> dimap f g h = g . h . f
16:35:26 <jmcarthur> sinelaw: that type is where the thing you are partitioning goes. the disc function may involve breaking that part down into smaller pieces recursively.
16:35:28 <jle`> they're on the wrong siddeee
16:35:35 <phaazon> so a *> b is a an arrow than takes a value, send it to both a and b, but only cares about b’s result
16:35:43 <ocharles_> right
16:35:51 <jle`> phaazon: it "forks" the input and feeds it to both a and b, but only cares about b's result
16:36:09 <edwardk>  sdiscNat n = Disc $ \xs -> filter (not . null) (bdiscNat n xs) where update vs v = v : vs; bdiscNat n' xs = reverse <$> Array.elems (Array.accumArray update [] (0,n') xs)
16:36:11 <jle`> ...yeah basically just what you said
16:36:21 <phaazon> :D
16:36:29 <jle`> ikr i just discovered this a few weeks ago too lol.
16:36:31 <sinelaw> jmcarthur, right - so no magic breakage of math here - I was wondering how one can generally do linear sorting on arbitrary types
16:36:42 <edwardk> sdiscNat :: Int -> DIsc Int -- sdiscNat n gives a discriminators for integers between 0 and n - 1 -- that does the radix sort
16:36:47 <phaazon> I’ve been using (*>) a lot with parsec
16:36:52 <phaazon> but that’s a different use
16:36:59 <edwardk> now we can build up more complicated ones using smaller radices
16:37:02 <jmcarthur> sinelaw: it's linear in the number of elements you are sorting, just like radix sort, but not linear in the sizes of each element, just like radix sort
16:37:06 <jle`> mhm
16:37:11 <phaazon> the more I learn stuff in Haskell
16:37:20 <jle`> liftA2 is also pretty useful for cat's/arrows too
16:37:31 <edwardk> e.g. to sort a Word32 i probably don't want 4 billion buckets
16:37:31 <phaazon> the more I understand why we call Functor, Applicative, Monoid and so, “powerful” abstractions
16:37:35 <phaazon> because they _are_ :D
16:37:38 <edwardk> but i could use 65536 buckets twice
16:37:42 <edwardk> sorting = divide (\x -> (fromIntegral (unsafeShiftR x 16), fromIntegral x)) (sdiscNat 65536) (sdiscNat 65536)
16:37:46 <jle`> liftA2 f a1 a2 is, fork the input and feed it to both a1 and a2, and "combine" their results with f
16:37:48 <jle`> phaazon: :D :D
16:38:02 <jle`> haskell, where "powerful" actually means powerful
16:38:12 <phaazon> jle`: well
16:38:19 <phaazon> liftA2 f a b forks only for arrows
16:38:21 <edwardk> sinelaw: basically the trick here is that the ADTs themselves are made out of products/sums and that the leaves are either trivial or radixable.
16:38:33 <phaazon> the general version of liftA2 just means… a binary lift
16:38:38 <edwardk> divide for Disc is fun
16:38:58 <edwardk>  divide k (Disc l) (Disc r) = Disc $ \xs ->  l [ (b, (c, d)) | (a,d) <- xs, let (b, c) = k a] >>= r 
16:39:02 <sinelaw> I'm beginning to see
16:39:06 * jmcarthur wonders if (some) exponentials might have interesting discriminators
16:39:12 <jle`> phaazon: i'm speaking in terms of Cateogry + Applicative
16:39:16 <phaazon> yeah
16:39:17 <phaazon> ok :)
16:39:38 <phaazon> oh yeah
16:39:53 <edwardk> bsically use your function to split a into (a', a'')   then turn [(a,b)] into [(a',(a'',b)]   and discriminate recursively
16:39:56 <phaazon> first (unless hasQuit <& unless (hasKey Escape KeyReleased)) *> scenes
16:40:00 <phaazon> works as a charm
16:40:08 <sinelaw> cool
16:40:18 <jle`> it also works on another popular cat+applicative pair, (->)
16:40:20 <phaazon> I guess I could factor the unless
16:40:38 <jle`> > (liftA2 (+) length sum) [1,2,3]
16:40:39 <lambdabot>  9
16:40:43 <jle`> phaazon: nice :)
16:40:46 <edwardk> jmcarthur: now, the interesting part that fritz _didn't_ discover is that you can do equivalence class partitioning _productively_
16:40:47 <ocharles_> phaazon: have a read of https://ocharles.org.uk/IdiomBrackets.html
16:40:58 <jmcarthur> edwardk: nice!
16:41:01 <ocharles_> and you'll see why I think we can get by with just applicative and category (see the FRP examples)
16:41:08 <jle`> (*>) is just slightly less useful for (->)
16:41:08 <edwardk> jmcarthur: you can write a discriminator that produces the results in each equivalence class lazily
16:41:33 <edwardk> this is useful for cases like nub / distinct where you just care about the head of each equivalence class
16:41:35 <jmcarthur> i see how that would work
16:41:43 <jmcarthur> very nice
16:41:45 <edwardk> and so you can start producing it live as you consume the input
16:41:50 <edwardk> its more memory intensive
16:41:57 <phaazon> > (+1) *> (*3) $ 10
16:41:58 <lambdabot>  30
16:42:03 <phaazon> :)
16:42:10 <edwardk> worked it out when talking to gershom before compose in new york
16:42:23 <phaazon> > liftA2 (,) (+1) (*3) $ 10
16:42:25 <lambdabot>  (11,30)
16:42:27 <edwardk> it only works for the equivalence class machinery, and its got a pretty large constant factor cost
16:42:47 <edwardk> it also needs a sort of rats nest of IVars, etc. to make it go
16:42:56 <jle`> liftA2 f a b = liftA2 f (arr a) (arr b)
16:43:08 <jmcarthur> oh. maybe i was naive in my thinking i could see how it works
16:43:13 <phaazon> hm
16:43:19 <phaazon> actually, it doesn’t really work
16:43:24 <edwardk> because your productivity comes as sort of 'spooky action at a distance' from demanding more of the input
16:43:48 <phaazon> because *> ignores the left value, I guess I don’t get inhibition
16:43:53 <phaazon> so my program never stops
16:43:56 <phaazon> pretty weird
16:44:07 <phaazon> that’s weird
16:44:11 <phaazon> > Nothing *> Just 3
16:44:13 <lambdabot>  Nothing
16:44:18 <phaazon> yeah, it should inhibit
16:44:20 <jmcarthur> i think i don't see what the ivars are for. maybe you are just talking about nats and such? for simple products and sums i don't see the need, at least.
16:44:59 <edwardk> consider the radix sort case
16:45:04 <sinelaw> funny thing is I'm actually in need of equivalence classes, for keeping track of type variables derived from instances of a generalized variable,  where I need to unify all of them if the checker decides that the variable couldn't have been generalized in the first place (e.g. it's actually mutable)
16:45:29 <edwardk> you need to produce an array of []'s and consume the elements of the final array productively, but you need to 'put things on the tail of the list', not replace the list each time
16:45:52 <jle`> phaazon: it does inhibit, it's in the Applicative instance of Wire
16:46:22 <edwardk> when you first find, say, (1, x)   you need to lay down the entry that 1 maps to x : ... 
16:46:28 <edwardk> the usual approach is to build the list in reverse
16:46:31 <edwardk> but that doesn't work here
16:46:33 <edwardk> not for productivity
16:46:40 <edwardk> i need a result list that is already determined
16:46:52 <edwardk> but where the fate of its -tail- isn't yet known
16:46:55 <phaazon> jle`: I posted a link a few hours ago
16:47:02 <phaazon> in which I wrote my own implementation of netwire
16:47:02 <ahf> 30
16:47:05 <phaazon> and yeah
16:47:08 <edwardk> and then demanding the next step in the tail has to force the ivar we're going to supply later
16:47:12 <phaazon> the Applicative instance used inhibition
16:47:16 <phaazon> it’s mandatory
16:47:41 <jmcarthur> edwardk: i can think of two ways it may be possible to do it not involving ivars. one is with a sad branching pattern of lazy list partitioning. the other is n allison queues, though i haven't worked out the details in my head of how that would work.
16:47:41 <edwardk> otherwise the usual henglein style of building the array of lists in reverse and then turning them around fails to capture the right productivity
16:47:44 <jle`> :)
16:48:08 <phaazon> jle`: http://lpaste.net/8932109723029733376
16:48:21 <phaazon> though I expressed inhibition with Nothing
16:48:23 <edwardk> the trick is you can't put in queues there, because the usual queue tricks will change out the 'head' of the structure. i need it to stay stable for producitivity reasons
16:48:31 <phaazon> since I only use () has inhibition type
16:48:39 <jmcarthur> edwardk: well, allison queues avoid that problem
16:48:45 <jle`> yeah i don't know anyone who uses anything else
16:48:52 <phaazon> (even though I have ideas in which a smarter inhibition type would be useful)
16:49:03 <jle`> like what?
16:49:08 <jle`> i guess it could be [String]
16:49:12 <jle`> oh i've used [String] for debugging
16:49:24 <phaazon> or a newtype other Int
16:49:31 <phaazon> for “counting inhibition time”
16:49:34 <jle`> ah, that's interesting :)
16:49:36 <jle`> well
16:49:43 <jle`> it would actually count more than that
16:49:44 <edwardk> jmcarthur: i don't think i can get the right asymptotics in the allison queue formalism. each one of those would be independent
16:49:46 <phaazon> newtype Succ = Succ Int
16:49:52 <edwardk> but would have to consume the entire input
16:50:01 <edwardk> the continuation chain is the wrong fix here
16:50:07 <phaazon> instance Monoid Succ where { mempty = 0; mappend = succ }
16:50:18 <phaazon> hm
16:50:20 <edwardk> i want to spend n steps, not n * active bucket count steps
16:50:21 <jle`> you'd be counting something like parallel time too
16:50:22 <phaazon> no
16:50:27 <phaazon> jle`: yeah
16:50:31 <jmcarthur> i haven't quite thought of how it could be made to work
16:50:42 <jle`> inhibit 1 *> inhibit 1 *> blah
16:50:59 <jle`> will increment twice per step
16:51:11 <jmcarthur> oh i see, it would need to take them all as input and produce them all as output for each step
16:51:38 <jmcarthur> there is no way to just enqueue into one without touching the others
16:51:51 <jle`> oh wait no, that's wrong
16:52:04 <jle`> inhibit 1 <|> inhibit 1, will increment twice per step
16:52:13 <edwardk> exactly
16:52:13 <jle`> the Monoid constraint comes from the Alternative instance
16:52:26 <edwardk> hence the ivar machinery letting you split up the 'demand'
16:52:54 <edwardk> its still an evil mutable algorithm behind the scenes, but its one we can run 'slow' like my slow ST monad
16:53:31 <jmcarthur> yup
16:53:59 <jmcarthur> hmm... an ST monad for just ivars, not general references, that is always safe to run slow...
16:54:10 <jmcarthur> persistently, that is
16:54:20 --- mode: ChanServ set +o glguy_
16:54:20 --- mode: glguy_ set -bbbb *!*@wn-campus-nat-129-97-124-8.dynamic.uwaterloo.ca *!*@209-112-40-2.dedicated.allstream.net *!*@wn-campus-nat-129-97-124-145.dynamic.uwaterloo.ca *!*@wn-campus-nat-129-97-124-21.dynamic.uwaterloo.ca
16:54:20 --- mode: glguy_ set -o glguy_
16:55:05 <edwardk> yep
16:55:19 <edwardk> kinda useful in its own right
16:55:39 <ttt_fff> how does runghc and runhaskell differ ?
16:55:44 <jmcarthur> maybe evaluation could even be driven by evaluation of ivars
16:56:04 <edwardk> that is pretty much the idea
16:56:07 <edwardk> it has to be
16:56:10 <edwardk> for productiivty
16:56:17 <xnull_> How do you use typeclasses with a data declaration? I have an example I'd like to make work:
16:56:18 <jle`> ttt_fff: technically runhaskell should work for all haskell implementations
16:56:25 <jle`> or at least more than just ghc
16:56:39 <jmcarthur> well, the old idea being used for deamortization didn't use that exactly, so i'm just thinking of it all over again
16:56:43 <ttt_fff> jle`: okay
16:56:49 <xnull_> data Ord a => MyData a = One a | Two a a
16:56:57 <edwardk> sure
16:57:15 <jle`> xnull_: what do you expect that to do?
16:57:22 <xnull_> jle`: same thing as
16:57:29 <xnull_> data MyData a = One a | Two a a
16:57:34 <jle`> this is often a solution-for-wrong-problem kinda thingy
16:57:47 <xnull_> but with the constraint that a is of typeclass Ord
16:57:52 <xnull_> jle`: i can understand that.
16:57:56 <jle`> what would that constraint look like in practice?
16:57:58 <xnull_> i'll look about another way of doing it
16:58:08 <xnull_> jle`: Int or Integer
16:58:11 <jle`> like when you actually use MyData, i mean
16:58:12 <xnull_> or Float
16:58:14 <xnull_> or Char
16:58:20 <xnull_> etc
16:58:23 <jle`> would it be constrained when your constructors are used?
16:58:24 <edwardk> jmcarthur: if you want to take a whack at it, i'd happily add you to the repo
16:58:26 <jle`> or when pattern matching?
16:58:39 <jle`> it's a bit of conceptual can of worms
16:58:44 <xnull_> oh i see
16:58:55 <edwardk> jmcarthur: its pretty far down my todo list right now. mainly a bauble i take out and play with in my spare time on the T
16:58:59 <jle`> it actually is implemented in GHC but the implications and possible usages are usually not what anyone intends
16:59:06 <jle`> by implemented i mean depreciatd, heh
16:59:15 <xnull_> deprecated*
16:59:18 <jle`> thanks :)
16:59:29 <edwardk> its kind of like my speculation library. i love it, its so useful when i get a chance to use it, but nobody cares about it
16:59:40 <xnull_> jle`: so say if i want
16:59:41 <jle`> actaully i think it is both deprecated and depreciated
16:59:53 <xnull_> data Integral a => MyData a = One a | Two a a
17:00:07 <jmcarthur> edwardk: it's also not very high on my list or else i'd be working on it already :)
17:00:11 <jle`> xnull_: usually the preferred solution is to have the constraint on whatever functions use your type
17:00:12 <edwardk> jmcarthur: heh
17:00:21 <xnull_> oh, alrighty then
17:00:25 <xnull_> makes sense
17:00:26 <jle`> similar to, for example, all of the functions in Data.Set requiring an Ord constraint
17:00:31 <xnull_> aha
17:00:37 <jmcarthur> edwardk: i like speculation. it's like async for pure functions!
17:00:45 <edwardk> i tend to randomly force elements on my todo list every once in a while to keep the biggest ticket items from starving everything else
17:00:46 <jmcarthur> well
17:00:48 <jmcarthur> that's just par
17:00:50 <xnull_> i see the implications of this
17:00:50 <jle`> technically you can only put an Ord in a Set, but instead of restricting it at the type level, it restricts it by only letting you use Set with functions that are constrained on Ord
17:01:13 <jmcarthur> ignore my idiotic statement about speculation
17:01:43 <edwardk> yeah spec is a bit ballsier, it has the temerity to guess what the result of a function will be and try to start off with that answer before it has achieved confimation
17:02:01 <jmcarthur> right
17:02:05 <edwardk> then relies on GHC's ability to throw away dead sparks and all attendant computation
17:03:37 <c_wraith> don't use spec when you expect to be using all your available cores for throughput anyway!
17:05:12 <jmcarthur> edwardk: i know all about speculation. :)
17:05:57 <edwardk> jmcarthur: you missed the fact that i turned about 45 degrees towards the audience before I began that soliloquy ;)
17:06:07 <jmcarthur> haha
17:06:33 <jmcarthur> i often forget there is an audience of about 1500 people here
17:07:13 <edwardk> "man this speculation package at http://hackage.haskell.org/package/speculation is awesome. it has great documentation, and uses all sorts of nice properties of sparks and advanced GHC features. I know you helped me write some of it but..."
17:07:46 <jmcarthur> time for dinner
17:07:57 <edwardk> i also spent about half an hour doing maintenance on it last night, getting it to where it builds warning-free on 7.10, so it was on the top of my head
17:08:24 <edwardk> later man
17:08:34 <edwardk> lemme know if you want access to the discrimination repo
17:09:17 <sinelaw> edwardk, btw, do you happen to have a nice solution for carrying over substitution maps during type inference? I keep needing to shove them in/out reader/writers
17:09:40 <sinelaw> to the point I just put a big one in a State and do it imperatively
17:09:52 <edwardk> my usual approach is to build them up during recursion as an explicit function when working with bound.
17:10:22 <edwardk> foo :: (a -> Maybe Whatever) -> Exp a -> whatever monad i want to work
17:10:41 <edwardk> then when i do polymorphic recursion to instantiate a scope i can extend 'a' contravariantly
17:11:18 <edwardk> this makes me think about names when and only when something new should come into scope
17:11:23 <edwardk> and the types force me to do the right thing
17:11:27 <edwardk> i can't forget
17:11:44 <edwardk> if you had an indexed state monad you could thread that through as a piece of indexed state
17:11:47 <sinelaw> but the code gets littered with applying substitutions on intermediate types
17:12:21 <sinelaw> oh you index them by the substitution?
17:12:31 <sinelaw> on the type level?
17:13:30 <edwardk> bound uses polymorphic recursion so that when i go into a scope i change the type of my free variables to extend it with more stuff
17:14:26 <edwardk> (then when i recurse into the 'F' case i can even throw away that extension, but that is a more advanced trick)
17:14:50 <edwardk> so the type of my environment changes as i recurse
17:15:24 <edwardk> say you have something like data Exp a = Var a | App (Exp a) (Exp a) | Lam (Scope () Exp a)
17:15:31 <sinelaw> ok
17:15:54 <edwardk> and you're working with an environment of some sort, (a -> Maybe String) which contains the names we've assigned or swap string for types, or whatever.
17:16:32 <edwardk> now when you walk into the Lam case we can fromScope :: Scope () Exp a -> Exp (Either () a) --  this is the simplest way, not the best, just for exposition...
17:16:49 <edwardk> now to recurse i need to extend my environment so its not (a -> Maybe String) but Either () a -> Maybe String)
17:17:06 <edwardk> when i've done that i recurse into the body polymorphically using that new environment rather than my old one
17:18:20 <pyon-tinuation> edwardk: Do you have any resouces on how to use bound to implement anything other than pure typed lambda calculi?
17:18:26 <edwardk> alternately you can open the Scope () Exp a yourself and get out Exp (Var () (Exp a)) -- and recurse through the outer expression, with a way to handle the () you get from the B case of Var, and when you find F, go back to the old environment
17:18:58 <edwardk> pyon-tinuation: most of the examples folks have built up are on pure type system style type systems.
17:19:13 <edwardk> someone had a fancy example that used bound a bit sideways to implement a system of statements and expressions
17:19:20 <edwardk> but i don't remember who it was off the top of my head
17:19:28 <pyon-tinuation> Awww. :-(
17:19:44 <edwardk> i asked if he'd send it to me as an example for the repo, but then forgot about it
17:20:34 <sinelaw> i'm actually doing "both"
17:20:40 <sinelaw> not using bound (yet)
17:21:07 <sinelaw> I translate the imperative into a lambda calculus augmented with reference cells
17:21:14 <pyon-tinuation> For typed lambda calculi without effects other than nontermination, bound is a real joy to use.
17:21:21 <edwardk> sinelaw: anyways that need to do polymorphic recursion to work with your environment is the thing that causes some folks consternation around bound. i personally think it requires just the right amount of thought about the nature of your environments, but it requires a very non-traditional way to build up your semantics, etc.
17:22:23 <sinelaw> edwardk, thanks i'll take another shot at bound, or maybe adopt a similar approach without bound
17:22:55 <sinelaw> unfortunately another complication I have is that immutable variables are sometimes discovered later in the AST to have actually been mutable
17:23:36 <edwardk> pyon-tinuation: we're rather enjoying working with bound in the ermine code base
17:24:31 <edwardk> sinelaw: http://comonad.com/reader/2014/fast-circular-substitution/ is another article i wrote up on a slightly different name management technique that also gives a nice substitution monad
17:24:50 <edwardk> also https://www.fpcomplete.com/user/edwardk/phoas
17:25:02 <edwardk> there are lots of ways to play with names
17:25:44 <edwardk> i like bound for compiler work, i like the fast substitution approach for deep embedded dsl's, and the phoas trick is nice for very shallow EDSls you want to write quickly
17:26:29 <edwardk> if hask was a little easier to use a polykinded form of Bound would be awesome for handling different variable sorts
17:26:52 <edwardk> basically Bound as a McBride style 1 parameter indexed monad works well
17:27:21 <sinelaw> edwardk, thanks for the links
17:27:31 <sinelaw> edwardk, my main issue is with mutability
17:27:59 <sinelaw> I mean, in addition to all the usual issues addressed by Bound and the like
17:28:21 <edwardk> mutability is regarding your environment, right? you have an environment that holds (typed?) variables and you want typed updates to them?
17:28:25 <edwardk> or are they untyped?
17:28:42 <sinelaw> they are typed
17:28:56 <sinelaw> but I also want polymorphism
17:28:59 <edwardk> and all the handling in haskell you'd prefer to be typed as well?
17:29:27 <edwardk> there my recommendation would be the 'typed bound' i described above, where you can do type preserving substitution
17:29:42 <sinelaw> sure, if I understand what you mean 
17:30:03 <tomberek> does anyone know if there is a function that takes a haskell-src-exts Exp of some source and can lift it up to an Exp of that source expressed in TemplateHaskell ExpE? so something like:  Exts.Var  (UnQual (Ident "aFunc")) becomes Exts.App (Var $ Qual (ModuleName "Language.Haskell.TH") (Ident "VarE")) (Var $ UnQual (Ident "aFunc"))   the idea is that one can write "myFunc (\a -> (a,a))" into "myFunc'' [| (\a->(a,a) |] (\a->(a,a) " 
17:30:26 <sinelaw> edwardk, the variables of the language are mutable, but I want to allow polymorphism if they are only ever assigned once (practically immutable)
17:30:38 <edwardk> sinelaw: 'ew'
17:30:46 <sinelaw> edwardk, JavaScript
17:30:59 <sinelaw> so yeah.
17:31:34 <edwardk> sounds like a lot of pain =)
17:31:45 <sinelaw> polymorphism for actually mutable variables is hard - I've decided to go the SML way and apply restrictions on polymorphism based on some basic syntax rules
17:32:07 <edwardk> value restriction style?
17:32:08 <Welkin> sinelaw: try Immutable.js
17:32:12 <sinelaw> edwardk, yes
17:32:19 <Welkin> it adds immutability and lazy evaluation
17:32:46 <oneb> When I do "cabal update", after the message about downloading it says "Killed". It also just says "Killed" if I do "cabal configure" in a project directory I copied over from another machine where cabal works fine. Known problem? What do?
17:32:49 * phaazon ’s head starting overheating
17:32:52 <phaazon>     loop f b = let (c,d) = f (b,d) in c
17:33:09 <phaazon> that d
17:33:15 <phaazon> is
17:33:17 <phaazon> killing me 
17:33:18 <phaazon> :D
17:33:20 <sinelaw> edwardk, so, relevant to our previous discussion, i keep track of what each polymorphically generalized variable was ever instantiated to, and then if it's found to be mutable, I unify all those instances to force it down to the same type
17:33:24 <ion> oneb: See if you ran out of memory.
17:33:34 <edwardk> fix f = let a = f a in a
17:33:42 <phaazon> yeah
17:33:46 <phaazon> that one is also killing me.
17:33:47 <phaazon> :D
17:33:55 <edwardk> phaazon: the key here is understanding the way a thunk works
17:34:09 <phaazon> hm
17:34:20 <sinelaw> Welkin, that's cool, but the type checker should be able to handle basic JS stuff 
17:35:07 <ab9rf> how would the typechecker do basic JS stuff?
17:35:40 <edwardk> phaazon: you build a thing in memory that when it gets evaluated points to its final answer, eventually replacing itself with it when the GC has gone by. So what happens we make a thunk that will evaluate to 'f' applied to the reference to itself when you force it, then we give it back. when you enter it, it passes the reference to itself to 'f', if 'f'
17:35:40 <edwardk> demands the answer from its argument while we're evaluating the argument, we spot that we're in a _|_ and give back the <<loop>> error
17:36:11 <oneb> ion: that's a realistic option because this is a VPS with 128mb of memory. But it doesn't look like that's happening when watching it live in "top".
17:36:14 <sinelaw> ab9rf, what part of JS do you mean
17:36:17 <edwardk> if not, when we're done we have a value, so we write the forwarding pointer into ourself pointing to our answer.. out answer may reference us back
17:36:25 <edwardk> er our answer may reference us back
17:36:25 <ab9rf> sinelaw: i don't know, it wasn't my idea
17:36:26 <ion> oneb: Anything in dmesg?
17:36:36 <edwardk> when gc comes along it tightens that forwarding pointer away
17:36:41 <edwardk> so lets consider
17:36:47 <edwardk> let ones = 1 : ones in ones 
17:37:04 <phaazon> yeah, I understand that
17:37:15 <phaazon> we have ones
17:37:23 <phaazon> if we need to evaluate it once
17:37:27 <phaazon> we get 1 : ones
17:37:36 <phaazon> deeper and we get 1 : 1 : ones
17:37:43 <oneb> ion: ah right, in dmesg it says that it was killed due to being out of memory
17:37:44 <phaazon> but in the case of arrow loop
17:37:56 <edwardk> ones is a thunk that when evaluated calls (1 :) with a reference to itself, which doesn't force itself, so it terminates, and gives back 1 consed onto the original list without being _|_, now gc tightens the loop and you get a node in memory 'ones" which points to a cons cell which points to 1 on one side and itself on the other.
17:37:57 <oneb> guess I'll make a swap space..?
17:38:03 <phaazon> loop f b = let (c,d) = f (b,d) in c
17:38:09 <sinelaw> ab9rf, basically, translate your JS into a lambda calculus with some fancy stuff (such as mutable assignment), then do type inference on that using a type system that includes enough features to approximately represent JS 
17:38:19 <phaazon> that, huh
17:38:28 <phaazon> my brain is like bufferoverflowing ahah
17:38:51 <phaazon> hm
17:38:52 <phaazon> I guess
17:38:57 <phaazon> let (c,d) = f (b,d)
17:39:03 <phaazon> we have a function application
17:39:07 <enthropy> tomberek: thisFunction x = Exts.App (Var $ Qual (ModuleName "Language.Haskell.TH.Syntax") (Ident "lift")) x -- maybe?
17:39:16 <phaazon> if we need to evaluate f (b,d)
17:39:20 <phaazon> then we need to evaluate d
17:39:28 <phaazon> so we need to evaluate another f (b,d)
17:39:28 <edwardk> we build c and d to be computations that when forced look at the result of 'f' and get out fst and snd respectively
17:39:44 <phaazon> that’s the weird point
17:39:48 <phaazon> how is d build?!
17:39:51 <edwardk> then we pass the second such thunk to (b,d)
17:39:54 <phaazon> built*
17:40:10 <tomberek> enthropy: i'm not sure,,, one sec, let me look at that "lift"
17:40:19 <enthropy> lift :: Lift t => t -> Q Exp
17:41:23 <tomberek> enthropy: so Lift is not defined for types (a->b) which is the problem I'm trying to work around to begin with
17:41:46 <edwardk> make placeholders all that the same time lets call them cd, bd, c and d such that bd is a thunk that replaces itself with (b,d)  when forced, cd when forced becomes 'f bd', c when forced becomes fst cd,  and d when forced becomes snd cd.
17:41:52 <edwardk> make all 4 of those thunks at the same time
17:41:55 <edwardk> then give back 'c'
17:41:57 <sinelaw> what I'm trying to do with JS hasn't been done as far as I know, either because it's just hard, or more probably, it's not a good idea 
17:42:11 <edwardk> when you demand c it demands the pair cd, which demands f bd
17:42:18 <phaazon> edwardk: yeah
17:42:26 <phaazon> but I don’t see how we can get things out of that
17:42:26 <edwardk> which may or may not demand things of bd
17:42:36 <phaazon> it looks like a nasty _|_ to me
17:42:44 <edwardk> it is potentially a nasty bottom
17:42:56 <edwardk> but only if the function 'f' makes 'd' evaluate itself
17:43:11 <edwardk> if f just passes 'd' around in the right places in the input it can stay unforced
17:43:19 <phaazon> huhu
17:43:31 <edwardk> you can pass around references to 'd' without seq'ing it
17:43:32 <phaazon> what’s the point having a value around, and never evaluate it?
17:43:40 <edwardk> > let ones = 1 : ones in ones
17:43:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:43:51 <edwardk> 1 : ones doesn't evaluate 'ones'
17:44:06 <ab9rf> phaazon: what's the HARM in having a value that you never evaluate?
17:44:08 <edwardk> but whatever consumes it can look at the whole knotted-up result just fine
17:44:11 <tomberek> enthropy: i'm trying to cheat TH and basically get the same function as an instance Lift (a->b) which is impossible in TH, but seems (to me) easy at the source-level.... This looks simple: func (\(a,b)->(b,a))  ===>   func' [| (\(a,b)->(b,a) |] (\a,b)->(b,a))  though doing that directly is an error because [| |] brackets cannot Lift anything of type (x-->y)
17:44:14 <edwardk> > let ones = 1 : ones in take 20 ones
17:44:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
17:44:21 <phaazon> ab9rf: no HARM, but no point either
17:44:30 <phaazon> edwardk: yeah but you still evaluate it
17:44:33 <phaazon> in some kind of way
17:44:44 <edwardk> es, but the key is its happening 'outside'
17:44:52 <phaazon> I see
17:44:58 <sinelaw> phaazon, you can think of an unevaluated thunk as a pointer
17:45:07 <sinelaw> in ones = 1 : ones
17:45:10 <phaazon> yeah yeah
17:45:13 <phaazon> I know fix
17:45:13 <pyon-tinuation> phaazon: If you read Chris Okasaki's book on purely functional data structures, you'll see that it can be quite useful to stage computations for later execution, and carefully control the timing of that execution.
17:45:16 <phaazon> I’m comfy with it
17:45:18 <sinelaw> 'ones' is a pointer you never need to dereference
17:45:20 <phaazon> I don’t know loop
17:45:21 <edwardk> we run into <loop> problems only when forcing a thunk forces something to also force that same thunk
17:45:26 <phaazon> it’s black magic to me
17:45:34 <edwardk> he trick is avoiding that situation
17:46:03 <sinelaw> phaazon, if while evaluating the thunk you need the same thunk, what can you do?
17:46:04 <ion> > let loop f b = let (c,d) = f (b,d) in c in loop (\(b,ones) -> (b:ones, 1:ones)) 42
17:46:04 <edwardk> then laziness can use the limited form of mutation that is thunk evaluation to do neat head-hurting things
17:46:05 <lambdabot>  [42,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:46:14 <edwardk> lets consider the alternative. where you don't have laziness
17:46:37 <edwardk> to make a circular list like that you'd need to make a node which starts with a null pointer for its tail or something
17:47:03 <edwardk> then when you know where its going in memory you'd "set!" or write to that pointer to tie the knot, to make the infinite list
17:47:12 <edwardk> that is how strict languages tie the knot
17:47:58 <edwardk> laziness gives us a limited form of mutation that is good enough to permit knot tying, but not the bad abuses, it lets you still reason while still giving you the ability to do letrec, fix, etc.
17:49:24 <phaazon> I really can’t wrap my mind around that loop
17:49:32 <edwardk> when you go to the other extreme of strictness you find that letrec does weird weird things at times. this is why you can find #f's strewn through out the code you wrote in scheme when you use letrec, because it had to make a place in memory, and initialize it to #f and fill it in in the end with the real answer.
17:50:07 <tomberek> enthropy: another way of doing it would be to build those brackets in src-exts, but toExp is not defined for the brackets
17:50:10 <edwardk> in haskell it'd fill it in with a thunk that references the final answer and the bad ircular cases where you can see #f peeking through in the strict setting become _|_'s
17:50:20 <phaazon> edwardk: do you have a simple example of loop?
17:50:30 <edwardk> > let x = 1 + x in x
17:50:33 <lambdabot>  mueval-core: Time limit exceeded
17:50:40 <phaazon> that’s a fix
17:50:48 <edwardk> oh of the loop call
17:50:52 <edwardk> see ion's example above
17:50:53 <phaazon> yes
17:52:29 <phaazon> that’s the kind of stuff I think I’ll never truly understand
17:52:39 <phaazon> well
17:52:44 <phaazon> I do understand it
17:52:45 <phaazon> the example
17:52:56 <phaazon> I don’t understand what it is for
17:53:01 <phaazon> I use fix to show off
17:53:03 <phaazon> nothing else.
17:53:04 <edwardk> phaazon: we can build silly little examples
17:53:04 <phaazon> like
17:53:16 <edwardk> > let loop f b = let (c,d) = f (b,d) in c in loop (\(bs,es) -> (2:es, 1:bs)) 42
17:53:17 <lambdabot>  [2,1,42]
17:53:32 <phaazon> « ohoh I can build an infinite list of dumb values, look! fix ("hihi"++) »
17:53:33 <edwardk> notice the interchange between the two sides
17:53:46 <edwardk> and notice the finite result
17:54:29 <phaazon> that’s
17:54:30 <phaazon> …
17:54:43 <edwardk> its something worth walking through step by step
17:54:45 <phaazon> I think I just have to go to bed.
17:54:53 <edwardk> or that
17:55:00 <phaazon> I won’t understand tonight
17:55:02 <phaazon> I’m pretty sure
17:55:25 <phaazon> I don’t even understand why it’s stopped
17:55:58 <gratimax> it's because haskell is very lazy
17:56:05 <enthropy> tomberek: you're doing   instance Lift (a -> b) where lift f = either error return $ Language.Haskell.Meta.Parse.Careful.parseExp (magicallyGetTheSourceOf f :: String)
17:56:08 <ion> Evaluating “loop”, that will become let (c,d) = (\(bs,es) -> (2:es, 1:bs)) (42,d) in c
17:56:30 <ion> uh
17:56:44 <phaazon> so hm
17:56:54 <phaazon> it replaces the d with 1:bs
17:57:06 <phaazon> but…
17:57:11 <phaazon> bs should be 42
17:57:15 <edwardk> and bs = 42
17:57:16 <edwardk> yeah
17:57:17 <phaazon> how 1:42 could even compile
17:57:17 <tomberek> enthropy:  i think that might be it..... I get the source by using a quasiquoter
17:57:18 <phaazon> wtf
17:57:25 <phaazon> seriously
17:57:26 <phaazon> bed.
17:57:38 <ion> > 1:42  -- Uh, lambdabot?
17:57:39 <lambdabot>  [1,42]
17:57:46 <phaazon> ok
17:57:48 <edwardk> > let loop f b = let (c,d) = f (b,d) in c in loop (\(bs,es) -> (2:es, 1:bs)) [42]
17:57:49 <phaazon> I quit 
17:57:50 <lambdabot>  [2,1,42]
17:57:51 <phaazon> :D
17:58:01 <enthropy> > 42 :: [Int]
17:58:02 <lambdabot>  [42]
17:58:03 <edwardk> that should be better
17:58:16 <edwardk> so d = 1:[42]
17:58:33 <phaazon> is there a Num instance for (Num a) => Num [a]?
17:58:36 <ion> Evaluating loop: let (c,d) = (\(bs,es) -> (2:es, 1:bs)) ([42],d) in c
17:58:40 <edwardk> on lambdabot
17:58:49 <phaazon> ok
17:58:50 <phaazon> so
17:58:59 <enthropy> :t (flip, (.))
17:59:00 <ion> Evaluating the lambda: let (c,d) = (2:d, 1:[42]) in c
17:59:00 <lambdabot> ((a -> b -> c) -> b -> a -> c, (b1 -> c1) -> (a1 -> b1) -> a1 -> c1)
17:59:52 <phaazon> ion: so d == 1:[42]
17:59:57 <ion> > let c = 2:d; d = 1:[42] in c
17:59:59 <lambdabot>  [2,1,42]
18:00:33 <phaazon> yeah
18:00:42 <phaazon> I really wonder now who _really_ uses loop
18:00:44 <phaazon> and what for
18:00:49 <ion> Where did you get loop?
18:00:54 <phaazon> Arrow
18:00:57 <phaazon> ArrowLoop
18:01:10 <edwardk> > let loop f b = let (c,d) = f (b,d) in c in loop Data.Tuple.swap 1
18:01:11 <lambdabot>  1
18:01:26 <edwardk> loop pops up in the same kind of situations as mfix
18:01:28 <tomberek> phaazon: i've been using and looking at ArrowLoop recently
18:01:41 <edwardk> you may want to look up 'causal commutative arrows' as well
18:01:42 <ion> Ah, ArrowLoop. Self-recursive arrow syntax desugaring.
18:01:46 <edwardk> they make heavy use of this sort of formalism
18:01:49 <phaazon> edwardk: don’t tell me about mfix
18:01:55 <phaazon> never understood that neither
18:02:27 <phaazon> that’s a part of Haskell that I feel is a danger
18:02:33 <phaazon> I feel super excited about something
18:02:42 <phaazon> and almost feel desperate being so “dumb”
18:02:43 <phaazon> :(
18:02:43 <tomberek> edwardk: that's what i've been trying to improve on
18:02:52 <edwardk> phaazon: https://www.youtube.com/watch?v=F7F-BzOB670 <- is a wonderful talk by kenny here at boston haskell on a fancy 'comonad' fix that is useful for doing spreadsheet-like operations
18:03:43 <tomberek> edwardk: hence my question about cheating TH to lift an (a->b) into TH, thus automating the arr' function they use in CCA
18:04:05 <edwardk> phaazon: anyways you may or may not enjoy kenny's talk, but its a great way to explore what comonadic fixed points are useful for
18:04:25 <phaazon> edwardk: I discovered the real use of comonads a few days ago
18:04:41 <phaazon> I don’t even know the use of “fixing” stuff
18:04:46 <phaazon> so comonadic fixs…
18:04:48 <phaazon> fixes*
18:04:49 <edwardk> > fix error
18:04:50 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:05:33 <phaazon> all those concepts make me feel like a little cat
18:05:39 <phaazon> escaping dogs
18:05:43 <phaazon> with big teeth
18:05:58 <edwardk> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html <- is an article from 2006 or so on loeb's theorem. kenny's talk is on a fancier comonadic fixed point than dan's with more efficient evaluation
18:06:09 <phaazon> or like a child being beated up with tree logs.
18:06:47 <edwardk> @let loeb x = r where fmap (\a -> a r) x
18:06:47 <lambdabot>  Parse failed: Parse error: EOF
18:06:53 <phaazon> and that also makes me thing I shouldn’t write articles about “haskellish” stuff
18:07:10 <phaazon> because they’re so much people out there knowing that kind of stuff I hardly even understand the use…
18:07:23 <edwardk> @let loeb x = let r = fmap (\a -> a r) x in r
18:07:24 <lambdabot>  .L.hs:210:1: Warning:
18:07:24 <lambdabot>      Pattern match(es) are overlapped
18:07:24 <lambdabot>      In an equation for ‘loeb’: loeb x = ...
18:07:29 <edwardk> :t loeb
18:07:30 <lambdabot> Functor f => f (f b -> b) -> f b
18:07:40 <edwardk> @undefine
18:07:40 <lambdabot> Undefined.
18:07:42 <edwardk> @let loeb x = let r = fmap (\a -> a r) x in r
18:07:43 <lambdabot>  Defined.
18:07:45 <edwardk> :t loeb
18:07:46 <lambdabot> Functor f => f (f b -> b) -> f b
18:07:48 <phaazon> > loeb [length,length]
18:07:48 <edwardk> there we go
18:07:49 <lambdabot>  [2,2]
18:07:54 <phaazon> I know that one
18:08:36 <edwardk> > loeb [length,\xs -> (xs!!0) + 1]
18:08:38 <lambdabot>  [2,3]
18:09:05 <phaazon> I have to work tomorrow, in a few hours actually…
18:09:14 <edwardk> heh, go sleep
18:09:16 <phaazon> thank you for your help
18:09:32 <phaazon> I’ll keep on writing dumb code though
18:09:38 <phaazon> because I truely can’t understand that
18:11:32 <tomberek> enthropy: we seem to be rediscovering the syntax-trees package (only syntax-trees-fork-bairyn seems to compile right now though)
18:11:33 <jberg_> http://lpaste.net/124246 hi, this program generates this image: http://johan.no/fractal.ppm, does anyone understand why the image is not showing a complete fractal?
18:11:52 <edwardk> don't worry about it, its typically only after several exposures to this stuff that you finally get it
18:13:23 * hackagebot yi-rope 0.7.0.1 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.7.0.1 (MateuszKowalczyk)
18:14:20 <jberg_> is there a haskell dev framework for android?
18:15:44 <edwardk> jberg_: https://www.fpcomplete.com/user/edwardk/snippets/mandelbrot <- is an adam7 interlaced png mandelbrot generator i wrote to teach some stuff a while back, but i don't have a ppm viewer handy to see your problem
18:15:58 <kaidelong> https://wiki.haskell.org/Android
18:16:20 <kaidelong> the answer last I knew was "only secret and propietary or experimental ones"
18:16:30 <kaidelong> but by the looks of this the situation has improved a little
18:16:44 <kaidelong> note that the GHC cross compiler might be needed for this, which means no template haskell
18:18:10 <jberg_> kaidelong: okay cool. people use template haskell?
18:18:16 <jberg_> edwardk: okay ill look
18:18:30 <kaidelong> template haskell is used a lot
18:18:51 <kaidelong> so you may have to pass up on some good libraries
18:19:14 <kaidelong> i think there is work being done to make template haskell work when cross compiling
18:19:22 <kaidelong> so the situation might improve with time
18:22:46 <jberg_> kaidelong: can you give me some examples on projects that use template Haskell
18:22:48 <jberg_> ?
18:23:03 <nshepperd> the way template haskell works now seems very strange to me
18:23:16 <edwardk> jberg_: lens for one.
18:23:37 <nshepperd> I'd expect ghc to use an interpreter, but the template code gets compiled and linked in
18:23:46 <edwardk> that said, lens doesn't actually use the TemplateHaskell extension itself
18:23:59 <edwardk> so it can build on stage1 platforms
18:24:08 <nshepperd> which I assume is why it doesn't work to crosscompile
18:24:39 <jberg_> is lens introspection stuff? looking at types and stuff in runtime?
18:25:00 <edwardk> lens is a swiss army knife for carving up haskell data
18:25:26 <jberg_> so who uses lens? ghc?
18:25:28 <edwardk> it has some template haskell for generating ways to view individual fields in record types
18:25:49 <edwardk> a few hundred different packages these days: http://packdeps.haskellers.com/reverse/lens
18:25:53 <Welkin> jberg_: yesod uses template haskell
18:26:22 <jberg_> ah ok
18:27:07 <SleepyPikachu> Can you nest case of expressions? I'm having trouble getting that to work.
18:27:16 <johnw> jberg_: lens can be like an insanely powerful swiss army knife :)
18:27:46 <Welkin> SleepyPikachu: yes
18:27:50 <Welkin> depending on what you mean
18:27:50 <ion> > case 42 of a -> case a of b -> b
18:27:51 <lambdabot>  42
18:28:00 <siddhu> for f :: Text -> (Int, Char), is there a better way than using (\x -> zip [1..] (T.unpack x)) ?
18:28:26 <edwardk> johnw: just be careful with the bazooka attachment
18:29:19 <meretrix> When I insert a new value into a large "Data.Map", isn't GHC allocating new memory for the entire Map and copying it all over?  How can it be O(log n)?
18:29:45 <edwardk> meretrix: the map itself is a bunch of immutable pointers, it can share all the parts that aren't on the path to what changed
18:30:06 <edwardk> meretrix: its only that one log time path that has to get updated (and some rotations along the way)
18:30:08 <heatsink> meretrix: The map is stored as a search tree.  It only allocates new nodes on the path from the root to the new element.
18:30:10 <meretrix> Ah ok, makes sense.
18:30:17 <edwardk> so the new and the old map share almost all of their structure
18:30:30 <edwardk> immutability is the key to making that work
18:30:31 <enthropy> nshepperd: there is an interpreter used: x = $(lift (1+1)) -- that 1+1 gets evaluated at compile time by (not exactly) ghci
18:30:38 <heatsink> I'm not sure how the complexity bound is guaranteed when rebalancing is involved 
18:31:08 <edwardk> heatsink: bounded balance ensures no one operation can require more than O(log n) steps of work
18:31:11 <SleepyPikachu> Welkin: I'm in a computation, the result of a computation I'm binding in is Maybe Value. If the result is Nothing then I want to use the result of different call to determine the continuation of the computation.
18:31:24 <johnw> edwardk: :)
18:31:33 <heatsink> Huh, okay
18:31:36 <lf94> Are there any minimal haskell implementations?
18:31:44 <edwardk> lf94: several
18:31:47 <lf94> It is fine if it is missing features
18:32:01 <meretrix> edwardk: If I have a huge ADT and "update" it by doing something like "d { x = 1 }", is it the same idea?  The 99% of the ADT that is not modified is shared?
18:32:02 <lf94> I just want to study how they work to get a better understanding of Haskell.
18:32:06 <edwardk> lf94: jhc, uhc, hugs, etc.
18:32:13 <heatsink> Oh, like in the paper about alternative number systems for persistent data structures
18:32:17 <lf94> Alright, I'll check those out, thank you!
18:33:26 <Welkin> SleepyPikachu: paste your code on lpaste
18:33:31 <Welkin> @lpaste
18:33:31 <lambdabot> Haskell pastebin: http://lpaste.net/
18:33:51 <edwardk> x { d = 1 } is doing a record update, what other fields are there in 'x'? basically you're going to make a data Foo = Foo { a,b,c,d,e :: Int, f :: Some Crazy Huge Map } -- updating that is going to make a new 'Foo' record, which is ~6 pointers wide, and change the value of the 'd' field in the process. it copies the whole thing, but it is a 'shallow' copy,
18:33:51 <edwardk> just Foo, it doesn't walk into the Some Crazy Huge Map
18:34:40 <SleepyPikachu> Also do you get an undefined if you have incomplete coverage in case of?
18:35:03 <edwardk> x { d = 1 } takes in say "Foo 1 2 3 4 5 crazy" and spits out "Foo 1 2 3 1 5 crazy"
18:35:17 <heatsink> SleepyPikachu: You get a pattern match failure exception.  It's similar to undefined but with a more useful error message.
18:35:19 <ion> sleepypikachu: Yes, and a compile-time warning (at least with -Wall).
18:35:29 <milottiv> good night everyone! (as in good evening)..
18:35:30 <edwardk> f those numbers aren't just numbers but instead big complicated thunks they remain references to the thunk that will compute their answer
18:35:32 <meretrix> edwardk: Thanks! 
18:35:34 <SleepyPikachu> heatsink: ion: thanks :-)
18:36:23 <edwardk> meretrix: you can play some pretty advanced games with this to get weird data structures with very desirable asymptotic performance
18:36:40 <edwardk> Chris Okasaki has a book on the topic, "Purely Functional Data Structures"
18:36:57 <edwardk> it is worth bouncing off that book a few times to get a feel for what he's all about
18:37:38 <milottiv> is there anyone who could check a 2005, 4 lines of obfuscated code that won't compile ? I am trying to benchmark against a C variant. Those 4 lines suggest a wide opening on a new language to me .. please PM me if someone is up for the quick fix :D :D :D 
18:38:20 <heatsink> Why would you want to benchmark obfuscated code?
18:38:43 <kaidelong> does ghci have something akin to lambdabot's instances?
18:38:53 <kadoban> milottiv: It's in…what language? C? A C variant? Why not just ask here instead of requiring PM?
18:39:24 <kadoban> kaidelong: Which instances?
18:39:25 <milottiv> in haskell
18:39:44 <kadoban> Obfuscated haskell? Can't say I've seen that intentionally done.
18:39:53 <ion> “@pl”
18:40:03 <Rotaerk> don't worry, haskell's already pretty obfuscated to most people
18:40:26 <SleepyPikachu> hastec does a pretty good job
18:40:47 <milottiv> pi = g(1,0,1,1,3,3) where 
18:40:47 <milottiv> g(q,r,t,k,n,l) = if 4*q+r-t<n*t 
18:40:47 <milottiv> then n : g(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n,l) 
18:40:47 <milottiv> else g(q*k,(2*q+r)*l,t*l,k+1,div(q*(7*k+2)+r*l)(t*l),l+2)
18:41:15 <milottiv> this generates as many pi decimal as memory allows
18:41:16 <FireFly> Looks golfed
18:41:33 <milottiv> lol @Rotaerk
18:41:38 <xnull_> oboy
18:41:40 <glguy> No
18:41:51 <xnull_> what jank-ass language is that, milottiv 
18:42:18 <xnull_> if it's Haskell then what is
18:42:26 <xnull_> g(q,r,t,k,n,l)
18:42:30 <siddhu> It is Haskell, since the language allows it
18:42:33 <xnull_> is that g with a tuple as argument
18:42:35 <ion> A tuple parameter.
18:42:47 <xnull_> oh you just ripped out all the whitespace
18:42:48 <xnull_> i see
18:42:49 <edwardk> MoALTz: oh do you want a paper on how that works?
18:43:02 <milottiv> lol. Can't tell. Can tell you about the C counterpart. The guy who wrote that back in 2005 is claiming it is streaming pi decimal. I want to see it on my screen
18:43:05 <xnull_> i just realized i was in #haskell
18:43:10 <Welkin> milottiv done goofed!
18:43:12 <edwardk> milottiv: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/spigot.pdf
18:43:26 <edwardk> milottiv: we also have shorter versions now
18:43:32 <edwardk> i worked on one with shachaf for a while
18:44:02 <milottiv> yeah
18:44:05 <milottiv> that paper
18:44:30 <edwardk> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
18:44:32 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
18:44:51 <edwardk> that is my shortest "fast enough to run on lambdabot" pi
18:45:11 <edwardk> > [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])!!n|n<-[0..]]
18:45:15 <lambdabot>  mueval-core: Time limit exceeded
18:45:19 <edwardk> ^- that one is technically correct, but too slow
18:45:46 <edwardk> > (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
18:45:47 <lambdabot>  "271828182845904523536028747135266249775724709369995957496696762772407663035...
18:45:51 <edwardk> ^- that one does e
18:45:55 <milottiv> I happen to have written the exact equivalent code in ANSI C edwardk
18:46:44 <kaidelong> kadoban: this thing:
18:46:48 <kaidelong> @instances-importing Enum
18:46:49 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:46:50 <milottiv> sorry . mixed lines 
18:47:02 <milottiv> pay no heed to my previous comment
18:47:10 <edwardk> anyways those are golfed as heavily as I know how at the moment. if you find anything that reduces characters lemme know =)
18:47:35 <kadoban> kaidelong: Ohh. Hmm, I dunno.
18:48:29 <edwardk> > let(q,r,t,k,n)%l|4*q+r-t<n*t=n:(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n)%l|z<-t*l=(q*k,(2*q+r)*l,z,k+1,div(q*(7*k+2)+r*l)z)%(l+2)in(1,0,1,1,3)%3>>=show
18:48:30 <lambdabot>  "314159265358979323846264338327950288419716939937510582097494459230781640628...
18:48:40 <edwardk> ^- that is the shortest version that is directly recognizable as gibbons' algorithm
18:49:12 <milottiv> thanks for the modifications
18:50:23 <ion> That usage of (%) :-D
18:50:32 <edwardk> ion: =)
18:50:48 <edwardk> saved 2 chars i think overall
18:50:57 <edwardk> maybe 3
18:52:45 <lpaste> edwardk pasted “pi and exp golf” at http://lpaste.net/124247
18:53:19 <edwardk> that shows the sort of slow evolution of them over time as they improved including old versions that had germs of good ideas in them
18:53:19 <kaidelong> is there a good tutorial+reference for GHCi somewhere?
18:53:49 <edwardk> it is funny watching the evolutionary leaps when new algorithms are found
18:54:10 <edwardk> apparently % was worth 4 chars
18:58:20 <levi> Ow, the golfed code hurts my head. :)
18:59:08 <milottiv> can't thank you more for the evolutionary tweaks and treasure of astuteness developed in these lines edwardk
18:59:52 <edwardk> shachaf and a few others on #haskell-blah helped quite a bit
19:02:53 <edwardk> kaidelong: for all the crazy commands you can use and how to program new ones? there used to be
19:03:20 <edwardk> https://wiki.haskell.org/GHC/GHCi#Customized_GHCi_interactive_environments talks a bit about it
19:03:39 <milottiv> nice team work then. appreciate reading it
19:05:47 <lf94> edwardk what text editor do you use
19:06:05 <johnw> edwardk is more about what he edits than how :)
19:06:59 <lf94> I program entire systems in a notepad-like editor
19:12:45 <edwardk> lf94: vim mostly
19:13:15 <lf94> Ah, ok.
19:45:33 <solrize> @pl (\a xs->a:a+2:xs)
19:45:33 <lambdabot> liftM2 (.) (:) ((:) . (2 +))
19:58:28 * hackagebot th-orphans 0.11.0 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.11.0 (MichaelSloan)
20:16:46 <osa1__> is there a way to run cabal exec for a specific ghc binary? like --with-ghc but for cabal exec?
20:17:43 <geekosaur> not sure what you're asking. cabal exec itself runs whatever you tell it to.
20:18:03 <geekosaur> if you're getting the "running cabal configure for you" message, then run cabal configure --with-ghc=... yourself
20:18:51 <osa1__> ok then this is a bug
20:19:25 <osa1__> this command fails: cabal install --with-ghc <ghc-path> && cabal sandbox exec <ghc-path> -- <further args> 
20:19:37 <osa1__> the error message saying that the library it just installed is not installed
20:19:50 <geekosaur> I think cabal install doesn't "remember" the config, so you need to "cabal configure" again
20:20:12 <geekosaur> because cabal install actually installs it and cleans up afterward, leaving the sandbox dir itself unconfigured
20:21:55 <osa1__> even if I manually configure it fails
20:21:58 <osa1__> oh wait I need to configure after install
20:22:34 <osa1__> nope, it didn' twork
20:22:58 <glguy_> cabal install is a whole sequence of configure, build, copy, register, etc
20:23:04 <osa1__> I know
20:23:13 <geekosaur> ok, then you do indeed have what appears to be a cabal bug. suggest you visit https://github.com/haskell/cabal/labels/cabal-install
20:27:23 <osa1__> changing PATH worked fine
20:27:28 <osa1__> btw I may have found a GHC bug
20:27:47 <osa1__> I have a program which fails with segfault in ghc 7.8.3 but it works fine with ghc 7.8.1
20:29:16 <osa1__> I'll now try with 7.8.2
20:38:15 <osa1__> any ideas what has changed in GHC between 7.8.2 and 7.8.3 in terms of RTS changes that may effect FFI functions? :)
20:41:53 <erikd> osa1: how big is that program?
20:41:58 <erikd> ie lines of code
20:42:20 <osa1> erikd: https://github.com/osa1/hslua/issues/24
20:42:52 <osa1> to be more specific, it's failing in a safe FFI call.
20:47:46 <hodapp> Pardon me, but does someone have a paper bag I can put over my head because I spent 10 minutes trying to figure out why my pattern-match was not working right after I made the first case the wildcard case?
20:48:30 <mauke> doesn't -Wall catch that?
20:48:30 * hackagebot farmhash 0.1.0.0 - Fast hash functions.  http://hackage.haskell.org/package/farmhash-0.1.0.0 (abhinav)
20:49:44 <hodapp> mauke: yeah, actually, I've gotten really good at ignoring errors about pattern matching because GHC complains about pattern-match overlap in some work code that isn't actually overlapping.
21:23:54 <randir> anyone here a CPA by chance?
21:26:33 <ab9rf> is anybody ever a CPA by chance?
21:31:54 <kadoban> I guess someone could have rolled a dice to pick a profession.
21:35:28 <randir> One could argue that everyone essentially does, with the butterfly effect.
21:37:07 <geekosaur> I certainly didn't set out to be a sysadmin, or a DBA for that matter which is what my first full time job was for the most part
21:37:59 <randir> (sysadmin comic to lighten your day, although I'm sure you've seen it before: http://xkcd.com/705/ )
21:38:33 * hackagebot farmhash 0.1.0.1 - Fast hash functions.  http://hackage.haskell.org/package/farmhash-0.1.0.1 (abhinav)
21:43:33 * hackagebot fgl 5.5.1.0 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.5.1.0 (IvanMiljenovic)
21:53:58 <gyaretto> Is there a function to move the head of a list to the last of the list?
21:54:34 <glguy_> There isn't a single function that does that in the base package. Generally if you need to do that you want a different type than a list
21:55:42 <johnw> rotate _ [] = []; rotate n xs = zipWith const (drop n (cycle xs)) xs
21:56:05 <gyaretto> Ohkay, thanks!
21:56:07 <johnw> or rotate n xs = bs ++ as where (as, bs) = splitAt n xs
21:56:14 <johnw> if you don't want to rotate more than the length of the list
21:56:41 <bernalex> uhm
21:56:50 <bernalex> f (x:xs) = xs ++ [x] -- like that?
21:56:58 <johnw> for just 1 position, yeah
21:57:13 <bernalex> they said "move the head to the last", nothing more.
21:57:18 <gyaretto> bernalex: That's surprisingly simple. Thanks.
21:57:34 <gyaretto> johnw: I appreciate your help. :)
21:59:32 <johnw> bernalex: I know what was asked for; I prefer being general when it is not inconvenient to do so
22:00:26 <bernalex> gyaretto: there's also 'f xs = tail xs ++ [head xs]' I guess.
22:03:47 <bernalex> or 'f = (++) <$> tail <*> return . head' if you like applicative style & eta-reducing.
22:04:15 <randir> gyaretto: Keep in mind though, as glguy_ said, if you're doing this a lot you might want to look into a different data-structure, as it's not very efficient.
22:04:57 <randir> Hey everyone, does haskell have a list implementation that uses doubly-linked lists on an underlying level?
22:08:30 <bob_twinkles> the [] type is a linked list IIRC
22:08:36 <Rotaerk> singly-linked
22:09:19 <gyaretto> He left.
22:09:44 <bob_twinkles> wow I really failed there then
22:20:47 <David> hey guys
22:21:01 <bramgg> IS there a "replicate" for IO?
22:21:07 <HeladoDeBrownie> @type replicateM
22:21:07 <David> what's the procedure to manually intstall cabal packages as binaries?
22:21:07 <lambdabot> Monad m => Int -> m a -> m [a]
22:21:15 <HeladoDeBrownie> m ~ IO
22:21:16 <David> here's the situation - I've got a vps with really low memory (512mb)
22:21:24 <HeladoDeBrownie> replicateM :: Int -> IO a -> IO [a]
22:21:34 <David> so I set up an identically configured VM on my laptop to compile haskell-src-exts
22:21:42 <David> (via cabal install)
22:21:51 <David> and I want to install them remotely
22:21:57 <bramgg> HeladoDeBrownie: thanks
22:22:12 <bramgg> actually checked for a replicateM, but assumed it would be in Prelude if it existed
22:22:14 <David> I presume I just copy the stuff from .cabal/lib and .cabal.bin
22:22:22 <HeladoDeBrownie> Control.Monad.replicateM
22:22:23 <David> but is there some sort of package registration thing I need to do?
22:22:35 <pacak> David: ~/.ghc
22:24:15 <David> ah, copy .ghc/x86_64-linux-7.6.3/haskell-src-exts-reallylonghash over?
22:24:29 <David> er.. in package.conf.d
22:25:45 <pacak> David: Yep
22:26:06 <David> all right, thansk
22:26:07 <David> !
22:26:14 <bramgg> Is it possible to specifically import a function that a module does no export?
22:26:47 <HeladoDeBrownie> bramgg, not exported functions are not available from the module in question
22:27:17 <HeladoDeBrownie> (however if it was in turn imported from another module, you might get it there)
22:27:45 <HeladoDeBrownie> bramgg, did i understand your question correctly?
22:28:20 <bramgg> HeladoDeBrownie: think so
22:34:28 <David> pacak: I got this error: <command line>: cannot satisfy -package-id haskell-src-exts-1.16.0.1-ac04bffe826c48234d59b12315ead605
22:34:36 <David> when trying to install hoogle, which depends on haskell-src-exts
22:34:55 <David> I copied over ~/.cabal/bin/haskel-src-exts-1.16.0.1 and the thing in .ghc
22:35:37 <David> er, sorry, lib/haskell...
22:35:41 <David> there's nothing in bin
22:35:58 <pacak> There's also a package.cache in .ghc
22:36:28 <pacak> You need either to recreate it or copy everything
22:40:09 <David> hmm. This is what I'm seeing
22:40:17 <David> when tryingto rebuild the cache
22:40:17 <David> ghc-pkg: /var/lib/ghc/package.conf.d/package.cache: you don't have permission to modify this file
22:40:27 <David> it's mode 666
22:41:23 <mauke> why would it be 666?
22:41:32 <David> it's owned by root
22:41:34 <David> and was 644
22:41:42 <David> so I tried changing it to 666
22:41:45 <David> still got the permisson error
22:42:40 <pavonia> It's 666 because it's from dependency hell, obviously
22:42:50 <pacak> /var/lib? I thought you are working with ~/.ghc and ~/.cabal
22:43:23 <David> I was doing a ghc-pkg recache
22:43:25 <David> to rebuild the cache
22:43:35 <pacak> add --user to recache ~/.ghc
22:44:14 <David> It works. Thanks pacak!
22:48:09 <SrPx> Hey guys, I'm starting to, anytime I need something not on the standard libraries, to create a standalone file with whatever extension I need, as if it was part of base. For example, this one: http://lpaste.net/124254
22:48:12 <SrPx> Is this an antipattern? 
22:51:49 <gyaretto> SrPx: What is the first line?
22:52:48 <SrPx> gyaretto: hm? Language pragmas
22:53:01 <gyaretto> What is that?
22:53:16 <gyaretto> I'm new to Haskell.
22:53:17 <HeladoDeBrownie> ghc features you can enable
22:53:29 <gyaretto> Oh, interesting.
22:53:31 <HeladoDeBrownie> basically that change the language semantics or syntax in useful ways
22:53:34 <HeladoDeBrownie> they*
22:53:48 <SrPx> they add some language extensions such as template haskell, view patterns, etc... I'm not sure why they don't make those extensions part of the language
22:54:12 <HeladoDeBrownie> e.g., scoped type variables lets you refer to the variables in a top-level binding's type from the types of its local bindings
22:54:13 <gyaretto> Huh, goog to know. I don't think I came across that in LYAH.
22:54:26 <gyaretto> s/goog/good/
22:55:15 <SrPx> There is not much to worry about it though, 90% of the times GHC himself tells you to add certain extension if you used a feature that needs it unknowingly 
22:56:18 <Javran> does "saturated constructor application" mean a fully applied constructor?
22:56:27 <HeladoDeBrownie> Javran, sounds right
22:56:41 <Javran> HeladoDeBrownie: I see
23:00:54 <glguy_> Anyone know if it's possible with the vty package to draw text on the screen so that it line-wraps in such a way that when I copy from my terminal I get a single line
23:00:58 <Galvus> After I get done reading "Learn you a haskell", what follow books should I investigate? My plan right now is to tackle the math problems listed on...https://projecteuler.net/
23:01:02 <glguy_> instead of an intervening newline
23:01:12 <dmj`> Galvus: the typeclassopedia
23:01:18 <Galvus> *follow up, one day I'll read a book on how to type w/o sucking.
23:02:01 <Galvus> thanks dmj, bookmarked. 
23:05:11 <dmj`> Galvus: parallel and concurrent programming in haskell by simon marlow
23:05:51 <jle`> suggestion seconded
23:07:01 <dmj`> Galvus: make sure you can write Control.Monad, Control.Applicative, Data.Monoid, Data.List, and the Prelude from scratch, and the types and instances for Reader, Writer, State, and how to Stack monads w/ transormers. 
23:07:42 <Galvus> When I finish LYAH, I imagine that will have more meaning to me. Copypasta'd your statement into my notes though.
23:08:47 <pacak> Galvus: RWH is a nice book, a bit outdated.
23:09:36 <kadoban> Galvus: I'd say following the course recommended by https://github.com/bitemyapp/learnhaskell is a better idea, if nobody has suggested it. The CIS194 one. It has exercises, suggests readings from LYAH and RWH, etc.
23:10:15 <kadoban> When I finished reading LYAH, I could barely actually code anything is the problem. Without exercises, I could kinda recognize some stuff, but actually sitting down to code something was…not possible.
23:10:49 <dron2065> Hello, I have problem with fastcgi. At Network.FastCGI command like "runFastCGI" create fcgi server, right? But how to specify listening port, or unix-socket?
23:10:51 <dmj`> Galvus: If you just read haskell you'll never become a haskell programmer, you have to write it, every example you read, you should also write, otherwise you're just kidding yourself
23:10:52 <Hijiri> I never got all the way through LYAH
23:11:02 <Hijiri> I just ran out of motivation then eventually used CIS194 instead
23:11:07 <Galvus> kadoban, I have a fair bit of functional programming experience from other languages but not nearly as expressive as haskell
23:11:22 <Galvus> I'm usually writing random programs based on what I've learned in LYAH
23:11:52 <Hijiri> you could try the follow-up to CIS194 suggested in bitemyapp's thing
23:11:57 <Hijiri> the NICTA course
23:12:12 <Hijiri> it just has you implement a lot of things, with some focus on typeclasses
23:12:30 <Galvus> Fun, I'll try that out.
23:13:08 <drewbert> Man cabal just ruins my day every day.
23:13:10 <kadoban> Yeah, it's pretty typeclass heavy. Which is good stuff, but isn't really "skip CIS194 and do that" kinda stuff, at least it certainly wasn't for me.
23:13:50 <Hijiri> it wasn't for me either, but haskell is my first functional language
23:14:56 <Galvus> End goal is being able to describe a bone system with forces acting upon them. Ideally following up with muscles/ligaments.
23:15:16 <kaidelong> drewbert: are you using sandboxes?
23:15:26 <kaidelong> or stackage
23:15:29 <drewbert> kaidelong: both
23:16:00 <kadoban> Using both of those made me stop hating cabal. I don't think I've had a fight with it since.
23:16:11 <drewbert> kaidelong: things were happy for a while until I tried to get haskell-interactive and ghc-mod working at the same time.
23:16:18 <HeladoDeBrownie> Galvus, df clone? :P
23:16:26 <Javran> what about hsenv?
23:16:29 <kadoban> HeladoDeBrownie: Hah
23:17:14 <Galvus> HeladoDeBrownie, hah no. Just read a few books on genetic algorithms and want to try generating animations based on simulations.
23:17:15 <Javran> but seems it just solves what cabal exec solves
23:17:34 <kaidelong> drewbert: last time that happened I checked out the source repositories, pulled the lowest upper bound up to the maximum lower bound to solve the incompatibility, fixed the problems, and umm
23:17:53 <kaidelong> I don't think I ever sent a pull request and now that work is lost with my old install
23:17:58 <kaidelong> but
23:18:02 <kaidelong> that is the strategy
23:18:08 <Galvus> HeladoDeBrownie, side effect of hopefully learning a bunch about functional programming/haskell ;)
23:18:11 <kaidelong> basically see if doing that still compiles
23:18:21 <kaidelong> if it doesn't, fix it and file a pull request and use your modified version in the meantime
23:18:42 <HeladoDeBrownie> i do remember mention of someone writing a df clone in haskell actually
23:18:51 <HeladoDeBrownie> and it was pretty involved
23:18:53 <drewbert> kaidelong: I cloned ghc 7.10 hoping it would fix things.  Apparently ghc 7.10 can't compile mysql at the moment.  So I guess instead of upgrading ghc I should have downgraded cabal.  I didn't know.
23:19:00 <Galvus> dwarf fortress is amazingly complex.
23:20:13 <kaidelong> Galvus: many of the rules it uses are hilariously simple though, like you can support giant structures on a single tiny pillar, much of the complexity is emergent, so cloning it may not be too hard
23:20:21 <kaidelong> it's the stats system that would be the biggest problem
23:20:25 <kadoban> It really is. I don't think he'll be done until he's modelling actual living cells of each dwarf.
23:20:33 <drewbert> blaming cabal is not fair as I guess cabal is just the messenger, but dang.  Haskell and libraries.  Never fun times.  Always sad times.
23:20:56 <Galvus> kaidelong, you ever play Space Station 13? (terrible 2d round based game that is amazingly fun as it runs stupidly complex simulations, like electrical load, gas pressure, etc)
23:22:14 <kaidelong> Galvus: I know about that game but I haven't played it, that may be significantly more complex to clone in Haskell because of its extensive net code
23:22:18 <kaidelong> but this is a bit off topic
23:26:28 <johnw> drewbert: try Nix
23:26:39 <SrPx> What is the best pattern to represent the effect of a card in a card game? For example, a card, "foo", could have the effect of shuffling your deck and drawing 3 cards. I have "foo :: (MonadRandom m, Functor m) => GameState -> m GameState" -- but I wonder if there is a "purer" way to program the logic of my game without requiring MonadRandom, etc.
23:26:50 <drewbert> johnw: I am so close to that point, you don't even know.
23:26:59 <johnw> well, it ended my woes
23:27:04 <johnw> created some new ones, but that's life
23:27:36 <HeladoDeBrownie> SrPx, MonadRandom is not "impure", and may be equivalent to how you would have implemented it anyway.
23:28:37 <HeladoDeBrownie> SrPx, how much reasoning about the effect of a card do you need to do?
23:28:52 <HeladoDeBrownie> SrPx, e.g., can cards alter the effects of others? or do they just do a thing and then are done?
23:28:55 <SrPx> I don't mean it is impure, "pure" is a bad word here. I mean, can I define the logic of my game without depending on MonadRandom? That is, I want to write things like: "do { shuffleDeck; coin <- flipCoin; case coin of { Head → drawCard ... } }" as if I had a DSL for my game.
23:29:18 <HeladoDeBrownie> SrPx, sure, but you can make a dsl anyway and just represent it using MonadRandom.
23:29:20 <pacak> SrPx: Make a shuffled deck before you start a game?
23:29:52 <SrPx> I can then have a "runGame" that makes the connection to ST, Random and any other similar monad I need. But for the logic itself, can I define the effect of a card by itself?
23:30:05 <SrPx> HeladoDeBrownie: but how
23:30:47 <drewbert> johnw: I'm doing it.  Will this really solve my troubles?  
23:30:52 <HeladoDeBrownie> newtype CardEffect … = CardEffect (forall m. (MonadRandom m) => …) ; drawCard :: CardEffect … ; drawCard = CardEffect …
23:31:03 <HeladoDeBrownie> insert appropriate code in place of the …s
23:31:27 <HeladoDeBrownie> that's just one way, anyhow.
23:32:21 <Rotaerk> probably don't want MonadRandom anywhere near the type of a gamestate transform that doesn't need randomness
23:32:35 <HeladoDeBrownie> drawCard seems like it does need randomness
23:32:44 <johnw> drewbert: some it will solve, some it won't, and there will be new -- albeit different -- problems
23:32:50 <Rotaerk> right, but not all gamestate transforms need it
23:33:22 <HeladoDeBrownie> in that case they can be lifted from something not using it
23:33:37 <HeladoDeBrownie> but actions in the dsl will need to have a random source since they can be composed of things needing a random source
23:33:40 <SrPx> hmm I see :( that is not what I'm looking for, though... I really mean, suppose that I had to write my entire logic without importing MonadRandom at all
23:34:05 <SrPx> I'm not on the right mindset here anyway, guess I have to think a little more before asking
23:34:13 <HeladoDeBrownie> SrPx, well, i suppose you could write a representation using Free, which has the advantage that it's slightly easier to analyze.
23:34:36 <SrPx> tell me more
23:35:27 <lpaste> bramgg pasted “Pls help ty (づ｡◕‿‿◕｡)づ” at http://lpaste.net/124255
23:35:39 <bramgg> ^
23:35:43 <HeladoDeBrownie> say you represent flipping a coin as a constructor of a type like: FlipCoin :: GameAction CoinResult
23:35:58 <HeladoDeBrownie> then you don't need randomness in the representation, but the interpreter will need it
23:36:09 <HeladoDeBrownie> writing it like that requires gadt by the way
23:36:18 <HeladoDeBrownie> let me find you a relevant post
23:36:43 <HeladoDeBrownie> wait i messed up
23:36:50 <HeladoDeBrownie> but check this out http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
23:37:00 <HeladoDeBrownie> you actually don't need gadt
23:37:06 <HeladoDeBrownie> i was confusing two approaches in my head
23:37:21 <HeladoDeBrownie> so it'd be like
23:37:29 <Rotaerk> I tend to confuse things in my ankle :)
23:37:40 <HeladoDeBrownie> data GameAction … a = … | FlipCoin (CoinResult -> a) | …
23:38:06 <David> mokus or int-e - is there anything in the lambdabot code still looking for Lambdabot.Plugin.Eval.Trusted?
23:38:09 <HeladoDeBrownie> define an appropriate Functor instead (it can be derived with the DeriveFunctor extension), use Free to generate a Monad
23:38:30 <HeladoDeBrownie> s/instead/instance/
23:38:42 <David> seems like it's now Lambdabot.Plugin.Haskell.Eval.Trusted, but when I try to execute something it's complaining Could not find module `Lambdabot.Plugin.Eval.Trusted'
23:44:05 <nshepperd> what's so bad about importing MonadRandom
23:49:39 <nshepperd> the free monad approach is cool, of course, but you can just as easily do something like 'type GameAction m a = StateT GameState m a', and then have 'drawCard :: GameAction m Card' as well as 'shuffleDeck :: (MonadRandom m) => GameAction m ()'
23:50:18 <nshepperd> the final value will have a MonadRandom constraint if and only if it uses randomness at any point
23:52:27 <SrPx> HeladoDeBrownie: my bad, I'm reading! Thank you
23:52:46 <jle`> SrPx: MonadRandom is whatever you want it to be, you can write your own instances, etc.
23:53:08 <jle`> instance MonadRandom IO where ...
23:53:13 <jle`> instance MonadRandom ST where ...
23:53:23 <jle`> um with w/e kind ST needs to be
23:53:54 <SrPx> jle`: uh huh, but I just wanted to somehow decouple the game logic from the notion of randomness
23:54:02 <SrPx> I guess free monads might be the answer indeed
23:54:18 <jle`> but your custom monad that you make will still have the notion of randomness in it
23:54:21 <HeladoDeBrownie> SrPx, ah, well *that*, i'd say, is not possible, the way you said it just now. your game logic inherently involves randomness.
23:54:36 <jle`> data Card = CardRandom | CardNonRandom
23:54:39 <jle`> it still has the notion of randomness in it
23:54:49 <jle`> it depends on how you interpret it
23:54:55 <HeladoDeBrownie> SrPx, the only thing you really gain from the Free solution is the ability to analyze what action an effect takes, and even then in limited ways
23:55:20 <HeladoDeBrownie> it may be that you don't want a monadic dsl at all, even
23:55:29 <HeladoDeBrownie> depends on the bigger picture really
23:55:33 <jle`> even if you make your own custom monad (w/ Free or howevery ou want), you're still going to be somehow reifying the idea of randomness
23:55:43 <jle`> which is exactly what MonadRandom is
23:57:21 <SrPx> (and this is why I'm so bad in expressing what I am thinking)
23:57:36 <SrPx> I'm almost sure free monads are what I need now, I will run some tests and report back :)
23:57:46 <SrPx> thanks guys
23:57:52 <jle`> mk
23:58:07 <jle`> does anyone know if there is any established atom/rss feed parser/manipulation library out there
23:58:18 <jle`> i'm trying out `feed` but it reports dates as strings
23:58:41 <jle`> i could parse it but i'm wondering if there's a library i don't know about out there :)
23:58:45 <dmj`> jle`: http://hackage.haskell.org/package/feed ?
23:58:50 <jle`> yes that's the one i'm trying
23:59:13 <jle`> i guess i'll just have to look up the atom spec and see what date formats there are and parse it w/ the time library
