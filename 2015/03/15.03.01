00:00:26 <shachaf> Not necessary.
00:00:38 <fayy> I agree with that :D  what's category theory?
00:00:45 <Cale> dashster18: That's a good question. Assuming that you're going to learn abstract algebra, whether to learn some category theory before or whether it's best to save it until after... you could really do it in either order. Having more areas of mathematics under your belt will certainly help you appreciate CT better.
00:01:40 <Cale> But if your goal is *just* to write programs, it's a slightly questionable use of time to study category theory, it's more about whether you find it fun :)
00:02:31 <dashster18> Most of my schooling was in CS, so the formal math (proof-based) I have under my belt is mostly related to Discrete. However, I really do enjoy it, probably more so than anything else and have fun learning it. So it looks like I can go straight from LA => CT?
00:06:26 <Cale> dashster18: Sure. I recommend Awodey's book. (I'll link it in PM for you.)
00:06:49 <dashster18> Awesome, thanks!
00:07:12 <shachaf> I recommend Tom Leinster's recent book, _Basic Category Theory_.
00:07:14 <dashster18> Now getting back to the programming part, what do you guys think is a good refresher on haskell after stepping away from it for ~6 months?
00:09:01 * hackagebot hwsl2 0.3.0.1 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.3.0.1 (srijs)
00:09:01 * hackagebot hnetcdf 0.3.0.0 - Haskell NetCDF library  http://hackage.haskell.org/package/hnetcdf-0.3.0.0 (IanRoss)
00:09:51 <Cale> But yeah, be aware that a lot of the richest examples of categories come in the form of those where the objects are some sort of mathematical structure, and the arrows are transformations between those which preserve the structure we're interested in. So, groups and group homomorphisms, rings and ring homomorphisms, topological spaces and continuous maps, and so on. Vector spaces and linear maps is a pretty decent exam
00:09:52 <Cale> ple too though :)
00:10:36 <Cale> As for what's a good refresher on Haskell, I don't know exactly. If you're looking for a course, a lot of people seem to recommend Brent Yorgey's CIS 194 course materials.
00:10:54 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
00:11:00 <dashster18> It doesn't necessary have to be a course, maybe a short-medium length programming project?
00:11:19 <dashster18> Any ideas?
00:11:38 <Cale> Perhaps a raytracer? :D
00:11:48 <dashster18> Don't know what raytracers are. :p
00:12:06 <dashster18> Maybe a web crawler to download images and store them in a db?
00:12:28 <Cale> sure
00:25:47 <Lokathor> dashster18, https://github.com/bitemyapp/learnhaskell goes into a lot of depth about suggested haskell resources
00:29:27 <dashster18> Lokathor: Ah, awesome. Thanks!
00:34:22 <dashster18> For Yorgey's class, can anybody sign up and submit homework?
00:38:31 <dulla> thought the lectures were open
00:38:57 * hackagebot diagrams-hsqml 0.0.0.2 - HsQML (Qt5) backend for Diagrams  http://hackage.haskell.org/package/diagrams-hsqml-0.0.0.2 (mjmrotek)
00:40:01 <fayy> dashster18: learning CT & LA to write a web scraper? D:
00:40:15 <dashster18> fayy: no, those were two un-related topics :p
00:40:29 <dashster18> fayy: Learning LA & CT for fun; writing a web scraper to refresh on haskell
00:44:49 <nuser> dashster18: how long did it take you to work through LYAH,RWH & Write You a Scheme.. ?
00:46:27 <dashster18> nuser: 2 weeks of dedicated study over a spring break for LYAH
00:46:45 <dashster18> Don't completely remember the last couple of chaptersd
00:47:10 <dashster18> RWH took longer, skipped a lot of the chapters after 21-22 because the code examples didn't work
00:47:30 <dashster18> WYAS48 was somewhere in between, can't remember
00:47:41 <dashster18> RWH took a few months though
00:48:15 <fayy> what's RWH?
00:48:26 <fayy> nvm, found it
00:49:43 <nuser> impressive
00:50:42 <dashster18> nuser: Heh, not really
00:51:15 <dashster18> When I started LYAH, I had a really easy and light semester where I only had class on TuTh
00:51:40 <dashster18> And I did RWH after I graduated and was living with my parents for the summer before joining my job
00:51:43 <dashster18> Had nothing else to do all day
00:51:58 <dashster18> + a broken foot
00:53:58 * hackagebot system-fileio 0.3.16.1 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.16.1 (MichaelSnoyman)
00:54:59 <nuser> 24hrs later I'm on Chapt 2 of WYAS48.
00:56:15 <dashster18> Yeah, WYAS48 took me a lot longer then 48 hours
01:01:37 <fayy> I want to learn Idris, I still get `head` errors and off by one mistakes, and I think dependent typing may help?  I have no idea though
01:03:43 <nuser> dashster18: may I pm you later (~4hrs)?
01:07:02 <dashster18> nuser: Heh, I'll probably be asleep. It's 1 am for me at the moment and I'm about to head to bed :)
01:07:12 <dashster18> But you can pm me whenever you see me on
01:08:32 <nuser> dashster18: will do, thanks.
01:30:05 <dashster18> I forgot how beautiful haskell is
01:30:27 <jle`> :)
01:31:26 <dashster18> I've been working in a lot of python lately, learning their scientific computing stack. Is there something similar to numpy/scipy/scikit-learn in haskell?
01:31:29 <dulla> Haskell
01:31:35 <dulla> It makes you function in your pants
01:31:59 <dulla> Not sure, but I know a place with about 200 freaking pdfs on python
01:32:14 <dulla> the hell is this numpy again?
01:32:33 <Axman6> a python wrapper to C
01:32:34 <Axman6> >_>
01:33:13 <dulla> Thought it was supposed to be a fancy number cruncher
01:33:25 <Axman6> dashster18: the support for that sort of work is less coherent in Haskell; there is work to make much nicer linear algebra libraries (we already have some very good ones though), and there's some good symbolic computation stuff too
01:33:27 <dulla> There's FFI to interface with C
01:34:05 <dulla> is there a respective pynomo in haskell
01:34:17 <Axman6> I was making a joke. Numpy is renowned for being quite fast, and it achieves this by doing as little in Python as possible
01:34:22 <dulla> something something, involves drawing really weird graphs via descriptive geometry
01:34:53 <dashster18> Numpy is an nD array processing library in Python which is a wrapper around C
01:35:00 <dashster18> Super fast linear algebra operations
01:35:17 <dashster18> Scipy is a library built on numpy which brings a lot of scientific programming into a library
01:35:25 <dulla> Man, does heart burn make your ribs creak
01:35:33 <Axman6> if that's what floats your boar, you should talk to carter and see if he's finished any of his array work
01:35:42 <dashster18> linalg, optimization, solving integrals, and a lot of other stuff
01:35:52 <dashster18> Scikit-learn is a machine learning library built on those two
01:35:54 <dulla> ech, solving integrals
01:36:13 <dulla> some demon magic with ast's, and arbitrary forms
01:37:34 <bennofs> dashster18: HLearn is a haskell ML library. but I don't know anything about ML :)
01:39:29 <dulla> something something, back propogating error rates
01:39:35 <dulla> expensive training, cheap usage
01:41:49 <dulla> It's not necessarily the smartest thing ever, but it's better than doing it yourself
01:42:43 <dulla> Seems to the the modus operandai for all of this
01:47:14 <Yaniel> holy ship this channel is huge
01:54:04 <dulla> This is Haskell: The Mialing List: The IRC Channel
01:54:20 <bitemyapp> Yaniel: a bit.
01:55:07 <bennofs> What is the reason that the vector library doesn't provide it's operations over a generic index type like array does with the Ix class?
01:55:21 <Axman6> performance
01:55:31 <Axman6> iirc
01:55:54 <Axman6> it's supposed to be quite low level; you can write such functionality on top of it (using Ix if you want)
01:56:18 <Cale> It's sort of sad that this is a viable reason
01:56:45 <Cale> It should be possible to have it be such that if you use Int indices, the performance is identical
01:56:54 <Axman6> well the work it's being used for is very strongly focused on performance
01:56:58 <Cale> yeah
01:57:14 <Axman6> and avoid GHC being sumb is easier if you just use Int =)
01:57:17 <Axman6> avoiding*
01:57:36 <Cale> I understand why it's not, I just think it would be nice if we could rely on specialisation more.
01:57:37 <bennofs> Shouldn't {-# SPECIALIZE #-} + {-# INLINE #-} pragmas allow it to generate code just like if it didn't use Ix
01:58:16 <shachaf> You would have to SPECIALIZE everything, even user-defined functions.
01:58:29 <Cale> Honestly, Ix was one of those little things which really impressed me about Haskell as a beginner :)
01:58:47 <Cale> It's one of those "Why doesn't every language do this?" things
01:59:06 <Axman6> I prefer Ada's related features
01:59:26 <bennofs> shachaf: well, user defined functions would mostly not be generic in the Index? If they are, I don't see why they shouldn't require inline or specialize
01:59:30 <funfunctor> hi
02:00:11 <Cale> Yeah, ideally, if you care about performance, you should just be able to *use* Int indices and have it be identical to the current library's performance.
02:00:17 <shachaf> bennofs: Well -- the inferred/most general type is generic.
02:00:23 <Cale> But I'm not sure how well that really works out.
02:00:30 <shachaf> I don't know whether they "should" require specialize, but they're not likely to get it.
02:00:36 <funfunctor> while reading https://hackage.haskell.org/package/binary-0.7.4.0/docs/Data-Binary-Get.html and trying out one of the examples I see there is no BL.Chunk and BL.Empty means to say BL.empty ?
02:01:14 <bennofs> Also, we already have Data.Vector.Generic, doesn't that have the same problem?
02:01:16 <Cale> funfunctor: That appears to be using the internal interface to lazy bytestrings
02:01:32 <funfunctor> Cale: sounds "bad" ?
02:02:04 <Cale> funfunctor: You could use the chunks function instead
02:02:15 <Cale> I think...
02:02:20 <funfunctor> :t chunks
02:02:21 <lambdabot>     Not in scope: âchunksâ
02:02:21 <lambdabot>     Perhaps you meant one of these:
02:02:21 <lambdabot>       âchunkâ (imported from Data.List.Split),
02:02:24 <Cale> uhh
02:02:35 <funfunctor> > import Data.List.Split
02:02:37 <lambdabot>  <hint>:1:1: parse error on input âimportâ
02:02:46 <funfunctor> ugh
02:02:51 <Cale> toChunks
02:02:55 <Cale> :t toChunks
02:02:56 <lambdabot>     Not in scope: âtoChunksâ
02:02:57 <lambdabot>     Perhaps you meant âBSLC.toChunksâ (imported from Data.ByteString.Lazy.Char8)
02:03:10 <Cale> :t BSLC.toChunks
02:03:11 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
02:03:44 <Cale> It turns a lazy bytestring into a list of strict chunks (which is more or less what a lazy bytestring is anyway)
02:07:26 <Cale> Yeah, I'm not sure what's going on with those examples, and why pushChunks isn't being used somehow.
02:07:37 <bennofs> Can anyone explain this http://hackage.haskell.org/package/vector-0.10/docs/Data-Vector-Generic.html#v:basicUnsafeIndexM comment?
02:08:11 <funfunctor> Cale: seems overly long..
02:08:18 <bennofs> I don't see how case basicUnsafeIndexM v i of Box x -> ... is different from let x = basicUnsafeIndex v i in x `seq` ...
02:08:26 <bennofs> (or pseq if you wish)
02:08:38 <lpaste> funfunctor pasted âNo titleâ at http://lpaste.net/121369
02:08:46 <Cale> bennofs: Yeah, that comment sounds like total BS to me, lol
02:09:00 <funfunctor> Cale: also I get some weird parse error Parse error in pattern: BSLC.toChunks
02:09:15 <Cale> funfunctor: uhhh
02:09:26 <Cale> funfunctor: you can't just replace Chunk with it
02:09:40 <funfunctor> oh um
02:09:52 <bennofs> Cale: you would probably get the strictness if m ~ IO automatically, without requiring any extra work
02:09:54 <funfunctor> how do you write this probably any way.. this example seems shit
02:09:58 <bennofs> Cale: that's the benefit I can see
02:10:45 <darthdeus> hey guys, what's the recommended way of running haskell processes as daemons? i'm totally noob at this (only deployed ruby in which servers have its own daemon implementations)
02:10:46 <bennofs> Cale: ah, I think I understand what they mean
02:11:06 <darthdeus> like, should I write upstart script for the app, or manually manage the process, or ?
02:11:23 <bennofs> Cale: if you had v = V.fromList [undefined], then let x = v ! 0 in x `seq` ... would be bottom
02:11:46 <bennofs> Cale: instead, case unsafeIndexM v 0 of Box x -> ... would not be bottom
02:12:39 <geek> how could haskell evaluate 2 Â± (3 â 4) ?
02:14:09 <Axman6> geek: the first thing that comes to mind is having an instance for Num a => Num [a]
02:14:36 <funfunctor> Cale: this example seems completely broken to me..
02:14:37 <Axman6> but how you do that has many different answers
02:14:38 <Cale> > do ((+-),(-+)) <- [((+),(-)), ((-),(+))]; return (2 +- (3 -+ 4))
02:14:40 <lambdabot>  [1,-5]
02:14:51 <funfunctor> Cale: where is this Chunks even from any way..
02:15:00 <Cale> funfunctor: Data.ByteString.Lazy.Internal
02:15:12 <Cale> funfunctor: If you import that, the example should work
02:15:13 <Axman6> funfunctor: pretty sure's it's the Cons for a lazy bytestring
02:15:45 <Cale> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
02:15:55 <Cale> That's how lazy bytestrings are defined internally
02:16:21 <bennofs> What benefits does vector have over array? saner interface and faster?
02:16:40 <Cale> bennofs: Faster because of stream fusion
02:17:09 <Cale> The interface isn't 100% saner, as was mentioned before, you don't get the nice benefit of Ix directly
02:17:23 <Cale> (though you can use Ix operations regardless to compute Int indices if you like)
02:17:45 <Cale> But yeah, mostly stream fusion.
02:18:17 <funfunctor> Cale: thx, well it didn't do what I expected
02:18:53 <Cale> funfunctor: What are you trying to do?
02:19:40 <Cale> I think those examples must have been written prior to certain functions were added to the API the Get module.
02:19:43 <funfunctor> Cale: parse frames as they come in.. so I am using a file as a sample of a stream dump which is truncated
02:19:48 <Cale> being added*
02:20:29 <Cale> I think basically you want to use pushChunk for the most part.
02:23:33 <Cale> funfunctor: Is your problem that you really want partial results from the parser before parsing is complete?
02:23:53 <Cale> Like, you really want to be able to do something with the first frames before the rest of the frames are parsed as well?
02:24:13 <Cale> It might be best to use runGetOrFail in a loop for that.
02:24:22 <Cale> and just have a parser which parses *one* frame
02:24:56 <funfunctor> Cale: ok, how would I do something like that?
02:27:43 <Cale> Uhh, I'll make an example for you when I get back in a minute :)
02:27:51 <lpaste> funfunctor revised âNo titleâ: âNo titleâ at http://lpaste.net/121369
02:28:14 <funfunctor> Cale: ah thanks, I just pasted the part i'm allowed to
02:40:59 <Cale> funfunctor: Okay, I'm back...
02:42:04 <Cale> funfunctor: So, there are a bunch of different things we could do depending on how you want to handle errors in the stream, and what needs to be done with each frame and so on.
02:43:20 <Cale> funfunctor: btw, I thought about what I said a bit more, and I think using the incremental parsing still makes sense even if you just stick the parser for one frame in -- it just means it'll give you a successful result sooner, and when it does, you get the remainder of the input anyway.
02:45:36 <Cale> i.e. you want to take the ByteString that comes along with your "Done" result, and stick that into the incremental parser for the next frame immediately
02:51:43 <dulla> wat
02:51:59 <dulla> also, found a neat place that explains concepts succintly and visibly
02:52:11 <dulla> setosa.io/ev/
02:52:35 <dulla> It has a section on Principle Component Analysis, and Eigenvectors/Values/Spaces
02:52:40 <dulla> And som lead offs
02:59:04 * hackagebot classy-prelude-yesod 0.10.5 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.5 (MichaelSnoyman)
02:59:05 <funfunctor> Cale: yea so thats basically what I want
02:59:06 * hackagebot classy-prelude 0.10.5 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.5 (MichaelSnoyman)
02:59:08 * hackagebot classy-prelude-conduit 0.10.5 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.5 (MichaelSnoyman)
02:59:34 <funfunctor> Cale: I main loop that takes in input and parsers frames at a time
03:01:22 <funfunctor> Cale: I have my parser ready with getClientFrame = isolate 58 getClientFrame' where getClientFrame' :: Get ClientFrame
03:07:46 <kuznero> Hi All!
03:09:04 * hackagebot shell-conduit 4.5.2 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.5.2 (ChrisDone)
03:10:54 <unsymbol> kuznero: allo
03:12:25 <dulla> hey
03:13:46 <bitemyapp> kuznero: howdy
03:30:14 <bennofs> Does killThread work for threads blocked in an STM atomically block?
03:30:56 <zipper> Is there a place I can get the logs for the #yesod channel?
03:33:32 <zipper> Turns out waiting two days for waiting for you mailing list questions isn't too long. I always delete my posts soon after I feel that nobody cares.
03:34:23 <Cale> bennofs: How do you block in an STM atomically? Also, it should.
03:35:16 <Cale> funfunctor: Sorry, trying to come up with something a bit more general and not too inelegant. There are a lot of obnoxious cases to deal with when doing I/O like this. :)
03:36:19 <funfunctor> Cale: yea :/
03:38:43 <bennofs> Cale: I'm doing atomically $ do a <- readTVar aVar; b <- readTVar bVar; check (a /= b); writeTVar bVar a
03:39:06 <lpaste> Cale pasted âthere's this...â at http://lpaste.net/121371
03:39:09 <Cale> funfunctor: ^^
03:40:19 <Cale> bennofs: okay, that shouldn't ever block
03:40:38 <Cale> bennofs: check b = if b then return () else retry
03:40:58 <bennofs> Cale: well, it was just a question if it works, didn't try yet :)
03:41:01 <Cale> Well, okay, the STM action won't block
03:41:08 <Cale> but the atomically will
03:41:36 <Cale> (if a and b are equal, it will effectively block until they aren't)
03:43:19 <Cale> That's actually an interesting pattern, why are you doing that? You just want to wake up occasionally when aVar is different from its previous value?
03:43:53 <Cale> bennofs: It's worth noting that you may miss some updates like that
03:44:54 <Cale> (If aVar changes twice before your STM action gets retried.)
03:46:52 <Cale> funfunctor: There's probably something somewhat elegant you could do using pipes.
03:47:19 <Cale> funfunctor: But that's a *lot* of fancy machinery to pull in, I always hesitate to use those libraries.
03:47:35 <Cale> (pipes/conduit/etc.)
03:47:57 <dulla> so STM is State Transtion machine?
03:48:05 <dulla> or transaction
03:48:05 <Cale> STM is software transactional memory
03:48:22 <dulla> ok
03:48:33 <Cale> It's a really cool device for thread communication
03:48:49 <dulla> and atomicity is some kind of acronym dealing with x action does not any action other than x
03:49:22 <dulla> sounds like a neat way to screw with STM, but still not sure what stm itself does
03:49:31 <Cale> You can write STM actions which are like IO actions except the only effects they may have are memory effects on TVars and related mutable data structures.
03:49:32 <lpaste> funfunctor pasted âNo titleâ at http://lpaste.net/121372
03:49:45 <funfunctor> Cale: ^ i'm just trying to get this to type-check..?
03:49:53 <bennofs> Cale: but I will always have the last update. I don't care if I miss updates in between, I
03:50:05 <bennofs> Cale: I'm using it to notify the UI of changes, so it should be ok
03:50:06 <Cale> and atomically :: STM a -> IO a will run one of these in such a way that it's *as if* it's the only action running
03:50:19 <dulla> So
03:50:57 <dulla> more or less STM actions update a given STM Var, but which one is used when another one acts
03:51:09 <Cale> Basically, reads and writes to memory are logged, and when the STM action finishes, the implementation internally takes a lock and checks that all the read values have the same values they did at the time, and if so, performs all the writes at once.
03:51:40 <Cale> (writes before that point just go in the transaction log)
03:52:03 <dulla> So it tries to enforce all functions on said value, is one the "correct" or rather, "locked" one
03:53:27 <dulla> And the correct one, is the latest one at the start of the function call
03:53:39 <dulla> Do the inconsistencies matter?
03:53:41 <Cale> It will ensure that each transaction (the action passed to atomically) will either run completely, or as if nothing ever happened, and it also ensures that it behaves as if no other threads were running at the same time (even if they really were)
03:54:06 <Cale> If the transaction throws an exception, none of its effects occur
03:54:41 <dulla> But I mean, between the non-coordinated calls
03:54:48 <Cale> If the transaction executes the primitive 'retry', then all the things that it read on the way to the retry are logged, and the thread sleeps until one of those is updated.
03:55:22 <dulla> ?
03:55:33 <Cale> I'm not sure what your question means exactly...
03:55:56 <Cale> (what's a coordinated call?)
03:57:01 <Cale> The only way to read or write the value of a TVar is to execute an STM transaction.
03:58:04 <funfunctor> yea can't get it to type check Cale
03:58:17 <Cale> funfunctor: um, I checked that my code typechecks
03:58:20 <funfunctor> why is this kind of thing so annoying..
03:58:34 <Cale> funfunctor: Are you confused about how to use it, or are you trying something different?
03:58:42 <funfunctor> Cale its not that, i'm sure its fine.. fitting it in with the rest is the problem..
03:58:54 <Cale> okay, so the idea is you pass in your parser for a single frame
03:59:06 * hackagebot yesod-bin 1.4.3.11 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.11 (MichaelSnoyman)
03:59:29 <Cale> and an IO action which tries to read a ByteString from the input (and returns Nothing on EOF)
04:00:03 <funfunctor> Cale not a problem there, just the input from BL.readFile and handling the unwrapping of the return value
04:00:31 <funfunctor> see paste
04:00:32 <Cale> do getFrame <- getStream parseFrame readChunk; v <- getFrame
04:01:25 <Cale> The result of executing getStream is itself an IO action which you'll use repeatedly to get one frame at a time
04:01:51 <Cale> and then the result of getFrame will be one of these Result ClientFrame values
04:02:12 <funfunctor> sorry what is in getFrame?
04:02:31 <funfunctor> i'm trying to do input <- BL.readFile "test.bin" there
04:03:23 <Cale> This is ultimately for network IO, right?
04:03:30 <funfunctor> actually I am very confused..
04:03:35 <Cale> You just want to use a file for testing?
04:03:39 <funfunctor> later it will be a serial port
04:03:43 <Cale> okay
04:03:43 <funfunctor> correct
04:03:56 <Cale> So, you'll want to openFile
04:04:38 <funfunctor> not just BL.readFile?
04:05:51 <Cale> Well... it's going to execute whatever action you pass repeatedly to get more input
04:06:47 <funfunctor> Cale I would like a action lazyIOClientFrames :: IO [ClientFrames] that opens the file does the parse rounds and gives me back an array of the frames it could extract
04:06:50 <Cale> and that action is supposed to return Nothing if there's no more input
04:07:26 <Cale> If you just want to read the whole file at once, there's no need for incremental parsing here
04:10:00 <funfunctor> Cale well thats just a test
04:10:05 <funfunctor> but its easier to try..
04:10:24 <Cale> Yeah, I tried to give you something which was closer to what you'd really end up needing
04:10:54 <funfunctor> I know thx, its just me not understanding how to fit it in to my thought process
04:10:55 <Cale> So, if you want to use it with file I/O, you want to openFile and then use hGetNonBlocking or something to read bits of the file from the handle
04:11:58 <Cale> Something like  do eof <- hIsEOF hdl; if eof then return Nothing else fmap Just (hGetNonBlocking hdl 20)
04:12:27 <Cale> Where that number 20 is arbitrary
04:12:40 <Cale> (probably 20 is a bad choice :)
04:13:44 <Cale> hGetSome is also a possibility
04:23:01 <funfunctor> Cale alright now I am close.. how to unwrap the result?     Expected type: String Actual type: IO (Result ClientFrame)
04:23:41 <funfunctor> I have something like, main  = do; frames <- getStream getClientFrame lazyIOClientFrames; putStrLn frames
04:23:47 <Cale> first of all, execute the action to get one result
04:24:10 <Cale> frames :: IO (Result ClientFrame)
04:24:10 <funfunctor> I thought frames <- getStream getClientFrame lazyIOClientFrames   should do that?
04:24:16 <funfunctor> ok
04:24:33 <Cale> so you probably actually want to call it getOneFrame or something
04:24:53 <Cale> getOneFrame <- getStream getClientFrame lazyIOClientFrames
04:24:55 <Cale> and then
04:25:01 <Cale> result <- getOneFrame
04:25:03 <Cale> case result of
04:25:15 <Cale>   Value cf -> ...
04:25:25 <Cale> etc.
04:30:59 <funfunctor> Cale ok I have the program doing what it did before, i.e. can grab one frame
04:31:10 <funfunctor> but how to build an array of them..
04:31:42 <lpaste> funfunctor pasted âNo titleâ at http://lpaste.net/121373
04:32:38 <funfunctor> Cale ^ frame should ideally be IO [ClientFrame]
04:33:36 <Cale> funfunctor: execute getOneFrame a bunch of times in a loop
04:35:01 <phaul> I'm playing with Control.Lens.Plated (or uniplate if you prefer) on the usual example AST, simple arithmetics, immediates, and variables. It's all very good if you want to write simple rewrite rules, like (Plus (Imm 0) (Imm1)) -> (Imm 1). I can't find an elegant solution to rewrite associative rules :( putting immediates in the same expression so they can be simplified. It seems the logic just explodes...
04:35:11 <funfunctor> Cale I didn't even know Haskell had loops!?
04:35:19 <funfunctor> I thought everything is recursion
04:35:28 <phaul> ^^ Is anyone aware of a working + and neat solution?
04:36:03 <Cale> funfunctor: Same thing
04:37:42 <funfunctor> Cale: yea not sure how to make frame into a recursion, what should the type signature look like?
04:40:15 <Cale> funfunctor: btw, you should also match the other constructors there
04:40:37 <Phyx-> Hi, having some trouble with the -C flag, just ghc -C file.hs returns ghc.exe: cannot compile this file to desired target: file.hs . Do I need something else?
04:40:40 <Cale> funfunctor: You could do something with the cf in result and then just apply frame again
04:42:08 <funfunctor> Cale yea I figured the base condition would be Finished
04:44:09 <Cale> funfunctor: Yeah, in the case that the result is Finished, you probably won't loop
04:45:05 <Cale> funfunctor: Note that what you're calling frame there could execute itself to continue, and it can be IO () instead of IO ClientFrame
04:45:24 <Cale> (or perhaps produce some other sort of result based on what it does with the frames)
04:50:51 <thevishy> will sudo dd if=/dev/sdb of=/dev/sda bs=8M && sync work to install a usb os to hdd
04:51:13 <thevishy> sorry wrong channel
04:51:49 <phaul> maybe I show you my code so it's more obvious what I mean: http://lpaste.net/121374.
04:52:03 <funfunctor> Cale if frame :: IO () calls itself how will it store the previous result? IORef ?
04:52:17 <funfunctor> Cale, this API seems way to complicated to do this..
04:53:57 <Phyx-> *sigh*
04:54:05 <Cale> funfunctor: What do you want to do with the ClientFrames?
04:54:24 <funfunctor> Cale I want an array of them
04:54:31 <Cale> funfunctor: I'm assuming you want to do something after obtaining each one
04:54:44 <Cale> funfunctor: because you went to the trouble of talking about incremental parsing in the first place
04:54:51 <Cale> instead of just waiting for the end of input
04:55:21 <funfunctor> each frame contains new data (but all the same format)
04:55:39 <funfunctor> | reading 1 | reading 2 | ..
04:55:56 <funfunctor> any way, I am looking for :: IO ClientFrame
04:55:59 <funfunctor> woops
04:56:08 <funfunctor> :: IO [ClientFrame] rather
04:56:42 <funfunctor> sorry, never done stream parsing in haskell till now
04:56:43 <i_am_neuron> Hi folks, I'm modelling a graph in Haskell and came up with those types: http://lpaste.net/121375. I don't need values on edges, so I tried avoiding introducing a type parameter to type Edge, but this doesn't compile. All I want is to say something like "edge is something linking two vertices with data of the same type". Is there a way to do this?
05:00:17 <i_am_neuron> If I do introduce a type variable on Edge (like "Edge a"), I always need to give a value when constructing an edge and this is not what I want
05:01:02 <adamse> i_am_neuron: you don't need to give the value when constructing an edge, only when writing the type, but GHC can infer it for you as well
05:01:06 <rasen> Add type parameter to edge type
05:01:27 <rasen> data Edge a = Edge (Vertex a) (Vertex a) deriving Show
05:02:16 <rasen> In case you want not give value in some cases, make it ()
05:02:44 <rasen> If value is optional, use Maybe
05:03:44 <i_am_neuron> adamse: Oh, that's true, sorry, stupid me
05:04:06 <i_am_neuron> Thanks
05:07:30 <adamse> i_am_neuron: also, have you tried a type like data Vertex a = Vertex a [Vertex a], your type requires putting the same vertex in many places which seems strange to me
05:08:56 <dis-pyon-tinuous> Just wondering... In the FMA proposal, is Alternative made a base class for MonadPlus, or is it possible for Alternative and MonadPlus to disagree?
05:09:48 <i_am_neuron> adamse: What do you mean in many places? I have imperative programming background, so I thought of a set of functions like: mkGraph, mkVertex, addVertex :: Graph -> Vertex -> Vertex, addEdge :: Graph -> Vertex -> Vertex -> Graph
05:09:55 <i_am_neuron> adamse: does this look wrong to you?
05:10:21 <dis-pyon-tinuous> FAM* proposal
05:10:24 <i_am_neuron> adamse: it should be addVertex :: Graph -> Vertex -> Graph
05:14:49 <adamse> i_am_neuron: how does you Graph type look?
05:18:14 <gfixler> is there a way to reduce the redundancy in this? http://lpaste.net/121377
05:18:56 <gfixler> e.g. with a list like: [("CM",900),("CD",400),etc...]
05:19:23 <i_am_neuron> adamse: data Graph a = Graph [Vertex a]
05:19:36 <KaneTW> not that i can think of
05:19:39 <immiNewHaskeller> hi .. umm new user , first time on irc , have a doubt
05:20:22 <adamse> dis-pyon-tinuous: from the latest base in GHC head: `class (Alternative m, Monad m) => MonadPlus m where`
05:21:49 <Axman6> immiNewHaskeller: well we can't help you with your doubt if you don't tell us what it is =)
05:21:51 <bergmark> gfixler: you could for instance use a hashmap
05:22:11 <immiNewHaskeller> watching Eric Meijer's c9 lecturers , in that he talks about list comprehensions as similar to nested loops , so apart from the concise way of writing , are we getting any performance benefits
05:22:28 <immiNewHaskeller> sure axman6 .. was just typing :)
05:22:41 <dis-pyon-tinuous> adamse: Nice. Thanks!
05:23:03 <Axman6> gfixler: looks pretty clear to me, nice work
05:23:24 <adamse> dis-pyon-tinuous: http://haskell.inf.elte.hu/docs/7.11.20141223.noWin32/html/libraries/base-4.8.0.0/
05:23:35 <dis-pyon-tinuous> Checking.
05:23:36 <Axman6> gfixler: I might add a case for the unhandled non-empty/non-roman-numeral string
05:24:10 <immiNewHaskeller> i mean , run time complexity of both imperative loops and list comprehension of 2 independent generators would be both n^2  , am i thinking right ?
05:24:26 <Axman6> immiNewHaskeller: yep
05:24:32 <dis-pyon-tinuous> Wait, now Functor is defined in Control.Monad?
05:24:49 <Axman6> immiNewHaskeller: but list comprehensions do benefit from laziness, so if you don't need all outputs it's a bit easier to deal with
05:25:22 <Axman6> > take 10 [(x,y) | x <- [1..], y <- [z--x]]
05:25:23 <lambdabot>  <hint>:1:42:
05:25:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:25:28 <Axman6> > take 10 [(x,y) | x <- [1..], y <- [1..x]]
05:25:30 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4)]
05:25:33 <adamse> dis-pyon-tinuous: the module hierarchy is a bit strange due to history, perhaps that is not new
05:25:38 <dis-pyon-tinuous> I see "class Functor f where" in both Data.Functor and Control.Monad -- is it possible to define the same type class in two places?
05:25:43 <Axman6> > take 10 . drop 100 $[(x,y) | x <- [1..], y <- [1..x]]
05:25:45 <lambdabot>  [(14,10),(14,11),(14,12),(14,13),(14,14),(15,1),(15,2),(15,3),(15,4),(15,5)]
05:25:55 <immiNewHaskeller> i get your point axman6 , thank you :)
05:26:12 <bergmark> dis-pyon-tinuous: check :i Functor in ghci to see where it originates from, several modules can reexport the same thing
05:26:35 <dis-pyon-tinuous> bergmark: Ah.
05:26:44 <adamse> dis-pyon-tinuous: or click th source link in the haddocks
05:26:52 <dis-pyon-tinuous> It's just that the Haddock documentation doesn't make it obvious that the Functor in Control.Monad is a reexport.
05:27:03 <adamse> it will take you to GHC.Base in the Functor case
05:27:13 <i_am_neuron> adamse: does the Graph type look wrong to you?
05:27:25 <bergmark> dis-pyon-tinuous: yeah that's a bit confusing
05:27:27 <i_am_neuron> adamse: it was data Graph a = Graph [Vertex a]
05:27:48 <adamse> i_am_neuron: no that looks reasonable, but the encoding of a graph you should use will depend on what operations you want to support
05:28:45 <i_am_neuron> adamse: I'll need a convenient BFS, that's all. That graph supposed to emulate electric circuits
05:29:13 <adamse> have you tried writing the addVertex, addEdge, .., functions?
05:29:48 <i_am_neuron> adamse: Yes, in progress right now :)
05:30:18 <adamse> i_am_neuron: well if it works out then all is well
05:30:26 <i_am_neuron> adamse: Great
05:31:34 <gfixler> bergmark: hadn't thought of maps
05:31:51 <gfixler> Axman6: good thinking on the non-roman case
05:43:51 <danilo2> Hello! What is the name of a library in hasell which allows me to construct "composable datatypes" - a datatype that could be composed out of others oin runtinme ?
05:45:17 <funfunctor> Cale: still about?
05:46:32 <peddie> danilo2: you could use (,) and Either to put things together with products and sums . . .
05:46:48 <peddie> danilo2: you could check out "data types a la carte" for some ideas; no idea whether what you're describing exists, though . . .
05:47:56 <Cale> funfunctor: yep
05:47:58 <danilo2> peddie: Ah, I was looking for the HList (rocords) functionality!
05:48:10 <adamse> danilo2: also http://hackage.haskell.org/package/generics-sop
05:48:17 <adamse> might be interesting
05:49:25 <danilo2> adamse: It is! Very interesting! thanks for the link!
05:49:38 <peddie> adamse: wow, that's neat
05:52:39 <adamse> danilo2: there is also http://hackage.haskell.org/package/vinyl which might be relevant
05:53:53 <funfunctor> Cale what to do here http://lpaste.net/121378
05:54:40 <danilo2> adamse, peddie: Yeh, but I just realised I need something else. I need a way to extend types with nwe constructors. so I want to define a type like HType '[A, B] and be able to pattern match on A and B and I want ot be able to limit it to HType '[A] or Extend to HType '[A,B,C]. In fact I've laready written it, but I'm looking for something ready. If there is no such functionality I'll push it tpo the hackage
05:54:55 <peddie> danilo2: cool, nice job
05:55:25 <danilo2> peddie: The question is, if somethink like tharo t exist. I hate when hackage get blowns with the same functionlaity across diferent packages, you know
05:55:58 <adamse> danilo2: I think vinyl pretty much does that
05:56:27 <danilo2> adamse: hmm, that's interesting. Iwas looking at it, but I cannot find exactly this one. Could you give me any hint ?
05:57:37 <danilo2> adamse: In the vinyl tutorial (https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs) we can see something very ismilar, but on the begin ning wre define all possible "constructors" and I do not want to have this restriction. In fact my implementation does not have it
05:58:29 <funfunctor> Cale i can only think of this but it looks shitty http://lpaste.net/121378
05:59:08 <danilo2> adamse: sorry for the typos in my message. I was typing too fast :D
06:01:31 <adamse> danilo2: I have actually never used vinyl, thus I cannot answer you question :)
06:02:27 <danilo2> adamse: sure! By the way - is here anybody that has used vinyl and could anwer the question if we are able to not only limit the possible "constructors" but also extend them?
06:06:20 <funfunctor> Cale woops, sorry, look again http://lpaste.net/121378 also I have the issue there *** Exception: foo.bin: openFile: resource exhausted (Too many open files)
06:07:28 <Cale> funfunctor: That sounds like you're opening lots of files
06:07:40 <Cale> funfunctor: Where are you calling openFile?
06:07:48 <funfunctor> Cale due to the recursive call
06:08:00 <Cale> uhh, you're not even calling openFile in the paste
06:08:10 <Cale> but also you're meant to call getStream only once
06:08:22 <Cale> you use the result of getStream repeatedly to get more elements
06:08:44 <Cale> It builds for you an IO action that will (attempt to) get the next ClientFrame
06:08:47 <dfeuer> Are EitherT and ExceptT basically the same?
06:08:56 <funfunctor> ok, how can I clean up having two frame actions into one also Cale?
06:10:58 <Cale> That code doesn't look like it uses getStream correctly at all
06:11:06 <Cale> You need to call getStream once, from main
06:11:31 <Cale> and the actions you pass into it also need to not open files
06:11:48 <Cale> so you'll have to open the file beforehand
06:12:19 <Cale> and then you'll get an IO action from getStream which you can execute repeatedly to get successive frames
06:15:04 <funfunctor> Cale that does not match what you were doing before
06:16:27 <funfunctor> (11:23:10 PM) Cale: getOneFrame <- getStream getClientFrame lazyIOClientFrames
06:16:28 <funfunctor> (11:23:13 PM) Cale: and then
06:16:28 <funfunctor> (11:23:18 PM) Cale: result <- getOneFrame
06:17:19 <funfunctor> really feel like giving up, this API feels horrible for this.. way too complicated to handle a stream
06:23:09 <EvanR> heh
06:24:01 <EvanR> threadDelay (maxBound `div` 2)
06:24:06 <EvanR> core: select: Invalid argument
06:25:27 <gregnwosu> hello can i use ghc 7.10 with cabal 1.20?
06:26:02 <brycelane> With the binary package, is there a way to fail with an error? `failG` looks like what I want, but its private.
06:43:45 <danilo2> Hello! Is there a way in haskell to make type-level set of types? I mean, I've got a type Foo '[A,B] and I want it to be equal to Foo '[B,A]
06:44:14 <danilo2> I'm looking for a way to ... order types in type level list or sometihng like that. Could be by theitr names for example
06:44:14 * hackagebot file-embed 0.0.8.2 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.8.2 (MichaelSnoyman)
06:45:07 <EvanR> danilo2: by the name, well theres Typeable
06:45:26 <danilo2> EvanR: yep, but I want to do it on the type-level
06:45:35 <EvanR> good luck ;)
06:45:54 <danilo2> EvanR: :D
06:45:54 <zipper> How can I print the Bool from a type of --> HandlerT site IO Bool
06:46:23 <EvanR> print <$> runHandlerT
06:46:48 <EvanR> hm. print =<< runHandlerT
06:47:14 <zipper> EvanR: runHandlerT is a function?
06:47:20 <EvanR> dunno
06:47:45 <exio4> danilo2: using a close type family sounds like the easier way to do that
06:47:51 <EvanR> zipper: whatever function looks like :: HandlerT x m a -> m a
06:47:53 <funfunctor> is there a simple way to turn a data Foo = Foo { this :: !Word16, that :: !Word8, ... } into [Word8] for passing into my crc16 function?
06:48:56 <EvanR> funfunctor: yeah, [(a .&. 0xf0) `shiftR` 8, a .&. 0x0f, b]
06:49:33 <EvanR> funfunctor: or if Foo has a binary instance
06:49:40 <danilo2> exio4: I dont want to limit to a set of types here. If I'm understanding your idea, it is limited to predefined set of type, isnt it ?
06:51:08 <danilo2> I've got one additional question regarding GHC.TypeLits. Why someSymbolVal returns SomeSymbol while someNatVal returns  Maybe SomeNat ? I understand the signature of someNatVal because it could or not be ocnverted to type-level int, but what is wrong with the first one ?
06:51:15 <funfunctor> EvanR: binary instance, hmm?
06:51:21 <EvanR> Binary
06:51:21 <funfunctor> sounds very interesting!
06:51:33 <funfunctor> just reading http://stackoverflow.com/questions/11905826/haskell-data-binary-example
06:52:03 <exio4> danilo2: no, I mean definining a closed type family "InSet" and another one (using that) "EquSet"
06:54:52 <danilo2> exio4: That doesnt solve my probvlem I think. I want the types Foo (Set '[A,B]) be equal to Foo (Set '[B,A]), so I want to create some kind of automatic ordering of elements. Does it make sense?
06:55:35 <EvanR> Set == sort ;)
06:55:45 <funfunctor> EvanR: Constructor `ClientFrame' should have 29 arguments how to make things short hand?
06:55:47 <danilo2> EvanR: yep, but type level one
06:55:56 <funfunctor> the instance is going to be big right?
06:55:57 <EvanR> funfunctor: what?
06:55:59 <danilo2> EvanR: Are we able to somehow sort type-level Symbols?
06:56:25 <danilo2> Because I'm free to define a type family , which will return me name of a datatype. I need to sort it out somehow
06:56:30 <funfunctor> EvanR: how would you serialise my example but with 29 fields?
06:57:40 <danilo2> OH! I KNOW! I can automatically encode Symbols as type-level list of Nat's and then compare them one by one! :D This is hacky :D
06:57:52 <EvanR> funfunctor: Binary instances tend to be quite big and tedious because the monadic language to describe the layout is very clean. so you write about 29 words
06:57:56 <exio4> danilo2: I don't know of any "automatic ordering", more than using type level functions for managing the type level "data structure"
06:58:10 <danilo2> exio4: ^^^
06:58:24 <EvanR> funfunctor: so you often auto generate this instance. i suggested it only because i thought it might be already made for you
06:58:50 <funfunctor> EvanR: ah no, I am learning how to parse binary data at the moment..
06:59:20 <EvanR> funfunctor: Binary isnt really for parsing binary data, its for serializing haskell data. it just happens that your example record looked very obviously binary
06:59:52 <exio4> danilo2: why are you doing this btw? you may find Idris or some "fancier" language nicer to play with :P
07:00:08 <EvanR> if you figure out how to make a set of types in idris let me know ;)
07:00:38 <danilo2> exio4: I cannot change the language right now and I need this in haskell. I'm creating a library which allows very nice way to add and remove constructors from datatypes (all type-lvel checked)
07:01:22 <funfunctor> EvanR: yep I managed to parse the binary data but now I have it in a record I want to compute a crc16 on it
07:01:49 <EvanR> funfunctor: wait, you *had* it in binary before?
07:02:00 <EvanR> or is this a different binary format than what it was
07:02:21 <EvanR> because its silly to write code to undo the parsing if you can just save the original
07:02:33 <funfunctor> EvanR: well I need to compute the crc of the data portion of the frame
07:03:45 <funfunctor> EvanR: so technically its a subset of the record but I figured it would be easier to try and compute the crc of the whole record first
07:03:59 <EvanR> ok. well look at the Put monad
07:04:27 <EvanR> write a Put monad program which serializes the data portion
07:04:40 <EvanR> then use runPut :: Put -> ByteString
07:07:07 <nshepperd> danilo2: isn't that just because negative numbers can't be converted into a Nat?
07:08:01 <danilo2> nshepperd: right! that makes sense! thanks!
07:10:10 <EvanR> is theres a package to equip parsec with a parser for doubles
07:19:30 <sgronblo> Are higher order types the same thing as higher kinded types?
07:20:53 <bergmark> i think so...
07:24:15 <tnks> also, people play games with how high "higher" is, I think.
07:25:52 <tnks> like whether to include (* -> *) as a "higher kind"
07:29:16 * hackagebot satchmo 2.9.0 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.0 (JohannesWaldmann)
07:29:30 <nshepperd> things that eventually produce a * are easier to understand I guess
07:30:50 <tnks> I guess I liken it to the debate about whether to include 0 in natural numbers.
07:31:01 <Geraldus> hey folks!
07:32:06 <Geraldus> Having troubles with haskell-mode in Emacs after recent upgrade from MELPA. error in process filter: Invalid function: ghc-with-current-buffer
07:32:29 <Geraldus> Can some one help? Maybe I should recompile or rebuild something?
07:34:17 * hackagebot tasty-silver 3.0.2.0 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0.2.0 (PhilippHausmann)
07:34:35 <meditans> hi, how could one write an `Arbitrary` (in the QuickCheck sense) instance for `fgl` graphs?
07:35:13 <meditans> eg. for the `Gr` type exported in Data.Graph.Inductive.PatriciaTree? (The constructors are hidden)
07:36:34 <Clint> meditans: mkGraph `liftM` arbitrary?
07:36:58 <Clint> well, no, you need to adjust for two arguments
07:37:40 <bergey> meditans: An Arbitrary instance for LNode looks easy.  I'd make an function that takes a list of LNodes, and a length, and returns a list of LEdges of the given length, using the given LNodes.
07:37:57 <bergey> Then putting those together with mkGraph is easy.
07:39:17 * hackagebot tasty-silver 3.0.2.1 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0.2.1 (PhilippHausmann)
07:39:31 <meditans> Clint: bergey: right, thanks :) I don't know why I expected it to be more difficult.
07:39:34 <bergey> I think QuickCheck has a way to use functions with a length argument, so it can test them on small and increasing lengths.
07:40:50 <meditans> I was trying to build up the instance from the concrete implementation, not realizing it's not necessary.
07:40:52 <zipper> WTF are there no non trivial projects using Yesod that are open on github?
07:40:57 <zipper> This seriously sucks
07:44:17 * hackagebot al 0.1.0.2 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.0.2 (DimitriSabadie)
07:49:13 * EvanR programs a dang <$> and <*> combo into vim
07:49:23 <EvanR> they are going to be the death of me
07:49:25 <bernalex> n.
07:49:30 <bernalex> ops.
07:49:39 <EvanR> n.
07:49:43 <EvanR> hmm
07:49:55 <hexagoxel> what synchronization construct can i use to achieve some "after 3 seconds of user input inactivity, do ..."? i can think of a low-level solution, but something like a read-MVar-with-timeout seems preferable (but does not exist, does it?)
07:50:14 <EvanR> hexagoxel: see the timeout package
07:50:21 <EvanR> System.Timeout
07:51:23 <hexagoxel> EvanR: i considered System.Timeout, but it seems wrong/not elegant for the purpose
07:51:52 <EvanR> im not sure about "n seconds of  user inactivity" but you can use it to make a "read mvar with timeout"
07:51:59 <EvanR> and hide the implementation
07:52:48 <stelleg> is it possible to hide instances from an import
07:52:49 <stelleg> ?
07:52:49 <EvanR> you can also implement such a thing without a timeout, by creating another thread
07:53:54 <Cale> You can also use the race function from the async package to implement timeouts nicely
07:54:07 <rpr> I asked this earlier today
07:54:15 <rpr> there's a timeout function in Control.Timeout
07:54:17 <rpr> :t timeout
07:54:19 <lambdabot> Not in scope: âtimeoutâ
07:54:22 <rpr> @hoogle timeout
07:54:24 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
07:54:24 <lambdabot> package timeout-control
07:54:24 <lambdabot> package timeout-with-results
07:54:26 <Cale> stelleg: no, instances are infectious
07:54:33 <hexagoxel> EvanR: but i'd like to avoid creating a thread for each user activity. the "timed-mvar-read using timeout" idea is nice though, thanks
07:54:51 <hexagoxel> zipper: what is non-trivial?
07:54:52 <EvanR> threads are nice and cheap
07:54:55 <stelleg> Cale: yeah looks like it :(
07:55:04 <Cale> stelleg: this is somewhat by design, it creates some problems and removes others.
07:55:05 <zipper> hexagoxel: Anything
07:55:21 <stelleg> how about a constraint that a type variable is not a certain type?
07:55:26 <EvanR> and user activity has the tendency to be relatively low frequency relative to typical computer activity
07:55:28 <zipper> hexagoxel: Anything with an auth systen
07:55:29 <Cale> stelleg: It's why we usually try to avoid instances which occur in modules where neither the class nor the data type involved are defined
07:55:34 <zipper> *system
07:55:39 <zipper> hexagoxel: With tests
07:55:40 <stelleg> e.g. something like (A !~ Char)
07:55:59 <Cale> stelleg: Nope, that's also not doable.
07:56:10 <hexagoxel> zipper: i have not looked at the source much, but https://github.com/bholst/blog
07:56:21 <stelleg> poop
07:56:28 <Cale> stelleg: What are you trying to accomplish?
07:56:52 <hexagoxel> zipper: i see a login button and a tests folder in the source tree :D
07:57:23 <stelleg> Cale: using text-format, theres an instance of Buildable String, which I understand the utility of, but I was hoping to add an instance Buildable a => Buildable [a]
07:57:28 <meditans> which are the drawbacks of the TypeSynonymInstances, if any?
07:57:33 <rpr> is there a findM :: Mond m =>  (a -> m Bool) -> [a] -> m (Maybe a) ?
07:57:36 <zipper> hexagoxel: I was hoping for something that uses HashDB
07:57:55 <zipper> hexagoxel: I will look for the BrowserId tests in the source tree
07:59:25 <EvanR> need a space cadet / apl keyboard with <$> keys, <*> keys, etc :P
08:00:20 <gfixler> EvanR: I've just been using https://github.com/kana/vim-arpeggio for that kind of thing
08:00:46 <gfixler> set up arpeggios for haskell files only
08:00:48 <carter> Axman6: dulla  the core is done, i'm just navigating making sure my current employer knows the code is mine before shipping :)
08:01:00 <carter> Axman6: dulla #numerical-haskell is a great channel for haskell+ numerical computing
08:01:22 <stelleg> Cale: not a big deal, easy to get around with just slightly less convenience
08:01:28 <EvanR> gfixler: that is cool, you can also make it so something happens when you press a sequence of keys quickly enough
08:01:31 <carter> err, i meant dashetermaybe?
08:01:34 <EvanR> like street fighter combos
08:02:18 <gfixler> EvanR: yeah, e.g. Arpeggionnoremap fli O{-# LANGUAGE FlexibleInstances #-}
08:02:24 <EvanR> haha
08:02:26 <rpr> findM pred xs = headMay `liftM` filterM pred xs
08:02:36 <Cale> stelleg: Yeah, that's awkward that there would be an instance for String and not just for lists.
08:03:33 <stelleg> Cale: yeah, but it's Bos so I'm guessing theres a decent reason for it :)
08:06:59 <gfixler> EvanR: I've been heading more and more toward the idea of Plover (open source steno program)
08:07:27 <gfixler> arpeggio doesn't care in which order you press the keys in its mappings, so you just hit them all roughly together
08:07:49 <EvanR> i cant imagine that working with any combination of keys
08:07:57 <gfixler> it also gets around the pesky n-key rollover issue
08:07:59 <EvanR> because keyboard mechanics
08:08:16 <gfixler> it's worked with everything I've thrown at it
08:08:31 <gfixler> plover won't work with my keyboard, because it's not nkro
08:08:38 <gfixler> but arpeggio works with any combo I've tried
08:09:10 <gfixler> it's reading them in sequence, and all just have to be within some tiny window of time
08:09:59 <EvanR> quick, whats (const f) <$> x
08:10:11 <gfixler> f x?
08:10:34 <EvanR> hmm
08:10:55 <exio4> EvanR: <$?
08:11:01 <EvanR> :t (<$)
08:11:02 <lambdabot> Functor f => a -> f b -> f a
08:11:14 <EvanR> yurp
08:11:17 <exio4> @type \x y -> (const x) <$> y
08:11:18 <lambdabot> Functor f => b -> f a -> f b
08:12:38 <gfixler> what is <$? is that lefmap?
08:16:54 <EvanR> glguy: how about keycombos to remap keys ;)
08:17:16 <EvanR> gfixler:
08:17:56 <exio4> gfixler: do { x ; return y } ~ (y <$ x)
08:18:18 <jmcarthur> @src (<$)
08:18:18 <lambdabot> (<$) = (<$>) . const
08:18:21 <jmcarthur> gfixler: ^^
08:18:37 <jmcarthur> that is not so beginner-friendly though... :(
08:18:52 <exio4> \x y -> fmap (const x) y
08:19:07 <jmcarthur> x <$ a = fmap (\_ -> x) a
08:34:20 * hackagebot hunt-server 0.3.0.2 - A search and indexing engine server.  http://hackage.haskell.org/package/hunt-server-0.3.0.2 (alexbiehl)
08:41:31 <gfixler> EvanR: I've played with that at times, e.g. to remap the keys to other layouts
08:43:21 <gfixler> jmcarthur: I actually find the type and a couple of examples to be much more illustrative
08:43:28 <gfixler> :t (<$)
08:43:28 <lambdabot> Functor f => a -> f b -> f a
08:43:34 <gfixler> 3 <$ [4]
08:43:41 <gfixler> 3 <$ Just 4
08:43:48 <gfixler> > 3 <$ [4]
08:43:50 <lambdabot>  [3]
08:43:52 <gfixler> > 3 <$ Just 4
08:43:54 <lambdabot>  Just 3
08:44:13 <gfixler> it's like a way of shoving a new value on the left into the functor on the right
08:47:43 <JoshieAS> the best way to negate or "flip" a negative number to positive? is it "-"?
08:47:53 <EvanR> :t negate
08:47:53 <lambdabot> Num a => a -> a
08:48:19 <EvanR> what it does to positive numbers though, not sure
08:48:30 <EvanR> YMMV
08:48:30 <gfixler> it makes them negative
08:48:37 <JoshieAS> noiceeee
08:49:14 <exio4> > -(2+2)
08:49:15 <lambdabot>  -4
08:49:34 <gfixler> let negatize = negate . abs
08:49:56 <EvanR> actually, negate should not be construed to imply a positive negative characteristic of Nums, see Complex
08:50:01 <exio4> > -(-4)
08:50:03 <lambdabot>  4
08:50:20 <EvanR> signum however
08:50:59 <JoshieAS> I'm getting a 'No instance for (Show (Int -> [a0]))..' for its use in this line: ((drop((length l) - negate(x)) l) ++ (take((length l) - negate(x)) l))
08:52:08 <gfixler> JoshieAS: what are you trying to do?
08:54:54 <thebnq> JoshieAS: the error is saying you're trying to 'show' (maybe in ghci?) a function (Int -> [a0])
08:55:06 <thebnq> so maybe give it an int too
08:55:12 <gfixler> > let l = [1,2,3,4,5]; x = (-2) in ((drop ((length l) - negate(x)) l) ++ (take ((length l) - negate(x)) l))
08:55:14 <lambdabot>  [4,5,1,2,3]
08:55:17 <gfixler> it works for me
08:58:28 <gfixler> let l = [1,2,3,4,5]; x = (-2) in drop n l ++ take n l where n = length l - negate x
08:58:30 <gfixler> > let l = [1,2,3,4,5]; x = (-2) in drop n l ++ take n l where n = length l - negate x
08:58:32 <lambdabot>  <hint>:1:55: parse error on input âwhereâ
08:58:49 <gfixler> > let l = [1,2,3,4,5]; x = (-2) in (drop n l ++ take n l) where n = length l - negate x
08:58:50 <lambdabot>  <hint>:1:57: parse error on input âwhereâ
08:58:57 <gfixler> > let l = [1,2,3,4,5]; x = (-2) in drop n l ++ take n l; where n = length l - negate x
08:58:58 <lambdabot>  <hint>:1:54: parse error on input â;â
08:59:04 <gfixler> how do I inline a where?
08:59:53 <JoshieAS> I'm doing it in ghci
09:00:15 <JoshieAS> gfixler: I have two clauses, one that handles a positive number and then that line that I gave you for negatives
09:00:17 <geekosaur> you don't, at least not that way. where scopes to a definition (the `l` or `x` in your attempt)
09:00:27 <JoshieAS> it 'rotates' the specified numbers in a list
09:00:37 <geekosaur> mixing let and where like that is weird anyway
09:01:01 <JoshieAS> negative shifts them left, positive right
09:01:18 <JoshieAS> the positives line works, but I get that error when I run a negative number
09:01:45 <gfixler> > let l = [1,2,3,4,5]; x = (-2); n = length l - negate x in drop n l ++ take n l
09:01:48 <lambdabot>  [4,5,1,2,3]
09:01:50 <gfixler> geekosaur: okay, that then
09:03:01 <thebnq> > let f = x where x = 3 in f
09:03:03 <lambdabot>  3
09:03:36 <gfixler> yeah, I didn't think it was all that weird
09:03:53 <thebnq> its a bit weird :p
09:03:56 <gfixler> :)
09:03:58 <nerium> I'm trying to create a simple monad calculator, but i'm getting an error, why is that?
09:03:59 <nerium> https://gist.github.com/oleander/8e48d29c3f296097bc5e
09:04:19 <geekosaur> I don't see why mixing a where at the end like that makes any sense. where is useful when scoping over multiple pattenrs/guards in a single definition
09:04:48 <JoshieAS> rue -> (drop((length l) - negate(x)) l) ++ (take((length l) - negate(x)) l)
09:04:54 <JoshieAS> I don't get why that's telling me I'm trying to show a function
09:04:55 <geekosaur> nerium, did you actually read the error message?
09:04:57 <gfixler> geekosaur: n is being used twice - I was using where to remove redundancy
09:05:00 <JoshieAS> negate(x) returns another Int
09:05:18 <nerium> geekosaur: Yes, and I*m not sure what i means
09:05:30 <geekosaur> nerium, GADTs (data Foo where) are not standard Haskell
09:05:40 <geekosaur> they're an extension. you must enable the extension to use it
09:06:00 <nerium> geekosaur: Aha, {-# LANGUAGE GADTs #-}
09:06:02 <nerium> Thanks!
09:06:24 <hiptobecubic> "For Haskell people, this is the same as (<$>) and (<*>) for applicative functors with the added benefit of not being extremely hideous.
09:06:30 <geekosaur> hm, that could stand to be improved. I think most of them reference -X at least
09:07:15 <hiptobecubic> I guess I see it, although I had never really thought of them as particularly hideous
09:07:22 <gfixler> hiptobecubic: sounds like elm docs
09:07:24 <geekosaur> maybe file an enhancement request against ghc that that message make more clear that "Use GADTs" refers to the language extension, perhaps by saying "Use -XGADTs" instead like some of the other extensiion-not-enabled errors
09:11:49 <Scriptonaut> can anyone tell me why on line 10 it's telling me couldn't match expected type [[a]] with actual type Int -> [[a0]]. https://gist.github.com/robins35/6afd3f53560d77e98ee3
09:12:50 <hiptobecubic> gfixler, yes
09:13:02 <hiptobecubic> gfixler, http://elm-lang.org/blog/announce/0.7.elm
09:13:33 <Scriptonaut> Here's the full lsit of errors, though the line numbers are shifted down 12 lines (22 -> 10, etc): https://gist.github.com/robins35/2388bb0f25f0b46c4ff4
09:14:20 <thebnq> Scriptonaut: it might be because you specify a in [Int] -> [[a]] but it also charlie
09:14:22 * hackagebot generic-xmlpickler 0.1.0.0 - Generic generation of HXT XmlPickler instances using GHC Generics.  http://hackage.haskell.org/package/generic-xmlpickler-0.1.0.0 (AdamBergmark)
09:14:23 <thebnq> Char*
09:14:46 <Scriptonaut> also in Char?
09:14:48 <Scriptonaut> where do I do that
09:15:36 <Scriptonaut> oh, because I hardcode l to be a char?
09:15:39 <int-e> Scriptonaut: please provide complete code; the code you provided produces a different error and typechecks after replacing the two [a] by String
09:15:42 <thebnq> yea
09:16:06 <monochrom> Scriptonaut: the error message says "getCombis :: [Int] -> Int -> [[a]] (bound at twentysix.hs:21:1)". your code says "getCombis :: [Int] -> [[a]]". why are they different? what did you, really, write?
09:16:19 <int-e> Scriptonaut: it doesn't have to be your code, but it should be code that can be loaded in ghci to reproduce the error.
09:16:50 <Scriptonaut> ah my bad, I just copied the part of the program that was breaking
09:16:57 <Scriptonaut> there was another function that wasn't being used
09:17:13 <Scriptonaut> anyways, that was the problem, it didn't like me saying it was an [[a]] when really it was a [String]
09:17:15 <hiptobecubic> I do like elm's approach to records though, at least on paper. I haven't played with them much
09:17:44 <gfixler> Scriptonaut: a good way to see what's going on in these situations is to remove your signatures
09:17:58 <gfixler> I did that for getCombis and combis, and it compiled
09:18:05 <gfixler> then I could :t each to see what haskell though they should be
09:18:17 <Scriptonaut> oh, that's a good trick
09:18:17 <gfixler> and it thought combis should be [Int] -> [Char]
09:18:23 <gfixler> sorry, combi
09:18:30 <Scriptonaut> thanks
09:24:22 * hackagebot satchmo 2.9.1 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.9.1 (JohannesWaldmann)
09:29:25 <JoshieAS> I figured out the problem -- I wasn't passing my negative number in ghci in parentheses
09:29:48 <JoshieAS> rotate [1,2,3,4,5,6] -2 when I should have been doing rotate [1,2,3,4,5,6] (-2)
09:30:28 <gfixler> parsing negative numbers is one of the hardest problems in computer science
09:32:29 <nerium> I'm trying to get this code to run, but I'm missing something
09:32:29 <nerium> https://gist.github.com/oleander/a8e70325541594370c8f
09:32:55 <nerium> Line 11 should be 17
09:33:38 <adamse> nerium: remove the a
09:33:46 <adamse> instance Monad Calculator where
09:34:28 * hackagebot tasty-silver 3.0.2.2 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0.2.2 (PhilippHausmann)
09:34:31 <nerium> adamse: That worked  thanks! What does the "a" do?
09:34:56 <Scriptonaut> anyone know why it's telling me the $ is redundant? http://lpaste.net/1737262035839746048
09:35:35 <bergmark> Scriptonaut: you can move the paren to the left to that position instead
09:35:39 <adamse> the a is the type parameter, the error message you got talks about kinds, which is like types of types, `Calculator a` has kind *, while `Calculator` has kind * -> *, meaning `Calculator` takes an argument of kind * and return a type of kind *
09:35:52 <supki> Scriptonaut: if you click on the warning it'll show the explanation
09:36:18 <bergmark> oh :-)
09:36:45 <Scriptonaut> ah, thanks
09:37:17 <nerium> adamse: Hmm Im getting the same error https://gist.github.com/oleander/2c6ae12e037059f88f41
09:38:57 <adamse> nerium: well now `Calculator` has kind * -> * -> *, meaning it takes 2 types and returns a type of kind *, Monad still wants a type of kind *->*, so in this case you need to give `Calculator a`
09:39:46 <adamse> but as you have rewritten Calculator I believe it will be impossible to write a law abiding Moand instance
09:40:35 <adamse> you'll probably need to switch the order of a and b in the type constructor
09:40:52 <nerium> adamse: On line 23?
09:41:20 <adamse> nerium: yes, the definition of the type
09:42:24 <nerium> adamse: How would i fix the * -> * problem?
09:42:55 <hiptobecubic> The notion of monoids as categories of a single object with arrows as monoid elements doesn't jive with intuition for me. I can see how it fits all the definitions, but what is the object? It kills me.
09:43:02 <hiptobecubic> Take integers and (+) for example
09:43:56 <adamse> nerium: which problem? that you give something of kind *->*->* instead of *->*?
09:43:57 <hiptobecubic> so 0, 1, 2... whatever are all elements of the monoid that can be (+)'d together to form new arrows. But what are we using these arrows for if not to go between objects?
09:44:34 <gfixler> hiptobecubic: what are you reading?
09:44:39 <miko__> pf: n x = sum $ zipWith (*) x x
09:44:44 <miko__> !l
09:45:31 <nerium> adamse: Yes
09:46:09 <adamse> nerium: as I said you need to give an argument to `Calculator`: instance Monad (Calculator b) where
09:46:19 <miko__> @pl  n x = sum $ zipWith (*) x x
09:46:19 <lambdabot> n = sum . join (zipWith (*))
09:47:54 <nerium> adamse: Could you provide an example? I tried a lot of things, but I can't get it to work
09:49:40 <miko__> @pf no x = map (flip (/) (n x)) x
09:49:41 <lambdabot> Maybe you meant: pl bf
09:49:49 <miko__> @pl no x = map (flip (/) (n x)) x
09:49:50 <lambdabot> no = map =<< flip (/) . n
09:51:03 <adamse> nerium: see the comment on the gist
09:51:40 <nerium> adamse: Thanks! I'll do some experimenting
09:53:24 <gfixler> hiptobecubic: are you talking about this? http://en.wikiversity.org/wiki/Introduction_to_Category_Theory/Monoids#Arrows
09:54:33 <miko__> @pl dot a b = sum $ zipWith (*) a b
09:54:33 <lambdabot> dot = (sum .) . zipWith (*)
09:55:03 <nerium> adamse: What's the purpose of "x"?
09:55:26 <hiptobecubic> gfixler, any one of the millions of places where they state that monoids are categories with a single object with arrows as the elements of the monoid. Today it's the 'cat theory for beginners' deck posted on /r/haskell http://www.slideshare.net/kenbot/category-theory-for-beginners
09:56:03 <meditans> I have a question about code organization in a cabal project
09:56:22 <Kron> > toList (1,1)
09:56:24 <lambdabot>  Not in scope: âtoListâ
09:56:24 <lambdabot>  Perhaps you meant one of these:
09:56:24 <lambdabot>    âF.toListâ (imported from Data.Foldable),
09:56:30 <Kron> > F.toList (1,1)
09:56:31 <lambdabot>  [1]
09:56:41 <meditans> I wrote an Orphan instance (for quickcheck's arbitrary) that I use extensively in my test suite but not in my code
09:57:14 <adamse> nerium: in your type you had an extra type parameter b, I called it x instead
09:57:34 <meditans> where should I put it? My first guess would be to put it into the test files, but then how can I import it in another test file?
09:58:19 <gfixler> meditans: put it in its own file and import that file into your tests?
09:58:36 <gregnwos`> poll: what tool do you use to refactor haskell?
09:59:10 <meditans> gfixler: but at that point my library depends from QuickCheck. Is this the recommended way?
09:59:39 <meditans> gfixler: up to this point, only the test suite depended from QuickCheck
09:59:48 <gfixler> meditans: I don't know, but it seemed the obvious, layer-of-indirection-based approach
10:00:34 <meditans> gfixler: it seems the easiest way, for sure. Thanks, I'll do this way.
10:03:26 <creichert> meditans: you can have other-modules: in a test-suite, would that help?
10:03:58 <creichert> e.g. other-module: TestLib (or whatever)
10:05:16 <creichert> you also might be able to newtype the orphan in that module to possibly avoid the warning, but i'm not sure in your specific case
10:09:44 <JoshieAS> I'm trying to solve a problem where you insert an element into a list -- my solution works for numbers but not charcters
10:10:27 <JoshieAS> insertAt e (x:xs) 1 = [e] ++ (x:xs) <---- This is my base case, but it when I run a string, it says it expects [[Char]] but I'm supplying [Char]
10:12:38 <dhinojosa> :quit
10:12:43 <dhinojosa> haha
10:13:07 <hiptobecubic> So if sums and products are dual, is there a term for the relationship between something like `nd` and `Right` ?
10:13:11 <hiptobecubic> `snd` *
10:14:16 <EvanR> i think we have a winner http://www.quadibloc.com/comp/images/enhpc.gif
10:14:53 <EvanR> http://segin-rr.blogspot.com/2010/06/discussion-on-keyboard-layouts.html
10:16:04 <breadmonster> So when I `cabal install package` and it has to compile stuff, is there any flag I can pass to get it to do that in parallel?
10:16:10 <heatsink> I notice there's a 'super' key and a 'hyper' key, but no 'ultra' key
10:16:14 <breadmonster> I'm on a quad core, I might as well make use of it.
10:16:17 <gregnwos`> hiptobecubic: they are isomorphic as long as they have the same algerbra as far as i am away
10:16:19 <breadmonster> heatsink: What's ultra/
10:16:41 <heatsink> What are super and hyper?
10:16:43 <rpr> how to comment a line in .hsc file?
10:17:17 <breadmonster> heatsink: Super is if I'm not mistaken the Win key.
10:17:17 <EvanR> super is a modifier key which is currently labeled with a windows logo
10:17:28 <heatsink> Oh, that
10:17:30 <gregnwos`> ,Right
10:17:35 <breadmonster> EvanR: I'm having some issues installing yesod. Could I show you the logs?
10:17:37 <EvanR> hyper is a long forgotten modifier but is reported in X nonetheless
10:17:52 <hiptobecubic> gregnwos`, I don't know enough at the moment to make a meaningful statement about any qualifiers. My question is based on the slides that were posted to /r/haskell and touted as "good" by some people that I believe to know what they are talking about. http://www.slideshare.net/kenbot/category-theory-for-beginners
10:17:54 <heatsink> rpr: I think hsc files are preprocessed with CPP, so C comment syntax should work
10:18:15 <kaidelong> @type state
10:18:17 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
10:18:46 <kaidelong> huhm
10:18:52 <kaidelong> how does that example on reddit work
10:20:05 <kaidelong> @type let strandom = state undefined in runState (do {x <- strandom; y <- strandom; return (x,y)})
10:20:07 <lambdabot> s -> ((t, t1), s)
10:20:21 <kaidelong> how does haskell figure out what m is
10:20:43 <kaidelong> I thought defaulting was completely non-extensible?
10:20:56 <gregnwos`> hiptobecubic: im studying category theory at the moment, im not sure about the algebra of functions, but at a guess.....
10:21:10 <kaidelong> @type state undefined
10:21:11 <lambdabot> MonadState s m => m a
10:21:12 <breadmonster> EvanR: http://lpaste.net/121386 Can you give me a hand?
10:21:39 <exio4> @type runState -- kaidelong
10:21:40 <lambdabot> State s a -> s -> (a, s)
10:21:57 <EvanR> breadmonster: youre having a network issue, or your package list needs to be updated
10:21:57 <kaidelong> oh runState is monomorphic
10:21:58 <kaidelong> I see
10:22:05 <breadmonster> EvanR: Okay, will do.
10:22:16 <kaidelong> of course it is
10:22:19 <gregnwos`> Right :: b -> Either a b , so I think it is b * a
10:22:20 <kaidelong> I'm dumb
10:23:09 <breadmonster> EvanR: You're the best, thanks!
10:23:25 <breadmonster> Also, is there a way I can compile in parallel?
10:23:30 <breadmonster> It just makes things much easier.
10:23:37 <gregnwos`> (a, b) -> b , so i think it is a * b
10:23:47 <gyaretto> On line 5, expected type [String] couldn't match actual type IO String and I'm not sure why. https://gist.github.com/garrettoreilly/4c02f3dc5d1735b559ef
10:24:21 <gregnwos`> actuall b -> Either a b , is probably a+ b
10:24:38 <lyxia> gyaretto: Did you mean to have getProgram :: IO [String]?
10:24:39 <breadmonster> gyaretto: Program is of type IO String
10:24:42 <gregnwos`> so i dont think they are isomorphic
10:24:44 <heatsink> gyaretto: getLine has type IO String, but it's used in a do-block that has type [String]
10:25:08 <kaidelong> well since program has to do IO
10:25:30 <heatsink> gyaretto: To agree with the do-block's type, that statement must have type [t] for some type t
10:25:33 <gyaretto> But shouldn't ln be of type String?
10:25:45 <kaidelong> you should defn rewrite "let program = getProgram" (which makes program the getProgram program) to "program <- getProgram" too (this runs the getProgram program and returns its result)
10:26:11 <kaidelong> getProgram also has to have type IO [String]
10:26:14 <breadmonster> gyaretto: liftM (intercalate "\n") program >>= putStrLn
10:26:23 <kaidelong> it's not a list of strings, it's a program that gets a list of strings
10:26:36 <gyaretto> Oh, ohkay.
10:27:19 <breadmonster> So when I make a sandbox, and install, say, yesod, does that tap on the packages I already have installed with ghc?
10:27:55 <kaidelong> breadmonster: AFAIK yes it does, even if it could install a newer version into the sandbox
10:27:57 <breadmonster> Say, yesod depends on some version of transformers. If I already have transformers installed with my ghc installation, will it still install transformers separately into the sandbox?
10:28:35 <kaidelong> iff the version of transformers installed globally is incompatible
10:28:38 <breadmonster> kaidelong: Okay cool.
10:29:15 <breadmonster> For some reason, yesod is refusing to install.
10:29:32 <kaidelong> yesod is difficult to install, if you're going to use it you should use stackage
10:29:44 <kaidelong> the same people behind stackage are behind yesod
10:29:50 <kaidelong> so they develop yesod with stackage in mind
10:30:16 <breadmonster> okay, no I think I got it.
10:30:25 <breadmonster> Had to figure out how to install monad-logger.
10:30:32 <breadmonster> Worked around that one...for now at least.
10:32:41 <breadmonster> kaidelong: It's really strange. cabal will often require me to specifically install some packages in a separate invocation.
10:34:23 <kaidelong> hackage can be hard to work with
10:34:41 <kaidelong> it seems like the in thing now is to install just a minimal installation of GHC and sandbox all the things
10:34:47 <kaidelong> (or use stackage)
10:39:32 * hackagebot hoodle-render 0.5.0 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.5.0 (IanWooKim)
10:39:34 * hackagebot hoodle-publish 0.2.0 - publish hoodle files as a static web site  http://hackage.haskell.org/package/hoodle-publish-0.2.0 (IanWooKim)
10:39:36 * hackagebot hoodle-core 0.15.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.15.0 (IanWooKim)
10:39:38 * hackagebot hoodle 0.4.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.4.0 (IanWooKim)
10:43:11 <meditans> creichert: yes! the other-modules in the test suite is a cleaner solution, thanks!
10:45:37 <meditans> what's the state of the art tool for time profiling?
10:46:50 <meditans> ie. I want my library to go faster, and I'm in search of a detailed tutorial on tools.
10:48:05 <meditans> (other than https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/profiling.html)
10:51:20 <meditans> example: what should I do if I don't have a `main` (being a library) but want to profile a function call?
10:54:15 <lucidmaybe> what is haskell
10:55:33 <h-core> lucidmaybe, it's a purely functional language which in short means that you tell them computer what you want rather than how you want it to do something
10:55:46 <h-core> *the
10:56:15 <lucidmaybe> does it have if then write out statements
10:56:49 <h-core> lucidmaybe, yes it has if then else
10:57:03 <h-core> and it can output results wherever you want
10:57:22 <lucidmaybe> can it make a chat server
10:58:10 <meditans> lucidmaybe: sure, take a look here https://wiki.haskell.org/Implement_a_chat_server
10:59:04 <JoshieAS> if I want to write a function that can take 1 OR 2 arguments, what's the best way to go about that?
10:59:23 <JoshieAS> like, if I want to build a range from x to y, I'd like to be able to just specify y so that it can assume x is 1
10:59:38 <ReinH> JoshieAS: Don't do that.
10:59:39 <JoshieAS> range 3 5 would be [3,4,5] and range 5 would be [1,2,3,4,5]
10:59:52 <ReinH> JoshieAS: There are two different functions for that in base
11:00:00 <JoshieAS> what do you mean?
11:00:15 <ReinH> vararg functions require a lot of type-level machinery and are not at all idiomatic Haskell
11:00:53 <ReinH> The number of arguments that a function takes is encoded in its type
11:01:06 <JoshieAS> so you're saying it's not worth it right now
11:01:08 <int-e> > id id id 1
11:01:08 <JoshieAS> ?
11:01:10 <lambdabot>  1
11:01:12 <ReinH> Yes.
11:01:27 <JoshieAS> Fair enough! Thasnk
11:02:34 <ReinH> (Technically, all functions take one argument)
11:03:01 <JoshieAS> They're all curried, right?
11:03:07 <ReinH> Right.
11:03:56 <JoshieAS> But you're saying if I define a function 'range' and declare its type ':: Int -> Int -> [Int]', that, even though range takes one function
11:04:10 <JoshieAS> my 'program' expects it to return a function that requires the expected type
11:04:16 <JoshieAS> as an input
11:04:16 <ReinH> We can still talk about what it takes to fully saturate that function
11:04:23 <ReinH> And it's different from range :: Int -> [Int]
11:04:49 <ReinH> base has enumFrom and enumFromTo, separate functions, for this
11:05:06 <JoshieAS> Gotcha, gotcha. I am understanding more and more.
11:05:13 <ReinH> "variadic" functions are used very infrequently, for things like printf
11:05:13 <JoshieAS> The shenaniganery involved in what I wanted to do.
11:05:24 <ReinH> I could make a good argument that doing so is a bad idea even in cases like printf
11:06:08 <hpc> sql packages use a list of some sum type
11:06:11 <ReinH> er, enumFrom and enumFromTo are not quite your two range functions, but they are somewhat analogous
11:06:27 <ReinH> JoshieAS: It's basically a subversion of the type system
11:06:34 <hpc> instead of (query "query" value value value), it's (query "query" [toValue value, toValue value, toValue value])
11:33:13 <passy> Hey! Is there a tool for automatically qualifying your import? I prefer avoiding wildcard imports, but when starting on a new file it's often more convenient to just do `import Control.Monad`.
11:33:52 <passy> Is there something that scans for your usages and can limit this to something like `import Control.Monad (join, forM_)
11:35:05 <Feuerbach> how do I fill the memory produced by alloca? is there a memset-like function somewhere in base?
11:36:00 <meditans> passy: if I understood correctly your problem, you kinda could do this with ghc-mod
11:36:41 <meditans> passy: is the problem that you want to write import Control.Monad, then code, and at the end generate something like
11:36:46 <passy> meditans: Oh, I didn't know it could do that.
11:36:56 <meditans> passy: import Control.Monad (join, forM_)?
11:37:17 <passy> meditans: Yes, precisely.
11:37:36 <meditans> passy: ok, so do so: write import Control.Monad, then code
11:37:51 <meditans> when you are done, and the program has no errors
11:37:59 <meditans> change the import in import Control.Monad ()
11:38:20 <meditans> in this way all the functions from Control.Monad you're using will error out
11:38:43 <meditans> then jump in turn on every error with ghc-next-error, or something
11:38:49 <passy> meditans: Ah yes, that's pretty much what I do at the moment. I was hoping that someone might have already written something that automates that. :)
11:38:50 <meditans> (these are ghc-mod functions in emacs)
11:39:28 <meditans> passy: yes, but if you do `M-t` on the error, it adds the import by it own
11:39:30 <enthropy> ghc has a -ddump-minimal-imports
11:40:00 <meditans> passy: and than you run on the snippets in the import the function ghc-sort-lines
11:40:11 <passy> @meditans That's awesome. Just installed spacemacs about an hour ago to check out the Haskell support. That's great to know.
11:40:11 <lambdabot> Unknown command, try @list
11:40:17 <meditans> passy: I automated that with an emacs macro
11:40:31 <meditans> passy: precisely! I'm using spacemacs too ;)
11:40:35 <passy> And I've confused IRC with Twitter again â¦ Sorry, lambdabot.
11:43:35 <carter> ReinH: Enum is broken unless your data type is isomorphic to a subrange of integer :/
11:43:44 <ericdwhite> Hi I'm still pretty new to Haskell and I'm stuck trying to put together some strings with a strongly typed String and the ++ operator.  Could someone please have a look at: http://lpaste.net/121391
11:44:43 <meditans> ericdwhite: the problem in this code is that String and BaseURL are different types
11:44:48 <Maxdamantus> Int*
11:45:04 <carter> (BaseURL "/hello")
11:45:05 <carter> :)
11:45:05 <kristikodare> createURL (BaseUrl base) = bkavbka
11:45:13 <passy> enthropy: Thanks for the -ddump-minimal-imports hint. Found this here by Googling for it which looks quite interesting: https://hackage.haskell.org/package/packunused
11:45:13 <carter> also ++ is the wrong type
11:45:16 <meditans> ericdwhite: because you defined BaseURL as a *new*, *different* type from String
11:45:17 <carter> enthropy: how's things?
11:45:18 <carter>  :)
11:45:28 <enthropy> not bad
11:45:38 <kristikodare> ericdwhite, unbox it like that
11:46:05 <carter> unpack
11:46:06 <Welkin> why not just make BaseURL a type synonym for String?
11:46:07 <carter> not unbox :)
11:46:16 <carter> Welkin: or make it a monoid instance?
11:46:17 <kristikodare> sorry
11:46:54 <meditans> passy: enthropy: packunused, good to know
11:46:54 <rasen> I believe it supposed to use OverloadedStrings. See pragmas
11:47:03 <stelleg> theres no way to make overlapping instances work is there
11:47:28 <stelleg> e.g. force some ordering on instances
11:47:53 <enthropy> passy: also https://hackage.haskell.org/package/module-management
11:48:48 <zaphix__> I have a cabal sandbox with directory-1.2.1.0 installed in the sandbox. which is also listed as a part of the global packages. Packages built in the sandbox seem to be trying to use the global version of the package no matter what I do. Help? The global version is missing some symbols required by a package I'm trying to build, and if I hide the global version it just complains that the package is hidden and does not seem to pick up t
11:49:09 <passy> enthropy: Sweet!
11:49:27 <ericdwhite> Thanks all.  what I really wanted was to do as Welkin said and make BaseURL a type synonym.
11:49:35 <rasen> Welkin: in case of type synonym, you won't benefit from type system
11:49:58 <enthropy> stelleg: they work, they just make for some confusion that's better to avoid unless you really really need them
11:50:02 <Welkin> the point of type synonyms is for clarity
11:52:29 <stelleg> enthropy: yeah, I'm checking out AdvancedOverlap in the wiki
11:52:47 <enthropy> I mean normal overlapping instances
11:52:51 <stelleg> enthropy: might give Closed Type families a go
11:53:36 <meditans> it is possible to profile a library with +RTS -p per se, or do you always need an application with a main?
11:53:40 <stelleg> right, but they don't resolve, right?
11:53:45 <stelleg> so
11:54:10 <stelleg> if I have a backup instance Show a => MyClass a
11:54:42 <stelleg> but want to define a special case for MyClass Text
11:55:06 <enthropy> stelleg: https://github.com/aavogt/IsInstance is some TH for that AdvancedOverlap idea... but that second TODO there stops it from being practical
11:55:12 <lpaste> ericdwhite revised ânewtype String with ++â: âNo titleâ at http://lpaste.net/121391
11:55:23 <stelleg> enthropy: cool, thanks
11:55:34 <hexagoxel> zaphix__: so the sandbox-installed version contains local modifications? pragmatic solution is to also modify the version, e.g. to 1.2.1.0.1
11:56:27 <ericdwhite> As kristikodare pointed out unboxing also works.
11:56:28 <hexagoxel> if you depend on that version, cabal will not be able to use global; also it will be apparent to other devs that this is not the default 1.2.1.0
11:56:56 <zaphix__> hexagoxel: huh, that's an interesting idea
11:56:58 <kristikodare> ericdwhite unpacking, is a better word apparently :)
11:57:18 <ericdwhite> Is just thought that OverloadedStrings would take care of that
11:59:01 <zaphix__> hexagoxel: I'll play around with that. The directory package installed into the sandbox doesn't have any of /my/ local modifications, but when I do a --force-reinstalls --only-dependencies from the top level, directory does get installed into the sandbox and contains symbols that differ from the global version.
11:59:12 <zaphix__> hexagoxel: the --force-reinstalls is needed because cabal install seems to need that despite the fact that the sandbox is initially empty and there really shouldn't be anything to reinstall =/
11:59:36 * hackagebot hledger-irr 0.1.1.5 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.5 (JoachimBreitner)
12:01:23 <geekosaur> zaphix__, overriding a global package with a sandbox package can still cause problems
12:01:53 <ReinH> carter_cloud: Well Enum is also broken full stop, so...
12:01:58 <carter> yeah
12:04:10 <zaphix__> geekosaur: the problem is, that if i don't override it, something that builds in the sandbox can't link against the global package lib (missing symbols). if I compile it in the sandbox, that lib does have the symbols, and I'm not exactly sure why. =/
12:04:57 <zaphix__> geekosaur: i guess maybe i'm not clear on why the global packages are even used in the sandbox, i thought the whole point of the sandbox is to isolate the whole dependency environment
12:05:11 <geekosaur> ghc does not allow suppressing the global environment
12:05:20 <geekosaur> mostly because it contains base aka the haskell runtime
12:05:20 <carter> zaphix__: are you using haskell paltform?
12:05:28 <geekosaur> and you can only build and install that with ghc itself
12:05:41 <zaphix__> carter: nope, just a binary installed ghc and a hand-built cabal-install
12:05:47 <carter> i have "constraint: transformers installed" in my ~/.cabal/config
12:06:05 <carter> zaphix__: i'm guessing you're hitting something using GHC API + wanting to use transformers 0.4 ?
12:06:54 <hexagoxel> zaphix__: i have no idea why the symbols would be different. that itself seems suspicious to me. nonetheless, you could download directory, make the version change, and add-source it to your sandbox
12:07:19 <zaphix__> carter: i don't think so, i'm buried amidst cabal hell and this seems to be related to fast-logger and a link step trying to link against a global lib that apparently doesn't have the symbols it expects, it's still not clear to me exactly what the underlying issue is
12:07:31 <carter> zaphix__: what are you pkg depvs
12:07:33 <zaphix__> hexagoxel: yeah i think i might try to hack around it like that, thank you for the suggestion
12:07:39 <carter> zaphix__: also the linker problems go away if you use 7.10
12:07:47 <zaphix__> carter: there are like 60 ;P
12:07:54 <carter> zaphix__: lpaste em
12:07:59 <carter> @lpaste
12:08:00 <lambdabot> Haskell pastebin: http://lpaste.net/
12:08:07 <zaphix__> carter: one sec
12:08:17 <carter> zaphix__: also, i repeat, many linker problems involving mixing library versions etc wrt linkery go away with 7.10
12:08:59 <zaphix__> carter: yeah, okay, that might be worth a shot too -- i'm just trying to find a stable build environment for some production code, so i have to be a little cautious about moving up from 783
12:09:16 <carter> zaphix__: ok, well, i am a wizzard a fixing deps
12:09:30 <carter> zaphix__: i actually find that its easier to fix up deps sans sandbox first
12:09:36 <carter> then after you sort it out, THEN sandbox
12:09:43 <carter> but anyways, show me ur deps :)
12:09:57 <zaphix__> carter: hehe. http://lpaste.net/121397
12:10:22 <zaphix__> carter: the obnoxious thing is that the deps can actually resolve and already build in a different build environment (on our build servers)
12:10:30 <zaphix__> carter: this link error is local to os x as far as i can tell
12:10:31 <carter> zaphix__: solution
12:10:33 <carter> oh
12:10:36 <carter> whats the error
12:10:44 <zaphix__> carter: i'll find the actual link error, one sec
12:10:45 <carter> zaphix__: what cabal version do you have on each
12:10:48 <carter> cabal --version
12:11:06 <carter> same GHC versions though?
12:11:46 <carter> zaphix__: one thing that might be helpful, is if it builds on your build servrer, do a "cabal freeze" there to write down the exact set of choices that builder makes
12:11:51 <zaphix__> carter: yeah, same ghc versions
12:11:52 <carter> so you can see what the exact versions chosen are
12:11:58 <carter> what CABAL ---version
12:12:18 <carter> i'm meh about version pinning, but for business apps life cycle its handy i guess
12:12:21 <zaphix__> carter: oh that's a good point -- i guess i just assumed that they'd be the same versions on both since the .cabal files are the same and they both run cabal update as a part of the build process
12:12:31 <carter> what cabal --version
12:12:35 <carter> the build tool
12:12:41 <zaphix__> cabal-install version 1.20.0.6 using version 1.20.0.3 of the Cabal library
12:12:41 <carter> there HAVE been bug fixes :)
12:13:11 <zaphix__> I couldn't bump up to a higher cabal version since it broke ghc-mod, but I guess I could live without it in favor of a working environment
12:13:13 <carter> 1.22.0.0 is the current version
12:13:16 <carter> oh
12:13:27 <carter> zaphix__: i dont believe in ghc-mod :)
12:13:29 <carter> or other tools
12:13:30 <zaphix__> duct tape and bubble gum recently :P
12:13:35 <carter> cabal build / cabal repl gives me the errors
12:13:45 <carter> smart editors distract me
12:14:05 <carter> otoh, agda-mode like things are magic
12:14:20 <zaphix__> carter: i like the in editor type introspection and depositing inferred type signatures
12:14:27 <carter> cool
12:14:38 <carter> get ghc-mod  apatch
12:14:42 <carter> :)
12:14:56 <carter> i know there was bug fix release of 1.22 cabal the library recently too
12:15:17 <zaphix__> carter: http://lpaste.net/121398
12:15:41 <carter> zaphix__: did you try not using sandboxes?
12:15:54 <carter> zaphix__: show me your ~/.cabal/config
12:16:02 <zaphix__> carter: not yet
12:16:53 <carter> zaphix__: how'd you install ghc on your mac?
12:16:57 <zaphix__> carter: http://lpaste.net/121399
12:17:04 <zaphix__> carter: bindist
12:17:30 <zaphix__> carter: bindist and then hand-built the small deptree for cabal-install
12:17:33 <carter> ahh
12:17:40 <carter> zaphix__: ghc for os x by etrepum  is great
12:17:41 <carter> use it
12:17:42 <carter> :)
12:17:42 <zaphix__> carter: then used sandboxes for everything else to try to avoid dep hell
12:17:47 <carter> nop
12:17:52 <zaphix__> carter: ok
12:18:05 <carter> https://ghcformacosx.github.io/
12:18:28 <carter> zaphix__: solution: explode your ~/.ghc
12:18:31 <carter> and then cabal install
12:18:49 <zaphix__> carter: blow away .ghc, cabal install with no sandbox eh?
12:18:53 <carter> yes
12:18:57 <carter> and only~/.ghc
12:19:00 <carter> NOT ~/.cabal
12:19:08 <carter> zaphix__: if you switch t using https://ghcformacosx.github.io/
12:19:13 <carter> then you get cabal install 1.22 for free
12:19:37 * hackagebot teeth 0.1.0.0 - Dental data types  http://hackage.haskell.org/package/teeth-0.1.0.0 (jophish)
12:19:39 * hackagebot websnap 0.1.0.0 - Transforms URLs to PNGs  http://hackage.haskell.org/package/websnap-0.1.0.0 (jrb)
12:19:39 <zaphix__> carter: okay, since shit's borked anyway i'll go install that first and see if i can get this to build
12:19:47 <jophish> :D
12:19:51 <zaphix__> carter: thanks for the suggestions, will let you know what breaks ;P
12:19:57 <int-e> Hmm, speaking of cabal-install, is there a way to specify extra flags for building the various 'setup' executables?
12:20:22 <carter> int-e: i honestly dont understand those setup-executibles myself
12:22:06 <int-e> carter: it's how cabal-install supports building with a different Cabal (library) version than it was itself built with: Compile the  main = Distribution.Simple.defaultMain  program, and run that for configuring and building packages
12:22:26 <carter> ahh
12:22:28 <carter> yeah
12:24:01 <int-e> carter: The thing is, I have a dynamic-only ghc (not really supported, I know, but it works almost flawlessly), but cabal-install builds the setup executables in the vanilla way. I've now hacked the ghc wrapper script to artificially inject a -dynamic there, but that's awful.
12:24:20 <zaphix__> carter: didn't switch ghcs yet, gonna try it with what i have now just in case with no sandbox. the first issue that comes to mind is that because i was using a sandbox, i was cloning a bunch of other repos and add-sourcing them to the sandbox, and doing the installation all at once which i thought would help evade cabal hell. if i install theses packages one at a time into the user package repository, i'm almost sure to have even mo
12:24:21 <carter> int-e: how much space do you safe?
12:24:26 <stelleg> enthropy: any idea why this doesn't work? http://sprunge.us/GcSC
12:24:36 <carter> zaphix__: you were getting too clever
12:24:50 <carter> zaphix__: you can cabal install path1 path2 path3
12:24:58 <carter> zaphix__: thats a thing, btw
12:25:04 <zaphix__> carter: well, these are forked repos and such for various packages, kind of have to have them
12:25:05 <carter> not marketed as well as it should be though
12:25:09 <carter> i know
12:25:11 <carter> read what i just said
12:25:12 <enthropy> stelleg: you forgot {-# LANGUAGE OverlappingInstances #-}
12:25:21 <zaphix__> carter: ah, ah, ok
12:25:41 <carter> zaphix__: yes,  so eg, when you wanna share a private package, you just give someone a urls
12:25:44 <carter> and they can do cabal install URL
12:25:47 <carter> $URL
12:26:19 <stelleg> enthropy: thank you for making me feel stupid
12:26:24 <stelleg> :)
12:26:33 <int-e> carter: Let's see, it's 210 MB for a dynamic-only installation (no docs), and I think each way adds that amount again.
12:26:48 <carter> @ask ttuegel  why doesn't the cabal help install docs mention that urls work as package names?
12:26:49 <lambdabot> Consider it noted.
12:27:04 <zaphix__> carter: so cabal install /path/pkg1 /path/pkg2 ... from inside the toplevel of the package i'm actually trying to build, yes?
12:27:11 <carter> no
12:27:26 <carter> outside of ALL OF THEM
12:27:35 <carter> so the constraints are all together
12:27:36 <zaphix__> carter: gotcha
12:27:40 <carter> i could be wrong
12:27:45 <carter> but if i'm wrong, its a legit bug report :)
12:27:51 <carter> zaphix__: and if it can't find a constraint
12:28:07 <carter> do the same command but add --max-backjumps=-1 -v3
12:28:12 <zaphix__> kk
12:28:13 <carter> and you'll lpaste that output
12:28:19 <carter> and then we'll talk about where it got stuck
12:28:25 <enthropy> stelleg: or you could define    class TextShow' (b::Bool) a; instance TextShow' True String; instance Show a => TextShow' False a -- is not overlapping
12:28:28 <int-e> carter: the space savings aren't my main motivation. mueval/hint are faster with shared libraries (once they've been cached)
12:28:32 <carter> ahh
12:28:45 <carter> zaphix__: notice how i'm also focusing on suggesting an approach that isn't clever
12:28:46 <carter> :)
12:28:53 <enthropy> type TextShow a = TextShow' (Defined a) a
12:29:15 <stelleg> enthropy: oh cool, good idea
12:29:17 <enthropy> and make sure the actual tshow function you export uses that defined
12:29:23 <zaphix__> carter: yes, i'm seeing that =P
12:29:28 <enthropy> well I dunno if it makes any practical difference
12:29:43 <enthropy> you just get to boast that you don't use OverlappingInstances
12:30:51 <stelleg> enthropy: my friends will be impressed
12:31:18 <zaphix__> carter: okay, it resolved the deptree, but says a handful of packages will be broken by reinstalls and to use --force-reinstalls, which I'm pretty sure I don't want to do.
12:31:47 <carter> zaphix__: which packages
12:31:53 <zaphix__> carter: sec
12:32:23 <carter> zaphix__: sometiems the best way is to add --allow-newer --dry at the end
12:32:27 <carter> and then it gives you the list of choices
12:32:33 <enthropy> hmm, I think you can have "class Defined a ~ b => TextShow' b a"
12:32:38 <carter> and it tries picking the newest of each dep
12:33:00 <carter> and then you run it and see if type errors happen
12:33:05 <carter> or if your bounds were too tight
12:33:08 <zaphix__> http://lpaste.net/121400
12:33:18 <zaphix__> carter: http://lpaste.net/121400
12:33:33 <zaphix__> carter: right, but i didn't really want to allow upgrades i didn't really trust
12:33:42 <carter> umm
12:33:51 <carter> lets talk about what would be the reinstalls
12:34:13 <carter> zaphix__: ok, now do the following
12:34:22 <carter> cabal update ; cabal install directory time unix
12:34:34 <zaphix__> carter: ok
12:34:45 <carter> that way they get installed into the user pkg db
12:35:08 <zaphix__> carter: already installed, use --reinstalls if you want to reinstall anyway
12:35:18 <carter> zaphix__: i thought you exploed ~/.ghc
12:35:35 <zaphix__> carter: i did, and there is nothing listed in ghc-pkg for user packages
12:35:40 <carter> ok
12:35:42 <carter> then reinstall
12:35:59 <carter> worst case you switch to ghc for os x even soon :)
12:36:08 <Luke> is there an easy way to generate run, eval, and exec for generalized newtype deriving monads?
12:36:18 <zaphix__> carter: http://lpaste.net/121401
12:36:27 <zaphix__> carter: yeah, right? this shit has been killing me for a day or so now ;P
12:36:44 <carter> ok
12:36:53 <carter> 1) thats lame
12:37:01 <zaphix__> carter: haha
12:37:09 <carter> 2) i want to see that -v3 output
12:37:16 <carter> that prompted the reinstall
12:37:23 <carter> so i can see WHY it wants to reinstall stuff
12:37:23 <zaphix__> carter: for that last install command?
12:37:27 <zaphix__> ok
12:37:47 <carter> cabal install  f1 f2 f3 fu --only-dependencies -v3 --dry
12:39:21 <zaphix__> carter: http://lpaste.net/121403
12:40:08 <carter> huh
12:40:14 <carter> zaphix__: nooo
12:40:18 <carter> for yourrrrrr stuff
12:40:19 <zaphix__> carter: haha
12:40:27 <carter> f1 f2 f3 fu
12:40:29 <carter> or whatever
12:40:29 <zaphix__> carter: oh, oh, ok. one sec
12:41:35 <zaphix__> carter: should i max backjumps that to something small?
12:41:57 <carter> --max-backjumps=-1 means "dont quite till you get me there"
12:41:59 <michaelt> zaphix__: I take it you are aware there will be trouble installing a new 'unix'
12:42:17 <carter> hrmmm
12:42:29 <zaphix__> michaelt: I am now. FFS, I just needed to use time >= 1.5. hehe.
12:42:31 <balor> If an IO action fails, like readFile not finding the file for reading, how does the caller know?
12:42:38 <carter> zaphix__: you can just cabal install time
12:42:46 <carter> that works fine
12:43:02 <zaphix__> carter: well the -v3 that you requested just keeps on churning
12:43:10 <carter> zaphix__: no news there
12:43:11 <carter> :)
12:43:25 <michaelt> zaphix__: yeah, I see time and directory now.  These are all 'boot libraries' that come with ghc.
12:43:57 <carter> zaphix__: is the build server at cabal 1.20 too
12:43:59 <carter> or 1.22
12:44:43 <zaphix__> carter: let me check, that's a great question.
12:45:04 <carter> zaphix__: are my questions giving you a roadmap so you too can help the next person with cabal hell? :)
12:45:17 <zaphix__> carter: yes, this is super useful :P
12:45:36 <michaelt> this is something worse than mere cabal hell
12:45:45 <carter> this is "your constraints are shit"
12:45:46 <carter> hell :)
12:45:57 <zaphix__> carter: -v3 too big for lpaste, do you need the whole thing?
12:46:04 <carter> zaphix__: use gist.github.com
12:46:06 <zaphix__> carter: haha, yes =)
12:46:11 <carter> dont get clever and editorialize
12:46:15 <carter> otherwise that means you know the answer :)
12:46:37 <michaelt> zaphix__: my deluxe ghc-7.10-rc1 has time-1.5.0.1
12:46:39 <carter> zaphix__: honestly, i'd just try out deleting all the constraints in your deps and seeing if the build works
12:46:54 <carter> and then doing cabal freeze if it does
12:47:09 <carter> or at least delting all the upper bounds
12:47:11 <zaphix__> carter: https://gist.github.com/anonymous/66baa453d2411cf96cb6
12:47:33 <carter> ok
12:47:50 <zaphix__> carter: yes, i'd thought about doing that
12:48:05 <carter> hrmmm
12:48:06 <carter> ok
12:48:10 <carter> so some things i'm noticing already
12:48:17 <carter> wait
12:48:21 <carter> are you using 2 aws pkgs?
12:48:32 <carter> ewww
12:48:33 <carter> ewwww
12:48:35 <carter> i see another problem
12:48:38 <carter> zaphix__: ok
12:48:50 <zaphix__> carter: yeah it's really gross, but i can't drop the aws dep yet until i rewrite a chunk of the code
12:48:59 <zaphix__> carter: cabal-install version 1.20.0.3; using version 1.20.0.0 of the Cabal library on the build server
12:49:06 <carter> 1) add "constraint: transformers installed" to your ~/.cabal/config
12:49:18 <carter> zaphix__: on the build server, cabal install cabal-install
12:49:21 <carter> then do cabal freeze
12:49:38 <carter> and you'll see what versions it picked of everything in a cabal.config file
12:49:58 <carter> [_21] next goal: utf8-string (dependency of aws-0.12)
12:49:58 <carter> [_21] rejecting: utf8-string-1 (conflict: aws => utf8-string==0.3.*)
12:49:58 <carter> [_21] trying: utf8-string-0.3.8
12:50:23 <zaphix__> carter: okay
12:50:47 * michaelt remembers there is something demonic about utf8-string's own bounds
12:50:58 <carter> zaphix__: ddi you add transformers installed  constraint to your macs ~/.cabal/config ?
12:51:12 <zaphix__> carter: not yet, doing that now
12:52:08 <carter> also --allow-newer=http-conduit
12:52:57 <zaphix__> carter: oh interesting, now i get a genuine dep error: http://lpaste.net/121405
12:53:11 <carter> i think your version of aws is shit
12:53:24 <carter> for what command?
12:53:31 <zaphix__> carter: yeah, ok, maybe i will just rip it out
12:53:38 <carter> zaphix__: LOLLLL, theres IS no aws 0.12
12:53:43 <carter> https://hackage.haskell.org/package/aws
12:53:53 <zaphix__> carter: no, i know, i had to hand patch something and that's a local version
12:54:03 <zaphix__> carter: it's 0.11 with a local bump
12:54:12 <carter> ok
12:54:21 <carter> how about you do the original build with --allow-newer everywhere
12:54:39 <carter> cabal install f1 f2 f3 fu --dry --allow-newer
12:54:40 <zaphix__> carter: okay, i'll give that a shot
12:54:59 <carter> zaphix__: idea: you actually got too clever
12:55:13 <carter> your patched version should still be marked 0.11.9.9
12:55:14 <carter> or something
12:55:31 <carter> because someone was smart and said "oh, 0.12 aws would be a breaking change, so we dont allow that"
12:55:38 <carter> or do --allow-newer=aws
12:55:40 <carter> that might work too
12:55:44 <carter> that'd be sanner
12:55:57 <carter> --allow-newer="aws,utf-string"
12:56:08 <zaphix__> carter: http://lpaste.net/121406
12:56:33 <zaphix__> carter: ah good idea
12:56:44 <carter> ok, first cabal install myaws --allow-newer
12:56:50 <carter> ok, first cabal install myaws --allow-newer --dry ; then not dry
12:56:59 <zaphix__> myaws or just aws?
12:57:06 <carter> youraws
12:57:09 <zaphix__> oh duh
12:57:10 <zaphix__> sorry :P
12:57:13 <zaphix__> one sec
12:57:16 <carter> why did you patch aws anyways
12:57:26 <carter> if it was just bound bumping, allow-nwere suffices
12:57:34 <carter> stop making shit complicated
12:57:50 <carter> also you can ask hackage trustees, usch as me
12:57:53 <carter> to fix the bouds on hackage
12:58:12 <carter> by opening a ticket here https://github.com/haskell-infra/hackage-trustees
12:58:23 <michaelt> will snaplet-amqp continue to require the newer transformers?
12:58:25 <zaphix__> carter: http://lpaste.net/121407
12:58:47 <carter> zaphix__: stop requireing aws 0.12
12:58:51 <carter> that breaks everyhing
12:59:05 <zaphix__> carter: no, it was a bugfix in one of the handlers, i hadn't gotten around to submitting a patch and waiting for it to be accepted before dropping my custom version, it was just a small local hack
12:59:09 <carter> ahhh
12:59:15 <carter> then name it 0.11.something
12:59:20 <carter> not 0.12
12:59:21 <zaphix__> ok
12:59:32 <carter> so like 0.11.whatever.x+1
12:59:50 <carter> so like 0.11.2.1
13:00:40 <carter> zaphix__: also -v3 output helps understand why it get stuck
13:00:44 <zaphix__> yeah, that didn't work either. fuck it, i'm going to rip out aws and use the ghc for mac os x thing with a new cabal you sent me. i'm betting that with cleaner deps all of this stuff goes away
13:01:14 <carter> zaphix__: i bet if you built with 0.11.something as the aws version, things work FINE
13:01:21 <zaphix__> carter: the aws stuff thing can go away anyway, i was just being lazy and trying to leave both bindings in the package set for the time being
13:01:29 <michaelt> maybe he should add "constraint: process installed" "constraint: directory installed"to .cabal/config
13:01:31 <zaphix__> carter: just tried that, didn't work
13:01:36 <zaphix__> carter: one sec
13:01:45 <carter> i think michaelt  has a good suggestion too
13:05:17 <zaphix__> carter: okay, i'll try that as well. i think something's screwy locally that i'll have to fix up because i changed myaws to 0.11.99 and it's still looking for 0.12, so I'm probably missing some detail of something.
13:05:36 <carter> zaphix__: check exploding your ~/.ghc :)
13:05:40 <carter> and cabal cleaning stuff
13:05:47 <zaphix__> carter: but it's getting to the point where i think the .cabal/config constraints and a fresh os x ghc/cabal 1.22 with no aws package might just be the way to go anyway
13:06:07 <carter> zaphix__: only only do those constraints for the pkgs we've mentioned
13:06:09 <carter> nothing else
13:07:32 <michaelt> zaphix__: is this all happening in a sandbox?
13:07:43 <zaphix__> michaelt: no not anymore, although it started out that way
13:07:58 <zaphix__> carter: yeah i'm not making any progress with changing the aws version number
13:08:07 <zaphix__> carter: that sounds like an absurd thing to say lol
13:08:13 <carter> zaphix__: ghc-pkg list
13:08:28 <carter> are you editing the right folder/file?
13:08:29 <zaphix__> no user packages, no aws
13:08:33 <michaelt> zaphix__: just to make like the sirens, i'm not having any trouble with 'cabal install aws' with my deluxe ghc-7.10-rc1 ;)
13:08:59 <hyuke> Is there anyone here who has experience writing gui applications both in haskell and an imperative language that could compare/contrast the difference in a very general way?
13:09:13 <zaphix__> michaelt: hehe yeah, we were just going to hold off on an upgrade to 7.10 since 783 has been stable for us and the bleeding edge has bitten us badly (although apparently we still get bit)
13:09:15 <carter> $otherLanguage has more mature gui bindings :)
13:09:35 <carter> zaphix__: 7.8.4 + 1.22 is where its at yo
13:09:35 <carter> :)
13:09:39 <michaelt> zaphix__: you should certainlu show carter ghc-pkg list and then maybe do ghc-pkg unregister x y z where x y and z are implicated in this nonsense.
13:09:52 <carter> or ghc-pkg hide
13:10:04 <carter> michaelt: unregister might be a bit much
13:10:17 <zaphix__> carter: http://lpaste.net/121409
13:10:27 <zaphix__> i mean, there's really nothing there
13:10:42 <michaelt> zaphix__: oh i see, i take it back about 7.10. ... does just fine on my macbook air ...
13:10:55 <hyuke> carter: that's the conclusion I came to as well :P.  I'm kind of new to learning Haskell and the bindings I see look kind of awkward to use (maybe because they originally are coming from an imperative language)
13:11:07 <michaelt> carter: yes
13:11:14 <zaphix__> michaelt: yeah, i'm sure it's workable, we just have production code running and tested on top of 783, so the migration to a newer compiler is something we're a little careful about, that's all
13:11:24 <carter> zaphix__: move to 7.8.4
13:11:30 <carter> via ghc for os x
13:11:33 <zaphix__> carter: okay, will do, thanks so much =)
13:11:35 <carter> and associated cbal install
13:11:36 <zaphix__> yup, doing that now
13:11:40 <zaphix__> kk
13:11:47 <carter> and then think carefully about how you version your privately patched things
13:11:51 <carter> :)
13:11:58 <zaphix__> carter: *nod*
13:12:09 <michaelt> zaphix__: no, right, i shouldn't have mentioned it.
13:12:16 <carter> does teh -v3 help make it clear that something about the aws guy is whats breaking things?
13:15:03 <michaelt> carter: what is the boot library that will go better with ghc-7.8.4
13:15:11 <carter> ???
13:15:39 <michaelt> or, what will go better with ghc-7.8.4
13:15:43 <michaelt> with aws
13:16:05 <michaelt> Oh wait, maybe it was just general advice "move to ghc-7.8.4"
13:16:17 <carter> + 1.22
13:16:53 <michaelt> ah, i see
13:17:31 <carter> plus "something is wrong, lets just explode the universe"
13:17:38 <erisco> :t [just 5, nothing]
13:17:39 <lambdabot> Num t2 => [t1 -> (t2 -> t1) -> t1]
13:17:48 <erisco> what encoding is this of the Maybe ADT?
13:18:28 <carter> :t nothing
13:18:29 <lambdabot> t1 -> t -> t1
13:18:34 <carter> :t just
13:18:35 <lambdabot> t2 -> t -> (t2 -> t1) -> t1
13:18:59 <erisco> I added these myself
13:19:30 <L8D> type Maybe a = b -> (a -> b) -> b
13:19:38 <L8D> nothing = const
13:19:46 <L8D> just x _ f = f x
13:20:13 <jmcarthur> :t maybe
13:20:14 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:20:31 <gyaretto> What would be a non-ugly way to check for "eof" or "EOF" in the same condition on line 8? https://gist.github.com/8abb309d40f4d5d7862f
13:20:49 <L8D> gyaretto: map toLower s == "eof"
13:21:35 <L8D> gyaretto: why not use getContents ?
13:22:06 <jmcarthur> gyaretto: what L8D said, or if you don't want to accept things like "eOf":   s `elem` ["eof", "EOF"]
13:22:09 <L8D> intercalate "\n" = unwords
13:22:19 <L8D> wait no
13:22:20 <L8D> derp
13:22:27 <L8D> intercalate "\n" = unlines
13:22:30 <mauke> no
13:22:33 <L8D> > unlines ["foo", "bar", baz"]
13:22:35 <lambdabot>  <hint>:1:29:
13:22:35 <lambdabot>      lexical error in string/character literal at end of input
13:22:36 <L8D> > unlines ["foo", "bar", "baz"]
13:22:38 <lambdabot>  "foo\nbar\nbaz\n"
13:22:39 <erisco> mauke, hi
13:22:51 <AlainODea> Is there an fmap-like function for Pair that acts like List fmap except hetegenous (ex: fmap ($1) ((+1),even) == (2,false))?
13:23:00 <erisco> okay, so Church and Scott encoding also talk about recursive types (I think?(
13:23:00 <mauke> @check \x -> intercalate "\n" x == unlines x
13:23:02 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
13:23:02 <lambdabot>  [""]
13:23:17 <erisco> so if I try to do something recursive, without really know what Church and Scott encodings are, I do this
13:23:18 <jmcarthur> AlainODea: it would need a higher rank type
13:23:22 <L8D> AlainODea: you should learn about Lens
13:23:27 <erisco> :t conz 1 . conz 2 . conz 3 . end
13:23:28 <carter> AlainODea: data Pair a = (a,a)
13:23:28 <lambdabot> (Num t8, Num t5, Num t2) => a -> (t2 -> ((t5 -> ((t8 -> (t9 -> t9) -> t7) -> t6 -> t7) -> t4) -> t3 -> t4) -> t1) -> t -> t1
13:23:35 <L8D> AlainODea: and no, but you could write one very easily
13:23:37 <carter> AlainODea: OR bimap/bifunctor
13:23:37 <erisco> :t conz 1 . end
13:23:38 <lambdabot> Num t2 => a -> (t2 -> (t3 -> t3) -> t1) -> t -> t1
13:23:41 <gyaretto> Thanks!
13:23:47 <AlainODea> L8D: I'm on it :)  I imagine Lens has this somewhere
13:23:50 <L8D> dmap f (x, y) = (f x, f y)
13:23:54 <erisco> :t conz 1 end
13:23:56 <lambdabot> Num t2 => (t2 -> (t3 -> t4 -> t4) -> t1) -> t -> t1
13:24:05 <jmcarthur> AlainODea: you'll need to be more specific about what kind of constraints there are on the function you pass in
13:24:12 <erisco> I mean that, sorry
13:24:16 <erisco> :t conz 1 . conz 2 . conz 3 end
13:24:17 <lambdabot> (Num t8, Num t5, Num t2) => (t8 -> (t9 -> t10 -> t10) -> t7) -> (t2 -> ((t5 -> (t6 -> t7) -> t4) -> t3 -> t4) -> t1) -> t -> t1
13:24:18 <jmcarthur> AlainODea: the most polymorphic version would basically only allow  id
13:24:31 <mauke> scott is like simple pattern matching, church has recursion built in
13:24:33 <mauke> like foldr on lists
13:25:52 <jmcarthur> scott gives you a view of the just "top" of the data structure. church replaces every constructor with something else.
13:26:20 <AlainODea> jmcarthur: my specific use case is using amazonka to get [(Text,IpPermission)] where the Text is the group id for AWS security groups. I can easily get [IpPermission] or [Text].  On inspection, I suppose zip is a reasonable solution here
13:26:35 <mauke> :t let scott [] _ nil = nil; scott (x : xs) cons _ = cons x xs in scott
13:26:36 <lambdabot> [t1] -> (t1 -> [t1] -> t) -> t -> t
13:27:33 <jmcarthur> AlainODea: if you want to map two different functions over it, you could use (***) from Control.Arrow.
13:27:54 <jmcarthur> AlainODea: so for your list of pairs xs, it might look like  map (f *** g) xs
13:28:10 <mauke> :t join (***)
13:28:11 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:28:21 <AlainODea> jmcarthur: that looks like just the ticket.  Thank you
13:28:33 <jmcarthur> mauke: that won't work for AlainODea because the goal was to be heterogeneous
13:28:42 <erisco> okay, I am still not very clear on it
13:28:48 <erisco> but can we do Church encoding in Haskell?
13:28:58 <erisco> for lists
13:29:03 <L8D> erisco: yes
13:29:17 <jmcarthur> erisco: yup!    type List a = forall r. (a -> r -> r) -> r -> r
13:29:21 <L8D> type List a = b -> (a -> List a -> b) -> b
13:29:31 <L8D> nil = const
13:29:34 <jmcarthur> L8D: that's scott encoding (and not legal with type)
13:29:40 * hackagebot aeson-casing 0.1.0.0 - Tools to change the formatting of field names in Aeson  instances.  http://hackage.haskell.org/package/aeson-casing-0.1.0.0 (andrewrademacher)
13:29:45 <L8D> cons x xs _ f = f x xs
13:29:58 <L8D> jmcarthur: ah
13:30:00 <mauke> L8D: that doesn't look like foldr
13:30:25 <L8D> jmcarthur: is Church encoding the one that takes cons and nil as arguments?
13:30:36 <jmcarthur> L8D: yes
13:30:36 <erisco> jmcarthur, ugh, forall rears it's ugly head again... so what does it mean in this context exactly?
13:31:27 <jmcarthur> erisco: it means that i can instantiate the same List a with different types in place of r
13:31:33 <carter> jmcarthur: hows things?
13:31:51 <jmcarthur> erisco: s/instantiate/unify/
13:31:55 <jmcarthur> carter: pretty good!
13:32:50 <jmcarthur> carter: i'm making an ocaml port of pipes. i'm finding there are some super awesome things about doing this, as well as some annoying things.
13:32:58 <carter> oh?
13:32:59 <erisco> jmcarthur, and how do I use this type?
13:33:08 <carter> jmcarthur: did you see that you can encode pipes in machines?
13:33:12 <carter> just got merged in
13:33:30 <jmcarthur> erisco: foldr = id; nil = \_ n -> n; cons = \c _ -> c
13:33:48 <jmcarthur> carter: i am not particularly surprised
13:34:32 <jmcarthur> carter: anyway, i'm using the reflection without remorse style encoding of operational, and going all in with all the different monads possible with pipes
13:34:43 <carter> oh?
13:34:49 <carter> using module functors?
13:34:51 <jmcarthur> carter: a nice thing about doing it in ocaml is i don't have any newtype wrapping, so using all the different monads at once is easy
13:35:01 <carter> how so?
13:35:03 <jmcarthur> carter: a downside is some of the functorization
13:35:40 <jmcarthur> carter: i just have different modules for each monad with no encapsulation.
13:35:55 <erisco> jmcarthur, can you show me an example of constructing and destructing a list please?
13:36:00 <jmcarthur> carter: they all operate on the same type, just with focus on different parameters
13:36:18 <jmcarthur> erisco: cons 1 (cons 2 (cons 3 nil))   with my definitions of cons and nil
13:36:35 <jmcarthur> erisco: and you can just foldr over that using my definition of foldr
13:37:27 <erisco> jmcarthur, I don't get it... cons 1 == 1
13:37:30 <erisco> I mean
13:37:32 <erisco> cons 1 x == 1
13:37:56 <jmcarthur> erisco: oh sorry, i fail
13:38:05 <jmcarthur> erisco:    cons x xs = \c _ -> c x xs
13:38:36 <L8D> Is there some way I can compose type constructors?
13:38:37 <mauke> that looks wrong
13:38:56 <mauke> but not
13:39:00 <erisco> jmcarthur, ah okay, that is what I had too
13:39:03 * mauke ponders
13:39:05 <erisco> so two questions
13:39:17 <jmcarthur> erisco: sorry g2g
13:39:44 <erisco> 1) how is this different from the Scott encoding and 2) cons 1 nil does not unify with cons 1 (cons 2 nil) so have really addressed recursivity?
13:40:00 <erisco> that is okay, thanks for your help :) hopefully someone else can answer
13:45:21 <Cale> erisco: The idea behind Church encoding is that you can always use a function which takes what would be the data constructors of your algebraic data type as arguments
13:45:38 <carter> zaphix__: alive?
13:45:44 <carter> o r did the yaks eat your cat
13:45:50 <zaphix__> carter: http://lpaste.net/121412
13:46:02 <zaphix__> carter: that's with 784 and a fresh install and the aws/snaplet-aws deps dropped
13:46:06 <zaphix__> it still wants to reinstall shit
13:46:14 <carter> zaphix__: give me the -v3
13:46:17 <zaphix__> kk
13:46:20 <carter> ddi you fix your aws?
13:47:22 <carter> honestly those pkages wont get broken by a user db reinstall, btw :)
13:47:40 <erisco> Cale, gotcha
13:47:43 <carter> (though i could be wrong :) )
13:47:44 <zaphix__> carter: https://gist.github.com/anonymous/999dad71e9591906f14b
13:48:00 <zaphix__> carter: i just dropped the aws entirely for now, i'd rather to see this thing build successfully
13:48:21 <zaphix__> carter: just using the newer bindings i want to use anyway and will make the related code changes after i get a sane package set
13:48:22 <carter> zaphix__: ... do you have any bounds on directory in your private paackage/s
13:48:30 <zaphix__> carter: don't think so lbut let me check
13:48:37 <erisco> what about Scott encoding and also can we use Church encoding and have a recursive type?
13:48:39 <Cale> erisco: The difference between Church and Scott encodings is that when you apply the Church encoding of a data structure to some arguments, you're essentially replacing all the constructors throughout the structure with the given arguments, while when you apply the Scott encoding, you effectively replace only the outermost constructor
13:49:01 <erisco> ah okay
13:49:07 <zaphix__> carter: ah yes, one of them has directory: >= 1.0     && < 2.0,
13:49:09 <erisco> gotcha on the differences
13:49:42 <erisco> the Scott encoding then is roughly the same as case analysis on an ADT value
13:49:48 <carter> zaphix__: ok
13:49:50 <Cale> yes, exactly
13:50:06 <carter> zaphix__:  1) cabal install lens snap-server
13:50:10 <carter> 2) try again
13:50:17 <zaphix__> ok
13:50:36 <carter> 1.5) cabal install fast-logger
13:51:00 <erisco> data Fix f = Fix (f (Fix f))   can we maybe use something like this to beef up the Church encoding? imma gunna try
13:51:15 <carter> zaphix__: because i'm pretty sure those aren't the blockers :)
13:51:32 <carter> ohhh
13:51:33 <zaphix__> carter: hehe ok
13:51:39 <carter> zaphix__: cabal install install mtl-2.1.3.1
13:51:42 <carter> also do that
13:51:48 <zaphix__> ok
13:52:00 <zaphix__> all in one go or as separate commands?
13:52:16 <carter> all in one go is fine
13:52:21 <carter> that you have [378] trying: transformers-compat-0.4.0.4:+mtl happening looks wrong
13:52:29 <carter> you should be getting 0.3
13:52:36 <carter> zaphix__: whats your current ~/.cabal/config look like
13:52:42 <carter> i think you didn't do the constraint
13:53:01 <carter> yup mtl-2.2.1 (new package)
13:53:04 <zaphix__> oh i should note i did take those constraint lines out for transformers installed and for process and directory (didn't work with them there either)
13:53:09 <zaphix__> carter: yeah you're right
13:53:14 <zaphix__> carter: so just for transformers?
13:53:23 <carter> yes
13:53:33 <zaphix__> ok
13:53:34 <carter> and SHOW me what the config file look slike
13:54:22 <zaphix__> carter: http://lpaste.net/121413
13:54:26 <ParmesanCaesar> i want to know what love is
13:54:42 <carter> zaphix__: that looks fine
13:54:52 <zaphix__> carter: so then cabal install lens snap-server fast-logger mtl-2.1.3.1 ?
13:54:55 <carter> yes
13:55:05 <carter> zaphix__: because those should all be fine
13:55:16 <zaphix__> k building those
13:55:19 <zaphix__> into the user package db
13:55:21 <carter> yes
13:55:28 <zaphix__> after exploding ~.ghc
13:55:39 <zaphix__> ~/.ghc, even
13:55:45 <carter> once we've surgeried this shit up, we can do cabal freeze to write down what works
13:56:18 <zaphix__> carter: yeah, I think I get what you were talking about before now, doing it outside of the sandbox, cabal freeze and sandbox with a rigid manifest
13:56:24 <carter> yes
13:56:31 <carter> you were gettig too clever with add source
13:56:42 <carter> zaphix__: my ~/.ghc IS my sandbox :)
13:56:43 <zaphix__> carter: yeah =)
13:56:48 <carter> faster that way
13:57:14 <carter> zaphix__: is it building?
13:57:19 <zaphix__> yeah
13:57:24 <zaphix__> chugging away
13:57:48 <carter> dont you  feel better now
13:57:53 <carter> something works in the world
13:58:00 <carter> it just may be that your code doesnt :)
13:58:26 <zaphix__> carter: haha =P
14:03:26 <zaphix__> carter: okay, build finished, gonna try to install the rest now and see what happens, one sec
14:03:31 <carter> ok
14:03:33 <carter> -v3 it
14:03:38 <carter> --dry
14:03:41 <carter> --allow-newer
14:04:33 <_d0t> hi. Is there any predefined typeclass for conversion from/to Int? Enum doesn't fit because my type doesn't support successive values.
14:04:49 <Welkin> fromIntegral
14:04:55 <Welkin> toIntegral
14:05:02 <mauke> fromInteger/toInteger
14:05:06 <Welkin> > fromIntegral 4 :: Float
14:05:07 <lambdabot>  4.0
14:05:14 <mauke> :t fromInteger
14:05:15 <lambdabot> Num a => Integer -> a
14:05:17 <mauke> :t toInteger
14:05:18 <lambdabot> Integral a => a -> Integer
14:05:27 <_d0t> same problem
14:05:27 <Welkin> that is only for Integer
14:05:30 <mauke> _d0t: so basically Integral
14:05:36 <Welkin> Integral works on both Int and Integer
14:05:45 <_d0t> mauke: the type in question isnt numerical
14:05:59 <Welkin> :t fromIntegral
14:06:00 <lambdabot> (Num b, Integral a) => a -> b
14:06:04 <mauke> _d0t: then how are you going to convert from/to Int?
14:06:16 <_d0t> mauke: using a lookup table
14:06:27 <mauke> _d0t: then why do you need a typeclass for it?
14:07:01 <_d0t> I want something similiar to C enum where the values do not have to be successive
14:07:11 <mauke> why?
14:07:33 <_d0t> the type in question in a set of valid values for a network packet field
14:07:41 <_d0t> the values are not successive
14:08:02 <mauke> ok?
14:08:17 <Welkin> what is the type?
14:08:23 <mauke> still not sure why this needs to be convertible to/from Int, let alone with a typeclass
14:08:52 <Welkin> just make a sum type
14:09:08 <_d0t> what I want is to avoid writing multiple functions like typeToInt for different types
14:09:19 <mauke> you only have one type
14:09:29 <_d0t> for now
14:09:29 <Welkin> data ValidValue = One | Two | Three
14:09:30 <mauke> one type that doesn't need to be convertible to Int
14:10:23 <_d0t> ok then
14:10:35 <Welkin> don't over-engineer
14:10:37 <_d0t> I mean I see your point about Int
14:10:38 <acowley> Cabal seems to compile setup.hs in a somewhat different way than it compoiles other things
14:11:01 <nerium> Any one knows a good tutorial for creating my own monad?
14:11:14 <dmj`> nerium: learn you a haskell has one
14:11:17 <dmj`> @lyah
14:11:17 <lambdabot> Unknown command, try @list
14:11:45 <dmj`> http://learnyouahaskell.com/for-a-few-monads-more#making-monads
14:11:46 <nerium> dmj`: That one didn't talk about creating new monads, just using already defined ones (or did I miss it?)
14:12:13 <Hijiri> the NICTA course has you define a lot of monad instances, although many of them are ones that already exist
14:12:34 <dmj`> nerium: think you missed it
14:12:37 <acowley> Does anyone know of a way to get Cabal to compile Setup.hs the same way it compiles other things? I.e. with explicit package names
14:12:40 <Hijiri> I think CIS194 has a parser monad section, but I don't remember if you define it
14:13:52 <nerium> dmj`: Do you mind linking to it b/c I can't find it
14:14:12 <Welkin> nerium: the typeclassopedia will help you here as well
14:14:18 <Welkin> @where typeclassopedia
14:14:18 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:14:41 * hackagebot lens-family-th 0.4.1.0 - Generate lens-family style lenses  http://hackage.haskell.org/package/lens-family-th-0.4.1.0 (DanBurton)
14:14:43 <nerium> Welkin: Thanks! I'll read it trough
14:15:07 <dmj`> nerium: I did
14:15:10 <Welkin> nerium: it's more of a reference than something you read in one sitting
14:15:18 <dmj`> nerium: http://learnyouahaskell.com/for-a-few-monads-more#making-monads
14:15:19 <Welkin> but you'll find yourself coming back to it to read it again and again
14:15:27 <Welkin> I have read many of the sections several times
14:15:38 <Welkin> the exerises are also helpful
14:15:42 <Welkin> exercises*
14:15:57 <nerium> dmj`: Hmm, I must have missed that one, sorry about that
14:16:22 <nerium> Welkin: I'll git it a go
14:16:27 <nerium> *give it
14:19:14 <brycelane_> Does anybody have any experience building a ghc cross compiler for a raspberry pi?
14:20:01 <brycelane_> In particular, I'm having trouble getting the gcc cross compiler to find the ncurses library
14:20:14 <carter> @google ghc arm cross compiler
14:20:15 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
14:20:34 <brycelane_> Yes, I've got most of those in tabs, but I'm still stuck.
14:29:42 * hackagebot shake-minify 0.1.0 - Shake Minify Actions  http://hackage.haskell.org/package/shake-minify-0.1.0 (LukeHoersten)
14:32:47 <siddhu> Stream fusion: Was there any interest in re-opening https://ghc.haskell.org/trac/ghc/ticket/915 considering http://ittc.ku.edu/~afarmer/concatmap-pepm14.pdf was published?
14:34:13 <ParmesanCaesar> I am a salad
14:34:41 <dolio> ParmesanCaesar: Are you here to learn Haskell?
14:34:56 <ParmesanCaesar> croutons
14:35:20 <dolio> I guess that's a, "no"?
14:36:03 <mauke> ParmesanCaesar: are you a bot?
14:36:14 <Hijiri> ParmesanCaesar is a salad
14:36:25 --- mode: ChanServ set +o dolio
14:36:53 <Axman6> with a redundant name; all caesar salad has parmesan
14:37:07 <ParmesanCaesar> http://bit.ly/1BORxp9
14:37:14 <Axman6> ChickenCaesar on the other hand is not redundant
14:37:30 <Axman6> dolio: time to do the thing by the looks of it
14:37:38 --- mode: ChanServ set +o mauke
14:37:39 --- mode: mauke set +b $a:ParmesanCaesar
14:37:44 --- kick: ParmesanCaesar was kicked by mauke (ParmesanCaesar)
14:38:02 <mauke> this is the worst spam bot
14:38:02 --- mode: ChanServ set -o dolio
14:38:23 <Axman6> did you look at the link? I decided it was probably a bad idea at work
14:38:33 <Hijiri> it is the wikipedia page for croutons
14:38:34 <mauke> wikipedia, "Crouton"
14:38:36 <arw_> "makes me hungry"-spambots are bad...
14:38:42 <Axman6> heh
14:38:48 <shachaf> Add + to bit.ly links to see where they redirect.
14:39:16 <heatsink> arw_: Does that mean the spam was successful?
14:39:44 --- mode: mauke set -o mauke
14:39:46 <arw_> heatsink: unfortunately not, no croutons in sight. and no clean pan to make some :(
14:40:02 <arw_> otoh, there is parmesan in the fridge...
14:42:05 <brycelane_> So nobody here has any experience making a ghc cross compiler for a raspberry pi? In particular I'm stumped on building the terminfo package because it can't find ncurses.
14:43:03 <brycelane_> I've built ncurses with arm-linux-gnuaebihf-gcc and installed it to the aforementioned gccs sysroot, but no dice.
14:43:13 <catsup> is it possible to import a type and then define a Read instance on it by deriving it?
14:43:28 <mauke> yes, with standalone deriving
14:43:33 <heatsink> deriving instance Read T
14:43:42 <catsup> sweet
14:44:00 <fayy> http://en.wikipedia.org/wiki/Forward_chaining how is forward chaining usually implemented?  I imagine just give the system some initial data, and keep running it through until no new data is created
14:48:09 <heatsink> fayy: In some systems, it's possible to keep applying inference rules until a complete list of facts is generated.  GHC's type class inference does that.
14:49:19 <heatsink> The complete list of facts becomes the class constraint in a function type signature.
14:58:52 <fayy> heatsink: thanks!  I think I've got a better understanding of it ... been hearing "rules engine" on HN, and it sounds really interesting, but at the same time not that interesting :)  this was a good read https://nebrios.com/blog/implimenting-a-rules-engine-in-python
15:16:37 <dulla> rules engine?
15:18:36 <jophish> 11 our flight tomorrow, can anyone suggest something interesting to read/listen to/watch for some of it. I've got a couple of talks by edwardk and all of the haskell cast already
15:18:39 <fayy> dulla: that's what I said!
15:18:39 <jophish> hour*
15:20:03 <fayy> jophish: best thing for me is get prescription sedated ... and noise cancelling headphones :D  planes are really uncomfortable for me, and I can't really focus on anything
15:20:17 <acowley> jophish: A good novel
15:20:33 <acowley> "good" is optional
15:20:45 <dulla> So 50 shades of grey?
15:20:47 <gyaretto> jophish: There's a great podcast called Hello Internet.
15:21:20 <acowley> I guess reading that would make you feel more connected to modern society
15:21:38 <indiagreen> jophish: download Tekmo's blog
15:21:48 <dulla> So what's a rule engine, seperate from simply rules
15:21:55 <acowley> jophish: also download hackage
15:22:40 <gyaretto> jophish: If you have noise cancelling headphones, you could download a bunch of ASMR videos.
15:23:09 <jophish> fayy: got headphones :)
15:23:50 <jophish> dulla: I'll put it on the reading queue
15:23:53 <jophish> priority queue*
15:24:02 <jophish> gyaretto: I'll give that a look, thanks
15:24:09 <dulla> I have a better book for you, jophish
15:24:13 <gyaretto> :)
15:24:16 <dulla> 50,000 Shades of Grey
15:24:25 <jophish> That's more than my monitor can handle
15:24:27 <dulla> One thousand times better
15:24:49 <dulla> Let me give you the synopsis
15:25:07 <dulla> :t replicate
15:25:08 <lambdabot> Int -> a -> [a]
15:25:39 <dulla> > unwords . replicate 50000 $ "Shades of Grey"
15:25:40 <lambdabot>  "Shades of Grey Shades of Grey Shades of Grey Shades of Grey Shades of Grey ...
15:25:42 <ruukasu> mo monads mo problems
15:25:48 <jophish> gyaretto: asmr is full of odd stuff
15:25:49 <dulla> there you go, jophish
15:25:56 <dulla> 50000 shades of grey
15:26:02 <Welkin> there are some great asmr videos
15:26:17 <jophish> dulla: I'll just pipe that to espeak
15:26:29 <Welkin> I like the one where the woman roleplays a travel agent for a resot on the moon and mars
15:26:38 <Welkin> resort*
15:26:50 <gyaretto> jophish: There are a lot of "normal" ones. My favorite channel for those is Deep Ocean of Sounds.
15:27:01 <dulla> ?
15:27:24 <gyaretto> Welkin: Yeah, she made a second one.
15:28:04 <inaoe> Is there a proper term for `x` in `class Foo a b where x :: a`? Just underconstrained?
15:29:14 <acowley> inaoe: I'm not aware of a standard name for that
15:30:05 <acowley> inaoe: does such a declaration produce a warning?
15:30:11 <acowley> inaoe: I'd probably crib from that text
15:30:26 <inaoe> acowley: No warnings until you try to use it
15:30:53 <acowley> inaoe: It's something verbose about not all types appearing, isn't it?
15:31:13 <acowley> I'm not sure if underconstrained is the right word since there is no constraint in the declaration
15:31:36 <acowley> It interferes with inference because use-sites are underconstrained
15:31:48 <acowley> So you could just say words to that effect
15:32:44 <inaoe> Alright, thanks
15:33:32 <enthropy>  instance (a ~ ()) => Foo Int a where x = 1 -- is usable
15:34:40 <gwm_> Can someone help me with list comprehension?
15:35:17 <Hijiri> @let class BananaInt a where { bananaint :: Int }
15:35:17 <lambdabot>  .L.hs:163:1:
15:35:18 <lambdabot>      The class method âbananaintâ
15:35:18 <lambdabot>      mentions none of the type variables of the class BananaInt k a
15:35:37 <nerium> I'm trying to implement this calculator, but getting an error
15:35:37 <nerium> Can anyone tell me why and maybe how to fix it?
15:35:38 <nerium> https://gist.github.com/oleander/36d1c353800833aeae25
15:37:30 <nerium> Line 36 is actually 42 here
15:37:34 <HeladoDeBrownie> nerium, Bind's first argument is of the form Calculator x a, but you're trying to matching it against Result
15:38:04 <HeladoDeBrownie> Undefined :: Result
15:38:37 <HeladoDeBrownie> that's on line 44
15:39:03 <HeladoDeBrownie> (36 + 8 = 44)
15:39:35 <nerium> HeladoDeBrownie: Aha, that makes sense
15:40:07 <HeladoDeBrownie> gwm_, ask away, if someone knows they may respond
15:41:03 <nerium> HeladoDeBrownie: Any idea what I should write instead? I can't get it to work
15:41:42 <nerium> If I've "eval (Bind m f)"
15:42:02 <nerium> then I want to evaluate m, using "value <- eval m"?
15:42:21 <HeladoDeBrownie> nerium, you need some way to get the result out of the first argument. fortunately you have a way of doing that
15:43:00 <HeladoDeBrownie> err, i don't mean Result, by the way, i mean the Integer or what have you
15:43:20 <HeladoDeBrownie> because the function that's the second argument to Bind demands an Integer
15:43:20 <nerium> HeladoDeBrownie: Shouldn't a in "a <- eval m" be of type Integer?
15:43:33 <HeladoDeBrownie> mmm, looks like, yeah
15:43:55 <HeladoDeBrownie> wait no
15:44:01 <HeladoDeBrownie> because eval m :: Integer
15:44:14 <HeladoDeBrownie> so if you write what you just did you're likely to get a type error
15:44:17 <HeladoDeBrownie> oh
15:44:21 <HeladoDeBrownie> no it doesn't, sorry i'm confused
15:44:30 <HeladoDeBrownie> it's a Result, out of which you can get an Integer
15:44:40 <HeladoDeBrownie> either way the do statement you wrote is incorrect
15:44:49 <HeladoDeBrownie> s/can/might be able to/
15:44:59 <nerium> Exactly, so "eval m" should return a Result?
15:45:07 <HeladoDeBrownie> sure, i mean look at the type
15:45:15 <HeladoDeBrownie> eval :: Calculator Result Integer -> Result
15:45:46 <nerium> HeladoDeBrownie: Should "eval (Bind m f) = f 1" compile?
15:46:06 <HeladoDeBrownie> at a glance i think so
15:46:49 <nerium> HeladoDeBrownie: I'm just getting this
15:46:50 <nerium>    Couldn't match expected type âResultâ
15:46:51 <nerium>                 with actual type âCalculator Result Integerâ
15:47:00 <HeladoDeBrownie> what code is producing that?
15:47:14 <nerium> "eval (Bind m f) = f 1"
15:47:30 <m-r-r> Hello
15:47:44 <HeladoDeBrownie> oh, yeah, my mistake. f 1 will be a Calculator. but you want a Result
15:47:54 <m-r-r> Why can't cabal install several versions of the same package ?
15:48:30 <HeladoDeBrownie> m-r-r, do you know about sandboxes?
15:48:34 <Welkin> m-r-r: use a sandbox
15:48:40 <Axman6> m-r-r: it can, but it cannot currently install many instances of the same version, iirc
15:49:33 <nerium> HeladoDeBrownie: How would I make it pass then? Feels like I've tried everything :(
15:49:35 <HeladoDeBrownie> nerium, what way do you know of to get a Result from a Calculator? (look at your code)
15:50:23 <nerium> HeladoDeBrownie: Run eval on it?
15:50:27 <HeladoDeBrownie> nerium, yep!
15:50:39 <m-r-r> Axman6: "many instances" ? What are instances ? I thought builds failed because of some conficts in the versions requirements ...
15:50:53 <silver> m-r-r, http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
15:52:33 <m-r-r> silver: I use sandboxes :-) It helps a little but sometimes I still get strange error messages :-/
15:52:58 <HeladoDeBrownie> m-r-r, okay, i was just asking that in case that solved the problem you were having. is it that you want multiple versions of a given package in the same project?
15:53:11 <HeladoDeBrownie> basically, what is the actual problem?
15:53:48 <HeladoDeBrownie> i don't know how to answer why cabal *can't* but might be able to help sort out something that cabal will agree with
15:53:58 <nerium> HeladoDeBrownie: Almost there :) What now? https://gist.github.com/oleander/8bcef714bcc4faf0a9bf
15:55:07 <m-r-r> HeladoDeBrownie: cabal failed to build syb and unix-compat (i don't even know what these packages are) I configured it to use Stackage and now I'm trying to build anew ...
15:56:08 <HeladoDeBrownie> nerium, one or more of your types are either over- or underconstrained afaict
15:56:27 <HeladoDeBrownie> nerium, try replacing all mentions of Integer with type variables, including in Result (this will involve adding a parameter)
15:57:00 <HeladoDeBrownie> nerium, this may also require adding a Num constraint in eval
15:57:23 <HeladoDeBrownie> (and possibly elsewhere)
15:57:52 <HeladoDeBrownie> nerium, oh, although calculate is probably fine as it is
15:58:11 <Zer000> So I want to create a data type (something like this http://dpaste.com/25W44ZR) But I want that 'k' value to always have a function of type k -> k -> Int (a distance metric), how do I enforce this?
15:58:16 <m-r-r> Still doesn't works :-/ It fails at "Creating package registration file", without error messages
15:58:28 <glguy> nerium: Does "eval" have an explicit type signature that you didn't paste?
15:58:43 <HeladoDeBrownie> glguy, the paste contains its type signature
15:58:52 <HeladoDeBrownie> this one https://gist.github.com/oleander/36d1c353800833aeae25
15:59:13 <glguy> OK, I was looking at an error message paste
15:59:16 <nerium> glguy: It's eval :: Calculator Result Integer -> Result
15:59:21 <Axman6> Zer000: how are you going to use those functions as keys for the Map?
15:59:23 <heatsink> Zer000: You could define a type class with that function as a member
15:59:57 <heatsink> The keys have type k, not k -> k -> Int
16:00:38 <HeladoDeBrownie> Zer000, in cases like this you'll usually constrain the operations over the type rather than the type itself
16:01:05 <HeladoDeBrownie> Zer000, in fact i don't think your example compiles because the constraint is there and that's no longer supported (correct me if i'm wrong)
16:01:16 <Zer000> Axman6, oh no, k is not a function, but there should be a function to compare two k's and get an int. It's to see if that k value can fit into my bucket or not
16:02:07 <Zer000> I don't actually need that constraint there.
16:02:24 <heatsink> Zer000: class Metric k where distance :: k -> k -> Int
16:02:30 <Hijiri> you put the constraint in the inserting function
16:02:39 <Zer000> oh ok thanks heatsink
16:02:42 <Zer000> that will work
16:05:10 <Zer000> I have a related question: my distance metric will always compare a value of type k to a fixed value (it's the same per RoutingTable) so is it good design to put that fixed value into the data definition or just pass it in to distance every time?
16:05:52 <Zer000> basically a RoutingTable has an ID and if I want to store something in it, under a key, I need to see if that key is close to my ID and if it's not really close I might discard it.
16:06:14 <HeladoDeBrownie> Zer000, i'd make it a parameter of your constructor(s), yeah'
16:06:39 <heatsink> It isn't good to pass it in every time, because that interface would allow you to pass in different values
16:06:43 <nerium> HeladoDeBrownie: Did i miss anything? Feels like it getting worse :) https://gist.github.com/oleander/725c5bbdd281cec72877
16:06:56 <heatsink> ... it would not require you to always pass the same value
16:07:26 <HeladoDeBrownie> nerium, do you mind putting the error message after instead of before so it's easier to check line numbers
16:07:43 <gwm_> cartProd xs ys = [(x,y) | x <- xs, y <- ys]
16:07:51 <lpaste> glguy pasted ânerium  calculatorâ at http://lpaste.net/121416
16:07:54 <gwm_> How would I change this so it takes 2 int's not 2 lists
16:08:01 <glguy> nerium: I'd expect your type to look more like this
16:08:14 <Zer000> Ok. I was just thinking that putting it into the constructor would mean that it gets copied to every sub-Bucket (you would have noticed they're nested).
16:08:16 <gwm_> cartesian m n = [(m, n) |
16:08:34 <glguy> nerium: and then   eval :: Calculator a -> Maybe a, or similar
16:08:53 <Zer000> anyway thanks guys
16:08:55 <heatsink> gwm_: Can you give example values for m and n, and the value that cartesian m n should return for that example?
16:09:05 <nerium> glguy: Would it be possible to use the type signature I've now?
16:09:18 <HeladoDeBrownie> nerium, you added Num constraints where they weren't necessary, e.g., at addr. a good rule is to look to see if you actually use Num methods
16:09:28 <HeladoDeBrownie> nerium, that's not what causes the error, but it's something that could cause problems
16:09:31 <glguy> nerium: not productively
16:10:08 <HeladoDeBrownie> gah, sorry, dinner time. looks like glguy's got you at least
16:10:10 <nerium> HeladoDeBrownie: That make sense
16:11:19 <gwm_> heatsink: e.g. user would say 'cartesian 2 3' and it would output the cartesian [(0,0), (0,1), (0,2), (0,3), (1,0), (1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
16:11:31 <gwm_> heatsink: as if the inputs are coordinates for a grid
16:12:53 <heatsink> gwm_: If you have a list of all numbers from 0 to m, and a list of all numbers from 0 to n, you can use the cartesian function that you have
16:13:10 <heatsink> The list of numbers from 0 to n is [0..n]
16:13:28 <gwm_> ok i'll give it a go
16:14:37 <gwm_> So simple aha, thanks heatsink
16:15:33 <heatsink> you're welcome
16:27:33 <ReinH> > (\n m -> liftA2 (,) [0..n] [0..m]) 2 3
16:27:35 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
16:28:23 <heatsink> > (sequence `on` enumFromTo 0) 2 3
16:28:24 <lambdabot>  Occurs check: cannot construct the infinite type: m0 ~ (->) [m0 a]
16:28:24 <lambdabot>  Expected type: [m0 a] -> [m0 a] -> [a]
16:28:24 <lambdabot>    Actual type: [m0 a] -> m0 [a]
16:30:13 <mac10688> I believe this package would allow me to read raw memory from another process
16:30:15 <mac10688> https://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign.html
16:30:21 <heatsink> yes
16:30:31 <mac10688> sweet! thanks for the confirmation
16:30:44 <Rotaerk> I don't like Foreign
16:30:47 * Rotaerk is a xenophobe.
16:31:15 <heatsink> See the Storable class in Foreign.Storable for reading and writing memory
16:31:15 <mac10688> Is there another package that would allow me to read memory from another process?
16:31:33 <mac10688> I see it now heatsink
16:31:34 <mac10688> thanks
16:31:46 <mac10688> I was looking at marshaling but I wasn't too sure
16:31:53 <mac10688> this storable looks like what I want
16:32:16 <heatsink> Foreign is the low-level interface for reading and writing memory.  There may be useful higher-level packages.
16:32:28 <mac10688> Now that I know I can do this, I will definitely plan to use haskell for my next program
16:33:40 <heatsink> You can also call to/from C functions
16:33:52 <jmcarthur> mac10688: what do you mean by reading "from another process"?
16:34:07 <jmcarthur> mac10688: if you mean what it sounds like you mean, that's not possible with plain old Foreign
16:34:26 <jmcarthur> mac10688: you can read and write raw memory in your *own* process with Foreign
16:34:29 <Axman6> sounds like using shared memory...
16:34:40 <jmcarthur> oh if it's actually shared memory then this is fine
16:36:07 <Axman6> mac10688: what do you mean by "raw memory from another process"
16:41:15 <Zemyla> Hmm. Might there be a Monad instance for Sum f g if f and g are monads?
16:41:27 <mac10688> jmcaruther, oh yeah you are right. I guess I should look for more packages :(
16:41:34 <Axman6> sounds like a monad transformer to me
16:42:02 <jmcarthur> Zemyla: you mean   data Sum f g a = SLeft (f a) | SRight (g a)   ?
16:42:24 <Zemyla> Axman6: I think it would require an Adjunction between g and f.
16:42:36 <Axman6> oh sum
16:42:44 <Axman6> I would guess the answer is no
16:42:53 <Axman6> at least in the general case
16:43:26 <mauke> what would 'return' look like?
16:44:03 <jmcarthur> Zemyla: http://www.informatik.uni-bremen.de/~cxl/papers/icfp02.pdf
16:44:41 <Zemyla> That's why it would require an Adjunction.
16:44:48 <jmcarthur> you have to do some representation hiding to satisfy the laws, iirc
16:45:09 <Zemyla> mauke: It would be right-biased, like Either is.
16:46:05 <mhitza> is there a "hidden" function in parsec that will parse Text, not String?
16:46:35 <Axman6> Parsec is fairly agnostic about what the type being parsed is
16:48:09 <mhitza> Axman6, you're right; I've confused the input with SourceName which is a type alias to String
16:49:00 <HeladoDeBrownie> import Text.Parsec.Text (Parser) and use the Parser from there in the types of your parsers and you're basically all set
16:49:14 <HeladoDeBrownie> (for many use cases)
16:49:49 * hackagebot docopt 0.7.0.0 - A command-line interface parser that will make you smile  http://hackage.haskell.org/package/docopt-0.7.0.0 (ryanartecona)
16:52:29 <mhitza> any idea why I get an error of expected Maybe String http://lpaste.net/3221419067650867200 ?
16:53:28 <Welkin> :t length
16:53:29 <lambdabot> [a] -> Int
16:53:45 <glguy> mhitza: Because you used a string literal when you tried calling that function?
16:54:18 <glguy> mhitza: It'd help us if you showed the error and the code related to the error
16:54:46 <glguy> oh, sorry! My browser wasn't scrolled enough!
16:55:18 <HeladoDeBrownie> the string literal shouldn't affect that i think
16:55:27 <HeladoDeBrownie> mhitza, where did you get Parser from?
16:55:31 <Welkin> "In the second argument of âfmapâ, namely â(safeIndex [] 6)â"
16:55:48 <Welkin> what is the type of safeIndex?
16:55:56 <HeladoDeBrownie> Welkin, it's in the paste
16:55:57 <mhitza> HeladoDeBrownie, Text.ParserCombinators.Parsec
16:56:06 <HeladoDeBrownie> mhitza, that would likely be it. grab it from where i suggested above
16:57:17 <HeladoDeBrownie> type Parser = Parsec String () -- included from there
16:57:43 <HeladoDeBrownie> the Parser in Text.Parsec.Text is type Parser = Parsec Text ()
16:57:52 <Welkin> I thought Text.ParserCombinators.Parsec was the old API and only existed for backwards compatability
16:57:54 <mhitza> HeladoDeBrownie, that was exactly the issue thanks
16:58:09 <HeladoDeBrownie> Welkin, mhitza, i believe that's the case, yeah
16:58:11 <Welkin> use Text.Parsec instead
16:58:31 <mhitza> HeladoDeBrownie, can I still use the parsercombinators if I hid the Parser import from a qualified Text.ParserCombinators ?
16:58:51 <HeladoDeBrownie> mhitza, should be able to afair
16:59:15 <HeladoDeBrownie> although i've never used that module in particular, always Text.Parsec
17:00:15 <mhitza> HeladoDeBrownie, well idk; second time using Parsec and I don't even know the differences between the 2 submodules
17:01:41 <HeladoDeBrownie> it's as Welkin said
17:02:14 <HeladoDeBrownie> by the way i notice you'll be ending up with two layers of Maybe. if you don't care about the difference between Nothing and Just Nothing you can squash them with join
17:03:00 <mhitza> actually it will be a Maybe (Either ...)
17:03:16 <HeladoDeBrownie> ah, my mistake
17:07:13 <Zer000> how do I represent a 160 bit string, such as the result of a sha-1?
17:08:08 <EvanR> the digest package exports a Word160 which is just a vector of Word32
17:08:25 <EvanR> you can also use Word8s
17:08:45 <tomberek> .
17:08:53 <Zer000> EvanR, isn't that what bytestring does?
17:09:13 <EvanR> theres a few ways to do vector of Word8s one is ByteString
17:09:21 <EvanR> but 5 Word32 is better for hasing
17:09:29 <EvanR> hashing
17:09:45 <Zer000> Ah ok thanks
17:09:59 <Zer000> hang on what's a vector in haskell?
17:10:09 <HeladoDeBrownie> i think ByteString is supposed to be more efficient than general vectors of words, right? although i imagine that a type just for sha-1 can be even more so
17:10:28 <EvanR> bytestring is implemented with the same thing as unboxed vectors
17:10:35 <tomberek> in haskell-src-exts, is there a way to tranform a Pat into an Exp? Basically to traverse the Pat and convert the PVar's into Expressions? this would not be a total function due to things like PWildCard
17:10:38 <EvanR> behind the scenes
17:11:45 <EvanR> Zer000: Data.Vectors
17:12:31 <EvanR> also theres data Word160 = Word160 !Word32 !Word32 !Word32 !Word32 !Word32
17:13:39 <EvanR> probably throw unbox pragmas or something in there
17:14:23 <pacak> EvanR: recent ghc  will unbox those automagically.
17:14:30 <EvanR> awesome
17:14:31 <kadoban> Zer000: Doesn't whatever library you're using to do SHA1 for you already have a representation it spits out?
17:17:34 <Zemyla> Hmm. That;s why there's no ComonadPlus.
17:17:53 <Zemyla> extract comzero = undefined.
17:18:09 <dolio> ByteString is not actually the same as unboxed vectors.
17:18:15 <dolio> It's the same thing as Storable vectors.
17:18:33 <dolio> Which may or may not be important for you.
17:18:47 <dolio> ByteStrings use ForeignPtr, which is pinned memory.
17:19:17 <dolio> It cannot be moved by the garbage collector. So if you use a lot of them, and they stay around, you can get memory fragmentation, for instance.
17:19:40 <rpr> I have over a thousand constants in a single file, and it takes good few seconds to load it. is there a way to speed it up?
17:19:49 <rpr> that is in ghci
17:20:10 <rpr> by constant I men a top-level variable
17:20:17 <HeladoDeBrownie> dolio, is there a solution for it you just want to represents strings of bytes but don't care if it gets moved?
17:20:26 <EvanR> bytestring and storable vectors use storable arrays
17:20:46 <EvanR> HeladoDeBrownie: yeah, https://wiki.haskell.org/Arrays
17:21:14 <EvanR> but it seems from this page that not caring if it gets moved doesnt buy you anything
17:21:19 <dolio> Unboxed vectors can get moved.
17:22:04 <dolio> The issue with unboxed vectors would be if ByteString has some specific function you want.
17:22:17 <dolio> I think they lack a lot of the IO stuff.
17:23:22 <EvanR> doesnt buy you anything and has less functionality ;)
17:23:36 <dolio> It buys you not having heap fragmentation.
17:24:59 <randir> What's a nice way to check that a given string foo is the exact beginning of the string bar?
17:25:08 <dolio> You probably need a lot of byte strings to have problems with heap fragmentation, though.
17:25:25 <dolio> Some people have reported having it, though.
17:25:38 <randir> so it would return True for (check "abc" "abcde") but not for (check "abc" "aabcde")
17:25:48 <dolio> isPrefixOf
17:25:52 <randir> thanks
17:27:25 <randir> dolio: gotta love Haskell's library
17:28:04 <dolio> It has its moments.
17:30:39 <dashster18> In Haskell, does the Num typeclass essentially specify a Field?
17:30:49 <dolio> It's closer to a ring.
17:31:52 <dashster18> But I thought rings only have addition and multiplication defined on them
17:34:35 <int-e> dashster18: without abs and signum, Num is a ring with unit; once you have a unit, you also have a homomorphism from the integers into the ring - that's fromInteger.
17:34:51 * hackagebot morte 1.1.0 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.1.0 (GabrielGonzalez)
17:35:15 <int-e> But abs and signum in there are odd.
17:35:17 <Zemyla> dashster18: Rings have +, negate, and * defined on them.
17:36:16 <int-e> Fractional defines fields, still with an odd abs and signum thrown in.
17:37:18 <dashster18> Zemyla: What structure has +, negate, * and divide defined on them? Or can that be defined in a ring using repeated negate and addition?
17:37:53 <int-e> dashster18: there's no division in the Num class.
17:39:00 <dashster18> int-e: Derp, I should have looked at the definition :P
17:39:32 <Zemyla> dashster18: That's a division ring, and every finite division ring is a field.
17:41:27 <dashster18> Zemyla: Ah, good to know
17:48:20 <kaidelong> @hoogle [a] -> a -> Int
17:48:22 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
17:48:22 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
17:48:22 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
17:49:07 <HeladoDeBrownie> @type \a -> length . filter (== a)
17:49:08 <lambdabot> Eq a => a -> [a] -> Int
17:49:36 <kaidelong> > elemIndex 2 [1,2,3,2]
17:49:38 <lambdabot>  Just 1
17:50:34 <HeladoDeBrownie> hmm, arguably should be Nat. too bad that's not in base :P
17:50:45 <HeladoDeBrownie> same goes for (!!)
17:52:10 <cmccann> @quote cmccann demote
17:52:10 <lambdabot> cmccann says: personally I'm just waiting for an extension that demotes types to the value level, so that we can finally have natural numbers.
17:53:33 <acowley> Is there a channel for Cabal?
17:54:03 <dolio> cmccann: 7.10 has naturals, you know.
17:54:16 <int-e> acowley: try #hackage
17:54:19 <dolio> Value-level naturals.
17:54:24 <EvanR> if there is nobody knows about it obviously from the name
17:54:24 <cmccann> dolio: wait, really? I totally missed that.
17:54:26 <acowley> int-e: Thanks!
17:54:36 <dolio> They're in GHC.Natural for some reason, but yes.
17:54:50 <dolio> GMP bindings.
17:55:01 <exio4> is there anything that isn't in 7.10? :<
17:55:14 <cmccann> exio4: i don't think it has a pony
17:55:29 <EvanR> -XNoHaltingProblem
17:55:45 <exio4> right, that's for 7.12, no? :p
17:55:55 <int-e> acowley: though if you're just stuck writing a package description, #haskell should work as well.
17:56:31 <acowley> int-e: No, I'm okay with that
17:56:54 <acowley> I guess my question is actually a GHC question, but it comes up with cabal usage
18:04:46 <rpr> how do I auto-export all the identifiers I imported from a specific module??
18:05:14 <cmccann> rpr: use an explicit export list
18:05:21 <acowley> or
18:05:24 <cmccann> and put "module Some.Other.Module" in it
18:05:38 <acowley> import This.Other.Module (foo,bar,baz) as M
18:05:45 <acowley> Then just export module M
18:06:04 <acowley> You just need an explicit import list, then a module export
18:09:56 <kaidelong> ghci is not able to :list code I enter into the interpreter
18:10:05 <kaidelong> how do I configure it to store this for later?
18:10:17 <geekosaur> you don't
18:10:46 <geekosaur> it's a desk calculator, really; it cal load stuff to use in desk calculator mode but you can't use it as a programming editor or etc.
18:11:04 <geekosaur> hence editor modes which know how to use ghci as a desk calculator as you edit
18:11:05 <kaidelong> so I'd have to make some listi hack that has ghci store a map String -> String? =/
18:11:17 <rpr> I tried this.   module A (B) where    import qulified B s B
18:11:27 <rpr> and I got: Not in scope: type constructor or class `F'
18:11:50 <rpr> constructor or class B, even
18:12:22 <geekosaur> you might also look at whether ghci-ng (on hackage) can be modified to do that kind of thing; it's a testbed for future ghci improvements and I doubt they'd say no to such a thing, just don't have anyone with the time and interest to work on it
18:12:47 <geekosaur> rpr, you imported only the type, not the constructors. try module A (B(..)) where
18:13:42 <geekosaur> um, sorry, I seem to be misreading stuff today
18:14:14 <geekosaur> hm
18:14:21 <bofh> Hello! Does anybody know some library/tool to solve the 3D bin packing problem?
18:14:53 <geekosaur> you imported qualified, so you have to use the qualified name in the export list. also probably need the (..) if you want to export the constructors along with the type
18:15:00 <bofh> I've found lots of abstracts and whitepapers in google, but nothing specific
18:15:02 <geekosaur> so module A (B.B(..)) where ...
18:15:13 <bofh> perhaps there's something in hackage I missed?
18:15:50 <sclv> bofh: yeah doesn't seem likely we'd have that on hackage if you haven't seen it :-(
18:18:56 <bofh> http://hackage.haskell.org/package/citation-resolve-0.4.2/docs/Data-BinPacking.html
18:19:13 <sclv> right but that doesn't look like it has any 3d stuff
18:19:38 <sclv> there's a binpacking package as well, not just in MissingH
18:19:50 <sclv> but again it appears to be specialized for the classic problem
18:19:53 <bofh> yeah
18:35:52 <lpaste> echo-area pasted âA grouping funcitonâ at http://lpaste.net/121422
18:37:09 <echo-area> Hello, I wrote a function as in the above link, but it does not terminate at the 10th element of as.  How can I modify it to terminate?  Thanks
18:37:56 <glguy> echo-area: You should show us the argument you tried running it with
18:38:01 <glguy> damn, missed it again!
18:38:10 <echo-area> It is the code I run
18:38:15 <glguy> echo-area: If youw ant it to be lazy won't be able to left fold it
18:38:27 <glguy> foldl starts at the end of a list
18:38:42 <glguy> which is a problem for infinite lists
18:38:59 <echo-area> So I should use plain recursion?
18:39:54 * hackagebot MonadCompose 0.8.1.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.8.1.0 (JamesCandy)
18:41:16 <lpaste> glguy annotated âA grouping funcitonâ with âA grouping funciton (annotation)â at http://lpaste.net/121422#a121423
18:43:31 <echo-area> glguy: There are a few notations which I see first, I'll check their meanings.  Thank you
18:43:44 <echo-area> *for the first time
18:50:22 <kaidelong> > (2,100) > (1,200)
18:50:24 <lambdabot>  True
18:51:17 <liyang> Is there an existing combinator that's equivalent to this? wowo w wo = w *> wo <|> wo
18:52:31 <kaidelong> @@ hoogle type \w *> wo <|> wo
18:52:31 <lambdabot>  hoogle type \w *> wo <|> wo
18:52:52 <kaidelong> @hoogle type \w *> wo <|> wo
18:52:54 <lambdabot> Did you mean: \ Type (*> w (<|> wo wo))
18:52:54 <lambdabot> No results found
18:53:00 <kaidelong> ugh
18:53:07 <kaidelong> @@hoogle type \w *> wo <|> wo
18:53:20 <kaidelong> does lambdabot compose not work anymore?
18:53:29 <kaidelong> oh that's wrong anyway
18:53:41 <liyang> :t \ w wo -> w *> wo <|> wo
18:53:42 <lambdabot> Alternative f => f a1 -> f a -> f a
18:53:56 <liyang> @hoogle Alternative f => f a1 -> f a -> f a
18:53:57 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
18:53:57 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
18:53:57 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
18:54:03 <kaidelong> mmm
18:54:07 <kaidelong> well none of those are what you want
18:54:12 <liyang> Nope.
18:57:53 <geekosaur> @. hoogle type \ w wo -> w *> wo <|> wo
18:57:54 <lambdabot> Parse error:
18:57:54 <lambdabot>   Alternative f => f a1 -> f a -> f a
18:58:09 <geekosaur> sad
19:01:54 <Hijiri> @. unpl pl f x y z a b c = a x b y a z c
19:01:55 <lambdabot> f al be b c f = return (\ w -> (\ aa ad -> aa al ad be) c w ((\ o -> o) c)) c f b;
19:02:45 <f|`-`|f> you what Hijiri
19:02:56 <f|`-`|f> Also, do you like hitting things with anchors
19:03:26 <Hijiri> wrong character I think
19:03:53 <f|`-`|f> Do you know a Byakuren?
19:04:05 <Hijiri> I'm supposedly a byakuren
19:05:12 <Hijiri> murasa throws anchors
19:05:34 <scott> that pl output contains "((\ o -> o) c)" ... what?
19:06:03 <geekosaur> that pl output is even more insane than the usual pl output
19:06:10 <scott> unpl output, rather, I guess
19:07:00 <mac10688> btw, to those that were helping me earlier with the Foreign package to read other memory processes
19:07:08 <HeladoDeBrownie> geekosaur, it's not pl output you may notice
19:07:08 <mac10688> I found this package that I think will help me
19:07:09 <mac10688> https://hackage.haskell.org/package/Win32
19:07:29 <geekosaur> unpl of I'm afraid to ask what @pl produced
19:07:41 <HeladoDeBrownie> @pl pl f x y z a b c = a x b y a z c
19:07:42 <lambdabot> pl = const (((flip . (flip .)) .) . flip flip id . (liftM2 flip .) . flip . (flip .) . flip id)
19:07:43 <HeladoDeBrownie> woops
19:07:51 <scott> oh the humanity
19:07:54 <Axman6> mac10688: you never explained what you mean by "read other processes's memory"
19:08:04 <HeladoDeBrownie> i mispasted but on second thought maybe let's not
19:08:08 <mac10688> I want to read memory from a game
19:08:10 <mac10688> and create a bot
19:08:16 <geekosaur> (like I would not be surprised if @pl produced something that @unpl can't make any sense of...)
19:08:20 <mac10688> so I suppose I wanted to read another executable's memory
19:08:44 <Axman6> that's usually extremely hard to do in any program that doesn't explicitly allow you to do that; that's basically why we have operating systems, to avoid that happening
19:08:49 <Axman6> process isolation
19:08:54 <Hijiri> you could wrap around a C library for that
19:09:01 <mac10688> I've done it before with c#
19:09:13 <Hijiri> it's necessary for doing it to programs that are proprietary and don't have some mechanism for it
19:09:17 <mac10688> yeah I could but this package has the access to win32 that I want
19:09:34 <Hijiri> oh, I thought you were still looking for a solution
19:09:40 <Hijiri> because I didn't read
19:09:55 * hackagebot docopt 0.7.0.1 - A command-line interface parser that will make you smile  http://hackage.haskell.org/package/docopt-0.7.0.1 (ryanartecona)
19:09:59 <mac10688> oh lol, no worries. Thought I would come back with the solution I found
19:11:05 <kaidelong> Hijiri: it's certainly possible on windows, it's how game trainers and cheating tools work
19:11:13 <kaidelong> you have to invoke the OS to do it
19:11:28 <Hijiri> tensokukan does it with soku, I think
19:12:46 <mac10688> yeah my life long dream has to create a bot for a game. I was reading memory and such in C# but the lore of haskell has turned my head. I just feel that if I can get past reading the memory, I would appreciate haskell more as a programming language. I'm pretty excited about this.
19:13:55 <Hijiri> If you're serious about diving into haskell, I'd recommend going through a guide like https://github.com/bitemyapp/learnhaskell
19:14:06 <mac10688> i'm here
19:14:07 <mac10688> http://learnyouahaskell.com/higher-order-functions
19:15:45 <Hijiri> LYAH is good as an overview, I think, but it lacks exercises
19:15:53 <mac10688> oh #haskell-beginners, I'll go there too
19:16:04 <mac10688> ok I'll finish LYAH and then do the practice exercises
19:25:03 <emaczen> I want to define an enumeration of operators * / + - (just these for now)
19:25:06 <emaczen> How can I do this?
19:25:26 <emaczen> I am trying this: data Op = '* | '/ | '+ | '-
19:26:30 <geekosaur> (1) this is not lisp (2) `data` creates new constructors, not existing things
19:27:09 <geekosaur> what problem are you actually trying to solve? an "enumeration of operators" is not really a thing, but perhaps there is a sensible way to do whatever you actually intend
19:27:46 <hodapp> I wonder what Blender would look like if it weren't a giant monolithic... thingy.
19:34:03 <Axman6> emaczen: anything wrong with ops :: Floating a => [a -> a -> a]; ops = [(*),(/),(+),(-)]?
19:35:23 <fluvian> When I compile my program, it seems to stop running lazily when its output is not the terminal.
19:35:41 <fluvian> Any program actually. The simplest example is `main = interact id`
19:35:42 <emaczen> Axman6: I'm not sure -- I'm going to try to rephrase my question
19:36:03 <emaczen> geekosaur: I want to create simple algebra expressions via * / + 0
19:36:35 <HeladoDeBrownie> fluvian, what do you mean by "seems to stop running lazily"? what did you actually observe?
19:36:45 <emaczen> So for an expression I would define: data Expr = Const String | Var String | Expr Op Expr
19:36:55 <emaczen> I'm not really sure if the last one is correct
19:36:57 <fluvian> HeladoDeBrownie: it waits until the input is closed before outputting anything.
19:37:09 <emaczen> But, I need to define Op anyway
19:37:19 <fluvian> whereas if I run it using `runhaskell`, it processes each line as it comes through
19:37:31 <emaczen> I'm not really sure what to do from here.
19:39:09 <Axman6> emaczen: you probably want something like Binop Expr Op Expr
19:39:35 <Axman6> and just define Op as something like data Op = Add | Sub | Mul | Div | Custom String
19:39:42 <emaczen> Axman6: In that last part of the data definition?
19:39:46 <HeladoDeBrownie> fluvian, i failed to reproduce that
19:39:50 <Axman6> emaczen: yeah
19:39:57 <emaczen> Axman6: cool
19:40:04 <HeladoDeBrownie> fluvian, please give instructions for what you tried
19:40:36 <emaczen> Axman6: What is Custom String?
19:40:44 <HeladoDeBrownie> fluvian, if necessary, lpaste it
19:40:56 <HeladoDeBrownie> along with the code you tried (even if it was just main = interact id)
19:41:19 <Axman6> emaczen: in case your language lets you define new infix operators =)
19:41:41 <fluvian> interesting. I'm running GHC 7.8.3 on Darwin 14.1.0 btw
19:41:58 <emaczen> Axman6: I know what infix means, but can you clarify?
19:42:09 <emaczen> maybe with an exaple of Custom String
19:42:11 <Axman6> > let x %$%^ y = (x*x+y*y)/(x+y) in 7 %$%^ 13
19:42:13 <lambdabot>  10.9
19:42:40 <geekosaur> emaczen: it makes little sense to try to use an actual operator in an AST, since even if it were allowed it would mean ugly quoting everywhere. you could however have (say) a Map from Binop to operator, e.g. fromList [(Add,(+)), (Mul,(*))] etc.
19:42:43 <emaczen> So we could print that without the %$s?
19:42:56 <HeladoDeBrownie> fluvian, i wouldn't be terribly surprised if it were an os x quirk
19:43:09 <Axman6> well, assuming you're definig a new language, you would allow users to create their own operators
19:43:12 <HeladoDeBrownie> that said i know little about os x since i've never used it
19:43:20 <fluvian> I just saved `main = interact id` to a file called main.hs, then compiled with `ghc main.hs`, then ran `./main | cat`
19:43:38 <HeladoDeBrownie> okay, will try that, one moment
19:43:49 <fluvian> then I tried typing lines into the stdin, and nothing was printed until I typed EOF
19:43:49 <geekosaur> fluvian: Unixlikes do block buffering on non-terminals by default
19:44:14 <fluvian> geekosaur: I wasn't aware, is there a workaround?
19:44:36 <HeladoDeBrownie> with interact not likely. but normally you can hSetBufferingMode
19:44:42 <geekosaur> import System.IO and add a call somewhere early in main: hSetBuffering stdout LineBuffering
19:44:45 <fluvian> I thought it might be a haskell issue since I wrote the program in go with no problems
19:44:47 <HeladoDeBrownie> err, yeah, that
19:45:02 <fluvian> OK I
19:45:05 <fluvian> I'll give that a shot*
19:45:17 <HeladoDeBrownie> interact, in practice, isn't terribly useful anyway
19:45:20 <geekosaur> I'm not sure why runhaskell defaults differently
19:45:29 <EvanR> so you learned nothing from your experience with go ;)
19:45:52 <geekosaur> (but this has been observed before; I suspect it's some code shared with ghci which assumes that any interactive session ought be line buffered)
19:45:58 <fluvian> EvanR: what, that I should be using go instead?
19:46:12 <HeladoDeBrownie> EvanR, honestly i'd prefer not having to mess with the quirks of whatever os i'm running. oses are terrible :P
19:46:45 <EvanR> you eventually will run into buffering issues on any system if youre doing low level stuff
19:46:57 <EvanR> knowing about it is essential imo
19:47:03 <EvanR> like knowing how floats work
19:47:14 <Axman6> no one should be using go instead of anything
19:47:16 <Axman6> :(
19:47:20 <HeladoDeBrownie> in a perfect world i don't care to have to know about either of those things
19:47:56 <EvanR> in a perfect world not only is your fancy ruby web app correctly logging debug info in reasonable time, but your fancy ruby app was already made for you
19:48:02 <EvanR> neither are true a lot of times
19:48:41 <HeladoDeBrownie> that's just the thing, whatever we envision as a perfect world, we may never actually reach it, but we can optimize the world we do live in to be more like it
19:48:50 <HeladoDeBrownie> and "this program already exists" can be realized by writing that program :)
19:49:04 <Zemyla> You know, $ should be a method of a Function class, so it can be used on various wrapped functions.
19:49:10 <fluvian> geekosaur: the hSetBuffering fix works. thanks for your help!
19:49:26 <EvanR> im just saying if 1/100 systems nicely guess at what kind of buffering you want, and you refuse to use 99 of them for that reason, or choose to be confused by them, thats not good
19:49:33 <EvanR> youre stuck on that system
19:49:48 <Zemyla> class Function f a b | f -> a b where ($) :: f -> a -> b
19:50:19 <HeladoDeBrownie> Zemyla, i'd prefer overloaded juxtaposition, but maybe that's going too far ;)
19:50:23 <EvanR> vice versa if the default was line buffering you might want to set it to block buffering for performance reasons
19:50:47 <EvanR> as far as performance issues go that topic is ridiculously simple
19:51:59 <EvanR> also, in order to model perfect worlds you might have to interact with the horrible real world, which is what im currently doing with keyboard codes
19:52:14 <HeladoDeBrownie> EvanR, good luck with that :P
19:52:52 <fluvian> as a bonus, I can still use interact after setting the buffer, although I realize it is a fairly pointless function :)
19:53:38 <EvanR> stuff like interact is good because its behavior is so well defined that if you ever see it in the wild you wont have to read pages of imperative code to understand whats going on
19:53:44 <HeladoDeBrownie> interact (\s -> â¦ unsafePerformIO â¦) -- now everything is possible
19:53:45 <HeladoDeBrownie> :P
19:54:10 <EvanR> interact in particular might never be in real use though, but the idea of something which is very specific in behavior shows up a lot in haskell
19:54:23 <HeladoDeBrownie> just kidding, you'd be better off writing a function like interactIO :: (String -> IO String) -> IO ()
19:54:34 <EvanR> s/dont have to read pages of code/only have to grep for unsafePerformIO/ ;)
19:55:26 <HeladoDeBrownie> although that still fails to correct abstract over concurrency. hmm, how can we improve this furtherâ¦
19:55:29 <HeladoDeBrownie> correctly*
19:55:48 <EvanR> how to correctly do X -> dont use IO ;)
19:55:50 <HeladoDeBrownie> (i'm just thinking aloud, you may not need concurrency :P)
19:56:13 <HeladoDeBrownie> EvanR, yeah, i kinda feel like the rest of my haskell program should be a compiler whose target language is IO
19:57:23 <EvanR> how to do X when the search for the right way prematurely terminates -> use IO
19:57:31 <HeladoDeBrownie> XD
19:59:02 <HeladoDeBrownie> IORefs and recursion are the only tools one needs /s
20:00:00 * hackagebot morte 1.1.1 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.1.1 (GabrielGonzalez)
21:30:04 * hackagebot clustering 0.1.0 - fast clustering algorithms  http://hackage.haskell.org/package/clustering-0.1.0 (kaizhang)
21:36:43 <pavonia> :pl \fs x y -> map (\f -> f x y) fs
21:36:51 <pavonia> @pl \fs x y -> map (\f -> f x y) fs
21:36:51 <lambdabot> flip (flip . (map .) . flip . flip id)
21:38:52 <Axman6> :t \fs x y -> zipWith3 id fs (repeat x) (repeat y)
21:38:54 <lambdabot> [b -> c -> d] -> b -> c -> [d]
21:39:50 <L8D> @pl (\f -> f x y)
21:39:50 <lambdabot> flip ($ x) y
21:39:54 <L8D> -.-
21:40:34 <Axman6> :t toZipList
21:40:35 <lambdabot> Not in scope: âtoZipListâ
21:40:40 <Axman6> :t ZipList
21:40:41 <lambdabot> [a] -> ZipList a
21:43:01 <jle`> Axman6: zipWith3 id fs (repeat x) (repeat y) sounds like map (\f -> f x y) fs
21:43:10 <pavonia> > (\fs x y -> id <$> fs <*> [x] <*> [y]) [(+), (-), (*)] 2 3
21:43:11 <lambdabot>  [5,-1,6]
21:43:36 <pavonia> That id is confusing
21:43:51 <jle`> you can ap it away
21:44:16 <jle`> > (\fs x y -> fs <*> pure x <*> pure y) [(+),(-),(*)] 2 3
21:44:18 <lambdabot>  [5,-1,6]
21:44:26 <Axman6> @hoogle f (a -> b) -> a -> f b
21:44:29 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
21:44:29 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:44:29 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:44:42 <SrPx> Hello, I can make Linear functions work with many types. Lists, for example: "[1,2] ^+^ [3,4]" works just fine. But, for some reason, "(1,2) ^+^ (3,4)" doesn't work. Why
21:44:50 <jle`> also it should be somewhat clear that f <*> pure x = map ($ x) f
21:44:53 <jle`> er, fmap
21:45:07 <jle`> SrPx: is that from the Linear library?
21:45:11 <pavonia> jle`: I like that last one
21:45:12 <jle`> do you have a type error for us? :)
21:45:15 <Axman6> SrPx: what is ^+^'s type and what result do you expect?
21:45:55 <SrPx> ^+^ is just vector sum, (^+^) :: (Additive f, Num a) => f a -> f a -> f a ... the type error is that there isn't an additive instance to (,). I'm just wondering why there is an additive instance for lists, even maps, but not (,) ?
21:46:24 <Axman6> well, (,) has kind * -> * -> *, the others have * -> *
21:46:30 <jle`> bingo
21:46:33 <Lokathor> ^+^ is the one of the happiest operators
21:46:44 <SrPx> Lokathor: no, it is ^-^
21:46:53 <SrPx> (^-^) :: (Additive f, Num a) => f a -> f a -> f a
21:46:57 <Lokathor> "one of" /= "the"
21:47:32 <jle`> SrPx: what could you possibly expect to put in for `f` that would make (^+^) :: Num a => (a, a) -> (a, a) -> (a, a) ...?
21:47:33 <SrPx> on linear, ^ indicates that the corresponding side is a vector, so ^- is vector minus scalar and so on
21:47:57 <Axman6> but (,) isn;t a vector really
21:48:07 <Axman6> it's a product of two potentially different types
21:48:21 <SrPx> Ah fair enough. I see...
21:48:59 <SrPx> So, in order to use Linear function with Gloss's Point (type Point = (Float,Float)) I have to use V2 and convert when needed?
21:49:33 <SrPx> or is there any clever trick that allows me to use a single type?
21:50:40 <jle`> you could stay in V2 and just go to gloss when necessary :) i think there might be a lens for that
21:50:58 <Axman6> newtype Both a = Both (a,a); instance Additive a => Additive (Both a) where ... ?
21:51:03 <Axman6> I could be wrong
21:51:21 <Axman6> "There's a lens for that"
21:51:52 <jle`> but yeah, haskell's type system doesn't let us find a way to use (Float,Float) as an Additive
21:52:13 <jle`> you'd have to newtype it the way that Axman6 did, but that newtype is basically V2 anyways
21:53:09 <SrPx> Okay I will just do what you said then :)
21:53:48 <SrPx> wouldn't it be better if gloss used V2, though? is there any downside in doing so?
21:54:44 <Axman6> Gloss came from an introductionary CS course and is designed to be extremely simple for people with only basic haskell knowledge
21:54:56 <Axman6> and I believe it's also supposed to have few deps
21:56:14 <Elision> what does the bar notation mean in: class (Monad m) => MonadState s m | m -> s where
21:56:50 <glguy> Functional dependency, It means that the type m fully determines the type s
21:57:03 <Elision> interesting
21:57:09 <SrPx> Axman6: ah I see.
21:57:32 <SrPx> Quick unrelated question, I've been writing "forM_ [0..10] \ $ i -> do" too much... is there a shortcut for it ?
21:58:21 <jle`> not that i know of.  although i wish we could be able to write things like that w/out the $
21:58:24 <haasn> SrPx: Not sure how much shorter you want it to be
21:58:26 <Axman6> Elision: it's there so thhat you can't define MonadState s (State s) and MonadState Foo (State s); the state that you can access within m should be determined by m
21:58:42 <Elision> yeah
21:58:51 <Elision> just not clear where that comes in when writing instances
21:59:05 <haasn> SrPx: What could possibly be shorter than forM_ [0..10] while still making sense?
21:59:21 <Elision> whether this restricts what instances you can write that typecheck, or opens up more possibilities
21:59:25 <Lokathor> i tried to install gloss just now
21:59:28 <Lokathor> it could not :(
22:00:03 <glguy> Elision: It does both, actually. It makes some instances that would have been ambiguous possible, and it makes some that would conflict with the functional dependency impossible
22:00:15 <Lokathor> I am cursed to never install any haskell package that uses a C binding while on windows
22:00:25 <Elision> oh, cool
22:01:09 <jle`> SrPx: btw i was wrong, there does not seem to be a lens for that
22:01:10 <glguy> Well, perhaps it's that it makes some classes possible to write that would have been ambiguous while it reduces the possible instances for a given class
22:01:35 <SrPx> jle`: that is actually relieving to know
22:01:43 <SrPx> haasn: yea you are right, I couldn't think in anything better
22:01:59 <jle`> you could make your own though
22:02:20 <haasn> SrPx: Instead consider if you want to set up a small macro or shortcut or something to insert precisely that sequence for you :)
22:02:20 <jle`> :t iso (\(x,y) -> V2 x y) (\(V2 x y) -> (x, y))
22:02:22 <lambdabot> Not in scope: data constructor âV2â
22:02:22 <lambdabot> Not in scope: data constructor âV2â
22:02:26 <jle`> sorry i tried
22:03:08 <Axman6> @let data V2 a = V2 a a
22:03:11 <lambdabot>  Defined.
22:03:18 <Axman6> :t iso (\(x,y) -> V2 x y) (\(V2 x y) -> (x, y))
22:03:19 <lambdabot> (Profunctor p, Functor f) => p (V2 a) (f (V2 t)) -> p (a, a) (f (t, t))
22:03:44 <Axman6> :t iso
22:03:45 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
22:03:50 <jle`> @let tupv2 = iso (\(x,y) -> V2 x y) (\(V2 x y) -> (x, y))
22:03:52 <lambdabot>  Defined.
22:03:56 <jle`> :t to tupv2
22:03:57 <lambdabot> (Contravariant f, Conjoined p, Profunctor p1, Functor f1, Functor f) => p (p1 (a, a) (f1 (t, t))) (f (p1 (a, a) (f1 (t, t)))) -> p (p1 (V2 a) (f1 (V2 t))) (f (p1 (V2 a) (f1 (V2 t))))
22:04:03 <Axman6> heh
22:04:09 <jle`> huh that's the least helpful type signature
22:04:14 <jle`> :t view tupv2
22:04:15 <lambdabot> MonadReader (a, a) m => m (V2 a)
22:04:47 <jle`> > review tupv2 (V2 1 3)
22:04:49 <lambdabot>  (1,3)
22:05:07 <jle`>  > view tupv2 (V2 1 3) would be (1, 3), but there's no Show instance for V2 so that's just going to be a bust demonstration
22:05:24 <jle`> not as we defined it earlier at least, oh wel
22:09:36 <fluvian> Are there any particularly well-designed Haskell modules you'd recommend studying for insight into the design of larger programs? Are XMonad and pandoc reasonably idiomatic and modern?
22:10:56 <glguy> jle`: Thanks for writing a bunch of stuff in a row. It made a good screenshot for testing (temporary) /ignore support ^_^ http://imgur.com/w4d0Z7S
22:11:28 <dmj`> fluvian: what are you trying to build?
22:11:33 <SrPx> points <- forM [0..10] (const (fmap (* screenSize) (V2 <$> randomIO <*> randomIO))) -- what would be your approach to get this to work? Where/how would you add the type annotation?
22:11:36 <EvanR> fluvian: gui applications doesnt seem to be the most common use case for haskell at the moment, but as far as those go this seems to be the biggest one, that i know of http://hackage.haskell.org/package/manatee
22:12:29 <fluvian> dmj` nothing yet, I just want to get a feel for how the language is used on large-scale projects. my experience is largely limited to tutorials and toy examples.
22:14:15 <dmj`> fluvian: I wrote a lot of haskell code for a SaaS company I started that failed, I open sourced it
22:14:24 <dmj`> fluvian: https://github.com/dmjio/SolidTranslate
22:14:37 <dmj`> website, 2 dbs, background worker, front end, etc
22:15:23 <dmj`> fluvian: only thing I'd change is to use a thread pool w/ acid-state
22:15:49 <fluvian> cool, what does the app do? no readme :P
22:16:48 <jle`> my pleasure glguy :)
22:17:26 <dmj`> It allowed users to upload CAD files, which would be stored in S3. After a successful upload a message was placed on a queue, and a background worker running windows would read the queue message, pull the file down, spawn a process that run a windows app to perform the translate, then reuploaded the completed file, charged the customer's stripe account, and sent them an email (ses)
22:17:36 <dmj`> would*
22:17:37 <f|`-`|f> What? dmj`
22:17:49 <dmj`> the*
22:17:57 <dmj`> reupload*
22:17:59 <dmj`> sorry it's late
22:18:42 <dmj`> we had a great product, unfortunately to get legal clarification it cost like a million bucks, so who's gonna raise money under those circumstances
22:18:59 <f|`-`|f> So it's a cad site for what
22:19:00 <dmj`> fluvian: it also uses websockets too
22:19:12 <dmj`> it solved the solidworks backwards compatability issue
22:19:22 <dmj`> we used their api to deconstruct geometry
22:19:30 <dmj`> and reconstruct in any version, forward or back
22:19:54 <dmj`> it's a windows company, new versions are just lipstick on a pig, the api isn't changing, just the gui, and they charge like $5k a license, it's criminal really
22:20:00 <f|`-`|f> So it was a cad conversion site?
22:20:08 <dmj`> yes, fully automated
22:20:19 <f|`-`|f> perfect conversion
22:20:25 <f|`-`|f> with a stipend per file
22:20:46 <fluvian> hey cool I've never seen a haskell implementation of websockets
22:21:58 <dmj`> almost :) that was my partner's job, he outsourced a lot of his work to a developer in ukraine, but worked with her. He did it in C#, probably should've used C++. He had no formal training in algorithms, but that doesn't really matter, the api is just a tree you traverse. The haskell worker would spawn his C# worker, which would spawn SolidWorks. 2 levels deep. His C# app spit json back over stdout, I'd parse, then charge, and upload
22:22:14 <carter> dmj`: the biz failed? boooo
22:22:17 <dmj`> it wasn't perfect
22:22:24 <EvanR> fluvian: there was a really good way a while back
22:22:30 <EvanR> a really good one
22:23:17 <f|`-`|f> websockets?
22:23:38 <EvanR> fluvian: it stopped building though, but now there is websockets support for all the haskell web front ends
22:24:21 <dmj`> carter: It could have worked, but what VC in their right mind would give you $1M just for legal clarification? What I didn't anticipate was that SolidWorks was essentially a legal company (w/ inhouse team), they were acquired in the 90's and were just a revenue generating arm. No innovation allowed basically. Got probono legal from an SF lawyer and he gave me the low down.
22:24:46 <carter> legal clarifciation what?
22:25:25 <dmj`> the EULA was vague in regards to API usage, intentionally. They said they wouldn't interpret it for us, that it was the job for the courts
22:25:46 <carter> but DMCA
22:25:54 <carter> fair use + reverse engineering
22:26:15 <fluvian> EvanR: OK, I've been reading through Yesod a little. Wish it didn't rely so heavily on TH but it seems like a solid program anyway
22:26:19 <dmj`> fluvian: haskell shined though, when we changed our pricing logic from per file to subscription the type system saved us an enormous amount of work
22:26:23 <f|`-`|f> th?
22:26:40 <fluvian> f|`-`|f:  template haskell
22:26:45 <L8D> is there a function that combines find and map?
22:26:46 <f|`-`|f> mm
22:26:48 <Yaniel> carter: wouldn't this fall under interoperability
22:26:54 <f|`-`|f> hmmm
22:27:00 <carter> Yaniel: backups
22:27:01 <f|`-`|f> probably under data.map or something
22:27:07 <carter> youre always allowed to make backups of data
22:27:08 <L8D> @hoogle (a -> Bool) -> (a -> a) -> [a] -> [a]
22:27:08 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:27:08 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
22:27:08 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:27:18 <EvanR> L8D: find . map ?
22:27:23 <f|`-`|f> lol
22:27:34 <L8D> EvanR: I want to modify only a single element of a list
22:27:41 <dmj`> carter: it's the fact we have a license, and they can tell us how we *have* to use it. If it affects their bottom line adversely you're done. Period.
22:27:59 <L8D> EvanR: where the single element is determined in a find-style manner
22:28:01 <f|`-`|f> either go to the T/MVars, IORef, or some kind of IO Array
22:28:22 <carter> dmj`: whereas if you had reverse enginered stuff and didnt' dep on any of their software
22:28:27 <carter> you'd have bene in the clear?
22:28:38 <EvanR> L8D: yeah data.list itself doesnt have a lot of these things that you usually use a more suitable structure for
22:29:15 <dmj`> carter: they explicitly outlaw reverse engineering in the EULA, they were explicity on some things :) but the usage of their free API, not so much. It really comes down to interpretation and tbh it could have gone either way, I'm not gonna pay to find out though
22:29:24 <dmj`> explicit*
22:29:41 <carter> dmj`: well, if you didn't own the product, you'd not be subject to the EULA
22:30:03 <carter> "people sent us fles  + pictures of how solid works rendered the files"
22:30:17 <carter> but yeah, not as easy to build :)
22:30:24 <dmj`> carter: we did, the api isn't usable without the solidworks process running, we bought a license from them, legitimately.
22:31:33 <dmj`> We had websockets printing out every phase of conversion too :) ugh. Windows http-client would post the snap server on unix which would grab the web socket connection from the mvar, encode the bytes and send em' down. It was hot
22:31:40 <dmj`> to the*
22:31:53 * dmj` gets nostalgic
22:32:16 <carter> dmj`: whatcha doing now
22:32:29 <dmj`> flippin' burgers
22:32:38 <f|`-`|f> So
22:32:42 <carter> is that code for ruby?
22:32:47 <f|`-`|f> the fuck is websockets
22:32:59 <dmj`> jk, I'm building a social media rest api for a music company w/ snap, dynamo, redis
22:33:02 <dmj`> carter: ^
22:33:06 <Yaniel> f|`-`|f: like... sockets in javascript
22:33:11 <carter> noice
22:33:16 <f|`-`|f> try again
22:33:44 <Lokathor> a socket sends bytes over the network
22:34:01 <EvanR> a websocket sends messages
22:34:12 <EvanR> which are text strings
22:34:44 <EvanR> way easier than sockets
22:35:05 <Lokathor> fancy
22:35:16 <Lokathor> i was not previously clear on what the distinction was
22:36:19 <EvanR> UDP also sends messages but people are scared of losing some of them ;)
22:36:44 <Lokathor> starcraft used UDP
22:36:50 <L8D> aren't sockets just unix streams with some polling tacked on?
22:36:53 <Lokathor> rather, it was one of the options you could use
22:37:07 <L8D> you could use read and write in place of recv and send in most cases
22:37:09 <EvanR> polling, gross
22:37:22 <L8D> but recv and send take some funny options
22:37:28 <L8D> or how to work with packets
22:37:33 <L8D> but in most cases it doesn't matter
22:37:45 <L8D> otherwise, they're unix streams
22:37:49 <Lokathor> L8D, in that you can both read from and write to a socket that you have one end of, yes a socket is like a unix stream sorta
22:37:50 <EvanR> Lokathor: yes, the game is simulated by all players simultaneously and the only communication is the players button presses
22:37:51 <L8D> nothing hard bout' them
22:38:09 <EvanR> try implementing websockets with sockets
22:38:26 <L8D> exactly
22:38:32 <L8D> websockets are way harder than sockets
22:38:34 <EvanR> ...
22:39:06 <L8D> websockets is more a protocol anyways
22:39:20 <L8D> it's like implementing http with sockets
22:39:23 <L8D> they
22:39:36 <L8D> there is a specification for web sockets
22:39:42 <L8D> I'm tired
22:39:56 <Lokathor> EvanR, really? Don't they need to send unit positions around occasionally in case a click or key got dropped and the simulations arn't aligned any more?
22:40:00 <taktoa> there should be a unix utility that ties a unix socket to a websocket connection
22:40:02 <taktoa> or something
22:40:06 <EvanR> when you `read' a stream socket, it will block until all the desired number of bytes are accumulated. if your application protocol has messages of a variable length, this means you need to do buffering and analysis to reconstruct the message
22:40:17 <EvanR> you may not know how many bytes you want
22:40:29 <EvanR> in any case, you need concurrency to work while its waiting
22:40:42 <EvanR> with websockets you get a message, thats all
22:40:48 <Fylwind> does anyone know if there's an 'exec' equivalent in Haskell?  There seems to be 'executeFile' in the 'unix' library but nothing for Windows AFAIK
22:41:26 <kristikodare> runHaskell?
22:41:42 <kristikodare> oh
22:41:52 <EvanR> Fylwind: System.POSIX ?
22:42:00 <kristikodare> System.Cmd?
22:42:00 <f|`-`|f> So
22:42:01 <L8D> EvanR: that's because websockets splits things up into messages
22:42:10 <f|`-`|f> Run concurrently on the stream? Or what, EvanR
22:42:19 <EvanR> L8D: yes it does the messages for you
22:42:51 <EvanR> f|`-`|f: for example in haskell you use a forkIO to read blocking on the Handle while the rest of the app goes on
22:43:00 <L8D> EvanR: with most transfer protocols you have to do that
22:43:06 <f|`-`|f> ah
22:43:15 <f|`-`|f> you concurrent to avoid haltng the whoel program
22:43:23 <L8D> EvanR: with HTTP, FTP, etc. you need to buffer things up and use concurrency to reconstruct messages
22:43:34 <EvanR> L8D: its easier for an application to use messages than to come up with a way to reconstruct messages on a stream socket
22:43:56 <L8D> okay.
22:44:02 <EvanR> and manage concurrency, and encryption, and text encodings
22:44:09 <EvanR> and event handling
22:44:18 <L8D> Makes sense, but personally I think unix sockets are 'simpler' though less practical to use.
22:44:55 <L8D> because in the context I'm referring to, you're purposefully not using messages
22:44:56 <EvanR> well if you ignore everything about sockets exception read, write, and close, yeah they are simpler and hard to use for messages
22:45:26 <EvanR> but they rest of the api that goes into sockets is very tedious
22:45:42 <fluvian> L8D: did you figure out your find map thing?
22:45:48 <L8D> fluvian: not really
22:45:54 <L8D> fluvian: just did a custom map
22:45:55 <lpaste> fluvian pasted âmapFirstâ at http://lpaste.net/121431
22:45:58 <EvanR> L8D: what is the protocol you have in mind
22:46:08 <lpaste> fluvian pasted âmapFirstâ at http://lpaste.net/121432
22:46:27 <fluvian> OK the second one probably does what you want
22:46:47 <fluvian> couldn't find a library function
22:47:27 <L8D> EvanR: utilities like netcat and so on...
22:47:41 <L8D> EvanR: just moving existing unix things to networks
22:48:01 <EvanR> L8D: yeah, netcat is a lot more complex to implement that a message based application
22:48:10 <L8D> EvanR: are you kidding?
22:48:11 <EvanR> in a browser
22:48:18 <fluvian> ^
22:48:30 <L8D> ooooooooooooooooooooooooooh
22:48:32 <fluvian> that's why websockets are useful, because you can easily write a javascript app that uses them
22:48:35 <EvanR> look at the code for netcat
22:48:51 <EvanR> fluvian: or a haskell app
22:48:54 <L8D> netcat is like 100 lines of C
22:49:16 <L8D> *not* on the web
22:49:19 <fluvian> EvanR: yeah, but you could say the same for regular sockets :P The big advantage of websockets is that browsers support them
22:49:37 <EvanR> netcat is 1667 lines of C
22:50:05 <fluvian> EvanR: is it really? shit. I would have thought it would just be a couple system calls to open up sockets and pipe them together
22:50:13 <L8D> you need like 10 lines for the client, 50 lines for the server and 40 lines for other shit and finding the -l flag
22:50:16 <EvanR> fluvian: if you havent used these two apis extensively, you should and then tell me which one is easier to use ;)
22:50:38 <EvanR> L8D: there are a lot of details involving sockets and unix
22:51:04 <L8D> EvanR: there is some boilerplate in establishing connections and hosting on sockets
22:51:16 <EvanR> yeah thats probably a minority of the application
22:51:27 <EvanR> and that boiler plate is quite extensive
22:51:33 <L8D> EvanR: outside of that, you're writing idiomatic C code
22:51:34 <EvanR> especially for generic ipv6 support
22:51:45 <EvanR> L8D: ok youre the expert
22:51:57 <L8D> EvanR: I am?
22:52:08 <EvanR> you must be since everything is easy ;)
22:52:48 <Fylwind> EvanR: right, System.Posix.Process.executeFile; I was wondeirng if there's an equivalent for Windows (without having to manually FFI it myself)
22:53:01 <EvanR> Fylwind: do you want to fork a process?
22:53:24 <Lokathor> where might a person go for advice on using stackage?
22:53:25 <Fylwind> EvanR: no, I want to 'exec': replace the current process image with another
22:53:46 <EvanR> Fylwind: well, its probably easier to step back and use System.Process to do the forking too
22:53:57 <EvanR> it has windows support (supposedly)
22:54:12 <Fylwind> EvanR: I don't want to do any fork though
22:54:20 <SrPx> whyyyy can't ambiguous occurrences just be disambiguated by type t_t
22:54:33 <EvanR> Fylwind: im not sure if windows has the concept of replace current program
22:55:12 <Fylwind> EvanR: I see
22:55:15 <EvanR> what youre trying to do can be simulated by creating a process and just ending the parent
22:55:43 <jle`> SrPx: btw i never got a chance to reply to your reddit thread about numerical algorithms properly...well i replied to a comment of yours i think but not to the main question heh.  my answer is usually no because i often time just don't bother making things polymorphic, but if i do, i don't mind having the stronger constraint and accepting that i need two different algorithms for what are two fundamentally
22:55:44 <jle`> different functions
22:55:50 <rjsalts> isn't that what happens in *nix systems as well?
22:56:06 <EvanR> rjsalts: no, you often want to keep the parent around and wait for the child to end
22:56:26 <EvanR> or use the child through the parent
22:56:41 <rjsalts> EvanR: fork rather than exec
22:56:43 <rjsalts> ?
22:56:46 <EvanR> fork then exec
22:57:34 <EvanR> fork splits a process in two identical selves (except for what gets returned from fork)
22:57:57 <EvanR> you need to follow with exec to run a different program
22:57:59 <rjsalts> yeah, sorry
22:58:11 <SrPx> jle`: yep, I guess just accepting non-polymorphic code is sometimes more acceptable than I believed
22:58:24 <SrPx> just using *
22:58:45 <rjsalts> I did realize that, but was being sloppy in my wording
22:59:55 <EvanR> we take it for granted but that dance is a rather idiosyncratic way to create a dang process
23:00:21 <EvanR> i guess it simplified the implementation of unices in ancient times
23:02:23 <jle`> yeah, for most actual application purposes i specialize to Double or Int depending on what i actaully want
23:02:35 <jle`> sometimes it bites me when i want to use like a vector or something but yeah
23:10:09 * hackagebot hjcase 0.1.0.0 - Jcase library for Haskell  http://hackage.haskell.org/package/hjcase-0.1.0.0 (seagreen)
23:26:55 <Zemyla> If arrays didn't have specified index types and lower bounds, they would make fine Monads.
23:31:09 <HeladoDeBrownie> the lower bound isn't specified at type level, is it? i think there must be a different reason why there's no Monad instance
23:32:13 <HeladoDeBrownie> oh, yeah, you're right, Ix doesn't give you the ability to join ranges
23:32:46 <HeladoDeBrownie> in fact i'm not sure there's a coherent way of generalizing over the range when you add elements anyway
23:33:14 <f|`-`|f> ?
23:33:25 <f|`-`|f> huh
23:34:21 <HeladoDeBrownie> it doesn't admit Applicative either for the same reason, that it would need to allow you to end up with more elements than you started with
23:39:11 <Zemyla> HeladoDeBrownie: Maybe a wrapper for array that makes it always go from (0..n-1) or (1..n)?
23:39:46 <HeladoDeBrownie> Zemyla, if you restrict what the index can be, i suppose.
23:40:09 <HeladoDeBrownie> (that's legal since it's not the variable that the Monad methods care about)
23:40:17 <Zemyla> Well, I'd probably restrict it to Int.
23:42:31 <HeladoDeBrownie> the other problem is that the arrays you compose it with could also have arbitrary start and end points
23:42:37 <HeladoDeBrownie> what do you do with a >> b?
23:44:32 <Zemyla> HeladoDeBrownie: That's why the wrapper would make sure it only goes from 0..n-1.
23:45:04 <HeladoDeBrownie> ah, so then it's no longer Array
23:45:12 <HeladoDeBrownie> that's fine
