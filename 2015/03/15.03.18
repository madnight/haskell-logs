01:49:47 <tdammers> hmm... is there a neat way to write case { } in applicative style?
01:50:00 <tdammers> foo >>= \x -> case x in { ... }
01:50:26 <tdammers> that, but without the ugly lambda and something angle-bracketed instead
01:53:20 <jtanguy> you can transform the "\x -> case x in " into "\case" with the LambdaCase extension, but that may not be what you want
01:53:47 <tdammers> foo >>= \case { ... } -- like this?
01:53:57 <jtanguy> yes
01:53:58 <tdammers> better than nothing I guess
01:55:42 <frerich2> tdammers: You could move the lambda into a separate function using pattern matching and then use f  foo. But I guess you want to keep th inline lambda...
01:55:47 <frerich2> err
01:55:55 * frerich2 wonders why this IRC cilent still swallows < $ >
01:56:37 <tdammers> yeah, sure, if I factor it out everything is fine and dandy
01:57:08 <tdammers> but I'd like to avoid that, because I have a lot of stuff right now where I pull a value from a monad and then feed it to a case statement
01:57:20 <tdammers> so that pattern appears a lot, and it's often perfectly simple stuff
01:57:35 <tdammers> I don't want this to turn into Python ;)
02:00:33 * hackagebot stackage 0.6.0 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.6.0 (MichaelSnoyman)
02:07:44 <h4d53> what is haskell good for?
02:07:53 <indiagreen> DSLs
02:07:56 <indiagreen> parsing
02:08:26 <indiagreen> but if you are asking “what can Haskell do”, the answer is “almost anything”
02:08:36 <indiagreen> it's just that at DSLs it's particularly amazing
02:08:58 <h4d53> what DSL stand for?
02:09:04 <indiagreen> domain-specific language
02:09:29 <indiagreen> it means that... say, in C world people are using specialised tools for parsing
02:09:39 <indiagreen> yacc, bison, etc.
02:09:50 <indiagreen> which generate parsing code from a set of rules
02:09:51 <sgronblo> its also good for correctness
02:10:16 <h4d53> so everything ehere parsing is used haskell iw way to go?
02:10:18 <indiagreen> but in Haskell most parsing tasks are done in-language, because it turned out to be easy to write a set of combinators
02:10:44 <indiagreen> or look at the diagrams package, which is used to generate pictures
02:11:25 <indiagreen> the point is that where other people would've written a specialised language for the task, Haskellers can just write a library
02:11:45 <Preyer> h4d53: look at Clay, which is a CSS preprocessor, but still valid Haskell (http://fvisser.nl/clay/)
02:12:22 <indiagreen> sgronblo's point is also good
02:12:48 <indiagreen> Haskell has lots of finer-grained abstractions other languages don't have
02:13:13 <indiagreen> the simplest example – some languages have “null” as a member of each type, and we have a special type for that
02:13:26 <indiagreen> Maybe Int ← something that can either be an Int or Nothing
02:13:31 <sgronblo> yeah, its a bit more tricky to get things done, but once you do them the right way you avoid a whole lot of trouble later in the development process.
02:14:32 <h4d53> sgronblo: beacase it have to be well considered?
02:15:30 <sgronblo> h4d53: yeah kind of
02:15:39 <sgronblo> you have to do a bit more thinking up front
02:17:12 <sgronblo> and you have to spend a bit more time editing your program to get rid of bugs before you can run it as opposed to dynamic languages which will happily run your program even with broken bits inside of it as long as your execution doesnt touch those land mines.
02:18:24 <indiagreen> on the other hand, thanks to that refactoring is much easier than in other languages
02:18:43 <indiagreen> change something, and compiler will complain about all pieces of your code which that change breaks
02:19:14 <h4d53> so writing is longer
02:19:16 <hacker> I like to say it's more about forcing you to pay a "cost" that you'd need to pay anyway
02:19:26 <h4d53> but maitenance painless?
02:20:34 * hackagebot stackage 0.6.0.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.6.0.1 (MichaelSnoyman)
02:21:26 <tdammers> let's say, "much less painful, and closer to linear"
02:21:33 <sgronblo> h4d53: in simple terms, yes
02:21:47 <tdammers> with something like Python, for example, maintenance effort tends to grow exponentially with codebase size
02:21:56 <tdammers> Haskell is closer to linear
02:22:55 <hacker> tdammers: 100 + x vs 1.2^x? :P 
02:23:25 <tdammers> something like that :D
02:27:40 <h4d53> when to avoid haskell?
02:28:17 <frerich2> h4d53 : When you're working in a team and nobody else knows the language.
02:28:36 <Xe> h4d53: a carpenter uses multiple hammers so the right one is used for the right job
02:28:55 <bernalex> I wouldn't use haskell for typesetting I guess maybe
02:28:57 <indiagreen> when you need excellent performance but you're not yet experienced enough with Haskell's evaluation model
02:28:58 <h4d53> Xe: that is why I am asking
02:30:08 <indiagreen> also it's worse than Python for one-off tasks (e.g. if you want to produce a PDF and you never did it before)
02:30:15 <indiagreen> Python's libraries are more uniform than Haskell's
02:30:34 * hackagebot test-sandbox-compose 0.1.3 - Lightweight development enviroments using test-sandbox  http://hackage.haskell.org/package/test-sandbox-compose-0.1.3 (junjihashimoto)
02:31:11 <tdammers> bernalex: why not? apart from libraries, that is...
02:31:12 <mauke^> I just realized I wouldn't choose haskell for well-tested software
02:31:27 <bernalex> tdammers: seems annoying.
02:31:30 <indiagreen> mauke^: what do you mean?
02:32:00 <mauke^> perl is so much better at testing
02:32:14 <mauke^> it has better tools, libraries, infrastructure, and culture
02:32:50 <indiagreen> that's interesting
02:33:13 <indiagreen> could you compare “Haskell vs. Perl for testing” briefly?
02:33:16 <frerich2> it also depends on it a lot more since less issues are found at 'compile time'.
02:33:37 <tdammers> that's kind of the core tradeoff with any dynamic language
02:33:39 <mauke^> indiagreen: I've never written tests for haskell
02:34:04 <indiagreen> ...but you seem sure that Perl is better?
02:34:04 <mauke^> whereas any module uploaded to CPAN will have a test suite (except maybe alpha releases)
02:34:14 <tdammers> throw out all static guarantees, replace them with unit tests, and get a faster development turnaround in return (maybe)
02:34:28 <mauke^> and the installer tools will automatically run those tests after building
02:34:33 <bernalex> how do u even queue connection pools with scotty?
02:34:56 <tdammers> bernalex: s/scotty/wai/
02:35:00 <tdammers> ;)
02:35:02 <bernalex> our current approach of "use an available connectionpool -- if there is nono, lol sux to be you" isn't scaling too hot.
02:35:12 <mauke^> and there's a bunch of servers that test CPAN modules automatically
02:35:12 <bernalex> tdammers: yeah I guess
02:35:23 <mauke^> I know nothing comparable for Haskell
02:35:31 <tdammers> bernalex: I think part of the problem is that WAI is built to be server backend agnostic
02:35:47 <tdammers> bernalex: so can't get process-global shared state
02:36:09 <bernalex> tdammers: damn you polymorphism!!!
02:36:20 <tdammers> basically because the execution models for CGI, SCGI, FastCGI, Warp, etc. are all so radically different
02:36:41 <alpounet> bernalex: connection pool to a db you mean?
02:37:01 * frerich does a mental note to use 'Left LolSuxToBeYou' somewhere, somewhen.
02:37:02 <bernalex> alpounet: yes, postgresql connection pools.
02:37:14 <tdammers> but, uhm, anyway... doesn't the DB client lib magically handle connection pooling for you anyway?
02:38:13 <alpounet> bernalex: you just set it up before starting the server...? I've done this a number of times it's dead easy to set up. i use resource-pool for the efficient pool impl, use it to wrap postgresql connection set up etc and then pass it to the handlers in a way or another
02:38:23 <bernalex> tdammers: if it is, it's not doing a very good job out of the box.
02:38:39 <bernalex> alpounet: i know some of those words
02:38:51 <bernalex> alpounet: I'm not really a Web programmer. I just get paid to do webdev.
02:39:40 <alpounet> i'm not either, but i have to do some every now and then
02:39:49 <tdammers> alpounet: the "in a way or another" is the tricky part
02:40:32 <tdammers> bernalex: the idea is that you connect outside of your runScotty context, and pass a (mutable) reference to whatever it is that manages the connection pool into your Scotty handlers
02:40:34 * hackagebot applicative-fail 0.0.2 - Applicative functor which collects all your fails  http://hackage.haskell.org/package/applicative-fail-0.0.2 (AlekseyUymanov)
02:40:47 <tdammers> close over it, or pass it as an argument
02:41:09 <tdammers> I do that with a custom in-memory database myself, using a TVar
02:41:40 <tdammers> performance isn't great with plain CGI, but other than that, it works fine
02:41:47 <alpounet> tdammers: no need for a mutable reference of anything. you just have to define a function like: myScottyApp :: Pool Connection -> ScottyM ()
02:41:48 <bernalex> we appear to be doing
02:41:53 <bernalex> run (MkConfig d c p) = runNoLoggingT $
02:41:55 <bernalex>   withPostgresqlPool (pack d) c $ NoLoggingT . scottyE p . serve
02:42:04 <tdammers> alpounet: yeah, hence the () around mutable
02:42:05 <bernalex> where c is the number of connections to the db
02:42:14 <bernalex> withPostGresqlPool is from Persist
02:42:18 <tdammers> the Pool probably does some mutable stuff behind the scenes for you
02:42:37 <bernalex> it does "pick an available pool. no available pool? lol ok too bad.", which is hardly optimal.
02:43:06 <tdammers> bernalex: "patches welcome", I guess :x
02:43:45 <bernalex> tdammers: oh. olol. it only waits for an available pool for 2 secs. that's likely the issue. and it's hard-coded. as always.
02:43:55 <bernalex> I guess we'll have to fix it ourselves. like for everything else.
02:44:20 <tdammers> haskell life
02:44:33 <bernalex> more of a lisp thing imo
02:46:08 <bernalex> -- Note: This function previously timed out after 2 seconds, but this behavior
02:46:09 <bernalex> -- was buggy and caused more problems than it solved. Since version 2.1.2, it
02:46:11 <bernalex> -- performs no timeout checks.
02:46:13 <bernalex> lol
02:46:44 <tdammers> no
02:47:16 <tdammers> the lisp thing is "oh, look, a library that does almost exactly what I need. But it's so much fun writing it myself that I'll ignore it"
02:47:42 <indiagreen> for reference, I think it's usually called “the Lisp curse”
02:48:20 <bernalex> symptom of the bipolar lisp programmer.
02:48:28 <tdammers> ^ ++
02:51:44 <paolino> edwardk, is there a plan for MealyT m ? , I'd like to make it work with STM
02:55:34 * hackagebot smoothie 0.1.2 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.1.2 (DimitriSabadie)
02:59:14 <funfunctor> @hoogle ByteString -> Int
02:59:16 <lambdabot> Data.ByteString length :: ByteString -> Int
02:59:16 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
02:59:16 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
02:59:39 <funfunctor> @hoogle ByteString -> String
02:59:39 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
02:59:39 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
02:59:39 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
02:59:49 <funfunctor> @hoogle String -> Int
02:59:49 <lambdabot> Test.HUnit.Base Label :: String -> Node
02:59:49 <lambdabot> Prelude error :: [Char] -> a
02:59:49 <lambdabot> Prelude length :: [a] -> Int
03:00:20 <indiagreen> hm, what are you looking for?
03:00:28 <f|`-`|f> oh yeah, hoogle is a thing
03:00:33 <f|`-`|f> well fuck me
03:00:41 <funfunctor> f|`-`|f: :)
03:00:51 <funfunctor> are you pretty?
03:00:55 * f|`-`|f funfunctor
03:01:03 <f|`-`|f> I'm a good talk
03:01:18 <funfunctor> indiagreen: i'm trying to parse binary data
03:01:19 <f|`-`|f> bit of a spazz, but it's a more bridgeable gap in person
03:01:31 <f|`-`|f> as far as being pretty, I don't look terrible, or bad
03:02:24 <indiagreen> funfunctor: if you want to read a number from a bytestring (written down with digits), there's readInt
03:02:40 <co-arbelos> +
03:02:41 <indiagreen> if you want to read a binary-coded Int, there's the binary package
03:03:03 <indiagreen> (which is useful for parsing binary data in general)
03:03:37 <f|`-`|f> you just need to be mindful of making your own custom encodings
03:03:46 <f|`-`|f> you can do it, but you have to be mindful
03:03:57 <f|`-`|f> much like with read instances
03:04:32 <f|`-`|f> but there are apparently autoderives
03:06:13 <steffen> for two maps Map k1 v1 and Map k2 v2 and show k1 == show k2 => k1 == k2 and same for v, can I be sure that show map1 == show map2 => map1 == map2?
03:06:55 <funfunctor> indiagreen: thx, I am trying to "reverse eng" this shitty code http://lpaste.net/127266
03:07:39 <tdammers> steffen: only if k1 and k2 implement Ord in an isomorphic way
03:08:10 <funfunctor> indiagreen: this is what I have so far http://lpaste.net/127267
03:08:23 <steffen> tdammers: thanks :)
03:08:25 <tdammers> i.e., show k1 == show k2 && show k1' == show k2' => compare k1 k1' == compare k2 k2'
03:08:30 <funfunctor> :t readInt
03:08:30 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
03:12:16 <funfunctor> indiagreen: any advice on how to progress?
03:12:37 <indiagreen> I honestly admit
03:12:40 <indiagreen> I don't know C
03:12:58 <funfunctor> indiagreen: its actually C++ but tell me what you are stuck reading
03:13:14 <indiagreen> well, it's more like deciphering, but okay
03:13:37 <indiagreen> “buffer” is an array? of bytes?
03:13:44 <indiagreen> what's the length of “int” in C++?
03:14:20 <funfunctor> indiagreen: buffer is a char array of bytes correct
03:14:28 <ibid> at least 16 bits
03:14:33 <ibid> iirc
03:14:40 <funfunctor> indiagreen: same as the length of a Int in Haskell
03:15:18 <tdammers> funfunctor: not necessarily
03:15:35 <funfunctor> well, what is a idiomatic way to write  for (int i = 0; i < 4; i++) frameNum = (frameNum << 8) | (0x0ff & buffer[i+1]);
03:15:44 <funfunctor> tdammers: well more or less
03:15:54 <funfunctor> I suspect it wont matter here
03:16:11 <indiagreen> using a fold, I guess
03:16:22 <tdammers> the philosophy is similar: "an integral type of platform-dependent size, with a guaranteed minimum size"
03:16:33 <indiagreen> no, wait, actu— it just constructs a 32bit int?
03:16:38 <indiagreen> out of 4 bytes?
03:16:41 <indiagreen> right?
03:16:56 <funfunctor> oh perhaps your right
03:17:10 <funfunctor> yea that looks right
03:17:20 <indiagreen> well, there are definitely methods in Binary for that
03:17:45 <funfunctor> ok I don't need to do that, there must be a way to fetch a 32bit using attoparsec right?
03:19:44 <pacak> funfunctor: Not really. On 64 bit platform sizeof(int) is 4
03:20:07 <funfunctor> ah true hmm
03:20:34 <indiagreen> I'd just grab those 4 bytes and do something like «foldl1 (\x y -> x*256+y) bytes»
03:20:36 <funfunctor> pacak: how would I fetch 64bits out of a bytestream then?
03:21:00 <funfunctor> ok
03:21:10 <ibid> pacak: but that's because people are stupid and forgot what the standard says, and so the ABI definers on 64-bit platforms were forced to a suboptimal choice
03:21:21 <pacak> funfunctor: What kind of stream do you have?
03:21:41 <indiagreen> funfunctor: you can use “count 4 anyWord8” to grab 4 bytes
03:21:49 <funfunctor> i'm not even 100% at the moment..
03:21:55 <funfunctor> indiagreen: thx!
03:22:04 <indiagreen> then you'd need to “fromIntegral” them
03:22:10 <indiagreen> or else there'd be overflows
03:22:16 <indiagreen> and then you can do the foldl thing
03:22:35 <pacak> ibid: Would you rather have all existing C code that assumes sizeof(int) == 4 to be broken? They don't have a nice typechecker like Haskell does...
03:22:44 <jtanguy> maybe one of the functions in attoparsec-binary might be of help ?
03:22:48 <ibid> pacak: that's exactly what i was talking about
03:23:26 <tdammers> pacak: that C code shouldnever have been written in the first place...
03:24:29 <ibid> (not to mention code that assumes CHAR_BITS == 8, but that's probably an even more lost cause)
03:24:46 <ibid> CHAR_BIT, sorry
03:26:56 <funfunctor> ibid: the code is very very bad
03:28:15 <funfunctor> indiagreen: where am I putting this fromIntegral in?
03:28:52 <indiagreen> foldl1 (\x y -> x*256+y) . map fromIntegral <$> count 4 anyWord8
03:32:03 <lpaste> funfunctor pasted “No title” at http://lpaste.net/127268
03:32:21 <funfunctor> indiagreen: yea I was trying something similar, it wont typecheck
03:32:32 <funfunctor> see above^
03:32:46 <indiagreen> paste the type error, too
03:33:09 <indiagreen> I would assume it happens earlier
03:33:31 <indiagreen> with “fromIntegral $ char8”, in particular
03:33:31 <indiagreen> if char8 is a parser, you can't just apply a function to it, you need <$>
03:35:53 <funfunctor> :t (<$>)
03:35:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:35:57 <funfunctor> functor?
03:35:58 <funfunctor> ah ok
03:36:37 <funfunctor> :t fromIntegral <$>
03:36:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:36:50 <funfunctor> :t fromIntegral (<$>)
03:36:51 <lambdabot>     Could not deduce (Integral ((a0 -> b0) -> f0 a0 -> f0 b0))
03:36:51 <lambdabot>       arising from a use of ‘fromIntegral’
03:36:51 <lambdabot>     from the context (Num b)
03:37:25 <indiagreen> :t (fromIntegral <$>)
03:37:27 <lambdabot> (Num b, Functor f, Integral a) => f a -> f b
03:40:17 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/127268
03:40:50 <funfunctor> indiagreen: still some issues
03:41:48 <indiagreen> «dc <- take (fromIntegral $ gSlotLen+50)»
03:41:52 <indiagreen> this doesn't look right
03:42:34 <indiagreen> no, wait
03:42:35 <indiagreen> nevermind
03:42:48 <indiagreen> forgot there was “take” in Data.Attoparsec
03:43:43 <indiagreen> anyway, paste the compiler message
03:45:05 <funfunctor> indiagreen: its ok, I managed to fix it by changing char8 to anyWord8
03:46:52 <funfunctor> and I cleaned things up by using the applicative functor sutff
03:51:29 <funfunctor> great, I have at least something in place now
04:12:16 <jophish> Hmm, people seem to be coming round to the idea of writing the next project in Haskell
04:12:26 <indiagreen> what people
04:12:30 <indiagreen> what project
04:13:08 <jophish> The guys at my work, we're going to write a compiler
04:13:35 <jophish> 'was chatting yesterday here about how to convinve people Haskell's a good tool for the job
04:13:44 <tdammers> writing compilers in Haskell is fun
04:13:51 <jophish> tdammers: too right!
04:13:53 <tdammers> not something you could say for, say, C
04:15:04 <frerich> Actually, a nice tight state machine loop in C is kinda sexy, too.
04:15:06 <funfunctor> yea, haskell is very well suited to writing a compiler, particularly with the LLVM binding
04:16:08 <tdammers> frerich: oh, sure, C does have a certain appeal, no doubt... I actually enjoy writing C for its cleansing effect
04:16:10 <funfunctor> frerich: i think the idea is to do something advanced/new not the "i can write a compiler too" classroom challenge
04:16:26 <tdammers> but parser combinators in C, ugh...
04:16:58 <tdammers> lex+yacc feels dirty
04:17:06 <funfunctor> C is for folks with a fetish for indeterminism
04:17:39 <jophish> Isn't it great when you come across a function, void f(void);
04:18:04 <funfunctor> tdammers: it would be incredibly interesting to write a C compiler in Idris actually
04:18:05 <tdammers> s/function/procedure/, and it all makes sense again
04:18:15 <funfunctor> then formally verify it
04:18:29 <tdammers> funfunctor: http://www.cs.man.ac.uk/~pjj/bnf/c_syntax.bnf
04:18:32 <tdammers> go go go
04:18:34 <tdammers> ;)
04:18:41 <tdammers> but, anyway, parsing C is hard
04:19:00 <frerich> I like to point people to the libc source code of FreeBSD ( http://svnweb.freebsd.org/base/head/lib/libc/string/ ) for something I consider rather pretty.
04:19:05 <tdammers> particularly because you need prior knowledge to disambiguate things
04:19:08 <jophish> is parsing C hard? I know C++ is a monumental pain
04:19:15 <funfunctor> thx but the BNF notation part of the CFG is not the hard part
04:19:18 <tdammers> C++ is probably worse
04:19:27 <funfunctor> yea I use to work on llvm/clang
04:19:40 <funfunctor> this was before C was fully working
04:19:47 <frerich> jophish : I suspect it's actually not too bad once you added a fallback to your parser which makes it treat whatever it's looking at as a function declaration.
04:19:53 <funfunctor> C++ was a massive job
04:20:36 <tdammers> Parsing C++... foo<<bar>>baz... nuff said :D
04:21:04 <frerich> Or 'void f() { std::string s(); }'
04:21:25 <funfunctor> frerich: maybe check out Alex and my work in coreboot's commit logs
04:21:48 <jophish> I think the most vexing parse in c++ is something like: Class c(ClasS());
04:22:15 <tdammers> "did you mean: recursion?"
04:29:59 <Vetii> Hello everyone!
04:29:59 <Vetii> I have a question: There is a project I'm working on (in C++) and I have a hard time dealing with the noisy syntax. So I'm considering using Haskell for prototyping, and then porting the code to C++ later, when I have a clear idea of what I am doing. Right now I'm parsing JSON files, but it might evolve in the future. I am aware I might fall off the ship since my code might be unportable (who said monads? stop saying monads). Does anybody has any experience 
04:31:20 <indiagreen> code might definitely be unportable because of the difference in paradigms
04:31:44 <indiagreen> say, if you write parsers using parser combinators, and the idiomatic way in C++ is to use yacc or something
04:32:18 <indiagreen> I don't know what C++ uses to parse JSON, but it might be rather different from aeson, too
04:32:41 <Vetii> indiagreen: I tried to use  Boost.PropertyTree, but it was way harder than I expected .
04:33:14 <jophish> It's possible that you'll write it in Haskell and not want to go back :)
04:33:31 <Vetii> jophish: I KNOW
04:37:52 <dropp> hey hey
04:38:01 <Vetii> hey!
04:38:45 <dropp> mmmm... haskell and chocolate muffin
04:38:49 <dropp> :-)
04:39:07 <dropp> better than those haskell muffins. they tasted like monads
04:40:45 <Vetii> Does anybody has knows a cool intro to parser combinators? :D
04:41:41 <Vetii> Oh, wait, here it is:https://wiki.haskell.org/Parsec
04:48:28 <mpickering_> If you're trying to parse JSON then why not use a JSON parsing library?
04:50:06 <frerich> Vetii: There's a (highly recommended, if you ask me) book called 'Programming in Haskell' by Graham Hutton. It has a chapter called 'Functional parsers' which introduces the idea of using a combinator library - I enjoyed it very much.
04:54:05 <Newb1e> Hi! I tried GHC 7.10 rc3 and was wondering whether anyone knows if EclipseFP supports 7.10 yet
04:58:33 <Newb1e> On a related note, while GHC works fine for me, a package I use no longer compiles (dotgen), seemingly due to the AMP change. Last update was in 2009. Do I report this to the maintainer or what what is the normal way to get this fixed?
04:59:51 <indiagreen> Newb1e: https://wiki.haskell.org/Taking_over_a_package
05:00:36 <indiagreen> in a nutshell, try to contact the maintainer first, then wait a week or 2, then post on Haskell-cafe, then wait again, then email admins
05:01:02 <Newb1e> indiagreen: :) Thanks, will do
05:01:09 <staffehn_> Hi, I'm currently playing around with Type Families (trying to get used to them better) and came to a point where I would like to do something like this:
05:01:09 <staffehn_> type family LTPred a b where
05:01:09 <staffehn_>   LT a b => LTPred a b = True
05:01:09 <staffehn_>   LTPred a b = False
05:01:09 <staffehn_> .. so I want to use a typeclass constraint for a type family instance. It gives me a parse error though. Google didn't help me much, is there a way do do what I want to do there?
05:02:19 <indiagreen> Newb1e: wait
05:02:24 <indiagreen> https://github.com/andygill/dotgen
05:02:44 <indiagreen> turns out there's already a commit adding support for GHC 7.10
05:02:59 <indiagreen> in this case, you should just ask the author to release it to Hackage
05:06:48 <Newb1e> indiagreen: Ah, the github repo was not mentioned on the Hackage page, that's why I was wonderingwhat to do. Thanks indiagreen !
05:30:36 * hackagebot applicative-fail 0.0.3 - Applicative functor which collects all your fails  http://hackage.haskell.org/package/applicative-fail-0.0.3 (AlekseyUymanov)
05:33:46 <jacquerie> very specific question: do you know if there's an accepted italian translation of "Monad Transformers"?
05:44:12 <zomg> It's-a me, monadi transformeri
05:44:14 <zomg> sorry :D
05:44:48 <clrnd> ಠ_ಠ
05:45:38 <gregnwosu> whats the best package for doing high performance vector operations, i.e. dot product
05:46:17 <hyPiRion> jacquerie: I generally just write stuff in English or use the English term when speaking in non-English languages. It's usually easier for everyone
05:51:37 <jacquerie> hyPiRion, that's usually my choice. But the constant repetition of an English term sounds a bit awkward in Italian, so it's usually convenient to have an Italian equivalent.
05:52:25 <jacquerie> I might go with "Trasformatori di Monadi", which isn't too far from the english term.
05:53:56 <tdammers> I'd go with writing everything in English
05:54:17 <tdammers> I really can't imagine how people manage to learn programming without being able to read English
05:54:19 <mniip> I wonder why does the russian transliteration of Monad (монада) belong to the first declension
06:18:17 <quchen2> tdammers: You'd be surprised.
06:23:31 <HeladoDeBrownie> mniip, the spanish term isn't just an english loanword either, it's (la) mónada. i suspect they already existed in another form in those languages already.
06:23:43 <HeladoDeBrownie> -already
06:24:13 <tdammers> "Monad" doesn't have Anglo-saxon etymology anyway
06:24:50 <tdammers> so even if those words didn't exist before, it would have been logical to retrofit the latin root into something idiomatic
06:25:15 <HeladoDeBrownie> even so, i've heard (el) monad used.
06:25:31 <jophish> is Trifecta the "in vogue" parser combinator library at the moment?
06:26:01 <HeladoDeBrownie> jophish, from what i've seen, i'd call parsec that
06:26:24 <tdammers> parsec is the "default" one :D
06:26:40 <tdammers> trifecta is what the cool kids use
06:27:09 <jophish> I like to think of myself as a "cool kid", certainly
06:27:32 <frerich> Wait, I thought that was attoparsec. Or wait, that's what people like me with training wheels on their bikes use?
06:27:35 <HeladoDeBrownie> because the haskell community needs social signaling based on what parsers you use :P
06:28:25 <frerich> "Show me the combinator lib you use and I tell you who you are."
06:28:45 <tdammers> attoparsec is what the "get shit done" squad uses
06:28:56 * tdammers is making plenty of enemies right now
06:29:04 <frerich> Hell yeah! I need to get that badge!
06:32:53 <Selwyn015> Hello guys, iam trying to learn Haskell and to do so I would like to start reading the code of some libraryfunctions such as Data.Char isDigit to see how its build. Does anybody know where and how I can look this up??
06:33:54 <jameseb> Selwyn015: you can usually look at the source of things on hackage
06:35:11 <tdammers> Selwyn015: hackage has "source" links for most things
06:35:42 <tdammers> Selwyn015: most of the packages also have a source code repository listed that you can browse through
06:35:57 <tdammers> also, lambdabot knows the sources of some things
06:36:02 <tdammers> @src isDigit
06:36:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:36:08 <tdammers> not this one though :D
06:36:13 <tdammers> @src Data.Char.isDigit
06:36:13 <lambdabot> Source not found. Abort, Retry, Panic?
06:36:23 <indiagreen> isDigit and friends are rather implementation-specific
06:36:29 <geekosaur> lb doesn't know the source t very much at all
06:36:38 <tdammers> pity
06:36:38 <indiagreen> I didn't add them when I was adding commonly requested things
06:36:41 <indiagreen> actually
06:37:01 <Selwyn015> okay well I was looking on Hackage earyler but I couldnt seem to find it
06:37:12 <indiagreen> I'm working on a database of functions with common implementations, GHC implementations, algorithmic complexity, etc.
06:37:19 <indiagreen> would anyone be interested in helping
06:37:35 <jameseb> Selwyn015: here's the source for isDigit that hackage links to: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Unicode.html#isDigit
06:37:37 <tdammers> Selwyn015: here: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Unicode.html#isDigit
06:37:44 <tdammers> this is the one from base
06:39:38 <Selwyn015> I see ill bookmark it, ty
06:40:39 <tdammers> no need to bookmark
06:40:43 <tdammers> hackage has you covered
06:41:08 <tdammers> duckduckgo even has bang patterns for !hackage, !hayoo, and !hoogle
06:42:56 <HeladoDeBrownie> !h being short for !hoogle as well
06:44:06 <indiagreen> and, of course, you can just set up search shortcuts in your browser
06:44:24 <jophish> WOO! Haskell at work!
06:45:37 * hackagebot crypto-random 0.0.9 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.9 (VincentHanquez)
06:48:12 <paolino> is there a reason why a Read a => String -> Maybe a is not available ?
06:48:43 <indiagreen> it is
06:48:51 <indiagreen> Text.Read.readMaybe
06:48:56 <paolino> I see there is one in Network.CGI.Protocol 
06:49:14 <bananagram> that should be put in Prelude
06:49:29 <bergmark> oh i didn't know about that either, is it new?
06:49:38 <bergmark> i've been using readMay from safe
06:49:40 <indiagreen> it's been in Text.Read since base-4.6
06:49:46 <indiagreen> that's... GHC 7.6, right?
06:50:29 <indiagreen> and there's also readEither if you want to see the error
06:51:55 <frerich> tdammers: Wow, I knew duckduckgo hsa some cool tricks but I never knew about !hackage/!hayoo/!hoogle. And when I make it my default search engine I can just type '!h a->b' in the location bar of chrome. Sweet!
06:52:34 <tdammers> yes
06:52:55 <tdammers> you can even request your own bang patterns, and if they're remotely useful, they'll add them
06:54:49 <paolino> indiagreen, thanks, I've wrote so many *case reads* before asking ..
07:13:39 <SrPx> Hello, is there a list of in which circunstances the type inferencer will not be able to define the type of an expression without annotations?
07:16:10 <chpatrick> could haskell remove tautological constraints on polymorphic types automatically?
07:16:39 <chpatrick> so if you say something is forall x. (x ~ x) => Int or something the constraint would disappear
07:17:08 <Iceland_jack> :t undefined :: (a ~ a) => Int
07:17:08 <HeladoDeBrownie> SrPx, i don't have an exhaustive list, but haskell will never infer higher-rank types (afaik)
07:17:09 <lambdabot> Int
07:17:11 <chpatrick> or a closed type family constraint that holds for any value
07:17:25 <HeladoDeBrownie> SrPx, it may also not be able to resolve ambiguous type variables on its own
07:18:03 <Iceland_jack> SrPx: An example of what HeladoDeBrownie is talking about
07:18:03 <Iceland_jack>     works :: (forall a. a -> a) -> (forall b. b -> b)
07:18:03 <Iceland_jack>     works x = id x
07:18:03 <Iceland_jack> and
07:18:06 <Iceland_jack>     doesn'tWork :: (forall a. a -> a) -> (forall b. b -> b)
07:18:09 <Iceland_jack>     doesn'tWork = id
07:18:13 <Iceland_jack>  
07:18:28 <chpatrick> *Main> :t undefined :: (x ~ x) => Int
07:18:28 <chpatrick> undefined :: (x ~ x) => Int :: Int
07:19:05 <chpatrick> my problem is that I have this type: type Appl f x a = ResultsIn x a ~ True => f a -> f x
07:19:18 <chpatrick> and composing these builds up these massive constraints that actually always hold
07:19:53 <SrPx> So if you don't use the rankn pragma and typeclasses type inference is 100% decidable? Higher rank types are necessary for the State monad, right?
07:20:02 <chpatrick> *Main> :t (app getLine // app getLine // app getLine )
07:20:02 <chpatrick> (app getLine // app getLine // app getLine )
07:20:02 <chpatrick>   :: (ResultsIn
07:20:02 <chpatrick>         (String -> String -> x) (String -> String -> String -> x)
07:20:02 <chpatrick>       ~ 'True,
07:20:03 <chpatrick>       ResultsIn (String -> x) (String -> String -> x) ~ 'True,
07:20:03 <chpatrick>       ResultsIn x (String -> x) ~ 'True) =>
07:20:04 <chpatrick>      IO (String -> String -> String -> x) -> IO x
07:20:23 <Iceland_jack> chpatrick: Use lpaste
07:20:26 <chpatrick> sorry
07:20:35 <HeladoDeBrownie> SrPx, i kind of doubt it, for example you don't need to use the RankNTypes pragma in order for your program to interact with things of rank-n types
07:20:39 <chpatrick> if it plugged in an arbitrary x for ResultsIn it could see that it holds for it, therefore it holds for all x right?
07:20:56 <jophish> frerich: I have "h" and "ho" bound in chrome for new and old Hoogle
07:21:48 <Iceland_jack> SrPx: http://stackoverflow.com/questions/7644658/are-there-type-signatures-which-haskell-cant-verify 
07:23:08 <SrPx> I didn't know sometimes even type checking would not be decidable
07:28:27 <root_usr> Using Haskell, in what function or functions should I look if I have an input with, e.g. "abc123de45" and I only want to get the numbers returned in a list, "12345"
07:28:39 <opqdonut> filter
07:28:51 <jophish> > filter isDigit "abc123de45"
07:28:53 <lambdabot>  "12345"
07:29:00 <paolino> Anyone can please have a look here http://lpaste.net/127275, I cannot understand the error
07:30:28 <opqdonut> paolino: your type EP is nonsensical. perhaps you meant to not include a in the forall?
07:30:37 * hackagebot effect-handlers 0.1.0.4 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  http://hackage.haskell.org/package/effect-handlers-0.1.0.4 (edofic)
07:30:48 <paolino> ah, stupid me
07:31:47 <paolino> that's it, thanks
07:36:02 <root_usr> I try the filter (http://lpaste.net/5187197716102381568), but it gives me a different error now http://lpaste.net/7956121260197412864
07:37:54 <paolino> getNumList is String -> String
07:38:25 <paolino> :t filter
07:38:26 <lambdabot> (a -> Bool) -> [a] -> [a]
07:40:14 <bhurt> \help
07:40:19 <bhurt> Sorry- ignore that.
07:43:27 <jophish> Cabal is giving me this warning: "The package list for 'stackage-lts-1.13' does not exist. Run 'cabal update' to download it." However cabal update just downloads from hackage
07:44:07 <frerich> paolino: It looks like 'isNum' expects a Char but you're trying to apply 'filter isNum' to a list of strings, i.e. each element given to isNum is a String instead of a Char.
07:44:35 <frerich> paolino: Maybe you mean 'filter (any isNum)' or so?
07:45:09 <paolino> it was for root_usr 
07:45:11 <jophish> or getNumList :: String -> [Char]
07:45:36 <frerich> paolino: Euhm, sorry. I'm getting confused with all the lpaste links :-}
07:45:46 <frerich> root_usr: What I just wrote to paolino was meant for you :-)
07:45:51 <paolino> np
07:45:53 <root_usr> frerich - paolino: Thanks guys :)
07:52:16 <root_usr> frerich: Hm, I'm really new to this. Does that mean I have to rewrite isNum function or the getNumList function? (http://lpaste.net/5187197716102381568)
07:52:38 <mmachenry> Is there an operator to lift an argument into an applicative without having to write pure?
07:52:40 <mmachenry> > Just (+) <*> pure 1 <*> Just 2
07:52:41 <lambdabot>  Just 3
07:53:04 <paolino> root_usr, look at filter type
07:53:13 <paolino> :t filter
07:53:14 <lambdabot> (a -> Bool) -> [a] -> [a]
07:53:19 <mmachenry> I want to say something like " Just (+) <…> 1 <*> Just 2
07:53:37 <paolino> isNum is a -> Bool
07:53:48 <frerich> root_usr: Both would be possible. You could adjust 'isNum' such that it's of type 'String -> Bool', i.e. it could check whether any character in the given string is a digit. Or you could adjust the definition of 'getNumList' such that it doesn't filter using 'isNum' but rather using something which applies 'isNum' to every charactr of each string
07:54:27 <paolino> so filter isNum is left to be [a] -> [a] which is cannot be made into  String -> [String]
07:54:51 <dredozubov> mmachenry: it would be possible with applicative do or idiom brackets if of these will become part of GHC
07:54:58 <frerich> root_usr: You could also go for a third approach: Define a new function 'containsDigits :: String -> Bool' which is implemented in terms of 'isNum'. You could then use that as the predicate for filter in getNumList, i.e. 'filter containsDigits'
07:55:37 <mmachenry> dredozubov: I guess I could easily write my own operator. 
07:55:37 <dredozubov> one of these*
07:57:14 <dredozubov> something in the lines of "apLift f g = f <*> pure g" will do
07:58:27 <dredozubov> or even shorter: apLift f = (<*>) f . pure
07:59:00 <mniip> aplift = (. pure) . (<*>)
07:59:34 <dredozubov> mniip: slightly more cryptic for my taste
07:59:56 <mauke^> :t \f g -> ($ g) <$> f
07:59:57 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:00:23 <mniip> that's what i first thought of, mauke^
08:00:50 <mauke^> @pl \ f g -> fmap ($ g) f
08:00:50 <lambdabot> flip (fmap . flip id)
08:01:20 <mauke^> :t flip $ fmap fmap $ flip pure
08:01:21 <lambdabot> Functor f => f a -> b -> f a
08:01:36 <mniip> :t fmap <$> ($) <*> id
08:01:37 <lambdabot> (b -> b) -> b -> b
08:01:44 <mniip> hm
08:01:57 <mniip> oh right, that's the reader
08:02:05 <frerich> (a -> b) -> (a -> b)
08:02:12 <frerich> er sorry, wrong window heh.
08:02:17 <napping> that "flip pure" is not what you want
08:02:32 <napping> it's specialized as flip const
08:02:44 <mniip> which is const id
08:03:32 <mauke^> :t flip $ fmap fmap $ pure asks
08:03:33 <lambdabot> (MonadReader r m, Functor f) => f (r -> a1) -> a -> f (m a1)
08:04:36 <dredozubov> mauke^: asks won't do for Applicative
08:05:38 * hackagebot directory 1.2.2.0 - Platform-agnostic library for filesystem operations  http://hackage.haskell.org/package/directory-1.2.2.0 (Rufflewind)
08:07:31 <mauke^> :t flip $ fmap fmap $ flip asks
08:07:31 <lambdabot> Functor f => f (b -> a) -> b -> f a
08:07:38 <breadmonster_> Does haskell distinguish between actual and logical types?
08:07:54 <breadmonster_> @type phoneNumber = string
08:07:55 <lambdabot> parse error on input ‘=’
08:08:21 <tdammers> ?
08:08:29 <tdammers> what are "actual" and "logical" types?
08:08:31 <paolino> you mean type synonyms ?
08:08:31 <breadmonster_> So like if I declare two types to be strings, and run an equality comparison against them, will Haskell report a type error?
08:08:35 <breadmonster_> paolino: Yup.
08:08:37 <mniip> type synonyms are entirely equivalent to the synonymised type
08:08:42 <breadmonster_> Sorry I didn't get the terms.
08:08:45 <tdammers> ah, right
08:08:56 <breadmonster_> mniip: How do I override this behavior?
08:09:00 <mniip> newtype
08:09:09 <breadmonster_> mniip: As opposed to type?
08:09:12 <mniip> yes
08:09:18 <breadmonster_> Cool.
08:09:22 <tdammers> the synonym is, indeed exactly equivalent, with the exception of compiler errors, where the compiler will pick one or the other based on the phase of the moon and such
08:09:23 <mniip> you get the burden of packing/unpacking the value (with no runtime overhead though)
08:09:37 <breadmonster_> mniip: What does that mean?
08:09:46 <mniip> but the typechecker will treat them as different types
08:09:53 <tdammers> breadmonster_: newtype PhoneNumber = PhoneNumber { unPhoneNumber :: String }
08:09:55 <mniip> breadmonster_, newtype is like data
08:10:03 <mniip> but only allows one constructor with one field
08:10:12 <tdammers> turn a string into a phone number: let phoneNum = PhoneNumber "555123456"
08:10:14 <mniip> which is strict
08:10:21 <tdammers> a.k.a. "pack"
08:10:38 <tdammers> unpacking: let phoneNumStr = unPhoneNumber phoneNum
08:11:19 <tdammers> the "without runtime overhead" means that the PhoneNumber constructor and the unPhoneNumber accessor compile away
08:11:35 <breadmonster_> mniip tdammers: What if I have some binary tree representation say, and I want to declare a type synonym for that?
08:12:10 <breadmonster_> Whose constructors require more than one argument?
08:12:40 <napping> that's in on the inner type
08:12:48 <tdammers> indeed
08:12:54 <napping> The list node itself will be a single argument to the newtype's constructor
08:13:14 <mauke^> newtype Whatevs a = Aaaaa (Tree a)
08:13:17 <tdammers> newtype Foobar = Foobar { unFoobar :: [(String, [Int]) -> IO ()] } -- no problem
08:13:23 <breadmonster_> I gotta run for a little bit, and I don't get what's going on.
08:13:32 <napping> and then Aaaaa (Branch l 'v' r)
08:13:34 <breadmonster_> I'll be back in a bit. See you guys then (:
08:13:37 <tdammers> newtype is pretty much exactly like data
08:13:53 <mauke^> @let newtype Whatevs a = Aaaaa (Tree a) deriving (Read, Show, Eq, Ord)
08:13:55 <lambdabot>  .L.hs:153:45:
08:13:55 <lambdabot>      No instance for (Ord (Tree a))
08:13:55 <lambdabot>        arising from the 'deriving' clause of a data type declaration
08:13:58 <mauke^> @let newtype Whatevs a = Aaaaa (Tree a) deriving (Read, Show, Eq)
08:14:00 <tdammers> only that there are a few restrictions what you can do with it, and some performance benefit
08:14:00 <lambdabot>  Defined.
08:14:10 <tdammers> (and -XGeneralizedNewtypeDeriving, which is pretty awesome)
08:14:13 <mauke^> > Aaaaa (Node "hi" [])
08:14:13 <breadmonster_> mauke^: Oh okay, yeah, I got what you mean.
08:14:14 <lambdabot>  Aaaaa (Node {rootLabel = "hi", subForest = []})
08:14:19 <breadmonster_> Thanks.
08:14:34 <phaazon> do we have a decent fonts loading library?
08:14:45 <phaazon> freetype2 is 3 years old...
08:16:30 <bennofs> phaazon: haven't used it, but http://hackage.haskell.org/package/FTGL is newer
08:16:48 <mniip> phaazon, linux is 24 years old, your point?
08:18:24 <phaazon> mniip: my point is that I use a recent kernel for linux
08:18:42 <phaazon> the Haskell freetype2 uses a version of freetype2 that is WAY past
08:18:54 <phaazon> 2.5 is the latest, and the haskell one is 2.0.1
08:22:12 <osa1> any ideas when is an UNPACK or ! is unexpected? like, sometimes I'm getting this messages: `Unexpected strictness annotation: {-# UNPACK #-}`
08:23:19 <int-e> osa1: I believe {-# UNPACK #-} expects a strict data type which has only a single constructor
08:23:53 <osa1> what do you mean by strict data type?
08:23:59 <int-e> osa1: Uh, I mean a data type, and a strictness annotation (bang, !)
08:25:31 <osa1> oh right {-# UNPACK #-} without ! doesn't make sense.
08:26:15 <int-e> osa1: But I don't get "unexpected" warnings or errors with ghc 7.8.3 (and interestingly, no error for types with multiple constructors)... can you show some code?
08:27:02 <int-e> (I'm experimenting with ghc 7.8.3)
08:29:21 <osa1> int-e: just try {-# UNPACK #-} !IORef Int in a record
08:30:28 <int-e> osa1: Aha. It should be  data X = X { foo :: {-# UNPACK #-} !(IORef Int) }
08:30:50 <int-e> osa1: note that it says "unexpected strictness annotation" - the ! is mispplaced.
08:34:13 <osa1> int-e: nice, thanks
08:34:14 <int-e> osa1: But yeah, it's a funny error, because the ! is inserted implicitely; I think it qualifies as a ghc bug.
08:34:28 <int-e> implicitly (training fingers...)
08:34:40 <osa1> inserted implicitly?
08:35:31 <mmachenry> Using Either as an applicative I can get a value or the first error that occurred in the arguments. Is there a trick to getting Either [Error] MyValue so I can see all of the errors?
08:35:57 <int-e> osa1: The "strictness annotation" is the !, but you get the error even for {-# UNPACK #-} IORef Int, where the ! is not even there. There's still a hint in the error message: Note the missing Int from 'Unexpected strictness annotation: {-# UNPACK #-}IORef'
08:36:02 <mmachenry> I could potentially make another error type and make an applicative or monad instance.
08:36:49 <dfeuer> {-# UNPACK #-} without !  will earn you a compiler warning, and will act as though the ! were there anyway.
08:37:08 <dfeuer> I think.
08:37:18 <dfeuer> Or it might just ignore the UNPACK.
08:37:21 <dfeuer> Either way, don't do that.
08:48:40 <S11001001> mmachenry: that's "Validation".  NB: there is no Validation monad, because as you may have observed, it is impossible to get all the errors from a chain of >>= / series of do x <- binds.
08:48:56 <S11001001> mmachenry: http://hackage.haskell.org/package/validation
08:49:06 <tdammers> Writer would work though
08:50:09 <S11001001> mmachenry: it is called AccValidation in that package
09:11:33 <dfeuer> Ping ski.
09:18:00 <jophish> Is there a way to install to a different prefix while building in a sandbox?
09:23:36 <jophish> so cabal install uses the prefix given to configure
09:25:39 * hackagebot purescript 0.6.9.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9.1 (PhilFreeman)
09:29:18 <paolino> which type is a Category and not an Arrow ?
09:29:45 <jophish> at the moment I'm just copying the bin directory across from .cabal-sandbox
09:30:29 <quchen> jophish: You can specify a bindir when using cabal install.
09:30:50 <jophish> quchen: how about things like documentation, or libraries?
09:31:42 <jophish> quchen: ah! passing prefix to install did the trick!
09:32:00 <quchen> The prefix is the prefix for pretty much any path Cabal uses, yes.
09:32:11 <quchen> But then I don't see the point of building the project in a sandbox.
09:32:14 <jophish> passing it to configure, and not to install doesn't
09:32:26 <jophish> quchen: to avoid installing the dependencies globally
09:32:49 <quchen> jophish: But your libraries will be broken if the dependencies are missing, it's linked against them after all
09:35:03 <jophish> quchen: hmm, that's no good
09:35:23 <mmachenry> S11001001: Woa, cool, thanks.
09:35:40 <jophish> How does one create redistributable executables using Haskell then
09:36:01 <quchen> jophish: *executables* can be statically linked, i.e. the binary will contain all libraries.
09:36:10 <quchen> But you can't do that with libraries themselves.
09:36:30 <jophish> ah, so this should all be fine, I'm not creating a library :)
09:36:51 <CaptainK> What is the status of the Haskell server security breach ?
09:36:54 <ski> enthropy : yes
09:37:24 <quchen> For executables you'll be fine most of the time. I wrote a script for this some time ago that automates the process, https://github.com/quchen/cabal-install-bin/ but I'm not entirely sure how well it works in general. The source might be a good way to get started though.
09:40:19 <quchen> jophish: I think the pull request I got yesterday fixes the issue though.
09:40:52 <jophish> quchen: thanks!
09:44:25 <bartavelle> > decode (encode ("xx" :: String)) :: Maybe String
09:44:27 <lambdabot>  Not in scope: ‘decode’Not in scope: ‘encode’
09:44:46 <bartavelle> humm, everybody agrees I should get (Just "xx") ?
09:45:06 <HeladoDeBrownie> bartavelle, for appropriately defined decode and encode, probably?
09:45:06 <quchen> jophish: Merged.
09:45:21 <bartavelle> HeladoDeBrownie, for Data.Aeson, sorry
09:45:43 <HeladoDeBrownie> bartavelle, the string represented by "xx" is not valid json. that might have something to do with it.
09:45:45 <quchen> A plain string isn't valid JSON, is it?
09:45:46 <mauke^> I'd expect Nothing
09:45:59 <bartavelle> it's the reason I use "encode" ?
09:46:15 <mauke^> this is a statement ?
09:46:18 <HeladoDeBrownie> bartavelle, ah, not sure how Data.Aeson works, that was just a guess
09:46:38 <c_wraith> bartavelle: if you want a dummy test string for json, use "{}"
09:47:16 <bartavelle> my statetement is that I expect (\x -> decode (encode x) == Just x) to work for all instances of FromJSON and ToJSON defined in Data.Aeson, but it seems I am wrong
09:48:27 <mauke^> encode "xx" should be "\"xx\"", and decode "\"xx\"" should be Nothing
09:48:47 <bartavelle> why is decode "\"xx\"" Nothing ?
09:48:50 <geekosaur> doesn't Aeson's decode require that it be a collection?
09:48:54 <bartavelle> there is something I don't understand
09:48:57 <bartavelle> ohhh
09:48:59 <bartavelle> ok !
09:49:15 <HeladoDeBrownie> what, like it forces it to be a json object or array?
09:49:19 <c_wraith> bartavelle: there's a reason why I said to use "{}"
09:49:19 <geekosaur> there's a comment on this in the haddock, and a workaround suggested there
09:49:27 <geekosaur> yes, it forces object ro array
09:49:30 <quchen> bartavelle: Have you see the "Pitfalls" section in Aeson's documentation? http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:6
09:49:31 <bartavelle> c_wraith, I did not understand what you implied
09:49:35 <c_wraith> HeladoDeBrownie: that's what the spec says to do
09:49:48 <HeladoDeBrownie> c_wraith, citation?
09:50:05 <geekosaur> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:6
09:50:08 <bartavelle> quchen, thanks, I should have read that
09:50:27 <HeladoDeBrownie> i assumed c_wraith meant the json spec
09:50:35 <HeladoDeBrownie> i was under the impression it allowed for top-level numbers and strings and such
09:50:39 <geekosaur> actually I have heard that the spec does not require that currently, although an early version did
09:50:52 <c_wraith> HeladoDeBrownie: looks like the latest version does allow arbitrary values.
09:51:00 <c_wraith> HeladoDeBrownie: But historically it hasn't
09:51:02 <geekosaur> but as I do not work with json regularly, I have not dug deeper
09:51:08 <HeladoDeBrownie> looking at json.org, it's vague on the topic
09:51:49 <HeladoDeBrownie> i do know that the js implementation permits it, and i believe the python one does too
09:53:53 <bananagram> is there any way to influence GHC to use less memory?
09:55:06 <Yuras> bananagram: when compiling?
09:55:21 <bananagram> Yuras: yeah
09:55:26 <Yuras> disable optimizations, don't use INLINE
09:55:42 <isBEKaml> hi, does anyone know when ghc source builds started enforcing libtinfo as a dependency? Or, how do I know which artifact requires libtinfo?
09:55:54 <isBEKaml> haskeline? readline repl?
09:55:55 <bananagram> do I have to compile it again to do that?
09:56:06 <HeladoDeBrownie> found it "A JSON text is a sequence of tokens formed from Unicode code points that conforms to the JSON value grammar." this confirms that more than objects and arrays are permitted top-level. and i think this has always been the case
09:56:41 <HeladoDeBrownie> so, aeson is not compliant with the spec
09:57:08 <Yuras> bananagram: no, disable optimizations when compiling you code
09:57:17 <geekosaur> isBEKaml, when haskeline was made part of ghc instead of relying on a platform readline library (which caused issues on Mac and Windows)
09:57:20 <c_wraith> HeladoDeBrownie: http://www.ietf.org/rfc/rfc7159.txt "A JSON text is a serialized value.  Note that certain previous specifications of JSON constrained a JSON text to be an object or an array."
09:57:41 <HeladoDeBrownie> c_wraith, ah, i see.
09:58:58 <geekosaur> isBEKaml, before that ghc did not try to constrain because it depended on how the platform's readline was built and satisfying the dependency was left to readline
09:59:17 <isBEKaml> geekosaur: thanks - do you happen to know why we chose libtinfo instead of libncurses? IIRC, libtinfo is a split down from libncurses?
09:59:50 <geekosaur> compatibility with older platforms like rhel6 which still have the ancient split of libtinfo from libncurses, likely
10:00:52 * hackagebot mime-types 0.1.0.6 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.6 (MichaelSnoyman)
10:00:54 * hackagebot purescript 0.6.9.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9.2 (PhilFreeman)
10:01:39 <geekosaur> ancient platforms had them separate; newer ones they're symlinked (or linker script or w/e); I imagien still newer ones dropped libtinfo entirely because Compatibility Not My Problem
10:02:12 <isBEKaml> geekosaur: okay, the reason I asked this was Slackware doesn't include libtinfo. So, binary builds were not working directly and we are now compiling from source 
10:02:59 <isBEKaml> geekosaur: also, we aren't using symlinking to libncurses since that would just pollute install sites
10:03:14 <geekosaur> "let's be incompatible Just Because We Can"
10:03:20 <isBEKaml> :-)
10:03:51 <geekosaur> sometimes I think linux is trying to be a living example of worst practices
10:04:13 <isBEKaml> each doing their own thing, yeah
10:05:24 <isBEKaml> geekosaur: do you think it's possible to just modify GHC's configure scripts to take an alternative term lib? --with-term-lib=libncurses or something like that?
10:05:43 <isBEKaml> we could possibly avoid incompatibilities that way
10:05:51 <geekosaur> I would hope so
10:05:52 * hackagebot wai-extra 3.0.4.6 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.6 (MichaelSnoyman)
10:06:04 <geekosaur> as long as it satisfies the dependencies. if it doesn't work then I'd file a ghc bug
10:06:12 <geekosaur> and try to get it into 7.10final
10:07:30 <isBEKaml> geekosaur: right now, there isn't such an option in GHC's configure scripts. This is something new 
10:09:47 <geekosaur> so, configure bug if it doesn't check -lncurses itself
10:09:59 <isBEKaml> guess so
10:10:05 <geekosaur> I think you're in #ghc territory now, or at least the ghc dev list
10:10:29 <isBEKaml> geekosaur: Ok, I'll ask on #ghc
10:10:35 <isBEKaml> geekosaur: thanks for all the info!
10:12:18 <oconnore2> Is there an equivalent for vcvars32.bat with ghc on windows? -- or, why is GHC not finding HsFFI.h and how can I fix that?
10:13:39 <geekosaur> that would be a mis-installed ghc, as it is part of the ghc installation. if you moved the installation then there is probably something somewhere that needs to be updated (but I have no idea where; on Unix it's a set of wrapper shell scripts but that's kinda not helpful on Windows)
10:14:03 <oconnore2> hmm, I haven't moved anything
10:20:52 * hackagebot th-desugar 1.5.2 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.5.2 (RichardEisenberg)
10:21:58 <JLJ1> hey I'm fairly new to haskell and have a probably silly problem. Can I PM someone for some help?
10:23:46 <bergmark> JLJ1: you have a better chance of getting help if you ask in here
10:23:50 <tommd> JLJ1: Typically people just ask publicly.
10:23:57 <glguy> JLJ1: Just go ahead and ask. Beginner questions are fine in channel.
10:30:08 <paolino> which type is a Category and not an Arrow ?
10:30:15 <paolino> ops
10:30:33 <paolino> I already asked that
10:31:09 <glguy> Looking at the list of instances http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Category.html
10:31:32 <glguy> There are 4 instances in base. 2 of those are not Arrows
10:32:19 <lpaste> JLJ1 pasted “Parse error on the if ” at http://lpaste.net/3790513598854332416
10:33:17 <JLJ1> Okay well I'm trying to recursively pass items from a list to a function but I'm getting a syntax error that I can't see what I'm doing wrong
10:33:19 <glguy> JLJ1: Other than the error you're about to paste you should avoid using TABs in your Haskell source
10:33:50 <MagBo> I'm sorry, I wonder — how to generalize a newtype to accept instances instead of exact types.
10:33:50 <JLJ1> Okay is it tab sensitive or just a preference thing?
10:33:52 <isBEKaml> JLJ1: yes, it looks like you've mixed tabs and spaces in your code
10:34:00 <quchen> JLJ1: Read this on tabs. https://github.com/quchen/articles/blob/master/fbut.md#tabs-vs-spaces
10:34:04 <glguy> Indentation matters in Haskell soruce, and they must be interpret with tabstops=8
10:34:07 <isBEKaml> JLJ1: just use spaces - it's just the layout that's tripping you up
10:34:23 <arbelos> i could be wrong but it feels like filmAsString should be the Show instance.. 
10:34:36 <MagBo> I want to use datatype contexts, but as it seems it shouldn't be used.
10:34:39 <glguy> arbelos: No, the Show instance should produce Haskell syntax
10:35:00 <EvanR> * if that makes sense
10:35:04 <MagBo> As it will be deprecated. :(
10:35:13 <arbelos> i was wrong
10:35:21 <EvanR> dont use datatype contexts
10:35:32 <MagBo> So I wonder how to work around datatype contexts deprecation.
10:35:45 <glguy> JLJ1: You probably meant to apply filmAsString to x, not film, and then you need to append that result with the recursive result
10:35:46 <Iceland_jack> MagBo: Move the constraints out of your datatype, into the functions
10:35:53 * hackagebot purescript 0.6.9.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9.3 (PhilFreeman)
10:35:55 <glguy> ++ is the append operator, as you've used in your file already
10:36:03 <quchen> MagBo: GADTs, sometimes. As a beginner, you should not constrain your data types. https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
10:36:46 <JLJ1> @glguy that is a mistake but it was from trying to fix it if you know what I mean 
10:36:46 <lambdabot> Unknown command, try @list
10:36:48 <Iceland_jack> GADTs make writing instances difficult 
10:37:09 <EvanR> how so
10:37:28 <paolino> I already asked that
10:37:29 <glguy> Also, @ indicates a bot command, so you don't need to prefix names with it like on Twitter
10:37:48 <JLJ1> I guess been a long time since I used IRC :(
10:37:54 <Iceland_jack> EvanR: Define
10:37:54 <Iceland_jack>     data Pair a where
10:37:54 <Iceland_jack>       MkPair :: Num a => a -> a -> Pair a
10:37:54 <Iceland_jack> and try to define instance Functor Pair
10:37:58 <paolino> ok, I unstick sthis window, sorry again
10:38:18 <EvanR> Iceland_jack: well thats not making it difficult, your type isnt a functor ;)
10:38:29 <MagBo> Ok.
10:38:31 <quchen> Iceland_jack: Making that a Functor is logically wrong, not really a problem with Haskell
10:38:38 <Iceland_jack> :) well okay, it makes it very simple then!
10:38:47 <quchen> At least if you consider the inability to add constraints in instances a problem
10:38:48 <glguy> allFilmAsString (x07:xs) 07= filmAsString x 07++ 04"\n" 07++ allFilmAsString xs
10:38:55 <EvanR> if you had another constructor you might be able to make a Functor with it
10:38:56 <quchen> +not
10:39:13 <glguy> JLJ1: And then you should have a separate case for when there are no more films
10:39:13 <EvanR> maybe not
10:39:25 <quchen> 5 do we have colour in here now?
10:39:45 <quchen> Neat. Time to get familiar with CLI hscolour again!
10:39:53 <JLJ1> glguy thank you :)
10:40:02 <EvanR> dont forget blinking
10:40:04 <glguy> JLJ1: Note that filmAsString doesn't print the string, it just creates one, so you have to do something with it
10:40:10 <narendraj9> quchen: How did you do that?
10:40:13 <narendraj9> quchen: color.
10:40:24 <EvanR> abuse it and lose it
10:40:43 <quchen> Via my IRC client's colour capabilities.  Lambdabot with coloured output would be really nice.
10:41:12 <JLJ1> glguy yeah I know but I'll be outputting it with io later on 
10:42:04 <geekosaur> the problem with irc color is that, while mirc publishes its colors, there's no guarantee that other clients use the same colors...
10:42:31 <breadmonster> Hey guys, can someone help me build GHC?
10:42:51 <tommd> breadmonster: The first question is why do you want to compile GHC yourself?
10:42:58 <arbelos> So Read/Show is actually meant for serialization... 
10:43:17 <breadmonster> tommd: It's the first step towards hacking ghc.
10:43:24 <arbelos> I thought they were just more for convenience 
10:43:42 <tommd> breadmonster: Great answer.  Have you downloaded a tarball and ran into trouble with it?
10:43:50 <breadmonster> Yup.
10:44:21 <tommd> breadmonster: Great answer.  And the trouble is what exactly?
10:44:53 <JLJ1> glguy many many thanks :)
10:45:11 <breadmonster> tommd: Okay, so I'm trying to compile the latest version, 7.10.x
10:45:25 <breadmonster> And I'm running Fedora 21 with ghc 7.6.3
10:45:36 <tommd> breadmonster: perl boot && ./configure && make && make install -- failes where exactly?
10:46:00 <geekosaur> arbelos: we don;t actually recommend them for serialization, a real parser works better. they are used for debugging where you generally want something as close to the haskell representation as possible to aid in understanding
10:46:24 <breadmonster> tommd: One second, so what I did was I ran `git clone http://github.com/ghc/ghc` in ~/projects/
10:46:34 <arbelos> geekosaur: yeah i was just looking at RWH and it mentions it also
10:46:42 <geekosaur> ...and something like binary or cereal works better yet for most serialization where a text format isn't required
10:47:07 <breadmonster> Error: utils/hsc2hs/LICENSE doesn't exist. Maybe you haven't done './sync-all get'? at boot line 75, <PACKAGES> line 52.
10:47:07 <breadmonster> tommd: And I get this error.
10:48:16 <harlanhaskins> :t filter . isLetter
10:48:17 <lambdabot>     Couldn't match type ‘Bool’ with ‘a -> Bool’
10:48:17 <lambdabot>     Expected type: Char -> a -> Bool
10:48:17 <lambdabot>       Actual type: Char -> Bool
10:48:23 <harlanhaskins> :t filter isLetter
10:48:23 <breadmonster> tommd: Any tips?
10:48:24 <lambdabot> [Char] -> [Char]
10:48:38 <harlanhaskins> :t map
10:48:39 <lambdabot> (a -> b) -> [a] -> [b]
10:48:45 <quchen> You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others). 
10:48:48 <breadmonster> What's the ghc dev channel?
10:49:02 <tommd> breadmonster: You have left out a step.  You did `git clone ...` then something then you got that error.
10:49:03 <quchen> breadmonster: The GHC dev channel is for GHC development, not for installation help.
10:49:43 <breadmonster> tommd: Running ./sync-all get only gives me another error.
10:49:47 <quchen> The Trac Wiki lists the dependencies and what to do in order to install GHC somewhere. I think it's called the building guide.
10:50:42 <breadmonster> tommd: What should I have done?
10:50:48 <tommd> breadmonster: Did you read 'README.md'?  The first step is, as I said above, perl boot
10:50:58 * hackagebot engine-io 1.2.4 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.4 (OliverCharles)
10:51:00 * hackagebot tttool 1.3 - Working with files for the Tiptoi pen  http://hackage.haskell.org/package/tttool-1.3 (JoachimBreitner)
10:52:13 <breadmonster> tommd: Alright, I'll delete it and restart.
10:52:37 <breadmonster> tommd: perl boot gives me an error.
10:53:56 <breadmonster> tommd: Can you tell me what this error means?
10:53:58 <breadmonster> Error: utils/hsc2hs/LICENSE doesn't exist. Maybe you haven't done './sync-all get'? at boot line 75, <PACKAGES> line 52.
10:54:12 <hexagoxel> breadmonster: did you respect the git submodules? git repo makes use of those
10:54:30 <breadmonster> hexagoxel: I just cloned the source, I haven't touched anything.
10:54:54 <quchen> Read the build guide, then come back for specific questions. https://ghc.haskell.org/trac/ghc/wiki/Building
10:54:59 <hexagoxel> which is mentioned in one of the installation guide, iirc
10:55:58 * hackagebot hsx2hs 0.13.3 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.13.3 (DavidFox)
10:56:20 <hexagoxel> `git clone --recursive ....`; just clone probably is not sufficient
10:58:15 <breadmonster> hexagoxel: Oh okay, thanks a ton (:
11:02:58 <Baurin> hi
11:03:32 <Iceland_jack> hey Baurin
11:05:12 <Baurin> hello Iceland_jack 
11:27:48 <breadmonster> hexagoxel tommd quchen: It's compiling, thanks (:
11:30:02 <breadmonster> Does it automatically make installation logs?
11:37:37 <Sonicz> The following script returns maximum Int (http://lpaste.net/7949614784175931392). There is no straight equivalant for Integer?
11:41:33 <valdyn> Sonicz: because there is no max Integer?
11:41:38 <geekosaur> there is no real maximum for Integer
11:41:51 <geekosaur> it's what happens to fit into memory
11:42:07 <EvanR> the min of that and the max gmp integer
11:45:43 <Sonicz> valdyn - geekosaur: Ah of course! Haskell has no max.
11:46:04 <EvanR> > maxBound :: Int
11:46:05 <Sonicz> Hm... Can I convert the value to an Int somehow?
11:46:05 <lambdabot>  9223372036854775807
11:46:21 <geekosaur> gmp has no max, therefore ghc's implementation of Integer has no max
11:46:41 <geekosaur> other implementations might (I don't know offhand if the no-gmp simple integer implementation has a limit(
11:51:39 <o_pax> The point of Integer is that it is arbitrary-precision, so a maximum is never useful, no matter what implementation is used. 
11:52:13 <EvanR> arbitrary precision? arbitrary range. i cant arbitrarily have half an Integer
11:52:59 <o_pax> precision means potentially unlimited number of digits. It has nothing to do with fractionals.
11:53:34 <EvanR> how is that precision
11:53:56 <kadoban> EvanR: Think of a floating point. It can store most Integer numbers, in practice, but with /really/ bad precision.
11:54:22 <EvanR> yeah so you lose precision, you can represent certain values between two numbers
11:54:25 <EvanR> cant*
11:54:40 <EvanR> like your resolution is going down
11:54:50 <steffen>  I have a Conduit 'Source m BS.ByteString' where m is already fixed qualified to be some monadStack. How do I put one more MonadT (StateT in my case) on that stack on wich the conduit operates?
11:54:59 <EvanR> and your resolution is fixed with Integer
11:55:02 <EvanR> cant get higher
11:55:19 <mauke> EvanR: you have to see it in relation to the magnitude of the number
11:55:43 <levi> EvanR: Think of how you write integers in scientific notation.
11:55:46 <EvanR> mauke: heh, so your precision is going up as the number goes up
11:55:54 <kadoban> Exactly
11:55:54 <EvanR> wonky
11:55:59 <o_pax> EvanR: Or think of Int as an approximation of natural numbers. It is a very good approximation up to maxBound::Int, but it is horrible after that. Integer is a better (or more _precise_) approximation, because it can represent more natural numbers than Int.
11:56:24 * EvanR responds to o_pax by saying think of Int as a natural with limited range
11:56:44 <steffen> I am looking for a way to do this "Source m ByteString -> Source (StateT Int m) ByteString"! How can I do this?
11:56:57 <f|`-`|f> > minbound :: Int
11:56:58 <lambdabot>  Not in scope: ‘minbound’
11:56:59 <lambdabot>  Perhaps you meant ‘minBound’ (imported from Prelude)
11:56:59 <EvanR> precision seems like a weird way to talk about natural numbers or integers, especially by bringing floating point into it
11:57:04 <f|`-`|f> > minbound :: Int
11:57:06 <lambdabot>  Not in scope: ‘minbound’
11:57:06 <lambdabot>  Perhaps you meant ‘minBound’ (imported from Prelude)
11:57:11 <EvanR> has nothing to do with it
11:57:15 <f|`-`|f> I can't capitalise
11:57:19 <Trollinator> Why put up with approximations when you can have the real thing? data Nat = Z | S Nat . nuff said.
11:57:36 <EvanR> Nat = Z | S Nat has arbitrary precision ;)
11:57:38 <levi> EvanR: If you're dealing in scientific notation, you can write a really large integer, but you lose precision in your represetnation of the number if you've got a fixed width storage.
11:57:40 <EvanR> arbitrarily 1
11:57:52 <EvanR> levi: if you were, of course, we usually arent
11:57:57 <EvanR> with Integer
11:58:02 <f|`-`|f> Because there are non-trivial hardware quirks, Trollinator 
11:58:23 <dolio> Just install GHC 7.10, and get actual naturals that are fast, too.
11:58:26 <EvanR> it sounds like a lot of trouble to go through to justify sloppy language that has become common
11:58:31 <EvanR> like "bandwidth"
11:58:32 <f|`-`|f> Some dude in the past suggested a varaible length encoding unum
11:58:57 <arianvp> Ugh. need to come up with a proposal for GSoC
11:59:10 <f|`-`|f> I think he noted some hardware slow downs
11:59:28 <f|`-`|f> but the numbers are stored in a minimally required amount of space
11:59:52 <Trollinator> What is this "real world" think people keep harping about?
12:00:00 <Trollinator> s/think/thing/
12:00:10 <EvanR> real world fake people
12:00:13 <f|`-`|f> the guy went on to talk about ubox, which is more or less an n-dimensional 2^n-tree approximation of solution spaces
12:00:27 <f|`-`|f> I don't know what he was thinking with that
12:00:48 <schell> is cabal capable of detecting the use of display server - as in - can it know whether the system is using X, Wayland or Mir?
12:01:07 <f|`-`|f> But I can give him credit for reinventing swarm solutions
12:01:14 <o_pax> EvanR: "precision" for Ints is not sloppy language, it means that Haskell Integers approximate  the mathematical Integers arbitrarily well.
12:02:02 <o_pax> s/precision/arbitraty-precision/
12:02:17 <dolio> schell: You might be able to write a custom Setup.hs that would do so. But it certainly doesn't do it by default.
12:02:27 <EvanR> o_pax: it is sloppy, Ints and Integer have a precision of 1
12:02:27 <levi> EvanR: Well, that's irrelevant. I'm just trying to explain why they're called 'arbitrary precision integers' pretty much universally.
12:02:38 <schell> dolio: thanks - I think I’ll let the user toggle a flag
12:02:45 <EvanR> irrelevant, perhaps ;)
12:02:51 <EvanR> well agree to agree
12:03:18 <EvanR> the precision of ints and integer is 1 part in 1
12:03:46 <EvanR> +/- 0
12:03:49 <kadoban> The only other term I even know for that, that doesn't include the word "precision", is "bigint", which I just feel like an idiot saying.
12:03:58 <EvanR> its an arbitrary range integer
12:04:20 <valdyn> calling maths / maths language sloppy is ironic
12:04:29 <arianvp> Who is responsible for the haskell GSoC? edwardk?
12:04:37 <levi> EvanR: With fixed-width data formats, you either have limited size or limited precision.  You can pick when you design your data representation.
12:04:54 <dolio> Maths language is sloppy, sometimes.
12:05:04 <EvanR> this is sloppy engineering language
12:06:03 <levi> It's pretty easy to design a limited-precision integer type in a fixed-width field using something akin to scientific notation.  We don't normally do that, sure, but that's mainly a matter of machine efficiency.
12:06:25 <EvanR> you mean one that can only represent even numbers?
12:06:29 <iulhysuigharw> did usa covertly supply isis with weapons like they did with al-qaeda to justify creating wars?
12:06:29 <iulhysuigharw> did usa excute the creative mess in the middle east like they said they will, does the creative mess include explosions with uncertain responsibles to create wars?
12:06:29 <iulhysuigharw> plz, send my qs to help limiting usa&israel aggression against others.
12:06:29 <iulhysuigharw> .
12:06:29 <iulhysuigharw> did usa covertly supply isis with weapons like they did with al-qaeda to justify creating wars?
12:06:29 <iulhysuigharw> did usa excute the creative mess in the middle east like they said they will, does the creative mess include explosion with uncertain responsibles to create wars?
12:06:29 <iulhysuigharw> plz, send my qs to help limiting usa&israel aggression against others.
12:06:32 <EvanR> yeah that would be limited
12:07:07 <levi> EvanR: No, I mean you can store really big numbers, but you lose precision (i.e. you drop less-significant digits) as the size of the number increases.
12:07:20 <dolio> It could store odd numbers if they were small enough.
12:08:57 <levi> EvanR: My point is, once you move beyond the basic machine encoding of integers, arbitrary precision of floats and arbitrary range of integers are basically the exact same thing.
12:09:23 <levi> It boils down to how many digits you can encode and where the decimal point goes.
12:09:47 <EvanR> levi: so we are more interested in what happens between 2^52 and 2^1023 than what happens after that?
12:10:34 <levi> I'm not sure what you're getting at.
12:10:35 <EvanR> i guess that could explain the preponderance
12:10:57 <EvanR> people consider ieee floats as being a broken integer
12:10:59 * hackagebot process-extras 0.3.3.1 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.3.1 (DavidFox)
12:11:01 * hackagebot smoothie 0.1.3 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.1.3 (DimitriSabadie)
12:11:14 <EvanR> the default, unless you use "bigint"
12:11:19 <EvanR> which fixes it
12:11:34 <EvanR> no body uses numbers past max float so range is not the concern
12:12:02 <EvanR> in my mind floats never entereed into it
12:12:29 <levi> I'm just trying to explain why 'arbitrary precision' correctly and precisely describes both big integers and big floats.
12:12:53 <EvanR> i see that, but i was only concerned with integers in isolation
12:13:04 <EvanR> floats are kind of a redhedded step child in haskell
12:13:29 <EvanR> who outperforms all his stepsiblings
12:14:46 <o_pax> EvanR: the best approximation of the number 10**30 in Int is 9223372036854775807, which is a pretty bad approximation. Integer can *precisely* represent that number, if your memory is big enough. Thus: arbitrary percision.
12:15:27 <EvanR> the number 10**30 is out of range
12:15:39 <EvanR> is it in range of Integer
12:15:54 <o_pax> EvanR: yes, if your memory is big enough.
12:16:01 <EvanR> what would you say the "level of approximation" Infinity float is to 10*400 ?
12:16:05 <levi> o_pax: There are other integer encodings, though, that approximate it differently.
12:16:08 <EvanR> 10^
12:16:21 <o_pax> levi: Clearly.
12:16:32 <levi> o_pax: I mean, fixed-width encodings.
12:16:34 <o_pax> levi: I did not want to dispute that.
12:16:41 <pEquals2>  /nick pEquals2
12:17:48 <levi> My point is that the range limit of Int is due to its encoding rather than its width. The choice was to be 100% precise at the cost of range. But other choices can be made.
12:18:40 <o_pax> levi: I totally agree. I just wanted to explain to EvanR why "precision" for a datatype that models mathematical integers is not sloppy language.
12:19:11 <EvanR> precision = 1 ;)
12:19:17 <EvanR> (for numbers in range)
12:19:23 <levi> Yeah, we have the same goal. I think I'm done with my attempt, though.
12:19:45 <EvanR> im only trying to attempt to change millions of peoples minds
12:19:49 <EvanR> whats the problem
12:20:59 * hackagebot singletons 1.1.1 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-1.1.1 (RichardEisenberg)
12:22:06 <o_pax> EvanR: all datatypes are completely precise for numbers in range. It just happens that 0.5 is in range for IEEE floats, while 0.1 is not.
12:22:20 <EvanR> now thats ridiculous
12:22:29 <EvanR> "0.1 is not in range"
12:22:35 <o_pax> EvanR: that is precise language.
12:22:42 <EvanR> its not representable
12:23:05 <EvanR> is it less than the max and greater than the min
12:23:11 <levi> Because its representation requires infinite digits.
12:23:22 <levi> So, in a sense, it is out of range.
12:23:25 <o_pax> EvanR: but there is no IEEE float with the value 0.1
12:23:26 <EvanR> its within range
12:23:43 <EvanR> levi: yeah this backward sense is what im complaining about, people contorting their minds to fit weird language, but im done now
12:23:55 <levi> The representation is out of range of its container, though the value would be in range.
12:24:06 <EvanR> floats are a subset of the reals
12:24:11 <EvanR> theres a range
12:24:18 <EvanR> (ignoring infinity and nan)
12:24:35 <dolio> Floating point numbers are a subset of the rationals. :)
12:24:46 <EvanR> more precisely a subset of rationals
12:24:53 <EvanR> (ignoring infinity and nan)
12:24:56 <levi> We are working with computers, though, not abstract mathematical entities. As much as we would like to be working with the math instead... :)
12:25:08 <valdyn> EvanR: why are you trying to replace language convention with your intuition? this wont work in any field.
12:25:12 <dolio> The mathematical description of floating point numbers doesn't have infinity and nan anyhow. :)
12:25:18 <EvanR> its not intuition 
12:25:34 <valdyn> EvanR: range is not defined what you are intuiting
12:25:48 <valdyn> EvanR: precision is not defined as ...
12:25:50 <shachaf> dolio: What about negative zero?
12:25:51 <EvanR> you dont have to admit that the terminology is wonky
12:26:03 <valdyn> EvanR: its wonky in any field
12:26:06 <EvanR> it is nonetheless
12:26:06 <dolio> shachaf: Mathematicians don't do stuff like that, either.
12:26:43 <dolio> Well, maybe they do sometimes. But not in the case of floating point numbers.
12:27:51 <o_pax> EvanR: how about this: doubles are more precise than floats because they can represent more rational numbers. 
12:28:12 <ttt_fff> three penny gui -- the haskell gui via browser library -- is there anyway to load a css file ?
12:28:18 <levi> EvanR: The terminology *seems* wonky from a limited point of view. A scientist working with large numbers all the time would not find it odd at all, even if they were not using a computer.
12:28:32 <o_pax> EvanR: (Haskell) Integer is more precise than Int (in modelling mathematical Integers) because it can respresent more numbers
12:28:37 <EvanR> stop trying so hard to support common jargon
12:28:47 <EvanR> challenge the man!
12:29:12 <EvanR> levi: earlier i was explaining this from a limited point of view, the limited range of floats
12:29:12 <o_pax> :)
12:29:26 <geekosaur> because being comprehensible and comprehended by others is overrated
12:29:39 <EvanR> never needed it
12:29:58 * EvanR goes back to his high bandwidth download
12:46:22 <nkar`> is there an alternative to the switch statement in haskell?
12:46:35 <nkar`> so I could have multiple cases and fall through them
12:46:43 <paolino>  case
12:46:58 <paolino> case ... of ... -> 
12:47:00 <nkar`> paolino: case will pick up the first matching branch
12:47:00 <geekosaur> but there is no fallthrough
12:47:09 <geekosaur> and C's fallthrough is generally seen as a misfeature
12:47:12 <nkar`> right, I want switch without break
12:47:18 <nkar`> geekosaur: I'm aware
12:47:22 <nkar`> I know what I'm doing
12:47:25 <nkar`> (c)
12:47:49 <nkar`> so, is there anything like that or not?  I can't think of anything similar.
12:48:54 <ReinH> If you think you need fallthrough, what you usually need is to restructure your data so that similar things are similar and different things are different
12:49:04 <ReinH> so that you can pattern match effectively
12:50:53 <m0rphism> nkar`: What is the reason you want this semantics? Is it speed or to avoid duplication?
12:50:53 <napping> another thing is extracting commin behavior into local functions to share between cases
12:51:14 <nkar`> m0rphism: a helpful error message, not speed
12:51:27 <nkar`> m0rphism: avoiding duplication, essentially
12:51:39 <paolino> fallthrough means multiple matches  ?
12:51:50 <m0rphism> couldn't you extract the right hand sides into a common function?
12:52:56 <nkar`> I'm sorry, I don't have much time to describe the problem.  I'll do what ReinH suggested.
12:54:15 <m0rphism> might be the better solution. This avoids having to identical branches on every pattern match.
12:54:23 <m0rphism> s/to/two
13:20:59 * hackagebot process-extras 0.3.3.2 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.3.2 (DavidFox)
13:31:00 * hackagebot hsx2hs 0.13.3.1 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.13.3.1 (DavidFox)
13:34:10 <steffen> Again: Lets say I have a value of Monad m => m a , how can I lift this in a StateT e.g. "Monad m => m a -> StateT MyState m a" ?
13:35:37 <Clint> steffen: return?
13:36:02 <steffen> Clint hahaha thanks :) 
13:36:18 <arkeet> steffen: do you really have a value of type forall m. Monad m => m a, polymorphic in m?
13:36:19 <S11001001> steffen: have a code sample?
13:36:26 <arkeet> also, 
13:36:27 <arkeet> :t lift
13:36:28 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
13:37:01 <steffen> S11001001: I'll try return, it should work, if it doesn't I'll be back with an example ;)
13:37:03 <ReinH> (No, not return)
13:37:15 <arkeet> try lift
13:37:16 <ttt_fff> in haskell's IO (), what is the cheapest way to store a state variable? (I'm doing GUI programming via three-penny, and I need to store the 'toggle state' of a div, to know whether to hide it or to unhide it)
13:37:38 <EvanR> an IORef
13:37:43 <arkeet> something like an IORef?
13:37:48 <S11001001> nkar`: there's nothing like that; it wouldn't make sense anyway, because a statement with an ignored value doesn't exist, due to its uselessness
13:37:49 <arkeet> (but then you need to hang on to the IORef)
13:38:06 <steffen> arkeet: no it is constrained in m
13:38:11 <ReinH> Cheapest? Pass the state an argument.
13:38:14 <ttt_fff> IORef = cheapest ?
13:38:19 <ttt_fff> https://hackage.haskell.org/package/base-4.5.0.0/docs/Data-IORef.html#t:IORef <-- this guy?
13:38:20 <ReinH> s/an/as an
13:38:31 <EvanR> if you can pass as an argument that would be better
13:38:50 <arkeet> I don't know much about threepenny, maybe there's something better for that.
13:39:54 <arkeet> maybe IORef is inappropriate.
13:40:30 <napping> IORef is a basic mutable variable, with nothing much for thread safety
13:40:41 <napping> You'd really need to check the docs on what threepenny does with threads
13:41:23 <nkar`> would people like to see mixfix ops in haskell?
13:42:08 <kaidelong> ttt_fff: mm, how do you hide or unhide a div in threepenny?
13:42:26 <ttt_fff> magic :-)
13:42:34 <kaidelong> well I'm asking because
13:42:34 <ttt_fff> you use css + display: none;
13:43:05 <barrucadu> Rather an an IORef, couldn't you just check for display:none on the div?
13:43:18 <barrucadu> If it's not there, hide it, if it is there, unhide it
13:43:47 <ttt_fff> possibly; but this is fucking threepenny; so doing that would be a round trip over a webcosket
13:43:52 <ttt_fff> or I pay the price of an IORef
13:44:00 <ttt_fff> I think IORefs are faster than talking over a websocket
13:44:11 <kaidelong> why not just write javascript for it, then?
13:44:24 <ttt_fff> have you used haste / ghcjs ?
13:44:38 <ttt_fff> I also suspect that my 16GB of RAM can store many IORef Bools
13:45:38 <EvanR> indeed you can make a global Vector of billions of IORef Dynamic and pretend this is PHP ;)
13:46:02 <octopuscabbage> okay so say I have somethign of type [a] or Maybe a. how to i refer to the [] or Maybe in relation to a? do i say it's a type on 'a' or what?
13:46:24 <Cale> [] and Maybe are type constructors
13:46:34 <ttt_fff> I think to be php, we also need to do "instance Bool [every $^%& object] where", and have the meanings be competely counterintuitive
13:46:44 <napping> ttt_fff: It's not too productive to worry that much about efficiency, especially if you're using threepenny in the first place
13:46:45 <EvanR> purescript has class BoolLike
13:46:59 <octopuscabbage> Cale, I understand that they are functions but I more mean in type signatures and stuff
13:47:04 <napping> but it seems it runs all your code in one Haskell thread, so have at it with the IORef if you like
13:47:14 <arkeet> what do you mean by "refer"?
13:47:21 <ttt_fff> napping: agreed; I was being sarcastic on all lines after the comparison of IORef vs websocket :-)
13:47:28 <napping> Their reactive stuff is interesting, but maybe overkill after your case
13:47:30 <Cale> octopuscabbage: Yeah, if that's not the answer you wanted, I'm not sure what you're asking
13:47:52 <ttt_fff> napping: I actually loked at it beuase of reactive-banana, but I can't get reactive-banan-threepenny to build
13:48:02 <octopuscabbage> So if I want to say that not only in haskell can you have Int but you can also have Maybe Int, what do I call what maybe is in relation to the int in that statement?
13:48:14 <arkeet> Maybe is a type constructor.
13:48:15 <napping> ttt_fff: lately threepenny itself includes a little Reactive model, which I guess is designed along the lines for reactive-banan
13:48:16 <arkeet> it is applied to Int.
13:48:21 <octopuscabbage> arkeet: I mean in a conversation, not in a programming sense
13:48:26 <octopuscabbage> arkeet, so it's a type applied to int?
13:48:27 <Cale> Yeah, you're looking for the words "type constructor"
13:48:38 <Cale> A type constructor applied to Int
13:48:53 <octopuscabbage> Cale, I think applied is more the word I was looking for
13:48:53 <arkeet> type constructors are functions from types to types.
13:48:54 <pdxleif> @kind Maybe
13:48:55 <lambdabot> * -> *
13:49:03 <napping> ttt_fff: see if you have a Ractive.Threepenny model
13:49:06 <arkeet> functions are things you apply.
13:49:07 <napping> *module
13:49:18 <ttt_fff> napping: I saw it in the docs; have not played with it yet
13:49:37 <napping> I think reactive-banana-threepenny might be obsolete or something?
13:50:45 <EvanR> @pl \t -> (f t) (g t)
13:50:46 <lambdabot> ap f g
13:50:46 <napping> That is, I remember some blog posts about development plans, and I think that might not be the currently recommended way to do reactive stuff, even if the author plans to reconnect them eventually
13:51:19 <arkeet> EvanR: or f <*> g
13:51:32 <EvanR> nice
13:57:10 <kylcarte> Are there any good resources on designing fundeps for classes out there? 
14:00:20 <jackhill> win 21
14:18:14 <nkar`> does RecordWildCards work inside a QuasiQuoter?
14:18:17 <EvanR> @hoogle Monad m => (a -> m (Maybe b)) -> [a] -> m (Maybe b)
14:18:20 <lambdabot> No results found
14:18:49 <c_wraith> nkar`: err.  What do you mean by that? QuasiQuoters are like String -> ExpQ
14:19:27 <c_wraith> nkar`: do you mean can you generate code that uses RecordWildCards?
14:19:58 <nkar`> c_wraith: I'm using the {..} syntax inside [mything| ... |] and getting "RecordWildCards is not enabled"
14:20:17 <nkar`> I enabled the extension in both files, just to make sure
14:20:22 <nkar`> and it fails nevertheless
14:21:16 <EvanR> @hoogle Monad m => [m (Maybe a)] -> m (Maybe a)
14:21:19 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:21:19 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
14:21:19 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
14:21:24 <EvanR> asum
14:21:29 <c_wraith> nkar`: I could have sworn the stuff in your ... is just treated as a string by the QQ system.
14:22:01 <int-e> nkar`: Looking at the Language.Haskell.TH.Syntax.Pat type I see no way of expressing a record wildcard.
14:22:26 <geekosaur> doesn't it effectively fire up a ghci though? which presumably does not have the same LANGUAGE flags enabled, which would be a bug
14:23:28 <int-e> hmm.
14:24:18 <nkar`> ScopedTypeVariables doesn't work either
14:24:46 <arkeet> how are you parsing the ... ?
14:26:00 * hackagebot QuickCheck 2.8 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.8 (NickSmallbone)
14:26:20 <nkar`> nevermind, I bet it's this case: ParseFailed _ e -> fail e
14:26:23 <int-e> nkar`: [p| Foo{..} |] works in the ghc-7.10 RC (and expands to the full lit of fields.
14:27:23 <c_wraith> I still don't understand the problem in the first place.  [mything| let Rec{..} = foo in bar |] doesn't parse the content as haskell.
14:27:38 <c_wraith> How could it possibly complain about a missing extension?
14:27:54 <int-e> Now where does the idea of calling normal TH quotations (pattern quotes, expression quotes, type quotes) quasi-quotations come from? quasi-quotations are the things that parse strings themselves.
14:29:14 <int-e> c_wraith: [p| |] is the pattern quoter.
14:29:20 <napping> Lisp has called things quasi-quotes for a lot longer
14:29:20 <nkar`> the code is here: https://gitorious.org/snowdrift/snowdrift/source/d3dbaf2615302ea9a899b4f7e84fa6c4f4f41b16:tests/TestImport/Internal.hs
14:29:32 <nkar`> marked as supposed to be a drop-in replacement for do
14:29:33 <c_wraith> int-e: the example used [mything| |]
14:29:47 <nkar`> but which prints the location on error
14:29:53 <napping> and there it's specifically the thing that has facilities for splicing computed stuff
14:30:22 <int-e> c_wraith: sorry, I missed that. so it does use a quasi-quoter, and it's a matter of the parser being used inside that (probably haskell-src-exts?)
14:30:26 <napping> if anything, it's Haskell's quasi-quoters that don't really fit the older usage, because they have to handle the whole string themselves
14:30:30 <arkeet> yes, it uses haskell-src-exts to parse the quoted thing.
14:30:34 <arkeet> not ghc.
14:30:45 <c_wraith> so the *real* question is "how do I tell haskell-src-exts to enable extensions"?
14:31:28 <int-e> c_wraith: that's only half the question. you *also* have to teach it (haskell-src-meta, perhaps?) to look up all the record fields for you.
14:31:43 <dfeuer> @ask ski Did you really expect me to reinvent http://arxiv.org/pdf/1309.5135.pdf  ?
14:31:43 <lambdabot> Consider it noted.
14:32:48 <Lutin`> o/
14:33:08 <c_wraith> int-e: oh, good point.  since there isn't a way to represent that in the TH AST, it needs to have a bunch of extra compiling work done.
14:33:22 <int-e> c_wraith: haskell-src-exts does know about RecordWildCards, encoded as a special case in PatField.
14:34:09 <int-e> And I recall that the parser takes a list of extensions somewhere.
14:34:47 <nkar`> int-e, c_wraith: nevermind, I eliminated the need for ScopedTypeVariables, by using let _ = r :: Type
14:35:45 <ski> @messages-loud
14:35:45 <lambdabot> dfeuer asked 4m 1s ago: Did you really expect me to reinvent http://arxiv.org/pdf/1309.5135.pdf ?
14:36:12 <dfeuer> Yes, ski?
14:36:17 <ski> dfeuer : i haven't seen that one before. it looks more complicated than what i did (perhaps it is more general, or handles more, i don't know)
14:36:23 <ski> dfeuer : i was thinking of something like my "`zipWith' using `foldr'" in 2007-04-10 at <http://lpaste.net/47814>, or Oleg's solution
14:36:59 <dfeuer> I tried much times, and failed gallons of different ways.
14:37:57 <ski> the interesting part is mainly that the "coroutining intuition" is correct. the rest is details about how to manage to express this in a working way
14:38:22 <dfeuer> ski, I did in fact make one attempt that involved using a newtype to get around an infinite type, but I couldn't figure out the *right* way around.
14:39:10 <ski> yeah, that's the crux :)
14:39:48 <ski> my `A a b c' and `B a b c' there should be thought of as types for the "internal states" of the two coroutines
14:40:17 <ski> when each one of those is resumed, it will be passed the "frozen" state of the other one, so that that one can resume later
14:40:35 <dfeuer> Rrrrrrr. 
14:40:47 <dfeuer> I will have to work through that for a while.
14:41:06 <dfeuer> ski, in the mean time, you can respond to my question on haskell-cafe about incremental sorting!
14:41:27 <ski> when A is relinguishing control to B, it also passes on the next element `a' that it has found. B will receive the next `b' (if any) and output the pair (or output `c' computed from `a' and `b')
14:41:37 * ski hasn't seen it
14:42:19 <dfeuer> Hmmm... I wonder if my emails are getting trapped in spam boxes for some reason.
14:42:57 <ski> (by "B will receive the next `b'" i mean it will receive it from it's `foldr'. namely the `consB' part of it (or `nilB' if no more `b'))
14:43:09 <dfeuer> Uhhhh
14:43:13 <ski> dfeuer : i mean, i haven't checked -cafe yet :)
14:43:42 <dfeuer> Like I said, I'll have to read that over a bunch to understand how these coroutines fit together.
14:45:16 <ski> dfeuer : might be simpler to manually step/trace through a small example of it
14:45:33 <ski> (though, now that i think of it, i can't recall ever doing that myself ..)
14:45:56 <lpaste> JLJ1 pasted “Help doing something dumb” at http://lpaste.net/127384
14:46:30 <JLJ1> Anyone mind taking a look at what I'm doing. I'm trying to get an list of ints.
14:46:34 <napping> Is this a good place for advice on Shake?
14:46:41 <dfeuer> ski, I can't find the right Oleg thing.
14:46:44 <glguy> JLJ1: length fans x   is     (length fans) x
14:47:00 <napping> I'm trying to read dependencies out of files, and I'm not quite sure how that should interact with "need" and stuff
14:47:43 <ski> dfeuer : it's linked to from my post
14:47:49 <ski> s/post/paste/
14:48:07 <dfeuer> ski, is it just a literate Haskell file,or is there more?
14:48:41 <JLJ1> glguy getNumFansFilmsByActor (x:xs) list = (length fans) x : list allFilmAsString xs list
14:48:41 <JLJ1>  
14:48:51 <JLJ1> glguy: didn't help sorry
14:49:03 <ski> dfeuer : it's <http://okmij.org/ftp/Haskell/zip-folds.lhs>, yes
14:49:06 <glguy> JLJ1: I was trying to show you why it was wrong, not to make it look like that
14:49:18 <ski> (earlier version posted on mailing list)
14:49:27 <JLJ1> glguy sorry my brain is going soft 
14:49:32 <glguy> JLJ1: Do you understand what this means? Could you try explaining it in words?    (length fans) x
14:49:36 <dfeuer> I couldn't tell if that was supposed to be some extra info or the main thing.
14:50:25 <JLJ1> glguy x is a film from xs; i want to count the number of fans of x; length fans x? is that flawed?
14:51:09 <glguy> JLJ1: fans is a function, but you're asking for the length of it
14:51:49 <glguy> length only works on lists. You'll need to use the "fans" function to get a list first, and then apply "length" to that
14:52:26 <JLJ1> glguy fans does return a list because it's part of the datarecord? 
14:52:42 <ski> dfeuer : i think <https://mail.haskell.org/pipermail/haskell/2005-October/016577.html> is the original oleg message
14:53:01 <dfeuer> Thanks. I think yours is probably going to be easier to understand anyway :-P
14:53:31 <glguy> JLJ1: fans is a "record selector". you need to apply fans to a value of that record to select that field
14:53:55 <glguy> It exists because you declared the record type above
14:54:23 <dfeuer> I wonder if this zipWith3' thing will actually fuse properly with Call Arity and such....
14:54:39 <dfeuer> Probably not.
14:55:32 <ski> (and <https://mail.haskell.org/pipermail/haskell/2005-October/016696.html>)
14:56:03 <ski> dfeuer : anyway, i only later became aware of Oleg's version, and checked that the basic idea was the same
14:57:02 <ski> (it was just a neat solution to a puzzle that i had been pondering a little. iirc, because it came up or was inspired by something someone mentioned in here at the time)
14:57:38 <JLJ1> glguy any recommendation of where I can read up on it that's not too complex; I've been using learnyouahaskell.
14:58:27 <dfeuer> ski, it's just more proof that I need to learn more, I guess. I have no clue how to figure such twisty things out.
14:58:45 <ski> dfeuer : anyway. i could of course have mentioned my solution directly, but i'm curious about whether other people will come up with something similar (or perhaps something different). struggling a little bit with it perhaps also makes you appreciate a solution more
14:59:34 <dfeuer> ski, well, I think I successfully proved that certain solution approaches cannot possibly work :-)
14:59:45 <ski> dfeuer : i think the basic "intuition idea" here of thinking of the computation in terms of (in this case) two coroutines, and that you can do that with folds, can possibly be a useful lesson for other problems, though
15:00:24 <dfeuer> ski, I see that. I do not yet see how that works, because I haven't spent enough time with it yet.
15:00:36 <dfeuer> But that does seem like the sort of thing I'd have fun playing with.
15:00:40 <dfeuer> So thanks.
15:01:13 <ski> as for how i figures that one out, well versions `0',`1',`2' in my paste aren't that hard to figure out -- for the final step, i needed the rough idea of wanting to represent coroutines and their forward-and-back passing of the control in some way
15:01:53 <ski> so, i played around with that, attempting to figure out how to express what i thought must be possible
15:02:03 <ski> (not sure i can explain it any better than that)
15:02:08 <dfeuer> I will.
15:02:09 <dfeuer> BUt
15:02:19 <dfeuer> There seems to be a problem.
15:02:47 <dfeuer> ski, zipWith3' does not typecheck so much at the moment.
15:02:55 <glguy> JLJ1: https://github.com/bitemyapp/learnhaskell has a lot of references. I don't know what the best starting point for learning about function application is, specifically
15:02:55 <oconnore> Hi, I just did a fresh install of the Haskell Platform, and the example here -> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/win32-dlls.html is erroring "multiple definitions of `main'", undefined reference to ZCMain_main_closure
15:02:57 <dfeuer> It may just need ScopedTypeVariables?
15:03:07 <ski> dfeuer : import `GHC.Exts.build', and turn on `Rank2Types' ?
15:03:10 <oconnore> is that documentation out of date? Or what could be going wrong?
15:03:33 <dfeuer> ski, oh, it needs higher-rank types? Weird...
15:03:43 <ski> @type GHC.Exts.build
15:03:44 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
15:03:51 <dfeuer> No, ski, that does not work.
15:04:01 <oconnore> I am doing exactly what is in the docs on a fresh install
15:04:11 <dfeuer> Oh, of course it doesn't work, ski!
15:04:24 <dfeuer> Ain't no hope for it as written.
15:04:35 <ski> (sorry, i should probably have done that myself in the paste .. that last  zipWith3'  was more of an afterthought, that i added when i repasted it, after the original paste had got lost on the old <hpaste.org>)
15:04:49 <dfeuer> Them thar newtypes don't match that version.
15:04:59 <dfeuer> I'll have to see if that can be repaired.
15:05:05 <JLJ1> glguy thanks one day I'll buy you a beer or coffee :P
15:06:07 <ski> dfeuer : hm .. actually, i think you're right. i didn't realize. i should fix that with an edit revision
15:06:12 <dfeuer> Fixed, ski. Just needed to add another type variable.
15:06:12 * ski is sorry
15:06:26 <dfeuer> Add d, and replace [c] with d.
15:06:28 <ski> i think replacing `[c]' with just `c' in the `newtype's is enough
15:06:51 <ski> (this is what i get for last-minute fixes !)
15:06:59 <dfeuer> Maybe? 
15:07:02 <dfeuer> Let me try that....
15:07:21 <dfeuer> Yeah, that works too, ski, and is better.
15:07:37 <dfeuer> But wait
15:07:38 <ski> (probably i did that change when i tested that last variant out, but forgot to fix it in what i pasted :( ..)
15:07:44 <dfeuer> Why do you need b?
15:08:13 <ski> i don't really, in this case
15:08:15 <dfeuer> Answer: you don't.
15:08:21 <dfeuer> Yeah, that.
15:09:14 <ski> this was just the first fix to break the cyclic type loop that worked. systematic in that i just abstracted over every type variable in scope
15:16:04 <pdxleif> Sounds zipper-esque? https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker
15:19:50 <sodifk> are the type signatures '(a -> b) -> c
15:20:04 <sodifk> are the type signatures '(a -> b) -> c' and 'a -> b -> c' equivalent?
15:20:18 <arkeet> no
15:20:25 <arkeet> the latter is equivalent to a -> (b -> c)
15:21:37 <sodifk> arkeet: the other day someone was explaining to me that they are actually equivalent because you can pass an 'a' to (a -> b) -> c and you would get a 'b -> c'
15:22:38 <pdxleif> you get a b -> c when you pass an a to a -> b -> c.
15:22:40 <arkeet> I think you or that someone got it mixed up.
15:23:01 <Fylwind> aawe: (old problem) so I found out how to catch errors in the ResourceT monad: turns out that ResourceT is an instance of MonadCatch from the 'exceptions' package, which provides the usual 'catch' function
15:23:02 <roboguy_> sodifk: that's the case for a -> (b -> c), not (a -> b) -> c
15:23:14 <pdxleif> passing an 'a' to an (a -> b) -> c would give you a type error: "a is not an a -> b"
15:23:28 <arkeet> the only thing you can apply to an (a -> b) -> c is an a -> b
15:23:45 <arkeet> er, got object and subject backwards.
15:24:01 <Fylwind> I guess my original confusion was because I didn't realize that the *concrete* type was actually ResourceT, which does have a MonadCatch instance
15:24:35 <sodifk> :t ($)
15:24:35 <lambdabot> (a -> b) -> a -> b
15:24:41 <sodifk> :t (1 $)
15:24:42 <lambdabot> Num (a -> b) => a -> b
15:24:46 <sodifk> :t (_ $)
15:24:47 <lambdabot>     Found hole ‘_’ with type: a -> b
15:24:47 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
15:24:47 <lambdabot>                the inferred type of it :: a -> b at Top level
15:24:55 <sodifk> :t (1 $)
15:24:56 <lambdabot> Num (a -> b) => a -> b
15:25:30 <sodifk> what about that ^
15:26:01 * hackagebot bindings-GLFW 3.1.1.2 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.1.1.2 (SchellScivally)
15:26:07 <benzrf> :t 1 2
15:26:08 <lambdabot> (Num (a -> t), Num a) => t
15:26:10 <benzrf> hmm
15:26:37 <roboguy_> sodifk: that is something very different. Because Haskell's numeric literals are polymorphic, it's trying to treat a function like a number
15:26:45 <roboguy_> which results in confusing messages
15:26:51 <sodifk> :t ((1 :: Int) $)
15:26:52 <lambdabot>     Couldn't match expected type ‘a -> b’ with actual type ‘Int’
15:26:52 <lambdabot>     In the first argument of ‘($)’, namely ‘(1 :: Int)’
15:26:52 <lambdabot>     In the expression: ((1 :: Int) $)
15:26:57 <sodifk> ah
15:27:16 <roboguy_> The function instance doesn't actually exist (you could add one, but that can add confusion)
15:27:34 <roboguy_> :t 5
15:27:35 <lambdabot> Num a => a
15:27:49 <arkeet> NumInstances is great.
15:29:05 <sodifk> is there some data type that represents a 'one'/'identity' that i can use as a placeholder for messing around with types in haskell?
15:29:24 <Fylwind> () ?
15:29:25 <roboguy_> sodifk: maybe undefined? what do you mean?
15:29:26 <Fylwind> _ ?
15:29:28 <pdxleif> Default?
15:29:34 <belgin> why is operator (<=) expecting type (Float, Float) -> (Float, Float) for its second argument?
15:29:44 <roboguy_> :t undefined
15:29:45 <lambdabot> a
15:29:51 <belgin> i'm trying to compare a couple of floats
15:29:58 <sodifk> roboguy_: a value that can take any type and doesnt need any type parameters?
15:30:05 <sodifk> a constructor that is
15:30:12 <kadoban> :t (<=)
15:30:13 <lambdabot> Ord a => a -> a -> Bool
15:30:15 <pdxleif> undefined, maybe?
15:30:19 <roboguy_> sodifk: well, undefined can take on any type if that's what you mean
15:30:19 <sodifk> :t (())
15:30:20 <lambdabot> ()
15:30:21 <kadoban> belgin: Probably something else around it.
15:30:46 <sodifk> roboguy_: yeah thats what i mean thanks
15:30:49 <roboguy_> sodifk: you can also use a type hole, _, to ask GHC what type should go in a certain spot
15:30:54 <roboguy_> (_ $)
15:30:56 <roboguy_> > (_ $)
15:30:57 <lambdabot>  Found hole ‘_’ with type: a -> b
15:30:57 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
15:30:57 <lambdabot>             the inferred type of it :: a -> b at Top level
15:31:01 * hackagebot GLFW-b 1.4.7.2 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.7.2 (SchellScivally)
15:31:24 <sodifk> > id _
15:31:25 <lambdabot>  Found hole ‘_’ with type: a
15:31:25 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
15:31:25 <lambdabot>             the inferred type of it :: a at Top level
15:32:07 <sodifk> :t (undefined $)
15:32:08 <lambdabot> a -> b
15:32:10 <belgin> kadoban, this is it http://pastebin.com/gDws9g25
15:32:40 <sodifk> oh right cause undefined can also be (a -> b)
15:32:44 <pavonia> Are there other holes than '_'?
15:32:47 <roboguy_> > fmap _ (Just 'a')
15:32:49 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Char -> b
15:32:49 <lambdabot>  Where: ‘b’ is a rigid type variable bound by
15:32:49 <lambdabot>             the inferred type of it :: Data.Maybe.Maybe b at Top level
15:32:59 <roboguy_> pavonia: you can have a hole with any name that starts with _
15:33:09 <roboguy_> > map _f _xs
15:33:11 <lambdabot>  Found hole ‘_f’ with type: a0 -> b
15:33:11 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
15:33:11 <lambdabot>         ‘b’ is a rigid type variable bound by
15:33:22 <roboguy_> lambdabot cuts off, but it usually shows all of them
15:33:42 <sodifk> cool
15:33:47 <kadoban> belgin: I don't really understand what that is. The advice I'd give would be to put explicit type-signatures on as much of that as you can until the error message starts making more sense
15:33:58 <pavonia> roboguy_: So all undefined variables starting with '_' are holes?
15:34:04 <belgin> ok, thanks kadoban
15:34:07 <roboguy_> pavonia: yep
15:34:13 <pavonia> Okay
15:34:22 <sodifk> can I have a type like undefined but it has to be a value? or it has to have x params?
15:34:34 <roboguy_> pavonia: in expressions anyway. You can have have named, ignored patterns with the _ prefix
15:34:46 <kadoban> sodifk: undefined isn't a type, it's a value
15:35:11 <sodifk> kadoban: right, but it can take any type even a function of any number of params
15:35:14 <roboguy_> sodifk: I'm not sure what you mean. undefined is a value of type forall a. a
15:35:34 <sodifk> is there something that is like undefined but only for n curryings?
15:35:37 <roboguy_> sodifk: undefined can take on any type, including function types
15:35:45 <roboguy_> :t undefined 'a' 'b' 'c'
15:35:46 <lambdabot> t
15:35:50 <kadoban> > :t undefined :: a -> b -> c
15:35:52 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:35:55 <kadoban> Bah
15:36:02 <quchen> :t undefined :: a -> b -> c
15:36:03 <lambdabot> a -> b -> c
15:36:11 <sodifk> like undefined_1 = restricted to values only (no functions) ?
15:36:30 <sodifk> undefined_2 = restricted to functions with one currying (a -> b)
15:36:32 <sodifk> etc
15:36:34 <roboguy_> sodifk: that would be a problem. functions are values, so how do you make the distinction?
15:36:36 <kadoban> sodifk: Only if you specify what it is. I don't think there's a "Anything but a function" constraint or anything.
15:37:02 <roboguy_> sodifk: after all, what if you have function that returns a value that happens to be a function?
15:37:25 <sodifk> right...
15:37:47 <roboguy_> like: f n = if n > 3 then (* 10) else (+ 5)
15:38:31 <sodifk> I guess it would have to be a runtime thing like a pattern match?
15:39:10 <roboguy_> It would probably need to be compile time. You could do something with type families, but I don't know if you can make an inhabited type that would be what you want
15:39:19 <roboguy_> and it would be relatively advanced stuff if you could
15:40:18 <roboguy_> sodifk: why do you want to do it? Just curiosity or is there a larger problem?
15:40:39 <sodifk> just curiosity
15:41:10 <kaidelong> does gloss come with any way to write output to a file?
15:42:41 <HeladoDeBrownie> kaidelong, use the IO interface instead of the pure one
15:43:04 <HeladoDeBrownie> e.g., http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss-Interface-IO-Game.html
15:44:29 <kaidelong> HeladoDeBrownie: what does this buy me?
15:44:43 <kaidelong> is it so I can add a print function using openGL binds?
15:45:15 <HeladoDeBrownie> kaidelong, i don't know what you mean about opengl binds. i was only answering your question.
15:45:27 <kaidelong> alright I don't understand the answer then
15:45:43 <HeladoDeBrownie> you can use an IO action to write to a file
15:46:00 <HeladoDeBrownie> and playIO lets you, e.g., respond to a key press with an IO action
15:46:01 <haasn> luite: does ghcjs target “asm.js”?
15:46:20 <kaidelong> but I can't write the output of gloss to a file using this that I can see
15:46:29 <HeladoDeBrownie> what's the "output of gloss"?
15:46:40 <kaidelong> the raster render it displays
15:46:49 <EvanR> screenshot
15:46:57 <kaidelong> that is what I was going to do, yes
15:47:00 <kaidelong> I guess it's the only way
15:47:04 <ProofTechnique> Depending on your usecase, you might find diagrams useful
15:47:12 <HeladoDeBrownie> if there's an interpreter for Picture you can use that
15:47:15 <ProofTechnique> I don't know how much you need the OpenGL stuff
15:47:45 <kaidelong> mm, oh, that's true, maybe there is a library on hackage that can turn picture to SVG?
15:48:08 <silver> sounds like a bad idea
15:48:13 <HeladoDeBrownie> Picture is specifically from gloss, so if it exists it'll be in the gloss package
15:48:40 <ProofTechnique> @hoogle Picture -> SVG
15:48:41 <HeladoDeBrownie> i'm not seeing anything for that though
15:48:42 <silver> oh, by picture you mean some kind of vector-like graphics?
15:48:43 <lambdabot> Warning: Unknown type Picture
15:48:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:48:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:48:44 <HeladoDeBrownie> ah
15:48:51 <ProofTechnique> Well, it was worth a shot
15:48:53 <HeladoDeBrownie> oh never mind, thought you had found it
15:49:04 <kaidelong> raster would be fine
15:49:14 <kaidelong> any conversion to PostScript would be ideal
15:49:39 <kaidelong> I'll just take a screen shot
15:49:46 <kaidelong> it's awful, but it works
15:50:32 <HeladoDeBrownie> unfortunately gloss doesn't seem to expose an interpreter for Picture
15:51:05 <HeladoDeBrownie> it does expose its constructors, but that'd get messy
15:53:01 <kaidelong> now I need to figure out how to make text remotely reasonable in terms of size
16:01:01 * hackagebot swish 0.9.1.3 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.1.3 (DouglasBurke)
16:10:59 <Fylwind> Regarding FRP, I read that "Time leaks aren't really a problem anymore, because they are largely related to the monadic framework."
16:10:59 <Fylwind> Does anyone know of some literature that explains this in greater detail?
16:11:40 <lpaste> ski revised “`zipWith' using `foldr'”: “removed badly inserted last-minute alternate version” at http://lpaste.net/47814
16:11:48 <lpaste> ski revised “`zipWith' using `foldr'”: “removed badly inserted last-minute alternate version” at http://lpaste.net/47814
16:12:06 <lpaste> ski annotated “`zipWith' using `foldr'” with “corrected alternate version, with the actual version of `A' and `B' i used for it” at http://lpaste.net/47814#a127465
16:12:35 <ski> (er, double revise was a misclick)
16:13:34 <ski> @tell dfeuer fwiw, i corrected the bas last-minute change at <http://lpaste.net/47814>
16:13:34 <lambdabot> Consider it noted.
16:24:03 <kaiyin> real world haskell says foldl is almost never used in reality because it creates a lot of thunks. Doesn't foldr create the same number of thunks?
16:26:22 <shachaf> Do you have a particular example in mind?
16:27:10 <kaiyin> I am sorry, now I have reach the next page which says we should use foldl' form Data.List instead.
16:27:20 <moghedrin> Anybody have any example how to use the ssh package to make an ssh server?
16:27:27 <eiffel> I'm trying to run cabal install cabal-install on a ubuntu 14.04 VM. I'm having an issue with zlib... This post describes my issue, but I can run as root. https://mail.haskell.org/pipermail/libraries/2013-July/020447.html
16:27:41 <kaiyin> So that's not about foldr being better than foldl.
16:28:54 <shachaf> Ah. Yes.
16:31:21 <geekosaur> eiffel: --extra-include-dirs, --extra-lib-dirs
16:31:22 <bergey> Fylwind: http://apfelmus.nfshost.com/blog/2012/09/03-frp-dynamic-event-switching-0-7.html and http://conal.net/blog/posts/trimming-inputs-in-functional-reactive-programming are both good, as I recall.
16:31:30 <geekosaur> in a sandbox you can put that into cabal.sandbox.config
16:31:43 <Fylwind> bergey: thank you!
16:31:48 <geekosaur> (same format as you'd use in ~/.cabal/config)
16:31:52 <eiffel> thanks geekosour - trying that
16:32:11 <eiffel> geekosaur * ;)
16:32:21 <Hijiri> kaiyin: foldr can result in less computation than foldl' if the folding function is lazy in the accumulator
16:32:41 <Hijiri> it also keeps things like constructors lazy
16:33:04 <kaiyin> Hijiri, could you give an example?
16:33:08 <geekosaur> also if your system is sufficiently obnoxious then what it unpacked for libz.so is a symlink to the runtime .so expected to be in the same directory, in which case it won't work >.>
16:33:23 <Hijiri> kayin: foldr (||) False
16:33:35 <Hijiri> suppose I have a list [True, False]
16:33:41 <Hijiri> @src foldr
16:33:41 <lambdabot> foldr f z []     = z
16:33:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:34:05 <eiffel> now I'm getting cabal-install-1.22.0.1 depends on Cabal-1.22.1.1 which failed to install.
16:34:11 <Hijiri> foldr (||) False [True, False] goes to True || foldr (||) [False]
16:34:39 <Hijiri> now we don't need to compute foldr (||) [False] because (||) is lazy in the second argument, if the first argument is True
16:34:56 <Hijiri> which is a long way to say that || short-circuits
16:35:02 <Hijiri> @src foldl'
16:35:02 <lambdabot> foldl' f a []     = a
16:35:02 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:36:19 <Hijiri> foldl' (||) False [True, False] becomes foldl' f True [False] (I implicitly did seq)
16:36:42 <Hijiri> but since foldl' is the outermost function call you have to do foldl' again
16:37:05 <Hijiri> and then it becomes foldl' (||) True [], which evaluates to True
16:37:19 <Hijiri> In the case with foldr, you only had to get to the True element before stopping
16:37:23 <Hijiri> foldl' required you to walk the whole list
16:37:51 <Hijiri> if the list was [True, False, False....., foldl' would never finish at all
16:38:03 <Hijiri> because it would keep on walking the list infinitely
16:38:16 <Hijiri> @let longlist = True : repeat False
16:38:19 <lambdabot>  Defined.
16:38:26 <Hijiri> > foldr (||) False longlist
16:38:29 <lambdabot>  True
16:38:37 <Hijiri> > foldl' (||) False longlist
16:38:42 <lambdabot>  mueval: ExitFailure 1
16:39:50 <arkeet> :t (?x $)
16:39:51 <lambdabot> (?x::a -> b) => a -> b
16:41:02 * hackagebot spir-v 0.0.0.1 - Some utilities for reading and writing SPIR-V files  http://hackage.haskell.org/package/spir-v-0.0.0.1 (jophish)
16:41:10 <eiffel> geekosaur - NM, I realized I'm using stackage.. I guess I don't want the latest cabal. :P
16:43:05 <mniip> [02:37:56] <arkeet> :t (?x $)
16:43:08 <mniip> what's this
16:43:51 <mniip> haskell extension, ghc plugin, lambdabot plugin?
16:44:10 <glguy> mniip: ?x is syntax from the ImplicitParameters extension
16:44:25 <mniip> ooh
16:48:10 <kaiyin> https://gist.github.com/kindlychung/53b1ab789e1752f412ad  what is wrong with the asInt_fold function?
16:49:01 <mniip> that's now how guards work
16:49:11 <mniip> you have a syntactic error on line 131-132
16:49:33 <shachaf> The syntax is "f x y | ... = ... | ... = ..."
16:49:38 <shachaf> You have an extra "="
16:50:05 <arkeet> pyon
16:50:09 <kaiyin> oh, my bad. 
16:50:35 <eiffel> ...Trying to build scotty. I have base 4.7, but the cabal app config at http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html uses 4.6.* -- the failure message is this: http://pastie.org/10036500
16:51:51 <arkeet> eiffel: you can see if todo builds with base 4.7
16:52:04 <arkeet> see --allow-newer
16:52:50 <eiffel> arkeet tried building with 4.7, other dependancy issues... where do I put --allow-newer? *n00b*
16:53:03 <arkeet> cabal install --help
16:53:09 <eiffel> thx
16:53:29 <arkeet> I guess cabal install --allow-newer=base
16:54:19 <arkeet> or you could modify the cabal file.
16:54:34 <eiffel> looks like it's compiling :D
16:54:38 <arkeet> cool
16:54:47 <dgpratt> I have a desire to plot some data coming over the serial port in real-time
16:54:57 <dgpratt> I thought it could be a fun project to tackle in Haskell
16:55:06 <arkeet> eiffel: the real solution I guess is to relax the upper bounds on your dependencies.
16:55:14 <dgpratt> any pointers to libraries that may be useful for that?
16:56:06 <eiffel> arkeet: tried doing that manually, but couldn't get it to work. Was probably too cude.. I just moved the * up (instead of 4.6.* used 4.*)
16:56:12 <eiffel> *crude
16:57:08 <eiffel> any pointers on how that should be done?
16:58:05 <arkeet> what didn't work about it?
16:58:15 <arkeet> like did it give the same error?
16:58:16 <eiffel> more dependancy issues
16:58:37 <eiffel> different, but same stuff "X.3 depends on Y.9"
16:59:15 <arkeet> what are X and Y?
16:59:31 <eiffel> don't remember.. big chunk of text like: http://pastie.org/10036500#
16:59:34 <arkeet> it might be the other dependencies.
16:59:39 <eiffel> prolly ;)
16:59:45 <arkeet> which is why I am asking.
16:59:55 <eiffel> I'm just not good at cabal hell yet 
16:59:57 <arkeet> btw, if you want to specify base 4.6 or higher, you just write
16:59:59 <arkeet> "base >=4.6"
17:00:11 <eiffel> tried that too... other stuff in the chain fell over
17:00:19 <arkeet> again, other deps.
17:00:20 <arkeet> :p
17:00:21 <eiffel> but this --allow-newer works great
17:00:31 <eiffel> still compiling :D
17:01:02 * hackagebot foldl 1.0.8 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.8 (GabrielGonzalez)
17:01:06 <eiffel> will have to play with it I guess.. all part of the learning process :]
17:02:27 <eiffel> arkeet: arg!! build failed: http://pastie.org/10036523
17:03:09 <kaiyin> > foldr (&&) True (repeat True)
17:03:12 <lambdabot>  mueval-core: Time limit exceeded
17:03:47 <kaiyin> Hijiri: it seems foldr suffers from the same problem sometimes. see above.
17:03:58 <arkeet> eiffel: read the error messages.
17:04:07 <Hijiri> that's because when the first argument of && is True, it needs to check the second argument
17:04:09 <eiffel> cabal libaray?
17:04:37 <Hijiri> I never said it always yields less computations, I said that it can
17:05:02 <Hijiri> and in the case of a lazy accumulating function, it keeps it lazy
17:05:22 <Hijiri> > foldr (&&) True (repeat False -- works like the previous example
17:05:23 <lambdabot>  <hint>:1:65:
17:05:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:05:30 <Hijiri> > foldr (&&) True (repeat False) -- works like the previous example
17:05:31 <lambdabot>  False
17:05:47 <Hijiri> > foldr (||) False (repeat False) -- fails like you noted
17:05:51 <lambdabot>  mueval-core: Time limit exceeded
17:06:17 <Hijiri> the thing is that you could never get a meaningful value in these cases, no matter how you processed the list
17:06:34 <Hijiri> because there is always the possibility that the next value is True (or False, in the case of &&)
17:07:01 <Hijiri> but foldr lets you get an answer before going through the whole list, if the function is lazy enough
17:07:13 <Hijiri> foldl' will always go through the whole list
17:07:45 <Hijiri> use foldr when ending early could give significant benefits, and when you want something to work on infinite lists
17:08:11 <Hijiri> use foldl' when you are guaranteed to need the whole list
17:08:18 <Hijiri> (such as for a sum or product)
17:08:32 <eiffel> arkeet: not finding much on this error... "ghc-pkg list |grep cabal"
17:08:32 <eiffel>  returns nothing. I installed stackage which uses cabal 1.20.
17:09:17 <arkeet> eiffel: 
17:09:19 <Hijiri> in your foldr (&&) True (repeat True) case, neither foldl' or foldr is going to do something useful
17:09:19 <arkeet> it's Cabal, not cabal.
17:09:34 <Hijiri> so that's not a case where you have to choose between foldl' and foldr
17:10:17 <eiffel> arkeet: great point: ghc-pkg list |grep Cabal
17:10:17 <eiffel>     Cabal-1.18.1.5
17:10:32 <arkeet> ok, now compare that
17:10:33 <eiffel> will it break stackage to update cabal?
17:10:35 <arkeet> to the version it's asking for.
17:10:43 <arkeet> I don't know anything about stackage unfortunately.
17:10:57 <arkeet> I haven't had any issues with upgrading Cabal, though.
17:11:34 <eiffel> it's a handpicked set of packages and versions that should work well together. It's FPComplete attempt to resolve cabal hell: http://www.stackage.org/
17:12:11 <eiffel> arkeet: I'll try upgrading. Can't hurt now ;)
17:16:09 <EvanR> can a list with type [forall a . a] have values of different types in it
17:16:54 <EvanR> or is it all the same type, and unknown to you. or is it nonsense
17:18:58 <jle`> that's impredicative types, and it's more or less useless
17:19:11 <pacak> EvanR: data A = forall v. A a ; [A], but there's not much you can do with resulting list other than playing around with it's length
17:19:23 <jle`> what you mentioned is useless. impredicative types is broken, i believe
17:19:38 <EvanR> i see
17:19:44 <arkeet> it's slightly more useful when you put a constraint on the type
17:19:50 <arkeet> like Typeable, say.
17:20:03 <jle`> but yeah, imagine the type signature of `head`, head :: [forall a. a] -> (forall a. a)
17:20:08 <shachaf> At any rate [forall a. a] is very different from [exists a. a]
17:20:25 <jle`> (forall a. a) is only inhabited by bottom
17:20:49 <EvanR> nevermind
17:21:23 <cfoch> hi
17:21:27 <jle`> hi cfoch 
17:21:30 <cfoch> is Prelude a module?
17:21:35 <ReinH> Yes.
17:21:39 <cfoch> jle`: o/
17:22:16 <jle`>  \o
17:28:30 <dgpratt> has anyone here used the plot-ho-matic library before?
17:28:43 <dgpratt> I'm a little confused by the API
17:31:12 <dgorbik> what's the proper way to work with AST-styled aeson? Do I have to constantly do formJSON on the Value whenever I hit Arrays?
17:32:44 <dgorbik> so I end up with something like this: http://lpaste.net/127531
17:33:10 <dgorbik> but I thought that if I go AST way it should all be parsed already and typed accordingly (not just Value, but an Object or Array for example)
17:33:10 <Axman6> @hackage plot-ho-matic
17:33:11 <lambdabot> http://hackage.haskell.org/package/plot-ho-matic
17:33:35 <peddie> dgpratt: a bit, what's up?
17:34:00 <Axman6> wow... excellent docs :\
17:34:01 <dgpratt> peddie, I think I've figured out my immediate confusion, but I'm still looking
17:34:27 <peddie> dgpratt: I encourage you to mail ghorn if you have trouble also :)
17:34:39 <dgpratt> peddie, will do, thanks
17:36:51 <dgpratt> peddie, do you know the difference between addChannel and addHistoryChannel?
17:37:48 <peddie> no, sorry
17:38:00 <dgpratt> peddie, which one did you use?
17:38:18 <peddie> dgpratt: looking at the current docs, I think it's changed API since I used it :(
17:38:24 <dgpratt> ah, ok
17:39:07 <peddie> sorry, thought I was going to be able to help
17:39:25 <dgpratt> no prob, as they say, it's the thought that counts :)
17:40:05 <dmwit> Is there a way to compute how many (fully-defined, but potentially infinite) inhabitants a given data type (constructed from sums, products, and fixed-points, say) has?
17:40:54 <Hijiri> two abstractions are equally powerful <=> each abstraction can be implemented in terms of the other ?
17:41:21 <dmwit> Hijiri: That's an interesting question that isn't so easy to answer.
17:41:42 <dmwit> Since it turns out there's not so many distinct levels of computability.
17:42:48 <dmwit> Certainly one would wish to say that Haskell's polymorphic types are more powerful than C's simpler type language. But both languages are Turing complete, so...
17:44:09 <Hijiri> I guess what "power" is depends on context
17:46:10 <ReinH> And, of course, a Haskell compiler and runtime can be written in C.
17:46:43 <HeladoDeBrownie> partly it's a matter of difficulty - how easily can i reuse these software components?
17:46:45 <mniip> dmwit, we should define cardinality for languages
17:47:10 <hodapp> mniip: good luck with that.
17:47:14 <mniip> 'turing complete' vs 'non-turing complete' is rather bland
17:47:43 <hodapp> not to mention: you can have abstractions in a language that is not Turing complete that are a good deal more powerful than a Turing complete one.
17:48:34 <ReinH> Hey, knowing that a program will terminate is pretty powerful.
17:50:10 <hodapp> Compare, for instance, Coq and Brainfuck.
17:50:45 <HeladoDeBrownie> i think coq versus brainfuck is a good example of how uininteresting the difference between tc and non-tc is.
17:50:51 <HeladoDeBrownie> uninteresting*
17:51:27 <shachaf> If I give you a program and promise that it terminates for every input, what properties of that program are decidable?
17:51:37 <EvanR> how about coq vs malbolge
17:51:44 <EvanR> non-tc ;)
17:52:37 <hodapp> HeladoDeBrownie: The point there is that one's TC and one's not, but Coq for a great many things is far more powerful.
17:53:40 <dmwit> shachaf: fun question; in what logic do you tell me this fact?
17:53:56 <HeladoDeBrownie> hodapp, you haven't said what "powerful" means ;)
17:54:15 <hodapp> HeladoDeBrownie: Neither has anyone else.
17:54:27 <HeladoDeBrownie> hodapp, so that excuses it then? :P
17:54:54 <hodapp> HeladoDeBrownie: If you consider what I said true, then that may shed some light on what 'power' means.
17:55:29 <HeladoDeBrownie> hodapp, not in a way that's obvious to me; as far as i can tell, i can at best guess
17:56:03 * hackagebot linear 1.18.0.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.18.0.1 (EdwardKmett)
17:56:03 <shachaf> dmwit: I don't know. What are some cases where it makes a difference?
17:56:25 <shachaf> How about: I give you a program and I promise you that it represents a computable real number. What properties of it are decidable?
17:56:28 <HeladoDeBrownie> shachaf, is that the same as an assertion that, for some unbounded but finite n, and some program p, p halts after n steps?
17:57:18 <hodapp> HeladoDeBrownie: If it were obvious what 'power' meant then this discussion would be moot, along with most programming language discussions.
17:57:40 <HeladoDeBrownie> hodapp, yeah, that's partly what i was drawing attention to with my original comment on "power"
17:57:44 <HeladoDeBrownie> s/partly/mostly/
17:58:00 <dmwit> dunno! maybe if you give me a computable function from inputs to halting proofs i can show the program is actually compact, hence do "impossible search"-style stuff
17:58:07 <guest2100> hello
17:58:21 <erisco> dmwit yes, https://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
17:58:21 <dmwit> shachaf: (that was for you)
17:58:35 <guest2100> anyone could help me with monad transfomers?
17:58:45 <HeladoDeBrownie> guest2100, probably; go ahead and ask
17:59:00 <HeladoDeBrownie> whoever can help may
17:59:04 <guest2100> ok
17:59:33 <shachaf> dmwit: It was an open-ended question, so things like that are good but I didn't have anything in particular in mind. :-)
18:00:14 <guest2100> if we got something like foo : (MonadWriter Type m, MonadError Type m) => a -> m a -> m a
18:00:19 <Hijiri> power is your ability to assert your will over others
18:00:29 <guest2100> should the second argument be instantiated?
18:00:30 <HeladoDeBrownie> shachaf, it does look like pretty much the relevant question for what tc does and does not give you at least
18:00:31 <Hijiri> therefore the popular languages like java and python must be the most powerful
18:01:00 <HeladoDeBrownie> guest2100, what do you mean instantiated?
18:01:19 <guest2100> The correct `m` instance
18:01:38 <guest2100> for example, ErrorT Type (Writer Type) a
18:01:51 <HeladoDeBrownie> well, whenever you use foo, and appropriate m must be obvious from how it's used, for the most part
18:01:56 <HeladoDeBrownie> s/and/an/
18:02:33 <HeladoDeBrownie> also, ErrorT Type (Writer Type) a is not an appropriate m since it's the wrong kind
18:02:37 <guest2100> yeah, but I'm talking when i'm defining foo
18:02:41 <dmwit> erisco: that discusses counting inhabitants, and discusses recursive types, but does not discuss counting inhabitants of recursive types (which is the hard part in the furst place)
18:03:03 <HeladoDeBrownie> guest2100, ah, well in that case you cannot use the properties of any specific m, only what the context and the rest of the type tell you.
18:03:23 <HeladoDeBrownie> guest2100, so, you can use appropriate MonadWriter and MonadError methods, and pass it around, but nothing else.
18:04:23 <guest2100> thanks
18:04:38 <guest2100> so
18:05:04 <erisco> dmwit I am not sure what you mean by counting inhabitants of recursive types, you obviously are not looking for a finite number
18:05:27 <dmwit> not obvious to me
18:05:50 <Hijiri> maybe cardinality of the set of inhabitants?
18:06:27 <guest2100> for example, if I have foo ::(MonadState State m, MonadError Type m) -> m a -> m a
18:06:30 <dmwit> could be finite; though i agree it often won't be
18:06:50 <HeladoDeBrownie> guest2100, i'm guessing you meant that first arrow to be =>?
18:06:59 <guest2100> yes
18:07:03 <HeladoDeBrownie> okay. go on
18:07:51 <guest2100> the first `m` needs to be "instantiaed" in order to use, for example runStateT
18:08:01 <guest2100> over thatargument
18:08:19 <HeladoDeBrownie> not just the first; all the variables of the same name in a type must be the same thing.
18:08:43 <dmwit> data X = X X; then: "X has one inhab. because it must use X constructor, then continue as an inhab. of X"; but this assumes there is just one inhab. while trying to show there is just one inhab.
18:09:05 <guest2100> mmm I don't think so
18:09:09 <HeladoDeBrownie> but sure, runStateT is a good way to fix some type at StateT
18:09:28 <HeladoDeBrownie> what makes you think otherwise?
18:10:10 <mniip> dmwit, X is only inhabited by bottoms
18:10:24 <mniip> it's little brother Void, on the other hand, is truly uninhabited
18:10:30 <dmwit> mniip: no, fix X is not bottom
18:10:37 <guest2100> the fact is I want to use runStateT over the first argument
18:11:08 <mniip> dmwit, you get ⊥, (X ⊥), (X (X ⊥)), ...
18:11:16 <mniip> whereas for Void there's only ⊥
18:11:22 <HeladoDeBrownie> guest2100, okay, that's doable, depending.
18:11:27 <mniip> wait
18:11:33 <mniip> does Void even have ⊥?
18:12:05 <Hijiri> > undefined :: Void
18:12:06 <Axman6> ⊥ inhabits all types no?
18:12:07 <lambdabot>  Not in scope: type constructor or class ‘Void’
18:12:23 <dmwit> mniip: no,`fix X` has no bottoms anywhere
18:12:27 <Hijiri> > undefined :: Data.Void.Void
18:12:29 <lambdabot>  Not in scope: type constructor or class ‘Data.Void.Void’
18:12:29 <lambdabot>  Perhaps you meant ‘Data.Word.Word’ (imported from Data.Word)
18:12:30 <HeladoDeBrownie> guest2100, although, be careful; runStateT results in whatever monad StateT is wrapped around. it sounds like you might be confused about that
18:12:37 <HeladoDeBrownie> @type runStateT
18:12:38 <lambdabot> StateT s m a -> s -> m (a, s)
18:12:45 <guest2100> again, foo ::(MonadState State m, MonadError Type m) -> m a -> m a... If I want to apply runStateT over the first `m a` the compiler will reject
18:12:54 <dmwit> mniip it is the lub of your suggested chain, but not in the chain
18:12:55 <guest2100> yeah
18:13:06 <guest2100> i'm not explaining well i geuess
18:13:41 <mniip> dmwit, 'fix X' eh
18:13:53 <mniip> well yes
18:13:55 <HeladoDeBrownie> a perfectly reasonable type for m in foo, for example, is StateT State (ExceptT Type Identity)
18:13:56 <mniip> it is a value of X
18:14:00 <guest2100> The thing is that in order to apply runStateT over the first argument, the type must be instantiated, that is, to have the correct order  of transfomrers applied
18:14:01 <mniip> with no bottoms
18:14:45 <guest2100> Yes, so to define foo (allowing me to use runStateT over the first arg)
18:14:54 <guest2100> again, foo ::(MonadState State m, MonadError Type m) -> StateT State (ExceptT Type Identity)  a -> m a
18:14:59 <HeladoDeBrownie> i think what you want to use runStateT over is the *result* of foo, from what it sounds.
18:15:16 <guest2100> nope, over the first monad that is given as an argument
18:15:24 <HeladoDeBrownie> why?
18:15:31 <guest2100> foo ::(MonadState State m, MonadError Type m) => StateT State (ExceptT Type Identity) a -> m a
18:15:34 <HeladoDeBrownie> you'd still have to satisfy the MonadState constraint, note
18:15:47 <HeladoDeBrownie> if you're going to replace one m in the type, you'd better replace them all
18:16:19 <HeladoDeBrownie> so for example, the input and output will *always* have the same type
18:17:02 <guest2100> with this definition? foo ::(MonadState State m, MonadError Type m) => StateT State (ExceptT Type Identity) a -> m a
18:17:05 <HeladoDeBrownie> also i think you might be better off showing code and mentioning whatever the problem/error is with it, since it sounds like you have something rather specific in mind.
18:17:23 <HeladoDeBrownie> so, you're saying now that foo should have a different type altogether?
18:17:36 <guest2100> m may vary
18:17:56 <HeladoDeBrownie> just so we're clear, that type for foo is not a valid instantiation of the foo you gave earlier. is that intentional?
18:19:10 <HeladoDeBrownie> also, unless you have more than one layer of StateT, the *result* of runStateT is not going to have a StateT type
18:19:26 <HeladoDeBrownie> that's why i was thinking you wanted to use it on the output of foo instead
18:26:03 * hackagebot openssl-streams 1.2.1.0 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.2.1.0 (GregoryCollins)
18:28:38 <nisstyre> if I want to apply to GSoC for Haskell, then do I have to come up with my *own* project idea or am I allowed to propose working on some feature another person requested? It's not really clear and I've never done GSoC before.
18:29:52 <Axman6> I believe that's ok, it's often used as a means to get features that lots of people want in a project but none of the usual developers have had time to work on
18:30:01 <nisstyre> ah okay cool
18:30:08 <nisstyre> so I just have to find one I'm interested in doing
18:30:11 <Axman6> you may want to try asking in #haskell-infrastructure too
18:30:42 <nisstyre> I'm kind of attracted to the lower level stuff but not sure if that changes often (i.e. the RTS)
18:31:56 <dmwit> The RTS changes sometimes, but usually that's the result of a pretty large-scale effort -- and is accompanied by a research paper.
18:32:04 <nisstyre> yeah :p
18:32:30 <mniip> rewrite the rts in haskell so that it uses the features of itself via lazy evaluation xD
18:33:31 <guest2100> http://lpaste.net/127537
18:34:05 <HeladoDeBrownie> guest2100, okay, so in terms of that, what's the question?
18:34:50 <guest2100> what I meant is we can't apply runStateT to something of type `m a` if we don't know the correct instance of it
18:35:18 <guest2100> in that case is StateT Int Id
18:36:00 <guest2100> if we have a generic m, we don't know how is it composed (how's the order of the monad transfomer stack)
18:36:03 * hackagebot hermit 0.7.1.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.7.1.0 (AndrewFarmer)
18:36:33 <HeladoDeBrownie> yeah, if m hasn't been determined enough to pick an instance then it needs to be specified further
18:36:40 <HeladoDeBrownie> but it looks like you have there
18:37:10 <guest2100> yes, my problem was if I have an m as an argument
18:37:26 <HeladoDeBrownie> okay. show what you tried with that
18:37:26 <dmwit> :t stateT
18:37:27 <lambdabot>     Not in scope: ‘stateT’
18:37:27 <lambdabot>     Perhaps you meant ‘state’ (imported from Control.Monad.State)
18:37:31 <dmwit> :t state
18:37:32 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:37:33 <HeladoDeBrownie> include any error message you may have got
18:38:18 <dmwit> guest2100: get and put are often enough to deal with the state without monomorphing your thing.
18:38:28 <dmwit> guest2100: Sometimes state is more convenient.
18:40:42 <guest2100> ok
18:41:54 <osa1> how hard would it be to use gloss with gtk? I guess we need a cairo backend for gloss for this, right?
18:43:32 <guest2100> foo :: (MonadState State m, MonadError String m) => m a -> m a
18:43:51 <guest2100> Let's suposse I want to apply runStateT over the first 'm a'
18:44:09 <dmwit> 1. Don't 2. Make your type (blah blah blah) => a -> m a
18:44:31 <Cale> Well, there are legitimate reasons to have things of the form m a -> m a
18:44:32 <dmwit> And then use (>>=).
18:44:43 <dmwit> Yes. I'm making an educated guess here.
18:45:15 <guest2100> why can't we have something like I that?
18:45:16 <Cale> Like, with that type signature, perhaps foo is something which brackets an operation with a change to the state and its inverse
18:45:50 <jle`> guest2100: when you have osmething like blah => a, it means that the function caller can chose `a`
18:45:57 <jle`> it's polymorphic over all a
18:46:01 <guest2100> yeah
18:46:11 <jle`> so, you can't apply runStateT over the first `m a`
18:46:18 <jle`> because the caller can decide to pick an `m` that isn't StateT
18:46:26 <dmwit> Okay. I admit it, we should ask this first before giving advice: what do you want `foo` to do?
18:46:27 <guest2100> that's what I wanted to know
18:46:52 <Cale> guest2100: It's weird that you *want* to use runStateT inside foo
18:46:55 <guest2100> so, in order to correctly use runStateT inside foo's definition
18:47:18 <jle`> it's proably possible to implement what you want to do polymorphically
18:47:26 <Cale> guest2100: because it's producing a stateful computation, you can just execute the action that got passed in as part of the action that you produce
18:47:31 <jle`> so that you don't need runStateT, you can use polymorphic functions
18:48:04 <jle`> there is probably a way you can do what you want, using only the methods in MonadState
18:48:08 <jle`> (and MonadError)
18:48:14 <jle`> (well, we can't know, until you tell us :) )
18:48:15 <dmwit> None of us knows what he wants yet...
18:48:21 <octatoan> hey
18:49:07 <octatoan> Is there some sort of errata doc for RWH?
18:49:17 <guest2100> I just wanted to know if I have to instantiate the first m in order to use runStateT
18:49:27 <guest2100> in that case
18:49:56 <bob_twinkles> octatoan: the comments usually mention any bitrot
18:50:20 <dmwit> guest2100: But what do you want to do?
18:50:38 <guest2100> just know that
18:50:42 <dmwit> guest2100: "use runStateT" is an implementation of something you want to do, not a thing you want to do
18:51:19 <Cale> guest2100: What is your program computing?
18:51:55 <guest2100> foo :: (MonadState State m, MonadError String m) => m a -> m a; foo c = do (a,s) <- runStateT c;return something
18:52:32 <Cale> guest2100: No, I mean, what is it that you intend for foo to compute
18:52:36 <Cale> In English
18:52:37 <guest2100> I just wanted to know if using a geneeric m that will be possible
18:52:53 <Cale> Well, no, but also you probably should never do that anyway
18:53:02 <dmwit> foo c = do { a <- c; s <- get; return something }
18:53:24 <guest2100> thanks
18:59:49 <lpsmith> Hmm,  there are two broad categories of generating error messages:   1.  stop generating error messages at the first mistake you find,  or 2.  try to continue processing past the error in order to generate more error messages.
19:00:18 <lpsmith> Are there nice convenient names for those two categories of error message generation?
19:00:45 <dmwit> TeX calls them interactive and batch mode.
19:02:50 <lpsmith> dmwit, thank you.   Unfortunately, that doesn't seem to fit my application :-/
19:04:02 <lpsmith> I'm working on a library for configuration file processing,  and two combinators "withInteractive" and "withBatch" seems a little obscure. =)
19:05:05 <lpsmith> I kind of like "withSerial"  for stopping error messages on the first mistake
19:06:04 <peddie> lpsmith: have you seen the validation package?
19:06:06 <mniip> withErrorRecovery?
19:07:01 <lpsmith> peddie, maybe?   I'm pretty sure I looked at everything on Hackage,  and decided to fork configurator instead.
19:07:26 <crobbins_> lpsmith: what are you looking for?
19:07:32 <peddie> ok, just the "keep going and gather more errors" rang a bell, since that's exactly what it does
19:07:45 <peddie> just tossing it out in case it helps :)
19:08:05 <lpsmith> crobbins_, I actually really like my fork of configurator,  it's really nice so far,  but it's not release-ready yet.
19:08:17 <dmwit> I'm not necessarily sold on "interactive". But "batch" seems like a pretty good name for "process the whole thing, please".
19:08:34 <Slothrop> night shift blows
19:08:36 <Slothrop> rescue me
19:09:07 <dmwit> Please keep the conversation on-topic or clean.
19:09:37 <lpsmith> "withSerial" and "withBatch" might work.
19:09:45 <dmwit> In fact, let's keep it on-topic and clean.
19:10:58 <lpsmith> Alternatively,  I'm calling my configuration processor computations  ConfigurationParserM and ConfigurationParserA,  the first stops at the first error,  the second generates more error messages but doesn't have a legitimate Monad instance.
19:11:07 <Slothrop> dmwit: I suspected that was a strange rule for a channel. But heard loud and clear, no more OOT
19:11:43 <lpsmith> so maybe withParserM  and withParserA  would also work,  to convert between the two.
19:12:05 <lpsmith> actually, ConfigParserM and ConfigParserA
19:14:23 <lpsmith> peddie, thanks for pointing out validation;   no I hadn't seen it.
19:17:31 <Big_G> Does Haskell require you to handle all possible values for a given value?
19:17:55 <dmwit> No. But it can warn you if you don't.
19:18:17 <bob_twinkles> and if the pattern sees something it can't handle at runtime it'll blow up
19:18:18 <pacak> :t const
19:18:20 <lambdabot> a -> b -> a
19:18:31 <pacak> Big_G: not really
19:18:41 <Big_G> dmwit, Will it always warn?
19:18:50 <Big_G> pacak, Is there a way to get that behavior?
19:18:55 <dmwit> You must ask it to warn with -fwarn-incomplete-patterns.
19:18:56 <kaidelong> no, it won't even warn you by default
19:19:07 <dmwit> here "it" is "GHC"
19:19:41 <kaidelong> not handling an unexpected pattern does end up giving you a GHC generated error message explaining the pattern match failure and where it happened
19:19:52 <pacak> Big_G: That depends on what you are trying to achieve. -Wall and typelevel magic usually helps
19:20:05 <dmwit> There are a few cases with GADTs where the exhaustiveness check is not quite right. I don't recall what behavior it has in that case, but you have to try pretty hard to hit it.
19:20:09 <kaidelong> GHC exceptions don't carry debugging information and I'm not sure if there's any way to recover that
19:20:19 <Big_G> So there is a way to do that but I have to have the right flags?
19:20:27 <lpsmith> Big_G, the const pacak issue is a little different,   but I do strongly recommend  -fwarn-unused-variables
19:20:35 <kaidelong> so it may be best just not to match the pattern rather than make a handler that throws an error
19:20:35 <dmwit> Big_G: What is "that"?
19:20:41 <shachaf> It's a bit of an interesting question what the right exhaustiveness check is for GADTs.
19:20:56 <lpsmith> err,  the const issue pacak brought up*
19:21:00 <shachaf> How would you express it if you didn't have type equality built into the language?
19:21:01 <Big_G> dmwit, Ensure that every case for a given input value is handeled 
19:21:04 * hackagebot kdt 0.2.3 - Fast and flexible k-d trees for various types of point queries.  http://hackage.haskell.org/package/kdt-0.2.3 (giogadi)
19:21:08 <shachaf> E.g. if you were using Leibniz equality.
19:22:10 <dmwit> Big_G: yes
19:22:58 <Big_G> dmwit, Any other flags like that which might be useful?
19:23:15 <dmwit> Many. The GHC documentation has a flag reference.
19:24:11 <Big_G> Are there any compilers that are actually used for Haskell beyond GHC?
19:24:41 <erisco> who cares about dependency graphs when you have circular programming
19:25:09 <ttt_fff> i'm wirting a haskell app with threepenny (browser as GUI). I have an element that I can press a button to hide/show it. I'm trying to decide on "toggleable, expandable, or collapsable, or hideable" ... but I can't think of a good name; is there a good name for things that you can toggle to hide/show ?
19:25:19 <dmwit> I believe there are several specialized compilers (e.g. for hardware, Javascript, and some in-house needs) that are used.
19:25:20 <ttt_fff> maybe I shoudl name it peek-a-boo
19:25:56 <erisco> ttt_fff forums call these "spoilers"
19:26:41 <ttt_fff> erisco: interesting name
19:26:43 <erisco> out of the initial need to hide pop culture spoilers from gazing eyes
19:26:58 <ttt_fff> i don't like it
19:28:02 <becquerel> I remember reading somewhere that GHC doesn't represent values of type "Maybe a" as a tagged union; it just stores them as a nullable pointer to "a"
19:28:17 <becquerel> why is it impossible to {-# UNPACK #-} them, then?
19:28:30 <dmwit> I don't think that's accurate.
19:28:44 <shachaf> becquerel: No, that's not true.
19:28:56 <dmwit> It doesn't store them as a tagged union, but it doesn't store them as a nullable pointer, either.
19:29:01 <shachaf> Maybe you're thinking of Rust or some other language. I don't know of a Haskell implementation that does it.
19:29:12 <shachaf> dmwit: It doesn't store them as a tagged union?
19:29:20 <shachaf> Well, I guess that depends on what you mean by "tagged union".
19:29:31 <dmwit> Yeah, I wouldn't call a code pointer a tagged union.
19:29:38 <dmwit> Unless you're big on Church encodings or something. =P
19:29:55 <becquerel> a code pointer?
19:30:18 <osa1> is there a way to install gloss without glut? I'm trying -fGLFW but it's still looking for glut
19:30:40 <dmwit> Yes. It is, to a first approximation, a pointer to some code which answers the "are you a Nothing or are you a Just" question.
19:31:00 <dmwit> If the thing is unevaluated, that code pointer does a lot of work. Otherwise not.
19:31:00 <shachaf> Well, once it's forced, it'll probably be passed around as a tagged pointer, which stores the constructor in its lowest bits.
19:31:25 <shachaf> Or the tag might otherwise be stored in a way that doesn't require an indirect jump.
19:31:54 <shachaf> Code pointers can be a problem even when they don't do a lot of work. :-)
19:32:01 <shachaf> @where ptr-tag
19:32:01 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
19:33:33 <becquerel> ok, maybe Maybe is more complex than I thought
19:34:40 <shachaf> Maybe is pretty simple as algebraic data types go.
19:35:08 <shachaf> I think GHC could potentially get a lot of benefit from unboxed sums, and an equivalent of CPR for sums/sums of products.
19:35:26 <shachaf> I've talked about this before, though.
19:35:42 <shachaf> One of these days I should try it, or talk to SPJ about it, or something.
19:36:57 <becquerel> Isn't it a bit silly that we can't UNPACK Bool?
19:37:40 <shachaf> It is.
19:37:54 <shachaf> Unboxed enums are an important special case of unboxed sums that would be especially good to have.
19:38:07 <shachaf> Instead, GHC uses a nasty hack with Int#. :-(
19:38:35 <shachaf> That's how people do things these days.
19:38:46 <shachaf> The Int# thing is only a few years old.
19:43:25 <ttt_fff> if I want to have thousands of haskell 'micro threads' (most of which are just stalling), what is the cheapest way to do so?
19:43:47 <ttt_fff> well, more like millions of 'micro threads'
19:44:05 <ttt_fff> so I have a bunch of weird gui elements .... which are just like "most of the time, do nothing .... but if you get this event, perform this sequence of moves"
19:44:15 <ttt_fff> so most of the times, these micro threads s just waiting along doing nothing
19:46:17 <bob_twinkles> you might be better off with some sort of pub/sub system instead
19:46:36 <bob_twinkles> thousands or millions of threads is likely not practical =P
19:47:41 <ttt_fff> doesn't ahskell have some type of lightweight threads?
19:47:45 <ttt_fff> I don't need full OS threads
19:47:59 <ttt_fff> I feel like there's gotta be some monads which is like "dude, I'm really a state machine; I just compile monads down to state machines"
19:48:26 <becquerel> forkIO is your friend
19:48:28 <ttt_fff> millions of DFAs (deterministic finite autonatons) are definitely feasible
19:48:35 <peddie> ttt_fff: there's no problem with running thousands of Haskell threads
19:48:55 <becquerel> but how are you getting millions of ui elements?
19:48:58 <peddie> they're much, much less expensive than OS threads
19:48:59 <ttt_fff> Concurrency is "lightweight", which means that both thread creation and context switching overheads are extremely low. Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages. <-- I like
19:49:29 <ttt_fff> becquerel: it's the output of an intercative theorem prover, with lots of clickable terms
19:49:34 <ttt_fff> becquerel: and I'm upperbounding
19:50:03 <carter> ttt_fff: ... should a gui have 1million things?
19:50:19 <ttt_fff> carter: one gui element per pixel
19:50:33 <carter> ttt_fff:..... why
19:50:35 <carter> i mean
19:50:37 <carter> you can do it
19:51:10 <platz> 'fromJson' returns a 'Result a', which can be an Error String or Success a.  if I'm using fromJson on a stream, does pattern matching on the Result force the whole stream to buffer completely first in order to parse regardless of further lazy consumption? 
19:51:13 <ttt_fff> ask not y ask y not
19:51:27 <pacak> carter: Probably those things in GUI are usually called pixels...
19:51:39 <platz> https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html#v:fromJSON
19:53:52 <platz> in other words, is it possible to consume the results of a json parser in constant space
19:54:22 <RageD> so i've coded myself into a box and am not sure how to get out. i want to run an operation inside of a monad. however, at this point i am already inside of the IO monad. Is there a way I can do this? Or is it best to refactor and keep IO at the inner-most level?
19:55:03 <carter> RageD: which monad
19:55:43 <RageD> Snap framework's Handler
19:55:49 <RageD> https://hackage.haskell.org/package/snap-0.6.0.2/docs/Snap-Snaplet.html#t:Handler
19:56:45 <enthropy> there is no IOT
19:57:35 <RageD> enthropy: I know :( 
19:57:46 <carter> RageD: use MonadIO
19:59:15 <RageD> carter: I'm going the other way, unfortunately
19:59:20 <carter> why
19:59:26 <carter> runFoo
19:59:29 <carter> is the other option
20:00:40 <RageD> carter: mostly bad decisions in hindsight :) short-sighted incremental changes which turned my code into a bit of a mess
20:00:55 <carter> thank the type checker and  refactor
20:01:15 <RageD> that's what i'll end up doing
20:01:16 <dfeuer> HI CARTER.
20:01:19 <carter> dfeuer: SUP
20:01:23 <carter> things going well?
20:01:35 <dfeuer> carter, don't talk to me about job stuff today; I've been distracted by things like MY NEW NEPHEW.
20:01:37 <dfeuer> But.
20:01:42 <carter> CONGRATS
20:01:44 <carter> oh?
20:01:54 <carter> how cute is the new baby?
20:02:08 <dfeuer> Very.
20:02:17 <dfeuer> Duh.
20:02:24 <carter> but?
20:02:32 <dfeuer> No buts :-)
20:02:39 <dfeuer> oh, that but
20:02:40 <dfeuer> Wel,
20:02:58 <shachaf> This is a reasonable topic but not for #haskell.
20:03:08 <dfeuer> I was wondering if you knew about good implementations of median-of-medians in Haskell.
20:03:57 <carter> hrmm
20:04:01 <carter> random or not random??
20:04:28 <dfeuer> I was actually thinking about not-random, because random needs IO :-/
20:04:52 <dfeuer> Did you see my email to haskell-cafe?
20:05:20 <carter> not yet
20:05:57 <dfeuer> Ohhhh, well, I had an idea, but if it's possible to make it a good idea, it needs to be very very smart about its selection.
20:06:17 <carter> dfeuer: i have a better idea
20:06:19 <dfeuer> I would very much like to have randomness for that.
20:06:21 <carter> how about approximate heaps
20:06:34 <dfeuer> Eggs-plain?
20:06:39 <carter> http://www.cs.princeton.edu/~chazelle/pubs/sheap.pdf
20:07:34 <carter> and citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.215.6250
20:07:44 <carter> its a super fast data structure for nearly sorting data
20:07:53 <carter> http://www.siam.org/proceedings/soda/2009/SODA09_053_kaplanh.pdf
20:08:00 <dfeuer> Why do you think that would be appropriate here?
20:08:00 <carter> the latter 2 links are for a simpler version of the alg
20:08:29 <dfeuer> The last link is broken.
20:09:01 <carter> http://delivery.acm.org/10.1145/1500000/1496823/p477-kaplan.pdf?ip=74.73.131.194&id=1496823&acc=ACTIVE%20SERVICE&key=4D4702B0C3E38B35.4D4702B0C3E38B35.3E1EB863F32E85BF.4D4702B0C3E38B35&CFID=490961904&CFTOKEN=28467643&__acm__=1426734727_06a8aa72e807f2c0867d8cdb81657c1c
20:09:02 <carter> try that
20:09:05 <carter> if not i can email you
20:09:09 <carter> the first linke should work too
20:09:19 <dfeuer> Nope no good.
20:09:51 <dfeuer> But the citeseer one works.
20:10:11 <carter> yes, but the pdf links from there dont owrk
20:10:14 <dfeuer> But carter, how will that help me?
20:10:23 <carter> i'll email you
20:10:27 <dfeuer> Ah, but they do! They just don't work on Android, and maybe on Mac.
20:10:37 <dfeuer> They work fine on my lappentopper.
20:10:48 <dfeuer> And no, I don't know why.
20:11:40 <carter> well, i'm emailing you anyways
20:11:50 <dfeuer> OK :)
20:12:20 <dfeuer> But you still haven't explained how that helps me accomplish my goal.
20:12:43 <carter> ok
20:13:03 <carter> dfeuer:  you want to nearly sort things in nearly linear time
20:13:15 <dfeuer> I do?
20:13:27 <carter> or maybe i need to read your emails agian
20:14:51 <dfeuer> I need to completely sort things in linearithmic time, but be as lazy as I can about it. So I should be able to get to elements at the very ends in linear time, and I shouldn't have to completely sort the ends before accessing things in the middle, etc.
20:15:02 <dfeuer> Well, that's the idea.
20:15:04 <dfeuer> BUT
20:15:25 <dfeuer> I don't know if I'll be able to get good enough constant factors for that to be of any practical value.
20:16:02 <carter> lets hrm
20:16:11 <dfeuer> I'm especially worried about violations of the generational hypothesis and cache behavior.
20:16:23 <carter> lets consider sorting with up to log(n) error
20:17:01 <carter> like in a squence with n slots, things might be in a position log(n) away from the correct spot in the order
20:17:13 <dfeuer> Because at least a naive median-of-medians builds a big list and then traverses it to partition, which sounds pretty bad.
20:17:15 <carter> so in practice, they're within 100 spots of the correct order
20:17:15 <rola> :t liftM5
20:17:17 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
20:17:29 <rola> do the lifts go up to 11
20:17:32 <rola> :t liftM11
20:17:33 <lambdabot>     Not in scope: ‘liftM11’
20:17:33 <lambdabot>     Perhaps you meant one of these:
20:17:33 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
20:17:44 <dfeuer> OK, carter, I will listen because I will probably learn something, whether relevant or no.
20:17:50 <glguy> rola: No. Do you know how to figure out if they do?
20:18:16 <carter> dfeuer: how much work does it take to sort a constant size interval?
20:18:52 <dfeuer> carter, it takes a constant amount of time.
20:18:56 <carter> true
20:19:13 <carter> now what happens if you  recursively "nearly sort", and then merge things?
20:19:33 <dfeuer> I'm not sure what you mean by that.
20:19:53 <carter> like, consider a merge sort that ... uses a "nearly sort" as a primitive
20:19:59 <carter> and then does a cleanup pass?
20:20:52 <dfeuer> A cleanup pass by ... sorting again?
20:21:13 <carter> sorting and merging
20:21:34 <dfeuer> A merge sort  splits, sorts each, then merges.
20:21:39 <dfeuer> What are you proposing?
20:22:06 <carter> like, what if we use this \epsilon  approximate sorting, every operation takes O(1) amortized, and inserts are O(1/\epsilon)
20:22:22 <carter> err
20:22:27 <carter> log (1/\epsilon)
20:23:01 <carter> so if we're OK with 1/log n error,
20:23:07 <carter> the inserts will be log log n work
20:23:16 <carter> so we could get n log log n complexity to nearly sort it
20:23:26 <dfeuer> Once you get to exactly sorted, you will be at n log n.
20:23:40 <carter> then we just need to do a rolling 2 * log n width window
20:23:41 <carter> fff
20:23:43 <carter> youre right
20:23:48 <carter> wait
20:23:53 <carter> not if we use bucket sort in that window
20:23:58 <dfeuer> Can't.
20:24:01 <carter> BO
20:24:10 <dfeuer> Well,
20:24:24 <dfeuer> could  do a lot of things, but I'm currently trying to assume (Ord a) =>
20:24:27 <carter> dfeuer: could we use edwardk's discrimination thing?
20:24:36 <dfeuer> I don't know what that is.
20:24:39 <carter> he says it allows linear time sorting
20:24:51 <carter> github.com/ekmett/discriminiation
20:24:53 <edwardk> dfeuer: linear time sorting, grouping and partitioning for almost everything
20:24:59 <carter> https://github.com/ekmett/discrimination
20:25:20 <dfeuer> edwardk, some horrifying type magic to find out you have exploitable structure?
20:25:49 <edwardk> dfeuer: uses a radix/american flag sort style trick to make it work
20:25:59 <edwardk> and generalizes it to polynomial ADTs
20:26:31 <dfeuer> I've never heard of an American flag sort; is that different from a radix sort?
20:27:07 <edwardk> newtype Disc a = Disc { (%) :: forall b. [(a,b)] -> [[b]] } -- is the workhorse. its responsible for partitioning things up into their respective equivalence classes by whatever properties of 'a' you want to discriminate on
20:27:24 <edwardk> its classically a non-stable radix sort variant that can be performed in place
20:28:10 <dfeuer> Interesting, that is. And I will look into whether it plays well with the Data.Sequence playground I've been having so much fun in. But I still don't know how it's going to help me if I want to deal with Ord :-/
20:28:15 <edwardk> was key to showing that radix sort can beat quicksort on a wallclock way back in the day.
20:28:27 <edwardk> before then radix sort had been relegated to a historical curiosity
20:28:36 <edwardk> dfeuer: its not
20:28:40 <edwardk> you need a special class for it
20:29:04 <edwardk> http://ekmett.github.io/discrimination/Data-Discrimination-Combinators.html
20:29:17 <edwardk> see "Sorting" and "Grouping" mentioned there
20:29:20 <dfeuer> So I figured.
20:30:03 <dfeuer> edwardk, did you see my haskell-cafe message? I had an idea based on median-of-medians for incremental sorting with Ord....
20:30:16 <dfeuer> Incremental sorting of sequences, that is.
20:30:46 <dfeuer> But I went looking for optimized median-of-medians implementations in Haskell, and found none.
20:31:03 <edwardk> mostly because folks have moved on to timsort like things from MoM
20:32:17 <dfeuer> The Wikipedia description of Timsort looks a lot like what I've read of GHC's mergesort.
20:32:33 <c_wraith> timsort has a ton of extra special cases
20:32:41 <c_wraith> but the core idea is similar
20:33:03 <bob_twinkles> b/ 5
20:33:28 <edwardk> there is a working timsort in vector-algorithms
20:33:29 <nuser> :t dfeuer 
20:33:30 <lambdabot> Not in scope: ‘dfeuer’
20:33:54 <nuser> oops
20:34:03 <dfeuer> edwardk, it looks utterly ad-hoc.
20:34:24 <edwardk> it does a bunch of things that fix the worse places where quicksort breaks down
20:34:48 <reem> isn't timsort a modification of mergesort, not quicksort?
20:34:53 <c_wraith> yes
20:35:05 <edwardk> yes
20:35:49 <dfeuer> I still think this selection-based method will be fun :-P
20:36:07 <carter> edwardk: .... when did timsort get into vector-algorithms?
20:36:20 <edwardk> carter: while back
20:36:26 <edwardk> maybe a year or  so?
20:36:30 <dfeuer> Mergesort doesn't break down, of course. It just doesn't break up either.
20:36:37 <carter> edwardk: ... which modules?
20:36:48 <carter> https://hackage.haskell.org/package/vector-algorithms ..
20:37:10 <edwardk> http://hub.darcs.net/dolio/vector-algorithms/browse/src/Data/Vector/Algorithms/Tim.hs
20:37:20 <edwardk> guess its not released
20:37:49 <edwardk> ok, well, dolio has been talking to me about the timsort impl in vector-algorithms for so long i assumed he'd shipped it ;)
20:38:04 <dfeuer> What behaves best in special cases will behave mediocrely in less special cases.
20:38:37 <c_wraith> that's why timsort has so many special cases. :)
20:38:50 <c_wraith> everything is a special case!
20:39:01 <dfeuer> Which take extra branches, and thus slow everything down?
20:39:21 <dolio> I didn't implement it. Someone else did, and sent me patches two or three weeks ago.
20:39:27 <carter> dolio: oh sweet
20:39:40 <dolio> I haven't gotten to releasing it yet.
20:39:40 <carter> dolio: .... do you have a criterion suite yet/
20:39:41 <carter> ?
20:39:50 <dolio> No, not yet.
20:39:53 <dfeuer> And a QuickCheck one?
20:39:59 <carter> dolio: i'll start surfacing on vectory stuff Real Soon now ™
20:40:04 <carter> lifes been crazy
20:40:11 <edwardk> dfeuer: timsort replaced the standard java sort because it "just won" on pretty much everything.
20:40:18 <dfeuer> Life could be a dream; life could be a dream.
20:40:46 <dolio> Timsort doesn't have special cases, exactly. It just behaves well on lots of special cases.
20:41:01 <c_wraith> dolio: did you check that timsort to see if it has the bug that crashes on specially-constructed inputs with more than 2^48 elements?
20:41:07 <dfeuer> edwardk, interesting. For arrays, I gather? I'm still deeply skeptical about anything that tries so hard to be good at X, Y, and Z.
20:41:23 <dolio> c_wraith: The guy that sent it fixed it almost immediately after that problem got published.
20:41:30 <c_wraith> dolio: good to know
20:41:33 <dolio> c_wraith: But it would never crash. Just be suboptimal.
20:41:48 <dfeuer> Suboptimal, or wrong?
20:42:04 <edwardk> dfeuer: the java version? wrong, the haskell one? suboptimal
20:42:06 <dolio> The crashes are caused by Java and Python implementations using a stack with a fixed max size.
20:42:24 <dfeuer> Ew.
20:42:36 <dolio> And the logic error causes you to use more than the pre-calculated maximum amount of needed stack.
20:42:40 * dfeuer cares much more about being wrong than crashing.
20:42:58 <edwardk> dfeuer: rather the java version would crash rather than yield an answer
20:43:07 <dfeuer> Except in safety-critical matters, of course.
20:43:33 <dolio> I don't really understand why they do that in Java/Python.
20:43:46 <dfeuer> [It doesn't matter if the antilock brake system crashes or is wrong; either way you're dead.]
20:43:55 <edwardk> dfeuer: http://envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/ <- is the problem in question
20:44:07 <dolio> In Haskell it's obvious to use a list for a stack of chunk boundaries, and you'll never do memory unsafe things that way.
20:44:23 <edwardk> and the fixed version has since been proven correct supposedly
20:44:41 <dolio> You just might have more than O(log n) chunks.
20:45:18 <dfeuer> In Haskell, carter is doing memory unsafe things all the time. And I've played with them a couple times myself.
20:45:34 <carter> dfeuer: nothing i do is unsafe
20:45:46 <carter> or at least, i fix the unsafe bits
20:45:51 <dolio> You aren't reading closely enough. :)
20:46:04 <carter> hrmm
20:46:05 * hackagebot relational-schemas 0.1.0.2 - RDBMSs' schema templates for relational-query  http://hackage.haskell.org/package/relational-schemas-0.1.0.2 (yuga)
20:46:09 <turtil> /buff/buffer close
20:46:14 <carter> ok, lemme clarify: that sparse sutff i worked out is memory safe
20:46:16 <dolio> Lists aren't memory unsafe.
20:46:22 <carter> dense array apis are memory unsafe
20:46:22 <dolio> In Haskell.
20:46:45 <carter> nah, everywhere :)
20:47:18 <dfeuer> And I forgot that edwardk does batshit unsafe stuff like that reflection package or whatever it's called.
20:47:22 <edwardk> the reason that the java/python things _crashed_ was because they were using fixed sized arrays they believed were big enough but had failed to properly establish the invariant. the haskell version uses a list, nothing unsafe happens, you just got a longer list than expected.
20:47:45 <edwardk> i roll a die each day, it tells me what level of type safety I want to assume ;)
20:47:58 <carter> what happens when you roll a 1
20:48:04 <carter> i know what a 20 looks like
20:48:06 <carter> ohhh
20:48:08 <carter> your asm jit
20:48:19 <edwardk> every so often I get stuck writing jits for assembly-to-assembly
20:48:29 <dfeuer> edwardk, is there somewhere I can read about WTF  Given is about? I couldn't make head or tail of it.
20:48:47 <edwardk> dfeuer: Given is something i want to remove. Use Reifies instead.
20:49:02 <dfeuer> OK, I will find out what that is, then.
20:49:35 <edwardk> reify takes a value and makes up a type that carries around that value that has a class constraint you can use to get the value back down to term land.
20:49:43 <dfeuer> edwardk, isn't there some library where you helped someone do something truly evil unsafeCoerceing dictionaries to values or something obscene like that?
20:49:54 <dfeuer> Maybe it was that....
20:50:09 <c_wraith> yeah, that sounds like reflection
20:50:15 <edwardk> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r;   reflect :: Reifies s a => p s -> a
20:50:29 <edwardk> dfeuer: i have a half dozen of those ;)
20:50:54 <dfeuer> edwardk, you'd better watch out. SPJ could break the lot with ten keystrokes.
20:51:14 <dfeuer> Or SM, for taht matter.
20:51:17 <edwardk> dfeuer: spj offered to bring reflection into GHC proper. i just haven't bothered.
20:51:47 <dfeuer> OK, so I'm looking at those types you wrote there, and I don't understand them.
20:51:53 <edwardk> dfeuer: it is actually something that is well-typed from a core perspective, but just is unexpressable in the surface language.
20:52:00 <carter> dfeuer: reflection is exploiting a pretty KEY detail of how typeclasses are implemented in ghc
20:52:09 <carter> edwardk: woah, it aactually passees core lint?
20:52:15 <edwardk> carter: it can, yes
20:52:20 <carter> :))))
20:52:31 <dfeuer> edwardk, I recognize that. It just seems like something better brought to the surface language on the language level, no?
20:52:46 <dfeuer> Or something.
20:52:51 <edwardk> hence why we're willing to teach ghc about it
20:52:59 <dfeuer> *nod*
20:53:31 <edwardk> its easiest to understand reflection by starting from an example with something like reifying a boolean
20:53:35 <edwardk> you can make something like
20:53:55 <edwardk> class ReifiesBool t where reflectBool :: p t -> Bool
20:54:07 <edwardk> data TRUE; instance ReifiesBool TRUE where reflectBool _ = True
20:54:17 <edwardk> data FALSE; instance ReifiesBool FALSE where reflectBool _ = False
20:54:40 <edwardk> now you can write reifyBool :: Bool -> (forall s. ReifiesBool s => Proxy s -> r) -> r
20:55:10 <edwardk> reifyBool False k = k (Proxy :: Proxy FALSE); reifyBool True k = k (Proxy :: Proxy TRUE)
20:55:52 <michaelt> oh edwardk is here... I am trying to figure out a stackage build failure for 'distributive' http://sprunge.us/KKai
20:56:10 * dfeuer is still here; just still parsing.
20:56:18 <edwardk> michaelt: interesting one
20:56:49 <glguy> cabal: Prelude.chr: bad argument: 2078608 is a problem with Cabal or cabal-install
20:56:54 <michaelt> edwardk: it's a cabal thing, of course.  the trouble is I can't reproduce it, it depends oon a certain combination
20:56:58 <glguy> afaik it's nothing in particular to do with distributive
20:56:58 <dfeuer> edwardk, it's polymorphic in p.... how's that work?
20:57:05 <michaelt> right, like glguy 
20:57:10 <edwardk> michaelt: that looks like its something outside of my code and in your cabal
20:57:15 <edwardk> dcoutts might know more
20:57:29 <glguy> It has happened to me around the time I upgraded cabals
20:57:35 <michaelt> edwardk: well, the going solution is not to use buildtype Custom so I was wondering about that https://github.com/ekmett/distributive/blob/master/Setup.lhs
20:57:41 <edwardk> dfeuer: doesn't use the argument for anything more than its type
20:58:33 <edwardk> dfeuer: it wants the type, it doesn't care about the value. the p s -> .. rather than Proxy s -> ... is a way of making that clearer, but also letting you pass things like [s] -> ... or Maybe s -> ... if you have one lying around
20:59:03 <edwardk> michaelt: well the Custom setup is needed for doctest not to die
20:59:13 <michaelt> right, I just figured that out.
20:59:23 <carter> glguy: someone hit that recently
20:59:25 <glguy> It seems to be related to stale cabal output from the previous version
20:59:30 <carter> glguy: try cabal clean
20:59:34 <michaelt> hmm hm hm
20:59:42 <dfeuer> edwardk, I'm still getting used to the fact that when it sees `a b` it assumes that `a` is a type *constructor*.
20:59:50 <dfeuer> Or ...
20:59:51 <dfeuer> uh ...
20:59:53 <dfeuer> something.
20:59:53 <glguy> and I had to delete the setup-exe-cache for a possibly related deal
20:59:54 <carter> glguy: pre 1.22 vs 1.22 db format?
21:00:02 <dfeuer> Forget that. 
21:00:10 <carter> glguy: i dont understand the setup exe caches myself
21:00:16 <michaelt> half the 7-10 build failures on stackage are due to distributive ...
21:00:18 <dfeuer> Not a synonym, anyway, or family.
21:00:23 <edwardk> dfeuer: thats basically what it has to be p a -> ... tells us p :: k -> *, and a :: k
21:00:58 <dfeuer> Yeah, something like that.
21:01:04 <edwardk> p could be [], Maybe, Proxy, it could be lots of things
21:01:29 <edwardk> all i care is that i can extract the type from it
21:01:37 <edwardk> i don't care about the value.
21:01:57 <dfeuer> OK, and you're extracting the *piece* of that that's available.
21:02:11 <dfeuer> It just looks like you're extracting the 3 from (+1) 3
21:02:14 <edwardk> given `p Int -> ...` the only thing i can do with that argument is seq it, which'd be dumb, so don't do that.
21:02:22 <dfeuer> Which makes no sense on the value level, but must on the type level.
21:02:59 <edwardk> i can extract the type "Int" from "[Int]" at the type level
21:03:44 <edwardk> type variables can't instantiate to type families or type synonyms
21:03:49 <edwardk> so its always doable
21:04:35 <edwardk> michaelt: for everyone or you?
21:05:10 <michaelt> snoyberg just published the list of failures today https://gist.github.com/snoyberg/49a12475bf28e478c5a3
21:05:13 <dfeuer> edwardk, yeah, I see that; I just keep thinking the wrong way there. I think I'm almost to understanding your Bool example.
21:06:05 <michaelt> i was trying to repair pipes-group which needs free ->  ..... comonad ... -> distributive
21:06:29 <edwardk> michaelt: honestly? it sounds like whatever system he built it on is just screwed up and can't run any custom setup.hs's
21:06:50 <edwardk> notice 'bifunctors' also breaks
21:06:57 <michaelt> edwardk: well, this isn't a legitimate complaint against your setup.hs for sure
21:07:21 <edwardk> oh, and bifunctors is even build-type: Simple
21:07:26 <edwardk> so something is very wrong there
21:07:36 <glguy> bifunctors: DependencyFailed (PackageName "semigroupoids")
21:07:50 <glguy> Well, it fails because it indirectly depends on distributive
21:07:51 <glguy> which failed
21:07:57 <glguy> in that build sedquence
21:08:20 <glguy> but the whole lens stacks builds fine against ghc 7.10.1-rc3, so the stackage build people will have to do some investigation
21:08:47 <michaelt> it seems that there a lot of cabal's out there that will generate such errors.  the discussion on the github issue is a nightmare ...
21:08:58 <michaelt> glguy: oh you had such a failure?
21:09:00 <edwardk> oh, bifunctors has the semigroupoids dep
21:09:24 <glguy> michaelt: I've seen cabal fail like that on other packages
21:09:27 <michaelt> and free needs bifunctors or something
21:09:34 <glguy> once you clean up the stale state it starts working again
21:09:47 <glguy> but I didn't work out which state that was specifically
21:10:06 <michaelt> glguy there's at least one issue about it. https://github.com/haskell/cabal/issues/2251 
21:11:14 <michaelt> glguy: what's the stale state?
21:11:34 <michaelt> would stackage be in one? 
21:11:40 <dfeuer> glguy, what is your name again?
21:11:51 <michaelt> oh, sorry I missed your last sentence
21:11:52 <glguy> I don't know, I deleted everything I could and rebuilt my cabal and cabal-install
21:11:58 <glguy> everything cabal related
21:12:03 <glguy> Eric Mertens
21:12:45 <michaelt> glguy: right, some of the comments recommend that.  But stackage shouldn't have had anything to clean...
21:13:41 <michaelt> I guess the conclusion"the stackage build people will have to do some investigation" is seeming like the right one.
21:14:46 <edwardk> yep
21:14:54 <edwardk> doesn't look like anything i can do to change it
21:15:03 <edwardk> if i had to guess, they are building with the wrong cabal or something
21:15:07 <dfeuer> edwardk, this reify thing reminds me of CPS. Is that a coincidence?
21:15:16 <glguy> The ticket says that error is related to a change in the binary format of files cabal uses, I imagine somehow it's doing a configuration build of the custom setup against one version of Cabal
21:15:24 <glguy> and then separately building against the other
21:15:29 <edwardk> dfeuer: you could make up a GADT to hold onto that info, but it'd be silly
21:15:56 <edwardk> data Reified a where Reified :: Reifies s a => Proxy s -> Reified a
21:16:05 * hackagebot monadic-arrays 0.2.1.4 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.1.4 (EdwardKmett)
21:16:05 <edwardk> reify :: a -> Reified a
21:16:12 <jamesfordummies> when I run this I get Prelude.undefined: http://lpaste.net/127542. However, when I remove the 3rd condition from the second guard, it works fine, why?
21:16:18 <edwardk> then you'd have to open the box to get at the type
21:16:39 <dfeuer> edwardk, isn't it rank-2 rather than existential in your version?
21:16:58 <shachaf> reify is encoding an existential, but the only point of that existential is to use it immediately, generally.
21:17:07 <edwardk> reify a Reified
21:17:43 <shachaf> Instead of passing around the existential you could just pass around the value directly.
21:18:03 <dfeuer> So you're faking up an existential with a rank-2 type, and you say that's better, and I believe you but don't know why.
21:18:36 <edwardk> what it does it create a lexical scope in which there is a 'new type' for which we have a Reifies instance. we made up a dictionary out of a value.
21:18:46 <edwardk> this normally wouldn't be safe, but here it is
21:19:00 <edwardk> because the type is new. that is what is what we're saying with the forall.
21:19:18 <edwardk> you have to give me a function that works for all choices of type.
21:19:33 <edwardk> just so long as it has a Reifies s a instance
21:19:40 <edwardk> and i can pick it however i want
21:19:43 <edwardk> i pick it by magic
21:20:04 <edwardk> but we can construct that magic (slowly) using tools that are available out of the box with haskell
21:20:13 <edwardk> and i can construct it much much more quickly using hackery
21:20:57 <dfeuer> So you're saying it's possible to construct it normally, but for some reason slow?
21:21:17 <edwardk> uses cases, you want fixed length vectors, V 4 a  -- etc. but you have a vector whose length won't be known until runtime, how do you cope?
21:21:50 <dfeuer> Er ... you lost me there.
21:22:03 <edwardk> reify 4 $ \(Proxy :: Proxy n) -> ... work with V n a in here...
21:22:20 <dfeuer> I sort of see.
21:22:34 <edwardk> 4 got turned from a term into a type n such that reflect (Proxy :: Proxy n) = 4
21:22:48 <edwardk> we can do this with anything, functions, etc.
21:23:02 <dfeuer> And what's that buy us again?
21:23:25 <dfeuer> I remember this showing up in the paper by Oleg and someone about the configuration problem?
21:23:34 <edwardk> well, say you want to build a type for working modulo some prime number. integers,  Mod n, but you won't know the prime until runtime sometimes?
21:23:45 <dfeuer> Sure.
21:23:45 <edwardk> this is that paper just made 3 orders of magnitude faster by hackery
21:23:58 <dfeuer> So I don't know the prime till runtime,
21:24:11 <edwardk> not every day i get to one-up oleg by that much of a performance margin ;)
21:24:25 <dfeuer> so ... I don't remember the tiny fraction of the paper I understood.
21:24:51 <edwardk> basically they show that what i did above with Bool can be extended to storing integers
21:25:04 <edwardk> and then they show you can do the same thing with lists of things you can reify
21:25:17 <edwardk> so you can reify a list of numbers.
21:25:30 <edwardk> so anything you can convert to a list of numbers and back can be reified
21:25:37 <edwardk> this includes everything Storable
21:25:47 <edwardk> because they become a list of bytes if you want them to
21:25:49 <dfeuer> Uh-huh... yeah, sounds slow. Peano, or not that bad?
21:25:55 <dfeuer> Oh, list of bytes. Yeah.
21:26:04 <dfeuer> So bad, but not *that* bad.
21:26:07 <edwardk> then stable pointers are storable
21:26:14 <edwardk> so we can take any 'a' and make a stable pointer to it
21:26:16 <edwardk> reify that
21:26:19 <edwardk> then reflect it back
21:26:24 <dfeuer> ZOOM.
21:26:27 <edwardk> and get the pointer turned back into a haskell data type
21:26:46 <edwardk> stable pointers are references to haskell data types intended for passing out and through the FFI mechanism
21:26:49 <luite> haasn: no
21:26:53 <edwardk> you need to be able to hand them to C and get them back later
21:27:08 <dfeuer> Yeah, I had a sense of that. But not how it relates to this issue.
21:27:08 <edwardk> for all those APIs that give you a callback and a void* or something
21:27:32 <edwardk> well, instance Storable (StablePtr a)  is out there
21:27:42 <edwardk> so we can take any value of type 'a'
21:27:50 <edwardk> make a 'StablePtr a' from it
21:27:55 <edwardk> serialize that to a list of bytes
21:28:00 <edwardk> then reify the list of bytes into a type
21:28:03 <edwardk> that we can reflect later
21:28:12 <edwardk> the reflection gets out the list of bytes
21:28:15 <dfeuer> Uh-huh. At which point you can be sure to be using the right pointer?
21:28:17 <edwardk> reassembles the stable ptr
21:28:31 <dfeuer> As opposed to some other pointer you accidentally used instead?
21:28:35 <edwardk> and then turns it back into a haskell object
21:28:44 <edwardk> the types don't let you do anything wrong
21:28:54 <edwardk> its a type
21:29:19 <dfeuer> But all that conversion is slow, and you found a way to make pretend real fast and not bother actually doing the conversion?
21:29:22 <edwardk> the problem with the StablePtr solution just described is that it leaks a stable pointer for every call to reify
21:29:34 <edwardk> so oleg came up with a trick that let it free the stable ptr
21:29:43 <edwardk> and for the longest time that was the best we could do
21:29:49 <dfeuer> Leaks as in can't GC ever?
21:30:09 <dfeuer> Why's that?
21:30:16 <edwardk> working with elliott, we figured out how to make it faster =)
21:30:44 <edwardk> because you might stuff your copy of the type into one of those existential boxes like i just described
21:30:49 <edwardk> and pull it out to look at later
21:31:04 <edwardk> oleg was tricky and figured out how to make the dictionary itself hold the only reference to the stable ptr
21:31:23 <edwardk> so the thunk that replaces itself into the answer frees the stable ptr in his version
21:31:44 <edwardk> and then he always forces that evaluation before calling your function
21:31:46 <edwardk> its a cute trick
21:31:53 <edwardk> its also really really hard to maintain!
21:32:02 <edwardk> so we found a better way that runs faster
21:32:18 <edwardk> (basically every release of ghc since 6.8 or so broke oleg's trick in different ways)
21:32:29 <dfeuer> Oy.
21:32:57 <edwardk> the oleg-like version we have is the 'slow' branch of reflection: https://github.com/ekmett/reflection/blob/master/slow/Data/Reflection.hs#L185
21:33:31 <edwardk> the fast path is ~5 lines with an unsafeCoerce. 
21:33:32 <edwardk> https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs#L102
21:35:13 <dfeuer> edwardk, yeah, but what does it do?
21:35:33 <edwardk> well, a dictionary with one entry in it is represented the same way as that one entry
21:35:35 <edwardk> so
21:35:46 <edwardk> class Reifies s a | s -> a where reflect :: p s -> a
21:36:04 <edwardk> Reifies s a => r    has the same representation as a function (p s -> a) -> r
21:36:14 <edwardk> at least in core
21:36:52 <dfeuer> Ah. 
21:37:10 <gfixler> > let a = [1..10] in zip a $ drop 3 a
21:37:12 <lambdabot>  [(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10)]
21:37:19 <gfixler> is ^^ considered 2 walkings of the list?
21:37:21 <RustyShackleford> is there a way to split a list into partitions, returning a list of lists?
21:37:27 <dfeuer> And there's something to stop you from trying that with the peculiar exception Coercible?
21:37:38 <edwardk> reify a k    then unsafeCoerces k :: forall s. Reifies s a -> Proxy s -> r   into (forall s. (p s -> a) -> Proxy s -> r)
21:37:40 <gfixler> RustyShackleford: chunksOf?
21:37:49 <edwardk> and then calls it with (const a)  and Proxy
21:37:51 <arkeet> RustyShackleford: how do you want it partitoned?
21:38:02 <edwardk> the newtype is needed because GHC is smart enough to see through the ruse otherwise
21:38:23 <edwardk> sure, what we're doing there is absolutely unsafe from the standpoint of the surface language
21:38:27 <dfeuer> edwardk, what newtype?
21:38:36 <edwardk> "Magic"
21:38:45 <edwardk> newtype Magic a r = Magic (forall (s :: *). Reifies s a => Proxy s -> r)
21:38:47 <arkeet> gfixler: I guess it would, but it would only take up a bounded amount of space when you consume it.
21:38:58 <dfeuer> Uh-huh... No, I don't understand that, and probably won't tonight.
21:39:07 <RustyShackleford> [1, 2, ...64] to [[1, ..., 8], [9, ..., 16], ...]
21:39:16 <edwardk> its just the second argument to reify packed into a newtype
21:39:17 <arkeet> > chunksOf 4 [1..64]
21:39:19 <dfeuer> The newtype somehow prevents GHC from seeing what?
21:39:20 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20],[21,22,23,24],...
21:39:34 <RustyShackleford> arkeet: thank you
21:39:54 <dfeuer> Since people are using chunksOf, can *someone* respond to my message on libraries@haskell.org to say they think it's a good idea to add that to Data.Sequence?
21:40:12 <edwardk> ghc won't let me unsafeCoerce  (p => r) to q -> r 
21:40:29 <edwardk> because it can't instantiate the type 'a' for unsafeCoerce to such a type
21:40:38 <edwardk> but it can unsafeCoerce :: Magic a r -> ...
21:40:48 <dfeuer> edwardk, why can't it do so?
21:40:58 <dfeuer> Is that an impredicative type or something?
21:41:05 <edwardk> impredicativity
21:41:11 <edwardk> you need to instantiate type variables to polytypes
21:41:16 <dfeuer> Huzzah.
21:41:25 <dfeuer> Well, I guessed that one right.
21:42:26 <edwardk> there are some articles showing how you can use reflection to make a monoid out of a unit and a binary function you have in scope, etc.
21:42:40 <edwardk> i use it for all sorts of neat stuff
21:43:03 <edwardk> it is key to making the lens exception handler machinery work with any fold for instance
21:43:13 <dfeuer> ASide from Given, it's supposedly safe to use?
21:43:18 <edwardk> correct
21:43:21 <edwardk> Given is evil
21:43:29 <dfeuer> And you're deprecating Given.
21:43:36 <edwardk> and will likely be moved to Data.Reflection.Unsafe whenever i can get my act together
21:43:48 <dfeuer> I looked at the type of Given and thought it didn't even make sense.
21:44:00 <edwardk> i can't remove it without annoying some people for whom it is the only way to  solve some things
21:44:15 <edwardk> but i can either exile it to another package or an Unsafe module in good conscience
21:44:26 <arkeet> why is it needed?
21:44:39 <edwardk> some folks use Given the same way they used to use ImplicitParam superclasses for classes.
21:44:53 <dfeuer> Lemme guess.... My guess is that it's because Haskell doesn't have a good module system?
21:45:08 <edwardk> instance (?x :: Int) => Foo Bar -- isn't legal but instance Given Int => Foo Bar  is
21:45:15 <edwardk> its because of lots of things
21:45:19 <edwardk> its a definite perversion
21:45:23 <edwardk> but some folks want to use it
21:45:50 <edwardk> anyways for a while GHC used to allow the instance (?x :: Int) => ... hack.
21:45:58 <edwardk> when they fixed it some people cried.
21:45:59 <dfeuer> How are these even used?
21:46:12 <edwardk> reflection or given?
21:46:29 <dfeuer> Given, briefly. Reflection you can probably point me to something?
21:47:04 * dfeuer is about to fall asleep.
21:47:18 <edwardk> data SystemConfiguration = .... instance Given SystemConfiguration where ...; now you can just    call functions with a Given SystemConfiguration => ... constraint
21:47:33 <edwardk> if you won't know the SystemConfiguration til runtime then you can use the given function
21:48:07 <arkeet> ImplicitParams can cover that use case. what about the superclass thing?
21:48:13 <edwardk> main = parseSystemConfiguration >>= \cfg -> given cfg $ do stuff
21:48:33 <dfeuer> *barf*
21:48:36 <edwardk> say you want the instance behavior to depend on the system configuration?
21:48:50 <edwardk> the implicit params can't do that
21:48:51 <arkeet> mmmmmmmmmhgh.
21:48:59 <edwardk> not any more
21:49:06 <edwardk> they could for a little window around 7.2-7.4 or so
21:49:17 <dfeuer> Why not anymore? Was that super-evil for some reason?
21:49:22 <edwardk> it is evil
21:49:41 <edwardk> it violates coherence of instance resolution all over the place
21:49:55 <dfeuer> Ick. 
21:50:01 <edwardk> what local assignment you have for an implicit param at the time a dictionary is constructed changes the meaning of an instance.
21:50:27 <dfeuer> So one thing I sort of understood from the configuration problem paper
21:50:27 <edwardk> Given is safe if you swear you'll only use it in one of the two ways mentioned above. a single global instance for your type or a local given call.
21:50:40 <edwardk> for a single top level given call usually somewhere in main
21:50:55 <dfeuer> was this idea of local instances for classes with an extra type variable that ensures coherence.
21:50:56 <edwardk> Reifies on the other hand, is always safe, because the type is 'fresh' each time.
21:51:12 <edwardk> which uses exactly what you said, a type variable to ensure coherence
21:51:26 <edwardk> its the same trick that makes ST s safe
21:51:33 <edwardk> the quantifier on 's'
21:52:05 * johnw imagines a shrivelled hobbit coughing out, "Skolem, skolem.."
21:52:27 <dfeuer> OK, edwardk, can you spare a pointer or two to where I can read about ways people use this reflection stuff?
21:53:25 <johnw> dfeuer: a key use of reflection is to pass data into an instance, where no monad or extra argument is allowed
21:53:47 <edwardk> dfeuer: i first used it when i was building a monoidal parser for regular languages. i wanted to take a DFA that i had expressed a term and turn it into a type 's', so that i could have Tab s talk about the tabulations for _that_ DFA.
21:54:20 <edwardk> `Mod n` is a good example.  
21:54:21 <edwardk> Building a monoid out of an associative operator and its unit that you have on hand.
21:54:51 <dfeuer> Without needing to make a newtype and a special instance?
21:54:54 <edwardk> reifies ((+),0) $ \(Proxy :: Proxy s) -> ... M a s ...  might be a monoid given something like
21:55:08 <edwardk> what happens when the instance really does depend on a value?
21:55:21 <edwardk> e.g. when you can't completely phase separate compilation?
21:55:25 <dfeuer> Now you're making me think of a paper I read part of about embedding System F in Haskell....
21:55:49 <edwardk> if you think about it this is giving a limited form of dependent types
21:56:00 <edwardk> we can take a term and generate a type
21:56:10 <edwardk> but the quantifier is keeping us sane
21:56:48 <johnw> "passing data boxed into a constraint"
21:57:12 <dfeuer> The modular arithmetic sounds like a good example, yes. I know there's a package that does that so, and I will have another shot at attempting to understand it.
21:57:18 <edwardk> the nice thing about reflection is that Reifies lets us move values from * into Constraint, but without compromising the coherence of isntance resolution
21:57:46 <edwardk> it gives you all the 'good' usecases for scala style implicits, without giving up coherence
21:58:11 <dfeuer> Sounds like fun.
21:58:23 <RustyShackleford> can $ and . accomplish anything that parentheses cannot?
21:58:32 <dfeuer> RustyShackleford, yes.
21:58:34 <RustyShackleford> parentheses seem much clearer to me
21:58:39 <edwardk> another example: https://github.com/ekmett/hyperloglog/blob/master/src/Data/HyperLogLog/Config.hs#L138
21:58:54 <edwardk> https://github.com/ekmett/hyperloglog/blob/master/src/Data/HyperLogLog/Config.hs#L138
21:59:09 <EvanR> RustyShackleford: you can use $ in a section to partially apply application
21:59:10 <edwardk> ReifiesConfig is a special case Reifies-like class
21:59:20 <edwardk> reifyConfig reifies things into it
21:59:36 <EvanR> but id also works
21:59:40 <edwardk> but its set up in such a way that the natural numbers can be used to reflect the right configuration
21:59:50 <edwardk> er type level naturals
22:00:26 <edwardk> that lets me work with Hyperloglog 5        or reifyConfig 5 $ \(Proxy :: Proxy n) -> ... Hyperloglog n ...
22:00:42 <edwardk> and on GHC's prior to when we got working type level nats you can use Hyperloglog $(5)
22:00:59 <dfeuer> edwardk, time for me to go back a few levels and understand some of the simpler stuff first. Like lenses and pipes :-P
22:01:01 <edwardk> because of some silly instances i have in reflection
22:01:14 <dfeuer> But
22:01:34 <dfeuer> I will keep this reflection in mind; I have the feeling I will find a reason to want it soon enough.
22:02:01 <edwardk> it pops up in surprising places. without it i'd find myself with a lot less type safety, or find myself forced to use agda/coq more
22:02:23 <dfeuer> edwardk, speaking of such things....
22:02:39 <dfeuer> An unsatisfying aspect of my reimplementation of zipWith for sequences,
22:02:49 <dfeuer> and also my proposed chunksOf for sequences,
22:03:33 <dfeuer> is that there are all sorts of "can't-happen" errors resulting from the fact that two sequences of the same length needn't have the same shape.
22:04:11 <dfeuer> So the type system doesn't recognize that a certain sequence will actually be a singleton, or non-empty.
22:04:28 <dfeuer> Is there any trickery around that, or is it just a "sucks to be you" situation?
22:05:08 <dfeuer> The finger tree is a numerical representation, but it's a redundant one.
22:05:48 <dfeuer> So the plain old "is this number equal to that number?" question is not such a nice one.
22:06:30 <edwardk> fingertrees are redundant, so you're going to have a hard time
22:06:53 <dfeuer> So I figured.
22:06:54 <edwardk> alas, you don't get to do what i did for online LCA =)
22:07:02 <dfeuer> Online LCA = ?
22:07:08 <edwardk> https://www.fpcomplete.com/user/edwardk/online-lca
22:07:30 <edwardk> http://hackage.haskell.org/package/lca
22:07:40 <edwardk> lowest common ancestor search
22:07:57 <edwardk> given two paths in a (potentially very very deep) tree, find their lowest common ancestor in the tree
22:08:48 <edwardk> there i use a number system based on skew binary, which isn't redundant, and then use the ability to zip up the shapes perfectly once the number of elements match u
22:08:51 <edwardk> er match up
22:09:33 <bob_twinkles> b 5
22:10:06 <edwardk> basically skew binary random access lists support log time 'drop', and two skew binary random access lists can be zipped perfectly if they are the same length, and i can do some other trickery and bam, it just works
22:11:32 <dfeuer> Very nice.
22:12:09 <dfeuer> I had a lot of trouble understanding skew binary the last time I tried to read about it, but I may have learned some things and find it easier by now.
22:12:40 <dfeuer> Good night all. Thanks, edwardk.
22:13:14 <dfeuer> OH!
22:13:24 <edwardk> you may also want to look at my "functionally oblivious" talk which uses zeroless binary and a modified zeroless binary number system
22:13:37 <dfeuer> edwardk, I don't have wakefulness enough to hear the answer,
22:13:47 <edwardk> https://yow.eventer.com/yow-2014-1222/functionally-oblivious-and-succinct-by-edward-kmett-1701 <- was the latest version of that talk
22:14:33 <edwardk> both the fpcomplete article and that talk use non-redundant number systems in fun ways
22:14:35 <dfeuer> but I was wondering if it's possible to represent *numbers* with O(1) addition and O(1) decrement with worst-case space less than linear in the magnitude of the number.
22:15:10 <edwardk> yes
22:15:15 <dfeuer> [and O(1) isZero, of course]
22:15:45 <edwardk> we take data structures and build number systems from them all the time
22:15:49 <edwardk> here you want to do the opposite
22:16:00 <dfeuer> I thought about Okasaki's catenable lists,
22:16:04 <edwardk> take any catenable deque and 'dumb it down'
22:16:25 <dfeuer> but I couldn't see how to compress it.
22:17:42 <edwardk> e.g. https://github.com/alang9/deque/blob/master/Data/Deque/NonCat.hs dumbed down considerably gives you numbers with O(1) inc/dec. and https://github.com/alang9/deque/blob/master/Data/Deque/Cat.hs dumbed down gives numbers with O(1) addition and still O(1) inc/dec
22:19:51 <dfeuer> I figured that it might be possible; I will think more about how this "dumbing down" process works.
22:19:55 <dfeuer> Good night for real.
22:23:47 <Cale> wat
22:24:00 <Cale> It's impossible to add arbitrary numbers in O(1) delay
22:33:42 <RustyShackleford> i want to take a list of list, and turn it into a list
22:34:01 <EvanR> @hoogle [[a]] -> [a]
22:34:04 <lambdabot> Prelude concat :: [[a]] -> [a]
22:34:04 <lambdabot> Data.List concat :: [[a]] -> [a]
22:34:04 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:58:20 <hunt> whats the best way to get started with haskell on mac
22:58:24 <hunt> i mean get it installed
22:58:26 <hunt> i already know haskel
22:58:29 <hunt> l
22:59:18 <Guest80955> haskell is surprisingly quiet tonight
23:00:28 <Hijiri> hunt: there is https://ghcformacosx.github.io/
23:00:32 <Hijiri> but I don't use a mac
23:00:36 <Hijiri> so I haven't tried it
23:02:18 <Guest80955> is the one on haskell.net up to date?
23:02:22 <Guest80955> haskell.org*
23:02:30 <Guest80955> https://www.haskell.org/platform/mac.html
23:03:34 <Hijiri> it's one minor version behind
23:08:31 <divVerent> @pl \ f pre0 pre1 pre2 post0 post1 post2 x -> f pre0 pre1 pre2 x post0 post1 post2
23:08:31 <lambdabot> (((((((flip .) . flip) .) . flip) .) .) .)
23:09:22 <divVerent> @pl \ f x pre0 pre1 pre2 post0 post1 post2 -> f pre0 pre1 pre2 x post0 post1 post2
23:09:22 <lambdabot> flip . ((flip . (flip .)) .)
23:09:59 <arkeet> :t flip
23:09:59 <divVerent> @pl \ f x pre0 pre1 pre2 pre3 post0 post1 post2 post3 -> f pre0 pre1 pre2 pre3 x post0 post1 post2 post3
23:09:59 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .)
23:10:00 <lambdabot> (a -> b -> c) -> b -> a -> c
23:10:02 <arkeet> :t (flip .)
23:10:03 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
23:10:07 <arkeet> :t ((flip .) .)
23:10:08 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> b -> a2 -> c
23:10:10 <divVerent> ah, now I see a pattern
23:10:11 <arkeet> :t (((flip .) .) .)
23:10:12 <lambdabot> (a -> a1 -> a2 -> a3 -> b -> c) -> a -> a1 -> a2 -> b -> a3 -> c
23:10:16 <divVerent> @pl \ x f pre0 pre1 pre2 pre3 post0 post1 post2 post3 -> f pre0 pre1 pre2 pre3 x post0 post1 post2 post3
23:10:16 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .))
23:10:23 <arkeet> you can flip arbitrary adjacent pairs of arguments like this.
23:10:27 <divVerent> okay, that was kinda obvious
23:10:45 <arkeet> so just write down the permutation of arguments you want
23:10:54 <divVerent> arkeet: sure, in theory I knew that... but getting the exact right order of flipping and composition isn't that easy
23:10:56 <arkeet> as a composition of transpositions of adjacent arguments
23:11:23 <arkeet> it's not that hard :)
23:11:45 <divVerent> well, if I just compose lots of transpositions, then I'll get a very long expression :)
23:11:57 <arkeet> quite
23:12:00 <divVerent> pl does a bit better than this
23:12:40 <divVerent> especially the pattern of my first one (i.e. bind all arguments to a value except for one) looks quite optimal
23:13:34 <divVerent> and the second one is also only O(n) in the number of args, while naive swapping yields O(n^2) characters
23:13:52 <arkeet> yeah
23:14:13 <divVerent> nevertheless... I suppose I'll still write "std::bind"-like stuff pointful instead, except for the case of 2 and 3 args
23:15:02 <divVerent> I actually wonder whether pl even solves this:
23:16:02 <divVerent> @pl \ f -> do { st <- get; let (st', x) = runStateT f st; put st'; }
23:16:02 <lambdabot> (line 1, column 11):
23:16:02 <lambdabot> unexpected '{'
23:16:02 <lambdabot> expecting variable, "(", operator or end of input
23:16:24 <divVerent> (also, I meant runState)
23:16:30 <arkeet> @@ @pl @undo \ f -> do { st <- get; let (st', x) = runState f st; put st' }
23:16:30 <lambdabot>  (line 1, column 1):
23:16:30 <lambdabot> unexpected "<"
23:16:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:16:53 <arkeet> hum
23:17:02 <divVerent> but I remember it's something like StateT . return . runState
23:17:13 <divVerent> (essentially, needed to call a State function when in a StateT)
23:19:32 <arkeet> :t runState
23:19:33 <lambdabot> State s a -> s -> (a, s)
23:19:52 <arkeet> :t state . runState
23:19:53 <lambdabot> MonadState s m => State s a -> m a
23:20:28 <divVerent> oh, that actually looks better... right, MonadState
23:21:13 <divVerent> in my specific case, I had instead changed my functions from State s a to Monad m => StateT s m a... could have used MonadState instead though
23:26:06 * hackagebot http-date 0.0.6 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.6 (KazuYamamoto)
23:26:12 <arkeet> MonadState is the thing to use yeah.
23:26:37 <arkeet> then you can access some StateT deep in a monad transformer stack.
23:40:14 <jle`> i needed a traverse using (a -> f b)...but i wanted each (a -> f b) run to have access to a mutable state. so now i am traversing using (a -> StateT s f b). everything feels so wrong yet so right
