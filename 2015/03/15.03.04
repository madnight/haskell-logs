00:00:05 <pharaun> good god
00:00:16 <dmj`> que?
00:00:17 <pharaun> well i'm happy to see more apps :)
00:00:31 <pharaun> but a 20 line flood seems a bit much
01:07:04 <jle`> used Writer(T) in real life correctly for the first time the other day.  the only time i've ever used it where it wasn't just to abuse do notation (ie having everything just be a sequence of tells, which might as well just be an mconcat)
01:07:52 <jle`> maybe i should say, Writer, while caring about the result and not just the side effecting tells
01:08:05 <tdammers> I was about to ask
01:08:50 <jle`> using Writer and not caring about the result usually is a tell that your whole thing could have just been an mconcat
01:09:05 <tdammers> indeed
01:09:33 <ocharles_> or at least sequenceA_
01:10:01 <jle`> isn't sequenceA_ just mconcat for Writer w?
01:10:09 <jle`> and execWriter
01:10:17 <jle`> :t sequenceA_
01:10:18 <lambdabot>     Not in scope: ‘sequenceA_’
01:10:18 <lambdabot>     Perhaps you meant one of these:
01:10:18 <lambdabot>       ‘F.sequenceA_’ (imported from Data.Foldable),
01:10:22 <jle`> :t T.sequenceA_
01:10:23 <lambdabot>     Not in scope: ‘T.sequenceA_’
01:10:23 <lambdabot>     Perhaps you meant one of these:
01:10:23 <lambdabot>       ‘F.sequenceA_’ (imported from Data.Foldable),
01:10:40 <jle`> i don't know how to read
01:10:55 <tdammers> I can see use cases for WriterT while throwing away the result though
01:11:49 <EvanR> huh
01:12:35 <EvanR> tdammers: how could that work
01:12:39 <acetoline> say, why doesn't my djinn support lists and recursive types
01:13:04 <jle`> acetoline: it's waiting for your pull request :)
01:13:07 <shachaf> It doesn't support lists because lists are boring.
01:13:14 <tdammers> EvanR: WriterT over IO makes plenty of sense to me
01:13:31 <acetoline> jle`: lol
01:13:35 <acetoline> but seriously
01:13:37 <jle`> tdammers: you mean instead of working with IO w's ...?
01:13:50 <EvanR> tdammers: but if you throw away the writers result whats the difference
01:13:58 <shachaf> Lists are seriously boring. f :: ... -> [a]; f _ = []
01:14:13 <tdammers> EvanR: no, not the stuff that the writer wrote; the "return value"
01:14:22 <EvanR> of tell?
01:14:24 <jle`> [IO w] -> IO [w]
01:14:29 <tdammers> EvanR: yes
01:14:35 <EvanR> :t tell
01:14:36 <lambdabot> MonadWriter w m => w -> m ()
01:14:40 <EvanR> () ?
01:14:45 <jle`> sounds like you could just use sequence
01:15:03 <EvanR> i just dont know what you mean
01:15:31 <jle`> EvanR: meaning, use execWriterT to get the all of the logging activity
01:15:49 <EvanR> oh, youre throwing away the main result
01:15:54 <EvanR> not the "writer result"
01:15:55 <jle`> so the logging happens still
01:15:58 <jle`> yes
01:16:30 <jle`> tdammers: oh i see, what if you don't have an [IO w] beforehand, if your IO w's can branch on results within the computation?
01:17:26 <tdammers> jle`: yes; or when most of your activity is IO, with occasional tells in between
01:17:33 <tdammers> (still have to liftIO all the things though)
01:18:04 <jle`> if your structure is static you could have `IO w` be all-of-the-activity-between-each-tell
01:18:39 <tdammers> yes, sure
01:18:45 <jle`> i guess any computation that only uses Applicative for `WriterT w IO a` (and not Monad) might as well be [IO w]
01:18:52 <tdammers> probably
01:18:57 <jle`> but when Monad happens then that's when it becomes useful
01:19:02 <tdammers> but I think it's nice to make the two concerns explicit
01:19:03 <jle`> who uses monads tho
01:19:05 <tdammers> signal intent and all that
01:19:16 <tdammers> "monad blindness", haha
01:19:17 <jle`> tdammers: ah yeah that's true
01:25:22 <ocharles_> Does  riker :: Applicative g => f Bool -> g () -> f (g ()) ; riker x = fmap (bool (pure ()) x)  have a standard name, or is it expressible in any other way? I sort of what a "conditional fmap"
01:25:49 <ocharles_> would also settle for Monoid m => f Bool -> m -> f m that is mempty when the Bool under f is False
01:26:30 <ocharles_> It's a bit like `when`, only for applicatives/functors
01:28:39 <kqr> ocharles_, how would you know if the bool under f is false?
01:28:46 <ocharles_> fmap
01:28:57 <kqr> oh right
01:29:05 <kqr> missed the last f
01:29:49 <ocharles_> I think for now I'll just introduce something with slightly more specialised types and give it a better now
01:29:50 <ocharles_> name*
01:29:52 <ocharles_> (whenCss)
01:29:58 <ocharles_> or even cssWhen
01:40:33 * hackagebot persona-idp 0.1.0.0 - Persona (BrowserID) Identity Provider  http://hackage.haskell.org/package/persona-idp-0.1.0.0 (frasertweedale)
02:19:27 <tjger> is there a generalizing module (like Data.Functor) providing the partition function?
02:22:33 <EvanR> tjger: what is the type of that function
02:23:29 <tjger> partition has (a -> Bool) -> [a] -> ([a],[a])
02:23:51 <tjger> i want something that not only works on lists but on...Foldable i guess?
02:23:58 <EvanR> so (a -> Bool) -> f a -> (f a, f a)
02:24:13 <shachaf> What would the type be for something other than a list?
02:24:18 <EvanR> wont work with Foldable because you cant put the subsets back together in some f way
02:24:56 <tjger> EvanR: i see. so is there a different typeclass that implements what im looking for?
02:25:06 <tjger> i really need to read the typeclassopedia again...
02:25:30 <EvanR> FromList ;)
02:25:33 <jtanguy> i think you need a Traversable here
02:25:42 <jtanguy> :t traverse
02:25:43 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:25:50 <EvanR> traversable cant remove any elements
02:26:25 <tjger> EvanR: it doesnt have to, just spread them out over a tuple
02:26:46 <EvanR> :t \x -> (x,x)
02:26:47 <lambdabot> t -> (t, t)
02:27:36 <tjger> let me ask in a different way: since partition is implemented in terms of filter, is there a generalized filter?
02:28:07 <tjger> i can justify running it twice. after all, that's a constant factor
02:28:15 <indiagreen> is there any publicly available list of Hackage package maintainers ordered by the numbers of packages maintained?
02:28:18 <EvanR> https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
02:29:29 <EvanR> tjger: you can produce a ([a], [a]) of course
02:30:20 <tjger> EvanR: sure. i wouldnt have thought that it would be so complicated. seems like a very common use case
02:30:53 <EvanR> its interesting to ask what the generalized properties of some must have to be able to do this filter thing
02:31:41 <EvanR> you can define a type class with one method (a -> Bool) -> f a -> (f a, f a) but what laws would it follow
02:32:18 <tjger> needs a neutral element for sure
02:33:22 <funfunctor> hi
02:33:38 <EvanR> tjger: well ++ on the result would need to be the original
02:33:45 <EvanR> so whats ++
02:33:56 <tjger> EvanR: ou mean on the tuple?
02:34:09 <frerich> Does anybody have some experience with abstracting a database? My program currently manages calendar data in a JSON file; it gets read into memory and then there are a couple of functions like 'absencesOf :: Calendar -> Person -> [Absence]' to query the data. To avoid having the data in memory, I might eventually migrate to something like SQL - is there a nice way to model this in Haskell?
02:34:09 <frerich> I was thinking of having a 'Calendar' typeclass with a couple of operations, but my experience is that whenever my reflex is to use a typeclass, it's actually not a good idea to use a typeclass. :-}
02:34:45 <Axman6> good reflex =)
02:35:01 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121533
02:35:41 <funfunctor> I'm having some issues understanding how to properly Marshall these data paths to and from bytestring
02:35:43 <tdammers> frerich: I like to formalize such APIs in a plain record type that contains a bunch of functions
02:35:46 <tdammers> "OOP"
02:36:16 <tdammers> data Calendar = Calendar { absenceOf :: Person -> [Absence]; ... }
02:36:26 <EvanR> funfunctor: like, you cant read data from a pointer (plus length) into a ByteString?
02:36:32 <funfunctor> I think I have bladeRFSyncTx pretty close to where I want it but bladeRFSyncRx I am not sure about
02:36:43 <frerich>  tdammers: True, reminds me of https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:36:54 <tdammers> frerich: yes, it's heavily inspired by that
02:37:21 <tdammers> https://bitbucket.org/tdammers/hubby/src/45f1e9272ed100bd888390fb1a1f5776a9588971/hubby/Hubby/Storage/?at=master
02:37:25 <funfunctor> EvanR: i'm not sure how to deal with c'bladerf_sync_rx needing preallocated space
02:37:30 <tdammers> here's how I'm applying that in the wild
02:37:43 <funfunctor> EvanR: and how to get that into a bytestring
02:37:54 <funfunctor> most importantly, how much space and of what type?
02:37:56 <tdammers> Type.hs defines the Storage interface, and a dummy implementation (blackHoleStorage)
02:37:58 <EvanR> funfunctor: ok so thats two different issues
02:38:06 <funfunctor> yes
02:38:35 <EvanR> funfunctor: for the first, issue, one way is to just preallocate space before doing the c call. you can use alloca-like function to allocate temporary space for the call. how much? i dont know doesnt the api tell you?
02:38:57 <EvanR> what type doesnt matter its a buffer for bytes
02:39:23 <EvanR> which makes sense since youre trying to get a ByteString
02:39:30 <funfunctor> EvanR: well I know alloc/malloc does that but its the size that confuses me
02:40:03 <funfunctor> EvanR: I included the C API in the paste at the bottom
02:40:03 <EvanR> funfunctor: allocaBytes to be more precise
02:40:16 <funfunctor> yes I know about allocBytes
02:40:45 <EvanR> do you not understand how to use the C api youre trying to bind to?
02:40:57 <EvanR> pretend theres no haskell for a minute
02:41:05 <EvanR> what would you do
02:41:18 <funfunctor> EvanR: I do but its very general. the structures that get sinked/sourced out of these functions are completely user defined
02:41:41 <EvanR> somewhere in there it will report or take a size
02:41:57 <funfunctor> sure, so the C API is such that you can define whatever structure you know and sink and source it out the radio hw
02:41:59 <EvanR> or else rely on "null byte terminators"
02:42:12 <funfunctor> yea I was thinking about how it knows the bounds?
02:43:14 <EvanR> look at all the parameters, return types, and relevant documentation for that c api
02:43:44 <funfunctor> i'm looking but not seeing :()
02:44:05 <funfunctor> http://hoopycat.com/bladerf_builds/latest/artifacts/libbladeRF_doxygen/group___f_m_t___m_e_t_a.html#gga4c61587834fd4de51a8e2d34e14a73b2a4af3974535ba338bbcecaa8d7500de03
02:44:06 <funfunctor> http://hoopycat.com/bladerf_builds/latest/artifacts/libbladeRF_doxygen/group___f_n___d_a_t_a___s_y_n_c.html#gacbe845827dd4ad717f3cbc812e66b204
02:44:30 <funfunctor> are the two places from the docs relavent
02:45:11 <EvanR> .oO( void* samples, unsigned int num_samples ... )
02:45:53 <funfunctor> EvanR: ah ! http://hoopycat.com/bladerf_builds/latest/artifacts/libbladeRF_doxygen/group___f_n___d_a_t_a___s_y_n_c.html#gacde68e74a8f7d27100b071634b2e65c5 the buffer size is sent in another function before calling this
02:46:04 <funfunctor> s/this/these sync functions
02:46:35 <funfunctor> EvanR: thats just the number of samples not their respective size
02:49:33 <nerium> I'm trying to run this calculator, but getting an error: https://gist.github.com/oleander/bd8593274b72fa87a43f#file-gistfile1-hs-L34
02:49:34 <nerium> Can anyone see what the problem is?
02:49:45 <funfunctor> EvanR: the API seems to 'remember' the size once you configure it with bladerf_sync_config
02:49:55 <EvanR> funfunctor: so looks like the assumption is you have a continuous stream of bytes, and it sends and recieves every n*1024 bytes
02:50:43 <EvanR> but you just need to tell it how many samples you want to read
02:50:51 <EvanR> a sample is some number of bytes
02:50:59 <zipper> There is a haskell meetup in Norway?
02:51:17 <f-a> nerium: I fear Bind :: Calculator x a -> (x -> Calculator x y) -> Calculator x y
02:51:38 <f-a> check the expected type vs. actual type error
02:51:58 <funfunctor> EvanR: so should I be using a hidden IORef between bladeRFSyncConfig and bladeRFSyncRx calls?
02:52:11 <EvanR> if you need to
02:52:31 <funfunctor> EvanR: well buffer_size is passed in one and used in the other it seems
02:52:46 <zipper> Haskell communities in Norway?
02:52:49 <EvanR> if you want to transfer whole buffers at a time ok
02:52:59 <EvanR> but the api lets you pick the number of samples to read
02:53:35 <f-a> nerium: i.e. (a -> Calculator x y) instead of (x -> Calculator x y), because bind (>>=) is m a -> (a -> m b) -> m b
02:53:37 <funfunctor> EvanR: the number of samples /= the buffer size though
02:53:37 <tdammers> zipper: bernalex is running something that looks like a promising operation from oslo
02:53:51 <EvanR> funfunctor: ...
02:55:25 <funfunctor> EvanR: a buffer is some fixed block size (buffer_size mod 1024) and a stream is num_samples * buffer_size * num_buffers
02:56:00 <nerium> f-a: Is this really possible with that signature? https://gist.github.com/oleander/ed52575368071de73d85
02:56:44 <EvanR> funfunctor: im just tell you what the documentation says, and how you might want to wrap it to give the exact functionality it says to the user
02:57:18 <EvanR> if you want to deviate from the api or ignore some of the functionality ok
02:57:35 <zipper> tdammers: Thanks
02:57:41 <funfunctor> i'm trying to have all the same functionality
02:58:21 <EvanR> the client code can read any number of samples it wants, and that many samples will be transfered to the client side buffer, and the operation might time out
02:58:28 <EvanR> or fail
02:58:48 <EvanR> thats literally where the size comes from for that call
03:00:26 <funfunctor> EvanR: so your saying I should add a extra parameter to my signature for bladeRFSyncRx for the size to allocate?
03:00:44 <f-a> nerium: help me, what is Calculator a x?
03:00:48 <EvanR> funfunctor: why another one?
03:00:59 <nerium> f-a: Calculator Integer (Result Integer)
03:01:09 <nerium> I want to be able to add and div numbers
03:01:26 <nerium> if I try to div by zero, it should stop the evaluation and return Undefined
03:01:34 <EvanR> there are three input parameters to that C cal
03:01:51 <EvanR> so a haskell function minimally wrapping it would have those three parameters
03:02:21 <f-a> what does the first integer represent, nerium ?
03:03:02 <nerium> f-a: The value that can be passed to addr and divr
03:03:48 <f-a> ok
03:07:21 <funfunctor> EvanR: those parameters in bladerf_sync_rx don't even contain enough information to work out how big the buffer should be
03:07:38 <nerium> f-a: Any idea :) ?
03:07:47 <EvanR> funfunctor: all you need to know is how big a sample is
03:08:34 <EvanR> funfunctor: i see the answer in the first link you pasted
03:08:52 <f-a> one sec nerium. At least your example works without the monas instance
03:09:08 <funfunctor> and how can I tell that by those parameters? because that is specified in bladerf_sync_config
03:09:24 <EvanR> it does matter
03:09:31 <EvanR> it doesnt even matter
03:09:36 <funfunctor> so I can only think of IORef
03:09:44 <funfunctor> ?
03:10:14 <funfunctor> the size is passed in one action and the allocation happens in another
03:10:29 <EvanR> you are talking about buffer size but i am taking about sample size
03:10:50 <EvanR> the amount of buffer to allocate to get num_samples is num_samples * sizeOfSample bytes
03:11:04 <EvanR> the send buffer internal to the system is irrelevant
03:12:17 <funfunctor> and how do we know what sizeOfSample bytes is in bladeRFSyncRx ?
03:12:43 <EvanR> because its a fixed number, specified in the doc
03:13:07 <funfunctor> where?
03:13:17 <EvanR> http://hoopycat.com/bladerf_builds/latest/artifacts/libbladeRF_doxygen/group___f_m_t___m_e_t_a.html#gga4c61587834fd4de51a8e2d34e14a73b2a4af3974535ba338bbcecaa8d7500de03
03:13:52 <funfunctor> EvanR: thats just the minimum bound
03:14:25 <EvanR> you are very interested in the internal buffer sizes that have nothing to do with the function you asked about ;)
03:14:51 <EvanR> ill just repeat "what is the size of a sample in bytes" and let you read that page
03:15:40 <funfunctor> EvanR: no because read http://hoopycat.com/bladerf_builds/latest/artifacts/libbladeRF_doxygen/group___f_n___d_a_t_a___s_y_n_c.html#gacde68e74a8f7d27100b071634b2e65c5 also
03:15:51 <funfunctor> EvanR: that is variable because the speed of the hw is variable
03:16:07 <funfunctor> you can transfer larger or smaller blocksizes
03:16:29 <EvanR> what does that have to do with the size of a single sample
03:17:17 <f-a> nerium: how about flipping the type arguments (a x instead of x a)
03:17:25 <f-a> (or use a newtype if you like)
03:17:58 <f|`-`|f> hmmm
03:19:18 <EvanR> funfunctor: allocaBytes (4 * numSamples) $ \ptr -> ...
03:20:09 <f-a> http://www.ariis.it/link/t/gistfile1.hs <-- like, this typechecks, nerium
03:25:36 <nerium> f-a: Thanks!
03:25:55 <funfunctor> EvanR: alright so, i'm probably missreading something then.. assuming I fix all that up.. how to get a bytestring from a pointer?
03:26:28 <zipper> Do buttons make get requests by default? Say I wanted to call a handler's get?
03:26:33 <nerium> f-a: May I ask what you changed?
03:26:58 <EvanR> funfunctor: peekArray :: Int -> Ptr Word8 -> IO [Word8]
03:27:37 <f-a> nerium: switched the parameters of the type and modified the program accordingly
03:27:51 <f-a> i.e. Calculation x a not is Calculation a x
03:28:14 <f-a> as you can see with my change and application of one type parameter, you get your monadic bind signature
03:28:32 <f-a> Bind :: Calculator x a -> (x -> Calculator y a) -> Calculator y a
03:28:37 <f-a> (apply leftmost arg)
03:29:01 <nerium> f-a: Aha. How would you implement Bind now?
03:29:21 <nerium> f-a: I tried this https://gist.github.com/oleander/8be1eb31e3bdfa830860
03:29:26 <nerium> But that didn't work
03:30:02 <f-a> nerium: paste the whole error, but keep in mind you *need* to follow your signatures
03:30:15 <nerium> f-a:
03:30:16 <nerium>     Expected type: Calculator (Result a) a
03:30:17 <nerium>       Actual type: Calculator (Result a) x
03:31:50 <mniip> is it ok to use Data.Matrix to represent 2-dimentional arrays of Bool or Char?
03:32:57 <funfunctor> EvanR: and then pack :: [Word8] -> ByteString ?
03:33:03 <EvanR> that would do it
03:34:32 <f-a> bind is a function nerium , what are you pattern matching against?
03:34:35 <f-a> *Bind
03:35:10 <ij> mniip, Do you have any reason to think it wouldn't be okay?
03:36:24 <f-a> nerium: is this some exercise from some course?
03:44:40 <mniip> ij, I'm not using most of the Data.Matrix operations though
03:44:45 <nerium> f-a: I just tought this would be a good exercise to learn monads.
03:45:12 <mniip> I only need random access, cloning with one element set to a different value, and indexed mapping
03:45:25 <f-a> nerium: indeed it is a good exercise
03:45:35 <EvanR> mniip: then a 2D array might make more sense
03:45:43 <nerium> f-a: "m" in Bind m f, should be a value returned by addr or divr
03:45:52 <EvanR> Data.Array
03:46:20 <nerium> f-a: I my case Result a
03:46:50 <nerium> f-a: No it should not, it should be of type Calculator a
03:46:59 <nerium> Add or Div
03:47:12 <nerium> Which is why I'm passing it to eval again
03:47:20 <f-a> indeed indeed
03:48:17 <nerium> f-a: So why is it complaining? :)
03:48:37 <f-a> (Bind m f) <--- you cannot pattern match against this
03:48:49 <f-a> Bind m f is the type signatura
03:48:59 <f-a> Bind contains a /function/
03:49:12 <f-a> so (Bind myfunction) will do
03:49:48 <f-a> does that mean that function has to be applied to obtain a Calc a x? totally!
03:50:02 <f-a> does that mean that eval might need another argument? Possibly!
03:51:05 <nerium> f-a: What should I apply myfunction to?
03:51:13 <nerium> If I just have Bind myfunction ?
03:51:23 <f-a> ok
03:51:28 <f-a> bind wraps a function
03:51:55 <nerium> f-a: I also need the return value from addr and divr
03:52:05 <f-a> this function takes some datatype (Calculator a x), a function x -> Calc a y and returns a Calc a y
03:53:09 <f-a> got to go now nerium , but keep at it, you are on the right track!
03:53:36 <mniip> EvanR, should I use 'Array i (Array i e)'?
03:53:41 <f-a> and remember, as someone said "monads like a great ocean, they are great"
03:53:58 <EvanR> mniip: Array (Int,Int) Char for example
03:54:33 <mniip> ohh
03:54:41 <mniip> tuples are also Ix?
03:54:56 <EvanR> Ix a => Ix (a,a)
03:55:01 <EvanR> or something
03:55:05 <mniip> neat
03:55:15 <Axman6> I think it might actually be (Ix a, Ix b) => Ix (a,b)
03:55:20 <Axman6> which is even cooler
03:57:04 <Elision> @hoogle (MonadState s m, MonadError e m) => Either e s -> m ()
03:57:06 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
03:57:06 <lambdabot> Data.Either rights :: [Either a b] -> [b]
03:57:06 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:57:14 <Axman6> so close
03:57:50 <Elision> ^ I'm trying to do some error+state shenanigans, and this seems like a fairly reasonable function, but it doesn't exist
03:58:02 <Axman6> write it!
03:58:25 <Elision> (it's just either throwError put AFAICT, but I feel like it ought to be somewhere in one of those modules)
03:58:32 <Axman6> I assume functions with types s -> m () and e -> m () exist
03:59:27 <tdammers> tfw you realize you're complaining that a function that takes 4 seconds to write isn't in the standard libraries #justhaskellthings #firstclassproblems
04:01:01 <Elision> :P
04:01:39 <Axman6> #firstclassproblems, I like it
04:07:24 <kqr> I usually have a bunch of definitions in the top of my source files near the imports
04:07:40 <kqr> which are the "these should really be part of a library but I haven't found it yet" definitions
04:08:35 <funfunctor> EvanR: any advice on cleaning this up a little? http://lpaste.net/121534
04:08:54 <EvanR> use allocaBytes
04:09:31 <EvanR> for instance you forgot to free the bytes
04:09:38 <funfunctor> EvanR: how do I use it in this context without another inner do block
04:09:40 <EvanR> so use allocaBytes as punishment
04:09:49 <funfunctor> lol
04:10:00 <tdammers> LIBERATE ALL THE BYTES!
04:10:11 <EvanR> let my bytes go
04:10:14 <funfunctor> I didn't forget I know I should be using allocaBytes
04:10:42 <EvanR> there are ways to do it without another inner do block, but why would you want to avoid that
04:11:19 <EvanR> (in this case it would be the first inner do block)
04:11:23 <funfunctor> EvanR: idk, whenever I touch it, it comes out more messy looking
04:12:12 <funfunctor> do you mind annotating it?
04:12:27 <EvanR> also ByteString and the magic number 4 might not be the best
04:12:46 <EvanR> a vector of Complex16 or something
04:13:06 <funfunctor> well this is my concern..
04:13:14 <funfunctor> I can't get this right in my mind..
04:13:43 <EvanR> make a type Complex16 and make it Storable
04:14:00 <EvanR> then use a Vector.Storable
04:14:10 <funfunctor> I was looking for http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Complex.html Complex16
04:14:13 <funfunctor> you mean make it
04:14:30 <funfunctor> hmm, need to research this..
04:14:46 <EvanR> maybe start by writing the Num and Fractional instances
04:15:47 <EvanR> if thats more work than youre willing to go through, Word16s
04:16:10 <funfunctor> well its very hard to test it "works" without a reasonable amount of code on top..
04:16:25 <EvanR> no way
04:16:26 <funfunctor> how do you know the radio data means anything..
04:16:34 <Elision> kqr: yeah I have some of those... plus the "this provided code isn't really idiomatic so here's my wrapper to make it nicer" functions
04:16:41 <EvanR> you can test new types with ghci
04:17:02 <funfunctor> oh sorry, thats what you mean by test ok :)
04:17:04 <EvanR> radio data meaning anything comes after complex numbers adding correctly
04:17:17 <EvanR> and storing / unstoring correctly
04:17:31 <funfunctor> am I looking in the right place? http://hackage.haskell.org/package/storablevector-0.2.10/docs/Data-StorableVector.html
04:17:45 <EvanR> i dont think so
04:17:59 <EvanR> Data.Vector.Storable
04:29:35 <EvanR> funfunctor: i found a package which has a arithmetic type for this
04:32:33 <bloot> catch is lazy?
04:34:16 <EvanR> funfunctor: Data.Fixed.Binary seems to be a package to do binary fixed point stuff, which is what the components of those complex numbers are
04:34:28 <bloot> defs <- liftIO $ catch (return $ runParserWithString parseDefs q "<<SHELL>>") (\(e :: SomeException) -> return [])
04:34:37 <bloot> it seems that parser errors aren't catched by this *just yet*
04:35:06 <EvanR> is it throwing at exception at all?
04:35:08 <EvanR> an
04:35:25 <bloot> yes
04:35:28 <EvanR> :t runParserWithString
04:35:29 <lambdabot> Not in scope: ‘runParserWithString’
04:35:31 <bloot> it get's catched in a catch later on
04:36:02 <bloot> http://codepad.org/wemGN0bI
04:36:13 <bloot> the second catch catches the parse error
04:36:18 <exio4> catch (return (..)), are you catching something an error/undefined?
04:36:18 <EvanR> what exception is it?
04:36:19 <bloot> the first one doesn't.
04:36:25 <grohne> hi. can someone help me translate this cabal error to english? http://lpaste.net/121535 In particular, why does ghc-7.8.3 conflict with a recent cabal?
04:36:31 <bloot> I'm not sure what parsec uses for an Exception
04:36:42 <EvanR> why are you trying to use exceptions with parsec?
04:36:53 <mniip> what was the name of the operator
04:36:59 <mniip> basically a shortcut for fmap.const
04:37:07 <EvanR> <$
04:37:12 <mniip> thanks
04:37:25 <hodapp> someone hit me with a 2x4 until I understand type families.
04:37:26 <bloot> EvanR: because I want to know if parse failed?
04:37:38 <exio4> bloot: it doesn't use exceptions
04:37:45 <bloot> it uses error
04:37:53 <bloot> most likely
04:37:58 <EvanR> since its a pure function look at the Either result or whatever type its exporting for that
04:38:04 <EvanR> it mostly likely does not use error
04:38:22 <bloot> fwiw I *can* catch whatever parsec raises
04:38:27 <bloot> the second catch does
04:38:41 <EvanR> dont catch error
04:38:46 <EvanR> even if thats what its throwing
04:38:55 <bloot> "ERROR: (line 1, column 9):"
04:38:58 <bloot> that's what parsec does
04:39:18 <exio4> where is "runParserWithString" defined?
04:39:29 <bloot> right
04:39:29 <bloot> ok
04:39:33 <EvanR> bloot: what is the type of runParserWithString
04:39:39 <bloot> so error can't be catched "for sure"?
04:39:55 <exio4> bloot: no, it doesn't, runParser returns an Either, not an exception, an error, or anything
04:39:56 <bloot> probably only if it's in I/O?
04:40:00 <bloot> exio4: I know
04:40:12 <EvanR> dont use error for exception handling
04:40:29 <EvanR> use a real exception if you want to throw an exception
04:40:50 <EvanR> and for pure parsers use Either
04:41:12 <exio4> exceptions should be things that really mean something bad happen, too
04:42:53 <hodapp> take a look at how some Java libraries use exceptions for all sorts of very non-exceptional behavior, and basically just to get a different kind of flow control.
04:42:56 <hodapp> now do the opposite.
04:43:18 <tdammers> hodapp: s/Java/Python/;s/some/all/
04:43:31 * EvanR ruby too
04:43:33 <kaiyin> is ghc's slow compiling speed due to the fact that it is written in haskell itself?
04:43:40 <hodapp> tdammers: I wasn't aware of Python, or general Java libraries, abusing it this badly.
04:44:20 <Axman6> kaiyin: it does a lot of pretty intense optimisations; it also hasn't really been written to be particularly fast. correctness >>> speed
04:44:59 <kaiyin> ok
04:45:41 * hackagebot entropy 0.3.6 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.6 (ThomasDuBuisson)
04:45:56 <Axman6> compiler speed isn't really a very import thing most of the time, especially when you also have a decent interpreter and/or repl, which we do have
04:46:41 <akegalj> how can i inspect if some structure has been evaluated in ghci (like has thunk been evaluated) ?
04:47:14 <hodapp> I'm using Haskell for code generation (of C code), and the short version is that the C code almost always takes longer than the Haskell to build.
04:47:29 <hodapp> though the numbers of Haskell files and C files are roughly the same
04:47:38 <Axman6> hodapp: what're you using it for?
04:47:51 <EvanR> number of files... size of files... content of files...
04:48:00 <hodapp> Axman6: targeting an embedded system where I have very little room for decent runtime abstraction
04:48:20 <Axman6> fun =) copilot? or something else?
04:48:28 <hodapp> EvanR: the number, size, and content of files tends to be tied to the comparable figure for the Haskell.
04:48:30 <Cale> akegalj: You can try :print x  which should print what it can without evaluating
04:48:54 <hodapp> Axman6: Atom & Ivory, but looking at Copilot because Atom is a bit old and has received no updates
04:49:31 <tdammers> hodapp: no, but Python takes "use exceptions for control flow" and turns it into a religion called "EAFTP"
04:49:42 <hodapp> er, what?
04:49:47 <Axman6> yeah I remember thinking ivory looked like a nice successor. I think there are some people using where I work on a project with galois
04:50:17 <Axman6> tdammers: Exceptions: Always Fuck the Programmer?
04:50:18 <hodapp> Ivory's not so much a successor; it's a much more general EDSL than Copilot
04:50:27 <tdammers> if item in dict: return dict[item]; else return Null # no no no, this isn't pythonic™
04:50:29 <frerich> Cale, akegalj: I think you meant 'sprint'
04:50:37 <EvanR> tdammers: unable to decomplect that acronym
04:50:45 <tdammers> try: return dict[item]; except KeyError: return None
04:50:48 <tdammers> # better :P
04:50:49 <akegalj> Cale: no, i was looking for ":sprint", but your answer brought me to this. thnx
04:50:50 <Cale> frerich: I think both :print and :sprint don't evaluate
04:50:51 <hodapp> EvanR: actually: 4476 lines of Haskell, 1704 lines of C, as of now.
04:50:58 <tdammers> EvanR: Easier to Ask Forgiveness Than Permission
04:51:02 <EvanR> ah
04:51:09 <Cale> akegalj: If you want more detailed information, there's a library called vacuum
04:51:17 <tdammers> the whole language is optimized around this clusterfuck
04:51:22 <Axman6> tdammers: that's horrible :(
04:51:26 <EvanR> tdammers: so basically throw copious exceptions and let somebody else figure out to catch them
04:51:38 <hodapp> Axman6: but Ivory is very nice, albeit fairly young and needs better docs
04:51:38 <tdammers> sort of
04:51:43 <akegalj> frerich: thankx
04:51:47 <Cale> akegalj: which you can use to inspect things like the closure type and info table of something
04:51:55 <tdammers> except that you are supposed to figure out when and how to handle them
04:52:03 <tdammers> but there is nothing to remind you
04:52:03 <akegalj> Cale: thanks, ill look into it
04:52:13 <hodapp> Axman6: it's been something like a cross between a code generation framework like Cog, but with actual type-safety, and the template system in C++, but not a royal horrid clusterfuck.
04:52:19 <EvanR> tdammers: sounds like GOTO
04:52:20 <frerich> Cale: Indeed, I stand corrected - I never realized that 'print' doesn't evaluate... in fact, I almost like 'print' better because it seems it also prints the types
04:52:26 <frerich> Cale: Thanks :)
04:52:30 <tdammers> EvanR: pretty close, yeah... at least GOTO is explicit
04:52:41 <EvanR> frerich: you can enable printing of the type by default
04:53:13 <tdammers> exceptions, by contrast, are completely implicit - maybe the author documented them, but more often than not, you just have to hope for the best and test the living shit out of your code
04:58:24 <kaiyin> > tail []
04:58:26 <lambdabot>  *Exception: Prelude.tail: empty list
05:00:01 <EvanR> *Exception: the door is ajar
05:00:02 <kqr> tdammers, d.get('item') is even more pythonic than the try except thing
05:00:09 <kqr> tdammers, if that's the behaviour you want
05:00:16 <grohne> why would ghc depend on a particular version of Cabal?
05:00:44 <Axman6> grohne: they're pretty closely tied
05:02:44 <grohne> Axman6: ok. so I need to upgrade ghc if I need a more recent Cabal? is that correct?
05:02:47 * frerich thinks people calling the way exceptions are used in Python 'gross' would also consider it gross how it's impolite to refuse a Vodka in russian. Or how 'merkins tend to suggest they want to meet you for dinner but don't actually expect you to show up. I think it's just a cultural thing. :)
05:05:25 <EvanR> frerich: gross
05:05:34 <bloot> wtf
05:05:37 <bloot> somethin still calls error :(
05:05:52 <EvanR> grep -r error
05:08:33 <byorgey> grohne: no, you don't
05:08:41 <byorgey> grohne: you can have multiple versions of Cabal installed
05:09:58 <bloot> ow. a show instance
05:10:05 <bloot> throws error
05:10:06 <bloot> alright
05:10:09 <bloot> that explains a lot :D
05:14:15 <kstt> Hi ! What is the current state of things regarding record field names please ? I am in a situation where being able to use the same field name in various records would be much appreciated.
05:15:04 <kstt> At first glance, it looks like a totally unambiguous situation.
05:15:14 <kstt> (in my specific case of course)
05:15:30 <grohne> byorgey: I tried that, but that generates warnings at cabal configure and fails build because Distribution.TestSuite.Test != Distribution.TestSuite.QuickCheck.Test
05:16:24 <EvanR> kstt: except that without QualifiedNames.something, all functions are in the same namespace
05:16:43 <EvanR> myFoo myFoo and myFoo would all be in the same namespace
05:16:54 <jameseb> kstt: you can't have more than one function with the same name defined, even if the types are different
05:17:06 <Axman6> that should be changing in a future version of ghc with type directed name resolution
05:17:06 <kqr> EvanR, jameseb https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
05:17:09 <kqr> yeah
05:17:26 <EvanR> you can say that they can have different types
05:17:30 <EvanR> but then type inference ...
05:17:45 <EvanR> idris is attempting to do something like that
05:17:53 <kstt> Indeed EvanR. But since this is a weakness in Haskell records, I hope that something (a ghc extension ?) can improve the situation.
05:18:05 <kstt> thank you kqr !
05:18:18 <Drup> hi, are there accelerate people around ?
05:18:28 <Axman6> ttps://wiki.haskell.org/TypeDirectedNameResolution
05:18:30 <Drup> I have a question about http://www.cse.unsw.edu.au/~chak/papers/acc-llvm.pdf and their gadt ssq representation
05:18:38 <Drup> ssa*
05:18:38 <EvanR> theres a few record libs out there that try to fix this problem, but i havent really run into a problem with it
05:18:46 <EvanR> maybe i dont use lots of records with lots of fields
05:18:52 <kstt> Haskell records should be entirely revisited sometime. They are not on par with the rest of the design.
05:19:03 <kqr> I agree
05:19:09 <Axman6> Drup: benl23 might be able to get you in touch with the right people. chak isn't on IRC much these days
05:19:09 <kqr> especially the syntax
05:19:12 <kqr> the syntax can burn in hell
05:19:25 <EvanR> the syntax and haskell records isnt going to be vastly improved just by changing the field naming thing
05:19:40 <kqr> nah
05:19:42 <kqr> not at all
05:19:42 <EvanR> its possible to have extensive systems of record typing
05:19:51 <kqr> fortunately I can just import a lens library and ignore the syntax
05:19:51 <EvanR> haskell doesnt do it
05:20:28 <Drup> Axman6: thanks, will wait for a pong then
05:20:48 <mauke\> kstt: http://nikita-volkov.github.io/record/
05:20:49 <EvanR> and where people would use numerous giant records types in other languages they use basically Data.Map Text Dynamic
05:20:55 <Axman6> Drup: might be a long time; you can probably find chak's email somewhere (possibly in that pdf?)
05:21:15 <funfunctor> EvanR: I'm on a little overload here.. where am I starting with all this Complex16 stuff?
05:21:19 <EvanR> and haskell supports that
05:21:24 <Axman6> EvanR: or Map (Either Int String) Dynamic =)
05:21:32 <EvanR> Axman6: or Data.PHP
05:21:44 <Axman6> heh, that was pretty much what I was thinking of
05:21:45 <Drup> yes, I'm not in a hurry though, and email is not optimal for lively discussion.
05:21:51 <Axman6> is that an actual thing?
05:21:56 <EvanR> funfunctor: maybe just start with storable vector of Word32
05:22:05 <EvanR> Axman6: i think theres one in acme
05:22:41 <kstt> mauke: interesting proposal, although I'm a bit reluctant to use TH so intrusively.
05:24:55 <kstt> mauke\: this is the behaviour I'd expect from a records update. Hope this gets into GHC as an extension, without QQ custom syntax, with "record Foo = ..."
05:25:34 <mauke\> that wouldn't work
05:25:45 <mauke\> type Foo = record {...} maybe
05:28:14 <EvanR> earlier i experienced an interesting behavior of concurrent haskell
05:29:13 <EvanR> when a Handle is garbage collected, it is closed
05:29:24 <noir> .
05:29:38 <EvanR> the program on the other side of pipe responded by exiting, which closed its other file handle which i was reading
05:29:45 <EvanR> which ended my program ;)
05:29:55 <EvanR> interesting because this happened later
05:30:19 <EvanR> made a keep alive thread
05:31:13 <mauke\> yeah, writing to a closed pipe triggers SIGPIPE by default
05:31:23 <EvanR> and then theres that
05:32:14 <SonLevi> can I ask a stupid question? http://pastebin.com/ZkSUd1nL this thing seems like it should be pretty straightforward but it fails on runtime, not sure what's going wrong
05:32:28 <mauke\> it's a cute way to emulate lazy evaluation with pipes
05:32:49 <mauke\> SonLevi: what does it do?
05:33:51 <SonLevi> it's suppose to take some number of lines of input from stdin, ignore the first line and sum up the rest of the lines
05:33:58 <mauke\> SonLevi: what does it do?
05:34:08 <SonLevi> where x++ becomes 1 and x-- becomes -1
05:34:12 <mauke\> SonLevi: what does it do?
05:34:50 <EvanR> SonLevi: yes you can ask a question ;)
05:35:05 * EvanR problem solved
05:35:14 <mauke\> nice
05:35:23 <mauke\> EvanR++
05:35:47 <lyxia> SonLevi: What does your input look like?
05:36:42 <ibid> SonLevi: what's the error?
05:36:52 <SonLevi> something like "5\nX++\n++X\n--X\nX--\nX++" in which case the output should be 1
05:37:01 <mauke\> SonLevi: HELLO
05:37:08 <SonLevi> well it compiles fine, but when I execute it, it simply gives no output
05:37:20 <mauke\> how are you running it?
05:37:24 <SonLevi> in ghci
05:37:29 <mauke\> go on
05:37:49 <Axman6> I can't imagine getContents working well in ghci...
05:38:01 <ibid> SonLevi: try with runghc?
05:38:05 <mauke\> well, it'll just keep reading and reading and reading ...
05:38:18 <SonLevi> I see
05:39:11 <ibid> hah, ran runghc without arguments, and gave it Ctrl-D.  result:
05:39:12 <ibid> /tmp/runghcXXXX12114.hs:1:33: Not in scope: `main' Perhaps you meant `min' (imported from Prelude)
05:39:13 <Drup> Is it possible to find users/uses in llvm-general without building the table yourself ?
05:39:16 <ibid> :D
05:40:13 <hnfmr> I am having trouble calling a C function from Haskell which prints a string and a number, the string part of the output is garbled,,(random text)
05:40:42 <mauke\> what's the C code, what's the Haskell code?
05:40:46 <hnfmr> the C function: void test(foo_t* foo) { printf("%s %d\n", foo->name, foo->num); }
05:41:03 <hnfmr> foo_t is a struct { char name[10]; int num; };
05:41:15 <hnfmr> the relevant haskell code:
05:41:19 <EvanR> come on theres no num instance for Num a => (a,a)
05:41:27 <hnfmr> test :: String -> Int -> IO ()                                                                                               |~                                                                                                                                 34 test name num =                                                                                                              |~
05:41:29 <hnfmr> sorry
05:41:35 <mauke\> hnfmr: /topic
05:41:40 <Axman6> use lpaste please
05:41:44 <EvanR> i guess abs makes no sense among other things
05:41:57 <Axman6> never paste code into irc channels unless you want to be yelled at
05:42:14 <hnfmr> sorry
05:43:17 <Axman6> well, never more than a single line anyway
05:43:36 <hnfmr> basically the haskell code: test :: String -> Int -> IO ()
05:43:40 <hnfmr> the definition: alloca $ \foo -> do { nm <- newCString name; poke foo (fromIntegral num)); c_test f }
05:44:15 <hnfmr> poke foo (Foo nm (fromIntegral num))
05:44:29 <hnfmr> Foo is the haskell Storable, which maps to C foo_t struct
05:44:41 <mauke\> hnfmr: stop paraphrasing and show us the code
05:45:12 <hnfmr> 1 sec i am going to paste to gist
05:45:23 <mauke\> (the "relevant haskell code" would be the Storable instance and the c_test declaration)
05:45:29 <mauke\> but seeing everything is even better
05:46:56 <hnfmr> https://gist.github.com/hnfmr/f8da628fde6ae957108b
05:47:27 <hnfmr> appreciate your help
05:47:35 <mauke\> that's not the source code
05:47:43 <mauke\> that's a file generated by hsc2hs
05:47:58 <mauke\> oh, there's more below
05:48:09 <mauke\> heh
05:48:10 <hnfmr> there are 4 files. hsc, hs, h, c
05:48:26 <mauke\> "#let alignment", old friend! haven't seen you in a while
05:48:34 <mauke\> (I invented that)
05:48:55 <hnfmr> wow, great to know :)
05:49:16 <mauke\> your Storable instance is wrong
05:49:38 <mauke\> it's written for typedef struct { char *name; int num; } foo_t;
05:49:43 <mauke\> but your name is not a pointer
05:50:01 <hnfmr> yes
05:50:18 <hnfmr> argh.
05:50:30 <hnfmr> I should use Ptr CString..
05:50:38 <hnfmr> is this correct?
05:50:43 <mauke\> that would be char **name
05:50:44 * hackagebot fay 0.23.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.0 (AdamBergmark)
05:50:49 <mauke\> CString = Ptr CChar
05:52:04 <mauke\> if you really want to have an array in your struct, you need to do some manual work
05:52:21 <hnfmr> char name[10] is equivalent to char **name, I guess?
05:52:40 <mauke\> no
05:52:43 <mauke\> not at all
05:53:03 <mauke\> char [10] is an array, char ** is a pointer to a pointer
05:53:39 <hnfmr> I get the point, it's a char array
05:54:27 <hnfmr> thank you mauke\
05:54:47 <yac> I want to catch an IOError and add an explanation like "Coudl not initialize applications working directory". Now I can catchIOError but how do I add the information to the IOError so it's information is not lost?
05:56:15 <yac> oh maybe modifyIOError and ioe{Get.Set}ErrorString
05:56:30 <EvanR> what, throw your own error or dont use an error after catching
05:57:52 <mniip> can I somehow make show stop rendering some characters as \1234 codes?
05:58:11 <EvanR> no use something besides show
05:58:27 <mauke\> hnfmr: poke p (Foo name num) = do pokeArray0 0 ((#ptr foo_t, name) p) (map castCharToCChar (take 9 name)); (#poke foo_t, num) p num
05:58:27 <EvanR> i think ghci has an option for that
05:58:29 <mauke\> untested
06:00:24 <mauke\> hnfmr: peek p = do nm <- map castCCharToChar <$> peekArray0 0 ((#ptr foo_t, name) p); nb <- (#peek foo_t, num) p; return Foo nm nb
06:00:27 <mauke\> equally untested :-)
06:00:48 <mauke\> hnfmr: oh, this assumes Foo { name :: String }
06:02:21 <EvanR> :t (:+:)
06:02:22 <lambdabot>     Not in scope: data constructor ‘:+:’
06:02:22 <lambdabot>     Perhaps you meant ‘:+’ (imported from Data.Complex)
06:02:33 <EvanR> cant seem to use the symbol :+:
06:02:55 <merijn> EvanR: From where?
06:03:08 <EvanR> (:+:) :: R2 -> R2 -> R2
06:03:30 <EvanR> i think its a type level thing now
06:04:27 <tomqq> hey all, pretty nooby question in reading type signatures.. how do you get from the foldr type signature (a -> b -> b) -> b -> [a] -> b and the ($) type signature (a -> b) -> a -> b to the (foldr ($)) type signature b -> [b ->b] -> b ? By, I assume, direct substitution of types when applying ($) to foldr ? :S
06:04:28 <EvanR> Invalid type signature: (:+:) :: R2 -> R2 -> R2
06:04:39 <EvanR> Should be of form <variable> :: <type>
06:04:52 <EvanR> oh i need to declare it first
06:05:09 <shachaf> By unification, but you should rename the types for clarity here.
06:05:22 <hnfmr> mauke\: I tested it, your code snippets work! THanks. It's good to know array needs more manual work in this regard!
06:05:31 <shachaf> foldr :: (a -> b -> b) -> b -> [a] -> b; ($) :: (c -> d) -> c -> d
06:06:04 <shachaf> In foldr ($), (a -> (b -> b)) must be the same type as (c -> d)
06:06:15 <shachaf> Er.
06:06:19 <shachaf> In foldr ($), (a -> (b -> b)) must be the same type as (c -> d) -> c -> d
06:06:53 <shachaf> So a = (c -> d), and (b -> b) = (c -> d), so b=c and b=d
06:06:54 <shachaf> And so on.
06:07:32 <akegalj> If I have Data.Vector structure of size N. What is the cost of changing one element? Can I do it in-place, thus avoiding unecessary garbage to be produced?
06:08:03 <shachaf> If you use a mutable vector.
06:08:26 <tomqq> @shachaf thanks :)
06:08:26 <lambdabot> Unknown command, try @list
06:09:31 <akegalj> shachaf: oh, ok
06:09:57 <jtanguy> oh lambdabot understands type holes, that's nice
06:10:01 <tomqq> shachaf: thanks :)
06:10:25 <shachaf> GHC doesn't have type holes last I heard.
06:10:45 <jtanguy> > foldr _foo  :: b -> [b -> b] -> b
06:10:46 <lambdabot>  Found hole ‘_foo’ with type: (b1 -> b1) -> b1 -> b1
06:10:46 <lambdabot>  Where: ‘b1’ is a rigid type variable bound by
06:10:46 <lambdabot>              an expression type signature: b1 -> [b1 -> b1] -> b1
06:11:14 <shachaf> That's a hole, but I don't see how the word "type" enters the picture.
06:11:17 <shachaf> It's a value hole.
06:11:19 <kaiyin> Does/will haskell support this kind of syntax, it looks more close to math equations. http://youtu.be/fQU99SJdWGY?t=7m26s
06:12:10 <shachaf> That frame describes a whole bunch of kinds of syntax.
06:12:16 <mauke\> miranda
06:12:36 <quchen2> shachaf: It used to be called "-XTypeHoles" during development for some reason.
06:12:41 <jtanguy> i meant typed hole. I mixed that with the name of the ghc extension TypeHoles
06:12:48 <clrnd> lol
06:12:57 <shachaf> Yes, people have been calling it that for a long time for some reason.
06:13:15 <shachaf> It's never made sense to me. It's one of those things.
06:13:35 <mauke\> kaiyin: http://freaknet.org/martin/libri/Miranda/Overview.html#Guard
06:13:40 <mauke\> and haskell doesn't support that
06:15:45 * hackagebot haste-compiler 0.4.4.4 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.4.4 (AntonEkblad)
06:18:12 <vin-ivar> hello folks
06:18:17 <vin-ivar> I can't seem to install IHaskell
06:18:24 <vin-ivar> I get an Error
06:18:27 <vin-ivar> TM
06:18:35 <quchen2> Did augur post anywhere about his problem with "_" for partial type sigs?
06:18:43 <quchen2> I haven't heard of it for some time now
06:18:45 <clrnd> @where lpaste
06:18:45 <lambdabot> http://lpaste.net/
06:18:48 <vin-ivar> to be precise, Couldn't match type `UniqFM.UniqFM TyVar' with `[Var.Var]'
06:21:21 <simg> hi. postgres-simple question: can anyone point me in the right direction for getting results with more than 10 columns?
06:22:31 <tdammers> :t (1,2,3,4,5,6,7,8,9,10,11)
06:22:32 <lambdabot> (Num t10, Num t9, Num t8, Num t7, Num t6, Num t5, Num t4, Num t3, Num t2, Num t1, Num t) => (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)
06:22:37 <tdammers> like that
06:22:53 <tdammers> getting data out of such tuples can be a bit tricky though
06:23:07 <EvanR> poor database with more than ten columns :(
06:23:16 <grohne> what do I do if "cabal test" fails with a linker error and the unresolved symbols clearly should be in my source tree and it did compile those modules?
06:23:30 <grohne> (not sure if pasting the error is useful)
06:23:31 <tdammers> EvanR: you mean you should always normalize to the point where every table has exactly one non-key column?
06:23:41 <tdammers> (or zero)
06:23:42 <EvanR> no ten is just a lot
06:23:49 <tdammers> pfff
06:23:56 <tdammers> you've never done enterprise programming then
06:23:59 <tomqq> shachaf: so after applying ($) you would have (foldr ($)) :: c -> [c -> d] -> d ? and because b = c and b = d I see (foldr ($)) :: b -> [b -> b] -> b ?
06:24:05 <EvanR> thats why im saying its a lot
06:24:18 <EvanR> 65536 columns is stupid
06:24:25 <speak> EvanR: I've seen ones with about 30, and all columns had 4 letter all-caps names (legacy on legacy)
06:25:41 <tdammers> http://stackoverflow.com/questions/26742040/what-is-the-maximum-upper-limit-on-number-of-columns-in-a-sql-server-view
06:25:51 <tdammers> "And I need more than 14K columns in my view to write where clause."
06:26:22 <EvanR> this isnt making me feel better
06:26:27 <tdammers> all the way, the correct answer is "if you need to ask, you're doing it wrong"
06:26:30 <clrnd> @djinn (a -> b) -> a -> b
06:26:30 <lambdabot> f a = a
06:26:35 <clrnd> narendraj9, ^
06:26:50 <clrnd> @djinn (a -> b) -> c -> c a
06:26:51 <lambdabot> Error: kind error: (KArrow (KVar 0) (KVar 3),KVar 2)
06:32:37 <EvanR> > range ((0,0),(3,3))
06:32:39 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
06:34:25 <akegalj> Is this O(N)?    (!2) . Data.Vector.map (+1) . Data.Vector.enumFromTo 0 N
06:42:38 <Taneb> Hmm, cabal update is giving "cabal: <file descriptor: 9>: permission denied"
06:43:50 <dcoutts> Taneb: hmm, that's an odd one
06:44:15 <hexagoxel> grohne: expose more modules?
06:44:23 <frerich> akegalj: Yes
06:44:28 <simg> EvanR: sry. afk. 10 database columns is a lot, are you serious ??
06:44:33 <hexagoxel> /other-modules
06:44:47 * EvanR asks simg if he is serious
06:45:07 <simg> yes, of coure !
06:45:11 <EvanR> k
06:45:15 <simg> *course
06:45:52 <simg> firstly, why wouldn't I have 100 columns in a db. real world entities can *easily* be this complicated ?
06:46:11 <EvanR> how many are NULL on a given day
06:46:28 * frerich suspects this is a bit offtopic
06:46:46 <merijn> Can we move the database normalisation discussion somewhere else?
06:46:48 * EvanR throws an olap cube at simg </offtopic>
06:47:00 <noir> since when are 10 columns a lot? i used to seeing a lot around 100
06:47:04 <kqr> 10 db coloumns is nothing
06:47:50 <EvanR> confusing not a lot with commonplace and terrible
06:48:14 <grohne> hexagoxel: afaik modules can only be exposed from libraries. there is no library
06:50:05 <grohne> hexagoxel: and even if I add a library an expose the relevant module, the linker error persists
06:50:12 <thomassgn> not sure if this is a problem with emacs/flycheck or some haskell/cabal thing, but i get 'Suspicious state from syntax checker haskell-ghc: Checker haskell-ghc returned non-zero exit code 1, but no errors from output: ghc: can't find a package database at /home/.../.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d' on a x86_64-linux machine. Anyone seen this before? I guess there is a part somewhere in the
06:50:14 <thomassgn> chain that makes an incorrect guess for my computer architecture++. Maybe there is a setting somewhere I can change?
06:50:20 <hexagoxel> grohne: show the .cabal file?
06:50:49 <grohne> hexagoxel: http://lpaste.net/121540
06:51:18 <grohne> hexagoxel: this one is without library and exposed modules as it didn't make a difference
06:51:20 <dcoutts> thomassgn: perhaps the error message is right, and the package db in that sandbox is indeed missing?
06:53:13 <thomassgn> dcoutts: there is no path on my computer containing 'x86_64-osx' so it is indeed a correct error message.
06:53:23 <Matt__> does  hackage stand for "Haskell package" ?
06:54:07 <jtanguy> Taneb: did you check in your .cabal/packages/hackage.haskell.org the permissions of the 00-index* files?
06:54:12 <EvanR> or Hacked Cabbage
06:54:24 <dcoutts> thomassgn: I presume the path is not literally "/home/.../.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d", and the ... bit is something
06:54:37 <thomassgn> dcoutts: yes
06:54:40 <dcoutts> thomassgn: in which case you can look at that, perhaps you deleted the sandbox?
06:54:52 <dcoutts> but not the sandbox config file
06:54:53 <grohne> hexagoxel: anything else I could try (after exposing modules)?
06:54:54 <hexagoxel> grohne: ah, but you have almost no build-depends in your test-suite
06:55:05 <dcoutts> thomassgn: and so now it cannot find any of its files
06:55:09 <hexagoxel> grohne: copy the build-depends from your executable to the test-suite
06:55:14 <thomassgn> dcoutts: that's not the problem
06:55:50 <grohne> hexagoxel: I tried that earlier. no difference. the missing symbols are from the Syntax.Name module which is part of igor2
06:56:17 <hexagoxel> grohne: how about copying the ghc-options as well?
06:56:33 <hexagoxel> (wild guessing mode engaged)
06:56:59 <grohne> hexagoxel: no change
06:57:15 <thomassgn> dcoutts: the problem is that for some reason it wants stuff from x86_64-osx i.e. osx. this computer has nothing remotely connected to apple/osx on it. I have a working '.../.cabal-sandbox/x86_64-linux-ghc.../' bit
06:57:15 <grohne> hexagoxel: wild guessing appreciated. I'm in that mode for an hour now.
06:57:24 <simg> tdammers: thx, not sure that helps. I think I need to create a fromRow instance for a ~12 element tuple (and/or) record?
06:57:36 <ThreeOfEight> Hallo, I'm struggling with the void type in Haskell. I want to do something like this: http://lpaste.net/121542
06:58:15 <dcoutts> thomassgn: oh, ok, that's odd then. Is flymake just doing the wrong thing then, baking in OSX paths and ghc to look at a those?
06:58:40 <grohne> hexagoxel: could it be due to the fact that I am locked to Cabal 1.18.0.8 by ghc rpm?
06:58:46 <ThreeOfEight> I tried a case analysis like "lessZeroImpossible ZLessS = …", but first of all, I couldn't write anything on the right-hand side, and second, GHC complains about "Inaccessible code"
06:58:53 <thomassgn> dcoutts: it might. Maybe that's a better place to look.
07:00:14 <tdammers> simg: yes
07:00:36 <tdammers> everything up to 10-tuples has an instance, but beyond that, you'll have to implement your own
07:01:03 <tdammers> but at this point, I'd go with a different representation for your rows, other than tuples
07:01:38 <tdammers> list or vector, if you want something homogenic, or a proper custom type with its own FromRow instance
07:01:51 <hexagoxel> grohne: no idea, but feels unlikely. the package is not published, is it?
07:02:01 <thebnq> ThreeOfEight: I can't think of a way to do that directly, and i'm not sure if this is sound, but you can use an empty case
07:04:16 <grohne> hexagoxel: the package (without test suite) is available at darcs clone http://www.cs.uni-bonn.de/~grohne/darcs/igor2/
07:05:15 <grohne> hexagoxel: the original developers seem to have vanished, I'm just trying to use it.
07:05:23 <thebnq> ThreeOfEight: ok nvm its no good, EmptyCase just lets any empty case typecheck
07:07:22 <grohne> hexagoxel: for the test suite a file with "tests = return []" and using any symbol from any other module will do to reproduce the error
07:09:54 <simg> tdammers: thx, I think you may have cleared up a misconception that I've had. if I create a custom type / fromRow instance, then there *isn't* a 10 column limit?
07:10:13 <tdammers> simg: there is no 10-column limit at all
07:10:31 <tdammers> simg: the developers just didn't implement suitable instances for tuples larger than 10
07:10:45 <tdammers> simg: remember that (a, b) and (a, b, c) are completely separate types
07:10:47 <ThreeOfEight> thebnq: yes, EmptyCase now complains about non-exhaustive pattern matches
07:12:14 <simg> tdammers. ah, ok, I get it. thx :)
07:12:51 <grohne> hexagoxel: are you trying to reproduce it?
07:12:53 <thebnq> ThreeOfEight: Even with the -XEmptyCase?
07:13:14 <hexagoxel> grohne: yes
07:13:21 <grohne> hexagoxel: cool. thanks \o/
07:15:42 <ThreeOfEight> thebnq: yes
07:16:29 <thebnq> weird, checks for me
07:18:35 <ThreeOfEight> thebnq: GHC version? I have 7.8.3.
07:18:41 <ThreeOfEight> It type-checks, yes
07:18:48 <ThreeOfEight> but with -Wall, I still get non-exhaustive pattern matches
07:20:05 <ThreeOfEight> oh, wait...
07:20:10 <thebnq> ThreeOfEight: 7.8.3 too, and -Wall
07:20:45 <grohne> hexagoxel: running into unrelated issues or just long build time?
07:21:11 <hexagoxel> just build time, fresh sandbox (of course :)
07:21:29 <grohne> haskell-src-exts can take some time
07:21:37 <thebnq> but foo x = case x of {} :: a -> b   checks fine for me, i'm not sure if this is right
07:21:48 <ThreeOfEight> thebnq: ah, yes, got it
07:21:52 <ThreeOfEight> the warning was actually something else
07:21:54 <ThreeOfEight> I'm an idiot
07:21:59 <ThreeOfEight> thanks, I didn't know about EmptyCase
07:22:37 <thebnq> it appears to just allow any empty case though
07:22:46 <ThreeOfEight> What do you mean by that?
07:23:25 <ThreeOfEight> ah, I see
07:23:28 <ThreeOfEight> that is a bit odd
07:24:40 <ThreeOfEight> Is this a bug?
07:25:01 <ThreeOfEight> This enables you to write non-exhaustive patterns without the compiler warning about non-exhaustive patterns
07:25:12 <ThreeOfEight> I thought the point of the empty case statement was precisely to avoid this kind of thing
07:25:37 <merijn> ThreeOfEight: How would an empty case statement prevent non-exhaustive patterns?
07:26:20 <merijn> ThreeOfEight: Oh, wait, you're doing GADTs and GHC isn't smart enough to see you've handled all possible cases, is that the problem?
07:26:42 <geekosaur> afaik that's in progress?
07:26:48 <merijn> geekosaur: Yes
07:27:01 <merijn> But George's work didn't make it into 7.19 :(
07:27:02 <merijn> eh
07:27:03 <ThreeOfEight> merijn: yes
07:27:04 <merijn> 7.10
07:27:18 <merijn> ThreeOfEight: The solution is: tough luck, you can't make it do the correct thing (yet)
07:27:27 <geekosaur> iirc it's worse even than that, because that work is itself not handling all cases yet
07:27:31 <geekosaur> just many of them
07:27:44 <merijn> geekosaur: As long as it handles my cases, I'm happy :p
07:27:45 <ThreeOfEight> my context is literally S ~ Z in both cases
07:28:09 <ThreeOfEight> so just writing down any of the patterns leads to "inaccessible code"
07:28:21 <merijn> ThreeOfEight: Write down a blank pattern
07:28:27 <ThreeOfEight> which kind of tells me that the type checker /is/ smart enough to figure out that this is broken
07:28:32 <merijn> "foo _ _ = error "blah""
07:28:46 <ThreeOfEight> yes, I can do that, but then the type system doesn't give me any guarantees
07:28:54 <ThreeOfEight> This is, of course, the obvious workaround
07:28:57 <merijn> ThreeOfEight: It's an issue with the exhaustiveness checker not being smart enough, Tom Schrijvers and George are working on it: http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm.pdf
07:29:03 <ThreeOfEight> I just wanted to know whether there was a type-safe way of doing it
07:29:07 <merijn> ThreeOfEight: But don't expect that before 7.12
07:29:12 <ThreeOfEight> okay, thanks
07:29:15 <merijn> ThreeOfEight: Right, and I repeat: no
07:30:48 <steffen> Lets say I want to parse 0439 into two numbers each using 2 of the 4 supplied digits with attoparsec. If i do 'di1 <- decimal; di2 <- decimal' the first operation will already consume all 4 digits! How can I limit the amount of characters a attoparsec combinator is allowed to consume?
07:31:50 <Darwin226> Hey, why can't I define .., -> or => operators?
07:32:09 <merijn> Darwin226: Because those are reserved symbols
07:32:22 <Darwin226> Why is .. a reserved symbol?
07:32:27 <Darwin226> Oh, right. Lists
07:32:34 <merijn> steffen: decimal parses a number, probably you want to parse a digit instead?
07:32:46 <merijn> Darwin226: Consult the Haskell2010 report for full details :)
07:33:00 <merijn> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
07:33:15 <mauke\> d1 <- digit; d2 <- digit; let di1 = digitToInt d1 * 10 + digitToInt d2
07:33:25 <steffen> merijn: no, I want numbers, so that I could do 'return $ di1 + di2' in the end for example
07:33:52 <merijn> steffen: Writer a number parser that consist of two digit parsers and combining them...
07:34:20 <bnjdlf> a
07:34:21 <steffen> mauke\: mhm, I hoped there was something more convinent.. But thanks
07:34:31 <steffen> and thank you too merijn :)
07:34:34 <Darwin226> Ok. Thanks merijn. I actually saw the report but missed the reserved section
07:36:46 <bnjdlf> Job - Windows C++ GUI Developer. Requirements - 'Master or Phd, +  8+ years of C++ experience, expert knowledge of networking, web development.' -_-
07:37:17 <bnjdlf> I can't tell if some people are serious sometimes
07:39:50 <EvanR> at least 16+ years experience in PHP
07:39:55 <EvanR> no exceptions
07:40:21 <EvanR> 8+ years app development in Swift
07:40:24 <clrnd> javascript
07:40:28 <mauke\> but catchable fatal errors
07:40:36 <Xe> EvanR: wot
07:40:50 <saml>  i have such experience
07:43:03 <bloot> I need an a
07:43:09 <bloot> as in foo :: a -> Integer
07:43:24 <bloot> and unfoo :: Integer -> a
07:43:27 <EvanR> :t toInteger
07:43:28 <lambdabot> Integral a => a -> Integer
07:43:37 <bloot> @djin Integer -> a
07:43:37 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
07:43:39 <EvanR> :t fromInteger
07:43:40 <lambdabot> Num a => Integer -> a
07:43:41 <bloot> @djinn Integer -> a
07:43:41 <lambdabot> Error: Undefined type Integer
07:43:45 <bloot> what
07:43:48 <bloot> @djinn Int -> a
07:43:48 <lambdabot> Error: Undefined type Int
07:43:51 <bloot> ah right.
07:43:59 <bloot> @hoogle Integer -> a
07:44:02 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
07:44:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:44:02 <lambdabot> Prelude id :: a -> a
07:44:04 <EvanR> give me an a
07:44:06 <EvanR> :t undefined
07:44:08 <lambdabot> a
07:44:12 <bloot> unsafeCoerce?
07:44:36 <bloot> > let foo x = (unsafeCoerce x) :: Int in foo 5.0
07:44:37 <lambdabot>  Not in scope: ‘unsafeCoerce’
07:44:40 <bloot> :(
07:44:51 <EvanR> > floor 5.0
07:44:53 <lambdabot>  5
07:45:00 <bloot> EvanR: I meant more like
07:45:05 <bloot> there's the type "a"
07:45:14 <bloot> but is there a value of type "a"
07:45:18 <bloot> ok, there's undefined
07:45:33 <bloot> but I can't compare undefined with anything
07:45:36 <bloot> > undefined == 5
07:45:37 <EvanR> undefined, infinite loops, errors all tend to have any type you want
07:45:37 <lambdabot>  *Exception: Prelude.undefined
07:45:39 <bloot> this should return true
07:45:52 <EvanR> undefined == 5 isnt true at all
07:45:58 <EvanR> its not even false
07:46:02 <bloot> or more technically speaking I need a value that is *everything*
07:46:16 <EvanR> Top type
07:46:17 <clrnd> > () :: Int
07:46:18 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’ with actual type ‘()’
07:46:42 <EvanR> bloot: you want a value that is equal to 5 and 4 at the same time?
07:46:52 <clrnd> something like Dynamic?
07:47:07 <EvanR> wouldnt that break the laws of equivalence relations
07:48:08 <bloot> EvanR: http://codepad.org/3tICMG1P
07:48:14 <bloot> ^- a little bit like that actually
07:48:25 <bloot> Everything is an instance of EVERY class
07:48:33 <EvanR> bloot: () is an instance of a lot of classes
07:48:35 <juanpablo_> Is there a way I can choose not to export instances defined in a module?
07:48:39 <mauke\> bloot: what is that good for?
07:48:58 <EvanR> > compare ()
07:48:59 <lambdabot>  <() -> Ordering>
07:49:01 <EvanR> > compare () ()
07:49:03 <lambdabot>  EQ
07:49:30 <EvanR> for all values a and b of (), a == b
07:51:12 <juanpablo_> I want my instances to be available in that module and in that module only
07:51:35 <juanpablo_> jvilla: ^^^^^
07:52:01 <mauke\> juanpablo_: AFAIK no
07:56:32 <jtanguy> bloot: why would you want such value?
07:57:44 <EvanR> bloot: you cant make a type an instance of every class, for one thing you have kind errors. Num wants a * and Functor wants a * -> *
08:02:19 <byorgey> juanpablo_: no, you cannot choose to not export instances
08:02:28 <bergmark> juanpablo_: don't export the type, only export functions using a type that you can map to your internal one
08:02:39 <juanpablo_> byorgey: is there a reason for that?
08:02:51 <byorgey> juanpablo_: yes, because for consistency instances must be globally unique.
08:03:16 <byorgey> juanpablo_: why do you want some instances to not be exported?
08:03:41 <juanpablo_> byorgey: I want to keep my Arbitrary instances only in the module where they were defined
08:03:56 <byorgey> juanpablo_: why?
08:04:16 <juanpablo_> because I may want to have different Arbitrary instances for other property tests
08:04:29 <EvanR> you cant
08:04:35 <mauke\> newtype it
08:04:41 <byorgey> juanpablo_: right, you shouldn't do that.  The usual approach is to make a newtype wrapper for each different instance you want
08:05:08 <juanpablo_> That sounds like a lot of overhead for something I'm going ot use like twice
08:05:12 <byorgey> juanpablo_: this actually works nicely because pattern-matching on the newtype constructor signals to the compiler which Arbitrary instance you want.
08:05:27 <juanpablo_> But yeah, I think I'm going that way
08:05:32 <byorgey> juanpablo_: e.g. see how QuickCheck itself defines newtype wrappers like Positive
08:05:44 <byorgey> so you can write    myProperty (Positive x) = ... x ...
08:05:55 <byorgey> and then that property will only be tested with positive values for x
08:06:14 <byorgey> it's not actually that much overhead.
08:06:25 <Iceland_jack> You can also use view patterns and write:
08:06:25 <Iceland_jack>     myProperty (abs -> x) = ... x ...
08:06:36 <Iceland_jack> allowing for more bespoke properties
08:07:24 <byorgey> Iceland_jack: that works for positive numbers, but in general there might not be a nice way to take the existing Arbitrary instance and transform values into the range/distribution of values you want
08:07:44 <byorgey> so in the general case it works much better to make a new Arbitrary instance for a newtype
08:09:15 <Iceland_jack> Yes absolutely, I use it quite often for some one-off property
08:09:51 <Iceland_jack> Like if I want even numbers I wouldn't bother creating a newtype, but for more involved examples I would write a new Arbitrary instance or at least a generator
08:11:18 <juanpablo_> Iceland_jack: the viewpatterns idea sounds great
08:12:15 <juanpablo_> Also, is there a way to combine QuickCheck modifiers? I'm sure nesting the newtype is not the way to go lol
08:12:24 <Iceland_jack> An example of the third thing is:
08:12:24 <Iceland_jack> @ty forAll ((*2) <$> arbitrary) (\a -> (a `div` 2) * 2 == a)
08:12:25 <lambdabot> Property
08:12:41 <vandenoever> could someone help me figure out how to resolve a cabal conflict? https://paste.kde.org/pkyyfgwft
08:15:02 <Rotaerk> I've got a few (EitherT e io r) type functions that have to do some kind of cleanup/rollback before returning a left value.  I realized this could perhaps be generalized as a sort of transaction monad, where every action within this monad that succeeds appends to a hidden action sequence for cleaning it up, and when an action fails, that cleanup-action sequence is executed before the left value is returned
08:15:13 <Rotaerk> does anything exist that would accomplish that, yet?
08:15:50 <Rotaerk> (when I say "hidden action sequence", I mean ala the State monad's "hidden" state)
08:16:12 <merijn> Rotaerk: Don't you just want something like bracket and the exceptions library?
08:16:32 <Rotaerk> merijn: bracket handles exceptions; I'm not talking about exceptions but Eithers
08:16:50 <merijn> bracket is just try + finally, not just for exceptions
08:17:56 <Rotaerk> how would it be used for an EitherT e io r?
08:18:13 <Rotaerk> bracket's type doesn't seem to do anything *but* exceptions ...
08:18:32 <ReinH> Rotaerk: ResourceT?
08:19:51 <bloot> hu
08:19:56 <bloot> I can't do instance Num (Ord a)?
08:20:06 <mauke\> that looks like a kind error
08:20:12 <ReinH> Ord is not a type
08:20:36 <ReinH> (constructor)
08:20:46 <Rotaerk> ReinH: hmm, the cleanup should only occur if an action at some point fails
08:21:03 <bloot> yeah
08:21:04 <bloot> but
08:21:06 <bloot> there's no
08:21:07 <ReinH> Rotaerk: Ah, then I don't think there's anything
08:21:14 <bloot> v@(Ord a) => Num v?
08:21:15 <bloot> or is there?
08:21:15 <Rotaerk> for instance, I have got a tryBuildShader function, which is:  EitherT e io Shader
08:21:19 <mauke\> bloot: ?
08:21:25 <bloot> well
08:21:26 <ReinH> bloot: That doesn't make sense
08:21:31 <bloot> it does to me
08:21:36 <Rotaerk> and then I made a tryBuildShaders function which is basically:  EitherT io [Shader]
08:21:37 <ReinH> Well, it doesn't to Haskell
08:21:48 <ReinH> @ doesn't work on constraints
08:21:49 <jtanguy> Rotaerk: you have bracketOnError
08:21:52 <mauke\> bloot: your mental model is incompatible with ours. explain your model
08:22:23 <bloot> like
08:22:40 <ReinH> do you mean instance Ord a => Num a ?
08:22:41 <bloot> instance v@(Ord a) => Num v where x + x = x
08:22:43 <Rotaerk> but if, say, the 3rd call to tryBuildShader returns e, it shouldn't merely return e from tryBuildShaders, it should first delete the shaders it created already
08:23:01 <funfunctor> EvanR: am I thinking about playing with these things in the right way here? Prelude Data.Complex Data.Vector> :t fromList [(3 :+ 4)]       fromList [(3 :+ 4)] :: Num a => Vector (Complex a)
08:23:04 <bloot> should work as long as x is an instance of Ord
08:23:15 <ReinH> bloot: It won't work because it isn't valid Haskell
08:23:15 <mauke\> bloot: x is a value. it can't be an instance
08:23:33 <funfunctor> EvanR: vector seems like its a instance of Storage by default so I don't need to do anything there?
08:23:51 <mauke\> bloot: you could say instance (Ord a) => Num a where ..., but that requires undecideable instances
08:23:59 <Rotaerk> jtanguy: the original bracket/bracketOnError work only on IO, and handle exceptions
08:24:01 <mauke\> and it also conflicts with every other Num instance
08:24:17 <ReinH> (So you can't, in fact, do it)
08:24:19 <Rotaerk> the generalized one in Control.Monad.Catch requires that the monad implement MonadMask, and EitherT doesn't
08:24:25 <bloot> but you can define instance Num a
08:24:27 <bloot> just like that
08:24:30 <mauke\> no
08:24:36 <mauke\> instance Num a also conflicts everywhere
08:24:39 <bloot> yeah
08:24:52 <bloot> but you can just -XOverlappingInstances or something
08:24:57 <mauke\> "just"
08:25:04 <bloot> that's not the point anyway
08:25:07 <tdammers> you don't generally want overlapping instances
08:25:13 <Rotaerk> I'll try building such a transactional monad
08:25:35 <jtanguy> bloot: is that related to your type which implements everything?
08:26:31 <ReinH> What would be the point of instance Ord a => Num a? How do you use the Ord methods in defining the Num instance?
08:27:02 <jtanguy> Rotaerk: maybe the iotransaction package might help you ?
08:29:14 <Rotaerk> jtanguy: no, but it does look conceptually very similar.
08:29:27 <Rotaerk> jtanguy: it supports the same concept, but where *exceptions* trigger rollback
08:29:37 <Rotaerk> whereas I'd like something like that, but where we're dealing with eithers
08:29:53 <Rotaerk> left values prompt rollback
08:33:20 <tekul> Any emacs/hlint/flymake users around ? I’m trying to work out how I can disable certain hints in the editor.
08:33:58 <tekul> I have an HLint.hs file in my project root, which works with vim, but I’m trying out spacemacs and it doesn’t use it.
08:37:30 <bloot> \o/
08:38:10 <bloot> http://codepad.org/zADfHXAd
08:38:14 <ianjneu> I'm guessing I'm just Doing It Wrong, but is there a way to add typeclass constraints to >>=? I have a "monad" that throws things into Data.Set and Data.Map, so I need that the contained type is ordered.
08:38:49 <Iceland_jack> ianjneu: This is a known problem, there are solutions but they're not elegant
08:39:09 <Iceland_jack> @google Constrained-Monad Problem
08:39:10 <lambdabot> http://www.cs.swan.ac.uk/~csnas/papers_and_talks/constrained-monad-problem.pdf
08:39:10 <lambdabot> Title: The Constrained-Monad Problem
08:39:18 <bloot> *Main> sum [9,8,lift 9, lift $ lift "hi"]
08:39:18 <bloot> a
08:40:00 <ianjneu> Iceland_jack: oh right. I was at that talk. I haven't really used haskell since.
08:42:33 <hexagoxel> vandenoever: i'd recommend sandboxes..
08:45:15 <jtanguy> bloot: but why ?
08:45:46 <jtanguy> I'm trying to understand what uses this Everything typeclass might have
08:46:29 <bloot> jtanguy: http://codepad.org/lBChhJ8Y
08:46:30 <bloot> mostly that
08:46:52 <EvanR> funfunctor: Storage?
08:46:58 <EvanR> or Storable
08:47:17 <EvanR> Word8 Word16 are instances are Storable
08:47:39 <funfunctor> EvanR: ah oh, sorry i'm dyslexic
08:48:06 <bloot> jtanguy: It's when you don't know the actual value
08:48:14 <bloot> but want to typecheck it
08:48:22 <EvanR> bloot: you can use undefined for that
08:48:27 <EvanR> it always type checks
08:48:31 <bloot> but then I can't run it
08:48:35 <bloot> because it will exception away
08:48:35 <jtanguy> you can use undefined or a hole
08:48:40 <EvanR> well you cant run it anyway because you dont know the value
08:50:42 <bloot> EvanR: no
08:50:45 <bloot> but I can use Debug.Trace
08:51:08 <EvanR> you can use that with undefined
08:52:50 <funfunctor> EvanR: I did type CVector a = Vector (Complex a)  so I should make that Storable ?
08:53:27 <jtanguy> bloot: what are you trying to do? I would like to understand
08:53:40 <kuznero> Hi All!
08:53:57 <jtanguy> you want to run your program with undefined values, what would you get out of that?
08:54:15 <EvanR> i suggested data C16 = C16 Word16 Word16 and that should be storable, but im looking at this binary fixed point library which would help you use those in computations, or you can just use Vector Word32 for your sample output
08:54:40 <EvanR> then you wouldnt even need to use a 4
08:55:17 <EvanR> really Int16 Int16
08:56:59 <funfunctor> EvanR: so I need to write a custom complex number package?
08:57:05 <EvanR> no
08:57:08 <funfunctor> using Int16 Int16
08:57:32 <bloot> jtanguy: Just screwing around and trying what messy things I can do with instances/classes
08:57:32 <bloot> to get an impression of what I should add to my LISP dialect
08:57:32 <funfunctor> but what about all the useful complex number primitives I could get
08:57:38 <EvanR> to just get the data out of the bindings you can use ByteString, Vector Word8, or Vector whatever storable
08:58:34 <funfunctor> EvanR: since the data is in the form of IQ points (essentially complex numbers) it actually makes sense for it to have type Vector Complex
08:58:42 <EvanR> not really
08:58:47 <funfunctor> oh?
08:58:53 <EvanR> Complex (Double) is 128 bits floating point
08:59:09 <EvanR> your data is 2x16 bit fixed point
08:59:29 <EvanR> doing an implicit conversion right at the C binding level is silly
08:59:32 <funfunctor> EvanR: sure, I mean a value restricted version like you suggest
08:59:42 <EvanR> not restricted, it would have to be converted
09:00:30 <funfunctor> I should check the library code but I suspect it has a packed struct complex { uint16_t x; uint16_t y; }; in there
09:00:43 <EvanR> uint16_t would be wrong since your data is signed
09:00:59 <funfunctor> sorry, signed
09:01:02 <funfunctor> yes
09:01:05 <funfunctor> 4am here..
09:01:18 <EvanR> and besides the C function you are trying to wrap is just outputing to a buffer
09:01:35 <EvanR> thats what you should wrap first and worry about higher level stuff elsewhere
09:02:19 <EvanR> later for signed fixed point binary math you can look at the package that exists
09:02:24 <funfunctor> EvanR: ok well I think I have that in the form of a bytestring now
09:03:08 <EvanR> or just convert to normal complex numbers
09:03:08 <funfunctor> EvanR: I think its time for me to tindy up bits in this binding and have it on hackage since its basically done now
09:03:30 <funfunctor> would you mind doing a code audit?
09:04:04 <funfunctor> I sort of would like the first release to be stable within reason
09:05:43 <EvanR> there is no way on this earth that my looking at your bindings half derived from wonky example C++ code to a library you dont fully understand is going to remotely ensure that your release is in any way stable
09:06:05 <EvanR> i think youll just have to wing it
09:06:30 <funfunctor> EvanR: the binding isn't from C++ at all???
09:06:40 <nerium> I got this question today "What invariants do you have on your Program data type?", but I'm not sure what they mean.
09:06:40 <nerium> Here's my data type : https://gist.github.com/oleander/6d1104b7b4fe5a9ac839
09:06:43 <EvanR> i sawwed the c++
09:06:55 <funfunctor> EvanR: thats nothing to do with the binding
09:07:00 <nerium> Are they talking about rules that apply to my data type?
09:07:24 <geekosaur> yes. "what must be true for a Program value to be valid?"
09:08:02 <nerium> geekosaur: And by "valid" we mean "not crashing" ?
09:08:09 <geekosaur> ...since Haskell doesn't do dependent types (even the recent work in that direction is not complete), you can't really make those rules part of the type itself
09:08:20 <nerium> or just behaving correctly
09:08:24 <geekosaur> probably "produce correct results"
09:09:08 <funfunctor> EvanR: does not look /so bloody/ bad does it man? https://github.com/victoredwardocallaghan/hlibBladeRF/blob/nomonad/src/LibBladeRF/LibBladeRF.hs
09:09:11 <ski> nerium : "valid" being more or less "not nonsensical", i think
09:09:13 <EvanR> nerium: [PenDown, Die, PenUp] ?
09:09:17 <EvanR> is that valid
09:09:53 <nerium> EvanR: Hmm, after "die" the program should stop evaluating i guess
09:09:59 <merijn> geekosaur: Stephanie disagrees with you ;)
09:09:59 <nerium> So PenUp is never used
09:10:09 <EvanR> nerium: seems like that program is invalid then ;)
09:10:25 <c_wraith> I'm pretty sure you can do clever GADT hacks to prevent programs like EvanR's
09:10:33 <ski> so you'd have to decide (perhaps by considering laboration/exercise specifications) whether that's valid or not
09:10:38 <merijn> GADT all the things!
09:10:43 <ski> c_wraith : yes (i've done it)
09:11:08 <EvanR> nerium: "sorry, you can't order the pen to move up after the program has ended"
09:11:20 <EvanR> ^ would be nice
09:11:35 <nerium> EvanR: Would we call this an invariant?
09:11:45 <EvanR> is this homework?
09:11:48 <nerium> After "Die", no more instructions
09:11:53 <nerium> I'm prepping for an exam
09:11:55 <nerium> So no
09:12:05 * ski would also consider `Idle',`Lifespan' and `Split'
09:12:41 <nerium> ski: Do you mean that they can't occur after Die?
09:13:42 <ski> i rather meant that one can consider, for each of those, whether they are to be considered valid in all places (within `Action's and `Program's) where they can be placed
09:14:15 <paolino> hello, why zip (concat $ repeat $  []) [] hangs ?
09:14:48 <EvanR> > concat (repeat [])
09:14:50 <glguy> concat (repeat []) is "undefined", concat is never able to produce an element of the list
09:14:52 <lambdabot>  mueval-core: Time limit exceeded
09:14:52 <ski> perhaps you only want `Lifespan' to occur at the start of a `Program', or perhaps at most once in a `Program'. i dunno
09:14:56 <glguy> and it never finds the end of the list
09:15:14 <ski> perhaps you don't want to allow `Action's after `Split', perhaps you do want to allow that
09:15:17 <EvanR> nerium: its subjective what subset of [Action] is valid
09:15:22 <ski> &c.
09:15:46 --- mode: ChanServ set -c
09:15:55 <ski> perhaps the specification can give some hints about how to settle questions like this
09:15:56 <EvanR> nerium: LifeSpan (-234) might mean something
09:16:03 <nerium> Okay, so we're talking about program that might compile and not crash but isn't valid?
09:16:11 <ski> but it's important that you consider the questions, and decide on some definitive answer
09:16:23 <nerium> EvanR: Exactly
09:16:27 <paolino> glguy, I have this valid zip (concat $ repeat $  [1]) [], how can I make it work in the [] case ?
09:16:29 <EvanR> nerium: but probably not ;)
09:17:25 <glguy> customCycle [] 07= []; customCycle xs 07= cycle xs
09:17:28 <ski> nerium : we're talking about what programs you *intend* to handle
09:17:57 * ski blinks at the colors
09:18:02 <paolino> concat . repeat == cycle ?
09:18:19 <nerium> ski: Exactly
09:18:23 <glguy> paolino: Yes, but cycle isn't defined on empty list
09:18:24 <yunxing> Hey, I was thinking about to define a function signature that can generalize the following functions, but I failed to do it after long struggling....: 
09:18:26 <ski> paolino : yes
09:18:28 <yunxing> int :: Int -> Cont Int (Int -> Int)
09:18:28 <yunxing> int f = return (\a -> a + f)
09:18:28 <yunxing> int2 :: (Int -> Int) -> Cont Int (Int -> Int -> Int)
09:18:30 <yunxing> int2 f = return (\a -> \b -> a + f b)
09:18:30 <nerium> EvanR: ski  Thanks for help!
09:18:32 <yunxing> int3 :: (Int -> Int -> Int) -> Cont Int (Int -> Int -> Int -> Int)
09:18:34 <yunxing> int3 f = return (\a -> \b -> \c -> a + f b c )
09:18:39 <paolino> ok, thanks
09:18:45 <ski> (paolino : except `==' isn't defined on functions. i'd just say `=' there)
09:18:50 <glguy> yunxing: Please use a paste bin instead of pasting into channel
09:18:58 <EvanR> but not pastebin itself
09:19:09 <quchen> ?where lpaste
09:19:10 <lambdabot> http://lpaste.net/
09:19:14 <quchen> ^ That one is nice.
09:19:21 <EvanR> @where paste
09:19:21 <lambdabot> Haskell pastebin: http://lpaste.net/
09:19:24 <ski> nerium : np
09:19:41 <yunxing> Good point... http://lpaste.net/121547
09:20:07 <ski> yunxing : why use `Cont' at all in there ?
09:21:16 <yunxing> ski: because I can then have the following usage: http://lpaste.net/121547
09:24:20 <cfoch> hello
09:24:28 <cfoch> what should I do when I receive the message
09:24:30 <cfoch> "cabal: The following packages are likely to be broken by the reinstalls:"
09:24:44 <EvanR> stop drop and roll
09:25:01 <glguy> cfoch: You can unregister those packages and then reinstall them against the new dependencies
09:25:23 <dmj`> force a reinstall
09:25:37 <ski> yunxing : why not just `main = print $ (\k -> k 3 2 1) (int3 (int2 (int 0)))', if you skip the `Cont Int's and the `return's ?
09:25:41 <EvanR> dont force reinstall if you dont want broken packages
09:25:53 <dmj`> if it breaks, just wipe the sandbox and start over
09:26:03 <EvanR> :(
09:26:17 <glguy> cfoch: I use this tool to unregister the packages recursively https://github.com/glguy/GhcPkgUtils
09:26:20 <cfoch> I don't like the word "force"
09:26:26 <glguy> and then I reinstall them against the new dependencies
09:26:37 <glguy> force reinstalls are a good way to get into a broken state
09:30:09 <yunxing> ski: Thanks, it also works. It then becomes something like this: http://lpaste.net/121547
09:31:22 <ski> yunxing : .. btw, since you didn't use any continuation effects. your previous version could have had `int :: Int -> Cont a (Int -> Int)' (`Cont a' instead of `Cont Int'), and similarly for `int2' and `int3'
09:31:53 <ski> yunxing : also, if you prefer to have the `\k -> ..' afterwards, use `flip', e.g. like
09:32:20 <ski>   main = print $ int3 (int2 (int 0)) `flip` \k -> k 3 2 1
09:33:28 <paolino> I have f :: a -> Maybe b and x :: Maybe  a  f `fmap` x is Maybe (Maybe a), can I get out with functor  ?
09:33:42 <ski> hm, actually. on second thought that's not right
09:34:00 <yunxing> ski: Sounds good. But I guess I still have problem with generalizing those three functions into something like "intm"
09:34:09 <HeladoDeBrownie> paolino, what does "get out" mean here?
09:34:15 <ski>   main = print $ flip ($) (int3 (int2 (int 0))) $ \k -> k 3 2 1  -- would work, but looks clunky :/
09:34:20 <paolino> go to Maybe b 
09:34:35 <paolino> Maybe (Maybe b) -> Maybe b
09:34:52 <ski> yunxing : there are ways of doing that, but typically it's not worth it (unless you have dependent types, which Haskell doesn't)
09:34:52 <HeladoDeBrownie> paolino, you can case match on the inner Maybe
09:34:58 <HeladoDeBrownie> paolino, or either of them really
09:35:07 <ski> yunxing : check out how `printf' works, if you're curious
09:35:25 <glguy> paolino: Given your f and x you could use:  f =<< x :: Maybe b
09:35:27 <HeladoDeBrownie> paolino, i suspect though that you might want to use (>>=)
09:35:37 <HeladoDeBrownie> yeah, what glguy said
09:35:51 <paolino> ok, I need to use Monad instance
09:36:59 <paolino> join (f `fmap` x) = x >>= f  ?
09:37:07 <yunxing> ski: thanks for the pointer, I will take a look
09:37:10 <ski> paolino : `join :: Maybe (Maybe a) -> Maybe a' also uses monads
09:37:31 <ski> paolino : yes, that's a consequence of the monad laws
09:37:43 <ski> @type printf
09:37:44 <lambdabot> PrintfType r => String -> r
09:38:36 <ski> > let x = 23 in printf "%s = %03d" "x" x :: String  -- yunxing, this is a simple example
09:38:38 <lambdabot>  "x = 023"
09:39:29 <paolino> :t join
09:39:30 <lambdabot> Monad m => m (m a) -> m a
09:40:13 <dami0> heheh, Hasimov's 3 laws of Monadics
09:40:25 <EvanR> lol
09:40:39 <EvanR> whats the zeroth law
09:41:32 <paolino> mh, Maybe is nothing without its monad instance
09:41:59 <dami0> "Thine shall use Monads were appropriate and only if appropriate."
09:42:25 <kadoban> Is the first law something about burritos?
09:42:40 <EvanR> you shall follow the laws when appropriate
09:42:43 <int-e> it's hard to get out of a burrito?
09:44:05 <paolino> and this channel needs a bot to insert random questions about monads
09:44:42 <glguy> We've already got plenty of questions about them and unnecessary responses about old monad jokes :)
09:44:59 <paolino> :)
09:45:08 <EvanR> monads are too mainstream switching to traversable
09:45:56 * hackagebot shake-minify 0.1.2 - Shake Minify Rules  http://hackage.haskell.org/package/shake-minify-0.1.2 (LukeHoersten)
09:47:55 <hodapp> one of these days, I'll understand comonads enough to use them >_>
09:48:31 <EvanR> youll have commonand of comonads
09:48:44 * hodapp throws snowball at EvanR
09:49:08 <hodapp> EvanR: I demonad that you cease these silly puns.
09:49:39 <paolino> @src Comonad
09:49:39 <lambdabot> Source not found. That's something I cannot allow to happen.
09:51:33 <paolino> what is the Maybe of Comonads ?
09:52:33 <paolino> if Maybe is the easiest Monad
09:52:54 <quchen> Nonempty lists?
09:52:57 <xnull_> Identity is the easiest Monad
09:53:15 <quchen> xnull_: Proxy is easier.
09:53:58 <xnull_> hrm.
09:54:00 <dami0> kadoban: if your monad is harder to ingest than a burrito and at least equally as hard to excrete; you've gone wrong"
09:54:01 <xnull_> ok then
09:54:13 <quchen> I don't know whether my intuition is right, but NonEmpty feels like the "comonad version of Maybe".
09:54:16 <Keiya> http://i.imgur.com/uIBQcVy.jpg
09:54:20 <Keiya> agh
09:54:22 <xnull_> burritoes are easy to ingest
09:54:32 <Keiya> I can't hit 8, I keep putting this in the wrong irssi window!
09:54:37 <EvanR> and the nightclub is the burrito of comonads
09:54:46 <EvanR> thats my intuition
09:54:47 <Clint> now i have to eat a burrito
09:55:07 <quchen> I wonder what the right answer to this is (and whether there is one). Streams are also a strong candidate for "CoMaybe monad".
09:55:17 <quchen> comonad*
09:55:22 <paolino> @src NonEmpty
09:55:23 <lambdabot> Source not found. Take a stress pill and think things over.
09:55:38 <quchen> NonEmpty a = a :| [a]
09:55:47 <quchen> Stream a = Cons a (Stream a)
09:56:06 <quchen> NonEmpty = list with guaranteed head, Stream = list without []
09:56:30 <EvanR> they both dont have []
09:56:47 <EvanR> and guaranteed heads
09:56:48 <ski> quchen : at least `NonEmpty' and `Stream' are two of the simplest comonads ..
09:57:07 <quchen> EvanR: Right, but at least a Stream value is allowed to have a [] value at least somewhere in it
09:57:21 <ski> `NonEmpty' can be thought of as a comonad for causal computation, while `Stream' could be a comonad for anti-causal computation
09:57:22 <EvanR> huh
09:57:43 <quchen> EvanR: Oh, NonEmpty, not Stream.
09:58:13 <paolino> causal is harder then comonad
09:58:19 <quchen> ski: What's causal? What's anti-causal?
09:58:20 <EvanR> unless its implemented as One a | More (NonEmpty a)
09:58:40 <dami0> anticasual?
09:58:45 <quchen> EvanR: Then One contains an empty list, and also an element ;-P
09:58:51 <dami0> xnull_: hey
09:58:53 <ski> quchen : "causal" (possibly) depends on history, but not on future. "anti-causal" (possibly) depends on future, but not on history
09:58:54 <EvanR> nevar!
09:59:12 <dami0> ah
09:59:23 <ski> quchen : when considering effectful operations like `foo :: NonEmpty A -> B' and `bar :: Stream A -> B'
09:59:32 <ski> `extract' gives the "current" input value
09:59:48 <quchen> ski: I thought the comonad instances for Stream and NonEmpty were pretty much identical?
09:59:58 <quchen> extract = obvious, duplicate = tails
10:00:09 <quchen> where obvious = head
10:00:23 <ski> you can combine them like `([a],a,Stream a)', to get both history, current, and future
10:00:41 <ski> quchen : yes. the difference here is one of interpretation
10:01:41 <ski> in this case we're imagining a process which has a starting point with an initial value (as far as we know it), and then an infinite sequence of points following that, with successive values
10:02:49 <ski> consider `fib = 0 fby 1 + fib' (in some hypothetical language with comonadic side-effects of this kind (compare with Lucid))
10:02:52 <akegalj> in ghc7.8 PrimMonad is in Control.Monad.Primitive, but in ghc7.6 its not. I can't find where it should be
10:03:04 <ski> er, s/fib/nats/
10:03:35 <ski> the initial value of `nats' is `0'. all successive values are computed as `1' plus the current value of `nats'
10:04:25 <ski> (i was first thinking about `fibs', but then decided to take the simpler `nats' instead)
10:05:11 <ski> (`fby' stands for "followed by")
10:06:17 <ski> or consider `cumulating x = 0 fby x + cumulating x', which is more or less like `scanl (+) 0 xs'
10:10:54 <quchen> Okay ..?
10:13:18 <trd> hey anyone alive at this hour?
10:13:48 <EvanR> the little clock in the corner clearly states 12 noon
10:13:49 <int-e> What hour, 7pm?
10:13:59 <EvanR> you dont see it?
10:16:07 <sritchie> 11am here :)
10:16:11 <sritchie> trd: all sorts of hours going on
10:16:22 <geekosaur> mine says 18:14 :p
10:16:49 <geekosaur> (irc client keeps time in UTC)
10:18:16 <EvanR> 802 .beats 
10:24:07 <arcjun5> ...
10:24:09 <arcjun5> ....
10:24:11 <arcjun5> .....
10:24:13 <arcjun5> ......
10:24:16 <arcjun5> .......
10:24:19 --- mode: ChanServ set +o glguy
10:24:35 <glguy> Please don't spam
10:25:40 <ibid> (ooh, nice, pick up a club and say please. i admire that:)
10:26:02 --- mode: glguy set -o glguy
10:29:39 <hodapp> ibid: yes, #haskell is much more polite about that than some other channels.
10:29:56 <ibid> :)
10:30:30 <EvanR> ask questions first then shoot later
10:39:52 <JoshieAS> atom
10:40:18 <clrnd> vim
10:40:39 <funfunctor> what is the haddock syntax for many multi-line comments explaining Foo and Bar in data Something = Foo | Bar
10:40:48 <funfunctor> is it just -- ^ ...
10:41:04 <paolino> and -- |
10:41:22 <benzrf> )
10:43:01 <funfunctor> yep I know about -- |
10:43:17 <xnull_> > data MyType = Int Int | Float Float deriving Show; Int 5
10:43:18 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:43:37 <xnull_> how do i make new datatypes with lambdabot?
10:43:44 <xnull_> is it possible?
10:43:44 <Cale> @let data MyType = Int Int | Float Float deriving Show
10:43:47 <lambdabot>  Defined.
10:43:49 <xnull_> oh, cool
10:43:51 <Cale> > Int 5
10:43:53 <lambdabot>  Int 5
10:44:03 <xnull_> @let data MyType = Int Int | Float Float deriving Show
10:44:04 <lambdabot>  .L.hs:171:1:
10:44:04 <lambdabot>      Multiple declarations of ‘MyType’
10:44:04 <lambdabot>      Declared at: .L.hs:167:1
10:44:07 <xnull_> oic
10:44:09 <xnull_> > Int 5
10:44:10 <lambdabot>  Int 5
10:44:45 <Cale> Yeah, it'll stick around until someone does @undefine which resets all the definitions.
10:47:45 <bnjdlf> Do type 'makers' get curried? - If I have type T1 with kind * -> * -> *-> would (T1 Maybe) be a complete type?
10:48:26 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121558
10:48:43 <funfunctor> how would one properly format this in Haddock?
10:48:54 <xnull_> > let GetType :: MyType -> String; GetType (t n) = show n ++ " :: " ++ (case t of Int -> "Int"; Float -> "Float") in GetType $ Int 2
10:48:55 <lambdabot>  <hint>:1:5:
10:48:55 <lambdabot>      Invalid type signature: GetType :: MyType -> String
10:48:55 <lambdabot>      Should be of form <variable> :: <type>
10:49:24 <xnull_> > let getType :: MyType -> String; getType (t n) = show n ++ " :: " ++ (case t of Int -> "Int"; Float -> "Float") in getType $ Int 2
10:49:25 <lambdabot>  <hint>:1:43: Parse error in pattern: t
10:49:56 <xnull_> > let getType :: MyType -> String; getType x@(_ n) = show n ++ " :: " ++ (case x of (Int _) -> "Int"; (Float _) -> "Float") in getType $ Int 2
10:49:57 <lambdabot>  <hint>:1:45: Parse error in pattern: _
10:50:27 <xnull_> i, um
10:50:28 <xnull_> ...
10:51:03 <n0n3such> trying to install propeller
10:51:05 <n0n3such> http://lpaste.net/5842416387519152128
10:51:29 <n0n3such> when i do a cabal install cabal-install then repeat i get the same results
10:53:30 <athan> n0n3such: `cabal update`?
10:53:42 <athan> what version of GHC are you using?
10:53:51 <athan> er wait, you may have spelled it wrong
10:54:04 <athan> http://hackage.haskell.org/package/propellor
10:54:14 <n0n3such> 7.6.3
10:54:26 <athan> n0n3such: it's `or`, not `er`
10:54:36 <n0n3such> oops
10:54:38 <n0n3such> thx
10:55:12 <athan> np
10:55:41 <bnjdlf> do kind-level functions get curried?
10:55:57 <bnjdlf> also is it possible to search hoogle by kind?
10:56:05 <ReinH> bnjdlf: what are "kind-level functions"?
10:56:19 <bnjdlf> ReinH: types
10:56:20 <bnjdlf> like Maybe
10:56:26 <exio4> those aren't kind-level functions
10:56:31 <bnjdlf> well
10:56:51 <exio4> type constructors get curried, yes
10:56:51 <bnjdlf> i just made up that terminology to use for this case
10:57:10 <exio4> @kind Either
10:57:11 <lambdabot> * -> * -> *
10:57:13 <bnjdlf> im asking if you have a function that accepts a type of kind * -> * -> *
10:57:32 <ReinH> Maybe is a type-level function, if anything.
10:57:32 <bnjdlf> can you pass a type (Either Maybe) for example
10:58:02 <ReinH> bnjdlf: If you're going to make up terminology, it's best to explain it when you use it
10:58:09 <ReinH> Otherwise people might be understandably confused
10:58:26 <bnjdlf> okay
10:59:57 <exio4> you can't partially apply _everything_, for what it's worth, type families can't, as an example
11:00:31 <exio4> bnjdlf: what'd (Either Maybe) do?
11:00:40 <exio4> @src Either 
11:00:40 <lambdabot> Source not found.
11:00:53 <exio4> data Either a b = Left a | Right b 
11:01:30 <bnjdlf> so I came accross this code:
11:01:31 <bnjdlf> data Free f a = Free (f (Free f a)) | Return a
11:02:04 <bnjdlf> the third occurance of Free specifies a type with 2 type params
11:02:40 <bnjdlf> but I can do 'Free Nothing'
11:03:00 <S11001001> bnjdlf: it's curried
11:03:07 <barrucadu> There's Free-the-data-constructor, which has one argument, and Free-the-type-constructor, which has two.
11:03:28 <exio4> Nothing has type "Maybe x", so f ~ Maybe, and x ~ Free Maybe a
11:03:38 <unknownloner> whats the difference between the hamlet and shamlet quasiquoters in the shakespeare package?
11:04:33 <bnjdlf> okay i think i understand..
11:05:26 <EvanR> aka data Free f a = MkFree (f (Free f a)) | Return a
11:05:28 <S11001001> bnjdlf: oh sorry, I thought you defined a data type named 'Nothing' and were trying it out :)
11:05:45 <EvanR> S11001001: double confusion over naming everything the same
11:06:02 <EvanR> and they want more of it, with record fields
11:06:05 <S11001001> install idris; problem solved
11:06:08 <S11001001> ;]
11:06:30 <S11001001> wait, idris added it back but a different way :)
11:06:30 <xnull_> data I int = Integ integer
11:07:02 <exio4> xnull_: what are you trying to do? 
11:07:14 <EvanR> Int Int Int = Int Int
11:07:20 <bnjdlf> Is idris a useable language for real-world applications, or is it mainly for research purposes atm?
11:07:21 <xnull_> i'm trying to be cute
11:07:40 <xnull_> can Idris interop with haskell code easily
11:07:45 <exio4> bnjdlf: research, the languages changes really fast 
11:08:01 <bnjdlf> ah
11:08:02 <clrnd> because haskell doesn't ...
11:08:03 <EvanR> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
11:08:38 <EvanR> xnull_: through an ffi probably, or inserting your haskell code into idris's haskell implementation ;)
11:08:46 <xnull_> data Data data = Data data data data data data data data data data data
11:12:18 <S11001001> bnjdlf: it aims to be used for applications, though.  e.g. research on more efficient generated code https://edwinb.wordpress.com/2015/02/28/practical-erasure-in-dependently-typed-languages/  a window manager by puffnfresh https://www.youtube.com/watch?v=4i7KrG1Afbk
11:13:08 <bnjdlf> ah
11:13:22 <bnjdlf> http://lpaste.net/121561 in this code is it required that a on line 3 is a Functor?
11:14:07 <S11001001> bnjdlf: yes
11:14:37 <bnjdlf> :S
11:15:08 <S11001001> bnjdlf: however, note that this is not true of all free monad representations, e.g. http://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Monad-Free-Church.html
11:15:22 <glguy> bnjdlf: If you want something like Free where you don't have a functor you can use Operational
11:15:42 <bnjdlf> no i dont want anything im just learning about free monads
11:15:48 <bnjdlf> http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern reading this article
11:15:56 <bnjdlf> it says that f must be a functor
11:16:02 <bnjdlf> doesnt say anything about a
11:16:20 <bnjdlf> f - the type
11:16:21 <glguy> f is a type, a is a value with type: f _
11:17:23 <bnjdlf> wait, why is the type of a - f _ ?
11:17:35 <glguy> 03data Free f a 07= Pure a 07| Free (f (Free f a))
11:17:58 <bnjdlf> oh right
11:18:13 <EvanR> nice colors bro
11:18:31 <glguy> I'm not your bro, pal ^_^
11:18:46 <bnjdlf> I feel like I have to learn how to deduce types all over again for each new typeclass -_-
11:20:43 <clrnd> woah
11:23:49 <Cale> bnjdlf: Well, that's *kind of* true :)
11:24:20 <Cale> bnjdlf: Type classes with enough extensions turned on basically let you do constraint logic programming at the type level
11:24:29 <Cale> But usually it's not that bad :)
11:24:49 <bnjdlf> Yeah, I don't mind ;)
11:29:15 <Cale> I'm not sure I care for calling this a "pattern" exactly. The free monad is something which can be defined and reused (and indeed is, you can use the 'free' package on Hackage).
11:29:41 <Cale> I suppose the notion of free objects in general is a pattern with respect to Haskell though, since we'd be hard pressed to implement that.
11:31:39 <bnjdlf> Cale: does the notion of free objects come from category theory?
11:31:43 <Cale> yeah
11:31:46 <bnjdlf> ah okay
11:32:16 <EvanR> the Data.Map pattern
11:32:27 <Cale> EvanR: haha, yeah
11:32:36 <athan> What's the hardest part about ffi-ing to C++?
11:32:44 <EvanR> C++
11:33:01 <Cale> athan: The same part which is hard about ffi-ing to C++ from C
11:33:12 <athan> :P
11:33:16 <Cale> (you need to expose a C-like interface from the C++ side)
11:33:32 <athan> Ahh, hmm. Okey dokey
11:37:52 <geekosaur> C++11 and later require that each platform define its own ABI so that C++ compilers can interoperate; this also enables direct FFI to C++, provided you teach the FFI interface about each supported platform's C++ ABI. which is still more painful than making your C++ code export a C interface and then FFI-ing to that
11:39:34 <Cale> geekosaur: However, that does sound moderately promising as something which might be made part of GHC.
11:40:27 <geekosaur> eventually, yes. I think there was even a suggestion of a GSoC project, but it was decided that it was too big a hob
11:40:29 <geekosaur> *job
11:47:47 <erynn> Given a list [ 0, 1, 2, 3, 0, 0, 0 ]  how do I extract all elements != 0?
11:48:03 <Cale> > filter (/= 0) [ 0, 1, 2, 3, 0, 0, 0 ]
11:48:05 <lambdabot>  [1,2,3]
11:48:21 <erynn> thanks Cale I'll check it out
11:48:28 <Cale> > [ x | x <- [ 0, 1, 2, 3, 0, 0, 0 ], x /= 0 ]
11:48:29 <lambdabot>  [1,2,3]
11:49:00 <erynn> nice mathematics
11:49:27 <Cale> Yeah, it's just like set comprehension notation. (Which is why they're called list comprehensions.)
11:49:59 <albeit> :t (fst &&&)
11:50:00 <lambdabot> ((a, b) -> c') -> (a, b) -> (a, c')
11:50:38 <albeit> :t first (+1)
11:50:39 <lambdabot> Num a => (a, d) -> (a, d)
11:51:30 <kristikodare> :t =================>
11:51:30 <lambdabot> parse error on input ‘=================>’
11:52:05 <Cale> kristikodare: If you wanted the type of an infix operator, you'd have to enclose it in parens, but obviously that thing isn't going to be in scope.
11:52:21 <Cale> :t (^^)
11:52:22 <lambdabot> (Integral b, Fractional a) => a -> b -> a
11:53:38 <lisbeth> I want a function that will send a string to the command line to be evaluated when my program has completed
11:53:53 <lisbeth> so that it can relaunch itself recursively
11:54:25 <Cale> You mean, like, shove a bunch of characters at the corresponding tty?
11:55:06 <Cale> Or do you just want to execute the program again, and don't really care about the terminal or shell?
11:56:22 <Cale> That actually seems a bit questionable to me -- why not just execute main recursively if that's what you want to do?
11:58:04 <kgadek> hi. is there a tool that would group the imports by package they come from?
11:58:30 <Cale> kgadek: That's a nice idea, I don't know of any though.
11:59:47 <geekosaur> lisbeth, one could actually be written, at least for Linux and *BSD, but it's a really bad idea. better for the program to restart itself in this case, either by reinvoking main or by executeFile
12:00:24 <geekosaur> (for one, you have little control over what *else* might be in the terminal's input buffer)
12:00:34 <Cale> I was thinking maybe lisbeth wanted to have the option to press Enter or not to re-execute
12:00:46 <Cale> But yeah, there are lots of issues with the plan
12:01:01 <lisbeth> I'd like to design it this way for now
12:01:03 <lisbeth> and see how it works
12:01:34 <Cale> lisbeth: Well, I'm still a little unclear on what behaviour it is that you'd like to have
12:01:48 <lisbeth> I'm not sure myself.
12:01:52 <lisbeth> I am re-implementing xargs in bash.
12:01:59 <Cale> oh
12:02:04 <Xe> lisbeth: are you insane?
12:02:08 <geekosaur> you'll need to use the FFI to get at the TIOCSTI ioctl call. http://man7.org/linux/man-pages/man4/tty_ioctl.4.html
12:02:10 <lisbeth> yes but that is besides the point
12:02:19 <Cale> Well, that shouldn't require messing with the terminal then
12:02:23 <geekosaur> ...that seems like a very bad way to implement xargs
12:02:32 <lisbeth> possibly
12:02:43 <Cale> http://hackage.haskell.org/package/process-1.2.2.0/docs/System-Process.html -- just use this stuff, in a loop
12:03:07 <Fylwind> does it ever make sense to have Hashable but not Eq?
12:04:01 <geekosaur> I wouldn't think so, since you could always use Hashable to construct an Eq instance
12:04:17 <Cale> Well, maybe not a very good Eq instance.
12:04:20 <juanpablo_> Can you implement liftM2 without >>=? I mean to have something like fmap2.
12:04:37 <geekosaur> juanpablo_, liftA2?
12:04:43 <clrnd> juanpablo_, <*>
12:05:14 <juanpablo_> It needs at least Applicative?
12:05:17 <Cale> yep
12:05:22 <geekosaur> Monad is a stronger typeclass than you need; Functor isn't strong enough. Applicable gives you both the amalog to liftM2 (liftA2) and the analog to Monad's ap (<*>)
12:05:31 <geekosaur> er, Applicative'
12:05:48 <Cale> In fact, we could have defined Applicative in terms of pure and liftA2
12:05:50 <juanpablo_> So no way to have fmap2 without Applicative?
12:06:00 <geekosaur> nope
12:06:07 <Cale> You can't do it with just Functor
12:06:14 <Cale> :t fmap
12:06:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:06:34 * geekosaur rereads that last of his and despairs at his typing... >.>
12:06:41 <Cale> fmap doesn't give you a way to *combine* values of type f a
12:07:35 <juanpablo_> Cale: oh that gives me some good intuition
12:08:29 <clrnd> @src fmap
12:08:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:08:46 <Cale> @src Functor
12:08:47 <lambdabot> class  Functor f  where
12:08:47 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
12:09:08 <Cale> fmap is a class method, so it's implemented differently for each choice of type f
12:09:23 <lisbeth> basically I'd like to make a wrapper for bash
12:09:29 <lisbeth> to add some syntax to make it a little more like haskell
12:09:36 <jle`> Applicative in terms of liftA2 would be nice
12:10:03 <jle`> maybe offering the option of one or the other ala bind/join would be cool too
12:10:07 <Cale> :t liftA2 ($)
12:10:08 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
12:10:09 <EvanR> lisbeth: theres turtle
12:10:27 <Cale> Also, liftA2 (,) is enough
12:10:30 <Cale> :t liftA2 (,)
12:10:31 <lambdabot> Applicative f => f a -> f b -> f (a, b)
12:11:05 <jle`> liftA2 (,) is enough but nobody would eve ruse it directly
12:11:23 <Cale> liftA2 (,) is the operation that mathematicians know best
12:11:36 <jle`> ah i was speaking about efficiency reasons
12:11:42 <jle`> but liftA2 (,) is how i understand Applicative too
12:11:43 <juanpablo_> Cale: I'm using (liftA2 (,)) in some production code I just wrote
12:11:57 <juanpablo_> Wrote it 10 seconds ago haha
12:12:44 <jle`> do peope really use liftA2 (,) in real life
12:12:47 <jle`> :O
12:12:52 <Cale> (Applicative functors are a special case of monoidal functors, where we're taking the category to be Hask and the monoidal structure to be the one given by () and (,))
12:13:46 <Cale> jle`: Sure, it's essentially Cartesian product on lists.
12:14:05 <EvanR> can you explain any of that
12:14:07 <jle`> one neat way to think about the family is that Applicative lets you turn an (f a, f b) into an f (a, b), and Monad lets you turn an f (f a) into an f a.  two different "directions" of squishing
12:14:24 <jle`> Cale: i guess that's one use case
12:14:28 <Cale> EvanR: Uh, sure... do you know what a monoidal category is, and if not, do you know what a category is?
12:14:45 <jle`> usually though if you use liftA2 (,) it's just delaying an fmap somewhere
12:14:51 <jle`> with an uncurried function
12:15:04 <jle`> because what are you going to do with a functor full of tuples except apply a function to it
12:15:20 <jle`> in that case you might as well do liftA2 f
12:15:41 <EvanR> Cale: whats a monoidal category
12:19:29 <clrnd> I know a monoid from algebra, do categories have `operations`?
12:19:47 <Cale> EvanR: So a monoidal category is a category C that comes equipped with a functor C x C -> C, which effectively acts like a monoid operation on the objects of the category (up to isomorphism)
12:20:05 <MasseR> gadh
12:20:30 <EvanR> Cale: a functor C x C -> C also maps arrows?
12:20:32 <MasseR> ... sorry about that. alt-g for changing xmonad topicspaces, adh for adhoc, missing alt
12:20:33 <Cale> yes
12:21:05 <EvanR> i guess whats C x C, all combinations of arrows
12:21:56 <Cale> Yeah, an object of C x C is a pair of objects of C, and an arrow (X,Y) -> (Z,W) in C x C is a pair of arrows (f,g) where f: X -> Z and g: Y -> W
12:22:25 <clrnd> Cale, a functor with two arguments isn't a bifunctor?
12:22:46 <Cale> Yes, that's what a bifunctor is.
12:23:28 <Cale> So, if we call this bifunctor ⊗: C x C -> C
12:23:39 <EvanR> alright
12:23:43 <clrnd> :D
12:24:17 <Cale> Then given f: X -> Y and g: Z -> W, we have f ⊗ g: X ⊗ Z -> Y ⊗ W
12:25:04 <Cale> and then there's some additional stuff to make this like a monoid operation
12:25:13 <Cale> So we have a unit object I in C
12:25:20 <clrnd> monoid has zero, that
12:25:24 <Cale> and some natural isomorphisms
12:26:06 <EvanR> what is the unit(s) of C x C
12:26:08 <Cale> The associator: α_{A,B,C}: (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C)
12:26:18 <EvanR> er
12:26:33 <EvanR> C is the monoidal category nevermind
12:26:56 <Cale> As well as λ_A: I ⊗ A -> A, and ρ_A: A ⊗ I -> A, the left and right unitor
12:27:10 <Cale> yeah, sorry for reusing C there :P
12:27:19 <Cale> maybe should have used X,Y,Z again
12:28:15 <Cale> Those are natural transformations with respect to the choices of objects A, B, and C there, and they're isomorphisms as well, so you can invert them.
12:28:40 <Cale> and then you have some coherence conditions to say that these isomorphisms interact in an appropriate way.
12:28:40 <btcNeverSleeps> what's that "thing" people are using to post fancy colors in their Haskell code on this IRC channel? Are these ANSI color codes? And what's the code -> ANSI converter?
12:29:11 <Cale> btcNeverSleeps: They're mIRC colour codes
12:29:20 <Cale> and it's mostly just glguy as of yet
12:29:22 <btcNeverSleeps> Cale: ah funny, they show fine under Emacs / erc
12:29:31 <Cale> Yeah, most IRC clients support them now
12:29:43 <clrnd> would be cool if lambdabot had them
12:29:52 <Cale> Yeah, glguy is working on it apparently :)
12:29:53 <EvanR> idris bot has them
12:29:55 <clrnd> yay
12:30:12 <Cale> http://en.wikipedia.org/wiki/Monoidal_category has the full set of diagrams for the laws
12:30:12 <clrnd> idris bot thinks he is too much, he aint nobody
12:30:13 <Hijiri> unfortunately not many clients support MS Comic Chat rendering
12:30:19 <aawe> looking forward to writing vulkan programs in a haskell-backed typed dsl
12:30:19 <EvanR> values are red types are blue (or the other way around)
12:30:54 <JoshieAS> cd .cddd
12:31:03 <EvanR> Cale: well, dont that beat all. monoidal categories have a lot more to their definition than monoids
12:31:05 <Cale> But yeah, for example, Hask is a monoidal category in a somewhat boring way, where we pick the bifunctor to be (,)
12:31:11 <Cale> and the unit object I to be (,)
12:31:15 <Cale> er, ()
12:31:51 <Cale> EvanR: The only reason there's a bit more to it is that we're replacing equational laws with isomorphisms
12:31:59 <EvanR> because (X, ()) -> X is an isomorphism... or a natural transformation or some such
12:32:13 <Cale> Like, usually we just demand that a * (b * c) = (a * b) * c
12:32:25 <jle`> 10w11o02o 12h06o13o
12:32:41 <aawe> what is that color wizardry
12:32:42 <Cale> But usually when you're working in some category, you're not going to get straight up equality
12:33:09 <unknownloner> omg color
12:33:16 <Cale> One case where you really do get equality is the case of the category of endofunctors on some fixed choice of category C
12:33:26 <Cale> Please don't abuse the fact that #haskell is -c
12:33:30 <EvanR> i cant wait until somebody makes it blink
12:33:41 <unknownloner> please no
12:33:51 <EvanR> BURRITOS
12:33:54 <Cale> You have a tensor product on that category given by composition of functors
12:33:56 <unknownloner> on the bright side my terminal doesnt support blink
12:33:58 <aawe> lambdabot should colorize though
12:34:05 <aawe> I demand it
12:34:07 <Cale> whose identity object is the identity functor, of course
12:34:08 <sternenseemann> jle`: yay?
12:34:20 <Cale> and there you get associativity and units "on the nose"
12:34:28 <EvanR> Cale: what functor, you mean endofunctors
12:34:45 <Cale> F ⊗ G = F . G
12:34:58 <Cale> where F and G are endofunctors on some category C
12:35:05 <btcNeverSleeps> jle: you wrote "woo hoo", wondering if my copy/paste of your "woo hoo" is also in color?
12:35:29 <EvanR> Cale: er, is this a different product with the same symbol, or the same product as before
12:35:30 <Cale> makes the category of endofunctors C -> C (and natural transformations between them) into a monoidal category
12:35:33 <drewbert> Guys, something amazing just happened.  I 'cabal install'ed a new package into a sandbox that already had packages... and it didn't break anything!
12:35:45 <geekosaur> most IRC clients don't copy/paste color properly
12:35:57 <geekosaur> it's up to the client to support it
12:35:57 <jle`> drewbert: time to drop everything and celebrate :)
12:36:30 <drewbert> jle`: I might actually have to get work done instead of fighting the package manager all day.
12:36:35 <Cale> EvanR: In order to define a monoidal category, we pick a category, and then we pick a bifunctor ⊗, and unit object I, and then the appropriate natural isomorphisms α,λ,ρ
12:37:03 <Cale> EvanR: So, for any category C, we can pick the category of endofunctors C -> C
12:37:07 <bnjdlf> Whats the best book for learning category theory for computer science applications?
12:37:08 <EvanR> Cale: where did that tensor product come from, is that out of nowhere or only in the context of already having a monoid category. and then C -> C is yet another monoid category on top of that, or just by itself
12:37:11 <Cale> and the bifunctor which is functor composition
12:37:27 <Cale> C is now an arbitrary category (not necessarily monoidal)
12:37:43 <Cale> and we're considering the category of endofunctors C -> C
12:37:49 <Cale> and turning *that* into a monoidal category
12:38:04 <Cale> So for any functors F, G: C -> C
12:38:14 <Cale> we have a functor F ⊗ G: C -> C
12:38:19 <Cale> which is just FG
12:38:24 <Cale> (the composite)
12:40:08 <Cale> and composition of functors is actually itself a bifunctor, in that if we take any natural transformations, say η: F -> H and θ: G -> K, then we can get a natural transformation η*θ: FG -> HK
12:41:12 <Cale> and it's associative, and has a left and right unit (the identity functor)
12:41:29 <EvanR> ok so bifunctor is something more than just a functor with "two args"
12:41:56 <Cale> I mean, it's basically just a "functor with two args", in the sense that it's a functor C x C -> C
12:42:14 <bnjdlf> Category theory books - 'Category theory for scientist by David Spivak' vs 'Category Theory for Computing Science by Barr & Wells' ?
12:42:26 <EvanR> FG -> HK seems to have one arg
12:42:30 <Cale> bnjdlf: Category Theory by Awodey
12:44:14 <Cale> EvanR: I guess it's a little confusing. What I'm saying here is that composition of endofunctors is itself a bifunctor on the category of endofunctors C -> C
12:44:17 <bnjdlf> Cale: I tried reading that book and found it very abstract and hard to read
12:44:55 <geekosaur> a book on category theory is abstract, whoda thunk
12:44:59 <geekosaur> >.>
12:45:22 <Cale> bnjdlf: Hmm, yeah, it tries not to have too many prerequisites, but it may require a bit of mathematical maturity regardless.
12:45:32 <EvanR> Cale: alright so i wanted to know what was up with liftA2 (,)
12:46:02 <Cale> What was that one someone mentioned... I think I heard Tom Leinster had a new introductory book?
12:46:13 <hannes___> Cale: Which book? I haven't found any thorough introduction on category theory yet
12:46:17 <funfunctor> Anyone used Haddock with FFI binding stuff before? I'm trying to stop haddock from including the bindings.XX.YY submodules somehow
12:46:24 <funfunctor> since those don't have coverage
12:47:41 <shachaf> I like Tom Leinster's _Basic Category Theory_: http://www.maths.ed.ac.uk/~tl/bct/
12:47:46 <Cale> hannes___: "Basic Category Theory" by Tom Leinster apparently. I was talking about "Category Theory" by Steve Awodey
12:48:23 <shachaf> Oh, Cale just mentioned it.
12:49:17 <hannes___> Cale: Yes, I meant the one you were talking about
12:50:07 <hannes___> blergh, why are math/tech books always so expensive -_-
12:50:25 <Cale> Because they don't print many copies
12:50:46 <EvanR> because they cant sell many copies
12:51:37 <EvanR> why do you have to buy edition n+1 in year+1 ?
12:51:40 <hannes___> I wonder if anyone ever tried the inject the idea that math is cool into pop culture
12:51:41 <EvanR> and throw the rest in the trash
12:51:49 <Hijiri> how many differences does the 2010 version have from the 2006 version?
12:51:52 <Hijiri> of awodey
12:51:58 <EvanR> hannes___: donald duck in mathemagic land!
12:52:10 <Hijiri> my school library has both but the 2010 one is due in november
12:52:35 <Cale> New version has stuff on monoidal categories
12:53:01 <Cale> and some additional exercises and solutions
12:54:13 <hannes___> Cale: do monoidal categories differ much from the concept of a monoid in algebra?
12:54:44 <Cale> hannes___: Well, they're like categories which more or less have a monoid operation on their objects (up to isomorphism)
12:55:59 <Cale> hannes___: and in addition to that, you can generalise the notion of a monoid from the (monoidal) category of sets (where the monoid operation on sets is Cartesian product with the identity being a one element set), to an arbitrary choice of monoidal category
12:58:14 <Cale> So, in a monoidal category (C,⊗,I), you have the notion of a monoid object M, which is an object of C, together with a "multiplication" μ: M ⊗ M -> M, and "identity" η: I -> M, satisfying laws similar to the ones you'd have for a monoid in Sets
12:58:29 <Cale> See: http://en.wikipedia.org/wiki/Monoid_(category_theory)
12:59:08 <Cale> A monoid object in the monoidal category of endofunctors C -> C is the same thing as a monad on C.
12:59:31 <g0r> gre.b.fab
12:59:40 <hannes___> Cale: the identity of cartesian product is a one element set? I assume that means that ((),a1,...,an) and (a1,...,an,()) are understood to be equivalent to (a1,...,an)? 
13:00:29 <EvanR> Cale: whats the multiplication there, join?
13:00:35 <Cale> EvanR: yes
13:00:45 <Cale> hannes___: Yeah, there's just an isomorphism.
13:01:08 <Cale> hannes___: Really A x (B x C) and (A x B) x C are not the same set, but there is a natural isomorphism between them
13:02:01 <Cale> hannes___: and when you provide the monoidal category structure for Set, you're required to specify this natural isomorphism, along with natural isomorphisms I x A -> A and A x I -> A
13:02:06 <EvanR> Cale: and applicative functor is a thing similar to this monoid object on category of endofunctors / monad?
13:02:44 <Cale> Okay, so an Applicative functor is sort of the same thing as a functor between monoidal categories which respects the monoidal structure
13:03:18 <Cale> (Obviously less general once we've stomped on it by picking the monoidal category to be (Hask, (,), ())
13:03:41 <Cale> http://en.wikipedia.org/wiki/Monoidal_functor
13:03:43 <mniip> if I have a forM, how can I tell the runtime (assuming threaded RTS) that the order of the evaluation doesn't matter
13:04:06 <hannes___> mniip: You don't?
13:04:22 <mniip> ugh
13:04:25 <mniip> order of execution
13:04:41 <Cale> EvanR: So, there, you see that a monoidal functor is a functor F: C -> D that comes with a natural transformation phi_A,B: FA * FB -> F(A ⊗ B)
13:05:37 <hannes___> mniip: At best, you could supply a monad that does that; You can't change the behavior of forM
13:05:38 <Cale> which once we stomp on it, becomes a Haskell endofunctor f with a polymorphic function (f a, f b) -> f (a,b)
13:06:05 <EvanR> stomp on it, like grapes to make wine ;)
13:06:07 <mniip> hannes___, I'm not asking it to be fixed to forM
13:06:14 <ReinH> Cale: see this is why I like the closed functor view now :)
13:06:33 <Cale> and the natural transformation phi: I_D -> F I_C becomes a function  () -> f ()
13:06:37 <mniip> I'm checking a list of patterns against a list of words. It doesn't matter in which order the patterns will match, so the search can be paralellized
13:06:46 <mniip> the question is how to make GHC understand that
13:06:59 <Cale> which, given that you have fmap, is the same as pure :: a -> f a
13:07:26 <EvanR> mniip: if you want to try to parallelize it, use Control.Parallel
13:07:54 <ReinH> Cale: with the monoidal functor view you have to bring in the tensor hom adjunction
13:08:04 <hannes___> mniip: You probably aren't going to be able to coax ghc into parallelizing your code for you
13:08:06 <EvanR> but you also need to set up profiling or benchmarking to make sure that its helping
13:08:14 <mniip> hmmok
13:08:26 <Cale> ReinH: Yeah, you can go halfway :)
13:08:37 <Cale> (in the stomping process :)
13:08:43 <ReinH> mniip: You should read Simon Marlow's book on concurrency and parallelism in Haskell :)
13:08:47 <ReinH> Cale: right :)
13:09:11 <EvanR> i need a bloody mary now
13:09:12 <mniip> I guess I should start with profiling my code then
13:09:18 <ReinH> Cale: with Applicative as a closed functor, (<*>) is just a statement that f preserves internal homs :)
13:11:29 <hannes___> mniip: also, I'm not sure exactly what you're trying to achieve. If you use forM you're presumably going through the list of matches sequentially afterwards, so parallelization would only help if matching itself is expensive. You won't get matches in a different order in a pure function.
13:12:32 <mniip> I'm asking for some [IO ()] -> IO () which assumes the IO actions can be paralellized
13:12:42 <mniip> and thus runs them non-sequentially in multiple treads
13:13:10 <EvanR> mniip: did you look in Control.Parallel
13:13:28 <mniip> yeah
13:13:38 <mniip> didn't look very interesting
13:14:44 <mniip> par creates a spark right, I have not 20 of those patterns, but rather hundreds, I don't think flooding the runtime with that much sparks is a good idea
13:15:03 <funfunctor> "Warning: LibBladeRF.LibBladeRF: could not find link destinations for: Bindings.LibBladeRF.Types.C'bladerf" <~ how can I get Haddock to ignore it and not try and link?
13:15:04 <mniip> especially given I don't have 100 cores
13:15:33 <EvanR> mniip: i doubt hundreds is enough to make a difference parallelizing that. and 100 cores would just slow it down even more from the communication to put them back together
13:15:56 <ReinH> mniip: spark size is definitely a consideration
13:16:04 <hannes___> mniip: you don't need a core per spark
13:16:19 <ReinH> hundreds doesn't seem like a very large number though
13:16:21 <dmwit> This is concurrency. Parallelism doesn't seem relevant.
13:16:28 <Hijiri> sparks are for pure computations, aren't they/
13:16:37 <dmwit> What Hijiri said.
13:17:09 <hannes___> well yeah, the signature mniip gave earlier sounded more like mapM_ forkIO to me
13:17:10 <EvanR> ah yeah, it should be trivial to split it into chunks and forkIO them all
13:17:34 <ReinH> mniip: sounds like you want something from async
13:17:34 <funfunctor> EvanR: do you ever sleep ?!
13:17:41 <EvanR> no
13:17:45 <ReinH> But I still suggest reading SimonM's book
13:17:46 <funfunctor> :)
13:22:33 <funfunctor> Is Haddock actually maintained very actively?
13:24:27 <drewbert> holy crud, I did it again!
13:24:53 <drewbert> Guys cabal is not !@#$ing me every chance it gets today.  It is so nice.
13:24:59 <micky> Hi all, if anyone can answer this question:  https://answers.yahoo.com/question/index?qid=20150304125415AA3GRlQ
13:25:21 <dcoutts> funfunctor: moderately
13:25:25 <JagaJaga> I have list [x1, x2...]. I need to apply function f to each element and return an element (not the result of function application)  where f x is min. How to do it properly?
13:26:06 <jle`> minimumBy sounds like it
13:26:08 <mauke> create a list of pairs (x, f x)
13:26:11 <funfunctor> dcoutts: yea it has its spots I noticed
13:26:11 <mauke> then minimumBy
13:26:22 <mauke> well, or just minimumBy
13:26:23 <jle`> :t minimumBy
13:26:23 <lambdabot> (a -> a -> Ordering) -> [a] -> a
13:26:30 <mauke> depends on how cheap your f is
13:26:43 <ReinH> mauke: depends on whether you want the schwartzian transform
13:26:44 <funfunctor> like, if you hide a module it still gets included in the coverage calculations ?!
13:26:50 <mauke> ReinH: exactly :-)
13:26:52 <ReinH> Which surely has another name in FP, right?
13:27:00 <jle`> > minimumBy (\x y -> compare (negate x) (negate y)) [1..10]
13:27:02 <lambdabot>  10
13:27:15 <JagaJaga> jle`: thank you!
13:27:23 <mauke> > minimumBy (comparing negate) [1..10]
13:27:24 <lambdabot>  10
13:27:30 <jle`> like mauke mentioned, this will recompute your twice at every comparison
13:27:32 <ReinH> mauke: BTW I believe the technical term for applying a schwartzian transform is "use the schwartz"
13:27:43 <jle`> *your f
13:27:44 <ReinH> (spaceballs jokes never get old)
13:27:51 <jle`> to avoid recomputation, you can do something like
13:28:02 <jle`> > map (id &&& negate) [1..10]
13:28:04 <lambdabot>  [(1,-1),(2,-2),(3,-3),(4,-4),(5,-5),(6,-6),(7,-7),(8,-8),(9,-9),(10,-10)]
13:28:18 <jle`> and then minimumBy (comparing snd), or minimum by (\(_,x) (_,y) -> compare x y)
13:28:24 <jle`> and then take the fst of that :)
13:28:32 <mauke> > map ((,) <*> negate) [1..10]
13:28:33 <lambdabot>  [(1,-1),(2,-2),(3,-3),(4,-4),(5,-5),(6,-6),(7,-7),(8,-8),(9,-9),(10,-10)]
13:29:47 <jle`> ReinH: ha ha
13:31:19 <dmwit> minimumOn :: Ord b => (a -> b) -> [a] -> a, and soon minimumByOn :: (a -> b) -> (b -> b -> Ordering) -> [a] -> a
13:32:28 <jle`> :O
13:32:31 <jle`> :t minimumOn
13:32:32 <lambdabot>     Not in scope: ‘minimumOn’
13:32:32 <lambdabot>     Perhaps you meant one of these:
13:32:32 <lambdabot>       ‘minimumOf’ (imported from Control.Lens),
13:32:39 <jle`> such sad
13:33:55 <dmwit> We're really getting sortOn soon, though, I think. Next release.
13:38:14 <aidecoe> is there a function similar to words, but takes separator? I'd like to split "abc;defgh;ij" into ["abc", "defgh", "ij"].
13:38:18 <aidecoe> it would be something like:
13:38:20 <aidecoe> map dropSemicolon $ groupBy (\_ y -> y /= ';') "abc;def;ghi"
13:38:43 <funfunctor> alright, I think I should just do a release
13:38:48 <mauke> Data.List.Split
13:40:37 <mauke> > splitOn ";" "abc;defgh;ij"
13:40:39 <lambdabot>  ["abc","defgh","ij"]
13:41:06 * hackagebot JuicyPixels 3.2.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.3 (VincentBerthoux)
13:41:21 <aidecoe> mauke: thanks (-:
13:43:45 <funfunctor> wonderful, my first hackage package http://hackage.haskell.org/package/hlibBladeRF-0.1.0.0
13:44:50 <funfunctor> but why no haddock docs are showing?
13:46:07 * hackagebot hlibBladeRF 0.1.0.0 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.0 (eocallaghan)
13:46:23 <glguy> funfunctor: The haddocks aren't built right away. You can manually upload them if you're in a hurry
13:46:32 <geekosaur> likely because the library it binds to is not installed on the buildbot. you may have to generate and upload them
13:47:22 <funfunctor> I thought I did..
13:47:28 <geekosaur> and, well, yes, if you're too fast then it hasn't built the package/docs yet :)
13:47:40 <funfunctor> so just cabal haddock && cabal sdist and re-upload?
13:48:10 <funfunctor> the git url looks a bit funky also
13:48:22 <glguy> I wrote this script for uploading documentation. It's not specific to the lens package, but what I use there: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
13:49:12 <funfunctor> should I remove this line? https://github.com/victoredwardocallaghan/hlibBladeRF/blob/master/hlibBladeRF.cabal#L77
13:50:32 <dmwit> funfunctor: Well, considering that repository doesn't appear to have a bindings-hlibbladeRF directory, I would say yes.
13:50:55 <funfunctor> dmwit: should that be src instead?
13:51:29 <funfunctor> or just remove it all together
13:52:12 <dmwit> I would put the directory that has the cabal file.
13:52:26 <dmwit> So yes, just remove it altogether.
13:52:52 <dmwit> The cabal documentation agrees with me: "This field lets you specify the relative path from the root of the repository to the top directory for the package, ie the directory containing the package's .cabal file.".
13:55:20 <funfunctor> dmwit: cool, I could not find the doc.
13:55:27 <bergmark> never heard of it!
13:55:46 <funfunctor> there isn't a way to re-upload a sdist without a version bump is there?
13:55:50 <dmwit> funfunctor: https://www.haskell.org/cabal/users-guide/installing-packages.html
13:56:19 <funfunctor> ta!
13:57:52 <funfunctor> dmilith: if you happen to know how to hide those Bindings packages from showing in Haddock let me know!
13:58:15 <dmwit> Did you try haddock's Fine Documentation?
13:58:25 <dmwit> (I happen to know the answer is in there.)
13:59:26 <funfunctor> dmwit: only this page https://www.haskell.org/haddock/doc/html/module-attributes.html
13:59:36 <funfunctor> but it does not work out
14:00:03 <dmwit> What does "work out" mean?
14:00:03 <Fylwind> is there a way to try out the FTP Prelude in an older version of GHC?
14:00:31 <funfunctor> dmwit: if you clone and try and build the docs you will see they keep ending up in coverage even those I do hide and prune
14:00:54 <dmwit> Fylwind: Not really. You can opt-in to any Prelude you like for a specific module, of course, but any libraries you build with e.g. cabal will be built against GHC's Prelude.
14:01:05 <funfunctor> its really annoying because I want to setup CI to ensure doc coverage is >=90%
14:01:34 <aawe> can I go from String to FilePath with overloadedstrings?
14:02:14 <jle`> yes
14:02:14 <geekosaur> yes?
14:02:26 <S11001001> aawe: you can do it without overloadedstrings :)
14:02:34 <aawe> oh, nevermind. seems that was never the error
14:02:35 <S11001001> @ty id :: String -> System.FilePath.FilePath
14:02:36 <lambdabot> String -> FilePath
14:02:40 <jle`> :t ("hello" :: String) :: FilePath
14:02:40 <lambdabot> FilePath
14:02:49 <geekosaur> S11001001, system-filepath library I presume
14:03:00 <Fylwind> dmwit: I mean for new code, I want to write some code that's forward compatible; was curious if there's like a package somewhere that "emulates" the new GHC Prelude
14:03:08 <geekosaur> which has its own FilePath that is not a String, but does have an instance of IsString
14:03:18 <dmwit> funfunctor: Yeah, I'm not going to figure out how to build your thing. No idea what libbladeRF is and neither does my package manager.
14:03:21 <aawe> was confused by "Could not deduce (a ~ [Char])".. I need to keep reading those error messages
14:03:36 <jle`> reading helps :)
14:03:54 <dmwit> Fylwind: {-# LANGUAGE NoImplicitPredule #-}, then import a module containing FTP as Prelude
14:04:23 <exio4> is there any to "typecheck" things within template-haskell? I'd basically want a way to infer the type of some expression using the actual scope + a few extra variables
14:04:33 <funfunctor> dmwit: ?? no I mean just build the haddock doc, cabal haddock
14:04:51 <dmwit> funfunctor: can't cabal haddock without cabal configure; can't cabal configure without pkg-config(libbladerf)
14:04:52 <gyaretto> Can I not call a function that doesn't return IO from within a do block?
14:05:06 <jle`> gyaretto: you can use `let`
14:05:24 <jle`> do { let x = f y; ... }
14:05:57 <gyaretto> jle`: Thanks!
14:06:10 <jle`> np! this is basically like an alias in the scope of the "rest of the do block"
14:06:37 <funfunctor> dmwit: can't you just comment it out in the cabal file or something
14:06:40 <Fylwind> dmwit: I see
14:07:23 <S11001001> geekosaur: ah
14:07:29 <dmwit> funfunctor: nope
14:07:31 <dmwit> funfunctor: (try it =)
14:07:39 <lpaste> funfunctor pasted “dmwit” at http://lpaste.net/121567
14:08:35 <funfunctor> dmwit: not sure how to deal with the three warnings first, then why Bindings.X.Y are winding up in coverage at all
14:09:05 <dmwit> You could consider moving them from exposed-modules to other-modules if they are not intended to be user-visible.
14:09:35 <dmwit> But this output doesn't tell me anything  about whether haddock is actually generating the docs for those or not. =P
14:09:46 <dmwit> I suspect it is not, if you asked it not to.
14:10:51 <funfunctor> dmwit: ok I moved them to other modules
14:11:15 <funfunctor> dmwit: well my coverage is failing to pass because they are being counted
14:11:39 <funfunctor> also, whats the deal with the "Could not find documentation for exported module: X" warning?
14:12:26 <dmwit> I expect haddock is wishing it could make a link to a file which contains documentation for module X.
14:12:30 <dmwit> But this is obviously hopeless.
14:12:49 <dmwit> Since X isn't *really* a module, but rather a handy prefix for names from a bunch of different modules.
14:13:04 <dmwit> I might be tempted to file a request-for-enhancement on the haddock bug tracker.
14:13:18 <dmwit> Though you will have to think about what you would want it to do.
14:13:59 <dmwit> In the short term, just export all the modules you imported instead of using this clever trick.
14:14:44 <funfunctor> dmwit: last but not least, how to stop haddock from chasing up C'bladerf link "could not find link destinations for: Bindings.LibBladeRF.Types.C'bladerf" ?
14:15:45 <funfunctor> ah, docs can suffer over source code not being elegant imho.
14:16:18 <dmwit> Don't export C'bladerf or anything that mentions C'bladerf in its type. ;-)
14:16:36 <dmwit> Or live with the warning, or generate docs for C'bladerf.
14:17:38 <fizbin> Why using strong types is good: because when getting back to code you had to set aside for 8 weeks, you can easily remember what the really strongly typed part was all about, but the [(Node, Int, S.Set Int, S.Set Int)] stuff has you wondering what on earth past-you was smoking.
14:17:50 <dmwit> e.g. document C'bladerf, mark its module as not-home, and re-export C'bladerf somewhere else.
14:18:10 <ab9rf> fizbin: amen
14:18:30 <fizbin> Seriously, WTF was I thinking when I wrote this code?
14:18:31 <dmwit> "why well-named types are good"
14:19:17 <Taneb> fizbin, seems to be some representation of a graph?
14:19:22 <gyaretto> Ohkay, I have some ugly code and an error. https://gist.github.com/garrettoreilly/c81c563db17eea02e223
14:19:42 <fizbin> I mean, I even still have the drawings on my whiteboard with a bunch of mostly unlabeled circles and arrows and those make much more sense than this code.
14:19:45 <aawe> how can I force ghci to read a script file with "#!/usr/bin/env runhaskell" as first line (target `x' is not a module name or a source file)
14:20:08 <glguy> gyaretto: lexProgram (x:y:xs), you need to handle the cases for 0 and 1 element lists
14:20:11 <dmwit> aawe: Make it a .lhs
14:20:32 <aawe> dmwit: won't work, has to be extensionless
14:20:47 <dmwit> aawe: Tell ghci it's literate.
14:20:49 <glguy> null (x07:y07:xs)       07= [] 14--14 Probably doesn't do what you think
14:21:04 <fizbin> Taneb: Yes, it's graph manipulation code (the Node type is from Data.Graph.Inductive) but I cannot figure out why I would want to represent stuff at this point in the code with a Node and an Int.
14:21:10 <adamse> I'm getting `setup: ghc: on the commandline: cannot use `--interactive' with `--info'` when using haskell-mode with the idris codebase, anyone seens this?
14:21:13 <gyaretto> glguy: Hm. Ohkay. Thanks!
14:22:03 <gyaretto> > null ""
14:22:04 <funfunctor> dmwit: there isn't a way to provide a stub for it to wind up at?
14:22:05 <lambdabot>  True
14:22:12 <gyaretto> glguy: ^ That's what I'm going for.
14:22:50 <glguy> gyaretto null (x:y:z) is always False, because it's never an empty list. It always has two elements
14:23:13 <gyaretto> Oh. :o
14:25:08 <dmwit> funfunctor: Didn't I describe how to do that?
14:25:50 <funfunctor> dmwit: no?
14:26:42 <dmwit> aawe: Okay, I read some documentation. It doesn't seem easy.
14:27:00 <dmwit> aawe: Perhaps you can have a symbolic link with the appropriate extension to the extension-less version.
14:27:42 <dmwit> funfunctor: 14:15 < dmwit> e.g. document C'bladerf, mark its module as not-home, and re-export C'bladerf somewhere else.
14:28:41 <funfunctor> these late nights..
14:28:45 <funfunctor> ok thx
14:29:31 <aawe> dmwit: that sounds like a good solution
14:30:50 <funfunctor> dmwit: so not-home goes into where? I actually don't want C'bladerf documented at all
14:31:03 <funfunctor> it is meant to be hidden inside a type wrapped up
14:31:09 * hackagebot persona-idp 0.1.0.1 - Persona (BrowserID) Identity Provider  http://hackage.haskell.org/package/persona-idp-0.1.0.1 (frasertweedale)
14:31:31 <aawe> I am getting stuck... I want to pattern match on an IO String
14:31:39 <dmwit> not-home goes into the OPTIONS_HADDOCK clause of the module you won't be exposing
14:32:04 <dmwit> aawe: Pattern match on a String, then use fmap or (>>=) to teach your pure function how to handle IO.
14:32:26 <dmwit> fmap :: (String -> a) -> IO String -> IO a
14:32:42 <dmwit> (>>=) :: IO String -> (String -> IO a) -> IO a
14:33:08 <dmwit> (=<<) :: (String -> IO a) -> IO String -> IO a -- makes the parallel with fmap more obvious, perhaps
14:33:40 <aawe> dmwit: the problem is, I return a "type Script = EitherT String IO" monad (run :: FilePath -> [String] -> String -> Script String). I want to return Left err or Right IO result depending on the resuöt
14:33:42 <aawe> result
14:34:13 <funfunctor> dmwit: ok done, and what do you mean by re-export C'bladerf somewhere else.?
14:34:36 <dmwit> aawe: That's okay, fmap and (=<<) work for all monads.
14:34:55 <ReinH> @unmtl EitherT String IO a
14:34:55 <lambdabot> EitherT String IO a
14:34:57 <dmwit> funfunctor: If you want a thing to be documented, it has to be exported from a module that's not hidden.
14:35:03 <ReinH> Ok, thanks lambdabot
14:35:12 <dmwit> IO (Either String a)
14:35:18 <ReinH> dmwit: yes
14:35:39 <funfunctor> dmwit: but I don't want it documented, I just want haddock to shut up about it.. i.e. send it to a null doc / stub doc
14:35:46 <ReinH> The point being, you can't get an Either String (IO a) out of it
14:35:49 <S11001001> aawe: that wouldn't be a monad, unfortunately.  You have to have IO either way as dmwit just pasted
14:36:10 <funfunctor> dmwit: newtype DeviceHandle = DeviceHandle { unDeviceHandle :: Ptr C'bladerf }  the pointer should never be seen
14:36:19 <dmwit> S11001001: huh? EitherT String IO is a perfectly good monad.
14:36:35 <aawe> dmwit, S11001001: check out the errors package (Control.Error.Script), it somehow works anyway
14:36:36 <S11001001> dmwit: I mean "Left err or Right IO"
14:36:46 <dmwit> funfunctor: If it's complaining about not knowing what link to make, it must be visible from somewhere.
14:37:11 <funfunctor> dmwit: can't I just fabricate a link in a comment?
14:37:18 <dmwit> S11001001: Shorthand for EitherT (Left err) or EitherT (Right io), I expect.
14:37:41 <S11001001> aawe: it is IO (Either err a), as dmwit posted.
14:37:49 <dmwit> funfunctor: Well, hacking on haddock would be another route, I suppose.
14:38:14 <aawe> S11001001: scriptIO :: MonadIO m => IO a -> EitherT String m a
14:38:14 <S11001001> dmwit: eh, I can't decrypt this untyped typey stuff
14:38:22 <aawe> S11001001: type Script = EitherT String IO
14:38:29 <S11001001> aawe: yes.
14:38:44 <athan> Is there a `mconcat` for Alternative?
14:38:47 <funfunctor> yea I think your right.. it needs some work here because bindings are sort of corner case I guess
14:39:00 <S11001001> aawe: I am making the point ReinH made, you cannot get Either String (IO a) out of it.
14:39:19 <dmwit> aawe: Why don't you go ahead and tell us the exact problem you're having. Otherwise S11001001 and I and others are just guessing.
14:39:26 <dmwit> ?hpaste some code and your exact error
14:39:26 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:03 <dmwit> athan: asum
14:40:11 <athan> thanks dmwit :)
14:40:21 <dmwit> athan: https://www.haskell.org/hoogle/?hoogle=Alternative+f+%3D%3E+[f+a]+-%3E+f+a
14:40:25 <aawe> dmwit: I think I'm solving it now
14:42:46 <aawe> how do I easily create a string exception? I want to avoid creating a new type for it
14:43:45 <Axman6> error?
14:43:56 <athan> aawe: How about using an `Either String Foo`?
14:44:02 <Axman6> but, also think twice about using exceptions at all if you can avoid it
14:44:59 <aawe> athan: why? I need IO
14:45:16 <athan> aawe: It's more pure and type-safe :)
14:45:44 <athan> aawe: But `error` usually gets the job done
14:45:56 <athan> your program will stop when it hits the command, though!
14:46:18 <Axman6> well,  it throws an ErrorCall exception, so i can be caught
14:47:39 <S11001001> aawe: exceptions aren't great for error reporting
14:47:59 <S11001001> > length [error "please stop!", error "stop it now!"]
14:48:01 <lambdabot>  2
14:48:25 <S11001001> aawe: they cannot be relied upon to report errors as you see above.
14:48:29 <athan> Axman6: Oh... I didn't know sorry :( NOT THE STICK
14:49:08 <athan> > deepseq $ length [error "please stop!", error "Not the stick!"]
14:49:09 <lambdabot>  Not in scope: ‘deepseq’
14:49:14 <aawe> S11001001: Don't worry, error reporting is handled for me and the thunks are forced
14:49:33 <S11001001> aawe: how are you verifying that?
14:49:41 <aawe> S11001001: using scriptIO
14:49:54 <aawe> and lines
14:50:13 <aawe> and IO
14:50:21 <S11001001> aawe: those don't check that all your thunks are forced.
14:50:41 <glguy> error isn't intended to be a reliable way to send information around about your program. GHC can/will collapse multiple calls to error into the same thing picking one of the error messages
14:50:52 <S11001001> aawe: if you are wondering, athan's line would have also evalled to 2.
14:50:55 <aawe> length . lines definitely forces a string
14:51:54 <S11001001> aawe: great, so your answer is "be careful"
14:52:00 <aawe> glguy, S11001001: how would you do this without error then? http://lpaste.net/561657529042468864
14:52:07 <S11001001> aawe: because you need to force that then too
14:53:18 <S11001001> aawe: with throwError from Control.Monad.Error.Class, which has a sensible instance for Script
14:53:52 <S11001001> aawe: and invoke scriptIO on the LHS of the >>= not the whole thing
14:54:56 <S11001001> aawe: which will make it so the monad you are operating in for your 'case' is Script, rather than IO.
14:55:42 <athan> shoot :(
14:56:09 <S11001001> athan: serendipitous
14:57:34 * funfunctor just fell inlove with Yi text editor
14:57:47 <athan> S11001001: But, if `deepseq` were appied to the list, then the exception would be thrown before the lazy computation. Maximum derp
14:57:48 <funfunctor> its ViM but not old
14:58:16 <S11001001> aawe: as I understand the intended style, it is desirable to scriptIO "primitive" IO actions that you are calling on, bringing them into Script, as soon as possible, so you can use the throwError and catchError capability to avoid exceptions.
15:00:01 <aawe> ok, my new function didn't solve it
15:01:28 <aawe> "fd:10: hGetContents: invalid argument (invalid byte sequence)", "_result :: IO (ExitCode, String, String)", "Logged breakpoint at git-stats.hs:13:19-57" which is the runProcess line
15:01:51 <geekosaur> that's usually a locale issue
15:04:12 <aawe> could it be binary output?
15:06:09 <btcNeverSleeps> funfunctor: editors war!  :)  Seriously, I'm totally into Emacs: magit, dired, ace-jump (vim's easymotion), paredit/smartparens, multiple-cursors, erc, ... I've got about 2 000 lines of custom elisp "configuration" lines in my Emacs setup :)
15:08:56 <btcNeverSleeps> Emacs's ace-jump / vim's easymotion is the one functionaly I totally and definitely need and cannot live without anymore. I'm not ever using a text editor which doesn't have it :)
15:09:20 <funfunctor> btcNeverSleeps: I was just reading this short paper http://publications.lib.chalmers.se/records/fulltext/local_72549.pdf
15:10:37 <aawe> it's binary :(
15:11:02 <creichert> btcNeverSleeps: seen smex yet?
15:13:25 <aawe> any package like process that works on bytestrings?
15:15:38 <bitemyapp> aawe: https://hackage.haskell.org/package/process-extras ?
15:16:03 <ultra_Sabreman> So I'm working on my final project for class
15:16:24 <ultra_Sabreman> Game of life, It's going really well: http://i.imgur.com/pFkxWTQ.gif
15:16:33 <ultra_Sabreman> I'm really liking haskell
15:16:34 <aawe> bitemyapp: perfect, thank you very much
15:19:32 <gyaretto> I have successfully written the basic functionality of a lexer in Haskell! :D
15:20:20 <bitemyapp> aawe: np
15:20:30 <btcNeverSleeps> creichert: of course I'm using smex, it's nothing like ace-jump/easy-motion.  The two are totally complementary :)
15:20:51 <creichert> btcNeverSleeps: yea, i don't know why i said that :) I guess projectile,ido,smex popped into my head :)
15:21:31 <btcNeverSleeps> creichert: I'm using all these... projectile being a recent addition but it seems to be great!
15:25:02 <btcNeverSleeps> funfunctor: Yi seems very nice that said...
15:25:12 <btcNeverSleeps> funfunctor: thanks for the PDF link btw
15:36:12 * hackagebot barrier 0.1.0 - Shield.io style badge generator  http://hackage.haskell.org/package/barrier-0.1.0 (HirotomoMoriwaki)
15:44:19 <Lokathor> how does one compile a program with GHC/cabal (on windows) so that it packages the requird .dll files into the resulting .exe?
15:44:27 <Lokathor> is that what the -static flag does?
15:46:08 <Lokathor> (it's hard to search for this because - will exclude terms from a goole search)
15:46:12 * hackagebot language-ecmascript-analysis 0.9.1 - JavaScript static analysis library.  http://hackage.haskell.org/package/language-ecmascript-analysis-0.9.1 (AndreyChudnov)
15:46:38 <geekosaur> try doublequoting
15:46:54 <geekosaur> (although then I think you get bit by it ignoring symbol chars...)
15:50:06 <Lokathor> hmm
15:50:13 <Lokathor> http://stackoverflow.com/questions/4360990/how-to-build-a-program-so-that-it-doesnt-require-dlls
15:50:19 <Lokathor> this seems to cover what i'm looking for
15:50:57 <Lokathor> but the answer for my specific situation seems to be, "you can do that using sdl2, since sdl2 provides DLLs not static libs"
15:53:29 <Polarina> Lokathor, you can order pkg-config to give configuration that will statically link SDL2.
15:54:08 <Lokathor> does that involve me rebuilding SDL2.dll myself?
15:54:53 <Polarina> Lokathor, if you didn't build SDL2 yourself, then yes. But you want a .lib, not a .dll for static linkage.
15:55:39 <Lokathor> ah. well right now i'll just suffer with an extra file then
15:56:09 <Polarina> :)
15:56:12 * hackagebot hOpenPGP 2.0 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.0 (ClintAdams)
15:56:14 * hackagebot hlibBladeRF 0.1.0.1 - Haskell binding to libBladeRF SDR library  http://hackage.haskell.org/package/hlibBladeRF-0.1.0.1 (eocallaghan)
16:01:13 * hackagebot hopenpgp-tools 0.14 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.14 (ClintAdams)
16:46:15 * hackagebot liquid-fixpoint 0.2.3.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.3.0 (EricSeidel)
16:46:17 * hackagebot liquidhaskell 0.3.1.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.3.1.0 (EricSeidel)
16:53:18 <perebor> what is the best way to install haskell on freebsd?
16:55:03 <perebor> specifically, if I install haskell-platform from ports how do I update cabal?
16:56:36 <pacak> perebor: At least in linux I have  separate installed copy of ghc under /usr/local so my experiments won't break xmonad. This allows to switch between different ghc
17:03:41 <perebor> if I run cabal install cabal-install it finishes successfully. but cabal --version is still old. do I need to point my path somewhere? is there documentation?
17:04:43 <pacak> If you run cabal install cabal-install as  user new cabal probably ends up in your ~/.cabal/bin
17:06:16 * hackagebot nagios-check 0.2.1 - Package for writing monitoring plugins  http://hackage.haskell.org/package/nagios-check-0.2.1 (fractalcat)
17:09:55 <meoblast001> hi
17:10:02 <meoblast001> is it possible to pattern match a partially applied constructor?
17:10:32 <hpc> no
17:10:38 <hpc> a partially applied constructor is a lambda
17:10:43 <meoblast001> ouch :X
17:10:43 <meoblast001> okay
17:10:45 <meoblast001> hmmm
17:12:00 <meoblast001> i have a solution
17:12:02 <meoblast001> thanks
17:32:18 <Lokathor> meoblast001, you can pattern match on the fully applied constructor with the other elements being ignored by using _ for the other elements
17:36:14 <Zemyla> Dammit, I don't want to actually write programs in Haskell, just do type fuckery :<
17:41:08 <meoblast001> Lokathor: i just decided to make an intermediate type and then something which converts everything over to the full type
17:41:37 <Lokathor> well i guess if that's simpler in your specific case
17:46:44 <Zemyla> Unfortunately, we already have an Edward Kmett.
17:47:58 <HeladoDeBrownie> Zemyla, i don't think there's any evidence he *just* wants to play with types :P
17:49:04 <peddie> Zemyla: have you considered agda?
18:09:41 <carter> agda has dependent records
18:09:46 <carter> which are very mind blowing
18:10:11 <carter> 'cause dependent records are kinda the generalization of existentials kinda
18:13:06 <jle`> meoblast001: you can also only mattern match on certain fields if your constructor has records
18:13:23 <jle`> data Foo = Foo { fooInt :: Int, fooBool :: Bool }
18:13:38 <jle`> stuff (Foo { fooInt = i }) = i + 3
18:14:28 <jle`> if your thing has many records than this could be more expressive than something like Foo _ _ _ i _ _ = ...
18:17:35 <hiptobecubic> @pl \acc c -> g (ord c) acc
18:17:35 <lambdabot> flip (g . ord)
18:25:13 <schoppenhauer> hello. (how) can I compile some .hs file such that I can load it in ghci?
18:25:59 <schoppenhauer> because loading it takes long ...
18:26:11 <schoppenhauer> and probably precompiling is easier.
18:26:34 <geekosaur> ghc -c whatever.hs but you won't have source available and only exported symbols
18:27:01 <geekosaur> there is currently no way to save bytecode so it would have to be recompiled each time
18:27:50 <schoppenhauer> what does ghc -c produce? can I load it in ghci?
18:28:12 <geekosaur> it produces a .o file and a .hi file
18:28:32 <geekosaur> you can load it but again, you only get exported names/types in ghci and it can't show you source
18:28:53 <schoppenhauer> what types are exported?
18:29:19 <schoppenhauer> do I have to declare them exported somehow?
18:29:23 <schoppenhauer> or is this the default
18:29:28 <geekosaur> whatever you list in the module header: module Name (export list) where
18:29:35 <geekosaur> if there is no export list then everything is exported
18:29:40 <schoppenhauer> ah ok.
18:29:46 <schoppenhauer> so then everything is exported
18:30:20 <meoblast001> jle`: yeah. i think i need more record syntax in what i'm doing
18:30:35 <schoppenhauer> thx
18:32:31 <schoppenhauer> geekosaur: how can I import it?
18:33:05 <geekosaur> hm? the usual :load should work. if you want to import it as a module then you need to register it as a module
18:33:30 <geekosaur> which takes a bit more work and it's easiest to just make a cabal package out of it
18:34:58 <ttt_fff> what's good stuff to read on for logic programming in haskell? i.e. equiv of prolog/mini-kanren ... but I want somethign embedded in haskell, not an interpreter written in haskell
18:35:52 <peddie> ttt_fff: LogicT
18:36:23 <peddie> ttt_fff: http://okmij.org/ftp/Computation/monads.html#LogicT
18:36:59 <ttt_fff> peddie: nice; thanks!
18:37:14 <peddie> enjoy :)
18:39:03 <schoppenhauer> thx again
18:50:27 <HeladoDeBrownie> in general terms, how does one compute exhaustivity of a case expression's cases?
18:51:19 <shachaf> There's a paper from two days ago: http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm.pdf
18:51:31 <MagBo> I love #haskell
18:51:33 <HeladoDeBrownie> shachaf, thanks!
18:51:42 <MagBo> “There's a paper from two days ago” <3
18:54:13 <carter> its a pretty neat paper
19:00:00 <octopuscabbage> book reccomendation for intermediate (kind of) haskeller
19:00:02 <octopuscabbage> ?
19:00:40 <shachaf> What is intermediate?
19:00:59 <octopuscabbage> i understand monads and applicatives and the other basic typeclasses, i have several small toy projects
19:01:29 <dmj`> octopuscabbage: parallel and concurrent programming in haskell and the typeclassopia
19:01:35 <dmj`> typeclassopedia*
19:01:51 <octopuscabbage> dmj`, i read the typeclasseopedia
19:02:04 <dmj`> octopuscabbage: and all of the linked articles?
19:02:07 <octopuscabbage> dmj`, i should buy paronic, i printed a bit of it out to see if i'd like it and started it but i got busy
19:02:15 <octopuscabbage> dmj`, not all the linked articles
19:02:18 <dmj`> octopuscabbage: parconc book is free
19:02:27 <octopuscabbage> dmj`, i mean the physical copy
19:03:37 <dmj`> octopuscabbage: it's very good, really explains lazy evaluation, concurrency portion is great
19:04:18 <octopuscabbage> dmj`, really the only reason i don't own it is that there's not a cheap used copy on amazon haha
19:22:52 <glguy> Anyone have a favorite regular expression library? I plan to be matching lots of things with the same regular expression, so if it can compile down to an efficient state machine that'd be neat, lack of external c library dependency a bonus :)
19:23:36 <shachaf> Why is it a bonus?
19:23:45 <shachaf> Oh, I guess you mean dynamic linking.
19:23:55 <peddie> glguy: regex-tdfa* has treated me well
19:26:51 <hjulle> I don't understand why this function is implemented like this: http://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Monad-Free.html#v:cutoff. The output of the last action executed (when n=0) is ignored, even if it was already Pure a and that value could have been returned instead. I can't figure out in what circumstances this behaviour would be preferable.
19:30:55 <hjulle> In most cases it probably doesn't do much harm either, but if you choose the functor to be IO, it will run the last IO action, but you can't collect the results from it if the function did halt there. 
19:35:38 <glguy> shachaf: I was just thinking it'd be nice if the client could be installed just using cabal and not separately installing C libraries
19:36:33 <shachaf> Sure. But it could still include a C library.
19:37:52 <hjulle> Example in Free [] Int: cutoff 1 (liftF [4,5]) == Free [Pure Nothing,Pure Nothing]. This means that it "executed" the list "action", but for no use, since it threw away the results anyways.
19:50:08 <gyaretto> I'm having trouble thinking functionally. I'm writing a lexer and I'm unsure how to keep track of the line number and position of each token. https://github.com/garrettoreilly/doompiler/blob/master/src/Lexer.hs
19:50:19 <gyaretto> I'm new to Haskell, sort of.
19:51:10 <erisco> gyaretto, can you be a bit more specific? a type you might try is [(Int, Int, Token)] for (line #, col #, token)
19:52:30 <gyaretto> erisco: I'd like to make the line and position part of the Token data type. Right now, I'm just passing 0's for all of them.
19:53:30 <erisco> hm, that is an odd choice to make because then tokens at different positions are nonequal
19:54:14 <gyaretto> I don't think that will be an issue. I don't think I'll be comparing them.
19:54:42 <erisco> that isn't really the point :) but no matter, worry about it later
19:55:01 <erisco> you might want to transform your input into something easier to work with
19:55:10 <erisco> > zip [0..] "hello world!"
19:55:11 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9,...
19:55:33 <erisco> say you did that to your input, now you know the character index as you iterate over it
19:55:59 <gyaretto> :o
19:56:04 <erisco> you can adapt this to be line and column numbers instead
19:56:10 <gyaretto> I hadn't thouht of that.
19:56:33 <gyaretto> I'll give that a try. Thanks!
19:56:38 <erisco> good luck!
19:56:43 <erisco> I am going to bed
20:29:38 <jrock> howdy, would someone help me out with installing ekmett's quine package?
20:32:36 <glguy> Your best bet is to ask about the specific problem you're having rather than to wait for someone to commit to helping with an unknown issue
20:36:14 <jrock> Thanks. I'm running Ubuntu 14.04 with ghc 7.8.4 / cabal 1.20 -- I git cloned the quine repo, cabal sandbox init && cabal install'd. Meanwhile, I have SDL2 2.0.3 installed on the box. All of my dependencies were able to be built; however, when it gets to building the quine package itself, I get all kinds of madness referring to the SDL C code.
20:37:03 <jrock> Lots of "error: storage class specified for parameter *" and "declaration for parameter * but no such parameter"
20:38:30 <Javran> http://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-7.8.4/Type.html#t:Type -- I'm wondering why Type's constructors are not shown in the document, while the module does export them?
20:39:19 <shachaf> Javran: Does it?
20:40:00 <Javran> shachaf: I can only find them in source code, but nowhere in the document
20:40:29 <shachaf> Where do you see that it exports them?
20:40:33 <heatsink> jrock: It sounds like the compiler is getting ill-formed C code.  Are there any errors about include files?
20:41:19 <glguy> http://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-7.8.4/src/Type.html#Type
20:41:27 <glguy> It does not export then
20:41:48 <glguy> It's confusing because they are exported from TypeRep
20:41:58 <Javran> oops, should be TypeRep, yes
20:42:00 <glguy> But you're looking at the Type module
20:42:29 <jrock> heatsink: The errors come from the following, mostly: /usr/include/x86_64-linux-gnu/sys/types.h, /usr/include/SDL2/SDL_stdinc.h, /usr/include/SDL2/SDL_main.h, /usr/include/SDL2/SDL.h
20:43:05 <Javran> glguy: I see, the "source" link takes me to "TypeRep", I didn't realize that
20:43:44 <shachaf> I see where the confusion was.
20:48:07 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121571
20:48:09 <heatsink> jrock: I think it's necessary to see the problem code.  Can you reduce it to just the step where the C compiler runs on a file?
20:48:41 <heatsink> jrock: That would be by getting a local copy of the repository and building it with verbose output
20:48:51 <funfunctor> Hi, i'm having issue getting this Storable instance to work properly?
20:49:09 <Axman6> are you?
20:49:11 <funfunctor> See paste, lines 27-30
20:49:49 <funfunctor> I realise line 27 is wrong because I can't pattern match on that but I am not sure how to fix it
20:50:10 <jrock> heatsink: the log tells me exactly what command it ran: a very length gcc compile line. I'm going to try and reinstall SDL2 first; I'm not sure I installed it correctly.
20:52:46 <heatsink> funfunctor: fromList [v0 :+ v1] creates a complex number, puts it in a list of length 1, and converts it to an SCVector
20:53:34 <heatsink> funfunctor: poke should do the opposite: convert an SCVector to a list, produce an error if the list's length is not 1, take the first value from the list, and take its real and imaginary parts.
20:53:48 <heatsink> funfunctor: That would be done with code, not pattern matching
20:54:27 <ttt_fff> i know how to add "deriving (generic)" to my own data declarations. However, how do I add this to haskell libs? for example [a] or Data.Map.StrictMap k v ? <-- how do I add "deriving (generic)" to these pre-existing haskell libs ?
20:55:05 <heatsink> funfunctor: It is weird that you have a Vector whose length must be 1
20:55:19 <Axman6> there is syntax for 'deriving instance Generic Foo', can't remember how to enable it
20:55:20 <pacak> ttt_fff: Use standalone deriving
20:55:41 <ttt_fff> pacak: do I have to implemeng the "instance Generic ... where" myself?
20:55:46 <pacak> Nope
20:55:55 <ttt_fff> beuase I'd prefer it to just do "instance Generic .. where do whatever the fuck the default thing to do would be"
20:55:58 <ttt_fff> pacak: what do I do instead?
20:56:20 <ttt_fff> GIVE ME THE LNES OF CODE :-)
20:56:23 <S11001001> ttt_fff: however, better still would be to carpet bomb Generic, Data, and Typeable everywhere that compiles with them
20:56:33 <alexi5> hello
20:56:40 <S11001001> upstreaming
20:56:47 <funfunctor> heatsink: yea I was trying to figure out how to do it properly
20:56:48 <alexi5> hi everyone
20:56:52 <pacak> StandaloneDeriving pragma
20:57:01 <mzero> hi alexi5
20:57:24 <S11001001> alexi5: hi!
20:57:39 <alexi5> i am interesting in using  learning how to  program in functional programing
20:57:52 <alexi5> and was wondering if it is best to start with haskell ?
20:57:54 <mzero> @where LYAH
20:57:54 <lambdabot> http://www.learnyouahaskell.com/
20:57:58 <mzero> yes, yes it is
20:59:14 <funfunctor> heatsink: can I generalise this with peek poke Array or something?
21:00:12 <Lokathor> alexi5, http://www.seas.upenn.edu/~cis194/spring13/lectures.html is also a very good introduction, better than LYAH in some ways
21:00:20 <pacak> ttt_fff:  and then "deriving instance Show Foo"
21:00:40 <ttt_fff> pacak: noted, thanks
21:00:44 <heatsink> funfunctor: SCVector does not have a constant size, so it should not be an instance of Storable
21:00:57 <enthropy> ttt_fff: https://hackage.haskell.org/package/th-reify-many can help... I think there's a package that uses it specifically for Generic
21:01:06 <bob_twinkles> @where rwh
21:01:07 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:01:20 <bob_twinkles> ^ also useful if you get tired of LYAH's tone
21:01:39 <funfunctor> heatsink: but if I fixed the vector length
21:02:02 <alexi5> thanks guys
21:02:24 <heatsink> Curently you have fixed the vector length to 1, so SCVector is isomorphic to Complex Int16.
21:02:42 <Lokathor> beware, RWH suffers from bitrot in a few places
21:03:01 <Lokathor> not till later on though
21:04:28 <heatsink> funfunctor: What do you want to use that code for?
21:04:33 <funfunctor> heatsink: currently yes, I was going to extend it to n later
21:04:48 <funfunctor> heatsink: a stream of IQ points for QAM modulation
21:06:12 <heatsink> How long is a stream of IQ points for QAM modulation?
21:06:53 <funfunctor> heatsink: lets say 1024 sample chunks
21:07:27 <funfunctor> heatsink: maybe its easier to serialise to bytestring and back?
21:08:31 <heatsink> It is easier to convert it to list and back
21:08:39 <heatsink> If you have a list, you can use peekArray and pokeArray
21:10:43 <alexi5> what some tips you guys can offer in  become profficient in using recursion technqiues ?
21:11:25 <heatsink> become proficient by practicing and becoming proficient
21:11:51 <ttt_fff> https://gist.github.com/anonymous/af531c3e79143570e9a9 <-- wtf is wrong with this
21:11:55 <ttt_fff> why can't I standaone derive ?
21:11:55 <heatsink> The first examples you will practice with are lists
21:12:02 <ttt_fff> I have the flag set in my *.cabal file
21:12:23 <alexi5> ok
21:12:35 <funfunctor> heatsink: so how to do poke part? maybe I can rework the peek part for more than n=1 myself
21:12:37 <heatsink> I think LYAH has list examples
21:12:48 <Lokathor> alexi5, the key to recursion, particularly in haskell, is to know when to do it "manually", and when to use a library function that does what you want
21:13:21 <Lokathor> especially map, foldr or foldl', and filter
21:13:45 <heatsink> I think you normally learn to do it manually before you learn to use appropriate library functions
21:14:21 <Lokathor> indeed, but once you know what it's doing, using a library function is often better because you'll understand what you're looking at later on
21:15:47 <heatsink> funfunctor: pokeArray p (Data.Vector.toList v)
21:16:15 <heatsink> funfunctor: That will work after you define Storable (Complex Int16)
21:19:08 <heatsink> funfunctor: pokeArray calls 'poke' on each element of the list, and computes the right pointer offsets
21:19:16 <heatsink> for the array elements
21:23:48 <Rotaerk> is there anything "wrong" with a monad transformer that only works for a subset of monads? e.g. a transformer that only works for MonadIO instances
21:24:21 <johnw> well, it would just be a MonadIO transformer, I guess
21:24:25 <Rotaerk> yea
21:24:46 <johnw> why bother with the abstraction then?
21:27:29 <Rotaerk> johnw, I'm tentatively calling this AtomicT, which is similar to EitherT, except that each action can optionally produce "undo" actions, which get accumulated as each action succeeds.  if the entire thing succeeds, then these undo actions are disposed of, but if the "left" value is ever produced, the undo actions accumulated so far are executed
21:28:49 <Rotaerk> johnw, and I can't think of how that could be useful to anything but an underlying IO monad
21:28:50 <heatsink> What does it need in addition to Monad
21:29:22 <heatsink> Rotaerk, it could also be useful for ST
21:29:31 <peddie> whoa, Rotaerk, I've just built some similar thing for work -- curious to hear what your version is for or how it works
21:29:50 <heatsink> to undo changes to mutable data structures
21:30:21 <Rotaerk> heatsink, true; I suppose I could leave it generalized
21:30:36 <Rotaerk> even if it'd probably be useless for a lot of underlying monads
21:31:37 <Rotaerk> peddie, nothing exciting; the abstraction just occurred to me while writing some utility functions for opengl (which I'm still learning)
21:31:43 <Rotaerk> which are kind of ugly without it
21:32:33 <peddie> Rotaerk: I see, mine is for doing HTTP calls with JSON data, and wanting it to work for any FromJSON/ToJSON instance made the types a bit painful
21:32:49 <Rotaerk> in my case, I've got a tryBuildShader which is an EitherT e io Shader, and then I made a tryBuildShaders which is EitherT e io [Shader]
21:32:51 <peddie> was wondering whether you'd come up with a nicer way :)
21:33:13 <Rotaerk> except in tryBuildShaders, if it fails along the way, I want any shaders that have been built-so-far to be disposed of
21:33:19 <peddie> I see
21:33:37 <peddie> so you roll back the list you're accumulating, including any OpenGL calls you've made to create the individual ones?
21:34:12 <johnw> Rotaerk: it sounds a lot like ResourceT, but where you are creating a group of resources atomically, rather than using resources
21:35:10 <Rotaerk> hmm
21:35:37 <johnw> the main difference being that you want the cleanup action to be disposed of on success
21:36:00 <Rotaerk> yea it'd be bad to cleanup the shaders at the end if they do all succeed
21:36:09 <Rotaerk> but it does look interesting...
21:36:18 <Rotaerk> wasn't aware of ResourceT
21:36:55 <johnw> there is also SafeT, which does the same thing
21:37:56 <Rotaerk> johnw, my searches aren't turning up SafeT anywhere
21:38:47 <Rotaerk> ah, hayoo knew about it... hoogle didn't
21:39:17 <Rotaerk> think I'll proceed with AtomicT though, because they don't seem to be exactly what I want
21:39:32 <johnw> oh, what you have is different
21:39:46 <johnw> but I thought maybe you'd see how they relate to MonadIO (if they do)
21:40:11 <Rotaerk> ah
21:41:53 <debnathshoham> Hello everyone. I am looking forward to contributing to haskell. Can anyone please guide me through.
21:42:02 <Rotaerk> lol
21:42:29 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
21:42:40 <Rotaerk> debnathshoham, you'll need to ask something more specific than that :P
21:44:24 <debnathshoham> Rotaerk: the ideas page seems a bit confusing for a beginner like me. :P
21:44:42 <Lokathor> step 1: install haskell platform; step 2: follow tutorials and learn what to do; step 3: uninstall the haskell platform :P
21:44:49 <Rotaerk> heh
21:45:08 <Rotaerk> someone in here should be able to offer a good suggestion for a resource
21:45:19 <Rotaerk> I learned from learn you a haskell, but that's no longer recommended these days
21:45:31 <mniip> why not
21:45:35 <Rotaerk> I don't really know
21:45:45 <Lokathor> that lecture series is honestly a good resource, though you have to be sure to read the suggested reading sections of LYAH as well
21:45:46 <mniip> great tutorial
21:45:54 <Rotaerk> but people don't seem to like to recommend lyah it seems
21:46:30 <Lokathor> mniip, if i had to say why LYAH isn't suggested more, I'd guess it has to do with the lack of exercises
21:46:35 <Rotaerk> maybe this:  https://github.com/bitemyapp/learnhaskell
21:46:56 <mniip> hm
21:47:11 <Rotaerk> (I haven't gone through that, but I've seen in recommended here a few times)
21:47:15 <Lokathor> LYAH is more like a reference tome of sort, not like a thing that makes you learn what you're doing
21:47:35 <heatsink> learnhaskell recommends the upenn course
21:47:39 <Lokathor> Rotaerk, that github is what suggested to me the cis194 actually :3
22:01:39 <perebor> I updated cabal through cabal install cabal-install and it segfaults on me now. on freebsd. any ideas?
22:03:21 <Lokathor> well, if you 'cabal install cabal-install', the old cabal should also be there somewhere
22:03:48 <Lokathor> so use the old cabal to rebuild the newer cabal using a different set of flags or... something?
22:21:32 * hackagebot temporal-csound 0.4.2 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.2 (AntonKholomiov)
22:21:34 * hackagebot temporal-csound 0.4.3 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.3 (AntonKholomiov)
22:21:59 <L8D> how can I show a Double without a trailing .0 ?
22:24:42 <Lokathor> :t (init . init . show)
22:24:43 <lambdabot> Show a => a -> [Char]
22:25:09 <Lokathor> that's the simplest, if it's always the .0 you wanna drop
22:25:40 <Cale> uhhh
22:25:44 <fro_ozen> you could use floor as well though
22:25:50 <Lokathor> there's also Text.printf
22:25:57 <fro_ozen> but you'd have to make sure it's actually .0
22:26:01 <L8D> I just did I workaround by checking if `mod'` 1 == n
22:26:22 <Cale> Or perhaps round or truncate
22:26:32 * hackagebot temporal-csound 0.4.3.1 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.3.1 (AntonKholomiov)
22:37:44 <dmwit> > printf "%.0f" 3.0 :: String
22:37:46 <lambdabot>  "3"
22:37:48 <dmwit> > printf "%.0f" 3.05 :: String
22:37:49 <lambdabot>  "3"
22:38:10 <dmwit> :t stripPrefix
22:38:11 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
22:39:19 <dmwit> > reverse . (\s -> fromMaybe s (stripPrefix "0." s)) . reverse . show $ 3.05
22:39:21 <lambdabot>  "3.05"
22:39:23 <dmwit> > reverse . (\s -> fromMaybe s (stripPrefix "0." s)) . reverse . show $ 3.0
22:39:24 <lambdabot>  "3"
22:40:23 <lpaste> glguy pasted “rendering floats” at http://lpaste.net/121578
22:40:50 <glguy> That's how I ended up writing it for doing the labels on my slide rule
22:41:34 <dmwit> ?hoogle floatToDigits
22:41:35 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
22:41:56 <Cale> I feel like there has to be something which uses showFFloat
22:42:11 <Cale> :t showFFloat
22:42:11 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
22:42:25 <Cale> > showFFloat (Just 1) pi ""
22:42:26 <lambdabot>  "3.1"
22:42:29 <Cale> > showFFloat (Just 0) pi ""
22:42:30 <lambdabot>  "3"
22:42:35 <Cale> > showFFloat (Just 4) pi ""
22:42:37 <lambdabot>  "3.1416"
22:43:11 <dmwit> > showFFloat Nothing 3 ""
22:43:12 <lambdabot>  "3.0"
22:45:26 <dmwit> > floatToDigits 10 pi
22:45:27 <lambdabot>  ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
23:41:29 <jle`> > floatToDigits 10 (pi * 10)
23:41:30 <lambdabot>  ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],2)
23:41:35 <jle`> oh neat
23:51:26 <jle`> did you all know, fortran had type inference this whole time
23:51:39 <jle`> since at least as far back as f77
23:51:47 <jle`> haskell is late to the party
23:52:07 <jle`> it wasn't exactly hindley-milner though
