00:29:44 * hackagebot hydrogen-prelude 0.20 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.20 (JulianFleischer)
00:38:06 <troll-> haskell is fookin shite
00:38:09 <troll-> motherfuckers
00:38:14 <troll-> fuck dis shit
00:38:20 <troll-> bitchass n1ggaz
00:38:34 <troll-> fu fu fu fu fu fu fu fu fu fu fu fu fu
00:39:00 <troll-> haskell is garbage
00:39:09 <troll-> BITCH
00:39:34 <troll-> fu
00:39:58 <troll-> fuck u
00:40:03 --- mode: ChanServ set +o shachaf
00:40:07 <troll-> fuck off
00:40:08 --- mode: shachaf set +b *!*4d551e8e@*.77.85.30.142
00:40:08 --- kick: troll- was kicked by shachaf (troll-)
00:40:39 --- mode: shachaf set -o shachaf
00:43:10 <uwap> see, this is the generation of java developers =(
00:44:19 <yarou> i was going to say php developers, but i didn't have the heart to 
00:44:42 <uwap> wouldn't tell that a language problem though
00:44:55 <uwap> it is an educational problem
00:49:59 <aawe> uwap: we just need to spread the gospel: https://imgur.com/a/tiW5S/
00:51:09 <shachaf> Please, no language bashing in here.
00:52:08 <ttt_fff> https://news.ycombinator.com/item?id=9265084 <-- article on "programming by superstition" <-- is Haskell also like this? (take some example code, modify it) or is it (2) read docs, (3) write beautiful code ?
00:54:01 <aawe> ttt_fff: I have seen very little haskell code that can be copypasted and slightly modified - there is no boilerplate to keep copying
00:54:25 <ttt_fff> boilerplate becomes monads
00:54:36 <aawe> "do" is not much boilerplate
00:54:54 <ttt_fff> i still struggle with this; instead of finding an example to modify, I end up having to ounderstand the type signatures of the functions to make them work together
00:55:06 <ttt_fff> aawe: no, but it gets thrown into ">>="
00:55:32 <uwap> imho haskell is more of learning some very powerful abstractions that enables you the power to do awesome things
00:55:47 <aawe> ttt_fff: it's a tradeoff between cognitive overhead (understanding types) and runtime errors
00:56:51 <aawe> on the polar opposite of the scale you have dynamic languages where you are barely aware of the types and get runtime errors to the extent you need a high percentage of test coverage
00:57:04 <aawe> would you rather spend a while grokking your types or write a full test suite?
01:02:14 <ReinH> aawe: types lessen the cognitive overhead for me.
01:02:29 <ReinH> Having to figure out what a bunch of code does without types to guide me is what makes things difficult for me
01:03:27 <aawe> ReinH: sure, they help the construction of the program, but you don't invent the final types instantly
01:04:10 <ReinH> I'm just saying I don't think the tradeoff is between cognitive overhead and runtime errors
01:04:13 <ReinH> I get less of both
01:04:37 <ReinH> or fewer, if you prefer using words properly...
01:05:02 <shachaf> unmore
01:11:06 <ReinH> less overhead, fewer errors
01:11:18 <ReinH> words are hard
01:11:22 <shachaf> more overhead, more errors
01:11:34 <shachaf> No problem. The ambiguity is imaginary.
01:14:15 <aawe> does that mean unambiguity is unimaginary?
01:19:10 <_ryan> hi does anyone use fpcomplete IDE?
01:19:47 * hackagebot auto 0.2.0.6 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.2.0.6 (jle)
01:22:27 <xaimus> mdl
01:22:43 <xaimus> wrong window, sorry
01:49:51 <_ryan> hi does anyone use fpcomplete IDE?
01:49:57 <_ryan> hi does anyone use fpcomplete IDE?
01:52:47 <dmwit> RustyShackleford: Instead of "cabal clean; cabal configure; cabal build" you can just "cabal build" to rebuild without reconfiguring.
01:53:20 <dmwit> RustyShackleford: Also, nothing is stopping you from just running the test program yourself if you want, I guess. Nothing cabal does is magical, so you can just do what cabal would do if you want.
02:00:46 <solatis> fpcomplete has an IDE now?
02:00:52 <solatis> does that guy ever sleep?
02:08:20 <bartavelle> they had their web IDE for quite a while
02:49:47 <arbelos> "In a purely functional program all data is immutable, so all data structures are automatically fully persistent."
02:50:07 <arbelos> I am confused...
02:50:34 <ibid> about what?
02:50:44 <arbelos> If data is fully persistent, doesn't that mean you can access any previous state or version of the data
02:51:51 <ibid> not sure about the details, but basically yes.  in that quote, the implicit assumption is that you retain a reference to the previous version
02:52:15 <arbelos> ok, so it's more conceptually, that it is possible to write a program in such way
02:52:19 <ibid> there is no automatic history kept
02:53:16 <jle`> if i had x = [2,3,4], and y = 1:x, then y = [1,2,3,4].  the "original list", x, still exists
02:53:32 <ibid> arbelos: the point that is being made is that the act of modifying a data structure does not by itself destroy the old version
02:53:50 <ibid> arbelos: like what happens in the typical imperative hash table
02:54:21 <ibid> or even the typical imperative search tree
02:54:53 * hackagebot network-anonymous-i2p 0.10.0 - Haskell API for I2P anonymous networking  http://hackage.haskell.org/package/network-anonymous-i2p-0.10.0 (solatis)
02:55:23 <arbelos> ok, but if i would consider a list a data structure.. the history is not built in to the list. so i can't say by looking at [1,2,3,4] .. well, hmm. ok actually i can hehe
02:55:59 <ibid> arbelos: as i said, you must retain a reference to the version you want to access
02:56:09 <ibid> arbelos: but nothing more is required
02:56:57 <arbelos> ok
03:09:28 <arbelos> the statement all data is immutable => all data structures are fully persistent is a bit dubious though
03:09:38 <arbelos> but your explanation makes sense
03:12:03 <jle`> persistent is a word that in this context means that the "updating actions" of the abstract data type leave the original instance unchanged
03:12:21 <jle`> so if we look at something like Data.HashMap
03:13:07 <jle`> we see something like insert :: k -> a -> Map k a -> Map k a
03:13:21 <jle`> insert an `a` with key `k` into a `Map k a`
03:13:27 <jle`> you get a new map with the item inserted
03:13:35 <jle`> the old map that was there did not go away or change in any way
03:14:01 <jle`> persistent doesn't mean that every data structure has a log of every state in its history
03:16:12 <arbelos> well in this text it says "a persistent data structure is a data structure that always preserves the previous version of itself when it is modified."
03:16:40 <arkeet> that means 
03:17:07 <arkeet> if it's modified, and you hang on to the previous version, that previous thing is still valid
03:17:48 <arkeet> a trivial way to make any mutable structure persistent is to make a copy every time you mutate.
03:17:54 <arkeet> but that performs awfully.
03:18:14 <jle`> arkeet: preserves as in, does not erase.  not as in, maintains a link/reference to
03:18:20 <arkeet> yes.
03:18:22 <jle`> does not erase or modify
03:18:28 <jle`> sory, that was for arbelos 
03:18:56 <arkeet> you said it well.
03:18:57 <arkeet> :)
03:19:29 <arkeet> efficient persistent structures will generally maintain a reference to parts of the previous version though.
03:19:39 <arkeet> and only copy the parts that must be modified.
03:20:10 <arkeet> e.g. when modifying an element in a balanced binary tree, you only have to copy the path down to the modified element.
03:20:21 <arbelos> ok, but partial persistence then.. 
03:20:43 <arkeet> which lets you do updates in O(log n) instead of full copying.
03:21:00 <arbelos> "all versions can be accessed but only the newest version can be modified"
03:21:29 <arbelos> i mean.. saying that you can access all versions suggests that a history exists.. or?
03:21:43 <jle`> it's saying you can access it if you happened to have kept a reference lying around
03:21:43 <arkeet> if you hold a reference to every version of the structure, sure.
03:21:44 <arbelos> partial persistence being a weaker requirement
03:22:31 * arkeet is trying to think of an example of something that is only partially persistent.
03:22:49 <jle`> one example of a non-persistent data structure is a C array.  let's say you had an array x that has the numbers one through ten, and then you modified x so that every item now just has the number five
03:22:56 <hpc> arbelos: journaling filesystem?
03:23:08 <arkeet> jle`: or even just modify one of the items.
03:23:09 <hpc> er, versioning filesystem
03:23:10 <jle`> this is not persistent because there's no now way for you to ever access the original one thoruhg ten...even if you tried really hard from the very beginning
03:23:22 <arbelos> well, all of this makes sense if i would forget all about functional programming and implement a data structure in C
03:23:24 <arkeet> hpc: I guess anything with a linear history.
03:23:44 <jle`> we have persistent structures in C, too
03:24:01 <arkeet> arbelos: sure. in a purely functional language there is no such thing as mutation, so everything is automatically persistent.
03:24:36 <jle`> remember that these are typically properties of abstract data types.  data types that encapsulate their actual implementation and offer an outward "API"
03:26:05 <arbelos> so isn't effectively immutable and persistent the same thing when talking about data structures then?
03:26:50 <jle`> immutable data structures are automatically persistent...persistent data structures might possibly be implemented in a mutable way idk
03:26:58 <jle`> they're not exactly the same exact concept i don't think
03:30:47 * arbelos gets used to the idea that persistent does not mean "record keeping"
03:30:52 <arkeet> I suppose an example of a partially persistent structure implemented with mutation is uh.
03:30:59 <arkeet> this is maybe not realistic, but
03:31:32 <arkeet> given infinite memory, you can make a partially persistent queue where
03:31:50 <arkeet> elements are stored linearly in mempry
03:31:58 <arkeet> you hang on to start and end pointers
03:32:12 <arkeet> removing just increments the start pointer
03:32:22 <arkeet> inserting increments the end pointer and writes the appropriate thing to that location.
03:32:52 <arkeet> any pair of pointers you previous had is valid
03:33:12 <arkeet> but inserting on an old version might destroy newer versions
03:33:14 <arkeet> so it's not fully persistent
03:33:45 <arbelos> i mean, at some level everything is "mutable".. state is involved, but it is implicit
03:54:56 * hackagebot Nomyx-Language 0.7.6 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.6 (CorentinDupont)
03:54:58 * hackagebot machines-zlib 0.1.0 - Decompression support for machines  http://hackage.haskell.org/package/machines-zlib-0.1.0 (RobinGreen)
03:55:00 * hackagebot Nomyx-Web 0.7.6 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.6 (CorentinDupont)
03:55:02 * hackagebot Nomyx-Core 0.7.6 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.6 (CorentinDupont)
03:59:56 * hackagebot Nomyx 0.7.6 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.6 (CorentinDupont)
04:02:47 <Gurkenglas> Is (\f -> snd . head . toList . M.fromListWith f . map ((),)) akin to foldl1 or foldr1?
04:42:12 <Gurkenglas_> @src minimum
04:42:12 <lambdabot> minimum [] = undefined
04:42:12 <lambdabot> minimum xs = foldl1 min xs
04:42:31 <Gurkenglas_> Why the first line? Doesnt't foldl1 already take care of that case? minimum = fold1 min would be simpler.
04:42:43 <Gurkenglas_> *l
04:43:15 <EvanR> that looks more obvious
04:43:57 <EvanR> @src foldl1
04:43:57 <lambdabot> foldl1 f (x:xs) = foldl f x xs
04:43:57 <lambdabot> foldl1 _ []     = undefined
04:44:26 <EvanR> Gurkenglas_: the @src listings are carefully written to be obvious rather than minimal or efficient
04:44:35 <quchen2> Gurkenglas_: That's just how Lambdabot's database shows the source, it's not how minimum is actually implemented.
04:45:12 <quchen2> The real source reads
04:45:13 <quchen2> minimum []              =  errorEmptyList "minimum"
04:45:14 <quchen2> minimum xs              =  foldl1 min xs
04:45:26 <quchen2> So you get an error that says "hey, minimum failed"
04:45:42 <Gurkenglas_> Is there no stacktrace?
04:46:21 <quchen2> Not by default, no. It'll just print a non-descriptive line. (You can enable traces using some compiler flags though,  but I haven't used it in ages.)
04:46:26 <Axman6> there is no stack luke. at least not as you know it
04:47:19 <Gurkenglas> Axman6, because a thunk can be referenced by multiple others and choosing one would be bad style?
04:47:38 <EvanR> Gurkenglas: youd like it to choose thunk addresses? ;)
04:47:50 <EvanR> and show them
04:48:30 <Gurkenglas> No wait you could just have the trace go up to the first (uhh inventing names here) primitively named thunk upwards
04:48:38 <EvanR> named thunk?
04:48:42 <EvanR> upward?
04:48:55 <EvanR> i would love for some debug output to make sense
04:48:58 <Axman6> Gurkenglas: the way evaluation works (in GHC anyway) means that there isn't really a stack full of callers waiting for results, but more a stack of functions awaiting results of the current thunk (a la continuations). IIRC anyway
04:49:38 <Axman6> there is no history, only the future!
04:50:26 <EvanR> so the current context is basically, where am i going next
04:50:53 <EvanR> and that corresponds to some expression somewhere in the code, maybe
04:50:56 <Gurkenglas> "foo = getLine >>= print . minimum . parse", where minimum is implemented via foldl1 min directly, with parse returning [], would show that foldl1->minimum->foo was the culprit, but no further. That'd work right?
04:52:36 <EvanR> it would show
04:52:41 <EvanR> > fold1 undefined []
04:52:42 <lambdabot>  Not in scope: Ã¢fold1Ã¢
04:52:42 <lambdabot>  Perhaps you meant one of these:
04:52:42 <lambdabot>    Ã¢foldl1Ã¢ (imported from Data.List),
04:52:47 <EvanR> > foldl1 undefined []
04:52:49 <lambdabot>  *Exception: Prelude.foldl1: empty list
04:53:39 <EvanR> what exactly is the culprit
04:53:58 <Gurkenglas> Your command line because you wrote foldl1 undefined []
04:54:33 <EvanR> the undefined didnt matter, if you tried to print the result that would be the error
04:54:43 <EvanR> if minimum was implemented with foldl1
04:54:56 <Gurkenglas> If you had written > minimum [] (and minimum was implemented as foldl1 min) it could (not saying it does, but it should be possible to implement it that way, right?) say that the error showed up in foldl1, as called by minimum, as called by your command
04:55:13 <EvanR> but it wasnted called by minimum
04:55:28 <EvanR> minimum was already evaluated to be foldl1, and forgotten
04:55:33 <{AS}> Hi, is there a way to swap monad transformers?
04:55:34 <Gurkenglas> Oh, I see. Okay
04:55:57 <Axman6> {AS}: probably not in general
04:56:04 <{AS}> Axman6: OK, thanks
04:56:04 <quchen2> Depends on what "swap" means
04:56:17 <Gurkenglas> So "enabling traces" probably removes exactly that step of forgetting to trade off memory for complete stacktraces
04:56:18 <{AS}> swap as in MT (MT' a) -> MT' (MT a)
04:56:35 * EvanR tries the stack trace feature
04:59:43 <{AS}> where MT and MT' are different MonadTransformers
05:03:04 <ion> A type would look more like MT M a or, say, MT (MT' Identity) a
05:03:27 <{AS}> ion: yeah :) 
05:03:28 <EvanR> Gurkenglas: http://lpaste.net/129663
05:03:45 <{AS}> swap :: MT (MT' m) a -> MT' (MT m) a
05:04:27 <EvanR> enlightening
05:12:03 <jules_> is this the right place to ask questions about cabal and haddock?
05:12:43 <quchen2> jules_: Sure, go ahead.
05:13:03 <jules_> okay, thanks
05:13:47 <jules_> i'm trying to generate haddock documentation for my project
05:15:12 <jules_> but it fails with an error message:
05:15:23 <jules_> odule ‘projects-0.1.0.0:Main’ is defined in multiple files: dist/build/tmp-8215/src/Main.hs dist/build/tmp-8215/./Setup.hs
05:15:36 <{AS}> Is there then a class of swappable transformers? :)
05:16:16 <jules_> i dont think so ... and i dont know what swappable transformers are 
05:16:39 <jules_> the Setup.hs file is the one autogenerated by cabal init
05:17:30 <{AS}> I was probably just looking for something similar to http://okmij.org/ftp/Haskell/extensible/exteff.pdf. Oh well, thanks everyone
05:18:33 <c_wraith> jules_: how are you running haddock?
05:19:18 <jules_> cabal haddock --executables
05:20:16 <c_wraith> Huh.  I've never run haddock with that flag.  Does it work, at least in the sense of not crashing, if you don't use that flag?
05:21:42 <jules_> Nope ... the output of cabal haddock is
05:21:47 <jules_> Warning: No documentation was generated as this package does not contain a
05:21:56 <jules_> library. Perhaps you want to use the --executables, --tests or --benchmarks
05:22:04 <jules_> flags.
05:22:19 <jules_> it's an application btw ...
05:22:42 <c_wraith> ah.
05:23:05 <c_wraith> I've never tried to run haddock on a non-library.  I don't think I can help with that. :(
05:23:23 <{AS}> jules_:  You can specify the cabal file to produce both a library and an application
05:23:45 <jules_> so it doesn't work on applications at all?
05:27:15 <quchen2> jules_: I don't know. But what do you expect to get as documentation for a library?
05:27:41 <quchen2> Haddock documents the public end of source code, and an executable doesn't have such ah thing
05:32:46 <elfeck> hey, can someone tell me why importing Text.Blaze does not expose any functions to me? i.e
05:32:46 <elfeck> import Text.Blaze (showHtml) does not allow me to use this function
05:33:56 <merijn> Well, Text.Blaze appears to be an empty module looking at the docs
05:34:19 <merijn> oh, haddocks are flipping out on me
05:34:49 <zipper> I'll ask here since I can't get an answer in haskell-gsoc.
05:34:50 <zipper> Hmmm when making a gsoc proposal. Do I not specify that the proposal will be to haskell.org?
05:35:03 <merijn> elfeck: But there still doesn't appear to be a showHtml function in blaze
05:35:19 <{AS}> Hmm, when I think about it I want a strictly weaker property: MT (MT' (MT m)) a -> MT (MT' m) a
05:35:38 <elfeck> http://hackage.haskell.org/package/blaze-html-0.1.2/docs/Text-Blaze.html
05:35:42 <elfeck> I was looking at that
05:35:49 <elfeck> but I cant even import Text.Blaze
05:36:13 <elfeck> it gives me "Cannot find module Text.Blaze"
05:36:26 <merijn> I don't see Text.Blaze exported in any external module
05:36:35 <merijn> Aren't you wanting Text.Blaze.HTML?
05:36:45 <merijn> eh, Text.Blaze.Html
05:37:18 <zipper> Oh wait they know somehow
05:37:33 <wolf_mozart> it's not the class but the functioin that's important
05:37:34 <elfeck> I need a function that convets a IO String to an html-node
05:37:53 <wolf_mozart> function*
05:38:12 <elfeck> like I got a svg-file and I want to directly insert it into the blaze-templating
05:39:05 <Phillemann> Just to make sure I'm doing nothing wrong per se: "cabal repl; :break MyModule someline; main" - this should stop the program at MyModel, line "someline", right? Or do I have to pass flags to enable debugging?
05:39:18 <kvelicka> Hi everyone. Was 7.10 release delayed?
05:40:40 <wolf_mozart> so the wrong idea about OOP is the member elements, like a class shouldn't have member elements, instead it would be more productive if it had functions that took in input and sent output? without a need to store them inside
05:41:11 <EvanR> thats not even wrong
05:41:39 <peddie> kvelicka: it was advertised as being 27 March . . .
05:42:31 <EvanR> wolf_mozart: usually classes arent the one with mutable elements, but the objects
05:42:50 <wolf_mozart> yes
05:44:28 <EvanR> wolf_mozart: a polite take away from the OOP paradigm would be that you should operate on your components through well-defined interfaces, in our case that means well-typed
05:44:49 <EvanR> but it can be tricky to come up with the right types to describe real OOP systems
05:44:49 <wolf_mozart> but the cumbersomeness about programming in OOP would come about because an object has these internal members that get changed by calling some internal method, instead a method should just return a value after it's done
05:45:13 <wolf_mozart> i see
05:45:54 <EvanR> hidden state like that can be bad, or the whole point
05:46:53 <EvanR> you can also use hidden state in a way that is referntially transparent, like the ST monad
05:47:39 <wolf_mozart> i was looking at functions more these days, and it seemed cumbersome having to code these additional get and set methods in the function, instead of just letting the function do all that stuff in one and return the whole data structure back
05:47:50 <EvanR> a lot of times in OO you use state like this, its not even for the purposes of mainintaining long lasting global state
05:47:52 <wolf_mozart> i see
05:50:59 <wolf_mozart> in the end it's the functions that do the real work :P
05:52:24 <EvanR> functions do work but without a clear model of your data your large program will turn into spaghetti, just a bunch of algorithms
05:53:04 <EvanR> i havent seen OOP as a good way to model the data or the algorithms
05:53:15 <wolf_mozart> how would you mean model, I still need OO do give it all shape?
05:53:25 <wolf_mozart> oh
05:53:27 <EvanR> no way
05:53:41 <elfeck> anyone knows if/how I can use IO String with Blaze-Html?
05:55:24 * hackagebot wai-extra 3.0.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.5 (MichaelSnoyman)
05:55:24 * hackagebot OpenAL 1.7.0.0 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.7.0.0 (SvenPanne)
05:55:41 <EvanR> wolf_mozart: data can be modeled from simply to more complex with simple types, record types, then databases
06:00:19 * hackagebot ALUT 2.4.0.0 - A binding for the OpenAL Utility Toolkit  http://hackage.haskell.org/package/ALUT-2.4.0.0 (SvenPanne)
06:00:21 * hackagebot yesod-core 1.4.9 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.9 (MichaelSnoyman)
06:05:17 <saep> elfeck: You have to bind the result of the "IO String" action and pass it to the function for your blaze-html use case. For that, you have to be in an IO context. 
06:05:36 <jerbome_> if a monad is also a monoid, does it mean it can trivially be  a MonadPlus ?
06:06:57 <jerbome_> with mzero = mempty and mplus = mappend ?
06:11:34 <elfeck> @saep could I also do smth like this: 
06:11:34 <elfeck> instance ToMarkup (IO String) where
06:11:34 <elfeck>   toMarkup = toHtml . show
06:11:34 <lambdabot> stop telling me what to do
06:12:13 <ion> lambdabot++
06:14:11 <saep> elfeck: "IO String" indicates an action with arbitrary side effects that may or may not produce a String at some point. How could that have a "Show" instance? 
06:15:23 <elfeck> hm okay
06:15:44 <elfeck> so I need to pull everything with blaze into the IO context?
06:17:30 <saep> elfeck: I assume, that you are writing a program and not a library. Your program's entry point always has an IO context (i.e. the main function). So you can, for example, bind the value of that IO action in tere and pass it to the blaze function.
06:17:51 <elfeck> ah okay
06:18:10 <elfeck> I will try that and report back, thanks
06:18:40 <saep> elfeck: You can also put some of the code you're having trouble with in a pastebin.
06:18:44 <saep> @where lpaste
06:18:45 <lambdabot> http://lpaste.net/
06:23:09 <elfeck> saep: thanks I got it working
06:23:13 <elfeck> :)
06:34:15 <Shapeshifter> Hi. I would like to parse haskell source code into an AST of more or less arbitrary format (I need it in Scala, but it could just be a graph/tree containing triples or anything I could transform/use in Scala). What can I use for this? Do I need to use the GHC API? Are there JVM compatible bindings for the GHC API?
06:37:41 <c_wraith> Shapeshifter: the current standard in parsing haskell code, at least in haskell, is the haskell-src-exts package.  It's the standard because it handles basically every extension GHC supports, and GHC extensions are quite common
06:38:06 <c_wraith> Shapeshifter: I'm not aware of anything that can do that in the jvm
06:38:18 <Shapeshifter> c_wraith: ok so I would probably need to write a small haskell program that uses haskell-src-exts to create the AST in some format that I can stream to my jvm based application?
06:38:42 <EvanR> you can communicate with a jvm application using java-bridge
06:39:01 <EvanR> doesnt help with running haskell ASTs on the jvm though, directly
06:39:49 <c_wraith> Shapeshifter: I don't know of anything that's going to be more direct.  But I don't know of everything out there. :)
06:40:21 * hackagebot statistics-hypergeometric-genvar 0.1.0.0 - Random variate generation from hypergeometric distributions  http://hackage.haskell.org/package/statistics-hypergeometric-genvar-0.1.0.0 (srijs)
06:50:57 <prophile> jerbome_: if it's Monoid (m a) for all a then yes
06:51:12 <prophile> but not if there are other constraints on a
06:51:41 <prophile> people argue for other laws on MonadPlus but the ones people agree on are exactly the monoid laws
06:55:22 * hackagebot yesod-auth-hashdb 1.4.2 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.2 (paulrouse)
07:10:22 * hackagebot uhc-util 0.1.5.1 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.1 (AtzeDijkstra)
07:16:12 <safinaskar> > 2 + 2
07:16:14 <lambdabot>  4
07:16:38 <safinaskar> > do { a <- return 1; a <- (a + 1); return a; }
07:16:39 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
07:16:39 <lambdabot>    arising from a use of Ã¢M432552631562672973710923.show_M4325526315626729737...
07:16:39 <lambdabot>  The type variables Ã¢m0Ã¢, Ã¢b0Ã¢ are ambiguous
07:16:58 <safinaskar> > do { a <- return 1; a <- return (a + 1); return a; }
07:16:59 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
07:16:59 <lambdabot>    arising from a use of Ã¢M818137911336561683610933.show_M8181379113365616836...
07:16:59 <lambdabot>  The type variables Ã¢m0Ã¢, Ã¢b0Ã¢ are ambiguous
07:17:05 <cfoch> hello
07:17:32 <safinaskar> > do { a <- return 1; a2 <- return (a + 1); return a2; }
07:17:34 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
07:17:34 <lambdabot>    arising from a use of Ã¢M134757607001353134010966.show_M1347576070013531340...
07:17:34 <lambdabot>  The type variables Ã¢m0Ã¢, Ã¢b0Ã¢ are ambiguous
07:17:38 <cfoch> are there people currently working on Finance Quote Yahoo (hackage) ?
07:17:43 <prophile> safinaskar: lambdabot doesn't know which monad you mean
07:17:51 <prophile> > do { a <- return 1; a2 <- return (a + 1); return a2; } :: Maybe Int
07:17:52 <lambdabot>  Just 2
07:17:54 <cfoch> or something related to the stock market?
07:18:00 <prophile> > do { a <- return 1; a2 <- return (a + 1); return a2; } :: (String, Int)
07:18:01 <lambdabot>  No instance for (GHC.Base.Monad ((,) GHC.Base.String))
07:18:01 <lambdabot>    arising from a do statement
07:18:07 <safinaskar> > do { a <- return 1; a <- return (a + 1); return a; } :: Maybe Int
07:18:08 <lambdabot>  Just 2
07:18:08 <zipper> prophile: The burrito monad. You know monads are like burritos.
07:18:21 <safinaskar> ahaha, look at this code. looks very like imperative code! :)
07:18:30 <safinaskar> and i even "modified" "a"!
07:18:35 <safinaskar> a <- return (a + 1) !!!
07:18:49 <EvanR> even i am getting tired of the burrito thing now
07:19:09 <EvanR> at least can we move on to comonad tutorials
07:19:12 <prophile> zipper: I like my burritos with black beans and all finite limits
07:19:43 <cfoch> I was writing a program to analyze the stock market from Google Finance and Yahoo Finance, and I found this hackage.
07:25:23 * hackagebot hlint 1.9.19 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.19 (NeilMitchell)
07:25:53 <Shapeshifter> So I'm trying to understand how to get an AST using haskell-src-exts. parseFile gives me a ParseResult Module, which apparently contains things like the module name, import declarations and then a Decl, which I suppose is a super type for all kinds of declarations. But How do I traverse this Decl tree?
07:26:23 <Shapeshifter> http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Syntax.html#t:Decl
07:26:47 <bergmark> Shapeshifter: by pattern matching
07:32:47 <etandel> Someone here always says Haskell is the best imperative language around. ;-)
07:32:51 <Shapeshifter> bergmark: does this mean that if I want to traverse the entire tree (and for example print the element type of the visited node), I will need to write a visitor for every single element type there is?
07:33:18 <lleksah> Hi
07:33:22 <Shapeshifter> Is there a more generic way to traverse all kinds of element types using a single visitor?
07:34:51 <lleksah> assuming I have the following two functions:
07:34:54 <lleksah> f1 :: Type1 -> IO (Maybe Type2)
07:35:02 <lleksah> f2 :: Type2 -> IO (Maybe Type3)
07:35:02 <bergmark> Shapeshifter: check out uniplate, it's very useful for generic traversals
07:35:09 <Shapeshifter> bergmark: thanks
07:35:10 <frerich> Shapeshifter: Maybe you mean a 'fold'. You could use http://hackage.haskell.org/package/catamorphism to generate a fold (a "catamorphism") for the Decl type. That'll generate a function with as many arguments as there are data constructors :-}
07:35:23 <lleksah> how can I "compose" them to create: f3 :: Type1 -> IO (Maybe Type3)
07:35:24 <lleksah> ?
07:35:27 <mauke^> Shapeshifter: do you know haskell?
07:35:51 <Shapeshifter> mauke^: tbh, I only know the basics, wrote a few toy programs months ago. I'm just picking it up again, now.
07:37:22 <c_wraith> when you're just beginning, doing the pattern-matching is probably the best approach.
07:37:42 * frerich concurs
07:38:48 <jerbome_> lleksah, do {Just b <- f1 a; f2 b} ?
07:39:15 <lleksah> but I would like the function to be complete
07:39:27 <lleksah> your suggestion seems partial
07:39:29 <jerbome_> lleksah, f3 a = do {Just b <- f1 a; f2 b} ?
07:39:41 <jerbome_> i'm new to haskell, so I may be wrong
07:39:46 <EvanR> if f1 returns Nothing then kablooey
07:40:06 <jerbome_> EvanR, it calls fail from IO monad no ?
07:40:20 <EvanR> which would probably be kablooey
07:40:20 <c_wraith> lleksah: if you you use something like the MaybeT package, you can compose them with like..  MaybeT . f2 <=< MaybeT . f1
07:40:34 <lleksah> I know it is easy to compose these functions if there was no IO monad involved, but I'm lost once it's involved
07:40:36 <jerbome_> EvanR, ok
07:40:58 <c_wraith> lleksah: well, composing functions like a -> M b is just <=<
07:41:09 <jerbome_> lleksah, IMO, it's not because it's IO monad, but it's because it's a monad "inside" another one
07:41:27 <lleksah> I guess so indeed
07:41:29 <c_wraith> lleksah: that problem is that that's actually IO + Maybe, so you need something like MaybeT
07:41:34 <lleksah> thanks for the suggestion, let me check that
07:42:46 <lleksah> is the usage of MaybeT in this kind of case convoluted? or would one usually use the case construct, etc.?
07:43:09 <herperson> how do i define myself ? Data Herp = Herperson ?
07:43:41 <EvanR> herperson: ive asked myself that many times
07:43:47 <mniip> who needs monad transformers when you can do this by hand
07:43:49 <mniip> join . liftM (liftM join . traverse id . (liftM f2)) . f1
07:44:18 <c_wraith> traverse id?  Isn't there a shorter way to write that?  sequence?
07:44:25 <frerich> Sombody figured out how to /msg lambdabot ;-)
07:44:35 <mniip> oh right
07:44:37 <mniip> sequenceA
07:45:11 <herperson> thanks EvanR, this is the best IRC ever
07:45:55 <JordiGH> Is there a simple way to combine map and filter? Kinda like how list comprehensions in Python allow "if" clauses?
07:45:59 <mniip> lleksah, other than that, if you're not familiar with monad transformers you better write a pointful function
07:46:28 <alynn> JordiGH: there's list comprehensions
07:46:36 <JordiGH> alynn: Do they allow if clauses?
07:46:46 <alynn> > [a | a <- [0..10], a < 5]
07:46:48 <lambdabot>  [0,1,2,3,4]
07:46:56 <mniip> lleksah, also that is not partial, a pattern match failure in Maybe returns a Nothing
07:46:56 <c_wraith> JordiGH: simpler.  any expression which is of type Bool is treated as an implicit filter
07:47:09 <lleksah> well, it seems like it's a good opportunity for me to learn those monad transformers
07:47:19 <bmuk> Hey everyone, I'm having a strange error with Happstack.Lite - http://pastebin.com/6yDn5wVc; parse error in pattern: method, possibly caused by a missing 'do'?
07:47:26 <jerbome_> > [a | a <- [0..], odd a]
07:47:28 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
07:47:35 <jerbome_> oh, lambdabot is smart !
07:47:42 <bmuk> on line 74, in processForm in formPage
07:47:45 <JordiGH> Ah, great, that'll work for me.
07:47:47 <JordiGH> Thanks.
07:47:50 <lleksah> I didn't know about that mniip, thanks for the info
07:47:53 <JordiGH> I couldn't figure out the syntax. 
07:48:38 <c_wraith> JordiGH: like most places, haskell chooses the minimal syntax that works.  (not every place, but most of them)
07:48:54 <JordiGH> "that works" is kind of subjective, but sure.
07:49:30 <mniip> > do { 0 <- Just 1; Just undefined; } -- lleksah
07:49:32 <lambdabot>  Nothing
07:50:35 <bmuk> I'm looking at the types and it should work, but it doesn't and I can't figure out why
07:50:49 <lleksah> I see
07:51:31 <lleksah> regarding the suggestion "MaybeT . f2 <=< MaybeT . f1"
07:51:40 <JordiGH> I still can't get over how cons-lists are the default in Haskell. They seem so wrong for so many reasons. Why couldn't they have been dynamically allocated arrays instead?
07:51:46 <bmuk> This is literally the same code as http://happstack.com/page/view-page-slug/9/happstack-lite
07:52:02 <c_wraith> JordiGH: the thing is, cons lists + laziness = loops
07:52:02 <lleksah> is MaybeT a constructor here?
07:52:12 <c_wraith> lleksah: yes, it's the constructor of the MaybeT type
07:52:34 <JordiGH> c_wraith: But then mergesort and binary search become a difficult puzzle!
07:52:46 <c_wraith> JordiGH: cons lists aren't great for when you want to store a collection in memory.  They're fantastic for producing a sequence to iterate over
07:53:05 <JordiGH> I kinda wonder how does sort even manage to be efficient with a cons list.
07:53:29 <lleksah> ok, I'm gonna try and see the magic happen, then read about it to understand
07:53:31 <JordiGH> I guess quicksort isn't so bad with a cons list, since you don't need to index.
07:53:39 <dlowe> JordiGH: merge sort works fine with a cons list
07:53:56 <JordiGH> dlowe: Sure, but you can't index, so translating the usual algorithm becomes a puzzle.
07:54:13 <c_wraith> JordiGH: bottom-up is better anyway
07:54:18 <c_wraith> so that doesn't matter
07:54:27 <dlowe> I've also seen implementations that just copy into an array and sort there
07:55:48 <Kron> Is there any library for parallelizing arbitrary folds on a sequence?
07:56:12 <JordiGH> I mean, really, who can figure out this strick on the first try? It's like that time that someone quizzed me with the racing pointers puzzle during a job interview: http://en.literateprograms.org/Merge_sort_%28Haskell%29#split
07:56:20 <Kron> stuff like splitAt or partition exist because they bundle separate filters and the like together into a single list traversal
07:57:28 <JordiGH> But you can't even know what to split at since you don't know the length of the list a priori.
07:58:42 <JordiGH> I am not just whining for no reason. I need to implement a weighted median algorithm now, which is done by a weighted binary search.
07:59:10 <JordiGH> I was hoping to be able to use lists, but I really think I need Data.Vector instead.
08:00:19 <bmuk> Does anyone know why I would be getting that error with Happstack.Lite?
08:00:58 <JordiGH> So why is sortBy's signature not merely (a -> a -> Bool) -> [a] -> [a]? Why Ordering instead of Bool?
08:02:22 <benzrf> auuugh
08:02:40 <jerbome_> JordiGH, you might want to do this differently when you get EQ ?
08:02:43 <benzrf> on the one hand, this is an extremely standard, extremely simplifiable potential application of zoom
08:02:46 <mauke^> JordiGH: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-List.html#sortBy
08:03:06 <benzrf> on the other hand, this is one of only like 3 places i'm doing it, so hauling in all of lens seems like massive overkill
08:03:20 <JordiGH> mauke^: What are you pointing to?
08:03:20 <benzrf>  r <- state $ \(GameState sh pl) -> second (flip GameState pl) (runState s sh)
08:03:53 <mauke^> JordiGH: the actual code in Data.List that doesn't use your split function
08:03:56 <benzrf> rip
08:04:41 <JordiGH> mauke^: Oh, sure, there are other solutions to this puzzle.
08:05:22 <JordiGH> jerbome_: I don't get it, what would you do differently, in which situation?
08:05:46 <JordiGH> If they're EQ, you want to further refine the sorting in your comparison function by some other method?
08:06:18 <JordiGH> First sort by string length, and if that fails, sort lexicographically?
08:06:39 <JordiGH> That still seems to me something that could work with Bool instead of Ordering.
08:06:52 <jerbome_> JordiGH, not really what I was thinking of
08:07:34 <jerbome_> more like the implementation of what you do with values that are equal may be different
08:07:39 <jerbome_> I don't have any example
08:08:34 <Kron> JordiGH: you can turn sortBy into a de facto (a -> a -> Bool) by using the "comparing" function
08:08:50 <JordiGH> Kron: Sure, why isn't it this already?
08:09:02 <Kron> because of EQ
08:09:09 <JordiGH> Exprain prease.
08:09:16 <mniip> sortBy is stable
08:09:18 <JordiGH> No comprendo.
08:09:19 <Kron> basically, ordering has 3 data constructors, not 2
08:09:23 <Kron> this is improtant for stable sorting
08:09:26 <Kron> LT, EQ, GT
08:09:30 <mniip> wouldn't be possible without EQ
08:09:33 <JordiGH> Aaaahh, stable sorting.
08:09:39 <Kron> in a stable sort it's possible for two values to not be larger or smaller than each other
08:09:45 <JordiGH> You don't want to move things that are equal.
08:09:45 <Kron> and must be held in the same place, relatively speaking
08:09:49 <Kron> sortBy allows stable sorting
08:09:50 <Kron> exactly
08:09:57 <Kron> you can dismiss this by just using comparing
08:10:00 <Kron> :t comparing
08:10:00 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
08:10:15 <Kron> you can just do "sortBy (comparing (< 3))" or whatever
08:10:28 <JordiGH> Thanks, got it.
08:10:56 * mauke^ boggles at comparing (< 3)
08:11:04 <Kron> yeaaaah it's a really dumb example
08:11:09 <Kron> and I regret making it, lol
08:11:11 <JordiGH> lol
08:11:16 <Kron> normally I use comparing to turn things into numbers
08:11:34 <Kron> like "sortBy (comparing length)" or "sortBy (comparing indexOfThing)" or whatever
08:11:57 <Kron> but hey! It'll definitely shove everything smaller than three to before the stuff greater than three
08:13:18 <JordiGH> I actually need something like the boggling example for implementing 
08:13:24 <JordiGH> weighted medians.
08:13:41 <mauke^> :t let sortBy3 cmp = sortBy2 (\x y -> cmp x y == LT); sortBy2 cmp = sortBy (\x y -> if cmp x y then LT else if cmp y x then GT else EQ) in (sortBy2, sortBy3)
08:13:42 <lambdabot> ((a -> a -> Bool) -> [a] -> [a], (a1 -> a1 -> Ordering) -> [a1] -> [a1])
08:14:33 <mauke^> 2-way and 3-way comparison sorts implemented in terms of each other
08:20:23 <mniip> @src compare
08:20:23 <lambdabot> compare x y | x == y    = EQ
08:20:23 <lambdabot>             | x <= y    = LT
08:20:23 <lambdabot>             | otherwise = GT
08:20:45 <mniip> @src <=
08:20:45 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
08:21:26 <Kron> I think we're running into primops here
08:23:22 <mniip> I was just demonstrating pretty much the same as mauke^ did
08:30:00 <c_wraith> I've been playing a bit with Auto, to see if it's a decent fit for the sort of thing I want to do.  One thing that's quickly become clear to me is that most of the Arrow stuff is somewhat easier to understand as an Applicative... Except when you do something that uses arr implicitly.  Is arr its own thing, beyond what Applicative+Category can do?
08:31:40 <shachaf> :t \f -> fmap f Control.Category.id
08:31:41 <lambdabot> (Category cat, Functor (cat a)) => (a -> b) -> cat a b
08:32:04 <c_wraith> oh!  It is an fmap, but not the way I thought.
08:32:33 <shachaf> With profunctors, it can be either rmap or lmap.
08:33:02 <c_wraith> I tried a couple things, but they didn't work out, because I didn't appreciate the full generality of id
08:33:13 <c_wraith> Oh, huh.  I think I wanted is actually simplest as an lmap
08:33:37 <shachaf> Well, if you have a Profunctor instance anyway, you might as well also have an Arrow instance at that point.
08:34:01 <c_wraith> Yeah, Auto has all the instances.  Even somewhat strange things like the Num hierarchy and IsString. :)
08:36:47 <c_wraith> Mostly, I was looking at stuff in proc notation, and going "why should I use this instead of Applicative?".  Every example I came up with so far was simpler with Applicative
08:37:11 <c_wraith> That probably becomes less true when you get into stuff using the ArrowLoop instance
08:40:17 <wizao> I remember reading  a blog about figuring out the nth letter in the string representation of for large ordinal numbers and cannot find the blog for the life of me
08:41:11 <c_wraith> wizao: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
08:41:24 <wizao> omg thank you
08:41:29 <wizao> been trying to find that for weeks now
08:41:40 <clrnd> it get's all NASA around part 3, couldn't follow past that
08:41:50 <wizao> thats okay
08:42:08 <wizao> I remember it did get crazy towards the end
08:42:14 <wizao> but my google foo failed me
08:42:27 <c_wraith> wizao: this channel is huge.  In many senses, it functions as a collective memory. :)
08:43:07 <c_wraith> jle`: you around?
08:45:44 <naudiz> hey, I have a type A a { arr :: Array Integer a } and want to define an Operator (!) :: A a -> Integer -> a -- I do it like this: v ! i = arr v (Data.Array.(!)) i -- but this gives me an error message that (!) could refer to multiple definitions. what am I doing wrong?
08:46:29 <naudiz> I actually wrote Data.Array.Base.(!) but the error is the same
08:46:35 <mauke^> v ! i = arr v Data.Array.! i
08:47:09 <Gurkenglas> Can I, in ghci, move into the "context" of a definition so I can use the names used in its where clauses?
08:47:16 <mauke^> v ! i = (Data.Array.!) (arr v) i
08:48:51 <naudiz> mauke^: "Not in scope: â€˜Data.Array.Base.!â€™"
08:50:42 <mauke^> @index (!)
08:50:42 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
08:50:52 <mauke^> one of those
08:51:19 <naudiz> now I just imported (!) from Data.Array.Base and now it works...
09:01:54 <ironChicken> in my .cabal file i'm using the setting: cc-options: -ggdb -O0
09:01:58 <frerich> Thanks to whoever recommended following parametricity on Twitter (wait, the cool kids would just saw 'for following @parametricity')
09:02:20 <ironChicken> hoping that gcc will include gdb debugging symbols, but GDB says that it can't find any symbols
09:03:41 <ironChicken> my code uses hsc2hs and i can see that the call to hsc2hs is getting those two options applied
09:04:14 <mauke^> what are you using gcc for?
09:05:58 <ironChicken> mauke^: um, hsc2hs uses it?
09:08:00 <safinaskar> how to convert Integer to Int?
09:08:46 <mauke^> ironChicken: yeah, but what's the point of adding debugging symbols there?
09:09:01 <mauke^> safinaskar: what do you want to do if the value is too large to fit in an Int?
09:10:52 <ironChicken> mauke^: none. i don't think that's what i'm trying to do. basically, my program shows me some garbage where i expect a C int and then segfaults. the garbage is coming from a foreign call. i'm trying to debug
09:10:55 <bennofs> in GHC, if I defined data K = A | B, and data P (tag :: K) where ....   and I want to define a function f :: P k, is this possible without constraints on k?
09:11:37 <bennofs> (I'd like to do some kind of "pattern match" on a closed kind)
09:12:03 <Feuerbach> bennofs: you need singletons
09:12:19 <Feuerbach> e.g. the singletons package on hackage
09:12:26 <Feuerbach> or roll your own
09:13:27 <safinaskar> mauke^: exception
09:14:20 <mauke^> safinaskar: what do you mean by exception?
09:14:36 <hodapp> huh, Ivory's coroutines seem a little backwards to me
09:14:42 <hodapp> perhaps it's just a restriction of the implementation
09:14:46 <safinaskar> mauke^: exception. i. e. thing that raised when i do "error "something""
09:14:51 <Feuerbach> bennofs: but essentially the answer is no, you can't do that without constraining k
09:15:03 <safinaskar> mauke^: i. e. i want to do something like "error" if there is no conversion
09:15:05 <hodapp> but I'd always looked at yielding a value in a coroutine as an analog of returning a value in a function/subroutine/whatever
09:15:46 <mauke^> safinaskar: you're not supposed to catch "error"
09:16:20 <mauke^> hmm. is there a checked conversion function somewhere?
09:17:12 <co-arbelos> hmm.. someone/something is posting a lot of spam to http://paste.hskll.org/
09:17:28 <safinaskar> mauke^: as well as i know, i can catch exception if i want (in IO monad)
09:17:50 <mauke^> except when you can't because it happens asynchronously
09:18:12 <safinaskar> mauke^: so, how to convert Integer to Int? any method will go (with exception, any other way), even returning "Maybe Int" is ok for me
09:18:30 <zebr> hi all. this isn't strictly haskell-related, but this is the best place i know to ask this question... does anyone know a nice way to do linear type unification? i have the problem that i need a => !a, and can't work out how to tell that i need to apply that rule when i'm trying to unify e.g. a ~ !b where a ~ b.
09:18:37 <mauke^> intFromInteger n | inRange (lo, hi) n = fromInteger n | otherwise = error ("intFromInteger: " ++ show n ++ " is out of range") where [lo, hi] = map toInteger [minBound, maxBound :: Int]
09:18:42 <mauke^> this seems slightly disgusting
09:18:48 <co-arbelos> maybe i should report that to the github repo
09:22:45 <mauke^> @src Integer
09:22:45 <lambdabot> data Integer = S# Int#
09:22:45 <lambdabot>              | J# Int# ByteArray#
09:23:06 <mauke^> intFromInteger (S# i) = I# i; intFromInteger _ = error "bzzt"
09:23:25 <safinaskar> mauke^: in fact, it is not important for me, what will happen in the case of overflow. so, just "fromInteger" itself is ok for me. thanks
09:24:23 <safinaskar> mauke^: what mean this "#" in "S#"?
09:24:41 <arkeet> it's just a character.
09:24:51 <arkeet> S# and J# are the names of the constructors.
09:25:02 <arkeet> Int# is the type of an unboxed Int.
09:25:04 <dolio> It's a naming convention to indicate that low level stuff is going on.
09:25:51 <Gurkenglas> There should be unfoldr :: (b -> [(a,b)]) -> b -> T.Tree a
09:26:37 <Gurkenglas> Hmm, without the r probs.
09:27:59 <safinaskar> arkeet: dolio: thanks
09:28:51 <arkeet> Gurkenglas: the Tree from containers?
09:29:13 <Gurkenglas> Waaait. There is. Huh.
09:29:19 <arkeet> oh good.
09:29:35 <Gurkenglas> (Noticed while checking hackage whether it was in a "containers" package)
09:29:37 <arkeet> you mean (b -> (a,[b])).
09:29:43 <arkeet> yeah
09:29:59 <arkeet> Tree is also known as Cofree []
09:30:15 <arkeet> https://hackage.haskell.org/package/free-4.11/docs/Control-Comonad-Cofree.html
09:30:19 <Gurkenglas> Nice.
09:30:30 <Gurkenglas> Good to know that particular intuition has already been captured
09:30:53 <Gurkenglas> Shouldn't unfoldr itself then be (b -> (a, Maybe b)) -> b -> [a]?
09:30:57 <arkeet> I was busy playing around with that last night.
09:31:06 <arkeet> no, because how would you unfold to the empty list?
09:31:16 <Gurkenglas> Well how do you unfold to the empty tree?
09:31:18 <Geekingfrog> Hello there, I have an issue with Parsec. Code sample here: http://lpaste.net/129678  Basically, it doesn't seem to recognize new lines :/
09:31:21 <arkeet> there is no empty tree.
09:31:31 <arkeet> Cofree Maybe is the type of nonempty lists.
09:31:35 <Gurkenglas> Right, and the empty list is not part of Cofree Maybe
09:31:49 <Gurkenglas> Ohh, hivemind.
09:35:31 * hackagebot uuagc-diagrams 0.1.1.0 - Utility for drawing attribute grammar pictures with the diagrams package  http://hackage.haskell.org/package/uuagc-diagrams-0.1.1.0 (JeroenBransen)
09:36:15 <Fuuzetsu> >If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
09:36:16 <Fuuzetsu> nice
09:37:25 <Shapeshifter> I'm following this guide http://chrisdone.com/posts/data-typeable but even though I specifiy the pragma, I get "Not in scope: type constructor or class â€˜Dataâ€™" and the same for Typeable. What do I do?
09:39:03 <arkeet> import Data.Data
09:39:18 <Shapeshifter> oh
09:39:19 <Shapeshifter> thanks.
09:46:32 <jerbome_> in the All about Monad article, in the part about the State monad, it states: The definition shown here uses multi-parameter type classes and funDeps, blah blah
09:46:42 <jerbome_> and the definition is newtype State s a = State { runState :: (s -> (a,s)) }
09:47:26 <jerbome_> I assume that it means that I cannot do my custom newtype's with 2 parameters, but I can still do it with data ?
09:48:17 <jerbome_> like data State s a = State { runState :: (s->(a,s)) } would be valid, even withouth the multi parameter type class etc ?
09:49:21 <ski> jerbome_ : "I cannot do my custom newtype's with 2 parameters" -- you can
09:49:54 <ski> `newtype' and `data' doesn't care about how many parameters your defined types have
09:50:14 <ski> the comment about "multi-parameter type classes" is unrelated to the definition of the data type itself
09:50:33 <jerbome_> ah
09:50:50 <ski> (it would be related to an instance declaration like `instance MonadState s (State s) where ...', where here `MonadState' is a multi-parameter type classe)
09:50:52 <jerbome_> so is it related to the instance Monad (State s) ?
09:51:03 <safinaskar> about parsec. Parsec.Token. should i put to opLetter/opStart all symbols present in reservedOpNames?
09:51:12 <ski> not to that, no. `Monad' itself is a single-parameter type class
09:51:35 <ski> jerbome_ : all clear ?
09:52:00 <jerbome_> ski, yeah I guess I understand now why I don't understand class MonadState m s | m -> s where syntax
09:52:43 <ski> jerbome_ : the `| m -> s' is an additional annotation. the basic part is `class MonadState m s', which states that `MonadState' will accept two type parameters (here called `m' and `s')
09:53:34 <jerbome_> ski, thanks. can you elaborate on 'additional annotation ?
09:53:54 <ski> jerbome_ : the `m -> s' part is the functional dependency (FD) part. it is added to avoid some (more or less) useless ambiguity in type inference&checking that would otherwise commonly result from uses of `MonadState' in constraints in type signatures
09:54:23 <ski> jerbome_ : reading `m -> s' we say that "`m' functionally determines `s'"
09:54:47 <S11001001> jerbome_: https://ocharles.org.uk/blog/posts/2014-12-14-functional-dependencies.html
09:54:57 <ski> there can be more than one FD (separated by commas), and there can be more than one type variable (separated by spaces) to the left of the `->' in each FD
09:55:32 * hackagebot mutable-containers 0.3.0 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.3.0 (MichaelSnoyman)
09:55:46 <ski> jerbome_ : logically, `m -> s' here means `forall m. unique s. MonadState m s' : which means that for every `m', there can be at *most* one `s' such that `MonadState m s' holds
09:56:06 <jerbome_> ski, I think I get it : in the MonadState case, that means if my monad is, say Maybe Int, s would be Int ?
09:56:42 <ski> er, should be `MonadStats s m' (i was mixing up the order of `s' and `m')
09:57:37 <ski> jerbome_ : so, for any given monad `m', there can be at most one state type `s' associated with it, via the `MonadState' class
09:57:50 <ski> jerbome_ : "if my monad is, say Maybe Int, s would be Int ?" -- not necessarily
09:58:10 <ski> jerbome_ : another way to state `forall m. unique s. MonadState s m' (typo corrected), logically, is `forall m s0 s1. (MonadState s0 m,MonadState s1 m) => s0 = s1'
09:58:45 <ski> jerbome_ : this means that if we know that `s0' is the state type for `m', and we also know that `s1' is the state type for `m', then that means that `s0' and `s1' actually have to be the same type
09:59:20 <jerbome_> ski, I think that's what I tried to say in my example
10:00:07 <jerbome_> but I'm not sure, all this stuff is reall new to me, and I'm still very confused about it
10:01:09 <ski> jerbome_ : consider this code snippet `do x <- get; foo; y <- get; return (x,y)', and let's say we've so far inferred this to have type `m (s0,s1)' -- then because of the FD `m -> s' on `MonadState s m', we *know* that the types of the states that we get from those two `get's *must* actually be the same type `s', so the type inference machinery can now just unify `s0' and `s1' (say rename to `s'), simplifying the inferred type from `(MonadState s0 m,MonadSt
10:01:26 <ski> er, end cut off near ".., so the type inference machinery can now just unify `s0' and `s1' (say rename to `s'), simplifying the inferred type from `(MonadState s0 m,MonadState s1 m) => m (s0,s1)' to the simpler `MonadState s m => m (s,s)'"
10:02:11 <ski> jerbome_ : the FD `m -> s' say that we only ever want to associate a *single* state type `s' with a monad `m', via the `MonadState' type class
10:03:04 <ski> jerbome_ : now, i've mentioned how the type inference can use this to simplify inferred types (and this can also remove ambiguity that you'd have to otherwise resolve in some way, which would often make the code more cluttered)
10:03:36 <jerbome_> ski, ok, I'll try to think over that, I believe I get the idea, but must confirm :)
10:04:18 <ski> jerbome_ : the other part of it is that, because of the FD `m -> s', if you have already declared `instance MonadState MyStateType MyStateMonad', then the type class system will *forbid* you from making an additional instance `instance MonadState MyOtherStateType MyStateMonad'
10:04:58 <ski> because that would violate the constraint `m -> s' that you're only allowed to have an instance for at *most* one `s', for each specific `m', for `MonadState s m'
10:05:15 <safinaskar> ski: good nick. SKI-calculus, right? :)
10:05:26 * ski grins
10:05:49 <ski> (also, it's not a calculus. it doesn't have bound variables)
10:06:48 <safinaskar> ski: wikipedia calls it calculus
10:07:12 <arkeet> ski: sure it does, it has 0 of them.
10:08:03 <ski> i mean, it doesn't have constructs that bind variables
10:08:19 * arkeet has never seen a definition of 'calculus'
10:08:24 <ski> (or, if you prefer : it is not the case that there exists a construct in it that binds variables)
10:08:58 <jerbome_> ski, so if I cretae an instance of MonadState s1 m in one of my module, and someone made an instance MonadState s2 m, and I try to use that in a single program, what happens ?
10:10:20 <dolio> ski: For some reason, combinators got an honorary title as calculi, even though they're clearly algebras.
10:11:41 <Gurkenglas> Who made the Cofree package? Is there a canonical place for discussing it?
10:11:49 <arkeet> edwardk did.
10:11:54 <arkeet> I think here is fine.
10:12:09 <arkeet> (and it's the 'free' package)
10:12:58 <arkeet> ski: google gives a definition for calculus as "a particular method or system of calculation or reasoning."
10:13:21 <Gurkenglas> Oh, up there in the corner. Duh. (Does the 2008-2013 mean it was made in 2008 and last changed in 2013?)
10:13:41 <arkeet> which seems general enough to include SKI.
10:14:03 <arkeet> Gurkenglas: nah, just that he hasn't updated the copyright date since 2013. 
10:14:11 <arkeet> https://hackage.haskell.org/package/free - last version was upload march 7
10:14:47 <ski> arkeet : i had <http://lambda-the-ultimate.org/node/533#comment-7712> in mind
10:15:14 <johnw> arkeet: I thought "calculus" was the math equivalent of a DSL
10:15:25 <ski> jerbome_ : ".., and I try to use that in a single program, what happens ?" -- you get an error
10:16:37 <Welkin> there are algebras of shapes
10:16:42 <arkeet> ski: I don't agree with the statement about calculus in mathematics.
10:16:42 <Welkin> like Minkowski Algebra
10:17:24 <Gurkenglas> Why isn't "Cofree [] forms a tree." among the examples?
10:17:37 <ski> arkeet : elaborate ?
10:17:42 <Welkin> calculus is "a particular method or system of calculation or reasoning."
10:17:54 <arkeet> Gurkenglas: it is, just look down a bit further.
10:18:14 <clrnd> what'd be a cool xmobar alternative?
10:18:19 <clrnd> something less ... minimalistic
10:19:26 <Welkin> what is xmobar?
10:19:26 <Gurkenglas> Does "f a â‰¡ [a]" mean something other than "f â‰¡ []"?
10:19:37 <arkeet> not really.
10:19:58 <tromp> it means f = (:[])
10:20:12 <arkeet> tromp: not when f and a are types ;)
10:20:34 <arkeet> ski: uh.
10:20:47 <shachaf> i,i f a â‰¡ '[a]
10:21:14 <tromp> good point, arkeet
10:21:18 <Gurkenglas> "'"?
10:21:58 <arkeet> shachaf is being silly.
10:22:14 <arkeet> '[a] is a type level list, with one element.
10:22:32 <arkeet> its kind is [*], as opposed to * for normal types.
10:23:24 <arkeet> :k '[Int]
10:23:24 <lambdabot> [*]
10:23:53 <arkeet> :k '[Int, Char, Bool -> Bool]
10:23:54 <lambdabot> [*]
10:25:34 <dolio> The big question is, why isn't its kind '[*]?
10:26:41 <voidzero> :k []
10:26:42 <lambdabot> * -> *
10:27:02 <arkeet> :k '[]
10:27:03 <lambdabot> [k]
10:27:06 <Gurkenglas> Is '[Int, Char, Bool -> Bool] different from (Int, Char, Bool -> Bool) aside from the type-safety like conveniences that might arise from the distinction?
10:27:06 <arkeet> :k '(:)
10:27:06 <lambdabot> k -> [k] -> [k]
10:27:20 <arkeet> Gurkenglas: those have different kinds.
10:27:35 <arkeet> (Int, Char, Bool -> Bool) is a regular type (with kind *), that has values such as (3, 'a', not)
10:28:03 <arkeet> the other thing doesn't have values.
10:28:14 <Gurkenglas> How is the other thing used?
10:28:21 <arkeet> very carefully.
10:28:28 <arkeet> also fairly rarely.
10:28:49 <exio4> the "value-way" to use it is with datatypes that keep the types and values in sync, but you normally don't want it 
10:29:02 <exio4> ( I am giving a way to use them, it is not just for this)
10:29:40 <arkeet> I think the only way to really use them is as a type argument in something of kind [*] -> ...
10:30:37 <arkeet> as a phantom type, say.
10:30:38 <Gurkenglas> I see, like something that turns a list of types into a conga line of Data.Maps
10:31:20 <arkeet> it falls under DataKinds kind of stuff, which is fairly recent in ghc.
10:31:28 <arkeet> I think it was introduced in 7.4?
10:31:52 <arkeet> (DataKinds is the thing to read about, actually.)
10:34:56 <arkeet> for instance, you could use something of kind [*] as a type variable for a heterogenous list.
10:35:09 <arkeet> where the list of types specifies the types of the elements.
10:35:18 <arkeet> it's kind of unwieldy though.
10:35:22 <Gurkenglas> Cause tuples can't do '(:)
10:35:35 * hackagebot hexpat-lens 0.1.3 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.3 (JosephAbrahamson)
10:35:57 <arkeet> I don't think it's much better than just using tuples.
10:36:32 <arkeet> (if you want a heterogenous list with types Int, Char, Bool,  you may as well just use (Int, (Char, (Bool, ()))) or something.)
10:36:50 <Gurkenglas> Heterogenous lists are stupid anyway! http://en.wikipedia.org/wiki/The_Fox_and_the_Grapes
10:39:23 <juanca_> or universal quantification and redifine your list :)
10:39:28 <exio4> arkeet: the nested tuples approach is pretty cumbersome to work with, and the limited way to work with type-indexed hlists is relatively nice for avoiding some mistakes
10:39:36 <arkeet> sure.
10:39:53 <arkeet> it's cumbersome either way, imo. :)
10:40:35 * hackagebot hoogle 4.2.39 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.39 (NeilMitchell)
10:40:45 <exio4> it's cumbersome either way, but one is 'safer' than the other 
10:41:20 <exio4> are there news on http://www.cis.upenn.edu/~eir/packages/nokinds/ , too? 
10:56:41 <Gurkenglas> Can I somehow talk to lambdabot about Cofree?
10:57:12 <shachaf> You can define it yourself.
10:58:01 <Gurkenglas> Surely, say, Data.Map wasn't hardcoded into lambdabot?
10:58:15 <shachaf> "hardcoded"?
11:00:01 <jle`> c_wraith: yes, the main reason is proc notation's handling of recursive bindings
11:00:11 <Gurkenglas> Umm, surely the sourcecode or configfile or whatever of lambdabot would be only a few lines shorter if nobody had put in Data.Map?
11:00:40 <Gurkenglas> And the same way, one could have it load Cofree without "defining it oneself"
11:01:08 <jle`> c_wraith: a lot of things can be done applicative style too...i just wanted to keep a consistent style instead of "everything applicative except for recursive things"
11:02:04 <jle`> i probably should make a note about applicative alternatives more prominent though as an option
11:02:13 <arkeet> lambdabot just imports Data.Map.
11:02:20 <arkeet> @let import Data.Map as M
11:02:23 <lambdabot>  Defined.
11:02:31 <arkeet> you could do that if it didn't already.
11:02:41 <arkeet> unfortunately you can't import Control.Monad.Cofree because it's unsafe. (???)
11:02:42 <Gurkenglas> w00t
11:02:43 <dolio> Now it's broken, probably.
11:02:46 <Gurkenglas> aw.
11:02:47 <arkeet> > M.empty
11:02:49 <lambdabot>  fromList []
11:02:51 <jle`> but even simple programs begin to involve recursive relationships
11:02:54 <c_wraith> jle`: I was actually going to ask you about serialization.
11:03:03 <arkeet> oh yes. 
11:03:03 <c_wraith> jle`: But I figured out how that works
11:03:05 <arkeet> :t empty
11:03:06 <lambdabot>     Ambiguous occurrence â€˜emptyâ€™
11:03:06 <lambdabot>     It could refer to either â€˜Control.Applicative.emptyâ€™,
11:03:06 <lambdabot>                              imported from â€˜Control.Applicativeâ€™ at /home/lambda/.lambdabot/State/L.hs:42:1-26
11:03:09 <arkeet> so.
11:03:11 <arkeet> @undefine
11:03:11 <lambdabot> Undefined.
11:03:13 <jle`> ah, cool :)
11:03:36 <arkeet> I guess not that it's unsafe, but that that package isn't whitelisted or something. I dunno.
11:03:44 <arkeet> @let import Control.Monad.Cofree
11:03:44 <lambdabot>  .L.hs:52:1:
11:03:45 <lambdabot>      Failed to load interface for â€˜Control.Monad.Cofreeâ€™
11:03:45 <lambdabot>      Perhaps you meant
11:03:50 <arkeet> @let import Control.Comonad.Cofree
11:03:51 <lambdabot>  <no location info>:
11:03:51 <lambdabot>      The package (comonad-4.0.1) is required to be trusted but it isn't!
11:03:57 <c_wraith> jle`: the key was when I noticed the Serializable constraint on all the functions that create internal state
11:04:01 <dolio> It would have to be installed, too.
11:04:15 <Gurkenglas> Surely any package uploaded with "Edwart Knett" in the name field can be trusted!
11:04:17 <dolio> If it isn't.
11:04:23 <arkeet> it seems to be installed.
11:04:47 <dolio> I don't know. That sounds like a hacker trying to cash in on Edward Kmett's good name.
11:05:36 <Gurkenglas> I know, I was trying to make it obvious I implied that implication :(
11:05:59 <dolio> Oh. I ruined the joke.
11:06:25 <Gurkenglas> Better one joke too many ruined than too few.
11:07:28 <dolio> I'm pleasantly surprised that @let puts imports at the top of the file instead of breaking, though.
11:07:55 <dolio> I figured it just appended lines.
11:08:19 <jle`> c_wraith: ah, yeah. the constraints to cause some trouble though as it makes you pay up-front for potential serialization you might never use. that was a consequence i didn't forsee. but there are the non-resuming underscore versions too.
11:08:30 <jle`> *do cause
11:08:59 <akegalj_> Data.Array.ST says data STArray s i e :: * -> * -> * -> * and also for s argument: s - the state variable argument for the ST type. I dont understand what this s should be?
11:09:15 <c_wraith> jle`: yes, but at least it forces you to be aware that you're breaking serialization when you do those things.  It would just be nice if it showed in the type somewhere
11:09:46 <arkeet> akegalj_: s is a type that you don't have access to.
11:09:58 <arkeet> it's consumed by runST or whatever.
11:10:37 * hackagebot verilog 0.0.11 - Verilog preprocessor, parser, and AST.  http://hackage.haskell.org/package/verilog-0.0.11 (TomHawkins)
11:10:39 * hackagebot arion 0.1.0.0 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.0 (karun012)
11:11:19 <juanpablo_> I'm trying to use the instances from Control.Monad.Trans.Either, but GHC keeps picking the instances from Control.Monad.Trans.Error
11:11:30 <juanpablo_> I'm not importing Control.Monad.Trans.Error anywhere in my file
11:11:40 <juanpablo_> But I'm importing Control.Monad.Trans.Either
11:12:00 <arkeet> how are you trying to use them?
11:12:08 <kadoban> Is there an `asAppliedTo` that can do the second argument instead of the first, or do I have to do a couple flips? Like how do I do: :t flip (flip fmap `asAppliedTo` []) -- in a more understandable way?
11:12:22 <juanpablo_> I'm trying to use the Alternative instance
11:13:05 <arkeet> :t asAppliedTo
11:13:05 <lambdabot> (a -> b) -> a -> a -> b
11:13:20 <arkeet> just define some (a -> b -> c) -> b -> (a -> b -> c)
11:13:27 <arkeet> as const
11:13:34 <arkeet> @let asAppliedTo2 = const :: (a -> b -> c) -> b -> (a -> b -> c)
11:13:36 <lambdabot>  Defined.
11:13:41 <arkeet> :t fmap `asAppliedTo` []
11:13:42 <lambdabot>     Couldn't match expected type â€˜a -> bâ€™ with actual type â€˜[t0]â€™
11:13:42 <lambdabot>     In the second argument of â€˜asAppliedToâ€™, namely â€˜[]â€™
11:13:42 <lambdabot>     In the expression: fmap `asAppliedTo` []
11:13:44 <arkeet> :t fmap `asAppliedTo2` []
11:13:45 <lambdabot> (a -> b) -> [a] -> [b]
11:13:55 <kadoban> Nice, thanks.
11:14:17 <kadoban> How long do '@let's stick around, until the bot resets or someone wipes them or something?
11:14:29 <akegalj> arkeet: so it means there is no way I could do something like `runST $ newListArray (1,1) "a" >> getElems` from MArray? https://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-MArray.html#newListArray
11:14:30 <Iceland_jack> Or until someone runs @undef
11:14:31 <arkeet> until either that or someone writes @undefine
11:14:37 <kadoban> Thanks
11:15:07 <arkeet> akegalj: I think that should work as is.
11:15:16 <akegalj> arkeet: ghc is telling me that newListArray is ambigius, it can be STArray or STUArray. How can i provide that info?
11:15:25 <arkeet> ah.
11:15:31 <arkeet> hm
11:15:54 <arkeet> can't you give it a type annotation?
11:16:45 <arkeet> newListArray (1,1) "a" :: ST s (STUArray s Int Char) or whatever.
11:17:25 <akegalj> arkeet: oh
11:17:50 <akegalj> arkeet: I i thought it was abigious around s parameter, so i wondered how to fix that
11:18:35 <enthropy> how do people deal with packages setting -XNoImplicitPrelude messing up your .ghci file?
11:19:17 <akegalj> arkeet: and giving polymorfic 's' in ST s works becouse s is defined with forall s. ?
11:19:25 <akegalj> arkeet: i never used type families or souch
11:19:30 <arkeet> yes, there's an implicit forall s.
11:19:46 <akegalj> arkeet: ok, thats clear now. Thank you
11:23:53 <jerbome_> How did u experts stop to think in an imperative way ?
11:24:10 <jerbome_> (I guess you all come from the OOP world more or less)
11:25:38 * hackagebot arion 0.1.0.1 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.1 (karun012)
11:27:09 <jle`> c_wraith: that's a good point :) and yes it would be really nice to find a nice way to indicate it in the type of any given Auto...have been thinking about this ever since integrating the serialization scheme heh
11:27:43 <jle`> jerbome_: practice :)
11:28:42 <c_wraith> jle`: doesn't seem tough to throw it into a phantom type - the trick is not having overwhelming types when every property an Auto can optionally have is reflected in the type. :)
11:29:00 <c_wraith> jle`: most people get scared of types with 15 type parameters :)
11:31:11 <safinaskar> how to convert [[0], [1, 2]] to [0, 1, 2]?
11:31:28 <c_wraith> > concat [[0], [1,2]]
11:31:30 <lambdabot>  [0,1,2]
11:31:44 <c_wraith> @hoogle [[a]] -> [a]
11:31:47 <lambdabot> Prelude concat :: [[a]] -> [a]
11:31:47 <lambdabot> Data.List concat :: [[a]] -> [a]
11:31:47 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
11:32:16 <c_wraith> safinaskar: hoogle is often a helpful tool for things like that, if you search for the type the operation must have
11:37:20 <hsk5> When I write
11:37:20 <hsk5> x -: f = f x
11:37:21 <hsk5> How do I know whether the function (-:) is left-associative or right-associative?
11:37:48 <hsk5> I mean, when I chain them
11:37:55 <hsk5> x -: f1 -: f2 -: f3
11:37:56 <dolio> By default it is left.
11:38:00 <dolio> But you can declare it.
11:38:07 <c_wraith> hsk5: you can ask ghci with :info
11:38:12 <kadoban> hsk5: :i in ghci, or in the docs, or yeah you can set it and the precedence.
11:38:56 <hsk5> c_wraith: :info gives me only:
11:38:57 <hsk5> (-:) :: t1 -> (t1 -> t) -> t 	-- Defined at test.hs:1:3
11:39:09 <dolio> infix{l,r,} N -:
11:39:17 <c_wraith> hsk5: in that case, the precedence must be the default, infixl 9
11:39:20 <dolio> Default is infixl 9
11:39:33 <safinaskar> c_wraith: thanks
11:40:22 <hsk5> c_wraith: so all functions are by default infixl 9, both special-char functions (like -:) and regular functions (like "boom")?
11:40:50 <c_wraith> hsk5: yes.  You can declare the fixity of functions when used `infix` too
11:41:11 <safinaskar> let's assume i have "data Foo = Bar Int | Baz Int". how to convert [Bar 1, Bar 2, Baz 3, Baz 4] to [1, 2] the most simple way?
11:41:30 <c_wraith> hsk5: that infixl 9 thing only applies when actually *used* as infix, of course.
11:41:42 <Iceland_jack> safinaskar: [ x | Bar x <- xs ]
11:41:44 <c_wraith> hsk5: functions used in prefix form have prefix precedence. :)
11:41:53 <hsk5> c_wraith: is that prefixl ?
11:41:58 <Iceland_jack> @let data Foo = Bar Int | Baz Int
11:42:00 <lambdabot>  Defined.
11:42:10 <Iceland_jack> > [ x | Bar x <- [Bar 1, Bar 2, Baz 3, Baz 4] ]
11:42:11 <lambdabot>  [1,2]
11:42:33 <c_wraith> hsk5: it's just..  different.  It's part of the spec that function application is always higher-precedence than infix operators, and always left-associative
11:43:10 <jerbome_> :t (->)
11:43:11 <lambdabot> parse error on input â€˜->â€™
11:43:26 <hsk5> c_wraith: ok, say I can't really modify precedence of regular function application, only of infix application?
11:43:35 <c_wraith> hsk5: yes
11:43:52 <c_wraith> jerbome_: :t only works on value expressions, but (->) is a type expression
11:43:56 <safinaskar> Iceland_jack: thanks
11:44:00 <safinaskar> :k (->)
11:44:01 <lambdabot> * -> * -> *
11:44:07 <safinaskar> jerbome_: :k (->)
11:44:11 <jerbome_> :k (->)
11:44:12 <lambdabot> * -> * -> *
11:44:18 <jerbome_> :k (->)a
11:44:18 <hsk5> c_wraith: so even if I I set infixl 100000 to something, regular function appl will still have a higher precedence?
11:44:19 <lambdabot> Not in scope: type variable â€˜aâ€™
11:44:20 <safinaskar> jerbome_: "k" means "kind"
11:44:25 <jle`> c_wraith: with a phantom type, Applicative, Category, etc. instances won't work
11:44:31 <safinaskar> jerbome_: "kind" is something like "type of type"
11:44:36 <jle`> at least without a lot of friction
11:44:48 <c_wraith> hsk5: well, the only valid precedence levels are 0 through 9
11:44:51 <jerbome_> safinaskar, thanks
11:44:55 <hsk5> c_wraith: lol ok. thanks
11:45:18 <jerbome_> how do I ask the type of fmap for the functor instance associated to (->) ?
11:45:35 <jerbome_> I'm tired of writing them by hand
11:45:49 <jerbome_> :t fmap
11:45:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:46:08 <arkeet> :t fmap `asAppliedTo2` (undefined :: r -> a)
11:46:09 <lambdabot> (a -> b) -> (r -> a) -> r -> b
11:46:20 <arkeet> (I'm cheating a bit.)
11:46:32 <safinaskar> jerbome_: :k ((->) Int)
11:46:35 <safinaskar> :k ((->) Int)
11:46:36 <lambdabot> * -> *
11:46:40 <jerbome_> oh cool
11:46:47 <arkeet> I defined asAppliedTo2 earlier.
11:46:49 <arkeet> :t asAppliedTo2
11:46:49 <lambdabot> (a -> b -> c) -> b -> a -> b -> c
11:46:57 <arkeet> it's equal to const, but with a more specific type.
11:47:03 <c_wraith> jle`: oh, I see the issue.  I think it can be worked around with a bit of cleverness.
11:47:13 <jerbome_> arkeet, I don't know what const is yet
11:47:17 <jle`> :t flip (flip fmap `asAppliedTo` unsafeCoerce)
11:47:17 <arkeet> const x y = x
11:47:17 <lambdabot> (b1 -> b) -> (a -> b1) -> a -> b
11:48:08 <arkeet> :t const
11:48:09 <lambdabot> a -> b -> a
11:48:24 <ttt_fff> ghcjs has built; woot!!!!! is there somethign like threepenny gui, but for ghcjs?
11:48:34 <jle`> c_wraith: if you have any leads, let me know :)  aside from explicitly up/down converting everything
11:48:44 <c_wraith> jle`: I'm testing something out.
11:49:37 <hsk5> c_wraith: Rules: (1) Regular function application has a higher precedence than anything else out there and this cannot be changed. (2) Infix function application is by default infixl 9, but it can be changed for a particular function if we want; we could make a particular function infixr, right-associative, if we want.
11:49:38 <hsk5> Accurate?
11:50:06 <jerbome_> so (->) a == r -> a, or a-> r
11:50:11 <c_wraith> hsk5: not quite - There are a couple things with higher precedence than function application, they're just not infix operators.
11:50:17 <jle`> ReinH: (->) a r = a -> r
11:50:19 <jle`> er, jerbome_ 
11:50:21 <jle`> sorry
11:50:30 <ReinH> jle`: thanks for the info ;)
11:50:31 <jerbome_> ok
11:50:31 <arkeet> (->) a b = a -> b
11:50:35 <arkeet> just like (*) x y = x * y
11:50:39 * hackagebot consul-haskell 0.1 - A consul client for Haskell  http://hackage.haskell.org/package/consul-haskell-0.1 (sseveran)
11:50:39 <c_wraith> hsk5: like record-update syntax.  foo bar { baz = quux} parses as foo (bar {baz = quux})
11:50:52 <jle`> always happy!
11:51:03 <jle`> i'm not sure how my finger slipped from j to r
11:51:36 <hsk5> c_wraith: ah ok
11:51:47 <hsk5> c_wraith: ok thanks
11:52:07 <jerbome_> jle`, thanks
11:53:20 <Gurkenglas> @let import Safe
11:53:22 <lambdabot>  Defined.
11:53:57 <Gurkenglas> Now why can't I import that in my ghci?
11:54:22 <Gurkenglas> And how do I "Use -v" as ghci recommends?
11:54:23 <c_wraith> > ()
11:54:24 <lambdabot>  ()
11:54:28 <arkeet> ghci -v
11:54:59 <Gurkenglas> Oh I guess ghci is usually run via the command line
11:55:12 <Gurkenglas> I'm starting it via rightclick on the .hs on windows ^^
11:55:20 <arkeet> apaprently you can also use :set -v
11:55:21 <arkeet> in ghci
11:55:30 <Gurkenglas> kth
11:55:30 <Gurkenglas> *x
11:56:33 <Gurkenglas> Is Safe a package that is not shipped with the default installation and you have to download it separately?
12:06:02 <c_wraith> jle`: might you be able to adapt this technique?  http://lpaste.net/129689
12:07:12 <c_wraith> jle`: the important part is that the only way to get a concrete value in the type variable is to use the restrictive constructor - And the serialization analogue requires that the input be polymorphic in that type variable)
12:08:12 <c_wraith> jle`: but it allows you to write things like the category instance easily..  I think.  Because the types can unify
12:17:09 <NemesisD> it looks like cabal can install packages for multiple ghc versions. anyone know how to point ghc at the correct package confs for its version?
12:21:09 <geekosaur> normally it figures that out itself. sandboxes may complicate this to some extent although IIRC it tries to do the right thing
12:23:20 <jerbome_> banana :: (a -> t -> b) -> (t->a) -> (t->b)
12:23:21 <jerbome_> banana f g = (\t -> f ( g t) t)
12:23:30 <jerbome_> is it possible to write this point free ?
12:24:01 <Iceland_jack> @pl banana f g = (\t -> f ( g t) t)
12:24:01 <lambdabot> banana = flip flip id . liftM2
12:24:03 <Iceland_jack> Enjoy :)
12:24:22 <EvanR> fruit themed combinators
12:24:27 <jerbome_> mm, it's unreadable :)
12:25:02 <EvanR> @unpl flip flip id . liftM2
12:25:02 <lambdabot> (\ o f a -> (\ i b -> return (o i ((\ g -> g) b)) b) (f a) a)
12:25:12 <EvanR> ah better
12:25:37 <Iceland_jack> Because I can
12:25:37 <Iceland_jack> @. unpl pl banana f g = (\t -> f ( g t) t)a
12:25:38 <lambdabot> banana v g = (\ p c -> return (v p ((\ n -> n) c)) c) (g a) a;
12:25:55 <kaidelong> @type flip flip
12:25:56 <lambdabot> b -> (a -> b -> c) -> a -> c
12:26:05 <enthropy> @type ap . flip
12:26:06 <lambdabot> (a -> b -> c) -> (b -> a) -> b -> c
12:26:13 <jerbome_> I prefer my initial stuff
12:26:22 <Iceland_jack> You should
12:26:57 <enthropy> pl isn't very optimizing
12:27:15 <osa1> I'm trying to implement a quasi quoter that generates declerations but what am I supposed pass for other fields of this data type: http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Quote.html ?
12:27:21 <EvanR> is there a bot command that takes your lambda and spits out de bruijn indices
12:28:12 <enthropy> osa1: you could not define them which will give a decent message to people that accidentally use your QQ in the wrong context 
12:29:42 <optocoupler> does anybody here happen to work for galois?
12:29:57 <osa1> enthropy: but I know some quoters are typed so that I can't use them in declaration context but I can use them in expression context etc.
12:30:10 <osa1> hm
12:30:30 <osa1> can I use [t| Int -> IO () |] in expression context for example?
12:30:37 <enthropy> you get the error message from that at the same time
12:31:02 <ublubu> has anyone had trouble installing hindent recently? I try 'cabal install hindent' and descriptive-0.9.3 isn't building
12:33:01 <nkar`> is there a concise way of expressing 'Foo | Bar' that's valid syntax: data FBB = Foo | Bar | Baz; let x = Foo; case x of Foo | Bar -> "foobar"; Baz -> "baz"
12:33:08 <nkar`> ?
12:33:22 <enthropy> put the Baz case first
12:33:31 <nkar`> I don't want a catch-all solution
12:33:43 <nkar`> I want to get a warning if I forget a value constructor
12:34:06 <enthropy> then you're out of luck
12:34:08 <Iceland_jack> nkar`: There is no â€œorâ€ pattern in Haskell, you can do
12:34:08 <Iceland_jack>     x | x `elem` [Foo, Bar] -> "foobar"
12:34:08 <Iceland_jack>     Baz                     -> "baz"
12:34:14 <Iceland_jack> as a workaround
12:34:34 <enthropy> that one gives warnings when you don't forget a constructor
12:34:36 <Iceland_jack> That should give you a warning in GHC 7.12 ,)
12:34:48 <Iceland_jack> *;) or maybe not
12:35:09 <Iceland_jack> But yeah, there is no nice way of doing that currently without repeating patterns
12:35:27 <nkar`> Iceland_jack: oh, I'd rather be explicit than rely on "maybe not"
12:35:45 <nkar`> thanks for the tips, though
12:36:05 <ski> (unfortunately, Haskell doesn't have disjunctive patterns, no)
12:36:42 <osa1> if I have this quoter `quoter :: [String] -> String -> Q [Dec]` can I use it like [quoter ["blah", "blah"] | <quoted stuff> |] ?
12:36:45 <nkar`> is it possible in ocaml?
12:36:54 <nkar`> iirc, it can be done in coq
12:37:00 <ski> nkar` : yes. also some SML implementations have it, i think
12:37:01 <nkar`> with the match statement
12:37:19 <nkar`> I wonder why it wasn't added to haskell, then
12:38:10 <enthropy> osa1: you can use -XImplicitParams ( quoter :: (?blahBlah :: [String]) => String -> Q [Dec] )
12:38:15 <ski> nkar` : see <http://rosettacode.org/wiki/Pattern_matching#OCaml> for an example
12:38:59 <osa1> quoter :: [String] -> QuasiQuoter <- I guess this is the right type.
12:39:00 <enthropy> so   let ?blahBlah = ["blah","blah"] in [normalQQ|  ... |]
12:39:03 <enthropy> yeah
12:39:18 <osa1> I didn't even know we have implicits
12:39:31 <enthropy> they are unpopular
12:40:52 <ski> enthropy : does that work ?
12:41:15 <safinaskar> i want module A to import B and B to import A
12:41:19 <safinaskar> is this possible?
12:41:47 <nkar`> safinaskar: no
12:41:49 <dolio> It's possible, but it'd be better if you didn't want that.
12:41:50 <enthropy> ski: I thought I had done it before
12:41:57 <nkar`> dolio: really? 
12:42:06 <dolio> Yes.
12:42:10 <nkar`> dolio: how?
12:42:12 <ski> @wiki Mutually recursive modules
12:42:12 <lambdabot> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
12:42:14 <ski> safinaskar ^
12:42:35 <dolio> nkar`: You have to write .hs-boot files that help the compiler.
12:43:02 <nkar`> thanks, til
12:46:48 <enthropy> ski, osa1 sorry it looks like that doesn't work
12:49:36 <osa1> why Q is not a MonadIO?
12:49:38 <ski> enthropy : in my understanding the quoter runs at TH-time, while the `let' would have to run at run-time, which was why i'd be surprised if it did work
12:49:52 <osa1> right
12:49:57 <c_wraith> osa1: because TH doesn't depend on transformers
12:50:11 <c_wraith> osa1: you can use the Q-specific function runIO to do the same thing
12:52:23 <osa1> so is a function with type `coq :: [String] -> QuasiQuoter` completely useless?
12:54:49 <c_wraith> osa1: well, no - you can use it as a helper for building related QuasiQuoters
12:57:19 <kallisti> https://hackage.haskell.org/package/webdriver
12:57:32 <kallisti> any idea why there's "docs pending; build status unknown"? 
12:57:47 <kallisti> it's been a month since I uploaded it...
12:58:46 <c_wraith> kallisti: hackage was broken for a while, in that it didn't try to build docs for new packages.  After that was fixed, it wasn't told to try to repair everything it missed.
12:58:57 <kallisti> ah okay
12:58:59 <c_wraith> kallisti: you can either upload docs manually, or upload a new version
13:02:14 <osa1> uh.. this is annoying. I can't use [q| ... |] syntax at top-level, and when I use $(q "...") I can't use newlines in the string
13:02:53 <c_wraith> osa1: you could try $[q| .. |] at the top level?
13:03:27 <osa1> c_wraith: are you sure such a syntax exists?
13:03:50 <c_wraith> osa1: maybe you need parens..  $([q| .. |])
13:04:28 <osa1> c_wraith: still doesn't work
13:04:36 <shinka> The cabal survival guide (https://wiki.haskell.org/Cabal/Survival) says to unpack a package and manually bumping the upper bound to solve incompatible version bounds, and then point cabal install to this directory. I can't find how to point cabal to the directory with the modified package, can someone point me to the documentation.
13:04:44 <c_wraith> osa1: I'm sure that being able to leave the leading $ off of splices at the top level is a new thing.
13:04:55 <kallisti> I wasn't aware quasiquotes worked at top-level because they produce expressions
13:05:10 <osa1> kallisti: they can produce declarations too
13:05:17 <kallisti> ah I see
13:05:22 <c_wraith> kallisti: QuasiQuoters are actually a record that have functions to produce expressions, declarations, patterns, and something else, iirc
13:05:24 <hexagoxel> shinka: are you using sandboxes?
13:05:31 <kallisti> ah that's right
13:05:34 <kallisti> been a while since I used QQ
13:05:40 <osa1> c_wraith: by new thing do you mean GHC 7.10 thing?
13:05:53 <c_wraith> osa1: no, it was added in something like 7.2
13:06:29 <c_wraith> osa1: at least for TH splices.  QQ splices should follow the same rules, though.
13:06:47 <shinka> hexagoxel: Yes! And my code depends only on base and hakyll... Oh well...
13:07:34 <hexagoxel> shinka: `cabal sandbox add-source`, see `cabal help sandbox`
13:08:24 <hexagoxel> you add-source the-directory-containing-the-bumped-package to the sandbox
13:09:25 <osa1> c_wraith: leaving $ off is mentioned here https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/template-haskell.html but no examples of generating top-level decls using [...| |] are given.
13:09:30 <osa1> I'm wondering if that's really possible
13:09:37 <c_wraith> osa1: ah, maybe it's not
13:09:42 <osa1> noo
13:09:52 <RustyShackleford> so i'm trying to learn HSpec. In all the examples I see, there is a main function and nothing else
13:10:04 <RustyShackleford> i'm used to writing unit tests as several functions
13:10:09 <osa1> $(quoter "...") syntax is awful, I need to escape newlines ;-(
13:10:28 <RustyShackleford> you name the function after what it tests, for example handlesEmptyLines
13:10:42 <osa1> RustyShackleford: you can split them to as many functions as you want.
13:11:02 <osa1> RustyShackleford: I don't think it can generate test names from function names though, you may have to name them manually using strings
13:11:13 <shinka> hexagoxel: Thanks!
13:11:26 <RustyShackleford> osa1: so then I'd have to explicitly call each function in main?
13:11:39 <osa1> RustyShackleford: yes
13:11:51 <RustyShackleford> there must be a way to automatically run all your tests
13:12:10 <osa1> RustyShackleford: it discovers test modules but I don't think it does that for functions
13:12:24 <osa1> that might be a good feature though. I'm wondering how hard would it be to implement this
13:13:17 <RustyShackleford> Python's unittest works like this: You make a class like TestMyObject which extends the TestCase class
13:13:29 <RustyShackleford> and it has methods like handlesEmptyLines
13:13:34 <osa1> RustyShackleford: see an example here https://github.com/osa1/rho-torrent/blob/master/test/Rho/ClientSpec.hs#L44
13:13:49 <RustyShackleford> and it automagically finds all of your TestCases and runs each of its methods
13:14:55 <RustyShackleford> thanks i appreciate some example code
13:15:35 <osa1> RustyShackleford: hspec only automatically finds test modules(I think it looks at Spec suffix, e.g. MyModuleSpec is discovered but MyModule is not)
13:16:47 <osa1> RustyShackleford: it's not very different than Python version if I understand correctly. instead of disocvering classes and calling methods, this one discovers modules and calls spec function
13:17:00 <osa1> classes -> spec modules, methods -> spec function
13:17:46 <napping> What's a reasonable performance hit for basic AST/ADT stuff in OCaml or Haskell?
13:18:13 <c_wraith> napping: compared to?
13:18:20 <napping> I'm seeing Haskell something like 50%/2x slower, with isomorphic algebraic types, marked strict pretty liberally
13:18:41 <napping> Just some fiddling around with stuff for an AST-based interpreter thingy
13:18:50 <c_wraith> napping: I still don't know what it's slower than
13:19:02 <napping> Slower than equivalent O'Caml code
13:19:23 <osa1> napping: you're using -O2 in Haskell side?
13:19:29 <napping> IIRC ghc has an extra header field to support concurrency and stuff
13:19:56 <napping> yeah, -O2
13:27:18 <RustyShackleford> osa1: so the spec funtion is a function that says which test cases need to be run?
13:28:03 <clrnd> -pthread
13:30:42 * hackagebot arion 0.1.0.2 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.2 (karun012)
13:31:17 <RustyShackleford> also wondering, can I run hspec tests and see the results of the failed test
13:31:34 <RustyShackleford> something like: Test failed! expected 0 but recieved 1
13:32:46 <bennofs> What is the recommended way to get some data out of the network description in reactive-banana? In my case, I build a "context object" in the networkDescription, which needs to be given to the gui
13:39:31 <c_wraith> jle`: http://lpaste.net/129699 is a bit better of an example, because it shows some instances, demonstrating that the approach doesn't interfere with creating instances - though using different GADT constructors makes instances verbose. You might want to just use module boundaries to prevent mucking with internals and just set the type appropriately in functions that need to.
13:40:43 * hackagebot cabal-mon 1.0.0 - A monitor for cabal builds  http://hackage.haskell.org/package/cabal-mon-1.0.0 (IavorDiatchki)
13:40:44 <kallisti> how do I import a module with a package qualifier in ghci?
13:41:45 <c_wraith> kallisti: exactly the same way you would in source
13:42:15 <c_wraith> kallisti: assuming you have a sufficiently recent version of GHC.  If not, you can't do it at all
13:55:43 * hackagebot cabal-mon 1.0.1 - A monitor for cabal builds  http://hackage.haskell.org/package/cabal-mon-1.0.1 (IavorDiatchki)
14:04:57 <osa1> anyone here using http://hackage.haskell.org/package/haskell-src-exts-qq-0.6.1/docs/Language-Haskell-Exts-QQ.html ? I'm getting an exception when I run `runQ $ quoteDec dec "blah = 1"`
14:05:07 <osa1> *** Exception: Unimplemented.
14:05:43 * hackagebot ListLike 4.2.0 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.2.0 (JohnLato)
14:07:50 <gyaretto> Apparently 'a' is not in scope. https://gist.github.com/garrettoreilly/f743eb552f6669451aa8#file-parser-hs-L19
14:07:56 <gyaretto> How should I define that type?
14:08:09 <hunteriam> So if this is true: type IO a  =  RealWorld -> (a, RealWorld)
14:08:43 <hunteriam> How come I can't write x :: IO Int; x a = (1,a)
14:09:07 <geekosaur> it's not true
14:09:30 <kadoban> hunteriam: Because the first thing isn't true. It's at best kind of a lame metaphor.
14:09:31 <hunteriam> In info io and in inside io the article it seems to be true
14:09:38 <hunteriam> :info IO
14:09:43 <geekosaur> gyaretto, your 'a' in that type is free and thererfore can't be given a type at all. normally we'd say something like `type Env a = ...`
14:09:51 <hunteriam> So what is true?
14:10:09 <gyaretto> geekosaur: Oh, ohkay. Thanks!
14:10:13 <EvanR> :t (1,a)
14:10:14 <lambdabot> Num t => (t, Expr)
14:10:37 <geekosaur> hunteriam, it's showing you an analogy. the real type is hidden, and involves unboxed tuples in ghc. other compilers may use other implementations
14:11:03 <geekosaur> gyaretto, note that all your uses of Env have to specify the type parameter with that
14:11:32 <gyaretto> geekosaur: In every type signature?
14:11:38 <geekosaur> yes
14:11:49 <geekosaur> I'm not sure what you were trying to accomplish with that
14:12:04 <gyaretto> I was just trying to clean up the type signatures.
14:12:20 <hsk5> c_wraith: hey, earlier you wrote: foo bar { baz = quux} parses as foo (bar {baz = quux})
14:12:35 <gyaretto> Having ([Token], a -> String -> a) -> ([Token], a -> String -> a) for every function looked pretty messy.
14:12:39 <c_wraith> hsk5: I did indeed write that. :)
14:12:42 <hsk5> c_wraith: shouldn't it be Bar instead of bar? Since it's a value constructor. What was I missing?
14:13:03 <c_wraith> hsk5: record update syntax
14:13:17 <RustyShackleford> any time I make changes to my project, I do this: cabal clean, cabal configure, cabal build
14:13:30 <RustyShackleford> is there a way to make this shorter? just one command maybe
14:13:34 <c_wraith> @let data Bar = Bar { x :: Int }
14:13:35 <lambdabot>  .L.hs:160:12:
14:13:35 <lambdabot>      Multiple declarations of â€˜Barâ€™
14:13:35 <lambdabot>      Declared at: .L.hs:153:12
14:13:38 <c_wraith> @undefined
14:13:38 <lambdabot> Undefined.
14:13:40 <c_wraith> @let data Bar = Bar { x :: Int }
14:13:43 <lambdabot>  Defined.
14:13:47 <c_wraith> @undefined
14:13:47 <lambdabot> Undefined.
14:13:51 <RustyShackleford> maybe a way to make cabal build rebuild any changed files
14:13:52 <c_wraith> @let data Bar = Bar { x :: Int } deriving Show
14:13:54 <lambdabot>  Defined.
14:13:58 <safinaskar> nkar`: dolio ski thanks
14:14:20 <c_wraith> > let bar = Bar {x = 5} in bar {x = 3} -- hsk5 
14:14:21 <lambdabot>  Ambiguous occurrence Ã¢xÃ¢
14:14:21 <lambdabot>  It could refer to either Ã¢L.xÃ¢, defined at L.hs:151:16
14:14:21 <lambdabot>                        or Ã¢Debug.SimpleReflect.Vars.xÃ¢,
14:14:31 <hexagoxel> RustyShackleford: uhm.. cabal build?
14:14:35 <c_wraith> gah, forgot about that.
14:14:38 <c_wraith> @undefine
14:14:39 <lambdabot> Undefined.
14:14:46 <c_wraith> @let data Bar = Bar { baz :: Int } deriving Show
14:14:49 <lambdabot>  Defined.
14:14:59 <c_wraith> > let bar = Bar {baz = 5} in bar {baz = 3} -- hsk5 
14:15:01 <lambdabot>  Bar {baz = 3}
14:15:05 <geekosaur> hunteriam: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/ghc-prim-0.3.0.0/src/GHC-Types.html#IO
14:15:20 <c_wraith> hsk5: it creates a copy of the existing record with the named fields updated
14:15:27 <RustyShackleford> hexagoxel: unless i'm mistaken, running cabal build will not rebuild the executable if it exists
14:15:44 * hackagebot cabal-meta 0.4.1.3 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4.1.3 (GregWeber)
14:16:08 <geekosaur> if you turn on MagicHash and import the right modules then you can indeed work with it directly... and break things quite comprehensively if you are not careful. IO's implementation is hidden for a reason
14:17:18 <hexagoxel> RustyShackleford: i am pretty sure it does, inside a sandbox. would consider it cabal bug if it did not, sandbox or no.
14:17:35 <hsk5> c_wraith: that's some bar recursion...
14:17:46 <c_wraith> @undefine
14:17:46 <lambdabot> Undefined.
14:18:07 <c_wraith> @let data Foo = Foo { bar :: String, baz :: Int } deriving Show
14:18:09 <lambdabot>  Defined.
14:18:44 <c_wraith> > let x = Foo { bar = "Hello", baz = 0 } in x { baz = 11 }
14:18:46 <lambdabot>  Foo {bar = "Hello", baz = 11}
14:18:47 <RustyShackleford> hexagoxel: so do I want/need to use sandbox?
14:18:52 <c_wraith> hsk5: is that example better?
14:18:55 <kadoban> RustyShackleford: I just work in a sandbox, and 'cabal install' definitely updates the "installed" executable in .cabal-sandbox/bin/ or whatever it is, without further cleaning or anything.
14:19:13 <kadoban> RustyShackleford: sandboxes are pretty important, yeah. You should check into them.
14:19:29 <RustyShackleford> okay. Lets add that to the list of things I need to learn
14:19:48 <RustyShackleford> its frustrating, the language and syntax are one thing, but you also have to learn the tools
14:20:04 <hexagoxel> RustyShackleford: it really should work as well without a sandbox.
14:20:08 <hsk5> c_wraith: it's similar to before. sorry, there was no recursion. just get confused with let-in for a while, soz
14:20:19 <hsk5> c_wraith: okay, i wasn't familiar with this record updating syntax. is it used often?
14:20:24 <hsk5> to just pick one record and change it
14:20:28 <c_wraith> hsk5: at least that example shows that the other fields are undisturbed
14:20:30 <RustyShackleford> hexagoxel: cabal build doesn't. perhaps cabal install does
14:20:35 <hsk5> c_wraith: yeah
14:20:37 <kadoban> RustyShackleford: You can ignore it for now, but when you start really using haskell, sandboxes and stuff help a lot.
14:20:44 <haskell938> Hey guys, I'm trying to run an example code, which I just copy pasted. 
14:20:46 <haskell938> http://lpaste.net/129700
14:21:05 <haskell938> It gives me a parser error on input '=' on 20:19
14:21:08 <c_wraith> hsk5: Eh.  It's somewhat common of a thing.  It's not common at all to use it inline in a place its precedence in parsing is important
14:21:44 <geekosaur> haskell938: lines 20 and 21 need to be indented so they start in line with "filename1" on line 20
14:21:48 <geekosaur> er, on line 19
14:22:22 <hunteriam> geekosaur: do you have the instantiation of IO as a monad too?
14:22:33 <JackPote> Hello :)
14:22:59 <kadoban> haskell938: Lines 22 and 23 look indented incorrectly too, they should line up with 'let' from line 19.
14:23:03 <JackPote> Does someone knows about cryptocurrency in C programming ? 
14:23:38 <mniip> JackPote, which part
14:23:44 <kadoban> haskell938: Hmm, you have a mix of tabs and spaces there too, which isn't a good idea. You should pick one. Line 19 is a tab, the rest look like spaces.
14:24:07 <haskell938> okay Ill try indenting the lines
14:24:18 <JackPote> mniip : for exemple, a way to run scripts like pool cpu miner in a C programm. Librairies maybe...
14:25:18 <mniip> I don't really see how is it related to haskell... but wouldn't that be just a call to system()
14:25:39 <mniip> or if you're desperate a little binding to the cpuminer itself
14:26:17 <hsk5> c_wraith: thanks
14:26:26 <c_wraith> hsk5: you're welcome
14:26:28 <hunteriam> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/ghc-prim-0.3.0.0/src/GHC-Tuple.html
14:26:38 <hunteriam> Shouldn't we fix that seg fault?
14:27:37 <JackPote> yup, i can do that, but maybe not the most discreet
14:27:51 <hexagoxel> RustyShackleford: i cannot reproduce that, with a simple test-case. when i change any of the involved modules, it rebuilds the executable. can you provide additional information about your setup? the package.cabal?
14:27:54 <bazqux> Is the left hand side of >>= always computed in it's entirety before the right hand side?
14:27:59 <mniip> what are you trying to do
14:28:02 <hexagoxel> (without a sandbox, that is)
14:28:08 <mniip> JackPote, what are you trying to do
14:28:12 <EvanR> bazqux: no
14:28:19 <geekosaur> (1) if you're using a tuple that big, you probably deserve it (2) I think it already was fixed at one point
14:28:24 <mniip> bazqux, only the IO execution part
14:28:49 <EvanR> only the IO, if that applies, and its not to be confused with fully evaluated
14:28:52 <bazqux> mniip: So that is the case for the IO monad but not other monads?
14:28:59 <mniip> well
14:29:02 <clrnd> bazqux, and if in IO
14:29:05 <mniip> >>= is just as lazy, you realize
14:29:28 <JackPote> Simply running cpu minner without it installed on the computer. 
14:29:36 <JackPote> Or another computer.
14:29:42 <EvanR> JackPote: are you trying to steal peoples cpu time?
14:29:43 <mniip> JackPote, how would one even do that
14:29:53 <mniip> in IO >>= introduces a sequence point
14:30:01 <mniip> in other monads a 'sequence point' doesn't make much sense
14:30:05 <JackPote> Not people
14:30:09 <RustyShackleford> hexagoxel: i made a small change, reran cabal build and the executable was not rebuilt
14:30:14 <RustyShackleford> heres my cabal file http://lpaste.net/129701
14:30:27 <hexagoxel> > [error "this better not be evaluated"] >>= (const [1])
14:30:28 <lambdabot>  [1]
14:30:35 <bazqux> mniip: Ok, I _think_ I understand.
14:30:48 <bazqux> EvanR, mniip: Thanks for the help.
14:33:17 <dgorbik_> Say I implement an ORM type of library that when requesting something from a server can specify which fields needed (because there are just too many). Is there some idiomatic way in haskell to form this list of fields based on how the object is going to be used later?
14:34:13 <c_wraith> dgorbik: I would think the most idiomatic approach is to map several types to the same table, and the choice of type determines what values to fetch and store.
14:35:44 * hackagebot SHA 1.6.4.2 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.4.2 (AdamWick)
14:35:50 <c_wraith> dgorbik: That works if the use plan is relatively static.  If it's more dynamic..  well, you can't identify what fields you need in advance so well.
14:38:30 <dgorbik_> c_wraith, ah, interesting. I wonder if there is a way to semi-automatically generate those kind of types. I guess I would have to automatically derive an instance of ServerRequest or something for each of these types
14:38:56 <hexagoxel> RustyShackleford: maybe your file timestamps do not work or something? does :r work as expected in ghci?
14:39:47 <c_wraith> dgorbik: there are ways to do it semi-automatically, using things like template haskell or deriving Generic
14:41:43 <RustyShackleford> hexagoxel: er actually. I edit the files via sshfs
14:42:00 <RustyShackleford> my VPS is using EST, my current computer is using CST
14:42:13 <RustyShackleford> maybe that is the source of the problem
14:42:38 <hexagoxel> RustyShackleford: i'd bet on that being the issue :D
14:43:02 <dgorbik_> c_wraith, thanks, I will experiment with those!
14:43:04 <RustyShackleford> yep it recompiles
14:43:18 <RustyShackleford> so... that kinda sucks. Not sure how i'll fix that
14:43:32 <RustyShackleford> well you're a genius for figuring that one out
14:51:22 <hexagoxel> the guess is not that magical when the same thing has happened to you at some point before
14:57:17 <RustyShackleford> is there a good example of a large HSpec test suite?
14:57:38 <RustyShackleford> putting all my tests in main seems very unorganized
14:58:52 <NemesisD> doesn't hspec have a discover thing?
14:59:18 <NemesisD> which i think may expect a certain naming convention for discovery
15:06:58 <wlangstroth> RustyShackleford: the snap framework has a decent sized hspec suite
15:07:01 <bigs> heya
15:07:21 <bigs> does anyone have much experience with Yi? i'm just starting to hack on it and am enjoying it quite a bit
15:07:42 <bigs> i'm just curious as to whether there is any sentiment that it is fundamentally flawed / limited
15:09:39 <wlangstroth> RustyShackleford: my mistake, thatâ€™s HUnit - ignore me
15:10:36 <nitrix> Holy moly, I finally understand (->) r.
15:10:39 <nitrix> It's just (r -> a) partially applied.
15:10:40 <nitrix> I don't know why it just clicked today o:
15:10:42 <nitrix> Brilliant! So functions are functors. Why else are you hiding me Haskell?
15:11:53 <EvanR> nitrix: functions are applicatives
15:11:56 <RustyShackleford> okay i did some digging through the docs. Yeah, there is a way to automatically discover tests
15:12:02 <EvanR> nitrix: functions are monads
15:12:19 <EvanR> nitrix: functions are monoids where the arguments are the same monoid
15:12:46 <nitrix> EvanR: I guess that makes sense, since Applicatives are Functors, and Monads are Applicatives, right?
15:12:59 <EvanR> in the reverse sense yeah it makes sense
15:13:03 <Cale> It's not the functions themselves that are monads
15:13:20 <Cale> Same for functor
15:13:25 <EvanR> er i meant, the result is the monoid
15:13:32 <EvanR> if the argument is a monoid thats the comonad instance
15:13:48 <Cale> It's that the type constructor (->) e is itself a functor, for any type e
15:13:56 <nitrix> I haven't heard monoid and comonad instance before, but from the context, it makes sense.
15:14:08 <EvanR> heres a monoid example
15:14:15 <EvanR> [1,2] <> [3,4]
15:14:21 <nitrix> :t <>
15:14:22 <lambdabot> parse error on input â€˜<>â€™
15:14:25 <EvanR> > [1,2] <> [3,4]
15:14:25 <nitrix> :t (<>)
15:14:26 <lambdabot> Monoid m => m -> m -> m
15:14:27 <lambdabot>  [1,2,3,4]
15:14:29 <EvanR> > [1,2] <> mempty
15:14:31 <lambdabot>  [1,2]
15:14:43 <nitrix> Interesting.
15:15:05 <EvanR> monoids are the shit
15:15:11 <nitrix> So <>'s version for lists is the same as ++ ?
15:15:12 <EvanR> thats what of their defining laws
15:15:33 <EvanR> nitrix: yes thats mappend, i.e. <>, for lists
15:15:42 <nitrix> Just like <$> with functions is (.), or map on lists, etc.
15:15:49 <EvanR> yes
15:15:51 <nitrix> Ah, that's fascinating.
15:16:23 <nitrix> So Haskell is really just built on top of kinds and typeclasses.
15:17:22 <nitrix> The Functor is just a really strong generalized concept, then you have applicates and monads building on top of it.
15:17:51 <EvanR> so for functions... > (take 2 <> reverse) [1,2,3,4]
15:17:56 <nitrix> Then you have the different Data.* modules that standardize the common operations you'd be able to write yourself anyway.
15:17:57 <EvanR> > (take 2 <> reverse) [1,2,3,4]
15:17:59 <lambdabot>  [1,2,4,3,2,1]
15:18:33 <nitrix> I kind of like that. It means the language has very few primitives and even the most complex elements actually belongs to the library, not the core of the language.
15:19:03 <EvanR> also a lot of the language is syntax sugar on top of more basic constructs
15:19:18 <nitrix> You're thinking of `do` ?
15:19:51 <mniip> do, <- patterns, let patterns, function argument patterns
15:19:54 <EvanR> complex patterns, ranges, list comprehensions
15:19:55 <mniip> list comprehensions
15:20:03 <nitrix> Right.
15:20:12 * nitrix wags its tail.
15:20:33 <mniip> $ recently, too, became syntactic sugar
15:20:46 * hackagebot criterion 1.1.0.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.1.0.0 (BryanOSullivan)
15:20:47 <EvanR> huh
15:21:05 <hpc> because of the ST thing?
15:21:09 <mniip> yeah
15:21:12 <hpc> blech
15:21:29 <hpc> i would have liked to see a solution to that kept in the type system
15:21:50 <nitrix> Was this on the mailinglist, I think I skipped that :(
15:21:52 <mniip> hold on I need to recheck
15:22:16 <bananagram> :t take 2 <> reverse
15:22:17 <lambdabot> [a] -> [a]
15:22:27 <KaneTW> :t (<>)
15:22:28 <lambdabot> Monoid m => m -> m -> m
15:22:32 <mniip> ah no
15:22:41 <mniip> it's not a syntactic sugar
15:22:43 <dgorbik_> c_wraith, it looks like the protocol I have is just a simplified version of SQL queries. So in theory I should be able to use Groundhog with custom PersistBackend which should give me all the neat features
15:22:45 <bananagram> I thought that would compose the functions
15:22:47 <mniip> it's a special case in the type inferrer
15:23:03 <hpc> heh, that makes more sense
15:23:07 <c_wraith> dgorbik_: well, if that does the job, it's certainly convenient
15:23:55 <nitrix> I'm to the point where I need to write unit tests for my toy project.
15:24:11 <NemesisD> isn't there an include file floating around somewhere that lets you easily integrate cabal into a makefile?
15:24:40 <nitrix> I almost feel like it's unecessary. That's just how ridiculously good haskell has been to me :/
15:24:41 <dan_s> I just started reading Â¨Learn ou a HaskellÂ¨ and I already love this language! :D
15:24:50 <nitrix> But I'll make an effort. I think HUnit is pretty cool.
15:25:21 <nitrix> dan_s: There's probably a stage where you'll want to drop the book, start fiddling on a project, then get back to the book.
15:25:47 <nitrix> dan_s: You need to write haskell code to really figure the small details. I know because I'm in the same boat :)
15:25:57 <dan_s> yeah, I heard there is a lot of wizardy in Haskell!
15:26:15 <nitrix> I _seems_ like wizardry, careful!
15:26:24 <nitrix> It's actually veeery clever. Too clever :P
15:26:59 <kadoban> dan_s: There's a cis194 course that has some exercises to do, which is a nice mix. https://github.com/bitemyapp/learnhaskell has a link to it, as well as other advice
15:27:16 <kadoban> dan_s: It uses LYAH and RWH as reading material, so you'll still be able to use that.
15:27:46 <nitrix> dan_s: I'd like to suggest fpcomplete.com
15:28:05 <hpc> nitrix: well, the beauty of it is that you don't have to write all the idiotic "make sure this function returns an integer" tests you find in other languages
15:28:26 <dan_s> Thanks =) I will look into them!
15:28:31 <nitrix> dan_s: I know it's ridiculous to code in a web IDE, but the tools (Hoogle, real-time type checking, hints, style) are just great to get going.
15:29:21 <hpc> unit testing is still necessary, but every test you write will be a "real test"
15:29:25 <mniip> usually when I hear about "wizardy in haskell" I think of typesystem hacks, unboxes and primops
15:30:14 <nitrix> Now I want to try xmonad c:
15:30:23 * nitrix is a i3wm user.
15:30:23 <hpc> when STM was fairly new, "wizardry in haskell" meant enormously concurrent code
15:31:23 <monochrom> suppose you want to test this function: f :: a -> [a], f x is supposed to give you [x, x, x]
15:31:38 <monochrom> then one test is enough. f () =?= [(), (), ()]
15:32:23 <monochrom> parametricity ensures that this automatically extends to f 42 = [42, 42, 42]
15:32:41 <nitrix> How would you test IO functions? My project is a file system, but I already have mock-up file systems in a folder that can be used to test the different behaviors.
15:33:08 <hpc> for the most part, you test IO the same way as in other languages
15:33:19 <hpc> but less so, because you can restrict where IO happens
15:33:57 <hpc> or use types that wrap IO to limit your operations
15:35:27 <Lis> hello everyone. i try to prepends the same string to each element in a list. how can i do this?
15:35:42 <Lis> other than with map
15:35:53 <kadoban> Lis: Why, what's wrong with map?
15:35:58 <hpc> sounds like homework
15:36:36 <Lis> kadoban, becouse i have a map to execute a function already
15:36:48 <benzrf> u
15:36:51 <benzrf> oops
15:36:53 <kadoban> Lis: So?
15:37:08 <Lis> i want to modify the list and prepend a string before using a second map
15:37:15 <Lis> there has to me a more elegant way to do this
15:37:22 <mniip> two maps?
15:37:28 <Ferdirand> yes, fuse all your maps into one
15:37:30 <mniip> a composition of functions in the map?
15:37:45 <Lis> uhm can i get a example somewhere ?
15:37:48 <Lis> i am new to haskell
15:37:49 <erikd> Lis: map func1 $ func2 xs
15:38:06 <mniip> > map read ["1", "2", "3"]
15:38:07 <lambdabot>  [*Exception: Prelude.read: no parse
15:38:12 <mniip> oops defaulting
15:38:13 <Gurkenglas> erikd, no that applies first (func2), then (map func1)
15:38:14 <Lis> ah ok, thats writte here i think https://wiki.haskell.org/How_to_work_on_lists true?
15:38:18 <mniip> > map read ["1", "2", "3"] :: [Int]
15:38:19 <lambdabot>  [1,2,3]
15:38:22 <Ferdirand> > map (("hello"++) . show . (+1)) [1,2,3]
15:38:24 <lambdabot>  ["hello2","hello3","hello4"]
15:38:31 <mniip> > map (read . ("1" ++)) ["1", "2", "3"] :: [Int]
15:38:32 <lambdabot>  [11,12,13]
15:38:38 <Lis> awesome thank you :D
15:38:42 <mniip> or, which is equivalent,
15:38:50 <Lis> now i understand whats the . used for
15:38:54 <mniip> > map read $ map ("1" ++) ["1", "2", "3"] :: [Int]
15:38:55 <lambdabot>  [11,12,13]
15:39:03 <Ferdirand> or use a list comprehension
15:39:14 <mniip> Lis, . is the function composition operator
15:39:23 <erikd> :t (.)
15:39:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:39:49 <Lis> yea i read that already but all the tutorials on haskell are a bit odd becouse the mostly are only explained with the line above
15:39:53 <EvanR> finally i made my algorithm lazy enough to function, but now its dirt slow
15:40:05 <EvanR> doing n^2 work
15:40:34 <mniip> very often, when working with higher order functions you'll be using . because it is more elegant than a lambda
15:41:17 <mniip> > dropWhile (not . even) [1,3,5,2,7,4]
15:41:18 <lambdabot>  [2,7,4]
15:41:38 <Lis> yea lambda was the second thought of me to use
15:41:38 <hexagoxel> is there a list of common types that are _not_ instance Typeable?
15:42:22 <Lis> anyway big thanks :D can someone recommend a good book on haskell=
15:42:56 <Lis> and another question, i do not want to start flamewars but, has someone knowledge of erlang? why you prefer haskell over erlang and are there any good comparisons for booth languages?
15:44:04 <Axman6> haskell's type system makes it, imo, much more pleasurable to work with than Erlang. most of erlang's advantages are available in one form or another in Haskel
15:44:07 <Axman6> l
15:44:16 <kadoban> Lis: https://github.com/bitemyapp/learnhaskell has some good advice, specifically the cis194 course. It has suggested readings from LYAH and RWH, and exercises so some of it actually sticks.
15:44:49 <RustyShackleford> are hyphens allowed to be in module names?
15:44:59 <RustyShackleford> Hyphenated-Module.hs
15:45:44 <kadoban> I don't think so.
15:46:56 <dmj`> Lis: the typeclassopedia is *very* helpful in learning haskell ime. If you were to make a matrix of typeclasses to commonly used datatypes populated by instances you'd learn quicker I think. Then check out parallel & concurrent programming in haskell (both are free)
15:50:00 <Lis> dmj`, i read that parallelism is better with haskell, thought you need to dig deeper to get it working in erlang like it works with haskell. i also dont know weather erlang fixed those problems already. in terms of kadobans answer (you can do the all of the thing in haskell which can be done in erlang) thats maybe true. i was searching for this feature especially: http://www.cse.iitk.ac.in/users/karkare/MTP/2013-14/pankaj2014hotcode.pdf
15:51:17 <Lis> main difference is, erlang support hot loading out of the box, while haskell does paralellism out of the box
15:51:21 <Lis> as far as i understand it
15:51:24 <dgorbik_> Lis, just write a somewhat big project in Haskell and you will learn much faster
15:51:44 <dgorbik_> read necessary chapters from LYAH and RWH when you hit a wall
15:51:54 <Lis> dgonyeo, i already do. it took me 1 day to understand monads, what i propabbly wouldnt in that time without math studies
15:52:27 <Lis> btw "think i understood it" :D
15:52:41 <dgorbik_> Lis, it's impossible to understand monads without using them for several weeks.
15:52:45 <Lis> the keyword is morphism
15:52:56 <arkeet> understanding the definition is one thing.
15:53:47 <dgorbik_> Lis, morphism?
15:54:34 <kadoban> Lis: By the way, I never said what you think I did. Someone else did.
15:57:13 <Lis> dgorbik_, in maths there are different expressions for relating sets. isomorphism homomorphisms epimorphism etc.
15:58:15 <Lis> dgonyeo, monads are expressed using morphisms
15:58:35 <arkeet> that's not a very meaningful statement.
15:58:40 <dgorbik_> Lis, mm, how?
15:58:52 <mniip> I prefer to think of monads as of a way to compose effectful computations
15:59:47 <mniip> or as a way to plumber an effectful value into a function returning another effectful value
15:59:55 <mniip> (>=> and >>= definitions respectively)
16:00:49 * hackagebot arion 0.1.0.3 - Watcher and runner for Hspec  http://hackage.haskell.org/package/arion-0.1.0.3 (karun012)
16:01:14 <Lis> dgorbik_, to not have to teach a whole math course, think of it as the one set can be transformed to either the resulting set or a different set
16:01:35 <pacak> mniip: You don't understand, monads are little fuzzy thigs, like burritos!
16:01:50 <mniip> yeah burritos
16:01:55 <dgorbik_> Lis, I know a little bit of math, so you can skip some stuff. But how are monads expressed using morphisms?
16:02:12 <dgorbik_> which morphisms are this
16:02:14 <dgorbik_> these*
16:02:27 <mniip> you can put the end of a burrito inside another burrito and you have a longer burrito
16:02:41 <dgorbik_> mniip, :)
16:02:56 <dgorbik_> mniip, can I put a burrito inside of other burrito?
16:03:15 <ProofTechnique> @hoogle ResponseFile
16:03:17 <lambdabot> No results found
16:03:19 <mniip> yeah
16:03:21 <ProofTechnique> Hmm
16:03:28 <pacak> dgorbik_: Sure you can. By using burrito transformers
16:03:29 <mniip> and then use the 'join' function to collapse them into one layer
16:03:53 <mniip> burrito transformers are only if they are different kinds of burritos
16:04:00 <dgorbik_> pacak, uh, these burritos must be of different types then
16:04:38 <pacak> dgorbik_: They can be the same type, just eating them will be less convenient.
16:05:39 <mniip> if the burritos are of the same type you just use 'join'
16:07:44 <roboguy_> Lis: isn't that a little like saying the keyword to understanding limits from calculus is function?
16:08:18 <Gurkenglas> Shouldn't there be two Monoid instances for Maybe, depending on how many Nothings the mappend needs to get to return Nothing?
16:09:04 <mniip> Gurkenglas, there are
16:09:12 <roboguy_> Gurkenglas: There are more than two actually. But I'm not sure any work like that
16:09:18 <mniip> there are 3
16:09:23 <roboguy_> what do you mean by "how many Nothings"?
16:09:28 <arkeet> I'm guessing 0 or 1.
16:09:29 <mniip> Maybe, First, Last
16:09:33 <Gurkenglas> Ah, because one takes the left of two Justs and the other the right
16:10:02 <arkeet> the existing Monoid instance uses Monoid for the underlying type to smash together Just values.
16:10:10 <arkeet> it ignores the existing mempty.
16:10:14 <arkeet> (which kinda sucks.)
16:11:42 <Lis> roboguy_, why you two wear me down? Be kind and courteous. Being mean or rude scares people off and makes people not want to participate. from https://github.com/bitemyapp/learnhaskell if you want to learn it completely read the monad wiki page, i tried to explain it with 2 sentences which is obvious not enough
16:12:28 <arkeet> it's just that a statement like that doesn't really convey any real understanding.
16:12:30 <roboguy_> Lis: aw, I didn't mean to be rude. I just wasn't sure I agreed with that description
16:12:44 <mniip> > let f x y= x <> y in f <$> [Nothing, Just "a"] <*> [Nothing, Just "b"]
16:12:46 <lambdabot>  [Nothing,Just "b",Just "a",Just "ab"]
16:12:51 <mniip> > let f x y= getFirst $ First x <> First y in f <$> [Nothing, Just "a"] <*> [Nothing, Just "b"]
16:12:52 <lambdabot>  [Nothing,Just "b",Just "a",Just "a"]
16:12:53 <arkeet> any more than "monads are like burritos".
16:12:57 <mniip> > let f x y= getLast $ Last x <> Last y in f <$> [Nothing, Just "a"] <*> [Nothing, Just "b"]
16:12:58 <lambdabot>  [Nothing,Just "b",Just "a",Just "b"]
16:13:04 <RustyShackleford> how do you write tests for functions in the main module?
16:13:09 <roboguy_> there are many kinds of morphisms and most of them don't have to do with monads, is what I meant
16:13:26 <ProofTechnique> Anyone know what this is about? http://lpaste.net/129705
16:13:45 <RustyShackleford> I was getting an error because of name conflicts when I compiled the test
16:14:05 <RustyShackleford> so I renamed the module, now I can't compile the executable
16:14:12 <arkeet> show code/error?
16:14:23 <ProofTechnique> For some reason, only the second is not in scope, but the first is.
16:14:23 <RustyShackleford> er, okay
16:14:56 <Gurkenglas> I see, thanks. I expected one to produce Nothing on the first three.
16:15:17 <ProofTechnique> Even replacing the definition with the one that works doesn't help. :/
16:15:30 <arkeet> ProofTechnique: what exactly is the issue?
16:15:31 <RustyShackleford> actually i'm going to revisit this on a full stomach
16:15:36 <safinaskar> is this possible to define a prefix?
16:15:40 <RustyShackleford> i'll be back later
16:15:41 <safinaskar> like infix, but prefix?
16:16:05 <arkeet> haskell has no prefix operators, other than -
16:16:08 <mniip> safinaskar, all functions have an infix and a prefix variant
16:16:19 <ProofTechnique> arkeet: I'm working on a PR for one of ndmitchell's projects, and all it is is bringing this FilePath into scope so I can use it in CmdArgs.
16:16:40 <ProofTechnique> But for some reason it's choking on it.
16:16:52 <mniip> 'foo a b' 'a `foo` b'
16:16:52 <roboguy_> ProofTechnique: what is the line that has gets the error?
16:16:59 <mniip> '(+) a b' 'a + b'
16:17:05 <safinaskar> mniip: i mean can i do something like "infixr $ 9", but to create a prefix?
16:17:19 <arkeet> you cannot.
16:17:21 <safinaskar> mniip: for example, i want to create prefix named "[]" and i want to write "[] a"
16:17:22 <mniip> can't do that
16:17:24 <dgorbik_> Lis, well, you are claiming to have understood monads, then give some definition that doesn't make it more clear and then refuse to expand it. Why are we rude?
16:17:48 <mniip> it will have the function application precedence
16:17:57 <ProofTechnique> roboguy_: None. It complains that it's not in scope when I go to use it in Main.hs. And when I load the paths file by itself, my definition doesn't show up as in scope
16:17:59 <ProofTechnique> It's very odd.
16:18:03 <mniip> also can't have non-alphanumeric names without parentheses
16:18:12 <arkeet> ProofTechnique: how are you using it?
16:18:20 <arkeet> you should show this Main.hs.
16:18:24 <arkeet> and also the error message.
16:18:34 <safinaskar> arkeet: mniip: thanks
16:21:03 <ProofTechnique> arkeet: Minimal example: http://lpaste.net/129706
16:21:14 <ProofTechnique> Error from cabal repl is "newmain.hs:6:18: Not in scope: â€˜getJQueryDirâ€™"
16:21:45 <arkeet> maybe you are not loading the module you think you are.
16:21:48 <roboguy_> ProofTechnique: what is the name of the file that has getJQueryDir?
16:22:15 <roboguy_> the underscores make me a little suspicious
16:22:32 <ProofTechnique> This is the original file
16:22:32 <ProofTechnique> https://github.com/ndmitchell/cmdargs/blob/afc3a0940c04d4a383036327e346e362c5436c96/cmdargs-browser/Paths/Paths_cmdargs_browser.hs
16:22:52 <ProofTechnique> And where it gets used https://github.com/ndmitchell/cmdargs/blob/afc3a0940c04d4a383036327e346e362c5436c96/cmdargs-browser/Main.hs#L78
16:22:54 <arkeet> ok, you better import Paths.Paths_cmdargs_browser then
16:23:24 <ProofTechnique> I find it weird that It's not done that way in the second linked file, though.
16:23:37 <ProofTechnique> And loading the module itself works fine, it just won't let me use the new definition
16:23:47 <arkeet> do you happen to have already installed that package?
16:23:58 <arkeet> it might be taking the one that's installed rather than the one you wrote.
16:24:06 <ProofTechnique> I've only installed deps
16:24:11 <ProofTechnique> Tried cabal clean and so on
16:25:51 <arkeet> maybe use -v to see where exactly it's loading stuff from.
16:25:58 <ProofTechnique> I'm wiping the sandbox and trying again. We'll see.
16:26:34 <Lis> is this the whole error message you get? can a haskell error be that short?
16:27:13 <ProofTechnique> The complete error is
16:27:13 <ProofTechnique> newmain.hs:6:18: Not in scope: â€˜getJQueryDirâ€™
16:27:13 <ProofTechnique> Failed, modules loaded: Paths_cmdargs_browser.
16:27:51 <Lis> yea, the second line is important
16:28:20 <ProofTechnique> Well, the module where it's defined was loaded, and I can (for instance) print getDataDir
16:28:29 <ProofTechnique> But my definition doesn't seem to exist
16:28:41 <arkeet> probably because it loaded a different module with the same name.
16:28:48 <arkeet> so as I said, try -v
16:28:51 <arkeet> to see where it's coming from
16:29:04 <ProofTechnique> When the reinstallation of deps finishes, I shall
16:29:12 <Lis> can you reinstall Paths_cmdargs_browser? can you check weather the Paths_cmdargs_browser installed is the same version required for getJQeryDir?
16:29:25 <arkeet> Paths_cmdargs_browser is a module, not a package.
16:29:32 <ProofTechnique> ^
16:30:25 <spindas> Anyone know how best to get in touch with dcoutts? 
16:30:37 <Lis> but it has a seperate cabal file and can be installed with cabal
16:31:11 <arkeet> no it doesn't.
16:33:02 <ProofTechnique> arkeet: http://lpaste.net/129707
16:33:11 <ProofTechnique> That's the output of cabal repl -v
16:33:21 <arkeet> see, it's coming from dist/build/autogen/Paths_cmdargs_browser.hs
16:34:24 <arkeet> what's in there?
16:34:24 <spindas> ah, did you do "cabal install" but not "cabal build"?
16:34:25 <ProofTechnique> Hmm. The autogen version is radically different from the one I've been editing
16:35:33 <ProofTechnique> http://lpaste.net/1212448428479479808
16:35:38 <Lis> i'd say it could be a version problem
16:36:06 <Lis> you could try to unregister the package and reinstall it again
16:36:22 <Lis> maybe haskell didnt replace the new compilation with the old one
16:36:26 <Lis> that happened to me once
16:36:41 <roboguy_> you could give an explicit version annotation in the import
16:37:03 <ProofTechnique> I'm just curious where this completely different file is coming from :|
16:37:03 <roboguy_> with the PackageImports extension
16:37:29 <Lis> ProofTechnique, that maybe from a cabal update
16:37:39 <Lis> becouse cabal sucks the latest versions and install them
16:37:41 <Profpatsch> This is probably trivial, but how can I turn something like a readNextPkg :: IO Sth into a lazy list of the results?
16:37:43 <arkeet> ok, uh
16:37:54 <Profpatsch> Without evaluating the thing first?
16:38:01 <arkeet> this situation sounds familiar
16:38:10 <arkeet> trying to remember what it is.
16:38:19 <Profpatsch> And maybe being finite, with a predicate.
16:38:29 <roboguy_> Profpatsch: what do you mean by evaluating and what is Sth?
16:38:32 <Gurkenglas> (unfold :: ([Maybe Int] -> (Int, [Maybe Int])) -> [Maybe Int] -> Cofree Identity Int) <- Why does this complain that the actual type of unfold is (([Maybe Int] -> (Int, [[Maybe Int]])) -> [Maybe Int] -> Cofree [] Int)?
16:39:00 <Profpatsch> roboguy_: Sth is a Bytestring of a Network Packet in that case.
16:39:29 <Profpatsch> s/evaluate/realize/
16:39:30 <benzrf> @pl x >>= \f -> f y
16:39:30 <lambdabot> ($ y) =<< x
16:39:33 <benzrf> hmm
16:39:35 <Gurkenglas> (As in, (unfold :: ([Maybe Int] -> (Int, [Maybe Int])) -> [Maybe Int] -> Cofree Identity Int) is a substring of my sourcecode and the compiler seems to complain about a mismatch on the inside of those brackets)
16:40:48 <spindas> ProofTechnique: is https://github.com/haskell/cabal/issues/2462 applicable here?
16:40:59 <Profpatsch> roboguy_: Or is a lazy list a bad idea and I should rather use pipes or a similar library?
16:41:02 <spindas> (check mietek's comment toward the middle)
16:41:25 <Gurkenglas> (Who controls lambdabot's config files?)
16:41:31 <roboguy_> Profpatsch: I don't have much experience with pipes, but that does sound like something it would be good for
16:41:34 <arkeet> Gurkenglas: unfold :: Functor f => (b -> (a, f b)) -> b -> Cofree f a
16:41:42 <arkeet> Gurkenglas: doesn't seem to match the type you wrote.
16:41:52 <roboguy_> Profpatsch: I'm a bit confused about the question though. Where should the list come from?
16:42:01 <Gurkenglas> arkeet, seems to me that it does. Identity is a functor.
16:42:15 <Profpatsch> roboguy_: Iâ€™ve got a thing I want to read in a lazy way.
16:42:22 <arkeet> Gurkenglas: there are two `f`s in the type.
16:42:25 <arkeet> they don't line up.
16:42:34 * mietek tips hat at spindas
16:42:39 <roboguy_> Profpatsch: I think normal >>= will do that
16:42:44 <Gurkenglas> Yep, once before the [Maybe Int] and once before the Int. Dammit.
16:42:44 <roboguy_> if it's a lazy ByteString anyway
16:43:14 <ProofTechnique> spindas: I don't think so. Happy and alex are all okay, and I don't seem to have any dist/dist-sandbox stuff
16:43:33 <mietek> ProofTechnique: why are you creating your own Paths_whatever module?
16:43:37 <Gurkenglas> No wait scratch the dammit it's right
16:43:41 <mietek> ProofTechnique: This is a module automatically created by cabal
16:43:55 <mietek> ProofTechnique: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
16:43:55 <ProofTechnique> mietek: I'm not. I'm editing one that is in one of ndmitchell's repos
16:44:12 <Profpatsch> roboguy_: I want to create a function that is to my getNextPacket :: IO ByteString what lines is to getLine.
16:44:28 <Gurkenglas> f b on the left there is Identity [Maybe Int] = [Maybe Int] and Cofree f a on the right there is Cofree Identity Int
16:44:30 <Profpatsch> Oh, wait.
16:44:30 <mietek> ProofTechnique: well, are you sure your module is actually being used?
16:44:45 <Profpatsch> Itâ€™s getNextPacket :: Handler -> IO ByteString
16:44:48 <ProofTechnique> It seems evident that it's not, but I have no idea where the one that is is coming from
16:44:58 <Gurkenglas> (On the dammit line, I thought Int ought to be [Maybe Int] too, mixed up the letters <.<)
16:45:07 <mietek> ProofTechnique: linked you to the Cabal userâ€™s guide
16:45:14 <Gurkenglas> arkeet, tell me whether you still mean me to continue analyzing what you said
16:45:15 <Profpatsch> And I want a function getPackets :: Handler -> IO [ByteString]
16:45:25 <ProofTechnique> I saw. I'm trying to see if I can work anything out from there
16:45:32 <Profpatsch> If thatâ€™s at all possible.
16:45:41 <spindas> ProofTechnique: oh, I think I misunderstood your problem
16:45:49 <roboguy_> Profpatsch: ohh. How do you want to split it up?
16:45:51 * hackagebot hjsonpointer 0.2.0.0 - JSON Pointer library  http://hackage.haskell.org/package/hjsonpointer-0.2.0.0 (seagreen)
16:45:53 * hackagebot hjsonschema 0.5.1.3 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.1.3 (seagreen)
16:46:06 <Profpatsch> roboguy_: Split what up?
16:46:07 <spindas> ProofTechnique: cabal autogenerates the dist/build/autogen files when you configure ("creating dist/build/autogen")
16:46:20 <roboguy_> Profpatsch: the ByteString into [ByteString]
16:46:24 <arkeet> ok aha.
16:46:25 <roboguy_> lines uses newlines
16:46:33 <arkeet> ProofTechnique: it's auto-generated by cabal
16:46:33 <Gurkenglas> ((b -> (a, b)) -> b -> Cofree Identity a) matches (Functor f => (b -> (a, f b)) -> b -> Cofree f a), right?
16:46:38 <arkeet> the cabal file uses a data-files directive
16:46:40 <spindas> ProofTechnique: so when it goes to import Paths_whatever, it's prioritizing the one it's generated there over the one you're modifying
16:47:04 <Profpatsch> roboguy_: The real thing is nextBS from https://hackage.haskell.org/package/pcap-0.4.5.2/docs/Network-Pcap.html
16:47:07 <spindas> ...unless I've misunderstood this too, in which case please correct me on this :)
16:47:09 <Profpatsch> Maybe then itâ€™s clearer.
16:47:18 <ProofTechnique> Hmm
16:47:21 <ProofTechnique> That's irritating
16:47:26 <Profpatsch> Or itâ€™s so obvious that my question doesnâ€™t even make sense. :)
16:47:33 <arkeet> really that Paths directory shouldn't even be in the repository I think.
16:47:54 <mietek> arkeet: itâ€™s probably for cases when the project is built without using Cabal
16:47:56 <ProofTechnique> :(
16:48:05 <arkeet> right, ok.
16:48:07 <arkeet> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
16:48:14 <arkeet> hey it's the same guy.
16:48:15 <mietek> arkeet: although without knowing which project it is, itâ€™s hard to say
16:48:16 <ProofTechnique> That complicates what I was hoping would be a pretty simple patch
16:48:28 <ProofTechnique> mietek: It's CmgArgs
16:48:33 <ProofTechnique> https://github.com/ndmitchell/cmdargs/blob/afc3a0940c04d4a383036327e346e362c5436c96/cmdargs-browser/Paths/Paths_cmdargs_browser.hs
16:48:36 <ProofTechnique> *CmdArgs
16:48:51 <ProofTechnique> I was editing that file thinking that it was the one in question, but evidently not
16:49:00 <roboguy_> Profpatsch: I've never used that, but you could try something like sequence $ repeat (nextBS handle)
16:49:05 <roboguy_> I'm not sure if that'd be an infinite loop or not
16:49:15 <Profpatsch> roboguy_: Thatâ€™s infinite loop.
16:49:28 <arkeet> ProofTechnique: you better define getJQueryDir in some other, non-autogenerated module
16:49:29 <spindas> ProofTechnique: for this project, you need to modify both that Paths_whatever.hs file and add the directives to the .cabal file, as in the article arkeet linked
16:49:49 <arkeet> assuming JQuery.file is what you really want, anyway.
16:49:50 <Profpatsch> I have to actually check the ByteString, and if itâ€™s empty I know the last package was reached.
16:49:51 <spindas> if you add the directives to the .cabal file, then it should generate what you need in the autogen'd version
16:49:51 <mietek> uh.
16:50:05 <ProofTechnique> arkeet: I suppose so. I guess I can just stick it in Main.
16:50:15 * mietek runs away
16:51:44 <roboguy_> Profpatsch: something like pipes would help, but you could use something of type Monad m => (a -> Bool) -> m a -> m [a]
16:51:48 <roboguy_> like this http://haddocks.fpcomplete.com/fp/7.8/20140916-162/monad-loops/Control-Monad-Loops.html#v:unfoldWhileM
16:52:17 <Profpatsch> roboguy_: Nice!
16:52:33 <Gurkenglas> arkeet gimme attentiooooon
16:52:37 <Profpatsch> Oh, itâ€™s recursing.
16:52:53 <Profpatsch> roboguy_: So you simply did a type search? -.-
16:53:00 <roboguy_> Profpatsch: yeah
16:53:01 <Profpatsch> Should have thought about that sooner.
16:53:02 <Profpatsch> Sorry.
16:53:04 <arkeet> sorry Gurkenglas hi
16:53:06 <arkeet> what is it
16:53:11 <roboguy_> Profpatsch: that's okay!
16:53:16 <Gurkenglas> <Gurkenglas> ((b -> (a, b)) -> b -> Cofree Identity a) matches (Functor f => (b -> (a, f b)) -> b -> Cofree f a), right?
16:53:19 <arkeet> Gurkenglas: Identity b is not b.
16:53:20 <roboguy_> sometimes things like that are easy to miss
16:53:38 <Profpatsch> But I guess I have to get reminded every once in a while that I am stupid and I should feel stupid. :D
16:53:39 <Gurkenglas> That's stupid and okay thanks.
16:55:52 * hackagebot hjsonschema 0.5.2.2 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.2.2 (seagreen)
16:56:39 <Gurkenglas> (Bah now I have to put "Identity" everywhere.)
16:56:52 <arkeet> Gurkenglas: what exactly are you doing?
16:57:08 <Gurkenglas> codewars katas, lemme paste
16:57:49 <Gurkenglas> http://lpaste.net/129708
17:00:44 <Gurkenglas> Thanks again for introducing me to Cofree btw :P
17:01:17 <Gurkenglas> I have the feeling I have grasped these completely immediately, as opposed to all the other typeclasses
17:02:31 <bazqux> Does anyone know if it in possible to make Aeson tell you where in a file a parse error occurs?
17:05:03 <spindas> bazqux: does the error message from eitherDecode help?
17:05:44 <bazqux> spindas: That's what I have at the moment but I don't know what point in the file caused it.
17:06:19 <bazqux> The error is: expected an object with a single property where the property key should be either "Left" or "Right"
17:07:03 <bazqux> Which I guess means that my Either field is failing to match. But I can't understand why.
17:07:16 <spindas> bazqux: hrm, so aeson is built on top of attoparsec, which explicitly doesn't track position information
17:08:13 <bazqux> spindas: So am I reduced to trial and error, more or less, do you think?
17:09:35 <spindas> bazqux: I think so, unfortunately, unless you can manually bolt on position information somehow
17:10:16 <spindas> bazqux: you could try adding tracing, maybe? that could give you some indication of where it is before it fails
17:11:04 <bazqux> spindas: Okay, thanks for the pointer. :-)
17:12:09 <spindas> bazqux: I found this patch for aeson that reports the JSON path of the error - https://github.com/bos/aeson/pull/220
17:13:08 <spindas> bazqux: there's also this which does error locations, but it's out of date and has merge conflicts https://github.com/bos/aeson/pull/210
17:13:42 <EvanR> byte offset into a bytestring isnt going to be as helpful as a json path to the error
17:14:09 <EvanR> this might call for a more robust json parsing lib
17:14:26 <EvanR> emphasis on debug support than performance
17:16:09 <bazqux> spindas: Thanks.
17:20:29 <bazqux> Through trial and error I seem to have linked the bug to having an "Either" field in my data structure. Which makes me wonder if there is a bug in Aeson, or if Either is simply not supported,
17:21:06 <EvanR> bazqux: try adding a Left or Right tag to the json
17:21:42 <bazqux> EvanR: To the JSON itself? I'm not really in a position to modify it.
17:21:53 <bazqux> Well not easily anyway.
17:21:54 <arkeet> make your own version of Either with its own FromJSON instance?
17:22:09 <EvanR> ah, then you need to modify your target type or FromJSON instance or both
17:22:14 <spindas> bazqux, take a look at the default "Either" instance: https://github.com/bos/aeson/blob/76cc2f8b7cd708b9f68b99e2ed2588777dcd9d19/Data/Aeson/Types/Instances.hs#L115
17:24:00 <bazqux> Right Okay. I understand what's going on now. Not yet sure how I'm going to fix it yet but there you are.
17:24:06 <bazqux> Thanks again guys!
17:24:30 <EvanR> dont use Either there, i guess
17:24:45 <spindas> bazqux: instead of making your own Either with a different instance, you could do the decoding/encoding for the Either field manually instead of using aeson's instance
17:24:59 <spindas> er, did that make sense?
17:25:49 <spindas> like, in FromJSON, branch to a Left or Right path yourself, and do Left <$> decode ... and Right <$> decode ...
17:25:56 <bazqux> spindas: Yes I think so. I already do that somewhere else in my code. Hopefully I can mix and match the two.
17:26:22 <spindas> okay, that's good :)
17:32:09 <dweave> hey I often hear about functional programmers crticizing most of the promise implementations in the javascript community.  Iâ€™m curious what the more functional alternative would be.  ANyone have any insights?
17:33:48 <benzrf> dweave: i dunno
17:33:52 <benzrf> what kind of criticism?
17:35:22 <shachaf> "promise" is a pretty broad term, but one interpretation of it is something that would be a monad or similar to a monad (perhaps Cont).
17:35:28 <roboguy_> dweave: how do most of the promise implementations work?
17:37:00 <dweave> rpboguy_: what it looks like: asyncTask.then(function(result) { .. do stuff ..});
17:37:07 <dweave> where the callback can itself return a promise
17:37:14 <dweave> so i guess then is a bit like a â€˜bindâ€™
17:37:28 <dweave> benzrf: Iâ€™m compiling some sources
17:37:33 <JordiGH> What's the general path to translate this function? http://codepad.org/EW1qdFz8
17:38:20 <JordiGH> I can sort of see it with a big fold, and a bunch of intermediate functions, and perhaps Maybe for indicating failure... all of which seems like it would really obscure what this function is doing.
17:38:50 <JordiGH> I would also lose the failure error message with just Maybe...
17:39:25 <JordiGH> I think it may be easier with State?
17:39:44 <porglezomp> What library should I use for HTTPS?
17:39:49 <srhb> Well, State would just make it a direct translation. Not that I actually read the code. :P
17:40:10 <porglezomp> Looking on hackage the best looking one is pronounced abandoned.
17:40:14 <EvanR> JordiGH: so, what are you trying to do, compute an answer to an optimization problem, and perhaps fail with an error?
17:40:27 <JordiGH> EvanR: This is merely the objective function.
17:40:44 <JordiGH> EvanR: I am trying to define the objective function.
17:40:49 <EvanR> im just trying to understand this one function you asked about
17:41:00 <JordiGH> This one function is the objective function.
17:41:06 <EvanR> what does this mean?
17:41:26 <arkeet> it is the function to be optimized.
17:41:32 <JordiGH> The objective function in an optimisation problem is the function whose extremum or extrema you seek.
17:41:43 <dweave> benzrf: http://www.quora.com/In-simple-terms-what-is-an-async-monad
17:41:56 <dweave> benzrf: â€œ In fact, the JavaScript Promise specs are basically poor imitations of a CPS monad that manage to simultaneously be more complex and less general because the JavaScript community is afraid of anything that sounds theoretical.â€
17:42:13 <EvanR> so the exceptions arent support to happen? or is that incoporated into the optimization problem
17:42:49 <JordiGH> EvanR: The exceptions are essentially just flow control, all callers catch InvalidPlan.
17:43:44 <EvanR> ok well you can basically do all this in haskell, just pass in the three functions, use an Either String instead of an exception
17:44:02 <dweave> benzrf: Iâ€™ve seen this sentement other places as well
17:44:16 <benzrf> lol
17:44:18 <JordiGH> lol
17:44:28 <benzrf> "because the JavaScript community is afraid of anything that sounds theoretical."
17:44:33 <benzrf> i can buy this
17:44:40 <gdoteof_> i'm pretty sure i just created the first ever object detectors for haskell books https://youtu.be/u6HPGCefm9I
17:44:54 <JordiGH> EvanR: What's your suggestion? I can't think of how to structure the code in a pretty way. Either I name all of the intermediate functions or I have a mess of lambdas.
17:44:56 <benzrf> shh
17:45:19 <EvanR> JordiGH: for a single function i often have a large where clause
17:45:24 <JordiGH> And we all know what the second hardest problem in computer science is.
17:45:52 <arkeet> what's the first hardest one?
17:45:55 <dweave> benzrf: I can definitely buy that, but I still failt to see what he means in this regard
17:45:59 <JordiGH> arkeet: Cache invalidation.
17:46:36 <JordiGH> EvanR: So a big fold for the loop, where I accumulate the contents of the Slot and the amount of capital?
17:46:46 <arkeet> sounds reasonable to me.
17:47:10 <dweave> benzrf, Iâ€™m not offended or seeking to make javascript make sense ha, I just donâ€™t understand how promises the point here.
17:47:11 <EvanR> if you need an explicit fold
17:47:24 <JordiGH> EvanR: I don't know what I need, just trying to leanr.
17:47:40 <EvanR> sometimes a large for loop can be refactored into several list operations, the final one being for example a sum
17:48:02 <JordiGH> I'm gonna whine a bit... is this really making my code better?
17:48:04 <JordiGH> Okay, done whining.
17:48:17 <EvanR> removing a big for loop probably will
17:48:21 <JordiGH> Now to puzzle it out.
17:48:41 <EvanR> your if statements look like filters to me
17:48:41 <JordiGH> I doubt it, but whatever, maybe I'll get a Haskegorical epiphany once I conclude this exercise.
17:48:56 <JordiGH> Well, the if slot statement is an obvious filter.
17:48:56 <arkeet> so your slot is either empty or a machine.
17:48:57 <porglezomp> The two hardest problems in computer science are cache invalidation, naming things, and off by one errors
17:49:03 <JordiGH> arkeet: Yeah, that's a Maybe.
17:49:05 <arkeet> you accumulate the pair of (slot, capital).
17:49:13 <JordiGH> arkeet: Yeah...
17:49:34 <arkeet> you can filter the list of machines by the plan I guess.
17:49:46 <arkeet> for each machine you update your state.
17:49:50 <arkeet> possibly failing.
17:49:53 <arkeet> :t foldlM
17:49:54 <lambdabot>     Not in scope: â€˜foldlMâ€™
17:49:54 <lambdabot>     Perhaps you meant one of these:
17:49:54 <lambdabot>       â€˜F.foldlMâ€™ (imported from Data.Foldable),
17:49:56 <arkeet> :t F.foldlM
17:49:57 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
17:50:22 <arkeet> (say, pick m to be Maybe, indicating possible failure.)
17:50:42 <JordiGH> arkeet: Okay... I don't get monadic folds yet, but maybe I will.
17:51:05 <arkeet> Maybe monad just sort of lets you exit early.
17:51:34 <JordiGH> Is Haskell smart enough to not evaluate the rest of a fold once it gets a Nothing?
17:51:40 <arkeet> > F.foldlM (\acc n -> if n < 10 then Just (acc+n) else Nothing) 0 [2,3,6,7]
17:51:42 <lambdabot>  Just 18
17:51:47 <arkeet> > F.foldlM (\acc n -> if n < 10 then Just (acc+n) else Nothing) 0 [2,3,6,200,7]
17:51:48 <lambdabot>  Nothing
17:52:00 <arkeet> sums a list of numbers, except fails if any number is at least 10.
17:52:03 <EvanR> i think its important to learn how to write things, even in python and ruby, without large for loops, for readability. if you dont, then why are you even asking
17:52:05 <arkeet> for example.
17:52:11 <EvanR> on the other hand for loops are there for stupid performance
17:52:15 <EvanR> enjoy
17:52:39 <arkeet> too bad there's no strict foldlM.
17:52:40 <JordiGH>  F.foldlM (\acc n -> if n < 10 then Just (acc+n) else Nothing) 0 [2,3..10000000]
17:52:44 <JordiGH> > F.foldlM (\acc n -> if n < 10 then Just (acc+n) else Nothing) 0 [2,3..10000000]
17:52:45 <lambdabot>  Nothing
17:52:58 <JordiGH> > F.foldlM (\acc n -> if n > 0 then Just (acc+n) else Nothing) 0 [2,3..10000000]
17:53:02 <lambdabot>  mueval-core: Time limit exceeded
17:53:08 <JordiGH> Yeah, guess it is smart enough.
17:53:34 <arkeet> because unfortunately this builds up a big thunk for the accumulator.
17:53:50 <arkeet> but yes, laziness will ensure that it'll stop doing stuff once it hits Nothing.
17:55:15 <arkeet> you could write out the loop yourself with explicit recursion though.
17:55:34 <Cale> Um, it's not laziness is it?
17:55:48 <arkeet> Nothing >>= _ = Nothing
17:55:51 <Cale> It's just the fact that the evaluator doesn't evaluate inside of unapplied lambdas
17:56:18 <Cale> That'll work just as well under strict evaluation
17:56:28 <arkeet> well, true.
17:56:56 <JordiGH> > F.foldlM (\acc n -> if n < 10 then Just (acc+n) else Nothing) 0 [2,3..]
17:56:57 <lambdabot>  Nothing
17:57:05 <JordiGH> > F.foldlM (\acc n -> if n > 1 then Just (acc+n) else Nothing) 0 [2,3..]
17:57:09 <lambdabot>  mueval-core: Time limit exceeded
17:57:33 <arkeet> reminder that you can pm the bot to experiment. :)
17:58:07 <JordiGH> Or use ghci.
17:58:12 <arkeet> yeah.
17:58:21 <porglezomp> Guys, what should I use for HTTPS?
17:58:53 <porglezomp> Since HTTP can't, and hackage reports at least one of them as deprecated/abandoned.
18:00:20 <JordiGH> Btw, how come Haskell is perfectly happy doing folds over infinite lists? It's not exactly a halting problem to determine if folding over [2,3..] will work.
18:00:49 <JordiGH> Or maybe it is, never mind.
18:00:49 <mada> Hi. Trying to install gtk3 but even pointing to /usr/include/gtk-3.0 with --extra-include-dirs doesn't help. Cabal still says 'missing C libraries': http://lpaste.net/8060476497200152576
18:01:11 <arkeet> that problem is at least semidecidable.
18:01:34 <EvanR> its not happy doing foldl over an infinite list
18:01:50 <arkeet> a normal foldl will never terminate on any infinite list.
18:02:48 <arkeet> foldlM is a bit different, since the monad thingy can change the control flow.
18:03:16 <pacak> mada: You you have -dev versions if gtk?
18:03:33 <arkeet> porglezomp: http-client-tls is a fine lower-level library for that.
18:03:40 <mada> pacak: yes, in arch they come with the package. They are in /usr/include/gtk-3.0
18:03:50 <arkeet> porglezomp: http-conduit uses it.
18:03:56 <arkeet> you can use http-conduit.
18:04:25 <pacak> mada: And pkgconfig related stuff?
18:04:42 <mada> pacak: such as?
18:05:23 <porglezomp> arkeet thanks
18:05:35 <arkeet> porglezomp: there might be others, but I don't know.
18:05:51 <JordiGH> > foldl (+) 0 [1..] -- EvanR, this doesn't error out.
18:05:52 <pacak> mada: /usr/lib/x86_64-linux-gnu/pkgconfig/gtk+-2.0.pc 
18:05:54 <lambdabot>  mueval-core: Time limit exceeded
18:05:59 <pacak> mada: But for gtk3
18:06:04 <arkeet> JordiGH: right, it just runs forever.
18:06:37 <EvanR> JordiGH: oh. yeah crashing and freezing up forever are sometimes taken together
18:06:46 <EvanR> _|_
18:07:05 <JordiGH> Well, it can't be caught early.
18:07:08 <porglezomp> > _|_
18:07:09 <lambdabot>  <hint>:1:2: parse error on input Ã¢|Ã¢
18:07:10 <JordiGH> That was my stupid question.
18:07:13 <pacak> EvanR: Bottom looks more bottomish if you display it as (_|_)
18:07:18 <porglezomp> haha
18:07:30 <JordiGH> What does Top look like?
18:07:34 <EvanR> T
18:07:53 <sx_> Is there something to write Hspec/HUnit/QuickCheck test cases, which fail after a given timeout?
18:08:26 <arkeet> curious how foldrM is defined using foldl.
18:08:36 <mada> pacak: it's there, that much I can tell, /usr/lib/pkgconfig/gtk+-3.0.pc
18:08:36 * porglezomp sighs (http-conduit depends on everything.)
18:09:01 <c_wraith> porglezomp: it's ok.  Dependencies means software reuse works.
18:09:29 <porglezomp> It's just going to take a long time to compile
18:09:45 <porglezomp> (this computer is not particularly fast.)
18:10:29 <pacak> mada: Check the log files then - I think it should be dumping everything including the operation which  actually failed.
18:10:42 <arkeet> oh, at least we can use foldlM in a stricter way.
18:10:47 <mada> pacak: thank you, will do that
18:10:49 <arkeet> > F.foldlM (\x y -> Just (x+y)) 0 [1..1000000]
18:10:51 <lambdabot>  Just *Exception: stack overflow
18:10:52 <arkeet> > F.foldlM (\ !x y -> Just (x+y)) 0 [1..1000000]
18:10:55 <lambdabot>  Just 500000500000
18:24:21 <Lis> uhm how can i extract the filename of a path? i know of uriPath but that does /foo/bar/baz.html
18:24:44 <Lis> filename of a url
18:25:55 <arkeet> > basename "/foo/bar/baz.html"
18:25:56 <lambdabot>  Not in scope: Ã¢basenameÃ¢
18:25:59 <arkeet> hm.
18:26:03 <arkeet> @let import Filesystem.Path
18:26:04 <lambdabot>  .L.hs:120:1:
18:26:04 <lambdabot>      Failed to load interface for â€˜Filesystem.Pathâ€™
18:26:04 <lambdabot>      Use -v to see a list of the files searched for.
18:26:13 <arkeet> ok, well try that.
18:26:24 <Lis> ty
18:39:26 <int-e> > let f = "a/b/c.d.e" in (takeDirectory f, takeFileName f, takeBaseName f, takeExtension f) -- from System.FilePath
18:39:27 <lambdabot>  ("a/b","c.d.e","c.d",".e")
18:41:39 <Lis> takeFileName worked with import System.FilePath.Posix
18:41:52 <Lis> or last . splitFileName .
18:48:18 <benzrf> > boop
18:48:19 <lambdabot>  Not in scope: Ã¢boopÃ¢
18:48:19 <lambdabot>  Perhaps you meant one of these:
18:48:19 <lambdabot>    Ã¢loopÃ¢ (imported from Control.Arrow),
18:48:21 <benzrf> whats up with that
18:48:28 <benzrf> this Ã¢ crap
18:49:57 <Cale> @undefine
18:49:57 <lambdabot> Undefined.
18:50:01 <Cale> > boop
18:50:02 <lambdabot>  Not in scope: Ã¢boopÃ¢
18:50:02 <lambdabot>  Perhaps you meant one of these:
18:50:02 <lambdabot>    Ã¢loopÃ¢ (imported from Control.Arrow),
18:50:04 <Cale> interesting
18:50:21 <Cale> Looks like the wrong encoding is being used
18:52:40 <pacak> > boop
18:52:41 <lambdabot>  Not in scope: Ã¢boopÃ¢
18:52:41 <lambdabot>  Perhaps you meant one of these:
18:52:41 <lambdabot>    Ã¢loopÃ¢ (imported from Control.Arrow),
18:53:18 <dgorbik_> > putStrLn "does it do IO?"
18:53:20 <lambdabot>  <IO ()>
18:54:08 <dgorbik_> > unsafePerformIO $ newIORef "test"
18:54:09 <lambdabot>  Not in scope: Ã¢unsafePerformIOÃ¢Not in scope: Ã¢newIORefÃ¢
18:54:09 <lambdabot>  Perhaps you meant Ã¢newSTRefÃ¢ (imported from Data.STRef)
18:54:38 <dgorbik_> :t Consumer
18:54:39 <lambdabot> Not in scope: data constructor â€˜Consumerâ€™
18:54:40 <bob_twinkles> dgorbik_: might want to test that sort of thing in a PM to lambdabot =P
18:54:44 <Cale> int-e: are you here?
18:55:12 <Cale> Oh, what? The quotes look okay there.
18:55:15 <Cale> > boop
18:55:16 <lambdabot>  Not in scope: Ã¢boopÃ¢
18:55:16 <lambdabot>  Perhaps you meant one of these:
18:55:16 <lambdabot>    Ã¢loopÃ¢ (imported from Control.Arrow),
18:55:21 <dgorbik_> bob_twinkles :D
18:55:21 <Cale> but still not there
18:55:25 <Cale> > Boop
18:55:26 <lambdabot>  Not in scope: data constructor Ã¢BoopÃ¢
18:55:30 <Cale> ...
18:55:39 <Cale> bizarre
18:55:44 <pacak> lambdabot was broken recently...
18:57:41 <mgsloan> Maybe a GHC update?  GHC changed its identifier quotes to be unicode
18:58:11 <Axman6> the quotes look broken here, they're a's with ^'s on top
18:58:27 <mgsloan> Yeah, definitely an encoding issue along the way
18:59:06 <Axman6> though the quotes around Consumer for dgorbik_'s :t query above are fine
19:00:53 <kaidelong> > Ã¢
19:00:54 <lambdabot>  Not in scope: Ã¢ÃƒÂ¢Ã¢
19:01:24 <arkeet> haha
19:02:29 <EvanR> > Ã¢ÃƒÂ¢Ã¢
19:02:30 <lambdabot>  Not in scope: Ã¢ÃƒÂ¢ÃƒÃ¢Not in scope: Ã¢ÃƒÂ¢Ã¢Not in scope: Ã¢Ã‚Â¢Ã¢
19:02:34 <kaidelong> GHC source files can be UTF-8, UTF-16, or UTF-32 right?
19:02:58 <EvanR> *does not compute does not compute does not compute*
19:02:59 <kaidelong> what kind of mode does lambdabot run in?
19:03:02 <kaidelong> UTF-8 in and out?
19:03:11 <kaidelong> also that output is bizzare
19:03:39 <arkeet> > "Ã¢ÃƒÂ¢Ã¢"
19:03:40 <lambdabot>  "\226\195\162\226"
19:03:53 <arkeet> > text "Ã¢ÃƒÂ¢Ã¢"
19:03:54 <lambdabot>  ÃƒÂ¢ÃƒÃ‚Â¢ÃƒÂ¢
19:04:04 <ProofTechnique> Well, that's a thing
19:04:06 <pacak> > text "Ñ‹"
19:04:07 <lambdabot>  Ã‘
19:04:23 <pacak> > text "`"
19:04:24 <lambdabot>  `
19:04:25 <Axman6> pacak: those two render completely differently for me o.O
19:04:30 <dgorbik_> "Ñ‚ÐµÑÑ‚"
19:04:34 <dgorbik_> > "Ñ‚ÐµÑÑ‚"
19:04:35 <lambdabot>  "\1090\1077\1089\1090"
19:04:43 <Axman6> lambdabot's response is Ã‘
19:04:48 <pacak> yep
19:04:50 <ProofTechnique> > text "Ñ‚ÐµÑÑ‚"
19:04:51 <lambdabot>  Ã‘ÃÂµÃ‘Ã‘
19:04:54 <Axman6> heh
19:05:00 <Axman6> how bizarre
19:05:05 <arkeet> > text "a\nb"
19:05:06 <lambdabot>  a
19:05:06 <lambdabot>  b
19:05:20 <dgorbik_> that usually happens when you try to print out ByteString.Char8 as UTF8 
19:05:29 <pacak> > text "ä½ å¥½"
19:05:30 <lambdabot>  Ã¤Â½Â Ã¥Â¥Â½
19:06:03 <ProofTechnique> > text "hej dÃ¥"
19:06:04 <lambdabot>  hej dÃƒÂ¥
19:06:07 <pacak> lambdabot: Go home lambdabot, you're drunk
19:07:41 <pacak> > text "ã“ã‚“ã«ã¡ã¯"
19:07:42 <FireFly> It's mojibake
19:07:43 <lambdabot>  Ã£Ã£Ã£Â«Ã£Â¡Ã£Â¯
19:07:45 <FireFly> "rÃ¤ksmÃ¶rgÃ¥s"
19:07:51 <FireFly> > "rÃ¤ksmÃ¶rgÃ¥s"
19:07:53 <lambdabot>  "r\228ksm\246rg\229s"
19:07:57 <FireFly> huh.
19:08:06 <FireFly> > text "rÃ¤ksmÃ¶rgÃ¥s"
19:08:08 <lambdabot>  rÃƒÂ¤ksmÃƒÂ¶rgÃƒÂ¥s
19:08:29 <arkeet> it seems like it's reading input correctly.
19:08:35 <arkeet> just doing weird things to the encoding.
19:08:45 <arkeet> like what dgorbik_ said.
19:09:11 <pacak> > length $ text "ã“ã‚“ã«ã¡ã¯"
19:09:12 <lambdabot>  Couldn't match expected type Ã¢[a0]Ã¢
19:09:12 <lambdabot>              with actual type Ã¢Text.PrettyPrint.HughesPJ.DocÃ¢
19:09:17 <pacak> o_O
19:09:45 <dgorbik_> does it have ByteStrings imported?
19:09:59 <pacak> :t text
19:09:59 <lambdabot> String -> Doc
19:10:04 <pacak> O_o
19:10:11 <pacak> :info Doc
19:10:18 <arkeet> it's from Text.PrettyPrint.HughesPJ
19:10:25 <arkeet> from pretty package
19:12:40 <pacak> Btw, is there any haskell libraries out there for non-blocking reading from network sockets?
19:13:13 <dgorbik_> pacak, I just use pipes with pipes-concurrency and multiple threads
19:13:47 <pacak> dgorbik_: And what kind of latency do you have?
19:14:17 <dgorbik_> pacak, do you mean network one or pipes one?
19:15:18 <jle`> c_wraith: huh, that's neat
19:15:36 <jle`> c_wraith: i'll play around with how the resulting API looks like in practice
19:15:36 <c_wraith> jle`: it's a decently far-reaching change, but it should do the job
19:15:36 <pacak> I have a bunch of sockets and one consumer. Right now I'm using mvar to sync stuff, but that gives latency up to 100-200us. With pfq it goes as low as 2us, but pfq looks a bit too derpy - found a few bugs in their kernel module
19:15:55 <c_wraith> jle`: if you decide it's a job worth doing
19:15:59 * hackagebot chell-quickcheck 0.2.5 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2.5 (JohnMillikin)
19:16:01 * hackagebot pinboard 0.5 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.5 (jonschoning)
19:17:59 <jle`> i might play around and see how the resulting api looks and assess if it adds too much cognitive overhead to beginner/intermediates
19:18:20 <jle`> but i do like the idea...and it seems solid.  nice :)
19:20:53 <dgorbik_> pacak, does it spend most of the time on the locking stuff?
19:22:05 <pacak> dgorbik_: If there's any locks it introduces extra latency, I'm trying to imlement a busy reading loop. Looks like I have to use FFI to import stuff myself.
19:28:16 <dgorbik_> pacak, I just wonder where the bottleneck is compared to pfq. It could be just haskell runtime
19:30:11 <pacak> dgorbik_: It's haskell event manager I think. pfq just uses tight loop (and it's also haskell) instead of going to sleep.
20:10:07 <enthropy> does -Wall encourage people to make gigantic where clauses?
20:10:19 <Clint> possibly
20:10:49 * enthropy wonders if -fwarn-missing-local-sigs would make people write code that makes more sense
20:11:27 <Iceland_jack> I would personally like a -fwarn-missing-instance-sigs flag, but I'm radical
20:11:36 <Iceland_jack> And joking, sorta
20:11:58 <platz> this is kind of interesting for a let, similar to a where https://github.com/ekmett/discrimination/blob/master/src/Data/Discrimination/Sorting.hs#L210
20:12:30 <Iceland_jack> Yeah this is often a nice way of getting an imperative feel
20:12:35 <platz> more of a read top-down style
20:12:45 <Iceland_jack> Yes
20:13:06 <Iceland_jack>     foo = let
20:13:06 <Iceland_jack>       x = 5
20:13:06 <Iceland_jack>       y = 42 + x
20:13:06 <Iceland_jack>       in print (2 * x + y)
20:13:28 <platz> normally people would shove them all in the where instead
20:13:46 <Iceland_jack> Yeah, it's not a common style but it's quite often more readable      
20:13:56 <enthropy> Iceland_jack: don't you need the 'in' less in-dented?
20:13:59 <Iceland_jack> no
20:15:15 <arkeet> that would be a syntax error if it was.
20:15:45 <arkeet> or not.
20:18:32 <dfeuer> in in in in
20:19:22 <dfeuer> Haskell syntax is *way* too flexible/complicated. Normal people like me can't actually understand all the intricacies, so we stick to very rigid indentation styles we know will work.
20:20:57 <platz> well you do get pretty much immediate feedback from the editor/compiler
20:21:31 <Iceland_jack> I ran into this when I was playing with Haskell's layout rules, probably re-re-re-invented after I realised it had a sequential feel to it, since then I've seen it a couple of times but I guess it's just didn't catch on
20:21:33 <platz> unlike memorizing some godforsaken clojure reader macro syntax
20:21:48 <Iceland_jack> *I guess it just
20:22:19 <heatsink> It's like pure do
20:22:39 <heatsink> main = do
20:22:40 <Iceland_jack> Exactly, with more recursive bindings 
20:22:41 <heatsink>   putStrLn "Hello"
20:22:52 <_ryan> hi how do i check if my query has data?
20:23:25 <platz> I just think the dump everything in a big where clause with unknown ordering is wanting for clarity
20:23:37 <mzero> _ryan: ? 
20:23:41 <peddie> _ryan: your query has too little data for anyone to answer it . . . more details?
20:24:04 <platz> there needs to be some hint how to digest the pieces
20:24:05 <Iceland_jack> Haskell's layout flexibility is probably bad in the large but it's excellent to craft EDSLs in (also because of ADTs, pattern matching, laziness, type system/GADTs/TFs and such)
20:24:25 <_ryan> for example data <- runDB $ selectList [UserName !=. ""] []
20:24:34 <_ryan> peddie: for example data <- runDB $ selectList [UserName !=. ""] []
20:25:07 <peddie> _ryan: are you using a particular library for this?  (I've never talked to a database from a Haskell program myself)
20:25:32 <mzero> _ryan: is this Yesod?
20:25:37 <_ryan> oh sorry i thought this is yesod chanell wrong channel...
20:25:44 <_ryan> yes it yesod.. sorry
20:25:44 <mzero> aha
20:25:50 <peddie> _ryan: no prob, good luck :)
20:26:11 <_ryan> by the way is there a yesod master here?
20:26:47 <MP2E> having a strange issue with bracket_ from the exceptions library, on exit my irc bot is supposed to serialize its state to disk, but the state gets truncated down to 16 bytes often. Using GHC 7.10.1-RC3, and then I build a newer build using git to make sure it wasn't the bug effecting shake.
20:26:57 <MP2E> literally no idea what is going on here
20:26:59 <Cale> _ryan: It's okay to ask about yesod here, there are probably some people who know it well, but they may or may not be watching right now.
20:27:21 <MP2E> https://github.com/MP2E/divebot/blob/master/src/Main.hs#L72 code in questin
20:27:23 <MP2E> question*
20:27:23 <_ryan> Cale: thank you :)
20:28:38 <MP2E> oh yeah one thing to note, if you run writeBrain during regular execution manually, it always saves just fine
20:28:51 <MP2E> (writeBrain is the serialization function that gets truncated)
20:30:14 <MP2E> stranger yet, this code worked fine before I moved it to use Text instead of String :P
20:30:26 <MP2E> starting to suspect a compiler bug but i don't know enough to be sure
20:37:13 <mzero> MP2E: when these truncated writes happen... what is the reason bracket exited?
20:37:15 <mzero> exception?
20:37:36 <MP2E> exitSuccess
20:37:43 <MP2E> but exiting with CTRL+C also triggers it
20:38:04 <MP2E> https://github.com/MP2E/divebot/blob/master/src/Main.hs#L98
20:38:35 <mzero> do you have anyway to tell if the State value is corrupted or shortened?
20:39:47 <mzero> for example
20:40:10 <mzero> perhaps change writeBrain to first hPutStrLn stderr the size of the structres in c
20:40:20 <mzero> just be sure that c is correct
20:40:28 <MP2E> ahh good idea, I'll do that
20:40:30 <mzero> or to see if the issue is corruption within your state
20:40:38 <mzero> or with the IO subsystem at the end
20:50:10 <MP2E> well that's a puzzler! seems to disappear entirely when I print the size of the structure
20:50:14 <MP2E> the bug, I mean.
20:50:30 <MP2E> huh
20:50:58 <tgeeky> a heisenbug?
20:51:12 <MP2E> might be, i'm going to poke at it more
20:51:34 <MP2E> aha
20:51:47 <MP2E> ok so it's a bit more particular than i originally though
20:51:48 <MP2E> t
20:52:00 <Iceland_jack> â€˜Heisenbugâ€™ has additional connotations after Breaking Bad
20:52:39 <tgeeky> Iceland_jack: yes, that show has caused a lot of changes for recognition of heisenberg. In a sense, unfortunate.
20:52:43 <MP2E> it works every time if the structure has already been fully evaluated. Aka if I read a serialized 'brain' and then reserialize it, it works every time. But if I use my chatlog parse function and then force it to write the brain while the application is quitting, it writes 16 bytes
20:52:51 <MP2E> interesting!
20:53:12 <MP2E> my chatlog parse function is using lazy IO i believe
20:53:27 <Iceland_jack> tgeeky: Or caused it to seem cooler because it was referenced in a TV show ;) a
20:53:30 <Iceland_jack> -a
20:54:38 <MP2E> yep prints size 0
20:54:44 <MP2E> hmm
20:55:08 <mzero> AH
20:55:12 <mzero> lazy IO
20:56:15 <mzero> I actually don't have a clear expaination  - wish tibbe were here - he'd expalin it in a snap
20:56:39 <mzero> I did notice that none of your state was strict and thought that odd
20:57:39 <mzero> perhaps on line 157       put $! decode contents
20:58:12 <mzero> also - 
20:58:24 <mzero> are lines 156 & 157 meant to be indented that much?
20:58:26 <MP2E> it works when I use readBrain first, it doesn't work if I use this function first https://github.com/MP2E/divebot/blob/master/src/Main.hs#L137
20:59:08 <MP2E> I think so, definitely open to suggestions :) This is actually my first 'real' haskell application
21:00:26 <mzero> ah
21:00:29 <mzero> but on line 130
21:00:33 <mzero> should be   return []
21:00:43 <MP2E> oh yeah
21:00:44 <mzero> you don't want [T.empty] - that's a list of one empty string...
21:01:14 <mzero> that will mask your failing to notice an error
21:01:15 <mzero> BUT
21:01:22 <mzero> the real problem here is that by using lazy IO
21:01:28 <mzero> that catch will never fire
21:01:29 <mzero> !
21:01:39 <mzero> because the IO hasn't happened when readLines returns
21:01:57 <glguy> I'ts using Text's hGetContents
21:01:58 <mzero> so no IO exception will happen (assuming one might have), and so the catch will never trigger the exception handler
21:02:09 <mzero> isn't that lazy?
21:02:12 <glguy> no
21:03:37 <glguy> The code never seems to clean up any of the Handles it opens
21:03:40 <mzero> ah- then never mind about that issue
21:03:55 <mzero> actually, I just read that hGetContents closes it's handle!
21:03:56 <MP2E> oh it doesn't, that's a good point
21:03:59 <glguy> hGetContents does close them
21:04:03 <glguy> but writeBrain doesn't 
21:04:07 <MP2E> aha :>
21:04:23 <glguy> readFile name 07= openFile name ReadMode 07>>= hGetContents
21:04:37 <glguy> That's in Data.Text, so you don't need to reimplement it
21:05:42 <glguy> instead of openFile, writing, and close file  you can use : withFile <writing>
21:05:49 <glguy> and instead of that you can use bytestring's "writeFile"
21:06:05 * hackagebot classy-prelude 0.11.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.11.0 (MichaelSnoyman)
21:06:06 <glguy> which bundles everything up
21:06:07 * hackagebot classy-prelude-yesod 0.11.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.11.0 (MichaelSnoyman)
21:06:09 * hackagebot classy-prelude-conduit 0.11.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.11.0 (MichaelSnoyman)
21:08:05 <MP2E> oh yeah, good tip. Just reduced writeBrain to 2 lines of code
21:13:36 <MP2E> hm still seems to have the bug, even using bytestring's writeFile
21:13:45 <MP2E> https://github.com/MP2E/divebot/blob/master/src/Main.hs#L137 just to make sure i'm not doing something silly
21:13:46 <glguy> MP2E: If you're playing with IRC you might join us in #haskell-irc
21:14:31 <mzero> glguy - I see you have a minecraft proxy in HS - that looks like fun
21:14:51 <randir> How can I do something like data.list.find except with a predicate of the type a -> IO Bool
21:14:56 <glguy> It was when it worked :) They changed the protocol since the time I was interested in working on it
21:15:02 <arkeet> @hoogle findM
21:15:03 <lambdabot> Data.IntMap.Strict findMax :: IntMap a -> (Key, a)
21:15:04 <lambdabot> Data.IntMap.Lazy findMax :: IntMap a -> (Key, a)
21:15:04 <lambdabot> Data.IntSet findMax :: IntSet -> Key
21:15:07 <arkeet> argh.
21:16:01 <mzero> @hoogle  (a -> IO Bool) -> [(a, b)] -> IO (Maybe b)   
21:16:01 <lambdabot> No results found
21:16:15 <arkeet> randir: http://hoogle.haskell.org/?hoogle=findM
21:16:22 <arkeet> seems like the extra package has it.
21:16:56 <randir> Perfect
21:16:59 <randir> what's the "Stream m a"?
21:17:01 <arkeet> exercise: without peeking at its source, implement it yourself.
21:17:07 <arkeet> where do you see that?
21:17:19 <arkeet> oh in the hoogle results
21:17:33 <arkeet> some thing used for stream fusion of vectors.
21:17:46 <randir> hmm, that's a good exercise, but sadly on the clock right now
21:17:51 <arkeet> :)
21:20:45 <arkeet> :t findM
21:20:46 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
21:21:02 <arkeet> > findM (const [False,True]) [1..4]
21:21:04 <lambdabot>  [Nothing,Just 4,Just 3,Just 2,Just 1]
21:21:11 <arkeet> interesting.
21:21:13 <randir> how do I delete a package from cabal?
21:21:16 <randir> or deregister it?
21:21:20 <arkeet> ghc-pkg unregister
21:21:24 <tgeeky> ^
21:21:38 <arkeet> (this will not delete the actual files)
21:22:20 <randir> so findM should be lazy, right?
21:22:28 <arkeet> what does that mean?
21:22:40 <glguy> which catch?
21:22:45 <randir> it won't check through the whole list before returning the item that matches the predicate?
21:22:47 <glguy> oh, i was scrolled up
21:22:51 <randir> lazy probably is the wrong word for that
21:23:14 <arkeet> try it out yourself.
21:23:23 <arkeet> :t findM (\a -> print a >> readLn)
21:23:24 <lambdabot> Show a => [a] -> IO (Maybe a)
21:23:46 <arkeet> oh... my ghci crashed.
21:24:24 <arkeet> that was weird.
21:24:59 <arkeet> anyway I guess that one would return the first thing the user types True for. 
21:26:19 <exio4> te paso el code
21:26:39 <exio4> eer, sorry 
21:26:48 <randir> paso.. what's that mean?
21:26:56 <randir> past?
21:27:00 <randir> paste*?
21:27:32 <exio4> randir: "I'll give you the code", did two alt-tabs instead of a single one and didn't check where I was writing.. :P 
21:27:40 <mzero> > let findM _ [] = return Nothing ; findM f (a:as) = f a >>= (\b -> if b then return (Just a) else findM f as) in findM (return . odd) [45, undefined]
21:27:40 <mzero> Just 45
21:27:41 <lambdabot>  No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe a0)))
21:27:41 <lambdabot>    arising from a use of Ã¢M41378132951936242925383.show_M41378132951936242925...
21:27:41 <lambdabot>  The type variables Ã¢m0Ã¢, Ã¢a0Ã¢ are ambiguous
21:28:01 <mzero> so that version is non-strict in the list argument - which is what I think you were after
21:28:23 <arkeet> mzero: scary, that's my definition of findM character for character. 
21:28:31 <arkeet> except I wrote findM f [].
21:28:33 <randir> exio4: Okay, cool. Estoy aprendiendo espanol, pero tengo que aprender mucho mas palabras y gramatica. And I don't have accents on my keyboard, sadly :P
21:28:43 <mzero> well - it isn't like there are too many possible reasonable definitions!
21:28:54 <arkeet> there are many alpha-equivalent ones!
21:29:30 <arkeet> oh.
21:29:33 <randir> the logic of it makes sense
21:29:39 <arkeet> I didn't put parentheses around the right side of >>=
21:29:40 <randir> still need to learn >>= and such better
21:30:24 <mzero> now if there were only   bool :: Bool -> a -> a -> a
21:30:31 <arkeet> yes.
21:30:35 <arkeet> well, a -> a -> Bool -> a
21:30:35 <EvanR> :t bool
21:30:36 <lambdabot> a -> a -> Bool -> a
21:30:36 <mzero> of course, we'd have bike shed arguments about which argument should be the one for False
21:30:42 <arkeet> the first one, of course.
21:30:51 <mzero> indeed!
21:31:00 <mzero> what?   a -> a -> Bool -> a
21:31:01 <mzero> ?
21:31:07 <EvanR> Bool -> a -> a -> a is annoying
21:31:12 <jle`> it's the same convention as `maybe`
21:31:12 <mzero> that is just peverse
21:31:14 <jle`> and `either`
21:31:31 <jle`> first argument breaks down the first constructor, second argument breaks down the second constructor
21:31:31 <arkeet> the Bool should be the last argument.
21:31:34 <jle`> :t maybe
21:31:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:31:36 <arkeet> ^
21:31:37 <jle`> :t either
21:31:37 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
21:31:41 <mzero> what jle` said!
21:31:43 <arkeet> yes.
21:31:56 <arkeet> :t \f t b -> if b then t else f
21:31:56 <lambdabot> t -> t -> Bool -> t
21:32:04 <mzero> er
21:32:05 <mzero> wait
21:32:10 <mzero> I'm brain dead tonight
21:32:11 <mzero> of course
21:32:13 <mzero> of course
21:32:14 <arkeet> :)
21:32:33 <mzero> THIS is what I get for coding python on one machine while trying to hang out in #haskell in the other
21:32:38 <EvanR> youd probably end up doing a lot of \b -> bool b foo bar if it was the other way around
21:32:54 <arkeet> which defeats the point.
21:32:59 <mzero> right
21:33:00 <mzero> right
21:33:04 <EvanR> still better than if then else ;)
21:33:06 <mzero> no no - I meant that way all around
21:33:10 <arkeet> :)
21:37:03 <randir> I love Haskell :)
21:37:16 <jle`> :D
21:37:19 <jle`> me too :3
21:37:20 <randir> I find myself, more and more, turning to haskell for quick scripting.
21:37:23 <arkeet> :3
21:37:23 <mzero> \O/
21:37:42 <randir> I think it gets a bad rep in comparision to Python and such for coming up with quick scripts
21:37:55 <randir> but honestly, the build-in string parsing library is almost better
21:38:01 <jle`> haskell's real benefit to me is in its long-term maintainability
21:38:10 <jle`> it's something that code golf snippets can't convey
21:38:21 <randir> I know, but I think it gets overlooked for the quick-coding projects 
21:38:21 <jle`> + safety
21:38:45 <randir> People think "Haskell is complicated and good for only large, provably correct code"
21:38:53 <randir> (well, some people)
21:39:13 <randir> but I find it's pretty good for quick hacked-together utility scripts for whenever I need one.
21:39:35 <EvanR> except its not good for provable correct code :(
21:39:48 <exio4> WHERE ARE THE DEPENDENT TYPES!
21:39:56 <exio4> where are my first-class proofs?
21:40:34 <randir> Well, compared to, say, python...
21:41:01 <EvanR> but python is used in space! ;)
21:41:06 <EvanR> somehow
21:41:14 <dolio> It is? Geeze.
21:41:20 <MP2E> in space, no one can hear your runtime errors
21:41:22 <benzrf> night
21:43:10 <EvanR> http://web.archive.org/web/20070607031819/http://www.python.org/ see right hand blurb lol
21:43:49 <Javran> any recommendation on s-expr based query lanuage?
21:44:14 <EvanR> recommend not
21:45:55 <mrmagneto> lol evanR
21:46:53 * Javran thinks dealing with XML is like a hell
21:47:08 <mniip> nah
21:47:16 <mniip> there are no innocent bystanders in hell
21:47:16 <dawik> id take xml over json
21:47:33 <EvanR> dawik is a plant
21:47:57 <Javran> so what're the advantages?
21:48:28 <Javran> someone even recommend me of sexp, that's why I asked that question
21:49:43 <Javran> maybe because XML has schema?
21:50:38 <EvanR> what is the use case? data transfer? data storage? data processing? data enterprise readiness?
21:51:07 * hackagebot touched 0.2.0.0 - Library (and cli) to execute a procedure on file change.  http://hackage.haskell.org/package/touched-0.2.0.0 (crough)
21:52:49 <randir> How can I make my code that uses findM run parallel? 
21:53:08 <randir> I'm searching for the first item in a large list that meets the given a -> IO Bool requirement
21:53:25 <randir> and by the nature of it, they can be run in parallel, limited only by system power
21:54:01 <randir> I would like to have about 16-32 threads going at once-- and it's not important that they be on separate cores
21:54:03 <EvanR> first split up the list, then use the stuff in Control.Parallel
21:54:51 <EvanR> whats the point of running in it parallel though if its not on separate cores
21:54:51 <randir> The list is a long text file of words, that I wanted to read from in a lazy manner
21:55:22 <EvanR> reading the file in in parallel is kind of pointless
21:55:30 <randir> web requests, sending out 10 requests and waiting for them to come back I think will be quicker than doing them sequentially 
21:55:49 <EvanR> thats more about concurrency not parallel processing
21:55:59 <EvanR> most of the requests are not doing anything
21:56:04 <EvanR> most of the time
21:56:47 <randir> So what would you advise I do?
21:57:01 <EvanR> what are you actually trying to do?
21:57:34 <randir> are you familiar with Hydra?
21:57:41 <EvanR> no
21:57:53 <randir> dictionary attack tool, targetting websites
21:58:09 <randir> I'm re-implementing the basic functionality 
21:58:25 <EvanR> to do a lot of requests concurrently, use forkIO and basic haskell concurrency stuff
21:58:30 <EvanR> Control.Concurrent
21:58:44 <jle`> randir: there's a chapter covering something very similar to that in simon marlow's concurrency book
21:58:51 <jle`> in fact almost the same
21:59:01 <randir> Oh, I know what I can do.
21:59:13 <randir> I've used Control.Concurrent pretty extensively, but it was awhile ago
21:59:45 <randir> I can, not concurrently, lazily go through the list
21:59:48 <randir> and spawn an IO computation
22:00:03 <L8D> randir: parallelism?
22:00:07 <randir> and have another thread which periodically polls some MVar to see if any of the threads have found it
22:00:26 <EvanR> so youre trying to interleave the search with web IO
22:00:31 <randir> yeah
22:00:40 <EvanR> not really parallel stuff
22:00:40 <L8D> randir: you can race threads
22:00:48 <L8D> randir: to get which one terminates first
22:01:00 <randir> L8D: How so?
22:01:04 <EvanR> thats essentially what randir was talking about doing
22:01:07 <randir> I'll need a thread pool
22:01:08 <L8D> randir: wait are you the dude who was doing the mapM stuff a few weeks ago?
22:01:20 <L8D> randir: that wanted to try each mirror until one succeeded?
22:01:31 <randir> No
22:01:37 <L8D> ok
22:02:02 <randir> going through the list and forking IO for each elem. will crash the system of course, because I'd be generating threads much faster than I'd be using them
22:02:08 <randir> then they'd be completing*
22:02:15 <L8D> randir: http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html#race
22:02:22 <randir> so I'd need a variable for max-threads that will block the main process 
22:02:32 <L8D> randir: how many threads are you thinking about spawning?
22:02:34 <EvanR> randir: in ghc forkIO threads are unusually cheap, so you might be able to spawn more than you think
22:02:49 <L8D> EvanR: I think he means crashing the server
22:02:50 <jle`> also the scheduler is pretty advanced
22:03:07 <EvanR> L8D: what server?
22:03:22 <randir> if I have 100000 web requests going out locally, nothing's gonna get done
22:03:24 <EvanR> i doubt you can crash any normal server with a single program
22:03:29 <EvanR> randir: not true
22:03:35 <randir> really?
22:03:41 <jle`> the scheduler handles that :)
22:03:49 <L8D> EvanR: he might hit an API limit or something
22:04:08 <randir> hmm
22:04:15 <randir> so if each forkIO had a get request
22:04:22 <EvanR> L8D: that could be an issue, so you want a per-target throttling maybe, and now were talking about how to DDOS somebody
22:04:45 <randir> and if nothing is found that I'm looking for in the web-request, I just close the fork
22:04:59 <randir> if something IS found I notify my "main" thread
22:05:12 <EvanR> yes
22:05:15 <randir> not sure of the best way to implement that, but something that polls an MVar would work
22:05:21 <EvanR> no
22:05:26 <randir> no?
22:05:33 <randir> ah
22:05:38 <randir> wait, why not?
22:05:45 <EvanR> randir: first of all, if you dont find anything, you dont have to do anything special to "close the fork", when the action ends, the thread goes away
22:06:06 <EvanR> second of all, you dont want to poll MVars, the point of MVars is to wait for something to happen
22:06:16 <EvanR> which is what you want, you just takeMVar
22:06:39 <randir> ah, yeah, of course
22:06:50 <randir> I've used MVar's before, I remember how they work now: it'll work perfectly
22:07:01 <randir> what about all the threads I generate that are sending out requests?
22:07:07 <randir> when I find something I don't need the rest of them
22:07:08 <EvanR> the ones that are waiting?
22:07:37 <EvanR> you can kill them all if you know their thread IDs
22:08:06 <randir> I could register each thread as I create it with a global list in an MVar
22:08:19 <EvanR> or just a regular list
22:08:20 <Hijiri> why does it have to be a global list
22:08:49 <randir> I'm just unsure how I'd have my "dispatcher" function know when to stop spawning threads
22:09:01 <randir> I guess I could have it "loop" between spawning and checking the MVar
22:09:03 <EvanR> spawn all the threads then wait
22:09:19 <randir> We're talking about 1MIL+ threads
22:09:22 <randir> can't do them all at once
22:09:24 <EvanR> so
22:09:27 <EvanR> just do it!
22:09:51 <randir> I'm going through a list, don't want to have to go to the end of the list unless I need to
22:09:58 <EvanR> why?
22:10:46 <randir> time
22:10:56 <Hijiri> traversing the list isn't going to be your bottleneck
22:11:23 <EvanR> also if you want to get an answer before finishing the list, just spawn another thread to read the MVar
22:11:26 <EvanR> or vice versa
22:11:35 <EvanR> use more threads, thats the haskell way
22:11:57 <L8D> so once you read the mvar, kill all the threads
22:12:00 <Hijiri> If you have a separate thread for spawning the multiple threads, you could just kill that when you get an answer instead of using an explicit list
22:12:08 <Hijiri> because then all the child threads will die
22:12:13 <Hijiri> at least I think that's how it works?
22:12:17 <EvanR> i dont think so
22:12:17 <Hijiri> I'm actually not sure
22:12:17 <randir> I don't think so?
22:12:26 <Hijiri> ok, nevermind then
22:12:26 <EvanR> thats erlang ;)
22:12:54 <EvanR> but a spawner thread sounds good
22:12:59 <EvanR> the main thread waits for the answer
22:13:05 <randir> This if fun :-)
22:13:10 <Hijiri> you could have the thread explicitly kill all its threads when it gets an exception
22:13:16 <randir> To switch questions a little bit, 
22:13:17 * EvanR is about to check what happens if i fork "1MIL+" threads
22:13:24 <peddie> randir: if you want to limit the number of threads for some reason, what about e.g. waiting on a QSem before spawning new ones?
22:13:27 <EvanR> yes you have to catch exceptions
22:13:29 <randir> how can I lazily read fro a file, line by line
22:13:42 <randir> peddie: that'd work work
22:13:43 <EvanR> a getLine loop
22:14:10 <EvanR> peddie: well, really should wait to optimize until its obviously necessary
22:14:50 <randir> if I have ~ 500 million threads
22:14:55 <EvanR> lol
22:14:57 <peddie> EvanR: OK, it's a way to do what randir was asking about :)  and if it's HTTP requests, the server or your kernel may not appreciate you trying to fire off a million requests at the same time
22:15:06 <randir> that's what I'm thinking
22:15:09 <peddie> even if the GHC runtime is perfectly capable of dealing with it
22:15:15 <randir> but you guys were saying the scheduler wouldn't do that?
22:15:26 <EvanR> i think you should try it before you start engineering a new runtime management ssystem
22:15:43 <randir> Well, I can't have my computer issue over a million requests at once
22:15:46 <EvanR> unless you want to tack on more zeros until im wrong before any code is written ;)
22:15:54 <randir> I'm on my school's network. I'd crash it.
22:16:01 <EvanR> youd crash the network? lol
22:16:08 * hackagebot touched 0.2.0.1 - Library (and cli) to execute a procedure on file change.  http://hackage.haskell.org/package/touched-0.2.0.1 (crough)
22:16:17 <randir> This network is on the brink of crashing with normal usage ;)
22:16:20 <EvanR> that guys torrent will suffer so much 
22:16:39 <randir> I'm serious though, wouldn't issuing millions of requests at once be a bad idea?
22:17:00 <bob_twinkles> depends on the hardware between you and what you're throwing them at
22:17:16 <peddie> also on what you're throwing them at :)
22:17:25 <randir> assume the hardware is low-end
22:17:27 <randir> because it is :P
22:18:19 <c_wraith> Polarina: I'm deeply suspicious of the type signature of https://hackage.haskell.org/package/sdl2-1.3.0/docs/Graphics-UI-SDL-Video.html#v:createWindowAndRenderer  Those last two arguments are used as out parameters in the underlying call
22:18:44 <randir> you said to have a getLine loop for reading 
22:19:01 <randir> how should I do this, so that the minimum amount of the file is loaded in memory at a given time?
22:19:13 <EvanR> by only reading one line at a time >_>
22:19:30 <randir> I meant what's the syntax for doing that :P
22:19:58 <EvanR> forever (getLine >>= doSomethingWithLine)
22:20:01 <randir> In C, I believe I'd be using a file pointer, not sure what the syntax is in Haskell
22:20:13 <randir> so getLine keeps track of where it's in, in a file?
22:20:16 <EvanR> or in C you use stdin
22:20:19 <jle`> yes
22:20:35 <Hijiri> the handle you use keeps track of where it's in
22:20:35 <randir> ah, given a file handle
22:20:53 <EvanR> getLine works with stdin, hGetLine will take a Handle
22:21:42 <EvanR> ok well my one million threads waiting a random amount of time then printing out is cinchy on this macbook air
22:22:05 <EvanR> it takes about 15 seconds
22:22:14 <randir> yeah, but are your random threads performing Network IO? ;)
22:22:21 <EvanR> wait its still going
22:22:49 <EvanR> no network, but 99% of network time is spent waiting ;)
22:23:03 <randir> right now I have findM foo passwords
22:23:20 <randir> where foo is String -> IO Bool
22:23:37 <randir> how can I make it so passwords is the file, gotten lazily line by line?
22:23:42 <randir> eh, not sure if I asked that well.
22:23:52 <randir> but you know what I mean? I can see how to use getLine with a handle
22:23:55 <EvanR> i dont see why you need to do that
22:24:07 <randir> well just want to test what I currently have
22:24:19 <EvanR> pipe the file to stdin and use getLine
22:24:58 <randir> well it seems like "readFile" is actually lazy, according to documentation 
22:25:07 <EvanR> yeah dont use that
22:25:11 <randir> why not?
22:25:17 <EvanR> lazy IO is weird
22:25:43 <EvanR> you want to get IO errors in IO
22:26:09 * hackagebot pinboard 0.6 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6 (jonschoning)
22:38:30 <randir> well
22:38:34 <randir> I'm using https://hackage.haskell.org/package/http-wget-0.6.2.3/docs/Network-HTTP-Wget.html
22:38:45 <randir> and apparently, it uses a backend server that doesn't allow many requests
22:39:03 <EvanR> wouldnt wget be a client
22:41:05 <randir> well, I got a backend server error
22:41:08 <randir> although now it's working
22:41:09 <randir> weird
22:41:51 <kadoban> Is there any guidance somewhere about picking a hackage category for a package, and also about picking a module hierarchy?
22:42:07 <randir> what's something like MVar, but that counts, so I can add or remove and it only blocks if it's at 0
22:42:17 <randir> semaphores, if I remember right
22:42:27 <randir> best way in Haskell to do this?
22:42:33 <EvanR> you can use an MVar for that
22:42:37 <EvanR> or a TVar
22:43:22 <randir> hmm.. I just realized, getLine probably isn't threadsafe?
22:43:33 <randir> is it atomic?
22:43:34 <EvanR> if you retry an STM action and nothing that you read has changed, you will block until it does
22:43:49 <EvanR> why are you using getLine from multiple threads?
22:43:58 <mniip> iirc getLine is even interleaved
22:44:06 <randir> ah, nevermind, it would be just from one thread
22:44:09 <randir> sorry, tired
22:46:10 * hackagebot peano 0.1.0.0 - Peano numbers  http://hackage.haskell.org/package/peano-0.1.0.0 (MatthewFarkasDyck)
22:51:10 * hackagebot peano 0.1.0.1 - Peano numbers  http://hackage.haskell.org/package/peano-0.1.0.1 (MatthewFarkasDyck)
22:52:06 <platz> kadoban: I was also curious about that, there doesn't seem to be much guidance beyond trying to "fit in" with previous works
22:52:32 <Hijiri> randir: there is QSem, I think it was mentioned earlier
22:52:45 <randir> I'm using Control.Concurrent.MSem
22:52:47 <randir> seems safer
22:52:52 <kadoban> platz: Hmm. Most of what's actually in existence seems like a big mess of seemingly random choices in that regard, so I'm not totally sure, heh.
22:54:04 <EvanR> kadoban: including the stdlib ;)
22:54:14 <kadoban> EvanR: Hah
22:54:26 <kadoban> Oh well, I guess it's not the most important thing ever, I'll just wing it.
22:55:29 <cfoch> is it possible to "heritage" the packages of one sandbox into another sandbox?
22:55:49 <randir> anyone used MSem?
22:55:57 <randir> Does forkfinally conflict with "with"?
22:58:25 <peddie> randir: I got the QSem idea from simon marlow's haxl code, so if you check out the haxl example code, you can see how he uses it to limit concurrency for I/O
22:59:20 <peddie> randir: https://github.com/facebook/Haxl/blob/master/example/facebook/FB/DataSource.hs#L83
23:06:11 * hackagebot semver 0.3.3.1 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.3.1 (BrendanHay)
23:10:41 <kadoban> Is there a way to generate documentation of type aliases with haddock? It shows the alias in type annotations, but it doesn't actually say what the alias means anywhere, and gives me a warning "could not find link destinations for: MyModule.MyType"
23:13:54 <enthropy> if you export MyModule.MyType, that type alias will be a hyperlink to the definition
23:14:38 <kadoban> Ohhh, thanks.
23:16:12 * hackagebot text-manipulate 0.1.3.1 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.1.3.1 (BrendanHay)
23:18:52 <TRManderson> :t (<*>)
23:18:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:19:03 <TRManderson> :t fmap (++)
23:19:04 <lambdabot> Functor f => f [a] -> f ([a] -> [a])
23:19:53 <TRManderson> :t foldr (<*>) ([id])
23:19:53 <lambdabot> [[(a -> a) -> a -> a]] -> [a -> a]
23:20:06 <TRManderson> :t foldr (<*>) (id)
23:20:07 <lambdabot> [a -> a -> a] -> a -> a
23:20:41 <TRManderson> :t foldr (<*>) id $ map (++)
23:20:42 <lambdabot>     Couldn't match expected type â€˜[a -> a -> a]â€™
23:20:42 <lambdabot>                 with actual type â€˜[[a0]] -> [[a0] -> [a0]]â€™
23:20:42 <lambdabot>     Probable cause: â€˜mapâ€™ is applied to too few arguments
23:20:51 <TRManderson> Alright, I'll stop now and move to GHCi
23:21:02 <randir> what does getLine return when a file it empty?
23:21:17 <jle`> TRManderson: you can also pm lambdabot too :)
23:21:22 <EvanR> randir: EOF is thrown
23:21:27 <TRManderson> jle`: ty
23:21:33 <randir> so an error?
23:21:41 <EvanR> an IO exception
23:21:45 <randir> k
23:22:10 <EvanR> you can use try on IO actions that might throw exceptions and deal with them. from Control.Exception
23:40:56 <randir> what's a simple quick way to do an http post?
23:41:12 <randir> I'm using the HTTP.wget library, but it has some issues with threading
23:44:39 <dgorbik_> randir, something like this? http://lpaste.net/129729
23:45:08 <dgorbik_> You can also use curl
23:46:06 <randir> dgorbik_ how would I use the first example to post a few parameters?
23:46:15 <randir> Do I have to encode content length and such?
23:46:59 <dgorbik_> randir, just replace the body with whatever parameters you have. Same format as usual: parameter=value&also=another
23:47:18 <dgorbik_> it will calculate everything automatically, this is what RequestBodyLBS is for
23:47:24 <randir> is that part of the Network.HTTP.Conduit lib?
23:47:59 <dgorbik_> randir, it's http-client lib, you can use conduit or pipes on top of it if you like
23:48:25 <dgorbik_> https://hackage.haskell.org/package/http-client
23:49:04 <randir> Okay
23:49:19 <randir> My brain is sluggis right now, been working for hours,
23:49:36 <randir> could you help me translate the code I have currently with wget?
23:49:52 <dgorbik_> sure
23:49:53 <randir> the "withManager" is throwing me off
23:50:03 <randir> I currently have html <- wget "myUrl" [] [("email",email),("pwd",pass)]
23:50:05 <dgorbik_> let's see what you have so far
23:50:29 <randir> How can I encapsulate it so I get html to store the html from a http-client request?
23:50:59 <randir> probably just return r instead of return () in the example you gave? Not sure about what the types are
23:51:21 <dgorbik_> randir, so you need a result from the request?
23:51:30 <randir> yeah
23:51:54 <randir> post request, which I believe leads to a 302 that directs to what I need
23:52:00 <randir> currently wget gives the right response
23:54:11 <dgorbik_> randir, apparently there is a way to just read everything without using conduits. One sec
23:54:27 <randir> k, ty
