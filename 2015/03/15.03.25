00:00:28 <mniip> pacak, dude
00:00:29 <randir> heh
00:00:33 <kadoban> Haha…
00:00:39 <EvanR> list comprehensions for all the things
00:00:51 <randir> indeed
00:00:51 <pacak> mniip: Buuutttt.... It's shorter this way!
00:01:11 <kadoban> It's kinda sad that that's actually true :-/
00:01:47 <EvanR> wait, thats the missing syntax i was looking for earlier ;)
00:01:49 <mniip> null [() | 0 <- product [0 | Piece Black <- [f]]]
00:02:01 <EvanR> to extract a Maybe from a sum type
00:02:39 <EvanR> listToMaybe [a | Foo a <- [x]]
00:03:41 <mniip> list comprehensions are boss
00:05:09 <randir> > concat [ s | Just s <- [Nothing, Just "c", Nothing, Just "oo", Nothing, Just "l"]]
00:05:10 <lambdabot>  "cool"
00:07:07 <kaiyin> > let loeb fs = xs where xs = fmap ($ xs) fs
00:07:08 <lambdabot>  not an expression: ‘let loeb fs = xs where xs = fmap ($ xs) fs’
00:07:59 <nkar``> int-e: remember when I was struggling with subseq?  the key to writing down the inductive definition in coq was to use inference rules.
00:08:23 * hackagebot ascii-progress 0.2.1.2 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.2.1.2 (yamadapc)
00:08:23 * hackagebot hoauth2 0.4.6 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.6 (HaishengWu)
00:09:20 <randir> You know that book "Black Hat Python"?
00:09:30 <randir> "Black Hat Haskell" needs to be written.
00:09:36 <randir> Just because.
00:14:59 <jokester> because?
00:18:45 <kaiyin> > loeb fs = xs where xs = fmap ($ xs) fs
00:18:46 <lambdabot>  <hint>:1:9: parse error on input ‘=’
00:19:00 <kaiyin> > let  loeb fs = xs where xs = fmap ($ xs) fs
00:19:01 <lambdabot>  not an expression: ‘let  loeb fs = xs where xs = fmap ($ xs) fs’
00:20:24 <randir> what's the simplest way to insert an element every 8 elements of a list?
00:21:19 <mniip> chunksOf intersperse concat?
00:23:19 * hackagebot pgdl 8.0 - pgdownloader  http://hackage.haskell.org/package/pgdl-8.0 (sifmelcara)
00:23:21 * hackagebot process-streaming 0.7.0.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.0.0 (DanielDiazCarrete)
00:28:19 * hackagebot OpenGL 2.12.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.12.0.0 (SvenPanne)
00:38:21 * hackagebot GLUT 2.7.0.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.7.0.0 (SvenPanne)
00:54:05 <{AS}> Hi, does anyone know if it possible to fast-forward/move parsec to a position in a file?
01:11:31 <zipper> jle`: Hey are you around?
01:11:37 <jle`> yea
01:11:38 <jle`> sup?
01:12:02 <zipper> jle`: Could I use auto on a server to check whether the source files have changed on disk and reload them somehow?
01:12:10 <zipper> jle`: Or the binaries
01:12:38 <zipper> jle`: This is in a web dev situation where the files may change often while the server runs.
01:13:04 <zipper> So I want automatic reloading of this. You could call the file change an event, right?
01:13:05 <jle`> you can but this is sort of a trivial thing you can do with inotify bindings
01:13:23 * hackagebot bustle 0.4.8 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.8 (WillThompson)
01:13:40 <zipper> jle`: Okay I'll google inotify bindings.
01:14:01 <jle`> there's an Auto that outputs a blip stream that emits whenever the input changes, `onChange`, so you can run `onChange` with mtime as an input, and then react on that and do stuff
01:14:18 <jle`> so if you're composing this as a part of a larger picture, then it might be useful
01:14:41 <jle`> but if all you're doing is reloading then it might not be worht the trouble :)  unless it's for fun
01:15:41 <zipper> jle`: Well one issue that I've already noticed is that inotify only works with the haskell kernel. http://hackage.haskell.org/package/hinotify
01:16:22 <zipper> jle`: I'd want it to be as platform agnostic as possible.
01:16:48 <jle`> you mean linix kernel, right?
01:16:50 <jle`> *linux
01:17:43 <zipper> jle`: LOL yeah
01:17:59 <zipper> There is no such thing as a haskell kernel.
01:18:14 <FreeFull> There is a research OS that's written in Haskell
01:18:22 <FreeFull> It's called House, and it's pretty old and basic
01:18:35 <zipper> FreeFull: wow, you don't say.
01:19:13 <jle`> you can do something like this with a a recursive IO loop, watch :: UTCTime -> IO (); watch time = do { mt <- getMTime; when (mt == time) (do my stuff); watch (max time mt) }
01:19:21 <FreeFull> http://programatica.cs.pdx.edu/House/
01:19:56 <ep0> speaking of things made with haskell
01:20:04 <ep0> do you guys know about liskell ?
01:21:01 <Iceland_jack> Yeah, cute idea
01:22:00 <jle`> but if you wanted to use auto you can too...the basic work flow would be the same as for most auto projects...it's just the "program logic" is simple enough that there isn't too much point
01:22:30 <jle`> if you really wanted to know for learning purposes, pm me or join #haskell-auto :)
01:23:16 <zipper> jle`: Doing
01:23:17 <jle`> liskell is interesting
01:23:23 <jle`> haha
01:23:26 <zipper> What is liskell?
01:23:42 <zipper> smh I should just google
01:23:46 <ep0> it's haskell semantics with lisp sintax
01:24:23 <zipper> ep0: OMFG you mean quotes on quotes on quotes? Doesn't that kinda undo the use of ($)
01:24:50 <zipper> :s/use/progress made with/
01:24:56 <ep0> and lots of ( and )
01:24:58 <frawgie> nothing wrong with lisp :)
01:25:03 <arkeet> overuse of ($) is unhealthy.
01:25:06 <ep0> if you try lisp, you'll find it very elegant
01:25:13 <ep0> and extremely powerful
01:25:13 <Iceland_jack> ($) is the root of all evil
01:25:24 <arkeet> I could never get past all the parentheses in lisp.
01:25:49 <zipper> I haven't seen that in my code but again. Almost everything I do is super trivial.
01:26:04 <ep0> hardcore lisp programmers use emacs
01:26:08 <romero_> Folks what is the "scientific" jargon for a function which we pass to a map function
01:26:18 <romero_> Not the map itself, but the thing we map via.
01:26:21 <ep0> it allows them to automatically close parens where they should close
01:26:22 <arkeet> a function.
01:26:26 <frawgie> ep0: that's why I had to move away from lisps.. im a vimer :(
01:26:27 <arkeet> an argument to map.
01:26:28 <arkeet> I dunno.
01:26:30 <romero_> A function.
01:26:31 <romero_> :P
01:26:40 <arkeet> there's not a lot to say about it.
01:26:47 <ep0> frawgie: i'm a vimer too. nice to meet you :)
01:26:47 <romero_> arkeet: well it
01:26:54 <romero_> arkeet:  has to take input A and ...
01:26:56 <Iceland_jack> romero_: map is a 'higher-order function'
01:26:56 <romero_> uhmm
01:27:15 <romero_> Iceland_jack: yea but I'm asking the function it takes, how is it called. The lower order one :)
01:27:26 <Iceland_jack> Yeah that one doesn't really have a name afaik
01:27:27 <randir> in case anyone cares, I now have a function for my chess engine that takes a piece at a given position in a given place and caculates all the legal moves it has
01:27:35 <romero_> Okey dokey then
01:27:37 <romero_> Thanks folks
01:27:40 <Iceland_jack> Maybe “callback” if you're in other languages
01:27:45 <romero_> Iceland_jack:  yeah
01:27:52 <randir> including piece collision. Haskell is fun :)
01:28:10 <romero_> Iceland_jack: thing is I have an entire library of "map callbacks" and I have no idea what to name it so people instantly get what it is.
01:28:14 <romero_> Iceland_jack:  "mappables" :P
01:28:53 <Iceland_jack> romero_: What do they do to the elements of the list?
01:29:09 <Iceland_jack> What does the list contain
01:29:35 <romero_> Iceland_jack: take it from one format and produce another format (or ensure the input format is valid). the format is defined by composing them into defining format structures
01:30:03 <arkeet> sounds sketchy.
01:30:05 <romero_> Iceland_jack: it's a modular lib, there's no single thing it produces.
01:30:07 <frawgie> btw, does anyone know of any companies using haskell in Sweden? (not universities) 
01:30:29 <romero_> Say it can map CSV string to a list or back
01:30:49 <frawgie> I have to find a new contract, and getting one related to fp/haskell would be pretty awesome
01:30:52 <Iceland_jack> romero_: Formatters or Converters or ConverterFns
01:31:17 <Iceland_jack> Since you don't know the value being produced
01:31:19 <romero_> Iceland_jack: I think I'll end up with something like this yeah
01:31:22 <romero_> Iceland_jack:  thanks
01:32:01 <romero_> BTW what I say "view" in functional context, what would people understand (not in MVC context)?
01:32:17 <Iceland_jack> romero_: ‘View’ as in view patterns or view functions
01:32:21 <randir> how can I get an "infinite" value?
01:32:33 <Iceland_jack> randir:
01:32:34 <Iceland_jack>     ones :: [Int]
01:32:34 <Iceland_jack>     ones = 1 : ones
01:32:41 <Iceland_jack> or equivalently 'cycle 1'
01:33:06 <romero_> Iceland_jack: what's the difference?
01:33:07 <randir> I mean, the value Inf
01:33:10 <randir> like NaN
01:33:17 <Iceland_jack> > 1/0
01:33:19 <lambdabot>  Infinity
01:33:25 <Iceland_jack> > 0/0
01:33:27 <lambdabot>  NaN
01:34:04 <Iceland_jack> romero_: View functions are what you informally call functions that can act as patterns in a way, like a function
01:34:04 <Iceland_jack>     uncons :: [a] -> Maybe (a, [a])
01:34:17 <romero_> Oh.
01:34:21 <randir> ty
01:34:22 <Iceland_jack> (I believe)
01:34:57 <Iceland_jack> And then you can use the ViewPattern extension to use those as ‘real’ patterns
01:34:57 <Iceland_jack>     length :: [a] -> Int
01:34:57 <Iceland_jack>     length (uncons -> Nothing)      = 0
01:34:57 <Iceland_jack>     length (uncons -> Just (_, xs)) = 1 + length xs
01:35:00 <SharpGAF> General PL question: are there any languages in which different modules may utilize different type systems / logics internally, exposing signaturs at boundaries that encode the necessary invariants?  That are then usable only from modules using a type system capable of expressing the invariants, but not necessarily types internal to the original module.
01:35:10 <SharpGAF> *signatures
01:37:05 <SharpGAF> (Apologies if this isn't the correct place to ask, as I realize this isn't strictly Haskell-related [unless GHC extensions count], but it is active and it seems like the sort of thing people here would know).
01:37:15 <Iceland_jack> romero_: Going on a quick tangent, in recent versions of GHC (7.8+) you can go even further and actually define real patterns from ViewPatterns using PatternSynonyms
01:37:15 <Iceland_jack>     pattern Nil       <- (uncons -> Nothing)
01:37:15 <Iceland_jack>     pattern Cons x xs <- (uncons -> Just (x, xs))
01:37:50 <romero_> Iceland_jack:  :D
01:37:56 <Iceland_jack> And in the next GHC 7.10 you can make them bidirectional
01:37:56 <Iceland_jack>     pattern Nil       <- (uncons -> Nothing)      where Nil  = []
01:37:56 <Iceland_jack>     pattern Cons x xs <- (uncons -> Just (x, xs)) where Cons = (:)
01:38:25 * hackagebot contravariant 1.3.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.3.1 (EdwardKmett)
01:38:39 <romero_> Curious.
01:39:01 <Iceland_jack> (of course that's a contrived example since the real way to define that would be)
01:39:01 <Iceland_jack>     pattern Nil       = []
01:39:01 <Iceland_jack>     pattern Cons x xs = x:xs
01:39:01 <Iceland_jack> (since [] adn (:) already are data constructors)
01:39:06 <Iceland_jack> *and
01:43:25 * hackagebot learning-hmm 0.3.2.1 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.2.1 (mnacamura)
01:56:48 <_ryan> hi - how do i convert my utctime to to m/d/y HH:mm format?
01:58:18 <indiagreen> _ryan: use formatTime from Data.Time.Format
01:58:36 <_ryan> can you give me snippets?
01:58:40 <_ryan> or code?
01:58:45 <indiagreen> yes, a sec
01:59:19 <indiagreen> can you say whether you're using time-1.5 or time-1.4? You can check by doing “cabal info time”
02:00:31 <_ryan> i don't know what is it. I'm using Fpcomplete IDE.
02:00:45 <indiagreen> okay
02:01:11 <indiagreen> formatTime defaultTimeLocale "%x %R"
02:01:50 <indiagreen> if it doesn't find defaultTimeLocale, you'll have to import System.Locale
02:02:47 <_ryan> can i do it on a function?
02:02:59 <_ryan> and return the formatted UTCTime?
02:03:21 <indiagreen> what do you mean?
02:03:39 <indiagreen> «formatTime defaultTimeLocale "%x %R"» takes UTCTime and returns a String
02:04:31 <indiagreen> http://lpaste.net/4048928638454726656
02:05:50 <_ryan> for example renderUTCT :: UTCTime -> Handler String  renderUTCT time = ?? don't know what's next
02:07:56 <_ryan> indiagreen: for example renderUTCT :: UTCTime -> Handler String  renderUTCT time = ?? don't know what's next
02:08:40 <kaiyin> how do you check the version of an installed package (through cabal install ...)? 
02:09:25 <adamse> kaiyin: if you're in a sandbox: cabal sandbox hc-pkg list
02:09:42 <adamse> kaiyin: if you're not in a sandbox ghc-pkg list
02:10:28 <indiagreen> _ryan: I don't know what Handler is. My guess would be just to use “return” (so that it would be «renderUTCT = return . formatTime defaultTimeLocale "%x %R"»), but it'd be easier to answer if I knew where Handler comes from
02:10:31 <adamse> kaiyin: example ghc-pkg list vector shows me versions of vector i have installed
02:11:13 <kaiyin> adamse: cool, got it. thanks.
02:12:28 <kaiyin> Has anyone had a look at this? https://www.techempower.com/benchmarks/
02:12:39 <kaiyin> It looks yesod ranks pretty low. 
02:13:22 <kaiyin> ur/web looks ok, though.
02:13:22 <_ryan> indiagreen: it says the formatTime is not in scope.
02:13:33 <indiagreen> have you imported Data.Time.Format?
02:16:40 <_ryan> it works. but it gives me a 24 hrs clock.. how about 12hrs?
02:17:45 <indiagreen> here's a list of all available formatters: http://hackage.haskell.org/package/time-1.4/docs/Data-Time-Format.html
02:18:39 <indiagreen> if you want 12h, it'll be “%I:%M” instead of “%R”, I guess
02:19:14 <_ryan> thank you very much big help for me.. :-)
02:23:49 <Flonk> Whoever said Monads are hard clearly didn't try to deal with RealFracs, Fractionals and Floatings
02:24:01 <Cale> hah
02:24:09 <merijn> Flonk: :)
02:24:53 <merijn> Flonk: FWIW, I get annoyed about explicitly converting all the time. And then I remember those 4 times I spend two weeks debugging C and C++ to find an implicit conversion bug and I feel happy about it again :p
02:26:08 <Flonk> Yeah, I suppose it has it's ups and downs
02:26:20 <Flonk> Also prevents rounding errors and the like :P
02:26:27 <Javran> I just saw GHC plans for 7.12.1 and am wondering how could the feature "Type Signature Sections" be used?
02:26:56 <indiagreen> Javran: for instance, «show . (:: Int) . read»
02:27:25 <indiagreen> or, if you're using OverloadedStrings, (:: String) could be handy
02:27:40 <Flonk> But still, ugh.. How do I compute the square root on Fractionals again?
02:28:03 <Javran> indiagreen: ah I see, got to be useful! thanks!
02:28:30 <Javran> it's like asTypeOf for identity functions
02:28:58 <merijn> :t sqrt
02:28:59 <lambdabot> Floating a => a -> a
02:29:12 <merijn> Javran: In case of doubt just realToFrac all the things :p
02:29:19 <merijn> Or fix on a specific monomorphic type
02:29:27 <jle`> type signature sections
02:29:31 <jle`> omg
02:29:41 <merijn> jle`: Yeah, I think Lennart proposed them
02:29:42 <jle`> what hath man wrought
02:29:57 <merijn> I think they're neat
02:30:12 <arkeet> Flonk: Fractional doesn't let you do that.
02:30:31 <arkeet> as the type of sqrt indicates, you need Floating.
02:31:22 <Flonk> arkeet: Can I not convert Fractional to Floating somehow?
02:31:25 <arkeet> Fractional merely lets you divide. 
02:31:26 <Flonk> and vice versa?
02:31:35 <arkeet> well, those are type classes, not types.
02:31:42 <arkeet> every type that is an instance of Floating is also an instance of Fractional.
02:31:59 <arkeet> but if you have a type that is not an instance of Floating, you cannot do sqrt on it.
02:32:01 <arkeet> e.g. Rational
02:32:18 <Flonk> Oh, I get it.
02:32:28 <Flonk> That clears it up, thanks
02:33:13 <arkeet> np :)
02:33:28 * hackagebot soap-openssl 0.1.0.2 - TLS-enabled SOAP transport (using openssl bindings)  http://hackage.haskell.org/package/soap-openssl-0.1.0.2 (AlexanderBondarenko)
02:33:56 <merijn> See also chapter 6 of the haskell report for how all the numeric classes relat
02:34:35 <Flonk> I was under the impression that Fractional and Floating exist next to each other since Fractional has properFraction (I think?) and Floating might represent an irrational number (I think?)
02:34:41 <Flonk> merijn: Yeah, maybe I should do that :)
02:36:53 <Javran> do you guys think it makes sense to let ghci allow type-checking in presence of typed holes? at least I can know whether things are unify-able
02:38:54 <jle`> if things aren't unifiable than typically you get a type error before i get a typed hole suggestion, right?
02:38:55 <Javran> for now "_1 <*> (_2 :: Functor m => m a)" and "_1 <*> (_2 :: Monad m => m a)" produce bascially the same error message, but we can type check the second one anyway
02:39:30 <jle`> ah
02:40:12 * frerich supposes his non-existant math education shows, but to me 'irrational' always meant something like 'stupid, pointless'. So 'irrational numbers' would be, like - 4. Or 17.
02:40:17 <Javran> it's kind of like using ghci like prolog xD
02:40:28 <merijn> jle`: Type hole suggestions ONLY occur when you have a name that starts with a prefix AND isn't in scope
02:40:52 <merijn> eh
02:40:57 <merijn> s/prefix/underscore
02:41:19 <echo-area> merijn: I found yet two errors in MyStateT.hs.  First, get, put, and modify should be bound to Monad m.  Then the Monad instance should be bound to Functor m in addition to the existing Monad m.
02:45:12 <merijn> echo-area: You don't need Functor m for the Monad instance, though
02:45:39 <merijn> I'm not sure you need it for Applicative either, now that I think about it
02:45:55 <echo-area> But I cannot compile without that
02:46:00 <merijn> But you're right about get/put/modify, that's whet I get for not testing my assignment :p
02:46:24 <merijn> echo-area: Probably you're using fmap somewhere, note that liftM == fmap, without functor constraint
02:46:27 <merijn> :t fmap
02:46:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:46:29 <merijn> :t liftM
02:46:30 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:46:44 <Javran> :t (<$>)
02:46:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:47:37 <echo-area> merijn: Oh, because you provided an implementation for return defined to be pure, which requires Functor
02:47:45 <Javran> oh right, Applicative is not necessary for <$> 
02:48:16 <Javran> :t unsafeCoerce
02:48:17 <lambdabot> Not in scope: ‘unsafeCoerce’
02:48:32 <merijn> echo-area: Oh, right! I'm simplifying the constraint to just always require Monad for m (which might be stronger than necessary, but that's not very important)
02:49:00 <merijn> CT people, I need help! I'm stuck in Awodey again...
02:50:19 <shiona> Someone pasted http://www.cs.toronto.edu/~sme/presentations/cat101.pdf here yesterday, and I have at least one question so far.
02:50:22 <shiona> Slide 7 seems to enforce that if f is an arrow from object A to B, and G is arrow from B to A, then g∘f would have to be ID_A. However slide 9 has two arrows going between groups named "cast to real" and "round". "round ∘ cast to real" does not seem like ID to me. Am I missing something?
02:51:10 <merijn> I don't get the definition of groups he gives on page 11. "For any set X, we have the group Aut(X) of automorphisms (or "permutations" of X, that is, isomorphisms f : X -> X. A group of permutations is a subgroup G \subset Aut(X) for some set X, that is, a group of automorphisms of X." <- I don't get this
02:51:31 <merijn> shiona: g.f = ID_A is only required if f and g form an isomorphism
02:52:01 <merijn> shiona: In fact, the definition of an isomorphism is that given f : A -> B and g : B -> A that f.g = id_A and g.f = id_B
02:52:22 <merijn> shiona: You can have any number of arrows A -> B and B -> A that are NOT isomorphisms and thus DON'T compose to the identity
02:52:51 <merijn> shiona: Also, let me link to to a slightly more in-depth CT for programmers blog :)
02:53:00 <merijn> shiona: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
02:53:06 <shiona> yes, but why does slide 7 just assume that f and g are isomorphic and therefore the pictured graph not an category
02:53:50 <merijn> shiona: Because there's probably some lecture context that you're missing? :)
02:53:58 <merijn> Slides are pretty poor for learning from in general :)
02:54:07 <shiona> merijn: true
02:54:19 <shiona> that's why I asked
02:54:48 <merijn> shiona: Anyway, the answer is that as given there you cannot conclude that "g.f = ID_A", unless that's an axiom you assume
02:55:40 <merijn> And actually, I think that slide is further wrong in that IF you accept "g.f = ID_A" etc, then g IS equal to h (upto isomorphism)
02:56:21 <shiona> I agree completely
02:56:25 <merijn> Since identity morphisms are unique and inverses are unique (both up to isomorphism, because all uniqueness in CT is upto isomorphism) therefore, if g.f = ID_A and h.f = ID_A then h = g
02:56:47 <merijn> shiona: So basically, those slides are terrible and you should read the blog I just linked ;)
02:56:55 <shiona> :D
02:57:33 <Darwin226> Hey, is there a way to have a type synonim that hides underlying type variables without losing polymorhism? Like type List = [a]
02:58:14 <Darwin226> so I could make functions like f :: List -> List that work for any list, but can't change the type
02:58:32 <merijn> Darwin226: Yes, no, maybe. Technically yes, but it probably doesn't do what you want, so no. Except sometimes it does, so maybe
02:59:17 <Darwin226> merijn: I need nothing more than a shorthand so I don't have to write Parsec s u a every time and just write MyParser a where s and u are implicit
02:59:28 <merijn> Darwin226: Sounds like you probably want RankNTypes, but I dunno how a good intro to those. "type List = forall a. [a]" <- this will not work if you wanna put List into other datatypes
02:59:51 <merijn> i.e. "Maybe (forall a. [a])" <- won't work, since this requires impredicative types which is a broken extension
03:00:23 <merijn> Darwin226: Can't you simply fix 's' and 'u' to specific types?
03:00:29 <Darwin226> merijn: I actually did try that but I can't seem to instantiate it. For example 2 : 3 : [] :: List doesn't type check
03:01:25 <Darwin226> merijn: Not really because I want the module that handles indentation parsing to fix the state component, and it depends on another module that provides parsing primitives
03:01:42 <Darwin226> That module with the primitives needs to operate on general types
03:01:50 <merijn> Darwin226: Of course that doesn't typecheck because a list of integers is not a list of "all types"
03:02:08 <jle`> Darwin226: something of the return type (forall a. [a]) means that the list must exist for *any* a that the caller can ask for
03:02:22 <jle`> like, [] :: forall a. [a]
03:02:22 <merijn> You can't get away with hiding the variable if it has some specific value
03:02:42 <jle`> that type signature means, "ask for any type `a`, and i'll give you a list of that type"
03:02:42 <merijn> Or: "length :: (forall a . [a]) -> Int
03:02:58 <jle`> so [] can be [Int], [Bool], [String], [IO ()], etc.
03:03:01 <merijn> Which says "I can give you the length, regardless of what's inside"
03:03:10 <Darwin226> jle`: Yeah, but doesn't [a] also mean that?
03:03:48 <jle`> it depends on the context you're asking about, but...
03:03:50 <Darwin226> jle`: Oh, right, it does so that also doesn't work
03:03:59 <jle`> yeah
03:03:59 <Darwin226> 2 : [] :: [a] doesn't typecheck
03:04:01 <Darwin226> That makes sense
03:04:01 <kqr> is there a Haskell equivalent of the python arrow time handling library? http://crsmithdev.com/arrow/
03:04:19 <jle`> exactly.  it's a similar thing to something like read :: Read a => String -> a
03:04:34 <Darwin226> Ok guys. I guess I'll just write the types every time. It's not that much of a hassle
03:04:35 <jle`> `read "hello"` :: Read a => a
03:04:52 <jle`> meaning... `read "hello"` can take on the type of *any* Read a that you might ever ask for
03:04:52 <merijn> kqr: I think there's only really one time library and it's fairly complete, but a bit hard to find what you want sometimes
03:05:11 <Kneiva> title raah
03:05:22 <kqr> merijn, ah okay
03:05:38 <jle`> [] :: [a] means, [] can be a list of *any* type that you might ever ask for or think of
03:06:35 <merijn> Man, why aren't of the usual CT squad online when I have questions? >.>
03:08:11 <echo-area> merijn: Functor is needed for Applicative because the Applicative class itself requires this
03:09:06 <merijn> echo-area: It merely requires Functor (MyStateT s m), not "Functor m", because Monad gives you sufficient power to replace all Applicative functions
03:09:09 <merijn> i.e.
03:09:09 <merijn> :t ap
03:09:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:09:17 <merijn> :t (<*>)
03:09:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:09:49 <merijn> echo-area: I wanted to avoid adding a ton of constraints on the instances
03:11:18 <merijn> This entire thing will be nicer once 7.10 is released and Applicative is a superclass of Monad
03:12:02 <echo-area> Will that change break compatibility?
03:13:23 <merijn> Partially, most things have been updated for months now, though, since 7.8 issued a deprecation warning for the few problematic areas
03:14:00 <merijn> echo-area: Basically, before you could define a Monad instance without defining an Applicative instance (but almost everyone already defined Applicative instances), this is no longer allowed)
03:18:56 <echo-area> merijn: I still don't understand why removing Functor in Applicative results in "Could not deduce (Functor m) arising from the superclasses of an instance declaration"
03:20:41 <SharpGAF> Re: my previous query, maybe the keyword I'm looking for should be something related to refinement types?  They seem to more-or-less capture the idea I was looking for, at least, if not the specifics.
03:21:19 <merijn> echo-area: Are you trying to use fmap in your implementation?
03:21:37 <echo-area> merijn: https://gist.github.com/herberteuler/b24a1097c1e31170f4e6  <--  This is my code
03:22:27 <echo-area> I have changed `return` so that the Monad instance doesn't require Functor
03:23:06 <kaiyin> Is there a good tutorial for setting up emacs for haskell development?
03:23:12 <merijn> echo-area: Try this change: https://gist.github.com/merijn/fb709e0ee932f3dbec05/revisions
03:23:16 <kaiyin> good and up-to-date?
03:23:39 <kaiyin> I am trying emacs 24 on osx 10.10.
03:25:55 <echo-area> merijn: That works.  I'll look into it.  Thanks
03:27:46 <echo-area> At least I learn that the constrains can be different for different defitions, since the constrains here are different from the ones in Control.Monad.Trans.State.Lazy.
03:27:55 <echo-area> *definitions
03:28:55 <merijn> echo-area: The constraints influence which functions you are able to use in the implementation
03:29:21 <merijn> echo-area: Since Monad covers all the functionality of both Functor and Applicative you can use all of them (at the cost that it works for less types)
03:30:13 <merijn> Functor is more general (works for more types), so more things can be instances, the downside is that it requires more finnicky constraints for applicative, etc.
03:30:27 <dr_diagoras> people, I'm a bit confused. I there a reason why we don't deduce automatically "(Monad m, MonadTrans t) => Monad (t m)"?
03:30:34 <dr_diagoras> *is there
03:30:50 <merijn> dr_diagoras: Because it's not guaranteed that the results in a Monad, I think
03:31:13 <merijn> I think things like ContT can play havoc there
03:32:26 <echo-area> merijn: I know why Functor is needed for Applicative: it can weaken the constrains of Functor.  I mean the Functor instances requires only a Functor before the change but a Monad after.
03:33:32 * hackagebot apiary 1.4.3 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.4.3 (HirotomoMoriwaki)
03:33:34 * hackagebot clash-prelude 0.7.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7.1 (ChristiaanBaaij)
03:33:41 <dr_diagoras> hm... then why don't we have class, that is just like MonadTrans, but guaranties preservation of Monad laws? looks like most transformers do this already
03:34:10 <merijn> echo-area: The reason why it didn't work in the initial version is that Applicative requires a Functor instance. So you had "Monad m => Applicative (MyStateT s m)" which requires "Functor (MyStateT s m)", but the only instance you had was "Functor m => Functor (MyStateT s m)", so you were effectively asking it to prove that ALL "Monad m" imply "Functor m", which it can't do
03:34:25 <merijn> dr_diagoras: Because there's no general way to guarantee preservation of Monad laws, afaik
03:35:44 <echo-area> merijn: Got it.  Thank you!
03:37:43 <merijn> echo-area: Once Functor is a superclass of Monad in 7.10 it would be able to prove that and the problem goes away :)
03:38:09 <dr_diagoras> merijn: hm... we can't prove this even for IdentityT, for example?
03:38:26 <merijn> echo-area: The other solution would be to say "(Functor m, Monad m) => Applicative (MyStateT s m)" to also convince it
03:38:48 <merijn> dr_diagoras: For a *specific* transformer sure, but we can't prove it *in general*
03:39:00 <merijn> dr_diagoras: And the instance you ask for would require a general proof
03:40:41 <echo-area> merijn: Is => not transitive?  I see in Base.hs that Functor f => Applicative f, and Applicative m => Monad m.  I thought it meant a Monad is also a Functor
03:41:39 <dr_diagoras> merijn: ah, got it. thanks. still mostly magic beyond my comprehension, though :-)
03:42:00 <merijn> echo-area: I'm betting the docs you're looking at are too new :)
03:42:05 <merijn> echo-area: That's only since 7.10
03:42:25 <merijn> echo-area: In 7.8 and earlier "class Monad m where" instead of "class Applicative m => Monad m where"
03:42:59 <merijn> echo-area: This is a historical accident due to Applicative being discovered/invented after Monad :)
03:43:00 <echo-area> Oh right, I forget I am reading source code in master >_<
03:43:33 <merijn> It's easy to forget that a lot of stuff people take for granted in modern haskell hasn't always been around ;)
03:44:31 <merijn> Monads weren't adopted until like 8 years (not entirely sure about that time) into Haskell's existence and Applicative wasn't thought up until 2004 :p
03:47:16 <untseac> omg I have to share this one. even the java bot is a jerk => <javabot> tonph: wrong window, dumbass
03:47:23 <untseac> some guy typed: clear
03:52:32 <SharpGAF> merijn: Since I'm not sure I understand: when you say "no way to guarantee" in reference to the (Monad m, MonadPreservingTrans t) => Monad (t m) thing, do you mean "no way to guarantee in Haskell"?  I thought that already applied to the monad laws themselves, but couldn't you still define the class appropriately?
03:53:08 <m0rphism> untseac: Well, lambdabot also threatens people not to be friends with them on facebook anymore, if they try to load non-existent sources ;3
03:53:24 <m0rphism> untseac: but it's more gentle in its wording, that's true ^^
03:54:13 <merijn> SharpGAF: If you assume MonadPreservingTrans only contains law preserving transformers, then sure
03:54:21 <untseac> m0rphism, the thing is that java channel is full of jerks :\
03:54:33 <merijn> SharpGAF: But my point was that with MonadTrans as-is, you don't have that
03:54:42 <untseac> and its not just because newbies make stupid questions
03:54:52 <untseac> they assume you are stupid from the start
03:54:55 <merijn> untseac: Spoken like someone who's never tried to get an answer out of ##c and ##c++, but this is rather off-topic :)
03:55:19 <untseac> lol no I haven't
03:55:24 <SharpGAF> Yeah, makes sense :)  Thanks, I just wanted to make sure there wasn't some massive flaw in my understanding.
04:23:53 <SharpGAF> Wait, now I'm reading that seq breaks the monad laws anyway (but in an uninteresting way, I guess?)
04:24:23 <opqdonut> you mean seq + IO?
04:24:55 <opqdonut> oh, all monads
04:25:07 <opqdonut> ( http://stackoverflow.com/questions/12617664/a-simple-example-showing-that-io-doesnt-satisfy-the-monad-laws/12620418#12620418 )
04:25:12 <SharpGAF> Yeah.
04:25:56 <SharpGAF> Well, all state monads at least.
04:29:31 <akegalj> What is the memory cost of holding Bool value (or any other enum). So if I define data T = A | B | C | D and create list of length N: replicate N A, then memory footprint for that list will be N*(3b + ?)
04:29:55 <akegalj> there whas a nice sheet with haskell data types overhead but i can't find it 
04:31:34 <kaiyin> how do you execute a command in emacs interactive haskell mode? for example: :t (:)
04:32:18 <kaiyin> I typed these things and pressed enter, but nothing happens, the cursor stays at the same place.
04:34:36 <SharpGAF> I guess seq is considered an unsafe function anyway, so it's a bit irrelevant.
04:35:07 <nshepperd> fast and loose reasoning is morally correct though, so we don't generally care about differences in evaluation
04:35:09 <jle`> it's not considered safe, it's well within the semantic model of haskell
04:35:13 <jle`> @google fast and loose reasoning
04:35:14 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
04:35:14 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
04:35:22 <jle`> *it's not considered unsafe
04:35:37 <jle`> but we can still ignore it and talk about things in a useful way
04:35:42 <nshepperd> ie. in most typeclass laws, 'a = b' means 'a = b modulo seq'
04:35:50 <SharpGAF> It's listed as unsafe: https://wiki.haskell.org/Unsafe_functions
04:35:54 <nshepperd> more or less
04:37:01 <SharpGAF> Yes, I'm not too concerned about it :P
04:37:28 <nshepperd> (for that reason I though it seemed weird that Data.Strict.Maybe doesn't have a Monad instance out of concern for strictness)
04:38:00 <dfeuer> nshepperd, why is that strange?
04:38:10 <dfeuer> It shouldn't have a Functor instance either, should it?
04:38:11 <m0rphism> kaiyin: just tried it with my emacs, and it works.
04:38:26 <merijn> I need some help with Awodey, on page 11 he gives the following definition, but I don't get it. "For any set X, we have the group Aut(X) of automorphisms (or "permutations" of X, that is, isomorphisms f : X -> X. A group of permutations is a subgroup G \subset Aut(X) for some set X, that is, a group of automorphisms of X."
04:39:12 <nshepperd> dfeuer: it's still both functor and monad in a total subset of haskell
04:39:16 <dfeuer> merijn, what's the problem?
04:39:24 <m0rphism> kaiyin: maybe we have different version? I'm quite new to emacs and installed haskell-mode from melpa-stable
04:39:41 <dfeuer> nshepperd, that's true, but it breaks without polymorphic seq.
04:40:30 <nshepperd> ie. it doesn't break any of the monad laws if we ignore nontermination and undefined, which seems to me enough to have usefully monadlike behaviour
04:40:36 * dfeuer is pretty much convinced polymorphic seq was a big mistake.
04:40:37 <kaiyin> m0rphism: yeah, it's working now, just a moment ago it was non-responsive. I have no idea what was going on.
04:41:10 <merijn> dfeuer: So f is an isomorphism that maps the set X to the set X (i.e., presumably it maps elements of X to other elements of X, but I'm not sure I onderstand that right)
04:41:18 <m0rphism> kaiyin: Ok, great :)
04:41:37 <mauke^> merijn: basically it rearranges the set X (hence permutation)
04:41:41 <merijn> dfeuer: Or does f map ONE element of X to an element of X? Or...I just don't get what he's saying
04:41:51 <merijn> mauke^: But sets don't have orders?
04:42:06 <mauke^> merijn: pretend they do :-)
04:42:16 <mauke^> in reality f just maps element x to element y
04:42:22 <mauke^> for some x, y
04:42:27 <dfeuer> merijn, it's an isomorphism, so it's a bijection from X to itself.
04:42:28 <merijn> So that doesn't make sense to me, unless we're mapping elements to elements, but then the objects wouldn't be X
04:42:40 <merijn> dfeuer: Yeah, I get that bit
04:42:51 <dfeuer> merijn, you're mapping elements to elements
04:43:02 <dfeuer> (in bulk)
04:43:03 <dfeuer> er ..
04:43:19 <dfeuer> merijn, a morphism in Set is a function.
04:43:22 <merijn> dfeuer: That's what I thought, but I'm not sure that makes sense :)
04:43:36 * hackagebot web-routing 0.6.1 - simple routing library  http://hackage.haskell.org/package/web-routing-0.6.1 (HirotomoMoriwaki)
04:43:37 <dfeuer> So in Set, a morphism from a set A to a set B is a function f:A->B
04:43:47 <dfeuer> That function of course operates on the elements of A.
04:43:51 <mauke^> is this category theory?
04:43:57 <dfeuer> But from a category-theoretic perspective,
04:43:59 <mauke^> because the definition makes perfect sense without CT
04:44:15 <dfeuer> you only care about the relationship between the objects (sets) and morphisms...
04:44:37 <dfeuer> mauke, Set is a category.
04:44:54 <dfeuer> So yes, if it makes sense without category theory, then it makes sense :-P
04:45:24 <merijn> mauke^: Yes
04:46:25 <merijn> ok, now it makes sense
04:46:52 <merijn> so a subgroup G of Aut(X) is the "set" of invertible mappings + identity mapping for a set X
04:47:13 <dfeuer> You don't need to put quotes around that.
04:47:22 <dfeuer> And no.
04:47:25 <mauke^> why "the"?
04:47:39 <mauke^> I'm pretty sure you can have lots of those
04:47:40 <merijn> ok, "a set"
04:47:41 <dfeuer> merijn, Aut(X) is the set.
04:48:06 <dfeuer> and a subgroup of Aut(X) is a subgroup thereof.
04:48:17 <merijn> dfeuer: Aut(X) is the set of ALL automorphisms on X, he's describing a subgroup of all Aut(X)
04:48:17 <mauke^> a tautology is a tautology
04:48:27 <merijn> eh
04:48:31 <merijn> s/of all/of
04:48:33 <dfeuer> merijn, yes, I understand that.
04:48:52 <mauke^> he's defining "group of permutations"
04:48:59 <merijn> mauke^: Sure, and any proven math statement is trivially true and obvious, but not for everyone ;)
04:49:11 <dfeuer> mauke, I say what I say and I do what I do!
04:49:18 <mauke^> that was specifically in reply to "a subgroup of Aut(X) is a subgroup thereof" :-)
04:49:55 <SharpGAF> merijn: I don't really understand the definition either… aren't automorphisms generally with respect to some relation?
04:49:58 <dfeuer> mauke, yeah, that may not have been my most illuminating utterance ever.
04:50:15 <dfeuer> SharpGAF, I don't think so.
04:50:39 <dfeuer> merijn, you might try rewriting that horribly convoluted sentence into three or four or five normal sentences.
04:50:41 <merijn> Right, and his observation that a homomorphism of groups h : G -> H is "just a homomorphism of monoids, which then necessarily preserves the inverses" is because if it didn't preserve the structure (including inverses) it wouldn't be a homomorphism? Or is that something different
04:51:32 <SharpGAF> Oh, right, I was thinking of homomorphisms.
04:51:40 <merijn> SharpGAF: The "relation" is "isomorphisms on X"
04:52:18 <dfeuer> merijn, it's really just that groupness is a property of monoids that is necessarily preserved by monoid morphisms.
04:52:32 <merijn> dfeuer: Only by monoid homomorphisms, no?
04:52:44 <merijn> Because morphisms in general don't have to preserve structure
04:52:49 <dfeuer> merijn, if ab=id, then f(a)f(b)=f(id)=id
04:52:56 <breadmonster> What does this cabal error mean?
04:52:57 <dfeuer> merijn, morphism = homomorphism
04:53:10 <merijn> dfeuer: No, that doesn't sound right at all
04:53:23 <breadmonster>  /usr/bin/ld: cannot find -lHStransformers-0.4.3.0-ghc7.8.4
04:53:24 <dfeuer> merijn, the words are, to the best of my knowledge, entirely the same :-). 
04:53:40 <breadmonster> How do I fix the error, anyone?
04:53:45 * dfeuer loves synonyms; they're so easy.
04:53:55 <breadmonster> I can't install parsec.
04:53:57 <breadmonster> For some reason.
04:54:07 <clrnd> breadmonster, are you in a sandbox?
04:54:08 <dfeuer> merijn, I promise that morphism===homomorphism.
04:54:15 <dfeuer> No difference at all.
04:54:17 <breadmonster> clrnd: How do I tell?
04:54:30 <merijn> synonyms aren't easy, they're confusing :(
04:54:41 <clrnd> ls .cabal-sandbox/, but I guess you aren't
04:55:25 <clrnd> breadmonster, try in a sandbox, do `cabal sandbox init` and try again
04:55:40 <dfeuer> merijn, yeah, that's true.
04:55:54 <clrnd> breadmonster, errr I mean, what is this for? compiling a project? experimenting?
04:56:01 <dfeuer> I was channeling beaky.
04:56:03 <breadmonster> clrnd: Opening parsec in ghci.
04:56:20 <merijn> dfeuer: Anyway, ok, so they obviously preserve inverses because structure has to be preserved. Good one more page down, next page ;)
04:56:50 <breadmonster> clrnd: I get some really strange error.
04:57:22 <clrnd> breadmonster,  paste the command and it's output in lpaste.net
04:57:37 <dfeuer> merijn, the "preserves structure" concept is a vague handwave.
04:58:49 <dfeuer> merijn, what structure has to be preserved depends on your understanding of what features are important. The morphism definitions are what make that precise.
04:59:29 <lpaste> breadmonster pasted “cabal output” at http://lpaste.net/8366166929022386176
04:59:44 <kaiyin> merijn: you are talking about Category Theory, Awodey 2006 ?
05:00:15 <merijn> kaiyin: Yeah
05:00:44 <dfeuer> merijn, don't forget that topology, with its continuous functions, is also a category. Closedness goes one way and compactness the opposite way!
05:01:08 <clrnd> breadmonster, cabal --version? 
05:01:14 <merijn> dfeuer: Well, if "f.g = id" then a morphism has to preserve h(f).h(g)=h(id)
05:01:22 <merijn> dfeuer: I don't know topology
05:01:23 <dfeuer> Yes.
05:01:25 <breadmonster> clrnd: using version 1.22.0.0 of the Cabal library 
05:01:26 <clrnd> breadmonster, and try cabal install parsec --reinstall --force-reinstalls, if you don't care about your installed libs
05:01:41 <dfeuer> merijn, I only know some basics of topology, but it's fun.
05:01:42 <merijn> dfeuer: That's what I meant by structure preserving, anyway, I think I get it
05:01:53 <dfeuer> OK!
05:02:24 * dfeuer recently joined a group of Haskellers trying to study Aluffi's "Algebra: Chapter 0".
05:02:36 <dfeuer> He uses better language, I think.
05:02:44 <breadmonster> dfeuer: Why'd you use the Aluffi book?
05:02:49 <dfeuer> We'll see how this goes.
05:02:59 <breadmonster> clrnd: Same error.
05:03:13 <breadmonster> It can't find text, transformers or mtl.
05:03:19 <dfeuer> breadmonster, two of us were interested in doing so, and some others tagged along. Do you have a reason to avoid it?
05:03:51 <breadmonster> dfeuer: Oh, no I thought it was just fairly advanced.
05:04:40 <dfeuer> breadmonster, really? It's intended as an introduction to abstract algebra for upper-level undergrads, I think.
05:05:13 <breadmonster> dfeuer: I don't know, my professor recommended Dummit and Foote.
05:05:50 <clrnd> breadmonster, well, I'd delete ~/.cabal ... no idea what else it could be
05:05:52 <dfeuer> breadmonster, I used that in a class, and managed to get a decent grade, but I couldn't stand it and hardly learned anything. Of course, different people are different.
05:06:16 <breadmonster> clrnd: Right, okay.
05:06:21 <breadmonster> Should I back it up first?
05:06:37 <merijn> breadmonster: Depends, got anything installed (haskell wise) you care about?
05:06:44 <merijn> breadmonster: if not, just nuke it
05:06:56 <breadmonster> merijn: Any examples?
05:07:05 <breadmonster> I have alex, happy and cpphs.
05:07:08 <breadmonster> in the bin folder.
05:09:03 <merijn> You can simply reinstall those
05:10:28 <breadmonster> merijn clrnd: Okay, similar error.
05:11:45 <breadmonster> merijn: There's something really strange about Haskell on this PC.
05:11:49 <clrnd> breadmonster, oh my .... 
05:11:58 <breadmonster> clrnd: Why?
05:12:00 <clrnd> breadmonster, ghc-7.4.8 right?
05:12:13 <breadmonster> clrnd: ghc-7.8.4
05:12:19 <clrnd> breadmonster, that :P
05:12:41 <breadmonster> Yup yup.
05:12:42 <breadmonster> Any ideas.
05:12:43 <breadmonster> ?
05:12:47 <clrnd> no :/
05:13:02 <breadmonster> Damn.
05:13:07 <breadmonster> Well, cabal installs to my sandbox.
05:13:08 <clrnd> breadmonster, oh wait a sec, maybe you have thos packages installed at system level
05:13:16 <breadmonster> ...yes, and?
05:13:25 <breadmonster> *cabal installs parsec to my sandbox.
05:13:30 <breadmonster> I just can't load up ghci.
05:13:30 <breadmonster> :(
05:13:37 <clrnd> breadmonster, oh that's easy `cabal repl`
05:16:45 <Ainieco> hello
05:16:52 <breadmonster> clrnd: Cool, that should do for now.
05:17:37 <Ainieco> what is the clever way to convert 0 to 1 but anything other than 0 should remain unchanged?
05:17:54 <Ainieco> could it be done with bitwise ops somehow?
05:18:20 <merijn> > let f 0 = 1; f n = n in (f 0, f 4)
05:18:22 <lambdabot>  (1,4)
05:18:32 <merijn> boom
05:18:45 <merijn> Clever bitwise ops are for suckers :p
05:20:41 <frerich> Ainieco: 'if n == 0 then 1 else n' comes to mind.
05:22:04 <breadmonster> merijn: Is there a parsec parser that will accept any string?
05:22:37 <indiagreen> you can use “many anyChar” to grab as many characters as possible
05:23:06 <breadmonster> indiagreen: Yeah, I want anyChar except '\n'
05:23:28 <indiagreen> well, then “many (satisfy (/= '\n'))”
05:24:08 <indiagreen> or «many (noneOf "\n")»
05:24:27 <breadmonster> Awesoem.
05:24:28 <breadmonster> Thanks!
05:24:59 <indiagreen> or, y'know, “anyChar `manyTill` newline”
05:26:03 <breadmonster> Yeah that worked.
05:26:38 <mjrosenb> if I am working in the monad transformer M2T m a; then there is one lifting function M2T . return :: m a -> M2T m a, what do I use for the other (slightly more awkward lifting), foo :: m2 -> M2T m a?
05:27:54 * frerich thought he saw 'line = anyChar `endBy` newline' somewhere...
05:29:02 <indiagreen> frerich: that would use newline as a separator between chars
05:29:50 <frerich> indiagreen : IIRC 'endBy' applies the first parser zero or more times, until the second parser succeeds - and then returns the collected results, no?
05:31:17 <indiagreen> frerich: http://lpaste.net/129624
05:32:47 <breadmonster> Does anyone know if parseFromFile uses lazy IO?
05:32:54 <frerich> indiagreen : Huh, Iguess I stand corrected. I thought thats what "sepBy" does.
05:33:14 <breadmonster> it makes my job a lot easier.
05:35:05 <indiagreen> breadmonster: the source uses standard lazy “readFile”
05:35:38 <breadmonster> indiagreen: Awesome!
05:35:59 <breadmonster> I'm writing a lexer for Python, and I'll follow it up with a parser.
05:36:13 <indiagreen> how does lazy IO help you?
05:36:13 <breadmonster> I think I'll be done by tonight at this rate, Haskell is so productive.
05:36:37 <breadmonster> Well, I thought I'd have to parse from a file.
05:36:53 <m0rphism> frerich: I think sepBy would not parse "1,2,3," because of the trailing ","
05:37:20 <indiagreen> I mean, for instance, this won't produce anything: «parse (many anyChar) "" (cycle "foo")», so even reading is lazy, parsing wouldn't be
05:37:35 <SharpGAF> Ainieco: FWIW, LLVM appears to think the best way to do it is a conditional move on (a & a) == 0, but this might be because I hid it from the optimizer (because inlining)
05:37:59 <indiagreen> * even if reading is lazy
05:38:31 <breadmonster> indiagreen: Well, I might have to run it on a fairly big file, didn't want to keep the AST in memory.
05:38:34 <breadmonster> *file in memory.
05:38:55 <breadmonster> And I'm not sure how to use the ByteString library.
05:39:00 <breadmonster> I'll have to pick it up soon.
05:39:16 <breadmonster> So parseFromFile just makes life so much easier.
05:41:52 <indiagreen> (by the way, you shouldn't use bytestring to parse text at any rate)
06:00:04 <Phillemann> Searching for a http client library, I encountered http-client in hackage, which directs me to the more "reliable" documentation on stackage, which has a series of cookbook examples (it has just one example with a proxy) and a broken link to the real documentation. What's up with that?
06:02:32 <indiagreen> Phillemann: Hackage doesn't display README.md, which is present in most projects hosted on Github
06:02:44 <indiagreen> instead you're required to write a description in the .cabal file
06:02:59 <indiagreen> which uses slightly awful Haddock syntax
06:03:13 <Phillemann> I see
06:03:32 <indiagreen> which Michael Snoyman, the author of http-client and also Stackage, doesn't like
06:03:38 <indiagreen> at all
06:04:19 <indiagreen> see here: http://www.yesodweb.com/blog/2014/12/use-stackage-for-docs
06:05:04 <dfeuer> indiagreen, if Snoyman's committed, he'll probably get his way eventually. 
06:05:27 <indiagreen> I'd rather just have a better Hackage
06:05:40 <indiagreen> with comments, ratings, better category system, and everything
06:06:00 <Phillemann> But if he doesn't like haddock's syntax, is he still writing documentation for his functions?
06:06:03 <dfeuer> indiagreen, that sounds like a great idea.
06:06:27 <dfeuer> Phillemann, I don't think he'd be the well-respected package maintainer he is if he didn't document his packages.
06:06:48 <dfeuer> maintainer and developer, I should say.
06:07:13 <Phillemann> Oh, by the way, the documentation link on stackage isn't broken per se, it breaks when you expand an HTML element.
06:07:14 <indiagreen> Phillemann: Haddock isn't bad for short descriptions, but it is bad for walls of text
06:07:37 <Phillemann> indiagreen: Ah ok.
06:07:44 <indiagreen> especially the .cabal version which requires you to have “.” instead of blank lines
06:08:41 <indiagreen> dfeuer: there are lots of obvious and great ideas to improve Hackage, there's just lack of developers
06:09:53 <jerbome> hi folks, would someone have time to help a newbie understand why two similar pieces of code don't return the same thing ?
06:10:03 <indiagreen> jerbome: sure, paste them
06:10:05 <indiagreen> @lpaste
06:10:05 <lambdabot> Haskell pastebin: http://lpaste.net/
06:10:25 <JordiGH> Haskell code seems to be awfully cavalier about filling up the namespace with unqualified imports. Whence this cultural trend?
06:10:55 <mauke^> JordiGH: if there are any clashes, the compiler will tell you
06:11:07 <indiagreen> JordiGH: maybe since an average file has like 20–40 imports and it's just too much to have them all qualified
06:11:08 <jerbome> http://lpaste.net/129626
06:11:26 <c_wraith> JordiGH: also, the syntax in haskell is clean enough that qualifying name use is PAINFUL.
06:11:42 <c_wraith> JordiGH: especially qualifying the use of infix operators.  eww.
06:11:59 <JordiGH> Well, never mind unqualified imports. I have a habit to only import the functions I actually want. Why isn't this common?
06:12:11 <jerbome> this comes from learnyouhaskell, for a few monads more chapter
06:12:31 <c_wraith> JordiGH: it stopped about when GHC stopped doing things that way, when they realized 50% of their commits were only updating import lists.
06:12:34 <jerbome> my contribution in the pastebin are the joinResult* methods
06:13:43 <JordiGH> Next question: docstrings. I want a docstring. Otherwise, how can I find out from ghci how reverse and tail differ?
06:13:47 <jerbome> I'm a 4 days old haskell "developer" so please excuse any obvious bad practices =)
06:14:35 <indiagreen> JordiGH: having this in GHCi would be really nice, but we don't have this yet out of the box; however, you can add a “:hoogle” shortcut to GHCi and use that
06:14:53 <JordiGH> indiagreen: I don't always have the internet.
06:15:02 <JordiGH> Oh well, so there just isn't a way to know if you don't already know?
06:15:03 <indiagreen> it's a local copy
06:15:14 <mauke^> JordiGH: you can read documentation locally
06:15:26 <JordiGH> How do I add a :hoogle shortcut to ghci?
06:15:33 <indiagreen> I mean, hoogle gets installed on your computer and generates local databases of packages you install
06:15:44 <JordiGH> I don't use cabal.
06:15:52 <JordiGH> I hate having one package manager per programming language.
06:16:00 <JordiGH> Does hoogle require cabal?
06:16:36 <JordiGH> Ah, there's a hoogle package for Debian.
06:17:34 <indiagreen> if you don't use cabal, then things may be a bit harder for you, as I'm not sure whether your distro's Haskell packages come with pregenerated hoogle databases
06:17:49 <JordiGH> Oh, no hoogle in Debian stable yet. Oh well. I guess I'll wait for the next Debian release. But once that happens, how do I add a hoogle command to ghci?
06:18:03 <indiagreen> https://wiki.haskell.org/Hoogle
06:18:07 <indiagreen> section 2.3
06:18:55 <mauke^> https://wiki.haskell.org/Hoogle#GHCi_Integration
06:19:08 <JordiGH> Thanks, got it.
06:19:40 <indiagreen> hm, I wonder – how hard would it be to add an actual “:doc” command to GHCi which would give docs for a symbol in scope?
06:20:05 <JordiGH> indiagreen: Where would those docs come from?
06:20:18 <indiagreen> from Haddock comments in code
06:20:42 <indiagreen> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-List.html#reverse
06:20:50 <JordiGH> Right, but does the parser even represent those?
06:21:37 <indiagreen> I guess this would require even tighter GHC–Haddock coupling
06:22:55 <indiagreen> and I really don't know whether GHC's parser preserves comment information or not
06:23:42 * hackagebot blunt 0.0.12 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.12 (fozworth)
06:23:48 <mniip> indiagreen, depends on the stage
06:24:26 <mniip> but generally GHC tries to make errors as related to the original source as possible
06:24:30 <L8D> morning
06:24:52 <lpaste> Jerome revised “MakingMonad”: “No title” at http://lpaste.net/129626
06:26:02 <lpaste> Jerome revised “MakingMonad”: “threeFlip” at http://lpaste.net/129626
06:28:29 <JordiGH> Okay, so I still don't get why unqualified imports are all the rage, even if the compiler reports clashes.
06:28:43 <JordiGH> It would be kind of like doing `using namespace foo` all the time in C++.
06:28:55 <JordiGH> The problem would be, compilation headaches.
06:29:20 <mauke^> people do that
06:29:24 <mauke^> 'using namespace std;'
06:29:31 <JordiGH> Yes, but it's unadvised.
06:29:31 <indiagreen> JordiGH: I haven't programmed anything but Haskell to be honest, so can you explain in a nutshell why unqualified imports are bad without comparisons with C++?
06:29:35 <JordiGH> Nobody is unadvising this in Haskell.
06:30:36 <geekosaur> unqualified imports are lazy and convenient but clash with the idea that modules may provide "their own version" of common names/operations (see Data.Map for example)
06:30:42 <mgsloan> Plenty of people advocate explicit / qualified imports in Haskell.  Unqualified imports aren't so bad in Haskell because its name resolution is sane.
06:31:26 <indiagreen> geekosaur: well sure, and we import those qualified (but I wish we solved this problem with type classes instead)
06:31:36 <indiagreen> but why import e.g. Data.Maybe qualified?
06:31:40 <geekosaur> in particular there is a weirdness coming up where the Prelude versions of various functions are going to be polymorphic. the Data.List ones should ideally be specific to lists... but because ~everyone imports Data.List unqualified, it's going to re-export the polymorphic ones
06:31:48 <geekosaur> so as not to clash with the new Prelude
06:31:51 <geekosaur> which is kinda dumb
06:32:28 <nshepperd> all things like 'fromList :: [a] -> Foo a' should an Unfoldable instance instead, or something
06:32:51 <indiagreen> Data.List, being a huge collection of “whatever is related to lists”, is slightly dumb in the first place
06:32:55 <nshepperd> er..
06:33:08 <JordiGH> indiagreen: When you have a very large library with lots of imports, and the things you're importing change, you'll eventually get annoying compilation errors that will require you to fix your client code.
06:33:18 <nshepperd> yeah, the most common reason I import Data.List is just to get 'sort'
06:33:53 <JordiGH> mauke^: Well, `using namespace std` at global scope is what's usually unadvised. It's less of a problem inside a smaller scope.
06:35:16 <JordiGH> indiagreen: Can you decide how to do qualified imports? e.g. import qualified Data.Maybe as DM?
06:35:30 <JordiGH> So you would just have to write DM.foo instead of Data.Maybe.foo ?
06:35:56 <indiagreen> JordiGH: I have a habit of importing well-known libraries unqualified, and other things – qualified. Data.List and Data.Maybe, for instance, are in base, which is tied to GHC. If GHC updates, something will break *anyway*/
06:37:04 <indiagreen> and, thanks to cabal, I can specify version constraints
06:37:19 <SrPx> Do you guys know what is a good place to ask about the pure untyped lambda calculus? I know this is off-topic here now. But it is not like we have a community for it or something :(
06:37:35 <SrPx> Maybe S.O. under the #functional-programming tag?
06:37:37 <indiagreen> even if attoparsec gets updated, it won't break my code unless I had no upper bound set
06:38:34 <indiagreen> (I'm not sure I understand your question correctly, but yes, you can do “DM.foo”)
06:42:16 <jerbome> so, can anyone help me understand what happens in this pbin ? http://lpaste.net/129626
06:42:49 <indiagreen> ah
06:42:56 <indiagreen> you have a typo
06:43:01 <indiagreen> “joinOnfirst”
06:43:13 <indiagreen> and the other equation is “joinOnFirst”
06:43:21 <indiagreen> and so these define 2 different functions
06:43:33 <jerbome> omg
06:43:37 <jerbome> thanks
06:45:04 <JordiGH> indiagreen: How do you specify how to qualify a qualified import? I don't know the syntax.
06:45:24 <indiagreen> exactly as you wrote
06:45:31 <indiagreen> import qualified ... as ...
06:45:37 <jerbome> it works now, but follow up question. I tried to convert that to 'do' syntax, but I couldn't do it. The 2 commented out functions at the end of the pbin are what I tried
06:46:41 <JordiGH> indiagreen: Ah, nice.
06:47:00 <utdemir> Hey. Can anyone explain me that whats the first parameter of Data.Table.makeTabular ?
06:48:01 <JordiGH> So, another argument people make against unqualified imports: it makes the code harder to read. You just don't know in which module a particular function is used.
06:48:11 <JordiGH> Er, defined.
06:48:15 <JordiGH> Is defined.
06:48:16 <Cale> utdemir: Which Data.Table is that?
06:48:18 <JordiGH> Why isn't this a problem in Haskell?
06:48:23 <indiagreen> it is
06:48:35 <Cale> Oh, tables package
06:48:36 <utdemir> Cale: the one from ekmett's tables package
06:48:38 <Clint> http://hackage.haskell.org/package/tables-0.4.1.1/docs/Data-Table.html#v:makeTabular
06:48:55 <indiagreen> that's another reason I import “rare” libraries qualified
06:49:23 <JordiGH> Can you import twice?
06:49:32 <JordiGH> import some functions qualified and some unqualified?
06:49:34 <exio4> yes, you can
06:49:37 <Cale> utdemir: It appears to be the primary key?
06:49:43 <exio4> import qualified Data.Map as M
06:49:46 <indiagreen> but if you're writing a module which uses Parsec, you'll hardly be able to understand anything if you don't know Parsec, qualified imports or not, so people don't qualify Parsec most of the time
06:49:50 <exio4> import Data.Map (Map)
06:50:41 <exio4> a typical example of doing two imports, one for the type(s) (unqualified) and another one for the functions (which will be qualified)
06:50:52 <Cale> utdemir: Looking at the source, yeah, that's what it is
06:50:54 <ProofTechnique> jerbome: Separate from what else you're doing, you probably shouldn't use foldl
06:51:05 <utdemir> Cale: It gives me "illegal data constructor name: f" , I guess I should file a bug report
06:51:12 <indiagreen> JordiGH: a really annoying thing about Haskell is that lots of packages end up being DSLs
06:51:15 <ProofTechnique> Data.List.foldl' is nearly always better.
06:51:29 <jerbome> ProofTechnique, oh I read about that one
06:51:30 <Cale> utdemir: It's not supposed to be the name of a data constructor, it's supposed to be the name of a field
06:51:41 <indiagreen> so, if you use a package, you'll have to understand it
06:51:53 <indiagreen> that's why aeson is hard to figure out, for instance
06:52:06 <Cale> Is that annoying?
06:52:22 <CaptainK> Any update on the debian server investigation?
06:52:25 <indiagreen> yes, because it means I can't use a package for a one-off task
06:53:14 <utdemir> Cale: I have `data Foo { _bar :: Int, _baz :: Int }; makeLenses ''Foo; makeTabular '_bar []`. Isn't this the right usage?
06:55:29 <Cale> utdemir: That data declaration isn't syntactically valid.
06:55:49 <Cale> You mean something like data Foo = Foo { _bar :: Int, _baz :: Int }
06:55:54 <utdemir> Cale: I meant dataFoo = Foo . yes
06:56:32 <kaiyin> anyone has got this thing to work? 
06:56:52 <Cale> kaiyin: Might help to know what you're talking about ;)
06:57:02 <kaiyin> https://github.com/chrisdone/structured-haskell-mode
06:57:28 <Cale> I'm pretty sure chrisdone has ;)
06:57:36 <Cale> I've installed it before, but actually using it...
06:57:40 <kaiyin> I can't for the love of gods get these keyboard shortcuts to behave as they should.
06:58:25 <JordiGH> kaiyin: #emacs was unhelpful?
06:58:35 <JordiGH> Fuco: Do you use SHM?
06:58:44 * hackagebot hydrogen-multimap 0.2 - Hydrogen Multimap  http://hackage.haskell.org/package/hydrogen-multimap-0.2 (JulianFleischer)
06:58:56 <Fuco> I don't use it
06:59:00 <kaiyin> JordiGH: chaotic and frustrating, it's for gurus only.
06:59:00 <JordiGH> kaiyin: Also, "keyboard shortcuts" fails the Emacs shibboleth test. You're not from here, are you?
06:59:11 <JordiGH> kaiyin: #emacs is too chaotic?
06:59:43 <kaiyin> JordiGH: too many packages to install and config before you can get things running.
06:59:56 <JordiGH> kaiyin: Emacs is chaotic and frustrating?
07:00:15 <kaiyin> JordiGH: yeah, you love it?
07:00:23 <JordiGH> Of course. It's the only thing I use since 2002.
07:00:26 <JordiGH> Man, I feel old.
07:00:29 <JordiGH> I also hate it, though.
07:00:38 <Cale> I couldn't get past the fact that none of the keybindings made any sense, but I seem to recall that they did do what they were supposed to.
07:00:39 <JordiGH> I really hated it for the first three months I used Emacs. I thought I had no choice.
07:00:55 <JordiGH> I was like, "I want to edit LaTeX", and they were like "you need Emacs". I thought I had no choice, so I worked hard to learn Emacs.
07:01:00 <JordiGH> Now I hate everything but Emacs.
07:01:28 <JordiGH> Cale: Are the SHM keybindings way too different from the paredit keybindings?
07:01:36 <Cale> JordiGH: I've never used paredit
07:01:52 <Cale> They're just all over the keyboard and unmemorable
07:01:57 <JordiGH> If it's just a matter of the default keybindings being ugly, that's an easy fix.
07:01:59 <kaiyin> JordiGH: it was inspired by paredit, according to its github page.
07:02:06 <JordiGH> Cale: Wait, Emacs in general or SHM in particular?
07:02:28 <Cale> Haha, probably Emacs in general. I've used Emacs a bunch, but I've never actually learned any of the keys.
07:02:58 <kaiyin> JordiGH: do you use shm?
07:03:03 <JordiGH> Cale: It's just a matter of habituation. I actually make GTK+ use the Emacs keybinding theme, so Emacs keybindings for me are the natural ones. My entire OS uses Emacs keybindings.
07:03:18 <JordiGH> kaiyin: No, but I might. I have used some paredit.
07:03:20 <Cale> Probably the problem is that Emacs is already taking all the good keybindings
07:03:35 <Cale> But I have no idea
07:04:19 <JordiGH> kaiyin: The SHM gifs really look enticing.
07:04:21 <kaiyin> JordiGH: the description sounds tempting, i would love it if everything works. I don't hate emacs itself, I hate about the fact that packages often don't work.
07:04:26 <indiagreen> Cale: I just went ahead and changed all Emacs keybindings to my liking, same as I did with my keyboard layout
07:04:34 <Cale> Too much trouble
07:04:46 <JordiGH> kaiyin: Well, Haskell packages often don't work either. 'Tis the nature of github.
07:04:50 <JordiGH> kaiyin: No quality control.
07:04:51 <indiagreen> it was actually easier than trying to memorise them
07:04:52 <utdemir> Hey. I got some collections of records which all have a primary key, I mostly do lookups using that key. Is there a library which enforces the PK's uniqueness, allows fast lookups etc? Should I use ixset, tables or something else?
07:05:29 <Cale> utdemir: I mean, you could use those things, but why isn't Data.Map appropriate?
07:05:37 <kaiyin> JordiGH: yeah, can't argue with that.
07:05:50 <zomg> indiagreen: completely custom keyboard layout and completely custom editor keybinds? Doesn't that make it difficult to work on any other machine besides your own?
07:05:57 <JordiGH> kaiyin: Emacs packages that make it into core do get some QA.
07:06:29 <indiagreen> it does, but since I work on my own machine all the time...
07:06:49 <zomg> heh
07:07:01 <Cale> I mostly use vim now, but only in a way which would make people who love vim hate me.
07:07:02 <JordiGH> zomg: It's quite common to keep your Emacs config under version control and pass it around the machines you use.
07:07:07 <exio4> reasons to take your laptop with you
07:07:10 <indiagreen> I mean, putting Backspace on J outweighs *all* trouble I could get from not being able to work somewhere else
07:07:14 <utdemir> Cale: It's currently implemented with Data.Map. I don't know why, but I'm searching for a fancier solution
07:07:24 <JordiGH> indiagreen: haha, are you serious?
07:07:26 <JordiGH> backspace on j?
07:07:29 <JordiGH> With evil-mode?
07:07:33 <indiagreen> no, globally
07:07:36 <zomg> JordiGH: yeah I try to do that with my vim settings and such, but those are mostly just how I like it to look and what plugins :)
07:07:37 <JordiGH> hahahah wtf
07:07:44 <JordiGH> indiagreen: Who do you type J? C-q j?
07:07:45 <indiagreen> also Ctrl on S
07:07:53 <indiagreen> J is the least used letter
07:08:00 <JordiGH> Not for me. :-(
07:08:01 <indiagreen> Backspace is the most used key
07:08:05 <JordiGH> It's one of the letters I use the most.
07:08:07 <zomg> My first and second names start with J
07:08:09 <zomg> so F you
07:08:10 <JordiGH> ... for obvious reasons.
07:08:12 <zomg> (joking)
07:08:12 <zomg> :D
07:08:14 <clrnd> I never use backspace
07:08:18 <zomg> but my names do really start with J
07:08:26 <JordiGH> zomg: just jocularly jesting here too.
07:08:39 <indiagreen> which is why I'm not saying everyone should use my layout or something
07:08:53 <JordiGH> indiagreen: So, really, do you do C-q j if you really want to type j?
07:08:58 <kaiyin> Cale: so have you managed to get autocompletion to work on vim?
07:09:05 <indiagreen> no, I do D-P
07:09:05 <JordiGH> indiagreen: Also, why not z? It's got a higher Scrabble score.
07:09:10 <Cale> kaiyin: Haven't bothered to try
07:09:13 <indiagreen> D is 3rd level key
07:09:17 <JordiGH> hahahahahaah
07:09:24 <Cale> kaiyin: I basically don't care about my text editor
07:09:29 <JordiGH> indiagreen: hahahahaha, man, that's the craziest thing I ever heard!
07:09:30 <indiagreen> because then I can also get D+IJKL to be arrows
07:09:35 <indiagreen> and that's another awesome thing
07:10:03 <quchen2> Sounds like you're reinventing Neo.
07:10:03 <Cale> kaiyin: If it will convert tabs to spaces, keep the indentation level of the last line, and maybe do a little syntax colouring, I'm fine.
07:10:37 <indiagreen> quchen2: could you give a link?
07:11:10 <quchen2> http://en.wikipedia.org/wiki/Keyboard_layout#Neo
07:11:25 <JordiGH> quchen2: I thought you were suggesting that indiagreen is The One.
07:11:40 <guampa> kaiyin: what kind of autocompletion do are you tring to make work?
07:12:05 <kaiyin> guampa: function names, module names, for starters?
07:12:17 <guampa> tried ctl+x, ctl+p?
07:12:36 <guampa> don't think it works for modules, but for same-file definitions it works
07:13:55 <kaiyin> ok. for same file definition, I find ctrl-n good enough.
07:14:17 <JordiGH> kaiyin: Man, SHM is complicated because it depends on non-elisp code.
07:14:42 <kaiyin> Cale: I have to say you are the wise man. I am expecting too much from editors. I am spoiled by intellij idea (for java).
07:15:28 <JordiGH> kaiyin: I kind of hate that sort of thing, Java IDEs.
07:15:29 <clrnd> Cale, I use exactly the same features (in Vim), yay
07:15:59 <JordiGH> kaiyin: But SHM looks nice.
07:16:02 <clrnd> if you program in lot's of languages, it can get messy with ultra-functional editors
07:16:06 <Cale> kaiyin: While I think there's definitely room for tooling at the editor/IDE level, I really think a lot of it serves to cover over problems which ought to be solved at the programming language level.
07:16:25 <JordiGH> kaiyin: I hate the little popups and autocompletion, though.
07:16:32 <JordiGH> And what Cale said.
07:16:43 <JordiGH> Java needs an IDE because Java.IsVerbose() == true.
07:17:14 <JordiGH> http://www.bash.org/?946461
07:17:44 <JordiGH> ^--- My description of Java's verboseness can't compete with the old masters.
07:17:59 <kaiyin> JordiGH: true. Module name completion could be useful even for haskell, though.
07:18:01 <Cale> I also worry about interactive debuggers in the same way. They help you solve problems, but over time, especially if abused, they can lead to codebases which are just horrifyingly impossible to understand.
07:18:27 <JordiGH> Cale: I need a debugger to understand what other people did, not me. :P
07:19:20 <Cale> Yeah, but the debugger can give you *just enough* understanding to make the change you need to make, and possibly miss a much nicer way to accomplish the same thing.
07:19:30 <JordiGH> I find it odd how I'm such a minority for using a debugger. It's so fundamental to me, but so many people rail against debuggers. I still need to learn how to use a Haskell debugger.
07:19:50 <Cale> I essentially never use the GHCi debugger
07:20:25 <JordiGH> Also, debuggers in other languages helped me immensely to understand how the language works. E.g. a C++ debugger taught me how vtables look, and a Python debugger showed me how generators get executed. I am hoping a Haskell debugger would teach me about thunks.
07:20:55 <Cale> Yeah, for learning purposes, it would be really good to have something which displayed expression graphs.
07:21:01 <JordiGH> Seeing the actual thing getting executed in slow motion is great.
07:21:55 <Cale> I really wish that Dr. Kahl would release this thing: http://www.cas.mcmaster.ca/~kahl/HOPS/
07:22:28 <Cale> It's not a Haskell implementation, but its own programming language based on graph reduction, and you can watch the graph reduction take place step by step.
07:22:34 <JordiGH> Whoa, Athena toolkit.
07:22:45 <JordiGH> How old is this Dr. Kahl?
07:22:55 <Cale> Well, the program itself is pretty old by now.
07:23:11 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
07:23:12 <jtanguy> Idris tooling is quite nice
07:23:39 <Cale> It's really nice to be able to see the space usage of a few simple programs like that to get an idea for how space in functional programs works
07:24:03 <JordiGH> Cale: Where are you, geographically?
07:24:19 <Cale> (the space usage is roughly proportional to the actual amount of paper the graph takes to draw)
07:24:26 <Cale> Ontario, Canada
07:24:35 <kaiyin> jtanguy: what editor do you use?
07:24:47 <JordiGH> Are you at McMaster?
07:25:00 <JordiGH> Sounds like you know "Dr. Kahl" personally.
07:25:41 <Cale> JordiGH: I worked at McMaster one summer while I was going to Waterloo
07:26:00 <JordiGH> I see.
07:26:19 <JordiGH> Well, in case you wanted to know (probably not) I'm in Mtl, and I used to go to McGill.
07:26:28 <JordiGH> Maybe we'll cross paths some day.
07:26:29 <Cale> (On a compiler in Haskell for a special purpose programming language for signal processing applications)
07:26:35 <Cale> ah, cool
07:29:08 <jtanguy> kaiyin: I use vim, but the idris tooling is baked into the compiler, not a huge vim plugin
07:29:27 <kaiyin> i see.
07:29:29 <zomg> Cale: for some reason I read McMaster as McDonalds
07:29:30 <zomg> lol
07:29:37 <Cale> lol
07:32:35 <mjrosenb> question about magic that is not inherently impossible:
07:33:31 <mjrosenb> I have a value of type IO String, I want to do some magic to it, so it is executed at complie time, and a String gets bound to a variable.
07:34:11 <mniip> mjrosenb, what kind of IO is that
07:34:41 <mjrosenb> mniip: compile time IO?
07:34:54 <mniip> no I mean what's the IO do
07:35:44 <mjrosenb> e.g. kernel = _MAGIC_ (readProcess "/usr/bin/uname" ["uname", "-a"] "")
07:36:01 <mniip> nope, can't do that
07:36:39 <ProofTechnique> Template Haskell might be able to.
07:37:14 <mniip> ah right
07:37:18 <mniip> that cray part of ghc
07:39:09 <jtanguy> why do you want to read uname in your program?
07:41:11 <nshepperd> seems like it be a bit unsafe to allow template haskell to do IO
07:41:47 <nshepperd> but then again, when you compile code, you usually also run so I guess it doesn't make much difference
07:42:04 <geekosaur> nevertheless, it can; the Q monad is an instance of MonadIO, IIRC
07:43:05 <geekosaur> mm, no it isn't curretly
07:43:17 <geekosaur> but it has runIO
07:43:34 <nshepperd> IO a -> Q a?
07:43:47 <geekosaur> yes
07:43:50 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/template-haskell-2.8.0.0/Language-Haskell-TH.html#v:runIO
07:44:07 <jtanguy> mjrosenb: why do you need uname ? If you need to access the os name or arch you have System.Info in base
07:45:23 <geekosaur> that, oddly, is the runtime one (despite not being in IO)
07:45:30 <geekosaur> sometimes you want the compile-time one
07:45:42 <Cale> $(liftString =<< runIO (readProcess "/usr/games/fortune" ["zippy"] ""))
07:47:19 <nshepperd> hmm, that seems 'too powerful'
07:48:21 <barrucadu> Why isn't Data.Functor in Control, like Applicative and Monad are?
07:49:34 <Flonk> barrucadu: Historical raisins.
07:49:48 <barrucadu> Hysterical raisins are the worst raisins
07:50:06 <Flonk> All old and moldy :(
07:53:36 <Cale> I kind of think that the Data and Control prefixes should just be dropped
07:53:39 <Cale> They're meaningless
07:53:59 <Cale> It's like having two miscellaneous junk drawers
07:56:03 * frerich just got out of a meeting where everybody (modulo silent people) heavily objected to using global variables to pass data between a couple of Python script functions, and instead demanded that a 'userData' argument which is readable and writeable everywhere to be passed to very single function because it's "more object-oriented".
07:56:06 <quchen2> I don't think that's practically possible though.
07:56:24 <clrnd> frerich, ouch, sounds like my day to day
07:56:51 <quchen2> frerich: It's like a ghetto for data
07:57:01 <clrnd> PyGhetto
07:57:16 <Gurkenglas> What do I do if the algorithm I'm thinking of to solve a given problem involves doing lots of minuscule changes in a giant datastructure? I am given to believe that that kind of thing is messy to implement in Haskell.
07:57:26 <quchen2> Cale: Removing Data/Control is probably even more painful than renaming fmap.
07:57:36 <indiagreen> Gurkenglas: lenses
07:57:37 <mniip> Gurkenglas, you rethink your algorithm
07:57:40 <indiagreen> or that
07:57:46 <Cale> quchen2: Yeah :(
07:57:48 <quchen2> Also zippers.
07:57:54 <mniip> indiagreen, I don't think lenses provide quite the efficiency
07:58:03 <quchen2> Cale: On the other hand, removing the prefixes is useful, which renaming fmap is not.
07:58:19 <Gurkenglas> mniip, are there ressources on that or is the instruction "think until you think of something"?
07:58:24 <indiagreen> mniip: I think Edward heavily optimises them
07:58:30 <Cale> I was actually around at the time when hierarchical modules were introduced, and I thought it was stupid even then.
07:58:43 <mniip> Gurkenglas, see what others suggested
07:58:48 <mniip> zippers for example
07:58:55 <barrucadu> Data is obviously roughly for data types, what is Control supposed to be for? Things which didn't fit anywhere else but were widely used?
07:59:04 <quchen2> I wasn't around so I'm not even sure what the name actually means. But I think stuff like List should not be in the topmost namespace.
07:59:09 <clrnd> Gurkenglas, or be in IO and use IORefs
07:59:20 <quchen2> barrucadu: Well, control structures. Like "if".
07:59:22 <Gurkenglas> That sounds messy :P
07:59:25 <mniip> clrnd, but but but
07:59:28 <mniip> STRef
07:59:35 <Cale> barrucadu: The problem is that data types are also essentially control structures in Haskell
07:59:36 <mniip> ST is underrated
07:59:38 <Gurkenglas> Gonna look at this Zipper stuff, don't think I know those yet
07:59:51 <Cale> barrucadu: So they end up meaning almost the same thing
08:00:40 <Cale> For any given functor, you can likely think of it as some sort of computation as well as some kind of (possibly fancy) container structure
08:00:40 <clrnd> I like Data and Control, we just need to refine them ....
08:00:53 <Cale> Data.Data.Data
08:00:55 <quchen2> Yes, by dropping one of them.
08:01:00 <clrnd> Data.Map, Control.Arrow
08:01:21 <quchen2> ControlData.{Functor,Applicative,Monad}
08:01:25 <Cale> alt.adjective.noun.verb.verb.verb
08:01:42 <clrnd> Category.Monad
08:01:48 <quchen2> Cale: Java jokes are cheap shots :-P
08:02:12 <Cale> That's not a Java joke, it's a usenet joke
08:02:21 <quchen2> Oh.
08:02:38 <frerich> Tsk tsk, the 'alt.' (as opposed to 'com.' or 'org.') should've clued you in!
08:03:21 <Cale> Has anyone ever suggested that since they're putting the com at the beginning, it should be moc?
08:03:43 <barrucadu> Should be "org", followed by ".haskell", clearly
08:04:00 <Cale> gro.lleksah
08:04:19 <frerich> Beware of the Grolleksah!
08:04:31 <barrucadu> Grolleksah, the laziest of monsters
08:04:57 <frerich> The laziest of co-angels
08:05:20 <mjrosenb> Cale: ooh, that looks nice.
08:06:29 <Cale> alt.adjective.noun.verb.verb.verb was a newsgroup where everyone tried to communicate in a format which fit the template suggested by its name, one per line, alt and dots included.
08:07:43 <Cale> https://groups.google.com/forum/#!topic/alt.adjective.noun.verb.verb.verb/hivbqem01gQ
08:07:51 <quchen2> It's quite a challenge to come up with a useful sentence.
08:07:57 <mauke^> alt.barney.dinosaur.die.die.die
08:09:10 <bananagram> when you do readTChan on an empty TChan, does it block until something enters the TChan?
08:09:19 <bananagram> or wait
08:09:30 <Cale> It retries
08:09:32 <quchen2> STM doesn't block, it retries
08:09:54 <fryguybob> block is a reasonable synonym for retry.
08:10:00 <quchen2> Reading an empty TChan aborts your current transaction, and keeps it in a waiting state until any of its dependencies change
08:10:00 <bananagram> using a lot of CPU until it gets something?
08:10:01 <Cale> (which effectively results in blocking until one of the things on the way to the retry changes)
08:10:57 <lolisa> What is the type of Object in a monoid category? I don't quite get it reading the book...
08:11:23 <quchen2> You mean a monoid regarded as a category?
08:11:25 <fryguybob> bananagram: It does not busy wait.
08:11:44 <bananagram> okay, that's good
08:11:51 <lolisa> Yes
08:12:57 <clrnd> https://groups.google.com/forum/#!topic/alt.adjective.noun.verb.verb.verb/GNEcbaq4EmM
08:13:15 <quchen2> The object can be anything. The category laws don't require much of a relationship between objects and arrows, other than arrows start and end at objects.
08:13:43 <lolisa> Equivalently, a monoid is a category with just one object. What Object? And if unit is identity arrow as book said, than how do I get the rest element in the monoid?
08:14:35 <Cale> lolisa: What the object is doesn't matter because there's only one of it
08:14:49 <Cale> lolisa: and objects only serve to tell you which arrows can be composed
08:14:56 <Cale> (they're effectively labels)
08:15:03 <EvanR> lolisa: the arrows are the elements
08:15:06 <Cale> If there's only one object, all arrows can be composed with each other
08:15:17 <lolisa> So I can set it to unit? (I am trying to program it in Coq)
08:15:25 <Cale> sure
08:15:35 <Cale> any one element type would do
08:15:57 <quchen2> You can set it to "curl -G http://wikipedia.org" or 1 or rabbit ;-)
08:16:16 <lolisa> But than, how do I get other non unit element? for example, if I consider the nat monoid, I can get 0 by id tt, but what about 1 and 2 and 3?
08:16:33 <quchen2> tt?
08:16:49 <Cale> lolisa: They are arrows from that one object to itself as well.
08:17:18 <Cale> lolisa: The category axioms don't tell you those arrows have to exist -- they're something particular about the given category you're defining.
08:18:18 <lolisa> I get it. Thx!
08:18:47 <sx_> Does anyone know why my code gets into an infinite loop? http://codepad.org/qzngditi
08:18:49 * hackagebot hydrogen-prelude 0.19 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.19 (JulianFleischer)
08:18:57 <Cale> (just like the monoid axioms don't tell you that nonidentity elements have to exist)
08:19:40 <Cale> sx_: I can't run that code, so I don't know.
08:20:06 <lolisa> So, I cannot just simply write a instance moniod -> Category which transform any kind of monoid into category, but instead I have to make them abstract class and write instance for each monoid manually?
08:20:18 <lolisa> * them it
08:20:29 <Cale> lolisa: You can write such a function if you've defined Monoid and Category correctly.
08:20:55 <Cale> Just take the type of arrows from tt to tt to be the monoid in question.
08:21:11 <Cale> and take the composition of arrows to be the multiplication of the monoid
08:21:20 <sx_> Cale: My bad, http://codepad.org/gLFoGdti
08:21:31 <Cale> Well, rather the type of arrows should be the underlying set of the monoid
08:21:38 <lolisa> Yes, but how do I get 1 in Nat (+) moniod if I transform it into Category automatically?
08:22:01 <lolisa> All I has is an identity arrow, and although I can compose it with tt as much as I want, it is always 0...
08:22:07 <EvanR> Category doesnt let you do that
08:22:29 <EvanR> not everything has a 1
08:22:49 <lolisa> Yes, but Nat (+) has a 1...
08:23:09 <EvanR> so you have to know youre using Nat + and 1
08:23:17 <sx_> Or let me respecify my question a bit, is there a way to know which values quickCheck used, to perform a single test?
08:23:36 <Cale> sx_: Oh, it's because QuickCheck applied cycleS to []
08:23:43 <EvanR> or some ring
08:24:00 <lolisa> So you mean I should extend my definition of monoid a bit so it can transform any object into an arrow?
08:24:07 <Cale> That is in fact the very first list that it tries
08:24:07 <sx_> Cale: oh my, thanks
08:24:13 <EvanR> no
08:24:30 <EvanR> no extension needed
08:25:11 <EvanR> two . three is five
08:25:31 <lolisa> But how can I construct something that is not a unit when all I have is unit and binary operation...
08:25:47 <EvanR> in general you cant because there may not be any such thing?
08:25:57 <lolisa> EvenR, but how can I get two or three...?
08:26:01 <arianvp> What is the common name of the property   f (f x) = x  ?
08:26:22 <EvanR> you have to know the particular example youre dealing with
08:26:28 <barrucadu> arianvp: Involution?
08:26:33 <mauke^> arianvp: idempotent
08:26:39 <arianvp> idempotency?
08:26:41 <sx_> arianvp: self-inverse ?
08:26:41 <mauke^> er, no
08:26:48 * mauke^ withdraws
08:27:00 <sx_> arianvp: f^{-1} = f
08:27:01 <Cale> lolisa: Maybe you'd better put your Coq definitions on lpaste.net
08:27:12 <ChristianS> lolisa: if all you have is unit and binary operation, you probably cannot get anything interesting. with a unary operator, things would look better.
08:27:13 <lolisa> So I should provide some element other than unit?
08:27:15 <guldfiskn> How would one define a recursive data type for simple arithmetic expressions?
08:27:25 <lolisa> Cale, OK, just a sec
08:27:26 <Cale> lolisa: What do you mean by "element"?
08:27:32 <arianvp> involution it is
08:27:38 <lolisa> element in the monoid
08:27:43 <Cale> lolisa: In order to specify a category, you must specify the following things:
08:28:03 <Cale> 1) A set (or type) of "objects" of the category.
08:28:31 <Cale> 2) For each pair of objects X and Y, a set of arrows
08:28:33 <sx_> guldfiskn: depends on what you want, you can do a straightforward recursive definition, or typed with GADTs, or you could have a look into the expression problem, which provides a more extensible approach.
08:28:52 <Cale> Say, C(X,Y)
08:29:17 <Cale> 3) For each triple of objects X, Y, Z, a composition map  C(Y,Z) -> C(X,Y) -> C(X,Z)
08:29:49 <lolisa> https://github.com/lolisa/Category_Theory/blob/master/Category_Theory.v Here, the last few line
08:29:51 <sx_> guldfiskn: or did I get your question wrong?
08:30:12 <guldfiskn> sx_: something like    data Recursive = Arith | Geo | Power
08:30:19 <Cale> okay, your definition of category looks fine
08:30:24 <guldfiskn> and then define Arith, Geo and Power as recursive functions
08:30:25 <guldfiskn> ?
08:30:43 <guldfiskn> like  geo = 3; geo n = geo (n-1) * 3
08:30:57 <lolisa> Cale, I had specific that part, and I can convert a monoid into a category, but the thing is, the result is not what I thought, because only the unit element exists after the conversion...
08:31:55 <Cale> lolisa: What do you mean? Arrow tt tt = M
08:32:09 <sx_> guldfiskn: I'm not exactly sure what your problem is, if you want simple arithmetic expression then do something like: data Expr a = Plus Expr Expr | Lit a
08:32:47 <lolisa> Yes, but I lose the ability to construct every other element beside unit...
08:32:56 <Cale> huh?
08:33:06 <Cale> I don't understand.
08:33:15 <Cale> The entire monoid is still there.
08:33:32 <guldfiskn> my roommate is trying to learn me haskell, and he basically made me a paper with exercises. "Define a recursive data type for simple arithmetic expressions and then write a function that will calculate the length of such expressions". And since I can't get a hold of my roommate now, I'm searching for help here.. :)
08:33:50 * hackagebot hjsonschema 0.5.1.0 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.1.0 (seagreen)
08:33:52 * hackagebot hjsonschema 0.5.1.1 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.1.1 (seagreen)
08:34:04 <EvanR> guldfiskn: heh, the length of an arithmetic expression?
08:34:15 <EvanR> perhaps the size?
08:34:22 <ChristianS> that was fast ^^ (hjsonschema)
08:34:29 <lolisa> For example, if I define a nat monoid with + and 0, after I feed them through my 178-185 line, the result category has a Identity tt tt = 0, and compose l r = l + r...
08:34:55 <guldfiskn> EvanR: yeah, as the question I wrote just above says (not very well translated from swedish tho..) 
08:35:07 <lolisa> So even though it is still the same monoid, I just can't reach other values...
08:35:29 <jerbome> I've just finished reading learnyouahaskell. What now ? Do I get a job @ Google ?
08:35:40 <indiagreen> unlikely
08:35:58 <seagreen> ChristianS: Forgot to update the changelog:(
08:36:02 <shapr> jerbome: you are now qualified to write something in Haskell! Where will you start?
08:36:28 <sx_> guldfiskn: Use a definition like: data Expr = Plus Expr Expr | Lit Int, and then write functions that operate on Expr, for example you could represent "4 + 4" as (Plus (Lit 4) (Lit 4)), but I cannot tell you what length should be. :)
08:37:00 <Roger__> Anyone know why a Gloss program would hang when compiled normally with GHC but run fine in GHCI or when compiled with "-osuf p_o -prof -auto-all"?
08:37:03 <jerbome> shapr, something simple I guess, like Wolfram alpha
08:37:13 <sx_> guldfiskn: but maybe some haskell book would be the best choice, when you're starting from zero.
08:37:17 <lwm> jerbome: where I went next, didn't regret it -> https://wiki.haskell.org/All_About_Monads
08:37:35 <jerbome> nice
08:37:39 <sx_> guldfiskn: http://learnyouahaskell.com/chapters
08:37:46 <guldfiskn> yeah perhaps.. I'm reading learn you a haskell atm, trying to learn this
08:38:01 <jerbome> I tried tens of the 99 exercise, but they're not really haskell specific, got bored very fast
08:38:07 <guldfiskn> sx_: haha thanks! already stumbled upon that though.
08:38:34 <guldfiskn> allright.. I'll give this some more time, thanks for the help.
08:39:04 <shapr> jerbome: have you tried writing something for yourself?
08:39:11 <sx_> jerbome: furthermore they seem to be really bad haskell, most of them are partial functions...
08:39:21 <Cale> lolisa: What do you mean you can't reach other values? The other values aren't guaranteed by the axioms of a category? Sure.
08:39:35 <Cale> lolisa: But they're still part of the structure of the category you defined.
08:40:15 <Cale> lolisa: Because you defined the type Arrow tt tt to be nat
08:40:27 <jerbome> shapr, I wrote quite a lof while reading learn you haskell, and I try myself on the exercises in real world haskell, but they suck IMO
08:40:40 <jerbome> 'they suck' as in more math than CS
08:40:42 <Cale> lolisa: and so e.g. S (S O) : Arrow tt tt then
08:40:54 <shapr> jerbome: oh, so you know how to improve them? You could write some of your own!
08:41:02 <shapr> jerbome: that's a good idea, go for it!
08:41:13 <shapr> I certainly wrote a bunch of tutorial stuff when I got into Haskell
08:41:23 <jerbome> shapr, lol, you're jumping to conclusion there !
08:41:23 <indiagreen> jerbome: do you want to write something useful, or do you want to learn more about other Haskell concepts?
08:41:28 <shapr> I was amazed at how much positive feedback I got from contributing tutorial stuff.
08:41:42 <lolisa> Dont composition of the arrows must be the binary operation?
08:41:47 <lpaste> Cale pasted “complete definition” at http://lpaste.net/129637
08:41:52 <lolisa> * the that
08:42:02 <shapr> jerbome: Well, I figure if you can tell how it's bad, then you can tell how it could be better, right?
08:42:12 <jerbome> indiagreen, both I guess. the concepts are what get me hooked to haskell non stop those past few days, but I still cannot make a simple HTTP request...
08:42:18 <Cale> lolisa: see my paste
08:42:38 <lolisa> OK, where?
08:42:45 <Cale> <lpaste> Cale pasted “complete definition” at http://lpaste.net/129637
08:42:47 <clrnd> jerbome, I strongly suggest you start a project and see where it goes
08:42:51 <jerbome> shapr, not sure I agree. identifying badness does not mean that what I could provide wouldn't be bad in another way
08:42:52 <kaiyin> anyone care to have a look at this? https://gist.github.com/kindlychung/7c852a6c5c15ce8080d4
08:42:55 <EvanR> jerbome: actually neither can i, never got around to figuring that one out ;)
08:43:32 <shapr> jerbome: If you provide another option, then people confused aboutt one option will have a second chance to learn, how about that?
08:44:06 <shapr> Speaking of which, I've been putting off a blog post about Haskell and Arduino
08:44:18 <jerbome> shapr, I'm not out of excuses yet : more badness around = more difficult to find the graal
08:44:26 <Cale> kaiyin: Try putting in more type signatures
08:44:33 <shapr> jerbome: afrikaans?
08:44:38 <Cale> kaiyin: Your type errors will improve as you add them
08:44:51 <Cale> kaiyin: What type is offsets supposed to be?
08:45:38 <kaiyin> Cale: ok. Double -> Double -> [R2], I think. diagrams type are often complicated. 
08:45:39 <jerbome> shapr, no, why ?
08:46:21 <Cale> kaiyin: Not possible, it's zipWith applied to three arguments, so it's some type of list, not a function.
08:46:55 <kaiyin> Cale: ah, it's [R2]
08:46:58 <lolisa> OK, thx
08:48:03 <kaiyin> Cale: no, it's VectorSpace t => [[t]]
08:48:10 <clrnd> kaiyin, what's ^* type?
08:49:02 <kaiyin> clrnd: (*^) :: VectorSpace v => Scalar v -> v -> v
08:49:18 <clrnd> kaiyin, then you want R2 and you are getting Scalar R2, what the error says
08:50:20 <Cale> lolisa: I'm not sure how well this instance will play with Coq's type class mechanism
08:50:53 <Cale> lolisa: Probably extremely poorly, but then your type class has no arguments, so...
08:56:04 <lolisa> Which typeclass?
08:56:46 <Cale> Category
08:56:54 <lolisa> Cale, All I am trying to say is that my definition is not doing well... Do you have any suggestion for enhancing it's ability?
08:57:00 <Cale> It would make a bit more sense just to make it a record type
08:57:41 <lolisa> Category?
08:57:51 <Cale> Yeah
08:58:05 <prophile> https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Category.html
08:58:06 <lolisa> Thankyou.
08:58:42 <Cale> Yeah, or I suppose you could do the slightly weird thing that we do in Haskell and parameterise it over the choice of Arrow
08:58:54 <kaiyin> clrnd: i got it, it's a typo, should have been *^ instead of ^*.
08:58:59 <Cale> Which of course means you'll also need to parameterise it over the choice of ObjectType
08:59:23 <lolisa> GADT? I like the latter idea better. So ObjectType should be a parameter of Category?
08:59:24 <clrnd> kaiyin, oh well
08:59:41 <Cale> Class Category (ObjectType : Type) (Arrow : ObjectType -> ObjectType -> Type) := { compose ... }.
09:00:58 <Cale> Ah, but then you have nothing which is actually called Arrow anywhere.
09:01:49 <lolisa> ... But I still doesn't see how it could help my performance of my monoid instance...
09:04:04 <indiagreen> how do I link to another section in Haddock?
09:04:12 <Cale> Yeah, you're better off not trying to have Coq infer which category you mean in all cases.
09:05:00 <schell> is there a preferred method to “eval” haskell? Like if I wanted to evaluate the string “filter (/=3)” into a function of type (Num a, Eq a) => [a] -> [a] that I can then run on internal data?
09:05:37 <clrnd> schell, that doesn't seem to make sense, you can curry that as is
09:05:40 <schell> or should i write an AST deriving (Read, Show) ?
09:05:52 <schell> clrnd: it’s just a trivial example
09:06:28 <schell> i have a program that generates a big data set and i’d like to be able to arbitrarily map reduce that set without recompiling
09:07:18 <Cale> Use something like hint or the ghc API?
09:07:42 <clrnd> schell, oh sorry, no idea, haskell-src-exts maybe?
09:07:56 <Cale> haskell-src-exts is just a parser/prettyprinter
09:08:06 <schell> Cale: i haven’t looked at hint yet
09:08:14 <schell> clrnd: no worries, i appreciate the help!
09:10:04 <schell> Cale: hint looks like the ticket!
09:10:07 <schell> thanks
09:10:54 <dmj`> why do I need to import Data.String in order for ghc to pick up on the IsString instance when the -XOverloadedStrings extension is enabled
09:11:33 <dmj`> why doesn't declaring my own IsString class work? The code in Data.String doesn't seem special, does OverloadedStrings only use the instance from the Data.String module?
09:11:38 <Cale> dmj`: Because that's where the IsString instance for [Char] is defined.
09:12:11 <dmj`> Cale: but defining that on my own instance IsString [Char] where fromString = id, should work no?
09:12:12 <Cale> The OverloadedStrings extension just makes String literals automatically have fromString applied to them.
09:12:22 <Cale> oh
09:12:38 <Cale> Uh... how are you doing that though?
09:12:52 <Cale> You can't import the class without the instance.
09:13:02 <Cale> because the class is in Data.String
09:13:20 <dmj`> I'm defining both the class and the instance in a file 
09:13:22 <Cale> and as soon as you import a module, you get all its instances, non-negotiable
09:13:45 <Cale> If you want to do that, maybe try turning on RebindableSyntax as well?
09:15:17 <ReinH> Cale: I don't think RebindableSyntax affects fromString since it isn't in the Prelude
09:15:18 <Cale> I'm not sure if RebindableSyntax interacts at all with OverloadedStrings
09:15:32 <ReinH> it affects fromInteger and fromRational
09:15:49 <dmj`> Cale: I just don't see what's so special about the classes in Data.String. Defining them on my own should allow OverloadedStrings to work
09:16:02 <dmj`> s/classes/class
09:16:10 <ReinH> dmj`: what's special is that OverloadedStrings is hard coded to work with it
09:16:23 <ReinH> OverloadedStrings uses Data.String.IsString
09:16:38 <ReinH> Not whatever IsString is in scope
09:16:50 <dmj`> ReinH: I see, that's the answer I was looking for. Thanks ReinH
09:19:46 <dmj`> ReinH: I don't see the hardcodedness in the GHC source, I know base is a library bundled with ghc, but where is the extension defined? 
09:20:40 <dmj`> GHC.Exts, ah :)
09:21:43 <mauke^> https://github.com/ghc/ghc/blob/b359c886cd7578ed083bcedcea05d315ecaeeb54/compiler/prelude/PrelNames.hs#L1190
09:23:50 <dmj`> mauke^: so this shows the class name is searched for, not necessarily specific to the module Data.String though
09:24:20 <dmj`> Oh nevermind
09:24:27 <dmj`> dATA_STRING     = mkBaseModule (fsLit "Data.String")
09:24:38 <dmj`> so that's how the sausage is made
09:25:03 <dmj`> mauke^: thanks
09:26:25 <lolisa> Cale, I figured out what I'd done wrong: with my definition of Category alone, all I can ever construct is the identity arrow... If I want anything else I must introduce another arrow by hand, whether it is monoid category or function category or poser or blablabla...
09:27:27 <EvanR> lolisa: if you only have "some arbitrary category" there may not be any other arrows to choose from
09:27:40 <EvanR> so the interface doesnt let you have one
09:27:58 <Cale> lolisa: Of course. That's not wrong.
09:28:00 <EvanR> you have to already have one some other way
09:28:23 <Cale> lolisa: The only arrows which the definition of a category guarantees exist are the identity arrows.
09:29:30 <lolisa> Thankyou for being so patient...
09:29:33 * lolisa go to sleep
09:30:11 <dmj`> overloaded lists, what a great idea
09:32:11 <schell> if i have a strict Map String a in normal form - is there any way to tell approximately how much RAM that is taking up?
09:32:49 <indiagreen> you can't have a strict Map
09:32:52 <sritchie> anyone have an issue with the emacs interactive-haskell process dying every minute or so?
09:32:53 <sritchie> anyone have an issue with the emacs interactive-haskell process dying every minute or so?
09:32:54 <sritchie> (whoops, sorry about the double tap)
09:33:07 <schell> indiagreen: really? what’s up with containers’ Data.Map.Strict then?
09:33:16 <sritchie> the process dies with nothing in *haskell-process-log*, and haskell-process-restart fixes it up for the next couple of minutes
09:33:25 <indiagreen> it's the same as usual Map, only the combinators are different
09:33:57 <schell> ah, okay - does that mean the answer is “no - there’s no way to approximate the amount of memory” ?
09:34:20 <schell> indiagreen: because i could “force” evaluation of the map, correct?
09:35:35 <dmj`> schell: ekg is good for eyeballing memory consumption. It just uses GHC.Stats under the hood. 
09:35:54 <indiagreen> honestly, if I was you I'd just do an experiment
09:36:11 <schell> dmj`: i have used ekg before, thanks - i’ll look into GHC.States
09:36:14 <indiagreen> actually, if you end up doing an experiment, please share
09:36:21 <schell> indiagreen: yes, i’ll have to do that
09:36:29 <schell> indiagreen: i will! thanks :)
09:37:25 <wz1000> Is there any way to make cabal just download the .cabal file and check if installing a package and its dependecies will not break stuff? 
09:39:18 <dmj`> schell: might be hard to gauge memory consumption because of the garbage collector, if you use a StablePtr you can store things outside of the GC's control
09:39:32 <hexagoxel> wz1000: `cabal install --dry-run` (which does no downloading, but finds the install plan, which is what you meant, right?)
09:40:06 <wz1000> hexagoxel: Yes, thanks
09:40:41 <schell> dmj`: my goal is to be able to set an upper bound of memory consumption beyond which my big data structure is flushed to disk
09:40:52 <schell> kinda like rotating logs
09:41:21 <schell> i just needs some approximate way of telling how much the structure is taking
09:41:34 <schell> i may have to fall back on # of entries or something
09:41:41 <schell> instead of # of bytes
09:42:20 <schell> dmj`: thanks for the tip
09:43:07 <dmj`> schell: why not use acid-state
09:43:24 <EvanR> acid-state requires the entire structure always be in memory
09:43:34 <schell> dmj`: i have considered that, and i haven’t ruled it out
09:43:37 <dmj`> EvanR: correct
09:43:38 <EvanR> that is, that it can fit in memory
09:44:20 <EvanR> ok thought schell was trying to save memory by flushing to disk
09:44:35 <schell> i am
09:44:42 <EvanR> acid state wont help then
09:45:09 <schell> not - not with that
09:45:20 <schell> it addresses some other problems i have to solve though
09:45:57 <dmj`> schell: after you flush the structure to disk are you recreating it anew? Like if you persisted a list w/ 50k objects, dumped it to disk, would you start over with an empty list
09:46:07 <schell> either way it’s would be nice to know if you can predict the byte size of some # of entries in a map
09:46:26 <schell> dmj`: yes - it would flush to disk and then start again with an empty map
09:47:55 <dmj`> schell: ok yea, don't use acid-state then
09:48:45 <wz1000> I'm trying to get IHaskell to run. Is this the right place or is there a dedicated channel?
09:49:29 <schell> what if i write a storable instance for [(k,v)] corresponding to my Map k v and then i can use (sizeOf . Map.toList)?
09:50:47 <schell> ah - i have to implement sizeOf when writing Storable, lol
10:02:18 <Luke> does anyone use persistent for sql db management?
10:02:33 <Luke> I've seen it treat relational tables pretty weird before and don't know if that's still the case
10:10:55 <benzrf> hmm
10:11:03 <benzrf> > case undefined :: () -> () of _ -> True
10:11:05 <lambdabot>  True
10:11:16 <benzrf> > undefined :: () -> () `seq` True
10:11:17 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable 'GHC.Types.True)
10:11:18 <lambdabot>    arising from a use of ‘M905282014726461184023901.show_M9052820147264611840...
10:11:27 <benzrf> > (undefined :: () -> ()) `seq` True
10:11:28 <lambdabot>  *Exception: Prelude.undefined
10:11:34 <benzrf> whats up with that
10:11:48 <mauke^> _ doesn't force
10:12:59 <bitemyapp> benzrf: charlie don't surf
10:13:06 <bitemyapp> benzrf: look at Core.
10:13:48 <benzrf> > case undefined :: () -> () of v -> True
10:13:50 <lambdabot>  True
10:16:14 <mauke^> irrefutable
10:16:20 <benzrf> hh
10:16:24 <benzrf> > case undefined :: () -> () of !v -> True
10:16:26 <lambdabot>  *Exception: Prelude.undefined
10:16:29 <benzrf> now there we go
10:18:37 <Luke> tomjaguarpaw: hey you around?
10:20:10 <mpickering> Is RecursiveDo required for the rec keyword?
10:22:31 <geekosaur> yes?
10:23:38 <shachaf> That's an odd question so you should clarify what you mean.
10:23:54 <geekosaur> indeed
10:24:08 <shachaf> For instance you could be asking "if I want to use do-rec syntax, do I need to turn on RecursiveDo?". The answer is yes.
10:24:46 <shachaf> Or you could be asking "if I want to have a variable named rec, am I safe as long as I don't turn on RecursiveDo?". It's a bit less clear in that situation.
10:25:29 <indiagreen> incidentally, the answer is “yes” for shachaf's latter question as well
10:25:34 <shachaf> (For instance the deprecated extension DoRec will also turn it on.)
10:25:45 <mauke^> DoRecMi
10:25:52 <indiagreen> hey, deprecated extensions don't cou— okay, fine, you got me here
10:25:53 <mpickering> I was reading the user guide which seemed to indicated that RecursiveDo was deprecated
10:26:09 <shachaf> Maybe you were reading a deprecated guide.
10:26:16 <mpickering> but google was caching and old version
10:26:53 <shachaf> Anyway, I did too much guessing already. It's a bad habit.
10:27:12 <mpickering> I was just reading an old version of the user guide
10:27:26 <mpickering> and was wondering what the proper way to get the rec keyword was if not RecursiveDo
10:27:33 <mpickering> but it turns out that's the way to do it
10:33:46 <bazqux> Is there anyway to obtain more information about a type error? Perhaps like some sort of backtrace showing what gave rise to the erroneous type.
10:33:49 <quchen> mpickering: Google is not a good source for the GHC user's guide. It hasn't sent me to the current version even once so far.
10:34:10 <quchen> mpickering: For a very manual approach, you can click the link and then replace the version number in it with "latest", that usually works.
10:48:13 <juanca_> has someone used before nested routes in snap, i'm having troubles with that
10:54:06 <schell> is there any specific reason ByteString does not have a Storable instance?
10:55:14 <geekosaur> doesn't Storable require a fixed size type?
10:55:30 <EvanR> right thats the issue
10:56:04 <schell> ahh
10:56:05 <EvanR> theres Storable Vector for that
10:56:29 <Saizan> you could store the pointer, i guess
10:56:56 <EvanR> or convert the ByteString to Storable Vector
10:57:21 <schell> for some reason i thought there was a Storable instance for Storable a => [a] as well 
10:57:39 <EvanR> thats Binary
10:58:43 <schell> EvanR: this Binary? http://hackage.haskell.org/package/binary-0.7.4.0/docs/Data-Binary.html
10:58:56 <EvanR> yers
11:13:59 * hackagebot hjsonschema 0.5.1.2 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.1.2 (seagreen)
11:18:01 <jwingfi> what's the difference between an operation/function defined as part of a typeclass and one that operates on a typeclass?
11:18:01 <jwingfi> e.g. =<< vs. >>=
11:18:11 <jwingfi> just that the ops defined on a typeclass must be implemented unless a default is provided?
11:18:18 <jwingfi> I guess scoping/imports too?
11:18:44 <Welkin> ?
11:18:59 <Welkin> there is always a minimal definition
11:19:08 <Welkin> you don't need to implement the entire typeclass
11:19:40 <johnw> often that minimal definition is a call to "error"
11:19:41 <Welkin> (==) and (/=) are defined in terms of each other
11:19:44 <c_wraith> jwingfi: things in the class can have their implementation depend on the type.  Things not in the class have only one implementation
11:19:45 <Welkin> so you only need to implement one of them
11:20:01 <jwingfi> ah, brilliant. thanks
11:20:02 <johnw> oh, you mean the minimal set of things
11:20:03 <levi> The ones defined as part of the typeclass are the ones that are specialized per instance and get passed to the class-constrained function. They may have default implementations in terms of other typeclass methods, though, so they're not *necessarily* specialized.
11:20:43 <c_wraith> levi: they at least always *can* be specialized
11:20:51 <levi> Right.
11:20:51 <jwingfi> yeah, makes sense. That should have been obvious to me
11:20:59 <jwingfi> because =<< is probably defined in terms of >>=
11:21:24 <jwingfi> no need to force instances to re-implement it
11:21:48 <levi> But *only* the class methods can know anything about the type; the others must be truly polymorphic.
11:21:58 <EvanR> jwingfi: well =<< isnt in the class
11:22:04 <EvanR> so thats another story
11:22:13 <jwingfi> @EvanR, yeah, that was what prompted my curiousity
11:22:13 <lambdabot> Unknown command, try @list
11:22:29 <EvanR> jwingfi: think /= in terms of ==
11:24:00 * hackagebot reflex 0.1.0 - Higher-order Functional Reactive Programming  http://hackage.haskell.org/package/reflex-0.1.0 (RyanTrinkle)
11:24:00 <jwingfi> right, but because >>= is defined on the typeclass, =<< doesn't need to be, and can just be defined independently. Correct?
11:24:20 <EvanR> its not independently, its dependent on the class
11:24:33 <EvanR> @src (=<<)
11:24:33 <lambdabot> f =<< x = x >>= f
11:24:56 <levi> Well, it's dependent on the class, but not the *instance* of the class.
11:25:28 <jwingfi> ok, got it. thanks
11:39:36 <breadmonster> Hey everyone.
11:39:56 <johnw> mold must be your eternal enemy
11:41:44 <Welkin> you mean water
11:41:58 <johnw> that just turns him into dumplingmonster
11:42:01 <hiptobecubic> what about ducks?
11:42:05 <johnw> ooh
11:47:03 <frerich_> Didn’t somebody (Cale?) talk about doing IO as part of using template haskell? I just found this interesting use case while browsing Hackage: http://hackage.haskell.org/package/file-embed-0.0.8.2/docs/Data-FileEmbed.html
11:49:39 <indiagreen> frerich_: that's pretty interesting, thanks
11:52:40 <dmj`> them thunks be buildin'
11:54:33 <schell> if i tid <- forkIO $ bracket a b c; killThread tid, does b get run?
11:55:17 <dmj`> schell: yes because bracket masks async exceptions
11:55:32 <schell> or better yet do{tid <- forkIO $ bracket a b (forever c); threadDelay 1000000; killThread tid}
11:55:40 <schell> dmj`: sweet, thanks
11:55:46 <dmj`> schell: mask turns async exceptions into sync exceptions, killThread raises an async exception, you're aborting a child thread
11:56:00 <dmj`> schell: I still you recommend you try it out
11:56:03 <dmj`> or I will
11:56:13 <schell> i definitely will
11:56:18 <schell> thank you :)
11:56:30 <dmj`> schell: quiz, name 4 kinds of async exceptions
11:57:01 <schell> good, bad, really bad and super bad? 
11:57:24 <int-e> Oh StateVar and ObjectName are back, I thought we had a discussion that they should have a more specific name and namespace :-(
11:57:38 <dmj`> schell: https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception.html#t:AsyncException
11:57:51 <schell> lol, sorry and thanks again
11:58:19 <dmj`> schell: async exceptions are tough since they could happen at any time
11:59:13 <schell> ah, nice - thanks for the link
12:00:19 <verement> I except
12:04:55 <EvanR> @hoogle on
12:04:57 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:04:57 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
12:04:57 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
12:05:15 <Welkin> @hoogle in
12:05:15 <lambdabot> keyword in
12:05:16 <lambdabot> Prelude init :: [a] -> [a]
12:05:16 <lambdabot> Data.List init :: [a] -> [a]
12:05:33 <Welkin> @hoogle over
12:05:34 <lambdabot> Graphics.UI.GLUT.Callbacks.Window overlayDisplayCallback :: SettableStateVar (Maybe DisplayCallback)
12:05:34 <lambdabot> Graphics.UI.GLUT.Overlay overlayPossible :: GettableStateVar Bool
12:05:34 <lambdabot> Graphics.UI.GLUT.Overlay overlayVisible :: SettableStateVar Bool
12:05:38 <EvanR> is there a comparing-like function for == Bool instead of Ordering
12:05:46 <indiagreen> @hoogle equating
12:05:46 <lambdabot> No results found
12:05:51 <indiagreen> hm
12:05:55 <indiagreen> @hayoo equating
12:05:55 <lambdabot> Unknown command, try @list
12:05:57 <johnw> breadmonster: hi :)
12:06:17 <EvanR> i see a proposal for equating
12:06:30 <indiagreen> it's also in base-prelude
12:06:35 <indiagreen> * basic-prelude
12:06:44 <EvanR> on (==) works
12:06:49 <EvanR> i think
12:07:18 <indiagreen> it does
12:09:25 <lpaste> schell pasted “bracket + forkio” at http://lpaste.net/129646
12:09:28 <geekosaur> I think the only reason comparing exists is that it predated (and in fact inspired) Data.Function.on
12:09:52 <schell> dmj`: it kinda does it
12:10:05 <schell> not what i expected though - i’m guessing i made a silly mistake
12:10:14 <EvanR> schell: are you looking for forkFinally ?
12:10:18 <schell> maybe?
12:10:32 <EvanR> i think you are
12:10:35 <schell> really just wanted to see if bracket would do what i wanted
12:10:51 <EvanR> it might do what you want, up to async exceptions
12:11:04 <schell> but - i also expected four or five outputs of “hello” and then “hello goodbye”
12:11:08 <EvanR> forkFinally does all the unmasking for you
12:11:14 <schell> i got one hello and two hello goodbyes
12:14:59 <dmj`> schell: you should check out the `async` package
12:15:17 <schell> ah yes! i have used and like async
12:19:35 <schoening> Hi! I am trying out some examples from the "learnyouhaskell" website.  I don't understand this part. Why does  x*2 return a 2  on the first list item. 1*1 shoulndt be 2.. [x*2 | x <- [1..10]]
12:20:04 <geekosaur> huh?
12:20:07 <koala_man> schoening: it's x*2, not x*x or x^2
12:21:06 <schoening> ohhh
12:21:13 <schoening> ok. sorry. I'm retarded :p
12:25:12 <schell> dmj`: BTW - in my lpaste i found my loop was incorrect i had switch bracket’s params and forgot to switch the loop as well
12:29:49 <Fylwind> is there a way to specify a constraint on 'a -> a' such that 'a' can be both X and Y without spinning off a whole new type class for it?
12:31:14 <Fylwind> can be coerced into both*, like: (x :: a) :: Y and (x :: a) :: Y are both valid
12:34:44 <ski> Fylwind : afaik, no
12:35:03 <Fylwind> ski: :(
12:35:29 <Fylwind> I'm trying to write a function to do LevMar fits but using AD differentiation
12:35:37 <Fylwind> to compute the Jacobian
12:36:15 <Fylwind> I don't want to put an explicit constraint like "Floating a =>" because that would limit the kinds of numbers allowed
12:36:42 <Fylwind> I guess I should just use a concrete type
12:41:05 <EvanR> heh tried to use fst on a list to get first item, bad very bad 
12:43:04 <johnw> EvanR: a very Lispy thing to do
12:43:32 <EvanR> yeah i had [(a,b)]
12:43:38 <EvanR> fst . fst ;)
12:43:43 <EvanR> very very wrong
12:44:10 <EvanR> ffst ;)
12:53:25 <sternenseemann> caar
12:56:14 <frerich_> I find myself using JSON even for configuration files simply because the Aeson TH magic works so well for parsing a file into data structures :-}
12:57:40 <t7> i have gone from loving json to loving xml
12:58:19 <benzrf> t7: eeeeew
12:58:32 <EvanR> uwot
12:58:36 <johnw> wow
12:59:04 * hackagebot pinboard 0.4 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.4 (jonschoning)
12:59:23 <t7> everything i tend to store tends to be ADT like in shape so it might as well have explicit tags 
13:00:05 <johnw> can't argue with you there
13:00:16 <johnw> I always thought gcc-xml was a great project idea, too bad it languished
13:00:38 <johnw> it's nice to read it in a fully constructed and validated AST
13:01:36 <t7> i guess clang will take that role now
13:01:47 <t7> after stallman's comments on the matter
13:02:17 <Rembane> Did he break gcc?
13:02:26 <johnw> well, libclang lets you access that information another way, and it can cache constructed ASTs to disk, but it isn't XML
13:03:05 <eremox-> anyone that could help me parsing comments? i've run into trouble and im getting odd errors
13:07:50 <sydneyhacker> @t7 try protobuf
13:07:50 <lambdabot> Maybe you meant: wn v thx rc pl id do bf @ ? .
13:11:48 <gyaretto> What is a reader monad?
13:12:14 <aawe> I have been avoiding the continuation monad in my mind ever since I heard of it, and suddenly out of the blue, today, it clicked and I understood how it must work
13:12:23 <EvanR> gyaretto: r -> a
13:12:27 <aawe> while thinking about completely different things
13:12:42 <aawe> is anyone else ever assaulted by haskell in their daily life?
13:12:58 <Clint> in a nice way
13:13:17 <TK_> Some think in it.
13:13:58 <spaceships> i often have dreams that are an uncomfortable mixture of programming and some other activity that is not programming
13:16:39 <Bashmetim> Is there an easy way to export every function in a module, except one or two?
13:17:08 <Bashmetim> You can say :: module Thing (a, b, c, d, e, g) where
13:17:21 <Welkin> use `hiding`
13:17:47 <Bashmetim> Isn't that for importing?
13:17:48 <Welkin> import Prelude hiding (foldr, foldl)
13:17:53 <Welkin> oh
13:18:11 <indiagreen> I think there's no way
13:18:17 <Welkin> it's good practice to onluy export what you need
13:18:25 <indiagreen> because I recall someone knowledgeable complaining about it
13:18:31 <Welkin> so doing it explicitly is good anyway
13:18:31 <Bashmetim> I'm thinking :: module Thing -(f) where :: to export everything but f
13:19:23 <randir> is there a more efficient way to write this? (f' <= 8 && f' >= 0)
13:19:45 <indiagreen> inRange (0,8) f'
13:20:07 <Fylwind> edwardk: there seems to be no Rank1 equivalent for AD.Mode.Reverse … is that intentional?
13:20:11 <Bashmetim> Hm. Is that more efficient, or just cleaner?
13:20:15 <EvanR> x <= && f >= 0 might be the most efficient
13:20:18 <EvanR> er x
13:20:33 <edwardk> i build a tape. where do i put the tape in a rank-1 version?
13:20:39 <indiagreen> just cleaner. I thought you meant “efficient” in the “saving keystrokes” way
13:20:55 <indiagreen> I wonder how it could actually be more efficient
13:21:17 <randir> I'm just looking for the most computationally efficent way to check if (a,b) is in the range [1..8] for both a and b
13:21:32 <randir> (I realize my code included 0, that was a mistake, it's only 1..8)
13:21:40 <Bashmetim> I'd agree with EvanR that its probably the most efficient way.
13:22:00 <Bashmetim> inRange is probably, at best, exactly the same
13:22:13 <Fylwind> edwardk: good point
13:23:56 <randir> this is what I have currently: inRange (f',r') = (f' <= 8 && f' >= 1) && (r' <= 8 && r' >= 1)
13:24:13 <randir> seems as efficent as I can get it?
13:24:25 <Bashmetim> randir - inline assembly might speed things up a bit, that seems good
13:24:39 <randir> Okay, thanks
13:24:44 <Bashmetim> If you import Data.Ix there's an inRange that also does exactly that
13:25:01 <Bashmetim> inRange :: Ix a => (a, a) -> a -> Bool
13:25:23 <EvanR> randir: at this point you need to allow the compiler to do its job
13:25:31 <randir> k
13:25:39 <EvanR> spelling x < 8 differently to speed things up is C thinking
13:25:49 <EvanR> even there it doesnt work
13:25:50 <randir> EvanR: btw, my chess engine is coming along. Got a nearly complete board framework and psudo-legal move generator
13:25:55 <teurastaja> i need an example of currying that function to understand, i want to make a function that makes another from 3 parameters and i can use the resulting function on the last argument. heres the uncurried version:
13:26:13 <Bashmetim> so :: inOneEight f' && inOneEight r' where inOneEight = inRange (1,8)
13:27:42 <teurastaja> charge farads volts ohms time = farads * volts * (exp ((0 - t) / (ohms * farads)))
13:28:16 <EvanR> t not in scope
13:28:16 <teurastaja> how do i make it a higher-order function that just takes time?
13:28:17 <Bashmetim> er... inRange ((1,1), (8,8))   <-- That does exactly what you want
13:28:33 <teurastaja> oops t is time
13:28:37 <teurastaja> sorry
13:28:44 <teurastaja> charge farads volts ohms time = farads * volts * (exp ((0 - time) / (ohms * farads)))
13:29:08 <EvanR> apply three out of the four arguments to the function charge
13:29:13 <EvanR> the result is a function of time
13:29:29 <teurastaja> i know the concept but what would it look like?
13:29:45 <EvanR> charge' = charge 4 5 6
13:30:15 <EvanR> look at the type signatures too, which helps think about this
13:30:40 <EvanR> charge :: Real -> Real -> Real -> Real -> Real
13:30:48 <EvanR> charge 3 4 5 :: Real -> Real
13:30:58 <teurastaja> so i keep my old definition and just define a function that takes time and does charge farads volts ohms ?
13:31:15 <EvanR> if you want
13:32:11 <Bashmetim> let f = charge farads volts ohms
13:32:36 <Bashmetim> f takes t and returns charge
13:32:40 <teurastaja> im also wondering, i use scientific and engineers notation a lot. is there a language facility that takes a bunch of scientific notations and put them on the same exponent?
13:33:00 <Bashmetim> What do you mean?
13:33:31 <Bashmetim> You can write real numbers in scientific notation: 1.75e3 == 1750.0
13:34:27 <teurastaja> like in this function i just asked about, id put the parameters in scientific notation and would like the answer converted to an arbitrary exponent in scientific notation
13:34:50 <EvanR> displaying numbers in scientific notation, you can use the Numeric module
13:35:03 <EvanR> this is a separate issue from computing with them or specifying them in source code
13:35:45 <porglezomp> Hey, does anyone know if `ghc --make` uses more memory than compiling files individually?
13:35:54 <EvanR> > showEFloat Nothing 3.14 ""
13:35:56 <lambdabot>  "3.14e0"
13:36:39 <teurastaja> what does the E stand for?
13:36:49 <johnw> exponent
13:36:50 <teurastaja> in EFloat
13:36:55 <teurastaja> oh
13:37:04 <johnw> * 10^0 in this case
13:37:32 <indiagreen> EvanR: this doesn't let you choose exponent, however
13:37:54 <Bashmetim> > map (\x -> x + 1) [1..10]
13:37:56 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:38:05 <EvanR> indiagreen: its scientific notation though
13:38:05 <Bashmetim> That is a cool bot!
13:38:13 <teurastaja> lets say i have 6.9e3 and i want it in e-6
13:38:20 <porglezomp> > [x + 1 | x <- [1..10]]
13:38:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:39:17 <teurastaja> precision is very important
13:39:23 <Enigmagic> > ((+) 1) <$> [1..10]
13:39:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:39:26 <Enigmagic> lets golf. :P
13:39:27 <Bashmetim> So, 6900000000e-6
13:39:37 <Bashmetim> ?
13:39:39 <porglezomp> Is there any good way to reduce memory usage of compiling?
13:39:57 <porglezomp> I'm running into the 2GB limit trying to compile Idris with cabal-install
13:39:58 <EvanR> teurastaja: you can multiply by million, take the whole number part and tack on a "e-6" yourself, is one way
13:40:38 <EvanR> or showFFloat the scaled number to keep the decimals
13:41:21 <EvanR> youre basically talking about units
13:41:41 <teurastaja> EvanR: i have many different calculations for instance i can have microfarads, kiloohms and volts then want the answer in millicoulombs
13:42:06 <EvanR> usually you agree on what units all your numbers are in ahead of time and remember
13:42:24 <Bashmetim> > :t showFFloat
13:42:25 <lambdabot>  <hint>:1:1: parse error on input â:â
13:42:43 <EvanR> but there are ways to use types to remember whats what and avoid dividing feet by meters per second
13:42:45 <porglezomp> :t showFFloat
13:42:46 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
13:42:59 <porglezomp> No need for a > when you're using the meta commands
13:43:44 <Bashmetim> > floatToDigits 10 3.14
13:43:46 <lambdabot>  ([3,1,4],1)
13:44:06 <teurastaja> do i lose precision?
13:44:38 <EvanR> when you do what
13:45:13 <teurastaja> with your float solution
13:45:38 <EvanR> you can multiply any float by a power of ten and it will be the right answer
13:45:49 <EvanR> ... unless its really big
13:45:55 <EvanR> so nevermind
13:46:23 <Bashmetim> If you are multiplying or dividing your number by 100 or 1000000 then you are running the risk of losing persicion, just because of the way floating point math is done
13:46:47 <teurastaja> i use picofarads and terabytes so yes i need precision for very big values
13:47:38 <teurastaja> can i use scientific notation and not lose precision?
13:47:44 <indiagreen> maybe you'd be better off using Scientific instead
13:47:56 <EvanR> you can use Data.Fixed to use base ten fractions if you want
13:48:04 <EvanR> > 3.14 :: Pico
13:48:06 <lambdabot>  3.140000000000
13:48:26 <EvanR> this isnt really appropriate for terabytes though, which are counting discrete bytes
13:48:26 <Bashmetim> > :info Pico
13:48:27 <lambdabot>  <hint>:1:1: parse error on input â:â
13:48:31 <aawe> isn't there an infinite-precision floating point type in haskell?
13:48:37 <roboguy_> teurastaja: scientific notation is just another way of writing floating point literals
13:48:42 <EvanR> aawe: CReal
13:48:53 <dolio> CReal isn't floating point, though.
13:48:59 <geekosaur> not built in. there's a CReal on Hackage but it has shortcomings (try getting infinite precision on pi)
13:48:59 <roboguy_> :t 3e-9
13:49:00 <lambdabot> Fractional a => a
13:49:08 <EvanR> > sin pi :: CReal
13:49:09 <lambdabot>  0.0
13:49:14 <Bashmetim> infinite-precision floating point is actually an oxymoron....
13:49:15 <EvanR> Floating at least
13:49:20 <Fylwind> I think scientific is more suited for storing numbers, but doing actual math on it is probably not a good idea (e.g. divergence on division)
13:49:20 <aawe> > sin 2 :: CReal
13:49:22 <lambdabot>  0.9092974268256816953960198659117448427023
13:49:27 <aawe> truly infinite
13:49:29 <dolio> No, it's not.
13:50:00 <dolio> The floating point numbers are numbers of the form i/2^n, where i and n are integers.
13:50:06 <joe9> need some advice, please? I want to write an app that will show me questions as: "How do you rate this <product> now?" and store the pair of product, rating to be read/analysed later. I use linux command line more. So, any suggestions for an ncurses library or any other library without using ncurses, please?
13:50:08 <Bashmetim> Does lambdabot guard against things like [1..]
13:50:17 <Bashmetim> (I'm assuming so)
13:50:18 <dolio> Which has arbitrary amounts of precision.
13:50:19 <Enigmagic> > length [1..]
13:50:19 <roboguy_> Bashmetim: it just stops after a while
13:50:20 <S11001001> Bashmetim: you don't have to guard against that
13:50:23 <lambdabot>  mueval-core: Time limit exceeded
13:50:24 <aawe> dolio: you are thinking of IEEE floating point
13:50:31 <indiagreen> dolio: CReal isn't implemented in this way
13:50:40 <roboguy_> Bashmetim: it also doesn't run IO actions
13:50:43 <S11001001> Bashmetim: the printer stops you by having too many characters :)
13:50:44 <dolio> I know. That's why I said CReal isn't floating point numbers.
13:50:46 <roboguy_> > print 4
13:50:48 <lambdabot>  <IO ()>
13:50:49 <Bashmetim> Hm
13:50:52 <Fylwind> edwardk: for calculating Jacobians where the inputs are few but outputs could be many, would Sparse be more or less efficient than Reverse?
13:50:52 <dolio> They are computable reals.
13:50:52 <Bashmetim> > print 2
13:50:54 <lambdabot>  <IO ()>
13:51:01 <Bashmetim> Correct!
13:51:21 <edwardk> with few inputs and many outputs you want sparse or forward-ish techniques
13:51:26 <arkeet> > sin pi == (0 :: CReal)
13:51:27 <lambdabot>  True
13:51:33 <arkeet> oh I guess it just compares some number of digits.
13:51:49 <arkeet> > cos pi == (10^^(-50) - 1 :: CReal)
13:51:50 <lambdabot>  True
13:51:58 <teurastaja> so... how would i take nanosomething megasomethingelse or picowhatever and have and answer in millithing?
13:52:06 <edwardk> arkeet: sadly
13:52:16 <dolio> Yes, it's sad that you get answers.
13:52:19 <ReinH> @hackage dimensional -- teurastaja
13:52:19 <lambdabot> http://hackage.haskell.org/package/dimensional -- teurastaja
13:52:25 <EvanR> == should freeze up almost always!
13:52:29 <aawe> isn't floating point a concept of non-integer numbers - numbers with a fractinal component - and IEEE floating point is the default impl?
13:52:33 <ReinH> @hackage units -- or perhaps this
13:52:34 <lambdabot> http://hackage.haskell.org/package/units -- or perhaps this
13:52:38 <Fylwind> edwardk: thanks!
13:52:44 <arkeet> > dropWhile (\x -> cos pi == (10^^x - 1 :: CReal)) [-50..]
13:52:45 <edwardk> dolio: indeed
13:52:46 <lambdabot>  [-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23...
13:52:49 <EvanR> floating point is fixed point where the point can move
13:53:43 <dmj`> the typeclassopedia is purifying to the soul
13:54:07 * hackagebot filtrable 0.1.0.0 - Class of filtrable containers  http://hackage.haskell.org/package/filtrable-0.1.0.0 (MatthewFarkasDyck)
13:54:31 <Fylwind> when doing scientific calculations, you should just pick the appropriate set of units for the problem so that floating-point overflow won't happen
13:55:41 <ronh> why am I not getting error in here? http://lpaste.net/129649
13:57:23 <indiagreen> ronh: because “name” and “age” are legitimate values
13:57:28 <indiagreen> functions, in this case
13:57:42 <ronh> how come they aren't fields?
13:57:50 <arkeet> you didn't bind them.
13:57:51 <teurastaja> floating points arent even an option for me
13:57:59 <ronh> NamedFieldPuns 
13:57:59 <indiagreen> they are functions which extract the field for you
13:58:06 <ronh> I am using NamedFieldPuns?
13:58:13 <aawe> ronh: f is a function, (f x) is a value
13:58:19 <aawe> if f returns a value that is
13:58:22 <aawe> also functions are values?
13:58:22 <arkeet> NamedFieldPuns doesn't do what you're expecting.
13:58:24 <aawe> time to go to bed
13:58:33 <Bashmetim> teurastaja how much percision do you need?
13:58:36 <indiagreen> aawe: sure they are values
13:58:38 <Fylwind> teurastaja: why not?
13:58:51 <Bashmetim> You are limited by the fact that you're using a computer (I assume)
13:58:52 <arkeet> NamedFieldPuns just lets you abbreivate Person{name = name, age = age} as Person{name, age}
13:58:57 <indiagreen> ronh: you should use RecordWildCards
13:59:04 <ronh> yeah.. rnf Person { name, age } = name `deepseq` age `deepseq` () did it
13:59:09 <arkeet> if you add RecordWildCards, you can further abbreviate it to Person{..}
13:59:09 <indiagreen> and do «{..}» instead of «{}»
13:59:12 * ski again thinks having the "field" names double as the actual fields, and as the field accessor functions, depending on context, was a design mistake
13:59:21 <teurastaja> i need at scientific precision
13:59:26 <ronh> yes.. I confused the two
13:59:46 <EvanR> teurastaja: double precision is probably good enough, assuming you have sane units
13:59:53 <Fylwind> teurastaja: what problem are you trying to solve that needs so much precision?
13:59:56 <ski> teurastaja : have you learned some numerical analysis ?
14:00:03 <teurastaja> are atto and pico sane?
14:00:03 <aawe> ski: what's the alternative in your mind?
14:00:12 <EvanR> teurastaja: sure
14:00:19 <EvanR> or yocto or whatever ;)
14:00:20 <Fylwind> they are, you just *define* your units to be pico/atto-whatever
14:00:45 <ronh> do you write NFData instances yourself or use Control.DeepSeq.TH?
14:00:45 <ski> aawe : hm, alternative to what ? regarding records or regarding floating-point computation ?
14:01:01 <Bashmetim> 1.2 pico-farads only needs as much percision as it takes to store the number 1.2
14:01:02 <Fylwind> the only time you'd need such crazy precision is if you're adding 1e-999 to 1e+999
14:01:11 <EvanR> you could have units of 10^-4096 if you wantd
14:01:33 <teurastaja> i do add insanely different units
14:01:40 <EvanR> then you have problems
14:01:48 <aawe> ski: context-sensitive record getter functions | names
14:01:53 <EvanR> if the magnitudes are really very different
14:02:01 <EvanR> which means you need to fix your units
14:02:02 <Fylwind> do you have an instrument that can measure to 1e-200?
14:02:14 <ski> teurastaja : specifically, various kinds of errors, conditioning of a problem, numerical stability of an algorithm and well-posed problems. see <https://en.wikipedia.org/wiki/Numerical_analysis> for some info
14:02:16 <teurastaja> isnt there a way to keep the precision in the exponent?
14:02:36 <Bashmetim> Try playing around with this: http://www.h-schmidt.net/FloatConverter/IEEE754.html ?
14:02:44 <teurastaja> and return the answer as an exponent?
14:04:03 <teurastaja> floats should never have been invented
14:04:37 <ski> aawe : in SML, if you declare `type point = {x : real,y : real}' then if you say `val myPoint = {x = 2.0,y = 3.2}', then here `x' and `y' are the fields as you expect, of type `real' (which really means "floating-point"). if you say `sqrt (#x myPoint ** 2.0 + #y myPoint ** 2.0)' then here `#x' and `#y' are the field accessor functions, of type `point -> real'
14:04:52 <Bashmetim> floats/doubles really do the best they can with 64/32 bits
14:05:14 <aawe> ski: sounds sane. I vote in favor
14:05:55 <ski> aawe : .. in O'Caml, you'd say `myPoint .x' instead, but it's the same idea
14:06:20 <ski> (so `.x' acts like a postfix operator)
14:06:54 <forgottenone> how can i split concatenation to multiple line?
14:07:13 <arkeet> what do you mean?
14:07:38 <ski> teurastaja : numerical analysis deals with how to determine worst-case bounds on the uncertainty of results of algorithms, and how to compare algorithms and problems
14:08:00 <forgottenone> arkeet : "abc"++ \n "def"
14:08:25 <arkeet> yes, you can just put the "def" on the next line, if that's what you mean.
14:08:30 <ski> forgottenone : do you want to write a string literal across multiple lines ?
14:08:31 <arkeet> you might have to indent it, because layout rules.
14:08:34 <teurastaja> ski: im still learning haskell, i believe i need more solid background before i tackle that problem
14:09:01 <forgottenone> ski that's and more generally splitting lines 
14:09:18 <teurastaja> forgottenone: you mean something like unwords but for newlines?
14:09:52 <arkeet> you can also split string literals across lines
14:09:53 <arkeet> "like\
14:09:56 <arkeet> \this"
14:10:01 <arkeet> (er, that's "likethis" but whatever.)
14:10:03 <ski> teurastaja : possibly, yes. (i don't know enough about numerical analysis, myself). i'm just pointing out that this area of study exists to deal with the problem of floating-point computation (or in general approximations) being inexact
14:10:04 <aawe> ski: record names could be automatically generated lenses, # could be view and { a = b } could be syntactic sugar for set
14:10:41 <ski> forgottenone : as arkeet said. you can add as much space as you like before the start of each line part of the string literal
14:10:50 <forgottenone> arkeet thanks but i want more like something like this: ln = length
14:10:51 <forgottenone> n
14:10:57 <ski> aawe : possibly, yes
14:11:03 <Hijiri> would you do { a.b.c.d = e } if you wanted to compose them?
14:11:08 <Fylwind> if floats were never invented, what would take its place?
14:11:08 <arkeet> forgottenone: again, you probably have to indent subsequent lines because of layout rules.
14:11:21 <ski> aawe : just saying that the current scheme is schizophrenic
14:11:22 <arkeet> if you're getting some sort of error, do you mind showing the code?
14:11:27 <arkeet> (and the error)
14:11:27 <forgottenone> arkeet oh ok that's what i'm looking for
14:11:34 <indiagreen> aawe: there ars a big discussion about this somewhat recently, and what you're proposing was one of the solutions
14:11:38 <arkeet> unless you can get it working I guess.
14:11:43 <raek> does lambdabot have a lint function? somethink like "use this instead of that" suggestions
14:11:54 <aawe> indiagreen: cool, got any links?
14:12:06 <forgottenone> so if you want to split a line to multiple lines you have to indent right?
14:12:27 <ski> Hijiri : i'd like a concrete syntax where i can give a name to the current/old value, for use in defining the new value (of the same field, and also of other fields, preferably not only in the same sub-record)
14:12:34 <untseac> Hi. What's the difference betwenn ** and ^^?
14:12:41 <arkeet> :t (**)
14:12:42 <lambdabot> Floating a => a -> a -> a
14:12:43 <arkeet> :t (^^)
14:12:44 <lambdabot> (Integral b, Fractional a) => a -> b -> a
14:13:12 <ski> untseac : `(**)' is floating-point exponentiation. `(^^)' is exponentiation where the exponent is integral (with `(^)' it must be non-negative as well)
14:13:18 <arkeet> untseac: ^^ restricts you to integer exponents, but lets you use any Fractional type as the base.
14:13:22 <ski> @type (^)
14:13:23 <lambdabot> (Num a, Integral b) => a -> b -> a
14:13:45 <dolio> If only we had Natural.
14:13:52 <ski> (with non-negative integral exponent, we don't need reciprocal/division on the base type)
14:13:55 <arkeet> ^ restricts you to natural number exponents, but any Num type for the base works (since you don't have to divide)
14:14:11 <untseac> arkeet, I fell stupid now lol I already did check the type but didn't get it at first. thanks!
14:14:15 <arkeet> :)
14:14:25 <indiagreen> aawe: a sec
14:14:31 <EvanR> last night was the first time in a while i explained any haskell anything to anyone in real life, and the question was about foldl. and i felt weird explaining how foldl should not be used for anything
14:14:34 <ski> untseac : perhaps you learned something for next time :)
14:14:46 <EvanR> i.e. if they asked me why it exists, i wouldnt be able to answer
14:14:57 <dolio> There's one legitimate use.
14:15:02 <dolio> But it's probably not used for it.
14:15:23 <indiagreen> aawe: https://mail.haskell.org/pipermail/ghc-devs/2015-January/008049.html
14:15:39 * EvanR asks dolio what that is
14:15:44 <ski> indiagreen : 404
14:15:55 <dolio> EvanR: You can define last with foldl, and not foldl'.
14:16:00 <aawe> indiagreen: much appreciated
14:16:16 <ski> indiagreen : oh, mispaste. ignore
14:16:16 <arkeet> dolio: is there anything else you can define with foldl but not foldl'?
14:16:29 <dolio> Yes, but it would probably be more contrived than last.
14:16:33 <arkeet> heh.
14:16:37 <arkeet> oh there's the example on https://wiki.haskell.org/Foldr_Foldl_Foldl%27
14:16:50 <arkeet> that's pretty contrived.
14:19:28 <dolio> If someone implemented optimistic evaluation for GHC, foldl might be fine pretty much all of the time.
14:19:41 <dolio> But it's pretty complicated.
14:19:53 <shachaf> Didn't someone already do that once?
14:20:09 <EvanR> why is the typical example sum implemented with foldl' and not foldr
14:20:10 <dolio> Did they do it for GHC or for some one-off research project?
14:20:49 <arkeet> EvanR: because see the wiki page I just linked.
14:20:49 <EvanR> just because of the seq
14:20:49 <dolio> Because foldl'
14:20:51 <Fylwind> EvanR: think it's more efficient that way
14:21:02 <dolio> Because foldl' works better for most numeric types people actually use.
14:21:18 <arkeet> foldr builds up a big thing on the stack, if (+) is strict.
14:21:20 <dolio> Without having to be super-inlined.
14:21:31 <shachaf> I thought it was for GHC.
14:21:33 <arkeet> (and (+) is strict for most numeric types.)
14:21:36 <EvanR> ah eager +
14:21:40 <joe9> Any suggestions on which would be more suited to write a program that asks questions and stores the input. prompt vs operational? I want the program to ask questions and suggest some answer prompts to the user. similar to an install program, etc..
14:21:44 <EvanR> (and strict)
14:22:02 <dolio> Actually, even inlining isn't going to save foldr.
14:22:20 <Fylwind> dolio: it'd have to understand associativity of +
14:22:39 <dolio> Not just that, probably.
14:25:32 <dolio> I think you need to know that + is strict in the second argument, too (in the cases that it is).
14:26:09 <dolio> And know that that allows you to fundamentally rewrite the computation in infinitary ways.
14:26:18 <dolio> Because it won't change the results on infinite inputs.
14:27:37 <dolio> For instance, foldr (+) 0 and foldl (+) 0 are not the same function when used with lazy naturals.
14:27:48 <dolio> Denotationally.
14:27:58 <dolio> Not merely operationally.
14:28:49 <levi> By 'lazy naturals' you mean an inductive definition of naturals?
14:29:02 <arkeet> > foldr (++) [] [[(),()], repeat ()]
14:29:04 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:29:08 <arkeet> > foldl (++) [] [[(),()], repeat ()]
14:29:09 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:29:13 <arkeet> hm.
14:29:15 <arkeet> poor example.
14:29:25 <arkeet> > foldl (++) [] (repeat [()])
14:29:29 <lambdabot>  mueval-core: Time limit exceeded
14:29:30 <arkeet> > foldr (++) [] (repeat [()])
14:29:31 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:29:54 <arkeet> the type [()] is the same as lazy naturals.
14:30:24 <levi> Yeah, that's what I was trying to confirm. Thanks.
14:30:32 <EvanR> not very natural, since repeat ()
14:31:18 <levi> Well, it's isomorphic, but you'd normally do something like data Nat = Z | S Nat
14:31:36 <EvanR> yeah fix S
14:31:43 <EvanR> not very natural either ;)
14:31:50 <roboguy_> it's natural numbers + some concept of "infinity"
14:31:56 <EvanR> uh
14:32:09 <EvanR> its a bug imo ;)
14:32:13 <levi> EvanR: What definition of 'natural' are you using here? I'm not sure what you're saying.
14:32:28 <EvanR> a well founded one
14:32:38 <roboguy_> levi: I think what EvanR is saying is that infinity isn't a natural number
14:32:52 <EvanR> also repeat () isnt infinity
14:33:02 <Welkin> () is not a number
14:33:22 <Aruro> is it possible to overload (+) by defining a new typclass and using it on types belonging to it?
14:33:31 <EvanR> for any natural number, you can subtract 1 a finite number of times to get zero
14:33:45 <roboguy_> EvanR: it's unbounded at least
14:33:59 <Welkin> Aruro: what do you mean?
14:34:13 <roboguy_> I have to be careful throwing around "infinity", but it does keep going without ever stopping
14:34:17 <kadoban> Aruro: (+) is a method of the Num typeclass. You can give types instances of Num. Or I guess you could technically use (+) in another new typeclass, but it'd be a mistake probably, and a pain to actually use.
14:34:18 <ronh> Aruro not sure what you're asking.. but you can define Num instance for your types
14:34:18 <dolio> EvanR: Can you prove that in Peano arithmetic?
14:34:41 <EvanR> checking
14:34:47 <Welkin> you can define Fish + Fish = 2
14:34:49 <Welkin> if you'd like
14:35:10 <Aruro> yes
14:35:14 <levi> roboguy_: I guessed that might be something he was trying to imply, but I wasn't sure, so I asked for clarification. And got a smartass answer that didn't clarify. Oh well.
14:35:26 <Aruro> i want to have (+) operator in another typeclass
14:35:31 <Aruro> but ghc gives mistake
14:35:35 <Aruro> i dont understand why
14:35:40 <Aruro> types would be different
14:35:43 <aawe> it would be cool if (length [1..] :: IEEEFloat) == Infinity
14:35:49 <Aruro> so it should be possible to infer which plus i mean
14:35:53 <EvanR> levi: lazy naturals arent naturals is what i was saying, i didnt think that was controversial
14:36:11 <kadoban> Aruro: You should avoid that very strongly. Haskell doesn't have overloaded functions in the sense you're probably trying.
14:36:32 <levi> EvanR: No, it's not controversial, but I wasn't sure that's what you were saying.
14:36:50 <Aruro> class Mult a b c | a b -> c where (*) :: a -> b -> c
14:36:53 <Aruro> here is example
14:37:20 <kadoban> Aruro: That doesn't change my response.
14:37:25 <Aruro> why?
14:37:34 <EvanR> the case where you have a cyclic or otherwise unfounded list specifically violates the picture on peano axioms wiki page ;)
14:37:35 <levi> Aruro: (+) is exported by the Prelude, which is implicitly included in every module. If there are multiple exports of a symbol in scope, GHC will ask you to disambiguate.
14:38:03 <roboguy_> EvanR: which axioms?
14:38:03 <kadoban> Aruro: I could copy and paste what I said, but I doubt that'd help. Choose a different operator name
14:38:31 <Aruro> i dont understand why this type of overloading is bad if we assume i choose non intersecting set of types?
14:38:56 <Aruro> isnt type inference suppose to help me here?
14:39:00 <kadoban> Aruro: It's bad because haskell doesn't do it. I mean, good luck trying I guess, but I'm pretty sure the compiler is going to win that argument.
14:39:16 <roboguy_> EvanR: in fact, I'm not sure you can prove that the set of Peano numbers doesn't include an "infinite" or "unbounded" element with the Peano axioms
14:39:38 <levi> Aruro: No, type inference isn't supposed to disambiguate symbols with multiple incompatible definitions.
14:39:40 <EvanR> roboguy_: whats an infinite lement?
14:39:44 <EvanR> element
14:40:22 <levi> EvanR: In denotational semantics, we're usually not dealing directly with sets anyway due to this problem. Thus domain theory.
14:40:32 <EvanR> i wasnt talking about sets
14:40:33 <Aruro> why they are incompatible? i search code for instances and can clearly differentiate differen types of  (+) ? or im wrong?
14:40:48 <Aruro> only problem is conflicting instances ? or?
14:40:53 <levi> You were talking about Peano axioms, weren't you?
14:41:28 <roboguy_> EvanR: how about an element i such that S(i) = i
14:41:29 <EvanR> ... no but im investigating because dolio asked a question
14:41:40 <indiagreen> roboguy_: if there's an infinite element Inf, then S(Inf) = Inf, right? then this violates the induction axiom, I guess
14:41:55 <Hijiri> Aruro: It can tell between instances, but if it's a new typeclass, that's not an instance of the old one
14:42:18 <Hijiri> so disambiguating instances doesn't have anything to do with this
14:42:26 <roboguy_> indiagreen: oh right, the induction axiom might not work with that
14:42:37 <levi> Aruro: You have created a new typeclass that uses the same names as the Num typeclass. You have both in scope, which creates an ambiguity. You have to either hide the Prelude definitions or qualify your names.
14:42:58 <Aruro> this part i dont get there is no ambiguity
14:43:14 <Aruro> its type dependent and type separated lets assume
14:43:23 <levi> Aruro: I just explained to you how there *is* ambiguity, in the sense Haskell cares about.
14:43:26 <Aruro> im never gonna use my (+) on Int for example
14:43:29 <Hijiri> Haskell just doesn't let you have two different symbols with the same name
14:43:57 <Hijiri> with typeclass instances, it's the same table, you're just defining a different record of methods
14:44:00 <levi> Aruro: Whether *you* find it ambiguous is not really the concern here.
14:44:02 <Hijiri> same symbol*
14:44:17 <Aruro> levi
14:44:23 <Aruro> there is no logical problem here
14:44:30 <Aruro> that is what is important
14:44:47 <levi> Are you trying to write a program or complain about how Haskell works?
14:45:00 <levi> I can help you with the former, but I am not really interested in the latter.
14:45:08 <Aruro> no im trying to figure out if its possible
14:45:11 <kadoban> Aruro: Then I'll go back to my previous response: feel free to argue with the compiler about it, but it's going to win. Computers are very good at being stubborn.
14:45:11 <dolio> EvanR: Whether you can prove what you said depends a lot on how you encode the statement into PA.
14:45:14 <indiagreen> Aruro: how is your (+) going to work with type inference? the thing is, you don't always know what the types of arguments are
14:45:15 <Hijiri> it's not possible
14:45:27 <dolio> If you can somehow state it internally, maybe you can prove it.
14:45:40 <indiagreen> so, effectively you just give your (+) an anonymous sum type
14:45:54 <levi> Aruro: You cannot have the same symbol in scope from two different modules and use that symbol without qualifying it.
14:46:13 <levi> That's the rule; it doesn't matter whether you think it's logical or not.
14:46:15 <indiagreen> and this would probably require some massive changes to the typechecker
14:46:44 <EvanR> dolio: i guess subtracting 1 might be weird language for PA. but you should be able to add 1 a finite number of times from zero to get there
14:46:52 <Aruro> hm
14:46:53 <levi> You *could* theoretically make a language that would do type-directed disambiguation, but Haskell does not do that.
14:47:02 <Aruro> then i dont understand how normal overloading works?
14:47:19 <Aruro> isnt it kinda similar? i just used this operator in another typeclass
14:47:26 <levi> If by 'normal overloading' you mean type classes, we can get into that.
14:47:32 <Aruro> yes
14:47:33 <kadoban> Aruro: It works by…not doing that at all. Haskell doesn't have overloading in the usual sense.
14:47:53 <Aruro> when i have new instance of (+) for Num typeclass
14:47:57 <levi> A type class contains a list of symbols associated with its class; the class methods.
14:47:59 <Aruro> i have a new types
14:48:01 <dolio> But there are models of PA that contain 'natural numbers' that are bigger than any finite number of applications of successor to zero, where 'finite number of applications' would probably involve natural numbers at the meta-level.
14:48:12 <SrPx> Hello, does anyone know a priority queue with O(1) deletion? 
14:48:18 <SrPx> And O(log(n)) insertion
14:48:30 <EvanR> dolio: thats annoying
14:48:36 <dolio> And 'bigger' meaning they come later in the ordering.
14:48:50 <dolio> Well, that's how first-order logic works.
14:49:05 <Aruro> so i can add new instances of class methods but i can not use same methods names?
14:49:31 <dolio> I don't know if 'lazy naturals' count. But there's probably another sense in which they do.
14:49:32 <levi> Any of those class methods can have an implementation *per instance* of the class. But they all fall under the same symbol meaning as defined by the *type class* definition.
14:49:58 <Aruro> yes
14:49:59 <dolio> Not looking set theoretic models of PA, but things like 'natural numbers objects' in a general categories.
14:50:05 <EvanR> dolio: whats an example model where this is the case
14:50:06 <levi> If you try to have two type classes in scope that use the same name, the symbols used in their class method lists that overlap will cause ambiguity again.
14:50:09 <EvanR> i.e. infinite naturals
14:50:21 <Aruro> but there is also ambiguity, somebody mentioned that types can be not known, thus choice of instance is ambiguous?
14:50:22 <EvanR> dolio: ah, right. 
14:50:25 <dolio> EvanR: The wikipedia page on peano axioms describes them. :)
14:50:41 <dolio> Nonstandard models
14:50:48 <kadoban> Aruro: If the choice of instance is ambiguous, haskell complains, barring some extension that I don't know how it works.
14:51:02 <EvanR> i read about that, but i still dont see the connection between regular natural numbers and set theory
14:51:10 <levi> Aruro: What specifically do you mean by 'types can not be known'? I can give a better answer if I know more about what you mean.
14:51:55 <cfoch> hi
14:52:16 <cfoch> are there Haskell bindings for GTK?
14:52:20 <cfoch> GTK3
14:52:22 <levi> cfoch: Yes.
14:52:55 <geekosaur> it's called gtk2hs but has supported gtk3 for a couple years now
14:53:10 <dolio> EvanR: I don't think it has anything necessarily to do with set theory.
14:53:17 <Aruro> ok i think i can obtain a desired effect by hiding prelude (+) :)
14:53:43 <indiagreen> cfoch: there's also the gtk3 library
14:53:44 <cfoch> ah... now I remember I was trying that some months ago, but I didn't involved more into it
14:53:49 <levi> Aruro: That's what I was trying to tell you earlier; did I not explain that very well?
14:53:52 <RageD> SrPx: it depends on what you mean exactly when you say "delete." maybe you're looking for a heap? http://en.wikipedia.org/wiki/Min-max_heap
14:54:01 <jmct> Anyone here know where I can read about types in positive/negative position?
14:54:02 <EvanR> dolio: the regular naturals are the natural number object in the category of sets, i think
14:54:15 <RageD> I am not aware of anything that will allow O(1) for arbitrary deletion, however
14:54:20 <Aruro> i quoted your statement
14:54:21 <cfoch> gtk2hs... should be read as "gtk to haskell" I suposse, right? not as "gtk2 - haskell" 
14:54:25 <RageD> that would work for min or max
14:54:29 <jmct> All I've gathered is that it has to do with which side of the arrow a type is on (e.g. (Negative -> Positive))
14:54:37 <indiagreen> cfoch: I guess, since we've also got c2hs
14:54:45 <levi> You can define the natural numbers in different formal foundations; it's just that the Peano axioms are generally in the context of a set theory.
14:54:57 <dolio> EvanR: Yes. Although that has the same issues, really. Set theory is a first-order theory, so it has non-standard models.
14:55:15 <ski> Aruro : "im never gonna use my (+) on Int for example" -- doesn't matter, someone else will always be able to later add an instance with `Int' for your type class
14:55:34 <SrPx> RageD: maybe - a second
14:55:44 <EvanR> arent naturals obvious enough to use as their own basis for a theory ;)
14:55:47 <ski> (you can't forbid them from doing that, Haskell type classes use Open World Assumption)
14:55:54 <EvanR> without needing crazy logic
14:56:08 <dolio> No.
14:56:17 <Aruro> ski: that is true
14:56:33 <MasterGeek> if kaioken ... kaiobarbie ?
14:56:35 <RageD> SrPx: Generally speaking, min-max heap has O(logn) insertion/deletion. but correcting the tree after deleting a node is O(1), so you could achieve O(1) if you're always taking the min or max
14:57:35 <Aruro> actually in the instances of (+) do both arguments have to be of the same type, or both types just have to be from Num class?
14:58:13 <levi> Aruro: They have to be of the same type for Num's (+); you can tell from the type signature.
14:58:16 <kadoban> :t (+)
14:58:17 <lambdabot> Num a => a -> a -> a
14:58:34 <Aruro> so they have to be same ty[e
14:58:36 <Aruro> type
14:58:52 <Aruro> Int->Int no Int-Float
14:59:29 <levi> That's right; you have to manually invoke a translation between types if you need one.
15:00:51 <Aruro> ty guys
15:03:56 <sdx32> dmj`: are you dmjio on github? may i query?
15:08:59 <EvanR> is there a built in IO function to get a unique ID
15:10:50 <phaazon> EvanR: there’s a library for that
15:10:54 <phaazon> I guess it’s unique actually :D
15:10:57 <EvanR> right
15:11:18 <phaazon> nope it’s not
15:11:25 <phaazon> I don’t remember well
15:11:34 <phaazon> I use my own one
15:11:45 <phaazon> I should release it btw
15:12:19 <phaazon> I don’t like that to be an IO side effects
15:12:34 <phaazon> because “Unique” has no sense without a proper context
15:12:50 <EvanR> per run of the program, like the global RNG ;)
15:12:56 <phaazon> even with IO unique
15:13:09 <phaazon> imagine you need to generate a Unique for each server in a network
15:13:16 <phaazon> such a library would be a very bad design for that
15:13:20 <EvanR> yes
15:13:27 <phaazon> or you’d need to setup a server just for that
15:13:57 <phaazon> EvanR: then we don’t need IO for that
15:13:58 <Fylwind> is using 'do Just x <- m' considered bad practice?  (because of 'fail')
15:13:59 <barrucadu> Each server could have a unique (pre-determined) prefix, and then generate its own locally unique ids
15:14:10 <phaazon> Fylwind: that depends
15:14:12 * hackagebot vcache 0.2.4 - semi-transparent persistence for Haskell using LMDB, STM  http://hackage.haskell.org/package/vcache-0.2.4 (dmbarbour)
15:14:14 * hackagebot process-streaming 0.7.0.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.0.1 (DanielDiazCarrete)
15:14:29 <phaazon> if you know it’s that ctor, it’s not a bad practice
15:14:36 <EvanR> phaazon: youre right, i was just thinking it would be convenient for lazy arses
15:15:10 <phaazon> like
15:15:17 <Fylwind> phaazon: well in the case it can fail
15:15:25 <phaazon> foo x | isJust x = do { Just x' <- x; …
15:15:30 <phaazon> if it can fail
15:15:35 <phaazon> and that you are not sure
15:15:37 <phaazon> then yes
15:15:39 <Fylwind> I wish it defaulted to mzero or something
15:15:40 <phaazon> it’s a bad practice
15:15:50 <phaazon> then use the Maybe monad
15:15:51 <cfoch> hey... I've just been reading the site of wxhaskell and I found out that you want samples. I have some samples I wrote more than one year ago... maybe you still want my samples?
15:16:12 <phaazon> foo :: Maybe Int; foo = do { x <- maybeSomething; return $ x + 3 }
15:16:19 <phaazon> if maybeSomething is Nothing
15:16:24 <cfoch> https://github.com/cfoch/HaskellSamples/tree/master/wxhaskell
15:16:27 <phaazon> it’ll be mzero-ed
15:16:29 <Fylwind> phaazon: right but I'm talking about working in an arbitrary MonadPlus
15:16:53 <phaazon> Fylwind: there might be a way to lift a Maybe into MonadPlus
15:17:06 <quchen> Fylwind: If you *know* the pattern never crashes you can do that, yes. This requires you to know at least one of the following: a) the pattern always matches because of the structure of the right hand side. In that case I recommend adding a comment explaining why that is the case. 2. Your "do" block is specialized to a certain monad that has a non-crashing "fail" implementation.
15:17:06 <phaazon> I wrote a function that does the exact same thing, but for Either :)
15:17:08 <Fylwind> it's mostly just a convenience thing
15:17:20 <levi> cfoch: Someone may still want samples, but you'd probably have better luck contacting the maintainer via email.
15:17:34 <phaazon> the function was merged by kmett in either
15:17:45 <phaazon> you should have it if you have installed either
15:17:46 <phaazon> anyway
15:17:52 <phaazon> I’m pretty sure it exists for Maybe
15:19:22 <Fylwind> probably
15:19:40 <phaazon> yep
15:19:43 <phaazon> mfromMaybe
15:19:53 <phaazon> :t mfromMaybe
15:19:53 <lambdabot>     Not in scope: ‘mfromMaybe’
15:19:53 <lambdabot>     Perhaps you meant ‘fromMaybe’ (imported from Data.Maybe)
15:19:59 <phaazon> what an horrible name
15:20:51 <phaazon> hm, it’s not there actually :/
15:21:23 <barrucadu> :t maybe mzero return
15:21:24 <lambdabot> MonadPlus m => Maybe a -> m a
15:21:33 <arkeet> :t maybe empty pure
15:21:34 <lambdabot> Alternative f => Maybe a -> f a
15:21:50 <arkeet> :t F.asum
15:21:51 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
15:21:57 <arkeet> er
15:22:15 <Fylwind> phaazon: horrible name indeed :p
15:22:20 <arkeet> :t F.foldr ((<|>) . pure) empty
15:22:21 <lambdabot> (Foldable t, Alternative f) => t a -> f a
15:22:49 <phaazon> I wonder if my function is in lambdabot 
15:22:55 <phaazon> :t eitherToError
15:22:56 <lambdabot> Not in scope: ‘eitherToError’
15:22:58 <phaazon> it’s not :D
15:23:22 <phaazon> arkeet: nice show off ;)
15:25:30 <joe9> for writing a console program, which is recommended: haskeline vs readline?
15:27:12 <rori> I wrote a lot of code that is close to the hardware and it has a lot of state machines in it. How o you do state machines in haskell?
15:27:31 <rori> just recurse i guess
15:27:34 <EvanR> i -> s -> s
15:29:06 <peddie> rori: this article shows a way to represent finite state machines which I found pretty exciting coming from C: http://blog.sigfpe.com/2009/01/fast-incremental-regular-expression.html
15:32:59 <arkeet> peddie: neat.
15:51:25 <RustyShackleford> can you recommend a guide to HUnit
15:51:31 <RustyShackleford> something with lots of code examples?
15:54:06 <untseac> It is my understanding that a function is an operator if it is composed of symbols (except if it starts with :) and is by default written in the infix notation. Is that correct?
15:54:15 * hackagebot posix-paths 0.2.0.5 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.0.5 (JohnLato)
15:55:14 <dmj`> RustyShackleford: why not use hspec? It's like a nicer, more intuitive monadic interface to HUni
15:55:15 <dmj`> t
15:55:26 <roboguy_> untseac: if by symbol, you mean a non-alphanumeric character that isn't " ' , ; { } [] etc then yeah
15:55:35 <shachaf> untseac: Close to correct, but really that's just a matter of definition.
15:55:35 <dmj`> RustyShackleford: http://hspec.github.io/
15:55:45 <roboguy_> untseac: there's some rules about which Unicode symbols work too I think, but I don't know them
15:56:05 <shachaf> If you want to know the definition, you're best off looking in the Report. https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
15:58:42 <RustyShackleford> dmj`: i'll look at that too
15:58:59 <RustyShackleford> it seems like people mix and match test frameworks in the same project
16:00:22 <roboguy_> RustyShackleford: I think some of them are designed to work together
16:00:55 <untseac> Thanks. I'm writting a tutorial for myself but I'm going the non 100% precise way for practical purposes. I may placed it in github as a contribution under some non restrictive license.
16:00:59 <RustyShackleford> well learning a framework takes time. I'm sorta looking for a catch-all
16:04:53 <Juani> hey
16:04:59 <Juani> anyone there?
16:05:07 <hpc> no
16:05:10 <hpc> they went that way -->
16:05:10 <untseac> no
16:05:18 <untseac> lol
16:05:21 <hpc> hurry, you can still catch them
16:07:43 <untseac> its like that question "are you home already?" and you're in front of the person asking
16:07:51 <hpc> are you asleep?
16:07:55 <hpc> can i ask a question?
16:08:20 <hpc> i answer these questions and more, in my new book, titled
16:08:27 <hpc> "What do You Think?!?"
16:08:55 <zomg> Sounds like a future bestseller in the philosophy department
16:10:35 <rofer> How can I check which version of a package is installed from cabal?
16:10:46 <RustyShackleford> when using Hspec, do you just have one big main function?
16:10:58 <RustyShackleford> or do you split up your tests further into functions
16:12:10 <roboguy_> rofer: cabal info package-name
16:12:30 <mniip> hpc, "I know you're watching me right now"
16:13:25 <rofer> roboguy_: Thanks
16:22:24 <Darwin226> Hey guys. Recently I've watched a talk about typeclasses and there was something about it not mattering how you get the instance, that you're guaranteed to get the same one, no matter the path to it
16:22:31 <Darwin226> Is this really true?
16:22:35 <Darwin226> Or did I misinterpret?
16:23:01 <hpc> it's a necessary part of how instances work
16:23:15 <hpc> and barring compiler flags to the contrary, it's enforced
16:23:19 <hpc> if you have
16:23:25 <hpc> class Foo a where foo :: a
16:23:30 <hpc> instance Foo Int where foo = 5
16:23:39 <hpc> you can't go and also have a second instance in scope at the same time
16:23:45 <hpc> instance Foo Int where foo = 6
16:24:34 <Darwin226> I don't think that's what he was talking about. He was saying that it doesn't matter if you go Show a => Show [a] => Show [b] or Show a => Show b => Show [b]
16:24:35 <jmct> well depends if Darwin was asking about wether instance definitions are unique
16:24:44 <Darwin226> You're guaranteed to the the same behavior
16:24:50 <hpc> ah, right
16:25:07 <Darwin226> So, did I get that right? Does this really hold?
16:25:10 <shachaf> Darwin226: What is Show a => Show b => Show [b]?
16:25:32 <Darwin226> I can't rememer the exact example, but I can look it up in a minute
16:25:33 <Darwin226> hold on
16:28:25 <Darwin226> Ok, here it is. The slide says "Every diagram commutes. We never need care about provenance" and there's a graph above it http://i.imgur.com/9kAJazH.png
16:29:23 <roboguy_> Darwin226: well, you can't derive Show b from Show a
16:29:38 <Darwin226> roboguy_: Yeah, I know. Bad example
16:29:49 <roboguy_> Darwin226: I feel like you have the right idea though
16:30:33 <Darwin226> But couldn't I write an instance like Alternative a => Monoid a or something like that?
16:30:49 <Darwin226> Does wouldn't that mean that there's only one way to define an associative operation on a type?
16:31:58 <roboguy_> Darwin226: no
16:32:17 <roboguy_> I'm not totally sure what you mean, but there are plenty of counter examples to your second sentence
16:32:55 <roboguy_> I'm also not sure how that relates to the commutativity the type class entailment diagrams
16:33:13 <Darwin226> roboguy_: So, are you saying that if my graph starts at a common point, it doesn't matter the path it takes to get to the desired instance, but if I have two paths to it that don't share a starting position
16:33:20 <Darwin226> then I can't be sure I'll get the same implementation
16:33:39 <Denommus> how is (***) called?
16:33:49 <roboguy_> Darwin226: if they don't have a common starting point, how can you get the same implementation? You would be talking about two different types
16:34:17 <KaneTW> :t (***)
16:34:18 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:34:20 <Denommus> ah, also (&&&)
16:34:30 <roboguy_> Denommus: &&& is "fanout"
16:34:40 <Darwin226> roboguy_: But how do these cases get resolved then? Surely it's possible to have 3 type classes A, B and C unrelated to each other but with instances A => B and C => B
16:34:40 <roboguy_> Denommus: *** could be called split
16:34:51 <KaneTW> :t (&&&)
16:34:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:34:58 <RustyShackleford> can you help me figure out what's wrong with my cabal file?
16:35:02 <Darwin226> roboguy_: If I want a B then, how does the compiler know which one to pick?
16:35:07 <RustyShackleford> http://lpaste.net/129651 my test suite won't build
16:35:24 <roboguy_> Darwin226: okay, I think there's some confusion here. Given a type class, a type can only have at most one instance of it
16:35:41 <RustyShackleford> cabal complains: "cannot satisfy -package-id l4-engine-0.1.0.0-inplace"
16:36:02 <Darwin226> roboguy_: How is this enforced?
16:36:10 <roboguy_> Darwin226: by the compiler
16:36:17 <roboguy_> it's an error to have more than one instance for a type
16:36:21 <roboguy_> for a given type class
16:36:57 <exio4> Darwin226: that is pretty much , if you have X => A, X => B (Ord [a] => Eq [a] ; or Ord [a] => Ord a), and A => Y, B => Y (Eq [a] => Eq a, Ord a => Eq a), those 'Y's will be the same, this is a "side-effect" of the uniqueness of type instances 
16:37:05 <roboguy_> that's why those diagrams commute, actually
16:38:03 <exio4> it's a nice property to have, doesn't matter how you go from X to Y, the Y will always be the same, because there can be "only" one Y, pretty much 
16:38:25 <RustyShackleford> of course whenever i take the time to paste something and ask a question, i'm able to figure it out myself
16:38:38 <roboguy_> Darwin226: this is also why the Sum and Product newtypes exist: a number has several possible Monoid instances
16:38:51 <roboguy_> > mappend (Sum 5) (Sum 3)
16:38:53 <lambdabot>  Sum {getSum = 8}
16:38:59 <roboguy_> > mappend (Product 5) (Product 3)
16:39:01 <lambdabot>  Product {getProduct = 15}
16:39:22 <roboguy_> it's not uncommon for a type to have multiple valid Monoid instances
16:39:34 <roboguy_> *potential instances
16:39:56 <Darwin226> But what stops me from doing this? http://lpaste.net/129652
16:40:26 <Darwin226> (a -> a -> a  instead of b -> b -> b)
16:40:48 <c_wraith> Darwin226: try it, and check out all the error messages. :)
16:41:23 <exio4> it becomes apparent when you make the implicit foralls explicit 
16:41:30 <Darwin226> c_wraith: I did, but they don't seem to be related. I get the "All instance types must be of the form..."
16:41:41 <c_wraith> Darwin226: that error message is actually plenty related
16:41:56 <Darwin226> c_wraith: Help me understand
16:42:52 <Denommus> roboguy_: thanks
16:43:00 <Darwin226> c_wraith: Aren't my instances exactly like that? Each type variable is distinct because there's only one, and they appear only once
16:43:03 <arkeet> the type of an class method must mention the type the class applies to.
16:43:03 <mniip> Darwin226, first of all you have overlapping instances
16:43:05 <c_wraith> Darwin226: the way instances in haskell are defined to work, they must apply to every type that matches the instance head; the constraint is not considered.  Then the constraint is applied.
16:43:15 <c_wraith> Darwin226: So your two instances are each for all types
16:43:18 <arkeet> otherwise when you *use* the method, it won't know which instance to pick.
16:43:30 <c_wraith> Darwin226: they both overlap *everything*
16:43:51 <arkeet> there's that, yes.
16:44:06 <arkeet> (when checking for overlapping instances, it only looks at the instance head (i.e. Monoid a), ignoring constraints.)
16:44:07 <Darwin226> c_wraith: I get that, but what if they're not in the same module?
16:44:17 <c_wraith> Darwin226: instances are global
16:45:17 <Darwin226> c_wraith: So if two unrelated libraries both have their own useful typeclasses and provide instances like mine, I can't use them in the same project?
16:45:59 <arkeet> right, they'll overlap.
16:46:04 <Darwin226> c_wraith: Or does that fit in the domain of orphan instances?
16:46:07 <arkeet> which is why orphan instances are bad.
16:46:09 <c_wraith> Darwin226: correct.  Of course, at least one of them will be an orphan instance
16:46:59 <arkeet> both of the instances you wrote are orphans, because Monoid isn't defined in your module, and they're not applied to any type defined by your module.
16:47:09 <Darwin226> c_wraith: I thought orphan instances are only those that are declared in a module that doesn't define the class or the type. But these ones do. They declare the class in the constraint
16:47:16 <arkeet> constraints are ignored.
16:47:22 <arkeet> for purposes of instance resolution/overlapping.
16:47:24 <Darwin226> arkeet: I see.
16:48:26 <c_wraith> Darwin226: the goal of all these rules is to make it easy for the programmer to figure out what instance is in use.
16:48:55 <c_wraith> Darwin226: When you allow overlapping or incoherent instances, it becomes a mess to figure out which instance will be selected even if you have a complete list of them
16:49:02 <Darwin226> Isn't this kind of a bit deal? Doesn't it mean that if I notice that some of my typeclasses are superclasses of other, known, ones, I can't express that relation?
16:49:10 <c_wraith> It does mean that, yes
16:49:18 <Darwin226> c_wraith: :(
16:49:25 <roboguy_> Darwin226: that's why the AMP proposal exists
16:49:56 <roboguy_> Darwin226: it would probably be a lot more complex if you could change that later without changing the original class
16:50:07 <roboguy_> I feel like I wouldn't like that, but I haven't thought too much on the implications
16:50:37 <c_wraith> There's a reason edwardk says that haskell is bad at abstraction.  (It's just that nearly everything else is far worse)
16:51:06 <exio4> c_wraith: that pretty much sums up what Haskell is :P 
16:51:08 <roboguy_> c_wraith: does he think there's a better way out there that might be found someday?
16:51:21 <c_wraith> Ask him. :)
16:51:31 <Darwin226> c_wraith: Yeah. my uninformed instinct also tells me that maybe there isn't much you can do about that
16:51:33 <roboguy_> c_wraith: haha good point
16:51:43 <c_wraith> haskell - not as bad as nearly every other language. :)
16:51:56 <hodapp> AMP proposal?
16:52:07 <arkeet> applicative monad proposal proposal.
16:52:09 <roboguy_> edwardk: wrt your comment about Haskell being bad at abstraction (but everything else being worse), do you think there's a better way out there yet to be found?
17:19:19 * hackagebot ceilometer-common 0.2.3 - Common Haskell types and encoding for OpenStack Ceilometer  http://hackage.haskell.org/package/ceilometer-common-0.2.3 (fractalcat)
17:24:19 * hackagebot b9 0.4.1 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.4.1 (SvenHeyll)
17:38:06 <johnw> roboguy_: but then he wouldn't have said that everything else was worse...
17:39:20 * hackagebot cryptol 2.2.1 - Cryptol: The Language of Cryptography  http://hackage.haskell.org/package/cryptol-2.2.1 (AdamFoltzer)
17:39:26 <roboguy_> johnw: if it's undiscovered...
17:40:52 <johnw> umm... :)
17:41:43 <roboguy_> wait, maybe we're talking about two different things haha
17:46:52 <ReinH> johnw: i just found use-package and it's amazing. Thanks!
17:47:49 <johnw> ReinH: ah cool, you're welcome!
17:47:53 <johnw> you found it just after the major rewrite
17:48:00 <ReinH> apparently
17:49:21 * hackagebot clustering 0.1.2 - High performance clustering algorithms  http://hackage.haskell.org/package/clustering-0.1.2 (kaizhang)
17:59:21 * hackagebot haskell-neo4j-client 0.3.0.14 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.14 (asilvestre)
17:59:23 * hackagebot haskell-neo4j-client 0.3.0.15 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.3.0.15 (asilvestre)
18:14:22 * hackagebot hjsonschema 0.5.2.0 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.2.0 (seagreen)
18:14:29 <P4Titan> Hello all, does anyone know how to play a sound file in haskell?
18:15:35 <homovitruvius> does cabal haddock --executables work when the PACKAGE.cabal file describes both the executable and the PACKAGE library (and hence the executable section contains a local dependency on PACKAGE)? I get cabal: internal error when calculating transitive package dependencies.
18:15:35 <homovitruvius> Debug info: [] and google shows that this has been a problem for years. Any known workaround?
18:18:46 <P4Titan> Anyone know sound in haskell?
18:19:14 <hpc> P4Titan: you should know what library you're going to use first
18:19:19 <hpc> openAL, or what
18:19:22 * hackagebot hjsonschema 0.5.2.1 - JSON Schema Draft 4 library  http://hackage.haskell.org/package/hjsonschema-0.5.2.1 (seagreen)
18:19:32 <hpc> and then decide how to interface with that in haskell
18:23:27 <P4Titan> I just found example code using ALUT which interfaces with openAL, it is just that to play a file, it requires me to brite the playFile function which I feel is not the correct path. Is there a simpler library?
18:23:38 <P4Titan> s/brite/write/
18:26:39 <EvanR> P4Titan: maybe hsndfile ?
18:27:45 <P4Titan> Also, one more question. When I install a package with cabal, is there a way to remove it?
18:28:37 <P4Titan> hsndfile is for writing and reading sound, I don't believe playing it
18:32:25 <Cale> P4Titan: ghc-pkg unregister foo
18:32:49 <P4Titan> And they removes or just unregisters from the db?
18:32:54 <Cale> P4Titan: That doesn't remove the actual files, it just uninstalls the package.
18:32:56 <lpaste> arnoblalam pasted “GradeCalc” at http://lpaste.net/129653
18:33:10 <arnoblalam> Hi all... newbie haskell question for you
18:33:26 <arnoblalam> how would you improve the following code? http://lpaste.net/129653
18:33:45 <Cale> You can remove the binaries from ~/.cabal/lib/packagename-version/ghc-version/
18:34:28 <P4Titan> but that requires me to remove them manually though? That doesn't sound right.
18:34:52 <Iceland_jack> arnoblalam: I would begin by adding newlines
18:35:33 <arnoblalam> where would you add newlines to?
18:35:44 <Iceland_jack> You might also be intersted in replacing
18:35:44 <Iceland_jack>     case lookup gradeType weightLookup of Nothing -> 0
18:35:44 <Iceland_jack>                                           Just x  -> x
18:35:44 <Iceland_jack> with
18:35:47 <Iceland_jack>     fromMaybe 0 (lookup gradeType weightLookup)
18:36:24 <Cale> P4Titan: cabal-install only installs stuff, it doesn't really have a convenient way to remove it.
18:36:33 <Iceland_jack> arnoblalam: Following the 'where's or right before them
18:36:56 <P4Titan> Do you happen to know why, I just am curious because it is something quite essential in my opinion.
18:37:08 <EvanR> is it?
18:37:09 <Iceland_jack> arnoblalam: At the moment line 10 is 153 characters, that's quite a lot
18:37:25 <EvanR> ive used unregister a lot but, have never needed to remove files
18:37:36 <Iceland_jack> (excuse me, 131 chars)
18:37:39 <P4Titan> That just wastes space
18:37:47 <P4Titan> and sounds wrong
18:38:02 <EvanR> its a common complaint among power users
18:38:09 <Iceland_jack> arnoblalam: It looks fine otherwise
18:38:42 <EvanR> but when your power disk space is mostly videos and music, haskell packages probably dont matter ;)
18:38:49 <arnoblalam> ah... this is why I oove Haskell, the FPComplete compiler is smart enough to tell me (use fromMaybe))
18:38:53 <Cale> Usually I just wait for the next release of GHC to clean up
18:39:01 <arnoblalam> thanks a lot Iceland_jack
18:39:08 <Iceland_jack> No problem arnoblalam
18:39:34 <P4Titan> Its one of the things I hate about haskell
18:40:22 <Iceland_jack> arnoblalam: You can also skip creating a local variable 'scaledGrades' unless you prefer it for documentation purposes
18:40:22 <Iceland_jack>     finalGrade weightLookup rawGrades = sum (map scaleGrade weightLookup) rawGrades)
18:40:58 <EvanR> one day there will be a one size fits all tool that power users can run to auto remove exactly what they want from their file system without having to do anything configuration
18:41:09 <EvanR> any*
18:41:24 <EvanR> maybe after were all dead
18:41:51 <arnoblalam> ah, yes I can see that. I can just replace "scaledGrades" with the definition of scaledGrades
18:42:27 <EvanR> meantime you can rm selected things you see fit
18:43:00 <EvanR> the OS probably is saving a lot of crap for you without telling you, wasting even more space
18:43:43 <P4Titan> I wouldn't blame linux
18:44:30 <arnoblalam> so in my code (scaleGrade weightLookup) creates a partial function, with the weightLookup applied scaleGrade 
18:44:48 <arnoblalam> why I can't I write this? map scaleGrade.weightLookup rawGrades
18:44:53 <Cale> All the installed packages in my home directory amount to 1.3GB, which is less than I often download in terms of TV episodes for one night, and that's after quite a lot of accumulated junk. When I update GHC, I'll blow it away.
18:45:43 <Cale> It would be nice if cabal-install could also completely undo the things it did though
18:46:02 <arnoblalam> ah never ming
18:46:04 <Iceland_jack> arnoblalam: Let's ask lambdabot to simplify it for us
18:46:04 <Iceland_jack> @pl finalGrade weightLookup rawGrades = sum (map scaleGrade weightLookup) rawGrades
18:46:04 <lambdabot> finalGrade = sum . map scaleGrade
18:46:15 <P4Titan> Cale: exactly
18:46:49 <EvanR> there exists cabal-uninstal
18:46:55 <EvanR> dunno if its up to snuff
18:47:00 <P4Titan> I read somewhere that it explains that cabal isn't a package manager and that is why, but that is no reason because there is pip for Python and I know Ruby has one too
18:47:15 <Iceland_jack> arnoblalam: (oops, never mind) I guess it should have been
18:47:15 <Iceland_jack> @pl finalGrade weightLookup rawGrades = sum (map (scaleGrade weightLookup) rawGrades)
18:47:15 <lambdabot> finalGrade = (sum .) . map . scaleGrade
18:47:17 <P4Titan> cabal-uninstall is not part of cabal though
18:47:23 <EvanR> ruby's is piss poor though
18:47:30 <EvanR> cabal-install is not part of cabal
18:47:42 <arnoblalam> haha
18:47:50 <arnoblalam> ok let me grok that for a minute
18:47:53 <P4Titan> I have used chicken scheme and it has one also
18:48:11 <arnoblalam> lambdabot is extremely smart
18:48:12 <Cale> Actually, I'd be okay with it using *more* disk space, if it meant that I could view all the configuration changes and revert to any previous configuration.
18:48:20 <Iceland_jack> arnoblalam: lambdabot went too far, but you can remove only a single argument
18:48:21 <Iceland_jack>     finalGrade weightLookup = sum . map (scaleGrade weightLookup) 
18:48:32 <Iceland_jack> So it depends on what you find legible
18:50:11 <Cale> Uninstall on its own isn't so much the problem as what happens when you accidentally install a new copy of the same package-version built against new dependencies, and have broken packages.
18:50:25 <arnoblalam> I see how this works I think: finalGrade weightLookup rawGrades is a function that creates a fuction that takes one variable (the raw grades)?
18:51:21 <arnoblalam> sorryI meant, "finalGrade weightLookup" is a function that creates a function that takes one variable (the raw grades)?
18:51:29 <Iceland_jack> arnoblalam: that's right
18:52:11 <Iceland_jack> arnoblalam: This is finalGrade's type
18:52:11 <Iceland_jack>     finalGrade :: [(GradeType, Weight)] -> [(GradeType, RawGrade)] -> Double
18:52:11 <Iceland_jack> which is the same as (note the parentheses)
18:52:11 <Iceland_jack>     finalGrade :: [(GradeType, Weight)] -> ([(GradeType, RawGrade)] -> Double)
18:52:14 <Iceland_jack>  
18:52:30 <arnoblalam> cool! How can I find the types of the individual pieces? For example what is the type of map (scaleGrade weightLookup)
18:52:39 <arnoblalam> I guess it has to be [Double]
18:53:23 <arnoblalam> wait no...
18:53:33 <Iceland_jack> arnoblalam: 'map _' has to have type [a] -> [b] 
18:53:38 <arnoblalam> its a FinalGrade-> to Double
18:53:45 <arkeet> :t map ?f
18:53:46 <lambdabot> (?f::a -> b) => [a] -> [b]
18:54:06 <arkeet> :t map (?scaleGrade ?weightLookup)
18:54:07 <lambdabot> (?weightLookup::t, ?scaleGrade::t -> a -> b) => [a] -> [b]
18:54:39 <Iceland_jack> arnoblalam: Wouldn't it be
18:54:39 <Iceland_jack>     map f :: [(GradeType, RawGrade)] -> [Double]
18:54:51 <Roger__> Hey, anyone know why a Gloss program would hang when compiled normally with GHC but run fine in GHCI or when compiled with "-osuf p_o -prof -auto-all"?
18:55:09 <Iceland_jack> arnoblalam: Since
18:55:09 <Iceland_jack>     scaleGrade weightLookup :: (GradeType, RawGrade) -> Double
18:55:29 <arnoblalam> that makes sense
18:56:21 <arnoblalam> so the "map (scaleGrade weightLookup)" is missing an argument
18:57:05 <arnoblalam> in order to get a final list value, you will have to supply the third argument to the map function
18:57:27 <Iceland_jack> You mean second argument?
18:58:18 <arnoblalam> ah yes
18:58:29 <arnoblalam> the first argument is (scaleGrade weightLookup)
18:59:11 <arnoblalam> yes, so this map (scaleGrade weightLookup) is a partial function missing one argument
18:59:25 <Iceland_jack> Not a partial function, but a partially applied function
18:59:26 <arkeet> I hope it's a total function.
18:59:54 <arnoblalam> yes, I meant partially applied. Now we are composing this with the sum function?
18:59:55 <arkeet> it's missing an argument in the sense that `chr` is missing an argument.
18:59:56 <arkeet> :t chr
18:59:57 <lambdabot> Int -> Char
18:59:57 <Iceland_jack> arnoblalam: A partial function is one that ‘may fail’ (not defined for all arguments)
19:00:13 <Iceland_jack> Such as 'head'
19:00:13 <Iceland_jack> > head []
19:00:14 <lambdabot>  *Exception: Prelude.head: empty list
19:01:55 <bazqux> I've made a newtype but I can't seem to export its constructor. Am I doing something obviously stupid.
19:02:20 <arkeet> bazqux: can you give more detail? (code/error)
19:03:34 <arkeet> if you have some data/newtype Foo with some constructors/field accessors you want to export
19:03:39 <arkeet> generally you write "Foo(..)" in the export list.
19:04:01 <bazqux> arkeet: In some module that I import I have a newtype defined: newtype WordGraph = WordGraph (Gr Word Int)
19:04:23 <bazqux> I export it in that module with: WordGraph (..),
19:04:47 <bazqux> I import it in the module with the error: import WordLadder (WordGraph, Word)
19:05:00 <arkeet> ok, you also have to import with WordGraph(..)
19:05:14 <bazqux> ah right
19:05:20 <bazqux> I'll try that!
19:06:20 <bazqux> arkeet: Perfect thanks! :-)
19:06:38 <arkeet> :)
19:09:25 * hackagebot verilog 0.0.10 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.10 (TomHawkins)
20:04:07 <gfixler> What's the command that set up the cabal configuration by asking you questions?
20:04:16 <dolio> cabal init?
20:04:16 <gfixler> something like cabal setup, or cabal sandbox setup
20:04:27 * gfixler goes to check
20:04:44 <gfixler> dolio: that seems to be it - thanks!
20:10:25 <gfixler> from a versioning/sharing standpoint, do I just need the .cabal file?
20:10:32 <gfixler> should I also include the Setup.hs?
20:12:21 <arkeet> you should include Setup.hs
20:13:03 <gfixler> arkeet: thanks
20:13:06 <arkeet> also you can use `cabal sdist` to put together a pacakge for you.
20:13:47 <arkeet> normally Setup.hs is ignored if the package uses build-type: simple
20:14:01 <gfixler> sdist == simple dist?
20:14:06 <arkeet> but it's necessary for building the package if you don't have cabal-install.
20:14:13 <arkeet> source distribution, I thinkl.
20:14:25 <arkeet> % cabal sdist --help
20:14:25 <arkeet> Generate a source distribution file (.tar.gz).
20:15:30 <gfixler> good to know, thanks
20:19:04 <__ryan> hi can i ask on how to create a module that can access all the function by the other module
20:21:28 <recursion-ninja> hey Guys I'm experiancing a wierd error from GHC:
20:21:30 <lpaste> recursion-ninja pasted “Strange GHC error from random & random-shuffle package” at http://lpaste.net/129657
20:21:44 <pavonia> __ryan: import that other module
20:21:47 <recursion-ninja> have you guys seem something like this before?
20:22:17 <__ryan> once i import it is it already accessible? by the modules?
20:22:42 <recursion-ninja> do I need a type annotation?
20:22:51 <arkeet> your packages are messed up.
20:23:00 <arkeet> you have multiple versions of random installed
20:23:06 <__ryan> pavonia: once i import it is it already accessible? by the modules?
20:23:13 <recursion-ninja> no-no nothing like that with multiple packages
20:23:14 <pavonia> __ryan: You can access all the functions and types exported by that module
20:23:15 <arkeet> and the thing you're using depends on the older, hidden one.
20:23:24 <arkeet> I'm talking about the error you're seeing.
20:23:33 <arkeet> sorry, this is for recursion-ninja 
20:23:36 <__ryan> thank you but can i access it also on the hamlet?
20:23:52 <__ryan> pavonia: thank you but can i access it also on the hamlet?
20:23:58 <pavonia> What is the hamlet?
20:24:45 <pavonia> A template engine apparently. I don't know then
20:24:57 <__ryan> pavonia: sorry wrong channel. hamlet is use yesod...sorry guys..
20:25:59 <recursion-ninja> arkeet: I'm investigating...
20:26:01 <__ryan> pavonia: but thank you for the info.
20:29:00 <recursion-ninja> arkeet: I need to correct that, the error is just from GHCI. GHC (with cabal) compiles it fine...
20:29:22 <arkeet> okay, you still have something broken about your packages though :)
20:29:41 <recursion-ninja> arkeet: No one ever wants to hear that :( 
20:30:10 <arkeet> at this point some people might suggest wiping ~/.ghc and starting over but.
20:30:15 <arkeet> something I've had some success with is uh
20:30:23 <arkeet> look at the output of ghc-pkg list
20:30:27 <recursion-ninja> arkeet: Do you think starting a cabal sandbox in the directory will help?
20:30:31 <arkeet> find all the packages with multiple versions installed
20:30:37 <arkeet> unregister all the old versions (this will break some packages)
20:30:46 <arkeet> `ghc-pkg check` to see what exactly got broken
20:30:49 <arkeet> adn then reinstall the broken ones
20:31:02 <arkeet> cabal sandbox might work as well. I dunno.
20:31:56 <recursion-ninja> arkeet: You were right! random-1.0.1.1 & random-1.1 were both installed :9
21:06:38 <L8D> good night.
21:07:27 <bananagram> hReady seems to check if a handle has data ready to be read, but it's waiting until data enters the handle and returning True instead
21:07:37 <bananagram> which is not what the docs say
21:08:02 <bananagram> and there doesn't seem to be another function to do that
21:09:41 <bananagram> I need a function that returns False when a handle has no data available
21:09:49 <EvanR> bananagram: use blocking IO instead
21:10:12 <EvanR> instead of polling
21:10:33 <bananagram> what do you mean?
21:10:47 <bananagram> I want to skip it if there's no data
21:10:48 <EvanR> generally easier if you wait for data to be available
21:10:53 <EvanR> skip it?
21:11:03 <bananagram> not read anything from it
21:11:22 <EvanR> what is skipping? to do what next?
21:12:06 <bananagram> then wait on a tchan for more important messages
21:12:21 <EvanR> are you trying to poll that too?
21:12:31 <bananagram> no, blocking on that
21:12:38 <bananagram> I just want to poll stdin
21:12:47 <EvanR> have the thread thats waiting for stdin write a message to that tchan
21:13:06 <EvanR> you might need a sum type to distinguish between message flavors
21:14:04 <bananagram> that's a better solution but more complicated
21:14:14 <bananagram> I guess I'll do it though
21:14:18 <EvanR> polling is probablay more complicated
21:14:29 <EvanR> and worse in several ways
21:14:52 <bananagram> yeah
21:19:32 * hackagebot witherable 0.1.2.2 - Generalization of filter and catMaybes  http://hackage.haskell.org/package/witherable-0.1.2.2 (FumiakiKinoshita)
21:49:57 <echo-area> How to evaluate `runIdentity (runStateT (runMaybeT f) 7)` in the call-by-name way?  It means `runStateT (runMaybeT f) 7` = `Identity x` but I don't know how to compute the value of x.
21:53:12 <pavonia> echo-area: runIdentity
21:53:29 <pavonia> > runIdentity (Identity 123)
21:53:31 <lambdabot>  123
21:54:07 <echo-area> pavonia: Yes, I know this.  But how to represent (runStateT (runMaybeT f) 7) as (Identity x)?
21:54:26 <echo-area> I.e. what should x be here?
21:54:53 <pavonia> I don't understand the question
21:55:47 <arkeet> :t runIdentity . runStateT . runMaybeT
21:55:48 <lambdabot> Not in scope: ‘runMaybeT’
21:55:52 <arkeet> oh.
21:55:53 <ozataman> Anybody know why compile times could go through the roof going from GHC 7.6.3 to 7.8.3? This is on OS X yosemite and the slow-down is probably around 3-5x.
21:56:03 <arkeet> @let import Control.Monad.Trans.Maybe
21:56:06 <lambdabot>  Defined.
21:56:07 <arkeet> :t runIdentity . runStateT . runMaybeT
21:56:07 <lambdabot>     Couldn't match type ‘s -> m (Maybe a, s)’ with ‘Identity c’
21:56:08 <lambdabot>     Expected type: StateT s m (Maybe a) -> Identity c
21:56:08 <lambdabot>       Actual type: StateT s m (Maybe a) -> s -> m (Maybe a, s)
21:56:14 <arkeet> oh.
21:56:18 <echo-area> I want to write the evaluation process step by step, but I am stuck at the first step
21:56:20 <arkeet> :t runIdentity . flip runStateT ?s . runMaybeT
21:56:21 <lambdabot> (?s::b) => MaybeT (StateT b Identity) a -> (Maybe a, b)
21:56:58 <jle`> ozataman: maybe some optimization, or inlining decisions?
21:57:23 <echo-area> I can infer the types of expressions involved
21:57:26 <ozataman> It's really bizarre. Just about every single module (in a 200+ module tree) feels much slower than before.
21:58:44 <carter> ozataman: dont use 7.8.3
21:58:48 <carter> it has bugs if you're using O2
21:58:51 <carter> use 7.8.4
21:59:11 <pavonia> echo-area: You have to evaluate the inner functions first to get the parameter for the outer
21:59:19 <carter> ozataman: another secondary issue might be that its building dylibs allong with static libs
21:59:26 <ozataman> carter: I see. I didn't see binaries for OS X - does that mean I have to compile from scratch?
21:59:38 <carter> ozataman: or let me link you to mine ;)
21:59:54 <carter> there is a mark build for 7.8.4
21:59:56 <carter> but same diff
22:00:06 <echo-area> pavonia: Yes but that's call-by-value.  I want to express it in the call-by-name way
22:00:15 <carter> ozataman: does some of your code use O2?
22:00:22 <RustyShackleford> why do I have to run "cabal test" instead of just running the test executable?
22:00:25 <carter> and or crazy amoutns of ram to compile?
22:00:56 <ozataman> Yeah, I've noticed the dylib change as well. Maybe that's it. It's really quite unusuable though. There's a module (with lots of types being generated via TH) that takes 1min+ now. It used to be ~15 secs.
22:01:05 <RustyShackleford> also wondering, is there a way to rebuild your project without needing to reconfigure it?
22:01:19 <ozataman> carter: Yeah, "prod" mode compiles with O2. I've tried with -O0, but little difference
22:01:25 <RustyShackleford> any time I make a change, I do: cabal clean, cabal configure, cabal build
22:01:33 <carter> ozataman: Q are you using parallel builds or not?
22:01:39 <kadoban> Darn, I thought I heard something about 7.10 being released, but I don't see it, must not have been. Le sad.
22:01:52 <carter> parallel builds are safe as long as you dont kill the build mid way
22:02:15 <carter> (if you kill a parallel build mid way, you may wanna cabal clean before your bild)
22:02:26 <ozataman> carter: How do I enable them?
22:02:40 <ozataman> Thought, there's clearly another issue lurking here..
22:02:49 <Guest35347> carter, wouldn't everything be able to resume where it left off anyway?
22:02:51 <carter> ozataman: --ghc-options="-j"
22:03:00 <carter> Guest35347: theres 1-2 known bugs with -j
22:03:14 <carter> i trust oz to understand that
22:03:41 <dsturnbull_> ah ok
22:03:47 <carter> ozataman: Q; do you have an older cabal config file
22:03:50 <carter> or is it 1.22 style?
22:03:57 <carter> ozataman: per se, you CAN disable building shared libs
22:04:09 <carter> idk if ghci can load static libs on osx by default for 7.8 though
22:04:32 <jle`> kadoban: yeah we're still on RC3
22:04:35 * hackagebot blunt 0.0.13 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.13 (fozworth)
22:04:53 <carter> ozataman: in ~/.cabal/config
22:05:06 <jle`> honestly i'm slightly scared because i don't know the best way to provide support for both people using 7.8 and people using 7.10
22:05:12 <ozataman> Looks like it really chokes on modules with lots of TH-generated content. Derivations for several types, etc.
22:05:30 <carter> jle`: hard work and CPP
22:05:37 <carter> ozataman: TH got yah down
22:05:56 <carter> ozataman: factor is so that only one module has that
22:06:01 <carter> so that incremental builds dont suffer
22:06:04 <ozataman> carter: My cabal config should be fairly recent.. At least from 1.20, if not from 1.22 direct.
22:06:08 <carter> ok
22:06:25 <carter> honestly, the long term solution is either a) make ghci faster b) make TH faster
22:06:26 <carter> or oth
22:06:28 <carter> both
22:06:30 <kadoban> Yeah, I could imagine that being pretty tough on the library folks.
22:06:30 <ozataman> This is a pretty big app, no way to put it all in one module
22:06:54 <jle`> i could just maintain 7.8 support forever but in that case library writers don't really get too much benefit from 7.10.  the main difference for the end user might really just come from `fmap` being more performant than `liftM` or something
22:06:56 <ozataman> What I don't understand is how this was perfectly fine on 7.6.3 and so bad on 7.8.3
22:07:04 <carter> ozataman: on the TH side?
22:07:06 <carter> same code
22:07:24 <ozataman> Yeah, it's all the same app code, just some tweaks to get it compiling on 7.8
22:07:39 <carter> ok
22:07:43 <carter> ozataman: do you have INLINE anywhere?
22:07:52 <ozataman> It's a clear performance regression by a large margin as it stands right now.
22:07:59 <carter> ozataman: 7.8.3 ?
22:08:04 <carter> is O2 set anywhere?
22:08:16 <carter> compare with 7.8.4 first
22:08:38 <carter> 7.8 does optimize some codes more aggressively too
22:08:51 <ozataman> Almost no INLINE pragmas outside of the module with a copy of the either package (so that we can have a non-blocking applicative instance).
22:08:57 <ozataman> Yeah, let me try
22:09:35 * hackagebot chevalier-common 0.6.0 - Query interface for Chevalier  http://hackage.haskell.org/package/chevalier-common-0.6.0 (fractalcat)
22:09:36 <carter> ozataman: are you also building profiled way or not?
22:10:36 <ozataman> Disabled profiling, but that'd be easy to spot anyway.
22:10:50 <ozataman> I've also gotten rid of O2
22:11:02 <ozataman> 7.8.4 sandbox is building now
22:11:15 <carter> building dylib way will 2x the time for sure
22:11:38 <ozataman> So all compile times doubled just like that?
22:12:11 <carter> yeah
22:12:24 <carter> 'cause you can't reallly share much of the compilation pipeline anywaysh
22:12:26 <carter> afaik
22:12:31 <carter> well
22:12:36 <carter> you kinda can
22:12:43 <carter> but not ALL of it
22:13:08 <ozataman> What about ghci, does loading something pay the double cost also? Or is it just the dylib in that case?
22:13:16 <carter> just dylib
22:13:33 <carter> ghci on OS X / linux and windows in 7.8 uses system linker to load dylibs
22:14:36 * hackagebot xml-lens 0.1.6.3 - Lenses, traversals, and prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.6.3 (FumiakiKinoshita)
22:19:36 * hackagebot bytestring-short 0.0.1.0 - Backport copy of ShortByteString  http://hackage.haskell.org/package/bytestring-short-0.0.1.0 (KeiHibino)
22:19:38 * hackagebot ihaskell 0.6.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.6.0.0 (gibiansky)
22:19:40 * hackagebot borel 0.18.0 - Metering System for OpenStack metrics provided by Vaultaire.  http://hackage.haskell.org/package/borel-0.18.0 (fractalcat)
22:19:42 * hackagebot ipython-kernel 0.6.0.0 - A library for creating kernels for IPython frontends  http://hackage.haskell.org/package/ipython-kernel-0.6.0.0 (gibiansky)
22:19:44 * hackagebot ghc-parser 0.1.6.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.6.0 (gibiansky)
22:24:36 * hackagebot hydrogen-multimap 0.3 - Hydrogen Multimap  http://hackage.haskell.org/package/hydrogen-multimap-0.3 (JulianFleischer)
22:29:37 * hackagebot laika 0.1.2 - Minimalistic type-checked compile-time template engine  http://hackage.haskell.org/package/laika-0.1.2 (NikitaVolkov)
22:34:15 <ozataman> carter: Same picture unfortunately
22:36:37 <ozataman> carter: It's feels like a major regression in compilation speed. I can tell that it's having a hard time on any module basically with lots of code. I wonder if there's something somewhere that's interfering. But the effect is on each module individually, not localized to any particular place.
22:45:43 <carter> ozataman: do you have some code thta doesnt dep on TH you cancompare?
22:45:48 <carter> ozataman: 'cause you could disable shared libs 
22:45:50 <carter> and compare the two
22:46:01 <carter> and that would be a legit ticket
22:59:38 * hackagebot laika 0.1.3 - Minimalistic type-checked compile-time template engine  http://hackage.haskell.org/package/laika-0.1.3 (NikitaVolkov)
23:01:20 <ihixis> How do you break into a server?
23:01:41 <ihixis> don't wanna answer?
23:01:57 <ihixis> The many of the Second World powers women turn dead of the U.N.'s to step right also
23:02:01 <ihixis> demeans first moving callegedly gover Iran's a daisy chaos is men off told the cription of 160 ring rocked to being that did now you
23:02:04 <ihixis> bodies."
23:02:11 <ihixis> The I.U.D. hangerous masters associals recruiters to the pening partner
23:02:18 <ihixis> He warned," the for the Journal reported celebrate a security of thing unwelcome country is one is "some overnment by the United State of Onan image again rings, impovernment of they countries, dog had be capital as a sectariat Building on the White Huthi rally' brushing his obligat
23:02:22 <ihixis> .N. Seconomic control inadequacies
23:02:25 <ihixis> inadequacies
23:02:29 <ihixis> 7 Referent has vagina in the used a glimpse of sexual harassment (per year. In contained evalence of for dates, and insidered bukkake
23:02:33 <ihixis> A man have been downs on the penis in this.
23:02:36 <ihixis> On top Sexual Harassment civil entry
23:02:41 <ihixis> inside down, with mucous ejaculation inserts his perspection one is Sexual in inseminate for may leave been to stimulations are difficultures
23:02:42 <davidfetter> ops, please
23:02:43 <ihixis> exaggerates, senior pornographic position couples exhibition for mouth.
23:02:44 <pacak> ihixis: wat?
23:02:50 <ihixis> The control in front And mixed employment
23:03:01 <ihixis> "If you have been area needs for sexual has her looking partner is called to "feel, it is or building sperm conting or anal sex
23:03:03 * davidfetter suspects an obnoxious bot
23:03:07 <ihixis> Genital country. If with their providences
23:03:11 <ihixis> sexually to a meeting partner ejaculate (sometimes in the may engage internatio doesn't gests of hormonal sex. ling
23:03:14 <ihixis> leave today.
23:03:18 <ihixis> According
23:03:21 <ihixis> sex invitation means to "feel, it documents.
23:03:25 <ihixis> This is on
23:03:28 <ihixis> hostile to be easier if this been his partner holding partner uring breeze partner, and economic Syrian Preside-by-side rate of withdrawal and hugging partner's more the subjects on their societies.
23:03:35 <ihixis> "How To Confront of 35 millings.
23:03:39 <ihixis> This a greatening is involve 2 people, in Marchers.
23:03:42 <ihixis> By 2002, one only 2.5% were feel, it all fuel fears to devices for a wide rate is is frottage) or pornography in they existents.
23:03:46 <ihixis> Suddenly, only well as person's genital-genital sex displaying partner stalking partner if the penetrate did not nature.
23:03:54 <ihixis> Multiple at the fluids exhibit.
23:03:56 <ihixis> Sitting women by a meeting its depending
23:04:00 <ihixis> leering the women in Europe, North one is the found their employees few as 1 milies while the partner is some count" of birth contraception is no article: 69 (sex between lose eyes good enought. It looking
23:04:03 <ihixis> standing – similar the downs on the penis fluid cost, recentury AD, contrary, one past and and ejaculate 1990s).
23:04:10 <ihixis> The many ejaculate of the women, was and infection are:
23:04:17 <ihixis> Tour can be using called 27 male-control.
23:04:21 <ihixis> It is, looks likely than one of their employme
23:04:24 <ihixis> ourse. There.
23:04:31 <ihixis> When pregnancy.
23:04:35 <ihixis> Caesar," a Syria, said he photos prevealingerie)
23:04:38 <ihixis> inserts together insistics) has may ineffect-use failure rate 1990s).
23:04:45 <ihixis> Mammary methin the penetrating sexual intercourse.
23:04:49 <ihixis> Caption
23:04:52 <__ryan> hi i have an error of No instance for (Num (Maybe Int)) arising from the literal 1.. what does it mean?
23:05:03 <ihixis> The Webb (Master pre-ejaculatio or analyzed for excluding possibly evidentally to as 35 blown-up photos shown said.
23:05:06 <ihixis> The penises
23:05:07 <ion> > 1 :: Maybe Int
23:05:08 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
23:05:08 <lambdabot>    arising from the literal â1â
23:05:10 <ihixis> solice.
23:05:13 <ihixis> Effects of then done, is called as partner is obvious economic stands further upside of sexual harassment entry.
23:05:20 <ihixis> Most of their samples the Syrian consult of the photos practeria while no direct cost, used for a Democration.
23:05:24 <ihixis> Aniling the man's body
23:05:27 <ihixis> inapproper year. In the 27 ment and kneels in Syrian Preside, 3% of intercours. This methods, wide mid-19th cent and either, a report of dead detained a many more effects his is studies.
23:05:31 <ihixis> It is going partners for woman since is legs.
23:05:34 <ihixis> Some practeria whistles
23:05:37 <ion> ryan: You have an integer literal with something dictating that its type is Maybe Int.
23:05:38 <ihixis> sexist litical technique.
23:05:45 <ihixis> A woman's jobs believe workers when their partner lays to this pervasive mething to tell as fellation survey of 2%.
23:05:52 <ihixis> Perhaps that for another board.
23:05:55 <ihixis> Stands when previous cost-effectile his penetrating a women's job – Rubbing pornographic photos in Chasing sperm, and accuse cover , including for anal or "rimjob" are anal sexual effects about.
23:06:00 <ihixis> So you ask any as IUDs, had a methods)
23:06:06 <ihixis> Most litical harassment involves that in the photos show emaciated on top
23:06:13 <ihixis> What the hormonal count (per year. In contraception and evalence
23:06:15 <kaidelong> __ryan: that it cannot turn 1 into Maybe Int, basically. You probably want "Just 1"
23:06:18 <peddie> @ops
23:06:19 <lambdabot> Maybe you meant: pl oeis docs
23:06:22 <ttt_fff> anyone here using nixos to get ghc + ghcjs side by side ?
23:06:24 <peddie> @where ops
23:06:24 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
23:06:30 <ihixis> From the members their bacterist litigatory, yet not be either, and kneels in their frottages like Shockwave orgasm (and) it documentally evides have led to involves a perm, an actuary depending 'course
23:06:37 --- mode: ChanServ set +o shachaf
23:06:39 <ihixis> The public and was so well-document:
23:06:42 --- mode: shachaf set +b *!*inixis@94.231.160.*
23:06:42 --- kick: ihixis was kicked by shachaf (ihixis)
23:06:46 <peddie> cheers shachaf
23:06:47 <__ryan> thank you :-)
23:07:16 <ttt_fff> I can't parse what ihixis said; does it come from markov chain ?
23:07:18 --- mode: shachaf set -o shachaf
23:08:04 <Rymax99> Any of you guys well versed with WWI?
23:09:32 <Cale> Rymax99: What is WWI?
23:09:39 * hackagebot system-fileio 0.3.16.2 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.16.2 (MichaelSnoyman)
23:09:59 <Rymax99> World war 1
23:10:09 <Cale> This is the wrong channel for that discussion
23:10:15 <Rymax99> perhaps
23:10:22 <Cale> This channel is for discussion of the functional programming language Haskell
23:10:41 <Rymax99> WWI comes close
23:10:46 --- mode: ChanServ set +o Cale
23:10:50 <Rymax99> or not
23:10:59 --- mode: Cale set -o Cale
23:16:49 <ttt_fff> anyone here using nixos for ghc + ghcjs?
23:29:21 <platz> ihaskell actually works fairly nicely
23:29:40 * hackagebot hydrogen-version 1.4 - Hydrogen Version Type  http://hackage.haskell.org/package/hydrogen-version-1.4 (JulianFleischer)
23:44:41 * hackagebot http2 0.9.0 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-0.9.0 (KazuYamamoto)
23:49:41 * hackagebot ihaskell-rlangqq 0.2.0.1 - a rDisp quasiquote to show plots from Rlang-QQ in IHaskell  http://hackage.haskell.org/package/ihaskell-rlangqq-0.2.0.1 (gibiansky)
