00:00:34 <carter> wz1000: 7.10  + cabal 1.22has some stuff
00:00:53 <carter> so youcan per se try itout  with the ghc 7.10 RCs
00:22:19 <pingu> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
00:30:04 <pingu> ?
01:06:48 <Xnuk> > repeat 'x
01:06:50 <lambdabot>  Syntax error on 'x
01:06:50 <lambdabot>  Perhaps you intended to use TemplateHaskell
01:15:58 <pingu> Apologies for the outburst of x's before. My cat broke in.
01:17:43 <xacktm> lol, I find it funny the cat typed '?' xD
01:18:29 <forgottenone> how can i use a rational as an exponent?
01:19:25 <kaidelong> @instances RealFloat
01:19:26 <lambdabot> Double, Float
01:19:31 <kaidelong> mmm
01:19:42 <kaidelong> @type (**)
01:19:44 <lambdabot> Floating a => a -> a -> a
01:19:52 <kaidelong> @instances Floating
01:19:53 <lambdabot> Double, Float
01:19:59 <kaidelong> so that is not overloaded
01:20:09 <kaidelong> @type (^)
01:20:10 <lambdabot> (Num a, Integral b) => a -> b -> a
01:20:34 <talw> Hi everyone! Is it possible to derive this instance? instance (MonadTrans IO ())
01:20:51 <kaidelong> forgottenone I am wondering if what you want to do even makes sense
01:21:05 <talw> I have a type that
01:21:06 <kaidelong> exponentiation is not closed under the rational numbers
01:21:46 <talw> rather than creating a type with 2 type parameters and imlementing instance of MonadTrans, my type already has 2 specific types for those would-be type parameters
01:21:53 <forgottenone> kaidelong i see
01:23:25 <talw> I'm getting an error that MonadTrans is applied to too many arguments. I've tried reading up on GHC's extensions, overlappingInstances and flexibleInstances, but  I can't get them to help me
01:23:47 <forgottenone> kaidelong i am trying to produce pi sequence with list comprehension so i wrote something like this: pi' a = take a [1^x/(2*x+1)|x<-[0..]::[Rational]] , so x will be a integer value always
01:23:59 <pingu> xacktm: yeah that's quite impressive now that I think about it. Requires shift.
01:24:29 <kaidelong> so then the real problem is, x cannot in fact be a Rational
01:24:34 <kaidelong> but that's okay, look at ^'s type
01:24:41 <kaidelong> ^ can work with arguments of different types
01:24:49 <kaidelong> @type (^)
01:24:51 <lambdabot> (Num a, Integral b) => a -> b -> a
01:25:03 <pingu> There's also ^^ if you want an integral
01:25:06 <kaidelong> so you could move your type signature to 1 and 2
01:25:20 <kaidelong> oh well
01:25:32 <kaidelong> I see, the second uses x
01:25:36 <kaidelong> with *
01:25:37 <kaidelong> but
01:25:42 <kaidelong> you can use fromIntegral there
01:25:48 <kaidelong> fromIntegral(2*x+1)
01:25:49 <talw> oh I think i understood my mistake! I should imlpement MonadIO instance instead
01:26:48 <forgottenone> kaidelong thanks 
01:26:55 <kaidelong> @type [(1::Rational)^x/fromIntegral(2*x+1)|x<-[0..]]
01:26:56 <lambdabot> [Rational]
01:27:01 <kaidelong> that typechecks
01:27:17 <kaidelong> > [(1::Rational)^x/fromIntegral(2*x+1)|x<-[0..]]
01:27:18 <lambdabot>  [1 % 1,1 % 3,1 % 5,1 % 7,1 % 9,1 % 11,1 % 13,1 % 15,1 % 17,1 % 19,1 % 21,1 %...
01:28:15 <kaidelong> as a rule the fromIntegral should be distributed outward as far as possible when casting to rationals because operations on rationals are expensive
01:28:41 <talw> aka I should derive it automatically
01:29:27 <kaidelong> so perhaps, mm
01:29:48 <forgottenone> kaidelong is there any implicit conversation in haskell , i mean after i say that 1 is rational, do i have to convert denumerator also?
01:29:56 <kaidelong> > [1 % 2*x+1 | x<-[0..]]
01:29:57 <lambdabot>  [1 % 1,3 % 2,2 % 1,5 % 2,3 % 1,7 % 2,4 % 1,9 % 2,5 % 1,11 % 2,6 % 1,13 % 2,7...
01:30:05 <kaidelong> this version is better in every way
01:30:25 <kaidelong> no, Haskell does no implicit conversions whatsoever
01:30:31 <kaidelong> this was an intentional design decision
01:30:41 <kaidelong> compare OCaml, and (strangely enough) Perl
01:31:12 <forgottenone> kaidelong i see there is no exception
01:31:35 <onub0> what's no1 resource to grasp functors, applicatives, monoids, etc.?
01:32:01 <kaidelong> LYAH and RWH both have pretty decent sections on them but the general rule is, except for monoids, don't
01:32:07 <onub0> got through 6 chapters in learn you for good, but further, it looks like too complex
01:32:19 <kaidelong> it's okay to understand how <|> and <*> work on say, parsec specifically
01:32:24 <kaidelong> you don't have to understand applicatives
01:33:05 <onub0> are they rarely used or very simple ?
01:33:23 <kaidelong> they're very simple, used all the time, but they're abstract in the general case
01:33:38 <kaidelong> you build intuitions for abstract concepts by working with specific example
01:34:00 <onub0> what can be a good source of examples to look up?
01:34:09 <onub0> in your opinion
01:34:49 <kaidelong> have you worked with Parsec yet
01:35:26 <onub0> no, not yet, started doing path from stack overflow post, 99 haskell problems, and it has some solutions in there
01:35:55 <onub0> thanks, will look into parsek
01:36:50 <onub0> and is it worth maybe to go from category theory? or it is too abstract
01:37:11 <kaidelong> if you're just looking to learn Haskell, don't bother with category theory
01:37:13 <onub0> there is "the joy of cats", but too severe for me so far
01:37:19 <onub0> ok
01:37:38 <kaidelong> the basics you need to know you will already learn just learning Haskell and you probably already know (laws for (.) and id)
01:37:53 <onub0> cause read somewhere that haskell constantly gets ideas from the cats theory
01:38:02 <kaidelong> the main boon you get for knowing it better is having some better understanding of terminology like "monad" or "natural transformation"
01:38:40 <kaidelong> yes largely by historical accident when Moggi figured out an algebraic structure for effectful programs
01:39:06 <kaidelong> although OCaml has deep roots in category theory in its implementation that IIRC predate haskell
01:39:13 <kaidelong> so there was precedent
01:40:07 <onub0> ok, that maybe explains why they use ML in coursera course for programming languages
01:40:24 <kaidelong> ML is just a traditional language for teaching the functional language paradigm
01:40:55 <kaidelong> CaML was an effort to make an ML implementation using concepts from category theory to work with things called abstract machines
01:41:21 <kaidelong> OCaml is the modern survivor of CaML like systems
01:42:10 <kaidelong> Usually I find that programming language courses uses SML of some kind, especially SML/NJ
01:42:15 <kaidelong> it's not really related to CaML
01:43:03 <onub0> I'm from java background, but unfortunately no haskell level language
01:43:06 <onub0> in jvm
01:43:12 <kaidelong> well, there is Frege
01:43:37 <kaidelong> although I wonder what the merits of Frege are since it does not seem to have very good java interoperation
01:43:48 <onub0> some issues with java security to freely manipulate stack and hence not easy implement e.g. tail recursion optimisation
01:44:20 <onub0> from popular languages what we have, just clojure and scala
01:44:25 <kaidelong> well, Microsoft managed it with their .NET bytecode and that has bytecode level security checks too
01:45:42 <kaidelong> maybe there was a security tradeoff but TCO is fundamentally a simple optomization so I would think they could figure something out for java if they put in the effort
01:48:13 <f|`-`|f> as far as I know
01:48:33 <f|`-`|f> Haskell is the consolidation of multiple seperate panels developing lazy fls
01:48:43 <f|`-`|f> to prevent the usual explosion
01:48:47 <f|`-`|f> it somewhat wored
02:25:44 <nocturne777> could someone help me understand this:  runWriter $ Writer(20, ["Got Number " ++ show 20]) >>= \x -> Writer(15, ["Got Number " ++ show 15]) >>= \y -> return (x*y)
02:26:00 <nocturne777> I was expecting that it would return (300,[])
02:26:01 <jle`> nocturne777: what are you having problems with?
02:26:07 * hackagebot current-locale 0.2.0.0 - Get the current system locale in System.Locale format  http://hackage.haskell.org/package/current-locale-0.2.0.0 (AlexeyKotlyarov)
02:26:09 * hackagebot current-locale 0.2.0.1 - Get the current system locale in System.Locale format  http://hackage.haskell.org/package/current-locale-0.2.0.1 (AlexeyKotlyarov)
02:26:14 <nocturne777> but what it returns is (300,["Got Number 20","Got Number 15"])
02:26:40 <jle`> the >>= instance mconcat's all of the logging terms
02:27:00 <jle`> so your logging terms are ["got number 20"], ["got number 15"], and []
02:27:15 <jle`> > mconcat [["got number 20"], ["got number 15"], []]
02:27:17 <lambdabot>  ["got number 20","got number 15"]
02:27:40 <jle`> you can see this mappending behavior in the instnace for (>>=)
02:27:45 <jle`> er, the definition
02:28:16 <nocturne777> jle`: I am looking at the definition of the writer monad here: http://learnyouahaskell.com/for-a-few-monads-more
02:28:32 <nocturne777> there's no mconcat there
02:28:38 <nocturne777> there's mappend
02:28:38 <jle`> well, it's mappend
02:28:41 <jle`> mappend on each element
02:28:44 <jle`> so technically it would be
02:29:00 <jle`> > ["got number 20"] `mappend` ["got number 15"] `mappend` []
02:29:02 <lambdabot>  ["got number 20","got number 15"]
02:29:23 <jle`> "mconcat" is just a synonym for "mappending everything" heh, sorry.
02:30:16 <nocturne777> jle`: I guess what I am unable to do in my head is the substitution in this case
02:30:34 <jle`> then do it on paper and pencil :)
02:30:51 <jle`> always also fun
02:31:13 <jle`> if we get rid of the newtype wrapper,
02:31:26 <nocturne777> jle`: mostly I do as you suggested, but in this case I could not do it either ahah
02:31:41 <nocturne777> couldn't figure out on paper..
02:31:45 <jle`> (x, l1) >>= f = let (y, l2) = f x in (y, l1 `mappend` l2)
02:31:59 <jle`> so let's try
02:32:22 <jle`> (20, ["got 20"]) >>= (\x -> (15, ["got 15"]))
02:32:34 <jle`> expanding out the definition....
02:33:07 <nocturne777> 20 gets substituted into x
02:33:24 <jle`> let (y, l2) = (15, ["got 15"]) in (y, ["got 20"] `mappend` l2)
02:33:31 <jle`> y = 15, l2 = ["got 15"]
02:33:47 <jle`> (15, ["got 20"] `mappend` ["got 15"])
02:33:55 <jle`> (15, ["got 20", "got 15"])
02:34:20 <rola> oh my goodness, i finally read more of the typeclassopedia and this cleared a bit up after looking for something that corresponds to bind  > return, fmap, and join correspond η, T, and μ
02:34:44 <jle`> the intuition is... "the result is the same as if you only cared about the first item.  and the logging term is the accumualted mappends of everything you have seen so far"
02:35:09 <jle`> so your function really is applying 20 to (\x -> 15)
02:35:13 <jle`> > (\x -> 15) 20
02:35:14 <lambdabot>  15
02:35:29 <jle`> so the answer is just 15.  and your log term is the mappending of every log you've seen so far
02:35:38 <jle`> which is ["got 20"] and ["got 15"]
02:35:46 <jle`> rola: nice :D
02:36:42 <jle`> we can try doing out the whole thing by hand if you wanted nocturne777 
02:37:19 <nocturne777> jle`: let me digest this example first :)
02:38:00 <jle`> (20, ["20"]) >>= (  \x -> ( (15, ["15"]) >>= \y ->  (x*y, [])  )  )
02:38:02 <jle`> mk
02:40:01 <dpwright_> Is there a Data.Vector.Storable concatenation function which can combine a Vector of Vectors? `concat` has the type signature "Storable a => [Vector a] -> Vector a"; I'm looking for "Storable a => Vector (Vector a) -> Vector a"
02:40:33 <dpwright_> I can see how that wouldn't be possible because "Vector a" isn't itself Storable
02:41:05 <dpwright_> but I'm not sure what the best approach is.  Except not to use Storable Vector and just use Vector instead
02:43:08 <jle`> depending on what you are doing you can use a flattened vector the entire time
02:45:15 <dpwright_> I have four vectors and I am trying to interleave them.  so I have "zipWith4 combine ps cs uvs ns" where combine unpacks the data from each of the things it's passed, and spits out a list, vector, whatever, of the unpacked data
02:46:05 <dpwright_> this is for a blog post I'm writing on the gl library, so the data is vertex data
02:46:44 <dpwright_> combine looks like this: "combine (V3 x y z) (V3 r g b) (V2 u v) (V3 nx ny nz) = [x, y, z, r, g, b, u, v, nx, ny, nz]"
02:47:30 <dpwright_> I am using OverloadedLists so the type of that varies with the type signature
02:47:30 <dpwright_> I think perhaps I need to use unfoldr to generate a new Storable Vector in this case
02:49:37 <dpwright_> I already had the code lying around using the OpenGL library, but using lists.  Since gl is a little lower-level, I thought I'd try doing it with Data.Vector.Storable instead
02:54:49 <nocturne777> jle`: I understand how mappend works
02:55:22 <nocturne777> jle`: what I am unable to do right now in that definition of Writer monad is the substitituion for f
02:55:34 <nocturne777>  Writer(20, ["Got Number " ++ show 20]) >>= \x -> Writer(15, ["Got Number " ++ show 15]) >>= \y -> return (x*y)
02:55:42 <nocturne777>  x = 20
02:55:42 <nocturne777>  v = ["Got Number " ++ show 20]
02:55:58 <nocturne777>  f = \20 -> Writer(15, ["Got Number " ++ show 15]) >>= \y -> return (20*y)
02:58:31 <jle`> nocturne777: so f is the function itself, before you apply it
02:59:14 <jle`> f = \x -> Writer (15, ["Got Number 15"]) >>= (\y -> Writer (x*y, []))
02:59:52 <jle`> f x = Writer (15, ["Got Number 15"]) >>= (\y -> Writer (20*y, []))
03:01:50 <jle`> and your answer is the result of that, with ["Got number 20"] mappended to the log of that
03:03:24 <octatoan> hey
03:06:18 <dpwright_> ok, I think I've come to the conclusion: If I want to use Data.Vector.Storable the only reasonable way to do it is to use `create` and initialise the vector imperatively.  The fiddling involved in doing otherwise negates any benefit of using Data.Vector.Storable in the first place
03:06:36 <nocturne777> jle`: I was able to do it on the paper this time
03:06:37 <dpwright_> so I'm just going to switch back to Data.Vector for an easier life for now
03:07:22 <jle`> octatoan: hi!
03:07:26 <jle`> nocturne777: congrats :)
03:07:43 <jle`> dpwright_: yeah, that's true
03:07:46 <nocturne777> (300, ["Got Number 15"] `mappend` [])
03:08:40 <nocturne777> then  (300 ["Got Number 20"] `mappend` ["Got Number 15"])
03:09:02 <octatoan> Has anyone here tried reading through Bartosz Milewski's post series on category theory? It's pretty fun!
03:11:02 <jle`> octatoan: yes, it's quite a lot of fun :)
03:11:14 <jle`> it's been a real pleasure
03:33:28 <bobajett> in ghci, when I type: print 1; I get print applied to 1 and see 1 printed to the screen.
03:33:36 <bobajett> When I type: map print [1,2,3], Im thinking I get a list of lazily applied print functions.
03:34:18 <bobajett> without using mapM, how do I (apply?) those lazy functions to get 1 2 3 printed to the screen?
03:42:50 <jle`> bobajett: you are actually getting a list of IO actions that represent printing strings :)
03:42:59 <jle`> anyways hoogle should help you here
03:43:05 <jle`> @hoogle [IO ()] -> IO ()
03:43:08 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
03:43:08 <lambdabot> Test.QuickCheck.Test safely :: State -> IO () -> IO ()
03:43:08 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
03:43:10 <jle`> hm
03:43:18 <jle`> @hoogle [IO a] -> IO ()
03:43:19 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
03:43:19 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
03:43:19 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
03:43:26 <jle`> sequence_
03:43:36 <m0rphism> bobajett: mapM f is basically sequence_ . fmap f, so you could use sequence_
03:43:54 <jle`> sequence_ takes a list of IO actions and returns an IO action that represents doing all of those actions in order, one after the other
03:44:02 <m0rphism> sry meant mapM_ f
04:03:23 <dron2065> Hello. Are there somebody who used Network.FastCGI? I have a question about it.
04:09:55 <breadmonster> Hey guys!
04:10:08 <SCHAAP137> hello
04:10:20 <Azel> dron2065: I never have but ask away. Perhaps we'll be able to help you nonetheless.
04:11:12 * hackagebot not-gloss 0.7.2.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.2.0 (GregHorn)
04:13:38 <dron2065> Azel: Ok. If I want create remote fastcgi server using haskell, how to specify listen port? No one func at Network.FastCGI doesn't take a TCP port as parameter.
04:31:13 * hackagebot not-gloss 0.7.2.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.2.1 (GregHorn)
04:33:29 <Azel> The FastCGI protocol being a way (like CGI) for web servers to offload processing of some requests to externals programs, I'd gather that to be in your webservers' config, not your CGI program's.
04:38:48 <Azel> After all, as far as the CGI (or FastCGI, in that they're the same) program is concerned, the request is coming from his standard input, not from a network socket.
04:39:21 <dron2065> Azel: CGI use stdin and stdout. With FastCGI web server and script can work separately, using TCP/IP and Unix sockets for communicating. Information about port or socket must be on every side (one - to listen, other - to call listening port, right?)
04:42:07 <ibid> fa
04:42:44 <ibid> dron2065: what i understand of the fastcgi protocol, from the script's side the socket is always stdin
04:43:07 <ibid> dron2065: the server may create a unix or tcp/ip socket as it chooses
04:44:18 <mrkkrp> Hi, can you recommend good (up to date) tutorial to learn Quick Check?
04:47:59 <absence> if i run "cabal run +RTS --help" it's the cabal executable itself that reports the RTS help. to pass RTS options to the target executable, i'm supposed to run "cabal run -- +RTS --help" instead, but it just runs the program as if no RTS options were given
04:52:18 <absence> cabal run -v confirms that the rts flags are not included on the target exe's command line
04:52:18 <adamse> absence: did you compile with rtsopts?
04:52:38 <absence> adamse: it works if i invoke the executable directly instead of via cabal run
04:52:53 <absence> so the problem seems to be that the options aren't passed along
04:53:17 <adamse> perhaps it is a bug then
04:53:38 <absence> "cabal run -- something +RTS --help" runs the executable with only the "something" parameter
04:53:42 <absence> i guess
05:08:57 <absence> if i set library-profiling to true in the main cabal config, will sandboxes inherit that?
05:26:16 * hackagebot boundingboxes 0.2.3 - A generic boundingbox for an arbitrary vector  http://hackage.haskell.org/package/boundingboxes-0.2.3 (FumiakiKinoshita)
05:26:18 * hackagebot eigen 1.1.1 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers, and related algorithms).  http://hackage.haskell.org/package/eigen-1.1.1 (OlegSidorkin)
05:36:16 <absence> trying to debug a space leak, and using the -hd flag it says the <main:Main.sat_sb1r> constructor is the problem. but there's no such thing in my code :)
05:37:35 <randir> What's everyone's favorite haskell web server?
05:38:00 <randir> Just looking for something really simple right now that serves paths
05:40:26 <bennofs> randir: something like scotty?
05:41:06 <hpc> different ones are for different purposes
05:41:16 * hackagebot eigen 1.1.2 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.1.2 (OlegSidorkin)
05:41:20 <zipper> Can I override the arguments that a typeclass method takes?
05:41:22 <hpc> you're pretty much asking what everyone's favorite application of webservers is
05:41:29 <zipper> e.g I want to make a monoid instance but...
05:41:29 <raek> absence: I have found -hy (by type) and -hc (by cost center) more useful (but I am a heap profiling noob myself)
05:41:42 <randir> fair enough
05:41:44 <zipper> For example I want mempty to take arguments.
05:41:51 <randir> I'm looking for something simple, for personal use
05:42:08 <randir> I've had a few recommended before, but forget their names.
05:43:27 <randir> Just want something that pretty statically, securely serves some files in a particular directory, with supporting some basic coding/redirection based off of form input
05:43:38 <raek> my approach so far has been to try all the -h flags one by one and see which one gives the most useful output... (https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/prof-heap.html)
05:43:47 <bennofs> zipper: no, that is the whole point of typeclasses, that the types of their members are fixed. Say you had a function f :: Monoid m => (m -> a) -> a; f g = g mempty. What would happen to that function if you applied it with some monoid where you overwrote mempty to take arguments?
05:44:29 <bennofs> -hc and -hy are the most useful, IMO
05:47:46 <randir> any examples for my own really basic webserver?
05:48:34 <randir> Something that serves files in a directory, securely (i.e., no being able to ../secretInfo.txt out of the given dir)
05:55:21 <mr-> 1Hier krieg ich immer so krass viel geschafft an einem Tag, sogar noch mehr als meine horrenden Pläne sogar
05:55:30 <mr-> oh, sorry
05:56:25 <raek> randir: In Haskell I don't know, but in Python there's "python -m SimpleHTTPServer"
05:56:48 <randir> raek: Yeah, I've been using that, but want to migrate to Haskell. Thanks though :) 
05:56:56 <randir> I found "Hakyll", looks perfect for what I want.
05:57:30 <bennofs> randir: hakyll is a static site generator, not a webserver
05:58:07 <randir> yeah, but I can run it on top of a simple server
06:02:04 <steprane> is it possible to iterate over bits in a ByteString ? In a code kata, I need to do things for each bits wether thery are 0 or 1 ? Also is it possible to have the content of ByteString as hexadecimal in a String ?
06:03:01 <absence> raek, bennofs: yeah, just a bit stuck and trying everything :)
06:08:46 <absence> Data.Vector.Vector is strict?
06:08:53 <mniip> steprane, 
06:10:49 <mniip> steprane, something like
06:10:52 <bennofs> absence: I think it's not strict in its elements (unboxed vectors are strict through)
06:10:59 <mniip> concatMap (\x -> map (testBit x) [0..7]) $ BS.unpack "hello"
06:12:49 <steprane> @mniip i'm going to look at it, thx
06:12:49 <lambdabot> Unknown command, try @list
06:14:13 <bennofs> absence: V.fromList [undefined, undefined] `seq` 3
06:14:23 <bennofs> absence: prints 3, so no, it's not strict
06:14:42 <absence> bennofs: i see, that might explain a few things. thanks!
06:16:22 <breadmonster> Is there a good reference on how to write a parser by hand?
06:16:27 <breadmonster> Like from scratch?
06:23:22 <notdan> breadmonster: without using parsec/attoparsec?
06:23:40 <breadmonster> notdan: Yup.
06:23:46 <breadmonster> I'm also open to using C/Python.
06:23:56 <notdan> well
06:24:18 <notdan> http://www.amazon.com/Compilers-Principles-Techniques-Tools-Edition/dp/0321486811 ?
06:24:35 <randir> Anyone here have experience with Snap?
06:24:51 <notdan> I mean, parsing and lexing is not that easy on the very basic fundamental level
06:25:35 <breadmonster> notdan: Argh, I didn't want to have to read the Dragon Book, but okay.
06:25:37 <breadmonster> Thanks (:
06:27:22 <jophish> I'm using hxt to parse some html, and want to represent failure in parsing. For example I have a function "parseVersion :: String -> Maybe Version" and I'd like to lift this failure into the ArrowXml. I've not relly grokked arrows yet, any hints on how to represent this using ArrowXml. 
06:27:55 <jophish> I know of inhibiting arrows in Netwire, perhaps something like that
06:28:26 <notdan> breadmonster: I guess it depends on your goal
06:29:06 <breadmonster> notdan: I wanna learn how parsers work. Parsec seems far too magical for me.
06:29:37 <breadmonster> I'm really interested in CS, so it's nice to get a chance to look under the parse function.
06:30:43 <notdan> If you want to learn about parser combinator specifically I can advise taking a look at http://research.microsoft.com/pubs/65201/parsec-paper-letter.pdf and the papers referenced in there
06:33:51 <hlidutysileh> did usa covertly supply isis with weapons like they did with al-qaeda to justify creating wars?
06:33:52 <hlidutysileh> did usa excute the creative mess in the middle east like they said they will, does the creative mess include explosion
06:33:52 <hlidutysileh>  with uncertain responsibles to create wars?
06:33:58 --- mode: ChanServ set +o geekosaur
06:34:18 --- mode: geekosaur set +b *!*@197.195.141.154
06:34:20 --- kick: hlidutysileh was kicked by geekosaur (hlidutysileh)
06:34:50 --- mode: geekosaur set -o geekosaur
06:35:04 <hodapp> well, that was silly.
06:35:14 <notdan> jeez
06:35:24 <hodapp> the answer's probably "yes", but this is #haskell
06:36:19 * hackagebot al 0.1.1.3 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.1.3 (DimitriSabadie)
06:36:21 <notdan> Damn, I really wanna do Haskell GSoC
06:36:24 <notdan> but no time
06:36:26 <notdan> not even close
06:37:01 <notdan> The SoC starts way before my finals and ends after the start of the year
06:37:54 <arbelos> Is there a truly immutable data structure that one could use to implement a "dictionary" for a LP solver? I mean, mutability is fine but then it feels like I might as well implement it in C and expose an interface to Haskell via FFI
06:38:44 <arbelos> This is not for a real-world application of course, just an exercise
06:39:29 <mniip> arbelos, all boxed objects are immutable
06:39:52 <EvanR> .oO( mutable arrays ...)
06:39:57 <mniip> do you want something that cannot be cloned?
06:40:17 <mniip> EvanR, which onez
06:40:19 <mniip> ones
06:40:26 <arbelos> well, the dictionary is typically going through tons of iterations.. so
06:40:28 <EvanR> all of them, the arrays themselves are boxed
06:40:43 <EvanR> well the reference to them
06:40:43 <arbelos> what does boxing have to do with it?
06:40:51 <EvanR> nothing
06:40:56 <mniip> EvanR, I don't think there's any that don't use both # stuff and IO
06:41:08 <EvanR> they do, im nitpicking on your comment
06:41:13 <mniip> s/both/neither/
06:41:18 <mniip> er
06:41:28 <mniip> s/don't use both/use neither/
06:41:31 <EvanR> the array isnt unboxed, the items in them are
06:42:31 <arbelos> i imagine a typical LP solver in Haskell is using a C implementation or something with mutable structures "underneath"
06:42:32 <EvanR> arbelos: does the algorithm call for a mutable array?
06:42:38 <bennofs> arbelos: there are immutable and mutable arrays / vectors (vector, array package)
06:43:31 <koomi> all of (ghc) haskell is using a C implementation with mutable structures underneath
06:44:16 <EvanR> IntMap is a fast immuable dictionary type
06:44:20 <EvanR> for Ints
06:44:56 <arbelos> EvanR: yes that would definitely be a candidate
06:45:29 <EvanR> still using mutable stuff in haskell might be easier than mucking with the ffi
06:45:30 <koomi> if your keys aren't Ints you can use Data.HashMap.{Strict,Lazy}
06:45:38 <hodapp> bah. I should just use Data.Colour's affineCombo/blend/over/darken/dissolve/atop instead of blending in HSL because I like how it looks
06:45:52 <koomi> if you really need the performance (profile!), there are mutable variants
06:45:54 <breadmonster> notdan: You're Aussie?
06:46:14 <notdan> breadmonster: nope
06:48:47 <breadmonster> notdan: May I PM?
06:48:54 <notdan> sure
06:48:57 <notdan> /w 35
06:49:01 <notdan> erm sorry
06:51:01 <fizruk> arbelos: does LP solver make use or parallel computations (I'm just not sure)? if you need to run multiple solvers in parallel on modifications of a dictionary, immutable data structures should be a perfect fit to reuse a common part of the dictionary
06:53:46 <arbelos> fizruk: the parallel solvers i know of usually just return the result from the instance that "finishes first". but maybe there are more clever algorithms
06:55:30 <arbelos> right now, i'm just looking at implementing a standard simplex algorithm
06:59:26 <EvanR> hmm. how do you do a floor :: Double -> Double
06:59:41 <EvanR> realToFrac . floor gives a warning about defaulting to Integer
07:02:53 <fizruk> :t fromInteger . floor
07:02:54 <lambdabot> (RealFrac a, Num c) => a -> c
07:03:27 <EvanR> thanks that fixed the warning
07:03:38 <EvanR> now im paranoid about converting to Integer first ;)
07:03:41 * EvanR ignores
07:04:33 <mniip> EvanR, is creating a ~1024-bit integer a performance issue to you?
07:05:17 <EvanR> the operation im doing is double floor(double)
07:05:30 <EvanR> i see a cmath package which binds it, meh
07:05:52 <EvanR> mniip: at some point it might contribute to a problem with lots of numeric code
07:08:10 <mniip> EvanR, no I mean that flooring something like 1e310 produces a rather large integer
07:08:31 <EvanR> oh 
07:08:41 <EvanR> no all my numbers are in the legal range
07:08:51 <fizruk> :t toEnum . floor
07:08:52 <lambdabot> (RealFrac a, Enum c) => a -> c
07:09:03 <mniip> EvanR, 1e310 is within double range
07:09:04 <EvanR> i was talking about needless route through integer being a performance problem
07:09:23 <EvanR> mniip: ... it is but its not really in "integer" range, why ?
07:09:27 <hexagoxel> absence: what cabal version? `cabal run -- +RTS --help` works over here.
07:09:42 <mniip> EvanR, it is in integer range
07:09:53 <EvanR> fizruk: i think that would be a warning too
07:09:59 <mniip> > floor 1e310
07:10:01 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:10:09 <mniip> huh
07:10:20 <EvanR> oh is 10^310 approx 2^52
07:10:35 <EvanR> the limit of sane integer math
07:10:51 <mniip> oh
07:10:57 <mniip> apologies
07:11:01 <mniip> double only goes to 308
07:11:06 <mniip> > floor 1e307
07:11:08 <lambdabot>  9999999999999999860310597602564577717002641838126363875249660735883565852672...
07:11:17 <EvanR> using base 10 to talk about floats is really confusing ;)
07:11:21 <mniip> that's a rather large integer nevertheless
07:11:27 <fizruk> EvanR: it's not, I've checked
07:11:29 <fizruk> :t toEnum
07:11:30 <lambdabot> Enum a => Int -> a
07:11:33 <mniip> might be a performance issue
07:11:43 <jmcarthur> 10^310 > 2^52. both base and exponent are larger
07:11:44 <EvanR> > 1e107 + 1 == 1e307
07:11:45 <lambdabot>  False
07:11:48 <fizruk> EvanR: it's just using Int instead of Integer :)
07:11:50 <EvanR> > 1e107 - 1 == 1e307
07:11:52 <lambdabot>  False
07:11:56 <EvanR> > 1e307 + 1 == 1e307
07:11:58 <lambdabot>  True
07:12:14 <mniip> 2^52 is nowhere near 2^52
07:12:15 <mniip> er
07:12:18 <EvanR> fizruk: should work
07:12:19 <mniip> 2^52 is nowhere near 1e307
07:12:24 <jmcarthur> right
07:12:30 <EvanR> yeah that was wrong
07:12:41 <EvanR> but 10^307 is not in a range of sane integer math
07:12:42 <mniip> > 1e16 + 1 == 1e16
07:12:44 <EvanR> for Double
07:12:44 <lambdabot>  True
07:13:10 <mniip> EvanR, if memory serves me right, you should only be getting 2-limb integers then
07:13:15 <mniip> shouldn't be too bad
07:13:27 <int-e> > 10^307 `mod` 42
07:13:27 <EvanR> eh? my integers are like in the 100s
07:13:29 <lambdabot>  10
07:13:58 <EvanR> allocating gmps Integers is ridiculous for floor(3), toEnum should be better
07:14:22 <fizruk> but still is ridiculous :)
07:14:26 <EvanR> yeah
07:14:44 <jmcarthur> EvanR: https://hackage.haskell.org/package/cmath-0.3/docs/Foreign-C-Math-Double.html#v:floor
07:14:50 <EvanR> i saw that
07:14:58 <EvanR> ill wait until its a real problem to use it
07:17:23 <jmcarthur> EvanR: so your numbers are no larger than 100?
07:17:56 <EvanR> well 1000
07:18:06 <jmcarthur> okay that's pretty small
07:18:21 <jmcarthur> (fromIntegral :: Int -> Double) . floor
07:18:30 <EvanR> ah
07:18:48 <EvanR> that should take the fast path right
07:18:50 <EvanR> "fast"
07:19:02 <jmcarthur> i don't know what the "fast path" would be here
07:19:16 <jmcarthur> Double -> Double would be the fastest i can imagine
07:19:25 <jmcarthur> but this does go via an intermediate Int
07:19:52 <EvanR> yeah as opposed to Integer
07:19:57 <jmcarthur> right, not Integer
07:20:06 <jmcarthur> so if the fast path is "not gmp", then yes
07:20:24 <EvanR> fromIntegral by default will go through Integer unless theres rewrite rules i guess
07:20:25 <jmcarthur> (afaik...)
07:20:47 <jmcarthur> i would be willing to bet that there is an optimization for this case
07:20:47 <EvanR> @src fromIntegral
07:20:48 <lambdabot> fromIntegral = fromInteger . toInteger
07:21:39 <jmcarthur> it's worth noting that Integer for sane ranges is not that slow either
07:21:56 <jmcarthur> not sure what your application is though
07:22:23 <EvanR> video game ish
07:22:54 <jmcarthur> is this per entity per frame? per vertex per frame? per pixel per frame?
07:23:04 <EvanR> in my test, im using trig to position a thing on the screen, but then since its not exactly on a pixel, it looks weird being rendered with cocoa/postscripty thing
07:23:17 <EvanR> so i put a floor on it
07:23:28 <jmcarthur> how frequently will you be doing this?
07:23:28 <int-e> jmcarthur: Indeed there are rewrite rules for floor :: {Double,Float} -> Int{,eger}, and primops for the machine word sized conversion.
07:23:38 <EvanR> per ent per frame, probably the least of my problems
07:23:58 <jmcarthur> yeah i would not worry about this
07:36:05 <nitrix> Are unit tests common in Haskell?
07:36:25 <nitrix> To me, it feels like the type system takes care of like 99%
07:36:35 <EvanR> would be nice
07:37:05 <fizruk> nitrix: there are also property-based tests via QuickCheck and SmallCheck
07:37:09 <EvanR> the type system gives you the option of catch errors like that, but you have to take advantage of it, and that might be implausible depending on the kind of guarantees you want to make
07:37:36 <EvanR> you also have to know how
07:37:39 <nitrix> Does HUnit has nice facilities to test I/Os ?
07:38:01 <nitrix> Because most of my Maybe/Eithers, etc, all depend on some IO functions as the origin of the data
07:38:24 <EvanR> you should separate out functions from IO so you can test them in isolation
07:39:13 <nitrix> What about the -> IO () ones?
07:39:25 <EvanR> good luck testing that
07:39:46 <EvanR> quickcheck did the missiles launch?
07:39:55 <EvanR> *calls russia*
07:40:33 <nitrix> I guess sometimes it's not realistic to expect so.
07:40:38 <EvanR> IO () is a very uninformative type
07:40:41 <EvanR> and powerful
07:41:20 <mniip> just as a -> b
07:41:22 <nitrix> My IO functions motly deal with files, and so, having test input to feed them well be nice.
07:41:42 <EvanR> a -> b at least tells you youre dealing with a function
07:42:01 <EvanR> nitrix: so a file system DSL would be nice
07:42:17 <nitrix> Well, I'm writing a file system, lol :)
07:42:27 <EvanR> then you can test file system operations against a mock file system and check the effects
07:42:40 <EvanR> then the file system program can be rendered as an IO action
07:43:18 <nitrix> EvanR: Yeah, I intentionally made the "file system" appears as an immutable Ledger. Operations receives and outputs a new Ledger for bookkeeping the metadata about files.
07:45:14 <nitrix> I'll let you know how it goes. Seems doable in my case.
08:00:19 <forgottenone> is there any inheritance like mechanism in haskell, i mean when i define with newtype can i use instances of the old type
08:00:41 <kaidelong> forgottenone: GeneralizedNewtypeDeriving
08:01:03 <kaidelong> this lets you derive any instance that the original type had
08:04:06 <jmcarthur> never thought of that as inheritance before
08:04:22 <hpc> it's not
08:04:30 <kaidelong> but it is what he asked for
08:06:05 <forgottenone> kaidelong thanks,i guess there is no such mechanism for defined with data(i guess it wouldn't make sense either)
08:06:24 <jophish> Is there a neater way of doing (inside proc): _ <- someSideEffectingValue -< ()
08:07:15 <kaidelong> forgottenone: lens could help remove some pain if you're working with an isomorphism because of the iso lens
08:07:20 <jophish> ah, it seems as though one can drop the "_ <-"
08:07:28 <Peaker> peaker
08:07:32 <kaidelong> but yeah you'll have to rewrite the instances instance by instance
08:07:55 <kaidelong> usually you do need to introduce extra information for useful "data" things though IE
08:08:09 <kaidelong> instance Monoid m => Monoid (Maybe m)
08:08:18 <kaidelong> requires additional handling of Nothing
08:08:30 <kaidelong> it can't just inherit from m blindly
08:11:11 <forgottenone> kaidelong thanks again 
08:16:24 * hackagebot distributed-process-zookeeper 0.2.0.0 - A Zookeeper back-end for Cloud Haskell.  http://hackage.haskell.org/package/distributed-process-zookeeper-0.2.0.0 (jeremyjh)
08:17:33 <Big_G> Is a list monad just a regular list?
08:19:20 <Welkin> what?
08:19:29 <Welkin> monad is just an interface
08:19:34 <uwap> Big_G, list is a monad, if that's what you are asking for
08:19:39 <Welkin> list happens to have that interface defined for it
08:19:49 <Welkin> the list in haskell is a linked list
08:20:08 <Welkin> data List a = Cons a | Nil 
08:20:14 <Welkin> er
08:20:20 <Big_G> uwap, Yeah. That's what I meant. I'm just used to others having to be explicit like maybe
08:20:25 <Welkin> data List a = Cons (List a) | Nil 
08:20:42 <bennofs> Welkin: now missing an a 
08:20:47 <Welkin> ah
08:21:24 * hackagebot radium 0.4 - Chemistry  http://hackage.haskell.org/package/radium-0.4 (klangner)
08:21:26 * hackagebot learning-hmm 0.3.2.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.2.0 (mnacamura)
08:21:28 <uwap> Big_G, a monad is everything that has a function return :: a -> m a and a function (>>=) :: m a -> (a -> m b) -> m b. in the case of list, m is just [].
08:21:36 <uwap> > return 5 :: [Int]
08:21:37 <lambdabot>  [5]
08:22:46 <Big_G> uwap, So is something like [3, 4, 1, 3] a monad of a monad of a monad of a monad?
08:23:19 <Welkin> that is just a list
08:23:20 <uwap> nah. it is still a list :P
08:24:11 <HeladoDeBrownie> Big_G, when someone says "a monad", they're generally referring to a specific *type* (not a value) along with the given operations.
08:24:48 <Big_G> so maybe Int is a monday but maybe 4 isn't?
08:24:56 <HeladoDeBrownie> so, for example, Maybe is a monad. Either String is a monad.
08:25:07 <HeladoDeBrownie> Maybe Int is not a monad, it's too applied.
08:25:13 <saclark> Beginner question here: why can I not do this?: `enumerate a = [(minBound :: a) .. (maxBound :: a)]`
08:25:15 <uwap> Big_G Maybe is a monad
08:25:19 <HeladoDeBrownie> Maybe 4 isn't valid syntax.
08:25:24 <Welkin> a Monad has kind * -> *
08:25:27 <Welkin> like a Functor
08:25:35 <HeladoDeBrownie> Big_G, do you know what a kind is?
08:26:02 <Big_G> HeladoDeBrownie, No
08:26:06 <kaidelong> the kind that's most familiar is the kind * which is fully realized types
08:26:17 <HeladoDeBrownie> Big_G, much as every value belongs to a type, every type belongs to a kind.
08:26:17 <kaidelong> Int, Maybe Int, String all have kind *
08:26:24 * hackagebot radium 0.4.1 - Chemistry  http://hackage.haskell.org/package/radium-0.4.1 (klangner)
08:26:50 <HeladoDeBrownie> Big_G, all monads in haskell are of kind * -> *. * means concrete types, i.e., those having values. so, * -> * is the kind of types that, applied to a concrete type, give a concrete type.
08:26:57 <Big_G> HeladoDeBrownie, Is a kind a set of types?
08:26:59 <HeladoDeBrownie> Big_G, make sense?
08:27:10 <kaidelong> yes, that's exactly what it is well
08:27:11 <HeladoDeBrownie> Big_G, i don't know if they're sets, but that's the right general idea
08:27:18 <kaidelong> modulo your specific definition of a set
08:27:24 <kaidelong> but that's for mathematicians to worry about
08:27:35 <kaidelong> for our purposes it's a set of types
08:27:55 <mrkkrp> I'm trying to add test suite to .cabal file. Let's say my project is called `MyProject' and my test suite depends on it, of course. I've added `My Project >= 0.1.0' to dependency list of the test suite. Now, when I call `cabal test', it says <command line>: cannot satisfy -package-id MyProject-0.1.0-inplace (use -v for more information). What's wrong?
08:28:19 <bennofs> mrkkrp: maybe try without the version
08:28:23 <Big_G> HeladoDeBrownie, So all functions with the same type signature form are of the same kind? Like + and *
08:28:35 <HeladoDeBrownie> Big_G, functions are values, so they don't have kinds; they have types.
08:28:57 <HeladoDeBrownie> but all values belong to concrete types, which are of kind *
08:29:04 <kaidelong> Int -> Int is the set of all functions from integers to integers
08:29:12 <kaidelong> Int -> Int is an element of the kind *
08:29:31 <Big_G> Why isn't that of kind * -> *?
08:29:42 <kaidelong> (->) Int has a missing type parameter and has a kind * -> *
08:29:56 <kaidelong> (->) itself has two missing ones and has a kind * -> * -> *
08:29:57 <HeladoDeBrownie> @kind (->)
08:29:58 <lambdabot> * -> * -> *
08:30:15 <HeladoDeBrownie> Big_G, because it's (->) applied to two concrete types, so given the kind of (->), it must be a concrete type.
08:30:22 <kaidelong> you can have higher kinds, like (* -> *) -> *
08:30:28 <kaidelong> but that's not important to understanding Monads
08:30:33 <kaidelong> well, except the free monad
08:30:36 <mrkkrp> bennofs: no difference... I use this file https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/pipes.cabal as example... Trying to learn QuickCheck and all the stuff...
08:30:44 <HeladoDeBrownie> kaidelong, i think we're getting ahead a bit ;)
08:31:34 <Big_G> I think I kind of get it
08:31:50 <raek> in untyped settings, it seems to be common to use the word "Monad" for the type class (Monad), for monadic types (eg. Maybe), and for monadic values (eg. Just 1)
08:31:53 <HeladoDeBrownie> Big_G, okay, good. so, all types that have instances of Functor, Applicative, or Monad, are of kind * -> *.
08:32:00 <kaidelong> anyway Monoid is a typeclass on things of * so it's comparatively familiar, you can implement Monoid in things like Java no problem
08:32:34 <kaidelong> Monad is a little harder because it works on things of kind * -> *, which is why the haskell implementors originally used a different word for things like "Monad" (constructor classes, as opposed to type classes)
08:32:46 <HeladoDeBrownie> raek, not just untyped; i've heard people in this channel say "monad" to refer to values that can be composed using Monad. i think it's probably confusing to use it that way though.
08:32:58 <Big_G> What is the difference between a typeclass and a kind?
08:33:08 <HeladoDeBrownie> Big_G, they're two different concepts entirely
08:33:10 <mek42> Do any of the online Haskell learning materials teach parallel Haskell right from the beginning, or is it expected for folks to learn serial Haskell and then learn parallel Haskell?  (I haven't seen parallel code since the MPICH days when x86-64 was released, so forgive me if this is a silly question.)
08:33:31 <HeladoDeBrownie> Big_G, value is to type as type is to kind, as i mentioned
08:33:55 <kaidelong> Well they're both sets of types, kind of, but they're used for different purposes and are kind of orthogonal
08:34:08 <HeladoDeBrownie> Big_G, and a typeclass is kind of like a data type except the language knows how to compute typeclass constraints automatically, unlike regular parameters
08:34:09 <raek> Big_G: a typeclass is a contstraint. Monad has the kind "* -> Constraint" (with some GHC extensions at least)
08:34:52 <HeladoDeBrownie> and also typeclasses are not as easily reifiable as data types.
08:35:02 <HeladoDeBrownie> another way to think of them are like interfaces in other languages.
08:35:06 <HeladoDeBrownie> s/are/is/
08:35:15 <kaidelong> typeclasses over * are exactly interfaces
08:36:03 <Big_G> Maybe I don't fully understand typeclasses. Can you please explain what they are
08:36:10 <fizruk> mek42: you mean parallel or concurrent? or distributed? anyway, afaik all materials on those topics require Haskell basics
08:36:15 <hexagoxel> mrkkrp: lpaste the .cabal file
08:36:32 <kaidelong> typeclasses are a set of methods which can be overloaded for different types
08:36:34 <HeladoDeBrownie> Big_G, they were introduced as a means of doing "ad hoc" polymorphism in a principled way; so, you can have various definitions of the same general form but with different implementations.
08:36:41 <kaidelong> like (+) in Haskell works on more than just Ints
08:36:44 <kaidelong> it can also work on Doubles
08:37:05 <ersran9> what does reifiable mean in this context? is it reference to the fact that typeclasses are not "first class citizens"?
08:37:11 <HeladoDeBrownie> ersran9, yes.
08:37:22 <mek42> fizruk: I want to assign multiple cores from identical cpus on the same motherboard.
08:37:29 <ersran9> HeladoDeBrownie, oh nice, thanks :)
08:37:30 <kaidelong> this is done by having them implement different implementations of (+), so long as it's consistent with the abstracted type (Num t) => t -> t -> t
08:37:43 <HeladoDeBrownie> ersran9, although with the right ghc extensions, Contraint is, which is a special kind. ConstraintKinds is that extension
08:38:03 <kaidelong> if you implement the methods of a typeclass for your type you make that type an "instance" of the typeclass
08:38:04 <HeladoDeBrownie> s/extensions/extension/
08:38:14 <Big_G> So is every type that has a given function like + implemented of the same typeclass?
08:38:18 <fizruk> mek42: for that I am not an expert :(
08:38:42 <kaidelong> Big_G: every type that has an instance of that type class, yes
08:38:48 <kaidelong> like String doesn't have +
08:39:01 <kaidelong> because String doesn't have a Num instance
08:39:08 <Big_G> kaidelong, has a or is a?
08:39:12 <kaidelong> but Double and Int both have Num instances so they supply a + you can use
08:39:21 <HeladoDeBrownie> mek42, you may have seen it already, but you may be interested in parallel and concurrent programming in haskell http://chimera.labs.oreilly.com/books/1230000000929
08:39:32 <kaidelong> Big_G: "has a" is probably more correct because a type can have an instance for more than one type class
08:39:48 <kaidelong> or in some situations have more than one instance for the same type class, which is why we have some newtypes like ZipList
08:39:57 <lpaste> mrkkrp pasted “.cabal file with test-suite” at http://lpaste.net/125444
08:39:58 <HeladoDeBrownie> Big_G, we often say things like "Maybe is a Monad", but that's just short for "there exists a Monad instance for Maybe"
08:40:02 <kaidelong> which purely exist to expose different instances from the default
08:40:18 <mrkkrp> hexagoxel: done
08:40:25 <Big_G> So Num is a typeclass while Int is a type?
08:40:30 <HeladoDeBrownie> Big_G, correct
08:40:32 <kaidelong> yes
08:41:00 <Big_G> and if I wanted to make a new type called Big_GInt, It'd have to implement all functions in Num?
08:41:16 <HeladoDeBrownie> Big_G, you'd only *have* to if you wanted to use them on it.
08:41:25 * hackagebot fluent-logger 0.2.1.0 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.2.1.0 (NoriyukiOhkawa)
08:41:47 <Big_G> HeladoDeBrownie, Isn't the point of having typeclasses so you know certain functions are avaliable?
08:41:51 <HeladoDeBrownie> also, iiirc some of the Num methods can be left in terms of others, so you wouldn't have to define them all
08:42:00 <HeladoDeBrownie> Big_G, sort of? that's kind of vague
08:42:30 <HeladoDeBrownie> it allows niceties like (+) working on different types and doing different things on those different types
08:42:33 <Big_G> HeladoDeBrownie, Let's say I have a function that requires a num. I need to make sure I can use + but if the creator didn't make a + function, I'm in a bad place
08:43:01 <raek> Big_G: Simon Peyton Jones explaining typeclases: https://youtu.be/3bjXGrycMhQ?t=25m9s
08:43:18 <HeladoDeBrownie> ah, well then you can create an instance yourself, if necessary, although usually orphan instances, those that exist in a module that is neither where the typeclass nor type in question is defined, tend to be frowned on
08:43:28 <mek42> HeladoDeBrownie: Thanks, I';ll check that out.
08:43:29 <zipper> The compiler gives me a warning that an import such as: `import Control.Monad (liftM)` is redundant but I should use `import Control.Monad ()`
08:43:39 <Big_G> raek, Thanks
08:44:02 <zipper> Isn't `import Control.Monad (liftM)` much better than `import Control.Monad ()` if all I am using is liftM?
08:44:11 <HeladoDeBrownie> zipper, do you already have liftM imported?
08:44:23 <zipper> HeladoDeBrownie: Not as far as I know.
08:44:24 <HeladoDeBrownie> zipper, import Control.Monad () means "import just the instances from Control.Monad, nothing else"
08:44:38 <HeladoDeBrownie> zipper, seems like a bug. what gives you that warning?
08:44:43 <zipper> Yesod
08:44:48 <zipper> Yesod devel
08:44:50 <HeladoDeBrownie> i mean, what program produces it?
08:44:58 <Big_G> HeladoDeBrownie, What is an orphan instance. If I created an instance myself, would I want to be garunteed that certain functions are present?
08:46:00 <zipper> I just noticed that after commenting out the imports it still works somehow. Seems magical.
08:46:04 <HeladoDeBrownie> Big_G, sorry, maybe i worded it poorly. say you have typeclass Foo defined in module A, and type Bar defined in module B. the instance Foo Bar would have to go in either A or B; if it's in neither of those, it's an orphan. this is allowed but can cause some problems.
08:46:04 <zipper> HeladoDeBrownie: ^
08:46:19 <jmcarthur> zipper: that warning just means one of your other imports is already giving you liftM
08:46:33 <jmcarthur> in fact i think liftM might just be in the Prelude
08:46:46 <HeladoDeBrownie> jmcarthur, that was my first thought too but i tried and it isn't, not in the ghc i have
08:47:06 <Big_G> HeladoDeBrownie, Couldn't you import from those two files?
08:47:09 <jmcarthur> HeladoDeBrownie: then i take it one of the other modules zipper is importing is reexporting it
08:47:11 <Big_G> *modules
08:47:29 <HeladoDeBrownie> Big_G, yes, when you import anything from a module you also get all instances defined in it.
08:47:47 <jmcarthur> zipper: the only reason ghc is suggesting to import Control.Monad () is because the warning is not able to tell whether you intend to import instances from that module
08:47:48 <Big_G> HeladoDeBrownie, Would it be an orphan if you imported?
08:47:57 <HeladoDeBrownie> Big_G, from A or B? no. from any other module? yes.
08:48:03 <jmcarthur> zipper: safer to suggest just cutting out the liftM than the whole thing.
08:48:11 <HeladoDeBrownie> Big_G, whether an instance is an orphan is not dependent on how it's imported
08:48:54 <Big_G> So if I create code outside of A and B using the type from B, it'd be garunteed to be orphaned? 
08:49:19 <HeladoDeBrownie> Big_G, can you rephrase that question to clarify?
08:49:26 <HeladoDeBrownie> i think you might be trying to ask something more specific than you're asking
08:49:53 <jmcarthur> Big_G: if you define an instance in a module that doesn't also contain either the type or the type class, it's an orphan
08:50:27 <Big_G> HeladoDeBrownie, Let's say I create an instance of Int which is 5. I don't define Int nor Num in that file. Wouldn't it be an orphan? Why is having an orphan bad?
08:50:32 <calvinx> I have a data structure `people = [(“name”, “a”), (“name”, “b”), (“name”, “c”)]` and I want to process it so as to generate `[“a”, “b”, “c”]`, how would I go about doing that?
08:50:42 <jmcarthur> Big_G: oh you are confused about what an instance is
08:50:44 <HeladoDeBrownie> Big_G, only typeclasses, not types, have instances.
08:50:48 <jmcarthur> Big_G: you are just talking about values, not instances
08:51:15 <HeladoDeBrownie> Big_G, you can tell that you're defining an instance because it will be helpfully labeled with the word "instance". e.g.: instance Num Int where …
08:51:17 <jmcarthur> Big_G: 5 is a value. it has type Int. Int is an instance of Num.
08:51:22 <ChristianS> calvinx: check out map and snd
08:51:26 <Big_G> So Int is an instance of Num but 5 isn't an instance of Int?
08:51:27 <HeladoDeBrownie> jmcarthur, careful with "is"
08:51:49 <jmcarthur> s/is/is an example of/
08:51:55 <HeladoDeBrownie> Big_G, right, there exists a Num instance for Int; 5 is a value of type Int.
08:52:10 <Big_G> Ah, that explains the confusion
08:52:28 <HeladoDeBrownie> Big_G, you'll find many terms are different in haskell from in other languages
08:52:40 <Big_G> Yeah, I can see that already
08:52:52 <jmcarthur> Big_G: <type> has an instance of <type class>. <value> has type <type>.
08:53:22 <jmcarthur> Big_G: i said "is an instance" earlier, but should have said "has an instance"
08:53:34 <jmcarthur> that is what i think HeladoDeBrownie was really calling me out on
08:53:56 <HeladoDeBrownie> yeah
08:54:03 <Big_G> jmcarthur, Why not is? 
08:54:08 <Big_G> instead of has
08:54:13 <HeladoDeBrownie> because they are not two things that can be equated
08:54:31 <jmcarthur> Big_G: because there is actually no relationship between Int and Num other than that there exists some instance Num Int somewhere
08:54:38 <Big_G> Oh, another difference from other languages
08:54:39 <HeladoDeBrownie> like i said earlier, we often say things like "Int is a Num", but that's shorthand for the existence of an appropriate instance
08:54:53 <calvinx> ChristianS: thanks. it is as simple as `map snd people`.
08:55:12 <Big_G> That makes a lot more sense
08:55:16 <HeladoDeBrownie> i just wanted this discussion to be crystal clear, although if you understand the basics you can feel free to use imprecise wording
08:55:16 <hexagoxel> mrkkrp: ah, you can not depend on an executable atm (long-standing cabal issue)
08:55:54 <hexagoxel> mrkkrp: the usual setup is a library with most stuff, a lightweight executable on top of the library, and test-cases also on top of library.
08:56:05 <Big_G> HeladoDeBrownie, Yeah, coming from Java is a real pain with wording
08:56:12 <hexagoxel> mrkkrp: or you can simply add a second hs-source-dirs, i think
08:56:40 <mek42> In the functional paradigm, is drawing a square on the screen (Logo comes to mind) considered a side effect of a function that returns nothing?  Or is display of the square considered the returned value?
08:57:14 <nh2> these days, is there any fundamental difference between attoparsec and binary, apart from that attoparsec cannot serialise? Both have a backtracking parser that work on ByteStrings, they seem identical to me
08:57:40 <jmcarthur> Big_G: type classes are actually just type-level functions that produce constraints. constraints are the things that go on the left of => in some type signatures.      5 :: Int  ,  Int :: *  , and  Num :: * -> Constraint
08:57:49 <HeladoDeBrownie> mek42, more like the latter; one way to encode what you just mentioned is using IO, in which case the act of drawing is a value representing a procedure for doing it.
08:58:37 <HeladoDeBrownie> mek42, also, "the functional paradigm" is really broad, i answered your question in terms of haskell since that's the channel we're in :)
08:58:40 <jmcarthur> Big_G: a constraint in a type is satisfied by an instance. the only difference between an instance and a value is that an instance doesn't have to be named and passed explicitly.
08:58:40 <mrkkrp> hexagoxel: so, test-suite cannot depend on executable. To test executable I should create separate library, test it, and build my executable on top of the library.
08:59:02 <mrkkrp> hexagoxel: *?
09:00:01 <jmcarthur> wow, trying to explain it somewhat comprehensively like this makes me realize how many words there are to define and how many arrows i would be drawing if i had a whiteboard
09:00:05 <HeladoDeBrownie> mek42, to be a little more specific, you might have drawShape :: Shape -> IO () or one of infinite other possibilities
09:00:17 <Big_G> jmcarthur, Can you have a constraint where a type is an instance of a typeclass in a given set?
09:00:50 <jmcarthur> Big_G: not sure what a "type class in a given set" means
09:01:26 * hackagebot simple-sql-parser 0.4.1 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.4.1 (JakeWheat)
09:01:32 <Big_G> Let's say I have a set of typeclasses like Num, Typeclass2, typeclass3, etc,
09:01:55 <Big_G> Can I have a contsraint for a type a where a must be in one of those type classes?
09:01:59 <mek42> HeladoDeBrownie: thanks - I have a hobby project in mind that seems to lend itself to being functional and I want it parallel, so I've decided to learn Haskell, as I'd read that parallel / concurrency is a strong feature of the language.  On top of this, I have a three year old daughter, so I'm also trying to learn how to explain programming to her someday.
09:02:10 <HeladoDeBrownie> Big_G, that's a bit complicated, the short answer is no, if i understand
09:02:36 <zipper> jmcarthur: Thanks
09:02:40 <monochrom> I suggest simply deleting "in a set" :)
09:02:49 <jmcarthur> Big_G: you can have any combination of the constraints  Num a, Typeclass2 a, Typeclass3 a, etc.,  but you can't describe anything like "there is a constraint Foo a, where Foo comes from the set of type classes X"
09:03:29 <Big_G> jmcarthur, I know that you can do that but what if I want a to be in at least one of those typeclasses but I don't care about which one it happens to be in?
09:03:45 <jmcarthur> Big_G: what is it you are hoping that would be useful for?
09:03:48 <HeladoDeBrownie> Big_G, in practice there's not much use for that
09:04:04 <HeladoDeBrownie> if you can't say which it's in, you can't use any of the methods
09:04:33 <Big_G> I don't think it'd be useful at all. Just poking holes and seeing if I really understand
09:04:46 <jmcarthur> Big_G: with extensions it is possible to abstract over constraints, though eventually somewhere the constraint has to be known or else it is not useful.
09:04:56 <jmcarthur> Big_G: and this is a very advanced topic
09:05:44 <jmcarthur> where by "very advanced" i mean "even expert haskell developers don't really need to know it's a thing"
09:06:24 <Big_G> jmcarthur, I guess I won't worry about it then
09:06:39 <osa1> is maintainer or pretty package here by any chance?
09:07:03 <HeladoDeBrownie> mek42, i definitely find haskell very pleasant for concurrency, though i've yet to do any explicit parallelism in it. however, there's a fairly common mistake of people assuming that the language will parallelize things where it can't or wouldn't know to do so; so, if you're interested in specifics, feel free to ask in here. i won't necessarily know them but surely others will.
09:07:16 <HeladoDeBrownie> mek42, if you're interested in abstract drawing of shapes and interactivity and things, gloss is a good start
09:07:35 <HeladoDeBrownie> however it has almost nothing to do with concurrency or parallelism
09:08:42 <jmcarthur> mek42: "display the square" is considered a returned value, in haskell
09:09:06 <jmcarthur> mek42: although i'm not you and i are *really* talking about the same concept
09:09:10 <jmcarthur> *not sure
09:10:08 <jmcarthur> i actually really like that way of differentiating haskell's IO from side-effects. think i might try to clean up the wording and put it into my bag of one-liners about what IO really is
09:10:26 <hexagoxel> mrkkrp: yes, that is the common pattern. alternative is to remove the dependency, and add another source-dir. then you get some redundant compilation, but otherwise it should work fine as well.
09:11:24 <mrkkrp> hexagoxel: which option is better in your opinion?
09:11:54 <jmcarthur> In most languages, the act of outputting a line of text is a side-effect of evaluating a function that returns unit. In Haskell, the act of outputting a line of text is the resulting value of the function.
09:12:04 <mek42> ok, I just started reading "Tackling the Awkward Squad" to learn about IO - I'll try to get through that, hopefully it will answer my questions
09:13:16 <vandenoever> can i put --extra-lib-dirs and --extra-include-dirs in cabal.config somehow?
09:13:18 <mek42> wife says it is lunch time, ty all for answering my questions and have a great Once a Century Pi Day!
09:13:46 <hexagoxel> mrkkrp: adding a library
09:14:31 <tswett> Ahoy.
09:14:37 <mrkkrp> hexagoxel: thank you for your help!
09:15:30 <geekosaur> vandenoever, my ~/.cabal/config shows entries for them commented out
09:16:00 <geekosaur> just remove the leading comment indicator and add the directories
09:16:07 <tswett> I'm poking around to see what tools look nice for doing test-driven development in Haskell.
09:16:36 <tswett> I've found a couple of blog posts from two years ago. Are there any amazing shiny tools that have been developed in the meantime, or should I just go ahead and follow these posts' advice?
09:17:27 <pharpend> tswett: TDD isn't really a Haskell thing. TDD is useful in languages where you have a ton of pitfalls. Haskell isn't huge in the pitfalls department
09:17:39 <pharpend> tswett: but QuickCheck and HSpec are the best test libraries
09:17:48 <tswett> pharpend: that's true. :)
09:17:56 <pharpend> tswett: the type system will be far more useful than any number of tests
09:18:23 <bennofs> pharpend: you can still write HUnit tests first if you're going to check your function in GHCi anyway. That way, you don't need to do the checking manually each time 
09:18:51 <tswett> Yeah, the reason I'm drawn toward TDD is not so much "I want to make sure I don't break stuff" as "I want to first decide exactly what behavior a feature should produce, and then implement that behavior".
09:19:01 <vandenoever> geekosaur: thanks!
09:19:21 <jmcarthur> shortened for twitter!
09:19:27 <jmcarthur> Most languages: "Write this text to stdout" is an implied side-effect of evaluation. Haskell: "Write this text to stdout" is a value.
09:19:53 <pharpend> tswett: I definitely understand. In practice, however, I've found that tactic doesn't really work in Haskell. It's definitely the way to go in Ruby/Python, though
09:20:04 <tswett> pharpend: *nod*
09:22:25 <tswett> Well, let me be a little more precise about what I'm doing. I want to implement a compiler for an experimental programming language.
09:23:04 <tswett> So I figured I'd start with a really tiny test program, and implement all the stuff for just that program, and build from there.
09:23:57 <tswett> I'm not sure exactly where I want to go with the language; I figured I'd figure it out as I go.
09:24:19 <tswett> pharpend: so would you say this sounds like a decent approach?
09:27:05 <pharpend> tswett: it's a decent approach
09:29:47 <Big_G> HeladoDeBrownie, Can you go into more detail about why orphans are bad?
09:31:18 <geekosaur> instances are global (and must be for the type system to be consistent), so someone using your library can inadvertently get an instance they didn't expect
09:31:44 <HeladoDeBrownie> Big_G, this also explains a little https://wiki.haskell.org/Orphan_instance
09:32:07 <geekosaur> worse, if you use two different libraries and one of them has an orphan instance, it can affect the other library at runtime in ways it does not expect
09:32:12 <Big_G> Are the words typeclass and class used interchangably?
09:32:59 <tswett> Big_G: pretty sure they're exactly the same in Haskell, yeah.
09:33:09 <Big_G> geekosaur, How can I prevent orphans?
09:33:21 <nh2> Big_G: they allow you to write two different instances of the same type in your program, e.g. one that serializes `1` as "1" and expects to deserialize it that way, and one that serializes it as "one" and expects to deserialize it that way. If two such programs talk with each other, that won't work
09:34:30 <nh2> usually we give one meaning to one concept (e.g. `Serializable`), with orphans you are suddenly allowed to give two meanings to one concept
09:34:33 <Big_G> nh2, I can understand the conflict between two different sources. Is there a proper way to resolve it?
09:34:40 <geekosaur> Big_G, don't define an instance unless you either defined the class it applies to in the same place, or are defining and using it in a final program (not a library)
09:35:04 <bennofs> Big_G, geekosaur: or defined the data type in the same place
09:35:11 <Big_G> nh2, So orphans only happen when you have two or more?
09:35:12 <geekosaur> yes
09:35:42 <nh2> Big_G: they can also happen if you have only one, but if you know there is only one, then they don't make problems
09:35:45 <geekosaur> orphans happen when you define an instance for someone else's data type in someone else's class 
09:36:25 <geekosaur> and you are not constraining it to your use only (which, since instances are global, means in a program or a library only usable in that program)
09:36:35 <nh2> Big_G: by disallowing orphans, you Haskell consistency, if you allow yourself to write an orphan, then it's on you to make sure that there are no two inconsistent orphans
09:36:35 <Welkin> I'll name my orphan Oliver Twist
09:36:39 <bennofs> an orphan is an instance that isn't defined in the same module as either: a) the data type for which the instance is or b) the class of the instance
09:36:43 <nh2> ah what am I writing
09:36:48 <Welkin> nh2: but think of the orphans!
09:36:58 <nh2> Big_G: by disallowing orphans, you let Haskell enforce consistency, if you allow yourself to write an orphan, then it's on you to make sure that there are no two inconsistent orphans
09:37:18 <nh2> Welkin: I know, they have a tough life, and everybody wants to avoid them
09:38:02 <nh2> Big_G: the only real problem is that for avoiding orphans, one bit of code must depend on the other. You have a module A that defines the class, and a module B that defines the data type which you want to make an instance. Now either A has to import B or B has to import A, then you can avoid orphans
09:39:16 <Big_G> nh2, so I'd only be able to use B in B? What if I have a chunk of code C that wants the cool type from B?
09:40:06 <nh2> Big_G: this I don't understand. Are you considering one of the two X-imports-Y cases I mentioned right now?
09:40:33 <Big_G> You mean B importing A and vice versa?
09:41:21 <nh2> ah no, I meant that if you want to avoid orphans, one has to import the other. As opposed to the third case:
09:41:55 <nh2> there are cases where you want that neither A imports B, nor B imports A, instead you want to have some C that imports both and make the instance there. Then you cannot avoid the orphan. This happens in practice e.g. for tests: QuickCheck's `Arbitary a` class allows you to generate some test values of type a. Now assume you write a library that has a MyType, and in the tests you want to have an `instance Arbitrary MyType`
09:42:49 <Big_G> nh2, Wouldn't you have to import both in C for something like a constraint to make sure a type a is in the typeclass?
09:42:53 <nh2> then you are in a bad situation: in order to not be an orphan, that instance has to sit either in QuickCheck (not possible since the QuickCheck library doesn't even know about your library) or in your library (the module that defines MyType), but you don't want the latter either because you only need this instance in your tests
09:43:37 <nh2> Big_G: yes, in C (or in the Mytest.Module) you have to import both A and B, but the instance is sitting in C, thus being an orphan
09:44:19 <Big_G> nh2, So there isn't a good way to not have an orphan if you want type constraints?
09:44:20 <nh2> "because you only need this instance in your tests" <- aka "you don't want to clutter your library with an instance that is only useful for your tests"
09:44:59 <nh2> Big_G: not sure what you mean with the type constraints
09:45:49 <Big_G> I want to make sure type a is in a certain typeclass. I'll have to import from module A to do this. I may also want the instance of the typeclass (type) which is in module B
09:45:55 <Cale> Orphans are generally easy to avoid. You just put the instances where they belong, either in the package which defines the class or the package which defines the datatype. Sometimes this means submitting (or using) patches against your dependencies.
09:47:49 <nh2> Big_G: as a user of A and B, you don't care, you just import the modules that contain the type, the class definition, and the instance. You only care if you're wondering into which module the instance should go
09:48:39 <Big_G> So it isn't my issue if they're a library I'm using but it is my issue if I'm writing a library?
09:48:49 <Cale> Big_G: Generally, yeah.
09:49:16 <Cale> Big_G: If you're writing an executable application, you also don't really give a damn about orphans
09:49:40 <Big_G> Cale, Good. It'll be a while until I write a library
09:49:41 <Cale> Because nobody is going to be importing anything from you. You can write all the orphan instances you like.
09:51:16 <cfoch> how can I access to all the installed packages list?
09:51:38 <cfoch> and its dependencies with the dependencies of the dependencies and so
09:52:12 <cfoch> in Cabal there's a function getInstalledPackages function (or something like that)
09:52:25 <cfoch> can I use that externally? 
09:52:40 <cfoch> should I use that function externally?
09:52:45 <nh2> cfoch: `ghc-pkg dot` gives you a textual output
09:56:29 * hackagebot exceptions 0.8.0.2 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.8.0.2 (EdwardKmett)
09:56:38 <monochrom> that output can be given to graphviz etc to draw a picture
09:57:03 <cfoch> Is there a way to get a graph like
09:57:05 <cfoch> https://www.google.com.pe/search?q=haskell+diagrams+types&espv=2&biw=858&bih=370&source=lnms&tbm=isch&sa=X&ei=XGcEVc6lDKf9sATjmIL4AQ&ved=0CAYQ_AUoAQ#imgdii=_&imgrc=OmV0eSmGmX__5M%253A%3BM8Z7r5KsBhvd3M%3Bhttps%253A%252F%252Fwww.cs.auckland.ac.nz%252Freferences%252Fhaskell%252Fhaskell-report-1.4-html%252Fclass-fig.gif%3Bhttps%253A%252F%252Fwww.cs.auckland.ac.nz%252Freferences%252Fhaskell%252Fhaskell-report-1.4-html%252Fbasic.html%3B591%3B671 ?
09:57:43 <monochrom> try graphviz, like I said
09:57:48 <cfoch> to obtain a graph of type classes ^
09:57:57 <monochrom> then I don't know
09:58:04 <cfoch> monochrom: not a graphical graph
09:58:13 <monochrom> then I still don't know
10:09:38 <nh2> cfoch: The Haskell community's tooling for things like this is pretty weak, although theoretically, Haskell makes such things easy. You could build a tool to do it with the GHC API, or syntactically with haskell-src-exts, but expect it to take a few days
10:31:31 * hackagebot tn 1.0.0 - A simple daily journal program  http://hackage.haskell.org/package/tn-1.0.0 (pharpend)
10:39:27 <humanoyd> Does anyone here have experience with haste?
10:41:38 <jophish> Is there a more generic version of catMaybes?
10:42:17 <bennofs> jophish: in what way more generic?
10:43:59 <bennofs> :t fromMaybe [] . foldMap (fmap (:[]))
10:44:01 <lambdabot> Foldable t1 => t1 (Maybe t) -> [t]
10:45:42 <jophish> bennofs: something along those lines. I can't help but feel as though the Maybe in there could be generalized too
10:45:49 <jophish> but I can't quite put my finger on it
10:46:32 * hackagebot shell-monad 0.6.3 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.3 (JoeyHess)
10:47:29 <jophish> and the output list type too. Although I guess it risks becoming less easily tractable
10:51:24 <enthropy> > msum [Just 1, Nothing, Just 3]
10:51:26 <lambdabot>  Just 1
10:51:32 * hackagebot tn 1.0.1 - A simple daily journal program  http://hackage.haskell.org/package/tn-1.0.1 (pharpend)
10:54:08 <wavewave> hi.
10:54:28 <pharpend> I've heard of Joey Hess, he's someone well known. What did he do?
10:54:42 <wavewave> git-annex
10:54:52 <pharpend> ah okay
10:54:59 <pharpend> that's written in Haskell, isn't it
10:55:23 <wavewave> yes. :-)
10:55:46 <pharpend> Oh great I have a bunch of notifications on GitHub. What did I say?
10:56:32 * hackagebot tn 1.0.2 - A simple daily journal program  http://hackage.haskell.org/package/tn-1.0.2 (pharpend)
10:58:42 <wavewave> pharpend: yeah. he is a real coding machine. my github news is full of his commits. ;-)
11:00:46 <wavewave> pharpend: maybe this is more about Joey Hess. https://zgrimshell.github.io/interviews-with-floss-developers-joey-hess/
11:04:07 <{AS}> Hi, so I have been looking at https://www.fpcomplete.com/user/edwardk/phoas, and I am still unsure how to write a simple interpreter for Exp. Any ideas on how to get started? 
11:05:27 <randir> I have a question about relative urls on a website, say a link to /foo/bar.html. If I am on examplesite.com/blah   when I click the link to /foo/bar.html, will it direct me to examplesite.com/foo/bar.html or examplesite.com/blah/foo/bar.html ?
11:07:08 <kadoban> randir: /foo/bar.html isn't a relative URL. It'll go to the former.
11:07:25 <geekosaur> if it starts with a slash then it's relative to the top level. if it doesn't then it uses the base definition which defaults to the current level
11:07:51 <randir> thanks guys!
11:08:36 <randir> By the way, I'm writing something in python now-- after doing Haskell for awhile, I twitch everything I write a python function as it has no specific return type specified
11:08:42 <randir> so different. A great language though.
11:09:20 <kadoban> I used to like python a lot more before learning haskell, heh.
11:10:05 <Yaniel> heh
11:10:42 <Yaniel> I'm modifying a largeish python project atm and I constantly find myself wondering about types
11:10:55 <Yaniel> "okay so what is THIS supposed to be now"
11:12:40 <kadoban> Exactly :-/
11:26:42 <pharpend> kadoban: You should try Sage, it's a Haskeller's worst nightmare
11:26:59 <pharpend> kadoban: "Why can I add a string to a picture of a duck?!"
11:30:06 <HairyDude> I'm getting warnings about Control.Monad.Error being deprecated in favour of Control.Monad.Trans.Except, but what monad class do I use to replace MonadError?
11:30:31 <HairyDude> (in the context of monads-tf)
11:30:52 <nh2> edsko: ping
11:31:06 <edsko> nh2: pong
11:31:12 <f|`-`|f> ping
11:31:22 <nh2> edsko: can I ask you a CloudHaskell question?
11:31:34 * hackagebot kure 2.16.8 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.8 (NeilSculthorpe)
11:31:46 <HeladoDeBrownie> HairyDude, same class, different module
11:31:55 <HeladoDeBrownie> Control.Monad.Except
11:32:17 <edsko> nh2: you can try, but I might not know the answer :) haven't worked on that in a long time. you might also try the #haskell-distributed channel
11:33:58 <nh2> edsko: OK, I'll ask you first, and otherwise I'll go over there. My question is: Assume I have
11:33:58 <nh2>     myFun :: SerializableDict a -> a -> Process ()
11:33:58 <nh2>     myFun SerializableDict _ = return ()
11:33:58 <nh2> Then why can I not do
11:33:58 <nh2>     myFunClo :: Closure (Process ())
11:33:58 <nh2>     myFunClo = $(mkClosure 'myFun)
11:33:59 <nh2> ? It gives: Not in scope: ‘myFun__sdict’
11:34:12 <kadoban> pharpend: Haha, sounds great I'll look into it.
11:34:27 <nh2> edsko: it seems like it doesn't generate __sdict when the function is polymorphic, is that possible?
11:34:53 <nh2> (oh, of course I also use `$(remotable ['myFun])`)
11:35:20 <edsko> er...
11:35:27 <HairyDude> HeladoDeBrownie: if I just replace 'import "monads-tf" Control.Monad.Error' with 'import "monads-tf" Control.Monad.Except' I get a "module not found" error
11:35:52 <HeladoDeBrownie> HairyDude, since you didn't say otherwise i assumed you were using mtl. i don't know what monads-tf is
11:36:05 <HairyDude> <HairyDude> (in the context of monads-tf)
11:36:18 <HeladoDeBrownie> ah, i missed that other message
11:36:19 <bennofs> HeladoDeBrownie: type-families version of mtl (replacing fun deps with tf)
11:37:08 <Big_G> What other haskell channels are there on here that I should be aware of?\
11:37:23 <HairyDude> if I replace Control.Monad.Error with Control.Monad.Trans.Except it tells me that module is in transformers, which obviously won't have a tf-based constructor class
11:37:49 <edsko> nh2: where is mkClosure coming from?
11:37:59 <Hijiri> #haskell-beginners, #haskell-game, #haskell-lens, #haskell-blah, #haskell-overflow, #haskell-in-depth, #numerical-haskell, and some others I'm missing
11:38:13 <nh2> edsko: http://hackage.haskell.org/package/distributed-process-0.5.3/docs/Control-Distributed-Process-Closure.html#g:5
11:38:52 <glguy> HairyDude: monads-tf never really caught on, are you using it for a particular reason?
11:38:53 <nh2> edsko: If I use `myFunMono :: Int -> Process ()` (no parameter `a` present), then all works well
11:39:04 <aupiff> I'm just checking what the current preffered method of calling sequence over [IO a] so that the IO actions are executed in parallel.
11:39:08 <HairyDude> glguy: cos I like the idea? :)
11:39:22 <bennofs> aupiff: check the async package
11:39:25 <bennofs> @hackage async
11:39:26 <lambdabot> http://hackage.haskell.org/package/async
11:39:38 <nh2> there seems to be something like "if the function is polymorphic, I'm not going to generate you the myFun__sdict, only the myFun__static"
11:39:40 <edsko> nh2: might it be the problem that you should uncurry?
11:39:44 <aupiff> bennofs: thanks!
11:40:05 <edsko> oh, no, it seems you're right
11:40:21 <nh2> edsko: unfortunately that gives the same error message, even if it only takes a single argument (tuple)
11:40:36 <edsko> nh2: yeah, if you look at the definition of generateDefs in the source code for that module
11:40:46 <edsko> it only creates an sdict if there are no type variables
11:41:14 <Big_G> what other media would you recommend like podcasts or videos?
11:41:38 <edsko> nh2: but the general infrastructure for these closures certainly does support polymorphism
11:41:53 <edsko> nh2: I would ask in #haskell-distributed or on the mailing list
11:42:04 <edsko> nh2: even thougth I wrote this code, it's been a looooong time and I don't really use it at all
11:42:18 <edsko> nh2: so I don't know what the current best practices are
11:42:37 <nh2> edsko: yes, I am able to do the whole thing with $(mkStatic) and `closureApply` and so on, but mkClosure would be extremely convenient
11:42:49 <nh2> edsko: ah, I see where in the code you mean: _ -> return ([], [])
11:42:58 <edsko> nh2: right
11:43:12 <edsko> nh2; I can't remember why I check for that
11:43:30 <nh2> edsko: do you recall if this was fundamentally not possible, or just complicated?
11:43:41 <edsko> nh2: but I am guessing htat if you try to reimplement this yourself and to to fix it you'll find out soon enough :)
11:43:46 <nh2> :D
11:44:01 <edsko> ah, wait
11:44:41 <edsko> I'm guesing things will go wrong in makeDict/generateDict once we have type variables
11:44:45 <edsko> nh2: ^^
11:45:05 <edsko> nh2: but if you fgiure out a way to do this, I'm sure Tim will be very happy with a pull request :)
11:45:14 <edsko> sorry, gotta go
11:45:20 <nh2> edsko: ok, this is great to know, it helped a lot
11:45:33 <edsko> nh2: this is all a nasty hack..
11:45:43 <edsko> with 7.10 this should all become a lot nicer :)
11:45:48 <edsko> if it ever comes out..
11:45:58 <nh2> edsko: indeed!
11:45:59 * edsko is gone
11:46:05 <nh2> edsko: have a nice evening!
11:46:53 <derekv2> I wish everything would just install through one package manager ( re using homebrew to install cabal-install and ghc vs haskell-platform ) ... but I see that haskell-platform is a bit more up-to-date so I guess I'll try it this time
11:47:18 <derekv2> I'm guessing that keeping things up to date in homebrew was somehow a bunch of trouble?  *sigh
11:47:33 <dmj`> derekv2: you can install everything from scratch w/o homebrew or the haskell-platform
11:48:09 <dmj`> derekv2: I just wget ghc and cabal-install from their sites, you could try this too though: https://ghcformacosx.github.io/
11:48:31 <derekv2> dmj`: the whole point is that I like .. no love a good package manager.  but I always end up with not just 1 but like 20 on my system 
11:49:19 <derekv2> In an ideal world, everything would get installed the same way.  ofc it's be a little closer to that if I was using debian or somesuch but for various reasons I'm on OSX
11:50:31 <SrPx> Is there any way I can disable type checking on Haskell? Reason: since it is so fast and we have no fast LC available, I had the idea to use it as a lambda calculator, but it will reject many valid lambda-calculus terms.
11:51:14 <bennofs> SrPx: you can delay type errors to runtime, but not disable them
11:51:21 <bennofs> (-fdefer-type-errors)
11:51:30 <hpc> what you want is a dsl or edsl
11:51:53 <hpc> if you really want untyped, use lisp
11:52:01 <SrPx> bennofs: interesting, but I guess that is of no use then, right?
11:52:18 <SrPx> For example, GHC will reject And on LC: "and p q = p q p"
11:54:33 <mniip> SrPx, try p q const
11:54:46 <mniip> another valid definition of 'and'
11:56:19 <koomi> why does performance matter for playing with lambda calculus?
11:57:29 <HairyDude> ah, and there is no Error class any more
11:58:50 <nitrix> How would I iterate a list with my own predicate Ord predicate, to find the biggest value below what I'm searching?
11:58:59 <calvinx> Is there a way to implement a `map`-like function that can accept both a number as well as a list?  that is, map’ func 1 and map’ func [1] will both work?
11:59:46 <HairyDude> nitrix: take 1 . sortWith (>=) ?
11:59:48 <HeladoDeBrownie> calvinx, the short answer is no.
11:59:52 <nitrix> Sorry, I mean the next highest value.
11:59:53 <HeladoDeBrownie> (and best answer)
11:59:58 <nitrix> e.g. something 10 [1, 5, 9, 12, 24] => 12
12:00:08 <nitrix> e.g. something 6 [1, 5, 9, 12, 24] => 9
12:00:15 <mniip> sortWith predicate
12:00:19 <mniip> then !! 1
12:00:22 <calvinx> ok. I must make sure i cast my number as a list first I suppose.
12:00:26 <mauke> > minimum (filter (> 6) [1, 5, 9, 12, 24])
12:00:27 <lambdabot>  9
12:00:46 <nitrix> mauke: Let me try that.
12:00:47 <HeladoDeBrownie> calvinx, yes, making sure you always give it a list sounds reasonable.
12:01:18 <HairyDude> using !! is hairy
12:01:27 <HairyDude> what happens if you give it a list with 0 or 1 elements?
12:01:35 * hackagebot one-liner 0.5.1 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.5.1 (SjoerdVisscher)
12:01:56 <HairyDude> > [1] !! 1
12:01:58 <lambdabot>  *Exception: Prelude.(!!): index too large
12:02:23 <voidzero> > [1] !! 0
12:02:25 <lambdabot>  1
12:02:33 <mniip> > cycle [1] !! 1
12:02:34 <lambdabot>  1
12:02:35 <HairyDude> voidzero: yes, that wasn't the point
12:02:39 <nitrix> mniip: Works fine, but I'll need to be careful that my search value isn't bigger than the biggest value in the array.
12:02:44 <nitrix> s/array/list
12:02:45 <voidzero> oh, right. Soryr.
12:03:12 <voidzero> Sorry*
12:03:27 <mniip> nitrix, depending on what you want to do in such a case it might make sense to either
12:03:31 <mniip> ++ [0]
12:03:33 <mniip> or cycle
12:03:52 <nitrix> Clever, I'll just cons [0].
12:03:57 <mniip> in case you have a default value, or want the result to be from the list, respectively
12:04:10 <nitrix> mniip: Numbers are all [1..] :)
12:04:15 <shachaf> You should use mauke's solution.
12:04:22 <nitrix> I am.
12:04:31 <shachaf> If you want you can substitute minimum with a version that returns a Maybe.
12:04:32 <nitrix> minimum (filter (>= 25) [0, 1, 5, 9, 12, 24])
12:04:42 <nitrix> Where 0 is prepended.
12:05:05 <nitrix> Ah gah, nah that wont work ahah.
12:05:18 <SrPx> koomi: performance always matters
12:06:18 <paolino> hello, is it possible that newtype W a b = W {add :: a -> (W a b,b)} is an arrow ? Has it a name ?
12:06:46 <shachaf> It has a name.
12:07:02 <paolino> W ?
12:07:12 <shachaf> https://hackage.haskell.org/package/machines-0.4.1/docs/Data-Machine-Mealy.html
12:07:37 <edwardk> paolino: that is a (slightly inefficient) encoding of a Mealy machine
12:08:32 <paolino> ooh, and it's an arrow
12:08:48 <edwardk> it is an instance of lots of useful things
12:09:00 <shachaf> It's an instance of lots of useful things, and also of Arrow.
12:09:08 <edwardk> you can compare it with https://hackage.haskell.org/package/machines-0.4.1/docs/Data-Machine-Moore.html which is almost the same thing
12:09:15 <edwardk> except the 'states' are labeled rather than the arrows.
12:09:35 <edwardk> basically you start with the -> a, but if you start with the (,) b  instead you get a Moore machine
12:09:42 <shachaf> Mealy a b = a -> Moore a b; Moore a b = (b, Mealy a b)
12:10:40 <paolino> well I just wrote the arrow instance, I doubt I can write the others, it's been a lucky strike
12:11:06 <shachaf> glguy: Imagine if your syntax highlighter highlighted covariant and contravariant parts of a type differently.
12:11:12 <edwardk> you can crib the answers from that package there
12:11:29 <edwardk> there is also a Mealy monad transformer, etc.
12:12:14 <edwardk> that'd look like MealyT a m b = a -> m (b, MealyT a m b)] -- or so
12:12:20 <glguy> Shachaf: I'll have to add a command for that
12:12:23 <edwardk> er. MealyT a m b = a -> m (b, MealyT a m b)
12:12:37 <edwardk> glguy ooh that'd be fancy
12:13:02 <joeyh> I'm trying the method given here, and it works, but cabal sdist only includes files from one of the hs-source-dirs http://blog.haskell-exists.com/yuras/posts/stop-abusing-cpp-in-haskell.html
12:13:49 <joeyh> Yuras: ah, you're on here. Do you have an example package using the method in your blog?
12:14:50 <Yuras> joeyh: hey (Make sure to add other implementations to extra-source-files to make sure cabal sdist will copy them into the tarball.)
12:15:10 <Yuras> joeyh: no, I don't have public code that uses that
12:16:01 <joeyh> hmm, I could instead vary my main-is by use flag
12:16:26 <joeyh> ah, extra-source-files
12:16:35 <joeyh> of course
12:17:13 <edwardk> joeyh: i use something similar in a few packages. I configure different source-dirs and add modules from them based on flags
12:17:22 <Yuras> joeyh: actually if you keep CPP localized, it is not so bad. it was mostly an example to show that you can avoid CPP altogather
12:17:33 <joeyh> cool, I think I'll avoid cpp this way
12:17:45 <edwardk> https://github.com/ekmett/void/blob/master/void.cabal#L39
12:17:51 <joeyh> although it is limited to 1 use of cpp per package really.
12:18:10 <edwardk> https://github.com/ekmett/transformers-compat/blob/master/transformers-compat.cabal#L87
12:18:41 <edwardk> https://github.com/ermine-language/ermine/blob/master/ermine.cabal#L236
12:18:42 <edwardk> etc
12:21:28 <Yuras> edwardk: I think it is a bit different thing. the idea is to have multiple files for the same module for different configurations
12:22:02 <Yuras> edwardk: then you have also to let cabal sdist know about all alternative implementations
12:23:16 <Yuras> edwardk: ah, sorry, I see exactly that in the last link
12:24:01 <edwardk> i work very carefully when it comes to flags though, because backtracking flags are a great way to break cabal
12:24:08 <rui3> Can you define a type family in a class such that all of the type instances must belong to some other class?
12:24:39 <edwardk> rui3: you can make a class associated type with a constraint in the class itself
12:24:57 <edwardk> class Foo (Bar a)) => Baz a where type Bar a :: *; ...
12:25:39 <edwardk> now all Bar Whatevers must be instances of Foo.
12:26:02 <rui3> Humm
12:29:48 <rui3> edwardk: Great! Thanks a lot
12:30:24 <tswett> GHC lets you defer type errors?
12:31:52 <rui3> "Illegal family declaraion" GHC ate the t
12:41:46 <edwardk> rui3: what does the line of code look like?
12:44:52 <paolino> mh, I thought I wrote the arrow instance, actually I wrote arr and (.) which belongs to different classes. Is it enough for an arrow instance ?  
12:45:54 <jmcarthur> paolino: you at least need first, as well
12:46:12 <paolino> but not (.)
12:46:18 <jmcarthur> you do need (.)
12:46:28 <jmcarthur> because Category required for Arrow
12:46:32 <jmcarthur> *is required
12:46:36 <paolino> ah
12:46:55 <jmcarthur> and i only leave out the id function of Category because it can be defined as arr id
12:47:08 <paolino> :t first
12:47:09 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:49:46 <paolino> :t arr
12:49:47 <lambdabot> Arrow a => (b -> c) -> a b c
12:49:53 <quchen> tswett: -fdefer-type-errors, yes
12:50:03 <quchen> tswett: It pairs well with typed holes
12:50:15 <quchen> It doesn't pair well with production code
12:52:08 <jmcarthur> tswett: all it does is replace the location with the type error with code that raises an exception at runtime. very simple.
12:53:08 <jmcarthur> tswett: so the type error is still detected at compile time. it just still produces an executable, with code that raises runtime exceptions where there used to be type errors
12:54:26 <tswett> I turned on -fdefer-type-errors in GHCi and tried to evaluate const 'a' ('b' 'c'), but it still gave me an error.
12:54:43 <jmcarthur> as it should
12:54:43 <shachaf> Yes. It was deferred until evaluation.
12:54:56 <jle`> paolino: if you only have arr and id, then you can make it a Functor and Catrgory
12:55:06 <tswett> I would have expected ('b' 'c') not to get evaluated.
12:55:21 <shachaf> You can't compose with arr and id.
12:55:31 <jle`> oh yes
12:56:19 <mniip> tswett, it fails to find the type of ('b' 'c')
12:56:22 <shachaf> Oh, I didn't see the const.
12:56:30 <mniip> which it needs to apply the const
12:56:32 <jmcarthur> tswett: try compiling  main = const 'a' ('b' 'c')  and then running it
12:56:38 * hackagebot radium 0.4.2 - Chemistry  http://hackage.haskell.org/package/radium-0.4.2 (klangner)
12:56:47 <shachaf> tswett: It gave you a warning, not an error.
12:57:00 <jmcarthur> shachaf: no, it actually didn't give the result. it didn't evaluate it
12:57:13 <shachaf> Oh.
12:57:20 <jmcarthur> shachaf: ghci doesn't seem to have the most desirable behavior here
12:57:20 <shachaf> Well, let x = const 'a' ('b' 'c') and then x works.
12:57:29 <jmcarthur> yeah that seems right
12:57:37 <shachaf> So that's a bit odd.
12:58:18 <jmcarthur> it might have been intentional. if your code has a type error, you may want to at least inspect the error first before trying to run it
12:58:35 <paolino> it's strange I needed  (.) and arr, and now I have to write first 
12:58:43 <jmcarthur> paolino: why is that strange?
12:59:35 <paolino> it seems a different path
13:00:14 <jmcarthur> i don't understand. Arrow requires Category, therefore you must implement (.). Arrow also requires at least arr and first because that's just what you have to do to define Arrow
13:00:45 <paolino> well composition comes before first
13:01:03 <jmcarthur> i'm not aware of any ordering among (.), arr, and first...
13:01:38 * hackagebot scroll 1.20150314 - scroll(6), a roguelike game  http://hackage.haskell.org/package/scroll-1.20150314 (JoeyHess)
13:02:16 <jmcarthur> i am able to compile the Agda package only if i free up enough ram first...
13:02:38 <paolino> it looks like I needed more than category but less than arrow
13:02:52 <jmcarthur> what do you mean "more than category" and "less than arrow"?
13:03:02 <jmcarthur> what does it mean to need more than category?
13:03:07 <paolino> arr
13:03:16 <jmcarthur> right, arr is required for Arrow
13:03:23 <jmcarthur> and so is first
13:03:28 <jmcarthur> so i don't see what's confusing
13:03:34 <paolino> but I don't need first
13:03:39 <jmcarthur> why not?
13:04:05 <kaidelong> arr is the most onerous
13:04:11 <paolino> myarrow n m = (mkMediumW n) `compose` lifter (roundn 2)  `compose` (mkChangingW m)
13:04:20 <jmcarthur> paolino: the documentation says: "
13:04:25 <jmcarthur> paolino: "Minimal complete definition: arr and first, satisfying the laws"
13:04:58 <kaidelong> Category lets you deal with restricted subsets of Haskell by having a limited number of constructors while Arrow requires you to allow arbitrary haskell functions to become arrows
13:05:10 <jmcarthur> kaidelong: yeah, arr is annoying
13:05:25 <jle`> paolino: do you want to use your type with functions parameterized over all Arrow/Categoryt?
13:05:26 <jmcarthur> kaidelong: most annoying is there are weaker versions of arrow that would be sufficient to get proc notation
13:05:33 <jophish> What's the method for lowering Maybe or Either into an ArrowXml from HXT?
13:05:39 <jle`> if not, then you can just make id & arr your own function
13:05:41 <jle`> s
13:05:49 <jle`> without involving them in the typeclass
13:06:09 <kaidelong> mm, is proc notation covered in RebindableSyntax?
13:06:10 <jle`> if you don't first or (.) and you don't plan on using it with Category/Arrow polymorphic functions, you don't benefit much from making them fit
13:06:15 <jmcarthur> kaidelong: nope :(
13:06:29 <kaidelong> I mean we probably should use indexed monads instead of monads now too since all monads can be used as indexed ones
13:06:31 <jmcarthur> kaidelong: or at least not in a nice way, if it is. it might just desugar to arr, first, etc.
13:07:05 <quchen> kaidelong: What's indexed Maybe?
13:07:13 <paolino> jle`, see my value up there, I used compose and lifter which I guess they are (.) and arr
13:07:35 <kaidelong> don't you just use an index of ()?
13:07:45 <jmcarthur> paolino: sounds about right, but just because you aren't using first there doesn't mean there is no such thing as first, or that you can just omit it
13:07:52 <jmcarthur> ... from Arrow
13:07:59 <jle`> paolino: ah yes it's a mealy machine, also called Auto in literature
13:08:14 <jle`> it might be more interesting to write the Category and Applicative instances instead
13:08:17 <jophish> Ideally something like: someArrow >>> Kleisli (function :: a -> Maybe b)
13:08:20 <shachaf> What is Auto?
13:08:21 <quchen> kaidelong: I only know indexed State and Cont, where you can mutate the state and result types.
13:08:22 <jle`> then you get a slightly inefficient first for free
13:08:36 <jophish> however there isn't an instance for ArrowXml (Kleisli Maybe)
13:08:53 <aupiff> hi all, using mapConcurrently from async to scrape a large site -- is there a clean way to make a thread pause before doing a `putMVar` or whatever it does? I am trying to avoid rate-limiting.
13:09:01 <jle`> when i was introduced to the type originally ertyes called it an "auto"
13:09:07 <jle`> i've seen it called an automation arrow
13:09:10 <shachaf> Where?
13:09:36 <quchen> jle`: I remembar that too. I think some Arrow tutorial stated that.
13:09:55 <jle`> https://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html
13:10:09 <quchen> aupiff: What do you mean with "pause"?
13:10:09 <platz> how can I get aeson to parse an object with dates as the keys? I can't use the normal (Date <$> o .: "key" <$> o .: "value") method because each key is a different date http://lpaste.net/125672
13:10:10 <paolino> jmcarthur, I don't get how lifting a function is related to first 
13:10:30 <kaidelong> jle`: that post does not help with Netwire 5, IIRC
13:10:38 <jle`> kaidelong: it wasn't about netwire
13:10:49 <jle`> it was about the usage of the term "automation arrow" for paolino 's type
13:12:10 <jle`> it appears as if it's used to model a mealy machine
13:12:15 <paolino> anyway I could write first so I'm happy
13:12:26 <aupiff> quchen: I just mean that I don't want so many concurrent http requests so I don't get blocked from the site. I want to decrease the frequency of http requests from my computer, but I don't want it as slow as a `sequence`. is there a high-level abstraction for this? or should i just mapConcurrently over list of length n, and wait on each one?
13:12:31 <jle`> congrats :)
13:13:12 <quchen> aupiff: How about using a semaphore? That would be a simple way of only having N concurrent requests at a time.
13:13:14 <c_wraith> aupiff: So you'd like to rate-limit client-side?  The typical way to do that is something like the QSem from Control.Concurrent.QSem
13:13:45 <aupiff> c_wraith: ok I'll look into that
13:13:54 <aupiff> thanks quchen, c_wraith 
13:13:54 <jmcarthur> aupiff: perhaps this is helpful? http://hackage.haskell.org/package/pooled-io
13:14:00 * paolino guess sooner or later will need first 
13:14:05 <aupiff> jmcarthur: I'll look at that too thanks
13:21:21 <erisco> what is Gabriel Gonzalez's IRC handle?
13:21:27 <dmj`> Tekmo
13:21:36 <HeladoDeBrownie> erisco, he's not often on
13:21:44 <HeladoDeBrownie> however he is responsive to email and twitter from what i've seen
13:22:05 <erisco> oh okay, thanks
13:22:11 <jophish> Does anyone know of a function looking at all like this: (ArrowXml a, MonadPlus m) => a b (m c) -> a b c
13:22:43 <erisco> well nonetheless I can ask you fine folks
13:22:47 <jophish> or even Maybe instead of m
13:24:09 <erisco> I found this article by him that advocates dictionary passing over type classing. The use case I am most interested in is the Isomorphism class, where apparently you are unable to define composition of isomorphisms in a useful way
13:24:10 <erisco> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
13:24:31 <erisco> is this still the status of such a type class?
13:24:35 <jmcarthur> erisco: it is worth saying that since writing that his opinion has become milder
13:24:48 <erisco> I read his comment on that
13:24:49 <jle`> jophish: what is it supposed to do?
13:24:56 <jmcarthur> ah didn't know he commented about it
13:25:54 <jmcarthur> erisco: i think that Isomorphism type class is not a very good type class
13:25:56 <jophish> jle`: something along the lines of (>>^ fromMaybe zeroArrow)
13:26:11 <erisco> that said, the isomorphism may not be unique, so maybe it is not a good class
13:26:16 <erisco> jmcarthur why do you say so?
13:26:17 <jmcarthur> erisco: you gain little from the canonicity of type classes in this case
13:26:31 <erisco> why?
13:26:39 * hackagebot hsilop 0.1.0.0 - RPN calculator  http://hackage.haskell.org/package/hsilop-0.1.0.0 (rnhmjoj)
13:26:40 <jmcarthur> erisco: i think Isomorphism makes more sense as a value because of this
13:26:48 <jmcarthur> erisco: well, why would one want it to be a type class?
13:26:53 <jmcarthur> instead of some value
13:26:57 <jmcarthur> *type
13:27:15 <erisco> because we can state the laws
13:27:30 <jmcarthur> ah i guess there is that. though it's only a convention
13:27:40 <jmcarthur> sometimes conventions should be questioned or even broken
13:29:25 <jophish> err, that doesn't work, but I think you get the picture
13:31:34 <erisco> the composition of isomorphisms would be incredibly problematic I think, actually, because it ambiguous on which instances to use (there are many ways to get from A to B)
13:31:52 <jmcarthur> right
13:32:13 <jmcarthur> a huge reason it doesn't make sense as a type class
13:33:23 <jmcarthur> erisco: i think the Isomorphism example is a great example of when you don't want a type class even though it may look like you do. i merely disagree with the conclusion of the article, which seems to be that because there exist some examples that dictionaries are to be generally preferred over type classes
13:34:36 <erisco> well at least we can have a Category instance for the category of isomorphisms
13:34:37 <f|`-`|f> ?
13:35:08 <erisco> or does that stumble as well? I do not think it does
13:35:16 <jmcarthur> nah, that seems fine
13:40:50 <jophish> jle`: something like this: http://lpaste.net/125703 This is pretty horrible (I'm certain it can be made neater)
13:42:08 <jle`> is there an Alternative instance?
13:42:24 <jle`> for ArrowZero?
13:43:00 <jophish> Not that I can see
13:43:18 <jle`> what about a MonadPlus instance?
13:43:37 <jle`> i probably should get to know these types heh
13:43:53 <jle`> is there a reference somewhere? what library is this from?
13:44:13 <arkeet> this is all standard Control.Arrow stuff.
13:44:15 <jophish> there's an alternative instance for arrow plus
13:44:28 <jophish> ArrowPlus*
13:44:30 <user129834765> What's the usual preferred technique for emulating keyword-based arguments, or in some way solving the issue of several ambiguous String parameters in a row?
13:45:42 <osa1> is any maintainers of `pretty` package here by any chance?
13:45:58 <jle`> arkeet: there is no ArrowZero or ArrowXml in standard Control.Arrow
13:46:11 <arkeet> there is ArrowZero
13:46:23 <jle`> oh, reallyt?
13:46:26 <jle`> :O
13:46:28 <jle`> sorry :)
13:47:11 <jle`> what is ArrowXml ?
13:47:18 <arkeet> from hxt
13:48:05 <platz> well I hacked something together with HashMap.toList.  it works, but not sure it's the aeson idiomatic way http://lpaste.net/125672
13:48:18 <user129834765> Hello?
13:50:27 <jle`> jophish: it looks like ArrowXml's are all ArrowPlus and ArrowZero, so you can just use (<|> zero) or (`mplus` mzero)
13:50:43 <jle`> oh, you have a Maybe there
13:51:26 <jle`> user129834765: what do you mean by emulating keyword-based arguments?
13:51:40 * hackagebot plot-gtk-ui 0.0.1.0 - A quick way to use Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-gtk-ui-0.0.1.0 (sumitsahrawat)
13:51:52 <jle`> jophish: do you have a more concrete type other than ArrowXML that you care about?
13:52:45 <jophish> jle`: Everything with ArrowXml at the moment, I've not thought about making it more concrete. Certainly ArrowXml is capable of the behaviour I'm after though
13:53:34 <timothyh> hm. anyone know where I might find a type for raw TCP packets / headers? I'm using pcap, so I have bytestrings, and want to tweak some flags
13:53:42 <paolino> ok, I have a Mealy a b and a Mealy c (Maybe a), can I make them compose fmapping to Mealy c (Maybe b) ?
13:57:11 <jle`> paolino: you can't without something like ArrowChoice
13:57:35 <jle`> well, your Mealy has an ArrowChoice instance...so...yes you can make them compose, but not with just Category and Arrow combinators
13:57:53 <Cale> uh, you could also just write it directly
13:58:07 <jle`> yeah, you can write them directly ><
13:58:16 <timothyh> looks like I can take the Get instance from HaNS and use their TCP types
13:58:48 <jophish> I guess what I'm looking for is an arrow eqiuvalent of join
13:59:01 <paolino> write it directly ?
13:59:05 <jophish> because ArrowXml doesn't have a monad instance
13:59:35 <user129834765> I have a function that takes a bunch of strings and I want to disambiguate them somehow.
13:59:44 <user129834765> In other languages, you can do keyword-arguments for htis.
13:59:54 <user129834765> How can you do it in Haskell.
13:59:55 <jle`> paolino: write your own function Mealy a b -> Mealy c (Maybe a) -> Mealy c (Maybe b)
14:00:00 <jle`> using the constructors of Mealy
14:00:14 <kadoban> user129834765: What do you mean "disambiguate" ?
14:00:34 <kadoban> user129834765: Ohh ohh, I think I see what you mean.
14:00:40 <enthropy> user129834765: you might make a data BunchOfStrings = BunchOfStrings { a,b,c,d :: String }
14:00:50 <arkeet> I don't see.
14:00:51 <user129834765> Oh, so use a record?
14:01:03 <SleepyPikachu> Is it typical to make a module for an instance of a class?
14:01:05 <jle`> you can use a record to simulate arguments with keywords
14:01:07 <user129834765> For example, (connect host username password)
14:01:18 <kadoban> Yeah, that's what comes to mind first, probably a decent solution.
14:01:19 <jle`> some people also use type synonyms/aliases or newtypes
14:01:27 <HeladoDeBrownie> SleepyPikachu, no, especially if neither the class nor type is in it. however it has some use
14:01:32 <enthropy> or you might have (newtype Username = Username String) etc.
14:01:34 <jle`> foo :: String -> Host -> Username -> Password -> ...
14:01:47 <user129834765> So just make a newtype for each of them based on String?
14:01:48 <jle`> but that's mostly for documentation purposes
14:01:55 <user129834765> Yes that's my goal.
14:02:08 <jle`> type alises will mostly be useful for documentation purposes
14:02:09 <enthropy> the problem with that approach is that you have to get the arguments in the right order
14:02:18 <jle`> newtypes will enforce at compile-time
14:02:21 <jle`> "enforce"
14:02:33 <SleepyPikachu> HeladoDeBrownie: So how does one typically deal with name collisions between the class and instance?
14:02:48 <HeladoDeBrownie> SleepyPikachu, i don't think that's usually a problem. can you illustrate what you mean?
14:03:09 <SleepyPikachu> HeladoDeBrownie: Sure, I'll make an lpaste
14:03:15 <lpaste> Cale pasted “paolino composition of Mealy machines” at http://lpaste.net/125723
14:03:21 <jophish> something like this: Arrow a => a b (a b c) -> a b c
14:03:31 <arkeet> instances should be defined either in the same module as the class, or in the same module as the type it's for.
14:03:37 <user129834765> I'm trying to avoid mixing up two String arguments accidentally.
14:03:42 <jophish> join exactly
14:03:48 <arkeet> instances defined elsewhere are called orphan instances, and they're bad.
14:03:58 <jle`> jophish: for a lot of instances that doesn't make too much sense
14:04:14 <jophish> jle`: yeah, I'm just thinking about that
14:04:35 <jle`> why don't you see if your Maybe-behavior is meaningful in specific instances
14:04:50 <jle`> and if it doesn't even make sense in a concrete instance of what you are trying to do, then of course you can't make a generalized one
14:05:06 <jle`> as in, write it for a specific ArrowXML
14:05:17 <jophish> I've not really 'got' arrows yet. Although it strikes me as a little odd that it's tricky to lift, a -> Maybe b to ArrowZero c => c a b 
14:05:33 <jle`> it is definitely possible for specific instances
14:05:48 <arkeet> you can't really do that though.
14:05:50 <jle`> but maybe not every ArrowZero needs an arr
14:05:55 <jle`> an "arrMaybe"
14:05:55 <arkeet> Arrow is annoying.
14:06:17 <jle`> what, people complain that Arrow has `arr`, and now they complain that ArrowZero doesn't have a -> Maybe b? :P
14:06:18 <jophish> or at the least ArrowList, Just x goes to [x] and Nothing to []
14:06:22 <paolino> thanks Cale I had this, I was trying to guess a more "categorical" method
14:06:36 <arkeet> anyway, the behaviour of an arrow in general can't depend on its input.
14:06:46 <arkeet> (same for ArrowZero/ArrowPlus/etc)
14:06:51 <jophish> arkeet: because they're not always monads, right?
14:07:05 <jle`> putting an `a -> Maybe b` constructor into ArrowZero is the same thing as putting the `a -> b` constructor `arr` into Arrow
14:07:10 <arkeet> ArrowApply lets you do that, but at that point you may as well just use a plain monad.
14:07:18 <arkeet> (see ArrowMonad)
14:07:31 <SleepyPikachu> HeladoDeBrownie: I've realised I don't mean name collisions, what I mean is if I have a class with many methods, I probably want to defer to a helper function in the body of the implementation, I'd like to avoid cluttering the file which makes use of the implementation with many helper methods.
14:07:55 <jle`> jophish: looks like you can use `arrL`
14:08:08 <HeladoDeBrownie> SleepyPikachu, you can define the operations over the type in question in another file, if you like, but it's still best to put the instance in the file the type is declared.
14:08:13 <jophish> jle`: ah! perfect!
14:08:24 <jophish> Just what I was looking for
14:08:26 <SleepyPikachu> HeladoDeBrownie: Is there a reason for that?
14:08:26 <jle`> :D
14:08:27 <phaazon> hm
14:08:36 <jophish> ++jle`
14:08:52 <HeladoDeBrownie> SleepyPikachu, so that you avoid potential instance collisions, which are in general impossible to resolve. see https://wiki.haskell.org/Orphan_instance
14:09:00 <phaazon> isn’t there a default implementation for mappend for instance (Semigroup w) => Monoid w?
14:10:01 <SleepyPikachu> HeladoDeBrownie: Thanks, that makes sense.
14:11:05 <jle`> phaazon: i don't think there is an instance (Semigroup w) => Monoid w
14:11:08 <jle`> at leas ti hope there isn't
14:11:41 * hackagebot hfoil 0.2.0 - Hess-Smith panel code for inviscid 2-d airfoil analysis  http://hackage.haskell.org/package/hfoil-0.2.0 (GregHorn)
14:11:42 <phaazon> why?
14:11:43 * hackagebot lipsum-gen 0.1.0 - Generators for random sequences of English-like nonsense  text.  http://hackage.haskell.org/package/lipsum-gen-0.1.0 (evilcandybag)
14:11:57 <phaazon> in the case (Semigroup w) => Monoid w, mappend = (<>)
14:12:15 <HeladoDeBrownie> what is mempty?
14:12:26 <phaazon> I just hope on some day, Semigroup is a superclass
14:12:32 <phaazon> HeladoDeBrownie: yeah, I forgot that
14:12:43 <phaazon> (Semigroup w,Monoid w) => Monoid w
14:12:55 <phaazon> mappend shouldn’t even exist :)
14:13:06 <exio4> "Monoid w => Monoid w"
14:13:11 <exio4> that's a nice tautology 
14:13:21 <phaazon> ahah
14:13:22 <phaazon> yeah
14:13:30 <jle`> auto-tautology
14:13:34 <phaazon> you made me go wrong
14:13:39 <phaazon> I meant the first
14:13:46 <phaazon> (Semigroup w) => Monoid w
14:13:49 <phaazon> that ^ 
14:14:00 <HeladoDeBrownie> that's what prompted my question "what is mempty?" :P
14:14:07 <phaazon> HeladoDeBrownie: you set it
14:14:14 <HeladoDeBrownie> to what?
14:14:21 <phaazon> instance Monoid MySemigroup where mempty = my Value
14:14:22 <phaazon> and that’s all
14:14:31 <HeladoDeBrownie> what is my Value?
14:14:56 <phaazon> this what default typeclass method extension is for
14:15:11 <HeladoDeBrownie> ???
14:15:24 <phaazon> HeladoDeBrownie: we could write Monoid this way:
14:15:52 <absence> http://i.imgur.com/9DgHoke.png <- i have what seems like a space leak (sorry for the light graph colour)
14:15:53 <phaazon> class Monoid w where { mempty :: w; mappend :: w -> w -> w; default mappend :: (Semigroup w) => w -> w -> w; mappend = (<>) }
14:15:57 <absence> http://lpaste.net/5416676860949954560 <- and here's the code
14:16:05 <absence> is there a reason it should use gigabytes of memory?
14:16:14 <phaazon> with -XDefaultSignatures
14:16:42 <HeladoDeBrownie> phaazon, isn't (<>) just mappend?
14:16:50 <HeladoDeBrownie> i.e., literally it uses mappend?
14:17:07 <phaazon> HeladoDeBrownie: in Data.Monoid, yes
14:17:15 <HeladoDeBrownie> then i don't see how that's a reasonable default.
14:17:34 <phaazon> HeladoDeBrownie: look at what I wrote ;)
14:17:44 <phaazon> Semigroup.(<>) is not Data.Monoid.(<>) ;)
14:17:57 <HeladoDeBrownie> i wasn't even aware there *was* a Data.Semigroup.(<>).
14:18:07 <lpaste> Cale annotated “paolino composition of Mealy machines” with “generalisation” at http://lpaste.net/125723#a125738
14:18:11 <phaazon> :)
14:18:12 <phaazon> well
14:18:16 <HeladoDeBrownie> and it looks like there isn't
14:18:17 <phaazon> I think we should stick to that
14:18:18 <Cale> paolino: ^^
14:18:29 <phaazon> implementing both
14:18:32 <HeladoDeBrownie> so then you meant mapend = (.++.)
14:18:36 <HeladoDeBrownie> mappend*
14:18:37 <phaazon> I tend to always implement both
14:18:39 <phaazon> no
14:18:41 <phaazon> mappend = (<>)
14:18:51 <HeladoDeBrownie> what semigroups module are you talking about then?
14:19:00 <phaazon> default mappend :: (Semigroup w) => w -> w -> w; mappend = (<>)
14:19:03 <phaazon> that should be there :
14:19:04 <phaazon> :(
14:19:18 <HeladoDeBrownie> never mind, i give up understanding
14:19:25 <phaazon> https://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-Semigroup.html
14:19:34 <phaazon> that’s quite simple though
14:19:40 <phaazon> what don’t you understand?
14:20:13 <jophish> Is there a reason why hxt doesn't use Text?
14:20:19 <phaazon> Monoid has actually the wrong implementation
14:20:21 <phaazon> it should be 
14:20:31 <phaazon> class (Semigroup w) => Monoid w where mempty :: w
14:20:37 <arkeet> phaazon: agreed
14:20:43 <arkeet> but Semigroup isn't in base.
14:20:47 <phaazon> it should be!
14:20:51 <arkeet> perhaps.
14:21:03 <phaazon> lists, Ordering
14:21:05 <arkeet> but dealing with all the existing code that writes Monoid instances without Semigroup instances
14:21:05 <phaazon> semigroups.
14:21:09 <shachaf> Next up: Applicative has the wrong implementation, it should have a Semigroupal superclass.
14:21:10 <arkeet> would be a pain.
14:21:21 <arkeet> shachaf: is that Apply?
14:21:27 <phaazon> arkeet: why so?
14:21:28 <shachaf> Probably.
14:21:37 <phaazon> we could temporarily use aliases
14:21:41 <arkeet> phaazon: any code that writes a Monoid instance but no Semigroup instance
14:21:42 <arkeet> would be broken
14:21:43 <phaazon> like mappend = (<>)
14:21:52 <phaazon> it would’nt
14:21:55 <arkeet> it owuld
14:22:01 <phaazon> it woldunt
14:22:03 <arkeet> also it would
14:22:13 <arkeet> yes, it would fail at the Monoid instance definition.
14:22:20 <arkeet> complaining about no Semigroup instance being in scope.
14:22:25 <phaazon> since Monoid would require Semigroup
14:22:29 <arkeet> yes precisely.
14:22:32 <phaazon> if you don’t have the (<>) implementation
14:22:33 <phaazon> hell
14:22:39 <phaazon> just copy-paste the old mappend…
14:22:51 <arkeet> you have to modify every library that provides a Monoid instance.
14:23:00 <phaazon> that’s not very hard
14:23:06 <arkeet> ok, go do it then. :)
14:23:18 <phaazon> and I’m pretty sure all recent and up-to-date libraries already provide both the instances ;)
14:23:36 <phaazon> let’s see that actually
14:23:40 <shachaf> Yes, GHC has given up all pretense of caring about not breaking people's code.
14:23:55 <arkeet> there are around 5000 packages on hackage.
14:24:02 <paolino> thanks again Cale, that's my rebus for tonight
14:24:17 <foofoo> hi!
14:24:21 <arkeet> have fun going through them all, and contacting the maintainer for each affected one, etc
14:24:21 <foofoo> i've got a question about newtypes
14:24:25 <foofoo> look at this:
14:24:26 <foofoo> newtype Reader e a = R { runReader :: e -> a }
14:24:36 <phaazon> arkeet: that’s an aspect I don’t like about legacy stuff
14:24:37 <foofoo> do I get the 'runReader' function without defining its function body?
14:24:40 <phaazon> we’re kept behind
14:24:43 <shachaf> Yes.
14:24:44 <arkeet> foofoo: yes
14:24:52 <foofoo> arkeet: how does that work?
14:24:55 <arkeet> you get runReader :: Reader e a -> (e -> a)
14:24:56 <shachaf> runReader :: Reader e a -> e -> a; runReader (R f) = f
14:24:57 <arkeet> record syntax.
14:24:59 <arkeet> always does that.
14:24:59 <phaazon> for f*ck’s suck, let’s just deprecate that, and force people to push the fix
14:25:03 <phaazon> it’s a _simple_ fix
14:25:10 <phaazon> you just go to your Monoid instance
14:25:14 <phaazon> take the mappend implementation
14:25:19 <arkeet> phaazon: consider what happened with the AMP.
14:25:20 <phaazon> and put it in the Semigroup, just above
14:25:25 <phaazon> what happened?
14:25:26 <jmcarthur> edwardk: i went back and dug up my past work on the mihaescu/tarjan deques. now i remember why i abandoned it.     http://lpaste.net/125743
14:25:30 <arkeet> lots of packages still haven't written Functor/Applicative instances for their Monads.
14:25:34 <foofoo> arkeet: thanks
14:25:52 <phaazon> arkeet: I’d say, “their problems”
14:25:54 <arkeet> they had a warning the entire lifetime of ghc 7.8.
14:25:58 <jophish> arkeet: out of interest, what's the reason?
14:26:03 <arkeet> reason for what?
14:26:08 <phaazon> with that philosophy, we’ll keep dragging behind
14:26:14 <jophish> the packages not being updates. Are they unmaintained?
14:26:20 <jophish> updated*
14:26:31 <phaazon> jophish: I tend to blacklist that kind of package
14:26:32 <jmcarthur> edwardk: the frustrating thing about that one is near the bottom i realized why they had the requirement that the bottom of the noncatenable version not have the form [2,0,0] or [0,0,2] :(
14:26:41 <Cale> jmcarthur: Wow, such Agda, very matching, many with
14:26:45 <phaazon> I use packages that have maintainers who care
14:26:49 <jmcarthur> Cale: it's awful
14:27:11 <jmcarthur> and that's the *simple* (non-catenable) version!
14:27:11 <phaazon> like, packages with no upper bounds lead to a “meh” followed by “nope” in my mind
14:27:19 <jmcarthur> and just an incomplete implementation of cons...
14:27:26 <jmcarthur> nothing else at all!
14:27:28 <arkeet> jophish: I'm not going to attempt to guess.
14:27:34 <arkeet> there are many packages out there.
14:27:44 <jmcarthur> oh it looks like i had written viewl already
14:27:53 <phaazon> arkeet: that’s a pity
14:28:08 <jmcarthur> ah, no, viewl is the one i didn't finish
14:28:15 <phaazon> not going forward, because of unmaintained and very likely discontinued packages
14:28:30 <phaazon> I truely think that’s the wrong way to go
14:28:31 <Cale> data Exposures (E : (Set → Set → Set₁) → Set → Set → (Set → Set → Set₁) → Set → Set → Exposure → Set₂) (A₀ : Set → Set → Set₁) (x₀ x₁ : Set) (A₂ : Set → Set → Set₁) (z₀ z₁ : Set) (e₀ : Exposure) : Exposure → Set₃
14:28:36 <Cale> It's beautiful
14:28:37 <Cale> lol
14:28:38 <jmcarthur> anyway, now i have shared my work. maybe a daring person will pick it up again
14:28:40 <arkeet> phaazon: some people like having at least a bit of stability.
14:28:49 <jmcarthur> it's so awful
14:29:25 <phaazon> arkeet: then we need better maintainance of packages…
14:29:52 <arkeet> phaazon: well, let me know if you find a solution.
14:30:08 <phaazon> arkeet: I don’t really see why it’s an issue
14:30:19 <jmcarthur> Cale: i was only using agda for agda-mode. you can see why i needed it
14:30:20 <phaazon> if people don’t update their libraries
14:30:25 <phaazon> they’re the one to blame
14:30:42 <phaazon> when you write something like a package, released on hacakge, you have responsibilities
14:30:59 <phaazon> if you can’t update
14:31:03 <phaazon> then don’t write packages
14:31:07 <EvanR> rofl
14:31:17 <phaazon> or grant the access to people that can do that for you
14:31:18 <phaazon> for instance
14:31:22 <EvanR> big brother is watching you
14:31:24 <phaazon> I pushed a PR to clock’s author
14:31:28 <Cale> jmcarthur: I suppose things like agda-mode suffer from the same double-edged sword issue as interactive debuggers -- they let you write things which no sane person would ever contemplate writing on their own.
14:31:30 <phaazon> to fix clock for windows
14:31:41 <phaazon> the author merged, but hasn’t released a new version of hackage
14:31:44 <shachaf> Yes, just break all the code every GHC release.
14:31:53 <phaazon> I just dropped the dependency with clock
14:32:04 <phaazon> shachaf: I don’t say that
14:32:08 <phaazon> but yeah
14:32:08 <jmcarthur> Cale: then again, Data.Sequence looks very similar (more tame, though)
14:32:11 <phaazon> just release GHC 8.
14:32:27 <phaazon> and deprecate all those things we all would want to see fixed
14:33:10 <arkeet> what would edwardk say.
14:33:28 <phaazon> I truely think that’s the wrong way to go thinking “there are 5k packages out there!”
14:33:30 <jophish> It's probably worth thinking about the disaster Python 3
14:33:40 <phaazon> what would we do if Haskell was a mainstream language?!
14:33:43 <Cale> phaazon: Aren't things getting fixed in base already?
14:33:51 <kristian_> phaazon get rich
14:33:52 <arkeet> maybe he can comment.
14:33:56 <phaazon> Cale: I’m talking about deprecation
14:33:59 <arkeet> being chair of the CLC and author of semigroups, after all.
14:34:03 <EvanR> avoid mainstream at all costs
14:34:04 <shachaf> Semigroup as a superclass of Monoid doesn't even improve things very much.
14:34:06 <arkeet> but he's probably explained this a bunch of times already.
14:34:06 <Cale> phaazon: What are you contemplating changing now?
14:34:16 <phaazon> shachaf: that removes stupid implementation
14:34:18 <arkeet> shachaf: we could finally get the right Monoid instance for Maybe.
14:34:28 <phaazon> _all_ my Monoid instances have mappend = (<>)
14:34:32 <phaazon> and… I never use mappend…
14:34:39 <shachaf> Yes, it means you have to use a few more newtypes and write a little bit more code.
14:34:59 <phaazon> more newtypes?
14:35:05 <Cale> What are people using bare semigroups for now?
14:35:06 <shachaf> For instance you can't use Maybe.
14:35:15 <phaazon> Cale: NonEmpty?
14:35:19 <shachaf> Because it has the wrong Monoid instance, like arkeet mentioned.
14:35:22 <Cale> People actually use NonEmpty?
14:35:25 <phaazon> I do
14:35:31 <Clint> i do
14:35:39 <ippo_> hello everyone! sorry to interrupt, I'm having some issues understanding how to write network code with haskell (specifically, how to download a file given its url): do you mind if I ask for some pointers?
14:35:40 <phaazon> for my vertices merging operation
14:35:58 <jmcarthur> ippo_: haskell questions don't count as interruptions
14:35:59 <sinelaw> ippo_, the curl package helps
14:36:22 <jle`> don't ask to ask, just ask! :)
14:36:26 <jle`> @where ask
14:36:26 <lambdabot> Don't ask to ask, just friggin ask.
14:36:33 <jle`> oh there was a nicer one i was thinking about
14:36:40 <jle`> sry
14:36:42 * hackagebot syncthing-hs 0.1.1.0 - Haskell bindings for the Syncthing REST API  http://hackage.haskell.org/package/syncthing-hs-0.1.1.0 (JensThomas)
14:36:48 <sinelaw> ippo_, http://hackage.haskell.org/package/curl-1.3.8/docs/Network-Curl.html
14:37:02 <sinelaw> ippo_, look at curlGet and variants 
14:37:09 <ippo_> thanks sinelaw, I'll start from there :)
14:37:19 <sinelaw> with pleasure
14:37:32 <phaazon> I hope AMP will pass
14:37:43 <arkeet> @where justask
14:37:43 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:37:46 <phaazon> we could keep liftM for legacy purpose
14:37:57 <arkeet> phaazon: AMP is long past.
14:38:01 <shachaf> I hope people stop using the acronym "AMP". It's the worst acronym.
14:38:07 <phaazon> arkeet: it’s failed?
14:38:10 <ippo_> what does AMP stand for?
14:38:11 <arkeet> warnings started in 7.8, it's implemented in 7.10
14:38:15 <arkeet> past as in passed.
14:38:17 <mniip> applicative monad proposal
14:38:19 <phaazon> Applicative Monoid Proposal
14:38:25 <mniip> monoid?
14:38:25 <ippo_> thanks
14:38:28 <phaazon> ah!
14:38:31 <phaazon> great! :)
14:38:33 <phaazon> yeah
14:38:34 <sinelaw> Monad..
14:38:38 <jmcarthur> GHC HAS BEEN AMPED UP
14:38:39 <phaazon> I saw the warnings
14:38:42 <shachaf> Everyone is terrible.
14:39:01 <mniip> shachaf is terrible
14:39:06 <jmcarthur> pff
14:39:12 <jophish> I don't know, every time I read ftp I think the other ftp :/
14:39:14 <arkeet> funpuns is terrible.
14:39:23 <phaazon> arkeet is terrible
14:39:25 <mniip> but don't tell him
14:41:02 <sinelaw> functional temporal programming
14:43:59 <tswett> I'm pretty sure GHCi is reporting the results of my code correctly and it actually *does* work.
14:45:01 <lpaste> tswett pasted “Parsec being weird” at http://lpaste.net/125763
14:45:36 <tswett> Evaluating 'parse tokenize "test" "a b c d e "' yields "unexpected end of input; expecting space".
14:47:14 <tswett> Why's it expecting space? I'm doing "spaces" and "many1 space"; both of those allow you to use only a finite amount of space if you like.
14:47:29 <arkeet> I think you need to try more.
14:48:08 <Cale> As in use the 'try' function
14:48:24 <arkeet> yes.
14:48:35 <tswett> I thought "try $ many1 space" would do the trick.
14:49:10 <tswett> Wait, no, that wouldn't work.
14:49:39 <SleepyPikachu> tswett: What are you trying to achieve?
14:50:12 <tswett> It successfully gets its "many1 space" and then thinks it needs to see another oneToken... or, failing that, some space?
14:50:29 <tswett> SleepyPikachu: well, I want that to yield the same thing as parsing "a b c d e".
14:50:58 <arkeet> it's seeing a space at the end and thinking that's part of the sepBy.
14:50:59 <arkeet> not the following spaces.
14:51:06 <tswett> Right, exactly.
14:51:10 <absence> http://i.imgur.com/9DgHoke.png <- heap profile, http://lpaste.net/5416676860949954560 <- code, is there a reason it should use gigabytes of memory?
14:51:15 <tswett> Now I'm trying to figure out how to make it not think that.
14:51:28 <arkeet> maybe sepBy doesn't work here.
14:51:37 <tswett> Maybe not.
14:51:47 <Cale> sepEndBy?
14:51:55 <arkeet> that sounds good.
14:52:47 <Cale> absence: How did you construct that heap profile? It doesn't look like the output from hp2ps
14:53:41 <absence> Cale: hp2html
14:54:00 <Cale> Interesting, didn't know that was a thing
14:54:05 <tswett> Here's something I came up with that worked.
14:54:13 <Cale> So where's the legend?
14:54:19 <tswett> tokenize = spaces >> many (do result <- oneToken; spaces; return result) where ...
14:54:33 <absence> Cale: hidden, there's a link outside the screenshot to toggle it
14:54:56 <tswett> Except I think sepEndBy sounds even better.
14:55:30 <absence> Cale: the biggest and almost invisible graph (i don't know how to set sensible colours, sorry) is (241)main.img/main/CAF:main4
14:55:34 <tswett> Sweet. Thanks, everyone.
14:59:50 <absence> Cale: any idea about the mem use? :) is it a space leak or something else?
15:00:05 <Cale> Well, it doesn't look like a space leak
15:00:16 <Cale> The memory use goes back down often
15:00:48 <Cale> How did you generate this graph? This is using +RTS -hc ?
15:01:19 <absence> right
15:01:28 <jmcarthur> maybe this is a case of missing a fusion opportunity somewhere
15:01:34 <jmcarthur> with something strict like a Vector
15:01:44 * hackagebot yst 0.5.0.2 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.5.0.2 (JohnMacFarlane)
15:01:49 <Cale> Maybe try -hy
15:01:53 <absence> the mem use going down often might be untypical, but i still wonder how it gets so high in the first place
15:02:04 <Cale> So that we can see which type it is (It's probably Vector)
15:02:12 <absence> will do
15:03:43 <absence> the highest spikes are from *
15:03:58 <dreams> absence: why are you not using hp2ps?
15:04:01 <jmcarthur> the heck is *?
15:04:26 <absence> then there are some at "only" around 500 MB that are from MUT_ARR_PTRS_DIRTY
15:04:56 <Cale> * is "unknown type"
15:05:16 <absence> dreams: i don't have any tools that open ps files
15:05:28 <Cale> Apparently closures with a polymorphic type show up as *
15:05:50 <Cale> absence: You can apply ps2pdf to the .ps file :)
15:05:58 <dreams> absence: use more powerful views of memory. It will help you understand memory-use better.
15:06:13 <dreams> absence: try the biographical & retainer. 
15:06:15 <sinelaw> absence, on linuxishes "evince" can open .ps or.ps.gz IIRC
15:06:22 <jmcarthur> oh gross, so there's some higher rank thing not being inlined or something?
15:06:32 <absence> sinelaw: i'm on windows
15:06:51 <Cale> absence: btw, how are you compiling?
15:07:09 <jmcarthur> absence: it doesn't exhibit this behavior for me
15:07:14 <Cale> absence: Make sure you have -O2
15:07:23 <Cale> Or at very least -O
15:07:24 <dreams> absence: which heap profile is that figure for? (eg. -hc?) I see no keys at all.
15:07:38 <jmcarthur> absence:  5 MB total memory in use
15:07:54 <jmcarthur> absence: and as Cale is suggesting, i had used -O2
15:08:12 <jmcarthur> if you weren't building with optimizations this doesn't surprise me at all
15:08:20 <jmcarthur> g2g
15:08:23 <absence> i build with "cabal build", using -v it seems that both -O and -O2 are passed to the compiler, so it should be good
15:08:55 <absence> dreams: it's -hc yes, i just hid the legend because it's impossible to see how the colours map anyway
15:09:15 <Cale> For me, it got up to ~100 MB max, according to the heap profile.
15:09:22 <Cale> I'll put the PDF up...
15:09:42 <dreams> absence: try -hb and show me the fig, I'll tell you if you have a space leak ;).
15:09:55 <Cale> http://cale.yi.org/share/abs.pdf
15:11:11 <Cale> absence: I wonder if this a Windows-specific performance bug
15:11:15 <Cale> is*
15:13:22 <absence> dreams: http://i.imgur.com/IGJmuPm.png
15:13:39 <absence> Cale: hm, not impossible
15:13:59 <absence> there's 7.10 coming soon, i can check then i guess :)
15:14:36 <absence> i don't even have the latest it seems, 7.8.2
15:15:54 <Cale> okay, so that huge spike consists of memory allocated for stuff that hasn't been used yet, and the total residency goes way down as soon as it gets used
15:16:22 <Cale> see https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/prof-heap.html#biography-prof for more info about what the states are
15:17:24 <dreams> absence: something is apparent now. You see that red spike, its because you have delayed computations, you might reduce it by adding strictness. I would look which component of the program is producing this lag. (lag means heap memory is created and used late). So try: -hc -hblag. This would show which function produces this lag. from then you could look at the body of the function. 
15:20:30 <dreams> I am actually puzzled why your -hc is way different than -hb. They should have a similar graph.
15:21:04 <Cale> Here's how it looks on Linux: http://cale.yi.org/share/abs.pdf http://cale.yi.org/share/absbio.pdf
15:22:38 <Cale> There is an unfortunate amount of lag there, but it's not an insane amount
15:23:09 <absence> dreams: i get different graphs each time i run the program, that might explain why they don't look the same
15:23:28 <dreams> Cale: I think it is. And there is also void which is just a waste.
15:23:38 <Cale> It is what?
15:24:20 <dreams> absence: they should not different. Of course because GHC sadly use time instead of allocation-ticks you would get slightly different graph. But if they're completely different then something is wrong.
15:24:30 <dreams> Cale: ?
15:24:47 <absence> dreams: (243)main.img/main/CAF:main4 is what i get on top from -hc -hblag
15:24:48 <Cale> <dreams> Cale: I think it is.
15:25:10 <dreams> Cale: I would worry if I had that amount of lag.
15:25:27 <dreams> Thats just me though.
15:25:46 <Cale> dreams: Well, it's not the couple of gigabytes that absence is seeing.
15:26:03 <Cale> It's a reasonably trivial amount of memory
15:26:18 <Cale> Especially given that it doesn't stick around too long
15:26:45 * hackagebot signals 0.0.0.1 - Stream Processing for Embedded Domain Specific Languages  http://hackage.haskell.org/package/signals-0.0.0.1 (mararon)
15:27:27 <dreams> Cale: I just hate memory waste. Its trivial for you but painful for me.
15:27:54 <Cale> I guess I'm spoiled :)
15:28:26 <dreams> heh
15:28:28 <absence> dreams: was the info from -hc -hblag useful?
15:28:35 <Cale> I run Chrome, and it uses more memory than anything else apart from some games pretty much all of the time, and I rarely use more than a quarter of my available RAM
15:28:37 <dreams> absence: where is it?
15:28:50 <dreams> ah
15:28:52 <Cale> The rest is all just for buffers
15:29:25 <absence> dreams: the graph itself doesn't look important, so i was lazy and pasted the name only :)
15:29:26 <Cale> (and /dev/shm :D)
15:31:06 <dreams> absence: well it is pointing you to "img" in main.
15:32:26 <dreams> absence: annotate the body of img with set cost centres. 
15:33:12 <absence> dreams: like so? img = {-# SCC "test" #-} Juicy.Image w h . VG.convert . V.generate (w*h*3) $ gen
15:33:22 <dreams> the whole pipeline
15:34:30 <absence> hm, i get compile errors
15:34:37 <absence> maybe it's due to the function composition
15:34:47 <dreams> show
15:35:42 <dreams> absence: try this http://pastebin.com/Ji7Ws8pD
15:37:01 <absence> dreams: http://pastebin.com/QirZqyqf
15:37:14 <absence> never mind the line numbers
15:40:03 <absence> dreams: this works: img = {-# SCC "img" #-} Juicy.Image w h ( {-# SCC "convert" #-} VG.convert (  {-# SCC "generate" #-}  V.generate (w*h*3)  gen))
15:40:14 <absence> adding one for gen fails
15:40:24 <absence> with that line, it's generate that comes out on top
15:43:25 <jmcarthur> to be clear, my measurement was just taken from +RTS -s. i wasn't using heap profiling
15:44:23 <dreams> absence: back in few minutes.
15:46:24 <Cale> absence: what does ./abs +RTS -s tell you the max residency is?
15:46:47 <Cale> (should be the third number it reports)
15:48:10 <absence> Cale: 147 MB
15:48:20 <Cale> okay
15:48:31 <Cale> So maybe there's just something wrong with the heap profiler
15:48:51 <absence>  14,668,150,112 bytes copied during GC
15:49:05 <jmcarthur> that's a lot
15:49:08 <jmcarthur> mine is only 78,392
15:49:11 <absence> i thought so too
15:49:18 <Cale>      633,329,984 bytes allocated in the heap
15:49:18 <Cale>      616,073,984 bytes copied during GC
15:49:18 <Cale>      159,165,528 bytes maximum residency (5 sample(s))
15:49:25 <Cale> for me, compiled with profiling on
15:49:31 <jmcarthur> mine was without profiling
15:49:46 <jmcarthur> with profiling looks like Cale's
15:49:58 <Cale>        4,327,736 bytes allocated in the heap
15:49:58 <Cale>           78,432 bytes copied during GC
15:49:58 <Cale>           44,872 bytes maximum residency (1 sample(s))
15:50:02 <Cale> with profiling off
15:50:56 <Cale> though, it only had time to take 1 sample
15:50:58 <Cale> so...
15:51:00 <jmcarthur> profiling thwarts every optimization i care about
15:51:05 <Cale> not sure how meaningful it is
15:51:20 <Cale> maybe I should turn the numbers up a bit
15:51:22 <jmcarthur> Cale: i think "total memory in use" might still be useful
15:51:24 <jmcarthur> ?
15:51:59 <Cale>  5 MB total memory in use (0 MB lost due to fragmentation)
15:52:06 <jmcarthur> exactly mirrors mine
15:53:08 <Cale> I sometimes wonder if the artificial cost centre stacks actually end up taking a lot of space in some cases
15:53:51 <Cale> I still think it was kind of a silly idea to introduce those. I understand the rationale for wanting them, but I've only ever been inconvenienced by them myself.
15:54:36 <Cale> i.e. the way that GHC now gives you cost centre stacks which correspond with what the stack would be if the program was being evaluated using strict evaluation
15:54:52 <jmcarthur> oh those. i was about to ask what that was
15:55:15 <Cale> They made the .prof output for our game almost unusable when I was working on Blood Knight.
15:55:27 <jmcarthur> would be nice if they were opt-in for prof rather than a default
15:55:41 <jmcarthur> actually now i am confused
15:55:53 <jmcarthur> i think i should shoudl just read how they work
15:55:55 <jmcarthur> i never bothered
15:55:59 <Cale> cale@ender:~/Work/old/bloodknight$ ls -l gameBenchmark*.prof
15:55:59 <Cale> -rw-r--r-- 1 cale cale   147185 Oct 30  2011 gameBenchmark-prepatch.prof
15:56:00 <Cale> -rw-r--r-- 1 cale cale 40788019 Mar  7  2012 gameBenchmark.prof
15:56:00 <Rotaerk> what's blood knight?
15:56:08 <jmcarthur> jeez
15:56:10 <Cale> ^^ the effect of the change to GHC
15:56:46 * hackagebot stable-tree 0.7.0 - Trees whose branches are resistant to change  http://hackage.haskell.org/package/stable-tree-0.7.0 (tsuraan)
15:56:54 <dreams> absence: there?
15:57:00 <Cale> Rotaerk: An unreleased action RPG in Haskell.
15:57:05 <Rotaerk> nice
15:57:13 <jmcarthur> honestly my whole life was without stack traces for a while. first haskell, before that change, then ocaml with the async library
15:57:32 <Cale> Stack traces are overrated
15:57:37 <jmcarthur> technically still stack traces with the latter, but mostly just showing stuff about the async scheduler
15:57:38 <absence> dreams: yes, sorry was fighting with cabal
15:57:45 <Cale> I sometimes would like to be able to see the *actual* stack in some encoding
15:58:03 <Cale> i.e. which case expressions/pattern matches are contributing to it
15:58:06 <absence> i get low memory use when i disable profiling as well
15:58:14 <dreams> absence: try -hr -hcgenerate  what set do you get?
15:58:36 <dreams> the whole set 
15:58:37 <jmcarthur> what gets me is ghc actually has a stack, and it's a totally sensible stack, but everybody seems to think it's special and weird somehow because the stack frames are thunk entry points instead
15:58:52 <jmcarthur> but that's actually just... exactly what i would expect?
15:58:59 <Cale> jmcarthur: yeah, I don't get it
15:59:54 <jmcarthur> i would actually love to get real stack traces that show me what thunks were entered
15:59:54 <Cale> jmcarthur: Though, I'm coming up on the time where I'll have spent more time programming in a setting with lazy evaluation than without it.
16:00:03 <Cale> jmcarthur: So perhaps it's just a matter of perspective.
16:00:13 <iaos___> hello
16:00:58 <Cale> I think the stack makes sense, but maybe to someone very much used to strict evaluation, it seems really weird
16:01:01 <dreams> absence: with the annotated code.
16:01:52 <Cale> jmcarthur: But I think if displayed correctly, it could make a ton of sense
16:02:07 <jmcarthur> i'm really tired of catering to newbies. yes, it is important to make things presentable for newbies, but it sucks when you have to make things harder for the experts
16:02:18 <jmcarthur> lower the bar to raise the barrier to entry
16:02:25 <jmcarthur> *lower
16:02:28 <jmcarthur> err :)
16:03:06 <absence> dreams: i had to use -i0.001 to get anything out of it at all. 
16:03:22 <dreams> what did you get
16:03:56 <Cale> absence: I found that anything less than -i0.02 ended up producing samples that were at identical times, making the additional resolution unhelpful
16:04:17 <dreams> absence: link the profile.
16:04:20 <Cale> (but maybe that's again a difference between Windows and Linux)
16:04:21 <absence> dreams: http://i.imgur.com/WuU5xfb.png
16:04:32 <absence> dreams: the .hp file?
16:04:44 <dreams> nope
16:14:20 <dreams> absence: seems like generate is building the whole computations before applying the function to each element.
16:16:15 <absence> dreams: does that mean generate needs some strictness annotations?
16:17:14 <dreams> absence: strictness may not work all the time. It depends on how it is defined. Why are you using generate?
16:20:32 <absence> dreams: i need to build a vector by defining each element from its index, so generate seemed like a good fit
16:23:17 <jmcarthur> absence: did you observe it actually taking this much memory before you turned on profiling?
16:24:33 <jmcarthur> it's true that even with profiling it's behaving differently for you than for me and Cale, but i'm wondering how bad it was without profiling
16:26:45 <dreams> jmcarthur: well even with Cale it shows a space leak.
16:28:59 <absence> jmcarthur: it was bad enough that the computer hung for a few minutes swapping
16:29:25 <ClaudiusMaximus> is it possible to declare fixity of function arguments?
16:29:41 <absence> that's why i started profiling at all :)
16:30:51 <jmcarthur> dreams: huh? that wasn't my reading of what cale said
16:31:05 <ClaudiusMaximus> > let f (+) (*) = 1 + 2 * 3 in f (+) (*)
16:31:07 <lambdabot>  9
16:31:10 <jmcarthur> dreams: cale seems to have similar results to me, which is to say... tiny memory usage
16:31:33 <ClaudiusMaximus> > let f (+) (*) = 1 + 2 * 3 where infixl 6 + ; infixl 7 * in f (+) (*)
16:31:34 <lambdabot>  The fixity declaration for ‘+’ lacks an accompanying binding
16:31:34 <lambdabot>    (The fixity declaration must be given where ‘+’ is declared)The fixity dec...
16:31:34 <lambdabot>    (The fixity declaration must be given where ‘*’ is declared)
16:31:41 * dreams eyes jmcarthur
16:31:43 <Cale> dreams: That was with profiling on only.
16:31:45 <dreams> Its not tiny
16:31:53 <Cale> dreams: When I turned off profiling, it took 5MB max
16:32:23 <dreams> Cale: hmm, profiling overheads are not included as far as I know.
16:32:34 <Cale> Well, they seem to have a dramatic impact here
16:32:38 <Cale> look at my results above
16:32:38 <jmcarthur> dreams: not included in what?
16:33:12 <ClaudiusMaximus> > let f p m = 1 + 2 * 3 where infixl 6 + ; infixl 7 * ; (+) = p ; (*) = m in f (+) (*) -- seems unnecessarily verbose and awkward :(
16:33:14 <lambdabot>  7
16:33:46 <zipper> How do I check which version of a package I am running from cabal?
16:33:48 <dreams> In the profiles
16:34:06 <dreams> jmcarthur: I'm 100% sure they're not included in heap profiles. 
16:34:09 <zipper> Also how to make cabal install a specific package.
16:34:18 <zipper> I mean a specific package version.
16:34:44 <Cale> dreams: It seems definitely included in the -s results
16:34:50 <bernalex> is there a 'delete :: a -> [(a, b)] -> b' somewhere that removes an (a, b) based on a, or doesn't if it's not there, and then returns the [(a, b)]?
16:34:53 <Cale> dreams: did you see my +RTS -s outputs above?
16:35:35 <dreams> Cale: ah, I was referring to the graphs.
16:37:06 <jmcarthur> dreams: ah the heap profiles. yeah, i don't think that overhead is included indeed. however, compiling with profiling breaks a lot of optimizations, too, so it's still affected
16:37:10 <ClaudiusMaximus> bernalex: would need to be more like  -> (Maybe b, [(a, b)])  so it 1. doesn't crash if your 'a' isn't there, and 2. gives you back the modified list
16:37:49 <dreams> jmcarthur: yup, that's an open problem.
16:40:21 <bernalex> ClaudiusMaximus: uh I meant to [(a, b)] -- not to b.
16:40:46 <bernalex> ClaudiusMaximus: I don't want Maybe [(a, b)], I just want it to delete if the a is there, else do nothing/just return the original, similar to how most database "delete" functions are.
16:42:05 <bernalex> note: it's no problem defining this, I just thought I'd ask if it's in there somewhere. I certainly expect Map/Set/similar things to have it, but I just need plain old tuple.
16:43:40 <vandenoever> i've been blocked on trying to solve this error msg all day:
16:43:42 <vandenoever> <command line>: cannot satisfy -package Cabal-1.22.0.0
16:44:05 <vandenoever> i've got only cabal 1.22.0.0 installed, so i dont see how it could not be found
16:44:27 <ClaudiusMaximus> bernalex: not found anything relevant on hoogle, so it's probably in an obscure package if it does exist
16:44:38 <bernalex> ClaudiusMaximus: I thought as much. thanks though.
16:45:11 <Cale> vandenoever: Maybe that Cabal package depends on something which was excluded?
16:45:21 <Cale> vandenoever: What does it report with -v ?
16:45:53 <Cale> vandenoever: Oh, also, are you trying to build a package globally, but Cabal-1.22.0.0 is installed locally?
16:45:58 <Cale> How are you compiling?
16:46:18 <monochrom> (in other words, what is the complete context?)
16:46:47 <vandenoever> cabal is installed globally indeed
16:46:59 <Cale> uhhh
16:47:08 <vandenoever> i'm running buildwrapper for use with eclipsefp
16:47:25 <vandenoever> i've got a local .cabal which has most of the packages
16:47:34 <Cale> Can you give the output of ghc-pkg list  and the complete output from your build?
16:47:39 <Cale> lpaste.net
16:47:50 <vandenoever> sure
16:48:45 <vandenoever> http://lpaste.net/125841  ghc-pkg list
16:49:16 <martydoe> I've been trying to use haskell to read an input.txt file containing rows of "id name age", then during execution program prompts the user to create new rows, list or delete.
16:49:26 <vandenoever> http://lpaste.net/125842 < for the build command
16:49:30 <Cale> vandenoever: Okay, you clearly don't have Cabal-1.22.0.0 installed
16:49:40 <Cale> vandenoever: So, that's the first problem
16:49:49 <martydoe> Stuck now on this seemingly simple program,  pointers appreciated http://lpaste.net/125840
16:50:03 <vandenoever> $ nix-env -q|grep -i cabal -> cabal-install-1.22.0.0
16:50:24 <Cale> vandenoever: It's referring to the Cabal library, not which version of cabal-install you have
16:50:35 <Cale> vandenoever: You have Cabal-1.18.1.5
16:50:37 <vandenoever> oh ,where does that cabal-1.18 come from?
16:50:40 <Cale> according to ghc-pkg
16:50:50 <Cale> That's the version of Cabal which comes with ghc
16:50:55 <mpickering> martydoe: Where is the problem?
16:51:01 <Cale> You can install a separate version locally
16:51:12 <Cale> cabal install Cabal-1.22.0.0
16:51:26 <martydoe> mpickering: just don't know how to structure it, around lines 197-206
16:51:39 <vandenoever> ah! the capital 'C' is what got me i think
16:52:01 <Cale> vandenoever: There's Cabal the library, and then there's cabal-install, the package installer which uses that library (and whose executable name is "cabal")
16:52:17 <Cale> vandenoever: Any complaint about a dependency is going to refer to the library version.
16:52:45 <vandenoever> what does Cabal contain?
16:53:03 <Cale> http://hackage.haskell.org/package/Cabal
16:53:18 <Cale> Lots of stuff for configuring and building packages.
16:54:06 <vandenoever> wow, i should have asked here earlier :-P
16:55:04 <mpickering> martydoe: I think people would be able to help if you could ask a more specific question
16:56:49 * hackagebot lipsum-gen 0.1.0.1 - Generators for random sequences of English-like nonsense  text.  http://hackage.haskell.org/package/lipsum-gen-0.1.0.1 (evilcandybag)
16:56:51 * hackagebot lipsum-gen 0.1.0.2 - Generators for random sequences of English-like nonsense  text.  http://hackage.haskell.org/package/lipsum-gen-0.1.0.2 (evilcandybag)
16:57:04 <vandenoever> Cale: thanks, now I've a different error msg (segmentation fault) which i can look into, so progress :-)
16:58:12 <mpickering> vandenoever: getting your environment set up is a bit of an art
16:58:29 <mpickering> a seg fault sounds bad though!
16:58:55 <mpickering> what exactly are you doing?
16:59:05 <vandenoever> mpickering: yeah, i had a setup in opensuse in a vm, but that was too slow over X, now attempting a proper setup on nixos
16:59:24 <vandenoever> mpickering: i think it's due to some missing env variable
16:59:48 <mpickering> ok :)
16:59:48 <vandenoever> mpickering: i'm using eclipse but want it in a dedicated dir for haskell, so i have a bash script that sets up an env for that
17:00:06 <vandenoever> HOME=myhaskelldevhomedir
17:00:08 <vandenoever> etc
17:00:42 <vandenoever> vim also crashes, so i think it's something term related
17:03:09 <mpickering> vandenoever: ha, this sounds bad
17:07:31 <martydoe> http://lpaste.net/125840   what I want to happen is to parse the command, if a successful parse then execute that command.
17:07:36 <martydoe> if the command is not quit then return.
17:08:05 <martydoe> Sorry if the command is the quit command, then return
17:08:27 <martydoe> then stop reading further commands (sorry for using the word return)
17:09:16 <mpickering> so this looks a bit strange at the moment 
17:09:37 <mpickering> cmd is of type Either ParseError Command
17:10:06 <mpickering> what is this first list in mainLop?
17:10:08 <mpickering> the parameter?
17:12:07 <mpickering> ok I think I see what's going on
17:13:18 <mpickering> correct me if I'm wrong, mainLop is a function which takes a list of Person and then gets a command from the user and updates the list?
17:13:46 <mpickering> firstly, should mainLop not be of type, mainLop :: [Person] -> IO [Person]?
17:14:25 <mpickering> martydoe: ?
17:14:47 <martydoe> mainlop is no longer used, old code
17:15:02 <mpickering> ... can you please say where the problem is then?
17:15:07 <martydoe> I was trying to move across to using the state monad
17:15:17 <martydoe> in the mainState method.
17:16:27 <martydoe> In mainState, I wanted to parse a command, only if the command parsed is quit would the mainState function exit, otherwise the failed parse was ignored, or the command executed.
17:16:41 <martydoe> That is the bit I could not get working.
17:16:53 <mpickering> ok I see
17:17:00 <nkar`> where's the list of reverse deps on hackage?
17:17:04 <mpickering> so the type of cmd is?
17:17:15 <mpickering> nkar`: http://packdeps.haskellers.com/reverse
17:17:30 <martydoe> Either ParseError Command
17:17:51 <martydoe> Command is defined on line 22
17:17:58 <mpickering> right, so there are two cases we need to handle. 
17:18:04 <SleepyPikachu> If I don't define method bodies for an instance of a class are they undefined by default?
17:18:15 <mpickering> The first when we have an error and the second when we parse the command correctly
17:18:23 <martydoe> Yes
17:18:38 <mpickering> to do this I would use a case statement and pattern match on "Left" and "Right"
17:18:46 <HeladoDeBrownie> SleepyPikachu, or whatever the default implementation is
17:19:14 <SleepyPikachu> HeladoDeBrownie: Thanks, that makes sense. Is there a compile flag I can provide to insist no methods are undefiend?
17:19:17 <jmcarthur> if any
17:19:28 <SleepyPikachu> (Without explicit x = undefined)
17:19:53 <mpickering> so (1) if there is an error then you don't want to do anything, the way to do this is to "return ()"
17:20:12 <jmcarthur> if you use -Wall then it will complain if they have no default definition, but not otherwise. be aware that this is still not sufficient for all cases, though, since the defaults could be cyclicly defined with the intent that you override at least one or something
17:20:31 <mpickering> and (2) if we have a command then we want to perform that action and then ask for another input
17:21:22 <mpickering> martydoe: do you have a function, Command -> StateT [Person] IO ()?
17:21:58 <nkar`> mpickering: it doesn't contain all packages
17:22:03 <martydoe> mpickering:  yes
17:22:14 <mpickering> what is it called?
17:22:17 <martydoe> Sorry its not in the paste I posted.
17:22:37 <mpickering> that's fine
17:22:45 <mpickering> what do you call it, I'm editing the paste
17:23:09 <martydoe> Sorry, it    handleCommand:: Command -> StateT [Person] IO ()
17:23:25 <mpickering> ok
17:23:43 <mpickering> so if you have a "Right command" what do you want to do to it?
17:24:03 <A4GT1> Hello
17:24:13 <mpickering> (command :: Command)
17:25:02 <vandenoever> i guess it's important that cabal-install and Cabal are the same version
17:25:25 <mpickering> vandenoever: hmm it depends
17:25:48 <mpickering> Actually the current version of Cabal is 1.22.1.1 and cabal-install 1.22.0.1 I think
17:25:51 <martydoe> For a successfully parsed command I want to execute it, that will update the state of the [Person] array and then it will prompt the user for another command
17:26:25 <mpickering> ok so you already have a function which does the first part, handleCommand
17:26:43 <mpickering> and we're writing a function which does the second part, mainState
17:26:49 <mpickering> so we should use them both to finish things off
17:26:59 <lpaste> mpickering revised “Read File with Commands”: “No title” at http://lpaste.net/125840
17:27:03 <martydoe> yes, I can update the array no problem.  The pure stuff like that is easy enough.
17:27:16 <mpickering> ^ see the changes I made there, do they made sense?
17:28:13 <martydoe> It looks annoyingly clear.
17:28:27 <Nadrieril> Hi all. I reinstalled ghc from scratch because of a version hell in cabal, but now I have cabal/cabal-install version incompatibilities
17:28:52 <Nadrieril> I only have platform-haskell installed, and I cannot install any package because of "The version of Cabal being used has changed (was Cabal-1.16.0, now Cabal-1.22.0.0)"
17:29:11 <martydoe> Thank you for that mpickering
17:29:29 <mpickering> Nadrieril: try "cabal configure" ?
17:29:34 <Nadrieril> I tried to cabal install cabal-install but it doesnt solve the problem
17:29:47 <Nadrieril> mpickering: I'm not gonna install all packages manually
17:29:54 <mpickering> Nadrieril: what does "cabal --version" give you 
17:30:01 <Nadrieril> Afaik, cabal configure only makes sens when installing manually
17:30:02 <mpickering> what command are you trying to run?
17:30:25 <Nadrieril> mpickering: cabal-install version 1.22.0.0
17:31:06 <Nadrieril> I was trying to run "cabal install xmonad xmonad-contrib xmonad'extras", but it doesn't matter, it fails for all packages
17:31:20 <Nadrieril> s/'/-/
17:31:31 <mpickering> are you in a sandbox?
17:31:52 <Nadrieril> No, because I want to install those packages globally
17:32:19 <mpickering> can you paste the full log of "cabal install xmonad xmonad-contrib xmonad'extras -v3" pls?
17:33:15 <Nadrieril> @paste
17:33:15 <lambdabot> Haskell pastebin: http://lpaste.net/
17:33:40 <meretrix> @hoogle Monad m => State s a -> StateT m s a
17:33:40 <lambdabot> No results found
17:33:45 <meretrix> How would I do that?
17:34:04 <mpickering> meretrix: That's generally known as "hoist" I think
17:34:23 <mpickering> you can write it yourself quite easily as well
17:34:34 <bitemyapp> > foldr (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..13])
17:34:36 <lambdabot>  "(1+(2+(3+(4+(5+(6+(7+(8+(9+(10+(11+(12+(13+0)))))))))))))"
17:34:39 <bitemyapp> Cale: ^^ that was your invention wasn't it?
17:34:51 <meretrix> Thanks
17:35:36 <lpaste> Nadrieril pasted “Cabal version fail” at http://lpaste.net/125846
17:35:40 <EvanR> you gonna think i invented math
17:35:51 <EvanR> -- drake
17:36:24 <Adeon> > foldl (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..5])
17:36:26 <lambdabot>  "(((((0+1)+2)+3)+4)+5)"
17:36:30 <Nadrieril> mpickering: I pasted it, but it is a common error, I'm not sure you need it all
17:37:23 <Cale> bitemyapp: I find it a little funny to think that it was, but you could say that I popularized it :)
17:38:24 <Cale> I mean, I guess it's possible, but it seems unlikely given how many decades those functions had been around, I'm sure someone before me had done that.
17:38:39 <enthropy> > foldr (+) 0 [1 .. 5] :: Expr
17:38:41 <lambdabot>  1 + (2 + (3 + (4 + (5 + 0))))
17:38:49 <mpickering> Nadrieril: I don't see the error you talked about in this paste?
17:40:25 <bitemyapp> Cale: hard to know who stumbled on it first.
17:40:27 <Nadrieril> mpickering: indeed, and yet without -v3 I see it
17:40:53 <bitemyapp> Cale: I don't want to make it seem like *I* invented it though, so may I attribute the popularization of it to you in my book?
17:41:54 <Cale> I guess if you think it's appropriate. I'm not sure it even needs attribution myself.
17:42:08 <bitemyapp> Cale: well, I'll toss it in there and decide whether to leave the footnote in or not later.
17:42:24 <bitemyapp> Cale: I'm just trying to be conscientious about attribution because I'm feeling very, very unoriginal as I write this book.
17:43:01 <mpickering> meretrix: http://lpaste.net/6546152512750092288
17:44:22 <meretrix> mpickering: I'm surprised this isn't already defined. Is it not a common requirement?
17:45:44 <mpickering> I don't think so
17:46:00 <mpickering> like I said, it's in the MMorph package 
17:46:42 <mpickering> Nadrieril: not really sure tbh, you usually get errors like that when you have build artifacts lying around from older version of Cabal 
17:47:23 <mpickering> maybe try installing in a sandbox and copying the executables into your bin?
17:48:01 <Nadrieril> mpickering: I could, but I ghc-pck deregistered all packages, then uninstalled ghc, then remove ghc-related folders...
17:48:07 <Nadrieril> Could try that
17:50:25 <jle`> meretrix: there is a built in way
17:50:31 <jle`> sorta
17:52:11 <jle`> meretrix: state . runState
17:52:16 <platz> aeson doesn't like decoding a (HashMap Text Int) http://lpaste.net/125847
17:52:18 <jle`> state . runState :: State s a -> StateT m s a
17:52:21 <jle`> er, StateT s m a
17:52:36 <jle`> the typical solution is to never use State though, but sometimes you can't avoid it
17:52:49 <kaiyin> what is your recommendation for a linear algebra library?
17:53:17 <mpickering> I've only reached for something like that when refactoring code to use monad transformer stacks rather than a single monad
17:53:46 <jle`> yeah, so the solution is to never use State in the first place heh
17:53:47 <cbaatz> Design question: does anyone have any thoughts on how to represent (database) IDs for values? Do you store them Maybe in the data type directly? Do you keep them separate and pass around tuples when you need both the value and its identifier? Or do you create a third type to represent the tuple?
17:53:55 <jle`> kaiyin: for what purposes?
17:54:03 <jle`> `linear` works pretty well if you just wanted to compute things
17:54:39 <meretrix> jle`: Ah yeah, that's not bad.
17:54:48 <EvanR> linear seems geared toward 3 dimensional stuff
17:55:01 <jle`> really?
17:55:35 <jle`> how so?
17:55:47 <jle`> it seems to abstract over dimensions pretty well...V3 isn't even a privileged/special type
17:56:05 <EvanR> M59 isnt a type ;)
17:56:14 <kaiyin> jle`:  just matrix operations, decomposition, determinants, eigen vectors etc. regular stuff.
17:56:33 <mpickering> cbaatz: I don't quite understand your question, can you give an example?
17:56:43 <jle`> ah
17:56:46 <EvanR> functions like mkTransformationMat :: Num a => M33 a -> V3 a -> M44 a
17:56:53 <jle`> that won't give you much of that then
17:56:56 <jle`> i don't think so
17:57:33 <jle`> hm. i guess i've always worked with linear algebra in situations unrelated to geometry
17:57:43 <jle`> s/always/in recent history
17:57:55 <jle`> so i usually use the generalized functions a lot and haven't run into it
18:00:14 <cbaatz> mpickering: Yes of course. Say I have a "User" object with first name, last name and an identifier. This is stored in a relational DB as a row with three columns of which one is an auto-generated ID. I now have a few choices for how to represent a user as a Haskell datatype: User UserID String String, (UserID, User String String), and/or IdentifiedUser UserID User (and maybe other options I'm missing). Do you have any thoughts on/experience
18:00:14 <cbaatz>  with which splits/representations make sense?
18:00:23 <EvanR> jle`: V3 is a special type it seems, theres V 1 through 4
18:00:54 <mpickering> I've mainly seen User UserId String String
18:00:57 <acowley> linear started out to provide canonical definitions of common types for low dimensional linear algebra, but it is generalized where possible
18:01:23 <cbaatz> mpickering: Yeah? Any sense for the rationale for that?
18:01:52 * hackagebot plot-gtk-ui 0.0.2.0 - A quick way to use Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-gtk-ui-0.0.2.0 (sumitsahrawat)
18:02:01 <cbaatz> mpickering: Oh, and actually, I meant to say User (Maybe UserID) String String, to allow for creating a new User without known the ID that will be generated.
18:02:13 <acowley> It probably needs a linear-core split off from at some point soon
18:02:40 <acowley> Or maybe we could pull out linear-low with the data type definitions
18:03:02 <bernalex> hm. how did you use monad comprehensions with maybes again? I have a list of a and I run them thorugh a function and get Maybe a, but I only want to keep the Justs. so I can do [p x | x <- xs], where xs is the list. this gives me e.g. [Just foo, Just bar, Nothing, Just fu]... -- how do I get rid of the Nothings & get the values "out of" the Justs? there should be a list monad trick for this.
18:03:05 <bernalex> but IDR it.
18:03:09 <mpickering> cbaatz: I can see what you're saying with the last one but I don't like to have to deal with the Maybe every time I want to access the ID 
18:03:30 <jle`> bernalex: that's just a list comprehension
18:03:42 <bernalex> jle`: uhm, yes, and?
18:03:48 <jle`> > [ x | Just x <- [Just 1, Just 2, Nothing, Just 3] ]
18:03:50 <lambdabot>  [1,2,3]
18:04:15 <mpickering> I'm not sure what best practices are, sometimes people have a seperate datatype to use before insertion and then fill in the ID properly
18:04:20 <cbaatz> mpickering: Yes, I share that dislike, which is why I was leaning towards three types to allow for better experssivity: User, UserID and IdentifiedUser (being just a type tuple).
18:04:35 <bernalex> jle`: ah! thanks.
18:04:46 <jle`> np
18:04:53 <FreeFull> > do { Just x <- [Just 1, Just 2, Nothing, Just 3]; x }
18:04:55 <lambdabot>  No instance for (GHC.Show.Show b0)
18:04:55 <lambdabot>    arising from a use of ‘M228966066322928249516755.show_M2289660663229282495...
18:04:55 <lambdabot>  The type variable ‘b0’ is ambiguous
18:05:07 <FreeFull> > do { Just x <- [Just 1, Just 2, Nothing, Just 3]; return x }
18:05:09 <lambdabot>  [1,2,3]
18:05:34 <bernalex> jle`: how do I combine these tho? i.e. the [x | Just x <- listOfMaybes] and the [p x| x <- xs] which generates the list in the first place
18:05:50 <bernalex> (I use list comprehensions way too seldom)
18:05:58 <Javran> :t catMaybes
18:05:59 <lambdabot> [Maybe a] -> [a]
18:06:18 <Javran> > catMaybes [Just 1, Just 2, Nothing, Just 3]
18:06:19 <lambdabot>  [1,2,3]
18:06:23 <cbaatz> mpickering: Yes, maybe that makes sense.
18:06:46 <mpickering> cbaatz: Just a thought, maybe you could define , data User a = User { userId :: IdType a ... } and a type family IdType Identified = UserId; Unidentified = () 
18:06:56 <mpickering> not sure how that would work out
18:07:04 <bernalex> jle`: I know I can do it with nested comprehensions like [y | Just y <- [p x| x <- xs]], but there should be another way that I just don't remember.
18:07:23 <mpickering> oh and data UserType = Identified | Unidentified (and DataKinds)
18:07:25 <exio4> that sounds like mapMaybe 
18:07:28 <cbaatz> jaspervd1: Do you have any thoughts on the above (on how to represent identifiers)?
18:09:08 <SrPx> Can I ask ghci the source?
18:09:14 <SrPx> @source (++)
18:09:14 <lambdabot> Unknown command, try @list
18:09:24 <Cale> @src (++)
18:09:24 <lambdabot> []     ++ ys = ys
18:09:25 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:09:25 <lambdabot> -- OR
18:09:25 <lambdabot> xs ++ ys = foldr (:) ys xs
18:09:29 <Cale> That doesn't use ghci
18:09:47 <Cale> It just looks up the source from a very limited handcrafted text file
18:10:07 <Cale> You can't ask ghci for the source of things because the source might not be on your computer
18:10:10 <SrPx> :( hm okay
18:10:23 <EvanR> julia repl is cool for showing you the source, and three levels of compilation of the function
18:10:34 <Cale> However, most Haddocks have source links along the right edge of the page
18:10:35 <cbaatz> mpickering: I've forgotten most of what I knew about type families I'm afraid. What's the advantage of your suggestion over doing something like having a separate IdentifiedUser type?
18:10:43 <Cale> So if you have the documentation, that can be helpful
18:10:53 <EvanR> but ghc compilation does cross module compilation
18:11:22 <SrPx> UH huh, Haddocks is awesome in that sense.
18:11:26 <mpickering> cbaatz: You wouldn't have to pattern match down two levels to get to the juicy bits
18:11:45 <cbaatz> mpickering: Oh, I see.
18:11:51 <mpickering> you can more easily write functions agnostic to whether a user is identified or not
18:14:19 <cbaatz> mpickering: I'll keep that in mind as I iterate and see if it could simplify the code. Thanks for all your input!
18:21:53 * hackagebot plot-gtk-ui 0.0.3.0 - A quick way to use Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-gtk-ui-0.0.3.0 (sumitsahrawat)
18:43:57 <Nadrieril> mpickering: I solved my problem by installing manually the cabal version corresponding to the installed caba-install version, which was not easy because I also had a version problem thanks to my package manager... Thks anyway
19:10:41 <bitemyapp> is there something better than :print and :sprint in GHCi for seeing what is and isn't evaluated?
19:10:47 <bitemyapp> both are proving kinda useless at the moment.
19:16:17 <sqrt2_> @pl \x -> x + x^2
19:16:17 <lambdabot> ap (+) (^ 2)
19:16:27 <sqrt2_> which monad is being used here?
19:16:49 <pavonia> (->) a
19:18:20 <sqrt2_> ooooh
19:18:21 <sqrt2_> thanks
19:19:01 <meretrix> > M.fromList [('a', (1,2))] & ix 'a' . _2 %~ (*2)
19:19:03 <lambdabot>  fromList [('a',(1,4))]
19:19:21 <meretrix> > M.fromList [('a', (1,2))] & at 'a' . _2 %~ (fmap (*2))
19:19:23 <lambdabot>  No instance for (GHC.Show.Show t1)
19:19:23 <lambdabot>    arising from a use of ‘M183409372905110501817963.show_M1834093729051105018...
19:19:23 <lambdabot>  The type variable ‘t1’ is ambiguous
19:19:37 <meretrix> How do I use "at" rather than "ix" in that example?
19:19:47 <meretrix> Do I need some kind of Maybe lens?
19:19:47 <shachaf> ix = at . traverse
19:20:08 <shachaf> Er, not quite that.
19:20:12 <shachaf> ix k = at k . traverse
19:20:37 <arkeet> > M.fromList [('a', (1,2))] & at 'a' . _Just . _2 %~ (*2)
19:20:38 <lambdabot>  fromList [('a',(1,4))]
19:20:49 <arkeet> > M.fromList [('a', (1,2))] & ix 'a' . _2 *~ 2
19:20:50 <lambdabot>  fromList [('a',(1,4))]
19:20:51 <shachaf> _Just is equal to traverse in this case.
19:21:31 <shachaf> optics are the best
19:21:44 <meretrix> Cool.. but what if I want to use the Maybe value in the setting function?
19:22:02 <shachaf> Then you just use at.
19:22:21 <meretrix> But then I can't use _2
19:22:36 <shachaf> What are you wanting to do?
19:23:05 <arkeet> at lets you get at some Just (1,2)
19:23:13 <arkeet> and you want to fiddle with Just 2
19:23:14 <arkeet> somehow?
19:23:22 <meretrix> I want "at 'a' . _2 %~ (\mx -> case mx of Just x -> 5; Nothing -> error "foo")
19:23:30 <shachaf> That's pretty tricky, if it's Nothing and you want to turn it into Just.
19:24:26 <meretrix> Basically change the value if the index, if it doesn't exist throw an error.
19:24:37 <meretrix> *if the index exists
19:25:05 <RyanGlScott> Speaking of lens, I'm curious to know what the current relationship between the lens and keys packages is.
19:25:18 <RyanGlScott> Is there any reason to use keys anymore now that Control.Lens.Indexed exists?
19:26:13 <arkeet> probably, since keys has been updated after Control.Lens.Indexed existed.
19:26:23 <arkeet> ask edwardk
19:26:42 <RyanGlScott> I noticed that there are some instances defined in keys that aren't in lens, and vice versa.
19:26:56 * hackagebot calculator 0.2.2.1 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.2.2.1 (sumitsahrawat)
19:27:43 <RyanGlScott> e.g., there's a Keyed (Array i) instance, but not a FunctorWithIndex i (Array i) instance
19:28:22 <arkeet> I'm sure he wouldn't mind if you added those instances.
19:29:04 <RyanGlScott> That's actually the reason I'm asking--I'm thinking of making a package that combines mono-traverable and lens/keys, but I'm not sure which of the two to use.
19:29:19 <zugz> I want to uniformly handle Real and Complex types, but am running into the problem that abs doesn't return an Ord with Complex types. Any advice on how to deal with this neatly?
19:29:35 <RyanGlScott> Regardless of what I pick, I'm probably going to need to make pull requests to get the missing instances in either package defined (since mono-traversable has them).
19:30:10 <arkeet> zugz: make a typeclass with your own abs?
19:30:42 <arkeet> or whatever other thing you're interested in
19:31:01 <zugz> arkeet: like "newtype Normed n = Normed {fromNormed::n}", and then a corresponding class definition with instances for Real and Complex types?
19:31:25 <arkeet> no need for a newtype.
19:32:07 <shachaf> arkeet is suggesting to make a new type class, not a new type.
19:32:13 <zugz> arkeet: but I can't do "instance Real n => Normed n" without undecidableinstances
19:32:29 <arkeet> indeed. so you need more specific instances.
19:32:57 <RyanGlScott> Another question that's been bugging me: is it considered bad practice to combine associated types with functional dependencies?
19:33:01 <zugz> oh... actually "instance Normed Float" and "instance Normed (Complex Float)" and so on?
19:33:07 <arkeet> yeah.
19:33:19 <arkeet> but you know
19:33:34 <arkeet> say, vector-space has some stuff that might be relevant.
19:33:45 <zugz> bit ugly... but yes, I guess that would do
19:33:49 <zugz> and thanks, I'll look
19:33:52 <arkeet> for example, Float and Complex Float are already instances of InnerSpace
19:33:56 <arkeet> which provides magnitude
19:34:06 <arkeet> both of those have Float as their Scalar type.
19:35:28 <edwardk> keys is pretty much dead
19:36:08 <shachaf> keys does allow for zipping, which we don't really know a good way to do with optics.
19:36:33 <mek42> reading the wikibook - will I go wrong thinking of Haskell variables as more of an overloadable user-defined constant than as a mathematical variable?  Does this capture immutability?
19:36:49 <shachaf> What is the difference in your mind?
19:37:22 <shachaf> They are a lot like mathematical variables.
19:37:34 <shachaf> If you write "f x = x + 1", is x an overloadable user-defined constant?
19:38:29 <jophish> Can anyone suggest a nice html renderer? Something which renders html snippets to text which resembles what one might see in a browser
19:39:47 <mek42> my mind sees "variable" and hears "something able to be changed at any time" (kind of like the flavor of a real number) whereas it seems that in Haskell / functional paradigm, a variable just gets re-written periodically, with more of a quantized integer flavor.  I don't have a better way to describe.
19:39:55 * arkeet initially thought something that renders to html when seeing html renderer.
19:40:14 <zugz> arkeet: ok, thanks, I see now that this is the correct solution, and isn't really ugly if you look at it from the right angle ;)
19:40:22 <arkeet> :)
19:40:56 <arkeet> mek42: many instantiations of the same "variable" can exist at once, e.g. inside a recursive function.
19:41:17 <arkeet> I don't know what re-written periodically means.
19:41:22 <mek42> yes, but it only changes at each iteration, each step
19:41:23 <arkeet> what's writing?
19:41:33 <arkeet> does it change back afterwards?
19:41:45 <jophish> arkeet: yeah, it's full of ambiguity
19:41:50 <arkeet> this sounds like a very difficult mental model.
19:41:57 <arkeet> I have to keep track of a lot of things.
19:42:13 <arkeet> a variable is
19:42:20 <arkeet> a name for a value.
19:42:22 <shachaf> What is a step?
19:43:04 <mek42> To me, f(x)=(x+1) has wave character, being a description of all x that can exist, while a Haskell variable has more particle behavior, in that the state (value) of the variable is exactly known at any point in time.
19:43:40 <Cale> mek42: Huh? How is f x = x + 1 any different in Haskell from the mathematical version?
19:44:09 <arkeet> (it's not.)
19:44:53 <nh2> @tell nh2: test
19:44:53 <lambdabot> You can tell yourself!
19:44:55 <Cale> Well, it might be, depending on your formalism, subtly different. But that has less to do with Haskell specifically, and more to do with the constructive nature of Haskell functions.
19:47:00 <nh2> @tell edsko: I actually discovered a very similar problem two years ago: https://cloud-haskell.atlassian.net/browse/DP-67 - where I even mentioned the precise location of that `_ -> return ([], [])` - looks like my memory isn't quite fresh either :)
19:47:00 <lambdabot> Consider it noted.
19:47:01 <Cale> In ZFC, a function f is usually defined to consist of a triple of its domain, codomain, and graph. When we write something like f: R -> R; f(x) = x + 1, that just means the unique function with domain and codomain R, and which satisfies the given equation at every point in its domain.
19:47:12 <mek42> maybe it is just my formal training in physical chemistry coloring things - I'll keep reading and hopefully tomorrow start writing too (building new computer at the moment - ran into difficulties today)
19:47:35 <arkeet> what's nonphysical chemistry?
19:48:09 <shachaf> Often a function is just defined as its graph, and codomain is something only strange people care about. :-)
19:48:10 <Cale> Formally, you could just as well write f = (R, R, {(x,x+1) | x in R})
19:48:41 <Cale> shachaf: Well, sometimes... usually people want to be able to ask whether a function is surjective
19:49:20 <arkeet> or total
19:49:35 <Cale> Total is the default sort of function
19:49:42 <arkeet> I didn't mean to hit enter.
19:49:46 <Cale> ah
19:50:46 <mek42> arkeet: as opposed to organic, inorganic analytical or biochemistry
19:50:59 <arkeet> :)
19:51:58 * hackagebot calculator 0.3.0.0 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.3.0.0 (sumitsahrawat)
19:52:07 <Cale> But yeah, so the difference in type theories is that elements of function types are constructed using lambda terms directly, rather than implemented in terms of some lower-level structures.
19:52:49 <Cale> (at least typically)
19:53:18 <Cale> But that has little to do with the nature of variables.
19:53:31 <arkeet> but their denotations are honest functions.
19:53:48 <Cale> arkeet: Could be, yeah.
19:53:51 <arkeet> could be.
19:54:57 <Cale> (and in the sort of standard denotation for Haskell, they're more than just functions, but actually monotone functions between directed-complete partial orders)
19:56:38 <shachaf> i,i continuous functions between Scott spaces
19:57:34 <Cale> Oh, right, the continuity is actually very important.
19:58:32 <shachaf> Well, continuity is the space as what you said, isn't it?
20:00:32 <Cale> You need to preserve directed suprema, i.e. if you have some increasing chain in the definedness ordering with an upper limit, like _|_ <= True : _|_ <= True : True : _|_ <= ... <= repeat True
20:01:00 <Cale> Then functions have to preserve the limit of that sequence
20:01:58 * hackagebot calculator 0.3.0.1 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.3.0.1 (sumitsahrawat)
20:02:08 <Cale> i.e. you need that f _|_ <= f (True : _|_) <= ... <= f (repeat True), and that f (repeat True) is actually the limit of the chain before that.
20:03:15 <shachaf> Oh, I guess I assumed you meant more than monotone.
20:03:35 <Cale> There are monotone maps which don't necessarily preserve limits like that
20:03:55 <shachaf> Rereading my sentence from before, it makes no sense. s/is/in/ s/as/is/
20:04:26 <Cale> If you didn't have this condition, you could maybe pick f (repeat True) to be something above the limit of the chain
20:05:04 <shachaf> Right.
20:05:18 <Cale> Like, maybe f _|_ = _|_, and f (True : _|_) = _|_ : True : _|_ and then f (True : True : _|_) = _|_ : True : _|_ : True : _|_, and so on, but then f (repeat True) = repeat True
20:05:27 <Cale> that would be monotone, but not limit preserving
20:21:04 <kaiyin> What gui framework would you recommend?
20:22:00 * hackagebot eigen 1.2.1 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.1 (OlegSidorkin)
20:33:46 <gfixler> is there a way to use a variable in a pattern?
20:34:05 <gfixler> foo (v:xs), where v is already something?
20:34:12 <gfixler> i.e. as a literal
20:34:30 <gfixler> foo ('b':xs) will match a string beginning with 'b'
20:34:36 <gfixler> I want 'b' to be a variable
20:34:48 <arkeet> use a guard.
20:34:49 <pavonia> foo (x:xs) | x == v = ...
20:34:51 <arkeet> foo (x:xs) | x == v
20:34:59 <gfixler> ah, I guess that's what I want
20:35:03 <gfixler> thanks
20:35:46 <arkeet> (note: matching literals ends up being a guard like that anyway.)
20:35:59 <arkeet> :t let f 5 = () in f
20:36:00 <lambdabot> (Num a, Eq a) => a -> ()
20:36:04 <arkeet> hence the Eq constraint
20:37:09 <delrik> @gfixler: let b@1:bs = [1,2,3]
20:37:10 <lambdabot> Unknown command, try @list
20:37:32 <delrik> using an as pattern, I dunno if its idiomatic though.
20:37:36 <arkeet> that only works with literal constants.
20:37:46 <arkeet> he wants to match against something not known statically.
20:38:13 <delrik> oh, sorry, I read his question incorrectly.
20:38:21 <delrik> or, statement rather =)
20:38:32 <arkeet> :)
20:38:48 <gfixler> is an a used in a type in a where clause shared with the a in the containing function?
20:38:58 <gfixler> or is a whole new a?
20:39:00 <arkeet> no.
20:39:10 <arkeet> you can if you use ScopedTypeVariables and put a forall on the a
20:39:21 <gfixler> is that what it's for?
20:39:23 <arkeet> yes
20:39:33 <gfixler> I was recently told that it's hard to know what it's for until you need it
20:39:38 <arkeet> lol
20:39:40 <gfixler> hehe
20:39:48 <gfixler> suddenly I need no explanation
20:39:54 <arkeet> some type signatures aren't possible to write without ScopedTypeVariables.
20:39:56 <gfixler> forall on which a?
20:40:00 <gfixler> the outer?
20:40:05 <arkeet> yes.
20:40:16 <arkeet> forall introduces new type variables.
20:40:24 <arkeet> that are scoped.
20:40:56 <gfixler> fascinating
20:42:03 <lpaste> arkeet pasted “ScopedTypeVariables contrived example” at http://lpaste.net/125853
20:42:22 <arkeet> ^
20:43:44 <shachaf> arkeet: Are there *programs* you can't write without STV?
20:44:01 <arkeet> maybe.
20:45:00 * arkeet considers `catch`
20:45:35 <dmj`> @typ fromException
20:45:36 <lambdabot> Exception e => SomeException -> Maybe e
20:45:48 <arkeet> maybe not.
20:46:23 <arkeet> you'd be able to use something like asTypeOf in cases like I'm thinking.
20:46:25 <haasn> I think you can use clever tricks to eliminate all usages of STV. But I'm not sure.
20:46:43 <haasn> I can't immediately think of a counterexample
20:47:00 <shachaf> Maybe something with uninferable rank-N types.
20:47:34 <arkeet> maybe.
20:48:12 <Hijiri> I never thought about it, I guess SomeException is Dynamic for exceptions
20:48:57 <arkeet> yes.
20:50:22 <gfixler> arkeet: well, it worked, but...
20:50:42 <gfixler> if I do anything that makes the a concrete in the inner function, it fails the outer function
20:50:58 <arkeet> paste code/error?
20:51:04 <arkeet> well
20:51:06 <arkeet> I mean
20:51:10 <arkeet> that's to be expected I think?
20:51:24 <gfixler> expected type: [a]; actual type [Char]
20:51:36 <arkeet> well yes, you don't know what a is.
20:51:40 <arkeet> in particular, you can't assume it's Char.
20:51:48 <gfixler> so I can just move the a around
20:51:59 <arkeet> what are you doing exactly?
20:52:04 <shachaf> arkeet: Wouldn't want to make it too easy for you.
20:56:30 <gfixler> arkeet: not sure yet - need to play some more :)
21:12:03 * hackagebot context-free-grammar 0.0.1 - Basic algorithms on context-free grammars  http://hackage.haskell.org/package/context-free-grammar-0.0.1 (nedervold)
21:12:48 --- mode: ChanServ set +o glguy
21:13:32 --- mode: glguy set -bbbb *!~asdd@athedsl-4506465.home.otenet.gr *!*@238.Red-88-0-136.dynamicIP.rima-tde.net *!*@host113-72-dynamic.246-95-r.retail.telecomitalia.it *!*@184.153.109.229
21:13:32 --- mode: glguy set -bbbb *!*@199.180.249.102 *!*@h88-150-204-154.host.redstation.co.uk *!*@95.141.20.196 *!*@79.141.160.64
21:13:34 <whitesn> hello, may I ask how to reproduce explode recursively in haskell with only pattern matching?
21:13:42 <whitesn> ex: explode "foo bar foo" ' ' -> ["foo","bar","foo"]
21:13:58 <Hijiri> is it bad style to use "fix error" in place of undefined
21:14:20 <kadoban> Hijiri: Haha, probably.
21:15:32 --- mode: glguy set -bbbb *!*pc@197.123.57.* *!*@197.121.122.177 *!*rau@87.117.225.* *!~Kristina2@95.141.20.196
21:15:32 --- mode: glguy set -bbbb *!*kvirc@64.116.185.* *!*6ca17b24@*.108.161.123.36 *!*@80.30.148.77 *!*@90.174.1.162
21:15:32 --- mode: glguy set -bb *!*@80.30.151.134 *!*@80.30.151.134nil
21:18:20 --- mode: glguy set -bbbb *!~neneng@31.217.* *!*Airwrecka@gateway/web/cgi-irc/kiwiirc.com/x-wbdovqowfuniyrdl *!*42b075c0@*.66.176.117.192 *!~fustirge@84.78.23.189
21:18:20 --- mode: glguy set -bbbb *!*@187.253.149.74 *!*@cpe-142-129-50-121.socal.res.rr.com *!~awrbgh@197.195.131.203 *!*@37.221.169.150
21:18:20 --- mode: glguy set -bbbb *!~Zektor7@187.153.55.92 *!*Stella21@95.141.20.* *!~Energy@25.104-66-87.adsl-dyn.isp.belgacom.be *!~tinytim@200.79.255.125
21:18:20 --- mode: glguy set -bbbb *!*@cha92-4-82-224-226-31.fbx.proxad.net *!*@37.221.173.229 *!*@67.221.255.* *!~adamo0@abkp235.neoplus.adsl.tpnet.pl
21:18:21 --- mode: glguy set -bbbb *!b5b1ef75@gateway/web/freenode/ip.181.177.239.117$#haskell-ops *!*@5.254.104.50$#haskell-ops *!~ircap@90.174.0.172 *!~some1@178.115.131.7.wireless.dyn.drei.com
21:18:22 --- mode: glguy set -bbbb *!*@79.141.162.19 *!~Anastasia@95.141.20.196 *!*EOD@*.fecalsmear.powerbrownie.com.br *!*@denuncia.anonima.empleosonora.gob.mx
21:18:23 --- mode: glguy set -bbb *!*suaporraq@200.79.255.* *!~ircap@90.174.0.162 *!*6010016@2.121.55.*
21:19:59 <jle`> whitesn: start with your patterns :)
21:20:12 <jle`> explode [] c = ???
21:20:17 <jle`> explode (x:xs) c = ???
21:21:03 <arkeet> I'd just use some splitting function someone else already wrote.
21:21:26 --- mode: glguy set -bbb *!*@185.25.84.104 *!*@122-62-237-10.jetstream.xtra.co.nz *!~Chris@122-59-82-97.jetstream.xtra.co.nz
21:22:07 <jle`> i think the question is phrased as one of curiosity
21:22:34 --- mode: glguy set -bbbb *!*@cpe-108-185-218-246.socal.res.rr.com *!*@162.sub-174-253-241.myvzw.com *!*@ip72-207-16-214.sd.sd.cox.net *!*@93.89.92.12
21:22:49 <whitesn> jle`: i tried, but I confused of the right associative things :(
21:22:50 <dmj`> > words "foo bar baz"
21:22:51 <lambdabot>  ["foo","bar","baz"]
21:23:04 --- mode: glguy set -bbbb *!*@128.204.196.111 *!*@2602:306:cd2c:320:d227:88ff:fe57:5a7c *!*@gateway/web/freenode/ip.82.25.201.214 *!~trainengi@ip68-8-31-14.sd.sd.cox.net
21:23:38 <jle`> whitesn: what do you mean?
21:24:16 <whitesn> let's say i want to do something like ('a':'b':'c':[]):('d':'e':'f':[]):[]
21:24:34 <whitesn> but in recursive calls i can't just add bracket as i would like too
21:24:50 <whitesn> so it will do the most left []:[] first instead of the left one
21:24:58 <whitesn> most right*
21:26:54 <SleepyPikachu> whitesn: I think you need an accumulator
21:27:40 <sgr> any ideas for something that does (Monad m) => (a->b) -> (b -> m c) -> m (b->c)
21:28:48 <sgr> ive come up with: \f g -> return . join $ g . f    which seems to work but complains when I add the type signature
21:29:18 <kadoban> sgr: Was that first one supposed to be (b -> c) I hope?
21:29:40 <sgr> oops last one was supposed to me m (a -> c)
21:30:28 <lpaste> glguy pasted “explode with foldr” at http://lpaste.net/125854
21:32:11 <arkeet> sgronblo: such a thing doesn't exist.
21:32:14 <SleepyPikachu> sgr: Forgive my ignorance, isn't that fmpa?
21:32:16 <arkeet> sgr
21:32:51 <arkeet> you can't go from (a -> m b) to m (a -> b)
21:41:33 <Maxdamantus> (String -> IO ()) -> IO (String -> ())
21:42:07 --- mode: ChanServ set -o glguy
21:45:15 <sgr> arkeet: why does this work? http://lpaste.net/125855
21:45:47 <arkeet> :t let joinF f g = return . join $ g . f in joinF
21:45:48 <lambdabot> Monad m => (a1 -> b) -> (b -> a1 -> a) -> m (a1 -> a)
21:45:54 <arkeet> that's a pretty different type.
21:46:14 <arkeet> (a -> b) -> (b -> a -> c) -> m (a -> c)
21:47:25 <sgr> it is, but im passing it an a->b and an b -> m c
21:47:38 <arkeet> yes, that only works for m = (a -> )
21:47:45 <arkeet> hence the inferred type
21:48:22 <shachaf> (e ->) is pretty special. You can write (a -> (e ->) b) -> (e ->) (a -> b)
22:04:10 <sgr> i dont quite get it, but im glad it makes sense to someone
22:05:06 <Maxdamantus> sgr: can you see that the type I said is nonsense?
22:09:22 <sgr> yes, and it closely mirrors what i was trying to acheive
22:10:06 <Maxdamantus> Indeed. If you try to use `m` as you are, you're saying it works for all Monads m, not just one.
22:10:13 <Maxdamantus> including IO
22:14:16 <sgr> so the only way that type signature is possible is if m = (e ->)
22:14:34 <Maxdamantus> Yes.
22:15:05 <Maxdamantus> Well, you could come up with different alternatives for `m`, but they'd have different definitions.
22:15:20 <sgr> ok
22:15:25 <lexi-lambda> For all those who are interested and/or saw the reddit post, I wrote a Day 3 for my thing. http://lexi-lambda.github.io/learning-haskell/day-3.html
22:15:33 <Maxdamantus> it works for readers.
22:17:19 <carter> lexi-lambda: oh, i was gonna point out that your remark about ghc-mod at the start was kinda odd 
22:17:35 <lexi-lambda> carter: Yeah?
22:17:36 <carter> got a bit side tracked c'ause i didn't wanna get sucked into a complicated thread 
22:17:47 <carter> ghc-mod isn't ghc
22:17:55 <carter> though your opening remarks seem to imply such
22:18:14 <carter> at least when i read it initially
22:18:15 <lexi-lambda> Oh, I know ghc-mod isn't ghc. Lemme reread and see if I implied that there.
22:18:52 <lexi-lambda> Oh, yeah, that actually has to do with an interaction between ghc-mod and ghc.
22:18:59 <lexi-lambda> I didn't really explain that in the post, though.
22:19:08 <carter> it seemed to imply that a sorta of "ghc-mod is essential", rather than "one of the popular vim/emacs/etc plugins  is powered by ghc mod"
22:19:44 <lexi-lambda> Honestly, since the series is targeted at Haskell programmers, I didn't really feel the need to explain that, I guess.
22:19:56 <carter> i thought it was targetting 3rd parties
22:20:12 <carter> the reason why 1.22 +  ghc -mod broke was ghc-mod silently depending on internal details of cabal's private formats
22:20:20 <carter> and those private formats changes
22:20:54 <lexi-lambda> You're right, but apparently ghc-mod interfaces with ghc in some way that reads cabal's private formats, and cabal switched to a binary format from plaintext.
22:20:59 <lexi-lambda> Honestly, I don't know the details.
22:21:13 <lexi-lambda> I just read the thread on GitHub and decided it wasn't worth my time to figure out.
22:21:18 <carter> i'm telling you the details
22:21:19 <carter> :)
22:21:29 <carter> yeah
22:21:44 <carter> i just am quibbling over detils
22:22:56 <f|`-`|f> you are learning
22:22:59 <f|`-`|f> kinda jealous
22:24:07 <lexi-lambda> Hmm?
22:30:21 <user104> Hi all. Is learning Haskell for web developement a good idea?
22:30:37 <Yaniel> learning haskell is always a good idea
22:31:00 <user104> I've Python and C bacground, Haskell is going to be very different.
22:31:11 <Yaniel> (though it does weird things to you if you ever want to use another language again)
22:31:13 <Yaniel> yes
22:31:21 <Hijiri> what if a sadist puts a bomb collar that will activate if you study haskell
22:31:28 <Hijiri> I would say it's a bad idea in that scenario
22:31:38 <glguy> Why's that?
22:31:39 <MP2E> purity or death! *explodes*
22:31:57 <Hijiri> if you die you don't get to use haskell
22:32:08 <glguy> Oh, on me. I see!
22:32:20 <Maxdamantus> if you live you don't either.
22:32:33 <Hijiri> well, the sadist might take it off, or the police might find you
22:33:31 <glguy> back to topic; Learning Haskell is a good idea if you're asking the people in this channel. It might not be the fastest way to solve your particular web problem off the bat, though
22:34:19 <Yaniel> I'd say it is a good idea anyway, it gives you a totally new way to look at things
22:34:46 <Yaniel> so if you have the time to spare...
22:35:03 <dmj`> user104: it's a great idea, but don't expect to be productive until you at least understand monad transformers. 
22:35:53 <user104> Alright thanks guys. I'll start reading some books on Haskell.
22:36:08 <user104> What resouces do you suggest for learning Haskell?
22:36:18 <user104> resources*
22:37:25 <dmj`> learn you a haskell, parallel and concurrent programming in haskell, typeclassopedia, cis194, real world haskell, write you a scheme in 48 hours
22:37:51 <dmj`> reddit
22:38:18 <dmj`> user104: https://github.com/bitemyapp/learnhaskell
22:40:55 <user104> Thanks everyone. I'll leave this irc channel and join #haskell-beginners instead. :D
22:41:22 <shachaf> Beginners are find in this channel.
22:41:45 <shachaf> fine
22:41:47 <glguy> found
22:42:12 <arkeet> @where learnhaskell
22:42:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:55:42 <jle`> in this channel, we are all found
22:56:15 <c_wraith> shachaf is the foundest
22:56:20 <c_wraith> Or was that founder?
23:00:20 <arkeet> wow, I didn't know ghci tab completion in strings completed file paths 
23:00:43 <shachaf> I think file paths is the default thing to complete if it can't figure out anything better.
23:00:47 <siddhu> what's the difference between (**) and (^) ?
23:00:58 <jle`> siddhu: (^) is iterated multiplication
23:01:16 <jle`> (**) is exponentiation with two things of the same type
23:01:30 <jle`> `x^2` is "expanded out" to 2*2
23:01:42 <jle`> if you look at the source
23:01:44 <jle`> @src (^)
23:01:44 <lambdabot> x ^ 0            =  1
23:01:45 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:01:45 <lambdabot>   where f _ 0 y = y
23:01:45 <lambdabot>         f x n y = g x n
23:01:45 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
23:01:46 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:01:48 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:01:52 <arkeet> :t (^)
23:01:53 <lambdabot> (Num a, Integral b) => a -> b -> a
23:01:55 <arkeet> :t (**)
23:01:56 <lambdabot> Floating a => a -> a -> a
23:01:58 <glguy> (^) is for non-negative exponents, (^^) allows negative exponents, (**) allows floatingpoint exponents
23:02:11 <jle`> that's why the second parameter of (^) takes an Integral, and not something of the same type
23:02:30 <arkeet> :t (^^)
23:02:31 <lambdabot> (Integral b, Fractional a) => a -> b -> a
23:02:39 <arkeet> Fractional because it needs division for negative exponents.
23:02:53 <jle`> (2.3 :: Double)^2 would be identical to having (2.3 * 2.3).  but (2.3 :: Double)**2 would be having your machine/computer execute its exponentiation operation on Doubles
23:03:25 <jle`> you can't implement (^) for your own type.  it's basically just iterated multiplcation.  but you can implement (**) for your own type
23:03:51 <siddhu> Hmm. Is (**) more efficient than (^) considering it's executed by the machine?
23:04:18 <shachaf> (^) is also executed by the machine. Every Haskell program you run on the machine is executed on the machine.
23:04:43 <siddhu> > 2000 ** 2000
23:04:44 <lambdabot>  Infinity
23:05:00 <Hijiri> what if I'm manually rewriting expressions
23:05:13 <Hijiri> wait
23:05:15 <Hijiri> nevermind
23:05:19 <jle`> siddhu: you need to compare 2000 ** 2 on your machine and 2000 * 2000 on your machine
23:05:25 <Yaniel> > 2 ** 0.5
23:05:26 <lambdabot>  1.4142135623730951
23:05:32 <shachaf> I would imagine that for Doubles (x^2) is generally going to be faster to compute than (x**2), but I have no idea. You can measure it.
23:05:33 <jle`> 2000 ** 3 vs. 2000 * 2000 * 2000, etc.
23:05:43 <jle`> can't really make any general statements
23:05:46 <Yaniel> > 2 ^ 0.5
23:05:47 <lambdabot>  Could not deduce (GHC.Real.Integral b0)
23:05:47 <lambdabot>    arising from a use of ‘GHC.Real.^’
23:05:47 <lambdabot>  from the context (GHC.Num.Num a)
23:06:09 <shachaf> Please test lambdabot in /msg unless you're demonstrating something to the channel.
23:07:03 <Yaniel> okay
23:07:22 <siddhu> Hmm. Neat. (**) just returns infinity on big numbers.
23:07:33 <jle`> it depends on the type
23:08:02 <carter> and on floats, theres like 3 different versions of ** 
23:08:12 <arkeet> there are?
23:08:14 <carter> not just ** and ^
23:08:23 <arkeet> well ^ is different.
23:08:26 <carter> yes
23:08:28 <carter> 3 :)
23:08:45 <arkeet> I don't consider ^ or ^^ to be a version of **.
23:09:13 <carter> idk
23:09:34 <jle`> it depends, are we talking about ieee floats and machine floats, or the Float haskell abstract data type
23:09:46 <carter> IEE Flaot
23:09:55 <carter> jle`: haskell Float ISSS ieee float
23:10:11 <arkeet> nah, it's a boxed IEEE float.
23:10:49 <jle`> not the difference i was talking about, but :P
23:10:50 <carter> ^ is IEEE pown on floats
23:11:09 <carter> i forget if ** corresponds to which mix of pow and powr
23:11:56 <carter> powr(x,y) == exp(y *  log (x))
23:15:25 <siddhu> ghc handles floats differently from other languages right? I remember it doesn't use FFI marshaling.
23:16:04 <shachaf> What is different?
23:19:16 <carter> really should be the same 
23:19:25 <carter> siddhu: the ffi totally supports Float and Double correctly
23:20:53 <arkeet> it doesn't use ffi stuff for pure float/double code.
23:20:56 <arkeet> I'm pretty sure.
23:22:25 <siddhu> Found it: https://ghc.haskell.org/trac/ghc/ticket/2209#comment:3
23:26:01 <carter> arkeet: yeah, its all native
23:26:28 <carter> siddhu: i can explain that bug if you want...
23:26:57 <carter> arkeet: if it was ffi it'd be too slow
23:27:11 <siddhu> carter: that would be nice.
23:27:19 <carter> siddhu: on x86 integers and floats live in different registers
23:27:59 <carter> so when unsafe coerce is acting on unboxed ints and float/doubles, it has to know to copy info from one type of cpu register to another
23:28:03 <carter> thats what that patch is about
23:32:13 <siddhu> carter: so, basically unsafeCoerce# assumes that the register sizes are equal, and hence cannot be used?
23:32:43 <carter> siddhu: its not about register size
23:32:49 <carter> its physically different registers
23:33:32 <carter> that ticket got fixed so it'd work
23:33:46 <arkeet> it looks like just a documentation fix.
23:33:54 <carter> oh yeah
23:33:54 <carter> nvm
23:34:08 <carter> yeah, basically to move between those two register types you have to read/write to memory
23:35:53 <siddhu> Just to clarify, what does Cmm mean?
23:36:05 <arkeet> c--
23:36:12 <dmj`> c minus minus
23:36:18 <shachaf> Cmm and C-- are different, confusingly.
23:36:27 <pharaun> oh they are?
23:36:30 <shachaf> @google cmm haskell
23:36:31 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Cmm
23:36:33 <pharaun> i always figured they were the same
23:36:39 <arkeet> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Cmm
23:36:52 <arkeet> I guess it's slightly different.
23:36:54 <wolftune> Arg, I get a "not in scope" error with cabal build for a plain static file that I know is there
23:37:03 <pharaun> anyway ahh k
23:37:16 <wolftune> I can literally use a different png file, but the one I want in the same directory says "not in scope"
23:37:19 <wolftune> what is going on??
23:37:39 <shachaf> What is a "not in scope" error?
23:38:56 <wolftune> not in scope generally means something isn't imported or available
23:39:16 <shachaf> Yes, I know what it generally means.
23:39:31 <wavewave> hello
23:39:33 <shachaf> I guess I should ask you to @paste your full error and full relevant code and directory structure and so on.
23:39:36 <shachaf> hi wavewave
23:39:45 <wolftune> Not in scope: ‘img_patrons_png’
23:39:47 <wolftune>     In the splice: $(widgetFile "projects")
23:39:48 <wavewave> shachaf: hi!
23:39:48 <wolftune> that's it
23:40:11 <wavewave> shachaf: Are you in Bay Area?
23:40:17 <wolftune> literally I change to img_s_png (another file in the same dir) and it works
23:40:17 <shachaf> Yes.
23:40:25 <wavewave> cool.
23:40:37 <shachaf> wolftune: Well, that's not your full code or full error, but it says something.
23:40:48 <wavewave> I am thinking about participating in BayHac this year.
23:40:50 <shachaf> "Not in scope" isn't saying that the file doesn't exist, it's saying the Haskell identifier doesn't exist.
23:41:07 <wolftune> right
23:41:09 <wolftune> I get that
23:41:10 <shachaf> So find out how img_s_png is defined.
23:41:19 <wolftune> so…
23:41:22 <wolftune> this is a Yesod app
23:41:27 <wolftune> and the context is
23:41:38 <wolftune> @{StaticR img…}
23:41:38 <lambdabot> Unknown command, try @list
23:41:38 <shachaf> I don't know anything about Yesod, and I don't have access to your code. I just know Haskell. :-)
23:42:09 <wavewave> shachaf: I assume that it will happen in June 12? do you know something about that?
23:42:10 * hackagebot eigen 1.2.2 - Eigen C++ library (linear algebra: matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-1.2.2 (OlegSidorkin)
23:42:11 <wolftune> it's pretty simple, it's just a static resource that points to a file in the static directory
23:42:25 <wolftune> I can actually run the app and it works with the correct file
23:42:32 <wolftune> if I just run the version built before
23:42:39 <shachaf> #yesod might be able to help you with Yesod details. But it sounds to me like you should find out how img_s_png is defined.
23:43:01 <shachaf> wavewave: My calendar says Jun 12-14, tentatively. But I don't know the details.
23:43:14 <shachaf> jfischoff is in NY so other people will be needed to organize it.
23:44:11 <wavewave> shachaf : cool! thanks! and c u there soon!
23:44:23 <shachaf> wavewave: mzero would probably be the best person to ask.
23:44:36 <wavewave> yes. I guess so.
23:45:09 <wavewave> wolftune: I may answer your question. 
23:45:17 <wavewave> wolftune: what was the problem?
23:45:30 <wolftune> wavewave: simple situation, I already have a workin thing…
23:45:34 <wavewave> Yesod.Static magic.
23:45:36 <wolftune> I just changed to a new png image
23:45:48 <wolftune> but then it won't build
23:45:51 <wavewave> wolftune: with the same file name?
23:46:00 <wolftune> no, different file name
23:46:15 <wolftune> and I have tried other file names… and all older images work in the same place
23:46:16 <wavewave> then you probably need to build from Foundation.hs
23:46:31 <wavewave> touch Foundation.hs 
23:46:38 <wavewave> and then build. 
23:46:38 <wolftune> ah
23:46:42 <wolftune> weird
23:46:45 <wolftune> will try that
23:46:46 <wavewave> that's template haskell magic. 
23:46:57 <wavewave> let me see my code. wait. 
23:46:58 <wolftune> I get it, I needed to force it to rebuild that
23:47:26 <wolftune> I tried cabal build and cabal install… install actually works without error, but cabal build on its own fails
23:48:10 <carter> shachaf: he's in ny?
23:48:17 <wavewave> do you have this line: staticFiles "static" ?
23:48:22 <wavewave> carter: hi!
23:48:37 <carter> ]hey
23:48:42 <carter> wavewave: hows physics?
23:48:53 <narendraj9> I need to have a matrix and the most frequent operation on it is swapping two columns or rows, what would be the most efficient way to do this?
23:49:22 <wolftune> wavewave: no I don't have that line
23:49:38 <wolftune> wavewave: and I tried saving Foundation.hs and it still failed via yesod devel
23:49:51 <wavewave> carter: nothing much. in fact, I am leaving physics :-P 
23:49:55 <shachaf> I think #yesod might be better for this, since it sounds pretty Yesod-specific.
23:50:08 <carter> wavewave: congrats and condolences! whats next?
23:50:26 <wolftune> shachaf: yeah, probably
23:50:26 <wavewave> carter: some business? heh
23:51:13 <wavewave> wolftune: anyway. try to find the staticFiles function (it's template haskell function.) and recompile the module that contain that line.
23:51:26 <wavewave> wolftune: that thing is defined in Yesod.Static.
23:51:38 <wolftune> wavewave: how do I force a particular file to recompile?
23:52:24 <wavewave> wolftune: well, in my case, I just touch it and cabal build
23:52:46 <wavewave> but I assume you are using some yesod infrastructure.
23:53:01 <wolftune> found it in Settings.StaticFiles
23:53:07 <wavewave> ah. there.
23:53:37 <wavewave> yesod devel should catch it, but I don't know. 
23:53:57 <wolftune> yeah, yesod devel just calls cabal build
23:53:59 <wavewave> I actually do not use "yesod devel" script .  
23:54:17 <wavewave> I am doing things explicitly by my hand. heh.. old fashioned. 
23:54:41 <wavewave> carter: are you now in east coast?
23:54:46 <wolftune> wavewave: sure, I reproduced the issue with just cabal build originally anyway
23:54:47 <carter> wavewave: currently heah
23:54:52 <carter> *yeah
23:55:10 <wavewave> wolftune: ok.. then.. I am not sure.. 
23:55:15 <wolftune> wavewave: TADA! Thank you!
23:55:40 <wavewave> wolftune: it worked?
23:55:44 <wolftune> yup
23:55:53 <wolftune> touching that file was the issue
23:56:04 <wavewave> cool. glad to hear that I helped you ;-)
23:56:41 <wolftune> goodnight now
23:56:44 <wolftune> cheers
23:56:53 <wavewave> wolftune: you too!
23:57:33 <shachaf> "The mtime was too long ago", said Tom touchingly.
